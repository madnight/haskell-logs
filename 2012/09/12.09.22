00:08:34 * hackagebot scrypt 0.3.4 - Stronger password hashing via sequential memory-hard functions.  http://hackage.haskell.org/package/scrypt-0.3.4 (FalkoPeters)
00:18:34 * hackagebot aeson-pretty 0.6.1 - JSON pretty-printing library and command-line tool.  http://hackage.haskell.org/package/aeson-pretty-0.6.1 (FalkoPeters)
00:20:26 <astry_> hi
00:20:35 <astry_> can i somehow express this code more succintly? http://dpaste.com/804367/
00:23:34 * hackagebot hedis 0.6.1 - Client library for the Redis datastore: supports full command set,  pipelining.  http://hackage.haskell.org/package/hedis-0.6.1 (FalkoPeters)
00:26:12 <JoeyA> astry_: RecordWildCards can help a little
00:26:54 <JoeyA> sPos <- newIORef startIdx; sFromTop <- newIORef 0; let state = State{..}
00:27:13 <JoeyA> The {..} syntax captures variables in scope that name members of State.
00:48:59 <solomatov> Recently I learned what lenses are. I wonder, if there're structures like them which support incremental changes.
00:49:46 <lightquake> what do you mean, incremental?
00:50:11 <solomatov> I.e. instead of get : a -> b  and set : a -> b -> a we have { get a -> b; update1 a -> ac -> bc; update2  a -> b -> bc -> a; ...}
00:50:55 <solomatov> I thinking about using them for editing large data structures and I naive approach will lead to performance problems.
00:51:34 <solomatov> i.e. concrete view is a model, and abstract view is a gui
00:54:54 <solomatov> in imperative code this is easy to implement, we can create a model which support listeners with fine grained events. I wonder how this can be done in purely functional settings.
01:48:36 * hackagebot doctest 0.9.1 - Test interactive Haskell examples  http://hackage.haskell.org/package/doctest-0.9.1 (SimonHengel)
02:18:53 <jtza8> Am I right in thinking that the Haskell philosiphy is that unintended side-effects are evil, not side-effects as such?
02:20:18 <fmap> isn't that just common sense?
02:21:22 <jtza8> Yeah, actually...
02:23:16 <jtza8> Just strange how things like infered static typing, lazyness and purity aren't ubiquitous.
02:26:49 <Saizan> it's also that you shouldn't be too happy about intending side-effects
02:29:16 <astry_> @tell JoeyA thanks for the info on RecordWildCards
02:29:16 <lambdabot> Consider it noted.
02:29:21 <jtza8> Saizan: True, but with something like a GUI, it's unlikely that you could get away without them.
02:30:40 <Iceland_jack> jtza8: it's about trying to avoid unneeded side-effects and also keeping a strict separation between pure code and code with side effects
02:30:56 <Iceland_jack> Which is applicable in almost every programming language
02:33:09 <Saizan> jtza8: not without entirely
02:33:48 <jtza8> You're both right, it just took me a while to realise what all this truely means.
02:35:34 <astry_> hey guys
02:36:43 <astry_> i have written a key press handler in my gtk2hs application. it takes about 2 seconds to execute. During that time, if i press and hold the button, it repeats and queues up further executions of this handler. how can i prevent this from happening? I would like input to be ignored until the key handler has finished.
02:37:35 <merijn> jtza8: tbh, I'm not sure about the universal value of laziness. (as in, I can imagine reasons for wanting a non-lazy language, I cannot really imagine arguments against purity and static typing)
02:38:38 * hackagebot string-conversions 0.2.1 - Simplifies dealing with different types for strings  http://hackage.haskell.org/package/string-conversions-0.2.1 (SoenkeHahn)
02:38:58 <Iceland_jack> merijn: no arguments against static typing?
02:39:44 <merijn> Ok, back to my type hackery quest of yesterday. If I want to define a Functor instance for (Foo (g a)) for specific g's, is there a way I can avoid newtype wrapping a la Data.Functor.Compose
02:40:15 <merijn> Iceland_jack: Given a sufficiently pleasant type system, no. I can think of plenty of arguments against Java/C like type systems, of course
02:40:53 <Iceland_jack> Si
02:41:12 <Iceland_jack> (didn't mean to send that)
02:41:48 <Iceland_jack> When you say "sufficiently pleasant type system", are you referring to Haskell's?
02:42:41 <Ferdirand> you tolerate static code, why would you not tolerate static typing ?
02:42:51 <merijn> So far it has been, although personally I would like to keep moving to something more Agda like (or maybe even Epigram!)
02:43:26 <astry_> merijn: tbh i really like haskell's static typing, it helps a lot in my work
02:43:30 <Iceland_jack> Almost every decision in language design has pros and cons
02:43:39 <astry_> merijn: as opposed to being a hindrance like in many other languages
02:44:11 <merijn> astry_: Yes, I used to think I hated static typing, then I learned Haskell and realised I hate lousy implementations of static typing ;)
02:44:37 <nschoe> Hi fellow Haskellers !
02:45:37 <typoclass> hello
02:46:00 <nschoe> I'd like to take some photos from my webcam with Haskell, and I'd like to use some opencv bindings. Like cv-combinators, which is an interface to HopenCV if I understand it well.
02:46:29 <nschoe> But when I tried ot install cv-combinators, it failed because HopenCV would not install. Here is the error I get when I issue 'cabal install hopencv': http://hpaste.org/75109
02:46:42 <nschoe> Any workaround?
02:47:18 <nschoe> I am running Archlinux with XFCE in case it matters. And I installed cheese and it does work: I can see iimages from my webcam
02:47:34 <ClaudiusMaximus> nschoe: I'd like the same, eventually (too many other projects) - but my guess is you have a "wrong" version of OpenCV installed (probably too new)
02:48:28 <ClaudiusMaximus> nschoe: you might try the v4l bindings i wrote a while ago if you need images in your program asap, but that doesn't help if you need opencv
02:48:33 <ClaudiusMaximus> *v4l2
02:48:44 <nschoe> ClaudiusMaximus, ah... this is something I had not thought about.
02:49:00 <ClaudiusMaximus> nschoe: they might also have bitrotted in the meantime, and I'll have no time to fix them until mid-October...
02:49:30 <astry_> merijn: i like that in haskell static typing solves itself..
02:49:49 <nschoe> ClaudiusMaximus, I don't *need* opencv. Actually the idea is: the webcam is the be mounted on a robot. And we will "just" take photos with the webcam, try to find an object on screen. So basically I just need to be able to take photos. It can be with smth else than openCV
02:49:49 <astry_> merijn: that's the #1 reason why i like it :)
02:49:57 <astry_> now if there were a vim plugin to automatically annotate types...
02:50:00 <astry_> that would be great.
02:50:03 <typoclass> nschoe: yes, looks to me like some kind of version mismatch. check which opencv version is expected by your version of hopencv (let's hope that's documented in some install guide or something ...)
02:50:35 <ClaudiusMaximus> (giving an invited artist talk and performance in Paris on 2nd October, 3 weeks after discharge from hospital where there was no computerz let alone internetz, is quite a challenge to prepare...)
02:51:07 <nschoe> typoclass, I have installed opencv with pacman -S opencv (which installs the latest version available obviously), BUT in the hackage page of HopenCV, it is said that we have to install openCVblah blah and they gime a sourceforge link to manually download and install opencv. Should I give it a try?
02:51:34 <ClaudiusMaximus> nschoe: try the v4l2 stuff first i reckon, if you just need images quick
02:52:29 <typoclass> nschoe: hm yeah, that sounds promising
02:52:30 <nschoe> ClaudiusMaximus, okay, I'll try that, then. Is this http://hackage.haskell.org/package/v4l2 ?
02:52:56 <ClaudiusMaximus> nschoe: yes
02:53:12 <nschoe> ClaudiusMaximus, ok. Thanks, I'll try that right away.
02:53:15 <ClaudiusMaximus> nschoe: if you set up your cabal to build documentation, it'll be useful
02:53:31 <ClaudiusMaximus> otherwise cabal unpack and inspect the sources
02:53:47 <nschoe> typoclass, thanks for the hlep, I'll try the v4l2 first, and if I don't succeed I'll try installing manually opencv
02:53:50 <nschoe> ClaudiusMaximus, And this is not a good thing?
02:53:56 <typoclass> nschoe: yes, good plan
02:54:09 <nschoe> ClaudiusMaximus, ho no you meant otherwise I'll have to unpack and inspect the soruce myself, ok ^^
02:54:36 <ClaudiusMaximus> there's also http://hackage.haskell.org/package/v4l2-examples which is pre the high level v4l2 bindings, and needs a new version written updated
02:54:40 <ClaudiusMaximus> (this is mostly note to self)
02:55:05 <ClaudiusMaximus> I should be around for the next ~3 hours (though sometimes afk) if you need assistance, then i have to go out
02:55:14 <nschoe> ClaudiusMaximus, so you're saying the ydefinitely won't work now, or should I give it a try anyway?
02:56:35 <ClaudiusMaximus> nschoe: try the v4l2, and an example that i'm about to find and hpaste from my laptop which has a webcam
02:57:09 <nschoe> ClaudiusMaximus, ok ok. But... sorry to appear a newbie, how cna I set up my cabal to build documentation as well?
02:57:35 <astry_> merijn: you know when static typing in haskell pisses me off? only one situation
02:57:45 <astry_> having to type fromIntegral everywhere
02:58:39 <merijn> astry_: Yeah, some library parts rely too much on explicit "Integer"/"Int" in their signatures
03:01:48 <Twisol> when that comes up, I just do something like: let double x = fromIntegral x :: Double in (double)42
03:02:03 <Twisol> hooray for abuse of syntax
03:02:11 <ClaudiusMaximus> nschoe: put documentation: true  in your .cabal/config
03:03:08 <nschoe> ClaudiusMaximus, yeah sorry I realized this just after I posted my message -_- v4l2 is currently installing.
03:03:16 <astry_> merijn: i'm currently working with no libraries, just basic haskell
03:04:04 <astry_> http://dpaste.com/804403/ merijn
03:04:53 <astry_> my image viewer is really coming along, i need to figure how to resize the window and then it's almost like it's full featured ;)
03:05:33 <astry_> oh yeah, and fit-to-window would be nice too..
03:05:39 <astry_> i think that's all though :))
03:05:48 <nschoe> ClaudiusMaximus, v4l2 and v4l2-examples installed sucessfully. Did you find your example on your computer, and if so could you hpaste it? i'd be very happy to finally have my webcam working ah ah.
03:06:07 <merijn> astry_: do you have the surrounding code? i.e. where things like imgWidth/imgHeight come from?
03:06:16 <hpaste> ClaudiusMaximus pasted “v4l2-capture ppm to stdout” at http://hpaste.org/75110
03:06:26 <merijn> I suspect you can get by with many fewer fromIntegrals
03:06:59 <merijn> astry_: Actually, I suspect you just don't want to use /
03:07:09 <bizman> oh my gods
03:07:14 <bizman> I am banned from so many
03:07:16 <bizman> its not fair
03:07:30 <merijn> astry_: This "floor $ fromIntegral x / y" probably means you want div instead :)
03:07:35 <nschoe> Thanks6^
03:07:37 <hpaste> ClaudiusMaximus annotated “v4l2-capture ppm to stdout” with “v4l2-capture to GLUT with historgram overlay” at http://hpaste.org/75110#a75111
03:07:41 <merijn> > (4 `div` 2, 5 `div` 2)
03:07:42 <lambdabot>   (2,2)
03:08:09 <merijn> astry_: div is integer division, / is floating point division :)
03:08:26 <ClaudiusMaximus> :t (/)
03:08:27 <lambdabot> forall a. (Fractional a) => a -> a -> a
03:08:35 <merijn> Fractional, I guess
03:08:44 <Nereid> and div is for Integral
03:08:49 <merijn> Same difference to me :p
03:08:49 <merijn> :t div
03:08:50 <lambdabot> forall a. (Integral a) => a -> a -> a
03:09:19 <Sculptor> > (/) 5 2
03:09:20 <lambdabot>   2.5
03:09:20 <ClaudiusMaximus> :t quot   -- if you like your rounding different, or something
03:09:22 <lambdabot> forall a. (Integral a) => a -> a -> a
03:09:26 <nschoe> ClaudiusMaximus, what does 'ppm' means ?
03:09:41 <Sculptor> parts per million, nschoe
03:09:43 * Digit spots a HaRe and chases it, wondering why no one told him HaRe existed http://www.cs.kent.ac.uk/projects/refactor-fp/hare.html
03:09:43 <Nereid> ppm is an image format
03:09:47 <ClaudiusMaximus> nschoe: it's a low level image format
03:10:01 <Sculptor> ah, my bad
03:10:19 <ClaudiusMaximus> nschoe: a short ascii header followed by raw raster data
03:10:26 <ClaudiusMaximus> so pipe it to /dev/null if you don't want to flood your terminal :)
03:10:26 <Sculptor> just like bmp
03:11:09 <merijn> ppm is ASCII, though. bmp is binary
03:11:53 <Sculptor> yeah
03:12:03 <Sculptor> bmp also supports compression
03:12:03 <nschoe> ok
03:12:13 <nschoe> Thanks ^^
03:12:29 <nschoe> I'll read your example, and the documentation and hopefully get smth to work^^
03:12:30 <Sculptor> 4-bit and 8-bit rle/huffman
03:12:43 <ClaudiusMaximus> http://hackage.haskell.org/package/pnm is my pacakge for ppm and variants
03:13:27 <ClaudiusMaximus> nschoe: appologies for the code quality of the hpastes and complete lack of inline documentation, they were more quick hacks to get something working than intended as serious tutorial examples
03:13:34 <leventov> ghci>tryJust ((\e -> Just $ show e) :: ArithException -> Maybe String) (return (1 `div` 0)) :: IO (Either String Int)
03:13:37 <leventov> Right *** Exception: divide by zero
03:13:52 <leventov> why not LEFT *** Exception: divide by zero ?
03:14:15 <merijn> leventov: Return puts something in the Right constructor
03:14:37 <nschoe> ClaudiusMaximus, yeah I can totally understand that! I'm glad already that you gave me this piece of code. It looks.. though to undertsand but I'll try. ANyway, since what I want doesn't seem too much coimplexe (just taking photos for now), I hope I should manage... I hope... nothing is sure wiht me ^^
03:14:44 <merijn> leventov: (Either a) is a monad, so return can only affect the b side of "Either a b"
03:15:06 <Saizan> leventov: the exception is triggered after tryJust has already returned, so it doesn't get catched
03:15:09 <ClaudiusMaximus> leventov: needs IO to catch exceptions, because you never know which exception you'll get with non-strict evaluation, and you might also like "evaluate" and/or deepSeq to sledgehammer your computations so stuff doesn't leak
03:15:12 <Saizan> merijn: that return is from IO
03:15:22 <merijn> oh, wait
03:15:30 <merijn> I hate parsing code on single lines >.>
03:15:37 <Shapeshifter> I'm reading learn you a haskell and it says that a value like 5 is deterministic, while [3,8,9] is non-deterministic. Then it says something like (*) <$> [1,2,3] <*> [10,100,1000] produces [10,100,1000,20,200,2000,30,300,3000], again a non-deterministic value. Why are they called non-deterministic, though? I don't see any non-determinism here, everything is determined depending on what I put into the lists...
03:15:53 <Saizan> leventov: try with "return $! (1 `div` 0)" instead
03:15:55 <Nereid> Shapeshifter: lists model nondeterminism
03:15:58 <merijn> Saizan: Actually, now that you're here I have another Functor question :p
03:16:28 <Saizan> merijn: the one about composition? i don't think you can
03:16:33 <Nereid> so [3,8,9] represents a number nondeterministically chosen among 3, 8, and 9
03:16:47 <merijn> Saizan: Yeah, that's what I feared. oh well
03:17:03 <leventov> Saizan, thanks
03:17:05 <Nereid> Shapeshifter: it's just an interpretation of lists.
03:17:13 <merijn> Now I need to find a type level way to hack around that >.>
03:17:30 <Saizan> or you could use (fmap . fmap)
03:17:35 <merijn> (Or give up, but that's for losers :D)
03:17:45 <merijn> Saizan: No, because the inner one isn't a functor
03:17:55 <Nereid> what's the question?
03:18:16 <merijn> Nereid: Whether it is possible to define a Functor instance Foo (g a) for specific values of g
03:18:33 <Nereid> what does that mean
03:18:35 <merijn> (Well it is using newtypes, but I wanted without newtype wrapping/unwrapping)
03:18:56 <merijn> Nereid: That "Compose Foo g" is a functor for some specific value of g
03:19:16 <Nereid> I don't know what you mean by
03:19:22 <Nereid> or what Foo is, for that matter.
03:19:23 <ClaudiusMaximus> nschoe: will be afk for ~20mins, feel free to leave lines prefixed with my nick so my client highlights them
03:19:30 <merijn> I can define "instance Functor (Compose Foo G) where" but than all callers of fmap are required to unwrap using getCompose
03:20:15 <Nereid> Foo and G are Functors, and Compose f g x is a newtype for f (g x)?
03:20:21 <merijn> Nereid: The kind of functor is * -> *, right? So suppose I have "Foo :: * -> *" and "G :: * -> *", then logically I can compose them together and get "Compose Foo G :: * -> *"
03:20:27 <Nereid> sure
03:20:30 <merijn> G is not a functor, that's my problem
03:20:38 <Nereid> well how do you expect the composite to be a functor?
03:20:58 <merijn> Data.Functor.Compose already has a functor instance for when f and g are both Functor's
03:21:18 <Nereid> sure
03:21:38 <Nereid> but my question
03:21:47 <merijn> Nereid: Foo is not a functor, G is not a Functor, but "Foo (G a)" *is* a Functor in my case, but I don't think it's possible to define that instance
03:22:02 <Nereid> oh
03:22:15 <Nereid> wouldn't you need some sort of OverlappingInstances or something?
03:22:16 <merijn> (Because the G type in Foo encodes a property of Foo using GADTs)
03:22:55 <merijn> No, there's no overlap. Just type level composition, but that requires newtype unwrapping at every fmap call site, which I find unacceptable :\
03:23:12 <Nereid> yes, there is an overlap, because what if you defined (unlawful) Functor instances for Foo and G later?
03:23:27 <Saizan> Nereid: he can just use a different Compose
03:23:33 <Nereid> ok fine
03:23:39 <Saizan> or a specialized wrapper
03:23:57 <Nereid> so you make a newtype for Foo (G a)
03:24:16 <nschoe> ClaudiusMaximus, okay, no problem. Thanks a lot for your help and motivation with me!
03:24:43 <merijn> Nereid: Which needs to be unwrapped at every fmap call site, in which case I might just as well define the fmap directly without the class
03:24:52 <Nereid> well how else could you possibly do it?
03:25:04 <merijn> Nereid: Well, that was my question :p
03:25:08 <Nereid> I don't think you can.
03:25:18 <Saizan> that was my answer :=
03:25:22 <Nereid> :V
03:25:28 <merijn> Which is what I feared and Saizan said ;)
03:26:19 <merijn> Although I'm not sure that is a fundamental limitation of the type system or just GHC's lack of type level composition/lambda's
03:28:40 <Nereid> well let me try something
03:29:31 <Nereid> yeah, no
03:30:34 <bizman> fameous last werds
03:30:47 <bizman> so gents anyone here run a web startup corp on ahskell?
03:30:50 <bizman> haskell?
03:30:54 <bizman> is happs rockin?
03:30:58 <bizman> or other haskell web stuff?
03:31:01 <bizman> making money
03:31:03 <bizman> ?
03:37:44 <statusfailed> bizman: www.silkapp.com use Haskell I believe
03:45:03 <nschoe> ClaudiusMaximus, for when you come back: I have analyzed your code and I have run it. When I do so I have a loooot of things displaying in my terminal, mostly not displayable characters. I suppose that means the program managed to take some photos from the webcam, right? The thing is: my little LED next to my webcam did not turn on. I don't care if it turns on or not, I just want ot make sure that the pogram actually read from my webcam.
03:45:38 <nschoe> ClaudiusMaximus, I suppose the second section (with GLUT) is supposed to display the images on a window, right? The code is much longer, so I'll need more time to process it. But if you could confirm that, that 'd be good ^^
03:46:52 <nschoe> ClaudiusMaximus, My bad, the lED actually does turn on ^^
03:50:41 <nschoe> ClaudiusMaximus, ok I have the confirmation: I did pipe the result of the program to a (binary) file. And then I opened it.. only yo see a picture. Ah! Thank you for that magnificient piece of code ah!
03:53:43 <merijn> Nereid: Oh, I might know a solution! "class Bar; instance Bar (G a); instance (Bar x) => Functor (Foo x)"
03:54:22 <merijn> oh, wait...no that doesn't work either
03:54:26 <Nereid> and how do you define fmap?
03:54:51 <Nereid> ah yes. that doesn't work at all.
03:55:24 <merijn> Because then fmap would be "f (G a) -> f (G b)" as opposed to "f a -> f b"
03:55:48 <Nereid> no, it's not even that
03:55:50 <Nereid> Foo x has the wrong kind
03:55:56 <Nereid> to be a Functor
03:56:02 <merijn> oh, duh
03:57:28 <Nereid> stupid idea: what if you made some MPTC to replace Functor
03:57:47 <Nereid> say, class Functor' :: * -> * -> * -> *
03:57:56 <Nereid> where
03:58:09 <Nereid> oops, wrong kind.
03:58:13 <Nereid> first * should be (* -> *)
03:58:17 <Nereid> fmap' :: Functor f x y => f x -> f y
03:58:37 <Nereid> and then instance Functor f => Functor' f x y
03:58:49 <Nereid> and write your own instance for Functor' F (G x) (G y)
03:58:55 <Nereid> gross
03:59:49 <Nereid> and would need flexible/overlapping/whatever instances
04:00:33 <Nereid> I suck at writing kind signatures, but that's the idea.
04:00:40 <Nereid> class Functor' f x y where ...
04:01:13 <ski> merijn : we really would want to be able to say `instance (Functor f,Functor g) => Functor (\a -> f (g a)) where ...'
04:01:15 <Nereid> merijn: ping
04:01:47 <Nereid> I also can't write the signature for fmap' either. it's late.
04:02:04 <ski> but it's not clear how to allow some (seemingly) benign lambda like this in the type system, without also allowing "malign" ones (ones which could make the type checking run into an infinite loop)
04:03:30 <Nereid> oops that doesn't work.
04:03:31 <Nereid> ha.
04:04:17 <k0ral> hello
04:05:16 <k0ral> is there a tool to automatically remove redundant imports from source files at compile time ?
04:05:28 <merijn> ski: Doesn't UndecidableInstances also already allow non-terminating type checks?
04:05:29 <ski> Nereid : itym something like  class Functor' fa fb a b where fmap' :: (a -> b) -> (fa -> fb)  with  instance Functor' (F (G a)) (F (G b)) a b where fmap' = ...
04:05:41 <Nereid> sounds better than the next thing I was trying.
04:05:45 <ski> merijn : for instance resolution, yes
04:06:01 <byorgey> k0ral: no, but you can use -ddump-minimal-imports to see what's actually needed
04:06:06 <Nereid> but similar
04:06:38 <merijn> There might just be "{-# LANGUAGE UnsafeTypeLambdasThatCanHangYourCompiler #-}" :p
04:07:10 <Saizan> hanging is not even the biggest problem
04:07:24 <Saizan> not having unique solutions for unification anymore is more serious
04:07:59 <merijn> ski: I would actually settle for built-in composition instead of arbitrary type lambda's. That case seems it should be solvable
04:08:59 <merijn> Nereid: Writing a custom Functor' also kinda voids the value of making it a functor in the first place, then you could just define myMap without the hassle :p
04:09:24 <Nereid> ski: that almost works, except it can't infer any types
04:09:53 <k0ral> byorgey: thank you, that will save me some time :)
04:10:09 <Nereid> so fmap' id [()] doesn't work because it doesn't know what to put for x, y, or fy
04:10:12 <merijn> ski: The problem with Data.Functor.Compose is that you are forced to use getCompose at every use site, making it useless for anything except monad transformers (which you need to unwrap anyway)
04:10:44 <Nereid> merijn: I think you should just write your own map.
04:10:54 <Nereid> and not try to use Functor.
04:11:05 <Nereid> either that or live with getCompose everywhere
04:11:47 <merijn> Nereid: Yeah, the reason why I wanted Functor is that then I could use a bunch of other stuff without having to write my own fold, map, sequence, etc.
04:12:06 <Nereid> well you wouldn't have to write them from scratch
04:12:09 <merijn> Because then I have to name all of those and I'm running short on short, understandable names
04:12:25 <k0ral> byorgey: I wrote "Ghc-options: -Wall -ddump-minimal-imports" in my .cabal file, but I don't see any change in GHC's output for redundant imports
04:12:25 <Nereid> you could extract them out of the correpsonding methods coming from the instances for Compose
04:12:49 <Nereid> assuming you can compose foldables and traversables...
04:12:58 <byorgey> k0ral: no, it generates a file called Foo.hs.minimal-imports or something like that
04:12:58 <merijn> Nereid: The implementation is not the issue, the naming is :p
04:13:01 <Nereid> :P
04:13:06 <merijn> The implementations are mostly trivial
04:13:19 <k0ral> byorgey: oh right
04:13:20 <merijn> Almost identical to the implementations for []
04:14:00 <Nereid> time for bed
04:16:27 <ski> merijn : "I would actually settle for built-in composition instead of arbitrary type lambda's" i think, as Saizan hinted, that you wouldn't necessarily get unique solutions for unification even in this case -- maybe it could be made to work out (possibly with some restriction ?) though
04:17:01 <Nereid> you wouldn't?
04:17:14 <Nereid> even assuming strict associativity
04:19:13 <Saizan> \x -> M (N x) is out of the pattern fragment for M and N meta variables, so we'd have to make our own theory :)
04:19:43 <merijn> ski: How could you get non-terminating composition?
04:20:43 <merijn> Composing two terminating types should yield a terminating type, no?
04:21:07 <ski> Nereid : consider unifying `\a -> i (j a)' with `\a -> F (G (H a))' -- one solution is `i = \a -> F a; j = `\a -> G (H a)', another is `i = \a -> F (G a); j = `\a -> H a'
04:21:36 <merijn> Oh, I guess maybe you could use recursive types and write Fix? "data Fix f = Compose f (Fix f)"?
04:21:44 <merijn> eh
04:21:45 <merijn> s/data/type
04:22:23 <Saizan> merijn: it's not expanding the type that doesn't terminate
04:23:01 <merijn> Yeah, hmmm
04:23:11 <merijn> It just seems there should be a more elegant solution :\
04:23:28 <mcstar> nand`: hi, do you have progress on your problem?
04:23:31 <zomg> Oh fun fun, random segfaults while compiling GHC 7.6.1...
04:23:55 <zomg> And only reason I'm compiling it is to see if it fixes the random segfaults I'm getting with cabal and my app with GHC 7.4.1...
04:24:23 <zomg> What on earth is wrong with this :P
04:25:17 <mcstar> zomg: do you live nearby energetic particle sources, like a supernova?
04:25:28 <nand`> mcstar: oh, no; I haven't tried anything beyond those initial experiments. I instead worked around it by using existing upscaling algorithms like bicubic on patterns where applicable
04:26:05 <nand`> there's no more priority on solving it
04:26:11 <zomg> mcstar: unless my microwave oven is broken, no
04:26:12 <mcstar> nand`: someone linked an article on 'compressed sensing' i just read it, and followed it up a bit, and it is very interesting
04:26:12 <zomg> =)
04:26:38 <nand`> yeah, I saw that; though I haven't given it a read or anything besides a brief mention in the presentation I am working on
04:27:08 <mcstar> i think ill look into it
04:27:28 <mcstar> i think i can solve a problem of mine with it
04:31:40 <astry> merijn_: thanks for the tip with div
04:37:30 <merijn> Saizan, Nereid: Heh...I just realised I've been over thinking this, there's a much simpler solution to my problem >.>
04:38:15 <ski> merijn : "It just seems there should be a more elegant solution :\" -- yeah
04:38:24 <merijn> So I had "Foo (a :: Maybe v)"to encode the presence of a v value, which means "Foo (Just a)"would be a Functor for any a
04:38:31 <nicoo> mcstar: Could you relink the article on compressed sensing ?
04:38:49 <nand`> https://brainwindows.wordpress.com/tag/compressed-sensing/
04:38:56 <nicoo> Thanks
04:39:13 <mcstar> not a good article
04:39:15 <mcstar> http://www.wired.com/magazine/2010/02/ff_algorithm
04:39:18 <mcstar> read this
04:39:24 <mcstar> and then some technical
04:39:34 <merijn> I realised I can rewrite this too "Foo (b :: Bool) v" and make "Foo True" a Functor, (which means the value v is unspecified in the False case (because it has no sensible value), but that should be okay if I use the boolean to distinguish valid values of v
04:39:41 <mcstar> https://sites.google.com/site/igorcarron2/cs
04:39:45 <mcstar> nicoo: ^^
04:40:06 <merijn> And the True/False part I can hind behind a type synonym anyway
04:40:19 <mcstar> hide
04:40:22 <mcstar> :)
04:41:13 <merijn> Although that means an unnecessary type variable in the false case. I guess I'll survive...
04:45:28 <nicoo> mcstar: I know some about compressed sensing and information theory; that's why I wanted to know what articles you were reading on it
04:45:32 <nicoo> Thanks :)
04:46:04 <mcstar> nicoo: working on the theory, or an application?
04:46:54 <nicoo> mcstar: I know some about the theory, even though that's not really my field
04:47:15 <nicoo> I'm in distributed systems (byzantine fault-tolerance, specificaly)
04:47:40 <mcstar> i know nothing about that :)
04:48:18 <nicoo> Ok; no problem, itś not well-known outside of distributed-systems academia
04:48:22 <nicoo> it's*
04:52:00 <ClaudiusMaximus> nschoe: glad you got it working, any further questions/problems ask haskell cafe list with me in cc, claude at mathr.co.uk ; the glut example displays the webcam images in a window with an overlayed colour histogram
04:52:19 <ClaudiusMaximus> (was just about to @tell lambdabot that but you arrived!)
04:52:46 <nschoe> ClaudiusMaximus, yes I had a connection breakdown ^^ Thanks.
04:53:12 <nschoe> ClaudiusMaximus, I won't try using the GLUT thing yet, because I don't need it for now. But I have two questions:
04:53:40 * hackagebot rdf4h 1.0.1 - A library for RDF processing in Haskell  http://hackage.haskell.org/package/rdf4h-1.0.1 (RobStewart)
04:54:18 <nschoe> ClaudiusMaximus, I have never used GLUT before, but I have used SDL. Is it possible to adapt the script and have the images displayed in a SDL window instead? And 2/ you chose to write the image in PPM format. Is there a reaosn for that? I mean, my goal now that I have the image is to try to find a red spherical shape. And compute its size.
04:54:39 <nschoe> I intend to process the image generated by your script. So, is PPm a good choice for that?
04:54:44 <ClaudiusMaximus> nschoe: should be no problem to adapt GLUT->SDL, the opengl code is the same for both
04:55:22 <nschoe> ClaudiusMaximus, Hum ok. I will try it then. But I am not sure I'll succeed. I have never used openGL before :/ so it will mainly be dumb copy paste of the openGL code and try to make it work with SDL
04:55:37 <ClaudiusMaximus> nschoe: ppm is just raw raster data preceded by an ascii header: http://netpbm.sourceforge.net/doc/ppm.html
04:56:52 <ClaudiusMaximus> nschoe: http://hackage.haskell.org/package/repa-v4l2 might also be of interest if you want image processing functions
04:57:09 <nschoe> ClaudiusMaximus, yes I recall Real World Haskell talks about it. They implement a parser for that type. Bu what I meant was: can I safely keep PPM to work on the image?
04:57:15 <ClaudiusMaximus> (or rather, parallel array procesing of repa images)
04:57:25 <nschoe> repa-v4l2 .. okay I'll give it a try. Let's hope I can find examples.
04:58:04 <ClaudiusMaximus> nschoe: https://github.com/cgo/hsimage/blob/master/example.hs
04:58:56 <ClaudiusMaximus> lunchtime, bbiab
04:58:58 <nschoe> Thank you
05:08:45 <mcstar> nicoo: i see, Tao has a series on the subject on youtube
05:09:54 <mcstar> oh, it is probably only 1 lecture
05:10:05 <mcstar> split up into 7 pecies
05:10:11 <mcstar> pieces
05:19:23 <mcstar> nand`: could you give me some sample images?
05:20:06 <mcstar> maybe, along with the corrected version, and the original
05:20:19 <mcstar> if it is not a trouble
05:21:34 <mcstar> i imagine this compressed sensing reconstruction woudlnt do very well, if the missing points are clustered
05:21:54 <mcstar> if this werent true, that would really hurt my common sense
05:35:42 <mcstar> lol, Tao says MRI works by emitting neutrons
05:36:41 <nicoo> o_O
05:36:54 <VieiraN> That's NRI
05:37:09 <nicoo> VieiraN: Yes; quite different beasts
05:38:25 <mcstar> whats NRI?
05:38:45 <mcstar> VieiraN: ^^
05:39:22 <byorgey> it's whatever MRI is but with neutrons, apparently
05:40:09 <mcstar> i never heard of it
05:40:11 <VieiraN> Neutral Resonance Imaging
05:40:16 <VieiraN> It's just a blank image
05:40:47 <mcstar> what?
05:41:18 <VieiraN> It's not really a thing, tbh
05:41:53 <mcstar> there are instruments using neutrons as scattering particles, to assess structure
05:42:00 <mcstar> but that is not used on living beings
05:42:12 <mcstar> for obvious resons
05:42:16 <mcstar> reasons
05:42:26 <VieiraN> It was a pun
05:42:32 <mcstar> i see
05:43:00 <mcstar> VieiraN: i suggest the application of an infix oprator next time, like :)
05:43:10 <mcstar> well, infix value constructor
05:43:43 <VieiraN> Hmmm, sure...
05:44:05 <mcstar> data Pun a = a :) Pun a | NoPun
05:44:37 <Shapeshifter> Is there a particular reason why functor/monad laws aren't checked by the compiler?
05:45:57 <mcstar> how can you be sure a property holds by inspecting on a finite input set?
05:48:15 <mcstar> ah
05:48:23 <mcstar> he is confusing MRI with a simple CT
05:48:38 <mcstar> and substituting netrons for photons
06:00:47 * nicoo wants to headbang
06:01:48 <Saizan> i think the Functor laws could be checked pretty easily with a bit of partial evaluation in many cases
06:02:38 <Saizan> though something ad-hoc for Functor is probably not going to get into the language, and you'd still be left puzzling in the cases a conclusion can't be met
06:02:47 <Saizan> s/met/reached/
06:03:40 <Saizan> but sooner or later GHC is going to get dependent types so you can have the pleasure of proving they hold ;)
06:05:01 <Saizan> there was a fork of GHC that had a system that would attempt checking somewhat arbitrary invariants but i don't remember the name..
06:17:35 <byorgey> proving Functor laws automatically should be easy, as one only needs to prove  fmap id = id
06:17:41 <byorgey> the other one follows from that + parametricity
06:20:12 <Ferdirand> hmm
06:20:35 <Ferdirand> what is + parametricity ?
06:21:29 <Ferdirand> oh wait i get it
06:21:37 <mcstar> i see the other day, that theres an extension of deriving Functor
06:22:30 <Ferdirand> the other one follows from fmap id = id because the functor must accept any type ?
06:26:18 <mcstar> > fmap (+2) (1,2,3)
06:26:19 <lambdabot>   No instance for (GHC.Base.Functor ((,,) t t1))
06:26:19 <lambdabot>    arising from a use of `e_...
06:28:27 <cocon> > fmap (+2) (1, True)
06:28:28 <lambdabot>   No instance for (GHC.Num.Num GHC.Bool.Bool)
06:28:28 <lambdabot>    arising from the literal `2'...
06:28:36 <cocon> ;)
06:28:55 <cocon> Is there any documentation on the new ExplicitNamespaces?
06:30:56 <MostAwesomeDude> > fmap (+2) (True, 1)
06:30:57 <lambdabot>   (True,3)
06:33:46 <cocon> > :i (,)
06:33:46 <lambdabot>   <no location info>: parse error on input `:'
06:33:58 <Jetbeard> :i (,)
06:34:01 <Jetbeard> :t (,)
06:34:02 <lambdabot> forall a b. a -> b -> (a, b)
06:34:10 <cocon> instance Functor ((,) a)
06:34:32 <byorgey> Ferdirand: yes, there is a technical property called 'parametricity' which essentially says that you can infer certain behaviors because of how polymorphism works
06:34:53 <byorgey> Ferdirand: i.e. polymorphic functions must behave "uniformly" for any input type, so that limits what they can do
06:35:52 <cocon> Any recommendations what iteratee package to use when speed
06:35:52 <cocon>  is the main concern?
06:36:44 <Ferdirand> byorgey: okay, so was the "+" a typo or is there also a "-" parametricity ?
06:36:48 <FPtje> Hey I've got a problem with my code (http://pastebin.com/uRA2NQBZ) My program prints ("Move Invalid!") once when the move is valid, and it prints it TWICE when it's NOT valid. I can't figure out why this is happening. When the move is valid, it prints "move invalid", but it does not go in recursion!
06:36:51 <mcstar> cocon: pick the fastest one :)
06:36:54 <maukd> The paste uRA2NQBZ has been copied to http://hpaste.org/75119
06:37:07 <byorgey> Ferdirand: by "+" I just meant "and"
06:37:18 <Ferdirand> aaah
06:37:29 <byorgey> heh, sorry for the confusion =)
06:37:48 <mcstar> i read it as 'plus' and it made sense
06:38:26 <mcstar> byorgey: for a tuple, theres not a unique way to define functor, right?
06:39:15 <byorgey> mcstar: well, given the way you have to write Functor instances (with the varying parameter being the last one) there's only one in Haskell
06:39:31 <mcstar> ah, thats what i was missing
06:39:34 <byorgey> but mathematically speaking, yes, there are two possible ways of making heterogeneous tuples into a functor
06:40:14 <byorgey> you can also make a functor out of  data Pair a = Pair a a  which is different
06:40:54 <mcstar> for that it is guaranteed that it is homogeneous
06:41:09 <FPtje> Note on my noob question about the "Invalid move": The condition in the "IF" statement is False.
06:41:20 <mcstar> but still, you can decide, on which part to apply the argument to fmap
06:42:11 <srhb> FPtje: That seems unlikely.
06:42:11 <mcstar> fmap f (Pair a b) = Pair (f a) b | Pair a (f b) | Pair (f a) (f b)
06:43:09 <FPtje> srhb: But it is! http://i.imm.io/FeIE.png
06:43:46 <Ferdirand> byorgey: i was trying to see a relationship with type parameter variance in languages that have subtyping
06:43:50 <FPtje> the moveValid function returns true, so the "not moveValid) should return false, right?
06:45:12 <mcstar> FPtje: return () doesnt exit 'main'
06:45:21 <byorgey> Ferdirand: ah, hehe
06:45:24 <mcstar> i not sure whether you know that or not
06:45:50 <FPtje> mcstar: Oops that's a redundant return that sneaked in while debugging
06:46:47 <srhb> FPtje: I can't see that there are any other possibilities than: You're wrong, you have another print statement somewhere else.. :P
06:47:23 <srhb> FPtje: But it's a bit difficult to read your code, perhaps you could clean it up to live up to Hlints suggestions?
06:47:52 <FPtje> srhb: Then I am wrong. I am new to Haskell and I have no idea how to clean it up.
06:47:52 <mcstar> FPtje: theres no need to write 'else do \n if'
06:48:03 <FPtje> mcstar thanks, I'll remove that
06:48:14 <mcstar> you need 'do' when you want to sequence several IO actions
06:49:04 <FPtje> mcstar: Do I need to remove the "else" keyword  too, or just the "do" next to the "else"?
06:49:29 <mcstar> just the 'do
06:50:09 <mcstar> and those other return () expressions might be superflous, if the previous actions returned ()
06:50:11 <RebelBunny> why do people say they feel like they're cheating when they use haskell to solve project euler problems?
06:50:26 <srhb> RebelBunny: No idea.
06:50:26 <mcstar> they are stupid
06:50:43 <mcstar> the reals cheaters are the ones who use mathematica or somesuch
06:50:48 <mcstar> -s
06:51:13 <mcstar> (except if they solve the problem wo very high level built-ins)
06:51:20 <merijn> mcstar: J/APL :p
06:51:34 <mcstar> factorize n:
06:51:37 <mcstar> q. n
06:51:47 <mcstar> or something like that i believe :)
06:52:36 <mcstar> q: n
06:52:39 <srhb> FPtje: Did you notive that the hpaste has the Hlint suggestions (with suggested fixes) at the very bottom?
06:52:46 <Ferdirand> if using mathematica is cheating, what about those who use google
06:53:06 <FPtje> mcstar, srhb: I tried removing the "do"s, but regardless of whether there's a "do" next to "Then", it gives a parse error on line 35...
06:53:12 <srhb> (They're not that good though, in this case :-))
06:53:21 <FPtje> srhb: yes, here's the new paste http://pastebin.com/6bDaX4yn
06:53:31 <maukd> The paste 6bDaX4yn has been copied to http://hpaste.org/75120
06:55:54 <mcstar> Ferdirand: it is cheating, when for example, you are clearly supposed to write a factoring algorithm, the guy just solves it with FactorInteger[]
06:55:54 <mcstar> but they are cheating themselfes, so who cares?
06:55:54 <srhb> FPtje: I wonder if you're having a buffering error on input on top of everything else.
06:55:54 <srhb> FPtje: Could you try disabling buffering on stdin in main?
06:56:06 <srhb> FPtje: And yeah, now it is more obvious that you need to indent your nested ifs and elses
06:56:15 <FPtje> srhb I have no clue how to do that. But the current code gives a paste error:  "main.hs:35:9: parse error (possibly incorrect indentation)". Thanks for your help, though, I really aprreciate it
06:56:47 <b__> why does HLint prefer `elem` over elem?
06:57:02 <FPtje> srhb: the body of the ifs are already indented, and I tried indenting the bodies of the elses too
06:57:21 <Eduard_Munteanu> b__: maybe because it looks more like x ∈ A
06:57:37 <srhb> FPtje: Oh, you have tabs. Convert those to spaces.
06:57:48 <srhb> FPtje: Tabs are illegal in Haskell. :-)
06:58:10 <b__> would you recommend infix Eduard_Munteanu?
06:58:25 <FPtje> srhb: I fixed the indentation, it compiles now. Let me test the "Invalid move" thing
06:58:48 <FPtje> srhb: It still does it, let me paste again
06:59:02 <Eduard_Munteanu> b__: it makes it look more like math notation, it's just a question of style, dunno
06:59:30 <hpaste> FPtje pasted “Invalid move v4” at http://hpaste.org/75121
06:59:31 <b__> okay
06:59:49 <Eduard_Munteanu> srhb: tabs definitely work if you use them as intended
07:00:16 <FPtje> srhb: I think you missed my paste ;) http://hpaste.org/75121
07:00:53 <srhb> Eeep.
07:00:56 <srhb> FPtje: It looks better, but I still see tabs!
07:01:07 <srhb> FPtje: Does it compile now though?
07:01:12 <FPtje> srhb Fixed. Yes, it compiles
07:01:38 <srhb> FPtje: Cool, now try turning off buffering on stdin
07:02:19 <mcstar> i think console io is line buffered
07:02:29 <mcstar> and why would that cause this problem anyway?
07:02:54 <srhb> I still think the move is not valid.
07:03:04 <mcstar> that code is very confusing
07:03:14 <srhb> Yes, it is
07:03:19 <mcstar> i certainly dont see how i was supposed to work
07:03:24 <mcstar> no data structores
07:03:33 <srhb> FPtje: Anyway, hSetBuffering stdin NoBuffering before your loop in main.
07:03:35 <mcstar> tuples everywhere, and you mix things together
07:04:05 <mcstar> and the paste is not complete enough to experiment with it
07:04:07 <FPtje> Sorry mcstar, this is my second week of haskell... I have not a clue on tidyness of code like I do with imperative languages
07:04:27 <srhb> mcstar: You're making it worse than it is for a more or less first attempt :-)
07:04:50 <FPtje> Oh I see part of the problem! It seems as though the condition in the if statement is true, but when it goes in recursion with exactly the same data, it's fals!
07:04:53 <srhb> What I think is happening is multiple inputs getting caught because of buffering (ie 6, return...)
07:04:53 <srhb> The six might be valid but the return is not
07:05:33 <FPtje> If I comment out the recursion in line 31, the program will terminate when doing a valid move
07:05:44 <srhb> FPtje: Did you try disabling buffering?
07:06:11 <FPtje> srhb: I don't know how to, and I can't immediately find it on google
07:06:24 <srhb> FPtje: hSetBuffering stdin NoBuffering
07:06:37 <mcstar> FPtje: do you advance your variables in the recursion?
07:06:43 <srhb> No he doesn;t
07:06:56 <srhb> FPtje: Those are from System.IO
07:07:18 <srhb> mcstar: Not in the "invalid move" case
07:07:25 <mcstar> yes i see
07:07:28 <srhb> FPtje: You should insert that bit before you start your loop
07:08:01 <nand`> mcstar: Here's a sample image. The ‘unknown’ pixels are marked red for your convenience. http://imageshack.us/a/img20/9823/xtrans.png
07:08:08 <srhb> FPtje: Key point being: 6 is a valid move, RETURN is not. I'm almost certain.
07:08:36 <FPtje> srhb: The buffering doesn't seem to do anything
07:08:38 <srhb> FPtje: (You could make this more obvious by actually outputting the input that yielded the invalid mvoe)
07:08:52 <srhb> FPtje: Are you compiling, then running it?
07:09:10 <FPtje> I'm running it from ghci
07:09:11 <mcstar> nand`: can i get the original too?
07:09:26 <srhb> FPtje: Please compile and run it.
07:09:33 <srhb> FPtje: With buffering disabled as instructed
07:10:21 <srhb> FPtje: 6<ret> -> valid -> invalid. f<ret> -> invalid -> invalid
07:10:45 * parcs` wonders why there's no (Exception a, Exception b) => Exception (a,b) instance
07:10:46 <nand`> mcstar: http://ompldr.org/vZmxlOA/original.png
07:11:15 <mcstar> thanks
07:11:39 <mcstar> nand`: maybe one that is reconstructed with the upscaling method? :)
07:12:12 <ski> srhb : when did they become illegal ?
07:12:15 <nand`> I don't have a reconstruction for that particular filter yet, but I have one for one that's quite similar
07:12:22 <srhb> ski: I was exaggerating. :-)
07:12:23 <benmachine> parcs`: for... throwing two exceptions as once?
07:13:35 <nand`> http://ompldr.org/vZmxlYg/upscaled.png
07:13:38 <parcs`> benmachine: yep
07:13:43 * hackagebot sloane 0.1.4 - A command line interface to Sloane's On-Line Encyclopedia of Integer Sequences  http://hackage.haskell.org/package/sloane-0.1.4 (AndersClaesson)
07:13:49 <benmachine> parcs`: why would you want to do that, excatly? :P
07:14:09 <mcstar> nand`: thanks
07:14:09 <FPtje> srhb: I don't see what you mean by that, in every recursion it does a new getChar. I don't see how per getChar it goes in recursion twice
07:15:17 <parcs`> well actually the constraints could be relaxed to instance (Show a, Show b, Typeable a, Typeable b) => Exception (a,b)
07:16:21 <benmachine> parcs`: yes but they probably shouldn't
07:16:32 <benmachine> parcs`: in my view Exception means 'this is an exception"
07:16:36 <benmachine> I don't want people throwing integers
07:16:40 <benmachine> they are not exceptions
07:17:22 <srhb> FPtje: Did you try doing what I said? I think it will be more clear what's going on once you've tried that.
07:17:34 <atriq> I really think Haskell ought to have private classes
07:17:40 <atriq> Instances, rather
07:17:46 <atriq> As in, "Don't export this instance"
07:17:57 <atriq> "It's useful here, but it's gonna annoy everyone else"
07:18:21 <benmachine> atriq: what happens if you build a Map with your private Ord instance and then give it to someone with a different Ord isntance
07:18:29 <atriq> Ooh, hmm
07:18:43 <srhb> FPtje: The reason, I think, is that it succeeds with the move '6', then it fails with the input '<return>', then it fails with the input 'f' and then it fails with the input '<return>'. Because of buffering, the first character is not available to getChar until you've pressed return, and then 'return' is interpreted as the next input in the next iteration.
07:18:45 <atriq> Then everyone's gonna get annoyed
07:18:49 <atriq> That's a good point
07:19:15 <srhb> FPtje: I'm not sure I can explain it in a clearer way, so please try to do as I suggested. Add hSetBuffering stdin NoBuffering before you start you loop, then try to compile and run your program and see what behaviour you get.
07:20:03 <FPtje> srhb: So it's considering the return as another input character?
07:20:08 <srhb> FPtje: Yes.
07:20:52 <benmachine> why wouldn't it?
07:21:55 <FPtje> srhb: It worked! I would have NEVER figured this out without you! I just put another getChar under the "input <- getChar" line, and now it works!
07:22:04 <FPtje> Thanks! :D
07:22:13 <srhb> FPtje: That's a bit hacky, but ok. :P As long as you understand what is happening.
07:22:46 <FPtje> srhb It has to work in ghci, so compiling it is not really an option :)
07:23:03 <mcstar> no
07:23:10 <mcstar> the solution is to not use getchar
07:23:36 <mcstar> i thought you were reading lines...
07:24:04 <FPtje> mcstar: no, I am reading a single character from the input. And that single character defines my actions. Why not getChar? :P
07:24:35 <mcstar> because you run into problems that you dont understand
07:24:47 <benmachine> well then you should understand them :P
07:25:12 <benmachine> why not just continue to use getChar, but manually filter out newlines?
07:25:22 <benmachine> recurse immediately if it's a newline
07:25:31 <benmachine> otherwise calculate result of moves
07:25:38 <benmachine> or! even better, define a getNonNewline
07:25:44 <mcstar> great
07:25:47 <mcstar> do that
07:26:00 <deech> Does GHC support banana braces for applicative programming?
07:26:09 <FPtje> mcstar: Haha! I guess I wasn't handling input that had more than one character in it either. getLine works. Thanks to you too!
07:26:18 <benmachine> deech: there's Conor's she preprocessor
07:26:30 <benmachine> deech: there's also the applicative-quoters package
07:26:31 <mcstar> FPtje: have fun with haskell
07:26:48 <t7> whats a banana brace?
07:26:56 <deech> benmachine: never heard of them, thanks!
07:27:10 <benmachine> deech: https://personal.cis.strath.ac.uk/conor.mcbride/pub/she/idiom.html
07:27:19 <ski> aka "idiom brackets"
07:27:22 <benmachine> deech: http://hackage.haskell.org/package/applicative-quoters
07:27:29 <deech> benmachine: awesome!
07:27:40 <benmachine> applicative-quoters used to be my package but no-one used it so I abandoned it :P
07:28:00 <benmachine> so hey, if you want a free package, I've got a great deal for you
07:29:35 <benmachine> oh man, the hackage on that is totally screwed up >_>
07:29:39 <benmachine> er haddock
07:31:34 <deech> benmachine: It appears that someone messed with it as of the 13th.
07:31:44 <benmachine> deech: that was me
07:31:49 <deech> Ah
07:35:24 <meatcomputer> I'm looking into the algebraic stuff related to folds and could use a wiser mind to help me get my thoughts organized...
07:36:50 <meatcomputer> these guys implemented a special genetic algorithm in C++ and need folds. It apparently uses program trees to evolve code... Seems like haskell is better for this, but they gots PHDs and stuff.
07:51:20 <HankMoody> but cant they just implement folds in C++? just loop over all elements and send ina fucntion pointer
07:52:41 <meatcomputer> yep.  I'm looking at helping them implement it.  They have a special lisp like library to evolve the programs.  I'm just wanting to learn more about the whole process and maybe help. It's opensource code
07:53:02 * nand` implements folds in C++ via generalized comonadic catamorphisms
07:54:11 <hpaste> scooty-puff pasted “MonadThrow/MonadCatch” at http://hpaste.org/75123
07:55:38 <mcstar> i dont understand, why fold? or what about them? folding over an AST?
07:56:23 <meatcomputer> hmm well they need it to evolve more intersting programs
07:56:54 <meatcomputer> damn nand` that is a mouthfull thanks
07:57:15 <nand`> (I don't relaly)
07:57:18 <nand`> really*
07:58:24 <mcstar> haskell would make it easier to work with the 'code' since it is so easy to define data/code and trees
07:58:44 <mcstar> but then you wouldnt have in place updates of the nodes
07:58:54 <mcstar> maybe that is important, maybe it isnt
07:59:05 <mcstar> (if they are very much concerned about speed)
07:59:09 <meatcomputer> very very
07:59:43 <meatcomputer> it's a subroutine of a big ole AI design.  artificial general intelligence
07:59:46 <mcstar> it is still not clear what do you hope to accomplish with 'fold'
08:00:06 <meatcomputer> do stuff with lists
08:00:09 <mcstar> maybe because im imbecile, idk
08:00:29 <mcstar> then do the stuff with lists
08:00:30 <meatcomputer> I'm just working with what they told me don't feel bad.
08:01:02 <meatcomputer> but they want to *evolve* programs that operate on lists and they intend to use fold.  I didn't design it.  I just want to help
08:01:24 <mcstar> fold is an operation, of taking a data structure, applying something on the elements on parts of it, and using another operation, that accumulates the result
08:01:55 <meatcomputer> right.  it is a general operator that is capable of powerful recursive operations
08:02:07 <HankMoody> i mean fold could just be recursively traverse your structure and send a function pointer in , like add(int a, int b); foldl(&add, initval, strcuture); obv they must be able to do that if they are PhDs
08:02:43 <meatcomputer> yep. but they are doing a bunch of shit. http://opencog.org/
08:03:15 <mcstar> meatcomputer: do they want to use fold to solve the problem, or they want 'fold' to be a primitive of the language they like to evolve their code in?
08:03:33 <meatcomputer> a primitive I believe...
08:03:52 <mcstar> now thats something quite different
08:03:54 <ski> mcstar : sounds like you're talking about `foldr' (or maybe `foldl')
08:04:02 <meatcomputer> ah.  I missed that.
08:04:15 <mcstar> ski: hm? r/l doesnt matter
08:04:19 <meatcomputer> yes that sounds familiar. I've read so much stuff lately
08:04:27 <mcstar> jsut that its a fold/reduce type of thing
08:05:12 <mcstar> ski: it isnt even haskell, just a prototypical language to genetically evolve code with, if i understand meatcomputer correctly
08:05:48 <ski> mcstar : a "fold/reduce type of thing" is different from a "general fold type of thing"
08:06:00 <meatcomputer> yes.  btw #math directed me here
08:06:12 <ski> (for lists, they happen to be basically the same thing)
08:06:15 <meatcomputer> it's called "combo"
08:06:20 <mcstar> he mentioned lists
08:06:33 <mcstar> "do stuff with lists"
08:06:35 <meatcomputer> the C++ library they evolve programming structures in
08:06:56 <meatcomputer> catamorphisms.  I need to study them.  That's what I figured out.
08:07:36 <ski> mcstar : hm, i thought meatcomputer mentioned ASTs -- however that was you -- sorry
08:07:51 <mcstar> he mentioned code trees iirc
08:08:02 <ski> in any case, "catamorphisms" is the general case
08:08:18 <ski> consider a simplistic datatype
08:08:52 <ski>   data Expr var = Var var
08:08:55 <ski>                 | Lit Int
08:08:56 <ski>                 | Add (Expr var) (Expr var)
08:09:23 <ski> a fold/catamorphism would be
08:09:48 <ski>   foldExpr :: (var -> r) -> (Int -> r) -> (r -> r -> r) -> (Expr var -> r)
08:10:27 <ski> meatcomputer : does this make any sense at all to you ?
08:11:37 <mcstar> well, the (Expr var -> r) can deal with (var -> r) and (Int -> r)
08:12:20 <ski> yes -- `Expr var -> r' is the type of the returned function
08:12:47 <mcstar> ah ok
08:12:50 <ski> (or, if you will, an argument of type `Expr var' is passed, that is traversed, and finally a value of type `r' is returned)
08:13:15 <mcstar> yes, i thought the whole sig wasnt fully applied
08:13:26 <meatcomputer> I haven't studied much Haskell. but yes it makes some sense.  I don't completely get it yet
08:13:29 <ski> anyway, a foldl/reduce-type operation here would look something like
08:13:30 <ski>   reduceExpr :: (var -> r -> r) -> (Int -> r -> r) -> (Expr var -> r -> r)
08:13:51 <meatcomputer> I'm more a math guy than a code guy.
08:14:02 <meatcomputer> but I'm trying to get my programming up to par
08:14:04 <MostAwesomeDude> Haskell's more a math language than a code language. :3
08:14:12 <ski> meatcomputer : do you understand inductively defined types/sets ?
08:14:18 <meatcomputer> yes
08:14:30 <ski> (and the corresponding structural alt. primitive recursion on such a set)
08:14:32 <meatcomputer> like geometric series right?
08:14:48 <ski> (with corresponding structural induction reasoning principle)
08:15:10 <ski> meatcomputer : .. not really
08:15:26 <meatcomputer> huh... give me an example then please
08:15:36 <ski> the simplest non-trivial example is probably the Peano representation of natural numbers
08:15:46 <mcstar> or the list
08:15:50 <meatcomputer> k. I'm going to read about it for a bit.
08:15:52 <ski>   (a) `zero' is a natural number
08:16:03 <meatcomputer> or you can tell me. :_)
08:16:13 <ski>   (b) if `n' is a natural number, then `succ(n)' is a natural number
08:16:38 <ski>   (c) only those `n' which can be constructed by finitely many applications of rules (a) and (b) are natural numbers
08:17:13 <meatcomputer> I've studied automata theory
08:17:17 <ski> (a) and (b) might be called "generating rules" for the inductively defined set of "natural numbers"
08:17:20 <meatcomputer> so this all seems familiar
08:17:23 <mcstar> theres no n such that succ n = zero
08:17:23 <meatcomputer> like grammars
08:17:39 <ski> (c) ensures that we get the *smallest* set satisfying conditions (a) and (b)
08:18:22 <ski> typically, we let the (c) condition be implicit in the fact that we're claiming to define an *inductively* defined set
08:18:34 <meatcomputer> ski: like grammars?
08:18:49 <meatcomputer> and how they operate on primitives. I may have the lingo wrong
08:19:13 <ski> yes -- though grammars have more laws (associativity of sequence concatenation)
08:19:56 <ski> in the above case, we have no additional laws added to the generation of the elements
08:20:23 <ski> (think of "laws" here in the sense of laws that one can impose when presenting a group, e.g.)
08:20:37 <meatcomputer> i'm developing a pretty serious headache.  I need to stop looking at this monitor and think about something else till some asprin kicks in. thank you ski.  I need a small break.
08:20:49 <ski> ok
08:20:52 <meatcomputer> i'll try to return shortly
08:22:16 * ski will leave for a short while, will be back
08:24:02 <Puffton> Hi guys!
08:25:02 <luc-> I'm a complete beginner in Haskell who tries to understand the library Ratio (http://www.haskell.org/onlinereport/ratio.html)
08:26:27 <luc-> I can't manage to understand the approxRational function, specifically that line: "xr@(n:%d) = toRational x"
08:27:19 <t7> do people usually write a program first, then turn it into a literate program?
08:28:23 <mcstar> luc-: xr is the name of the whole thing in the (), to later refer to it, n :% d just decomposes the rational into a numerator and denominator
08:30:13 <mcstar> > toRational 1
08:30:14 <lambdabot>   1 % 1
08:30:34 <Puffton> In using list comprehensions to get all permutations, like this: [(x, y) | x<- a, y<-a]
08:30:35 <Puffton> for example
08:30:37 <mcstar> > let xr@(n:%d) = toRational 123 in (xr, n, d)
08:30:38 <lambdabot>   Not in scope: data constructor `:%'
08:31:00 <luc-> mcstar: I did not know that syntactic use of @, thanks!
08:31:00 <Puffton> is there an easy way to weed out equivalent pairs? i.e. (x,y) == (y,x), in a compact/easy way?
08:31:40 <Puffton> (in my code they are equivalent, of course they could be different in another context)
08:32:10 <hpc> @pl \(x,y) (x2, y2) -> (x,y)==(x2,y2) || (x,y)==(y2, x2)
08:32:13 <lambdabot> uncurry (flip flip snd . (ap .) . flip flip fst . ((.) .) . ap (ap . (liftM2 (liftM2 (||)) .) . flip flip (,) . (((.) . (.) . (==)) .) . (,)) (flip flip (flip (,)) . (((.) . (.) . (==)) .) . (,)))
08:32:21 <hpc> well that's not compact
08:32:35 <mcstar> > [(x, y) | x<- [1..4], y<-[1..4], x /= y]
08:32:36 <lambdabot>   [(1,2),(1,3),(1,4),(2,1),(2,3),(2,4),(3,1),(3,2),(3,4),(4,1),(4,2),(4,3)]
08:32:43 <mcstar> like that?
08:32:57 <luc-> I only went through "Yet Another Haskell Tutorial" so far.
08:33:10 <hpc> :t uncurry (==)
08:33:11 <lambdabot> forall a. (Eq a) => (a, a) -> Bool
08:33:19 <luc-> But now, that's the definition of toRational I don't understand
08:33:22 <hpc> @let samePair = uncurry (==)
08:33:23 <lambdabot>  Defined.
08:33:25 <mcstar> hpc: what did you do there?
08:33:26 <hpc> > samePair (5, 5)
08:33:28 <lambdabot>   True
08:33:39 <nevrenato> Does anyone know any good article about "when is safe to use undecidable functional dependencies" ?
08:33:53 <hpc> mcstar: two tuples that are equal either by normal comparison or if one is flipped
08:33:58 * hpc misunderstood the question
08:34:02 <mcstar> yes
08:34:06 <hamishmack> Can anyone tell why this… http://ghcjs.github.com/bin/advgame.jsexe/hterm.html works in chrome and safari, but not in firefox?
08:34:19 <mcstar> hpc: im just commenting on the gross thing that came out of @pl
08:34:21 <hpc> nevrenato: it should always be safe to use undecidable instances in combination with other safe extensions
08:34:39 <hpc> undecidable instances lets the compiler fail to terminate, but if it does you have a valid program
08:35:07 <nevrenato> cool :)
08:35:38 <nevrenato> and can we know if, the compiler is going to fail or not ?
08:35:49 <nevrenato> or only testing ?
08:35:53 <nevrenato> we will know
08:35:59 <mcstar> [(x, y) | x<- [1..4], y<-[1..4], x <= y]
08:36:01 <mcstar> > [(x, y) | x<- [1..4], y<-[1..4], x <= y]
08:36:02 <lambdabot>   [(1,1),(1,2),(1,3),(1,4),(2,2),(2,3),(2,4),(3,3),(3,4),(4,4)]
08:36:16 <mcstar> Puffton: maybe that ^^
08:37:41 * mcstar wishes he was undecidable, so he would never terminate...
08:38:02 <geekosaur> nevrenato, I'm not sure what you asked there, but it is not possible to know ahead of time that the compiler will not terminate (see:  halting problem)
08:41:00 <nevrenato> geekosaur: ok…sorry for the bad english…I have a relatively large program and i want to use undecidable instances…but i'm afraid that in the end of the implementation i will no termination
08:41:17 <nevrenato> geekosaur: * i will have no termination
08:42:17 <Puffton> mcstar, ah yes, very elegant
08:43:00 <luc-> I mean I don't understand how "toRational x" fits with the definition "toRational(x:%y)"
08:45:27 <freels> Question: Is there a way to choose the correct build product when invoking 'cabal-dev ghci' ?
08:47:07 <freels> e.g. i have a project with an executable, a library, and test harness. cabal-dev seems to choose which context to use at random.
08:48:21 <ski> > [(x,y) | xs@(x:_) <- tails [0,1,2,3] , y <- xs]  -- Puffton
08:48:22 <lambdabot>   [(0,0),(0,1),(0,2),(0,3),(1,1),(1,2),(1,3),(2,2),(2,3),(3,3)]
08:49:32 <Puffton> that will work for non-ints too?
08:49:46 <ski> > [(x,y) | xs@(x:_) <- tails "abcd" , y <- xs]
08:49:47 <lambdabot>   [('a','a'),('a','b'),('a','c'),('a','d'),('b','b'),('b','c'),('b','d'),('c'...
08:49:54 <ski> > [(x,y) | xs@(x:_) <- tails "aab" , y <- xs]
08:49:55 <lambdabot>   [('a','a'),('a','a'),('a','b'),('a','a'),('a','b'),('b','b')]
08:50:25 <ski> (you get duplicates in the last example there, because the given list already had duplicates)
08:54:21 <ski> to not even get `(x,x)' pairs, use `x:xs' instead of `xs@(x:_)'
08:55:18 <ski> to not get such duplicates, but still get both `(x,y)' and `(y,x)', i'd define and use `select :: MonadPlus m => [a] -> m (a,[a])'
08:55:47 <Puffton> I'm basically measuring distances between two points
08:55:50 <Puffton> (p1, p2, distance)
08:55:53 <Puffton> this is the output
08:56:01 <Puffton> but I figured (p2, p1, distance) would be reduntant in this context
08:56:23 <ski> aye
08:59:52 <noviceprogrammer> http://ideone.com/OQ8QQ why does my code fail to compile?
09:00:11 <noviceprogrammer> also, how do I match negative integers in the second case of countChange?
09:03:04 <geekosaur> noviceprogrammer, '(money (tail coins))' invokes money as a function
09:04:06 <geekosaur> note, haskell does not process parameter lists the same way other languages do, you can't say foo(bar baz) to invoke foo with two parameters
09:04:15 <noviceprogrammer> right
09:05:41 <Puffton> ski, what you wrote is basically equivalent to
09:05:41 <Puffton> [(x,y) | x  <- head ["abc"], y <- tail "abc"]
09:05:41 <Puffton> ?
09:06:46 <ski> > [(x,y) | x  <- head ["abc"], y <- tail "abc"]
09:06:47 <lambdabot>   [('a','b'),('a','c'),('b','b'),('b','c'),('c','b'),('c','c')]
09:06:53 <ski> > [(x,y) | xs@(x:_) <- tails "abc" , y <- xs]
09:06:54 <lambdabot>   [('a','a'),('a','b'),('a','c'),('b','b'),('b','c'),('c','c')]
09:07:28 <Puffton> oh yeah crap, no 'a', 'a'
09:07:54 <noviceprogrammer> http://ideone.com/9pzUl now it is causing a stack blowout :( I think it's because of the second case.
09:07:55 <ski> also, both  ('b','c')  and   ('c','b')
09:08:25 <noviceprogrammer> how do I get the second case to match only negative values of the first parameter?
09:10:29 <noviceprogrammer> how do I add a boolean guard in the second case? ^^
09:10:39 <ski>   countChange money [] | money < 0 = 0
09:10:40 <ski> ?
09:10:44 <srhb> noviceprogrammer: You can use guards. foo x | x > blah = ...
09:10:58 <noviceprogrammer> ah
09:12:12 <ski> noviceprogrammer : note that `putStrLn $ show $ ...' (which can more nicely be written as `putStrLn (show (...))' or `putStrLn . show $ ...') can actually be abbreviated to `print (...)'
09:12:27 <noviceprogrammer> right
09:12:34 <ski> also, instead of saying
09:12:47 <ski>   countChange money coins = ..(head coins)..(tail cons)..
09:13:07 <noviceprogrammer> http://ideone.com/ioQ7h there
09:13:24 <ski> well, actually, `coins' do occur in one more place
09:13:25 <ski> so
09:13:39 <ski>   countChange money coins = ..(head coins)..(tail coins)..coins..
09:13:47 <ski> can be changed into, e.g.
09:14:15 <ski>   countChange money coins0@(coin:coins) = ..coin..coins..coins0..
09:14:44 <ski> so `coins0' is here the whole list of coins, `coin' is the first element of that list, and `coins' is the list of all the other elements
09:15:09 <ski> noviceprogrammer : that way, you can avoid using `head',`tail', which is nice
09:15:17 <noviceprogrammer> right
09:15:20 <ski> an alternative is to say
09:15:35 <ski>   countChange money (coin:coins) = ..coin..coins..(coin:coins)..
09:15:39 <Sculptor> head or tail
09:15:52 <ski> but then you have to write `coin:coins' twice (once in the pattern, once in the body)
09:16:06 <noviceprogrammer> I like the cons pattern matching
09:16:06 <ski> noviceprogrammer : you decide yourself which of these two forms you prefer
09:16:53 * ski idly wonders where meatcomputer disappeared
09:17:34 <Puffton> > tails [1,2,3]
09:17:35 <lambdabot>   [[1,2,3],[2,3],[3],[]]
09:17:45 <Puffton> hm, it doesn't work for me when I import List
09:18:01 <simon> ski, by two forms you mean whether or not to use alises in the pattern, right? head/tail are prone to throwing errors.
09:18:09 <simon> s/alises/aliases/
09:18:38 <noviceprogrammer> how do I perform a logical or in haskell?
09:18:46 * hackagebot hbro 1.0.0.0 - Minimal KISS compliant browser  http://hackage.haskell.org/package/hbro-1.0.0.0 (koral)
09:18:47 <simon> noviceprogrammer, ||
09:18:51 <simon> :t (||)
09:18:51 <ski> simon : yes
09:18:52 <lambdabot> Bool -> Bool -> Bool
09:18:53 <srhb> noviceprogrammer: (||)
09:18:56 <noviceprogrammer> ah thanks
09:19:14 <ski> @index tails
09:19:14 <lambdabot> Data.List
09:19:14 <simon> hi srhb :)
09:19:20 <ski> Puffton : import `Data.List'
09:19:21 <srhb> Hi simon ^^
09:19:34 <dfordivam> Hello
09:19:40 <ski> ehlo
09:21:09 <noviceprogrammer> http://ideone.com/MFYFt :( what went wrong here?
09:21:35 <Puffton> oh Data.List, ok
09:21:41 <srhb> noviceprogrammer: Function application binds more tightly than operators like that
09:21:47 <Puffton> the doc I found only said "List"
09:21:48 <noviceprogrammer> right
09:21:51 <srhb> foo (bar:baz) is different from foo bar:baz
09:22:46 <noviceprogrammer> http://ideone.com/clone/3P6ph seems to yield a parse error
09:22:54 <Shou> I have a question. Let's say I have an MVar with a list that I need to check the contents of in a thread, if I just `forever (do stuff)` the procedure will run as often as it can, using 100% of a CPU core. With my limited knowledge, the only thing that comes to mind to bring it down is `threadDelay'. Is there a better way?
09:23:31 <srhb> noviceprogrammer: Think your link failed.
09:23:46 * hackagebot hbro-contrib 1.0.0.0 - Third-party extensions to hbro.  http://hackage.haskell.org/package/hbro-contrib-1.0.0.0 (koral)
09:24:14 <noviceprogrammer> ah sorry here it is: http://ideone.com/07p0B
09:24:30 <ski> noviceprogrammer : you want `countChange (money - coin) (coin:coins)' -- otherwise it's parsed as `(countChange (money - coin) coin):coins'
09:24:36 <srhb> noviceprogrammer: Now you have the same error twice
09:24:40 <srhb> :-)
09:25:01 <noviceprogrammer> ^^
09:25:07 <srhb> noviceprogrammer: Same goes for the pattern. (coin:coins), not coin:coins
09:25:32 <nicoo> You are all making me think of ducks
09:25:51 <srhb> nicoo: Huh?
09:25:51 <ski> noviceprogrammer : the brackets around `coin:coins' are need (in this case) to make Haskell parse what you're written correctly (i.e. in the way you want, instead of parsing it in another way)
09:26:42 <noviceprogrammer> looks like the 'functions are first-class objects' parsing needs getting used to ^^
09:26:52 * ski . o O ( <http://www.neilvandyke.org/quack/> )
09:27:32 <noviceprogrammer> http://ideone.com/d3P6w looks good now, but line 4 looks way too long on my 24x79 terminal. How do I break down long functions to multiple lines in haskell?
09:27:41 <nicoo> srhb: Ducks' quack is « coin » in French
09:27:49 <ski> noviceprogrammer : this is unrelated to functions as first-class values. it's just that if you write `f x:xs', Haskell will parse this as if you've written `(f x):xs' -- if you mean `f (x:xs)', you have to write the brackets
09:27:52 <srhb> Ah!
09:28:09 <sangiang> does anyone here successfully install wx with Haskell platform 2012.2.0.0 on Windows?
09:28:26 <srhb> sangiang: Not without sacrificial babies and kittens.
09:28:55 <ski> noviceprogrammer : we say that "function application binds tighter than any other operator"
09:28:58 <noviceprogrammer> right
09:29:18 <mcstar> it is like latex pijamas
09:29:20 <srhb> noviceprogrammer: You can pretty much break that line anywhere you want
09:29:24 <srhb> noviceprogrammer: As long as you pay respect to indentation.
09:29:41 <noviceprogrammer> what kind of indentation does haskell require?
09:29:50 <hiptobecubic> mcstar, are we talking about monads again?
09:29:51 <sangiang> no?
09:30:11 <mcstar> hiptobecubic: no, precedence of function application
09:30:32 <ski> (or at least any other *normal* operator -- in fact `f ~(x:xs)',`f !x',`f C {...}' will actually mean `f (~(x:xs))',`f (!x)',`f (C {...})' -- but those three are the only exception to this i can think of -- and those are not normal operators)
09:30:46 <noviceprogrammer> http://ideone.com/buzOY looks elegant now ^^ this was just to compare Haskell to Scala: http://ideone.com/LWB5n
09:31:11 <mcstar> scala and haskell are very different
09:31:28 <noviceprogrammer> haskell seems faster
09:31:28 <mcstar> the biggest difference is scala doesnt try to avoid success at all costs
09:31:53 * cmccann has the impression that scala was created by taking the most awkward and confusing aspects of Haskell and Java and combining them
09:31:56 <ski> noviceprogrammer : now, `(money < 0) || (null coins)' is simpler written as `money < 0 || null coins'
09:32:26 <ski> noviceprogrammer : and `(countChange money coins) + (countChange (money - coin) (coin:coins))' is simpler written as `countChange money coins + countChange (money - coin) (coin:coins)'
09:32:41 <noviceprogrammer> right
09:32:53 <mcstar> there is an interesting fact: the mandelbrot problem on the shootout page, solved by scala is only beaten by fortran
09:33:03 <ski> (application still binds tighter than operators. and the `<' operator binds tighter than the `||' one)
09:33:24 <Puffton> > [(x, y) | (x:xs) <- tails "abc" , y <- (x:xs)]
09:33:25 <Puffton> > [(x,y) | x  <- head ["abc"], y <- tail "abc"]
09:33:25 <lambdabot>   [('a','a'),('a','b'),('a','c'),('b','b'),('b','c'),('c','c')]
09:33:26 <lambdabot>   [('a','b'),('a','c'),('b','b'),('b','c'),('c','b'),('c','c')]
09:33:37 <Puffton> err
09:33:46 * hackagebot applicative-quoters 0.1.0.8 - Quasiquoters for idiom brackets and an applicative do-notation  http://hackage.haskell.org/package/applicative-quoters-0.1.0.8 (BenMillwood)
09:33:52 <Puffton> > [(x,y) | xs@(x:_) <- tails "abc" , y <- xs]
09:33:53 <lambdabot>   [('a','a'),('a','b'),('a','c'),('b','b'),('b','c'),('c','c')]
09:34:03 <hiptobecubic> mcstar, that shocked me also
09:34:08 <noviceprogrammer> what does the joke 'avoid success at all costs' mean?
09:34:20 <mcstar> hiptobecubic: i dont read scala, dont know why is that so
09:34:33 <hiptobecubic> noviceprogrammer, it means that if haskell goes "enterprise" then it will no longer be ok to break all compatibility every few months with new features
09:34:40 <ski> Puffton : `head ["abc"]' is the same as `"abc"'
09:35:04 <dfordivam> If I am hacking a haskell library, then how should I import the Lib directly from source, (i e without doing a cabal install method)
09:35:34 <hiptobecubic> dfordivam, import MyLib  ?
09:35:42 <hiptobecubic> dfordivam, also probably have to pass -imylibdir to ghc
09:35:44 <mcstar> i think it would onnly result in forking ghc, a stable one, and one for research
09:36:01 <hiptobecubic> mcstar, but the research one will be hampered by concerns for the stable one
09:36:04 <dfordivam> any alternatives of -i option in ghci
09:36:19 <hiptobecubic> why introduce a feature into the research one if you *know* it can never go into the stable one?
09:36:24 <hiptobecubic> then it's just a new language
09:36:37 <hiptobecubic> dfordivam, be in the directory with the module?
09:36:49 <hiptobecubic> ghci also accept -i though
09:37:01 <mcstar> there is :add
09:37:03 <Puffton> ski, yeah it was a copy/paste mistake
09:37:18 <hiptobecubic> i think
09:37:52 <ski> > [(x, y) | (x:xs) <- tails "abcd" , y <- xs]
09:37:53 <lambdabot>   [('a','b'),('a','c'),('a','d'),('b','c'),('b','d'),('c','d')]
09:38:22 <Puffton> > [(x, y) | (x:xs) <- tails "abcd" , y <- (x:xs)]
09:38:23 <lambdabot>   [('a','a'),('a','b'),('a','c'),('a','d'),('b','b'),('b','c'),('b','d'),('c'...
09:38:28 <Puffton> This has the desired effect too
09:38:41 <ski> yes
09:38:45 <Puffton> it's ok to check distance with oneself
09:38:46 <Sculptor> nbj
09:39:04 <ski> > [(x, y) | xs@(x:_) <- tails "abcd" , y <- xs]  -- is just a shorthand way of writing that
09:39:04 <lambdabot>   [('a','a'),('a','b'),('a','c'),('a','d'),('b','b'),('b','c'),('b','d'),('c'...
09:39:10 <Puffton> basically both y and x will iterate through the possible chars once
09:39:30 <hiptobecubic> > replicateM 2 "abcd"
09:39:31 <lambdabot>   ["aa","ab","ac","ad","ba","bb","bc","bd","ca","cb","cc","cd","da","db","dc"...
09:39:49 <dfordivam>  hiptobecubic:  What if the lib is already cabal installed, will ghci override it and use the one in current dir?
09:40:01 <hiptobecubic> dfordivam, i don't know, unfortunately.
09:41:10 <ski> > replicateM 2 "abc"
09:41:11 <lambdabot>   ["aa","ab","ac","ba","bb","bc","ca","cb","cc"]
09:41:13 <ski> > replicateM 3 "ab"
09:41:14 <lambdabot>   ["aaa","aab","aba","abb","baa","bab","bba","bbb"]
09:52:24 <noviceprogrammer> pattern matching ftw
09:53:23 <ski> noviceprogrammer : notice than instead of `null', you could use a pattern-match
09:53:40 <noviceprogrammer> I could?
09:53:49 <noviceprogrammer> would it be an extra case?
09:53:52 <hiptobecubic> []
09:53:55 <ski> yes, but (in this case), you'd have to split that line in two
09:54:10 <ski>   countChange money coins | money < 0 || null coins = 0
09:54:11 <ski> becomes
09:54:19 <ski>   countChange money coins | money < 0 = 0
09:54:28 <ski>   countChange money [    ] = 0
09:54:36 <hiptobecubic> It's good to do though. I think the compiler has a better chance of clever optimization that way
09:54:47 <ski> probably, yes
09:54:55 <noviceprogrammer> so best to give the compiler as many cases as i can?
09:54:57 <hiptobecubic> as opposed to waiting on the result of some conditional
09:55:02 <noviceprogrammer> right
09:55:12 <noviceprogrammer> but 1 extra line :(
09:55:23 <hiptobecubic> noviceprogrammer, it's usually better to make things as compile-time as possible, with respect to optimization anyway
09:55:33 <hiptobecubic> noviceprogrammer, 1 extra line, which is more readable than the original
09:55:37 <ski> noviceprogrammer : generally, it's better to choose cases by pattern-matching, rather than guards (or `if'-`then'-`else')
09:56:07 <noviceprogrammer> right
09:56:29 <Eduard_Munteanu> if-then-else is pretty awkward most of the times, anyway
09:57:25 <noviceprogrammer> ghc is great
09:57:41 <noviceprogrammer> I want to write a turing machine
09:57:45 <ski> noviceprogrammer : note that "pattern-matching" includes both the ordinary matching in arguments for a function defined by several defining equations/clauses, *as well* as using `case'-`of'
09:58:10 <noviceprogrammer> so theres two kinds of pattern-matching in Haskell?
09:58:35 <geekosaur> no, those are the same mechanism
09:58:47 <sclv> just two slightly different syntaxes
09:58:50 <geekosaur> (and in fact function arguments are a special case of case-of
09:59:02 <ski> syntactically, pattern-matching (splitting into cases) occurs in two variants, yes -- but conceptually it's the same thing
09:59:07 <noviceprogrammer> right
09:59:13 <ski> if you write
09:59:21 <ski>   f [    ] = ...
09:59:30 <noviceprogrammer> should I prefer the case style? or the function parameter style?
09:59:30 <ski>   f (x:xs) = ..x..xs..
09:59:36 <ski> then this is the same as writing
09:59:42 <ski>   f xs0 = case xs0 of
09:59:52 <ski>     [  ] -> ...
09:59:57 <ski>     x:xs -> ..x..xs..
10:00:01 <Eduard_Munteanu> noviceprogrammer: usually you should pattern-match on parameters
10:00:26 <ski> noviceprogrammer : generally, if you can avoid using `case', it will usually be more readable (imo, at least)
10:00:52 <hiptobecubic> noviceprogrammer, you can make some *simple* examples and look at the Core that ghc generates. If they look the same, then it doesn't matter which way you did it.
10:00:54 <lpvb> are haskell libs usually linked in statically?
10:00:55 <ski> noviceprogrammer : however, e.g. if you have lots of extra arguments which you're not really doing any non-trivial matching on, a `case' might be preferable
10:00:59 <Eduard_Munteanu> case-of makes sense in case you define stuff in the local scope
10:01:02 <hiptobecubic> lpvb, yes
10:01:29 <ski> noviceprogrammer : also, if the price of not using `case' is to define a new helper function (by pattern-matching), it might not be worth it (in terms of readability)
10:01:39 <Eduard_Munteanu> e.g. f xs0 = case xs0 of [...] where foo = bar
10:02:16 <Eduard_Munteanu> If you pattern-matched in the arguments, you'd have to define foo at the top-level, or redefine it for each case.
10:02:40 <ski> noviceprogrammer : also, as Eduard_Munteanu seemed to be implying, in some cases you're "deep" in the body of a definition, so `case' might be the only alternative (apart from defining a helper)
10:02:40 <noviceprogrammer> is there any Haskell style-guide I can read?
10:02:48 <hiptobecubic> noviceprogrammer, github
10:02:53 <noviceprogrammer> ^^
10:02:55 <lpvb> hiptobecubic: do only the functions that are needed get linked in? if not, how do I tell ghc to only include what the program needs?
10:03:01 <hiptobecubic> noviceprogrammer, i think the Snap team has a style guide
10:03:18 <hiptobecubic> noviceprogrammer, other than that i don't think there's the same kind of religion around it like there is in, for example, C
10:03:36 <noviceprogrammer> ah
10:03:49 <noviceprogrammer> q
10:03:53 <Nafai> noviceprogrammer: This is one I follow: https://github.com/tibbe/haskell-style-guide
10:03:54 <hiptobecubic> except for list-like separators being at the beginning of lines, it's usually just however it looks good ends up being the 'normal' way
10:04:08 <hiptobecubic> and once you're used to that, you think that looks good too
10:04:21 <ski> well, i would say that `$' appears to be used too much (in my taste) (mostly by newbies ?)
10:04:57 <hiptobecubic> ski, i guess that's a fairly agreed-upon "rule"
10:05:08 <hiptobecubic> Something like one-$-per-line
10:05:11 <mcstar> you need to use it, to differentiate haskell from lisp
10:05:11 <noviceprogrammer> what does $ do? Does it chain functions?
10:05:28 <hiptobecubic> noviceprogrammer, it applies them, but with lowest possible precedence
10:05:30 <ski> typically, i only use `$' if either it is followed by a lambda or a keyword, or in the form `foo x . bar y z . baz $ blah'
10:05:34 <hiptobecubic> @src ($)
10:05:34 <lambdabot> f $ x = f x
10:05:51 <hiptobecubic> noviceprogrammer, but "f" and "x" will both be fully evaluated first
10:05:59 <ski> hiptobecubic : nope
10:06:07 <hiptobecubic> ski, resolved?
10:06:08 <sclv> there's also neil mitchell's hlint
10:06:13 <sclv> that makes lots of helpful suggestions
10:06:17 <sclv> w/r/t style
10:06:18 <ski> hiptobecubic : you're thinking of `($!)', i think
10:06:30 <hiptobecubic> ski, evaluated was the wrong word, i agree
10:07:13 <mcstar> f x , no operator, f $ x thers the operator, now you can assign precedence
10:07:15 <mcstar> thats all
10:07:18 <mcstar> no?
10:07:21 <hiptobecubic> ski, but how does one phrase it then? I guess it does something like  f $ x = f (x) ?
10:07:30 <hiptobecubic> mcstar, yes but the intuition behind what it does
10:07:44 <ski> noviceprogrammer : if you write `foo x $ bar y z $ baz $ blah', then this is the same as `foo x (bar y z (baz (blah)))' -- but we tend to prefer the form `foo x . bar y z . baz $ blah'
10:08:21 <hiptobecubic> noviceprogrammer, which is basically "build a big function on the left and then apply it to the right"
10:08:23 <mcstar> hiptobecubic: except, that f (x) is f x in haskell, but you could say, that if f(x) is interpreted in C for example
10:08:50 <noviceprogrammer> what does the . operator do?
10:08:58 <ski> function composition
10:09:07 <noviceprogrammer> haskell has lots of interestig operators ^^
10:09:18 <latro`a> (f . g) x = f (g x)
10:09:35 <ski> > (tail . head . tail) [[1,2,3],[4,5,6],[7,8,9]]
10:09:37 <hiptobecubic> mcstar, i'm not suggesting that f(x) is actually different from f x, just stressing that the inside of the parens is evaluated first... which only matters if x is many terms
10:09:37 <lambdabot>   [5,6]
10:09:37 <latro`a> I feel like just saying "function composition" sometimes confuses people
10:09:47 <ski> > tail (head (tail [[1,2,3],[4,5,6],[7,8,9]]))
10:09:48 <lambdabot>   [5,6]
10:09:50 <hiptobecubic> cos sin 0   vs   cos (sin 0)
10:09:52 <Martty> function composition is very intuitive
10:09:57 <mcstar> noviceprogrammer: great package http://hackage.haskell.org/packages/archive/plumbers/0.0.2/doc/html/Control-Plumbers-Monad.html
10:10:01 <Martty> its sequential application of stuffs
10:10:08 <latro`a> Martty, not as much when you have several arguments
10:10:14 <latro`a> because people get thrown off by currying
10:10:37 <noviceprogrammer> I like how in haskell, partial function application is everywhere :D
10:10:38 <parcs`> anyone have a copy of ghc 7.6?
10:10:48 <latro`a> ....the hell is that
10:10:57 <hiptobecubic> noviceprogrammer, it is something you will begin to miss very quickly in other languages i think
10:11:12 <ski> > (unwords . map reverse . words) "esehT sdrow erew desrever"  -- noviceprogrammer, see if you can figure out this one
10:11:14 <lambdabot>   "These words were reversed"
10:11:42 * noviceprogrammer scratches head
10:12:07 <hiptobecubic> it's a clever example. Read the entire thing right to left :D
10:12:10 <noviceprogrammer> words turns a [Char] into a [[Char]] ?
10:12:15 <ski> > words "a sleepy cat purrs"
10:12:16 <lambdabot>   ["a","sleepy","cat","purrs"]
10:12:18 <hiptobecubic> :t words
10:12:19 <lambdabot> String -> [String]
10:12:25 <parcs`> can anyone with ghc 7.6 try inputting this sequence of commands in ghci and tell me whether ghci segfaults http://paste.debian.net/191951/
10:13:02 <noviceprogrammer> so it reverses words in-place, but why do we need the function composition operator in there?
10:13:12 <donri> [why] isn't applicative strong enough for monad comprehensions?
10:13:16 <ski> we *could* have written it like
10:13:16 <mcstar> in-place?
10:13:28 <ski> > unwords (map reverse (words "esehT sdrow erew desrever"))
10:13:28 <ozgura> parcs`: mine does.
10:13:29 <lambdabot>   "These words were reversed"
10:13:30 <hiptobecubic> noviceprogrammer, it's not in-place
10:13:35 <byorgey> parcs`: mine too.
10:13:46 <noviceprogrammer> right
10:13:49 <ski> > unwords $ map reverse $ words $ "esehT sdrow erew desrever"  -- or this, if you really insist
10:13:49 <byorgey> parcs`: file a ticket?
10:13:49 <donri> this looks an awful lot like a monad comprehension http://hackage.haskell.org/packages/archive/applicative-quoters/0.1.0.7/doc/html/Control-Applicative-QQ-ADo.html
10:13:50 <lambdabot>   "These words were reversed"
10:14:09 <parcs`> byorgey: will do, thanks
10:14:17 <ski> noviceprogrammer : however, now consider the following definition :
10:14:36 <ski>   reverseWords s = (unwords . map reverse . words) s
10:14:53 <noviceprogrammer> :t reverseWords
10:14:54 <lambdabot> Not in scope: `reverseWords'
10:14:58 <noviceprogrammer> :(
10:15:24 <ski> because we used function composition here, we can now "cancel" the `s' at the end of both side of the equality, getting
10:15:26 <hiptobecubic> > let f = foldr1 (.) [unwords, map reverse, words] in f "abc def ghi"
10:15:27 <lambdabot>   Couldn't match expected type `[GHC.Types.Char]'
10:15:27 <lambdabot>         against inferred ty...
10:15:30 <hiptobecubic> rats
10:15:31 <ski>   reverseWords = unwords . map reverse . words
10:15:39 <mcstar> Martty: this is the sequential(nested) application of functions: f (g (h x)), but this is (f . g . h) x is the application of 1 function
10:16:09 <noviceprogrammer> so reverseWords becomes a function that takes no arguments?
10:16:10 <ski> noviceprogrammer : iow, `reverseWords' *is* the function, which processes input first with `words', then continues with `map reverse', and finally with `unwords'
10:16:25 <ski> `reverseWords' is still a function which takes one argument
10:16:36 <Martty> mcstar: connecting the dots
10:16:52 <ski> however, in the *definition* of it, we have changed the focus from what the function *does* when given an argument, to what the function *is*
10:17:10 <ski> @let reverseWords = unwords . map reverse . words
10:17:11 <lambdabot>  Defined.
10:17:13 <noviceprogrammer> so compared to nesting with parentheses, . truly composes functions like in maths?
10:17:25 <ski> > reverseWords "Rats live on no evil star."
10:17:27 <lambdabot>   "staR evil no on live .rats"
10:17:56 <ski> @let reverseWordOrder = unwords . reverse . words
10:17:57 <lambdabot>  Defined.
10:18:04 <ski> > reverseWordOrder "Rats live on no evil star."
10:18:06 <lambdabot>   "star. evil no on live Rats"
10:18:19 <ski> > reverse "Rats live on no evil star."
10:18:20 <lambdabot>   ".rats live on no evil staR"
10:18:25 <noviceprogrammer> ^^
10:18:43 <hiptobecubic> :t foldr1
10:18:44 <lambdabot> forall a. (a -> a -> a) -> [a] -> a
10:18:50 <ski> note the difference between the three functions `reverse',`reverseWords',`reverseWordOrder'
10:19:05 <hiptobecubic> ah, you can't change the type of the function halfway... right
10:19:09 <noviceprogrammer> :t reverse
10:19:10 <lambdabot> forall a. [a] -> [a]
10:19:16 <noviceprogrammer> :t reverseWords
10:19:16 <ski> noviceprogrammer : "so compared to nesting with parentheses, . truly composes functions like in maths?" -- yes
10:19:17 <lambdabot> String -> String
10:19:42 <ski> `reverse' reverses any list (and `String's are lists of `Char'acters)
10:19:42 <noviceprogrammer> right
10:20:08 <noviceprogrammer> what's up with the 'forall a.' in the type signature?
10:20:12 <ski> noviceprogrammer : sometimes, it's quite nice to be able to define a function like a "pipe-line" as above
10:20:16 <hiptobecubic> noviceprogrammer, also like in maths.
10:20:30 <ski> noviceprogrammer : that's GHC's way of saying that these are polymorphic functions
10:20:37 <noviceprogrammer> right
10:20:38 <hiptobecubic> forall a, this function is a mapping from [a] to [a]
10:21:08 <Eduard_Munteanu> noviceprogrammer: and it's normally omitted
10:21:09 <ski> in standard Haskell, one'd e.g. say
10:21:20 <ski>   zip :: [a] -> [b] -> [(a,b)]
10:21:26 <ski> but GHC says
10:21:31 <ski>   zip :: forall a b. [a] -> [b] -> [(a,b)]
10:21:36 <ski> the meaning is still the same
10:21:42 <ski> it's just that the latter is more explicit
10:22:45 <ski> saying that `zip' is a polymorphic function here means that, regardless of which actual *concrete* types we replaces the type variables `a' and `b' with, we get a valid possible type signature for `zip'
10:22:50 <ski> e.g.
10:23:01 <ski>   zip :: [Int] -> [Bool] -> [(Int,Bool)]
10:23:21 <noviceprogrammer> so it's like C++ templates?
10:23:30 <ski>   zip :: [[Double]] -> [(String,Int)] -> [([Double],(String,Int))]
10:23:49 <ski>   zip :: [Int -> Int] -> [Bool] -> [(Int -> Int,Bool)]
10:23:53 <ski> &c.
10:24:21 <ski> noviceprogrammer : yeah -- at least the variety of templates which takes a type argument (and behaves uniformly in it)
10:24:35 <ski> given
10:24:40 <ski>   zip :: [a] -> [b] -> [(a,b)]
10:25:01 <ski> there is *no* way for `zip' to be able to figure out at run-time which types `a' and `b' actually are
10:25:19 <ski> iow, `zip' runs the *same* code, regardless of which types `a' and `b' turn out to be
10:25:45 <ski> this means that the only thing `zip' can do with the elements of those lists is "pass them around"
10:25:51 <ski> it can't "look inside them"
10:26:19 <ski> this general property of polymorphic functions (called "parametricity") is sometimes quite nice to have
10:26:26 <Sharyari> Hi. I need to know if a real number is a natural number, is there a function for this?
10:26:44 <mcstar> easy, it is not
10:26:46 <ski> just by looking at the type signature of the operation, you can already tell some things the function *can't* do (and you can depend on that)
10:27:30 <ski> Sharyari : there is no algorithm for checking of a real number is actually a natural number -- this is undecidable (in the general case)
10:28:18 <ski> (in specific cases, when one's only interested in real numbers of some particular form, it can happen that there is an algorithm)
10:28:20 <Sharyari> Yea, I see the problem. But with a certain precisio?
10:28:27 <Sharyari> precision*
10:28:43 <mcstar> do you really have reals, or rationals?
10:29:25 <Sharyari> No idea actually, never used anything else that integers before. What I'm trying to do is to see if the square root of a number is a natural number
10:29:58 <mcstar> use integer square root
10:30:13 <mcstar> if the square of that is the same number, it is
10:30:19 <ski> > showCReal 2 (exp pi - pi)
10:30:20 <lambdabot>   "20.0"
10:30:24 <ski> > abs ((exp pi - pi) - 20 :: CReal) < 0.001
10:30:25 <lambdabot>   True
10:30:27 <byorgey> Sharyari: ah. In that specific case, you should use an algorithm to compute the rounded-down square root of an integer using all integer operations.  Then square it and see if you get the original number.
10:30:57 <ski> Sharyari : you can do something like that -- no guarantee of termination, though, so it's strictly speaking not an algorithm
10:31:35 <Sharyari> Of course, thank you ski byorgey mcstar  :)
10:32:22 <byorgey> Sharyari: there seems to be an implementation on this page: http://www.haskell.org/haskellwiki/Lambda_lifting
10:33:49 * hackagebot aeson-pretty 0.6.2 - JSON pretty-printing library and command-line tool.  http://hackage.haskell.org/package/aeson-pretty-0.6.2 (FalkoPeters)
10:42:59 <Taslem> How would I go about detecting key presses in the typical terminal?
10:43:24 <Iceland_jack> xev?
10:43:37 <Iceland_jack> sorry, probably not what you're looking for
10:45:19 <Taslem> Effectively what I need is someway to do "getChar" that won't wait for a line-end to feed in.
10:46:11 <byorgey> Taslem: turn off buffering.  hSetBuffering stdin NoBuffering
10:46:42 <Taslem> Doesn't seem to do anything.
10:47:36 <byorgey> Taslem: it Works For Me (tm).  Can you paste your code, along with a description of its expected and actual behavior?
10:48:04 <Taslem> main = do 	hSetBuffering stdin NoBuffering 	loop  loop = do 	p <- getChar 	putStrLn "#" 	putStrLn (p:"") 	loop
10:48:07 <Taslem> Er.
10:48:14 <Taslem> Recommend a paste site?
10:48:23 <byorgey> Taslem: hpaste.org
10:48:27 <latro`a> @where hpaste
10:48:27 <lambdabot> http://hpaste.org/
10:48:52 <Taslem> http://hpaste.org/75126
10:49:16 <Taslem> Missing the import, sorry. System.IO
10:49:43 <byorgey> Taslem: and what happens when you run that code?
10:50:04 <noviceprogrammer> what happens when you zip two lists of unequal size?
10:50:11 <byorgey> when I run it, it echoes # and the character I pressed after each keypress, without waiting for a newline
10:50:13 <Taslem> It prints nothing until I type, when I do it says what I type, but it doesn't print each of the characters/# until I press return.
10:50:27 <Taslem> So, the getChar is still blocking.
10:50:28 <ion> taslem: Add hFlush stdout after the putStrLns.
10:50:30 <byorgey> noviceprogrammer: the end of the longer list gets dropped
10:50:55 <ClaudiusMaximus> > zip "try it" "and see for yourself"
10:50:56 <lambdabot>   [('t','a'),('r','n'),('y','d'),(' ',' '),('i','s'),('t','e')]
10:50:56 <ion> taslem: stdout is still buffered.
10:50:59 <byorgey> Taslem: also, what OS are you on?
10:51:07 <Taslem> Windows. I know that can be an issue.
10:51:13 <byorgey> ion: but isn't it line-buffered by default?
10:51:22 <byorgey> oh, well, I don't know what the default is on Windows
10:51:58 <ion> byorgey: Ah, it should be. I didn’t think of that.
10:52:33 <Taslem> So should I also tell stdout to be nobuffering?
10:53:09 <byorgey> Taslem: ah. It seems this is a known bug with GHC on Windows: http://hackage.haskell.org/trac/ghc/ticket/2189
10:53:12 <ion> taslem: hFlush would be better IMO. You wouldn’t lose the beneficial buffering. Not that it really matters in this piece of code.
10:53:32 <ion> taslem: Although even hFlush shouldn’t be necessary with LineBuffering.
10:53:44 <latro`a> maybe you should do this real fast:
10:53:51 <Taslem> ion: The issue is solely with stdin, not stdout
10:54:00 <Taslem> byorgey: thanks... Though ultimately not helpful.
10:54:22 <latro`a> main = do {mi <- hGetBuffering stdin; mo <- hGetBuffering stdout; print mi; print mo}
10:54:33 <ion> taslem: Btw, putStrLn ['#',p]
10:55:16 <byorgey> Taslem: right, sorry.  You could try to see how e.g. haskeline deals with this.
10:55:18 <byorgey> @package haskeline
10:55:18 <lambdabot> http://hackage.haskell.org/package/haskeline
10:55:22 <Taslem> ion: I wanted them on separate lines. The point of the '#' is a divider so I can tell where what I press and what it prints begin and end.
10:57:47 <byorgey> oh, never mind.  Haskeline goes all the way down to implementing stuff in terms of Win32 system calls etc.
10:57:54 <Taslem> Yeah, that's what it looks like.
10:57:59 <byorgey> but there must be an easier workaround.
10:58:01 <Taslem> win_console.h
10:58:24 <Taslem> I don't think this is really isolated to Haskell. I recall it's about as difficult in C...
10:58:33 <Taslem> Though that seems strange.
10:58:44 <ion> taslem: Ah, i forgot that the first one was a “Ln” as well. In any case, (p:"") can also be written as [p].
10:59:21 <ski> @src zip
10:59:21 <lambdabot> zip (a:as) (b:bs) = (a,b) : zip as bs
10:59:21 <lambdabot> zip _      _      = []
10:59:24 <ski> noviceprogrammer : per ^
11:00:05 <ski> > zip [0 ..] "hello"  -- a nice simple way to add index numbers
11:00:06 <lambdabot>   [(0,'h'),(1,'e'),(2,'l'),(3,'l'),(4,'o')]
11:00:34 <noviceprogrammer> right
11:00:52 <noviceprogrammer> ah was wondering where zip would be useful ^^
11:00:59 <ski> > (zip `ap` tail) [0,1,2,3,4]  -- the Aztec god of consecutive pairs
11:01:00 <lambdabot>   [(0,1),(1,2),(2,3),(3,4)]
11:01:38 <ski> @where sneaky
11:01:39 <lambdabot> dropFromEnd n xs = zipWith const xs (drop n xs)
11:01:52 <ski> i forgot who suggested that ^ one
11:03:12 <ski> noviceprogrammer : note that `zip = zipWith (,)', and `zipWith f as bs = map (uncurry f) (zip as bs)'
11:03:31 <nand`> hopefully not with those two exact definitions
11:03:39 <ski> (that last can also be expressed like `zipWith (curry g) as bs = map f (zip as bs)')
11:03:56 <ski> nand` : hehe, these are theorems, not definitions :)
11:04:29 <carter> hello!
11:04:40 <ion> That last expression is probably confusing especially to newbies.
11:05:43 <ski> possibly
11:06:43 <ski> noviceprogrammer : those were just meant to show how you can translate uses of `zip' with uses of `zipWith', and vice versa -- if you don't understand this, don't worry, just ignore this for now
11:10:07 <astry> hey guys..
11:10:16 <astry> ..how can i repeat an action n times?
11:10:34 <danharaj> replicateM
11:10:37 <danharaj> :t replicateM
11:10:38 <astry> oo
11:10:38 <lambdabot> forall (m :: * -> *) a. (Monad m) => Int -> m a -> m [a]
11:11:10 <ski> @type replicateM_
11:11:11 <lambdabot> forall (m :: * -> *) a. (Monad m) => Int -> m a -> m ()
11:11:18 <danharaj> I need `traverse` for unboxed vectors (restricted of course). I'm not sure how to write it to help fusion?
11:11:21 <noviceprogrammer> right
11:11:30 <ski> for when you don't care about the results for each repeat
11:11:53 <shachaf> @ty replicateM__
11:11:54 <lambdabot> forall (m :: * -> *) a. (Monad m) => Int -> m a -> m ()
11:12:03 <shachaf> Er, never mind.
11:12:43 <astry> @type (liftM last) $ replicateM
11:12:44 <lambdabot>     Couldn't match expected type `[a]'
11:12:45 <lambdabot>            against inferred type `m a1 -> m [a1]'
11:12:45 <lambdabot>     Probable cause: `replicateM' is applied to too few arguments
11:12:57 <astry> hrm
11:13:13 <benmachine> @type (liftM last .) . replicateM
11:13:14 <lambdabot> forall a (m :: * -> *). (Monad m) => Int -> m a -> m a
11:13:27 <benmachine> although hmm
11:14:01 <benmachine> @type foldr1 (>>) . replicate
11:14:02 <lambdabot>     Couldn't match expected type `[m a]'
11:14:02 <lambdabot>            against inferred type `a1 -> [a1]'
11:14:02 <lambdabot>     Probable cause: `replicate' is applied to too few arguments
11:14:17 <benmachine> @type (foldr1 (>>) .) . replicate
11:14:18 <lambdabot> forall (m :: * -> *) a. (Monad m) => Int -> m a -> m a
11:14:46 <shachaf> Why foldr1? :-(
11:14:52 <shachaf> Oh, you're liftMing last.
11:16:05 <ski> @type foldM (flip const) (error "no actions to run") .: replicate
11:16:06 <lambdabot> forall a (m :: * -> *). (Monad m) => Int -> m a -> m a
11:16:42 <ski> hm, `foldr1' looks nicer
11:30:03 <eilyx> how do i get standard deviation?
11:33:27 <snickerz777> hello, i have a problem by installing wxwindows at win7. when i try to set the wxcfg flag at wx-config, it says, that i have no valid studio.h there
11:49:03 <astry> snickerz777: you sure it says studio.h
12:01:01 <benmachine> I feel like I've spent some of my Haskell career searching for something useful to do
12:01:08 <benmachine> and some of it searching for someone to do useful things for me
12:01:34 <benmachine> I wonder if we could not benefit from a list of "here are things that I need doing and I think are god for the community"
12:01:35 <Sculptor> you can base your career on haskell?
12:01:37 <benmachine> that people can add to
12:01:48 <Sculptor> are there haskell jobs
12:01:48 <hiptobecubic> benmachine, i'll start
12:01:50 <benmachine> Sculptor: I'm not using the term career literally (other people could do)
12:01:51 <hiptobecubic> parallel cabal
12:02:06 <benmachine> hiptobecubic: isn't that a GSoC project?
12:02:28 <hiptobecubic> benmachine, at the package level it was i guess
12:02:38 <hiptobecubic> but if you have one package with 300 files, it's still serial
12:02:44 <benmachine> oh
12:02:50 <benmachine> that's more GHC than cabal, isn't it?
12:03:06 <benmachine> cabal just runs ghc --make and lets GHC get on with it
12:03:14 <hiptobecubic> does ghc do all of the resolution of what to build?
12:03:28 <benmachine> GHC does all of the dependency analysis I think
12:03:37 <Ralith> benmachine: contribute to idris!
12:03:47 <benmachine> Ralith: I'm currently in the second phase, not the first one :P
12:03:51 <hiptobecubic> I don't know much about the internals of GHC, but I don't understand why this is such an enormous problem
12:03:57 <benmachine> (I need people to do things, not things to do)
12:04:22 <hiptobecubic> if the files can all be compiled individually, then it seems like a pool-of-workers approach should be fine no?
12:04:27 <benmachine> hiptobecubic: it may not be /enormous/ but it's non-trivial, so it's only going to happen if someone does the legwork
12:04:29 <Ralith> benmachine: aw.
12:04:56 <benmachine> Ralith: I'm trying to recruit some friends though, I'll let you know if any of them get both competent and bored :P
12:05:05 <benmachine> (don't hold your breath)
12:05:11 <Ralith> :P
12:05:28 <hiptobecubic> i'm busy and incompetent, if that's of any help
12:06:08 <benmachine> hiptobecubic: if that's not of any help, do you stop being busy?
12:06:59 <Saizan> benmachine: what useful things are you needing done?
12:07:30 <benmachine> Saizan: by this stage in the conversation I've forgotten exactly what I had in mind
12:07:45 <Saizan> heh
12:08:03 <benmachine> I have a few things, though
12:08:33 <benmachine> like "get these useful things into the libraries process"
12:08:43 <benmachine> depends on: "find out what the libraries process actually is"
12:09:27 <benmachine> oh, "write a locale package to replace old-locale"
12:09:28 <benmachine> that's a good one
12:09:39 <benmachine> or just... update old-locale, I dunno
12:09:43 <benmachine> find out what needs to be done there and do it
12:10:00 <Saizan> "rename old-locale to locale"
12:10:05 <benmachine> haha
12:10:07 <benmachine> that would work too
12:10:22 <benmachine> but it's worth at least looking to see if there's anything that ought to be done
12:10:28 <benmachine> time is a way better library than old-time
12:10:44 <osa1> does ghci have a command for showing source of a function (when source is available)
12:10:46 <hiptobecubic> beggars can't be choosers
12:10:47 <Saizan> uh, i have something like "ornaments for zippers"
12:11:09 <hiptobecubic> osa1, *that* is a feature i would very much like to have
12:11:56 <osa1> @source fix
12:11:57 <lambdabot> fix not available
12:11:59 <hiptobecubic> the text of a definition is so small compared to the enormous code that is required to implement it, i wish the text of the functions was just appended to the binary libraries so ghc could get to it if needed
12:12:02 <osa1> @type fix
12:12:02 <Saizan> osa1: nope, there are a few programs producing TAGS or ETAGS files though
12:12:03 <lambdabot> forall a. (a -> a) -> a
12:12:19 <benmachine> maybe I should write a webapp to track "generic haskell community tasks" that can be voted on
12:12:32 <benmachine> or maybe that's what trac does :P
12:12:34 <benmachine> but I don't like trac
12:12:48 <benmachine> it has silly custom markup and keeps breaking
12:12:49 * hiptobecubic hates trac
12:12:52 <Saizan> yeah, the gsoc trac doesn't get much traffic
12:13:07 <Ralith> hiptobecubic: I think the best solution would be to do what C does and attach source location pointers to the binaries.
12:13:47 <edwardk> osa1: set up hasktags
12:13:53 <benmachine> hiptobecubic: in some cases the code will be in the interface file, for inlining
12:14:15 <benmachine> it might be optimised to the point of unrecognisability though >_>
12:14:21 <osa1> edwardk: thanks. what sould I add to my ghci config file after that ?
12:14:21 <benmachine> probably not
12:14:22 <edwardk> osa1: https://github.com/ekmett/lens/blob/master/.vim.custom shows how i get vim to rebuild my tags files for me using hasktags
12:14:30 <benmachine> probably the code for inlining is relatively unmolested
12:14:47 <edwardk> osa1: that doesn't get it for you in ghci, but it at least gets you the ability to :tj foo inside vim
12:15:02 <osa1> edwardk: oh, ok. thanks.
12:16:31 <hiptobecubic> benmachine, but what i'm saying is that it would be very easy to just include the source file, compressed(?), somewhere in the "data" part of the library
12:16:43 <hiptobecubic> by easy i mean, easy-sounding
12:16:50 <benmachine> hiptobecubic: :P
12:17:05 <hiptobecubic> I'm not very well versed in this
12:17:08 <benmachine> vim
12:17:10 <mcstar> is the object file really that much bigger than the source?
12:17:11 <hiptobecubic> but i don't see why it couldn't be
12:17:12 <benmachine> erp
12:17:17 * benmachine meant to put that in a shell
12:17:19 <osa1> edwardk: I installed hasktags, is there an easy way to generate tags for all downloaded libraries ?
12:17:23 <ClaudiusMaximus> Ralith: http://hackage.haskell.org/package/prof2pretty might interest you
12:17:46 <edwardk> osa1: probably, but i don't tend to do that. i tend to just set up a tags file per project
12:17:55 <hiptobecubic> mcstar, the sources files are maybe a few K compressed. Does it matter much? It could be optional
12:19:22 <edwardk> hrmm, it'd be kinda tricky i suppose
12:19:45 <edwardk> your ~/.cabal/packages/hackage.haskell.org folder only has gzipped tarballs of the projects, not the actual files
12:20:05 <edwardk> so i suppose you could take everything in there, untar it, and use xargs or something to run hasktags over the whole shebang
12:20:16 <edwardk> but that sounds messy ;)
12:20:36 <Ralith> ClaudiusMaximus: integrate it with lambdabot!
12:20:37 <hiptobecubic> sounds fine to me :)
12:20:56 <hiptobecubic> also, you could at least get the source for files that are interpreted directly by ghci
12:21:14 <hiptobecubic> ghci T.hs  and then you want to look at the source of something defined in T
12:22:04 <edwardk> mcstar: i can generate object files that are arbitrarily larger than the source files. ;)
12:22:16 <edwardk> mcstar: i think my old type-int package generates MASSIVE object files ;)
12:22:17 <mcstar> edwardk: thanks to TH
12:22:37 <edwardk> and inlining in general
12:23:16 <mcstar> if ghc featured a similar development environment as CL, that would be awesome
12:23:27 <edwardk> wow, the object files for type-int are an order of magnitude smaller than they used to be
12:23:39 <edwardk> ghc++
12:25:50 <Ralith> mcstar: I bet you could get pretty far with ghci as your base.
12:27:20 <bitonic> Ralith: well, nothing like CL + SLIME
12:27:22 <bitonic> sadly
12:27:26 <mcstar> :)
12:27:49 <bitonic> but lisp has a certain culture of integrated environment, Haskell people don't care that much
12:28:07 <bitonic> hell I don't care that much either :P
12:28:09 <mcstar> i think it would only benefit them
12:28:21 <bitonic> mcstar: sure but you need someone to do it
12:28:28 <Ralith> bitonic: why couldn't it be?
12:28:29 <mcstar> we have benmachine
12:28:36 <mcstar> he want to do stuff, doesnt he?
12:28:39 <mcstar> wants*
12:28:43 <benmachine> mcstar: noo I explained this
12:28:52 <benmachine> I want /other people/ to do stuff for /me/
12:28:56 <mcstar> sry
12:29:04 <mcstar> benmachine: then, you are just like the rest of us
12:29:05 <benmachine> I did once have a time when I wanted to do stuff
12:29:15 <Ralith> bitonic: the only thing GHC doesn't provide from normal SLIME use is a really sweet debugger.
12:29:19 <benmachine> but then I duly got some stuff :P
12:32:22 <bitonic> Ralith: that's not true, there is a lot of other stuff.
12:32:33 <bitonic> anyway, gotta go
12:32:45 <bitonic> with SLIME I mean the emacs part eh
12:32:52 <Ralith> I know what SLIME is. I am a heavy CL user.
12:33:00 <bitonic> so what does it have to do with GHC?
12:33:06 <Ralith> what part of normal SLIME use extends beyond rapid compilation, interactive testing, and debugging?
12:33:15 <Ralith> ghci serves the first two of those just fine.
12:33:26 <Ralith> haskell-mode even makes it convenient.
12:33:27 <bitonic> well but the whole point is to have those integrated in your editor!
12:33:33 <Ralith> well, they are.
12:33:34 <Ralith> so.
12:33:37 <bitonic> and haskell mode is far inferior
12:33:42 <bitonic> ghc mode makes it a bit better
12:33:46 <Ralith> it serves the first two of those just fine.
12:34:09 * hackagebot aeson-schema 0.2.0.0 - Haskell JSON schema validator and parser generator  http://hackage.haskell.org/package/aeson-schema-0.2.0.0 (TimBaumann)
12:34:11 <bitonic> whatever, I like them as well, but SLIME does much more, for example I can't just open a buffer and start evaluating expressions
12:34:13 <Ralith> I'd like a nice debugger too, but I understand that such a thing looks very different in a lazy evaluation model.
12:34:30 <Ralith> that's because Haskell doesn't have top-level expressions.
12:34:41 <bitonic> or the tight integration with the documentation
12:34:48 <Ralith> there are modes for that.
12:34:57 <bitonic> not really.  not nearly as good as slime.
12:35:13 <Ralith> I get the feeling nothing can be "as good as SLIME" in your view :P
12:35:27 <mcstar> can it?
12:35:29 <bitonic> are you really comparing something as SLIME to haskell-mode?
12:35:39 <bitonic> I mean they are totally different beasts.
12:35:50 <Ralith> yes, with the same design goals.
12:36:01 <bitonic> no.
12:36:02 <Ralith> and for a subset of what SLIME is useful for, haskell-mode is comparably useful.
12:36:16 <bitonic> haskell-mode is not meant to be what SLIME is.
12:36:22 <Ralith> I didn't say it was.
12:36:38 <bitonic> it doesn't interact with the compiler/interpreter in *any* way, apart from starting a ghci shell or loading files
12:36:42 <bitonic> it doesn't give you docs
12:36:49 <bitonic> you can't jump to definitions
12:36:53 <bitonic> no semantic completion
12:36:55 <Ralith> but this argument is offtopic, so I shall cease participating.
12:37:15 <bitonic> well, I have to go, bye :)
12:37:36 <mcstar> haskell-blah
12:37:42 <mcstar> dont stop participating
12:37:59 * Ralith is in too many IRC channels as it is.
12:38:29 <Ralith> and I don't ultimately care what bitonic thinks of haskell-mode :P
12:39:13 <mcstar> probably it is not in interest of the haskell community to develop a better integration between ghc and emacs
12:39:30 <mcstar> if it were, it would have had happened already
12:39:36 <hpaste> nu11ptr pasted “series/arrays: haskell vs scala” at http://hpaste.org/75135
12:39:49 <mcstar> maybe, most of them just dont use emacs, idk
12:42:11 <nu11ptr> I'm a haskell noob…so go easy on me :-) Trying to do a very quick and dirty performance comparison between haskell/scala for some time series code I'm writing. Bbest I can do is 8x slower in haskell. I'm stumped! Anybody wanna take a crack at what I did wrong? (pasted to hpaste - see above)
12:43:18 <mcstar> i dont think you should need those core-types
12:44:33 <jmcarthur> yeah the manual unboxing probably shouldn't have been attempted until you had already checked the core output
12:44:53 <jmcarthur> nor do you really need Data.Vector.Primitive
12:44:58 <jmcarthur> Data.Vector.Unboxed should be just fine
12:45:16 <nu11ptr> jmcarthur: Had unboxed first… primative was about 30% faster
12:45:24 <jmcarthur> "Stack space overflow: current size 1024000000 bytes."  <-- should be a hint
12:45:36 <nu11ptr> jmcarther: stack overflow only on the profiling
12:45:50 <jmcarthur> that's weird
12:45:56 <jmcarthur> i'd still take it as a hint
12:46:25 <nu11ptr> jmcarthur: hint of? it works just fine when not profiling
12:46:51 <nu11ptr> jmcarther: real world haskell said it is semi normal to have this when profiling due to the tons of extra stack space needed
12:47:24 <nu11ptr> jmcarthur: if I reduce the loop size 10X, it finishes, but I figured I had enough iterations of data already…so didn't bother
12:47:30 <mcstar> nu11ptr: are just trying to make 2 vectors and sum them up in a third, and sum that one?
12:47:31 <jmcarthur> i'm not actually sure how unboxed parameters work in haskell in terms of strictness, etc. you might want to try a bang pattern on the v argument to loop?
12:47:57 <mcstar> the core has boxing and strictness annotations
12:48:04 <mcstar> you can easily look that up
12:48:05 <jmcarthur> ah
12:48:28 <nu11ptr> mcstar: this is an example of what will be produced in my framework… these series eventually will go very deep, but so it is important we don't cheat and do a more efficient add (in other words, series must form a graph of operations)
12:49:38 <nu11ptr> I guess my biggest question is: did I botch something really, really simple? Did I cheat somewhere w/o realizing it maybe in my scala (yeah I know this isn't #scala :-))
12:51:06 <nu11ptr> nullptr: one thing I'm wondering…. how efficient is it to call a function assigned to a field on an ADT? I wonder if Scala is inlining calls to the trait but perhaps haskell is not? I'm just a bit over my head here :-/
12:51:24 <nu11ptr> see..now I'm talking to myself :-)
12:51:44 * jmcarthur is reading the code
12:52:25 <Cale> nu11ptr: How much did all the unboxing help?
12:53:05 <nu11ptr> Cale: Before I even started optimizing (everything lazy, before 1st attempt (strict), and current code (unboxing) it was fininshing in about 1.2 seconds
12:53:20 <nu11ptr> so I only shaved off about 30ish pct?
12:53:31 <mcstar> i dont know why is it necessary to hold the indexing function as a record field
12:54:23 <astry> hello
12:54:32 <astry> is there a way to swap the values held by two ioref's?
12:54:49 <nu11ptr> mcstar: all the series will eventually be nested within each other…. every "value" function is directly tied to the type of series…. so the ADT is used to find the correct value function
12:55:44 <nu11ptr> admittedly, this is a sort of OOPish design, but I don't' know how to do it better given the task. Create a ton of different series, nest them in each other and compute the top series through the graph
12:56:02 <jmcarthur> nu11ptr: that value function is being taken out of the ADT anyway in the loop
12:56:16 <jmcarthur> it's being passed as its own parameter
12:56:24 <nu11ptr> jmcarther: Ok, you see that in core?
12:56:35 <jmcarthur> i'm using ghc 7.4
12:56:36 <jmcarthur> yes
12:56:37 <Cale> astry: Not that I know of in the libraries. You can obviously write one really easily
12:57:04 <jmcarthur> however, it's not being inlined or anything. it's just a parameter
12:57:44 <nu11ptr> jmcarthur: I have more experience in scala, a bit of a haskell noob… I'm about 80% scala is inlining this call, but I did not verify it in this case
12:57:51 <nu11ptr> 80% sure
12:57:54 <jmcarthur> this code looks overoptimized to me. what is it meant to do?
12:58:20 <nu11ptr> jmcarthur: It is…it wasn't so messy when it started…got desperate :-)
12:58:21 <astry> Cale: hmm ok :)
12:58:26 <astry> Cale: thanks..
12:58:34 <jmcarthur> i don't have any scala infrustructure on my machine for a comparison, but i can try to write a reasonably efficient implementation if i know the goal
12:59:03 <Cale> astry: swapIORefs r r' = do v <- readIORef r, v' <- readIORef r'; writeIORef r v'; writeIORef r' v
12:59:44 <jmcarthur> i also noticed a lot of Integers in the core, but i haven't tried to determine where they are coming from
12:59:55 <jmcarthur> could be some unrelated not-performance-critical bit
13:00:15 <nand`> jmcarthur: time calculation stuff perhaps
13:00:25 <nu11ptr> jmcarthur: well there isn't a big goal to this problem. It is a proof of concept that further work would be based on. You would never write code this way for such a simple program as this…. Imagine 500 different series that you can nest together in a DSL to produce something finally useful
13:00:26 <jmcarthur> that would make sense
13:00:43 <nu11ptr> jmcarthur: only thing I know that uses Integers is getCPUTime… called twice
13:00:59 <nu11ptr> jmcarthur: in 'time' function
13:01:10 <mcstar> nu11ptr: i dont think a vector is evaluated because you request its size
13:01:21 <mcstar> just a remark
13:02:01 <nu11ptr> mcstar: yep, understood… my length call was just a hack to make sure the vectors are eval'd
13:02:06 <noviceprogrammer> hello
13:02:08 <noviceprogrammer> hello
13:02:16 <Cale> hi
13:02:16 <nu11ptr> mcstar: before 'time' function was the idea
13:02:18 <noviceprogrammer> what colorscheme is used in the lyah code boxes?
13:02:34 <Cale> noviceprogrammer: What do you mean by that?
13:02:57 <mcstar> where is he now?
13:03:10 <jmcarthur> nu11ptr: explain this series stuff in a bit more detail for me, because i don't understand. what is the function field for, exactly?
13:03:17 <mcstar> he is gone
13:03:25 <noviceprogrammer> http://learnyouahaskell.com/syntax-in-functions what colorscheme does he use in the code examples?
13:03:30 <Cale> noviceprogrammer: Seems like numeric constants are pinkish, some punctuation and most infix operators are light blue, everything else is white?
13:03:36 <Cale> oh, strings are light yellow
13:03:37 <noviceprogrammer> right
13:03:40 <mcstar> jmcarthur: it seems to me he is holding onto the vectors as a closure in the indexing function
13:03:55 <jmcarthur> series seems to be a tree of functions
13:04:10 <mcstar> the series itself doesnt contain any vectors
13:04:17 <astry> Cale: yeah. I was wondering if I'm doing something stupid by writing that on my own.
13:04:23 <astry> Cale: thanks a lot.
13:04:29 <jmcarthur> well, it does in that it contains functions with vectors in the closures, as you said
13:04:35 <nu11ptr> jmcarthur: function field is my way of overloading the "value" function. Since each series does something different (AddSeries is an extreme simple one….just adds two other series). This way you can nest series together without having to track which value function goes with it.
13:04:37 <mcstar> yeah
13:04:56 <mcstar> weird
13:05:03 <mcstar> i cant tab complete on your name
13:05:09 <mcstar> nullptr
13:05:17 <mcstar> nu11ptr:
13:05:18 <Cale> mcstar: those l's are 1's
13:05:22 <mcstar> i see
13:05:25 <mcstar> fail
13:05:25 <jmcarthur> 1, not l
13:05:28 <nu11ptr> mcstar: yep, 1's :-)
13:06:01 <jmcarthur> nu11ptr: could value not be determined based on some type parameter and a type class (i'm making some guesses about its purpose, here)
13:07:06 <nu11ptr> jmcarthur: I thought of using type classes instead of making it an ADT field. I suspect that would work…do you suspect that would perform better than the indirectness of calling a function in an ADT?
13:07:14 <jmcarthur> nu11ptr: maybe a little API for series and some claims about the desired performance of the operations would help me understand the goals
13:07:26 <sinelaw> ahoy
13:07:26 <jmcarthur> depending on how it's used, a type class might be significantly better
13:07:29 <Cale> nu11ptr: It ought to perform identically
13:07:45 <nu11ptr> jmcarthur: as fast as possible without using a crappy language like C :-)
13:07:48 <Cale> nu11ptr: Typeclass constraints get turned into dictionary passing
13:07:54 <jmcarthur> Cale: the type class should be better unless it's hidden under an existential, i think
13:08:03 <Cale> hm?
13:08:14 <Saizan> typeclass dictionaries are more likely to get compiled away, i think
13:08:27 <jmcarthur> Cale: i still don't fully understand the purpose here, but i'm interring that there would be some type parameter exposed
13:08:31 <jmcarthur> *inferring
13:08:39 <jmcarthur> **assuming
13:08:50 <nu11ptr> jmcarthur: I would need to use it with an existential…since I'd need to keep these "series" type class in a list…. and they wouldn't be all the same type
13:08:57 <jmcarthur> ah
13:09:02 <jmcarthur> then it wouldn't likely help after all
13:09:39 <jmcarthur> i'm afraid i don't understand the point enough to help optimize it
13:09:52 <Cale> Yeah, what are you actually trying to compute here?
13:09:58 <mcstar> nu11ptr: i see, so you want to build up a function hidden as a series object, that is composed of other series' accesor functions of basically to a vector
13:10:18 <mcstar> so from a couple of input vectors, you build up a whole computation expression
13:10:38 <nu11ptr> one thing I'm wondering is if given the point of this (a big framework of these series all inside each other), if this benchmark is even valid. For example, I wonder if scala is inlining the simple case…but if further down the road I won't do something that defeats that optimization…. *sigh* who knows.
13:11:05 <jmcarthur> nu11ptr: is the idea to just end up with a big expression tree?
13:11:11 <jmcarthur> and then interpret it?
13:11:24 <nu11ptr> mcstart: the base of  every graph of series will be a vector or some form of static array…on top of it will likely be series that are "dynamic" and don't use an array/vector…some may if they do complex expressions for memorization purposes
13:11:39 <mcstar> nu11ptr: yes, exactly
13:11:55 <astry> hmm, is there maybe a smarter way of doing this? do { v <- readIORef r; let v2 = f v; writeIORef r v2 }
13:12:10 <mcstar> astry: modifyIORef
13:12:13 <nu11ptr> jmcarthur: correct, this will be a toolkit…. it will end up as a big tree… you read the top "value" function and it walks all the way down until the expression is complete
13:12:24 <astry> mcstar: hmm thanks
13:12:31 <jmcarthur> nu11ptr: why reify the tree at all? why not just make it a big function?
13:12:31 <astry> @type modifyIORef
13:12:32 <lambdabot> Not in scope: `modifyIORef'
13:12:45 <Eduard_Munteanu> @hoogle modifyIORef
13:12:45 <lambdabot> Data.IORef modifyIORef :: IORef a -> (a -> a) -> IO ()
13:12:45 <lambdabot> Data.IORef atomicModifyIORef :: IORef a -> (a -> (a, b)) -> IO b
13:13:08 <Polarina> mm_freak_, (netwire) I got this little line here { fps <- hold (constant 1 >>> periodically >>> avgFps 10) <|> constant 0 -< () }, and it gives me a value of around 1 the whole time (probably something about local time for avgFps that's causing that, I think). I want a FPS counter, but want to hold the value for 1 second before it updates. Do you know how I can do that?
13:13:20 <nu11ptr> jmcarthur: I'm not sure I follow, but this tree will be built by someone else in a separate program. This is a library that allows arbitrary computations.
13:13:49 <jmcarthur> if it's build in a separate program, how do you intend to serialize it and get it into your program?
13:13:51 <Polarina> mm_freak_, I had something like { fps <- avgFps 10 -< () } and it worked fine (value of around 60), but kept updating way too rapidly on my screen.
13:13:52 <jmcarthur> *built
13:13:59 <nu11ptr> jmcarthur: I'm definitely looking for design ideas if there are better ways (read: much faster) of doing this in haskell
13:14:41 <nu11ptr> jmcarthur: there is a DSL layer that the user writes in…this in turn builds the series tree indirectly behind the scenes
13:14:42 <jmcarthur> nu11ptr: i just noticed you never use the depends field
13:15:20 <nu11ptr> jmcarthur: yes, I expect I probably cheated there… but that would make the results better :-)
13:16:01 <nu11ptr> jmcarthur: the final series ADT would have a lot more fields, and there would be even more dynamic dispatch…this is just scratching the surface as a quick and dirty proof of concept
13:16:35 <jmcarthur> so what would the api look like?
13:16:37 <astry> Cale: we've found a disturbance in Caleskell
13:16:52 <Cale> ?
13:17:04 <astry> 22:11 < lambdabot> Not in scope: `modifyIORef'
13:17:08 <Cale> You mean in lambdabot?
13:17:18 <noviceprogrammer> how do I make ghc optimize my program to the max?
13:17:22 <Cale> It would be useless to put IORef in scope
13:17:24 <astry> yeah, usually lambdabot knows every function :)
13:17:32 <Cale> because you can't do IO
13:17:34 <jmcarthur> noviceprogrammer: -O2 is usually plenty
13:17:35 <nu11ptr> jmcaruthur: API is very, very abstracted but it is declarative in that you are building the series, but not computing the values. That happens in a "loop-like" function later, so the DSL/API shouldn't be performance impacting
13:17:40 <astry> Cale: hmm, yeah.
13:17:52 <jmcarthur> noviceprogrammer: http://www.haskell.org/ghc/docs/latest/html/users_guide/options-optimise.html
13:18:16 <jmcarthur> nu11ptr: sure, but the API would help me understand what you're trying to do
13:18:26 <jmcarthur> maybe i could suggest a better representation
13:19:02 <nu11ptr> jmcarthur: ok, I'm building an array language as a DSL
13:19:08 <jmcarthur> ah!
13:19:10 * hackagebot attoparsec-binary 0.2 - Binary processing extensions to Attoparsec.  http://hackage.haskell.org/package/attoparsec-binary-0.2 (AndrewDrake)
13:19:30 <jmcarthur> this _was_ reminding me of repa in some sense. have you looked at how it works?
13:19:36 <noviceprogrammer> my program is still slow even with O(2) optimization :(
13:19:50 <nu11ptr> jmcaruther: example code:   gapUp <- open > close
13:19:52 <noviceprogrammer> it's O(2^n) ^^
13:20:09 <nu11ptr> jmcarthur: gapUp, open, >, and close are all "Series"
13:20:13 <jmcarthur> nu11ptr: essentially you have a sum type. one constructor has a manifest (concrete) array. another has a function representation instead
13:20:25 <jmcarthur> it's more complicated than that though
13:20:43 <nu11ptr> jmcarthur: reps you say… I can find that on hackage?
13:20:46 <nu11ptr> repa
13:20:47 <jmcarthur> noviceprogrammer: O(2) doesn't make sense as a way to describe optimization levels
13:20:52 <noviceprogrammer> when is the function type signature not optional?
13:20:54 <jmcarthur> nu11ptr: yes
13:20:58 <noviceprogrammer> jmcarthur: sorry meant O2*
13:20:59 <jmcarthur> nu11ptr: there are a couple papers, too
13:21:18 <jmcarthur> noviceprogrammer: if your algorithm is O(2^n) then that's your problem ;)
13:21:37 <nu11ptr> jmcarthur: interesting..
13:21:39 <noviceprogrammer> ^^
13:21:57 <nu11ptr> jmcarthur: I'll take a peek at this…I suspect it would eliminate some work as well if it fits my use case
13:22:20 <jmcarthur> noviceprogrammer: ghc sometimes borderlines on "sufficiently smart", but it's really not so. you still have to choose good algorithms
13:25:24 <tel> Can anyone help me parse some JSON—I want to parse a heterogenous list
13:25:28 <jmcarthur> nu11ptr: i'll take a stab at rewriting your code in a more repa-style fashion
13:26:12 <nu11ptr> jmcarthur: Ok, I suspect the catch…and why I'm writing this in the first place is that the index of a top level series and the index of bottom level series… may be very very different
13:26:34 <nu11ptr> jmarthur: My code does "alignment" between differing time series lengths
13:26:45 <jmcarthur> right
13:26:46 <nu11ptr> jmarthur: Most libraries can't handle that case….
13:26:47 <jmcarthur> repa can handle that
13:26:59 <nu11ptr> jmarthur: Interesting….
13:27:01 <jmcarthur> indexing transformations and such
13:27:23 <nu11ptr> jmarthur: no doubt it is worth a full look then
13:31:18 <simon> I tried to install hlint through cabal, but it complained that haskell-src-exts couldn't compile because happy wasn't found. I wonder why not simply depend on the happy package?
13:32:20 <dcoutts> simon: currently cabal-install's dependency solver only looks at library dependencies, not tools, not C libs etc
13:32:54 <hpaste> tel pasted “JSON parsing of a heterogenous List” at http://hpaste.org/75138
13:34:13 <hpaste> tel annotated “JSON parsing of a heterogenous List” with “JSON parsing of a heterogenous List (annotation)” at http://hpaste.org/75138#a75139
13:34:57 <simon> dcoutts, ok.
13:38:06 <noviceprogrammer> How do I obtain an Integer from stdin?
13:38:31 <jmcarthur> :t readLn
13:38:32 <lambdabot> forall a. (Read a) => IO a
13:38:32 <ClaudiusMaximus> :t readLn
13:38:33 <lambdabot> forall a. (Read a) => IO a
13:39:11 <ClaudiusMaximus> (you'll get a horrible exception if it's not well-formed though)
13:39:16 <latro`a> yeah
13:39:27 <latro`a> fmap reads getLine, with exception handling, will avoid that issue
13:41:34 <astry> hi
13:41:59 <astry> i tried using atomicModifyIORef but it's not equivalent to my code, but i'm not sure why
13:42:00 <hpaste> mcstar pasted “nu11ptr” at http://hpaste.org/75140
13:42:02 <astry> http://dpaste.com/804543/
13:42:12 <astry> why are those two blocks of code not equivalent?
13:43:40 <noviceprogrammer> http://ideone.com/yFJAy readLn doesn't work :(
13:43:59 <nu11ptr> mcstar: thx… does this perform better for you than my old version?
13:44:07 <mcstar> idk
13:44:10 <mcstar> didnt test
13:44:17 <mcstar> i hope you will do that :)
13:44:23 <nu11ptr> mcstart: I will :-)
13:44:24 <latro`a> noviceprogrammer, readLn is an IO action, you have to bind it
13:44:39 <nu11ptr> mcstar: thx, nice to have another version to play with
13:44:48 <mcstar> well, im a noob
13:45:01 <noviceprogrammer> so I must use >>=?
13:45:08 <mcstar> and im not sure whther i can define another module in the same file as Main
13:45:29 <mcstar> ghc is bitching with me  parse error on input `module'
13:45:38 <astry> noviceprogrammer: just put stuff in a do block
13:46:22 <noviceprogrammer> http://ideone.com/xeMhS the do block still won't compile :(
13:47:27 <astry> you put the <- thing in the do block
13:47:30 <mcstar> nu11ptr: i just put the Series module into another file to compile it, you should do that too
13:47:31 <astry> not in the where block
13:47:57 <Eduard_Munteanu> noviceprogrammer: that's not how do syntax works
13:48:13 <noviceprogrammer> http://ideone.com/2hdV1 works! thanks
13:48:20 <astry> yw
13:48:34 <Eduard_Munteanu> Do syntax is merely sugar for >>= and lambdas.
13:48:58 <noviceprogrammer> I thought do blocks put haskell into imperative mode
13:49:09 <Eduard_Munteanu> @undo do { y <- f x; g y }
13:49:10 <lambdabot> f x >>= \ y -> g y
13:49:14 <astry> no they're just do blocks
13:49:23 <Eduard_Munteanu> Heh, there's no such thing :)
13:50:51 <astry> noviceprogrammer: IO puts haskell in "imperative mode"
13:50:52 <noviceprogrammer> http://ideone.com/rQWTt so without the do block, it looks like this?
13:50:55 <ski> noviceprogrammer : in a way, both "do blocks put haskell into imperative mode" and "no they're just do blocks","there's no such thing (as imperative mode)" is true ..
13:51:00 <astry> you can write IO without any do blocks
13:51:14 <astry> and you can write do blocks for stuff that isn't IO.
13:51:15 <Eduard_Munteanu> noviceprogrammer: yep
13:51:20 <ski> noviceprogrammer : yes
13:52:05 <noviceprogrammer> what does readLn >>= \n do?
13:52:30 <astry> i'd even do readLn >>= fact >>= print
13:52:35 <Eduard_Munteanu> noviceprogrammer: you're not grouping things correctly, do you know lambdas?
13:52:49 <noviceprogrammer> nope
13:52:57 <Eduard_Munteanu> astry: won't work there
13:53:04 <astry> why not?
13:53:21 <Eduard_Munteanu> noviceprogrammer: lambdas are just anonymous functions like in other languages you may have seen
13:53:30 <Eduard_Munteanu> > (\x -> x + 1) 2
13:53:31 <lambdabot>   3
13:53:43 <noviceprogrammer> ah
13:53:44 <Eduard_Munteanu> > map (\x -> x * 2) [1..3]
13:53:45 <lambdabot>   [2,4,6]
13:53:52 <noviceprogrammer> lambdas are really handy things
13:54:12 <Eduard_Munteanu> Now, that's   readLn >>= (\n -> print n)
13:54:32 <Eduard_Munteanu> Erm,   readLn >>= (\n -> print (fact n))
13:54:51 <noviceprogrammer> right
13:55:03 <ParahSailin> :t fact
13:55:04 <lambdabot> Not in scope: `fact'
13:55:27 <noviceprogrammer> so readLn reads an Integer from stdin and binds it to print fact ?
13:55:53 <jmcarthur> nu11ptr: sorry, i got bored
13:55:57 <Eduard_Munteanu> noviceprogrammer: that's what (>>=) does
13:56:06 <Eduard_Munteanu> Binding, I mean.
13:56:19 <noviceprogrammer> :t readLn
13:56:20 <lambdabot> forall a. (Read a) => IO a
13:56:39 <noviceprogrammer> how does readLn know that it must read an Integer?
13:56:39 <nu11ptr> jmcarthur: :-)
13:56:40 <Eduard_Munteanu> And in the expression to the right of (>>=), n :: Integer
13:56:46 <noviceprogrammer> ah
13:57:03 <ski> noviceprogrammer : because `fact' wants an `Integer' as input
13:57:04 <Eduard_Munteanu> noviceprogrammer: unification :). Basically, because you used fact there, it *has* to be an Integer.
14:01:24 <noviceprogrammer> is Haskell still purely functional after I do things like readLn and print?
14:01:31 <atriq> Yes
14:01:46 <atriq> readLn doesn't actually do IO
14:02:19 <atriq> It makes a thingy that, when main is set to it
14:02:26 <atriq> Does IO when the program is actually run
14:02:44 <atriq> (someone who knows what they're talking about, correct me, please)
14:03:06 <Eduard_Munteanu> noviceprogrammer: main is just building an IO action that's executed by the RTS at runtime. All that code does is evaluate to an IO action.
14:03:13 <pharaun> anyone here familiar with conduit-filesystem? I'm having some trouble with its traverse source
14:03:20 <noviceprogrammer> right
14:03:35 <pharaun> basically, if i have a named pipe or special pipe in a directory the program locks up blocking on the named pipe
14:04:09 <pharaun> i've isolated it down to only "traverse False 'directorypath' $$ CL.consume"
14:04:19 <pharaun> it attempts to open the pipe file then blocks/wait on it
14:07:17 <Dowal> Any idea why cabal won't find the glut library when installing gloss?
14:07:21 <geekosaur> Pharaun, that's an incredibly common logic error in random programs
14:07:24 <benmachine> there's some significant argument about what "purely functional" means and whether or not it applies to IO in Haskell
14:07:45 <pharaun> geekosaur: hm? i'm going to attempt to reduce it then will present a example
14:07:50 <Dowal> I'm confused as I am able to get it on a very similar machine
14:07:59 <benmachine> some would argue that IO in Haskell has no real notion of equality, no denotational semantics, and therefore it doesn't really make sense to call it purely functional
14:08:05 <geekosaur> I would nbot be even remotely surprised if whoever wrote conduit-filesystem missed the possibility of fifos. Or of device nodes for that matter
14:08:11 <pharaun> :\
14:08:14 <Dowal> I can find /usr/include/GL/glut.h just fine, and setting --extra-include-dir is not doing much
14:08:15 <dcoutts> benmachine: but that's ok because they're wrong :-)
14:08:32 <geekosaur> (tht's okay,  try it on windows and feed it 'con'  :p)
14:08:41 <benmachine> dcoutts: I do think it's legitimate to point out that the "oh, you're just creating an IO recipe" argument is unsatisfactory
14:08:42 <pharaun> geekosaur: guess i'll need to write my own version of conduit-filesystem and/or figure out if i can submit the guy a patch
14:08:47 <pharaun> geekosaur: haha i know of con :)
14:09:08 <benmachine> dcoutts: you do have to then understand that recipe, and you can't do that easily because mutable state is all over the place
14:09:20 <latro`a> I consider "haskell just chains together IO actions in a pure functional way, only the RTS actually executes imperative code" kinda...pedantic. anyone agree?
14:09:25 <mcstar> nu11ptr: yours: 1.3s, mine 0.4s, with Data.Vector.Primitive
14:09:27 <pharaun> geekosaur: i'm doing a directory tree hasher/sync thus :) i need to take care of all of the special... cases like that :p
14:09:39 <atriq> Hmm
14:09:44 <pharaun> just surprised that it was missed in conduit-filesystem
14:09:52 <atriq> I don't think ap, const, and fix is Turing-Complete in Haskell
14:09:54 <mcstar> nu11ptr: well, for 10M long vectors
14:09:54 <benmachine> latro`a: I consider it problematic, I'm not sure if I would use the word pedantic but I think you've got a point
14:09:55 <nu11ptr> mcstar: Only change from what was pasted?
14:09:55 <geekosaur> Dowal, The question may not be the include file but the library (libglut.so?)
14:09:59 <atriq> On closer inspection
14:10:00 <dcoutts> benmachine: it's also interesting to look at what the semantics of the I/O actions are, but I think that's separate from the issue of purity
14:10:04 <atriq> I think you do need unsafeCoerce
14:10:05 <mcstar> nu11ptr: yes
14:10:14 <mcstar> nu11ptr: just add Primitive
14:10:26 <nu11ptr> mcstar: k, thx
14:10:31 <mcstar> nu11ptr: oh well, i throw in some strictness annotations
14:10:38 <mcstar> am not sure how much that counts
14:10:45 <cmccann> atriq, why's that?
14:10:55 <atriq> Type system
14:10:58 <benmachine> dcoutts: okay, but if you claim that you're almost using Haskell as a metaprogramming language to produce this IO program, you have to admit that real-world haskell actually involves writing pure Haskell code *and* impure IO code
14:10:59 <cmccann> well, yes
14:11:02 <atriq> Hmm
14:11:03 <cmccann> but do you have a specific example?
14:11:23 <mcstar> nu11ptr: the arguments of 'go' and the data fields of Series are preceded with a !, thats all
14:11:29 <dcoutts> benmachine: I also think it probably is possible to give a reasonable explanation of the I/O actions, e.g. using CSP to describe the interaction with the external environment
14:11:51 <atriq> :t fix $ \r x y -> (\a b p -> p a b) x (r y ((\m n f x -> m f (n f x)) x y)
14:11:52 <lambdabot> parse error (possibly incorrect indentation)
14:11:54 <atriq> :t fix $ \r x y -> (\a b p -> p a b) x (r y ((\m n f x -> m f (n f x)) x y))
14:11:55 <lambdabot>     Occurs check: cannot construct the infinite type:
14:11:55 <lambdabot>       t = ((t2 -> t3 -> t3) -> t -> t1) -> t1
14:11:55 <lambdabot>     Probable cause: `r' is applied to too few arguments
14:11:56 <dcoutts> benmachine: yes, sure, main :: IO ()
14:11:56 <noviceprogrammer> :t getLine
14:11:57 <lambdabot> IO String
14:11:58 <Dowal> geekosaur: also have it located at /usr/lib/i386-linux-gnu/libglut.so
14:12:03 <benmachine> dcoutts: oh, well, I don't know what that is, so you get authority on that one :)
14:12:14 <atriq> cmccann, that should be a Fibonacci numbers thingy
14:12:27 <cmccann> atriq, that uses lambdas anyway
14:12:39 <atriq> cmccann, which can be replaced by const and ap
14:12:44 <geekosaur> Dowal, that doesn't mean the program can find it. In fact it would make me wonder if you hgave 32 bit library on 64 bit machine
14:12:48 <atriq> I just can't be bothered if I know it's not going to work
14:12:50 <cmccann> but yeah, stuff like that can be awkward
14:13:04 <atriq> Other than the fix, there's no recursion
14:13:11 <atriq> It's the recursion that makes it awkward
14:13:16 <noviceprogrammer> when should I go for the `readLn >>= \foo ->` over do notation?
14:13:25 <dcoutts> benmachine: it's a formalism for concurrency, it lets you describe a process by explaining how it interacts (you don't need to also describe the other processes it interacts with)
14:13:29 <cmccann> atriq, can you fix it with RankNTypes?
14:13:33 <jmcarthur> a pedantic point of view might be that I/O is impure unless somebody comes up with a precise semantics for it
14:13:38 <atriq> noviceprogrammer, "foo <- readLn; ..."
14:13:44 <atriq> cmccann, I don't think so
14:13:49 <benmachine> atriq: you can usually use newtypes to paper over your type holes
14:14:03 <nu11ptr> mcstar: gotta run, but I'll plug it into my timing func and play with it in a bit. Thx!
14:14:05 <cmccann> and yeah, allowing newtype should also work
14:14:06 <Dowal> geekosaur: right... that's actually what's happening
14:14:07 <ddarius> jmcarthur: Is all of Haskell impure then (even if we excluded IO)?
14:14:07 <Dowal> thanks!
14:14:13 <atriq> benmachine, I'm planning on rampant obfuscation. Really, I'd rather use unsafeCoerce
14:14:27 <benmachine> atriq: oh, well, good luck to you then :P
14:14:28 <jmcarthur> ddarius: i did say it was pedantic :)
14:14:30 * cmccann defines non-termination as impure and avoids the whole issue
14:14:40 <atriq> benmachine, I'm sure I showed you my last obfuscation
14:14:46 <benmachine> atriq: yeah, rings a bell
14:15:01 <Eduard_Munteanu> noviceprogrammer: for simpler stuff, (>>=) is sometimes more convenient
14:15:04 <benmachine> jmcarthur: is it less pedantic if I cut out the "precise" bit?
14:15:20 <Eduard_Munteanu> Say, readLn >>= print
14:15:21 <jmcarthur> i think "precise" was redundant
14:15:24 <cmccann> atriq, anyway, I suspect (but am not certain) that RankNTypes would let you get around the issue
14:15:36 <cmccann> by not unifying as many types
14:15:58 <benmachine> jmcarthur: I don't think semantics are by necessity precise, just way more useful that way
14:16:13 <hpaste> pharaun pasted “Hanging traverse” at http://hpaste.org/75146
14:16:43 <cmccann> I'm also not convinced that you need any of that to merely be turing complete, with the caveat that you might need to write things in certain ways
14:17:12 <jmcarthur> benmachine: i think i see an imprecise semantics as more of an analogy
14:17:15 <atriq> cmccann, RankNTypes doesn't help
14:17:15 <pharaun> geekosaur: anyway glad to know i'm not going crazy :)
14:17:26 <cmccann> creating a turing tarpit is surprisingly easy
14:17:31 <dcoutts> benmachine: e.g. I would try to describe an I/O primitive like  foreign import ccall "foo" :: Int -> IO Int,  as a CSP process that sends an int and then expects an int. We don't specify what foo does, we describe our interaction.
14:17:34 <atriq> And you DEFINITELY need some way of looping to be Turing Complete
14:17:36 <pharaun> going to find/attempt to contact the author of conduit-filesystem and give a bug report and make my own version
14:17:44 <atriq> The only way to do this with const/ap is recursion
14:17:53 <atriq> (infinite looping)
14:18:12 <atriq> (and I'm a regular on #esoteric, I know how easy it is to make a turing tarpit)
14:18:21 <cmccann> yes, S and K are enough without types, so adding a fixpoint combinator isn't missing anything obvious
14:19:25 <Puffton> myvar = [toUpper, toLower] `ap` "bcdfghjklmnpqrstvwxz"
14:19:38 <Puffton> I know what the code does, but how exactly does `ap` work?
14:19:39 <atriq> cmccann, if you can make it typecheck
14:19:55 <jmcarthur> @src ap
14:19:55 <lambdabot> ap = liftM2 id
14:19:59 <jmcarthur> @src liftM2
14:19:59 <lambdabot> liftM2 f m1 m2 = do { x1 <- m1; x2 <- m2; return (f x1 x2) }
14:20:04 <dcoutts> benmachine: then you can try and pin things down a bit by giving a total or partial specification of the environment, ie what foo does (or some bound on what it can do)
14:20:09 <atriq> ap x y z = x z $ yz
14:20:16 <atriq> for the ((->) r) monad
14:20:27 <atriq> *x z $ y z
14:20:27 <noviceprogrammer> http://ideone.com/W1hhv is it possible for me to test n and exit cleanly if it fails to read an Integer or hits EOF?
14:20:41 <benmachine> dcoutts: ok, fine, but... surely the result would not be pure
14:20:49 <benmachine> dcoutts: I mean, you have a global mutable environment right htere
14:20:51 <Puffton> atriq, basically syntactic sugar?
14:20:57 <cmccann> ap and const are the S and K combinators
14:21:05 <atriq> Puffton, how so?
14:21:21 <cmccann> for anyone who didn't catch that, obviously atriq knows :P
14:21:33 <dcoutts> benmachine: the same Haskell function that gives you something of type IO (), it gives you the same IO action every time. That IO action has a precise (non-deterministic) semantics.
14:21:49 <atriq> I've spotted a way of making a really evil obfuscation and want to get it perfect
14:21:55 <benmachine> dcoutts: okay, but you need to understand how the IO action operates to write a Haskell program
14:22:06 <jmcarthur> i disagree with that claim, benmachine
14:22:06 <benmachine> how IO actions operate
14:22:12 <dcoutts> benmachine: to write IO actions, yes sure
14:22:14 <benmachine> jmcarthur: go on
14:22:25 <Botje> noviceprogrammer: you could use getLine and reads.
14:22:28 <mcstar> whats the scala source extension?
14:22:33 <jmcarthur> if you know the semantics, such as that proposed by dcoutts, it should be all you need
14:22:40 <Botje> noviceprogrammer: or catch the exception otherwise thrown by readLn
14:23:09 <jmcarthur> (i'm ignoring thing's like cpu and memory, if those are intentionally excluded from the semantics)
14:23:10 <noviceprogrammer> haskell has exceptions?
14:23:12 <jmcarthur> *things
14:23:27 <benmachine> jmcarthur: okay, sure, but those semantics involve interacting with a global mutable environment
14:23:31 <dcoutts> benmachine: just like you need to understand C semantics to usefully write a function :: ... -> CAst
14:24:03 <jmcarthur> benmachine: the semantics describes the nature of the interaction with the environment, not the environment itself
14:24:17 <jmcarthur> which is, of course, about as precise as you'll get
14:24:41 <dcoutts> jmcarthur: but it's also true that you often need to know something about what the environment will do to write useful code
14:24:50 <Puffton> atriq, well it feels like it's not really necessary, just a "good to have", making the code a bit prettier?
14:24:50 <dcoutts> which is fine
14:25:18 <atriq> Puffton, you mean unsafeCoerce or fix?
14:25:27 <Puffton> ap
14:25:36 <jmcarthur> dcoutts: right. if you are also given a semantics for the environment then you can fully describe the behavior of the problem. otherwise you can't.
14:25:40 <benmachine> dcoutts: re: functions to CAst, yeah, so I think the difference is that IO is much more central to Haskell programming
14:25:41 <atriq> For my purposes it's really really necessary
14:25:48 <atriq> Otherwise you've got pretty much nothing
14:25:55 <atriq> As in, actually nothing
14:26:13 <Botje> noviceprogrammer: yes, it does.
14:26:13 <benmachine> dcoutts: I'd be happy if people said "Haskell is pure, but if you want to do IO, you also have to understand this principally impure other thing"
14:26:14 <Puffton> so you mean it's impossible to write some code without the use of ap?
14:26:14 <dcoutts> benmachine: yes
14:26:25 <jmcarthur> in that sense, IO can be seen as parameterized on something else
14:26:28 <atriq> Puffton, the way I'm writing code, yes
14:26:32 <atriq> You can't just use const
14:26:33 <benmachine> dcoutts: I feel that leaving out the latter part is a little unfair
14:26:37 <atriq> But in general?
14:26:47 <atriq> You don't even need Haskell
14:26:52 <atriq> To write a program
14:26:58 <atriq> (but don't tell anyone)
14:27:17 <Botje> noviceprogrammer: getLine >>= \ln -> case reads ln of [(x, String)] -> ...; _ -> ...
14:27:49 <Puffton> So strictly speaking "ap x y z" is not syntactic sugar for "x z $ y z"
14:27:55 <Puffton> or?
14:28:11 <dcoutts> jmcarthur: yes, though also note that there's a continuum, with partial specifications of the environment
14:28:16 <jmcarthur> benmachine: but not necessarily incorrect
14:28:19 <jmcarthur> dcoutts: right
14:28:23 <atriq> Puffton, I'm using it as a unit in of itself
14:28:29 <atriq> I'm trying not to use $ at all
14:28:38 <benmachine> jmcarthur: not /pedantically/ incorrect, but I don't think it reflects the reality of programming in Haskell
14:28:50 <atriq> And besides, there are stuff like ap x y, parially applied functions
14:28:53 <Puffton> ok
14:29:07 <atriq> Where having it as syntatic sugar would break down and crash and burn and stuff
14:29:10 <jmcarthur> benmachine: i don't mean to advocate being misleading, but i don't know who would expect that even I/O in haskell is completely pure in the pedantic sense
14:29:35 <atriq> By the way, ap is the same as (<*>)
14:30:35 <benmachine> jmcarthur: I just feel like people say "if you use Haskell you don't have to worry about all these things you're used to worrying about" and that's not fair, you just worry about them less
14:30:49 <benmachine> jmcarthur: I feel like as a consequence the notion people have of purity is kind of fuzzy and loses some value
14:30:49 <Lutin_> ap                =  liftM2 id
14:30:57 <benmachine> because if even IO is pure, then purity can't be that special
14:31:07 <dcoutts> benmachine: the reality is you need to know about the world outside of pure computation. I guess the point is that the Haskell trick for incorporating IO into a pure language really does work. It does not break purity. But yes I/O is still I/O, there's nothing new there.
14:31:19 <jmcarthur> benmachine: i think i would say something more along the lines of "Haskell gives you a pure programming model, and when that doesn't fit your needs you can also write code that has effects."
14:31:49 <jmcarthur> benmachine: because when you're writing pure code, you really *don't* have to worry about these things
14:31:54 <dcoutts> benmachine: and you're right about the practice, in practice one can just think of the pure bit and the impure bit.
14:32:03 <dylukes> I think the Haskell trick is quite clever, and works well.
14:32:07 <benmachine> dcoutts: right
14:32:08 <jmcarthur> benmachine: IO is, in that sense, an extra power (and responsibility) that you don't always have to deal with
14:32:10 <benmachine> dylukes: certainly!
14:32:16 <benmachine> jmcarthur: yes
14:32:17 <dylukes> Explaining it can be a little tricky sat first, but I've never met anyone who took more than 30 seconds to grok it roughly.
14:32:31 <dcoutts> benmachine: but I think the semantic worries are misplaced
14:32:49 <dcoutts> benmachine: even for questionable things like unsafeInterleaveIO
14:32:50 <benmachine> dcoutts: sometimes it feels to me like people will try to deny the impure bit exists
14:32:57 <benmachine> that's all
14:32:58 <dylukes> How does the IO execution work? Abstractly speaking.
14:33:45 <MostAwesomeDude> dylukes: type IO a = State RealWorld IO -- very roughly.
14:33:55 <dcoutts> benmachine: I guess they don't write very interesting I/O programs :-)
14:33:57 <benmachine> MostAwesomeDude: that's a kind error :P
14:33:58 <dylukes> I know :P. I'm asking more so I have a "correct" way to teach people.
14:34:02 <shachaf> MostAwesomeDude: That's anything but abstract.
14:34:10 <dylukes> shachaf: ^
14:34:12 <MostAwesomeDude> Oh, derp, type IO a = State RealWorld a
14:34:13 <jmcarthur> dylukes: i think the explanation given by dcoutts is pretty good, actually. simplified, you can think of IO actions as a request sent to a concurrent server and continuations to handle the responses (in some free monad sense)
14:34:22 <shachaf> That's concrete implementation details used in GHC.
14:34:22 <MostAwesomeDude> Also ignore me.
14:34:44 <dylukes> The way I usually explain is thinking of IO actions are messages sent to an external server called "the real world" with continuations, yeah.
14:34:59 <dylukes> er, I usually think of it as a process.
14:35:05 <dylukes> In an Erlang sense.
14:35:09 <jmcarthur> that is reasonable
14:35:23 <ddarius> dylukes: That's exactly what's happening.
14:35:25 * dcoutts recommends CSP for this purpose
14:35:39 <jmcarthur> data IO a = Return a | Action Request (Response -> IO a)
14:35:48 <ddarius> To do any real IO, you are making system calls which are (usually synchronous) messages to a concurrent process.
14:35:51 <ddarius> Namely the kernel.
14:36:01 <ddarius> Or the RTS if you like.
14:36:52 <mcstar> jmcarthur: that program nullptr pasted, takes 42s to compile, vs. 3.3 the hs one
14:37:03 <dylukes> Heh, good point.
14:37:11 <jmcarthur> mcstar: the scala one does?
14:37:18 <mcstar> yeah
14:37:22 <jmcarthur> that's amazing
14:37:40 <mcstar> jmcarthur: and im withing 2x of it with my version
14:37:44 <mcstar> runtime
14:37:55 <mcstar> 0.2 scala vs 0.4 hs
14:38:06 <mcstar> but scala has 3s of startup overhead
14:38:14 <jmcarthur> there's no telling whether you're really doing what he wants, though
14:38:25 <jmcarthur> at least, i still don't quite have a strong enough notion to be sure
14:38:35 <mcstar> jmcarthur: i think i know wha he wants, and made it in a couple lines
14:38:56 <mcstar> jmcarthur: just composing functions hidden behind a data type
14:39:25 <mcstar> jmcarthur: but theres a HUGE difference between vector and vector.primitive
14:39:34 <mcstar> like 8s vs. 0.5s
14:39:34 <jmcarthur> that is basically my understanding as well, although he did point out that he intends to carry a lot of information around with these functions, not just the functions themselves
14:39:58 <jmcarthur> mcstar: between Data.Vector and Data.Vector.Primitive or between Data.Vector.Unboxed and Data.Vector.Primitive?
14:40:07 <mcstar> ! vs undafeindex
14:40:21 <mcstar> it is boxed
14:40:39 <jmcarthur> ah. i think i would be more interested in Data.Vector.Unboxed and Data.Vector.Primitive
14:40:51 <jmcarthur> Data.Vector *should* be much slower for this than Data.Vector.Primitive
14:40:54 <cmccann> ddarius, any thoughts on types for a geometric algebra implementation? is it worth having separate types for e.g. pure k-blades, or just everything as general multivectors?
14:41:16 <dylukes> Why use .Primitive instead of .Unboxed?
14:41:25 <dylukes> cmccann: *woosh*
14:41:31 <dylukes> that was the sound of you flying over my head.
14:41:31 <cmccann> enough useful operations are much simpler on objects of a single grade or whatever that it seems like it might be useful
14:41:32 <ddarius> cmccann: As I said, for very pragmatic implementations, I usually have types for scalars, vectors, bivectors, and spinors.
14:41:46 <dylukes> bivectors?
14:41:46 <cmccann> but it also introduces potential conversion boilerplate &c.
14:41:53 <jmcarthur> dylukes: nu11ptr's code was using .Primitive after some (i claim) misguided optimizations
14:42:18 <ddarius> You almost certainly want to have k-blades specialized since many operations are defined directly in terms of k-blades or only make "sense" on k-blades.
14:42:25 <ddarius> k-blades are also generally important.
14:42:34 <cmccann> yeah
14:42:45 <ddarius> I probably have a type for pseudoscalars as well.
14:43:18 <mcstar> jmcarthur: i see, i thought unsafeindex was in Primitive
14:44:19 <mcstar> jmcarthur: well, no difference with Unboxed
14:44:33 <jmcarthur> mcstar: ah, no. it's unsafe in that it skips the bounds check, not in any sort of primitive sense
14:45:02 <jmcarthur> mcstar: that sounds more sane then. (Unboxed is normally the way to go, btw)
14:45:19 <mcstar> i know why it is unsafe
14:45:30 <mcstar> i just didnt know it was available wo Primitive
14:45:35 <jmcarthur> ah
14:45:38 <mcstar> i thought thats the reason why he used it in the first place
14:48:16 <Saizan> i might actually get to learn geometric algebra given a Haskell implementation
14:49:26 <edwardk> Saizan: check my algebra package. it has a haskell implementation of a geometric coalgebra at least
14:49:28 <cmccann> ddarius, basically I was leaning toward type-level distinction for k-blades (since decomposition as a wedge product is useful), k-vectors (though maybe only 0, 1, 2, and the pseudoscalar are very useful), and general multivectors
14:50:14 <ddarius> Having an explicit representation for spinors is also useful.
14:50:21 <cmccann> oh, yeah, that to
14:50:39 <cmccann> that's definitely worthwhile
14:51:06 <cmccann> anything much more than those seems like more hassle than it'd be worth
14:51:11 <ddarius> Saizan: Either you are doing things where GA would help you significantly without an implementation, or you probably don't have a use for a GA implementation at all.
14:51:24 <hiptobecubic> If i have [IO a], how can I get an IO [a] where the [a] is lazy?
14:51:35 <jmcarthur> mapM
14:51:39 <jmcarthur> :t mapM
14:51:40 <cmccann> even though it'd be possible to encode all kinds of extra bullshit about what grades are present into the type as well
14:51:40 <lambdabot> forall a (m :: * -> *) b. (Monad m) => (a -> m b) -> [a] -> m [b]
14:51:45 <Nereid> hiptobecubic: sequence gives you an IO [a], but why lazy?
14:51:46 <jmcarthur> oh sorry
14:51:46 <maukd> hiptobecubic: unsafeInterleaveIO
14:51:48 <jmcarthur> :t sequence
14:51:49 <noviceprogrammer> :t 1
14:51:49 <lambdabot> forall (m :: * -> *) a. (Monad m) => [m a] -> m [a]
14:51:50 <lambdabot> forall t. (Num t) => t
14:51:57 <hiptobecubic> maukd, no thanks :)
14:51:58 <Polarina> mm_freak_, I actually managed to do it! :D   { fps <- hold (avgFps 10 <* (constant 1 >>> periodically)) <|> constant 0 -< () }   Thanks.
14:51:58 <ddarius> cmccann: At least for non-CGA representations, there aren't too many things that have a (known) compelling structure.
14:52:01 <maukd> hiptobecubic: yes
14:52:06 <jmcarthur> oh you mean where the evaluation of the list triggers the execution of the IO?
14:52:07 <ddarius> (too many other things)
14:52:20 <mcstar> jmcarthur: well, all is good and well again
14:52:27 <hiptobecubic> hmmm I guess there's no hope otherwise
14:52:29 <cmccann> whereas having just multivectors means lots of operations being hard to compute and/or very partially defined
14:52:29 <noviceprogrammer> :t [1,3..10]
14:52:30 <lambdabot> forall t. (Num t, Enum t) => [t]
14:52:36 <Saizan> ddarius: well, it just often helps to have the definitions written in a familiar and clear notation
14:52:47 <Saizan> edwardk: thanks
14:52:48 <mcstar> 2.7s when you count in the time used to create the vectors, for the scala version
14:52:53 <mcstar> jmcarthur: ^^
14:52:54 <ddarius> Saizan: The "familiar and clear notation" would be vector algebra.
14:53:08 <cmccann> ddarius, anything else that would be particularly useful for CGA, then?
14:53:50 <hiptobecubic> I need the list to be infinite, and then I just want to fmap (take n) some as needed
14:53:57 <mcstar> jmcarthur: vs. his original hs, 1.3s, vs my hs 0.4
14:54:00 <ddarius> I'd have to think about it, though screw transformations may not fall into any of the above categories.
14:54:01 <jmcarthur> mcstar: oh, were you already counting that in the haskell version?
14:54:06 <mcstar> sure
14:54:09 <jmcarthur> ah
14:54:22 <jmcarthur> nu11ptr: !
14:54:30 <mcstar> i learned to do full benchmarks
14:54:35 <mcstar> lazyness screws things up
14:54:39 <Nereid> hiptobecubic: so... unsafeInterleaveIO?
14:54:40 <jmcarthur> well
14:54:47 <hiptobecubic> Nereid, apparently, yes
14:55:42 <jmcarthur> @hoogle evaluate
14:55:42 <lambdabot> Control.Exception.Base evaluate :: a -> IO a
14:55:42 <lambdabot> Control.Exception evaluate :: a -> IO a
14:55:42 <lambdabot> Control.OldException evaluate :: a -> IO a
14:55:51 <cmccann> ddarius, if memory serves me a lot of stuff just becomes a simple rotation in CGA, which is part of the appeal
14:55:52 <jmcarthur> weird location for that, but okay...
14:56:26 <hiptobecubic> That can't be right, though. This is part of a course and we *definitely* haven't discussed that kind of thing. But he asks for a random list of ints by a function (f :: IO [Int])
14:56:36 <cmccann> but I didn't spend that much time playing with the crude implementation I had before
14:56:41 <ddarius> cmccann: Yes, and a lot of interesting objects are just k-blades.
14:56:41 <hiptobecubic> It takes no parameters so I assume it's infinite, but maybe he's just not being precise about what he wants
14:56:56 <hiptobecubic> I guess I could just return IO []  :)
14:57:25 * cmccann enjoys the whole "translation is a rotation around infinity" thing
14:57:50 <ddarius> cmccann: That's just a homogeneous thing.
14:58:28 <jmcarthur> hiptobecubic: you could definitely create an IO action that returns an infinite list. it's just that the list itself must be generated by pure code, perhaps using data acquired from IO
14:58:43 <jmcarthur> hiptobecubic: without unsafeInterleaveIO, that is
14:58:57 <hiptobecubic> jmcarthur, hmm
14:58:58 <hiptobecubic> yes
14:59:06 <cmccann> I thought it worked better using the CGA model for some reason--maybe just the better coordinate independence?
14:59:08 <jmcarthur> hiptobecubic: have you looked at System.Random?
14:59:09 <hiptobecubic> get a seed via IO and then run a pure RNG
14:59:14 <jmcarthur> right
14:59:14 <cmccann> dunno, it's been ages since I looked at this stuff before :[
14:59:21 * hackagebot sfml-audio 0.7.1.1816 - minimal bindings to the audio module of sfml  http://hackage.haskell.org/package/sfml-audio-0.7.1.1816 (SoenkeHahn)
15:00:06 <donri> when they say e.g. that applicative is a "strong lax monoidal functor", does lax mean the same as non-strict?
15:01:33 <cmccann> ddarius, anyway, thanks for the input
15:04:01 <ddarius> donri: No, it has nothing to do with strictness.
15:04:09 <donri> ok thanks
15:11:43 <Cale> donri: From my understanding, you have strict definitions where there are certain equalities and then weak definitions where those get relaxed into canonical isomorphisms, and then with lax, you just have (possibly not invertible) mappings, and that introduces a convention about the orientation of those things (which direction the mapping goes in), and then the opposite convention, whatever that is, is called oplax.
15:13:01 <Lutin`> donri: http://www.archlinux.org/mirrorlist/
15:13:03 <Lutin`> Whoops
15:13:07 <Lutin`> donri: http://ncatlab.org/nlab/show/lax+functor
15:14:23 <pharaun> geekosaur: yep nailed it down, was not conduit, it was an underlaying library, it was attempting to simulate posixStats via opening the frigging file
15:15:38 <Polarina> I'm getting this error from GHC: Couldn't match expected type `IO <stderr>: hPutChar: invalid argument (invalid character)
15:15:45 <Polarina> Anyone know what that type means?
15:16:20 <c_wraith> Polarina: It means GHC is running with the wrong locale
15:16:24 <cmccann> it means that GHCi can't print the type for some reason
15:16:27 <Cale> Polarina: are you using weird characters in your type variables?
15:16:35 <Cale> (or types)
15:16:41 <Polarina> Ah, transformers-base is doing that then.
15:16:42 <cmccann> I've gotten that with unicode in type names and GHCi on windows
15:17:01 <Nereid> Polarina: GHC started printing the type and then suddenly it broke.
15:17:09 <Nereid> :v
15:17:12 <cmccann> heh, greek letters as type variables
15:17:13 <cmccann> nice
15:17:32 <donri> thanks people
15:17:40 <Cale> ah, yeah, lol
15:17:52 <Cale> liftBase :: b α -> m α
15:17:56 <cmccann> :D
15:18:34 <cmccann> better than doing "type ℝ = Double"
15:18:39 <Nereid> haha
15:19:04 <Polarina> This is very disturbing, now I have to go blind on what's wrong.
15:19:17 <cmccann> Polarina, you could fix the locale issue
15:19:22 <cmccann> but I'm not sure how to do that
15:19:31 <maukd> liftBase :: O b α -> m α
15:20:07 <Cale> Polarina: go into ghci and type  hGetEncoding stdout
15:20:20 <Cale> oh, after importing System.IO
15:20:39 <Polarina> Cale, Just CP850
15:21:31 <Cale> I wonder if there's a way to set your locale in Windows so that it'll use UTF-8
15:21:33 * cmccann wonders whether "x ⊗ (y ⅋ z) ⊢ (x ⊗ y) ⅋ z" is a reasonable type signature...
15:22:15 <atriq> You'd need XTypeOperators
15:22:24 <cmccann> yes
15:22:34 <cmccann> it looks so much nicer than having : before everything
15:23:00 <Polarina> Cale, I got a { newtype MyIO a = MyIO (IO a) deriving (Functor, Applicative, Monad, MonadIO) }, and I need a {MonadBaseControl IO MyIO} instance. Know how I can do that?
15:23:11 <cmccann> kinda miss being able to use (Arrow (~>)) => though...
15:23:30 <Cale> Polarina: What the heck is MonadBaseControl?
15:23:48 <cmccann> it's a monad that's in ur base, controllin ur side effects
15:23:58 <Polarina> Cale, http://hackage.haskell.org/packages/archive/transformers-base/0.3/doc/html/Control-Monad-Base-Control.html
15:23:59 <Cale> Do you mean MonadBase IO MyIO?
15:24:20 <Cale> oh, you're using the older version of transformers-base?
15:24:29 <Polarina> So it would seem.
15:24:51 <Cale> LOL, using η and μ for monads is so screwy
15:25:36 <Cale> Back up a second, why are you using this package?
15:25:55 <Pip> So is there x64 version of haskell platform for windows ?
15:26:28 <Cale> cmccann: I have like 10k lines of code which will have to be refactored because of that (Arrow (~>)) => ... thing :)
15:26:49 <cmccann> Cale, ouch
15:27:50 <Polarina> Cale, netwire seems to depend on it.
15:27:59 <lightquake> Cale: ugh, that sucks :(
15:28:13 <Polarina> Cale, I'm trying to run a IO action inside my wire network.
15:28:18 <Puffton> If you guys were to explain monads to a newbie, how would you do it?
15:28:33 <Polarina> Puffton, how many monads do you know?
15:28:39 <Iceland_jack> Puffton: using loads of examples
15:28:45 <c_wraith> My primary explanation of monads to newbies is "not important.  Don't think about it.  Just learn to use the language."
15:28:49 <Cale> Puffton: First I'd make sure that the newbie actually wanted to understand monads, and not some specific example of a monad.
15:29:00 <lightquake> what c_wraith and Cale said
15:29:13 <shachaf> Puffton: I would say "read the FAQ"
15:29:13 <Puffton> I'm just curious about the general concept
15:29:15 <shachaf> @where faq
15:29:15 <lambdabot> http://www.haskell.org/haskellwiki/FAQ
15:29:19 <hpaste> hiptobecubic pasted “Why isn't this lazy?” at http://hpaste.org/75152
15:29:20 <Puffton> I've read on Wikipedia but that's a formal explanation
15:29:21 <Cale> Puffton: and then I'd give them an interactive version of http://www.haskell.org/haskellwiki/Monads_as_computation
15:30:10 <Puffton> Cale, an interactive version?
15:30:26 <Cale> Puffton: I usually prefer to answer questions as they come up
15:30:38 <Cale> rather than just pointing someone at an article :)
15:30:52 <benmachine> Cale: I think the cahange to TypeOperators is baloney and should be undone
15:30:58 <mcstar> i just dont see the financial aspect of this
15:31:03 <benmachine> but that's just my opinion
15:31:20 <mcstar> from whom do you get the money for this much help-giving?
15:31:24 <Cale> benmachine: I'm not totally sure that it should.
15:31:50 <benmachine> Cale: whoever achieved anything by going around being unsure all the time :P
15:31:57 <mcstar> you guys, can restlessly go over the same topics, and helping anyone
15:32:06 <Cale> mcstar: I'm making $40/hr now that I don't think I would be, had I not spent lots of time helping people online.
15:32:42 <mcstar> Cale: you mean you deepened your understanding by 'teaching'?
15:33:18 <Cale> mcstar: I mean that eventually some of the people I helped and talked with started businesses :)
15:33:32 <mcstar> ah
15:33:39 <mcstar> whoa, never thought og that
15:34:04 <copumpkin> an interactive Cale!
15:34:11 <Puffton> Being the newbie here I guess I don't have much say, but I have learnt a lot in other subjects by helping others, too
15:34:31 <hiptobecubic> Hm... actually I never return a result
15:34:33 <Cale> And yes, I have refined my own understanding of things by going over the presentations of these ideas again and again
15:34:37 <hiptobecubic> that's a problem i guess
15:34:40 <Puffton> Especially in cases where I have had a hard time motivating myself, like in subjects where you can't really see the knowledge applied
15:34:51 <Cale> You don't really get a polished presentation of something without presenting it repeatedly.
15:35:00 <mcstar> true
15:35:11 <Puffton> It can become a kind of motivation. I'm learning it to teach someone, rather than learning just to know it
15:35:21 <Cale> Which is why most of the monad tutorials people write immediately after understanding monads are kinda bad.
15:35:22 <shachaf> double (double Cale'sUnderstanding)
15:35:50 <hiptobecubic> aha... no that's not the problem at all. The problem is I build the list backwards
15:35:59 <hiptobecubic> So i need to know the last element before I can take any
15:36:18 <HankMoody> Young man, you don't understand mathematics, you get used to it. -Neumann
15:36:44 <mcstar> not by any change 'quantum mechanics'?
15:36:48 <mcstar> chance
15:37:18 <ddarius> "kinda"
15:37:18 <Cale> HankMoody: The same could be said of literally anything, but I think it dilutes the meaning of "understand" to think like that.
15:37:34 <Cale> (or perhaps rather, strengthens it beyond usefulness)
15:39:00 * ddarius prefers steamed kale.
15:39:10 <Pip> seriously? 900mb required to install ghc?
15:39:23 * hackagebot QuickCheck 2.5.1 - Automatic testing of Haskell programs  http://hackage.haskell.org/package/QuickCheck-2.5.1 (NickSmallbone)
15:39:25 * hackagebot QuickCheck 2.5.1.1 - Automatic testing of Haskell programs  http://hackage.haskell.org/package/QuickCheck-2.5.1.1 (NickSmallbone)
15:39:27 <shachaf> 900 millibits isn't a lot.
15:39:36 <aristid> Pip: yes, GHC is big.
15:39:40 <mcstar> haha
15:39:50 <Cale> shachaf: hahaha
15:39:58 <Pip> i didn't know that
15:40:03 * ddarius is pretty sure GHC is not 900MB.  However, GHC plus many, many libraries probably is.
15:40:26 <aristid> presumably Pip installed the haskell platform?
15:40:36 <mcstar> 61MB package, 750MB installed
15:40:39 <Pip> yes
15:40:43 <mcstar> only ghc ^^
15:40:54 <Pip> is it recommended ?
15:41:09 <aristid> Pip: sure. you just better have a nice chunk of hard disk space
15:41:25 <ddarius> 1GB is a tiny piece of hard disk space.
15:41:56 <aristid> *shrug* some people have 60 GB SSDs as their main disk because they're cheap
15:42:02 <mcstar> i wouldnt say tiny
15:42:08 * ddarius remembers the days, though, when 50MB was a lot of disk.
15:42:10 <mcstar> we have huge hdd's but that doesnt make it tiny
15:42:14 <Cale> I've downloaded single TV episodes larger than 1GB.
15:42:14 <aristid> i have 128 GB here oO
15:42:18 <shachaf> aristid: If you're cheap, why would you use an SSD as your main disk?
15:42:39 <aristid> shachaf: because it's fast and you think 60 GB is enough?
15:42:40 <ddarius> The low quality SICP lectures are about 700MB each, two for a day, 20(?) days.
15:43:02 <aristid> you can stream most videos instead of downloading.
15:43:16 <mcstar> -rw-r--r-- 1 mcstar users 293M Nov 28  2008 lec1a_512kb.mp4
15:43:18 <simon> 20 lectures about a sick pea. hah!
15:43:36 <bearophile> Hello, I have a small Haskell code design question (I am Haskell newbie), regarding a "newtype". I hope this the right place to ask.
15:43:49 <Cale> The real reason for the installed size of GHC being so large is that in the background it secretly downloads a video of SPJ riding a unicycle.
15:43:49 <simon> bearophile, this is a good place to ask.
15:44:07 <ddarius> For 2 hours.
15:44:15 <Cale> :D
15:44:16 <bearophile> OK. This program needs to use circle arcs:   http://rosettacode.org/wiki/Total_circles_area#Haskell:_Analytical_Solution
15:44:42 <simon> Cale, encoded as gibberish Haskell code.
15:44:48 <bearophile> So it contains types like   data Angle2 = Angle2 Angle Angle, etc
15:45:12 <Cale> bearophile: You're asking why it's   newtype Angle = A Double?
15:45:24 <bearophile> An angle2 is used to represent an arc, with an asociate circle
15:45:31 <bearophile> The Angle is represented as:   newtype Angle = A Double
15:45:38 <bearophile> (I have written part of thar code)
15:45:39 <pharaun> wee submitted my first patch to filesystem-conduit
15:45:40 <cmccann> Cale, that sounds like a great video
15:45:49 <benmachine> @remember Cale The real reason for the installed size of GHC being so large is that in the background it secretly downloads a video of SPJ riding a unicycle.
15:45:49 <lambdabot> It is stored.
15:46:17 <bearophile> So the question is, its it better to represent a pair of angles as   data Angle2 = Angle2 Double Double
15:46:23 <adanuseam> @hoogle log
15:46:23 <lambdabot> Prelude log :: Floating a => a -> a
15:46:23 <lambdabot> Prelude logBase :: Floating a => a -> a -> a
15:46:23 <lambdabot> Network.CGI.Protocol logCGI :: MonadIO m => String -> m ()
15:46:37 <bearophile> Or is it better to define an Angle neewtype, and then define Angle in terms of it?
15:46:54 <aristid> shachaf: so if i had $100 for a main disk and had to choose between a very small SSD and a big HDD, i'd choose the SSD everytime, even if it's not actually enough space to store everything i might want to store.
15:46:54 <ski> bearophile : efficiency-wise, in GHC, it ought to be the same
15:47:03 <bearophile> I ask this because in other languages defining a struct that contains two doubles is normal
15:47:04 <cmccann> also, pf, I have a 1TB external HD and it was pretty cheap
15:47:19 <shachaf> aristid: I'd choose a big HDD + lots of RAM.
15:47:22 <Cale> bearophile: Well, I guess it depends on whether you want to enforce the constraint that Angle values not get mixed up with other Doubles so easily
15:47:23 <bearophile> but defining a single distinct new type is uncommon in most languages.
15:47:24 <adanuseam> ssd. enough online storage for everything else
15:47:39 <bearophile> Cale: that's why I have introduced the newtype.
15:47:40 <adanuseam> multiple ssds in raid *drools*
15:47:44 <ski> bearophile : "typically", with `newtype Bar = MkBar Foo', a `Bar' value will be represented in exactly the same was as a `Foo' value
15:47:50 <Cale> bearophile: right, and that's fine :)
15:47:50 <bearophile> But is this idiomatic and good idea in Haskell?
15:48:03 <Cale> bearophile: It's perfectly idiomatic, and it's what newtype is for.
15:48:07 <ski> bearophile : yes, this is quite common
15:48:09 <bearophile> Because another person has said it's not a so good idea...
15:48:11 <bearophile> OK
15:48:16 <aristid> shachaf: i guess RAM is reasonably cheap these days, but you still need to get all the stuffs into RAM in the first place. so never ever shut down the machine? :)
15:48:25 <bearophile> http://rosettacode.org/wiki/Talk:Total_circles_area#Haskell_analytical_solution
15:48:25 <Cale> bearophile: It *can* be taxing if you do it too much though
15:48:35 <shachaf> aristid: That's what I do.
15:48:40 <shachaf>  15:48:16 up 36 days, 18:27, 10 users,  load average: 0.43, 0.32, 0.22
15:48:41 <bearophile> You see Ledrug questioning it there
15:48:43 <hiptobecubic> > let xs' n = (xs' (n+1) ++ [n]) in take 5 . reverse $ xs' 0
15:48:45 <lambdabot>   *Exception: stack overflow
15:48:53 <hiptobecubic> It's a contrived example, but is there a way to make that work
15:49:07 <aristid> shachaf: and how much of your memory is used by drive cache?
15:49:18 <Cale> bearophile: In that if you define lots of newtypes, the syntactic cost of wrapping and unwrapping them all the time can become annoying -- but in a sense, you define them to force yourself to be explicit about the conversions.
15:49:19 <bearophile> ahschaf: I understand. I think it was OK using it in this case.
15:49:24 <shachaf> aristid: About half, I guess?
15:49:30 <shachaf> I have 8GB and htop is showing 4GB as used.
15:49:39 <hiptobecubic> i know i could do  n:xs' (n+1)  but that's not applicable in the actual case i'm working with I don't think
15:49:40 <aristid> shachaf: well even that way you still have some slowness, for example when you have writes and want to have them committed
15:49:46 <bearophile> I also have had to use  GeneralizedNewtypeDeriving
15:49:52 <simon> hiptobecubic, xs' n first has to generate an infinite list before it appends anything.
15:49:54 <bearophile> To simplify the code a little...
15:49:55 <hiptobecubic> actually, how can that be right... it must be possible
15:49:59 <shachaf> aristid: SSDs can have slowness with that too. :-)
15:50:06 <aristid> shachaf: not nearly as much:)
15:50:14 <benmachine> hiptobecubic: xs' produces an infinite list, you realise that right?
15:50:15 <hiptobecubic> simon, yes but we reverse it and we know what the final element is
15:50:21 <shachaf> aristid: SSD write performance can be very unpredictable.
15:50:34 <benmachine> hiptobecubic: it doesn't *have* a final element
15:50:35 <shachaf> When you're writing to an HDD without seeks, at least you know what you're going to get.
15:50:38 <bearophile> And in the end the Angle was deriving lot of stuff:   newtype Angle = A Double   deriving (Eq, Ord, Num, Fractional)
15:50:48 <benmachine> hiptobecubic: the call to ++ tries to expand the first argument, but it just expands to another call to ++
15:50:55 <aristid> shachaf: if it goes as slow as a hard disk seek, i'd say you have a terrible SSD controller
15:51:01 <hiptobecubic> benmachine, the final element in that example is 0.
15:51:46 <Nereid> hiptobecubic: that's as true as saying the final element in (repeat 1) ++ [0] is 0
15:51:47 <bearophile> Thank you for the answers. Your answers are that it's good, unless the price to pay becomes higher than the advantages doing that brings :)
15:52:00 <simon> hiptobecubic, but the way reverse works is by traversing the list (which is infinite). if you could reverse an infinitely list, it'd work.
15:52:04 <hiptobecubic> Nereid, and? Is that not try?
15:52:06 <hiptobecubic> true*
15:52:07 <simon> s/infinitely/infinite/
15:52:09 <Nereid> hiptobecubic: it really isn't
15:52:15 <Nereid> because repeat 1 ++ [0] = repeat 1
15:52:23 <bearophile> See you later.
15:52:54 <hiptobecubic> Nereid, surely there is some difference between them, even if it's impossible to evaluate it completely
15:52:59 <Nereid> there is no difference
15:53:12 <hiptobecubic> if we print them backwards, it's obviously different
15:53:15 <Nereid> a ++ b = a whenever a is infinite
15:53:19 <Nereid> you can't print repeat 1 backwards
15:53:37 <hiptobecubic> Nereid, no, but you don't have to in order to print 0
15:53:39 <shachaf> Nereid: That's why I use FMList!
15:53:39 <simon> hiptobecubic, you could construct a language with these semantics of the last elements of infinite lists and create operators that reverse them without traversing them.
15:54:11 <benmachine> simon: I don't think it's even really an infinite list - there are never any conses generated
15:54:14 <benmachine> it's just an infinite loop
15:54:35 <Nereid> hiptobecubic: no look
15:54:38 <Nereid> @src (++)
15:54:38 <hiptobecubic> but because of the reverse, we don't need to enter it
15:54:38 <lambdabot> []     ++ ys = ys
15:54:38 <lambdabot> (x:xs) ++ ys = x : (xs ++ ys)
15:54:38 <lambdabot> -- OR
15:54:38 <lambdabot> xs ++ ys = foldr (:) ys xs
15:54:47 <shachaf> λ> let l = FM.repeat 1 <> FM.singleton 0 in (FM.head l,FM.last l,FM.last (FM.init l))
15:54:50 <shachaf> (1,0,1)
15:54:52 <simon> benmachine, right.
15:55:09 <Nereid> shachaf: now reverse it
15:55:19 <hiptobecubic> Nereid, ok i'll accept that the implementation of (++) doesn't allow it. But I still think it's clear that the last element of the list is 0.
15:55:25 <aristid> simon: what's FMList?
15:55:28 <Nereid> hiptobecubic: it really isn't clear
15:55:30 <benmachine> hiptobecubic: I guess the thing to understand is that xs ++ [n] does not put n on the end of xs
15:55:35 <aristid> i mean shachaf
15:55:40 <benmachine> hiptobecubic: it puts xs on the beginning of [n]
15:55:46 <benmachine> hiptobecubic: because lists are built left-to-right
15:56:02 <shachaf> λ> let l = FM.reverse (FM.repeat 1 <> FM.singleton 0) in (FM.last l,FM.head l,FM.head (FM.tail l))
15:56:05 <shachaf> (1,0,1)
15:56:07 <Nereid> hiptobecubic: repeat 1 ++ [0] and repeat 1 are completely indistinguishable
15:56:08 <shachaf> aristid: It's a thing.
15:56:08 <benmachine> hiptobecubic: in the case that xs doesn't have an end, [n] is in no sense the end of the list xs ++ [n]
15:56:11 <Nereid> because they deconstruct in exactly the same way
15:56:11 <shachaf> @google FMlist
15:56:13 <lambdabot> Plugin `search' failed with: getAddrInfo: does not exist (Name or service not known)
15:56:19 <shachaf> @hackage fmlist
15:56:19 <lambdabot> http://hackage.haskell.org/package/fmlist
15:56:25 <benmachine> Nereid: they are not only indistinguishable, they are strictly equal
15:56:28 <Nereid> yes
15:56:35 <hiptobecubic> hm
15:56:36 <benmachine> well, I guess that's pedantry
15:56:38 <benmachine> carry on :)
15:56:39 <Nereid> yes
15:57:39 <Nereid> shachaf: fromList :: [a] -> FMList a is not surjective, then.
15:57:58 <hiptobecubic> So if i say to you. There is an infinite chain here with a 0 afterwards. You're telling me that's exactly the same in a theoretical sense as if i had just said "this is an infinite chain"
15:58:24 <shachaf> Nereid: What do you mean?
15:58:24 <Nereid> hiptobecubic: yes, because we can only see things up to omega
15:58:43 <hiptobecubic> And then I say, "Ok so what's after the infinite chain", you say "that's stupid." in both cases?
15:58:53 <shachaf> Nereid: You mean that fromList (repeat a) ++ fromList (repeat b) /= fromList (repeat a ++ repeat b)?
15:59:04 <maukd> oh god, not another 0.99999... "discussion"
15:59:09 <Nereid> shachaf: that too
15:59:16 <hiptobecubic> maukd, ;)
15:59:26 <Nereid> well just replace (repeat b) with a singleton even.
15:59:41 <maukd> "yes, but what if I have infinite 9s but with a 8 at the end?"
15:59:49 <Nereid> shachaf: because evidently last (fromList (repeat 1 ++ [0])) is different from last (fromList (repeat 1) ++ fromList [0])
15:59:56 <shachaf> Nereid: Ah, you mean that there are some FMlist that you can't generate with fromList.
15:59:59 <shachaf> Yes.
16:00:00 <hiptobecubic> maukd, i think the problem here is that i'm trying to abuse the fact that one is written with 9's and one is written with 0's, even though they mean the same thing.
16:00:01 <Nereid> yes.
16:00:08 <Nereid> that is what not being surjective means.
16:00:09 <aristid> shachaf: so FMList is just everything that a foldMap can be defined for?
16:01:22 <ddarius> s/means/implies/
16:01:53 <hiptobecubic> Anyway i'm off for the night. You guys can go back to your *real* math. Where 1=1 and things are consistent.
16:02:04 <Nereid> can we think of (FMList a) as (exists t (which is Foldable). t a)?
16:02:06 <ddarius> 1=0.99999....
16:02:17 <hiptobecubic> ddarius, looks the same to me
16:02:19 <hiptobecubic> :)
16:02:44 <Nereid> hiptobecubic: the repeat 1 ++ [0] = repeat 1 thing and 0.999... = 1 have a lot of similarities actually.
16:03:04 <hiptobecubic> Nereid, they do. I understand the issue. I just wish i could cheat
16:03:06 <Nereid> because you can look at recursive things as being the limit of some sequence.
16:03:07 <Nereid> haha.
16:03:33 <hiptobecubic> If haskell was a third grader, this would be obvious.
16:03:53 * cmccann recalls 1 + 2 + 3 + 4 + ... = -1/12
16:03:56 <Nereid> ahha.
16:04:31 <hiptobecubic> cmccann, that's new to me
16:04:39 <Nereid> cmccann: I've pondered whether there's some natural-ish topology on (say, rational) numbers that makes that true.
16:04:50 <Nereid> much like the 1-adic topology makes 1 + 2 + 4 + 8 + ... = -1
16:04:53 <Nereid> er 2-adic
16:05:04 <Cale> hiptobecubic: It comes from abusing the series definition of the Riemann zeta function, and confusing it with its analytic continuation.
16:05:27 <cmccann> yeah, what Cale said
16:05:43 <hiptobecubic> Cale, I see.
16:06:09 <hiptobecubic> Well, i mean that in the idiomatic sense, because actually I don't see how that works out yet.
16:06:16 <Cale> hiptobecubic: for complex values s with Re(s) > 1, you have zeta(s) = sum over k >= 1 of k^(-s). The analytic continuation of zeta has zeta(-1) = -1/12
16:06:36 <Cale> if you plug that back into the series formula, you get sum over k >= 1 of k = -1/12 :)
16:07:06 <ddarius> Everyone loves s times the Mellin transform of the floor function.
16:07:27 <hiptobecubic> Cale, I appreciate it. I pasted it into vim to read in the morning. But now is not the time. As the clock rolls onward into the night, I only get farther from the truth.
16:07:37 <Nereid> it's too bad I don't know anything about number theory, analytic or otherwise.
16:07:50 <ddarius> Nereid: Do you know complex analysis?
16:07:53 <Nereid> sure.
16:08:00 <ddarius> Nereid: Then you know analytic number theory.
16:08:03 <Nereid> haha.
16:08:05 <Cale> Of course, Re(-1) is not greater than 1, so it's not actually valid. Physicists apparently do this kind of thing though.
16:08:32 <Nereid> Cale: and the scary thing is that a lot of the time it works.
16:09:56 * cmccann enjoyed the question on Stack Overflow from a mathematician abusing power series expansion to talk about algebraic data types and asking "this is clearly bogus so why does it work?"
16:10:04 <benmachine> Cale: I wouldn't say it's categorically invalid, just that we don't have a way of interpreting it that makes it valid
16:10:09 <benmachine> there might be one?
16:10:15 <ddarius> Nereid: You can define a Dirichlet convolution and then a "Dirichlet transform" and then you have a convolution theorem.  From there it's easy and fun to work out various interesting number theoretic functions and their Dirichlet transforms.
16:10:17 <shachaf> cmccann: Which question was that?
16:10:31 <Cale> benmachine: Well, the sum does not converge.
16:10:43 <cmccann> shachaf, http://stackoverflow.com/q/9190352/157360
16:10:44 <Cale> benmachine: So it's just not equal to -1/12
16:10:47 <lightquake> cmccann: there was a proof somewhere that you can use ADT equations as equations for complex variables, and any result you get that isn't 'obviously wrong' is right
16:11:04 <lightquake> so you can get T=T^7 for binary trees
16:11:23 <ddarius> Types do form a vaguely ring-like structure, so any result that only depends on that structure holds.
16:11:40 <Nereid> cmccann: formal power series.
16:11:40 <cmccann> in particular I like the stuff about bijections between trees and seven-tuples of trees
16:11:44 <shachaf> Semiring, isn't it?
16:11:50 <cmccann> oh, lightquake just mentioned that, nevermind
16:12:07 <ddarius> The theory of combinatorial species extends and explains a lot of this.
16:12:07 <benmachine> Cale: right, but when you have 1 + 2 + 3 + ... one might argue that the Euclidean limit of partial sums is not necessarily the only way you might interpret that
16:12:20 <lightquake> i don't have the pdf on me though
16:12:33 <ddarius> @google types complex numbers trees
16:12:35 <lambdabot> http://www.postgresql.org/docs/8.1/static/xindex.html
16:12:35 <lambdabot> Title: PostgreSQL: Documentation: 8.1: Interfacing Extensions To Indexes
16:12:36 * shachaf imagines lightquake carryingg hundreds of printed papers everywhere he goes.
16:12:44 <ddarius> @google types "complex numbers" trees
16:12:45 <cmccann> lightquake, http://www.math.lsa.umich.edu/~ablass/comb.html ?
16:12:48 <lightquake> http://arxiv.org/pdf/math/0212377.pdf
16:12:55 <lambdabot> http://www.tutornext.com/math/classification-of-number-system.html
16:12:55 <lambdabot> Title: Classification of Number System | TutorNext.com
16:12:58 <lightquake> cmccann: it's an extension of that one
16:13:08 <cmccann> ah, ok
16:13:18 <benmachine> Cale: just like you might say "the integral of the indicator function of the rationals does not converge" because you only have the Riemann integral and not the Lebesgue one
16:13:28 <Cale> benmachine: "Euclidean" is a bit funny there, this notion of limit is due to Cauchy, I believe.
16:13:35 <lightquake> basically t=p(t) => q1(t) = q(t) can be transformed into an isomorphism over ADTs
16:13:40 * ddarius knows what paper lightquake is talking about but doesn't remember the title well enough.
16:13:51 <lightquake> (i just posted it)
16:13:52 <benmachine> Cale: yeah I only meant to refer to the topology
16:13:52 <Cale> But yes, you can come up with other types of summation to make it work out.
16:14:23 <benmachine> (of course Euclid didn't know what a topology was. luckily, he's dead, so he won't mind)
16:14:29 <Cale> :)
16:14:36 <Iceland_jack> benmachine: I have it on good authority that he does
16:14:55 <ddarius> benmachine: Do you have proof that he's dead?
16:15:00 <benmachine> Iceland_jack: well, pass on my apologies, then
16:15:10 <Cale> EUCLID IS HIDING OUT WITH ELVIS
16:15:23 <lightquake> EVCLID
16:15:25 <lightquake> ELVIS
16:15:28 <lightquake> coincidence?????????
16:15:32 <cmccann> :O
16:15:33 <Iceland_jack> lightquake: (probably)
16:15:47 <benmachine> ddarius: proof by someone told me so
16:16:23 * cmccann defines Elvisian geometry, with a notion of instance defined by whether a point has left the building
16:17:04 <Cale> It may be that Euclid cannot be dead because he never lived?
16:17:36 <atriq> Euclid's dead!?
16:17:48 <cmccann> that is not dead which can eternal lie :O
16:18:03 <dmwit> But Euclid told the truth!
16:18:22 <maukd> yet with strange aeons even axioms may die
16:18:28 <cmccann> hahaha
16:19:28 <ddarius> dmwit: I measured all his diagrams and not a single one satisfied the laws he was stating.
16:20:24 <Cale> His axioms were actually insufficient to prove many of his results. Even the construction of a regular triangle doesn't really work, because there's no way to guarantee that the two circles you construct will intersect.
16:20:57 <ddarius> They often won't.
16:21:15 <maukd> http://en.wikipedia.org/wiki/Logicomix
16:22:44 <ddarius> y = x and x^2 + y^2 = 1.  No solutions.
16:23:35 <Cale> Does anyone know of any algorithms for decomposing an integer n into a perfect square and a squarefree part which are better than general integer factorisation?
16:24:12 <cmccann> Logicomix is pretty neat
16:24:51 <cmccann> Cale, just pick a perfect square as your integer, then you're done
16:24:53 <cmccann> :D
16:25:57 <Cale> What's an imperfect square anyway?
16:26:59 <cmccann> a square with a criminal record?
16:28:30 <Cale> Can a square even be a perfect number? :)
16:29:59 <benmachine> interesting
16:30:04 <benmachine> I see no reason why not
16:30:17 <cmccann> Cale, probably not
16:30:26 <benmachine> square numbers are the only numbers with an odd number of factors
16:30:36 <latro`a> uh
16:30:40 <latro`a> you mean divisors
16:30:44 <benmachine> err
16:30:48 <benmachine> what's the difference
16:30:56 <latro`a> "factor" makes me think "prime factor"
16:30:59 <latro`a> which would be wrong
16:31:10 <Nereid> why doesn't divisors make you think "prime divisor", then?
16:31:12 <benmachine> "prime factor" makes me think "factor which is prime"
16:31:13 <Nereid> divisor*
16:31:31 <latro`a> not sure, but I haven't heard the term "factor" used to refer to a generic divisor of a number
16:31:33 <latro`a> so it seems strange
16:31:33 <Cale> benmachine: When you say "factors" you're making an implicit reference to a representation of the number as the product of some numbers which are called the factors.
16:31:46 <latro`a> yeah
16:31:53 <latro`a> that's what underlies it, I guess
16:31:55 * benmachine shrug
16:31:58 <benmachine> I suppose
16:31:59 <ddarius> latro`a: Cale's statement still doesn't say they are prime.
16:32:20 <latro`a> I was talking about benmachine's statement
16:32:21 <benmachine> anyway, 36 is abundant, 25 is deficient
16:33:57 <Nereid> well clearly no even square can be perfect
16:34:10 <benmachine> Nereid: why not?
16:34:14 <latro`a> I think I just showed that clearly no odd square can be perfect too
16:34:17 <Nereid> because it has an odd number of odd divisors
16:34:46 <latro`a> actually
16:34:51 <benmachine> Nereid: ...why?
16:34:51 <latro`a> are *any* odd numbers perfect
16:35:03 <latro`a> ah nvm
16:35:18 <benmachine> http://oeis.org/A000396 I have this to hand :P
16:35:26 <benmachine> none of the small ones are
16:35:39 <Nereid> benmachine: because the odd divisors of 2^n k (k odd) are in bijection with the divisors of k, and if 2^n k is a square then k is a square, so has an odd number of divisors
16:35:41 <latro`a> wait...an odd number which is perfect would actually have to be a square
16:35:59 <latro`a> because an odd number which is perfect and not a square would be a sum of an even number of odd numbers and hence even
16:36:21 <benmachine> latro`a: that makes sense
16:36:36 <benmachine> Nereid: okay, fair enough
16:37:24 <unlink> Is WAI the One True application server interface in Haskell which new servers and frameworks are gravitating towards, or is there competition or otherwise a lack of consensus?
16:37:47 <shachaf> unlink: #haskell-web probably knows more.
16:38:32 <unlink> shachaf: Thanks.
16:38:54 <Cale> unlink: I haven't heard of any other ones.
16:39:13 <Cale> unlink: Do you know of any?
16:39:19 <sm> unlink: yes, but verrry slooowwly
16:39:44 <unlink> Cale: Happstack uses its own bespoke Request and Response data types, whereas Snap depends on a slightly server/framework agnostic iteratee-based Snap monad.
16:40:05 <Cale> unlink: Okay, so that's just not using such a standardised interface.
16:41:53 <mysticc> I have a Datatype like Data X = Map String B where B is data B = [C] and data C = C1 String | C2 Int | C3 something ... .. I need to provide some persistent way to store X .. It is just a class assignment so I need it to be easy so I am quickly done with it ..
16:42:24 <deech> Is there any connection between "join" and "extract" in comonads?
16:42:50 <Cale> deech: comonads don't have join
16:43:06 <maukd> mysticc: show
16:43:07 <shachaf> deech: "extract" is more similar to "return" than to "join".
16:43:08 <unlink> I mainly ask because I don't like WAI. It feels considerably more ad-hoc than WSGI, Rack, ring, or even J2EE. For example, the Response data type is a concrete data type with three specialized constructors (e.g. ResponseFile), and the API explicitly wires in types from the blaze-builder and conduit packages.
16:43:20 <mysticc> maukd: show ??
16:43:51 <Cale> unlink: Which is probably the reason why other web application libraries aren't using it :)
16:43:51 <deech> Cale: Yes but I was thinking of join as removing one layer of context and extract seems to do something similar.
16:44:05 <maukd> mysticc: yes
16:44:35 <mysticc> maukd: I mean what show ? .. I need to store X persistently ..
16:44:56 <maukd> mysticc: what do you mean, "what show"?
16:44:59 <mysticc> maukd: and read it back later too
16:45:03 <maukd> Prelude.show
16:45:16 <Cale> deech: Well, yeah, purely in terms of the type, fmap extract :: (Comonad w) => w (w a) -> w a
16:45:41 <mysticc> maukd: That will convert it to string .. Then I will have to think of writing Read too ..
16:45:44 <ParahSailin> i get the maybe, list, and io monads-- whats another good one to grok?
16:45:51 <unlink> Cale: Maybe. Unfortunately the lack of a good, generic application interface specification puts a huge damper on prospects of distributing and maintaining portable middleware libriares or web servers for Haskell. sigh.
16:45:52 <Cale> ParahSailin: State s
16:45:56 <mysticc> ParahSailin: State .
16:46:04 <maukd> mysticc: deriving, not writing
16:46:18 <shachaf> monad++
16:46:19 <shachaf> Er.
16:46:20 <shachaf> monad--
16:46:21 <shachaf> monads++
16:46:22 <Nereid> State is the most natural monad.
16:46:31 <latro`a> I think under the right subcategory, fmap extract = join
16:46:37 <latro`a> er, s/under/in
16:46:38 <maukd> ParahSailin: Reader, Writer
16:46:58 <Nereid> understanding State is a pretty good thing to do.
16:46:59 <latro`a> this isn't true over all of Hask, obviously, though it is probably true for monads whose comonad is a monad on all of Hask
16:47:00 <Cale> unlink: I don't really understand what these things are though. (Maybe I should because I'm working on a web application as my job...)
16:47:18 <mysticc> maukd: oh .. ok
16:47:20 <unlink> Cale: what things?
16:47:33 <deech> Cale: Ah, that makes sense. But it's probably more useful to think of it as a version of "return" as you said. Thanks for the input!
16:47:39 <mysticc> maukd: I though read will be ambiguous for a given show .. let me check ..
16:48:00 <Cale> unlink: These application interface specifications and middleware libraries that people talk about.
16:48:21 <Cale> deech: It's like return, but the opposite :)
16:48:53 <unlink> Cale: Check out Python's WSGI. Probably the most successful such example (unless you count J2EE and servlets, which are considerably more general).
16:50:16 <Nereid> extract = coreturn
16:51:51 <eyebloom> Is it possible to use typeOf to determine the type of a function: such as for example typeOf (\x -> False)
16:52:06 <latro`a> > typeOf (\x -> False)
16:52:07 <lambdabot>   Ambiguous type variable `t' in the constraint:
16:52:07 <lambdabot>    `Data.Typeable.Typeable t...
16:52:12 <latro`a> bah
16:52:17 <Cale> unlink: I kind of understand that the idea is to standardise the type of a web application, such that functions on web applications can be written in general, and then plugged in without having to think about how things need to be adapted. I'm not totally sure that it's actually worth the constraints that it would put on web servers and applications though.
16:52:21 <latro`a> > typeOf (\x y -> x+y)
16:52:23 <lambdabot>   Integer -> Integer -> Integer
16:52:30 <Cale> Unless it can be done at an extremely high level of abstraction.
16:52:49 <maukd> > typeOf ord
16:52:50 <lambdabot>   Char -> Int
16:52:52 <eyebloom> I see so if their is an open type variable then it doesn't work?
16:52:58 <Cale> eyebloom: If it's monomorphic, yeah.
16:53:10 <Cale> eyebloom: Typeable only works for monomorphic types.
16:53:55 <unlink> Cale: Maybe it's not possible in Haskell, but it's done quite successfully in Python, Ruby, Perl, clojure, Java, ...
16:54:12 <Cale> unlink: and it's generally seen as having been a good idea?
16:54:13 <cmccann> Cale, things at an extremely high level of abstraction? who does THAT?
16:54:25 <ddarius> unlink: Why would it not be possible?  You already pointed out an example.
16:54:57 <Cale> unlink: I'm questioning whether such a thing really lets you write two webservers which are distinct in any fashion which is worthwhile.
16:55:52 <luite> i think it's more the other way around, write two apps but only write the web server part once?
16:56:00 <unlink> Cale: Why should a web server have an opinion on the name of the ADT that encodes the request method, for example? Or the accessor that gives the request headers?
16:56:22 <ddarius> luite: You are misunderstanding what Cale is saying.
16:56:35 <ddarius> luite: He's saying that the -providers- of the interface are all essentially the same.
16:56:55 <luite> oh right
16:57:06 <Cale> Maybe I'm just wrong here
16:57:14 <Cale> I don't know enough about this to really say
16:57:31 <unlink> luite: No, it's both. Any web server should be able to support a given application. For example in Python, I can write my application generically, and Apache, CherryPy, gunicorn, uWSGI, twisted.web, and many more can run my application without changes.
16:57:39 <Cale> But just looking at WAI, it seems to be extremely opinionated about what the webserver ought to look like internally.
16:57:49 <unlink> Cale: Right, which is my criticism of WAI.
16:58:01 <Cale> but I'm not sure how to replace this definition by one which isn't opinionated
16:58:14 <Cale> If you have one, maybe you should write that library :)
16:58:19 <eyebloom> Is it impossible to write a version of typeOf that works for polymorphism.
16:58:22 <eyebloom> ?
16:58:25 <Cale> eyebloom: yes
16:59:05 <Cale> eyebloom: because allowing typeclasses which "pattern match" on the "forall" part is a can of worms.
16:59:15 <ddarius> Clean does it.
16:59:25 <cmccann> we need a "kindOf" function to go with "typeOf".
16:59:27 <Cale> Oh, really?
16:59:32 <Cale> I didn't know that1
16:59:34 <cmccann> should be easy to implement
16:59:37 <Cale> s/1/!/
16:59:41 <unlink> The trouble with authoring such a library (or specification, rather) is that in order to be of any use, it needs wide community acceptance and a suite of tools both at the middleware (e.g. routing, static file serving, HTTP authorization, etc) -level, as well as the web server level.
16:59:51 <Nereid> cmccann: kind classes? :O
16:59:52 <eyebloom> What is Clean?
16:59:58 <unlink> Consequently it's not very useful to write anything in the absence of a conversation.
16:59:59 <ddarius> Clean's dynamic type is more built-in.  It residuates the type checking algorithm which allows you to package up polymorphic types.
17:00:15 <Nereid> eyebloom: a language
17:00:15 <Cale> unlink: Well, you're not going to convince anyone to use an interface which doesn't exist :)
17:01:05 <eyebloom> Got it.
17:01:33 <Cale> eyebloom: Clean is Haskell's sibling
17:01:43 <ddarius> Older sibling.
17:01:55 <Cale> (but just slightly, iirc)
17:02:14 <ddarius> Yes.
17:02:48 <Nereid> is clean worth learning?
17:03:17 <Nereid> (terrible question, I know)
17:04:28 <ddarius> It's -very- similar to Haskell.  The main difference is uniqueness typing.  There is a lot of cool technology in Clean though.
17:06:01 <Nereid> that's the part I'm interested in.
17:06:02 <hbIppo> ddarius: what do you mean with uniqueness typing?
17:06:29 <Cale> hbIppo: You can have types which express that a parameter to a function occurs at most once in the body of the function.
17:06:31 * ddarius needs some superglue.
17:06:45 * cmccann should implement a toy language with linear types one of these days
17:07:17 <hbIppo> cale: and what benefit does it give?
17:07:27 <Cale> hbIppo: and which indicate that a value may be consumed in at most one location.
17:07:45 <ddarius> cmccann: Uniqueness typing is subtly different from linear typing.
17:07:51 <Cale> hbIppo: For one, you can expose optimisations which would otherwise be difficult to prove correct
17:07:52 <cmccann> yes, I know
17:08:36 <hbIppo> cale: thought so, but besides optimization?
17:09:00 <Cale> hbIppo: Secondly, you can do impure I/O which is safe in the presence of lazy evaluation, passing RealWorld tokens around explicitly, and having the compiler prove that each RealWorld is used in exactly one place
17:09:02 <simon> unlink, Cale: I traced back a part of the conversation on web frameworks. I'm not sure exactly what other web frameworks do that ones written in Haskell don't.
17:09:19 <hbIppo> cale: ok, now this is cool.
17:09:24 <hbIppo> definitely cool
17:10:23 <Cale> I'm honestly not so convinced that this is actually that useful, relative to representing IO actions by values.
17:10:49 <ddarius> It definitely has some useful consequences
17:10:49 <hbIppo> I didn't say useful, I said cool :D
17:10:49 <unlink> simon: My gripe is that in other languages, they agree on their web server application interface, and can consequently share middleware or target each other's web servers (or elect not to ship a web server at all).
17:11:11 <Cale> I think the optimisations you can do are cool though.
17:11:58 <Cale> Being able to avoid allocation altogether and just write a new value into memory that you've already allocated because you're sure that it's not used anywhere else is pretty nice.
17:12:14 <Cale> I think it's a little more operational in nature than I'd usually like things to be though.
17:12:14 <cmccann> couldn't you thread the RealWorld tokens through a state monad anyway to get the same result?
17:12:25 <Cale> cmccann: yes
17:12:26 <cmccann> you'd just be able to have runIO that spits the token back out
17:12:50 <Cale> cmccann: You can construct an IO monad in Clean (for years, you couldn't because Clean didn't have constructor classes, but it does now)
17:13:10 <Cale> So you can have a proper Monad class and make an IO instance of it.
17:13:18 <Cale> Of course, you'd be swimming upstream to do that
17:13:47 <shachaf> Cale: Then again, to be using Clean you'd have to be streaming upstream in the first place.
17:14:05 <shachaf> I think the order of my words got mixed up there.
17:15:52 <simon> unlink, I'm not sure I understand what is meant by agreeing within a language about web server application interfaces. do python developers discuss how django is built? or do you mean that different web server developers within the python community have agreed upon a similar internal interface for interchangeable components (middleware)?
17:17:24 <Nafai> simon: yes, there is a middle-ware standard (wsgi) that Python has
17:17:34 <unlink> simon: Django is a bad example because it predates WSGI's popularity and is correspondingly at odds with its design, exhibiting only nominal compatibility.
17:18:52 <unlink> simon: I mean that other frameworks express their abstractions as interoperable middleware abstractions which themselves work with any participating web server (which are numerous), and that that interface is the same for middleware and for web servers.
17:19:32 * hackagebot TCache 0.10.0.3 - A Transactional cache with user-defined persistence  http://hackage.haskell.org/package/TCache-0.10.0.3 (AlbertoCorona)
17:19:34 * hackagebot Workflow 0.7.0.5 - Monad transformer for thread state persistence and workflow patterns  http://hackage.haskell.org/package/Workflow-0.7.0.5 (AlbertoCorona)
17:19:36 * hackagebot MFlow 0.1.5.4 - Web app server for stateful processes with safe, composable user interfaces.  http://hackage.haskell.org/package/MFlow-0.1.5.4 (AlbertoCorona)
17:21:33 <simon> unlink, I haven't read about WSGI before now. is there something that prevents Haskell from using WSGI?
17:21:51 <unlink> simon: Yes, it's intrinsicly python-specific.
17:22:52 <unlink> simon: For example, the wsgi.input parameter is a file-like object, which has no direct Haskell equivalent.
17:25:28 <simon> unlink, ok. I've built some number of websites using PHP/Ruby/Perl/Python and the frameworks they offer, and I don't like any of them particularly much. I'd settle with anything remotely better than CGI, or maybe just CGI.
17:27:29 <unlink> simon: Yes, WSGI is in my opinion strictly superior to CGI for Python applications. Using werkzeug or webob with WSGI applications offers a program experience at a similar level of abstraction to CGI which is considerably more convenient, and also offers the efficiency benefits of an application server and composability of middleware.
17:28:45 <unlink> Unfortunately in Haskell, we are still trying to figure out which library we want to use to model the request body and response stream, and consequently are unable to agree on something as basic as WSGI.
17:34:39 <pharaun> WAI ?
17:35:01 <hpc> NOWAI
17:35:11 <unlink> I think it's a stretch to say that everyone agrees on WAI.
17:35:34 <pharaun> yeah but i just see it on 2 web projects, yesod and uh happstack
17:35:46 <pharaun> its the other one that has their own i think, i only know of wai via yesod
17:36:13 <unlink> Snap and Happstack both natively prefer other web server abstractions.
17:36:24 <pharaun> aha i see
17:36:54 <tsou> scotty uses WAI as well..
17:37:22 <unlink> Oh that's a cute framework. I wonder why I've never seen it.
17:38:00 <tsou> coincidentally i was checking its documentation earlier today; never used it
17:38:12 <cmccann> obviously the solution is to create yet another alternative and promote that as a standard
17:38:19 <cmccann> that always works
17:38:45 <unlink> Yes. Everyone is simultaneously successful at that effort :-)
17:39:15 <donri> unlink: but why do you feel you need something like wsgi?
17:40:32 <zomg> Does anyone have any suggestions why I might be getting a segfault in my app with GHC 7.4.1 when it worked just fine in GHC 7.0.3
17:40:46 <zomg> Everything was compiled from fresh again, all ghc packages, etc.
17:41:14 <benmachine> zomg: a segfault, huh
17:41:15 <benmachine> weird
17:41:41 <benmachine> do you use the FFI, or vector, or anything else unsafe?
17:41:53 <donri> or a package that does, like curl
17:42:15 <zomg> benmachine: not to my knowledge, but I am using Yesod which I don't know if it does or not
17:42:29 <benmachine> I don't know about Yesod
17:42:33 <benmachine> I'd assume it was safe, but it's pretty large
17:42:35 <zomg> I can try to figure it out but not sure how to go about it
17:42:41 <benmachine> so maybe some corner is problematic
17:42:54 <benmachine> zomg: well, try to isolate when it happens, perhaps
17:43:10 <benmachine> I'm sure there are ways to get the profiler to help you, but I don't know about them
17:43:37 <zomg> Yeah was suggested to check the backtrace with gdb but it's not really giving anything for it
17:44:17 <benmachine> that doesn't surprise me
17:44:29 <benmachine> GHC isn't a C program, nor very much like one
17:45:54 <Cale> zomg: The thing about segfaults in Haskell is that when they show up they're usually someone else's problem
17:46:29 <benmachine> Cale: unless you're doing peek nullPtr somewhere :P
17:46:31 <Cale> zomg: In this case, maybe Michael Snoyman's problem, or maybe Simon Marlow's :)
17:46:35 <zomg> heh
17:46:52 <zomg> Yeah I tried to compile ghc 7.6.1 but I couldn't get cabal install running with that
17:47:42 <benmachine> oh, um, I could :P
17:47:44 <benmachine> but
17:47:48 <benmachine> not much else, to be fair
17:47:59 <benmachine> library support on 7.6 is still a little sparse
17:48:18 <zomg> I see, not really familiar with how much haskell changes between minor releases
17:48:37 <Cale> 7.4 to 7.6 isn't really a minor release
17:48:52 <Cale> 7.4.1 to 7.4.2 is a minor release
17:48:55 <zomg> Yeah I'm probably used to a different versioning style =)
17:49:29 <zomg> I wonder if it could be an issue in gcc or whatever..
17:49:31 <benmachine> GHC releases tend to be all fairly major on account of how they're all binary-incompatible with each other :P
17:49:50 <zomg> Since in addition to upgrading 7.0.3 -> 7.4.1 GHC, I did upgrade my Ubuntu version from 10.4 to 12.4
17:50:11 <zomg> Who knows if there was some old junk lying around that just breaks stuff now...
17:50:16 <zomg> Not I at least :P
17:50:18 <Cale> zomg: heh, how's the new Ubuntu treating you?
17:50:22 <ddarius> benmachine: Only because of some bits in the .hi files.
17:50:36 <zomg> Cale: not seeing a big difference besides ghc not working since I'm just running it on my vps =)
17:50:46 <zomg> well ghc does work, but my application fails with that cryptic error
17:50:48 <Cale> zomg: ah, okay
17:51:47 <Cale> zomg: I tried upgrading on my desktop machine, and was forced to switch back by random crashes to login screen (among lots of other irritating but more reasonably solvable issues)
17:52:32 <simon> unlink, thanks for the references. I'll check out werkzeug or webob if I need to do something like that.
18:31:55 <hpaste> scooty-puff pasted “MonadThrow/MonadCatch” at http://hpaste.org/75161
18:39:20 <hpaste> scooty-puff pasted “MonadThrow/MonadCatch” at http://hpaste.org/75162
18:49:44 <mysticc> For ord defining only < will do ?
18:50:08 <pharaun> <= i believe
18:50:11 <shachaf> mysticc: Hoogle will tell you. :-)
18:50:15 <pharaun> but yeah ^
18:53:07 <Anpheus_> I appear to be horribly misunderstanding the Reader monad - I have a typeclass that is parameterized by (Monad m) => ... m b .... The idea is that the monad can provide additional behavior for implementers of the typeclass. One such instance of that behavior might be just to store an environment or settings. The implementer might not choose to do anything inside the monad, so I figured the instance declaration this would be "Reader En
18:53:35 <shachaf> figured the instance declaration this would be "Reader En
18:53:43 <Anpheus_> oh it cut off
18:53:43 <Anpheus_> ok
18:53:51 <Anpheus_> so I figured the instance declaration this would be "Reader Environment ()". But I don't know how to *instantiate* a "Reader Environment ()" with some settings.
18:53:53 <Anpheus_> And perhaps that's meaningless, but for example, what I want is something that behaves very much like Identity except the value is constant. Is this even sensible? Does this parse?
18:53:55 <mysticc> shachaf: If I have 4 constructors in my data type .. Do I need to define compare for all 4c2 combinations ? my data type is A s|B s|C s|D s .. I want to make ord such that A < B < C < D
18:54:00 <shachaf> But why are you having a type class?
18:54:18 <maukd> mysticc: why not just derive the instance?
18:54:23 <shachaf> mysticc: No, you wouldn't need to do that even if you were writing it by hand.
18:54:25 <shachaf> But just use deriving.
18:54:45 <Anpheus_> shachaf: Is that directed to me?
18:54:48 <shachaf> Yes.
18:54:52 <mysticc> shachaf: I mean I dont have constructor names as A,B etc and types of s are not same for all ..
18:54:54 <shachaf> Anpheus_: I don't think what you're saying makes sense, but maybe that's just because I don't understand it. :-)
18:55:07 <mysticc> how will deriving know what I want ..
18:55:21 <shachaf> Anpheus_: "Reader a b" is pretty much the same as "a -> b"
18:55:33 <Anpheus_> shachaf: I am writing a parser library on top of Attoparsec, example here: https://github.com/AaronFriel/Iota/blob/master/Data/Iota/Monad/Text.hs
18:55:48 <Anpheus_> Err, that's some library nuts and bolts
18:56:03 <Anpheus_> Link to example use of it here: https://github.com/AaronFriel/Iota/blob/master/Data/Iota/Monad/Tests/Text.hs
18:56:41 <mysticc> shachaf: If I was doing it even by hand then how would I do for 4 constructors ?
18:57:04 <maukd> mysticc: have you tried if "deriving (Ord)" does what you want?
18:57:25 <Anpheus_> shachaf: What I wanted was to create a library for incrementally parsing text on top of attoparsec for producing a bytestring stream from some input data. I wanted it to be incremental and allow embedding of one parser in another.
18:57:46 <shachaf> mysticc: Exercise for the reader. You only need to hand-write 8 cases, I think?
18:57:50 <shachaf> Oh, I'm wrong.
18:58:18 <Anpheus_> shachaf: Based on data states of the parser, much like the HTML5 tokenization states (http://www.whatwg.org/specs/web-apps/current-work/multipage/tokenization.html)
18:58:28 <shachaf> You need to define 10 cases by hand.
19:00:06 <Anpheus_> shachaf: In the example of my tests/text.hs, I have a parser that is parameterized by a data type containing all the possible parse states (CData, CForwardSlash, CBlockComment, CBlockCommentAsterisk, CLineComment)
19:00:38 <Anpheus_> shachaf: Parameterized by a monad (Identity) and a value (Int) that, for that particular combination of things, has a given parsing behavior: it counts the number of characters it has read.
19:00:40 <mysticc> maukd: Oh, It depends on the order I have given constructors I think ?
19:01:31 <mysticc> shachaf: 4c2 is 6. where 10 came from.
19:01:43 <mysticc> oops
19:01:45 <mysticc> :)
19:01:54 <mysticc> 12
19:02:11 <shachaf> mysticc: The naïve way would be 4^2
19:02:11 <Anpheus_> shachaf: So, in the case of my example in this file: https://github.com/AaronFriel/Iota/blob/master/Data/Iota/Monad/Tests/Text.hs - is it possible to have a *constant* Monad, that once initialized always returns the same value. i.e.: a Reader e () monad?
19:02:55 <maukd> mysticc: right
19:03:16 <mysticc> maukd: Thanks .. I just changed my constructor orders to what I wanted :)
19:05:06 <shachaf> Anpheus_: I'm not quite sure what you're asking or what you're doing.
19:06:06 <Anpheus_> shachaf: So... I have a parser whose behavior is parameterized by the set of states the parser can enter into. Such as a "data" state and a "in a comment" state, etc.
19:07:01 <Anpheus_> shachaf: And I have threaded through this parser a monad as another parameter. In the case of some monads, the values will be opaque - an IO monad threaded through it for example would not be able to be "peeked into".
19:08:01 <Anpheus_> shachaf: But other monads, like the Identity monad for example, can just be examined directly by pattern matching. I use that in an example. Others are more complex and you might need to do something with a monadic value to get something meaningful out of it.
19:08:36 <Anpheus_> shachaf: So... in my example code: https://github.com/AaronFriel/Iota/blob/master/Data/Iota/Monad/Tests/Text.hs I have this really dumb "C parser" that removes comments from an input stream
19:08:38 <Anpheus_> You give it "?
19:08:52 <Anpheus_> You give it "/*this is a comment*/" and it will emit as a bytestring ""
19:09:52 <Anpheus_> But it was extended with this monad to also count how many characters had been parsed.
19:10:21 <Anpheus_> And it can choose the next parse state, or what to do, based on that monadic value - in this case I insert a comment after the 10th character.
19:11:22 <Anpheus_> You could also use this parser library to do things like, implement the HTML5 tokenization spec
19:11:24 <Anpheus_> Which I did.
19:12:00 <Anpheus_> And you could then use the monadic version of it to say, write a stream of parse errors as an alternate data stream independent of the bytestring that is output
19:12:15 <Anpheus_> Because the HTML5 spec says you should do so
19:13:55 <Anpheus_> So does it make sense at all to have a "constant monad" whose value cannot change throughout a computation?
19:14:30 <Anpheus_> like, you do (>>= \_ -> return 5) and the value is still what it originally was? Like a Reader?
19:14:40 <shachaf> That's completely unlike Reader.
19:14:47 <Anpheus_> Well that's what I was curious about
19:15:26 <shachaf> There's "data Const a b = Const a"
19:15:46 <cmccann> oh boy, html5 spec
19:15:52 <cmccann> that's fun reading lemme tell ya
19:15:56 <shachaf> But it's not a monad, I think.
19:16:00 <aristid> no
19:16:03 <aristid> but Const () is
19:16:20 <cmccann> tricky to write return for "Const a"
19:16:30 <shachaf> cmccann: There's an instance Monoid m => Applicative (Const m)
19:16:34 <Anpheus_> cmccann: When you have a good parser library, the HTML5 spec is a snap to implement :P
19:16:36 <ddarius> return = Const . unsafeCoerce
19:16:47 <shachaf> But no monad instance -- so is there some other reason it's not a monad?
19:16:55 <cmccann> shachaf, adding a Monoid constraint changes things :P
19:17:07 <aristid> ddarius: might as well write return _ = Const undefined then, no? :)
19:17:13 <shachaf> cmccann: Sure.
19:17:24 <ddarius> aristid: That wouldn't be relevant.
19:17:32 <shachaf> aristid: That'll crash even for (Const a a)!
19:17:56 <Fuuzetsu> Cale: is there a page on Haskell Wiki you HAVEN'T contributed to?
19:18:00 <shachaf> Whereas unsafeCoerce will work there.
19:18:16 <aristid> shachaf: um let's just pretend the unsafe* functions don't exist.
19:18:29 <ddarius> Monoid m => Const m === WriterT m (Const ())
19:18:33 <shachaf> aristid: undefined is totally unsafe.
19:18:38 <cmccann> @quote unsafeCoerce
19:18:38 <lambdabot> Jafet says: unsafeCoerce takes any argument. AND IT WINS THAT ARGUMENT.
19:18:41 <cmccann> @quote unsafeCoerce
19:18:41 <lambdabot> int-e says: What, unsafeCoerce# is kind-preserving? how boring :/
19:18:45 <cmccann> @quote unsafeCoerce
19:18:45 <lambdabot> roconnor says: unsafeCoerce isn't even safe
19:18:51 <cmccann> @quote unsafeCoerce
19:18:51 <lambdabot> Japsu says: segfault cat is watching you unsafeCoerce
19:18:53 <MostAwesomeDude> Fuuzetsu: Cale has not contributed to http://www.haskell.org/haskellwiki/Meet_Bob_The_Monadic_Lover
19:18:56 <cmccann> bah
19:18:58 <cmccann> those are all boring
19:19:00 <shachaf> @quote unsafeCoerce
19:19:00 <lambdabot> benmachine says: unsafeCoerce is just a generalisation of id
19:19:02 <shachaf> @quote unsafeCoerce
19:19:02 <lambdabot> elliott says: <elliott> I like how edwardk's answer to every question always goes "most abstract solution to the problem possible --> microoptimisation details". <elliott> I swear I've seen him go
19:19:02 <lambdabot> from category theory to unboxed types and unsafeCoerce in a single line of IRC.
19:19:09 <shachaf> There are a lot of unsafeCoerce quotes.
19:19:14 <shachaf> @quote unsafeCoerce
19:19:14 <lambdabot> Japsu says: segfault cat is watching you unsafeCoerce
19:19:16 <shachaf> @quote unsafeCoerce#
19:19:16 <lambdabot> int-e says: What, unsafeCoerce# is kind-preserving? how boring :/
19:19:20 <shachaf> @quote unsafeCoerce#
19:19:20 <lambdabot> int-e says: What, unsafeCoerce# is kind-preserving? how boring :/
19:19:21 <shachaf> @quote unsafeCoerce
19:19:21 <lambdabot> int-e says: What, unsafeCoerce# is kind-preserving? how boring :/
19:19:23 <shachaf> @quote unsafeCoerce
19:19:23 <lambdabot> shachaf says: isTrue :: Bool -> Bool; isTrue = unsafeCoerce
19:19:28 <shachaf> OK, enough botspam.
19:19:30 <cmccann> heh
19:19:30 <shachaf> Wait, I can't stop now.
19:19:33 <shachaf> @quote unsafeCoerce
19:19:33 <lambdabot> ghc says: Dangerous-looking argument. Probable cause: bad unsafeCoerce#
19:19:33 <shachaf> @quote unsafeCoerce
19:19:34 <lambdabot> Japsu says: segfault cat is watching you unsafeCoerce
19:19:34 <shachaf> @quote unsafeCoerce
19:19:34 <lambdabot> monochrom says: isTrue = (unsafeCoerce :: Either a b -> Bool) . (unsafeCoerce :: Maybe c -> Either a b) . (unsafeCoerce :: Bool -> Maybe c)
19:19:36 <shachaf> There.
19:19:59 <aristid> does that actually work?
19:20:06 <ddarius> Why wouldn't it work?
19:20:09 <cmccann> using unsafeCoerce to check if something is not its first constructor is the best
19:20:39 <shachaf> Bool is so passé.
19:20:42 <shachaf> Everyone should use FastBool.
19:20:52 <aristid> oO
19:20:53 <cmccann> why is it fast?
19:21:03 <maukd> sizeof FastBool = 1/8
19:21:12 <cmccann> heh
19:21:17 <Fuuzetsu> MostAwesomeDude: that page...
19:21:24 <aristid> that'd make it slow
19:21:40 <shachaf> cmccann: type FastBool = Int#
19:22:06 <ddarius> aristid: Only if you sillily failed to exploit the massive bit-level parallelism.
19:22:16 <cmccann> shachaf, sounds like an important optimization
19:22:38 <shachaf> cmccann: (That's from GHC code.)
19:22:52 <cmccann> GHC has some interesting stuff in its code
19:22:59 <shachaf> They alsoThey have a whole bunch of FastTypes.
19:23:06 <aristid> oh, FastBool actually exists? thought this is a joke :D
19:23:18 <ddarius> type FastFastBool
19:23:38 <ddarius> ByteString started life as a GHC internal called FastPackedString.
19:23:43 <cmccann> someone should refactor it so that Fast is a type family
19:23:45 <shachaf> type FastAndLooseBool
19:23:45 <MostAwesomeDude> Fuuzetsu: Yeah, I know, right? :3
19:24:10 <shachaf> GHC also has FastString which is a completely different beast, if I remember correctly.
19:24:23 <cmccann> @quote faststring
19:24:23 <lambdabot> No quotes match. And you call yourself a Rocket Scientist!
19:24:27 <cmccann> @quote fastpackedstring
19:24:28 <lambdabot> No quotes match. Just what do you think you're doing Dave?
19:24:30 <cmccann> pf
19:24:36 <cmccann> I thought there was something about those
19:24:57 <ddarius> @quote cmccann.*thinking
19:24:57 <lambdabot> No quotes match. My brain just exploded
19:25:20 <shachaf> Ugh, FastString.
19:25:20 * cmccann clearly doesn't spend enough time thinking, then.
19:25:32 <shachaf> Do all these optimizations in GHC really make a difference?
19:26:08 <ddarius> shachaf: Make a patch that removes them all and find out.
19:26:44 <shachaf> ddarius: Would it be likely to be accepted?
19:26:54 <shachaf> Every time I read GHC code I get a strong urge to clean it up.
19:27:04 <aristid> shachaf: probably not?
19:27:09 <ddarius> It's possible if you show that it performs just as fast.
19:27:14 <Cale> Fuuzetsu: Why do you say that? Most of the stuff I have contributed to is just complete articles written by me
19:27:20 <ddarius> (And presumably that the code is cleaner.)
19:27:34 <ddarius> (and you pass the test suite)
19:27:43 <shachaf> ddarius: I hear FastString is one of the things that made parallelizing GHC tricky.
19:27:53 <shachaf> Everyone wants ghc -j, right?
19:28:04 <ddarius> If it's what I think it is, then it's pretty common in compilers.
19:28:19 <ddarius> But it probably is important unless you make changes in many other places.
19:29:00 <shachaf> Yes, it's probably good to have some version of it.
19:29:25 <shachaf> But having it not be a global variable, on the other hand...
19:29:35 * hackagebot fountain 0.0.4 - A fountain codec.  http://hackage.haskell.org/package/fountain-0.0.4 (RubenAstudillo)
19:29:37 <shachaf> http://www.aosabook.org/en/ghc.html , section "Crime Doesn't Pay"
19:29:45 <shachaf> «GHC uses a few data structures that rely on mutation internally. One is the FastString type, which uses a single global hash table; another is a global NameCache that ensures all external names are assigned a unique number. When we tried to parallelise GHC (that is, make GHC compile multiple modules in parallel on a multicore processor), these data structures based on mutation were the only sticking points. Had we not resorted to mutation in ...
19:29:51 <shachaf> ... these places, GHC would have been almost trivial to parallelise.»
19:30:09 <Fuuzetsu> Cale: I was just noting the other day that your name comes up everywhere and now I saw it yet again.
19:31:05 <cmccann> Cale is sort of a major fixture of the Haskell community. can't walk three feet without stumbling over him trying to explain Haskell to someone.
19:32:18 <Fuuzetsu> He's the hero we need, but not the hero we deserve...
19:37:11 <Cent> Hi all, is this the right room for people new to the language & FP?
19:37:27 <Fuuzetsu> Yes.
19:37:54 <Fuuzetsu> Remember that there's Google and Haskell wiki too though!
19:38:28 <Cent> Oh, absolutely. Just getting my environment set up and wanted to make sure I'm in the right place :)
19:43:09 <centrinia> Hello Cent.
19:43:20 <Cent> Hi!
19:44:01 <maukd> any relation?
19:44:14 <Cent> I highly doubt it
19:44:41 <Cent> Now if there was a nickel or dime ...
19:45:59 <riniA> is this a place for haskell experts?
19:46:03 <riniA> i know haskell so well that i'll basically do nothing but mock other people for not knowing it as well as i do
19:46:42 <Cent> That sounds ... unkind.
19:47:09 <riniA> it's just a constraint kind
19:47:46 <shachaf> Wow, that riniA person sure was rude.
19:49:07 <Fuuzetsu>  riniA [~shachaf@ [...]
19:49:15 <Fuuzetsu> y-yeah.
19:49:27 <Fuuzetsu> do
19:49:39 <shachaf> Fuuzetsu: There are lots of shachafs in the world.
19:49:49 <Fuuzetsu> hostmask ban is the least we can do then
20:00:37 <ddarius> The was(?) a channel for people who wanted to have long conversations about details of Haskell.
20:01:32 <djahandarie> Maybe #haskell-in-depth
20:01:43 <djahandarie> Yeah I think that's the one.
20:04:32 <zzo38> How to make call/cc yin yang with Haskell?
20:13:41 <carter> djahandarie: seems it was last modded by phillipa in 2009
20:15:50 <zzo38> Do you know the call/cc yin yang, and if it can be made by Haskell? I think I may have managed to make the function to read the current continuation from outside of callCC, but I am not sure. The call/cc yin yang is implemented in Scheme, and in Unlambda, but is it implemented in Haskell?
20:16:37 <carter> zzo38 could you post the code to hpaste.org then ? :)
20:17:22 <zzo38> Actually nevermind I just got it to work now.
20:18:07 <zzo38> join $ liftA2 runCT (getCC <* lift (putChar '\n')) (getCC <* lift (putChar '*'))
20:18:36 <zzo38> newtype CT r m x = CT { runCT :: CT r m x -> ContT r m x }; getCC = callCC (return . CT);
20:18:37 <carter> zzo38:  that seems specific to string io
20:18:40 <zzo38> This works.
20:19:04 <carter> works for what pray tell? :)
20:19:17 * shachaf likes getCC = callCC (return . fix)
20:19:54 <zzo38> carter: How do you mean, works for what pray tell? It works!
20:20:08 <carter> works as ___
20:20:18 <carter> callCC?
20:20:30 <carter> (i just tend to be leery of people using pronouns)
20:20:32 <zzo38> It works to do the same as the other call/cc yin yang.
20:20:49 <carter> yin yang?
20:21:13 <carter> metaphorical yin yang I assume?
20:21:33 <zzo38> If you want, try this code: The expression above with "join $" at first is the code, and to run it as the I/O, you can put runContT at first and (const $ return ()) at end.
20:21:43 <shachaf> zzo38: Hmm, CT is a weird type.
20:21:46 <shachaf> It's like Rec.
20:21:55 <zzo38> If you don't know what it is, try to figure out before trying to run it, if you want to.
20:22:16 <carter> zzo38: i understand continuations :)
20:22:21 <carter> i'm just asking you to explain
20:22:26 <carter> rather than point at things :)
20:22:35 <carter> it works as ___
20:22:54 <carter> with ___ replaced with a noun
20:22:59 <carter> is easier to interpret
20:23:01 <carter> than "it works"
20:23:07 <zzo38> If you understand, then why do you need to ask? It works as yin yang call/cc codes works.
20:23:24 <carter> i dont understand the remark about yin yang :)
20:23:36 <shachaf> carter: There exists a puzzle called "yin yang" in Scheme that uses call/cc.
20:23:39 <zzo38> (The Wikipedia article about call/cc describes the yin yang call/cc codes, in case you don't know; but I am telling you, this is what the yin yang codes is.)
20:23:41 <carter> shachaf: ahhh
20:23:43 <shachaf> You can find it if you look up "yin yang callcc"
20:23:46 <carter> ok
20:23:50 <shachaf> I found it that way a few minutes ago. :-)
20:23:54 <carter> ok
20:23:57 <carter> that would have been helpufl
20:24:05 <carter> that must be a new thing
20:24:28 <carter> is that as of the past 2-3 years?
20:24:59 <carter> all my call/cc , call/dc, continuation typing, delimited continuation stuff is only up to date till around 3 years ago :)
20:24:59 <zzo38> I think it was implemented in Unlambda before that.
20:25:15 <shachaf>     Couldn't match kind `* -> *' with `*'
20:25:16 <shachaf>     Expected type: IO -> (IO -> b0) -> b0
20:25:16 <shachaf>       Actual type: IO -> IO -> b0
20:25:24 * shachaf likes that error.
20:25:34 <shachaf> (There wasn't a single type specified in the code that led to it.)
20:26:31 <zzo38> This error message does not seem to make much sense to me.
20:27:04 <carter> zzingjoin $ liftA2 runCT (getCC <* lift (putChar '\n')) (getCC <* lift (putChar '*'))
20:27:15 <carter> i think that code is where the io ness happens
20:27:53 <Ralith> shachaf: that is a very hard to read error.
20:27:57 <carter> but thats also a werid type
20:28:10 <shachaf> zzo38: Isn't it great?
20:28:11 <carter> Ralith shachaf : IO has kind *->*
20:28:16 <carter> so isn't that type a bit off?
20:28:28 <shachaf> carter: Yes, it's a kind error.
20:28:33 <Ralith> carter: indeed.
20:28:43 <Ralith> I'm confused by why there's an expected and actual type for that, though.
20:28:53 <Ralith> especially as both of them seem to have inappropriate uses of IO.
20:29:00 <zzo38> carter: What is "zzingjoin ...."?
20:29:05 <carter> missing space
20:29:06 <carter> join
20:29:12 <carter> drop the handle prefix
20:29:16 <carter> :p
20:29:38 <carter> Ralith: shachaf : so maybe the type error machinery hasn't been augmented for type level applications?
20:29:52 <carter> perhaps we should file a ticket as a feature request :)
20:31:40 <shachaf> carter: I wrote wrong code (that made no mention of types) and got that error.
20:31:43 <shachaf> Doesn't look like a bug to me.
20:32:09 <carter> shachaf do you have a type IO?
20:32:10 <zzo38> carter: Why did you just repeat my code, though? Is it supposed to be a question or whatever?
20:32:31 <carter> zzo38 I thought from the context that it was the code shachaf had the type error with
20:32:34 <shachaf> carter: I don't. That's a kind error.
20:32:47 <zzo38> At least to me this code is not error.
20:32:54 <zzo38> It works on my computer.
20:32:57 <carter> zzo38: ignore me
20:33:09 <shachaf> carter: I found it amusing that code that didn't mention types at all could have a kind error like that, that's all.
20:33:13 <carter> shachaf: could you hpaste the code that gives the error?
20:33:16 <zzo38> Does it work on your computer?
20:33:17 <carter> shachaf: thats a bug
20:33:35 <carter> shachaf: you should not be able to get a kind error from infered types
20:33:51 <shachaf> carter: I don't have the code anymore. It was some variation on zzo38's yin yang thing.
20:33:56 <carter> ahh
20:33:57 <carter> ok
20:33:59 <shachaf> I've gotten kind errors from inferred types before.
20:34:03 <shachaf> I can try to get it again...
20:34:14 <carter> shachaf: please ! :)
20:34:22 <zenware> Has anyone experimented with cluster computing using haskell?
20:34:32 <carter> zenware: theres some folks who have
20:34:49 <cmccann> for what it's worth, I think I've gotten kind errors from inferred types before as well
20:35:05 <carter> cmccann: that does seem like a bug!
20:35:19 <shachaf> λ> ap (getcc <* (lift (putStr "\n"))) (getcc <* lift (putStr "*"))
20:35:30 <shachaf> Where getcc = callCC (return . fix)
20:35:34 <cmccann> whenever it happened it seemed to make sense though
20:35:38 <shachaf> That's obviously wrong, but the error is funny.
20:35:39 <cmccann> so I don't see why it's a bug
20:37:22 <carter> its a bug if the error messages are pointing at something thats not the right error :)
20:37:28 <zzo38> On my computer I get the proper error.
20:38:18 <carter> or at least its worth asking if its the intended behavior of the type error reporting machinery is the case
20:38:28 <carter> what Ghc versions? shachaf  and zzo38 ?
20:38:45 <shachaf> carter: 7.6
20:38:52 <cmccann> the errors I saw involved trying to unify types with incompatible kinds
20:39:01 <carter> cmccann: that makes sense
20:39:22 <cmccann> yeah
20:39:22 <shachaf> I get a kind error with 7.4 too, though a different one.
20:39:28 <shachaf> Anyway this doesn't seem like a bug to me.
20:39:36 <carter> shachaf: could you hpaste the code needed to reproduce it though?
20:39:44 <carter> i'll then have a see
20:39:45 <shachaf> carter: Just the two lines I pasted.
20:39:52 <zzo38> I have an older version 7.0.3 because it seems difficult to upgrade it
20:39:58 <cmccann> if it infers types that should unify but can't because of a kind mismatch that seems entirely reasonable to me
20:40:19 <cmccann> which I assume is what shachaf's code is doing
20:40:27 <carter> shachaf: theres some imports too!
20:40:32 <shachaf> ==cmccann
20:40:37 <shachaf> carter: Those come from my .ghci
20:40:41 <carter> ohhh
20:40:42 <carter> ok
20:40:45 <carter> fineee
20:40:45 <shachaf> It's Control.Monad.Cont or Control.Monad.Trans.Cont or something.
20:41:35 <shachaf> I'm sure you can make a simple test case.
20:41:38 <cmccann> unlike delimited continuations, which are defined in Control.Monad.Oleg
20:41:50 <shachaf> Oh, in GHC 7.0 it's just a boring type error.
20:42:01 <shachaf> But who uses 7.0? More like GHC 7.dinosaur.
20:42:13 * ddarius misses GHC's happy dinosaur.
20:42:29 <cmccann> "seven point oh? more like seven point OLD."
20:42:44 <shachaf> 7.0ld.so
20:44:18 <ddarius> http://web.archive.org/web/20020610203435/http://haskell.cs.yale.edu/ghc/
20:46:06 * jmcarthur remembers reading this! http://web.archive.org/web/20020802015017/http://www.haskell.org/aboutHaskell.html
20:47:36 * carter was just starting high school around then!
20:47:49 <carter> 2002
20:48:10 <carter> I think i was reading the LTU papers and SICP that summer or 2003
20:48:16 <carter> prolly 2003
20:49:28 * cmccann was graduating college around then, and had never heard of functional programming at all. :[
20:49:48 * shachaf hadn't heard of Haskell around then.
20:49:58 <shachaf> I think I had learned English around then.
20:50:02 <shachaf> Well, maybe a bit earlier.
20:53:46 <cmccann> was it always possible to use atomically inside of unsafePerformIO? I thought it immediately complained if you tried, but maybe I'm misremembering...
20:53:58 <Nafai> cmccann: same here, graduated uni Dec 2003
20:54:31 <acyed> hello everyone
20:54:32 <shachaf> cmccann: That's what I remember too
20:55:02 <cmccann> because it doesn't seem to when I try it now
20:55:37 <cmccann> only giving an error if atomically was used inside itself
20:56:06 <shachaf> Oh, maybe I'm thinking of atomically-inside-itself too?
20:56:20 <cmccann> yeah, I'm not sure
20:56:25 <cmccann> obviously that's what matters
20:56:37 <shachaf> cmccann: I remember that this was the motivation for primitives like newTVarIO
20:56:45 <acyed> I'm reading through "learn you a haskell for greater good" and I can't seem to understand how you define what is returned from a function. Is there a simple explanation for this?
20:56:52 <shachaf> I don't imagine that those are ever called inside atomically, though.
20:56:55 <cmccann> but I think I remember it failing more aggressively last time I tested something
20:56:56 <shachaf> So I must be missing something.
20:57:45 <cmccann> acyed, the body of a function is just an expression. the return value is the value of that expression.
20:58:26 * cmccann is now imagining "learn you a haskell for the greater good"
20:58:49 <acyed> ok. That makes sense.
20:59:13 <cmccann> it's really very simple :]
20:59:14 <acyed> thanks.. coming from c/c++/objective-c is.. a challenge
20:59:25 <cmccann> yeah, I can imagine
20:59:25 <acyed> but you're right, that is simple
20:59:35 * cmccann came from scheme and python, which kinda helped
21:02:02 <shachaf> The = thing is really quite simple.
21:02:18 <shachaf> It's just substitution.
21:02:26 <zzo38> shachaf: What is that you need fix to implement, did you mean?
21:02:44 <shachaf> zzo38: ?
21:04:54 <zzo38> Never mind
21:06:15 * Digit still wishes he could just learn all haskell in a download, and be done in mere seconds
21:06:40 <carter> Digit: but even the good people seem to eternally level up!
21:07:26 * shachaf levels down.
21:08:12 * ddarius levels driveways.
21:08:19 * Digit levels out
21:09:51 * jmcarthur levels bullies
21:10:24 * otters levels rotators racecars
21:13:22 <thirsteh> is there an easy way to get a mirror of all the latest docs from hackage? Something easier than wget --mirror?
21:28:07 <Polarina> thirsteh, one way would be to download the libraries and gerenate the haddock documentations yourself.
21:28:19 <Polarina> s/libraries/packages/
21:46:42 <ew0> hello
21:46:51 <Polarina> ew0, Hi.
21:47:02 <ew0> is it possible to do a dump of some stuff to a file
21:47:18 <ew0> the same way the trace function works?
21:47:25 <ew0> from Debug.Trace
21:47:48 <shachaf> Yes, you can implement that for debugging.
21:48:44 <ew0> I'm not very good with these monads stuff
21:48:46 <ew0> xD
21:48:57 <ew0> can I call a printStrLn inside a trace?
21:49:00 <shachaf> You don't need to "understand monads" to understand IO.
21:49:17 <shachaf> But you should probably understand IO before you use Debug.Trace.
21:49:19 <Polarina> ew0, what's the type of trace?
21:49:27 <ew0> :type trace
21:49:34 <ew0> oops
21:50:01 <ew0> String -> a -> a
21:51:44 <Polarina> ew0, a can be any type, so you can do something like { trace "str" (print 42) }
21:52:00 <Polarina> ew0, I don't know if that'll be useful or not.
21:52:28 <shachaf> Polarina: I think that's among the less useful contexts for Debug.Trace. :-)
21:52:36 <ew0> yeah, but I wanted to do something like { trace (putStrLn "a") x }
21:53:16 <ew0> I'm already doing { trace ("x: " ++ x) x }
21:53:29 <shachaf> ew0: Look at the implementation of Debug.Trace to see how it works.
21:53:34 <shachaf> But you should probably understand IO first. :-)
21:53:42 <ew0> I more or less do
21:53:47 <rwbarton> you could also use, um
21:53:50 <Polarina>  ew0: http://hackage.haskell.org/packages/archive/base/4.5.1.0/doc/html/src/Debug-Trace.html#trace
21:53:52 <rwbarton> > text "x: foo"
21:53:53 <lambdabot>   x: foo
21:53:54 <ew0> I've done a function to print a list of stuff yesterday
21:53:57 <rwbarton> whatever this is
21:54:07 <rwbarton> or make your own Show instance
21:54:19 <shachaf> rwbarton: ?
21:54:31 <shachaf> What does text have to do with Debug.Trace?
21:54:35 <rwbarton> trace uses print right?
21:54:56 <ew0> unsafePerformIO $ do
21:54:58 <ew0> ow yeah!
21:55:01 <shachaf> You mean Show? No.
21:55:02 <ew0> that's what I wanted
21:55:03 <shachaf> traceShow uses Show.
21:55:07 <rwbarton> oh
21:55:08 <ew0> thanks, ppl
21:55:12 <shachaf> 21:49 <ew0> String -> a -> a
21:55:23 <shachaf> I guess that text thing would work otherwise. But it's a hack.
21:55:25 <rwbarton> 'trace (putStrLn "a") x' -- isn't this just trace "a" x
21:55:37 <ew0> I want to write to a file
21:55:38 <rwbarton> if it made sense
21:55:38 <ew0> some data
21:55:42 <rwbarton> augh
21:55:47 <rwbarton> say so :P
21:55:57 <ew0> so it would be ' trace (writeFile file stuff) x
21:56:09 <shachaf> ew0: No, it would be unsafePerformIO.
21:56:14 <ew0> yeah
21:56:18 <rwbarton> you could redirect stderr
21:56:20 <shachaf> But you probably shouldn't be doing this.
21:56:29 <shachaf> Given that 21:48 <ew0> I'm not very good with these monads stuff
21:56:33 <ew0> It is just for debug
21:56:56 <ew0> I'll have unique files
21:57:07 <ew0> for each record
21:57:46 <ew0> I'm doing fine with my test graphs
21:57:57 <ew0> but when I go to a real one, my program is generating garbage
21:58:19 <ew0> I want to find what it breaking and write a proper test
21:58:27 <ew0> based on the problem graph
21:59:38 <ew0> is there a way to marshall arbitrary data?
22:00:05 <Polarina> Marshall?
22:00:23 <ew0> uhm, something like python's pickel
22:00:31 <ew0> pickle
22:00:31 <cmccann> show?
22:00:46 <Polarina> ew0, there's cereal and binary.
22:00:49 <ew0> to output the record and read it back
22:00:53 <Polarina> Both are good libraries.
22:00:58 <ew0> ok
22:01:04 <cmccann> show/read basically serialize to and from strings
22:01:08 <cmccann> if you use the default instances
22:01:13 <cmccann> or any sensible instances
22:01:33 <cmccann> otherwise, yeah, the libraries Polarina mentions
22:02:50 <ew0> I broke show becase it was messing with the graphviz
22:02:57 <ew0> so its a no no
22:03:04 <ew0> I'll try one of those
22:17:49 <Skillson> Hi, Haskellers
22:17:53 <Guest80118> I am trying to follow the All About Monads tutorial (http://www.haskell.org/haskellwiki/All_About_Monads). In Section 6.1.2 a function mcons is defined as: mcons p q = p >>= \x -> q >>= \y -> return (x:y)
22:18:33 <Guest80118> So I try evaluating mcons [3, 4, 5] (return []) by hand
22:19:02 <ion> Eww, a monad tutorial that first mentions functors in… section 21.3
22:19:24 <Guest80118> And I end up with [[x], [x], [x]] . Here "x" is the variable bound in the first lambda expression in the definition of mcons
22:20:01 <Guest80118> Now, when I execute this expression on ghci, I get [[3], [4], [5]] as the answer
22:20:49 <Guest80118> What is the behaviour which binds the x to each of the three elements of [3,4,5], in turn?
22:21:37 <Skillson> Am I able to add type/typeclass constraints to data types I make myself? I'm making a self balancing binary tree for practice, and I only want Ord types to be in my tree, so how I tell Haskell data (Ord a) => MyTree a?
22:22:26 <Guest80118>  The definition of >>= for the List monad, as l >>= f == concatMap f l  does not seem to explain this "nondeterministic" behaviour.
22:22:52 <Polarina> Skillson, you can't do that. Restrict the possible types in your functions that work with your tree. Like :: (Ord a) => MyTree a b -> a -> Maybe b
22:23:55 <Skillson> Thanks. I've just been googling a bit, and I think I can see why that's the case.
22:24:14 <ion> mcons [3,4,5] [[]] = [3,4,5] >>= \x -> [[]] >>= \y -> [(x:y)] = [3,4,5] >>= \x -> concatMap (\y -> [(x:y)]) [] = concatMap (\x -> concatMap (\y -> [(x:y)]) [[]]) [3,4,5]
22:24:23 <ion> > concatMap (\x -> concatMap (\y -> [(x:y)]) [[]]) [3,4,5]
22:24:24 <lambdabot>   [[3],[4],[5]]
22:24:27 <ion> @src concatMap
22:24:27 <lambdabot> concatMap f = foldr ((++) . f) []
22:24:39 <ddarius> Guest80118: Considering this is all normal code, there is no magic, and that's the definition, I would say it completely explains it.
22:24:47 <Guest80118> ion: thank you, let me try groking that
22:25:02 <Guest80118> ddarius: thanks, it helps to know that this is "normal" ;-)
22:25:48 <Skillson> So now I'm trying to make my tree a monad, and I'm using a function called combineTrees for my mappend, and now it's complaining that combineTrees takes an (Ord a) MyTree a. Is there a way to tell Haskell "This is a monoid iff it has an orderable a", or am I still thinking about this the wrong way?
22:25:57 <Skillson> make my tree a monoid***
22:26:25 <Cale> Guest80118: you can think of xs >>= f as picking an element from xs in all possible ways, then applying f to the element it picked, and collecting all the results from each application of f
22:26:38 <cmccann> Skillson, "instance (Ord a) => Monoid (Tree a) where ..." ?
22:27:09 <Cale> Guest80118: or, if you prefer, picking an element v from xs in all possible ways, then picking an element w from f v in all possible ways, and producing the list of w's
22:27:12 <Skillson> Thanks a bunch!
22:27:35 <Guest80118> I think the part I missed is that >>= is right associative
22:27:40 <Guest80118> Cale: thank you!
22:28:54 <Cale> Guest80118: So what mcons hs ts = hs >>= \h -> ts >>= \t -> return (h:t) does, is to pick a list head from hs, and a list tail from ts, and stick them together into a single list, in all possible ways
22:29:19 <Cale> Guest80118: Does that make sense?
22:29:44 <Cale> Guest80118: you might prefer it in do-notation:  mcons hs ts = do h <- hs; t <- ts; return (h:t)
22:30:10 <Cale> Guest80118: which incidentally, ought to remind you of the list comprehension: [(h:t) | h <- hs, t <- ts]
22:31:37 <hpaste> mmcdermo pasted “RepeatT” at http://hpaste.org/75163
22:31:48 <Cale> I don't think that writing it out in terms of concat and map is particularly helpful. You can try it if you want, but it's easier if you just understand what >>= does in terms of picking elements in all possible ways, and then understand the larger program in terms of that.
22:31:51 <mmcdermo> Hmm It seems like there must be a more idiomatic way of doing this? So that all computations are automatically repeatable?
22:32:22 <mmcdermo> http://hpaste.org/75163
22:32:41 <Cale> mmcdermo: it wouldn't satisfy associativity
22:34:04 <mmcdermo> Cale: So is this the best way of doing this - not having it automatic, but using something like "repeatable" ?
22:34:21 <Cale> actually, it's kind of surprising that the trick there works -- I guess all your computations have the same result type here, so you're not running into any problems
22:34:50 <Guest80118> Cale: I am trying to slowly understand the expansion which ion posted. I think it will make sense after I understand that one. Thanks!
22:35:17 <mmcdermo> Yes I thought about that too! I was thinking I'd have to use some sort of heterogeneous list if they had a different type.
22:39:18 <mmcdermo> Thanks for the heads up about associativity. Going to look into this more.
22:44:39 <shachaf> @brain
22:44:39 <lambdabot> I think so, Brain, but me and Pippi Longstocking -- I mean, what would the children look like?
22:44:54 <Rotaerk> lol
22:45:12 <Rotaerk> a freckle-faced, red-haired girl you wanna know
22:45:20 <shachaf> @quote
22:45:20 <lambdabot> preaux says: in my family when someone was sick, we would get together and cook, talk about the good time we have with the person, and hope for their recovery, its kinda like a cajun prayer meeting
22:45:20 <lambdabot> with seafood and beer
22:45:31 <shachaf> @brain
22:45:31 <lambdabot> What can I do for fun, Pinky? That's it! I'll send several
22:45:31 <lambdabot> bills to Senate for ratification, then veto them all!
22:45:39 <Guest80118> Cale: I am pretty sure what you say is true, but before I can forget the detail and assume that behaviour of >>= in List, I need to convince myself that there is no "magic" involved, that this is all just the consequence of how things are defined.
22:46:32 <ion> Don’t listen to #haskell, they’re lying to you.
22:46:44 <Guest80118> right associativity of >>= was what I missed. Using the expansion which ion gave, I have understood this now as follows.
22:46:47 <Guest80118> mcons [3,4,5] [[]] = [3,4,5] >>= \x -> (return []) >>= \y -> (return (x:y)) = [3,4,5] >>= \x -> [[]] >>= \y -> [(x:y)] = [3,4,5] >>= \x -> concatMap (\y -> [(x:y)]) [[]] = [3,4,5] >>= \x -> [[x]] = [[3], [4], [5]]
22:47:26 <Guest80118> ion: i am not that paranoid .. yet :-)
22:47:39 <Cale> The associativity of >>= is not used in that definition
22:48:02 <ion> No matter the associativity of (^-^), “something ^-^ \x -> whatever ^-^ \y -> blah” would parse as “something ^-^ (\x -> whatever ^-^ (\y -> blah))”
22:48:04 <Cale> What is used is that lambdas enclose the expression as far to the right as possible
22:48:26 * ddarius agrees with ion.
22:48:32 <Guest80118> hmm.. but when i tried evaluating the first >= first, i ended up with [[x], [x], [x]] which required "magic" to turn into [[3],[4],[5]]
22:48:51 <ion> You’re free to evaluate the first >>= first.
22:48:56 <Guest80118> Cale, ion: ok, let me try to grok that :)
22:49:05 <ddarius> Guest80118: Which sounds like you did it wrong, most probably by not suitably alpha renaming.
22:49:12 <Cale> Evaluating the second >>= first is trickier
22:49:21 <ion> [3,4,5] >>= \x -> [[]] >>= \y -> [(x:y)]
22:49:28 <ion> concatMap (\x -> [[]] >>= \y -> [(x:y)]) [3,4,5]
22:49:48 <ion> concatMap (\x -> concatMap (\y -> [(x:y)]) [[]]) [3,4,5]
22:50:00 <ion> I evaluated the first >>= first.
22:50:06 <Cale> funny to evaluate under a lambda like that
22:50:23 <ddarius> People try to trick people into thinking the lambda calculus is simpler than it is by saying "There's only one rule, beta reduction: (\x -> E[x]) y ~> E[y/x]".  What they often fail to say is that [y/x] hides a lot of complexity.
22:50:24 <Cale> (though it is valid, it's something that essentially no implementation will do)
22:50:26 <Guest80118> "lambdas enclose the expression as far to the right as possible" is good to remember, thanks
22:50:29 <shachaf> Cale: GHC does quite a lot of that while compiling, doesn't it?
22:50:38 <ion> cale: Granted.
22:50:39 <shachaf> In the form of optimizations, I mean.
22:50:57 <Cale> shachaf: Well, while compiling, but it doesn't produce code which does that at runtime :)
22:50:58 <ion> But you can evaluate things in any order and it will work.
22:51:13 <Guest80118> ddarius: I did it wrong, as I see from what ion posted
22:51:47 <Guest80118> because i didn't realize then that "lambdas enclose etc."
22:51:53 <shachaf> ddarius: Less complexity if you use De Bruijn indices.
22:54:34 <dolio> If you're just using de Bruijn indices, it's still complex.
22:55:38 <latermuse> hi
22:56:30 <latermuse> if Im running a compiled haskell program in the cgi-bin of a website, what is the best way to retrieve data that has been sent to it via POST?
22:57:37 <ion> (Side note: plain HTTP > CGI)
22:59:16 <latermuse> can compiled haskell run in plain http? do you mean by listening on a certain port?
23:00:10 <ion> You can have your web app listening for HTTP connections on a port and have your main HTTP server proxy certain requests to that.
23:00:50 <latermuse> thanks! thats way better than the cgi idea I was working on.
23:01:17 <latermuse> (im new to this channel, what is the correct command to give you some karma points?)
23:01:27 <latermuse> ion++
23:01:34 <shachaf> latermuse: That works.
23:01:44 <ion> WAI <http://www.yesodweb.com/book/web-application-interface> provides a nice abstraction for the Haskell web servers.
23:01:50 <latermuse> great ;) thanks
23:02:13 <ion> Then there are frameworks built on top of that.
23:02:16 <Cale> ion: Is it used by anything other than Yesod?
23:03:38 <ion> I should hope they’re all at least moving toward a common equivalent to WSGI/Rack.
23:06:39 <Guest80118> Cale: what you said about mcons hs ts sometime back now makes sense, thank you! I think what I understood from you will also help me read similar stuff faster now. Thanks
23:06:55 <astry> hi!
23:06:56 <Cale> ion: I'm still not convinced that's a good plan, but I don't know anything about WSGI/Rack
23:07:09 <ion> Btw, mcons = liftM2 (:)
23:07:19 <astry> Cale: wsgi is a fairly simple cgi style interface
23:07:29 <astry> Cale: it's just a minimal API
23:07:37 <astry> although python is moving away from wsgi
23:07:42 <astry> i don't know towards what
23:07:45 <astry> i forgot
23:07:53 <ion> They are? Interesting.
23:08:10 <astry> yeah apparently it was a bad idea
23:08:18 <ion> Huh
23:08:26 <ion> For what reasons?
23:08:39 <astry> i forgot
23:08:54 <astry> it was just a note i read somewhere in passing
23:09:20 <Cale> It seems like standardising the interface of web servers is mostly just going to ensure either that 1) There's only one viable way to implement a web server, or 2) Every implementation is equally bad.
23:09:23 <latermuse> ion: I just read that yesodweb.com example you gave me, and it is exactly what I was looking to do. Thanks again!
23:10:14 <Cale> Apart from the manner in which web servers are already standarised on account of being web servers.
23:10:16 <astry> http://www.python.org/dev/peps/pep-0444/
23:11:18 <Cale> I'm just wary of the "type classes with only one instance" problem.
23:12:08 <cmccann> hm, TH doesn't seem to like (GHC.TypeLits.+) in a splice
23:12:33 <astry> Cale: i think wsgi is basically that, the api you get by the virtue of your server being a http server
23:12:49 <astry> with little else conjectured
23:12:50 <Cale> Any interface which is going to be shared between many web servers had better be really simple. I would propose that it be something like ByteString -> IO ByteString, and fuck formalising that into a library. :)
23:13:38 <cmccann> what, not (MonadIO m) => ByteString -> m ByteString?
23:13:39 <astry> Cale: in that case it's still a pain to look up headers, separate the body, body attachments, return status codes, etc
23:13:44 <cmccann> and is that a lazy or strict ByteString?
23:13:50 <cmccann> these are important details, Cale!
23:14:18 <Cale> cmccann: I already thought about the latter of those. The reason to use IO is that it's the universal MonadIO instance.
23:14:48 <astry> Cale: as opposed to multiversal?
23:14:57 <Cale> cmccann: If you have something of type  forall m a. MonadIO m => m a, then you really have something of type IO a.
23:15:06 <ion> cale: They’re a very thin interface upon HTTP itself, abstracting only the difference between a HTTP socket/FastCGI/a unit testing interface etc. In addition you can plug in so-called middleware to transparently handle things like gzipping, caching, workarounds for HTTP forms not supporting PUT/DELETE etc. with common code for all frameworks/apps.
23:15:12 <cmccann> psh, that's a minor detail
23:15:24 <astry> ion: have you seen my link? that's what they are replacing wsgi with
23:15:42 * cmccann proposes a generic interface with type "IO () -> IO ()". you give it something to run, and it runs that.
23:16:17 <ion> astry: Yes. It seems like just a slight update to WSGI without changing anything fundamental.
23:16:46 <Cale> astry: But if not parsing headers etc, what the heck does a web server backend actually have to do?
23:17:57 <astry> ion: right
23:18:11 <astry> Cale: read the wsgi spec
23:18:28 <astry> i can't really explain this other than that wsgi is a convenience lib
23:18:30 <Cale> There are presumably lots of good functions from ByteString to parsed structures which could be implemented by different people and don't need to be standardised.
23:19:14 <ew0> I'm finally understanding IO quite well
23:19:17 <ew0> =D
23:19:29 <astry> one thing that wsgi enabled was for people to experiment a lot with web servers
23:19:37 <astry> because you could take any app and any web server and they'd work together
23:19:46 <astry> so you could really check out different approaches and how that helps you
23:19:51 <ion> ew0: Yes. An IO value is a wrapper for a Perl script the runtime system executes via the Perl interpreter.
23:20:08 <Cale> astry: But, an interface of ByteString -> IO ByteString would also enable that.
23:20:17 <ew0> O_O'
23:20:18 <ew0> really?
23:20:23 <ion> ew0: Just joking, sorry.
23:20:38 <ew0> lol
23:20:47 <cmccann> don't even joke about that. at least the evil mangler was finally laid to rest...
23:20:53 <astry> Cale: not really, because every web server will end up having its own headers implementation and stuff like that
23:21:01 <astry> Cale: and then your web app depends on that
23:21:19 <ew0> this monads stuff is still confusing
23:21:24 <astry> Cale: and then, because both things on each side of your BS -> IO BS api are in one framework, they will mess up that interface
23:21:41 <astry> and you won't be able to use your web server's header parser with another web server's http server
23:22:00 <ew0> but I understood what return is
23:22:09 <ion> cale: It could very well be ByteString -> IO ByteString, that could still easily provide the same abstraction between e.g. a HTTP socket vs. FastCGI et al. and it could still provide the same support for middleware etc. (except that now everything would need to parse and encode HTTP headers only to have the next module in the chain reparse it again).
23:22:12 <ew0> and how it is fundamentaly different from return from other languages
23:22:21 <astry> @type return
23:22:22 <lambdabot> forall a (m :: * -> *). (Monad m) => a -> m a
23:22:24 <Cale> ew0: okay
23:22:48 <Cale> So http://www.haskell.org/haskellwiki/Introduction_to_IO should be familiar
23:23:12 <Cale> http://www.haskell.org/haskellwiki/Monads_as_computation will explain what monads are and why we care about them
23:23:12 <ew0> yes
23:23:16 <ew0> uhm
23:23:19 <ew0> thanks
23:23:46 <Cale> ew0: If you have any questions about that, just let me know :)
23:24:37 <Cale> ew0: Ultimately, the point of monads is to take all the various things which support operations of the same shape as return and (>>=), and abstract over them
23:24:41 <astry> ew0: what is return?
23:25:46 <ew0> return is a function to put any value as a operation in the monad
23:26:13 <astry> what is an operation in the List monad?
23:26:20 <ew0> an item
23:26:25 <ew0> in the list?
23:26:28 <Cale> a list!
23:26:39 <astry> why not say "monadic value" instead?
23:26:40 <ew0> ah, a sublist
23:26:49 <astry> there's no "sublist" value
23:26:53 <astry> there's only "list"
23:27:00 <astry> a "sublist" is a list
23:27:05 <Cale> In the list monad, we have return :: a -> [a]
23:27:10 <Cale> and  return v = [v]
23:27:28 <ew0> I see, you can use it to build lists
23:27:48 <Cale> and we have  (>>=) :: [a] -> (a -> [b]) -> [b]
23:28:02 <Cale> now, based on the type, can you guess what that might do?
23:28:10 <ion> cale: So the next obvious step would be parsing the incoming HTTP headers and generating the outgoing HTTP headers once at the border and having Request -> IO Response. Just make Request and Response completely isomorphic to HTTP requests/responses and it will just let everyone share the implementation of the HTTP parsing/generating and let everyone pass Request and Response values around instead of
23:28:11 <Cale> It takes a list of values of type a
23:28:12 <ion> everything encoding their ad hoc equivalents to ByteStrings only to have the next thing parse it back to its ad hoc data type.
23:28:24 <Cale> and a function taking values of type a and producing lists of values of type b
23:28:33 <Cale> and it needs to produce a list of values of type b
23:29:16 <ew0> its confusing, shouldn't it be [a] -> (a -> [b]) -> [[b]]
23:29:17 <ew0> ?
23:29:24 <Cale> ew0: nope
23:29:31 <ew0> uhm
23:29:39 <Cale> but if you can imagine a function which gets you to [[b]], how can you get to [b]?
23:29:47 <ew0> concat
23:29:50 <Cale> right
23:29:59 <Cale> so what should  xs >>= f  be?
23:30:34 <ew0> concat (map f xs)
23:30:36 <astry> no ew0
23:30:38 <Cale> exactly
23:30:43 <ew0> xD
23:30:43 <Cale> no?
23:30:51 <Cale> That is the definition
23:31:08 <astry> for example what it can do is to create a list [b] for each element in [a] and then concatenate those lists together
23:31:19 <astry> sorry i was saying "no" to an earlier question
23:31:25 <Cale> oh
23:31:29 <astry> where he asked if it should be [[b]]
23:31:35 <Cale> well, he just wrote the definition in terms of concat and map himself
23:31:38 <cmccann> :t concatMap
23:31:39 <lambdabot> forall a b. (a -> [b]) -> [a] -> [b]
23:31:40 <Cale> So I think he gets it :)
23:31:49 <astry> ew0: as opposed to concatenate you can say it "binds" them
23:31:56 <astry> in darkness
23:32:05 <cmccann> one monad to rule them all
23:32:15 <Cale> and yeah, there's already a glued together version of concat and map, which only exists because of premature optimisation in old implementations of Haskell :)
23:32:32 <otters> :t (>>=)
23:32:33 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m a -> (a -> m b) -> m b
23:32:43 <otters> so concatMap is =<<
23:32:50 <Cale> right
23:33:32 <Cale> astry: well, it binds the elements of the list on the left to the parameter of the function on the right (and handles joining the results of that function into a single list)
23:33:55 <Cale> > [1,2,3] >>= \x -> [x, 10*x]
23:33:56 <lambdabot>   [1,10,2,20,3,30]
23:34:06 <astry> i thought "bind" meant just "join"
23:34:23 <otters> no
23:34:27 <Cale> I guess it's up to interpretation
23:34:29 <astry> not in terms of the "bind operator"
23:34:34 <astry> but in terms of the output
23:34:43 <astry> which ends up being joined, as opposed to [[b]]
23:34:56 <otters> :t join
23:34:57 <lambdabot> forall (m :: * -> *) a. (Monad m) => m (m a) -> m a
23:35:01 <Cale> but I've always thought it was called that just because of how it binds the result of the computation on its left to the parameter of the (presumed) lambda on its right
23:35:30 <astry> hmm ok
23:35:36 <cmccann> maybe we should rename (=<<) joinFmap by analogy to concatMap
23:35:43 <ion> cale: gzipMiddleware :: (Request -> IO Response) -> Request -> IO Response; gzipMiddleware app req | wantsGzip req = (mapBody gzipCompress . addGzipHeader . app . removeGzipHeader) req | otherwise = app req
23:36:49 <ion> cale: That will work no matter if Request and Response are ByteStrings or not, but it will be less work if Request has been parsed just once in the beginning and a HTTP response will be generated out of Response just once in the end.
23:37:05 <Cale> ion: Have you looked at the Request and Response types in wai?
23:37:34 <ew0> so do x ; y  is just    x >>= y
23:37:37 <otters> but joinFmap is bind
23:37:41 <otters> ew0: it's x >> y
23:37:51 <ion> cale: Not really. They may totally suck for all i know, but that doesn’t mean there’s no good way to do this.
23:37:54 <Cale> ion: I find it hard to believe that anything other than Yesod is going to use those very easily, due to the dependencies on Conduit and Blaze
23:39:05 <Cale> ion: Maybe it's possible to just replace *those* bits with ByteString
23:39:25 <pharaun> is there anything wrong with conduit/blaze i thought lots of folks used them?
23:40:20 <Cale> pharaun: Well, okay, there's a bunch of people who have jumped into using each of those, but they're pretty serious pieces of architecture, and are *not* obviously the best possible thing.
23:40:44 <pharaun> fair enough :)
23:40:47 <Cale> (that's not to say that they're bad, just that they're pretty big design choices)
23:43:54 <Cale> In particular, I still can't really see myself using Conduit unless I was really pressured into taking that sort of route with something.
23:44:18 <pharaun> curious why not? i've been using it for some of the fs stuff and its kind of nice
23:44:49 <Cale> Choosing to use it seems like an insane premature optimisation to me.
23:45:13 <pharaun> over regular lazy i/o ?
23:45:21 <Cale> Yes.
23:45:38 <Cale> Or over regular strict I/O
23:45:48 <ram_> why is it impossible to cleanly do state in Haskell?
23:45:50 <cmccann> regular strict IO is very underrated
23:46:03 <pharaun> a ton of my filesystem code was in regular strict IO and they worked :)
23:46:04 <Cale> ram_: It's not impossible, and there are tons of ways to do it.
23:46:15 <astry> ram_: why do you say it is impossible?
23:46:28 <pharaun> just felt kind of chunky, i have a conduit version and it is certainly tons shorter
23:46:34 <astry> i use IORef for state in the program i'm working on right now
23:46:51 <cmccann> ram_, why is it impossible to manage state changes in most other languages?
23:46:53 <pharaun> ram_: i use MVars here
23:47:04 <Cale> I open up the haddock for Data.Conduit and I see things like (>+>) :: Monad m => Pipe l a b r0 m r1 -> Pipe Void b c r1 m r2 -> Pipe l a c r0 m r2
23:47:14 <Cale> and, you know, maybe that's perfectly reasonable
23:47:17 <cmccann> hooray, type variables!
23:47:31 <ion> data Request = Request { reqMethod :: ByteString, reqURI :: ByteString, reqHTTPVersion :: ByteString, reqHeaders :: Map ByteString ByteString, reqBody :: ByteString }; data Response m = Response { respHTTPVersion :: ByteString, respStatusCode :: Integer, respReason :: ByteString, respHeaders :: Map ByteString ByteString, respBody :: m ByteString }  -- or something like that
23:48:13 <Cale> ion: Well, okay, something like that would be pretty much fine by me.
23:48:15 <ram_> cmccann: it's not, you just use mutable state
23:48:28 <pharaun> Cale: heh i'm not really deep into conduit :) but yeah some of the types/def makes my eyes cross
23:48:31 <cmccann> ram_, which is exactly the problem, that's a terrible way to do it
23:48:55 <pharaun> Cale: it just seems like the cleanest fit to my problem as it is right now but who knows i might end up on a different solution if i find a better one
23:49:01 <cmccann> Cale, to be fair if you look at that type for a moment it's clearly two different compositions and some sort of monad
23:49:03 <ram_> cmccann: why is it?
23:49:34 <Cale> cmccann: yeah, there's definitely something structured going on there, but the library has completely failed to capture whatever it is in a way which is easily comprehensible
23:50:03 <ew0> is there a function somwhere to sanitize any string to be used as a filename?
23:50:15 <pharaun> i had to go back to iteratree and start at scratch to understand some of the things that conduit was doing
23:50:32 <cmccann> ram_, just learn how to do things in Haskell and you'll understand why most other languages are worse soon enough
23:50:35 <Cale> I've also never loved Iteratee
23:51:17 <cmccann> using iteratees feels like mincing your program up into tiny pieces and shoving them into some weird machine with the wrong level of granularity for basically everything :T
23:51:28 <pharaun> aha i see
23:51:43 <pharaun> my use of conduit is very very limited, i isolate it mainly to the FS/Hasher on disk
23:52:20 <pharaun> so that usage/the code i have in those area feels pretty clean but i don't think i would want to structure my entire program around conduit pipelines
23:53:32 <cmccann> the free monad business in pipes at least gives a nicer API, to my mind
23:54:19 <ram_> cmccann: "just learn how to do things in Haskell and you'll understand why most other languages are worse soon enough" that's a good explanation for why it's a terrible thing to use mutable state?
23:54:40 <pharaun> ram_: ok here's a quick example. Threads
23:54:44 <cmccann> no, it's telling you how to discover the answer yourself
23:55:06 <cmccann> ram_, but something tells me you're not actually interested in learning, given the question you asked when you first joined
23:55:25 <pharaun> ram_: another example, being able to export your entire state set, then hot reload your program (Ala xmonad)
23:55:55 <Cale> cmccann: Actually, I hadn't really taken a look at pipes yet, but the description sounds hopeful.
23:55:58 <ew0> I'm figuring out monads, just need a few more days writting haskell
23:56:21 <Cale> cmccann: and there are only 4 type parameters, so you know they must be doing something right ;)
23:56:34 <pharaun> ew0: having a little project does go a long way in helping you pick up on haskell imho :)
23:56:50 <cmccann> Cale, it's basically the free monad for a functor representing the things you can do at each step of a stream processor
23:57:15 <ew0> yeah, I actualy have a very big project (my phd)
23:57:25 <ew0> I wrote most of it in python, but it is tooo slow
23:57:28 <cmccann> so binding lets you glue new layers of step actions using do notation
23:57:33 <ew0> I'm moving the heavy stuff to haskell
23:57:47 <Cale> ram_: Okay, there are lots of problems with managing state with explicit mutable variables. Think about a game or something -- it's essentially a big graph of stateful things which depend on one another in various ways.
23:58:16 <ew0> the cool stuff is I'm finding a ton of bugs I never knew xD
23:58:33 <pharaun> ew0: type system has a way of doing that to you, i would also suggest checking out quickcheck too :)
23:58:40 <Cale> ram_: Using mutable variables and explicitly saying when one thing updates in terms of another leaves room for many many bugs: you can forget to update the state of one thing in response to another changing.
23:58:43 <pharaun> i'm finally applying quickcheck to a subsystem of mine its sweet
23:58:58 <Cale> ram_: you can do the updates in the wrong order, and obtain the wrong results
23:59:07 <ddarius> (>>=), "bind", directly implements binding (let) from Moggi's monadic meta language.
23:59:15 <ew0> yeah, it forces to think of a real general solution, instead of covering corner cases
23:59:24 <ew0> forces you*
23:59:35 <Cale> ram_: you can update something too frequently even when the things it depends on haven't changed, resulting in worse performance
23:59:49 <pharaun> ew0: yeah i find often time i write down a specific solution, i code it, i notice how to generalize it and how to clean it up then over time i end up with a nice and general solution :)
