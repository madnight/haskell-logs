00:00:02 <johnw> not even on creation of the Lazy BS
00:00:05 <shachaf> type ByteString.Lazy.ByteString = [ByteString.Strict.ByteStrict]
00:00:13 <shachaf> Sure there is, on creation.
00:00:20 <johnw> yeah?  how?  I couldn't find it
00:00:31 <pharaun> shachaf: oh? only way i found was to recompile my own build of the library
00:00:34 <johnw> you mean, by writing a recursive function to build the list
00:00:38 <shachaf> Right.
00:00:48 <pharaun> hm
00:00:51 <johnw> interesting
00:00:54 <shachaf> The library's IO functions and such are probably hard-wired to some value.
00:00:59 <pharaun> they are
00:01:14 <shachaf> fromChunk (repeat (SB.pack [1,2,3]))
00:01:18 <pharaun> so i would need to provide my own version of the io function to construct....
00:01:44 <ew0> hello, which is the default implementation for graphs in Haskell?
00:02:29 <johnw> 'default'?
00:02:35 <ew0> I was playing with Data.Graph
00:02:38 <shachaf> We need @official
00:02:39 <ew0> but it seems, uhm lacking
00:02:42 <johnw> from the "graphs" package?
00:03:01 <shachaf> ew0: What's the default one in C?
00:03:12 <ew0> xD ok, ok
00:03:15 <dmwit> ?hackage fgl
00:03:15 <lambdabot> http://hackage.haskell.org/package/fgl
00:03:15 <ew0> your favorite one
00:03:17 <ew0> ok
00:04:23 <ew0> ow yeah
00:04:23 <sopvop> is there a function to `init' and `last' in one go?
00:04:28 <shachaf> So can you do things like pattern-match on successors with GHC's type-level anturals?
00:04:29 <ew0> that was what I was talking about
00:04:32 <ew0> thanks!
00:04:54 <dmwit> sopvop: Don't think so. Write one!
00:04:56 <ew0> uhm, not really
00:05:19 <ew0> I only need to unroll some loops in a graph
00:05:21 <dmwit> shachaf: type instance F (S n) = ...
00:05:32 <sopvop> dmwit: Seems i'll have to, prefer to use standard ones though
00:05:37 <ew0> and do a topological sort
00:05:39 <shachaf> dmwit: Where does S come from?
00:05:55 <dmwit> I... oh, what, GHC has some built-in nats now?
00:05:57 <dmwit> Ignore me.
00:06:21 <shachaf> λ> :k 5 + 3
00:06:22 <shachaf> 5 + 3 :: Nat
00:06:54 <mm_freak> ok, i think i really want GHC 7.6
00:07:06 <johnw> > liftM2 (,) init last $ [1, 2, 3]
00:07:07 <lambdabot>   ([1,2],3)
00:07:14 <shachaf> mm_freak: I haven't worked out whether these Nats are useful for anything yet.
00:07:22 <johnw> sopvop: ^
00:08:04 <dmwit> http://hackage.haskell.org/trac/ghc/wiki/TypeNats/InductiveDefinitions
00:08:10 <dmwit> See also the page one level up.
00:08:35 <sopvop> johnw: that will traverse list twice, and that's what I want to avoid :)
00:08:49 <dmwit> ?google beautiful folding haskell
00:08:50 <lambdabot> http://squing.blogspot.com/2008/11/beautiful-folding.html
00:08:59 <dmwit> sopvop: might like that, maybe
00:09:10 <johnw> sopvop: oh, I see
00:09:28 <johnw> sopvop: would be a trivial function to write, but yeah, I don't know of it
00:10:38 <dmwit> shachaf: (Dunno whether that actually answers your question or not.)
00:10:56 <Nereid> so
00:11:01 <Nereid> http://hackage.haskell.org/packages/archive/reflection/1.1.6/doc/html/Data-Reflection.html
00:11:07 <Nereid> I'm trying to understand the type signature for reflect
00:11:34 <shachaf> I want something like data family (n :: Nat) a; data instance 0 a = Nil; data instance (S n) = Cons a (Vec n a)
00:11:38 <Nereid> I know proxy is some function defined in Data.Proxy, but how does proxy s make sense as a type?
00:11:50 <ew0> "The same as Decomp, only more sure of itself" LOL
00:11:51 <shachaf> dmwit: Does that help me with that?
00:11:59 <ew0> straight out of the docs
00:12:12 <dmwit> shachaf: You have access to exactly the same resources I do. =)
00:12:29 <shachaf> dmwit: All those resources + a working GHC 7.6!
00:12:31 <dmwit> And you know I don't have experience with it, since I just learned about it when I read your message ten minutes ago.
00:12:44 <shachaf> True enough.
00:12:50 <Nereid> anyone? :S
00:13:17 <dmwit> Nereid: proxy :: * -> *, what's the problem?
00:13:29 <Nereid> how is that?
00:13:40 <dmwit> Nereid: How does the type Monad m => m () make any sense?
00:13:46 <dmwit> answer: m :: * -> *
00:13:52 <Nereid> yeah but what's proxy
00:13:56 <dmwit> It's a type variable.
00:13:58 <dmwit> Just like m.
00:14:11 <Nereid> but m comes into existence when you say Monad m
00:14:25 <dmwit> m () is a perfectly good type even without the Monad m constraint.
00:14:27 <shachaf> It comes into existence when you say m, presumably.
00:14:36 <Nereid> aghhhhhhhhhhtghghthtghtghthth
00:14:39 <Nereid> so this is
00:14:48 <Nereid> reflect :: forall (proxy :: * -> *). proxy s -> a
00:14:49 <Nereid> or so
00:14:52 <dmwit> yes
00:14:53 <Nereid> ?
00:14:55 <Nereid> well then.
00:14:56 <Nereid> thanks.
00:15:14 <Nereid> the name was throwing me off, I guess.
00:15:24 <avpx> Yeah, I think it's dangerous to think that constraints create the type variable
00:15:49 <Nereid> I'd have figured it out eventually. :V
00:15:50 * dmwit . o O ( What is this, a type variable with more than one letter?? )
00:15:51 <dmwit> ;-)
00:15:51 <shachaf> So given that you can define a reasonable-seeming Vec as either a GADT and data family, are there big advantage to one or the other?
00:16:03 <shachaf> dmwit: How un-abstract!
00:16:13 <avpx> dmwit: That would throw me off, too. Perhaps that reflects badly on Haskell naming conventions?
00:16:43 <dolio> shachaf: It's the same as defined vectors as an inductive family or by recursion on the naturals in, say, Agda.
00:16:49 <dolio> Defining, even.
00:17:03 <shachaf> dolio: Right.
00:17:05 <mm_freak> shachaf: i don't see a difference, until we have kind classes
00:17:24 <shachaf> I assume the former is somewhat nicer but I don't really know.
00:17:31 <dolio> Yes.
00:17:34 <Nereid> dmwit: I feel like an idiot now, thanks.
00:17:41 <shachaf> dolio: Feel free to answer my question about Agda instead of Haskell.
00:18:13 <dolio> The advantage of the inductive family is that you get pattern matching with refinement on the index.
00:18:29 <dmwit> Nereid: No worries. My "what's the problem" was significantly tongue-in-cheek, as I've failed to grok the reflection package before myself. =D
00:18:34 <shachaf> Ah, makes sense.
00:18:37 <dolio> And for the recursive definition, you have to match on the index to figure out what your vector looks like.
00:18:51 <dolio> Which, in Haskell, would mean defining all your functions in a type class, I think.
00:19:10 <dolio> At least, the ones that need to match directly.
00:20:59 <dolio> Of course, you can probably define a single fold function that lets you do everything else you'd want to do, in principle.
00:21:22 <mm_freak> dolio: i think, you get refinement for type families as well
00:21:46 <mm_freak> at least for associated types (naturally)
00:22:28 <akamaus> hi! what's the easiest cross-platform way of getting current time? I need a about a tenth of second precision.
00:22:34 <dolio> If Vec n is a data family, it doesn't make sense to pattern match on it until you know what n is.
00:22:48 <liyang> akamaus: Data.Time.getCurrentTime
00:23:41 <mm_freak> akamaus: do you need system time or just any clock for time deltas?
00:23:53 <akamaus> mm_freak, any clock
00:24:42 <mm_freak> akamaus: Data.Time.Clock is fine (time package), but sadly comparing times using diffUTCTime is slow (i get around 80k comparisons per second)
00:24:54 <mm_freak> if you need a faster time source, SDL has getTicks, which is a lot faster
00:25:07 <akamaus> mm_freak, I will do about ten in a second :)
00:25:19 <mm_freak> then use Data.Time.Clock =)
00:25:34 <akamaus> hope it wouldn't be the bottleneck ;)
00:26:07 <mm_freak> you would need to do 8000 times the number of comparisons for it to become a bottleneck on my system (i5, 2.8 GHz)
00:26:35 <mm_freak> i wonder how you make sure that you do 10 comparisons per second =)
00:27:07 <tdlguiinstall> .
00:27:08 <tdlguiinstall> .
00:27:08 <tdlguiinstall> .
00:27:08 <tdlguiinstall> .
00:27:08 <tdlguiinstall> .
00:27:08 <tdlguiinstall> .
00:27:08 <tdlguiinstall> .
00:27:09 <tdlguiinstall> ..
00:27:09 <tdlguiinstall> ..
00:27:10 <tdlguiinstall> .
00:27:10 <tdlguiinstall> .
00:27:11 <tdlguiinstall> .
00:27:11 <tdlguiinstall> .
00:27:12 <tdlguiinstall> ..
00:27:16 <pharaun> Cale: ^
00:28:09 <akamaus> mm_freak, I just do threadDelay 100000 inside my loop. I don't need absolute precision.
00:28:10 <hpaste> sopvop pasted “splitLast, should there be some lazy pattern matching?” at http://hpaste.org/74982
00:28:15 <astry_> hello
00:28:45 <johnw> pharaun: you can use the Last Monoid
00:28:48 <astry_> i need to build an image viewer in haskell, just to display images in a directory
00:28:54 <astry_> what windowing toolkit should i use?
00:28:55 <akamaus> mm_freak,  I'm sampling a position of an agent in a simulated environment.
00:28:58 <shachaf> johnw: Is that like the Last Unicorn?
00:29:02 <pharaun> johnw: hm?
00:29:03 <mm_freak> akamaus: you could get higher precision easily…  calculate the remaining delay for the current frame
00:29:09 <johnw> http://localhost:8687/file//usr/local/share/doc/ghc/html/libraries/base-4.5.1.0/Data-Monoid.html#v:Last
00:29:10 --- mode: ChanServ set +o Cale
00:29:12 <astry_> i would like this to work with runhaskell
00:29:33 <akamaus> mm_freak, I don't do the drawing :)
00:29:34 <astry_> i would also like double-buffering to be easy
00:29:35 <johnw> it is for getting the last of a series of Just x
00:29:49 <akamaus> john__, just controlling
00:29:52 <mm_freak> astry_: if you really just want to draw images without any widgets or anything, SDL is very simple
00:30:04 <johnw> but maybe that's more complication than you need here
00:30:06 <liyang> mm_freak: threadDelay is not exactly accurate. Expect errors of ±5ms to ±15ms.
00:30:22 <pharaun> johnw: probably for now :) but i'll keep it in mind :D
00:30:23 <johnw> shachaf: it's a Just MythicalBeast?
00:30:24 <akamaus> liyang, that's ok for me
00:30:25 <mm_freak> astry_: if you need more, the two main choices are gtk2hs (gtk package) or wxHaskell (wx package)
00:30:26 <dmwit> sopvop: Probably yes, there should, but profile it and make sure.
00:30:49 <mm_freak> liyang: i know…  you can correct the error using the time deltas
00:31:31 <mm_freak> astry_: if you like experimental stuff, you can also give reactive-banana-wx a shot
00:31:50 <mm_freak> it's an FRP wrapper around wx
00:32:05 <astry_> mm_freak: i also need keyboard input but that's all
00:32:32 <astry_> browsing backward and forward, deleting images
00:32:41 <astry_> zooming via mouse and dragging the image
00:32:47 <mm_freak> astry_: SDL provides you with a canvas (optionally using OpenGL) and of course feeds your application with WM events such as keystrokes
00:33:01 <astry_> what about resizes?
00:33:06 <astry_> do i get to resize my window?
00:33:07 <mm_freak> astry_: for the fancy stuff like zooming, dragging, rotating, etc., i recommend OpenGL
00:33:08 <akamaus> mm_freak, thanks for your suggestion about modifying the delay time. Looks like nevertheless it's actual for my case.
00:33:10 <liyang> astry_: and if you're okay with vapourware, we'll have a GTK-based toolkit based on https://github.com/tsurucapital/euphoria soon-ish.
00:33:12 <mm_freak> astry_: sure
00:33:25 <astry_> liyang: i want to be done before noon
00:33:34 <liyang> astry_: nevermind. :)
00:33:55 <astry_> mm_freak: i have started working with wx, i'll try sdl if wx takes too much time
00:34:20 <avpx> astry_: They're quite a bit different
00:34:30 <mm_freak> astry_: if you have OpenGL experience and can live without widgets (buttons, menus, etc.), definitely go with SDL
00:34:32 <avpx> SDL basically gives you a pixel buffer
00:34:34 <akamaus> astry_, also, if you need them, some vector graphics capabilities present in gtk2hs cairo
00:34:40 <astry_> oooops, first problem: wxc-0.90.0.4 failed during the configure step. The exception was:
00:34:42 <astry_> ExitFailure 1
00:34:55 <astry_> mm_freak: i have 0 opengl experience
00:34:58 <dmwit> Did you install wx, the C library? (and -dev files?)
00:35:14 <astry_> no, that was going to be my first bet though
00:35:15 <mm_freak> astry_: for image loading i recommend JuicyPixels…  only downside is that it only supports JPG, PNG, BMP and GIF
00:35:24 <mm_freak> astry_: but there are also DevIL bindings on hackage
00:35:47 <mm_freak> gives you more formats in exchange for a less convenient interface
00:35:50 <ClaudiusMaximus> gtk2hs + gtkglext is my preferred environment for graohivs, though it' s a bit of a headwrecking experience if you're new to it
00:35:58 <ClaudiusMaximus> *graphics
00:35:59 <akamaus> astry_ try gtk2hs then. All this 3d related stuff of opengl is quite involved on it's own
00:36:27 <mm_freak> you don't need any 3D for this application, but you should know how to actually draw stuff
00:36:35 <mm_freak> basic 2D drawing can be learned quite fast
00:36:38 <akamaus> astry_, your experience on windows may vary, it's the only downside with gtk2hs
00:36:50 <astry_> akamaus: i think wx works with runhaskell though doesn't it?
00:36:58 <astry_> i prefer things that work with runhaskell
00:37:09 <mm_freak> astry_: don't worry about runhaskell…  if it compiles, it also works with runhaskell
00:37:16 <dcoutts_> astry_: gtk2hs can work with ghci / runhaskell too
00:37:22 <astry_> no it doesn't
00:37:24 <Ralith> I don't think astry_ wants to use opengl.
00:37:27 <astry_> i've run into things that didn't work
00:37:31 <ClaudiusMaximus> JuicyPixels might soon support PPM and PGM, was in discussions with the author before my break away - i do have a library for that too anyway
00:37:53 <dcoutts_> astry_: yes there's sometimes issues, but it does work, I fixed it :-)
00:37:59 <akamaus> astry_, gtk2hs works, I've never tried wx so dont know. I don't like thick wrappers and on Linux gtk is native choose.
00:38:05 <astry_> juicypixels sounds good. i only need jpg, png, and bmp anyways. well, tiff might be good.
00:38:12 <mm_freak> astry_: if you come across examples of this again, i'd love to know, because i haven't in many years of haskell experience =)
00:38:12 <astry_> but for a start only jpg.
00:38:30 <dcoutts_> astry_: the recent release had a problem with loading cairo in ghci. There's a patch upstream and you can apply a local workaround.
00:38:36 <mm_freak> anyway, if OpenGL is too complicated, go with GTK, but you may have to scale your images manually
00:38:38 <astry_> mm_freak: one of the curses-style libs didn't work
00:38:41 <astry_> but i forgot which one
00:38:59 <dcoutts_> astry_: without rebuilding I mean, just have to tweak the package registration info for the cairo package
00:39:09 <mm_freak> in OpenGL you would simply draw a smaller rectangle and the image is scaled for you
00:39:30 <akamaus> mm_freak, astry_ yeah, you don't need 3d stuff, but you have to make your way through all these projection and modelview matrices and so on.
00:39:49 <astry_> ncurses did not work with runhaskell
00:39:54 <astry_> there you goo
00:40:03 <ClaudiusMaximus> mm_freak: (plus setup cost: generating mipmaps / texture filters if you don;t want it to look rubbash))
00:40:06 <akamaus> and opengl gives nothing for drawing widgets
00:40:09 <mm_freak> akamaus: you don't need to /understand/ them for simple applications, you just need to know how to use them…  GLU is of great help here
00:40:16 <astry_> now your many years of haskell experience are worth even more
00:41:02 <astry_> dcoutts_: thanks, i might try gtk2hs then
00:41:22 <astry_> dcoutts_: is there a simple way to draw a double-buffered rectangle in gtk2hs?
00:41:34 <dcoutts_> astry_: yes, it's double buffered by default
00:41:47 <akamaus> mm_freak, yeah.. but still it's an overkill. A friend of mine now busy porting a sketch of opengl visualizer I wrote a couple of days before to gtk2hs so I'm biased ;)
00:42:08 * hackagebot binary 0.6.1.0 - Binary serialisation for Haskell values using lazy ByteStrings  http://hackage.haskell.org/package/binary-0.6.1.0 (LennartKolmodin)
00:42:12 <dcoutts_> astry_: all you need to do is to draw in response to the onExpose signal and the double buffering is done fore you
00:42:13 <mm_freak> akamaus: well, i do most of my graphics stuff with OpenGL, even if it's really simple
00:42:30 <astry_> ok, wxhaskell requires wx 2.9 and ubuntu only has 2.8
00:42:31 <astry_> this sucks
00:42:38 <ClaudiusMaximus> astry_: and do your setup stuff onRealize iirc
00:42:41 <fmap> speaking about gth2hs; is there a chance it would be uploaded on hackage with 7.6 support?
00:42:42 <astry_> i'm trying gtk2hs next
00:42:48 <astry_> ClaudiusMaximus: what is setup stuff?
00:43:00 <ClaudiusMaximus> astry_: allocating textures, framebuffers, etc
00:43:15 <Catnaroek> Is there any version of cabal-install that is not incompatible with version 2.6 of the unix package?
00:43:59 <dmwit> fmap: I'm working on it. I don't even understand what broke yet.
00:44:43 <akamaus> dcoutts, what's the current stage of multithreading support in gtk2hs? I had some spurious crashes in the past on 0.9.
00:44:54 <dmwit> akamaus: http://dmwit.com/gtk2hs
00:45:00 <dmwit> multithreading is fully supported
00:45:08 <dcoutts_> akamaus: it works fine, but you need to be exceedingly careful if you're using the threaded rts
00:45:57 <fmap> dmwit: oh :(
00:46:04 <akamaus> dmwit, thanks! Looks like a great explanation.
00:46:06 <astry_> if i haven't run cabal update for a long time, and run cabal install gtk, will it install the latest version gtk?
00:46:27 <astry_> is cabal update only needed for cabal to know that a package exists, or is it also needed for it to find the latest version?
00:46:34 <dcoutts_> astry_: depends when you last did cabal updated, compared to when it was released
00:46:46 <astry_> for example half a year ago
00:46:55 <akamaus> dcoutts, careful with what? To do the work with gui in one dedicated thread?
00:46:57 <dmwit> cabal update is also needed to find the latest version.
00:47:05 <dmwit> akamaus: Yes, exactly.
00:47:10 <dcoutts_> astry_: it does not know magically :-)
00:47:26 <dmwit> akamaus: (And also that thread should be a bound thread.)
00:47:36 <astry_> so i'll get an old version of the package?
00:47:40 <astry_> ok.
00:47:41 <astry_> thanks.
00:47:55 <dmwit> astry_: You can find out with "cabal info gtk" and compare the output to
00:47:57 <dmwit> ?hackage gtk
00:47:57 <lambdabot> http://hackage.haskell.org/package/gtk
00:48:07 <akamaus> dmwit, I always done so, still had some crashes I have no idea how to debug
00:48:36 <dmwit> akamaus: If you can make a minimal reproducible test case, I can try to lend a bit of help, though I'm by no means an expert.
00:48:41 <dcoutts_> astry_: thing of it as a feature: when you do cabal update you get a snapshot of hackage, you'll get the same behaviour about which versions are selected etc until you next do an update
00:48:44 <dmwit> I'm only here because nobody else is. =P
00:49:09 <astry_> dcoutts_: makes sense
00:50:21 <akamaus> dmwit, they're non-reproducible :( Say, I have a two-threaded spectrum analyzer which fails with gtk-related error message every couple minutes or so. No idea why.
00:50:53 <astry_> wow gtk is taking ages to compile
00:50:55 <fmap> Catnaroek: you probably shouldn't install unix package by hand since it's bundled with ghc
00:51:03 <dmwit> It takes a while, yup.
00:51:06 <astry_> i think it's trying to solve the halting problem
00:51:08 <akamaus> astry_, indeed :)
00:51:18 <astry_> :))
00:51:37 <astry_> yay it finished!
00:51:40 <Catnaroek> fmap: Well unix-2.6.0.0 is what comes with GHC 7.6.1.
00:52:02 <akamaus> astry_, Wow! Guess you have a beefy hardware
00:52:09 <Catnaroek> fmap: And when I attempt to install cabal-install, it says needs unix >= 2.0 and < 2.6. :-/
00:52:20 <fmap> oh
00:52:46 <Catnaroek> Yeah, pretty weird.
00:52:56 <Nereid> Catnaroek: and what version of unix do you have?
00:53:03 <Catnaroek> Nereid: 2.6.0.0
00:53:07 <fmap> that's probably why i use cabal-install from 7.4.1
00:53:10 <Nereid> maybe you need to try a newer version of cabal-install
00:53:15 <Nereid> oh
00:53:23 <Nereid> yeah, I use cabal-install from 7.4.1 too
00:53:29 <Nereid> well 7.4.2
00:53:31 <Catnaroek> Is there anything more recent than cabal-install-0.14 ?
00:53:40 <dmwit> Catnaroek: Install cabal-install from darcs.
00:53:48 <Nereid> or git
00:53:51 <dmwit> Catnaroek: Even after you bump the dependencies, it still doesn't build on 7.6.
00:53:58 <Nereid> well when I tried it from git it built, but failed to run
00:54:01 <Nereid> correctly, anyway
00:54:11 <killy9999> how do I turn -O2 flag only for selected modules?
00:54:17 <pharaun> wee reduced it, its not crypto-hash, it was fact that there was no (afaik) bigBlockSource in conduit, i think i might try to submit a patch for a variable block size source or at least one for 1MiB blocks
00:54:25 <Catnaroek> Mmm...
00:54:32 <killy9999> I want some modules to be compiled with optimalization and some without
00:54:41 <Nereid> killy9999: there's a GHC_OPTIONS pragma, or if you're using cabal then maybe cabal can do it?
00:55:37 <astry_> akamaus: no it's just an ivy bridge
00:55:39 <astry_> 2.4
00:55:41 <astry_> or something
00:55:46 <killy9999> Nereid: thanks
00:56:15 <astry_> i have created this script: http://dpaste.com/803432/             however, when i close the window, the script does not exit. what gives?
00:56:39 <astry_> akamaus: Extended brand string: "      Intel(R) Core(TM) i7-2670QM CPU @ 2.20GHz"
00:56:56 <dmwit> astry_: The main loop doesn't exit just because there's no windows.
00:57:01 <astry_> dmwit: ok
00:57:02 <dmwit> After all, maybe you'll open another window later.
00:57:04 <ClaudiusMaximus> astry_:   window `on` destroyEvent $ mainQuit    or similar
00:57:07 <astry_> gotcha
00:57:12 <dmwit> You can add ... what ClaudiusMaximus said. =)
00:57:20 <astry_> yeah trying :)
00:57:49 <cbm80> dmwit: the latest cabal & cabal-install on github actually compiles now. i'm using it.
00:58:12 <dmwit> I never claimed it didn't.
00:58:21 <Nereid> I claimed so.
00:58:29 <cbm80> well just sayin'
00:58:33 <astry_> does not compile: http://dpaste.com/803434/
00:59:01 <ClaudiusMaximus> astry_: maybe i got the syntax/spelling wrong - it's been a while - check https://gitorious.org/maximus/graphgrow/blobs/master/Fractal/GraphGrow/GUI/Editor.hs#line177 for some code that opens/closes multiple windows
00:59:41 <ClaudiusMaximus> astry_: G.onDestroy window G.mainQuit   -- the key line
00:59:54 <astry_> yeah found it
00:59:55 <astry_> thanks
01:00:25 * ClaudiusMaximus wanders off for a bit, happy haskelling!
01:00:27 <astry_> works! great!
01:00:32 <astry_> thank you ClaudiusMaximus
01:00:50 <sopvop> http://hpaste.org/74983 splitLast profiled, am I doing it right?
01:01:11 <Nereid> so here's what I'm working on right now:
01:01:35 <Nereid> I made a Monad (Memoizing t), together with
01:01:52 <dmwit> sopvop: nope =)
01:01:56 <Nereid> memoizing :: (Int -> t) -> Memoized t a -> a, and memoized :: Int -> Memoized t t
01:02:01 <Nereid> now
01:02:15 <Nereid> I don't want anyone to tell me the answer but
01:02:32 <sopvop> dmwit: wouldn't `$!!' eval that whole thing?
01:02:49 <dmwit> Oh, you're asking if you've done the profiling bit right?
01:02:53 <Nereid> I have some f :: Monad m => (Int -> m a) -> (Int -> m a)
01:02:59 <dmwit> I thought you were asking whether you'd done the lazy-pattern-ising bit right.
01:03:16 <sopvop> dmwit: And what about lazy-pattern thing?
01:03:22 <Nereid> now (runIdentity . fix f) would be some recursive function
01:03:23 <dmwit> should be something like this:
01:03:48 <dmwit> go x ~(acc, m) = case m of Nothing -> (acc, Just x); Just l -> (x:acc, m)
01:03:57 <sopvop> oh, I see
01:03:59 <Nereid> but it's slow and memoization would make it faster, and I'm trying to figure out how to tie it in with Memoized.
01:04:49 <dmwit> not sure that helps, though, actually
01:05:01 <Nereid> hmm.
01:05:52 <sopvop> dmwit: It sure helps me understand, but still reversing the list is much faster and better. Thank you!
01:06:00 <dmwit> sopvop: I think you'll want to adjust it a bit. Give me a second.
01:06:31 <Nereid> hmm, maybe I can't.
01:09:07 <Nereid> ok, time to redesign Memoized.
01:09:07 <dmwit> sopvop: Also, are you sure that [1..100000] isn't getting shared by the optimizer?
01:10:45 <sopvop> Maybe, but .prof file shows cost inside function, not in main. I'll try to reverse order
01:12:18 <hpaste> sopvop pasted “same thing” at http://hpaste.org/74984
01:12:35 <dmwit> That's good. =)
01:12:45 <shachaf> So can you do a CPS sort of transformation to turn exists into forall?
01:13:49 <sopvop> dmwit: do I use `$!!; right way for profiling?
01:14:09 * shachaf isn't sure whether that can properly be called CPS.
01:14:36 <ew0> hey, I want to build an infinite list with its only element being 1
01:14:37 <mm_freak> shachaf: i think (forall a. a -> b) -> b is the same as exists a. a
01:14:44 <ew0> such as [1, 1, 1, ...]
01:14:49 <mm_freak> shachaf: at least practically
01:14:52 <ew0> any hint?
01:14:59 <sopvop> > take 10 $ repeat 1
01:15:01 <lambdabot>   [1,1,1,1,1,1,1,1,1,1]
01:15:05 <mm_freak> ew0: repeat 1
01:15:09 <ew0> tks
01:15:18 <mm_freak> if that's too long…
01:15:19 <shachaf> > [1,1..]
01:15:20 <lambdabot>   [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,...
01:15:25 <mm_freak> > fix(1:)
01:15:27 <lambdabot>   [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,...
01:15:39 <avpx> @src fix
01:15:39 <lambdabot> fix f = let x = f x in x
01:15:48 <Nereid> @src repeat
01:15:48 <lambdabot> repeat x = xs where xs = x : xs
01:15:56 <shachaf> mm_freak: Hmm.
01:16:10 <dmwit> sopvop: $!! seems reasonable, yup.
01:16:52 <mm_freak> shachaf: as a practical example think of a getLine that returns a Vec instead of a list
01:17:05 <sopvop> Thanks again. You #haskell guys are really nice.
01:17:16 <mm_freak> shachaf: option 1:  getLine :: IO (exists n. Vec n Char)
01:17:22 <shachaf> mm_freak: That makes sense because a function :: (exists a. ...a...) -> B is the same as a function :: forall a. ...a... -> B, I think.
01:17:33 <mm_freak> shachaf: option 2:  getLine :: (forall n. Vec n Char -> IO b) -> IO b
01:17:56 <shachaf> Right.
01:18:44 <ew0> I'm using the list with a zip3 so the longest the better
01:18:47 <ew0> xD
01:19:00 <Saizan> shachaf: currying
01:19:14 <shachaf> Saizan: Currying?
01:20:15 <avpx> Hmm. I've read a bit about intuitionist logic, and IIRC the definition of (not p) is that p implies falsity. What does this look like in Haskell?
01:20:25 <shachaf> data Void
01:20:29 <shachaf> type Not a = a -> Void
01:20:51 <avpx> So in this case it's just bottom
01:21:05 <shachaf> _|_ (the value) has nothing to do with it.
01:21:05 <avpx> Is using Void different than (forall a. a)?
01:21:17 <shachaf> Not really, except that it's valid Haskell. :-)
01:21:18 <dmwit> Void is not different from (forall a. a).
01:21:34 <avpx> Okay.
01:21:37 <dmwit> falsity is bottom, yes.
01:21:45 <dmwit> (not p) is not bottom, necessarily.
01:22:06 <shachaf> People call it "bottom", but it's not really related to what people call "bottom" in Haskell.
01:22:27 <dmwit> It... actually sort of is in this case?
01:22:32 <shachaf> Is it?
01:22:38 <dmwit> bottom :: bottom
01:22:44 <shachaf> The uninhabited type doesn't have much to do with the value that inhabits every type.
01:22:44 <dmwit> =)
01:22:57 <shachaf> That value inhabits that type, of course, but that's because it inhabits every type.
01:23:15 <dmwit> bottom is the most general type of bottom.
01:23:17 <shachaf> "uninhabited" except for the value _|_, I mean. :-)
01:23:24 <avpx> shachaf: But it is uniquely so
01:23:45 <ew0> ok, major heavy lifting in my graphs done
01:23:55 <ew0> tested for the largest graph and it takes 3 secs
01:23:58 <shachaf> The value "bottom" is called that because it's the "least defined" in the semilattice of definedness, or something.
01:24:14 <ew0> quite good comparing the 40 minutes of the python implementation
01:24:45 <ew0> xD
01:24:57 <ew0> I'm really liking haskell
01:25:39 <Saizan> shachaf: since exists a. P a is a tuple with a fancier type then going from exists a. P a -> B to forall a. P a -> B is essentially currying
01:26:45 <ew0> good night ppl
01:26:48 <ew0> thanks for the help
01:27:02 <shachaf> Ah, "((a:A),(b:B a)) -> R"  -->  "(a:A) -> (b:B a) -> R"?
01:27:27 <shachaf> That makes sense.
01:29:15 <bartavelle> why is this Haskell news ? http://joyridelabs.de/blog/?p=1435
01:29:45 <bartavelle> written in haskell ?
01:29:47 <Botje> yes
01:29:52 <bartavelle> ok !
01:30:11 <dmwit> Well, that was easy.
01:30:28 <hiptobecubic> I tried to play the demo of that game
01:30:36 <hiptobecubic> The controls were really miserable, but the idea was nice
01:30:51 <hiptobecubic> I wonder if it's been cleaned up
01:30:59 <bartavelle> I wondered if this wadn't a case of famous haskell guy promotion for an unrelated project
02:04:06 <astry_> hi again
02:04:27 <astry_> dcoutts_: any idea how i would grab keyboard input?
02:04:44 <astry_> like, say, the right arrow.
02:06:00 <dcoutts_> astry_: you usually do it for a specific widget (which might be a container for several other widgets)
02:06:34 <dcoutts_> so you just use the keyboard event signal for the widget
02:07:08 <dcoutts_> astry_: I think the gtk2hs examples have an example of this
02:07:36 <ClaudiusMaximus> window around eventbox around opengl canvas is what i usually do, from hazy memory
02:09:05 <astry_> dcoutts_: events bubble up, right? so i'll just do it for the window
02:09:14 <astry_> dcoutts_: "gtk2hs examples" let me search for that
02:09:35 <dcoutts_> it's part of the gtk2hs sources, demo dir
02:11:24 <akamaus> my program suddenly started to fail on running in ghci. Looks like two version of time package are loaded as dependencies. Any ideas? http://hpaste.org/74986
02:12:18 <astry_> wow i keep on getting old documentation in google results, this sucks so much
02:12:28 <astry_> i wish there were a way to get the latest docs only
02:12:44 <flux> astry_, try google time ranges :)
02:13:28 <astry_> meh
02:16:04 <astry_> @hoogle liftIO
02:16:04 <lambdabot> Network.CGI liftIO :: MonadIO m => IO a -> m a
02:16:04 <lambdabot> Control.Monad.IO.Class liftIO :: MonadIO m => IO a -> m a
02:16:04 <lambdabot> Network.CGI liftIO :: MonadIO m => forall a. IO a -> m a
02:16:27 <t7> @hoogle lift
02:16:27 <lambdabot> Text.ParserCombinators.ReadPrec lift :: ReadP a -> ReadPrec a
02:16:27 <lambdabot> Control.Applicative liftA :: Applicative f => (a -> b) -> f a -> f b
02:16:27 <lambdabot> Control.Applicative liftA2 :: Applicative f => (a -> b -> c) -> f a -> f b -> f c
02:16:49 <astry_> hmm
02:16:58 <astry_> i'm looking for a function which is called liftIO
02:17:23 <merijn> Control.Monad.Trans is the usual place to get liftIO from
02:17:25 <t7> astry_: in what monad ?
02:18:00 <akamaus> mm_freak, have got a weird crash with Time. Can you help?
02:18:08 <astry_> found it already, it's in Control.Monad.IO.Class
02:21:09 <hiptobecubic> astry_, hayoo is quite good i think
02:21:33 <fmap> astry_: it's the same function. Control.Monad.IO.Class is from transformers, Control.Monad.Trans is from mtl
02:21:36 <astry_> right hayoo
02:21:41 <astry_> i get lost in all those haskell tools :)
02:21:47 <astry_> so guys
02:21:58 <astry_> i need to traverse a directory, getting file names, and possibly opening files
02:22:01 <shachaf> astry_: That's no way to talk to the nice people of #haskell!
02:22:05 <astry_> how do i best do this?
02:22:11 * hackagebot Cabal 1.16.0 - A framework for packaging Haskell software  http://hackage.haskell.org/package/Cabal-1.16.0 (DuncanCoutts)
02:22:13 * hackagebot bytestring 0.10.0.0 - Fast, compact, strict and lazy byte strings with a list interface  http://hackage.haskell.org/package/bytestring-0.10.0.0 (DuncanCoutts)
02:22:15 * hackagebot bytestring 0.10.0.1 - Fast, compact, strict and lazy byte strings with a list interface  http://hackage.haskell.org/package/bytestring-0.10.0.1 (DuncanCoutts)
02:22:19 <astry_> sorry, guys
02:22:20 <astry_> ...and girls
02:22:23 * astry_ nods to shachaf 
02:22:33 <shachaf> ?
02:22:39 * shachaf was just making silly joke. Never mind.
02:22:48 * shachaf >=> sleep
02:23:08 <hiptobecubic> astry_, i think RealWorldHaskell has this as an example case
02:23:49 <mm_freak> akamaus: if you provide more info, i might
02:24:59 <akamaus> mm_freak, great, take a look then http://hpaste.org/74986
02:26:13 <ivanm> dcoutts_: can we expect cabal-install-0.16 any time soon?
02:27:17 * hackagebot bytestring 0.10.2.0 - Fast, compact, strict and lazy byte strings with a list interface  http://hackage.haskell.org/package/bytestring-0.10.2.0 (DuncanCoutts)
02:27:34 <Spockz> I have a data-type (GADT) which has an Eq constraint on it's constructors, However, the Category class doesn't have this constraint, how can I make my datatype an instance of Category? (See: https://gist.github.com/bf11d9f7e2dffeae6b6f)
02:28:51 <shachaf> You can't.
02:29:55 <akamaus> mm_freak, have solved it. Looks like some package updated old Time so different packages used different versions. And I happened to  use them together. After reinstall the error is gone
02:29:55 <shachaf> Spockz: Are you sure you need the Eq constaints on the constructors?
02:30:11 <Spockz> shachaf: I've been trying to avoid it
02:30:19 <shachaf> If your functions need Eq constraints, you can put the Eq constraints on the functions.
02:31:00 <mm_freak> akamaus: ah, ok
02:31:02 * shachaf wonders whether "R" is really what Spockz wants.
02:31:29 <shachaf> Anyway, I'm to sleep. Good luck.
02:31:29 <Spockz> shachaf: what I want is to be able inspect the structure of my arrow
02:31:53 <Spockz> shachaf: and it is working now, with the exception that I want to add some functionality that needs Eq :)
02:33:31 <mm_freak> Spockz: why would you need the Eq on the constructors?
02:34:14 <mm_freak> mySuperSpecialId :: (Eq a) => R a a; mySuperSpecialId = Id
02:35:33 <Spockz> mm_freak: because of this: https://gist.github.com/30ef98d17c4ebe138ce3
02:36:19 <Spockz> mm_freak: the == on line 19
02:37:15 <mm_freak> Spockz: that doesn't require an Eq constraint on the constructors
02:37:23 <mm_freak> in fact i don't know anything that does
02:37:24 <Spockz> which forces a Eq a, which in turn forces Eq b because of line 29, and there also comes the Eq constraint on the constructor,
02:37:56 <Spockz> lines 28 and 29
02:40:04 <Spockz> mm_freak: because of the recursive call to install there
02:40:21 <mm_freak> Spockz: just try without the Eq constraint on the constructors…  id and (.) don't need the Eq
02:40:39 <Spockz> mm_freak: no, but Comp does
02:41:00 <Spockz> which is (.)
02:41:37 <Spockz> Ive updated the gist https://gist.github.com/30ef98d17c4ebe138ce3 u
02:45:03 <mikeplus64> why does ghc use do notation with curly braces so much?
02:45:34 <mikeplus64> (and in a relatively odd style, for curly brace styles - with ; at the beginning of lines
02:45:38 <mikeplus64> )
02:46:36 <hiptobecubic> mikeplus64, haskell programmers often use that nice "separator at the beginning" style
02:46:37 <osfameron> you mean the generated core code?
02:47:00 <mikeplus64> osfameron: i mean the ghc sources
02:47:06 <osfameron> ah
02:48:11 <mikeplus64> and occassionaly very odd indentation e.g. compiler/typecheck/TcEnv.lhs lines 592 -> 604
02:48:14 <Spockz> mm_freak: can you explain a bit more what you mean?
02:55:29 <Otto123123> So i am new to using the quciCheck lib for testing and i am getting this error message how do i delcare such a instance ?  No instance for (Testable (Int, Int))
02:55:29 <Otto123123>    arising from a use of `quickCheck'
02:55:29 <Otto123123>  Possible fix: add an instance declaration for (Testable (Int, Int))
02:55:29 <Otto123123>  In the expression: quickCheck prop_world_move
02:55:29 <Otto123123>  In an equation for `main': main = quickCheck prop_world_move
02:57:51 <mm_freak> Spockz: you never need a constraint on constructors, unless the type variable is existential, which is not the case in your example
02:58:19 <mm_freak> an existential type variable is one that does not appear in the resulting type
02:58:34 <mm_freak> MyConstr :: a -> MyType Int
02:59:23 <Spockz> Comp     :: R b c    -> R a b          -> R a c < that would be b then
03:00:08 <mm_freak> that one is existential, but it doesn't really help the point
03:00:13 <mm_freak> again, just try without
03:00:18 <mm_freak> don't insist that you need it
03:00:21 <Spockz> mm_freak: I tried it
03:00:30 <mm_freak> care to show the code?
03:00:40 <pepe> I am trying to contribute to http://trac.haskell.org/diffarray/ticket/2 but I can't register an account properly. Is this on purpose / a known issue ?
03:01:35 <Spockz> mm_freak: I did, I'll add some more
03:01:50 <mm_freak> Spockz: show the one that fails without the constraints
03:02:04 <Spockz> mm_freak: https://gist.github.com/30ef98d17c4ebe138ce3
03:02:56 <Spockz> mm_freak: v
03:02:59 <Spockz> mm_freak: https://gist.github.com/30ef98d17c4ebe138ce3
03:03:23 <mm_freak> Spockz: at a first glance my first guess is that you really just need to add a type signature on line 35
03:03:34 <mm_freak> probably combined with ScopedTypeVariables
03:03:54 <mm_freak> since Cache has no arguments, it may fail to unify the types
03:04:50 <mm_freak> Spockz: with ScopedTypeVariables you can write:  install :: forall a b. (Eq b) => R a b -> RVar a -> IO (RVar b)
03:05:18 <mm_freak> then you can use the type variables 'a' inside the definition to refer to the main signature's types
03:05:24 <mm_freak> + and 'b'
03:06:12 <mm_freak> Spockz: oh, sorry, line 34
03:06:26 <mm_freak> i.e. write a type signature for 'set' including the scoped type variables 'a' and 'b'
03:08:11 <Spockz> mm_freak: I've done it with a only https://gist.github.com/30ef98d17c4ebe138ce3
03:11:29 <astry_> dcoutts_: i am trying to iterate through a list, say ["a", "b", "c", ... "z"]. Every time I get a Return event on my widget, I would like to change the title of the window to the next element. I'm not sure how to do this. I know how to change the title and how to receive events, but I'm not sure how to keep state inbetween.
03:12:02 <astry_> dcoutts_: any tips on how to do this in gtk2hs? this is my current code.. http://dpaste.com/803480/
03:13:36 <mm_freak> Spockz: i'd expect that to error, because 'a' has no Eq constraint
03:13:53 <asante> i'm trying to do some recursive user input. getting numbers till a 0 and then put them together in a list. but my recursion is wrong, cause i can not figure out, how to build that list right.. my first attempt looks like
03:14:06 <hpaste> asante pasted “recursive number input” at http://hpaste.org/74990
03:14:12 <Spockz> mm_freak: it's the same with b
03:14:14 <astry_> or maybe someone else knows how to keep state between event handlers in gtk2hs?
03:14:26 <mm_freak> Spockz: 'b' has an Eq constraint, but 'a' doesn't
03:14:56 <Spockz> mm_freak: if I use set :: Eq b => OnValSet b I get a similar errorr
03:15:08 <mm_freak> Spockz: you can't add constraints to scoped type variables
03:15:17 <mm_freak> just leave out the constraint
03:15:29 <mm_freak> it refers to the 'b' from the outer type signature, so the Eq applies automatically
03:16:36 <shachaf> Saizan: Oh, so "CPS" does have something to do with it.
03:16:49 <mm_freak> good morning shachaf =)
03:16:50 <Spockz> mm_freak: I see. https://gist.github.com/30ef98d17c4ebe138ce3
03:16:59 <shachaf> (exists a. Foo a) ==> (forall r. ((exists a. Foo a) -> r) -> r) ==> (forall r. (forall a. Foo a -> r) -> r)
03:17:13 <mm_freak> Spockz: if the type is correct, that seems sensible
03:17:36 <Spockz> mm_freak: So we still need to get the Eq constraint from the fields of the Comp constructor
03:18:38 <mm_freak> Spockz: reading your code you probably want 'a' instead of 'b', so really your 'a' needs an Eq constraint in the outer type signature
03:18:43 <mm_freak> on 'install' that is
03:18:46 <shachaf> nominolo++ # lambdachine
03:18:54 <shachaf> mm_freak: Grngh.
03:19:06 <Spockz> mm_freak: yes I agree.
03:19:13 <merijn> asante: I see a few errors
03:19:28 <mm_freak> Spockz: in any case, putting the constraints on the constructors will not be necessary
03:19:35 <asante> merijn: ok, can you hint me at them?
03:19:38 <merijn> asante: 1) You do "return ints", but ints is not in scope (it is defined in the case statement)
03:20:01 <mm_freak> Spockz: the problem lies within the 'install' function…  nothing else needs Eq constraints, in particular not construction of an R value
03:20:15 <merijn> asante: 2) You define ints as "x : getIntsTillZero", what is the type of x and what is the type of getIntsTillZero?
03:20:36 <mm_freak> rule of thumb:  if you're putting constraints on non-existential variables in a constructor, you're doing something wrong
03:20:51 <shachaf> mm_freak: There are some exceptions to that.
03:20:54 <asante> merijn: i saw that problem, but couldn't figure a nice solution
03:20:55 <shachaf> (Are we talking about GADTs?)
03:21:10 <mm_freak> shachaf: we are, and i don't know examples
03:21:17 <merijn> asante: As a side note, whenever you do "x <- getLine; read x" you probably want readLn
03:21:20 <merijn> :t readLn
03:21:22 <lambdabot> forall a. (Read a) => IO a
03:21:54 <mm_freak> shachaf: perhaps for some static proofs, but not for getting things done
03:21:54 <Spockz> mm_freak: yes, but because I recursively call install it will need the Eq a constraint on the parameter. But the parameter comes from the constructor, which has a type without the constraint
03:22:08 <Saizan> shachaf: yeah, have you seen monad-ran? it's a lot like rediscovering church-encodings by generalizing CPS
03:22:22 <Spockz> shachaf: we are talking about this: https://gist.github.com/30ef98d17c4ebe138ce3
03:22:22 <shachaf> Saizan: Nope.
03:22:34 <t7> when is it useful to use first class polymorphism? isn't polymorphic let a sufficient alternative?
03:22:35 <Saizan> generalizing Cont/Codensity at least
03:22:36 <merijn> asante: The first problem (ints not in scope during return) is easy, just put the return in the case statement
03:23:11 <hpaste> merijn annotated “recursive number input” with “recursive number input (annotation)” at http://hpaste.org/74990#a74992
03:23:22 <astry_> hey guys, haskell is reporting the System package is not installed, and that it's in the package haskell98
03:23:31 <astry_> i thought that gets installed by haskell platform?
03:23:40 <mm_freak> Spockz: one of my problems is that i can't run your code and i also don't understand its intention
03:24:06 <Spockz> mm_freak: I can explain it to you
03:24:35 <merijn> asante: So now, something for you to think about is, that you have "x :: Int", "getIntsTillZero :: IO [Int]" and "(:) :: a -> [a] -> [a]" and you need to combine this somehow into "IO [Int]"
03:25:10 <astry_> should i install haskell98 with cabal install?
03:25:12 <astry_> i'm lost
03:25:21 <astry_> i tried that and it errors out
03:25:28 <shachaf> Saizan: So this conversion is the same as ∃x.P(x) == ¬∀x.¬P(x)
03:25:38 <shachaf> Well, if you pick r = Void
03:25:44 <mm_freak> Spockz: only briefly, because i have to go soon
03:25:52 <shachaf> Saizan: I should look at monad-ran tomorrow.
03:26:12 <Spockz> mm_freak: the intention is to inspect the Arrow that has been build up. RVars are IORefs containing a RVal { meta:: MetaData , value :: a }. The installing is to create a RVar at each `junction'
03:26:23 <matthiasgorgens> I'm using the PromptMonad.  Now I need to implement something to set up an inotify (easy with the hinotify), that should then call back asynchronously and cause something to happen in the PromptMonad.
03:26:27 <matthiasgorgens> anybody have any clue?
03:26:28 <merijn> asante: The simplest solution will probably involve the fact that IO is a Functor in addition to a Monad, so you have access to "fmap :: Functor f => (a -> b) -> f a -> f b" (or, specialised for IO: "fmap :: (a -> b) -> IO a -> IO b")
03:27:02 <Spockz> mm_freak: Being it a composition, a &&& or whatever other construct. The idea is that you can set the input and then the calculation is run from the input
03:27:06 <merijn> matthiasgorgens: Share an MVar between the PromptMonad and the callback and use that to block until something happens?
03:27:07 <mm_freak> Spockz: try to explain it without haskell terms
03:27:12 <mm_freak> Spockz: i.e. explain your application
03:27:34 <t7> shachaf: im not sure thats valid...
03:27:54 <shachaf> t7: Who're you calling invalid?
03:27:55 <Spockz> mm_freak: So I have a computation, modeled so I can inspect it. install creates from this model a graph or network of variables
03:27:56 <merijn> asante: Did all that make sense?
03:28:01 <shachaf> Saizan: Can you do ∀x.P(x) == ¬∃x.¬P(x) as well?
03:28:07 * shachaf is so tired. :-(
03:28:21 <Spockz> mm_freak: with on the edges the update functions
03:28:23 <asante> merijn: yes
03:28:35 <asante> but i'll take some time to understand that, i guess^^
03:28:49 <mm_freak> Spockz: what's the purpose?  sounds like you want to calculate dependency graphs
03:29:00 <Spockz> mm_freak: so you push in a value in the front, and then it is carried by the functions to the end.
03:29:04 <Spockz> mm_freak: incrementality
03:29:19 <mm_freak> Spockz: of what?
03:29:28 <Spockz> mm_freak: of the calculation you describe in the model
03:29:29 <merijn> asante: ok :) Just try playing with the clues I gave you and if you get stuck after awhile you can always ask for more hints
03:29:47 <mm_freak> Spockz: let me ask differently, what would you use it for?
03:30:47 <astry_> @hoogle getArgs
03:30:48 <lambdabot> System.Environment getArgs :: IO [String]
03:30:48 <lambdabot> Graphics.UI.GLUT.Initialization getArgsAndInitialize :: IO (String, [String])
03:30:59 <Spockz> mm_freak: to construct applications that have values depending on inputs and computations in between, and you don't want to re-run the computations yourself each time and want that changes in the update cause as little of update steps along the line
03:31:44 <matthiasgorgens> merijn: I wonder how you can use an MVar in the Prompted monad, since it's explicetely not IO.
03:31:56 <matthiasgorgens> merijn: otherwise I'd set up the inotify directly in the prompted monad.
03:32:09 <Spockz> mm_freak: basically if the input changes the output might change, but it depends on a lot of little steps in between. But maybe somewhere along this line you do end up with the same value and thus you don't need to continue from there. As everything that will come after will be the same any way
03:32:26 <mm_freak> Spockz: ok, i get it now…  how about:  newtype Cache a b = Cache (Bool -> a -> (b, Cache a b))
03:32:46 <merijn> matthiasgorgens: If you can't use IO then maybe something using STM? Though I'm not sure you can avoid IO
03:32:47 <mm_freak> Spockz: i assume you also have some IO in there
03:33:01 <merijn> matthiasgorgens: Because a pure value depending on some IO event doesn't make sense
03:33:04 <mm_freak> (because otherwise haskell's lazy evaluation already takes care of that)
03:33:15 <Saizan> shachaf: you can go from (forall a. P a) to forall r. (exists a. (P a -> r)) -> r, i don't think you can the other way around
03:33:20 <mm_freak> so let's extend that to:  newtype Cache m a b = Cache (Bool -> a -> m (b, Cache a b))
03:33:25 <mm_freak> well, almost
03:33:29 <mm_freak> so let's extend that to:  newtype Cache m a b = Cache (Bool -> a -> m (b, Bool, Cache a b))
03:33:43 <Spockz> mm_freak: yes because I update IORefs, that's only reason why I use IO (and debugging now)
03:34:14 <mm_freak> are you using IORefs for the purpose of caching or is the computation you want to cache actually using IORefs for its algorithm?
03:34:32 <matthiasgorgens> merijn: I can't use IO in the prompted monad.  that defeats the purpose.  but I just realized that I can start a second run of the prompted monad.  (that probably works as far as i can see, but I am not entirely sure, if that's the Right Thing, yet.)
03:34:41 <shachaf> Saizan: Oh. The usual constructivism thing, isn't it. :-(
03:34:49 <Spockz> mm_freak: the first, but not for caching but because you *change* the input
03:35:06 <Saizan> shachaf: yeah
03:35:06 <mm_freak> Spockz: you can represent that by a pure function, if the algorithm is pure
03:35:10 <shachaf> Saizan++ # like, knowing things, man
03:35:18 <matthiasgorgens> merijn: the prompted monad is basically the free monad over some finite set of generators.
03:35:20 <Saizan> :)
03:35:29 <matthiasgorgens> and we run it with an interpreter.
03:35:29 * shachaf must go to sleep before dying of lack of sleep.
03:35:49 <Saizan> shachaf++ # not dying
03:36:09 <Spockz> mm_freak: do you maybe have some additional material on that?
03:36:40 <asante> merijn: i'll work on it. thanks!
03:37:34 <matthiasgorgens> Saizan: what do you want to concatenate shachaf with?
03:37:50 <mm_freak> Spockz: i'm writing it
03:38:22 <matthiasgorgens> or did you mean: modifyMVar_ shachaf (return . (1+))  ?
03:39:37 <Saizan> we should use lenses
03:39:37 <Spockz> mm_freak: the intended use is ` f = do { (input, output) <- install' some_model; set input 400; val <- get output; etc. } and then you can link the output to something you want to update
03:40:17 <mm_freak> Spockz: before i continue, are you sure coroutines wouldn't solve your problem?
03:40:46 <Spockz> mm_freak: I am not really sure
03:40:58 <mm_freak> a coroutine can report back and ask for further data, before it continues
03:42:21 <shachaf> Oh.
03:42:32 <mm_freak> Spockz: or perhaps explain an actual practical application…  i have difficulty coming up with an actual use case in haskell
03:43:20 <Spockz> mm_freak: my first goal was to incrementalise list sort, or a non-recursive computation inside an Arrow
03:43:48 <mm_freak> Spockz: how would the former work?
03:44:29 <Spockz> mm_freak: however the ultimate use case would be to update things on a GUI from given input field or in whatever way you would desire it. Say display a grid of data depending on some input fields
03:44:59 <mm_freak> i see
03:45:27 <Spockz> mm_freak: in the same way as Acar did, so suppose you change the list a bit, adding a number to the head. You don't want to sort the whole list again if it is not necessary but re-use elements from your previous computation
03:45:42 <mm_freak> then it's interesting for me, too
03:45:54 <Spockz> mm_freak: additionally I would like it work as well if you would change the value of one of the list-items
03:45:57 <mm_freak> but i'll have to think about it some more later…  i'm off for now
03:46:05 <Spockz> ok thank you mm_freak :)
03:46:15 <Spockz> mm_freak: could I read what you wrote down in the mean time?
03:46:34 <mm_freak> newtype Cache a b = Cache ((a, Bool) -> ((b, Bool), Cache a b))
03:46:41 <mm_freak> with the obvious Category instance
03:46:53 <mm_freak> it's just the automaton arrow with an additional "hasChanged" value
03:47:23 <mm_freak> i thought about something similar for netwire, but gave it up and decided to integrate it into the corresponding GUI wrapper instead
04:02:03 <merijn> Right now I have "type Foo a = StateT a IO ()", I don't suppose there's a way to define this as "type Foo a = MonadIO m => StateT a m ()" without having m also show up on the left hand side?
04:02:50 <byorgey> merijn: correct.
04:03:07 <merijn> Bollocks :\
04:03:17 <byorgey> merijn: if you made it into a newtype you could existentially quantify over the m.  But then it would be useless because you couldn't sequence two actions of type Foo a
04:03:25 <byorgey> because there would be no guarantee that the m's are the same
04:04:03 <merijn> Time to rethink some of my design...
04:04:05 <shachaf> newtypes don't let you existentially quantify, do they?
04:04:12 <merijn> shachaf: They do
04:04:21 <shachaf> With class constraints?
04:04:43 <shachaf> "A newtype constructor cannot have an existential context, but `Foo' does"
04:07:38 <astry> hi
04:08:35 <astry> how do i read an IORef here? when i uncomment the line, the program doesn't typecheck anymore: http://dpaste.com/803498/
04:09:24 <astry> i'm sure someone knows :)
04:09:27 <merijn> astry: Hard to tell, I don't know the type of handleKey?
04:09:32 <fmap> liftIO ?
04:09:44 <merijn> But probably liftIO, yes
04:10:05 <astry> the type error is:
04:10:21 <astry> Couldn't match expected type `Control.Monad.Trans.Reader.ReaderT
04:10:21 <astry>                                     (GHC.Ptr.Ptr any0) IO t0'
04:10:22 <astry>                 with actual type `IO a0'
04:10:33 <astry> let me try liftIO then
04:10:33 <Botje> yes, that sounds like liftIO would help.
04:10:42 <astry> why do you think liftIO would help?
04:10:47 <junis> greetings fine people ....
04:10:48 <astry> i'm not sure how to figure this out on my own
04:10:49 <Botje> (liftIO wraps the IO thing in a ReaderT
04:11:00 <Botje> :t liftIO
04:11:01 <lambdabot> forall a (m :: * -> *). (MonadIO m) => IO a -> m a
04:11:01 <JuanDaugherty> yello junis
04:11:05 <merijn> astry: "readIORef has type "IO a" as result
04:11:21 <junis> Prelude tells me     Failed to load interface for `Char'
04:11:21 <junis>     It is a member of the hidden package `haskell98-2.0.0.1'.
04:11:29 <merijn> astry: However, your do block appears to be inside "ReaderT r IO x" i.e., a reader wrapper around IO
04:11:32 <Botje> junis: use Data.Char instead.
04:11:40 <junis> thank you Botje
04:11:42 <Botje> junis: almost all definitions from Char were moved into Data.Char
04:12:38 <merijn> astry: Since ReaderT is a monad transformer and "ReaderT r IO" is an instance of MonadIO, liftIO ends up being "liftIO :: IO a -> ReaderT x IO a"
04:13:14 <merijn> astry: i.e. liftIO "lifts" the readIORef into the proper monad
04:16:36 <astry> mhm
04:17:58 <astry> i'm currently using IORef's. Is there some better way to keep state around? What would you guys say?
04:18:13 <astry> I heard IORef's aren't the best things to use
04:18:16 <Automorphism> Are there any frontends for Cabal-1.16?
04:19:43 <ivanm> Automorphism: by "front-ends" you mean cabal-install, etc.?
04:19:50 <ivanm> seeing as how it just got officially released, I doubt it
04:20:13 <merijn> astry: The StateT monad?
04:20:32 <astry> merijn: how would you use StateT there?
04:20:43 <astry> let me upload the latest working code
04:20:45 <astry> 1 sec
04:20:46 <mikeplus64> how can one 'reopen' a handle? namely, i want to call getContents more than once
04:21:18 <merijn> astry: tbh I haven't really looked in depth at your code, let me see if it makes sense when you update the new code
04:21:38 <ivanm> mikeplus64: then use something better than getContents?
04:21:47 <ivanm> getContents is meant to get _all_ of the contents
04:21:53 <ivanm> so there shouldn't be anything else to get
04:21:54 <astry> merijn: http://dpaste.com/803513/
04:21:58 <astry> it's really simple
04:22:03 <ivanm> (though laziness might mean you didn't let it finish getting everything)
04:22:09 <mikeplus64> ivanm: OK
04:22:34 <astry> merijn: it displays a window with a button. when I press "a", it displays a variable then increments it
04:23:56 <Automorphism> astry: Inside main (or wherever you do the heavy lifting), call runStateT. You will be in a StateT monad transformer stacked on top of IO.
04:23:58 <merijn> Normally I debug people's code here without having a clue as to what it does xD
04:24:14 <astry> Automorphism: i don't understand the part after "You".
04:24:29 <astry> merijn: is it bad if you do know
04:24:41 <astry> have i imposed the burden of knowledge
04:24:56 <merijn> astry: Naah, I just need to look up the types of the functions you're using, as I haven't used gtk before :p
04:25:02 <Automorphism> astry: I think there is a tutorial on monad transformers in the Haskell Wiki.
04:25:24 <astry> right..
04:26:45 <merijn> I don't suppose you know where G.on is defined?
04:27:34 <astry> hmm
04:27:42 <astry> no i actually haven't found it
04:27:43 <astry> wait
04:27:46 <astry> i think it's in EventM
04:28:25 <astry> hmm no
04:28:33 <astry> @hoogle on
04:28:33 <lambdabot> Data.Function on :: (b -> b -> c) -> (a -> b) -> a -> a -> c
04:28:34 <lambdabot> Control.Exception.Base onException :: IO a -> IO b -> IO a
04:28:34 <lambdabot> Control.Exception onException :: IO a -> IO b -> IO a
04:28:38 <astry> nope
04:30:42 <astry> on is defined in Graphics.Ui.Gtk
04:30:44 <astry> according to the index
04:31:01 <Daneo> Would it be doable performing a home-made DES ecnryption ?
04:31:06 <Daneo> in Haskell
04:31:16 <merijn> That's where it is exported from, but it's not listed in the Haddock documentation
04:31:25 <merijn> astry: Can you check in GHCi what it's type is?
04:31:36 <merijn> Because it is hard for me to comment without knowing what it does :p
04:31:46 <astry> merijn:
04:31:51 <astry> on :: object -> Signal object callback -> callback -> IO (ConnectId object)
04:32:33 <merijn> ah, bingo
04:32:34 <fmap> Daneo: sure
04:33:00 <Ferdirand> stupid general knowledge question: was the usage of (->) to denote both function types and logical implication established after the Curry-Howard discovery, or was it just a beautiful coincidence ?
04:33:18 <Daneo> fmap: Would it ? I'm not sure how, but thats just lack of knowledge about Haskell.
04:33:47 <Daneo> But as it is more a math- style language I thought of Haskell as a candidate in that subject, to write our own version of the algorithm
04:34:00 <astry> Daneo: Haskell contains all the logical operators to run a full turing-complete computer
04:34:25 <astry> you're really getting a lot here
04:34:52 <t7> Daneo:  i implemented eliptic curve crypto in haskell recently
04:35:02 <t7> elliptic *
04:35:41 <t7> Astry would you rather write code in lambda calculus or brainfuck?
04:36:06 <astry> lambda brainfuckulus
04:36:32 <merijn> I am annoyed by GTK's documentation...
04:36:33 <t7> sounds kinky
04:36:49 <astry> merijn: hmm, what are you missing?
04:36:51 <astry> maybe i can help
04:37:01 <astry> i've been staring at it all day long without fruition :DDD
04:37:19 * hackagebot unix-compat 0.4.0.0 - Portable POSIX-compatibility layer.  http://hackage.haskell.org/package/unix-compat-0.4.0.0 (JacobStanley)
04:37:35 <merijn> astry: Well, I want to know the type of callback, but I can't find the definition of "G.keyPressEvent"
04:38:13 <astry> merijn: http://hackage.haskell.org/packages/archive/gtk/0.12.0/doc/html/doc-index-All.html
04:38:16 <astry> :)
04:38:23 <astry> http://hackage.haskell.org/packages/archive/gtk/0.12.0/doc/html/Graphics-UI-Gtk-Abstract-Widget.html#v:keyPressEvent
04:38:46 <fmap> Daneo: yes; if you encounter specific problems feel free to ask here
04:39:59 <Daneo> t7: Hadn't even heard of it.
04:40:02 <astry> merijn: i guess this is newer: http://hackage.haskell.org/packages/archive/gtk/0.12.3.1/doc/html/doc-index-All.html
04:40:34 <Daneo> fmap: Ok, thanks. Lets first follow the course about how it stenography works first :) Thanks in advance.
04:40:49 <merijn> astry: Ok, and you want to maintain state between keypresses, I guess?
04:41:14 <astry> merijn: yeah
04:41:26 <astry> merijn: every time i press "a", i should get a higher number
04:42:02 <merijn> astry: Actually, I don't think there's a much easier way to do that, other than MVar's/IORef's, but I think the way you use it can be considerably simplified
04:42:17 <astry> in what way can it be simplified?
04:42:34 <astry> whale techno... that's gotta be like 0.0000000000000000001 bpm
04:43:43 <whaletechno> astry: http://www.youtube.com/watch?v=L2fGQE9Kh44
04:44:53 <hpaste> merijn pasted “Nicer handleKey” at http://hpaste.org/74997
04:45:05 <merijn> astry: Like that
04:45:18 <merijn> astry: That way you don't need to lift every individual action
04:45:26 <merijn> (also "print = putStrLn . show"
04:46:04 <astry> merijn: i was wondering how to extract liftIO..
04:46:11 <astry> thanks
04:48:24 <fmap> and `readIORef … >> writeIORef …' can be merged into `atomicModifyIORef'
04:48:56 <astry> mhm
04:49:16 <astry> how can i get new_position under the liftIO do block?
04:50:42 <merijn> astry: Return in it in the do block and then add "newPos <-" in front of liftIO
04:51:15 <astry> oh
04:51:18 <astry> yeah of course
04:51:43 <ski> Ferdirand : i suspect the latter
05:00:39 <ksf> do we have a parsing lib specialised to returning token-lists? I'm not speaking about a lexer, but parser.
05:00:55 <sithisbitch> parsec
05:01:02 <ksf> (the token type I want is context-sensitive)
05:01:03 <sithisbitch> lexing and parsing are the same thing
05:01:46 <ksf> parsec doesn't return a token stream
05:01:54 <sithisbitch> you can
05:02:03 <sithisbitch> parsec return what you want
05:02:06 <ksf> yes, but not online...
05:02:18 <asante> merijn: i found a solution in [haskell-cafe] but without using fmap
05:02:21 <hpaste> asante annotated “recursive number input” with “recursive number input (annotation) (annotation)” at http://hpaste.org/74990#a74999
05:02:47 <ksf> secondly, I'd like the same parser to return a traditional applicatively-constructed result, because I need both.
05:03:00 <asante> this one runs, but i'd like to know the solution you had in mind
05:04:33 <junis> greetings fine people ... how do i concat (++)  two values of type  Maybe [Char] ?
05:04:57 <Lemmih> junis: How do you want it to behave?
05:05:04 <zhulikas> fmap mconcat val ?
05:05:04 <ion> junis: (<>)
05:05:39 <zhulikas> :t (<>)
05:05:40 <lambdabot> Doc -> Doc -> Doc
05:06:10 <junis> Lemmih: i want it to return Nothing if any of the two operands is Nothing
05:06:38 <ion> liftA2 (++)
05:07:31 <astry> merijn: thanks a lot, that helped me out nicely :)
05:10:14 <astry> hmm..
05:10:16 <astry> http://hackage.haskell.org/package/toilet
05:10:35 <Trudko> Guys in haskell not False is same as !false in other languages?
05:11:26 <bartavelle> I am unsure on how to get the "Result" from aeson, the only function I know how to run is decode
05:11:39 * ksf is thinking too complicated. a position-annotated ast should suffice
05:11:47 <fmap> > not False
05:11:48 <lambdabot>   True
05:12:31 <merijn> asante: The solution I was thinking of using fmap was "fmap (x:) getIntsTillZero"
05:12:57 <bartavelle> I can't rewrite this function as it uses non exported function itself
05:13:11 <bartavelle> how can I get the failure message from aeson instead of "Nothing" ?
05:13:44 <merijn> asante: Where "(x:) :: [Int] -> [Int]" and "fmap (x:) :: Functor f => f [Int] -> f [Int]" (specialised for IO: "fmap (x:) :: IO [Int] -> IO [Int]"
05:14:18 <merijn> Trudko: Correct
05:14:21 <asante> ok, i tried something like that, but think i had a return to much
05:14:33 <merijn> asante: The fmap removes the need for return
05:14:52 <ion> astry: Eh :-D
05:14:55 <Spockz> did someone here make implementations of RCategory and RArrow analogous to RMonad?
05:15:13 <asante> merijn: yes. thanks again!
05:17:38 <fmap> well, in python 2.* "not False" can be anything
05:18:12 <fmap> so question doesn't seem correct
05:18:18 <Trudko> I am learning learn you a haskeel and it says that * is function and normally I am used that * is referenced as operator
05:18:52 <Nereid> Trudko: a * b is the same as (*) a b
05:18:57 <Nereid> syntactic sugar
05:19:05 <simon> Ralith, re. emacs and no-latency across networks: I've tried working with ftp/ssh-based filesystems and simply editing them. this reduces the latency to file operations only, but I must admit I prefer to simply edit files on the server... I can't defend that preference though. ;-)
05:19:07 <parcs`> Trudko: in haskell you can define your own operators
05:19:21 <Nereid> in haskell, operators are functions.
05:19:42 <simon> in haskell, `functions` are also operators. :P
05:20:12 <Trudko> wait simon :D how can be *(operator) function  and funciton operator at same time :)
05:20:37 <simon> Trudko, I don't understand.
05:21:17 <simon> Trudko, what I meant was that if foo is a function, then foo x y = x `foo` y (syntactic sugar for infixing regular functions)
05:22:09 <Trudko> simon: ok i get it as parcs` said you can define your own operators
05:22:35 <Trudko> and out of courisity how is it then in other language like java? operator is well ....just operator :)
05:25:40 <simon> Trudko, in Python, you can make operators like + work on your own kind of objects if you define methods like __add__ for them.
05:26:04 <Trudko> simon: possible not sure about Python dont work with that, I work with java and javascript
05:26:04 <donri> (but + is still special syntax in python, with a fixed fixity (hah))
05:26:58 <simon> yeah, + isn't a value in Python. I suppose equal rights is a good reason to choose functional languages. :)
05:27:05 <donri> > let (%&?) = (*) in 5 %&? 5
05:27:06 <lambdabot>   25
05:28:04 <mux> is there a way to convert from/to network byte order in the standard libs or in some other package you would recommend?
05:28:22 <donri> mux: possibly binary/cereal
05:29:03 <mroman> Is there a monad relative with m a -> (a -> m a) -> m a?
05:29:29 <merijn> mroman: That just looks like >>=?
05:29:40 <mroman> Yeah.
05:29:59 <shapr> In Soviet Haskell, operator defines you!
05:30:00 <merijn> What's your question, then?
05:30:16 <mroman> When I want to define a Monad
05:30:24 <timemage> mux, there seems to be a System.ByteOrder package.    what little reordering i've had to do in haskell i just did manually.
05:30:25 <mroman> I always get stuck at m a -> (a -> m b) -> m b
05:30:37 <mroman> but it would work with m a -> (a -> m a) -> m a
05:30:48 <mux> timemage: I found several packages providing such functionality, I'm looking for a "blessed" one if you see what I mean
05:30:56 <mroman> or to be put in better terms: When I want to make somethin instance of Monad.
05:32:10 <donri> mroman: might help to define bind in terms of fmap and join
05:32:15 <donri> @where typeclassopedia
05:32:15 <lambdabot> http://www.haskell.org/haskellwiki/Typeclassopedia
05:32:15 <parcs`> mroman: you are probably defining the instance incorrectly, or the thing is not a monad
05:32:21 <donri> do them exercises
05:32:38 <mroman> parcs`: Yes.
05:32:42 <mroman> But what is it then?
05:32:53 <mroman> Is there a construct with m a -> (a -> m a) -> m a?
05:33:14 <Trudko> > div 92 10
05:33:15 <lambdabot>   9
05:33:20 <Trudko> > 92 div 10
05:33:21 <lambdabot>   92
05:33:43 <parcs`> @hoogle m a -> (a -> m a) -> m a
05:33:44 <lambdabot> Prelude (>>=) :: Monad m => m a -> (a -> m b) -> m b
05:33:44 <lambdabot> Control.Monad (>>=) :: Monad m => m a -> (a -> m b) -> m b
05:33:44 <lambdabot> Control.Monad.Instances (>>=) :: Monad m => m a -> (a -> m b) -> m b
05:33:46 <Trudko> > 92 'div'10
05:33:47 <lambdabot>   <no location info>:
05:33:47 <lambdabot>      lexical error in string/character literal at chara...
05:34:00 <Spockz> @i Constraint
05:34:00 <lambdabot> Maybe you meant: id ignore index instances instances-importing irc-connect . ? @ v
05:34:07 <Trudko> what am I doing here wrong?  -> So we can call it as an infix function by doing 92 `div` 10 and suddenly it's much clearer.
05:34:09 <Spockz> @hoogle Constraint
05:34:09 <lambdabot> No results found
05:34:43 <mikeplus64> > 92 `div` 10 -- Trudko ?
05:34:44 <lambdabot>   9
05:34:47 <ion> > 92 odd or otherwise "hello" even
05:34:48 <lambdabot>   92
05:35:20 <mikeplus64> > 0 "oh" "god" "what"
05:35:21 <lambdabot>   0
05:35:37 <mikeplus64> :t \x -> 0 x
05:35:38 <lambdabot> forall t t1. (Num (t -> t1)) => t -> t1
05:35:46 <Trudko> 92 `div` 10
05:35:50 <Trudko> >92 `div` 10
05:35:56 <Trudko> > 92 `div` 10
05:35:57 <lambdabot>   9
05:36:03 <ion> >  92 `div` 10
05:36:04 <lambdabot>   9
05:36:05 <ion> >   92 `div` 10
05:36:06 <lambdabot>   9
05:36:11 <Trudko> ou I did not use `
05:36:11 <Spockz> where can I find the Constraint type? I added the ConstraintKinds pragma
05:36:27 <astry> hey guys what package should i use for command line args? cmdline, cmdtheline, or options?
05:36:32 <donri> GHC.Exts IIRC?
05:37:03 <donri> Spockz: GHC.Prim
05:37:04 <mikeplus64> Spockz: it's the kind of typeclass constraints, does it have a type?
05:37:10 <mikeplus64> nevermind donri is smarter
05:37:12 <donri> ghc-prim package
05:37:21 <Trudko> > 92 'div' 10
05:37:21 <lambdabot>   <no location info>:
05:37:22 <lambdabot>      lexical error in string/character literal at chara...
05:37:32 <Trudko> btw stupid question but what do you call ` in english?
05:37:38 <astry> prime
05:37:40 <mikeplus64> Trudko: backtick
05:37:52 <astry> back-tick is right too, yes
05:37:54 <mikeplus64> i don't think ` is english
05:38:18 <astry> it is, given that it was used by newton..
05:38:34 <Trudko> ok thx dont use that much
05:38:52 <astry> i wish the names in haskell could have hyphens
05:38:59 <astry> that would be like the number one helpful addition
05:39:01 <donri> astry: agda!
05:39:29 <astry> another god damn agda
05:39:36 <astry> recurnym
05:39:46 <mikeplus64> astry: what would let foo-bar = 0; foo = 1; bar = 2 in foo-bar be ?
05:39:54 <mikeplus64> i mean would ghc prefer foo - bar or foo-bar
05:40:07 <astry> mikeplus64: for me, it would be 0.
05:40:31 <donri> mikeplus64: I think Constraint is a data type that is promoted to the kind-level
05:40:31 <astry> that's what it means hyphens can be part of names.
05:41:00 <alpounet> astry, or it redefines the - operator
05:42:51 <nand`> hmm; JuicyPixels 2.0 reads ‘Built on: ghc-7.6’ but building on GHC 7.6.1 fails for me, with a dependency on bytestring. There's a fix on the git version, but it's not on hackage yet. How does that compute?
05:43:03 <mikeplus64> maybe instead we can have foo―bar instead of foo-bar (i'll show myself out)
05:54:28 <fmap> maybe there was ghc 7.6 with bytestring < 0.10
05:55:28 <fmap> hmm, it's uploaded on 16 of september
06:00:21 <nand`> right now, it would be super useful to have Codec.Picture.Lens for juicypixels
06:00:32 <nand`> I want a traversal from PixelRGBA8 to PixelRGB8 :)
06:02:32 <fmap> are there build logs for successful builds on hackage?
06:03:26 <fmap> there are
06:04:45 <fmap> nand`: seems there is local bytestring-0.9.2.1 package with dependency on base-4.6.0.0 on hackage
06:06:47 <t7> :t \(x :: forall x. x -> x) -> x x
06:06:48 <lambdabot> forall x. (forall x1. x1 -> x1) -> x -> x
06:07:45 <t7> > take 3 $ (\(x :: forall x. x -> x) -> x x) ("hi "++)
06:07:46 <lambdabot>   Couldn't match expected type `[a]' against inferred type `x -> x'
06:08:22 <fmap> or that's not what's going on
06:08:32 <t7> infinite types plox
06:15:11 <nand`> hmm; is there some image library that would make it easy to get something like [[Color]]? JuicyPixels seems to be relatively simple but it has two complications: 1. its DynamicImage type which forces me to do all necessary conversions by hand and 2. It uses an (Int, Int, Vector Word8) which makes the logic to extract the individual pixels a bit roundabout; I'd probably have to use the helper functions
06:15:13 <nand`> (pixelAt) to construct the lists
06:18:24 <tdammers> maybe I'm being naive here, but wouldn't [[Color]] produce something like a 100% memory overhead?
06:20:27 <flux> what's 100% memory overhead among friends?
06:22:29 <nand`> tdammers: all of my operations on the image are whole-image operations based on zips, drops and maps
06:22:36 <nand`> which is why lists are ideal
06:22:44 <nand`> or list-like structures
06:22:49 <tdammers> I see
06:22:57 <tdammers> I guess most applications aren't like that though
06:23:14 <tdammers> which probably means they'd keep the whole evaluated list-of-lists n memory
06:23:21 <tdammers> s/n/in/
06:23:24 <tdammers> at some point
06:23:36 <nand`> efficiency is not too great of a concern
06:33:50 <nand`> @hoogle Either String a -> a
06:33:51 <lambdabot> No results found
06:39:11 <hiptobecubic> @hoogle () -> ()
06:39:12 <lambdabot> Control.Parallel.Strategies (>|) :: Done -> Done -> Done
06:39:12 <lambdabot> Control.Parallel.Strategies (>||) :: Done -> Done -> Done
06:39:12 <lambdabot> Control.DeepSeq force :: NFData a => a -> a
06:39:32 <hiptobecubic> huh... i assumed no one would bother with a such a function
06:41:42 <EvanR> is it safe to assume that a 'parser' implies that the input is a stream of something
06:42:06 <EvanR> not for instance, a grid, or something else
06:42:26 <EvanR> terminology question
06:42:40 <hiptobecubic> you mean some kind of sequential data?
06:42:43 <sithisbitch> it's excalty that
06:42:47 <EvanR> ok
06:43:02 <sithisbitch> a parser/lexer is something which take an input stream and produce something
06:43:09 <sipa> i'd say a parser is something to find structure in unstructured data
06:43:19 <sipa> a grid would already be somewhat structured
06:43:23 <sithisbitch> usually a lexer produce a stream of token for the parser wich produce an expression
06:43:45 <EvanR> a list or stream is 'not as structured' ?
06:43:49 <hiptobecubic> i finally understood that yesterday
06:44:08 <hiptobecubic> the roles of lexing and parsing i mean
06:44:23 <EvanR> for the same of my question lexing and parsing are the same thing
06:44:25 <EvanR> sake*
06:44:49 <fmap> so, say, befunge parsers are not parsers if they parse befunge not as a list of commands?
06:46:13 <EvanR> it seems that all the work has been done on input streams, but im wondering if any of parsing tech applies to input grids or something else
06:47:08 <tgeeky> EvanR: ah, that reminds me of my ideas/attempts; no
06:47:22 * hackagebot idris 0.9.3.1 - Functional Programming Language with Dependent Types  http://hackage.haskell.org/package/idris-0.9.3.1 (EdwinBrady)
06:47:59 <tgeeky> EvanR: well, I haven't reviewed the literature, but I don't think there are any parsers or pretty printers that treat the data as anything other than 1 dimensional
06:48:10 <tgeeky> as packages on hackage
06:48:26 <EvanR> 1 dimensional and 'streamy' like youd rather not have to go back and forth
06:48:37 <EvanR> and you probably cant jump to the end of the input
06:48:57 <tgeeky> well, I consider the 1 dimensional part to be a more serious limitation
06:49:31 <EvanR> im not sure dimensionality is a thing i know about with respect to data
06:49:36 <tgeeky> there is 'mpppc' which is OK, but it's just for pretty printing
06:51:05 <tgeeky> by dimensionality, I mean something like 'chunking' or something
06:51:31 <EvanR> hmm
06:51:33 <tgeeky> a haskell file with 30 blocks of code/functions/comments.
06:51:48 <tgeeky> a regular parser just starts at some char position, and goes in a single direction
06:51:55 <tgeeky> and may do fancier things still
06:52:21 <tdammers> thing is, computer memory is a linear space on practically all architectures
06:52:22 * hackagebot adict 0.1.0 - Approximate dictionary searching  http://hackage.haskell.org/package/adict-0.1.0 (JakubWaszczuk)
06:52:23 <EvanR> thats how all the languages are structured
06:52:43 <EvanR> except those funny esoterics
06:52:48 <wumpus> I've seen stuff about two-dimensional parsers in the context of screen scraping / image recognition
06:52:48 <hvr> ...adict :-)
06:52:49 <tgeeky> you could take for granted the successful parse of the outer wrapper of the document (the import statements, pragmas, module decl, etc...)
06:52:56 <tdammers> any n-dimensional data structures need to be folded into one dimension for storage anyway
06:53:03 <EvanR> wumpus: ahhhhh
06:53:44 <hiptobecubic> yes i think the problem is that you are automatically associating parsing with text, which *is* a 1D stream
06:53:54 <EvanR> tdammers: still im not sure any n besides 1 makes sense in haskell
06:53:56 <tgeeky> no it's not a 1D stream
06:54:21 <tgeeky> so, for example:
06:54:26 <EvanR> hiptobecubic: nah im not thinking of text, could be bytes, or bits
06:54:31 <EvanR> or tokens
06:54:44 <EvanR> or in wumpus's case, colors
06:54:47 <tdammers> text isn't one-dimensional, but you have to fold it into one dimension when storing it in a file, because files are 1F
06:54:51 <tdammers> s/1F/1D/
06:54:53 <tgeeky> imagine i've elided the top and bottom parts of the document, so I might be left with 30 blocks of code seperated by some thing (\n\n\n\n\n\n or somesuch)
06:55:32 <tgeeky> there are two function definitions which are nearby each other in the file (that is, one after the other, or one before the other)
06:56:10 <tgeeky> and their paramters (the function has 10, eww!) are nicely indented, aligned, and whitespaced
07:01:11 <nand`> Has work been done in Haskell on interpolation of image data? I imagine this would be easily modeled as a comonad, with the filter kernel simply being a function that takes the cursor and mixes in its environment according to whatever function
07:01:39 <edwardk> nand`: there has been work on doing blurring, etc using comonadic blur kernels
07:01:52 <edwardk> but i don't think there has been work on interpolation per se
07:02:05 <edwardk> you should be able to do it by building the ComonadApply instance for images
07:02:35 <hiptobecubic> just when i started feeling comfortable with monads, people started talking about comonads
07:03:52 <EvanR> haha
07:04:02 <tgeeky> EvanR: folding the file down to 1 dimension might lose the fact that, for instance, two function definitions which are nearby have identical indentation hints ; but they are freely reorderable
07:04:08 <Adeon> perhaps in time we'll have 1000 comonad tutorials as well
07:04:17 <edwardk> Adeon: probably
07:04:17 <nand`> comonad cotutorials
07:04:24 <alpounet> hiptobecubic, it will continue up to Kan Extensions
07:04:26 <EvanR> tgeeky: right
07:04:34 <edwardk> cotutorials: you must unlearn all you think you know about comonads
07:04:46 <EvanR> Adeon: until then, all i know is that comonads are like nightclubs
07:05:01 <edwardk> EvanR: thats a pretty good analogy actually
07:05:02 <tgeeky> that is, you could make it so the two function blocks weren't one after another .. in my case, often for as trivial of reasons as I want to reorder blocks of type definitions or something
07:05:25 <edwardk> some times you need to leave the nightclub and go home, but its a much more interesting to be inside it.
07:05:34 <EvanR> haha
07:05:49 <nand`> ‘extend’
07:05:59 <EvanR> but you cant get in whenever you want
07:06:01 <EvanR> ?
07:06:05 <EvanR> or however you want
07:06:06 <ciaranm> a comonad is just a comonoid in the category of endofunctors. what's the coproblem?
07:06:09 <ciaranm> or something
07:06:21 <tgeeky> hehe
07:06:23 <nand`> if a monad is a lax 2-functor from a terminal bicategory, what does that make a comonad?
07:06:35 <EvanR> haha
07:06:44 <edwardk> ask dolio =P
07:06:58 <tgeeky> nand`: first shot: a cheeseburger
07:07:12 <typoclass> @remember ciaranm a comonad is just a comonoid in the category of endofunctors. what's the coproblem?
07:07:12 <lambdabot> Good to know.
07:07:13 <edwardk> the moment you start throwing 2-categories around my brain shuts off
07:07:25 <tgeeky> edwardk: ah! that's disappointing
07:07:32 <edwardk> i mean i understand the basics of them
07:07:34 <ciaranm> infinity-categories are fun!
07:07:34 <tgeeky> did you ever read that intro chapter that Baez wrote?
07:07:45 <tgeeky> the prehistory of n-category theory
07:07:48 <edwardk> but i just get mired in bicategories vs 2-categories, etc.
07:07:49 <tgeeky> in the front of deep beauty
07:08:11 <tgeeky> oh, I don't appreciate that there was a difference
07:08:15 <tgeeky> s/was/is/
07:08:15 <edwardk> too many notions of equivalence start popping up in n-categories for my taste
07:08:39 <edwardk> which means you spend a lot of time saying what framework it is that you are saying something, rather than saying something
07:08:49 <edwardk> er that you are saying something in
07:09:07 <tgeeky> there's a table of "features" you pick up
07:09:14 <tgeeky> that Baez et al are famous for
07:09:23 <edwardk> sure
07:09:26 <edwardk> its neat
07:09:34 <edwardk> i just don't find it terribly productive =)
07:09:49 <tgeeky> I assumed that if you were to try to do something like that in haskell, you'd do it "once and for all" at some higher number d
07:09:51 <edwardk> i have enough trouble getting people to grok kan extensions =P
07:10:00 <tgeeky> haha
07:10:02 <tgeeky> like 10
07:10:28 <nand`> I have no idea what a kan extension really ‘is’, but I know how to apply Codensity. Is that enough?
07:10:38 <edwardk> nah the haskell solution would be to just work with omega-categories only
07:10:53 <edwardk> nand`: its a solid start =)
07:11:17 <nand`> and by ‘apply’ I mean ‘wrap free monad in codensity, things go vroom’
07:12:04 <edwardk> =)
07:12:23 <edwardk> i do wish i'd come up with a better name for that monad when i started pushing it on the haskell community
07:12:45 <copumpkin> arrr
07:12:46 <edwardk> sadly the only older name for it is 'the monad generated by a functor'
07:13:07 <edwardk> and thats not ambiguous, no, not at all
07:16:09 <dfordivam> hello
07:16:37 <EvanR> can a comonad in some way be considered as a monad?
07:16:44 <sithisbitch> sometimes
07:16:56 <sithisbitch> Id a is a monad and a comonad
07:16:57 <sithisbitch> :)
07:17:09 <edwardk> EvanR: sure its a monad in the dual category
07:17:27 <EvanR> how does that apply to haskell
07:17:37 <edwardk> EvanR: and there are several monads and comonads that are somehow compatible and use the same type
07:17:47 <EvanR> interesting
07:17:50 <edwardk> (,) e    -- is a monad if e is a monoid, but its also a comonad.
07:17:57 <edwardk> extract (e,a) = a
07:18:10 <edwardk> extend f w@(e,_) = (e, f w)
07:18:23 <EvanR> riiiight, the same type has a monad instance and a comonad instance
07:18:44 <EvanR> but what i was asking was, given a working comonad, is there some relation to that thing in terms of monads
07:18:58 <edwardk> yes, but not in the way you'd expect
07:19:28 <edwardk> given any comonad I can give you a monad /transformer/
07:19:31 <dfordivam> I have a quick ques : If there is a Data Container type Con and I want to modify one of its field and return the new Con ( add :: Con -> Int -> Con), the rest of the Con I want to copy, what can be a short code to do that  ( I think I cannot do newCon = Con followed by ,myid newCon = inpId)
07:19:52 <edwardk> newtype Co w a = Co (forall r. w (a -> r) -> r)
07:19:59 <merijn> Man, my main problem with type level programming: The limited number of synonyms for Cons and Nil >.<
07:20:35 <EvanR> edwardk: ok
07:21:11 <edwardk> newtype CoT w m a = CoT (forall r. w (a -> m r) -> m r)
07:21:46 <edwardk> the theory behind it is a bit tortured. i derived it and posted it on my blog at some point, look for posts on how there are fewer comonads in haskell than monads
07:22:39 <dfordivam> anyone?? for a quick response to the ques
07:22:55 <EvanR> edwardk: interesting
07:23:03 <merijn> dfordivam: Did you define it using record syntax?
07:23:18 <edwardk> dfordivam: you can use record syntax or lense
07:23:20 <edwardk> er lenses
07:24:14 <edwardk> newCon = oldCon { myId = whatever }
07:24:51 <edwardk> or using lenses newCon = oldCon % myId .~ whatever
07:25:39 <merijn> Actually, rephrase: my *two* main problems with type programming: The limited number of synonyms for Cons/Nil and the need to find different names for map/fold/zip everytime >.>
07:26:53 <dfordivam> yup lenses might be the thing i was looking for
07:27:47 <astry> @hoogle getArgs
07:27:47 <lambdabot> System.Environment getArgs :: IO [String]
07:27:47 <lambdabot> Graphics.UI.GLUT.Initialization getArgsAndInitialize :: IO (String, [String])
07:27:48 <dfordivam> yes i defined it using record syntax, so is there any 'direct method' to 'update' one of the fields of a container?
07:27:50 <edwardk> dfordivam: look at the lens package
07:28:15 <edwardk> you'd change the way you define your fields slightly
07:28:36 <merijn> dfordivam: "foo { myField = 5}" returns a copy of foo with "myField" set to 5
07:29:01 <merijn> But if you need to have many different updates lenses are much nicer
07:29:12 <Con> Hello. Is this the correct channel to ask question about installing packages via cabal?
07:29:24 <Eduard_Munteanu> Con: probably
07:29:28 <dfordivam> edwardk: aah its that easy!!
07:29:36 <dfordivam> Exactly what I wanted
07:30:22 <mux> @hoogle Applicative f => Int -> f a -> f [a]
07:30:23 <lambdabot> Control.Monad replicateM :: Monad m => Int -> m a -> m [a]
07:30:23 <lambdabot> Test.QuickCheck.Gen vectorOf :: Int -> Gen a -> Gen [a]
07:30:23 <lambdabot> Test.QuickCheck vectorOf :: Int -> Gen a -> Gen [a]
07:30:31 <Con> I'm trying to install the package blaze-builder, which depends on the package text. While I seem to have the correct version of 'text', the dependency still isn't found: http://pastebin.com/tnRe2Gha . Any idea how to solve this?
07:35:24 <EvanR> edwardk: whats -|
07:36:55 <merijn> Man, who needs unit tests when you have TypeFamilies and GADs?
07:37:19 <merijn> eh, GADTs even
07:37:29 <srhb> All your datas!
07:37:33 <Lutin`> EvanR: I'm sure Hoogle or Hayoo could tell you
07:38:24 <EvanR> im not sure
07:38:33 <EvanR> edwardk: what software does your blog run on
07:38:43 <Saizan> Con: what does ghc-pkg list blaze-builder say?
07:38:49 <madjestic__> merijn,  somebody who checks for non-type related errors?
07:39:45 <EvanR> heres my unit test, ghci f v0, f v1, f v2, eyeball, done
07:39:49 <tdammers> madjestic__: someone who can't play the type system to its extremes yet
07:42:29 <merijn> madjestic__: If your program allows for non-type related errors you're not using TypeFamilies and GADTs properly :p
07:42:41 <merijn> madjestic__: Which is what I was jokingly getting at :p
07:43:17 <Con> Saizan: http://pastebin.com/Dbi6ysYL
07:43:28 <hiptobecubic> merijn, i'd like to see this web you're spinning
07:43:30 <madjestic__> is there a proof for consistency of haskell type system?
07:43:41 <Lutin`> Just because a program typechecks doesn't mean it's going to produce the right output
07:44:01 <Lutin`> Your algorithms could be messed and you wouldn't know unless you check it
07:44:05 <merijn> hiptobecubic: I'm about to throw the first prototype online (somewhere today-ish)
07:44:13 <madjestic__> or, conversely: is there a proof for type inconsistency?
07:44:16 <merijn> hiptobecubic: I'll ping you when it's online
07:44:28 <hiptobecubic> merijn, sure
07:44:29 <astry> hi
07:44:55 <astry> i messed something up and the program doesn't compile anymore.. but i swear i didn't touch anything.. can someone help me out? this is terrible.
07:45:31 <astry> http://dpaste.com/803579/
07:46:00 <merijn> There's some flaws still in there (i.e. missing functionality), for now I don't yet support external pointers (which are a pretty fundamental required bit :p) and I use MVar's as communication channels (completely braindead, I should probably use BoundedChan for bounded channels), but I figured get a minimal usable thing first and add later
07:46:03 <astry> i have no idea what's going on. i don't have this in version control, sure, but i just left it alone for a couple hours, came back, now i get compile errors.
07:46:03 <srhb> astry: What's the error?
07:46:09 <byorgey> astry: please paste the error message along with the code
07:46:32 <Saizan> Con: sorry, i meant "ghc-pkg list text" and also "ghc-pkg field text id"
07:46:37 <byorgey> astry: in general, people who are not named "Oleg" do not have Haskell typecheckers built into their heads.
07:46:53 <astry> yeah i'm doing that :)
07:46:54 <zhulikas> who is Oleg?
07:46:55 <zhulikas> :)
07:47:13 <srhb> @faq Can Haskell typecheck Haskell in your head?
07:47:13 <lambdabot> The answer is: Yes! Haskell can do that.
07:47:14 <astry> here you go http://dpaste.com/803580/
07:47:18 <Saizan> Con: it's to see if ghc-pkg considers the package installed correctly, and which is the actual package-id
07:47:24 <sipa> Oleg actually only exists at the type level
07:47:24 <astry> zhulikas: google for "this ftp site"
07:47:30 <byorgey> zhulikas: http://okmij.org/ftp/
07:47:37 <Saizan> Con: ghc-pkg check could also highlight some problems
07:47:41 <Sculptor> yo
07:48:07 <Con> Saizan: Ah. I fixed one of those problems without realizing I did: updating the cache. It's installing now, thanks :D
07:48:37 <Saizan> Con: good :)
07:49:38 <zhulikas> looks like some bad-ass theoretical programmer
07:50:01 <byorgey> zhulikas: that's right.
07:50:05 <astry> ok this is very certainly messed up. i just undo'ed to an earlier version of the file which certainly worked, and this doesn't compile either. what's going on?
07:50:15 <Lutin`> astry: Try adding a type signature to handleKey
07:50:32 <astry> but i didn't have a type signature before!
07:50:35 <byorgey> zhulikas: http://www.cis.upenn.edu/~byorgey/haskell-alphabet/O.html
07:50:38 <astry> that's the thing!!
07:50:41 <srhb> handleKey is definitely weird, I can't understand what that liftIO is doing there nor what it would be before.
07:51:37 <byorgey> astry: the fact that the error message refers to a specific version of the transformers package sets off alarm bells for me
07:51:39 <astry> is ghc using some sort of random pattern for inferring the types in my program? because this is absolutely bizzarre
07:51:44 <Lutin`> byorgey: Yeah that too
07:52:04 <byorgey> astry: you say you didn't touch the code, I believe you, but did you install any packages?
07:52:05 <Lutin`> esp since it's a 2 year old version
07:52:07 <Lutin`> :X
07:52:09 <astry> byorgey: i may have installed something
07:52:17 <srhb> That's fairly certain :P
07:52:17 <byorgey> Lutin`: yes, good call!
07:52:32 <Lutin`> Yeah it looks like it's importing Control.Monad.IO.Class from transformers-0.2.2.0
07:54:01 <astry> does cabal keep a log of things that are being installed?
07:54:17 <byorgey> astry: can you run 'ghc-pkg list' and paste the output?
07:54:33 <byorgey> astry: and also  'cabal --version'
07:54:54 <astry> http://paste.ubuntu.com/1216839/
07:55:06 <astry> 0.14.0
07:55:51 <merijn> astry: If you're going to use liftIO in all branches of the case, why not do "liftIO $ case k of {cases here}"?
07:55:55 <edwardk> EvanR: 'left adjoint to'
07:56:05 <madjestic__> tdammers, merijn besides possible error not related to type system, untill there is a proof for haskell type system to be consistent, there is no warranty against errors, is not that so?
07:56:07 <astry> merijn: i need this to work at all first. it just stopped working.
07:56:20 <edwardk> EvanR: it runs on a wordpress i hacked up quite a bit a couple years ago
07:56:21 <Lutin`> madjestic__: What do you mean consisiten
07:56:29 <edwardk> er i guess 4 years ago now
07:56:33 <zhulikas> whoever came up with "Zygohistomorphic prepromorphisms" has a sense of humour!
07:56:39 <edwardk> zhulikas: was me
07:57:02 * byorgey can confirm that edwardk has a sense of humor
07:57:16 <byorgey> not sure about humour
07:57:19 <madjestic__> Lutin`, consistent in Hilbert's consistency sense
07:57:22 <edwardk> =)
07:57:23 <zhulikas> oh, right
07:57:24 * hackagebot polysoup 0.1.0 - Online XML parsing with polyparse and tagsoup  http://hackage.haskell.org/package/polysoup-0.1.0 (JakubWaszczuk)
07:57:29 <edwardk> my humours are out of whack
07:57:37 <astry> maybe i should just uninstall transformers?
07:57:40 <merijn> TypeFamilies question time!
07:57:42 <zhulikas> oh, actually humour!
07:57:59 <tdammers> madjestic__: even a perfect type system won't catch all errors
07:58:20 <byorgey> zhulikas: I was just making a US vs. British english joke, humour is the British spelling I think
07:58:22 <zhulikas> humour is a British variation of humor
07:58:23 <tdammers> I do believe though that the majority of things typically tested with unit tests can be covered by a type system
07:58:25 <madjestic__> tdammers, define perfect ;)
07:58:27 <zhulikas>  yeah
07:58:34 <zhulikas> byorgey, I wasn't fast enough to figure that out on the way
07:58:40 <zhulikas> and had to check the spelling instead
07:58:41 <zhulikas> :D
07:58:41 <tdammers> madjestic__: no need ;-)
07:58:45 <madjestic__> tdammers, agreed on that
07:58:46 <byorgey> zhulikas: hehe =)
07:58:46 <astry> i think it also installed parsec, byorgey
07:59:02 <astry> but not sure
07:59:08 <mapreduce> I call my variant of English English English because I'm not certain the Scots, Welsh and Northern Irish actually speak the same version.
07:59:09 <tdammers> thing is, when people say "unit tests", they often mean "some sort of automated tests"
07:59:23 <merijn> I have the function "Foo -> (forall p . Bar p -> a) -> a", I want to replace the "(forall p . Bar p -> a)" argument with a type fun generated one. But doing the naive thing "type family Fun a b = forall p . Bar p -> a" is wrong?
07:59:25 <tdammers> which can be anything - unit test, integration test, regression test, etc.
07:59:29 <byorgey> astry: try doing  ghc-pkg hide transformers-0.2.2.0
07:59:48 <byorgey> astry: uninstalling will break anything that depends on it
07:59:50 <mapreduce> tdammers: I've recently seen it used to describe manual tests too.
07:59:58 <byorgey> astry: hiding means things can only use it if they explicitly request it
08:00:53 <Lutin`> I don't understand why old versions aren't automatically hidden
08:01:13 <Lutin`> As far as I can tell that would be a Good Thing (TM)
08:01:17 <astry> byorgey: this does not help
08:01:28 <astry> byorgey: i exposed it again and that did not help either.
08:01:34 <astry> does cabal have a log of things it installs??
08:01:41 * astry is going crazy over this
08:01:59 <astry> why does installing new packages have to break things.. this is so, so terrible :(((
08:02:14 <astry> isn't this the whole point of "package"
08:02:23 <srhb> Cabal install is not a package manager.
08:02:24 <srhb> Sorry.
08:02:26 <astry> something that doesn't interact with other things unless it's asked to
08:02:29 <byorgey> astry: installing new packages doesn't break things which properly specify their dependencies.
08:02:46 <astry> byorgey: let's try to fix this somehow..
08:02:50 <dcoutts> astry: we're working on it. The problem is that we currently cannot handle installing multiple instances of the same package.
08:02:52 <byorgey> astry: but if you just has some code that says "import such-and-such modules", there's no way to know which packages they should come from
08:03:22 <dcoutts> astry: once you allow multiple versions, it turns out you actually need multiple instances of the same version to avoid breaking existing packages when you install new things
08:03:34 <astry> dcoutts: but why did this fairly simple snippet of code i'm running break on its own? i don't know what this has to do with having multiple instances of a package.
08:03:57 <byorgey> dcoutts: that isn't even the problem here.  none of astry's packages are broken as far as I can tell.  there is some code that used to work with 'runhaskell' and after installing more stuff it now doesn't compile.
08:04:06 <dcoutts> astry: I've not looked at your example, just explaining why installing packages can break other packages.
08:04:23 <dcoutts> byorgey: oh ok
08:04:27 <astry> dcoutts: have a look.. it's fairly simple..
08:04:52 * astry goes to scream out of a window for 60 seconds because half a day of work is lost
08:05:50 <byorgey> http://dpaste.com/803579/ http://dpaste.com/803580/ http://paste.ubuntu.com/1216839/  for those interested in looking at astry's problem
08:06:18 <byorgey> No instance for (Control.Monad.IO.Class.MonadIO (transformers-0.2.2.0:Control.Monad.Trans.Reader.ReaderT (GHC.Ptr.Ptr E.EKey) IO))  is the key error
08:06:46 <byorgey> which is strange because there should be an instance of MonadIO for ReaderT .. IO; the problem seems to be some sort of package version mismatch
08:06:50 <astry> thanks byorgey
08:07:04 <byorgey> as indicated by the explicit listing of the transformers package version
08:07:05 <dcoutts> my guess is you're depending on two different versions of transformers
08:07:11 <dcoutts> so you end up missing an instance
08:07:24 * hackagebot syntactic 1.0.1 - Generic abstract syntax, and utilities for embedded languages  http://hackage.haskell.org/package/syntactic-1.0.1 (EmilAxelsson)
08:07:26 <byorgey> dcoutts: right, but somehow hiding one version of transformers didn't seem to help
08:07:30 <astry> i wasn't depending on two different versions of transformers before.
08:07:36 <dcoutts> byorgey: no, because it's an indirect dep
08:07:44 <byorgey> oh, I see
08:07:46 <byorgey> right
08:07:59 <astry> i am running the exact same code i wrote 3 hours ago.
08:08:00 <dcoutts> astry: you installed something new against the newer transformers, but you're still using other packages built against the older one
08:08:11 <byorgey> hmm, so I guess the changes to cabal with multiple packages *would* actually help in this situation.
08:08:11 <astry> how can i rebuild all packages?
08:08:21 <dcoutts> astry: this is something that cabal helps with, it makes sure you only depend on single versions of the same package
08:08:22 <byorgey> er, multiple instances of a package I mean
08:08:43 <dcoutts> byorgey: using cabal to build the prog in question would help
08:08:50 <byorgey> that too.
08:09:03 <dcoutts> runghc/ghci does not enforce that you only use one version of each dep
08:09:30 <astry> well if i try ghc hello.hs it doesn't compile either
08:09:35 <byorgey> right.  This was my point earlier when I said that "installing new packages doesn't break things which properly specify their dependencies"
08:09:37 <astry> so it's not only ghci
08:09:46 <dcoutts> astry: no, that'd have exactly the same problem. I said building with cabal.
08:09:52 <byorgey> astry: no, the point is to make a .cabal file for your project and then use cabal to build it
08:09:56 <astry> yeah, just clarifying
08:10:12 <dcoutts> byorgey: right, that properly specify their deps
08:10:14 <astry> guys
08:10:26 <astry> cabal does have a log of packages it installs, doesn't it?
08:10:46 <Lutin`> Yeah you did it earlier lol
08:10:46 <Lutin`> 'ghc-pkg list
08:10:53 <astry> that's not a log
08:10:56 <astry> that's a listing
08:11:02 <astry> i mean something with a timestamp
08:11:02 <byorgey> no, I think astry means like at what time what was installed etc.
08:11:03 <Lutin`> Oh true
08:11:14 <byorgey> I don't actually know. dcoutts?
08:11:17 <Lutin`> Yeah that makes more sense, sorry
08:11:18 <dcoutts> astry: ~/.cabal/logs/build.log,  but it's not used by default
08:11:24 <dcoutts> you have to turn it on
08:11:34 <astry> why isn't it on by default?
08:12:03 <dcoutts> I forget, I did have it on by default originally
08:12:29 <dcoutts> it doesn't have timestamps though
08:12:40 <astry> byorgey: why do you think i have two versions of transformers?
08:12:43 <astry> i only see one version
08:12:47 <dcoutts> it's mainly part of the anonymous build reporting infrastructure
08:12:51 <Lutin`> You def have two
08:12:59 <astry> well where do you see that i have two ?
08:12:59 <Lutin`> http://paste.ubuntu.com/1216839/
08:13:06 <Lutin`>     transformers-0.2.2.0
08:13:06 <Lutin`>     transformers-0.3.0.0
08:13:20 <Lutin`> In the thing you pasted! lol
08:13:26 <astry> riight
08:13:29 <astry> i see it now
08:13:43 <Lutin`> It's all good haha
08:13:56 <dcoutts> astry: building your thing with cabal will almost certainly solve it. Use cabal init to get started.
08:14:15 <Lutin`> dcoutts: Are you the cabal guy
08:14:26 <astry> ok
08:14:32 <astry> hiding the NEW transformers works
08:14:39 <dcoutts> Lutin`: depends if you have a difficult or easy question :-)
08:15:07 <Lutin`> I'm just trying to see where everyone's place in the community is ;D
08:15:43 <applicative> dcoutts is at the center, clearly
08:15:46 <byorgey> dcoutts's place in the community is being dcoutts. =) One of the things dcoutts does is work on cabal.
08:15:51 <astry> right, it works now
08:15:55 <astry> thanks a lot guys
08:16:04 <byorgey> astry: glad you got it to work!
08:16:11 <astry> it's more like you guys got it to wrok
08:16:13 <Lutin`> hehe
08:16:15 <Lutin`> fair enough
08:16:39 <astry> this is so annoying though!!!! i hope this stops happening
08:16:42 <dcoutts> astry: my advice still stands. It's easy to end up with inconsistent dependencies if you're just using ghci
08:16:43 <astry> it's DLL HeLL
08:17:01 <astry> dcoutts: yeah, i'll check out cabal builds once i have running software
08:17:08 <astry> until then i want the ease of use that runhaskell provides
08:17:10 <byorgey> hiding transformers-0.3 is also not a very good long-term solution
08:17:18 <srhb> You'll get more running software by using cabal builds :P
08:17:24 * hackagebot chalmers-lava2000 1.3 - Hardware description library  http://hackage.haskell.org/package/chalmers-lava2000-1.3 (EmilAxelsson)
08:17:37 <astry> how can i rebuild everything that uses transformers against 0.3?
08:17:39 <astry> is there a way?
08:17:58 <dcoutts> unregister transformers-0.3 and then use ghc-pkg list to see what is broken
08:18:31 <rwbarton> you mean unregister -0.2.2.0 right?
08:18:36 <astry> you mean transformers-0.2.2.0
08:18:38 <astry> yeah
08:18:42 <byorgey> or if you mean you want to rebuild everything so that it uses 0.3... right
08:18:45 <astry> well there's a lot of stuff that would break
08:18:53 <astry> so how do i actually get ghc to rebuild it?
08:19:10 <dcoutts> the way to use cabal is to tell it all the things you want to be installed together, consistently. List those as targets, let the solver do the work.
08:19:25 <donri> bitonic: was it you who told me kd-trees have better performance potential than HiggsSet? if so, care to join the discussion in #happs?
08:19:29 <astry> dcoutts: if you can make cabal work inside a hashbang, i'm all for it
08:19:30 <donri> sorry if I'm misremembering
08:19:45 <byorgey> astry: also, how did you end up with two versions of transformers in your global package DB?  did you do 'sudo cabal install' or 'cabal install --global' or something?
08:19:48 <astry> dcoutts: i need to be able to run things quickly
08:19:56 <astry> byorgey: yes i did --global
08:19:58 <astry> why?
08:20:03 <byorgey> astry: don't
08:20:06 <astry> why not?
08:20:07 <bitonic> donri: we might have talked about that but I don't remember
08:20:23 <bitonic> I took a look at those a while ago, but my memory is hazy, and I'm busy now, I'll join later
08:20:33 <Lutin`> I hate that one of the first things RWH does is tell you to make cabal global
08:20:40 <Lutin`> At least I think it was RWH that did that
08:20:42 <byorgey> astry: it just makes things a lot easier to install only the Haskell Platform packages in your global DB, and then manage everything else in the user DB
08:20:45 <applicative> astry: I was going to say, theres way too much stuff in the global database.
08:21:02 <astry> why does it make things easier
08:21:07 <astry> why is there too much stuff
08:21:14 <astry> how do you decide how much is too much
08:21:17 <astry> :)
08:21:27 <Lutin`> You have more in the global database than your user db
08:21:30 <Lutin`> That's too much
08:21:34 <byorgey> astry: then you know you will never get inconsistencies like this in your global DB, and in the very worst case you can always just delete your local package DB and start rebuilding things, knowing that you still have a working, consistent Platform
08:21:48 <applicative> astry, when you have conflicts and unpleasantness, its much easier to 'nuke' the local registry and do as dcoutts said, reinstall whats needed all at once in one command
08:22:17 <Lutin`> esp if you have cabal set up for your current project
08:22:35 <astry> byorgey: aha
08:22:43 <astry> byorgey: that makes sense
08:22:45 <astry> thanks
08:23:00 <dcoutts> applicative: you usually don't even need to nuke anything
08:23:05 <applicative> astry: unless you are doing something with a commplicated system, Ithink the best thing is to restrict to global db to things that come with ghc and the haskell platform
08:23:12 <Lutin`> Also take a look at cabal-dev. It might not be for you but it's helped me out at least 1
08:23:29 <applicative> dcoutts: no, just regress to where the conflict is.  But sometimes one can see more conflicts coming...
08:24:02 <Lutin`> Is there any plan to merge the features of cabal-dev into the mainline cabal?
08:24:23 <dcoutts> Lutin`: not just a plan, a successful GSoC project.
08:24:44 <astry> aha
08:24:45 <Lutin`> :O
08:24:57 <dcoutts> it's not a merge of cabal-dev though, it's a proper implementation
08:25:05 <Lutin`> Of course
08:25:15 <applicative> ...  unlike cabal-dev ....?
08:25:36 <Lutin`> applicative: He's saying it's not just cabal-dev stuck onto cabal
08:25:43 <applicative> ah
08:26:08 <dcoutts> cabal-dev is a hack, though a useful one to be sure
08:26:38 <Lutin`> Something just bothers me about all the projects I'm working on being installed to the local DB
08:26:51 <Lutin`> I like self-containment
08:27:11 <astry> phew
08:27:14 <astry> that was exhausting
08:27:22 <astry> maybe i can ask a small question now..
08:27:46 <astry> i'm in an IO do block. I got my args value with getArgs. how do i quit if there aren't enough arguments?
08:28:13 <astry> i'm still sort of struggling with the syntax here
08:28:15 <applicative> case args of [] -> putStrLn "more args please"
08:28:38 <applicative> (thats a bit simple minded)
08:28:51 <applicative> case args of [] -> putStrLn "Bye"
08:29:00 <astry> this is my current code: http://dpaste.com/803588/
08:29:06 <astry> applicative: right.. hmm..
08:31:36 <astry> wait, how would i perform two actions?
08:31:43 <astry> i tried using "do" but that doesn't work
08:31:43 <hpaste> applicative pasted “getArg” at http://hpaste.org/75015
08:31:51 <applicative> might depend what you want to do next of course
08:32:25 * hackagebot language-puppet 0.1.8.0 - Tools to parse and evaluate the Puppet DSL.  http://hackage.haskell.org/package/language-puppet-0.1.8.0 (SimonMarechal)
08:32:27 * hackagebot hsfacter 0.2.0.0 - A small and ugly library that emulates the output of the puppet facter program.  http://hackage.haskell.org/package/hsfacter-0.2.0.0 (SimonMarechal)
08:32:35 <bartavelle> this is an awesome release of language-puppet
08:33:27 <applicative> astry: what two actions do  you want to perform
08:35:13 <astry> applicative: i would like to putStrLn and then exit
08:35:21 <astry> or even let's start with putStrLn twice
08:36:03 <astry> i know i can use >>
08:36:08 <applicative> it will exit after putStrLn  you can repeat the putStLn line
08:36:08 <astry> why can i not use do?
08:36:59 <astry> mhm
08:37:02 <hpaste> applicative annotated “getArg” with “getArg (annotation)” at http://hpaste.org/75015#a75016
08:37:12 <srhb> astry: Not sure what you're asking. putStrLn foo >> putStrLn bar is equivalent to do putStrLn foo; putStrLn bar
08:37:25 * hackagebot puppetresources 0.3.0 - A program that displays the puppet resources associated to a node given .pp files.  http://hackage.haskell.org/package/puppetresources-0.3.0 (SimonMarechal)
08:37:32 <applicative> astry: heres  ^ a use of >>
08:38:12 <applicative> astry: it prints the arg (or a blank line) twice then exits
08:39:17 <hpaste> applicative annotated “getArg” with “getArg (annotation)” at http://hpaste.org/75015#a75017
08:39:25 <hpaste> merijn pasted “Two actions in case” at http://hpaste.org/75018
08:39:28 <applicative> astry: ^^ heres the  same
08:40:17 <applicative> so with merijn s function you could write main =  getArgs >>= foo
08:42:11 <astry> ahhhhhhhh
08:42:13 <astry> i know what it was
08:42:17 <astry> layout bit me in the butt
08:42:48 <astry> stupid layout :(
08:42:56 <astry> but it works now! yay!
08:44:34 <Cale> astry: if you haven't done so already, it helps to make sure your editor is set to convert tabs to spaces automatically. Apart from that, the golden rule of indentation is that things which are at the same level should start in the same column, and something which is part of something else should start in a deeper column.
08:44:44 <merijn> astry: after do and friends I either go to the next line and have everything indented 1 indent to the right of the line above it, or line up everything after the do
08:45:15 <astry> Cale: it does, but i did something like this:
08:45:21 <astry> case x of [] -> do
08:45:25 <astry>   putStrLn "aaa"
08:45:28 <astry>   putStrLn "aaa2"
08:45:32 <astry> that didn't work..
08:45:52 <astry> those quirks in haskell layout are slightly aggravating
08:46:10 <astry> i hope one day this stuff will become more flexible
08:46:12 <hpaste> merijn pasted “TypeFamilies + Rank2Types?” at http://hpaste.org/75019
08:46:16 <rwbarton> well where exactly were you planning on putting the other case :P
08:46:23 <astry> nowhere
08:46:25 <zomg> oh for fucks sake... I install hashmap from cabal and it breaks aeson...
08:46:28 <zomg> >_>
08:46:29 <merijn> Is it possible (and if so, how) to do a type family like the one I just pasted?
08:46:45 <dcoutts> zomg: cabal install hashmap aeson --dry-run
08:47:01 <merijn> astry: Haskell wants the do block to be indented more than the start of the pattern in case
08:47:19 <Cale> astry: right, because the case body's indentation level is set by the first non-whitespace character after the 'of'
08:47:22 <rwbarton> astry: well, that's not going to work anyways
08:47:23 <zomg> wtf did it do because it seems to have removed some package o_O
08:47:35 <merijn> astry: So either you move the case pattern to the next line (and indent a little) or you have to indent the putStrLn more
08:47:42 <Cale> and then your next line closes that block, because it starts in a column which is shallower than []
08:48:07 <rwbarton> astry: you probably meant "when (null x) $ do ..."?
08:49:04 <Cale> astry: your next pattern would have to line up with the [], if that helps to see the problem :)
08:49:20 <rwbarton> you can't just not handle a pattern in a case or your program will crash when it encounters that missing pattern
08:49:23 <astry> i hate variable indent
08:49:23 <Saizan> merijn: i don't think you can withotu a newtype
08:49:32 <astry> rwbarton: no idea.
08:50:03 <merijn> Saizan: How would I do that using a newtype, then?
08:50:39 <Saizan> merijn: make a newtype for (forall p. Bar p -> a)
08:50:58 <rwbarton> newtype FromBar a = FromBar (forall p. Bar p -> a)
08:51:16 <merijn> You mean "newtype Xyzzy a = forall p . Bar p -> a; type instance Fun (Foo a) b = Xyzzy b"?
08:51:22 <rwbarton> type instance Fun (Foo x) a = FromBar a
08:51:31 <merijn> Bah, that means I have to wrap the function when calling, that's not good enough :\
08:51:41 <merijn> Oh well, time to go home. I'll think about it tomorrow/later
08:53:07 <applicative> astry:  just think when writing the keywords like 'of' 'case' 'do'; the next think you type makes a new left margin
08:53:21 <astry> ok this has me stumped...
08:53:25 <applicative> the next thing you type, rather
08:53:33 <astry> what's wrong with the case in this thing?
08:53:34 <astry> http://dpaste.com/803600/
08:54:54 <applicative> astry, the word 'let' is a key word
08:55:09 <applicative> the next thing you wrote made a new left margin
08:55:13 <astry> so?
08:55:23 <applicative> the a in arg
08:55:33 <applicative> but then  you started [] at that same line
08:55:36 <rwbarton> line 4 is syntactically a new binding in the let block
08:55:51 <applicative> you are defining [] !
08:56:03 <astry> right
08:56:07 <applicative> indent the [] and (x:xs) one space
08:56:08 <astry> i understand now
08:56:53 <astry> how can i write this so that i only ever indent the next line once?
08:56:56 <applicative> again, words like LET IF THEN ELSE DO CASE OF are the whole story, the position of the next letter you type decides everything
08:57:00 <astry> instead of indenting twice
08:57:25 * hackagebot acid-state 0.7.7 - Add ACID guarantees to any serializable Haskell data structure.  http://hackage.haskell.org/package/acid-state-0.7.7 (DavidHimmelstrup)
08:57:49 <astry> because having to think when you should indent once or twice is fairly sadistic
08:58:19 <rwbarton> put a newline after every layout keyword i guess
08:58:32 <rwbarton> or use an editor mode that takes care of the thinking for you
08:58:55 <astry> what editor mode would that be
08:59:03 <quicksilver> applicative: if/then/else is only part of the story because of a stupid bug deliberately introducted into haskell2010; ideally one pretends they aren't :)
08:59:23 <quicksilver> astry: I never have to think about whether to indent once or twice
08:59:28 <rwbarton> emacs haskell-mode for me
08:59:33 <applicative> quicksilver: yes, i was simplifying. Not that I totally comprehend ...
08:59:55 <rwbarton> layout keywords are let, where, do, of
09:00:35 <applicative> right I was overdoing my keyword sensitivity training...
09:01:09 <astry> rwbarton: my editor does not support emacs scripts
09:01:28 <rwbarton> you mean "it isn't emacs"? :)
09:01:32 <applicative> astry: a lot of them have indentation support
09:01:38 <amos> identity:
09:03:03 <applicative> I wonder if the sublime text business someone put up has indentation
09:03:14 <rwbarton> but it makes sense that after "let a = ..." in a do block the indentation of the next line will depend on whether you are continuing the definition of a, introducing a new binding in the let block, or continuing the do block
09:03:51 <astry> why would you continue the do block after "let a =" ?
09:04:03 <rwbarton> you do it in your last paste...
09:04:05 <astry> it makes no sense to write "let a =" on its own
09:04:11 <astry> no, i don't
09:04:17 <rwbarton> sorry, "..." is more text on that line
09:04:32 <astry> i didn't include any dots
09:04:44 <c_wraith> astry: are you not a native speaker of english?
09:04:45 <astry> what i meant was that writing "let a =" on its own makes no sense
09:04:47 <sellout42> astry: … is an elision.
09:04:56 <astry> c_wraith: why does it matter?
09:05:08 <c_wraith> astry: because "..." is an english convention for "more text here"
09:05:14 <rwbarton> I wasn't talking about "let a =" on a line or I would have written "let a =" not "let a = ..."
09:05:32 <rwbarton> but if you prefer, pretend I wrote "let a = expr"
09:05:32 <astry> yes, and maybe you're not a native speaker because i said clearly that i specifically did not include them
09:05:37 <astry> rwbarton: but i was
09:05:52 <astry> rwbarton: and what i mean is that writing "let a =" on a line of its own makes absolutely no sense
09:06:02 <rwbarton> you didn't write that either
09:06:07 <rwbarton> so what are you talking about
09:06:12 <applicative> its the monadic let that affects indentation
09:06:15 <sellout42> astry: But no one suggested writing "let a =" on a line of its own
09:06:25 <astry> rwbarton: i did too
09:06:35 <rwbarton> let arg = case args of
09:06:47 <rwbarton> where did you write "let arg ="
09:06:54 <rwbarton> if you did I didn't see it, sorry
09:07:02 <astry> look here
09:07:03 <astry> http://dpaste.com/803619/
09:07:06 <astry> it does not work
09:07:16 <astry> what is the compiler thinking when it sees that?
09:07:26 <applicative> bad, 'case' is on a level with 'arg'
09:07:33 <astry> yeah
09:07:35 <astry> the question is why it's bad
09:07:46 <astry> there's no ambiguity in that code is there
09:07:58 <rwbarton> the compiler doesn't try to randomly repair your code
09:08:01 <applicative> but 'a' in 'arg' was the first letter after let
09:08:13 <astry> yeah that doesn't matter applicative
09:08:20 <astry> the code is still not ambiguous
09:08:21 <c_wraith> actually, it's all that matters
09:08:38 <astry> what i'm trying to say is that the compiler is stupid
09:08:43 <c_wraith> whether a particular chunk of code is ambiguous isn't important.  Whether the code corresponds to haskell's syntax is what matters
09:08:49 <astry> whether it matters to a stupid compiler is unimportant
09:09:10 <c_wraith> You're doing the same thing as asking why you need to end lines with ; in C, because it's obvious you meant the end of the statement by the newline
09:09:21 <c_wraith> the answer is "because that's how the language is specified"
09:09:37 <applicative> astry: the place you started 'case' is where you would start your next let binding
09:09:38 <astry> i am not doing that
09:09:42 <rwbarton> or why can't I write this in python
09:09:43 <rwbarton> print 1 +
09:09:43 <rwbarton> 2
09:09:47 <astry> i am asking why the language was specified in such a deficient way
09:09:57 <sithisbitch> haskell ? defficient ?
09:09:58 <sithisbitch> no
09:10:15 <astry> as of this moment, after about 10 pages of text, no one even came close to hearing the question
09:10:15 <c_wraith> I see the fundamental misunderstanding.  We mistook you for someone who was here to learn.
09:10:18 <sithisbitch> but it's strange when coming from another world
09:10:59 <Ferdirand> sorry, jumping in, what was the question ?
09:11:05 <mcstar> i think it is 'ellipsis' not 'elision'
09:11:14 <astry> c_wraith: i think you are upset because i criticized something which you like very much and identify with, and you're starting to make personal attacks. i don't like that.
09:11:21 <c_wraith> mcstar: the symbol is elipsis, the meaning is "something was elided"
09:11:23 <astry> please stop doing that.
09:11:26 <rwbarton> mcstar, both :) it is an ellipsis but it represents an elision
09:11:36 <mcstar> k
09:12:07 <astry> so what *else* could this snippet of code mean? http://dpaste.com/803619/
09:12:16 <astry> other than what it obviously looks like
09:12:23 <rwbarton> astry, the compiler's goal is not to accept as many programs as possible
09:12:46 <astry> rwbarton: i'm not sure how that helps me
09:12:58 <rwbarton> there is a simple rule here, every line that starts in the same column after let is the same kind of thing, a binding
09:14:11 <astry> so what could i write? let a = 2\n    b = 3\n    c = 4?
09:14:13 <rwbarton> until the block is closed by a line that starts earlier than that column
09:14:30 <rwbarton> yes, exactly
09:14:56 <astry> that is the answer i've been looking for
09:15:00 <astry> thank you rwbarton
09:15:05 <rwbarton> if let only allowed a single binding then there would be no reason for it to introduce layout and then your program would be accepted
09:16:23 <Cale> The 4 keywords which introduce layout are 'case', 'of', 'let' and 'do', and the first non-whitespace character after them sets the column that things have to line up with.
09:16:28 <astry> rwbarton: right, that makes perfect sense
09:16:31 <astry> thanks Cale
09:16:41 <Cale> er, sorry 'where', 'of', 'let' and 'do'
09:16:52 <Cale> 'case' doesn't
09:17:26 * hackagebot snaplet-sqlite-simple 0.1.1 - sqlite-simple snaplet for the Snap Framework  http://hackage.haskell.org/package/snaplet-sqlite-simple-0.1.1 (JanneHellsten)
09:17:26 <astry> mhm
09:17:29 <astry> yeah, case doesn't
09:17:55 <mcstar> you can use {} to 'solve' it
09:18:19 <astry> mcstar: yeah.. i try as a rule not to use layout braces ever
09:18:53 <astry> c_wraith: watch and learn.. that's how you productively resolve misunderstandings
09:19:27 <astry> thanks guys, this layout stuff keeps on messing with me every time i resume writing haskell after a longer break
09:19:46 <astry> maybe i'll learn it once and for all this time
09:19:47 <astry> :)
09:19:49 <applicative> where of let do
09:19:54 <astry> :)
09:20:53 <mcstar> you need a SSE
09:20:53 <applicative> where of, let do!
09:21:47 <astry> heh
09:24:20 <rwbarton> astry, happy to help
09:24:56 <mcstar> the online dict i often use didnt list all the meanings of 'elision' but the printed one does :)
09:25:17 <rwbarton> astry, you might have gotten a productive answer sooner if you had asked questions like "I don't understand why indenting this line an extra space is necessary" rather than "what i'm trying to say is that the compiler is stupid"
09:25:33 <Cale> > let in let in' = "in" in let in do in'
09:25:34 <lambdabot>   "in"
09:25:47 <applicative> its a bad idea to call the compiler stupid; this is a religious channel.
09:26:06 <mcstar> but that is polytheism
09:26:07 <rwbarton> > if 2 + 2 == 4; then "good"; else "bad"
09:26:08 <lambdabot>   <no location info>: parse error on input `;'
09:26:13 <rwbarton> huh
09:26:22 <rwbarton> > do { if 2 + 2 == 4; then "good"; else "bad" }
09:26:23 <lambdabot>   <no location info>: parse error on input `;'
09:26:39 <rwbarton> oh I guess lambdabot is old and doesn't have that extension enabled
09:26:55 * applicative doesnt want that extension
09:27:26 * hackagebot strptime 1.0.8 - Efficient parsing of LocalTime using a binding to C's strptime,  with some extra features (i.e. fractional seconds)  http://hackage.haskell.org/package/strptime-1.0.8 (EugeneKirpichov)
09:27:28 * nand` indents ‘then’ and ‘else’, each on the same line as their bodies
09:27:34 <nand`> and that's the only way I want to see it
09:28:02 <applicative> this is the rule quicksilver doesnt like
09:28:37 <nand`> I see it like a form of contracted case/of; ‘then’ matches True and ‘else’ matches False
09:29:35 <astry> rwbarton: i only said this after people started refering to the compiler as the be-all end-all in deciding which code makes sense and which doesn't
09:29:53 <astry> rwbarton: which was circular logic because it said "the compiler is correct because the compiler is correct"
09:30:01 <astry> rwbarton: so i had to break that up somehow
09:30:05 <rwbarton> well, you might have asked why the language standard was designed this way
09:30:13 <mcstar> haskell has a specification
09:30:19 <mcstar> independent of the compiler
09:30:27 <astry> i know mcstar
09:31:08 <mcstar> you dont know mcstar
09:31:08 <enolan> anyone who knows reactive-banana around? How do I lift an a into an Event t a?
09:31:14 <mcstar> XD
09:31:27 <mcstar> you see?
09:31:29 <applicative> is Event t a monad?
09:31:30 <mcstar> you forgot a comma
09:31:37 <mcstar> changed the meaning of the whole sentence!
09:31:39 <astry> rwbarton: right, but i did not know that the language was designed this way.
09:31:44 <astry> hindsight is always 20/20
09:32:00 <enolan> I want a function that takes an a and returns an Event that occurs once at the beginning of time.
09:32:17 <enolan> applicative: nope
09:33:06 <yitz> Cale: weird. why should an empty let be legal?
09:33:41 <benmachine> yitz: why disallow it?
09:33:44 <mcstar> type Event t a = [(Time,a)]
09:33:44 <applicative> enolan: i see its [Maybe a], so why not [Just a]
09:33:46 <c_wraith> yitz: same reason "let 1 = 2" is legal
09:34:13 <c_wraith> yitz: that reason being it's more work to disallow it than allow it, since allowing it doesn't hurt anything.
09:34:24 <Cale> > let 1 = let in do 2 in do 1
09:34:25 <rwbarton> could be useful in code generation also
09:34:25 <lambdabot>   1
09:34:25 <applicative> i'm looking at the wrong Event
09:34:38 <astry> Cale: hahaha
09:34:42 <astry> how does *that* work?
09:34:47 <enolan> that type is supposed to be an abstract representation. you can't actually get an Event that way
09:35:43 <yitz> > do let; "but here it's not allowed"
09:35:44 <lambdabot>   <no location info>: parse error (possibly incorrect indentation)
09:35:45 <mcstar> how about unE>
09:35:52 <Cale> astry: do x  desugars to  x,  you can leave the declaration list in a let blank, and numbers are admissible patterns which try to match the given number (using an Eq instance)
09:36:14 <mcstar> i see, un-E
09:36:15 <yitz> > do let {}; "unless you explicitly include curlies"
09:36:16 <lambdabot>   "unless you explicitly include curlies"
09:36:46 <rwbarton> yeah, otherwise the ; is in the let block, not the do block
09:36:54 <Cale> astry: think about  f 0 = 1; f n = 2 * f (n-1)
09:37:04 <c_wraith> > do let { ; ; ; ; ; ; ; } ; "foo!"
09:37:05 <lambdabot>   "foo!"
09:37:32 <rwbarton> and, I guess, so is the string
09:37:33 <yitz> it's inconsistent and confusing. an empty let is definitely an error and the user should be informed. it's not clear that allowing no content is easier and not harder.
09:37:35 <enolan> mcstar: I don't see an unE in the haddocks. Where are you looking?
09:37:40 <astry> hmmm
09:37:41 <astry> ok
09:37:48 <mcstar> file://localhost/home/mcstar/.cabal/share/doc/reactive-banana-0.6.0.0/html/Reactive-Banana-Combinators.html
09:38:05 <Cale> astry: That 0 is a pattern there. We can also use that pattern in a pattern binding like:  let 0 = ... in ... -- let bindings are lazy, and will only evaluate the expression when a variable which was bound gets evaluated, but the pattern 0 doesn't bind any variables
09:38:05 <rwbarton> > do let {; 1 = 2}; "test"
09:38:06 <lambdabot>   "test"
09:38:13 <enolan> hmm, I'm using 0.7.0.1
09:38:20 <rwbarton> yitz: it's not inconsistent!
09:38:21 <astry> > let 1 = let in do 2 in do 1
09:38:22 <lambdabot>   1
09:38:27 <rwbarton> the rest may be true though
09:38:29 <astry> > let 1 = let in do 2 in 1
09:38:30 <lambdabot>   1
09:38:59 <mcstar> enolan: if you cant find the 'obvous' way to construct something, then, maybe you are not supposed to do it, that way
09:38:59 <astry> what's the next evaluation step?
09:39:04 <applicative> enolan: you have to figure out how to relate a to time if you want to make an event
09:39:17 <mcstar> do you have an understanding how it supposed to work? this model
09:39:43 <yitz> rwbarton: that's true it's not inconsistent. but it wouldn't be inconsistent to define it the other way either. use a + instead of a *, that's all. and it would make more sense, i think.
09:39:45 <enolan> I'm just learning, so I have a weak understanding at best
09:40:03 <Cale> astry: Well, you don't need any of the definitions made in the let to evaluate to 1 there.
09:40:13 <mcstar> i think not a great many people use reactive banan here
09:40:28 <Cale> (there were no variables bound in the let, so it's pointless)
09:40:42 <yitz> btw Cale you're op (in case it's not intentional)
09:41:08 --- mode: Cale set -o Cale
09:41:18 <rwbarton> yitz: one argument I can see for allowing it is if you are generating code which let-binds a variable number of bindings, well, 0 is a number of bindings that you might want
09:41:21 <mcstar> yitz: is there a problem with that? i see other ppl bringing this to the attention of the 'oeprator'
09:41:35 <rwbarton> it's not an extremely compelling argument though
09:42:21 <c_wraith> rwbarton: the only real argument I can see is "it doesn't hurt anything to allow it. It makes the spec more complicated to disallow it."
09:42:34 <rwbarton> > case undefined of {}
09:42:35 <lambdabot>   <no location info>: parse error on input `}'
09:42:51 <yitz> mcstar: dunno. i guess it feels like being logged in as root all the time. bound to break something somehow eventually. also, Cale's nick is more beautiful (in irssi at least) without the op marker.
09:43:07 <mcstar> :)
09:43:29 <applicative> enolan: i see, there isnt any way to construct an event without a Behavior. never is defined....
09:43:41 <yitz> c_wraith: why is + more complicated than *? they're both a single character.
09:44:00 <byorgey> mcstar: there's a social aspect to it as well.  Some people might view being opped as somehow threatening or flaunting one's status
09:44:20 <byorgey> though anyone who knows Cale even a bit knows that isn't the case here.
09:45:34 <Cale> Well, sometimes I take ops in order to threaten someone into behaving better. Someone spammed a bunch of '.' earlier and it stopped, but I +o'ed myself just in case.
09:45:35 <ParahSai1in> say i have a library that has a function that reads a bytesting from a file handle, maps (+33) to each byte; and i have another function that maps (negate 33) to each byte of a bytestring and writes to a file handle -- if nothing else is done with that intermediate bytestring, is ghc canceling out the extra operations?
09:45:36 <c_wraith> yitz: because haskell's grammar is not expressed with a regular expression
09:45:50 <mcstar> enolan: what i thought, partly, maybe you cound find a tutorial to make sense of banana?
09:46:07 <c_wraith> ParahSai1in: well, no.  though if you mean (subtract 33), the answer is still no. :)
09:46:07 <yitz> in which case being op all the time blunts that effect
09:46:12 <rwbarton> someone who believes that an empty let- or where-block in a program is usually/always unintentional and tends to indicate that they've made a mistake would probably disagree with "it doesn't hurt anything to allow it"
09:46:28 <c_wraith> ParahSai1in: GHC doesn't optimize (x + 1) - 1  to x
09:47:12 <rwbarton> though perhaps a warning would be better
09:47:21 <c_wraith> ParahSai1in: even if it fused the operations far enough to see that's what's going on.
09:47:21 <ParahSai1in> http://hackage.haskell.org/packages/archive/bio/0.5.0.1/doc/html/src/Bio-Sequence-FastQ.html#parse and http://hackage.haskell.org/packages/archive/bio/0.5.0.1/doc/html/src/Bio-Sequence-FastQ.html#unparse
09:47:23 <nand`> optimizing that would break semantics
09:47:34 <c_wraith> nand`: not if it was a type that was known to be well-behaved
09:47:40 <rwbarton> it's quite possible that the codegen would optimize that
09:47:41 <ParahSai1in> so its spinning extra cpu operations
09:47:57 <rwbarton> probably not in a situation like this though
09:48:48 <c_wraith> wow.  I suddenly understand why supercompilation is so hard.  On that note, time to go to work.
09:49:16 <enolan> mcstar: I am actually attempting to write an adequate tutorial while learning it
09:49:32 <enolan> http://www.haskell.org/haskellwiki/User:Echo_Nolan/Reactive_Banana_Straight_to_the_Point
09:50:02 <rwbarton> if you were reading one byte at a time, adding 33, subtracting 33 and writing the result then I would expect the LLVM backend at least not to write out an add instruction followed by a sub instruction :)
09:53:21 <rwbarton> just saying that even if GHC makes no attempt to simplify (x + 1) - 1 in general, once it is specialized, unboxed and converted to machine operations, a lower level may be able to make that simplification
09:55:46 <yitz> c_wraith left, but: it's true, haskell's grammar is not expressed with a regular expression. from the report: "decls -> { decl1 ; … ; decln } (n ≥ 0)". so i should have said, 0 and 1 are both a single character.
10:02:26 <rwbarton> decls is probably also used in the definition of module
10:02:35 <rwbarton> fwiw
10:04:34 <rwbarton> oh, not really
10:04:36 <t7> when will it be haskell's turn for dependent types?
10:05:55 <madjestic__> t7, indeed
10:06:41 <rwbarton> weird, it looks like the Haskell report doesn't allow empty modules
10:06:44 <rwbarton> GHC does though
10:07:05 <rwbarton> oh it is just a typo
10:08:03 <rwbarton> is there a place to report Haskell Report typos?
10:21:12 <videl> Hello everyone, it's nice to be @Haskell back again!
10:23:19 <Sculptor> welcome back and have a nice stay
10:23:37 <mcstar> what stay is today?
10:25:02 <videl> It's a x stay where x = "nice"
10:26:26 <videl> I programmed haskell on studies, do you know any good haskell refresher?
10:28:08 <Eduard_Munteanu> videl: usually people in here recommend LYAH as an intro book, but if you want something more succint, perhaps you should look at the Gentle Introduction or the report. Or simply google for the topics you're interested in.
10:28:12 <Eduard_Munteanu> @where lyah
10:28:12 <lambdabot> http://www.learnyouahaskell.com/
10:28:40 <rwbarton> the later chapters of RWH maybe
10:28:51 <Eduard_Munteanu> @where gentle
10:28:51 <lambdabot> http://www.haskell.org/tutorial/
10:31:28 <videl> I wouldn't dare to ask if i hadn't googled something. Thank you for links and your kind response :)
10:36:23 <sm> ack, I wish haddock used markdown
10:36:40 <sm> italicising /stuff/ is really a pain
10:37:29 * hackagebot darcsden 1.0.1 - Darcs repository UI and hosting/collaboration app.  http://hackage.haskell.org/package/darcsden-1.0.1 (SimonMichael)
10:38:11 <hiptobecubic> sm, sounds patchable
10:40:56 <sm> it does doesn't it
10:41:02 <jfischoff> yeah
10:41:19 <jfischoff> I wonder if pandoc could also be useful?
10:41:26 <sm> I suppose one reason it might not have been done yet is breaking old haddocks ?
10:41:48 <jfischoff> My bet is its not a high priority
10:41:51 <sm> or because pandoc was GPL ?
10:42:01 <jfischoff> oh possibly
10:42:41 <jfischoff> well I think markdown might be worthwhile. Its more well known then haddock syntax, could lead to better documentation
10:42:49 <sm> but now there's http://hackage.haskell.org/package/markdown
10:43:51 <jfischoff> half way there ;)
10:46:20 <byorgey> to be fair, the first release of haddock predated the invention of Markdown by two years
10:47:01 <c_wraith> they should have time-traveled into the future to get the markdown spec.
10:47:07 <c_wraith> no excuses!
10:47:28 <byorgey> but I don't see why one couldn't, say, add a flag to haddock to tell it to use Markdown
10:47:33 <jfischoff> seriously we have the Tardis monad? I'm come on!
10:47:42 <jfischoff> *I mean
10:47:42 <byorgey> then existing docs wouldn't break, and you could opt-in to using markdown
10:48:04 <Clint> any one of the 17 different markdown variants
10:49:04 <dmwit> Clearly the superior option would be to invent variant 18: Haddock markdown.
10:49:13 <byorgey> haha
10:49:34 <byorgey> hmm, the description of the markdown package says: "This library leverages existing high-performance libraries (attoparsec, blaze-html, text, and conduit), and should integrate well with existing codebases."
10:49:48 <byorgey> that has got to be one of the worst package descriptions I have ever seen.
10:50:11 <jfischoff> So I'm going to give vim and haskell a go, is there a particularly popular setup I should start with?
10:50:16 <Enigmagic> "this package is developed in Haskell"
10:50:23 <sm> heh
10:50:28 <Enigmagic> durrrrr
10:50:44 <jfischoff> "you suck"
10:50:53 <sm> steady now
10:51:02 <mcstar> jfischoff: haskell-mode with emacs?
10:51:03 <dmwit> jfischoff: moment
10:51:06 <mcstar> i think that is popular
10:51:15 <sm> you churn out that many useful packages, you can be excused for an occasional imperfect haddock
10:51:32 <dmwit> jfischoff: https://github.com/jejansse/haskim covers the popular stuff, I think
10:51:43 <jfischoff> dmwit: thanks
10:51:43 <dmwit> s/covers/pulls in/, maybe?
10:51:47 <mcstar> oh, i only read the second half of your sentence...
10:52:00 <dmwit> Personally I just use the built-in highlighter and :set ai,noet
10:52:02 <dmwit> =)
10:52:02 <byorgey> sm: oh, I am happy to excuse anyone for an occasional imperfect haddock, no matter how many packages they write
10:52:11 <jfischoff> mcstar: thought you really like emacs ;)
10:52:21 <mcstar> i do i do, and it was a joke
10:52:32 <jfischoff> :)
10:52:39 <mcstar> the cyclic indentation is superb
10:52:54 <mcstar> i have no idea how to format code in vim
10:53:03 <sm> byorgey: I noticed you tried out hub.darcs.net, any problems so far ?
10:53:04 <mcstar> thats why i only edit config files with it sometimes
10:53:32 <byorgey> sm: nope
10:53:45 <byorgey> sm: I'll definitely let you know and/or submit patches if I run into anything.
10:53:49 <sm> super
10:55:37 <clahey> Do any of y'all do web development in haskell?
10:56:23 <dmwit> I don't personally do it, but there exist Haskell web devs.
10:56:27 <sm> yup
10:56:50 <sm> lots more on #snapframework, #yesod and #happstack
10:57:01 <Clint> and #hakyll if you count that one
10:57:12 <sm> +1
10:57:49 <clahey> Is one of them preferred?
10:58:02 <clahey> Or is there a good list of advantages/disadvantages somewhere?
10:58:36 <zhulikas> mainly framework wars
10:58:47 <zhulikas> I don't believe you can get any objective opinion on them
10:58:48 <Jello_Raptor> huh, i have no clue what i'm doing wrong http://hpaste.org/75022
10:59:04 <Clint> i agree with zhulikas
10:59:10 <clahey> zhulikas: No, but I can hear the arguments for each side and decide which one appeals to me more.
10:59:16 <mroman> Jello_Raptor: maxMap _ (x:[]) = [x]
10:59:19 <sm> all of the big three are pretty good, currently yesod is most featureful, snap is simplest, there is a good blog post by a snap author comparing them
10:59:23 <mroman> probably
10:59:36 <zhulikas> or... you can check the 'getting started' guides and see which style of programming fits you better
10:59:46 <sm> outside the big three, hakyll is good for static sites and scotty is by far the simplest for small web apps
10:59:47 <mroman> hm. no.
11:00:28 <mroman> The other case which only returns [x] would be (f x) > (f y)
11:00:47 <Jello_Raptor> mroman: ahh thanks that's it :)
11:01:02 <mroman> If I have to guess it's because id 4 is > id 1?
11:01:02 <nand`> Is there something like http://hackage.haskell.org/packages/archive/cubicspline/0.1/doc/html/Data-Algorithm-CubicSpline.html but giving me [(Double, Double)] -> Double -> Double ? I want to interpolate some values without a lot of headache
11:01:09 <nand`> I don't know what to do with [PolyCos]
11:01:20 <Jello_Raptor> mroman: yup
11:01:31 <Jello_Raptor> mroman: also i should just do that with a fold
11:05:19 <mcstar> enolan: what is sox?
11:06:20 <frigga> zhulikas: Opinions are never objective. :)
11:06:20 <mcstar> i bet it has to do with music
11:06:59 <madjestic__> frigga, is that an objective opinion?
11:07:25 <frigga> lol
11:07:31 <bartavelle> is there a way to know why hackage doesn't generate the haddocks for my library ?
11:09:01 <nand`> I found http://hackage.haskell.org/packages/archive/splines/0.3/doc/html/Math-Spline.html which seems fairly complicated
11:09:30 <nand`> as such, I have zero clue how to use it; eg. bSpline :: Knots (Scalar a) -> Vector a -> BSpline a  tells me nothing
11:10:05 <nand`> how would I implement [(Double, Double)] -> Double -> Double using this? In fact, I can simplify my function to [(Int, Double)] -> Int -> Double
11:15:11 <acowley> I'm having trouble using the singletons library. I have instances for "SingI k Foo" and "SingI k Bar" for the only two types, Foo and Bar, that inhabit my promoted kind k. But when I try to use sing in a function, it complains I don't have an instance for "Sing k a"
11:15:31 <acowley> that last one should be a complaint about a missing instance for "SingI k a"
11:16:36 <mcstar> nand`: bezierCurve :: Vector t -> BezierCurve t cant you use this?
11:17:26 <acowley> My intended usage is to write a function of type "Qux (a::MyKind) -> Int", and I want to look at a value-level representation of the singleton type associated with a.
11:17:44 <nand`> mcstar: won't that construct an n-1-th degree polynomial?
11:17:59 <dmwit> acowley: I am 100% not the right person to give advice here, but... can you just add the missing constraint to your type signature?
11:18:32 <acowley> dmwit: the error message asks about a missing instance that really doesn't exist though
11:18:35 <mcstar> a bezier curve is a kind of spline
11:18:45 <dmwit> huh
11:18:47 <acowley> dmwit: So I'm not sure what more I can put in my type signature
11:19:00 <nand`> perhaps I'm confused by the definition: ‘The degree of the curve is one less than the number of control points.’
11:19:03 <acowley> I just wanted closed phantom types :/
11:19:16 <dmwit> Yeah, I know. =(
11:19:22 <dmwit> Perhaps related StackOverflow question:
11:20:03 <dmwit> http://stackoverflow.com/q/12438909/791604
11:20:25 <dmwit> I figure you're pretty hip to GADTs, though, so probably not helpful to someone at your level.
11:20:43 <rwbarton> this sounds like a question I was asking before about whether you can drop a constraint (C a) when you have instances for every inhabitant
11:20:44 <acowley> Also, I had to make a change to happy to get it to compile with 7.6.1 but can't find a repo anywhere
11:21:00 <acowley> rwbarton: Yes, it's very similar
11:21:14 <rwbarton> unfortunately I never really found out the answer :)
11:21:18 <mcstar> nand`: i think that is how the degree of the bezier spline made out of bezier curves is calculated
11:21:21 <rwbarton> besides that it didn't seem to work automatically
11:21:31 <mcstar> nand`: the problem is, that with that, you dont have control over the knotw
11:21:34 <mcstar> knots
11:21:38 <acowley> rwbarton: I thought the brave new world of 7.6.1 might have solved these things
11:21:42 <rwbarton> ah
11:21:50 <rwbarton> I was testing 7.4 yeah
11:21:50 <rwbarton> but no?
11:22:00 <dmwit> no
11:22:43 <acowley> it seems not
11:23:01 <acowley> but then I don't really get the singletons paper, because my skimming (ahem) suggested it was addressing just this issue
11:23:18 <acowley> I suppose more than skimming is in order, or I could just set this aside for another year
11:23:37 <mcstar> nand`: you might be right, on a second read, it might really just give you basically one 'know', and you would have to compose from things like those, the whole spline
11:23:48 <mcstar> one 'knot'
11:24:12 <rwbarton> -fwarn-incomplete-patterns has historically tended to lag behind developments in the pattern language and types anyways
11:25:12 <acowley> Ah!
11:25:19 <acowley> I *was* missing a constraint
11:25:37 <acowley> geese, I thought I'd put every possible annotation in every possible place
11:26:49 <nand`> mcstar: perhaps it would help to approach my concrete use case somewhat. I want to write [Maybe Double] -> [Double] with the semantics that Just values are taken as-is and Nothing values are interpolated, according to some nice algorithm like bicubic or whatever
11:27:12 <nand`> the ‘x’ axis is sort of superfluous, but easily given a numbering via Int
11:27:17 <acowley> Oh, hooray, this is awesome! Given how hard it is to get a 7.6.1 dev environment setup, now nobody will be able to use my library!
11:27:33 <hiptobecubic> acowley, eventually they will
11:27:44 <mcstar> nand`: id just use gsl
11:27:52 <acowley> hiptobecubic: I find I'm always waiting for eventually
11:27:57 <nand`> mcstar: if you can tell me what the easiest way of achieving this (least amount of haskell source lines) would be, I'd be grateful
11:28:10 <acowley> now I really wish ghc-mod worked with 7.6.1
11:28:56 <nand`> gsl? hmm, I don't feel like throwing around Ptr C'gsl_interp_type; I'm guessing bindings-gsl is not what I want
11:29:31 <byorgey> acowley: the singletons paper is describing a library.  It has nothing to do with what's implemented in 7.6.
11:29:53 <acowley> byorgey: But it's a library that works with 7.6
11:29:57 <mcstar> nand`: i just looked at it, quite horrible, i used the ocaml binding before, it is quite nice
11:30:04 <byorgey> acowley: yes...
11:30:07 <acowley> Hackage suggests it doesn't build on 7.4
11:30:28 <byorgey> no, it doesn't
11:30:42 <kirindave> Man, 32bit haskell
11:30:48 <kirindave> Still terrifying on OSX.
11:30:59 <nand`> mcstar: I think it may be easiest (if hacky) to just use the -> [PolyCos] function I found earlier and manually pick the correct coefficients by counting the number of Just’s passed so far
11:31:03 <astry> hey guys, does anyone know why my gtk2hs app would be getting keyboard input repeated twice?
11:31:04 <byorgey> it relies on non-buggy implementations of type promotion and kind polymorphism
11:31:06 <kirindave> With timing numbers like -2ms, haskell has found a way to defy causality.
11:31:07 <jdavis_> I am on ghc7 and I am trying to compile something I wrote a while ago. It is unable to find the module Data.Binary.Strict.Get. I am a new user and, in general, have a lot of difficulty finding which libraries to use or which cabal packages I need. I also end up running into old documentation for modules that are either no longer in use or have changed. Is there a guide for that somewhere?
11:31:09 <acowley> In any case, I was initially interested in the 7.6 features, and hoped the singletons library would help take advantage of them… and it does!
11:31:22 <kirindave> dysinger: Hullo.
11:31:30 <jfischoff> dmwit: the completion plugin is pretty dope
11:31:38 <byorgey> acowley: oh, I see.
11:31:47 <dysinger> kirindave: 'allo mate
11:31:47 <typoclass> astry: random guess -- maybe you're listening for both the key down and the key up events?
11:32:48 <hpaste> astry pasted “application gets keyboard input twice (press a)” at http://hpaste.org/75023
11:33:25 <astry> typoclass: it would seem like the "keyPressEvent" is for key down
11:33:45 <mcstar> nand`: i would do this kind of thing in python with numpy :(
11:34:05 <nand`> it has to be haskell
11:34:29 <astry> typoclass: if i try to use KeyReleaseEvent it still gets it twice
11:34:50 <MagneticDuck> when would someone want to use "overloaded strings"?
11:34:50 <MagneticDuck> oh never mind I read a bit on it
11:34:51 <MagneticDuck> cancel my question
11:36:13 <rwbarton> jdavis_: if you create .cabal files for your projects ("cabal init" will get you started) then they will serve as documentation of what packages are used in case you move your code to another machine or upgrade ghc
11:36:41 <rwbarton> jdavis_: the answer to the rest of your questions seems to be "use google and make sure you're looking at the right version of the documentation"...?
11:37:44 <mcstar> nand`: as a first solution, you could just take the average value of the preceding and succeeding points, and use that for the missing one
11:37:47 <nand`> mcstar: oh well, I'll settle for Data.Algorithm.CubicSpline and manually reconstructing the spline using pre-existing knowledge
11:38:20 <astry> oh i think i got it
11:38:21 <mcstar> i dont think you really need a splice
11:38:24 <mcstar> spline
11:38:37 <mcstar> because you only want to know a missing value
11:38:45 <mcstar> you dont need a smooth interpolation
11:38:46 <nand`> mcstar: yeah, but that would be horrible, eg. consider [Just 8, Nothing, Nothing, Nothing, Just 4]; I would get [8, 6, 6, 6, 4]; while I want something like [8, 7, 6, 5, 4]
11:39:04 <nand`> mcstar: this is for image processing
11:39:07 <benmachine> Data.Algorithm is surely a contradiction in terms >_>
11:39:28 <mcstar> nand`: ok, so you want to make it as smooth as possible
11:39:37 <nand`> not necessarily
11:39:44 <nand`> I want it to “look nice” as possible, whatever that means
11:39:50 <mcstar> smooth
11:39:50 <benmachine> "hey guys, I need to name a module. I know, I'll take a sensible module name, and then put "Data" on the beginning"
11:39:50 <nand`> I know there are dozens of algorithms for this kind of stuff
11:39:56 <nand`> sharp can be good
11:40:06 <nand`> often sharp (aliasing) upscalers are more desirable than smoother ones
11:40:17 <mcstar> do you have a 2d image then?
11:40:22 <nand`> yeah
11:41:05 <mcstar> id just use an averaging, but thats me
11:41:14 <jdavis_> rwbarton: ok, thank you. For some reason, I find myself confused about libraries, versions, and which ones are superseded often. But I'll take a look.
11:41:15 <DrPete> i just remembered http://www.wisdom.weizmann.ac.il/~vision/SingleImageSR.html
11:41:28 <mcstar> like, you know the values of the pixels on the sides of a polygon, that is missing data
11:41:35 <jfischoff> nand`: do you want to interpolation for resizing an image?
11:41:40 <mcstar> and i'd just diffuse the values across the void
11:42:16 <astry> typoclass: thanks, in trying to get a better version for you i made a minimal test case and then it became clear..
11:42:20 <carter_> acowley: i started slowly hacking on ghc-mod to adjust to the newer apis
11:42:29 <nand`> jfischoff: no, not necessarily - my samples are not evenly distributed like they are with rescaling
11:42:33 * hackagebot aeson-schema 0.1.1.0 - Haskell JSON schema validator and parser generator  http://hackage.haskell.org/package/aeson-schema-0.1.1.0 (TimBaumann)
11:42:35 <jfischoff> ah
11:42:37 <acowley> carter_: you're brave
11:42:47 <typoclass> astry: i don't think i contributed very much, but nonetheless, you're welcome :-)
11:42:48 <carter_> no, just foolish
11:42:49 <carter_> :p
11:43:05 <nand`> I have a bunch of points of differing colors at different positions; not necessarily following any pattern - and I want to generate an as reasonably as possible approximation to what the source image was
11:43:35 <rwbarton> jdavis_: in specific cases it can often be confusing. best bet is probably to ask here if you are confused
11:43:35 <dmwit> colors are not Doubles -_-
11:44:06 <acowley> carter_: Do you have a working version anywhere I could snag it?
11:44:13 <carter_> acowley: not yet
11:44:16 <DrPete> nand`: you may like to consider compressed sensing (see: https://brainwindows.wordpress.com/tag/compressed-sensing/)
11:44:27 <carter_> if you ask really nicely i'll have that be my afternoon procrastination of doom for the day
11:44:28 <carter_> :)
11:44:43 <nand`> dmwit: I'm working with a tricolor model which has three components to represent some subset of perceived color
11:44:54 <nand`> dmwit: each of those are modelled as a Double on the scale 0-1
11:44:58 <astry> typoclass: :)
11:45:01 <astry> oh noooo...
11:45:15 <astry> i think i may have run into a big problem
11:45:18 <MagneticDuck> geez, I've never gotten this error before...
11:45:31 <MagneticDuck> "Improper character constant or misplaced '"
11:45:36 <MagneticDuck> the single quote at the end is there
11:45:37 <astry> dcoutts: please tell me if i hold down a key it's possible to have it fire events repeatedly
11:45:55 <nand`> DrPete: yeah, that would be perfect, if it exists as a Haskell library I can just embed into my program
11:46:05 <dmwit> astry: man xset?
11:46:06 <nand`> if not, then I have no interest, because the scope would be vastly outside what I am doing
11:46:21 <rwbarton> > 'a
11:46:22 <lambdabot>   <no location info>:
11:46:22 <lambdabot>      lexical error in string/character literal at end o...
11:46:27 <rwbarton> hm
11:46:29 <rwbarton> > ''
11:46:30 <lambdabot>   <no location info>:
11:46:30 <lambdabot>      lexical error in string/character literal at chara...
11:46:35 <typoclass> MagneticDuck: are all the backslash sequences okay? '\' won't work, it has to be '\\' or '\ESC' or '\n' or whatever
11:46:44 <MagneticDuck> I'm not typing a string
11:46:47 <MagneticDuck> .____.
11:46:55 <astry> dmwit: i have keyboard repeat on. but currently in my program if i hold a key it does not repeat the keyPressEvent
11:46:56 <MagneticDuck> I"ll paste the code
11:47:06 <rwbarton> > 'ab'
11:47:07 <lambdabot>   <no location info>:
11:47:07 <lambdabot>      lexical error in string/character literal at chara...
11:47:43 <hpaste> MagneticDuck pasted “gah weird error” at http://hpaste.org/75024
11:47:47 <MagneticDuck> well...
11:48:02 <MagneticDuck> the error is actually buildwrapper
11:48:06 <MagneticDuck> yes
11:48:08 <MagneticDuck> I forgot about that
11:48:10 <rwbarton> line 9 looks a bit fishy
11:48:26 <MagneticDuck> x|
11:48:28 <MagneticDuck> lol
11:48:34 <MagneticDuck> lol
11:48:39 <MagneticDuck> erm
11:48:41 <MagneticDuck> that
11:48:42 <dmwit> astry: uh, no, but you also shouldn't get a KeyReleaseEvent ;-)
11:48:43 <MagneticDuck> was the dumbest error
11:48:47 <MagneticDuck> I've had in a while
11:48:47 <carter> acowley: i have a partial set of changes that needs a bit more hacking
11:48:47 <hiptobecubic> '
11:48:58 <carter> but at least seemingly kills some of the api mis matches
11:48:58 <MagneticDuck> :D
11:49:05 <MagneticDuck> > '   if 4 == 4 then 4 else 5
11:49:06 <lambdabot>   <no location info>:
11:49:07 <lambdabot>      lexical error in string/character literal at chara...
11:49:19 <acowley> carter: I took a quick look and couldn't track down the first error so figured I'd let it be someone else's problem :)
11:49:21 <carter> though a thing i'm fuzzy on is if its kosher to use the tracing version of the ghc config record
11:49:23 <dmwit> astry: And there's a separate event like KeyActivate or some such thing that has to do with how you type rather than how you press and release keys.
11:49:36 <astry> dmwit: ohh looking
11:49:49 <carter> acowley: i'll push it onto my gh
11:49:49 <rwbarton> astry: your logic in http://hpaste.org/75023 in handleKeys and handleKey is all wonky
11:49:54 <carter> the partial hacking
11:50:00 <carter> and maybe you can help me
11:50:07 <rwbarton> like on line 29 you shadow the k you passed in
11:50:20 <rwbarton> and handleKeys calls handleKey twice
11:50:28 <rwbarton> so that is why you get duplicate key events?
11:51:09 <rwbarton> can't you just delete lines 23 through 28
11:51:36 <astry> rwbarton: yeah i noticed that :))
11:51:56 <astry> rwbarton: thanks a lot.. very friendly of you to take time and find the error
11:52:37 <astry> basically i kept carving away from the program until i only had like 10 lines of code left, then it was obvious :)
11:53:25 <carter> acowley: i have the partial (still more work needed) change set at https://github.com/cartazio/ghc-mod
11:53:39 <carter> on the 7.6 branch
11:53:43 <carter> still some more stuff needed
11:53:47 <acowley> carter: Okay, I'll take a look at it
11:54:29 <carter> theres a few wonky things involving the change in the time / clock api
11:54:34 <carter> plus how DynFlags are handled
11:54:49 <carter> that are needed to solve the next batch of type errors in info.hs
11:55:48 <astry> dmwit: i don't see the event that you describe - do you see it? http://hackage.haskell.org/packages/archive/gtk/0.12.0/doc/html/Graphics-UI-Gtk-Abstract-Widget.html
11:56:27 <carter> acowley: you'll want to look at http://www.haskell.org/ghc/docs/7.6.1/html/libraries/ghc-7.6.1/index.html  and http://www.haskell.org/ghc/docs/7.6.1/html/ generally
11:56:43 <carter> and maybe compare it with the 7.4.1 docs
11:57:04 <acowley> oy vey
11:57:07 <astry> rwbarton: btw, you're pretty good to spot a bug in such a complex program so quickly.. how do you do it?
11:57:18 <carter> look at the changes I did in that branch
11:57:21 <clahey> Have y'all checked out yesterday's xkcd?
11:57:21 <carter> to see the patterns :)
11:57:36 <carter> most of the changes are really really simple
11:59:28 <carter> the heavy lifting is just looking at the \deltas
11:59:32 <carter> between the old and new apis
12:00:17 <dmwit> astry: It's only for things where you're supposed to be doing something that looks like typing, e.g. http://hackage.haskell.org/packages/archive/gtk/0.12.0/doc/html/Graphics-UI-Gtk-Entry-EntryBuffer.html#v:entryBufferInsertedText
12:01:37 <typoclass> clahey: yup. check out this, it supports cursor keys xkcd-map.rent-a-geek.de/
12:01:56 <astry> dmwit: i am making an image viewer. i want to be able to press the space bar and have the viewer shuttle through the images.
12:02:11 <astry> if this is not possible.. that's terrible
12:02:41 <dmwit> I don't see why it should be impossible.
12:02:56 <dmwit> Watch for a press event, set up a timer, cancel the timer on release events.
12:03:27 <typoclass> astry: i have little clue about gtk, but i'm sure it's possible. it's just that the EntryBuffer thingy is the wrong tool for the job
12:03:28 <astry> oh i can have a timer?
12:03:42 * astry looks up timers
12:05:30 <dmwit> http://hackage.haskell.org/packages/archive/gtk/latest/doc/html/Graphics-UI-Gtk-General-General.html#v:timeoutAdd
12:05:53 <astry> yeah i just found out it's called timeoutAdd by googling around :)
12:05:56 <astry> thanks a lot, great link
12:06:20 <dmwit> minor point of possible confusion: both gtk and glib offer a timeoutAdd
12:06:43 <dmwit> The documentation for each (should) discuss the difference, but Haddock doesn't add package-qualification, so it looks weird:
12:06:55 <dmwit> "timeoutAdd: this function differs from timeoutAdd in the following way"
12:07:44 <dmj> yo, any python devs here?
12:10:26 <typoclass> dmj: hello. this channel is about the programming language haskell. try the channel #python
12:10:28 <typoclass> @where lyah
12:10:28 <lambdabot> http://www.learnyouahaskell.com/
12:10:43 <acowley> Is there any hope that the (->) type constructor could work for kinds other than *?
12:10:52 <acowley> I should think through that some more
12:11:17 <typoclass> dmj: in the meantime, check this haskell tutorial ^^ it'll bend your mind and expand your programming skill :-)
12:11:23 <copumpkin> acowley: not many kinds whose types have values :)
12:11:24 <dmj> typoclass: I have gone through LYAH and RWH, I was asking if there were any Haskell programmers who also know Python
12:11:44 <dmj> and yes, LYAH blows my mind
12:11:44 <acowley> copumpkin: I'm single toning everything in sight
12:11:50 <acowley> autocorrect is killing me
12:12:01 <copumpkin> :O
12:12:06 <acowley> why isn't "singletoning" already in my dictionary?
12:12:11 <acowley> I use that world all the time
12:12:18 <copumpkin> I didn't even know that was a word
12:12:27 <acowley> "Those guys were singletoning like they just didn't care."
12:12:36 <typoclass> dmj: oh i see :) i bet there's plenty of folks here who know at least some python. just ask your question.
12:12:43 <copumpkin> sounds like a postprocessing step on photos
12:12:45 <copumpkin> where you take a nice photo
12:12:48 <copumpkin> and make it into a solid color
12:13:02 <acowley> see, that's the metaphor
12:13:54 <acowley> the type singletoning process takes a richly shaded kind and pulls out a solid color … okay, I lost hold of this one
12:14:30 <acowley> I guess it's just funny how Proxy circumvents then -> limitation
12:14:44 <carter> I'd say it like "singletening"
12:16:34 <clahey> yesod will have changed a lot in the last two years, right?
12:16:54 <Clint> many things in the haskell world have
12:18:05 --- mode: wolfe.freenode.net set +o ChanServ
12:18:28 <stepcut> clahey: for some definition of change.. I believe it is a lot the same but different.. like function taking slightly different arguments, switching from enumerators to conduits, etc. But fundamentally, it is still the same?
12:19:06 <clahey> stepcut: But if my 4 year old distro has a package, I'm not interested in it.
12:19:14 <clahey> Whereas ghc will probably be mostly the same.
12:19:43 <rwbarton> two years ago the most recent release of ghc was 6.12
12:21:06 <rwbarton> which I guess is not staggeringly different from today's ghc
12:21:11 <stepcut> clahey: i dunno.. I think GHC has probably changed more than yesod
12:21:20 <acowley> I think the difference is pretty staggering
12:21:21 <clahey> The Glorious Glasgow Haskell Compilation System, version 6.12.1
12:21:33 <acowley> it's amazing how easily you pull in language extensions once you open that door
12:21:38 <stepcut> we have DataKinds PolyKinds, Generics, and a ton of other stuff now
12:22:14 <rwbarton> what since then is widely used by now though, I'm sure there is something
12:22:59 <clahey> Are those described in lyah?
12:23:24 <rwbarton> those are not really lyah-appropriate :)
12:23:55 <nand`> http://hackage.haskell.org/packages/archive/numeric-tools/0.2.0.0/doc/html/Numeric-Tools-Interpolation.html ooh, this looks useful
12:26:32 <nand`> ah, except that Numeric.Tools.Mesh doesn't actually contain anything other than UniformMesh, which is useless for my purpose :(
12:26:48 <nand`> I guess I'll have to implement my own mesh
12:27:34 * hackagebot snap-core 0.9.2.1 - Snap: A Haskell Web Framework (core interfaces and types)  http://hackage.haskell.org/package/snap-core-0.9.2.1 (GregoryCollins)
12:27:37 * hackagebot snap-server 0.9.2.3 - A fast, iteratee-based, epoll-enabled web server for the Snap Framework  http://hackage.haskell.org/package/snap-server-0.9.2.3 (GregoryCollins)
12:27:39 * hackagebot JuicyPixels 2.0.1 - Picture loading/serialization (in png, jpeg, bitmap and gif)  http://hackage.haskell.org/package/JuicyPixels-2.0.1 (VincentBerthoux)
12:27:43 <dmwit> rwbarton: popular changes since 6.12: H2010 is default, LLVM codegen exists, equality superclass constraints, delayed typechecking, constraint kinds/kind polymorphism, ghci declarations
12:27:45 <noviceprogrammer> hello
12:28:46 <typoclass> noviceprogrammer: hi
12:28:56 <dmwit> Wait, you can derive Show for GADTs now?
12:29:03 <noviceprogrammer> can you do OOP in haskell?
12:29:17 <dmwit> ?google okmij oop haskell
12:29:18 <lambdabot> http://okmij.org/ftp/
12:29:18 <lambdabot> Title: This FTP site
12:29:47 <hiptobecubic> noviceprogrammer, you probably want to approach the problem in a different way with haskell though.
12:29:49 <rwbarton> useful title
12:29:58 <Saizan> dmwit: cruel man
12:30:39 <typoclass> noviceprogrammer: not really. haskell does things in different ways than oop languages (but we would argue in better ways)
12:30:46 <dmwit> ask a crappy question, get a crappy answer
12:30:52 <noviceprogrammer> I'm writing a simple game ^^
12:31:07 <hnsz> goodies :)
12:31:30 <rwbarton> dmwit: I guess I was really thinking more about how the landscape of widely-used packages has changed over the past two years.
12:31:31 <noviceprogrammer> the player must guess an Int between A and B
12:31:32 <dmwit> I wonder if this is on the Haskell FAQ yet.
12:31:38 <dmwit> rwbarton: ah
12:31:41 <dmwit> ?where faq
12:31:42 <lambdabot> http://www.haskell.org/haskellwiki/FAQ
12:31:52 <rwbarton> Several of those ghc features only affect the end user, not a library writer (-fllvm, -fdefer-type-errors, ghci improvements)
12:32:07 <Saizan> there was a Cale's article on doing somewhat OO programming in haskell
12:32:08 <dmwit> http://www.haskell.org/haskellwiki/FAQ#I_heard_Haskell_is_pure_functional._Does_that_mean_I_can.27t_do_imperative_.2F_OOP_.2F_aspect-oriented_.2F_logic_programming_in_Haskell.3F
12:33:47 <typoclass> dmwit: the question wasn't crappy, and i don't think your comment is appropriate. i think it's best if you say something helpful, or ask for clarification, or saying nothing at all
12:33:58 <dmwit> Wow, http://www.haskell.org/haskellwiki/Guess_a_random_number is a really long program.
12:34:07 <rwbarton> noviceprogrammer: you might also like http://www.haskell.org/haskellwiki/FAQ#I.27m_making_an_RPG._Should_I_define_a_type_for_each_kind_of_monster.2C_and_a_type_class_for_them.3F
12:35:30 <dmwit> typoclass: I do not agree with your complaint. If you'd like to discuss further, perhaps we should move to another channel; perhaps #haskell-blah?
12:37:40 <rwbarton> these functions are all too short
12:38:05 <rwbarton> well, not all of them but many of them
12:38:54 <rwbarton> what does "guess my number" have to do with OO anyways?
12:39:04 <dmwit> exactly
12:39:48 <jfischoff> I guess emulating subclassing and objects graphs would be better
12:40:59 <clahey> I was actually about to ask a question about class.  What does "class (Product t, Convert t, Container Vector t, Container Matrix t, Normed Matrix t, Normed Vector t) => Field t" mean?
12:41:40 <dmwit> It declares a new type class Field; all instances of Field must also implement the classes Product, Convert, etc.
12:42:24 <typoclass> clahey: it's a typeclass called Field, with one type variable t. the type variable has a whole bunch of constraints: for t, there must be an instance of typeclass Product present, an instance of typeclass Convert, etc.
12:43:02 <clahey> So a field isn't required to be a Normed Matrix.  There must be an implementation of Normed Matrix that supports it.
12:43:17 <clahey> Seems like a bit of a backward definition, but I can handle it.
12:43:20 <zomg> Anyone got any ideas? Getting this from cabal "cabal: error while loading shared libraries: libffi.so.5: cannot open shared object file: No such file or directory"
12:43:33 <zomg> Tried looking it up on el goog but nothing useful
12:43:38 <rwbarton> clahey, those sound the same to me
12:43:58 <dcoutts> zomg: do you get that when running ghci for example?
12:44:03 <rwbarton> but more precisely the meaning is "in order to write an instance for Field T (T some specific type) I have to already have an instance for Normed Matrix T"
12:44:17 <clahey> rwbarton: In math, a field is something that can be able to be put into a Normed Matrix.
12:44:23 <zomg> dcoutts: no, ghci runs just fine. This started happening as I upgraded my Ubuntu version just now
12:44:29 <clahey> rwbarton: Well I don't know what Normed means there.
12:44:37 <zomg> I attempted to reinstall cabal-install but it didn't seem to have any effect
12:44:39 <rwbarton> well neither do I :)
12:44:42 <dcoutts> zomg: so you get it when you run, .e.g cabal --version ?
12:44:56 <clahey> So a float is a field, but therefore float can be put into a Matrix.
12:44:58 <zomg> Yes, just 'cabal' will also cause it
12:45:18 <clahey> But I suppose an implementation of a matrix for a type is a matrix holding that type.
12:45:41 <dcoutts> zomg: do you also get it if you compile a trivial hello world prog with ghc and then run that prog?
12:45:55 <zomg> Trying, moment
12:46:22 <rwbarton> clahey, oh I think I see what you are saying
12:46:46 <zomg> dcoutts: compile and run works just fine
12:47:03 <rwbarton> it does seem backwards, because really a field is something where I can add, subtract, multiply and divide
12:47:10 <clahey> Exactly.
12:47:12 <Trudko> > doubleMe x = x + x
12:47:13 <lambdabot>   <no location info>: parse error on input `='
12:47:16 <rwbarton> I don't know why whoever wrote that class declaration chose to write what they did
12:47:23 <madjestic> zomg which OS are you using?
12:47:26 <clahey> Trudko: You can't define functions that way on the command line.
12:47:48 <zomg> madjestic: Ubuntu 12.04 LTS
12:47:54 <dcoutts> zomg: then building cabal-install from source should work
12:48:11 <clahey> I wonder how hard it would be to write an implementation of Field for the finite fields.
12:48:13 <dcoutts> zomg: or revert to the cabal-install that comes with the distro
12:48:16 <Trudko> clahey: yeah i did notice that i am reading lyh and they do say that i should save function def in file and load it
12:48:19 <typoclass> > let doubleMe x = x + x in doubleMe 42 -- trudko, try "let ... in ..."
12:48:20 <lambdabot>   84
12:48:42 <zomg> dcoutts: yeah, I tried apt-get remove cabal-install and then reinstalling, it had no effect. Guess I'll just compile it myself then
12:48:42 <clahey> rwbarton: Can I make a type that is (in C++ language) templatized on an int?
12:49:04 <rwbarton> sort of
12:49:10 <rwbarton> better with fancy new type system features
12:49:21 <rwbarton> oh
12:49:45 <rwbarton> somehow I misread "type" as "class", but anyways I think my answer is the same
12:49:59 <rwbarton> you want to do modular arithmetic?
12:50:16 <rwbarton> with a "mod p" type that depends on an int p?
12:50:18 <clahey> rwbarton: So I want to make something called FiniteField which implements Num, Eq, and so forth.
12:50:20 <zomg> dcoutts: okay I think I found the problem... I removed cabal-install, tried running cabal... and it still runs despite the package having been removed :P
12:50:25 <clahey> rwbarton: 'zactly.
12:50:38 <rwbarton> the old way to do that was with the magic reflection library
12:50:41 <rwbarton> @hackage reflection
12:50:41 <lambdabot> http://hackage.haskell.org/package/reflection
12:51:02 <dmwit> zomg: which cabal
12:51:10 <clahey> rwbarton: And then see if hmatrix's Numeric.LinearAlgebra.Algorithms.linearSolve would work on it, for example.
12:51:16 <clahey> rwbarton: Just as something to play with.
12:51:18 <dmwit> zomg: I mean, like, run the command "which cabal".
12:51:53 <rwbarton> with DataKinds there should be a better way though
12:52:24 <zomg> dmwit: yeah figured that =) was in /home/user/.cabal/bin/cabal..
12:52:37 <zomg> infact it was in one other place in addition to that, although that one was unused
12:52:44 <zomg> Yeah I'm good with linux
12:52:45 <zomg> lol
12:53:20 <clahey> So far, I've done two crypto homeworks in haskell and am very happy with it.
12:53:29 <clahey> And I did the second one in two different ways.
12:53:48 <rwbarton> clahey: apparently linearSolve (and a bunch of other stuff) is essentially a method of Field. http://hackage.haskell.org/packages/archive/hmatrix/0.14.1.0/doc/html/src/Numeric-LinearAlgebra-Algorithms.html#Field
12:54:00 <rwbarton> I guess you aren't intended to implement your own Field instances
12:54:44 <zomg> Maybe I should just nuke the whole .cabal folder since it seems borked :P
12:55:09 <rwbarton> or rather Field really means "a type of data that LAPACK/etc. can operate on"
12:55:22 <zomg> dcoutts: thanks for your help
12:55:41 <clahey> rwbarton: That's too bad.
12:55:53 <clahey> rwbarton: I see no reason that it couldn't be implemented in both a generic way and a specific way.
12:56:06 <clahey> rwbarton: So that it would be fast if done on doubles, but will still work with any field.
12:56:35 <clahey> I'm not wrong that that sort of thing is almost trivial in haskell, right?
12:57:22 <clahey> rwbarton: And in fact what Field means is Double | Complex Double
12:57:24 <rwbarton> well it's not trivial compared to writing a binding to LAPACK for the specific way and then not ever implementing the generic way :)
12:57:29 <rwbarton> clahey, yes
12:58:16 <clahey> rwbarton: What I mean is that it's trivial to write the part where haskell makes the decision of which version to use.
12:58:25 <clahey> Yeah, you have to write the algorithms.
12:58:52 <rwbarton> that kind of thing is actually not quite straightforward
12:59:15 <clahey> :(
12:59:16 <rwbarton> because there is no way to say "any type except Double"
12:59:53 <clahey> Can't you just say any type and then say Double and it'll choose the Double if it can?
13:00:01 <rwbarton> or "any type that *isn't* an instance of C" where C's instances are the types for which you can use LAPACK
13:00:15 <rwbarton> well I guess with OverlappingInstances, but I tend to pretend that doesn't exist
13:00:31 <typoclass> clahey: not sure what you're after, but i think it should be straightforward to do "instance Something Double where f x = <fast implementation>"; "instance Something (Complex Double) where f x = <slower implementation>". or really just 2 functions "fFast :: Double -> ...", "fSlow :: SomeOtherThing -> ..."
13:00:39 <typoclass> and yes, what rwbarton says
13:00:53 <clahey> I'm trying to hint at something like Ord.
13:00:58 <rwbarton> he also wants instance (Num a) => Something a where {- slower implementation -}
13:01:01 <clahey> Where it implements < and >
13:01:04 <rwbarton> as I understand it
13:01:10 <clahey> Oh, not Ord.
13:01:10 <clahey> Eq.
13:01:12 <rwbarton> oh
13:01:18 <clahey> Where it implements == and /= in terms of one another.
13:01:22 <rwbarton> well, yes that is one way you can do it
13:01:32 <clahey> And then you make instances of it and you get your versions.
13:01:41 <rwbarton> then the cost is for every type that you want to use the default slow implementation, you have to write an (empty) instance
13:01:55 <mcstar> someone said crypto?
13:02:01 <clahey> Like what Matrix does with Storable => Element.
13:02:11 <clahey> Storable a => Element a
13:02:29 * mcstar stares happily at his crypto .hs files
13:02:31 <clahey> rwbarton: That's a little icky, but not awful.
13:02:51 <rwbarton> right
13:03:01 <rwbarton> that's the "not quite straightforward" I was alluding to
13:03:28 <clahey> mcstar: Yeah, I used Data.Digest.SHA256 last week.
13:03:32 <tomh> anyone knows how to get a bit more information why a cabal fails to build than exit failure 1?
13:03:41 <tomh> I tried --verbose already
13:03:52 <dcoutts> tomh: the info is spat out further up in the build log
13:03:52 <rwbarton> clahey: you can also use RULES
13:03:55 <typoclass> tomh: try to make it more verbose with "-v3" (i think that is the switch)
13:04:07 <mcstar> clahey: dan boneh?
13:04:20 <clahey> mcstar: This week's assignment I just built everything from xor since the assignment was more breaking Crypto
13:04:22 <clahey> mcstar: Yeah.
13:04:30 <mcstar> i did it last 'semester'
13:04:30 <clahey> rwbarton: Interesting.
13:04:40 <clahey> mcstar: I did too, but I didn't do the homework.
13:04:50 <tomh> seems to fail at the very last line without much info :/
13:04:51 <clahey> So I've taken it again and am doing the homework and quizes this time.
13:04:56 <tomh> dcoutts: ill look that up thanks
13:05:04 <rwbarton> where you implement slowFunction and fastFunction and then write something like {-# RULE forall x. slowFunction x = fastFunction x #-}
13:05:16 <rwbarton> and if fastFunction x typechecks, it will be used instead. something like that
13:05:43 <dcoutts> tomh: when you're building several packages, it lists at the end that they failed, but the details will have been earlier at the point the individual package failed
13:05:45 <mcstar> clahey: hard to obtain a letter of accomplishment otherwise :)
13:05:59 <mcstar> i totally forgot about machine learning with Ng
13:05:59 <clahey> mcstar: Exactamundo.
13:06:08 <mcstar> after week 6 i just forgot about it
13:06:13 <clahey> mcstar: I'm keeping up to date on that one.
13:06:20 <clahey> I thought it was at week 6.
13:06:21 <mcstar> though i did everything up to that point
13:06:29 <clahey> Or is this a second run of it as well?
13:06:41 <mcstar> no, the first
13:06:53 <mcstar> it was supposed to end in august
13:06:57 <tomh> dcoutts: in this case its my own program that fails to build, but I suspect its the results of a preprocessor failing
13:07:21 <clahey> mcstar: I mean the one I'm taking is a second run of it.
13:07:27 <mcstar> it just bothers me, cause i did all the octave one liners :(
13:07:38 <mcstar> ok
13:07:40 <clahey> Yeah, the octave assignments are pretty easy.
13:08:02 <clahey> I would do them in haskell to give myself a chance to learn more, but I can't turn them in that way.
13:08:09 <typoclass> tomh: if you can't figure it out, feel free to put cabal's output on hpaste for us to look at
13:08:11 <typoclass> @where hpaste
13:08:11 <lambdabot> http://hpaste.org/
13:08:31 <clahey> I'm thinking of trying a couple of different learning algorithms to predict local house prices and see what I should offer to buy a house.
13:08:51 <mcstar> clahey: i was annoyed at first that i had to use octave, but it is actually not that bad and fits the problem(i hated matlab before...)
13:09:44 <clahey> mcstar: It does seem to fit the problem well.
13:11:03 <hpaste> Tomh pasted “cabal log” at http://hpaste.org/75025
13:11:32 <clahey> mcstar: I haven't decided whether to use octave or haskell for my own learning algorithms.
13:11:41 <tomh> maybe any of you can see it right away what could be wrong, but I can't see anything other than one of the preprocessors failing
13:11:45 <clahey> Probably octave as it has a ton of functions for answering specific problems.
13:12:16 <clahey> mcstar: I haven't figured out how to represent location as a feature.  Maybe that will come in week 7 or 8 when he talks about algorithms for automatic grouping.
13:13:00 <dcoutts> tomh: ok, there's very little there. It looks to me like a custom Setup.hs in the uurpc package that is producing no message
13:13:03 <Philonous> How do I correctly initialize the C++ runtime in a library that calls into C++ code?
13:13:11 <acowley> The fun part of octave/matlab is that discussions about data structures and types don't happen. "How should we arrange this logical record of data?" "As a vector." "… should the individual fields be…" "They're all doubles."
13:13:26 <dcoutts> tomh: the lines containing "127" are suspicious (cabal itself doesn't generate anything like that)
13:13:35 <tomh> yeah thats what I thought
13:13:42 <rwbarton> are indexes into a vector also doubles? :)
13:13:46 <edwardk> acowley: =)
13:13:49 <mcstar> clahey: idk about that, if you have a fix learning alg. i guess you could do it in haskell, but maybe it isnt the best way to prototype it
13:13:49 <dcoutts> tomh: makes me think it's a custom Setup and it's printing an exit code from a tool, 127 would mean it doesn't exist.
13:14:27 <clintm> Do any of you know of a cabal-dev -a-like that supports ghci?  Missing 'cabal-dev ghci' and thought I'd ask before attempting to fix it.
13:14:50 <tomh> dcoutts: I probably have to write a better Setup.hs thanks :)
13:14:58 <clahey> mcstar: A good point.
13:15:04 <mcstar> clahey: if you ever consider c++, have a look at eigen, really nice linalg abstraction
13:15:40 <clahey> mcstar: The two main things I would need are matrix math and minimization algorithms.
13:16:06 <dcoutts> tomh: unpack the uurpc package, and configure and build manually
13:16:20 <dcoutts> tomh: then hack the Setup.hs, add some print statements :-)
13:16:48 <clahey> mcstar: But I think you're right about prototyping in octave or something like it.
13:16:57 <clahey> mcstar: Especially since I can just copy the code from the class.
13:17:07 <mcstar> yeah :)
13:17:30 <statusfailed> edwardk: Your ad package is incredible
13:17:33 <mcstar> python wouldnt be too bad either, octave just makes it more succint
13:17:36 <edwardk> statusfailed: thanks =)
13:17:52 <statusfailed> I'm serious that thing is amazing :D
13:17:53 <tomh> dcoutts: the Setup.hs is only 1 line :)
13:17:54 <edwardk> i've been slowly working on adding a bunch of conjugate gradient methods to it, etc. those should go in soon
13:18:06 <edwardk> BFGS, etc.
13:18:10 <hiptobecubic> nice
13:18:11 <dcoutts> tomh: oh, grr
13:18:11 <enolan> for anyone interested in my FRP questions earlier, I posted on StackOverflow: http://stackoverflow.com/questions/12520242/why-are-there-no-functions-for-building-events-out-of-non-events-in-reactive-ban
13:18:19 <statusfailed> oh wow, that sounds cool
13:18:32 <edwardk> that should help folks who just want to use it for optimization
13:18:48 <tomh> dcoutts: but its almost certainly uuagc which is complaining
13:18:51 <mcstar> edwardk: automatic differentiation?
13:18:53 <statusfailed> I just use it for fun :D
13:19:12 <dcoutts> tomh: so it's build-type Simple?
13:19:20 <statusfailed> mcstar: yeah
13:19:39 <edwardk> i used it for a nice example at a dsl worshop i ran up at mcmaster last year with winterkoninkje. used AD to automatically fit train tracks together given a set of constraints on how they intersected, etc.
13:20:08 <tomh> dcoutts: custom
13:20:25 <dcoutts> tomh: what is the 1-line Setup.hs?
13:20:27 <edwardk> there was a paper that someone put out 2 days before the workshop for fitting train tracks using what turned out to be AD-like techniques, but he didnt spot the AD connection, so i made it explicit, and used the example, which my version had the benefit that you could fit multiple tracks simultaneously, etc.
13:20:32 <typoclass> tomh: is this the cabal file in question? https://github.com/Intellicode/uurpc/blob/master/uurpc.cabal
13:20:39 <tomh> it used to work a while ago, but GCH is updated so fast I can barely keep up updating code :P
13:20:40 <tomh> yes
13:20:59 <tomh> just trying to get an old project running
13:21:05 <edwardk> statusfailed: https://github.com/ekmett/dsl2011/blob/master/TrainTrack.hs
13:21:17 <Trudko> btw are lists  basicly arrays in haskell?
13:21:23 <Clint> no
13:21:26 <Trudko> or are at least used for same purpose/
13:21:26 <edwardk> basically it models track segments as clines
13:21:31 <dcoutts> tomh: ohh, so it is custom but all the code is in another package
13:21:43 <tomh> https://github.com/Intellicode/uurpc/blob/master/Setup.hs
13:21:52 <edwardk> Trudko: if you need to index into it, don't use a list. if you just need to work with it from left to right, etc. then lists are a good fit
13:21:56 <tomh> no the code is in the same package
13:22:20 <tomh> but it uses alex, happy, uuagc
13:22:27 <Trudko> edwardk: ok so it is something like linkedlists from java more or less?
13:22:35 <edwardk> Trudko: exactly
13:22:35 <tomh> and either a new cabal, uuagc or ghc broke my project :)
13:22:38 <mcstar> edwardk: lot of automatic derivation (pun)
13:22:56 <typoclass> Trudko: lists are more like linked lists, and they are used very frequently in haskell (they even have a little extra syntax, [] and so on)
13:23:15 <edwardk> but i thought it was pretty elegant to be able to say
13:23:25 <edwardk> find (clockwise_circle 0 0 1) $ satisfying [ passing_through x1 y1, passing_through x2 y2, clockwise_radius r ]
13:23:41 <edwardk> and have the ad engine try to simultaneously satisfy those constraints for you
13:23:57 <Trudko> typoclass: ok [] syntax confused
13:24:00 <statusfailed> edwardk: I can't guarantee I will understand it, but it sounds damn cool :)
13:24:26 <Trudko> edwardk: and what if I need to work with indexis?
13:24:32 <edwardk> find estimate $ satisfying [ passing_through x y, tangent_to c1, tangent_to c2 ]
13:24:52 <edwardk> Trudko: Data.Sequence.Seq, Data.Array, Data.Vector, Data.Map, there are lots of options
13:25:02 <Trudko> ok great
13:25:28 <mcstar> so, you take lines, with constraints of not crossing, and going around certain objects, and minimize for length?
13:26:22 <edwardk> mcstar: they are 'clines',  http://en.wikipedia.org/wiki/Generalised_circle
13:26:41 <edwardk> mcstar: this is a homogeneous representation that covers lines and circles
13:27:09 <mcstar> are you on a riemann sphere?
13:27:13 <Trudko> typoclass: plus in luh they show how to use index  with !!
13:27:21 <crdueck> @src pred
13:27:21 <lambdabot> Source not found. BOB says:  You seem to have forgotten your passwd, enter another!
13:27:24 <edwardk> then what i do is i put constraints on the clines i'm looking for, the constraints basically become a function that has a larger value the more you violate the assumption.
13:29:01 <edwardk> mcstar: not deliberately. though it becomes a sphere when you view it stereographically
13:29:41 <edwardk> basically ad is used to minimize the sum of the squares of the errors for each condition you put on the clines,
13:30:01 <edwardk> and it does that by basically hill climbing (in the 1 dimensional smaller inhomgeneous space)
13:30:08 <edwardk> er 1-dimension smaller
13:30:11 <typoclass> Trudko: right. you have probably noticed that normally, !! in haskell is not used as often as for example x[i] is used in java
13:31:01 <Trudko> typoclass: actually i did not have time to notice that yet i am new into haskell :D and  few lines later lyh writes Lists can also contain lists. so it totally reminds me arrays :D
13:31:17 <Trudko> but ok i wil take your word that it is not same
13:31:25 <Trudko> hopefully I will find difference later in book
13:33:20 <nand`> something tells me truncating a double to an int to use as array index is probably not the most desirable thing to do
13:33:33 <nand`> it means I'm either fundamentally misunderstanding this library, or the library is fundamentally broken
13:33:57 <c_wraith> nand`: it could be a sane thing to do in the case of approximations - what's the library for?
13:34:04 <nand`> http://hackage.haskell.org/packages/archive/numeric-tools/0.2.0.0/doc/html/Numeric-Tools-Mesh.html#t:Mesh
13:34:25 <c_wraith> Yeah, I have no clue about that one.
13:34:53 <rwbarton> I don't see the problem
13:35:06 <nand`> I'm still banging my head at the ‘interpolating a list of values’ problem, and still haven't made any progress apparently. I defined my own ‘SparseMesh’ to go with the UniformMesh; but the types involved seems like it wants my mesh to produce Double values as the actual positions to index at, for seemingly no reason whatsoever
13:35:13 <nand`> even though my actual data is a vector
13:36:06 <nand`> actually, that code isn't the problem; it's http://hackage.haskell.org/packages/archive/numeric-tools/0.2.0.0/doc/html/Numeric-Tools-Interpolation.html
13:36:36 <nand`> tabluate expects IndexVal m ~ Double <- this seems incredibly broken to me; what the heck is it doing there?
13:36:40 <nand`> tabulate*
13:37:28 <rwbarton> look at the definition of Indexable
13:37:47 <rwbarton> it seems the name IndexVal is not very good
13:38:03 <nand`> I don't know what I'm supposed to be seeing here
13:38:11 <rwbarton> well take (!)
13:38:15 <rwbarton> IndexVal a is what you get out
13:38:41 <adanuseam> dont suppose theres a 3rd sqrt in ghci
13:38:41 <Sculptor> is that an operator or a random ascii art
13:38:42 <tomh> btw, is this still not supposed to happen? "Unknown fields: alex-options "
13:38:47 <rwbarton> e.g. if I have an instance Indexable a with IndexVal a = Double then a is like an array of Doubles indexed by Int
13:38:51 <nand`> but that's the problem - the mesh is for calculating the index positions of whatever you're interpolating, yes?
13:38:53 <nand`> so getting a Double out is broken
13:39:00 <nand`> if I don't index by doubles
13:39:09 <rwbarton> hmm
13:39:31 <nand`> the only example it provides uses (Double -> Double) as the actual data; which of course gets indexed by Double just fine
13:39:35 <nand`> but I'm using [Double]
13:39:50 <nand`> yet it still forces the Double constraint on me, even though it's my instance and I can theoretically pick anything I want
13:40:54 <nand`> the only solutions I see here are: 1. the type signature is broken or 2. my assumption of what ‘Mesh’ is used for, and consequently my entire implementation, are broken
13:43:55 <mcstar> a mesh in this setting is a uniform grid over a (float, float)x(float,float) region
13:43:58 <rwbarton> so I think a(n instance of) Mesh is a bunch of points on the real line
13:44:17 <mcstar> if you give it some inner value, it will give back the indexes of the grind lines it belongs to
13:44:24 <mcstar> sorry, this is 1d
13:44:33 <rwbarton> it's (x_1, ..., x_n) where you have some equations f(x_1) = y_1, ..., f(x_n) = y_n you want to interpolate from
13:44:36 <mcstar> anyway, seems sensible enough to me
13:45:25 <nand`> rwbarton: but that's exactly the thing; my f is not :: Double -> Double
13:45:38 <rwbarton> that's fine
13:45:51 <nand`> how so?
13:45:59 <mcstar> 3 == 3.
13:46:19 <rwbarton> you imagine you are interpolating a function Double -> Double where it just so happens that all of the known values are at integer x
13:46:34 <nand`> so my approach of truncating the values was sensible?
13:46:44 <rwbarton> I think you're supposed to use tabulate
13:47:12 <rwbarton> if you are using tabulateFun and truncating the input that's not particularly sensible but it should end up being the same thing :)
13:47:44 <rwbarton> because I assume tabulateFun only passes your function points that are in the mesh and I assume you've arranged for those to all be integers
13:47:48 <nand`> yeah, I did use tabulate first but switched to tabulateFun because the results I was getting did not seem correct. (I get the same results with tabulateFun)
13:47:55 <tomh> dcoutts_: a while back someone here suggested I should bug you about alex-options and happy-options being unknown fields in cabal
13:48:18 <nand`> with what I have written now; interpolate [Just 1, Nothing, Just 2, Nothing, Just 3] ==> [1, 2, 3, 4, 5] <- and I have no idea where the extra numbers are coming from
13:48:19 <mcstar> nand`: if your values, that you are interpolating, are doubles, why would you truncate them?
13:48:35 <rwbarton> oh right, you have unknown gaps
13:48:50 <rwbarton> how are you making your mesh?
13:49:18 <mcstar> i dont see a way to make a non-uniform mesh
13:49:23 <rwbarton> right
13:49:28 <rwbarton> you would need to implement your own Mesh instance
13:49:46 <nand`> by storing a distrib :: [Bool] and, for input d; counting how many True values occur in (drop (truncate d) distrib)
13:49:58 <rwbarton> that just contains fromIntegral i for those i for which your list xs !! i is Just something
13:50:52 <nand`> for example, for [True, False, True, False, True] (as above) meshFindIndex 0 => 1; 1 => 1; 2 => 1; 3 => 2; 4 => 2; 5 => 3
13:51:14 <rwbarton> shouldn't it start at 0? otherwise looks good
13:51:19 <nand`> yeah, just saw that
13:51:34 <mcstar> what?
13:52:08 <mcstar> [True, False, True, False, True] is basically 0. to 4.
13:52:30 <rwbarton> right but the indices are 0, 1, 2, because the mesh has only 3 points
13:52:36 * hackagebot json-tools 0.4.0 - A collection of JSON tools  http://hackage.haskell.org/package/json-tools-0.4.0 (NicolasPouillard)
13:52:47 <nand`> the actual vector passed to tabulate contains three elements: 0, 1, 2
13:52:47 <mcstar> rwbarton: no, it should have 5 points
13:52:51 <rwbarton> oh hmm
13:52:53 <rwbarton> what?
13:53:05 <rwbarton> doesn't False mean I don't know the value at that integer?
13:53:07 <nand`> (at the same index positions, respectively)
13:53:10 <rwbarton> so there is no corresponding x_i at all?
13:53:36 <mcstar> .....
13:53:38 <mcstar> ABABA
13:53:43 <mcstar> first is the mesh
13:53:51 <mcstar> B are the missing values
13:53:58 <mcstar> but there must be a mesh point there
13:54:08 <mcstar> otherwise, how could you interpolate?
13:54:09 <rwbarton> tabulate doesn't let me say "no known value here"
13:55:05 <Sharyari> Hi. I would like to do something like a map, but on two lists. Something like map (>) [3,2] [2,4] => [true, false]. Is there such a function?
13:55:22 <MostAwesomeDude> Sharyari: zipWith?
13:55:25 <mcstar> you can only use a uniform mesh, with all the mesh points know
13:55:27 <mcstar> known
13:55:33 <MostAwesomeDude> > zipWith (>) [3,2] [2,4]
13:55:34 <lambdabot>   [True,False]
13:55:36 <rwbarton> or you can define your own mesh
13:55:39 <mcstar> after that, you can evaluate it at any x
13:55:47 <mcstar> yes
13:55:55 <Sharyari> MostAwesomeDude: Looks exactly right. Thank you
13:56:01 <MostAwesomeDude> Sharyari: Note that zip is zipWith (,)
13:56:06 <MostAwesomeDude> > zipWith (,) [3,2] [2,4]
13:56:06 <Sharyari> Can't believe I failed to google that :P
13:56:06 <lambdabot>   [(3,2),(2,4)]
13:56:08 <mcstar> but it doesnt make sense at all, if you want to have interolation across 5 points, to make a 3 point mesh
13:56:12 <MostAwesomeDude> No worries; it's not obvious. :3
13:56:31 <nand`> mcstar: why not?
13:56:31 <rwbarton> interpolation is across the whole interval [0,4] of Doubles
13:56:39 <tsou> Sharyari: in general if some function exists and you can spell-out its type, have a look at hoogle as well :)
13:56:44 <mcstar> nand`: cause, that is not how this works
13:56:50 <nand`> mcstar: then explain how this works
13:57:03 <nand`> it makes total sense to me
13:57:05 <nand`> just, it doesn't work
13:57:07 <nand`> for some reason
13:57:33 <mcstar> you are trying to do something that is first of all, not that simple, second of all this package is not designed to
13:57:49 <nand`> there is no package designed to do what I want to do, apparently
13:57:58 <parcs`> (!*!) :: (Functor m, Foldable r, Applicative r, Distributive n, Num a) => m (r a) -> r (n a) -> m (n a)
13:58:15 <tsou> Sharyari: *if you are wondering whether some function exists...
13:58:49 <mcstar> nand`: you could do this: put your values into a matrix, that contains the values of the image at the mesh points
13:58:54 <rwbarton> you can do it with this package, you just have to do some tricky work to build the mesh right
13:58:55 <mcstar> now, have a list of the missing points
13:59:02 <mcstar> start for them form some sensible value
13:59:15 <mcstar> define a fitness function, that involves some n-nearest nbors
13:59:20 <mcstar> and optimize
13:59:29 <mcstar> over the 'variables' i.e. the missing mesh values
13:59:41 <Sharyari> tsou: Will remember that, I'm trying to find basic functions all the time. Just been doing haskell two days
14:00:01 <nand`> I think it may be less work to just get out an elastic ruler and do it by hand
14:00:13 <mcstar> what i described is quite simple
14:00:35 <tsou> Sharyari: you'll love hoogle
14:01:13 <rwbarton> how about just defining meshFindIndex m x = case [ i | i <- [0..size m - 2], m ! i <= x && x < m ! (i+1) ] of [i] -> i; _ -> -1
14:02:30 <nand`> I think it may actually be my implementation of (!) that's incorrect
14:02:39 <rwbarton> that is also tricky
14:03:32 <nand`> I think I made an incorrect assumption there (that I'm mapping from some index space (Int) to their Double correspondents in the source function; in this case the vector)
14:03:36 <rwbarton> probably easiest to do a filter (isJust . snd) . zip [0..] $ myVals and index into that
14:03:37 <nand`> I defined it as unsafeIndex = const fromIntegral
14:04:20 <nand`> but on second though, I have no clue what the Int is used for, or where it comes from
14:04:23 <nand`> or what I'm supposed to be mapping to what
14:04:27 <rwbarton> it's the index of the mesh point
14:04:28 <nand`> thought*
14:04:41 <rwbarton> in your example [Just 1, Nothing, Just 2, Nothing, Just 3] the mesh points are 0, 2, 4
14:04:47 <rwbarton> (0, 2, 4 :: Double)
14:05:01 <nand`> why 2 and 4? they're 1 and 2 in the source function
14:05:07 <nand`> this must be the error
14:05:10 <rwbarton> because you have no data at 1 or 3
14:05:16 <rwbarton> source function?
14:05:30 <nand`> the source function :: Double -> Double  which maps 0 => 1; 1 => 2; 2 => 3
14:05:40 <nand`> that is
14:05:42 <nand`> the vector
14:06:02 <rwbarton> okay but the x-coordinates where those points live are 0, 2, 4
14:06:03 <rwbarton> right?
14:06:11 <tomh> anyone knows how to add build tool flags in cabal files?
14:06:16 <rwbarton> you have f(0) = 1; f(2) = 2; f(4) = 3 and you want to calculate f(1) and f(3)?
14:07:10 <nand`> yes
14:07:11 <rwbarton> (presumably getting f(1) = 1.5 and f(3) = 2.5? or have I misunderstood the whole operation here)
14:07:18 <nand`> no, that's correct
14:07:20 <mcstar> no, he is
14:07:37 * hackagebot certificate 1.2.8 - Certificates and Key Reader/Writer  http://hackage.haskell.org/package/certificate-1.2.8 (VincentHanquez)
14:07:37 <rwbarton> okay right, so your mesh is points 0, 2, 4 because that's where you know the input
14:07:50 <nand`> is unsafeIndex supposed to be something like an opposite to meshFindIndex?
14:07:54 <rwbarton> yes
14:08:01 <rwbarton> it just lists the points of the mesh
14:08:05 <nand`> there's my confusion
14:08:59 <rwbarton> e.g. unsafeIndex (UniformMesh a da _) i = a + fromIntegral i * da
14:09:17 <mcstar> nand`: in the real image, how big are the regions that you are missing? is there a sample image?
14:10:33 <rwbarton> BTW didn't you say you wanted to do this in 2D?
14:10:39 <mcstar> yes
14:10:43 <nand`> mcstar: in practice, gaps may be as large as 5 and as small as 0
14:10:54 <mcstar> wrt what?
14:10:59 <mcstar> 10000? 100?
14:11:13 <mcstar> what is the scale of the features of the image?
14:11:21 <nand`> 5 missing pixels per filled in pixel
14:11:31 <mcstar> whoa
14:11:46 <mcstar> ok
14:11:49 <nand`> rwbarton: I was thinking of doing it on a row-by-row basis and seeing what the result looks like
14:11:52 <mcstar> so thats something else entirely
14:12:05 <mcstar> mainly terrible
14:13:05 <rwbarton> you have like a random 20% of the pixels of an image and want to reconstruct the original?
14:13:42 <tomh> whats the best place to ask some cabal questions if not here?
14:13:56 <mcstar> #cabal
14:14:05 <mcstar> j/k
14:14:17 <nand`> rwbarton: the values always follow a pattern, but it's not clear in advance what pattern this is; furthermore, the 5 is an extreme value only present in one specific spot; usually there's a distance of at most 1 or 2
14:14:40 <rwbarton> i see
14:14:44 <mcstar> nand`: where does this data come from?
14:16:43 <nand`> mcstar: in principle, any digital image (after a preprocessing step which loses a lot of the original information - the goal is, in theory, to reconstruct the original image as closely as possible)
14:17:17 <nand`> this preprocessing step consists of a filter which obscures pixels according to a pattern
14:17:36 <nand`> and leaves the rest unchanged; the algorithm is supposed to interpolate these missing spots from the ones that weren't changed
14:17:56 <xplat> nand`: and why wouldn't you just leave the spots in in the first place?
14:17:59 <rwbarton> if you have such a large fraction of the pixels and since this is in 2D I agree that treating the interpolation as an optimization problem is likely to be easiest
14:18:12 <mcstar> or with a neural network
14:18:19 <rwbarton> e.g. minimize sum of squares of all neighboring pixel pairs
14:18:19 <mcstar> that is trained with different kinds of images
14:18:29 <mcstar> i.e. lighting conditions, and such
14:18:44 <mcstar> but how do you actually know the 'bad' pixels?
14:18:56 <xplat> how best to fill in missing pixels depends some on what sort of image it is
14:18:56 <mcstar> i understand that for the tests, you know it
14:19:00 <mcstar> but in general
14:19:18 <xplat> for example, the scale
14:19:48 <xplat> and whether it's photographic or line art
14:19:50 <nand`> mcstar: it's known in advance - they are marked as obscured
14:20:36 <mcstar> i know that you know now, but how do you know a live digital image?
14:20:43 <mcstar> on a *
14:20:48 <xplat> and what the overall density of 'obscured' pixels is
14:20:51 <nand`> this is not a general purpose “fill in the missing data” algorithm, thus the [Maybe Double] and not [Double] in the signatures I've been wishing for
14:21:34 <xplat> (and how clumpy it is)
14:21:36 <mcstar> id definitely do this in a more numerically oriented environment
14:21:48 <mcstar> and when you have your algorithm, rewrite it in haskell
14:22:19 <nand`> in practice, the pattern is known - in fact; I've determined that if I fail this ‘any-pattern’ algorithm I'll work on vastly simpler patterns optimized for a specific pattern instead
14:22:35 <acowley> How can I explicitly export a promoted type?
14:22:35 <nand`> err
14:22:40 <nand`> vastly simpler algorithms*
14:23:13 <nand`> mcstar: in effect, the purpose of this haskell program is to allow me to change the pattern and see the result more or less live
14:23:16 <xplat> is this some kind of text removal?
14:23:41 <astry> hi
14:23:46 <astry> dcoutts_: around? :)
14:23:50 <mcstar> haskell doesnt help you with that
14:24:03 <mcstar> matrix and optimization libraries are written in c or fortran
14:24:12 <nand`> I don't know C or Fortran
14:24:17 <mcstar> you dont have to
14:24:19 <xplat> mcstar: some of them have haskell wrappers, though
14:24:22 <astry> dmwit: or are you perhaps still there?
14:24:25 <mcstar> i mean, even in python id be pretty fast
14:24:49 <mcstar> xplat: yeah, and that is great
14:26:10 <nand`> I guess I could use existing programs aimed at letting me preview this kind of stuff (Mathematica? Photoshop?)
14:26:33 <xplat> mathematica seems to have some image processing stuff.  so does matlab.
14:26:56 <mcstar> mathematica is great in one respect
14:27:02 <mcstar> a lot of ready made stuff
14:27:05 <xplat> for photoshop it depends if you can do it with some combination of the filters PS already has
14:27:08 <mcstar> but programming in it, is horrible
14:27:15 <nand`> the only hindrances would be finding a free program that does the job well enough; and then getting familiar with this program and how to use it
14:27:52 <xplat> photoshop in theory is almost as programmable as GIMP, but programming is a lot more accessible in GIMP (you don't need an SDK etc)
14:27:55 <acowley> is there a short summary of the image processing ops you guys are looking to do?
14:28:01 <astry> hey everyone, i was wondering if my idea for a gtk2hs app would work.. basically it's an image viewer. i would like to be able to press space and hold it and have the program show images one after another in quick succession. I would like to register a function with timeoutAdd. This function would check an IORef Bool which says whether the spacebar is currently down or not. This IORef gets updated via the window's key press / key release events.
14:28:10 <astry> do you think using IORef's like this is a good idea?
14:29:30 <xplat> i don't know if it's a good idea, but it would work ...
14:29:46 <acowley> astry: Sure. You may want to capture application state in a record that is updated by the handlers and used by the view.
14:30:06 <acowley> the best granularity of IORefs depends on everything else
14:30:08 <astry> why would i do that?
14:30:50 <acowley> Suppose you want another bool to indicate that shift is held down, and then something to tell you what letter key is pressed, and you're going to consider all those things when deciding what to do. You might not want 3 IORefs.
14:30:56 <mcstar> nand`: another option: write a simple flood fill or similar alg. that takes the countours of the missing sections, each, and use the known and required mesh points with a successive bilinear interpolation
14:31:08 <mcstar> but i still think what i said earlier would be the best
14:31:11 <astry> oh right, yeah
14:32:15 <janua1> Hello, I am trying to write a small function that parses a string and returns a maybe int. customToInt :: String -> Maybe Int. I am using read, but I am unsure how to catch the exception it is throwing and turn it into a Nothing
14:32:53 <maukd> janua1: reads
14:33:01 <nand`> readMaybe
14:33:09 <acowley> astry: And if your GUI framework supports it, you might just write update a reference to a view function. This approach is described in a sigfpe post on reinversion of control or something like that.
14:33:27 <acowley> astry: That way you just stuff the updated record into a closure, and write the closure to the IORef
14:34:08 <astry> no idea how closures work in haskell
14:34:33 <astry> got any example code?
14:34:39 <acowley> handler keys = writeIORef drawWindow (myDraw keys)
14:35:02 <acowley> where myDraw :: Keys -> IO (), and drawWindow :: IORef (IO ())
14:36:03 <astry> how do i use that?
14:36:21 <astry> do i go to my view and just load the callback from the ioref?
14:36:46 <janua1> maukd: I'm not sure how to use reads
14:36:56 <astry> @type reads
14:36:57 <lambdabot> forall a. (Read a) => String -> [(a, String)]
14:37:09 <mcstar> [] if it wasnt succesful
14:37:37 <acowley> astry: Here's the blog post I mentioned, http://blog.sigfpe.com/2011/10/quick-and-dirty-reinversion-of-control.html
14:37:50 <acowley> astry: How useable that approach is depends on how you interact with your GUI framework
14:38:01 <janua1> Thats different to the reads i have
14:38:11 <typoclass> janua1: here, this faq answer should get you started http://www.haskell.org/haskellwiki/FAQ#How_do_I_catch_the_error_thrown_by_read_on_a_parse_failure.3F
14:38:59 <astry> acowley: right.. makes sense.
14:39:10 <janua1> My reads is... reads :: Read a => ReadS a
14:39:26 <tomh> hey typoclass, had any chance to look at my cabal file earlier?
14:40:28 <aristid> tomh: can you link it again?
14:41:39 <tomh> https://github.com/Intellicode/uurpc/blob/master/uurpc.cabal
14:41:52 <mcstar> janua1: thats ok
14:41:53 <typoclass> tomh: yeah ... i found it weird that it complains about 'alex-options' and 'happy-options', but otoh, earlier it claims it did find them in /usr/bin or whatever. other than that, yeah, 127 often means "file not found"
14:42:07 <mcstar> use it like String -> [(a, String)]
14:42:21 <janua1> mcstar: But i dont know how to use it
14:42:21 <tomh> typoclass: yeah I got that error now as a string, I modified the setup.hs
14:42:29 <tomh> I guess a bug in uuagc
14:42:31 <acowley> Now I want heterogeneously kinded tuples.
14:42:39 <tomh> or an "undocumented" feature
14:43:07 <tomh> typoclass: any idea what I can do about the alex-options and happy-options?
14:43:14 <mcstar> case reads "434" of [(n, _)] -> n; _ -> do something else
14:43:18 <janua1> mcstar: Oh, wait. I needed to specify what the a was
14:43:25 <typoclass> aristid: also see http://hpaste.org/75025 that's his build log
14:44:03 <typoclass> janua1: ReadS is a type alias, so your 'reads' is actually not different from what lambdabot showed http://www.haskell.org/ghc/docs/latest/html/libraries/base/Prelude.html#g:23
14:44:05 <aristid> tomh: did you try upping the cabal-version field to 1.8 or so?
14:44:13 <tomh> I guess
14:44:22 <tomh> I installed the latest platform
14:44:35 <aristid> tomh: no, there's a Cabal-version field in the cabal file.
14:44:43 <aristid> Cabal-version:       >=1.2
14:44:45 <typoclass> janua1: have you seen my message about the faq entry? it's question 5.12: http://www.haskell.org/haskellwiki/FAQ#How_do_I_catch_the_error_thrown_by_read_on_a_parse_failure.3F
14:44:48 <tomh> oh yeah
14:44:53 <tomh> maybe I should just put it on 1.2
14:45:05 <aristid> tomh: no, set it to >=1.8 and see what happens.
14:45:12 <acowley> Can I not define a multi param type class where the types come from different kinds?
14:45:32 <rwbarton> like MonadState?
14:47:03 <tomh> aristid: same error basically
14:47:49 <tomh> maybe I should just write a make script instead of cabal
14:47:54 <tomh> atleast that doesn't break -.-
14:48:04 <acowley> Ah, stupid me walking into the kind impoverished function type constructor
14:48:12 <acowley> Proxy to the rescue yet again
14:48:26 <aristid> tomh: it seems that too few people use alex/happy to find a lot
14:48:29 <aristid> on google
14:48:40 <tomh> yeah :/
14:48:57 <rwbarton> something major uses them
14:49:01 <tomh> then what do people use?
14:49:14 <rwbarton> language-c maybe?
14:49:34 <dcoutts> tomh: you shouldn't need alex options or happy options
14:49:54 <tomh> how come I don't need them?
14:50:01 <dcoutts> tomh: have they started adding new flags rather than directives in the source file or something?
14:50:05 <tomh> I noticed a big difference in speed when I had certain flags
14:50:23 <dcoutts> tomh: you mean like -g in alex?
14:50:28 <tomh> yes
14:50:47 <dcoutts> tomh: and cabal uses that automatically if you're building with ghc
14:51:19 <dcoutts> same with -g -a -c in happy
14:51:28 <tomh> ah ok
14:51:39 <tomh> I didn't knew that :)
14:51:39 <dcoutts> tomh: there's some other happy flags, but iirc they've also made them directives
14:51:55 <dcoutts> things that affect the meaning should go in the source file
14:52:47 <tomh> alright thanks :)
14:52:58 <tomh> seems to work, only thing left is debugging uuagc
14:53:34 <typoclass> tomh: so you've figured out the 127 thingies? if not you could always use strace
14:53:50 <tomh> typoclass: I modified setup.hs
14:54:00 <tomh> that resulted in a file not found error as you described
14:54:21 <tomh> it searches for ""
14:54:45 <rwbarton> well that's unhelpful
14:54:51 <tomh> exactly
14:55:03 <tomh> keeps things challenging
14:55:23 <Sharyari> Hi. I have a bug that results in a stack overflow, but I can't seem to find it. It's probably obvious, so if anyone would like to help me: http://pastebin.com/mM6rjUz7
14:55:28 <maukd> The paste mM6rjUz7 has been copied to http://hpaste.org/75026
14:57:25 <mcstar> do you compile with -O1/2 ?
14:57:41 <Sharyari> No, what does that do?
14:58:11 <Sharyari> Does not fix it though
14:58:26 <mcstar> sometimes it fixes it
14:58:54 <tomh> well time for sleep, thanks everyone
14:58:59 <shachaf> Compiles with optimizations. But you shouldn't trust compiler voodoo too much -- you should at least know why it's stack-overflowing.
14:59:17 <janua1> typoclass: I don't understand completely about the type alias stuff. I have seen the FAQ yes, but now i'm unsure how im meant to read the reads signature
15:00:06 <rwbarton> @hoogle ReadS
15:00:06 <lambdabot> Prelude type ReadS a = String -> [(a, String)]
15:00:06 <lambdabot> Text.ParserCombinators.ReadP type ReadS a = String -> [(a, String)]
15:00:06 <lambdabot> Text.Read type ReadS a = String -> [(a, String)]
15:00:29 <rwbarton> "type ReadS a = String -> [(a, String)]" means everywhere you see ReadS a you can replace it by String -> [(a, String)]
15:01:22 <Sharyari> I see, well, no point in solving project euler exercizes with built-in optimizations :)
15:02:37 <statusfailed> possibly dumb question: How do you draw values from a mixture of probability distributions?
15:02:38 * hackagebot snap 0.9.2.1 - Top-level package for the Snap Web Framework  http://hackage.haskell.org/package/snap-0.9.2.1 (GregoryCollins)
15:02:56 <janua1> rwbarton: I didn't know you could use type for a whole signature, i thought it could only map to another type?
15:03:41 <mcstar> Sharyari: what number?
15:04:07 <mcstar> (which problem)
15:04:24 <Sharyari> mcstar: 23
15:05:14 <mcstar> thats a 4-liner, i used intmap
15:05:16 <maukd> janua1: there is no "whole signature". the thing on the right side of a :: is just a type
15:06:54 <Sharyari> mcstar: well, I also used intMap. But also a lot more than 4 lines :)
15:07:38 * hackagebot functor-combo 0.2.1 - Functor combinators with tries & zippers  http://hackage.haskell.org/package/functor-combo-0.2.1 (ConalElliott)
15:12:38 * hackagebot TypeCompose 0.9.4 - Type composition classes & instances  http://hackage.haskell.org/package/TypeCompose-0.9.4 (ConalElliott)
15:13:13 <moobull69> does anyone happen to know where lambdabot gets installed to after it is installed?
15:14:39 <mikeplus64> mmooif you installed it using cabal, probably ~/.cabal/bin
15:14:42 <mikeplus64> moobull69:
15:15:13 <moobull69> ooh ok, I need to recompile it anyway with the 7.2 ghc too lol
15:15:20 <moobull69> ill check ty
15:16:25 <whittle> I want to use a package (riak) that provides a specific exception type (RiakException) that is an instance of Control.Exception.Base.Exception. Is there any danger in making RiakException an instance of Control.Monad.Trans.Error.Error as well, so that I can use it in an ErrorT?
15:18:07 <whittle> Also, is the ErrorT in transformers or mtl preferred?
15:22:38 * hackagebot onu-course 1 - Code for the Haskell course taught at the Odessa National University in 2012  http://hackage.haskell.org/package/onu-course-1 (RomanCheplyaka)
15:53:31 <pr> @let bazfoo = sum . map digitToInt . show
15:53:32 <lambdabot>  Defined.
15:53:36 <pr> @type bazfoo
15:53:37 <lambdabot> forall a. (Show a) => a -> Int
15:53:55 <pr> strange. here's what i get with ghci:
15:53:58 <pr> Prelude Data.List Data.Char> let f = sum . map digitToInt . show
15:53:58 <pr> Prelude Data.List Data.Char> :t f
15:53:59 <pr> f :: () -> Int
15:54:29 <glguy> GHCi uses "extended defaulting rules"
15:54:58 <glguy> http://www.haskell.org/ghc/docs/6.6/html/users_guide/ch03s04.html#extended-default-rules
15:55:22 <glguy> I don't know what 7.4.2 has to say about it, but that's what came up with I googled
15:55:43 <pr> oh, ok, that makes sense. thanks
15:56:11 <shachaf> :set -XNoMonomorphismRestriction
15:56:15 <startling> is mighttpd any good?
15:56:47 <pr> shachaf: thanks!
16:07:49 <janua1> If I have three Maybe Int, how can i add the three of them? I was thinking perhaps applicative functors, but i'm not sure how.
16:08:05 <benmachine> janua1: applicative functors are exactly what you want!
16:08:11 <benmachine> well.
16:08:14 <janua1> Errr!!
16:08:15 <cmccann> :t liftA2 (+)
16:08:16 <lambdabot> forall a (f :: * -> *). (Num a, Applicative f) => f a -> f a -> f a
16:08:17 <benmachine> actually there's more than one way to get what you want
16:08:21 <janua1> I tried THIS
16:08:30 <benmachine> do-notation would be the easy way
16:08:39 <janua1> (+) <$> Just 1 <*> Just 2 <*> Just 3... But it doesnt work
16:08:52 <benmachine> janua1: because (+) takes two arguments, not 3
16:08:56 <glguy> :t asum :: [Maybe Int] -> Maybe Int
16:08:57 <lambdabot> Not in scope: `asum'
16:09:02 <cmccann> :t \xs -> sum <$> sequenceA xs
16:09:03 <lambdabot> Not in scope: `sequenceA'
16:09:03 <glguy> Data.Foldable
16:09:05 <benmachine> janua1: if you define add3 x y z = x + y + z and then use that instead, it'll work
16:09:11 <cmccann> pf.
16:09:21 <cmccann> :t \xs -> sum <$> sequence xs
16:09:21 <janua1> benmachine: So how should i do this, instead of defining a new add function
16:09:22 <lambdabot> forall a (f :: * -> *). (Num a, Monad f, Functor f) => [f a] -> f a
16:09:29 <benmachine> glguy: umm, what are you expecting that to do exactly
16:10:01 <glguy> I'd have to think about it now that you ask :)
16:10:10 <glguy> I guess take the first non-nothing
16:10:21 <benmachine> janua1: there are several ways forward - let me paste a few
16:11:56 <cmccann> > sum <$> sequence [Just 1, Just 2, Just 3]
16:11:57 <lambdabot>   Just 6
16:12:01 <cmccann> janua1, something like that work?
16:12:08 <cmccann> > sum <$> sequence [Just 1, Just 2, Nothing]
16:12:09 <lambdabot>   Nothing
16:14:19 <benmachine> janua1: http://hpaste.org/75027
16:15:51 <startling> :t fmap sum . sequence
16:15:52 <lambdabot> forall a (f :: * -> *). (Num a, Functor f, Monad f) => [f a] -> f a
16:18:53 <pr> :t if'
16:18:54 <lambdabot> Not in scope: `if''
16:19:03 <elliott> if' p q r = if p then q else r
16:19:03 <lambdabot> elliott: You have 1 new message. '/msg lambdabot @messages' to read it.
16:19:04 <elliott> lambdabotism
16:19:08 <elliott> lambdabot: hi
16:19:11 <pr> :)
16:19:36 <pr> hah, of course. it's just a function, and works, thanks to laziness
16:20:00 <elliott> yes, if...then...else is just syntax sugar for a simple function (or case)
16:20:11 <elliott> some argue the sweetness
16:20:58 <janua1> benmachine cmccann: I think I like the sequence way the most, the problem is i have an arbitrary amount of Maybe Int
16:21:08 <janua1> That are not in a sequence
16:21:16 <janua1> So i guess i'll just have to put them into one
16:21:19 <pr> hmm, what is if's type? Bool -> a -> a?
16:21:36 <cmccann> I'm not sure how you're having an arbitrary number if they're not in a sequence.
16:21:36 <benmachine> yep
16:21:42 <benmachine> pr: no, one more a
16:21:56 <cmccann> :t \b t f -> if b then t else f
16:21:57 <lambdabot> forall t. Bool -> t -> t -> t
16:22:01 <pr> ah of course :)
16:22:21 <janua1> cmccann: Good response, i guess they are in a sequence already
16:22:38 <cmccann> and yes, "if" is mostly syntactic bitterness :P
16:41:09 <startling> is there an extension that will let me write a type annotation twice if they're synonyms?
16:41:39 <Cale> startling: well, you can give two type annotations to an expression
16:41:53 <Cale> > ("hello" :: String) :: [Char]
16:41:54 <lambdabot>   "hello"
16:42:11 <startling> oh, hm
16:54:00 <elliott> cmccann: hi!
16:54:09 <janua1> I have a function with the signature :: IO Handle -> [IO Int], but when i try to use x <- hGetLine in the do block, it fails with type errors. What am i doing wrong?
16:54:27 <elliott> janua1: the function should probably have the signature IO [Int] instead.
16:54:27 <cmccann> 'sup, elliott
16:54:46 <latro`a> if it actually is a [IO Int] you can make a IO [Int] with sequence
16:54:48 <elliott> [IO Int] is a list of side-effectful actions that give integers when executed, whereas IO [Int] is an action that gives a list of integers when executed
16:55:00 <elliott> (execution like printing out something, asking for input, etc.)
16:55:14 <elliott> cmccann: not much :)
16:55:21 <cmccann> not execution like executing someone for their crimes
16:55:25 <cmccann> though I guess it could do that
16:55:33 <cmccann> gotta be careful with IO
16:55:34 <elliott> cmccann: did you ever get that iteratee-esque library working?
16:55:43 <elliott> unsafeCapitalPunishment
16:56:16 <cmccann> no, I was still stuck on one particular piece when other stuff took over all my spare time for a while
16:56:53 <elliott> mm
16:56:59 <elliott> too bad
16:57:24 <cmccann> and after further thought I'm not sure what I was trying to accomplish was ever going to work in that form
16:57:26 <janua1> elliott: Thanks. I didn't figure it out, but i think thats enough of this monad stuff for one night!
16:58:23 <cmccann> so now I'm thinking of alternate approaches to fill in the missing piece, since I still want to get the idea working and try it in practice
16:58:41 <elliott> janua1: well, just changing the function signature should help, at least :)
16:59:02 <elliott> just think of [IO Int] as "a bunch of descriptions of how to do a bunch of IO to get an Int", and IO [Int] as "a description of how to do a bunch of IO to get a list of Ints", basically
16:59:04 <janua1> elliott: No, it didnt
16:59:35 <elliott> janua1: mm, then there's some other problem in your function body... hop eyou work it out
16:59:50 <latro`a> you want to paste what you have?
16:59:59 <cmccann> elliott: so unless you want to hear an extended diatribe on attaching semantic interpretations to linear logic I don't have much to show you right now
17:01:02 <latro`a> er
17:01:04 <latro`a> @ janua1
17:01:10 <elliott> cmccann: sounds thrilling, but I know little enough linear logic that it would probably be wasted on me :p
17:01:10 <janua1> Don't judge me :) http://hpaste.org/75028
17:01:52 <elliott> janua1: you're trying to append [x] (an [Int]) and listNumbers h (an IO [Int]) there
17:01:56 <latro`a> yeah
17:01:58 <cmccann> elliott, yes, that is why it would be an extended diatribe instead of a moderately sized one
17:02:01 <elliott> the latter isn't a list, but rather a description of how to do some IO to produce a list
17:02:08 <latro`a> also, there's no need to use append
17:02:12 <elliott> you probably want: do { xs <- listNumbers h; [x] ++ xs }
17:02:13 <elliott> er
17:02:16 <elliott> you probably want: do { xs <- listNumbers h; return ([x] ++ xs) }
17:02:37 <ion> or ([x] ++) <$> listNumbers h
17:02:38 <elliott> (note that [x] ++ xs is the same as x:xs)
17:02:39 <janua1> hmm
17:02:51 <cmccann> elliott, though incidentally I put together a simple model of linear logic in Haskell that (I think) makes it much clearer how things "work" in some sense
17:03:09 <elliott> janua1: basically, do { xs <- listNumbers h; return ([x] ++ xs) } is a description that reads "do the actions in listNumbers h, and call the resulting [Int] 'xs'. then, simply return [x] ++ xs"
17:03:37 <elliott> Haskell makes this distinction between things and descriptions of how to do something that happens to produce some things all over the place, especially when dealing with IO
17:03:55 <janua1> So is this a new do inside the do
17:04:08 <elliott> (consider that you can produce an IO [Int] which produces a list of random numbers, but not an [Int] that is a list of random numbers; Haskell separates out the side effects: a list of numbers is just one thing, but a description of how to produce a list of numbers can produce any number of such lists)
17:04:21 <elliott> janua1: yes, when using if...then...else or case inside a do block you need another do block inside the cases
17:04:32 <janua1> Oh.
17:04:36 <elliott> (unless you just have one expression, in which case you can omit the "do", of course; the same rules apply as to the expression you put after a =)
17:04:52 <elliott> cmccann: sounds interesting
17:05:00 <latro`a> Just x -> do {xs <- listNumbers h; return (x:xs)}
17:05:07 <latro`a> is what elliott means
17:05:16 <janua1> elliott: Is the case correct then? Are you just referring to after the Just x block in the case statement?
17:05:21 <cmccann> elliott: it would make a good blog post, but for the minor detail that I don't have a blog
17:05:24 <janua1> Ahhhh
17:05:28 <latro`a> err...but without the outer return
17:05:59 <elliott> oh, yes, your return before the case is wrong
17:06:03 <elliott> you just want "case" where you have "case $ return"
17:06:09 <elliott> err... "return $ case", rather
17:06:24 <elliott> janua1: and _ -> [] should be _ -> return [] instead
17:06:45 <elliott> cmccann: I hear all the cool people use github repositories as blogs these days
17:07:30 <rwbarton> use hackage as your blog
17:07:30 <cmccann> maybe I should figure out how to do that
17:07:39 <cmccann> rwbarton, but I'm not edwardk
17:08:10 <Hail_Spacecake> is there a way in ghci to see what module an identifier is imported from?
17:09:19 <janua1> Oooh
17:09:27 <ivanm> Hail_Spacecake: :info
17:09:33 <ivanm> well, it tells you where it's defined
17:09:34 <Ralith> simon: ah; I find I just can't stand latency in response to my input.
17:09:35 <janua1> elliott: return ([x] ++ xs)  Didn't work at all
17:09:44 <janua1> But return(x:xs) did
17:09:45 <Jello_Raptor> this isn't exactly a haskell question, but is there a pandoc compatible live preview for latex?
17:09:59 <ivanm> janua1: why use [x]++ rather than x: in the first place?
17:10:11 <ivanm> Jello_Raptor: markdown-mode can use pandoc
17:10:16 <ivanm> but it's not live
17:10:28 <Hail_Spacecake> thanks!
17:10:32 <elliott> janua1: it is literally impossible for ([x] ++ xs) not to work but for (x:xs) to, so I don't know what you did :P
17:10:39 <ivanm> (and from what I can tell everyone agrees markdown-mode sucks, but no-one can be bothered writing a better one)
17:10:48 <frio> god i love pandoc
17:10:49 <elliott> :t \x xs -> [x] ++ xs
17:10:50 <lambdabot> forall t. t -> [t] -> [t]
17:10:52 <elliott> :t \x xs -> x:xs
17:10:53 <lambdabot> forall a. a -> [a] -> [a]
17:11:18 <ivanm> elliott: see, there's a big difference! a /= t !!!
17:11:19 <ivanm> :p
17:11:33 <latro`a> wake up sheeple, variable names matter!
17:12:05 <elliott> clearly by parametricity we can conclude that the letters "a" and "t" are there same
17:12:05 <cmccann> pf, a and t are equivalent up to isomorphism
17:12:20 <Jello_Raptor> ivanm: ahh ... i'm a vim person myself. I sort of really want a pandoc style latex DSL but where I can define stylesheets and similar.
17:12:43 <ivanm> Jello_Raptor: come again?
17:12:45 <ion> :t [\x xs -> [x] ++ xs, \x xs -> x:xs]
17:12:46 <lambdabot> forall t. [t -> [t] -> [t]]
17:13:47 <shachaf> > let (x,xs) = ('a',"bcd") in let (++) = 5 in ([x] ++ xs)
17:13:48 <lambdabot>   5
17:13:50 <shachaf> > let (x,xs) = ('a',"bcd") in let (++) = 5 in (x:xs)
17:13:51 <lambdabot>   "abcd"
17:14:13 <Jello_Raptor> ivanm: think pandoc markdown instead of html, and some DSL instead of css, and it'll convert to latex. Templates are annoyingly restrictive, and I find that if i could i'd fuck with syntax on a per project basis as suits me.
17:14:17 <janua1> this is driving me nuts. It's time to sleep! Thanks elliott and all
17:14:44 <ion> > let (x,xs) = ('a',"bcd") in let (++) = 5 in let x:xs = [x]++xs in (x:xs)
17:14:45 <lambdabot>   No instance for (GHC.Num.Num [t])
17:14:45 <lambdabot>    arising from a use of `e_15' at <inter...
17:14:45 <ivanm> Jello_Raptor: pandoc uses templates for what I think you're after
17:16:34 <elliott> janua1: glad i could help :p
17:17:00 <Jello_Raptor> ivanm: I know, they're not quite as powerful as I would like or meant for what i'm thinking of, and I have no idea where to start even reading pandoc's source. (I'm a newb)
17:17:28 <ivanm> Jello_Raptor: well, I'm still not sure what a css-like DSL for latex even _means_ :p
17:17:55 * ivanm still writes his LaTeX in LaTex
17:18:02 <ivanm> s/x$/X/
17:18:06 <ivanm> shocking concept, I know :p
17:20:40 <Jello_Raptor> ivanm: css like only in the sense of style/semantic seperation. The details would have to necessarily be completely different. Also latex is ugly >_< and I don't like having to see it even in tiny bits, at least not in my content.
17:21:36 <startling> wow, (>=>) is nice to use
17:25:27 <scp> howdy haskell-ites
17:26:31 <scp> So, I have this situation -- I'm writing a parser for a compiler
17:26:47 <scp> and it's possible that I might want to just give up on parsing at a given point (i.e. too many errors)
17:27:06 <scp> in other languages I might panic or throw an exception, and catch it at the top of the parser
17:27:08 <Ralith> isn't one error generally too many?
17:27:16 <scp> yes, one is my current threshold =P
17:27:17 <cmccann> not if you want good error messages
17:27:38 <Ralith> perhaps if your syntax is excessively complex
17:27:41 <scp> I'm not yet a sophisticated enough compiler-writer to produce more than one reliable message
17:27:42 <startling> scp, what parsing library?
17:27:53 <scp> startling: I'm writing the parser from scratch
17:28:13 <scp> I'm masochistic
17:28:19 <startling> scp: oh. so you might want to make your parser an Alternative
17:28:21 <benmachine> Ralith: one good example is that if you have not-in-scope errors, you might want all of them instead of just one
17:28:42 <scp> startling: What is this 'Alternative'?
17:28:53 <startling> scp: or the results of your parser or whatever, depending on your setup
17:28:57 <benmachine> scp: wait a sec, what errors are you detecting *during parse*?
17:29:01 <Ralith> benmachine: those are easily handled on a second pass
17:29:04 <YayMe> I thought we were haskellers not haskellites
17:29:06 <startling> scp: it's in Control.Applicative
17:29:08 <benmachine> I mean, apart from parse errors, which are pretty hard to continue from
17:29:13 <YayMe> and by we I mean not me
17:29:15 <benmachine> YayMe: I'm a haskelltron
17:29:26 <Ralith> benmachine: well, we're discussing parse errors, so...
17:29:31 <startling> haskelloff.
17:29:58 <scp> startling: oh, I see. I am using a state monad atm, keeps track of where I am in the token stream
17:30:07 <scp> startling, possibly very bad haskell, I'm learning =P
17:30:13 <Jafet> Haskellmania
17:30:34 <benmachine> scp: not unreasonable. I've used StateT s Maybe as a parser before
17:30:49 <benmachine> StateT s [] is nice if you're fond of ambiguity
17:31:07 <YayMe> benmachine: impressive. so have you decided to write 2 applications, a javascript client and a haskell server? or are you still trying to avoid 2 code bases?
17:31:22 <benmachine> YayMe: I have absolutely no idea what you are talking about
17:31:30 <parcs`> i've never used StateT s Maybe as a parser. instead i just used parsec
17:31:30 <scp> It's currently (State ParserState (Maybe SyntaxTree))
17:32:09 <YayMe> benmachine: I guess benmachine /= ben from last night
17:32:20 <benmachine> YayMe: indeed we are different people
17:32:24 <scp> parcs`: I'm using the parser to learn the language, I write one in every language I learn
17:32:43 <parcs`> scp: hmm that's not good. you should make any potential failures get handled implicitly
17:32:53 <benmachine> YayMe: it's kind of frustrating, I normally highlight on ben but I can't in here
17:32:56 <scp> parcs`: how do you mean?
17:32:59 <benmachine> YayMe: pitfalls of having a common name
17:33:28 <parcs`> scp: like benmachine said use StateT ParserState Maybe SyntaxTree
17:33:38 <benmachine> parcs`: I wouldn't say it's *bad*, just that it could be better
17:33:59 <YayMe> scp: there's a neat idea, I'm using euler to get more haskelly but maybe parser is a good way
17:34:13 <benmachine> YayMe: parsers in haskell are great
17:34:23 <benmachine> euler's... okay but quite specific
17:35:13 <benmachine> scp: the crucial difference between StateT s Maybe a and State s (Maybe a) is where the Maybe goes
17:35:31 <benmachine> scp: in StateT s Maybe a, you get a state and turn it into Maybe a new state and a value
17:35:45 <benmachine> scp: in State s (Maybe a) you get a state and you turn it into a new state and Maybe a value
17:35:51 <parcs`> benmachine: error propagation would have to done explicitly with scp's parser type
17:35:52 <scp> benmachine: ohhhh, that makes a lot of sense
17:36:11 <benmachine> scp: when I wrote a parser that was StateT String Maybe Exp, I don't care what string is left if the parse fails, so the former makes more sense
17:36:29 <parcs`> which is pretty bad for a parser meant as a exercise for learning the language
17:36:53 <scp> benmachine: Here's my pitfal for that. I want to propagate an error message up the stack
17:37:10 <parcs`> he might as well pass the state around explicitly if he's going to propagate failure explicitly
17:37:12 <benmachine> scp: ah, well, maybe you want Either ErrorType instead of Maybe
17:37:26 <benmachine> parcs`: nah, some abstraction is better than none
17:37:30 <scp> benmachine: Maybe I should write my own 'maybe-like' monad that behaves like Nothing, but propagates a value with Nothing
17:37:38 <benmachine> scp: that's Either :)
17:37:59 <benmachine> at least, if you're using a version of GHC after the whole monad-instance mess got sorted out, it's Either
17:38:36 <parcs`> scp: consider defining a custom monad instead of using monad transformers
17:39:10 <benmachine> you can do that too
17:39:28 <scp> so, like forsaking State and everything
17:39:52 <parcs`> forsaking the State monad, but not the idea of a state monad
17:40:45 <benmachine> I think it's neat to know that you can do this without writing a single Monad instance of your own
17:40:59 <benmachine> but it can be easier to understand if you just go and do all the legwork yourself
17:41:08 <benmachine> so it's a tradeoff depending on what you want to learn, I suppose
17:41:35 <parcs`> though i think it's better to learn from the top down and use parsec to get an idea of how a good parsing interface should look like, and then possibly define your own parsing interface
17:42:39 <scp> I'm a bottom up guy =]
17:42:49 <scp> can't stand not knowing what's going on underneath
17:43:16 <benmachine> my advice is, stop doing that :P
17:43:19 <parcs`> i can, which is why i use haskell in the first place. abstraction is awesome
17:43:36 <benmachine> realise how powerful it makes you when you allow yourself to not know things
17:43:44 <hpaste> scooty-puff pasted “mapError” at http://hpaste.org/75030
17:43:59 <benmachine> well.
17:44:00 <Polarina> Why is it that each time I do some programming in an imperative language, I get frustrated at lots of things and want to switch to a functional programming language. And each time I do functional programming, I get frustrated at lots of things and want to go back to an imperative programming language? :(
17:44:00 <scooty-puff> does something like the above paste already exist?
17:44:05 <benmachine> that could easily be interpreted wrongly
17:44:38 <benmachine> I do think it's a good idea to have reimplemented much of haskell's basic libraries as a learning exercise
17:44:43 <benmachine> at one time or another
17:44:49 <benmachine> or at least to know how it's done
17:45:39 <parcs`> Polarina: you should check out this totally awesome multi paradigm language called haskell
17:46:00 <scp> benmachine, parcs`, thanks for your help
17:46:28 <scp> benmachine, parcs`: I'll take the haskell knowledge, not ready for the philosophical advice yet =P, I'll take it under advisement though
17:46:34 <Polarina> parcs`, doing imperative programming in Haskell just feels wrong. I keep going between C and Haskell. :/
17:47:00 <benmachine> scp: ignore my philosophical advice, I think >_>
17:47:01 <Ralith> Polarina: I've been doing some imperative stuff in haskell lately; it's still a nicer experience than C.
17:47:05 * cmccann would rather do imperative programming in Haskell, it's better at it
17:47:06 <benmachine> it came out wrong, I'd have to think about it more
17:47:15 <benmachine> imperative Haskell is pretty nice
17:48:00 <parcs`> scp: :) good luck with your parser
17:50:01 <Polarina> I've been trying to do some game programming with FRP. I have never gotten it to work nicely. Always having to squeese out the entire "state" each frame for rendering. Getting user input in..
17:53:14 <parcs`> why not use idiomatic haskell?
17:53:38 <Ralith> instead of FRP?
17:53:48 <scooty-puff> "why not stop sucking, and start being awesome"
17:53:57 <parcs`> frp is still pretty experimental
17:54:23 <parcs`> or rather, frp libraries are
17:54:33 <mikeplus64> Polarina: i like glfw (use glfw-b), you set a callback for input
17:54:34 <Polarina> Idiomatic?
17:55:00 <cmccann> pf, callbacks. let me have my own event loop plzkthx.
17:55:05 <parcs`> Polarina: idiomatic as in not-frp :P
17:55:12 <Polarina> Oh.
17:55:22 <mikeplus64> cmccann: then you can use SDL
17:55:42 <Ralith> pf, SDL. let me have OpenGL 3.2+ please.
17:55:55 <parcs`> you can always convert from callback <-> polling
17:56:10 <Polarina> Ralith, I think FreeGLUT can give you OpenGL 3+
17:56:24 <mikeplus64> Ralith: you can use opengl 3.2+ just fine with sdl, can't you?
17:56:34 <Ralith> Polarina: see cmccann's comment.
17:56:43 <Ralith> mikeplus64: not really, no.
17:56:51 <mikeplus64> why?
17:57:07 <cmccann> I thought SDL just gave you a GL context and then stayed out of the way
17:57:12 <mikeplus64> yeah
17:57:16 <cmccann> but I haven't really done anything with it in ages :[
17:57:17 <Ralith> you have to explicitly request a 3.2+ context.
17:57:18 <parcs`> well you can't ask for a core/compat profile with sdl
17:57:21 <Ralith> SDL doesn't support the new API for that.
17:57:36 <cmccann> lame!
17:57:39 <Ralith> so, it gives you the wrong context.
17:57:42 <mikeplus64> did not know that (happily using GLFW-b :))
17:58:18 <Ralith> SDL2 will support it but is perpetually incomplete.
17:59:51 <parcs`> i think sdl2 is slated to be released "soon"
17:59:56 <parcs`> also development is pretty active http://hg.libsdl.org/SDL/
18:01:07 <Ralith> it's been several years, hasn't it?
18:01:16 <Ralith> for how much of that has it been slated for 'soon'
18:04:11 <parcs`> i'm basing "soon" off of this http://lists.libsdl.org/pipermail/sdl-libsdl.org/2012-July/085111.html
18:05:07 <Ralith> seems reasonable
18:05:10 <Ralith> here's to hoping they follow through!
18:17:24 <startling> where do I read about Settable and Gettable from `lens`?
18:18:06 <startling> oh, right, Control.Lens.Internal
18:19:40 <YayMe> has anyone here played a lot of euler?
18:21:29 <xplat> is there a quick fix for directory-1.2.0.0 not building on the platform?
18:21:59 <acowley> OpenCV bindings are now smothered in DataKind goodness
18:22:01 <xplat> says that try/catch are ambiguous between IO.System.Error and Control.Exception.Base
18:22:22 <xplat> acowley: cool
18:22:55 <acowley> I track color depth, color channels, and the presence of a region-of-interest spec in the image type
18:22:55 <ivanm> xplat: use an older version?
18:23:29 <ivanm> acowley: sounds interesting
18:24:41 <acowley> ivanm: I think so! WIth these latest upgrades, I'm happier with the code. I do a lot of nasty stuff to keep speed up, so it's very fast. I need to take the time to write up a blog post about it.
18:24:52 <acowley> I started one a while ago and got bogged down with saving sample videos and such.
18:24:53 <xplat> ivanm: ah, that might work, the thing that was depending on it has a flag
18:25:15 <ivanm> I've never used opencv and don't think I have a reason to; but I'm curious how you use DataKinds
18:25:16 <acowley> If you want to take video from your webcam, process it, and save it to a video file… it's a one liner.
18:25:27 <acowley> It's pretty trivial use of DataKinds
18:25:36 <acowley> for instance, data Channels = Monochromatic | Trichromatic
18:25:43 <acowley> data Image (c:Channels) … where
18:25:58 <ivanm> ahhhh
18:26:10 <acowley> it's important for OpenCV because some functions are only defined on, say, monochromatic images
18:26:18 <acowley> misuse of the library functions is caught by the type checker
18:26:26 <ivanm> still interested in that blog post you might get around to writing :p
18:30:35 <xplat> how many lines is it to find green potatos and remove them from the line?
18:30:48 <xplat> potatoes?
18:31:02 <acowley> I bet 1
18:31:15 <acowley> assuming nothing else is green :P
18:31:51 <xplat> greening is a little more subtle than that ...
18:31:58 <johnw> cool, I just discovered that \x -> f x x = join f
18:32:42 <xplat> > join (+) 2 -- it's just that simple
18:32:43 <lambdabot>   4
18:33:01 <scp> woh
18:33:11 <scp> > 1 + 1
18:33:11 <pr> > join (*) 12
18:33:12 <lambdabot>   2
18:33:12 <lambdabot>   can't find file: L.hs
18:33:31 <xplat> pr: transient error, try again
18:33:37 <pr> > join (*) 12
18:33:38 <lambdabot>   144
18:33:40 <pr> there we go
18:34:23 <maukd> > iterate (join f) x
18:34:24 <lambdabot>   Ambiguous occurrence `f'
18:34:25 <lambdabot>  It could refer to either `L.f', defined at <local...
18:34:30 <xplat> > join const "hello"
18:34:30 <maukd> @undefine
18:34:31 <lambdabot>   "hello"
18:34:37 <xplat> er
18:34:48 <maukd> > iterate (join f) x
18:34:49 <lambdabot>   [x,f x x,f (f x x) (f x x),f (f (f x x) (f x x)) (f (f x x) (f x x)),f (f (...
18:34:55 <xplat> > join join "hello"
18:34:55 <pr> heh
18:34:56 <lambdabot>   Occurs check: cannot construct the infinite type:
18:34:56 <lambdabot>    m = (->) (m (m a))
18:35:11 <cmccann> :t fmap fix return
18:35:12 <lambdabot> forall a. a -> a
18:35:22 <benmachine> :t join join
18:35:23 <lambdabot>     Occurs check: cannot construct the infinite type:
18:35:24 <lambdabot>       m = (->) (m (m a))
18:35:24 <lambdabot>     Probable cause: `join' is applied to too few arguments
18:35:30 <cmccann> > fmap fix return ":D"
18:35:31 <lambdabot>   ":D"
18:36:15 <xplat> cmccann: :)
18:36:25 <pr> > iterate (join (+)) 1
18:36:26 <lambdabot>   [1,2,4,8,16,32,64,128,256,512,1024,2048,4096,8192,16384,32768,65536,131072,...
18:36:29 <pr> neat
18:37:07 <maukd> > fix ((1 :) . map (2 *))
18:37:09 <lambdabot>   [1,2,4,8,16,32,64,128,256,512,1024,2048,4096,8192,16384,32768,65536,131072,...
18:37:47 <maukd> > fix (((.) (1 :) . (.)) (2 *))
18:37:49 <lambdabot>   [1,2,4,8,16,32,64,128,256,512,1024,2048,4096,8192,16384,32768,65536,131072,...
18:38:07 <pr> it's getting scary
18:38:22 <scp> > [2^x | x <- [1..]] -- my best =[
18:38:23 <lambdabot>   [2,4,8,16,32,64,128,256,512,1024,2048,4096,8192,16384,32768,65536,131072,26...
18:38:35 <xplat> > join (fmap.const) "hello"
18:38:36 <scp> darn, should have done [0..]
18:38:37 <lambdabot>   ["hello","hello","hello","hello","hello"]
18:38:40 <gdoteof_> i am trying to get a random item from a list
18:38:48 <maukd> :t randomRIO
18:38:49 <lambdabot> forall a. (Random a) => (a, a) -> IO a
18:39:08 <xplat> > join $ join (fmap.const) "hello"
18:39:10 <maukd> :t \xs -> randomRIO (0, length xs - 1)
18:39:10 <lambdabot>   "hellohellohellohellohello"
18:39:11 <lambdabot> forall a. [a] -> IO Int
18:39:19 <gdoteof_> i see buy, why IO ?
18:39:22 <maukd> :t \xs -> fmap (xs !!) $ randomRIO (0, length xs - 1)
18:39:23 <lambdabot> forall a. [a] -> IO a
18:39:24 <gdoteof_> s/buy/but/
18:39:34 <maukd> to access the random number generator
18:40:00 <xplat> gdoteof_: you want it to get a different random item each time you run your program, right?
18:40:28 <YayMe> ok, haskell-mode.. let's see about you..
18:40:54 <YayMe> also, ansi-terminal lib, let's see about you.. has anyone does any ncurses type stuff in haskell?
18:41:18 <xplat> gdoteof_: trying to do a random choice in pure code would be like http://www.xkcd.com/221/
18:41:40 <YayMe> worked for sony
18:43:30 <gdoteof_> xplat: yes.  that makes sense
18:44:58 <cmccann> 7 is a more random number than 4
18:45:04 <cmccann> empirically speaking
18:45:25 <startling> randomNumbers = repeat 7
18:45:33 <centrinia> > randomNumbers
18:45:33 <acowley> Always bet on ⊥
18:45:34 <lambdabot>   Not in scope: `randomNumbers'
18:45:44 <sipa> you need a probability model to make such claims
18:45:47 <centrinia> @let randomNumbers = repeat 7
18:45:48 <lambdabot>  Defined.
18:45:49 <centrinia> > randomNumbers
18:45:54 <lambdabot>   [7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,...
18:46:04 <cmccann> see here for details: http://arunshanbhag.com/2011/11/19/random-number-poll-answers/
18:46:22 <acowley> Just make sure you sample your randomNumbers list at a random index. Say, 7.
18:46:43 <sipa> cmccann: interesting; so you're talking about a human-generated digits
18:46:48 <Dodek> nothing is random, everything is deterministic, universe is finite and quantized, there are finite number of states, so we'll either enter some loop or we're in the loop already and will live the same life forever
18:46:50 <ion> > (2^).[1..]
18:46:52 <lambdabot>   [2,4,8,16,32,64,128,256,512,1024,2048,4096,8192,16384,32768,65536,131072,26...
18:46:56 <ion> 0..
18:47:08 <pr> freaking 0!
18:47:08 <sipa> cmccann: still, 7 has higher probability, so it's less "random" (less entropy)
18:47:10 <startling> cmccann, nah, it's less random!
18:47:11 <cmccann> sipa, well mostly I was saying something ridiculous as a joke
18:47:11 <xplat> sadly, 'fix (randomNumbers!!)' will loop
18:47:20 <sipa> cmccann: sorry, i need sleep :)
18:47:28 <maukd> > ap (zipWith subtract) tail . map ord . concat $ cake
18:47:30 <lambdabot>   [31,-9,-69,17,7,-10,4,3,-21,79,6,-7,-11,2,-69,80,-15,2,8,-10,6,-2,-69,67,5,...
18:47:51 <pr> :t cake
18:47:52 <lambdabot> [[Char]]
18:47:56 <gwern> @quote
18:47:56 <pr> > cake
18:47:56 <lambdabot> dino- says: Doesn't terminate! Holy _|_ Batman.
18:47:58 <lambdabot>   ["One 18.25 ounce package chocolate cake mix.","One can prepared coconut pe...
18:48:24 <xplat> > transpose cake
18:48:25 <cmccann> I've seen several such "random number" polls, 7 consistently wins
18:48:26 <lambdabot>   ["OOTFOTOTDFFFFFPFCOAUFANTOATTOOTOOTASCIICAT","nnhonhnwoiiiiiuianlniniwnnww...
18:48:29 <pr> haha.
18:48:30 <cmccann> 13 and 17 are also popular
18:48:34 <pr> > length cake
18:48:36 <lambdabot>   42
18:48:53 <pr> oh come on. out of all possible, finite list sizes
18:48:57 <cmccann> hahaha
18:49:12 <xplat> > length $ join cake
18:49:14 <lambdabot>   1393
18:49:21 <sipa> :t cake
18:49:21 <pr> 1393, hm.
18:49:22 <lambdabot> [[Char]]
18:49:31 <sipa> > join cake
18:49:33 <lambdabot>   "One 18.25 ounce package chocolate cake mix.One can prepared coconut pecan ...
18:49:37 <ion> > let diag ((x:_):xs) = x : diag (map (drop 1) xs); diag _ = [] in diag cake
18:49:38 <lambdabot>   "Onrrc dsred dtlanc"
18:49:58 <ion> > let diag ((x:_):xs) = x : diag (map (drop 1) xs); diag _ = [] in diag (transpose cake)
18:50:00 <lambdabot>   "Onrrc dsred dtlaieds rat r"
18:50:12 <pr> wow, 1393 is not even mentioned on http://www2.stetson.edu/~efriedma/numbers.html
18:50:15 <pr> what a boring number
18:50:52 <xplat> maybe try 1435?  that's the length with unix newlines after each line.
18:50:54 <ion> It seems to be.
18:51:06 <xplat> > length $ unlines cake
18:51:07 <pr> 1435 is a vampire number.
18:51:08 <lambdabot>   1435
18:51:10 <maukd> > cake !! 12
18:51:11 <lambdabot>   "Fish shaped dirt."
18:52:31 <xplat> i'm pretty sure it's a vampire cake, so that fits
18:52:50 <maukd> > drop 5 cake
18:52:51 <lambdabot>   ["Three slash four cups butter or margarine.","One and two third cups granu...
18:53:09 <cmccann> > drop 25 cake
18:53:10 <startling> > drop 5 cake
18:53:11 <lambdabot>   ["An entry called 'how to kill someone with your bare hands.'","Two cups rh...
18:53:12 <lambdabot>   ["Three slash four cups butter or margarine.","One and two third cups granu...
18:53:18 <pr> > cake . (!!) . head $ randomNumbers
18:53:19 <lambdabot>   Couldn't match expected type `a -> b'
18:53:19 <lambdabot>         against inferred type `[[GHC....
18:53:29 <maukd> let lex = take 40 cake in terrible
18:53:33 <YayMe> will emacs create a folder if I tell it to open a file in a non-existent folder?
18:54:02 <xplat> > (cake!!) . head $ randomNumbers
18:54:04 <lambdabot>   "Two cups all-purpose flour."
18:54:05 <pr> i dont think so YayMe
18:54:22 <centrinia> @let bw xs = let ts = tails xs; in map snd $ sortBy (compare `on` fst) $ zip (init ts) (Nothing:map (Just . head) ts)
18:54:23 <lambdabot>  Defined.
18:54:54 <pr> :t bw
18:54:55 <lambdabot> forall a. (Ord a) => [a] -> [Maybe a]
18:55:25 <Catnaroek> > bw [1..10]
18:55:27 <lambdabot>   [Nothing,Just 1,Just 2,Just 3,Just 4,Just 5,Just 6,Just 7,Just 8,Just 9]
18:55:35 <xplat> > bw cake
18:55:37 <lambdabot>   [Just "Two tablespoons rhubarb juice.",Just "One cup lemon juice.",Just "On...
18:55:39 <cmccann> > cake !! 32
18:55:40 <pr> haha.
18:55:41 <lambdabot>   "One cross borehole electro-magnetic imaging rhubarb."
18:55:51 <centrinia> > map bw cake
18:55:53 <lambdabot>   [[Just 'e',Just 'e',Just 'e',Just 'e',Just '5',Just 'e',Just 'x',Just '8',J...
18:55:56 <Catnaroek> > length cake
18:55:57 <lambdabot>   42
18:56:15 <centrinia> Can anyone guess what bw does?
18:56:26 <xplat> > map catMaybes $ map bw cake
18:56:27 <lambdabot>   ["eeee5ex8 .21pkcl n aontgkcacmcao uOhc  aoi","edntngccpe  oenprr ntaaOiocc...
18:56:36 <Catnaroek> centrinia: Gets the element in the list that is immediately below the...?
18:56:40 <xplat> burrows-wheeler transform
18:56:41 <Catnaroek> (Just guessing)
18:56:43 <Catnaroek> Oh.
18:56:46 <centrinia> xplat, yeah.
18:56:46 <Jafet> > length . concat $ filter (not . (`elem` ["Don't forget garnishes such as:","Fish shaped ethylbenzene."])) cake
18:56:48 <lambdabot>   1337
18:56:53 <centrinia> Leet.
18:57:06 <Catnaroek> What is Burrows-Wheeler transform?
18:57:12 <Catnaroek> s/is/is the/
18:57:16 <sipa> it's what bzip2 does
18:57:27 <Catnaroek> sipa: Ah, I see.
18:57:36 <xplat> well, bzip2 does several things; that's just the most magical one
18:57:37 <pr> it's bwt + huffman, isn't it?
18:57:38 <centrinia> It sorts the suffixes of a string and gives you the character right before the beginning of the respective suffix.
18:57:45 <Jafet> That's a really inefficient bwt
18:58:05 <centrinia> Jafet, I know. There are much faster suffix sorts. :(
18:58:07 <pr> avoid efficiency at all costs, #Haskell
18:58:11 <Jafet> I mean it's too long
18:58:14 <maukd> > rand
18:58:15 <lambdabot>   84784
18:58:19 <maukd> > rand
18:58:20 <lambdabot>   74223
18:58:21 <maukd> > rand
18:58:23 <lambdabot>   73825
18:58:24 <startling> :t rand
18:58:25 <lambdabot> forall t. (Num t) => t
18:58:34 * benmachine suspects maukd of cheating
18:58:41 <benmachine> > (rand, rand)
18:58:42 <lambdabot>   (59004,59004)
18:58:44 <benmachine> > (rand, rand)
18:58:45 <cmccann> haha
18:58:46 <lambdabot>   (56164,56164)
18:58:46 <Catnaroek> :t rand
18:58:48 <lambdabot> Not in scope: `rand'
18:58:48 <xplat> > map (maybe '$') $ bw "hello world"
18:58:49 <lambdabot>   Not in scope: `bw'
18:58:50 <sipa> > bw "Voila, in view a humble vaudevillian veteran, cast vicariously by the vicissitudes of faith."
18:58:50 <startling> that would be compiled in, though, wouldn't it?
18:58:50 <lambdabot>   Not in scope: `bw'
18:59:10 <centrinia> @let bw xs = let ts = tails xs; in map snd $ sortBy (compare `on` fst) $ zip (init ts) (Nothing:map (Just . head) ts)
18:59:11 <lambdabot>  Defined.
18:59:14 <sipa> > bw "Voila, in view a humble vaudevillian veteran, cast vicariously by the vicissitudes of faith."
18:59:16 <lambdabot>   [Just 'w',Just 'y',Just ',',Just 'f',Just 'a',Just ',',Just 's',Just 'y',Ju...
18:59:19 <xplat> > map (maybe '$') $ bw "hello world"
18:59:20 <lambdabot>   Couldn't match expected type `a -> GHC.Types.Char'
18:59:20 <lambdabot>         against inferred...
18:59:26 <maukd> benmachine: at the speed of light!
18:59:30 <xplat> :t maybe
18:59:31 <lambdabot> forall b a. b -> (a -> b) -> Maybe a -> b
18:59:33 <sipa> > map fromJust $ bw "Voila, in view a humble vaudevillian veteran, cast vicariously by the vicissitudes of faith."
18:59:35 <lambdabot>   "wy,fa,syentennah*Exception: Maybe.fromJust: Nothing
18:59:40 <benmachine> maukd: well, naturally
18:59:52 <xplat> > map (maybe '$' id) $ bw "hello world"
18:59:52 <sipa> > map (maybe '-') $ bw "Voila, in view a humble vaudevillian veteran, cast vicariously by the vicissitudes of faith."
18:59:53 <lambdabot>   can't find file: L.hs
18:59:53 <lambdabot>   "olh$rellwo "
19:00:05 <sipa> > map (maybe '-') $ bw "Voila, in view a humble vaudevillian veteran, cast vicariously by the vicissitudes of faith."
19:00:06 <lambdabot>   Couldn't match expected type `a -> GHC.Types.Char'
19:00:06 <lambdabot>         against inferred...
19:00:09 <centrinia> > catMaybes $ bw "Voila, in view a humble vaudevillian veteran, cast vicariously by the vicissitudes of faith."
19:00:11 <pr> nn
19:00:11 <lambdabot>   "wy,fa,syentennah lfirccvm i iuulhtdvdio tt lvvvov rcasiblisuaia Vieaesuias...
19:00:15 <maukd> :t fromMaybe
19:00:16 <lambdabot> forall a. a -> Maybe a -> a
19:00:24 <centrinia> > fromMaybe Nothing
19:00:26 <lambdabot>   Overlapping instances for GHC.Show.Show
19:00:26 <lambdabot>                              (Data....
19:00:32 <xplat> ah, right, fromMaybe
19:00:46 <sipa> :t maybe
19:00:47 <lambdabot> forall b a. b -> (a -> b) -> Maybe a -> b
19:01:03 <xplat> maybe foo id === fromMaybe foo
19:01:24 <maukd> :t flip maybe ask
19:01:26 <lambdabot> forall a. a -> Maybe a -> a
19:01:37 <cmccann> I still say that if we have fromJust, we should have fromNothing as well
19:01:42 <cmccann> it's only fair
19:01:59 <nexion> lol
19:02:05 <centrinia> @let fromNothing Nothing = Nothing
19:02:05 <Catnaroek> xplat: I don't think so. fromMaybe is a partial function. :-\
19:02:06 <lambdabot>  Defined.
19:02:11 <sipa> @let fromNothing _ = Void
19:02:11 <maukd> fromNothing :: Maybe a -> b
19:02:12 <lambdabot>  <local>:4:16: Not in scope: data constructor `Void'
19:02:19 <centrinia> :t fromNothing
19:02:20 <lambdabot> forall t a. Maybe t -> Maybe a
19:02:29 <cmccann> nah, it should return () for Nothing
19:02:30 <maukd> Catnaroek: what
19:02:42 <Catnaroek> Oh, oh.
19:02:43 <cmccann> fromJust is partial
19:02:45 <Catnaroek> I was thinking of fromJust.
19:02:46 <xplat> > fromMaybe '$' Nothing
19:02:47 <cmccann> fromMaybe is fine
19:02:47 <lambdabot>   '$'
19:02:48 <Catnaroek> My bad.
19:02:50 <Catnaroek> My bad.
19:02:54 <sipa> :t fromJust
19:02:55 <lambdabot> forall a. Maybe a -> a
19:02:57 <shachaf> fromJust :: Maybe a -> a, so fromNothing :: Maybe a -> Maybe
19:02:58 <cmccann> people mix those up a lot
19:03:07 <Catnaroek> My apologies.
19:03:21 <Catnaroek> :t fromMaybe
19:03:22 <lambdabot> forall a. a -> Maybe a -> a
19:03:26 <xplat> @k Maybe a -> Maybe
19:03:26 <lambdabot> Maybe you meant: karma karma+ karma- karma-all keal kind . ? @ v
19:03:26 <maukd> how do I extract the IO from IO String?
19:03:35 <xplat> @kind Maybe a -> Maybe
19:03:36 <lambdabot> Not in scope: type variable `a'
19:03:51 <xplat> @kind forall a. Maybe a -> Maybe
19:03:52 <lambdabot>     `Maybe' is not applied to enough type arguments
19:03:52 <lambdabot>     Expected kind `?', but `Maybe' has kind `* -> *'
19:03:52 <lambdabot>     In the type `forall a. Maybe a -> Maybe'
19:04:10 <xplat> finally, the right error message :)
19:04:30 <xplat> takes me 3 tries to fail correctly :)
19:04:33 <maukd> @kind Maybe Maybe
19:04:33 <amosr> @kind (->)
19:04:34 <lambdabot>     `Maybe' is not applied to enough type arguments
19:04:34 <lambdabot>     The first argument of `Maybe' should have kind `*',
19:04:34 <lambdabot>     but `Maybe' has kind `* -> *'
19:04:35 <lambdabot> ?? -> ? -> *
19:04:54 <maukd> @kind 1
19:04:55 <lambdabot> *
19:04:58 <Catnaroek> Is there any way to declare type functions?
19:04:59 <maukd> :3
19:05:12 <maukd> Catnaroek: type family ...
19:05:13 <mm_freak_> Catnaroek: type families
19:05:17 <ddarius> > take 2 "IO String"
19:05:18 <lambdabot>   "IO"
19:05:19 <Catnaroek> Ah!
19:05:25 <Catnaroek> ddarius: lol
19:06:26 <amosr> my ghci 7.4.1 lies and tells me (->) :: * -> * -> *
19:06:38 <maukd> > (take 2. tail. show) getLine
19:06:40 <lambdabot>   "IO"
19:06:55 <maukd> > (read. take 2. tail. show) getLine
19:06:57 <lambdabot>   *Exception: Prelude.read: no parse
19:08:16 <geekosaur> amosr, that's actually correct for 7.4.1 and later
19:08:33 <geekosaur> the new kind system made the old ?? and ? kinds unnecessary
19:08:34 <xplat> huh, really?  i didn't know they'd done that
19:08:50 <amosr> oh wow, okay
19:08:51 <maukd> geekosaur: that's kind of cool
19:08:54 <Mortchek> geekosaur, what did ?? and ? originally do?
19:08:56 <amosr> hmm
19:09:01 <xplat> yeah, they were kind of a hack anyway
19:09:07 <maukd> huehue
19:09:11 <geekosaur> had to do with unboxed tuples
19:09:30 <amosr> but I still get kind errors... eg Int# :: # whereas Int :: *
19:09:45 <maukd> :t 1#
19:09:46 <amosr> but (Int# -> Int) still works, right?
19:09:46 <lambdabot> GHC.Prim.Int#
19:09:55 <geekosaur> http://stackoverflow.com/questions/3034264/haskell-weird-kinds-kind-of-is
19:09:55 <ddarius> xplat: It was a fairly nice hack.
19:09:59 <xplat> ? could be boxed or unboxed (but not unboxed tuple), ?? could be unboxed tuple as well
19:10:02 * shachaf wonders whether -fdefer-type-errors works for kind errors.
19:10:35 <maukd> -fdefer-parse-errors
19:10:36 <xplat> ddarius: well yeah, and it worked pretty well as long as atomic kinds weren't used for anything else ...
19:10:42 <cmccann> -fdefer-runtime-errors
19:10:51 <xplat> -fdefer-lexical-errors
19:11:02 <Jafet> @let bw = map head.sort.init.(zipWith(++)<$>tails<*>inits).(fail"":).map Just
19:11:03 <lambdabot>  Defined.
19:11:06 <ddarius> -fdefer-logical-errors
19:11:09 <maukd> -fdefer-encoding-errors
19:11:39 <maukd> (we've reached phase 0 of C)
19:11:46 <xplat> -fdefer-missing-files
19:11:47 <geekosaur> -fdefer-bottom
19:11:59 <maukd> xplat: hah
19:12:02 <xplat> can i have -fno-defer-runtime-errors?
19:12:06 <shachaf> -fdefer-commandline-anVzdCBzb21lIG5vbnNlbnNl
19:12:11 <cmccann> -fdefer-running-ghc
19:12:26 <maukd> ``Just Too Late'' compilation
19:12:30 <cmccann> yes
19:12:38 <cmccann> it'll be the new big thing
19:12:49 <maukd> (used in intercal)
19:12:58 <shachaf> Lots of languages have -fdefer-parse-errors
19:13:08 <maukd> sh?
19:13:11 <shachaf> For example.
19:13:34 <shachaf> GHC does too, actually, when it reads .ghci files.
19:13:42 <maukd> I don't know any others ... tcl maybe
19:14:16 <xplat> tcl is one
19:14:26 <xplat> m4, tex
19:14:26 <shachaf> Perl with BEGIN, kind of?
19:15:27 <maukd> nah
19:15:38 <maukd> the code in BEGIN is still parsed first
19:16:11 <xplat> BEGIN is more like poor man's staged execution
19:16:23 <geekosaur> more correctly, BEGIN is executed *during* parsing
19:16:49 <maukd> not that poor
19:16:54 <xplat> BEGIN blocks are executed as soon as they are parsed, before the rest of the file is parsed
19:18:14 <hpaste> isomorphic pasted “Adding exception handling” at http://hpaste.org/75037
19:18:24 <Jafet> -fno-errors
19:18:31 <geekosaur> some versions of sh do have a sort of deferred parse errors.  ksh and later shells tend to parse an entire source file as a unit (and this is required for aliases), Bourne shell variants generally behave as if they don't do so even if they do, so they have to defer parse errors
19:18:55 <isomorphic> I'm trying to add exception handling to a simple function in the past - can anybody tell me whether the style I'm trying to use make sense?
19:21:40 <geekosaur> (interestingly, the freebsd /bin/sh seems to parse the entire file first without acting compatibly with historical /bin/sh; I have not observed this behavior with dash, which is supposed to be related...)
19:21:41 <xplat> i'm not at all sure the style of using a time machine to change functions in the past makes sense
19:22:26 <Jafet> It makes excellent sense
19:24:50 <YayMe> Anybody here use haskell mode who could tell me how to make a .hs file in a buffer get ghc'd and the result executed?
19:27:17 <isomorphic> xplat, Jafet:   Oh, the time machine approach was too expensive - so I decided to do it without involving the real world or even IO ;)
19:32:57 <shachaf> ddarius: Does the L in "Simon L. Peyton Jones" stand for "Lester"? Apparently you claimed that once.
19:33:07 * shachaf can't find a source for it.
19:37:32 <maukd> it stands for Lambda
19:38:06 <Cale> shachaf: I don't know where you're seeing Simon L. Peyton Jones, but SPJ wrote a book with David Lester called Implementing Functional Languages
19:38:11 <YayMe> so what you're saying is, Simon Peyton Jones is the Ultimate?
19:38:38 <shachaf> Cale: E.g. http://research.microsoft.com/en-us/um/people/simonpj/papers/slpj-book-1987/IMAGES/III.JPG
19:38:50 <Cale> hmm
19:39:09 <shachaf> I suspect the Lester thing came from a misreading of "Peyton Jones, Simon; Lester, David R.", though.
19:40:00 <ddarius> shachaf: Possibly.
19:40:23 <Cale> http://www.researchgate.net/profile/Simon_Peyton_Jones/
19:40:40 <ddarius> Loftus
19:40:43 <ddarius> Interesting.
19:40:45 <shachaf> Cale++
19:41:36 <Cale> http://appft1.uspto.gov/netacgi/nph-Parser?Sect1=PTO1&Sect2=HITOFF&d=PG01&p=1&u=%2Fnetahtml%2FPTO%2Fsrchnum.html&r=1&f=G&l=50&s1=%2220060161844%22.PGNR.&OS=DN/20060161844&RS=DN/20060161844
19:41:42 <Cale> There it is again on a patent
19:42:37 * cmccann makes a mental note to ask Cale next time he wonders what someone's middle name is
19:42:41 <shachaf> Except that patent got the last name wrong, I think...
19:42:55 <shachaf> Cale: What's cmccann's middle name?
19:42:58 <Cale> Jones; Simon Loftus Peyton
19:42:58 <shachaf> I think it starts with "A".
19:43:05 <Cale> wat
19:43:15 <ddarius> Cale: What's my middle name?
19:43:40 <shachaf> ddarius has a middle name?
19:45:01 <shachaf> Maybe I should get some software patents.
19:45:45 <djahandarie> Try patenting values.
19:46:04 <ddarius> Kiki; Shachaf Ben
19:46:18 <djahandarie> If Apple can patent a rectangle with rounded corners, you can do anything!
19:46:29 <djahandarie> And I think Ben-Kiki is his full last name
19:46:40 <ivanm> djahandarie: apparently there were more details than that
19:46:47 <ivanm> has to mention glass screen as well
19:46:49 <cmccann> we need proper support for existential patents
19:46:51 <Cale> ddarius: hmm... you have an email address derek.a.elkins@gmail.com
19:46:58 <cmccann> that's what most people seem to be trying for anyway
19:47:14 <cmccann> "I've patented something but you can't tell what"
19:47:40 <ivanm> cmccann: "I've patented something but I'll only tell you what once you've violated it and have big bags of cash I can claim"
19:47:57 <dolio> Anfernee?
19:48:19 <cmccann> ivanm, yes, that's the idea
19:48:21 <shachaf> cmccann: The NSA can do that.
19:48:44 <shachaf> NSA has the ability to file for a patent from the U.S. Patent and Trademark Office under gag order. Unlike normal patents, these are not revealed to the public and do not expire. However, if the Patent Office receives an application for an identical patent from a third party, they will reveal NSA's patent and officially grant it to NSA for the full term on that date.[49]
19:48:54 <cmccann> bwahahaha
19:48:59 <ivanm> w...t...f...
19:49:13 <cmccann> that's the NSA for you
19:49:30 * ivanm is once again pleased he doesn't live in the USA
19:49:33 <ddarius> What the heck happens if the NSA sues you for patent infringement?
19:50:00 <Ralith> iirc there are various allowances for court records that contian national secrets
19:50:56 <scp> Can anyone explain the difference between the following to me?
19:51:06 <scp> State Int Maybe Int
19:51:12 <scp> State Int (Maybe Int)
19:51:13 <ddarius> I guess it's important that the NSA not have to license things that they've invented...
19:51:19 <ivanm> the first one isn't legit
19:51:20 <shachaf> scp: The former is an error. The latter is not.
19:51:21 <cmccann> :k State Int Maybe Int
19:51:22 <lambdabot>     `State' is applied to too many type arguments
19:51:22 <lambdabot>     In the type `State Int Maybe Int'
19:51:28 <ivanm> do you mean StateT ?
19:51:33 <scp> maybe
19:51:35 <ivanm> :k StateT Int Maybe Int
19:51:35 <shachaf> scp: State takes two arguments.
19:51:36 <lambdabot> *
19:51:42 <scp> What is StateT then o_O
19:51:55 <dmj> hi, does anyone have any experience being employee #1 at a startup? I just need someone to talk to i've never done this before.
19:51:55 <ivanm> scp: type State s a = StateT s Identity a
19:52:03 <ivanm> where Identity is the Identity monad/functor
19:52:20 <shachaf> It seems more likely that scp means "how do parentheses work", and talking about StateT will just cause confusion.
19:52:30 <scp> no, I wanna talk about StateT
19:52:46 <ivanm> scp: RWH has a chapter on monad transformers that might help
19:52:50 <shachaf> scp: You should understand State before bothering with StateT. :-)
19:52:52 <shachaf> djahandarie: What happened to the good old days when you were in #-blah?
19:53:09 <elliott> dmj: i suggest using haskell
19:53:22 <ivanm> elliott: just because? ;)
19:53:24 <scp> So, State has type (*) -> (*) -> (*), whereas StateT is (*) -> (*) -> ((*) -> (*))
19:53:27 <scp> is that right?
19:53:33 <ivanm> scp: no
19:53:37 <elliott> ivanm: well, who doesn't love topicality
19:53:39 <scp> =[
19:53:43 <ivanm> first of all, kind, not type
19:53:46 <dmj> elliot: Employee -> Negotiation -> Happy
19:53:50 <scp> kind, right
19:53:52 <ivanm> :k StateT
19:53:53 <lambdabot> * -> (* -> *) -> * -> *
19:54:00 <djahandarie> shachaf, no time
19:54:10 <scp> :k State
19:54:10 <ivanm> ^^ takes the state type, the underlying Monad, then the `a'
19:54:11 <lambdabot> * -> * -> *
19:54:16 <dmj> :t Monad
19:54:17 <lambdabot> Not in scope: data constructor `Monad'
19:54:30 <ivanm> all Monads are kind * -> *
19:54:30 <dmj> :t lines
19:54:31 <scp> ok, I need to look up StateT =] thanks
19:54:31 <lambdabot> String -> [String]
19:54:37 * shachaf really thinks a discussion of monad transformers is out of place here.
19:55:05 <ivanm> shachaf: in the "too technical for now" sense rather than "not Haskell"? ;-)
19:55:20 <cmccann> maybe, maybe not, depends on why scp is asking
19:55:38 <cmccann> it's not unreasonable for someone to stumble on a type involving StateT before they "should" worry about it
19:55:55 <cmccann> it's pretty common
19:55:59 <shachaf> cmccann: scp was just asking what the difference between "State Int Maybe Int" and "State Int (Maybe Int)" was.
19:56:10 <isomorphic> dmj: let newPlan = flip elliot            -- allows convenient partial application
19:56:15 <shachaf> One should understand State before worrying about StateT.
19:56:18 <YayMe> whats '>>' function do?
19:56:33 <ivanm> @type (>>)
19:56:34 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m a -> m b -> m b
19:56:35 <ivanm> @src (>>)
19:56:35 <lambdabot> m >> k      = m >>= \_ -> k
19:56:44 * cmccann thinks misreading StateT as State in one case is plausible as well
19:56:56 <dmj> isomorphic: Ah I see, is that point free?
19:57:02 <scp> cmccan is actually right =[
19:57:07 <scp> I was asking about this earlier
19:57:12 <ivanm> dmj: is what point free? >> ?
19:57:13 <scp> and misread StateT as State
19:57:18 <ivanm> the definition of >> has two points...
19:57:26 <dmj> :ivanm let newPlan = flip elliot
19:57:34 <dmj> ivanm: let newPlan = flip elliot
19:57:35 <ivanm> which is what I figured had happened to scp and hence why I asked if he meant StateT
19:57:37 <ivanm> dmj: yes
19:57:44 <dmj> ivanm: thanks
19:57:51 <YayMe> so the results of m execution will be ignored and k will be returned
19:58:02 <scp> in retrospect, glad ivanm was able to see into my brain =P
19:58:08 <cmccann> if you don't already know that StateT is a thing misreading it would be very easy
19:58:15 <ivanm> YayMe: yes
19:58:23 <ivanm> "run m, discard the result and then run k"
19:58:36 <YayMe> okey
19:58:41 <dmj> I asked Erik Meijer what was the reason why haskell won't be adopted mainstream and he said debugging, since its lazy... but I thought ghc had a debugger
19:58:52 <ivanm> yes
19:59:00 <ivanm> I've never used it though
19:59:06 <ivanm> (partially because I've never bothered to learn it :p)
19:59:18 <scp> what is the name of said debugger? o_O
19:59:21 <cmccann> yes, and debugging through lazy evaluation is kinda weird and confusing compared to debugging in most languages
19:59:26 <ivanm> scp: it's part of ghci
19:59:39 <scp> guess that makes sense
19:59:58 <cmccann> with good support from an IDE it would probably be much easier to follow
20:00:11 <ivanm> IDE, SCHMIDE
20:00:20 <cmccann> but in practice you don't need a debugger very often in Haskell
20:00:52 <YayMe> I don't believe that's the reason.. I think it's simply too different from any imperative language. No functinoal languages have mainstream adoption
20:01:21 <scp> Haskell requires way way more abstract thinking than the popular modern languages
20:01:27 <scp> (says the newby)
20:01:27 <YayMe> yeah
20:01:30 <cmccann> meh, not really
20:01:33 <cmccann> it's just not what people are used to
20:01:41 <ivanm> yeah, the emphasis on purity (and being unable to chuck random printLn statements in) and laziness being different is a detriment to many people's eyes
20:01:48 <cmccann> give me someone who's never programmed before and I'd rather teach them Haskell than C++ by a long shot
20:02:06 <YayMe> cmccann: same here, but very few people have that opportunity
20:02:06 <Ralith> ivanm: chucking random Debug.Trace statements in, on the other hand...
20:02:13 <amosr> I just use debug.trace when I need to
20:02:15 <Ralith> :P
20:02:22 <ivanm> Ralith: sure, but even the name emphasises you shouldn't leave it in
20:02:24 <cmccann> Debug.Trace.unsafePerformPrintfDebugging
20:02:30 <ivanm> and laziness causes trace to do weird things sometimes...
20:02:34 <elliott> cmccann: something about a false dichotomy :P
20:02:47 <Ralith> cmccann: the problem is, those people google "how to learn to program" and before long hear about how HARD and SCARY haskell is
20:02:49 <cmccann> just like the good old days of sprinkling printf through my crappy C code because I didn't know debuggers existed :D
20:02:57 <Ralith> cmccann: and then attach themselves to C++ like limpets :P
20:02:57 <scp> I ran into this earlier today actually -- How do you use Debug.Trace w/ monads?
20:03:10 <Ralith> scp: $ return ()
20:03:21 <YayMe> If we started acting like writing haskell imperatively was the right way to do it, and everything about haskell online showed that instead of it's purity it would probably get more adoption
20:03:26 <cmccann> elliott, hm?
20:03:49 <Cale> Avoid Success At All Costs
20:03:51 <scp> Ralith, so like `trace ("some output here") $ return
20:03:53 <scp> ()
20:03:57 <scp> `
20:04:12 <scp> where ` is my arbitrary code delimiter
20:04:23 <YayMe> Cale: yeah, that too :)
20:04:26 <scp> and newlines are ignored
20:04:36 <cmccann> we could start acting like writing concurrent programs that work the way you expect is essentially a solved problem in Haskell because of STM
20:04:46 <dmwit> ISAAC -- ignore success at all costs
20:04:55 <Ralith> scp: assuming you're in a do block, yeah
20:05:06 <ivanm> @remember dmwit  ISAAC -- ignore success at all costs
20:05:07 <lambdabot> Done.
20:05:11 <scp> that makes a lot of sense x_X
20:05:22 <Ralith> these things tend to ^^
20:05:24 <elliott> cmccann: well, I'm not sure I'd want to teach a newbie either C++ or Haskell :p
20:05:39 <elliott> @quote dmwit isaac
20:05:39 <lambdabot> dmwit says:  ISAAC -- ignore success at all costs
20:05:39 <scp> here I was trying `let _ = trace ("message") 5 in someMonadFunction`
20:05:39 <YayMe> What does pause do?
20:05:43 <elliott> @remember dmwit ISAAC -- ignore success at all costs
20:05:43 <lambdabot> Done.
20:05:46 <elliott> @forget dmwit  ISAAC -- ignore success at all costs
20:05:46 <lambdabot> Done.
20:06:21 <ivanm> elliott: fine, don't like the extra space I accidentally put there *humph*
20:06:26 <ivanm> @hoogle pause
20:06:27 <lambdabot> No results found
20:06:35 <ivanm> YayMe: where did you find it?
20:06:47 <ivanm> at a guess, it would prevent that thread from executing anything for a given period of time
20:06:52 <cmccann> elliott, which is entirely reasonable, but for some reason people often think that C++ is an appropriate language for beginners
20:06:59 <cmccann> or for anyone at all
20:07:00 <shachaf> pause = rep nop
20:07:04 <YayMe> oh nevermind
20:07:12 <YayMe> it's defined in the file I'm reading lol
20:07:13 <YayMe> :)
20:07:23 <ivanm> heh
20:07:26 <scp> To quote a quote I found on harmful.cat-v
20:07:26 <elliott> cmccann: i have been using more C++ than I'd like recently
20:07:30 <ivanm> shachaf: rep = repeat ?
20:07:41 <scp> "C++ is like cramming a helicopter inside a miata and expecting some kind of improvement"
20:07:55 <ivanm> @wn miata
20:07:55 <lambdabot> No match for "miata".
20:07:59 <shachaf> ivanm: Sure.
20:08:04 <dmwit> ivanm: A kind of crappy car.
20:08:10 <ivanm> ahhhh
20:08:22 <shachaf> C++ is a pretty great language.
20:08:30 <ivanm> the wiki page shows a mazda sports car...
20:08:51 <shachaf> FVPVO "great"
20:09:06 * shachaf >=>
20:09:07 <dmwit> I don't know, maybe it's a kind of awesome car.
20:09:08 <Dodek> "great" as in "large", sure
20:09:14 <dmwit> doesn't change the meaning of the quote much =)
20:09:23 <ivanm> heh
20:09:40 <Nafai> ivanm: A Miata is a Mazda
20:09:49 <YayMe> a small one
20:10:07 <ivanm> Nafai: I did say that I found that on the wiki page :p
20:10:24 <scp> I'm just glad I spelled miata correctly =P
20:11:14 <scp> also, it's pretty awesome how hoppin' the Haskell channel here is
20:12:14 <Dodek> maybe i'm living in a bubble, but do you also think that haskell has been growing _very_ fast in the past few years?
20:12:31 <cmccann> growing in what sense?
20:12:44 <Dodek> like, the haskell awareness, community and how frequently it's used
20:13:52 <cmccann> dunno, that's hard to judge
20:14:17 <cmccann> it's certainly more visible relative to how much it's actually used than most languages, heh
20:14:42 <YayMe> I work in C# and in 08 C# got a huge functional infusion, over the following couple years they gained wide spread adoption among us corporate devs, I believe similarly this pressed java to add some functional bits
20:14:59 <YayMe> plus javascripts growth over the past few years has pushed people to learn more functional stuff
20:15:02 <isomorphic> Perhaps we should keep a running graph of the number of users in each of the channels?
20:15:10 <YayMe> I think haskell/erlang have had major gains over past few years from those trends
20:15:40 <jfischoff> Does anyone know if you can use Haskim and haskellmode for vim together?
20:15:56 <YayMe> imperative languages are sneaking functional training into the minds of imperative developers somewhat, did for me anyway.
20:16:08 <dmwit> jfischoff: I don't, but now I know who to ask tomorrow when I want to know. ;-)
20:16:29 <cmccann> heh, C# is getting most of its functional inspiration from Haskell anyway
20:16:49 <YayMe> cmccann: yep, and good for us who work in it
20:16:55 <YayMe> thanks simon peyton jones :)
20:17:05 <jfischoff> dmwit: haha that's a tall order I'm still trying to wrap my head around vim altogether we
20:17:10 <jfischoff> ll see :)
20:18:08 <YayMe> cmccann: having bridges the gap and getting used to lambda's/map ("select")/fold ("aggregate") in C# made those basic parts of haskell much easier for me to get going at
20:18:53 <cmccann> don't forget SelectMany == (>>=)
20:18:55 <cmccann> that's kinda important
20:18:57 <YayMe> granted, I had a habit of using lots of "anonymous functions" (lambda functions) in C# and getting complaints from other imperative developers to an extent that it's confusing
20:19:04 <YayMe> cmccann: WHAT??
20:19:22 <YayMe> I know SelectMany, and I thought I was starting to understand >>=
20:19:33 <YayMe> but your definition was not at all what I was thinking of >>=
20:19:38 <YayMe> that doesn't fit..
20:19:53 <carter> Dodek cmccann i definitely feel like the # of haskell jobs on the east and west costs in nice cities is growing exponentially year2year now
20:19:54 <cmccann> well, under normal circumstances LINQ is roughly based on the list monad
20:19:58 <dmwit> > [1..5] >>= \x -> [x + 10, x * 1000]
20:19:59 <lambdabot>   [11,1000,12,2000,13,3000,14,4000,15,5000]
20:20:02 <YayMe> SelectMany is flatten . map
20:20:04 <cmccann> so >>= is concatMap
20:20:10 <carter> granted, 2-4x a year when its initially like 1 isn't THAT big :)
20:20:19 <cmccann> but you can wedge other monads into LINQ syntax if you want
20:20:33 <cmccann> you can't define a generic version of return so it's not very useful
20:20:43 <carter> actually, that might be off by 1-2 orders of magnitude it base 2
20:21:31 <cmccann> YayMe, here, read this: http://blogs.msdn.com/b/wesdyer/archive/2008/01/11/the-marvels-of-monads.aspx
20:21:58 <YayMe> err map . flatten rather
20:23:27 <dmwit> YayMe: I'd be pretty surprised if it was map . flatten.
20:23:37 <YayMe> well sortof
20:23:40 <cmccann> and yeah, you had it right the first time
20:23:42 <Cale> cmccann: Heh, it's like monads, but without the unit... semigroupads strike again?
20:23:50 <dmwit> ?src [] (>>=)
20:23:50 <lambdabot> xs >>= f     = concatMap f xs
20:23:57 <dmwit> ?src concatMap
20:23:57 <lambdabot> concatMap f = foldr ((++) . f) []
20:24:01 <dmwit> oh, come on
20:24:08 <YayMe> hahaha
20:24:38 <Cale> That way is actually more efficient than concat . map under some assumptions.
20:24:55 <Cale> (except in reality, we have some fusion rules)
20:25:02 <cmccann> Cale, wouldn't surprise me if the people who worked on LINQ were aware of that, actually :D
20:25:51 <dmj> cmccann: The guy who made F# (don syme) did some linq, so he def. did
20:25:53 <Cale> cmccann: I mean the definition with foldr
20:26:23 <cmccann> Cale, I was referring to the monads without return thing
20:26:27 <Cale> ah
20:26:35 <YayMe> in C#: [{ bla=[1,2]; },{ bla=[5,5]; }].SelectMany(x => x.bla); would generate [1,2,5,5]
20:26:50 <YayMe> except that's totally syntactically incorrect
20:26:58 <YayMe> but you get the idea
20:27:04 <Cale> semigroupads is just a name I randomly made up for functors with an associative join but no return
20:27:25 <YayMe> that's not quite the same behavior as [] >>=
20:27:30 <YayMe> from what you just showed
20:27:49 <dmwit> > [[1,2],[5,5]] >>= \x -> x
20:27:50 <lambdabot>   [1,2,5,5]
20:27:55 <dmwit> looks pretty much the same to me
20:27:55 <monochrom> and semigrouphone, semigroupodtouch, semigroupmac :)
20:28:01 <YayMe> hah, no joke
20:28:11 <YayMe> now I understand >>= completely differently, thanks
20:28:28 <YayMe> gives me a much clearer frame of reference
20:29:19 * cmccann also notes that main (?) person behind LINQ was one of the many authors of the Haskell 98 report and aided and abetted all that zygohistomorphic prepromorphism nonsense
20:29:33 <YayMe> > [([1,2]),(5,5)] >>= \x -> fst x
20:29:34 <lambdabot>   Couldn't match expected type `[t]' against inferred type `(t1, t2)'
20:30:01 <isomorphic> Hrmm - I have a do-block with a return Nothing, wrapped in a catch.   When I handle any exception (outside the do block), how should I make the types line up - ie: give the result an IO type, like the do-block?
20:30:13 <YayMe> > [([1,2]), ([5,5])] >>= \x -> fst x
20:30:14 <lambdabot>   Couldn't match expected type `(a, b)' against inferred type `[t]'
20:30:19 <cmccann> in other news why does the spell-checker in xchat think "prepromorphism" is a word I mean come on
20:30:45 <edwardk> cmccann: =)
20:30:55 <cmccann> edwardk, this is probably your fault somehow
20:30:59 <edwardk> maybe you have it set to dutch
20:31:06 <cmccann> hahaha
20:31:18 <YayMe> dmwit: my example is a little more similar to select many, because the lists being concatted are accessed through indirection, what am I doing wrong here though?
20:31:36 <edwardk> lens talk went better than i expected given how much time i had to work on the slides
20:31:55 <edwardk> the demo component was important to actually sell it though
20:32:08 <ivanm> edwardk: who were you talking to?
20:32:12 <edwardk> boston haskell
20:32:22 <edwardk> so ~15-20 haskell users out here
20:32:22 <Cale> Will there be videos of the talks?
20:32:37 <edwardk> Cale: i have it captured on my ipad. i'm not sure yet how it turned out
20:32:44 <edwardk> i also captured mgsloan's talk on lenq
20:32:46 <ivanm> oh, so "selling" it was more "why you should use _my_ lens library" ?
20:32:58 <dmwit> > [([1,2],()),([5,5],())] >>= fst -- YayMe
20:32:59 <lambdabot>   [1,2,5,5]
20:33:09 <edwardk> ivanm: lens isn't really a lens library. its a whole lot of stuff that happens to involve lenses.
20:33:14 <edwardk> its not really a competition ;)
20:33:17 <ivanm> heh
20:33:27 <YayMe> oh ok I see
20:33:29 <ivanm> well, you're the one who mentioned "sell it" :p
20:33:43 <edwardk> well, by sell it, i meant sell the idea of lenses, traversals, folds, etc.
20:33:48 <edwardk> its a lot of new concepts all at once
20:33:55 <AfC> "lens isn't really a lens library" I should write that down somewhere.
20:34:01 <YayMe> dmwit: Thanks! I'll henceforth read that operator as SelectMany
20:34:05 <dmwit> It's "sell" in the non-literal sense, yes.
20:34:08 <dmwit> YayMe: =)
20:34:20 * ddarius should really join that Google group.  Not that I have time right now.
20:34:23 <edwardk> combined with a rather distinctive way to reason about parametricity for them, etc.
20:34:28 <elliott> edwardk: i'll buy 3 lens installations
20:34:33 <edwardk> ddarius: boston-haskell?
20:34:35 <AfC> edwardk: so which lens library does lens use? And where does lens-family fit in to this?
20:34:36 * cmccann usually assumes that edwardk is always attempting to sell anybody who'll listen on whatever he's currently working on
20:34:38 <edwardk> elliott: great!
20:34:43 <elliott> lens uses the lens lens library
20:34:46 <Cale> Scumbag Steve (Edward?) takes the package name "lens", but doesn't write a lens library.
20:34:52 <AfC> elliott :)
20:34:59 <elliott> lens, which isn't a lens library but instead is lens, uses the lens lens library, which isn't a lens library
20:35:26 <isomorphic> LINALL?
20:35:28 <AfC> LINALL Lens is not a Lens Library
20:35:32 <edwardk> afc: lens is mostly compatible with lens-family. it has lenses in it, but its more about the traversals, folds, setters, getters, isomorphisms, indexed folds, projections, etc. that are compatible with the lenses
20:35:57 <edwardk> cmccann: pretty much
20:36:16 <edwardk> cmccann: its a tool to refine my sales pitch ;)
20:36:36 <edwardk> cale: now the funny one is that there are no parsers in 'parsers' ;)
20:36:36 <AfC> edwardk: ug, "mostly compoatible" that sounds like what's going on in Haskell crypto community at the moment. Classes with the same names that aren't compatible at all that the library authors encourage you to "use together"
20:36:51 <AfC> edwardk: anyway, so what lens library does lens-family use, then?
20:37:00 <edwardk> afc: well, what i mean is that lenses from lens work with the ones from lens-family.
20:37:04 <cmccann> edwardk, seriously though, it's impressive how much you can start extemporizing lectures on five different things at once given the chance :P
20:37:19 <edwardk> cmccann: =)
20:37:19 * AfC is as far along as edwardk's stackoverflow post, but I get the sense that things have moved on a bit.
20:37:50 <edwardk> afc: lens is its own lens library, lens-family is also its own. the two are compatible though for lenses (and traversals) because the combinators for each only use types from base.
20:37:57 <AfC> cmccann: true enough. I gave a Haskell talk last night, and the most interesting part was in the hand-wavey bits & discussion. I'm not entirely convinced the slides themselves have value.
20:38:07 <edwardk> afc: so you can use a lens generated using the lens-family template haskell code in my lens package and vice versa.
20:38:48 <edwardk> the lenses generated by 'lens' is far more powerful, have signatures, have tests, documentation, etc. but they are compatible
20:38:53 <AfC> Whoa. "lens is its own lens library" ⋃ "lens isn't really a lens library"
20:39:15 <shachaf> lens isn't a lens library?
20:39:26 <edwardk> afc: what i meant by the latter was that it isn't focused on being a lens library, its focused on providing a coherent framework for working with lenses, folds, traversals, etc.
20:39:46 <dolio> That's why it's called lens.
20:39:49 <edwardk> there are a lot of things in the ecosystem around lenses that nobody else packages up or even has the tools for
20:39:53 <AfC> shachaf: That's what edwardk said 5 minutes ago :)
20:40:03 <shachaf> Oh, edwardk is talking about his talk.
20:40:05 <edwardk> afc: 'really' was the key word there. its got lenses in it
20:40:12 <shachaf> Presumably next month's talk will be even better?
20:40:15 <dmwit> This whole conversation reminds me of the Lewis Carroll skit about names and what things are called.
20:40:16 <AfC> edwardk: I know. I'm stirring the pot.
20:40:17 <edwardk> but they are a rather deemphasized component
20:40:24 <cmccann> in other news, Data.Data contains very little in the way of actual data
20:40:38 <cmccann> pf, names
20:40:39 <Cale> Data.Data.Data is not a datatype
20:40:40 <shachaf> cmccann: But it contains Data!
20:40:40 <edwardk> shachaf: thats the plan
20:40:52 <cmccann> right, but Data.Data.Data is not data, as Cale points out
20:40:55 <edwardk> shachaf: this time i didn't have much time to prep the slides, etc. because i only found out mgsloan was coming a week ago
20:41:07 <edwardk> plus i had no idea how long it would run
20:41:10 <shachaf> cmccann: It's Data as far as the people writing the compiler are concerned.
20:41:14 <edwardk> so i wound up talking or almost 2 hours on lenses
20:41:14 <shachaf> s/D/d/
20:41:18 <edwardk> er for
20:41:24 <Cale> We need Control.Control.Control
20:41:43 <shachaf> alt.control.delete
20:41:45 <edwardk> cale++
20:41:50 <edwardk> Control.Alt.Delete
20:41:51 <YayMe> composition isn't technically a "monad" is it?
20:41:56 <shachaf> edwardk: Not Usenety enough.
20:41:57 <edwardk> that way you fit the namespace structure
20:42:03 <cmccann> Cale, some sort of control theory-oriented library I expect
20:42:20 <bane> hi there, which book shud I refer as a beginner to haskell?
20:42:33 <YayMe> monad's are data types no?
20:42:37 <edwardk> Cale: when I do a library for web controls or something i'll make sure to call one Control.Control.Control for you
20:42:40 <cmccann> (which might actually be useful, control theory is pretty cool)
20:42:40 <YayMe> bane: Learn you a haskell for great good
20:42:44 <edwardk> @where lyah
20:42:45 <lambdabot> http://www.learnyouahaskell.com/
20:42:50 <edwardk> bane ^ that one
20:43:08 <cmccann> more useful than web controls at any rate :P
20:43:20 <bane> YayMe: thanks !
20:43:24 <Cale> moreover, Control.Control.Control *will* be data :)
20:43:27 <edwardk> YayMe: i've been debating about spitting out a library of monads that are a bit more er… permissive with the use of extensions and putting them in Data.Monad
20:43:34 <cmccann> Cale, I should certainly hope so
20:43:48 <shachaf> Cale: Are lists data?
20:44:22 <Cale> shachaf: Not when their use is appropriate.
20:44:26 <Cale> :)
20:45:23 <cmccann> if only the text package used Text.Text.Text
20:45:28 <cmccann> oh well
20:45:57 <dolio> Like, when they're being used in free monoid algebras?
20:46:00 <Cale> For some reason, I am reminded of alt.adjective.noun.verb.verb.verb
20:46:02 <dolio> Or as a stack?
20:46:36 <YayMe> After getting comfortable with LYAH I found this to be one of the best primers to thinking at the level of abstraction common in haskell: http://en.wikipedia.org/wiki/SKI_combinator_calculus
20:46:36 <Hail_Spacecake> I'm still trying to work throuhg this tutorial: http://www.haskell.org/haskellwiki/Roll_your_own_IRC_bot
20:46:46 <Hail_Spacecake> and when I run the code verbatim
20:47:00 <Hail_Spacecake> I get an ambiguous type variable message on line 26
20:47:00 <AfC> bane: also read http://fpcomplete.com/ten-things-you-should-know-about-haskell-syntax/ quickly. Will help.
20:47:09 <ivanm> Hail_Spacecake: lemme guess: exception handling?
20:47:13 <Hail_Spacecake> yeah
20:47:14 <shachaf> Hail_Spacecake: That code is quite old and probably wrong.
20:47:16 <ivanm> that changed since the tutorial was written
20:47:19 <Hail_Spacecake> ah
20:47:23 <Cale> http://www.faqs.org/faqs/verb-verb-verb/
20:47:38 <shachaf> For example the whole deal with Strings.
20:47:46 * hackagebot shelly 0.14.1 - shell-like (systems) programming in Haskell  http://hackage.haskell.org/package/shelly-0.14.1 (GregWeber)
20:47:58 <Cale> Given that the tutorial is on a wiki, you would think someone would have corrected it by now
20:48:12 <Cale> Oh well, I'm sure someone else will do it :)
20:48:21 <geekosaur> the new exceptions variant is present but commented out
20:48:26 <geekosaur> someone should switch it around
20:48:35 <shachaf> Cale: Maybe the person who writes the new lambdabot can do it!
20:48:51 * Cale nominates shachaf for both jobs
20:49:05 <shachaf> Cale: Will you switch to the new lambdabot if someone writes it?
20:49:18 <shachaf> elliott has already started.
20:49:48 <Cale> shachaf: Yeah
20:49:55 <geekosaur> there's even a comment on it but 'base 4' probably means nothing to haskell newbies
20:50:10 <shachaf> geekosaur: Control.OldException is gone in GHC 7.6.
20:50:31 <geekosaur> and?
20:50:31 <ddarius> You have to use Control.AncientException.
20:50:40 <ivanm> there's a new lambdabot? :o
20:50:47 <YayMe> Sometimes I wish haskell function execution were such that: too many parameters just causes a function to return it's value and the extra parameters get handed to that return, though if that return weren't a function then it would just be cons'd with the extra parameters already available and applied to the next parameter over with the same apply-or-cons behavior
20:50:49 <shachaf> ivanm: There will be after you write it!
20:50:52 <Clint> Hail_Spacecake: if you actually want an irc bot, you might want to use simpleirc instead
20:50:58 <YayMe> Does that make sense or would something like that be just stupid?
20:50:59 <ivanm> shachaf: you said elliott already started...
20:51:05 <shachaf> ivanm: He stopped shortly thereafter.
20:51:08 <ivanm> heh
20:51:12 <Hail_Spacecake> well mostly I'm trying to understand how that code works
20:51:20 <shachaf> Easy: It doesn't.
20:51:24 <Clint> *rimshot*
20:51:25 <Hail_Spacecake> namely, the thing it's doing with monads
20:51:28 <geekosaur> shachaf, I am talking about the comment firther in which has the new-exceptions version, *not* the one at the top
20:51:28 <ivanm> wouldn't the successor to lambdabot be mubot? :p
20:51:30 <Hail_Spacecake> to get rid of passing around the file handle
20:51:45 <shachaf> geekosaur: Oh, maybe I meant something else.
20:52:03 <Hail_Spacecake> also what is simpleirc?
20:52:06 <shachaf> lambdabot: Do that thing you do with the monads.
20:52:14 <Hail_Spacecake> or I guess, how it *would* work
20:52:19 <elliott> YayMe: That doesn't make sense, no.
20:52:23 <Clint> @hoogle simpleirc
20:52:23 <lambdabot> package simpleirc
20:52:28 <Clint> @hackage simpleirc
20:52:28 <lambdabot> http://hackage.haskell.org/package/simpleirc
20:52:31 <YayMe> elliott: balls. I'm just not that bright sometimes
20:52:40 <geekosaur> there's a commented out line at the top with Control.OldException, then another comment further down with a SomeException variant (which is new exceptions).  I don;t know why the code shows *both* of those along with the uncommented old-exceptions code, though
20:52:42 <geekosaur> weird
20:52:57 <Hail_Spacecake> also I guess it'd be good to edit that page so it does work
20:53:04 <Hail_Spacecake> I'm not expert enough in haskell to try it myself
20:53:33 <geekosaur> I think I lost access during some shuffle or other
20:54:56 <ivanm> wait, it's using SomeException?
20:55:03 <ivanm> that's not exactly all that great...
20:57:17 <bane> AFC: thanks
20:59:20 <bane> well, can nyone quickly and briefly acquaint me wid the terms, monad, curry?
20:59:38 <shachaf> bane: The FAQ might help.
20:59:40 <shachaf> @where faq
20:59:40 <lambdabot> http://www.haskell.org/haskellwiki/FAQ
21:00:10 <centrinia> @faq Where?
21:00:10 <lambdabot> The answer is: Yes! Haskell can do that.
21:00:17 <AfC> bane: read the post I sent you. It answers those questions.
21:00:29 <cmccann> currying is a transformation applied to food that makes it tastier
21:00:32 <ddarius> shachaf: Can you quickly and briefly acquaint me with sheaf cohomology?
21:00:39 <bane> shachaf: I didn't quite get you sir
21:00:40 <ivanm> cmccann: especially when the food is off :p
21:01:38 <shachaf> ddarius: Do you mean wid?
21:18:50 <Lemon> you know what'd be crazy?
21:19:06 <Lemon> if we had a function-based module system
21:19:25 <Lemon> where you import functions directly
21:19:29 <Lemon> rather than by module
21:19:47 <Cale> Lemon: hm?
21:19:57 <shachaf> What if we, like, had functions *inside other functions*?
21:20:27 <Lemon> and for each imported function, you have an implicit, invisible import of the functions it depends on
21:20:44 * Clint squints.
21:21:04 <Cale> Lemon: Isn't that the opposite of what the module system is supposed to do?
21:21:11 * cmccann still likes the idea of being able to export qualified bindings from any where clause, with modules as a special case
21:21:28 <Lemon> namespacing would be a problem, yes
21:21:45 <cmccann> just add prefixes to the names of everything to disambiguate
21:21:50 <cmccann> works for record fields, right
21:22:02 <cmccann> namespaces, who needs 'em
21:24:55 <Cale> cmccann: lololol, just steal . as an identifier symbol
21:25:18 <cmccann> what, no. that is a ridiculous idea.
21:25:28 <shachaf> I recommend ·
21:25:40 <Clint> o·k
21:25:47 <shachaf> Control.Monad.Cont.Cann
21:25:56 <shachaf> That's what c.m.c.cann stands for, right?
21:26:04 <cmccann> how about unicode snowman as a separator
21:26:12 <cmccann> haha
21:26:28 <shachaf> How do you catch a Unicode snowman?
21:26:32 <shachaf> Unic up on it.
21:26:39 <cmccann> yes ok my initials stand for Control.Monad from now on
21:26:43 <cmccann> time to change my last name
21:27:02 <shachaf> cmccann: If you change it, it won't be your last name anymore...
21:27:26 <cmccann> sure, it'll be the last name I had before the new one
21:27:44 <cmccann> see, I got this covered
21:28:36 <shachaf> Control.Monad.Cover
21:29:55 <dmwit> shachaf: Oh, I know this one. Next up is "how do you catch a namespace with a Unicode snowman in it?"
21:30:14 <dmwit> name way: Unic up on it
21:34:55 <Cale> dmwit: heh
21:35:23 <ddarius> For Cale: http://www.youtube.com/watch?v=J0c4L-AURDQ&feature=plcp
21:36:24 <shachaf> Slides: http://www.haskell.org/wikiupload/6/6c/Hiw2012-simon-marlow.pdf
21:37:13 <Cale> ah, I have seen at least one talk by Simon Marlow on it, but I don't think I've seen this one.
21:38:17 <shachaf> This one is a few days old.
21:38:33 <shachaf> Looks like the HIW had several interesting talks.
21:41:39 <Cale> dmwit: You should write a lyrical verse praising the subtle differences between languages which make them interesting, and it should have a part in each of the world's languages. That would be a truly unique ode.
21:42:14 <dmwit> =D
21:43:36 <dmwit> (Did I miss a pun in there?)
21:43:53 <Cale> So long as you found the obvious one, you didn't miss it.
21:44:13 <shachaf> Cale: Perhaps *you* missed a pun.
21:44:53 <Cale> shachaf: Well!
21:45:22 <ehamberg> god morgen, habbes!
21:58:35 <mm_freak_> how about the unicode symbol for a pile of shit?
21:58:51 <mm_freak_> ok, officially it's called poo, not shit
21:58:54 <copumpkin> 💩
21:58:57 <mm_freak_> but it looks a lot like shit, no shit
21:59:14 <copumpkin> http://snapplr.com/jh35
21:59:36 <startling> I'm a fan of the love hotel myself.
21:59:43 <shachaf> https://plus.google.com/109925364564856140495/posts/WVCgkLVGUZe
22:00:12 <startling> http://unicodelovehotel.com/
22:05:26 <startling> so how do Indexed things in `lens` work, again? I'm not seeing it
22:06:09 <edwardk> startling: write a function (i -> c -> f d) -> a -> f b  with an appropriate constraint on f.  call 'index' on that function
22:06:50 <edwardk> the result will act like a normal traversal/setter/fold, etc after that unless someone uses imapMOf or one of the other combinators that requires an indexed traversal
22:07:07 <startling> what does that function *do*, though? The types aren't making sense to me
22:08:01 <edwardk> heh, lets look at isomorphic first, i think its easier to follow
22:08:12 <startling> alright
22:08:13 <edwardk> Control.Lens.Isomorphic
22:08:29 <edwardk> class Category k => Isomorphic k where isomorphic :: (a -> b) -> (b -> a) -> k a b
22:08:40 <edwardk> now my goal there is to overload function application for isomorphisms
22:08:47 <edwardk> so i make an instance of Isomorphic for (->)
22:08:53 <startling> mhm
22:08:56 <edwardk> instance Isomorphic (->) where isomorphic = const
22:09:09 <edwardk> but i also need to use the (b -> a) method in places
22:09:21 <edwardk> data Isomorphism a b = Isomorphism (a -> b) (b -> a)
22:09:32 <edwardk> instance Isomorphic Isomorphism where isomorphic = Isomorphism
22:09:41 <startling> sure.
22:09:42 <edwardk> now we have two instances of 'k' we can use
22:09:46 <edwardk> so if i had
22:09:59 <edwardk> type a <-> b = forall k. Isomorphic k a b
22:10:04 <edwardk> i could use it as a function
22:10:09 <edwardk> and it'd dumb down to (a -> b)
22:10:24 <edwardk> or i could use it as an Isomoprhism and it'd magically give me the forward version and the inverse
22:10:25 <edwardk> right?
22:10:31 <startling> yeah, understood
22:10:37 <startling> that's pretty clever
22:10:38 <edwardk> from :: Isomorphic k => Isomorphism a b -> k b a
22:10:52 <edwardk> from (Isomorphism f g) = isomorphic g f
22:11:03 <shachaf> Is "from" related to "to"?
22:11:11 <startling> and then it dumbs back down to a function if you need it
22:11:17 <edwardk> yep
22:11:27 <edwardk> (yep it dumbs down) sadly, its no longer related to to
22:11:50 <edwardk> but to is too valuable of a name to give up for a 'foolish consistency' ;)
22:11:58 <startling> heh
22:12:10 <edwardk> ok, so we broken Isomorphic?
22:12:11 <startling> something something hobgoblin
22:12:14 <edwardk> er we grok
22:12:15 <shachaf>     Ambiguous occurrence `index' It could refer to either `Control.Lens.index', imported from `Control.Lens' (and originally defined in `Control.Lens.Indexed') or `Data.Ix.index', imported from `Data.Ix' (and originally defined in `GHC.Arr')
22:12:18 <startling> edwardk, yeah
22:12:32 <edwardk> shachaf: =/
22:12:41 <ddarius> Who uses Ix?
22:12:55 <ddarius> I mean Ix isn't that bad, but it means you are using Data.Array, and who uses Data.Array?
22:13:07 <edwardk> shachaf: alas, i can't make every name collision free
22:13:25 <shachaf> Ixnay on the enslay.
22:13:30 <edwardk> now, we can define Iso
22:13:41 <ddarius> (Actually, there are a few uses for Ix separate from arrays.)
22:13:55 <shachaf> edwardk: What's a free name collision? Does it have to do with forgetful functors?
22:14:12 <edwardk> type Iso a b c d = forall k f. (Isomorphic k, Functor f) => k (c -> f d) (a -> f b)
22:14:25 <edwardk> when you need to compose an Iso with a Lens, it forces k = (->)
22:14:30 <edwardk> and dumbs the Iso down to a Lens
22:14:33 <startling> edwardk: this is C.L.Iso?
22:14:40 <edwardk> yep
22:15:08 <edwardk> When you compose an Iso with an Iso if you use Control.Category.(.) then it'll give you an Iso, otherwise the composition will just silently revert to a Lens
22:15:30 <edwardk> the nice thing with that is that you can use Iso directly as a Lens.
22:15:50 <ddarius> (Control.Category..)
22:15:52 <edwardk> and this is the key to understanding the way overloading works in lens for stuff like Indexed. (which uses a similar but more complicated trick)
22:16:10 <startling> edwardk: I think I follow so far
22:16:59 <edwardk> Now, with index, my goal is to support things like
22:17:24 <edwardk> traverseWithKey :: Applicative f => (k -> a -> f b) -> Map k a -> f (Map k b)
22:17:36 <edwardk> so we have
22:17:49 <edwardk> class Indexed i k where index :: ((i -> a) -> b) -> k a b
22:18:17 <edwardk> instance Indexed i (->) where index f = f . const -- just ignores the 'i'
22:18:49 <startling> edwardk, how's that useful?
22:19:00 <edwardk> newtype Index i a b = Index { withIndex :: (i -> a) -> b }
22:19:17 <edwardk> instance i ~ j => Indexed i (Index j) where index = Index
22:19:29 <edwardk> so like before, we make the function case throw out the 'extra' stuff
22:19:47 <edwardk> and we make a custom Index type that captures all the information 'index' provides
22:20:08 <startling> ah, okay
22:20:33 <edwardk> then we instantiate that type with a replaced with (c -> f d)    and b replaced with (a -> f b)
22:20:53 <edwardk> and you can get index :: (i -> c -> f d) -> a -> f b) -> k (c -> f d) (a -> f b)
22:21:00 <edwardk> for Indexed i k
22:21:14 <startling> eh, what?
22:21:22 <edwardk> index :: Indexed i k => ((i -> c -> f d) -> a -> f b) -> k (c -> f d) (a -> f b)
22:21:53 <edwardk> just by picking appropriate values for the args to k like we did with Iso instead of the more general Isomorphism
22:22:31 <edwardk> type IndexedTraversal i a b c d = forall f. (Indexed i k, Applicative f) => k (c -> f d) (a -> f b)
22:22:47 <edwardk> when k = (->) we throw away the index
22:23:01 <edwardk> when k = Index we keep it. and the user can force that choice using the 'withIndex' accessor since
22:23:06 <edwardk> newtype Index i a b = Index { withIndex :: (i -> a) -> b }
22:23:16 <startling> oh hm
22:23:19 <edwardk> it is just the field that contains the value
22:23:24 <startling> it's starting to make a little sense
22:23:45 <startling> how do you come up with this stuff?
22:24:05 <edwardk> i knew what i wanted and i'm pretty good at making the types eventually do that if i put my mind to it =P
22:24:29 <edwardk> Now, unlike Isomorphism, Index doesn't form a Category.
22:24:44 <edwardk> So I have combinators like:
22:24:46 <edwardk> (<.>) :: Indexed (i, j) k => Index i b c -> Index j a b -> k a c
22:24:54 <startling> but no id?
22:24:58 <edwardk> which provide indexed compositions
22:25:10 <ddarius> data Record a b z = Record { _a :: A a b z, _b :: B a b z, _c :: C a b z };  class Recorded a b z r where recorded :: A a b z -> B a b z -> C a b z -> r a b z
22:25:36 <edwardk> foo <. id = foo  and id .> foo = foo
22:26:10 <startling> right, but that id isn't an Index.
22:26:37 <edwardk> but there is no id such that when you compose it using (,) that it leaves the index unchanged ;)
22:26:51 <edwardk> so you _have_ to use <. or .> to compose with id. its just not a category
22:28:36 <edwardk> so thats index
22:28:54 <edwardk> withIndex . index = id
22:29:28 <edwardk> then you just get combinators like:    itraverseOf = withIndex
22:29:51 <ddarius> instance Recorded a b z Record where recorded = Record;  newtype AnA a b z = AnA { theA :: A a b z }; instance Recorded a b z AnA where recorded = AnA
22:30:17 <edwardk> ifoldMapOf l f = runAccessor . withIndex l (\i -> Accessor . f i)
22:30:25 <edwardk> ddarius: not sure i follow where you are going with that
22:34:27 <ddarius> Just generalizing the pattern in Isomorphic and Indexed to arbitrary records.
22:36:15 <ddarius> It's like type directed component selection.
22:37:45 <ddarius> type HasRecord a b z = forall r. Recorded r => r a b z
22:38:30 <ddarius> Now if something produces a HasRecord a b z, you can use as much or as little of it as you want implicitly.
22:39:53 <ddarius> This may be useful generally for providing rich amounts of data that degrade gracefully.
22:41:18 <ddarius> Of course there's no real reason to split the record apart into multiple arguments (but then there's no real reason to build the record just to immediately deconstruct it.)
22:41:48 <ddarius> I.e. class Recorded a b z r where recorded :: Record a b z -> r a b z;  instance Recorded a b z Record where recorded = id;
22:42:21 <shachaf> Do you mean instance Recorded a b z AnA where recorded x y z = AnA x?
22:42:31 <ddarius> shachaf: Yes.
22:46:23 <ddarius> This has connections to representability.
22:48:38 <ddarius> Hmm.
22:48:56 * ddarius might start explaining universal elements using a representation not too different from this.
22:52:22 * ddarius considers going through all of Shin Angyo Onshi again.
22:55:26 <shachaf> I like how every other function in the GHC codebase starts with "dflags <- getDynFlags"
22:55:51 <ddarius> getDynFlags = do dflags <- getDynFlags; ...
22:56:07 <ddarius> Easy exercise: Generalize the above representation to do sums as well.
22:58:04 <shachaf> ddarius: That's not a function.
23:02:10 <certainty> moin
23:12:43 <unlink> What's a good high-level database binding which handles exceptions well and lets me drop down to raw SQL if I need to?
23:13:04 <unlink> Quality of Haskell binding library is more important to me than the particular DB I use.
23:18:09 <AfC> unlink: mysql-simple and postgres-simple?
23:19:16 <AfC> unlink: if you want constructs to give you a higher order functional interface to the notion of database, there are quite a few [new or otherwise] projects floating around; open question whether they're any good or not.
23:19:55 <AfC> unlink: I'd be wary of the tradeoffs being made in the name of type safety; people once thought object-relational mapping was a slick idea, too.
23:20:15 <AfC> unlink: Ultimately, though, a matter of taste I expect.
23:21:24 <startling> wow, Plated is useful
23:22:08 <startling> can I run "someLens %~ fn" on two lenses at the same time?
23:23:25 <startling> say I have a data Twice a = Twice a a. since they both have to be the same type, I can't run an (a -> b) function over the first lens and then the second lens.
23:25:29 <unlink> AfC: I know all of the queries I will want before hand, so it is very easy for me to evaluate whether one of those libraries will be sufficient.
23:26:12 <johnw> unlink: have you look at esquelto?
23:26:23 <johnw> esqueleto
23:26:29 <johnw> @hoogle esqueleto
23:26:29 <lambdabot> No results found
23:26:32 <johnw> @google esqueleto
23:26:33 <lambdabot> http://www.shopesqueleto.com/
23:26:33 <lambdabot> Title: ESQUELETO
23:26:44 <johnw> well, it's spelled something like that anyway
23:27:49 <startling> @google haskell esquelito
23:27:50 <lambdabot> http://xdecrypt.com/google-mysql-69bf
23:27:51 <lambdabot> Title: decrypt MD5 | FREE MD5 decrypter
23:27:56 <startling> ugh what
23:28:05 <AfC1> johnw: there've been like three of those libraries lately, yeah?
23:28:31 <johnw> esqueleto-0.2.6
23:28:35 <johnw> that's what I have installed
23:29:51 <AfC> Here we are http://hackage.haskell.org/package/esqueleto http://hackage.haskell.org/packages/archive/groundhog/0.1.0.1/doc/html/Database-Groundhog.html and http://hackage.haskell.org/package/persistent
23:30:15 <johnw> esqueleto uses persistent underneath
23:30:39 <johnw> it just adds much more SQL-like query construction
23:31:18 <AfC> I must admit, I'm not convinced by any of them. I dare say if one of them gels in your worldview, then it'd be fine, but serialization has non trivial costs and most attempts to do an EDSL to replace writing SQL have (regardless of programming language) been a disaster.
23:31:50 <AfC> I'd really like someone to decide that there is One True Way to do it. Then I wouldn't have to have an opinion about it anymore :)
23:32:09 <AfC> and http://hackage.haskell.org/packages/archive/haskelldb/2.1.1/doc/html/Database-HaskellDB.html too
23:32:49 <AfC> unlink: I'd be interested to hear what you end up going with after your analysis
23:32:52 <johnw> yeah, the esqueleto author was in particular disappointed with query performance in HaskellDB
23:33:02 <AfC> "surprise"
23:33:23 <johnw> he said that using a relational algebra was clever, but utterly sucked for join queries that perform super-well in raw SQL
23:33:37 <johnw> so he wrote esqueleto to make sure you do proper joins on top of persistent
23:34:04 <AfC> "When using the an SQL-based backend (such as SQLite or PostgreSQL), an Entity may take any number of columns depending on how many fields it has. In order to reconstruct your entity on the Haskell side, persistent needs all of your entity columns and in the right order...." egads.
23:37:08 <AfC> as an aside, the work being done by the Cloud Haskell crew on serializing closures is fascinating.
23:37:49 * hackagebot sylvia 0.2.1 - Lambda calculus visualization  http://hackage.haskell.org/package/sylvia-0.2.1 (ChrisWong)
23:37:56 <AfC> johnw, unlink: have to run, be interested to hear of your experiences. Cheers.
23:56:39 <isomorphic> > let x = 1 `div` 0 in (Control.Exception.try (print x)) :: (IO (Either SomeException ()))
23:56:40 <lambdabot>   Not in scope: type constructor or class `SomeException'Not in scope: `Contr...
23:58:23 <isomorphic> Hrmm.. I'm trying to make the catch equivalent of the above expression - any thoughts on how to make the types correct?
