00:00:06 <ivanm> @type catch
00:00:06 <lambdabot> forall a. IO a -> (IOError -> IO a) -> IO a
00:00:11 <ivanm> @hoogle catch
00:00:11 <lambdabot> Prelude catch :: IO a -> (IOError -> IO a) -> IO a
00:00:11 <lambdabot> System.IO.Error catch :: IO a -> (IOError -> IO a) -> IO a
00:00:11 <lambdabot> Control.OldException catch :: IO a -> (Exception -> IO a) -> IO a
00:00:17 <ivanm> bah
00:01:24 <isomorphic> ivanm:  Code i pasted works if Control.Exception is imported - issue is that there was apparently a revision to ghc and now it needs explicit type signatures
00:01:26 <ivanm> I prefer handle, which is flipped catch, but: catch (print (1 `div` 0)) (\ e@SomeExceptionP{} -> print e) ?
00:01:42 <ivanm> isomorphic: you mean for extensible exceptions?
00:01:46 <ivanm> that's been since 6.10 I think
00:02:26 <isomorphic> I think so - I'm reading from Ch 19 on RWH, there is a comment on the online version to that affect
00:03:22 <ivanm> yeah, 6.10 came out just after RWH did
00:03:57 <isomorphic> ivanm:  Interesting - that works without an explicit type signature.
00:04:15 <ivanm> yes, because I'm using the constructor
00:04:26 <ivanm> but you usually shouldn't use SomeException
00:04:42 <ivanm> and I typically end up writing my exception handlers as separate sub-functions to provide type sigs
00:04:44 <isomorphic> ivanm:  Prefer something more specific?
00:05:22 <ivanm> yes
00:05:35 <ivanm> the problem with SomeException is that it even stops C-c from working to kill your program
00:06:56 <isomorphic> ivanm:  Ah, okay.  My goal at this stage is to make toy applications work so that I have some practical intuition
00:07:06 <ivanm> *nod*
00:23:30 <isomorphic> ivanm:  The @ syntax you use - is there a name for that I can google?
00:23:42 <ivanm> ummmm....
00:23:50 <ivanm> at-patterns maybe?
00:24:03 <ivanm> it lets you do a pattern match whilst also naming the entire variable
00:24:10 <isomorphic> Yes, that's they look like as patterns
00:24:11 <ivanm> e.g. foo xs@(a:as)
00:24:18 <isomorphic> but I've not seen one in a lambda
00:24:21 <ivanm> ^^ xs is the whole list, a is the head, as is the tail
00:24:36 * killy9999 needs help with getting started with QuickCheck
00:24:50 <killy9999> how do I create test data generator by hand?
00:25:04 <killy9999> let a = MkGen (System.Random.mkStdGen 2) 10
00:25:13 <killy9999> this is obviously not correct syntax
00:25:56 <ivanm> why do you want test data?
00:26:08 <shachaf> isomorphic: Try Hoogle instead.
00:26:11 <shachaf> http://www.haskell.org/hoogle/?hoogle=%40
00:26:25 <ivanm> shachaf: hoogle searches for syntax symbols as well? :o
00:26:33 <shachaf> Yep.
00:26:34 <killy9999> ivanm: I want to understand what's going under the hood
00:26:39 <ivanm> :o
00:26:47 <isomorphic> killy9999:  Have a look at the function sample - I think it solves the problem
00:26:56 <isomorphic> sample :: Show a => Gen a -> IO ()
00:27:02 <ivanm> killy9999: it uses the Random stuff from the random package (StdGen, etc.)
00:27:13 <ivanm> the Gen monad is about how to generate data
00:27:15 <isomorphic> killy9999:  Give it a Gen a
00:27:32 <ivanm> shachaf: that's cool; never knew it did keywords as well!
00:28:22 <isomorphic> shachaf:  Thanks :)
00:28:45 <killy9999> isomprphic: I'm affraid I don't know how should I do that :(
00:29:05 <isomorphic> killy9999:  Give me a sec - I'll try to make something you can experiment with
00:29:10 <killy9999> ok
00:29:20 <killy9999> MkGen :: (System.Random.StdGen -> Int -> a) -> Gen a
00:29:37 <killy9999> I feel like an idiot, because I know the type signature and I can't make sense of it :/
00:30:04 <killy9999> basically I'm reading RWH, but it uses QuickCheck 1.0, so the chapter is kinda out of date
00:30:25 <ivanm> killy9999: it means that Gen is a wrapper around StdGen -> Int -> a
00:30:53 <ivanm> so it takes a random seed, a "size" value and returns a value of type 'a'
00:31:26 <killy9999> let a = MkGen (System.Random.mkStdGen 2) 10
00:31:30 <killy9999> so why doesn't this work?
00:31:42 <ivanm> because the type is wrong
00:31:45 <ivanm> @type random
00:31:46 <lambdabot> forall g a. (Random a, RandomGen g) => g -> (a, g)
00:32:04 <killy9999> hm...
00:32:17 <ivanm> so... MkGen $ \ g s -> fst (random g) `mod` s
00:32:29 <killy9999> System.Random.mkStdGen :: Int -> System.Random.StdGen
00:32:31 <ivanm> ^^ bounded non-negative Integer values
00:32:47 <ivanm> @type \ g s -> fst (random g) `mod` s
00:32:48 <lambdabot> forall b a. (Random a, RandomGen b, Integral a) => b -> a -> a
00:33:03 <killy9999> shouldn't mkStdGen 2 return a value of type StdGen >
00:33:04 <killy9999> ?
00:33:08 <ivanm> actually, since you need an Int, it's only an Int value
00:33:16 <ivanm> killy9999: yes
00:33:17 <killy9999> @type mkStdGen
00:33:18 <lambdabot> Int -> StdGen
00:33:27 <ivanm> but your usage of MkGen is wrong
00:33:32 <ivanm> MkGen takes a _function_
00:33:38 <killy9999> I see
00:34:04 <killy9999> somehow I knew it but I thought that this could be done without the need for lambda
00:34:18 <ivanm> sure, you can define a function elsewhere and return that
00:34:24 <ivanm> or use the various combinators that QC defines
00:34:50 <ivanm> I doubt many people use MkGen directly
00:35:12 <killy9999> as I said - I only want to understand how this works
00:35:33 <killy9999> right now I still don't...
00:35:37 <ivanm> if you mean "how does QC do what it does", I think there are some papers
00:35:42 <ddarius> x@y is called an as-pattern.
00:36:00 <isomorphic> > sample $ choose (1,5)
00:36:01 <lambdabot>   Not in scope: `sample'Not in scope: `choose'
00:36:05 <killy9999> ivanm: no I;m not into gory details
00:36:19 <ivanm> killy9999: if you want to just _use_ QC, then RWH is still mainly correct
00:36:21 <killy9999> more like an idea of what happens
00:36:26 <ivanm> except you just want arbitrary, not coarbitrary
00:36:37 <isomorphic> killy9999: sample $ listOf $ choose (1,5)
00:36:45 <ivanm> killy9999: you give QC a function to test, and it knows how to generate inputs of that type
00:37:14 <ivanm> so it generates a value; tries it; if the function works it increases the "size" of allowed values (length of lists, etc.) and tries again
00:37:23 <killy9999> isomorphic: thanks, I'll play with that
00:37:32 <ivanm> if it finds a case where it fails, it tries to use the shrink function to reduce it to a more minimal case
00:37:40 <ivanm> if all test succeeds, then it finishes
00:37:44 <killy9999> mhm
00:38:23 <killy9999> I guess my main problem is that I can't figure out how to orginize and automate my tests
00:38:35 <killy9999> I mean I've been doing TDD for years in Java
00:38:46 <ivanm> there are various test frameworks available
00:38:52 <ivanm> with integration support for QC
00:38:59 <killy9999> I know that this channel is not the best place to speak good about Java, but as far as TDD goes Java is great
00:39:13 <killy9999> I;m aware of test-framework
00:39:32 <killy9999> I'll try to figure out how this works
00:40:27 <isomorphic> killy9999:  OK.  So, remember quickcheck is a bit different to junit
00:40:59 <killy9999> isomorphic : yes, I know it's based on properties
00:41:17 <killy9999> and I'm also awaro of HUnit, which I plan to learn sometime in the near future
00:41:33 <isomorphic> killy9999:  With HUnit, you can do things like:     functionName = TestCase $ assertEqual "Thing" (1 :: Integer) (fibonacci 1)
00:41:46 <isomorphic> (or whatever the first fibonacci number is)
00:41:53 <killy9999> but the question of test organization is still an open issue to me
00:42:05 <killy9999> where should I put my tests?
00:42:17 <isomorphic> Ok.  I can tell you how I do mine
00:42:24 <isomorphic> But it's probably wrong ;)
00:42:32 <killy9999> Java allows to separate the tests from the actuall code and at the same time allows tests to be located in the same packages as the tested classes
00:42:38 <isomorphic> I have a separate file
00:42:55 <killy9999> I've googled up some blog posts
00:43:23 <isomorphic> main = do  quickCheckWith Args { replay = Nothing, maxSuccess = 1000, maxDiscard = 1000, maxSize = 100, chatty = True} prop_fibonacci
00:43:26 <killy9999> and people advocate different approaches: all tests in one file, tests located in the same files as source code they are testing
00:43:42 <isomorphic> and then I write in the same file a definition for my prop_fibonacci
00:44:47 * killy9999 notes that down
00:44:53 <ivanm> killy9999: IMO it's better not to have a direct QC dependency on your package _unless_ you're building and running the tests (i.e. keep the properties together with the code if you want, but not the actual QC instances, etc.)
00:45:14 <isomorphic> which is something along the lines of prop_fibonacci i = (i >= 0) ==> fibonacci (i) + fibonacci (i+1) == fibonacci(i+2)
00:45:46 <mapf> ivanm: xmonad uses same approach
00:45:53 <isomorphic> (or however the property of the fibonacci series is defined)
00:46:10 <killy9999> ivanm: so say I'm developing my package wand when the development is done I want to separate the tests from the release
00:46:32 <isomorphic> killy9999:  Is the property of the series I'm suggesting evident from the code?
00:46:39 <ivanm> killy9999: if you use Cabal, it has support for testing; it's in the same tarball, just not built and installed by default
00:46:39 <killy9999> or at least make in such a way that people installing the app/lib don't need dependencie to QC
00:46:43 <killy9999> how do I do that?
00:47:15 <killy9999> isomorphic: yes
00:47:34 <isomorphic> killy9999: cool :)
00:48:14 <killy9999> no, one thing is unclear I guess - where do you put that main ?
00:48:32 <killy9999> ivanm: I didn't know that, I'll look into cabal documentation
00:49:04 <killy9999> and I still don't know where to put the tests...
00:49:21 <killy9999> in the same file as tested functions?
00:49:27 <isomorphic> killy9999:  in your project, have a directory src and a directory test
00:49:38 <killy9999> ok, that's how Java does it
00:49:43 <isomorphic> In your cabal file, test/Main.hs
00:50:03 <isomorphic> Main-Is:            Main.hs
00:50:21 <killy9999> but in Java if I have, say src/myPackage/MyClass.java and test/myPackage/MyClassTest.java
00:50:25 <isomorphic> then, cabal configure ; cabal test
00:50:30 <killy9999> then these two files are considered to be in the same package
00:51:35 <killy9999> so the question is: do these tests have access to functions that are not exported from the modules?
00:51:56 <isomorphic> killy9999:  If you have a cabal file, take the stanza that makes your executable (Executable foo) and change it to "Test-Suite foo"
00:54:04 <killy9999> so if I create "Test-Suite foo" section with tests in test/ dir I can run tests with cabal test?
00:54:49 <killy9999> is this the built in feature of cabal meant especially for testing, or could I possibly replace the word "test" with anything else and it still would work?
00:55:09 <ivanm> you need to have Test-Suite
00:55:27 <ivanm> as for the directory, you state which directory it's in
00:55:38 <killy9999> OK
00:55:45 <killy9999> I guess I should RTFM
00:55:57 <killy9999> and then come back with questions
00:57:06 <killy9999> one last question
00:57:15 <killy9999> RWH has this code:
00:57:43 <killy9999> generate 10 (System.Random.mkStdGen 2) arbitrary :: [Bool]
00:58:08 <killy9999> how to do this in QC 2.x ?
00:59:10 <ivanm> I don't think you can
00:59:38 <killy9999> isomorphic gave a similar example, but the result was in the IO monad
00:59:50 <ivanm> yes
00:59:54 <ivanm> because it gets the initial seed
00:59:58 <ivanm> rather than you providing one
01:00:11 <ivanm> @hoogle Int -> Gen a -> [a]
01:00:12 <lambdabot> Test.QuickCheck.Gen vectorOf :: Int -> Gen a -> Gen [a]
01:00:12 <lambdabot> Test.QuickCheck vectorOf :: Int -> Gen a -> Gen [a]
01:00:12 <lambdabot> Prelude replicate :: Int -> a -> [a]
01:00:19 <ivanm> oh, vectorOf
01:00:25 <ivanm> duh, that's still in Gen
01:00:41 <ivanm> killy9999: in QC 2, the usage of random numbers is hidden from you
01:01:16 <Cale> er, wait, what?
01:01:22 <ivanm> isn't it?
01:01:36 <ivanm> I haven't actually looked at the QC docs for a while
01:01:58 <ivanm> so I'm just vaguely remembering how I did the equivalent of generate after reading RWH
01:02:10 <Cale> Well, there's an explicit Gen monad which is basically a Reader (StdGen, Int), and arbitrary is a computation in it.
01:02:31 <killy9999> oh wait
01:02:48 <ivanm> Cale: yes, but killy9999 wanted to run Gen with a provided seed so as to purely generate values
01:02:50 <killy9999> is "Gen a" just an IO monad in disguise?
01:02:55 <ivanm> killy9999: no
01:02:57 <Cale> It's not IO
01:03:05 <ivanm> @type quickCheck
01:03:06 <lambdabot> forall prop. (Testable prop) => prop -> IO ()
01:03:09 <killy9999> but it has IO monad hidden?
01:03:11 <ivanm> ^^ but you run it in IO
01:03:12 <Cale> :t unGen
01:03:13 <lambdabot> Not in scope: `unGen'
01:03:24 <Cale> :t Test.QuickCheck.Gen.unGen
01:03:25 <lambdabot> forall a. Gen a -> StdGen -> Int -> a
01:03:57 <ivanm> @hoogle resize
01:03:58 <lambdabot> Test.QuickCheck.Gen resize :: Int -> Gen a -> Gen a
01:03:58 <lambdabot> Test.QuickCheck resize :: Int -> Gen a -> Gen a
01:03:58 <lambdabot> Graphics.Rendering.OpenGL.GL.Texturing.Specification maxTextureSize :: TextureTarget -> GettableStateVar GLsizei
01:04:17 <ivanm> no, wait, use replicateM
01:04:33 <Cale> You can also use quickCheckWith
01:05:07 <ivanm> @type \ g s gn -> unGen g s $ replicateM s gn
01:05:08 <lambdabot> Not in scope: `unGen'
01:05:14 <ivanm> oh, wrong way round anyway
01:05:19 <ivanm> @type quickCheckWith
01:05:20 <lambdabot> forall prop. (Testable prop) => Args -> prop -> IO ()
01:05:33 <ivanm> Cale: killy9999 wanted [a] as the result, not IO ()
01:06:05 <Cale> oh, he just wants to run computations in the Gen monad?
01:06:12 <ivanm> yes
01:06:16 <ivanm> so you could use unGen
01:06:20 <killy9999> Cale: I wan't to understand how QC works under the hood
01:06:28 <ivanm> and to get a list of specified length, do a resize
01:06:36 <killy9999> to be aware of what and how it does for me
01:06:43 <Cale> killy9999: Okay
01:07:22 <killy9999> sadly, I wasn't able to find a comprehensive tutorial about QC
01:07:22 <Cale> killy9999: So basically,   newtype Gen a = MkGen { unGen :: StdGen -> Int -> a }
01:07:53 <killy9999> I found lot's of good information, but scattered on various blogs
01:08:05 <mikeplus64> is there a way to, with TH, "find" all the locally declared functions/values of a specific type?
01:08:25 <Cale> mikeplus64: Probably not.
01:08:27 <ivanm> mikeplus64: that sounds more like a parsing job...
01:10:32 <Cale> killy9999: So if this makes sense, you can sort of think of a value of type Gen a as being like a family of random variables, indexed by a "size" parameter, the Int parameter there.
01:11:08 <ivanm> mikeplus64: why do you want to know?
01:11:31 <Cale> killy9999: In order to generate a random value of type a, of a given size, QuickCheck is going to unpack that function with unGen, and then apply it to the state of the pseudorandom number generator, and the size that it wants.
01:11:45 <mikeplus64> ivanm: because i'm lazy and don't want to update a Map with a bunch of functions i'm defining all the time :)
01:12:06 <mikeplus64> (and always forget to)
01:12:35 <ivanm> so are you wanting to edit all the functions? or somehow create a list of all these functions?
01:12:46 <Cale> (Note the full type of unGen :: Gen a -> StdGen -> Int -> a)
01:13:52 <mikeplus64> ivanm: i mean, update as in actually edit the fromList [...] thing, i.e. add or remove functions i'm defining
01:14:05 <ivanm> ahhhhh
01:14:24 <mikeplus64> i think i'm grossly overthinking what is a very simple task (add an element to a list manually)
01:14:25 <Cale> mikeplus64: One option would be to put the code which generates them inside of a Map in the first place to keep the definitions together
01:14:35 <mikeplus64> yeah
01:16:16 <killy9999> Cale: this makes sense, but I guess I still don't see how can I (or why can't I) generate, say a list of 10 random integers by hand
01:16:43 <Cale> You can
01:16:48 <killy9999> assuming that I pass in the StdGen
01:16:50 <killy9999> how?
01:17:55 <killy9999> oh dear, I just tried to understand what Property type is... I think that trying to understand QC internals is not a good way to learn it
01:17:58 <Cale> unGen (vectorOf 10 arbitrary) (mkStdGen 42) 10
01:18:06 <Cale> oh, of course, give that a type signature
01:18:12 <Cale> because it's ambiguous
01:18:23 <Cale> you'll have to import Test.QuickCheck.Gen and System.Random
01:19:14 <killy9999> hah, briliant!
01:22:34 <Cale> A Property is QuickCheck's generalisation of Bool in order to give more information about the outcomes of tests, and to be able to do some I/O to monitor testing.
01:23:14 <Cale> It is kinda hairy :)
01:24:22 <Cale> You don't really have to understand all the details of how that works though, to make sense of it. The important thing is that Property is an instance of Testable, so things which happen to make Property values are okay to use as arguments to quickCheck
01:25:22 <Cale> It happens that Property is the case which it turns everything else that it accepts into, but that means Property has to be quite a rich structure to cope with all the features that QC has.
01:25:50 <Cale> If you want to mostly replace it with Bool in your head, you won't be far off the mark though.
01:27:00 <killy9999> mhm
01:27:39 <killy9999> I'm not yet sure when do I have to use Property and when I can use Bool
01:27:49 <killy9999> I noticed that ==> requires usage of Property
01:27:55 <Cale> ah, yeah
01:29:00 <Cale> The cleverness there is that p ==> q won't count toward the test limit when p is unsatisfied.
01:29:09 <killy9999> ok, I see there's a bunch of combinators that return Property
01:30:55 <ivanm> Cale: yes, but there is a discard limit
01:31:05 <ivanm> and if p fails too many times then QC will stop
01:31:10 <Cale> right
01:37:04 <sopvop> Dear #haskell, 3 months ago I made a few simple functions to do validation of input and updating stored data with it. In following 3 months I've refactored it 4 times using more and more advanced type system features. And now have refactored it all back to almost the same simple thing I had.
01:37:37 <Lemmih> sopvop: It's all about the journey. (:
01:37:53 <hirsch_> why must a quasiquoter be defined in a separate module?
01:37:54 <sopvop> It's all about KISS :)
01:39:43 <alpounet> sopvop, as long as you have learned a few things in the process, i'd say it's cool
01:41:43 <ivanm> hirsch_: I think because it's sourced separately or something
01:41:55 <ivanm> (to do with TH rather than being QQ specific)
01:42:37 <hirsch_> ivanm: ok, i suppose there's no way around it?
01:43:29 <ivanm> not AFAIK
01:44:00 <Cale> sopvop: Well, yeah, it's all about deciding which properties of your program are worth enforcing at compile time.
01:44:05 <merijn> I don't suppose it's possible to define a TypeFamilie "type instance Foo () = Bar; type instance Foo b = Baz b"?
01:44:14 <Saizan> no.
01:44:42 <merijn> hmm :\
01:45:44 <merijn> I guess there's also no type level inequality operator (i.e. the reverse of ~)?
01:45:54 <ivanm> nope
01:46:31 <sopvop> Cale: in my case it was more about automating things to make less coding. In the end there were more coding :(
01:46:35 <merijn> Bah, I want a better type system :p
01:46:43 <ivanm> merijn: agda? ;)
01:49:49 <alpounet> merijn, there must be some work around to get what you want
01:50:21 <hiptobecubic> if we have ~  it seems like it should be easy to also have /~ ?
01:50:40 <Cale> hiptobecubic: I'm not so sure.
01:50:56 <hiptobecubic> if ~ succeeds then it fails. otherwise it succeeds?
01:51:04 <merijn> alpounet: How?
01:51:09 <Cale> Maybe, but equality is often a much nicer relation than inequality.
01:51:23 <Cale> ~ doesn't always just succeed or fail
01:51:30 <merijn> ivanm: Now that I've started using more advanced type extensions Agda is starting to seem much nicer :p
01:51:36 <ivanm> heh
01:51:47 <quicksilver> ~ isn't an equality check, exactly
01:51:49 <Cale> It unifies the things on either side of it
01:51:51 <quicksilver> it's a unification constraint
01:51:54 <quicksilver> that's quite different
01:52:01 <quicksilver> it's not "like" Type -> Type -> Bool
01:52:12 <hiptobecubic> How not?
01:52:16 <quicksilver> instead it's an extra constrain which helps unification
01:52:17 <merijn> Yeah, I guess that was poorly chosen
01:52:25 <quicksilver> and may later cause a rejection
01:52:30 <quicksilver> or maybe simple get propogated
01:52:44 <merijn> hiptobecubic: Because the "[()] ~ [a]" is unifies as long as a can be ()
01:52:56 <merijn> s/is//
01:53:03 <Cale> hiptobecubic: Suppose we have something like (a,b) ~ (c,d) -- this reduces to (a ~ c, b ~ d), and those constraints might be propagated somewhere else, where they cause other type variables to become equal
01:53:05 <merijn> also s/the//
01:53:25 <hiptobecubic> but at some point, we know if the constraint is satisfiable right?
01:53:30 <Cale> It's not just a one-time test
01:53:53 <merijn> My main problem is that I want to specify an implementation that is different for () but the same for all other types, without having to exhaustively list the other types
01:53:54 <Cale> hiptobecubic: Perhaps not during the compilation of the module?
01:54:09 <hiptobecubic> Cale, then when?
01:54:11 <merijn> I guess the only solution would be typeclass + overlappinginstances
01:54:28 * alpounet is trying to find a overlappinginstances-less solution
01:54:59 <Cale> hiptobecubic: During the compilation of some future module which depends on this one.
01:55:00 <merijn> Which seems bad (and less preferable to having less nice solution of just having two functions, one for () and one for the other case)
01:55:35 <Cale> hiptobecubic: Though I guess where that happens, the equality constraint always appears as part of the interface
01:55:46 <hiptobecubic> but that modules will know then whether or not it's satisfiable. I don't see why we can propagate ~ indefinitely but not /~?
01:55:52 <hiptobecubic> module*
01:56:06 <Cale> I guess we can.
01:56:18 <Cale>  /~ doesn't usually tell you so much though.
01:56:33 <Cale> Like suppose I know a /~ Integer
01:56:51 <Cale> ... I need something that I can do with this information.
01:57:09 <hiptobecubic> Fail to compile if a has to be an Integer?
01:57:11 <merijn> Cale: Well, it avoids the need for OverlappingInstances when trying to special case Integer
01:57:12 <Cale> There are still no operations I can perform validly on a value of a type I know isn't Integer
01:57:29 <Cale> yeah, I guess you could use them in instance selection.
01:57:36 <Cale> But hmm...
01:57:41 <merijn> Cale: And using typefamilies + GADTs it would be nice
01:58:21 <killy9999> Can I override instance declaration?
01:58:49 <Saizan> you'd have to make instance selection care about contexts first
01:58:53 <hiptobecubic> isn't that what ~ already does? [()] ~ [a] doesn't appear to let you do anything either. Just constrains you to a's which can be replaced with ()  right?
01:58:56 <ivanm> killy9999: with some extensions you can override some of them, but you usually shouldn't
01:59:37 <Cale> hiptobecubic: If you know that a ~ Integer, for example, and x :: a then you know that x + 1 is valid
02:00:04 <Cale> hiptobecubic: But if you know that a /~ Integer, and x :: a, then there's very little you can do still.
02:00:26 <merijn> Cale: I agree that inequality is not really useful for code itself, but for type level coding and can help you select the right instance without resulting in ugly OverlappingInstance hacks
02:00:29 <Cale> There are some funny cases where the information could conceivably be used, particularly involving GADTs, maybe
02:00:39 <killy9999> ivanm: I want to override declaration of Arbitrary Char in QC, so that I can generate diacritic signs from my language
02:00:46 <killy9999> I mean I don't really nedd that
02:00:55 <killy9999> but I'm curious if it could be done
02:00:59 <ivanm> no
02:01:11 <ivanm> if you define a type alias, I think you can do it for your alias
02:01:17 <ivanm> but even then, it's a bad idea
02:01:19 <Cale> But for instance selection, that's a pretty heavy change as well, because contexts are completely ignored for instance selection at present, as I understand things.
02:01:37 <ivanm> for graphviz, I needed a custom way of generating strings, so I wrote custom Gen String values and used those
02:01:47 <Cale> You *could* make use of the inequality there, I'll admit.
02:01:47 <merijn> I have a GADT that has either a pair of values or only a single one. The single case is encoded by () in the GADT type, so being able to distinguish that one would be very nice for selecting between the two cases
02:01:56 <killy9999> ok
02:02:23 <Cale> merijn: what is the pair case encoded by?
02:02:24 <merijn> Cale: For instance selection of typeclasses it might be more hassle than needed, but for type funs it shouldn't be, right?
02:02:28 <Cale> merijn: why ()?
02:02:55 <merijn> Cale: Well, I could introduce a new type for the empty case, but that doesn't add much value
02:03:07 <merijn> Cale: The pair case has the type of the second pair entry
02:04:08 <merijn> So havin (a /~ ()) would let my code deal with the pair case, regardless of what the value is
02:05:03 <Cale> I'll admit that part of my view here is coming from a gut reaction that equational theories are nice and other relations are often not an acceptable substitute. The one occurrence of /= in the definition of a field means the difference between the theory of rings and groups and vector spaces etc. being easily encoded by monads and fields not.
02:05:46 <Cale> (The constraint that multiplicative inverses only apply to numbers which aren't 0)
02:06:47 <astry> Cale: don't you think it's more about not having edge cases?
02:06:59 <astry> monads don't have special cases, fields do
02:07:01 <hpaste> merijn pasted “TypeFamilies + GADTs” at http://hpaste.org/75043
02:07:03 <quicksilver> merijn: I think you underestimate the deeprootedness of the fact that constraints are not part of instance resolution.
02:07:23 <merijn> quicksilver: Hence why I said I'd settle for constraints on type funs :p
02:07:24 <quicksilver> I think this is a very deep fact about the haskell language, not a trivial choice which can easily be altered.
02:07:25 <astry> if you had a monad-with-special-case it could probably encode a field in some way
02:07:31 <merijn> quicksilver: That'd be good enough for most of my use cases
02:07:56 <merijn> quicksilver: And since type funs are resolved at compile/type checking time the constraints should be available there, no?
02:09:03 <merijn> If I could have "type instance Foo a () = Bar a; type instance (b /~ ()) => Foo a b = Baz a b" that'd be sufficient
02:09:23 <mm_freak_> merijn: Single :: a -> MyType Nothing a;  Pair :: a -> b -> MyType (Just b) a
02:09:32 <mm_freak_> merijn: that's clean and doesn't require type inequality
02:09:36 <mm_freak_> (but DataKinds)
02:10:12 <Cale> astry: Well, in what sense? That "edge case" is created by the use of not equal to. The models of any equational theory -- one which defines a bunch of k-ary operations and universal equational properties they need to satisfy, can be encoded as the algebras for some monad.
02:10:13 <merijn> mm_freak_: That doesn't solve my problem, because then I still can't get the mapVariants signature I want (see paste)
02:10:52 <merijn> mm_freak_: That solution is trivial to implement even without constraints OR data kinds. But I'd have to implement mapVariants twice
02:11:07 <merijn> (One version ignoring the paired items, one using them)
02:11:45 <astry> Cale: what are some edge cases you can come up with in equational theories ?
02:12:04 <Cale> astry: well, none -- it's almost a definition of what edge cases mean
02:12:15 <Cale> astry: anything which isn't universally equational :)
02:12:34 <astry> so you see the issue here
02:12:56 <merijn> mm_freak_: Actually, maybe I can hack my way around this using DataKinds and type synonyms :)
02:13:14 <astry> maybe there are classes of non-equationality?
02:13:33 <mm_freak_> merijn: i didn't read the full backlog, so that's my solution =)
02:13:37 <astry> for example, "set with one edge case" or "set with two edge cases"
02:13:58 <mm_freak_> merijn: with my limited understanding of your problem, it appears as if you want to define a fold
02:14:14 <astry> if you could find a good generalization of this, you could encode more complex stuff in your language
02:14:52 <astry> for example what if you had monad-with-one-edge-case, for example monad-without-division-by-zero
02:14:59 <Cale> astry: If you can come up with a nice categorical characterisation of the category of fields, I'd love to see it. I've thought this same thing, but failed to work out any good way of being able to encode a condition like that.
02:15:03 <mm_freak_> a fold includes morphisms for each constructor, so if you have two constructor, but your fold has only one morphism, it's not a fold
02:15:44 <astry> well, it's really similar to geometry
02:15:59 <astry> you can only do so many things with sets that are 1-dimensional in every point
02:16:06 <Cale> astry: how do you go about defining a "monad with one edge case"?
02:16:13 <astry> i don't know
02:16:24 <Cale> Neither does anyone else :)
02:16:24 <astry> what about looking at it topologically?
02:16:31 <Cale> (as far as I can tell)
02:16:55 <astry> monads seem to be kind of like the haskell version of a 1-dimensional set
02:17:08 <Cale> er...
02:17:10 <Cale> what?
02:17:14 <astry> they're simple
02:17:19 <astry> no special cases
02:17:49 <Cale> I mean, what's the analogy?
02:17:57 <astry> what if you took a Y set? that's 2-dimensional in one place. you have to perform a choice if you want to keep going
02:18:06 <Cale> ...
02:18:13 <merijn> I'm really racking up the type extension count xD "Perhaps you intended to use -XPolyKinds"
02:18:49 <astry> Cale: this must be really stupid to you, but that's experimental mathematics :)
02:19:09 <astry> most of it is stupid
02:19:13 <astry> until something explodes
02:19:16 <astry> :)
02:19:23 <Cale> astry: Okay, given a category C, a monad on C is an endofunctor T: C -> C together with natural transformations eta: 1 -> T, and mu: T^2 -> T, satisfying left and right unit laws, and associativity, right?
02:19:38 <Cale> (have you seen that definition?)
02:20:02 <astry> i'm not sure how mu would look
02:20:15 <astry> i haven't seen that devinition, but keep going
02:20:19 <hpaste> killy9999 pasted “Old QuickCheck” at http://hpaste.org/75044
02:20:29 <Cale> well, it's kind of important for everything to follow, but okay
02:20:33 <killy9999> hwo should this be done in QC 2?
02:20:42 <astry> if something doesn't follow i can backtrack.
02:20:49 <merijn> "Data constructor `Variant' cannot be GADT-like in its *kind* argument" :(
02:21:27 <Cale> An algebra for T is an object A of C together with a map h: TA -> A which satisfies some natural axioms with respect to eta and mu.
02:22:03 <killy9999> s/hwo/how/
02:22:34 <Cale> In the category of sets, there are appropriate monads T for which the algebras are monoids, groups, rings, vector spaces over a given field, and many other structures.
02:22:41 <Cale> (one monad for each of these)
02:22:48 <alpounet> merijn, can't find an overlappinginstances-less solution, sorry
02:23:04 <astry> but not fields?
02:23:10 <Cale> but not fields, right
02:23:48 <astry> what about semigroups?
02:23:52 <Cale> yep
02:24:22 <Cale> also commutative versions of all those things are fine
02:24:40 <astry> how would you define the monad for the S_3 group?
02:24:58 <astry> what would the eta and mu look like?
02:25:10 <merijn> alpounet: I might have one, if I can figure out the proper syntax without scaring GHC :p
02:25:23 <Cale> The monad would be a monad for *all* groups
02:25:47 <astry> oh, ok. what would it look like?
02:26:51 <alpounet> merijn, oh cool, keep me posted
02:27:29 <Cale> and it sends a set S, treated as some alphabet, to the set of reduced words on that alphabet -- basically, strings of elements of S, and their inverses, such that no inverse pair occurs next to each other.
02:29:08 <astry> ok
02:29:19 <Cale> for any set X, the map eta_X: X -> TX will then send each element x of X to the one-letter word "x"
02:29:34 <astry> is mu "reduction"?
02:30:00 <astry> no.. maybe concatenation? hmm
02:30:11 <Cale> and mu is reduction, so we take a reduced word of reduced words, concatenate them all together, and reduce, removing pairs of adjacent inverses
02:30:24 <astry> ah, both at once, haha
02:30:48 <astry> wait, a reduced word of reduced words doesn't fit in T^2
02:31:06 <astry> wouldn't that be in 2^T?
02:31:09 <Cale> and then the algebras for this monad, are objects G together with a map eval: TG -> G, which is in some ways compatible with the eta and mu
02:31:32 <Cale> T^2 X means T(TX)
02:31:38 <astry> oh ok
02:31:48 <astry> right since T is a functor
02:31:56 <Cale> yeah, it's composition
02:31:58 <hpaste> merijn pasted “GADTs + DataKinds + PolyKinds = won't compile?” at http://hpaste.org/75045
02:32:13 <astry> merijn: stop ricing your code
02:32:21 <merijn> Can someone help explain why this confuses GHC? Or why this is impossible so I should stop trying?
02:32:24 <astry> :)
02:32:35 <Cale> http://en.wikipedia.org/wiki/Monad_(category_theory)#Algebras_for_a_monad -- you can see the conditions here
02:32:38 <astry> Cale: that's nicely explained. so what point are you trying to make?
02:33:22 <Cale> in the case of groups, basically, we think of eval: TG -> G as taking a word of elements of G, and evaluating it all at once down to an elmeent of our group G
02:33:34 <hpaste> hi annotated “GADTs + DataKinds + PolyKinds = won't compile?” with “GADTs + DataKinds + PolyKinds = won't compile? (annotation)” at http://hpaste.org/75045#a75046
02:33:56 <shachaf> hi merijn
02:34:06 <Cale> and the laws for the structure map/evaluation map say that it has to do this in a way which is compatible with mu, and in some sense mu is already encoding the group axioms
02:34:16 <Cale> well, eta and mu together, I should say
02:34:24 <Cale> eta's kind of simple in this case
02:34:47 <merijn> oh...duh
02:34:52 * merijn feels silly now
02:35:04 <shachaf> merijn: Why not just use Maybe?
02:35:05 <astry> eval is h in that article, right?
02:35:17 <Cale> yes
02:35:23 <astry> that is T eval?
02:35:28 <Cale> T is T
02:35:40 <astry> i don't know what you get when you say T eval
02:35:50 <Cale> oh, T eval is the functor applied to eval
02:35:53 <merijn> shachaf: Wait, I can just use maybe automatically promoted?
02:36:00 <astry> right, what does it do?
02:36:01 <merijn> shachaf: Because I'm dumb, probably...
02:36:02 <shachaf> merijn: Everything is promoted.
02:36:02 <Cale> Right, I didn't say what T did to maps :)
02:36:10 <shachaf> Type :k Just in ghci. :-)
02:36:16 <Cale> T sends a function on alphabets to a function on words
02:36:27 <Cale> in basically the obvious way: apply the function to each letter
02:36:28 <shachaf> Hmm, I guess not *everything* is promoted as such.
02:36:53 <astry> so T on functors is map?
02:36:55 <Cale> So if f: X -> Y, then Tf: TX -> TY
02:37:12 <Cale> map is the list functor acting on functions
02:37:48 <astry> what other functors could i know?
02:37:50 <mmaruseacph2> fmap,  maybe :)
02:37:50 <Cale> T is the reduced word functor, and here we're using the same notation for it acting on functions and objects, which is customary for category theory
02:37:53 <merijn> shachaf: The day might yet be saved and two lines of code duplication avoided xD
02:38:04 <Cale> astry: Have you ever used fmap?
02:38:11 <Cale> For, say, the IO functor?
02:38:24 <astry> i think but i forgot what it did
02:38:39 <astry> are you trying to say that T is fmap?
02:38:57 <Cale> IO is a functor: it sends each type t to the type IO t of I/O actions producing results of type t
02:39:04 <Cale> and it sends each function a -> b
02:39:11 <Cale> to a function IO a -> IO b
02:39:20 <Cale> which is what fmap does
02:39:35 <Cale> and yeah, here T is fmap
02:39:51 <astry> right, and IO eval is IO IO a -> IO a?
02:40:01 <Cale> yeah, it would be
02:40:03 <Cale> heh
02:40:12 <Cale> if the IO monad has any algebras at all! :)
02:40:16 <astry> eval is "run" in IO isn't it?
02:40:31 <Cale> yeah, eval would have to have type IO a -> a
02:40:37 <Cale> which in the case of IO is pretty bad
02:40:48 <Cale> so the IO monad is perhaps not the best example here :)
02:40:59 <Cale> actually
02:41:07 <Cale> it would be more like IO A -> A
02:41:15 <Cale> i.e. it wouldn't be a polymorphic function
02:41:19 <Cale> it would have some specific type
02:41:38 <Cale> and I guess there are some IO-algebras, hmmm...
02:41:51 <Cale> (they all happen to internally involve IO in some way)
02:42:33 <astry> so what are you trying to say Cale?
02:42:42 <Cale> Well, this is getting off track
02:42:46 <astry> yeah
02:42:54 <astry> you were going to say something about special cases
02:43:03 <Cale> So, okay, the T-algebra laws here
02:43:28 <astry> on that wiki article?
02:43:41 <Cale> The square says
02:43:54 <Cale> that if we take a reduced word of reduced words, evaluate each of the words in it, and then evaluate the resulting word
02:44:22 <Cale> it's the same as if we first concatenate all the words together and reduce (what mu does), and then evaluate after that
02:44:22 <astry> then we get a letter
02:44:34 <astry> yeah
02:44:41 <hpaste> merijn pasted “Yay, type extensions!” at http://hpaste.org/75047
02:44:56 <merijn> alpounet: Managed to get a working solutions like this: http://hpaste.org/75047
02:45:09 <merijn> No OverlappingInstances necessary :p
02:45:36 <Cale> So that's encoding the fact that evaluation has to be compatible with the way in which we collapse a reduced word of reduced words down -- if you're careful and pick words of the right type, you can extract the traditional group axioms from that here
02:45:45 <astry> this is fairly simple to imagine in the form of IO, e.g. flipping a single bit in a range of RAM could be seen as a letter (and it's its own inverse)
02:46:01 <Cale> The triangle one is just saying that if we evaluate a one letter word, we get that letter
02:46:12 <astry> right
02:46:21 <astry> 1x is something like "head" isn't it?
02:46:33 <Cale> it's the identity map
02:46:34 <Cale> id
02:46:36 <astry> oh
02:46:40 <astry> of course
02:46:52 <astry> right, we start out with x and not Tx
02:46:56 <astry> ok go on
02:47:11 <astry> how can we introduce special cases?
02:47:21 <Cale> I don't know :)
02:47:31 <Cale> It's tricky
02:47:46 <astry> i think if you broke mu you could get somewhere
02:48:45 <Cale> well, we need something analogous to picking out some subset of x where things are going to behave differently from the rest
02:48:57 <astry> we could define mu as a recursive function with a fairly simple body, couldn't we?
02:49:50 <Cale> mu is different in every case
02:50:00 <Cale> mu is a different natural transformation for each monad
02:50:03 <alpounet> merijn, right, my solution just lacked the usage of the promoted Maybe
02:50:08 <Cale> It corresponds to join in Haskell
02:50:10 <Cale> :t join
02:50:11 <astry> start with the first element, take the next element, if they reduce then accumulate nothing and recurse with the next two elements, if they don't reduce then accumulate the left element and recurse with the right element and the next element
02:50:11 <lambdabot> forall (m :: * -> *) a. (Monad m) => m (m a) -> m a
02:50:14 <alpounet> that was the missing bit in my head
02:50:18 <Cale> and eta is return
02:50:20 <Cale> :t return
02:50:21 <lambdabot> forall a (m :: * -> *). (Monad m) => a -> m a
02:50:32 <astry> think i have described mu correctly here?
02:51:08 <Cale> astry: well, you need to be careful because of things like a b c c^-1 b^-1 a^-1
02:51:16 <Cale> but otherwise, something like that
02:51:25 <astry> ok if we have that word then
02:52:15 <astry> we start out with (a, b) which doesn't reduce, accumulate to [a, b] and get (c, c') which reduce so we then get [a, b] and (b', a') which don't reduce so we accumulate [a, b, b', a']
02:52:17 <Cale> If you ever commit entirely to putting a in the reduced word, then the algorithm doesn't work :)
02:52:24 <astry> are you saying they need to reduce too?
02:52:33 <Cale> yes
02:52:42 <Cale> the result should be the empty word
02:52:44 <astry> then we can just run mu until it stops i guess
02:52:56 <Cale> well, the reduction part of my
02:52:57 <Cale> mu
02:53:14 <Cale> remember, mu also concatenates a word of words and then it reduces
02:53:21 <astry> or, on every recursive step, pop off the accumulator and then you have (x, y, z) and see how that reduces
02:53:44 <Cale> Yeah, if you reduce, then you want to "pop the stack" and see if you can reduce again
02:53:59 <astry> so what if we messed with that?
02:54:20 <astry> for example, what if we had an element that can reduce multiple other elements in some way that can't be encoded currently
02:54:23 <Cale> So the challenge isn't how to implement mu computationally
02:54:40 <Cale> The challenge is that for fields, there doesn't seem to be a T and mu and eta which do the job at all
02:55:03 <ehamberg> http://www.explosm.net/comics/2930/ LÅLL
02:55:31 <astry> for example, for an element x, let's say x' is the inverse. Then x'' could be an element which, when multiplied by x, also eats one more letter in each direction.
02:55:56 <astry> that is a simple extension of mu.
02:56:02 <Cale> Okay, so let's suppose we want to represent fields in something like this
02:56:26 <astry> i'm not saying fields could be represented this way, just that it would give us something new
02:56:32 <astry> x" cannot be encoded as a word
02:56:47 <Cale> Well, we can already have different monads which give us new algebras
02:57:04 <astry> sure, but they're still algebras
02:57:12 <astry> something which has x" is not an algebra
02:57:14 <Cale> For example, I can do this same trick with different T and eta and mu, and get rings or vector spaces
02:58:30 <astry> it's fairly chaotic and depends on the order in which you do things. for example, how do you evaluate              a' a a" b c ?           is the next step a" b c, or a" c?
02:59:02 <moobull69> hello everyone, I have a noob question
02:59:06 <Cale> Oh, btw, you can also get compact Hausdorff spaces this way, as the algebras of an appropriate monad on Set :D
02:59:18 <kuribas> Is there a good library for solving a system of nonlinear equations?  I found gsl, but it is very low level.
02:59:31 <mmaruseacph2> isn't it one merit of cat theory that you no longer worry about order or operations? (due to associativity law?)
02:59:37 <astry> what if we said instead we have x''' which, when multiplied from the left with x, eats that x and the next letter to the left. similar in the right direction. Then it could be a little nicer, right?
02:59:56 <Cale> astry: You're allowed to make mu whatever function you like, so long as it obeys the monad axioms, and all the stuff surrounding this will work
03:00:11 <astry> do you think either of my mu obeys the monad axions?
03:00:13 <astry> axioms
03:00:18 <astry> i hate typos :(
03:00:52 <Cale> astry: probably they could
03:01:04 <Cale> astry: well...
03:01:18 <Cale> I don't think I understand the descriptions well enough to really say
03:02:14 <Cale> mmaruseacph2: just because arrow composition is associative doesn't necessarily mean that absolutely everything is
03:02:36 <Cale> moobull69: please ask :)
03:02:37 <mmaruseacph2> Cale: true, but I thought your discussion was into a category theory setup
03:02:51 <mmaruseacph2> (lurking on it since it looks interesting)
03:03:04 <moobull69> I fineally got lambdabot installed, but I don't know how to run it or where the config file is :P
03:03:05 <Cale> mmaruseacph2: I was explaining to astry how we can construct a monad whose algebras are groups
03:03:42 <mmaruseacph2> yep, and he wants exceptions and fields
03:03:58 <astry> Cale: x''' is a generalized inverse.
03:04:05 <Cale> moobull69: I run it with cd ~/.lambdabot/; ~/bin/lambdabot -e 'rc /home/cale/.lambdabot/online.rc'
03:04:06 <astry> Cale: does that help you further?
03:05:25 <hpaste> Cale pasted “example online.rc” at http://hpaste.org/75048
03:06:08 <hpaste> Cale annotated “example online.rc” with “example passwd.rc” at http://hpaste.org/75048#a75049
03:06:31 <moobull69> ooh ok, ill try it thank you cale :)
03:06:44 <Cale> moobull69: btw, the ... is just where I snipped the file
03:06:54 <Cale> you can see where the nick is
03:07:02 <kuribas> Ok, I found that hmatrix can do nonlinear systems :-)
03:07:16 <Cale> you also probably shouldn't join it to this channel or it'll annoy people of course :)
03:07:59 <moobull69> I got it :P
03:09:12 <astry> Cale: basically, think back to our mu.
03:09:48 <Cale> astry: you can actually generalise pretty far: any set of operations of arbitrary arity (0 or more), with any set of equational identifications between terms will give you a monad on Set -- you can equally well take TX to be the set of equivalence classes of syntax trees in your language built on the set X.
03:10:01 <astry> Cale: let's say we have (x, x', y). then we reduce that to (_, _, y) and pop one element off acc (the accumulator) and one off proc (the word left to process)
03:10:18 <astry> so then we get (u, y, v)
03:10:56 <Cale> astry: I don't want to think about how to implement mu with a computer so much
03:11:07 <Cale> astry: but just in terms of what it does
03:11:18 <Cale> (which things does it send to which things)
03:11:26 <astry> if you have (x, x''', y) then you reduce to (_, _, y) and pop an element off acc and throw it away. Then you recurse by popping off acc and proc. You get (w, y, v)
03:12:05 <Cale> and anyway, considering one example of a weird mu won't do
03:12:08 <astry> Cale: i don't think that's got much to do with a computer, it's just a fairly natural angle to look at mu
03:12:26 <astry> in order to break mu you first need to look at mu from some angle, close one eye, and smash it with a hammer :)
03:12:37 <astry> why will it not do?
03:13:23 <Cale> We need a systematic way to express the fact that not all ways of building up terms in our language are valid -- just like how 0^-1 isn't a valid expression on fields.
03:13:25 <astry> i may not fully understand what equational identification means, but i don't think it applies to x'''
03:13:42 <Cale> Well, maybe, I'm tired
03:13:46 <Cale> (it's 6am)
03:13:58 <astry> that's good
03:14:09 <astry> when your brain shuts off, you are released from the burden of knowledge :)
03:14:36 <Cale> knowledge isn't really a burden if you structure it the right way
03:14:59 <astry> structure is a burden if you want to find things that don't follow it
03:15:02 <astry> :)
03:15:19 <Cale> I don't just want to find things that aren't monads
03:15:34 <astry> so, think about it. is x x''' y z a valid word?
03:15:36 <Cale> I want to find a structure analogous to the setup for a monad
03:15:40 <astry> i don't think it is. what is x''' going to eat?
03:15:43 <Cale> in large scale terms
03:15:47 <astry> it's going to eat x, but it'll still be hungry
03:15:53 <astry> we get an error of some sort, don't we?
03:15:55 <Cale> Where you can't say exactly what eta and mu do
03:16:02 <Cale> you can only put laws on them
03:16:11 <astry> well
03:16:14 <astry> what i'm trying to say is
03:16:22 <Cale> I want a setup consisting of some bunch of functors and natural transformations
03:16:27 <astry> this specific example that i gave satisfies your need of being able to construct invalid terms
03:16:43 <astry> maybe if it's nice it'll show us a generalized way of making such things
03:16:52 <Cale> whose natural notion of "algebras" will admit definitions like fields
03:17:10 <astry> sure Cale, just take it one step at a time :)
03:17:59 <Cale> Maybe it's just that I'm tired, so I don't understand, but it looks like you're doing random things to mu, and hoping to see what comes out
03:18:10 <astry> that is exactly what i'm doing
03:18:19 <astry> and so far it also does everything *you* hoped for
03:18:38 <astry> so let's see what more, on this level of detail, you are looking for
03:18:57 <astry> i mean we already have invalid terms.
03:19:09 <Cale> well, I'm going to sleep
03:19:09 <astry> what else do you think are we missing?
03:19:14 <astry> take care :)
03:22:56 <bford> is there any documentation/paper covering how to use haskell-type-extensions?
03:26:13 * merijn isn't sure whether "haskell-type-extensions" is a specific thing or just refers to all existing type system extensions...
03:26:28 <merijn> If the latter, I've recently become an expert :p
03:28:14 <shachaf> merijn: You're an IncoherentInstances expert?!
03:29:23 <merijn> shachaf: No, I've stuck to the safe (and relatively sane) extensions so far. So no IncoherentInstances, OverlappingInstances, UndecidableInstances
03:30:41 <astry> you just need DrunkInstances
03:33:52 <merijn> I've started to appreciate the observation that once your types become abstract enough it becomes almost impossible to write expressions that type check but do the wrong thing :p
03:35:13 <shachaf> merijn: Clearly you haven't tried the most advanced type system extension of them all, -fdefer-type-errors.
03:35:49 <benmachine> merijn: UndecidableInstances is fine
03:37:38 <int-e> @djinn a -> a -> a
03:37:39 <lambdabot> f _ a = a
03:37:53 <fmap> undecidable instances is a needlessly creepy name
03:37:56 <merijn> benmachine: I just haven't needed it :p
03:38:16 <shachaf> @djinn Bool -> a -> a -> a
03:38:16 <lambdabot> f a b c =
03:38:16 <lambdabot>     case a of
03:38:16 <lambdabot>     False -> c
03:38:18 <lambdabot>     True -> b
03:38:19 <shachaf> Clever djinn
03:38:22 <luv> is it possible to inspect a data type in ghci?
03:38:28 <shachaf> luv: :i
03:38:37 <luv> thanks :-)
03:45:00 <hiptobecubic> is it possible for a function to just remove information about a type?  as in foo :: [Int] -> [a] ?
03:45:18 <hiptobecubic> foo = id
03:46:10 <Jeanne-Kamikaze> what are you trying to do ?
03:46:17 <flux> that's an interesting question, although I immediately started to think about that in ocaml context
03:47:01 <hiptobecubic> Jeanne-Kamikaze, i have no idea. I'm just curious.
03:47:19 <Jeanne-Kamikaze> but what's the point ? a function taking [a] will also work on [Int]
03:47:22 <bford> merijn, sorry I was refering to the haskell-type-exts package
03:47:31 <hiptobecubic> i was reading http://okmij.org/ftp/Computation/Subtyping/Preventing-Trouble.html   and looking at his Haskell implementation of the generic "Shapes" example in OOP
03:47:47 <hiptobecubic> abstract base class Shape, and then some subclasses Rectangle, Square, Ellipse, etc
03:47:49 <fmap> I don't think `foo ∷ [Int] → [a]' is what you want since caller can choose the type of a
03:49:03 <hiptobecubic> He does a neat trick where, when resizing, he returns a Square instead of a Rectangle if the width and  height of the resized rectangle are equal. But that only works because his implementation of rectangle resizing already knew about squares
03:49:52 <hpaste> hiptobecubic pasted “Oleg's OOP http://okmij.org/ftp/Computation/Subtyping/Preventing-Trouble.html” at http://hpaste.org/75051
03:50:30 <hiptobecubic> But i was expecting Shape to be a typeclass, for example
03:50:39 <hiptobecubic> with an instantiation for each shape
03:51:03 <gensymv> are anonymous functions instances of Read?
03:51:18 <hiptobecubic> He just makes a "shape" be completely defined by the functions on the shape.
03:52:25 <hiptobecubic> gensymv, doesn't look like it
03:52:29 <sopvop> hiptobecubic: typeclass makes it the same way, but hides the fact
03:53:15 <alpounet> hiptobecubic, a Shape typeclass actually "desugars" to something similar
03:53:23 <hiptobecubic> yes i see it now
03:53:29 <alpounet> you may want to read about how typeclasses are implemented
03:53:35 <hiptobecubic> i may, yes
03:53:37 <hiptobecubic> :)
03:53:41 <gensymv> hiptobecubic, thank you, so it is not just me doing something stupid.
03:53:56 <hiptobecubic> gensymv, don't trust anything I say. :)
03:54:03 <hiptobecubic> gensymv, but i don't see how they could be really.
03:54:23 <gensymv> lol :)
03:54:28 <hiptobecubic> lunch ->
03:54:45 <hpaste> pyf pasted “Could this function be made clearer?” at http://hpaste.org/75052
03:55:27 <sopvop> I think there was an effort to make build-bot in haskell, GSOC or something. Anyone remembers it?
03:57:06 <pyf> Hi, I was wondering whether someone could help me with a function I've written. It works correctly, but is very unclear to my inexperienced eyes. Is there a more idiomatic way of writing it? Or will I eventually be able to see what's going on more easily? See above hpaste. Thanks!
03:57:20 <merijn> pyf: Looks like at the very least you could introduce some helper functions to make it cleaner
03:57:54 <merijn> pyf: Consider moving the "(flip (map.flip (:)) s)" to it's own function, for one
03:58:15 <pyf> merijn: Ok.
03:58:17 <merijn> There might be other more subtle code reshuffling to clean it up, but I don't have the time to look into that
03:59:31 <benmachine> pyf: I avoid use of 'flip' except where it's very clear what it means
04:00:17 <alpounet> sopvop, yes, i'm one of the authors of WIP build bot software, and we've had a GSoC student working on it
04:00:42 <alpounet> of the*
04:01:45 <benmachine> pyf: also, have a look at 'replicateM', it might do what you want
04:02:03 <benmachine> > replicateM 3 [1,2,3]
04:02:04 <lambdabot>   [[1,1,1],[1,1,2],[1,1,3],[1,2,1],[1,2,2],[1,2,3],[1,3,1],[1,3,2],[1,3,3],[2...
04:03:43 <benmachine> pyf: oh, you ping-timeouted
04:03:52 <benmachine> pyf: did you get my previous messages?
04:06:16 <alpounet> sopvop, feel free to contact me or join the irc channel if you want to know more (it's still far from a release though, i've got back to working on it just yesterday, been busy)
04:08:02 <pyf> benmachine: Yes, thanks. I'll look into replicateM.
04:08:09 <sopvop> alpounet: which channel?
04:08:14 <alpounet> scoutess
04:08:20 <alpounet> err, #scoutess
04:08:37 <benmachine> pyf: anyway, I made your flippy function into an explicit lambda and it became way clearer
04:14:08 <merijn> @src foldr
04:14:08 <lambdabot> foldr f z []     = z
04:14:08 <lambdabot> foldr f z (x:xs) = f x (foldr f z xs)
04:19:28 <merijn> @pl \x y -> (f x y :)
04:19:28 <lambdabot> ((:) .) . f
04:27:12 <merijn> @src mapM
04:27:12 <lambdabot> mapM f as = sequence (map f as)
04:27:39 <merijn> @src sequence
04:27:39 <lambdabot> sequence []     = return []
04:27:39 <lambdabot> sequence (x:xs) = do v <- x; vs <- sequence xs; return (v:vs)
04:27:39 <lambdabot> -- OR: sequence = foldr (liftM2 (:)) (return [])
04:30:04 <efie> When I click at "Source" at http://hackage.haskell.org/packages/archive/base/latest/doc/html/Prelude.html#t:Maybe , why can I only see how Maybe is an instance of Monad and Functor - why not the implentation of Foldable, Typable, etc.?
04:31:24 <merijn> efie: Those instances are defined in Data.Foldable and Data.Typable, I think?
04:31:44 <merijn> efie: i.e. in the modules where Foldable/Typable are defined, not the module where Maybe is defined
04:36:12 <astry_> @hoogle sortby
04:36:12 <lambdabot> Data.List sortBy :: (a -> a -> Ordering) -> [a] -> [a]
04:36:13 <lambdabot> Data.Sequence sortBy :: (a -> a -> Ordering) -> Seq a -> Seq a
04:36:13 <lambdabot> Data.Sequence unstableSortBy :: (a -> a -> Ordering) -> Seq a -> Seq a
04:37:52 <astry_> @hoogle a -> a -> Ordering
04:37:52 <lambdabot> Data.Ord comparing :: Ord a => (b -> a) -> b -> b -> Ordering
04:37:53 <lambdabot> Prelude compare :: Ord a => a -> a -> Ordering
04:37:53 <lambdabot> Data.Ord compare :: Ord a => a -> a -> Ordering
04:48:47 <merijn> Is the foldr definition of sequence more efficient is or ist just nicer because it works on infinite structures?
04:49:28 <hiptobecubic> @src [] replicateM
04:49:28 <lambdabot> Source not found. Wrong!  You cheating scum!
04:49:35 <hiptobecubic> :(
04:52:42 <hiptobecubic> I feel like there are so many hidden tricks based on monadic functions. It seems hopeless to ever recognize when to use them properly
04:53:31 <hiptobecubic> For example, benmachine's  replicateM 3 [1,2,3] producing all of the combinations of 3 of the elements
04:54:05 <frerich2> Heh, that's neat.
04:54:22 <hiptobecubic> it is neat.
04:54:40 <hiptobecubic> But would code that isn't a demonstration be written that way?
04:54:48 <benmachine> hiptobecubic: fwiw I didn't remember what replicateM did, I worked it out based on the spec
04:54:57 <benmachine> based on my intuition of the list monad
04:55:17 <hiptobecubic> benmachine, right. It seems like a long journey to get to that point
04:55:17 <benmachine> "I want to choose an item from this list three times"
04:58:22 <hiptobecubic> but you knew that replicateM a l would make selections of length a from l.
04:58:45 <hiptobecubic> instead of, i don't know, make a list of each of element of l repeated 3 times
04:58:56 <benmachine> yeah that's because I know what the list monad does
04:58:56 <hiptobecubic> a list of lists*
04:58:57 <benmachine> it makes choices
04:59:39 <benmachine> (okay, admittedly I had a strong instinct of "I bet there's a function somewhere that does this", but still.)
05:00:52 <hiptobecubic> but for example, it's obvious to me what replicateM 3 (Just 'a') would do
05:00:58 <hiptobecubic> because that monad is pretty simple
05:01:16 <hiptobecubic> there's not much it could do really
05:01:46 <hiptobecubic> Either's not a monad?
05:02:37 <frerich2> To me, lists are up there together with '(->) r' as the most miraculous monads; not always intuitive to me, but usually very funky.
05:04:14 <int-e> hiptobecubic: it is a monad. an instance is defined in Control.Monad.Instances
05:04:33 <int-e> hiptobecubic: well, Either e  is. Either is a binary type constructor, so not a monad.
05:06:51 <hiptobecubic> frerich2, yes.
05:07:25 <merijn> @src [] (>>=)
05:07:25 <lambdabot> xs >>= f     = concatMap f xs
05:08:21 <hiptobecubic> merijn, that one i can manage with. but only because i know have "concatMap f xs" embedded in my brain. Not because I have some intuition about how that's the most reasonable implementation
05:08:27 <hiptobecubic> i now*
05:08:42 <merijn> hiptobecubic: Oh, that was unrelated to your questions :p
05:08:50 <hiptobecubic> merijn, oh
05:08:53 <merijn> I just wanted to remember how the list monad was implemented :p
05:09:10 <hiptobecubic> @src [] join
05:09:11 <lambdabot> Source not found. :(
05:09:12 <merijn> Because I find myself needing to reimplement sequence for something list like
05:09:27 <t7> > 0x200
05:09:28 <lambdabot>   512
05:13:31 <mmaruseacph2> merijn: isn't join mappend?
05:14:18 <mmaruseacph2> nop, i'm just silly
05:14:27 <sipa> :t join
05:14:28 <lambdabot> forall (m :: * -> *) a. (Monad m) => m (m a) -> m a
05:15:52 <hiptobecubic> concat?
05:15:53 <merijn> @src [] pure
05:15:53 <lambdabot> pure = return
05:15:54 <hiptobecubic> i assume
05:16:37 <mmaruseacph2> hiptobecubic: yup, concat it was
05:16:46 <mmaruseacph2> have to start coding in haskell again
05:17:17 <xplat> Alt.Continuations.Delimited.Control.Control.Control
05:20:04 <hiptobecubic> why does `mplus` for Maybe only return the first argument?
05:20:16 <benmachine> > Nothing `mplus` Just 4
05:20:17 <lambdabot>   Just 4
05:20:28 <hiptobecubic> well sure. the Nothing case is obvious
05:20:32 <hiptobecubic> i mean in the non-nothing case
05:20:44 <benmachine> the nature of MonadPlus is such that the other case is obvious too
05:20:55 <hiptobecubic> Just 4 `mplus` Just [1,2,3]
05:20:58 <benmachine> there are about two possible total implementations of mplus
05:20:59 <hiptobecubic> > Just 4 `mplus` Just [1,2,3]
05:21:00 <lambdabot>   No instance for (GHC.Num.Num [t])
05:21:00 <lambdabot>    arising from a use of `e_14123' at <in...
05:21:05 <hiptobecubic> > Just 4 `mplus` Just 6
05:21:06 <lambdabot>   Just 4
05:21:26 <benmachine> hiptobecubic: the key is that 'MonadPlus m' doesn't allow any constraints on the 'a' in 'm a'
05:21:27 <merijn> :t mplus
05:21:28 <lambdabot> forall (m :: * -> *) a. (MonadPlus m) => m a -> m a -> m a
05:21:45 <benmachine> mplus is forced to be wholly polymorphic in the parameter of the monad
05:21:56 <benmachine> so you can't really do anything to combine Just values
05:22:01 <benmachine> you have to pick one
05:22:06 <hiptobecubic> oh
05:22:19 <hiptobecubic> Is that really useful though? I guess just as a test for Nothings
05:22:27 <benmachine> it is really useful, yes
05:22:41 <astry_> i wish keywords in haskell were single-letter
05:22:50 <benmachine> see: msum, which finds the first Just in a list
05:23:08 <ivanm> though I've also wished at times there was a variant that also takes an (a -> a -> a)
05:23:12 <benmachine> astry_: I sincerely hope no-one ever lets you on the design committee :P
05:23:13 <hiptobecubic> @src msum
05:23:13 <lambdabot> msum =  foldr mplus mzero
05:23:17 <benmachine> ivanm: that's called mappend
05:23:26 <ivanm> ..
05:23:27 <benmachine> actually, no, it isn't
05:23:30 <benmachine> wait
05:23:31 <benmachine> yes it is
05:23:36 <ivanm> @type mappend
05:23:37 <lambdabot> forall a. (Monoid a) => a -> a -> a
05:23:43 <ivanm> no it isn't :)
05:23:54 <merijn> astry_: Are you familiar with APL? xD
05:23:55 <benmachine> > Just [1,2,3] `mappend` Just [4,5]
05:23:56 <lambdabot>   Just [1,2,3,4,5]
05:24:05 <ivanm> astry_: that would really work well...
05:24:21 <benmachine> well, fair enough, it doesn't *take* an a -> a -> a, it uses mappend
05:24:23 <hiptobecubic> isn't that an inefficient way to do it? msum i mean? foldr starts at the back of the list doesn't it?
05:24:23 <benmachine> but still
05:24:27 <astry_> ivanm: think so?
05:24:29 <benmachine> hiptobecubic: no
05:24:36 <ivanm> benmachine: yes, but what happens if either the a isn't a Monoid or I want to use a different function?
05:24:36 <astry_> benmachine: there aren't so many to keep track of!
05:24:38 <benmachine> hiptobecubic: because of laziness
05:24:51 <benmachine> ivanm: newtypes newtypes everywhere
05:24:56 <ivanm> bah
05:24:58 <benmachine> :P
05:25:24 <benmachine> hiptobecubic: a nice way to think of 'foldr f z' is that it replaces every : in a list with f and the [] with z
05:25:28 <mmaruseacph2> hiptobecubic: foldr is more efficient that foldl
05:25:33 <mmaruseacph2> one moment to look up a link
05:25:46 <benmachine> hiptobecubic: if f is lazy in the second argument, foldr can return immediately
05:26:08 <astry_> hey, guys, is there a way for ghci to tell me the type of a value in a file?
05:26:16 <astry_> for ghc rather
05:26:18 <benmachine> > foldr const undefined [1 ..]
05:26:19 <lambdabot>   1
05:26:20 <mmaruseacph2> http://ics.p.lodz.pl/~stolarek/blog/ the first article here
05:26:38 <mmaruseacph2> I don't know why the direct link opens the rss feed though :(
05:26:44 <ivanm> astry_: why would a compiler give you information on the internals; why not just use ghci?
05:27:05 <hiptobecubic> benmachine, ah yes.
05:27:08 <ivanm> benmachine: for starters, what happens if you don't have a  mempty?
05:27:31 <astry_> ivanm: i would like something that i can put in a shell script
05:27:39 <astry_> to automatically get type annotations
05:27:47 <benmachine> ivanm: edwardk's semigroups package? :P
05:27:55 <ivanm> benmachine: heh
05:28:03 <astry_> i know you can do this by doing :l myfile.hs and then :t whatevervalue
05:28:08 <ivanm> astry_: why wouldn't you ensure there were type annotations as you develop?
05:28:17 <astry_> ivanm: because it's easier not to
05:28:27 <astry_> i'm a newbie, the compiler makes better choices than i do
05:28:38 <ivanm> though with the new haskell-src-types (or whatever it's called), it might be possible to script it
05:28:39 <astry_> i can rip off the compiler and i'll be better off than if i don't
05:29:00 <astry_> you think? hmm
05:29:00 <ivanm> astry_: people keep saying that you don't need types in Haskell; I find it a hell of a lot easier to write the types of my functions first
05:29:08 <ivanm> and then make the code match the types
05:29:18 <benmachine> if you do -fwarn-missing-signatures, GHC includes the typesig in the warning
05:29:19 <merijn> astry_: You develop in the wrong order. I always write my types first, then write my code to match the types
05:29:21 <ivanm> quite often as I'm writing them I realise that it might help to have a helper function, etc.
05:29:44 <astry_> merijn: that's great for you, but i'm not good enough to keep track of that yet
05:29:45 <merijn> astry_: Writing the types I want is usually easier than writing the code that accomplishes them
05:29:49 <isomorphic> actually - while we're on the topic - is there any editor plugin that can give me hints about the order something is likely to be evaluated?
05:29:53 <Philippa> ivan: I don't write them by default, but I tend to pretty fast if I'm debugging something or have a type error that doesn't make sense
05:30:04 <ivanm> astry_: it's a lot easier to grok types (and understand type errors!) when you start thinking in types from the beginning
05:30:17 <astry_> merijn: when i have worked as many hours with haskell as you have i'll be able to do that too
05:30:27 <ivanm> Philippa: *nod* I occasionally leave them off when I want to check the type of something for an error
05:30:30 <Philippa> isomorphic: that's surprisingly difficult. Learning to read GHC Core will let you do that and much more, though?
05:30:32 <astry_> ivanm: that's what i'm trying to do
05:30:35 <benmachine> astry_: what people are trying to tell you is that what we are suggesting requires /less/ skill not more :P
05:30:44 <ivanm> isomorphic: you mean "this is the stack trace that will occur" kind of thing?
05:30:46 <merijn> astry_: I started doing this as soon as I understood the types (say after 1 or 2 weeks of learning haskell?)
05:30:51 <astry_> ivanm: but first i would like to see the types ghc comes up with
05:30:53 <Philippa> ivanm: right. I often avoid writing the types of transformer stacks and the like...
05:30:58 <ivanm> SourceGraph can do that (disclosure: I wrote it, but haven't updated it in years)
05:31:01 <astry_> benmachine: i tried that, it didn't work
05:31:08 <benmachine> astry_: try compiling your module with -fwarn-missing-signatures
05:31:13 <ivanm> Philippa: heh, I avoid transformer stacks and the like :p
05:31:16 <astry_> oh
05:31:23 <astry_> that's an interesting option
05:31:30 <ivanm> benmachine: or just -Wall
05:31:33 <Philippa> right, I use them pretty regularly :-) They make sense for the stuff I do
05:31:38 * ivanm now has :set -Wall in ~/.ghci
05:31:40 <litb> hello all folks
05:31:51 <isomorphic> ivanm:   Each subexpression might be marked to indicate the order of evaluation
05:31:52 <benmachine> ivanm: so do I, it confuses me sometimes when I forget to set it in GHC though
05:31:58 <litb> where was that blog again that was about automatic integration with haskell?
05:32:05 <litb> it was two blog articles
05:32:06 <Philippa> that, and it's amazing how you can work your way out of corners if you've already got code in monadic style
05:32:06 <astry_> benmachine: that's amazing, thanks
05:32:24 <litb> with some amazing nerd stuff in it
05:32:33 * ivanm makes a wild guess and suggests edwardk's comonad reader to litb
05:32:40 <Philippa> need to totally alter the structure because you forgot to account for the (recursive) effects of choice in some structure? Stick [] at the bottom or one of the related transformers on the stack...
05:32:53 <isomorphic> Philippa: Thanks
05:33:05 <ivanm> isomorphic: well, SourceGraph doesn't do expressions within function definitions (it was getting noisy enough as it was)
05:33:25 <Philippa> isomorphic: FWIW, there are several reasons it's tricky to write that plugin for how GHC actually behaves
05:34:34 <ivanm> pgrep -l plug
05:35:07 <isomorphic> Philippa:  Is there a project in particular that has headed in that direction?
05:36:13 <merijn> astry_: Maybe this screencast can illustrate how/why I think writing the types first is useful: https://www.youtube.com/watch?v=045422s6xik
05:36:25 <isomorphic> ivanm:  Is SourceGraph intended to address dependency resolution in cabal?
05:36:27 <merijn> astry_: Most of the things happening there are very easy to follow
05:36:43 <astry_> i know they're useful, i just can't come up with them
05:36:53 <astry_> it's not a skill you just get all of a sudden
05:37:03 <ivanm> isomorphic: well, that's not what it was intended for
05:37:04 <astry_> let me look at the video
05:37:06 <astry_> thanks
05:37:11 <ivanm> but if someone manages to use it for that, more power to them :)
05:37:41 <ivanm> merijn: since I'm curious but my computer is deciding to misbehave and act slowly, which video is that?
05:37:57 * hackagebot hermit 0.1.1.1 - Haskell Equational Reasoning Model-to-Implementation Tunnel  http://hackage.haskell.org/package/hermit-0.1.1.1 (AndrewFarmer)
05:38:10 <merijn> ivanm: Data Driven Programming in Haskell
05:38:18 <ivanm> whom by?
05:38:45 <merijn> ivanm: No clue, some guy with the youtube account "entirelysubjective"
05:40:18 <Philippa> isomorphic: I don't know of such a project. But short of generating it from the Core again, you'd have to mirror GHC's optimiser
05:41:03 <ivanm> and of course the GHC API is _so_ stable...
05:41:04 <ivanm> ;)
05:41:07 <Philippa> lazy evaluation per se is also not totally trivial to track, but it's at least doable
05:41:45 <ivanm> another alternative: compile with profiling and full CAF-ing; profile output now includes sub-values in there, so you can get a call graph out of that
05:41:58 <ivanm> and there's prof2dot which might do that for you (haven't touched it in a while)
05:42:19 <t7> > 0x7c00 + 512
05:42:20 <lambdabot>   32256
05:42:27 <t7> > showHex "" $ 0x7c00 + 512
05:42:28 <lambdabot>   No instance for (GHC.Real.Integral [GHC.Types.Char])
05:42:28 <lambdabot>    arising from a use ...
05:43:39 * t7 is confuzled
05:43:46 <merijn> @hoogle Ord b => (a -> b) -> b -> b -> a
05:43:47 <lambdabot> Data.Ord comparing :: Ord a => (b -> a) -> b -> b -> Ordering
05:43:47 <lambdabot> Data.Sequence iterateN :: Int -> (a -> a) -> a -> Seq a
05:43:47 <lambdabot> Data.Function on :: (b -> b -> c) -> (a -> b) -> a -> a -> c
05:44:16 <isomorphic> Philippa:  Ah, yes thanks.
05:44:33 <merijn> hmm, there's no maxBy? :\
05:44:34 <dvdalilue> hi
05:44:43 <ivanm> merijn: max `on` f ?
05:44:47 <dvdalilue> what are you?
05:45:01 <ivanm> merijn: your supplied type sig looks wrong
05:45:07 <ivanm> dvdalilue: I'm human, last I checked
05:45:07 <ivanm> :p
05:45:38 <merijn> ivanm: No, max `on` f would return the section returned by f
05:45:38 <astry_> merijn: that guy got lost figuring the types out for the functions by the 6th minute.
05:45:47 <astry_> merijn: and he only has 1 real line of code there.
05:46:02 <astry_> he gets lost and he's the guy who is making the tutorial..
05:46:06 <ivanm> merijn: use a schwartzian transform?
05:46:35 <astry_> btw
05:46:39 <merijn> astry_: Yes? That's kind of the idea of thinking before programming...
05:46:49 <astry_> is there a switch for ghc to tell it to compile, but not actually write the files to disk?
05:46:54 <ivanm> snd . max `on` snd . map (ap (,) f)
05:47:00 <ivanm> might have the fst and snd wrong way round
05:47:05 <ivanm> @type ap (,)
05:47:06 <lambdabot> forall a a1. (a -> a1) -> a -> (a, a1)
05:47:15 <ivanm> oh good, I had it right
05:47:23 <merijn> > max `on` fst (1,2) (3, 4)
05:47:24 <lambdabot>   Overlapping instances for GHC.Show.Show (a -> a -> b)
05:47:25 <lambdabot>    arising from a use...
05:47:41 <ivanm> > (max `on` fst) (1,2) (3,4)
05:47:42 <lambdabot>   3
05:48:02 <ivanm> bah
05:48:05 <merijn> There's a maximumBy that does what I want, but I don't have a list :\
05:48:11 <ivanm> I normally use it with sortBy, etc.
05:48:12 <merijn> :t maximumBy
05:48:13 <lambdabot> forall a. (a -> a -> Ordering) -> [a] -> a
05:48:14 <ivanm> @src maximumBy
05:48:14 <lambdabot> Source not found.
05:48:37 <merijn> Or rather, you can use on with maximumBy
05:48:46 <merijn> @src max
05:48:46 <lambdabot> max x y = if x <= y then y else x
05:48:47 <astry_> merijn: i don't see the merit in writing incorrect types and incorrect code, and then getting confused by them, and having to crawl out of that mess
05:48:48 <ivanm> yeah
05:48:59 <ivanm> merijn: you might need to write your own function then :/
05:49:12 <astry_> merijn: i'd rather just write correct code, look up the type once it's mostly done, and then maybe change it if i make minor adjustments.
05:49:40 <merijn> If you're not gonna use the types you might as well just write python
05:50:03 <ivanm> @remember merijn If you're not gonna use the types [by writing them] you might as well just write python
05:50:04 <lambdabot> It is forever etched in my memory.
05:50:10 <merijn> Then you also "just" need to write correct code, and you don't even have to add types later
05:51:16 <astry_> whatever
05:51:17 <osfameron> but automatic inferencing of types is very nice
05:51:42 <astry_> it's great to be surrounded by open-minded people eager to take part in constructive conversation
05:52:47 <ivanm> or you could consider us as people who have learnt from experience and trying to help you avoid mistakes that we might have made
05:54:28 <astry_> "help avoid mistakes" is far, far away from "berate for not mindlessly following you"
05:54:48 <hpaste> “Alfredo Di Napoli” pasted “Have I understood StateT?” at http://hpaste.org/75055
05:56:18 <ivanm> who's berating?
05:56:28 <osfameron> astry_: I like to let the compiler figure out types too when I'm starting out.  Once I've done that for a bit, I can figure out types myself for simpler functions, and I build up.
05:56:35 <osfameron> I don't think there's anything wrong with that
05:56:40 <adinapoli> hi guys
05:56:47 <astry_> osfameron: that's the plan
05:56:52 <osfameron> I think it's good practice to start writing the types yourself before *when you know how*
05:56:59 <osfameron> but I wouldn't stress about it too much
05:57:04 <astry_> osfameron: did you know about the warn-missing-signatures plan?
05:57:07 <astry_> er
05:57:07 <astry_> flag
05:57:13 <osfameron> nope
05:57:19 <astry_> it's useful for exactly that
05:57:26 <osfameron> nice
05:57:29 <astry_> benmachine told me about it
05:57:39 <ivanm> it's part of -Wall
05:57:40 <osfameron> I'd kinda like my editor to do that  automagically ;-)
05:57:52 <osfameron> what I'd really like is to be able to get type sigs for lets and wheres too
05:57:56 <astry_> osfameron: what editor do you use?
05:58:08 <osfameron> astry_: vim.  I haven't set it up to do anything magical at all (for haskell)
05:58:22 <Lutin`> osfameron: haskellmode-vim has a mouseover type
05:58:24 <astry_> me either, but i'm thinking of writing a plugin which does just that
05:58:26 <Lutin`> thing
05:58:34 <osfameron> Lutin`: you can use a mouse with vim?!!!!! ;-P
05:58:39 <Lutin`> Well
05:58:40 <Lutin`> gvim
05:58:47 <Lutin`> vim -g
05:58:49 <astry_> what happens when you mouse over it?
05:58:59 <astry_> do you get a tooltip or something?
05:59:02 <osfameron> sounds good, I guess you can make it tell you in status bar on cursor-over instead
05:59:02 <Lutin`> Yah
05:59:07 <astry_> osfameron: you should never use a mouse with vim.
05:59:09 <Lutin`> Yeah I'm sure you could
05:59:10 <astry_> it's the dark path.
05:59:19 <osfameron> astry_: heh, I use hjkl and everything ;-)
05:59:30 <astry_> osfameron: but do you use text objects?
05:59:35 <osfameron> astry_: oh god yes
05:59:44 <astry_> then you're good to go.
05:59:51 <osfameron> I'm not very up to date -- appearntly it's easier to define your own text objects these days?
05:59:55 <osfameron> anyway that's a -blah topic, sorry
06:00:09 <astry_> no idea how that works
06:00:14 <astry_> what is a blah topic?
06:00:21 <adinapoli> guys, I wrote a trivial haskell snippet to grok StateT and the other transformer fellas. Would you mind spending two minutes telling me if that is the idiomatic way to use StateT? The link is here: http://hpaste.org/75055
06:00:23 <Lutin`> #haskell-blah
06:00:36 <astry_> is that a channel you are in osfameron
06:00:47 <adinapoli> in particular, I would like to know if the idiomatic way to go is to have a single "facade"
06:00:49 <osfameron> astry_: #haskell-blah, yeah, what he said
06:01:05 <adinapoli> which the state goes in, just like I did
06:01:26 <adinapoli> I'm talking about the main function, line 33
06:02:15 <astry_> osfameron: i do not see you there
06:02:35 <osfameron> astry_: ah, must've fallen off... busy right now anyway, so probably for the best
06:02:50 <osfameron> astry_: but anyway, that's a good place for tangentially related conversations from #haskell ;-)
06:02:54 <merijn> adinapoli: Looks good to me?
06:03:03 <byorgey> adinapoli: looks pretty good, I just have a few comments
06:03:10 <astry_> oh ok
06:03:11 <merijn> adinapoli: You probably want to look at lenses if you're gonna have game state in a StateT
06:03:18 <astry_> yeah i'll get back to work too
06:03:31 <merijn> They will make using significant amounts of fields in your State *much* more pleasant
06:03:34 <adinapoli> merijn: lenses were out the scope of the snippet :P I already grokked them :)
06:03:44 <adinapoli> what I really would like to know is...
06:04:08 <adinapoli> if in the "real world" the idiomatic way is to isolate a single facade like I did calling runGame
06:04:15 <byorgey> adinapoli: one is that I would use liftIO instead of lift on line 17; liftIO would continue to work even if you decided to add another transformer layer, whereas you would have to change lift to (lift . lift)
06:04:17 <adinapoli> and then performing ALL the state stuff in there
06:04:36 <adinapoli> byorgey: thanks for the tip
06:04:37 <byorgey> adinapoli: as opposed to what?
06:05:05 <adinapoli> byorgey: as opposed to "I don't know", I mean I haven't found any other way to "concatenate" state actions
06:05:26 <adinapoli> rather then wrapping everything in a single facade that got evaluated in main with evalStateT
06:05:30 <merijn> adinapoli: Well, >>, >>=, replicateM, forever, etc.
06:05:58 <merijn> adinapoli: monad-loops also has tons of monadic loops you could use to loop/concatenate state actions
06:06:07 <adinapoli> so Is possible in main to have various state call chained together?
06:06:17 <adinapoli> because the thing that was blocking me was that
06:06:35 <adinapoli> I didn't know how to chain state action is a way that wasn't the one I posted
06:06:51 <byorgey> adinapoli: well, sure, but you have to chain them together using >> or >>= (or a do-block), then run the whole thing
06:06:52 <adinapoli> so I was wandering if the "real world" adopt the same technique
06:07:21 <adinapoli> byorgey: so you can actually have something like evalStateT (mychained stuff) myInitConfig ?
06:07:29 <Lutin`> of course!
06:07:30 <byorgey> adinapoli: if you called 'runStateT' on two separate State actions separately, but wanted them to be chained together, you would have to manually pass the state output from the first one to the second one
06:07:38 <byorgey> adinapoli: yes, of course
06:07:58 <byorgey> adinapoli: but that passing of state is exactly what the State monad does.  So that would be pointless.
06:07:58 <adinapoli> I little gist/hpaste, maybe a slight mod of my original snippet would be very appreciated :)
06:08:18 <adinapoli> so I can compare the various things together
06:08:52 <Lutin`> You would just do `evalStateT (stateA >>= stateB) myInit`, right byorgey?
06:08:57 <hpaste> “Brent Yorgey” annotated “Have I understood StateT?” with “Have I understood StateT? (annotation)” at http://hpaste.org/75055#a75056
06:09:14 <byorgey> adinapoli: ^^^ this works too (not that I am saying it's necessarily better)
06:09:26 <Philippa> merijn: I suspect the fact my code's as monad-laden as it is helps reduce the obviously-an-annotation burden - runFooT calls being stealth annotations
06:09:32 <adinapoli> cool, a little clearer, thanks :)
06:09:49 <Lutin`> adinapoli: Matter of fact if you remove the sugar behind do notation, you're already doing this
06:09:50 <Philippa> I use types a lot, I just keep the annotation count low by default
06:10:12 <adinapoli> just to sum up: Is the way I tackled the problem "right" even in the real world? I mean, do "real haskellers" write code of the same shape? :P
06:10:18 <byorgey> adinapoli: yes
06:10:37 <adinapoli> thanks a lot guys, I'm a step closer to the enlightenment :D
06:10:45 <adinapoli> have a nice day and see you later!
06:10:51 <Lutin`> adinapoli: You know how do notation works right?
06:11:03 <adinapoli> Lutin`: yup
06:11:19 <Lutin`> Well your runGame is already a StateT composed of other StateTs
06:11:22 <adinapoli> It's a sort of "implicit chain"
06:11:52 <adinapoli> yes, now I see it
06:12:07 <adinapoli> because I'm implicitly chaining the whole stuff with do
06:12:11 <Lutin`> Yes
06:12:16 <adinapoli> that's like composing with a >> b >> c
06:12:19 <adinapoli> right? :)
06:12:24 <Lutin`> yup
06:12:28 <adinapoli> perfect :)
06:12:36 <adinapoli> thanks a lot guys :)
06:12:45 <Lutin`> And in regards to the single facade thing
06:12:57 <Lutin`> I personally like to abstract as much as possible
06:13:39 <adinapoli> Lutin`: so you a "pro" the facade thing or not? :D
06:13:42 <Lutin`> yes
06:13:52 <Lutin`> I like small functions
06:13:55 <Lutin`> But lots of them
06:14:05 <adinapoli> Lutin`: well, I quite the facade thing too, it's clear what it does
06:14:19 <adinapoli> Lutin`: I usually follow Bob Martin advices (cfr. Clean Code)
06:14:23 <adinapoli> :)
06:15:25 <Lutin`> Well in that case you're gonna love Haskell!
06:15:34 <Lutin`> Writing clean code is so easy~
06:16:28 <matthiasgorgens> If that fails, you can try writing Clean code.
06:16:37 <Lutin`> lol
06:17:25 <luv> am i the only one who finds using getOpts such a pain?
06:18:07 <Lutin`> getArgs?
06:18:10 <scooty-puff> if i want to translate an error type when using MonadError, i assume i cannot use just that type class - is something like this required (and similarly for MonadState)? http://hastebin.com/diviyitudu.hs
06:18:39 <luv> Lutin`: isnt that lower level than getOpts?
06:18:43 <stepcut> I am trying to use markdown+lhs, but the ### style headers make ghc unhappy. Any idea how to deal with that ?
06:18:49 <scooty-puff> the use i have in mind is catching an error, reading the current location (for a parser), then rethrowing as a tuple of the original error and the location
06:18:52 <Lutin`> I don't even know what getOpts is
06:18:59 <luv> umm alright
06:19:39 <Lutin`> in hdirect?
06:20:23 <Lutin`> Oh, getopt-simple
06:20:40 <Lutin`> Wait
06:21:01 <Lutin`> ...I am so tired I shouldn't be talking haha
06:22:27 <luv> http://hackage.haskell.org/packages/archive/base/4.5.1.0/doc/html/System-Console-GetOpt.html
06:22:49 <Lutin`> Yeah I see it now
06:23:05 <luv> i'll paste my code shortly ...
06:23:17 <Lutin`> What exactly about it is a pain?
06:23:45 <luv> exactly ... how it compares tu using argparse in python :-)
06:25:09 <Lutin`> Well I can't understand that then cause to me it looks so much nicer than argparse haha
06:26:57 <luv> ok, so, in haskell getOpts I need to define my own data structure (Flag) to begin with and then also i need to write functions that will extract data from flags based on that data struct
06:27:01 <bford> what's the simples FRP implementation you know of?
06:27:49 <bford> s/simples/simplest/
06:27:59 <luv> http://pastebin.com/JBfJjcjk
06:28:03 <maukd> The paste JBfJjcjk has been copied to http://hpaste.org/75057
06:28:04 <luv> it doesnt even compile now :-)
06:29:09 <fmap> luv: you can't have "where data"
06:29:35 <luv> unfortunate
06:29:46 <luv> i'd like to limit scope there
06:34:38 <kuribas> stepcut: I had the same problem.
06:35:32 <stepcut> kuribas: doesn't look like there is a fix, aside from putting something like *** in the source and running it through sed before sending it to pandoc :-/
06:38:17 <mm_freak> stepcut: there is no fix…  you can use a preprocessor on the haskell side to remove those lines before compiling
06:39:13 <mmaruseacph2> bford: isn't it still a hot research topic?
06:39:17 <stepcut> mm_freak: yeah, that is the other solution… though getting ghci to run that automatically is a bit annoying
06:39:29 <mmaruseacph2> I mean, they still develop libraries and write papers
06:39:32 <mmaruseacph2> for FRP
06:39:57 <mm_freak> bford: there are two possible meanings of "simplest" here
06:40:10 <mm_freak> simplest internally, simplest in user interface
06:40:15 <hpaste> luv pasted “getorgs aaaaarrrrgh” at http://hpaste.org/75058
06:40:23 <bford> i don't know, I've read a lot of the papers, but from elerea, reactive-banana, sodium et al I had hoped to find a little simple library that captures the essence to port to Fay
06:40:49 <luv> alright, it compiles now ... (flag is "data Flag = RefFile String | SymFile String deriving(Show)")
06:40:53 <luv> but
06:40:56 <mm_freak> bford: yampa/netwire
06:40:57 <luv> it's sooo cumbersome!
06:41:13 <mm_freak> bford: the libraries implementing classic FRP are fairly complicated under the hood
06:41:21 <mm_freak> AFRP is very simple internally
06:41:59 <fmap> luv: as a side note I'd personally recomend optparse-applicative for that kind of task, but it can be not so easy to use for a beginner
06:42:29 <fmap> s/recomend/recommend/; s/can/may/
06:42:34 <merijn> @hoogle (Monad m, Functor f) => f (m a) -> m (f a)
06:42:35 <lambdabot> Data.Traversable sequence :: (Traversable t, Monad m) => t (m a) -> m (t a)
06:42:35 <lambdabot> Prelude sequence :: Monad m => [m a] -> m [a]
06:42:35 <lambdabot> Control.Monad sequence :: Monad m => [m a] -> m [a]
06:42:39 <bford> the main impediment for fay as i understand it is the lack of typeclases
06:43:10 <luv> fmap: yeah, i realize it's cumbersome b/c my lack of haskell skills
06:43:23 <luv> that's why im asking for you help afterall :-)
06:43:34 <mm_freak> bford: you don't need type classes, but you want your language to be sufficiently lightweight to support applicative functors
06:43:42 <mm_freak> s/language/syntax/
06:44:17 <mm_freak> bford: you can have full yampa-like FRP with this simple type:  data SF a b = SF (Time -> a -> (b, SF a b))
06:44:43 <mm_freak> SF is a Category/Arrow and for every 'a' the type 'SF a' is an applicative functor
06:45:07 <bford> looks a lot like State monad..? with one extra arg..
06:45:37 <mm_freak> it's a special state arrow, let me give you an equivalent definition
06:45:48 <merijn> What is the minimum extra constraints I need to add to write something like "Monad m, Functor f => f (m a) -> m (f a)"?
06:46:04 <Lutin`> luv: for one you should use pattern matching on getOpt
06:46:07 <mm_freak> data LS a b = forall s. LS s (Time -> (a, s) -> (b, s))
06:46:07 <Lutin`> with case
06:46:16 <mm_freak> bford: where LS stands for LocalState
06:46:18 <merijn> I guess I need Applicative?
06:46:26 <Lutin`> That will make it easier to read
06:46:39 <mm_freak> merijn: Traversable
06:46:55 <bford> unfortunately I don't think typeclasses work at all in fay, I think I'd have to define my own hardcoded equivalent of the typeclass methods
06:46:56 <merijn> mm_freak: Traversable requires Foldable which I don't think I can write for my functor
06:46:57 <luv> Lutin`: i see they use it in the example on the site i linked ... but this (checking for errs seperately) looks cleaner to me
06:47:29 <hpaste> luv pasted “next try on getOpt” at http://hpaste.org/75059
06:47:40 <luv> alright this looks ok to me
06:47:47 <luv> except the cumbersome use of getRefFile!
06:48:24 <luv> and keeping  "data Flag" and options to populate global scope
06:48:52 <luv> i guess i could implement getRefFile as a fold
06:48:58 <mm_freak> merijn: can you write toList?  if yes, you can also write Foldable =)
06:49:06 <mm_freak> Foldable is really ToList
06:49:14 <bford> mm_freak, presumably I'd have to also implement all the useful stuff in Arrow too? (>>>, &&& and the like)?
06:49:20 <mm_freak> bford: you don't need type classes
06:49:26 <mm_freak> you just need the combinators
06:49:51 <mm_freak> bford: the arrow interface is optional…  yampa only provides the arrow interface, but in netwire you can also use applicative style
06:50:02 <merijn> mm_freak: toList discards information that I'm trying to keep around
06:50:24 <merijn> mm_freak: (By type is a heterogeneous list, so toList would discard the type info)
06:50:43 <fmap> luv: use of length instead of simply pattern matching isn't cleaner
06:51:01 <Lutin`> merijn: Yeah not foldable then I think
06:51:10 <luv> fmap: umm im not using length on errs but that's not the point
06:51:40 <bford> mm_freak, the idea I'm struggling with is how to get the combinators without the typeclasses... If fay can't look the typeclass methods up sure I'll have to redefine (cut and paste) all of them defined in terms of SF?
06:51:50 <mm_freak> merijn: as long as there is a sensible toList, it's a Foldable…  it's easy to see that toList drops information for every type that is not isomorphic to lists =)
06:52:12 <mm_freak> merijn: toList doesn't have to be iso
06:52:25 <Lutin`> What about the constraints on the function?
06:52:26 <Saizan> merijn: are you sure you have Functor f then?
06:52:36 <Lutin`> I guess that would depend on the type of heterogenous list
06:52:45 <mm_freak> bford: basically you would have (~.~) :: SF b c -> SF a b -> SF a c
06:52:57 <mm_freak> bford: but perhaps now is a good time to add type classes =)
06:53:46 <bford> if I had the first clue how to use haskell-type-exts I might take a stab at it!
06:54:26 <mm_freak> bford: do you want to have FRP built into the language?
06:55:03 <merijn> Saizan: Well, I have "data Foo a b" where a encodes the heterogenous types, so "Foo a" is a functor, afaict
06:55:21 <merijn> Since the b is just somethng of kind *
06:55:37 <bford> I think i'd like to have it as a library
06:55:55 <mm_freak> bford: good choice, but you really should experiment with it in haskell
06:56:05 <killy9999> is adding "ghc-options: -O2" in .cabal file a good idea?
06:56:10 <mm_freak> killy9999: no
06:56:32 <killy9999> so what's the preffered way of controlling how a package is built?
06:56:51 <mm_freak> killy9999: cabal configure --my-flag --my-other-flag
06:57:29 <luv> alright
06:57:39 <luv> i leave it for monday :-)
06:57:40 <luv> thx
06:57:41 <killy9999> example in Cabal user guide shows "ghc-options: -Wall"
06:57:46 <killy9999> is that ok?
06:57:52 <bford> i've played with reactive-banana a little bit... perhaps I''d be better wrapping an existing javascript implementation (like RX)?
06:57:59 * hackagebot getopt-simple 0.1.0.2 - A "System.Console.GetOpt" wrapper to make simple use case easy.  http://hackage.haskell.org/package/getopt-simple-0.1.0.2 (AlexanderBondarenko)
06:58:11 <mm_freak> killy9999: yeah, that one is fine
06:58:44 <mm_freak> killy9999: other examples:  -threaded, -rtsopts, etc.
06:58:44 <killy9999> thanks
07:00:29 <merijn> Saizan: This seems like it should be a valid functor: http://hpaste.org/75060 I just dislike the "sequence" implementation, but I don't think there's a better way to do it.
07:00:56 <Lutin`> merijn: Check the functor laws
07:01:14 <mysticc> Not a haskell question but where do you guys set a mailing list for a small group project. (non gmail emails)
07:01:44 <mm_freak> on my server
07:02:15 <luv> before i go
07:02:20 <luv>  59           let sym_lines' <- mapIO getLines symFiles -- streamline this  60           let sym_lines = concat sym_lines'
07:02:28 <luv> can i make this into one line?
07:02:30 * mysticc will try to break mm_freak's server to set up his mailing list.
07:02:36 <mm_freak> =)
07:02:51 <mm_freak> if you break it, you can't set up an ML anymore ;)
07:03:05 <mm_freak> luv: let { a = b; c = d }
07:03:17 <mm_freak> luv: but you have a syntax error there
07:03:19 <mysticc> concat <$> mapIO .... ..
07:03:23 <luv> umm
07:03:49 <mysticc> luv: if the monad has a functor instance
07:03:55 <luv> no idea :-)
07:03:58 <mm_freak> if that's supposed to be haskell code at least
07:04:03 <luv> haha
07:04:10 <luv> yeah i pasted it in middle of editing :-)
07:04:11 <luv> sry
07:04:22 <luv> sym_lines' <- mapIO getLines symFiles
07:04:26 <luv> let sym_lines = concat sym_lines'
07:04:31 <luv> this is it
07:04:38 <luv> and id like to get rid of sym_lines'
07:04:56 <mm_freak> luv: what's the type of mapIO?
07:05:05 <luv> mapIO :: (a->IO b) -> [a] -> IO [b]
07:05:48 <mm_freak> luv: (fmap concat . mapM getLines) symFiles
07:05:48 <mysticc> :t
07:05:57 <mysticc> @type
07:05:58 <lambdabot> <no location info>: not an expression: `'
07:06:01 <mysticc> @type concat
07:06:02 <lambdabot> forall a. [[a]] -> [a]
07:06:12 <killy9999> how can I foind out which version of cabal library do I have?
07:06:20 <killy9999> I don't see it in ghc-pkg list
07:06:23 <mm_freak> killy9999: cabal info cabal
07:06:29 <mysticc> cabal --v
07:06:46 <mm_freak> or that =)
07:07:15 <mysticc> cabal info cabal filled my screen. I had to scroll to actually see the version :P
07:07:20 <applicative> that tells you which Cabal cabal was built with, not the one  your ghc is using
07:07:34 <Saizan> merijn: that's a Traversable too
07:07:44 <luv> mysticc: so?
07:07:54 <mysticc> luv: So what ?
07:07:56 <applicative> if ghc-pkg list doesn't show a Cabal lib, something is wrong killy9999
07:08:08 <luv> mysticc: how does type of concat help?
07:08:12 <killy9999> mm_freak, mysticc :thanks
07:08:23 <mm_freak> :thanks
07:08:27 <merijn> Saizan: Oh?
07:08:41 <mysticc> luv: Nothing .. does <$> helped
07:08:49 <luv> alright
07:08:49 <luv> np
07:08:57 <killy9999> applicative: Oh, it does show cabal
07:08:59 <luv> i leave it for later ...
07:09:02 <luv> thanks!
07:09:03 <mysticc> luv what happened ..
07:09:05 <killy9999> only in the upper case
07:09:10 <mm_freak> luv: (<$>) is an infix version of fmap, but you need to import Control.Applicative to get it
07:09:18 <killy9999> so it shows at the beginning of a list
07:09:23 <killy9999> I must be blind...
07:09:43 <luv> mm_freak, mysticc: I am sure this would get it sorted but my haskell skills are not good enough yet to understand Functors etc.
07:09:51 <applicative> killy9999: right,  that's the library, it comes with ghc.  cabal the executable uses it, but works with other ghc's you might have
07:10:03 <mm_freak> luv: fmap :: (a -> b) -> f a -> f b
07:10:06 <luv> so I leave it for next week and for now I will just enjoy I progressed somehow
07:10:09 <mm_freak> luv: now just replace f by IO
07:10:34 <mm_freak> it simply applies a function to the result
07:10:40 <mm_freak> fmap lines getContents
07:11:41 <mm_freak> getContents :: IO String;  lines :: String -> [String];  fmap lines getContents :: IO [String]
07:11:58 <Lutin`> And you can write that as: lines `fmap` getContents
07:12:06 <mysticc> luv: Never leave for tomorrow :P
07:12:12 <Lutin`> Or if you import Control.Applicative: lines <$> getContents
07:12:18 <mm_freak> he's gone
07:12:18 <Saizan> merijn: traverse _ MapEmpty = MapEmpty; traverse f (MapVariant p v ps) = MapVariant p <$> f v <*> traverse f ps
07:12:24 <Lutin`> Is he
07:12:30 <Lutin`> I have parts/quits off :X
07:12:44 <merijn> Saizan: <*> requires Applicative, and I don't know how to sensibly define pure
07:13:13 <Saizan> merijn: the Applicative requirement is not on MapVariant
07:13:17 <Saizan> ?type traverse
07:13:18 <lambdabot> Not in scope: `traverse'
07:13:27 <Saizan> ?type Data.Traversable.traverse
07:13:28 <lambdabot> forall a (f :: * -> *) b (t :: * -> *). (Data.Traversable.Traversable t, Applicative f) => (a -> f b) -> t a -> f (t b)
07:13:39 <mm_freak> somehow i never understood why people use (<$>) instead of fmap…  i'd end up writing (f <$>) all the time
07:13:52 <Saizan> t = MapVariant ps, there
07:13:53 <merijn> :t (<*>)
07:13:54 <lambdabot> forall (f :: * -> *) a b. (Applicative f) => f (a -> b) -> f a -> f b
07:13:55 <Lutin`> Well yeah
07:14:12 <Saizan> f is some general Applicative/Monad
07:14:14 <Lutin`> But then you can do f <$> a <*> b <*> c
07:14:17 <Lutin`> And it looks nice
07:14:30 <Saizan> (Monad when you're going to use it for mapM)
07:14:32 <mm_freak> does it?  i always prefer liftA*
07:15:01 <mm_freak> except when the application spans several lines or uses more than 3 computations
07:15:10 <Lutin`> Yes that's the key
07:15:24 <Lutin`> When it's long infix looks really pretty
07:15:27 <mm_freak> i think that only happens for parsers and for web forms
07:15:40 <Lutin`> And is very readable to me at least
07:16:14 <Lutin`> OH wait
07:16:24 <Lutin`> no nevermind
07:16:47 <mm_freak> Lutin`: sure?  compare:  (,) <$> x <*> y
07:16:52 <mm_freak> with:  liftA2 (,) x y
07:17:56 <Lutin`> hmm
07:18:17 <Lutin`> I guess it's because I don't like fooN type functions
07:18:29 <Lutin`> But it really shouldn't be a problem
07:18:43 <merijn> Saizan: Hmm, let me try, by this will work after all
07:19:01 <benmachine> mm_freak: I think people like <$> because it emphasises the whole "lifted form of application" thing
07:19:08 <benmachine> so it visually looks like an application
07:19:10 <benmachine> but with added magic
07:19:27 <merijn> I don't suppose we have type lambda's? xD
07:19:53 <mm_freak> benmachine: unfortunately (<$>) doesn't go well with composition
07:20:09 <mm_freak> compare fmap f . g with (f <$>) . g
07:20:46 <mm_freak> IMO multi-line Applicative applications are the only use case for (<$>) and (<*>)
07:20:59 <benmachine> mm_freak: <$> *is* composition :P
07:21:20 <Spockz> mm_freak: remember our issue from yesterday (incrementalisation?)
07:21:21 <benmachine> mm_freak: plus you can do f . g <$> x
07:22:06 <merijn> benmachine: Yeah, but the fixity of <$> is wrong for that usecase :(
07:22:12 <mm_freak> i think the main drive for using (<$>) instead of fmap is the compulsive need to avoid parentheses at all costs, which all haskell beginners seem to display
07:22:16 <mm_freak> Spockz: i do
07:22:25 <Spockz> mm_freak: I think I don't need it at all
07:22:33 <mm_freak> benmachine: no, you can't
07:22:37 <Spockz> mm_freak: the only place where I need to add the constraint is the Cache consstructor
07:22:42 <mm_freak> benmachine: the law is:  fmap f . fmap g = fmap (f . g)
07:22:59 <mm_freak> benmachine: fmap f . g = fmap (f . g) does not hold and cannot in fact hold
07:23:12 <benmachine> mm_freak: I... didn't say it did
07:23:16 <benmachine> sorry
07:23:19 <benmachine> I used the same letters as you
07:23:24 <benmachine> but I meant them to be different things
07:23:36 <merijn> mm_freak: He meant that you'd need put parenthesis around (f . g) when using fmap
07:23:36 <benmachine> I meant "you can easily fmap a composition over things with <$>"
07:23:41 <mm_freak> benmachine: i see, but i still don't see the advantage of f . g <$> x over fmap (f . g) x
07:23:57 <mm_freak> in fact i find the latter more readable
07:23:58 <benmachine> mm_freak: imo it's visually more intuitive, especially if you use $ a lot
07:24:10 <mm_freak> i don't, because parentheses are helpful
07:24:15 <benmachine> mm_freak: this is an aesthetic debate, in the main part
07:24:21 <mm_freak> yeah, i know
07:24:28 <benmachine> parentheses are helpful as long as you can easily track them
07:24:44 <benmachine> if you ever find )))) in your code it's a sign things are going badly for you
07:24:52 <mm_freak> but not only aesthetic…  i used to get rid of as many parentheses as possible, but when i revisited my code much later it bit me
07:25:03 <sipa> benmachine: i think that means you're writing lisp
07:25:06 <mm_freak> i don't have )))) in my code
07:26:54 <mm_freak> if your coding style is properly compositional you won't need parentheses for nesting things, but you should use parentheses to mark the arguments of your functions
07:26:58 <mysticc> then you are writig small functions in lisp
07:27:02 <mm_freak> this is not about aesthetics, but about maintainability
07:27:10 <mm_freak> flat code is always a bad idea
07:27:31 <frerich2> It may be lame, but in order to have decide between $ or () I usually put down my pen and try to find a good name for the thing on the right side of the $ and then use that so that I don't have to use either () or $.
07:27:43 <frerich2> s/to have decide/to not have to decide/
07:27:52 <killy9999> if I make a library named X, is it required that module names begin with X. ?
07:28:07 <mm_freak> killy9999: no
07:28:10 <applicative> no, killy9999
07:28:15 <applicative> Text.X maybe
07:28:27 <applicative> or Control.Monad.X
07:28:31 <mm_freak> killy9999: otherwise there would be hundreds of libraries with the name "Control" on hackage =)
07:28:46 <killy9999> mhm
07:29:12 <killy9999> so it would be best to place my modules in already existsing namespace?
07:29:14 <applicative> killy9999: oh, if its just the package name,  that can be anything, it has nothing to do with the way you arrange the modules
07:29:31 <killy9999> applicative: no, I'm asking about the modules
07:29:37 <killy9999> I don't want them to be confusing
07:29:41 <mm_freak> you can't name a library
07:29:52 <mm_freak> it's always named after the package name
07:30:00 <applicative> killy9999: you don't have to do that, but it would be strange not to use the hierarchy.
07:30:02 <killy9999> and I guess I don't have that much Haskell experience to figure out what is the best way to do it
07:30:14 <applicative> what is in this package?
07:30:19 <typoclass> mm_freak: he says he is asking about the modules
07:30:43 <killy9999> applicative: wavelt transforms
07:30:47 <merijn> Saizan: A traversable instance requires foldable, though...
07:30:50 <mm_freak> killy9999: does your library define types?
07:31:02 <killy9999> not yet, but perhaps it will
07:31:22 <merijn> Oh, wait. That might be possible
07:31:36 <mm_freak> killy9999: well, some packages use the Math.* hierarchy, if it's really just about algorithms
07:31:53 <killy9999> I see
07:32:13 <killy9999> I was thinking about Math
07:32:18 <mm_freak> if it's about algorithms for a specific data type (say Complex), another good option is to start at Data.Complex.MyAlgorithm
07:32:20 <applicative> killy9999: or Numeric.*
07:32:49 <killy9999> applicative: I didn't know that one
07:33:28 <mm_freak> killy9999: you don't have to…  there are no constraints, so you could write Haha.Hehe.MyModule
07:33:43 <mm_freak> Numeric.* isn't special, just like Control.* isn't
07:34:09 <Saizan> merijn: see foldMapDefault
07:34:14 <killy9999> mm_freak, yeah, I know
07:34:21 <Saizan> ?type Data.Traversable.foldMapDefault
07:34:22 <lambdabot> forall a m (t :: * -> *). (Data.Traversable.Traversable t, Monoid m) => (a -> m) -> t a -> m
07:34:30 <killy9999> but I;m trying to fit into existing environment :)
07:34:33 <applicative> http://hackage.haskell.org/package/AERN-Basics   http://hackage.haskell.org/package/fast-math
07:34:38 <typoclass> killy9999: i think Math.Wavelet is plausible, as is just Wavelet, or WaveletTransform, or Math.WaveletTransform
07:34:53 <Lutin`> Don't try to force it into the heirarchy
07:35:06 <benmachine> I think the hierarchy is mostly silly anyway
07:35:14 <Lutin`> It's rediculous imo
07:35:21 <mm_freak> in particular the distinction between Control and Data
07:35:24 <mm_freak> they are really the same thing
07:35:25 <Lutin`> ^
07:35:30 <Lutin`> That's my main issue
07:36:31 <applicative> killy9999: well a submodule WaveletTransforms has a precedent http://hackage.haskell.org/packages/archive/bindings-gsl/0.2/doc/html/Bindings-Gsl-WaveletTransforms.html
07:38:33 <killy9999> I guess I'll go with Signal.Wavelet
07:38:53 <typoclass> killy9999: yup, sure, why not
07:40:31 <Lutin`> Wow
07:40:42 <merijn> Saizan: Yeah, I figured that part out :)
07:41:08 <Lutin`> Looking at the code for Control.Applicative they switch between <*> and liftA2 almost too much :X
07:41:18 <Lutin`> I mean not too much, but just very oddly
07:41:57 <Lutin`> Like *> is defined right after <*> but is defined using liftA2, which is at the bottom of the file under utility functions
07:43:00 * hackagebot sloane 0.1 - A command line interface to Sloane's On-Line Encyclopedia of Integer Sequences  http://hackage.haskell.org/package/sloane-0.1 (AndersClaesson)
07:43:09 <astry_> in a do block, can i somehow assert the type of the result?
07:43:31 <astry_> i tried do { x <- func; x :: MyType } but that doesn't work
07:43:49 <astry_> it throws a type error because of the second line
07:43:53 <Lutin`> Try do { x :: MyType <- func }?
07:43:59 <astry_> nope
07:44:06 <Lutin`> Yeah I dunno
07:44:06 <applicative> astry_: you have to do it on the right  hand side without extension so x <- func :: IO MyType
07:44:09 <applicative> if  its io
07:44:20 <typoclass> astry_: if the do block makes up a function, you could declare its type: abc :: ... -> IO MyType
07:44:20 <ski> Lutin` : hm, that worked before, with `ScopedTypeVariables'
07:44:26 <astry_> applicative: i know about that, but that's a bit remote.. is there no other way?
07:44:38 <Lutin`> How is it remote?
07:44:41 <ski> (or maybe it was `PatternSignatures')
07:44:53 <astry_> typoclass: it doesn't, x is only an intermediate value
07:44:53 <applicative> right like ski says
07:44:56 <rwbarton> it used to be PatternSignatures but now is ScopedTypeVariables
07:44:58 <Lutin`> func is of type IO MyType so anything it returns is of type MyType
07:45:11 <astry_> i guess i'll resort to annotating the rhs
07:45:11 <ski> rwbarton : yeah, (mostly) a change for thw worse, imho
07:45:12 <astry_> thanks guys
07:45:20 <rwbarton> it always confuses me a bit
07:45:28 <applicative> do { x :: MyType <- func } should compile with {-#LANGUAGE PatternSignatures #-}
07:45:36 <mysticc> @hoogle System.Console.ParseArgs
07:45:36 <lambdabot> package parseargs
07:45:45 <Lutin`> I can't see a reason to need to annotate it tho
07:45:49 <Lutin`> ugh
07:45:49 <applicative> oh damn, ScopedTypeVariables
07:45:54 <Lutin`> though*
07:46:31 <astry_> TAL guys
07:46:34 <xrchz> I have (liftIO $ foo bar) \n >>= baz. is there any neat way to avoid the parentheses?
07:46:56 <applicative> -XPatternSignatures is deprecated: use -XScopedTypeVariables or pragma {-# LANGUAGE ScopedTypeVariables #-} instead
07:46:57 <astry_> i can't believe i am actually getting a hang of it and making something useful in haskell
07:47:11 <roconnor> @pl (liftIO $ foo bar) >>= baz
07:47:12 <lambdabot> baz =<< liftIO (foo bar)
07:47:17 <roconnor> hmm
07:47:26 <typoclass> xrchz: hat looks weird. is the "\n" a newline, or do you want to introduce a lambda? that'd be "\n -> ..."
07:47:35 <xrchz> it was a newline, sorry
07:47:38 <geekosaur> and a lambda in that position is wrong too...
07:47:42 <applicative> @pl \foo bar baz -> (liftIO $ foo bar) >>= baz
07:47:42 <lambdabot> (((>>=) . liftIO) .)
07:47:58 <xrchz> roconnor: that's not bad...
07:48:03 <geekosaur> that;s not exactly avoiding the parens :p
07:48:08 <xrchz> roconnor: but still has parens
07:48:15 <Lutin`> lift (foo bar) >> = baz works
07:48:16 <xrchz> baz =<< liftIO $ foo bar... ?
07:48:34 <xrchz> yeah
07:48:36 <roconnor> xrchz: that should do it
07:48:38 <nand`> let fb = foo bar in liftIO fb >>= baz
07:48:40 <hpaste> killy9999 pasted “test organization” at http://hpaste.org/75061
07:48:41 <nand`> no parens
07:48:44 <xrchz> indeed
07:48:47 <killy9999> ok, I'm trying to figure out how to use QuickCheck and test-framework and I need some help with how to organize my tests
07:48:49 <typoclass> xrchz: anyway, i think it is fine with parens. i wouldn't have any doubts leaving that as it is
07:48:57 <nand`> I would personally do liftIO (foo bar) >>= baz
07:48:57 <xrchz> cheers everyone
07:49:13 <killy9999> when ghci is started in project root directory and I try to load WaveletTest.hs
07:49:18 <killy9999> I get an error
07:49:27 <nand`> xrchz: doesn't that change semantics to (baz =<< liftIO) (foo bar) ?
07:49:32 <killy9999> ghci says that it cannot find Signal.Wavelet.hs
07:49:35 <nand`> maybe baz <=< liftIO or something
07:49:54 <applicative> liftIO . foo   >=>  baz  $ bar
07:50:07 <killy9999> how do I tell ghci where to look for this module?
07:50:21 <Botje> killy9999: load it with :m instead
07:50:34 <Botje> uh .. wait
07:50:48 <Botje> killy9999: what files do you have right now and who imports whom?
07:50:50 <merijn> Man, I wish I had type level composition/lambda's without newtype wrapping :(
07:51:09 <typoclass> Botje: check his paste
07:51:18 <nand`> liftIO >=> baz $ foo bar
07:51:25 <killy9999> Botje: look at my hpaste
07:51:31 <killy9999> http://hpaste.org/75061
07:51:46 <killy9999> that's the structure of directories
07:52:15 <typoclass> killy9999: have you tried going into src and running ghci there? alternatively, try ":cd .../src" in a running ghci
07:53:07 <killy9999> typoclass: if I go into src/ then ghci will ceratinly not find files located in tests/
07:53:36 <applicative> killy9999: if you enter src and do ghci ../tests/Wavelet...
07:54:06 <typoclass> killy9999: yeah, i meant what applicative said. should have spelled that out, sorry :-/
07:54:16 <killy9999> applicative: thanks...
07:54:41 <merijn> Can you write typeclass instances for partially applied type funs?
07:54:50 <mm_freak> merijn: no
07:54:54 <merijn> :(
07:55:15 <Botje> according to man ghc you can set import paths with -i or :set -i ...
07:55:49 <merijn> mm_freak: So close to what I want, yet so far away :\
07:56:50 <mm_freak> merijn: with a few extensions the type system becomes turing-complete, so at least you have a guarantee that it's possible =)
07:59:09 <merijn> mm_freak: Sure, I can do it using Data.Functor.Compose, but that means I have to uglify my code using getCompose >.>
07:59:30 <astry_> how can i perform an action only conditionally? I tried something like do { a <- func; if a > 0 then myaction else return ()}
07:59:32 <killy9999> I guess Botje: thanks
07:59:50 <Cale> astry_: that'll work
08:00:03 <Cale> astry_: but there's also  when
08:00:06 <astry_> doing do { a <- func; myaction } worked. my version hasn't
08:00:31 <Cale> what's the type of myaction?
08:00:40 <Clint> and what's the type of func?
08:00:41 <Botje> astry_: you need to return something of the same type as myaction
08:01:07 <astry_> can i just return undefined ?
08:01:31 <astry_> no, i guess no
08:01:35 <Cale> you *could* if you don't mind anything which uses the result of the action you're writing potentially crashing
08:01:48 <Cale> (when it tries to observe the value)
08:02:01 <Cale> You might prefer to use a Maybe type
08:02:49 <astry_> oh i got it now
08:02:58 <astry_> i forgot to add a do block
08:03:28 <astry_> Cale: the type is IO () anyways..
08:03:44 <prh> trying to learn Haskell. Getting close to spontaneous human combustion.
08:03:46 <Cale> ah, okay
08:03:57 <merijn> prh: That's the feeling of learning ;)
08:04:02 <Cale> prh: Feel free to ask any questions
08:04:09 <Botje> prh: did you receive your complimentary basket of painkillers and duct tape?
08:04:10 <astry_> i keep forgetting to add do blocks
08:04:12 <prh> I will later
08:04:15 <astry_> thanks for enduring me
08:04:27 <prh> Botje: no I missed that on the way it - would be helpful :)
08:04:35 <typoclass> prh: a common side-effect. get bucket of water ready and carry on calmly :-)
08:07:08 <merijn> @quote cjeris explodes
08:07:08 <lambdabot> cjeris says: Cale: I like how you conveniently gloss over the part where your head explodes.
08:07:58 * nand` wonders what the context for that was
08:08:09 <nand`> probably higher categories or something
08:08:15 <dylukes> prh: It's worth enduring it. ^_^
08:08:19 <Cale> I don't quite remember... yeah, something like that
08:08:27 <mm_freak> when i first learned haskell it felt like i just found a portal to a beautiful parallel universe
08:08:39 <dylukes> concurrent universe*
08:08:40 <applicative> mm_freak: and now?
08:08:41 <nand`> when I first learned haskell I thought it was too good to be true
08:08:43 <mm_freak> (nowadays i understand it and it even has a name:  Hask)
08:11:47 <astry_> spontaneous combustion :)))
08:11:51 <astry_> love it
08:12:02 <merijn> hiptobecubic: ok, the very first initial version is online at https://github.com/merijn/snet2.0 if you still want to see what I've been working on
08:16:39 <Tarrasch> Hello, should I interpret this as directory-1.2.0.0 does not compile on ghc-7.4? Is that how it is supposed to be?
08:16:44 <Tarrasch> see: <http://hackage.haskell.org/package/directory-1.2.0.0>
08:17:52 <quicksilver> it's a wired-in package isn't it?
08:18:01 <fmap> yes
08:18:05 <quicksilver> you can't use any version except the "right" one for that GHC
08:18:14 <quicksilver> so you can't use directory-1.2.0.0 with any GHC except 7.6
08:18:24 <typoclass> Tarrasch: hello, ghc comes with a compatible version of 'directory'. it's kind of normal that the directory package ofr 7.6 doesn't build with 7.4. (you don't need to build it yourself, unless you really know exactly what you're doing)
08:18:27 <Tarrasch> quicksilver: ok, that makes sense.
08:25:02 <Tarrasch> Ok, what about bytestring >= 0.10? The reason I ask is that when I compile my package with `--constraint="bytestring >= 0.10"` I get some propagated errors that everything fails to install because they depend on `directory-1.2.0.0` which fails.
08:25:32 <Tarrasch> I can just compile without that constraint, but I just wanna test how slack constraint I can put on bytestring.
08:25:48 <quicksilver> yes, bytestring-0.10 is probably also ghc-7.6 only
08:26:20 <quicksilver> there is no really easy way to understand which versions of which packages are loosely or tightly bound to specific ghc versions
08:26:39 <gdoteof_> what do i call the <- and -> operators?
08:26:43 <Cale> and the ones which come with GHC are usually a bad idea to replace
08:26:44 <Tarrasch> ok, that was the more general answer I was looking for
08:26:57 <quicksilver> gdoteof_: they aren't operators.
08:27:00 <Cale> gdoteof_: they're punctuation in various parts of the syntax of Haskell
08:27:10 <gdoteof_> ok
08:27:18 <gdoteof_> what do I call the punctuation marks?
08:27:21 <Lutin`> You could say left/right arrow
08:27:21 <nand`> I would call -> ‘to’
08:27:37 <frerich2> This may be a bit silly, but since I just had some funny misunderstandings with another non-native english speaker when talking about Haskell I do wonder: how do you pronounce "Haskell" correctly? Is it "Ha-skell" with "Ha" being as in "Ha ha!" or does the "Has" rhyme with "bes" in "best"?
08:27:42 <typoclass> Tarrasch: if it doesn't build with "bytestring >= 0.10", that probably means the constraint is too tight (not too slack). try 0.9 or 0.8 or something
08:27:42 <nand`> \x -> y:  ‘x to y’
08:27:47 <DrChickenSalad> yeah.  foo :: a -> b is usually said a to b from what I've seen
08:27:59 <nand`> of course, there is a third context for them; case/of
08:28:05 <Cale> In a list comprehension x <- xs is usually read "x drawn from xs" or "picking x from xs"
08:28:15 <nand`> ‘x bound from xs’ perhaps
08:28:22 <nand`> to go with the ‘bind’
08:28:23 <DrChickenSalad> Cale: sometimes just from
08:28:28 <Cale> yes
08:28:40 <gdoteof_> but theya lways mean the same thing?  or no.. <- unwraps a value from a monad, and -> is always like 'do this'
08:28:50 <Lutin`> to and from are good then
08:28:53 <Cale> In a do-block in general, v <- x means to run x and name its result v
08:28:56 <nand`> now, how do I read out loud ‘-<’ ?
08:29:01 <Cale> Please don't say "unwraps"
08:29:19 <gdoteof_> ok i will not say that
08:29:21 * gdoteof_ makes note
08:29:26 <Cale> It makes it sound like there was a value v inside of x to begin with :)
08:29:42 <Cale> In some monads, that's the case, but in many it's not.
08:30:06 <Cale> @quote list.of.files
08:30:06 <lambdabot> shachaf says: getLine :: IO String contains a String in the same way that /bin/ls contains a list of files
08:30:07 <DrChickenSalad> <- is always bind.  the concept is simpler for lists to be frank, but the type sig is the same
08:30:27 <DrChickenSalad> you're "unwrapping" an object when you bind, so with a list you "unlist it" with a <- [1, 2, 3]
08:30:36 <nand`> is there a monad besides Identity  where bind simply ‘unwraps’ the value?
08:30:43 <shachaf> hi Cale
08:30:44 <Lutin`> Even in list comprehensions <- is bind
08:30:51 <typoclass> DrChickenSalad: yeaaaah well 'bind' kinda means something else with monads ...
08:30:56 <shachaf> Also "id :: Int -> Int" doesn't contain an Int. :-)
08:30:59 <Cale> nand`: I guess you could make an argument for Maybe/List
08:31:01 <Lutin`> nand`: Maybe?
08:31:13 <Lutin`> Or list, yeah
08:31:17 <DrChickenSalad> No.  bind is always <- and always a monad
08:31:20 <nand`> x <- Nothing doesn't unwrap a thing
08:31:31 <DrChickenSalad> "unwrap" is fluff for some cases  :P
08:31:40 <Lutin`> Fair enough
08:31:46 <nand`> I think the term is only appropriate for Identity
08:31:49 <nand`> and as such, not particularly useful
08:31:56 <Cale> DrChickenSalad: And pattern guards? :)
08:31:57 <DrChickenSalad> It's appropriate for list and io
08:32:14 <Cale> I guess they're kind of in the Maybe monad or something?
08:32:15 <Cale> :)
08:32:27 * frerich2 wonders what the fuzz about nomenclature is about, given that everyone appears to agree on what's meant
08:32:28 <nand`> MonadPlus ?
08:32:37 <DrChickenSalad> In maybe it also makes sense, but "unwrap" doesn't unfortunately.  well, it does a bit to me, but noit as strongly as io and []
08:32:53 <Lutin`> frerich2: Such is #haskell haha
08:33:18 <DrChickenSalad> you're unwrapping a value from the possibility of one existing.  it's weird in the fact it can possibly "not unwrap" a value with nothing, but eh i give up
08:33:41 <Lutin`> You can open a box and find nothing inside
08:33:48 <Lutin`> Yet you're still 'unwrapping' it
08:33:57 <DrChickenSalad> good analogy
08:34:01 <typoclass> DrChickenSalad: bind is commonly the name for the function (>>=), so i find it clumsy to reuse that name for <-. it'll just lead to confusion. i don't know what you mean by "bind is always a monad"
08:34:05 <Cale> frerich2: If we didn't talk about nomenclature so much, then we wouldn't agree so often.
08:34:13 <Tarrasch> typoclass: I can build with bythstring-0.9, building is not the problem. I just want to make sure that when I publish my package that it actually builds with 0.10 before I start slack my constraint to allow 0.10
08:34:25 <Lutin`> typoclass: Well considering <- is fluff for >>=
08:34:36 <Tarrasch> However, since I won't bother getting ghc 7.6 right now I'll just slacken it to allow 0.10.*
08:35:15 <DrChickenSalad> >>= is <- ?
08:35:31 <typoclass> Tarrasch: right, from what you're saying, bytestring > 0.10 depends on ghc-7.6 (directly or via other dependencies)
08:35:38 <Cale> Tarrasch: hehe, this is what everyone ends up doing
08:35:51 <nand`> I wonder what an environment would look like that takes your unversioned list of dependencies and figures out the exact version constraints to apply via brute force or heuristics or something
08:35:55 <nand`> by simply seeing what it compiles against
08:35:58 <Cale> Tarrasch: the package version constraints rarely have any exactness to them
08:36:04 <Lutin`> a <- b = b => (\a ->)
08:36:12 <Lutin`> Sorry >>= not =>
08:36:19 <Tarrasch> Cale: yea, kinda ruins the whole point of having constraints :p
08:36:30 <nand`> personally, I think it's better to constrain for known-broken versions; not the other way around
08:36:36 <rwbarton> isn't the idea that you put constraints on the packages you directly care about
08:36:40 <Tarrasch> however you'll have 0 productivity if you're gonna narrow down to exact versions all the time ...
08:36:47 <typoclass> nand`: hm, interesting idea
08:36:48 <Cale> nand`: I agree!
08:36:49 <DrChickenSalad> line <- getLine ... is just getLine >>= \line -> ...
08:36:55 <zalzane|alt> >change ip
08:36:56 <zalzane|alt> >banned for cp
08:36:58 <Cale> (for libraries
08:36:58 <Cale> )
08:36:59 <Lutin`> DrChickenSalad: Yes that's what I said
08:37:00 <zalzane|alt> fucking comcast
08:37:02 <zalzane|alt> err
08:37:04 <zalzane|alt> wrong channel
08:37:07 <nand`> the only downside is that it may not be immediately clear from the compile failure which version is leading to breakage
08:37:09 <zalzane|alt> sorry
08:37:10 <Cale> Programs should specify exact constraints
08:37:10 <DrChickenSalad> Yes I'm just being redundant
08:37:21 <DrChickenSalad> Personally I always need to see something twice to understand  ;P
08:37:22 <Lutin`> I was just confirming
08:37:26 <rwbarton> like if bytestring-0.10 doesn't get along with directory-1.2 that's not your problem
08:37:35 <Cale> Well, maybe that's slightly overkill
08:37:40 <Lutin`> DrChickenSalad: Communication works best in two ways
08:37:44 <Cale> but on some days I feel that's better
08:37:50 <Lutin`> Confirmation of understanding is key!
08:37:51 <nand`> Cale: I don't necessarily see the distinction between programs and libraries; consider that other people may be wanting to build your code base with their potentially slightly different versions of the dependencies
08:38:02 <Tarrasch> Cale: why diffrentiate between libraries and programs? I get equally sad when one of them doesn't compile.
08:38:07 <Lutin`> s/ways/directions
08:38:10 <killy9999> which testing frameworks are compatible with Cabal'c Distribution.TestSuite.Test ?
08:38:29 <killy9999> s/Cabal'c/Cabal's/
08:38:32 <Cale> nand`, Tarrasch: because I'm thinking of final programs as being the end of the dependency food chain
08:38:43 <nand`> installing a program with strict dependencies puts the same constraints on the set of libraries I can install as libraries themselves
08:39:11 <Cale> nand`: You ought to be able to install multiple versions of libraries
08:39:12 <typoclass> maybe we should distringuish between new versions that only add some functions, and new versions that change the meaning of existing functions
08:39:13 <rwbarton> but you don't use two programs in the same ... whatever
08:39:24 <Lutin`> Cale: I feel like that's a bad way to code, as you're not considering that what you make could be built upon or used as a library to an extent
08:39:35 <nand`> Cale: I feel so too, but apparently my package manager disagrees
08:39:50 <Lutin`> nand`: What package manager?
08:39:55 <nand`> but I think different versions of libraries is fairly complicated with GHC stuff, isn't it?
08:40:11 <Cale> nand`: You're right, it can be complicated :(
08:40:28 <Tarrasch> Ok, thanks for your cabal and versioning insights guys
08:40:45 <nand`> for example library A uses type X from package B-0.9; and library C uses type X from package B-0.10
08:40:53 <nand`> now I want to write program P depending on both library A and library C
08:41:03 <nand`> the two Xs are distinct
08:41:08 <Cale> Lutin`: Well, factor as much as you can into libraries, but at the end of the day, I think it helps to have some actual programs :)
08:41:19 <Cale> (that you can run)
08:41:27 <nand`> (granted, the scenario here is of libraries depending on exact versions; not programs)
08:41:33 <astry_> how can i better express this? foo "a" >> foo "b" >> foo "c" >> foo "d"
08:41:40 <rwbarton> right, and that's the difference between libraries and programs
08:41:56 <DrChickenSalad> @pl \a -> \b -> \c -> \d -> (a, b + (read c), (map d a))
08:41:56 <lambdabot> ap (flip . ((flip . ((.) .)) .) . (. ((. read) . (+))) . (.) . (,,)) (flip map)
08:42:01 <DrChickenSalad> i love lambdabot
08:42:14 <rwbarton> however, it doesn't work out as well in practice as in theory as you might have installed libraries A and C already, linked against different versions of B
08:42:16 <Cale> astry_: mapM_ foo ["a","b","c","d"]
08:42:40 <Cale> actually, that's a little off, as your original program would give the result of foo "d"
08:42:44 <nand`> but in my scenario, if program P puts a strict dependency on B-0.9 since that's what it was known to build with; I would need to install B-0.9 (I may be on B-0.10) and recompile every single one of P's dependency in B's reverse dependency list
08:42:49 <Cale> while mapM_ will discard it
08:42:54 <nand`> just to keep P happy
08:43:04 <rwbarton> why would P put a dependency on B unless it needed one
08:43:09 <rwbarton> that's what I'm saying earlier
08:43:20 <nand`> so I would in effect not only need different versions of libraries, but same versions of libraries compiled against different versions of their dependencies; just to keep P's constraint list happy
08:43:34 <typoclass> does cabal choke if you have both B-0.9 and B-0.10 installed?
08:43:38 <nand`> rwbarton: suppose P uses B as well
08:43:44 <Cale> rwbarton: Because I mentioned that occasionally I think that libraries should have loose versions and programs should have exact ones.
08:43:47 <rwbarton> if P uses A and C and doesn't use B directly then it shouldn't appear as a dependency at all
08:44:00 <nand`> rwbarton: in general, I see this problem arising if P depends on A, B, *and* C; which have their own relationships
08:44:01 <Cale> I'm not sure this is actually the best policy in general, but it sometimes helps.
08:44:19 <quicksilver> nand`: (incidentally GHC is capable of doing that)
08:44:29 <rwbarton> nand`: right, well doesn't this already happen if P doesn't depend on B
08:44:31 <Cale> (maybe also because in the cases I'm thinking of, I had the freedom to pick the exact versions by hand)
08:44:34 <quicksilver> the hard thing is getting cabal to make the right call about what to choose to compiler new things against
08:44:39 <rwbarton> if P depends on A and C, and I have already built those against different versions of B
08:44:56 <rwbarton> I can build P from a "clean slate"
08:45:03 <rwbarton> but not starting from my incompatible A and C
08:45:13 <nand`> rwbarton: in the absence of the B-0.9 constraint; all libraries can simply be built against the ‘latest version that works for everything’
08:45:23 <nand`> and if you change the dependency, all of the world is updated to compensate - that's what I do right now
08:45:52 <rwbarton> what if you installed A at a time when B-0.9 was the latest version that existed
08:46:02 <nand`> I don't have any two Haskell programs that were built against differing versions of the same package
08:46:18 <nand`> rwbarton: then A has to get recompiled when you update to B-0.10
08:46:21 <astry_> Cale: i don't care about the result, this is IO
08:46:25 <astry_> IO ()
08:46:28 <Cale> No two packages are not on fire.
08:46:38 <astry_> @type mapM_
08:46:39 <lambdabot> forall a (m :: * -> *) b. (Monad m) => (a -> m b) -> [a] -> m ()
08:46:55 <sm> heh
08:47:03 <Cale> astry_: see also, forM_ as well as mapM and forM
08:47:13 <astry_> @hoogle mapM_
08:47:14 <lambdabot> Prelude mapM_ :: Monad m => (a -> m b) -> [a] -> m ()
08:47:14 <lambdabot> Control.Monad mapM_ :: Monad m => (a -> m b) -> [a] -> m ()
08:47:14 <lambdabot> Data.Foldable mapM_ :: (Foldable t, Monad m) => (a -> m b) -> t a -> m ()
08:47:20 <Cale> The underscore is a little convention that means that it discards the results
08:47:26 <astry_> @hoogle mapM
08:47:26 <lambdabot> Prelude mapM :: Monad m => (a -> m b) -> [a] -> m [b]
08:47:26 <lambdabot> Control.Monad mapM :: Monad m => (a -> m b) -> [a] -> m [b]
08:47:26 <lambdabot> Prelude mapM_ :: Monad m => (a -> m b) -> [a] -> m ()
08:47:30 <astry_> @hoogle forM
08:47:30 <lambdabot> Data.Traversable forM :: (Traversable t, Monad m) => t a -> (a -> m b) -> m (t b)
08:47:31 <lambdabot> Control.Monad forM :: Monad m => [a] -> (a -> m b) -> m [b]
08:47:31 <lambdabot> Data.Foldable forM_ :: (Foldable t, Monad m) => t a -> (a -> m b) -> m ()
08:47:38 <astry_> @hoogle forM_
08:47:38 <lambdabot> Data.Foldable forM_ :: (Foldable t, Monad m) => t a -> (a -> m b) -> m ()
08:47:38 <lambdabot> Control.Monad forM_ :: Monad m => [a] -> (a -> m b) -> m ()
08:47:44 <rwbarton> nand`: okay I see, so under this particular usage convention you're saying that P should not specify a version of B just because it can
08:47:47 <Cale> forM has the parameters flipped
08:47:53 <Cale> So you can write things like:
08:47:54 <Lutin`> @p \x y -> [ (x,y) | x <- [1..10], y <- ['a'..'z'] ]
08:47:54 <lambdabot> Maybe you meant: palomer part paste ping pl pl-resume pointful pointless pointy poll-add poll-close poll-list poll-remove poll-result poll-show pretty print-notices protontorpedo purge-notices . ? @
08:47:54 <lambdabot> v
08:48:02 <typoclass> astry_: lambdabot is also available in private chat. also, hoogle is on the web
08:48:05 <typoclass> @where hoogle
08:48:06 <lambdabot> http://haskell.org/hoogle
08:48:06 <Lutin`> @pl \x y -> [ (x,y) | x <- [1..10], y <- ['a'..'z'] ]
08:48:06 <lambdabot> (`ap` (return . (<- ['a'..'z']))) . ((:) .) . flip flip [1..10] . ((<-) .) . (flip =<< ((|) .) . (,))
08:48:07 <nand`> rwbarton: exactly; what I would consider ideal is for packages to simply list which versions they don't compile against
08:48:10 <Cale> forM $ \x -> do print x; getLine
08:48:12 <Lutin`> Oh my
08:48:14 <Cale> oops
08:48:18 <DrChickenSalad> > mapM_ (:[]) [1, 2, 3]
08:48:18 <nand`> this set being initially empty until you run into compile errors
08:48:19 <Cale> forM [1..4] $ \x -> do print x; getLine
08:48:19 <lambdabot>   [()]
08:48:23 <nand`> and perhaps distributed / automated
08:48:26 <astry_> sorry i didn't want to spam
08:48:37 <astry_> i'm lagged, didn't notice the size of the output at first
08:48:52 <typoclass> astry_: no worries, just a friendly heads-up
08:48:58 <DrChickenSalad> lambdabot: > print test
08:51:15 <Cale> > mapM (\x -> [x,10*x]) [1,2,3]
08:51:16 <lambdabot>   [[1,2,3],[1,2,30],[1,20,3],[1,20,30],[10,2,3],[10,2,30],[10,20,3],[10,20,30]]
08:53:24 <astry_> why is the shape of the output like that?
08:53:59 <nand`> oh hey, it's like counting in binary
08:54:44 <nand`> > sequence [[1,2],[3]]
08:54:45 <lambdabot>   [[1,3],[2,3]]
08:54:51 <quicksilver> > [1..] >>= flip replicateM "abc"
08:54:53 <lambdabot>   ["a","b","c","aa","ab","ac","ba","bb","bc","ca","cb","cc","aaa","aab","aac"...
08:55:02 <quicksilver> like counting in ternary!
08:55:21 <nand`> yeah, I love that trick for generating all possible strings of some alphabet :)
08:55:56 <nand`> (replicateM)
08:58:32 <killy9999> can I run HPC via cabal ??
08:58:48 <killy9999> I just noticed that cabal creates hpc directory under dist
08:59:24 <dcoutts> killy9999: it has some support for running package tests with hpc
08:59:35 <killy9999> how?
08:59:53 <killy9999> I don't see it in the docs :/
09:04:07 <Jello_Raptor> is there any function that'll make ghci print " one line \n two line \n red line \n blueline " with the \n replaced with actual newlines?
09:04:44 <shachaf> Yes, (\_ -> putStr " one line \n two line \n red line \n blueline ")
09:04:50 <astry_> hmm..
09:05:02 <shachaf> If you're OK with it not being a function, you can just use (putStr " one line \n two line \n red line \n blueline ")
09:05:11 * shachaf shouldn't do that.
09:05:28 <Jello_Raptor> ahh that's what i'm loking for
09:05:47 <bford> mapM_ print $ lines " one line \n two line \n red line \n blueline "
09:05:48 <astry_> if i do mapM_ handler ["a", "b", "c"] then i get a type error, but it works if i do mapM_ handler ["a", "b", "c"] >> return True. What am I doing wrong?
09:05:56 <Jello_Raptor> it make debug a lot easier since, my actual program just sort of folds into an interact call
09:06:18 <shachaf> bford: That will print a very different thing.
09:06:19 <astry_> I also tried mapM, but then the error said it couldn't match Bool [Bool]. so i tried "head mapM" but that hasn't worked out either
09:06:20 <quicksilver> astry_: mapM_ will return ()
09:06:24 <shachaf> astry_: Nothing?
09:06:31 <quicksilver> astry_: return True will return True which is a bool
09:06:32 <shachaf> You just said how to fix your type error.
09:06:39 <quicksilver> astry_: if you want the return of the last one, then
09:06:50 <quicksilver> liftM last (mapM_ handler ["a", "b", "c"])
09:07:00 <shachaf> quicksilver: s/_//, I think. :-)
09:07:09 <quicksilver> yes, sorry
09:07:14 <quicksilver> liftM last (mapM handler ["a", "b", "c"])
09:07:28 <quicksilver> you may also consider 'or' or 'and' instead of 'last'
09:07:29 <quicksilver> :t or
09:07:30 <lambdabot> [Bool] -> Bool
09:07:32 <quicksilver> :t and
09:07:33 <lambdabot> [Bool] -> Bool
09:07:59 <shachaf> That'll possibly be a bit inefficient with a large list since it'll hold the whole thing in memory.
09:09:13 <shachaf> @ty let sequenceLast [] = error "oops"; sequenceLast [x] = x; sequenceLast (x:xs) = x >> sequenceLast xs in sequenceLast
09:09:14 <lambdabot> forall (m :: * -> *) a. (Monad m) => [m a] -> m a
09:09:38 <shachaf> (Is there a nice way to write that as a foldr?)
09:09:44 <astry_> oh liftM, i tried liftM but it hasn't worked out for me before, but your suggestion was good, thanks quicksilver
09:10:02 <rwbarton> foldr1 (>>)?
09:10:09 <rwbarton> is it that?
09:10:13 <shachaf> Oh, er, yes.
09:10:17 * shachaf = silly
09:10:42 <shachaf> To be fair, writing foldr1 in terms of foldr probably gets hacky.
09:10:55 <shachaf> astry_: Better than liftM: You can use fmap.
09:11:08 <astry_> how would i do that?
09:11:15 <b__> is there a more powerful language than Haskell (leaving it up to you to define more powerful)?
09:12:06 <shachaf> I define "power" as "similarity to Haskell", and therefore no.
09:12:13 <Mortchek> b__, can't get more powerful than machine code.
09:12:31 <rwbarton> there's dependently typed languages (agda, idris, coq, ...) that are more something than Haskell
09:12:31 <astry_> Mortchek: depends what machine..
09:12:40 <b__> I knew I'd be getting this type of answer from a bunch of smart programmers
09:12:46 <Cale> b__: There are some theorem provers with more expressive type systems, like Agda and Coq.
09:12:52 <kame> people who use Haskell in production: do you use hp2ps?
09:13:07 <shachaf> ...That definition there only extended to that one line of IRC, by the way.
09:13:08 <astry_> what is hp2ps?
09:13:11 <Cale> kame: yes occasionally
09:13:12 <nand`> Haskell is machine code for Haskell machines
09:14:11 <astry_> hp2ps looks useful
09:14:12 <kame> astry, ghc can generate a heap profile, the output is an hp (text) file. hp2ps converts it to a postscript graph
09:14:28 <b__> what would make Haskell more powerful than how it is in your opinion(s)?
09:14:30 <astry_> got any screenshots kame?
09:14:34 <Cale> hp files are pretty unreadable without hp2ps
09:14:45 <b__> dependent typing does seem supercool
09:14:50 <kame> Cale, I know that
09:14:58 <rwbarton> I started playing around with idris last night. You can tell it is more powerful than Haskell because the error messages are much, much worse ;)
09:14:59 <b__> but are there other directions we could take?
09:15:11 <nand`> b__: the addition of a primitive functionm for solving the halting problem
09:15:18 <kame> I'm wondering if it's a tool that "everybody" uses
09:15:19 <clsmith> rwbarton: that does seem to be a trend...
09:15:21 <nand`> would make Haskell quite a bit more powerful, in my opinion
09:15:38 <kame> or if it's rarely used... or if it's been superseded by something else...
09:15:56 <Cale> It makes me sad that these dependently typed languages usually go with strict evaluation
09:16:19 <Cale> I mean, just because you can prove it'll terminate doesn't mean that it's a good idea :)
09:16:20 <b__> can't tell if you're trolling meh, or if you're serious nand`, either way my knowledge is lacking :[]
09:16:26 <kame> the reason I ask is because I'm in the process of converting hp2ps source from C to Haskell, as an exercise
09:16:40 <rwbarton> I bet you could cook up a cool hp2ps replacement with gloss
09:16:41 <astry_> b__: the former
09:17:01 <nand`> b__: the ‘joke’ is that it's not possible on a turing machine; so adding it as a primitive function would mean Haskell is capable of things even a turing machine is not
09:17:07 <nand`> thus, more ‘powerful’
09:17:16 <nand`> in finite time, I might add
09:17:26 <nand`> b__: it's not a serious proposal
09:17:39 <b__> thanks for footnoting that :D
09:17:40 <astry_> the most powerful thing imo would be if hackage started showing up in google results in better ways
09:17:59 <astry_> currently i get results from old versions of packages, buried deep in the result list
09:18:00 <kame> yes, gloss would be nice
09:18:02 <b__> or if it wouldn't be down so much
09:18:11 <kame> but first I want to do the simplest thing possible
09:18:15 <astry_> and only if i actually google for "hackage + what i wanted to search for"
09:18:40 <astry_> someone needs to search-engine-optimize
09:19:08 <b__> despite not knowing about the halting problem, I do that in my day job
09:19:20 <b__> could lend a hand
09:19:21 <rwbarton> another fun idris experience is having to optimize your program not for run time but for compile time
09:19:32 <nand`> personally I'd be for revamping some of existing Haskell with newer ideas or approaches; even simple things like making Applicative a superclass of Monad - or more radical stuff like providing lens (families) for record syntax instead of the current somewhat clumsy system
09:19:56 <Lutin`> I think a general restructuring would help
09:19:57 <nand`> rather than trying to introduce lots of ‘cool new stuff’ and making it gravitate in on itself
09:20:11 <clsmith> yeah, haskell could do with a spring clean
09:20:27 <b__> I was writing a chess engine and I got stuck on the big-ass move generation function
09:20:35 <b__> I got lost trying to structure it
09:20:37 <Lutin`> It needs the Functor -> Applicative -> Monad
09:20:42 <astry_> yes the current system for records is bad
09:21:00 <nand`> it's not too bad in itself; it just doesn't fit into the feel of haskell very well imo
09:21:05 <astry_> but lens is new, how do you know soon lens won't be superceded by something new
09:21:13 <b__> I had to update a big (board/state) data structure, and I found myself begging for state
09:21:29 <Cale> The current system for records is okay, it's just not great.
09:21:33 <edwardk> astry_: if i lived in fear of that i'd never get anything done
09:21:38 <Cale> Same goes for modules
09:21:38 <nand`> astry_: well, the thing about van laarhoven lens families is that they aren't dependent on any single lens package
09:22:00 <astry_> nand`: not sure what that means
09:22:13 <edwardk> astry_: _2 f (a,b) = (,) a <$> f b
09:22:15 <nand`> astry_: you can provide a lens without a dependency on the ‘lens’ package
09:22:23 <nand`> astry_: and any other lens package can use them
09:22:24 <edwardk> astry_: that defines a 'van laarhoven lens family'
09:22:29 <edwardk> it doesn't use anything from lens
09:22:31 <Lutin`> astry_: http://comonad.com/reader/2012/mirrored-lenses/
09:22:34 <edwardk> but its compatible with my library
09:22:36 <nand`> (ones that use van laarhoven lenses, at any rate)
09:22:37 <Cale> Yeah, the lenses that people are working with now are type Lens a b c d = forall f. Functor f => (c -> f d) -> a -> f b
09:22:44 <nand`> yeah, it's just a type alias
09:22:49 <astry_> my #1 practical problem with haskell is that people use unqualified imports everywhere and it's so annoying to track documentation..
09:22:59 <kame> b___ why do you need state for updating a board?
09:23:07 <Cale> It's really unlikely that Functor gets superseded at this point
09:23:09 <astry_> my #2 problem is a fairly dry repl
09:23:31 <nand`> A supercharged haddock that sprinkles the source code with links to documentation for every single function might be neat
09:23:38 <nand`> basically, a smart ‘Source’ page
09:23:43 <Cale> nand`: I was thinking about that the other day
09:23:48 <b__> came, probably because my way of thinking is fawked :}
09:23:50 <danharaj> edwardk: how much trouble will I get into if I make an iso out of a pair of functions that are only sections/retracts of each other?
09:23:55 <Cale> That I had to go back to the documentation and then click another source link
09:24:09 <Cale> rather than just clicking around in the generated source HTML
09:24:15 <b__> I need to increment move count, swap active colours, and update the board
09:24:15 <Lutin`> Yeah I mean I can just do ctrl-] in vim
09:24:25 <Lutin`> Why can't I do this in haddock
09:24:26 <b__> kame*
09:24:27 <nand`> Cale: sometimes it can be downright difficult to track down some internal function (eg. if you're researching implementation) which is buried deep within modules, if you don't know where it is because haddock doesn't show it
09:24:30 <astry_> Cale: good morning, btw
09:24:34 <astry_> :)
09:24:42 <nand`> Cale: yeah, that as well
09:24:46 <Cale> I think I'm going to go back to sleep, I didn't really get enough
09:24:49 <Cale> (4 hours)
09:24:57 <astry_> go on then
09:25:00 <Cale> I'm not having much luck getting work done
09:25:01 <kame> yeah, you just create a new board.... newBoard = currentBoard { count = count currentBoard + 1, ....}
09:25:05 <astry_> watch out for sugar
09:25:08 <b__> yeah that's what I'm doing kame
09:25:26 <nand`> Cale: Ideally I could see a sort of ‘hybrid’ page working also, which works like the usual haddock page but where the source link just expands the source code for that function in-place
09:25:29 <b__> but I have to get a new board (potentially) for every piece
09:25:37 <kame> if the syntax is incovenient you can try some of the lenses packages (I don't know them well)
09:25:41 <b__> I know how to do it, but not elegantly
09:25:48 <b__> I'm using fclabels
09:25:55 <kame> cool
09:26:15 <b__> but perhaps lens packages exist that are better suited for complex modifications
09:26:25 <kame> I want to write a Go program  in Haskell
09:26:32 <b__> in other words I need to stop being lazy about it and do some research
09:26:35 <Cale> nand`: I would also just love it if Haddock didn't mangle the syntax of types so often.
09:26:38 <kame> probably will use some existing open source program as a base
09:26:43 <nand`> (a different but related concern is that instance implementations don't have Source links)
09:26:47 <b__> Go as in game yeah?
09:26:50 <kame> yes
09:26:54 <nand`> Cale: yes, ~ * stuff looks confusing and ugly
09:26:58 * Lutin` points b__ to edwardk
09:26:58 <nand`> I have to look at the source to figure them out
09:27:14 <nand`> ‘complex modifications’
09:27:20 <kame> It will be nice to play with parallel programming
09:27:22 * nand` glares at edwardk's zipper-based traversals
09:27:35 <b__> edwardk has saved my ass more than once (probably not remembering that), but why are you pointing him to me?
09:27:46 <b__> or me to him, rather
09:27:57 <Cale> b__: have you looked at 'lens'?
09:28:08 <nand`> well for example in ‘lens’ the currentBoard { count = count currentBoard + 1 } would just be count +~ 1
09:28:11 <Cale> http://hackage.haskell.org/package/lens-2.9
09:28:17 <b__> oh wow
09:28:37 <nand`> or += 1 if you're working in State :)
09:28:49 <Cale> (you may have to mention currentBoard)
09:28:50 <applicative> b__: *everyone*s talking about it...
09:28:53 <rwbarton> can someone explain briefly what versions of GHC have what degree of support for type level naturals/integers?
09:28:53 <b__> thanks, I'll definitely look at it : }
09:29:11 <nand`> Cale: yeah; often you can eta-reduce after switching to lens operators though
09:29:19 <nand`> which is a cool thing that is missing from record syntax
09:29:22 <Cale> rwbarton: 7.6.1 introduced support for those
09:29:26 <rwbarton> aha
09:29:28 <b__> that's the kind of alien-brain solution I'm looking for
09:29:28 <Lutin`> nand`: eta or beta?
09:29:36 <rwbarton> and do they work? :)
09:29:39 <nand`> uh
09:29:40 <Lutin`> b__: lol good way to put it
09:29:49 <nand`> 7.6.1 just added type nat literals; but type nats can be defined before it
09:30:04 <rwbarton> I pretty much want literals really
09:30:08 <b__> yeah and for the record, that's definitely a compliment
09:30:15 <b__> oh that pun was not intentional
09:30:43 <Cale> rwbarton: if you don't do anything too fancy requiring an equation solver, then they ought to
09:30:45 <nand`> b__: lenses can do a lot of cool stuff for modifying stuff like arrays too
09:31:02 <astry_> for the record, lens focuses on Functor
09:31:02 <rwbarton> ok so basically 7.6.1 = built-in type-level naturals and literals, 7.4 = DataKinds which I can use to build my own type-level naturals, earlier = I can fake type-level naturals
09:31:07 <Cale> rwbarton: (there's no solver yet)
09:31:07 <nand`> eg. something like board ^. at (x, y) for reading out the board
09:31:12 <astry_> pun intentional
09:31:19 <Cale> rwbarton: right
09:31:44 <rwbarton> Thanks
09:31:47 <astry_> rwbarton: before 7.4 you could use successor type constructors, right?
09:31:52 <astry_> or did that start with 7.4?
09:31:54 <Lutin`> astry_: lens is to functor as applicative is to biplate
09:32:09 <astry_> what is biplate?
09:32:24 <Lutin`> Woah I got the orders switched in that
09:32:25 <astry_> when i hear biplate i think of that physics experiment with thermal expansion differential
09:32:28 <Cale> I don't understand why the ConstraintKinds extension is plural
09:32:43 <b__> cheers Cale, nand`, astry_, Lutin`, kame, gonna have fun with it this weekend
09:32:49 <applicative> Cale: At first they called it that
09:33:00 <Lutin`> b__: Read all the source!
09:33:00 <nand`> b__: the wiki is a good resource, as are edwardk's blog posts
09:33:02 <astry_> enjoy
09:33:03 * hackagebot data-treify 0.3.3 - Reify a recursive data structure into an explicit graph.  http://hackage.haskell.org/package/data-treify-0.3.3 (ConalElliott)
09:33:06 <applicative> maybe (* -> * -> Contstraint) is a constraint kind
09:33:21 <edwardk> Lutin`: lens is to functor as traversal is to applicative
09:33:26 <Cale> yeah, I guess maybe
09:33:30 <nand`> applicative: have you been working with a lot of continuations lately?
09:33:34 <b__> Lutin`, nand`, will do :}
09:34:00 <astry_> Cale: btw, i was told by shachaf that i could use fmap instead of forM_ ?
09:34:02 <rwbarton> astry_: you could build your own type level naturals for a long time (how long depending on exactly what you want to do with them) but 7.4 introduced the possibility of having a kind which is inhabited *only* by type level naturals
09:34:11 <edwardk> rwbarton: 7.6.1 has basic type literals, but no solver plugged in
09:34:16 <applicative> @type forM_
09:34:16 <astry_> rwbarton: mhm
09:34:17 <lambdabot> forall a (m :: * -> *) b. (Monad m) => [a] -> (a -> m b) -> m ()
09:34:37 <astry_> @type fmap
09:34:38 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
09:34:38 <shachaf> astry_: No, instead of liftM.
09:34:39 <edwardk> rwbarton: and you could fake that closure property by doing dirty tricks before, see my old type-int package
09:34:44 <Lutin`> edwardk: I'm going off this, I couldn't prove it myself :P http://arxiv.org/ftp/arxiv/papers/1103/1103.2841.pdf
09:34:50 <astry_> shachaf: oh
09:34:52 <astry_> never mind then
09:34:59 <edwardk> Lutin`: yes, i know the paper =)
09:35:05 <astry_> @type liftM
09:35:06 <lambdabot> forall a1 r (m :: * -> *). (Monad m) => (a1 -> r) -> m a1 -> m r
09:35:28 <astry_> fmap is like a better liftM right?
09:35:37 <astry_> because Functor < Monad
09:35:42 <applicative> astry_: fmap requires a Functor instance
09:35:43 <edwardk> Lutin`: CartesianStore is the 'Bazaar' comonad used in lens. Traversal is a nicer name for Biplate
09:35:46 <applicative> of course
09:36:04 <edwardk> Lutin`: because 'traverse' is a Traversal
09:36:05 <astry_> oh i thought Functor was less specific than Monad?
09:36:17 <applicative> astry_: yes but Functor and Monad instances  are made separately
09:36:25 <nand`> Functors are more general than Monad, but for historical reasons Functor is not a superclass of Monad
09:36:29 <astry_> what is a biplate?
09:36:40 <astry_> applicative: ok
09:36:44 <nand`> you can use fmap if you're working with some concrete type that you know has a Functor instance
09:36:45 <edwardk> astry_: type Traversal a b c d = forall f. Applicative f => (c -> f d) -> a -> f b
09:36:51 <edwardk> astry_: biplate is an old name for traversal
09:37:08 <astry_> i am not sure how forall works
09:37:16 <nand`> but if you're polymorphic in the choice of monad; you'd need a Functor constraint as well to use fmap; which is mainly why liftM exists (also so you can write instance Functor f where fmap = liftM)
09:37:23 <edwardk> :t Data.Traversable.traverse
09:37:24 <lambdabot> forall a (f :: * -> *) b (t :: * -> *). (Data.Traversable.Traversable t, Applicative f) => (a -> f b) -> t a -> f (t b)
09:37:32 <applicative> astry_: if you make your own monad instance, you can make a functor instance with fmap = liftM .... as nand` says
09:37:54 <edwardk> traverse :: (Traversable t, Applicative f) => (c -> f d) -> t c -> f (t d)
09:37:56 <edwardk> or
09:37:56 <astry_> applicative: i am not making monads
09:38:09 <Lutin`> edwardk: I really need to take a category theory class :X
09:38:10 <edwardk> traverse :: Traversable t => Traversal (f c) (f d) c d
09:38:15 <nand`> applicative: how often is this done in practice? Don't many definitions opt for more efficient/direct implementations of fmap?
09:38:19 <edwardk> Lutin`: none of this comes from category theory
09:38:25 <applicative> astry_: for the built in monad types, they all  have functor instances,  so fmap = liftM = <$>
09:38:32 <nand`> edwardk: except applicative functors, arguably
09:38:46 <edwardk> nand`: loosely, yes
09:39:34 <astry_> i have a question
09:39:51 * nand` has an answer, though not necessarily for astry_'s question
09:39:59 <astry_> i have currently a case expression where the targets for a lot of cases are duplicated
09:40:13 <astry_> how can i tidy that up?
09:40:31 <nand`> astry_: I'd put common stuff in a ‘where’ block below it
09:41:17 <astry_> i mean something like this: http://dpaste.com/804118/
09:41:59 <applicative> astry_: what happens in the other cases?
09:42:10 <nand`> well, I guess in this case I would go with something like | k `elem` "ax" = handleAX state k | k `elem` "hjkl" = handleHJKL state k | otherwise = liftIO G.mainQuit
09:42:32 <nand`> (as a function definition, if that case is its only body)
09:43:02 <applicative> astry_: note that you're pattern matching on strings, maybe it should be Chars?
09:43:03 * hackagebot yall 0.2.1 - Lenses with a southern twang  http://hackage.haskell.org/package/yall-0.2.1 (BrandonSimmons)
09:43:48 <astry_> no it's strings
09:43:52 <astry_> they're event names
09:44:14 <rwbarton> edwardk: I need a "collapse all instances" button in Haddock to read this
09:44:41 <nand`> read what?
09:44:51 <rwbarton> the type-int haddocks
09:44:57 <MostAwesomeDude> Hackage really needs a way for maintainers to mark things as deprecated.
09:45:04 <astry_> can i use guards anywhere or only in the function top level?
09:45:13 <nand`> ouch, yeah
09:46:30 <nand`> how come the instance list is so huge for that but the source code is rather small? Are all of the instances hidden in some (TH-generated?) internal file?
09:46:36 <nand`> ah, dependency on template-haskell
09:46:39 <edwardk> rwbarton: hahaha, its pretty bad
09:46:43 <nand`> I guess that would answer at least a portion of that question
09:47:27 <edwardk> rwbarton: keep in mind that was basically the second package i ever wrote in haskell, i'm not sure i'd do things the same way now
09:47:32 <edwardk> but it was a nice way to learn haskell
09:47:54 <rwbarton> oh
09:47:59 <rwbarton> I was planning on using something like this
09:48:03 * hackagebot zippo 0.3 - A simple lens-based, generic, heterogenous, type-checked zipper library  http://hackage.haskell.org/package/zippo-0.3 (BrandonSimmons)
09:48:12 <rwbarton> in the past I used some other similar library though
09:48:49 <rwbarton> @hackage type-level
09:48:49 <lambdabot> http://hackage.haskell.org/package/type-level
09:48:56 <edwardk> this one has the benefit that it does 2s and 16s complement arithmetic so it can represent negative numbers properly. none of the others that i recall did so correctly
09:49:32 <edwardk> this has the benefit that pred can be total, and so can subtraction, etc.
09:49:55 <edwardk> and with 16s complement it can represent something like 72 bits of data at the type level before hitting the default recursion limit
09:50:05 <edwardk> which is enough to store a pointer ;)
09:50:36 <rwbarton> my needs are pretty trivial
09:50:55 <rwbarton> I want to be able to talk about bounded integer types and fixed size arrays to index into with them
09:50:55 <edwardk> http://hackage.haskell.org/packages/archive/type-int/0.5.0.2/doc/html/Data-Type-Hex-Stage2.html is pretty ridiculous from a haddock perspective
09:51:04 <edwardk> back when i wrote that package haddock didn't see any TH instances
09:51:09 <applicative> astry_: you can use guards inside a case statement.
09:52:02 <nand`> ‘it was basically the second package i ever wrote in haskell’ <- I imagine edwardk was doing type-level computation by arranging colored blocks as a baby
09:52:12 <t7> i anyone using the type level stuff todo verified programs in haskell?
09:52:29 <astry_> applicative: i didn't know. i'll check it out, thanks.
09:52:32 <t7> (at a level higher than tinkering)
09:52:34 <Lutin`> astry_: Top level patterns in case expressions and the set of top level patterns in function or pattern bindings may have zero or more associated guards.
09:52:38 <Lutin`> From Haskell98
09:53:16 <edwardk> nand`: the first package was some embarassingly bad stm based sorted linear hash table that had a pretty bad choke point in it
09:53:24 <astry_> is there a more succinct way to write this? do { x <- func; let y = MyRecord { foo = x } }
09:53:44 <edwardk> i suppose i redeemed it by later on selling a product built on a bloom filtered version of it ;)
09:53:47 <astry_> i would like "func" to be on the rhs of "foo".
09:54:04 <Lutin`> Just to test
09:54:10 <Lutin`> @pl \func -> do { x <- func; let y = MyRecord { foo = x } }
09:54:10 <lambdabot> (line 1, column 13):
09:54:11 <lambdabot> unexpected "{"
09:54:11 <lambdabot> expecting variable, "(", operator or end of input
09:54:12 * nand` .oO( foo <~ func )
09:54:22 <nand`> oh
09:54:24 <nand`> no, note the same thing
09:54:26 <nand`> not*
09:54:42 <astry_> doesn't seem to work
09:55:09 <nand`> edwardk: is <~ the perform-MonadState-action-and-assign-to-lens thing right now?
09:55:18 <edwardk> nand`: yeah
09:55:32 <edwardk> nand`: i'm thinking of adding a <<~ variant that you can use to 'also get the result
09:55:37 <edwardk> i just realized that was missing
09:55:54 <nand`> that looks like a funky comonad operator
09:55:58 <edwardk> heh
09:56:20 <edwardk> its sad, but _I_ can never remember the infix versions of the comonad operators
09:56:47 <nand`> they're like >>= =<< but with the = on the other side? :P
09:58:06 <edwardk> my problem is that >> screws up the analogy
09:58:54 <shachaf> Is there an equivalent to >> for Comonad?
09:59:04 <copumpkin> does do notation desugaring use >> where posibble?
09:59:10 <copumpkin> or does it use >>= \_ ->
09:59:31 <edwardk> w a -> (w a -> b) -> w b   would give you something with: w a -> b -> w b
09:59:34 <nand`> I guess you could test it by writing a broken monad implementation
09:59:46 <copumpkin> nand`: yeah, too lazy though
09:59:53 <applicative> copumpkin: It goes by >> since you are supposed to be able to optimize
09:59:59 <nand`> edwardk: that looks like ($>)
10:00:33 <Lutin`> copumpkin: Yes it uses >>
10:00:35 <edwardk> nand`: haven't calculated if it does the same thing
10:00:53 <Lutin`> http://www.haskell.org/onlinereport/exps.html#sect3.14
10:03:40 <magistr> hi to all
10:04:06 <magistr> give me a books to learning lambda calculus
10:04:10 <smithw> is there a built-in way in haskell to do the same thing getDirectoryContents do without exceptions, and instead with Either/Maybe monads?
10:04:12 <magistr> please
10:04:20 <clsmith> barendregt? :p
10:05:12 <coldpizza72i_> Would someone be kind enough to help me with my bubble sort implementation… Here is my approach that I started http://ideone.com/Er2Qx …The idea I was going for is to run in O(n^2) for every case…. right now this just returns the first element of the list
10:08:38 <Ferdirand> coldpizza72i_: otherwise = x
10:08:41 <Ferdirand> there's your problem
10:09:23 <coldpizza72i_> Ferdirand: then i get Non-exhaustive patterns in function outerLoop
10:09:45 <Ferdirand> well you should fix it, not remove it
10:09:54 <fmap> @type \x -> Control.Exception.try $ System.Directory.getDirectoryContents x
10:09:55 <lambdabot> forall e. (GHC.Exception.Exception e) => FilePath -> IO (Either e [FilePath])
10:10:09 <fmap> smithw: ^
10:10:16 <magistr> give me a books to learning lambda calculus
10:10:29 <smithw> fmap: thanks so much!
10:11:51 <coldpizza72i_> Ferdirand: otherwise = pass x would make sense right?
10:15:21 <magistr> give me a books to learning lambda calculus please
10:15:54 <djahandarie> magistr, try TAPL. http://www.cis.upenn.edu/~bcpierce/tapl/
10:17:17 <coldpizza72i_> Ferdirand: because when i do that I get No instance for (Num [a0])
10:19:49 <Ferdirand> coldpizza72i_: you should write type signatures
10:20:56 <Ferdirand> it will make the error messages more relevant
10:24:15 <Ralith> bos: don't have time to talk right now, but the pull request is up.
10:24:46 <Ralith> dammit.
10:25:13 <coldpizza72i_> Ferdirand: is this the correct type signature of outer loop "outerLoop :: Num a -> Num a -> Num b  "
10:25:57 <Ferdirand> what do you think
10:26:02 <coldpizza72i_> yes?
10:26:07 <Ferdirand> is outerLoop a function that takes two numbers and returns a third ?
10:26:25 <coldpizza72i_> oops
10:26:28 <Ferdirand> (which compiler is that by the way ?)
10:26:56 <coldpizza72i_> ghc
10:27:15 <Ferdirand> ghc gave you "outerLoop :: Num a -> Num a -> Num b  " ?
10:27:34 <coldpizza72i_> outerLoop :: Num t => [t] ->[t] ->[t]
10:27:53 <coldpizza72i_> huh
10:28:07 <Ferdirand> okay, that makes more sense
10:28:49 <hpaste> pr pasted “ghc (64bit) fails to compile simple file” at http://hpaste.org/75066
10:29:08 <pr> ^^ what is ghc actually complaining about here?
10:29:49 <shachaf> pr: It's some linker error. Maybe it has to do with versions of libraries?
10:30:38 <coldpizza72i_> Ferdirand: without the type sig ghc tells me outerLoop :: (Eq t, Ord a) => [[a]] -> [t] -> [a]
10:32:33 <gabor> zygoloid: hi
10:32:50 <pr> right. seems to me that maybe there's some package that wasn't build with the 64bit i have installed? a while ago i used to use the 32bit version of ghc, uninstalled it in a more or less clean way, and installed the 64bit version
10:34:33 <pr> hah, quick google search for libHSbase turns up this: http://blog.omega-prime.co.uk/?p=96
10:35:14 <clahey> Has anyone tried using haskell for mobile app development?
10:35:24 <shachaf> pr: Oh, OS X.
10:46:21 <Ralith> bos: I noticed (as you might guess) that a sizable portion of this is redundant to LLVM.Util, but I feel it's useful to have an isolated, self-contained, more complete and more consistent-with-the-C-API approach; perhaps eventually LLVM.Util would be largely subsumed.
10:46:26 <pr> right, i just "disabled" libiconv and everything that depended on libiconv (quite a bit). now Test.hs compiles, tho its output is rather unexpected, but still, it compiles, hooray
10:48:02 <bos> Ralith: i'll review when time permits - thanks
10:48:15 <Ralith> \o/
10:49:35 <hpaste> keep_learning pasted “Putting values in list of MVar ” at http://hpaste.org/75068
10:49:48 <Ralith> there's very little to it beyond the minor fixes I found it necessary to apply to base
10:50:44 <Ralith> and the refactoring of the FP/Int predicates into base from LLVM.Util
10:51:18 <Ralith> (to maintain consistency with the linkage stuff also being there)
10:51:47 <keep_learning> Hello all
10:52:31 <keep_learning> I am trying to fork 10 threads inside a thread so I created list of 10 MVars
10:52:52 <keep_learning> but I am not sure how to use putMVar inside those threads.
10:52:57 <keep_learning> I am getting Thread: thread blocked indefinitely in an MVar operation
10:53:05 * hackagebot yesod-auth-kerberos 1.0.2 - Kerberos Authentication for Yesod.  http://hackage.haskell.org/package/yesod-auth-kerberos-1.0.2 (ArashRouhani)
10:55:20 <keep_learning> or any other way to do this?
10:55:44 * Ralith isn't really familiar with MVars, but wonders if they might block until another thread reads from them
11:00:29 <keep_learning> Any one please.
11:00:52 <byorgey> Ralith: no, they don't
11:01:22 <Ralith> kk
11:02:00 <byorgey> keep_learning: on line 21, you try to read from empty MVars, which will block
11:02:13 <byorgey> keep_learning: so it never gets to the forkIO
11:03:17 <keep_learning> byorgey, Are not they empty so they will blocked until filled by some other thread ?
11:03:18 <Ralith> ah, the opposite.
11:04:17 <byorgey> keep_learning: a call to readMVar will block on an empty MVar until the MVar is filled, yes.
11:04:42 <byorgey> keep_learning: but in your code you have a single thread which creates empty MVars and then reads them, so it blocks.  It never gets around to creating other threads.
11:05:25 <keep_learning> byorgey, So how to fire those inside threads.
11:05:47 <byorgey> keep_learning: simple, you have to fork them *before* reading from the MVars.
11:06:02 <byorgey> keep_learning: also, right now your code only forks one thread
11:06:38 <keep_learning> byorgey, Yes and my problem is how to use putMVar for list of  MVar.
11:07:28 <keep_learning> If I have to fire a single thread then I can declare  a newEmptyMVar and fill it inside.
11:07:33 <byorgey> keep_learning: something like  'sequence $ zipWith putMVar mvars values' ought to work
11:07:38 <Ralith> :t putMVar
11:07:39 <lambdabot> Not in scope: `putMVar'
11:07:42 <Ralith> aw
11:07:45 <shachaf> Your problem is not putMVar. The code never gets to putMVar.
11:10:52 <hpaste> keep_learning annotated “Putting values in list of MVar ” with “Putting values in list of MVar  (annotation)” at http://hpaste.org/75068#a75069
11:12:00 <keep_learning> byorgey, Oh I got you.  mapM_  readMVar  tot  should be below the forkIO otherwise it will be blocked ?
11:12:07 <zomg> Any ideas how to go about debugging a segfault from a haskell application?
11:12:09 <byorgey> keep_learning: correct.
11:12:25 <Daneo> What IDE is advised for writing developing haskell? I've read about leksah, but don't know, I'm either using windows or Slackware
11:12:34 <byorgey> keep_learning: more to the point, otherwise the forkIO will never run.
11:12:35 <zomg> Daneo: vim ;)
11:12:43 <keep_learning> byorgey, thank you
11:13:04 <byorgey> Daneo: if you want an IDE you could try EclipseFP
11:13:13 <byorgey> which is a Haskell plugin for Eclipse
11:13:14 <keep_learning> byorgey, Now I can fire thread inside a thread because I know I have only one MVar so I can fill it inside the thread
11:13:15 <Ralith> zomg: I tried to do that a while ago; ultimately I fell back on Debug.Trace
11:13:19 <geekosaur> Daneo, there's no single recommended IDE; haskell has less of a need for the kind of refactoring tools that IDEs offer, by nature.  many people use emacs or vim; there is leksah, also eclipseFP
11:13:35 <Daneo> zomg: ok lol. byorgey: Does it offer an advantage compared to vim?
11:13:43 <keep_learning> What if I have say 10 thread and I have to put fill those values
11:13:54 <byorgey> Daneo: I don't know, I don't use either
11:14:16 <byorgey> keep_learning: just pass a differnt MVar to each thread
11:14:29 <zomg> Ralith: yeah I'm getting this error from library code (Yesod) so a bit tricky that
11:14:44 <zomg> Well trying to ask on yesod if they have any idea but thought maybe someone here had some general advice
11:14:57 <Ralith> zomg: oh, in that case submit a bug report and let someone else fix it
11:14:58 <Ralith> ^^
11:15:06 <Ralith> (don't forget a minimal testcase)
11:15:14 <zomg> Yeah I wish it was that simple =)
11:15:19 <Ralith> ?
11:15:27 <byorgey> keep_learning: mapM_ mkThread tot;  mkThread var = forkIO $ ... var ...
11:15:30 <zomg> Pretty sure it's something wrong with cabal or some other libs or such...
11:15:31 <Yuu-chan> I'm trying to use Text.Regex. How can I extract parts of the regex (like .group(i) in Python)?
11:15:37 <zomg> since it worked fine before I upgraded GHC
11:15:47 <Ralith> zomg: ah. My sympathies.
11:15:51 <zomg> Just don't have any ideas how to go about fixing that
11:15:52 <zomg> :P
11:16:03 <keep_learning> byorgey, Thank you!
11:16:06 <Ralith> get local checkouts of the libs and really spam trace.
11:16:10 <Ralith> >_>
11:16:23 <byorgey> keep_learning: there's nothing really specific to MVars or threads going on here. It's all just paying attention to types and using combinators like map, zip, mapM_, etc.
11:16:28 <danharaj> writing Unbox instances for Vectors is painful. Does anyone have a TH macro for it?
11:17:25 <zomg> Ralith: think I'll just nuke .cabal
11:17:26 <zomg> :P
11:17:37 <zomg> again.
11:17:38 <zomg> lol
11:17:50 <keep_learning> byorgey, I am  trying to learn thread  so probably it's fear of threads which are making me bit nervous.
11:19:21 <Saizan> zomg: the thing you want to delete is ~/.ghc/ if anything
11:19:33 <copumpkin> danharaj: nope, but you aren't a newtype are you?
11:19:33 <copumpkin> in that  case you could just use newtypederiving
11:20:05 <zomg> Saizan: Ah, should do that too I guess
11:20:11 <Saizan> newtype Danharaj = ..
11:20:11 <zomg> thanks, wouldn't have realized that myself :P
11:20:21 <byorgey> zomg: you really should never have to delete .cabal
11:20:31 <byorgey> zomg: .ghc is where installed packages go
11:20:40 <byorgey> .cabal just has some cached .tar files and such
11:20:45 <zomg> well looks like I had some junk for ghc 7.0.3 in cabal so at least I'll save some space :P
11:20:52 <byorgey> ok, sure =)
11:21:17 <Daneo> geekosaur: If i look at haskell as a scrypting language, would that be wrong? Or in what sense do you mean less need of refactoring tools?
11:21:17 <danharaj> copumpkin: Some newtypes, some simple tuple types. Regardless I wouldn't feel right using a terribly dangerous extension for convenience :P
11:21:35 <Saizan> anyhow upgrading to a new ghc early is not the best route if you care about large libs building fine
11:21:36 <copumpkin> danharaj: it isn't terribly dangerous
11:21:48 <geekosaur> Daneo:  refactoring is a concept that is to some extent replaced by higher order operations in Haskell
11:21:50 <danharaj> It is at least 12 dangerous
11:22:03 <copumpkin> danharaj: it can be used to do evil occasionally, but it's awfully helpful sometimes
11:22:07 <ethercrow> Daneo: you could also try yi, it's hard to get it working without learning some haskell
11:22:19 <copumpkin> seems silly to write a bunch of boilerplate because an extension can be used incorrectly
11:22:41 <Saizan> why are we considering newtype deriving dangerous?
11:23:01 <danharaj> because it can break module boundaries and make code asplode
11:23:14 <copumpkin> meh :P
11:23:35 <Daneo> ethercrow: Guess that's not for just now then :-)
11:23:43 <Saizan> as long as the methods for the class are exported it doesn't seem a problem
11:24:06 <rwbarton> wow, this had me baffled for a long time. http://hpaste.org/75070
11:24:26 <Daneo> notepad ++ 'll do as well I guess :-)
11:24:52 <rwbarton> got this error message because constant has a (Show t) constraint and there is a (Num t) constraint in scope
11:25:38 <rwbarton> now Show isn't a superclass of Num any more so it tried to use the overlapping instance "instance Yices f r => Show f where ..." in this module instead :(
11:25:54 <Saizan> oh god
11:26:05 <danharaj> idk why ghc decided to break the standard in that particular way
11:26:23 <danharaj> It's useful but it seemed to be done without much discussion.
11:26:56 <rwbarton> well if not for this silly instance I think I would have gotten a helpful error "Could not conclude (Show t) from the context (Num t, ...)"...
11:27:55 <benmachine> danharaj: there was /some/ discussion, on the libraries list I think
11:27:58 <benmachine> but it was some time ago now
11:31:45 <Sharyari_> Hi. I'm trying to divide two integers that are the result of function calls, why does this not work? (i.e. f x returns an int, I'm trying to divide (f x)/(f x)
11:32:13 <shachaf> Because / can't divide integers.
11:32:21 <Yuu-chan> \me has read "command" as "comonad"
11:32:25 <Yuu-chan> Meh.
11:32:48 * Yuu-chan forgot how to use IRC
11:33:13 <Sharyari_> shachaf: Ah, of course :)
11:33:15 <Eduard_Munteanu> \you remembered :P
11:35:18 <kanedank> hey, what does the "," signify for this:
11:35:19 <kanedank> eval (List [Atom "quote", val]) = val
11:35:44 <kanedank> usually I think of , as separating values in a tuple; I have no clue what it means in teh context of a list
11:36:17 <bibbi> hi guys, I'm trying to install ncurses with cabal
11:36:32 <bibbi> but I get:  dist/build/UI/NCurses.chs.h:5:29: fatal error: ncursesw/curses.h: No such file or directory
11:36:42 <kanedank> oops, I'm an idiot, it's described in a later paragraph :(
11:36:56 <bibbi> I have install ncurses-devel, I'm in ubuntu
11:37:02 <bibbi> *installed
11:37:12 <geekosaur> bibbi, the haskell ncurses package is a little behind and expects an older version of ncurses
11:37:25 <Cale> kanedank: It also separates the elements of a list
11:37:44 <bibbi> geekosaur: which version am I supposed to use?
11:37:45 <geekosaur> ncursesw (utf8 aware ncurses variant) was folded into ncurses some time back, but the haskell bindings think it's still separate
11:38:28 <geekosaur> the correct fix is to cabal unpack ncurses, change "ncursesw" to "ncurses" everywhere, then "cabal install" (without a package name) in the directory with the ncurses.cabal file
11:38:53 <bibbi> wow
11:38:57 <bibbi> I'll try it
11:39:48 <akfdj> http://vpayin.com/ref.php?page=act/ref&invcod=47781
11:40:08 <geekosaur> and at some point someone should update the ncurses package, but apparently nobody uses it... someone asks about this every couple months, which isn't a sign of a popular package :)
11:40:44 <bibbi> lol I see
11:41:54 <bibbi> ncurses/curses.h: No such file or directory             :(((
11:43:30 <armlesshobo|work> kanedank: now that I think about it, me neither :S
11:43:59 <rwbarton> easy as [1, 2, 3]
11:44:11 <armlesshobo|work> Cale: I understand it separates elements of a list, but is it itself anything more than a delimiter?
11:44:17 <geekosaur> bibbi, I don't have a current ububtu install, try using "dpkg -L ncurses-devel" to see where it's installed (it may not be in the subdir any more; that might necessitate editing paths in several places)
11:44:35 <armlesshobo|work> and a function for making tuples?
11:44:58 <shachaf> "Of course, the use of short meaningless names is not encouraged in Haskell but I do it here to help you prime your internal parser."
11:45:28 <akamaus> Hi! I'm looking for the easiest way of running a process as another user from a haskell program running as root. The classic way is to do fork, setuid and then exec. Is there an easier way?
11:46:05 <shachaf> You could use su instead of doing it yourself...
11:46:13 <clsmith> (,) being a function is something that ends up really confusing to me for some reason
11:46:31 <benmachine> clsmith: well, in fairness it is magic
11:46:54 <benmachine> and commas are not functions everywhere they appear
11:50:06 <Eduard_Munteanu> Um, what's magic about (,) as a function?
11:50:09 <Eduard_Munteanu> :t (,)
11:50:10 <lambdabot> forall a b. a -> b -> (a, b)
11:51:13 <clsmith> syntax-wise
11:51:26 <rwbarton> should I expect to be able to load packages that link against C++ libraries in ghci? or is what I'm trying to do just hopeless?
11:51:40 <mysticc> Can I encode class constraints on type parameters of a data definition .. like .. data B a = B a .. Now I want to restrict a to certain classes ?
11:51:44 <Ferdirand> (1,2,3) is neither ((1,2),3) nor (1,(2,3))
11:51:49 <Ferdirand> that is what is wrong :p
11:52:26 <applicative> mysticc not for regular data types
11:52:51 <benmachine> Eduard_Munteanu: , is not an allowed character in function names, typically
11:53:11 <rwbarton> for example is it possible to use wxhaskell in ghci?
11:53:23 <rwbarton> (on linux)
11:53:35 <benmachine> mysticc: yes, but why would you want to?
11:54:12 <benmachine> mysticc: there are a couple of ways to do it, one of them is deprecated, the other requires a language extension
11:54:21 <applicative> isn't it forbiddenby Haskell 2010?
11:55:37 <mysticc> benmachine: What extension ?
11:55:42 <mysticc> applicative: Why ?
11:55:57 <benmachine> applicative: H2011 removes datatype contexts
11:56:35 <benmachine> mysticc: before I tell you, it would be helpful to know a little more about what you want
11:56:39 <clsmith> benmachine: might be nicer if you could (data Eq a => Set a) rather than having to always (Eq a => Set a -> ...) i guess
11:57:27 <benmachine> clsmith: datatype contexts used to let you do data Eq a => Set a = ..., but you needed the Eq constraint on functions *anyway*
11:57:37 <benmachine> it was fairly useless, so they were gotten rid of
11:57:54 <applicative> mysticc: gadts allow  it data Foo a where Foo :: Num a => a -> a -> Foo a
11:58:27 <clsmith> ^ i presume you need to constrain functions as before?
11:59:13 * benmachine has to leave before explaining
11:59:27 <clsmith> my guess is the answer is "yes" :p
12:00:16 <clsmith> yeah, must be. still, it might be nice if you could constrain data types that way.
12:00:43 <applicative> with a gadt you dont need the constraint in all cases:: f :: Foo a -> Foo a ;  f (Foo a b) = Foo (a+b) b -- given data Foo a where Foo :: Num a => a -> a -> Foo a
12:01:27 <hpaste> keep_learning annotated “Putting values in list of MVar ” with “Putting values in list of MVar  (annotation) (annotation)” at http://hpaste.org/75068#a75072
12:01:29 <mysticc> Yeah, Thanks
12:01:39 <clsmith> applicative: oh that is neat.
12:02:07 <bibbi> I'm getting [wget_wch]  >>>> Unknown Identifier!!
12:02:46 <keep_learning> byorgey, I have written this code to fire 10 concurrent threads inside a thread ( http://hpaste.org/75068 )
12:04:03 <keep_learning> byorgey, it's working fine but it would be great if you can have a look and kindly let me know if  I got your suggestion correctly.
12:04:30 <byorgey> keep_learning: yes, it looks good to me
12:05:05 <keep_learning> byorgey, Thank you!
12:07:09 <Jello_Raptor> note: this not how I should be making ascii tables in haskell :P http://hpaste.org/75073
12:08:34 <applicative> wow
12:11:09 <rwbarton> that is pretty awesome though!
12:11:13 <Jello_Raptor> that was me quickly hacking together a human readable output format so I could actually debug the important functions to generate those tables ... I think hacking is the perfect term there
12:11:17 <rwbarton> you might like this:
12:11:19 <rwbarton> @hackage diagrams
12:11:20 <lambdabot> http://hackage.haskell.org/package/diagrams
12:11:47 <ski> Jello_Raptor : looks lovely :)
12:12:12 <Jello_Raptor> ski: thanks :) .. not the code though, i am mostly amused that actually worked.
12:12:38 <rwbarton> hmm
12:12:47 <rwbarton> with cairo it should be possible to make an ascii art backend for diagrams right? :)
12:13:05 <cglazner>  iterate (join f) x
12:13:10 <cglazner> oops sorry
12:13:38 <Jello_Raptor> rwbarton: that looks wonderful
12:13:50 <ski> Jello_Raptor : .. did you define your table recursively ?
12:13:51 <byorgey> rwbarton: yes!
12:15:20 <Jello_Raptor> ski: not exactly, the original table is basically generated from a special 2d map function that will include the the three elements to the left and above the current one
12:15:32 <hpaste> keep_learning annotated “Putting values in list of MVar ” with “Putting values in list of MVar  (annotation) (annotation) (annotation)” at http://hpaste.org/75068#a75074
12:15:59 <keep_learning> byorgey, If  I write replicateM_ 10 ( forking function ) then it will create 10 sequential threads ( http://hpaste.org/75068 )
12:16:57 <byorgey> keep_learning: they are sequential because of the readMVar at tne end of the block inside the replicate
12:17:05 <byorgey> each time it will wait for the forked thread to write
12:17:48 <keep_learning> byorgey, Thank you! Looks like I learned little bit of threading :)
12:17:54 <byorgey> great =)
12:18:11 <ski> Jello_Raptor : well, you're (hopefully) doing dynamic programming, and a nice way to do this in haskell is to define a table (say an (immutable) array) recursively
12:18:53 <ski> Jello_Raptor : then, you inspect the result in the top-left cell, and that will only then compute the values in the cells that are actually needed
12:18:53 <keep_learning> byorgey, All credit goes to you :)
12:19:13 <keep_learning> and Haskell channel
12:20:30 <Jello_Raptor> ski: basically 'tableMap :: (a -> c -> c) -> (b -> c -> c) -> (c -> c -> c -> c) -> c -> [a] -> [b] -> [[c]]' which doesn't have the benefit you speak of I think
12:20:40 <Philonous> Why does cabal complain about a missing C library (udt) when I forget to mention pthread as an additional library?
12:21:03 <Daneo> Why is readFile :: FilePath -> IO String impure ? Due to the fact that the return values depend on the external file ?
12:21:15 <Philonous> Daneo:  Yes
12:21:39 <Philonous> Daneo:  The result is dependent on external factors and might change during the run time of a program
12:21:42 <Jello_Raptor> it's 'tableMap :: topRowFunc -> leftRowFunc -> internalFunc -> topLeftCell -> topRowInput -> leftRowInput -> output'
12:21:56 <Cale> Daneo: It's only impure if you think about it in terms of the resulting String. The function itself is a pure function which takes a filename, and always gives the same action for the same name.
12:21:56 <ski> yes, i figured
12:22:25 <Cale> Daneo: (it's just that executing that action may have different results each time)
12:22:55 <Daneo> Philonous: Ok, so is it simply because, as a pure function gives the same result for the same input, in this case , the FilePath could be the same but the output differs?
12:23:15 <Daneo> Cale: I see, the action is, but not the result ?
12:23:17 <ski> Jello_Raptor : which cell do you want to inspect at the end here, the bottom right one ?
12:23:21 <Cale> yeah
12:23:23 <Philonous> Daneo:  Sure, you have no way of knowing that the contents of that file won't change
12:23:25 <Jello_Raptor> ski: yup
12:23:27 <Daneo> Cale: Which makes the function impure?
12:23:34 <Jello_Raptor> ski: i'm not sure how i'd go about it your way
12:23:45 <Cale> Daneo: if it was FilePath -> String, then it would always have to produce the same resulting String for the same FilePath
12:24:12 <Daneo> Cale, Philonous: Alright, thanks. Get it I think.
12:24:15 <Cale> Daneo: which, among other troubling things, would mean that it could never reflect changes in any file, and would produce the same result on your system as mine.
12:24:30 <Philonous> Daneo:  Also, it's a bit of a conceptual thing. Accessing the file system is not, mathematically speaking, a function, that is, the result is not uniquely determined by the parameters
12:24:57 <Cale> (unless perhaps the entire filesystem were a parameter to the function :)
12:25:02 <Jello_Raptor> ski: tracing that back to the top right cell will give you an alignment
12:25:57 <ski> @let tabulate :: Ix i => (i,i) -> (i -> e) -> Array i e; tabulate ix f = array ix [(i,f i) | i <- range ix]
12:25:59 <lambdabot>  Defined.
12:26:40 <Daneo> Cale: Got it.
12:27:19 <ski> > let fib n = fibs ! n where fibs = array (0,n) [(i,if i `elem` [0,1] then i else fibs ! (i - 1) + fibs ! (i - 2)) | i <- [0 .. n]]  in  fib 12
12:27:20 <lambdabot>   144
12:27:45 <ski> > let fib n = fibs ! n where fibs = tabulate (0,n) $ \i -> if i `elem` [0,1] then i else fibs ! (i - 1) + fibs ! (i - 2)  in  fib 12
12:27:47 <lambdabot>   144
12:28:07 <ski> Jello_Raptor : this example defines an array, `fibs', in terms of itself
12:28:34 <ski> Jello_Raptor : the element `fibs ! 0' is defined to be `0', the element `fibs ! 1' is defined to be `1'
12:28:59 <ski> Jello_Raptor : for other `i', `fibs ! i' is defined to be `fibs ! (i - 1) + fibs ! (i - 2)'
12:29:17 * Jello_Raptor nods
12:29:31 <ski> Jello_Raptor : i.e., if you look up the value of, say `fibs ! 12', it will look up the value of `fibs ! 11' and the value of `fibs ! 10'
12:29:56 <ski> now, to compute the value of `fibs ! 11', it will look up (i.e. compute) the value of `fibs ! 10' and `fibs ! 9'
12:30:25 <ski> after having got the value of `fibs ! 11', it still has to look up the value of `fibs ! 10'
12:30:52 <ski> however, this has already been computed, so this is just a fetch from the array, instead of a new recursive computation
12:31:09 <ski> this way, the intermediate values (the values in the cells of the array) are *reused*
12:31:57 <Jello_Raptor> ski: but while your way is more elegant is it functionally different? with the exception of the origin, top row, and left column, each cell is defined by 'min [f diagCell,f uppercell,f leftcell]' so it'll have to compute all the cells anyway.
12:32:08 <ski> in this case, to compute `fibs ! 12', it actually has to compute all the values of `fibs ! i' for every `i' less than `12' -- but it will only compute each such value once (next time it will just reuse the computed value)
12:32:16 <Daneo> Alright, going to bed. Thanks for the guidance, see you in a few days.
12:32:21 <Daneo> Or sooner perhaps
12:32:50 <ski> Jello_Raptor : i think it depends on how you're defining `tableMap', and on how you use it (but i suspect that you don't get a similar effect)
12:33:07 * hackagebot happy 1.18.10 - Happy is a parser generator for Haskell  http://hackage.haskell.org/package/happy-1.18.10 (SimonMarlow)
12:33:46 <ski> @let arrayMemo :: Ix i => (i,i) -> (i -> e) -> (i -> e); arrayMemo ix f = (tabulate ix f !)
12:33:48 <lambdabot>  Defined.
12:34:55 <clahey> :t putStrLn
12:34:56 <lambdabot> String -> IO ()
12:35:52 <ski> hm
12:36:47 <Jello_Raptor> ski: hmm, my implementation lacks the ability to pick an arbitary element and calculate the minimum table for that element, but in generating the table each row is defined as a function of the previous row, so it builds up without duplication. (I think, i'm nto sure)
12:37:44 <ski> > let fib n = foo n where (arrayMemo (0,n) -> foo) = \i -> if i `elem` [0,1] then i else foo (i - 1) + foo (i - 2)  in  fib 12  -- perhaps not much nicer
12:37:46 <lambdabot>   144
12:38:06 <ski> Jello_Raptor : yeah, i'm not sure either
12:38:20 <Jello_Raptor> and then (because backtracking data is stored in each cell) I can ask for the alignment of the last cell, and it'll grab one path arbitrarily.
12:38:49 <ski> Jello_Raptor : it's possible that something like `tableMap', with a type like you have, is all you need to get this efficiency behaviour
12:39:23 * ski would probably have to see the code to be able to decide
12:40:21 <ski> Jello_Raptor : my main point was that, at least in more general cases (i.e. when the value of one "cell" might be defined in terms of the values of other "cells", which aren't necessarily near that cell), using an array (or possibly another intermediate data structure) can be a good idea
12:40:25 <Jello_Raptor> yeah <_< my code for that is not quite as bad as the print function but ti's close. It's mainly something i'm making to learn haskelland so that I don't have to generate these damn things manually.
12:42:22 <Jello_Raptor> ski: right, i've not yet gotten around to learning how arrays work (mostly by didn't of having other things to do) but it's on the list, especially since i'm going to refactor the code to be properly monadic.
12:44:23 <ski> Jello_Raptor : *nod* -- i'm just trying to hint that in several cases, *immutable* arrays would work just fine in Haskell, where you'd use a *mutable* array in a strict language
12:48:15 <Jello_Raptor> ski: ahh, that I know.
12:48:29 <shi> hi
12:49:16 <Eduard_Munteanu> shi: hi
12:53:14 <Clint> is there something akin to Data.Ranges.range where one end fo the range can be unbounded?
12:53:51 <neothemachine> hey, I just wanted to check if two arrays (Array Int a) are equal (same elements) but couldn't find a predefined function, is there a oneliner for that?
12:54:49 <rwbarton> (==)
12:54:53 <rwbarton> same as usual
12:55:10 <rwbarton> > listArray (0,2) [1,2,3] == listArray (0,2) [1,2,3]
12:55:12 <lambdabot>   True
12:55:13 <rwbarton> > listArray (0,2) [1,2,3] == listArray (0,2) [1,2,4]
12:55:14 <lambdabot>   False
12:55:15 <neothemachine> shit, I just realized I forgot a Eq a =>
12:55:17 <neothemachine> sorry! :D
12:55:45 <astry_> i wish you could plug arbitrary predicates into case expressions
12:58:34 <ski> Jello_Raptor : yeah, in case the elements of the array are defined independently of the other elements, it's obvious -- the trick of using a recursively defined array to encode dynamic programming might not be as obvious
12:58:38 <byorgey> astry_: you mean you want something like  if ... elseif ... elseif ... ?
13:00:10 <byorgey> astry_: note you can do   case () of { _ | condition1 -> expr1; _ | condition2 -> expr2 ... }
13:00:23 <rwbarton> don't even need the "; _"
13:00:25 <shachaf> GHC 7.6 has if | ... -> ...
13:00:31 <nand`> you can also do:  if | condition 1 -> expr; .. yeah what shachaf said
13:00:32 <byorgey> astry_: and the latest release of GHC actually has multi-way if expressions: http://www.haskell.org/ghc/docs/7.6.1/html/users_guide/syntax-extns.html#multi-way-if
13:00:45 <byorgey> rwbarton: oh, good point
13:01:05 <shachaf> Contrapuntal fugues, eh?
13:07:19 <astry_> byorgey: i mean like this: http://dpaste.com/804200/
13:08:26 <astry_> rwbarton: ^
13:08:41 <byorgey> astry_: aha, I see
13:08:51 <rwbarton> if you don't want to bind any variables you can implement constructions like this yourself
13:08:55 <shachaf> You can build a control structure like that yourself.
13:09:00 <rwbarton> @unpl (flip flip 0 . ((==) .) . mod)
13:09:00 <lambdabot> (\ j f -> (mod j f) == 0)
13:09:07 <rwbarton> wow, that was actually helpful
13:09:16 <shachaf> Is that a first for unpl?
13:09:38 <rwbarton> in fact
13:09:40 <rwbarton> @type findBy
13:09:41 <lambdabot> Not in scope: `findBy'
13:09:43 <rwbarton> hmm
13:09:49 <rwbarton> @type find
13:09:50 <lambdabot> forall a. (a -> Bool) -> [a] -> Maybe a
13:09:56 <rwbarton> @type lookupBy
13:09:57 <lambdabot> Not in scope: `lookupBy'
13:10:54 <astry_> rwbarton: you think a pluggable case is helpful?
13:11:12 <shachaf> Something like a -> (a -> b -> Bool) -> [(b,c)] -> c?
13:11:13 <rwbarton> i don't know what "pluggable" means
13:11:31 <shachaf> Well, no reason not to apply that yourself.
13:11:32 <astry_> it means you can have different things like in my paste as opposed to just "of"
13:11:41 <rwbarton> @type lookup
13:11:41 <astry_> and (==) is the same as "of"
13:11:42 <lambdabot> forall a b. (Eq a) => a -> [(a, b)] -> Maybe b
13:11:43 <shachaf> In fact I'm pretty sure I've written a function like this before.
13:12:19 <rwbarton> @let lookupBy x f [] = Nothing; lookupBy x f ((a,r):rest) | f x a = Just r | otherwise = lookupBy x f rest
13:12:20 <lambdabot>  Defined.
13:12:24 <rwbarton> @type lookupBy
13:12:25 <lambdabot> forall t t1 a. t -> (t -> t1 -> Bool) -> [(t1, a)] -> Maybe a
13:13:03 <shachaf> I think applying f to x yourself at the place you call lookupBy is probably more useful.
13:13:09 <shachaf> @let (==>) = (,)
13:13:11 <lambdabot>  Defined.
13:13:15 <rwbarton> @type lookupBy ?path endsWith [(".tif", ?handleImage), (".mkv", ?handleVideo), (".flac", ?handleMusic)]
13:13:16 <lambdabot> Not in scope: `endsWith'
13:13:24 <astry_> i don't see how lookupBy helps
13:13:36 <shachaf> @type lookupBy ?path isSuffixOf [(".tif", ?handleImage), (".mkv", ?handleVideo), (".flac", ?handleMusic)]
13:13:37 <lambdabot> forall a. (?handleMusic::a, ?handleVideo::a, ?handleImage::a, ?path::[Char]) => Maybe a
13:13:38 <rwbarton> @type lookupBy ?path isSuffixOf [(".tif", ?handleImage), (".mkv", ?handleVideo), (".flac", ?handleMusic)]
13:13:38 <lambdabot> forall a. (?handleMusic::a, ?handleVideo::a, ?handleImage::a, ?path::[Char]) => Maybe a
13:14:22 <rwbarton> isn't it just find then
13:14:34 <astry_> that doesn't ensure exhaustive patterns
13:14:35 <shachaf> find doesn't take tuples.
13:14:40 <astry_> and it doesn't allow bindings
13:14:40 <rwbarton> oh right
13:14:54 <shachaf> I think something like "(a -> Bool) -> [(a,b)] -> b -> b" is possibly more useful.
13:14:57 <rwbarton> well yes, bindings are more difficult
13:15:06 <astry_> impossible?
13:15:17 <rwbarton> your example with bindings doesn't make any sense
13:15:18 <shachaf> astry_: you can use view patterns for something like this.
13:15:40 <astry_> why does it not make sense rwbarton
13:15:41 <rwbarton> or wait, is that even a binding
13:15:48 <astry_> yes
13:15:49 <astry_> it is
13:16:04 <rwbarton> it doesn't make sense at all
13:16:12 <astry_> i know, i made an error in it
13:16:23 <rwbarton> well how about an example that does make sense :)
13:16:29 <Philonous> Is there a way to tell c2hs not to convert all pointer arguments to "Ptr ()" ?
13:16:41 <astry_> case x (flip flip 0 . ((==) .) . mod) y -> putStrLn "least divisor is " ++ (show y)
13:16:56 <astry_> i just deleted the first case
13:17:00 <astry_> now it makes sense
13:17:09 <rwbarton> that's a lot different than the other examples
13:17:17 <rwbarton> how do you know you're not getting the greatest divisor
13:17:41 <astry_> case x (flip flip 0 . ((==) .) . mod) y -> putStrLn "a divisor is " ++ (show y)
13:18:08 * hackagebot wtk-gtk 0.2 - GTK tools within Wojcik Tool Kit  http://hackage.haskell.org/package/wtk-gtk-0.2 (BartoszWojcik)
13:18:29 <shachaf> @let foo :: (a -> Bool) -> [(a,b)] -> b -> b; foo f [] d = d; foo f ((x,v):xvs) d | f x = v | otherwise = foo f xvs d
13:18:30 <lambdabot>  Defined.
13:20:00 <shachaf> @ty foo (`isSuffixOf` path) [".tif" ==> ?handleImage, ".mkv", ==> ?handleVideo, ".flac", ==> ?handleMusic] ?handleUnknown
13:20:01 <lambdabot>     Ambiguous occurrence `==>'
13:20:01 <lambdabot>     It could refer to either `L.==>', defined at <local>:6:0
13:20:01 <lambdabot>                           or `Test.QuickCheck.==>', imported from Test.QuickCheck
13:20:07 <shachaf> Bah, quickcheck.
13:20:19 <shachaf> @let (-->) = (,)
13:20:21 <lambdabot>  Defined.
13:20:25 <rwbarton> what you really want to do is generate all the cases 2 -> putStrLn "least divisor is " ++ (show 2), 3 -> putStrLn "least divisor is " ++ (show 3) ...
13:20:31 <shachaf> @ty foo (`isSuffixOf` path) [".tif" --> ?handleImage, ".mkv", --> ?handleVideo, ".flac", --> ?handleMusic] ?handleUnknown
13:20:32 <lambdabot> parse error (possibly incorrect indentation)
13:20:40 <shachaf> Blah.
13:20:51 * shachaf wonders if that's a lambdabot expression verifier bug.
13:20:55 <rwbarton> you have two extra ,s
13:20:57 <shachaf> @let (===>) = (,)
13:20:58 <lambdabot>  Defined.
13:21:04 <shachaf> Oh.
13:21:10 <shachaf> @ty foo (`isSuffixOf` path) [".tif" --> ?handleImage, ".mkv" --> ?handleVideo, ".flac" --> ?handleMusic] ?handleUnknown
13:21:11 <lambdabot> parse error (possibly incorrect indentation)
13:21:15 <rwbarton> also i like the way lambdabot suggests incorrect indentation
13:21:18 <Sharyari_> I need a big list of primes to be sent as an argument to a function. I have a function generating prime number. But I don't want to generate all my primes every time, so how can I save the generated list?
13:21:22 <rwbarton> okay that might be a bug :)
13:21:22 <shachaf> @ty foo (`isSuffixOf` path) [".tif" ===> ?handleImage, ".mkv" ===> ?handleVideo, ".flac" ===> ?handleMusic] ?handleUnknown
13:21:23 <lambdabot>     Couldn't match expected type `[a]'
13:21:23 <lambdabot>            against inferred type `Graph -> Vertex -> Vertex -> Bool'
13:21:23 <lambdabot>     In the second argument of `isSuffixOf', namely `path'
13:21:33 <shachaf> @ty foo (`isSuffixOf` ?path) [".tif" ===> ?handleImage, ".mkv" ===> ?handleVideo, ".flac" ===> ?handleMusic] ?handleUnknown
13:21:34 <lambdabot> forall b. (?handleUnknown::b, ?handleMusic::b, ?handleVideo::b, ?handleImage::b, ?path::[Char]) => b
13:21:52 <shachaf> There we go. Enough bot spam.
13:21:54 <rwbarton> there's probably a haskellwiki page with this function
13:22:05 <shachaf> I think your use of isSuffixOf had an argument order bug. :-)
13:22:15 <shachaf> Which is another reason to do the application at the top.
13:22:21 <rwbarton> yes
13:22:25 <rwbarton> true
13:22:47 <rwbarton> Now abuse do notation for the cases!!
13:22:55 <shachaf> @slap rwbarton
13:22:55 * lambdabot orders her trained monkeys to punch rwbarton
13:23:09 <astry_> rwbarton: http://dpaste.com/804203/
13:23:14 <shachaf> Hmm, can you do that?
13:23:35 <rwbarton> line 19 is in serious logic programming territory
13:23:53 <shachaf> Or a special kind of view pattern.
13:24:05 <rwbarton> combined with endsWith, it's very special
13:24:07 <shachaf> Well, OK, that would need to be a very special kind of view pattern, with the variable in the middle.
13:24:12 <astry_> rwbarton: why is it?
13:24:24 <shachaf> astry_: Try writing out what that would desugar into.
13:24:39 <rwbarton> you're basically asking it to solve an equation like stuff ++ "." ++ ext ++ ".bak" == path
13:24:49 <astry_> rwbarton: yes
13:24:55 <rwbarton> that is what logic programming languages do
13:25:08 <rwbarton> note for example the solution might not be unique
13:25:27 <astry_> rwbarton: yeah, it could be non-unique.
13:25:34 <shachaf> rwbarton: Another reason to use a monad like you suggested!
13:26:30 <astry_>     "." ++ [a, b, c] ++ ".bak" -> documentHandler $ '.':a:b:c
13:26:41 <astry_> here you go
13:26:44 <astry_> unique now
13:27:16 <astry_> it's broken syntax
13:27:19 <astry_> but at least it's unique
13:27:39 <shachaf> astry_: What you're asking for now seems like a lot more than simple syntax sugar.
13:27:59 <shachaf> @let bar :: (a -> Bool) -> [(a,b)] -> b -> b; bar f xvs d = foldr (\(x,v) n -> if f x then v else n) d xvs
13:28:00 <lambdabot>  Defined.
13:28:13 <astry_> that's just who i am
13:28:44 <astry_> always expecting more
13:28:55 <shachaf> I'm not sure what you're expecting, though.
13:29:03 <shachaf> I mean, wht do you want your snippets to compile into?
13:29:13 <rwbarton> you might like Curry
13:29:26 <astry_> rwbarton: why?
13:29:27 <rwbarton> a Haskell-like functional logic programming language
13:29:32 <rwbarton> "last l | xs++[e] =:= l = e where xs,e free"
13:29:35 <rwbarton> from its wikipedia page
13:29:48 <astry_> no idea what that would do
13:30:02 <rwbarton> you can also try to do logic programming in Haskell but it doesn't come out-of-the-box
13:31:51 <astry_> rwbarton: i'm not really steering this toward logic programming
13:32:02 <gensymv> hello can someone recommend me a good library for drawing 3d images? i have been using gd for a while, but as far as i am concerned it has no built in support for the third dimension.
13:32:02 <astry_> rwbarton: just more flexible predicates
13:32:11 <rwbarton> you are though
13:32:19 <astry_> rwbarton: yeah, i know
13:32:21 <jnhnum1> so I've been wanting to use unsafePerformIO recently and I don't really see any recourse - I want to use hmatrix (http://hackage.haskell.org/packages/archive/hmatrix/latest/doc/html/Numeric-GSL-Minimization.html#v:minimize) to minimize a function, but I also want to see how many times the minimization method calls the objective function (it's for an assignment)
13:32:22 <rwbarton> I agree with shachaf, if this is just syntactic sugar, write the desugared form
13:32:40 <jnhnum1> it seems like the real problem is that the library function is not monadic, but there are a lot of functions like this
13:32:59 <astry_> rwbarton: but only as a necessity not as a focus
13:33:22 <jnhnum1> is it actually considered bad to use unsafePerformIO if logically you still have a pure function
13:33:23 <jnhnum1> ?
13:33:47 <shachaf> If it's really a function, using unsafePerformIO as an implementation detail is OK.
13:33:53 <astry_> why not use traceShow
13:33:56 <shachaf> But many things that you think are really functions aren't really functions.
13:34:02 <rwbarton> jnhnum1, in principle, what you are trying to do makes no sense
13:34:11 <shachaf> Oh, I missed the context.
13:34:30 <rwbarton> because the compiler is free to duplicate calls to the objective function, or remove duplicate calls
13:34:32 <shachaf> That's not a function. :-)
13:35:14 <jnhnum1> rwbarton: I want to see how many calls are actually made after the compiler duplicates or removes calls
13:35:30 <rwbarton> if you are specifically trying to observe the operational behavior then unsafePerformIO is IMO entirely appropriate
13:35:54 <rwbarton> short of rewriting minimize to work in a monad
13:36:00 <benmachine> it's a bit strange
13:36:26 <jnhnum1> oh ok
13:36:32 <jnhnum1> benmachine: are you talking to me?
13:36:39 <benmachine> jnhnum1: well, about your issue
13:36:56 <rwbarton> how does this work anyways, I see it uses ffi...
13:37:10 <benmachine> I think in a real program, unsafePerformIO would not be acceptable, and you'd say that "the API doesn't support me doing this"
13:37:14 <benmachine> for an assignment, I'ld allow it
13:38:06 <jnhnum1> rwbarton: this uses GSL as a backend, so essentially it is a wrapper around a bunch of super efficient C code.
13:38:07 <rwbarton> I guess you could change the imported type of c_minimize to c_minimize:: CInt -> FunPtr (CInt -> Ptr Double -> IO Double) -> Double -> CInt -> TVVM
13:38:23 <rwbarton> and then adjust whatever needs fixing in minimize and minimizeV
13:38:31 <jnhnum1> the assignment actually doesn't mandate using haskell, I'm just trying to stick to my academic new year's resolution of using haskell as much as possible
13:38:58 <rwbarton> given that your function is only called from C I guess the unsafePerformIO approach is pretty safe...?
13:39:26 <shachaf> If unsafePerformIO is too safe for your taste, you can always switch to unsafeDupablePerformIO
13:40:14 <rwbarton> well aside from the fact that minimizeV then uses unsafePerformIO too
13:40:26 <Ferdirand> i've never touched unsafePerformIO but i suddently feel an irrepresible urge to test its semantics
13:40:38 <benmachine> shachaf: is that like inlinePerformIO
13:40:39 <shachaf> "its semantics"
13:40:56 <shachaf> benmachine: I think inlinePerformIO is one step further.
13:41:09 <benmachine> rwbarton: sure, but that *is* pure, what jnhnum1 wants isn't
13:41:18 <shachaf> But unsafeDupablePerformIO doesn't have the noDuplicate call, which means that multiple threads might be evaluating it at the same time.
13:41:27 <benmachine> oh right
13:41:27 <benmachine> neat
13:41:47 <SLi> unsafePerformIO is a function I *think* I understand and wait (not even dreading :-) for the day I actually need it for something. To me it seems like an elegant hack, if there is such a thing.
13:42:08 <t7> not elegant
13:42:23 <rwbarton> benmachine: I mean if you pass in an argument to minimize that uses unsafePerformIO and then wrap a (return $!) or something around the result of minimize, you "should" get the same result as if you did it the proper way
13:42:28 <astry_> rwbarton: http://dpaste.com/804213/
13:42:33 <t7> hack for lazy people with poor design skills
13:42:36 <SLi> I think it is quite elegant.
13:42:42 <rwbarton> astry_: yes, line 40 is the problem :)
13:42:56 <astry_> yeah
13:42:58 <rwbarton> we gave you an approach for the others
13:43:00 <astry_> it's your job
13:43:02 <astry_> :)
13:43:05 <rwbarton> nope.
13:43:11 <astry_> you're the logic programmer here
13:43:12 <jnhnum1> isn't the problem that libraries aren't written sufficiently generically?
13:43:15 <astry_> stop being a bum
13:43:18 <astry_> ;)
13:43:30 <rwbarton> you're the one who wants the feature, but you can't even tell me what it should do
13:43:39 <rwbarton> so it's not surprising the feature doesn't exist :)
13:43:45 <t7> SLi explain
13:43:50 <astry_> i can give you some input-output pairs
13:44:00 <shachaf> rwbarton.conal.moed
13:44:31 <astry_> rwbarton: but are you really serious when you say you don't know what the example above line 40 should do?
13:44:48 <rwbarton> of course IN THIS CASE I know
13:44:55 <astry_> yeah
13:44:59 <rwbarton> that uses very special facts about e.g. (++)
13:45:04 <astry_> yes
13:45:15 <SLi> t7, well, for things like FFI you obviously are going to need it if you want to use impure C code and you don't want to do everything in the IO monad. And I think that some optimizations may plausibly require doing unsafe things and declaring them safe once you are sure that the result is pure. For example, the code in the explicit-sharing package has pretty optimized code that does that kind of stuff (which I unfortunately ...
13:45:17 <rwbarton> as a general syntactic construction it makes no sense
13:45:21 <SLi> ... failed to understand to the extent that I never managed to write a program that uses the newest version, since the tutorial on the webs is for the previous version ;)
13:45:36 <SLi> t7, but I think FFI would be the main use.
13:45:46 <astry_> well, maybe there's something else which makes sense?
13:45:55 <astry_> and functionally does the same thing?
13:46:03 <SLi> t7, specifically if you are interfacing to C code which was not designed as a pure, effect-free API.
13:46:24 <shachaf> astry_: That code looks so specialized that I'd write it by hand rather than build support for some generalization I don't understand into the compiler.
13:46:30 <astry_> the idea is to catch the case when a string ends with a dot, 3 characters, a dot, and the letters bak
13:46:42 <SLi> t7, then it will still make a lot of sense to wrap it in a layer of code that is pure in its inputs and outputs and run the computation with unsafePerformIO.
13:46:44 <astry_> shachaf: that's good for you
13:46:56 <SLi> It's a hack, but one I consider elegant for a hack ;)
13:47:18 <Lutin`> astry_: Then do '.' : a : b : c : ".bak"
13:47:24 <rwbarton> case x of (takeFromEnd 8 -> ['.', a, b, c, '.', 'b', 'a', 'k']) -> doSomethingWith [a, b, c]
13:47:43 <rwbarton> right, or that
13:47:48 <SLi> t7, I think it's conceptually the Obviously Right(tm) way to handle the real-world problem it solves.
13:47:51 <shachaf> rwbarton: Do you have a sneaky implementation of takeFromEnd?
13:47:55 <astry_> rwbarton: that uses that one extension doesn't it
13:47:57 <rwbarton> I knew you would ask that
13:47:57 <astry_> what's the name
13:48:00 <rwbarton> astry_, yes, ViewPatterns
13:48:08 <astry_> right view patterns
13:48:21 <rwbarton> shachaf, not on me :)
13:48:22 <int-e> reverse ".bak" `isPrefixOf` reverse fileName
13:48:42 * int-e grins foolishly - isSuffixOf exists.
13:51:15 <rwbarton> shachaf: by which I mean you would do the same thing, but the zipWith analogue doesn't already exist
13:51:18 <shachaf> rwbarton: You should be able to use a similar trick where you drop n from the list and then pattern-match against the dropNed list to see when to start taking.
13:51:26 <shachaf> Right.
13:51:46 <astry_> hey guys, btw, i have a gtk question
13:51:50 <shachaf> It's not exactly a zipWith.
13:52:16 <ew0> hey, I want to do a foldr in a list with Maybes
13:52:18 <shachaf> Better write splitAtFromEnd instead...
13:52:27 <ew0> and I want the fold to give up  in the first Nothing
13:52:41 <astry_> i have a window and inside it an image element of a specific size. when i make the window bigger, a callback makes that element fill up the window. but there's no way to make the window smaller. how can i go about this?
13:52:47 <ew0> is there a foldrMaybe or something like that?
13:53:30 <neothemachine> before I'll dive into template haskell (or any alternative?), can you tell me if the following is possible with it? basically, I have a 'type X a b = (...->..,...->..)' which is a tuple of functions, and what I want is to generate a data type from it, so I would need to inspect the function signatures
13:53:43 <Mon_Ouie> ew0: There's foldM
13:53:55 <ew0> which is in with package?
13:53:55 <shachaf> foldM probably doesn't do what ew0 wants.
13:53:59 <ew0> which
13:54:02 <copumpkin> > let zup [] ys = ys; zup xs [] = xs; zup (x:xs) (y:ys) = zup xs ys; lastFew n xs = zup xs (drop n xs) in lastFew 5 [1..]
13:54:05 <lambdabot>   mueval-core: Time limit exceeded
13:54:08 <ew0> uhm
13:54:16 <copumpkin> > let zup [] ys = ys; zup xs [] = xs; zup (x:xs) (y:ys) = zup xs ys; lastFew n xs = zup xs (drop n xs) in take 100 (lastFew 5 [1..])
13:54:20 <lambdabot>   mueval-core: Time limit exceeded
13:54:38 <copumpkin> whoops :)
13:54:42 <shachaf> > let zup [] ys = ys; zup xs [] = xs; zup (x:xs) (y:ys) = zup xs ys; lastFew n xs = zup xs (drop n xs) in lastFew 5 [1..20]
13:54:43 <lambdabot>   [16,17,18,19,20]
13:55:01 <copumpkin> why isn't it giving me the last few elements of that infinite list??
13:55:12 <shachaf> copumpkin: Give it time!
13:55:15 <copumpkin> k
13:55:17 * copumpkin waits
13:55:23 <benmachine> > time
13:55:24 <lambdabot>   Not in scope: `time'
13:55:27 <benmachine> :(
13:55:38 <shachaf> copumpkin: I think the biggest number is 83.
13:55:38 <rwbarton> zip zap zup
13:55:40 <copumpkin> > let zup [] ys = ys; zup xs [] = xs; zup (x:xs) (y:ys) = zup xs ys; lastFew n xs = zup xs (drop n xs) in lastFew 5 cake
13:55:42 <lambdabot>   ["Injector needle driver.","Injector needle gun.","Cranial caps.","And it c...
13:55:45 <shachaf> So it might take a while.
13:55:49 <benmachine> shachaf: 45,000,000,000
13:55:54 <shachaf> benmachine wins.
13:55:56 <copumpkin> I always liked that approach to grabbing the last few
13:56:08 <shachaf> copumpkin: Can you write a splitAtFromEnd now?
13:56:11 <n-dolio> 24 is the biggest number.
13:56:16 <n-dolio> http://www.youtube.com/watch?v=f3ek85X2uOE
13:56:18 <copumpkin> shachaf: what's that do?
13:56:28 <shachaf> copumpkin: Combination takeFromEnd and dropFromEnd.
13:56:31 <shachaf> Where takeFromEnd = lastFew
13:56:34 <shachaf> @where sneaky
13:56:34 <lambdabot> dropFromEnd n xs = zipWith const xs (drop n xs)
13:56:38 <benmachine> shachaf: mathematicians suspect there may be even larger numbers
13:57:35 <shachaf> benmachine: Oh, that's LAY, isn't it.
13:57:43 <benmachine> shachaf: yes :P
13:57:55 <benmachine> I can't still find it on youtube, sadly
13:58:02 <benmachine> I have the DVD somewhere
13:58:07 * shachaf has the DVD too.
13:58:17 <shachaf> It used to be online.
13:58:27 <benmachine> bits of it are
13:58:37 <shachaf> I mean Maths used to be online.
13:59:04 <benmachine> bits of it are :P
13:59:08 <benmachine> including a, um, spanish dub
13:59:09 <benmachine> apparently
14:00:19 <lightquake> is there a way to alias contexts?
14:00:39 <lightquake> so, for example, if i have (Foo t, Bar t, Baz t, Quux t), i'd like to be able to write it as FBBQ t
14:00:48 <shachaf> Yep.
14:00:55 <shachaf> type FBBQ t = (Foo t, Bar t, Baz t, Quux t)
14:01:02 <benmachine> that's with ConstraintKinds
14:01:02 <lightquake> ... that works?
14:01:04 <lightquake> oh
14:01:11 <shachaf> Since ConstraintKinds, yes.
14:01:15 <benmachine> there's another vanilla way that isn't so good
14:01:37 * shachaf hopes benmachine doesn't mean class (Foo t, Bar t, Baz t, Quux t) => FBBQ t
14:01:49 <benmachine> shachaf: you hope wrong!!
14:01:50 <MostAwesomeDude> ^^ that's what I thought of.
14:01:54 <benmachine> even though that doesn't grammar
14:01:55 <benmachine> but yes that works
14:02:00 <benmachine> and then a single global instance
14:02:19 <benmachine> (aside: shouldn't ConstraintKinds really be ConstraintKind? there's only one of them, surely)
14:02:27 <shachaf> Isn't that undecidable?
14:02:34 <benmachine> eerm
14:02:36 <benmachine> pass
14:02:43 <benmachine> I don't think so?
14:02:46 <shachaf> I mean the global instance.
14:02:53 <shachaf> By "undecidable" I mean "required UndecidableInstances"
14:03:00 <benmachine> yes I got that
14:03:03 <benmachine> let me check
14:03:27 <benmachine> it's flexible, I think
14:03:40 <shachaf> That's what my ghci says.
14:03:41 <shachaf> Constraint is no smaller than the instance head
14:03:41 <lightquake> what exactly is the difference between  context and a constraint?
14:03:44 <lightquake> i've seen both
14:04:18 <shachaf> lightquake: I don't think people are very precise with that terminology.
14:04:27 <rwbarton> it does require the extension but in practice it is decidable
14:04:32 <benmachine> I think a context is a tuple of constraints
14:04:34 <Eduard_Munteanu> I think a context is made up of multiple constraints.
14:04:36 <rwbarton> unless you do something silly and make a loop of them
14:04:54 <Eduard_Munteanu> Or what benmachine says :)
14:04:55 <lightquake> ah, ok
14:04:57 <benmachine> rwbarton: yes, well, working out if you've made a loop of them is probably undecidable :P
14:04:58 <shachaf> Eduard_Munteanu: Aren't multiple constraints a constraint?
14:05:11 <benmachine> shachaf: actually, you're probably right
14:05:13 <Eduard_Munteanu> Hm, maybe, dunno.
14:05:19 <shachaf> (,) :: Constraint -> Constraint -> Constraint
14:05:33 <benmachine> anyway, I concede defeat, the ConstraintKinds way is unequivocally better
14:05:38 <benmachine> unless you only have old GHC
14:05:52 <Eduard_Munteanu> Maybe the context refers to the form constraints take in types.
14:11:29 <Ralith> Is there a common function that takes a null pointer and returns either Just aNonNullPtr or Nothing?
14:11:47 <shachaf> You mean a possibly-null pointer?
14:11:51 <EvanR> takes a possibly null pointer
14:12:08 <Ralith> er
14:12:09 <Ralith> yes
14:12:33 <shachaf> Where aNonNullPtr is the same as the argument you passed?
14:12:43 <Ralith> yep.
14:12:46 <shachaf> I don't think there's a NonNullPtr type.
14:12:54 <Ralith> I didn't ask for one!
14:12:59 <shachaf> In that case the binding is kind of pointless -- you could just use a Bool.
14:13:02 <shachaf> Although Bool is the devil.
14:13:05 <Ralith> huh?
14:13:08 <hpaste> keep_learning annotated “Putting values in list of MVar ” with “Putting values in list of MVar  (annotation) (annotation) (annotation) (annotation)” at http://hpaste.org/75068#a75078
14:13:17 <Ralith> what do you mean, "the binding is kind of pointless"
14:13:35 <Ralith> I have a foreign function which returns null on failure or a valid pointer otherwise, and I want to make that slightly nicer to use.
14:13:39 <shachaf> Ralith: case foo x of Just x' -> ...; Nothing -> ...
14:13:39 <luite> Ralith: there are a few in Foreign.Marshal.Utils that compare to nullPtr
14:13:49 <Ralith> shachaf: what?
14:13:50 <luite> maybeWith, maybePeek etc
14:14:15 <Jeanne-Kamikaze> there's nullPtr and Ptr a is Eq
14:14:23 <Ralith> luite: not quite what I want
14:14:24 <rwbarton> but not so nice to use that it doesn't return a Ptr at all ;)
14:14:33 <keep_learning> Could some one please tell me if these both function works the same way ( http://hpaste.org/75068 )
14:14:41 <Ralith> Jeanne-Kamikaze: yes, I know I can write it myself, it's trivial. I want to know if there's one already-written I can use.
14:15:01 <Ralith> idg why this is confusing
14:15:44 <Ralith> does there exist a common function :: Ptr a -> Maybe (Ptr a) which behaves as \x -> if x == nullPtr then Nothing else Just x
14:15:52 <EvanR> i dont think putting maybe on there makes it nicer
14:15:56 <Ralith> I do
14:16:11 <Jeanne-Kamikaze> why ?
14:16:22 <EvanR> however what would be nice is a NonNullPtr type
14:16:29 <shachaf> Ralith: I don't think so.
14:16:32 <Ralith> because then I can know that when I get a pointer from the function it's valid.
14:16:34 <Ralith> shachaf: okay, thanks.
14:16:36 <EvanR> then Maybe NonNullPtr
14:16:46 <rwbarton> keep_learning: forkIO (forkIO a) should be the same as forkIO a, yes
14:16:49 <shachaf> Ralith: But given that you already have "x", a bool would serve the same purpose.
14:16:49 <rwbarton> just more convoluted
14:16:52 <Ralith> EvanR: what would be nice would be dependent typing, but we don't have that.
14:16:56 <Ralith> shachaf: what purpose?
14:17:16 <shachaf> case isNullPtr x of False -> ...; True -> ...
14:17:18 <EvanR> i suggested a wrapper, but also a non null ptr is not guaranteed to be 'valid'
14:17:30 <shachaf> case yourFunction x of Just x' -> ...; Nothing -> ...
14:17:31 <keep_learning> rwbarton, Thank you !
14:17:33 <EvanR> if isNullPtr x then foo else bar
14:17:47 <Ralith> shachaf: yes, I'm aware that it's trivial to inline; I wanted to know if yourFunctoin existed.
14:18:20 <shachaf> Ralith: The point is that you don't really get any benefits from the Just/Nothing as opposed to False/True.
14:18:30 <rwbarton> shachaf: he wants to define whatever = yourFunction . c_whatever so that you can't accidentally use a null pointer returned from c_whatever
14:18:35 <rwbarton> or fmap yourFunction
14:18:39 <Ralith> rwbarton: thank you.
14:18:42 <shachaf> Doesn't matter, anyway. It doesn't exist but you can make it.
14:18:42 <rwbarton> (caleskell to the rescue?!)
14:18:44 * Ralith had assumed this was obvious
14:18:45 <EvanR> you want a NonNullPtr newtype
14:19:02 <shachaf> Ah, OK.
14:19:12 <Ralith> shachaf: yes, but I always feel silly making something and then discovering that it's a wheel reinvention.
14:19:20 <Ralith> so I try to check if it's a commonly applicable thing like that.
14:19:26 <EvanR> sometimes theres a reason it doesnt exist yet
14:19:33 <EvanR> sometimes
14:19:46 <Philonous> That reason mostly turns out to be limited developer time
14:19:55 <Ralith> indeed
14:20:14 <Philonous> Even if it's ill-adviced, with enough time, somebody will implement it
14:20:15 <EvanR> no but theres so many library functions in these web libraries that someone thought would be useful but arent
14:20:21 <EvanR> or are harmful
14:21:28 <Ralith> in this case, I suspect it's a combination of 'short enough to inline without much effort' and 'not often needed'
14:23:49 <EvanR> Ralith: map the pointer to Maybe RegularType instead of Just (Ptr Foo)
14:23:56 <Ralith> no.
14:24:01 <EvanR> ok :(
14:24:39 <parcs`> you can do fmap yourFunction (c_whatever <$ guard (c_whatever /= nullPtr))
14:24:54 <Ralith> ..what for?
14:25:17 <parcs`> for not being able to accidentally use a null pointer return from c_whatever
14:25:46 <Ralith> oh, we've been using 'yourFunction' to refer to the function :: Ptr a -> Maybe (Ptr a)
14:25:52 <lpvb> real world haskell is soo boring :(
14:26:02 <lpvb> can't seem to focus on it, while I breezed through lyah
14:26:30 <Ralith> parcs`: as rwbarton observed, that doesn't serve the usecase, but it's an interesting snippet nonetheless.
14:26:31 <parcs`> so skip the boring ports
14:26:33 <parcs`> parts
14:26:49 <lpvb> I think it's the way he does top-down design
14:27:01 <lpvb> I have to get to the end of the chapter to have a working program
14:33:10 * hackagebot happstack-server 7.0.5 - Web related tools and services.  http://hackage.haskell.org/package/happstack-server-7.0.5 (JeremyShaw)
14:33:21 <ew0> Stack space overflow: current size 8388608 bytes.
14:34:09 <EvanR> ew0: memory leak
14:34:16 <EvanR> :(
14:34:30 <ew0> how's it possible in haskell?
14:35:10 <NihilistDandy> So I was reading a couple of articles today (http://matt.might.net/articles/implementing-exceptions/ and http://okmij.org/ftp/continuations/against-callcc.html) and I became curious about call/ec. I understand that Control.Monad.Cont implements callCC to provide escape continuations, but I don't know enough about the implementation to know if this gets around the issues that Matt and Oleg mention
14:35:10 <lambdabot> NihilistDandy: You have 1 new message. '/msg lambdabot @messages' to read it.
14:36:03 <Puffton> Hi, Haskell kings!
14:36:31 <Ar83s> hello
14:37:11 <tswett> Ahoy.
14:37:14 <EvanR> ew0: your is doing something inefficiently and youre processing a lot of data, or something
14:37:20 <EvanR> uses too much memory in the intermediate term
14:37:33 <ew0> I'm processing a graph with 150.000 nodes
14:37:36 <EvanR> your code*
14:37:41 <EvanR> 150k
14:37:47 <ew0> yeah
14:38:00 <EvanR> nothing ridiculous about that, but you gotta be careful to right code that doesnt blow up due to laziness
14:38:05 <EvanR> write*
14:38:41 <EvanR> ew0: are you reading the data from a file?
14:38:49 <Ar83s> how can i make my own programming language in Haskell??
14:39:20 <EvanR> Ar83s: write yourself http://en.wikibooks.org/wiki/Write_Yourself_a_Scheme_in_48_Hours
14:40:07 <OceanSpray> GHC 7.6 still hasn't hit archlinux repos
14:40:26 <OceanSpray> who here is responsible for that kind of stuff?
14:40:39 <tswett> I now have a "replace" function for lists.  replace last 'x' "referee" === "referex".  It does exactly what you would expect it to do, given that example.
14:41:00 <ew0> yes
14:41:05 <Puffton> I'm new to Haskell, and would really appreciate some input in general on my Haskell code: http://pastebin.com/zWagHMB3
14:41:11 <applicative> it's easy enough to install it yourself OceanSpray .
14:41:12 <maukd> The paste zWagHMB3 has been copied to http://hpaste.org/75083
14:41:18 <Puffton> i.e. does it look all crazy, ugly.. should I avoid anything I'm doing etc.
14:41:19 <parcs`> Ar83s: very carefully
14:41:26 <ew0> yes I am. I can't manage to increase stack size
14:41:39 <ew0> ghc Main.hs -O2 +RTS -K1G -RTS -fforce-recomp
14:41:50 <shachaf> Puffton: maukd's link has a lot of great feedback. :-)
14:41:51 <ew0> and still 8 mega bytes only
14:41:57 <shachaf> ew0: +RTS is given to your program, not to GHC>
14:42:00 <applicative> Puffton: note the advice given by hlint on the hpaste copy
14:42:06 <applicative> oh as shachaf says
14:42:25 <Puffton> oh, cool
14:42:26 <NihilistDandy> What they all said
14:42:32 <Puffton> like JSLint
14:42:37 <ew0> uhm
14:42:40 <EvanR> ew0: you shouldnt have to increase the stack size
14:42:40 <parcs`> OceanSpray: http://www.haskell.org/mailman/listinfo/arch-haskell
14:42:41 <Puffton> but for haskell of course
14:42:49 <EvanR> ew0: you probably need to load your data using ByteString instead of String
14:43:25 <ew0> ow yeah
14:43:27 <ew0> now it is running
14:43:29 <ew0> thanks !
14:43:37 <EvanR> lol you fixed it that fast?
14:43:51 <ew0> No, I put it tu ron
14:43:54 <ew0> run*
14:44:08 <EvanR> oh, well youre just going to run out of more space
14:44:38 <EvanR> load the file using ByteString then split it up and stuff with bytestring functions
14:45:02 <ew0> uhm
14:45:12 <ew0> care to point me to the docs?
14:45:21 <EvanR> Data.ByteString on hackage
14:45:35 <ew0> ok
14:46:05 <ew0> what is happening ?
14:46:13 <ew0> I mean, with my code
14:46:34 <EvanR> if you load a large file with String, which is a linked list of characters, then process it, you get huge thunks
14:46:48 <EvanR> that is, if you use the wrong functions on it
14:46:56 <EvanR> usually you avoid all that by using string bytestring
14:47:00 <EvanR> ... strict bytestring
14:47:31 <shachaf> EvanR: String isn't comparable to ByteString.
14:47:43 <shachaf> Compare String to Text or ByteString to [Word8].
14:48:03 <EvanR> hes using String, you should be using ByteString
14:48:20 <lpvb> what's are the pros/cons of binary vs cereal?
14:48:50 <ew0> I c
14:49:06 <EvanR> for loading data from large files
14:49:11 <ew0> But I already was reading the whole file
14:49:14 <ew0> and it was fine
14:49:35 <EvanR> you can read the whole file into a String but as soon as you try to do anything thats not a streamable operation, it will blow up
14:49:47 <shachaf> Puffton: Please write more type signatures. :-(
14:50:05 <ew0> UHm, atualy, I'm using Parsec
14:50:10 <ew0> actually
14:50:18 <ew0> and Parsec is giving me my data
14:50:28 <ew0> (just forgout about that)
14:50:29 <EvanR> in that case i dont know
14:50:46 <ew0> maybe I'm doing something noobish
14:50:49 <Puffton> shachaf, ah yes, maybe a good habit is to always do it?
14:51:02 <Puffton> in my assignment, only some functions were specified in detail to have certain signatures
14:51:13 <Puffton> so I only specified them explicitly
14:51:40 <ew0> can it be a foldr?
14:51:45 <ew0> I just added a huge foldr
14:51:59 <hpaste> “a few changes” annotated “pastebin.com/zWagHMB3” with “pastebin.com/zWagHMB3 (annotation)” at http://hpaste.org/75083#a75084
14:52:05 <EvanR> depends on what youre doing
14:52:12 <ew0> joining graphs
14:52:29 <EvanR> could be foldr
14:52:50 <ew0> should I try a foldl  or something else?
14:53:04 <EvanR> try foldl'
14:55:16 <Puffton> Ah, cool
14:55:27 <Puffton> I didn't know it was that easy to add new types
14:55:45 <shachaf> Puffton: You have one right there!
14:55:55 <shachaf> In general you should avoid using Strings for things like that.
14:56:42 <Puffton> Why does it derive from Eq/Read too?
14:56:52 <shachaf> It doesn't "derive from" anything.
14:57:02 <Puffton> deriving(Show,Eq,Read) it says? :/
14:57:09 <shachaf> GHC derives instances for those classes.
14:57:21 <shachaf> Do you know how type classes work? If not, you should probably just ignore that.
14:57:47 <shachaf> "data Foo = ... deriving (Eq)" means that GHC generates code that lets you do (==) on Foo values.
14:58:21 <Puffton> yeah, that was what I imagined
14:58:29 <applicative> Puffton: if you prefer you can write seqName (MolSeq n _ _) = n   instead of using the record business  seqName MolSeq {name = n} = n
14:58:52 <shachaf> applicative: That seems strictly worse to me.
14:59:04 <shachaf> Of course, even better is the fact that the function seqName was autogenerated for you.
14:59:07 <Puffton> applicative, oh, yeah I was looking for that for some more complex scenarios. That's exactly how it works in Prolog
14:59:09 <shachaf> It's called "name", and it's already there.
14:59:26 <applicative> I was just telling him about syntax
14:59:40 <applicative> he seems to think he needs it to pattern match
14:59:55 * nand` loves MolSeq{..} and using ‘name’ as the field directly
15:00:04 * shachaf hates that.
15:00:08 <shachaf> RecordWildCards = the devil
15:01:23 <ew0> ok
15:01:26 <ew0> it stoped blowing up
15:01:33 <ew0> but I new a machine with more memory =D
15:02:48 <n-dolio> NihilistDandy: What issues?
15:02:50 <EvanR> ew0: no, you probably have bad code
15:03:16 <EvanR> or perfectly good code for an infinite memory computer
15:04:25 <NihilistDandy> n-dolio: The performance and memory issues, mostly. It's not relevant to anything I'm doing, it's just a curiosity. I also wonder if the escape continuations provided by callCC in Haskell are equivalent to call/ec, or if they take the performance hit of call/cc.
15:05:23 <Lutin`> ew0: You should take a look at profiling with GHC
15:05:39 <Lutin`> Find out what exactly is blowing up
15:05:42 <Puffton> how come not all types derive from show for instance by default?
15:05:54 <Puffton> is there a noticeable overhead or something?
15:05:55 <shachaf> Puffton: Don't call it "derive from Show".
15:06:06 <shachaf> That phrasing will just lead to confusion.
15:06:24 <Puffton> I think of it as inheritance
15:06:25 <shachaf> It's called "deriving" because GHC "derives" the code for it.
15:06:29 <nand`> Puffton: how would you show  newtype Foo = Foo { foo :: Int -> Char } -- ?
15:06:34 <shachaf> Puffton: It's not inheritance. Haskell doesn't have inheritance.
15:06:37 <NihilistDandy> Puffton: If every Show instance were derived automatically, you wouldn't be able to define your own instance.
15:06:44 <NihilistDandy> And all my trees would look ugly
15:06:53 <shachaf> The sooner you get these OOish ideas out of your head, the better off you'll be. :-)
15:06:57 <Puffton> NihilistDandy, oh you mean define your own Show instance?
15:07:05 <NihilistDandy> Yeah
15:07:11 <shachaf> Puffton: Anyway, the reason is that it's not possible for all types, and you might want your own instance even for types that it is possible for.
15:07:18 <NihilistDandy> Also what shachaf said
15:07:26 <Puffton> shachaf, then I can think of it like including the code for Show?
15:07:41 <Puffton> what is the preferred terminology here
15:07:44 * nand` has always dreamed of a sort of ‘Debug’ type class for this purpose
15:08:06 <nand`> where non-printable types would simply be printed as _ or something
15:08:55 <shachaf> Puffton: "has a Show instance" is fine, for a type has a Show instance.
15:09:41 <Puffton> if you have multiple types or instances of them, do they all have the same show instance?
15:09:44 * cmccann also notes that automatically defining Show for all types without needing a Show constraint would break parametricity
15:10:02 <shachaf> cmccann: We automatically define Seq instances for all types...
15:10:03 <Puffton> (I figure not but asking just to make sure)
15:10:14 <Lutin`> I sense an underlying misunderstanding of type classes
15:10:32 <nand`> shachaf: there's a Seq type class?
15:10:34 <cmccann> shachaf, it's not needing a constraint in the context that breaks things
15:10:43 <NihilistDandy> Puffton: http://www.haskell.org/haskellwiki/Typeclassopedia
15:10:50 <shachaf> cmccann: Right. Which is how seq works.
15:10:55 <shachaf> nand`: There was once.
15:11:15 <Lutin`> NihilistDandy: Err, how would that help him?
15:11:17 <applicative> I'm not sure Puffton is ready for typeclassopedia
15:11:27 <shachaf> class  Eval a  where seq              :: a -> b -> b
15:11:30 <shachaf> -- Haskell 1.4 report
15:11:35 <NihilistDandy> I suppose that's true. Probably a bit much.
15:11:52 <NihilistDandy> How about: http://book.realworldhaskell.org/read/using-typeclasses.html
15:12:05 * cmccann doesn't think you can break anything with seq in a way that pure code can observe, though. can you?
15:12:31 <shachaf> «In their paper "Free theorems in the presence of seq"[3], Patricia Johann and Janis Voigtlaender showed that because of the presence of these operations, the general parametricity theorem does not hold for Haskell programs; thus, these transformations are unsound in general.»
15:13:43 <nand`> do you think it would be a good pedagogical exercise to model type classes as records and pass them around via (possibly implicit) parameters?
15:14:17 <nand`> (of course, this doesn't cover typeclass resolution)
15:14:26 <nand`> instance resolution rather
15:14:40 <shachaf> My instance resolution is 1440×900. :-(
15:14:46 * cmccann dislikes stuff that misbehaves where the programmer can see it, but stuff that misbehaves where pure functions can exploit it seems significantly worse
15:15:37 * Puffton started with Haskell a couple of days ago, but has been coding some Prolog (pretty close to functional programming?) and I have worked with C# for about 5 years (the paradigms may be different but I mean in terms of general programming).
15:15:55 <Puffton> i.e. this is not my first time touching code, but it's my first time touching Haskell (whether it's better or worse I don't know)
15:16:09 <rwbarton> opinions vary on that :)
15:16:20 <cmccann> the main way that prolog is similar to Haskell is that both are very different from mainstream languages
15:16:39 <nand`> what about eg. data Foo = Foo | Bar; data Baz = Baz Int Foo  giving rise to instance Show Foo  and  instance (Show Int, Show Foo) => Show Baz  ?
15:16:58 <ski> Puffton : recursion, pattern-matching, and immutability carries over from Prolog to Haskell (and vice versa)
15:17:13 <Puffton> ski, omg, you are here too :p
15:17:15 <cmccann> prolog pattern matching is really not the same thing, is it
15:17:26 <cmccann> beyond a superficial level, at least
15:17:32 <ski> (however, pattern-matching in Prolog is more general : it's unification, which is two-way matching, while Haskell only does one-way matching)
15:17:35 <Puffton> To me it feels really similar to Prolog
15:18:12 <ski> (and a consequence of this is that in Prolog, it's possible to compute with expressions containing uninstantiated variables -- this isn't possible in Haskell)
15:18:27 * shachaf wonders why Prolog is called "logic programming".
15:18:30 <cmccann> yeah, prolog can do far more with its pattern matching
15:18:36 <nand`> the feel of a declarative, immutable language as compared to a stateful, mutable one in general is quite noticeable
15:18:57 <cmccann> shachaf, perhaps all other languages are illogical
15:19:13 <ski> shachaf : sometimes it's called "relational programming", i think i've also seen "rule-based programming" and "declarative programming" (sic !)
15:19:17 <cmccann> just like languages that aren't functional must be dysfunctional instead!
15:19:51 <EvanR> law of excluded middle
15:19:54 <rwbarton> basic is an illogical, dysfunctional, object-disoriented language
15:19:55 <ski> shachaf : in any case, it's based on (a fragment of) predicate logic, rather than a kind of equational logic
15:20:06 <nand`> rwbarton: heh
15:21:28 <nand`> “rule-based programming” <- most programming languages I've seen follow a certain set of rules. the exception seems to be PHP
15:21:34 <EvanR> lol
15:21:40 <cmccann> we need more rule-breaking programming languages
15:21:44 <nand`> but “x += 1” is a fine state transition rule
15:21:55 <cmccann> or maybe suggestion-based programming
15:22:00 <cmccann> rules are too demanding
15:22:45 * cmccann considers generalizing imperative programming to other grammatical moods
15:23:34 <ski> nand` : well, the "rules" in this case would be the implications
15:23:56 <ski> one can both have forward-chaining and backward-chaining of such rules
15:24:29 <nand`> ski: yes; the term is a bit too broad to be a meaningful distinction of programming languages imo
15:24:37 <cmccann> hm, actually "declarative" is sometimes used as a synonym for the indicative mood, isn't it? this totally works.
15:24:41 <shachaf> subjunctive programming
15:24:44 <ski> i think typically, the systems that are stated to support "rule-based programming" actually does forward-chaining (responding to stimuli), while Prolog does backward-chaining (attempting to prove/solve goals)
15:26:25 <ski> <http://en.wikipedia.org/wiki/Production_system>
15:27:44 <cmccann> shachaf, subjunctive programming would be fun if it were to exist :D
15:28:12 <shachaf> cmccann: I reject the subjunctive case, by the way.
15:28:21 <shachaf> I proudly say "if I was"!
15:28:33 <osfameron> that's not rejecting the case
15:28:43 <shachaf> Well, OK.
15:28:56 * cmccann rejects case in favor of scott encoding
15:29:00 <shachaf> I reject the crazy use of it people prescribe.
15:29:09 <Puffton> Which is the most common functional language in the market do you guys think? I see here on freenode that Haskell is huge (and Python too, which could be functional I guess)? But I haven't really seen any jobs in Haskell (it tends to be in Eglang, F# etc)?
15:29:22 <MostAwesomeDude> Puffton: Depends on the market.
15:29:29 <Puffton> Erlang*
15:29:37 <EvanR> Puffton: javascript
15:29:39 <osfameron> shachaf: well, you're just tunneling it through the imperfect case
15:29:43 <osfameron> Excel?
15:29:44 <cmccann> Python is really not functional
15:29:44 <osfameron> SQL?
15:29:51 <EvanR> python is dysfunctional
15:29:53 <osfameron> er, imperfect tense
15:29:54 <Puffton> :D
15:29:55 <nand`> define ‘functional language’
15:29:58 <EvanR> sql would be functional if it had functions
15:30:01 <shachaf> Uh-oh, is it already what's-a-functional-language-o'clock?
15:30:15 <cmccann> seriously, python only looks functional to people who've never used a functional language
15:30:16 <shachaf> Take it to #haskell-offtopic.
15:30:19 <nand`> it's always define-x-o'clock
15:30:27 <Puffton> ok
15:30:30 <osfameron> shachaf: it's Friday night, everything is on topic!
15:30:35 <shachaf> @localtime
15:30:37 <Puffton> I'm alone there ;(
15:30:38 <lambdabot> Local time for shachaf is Fri Sep 21 15:30:15 2012
15:30:51 <nand`> saturday here
15:31:05 <osfameron> bah, temporal relativism ftl
15:31:12 <cmccann> Local time for shachaf is arguing-about-terminology-o'-clock
15:31:46 <janua1> If I have an IO String, how can i use putStrLn on it, without having to take it out of the IO in the first place
15:32:01 <EvanR> yourThing >>= putStrLn
15:32:04 <Puffton> nand`, that's something I have been having a hard time wrapping my head around. I mean the textbook answer is immutability and the use of lambda functions isn't it?
15:32:15 <shachaf> janua1: You should read an introduction to IO in Haskell.
15:32:20 <shachaf> @google introduction to IO in Haskell
15:32:22 <Puffton> But what if I wrote C#-code with some lambda stuff and immutable vars? Would that be functional?
15:32:22 <lambdabot> http://www.haskell.org/haskellwiki/Introduction_to_IO
15:32:23 <lambdabot> Title: Introduction to IO - HaskellWiki
15:32:40 <shachaf> The argument about "what is functional" is a complete waste of time.
15:32:43 <osfameron> immutability doesn't mean functional (or vice versa)
15:32:49 <osfameron> that doesn't mean it's not fun
15:32:57 <EvanR> declarative
15:33:07 <EvanR> vs imperative
15:33:12 <EvanR> functional vs dysfunctional
15:33:15 <EvanR> haha
15:34:48 * nand` .oO( imperative languages <-> unimportant languages )
15:35:00 <NihilistDandy> I wish there were a subjunctive language 😼
15:35:16 <cmccann> as a rule of thumb "functional language" means either "it is or wants to be lisp" or "it's vaguely descended from ML"
15:35:35 <Mortchek> NihilistDandy, it's called English
15:35:43 <Mortchek> or any other natural language for that matter
15:35:44 <shachaf> cmccann: Or "it works".
15:35:47 <NihilistDandy> Mortchek: *programming language
15:35:52 <nand`> cmccann: so does SKI fall into the “it wants to be lisp” category?
15:36:14 <shachaf> I think "derived from the lambda calculus" is another (overlapping) category.
15:36:19 <shachaf> Wait, how did we get onto this again?
15:36:27 <shachaf> A language is functional iff it uses {- -} for multiline comments.
15:36:29 <shachaf> There.
15:36:35 <ion> Hear, hear.
15:37:27 <cmccann> shachaf, untyped lambda calculus with extra stuff gives you lisp, typed lambda calculus with algebraic data types gets you something ML-ish
15:37:49 <shachaf> cmccann: Lisp is all about lists.
15:37:55 <nand`> I guess you could say ‘is based on something in the lambda cube’
15:38:20 <osfameron> cube?
15:38:48 <ion> It’s like the time cube.
15:38:52 <cmccann> shachaf, it's not hard to build lists on top of untyped lambda calculus
15:39:05 <nand`> it's not hard to built a lot of things on top of the untyped lambda calculus
15:39:16 <osfameron> time cube?
15:39:27 <shachaf> cmccann: Sure, but the whole "syntax is represented as lists" bit seems to be important to lispers.
15:39:42 <nand`> @quote list.processing
15:39:42 <lambdabot> monochrom says: in retrospect, it seems lisp designers were more interested in list processing than functional programming
15:40:21 <MostAwesomeDude> osfameron: timecube.com
15:41:33 <osfameron> MostAwesomeDude: is that a markov chain?
15:41:39 <cmccann> hahaha
15:41:48 <nand`> how often was that website run through google translate and back?
15:42:04 <MostAwesomeDude> osfameron, nand` : It is not machine-generated.
15:42:15 <nand`> and thanks for bringing it to my attention that, apparently, I don't have a forced maximum font size configured
15:42:16 <MostAwesomeDude> It is updated, by hand, by one man who sincerely believes every word he has written.
15:42:16 * cmccann is too educated stupid to understand nature's 4-sided harmonic time cube
15:42:18 <cmccann> or whatever it is
15:42:31 <osfameron> MostAwesomeDude: he's a semi-literate nutjob then
15:42:35 <osfameron> why is it notable?
15:42:42 <osfameron> I'm sure there are many semi-literate nutjobs
15:42:45 <MostAwesomeDude> YOU ARE DUMB AND STUPID. YOU MUST COMPREHEND THE TRUE HARMONIC NATURE OF 4 DAYS IN ONE EARTH.
15:42:57 <MostAwesomeDude> osfameron: This has been around for, oh, 15 years? 20 maybe?
15:42:57 <ion> osfameron: Not many have that awesome websites.
15:43:09 <cmccann> osfameron, it's a classic
15:43:13 <startling> osfameron, have you ever had an old racist crazy grandpa?
15:43:18 <osfameron> "This a major lie has so much evil feed from it's wrong.
15:43:35 <osfameron> startling: I've never had a grandpa
15:44:02 <startling> osfameron: oh. well.
15:44:37 <cmccann> it's been around for 15 years according to wikipedia
15:46:33 <osfameron> and it's definitely not a joke?
15:46:39 <mikeplus64> is there a packCString# :: Addr# -> CString ?
15:47:15 <cmccann> I don't think the web itself is even 20 years old, at least in anything resembling its current form
15:48:02 <MostAwesomeDude> osfameron: Definitely not.
15:48:09 <cmccann> if it's a joke, he's done a very good job of playing it straight
15:48:13 <cmccann> for 15 years
15:48:29 <dmwit> Some MIT students invited him (a bit cruelly, I think) to give a talk there.
15:48:45 <dmwit> There's footage on YouTube if you want to judge his level of seriousness for yourself.
15:49:51 <cmccann> yeah, it's a little off-putting the way people treat him. on one hand I don't think anyone dislikes him, and the site is kind of a fixture of the web
15:49:51 <osfameron> ONEism is demonic Death Math!
15:50:16 <cmccann> but on the other hand it's pretty much always sorta patronizing and implicitly mocking him behind his back
15:50:23 <cmccann> so, eh
15:50:35 <ion> Ray spoke about Time Cube at the Massachusetts Institute of Technology (MIT) in January 2002 as part of the Independent Activities Period, a student-organized extra-curricular event.[5] He repeated his $10,000 offer for professors to disprove his theories at the event; none attempted it.[4]
15:50:37 <ion> :-D
15:50:53 <mikeplus64> :i State#
15:51:04 <c_wraith> I would certainly not attempt.  It'd be a bad idea to even talk to him
15:51:04 <shachaf> mikeplus64: I doubt it.
15:51:20 <cmccann> reminds me a bit of Emperor Norton, in a way
15:51:29 <cmccann> quasi-respectfully humoring the crazy guy
15:52:03 <cmccann> (google Emperor Norton if you don't know who I'm talking about, it's entertaining)
15:52:49 <osfameron> apparently Ray is the Wisest Human to ever live on Earth
16:04:48 <parcs`> poor guy
16:07:37 <kyagrd> Anyone running ghc 7.6 and interested in higher-order functor class?
16:07:37 <lambdabot> kyagrd: You have 2 new messages. '/msg lambdabot @messages' to read them.
16:09:23 <kyagrd> having a warning message of "orphan class", which is not an error, but I still don't understand why this message is comming out and would this make a problem at all
16:10:10 <hpaste> foxnewsnetwork pasted “maximum function” at http://hpaste.org/75091
16:11:35 <notola> that program won't compile for some reason
16:11:46 <notola> help please
16:12:00 <shachaf> notola: Does GHC say "refusing to compile for some reason" when you try to compile it?
16:13:12 <Lemon> so what is the reason that static binaries still exist?
16:13:28 <Lemon> like, why not just have everything be dynamically linked
16:13:50 <shachaf> Inlining and things.
16:13:57 <shachaf> It's hard.
16:14:18 <pr> http://harmful.cat-v.org/software/dynamic-linking/
16:14:19 * pr hides
16:15:01 <Lemon> >cat-v
16:15:06 <Lemon> >2012
16:15:22 <shachaf> Can you not do that in here? :-(
16:16:16 <Lemon> okay fine
16:16:26 <notola> shachaf: sorry, internet drop out for a sec there (and for being newb), haskell says there is something wrong with the loop max ( y :| ys) = ... line
16:17:07 <shachaf> notola: Is that what GHC says?
16:17:11 <shachaf> "there is something wrong with the loop max ( y :| ys) = ... line"?
16:17:39 <notola> shachaf: ghci says " parse error on input `="
16:17:51 <shachaf> Ah, that's better.
16:18:14 <shachaf> notola: Your "lupine"s need to all be aligned. They aren't.
16:18:27 <shachaf> The solution is not to use tabs for indentation, but instead spaces.
16:18:27 <Lemon> notola, to have them align, either stop using tabs
16:18:37 <Lemon> or put the type annotation for lupine on its own line
16:18:38 <ben> or stop using haskell
16:18:54 <ben> make spaces, not tabs~
16:18:56 <Lemon> I recommend that you stop using tabs
16:18:58 <Lemon> seriously
16:19:07 <Lemon> also, typo in line 6
16:19:07 <gabor> kyagrd: can you paste your 'higher-order functor class'?
16:19:08 <notola> oh okay thanks, will attempt the no-tabs fix
16:19:22 <Lemon> should be: in lupine x xs
16:19:35 <notola> ah, okay thanks
16:19:38 <Lemon> also, why do you have parens around the expression in line 5
16:19:48 <pr> tabs are fine for indentation, it's just that haskell doesn't really like it that much. so let your tabs be expanded to spaces, at least for your haskell files ;)
16:20:15 <Puffton> http://hpaste.org/75094
16:20:20 <Puffton> On line 15, why does it say redundant bracket?
16:20:47 <shachaf> Puffton: Click on it and see.
16:21:06 <Puffton> ah I didn't know that was possible
16:21:10 <Puffton> oh ok, it makes them all the same line
16:21:42 <Lemon> which is kind of weird
16:22:03 <Lemon> well, dayum
16:22:10 <Lemon> my VM ran out of memory trying to compile GHC
16:23:40 <monochrom> do not allow editors to insert tabs behind your back
16:23:55 <pr> haha
16:24:15 <monochrom> do not believe in "plain text editors tell you the truth" lies
16:26:14 <gabor> kyagrd: this one? https://code.google.com/p/nax/source/detail?r=436
16:26:37 <gabor> kyagrd: yo seem to like natural transformations :-)
16:29:49 <ski> Puffton : is  profileDistance'  only supposed to be passed two lists of the same size ?
16:31:15 <Puffton> ski, I don't know.. my friend and I thought about it.. the example data we have suggests so, but it is never stated clearly
16:43:47 <ski> Puffton : is there only two values of the type of `DNA' ?
16:44:59 <Puffton> ski, I think there are many, 1 min
16:45:29 <Puffton> well, only two that I can find
16:45:46 <Puffton> but potentially any combination of A,C,G,T will be classified as DNA I think
16:50:46 <ski> Puffton : well, i was talking about the output type of `seqType'
16:50:56 <Puffton> oh, that
16:50:56 <Puffton> yes
17:00:25 <hpaste> ski annotated “Puffton” with “some simplifications” at http://hpaste.org/75094#a75101
17:00:33 <ski> Puffton ^
17:00:52 <kyagrd> can we use kind variables in ghc 7.6?
17:01:01 <kyagrd> ghc 7.4 doesn't seem possible
17:01:35 <Puffton> oh
17:01:40 <Puffton> thanks!
17:05:19 <ski> (and yes, see also the hints for fusing adjacent `map' calls)
17:06:11 <Puffton> I'm still a bit too newbish to follow everything you do here
17:06:13 <Puffton> For instance
17:06:28 <Puffton> m@(m0:_)
17:06:34 <Puffton> What does this snippet mean?
17:06:56 <shachaf> Puffton: Do you know about Hoogle?
17:06:58 <ski> it means that that argument is both named `m', and matched with the pattern `m0:_'
17:07:01 <shachaf> Try typing @ into Hoogle. :-)
17:07:19 <ski> and therefore (if the match succeeds), `m0' will be the first element of `m'
17:07:29 <ski> which was why i replaced `head m' by `m0'
17:08:03 <ski> (using a match on `m0:_' will give better error messages than using `head' -- you should try to avoid using `head' and `tail')
17:10:19 <Puffton> oh, ok
17:12:51 <Lutin`> So I still haven't gotten my toes wet in Template Haskell
17:13:03 <Lutin`> Any suggestions on where to start?
17:14:12 <Puffton> ski, is it correct that _ in Prolog and Haskell works in the same way?
17:15:45 <ski> in patterns, yes
17:15:57 <ski> however, one can't use `_' in expressions in Haskell
17:16:28 <ski> (and `m0:_' would correspond to `[M0|_]' in Prolog terms)
17:21:51 * shachaf wonders whether there would be any reasonable meaning to "dependent sum".
17:23:43 <kyagrd> you can use "__" as an identifier, and overload it and overload other things to mimic prolog maybe
17:23:54 <simon> I just read on Lennart Kolmodin's Google+ that a tango step is a monoid, but I can't dance. can anyone explain associativity and identity, and maybe I can learn to dance?
17:25:59 <simon> I mean, step1 x (step2 x step3) = (step1 x step2) x step3 implies I'll end up in the same position regardless of which order I take the steps, but what is the identity step?
17:27:28 <shachaf> Presumably the identity is not moving.
17:27:51 <simon> shachaf, I wonder if MC Hammer style is a monoid then.
17:28:54 <NihilistDandy> Or Gangnam style, for that matter
17:30:04 <ski> shachaf : hm, according to one terminology, `forall x : A. P x'/`(x : A) -> P x' is a dependent product, while `exists x : A. P x'/`(x : A) * P x' is a dependent sum
17:30:21 <Ralith> '/`?
17:30:36 <ski> "/" meaning "alternatively"
17:30:42 <shachaf> ski: Right.
17:30:43 <Ralith> ooh.
17:30:54 <shachaf> A dependent Either doesn't make much sense to me.
17:31:03 <ski> (according to another, the first is a "dependent exponential" and the other a "dependent product")
17:31:18 <ski> shachaf : i think that you need to talk about continuations to make sense above that
17:31:57 <shachaf> As in a Church-encoded Either?
17:32:12 <kyagrd> Which version of ghc can type check the last of http://hpaste.org/63852 ???
17:32:41 <kyagrd> Neither ghc 6.7.1 nor ghc 7.4.1 works hmm ...
17:33:27 <ski> shachaf : let's replace the ordinary `x : A' by `val x : A', and let's also introduce a `cont y : A' (meaning that `y' is a continuation of type `A' / a counter-example of the proposition `A')
17:33:37 <shachaf> kyagrd: I'm not sure that last thing makes sense...
17:34:11 <ski> shachaf : then i think we could consider `(cont y : A) + P y', where the type `P y' depends on the counter-example for `A'
17:34:41 <rwbarton> kyagrd: I think you aren't allowed to have a type instance be a polytype. wrapping in a newtype should work
17:34:46 <ski> (however, i think this disjunction would behave more multiplicatively than additively)
17:36:00 <kyagrd> rwbarton: I wish I could have a result of a type instance to be a polytype :)
17:36:22 <ski> (the computational interpretation of a multiplicative disjunction `A + B' is more or less that if someone manages to refute one of the disjuncts, then you can (possibly using that refutation) prove the other disjunct)
17:37:28 <Puffton> ski, MolSeq and Profile, are they type classes?
17:37:31 <ski> (this seems to often be the intended interpretation of disjunction, in e.g. `p | a * b  =>  p | a  \/  p | b' and `a * b = 0  =>  a = 0  \/  b = 0')
17:38:22 <ski> Puffton : you both have two modules called `MolSeq',`Profile', and also two types called that. no type classes though
17:39:15 <Puffton> ah ok, now I see the difference
17:39:21 <parcs`> what exactly would a dependent sum depend on?
17:39:27 <Puffton> are type classes normally defined in their own modules?
17:39:44 <hpaste> rwbarton annotated “kind-indexed type family” with “kind-indexed type family (now with 100% more higher-order kinds!) (annotation) (annotation)” at http://hpaste.org/63852#a75102
17:40:00 <rwbarton> kyagrd, even with the newtype it needs a lot of hand-holding apparently
17:40:35 <Eduard_Munteanu> parcs`: I guess in Σ A B, the second component depends on the values of A
17:40:54 <parcs`> that's a dependent product though
17:40:55 <shachaf> It dependo.
17:41:26 <Eduard_Munteanu> Mm, it is a dependent sum, AFAIK.
17:41:28 <dolio> It's a dependent sum.
17:41:51 * ddarius prefers the dependent product/sum terminology over the dependent function space/pair terminology.
17:42:26 <Eduard_Munteanu> parcs`: are you thinking of Agda's Data.Product? :)
17:42:34 <parcs`> yeah
17:42:49 <dolio> Data.Product has dependent sums in it.
17:43:00 <dolio> It's a great naming scheme.
17:43:05 <parcs`> i guess if A : Bool then you can write Either with it
17:43:22 <shachaf> dolio: Dependent "repeated sums", right?
17:43:31 <parcs`> but is that really a dependent sum or is it a sum type encoded with a dependent product
17:43:36 <hpaste> gabor annotated “kind-indexed type family” with “kind-indexed type family (now with 100% more higher-order kinds!) (annotation) (annotation)” at http://hpaste.org/63852#a75103
17:43:49 <Cale> dolio: Do you know of a good reference for the production rules and axioms of homotopy type theory in a more traditional notation?
17:43:58 <ski> parcs` : not clear what you intend by "dependent sum", see above ?
17:44:05 <ddarius> parcs`: In normal algebra, what's the sum of x form 1 to N.
17:44:14 <ddarius> x not depending on anything.
17:44:20 <ski> shachaf : itym s/repeated/iterated/ :)
17:44:28 <Eduard_Munteanu> parcs`: you can write A x B as a dependent sum
17:44:29 <dolio> Cale: Not really. Depends what you're looking for. There's only one extra rule.
17:45:00 <ski> ddarius : i tend to write that as `(i < N) * x' :)
17:45:09 <dolio> For the rest you just find something you like on Martin-Loef intuitionistic type theory.
17:45:13 <Cale> dolio: So it's just Martin-Löf type theory + Univalence?
17:45:14 <jia> hi
17:45:19 <dolio> Cale: Yeah.
17:45:23 <Eduard_Munteanu> parcs`: A x B = Σ A (const B)
17:45:29 <ddarius> Cale: One of the whole points of HTT is that it's "just" Martin-Loef type theory and, right now, univalence is added.
17:45:43 <shachaf> > ($ 0) $ foldr (.) id $ zipWith ($) (repeat (+)) [1..5]
17:45:45 <lambdabot>   15
17:45:53 <shachaf> ski: Repeated, see?
17:46:25 <Eduard_Munteanu> That has to be the best "X is just Y" phrase :)
17:46:28 <shachaf> > foldr ($) 0 $ zipWith ($) (repeat (+)) [1..5]
17:46:29 <lambdabot>   15
17:46:33 <ski> shachaf : yes. just saying that i think one common calls this an "iterated sum"
17:46:42 <parcs`> ddarius: n*(n+1)/2 ?
17:46:45 <ski> s/common/commonly/
17:46:54 <shachaf> ski: Ah.
17:46:55 <ski> parcs` : no
17:47:08 <dolio> Cale: The problem, of course, is no one has a computational interpretation of univalence, as far as I know.
17:47:16 <dolio> Not that that bothers all the mathematicians.
17:47:39 <Cale> dolio: I think it's quite possible that there isn't one.
17:47:43 <ski> parcs` : i think ddarius meant "the sum of x, as i goes from 1 to N"
17:48:04 <dolio> That'd be unpleasant.
17:49:47 <parcs`> ski: *shrug*
17:49:52 <Cale> dolio: It implies function extensionality, but knowing that functions are equal sounds pretty uncomputable?
17:50:03 <gabor> dolio, Cale: do you 'get' this opetope thingy? http://golem.ph.utexas.edu/category/2012/06/directed_homotopy_type_theory.html#c041675
17:50:14 <dolio> Cale: It's not deciding equality.
17:50:46 <dolio> Having functional extensionality in a decidable, intensional type theory is old hat since Observational Type Theory.
17:51:01 <dolio> Or, it would be old hat if anyone ever implemented it.
17:51:04 <cmccann> gabor, have you poked at http://sma.epfl.ch/~finster/opetope/opetope.html ?
17:51:14 <gabor> yes I did
17:51:44 <gabor> I am mostly interested in opetopes vs. inference rules, axioms
17:52:06 * ski isn't sure what the bad consequences of adding function extensionality would be
17:52:23 <dolio> And everything in OTT has computational interpretations, as far as I know.
17:52:32 <parcs`> Eduard_Munteanu: Σ is defined as a record with two fields, which looks like a product to me. i guess the dependentness of the second field makes it a sum?
17:52:49 <dolio> The thing is, all the extra axioms are propositions, so their computational interpretation is either the unit or empty type.
17:53:00 <Cale> gabor: There's more on Opetopes in Leinster's book.
17:53:36 <Cale> http://arxiv.org/pdf/math/0305049v1.pdf -- see Chapter 7
17:53:37 <ski> parcs` : it's often called a "dependent sum", because it's like an iterated sum `Sum_{i \in A} x_i'
17:53:54 <dolio> HTT wants to keep all the computation in identity types, but still have the axioms that imply functional extensionality and whatnot.
17:53:56 <rwbarton> parcs`: if I have a bunch of (disjoint) sets A_1, ..., A_n then an element of the sum (union) A_1 + ... + A_n is a pair (i, x) where x in A_i
17:54:09 <Eduard_Munteanu> parcs`: well, Σ Bool (const B) = B + B
17:54:31 <ski> dolio : are you claiming that the only subsets of the unit type is the unit type and the empty type ?
17:54:37 <gabor> Cale: I scanned E Cheng's thesis, but it did not really establish the connection between types and opetopes
17:54:41 <Eduard_Munteanu> parcs`: actually, what you get is a sum of products
17:55:49 <cmccann> every time I read anything about dependent types I become confused about what sums and products are for at least a day or two afterwards :[
17:56:35 <parcs`> i think i see it
17:56:47 <mikeplus64> shachaf: i'm not sure how safe it is, but, the function i was looking for :: Addr# -> CString is just Ptr
17:56:54 <mikeplus64> seems to work :)
17:56:58 <Cale> cmccann: Why is that?
17:57:28 <cmccann> Cale, if I could answer that usefully I wouldn't get confused by it in the first place
17:57:31 <gabor> cmccann: the sum and product notations count the possible inhabitants
17:58:27 <ddarius> cmccann: Dependent sums are vaguely analogous to existentials and dependent products are analogous to universals.
17:58:32 <Cale> cmccann: Do you know what sums and products are in category theory?
17:58:34 <gabor> cmccann: Σ(i :: {1,2,3}) = 6
17:58:56 <cmccann> ddarius, I gather that much
17:59:03 <dolio> ski: If you go read about OTT, the equality type, which is where all the axioms are added, is defined by recursion, with all the base cases either unit or empty, and all the inductive cases are products.
17:59:17 <ski> Cale : because, looking at the (sensible, imo) notations `(x : A) -> P x' and `(x : A) * P x', these appear to be dependent versions of the nondependent `A -> B' and `A * B'
17:59:18 <Eduard_Munteanu> What's a dependent product, just Pi?
17:59:25 <maukd> so for the first time I've been actually thinking about lazy evaluation in the context of lambda calculus
17:59:43 <maukd> it seems like all thunks are thunks of applications. is this correct?
18:00:00 <dolio> And I believe it's even identified as part of the proof irrelevant sub-universe of the overall universe.
18:00:08 <maukd> (conversely, what forces thunks is applying a function)
18:00:11 <cmccann> it's probably just the conflict in terminology because I'm used to sums and products in the usual sense of what Either and (,) don't quite manage to be
18:00:15 <ddarius> In the pure lambda calculus, that the only potentially reducible expression.
18:00:19 <ski> dolio : hm, ok
18:00:25 <Eduard_Munteanu> maukd: well, beta reduction is all about application in LC
18:00:59 <maukd> and if you add pattern matching, that's another thunk/force point
18:01:00 <Cale> maukd: I suppose you could say that, but you could also just not talk about thunks at all.
18:01:13 <Cale> (they're just representations of expressions anyway)
18:01:20 <parcs`> actually no i don't see it. oh well
18:01:20 <maukd> ah, but I'm thinking in java here
18:02:09 * Cale makes a little associahedron out of magnets.
18:02:23 <Puffton> is there something like "import once" in haskell? to prevent cycling imports
18:02:26 <Puffton> if you have them in multiple files
18:02:34 <Puffton> cyclic*
18:02:45 <maukd> Puffton: ?!
18:03:06 <parcs`> there are hs-boot files to facilitate cyclic imports
18:03:07 <rwbarton> Puffton: you mean like A imports B and C which both import D?
18:03:12 <rwbarton> or A imports B which imports A?
18:03:17 <Eduard_Munteanu> import {-# SOURCE #-} ?
18:03:28 <ski> maukd : slightly apropos, "An Architecture for Combinator Graph Reduction (TIGRE)" by Philip J. Koopman at <http://www.ece.cmu.edu/~koopman/tigre/index.html> might be fun
18:03:36 <Cale> dolio: So you're saying that extensionality doesn't imply that function equality is computable because the proposition it depends on is the hard-to-compute part?
18:03:39 <cmccann> pf, why can't we have self-importing modules
18:03:42 <Puffton> rwbarton, yeah
18:03:45 <rwbarton> yeah which
18:03:52 <rwbarton> the former is okay and works automatically
18:03:54 <rwbarton> the latter is a pain
18:03:59 <Puffton> the latter
18:04:00 <geekosaur> *blinkblink* although perhaps I should not be surprised
18:04:11 <ddarius> Cale: Have you finally maxed out the number of free magnetic balls you can get?
18:04:13 <avpx> ski: That's pretty interesting.
18:04:14 <dolio> Cale: Probably.
18:05:12 <Eduard_Munteanu> cmccann: like those C tricks involving recursive includes? :)
18:05:56 <cmccann> Eduard_Munteanu, that sounds unwise D:
18:06:02 <ski> (hm, i think in O'Caml, you can define a module as a fix-point of a functor)
18:06:08 <Cale> ddarius: Not really, but I've reached a number that I'm happy with. It's 4320, which factors as 2^5 3^3 5, or 20 * 216, which turns out to be a really nice number for large icosahedral structures.
18:06:18 <dolio> Cale: The problem with extensional type theory is doing the deciding, because there's a rule that says if a proof of something is derivable, then it must be incorporated into the typing check.
18:06:32 <Eduard_Munteanu> Equirecursive modules :O   :P
18:07:25 <dolio> Cale: Whereas in intensional type theory, there's just an eliminator that says given an identity proof and a term, you can get a new term with a modified type by using the eliminator.
18:07:44 <ski> "Recursive modules" <http://caml.inria.fr/pub/docs/manual-ocaml-4.00/manual021.html#toc75>
18:07:47 <maukd> Cale: I know LC is just rewriting expressions, but I wanted to get some intuition as to what haskell implementations actually do
18:08:16 <Eduard_Munteanu> Where do I read on ITT vs ETT vs OTT? Any particular book I should look for?
18:08:28 <Cale> maukd: I like understanding them first in terms of expression graph rewriting -- everything else is just a further optimisation of that.
18:08:29 <dolio> And in OTT, the eliminator never even cares what the proof is, except when it has to be empty. So there's no issue of what computational behavior the eliminator has on any axioms you add, as long as the axioms are consistent.
18:08:54 <Eduard_Munteanu> I mean, I want a primer on those topics, I *think* I know some things, but there are lots of gaps.
18:09:04 <Cale> dolio: hmm...
18:09:04 <maukd> in particular, where exactly "laziness" lives and which parts of the machine are recursive
18:09:14 <Puffton> Is there any place I can find some examples of derivable type classes?
18:09:51 <dolio> But in HTT, the identity eliminator can have non-trivial computational content, so it has to do something, and the proofs that you get from, say, proving two sets are isomorphic and using univalence, have to carry the right information.
18:10:07 <Puffton> (found one in the docs but I would like some more)
18:10:35 <dolio> What it has to do in any particular case is kind of obvious in a hand-wavey sense (for the set case, it has to apply each half of the isomorphism in the right place), but I don't think it's trivial what the computational content should be in general.
18:10:43 <dolio> Because it can go up to any dimensionality.
18:10:59 <Eduard_Munteanu> maukd: laziness or non-strictness? IOW, are you interested in details regarding implementation details, or semantics?
18:11:37 <ski> (s/semantics/denotational semantics/ ?)
18:11:38 <maukd> the former, I think
18:11:46 <maukd> I care about sharing and black holes and stuff
18:11:50 <Cale> dolio: So just to be clear, extensionality in this context means that  forall f,g: A -> B. (forall x:A. f x ~ g x) -> f ~ g?
18:12:01 <dolio> Yes.
18:12:13 <dolio> Or even pi types.
18:12:29 <Cale> Well, that's what forall means?
18:12:39 <Cale> (Or is that wrong?)
18:12:43 <ddarius> Pi A.B
18:12:44 <dolio> Cale: No, I mean f and g could be pis.
18:12:52 <Cale> oh, I see
18:12:54 <dolio> Have pi types.
18:13:00 <ski>   forall f,g : (forall x : A. P x). (forall x : A. f x ~ g x) -> f ~ g
18:13:11 <Cale> right
18:14:03 <dolio> I don't even know what the proof of that looks like in HTT.
18:14:12 <dolio> I haven't bothered to work through the example.
18:14:15 <rwbarton> Puffton: the Haskell report lists Eq, Ord, Enum, Bounded, Show, and Read (http://www.haskell.org/onlinereport/haskell2010/haskellch4.html#x10-780004.3.3)
18:14:24 <dolio> I think there's an agda one. I should look at that. I can't read Coq.
18:14:48 <Eduard_Munteanu> dolio: um, is there a model of HTT in Agda?
18:15:03 <dolio> You just need to add an axiom.
18:15:08 <dolio> And disable K.
18:15:21 <Eduard_Munteanu> Hrm.
18:15:29 <Cale> dolio: Apparently nobody can read Coq, not even its users.
18:15:32 <dolio> Nisse has done a bunch of stuff with it somewhere.
18:15:52 <dolio> Cale: Yeah, I think you have to have it running in Emacs and step through or something.
18:15:56 <Cale> right
18:16:04 * Eduard_Munteanu really wants to learn *something* about HTT, but doesn't know where to begin :(
18:16:19 <Cale> Only the stuff which the Coq IDE tells you as you step through a proof is readable
18:16:23 <ddarius> Eduard_Munteanu: Start with learning Martin-Loef type theory.
18:16:31 <Cale> the proofs themselves involve way too much magic
18:16:53 <ddarius> Magic: What Computer Scientists Brought To Mathematics
18:17:17 <Eduard_Munteanu> ddarius: any particular book / resource I should read on that?
18:17:23 <ddarius> Holy shite, I finally got my fucking diploma.
18:17:38 <ski> Eduard_Munteanu : <http://intuitionistic.wordpress.com/works-on-martin-lofs-type-theory/> might be useful
18:17:48 <Eduard_Munteanu> Thanks, *looks*
18:17:52 <Cale> ddarius: lol, you too? It took them a couple years to get mine to me.
18:18:06 <ski> @where TTFP
18:18:06 <lambdabot> http://www.cs.kent.ac.uk/people/staff/sjt/TTFP/
18:18:13 <ski> Eduard_Munteanu : you can also try that ^
18:18:43 <Eduard_Munteanu> Hm, right, I should have another look at TTFP.
18:19:19 <ski> Eduard_Munteanu : anyway, i think Martin-LÃ¶f's "Intuitionistic Type Theory" is nice
18:19:24 <dolio> Cale: I think the fellow working on adding parametricity to something Agda-like did the same thing as OTT.
18:19:40 <dolio> If you add the parametricity statements to a propositional fragment, there's no computational issues.
18:20:35 <ski> Eduard_Munteanu : also, i found the initial parts of "Programming in Martin-Lï¿½f?s Type Theory" (especially the part about "arities") interesting
18:21:11 <dolio> So you don't have to worry about what any of your axioms do.
18:21:14 <Cale> Ã¶ is the best ö
18:21:39 <Eduard_Munteanu> Damn, I should get something usable as an ebook reader.
18:21:47 <maukd> oh god, it keeps mutating
18:22:01 <dolio> Although that seems iffy for the parametricity case to me, since the types I'd expect the internal statements to have wouldn't necessarily have 'relations' that are propositional.
18:22:04 <rwbarton> Cale: you don't like ï¿½?
18:22:20 <dolio> Maybe that's necessary, though.
18:22:33 <maukd> I think the last one was a UTF-8 replacement char decoded as latin-1
18:24:08 <dolio> ddarius: You use vim, right? What do you use for latex?
18:24:32 <zomg> Everything went to shit with cabal and ghc after installing ghc 7.4.1...
18:24:39 <zomg> Is there some known issue with that and ubuntu?
18:25:20 <zomg> Random Error 11's with installs, it seems to think deps are fucked, removing/reinstalling ghc via apt has no effect, nuking .ghc or .cabal no effect..
18:25:27 <Eduard_Munteanu> dolio: vim + latex is ok. There's the vim-latex stuff if you need folding, various macros etc.
18:25:54 <Cale> dolio: Is it reasonable to think about the computational content of HTT statements in terms of computations which realise the geometric interpretations of the statements?
18:26:13 <parcs`> i wonder if there's an Alternative-like combinator f a -> f b -> f (Either (a,b) (Either a b))
18:26:29 <dolio> Cale: I'm not sure what that means.
18:26:37 <Nereid> parcs`: what would it do?
18:26:50 <maukd> ski: are you interested in investigating which part of your setup is wrong?
18:28:05 <ski> maukd : istr "this" doesn't happen when i'm typing at my computer -- and, sure, i'm interested in finding out, but i'm not sure how to isolate it
18:28:24 <Cale> dolio: Hmm, I'm not 100% sure myself, but I'm thinking in terms of more classical datatypes which implement these spaces in terms of something like the computable real numbers and programs which implement the various continuous maps, etc.
18:28:26 <cmccann> parcs`, something like https://github.com/isomorphism/these/blob/master/Data/Align.hs ?
18:28:41 <ski> (and no, i can't actually check at my computer atm; not at home)
18:29:13 <hpaste> t7 pasted “How do i map over a Map nicely?” at http://hpaste.org/75105
18:29:43 <latro`a> uh
18:29:46 <latro`a> isn't there a Map.map
18:30:02 <latro`a> yeah, there is
18:30:38 <cmccann> isn't Data.Map a Functor anyway?
18:30:41 <Nereid> and Map k should be a functor
18:30:44 <latro`a> it is, yeah
18:30:47 <Cale> dolio: and so when you have something like p: x ~ y, there's actually some computable continuous map from the type of computable reals in the unit interval to the space in which x and y lie.
18:30:50 <latro`a> so there's an fmap too
18:31:00 <Cale> dolio: Does that sort of thing make sense?
18:31:52 <Nereid> it's even Traversable so
18:33:03 <dolio> That falls rather out of my area of expertise.
18:33:56 <dolio> Cale: Usually, the computation is pretty simple. J(refl, p) = p. Ind(0,s,z) = z, Ind(Sn,s,z) = s(Ind(n,s,z)).
18:34:41 <dolio> So, in that sense, the question is what is J(univalence, p).
18:34:42 <Cale> dolio: In my very fuzzy view of what's going on, it *seems* like extensionality is doing something a little bit choice-like to me. It's taking this big collection of witnesses that these path spaces are nonempty, and choosing a continuous path in the function space, which then consists of a witness from each of the input path spaces
18:35:18 <tsou> how are the tuples constructed as types?
18:35:20 <Cale> (maybe not really, but at least classically it would)
18:36:01 <Cale> Or really, I guess it's doing even more and constructing a continuous map which does that :)
18:36:48 <tsou> I wondered that while wondering of how they are made instances of the Bounded typeclass..
18:36:51 <Cale> dolio: I don't *really* understand even what J is yet. What was its type again?
18:37:18 <Cale> tsou: maxBound = (maxBound, maxBound), and minBound = (minBound, minBound)
18:38:16 * hackagebot MissingH 1.2.0.0 - Large utility library  http://hackage.haskell.org/package/MissingH-1.2.0.0 (JohnGoerzen)
18:38:20 <dolio> Well, it has more arguments than that in fact. A full type would be something like...
18:39:28 <tsou> Cale: I don't see how that works for tuples in general..
18:39:33 <dolio> J : (A : Type) -> (x : A) -> (P : (y : A) -> x = y -> Type) -> P x refl -> (y : A) -> (eq : x = y) -> P y eq
18:39:47 <Cale> tsou: Or to put type annotations in, if a and b are both instances of Bounded, then (maxBound :: (a,b)) = (maxBound :: a, maxBound :: b)
18:40:13 <Puffton> My dilemma: In MolSeq I want to derives(Evol), and in Evol I depend on MolSeq (http://hpaste.org/75106)
18:40:15 <Cale> tsou: The instance is conditioned on both of the components being instances of Bounded
18:40:17 <tsou> Cale: but this only takes care of pairs.. or am I missing somethign?
18:40:29 <Puffton> i.e. I would have to import MolSeq in Evol and Evol in MolSeq = circular imports
18:40:32 <Cale> tsou: Well, the instances for other tuples are analogous
18:40:41 <dolio> Cale: But, then, you should probably actually go and learn about Martin-Loef type theory and stuff. Because I don't see how thinking about classical set theory is going to help you think of what the rewrite rules for combinators in a type theory are, off hand.
18:40:43 <Cale> tsou: there are something like 15 of them
18:40:44 <tsou> yes, but my question is how i could right something like that...
18:40:52 <dolio> Maybe there's a way, but I don't know what it is.
18:41:01 <rwbarton> Puffton: what do you mean "derives(Evol)"
18:41:04 <tsou> that would be applied to all tuples
18:41:14 <Puffton> deriving(Evol), sorry
18:41:20 <rwbarton> you can't derive your own classes
18:41:22 <rwbarton> just delete that
18:41:24 <tsou> Cale: 15?
18:41:38 <ddarius> dolio: I rarely use any kind of vim plugins.  I think I have :make set up to rebuild a the latex file and produce (and maybe even open) a PDF.
18:41:42 <Cale> tsou: Yeah, it stops at some arbitrary point
18:41:55 <tsou> Cale: so there's no way to treat it in a uniform way?
18:41:55 <Cale> tsou: They're just put in by hand.
18:42:04 <Puffton> rwbarton, how can I make an instance of Evol then?
18:42:12 <rwbarton> you already did
18:42:15 <Cale> tsou: There's no way to treat tuple types at all in a uniform way, they're *completely* separate types.
18:42:21 <rwbarton> on lines 7-10 of your most recent paste
18:42:49 <t7> @hoogle (\a b -> c) -> (Map a b) -> [c]
18:42:49 <lambdabot> Parse error:
18:42:50 <lambdabot>   (\a b -> c) -> (Map a b) -> [c]
18:42:50 <lambdabot>     ^
18:42:55 <t7> @hoogle (a b -> c) -> (Map a b) -> [c]
18:42:55 <Cale> tsou: If it's any consolation, you only really need pairs. You can build longer "tuples" out of pairs, and get uniform things to happen.
18:42:55 <lambdabot> No results found
18:43:05 <Cale> tsou: but it's not really quite the same
18:43:07 <t7> i need this :|
18:43:22 <Nereid> t7: what the heck are you trying to say by (a b -> c)
18:43:30 <t7> @hoogle (a -> b -> c) -> (Map a b) -> [c]
18:43:30 <lambdabot> Data.Map foldl :: (a -> b -> a) -> a -> Map k b -> a
18:43:31 <lambdabot> Data.Map foldl' :: (a -> b -> a) -> a -> Map k b -> a
18:43:31 <lambdabot> Data.Map isProperSubmapOfBy :: Ord k => (a -> b -> Bool) -> Map k a -> Map k b -> Bool
18:43:46 <dolio> Cale: Anyhow, in the case where we have iso(f, g) : A = B, where A and B are sets, it seems kind of 'obvious' that any type P : Set -> Type can only use its argument in places where one half of the iso would help us go from P A to P B (use A -> B in the covariant spots and B -> A in the contravariant spots).
18:43:46 <rwbarton> @hoogle Map a b -> [(a,b)]
18:43:47 <lambdabot> Data.Map assocs :: Map k a -> [(k, a)]
18:43:47 <lambdabot> Data.Map toAscList :: Map k a -> [(k, a)]
18:43:47 <lambdabot> Data.Map toDescList :: Map k a -> [(k, a)]
18:43:47 <Puffton> rwbarton, so in another file if I have a MolSeq { ? }  I will be able to run distance just by importing Evol?
18:43:48 <tsou> Cale: yes, i thought of that when you only gave the pair-example, but then realized that it doesn't really work like that in haskell..
18:43:53 <rwbarton> Puffton, yes
18:44:00 <Puffton> oh ok
18:44:09 <dolio> Cale: If we could walk over the structure of P we could probably do it.
18:44:16 <rwbarton> that is a feature of type classes, you can make your type an instance of a class somewhere that isn't the defintion of the type
18:44:18 <t7> @hoogle (a -> b -> c) -> Map a b -> Set c
18:44:18 <lambdabot> Data.Map foldl :: (a -> b -> a) -> a -> Map k b -> a
18:44:18 <lambdabot> Data.Map foldl' :: (a -> b -> a) -> a -> Map k b -> a
18:44:18 <lambdabot> Data.Map isProperSubmapOfBy :: Ord k => (a -> b -> Bool) -> Map k a -> Map k b -> Bool
18:44:21 <dolio> Cale: So J(iso(f, g), p) should probably do that, somehow.
18:44:26 <Cale> dolio: Yeah, I don't know. I'm sorta hoping that since there are geometric interpretations of everything, one can sneak (at least some!) classical results about spaces back into HTT.
18:44:43 <Cale> If one can find the right combination of these funny geometric primitives :)
18:44:44 <Puffton> cool, reminds me of extension methods in C# (yes, yes, taboo to talk about C#)
18:44:55 <dolio> But that's still a special case, and generalizing that is hard.
18:45:03 <cmccann> C# is pretty cool for a mainstream language.
18:45:21 <tsou> Cale: wow.  So.. the types for longer tuples work fine, it's just that they are not defined to be instances of the appropriate typeclasses.. right?
18:45:29 <t7> cmccann: just a shame about the .net standard libs
18:45:30 <Nereid> t7:
18:45:34 <Cale> tsou: yeah
18:45:34 <Nereid> @type traverseWithKey
18:45:35 <lambdabot> Not in scope: `traverseWithKey'
18:45:37 <Nereid> oops.
18:45:39 <Nereid> @hoogle traverseWithKey
18:45:39 <lambdabot> No results found
18:45:43 <Nereid> .
18:45:57 <Puffton> cmccann, yeah, I think it has been borrowing a little from functional languages lately too, with lambda and all that
18:46:00 <Cale> tsou: Practically no human uses tuples which are larger than 2 or 3 tuples anyway
18:46:19 <cmccann> more than a little, I think
18:46:24 <t7> traverseWithKey	:: (k -> a -> t b) -> Map k a -> t (Map k b)
18:46:25 <Cale> tsou: because as the number of components increases you really want to define your own datatype
18:46:31 <dolio> Cale: OTT does exactly that. It has a meta-finite universe of types, and does meta-induction on the structure of the type to interpret the identity type. So it actually walks over the structure of types deciding what it has to do with the identity proof.
18:46:40 <cmccann> what with LINQ being explicitly inspired by the list monad in Haskell
18:47:09 <Cale> dolio: hmm (just taking in the stuff you said about iso(f,g) now)
18:47:23 <dolio> But types aren't even up to isomorphism in OTT, so it only either does J(eq, p) = p if it decides the equality is trivial, or J(eq, p) = empty-elim(eq) if it decides the eq is empty. Or something like that.
18:47:32 <edwardk> every time i see that the white trash part of my brain goes "you down with OTT? yeah you know me"
18:47:41 <tsou> Cale: sure, but I had the impression that I could have as long tuples as I pleased and they were internally somehow treated uniformly
18:47:47 <dolio> OPP?
18:47:50 <edwardk> yeah
18:48:00 <tsou> Cale: but I just saw this: A 64-tuple is too large for GHC  (max size is 62)
18:48:35 <Cale> tsou: ah, right, there's also a hard limit on tuple length, but that's just hardcoded, iirc.
18:48:42 <Nereid> why would you want a 64-tuple
18:48:45 <MostAwesomeDude> tsou: Why do you need such large tuples?
18:48:56 <tsou> MostAwesomeDude: i definitelly don't..
18:49:26 <Cale> The only case where they might reasonably appear is in the output of some code-generator
18:49:28 <tsou> MostAwesomeDude: i was just wondering how they are implemented
18:50:53 <tsou> MostAwesomeDude: (and why would i want a 62-tuple? :P)
18:51:40 <tsou> but I remember reading in a book somewhere that you can have a function like zipWith that would work with arbitrary tuples..
18:51:55 <tsou> the author claimed that it's too advanced for the book and didn't mention anything extra about it
18:52:05 <tsou> i don't remember where I saw this, anyone's familiar with that?
18:52:09 <Cale> tsou: In order to do that, you usually work with nested pairs
18:52:21 <bgamari> Has anyone seen cabal install inexplicably fail with "ExitFailure 139"
18:52:29 <Cale> or perhaps you're thinking of the ZipList applicative instance
18:52:29 <tsou> then that's not advanced at all, it's just "cheating" :P
18:52:29 <geekosaur> 139 is a segfault
18:52:33 <geekosaur> usually
18:52:35 <bgamari> ouch
18:52:48 <bgamari> very strange
18:53:08 <bgamari> damn, very strange
18:53:13 <shachaf> bgamari: If it's printing it, that presumably means that its child is segfaulting.
18:53:14 <geekosaur> (more precisely it;s a segfault filtered through a shell)
18:53:23 <shachaf> strace to the rescue!
18:53:29 <bgamari> shachaf, Yeah, I suspect ghc is segfaulting
18:53:30 <rwbarton> could be running out of memory
18:54:13 <bgamari> time to upgrade to ghc 7.6 and hope for the best
18:54:22 <shachaf> bgamari: You were the person working on the ARM linker thing, right?
18:54:30 * shachaf assumes that was long enough ago that this is unrelated.
18:54:33 <bgamari> shachaf, yep
18:54:38 <geekosaur> mac 64-bit by any chance?  there are some sporadic failures in 7.4.x IIRC
18:54:41 <bgamari> also unrelated
18:54:56 <bgamari> geekosaur, Nope, 32-bit intel
18:56:04 <bgamari> and by intel I mean not a Mac
18:57:19 <shachaf> Hmm, Apple had 64-bit PowerPC computers, right?
18:57:35 <geekosaur> yes
19:09:41 <Puffton> I have just learned that it's possible to create different instances of a class for different types. Is it also possible to create ONE instance of a class that works with MULTIPLE types?
19:10:50 <shachaf> Puffton: You probably shouldn't be worrying about type classes so much right now.
19:11:35 <Puffton> shachaf, how so+
19:11:45 <ddarius> You think people write instances of Show for [[[[(Int, String)]]]]
19:11:47 <ddarius> ?
19:12:43 <Puffton> no, hence the question, because I would like to do it
19:13:22 <cmccann> shachaf, we should write a bunch of type class tutorials to confuse people into avoiding them
19:13:32 <cmccann> empirically speaking that seems to work
19:13:44 <Puffton> I have to use them for school
19:13:49 <shachaf> cmccann: Really? It seems to me to have the opposite effect...
19:14:02 <shachaf> Puffton: Ah, test-driven development.
19:14:47 <cmccann> shachaf, not if the tutorials are written properly!
19:14:52 <cmccann> analogies about space suits seem to help
19:15:12 <cmccann> @quote spacesuit
19:15:12 <lambdabot> syntaxglitch says: a monad is an endospacesuit on a burrito category
19:15:13 <shachaf> cmccann: All those tutorials make people come here and ask *more* questions about monads.
19:15:25 <shachaf> syntaxglitch is you, right?
19:15:29 <cmccann> yes
19:15:42 <shachaf> cmccann: Do you think that Curry-Howard proof game should have dependent types?
19:16:26 <ski> shachaf : why not ?
19:16:33 <cmccann> I don't know. would depend (ha, ha) on how it would work.
19:17:28 <cmccann> if you're going to make a game based on math-y stuff you really need to worry about gameplay and correctness first, subject matter second
19:17:35 <Eduard_Munteanu> Puffton: you could, but the question is, can you write a polymorphic function? Usually you can't do it, that's why you used a typeclass to begin with.
19:17:52 <shachaf> cmccann: I was trying to figure out a good way to represent polymorphism.
19:17:56 <cmccann> how the game is played would have to guide what sort of concepts it used
19:18:09 <shachaf> cmccann: Right.
19:18:17 * hackagebot sloane 0.1.1 - A command line interface to Sloane's On-Line Encyclopedia of Integer Sequences  http://hackage.haskell.org/package/sloane-0.1.1 (AndersClaesson)
19:18:31 <cmccann> I haven't really given it much thought to be honest, would be interested to hear what you had in mind
19:18:35 <cmccann> though maybe not in channel
19:18:43 <cmccann> since that'd be wandering a bit off topic
19:18:50 <Puffton> Eduard_Munteanu, the reason I'm asking is because of the teachers phrasing. He first said to implement one function for each instance, which was easy. Then he said to implement another (with different functionaly), for *all* instances (unless I misunderstood him, he is not 100% clear)
19:18:51 <shachaf> You should join the other channel!
19:19:02 <benmachine> shachaf: fwiw I'm a bit behind and I really like the joke you made five minutes ago
19:19:05 <Puffton> functionality*
19:19:07 <benmachine> it was great
19:19:18 <shachaf> I probably haven't given it enough thought to be able to say something concrete, though.
19:19:28 <benmachine> man, that would sound less weird if it was s/and/but/
19:19:31 <shachaf> benmachine: ?
19:19:42 <shachaf> Oh, at :13?
19:19:46 <benmachine> yes
19:20:06 <benmachine> only marginally less weird, mind
19:20:27 <benmachine> continue doing whatever it was you were doing before I interrupted
19:21:53 <shachaf> cmccann: (You should join the other channel anyway!)
19:22:18 <cmccann> bluh. two channels is already plenty for me.
19:22:52 <shachaf> Pft. Until you're mid-two-digits you're not even getting started.
19:23:06 <Cale> I'm in 20 and I already miss PMs too often.
19:23:10 <benmachine> it's really more active channels than channels taht matters
19:23:23 <benmachine> something like 25% of my channels have anything other than joins or parts in them :P
19:23:26 <Cale> well, 24 actually
19:23:31 <cmccann> shachaf, anyway, one thing I was considering was trying to avoid using names
19:23:37 <cmccann> something closer to combinatory logic
19:23:47 <cmccann> and/or the category theory side of things
19:23:57 <dolio> Cale: Another way to state the iso thing, more categorically, is: Any P : Set -> Type is at worst an invariant functor (predicated on the fact that we can't do case analysis on Set). We should be able to witness that for any particular P we can write in the language. So univalence says, 'if you give me an isomorphism, I'll give you an identity, so that you _can_ map through arbitrary P.' Except it does it for more than 1-functors (I thi
19:23:58 <dolio> nk).
19:23:58 <cmccann> seems more amenable to a visual presentation
19:23:59 <shachaf> cmccann: Combinatory logic? I was thinking of avoiding names by using a directed graph sort of representation.
19:25:38 <benmachine> cmccann: just checking, you've seen this, right? http://logitext.mit.edu/main
19:25:48 <dolio> But then, what does the mapping when you actually use the identity?
19:25:58 <cmccann> benmachine, yes, that's indirectly an inspiration for this conversation
19:26:11 <benmachine> okay, good :P
19:26:24 <cmccann> as well as a blog post about an algebra game I saw somewhere
19:26:50 <dolio> It seems like applying the isomorphism correctly requires walking the structure of P somehow.
19:27:22 <cmccann> shachaf, the details aren't the important thing so much as using a compositional rather than applicative approach
19:27:36 <dysinger> anyone know what happened to the ghc-7.4 branch of the transformers lib ? http://darcs.haskell.org/packages/transformers.git/refs/heads/
19:27:38 <shachaf> cmccann: What do you mean?
19:27:50 <ski> dolio : what is `Set' and `Type' there ?
19:28:16 <cmccann> shachaf, think of those little box-and-line diagrams people like to use when talking about Arrow
19:28:17 * hackagebot sloane 0.1.2 - A command line interface to Sloane's On-Line Encyclopedia of Integer Sequences  http://hackage.haskell.org/package/sloane-0.1.2 (AndersClaesson)
19:29:04 <dysinger> having that transformers branch go missing kills building from the git repo
19:29:21 <ski> (dolio : or differently phrased : what is the difference between the category `Set' and the category `Type' ?)
19:29:53 <dolio> ski: Set is a collection of types that have dimension at most 2. Type may have higher dimensional types.
19:30:25 <cmccann> shachaf, basically trying to avoid needing a visual representation for lambdas, or similar stuff
19:30:33 <cmccann> I've never seen a way of doing that I liked
19:31:05 <applicative> dysinger, kills building ghc-7.4?
19:32:03 <dysinger> ./sync-all checkout ghc-7.4 gives an error for the transformer lib because that branch is missing.  then later explosions because … missing branch.
19:32:14 <shachaf> cmccann: Ah, I was mostly thinking of ways that involved lambdas.
19:32:20 <dolio> ski: There isn't really such type-level distinctions in the usual HTT stuff, though.
19:32:33 <ski> dolio : hm, and it "dimension" the same as the "universe level" concept in Agda ?
19:32:40 <dolio> No.
19:32:46 <shachaf> cmccann: I'd think that doing everything without lambdas would get really awkward.
19:32:59 <shachaf> (@pl style gets awkward in Haskell, certainly.)
19:33:05 <dolio> A type has dimension 0 if there exists an inhabitant such that all other inhabitants are equal to it.
19:33:07 <SLi> If I have class Foo a b where arity :: a -> Int, why cannot I say "instance Foo a b => Foo (b -> a) b where arity f = 1 + arity (f undefined)"? The error is "Ambiguous type variable b0 in the constraint: (Foo a b0) arising from the use of `arity'", but I can't see the ambiguity :-)
19:33:26 <ski> cmccann : i assume you've seen Charity ?
19:33:28 <Cale> dolio: Not "there is a path"?
19:33:39 <Cale> I guess it doesn't matter how you say it :)
19:33:43 <dolio> Sure, whatever.
19:33:50 <dolio> I should say identical, I guess.
19:34:08 <dolio> And a type has dimension 1+n if its identity types have dimension n.
19:34:31 <ski> dolio : so, a subsingleton type doesn't necessarily have dimension `0', then ?
19:34:35 <cmccann> shachaf, with a visual representation showing inputs and outputs being connected, I suspect that in many cases the "pointless" style would look nicer than whatever horrendous thing you do to represent a lambda
19:34:43 <dolio> Cale: For dimension 0 it might as well be equal, though. :)
19:35:08 <cmccann> ski, I'm passingly familiar with it but not in much detail, why?
19:35:13 <dolio> Subsingleton probably has dimension 1.
19:35:16 <dolio> But I'm not certain.
19:35:41 <ski> SLi : if you use `arity' of type `A -> Int', how will it know what type `B' to use for the constaint `Foo A B' ?
19:35:45 <maukd> SLi: because arity :: a -> Int. (f undefined) :: a.
19:35:53 <maukd> SLi: so what's b here?
19:36:10 <ski> cmccann : just that it expresses more things with composition
19:36:24 <dolio> ski: The empty type is a subsingleton, right? But it has dimension 1.
19:37:04 <Cale> dolio: Well, yeah, in that you have a homotopy equivalence to a one-point space. :)
19:37:09 <SLi> Hmm. Ah, I think I can see the problem. Sort of.
19:37:24 <cmccann> ski, oh, right. dunno how much that'd really help as an example though
19:37:31 <ski> dolio : and the identity types for `A' are the types `Id A a0 a1' for every choice of `a0' and `a1' in `A', i take
19:37:44 <dolio> Yes.
19:37:49 <cmccann> since I want to avoid the usual "lines of text" sort of representation as much as possible
19:37:52 <Cale> The definition I saw Voevodsky give was that a type T has h-level 0 if it's contractible, and it has h-level n+1 if for all x,y:T, the space of paths x ~ y is of dimension n.
19:38:11 <dolio> So, dimension 2 is sets.
19:38:27 <shachaf> cmccann: Hmm.
19:38:30 <Cale> and then dimension 3 is groupoids
19:38:34 <dolio> If A is a set, then forall x, y : A. Id A x y is a proposition.
19:38:41 <Cale> and then dimension n is (n-2)-groupoids
19:38:44 <cmccann> shachaf, like I said I haven't given it much detailed consideration
19:38:45 <shachaf> cmccann: I have trouble visualizing the sort of thing you mean. I also have trouble visualizing the sort of thing I mean, come to think of it. :-)
19:38:54 <rwbarton> on the nlab they call this notion "homotopy level" so as to not be horribly confusing
19:39:05 <rwbarton> with the odd shift by 2
19:39:09 <SLi> So, if I'm trying to just determine the arity of functions, then I probably should refactor the arity code into a different class (my current class Foo a b represents functions of the type a -> a -> .. -> a -> b).
19:39:16 <SLi> I think I get it. Thanks :)
19:39:21 <dolio> Yeah.
19:39:32 <cmccann> shachaf, at some point maybe I'll try to sketch out some possibilities
19:39:37 <cmccann> see if I can find something I like
19:39:41 <Cale> rwbarton: Yeah, I like "homotopy level" better too, I think
19:39:53 <rwbarton> though I guess fortunately 2 is large enough that you can usually detect whether a shift by 2 has occurred :)
19:39:55 <JoeyA> I want to code up a simple GUI that's little more than a few circles that you can drag around.  Which of the various GUI platforms would be a good choice?  I'm thinking Elm right now.
19:40:24 <JoeyA> It's a very simple task, but doesn't quite use "widgets".
19:40:41 <ski> SLi : perhaps you actually want `class Foo a b | a -> b where ...' -- or maybe you want to factor as `class Bar a where arity :: a -> Int' and `class Bar a => Foo a b where ..other methods..'
19:40:47 <Cale> If you want to use dimension, you should probably say that the contractible spaces are dimension -2, the truth values have dimension -1, and then sets have dimension 0 :)
19:40:51 <applicative> dysinger,  I'm not sure why it isn't picking this up https://github.com/ghc/packages-transformers
19:41:02 <Cale> and then it agrees with the usual dimensionality for groupoids
19:41:04 <SLi> ski, hmm, maybe. I think I'll go the latter route :)
19:43:20 <JoeyA> Maybe I should try to code it up in Elm, and submit it as an example.  Namely, I want to visualize 2D vector projections.
19:44:20 <dolio> Cale: The other thing which is kind of separate from the univalence stuff, but has the same issues, is higher inductive types.
19:45:09 <dolio> Where, in addition to giving constructors for the type, you get to give inhabitants of the identity types.
19:45:25 <dolio> Which, presumably, have to do something.
19:45:34 <Cale> If you've got fencepost errors, I feel for you son, you got 99 problems and you solved 101.
19:46:34 <dolio> That's the other stuff you'd have to read up on, but I'm pretty sure no one's written that up ultra-formally, either.
19:46:39 <benmachine> *feel bad for you >_>
19:46:50 <Cale> benmachine: FINE
19:46:59 <benmachine> Cale: don't you know your Jay-Z??
19:47:42 * benmachine is grateful to the nature of internet chat that it masked the giant pause before he remembered who actually wrote that song
19:48:37 <Cale> benmachine: I was thinking of xkcd's click and drag map
19:49:07 <benmachine> Cale: I bet there's a "bad" in that too
19:49:15 <benmachine> unfortunately I can't remember where that joke is
19:50:37 <Cale> yeah
19:50:40 <Cale> there was
19:50:49 <Cale> http://xkcd-map.rent-a-geek.de/#10/1.3800/24.7131
19:51:34 <ski> (benmachine : .. song ?)
19:52:13 <benmachine> ski: is that a satirical comment about rap or do you genuinely not know that there's a song involved here :P
19:52:23 <benmachine> or c. other
19:53:36 <ski> benmachine : i have no idea what you(?) said that was related to a song
19:54:12 <benmachine> ski: oh, the whole "feel bad for you son" thing that Cale referred to
19:54:18 <benmachine> it is a song
19:54:28 <ski> oh, ok
19:54:28 <benmachine> well
19:54:30 <Fuuzetsu> @pl f (g x y) z
19:54:31 <lambdabot> f (g x y) z
19:54:41 <Cale> It is a comic which is referring to a song
19:54:44 <benmachine> the origin of the line is a song, it is corrupted for humorous purposes
19:54:55 <Fuuzetsu> @pl p x y z = f (g x y) z
19:54:55 <lambdabot> p = (f .) . g
19:55:11 * ski tends to listen to very little music with vocals/lyrics
19:55:12 <benmachine> the original song is about a gentlemen named Jay-Z, whose problems are numerous
19:55:24 <benmachine> enumerated, in fact
19:55:49 <ski> Fuuzetsu : aka `p = f .: g'
19:55:57 <benmachine> ski: in fairness I don't listen to this either, I just live near people who do >_>
19:56:01 <maukd> countable
19:56:04 <Fuuzetsu> :t (.:)
19:56:05 <lambdabot> forall a b (f :: * -> *) (g :: * -> *). (Functor f, Functor g) => (a -> b) -> f (g a) -> f (g b)
19:56:14 <benmachine> maukd: indeed
19:56:44 <Fuuzetsu> @src (.:)
19:56:44 <lambdabot> Source not found.
19:56:48 <ski> @type let (.) = (Prelude..); infixr 9 .:; (.:) = (.) . (.) in (.:)
19:56:48 <lambdabot> forall b c a a1. (b -> c) -> (a -> a1 -> b) -> a -> a1 -> c
19:57:09 <Fuuzetsu> heh
19:57:31 <Fuuzetsu> going to take a few minutes to let this sink in
19:57:36 <Fuuzetsu> thanks though
19:57:59 <ski>   (f .: g) x y = f (g x y)
19:58:09 <ski>   (f .: g) x y = (f . g x) y
19:58:13 <ski>   (f .: g) x = (f . g x)
19:58:17 * hackagebot hslogger 1.2.1 - Versatile logging framework  http://hackage.haskell.org/package/hslogger-1.2.1 (JohnGoerzen)
19:58:22 <ski>   (f .: g) x = (.) f (g x)
19:58:36 <ski>   (f .: g) x = ((.) f . g) x
19:58:54 <ski>   f .: g = (.) f . g
19:59:03 <ski>   f .: g = (f .) . g  -- aka
19:59:12 <ski>   f .: g = (.) f . g  -- continuing
19:59:39 <ski>   (.:) f g = (.) ((.) f) g
19:59:44 <ski>   (.:) f = (.) ((.) f)
19:59:51 <ski>   (.:) f = ((.) . (.)) f
19:59:56 <ski>   (.:) = ((.) . (.))
20:00:01 <ski> easy, huh ?
20:00:14 <Fuuzetsu> heh
20:00:35 <ski> (and yes, i chose the name `.:' because it has the same number of dots as `(.) . (.)')
20:00:42 * ddarius watches dolio's writing get distorted by Agda.
20:00:50 <maukd> ∴
20:01:15 <maukd> @let (∴) = (.:)
20:01:15 <dolio> Eh?
20:01:16 <lambdabot>  Defined.
20:01:24 <Fuuzetsu> It doen
20:01:28 <Fuuzetsu> oops
20:02:19 <Fuuzetsu> it doesn't seem to exist in any packages; I take it that I have to define it myself then?
20:02:19 <ski> Fuuzetsu : however, using Cale's generalization `(.) = fmap' (in lambdabot), the type for `(.:)' is somewhat more general (as you noted above)
20:02:36 <ddarius> "[22:33] <dolio> And a type has dimension 1+n if its identity types have dimension n."
20:02:43 <dolio> :)
20:02:46 <ski> > (^ 2) .: [Just 0,Nothing,Just 2,Just 3]
20:02:47 <Fuuzetsu> :t dot
20:02:48 <lambdabot> forall a. Strategy a -> Strategy a -> a -> Eval a
20:02:48 <lambdabot>   [Just 0,Nothing,Just 4,Just 9]
20:03:00 <dolio> Totally different from n+1.
20:03:05 <Fuuzetsu> http://www.haskell.org/haskellwiki/Pointfree#Dot
20:03:34 <ski> Fuuzetsu : iirc, it's defined in two or three packages (sorry, i don't recall names)
20:03:48 <maukd> :t (∴)
20:03:49 <lambdabot> parse error (possibly incorrect indentation)
20:04:08 <maukd> > (∴) :: ()
20:04:09 <lambdabot>   Couldn't match expected type `()'
20:04:09 <lambdabot>         against inferred type `(a -> b) -...
20:04:16 <maukd> dot dot dot
20:04:57 * Cale has a very long term plan to get the covariant Hom functor named after him.
20:07:31 * ddarius makes a category of Complex Algebraic Etales.  Then we'd had CAlE(-,f)
20:07:51 <Cale> lol
20:48:18 * hackagebot sloane 0.1.3 - A command line interface to Sloane's On-Line Encyclopedia of Integer Sequences  http://hackage.haskell.org/package/sloane-0.1.3 (AndersClaesson)
21:02:37 <mantovani> hi girls
21:03:08 * stew blushes
21:05:03 <fracture> is there a haskell function similar to perl's split?  (turn a string into [String] based on a separator)
21:05:05 <maukd> hello, DANIEL
21:05:13 <maukd> fracture: Data.List.Split
21:05:39 <fracture> ah there's a bunch of them :)
21:05:40 <fracture> thanks
21:27:54 <coldpizza72i_> This is my work in progress to an insertion sort implementation…http://ideone.com/cqp1e could someone verify if this is insertion sort or not as Im doing it a bit different then how I have always seen it in OO languages
21:30:01 <JoeyA> coldpizza72i_: Mind running that through a compiler first?  y /= null is a type error.
21:30:04 <JoeyA> :t null
21:30:05 <ski> coldpizza72i_ : you seem to be (roughly) on the right track (though you need to fix several things)
21:30:05 <lambdabot> forall a. [a] -> Bool
21:30:22 <coldpizza72i_> thanks guys
21:33:59 <coldpizza72i_> JoeyA: how do i know if y is null then?
21:34:42 <ski> coldpizza72i_ : `null y', in case you want to check whether `y' is the empty *list*
21:34:51 <coldpizza72i_> ohh
21:34:56 <ski> (though better would be to pattern-match on the pattern `[]')
21:35:24 <coldpizza72i_> ski: why would it be better?
21:35:45 <JoeyA> coldpizza72i_: What do you mean by null?  Haskell doesn't have null.  But a list might be "nil", meaning it's empty.
21:35:48 <JoeyA> > null []
21:35:49 <lambdabot>   True
21:35:52 <JoeyA> > null [1,2]
21:35:53 <lambdabot>   False
21:36:01 <JoeyA> > null 123
21:36:02 <lambdabot>   No instance for (GHC.Num.Num [a])
21:36:02 <lambdabot>    arising from the literal `123' at <int...
21:36:14 <ski> coldpizza72i_ : it can make the code more compact, and thus clearer. also it might make things more efficient in some cases, i think
21:36:35 <ion> As we know, more compact code is always clearer.
21:36:43 * ski nods solemnly
21:36:51 <JoeyA> Pattern matching lets you test emptiness and extract values at the same time.
21:37:52 <JoeyA> > let f [] = "and that's it!"; f (x:xs) = show x ++ ", " ++ f xs in "The list contains " ++ f [1,2,3]
21:37:54 <lambdabot>   "The list contains 1, 2, 3, and that's it!"
21:38:28 <JoeyA> As an exercise, get it to just say "The list contains 1, 2, and 3"
21:42:04 <coldpizza72i_> hmm
21:44:27 <coldpizza72i_> I'm not sure i understand the "in" part
21:47:57 <ion> The syntax is “let … in …” where the definitions in the first … are in scope for the second …
21:49:52 <JoeyA> In Elm, can I do this?  type M = (Element, Signal M); machine :: M
21:50:02 <JoeyA> (the type signatures are pseudocode, as Elm can't parse them)
21:50:23 <JoeyA> But the idea is, the machine is an element, paired with a signal which updates the machine.
21:50:37 <JoeyA> That is, a Signal which returns the new machine.
21:50:49 <JoeyA> (this is a sort of Mealy machine, by the way)
21:51:06 <ion> Elm?
21:51:09 <coldpizza72i_> >f [3]
21:51:11 <JoeyA> elm-lang.org
21:51:16 <coldpizza72i_> ?
21:51:33 <JoeyA> > 2+2
21:51:34 <lambdabot>   4
21:51:38 <JoeyA> > f [3]
21:51:39 <lambdabot>   Ambiguous type variable `a' in the constraints:
21:51:39 <lambdabot>    `SimpleReflect.FromExpr ...
21:51:56 <JoeyA> coldpizza72i_: Need a space after the > to get lambdabot to accept it, it seems.
21:52:07 <JoeyA> But f isn't in scope because I defined it locally above.
21:52:18 <fracture> is there a function to randomly shuffle a list?
21:52:40 <JoeyA> http://hackage.haskell.org/package/random-shuffle
21:52:49 <coldpizza72i_> let f [] = ""; f (x:xs) = show x ++ ", " ++ f xs in "The list contains " ++ f [1,2,3]
21:52:58 <coldpizza72i_> > let f [] = "and that's it!"; f (x:xs) = show x ++ ", " ++ f xs in "The list contains " ++ f [1,2,3]
21:53:00 <lambdabot>   "The list contains 1, 2, 3, and that's it!"
21:53:11 <coldpizza72i_> thats what you meant me to do?
21:53:21 <coldpizza72i_> shit
21:53:23 <JoeyA> No, see if you can get it to say "1, 2, and 3".
21:53:34 <coldpizza72i_> > let f [] = ""; f (x:xs) = show x ++ ", " ++ f xs in "The list contains " ++ f [1,2,3]
21:53:36 <lambdabot>   "The list contains 1, 2, 3, "
21:53:54 <coldpizza72i_> without the comma?
21:54:05 <JoeyA> No, "and 3" at the end.
21:54:05 <maukd> and with the "and"
21:54:09 <JoeyA> Special case for the last item.
21:54:14 <coldpizza72i_> oh
21:54:34 <JoeyA> Hint: you can use a pattern to test for a singleton list.
21:54:56 <fracture> JoeyA: I take it there's nothing in standard libs though?
21:54:59 <fracture> (thanks though)
21:55:16 <coldpizza72i_> does x: force the list to one element?
21:55:20 <coldpizza72i_> for input?
21:55:25 <fracture> ah nm; it looks like platform includes that by default
21:55:48 <JoeyA> coldpizza72i_: (x:xs) says the list has one or more items.
21:56:02 <coldpizza72i_> yes i mean just x:
21:56:03 <JoeyA> See if you can guess the pattern for a list of exactly one item.
21:56:08 <JoeyA> Oh
21:56:19 <coldpizza72i_> or mayb x:[]
21:56:22 <JoeyA> (x:) is a syntax error (as a pattern).
21:56:29 <JoeyA> (x:[]) would work, yes.
21:56:44 <JoeyA> You can also say [x].
21:57:09 <JoeyA> [a,b,c] is shorthand for (a : (b : (c : [])))
21:57:46 <JoeyA> Since : is right associative, you could also say (a : b : c : []).  I was just making the conses explicit.
22:00:39 <coldpizza72i_> > let f (x:[]) = show " and " ++ x; f (x:xs) = show x ++ ", " ++ f xs in "The list contains " ++ f [1,2,3]
22:00:40 <lambdabot>   No instance for (GHC.Num.Num GHC.Base.String)
22:00:40 <lambdabot>    arising from the literal `...
22:01:58 <JoeyA> " and " ++ show x
22:02:05 <JoeyA> show turns a thing into a string.
22:02:07 <JoeyA> :t show
22:02:08 <lambdabot> forall a. (Show a) => a -> String
22:03:07 <JoeyA> " and " is already a string
22:03:13 <coldpizza72i_> > let f (x:[]) = " and " ++ show x; f (x:xs) = show x ++ ", " ++ f xs in "The list contains " ++ f [1,2,3]
22:03:15 <lambdabot>   "The list contains 1, 2,  and 3"
22:04:04 <JoeyA> Good
22:04:18 <JoeyA> Now see if you can make it handle an empty list gracefully, too.
22:04:31 <JoeyA> e.g. "The list contains nothing" if the list is empty.
22:04:44 <JoeyA> > let f (x:[]) = " and " ++ show x; f (x:xs) = show x ++ ", " ++ f xs in f []
22:04:46 <lambdabot>   "*Exception: <interactive>:3:4-66: Non-exhaustive patterns in function f
22:06:41 <coldpizza72i_> > let f [] = "The list is empty"
22:06:42 <lambdabot>   not an expression: `let f [] = "The list is empty"'
22:07:05 <coldpizza72i_> > let f [] = "The list is empty" in []
22:07:06 <lambdabot>   []
22:07:23 <coldpizza72i_> lie that?
22:07:25 <coldpizza72i_> like*
22:07:49 <coldpizza72i_> JoeyA: ^
22:09:19 <JoeyA> Well, that only handles an empty list.  What if I pass f [1,2,3] now?
22:09:40 <MostAwesomeDude> > let f [] = "What now?" in [1]
22:09:41 <lambdabot>   [1]
22:09:47 <MostAwesomeDude> > let f [] = "What now?" in f [1] --derp
22:09:48 <lambdabot>   "*Exception: <interactive>:3:4-21: Non-exhaustive patterns in function f
22:14:26 <coldpizza72i_> > let f [] = "The list contains nothing"; f (x:[]) = " and " ++ show x; f (x:xs) = show x ++ ", " ++ f xs in f []
22:14:27 <otters> > let f ~[] = "hello" in f [1]
22:14:28 <lambdabot>   can't find file: L.hs
22:14:28 <lambdabot>   "The list contains nothing"
22:14:34 <otters> huh
22:14:42 <coldpizza72i_> JoeyA: ^
22:14:59 <ski> > let f ~[] = "hello" in f [1]  -- like this
22:15:00 <lambdabot>   "hello"
22:15:24 <Havel0c> Hi I was wondering where I could find the source code for the built in sin and cosine functions
22:15:48 <Havel0c> I am assuming they are written in haskell
22:16:03 <ddarius> Why do you assume that?
22:16:27 <JoeyA> hackage.haskell.org/packages/archive/base/latest/doc/html/src/GHC-Float.html
22:16:32 <JoeyA> instance  Floating Double  where
22:16:42 <JoeyA> That of course just redirects you to sinDouble
22:17:23 <JoeyA> If you dig in the source, you see: sinDouble (D# x) = D# (sinDouble# x)
22:17:33 <ddarius> And all is clear.
22:18:00 <Havel0c> ah thank you, and ddarius: no real reason
22:18:21 <JoeyA> And I don't know exactly where sinDouble is defined...
22:18:34 <shachaf> JoeyA: You just gave its definition.
22:18:35 <JoeyA> err, sinDouble#
22:19:51 <shachaf> It's a primop. You probably won't find its definition in Haskell.
22:20:42 <coldpizza72i_> JoeyA: is ^^that^^ what you meant?
22:20:44 <shachaf> See compiler/prelude/primops.txt
22:23:05 <ddarius> Youn In-Wan had a very long view.
22:23:34 <ddarius> Perhaps Intel or AMD will provide you with their VHDL files.
22:24:18 <Havel0c> Perhaps
22:26:00 <shachaf> ddarius: Maybe I'll settle for reading the qemu source.
22:31:14 <JoeyA> coldpizza72i_: Yes
22:31:39 <JoeyA> > let f [] = "The list contains nothing"; f (x:[]) = " and " ++ show x; f (x:xs) = show x ++ ", " ++ f xs in (f [], f [1], f [1,2], f [1,2,3])
22:31:41 <lambdabot>   ("The list contains nothing"," and 1","1,  and 2","1, 2,  and 3")
22:32:04 <JoeyA> err, not quite.  But close enough
22:33:48 <coldpizza72i_> JoeyA: I'm still having some trouble with my insertion sort, heres what i have so far http://ideone.com/7sIM9
22:33:55 <Havel0c> we have been given a language that is kind of haskell-like ( called Flange) and a program which takes the  code and outputs a svg. But it lacks a sin and a cos so I was hoping to extend it
22:35:18 <Havel0c> it doesnt really matter that I cant though because I have the source of the svg making program which is in C so I can change it on that level I guess
22:36:30 <JoeyA> coldpizza72i_: x:insert(y xs)
22:36:39 <JoeyA> Do you mean x : insert y xs
22:36:52 <JoeyA> insert(y xs) is applying xs to y, which isn't a function.
22:37:07 <coldpizza72i_> oh
22:37:08 <maukd> *y to xs
22:44:17 <coldpizza72i_> hmm, now I'm getting non exhaustive patterns in insert but don't see why
22:45:12 <shachaf> coldpizza72i_: Compile with -Wall
22:45:19 <shachaf> You should do that anyway.
22:45:43 <coldpizza72i_> I'm using ghci, plus it compiles fine, its when i call the function
22:47:16 <maukd> ...
22:48:08 <coldpizza72i_> ...?
22:48:45 <ew0_> hello
22:48:51 <ew0_> I want to output to some files
22:48:53 <shachaf> coldpizza72i_: Exactly.
22:48:59 <ew0_> and I'm a noob
22:49:09 <ew0_> I know how to output to 1 file
22:49:10 <coldpizza72i_> shachaf: exactly what?
22:49:31 <shachaf> coldpizza72i_: Exactly "...", I think.
22:49:38 <shachaf> You should listen to maukd about this sort of thing.
22:49:47 <JoeyA> Sorry if I crashed elm-lang.org, folks.
22:49:52 <ski> coldpizza72i_ : maybe you should consider what e.g. `insert 4 [0,1,2]' should result in
22:49:52 <ew0_> but I want to output a list with (fileNames, stuff)
22:50:04 <shachaf> coldpizza72i_: Do you know what "-Wall" is?
22:50:13 <coldpizza72i_> a flag?
22:50:34 <shachaf> Correct!
22:51:06 <fracture> what's the best way to remove a suffix from a String?
22:51:27 <ddarius> Poor shachaf.  He's like copumpkin of a year ago.
22:51:43 <shachaf> ddarius: Uh-oh. What was copumpkin of a year ago like?
22:52:09 <Nisstyre-laptop> just a pumpkin?
22:52:23 * shachaf suspects the answer will be "you".
22:52:30 <coldpizza72i_> im so confused
22:52:47 <Nisstyre-laptop> coldpizza72i_: go read learnyouahaskell
22:52:50 <shachaf> coldpizza72i_: You should find out what "-Wall" does, and then use it. :-)
22:53:07 <coldpizza72i_> Nisstyre-laptop: that will tell me about pumpkins?
22:53:15 <Nisstyre-laptop> on that note, RWH sorely needs updating
22:53:32 <ddarius> Nisstyre-laptop: To include pumpkins?
22:53:41 <Nisstyre-laptop> ddarius: yes, exactly
22:53:44 <Nisstyre-laptop> and copumpkins
22:54:04 <Nisstyre-laptop> the dual to pumpkins
22:54:38 <shachaf> It needs a discussion of the pumpkin lemma.
22:54:50 <Nisstyre-laptop> ddarius: but seriously, a lot of things have changed in the time it was last updated
22:55:21 <shachaf> Nisstyre-laptop: That's why they were working on an update.
22:55:24 <shachaf> Look it up.
22:55:37 <Nisstyre-laptop> shachaf: cool, I figured they were working on it
22:56:03 <shachaf> They had a Survey and everything!
22:56:17 <Nisstyre-laptop> nice! I assume it was on one of the MLs?
22:56:32 <shachaf> I don't remember.
22:56:54 <Nisstyre-laptop> shachaf: do you think it would be possible to translate SICP into Haskell?
22:57:18 <shachaf> Not line-by-line?
22:57:21 <Nisstyre-laptop> I wonder if the license prevents that, but apparently there's a textbook by Carnegie Mellon that is SICP with python
22:57:43 <Nisstyre-laptop> shachaf: so maybe take the general concepts and examples and translate them using my own words?
22:57:53 <ddarius> An SICP using Haskell would have pretty different emphases.
22:57:57 <shachaf> Some things carry over, but I'd imagine that you're better off taking it as inspiration and writing a Haskell book.
22:57:58 <Nisstyre-laptop> like I would use a source in a research paper?
22:58:17 <shachaf> Disclaimer: I haven't read most of SICP.
22:58:25 <Nisstyre-laptop> shachaf: I kind of figured that. Also I wouldn't be the one to do this.
22:58:29 <ddarius> shachaf: You should read it.
22:58:51 <Nisstyre-laptop> shachaf: it essentially covers lambda calculus in the first few chapters without naming any of the concepts.
22:59:15 <Nisstyre-laptop> e.g. it talks about how you would evaluate things, but it doesn't say "beta reduction"
22:59:25 <shachaf> ddarius: That's probably true.
22:59:48 <Nisstyre-laptop> it also covers writing a parser for Scheme later on, and a register machine
23:00:59 <Nisstyre-laptop> shachaf: some things would obviously not translate at all, like the one question about writing "if" as a procedure
23:01:08 <Nisstyre-laptop> the "naive" version actually works due to lazy evaluation
23:12:14 <ew0_> mapM_ does the job!
23:15:18 <ew0_> gn ppl
