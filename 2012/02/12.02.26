00:00:38 <Schadenfr> whos shapr
00:01:19 <kowey> dmwit: ping
00:01:41 <ddarius> lispy: Review of what?
00:03:20 <dolio> Was it a review of the 55 gallon drum of lube they have for sale?
00:03:52 * ddarius wonders why dolio knows that Amazon was selling a 55 gallon drum of lube.
00:03:52 <tsanhwa> hi, I am cabal-installing webkit hackage on windows, and get a error: pkg-config pckage webkit-1.0 version > 1.1.15 is required but could be not found
00:03:57 <tsanhwa> does it mean I have to install webkit by myself?
00:04:10 <dolio> I happened upon it a while back. I forget how.
00:04:31 <ddarius> Perhaps it was a suggested search item or a recommendation.
00:04:56 <dolio> Yeah, probably. Weird stuff pops up there occasionally.
00:12:15 <Ngevd> You know what annoys me?
00:12:22 <Ngevd> Pattern matching on sequences
00:13:25 <Saizan> tsanhwa: pkg-config is a linux (unix?) tool to find metadata about installed C libs
00:14:01 <Saizan> tsanhwa: anyhow you are supposed to install the C webkit lib youself
00:17:25 <Ngevd> It should be possible to do foo (xs|>x) = x
00:17:31 <Ngevd> But alas, it is not
00:17:54 <Cale> You can use pattern guards
00:18:19 <Cale> or ViewPatterns
00:18:20 <Saizan> or view patterns
00:18:47 <Ngevd> Hmm
00:20:09 <Cale> As an aside, pattern guards are really really cool syntactically for cases where you have a lot of GADTs carrying type evidence around and you want to match on a bunch of them to make use of it all.
00:25:24 <Ngevd> Hmmmmmm
00:26:04 <The_Journey> hi, I installed a Haskell package using the --user option, how can I use the installed package now using ghc?
00:27:53 <The_Journey> nvm :)
00:33:15 <Sgeo> bbbbiblbbloble
00:33:17 <Sgeo> http://kawagner.blogspot.com/2007/02/understanding-monads-for-real.html
00:38:15 <shergill> as the last step of my haskell program i want to invoke a shell command. i'd like to not have to do it manually, leaving the option of invoking that shell command through haskell, or writing a shell wrapper for the command. what's the easiest/simplest way to achieve the former?
00:40:51 <shergill> ok rawSystem does the job
00:52:15 <drbean> I wasn't too sure if ghc's -o flag would name the executable or the object file. But it names the executable.
01:11:33 <otk_> if a man speaks his mind in the forest and no woman hears him, is he still wrong
01:11:50 <zzo38> How many people want to define a monad using join instead of bind?
01:14:23 <zxj> which module should i use when i want to develop a GUI interface using ghc win32 ver?
01:16:07 <osa1> how can I pattern match a one element list?
01:16:31 <ivanm> [x]
01:16:33 <ivanm> osa1: ^^
01:24:15 <isBEKaml> hi, is hackage down right now? cabal update and pings elicit no response...
01:37:18 <yitz> isBEKaml left, but for the record, hackage seems to be fine from here
01:41:39 * hackagebot yesod-auth-oauth 0.8.0 - OAuth Authentication for Yesod.  http://hackage.haskell.org/package/yesod-auth-oauth-0.8.0 (HiromiIshii)
02:00:02 <Taneb> Hello!
02:02:19 <Taneb> I could really do with an Ord instance for IORefs
02:02:53 <Taneb> For one of my silly family tree programs
02:03:48 <ddarius> You could probably make one with a bit of hackery.
02:04:01 <ddarius> I don't know if it would be reliable though.
02:04:20 <opqdonut> or you could make your own IORef wrapper that includes a numerical id
02:04:25 <MostAwesomeDude> ^^
02:04:28 <ddarius> There might be an hash instance.
02:06:27 <shachaf> Why bother worrying? Just do what Pugs does!
02:06:28 <shachaf> https://github.com/perl6/Pugs.hs/blob/master/Pugs/src/Pugs/AST/Types.hs#LC380
02:07:06 <opqdonut> oh, I didn't know it'd be that easy
02:07:18 <shachaf> Note: Don't actually do that.
02:09:33 <geekosaur> heh
02:09:41 <MostAwesomeDude> What's addressOf? Hoogle doesn't know it.
02:09:48 <Taneb> Hayoo does
02:09:53 <Taneb> http://hackage.haskell.org/packages/archive/MetaObject/latest/doc/html/MO-Util.html#v:addressOf
02:10:24 <Taneb> But I don't think that's i
02:10:24 <Taneb> t
02:10:58 <efie> when using dropWhile, can i somehow count how many items in the list have been dropped?
02:11:08 <opqdonut> no
02:11:14 <opqdonut> but you could use break instead
02:11:16 <opqdonut> :t break
02:11:17 <lambdabot> forall a. (a -> Bool) -> [a] -> ([a], [a])
02:11:27 <shachaf> Or zip.
02:11:41 <efie> i will check it out, thanks
02:12:11 <opqdonut> shachaf: right
02:13:33 <shachaf> > first head . unzip . dropWhile (isUpper . snd) . zip [0..] $ "ABCDefgh"
02:13:35 <lambdabot>   (4,"efgh")
02:15:02 <opqdonut> > first length $ break isUpper "abcdEFGH"
02:15:03 <lambdabot>   (4,"EFGH")
02:15:12 <opqdonut> I like mine better :)
02:15:27 <shachaf> Yours does extra work.
02:15:34 <opqdonut> no, yours does
02:15:44 <opqdonut> mine doesn't cons
02:16:11 <opqdonut> okay it might if the implementation of break doesn't use build
02:16:58 <opqdonut> but isn't the zip/unzip extra work?
02:17:21 <Algo> Any chance learning Haskell is doable over the summer?
02:17:26 <Taneb> Yes
02:17:27 <opqdonut> sure
02:17:37 <Taneb> I would start with Learn You A Haskell
02:18:03 <Taneb> http://learnyouahaskell.com/introduction
02:18:19 <opqdonut> the problem with LYAH is it doesn't have (enough) exercises
02:18:22 <opqdonut> but otherwise it's nice
02:18:28 <Skola> I can recommend "Programming in Haskell" if you're looking for a paperback to get you started
02:18:31 <Algo> Taneb:  you need to learn some category theory  to be able to do some non-trivial stuff in Haskell, no?
02:18:36 <opqdonut> no
02:18:39 <opqdonut> absolutely not
02:18:51 <Taneb> I never have
02:19:10 <Algo> opqdonut Taneb would it help?
02:19:17 <opqdonut> ... probably not
02:19:27 <Taneb> Just dive right in
02:19:35 <Algo> to understand Monads and stuff
02:19:36 <OreoGirl>  Please Click Link and Like My Photo on FB For Competition: http://www.facebook.com/photo.php?fbid=10150695579957502&set=a.10150655271852502.448424.341799172501&type=1&theater
02:19:44 <Taneb> Monads just need practice
02:19:45 <opqdonut> Algo: Monads are about as hard to understand as Objects
02:19:57 <opqdonut> and like Objects, they can be understood through practice
02:20:59 <Algo> opqdonut: objects aren't hard to understand
02:21:15 <Taneb> I don't understand them
02:21:32 <Taneb> And I'm decent at Monads
02:21:50 <opqdonut> Algo: are you sure? or maybe you've just gradually learned them while getting stuff done
02:22:00 <opqdonut> that's the best approach to monads too. get stuff done.
02:22:06 <opqdonut> or at least, it worked for me
02:22:34 <efie> are there any excercises in which one has to decide if and how a monad could be useful and so on?
02:23:04 <Algo> Taneb: but I want to be able to actually understand them
02:23:33 <opqdonut> you can understand how Haskell Monads work without knowing category theory
02:23:45 <Algo> opqdonut: category theory can be pretty helpful in understanding Haskell's type system, no?
02:23:48 <opqdonut> if you want to understand how Category Theory Monads work, go read a CT book
02:23:52 <Algo> opqdonut Taneb The only thing that's relatively new to me is defining functions/objects inside other functions or objects.
02:23:53 <opqdonut> no, not really
02:23:55 <Algo> That's something that sort of surprises me (past anonymous functions) that seems odd.
02:24:10 <opqdonut> Haskell's type system doesn't have that much to do with category thery
02:24:10 <Taneb> Just dive in!
02:24:16 <Taneb> Everything will be made clear
02:24:17 <opqdonut> it has stuff to do with type systems
02:24:25 <Algo> But understanding things like abstracting or instantiating, that makes sense....
02:24:35 <opqdonut> (the theory of type systems)
02:24:37 <Skola> make things, fail, read, make things, fail, read
02:24:43 <Algo> Or even scoping in general (although Java's "final" type is redundant to me sometimes)
02:27:24 <efie> now i changed a function from "isAlreadythere dat datas = not $ null (dropWhile (((not .) . isPrefixOf) (unwords (take 2 (words dat)))) datas)" to "isAlreadyThere dat datas = not $ null $ fst (break (((not .) . isPrefixOf) (unwords (take 2 (words dat)))) datas)" and then GHCi says: *** Exception: data.txt: openFile: permission denied (Permission denied). I use data.txt to load the "datas"
02:27:56 <Taneb> I suppose it's pointless to say that unsafeCoerce is unsafe
02:28:24 <efie> so after rewriting it with break this exception occurs
02:29:08 <geekosaur> efie, did you by any chance write data.text from the same ghci?  more likely is for some reason the file is still open, the ghc runtime prevents it from being  reopened for reading in that case (per current haskell standard, although I think that's being reconsidered)
02:30:48 <Algo> I'd rather just start with something incredibly complicated
02:30:54 <Algo> I know well over 20 languages and I can probably pick up things instantly
02:31:02 <efie> "did you by any chance write data.text from the same ghci? " what do you mean with this? no, the fill is closed, and if i swap the definition of the function isAlreadyThere to the "dropWhile" solution it works again
02:31:03 <Algo> you know, I do like Mathematica's syntax a bit more than any other language
02:31:03 <Taneb> No
02:31:06 <Algo> For example, everything in mathematica is a List
02:31:08 <efie> file*
02:31:12 <Taneb> Start with the basics
02:31:27 <Algo> In the sense that there are at least two items ie: a = 2;in mathematica.
02:31:34 <Taneb> If you're as scared as monads as you seem, learn them naturally
02:31:36 <Algo> if I did a[[0]] (first element)it returns "Integer"a[[1]] and a both return '2'...it's clever
02:31:48 <maurer> Algo: Have you tried Lisp?
02:34:28 <Algo> maurer: Lisp/Scheme can screw themselves
02:34:35 <Algo> NOBODY NEEDS THAT MANY PARENTHESES :{
02:34:43 <maurer> Algo: I thought you were just saying how you wanted everything to be a list...
02:35:15 <zerax> Alternatively, write your own Monad typeclass. Then write instances for [], Maybe, Either, and define >>=, >>, return, join, ap, sequence for them.
02:35:27 <zerax> If you're still alive by the end of it, you've probably worked out how Monads worked
02:35:33 <zerax> -ed
02:35:50 <companion_cube> what's the problem with parentheses?
02:36:16 <Algo> maurer: Well, Mathematica's way of using lists/arrays for typing is brilliant.
02:36:20 <Algo> And you might see a LOT of similarities with Mathematica and Haskell
02:36:23 <Algo> infix/prefix and whatnot
02:36:33 <Algo> In fact, a lot of what they mention in the LYAH - I can name a mathematica equivalent so far. http://learnyouahaskell.com/starting-out
02:36:34 <Algo> Especially infinite lists and such.
02:36:41 <Algo> companion_Nothing, except Scheme uses too many. >.>
02:37:57 <albel727> companion cube lol.
02:38:03 <Dodek> maurer: how is "everything is a list" related to lisp?
02:38:11 <albel727> BUT YOU MUST BE DEAD! I'VE KILLED YOU WITH MY OWN HANDS!
02:38:14 <opqdonut> yeah mathematica is like haskell in many ways
02:38:42 <companion_cube> Dodek: because the code itself is a list in lisps
02:39:01 <opqdonut> Algo: you know what? once you code some lisp you stop seeing the paretheses. also, lines like "NOBODY NEEDS THAT MANY PARENTHESES :{" are very immature :)
02:39:23 <albel727> yeah. code as list is what makes lisp cool.
02:40:02 <opqdonut> OTOH, I think higher-order functions make a lot of macros look stupid
02:40:52 <Dodek> companion_cube: but it's not relevant. the point is that the code in lisp is _data structure_.
02:41:18 <albel727> which makes posiible brilliant things like lisp macros.
02:41:18 <companion_cube> Dodek: and this data structure happens to be a list
02:41:23 <Algo> opqdonut: But tbh, every language has a specific syntax which makes it addictive.
02:41:25 <Algo> Python is there for being incredibly readable - like Coffeescript.
02:41:36 <companion_cube> what is the problem with this statement?
02:41:43 <Algo> PHP just has automagic. It's like sex, dirty sex.
02:42:01 <Algo> Java is BIG on OOP
02:42:13 <Algo> C,C++ for memory allocation, pointers, and goddamned leaks
02:42:16 <Dodek> companion_cube: this is more or less correct -- more for common lisp and less for scheme
02:42:50 <Dodek> companion_cube: my problem is that "everything is a list" is really, really misleading
02:42:51 <companion_cube> Dodek: which other data structures are used to represent code in scheme?
02:43:16 <companion_cube> Dodek: I did no say that, I said the code was lists
02:43:21 <companion_cube> nested lists, in fact
02:43:24 <Algo> Mathematica is almost brilliant in defining functions by matching patterns of arguments (they overload functions by default), using upvalues/downvalues
02:43:33 <Algo> Matlab is natural with matrices
02:43:45 <Dodek> companion_cube: i've seen people believe that there's no other data structure in lisp than lists
02:43:58 <companion_cube> I know there are other data structures
02:44:18 <albel727> everyone knows, that there are other data structures in lisp.
02:44:23 <Dodek> companion_cube: of course you did not say that, but my first line directed to maurer, as you can read in a backlog.
02:44:40 <companion_cube> yes, ok
02:44:51 * ddarius is not sure he'd say Mathematica is like Haskell is many ways.  I may even say it's not like Haskell in any way.
02:44:54 <Algo> Mathematica's pattern matching got me hooked
02:44:59 <Algo> they also create functions with conditionals almost incredibly straightforward for instance
02:45:24 <Algo> f[x_List] = (some operation on x) /; x//Length > 10
02:45:36 <companion_cube> a partial function?
02:45:39 <Ngevd> >ModifiedJulianDay (-678941)
02:45:45 <Ngevd> > ModifiedJulianDay (-678941)
02:45:46 <lambdabot>   Not in scope: data constructor `ModifiedJulianDay'
02:46:09 <Dodek> companion_cube: with regard to the code being list in scheme -- neither in common lisp, nor in scheme the code as written in a file is a list
02:46:09 <Algo> f[{1,2,3,4}] will return null  while f[{1,2,3,4,5,6,7,8,9,10,11}]  will return that operation
02:46:26 <companion_cube> Dodek: yes, it's several lists...
02:46:46 <Algo> and the amount of time taken is surprisingly faster than creating a function that does something like myFunc (list) if length(list) > 10:
02:46:46 <Algo>  return null  //do something
02:46:49 <Dodek> companion_cube: no, i'm talking about things like quasiquote or reader macros.
02:46:50 <companion_cube> but i think that you can read a file at runtime as a list of (quoted) lisp lists?
02:47:04 <opqdonut> Algo: haskell has guards, which are kinda like that
02:47:18 <opqdonut> Algo: except you need to specify all the cases since there is no "null"
02:47:36 <Dodek> companion_cube: (let ((x 3)) `(x ,x))
02:47:49 <Dodek> companion_cube: this code will return a list (x 3)
02:47:52 <opqdonut> like "f xs | length xs > 10 = map something xs; | otherwise = []"
02:48:05 <opqdonut> that looks really messy on one line, you're supposed to line up the |s :)
02:48:16 <Dodek> companion_cube: but the code is not a list, because ` and , is not part of a list printed representation
02:48:17 <companion_cube> Dodek: isn't it sugar for  (let ((x 3)) (quasiquote (x ,x)))?
02:48:23 <ddarius> opqdonut: Actually, your syntax is just wrong.
02:48:25 <companion_cube> i forgot for the ,
02:48:27 <ddarius> | doesn't introduce layout.
02:48:32 <opqdonut> ddarius: oh, okay
02:48:37 <Algo> opqdonut: like say f[x_List] ^= (operation on list) /; Length[list] > 10
02:48:40 <opqdonut> I never do it on one line :D
02:48:49 <companion_cube> so ok, if you want to be really picky and cut hairs in four, code is not always simply lists
02:48:56 <companion_cube> but as a first approximation...
02:49:06 <Dodek> companion_cube: it's not easy to answer to this question
02:49:17 <ddarius> > let f xs | length xs > 10 = map (join (*)) xs | otherwise = [] in f [1,2,3]
02:49:17 <lambdabot>   []
02:49:25 <Dodek> companion_cube: let me give another example, this only works in common lisp
02:49:53 <Dodek> companion_cube: (princ #.(find-counterexample-to-goldbach-conjecture))
02:50:09 <Dodek> (of course you need to define the find-... function yourself)
02:51:01 <Dodek> companion_cube: it's not a list, and you cannot really tell what's this a sugar for. it may not even be a readable piece of code, because this function may not halt
02:51:04 * ddarius would not drink too much of the "everything is a list" or "code is data" Lisp Kool-Aid.
02:51:26 <companion_cube> is "most code is a list" ok?
02:51:34 <ddarius> companion_cube: No.
02:51:38 <companion_cube> or are you going to keep finding specific countre examples?
02:51:48 <companion_cube> counter*
02:51:48 <Dodek> companion_cube: let me present my point
02:52:28 <ddarius> Lisp processes "pairs" but even then the lexical syntax is strings and the abstract syntax is a rose tree, but really it's an abstract syntax tree like any other language, they just happen to use a rather uniform, untyped representation for it.
02:52:34 <Dodek> companion_cube: nevertheless, if there's a counterexample to goldbach conjecture and this function will find it, the common lisp reader will read this piece of code and will actually represent it as a list for you to play with
02:52:48 <Dodek> companion_cube: the way it works in scheme is different, though.
02:53:06 <ddarius> Really, the strength of Lisps in this area is that this abstract syntax is standardized and has standard ways of getting and manipulating it.
02:53:08 <companion_cube> ddarius: that's what i call 'lists', since they are heterogeneous, there is no difference with a tree
02:54:11 <ddarius> There is nothing terribly special about the syntax of Lisps.
02:54:41 <opqdonut> agreed
02:54:49 <Ngevd> It's just unusual notation
02:55:22 <opqdonut> forgetting the macros for a while, they're nice dynamic programming languages with no weird corner cases. they also support functional programming prettty well.
02:55:23 <Algo> f[x_List] ^= (operation on list) /; Length[list] > 10which assigns the ownership of f to Lists rather than the namespace of 'f' It declutters magically, but it's fucking confusing :/
02:55:27 <Dodek> companion_cube: in r5rs scheme, the most important way to write macros was syntax-rules, and if you think about it for a while, it turns out that the fact the code is a list is not really relevant to the way syntax-rules works
02:55:27 <Algo> Man, the one thing PHP doesn't have is list comprehensions
02:55:34 <Algo> MAN
02:55:35 <Algo> L.
02:55:36 <Algo> :.
02:55:40 <Algo> But to be honest, I haven't thought up a case where it might need it
02:55:46 <Algo> Only because PHP's brilliance is dealing with HTTP GET, POST, Sessions, and Cookies
02:56:22 <Algo> The fact is, since everything is passed as strings, there's a reason why PHP works against a more strongly-typed language
02:56:26 <companion_cube> Dodek: oh, really? I thought macros were supposd to produce syntax trees (or lists)?
02:56:40 <Dodek> companion_cube: they certainly work the way you describe in common lisp
02:58:04 <Dodek> companion_cube: but in scheme (r5rs) they work a bit like hmm unix sed, but on structures, not text
02:58:38 <mmcdermo> :q
02:58:51 <companion_cube> wait, since sed transforms text into text, macros would transform structures into structures... which is what I said?
02:59:31 <Dodek> companion_cube: but the way you transform them in scheme is much more constrained compared to common lisp
02:59:51 <companion_cube> ok, but you still produce a syntax tree
03:00:49 <Dodek> companion_cube: it's not you who produce a syntax tree. just like in sed, it's sed who transforms the text, you only provide a rules for a transformation
03:01:13 <Dodek> companion_cube: but what you can achieve with sed is a strict subset of what you can achieve with C
03:01:24 <companion_cube> Dodek: but my point is still valid, you manipulate lists in the end
03:02:10 <Dodek> companion_cube: not really. it seems that i'm unable to explain it, so it seems that the only way is for you to find someone better at explaining than me, or see for yourself
03:03:47 <ddarius> http://docs.racket-lang.org/guide/stx-obj.html
03:04:28 <lukish> if `take 4` takes first 4 elements, how can I get last 4 elements?
03:05:23 <ddarius> There isn't a predefined function in the standard library that does that as it's not the type of thing you should be doing on a singly-linked list.
03:05:30 <albel727> sed is turing complete. how come C could do any better than that?
03:05:33 <ddarius> You could reverse . take 4 . reverse which illustrates the cast
03:05:37 <ddarius> s/cast/cost/
03:13:06 <zhulikas> @t Word8 -> Char
03:13:06 <lambdabot> Maybe you meant: tell thank you thanks thx ticker time todo todo-add todo-delete topic-cons topic-init topic-null topic-snoc topic-tail topic-tell type . ? @ ft v
03:13:32 <zhulikas> how can I convert [Word8] to human-readable content?
03:14:33 <DevHC> zhulikas: show xs
03:20:25 <hpaste> zhulikas pasted “that's what I try to do” at http://hpaste.org/64362
03:20:49 <zhulikas> in ghci
03:21:19 <Saizan> what you consider human-readable?
03:21:38 <zhulikas> I need to extract some data from this ByteString
03:21:57 <zhulikas> so, uhm... letters?
03:22:37 <Saizan> it'd be better to use Data.ByteString.Lazy.Char8 then
03:22:57 <zhulikas> ok
03:23:01 <zhulikas> I'll look into it
03:23:08 <Saizan> and just use L.putStrLn, probably
03:23:26 <Saizan> though if this is text, you might want Data.Text instead
03:44:39 <mikeplus64> @src many
03:44:39 <lambdabot> Source not found. My mind is going. I can feel it.
03:47:41 <zerax> @src Control.Applicative.many
03:47:41 <lambdabot> Source not found. Have you considered trying to match wits with a rutabaga?
03:48:26 <mikeplus64> > many []
03:48:27 <lambdabot>   [[]]
03:48:30 <mikeplus64> > many [1]
03:48:34 <lambdabot>   mueval-core: Time limit exceeded
03:48:47 <osa1> I'm new at this monad stuff, how can I work with a State monad and do IO in the same function?
03:48:49 <mikeplus64> can someone clarify the point of many to me? :(
03:49:27 <Peaker> osa1: It depends on which kind of combination you want
03:50:02 <zerax> :t get (undefined :: StateT [Int] IO Char)
03:50:03 <lambdabot> forall s. (MonadState s ((->) (StateT [Int] IO Char))) => s
03:50:07 <osa1> Peaker: what do you mean by combination? I want to update my state and then print some stuff, for example
03:50:10 <Peaker> osa1: The most common form of combination is using the State monad transformer, which is a generalized form of the state monad, that can compose with another monad
03:50:30 <Peaker> osa1: So instead of   State s a   You get something like:   StateT s IO a
03:50:44 <Peaker> osa1: StateT s IO a     is a monad that can do both State and IO actions
03:51:03 <osa1> Peaker: ok, just curiosity, what if I want to work with 3 different monads?
03:51:29 <Peaker> osa1: Then you transform the monad again, e.g:   MaybeT (StateT s IO) a
03:52:08 <Peaker> osa1: ContT r (MaybeT (StateT s IO)) a  -- transformed once more :)
03:52:18 <Peaker> osa1: Do you know what the kind "* -> *" is?
03:52:34 <osa1> Peaker: ok, thanks. I'm trying to write a simple game with SDL and I'm not sure if I'm on the right direction, is using StateT with IO good option?
03:52:46 <osa1> Peaker: I think it takes a type and then returns a new type
03:52:54 <zerax> It depends what you want to model
03:53:03 <Peaker> osa1: Yeah, all monads are of the kind * -> *
03:53:04 <DevHC> osa1: btw SDL sux
03:53:20 <Peaker> osa1: a monad transformer is of kind:   (* -> *) -> (* -> *)     i.e: it takes a monad, and transforms it into a new monad
03:53:34 <osa1> DevHC: I love SDL. it's small enough that you don't need to look referances for everything, you have to solve your problems yourself which makes a good practice when learning a new language
03:53:35 <Peaker> osa1: a monad transformer basically adds some effect/capability to the monad it transforms
03:54:08 <mikeplus64> osa1: if you're interested in a very boring un haskell-like solution (my game I finished recently) : https://github.com/mikeplus64/Level-0
03:54:14 <mikeplus64> it's a snake clone using the SDL bindings
03:54:19 <osa1> Peaker: how does it transform? I mean, if I write a new monad, how can transformers transform it?
03:54:24 <Peaker> So while: "State s" is a monad,  "StateT s" is a monad transformer.  "State" can be defined as:  State s = StateT s Identity         (i.e: A StateT transform of the Identity monad)
03:54:36 <osa1> mikeplus64: thanks, yill look
03:54:38 <osa1> will*
03:54:51 <Peaker> osa1: Well, in the State case:    Instead of:   State s =
03:55:10 <Peaker> State s a = s -> (s, a)     you get:  StateT s m a = s -> m (s, a)
03:55:24 <Peaker> osa1: Did you implement the State monad instance yourself for practice?
03:55:41 <DevHC> osa1: i have no idea what u've just said
03:55:48 <osa1> Peaker: no but I read it's implementation, it was easy enough for a new haskeller
03:56:03 <Peaker> osa1: it's really good practice to implement some monad instances from scratch, yourself, and fight the type errors :)
03:56:20 <Peaker> osa1: it would be good practice to implement the Monad instance of StateT too, for practice
03:56:28 <Peaker> osa1: then, all monad transformers also implement the MonadTrans class:
03:56:29 <Peaker> @src MonadTrans
03:56:29 <lambdabot> Source not found. Wrong!  You cheating scum!
03:56:46 <Peaker> class MonadTrans t where lift :: Monad m => m a -> t m a
03:56:50 <mikeplus64> lambdabot is quite moody nowadays
03:57:04 <MagneticDuck> *sigh* lambabot. What a character.
03:57:21 <Peaker> So "t" is a monad transformer if you can define "lift" that takes an action in any monad "m" and lifts it to be an action in the transformed "t m"
03:58:08 <Peaker> osa1: can you guess how "lift" is implemented in the StateT instance?
03:58:37 <osa1> Peaker: well, no :)
03:58:55 <Peaker> osa1: Can you write the concrete type, i.e: replace the type variables with StateT's case?
04:00:28 <osa1> Peaker: yea
04:00:50 <osa1> I'm trying to understand how this helps me implement lift for StateT
04:01:06 <Peaker> osa1: why don't you write it down here?
04:01:08 <ddarius> @where lambdabot
04:01:08 <lambdabot> http://haskell.org/haskellwiki/Lambdabot
04:02:12 <Peaker> osa1: I have to go soon... If I'm unable to return, someone else can probably fill you in about transformers
04:03:11 <akosch> shameless self-promotion: http://stackoverflow.com/questions/9452870/http-conduit-browser-usage
04:08:36 <mekeor> how can i make C-code out of Haskell-code (with GHC) ?
04:09:45 <Jafet> Well, can you?
04:10:10 <mekeor> oh, i forgot to to write brackets arount the "how", sorry.
04:10:13 <Jafet> Lie: you can't
04:10:13 <mekeor> (how) can i make C-code out of Haskell-code (with GHC) ?
04:10:31 <mekeor> Jafet: bummer. okay, thanks.
04:10:41 <mekeor> Jafet: but is there another compiler which can?
04:11:43 <Jafet> If C means very troublesomely specific distributions of gcc, then you can.
04:11:59 <Jafet> See -fvia-c.
04:12:50 <osa1> DevHC: what are my alternatives to SDL in Haskell?
04:12:53 <Jafet> However, GHC actually produces a moon language that happens to be understood by gcc.
04:13:26 <mekeor> Jafet: hmm… okay. thank you so far. :)
04:15:32 <akosch> osa1: http://hackage.haskell.org/packages/archive/pkg-list.html#cat%3agraphics
04:16:42 <geekosaur> actually that hasn;t been true for a while, -fvia-c has been deprecated for a while and I think is gone in ghc7.4?
04:17:26 <Jafet> My lie just became true!
04:17:47 <geekosaur> there is a bootstrap mode which produces portable ANSI C but I think might only be guaranteed to work with ghc itself
04:18:13 <hiptobecubic> Did anyone participate in the codesprint yesterday? I'd really enjoy seeing haskell solutions by some people that know that what they are doing. I am always confused about when is the right time to try to introduce new types.
04:18:21 <ddarius> geekosaur: It depends on your architecture.
04:18:29 <ddarius> JHC produces portable C.
04:18:54 <ddarius> It's always the right time to introduce types.
04:21:57 <hpaste> MagneticDuck pasted “Buffering trouble” at http://hpaste.org/64363
04:22:39 <MagneticDuck> Hey, sorry if I'm disturbing any conversations...
04:22:50 <MagneticDuck> Hey, sorry if I'm disturbing any conversations...
04:23:22 <MagneticDuck> Hey, sorry if I'm bothering any current conversations...
04:23:41 <Saizan> MagneticDuck: you should rather state your question
04:23:41 <MagneticDuck> But I have a little buffering trouble with reading from the terminal.
04:23:51 <mekeor> lol yea :D
04:23:56 <Saizan> MagneticDuck: use "hFlush stdout"
04:24:08 <Saizan> between line 2 and 3
04:24:16 <MagneticDuck> That was fast . Thanks!
04:24:20 <MagneticDuck> LOL
04:24:31 <Jafet> Hey, hey, you, you, sorry for disturbing!
04:24:32 <Saizan> mh, though maybe that's not your problem?
04:25:04 <akosch> MagneticDuck: or use hSetBuffering (http://zvon.org/other/haskell/Outputio/hSetBuffering_f.html)
04:25:12 <MagneticDuck> Well, my problem is I want the terminal to buffer after each key stroke as opposed to after a line break. Would that solve it?
04:25:24 <geekosaur> no
04:25:27 <mekeor> akosch: who uses zvon.org anymore??
04:25:34 <mekeor> @hoogle hSetBuffering
04:25:34 <lambdabot> System.IO hSetBuffering :: Handle -> BufferMode -> IO ()
04:25:34 <lambdabot> GHC.IO.Handle hSetBuffering :: Handle -> BufferMode -> IO ()
04:25:45 <MagneticDuck> And how is BufferMode defined?
04:25:46 <Saizan> yeah, then use hSetBuffering stdin NoBuffering
04:25:46 <geekosaur> on unix you need to switch the terminal to character mode
04:25:48 <akosch> mekeor: sorry, just googled it
04:26:02 <Saizan> ?hoogle BufferMode
04:26:03 <lambdabot> System.IO data BufferMode
04:26:03 <lambdabot> GHC.IO.Handle data BufferMode
04:26:03 <lambdabot> Graphics.Rendering.OpenGL.GL.Framebuffer data BufferMode
04:26:07 <mekeor> akosch: WWWAAAAHHH … don't use google for haskell stuff… :)
04:26:21 <mekeor> Saizan: is ?hoogle == @hoogle ?
04:26:29 <MagneticDuck> Yeah, I'm on a unixy system. That is, Ubuntu, by the way.
04:26:37 <geekosaur> the ? and @ prefixes are identical, yes
04:26:43 <mekeor> ok
04:26:47 <akosch> mekeor: yeah, it's a bad habit... :)
04:27:16 <MagneticDuck> mekeor: Personally, I like zvon.org
04:27:20 <Saizan> MagneticDuck: http://www.haskell.org/ghc/docs/latest/html/libraries/base-4.5.0.0/System-IO.html#t:BufferMode
04:27:45 <geekosaur> for the character vs. line mode issue see System.Posix.Terminal
04:27:51 <MagneticDuck> Alright, everyone here sure pounced on me with answers. Thanks all.
04:29:38 <MagneticDuck> But wait, what do I use for the handle? With a file, I'd just use the file handle, but with the terminal, I have to use stdin or something like that...?
04:29:45 <MagneticDuck> That is, in hSetBuffering
04:29:51 <MagneticDuck> The first param
04:29:56 <mekeor> MagneticDuck: i prefer http://hackage.haskell.org/packages/archive/base/latest/doc/html/Prelude.html over zvon.org
04:29:56 <Saizan> yes, stdin or stdout or stderr
04:30:09 <Saizan> they are all exported from System.IO
04:30:13 <MagneticDuck> mekeor: I'll check it out.
04:30:19 <MagneticDuck> Saizan: Okay, thanks
04:31:30 <MagneticDuck> Okay, it's workin'! Pretty cool.
04:32:45 <MagneticDuck> BTW, what do all you guys / gals use for source editors?
04:33:09 <Saizan> i use emacs
04:33:19 <mekeor> i use emacs
04:34:05 <raichoo> i use vim
04:34:49 <osa1> is there a way to match last element of a list?
04:35:08 <raichoo> _:x:[]
04:35:16 <osa1> thanks
04:35:33 <mekeor> that'd be a list with two elements!
04:35:43 <raichoo> yeah sorry, i was wrong
04:35:50 <raichoo> Just woke up ^^
04:35:54 <mekeor> :)
04:36:01 <mekeor> osa1: no, there is not.
04:36:09 <Jafet> osa1: what's the last element of [0..]?
04:36:11 <mekeor> just do 'last list'
04:36:19 <mekeor> > last [0..]
04:36:23 <lambdabot>   mueval-core: Time limit exceeded
04:36:27 <chu> Haha
04:36:30 <mekeor> :)
04:37:16 <ClaudiusMaximus> > last [0..] :: Word8
04:37:17 <lambdabot>   255
04:37:37 <MagneticDuck> Yeah. With a list structure, you can't have a infinite list that *extends to the front*.
04:37:51 <MagneticDuck> Or wait, you can.
04:38:07 <MagneticDuck> Huh??
04:38:12 <mekeor> > last [0..] Int -- should be maxBound :: Int, right?
04:38:13 <MagneticDuck> No, you can't
04:38:13 <lambdabot>   Not in scope: data constructor `Int'
04:38:40 <ski> > let f (last -> x) = x in f [0,1,2,3]
04:38:40 <lambdabot>   3
04:38:45 <mekeor> > last [0..] :: Int -- should be maxBound :: Int, right?
04:38:49 <lambdabot>   mueval-core: Time limit exceeded
04:39:02 <mekeor> ski: what's that?
04:39:07 <ski> view pattern
04:39:12 <mekeor> lang ext?
04:39:16 <ski> yep
04:39:22 <mekeor> cool
04:39:40 <mekeor> http://hackage.haskell.org/trac/ghc/wiki/ViewPatterns
04:40:00 <ski> (aka transformational pattern)
04:40:18 <Kuba> Peaker: I have reinstalled ghc, cabal-install and all distro packages connected to ghc; then I removed ~/.{cabal,ghc}; and cabal install criterion works like charm
04:40:34 <Kuba> Peaker: magic!
04:41:20 <mekeor> > let f list@(last -> lastElem) = (list,last) in f [1..5]
04:41:21 <lambdabot>   Overlapping instances for GHC.Show.Show ([a] -> a)
04:41:21 <lambdabot>    arising from a use of...
04:41:41 <mekeor> bummer.
04:41:53 <ski> > let f list@(last -> lastElem) = (list,lastElem) in f [1..5]
04:41:53 <lambdabot>   ([1,2,3,4,5],5)
04:42:12 <mekeor> oh, hehe
04:42:13 <mekeor> :D
04:42:43 <mekeor> > let f g (g -> x) = x in f last [1..5]
04:42:44 <lambdabot>   5
04:42:49 <mekeor> O_O
04:42:50 <mekeor> wooooow
04:43:04 <mekeor> @let f g (g -> x) = x
04:43:04 <lambdabot>   ViewPatterns is not enabled
04:43:09 <mekeor> argh
04:44:59 <ski> @let f g y = g y
04:45:00 <lambdabot>  Defined.
04:45:21 <mm_freak_> @let f' = id
04:45:22 <lambdabot>  Defined.
04:46:57 * hackagebot stompl 0.0.2 - Stomp Parser and Utilities  http://hackage.haskell.org/package/stompl-0.0.2 (TobiasSchoofs)
04:46:59 * hackagebot stomp-queue 0.0.2 - Stompl Client Library  http://hackage.haskell.org/package/stomp-queue-0.0.2 (TobiasSchoofs)
04:47:01 * hackagebot patterns 0.0.1 - Common patterns in message-oriented applications  http://hackage.haskell.org/package/patterns-0.0.1 (TobiasSchoofs)
04:48:40 <mekeor> > let f g h (g -> h -> x) = x in f head tail [1..5]
04:48:41 <lambdabot>   <no location info>: parse error on input `->'
04:50:21 <MagneticDuck> Hey, wait, how does that work?
04:50:39 <MagneticDuck> You're pattern matching the final parameter as a function...
04:50:46 <MagneticDuck> but you're calling a list?
04:50:47 <mekeor> that's a language extension. it's not part of haskell 2010.
04:50:54 <MagneticDuck> Okay. Phew
04:51:05 <MagneticDuck> Part of lambdabot, I imagine>
04:51:13 <mekeor> nop
04:51:20 <MagneticDuck> What is it?
04:51:22 <mekeor> it's implemented in GHC
04:51:26 <mekeor> you can turn it on.
04:51:34 <MagneticDuck> But what does it do?
04:51:36 <mekeor> with -XViewPatterns
04:51:38 <mekeor> er
04:51:51 <MagneticDuck> ...that's the hard part to explain, I imagine.
04:51:59 <mekeor> "f l@(head -> x)" means "x" is "head l".
04:52:15 <MagneticDuck> ???
04:52:18 <raichoo> http://hackage.haskell.org/trac/ghc/wiki/ViewPatterns
04:52:23 <MagneticDuck> Thanks
04:52:24 <magicman> A value x matches a pattern (f -> p) if "f x" matches p.
04:52:30 <mekeor> MagneticDuck: do you know '@' ?
04:52:35 <MagneticDuck> Yeah, of course.
04:52:41 <MagneticDuck> As patterns
04:52:44 <mekeor> yep
04:53:20 <mekeor> so there's actually nothing to understand then… (or not understand…)
04:54:06 <MagneticDuck> Wait, but how do I call a function f (x -> y)? f takes a function that takes a value x and gives y...???
04:54:21 <MagneticDuck> So that's what this is.
04:54:46 <mekeor> no
04:55:05 <MagneticDuck> Yeah... I'm reading the article
04:55:54 <MagneticDuck> Oh. So, you're basically pattern matching for "views"
04:56:22 <mekeor> when "f (x -> y) = ..." and "x :: Y -> X" then "f :: Y -> ...", i think. right?
04:56:50 <ddarius> Gingerbread is annoying.
04:56:53 <MagneticDuck> Hmmm
04:56:57 <raichoo> > let f g (g -> x) = x in f (head . tail) [1..5]
04:56:58 <lambdabot>   2
04:57:13 <mekeor> :t f
04:57:14 <lambdabot>     Ambiguous occurrence `f'
04:57:14 <lambdabot>     It could refer to either `L.f', defined at <local>:15:0
04:57:14 <lambdabot>                           or `SimpleReflect.f', imported from SimpleReflect at State/L.hs:73:0-32
04:57:26 <mekeor> @let f g y = g y
04:57:26 <lambdabot>  <local>:17:0:
04:57:27 <lambdabot>      Multiple declarations of `L.f'
04:57:27 <lambdabot>      Declared at: <local>:...
04:57:31 <MagneticDuck> :t L.f
04:57:32 <lambdabot> forall t t1. (t -> t1) -> t -> t1
04:57:36 <mekeor> @forget f
04:57:36 <lambdabot> Incorrect arguments to quote
04:57:40 <mekeor> aah
04:58:03 <mekeor> :t ($)
04:58:04 <lambdabot> forall a b. (a -> b) -> a -> b
04:58:10 <mekeor> ha! i was right!
04:58:46 <MagneticDuck> Okay, I understand (a -> b) in type definitions fine, but I'm still having a hard time with f (x -> f) == ...
04:59:50 <MagneticDuck> Okay, to start, what's raichoo's function trying to do>
05:01:13 <MagneticDuck> Restate question: what does raichoo's function calculating?
05:02:13 <MagneticDuck> Did I scare everybody or somethin'?
05:03:07 <Taneb> Hello!
05:03:08 <ski> you can read `g ->' sortof as the inverse of `g'
05:03:17 <MagneticDuck> Okay...
05:03:18 <Taneb> Is it possible to use more than one monad in a do notation block?
05:03:36 <ski> > let f g h (g -> (h -> x)) = x in f tail head [0 .. 4]
05:03:36 <lambdabot>   1
05:03:56 <ski> Taneb : if you combine them into a single monad, yes
05:04:03 <Taneb> Hmm...
05:04:07 <MagneticDuck> Hmmm...
05:04:09 <MagneticDuck> LOL
05:04:09 <ski> (see monad transformers)
05:04:11 <Taneb> I don't think I want to combine Maybe and IO
05:04:18 <ski> why not ?
05:04:28 <Taneb> Because I only really need it once
05:04:30 <ski> @unmtl MaybeT IO a
05:04:30 <lambdabot> IO (Maybe a)
05:04:36 <MagneticDuck> I'll think about that... anyway, I have to go.
05:04:44 <magicman> MagneticDuck: Something which may not be immediately clear is that the left-hand side of the arrow must be a function expression. It is *not* a pattern.
05:04:54 <raichoo> Taneb: That's pretty much the canonical example :D
05:05:31 <Taneb> And in this case, it's just gonna make my code even less readable
05:05:39 <adimit> once you give in to combining monads, you'll build your transformer stacks sky-high.
05:06:00 <adimit> At least, that's what happened to me. And Taneb, it *makes* your code more readable — to people who understand monad transformers.
05:14:26 <Taneb> Right, my latest family tree program works.
05:14:34 <Taneb> Now to work on the interface
05:17:46 <Botje> cue the stack overflow thread about cycles in family trees
05:18:06 <Taneb> Uses IORefs.
05:18:06 <chu> haha
05:18:16 <Taneb> Cycles are possible
05:18:24 <Taneb> I have already tested this.
05:18:38 <Taneb> Well, it allows cousin marriages.
05:18:52 <Taneb> Actual time-travel cycles would only break the renderer
05:20:14 <Taneb> It probably allows a person to be his/her own parents
05:20:17 <Taneb> Both of them
05:21:09 <Jeanne-Kamikaze> is anyone familiar with ResourceT ?
05:21:53 <Taneb> I'm not sure why I'm doing this, I just enjoy making family trees
05:34:10 <Jafet> Taneb: modelling, you mean?
05:34:29 <Taneb> Perhaps
05:34:40 <Taneb> Constructing, maybe
05:35:08 <Jafet> As opposed to the more literal interpretation
05:36:08 <Taneb> Yes
05:40:49 <Ivoz_> what do you guys think of this? http://pastebin.com/qL4ZfH5q I found mathematical solution through experiment, its just ceil(log), but not algorithm...
05:40:51 <mauke> The paste qL4ZfH5q has been copied to http://hpaste.org/64367
06:02:22 <Haslog> I'm trying to recursively grow a tuple of lists, is there a 'cons'-like function for this e.g.: (a,b) -> ([a],[b]) -> ([a],[b]) can't find it in hoogle
06:02:46 <hpc> :t (:) &&& (:)
06:02:46 <lambdabot> forall b. b -> ([b] -> [b], [b] -> [b])
06:02:53 <hpc> :t (:) *** (:)
06:02:54 <lambdabot> forall b b'. (b, b') -> ([b] -> [b], [b'] -> [b'])
06:03:02 <byorgey> Haslog: no, there isn't
06:03:18 <byorgey> hpc: good luck with that
06:03:21 <hpc> er, yeah
06:03:22 <ddarius> It's not a common enough thing to put in the libraries.
06:03:33 <hpc> it's an easy function to write though
06:03:50 <byorgey> Haslog: yeah, just write your own
06:03:53 <hpc> @pl \(x,y) (xs,ys) -> (x:xs, y:ys)
06:03:53 <lambdabot> uncurry (flip flip snd . (ap .) . flip flip fst . ((.) .) . (. (:)) . flip . (((.) . (,)) .) . (:))
06:03:56 <hpc> eeeew
06:03:57 <Haslog> k, just checking in case I'd do something redundant ;p ty
06:04:17 <mekeor> can someone explain this?:
06:04:18 <mekeor> :t 1 2
06:04:18 <lambdabot> forall t t1. (Num (t1 -> t), Num t1) => t
06:04:54 <hpc> mekeor: instance Num a => Num (b -> a) where fromIntegral = const, ...
06:04:58 <byorgey> mekeor: well, to start, do you understand...
06:05:00 <byorgey> :t 1
06:05:01 <lambdabot> forall t. (Num t) => t
06:05:02 <hpc> 1 2 = const 1 2 = 1
06:05:04 <ddarius> hpc: That has nothing to do with the type.
06:05:04 <hpc> > 1 2
06:05:05 <lambdabot>   1
06:05:07 <mekeor> byorgey: i think so, yes.
06:05:28 <byorgey> mekeor: are you just trying to understand the type of '1 2'? or how it behaves in lambdabot?
06:05:41 <mekeor> the former
06:05:45 <byorgey> ok.
06:05:47 <mekeor> (or both)
06:05:54 <hpc> mekeor: for the latter, see what i said
06:05:58 <mekeor> (but rather the former)
06:06:05 <mekeor> hpc: ah, okay.
06:06:18 <byorgey> so for 'f x' to typecheck, it must be the case that f is a function which can be applied to x, right?
06:06:20 * mekeor is listening byorgey
06:06:27 <mekeor> right
06:06:32 <mekeor> yes.
06:06:33 <byorgey> so  f :: a -> b   and x :: a
06:06:34 <ddarius> hpc: You have multiple errors in your instance declaration.
06:06:41 <mekeor> byorgey: exactly, yep.
06:07:03 * hackagebot patterns 0.0.2 - Common patterns in message-oriented applications  http://hackage.haskell.org/package/patterns-0.0.2 (TobiasSchoofs)
06:07:16 <mekeor> byorgey: that's it? >.>
06:07:16 <byorgey> mekeor: and in that case  f x :: b.
06:07:21 <mekeor> rihgt
06:07:53 <byorgey> mekeor: so, for '1 2' to typecheck we must have  1 :: a -> b  and 2 :: a, but in order for 1 and 2 to have any type that type must be an instance of Num
06:08:59 <byorgey> so forall t t1. (Num (t1 -> t), Num t1) => t  says that  1 2  can have any type t,  as long as (t1 -> t)  (the type of 1) is an instance of Num, and so is  t1  (the type of 2).
06:09:38 <mekeor> i didn't get why (t1 -> t) has to be in Num…
06:09:49 <byorgey> mekeor: because that is the type of 1
06:09:51 <mekeor> "in order for 1 and 2 to have any type", you said…
06:10:02 <mekeor> byorgey: ah!
06:10:02 <mekeor> right
06:10:16 <hpc> mekeor: unify (a -> b) with (Num c => c)
06:10:17 <mekeor> :t (1 :: Integer) 2
06:10:17 <lambdabot>     Couldn't match expected type `t1 -> t'
06:10:18 <lambdabot>            against inferred type `Integer'
06:10:18 <lambdabot>     In the expression: (1 :: Integer) 2
06:10:18 <byorgey> mekeor: I meant that a numeric literal can have any type as long as that type is an instance of Num
06:10:24 <mekeor> haha! i got it!
06:10:32 <byorgey> nice =)
06:10:33 <hpc> mekeor: replace "c" with "(a -> b)"
06:10:36 <hpc> yay
06:10:47 <mekeor> :t (1 :: Floating a) 2 -- should work
06:10:48 <lambdabot>     Class `Floating' used as a type
06:10:48 <lambdabot>     In an expression type signature: Floating a
06:10:48 <lambdabot>     In the expression: (1 :: Floating a) 2
06:10:56 <mekeor> :t (1 :: Fractional a) 2 -- should work
06:10:56 <lambdabot>     Class `Fractional' used as a type
06:10:57 <lambdabot>     In an expression type signature: Fractional a
06:10:57 <lambdabot>     In the expression: (1 :: Fractional a) 2
06:11:00 <mekeor> er…
06:11:04 <mekeor> :t (1.0 :: Fractional a) 2 -- should work
06:11:05 <lambdabot>     Class `Fractional' used as a type
06:11:05 <byorgey> mekeor: now, in the standard libraries there is no Num instance for Functions
06:11:05 <lambdabot>     In an expression type signature: Fractional a
06:11:05 <lambdabot>     In the expression: (1.0 :: Fractional a) 2
06:11:16 <mekeor> byorgey: yep
06:11:26 <byorgey> mekeor: but there is such an instance defined in lambdabot
06:11:33 <mekeor> ah, okay. i got it.
06:11:45 <mekeor> it's implemented using const like hpc said, right?
06:11:49 <mekeor> got it.
06:11:49 <byorgey> mekeor: yes
06:11:57 <mekeor> but why does that not work then?
06:11:59 <mekeor> :t (1.0 :: Fractional a) 2 -- should work
06:12:00 <lambdabot>     Class `Fractional' used as a type
06:12:00 <lambdabot>     In an expression type signature: Fractional a
06:12:00 <lambdabot>     In the expression: (1.0 :: Fractional a) 2
06:12:10 <byorgey> mekeor: did you read the error message?
06:12:12 <mekeor> oops
06:12:21 <mekeor> :t (1.0 :: (Fractional a => a) ) 2 -- should work
06:12:22 <lambdabot> forall t t1. (Fractional (t1 -> t), Num t1) => t
06:12:25 <mekeor> nice
06:12:39 <byorgey> yep, there you go
06:13:02 <mekeor> thank you, byorgey :)
06:13:13 <byorgey> you're welcome =)
06:14:14 <mekeor> it's a good feeling to understand more (i.e. to 'learn')… :)
06:14:40 <byorgey> sure is =)
06:17:02 <rostayob> how do you define a CPP macro in cabal?
06:17:27 <rostayob> actually, I think I know
06:17:44 <rostayob> -DFLAG_NAME=whatever
06:18:09 <mekeor> When I define a type class which is a subclass of Applicative, is this class then automatically a subclass of Functor, too? (because Functor is a subclass of Applicative.)
06:19:36 <geekosaur> you need to declare Functor explicitly before you can declare Applicative
06:20:18 <geekosaur> automatic classing of that variety is still being discussed (as part of fixing the absence of Functor for Monad without breaking the universe)
06:20:47 <mekeor> geekosaur: ah, okay.
06:21:34 <mekeor> geekosaur: is there a language extension which does that automatically? that'd be magic…
06:21:58 <rostayob> mekeor: GHC can derive Functor in a lot of cases (-XDeriveFunctor)
06:23:46 <geekosaur> see "still being discussed"
06:24:13 <geekosaur> I expect there will be one eventually (aside from -XDeriveFunctor which still requires you to request it) but not yet
06:31:46 <drdo> Does anyone know if there's something like fmap over Maybe in erlang? (with undefined)
06:33:16 <mekeor> drdo: #erlang ?
06:33:56 <drdo> mekeor: I thought about asking there, but i figured it would be more likely to find someone who knows erlang here than someone who knows haskell there :)
06:34:18 <mekeor> ah, okay. sorry.
06:34:33 * mekeor doesn't know…
06:34:36 <efie> I have a list of Strings and each String consists of exactly 3 words, for example: ["a a 1", "b b 2"]. Now i want to drop elements of this list until i get a String whose first 2 words match a predicate (so a string with 2 words). I'm not that familiar with function composition, so can anybode help me? Something like dropWhile (("pre deciate" (not .) . (==)) . unwords . take 2 . words) ["a a 1", "b b 2"]?
06:35:53 <ddarius> efie: You don't need to use function composition.  Just write it out in whatever way is clearest to you.
06:37:18 <efie> ddarius: but using dropWhile i have to have function (in this case more functions, therefore function composition?) which checks against a predicate, have I not?
06:37:27 <mekeor> efie: use lambda notation, like map (\aStr -> ...) myList
06:38:27 <mekeor> efie: function composition is somehow just a few to write functions "point-free".
06:38:29 <mekeor> @src (.)
06:38:29 <lambdabot> (f . g) x = f (g x)
06:38:30 <lambdabot> NB: In lambdabot,  (.) = fmap
06:39:11 <mekeor> s/few/way/
06:47:37 <jay_gridley> hello, may I ask someone about Parsec library (lexical part)?
06:47:52 <mekeor> go ahead.
06:47:57 <byorgey> jay_gridley: don't ask to ask, just ask =)
06:49:40 <jay_gridley> thanks, so I am writting Pascal language parser (stucked at lexical analysis) -> what I need to do, is re-define "stringLiteral" token from Parse.Token, I am trying to do so like this: http://pastebin.com/ys9QvmTt
06:49:42 <mauke> The paste ys9QvmTt has been copied to http://hpaste.org/64369
06:50:00 <jay_gridley> what am I doing wrong?
06:52:02 <byorgey> jay_gridley: records don't work like that in Haskell
06:52:31 <zhulikas> can anyone tell me a scenario of how can I read binary data and get it's actual contents (which is text) ?
06:52:47 <byorgey> jay_gridley: (1)  foo.bar is not the syntax for accessing a field; (2) you cannot modify x by writing  x = y
06:53:03 <zhulikas> first step, get Lazy ByteString (from Data.ByteString.Lazy)
06:53:09 <drdo> zhulikas: What do you mean it's actual contents?
06:53:13 <drdo> *its
06:53:19 <zhulikas> drdo, the binary file contains text
06:53:25 <jay_gridley> I am quite new in Haskell world, so, sorry for my mistakes
06:53:27 <zhulikas> and I want to parse that text for some values
06:53:32 <zhulikas> and return those values
06:53:37 <srhb> zhulikas: What binary format is the text encoded in?
06:53:41 <byorgey> jay_gridley: instead you probably want something like   lexer = (P.makeTokenParser pascalStyle) { stringLiteral = myStringLiteral }
06:53:46 <zhulikas> ohh, good question
06:53:52 <zhulikas> how can I know?
06:53:58 <zhulikas> I never did anything with binary
06:54:11 <byorgey> which uses record update syntax to create 'lexer' as the same as (P.make ...) except with the 'stringLiteral' field modified
06:54:18 <srhb> zhulikas: Well, how was it generated for instance
06:54:25 <drdo> zhulikas: What is it that you want to do? (At a higher level)
06:54:35 <srhb> zhulikas: The question is really how can _we_ know. :P
06:54:39 <zhulikas> hehe
06:55:00 <zhulikas> I have 4MB file, which is supposedly sent through udb
06:55:00 <o1iver> Hey. What is the top level parser to use with parsec when parsing one or multiple expressions? Using many1 doesn't really work because it simply stops the parser if there is an error somewhere so you don't get an error, but rather a list of successfully parsed expressions until the error. I want to force it to parse the whole input string...
06:55:02 <zhulikas> udp*
06:55:14 <zhulikas> with .pcap extension if that says anything
06:55:22 <zhulikas> actually, http://www.tsurucapital.com/en/code-sample.html
06:55:28 <zhulikas> this is the thing
06:55:35 <byorgey> o1iver: if you use  parser <* eof   it forces it to parse the whole input
06:55:42 <byorgey> because it must match eof at the end
06:56:18 <drdo> zhulikas: You can just use attoparsec
06:56:24 <zhulikas> hmm
06:56:30 <o1iver> byorgey: ah. That's exactly what I was looking for. Thanks!
06:56:36 <zhulikas> 1 attoParsec = 3.08568025 centimeters
06:56:37 <zhulikas> D
06:56:37 <zhulikas> :D
06:56:44 <zhulikas> found it
06:56:50 <drdo> http://hackage.haskell.org/packages/archive/attoparsec/0.10.1.0/doc/html/Data-Attoparsec-ByteString.html
06:56:57 <zhulikas> yeah
06:57:24 <Botje> zhulikas: have you checked if there's any pcap parsers for haskell?
06:57:26 <zhulikas> so actually if it was sent using udp, it has some sort of special format, right?
06:57:38 <zhulikas> Botje, nope
06:57:40 <drdo> Not really
06:58:00 <zhulikas> http://hackage.haskell.org/package/pcap
06:58:02 <zhulikas> :D
06:58:04 <byorgey> UDP is just a transfer protocol.
06:58:17 <mekeor> @package crap -- hehe
06:58:17 <lambdabot> http://hackage.haskell.org/package/crap -- hehe
06:58:26 <jay_gridley> byorgey: still it does not parse string using my parser
06:58:54 <Botje> zhulikas: the pcap package has a Network.Pcap package, which allows you to open 'offline' dumps.
06:59:08 <Botje> zhulikas: .. which is what that site asks you to process, i guess.
06:59:23 <zhulikas> yes :)
06:59:27 <srhb> zhulikas: http://stackoverflow.com/questions/7747739/pcap-file-decoding-in-haskell
06:59:38 <srhb> And some other relevant google searches on pcap haskell, too
06:59:55 <byorgey> jay_gridley: well, if you paste your current code along with a sample input, what you expect to happen, and what happens instead, perhaps someone can offer suggestions
06:59:57 <zhulikas> sorry for not doing the research on pcap earlier
07:00:09 <drdo> Shit, that sounds like i'd like (those guys at tsurucapital)
07:00:12 <zhulikas> I had a different view on this thing
07:00:17 <drdo> *sounds like a job
07:00:19 <zhulikas> yeah
07:00:21 <srhb> zhulikas: Sometimes people just have to not answer and give the right counter questions. :)
07:00:39 <zhulikas> drdo, I wonder if I can get an internship at tsuru
07:00:47 <zhulikas> though I suck at haskell right now
07:02:38 <mekeor> zhulikas: you're from japan? isn't it late over there atm?
07:02:54 <zhulikas> I am not from japan
07:03:01 <mekeor> bummer.
07:03:04 <zhulikas> if I were from japan, I would rule haskell
07:03:11 <mekeor> hehe :D
07:03:15 <zhulikas> and every other complicated thing in the world
07:03:21 <mekeor> lol :)
07:03:22 <zhulikas> but I am just dumb european
07:03:31 <mekeor> like me…
07:03:32 <srhb> Except getting your peers to breed, mind.
07:05:01 <zhulikas> mekeor, do you work with haskell?
07:05:23 <zhulikas> I didn't find much to do with Haskell in Europe
07:05:29 <zhulikas> I mean I am looking for an internship
07:05:38 <zhulikas> and found only one with F# in Hungary :D
07:05:44 <zhulikas> still FP
07:05:59 <mekeor> zhulikas: no, i'm a scholar…
07:06:50 <zhulikas> I am not sure what a schoalr is
07:06:55 <zhulikas> phd student?
07:07:19 <hpaste> jay_gridley pasted “Re-define "stringLiteral" token in Parsec.Token” at http://hpaste.org/64370
07:07:34 <mekeor> zhulikas: pupil, i mean…
07:07:54 <srhb> mekeor: Student. :-)
07:08:01 <zhulikas> ah, ok
07:08:03 <mekeor> whatever…
07:08:10 <mekeor> srhb: you? or me?
07:08:15 <zhulikas> you
07:08:15 <zhulikas> :D
07:08:22 <mekeor> ok
07:08:24 <zhulikas> or pupil as in school student?
07:08:26 <srhb> mekeor: Both. ;) But I was handing you the right word.
07:08:31 <zhulikas> damn
07:08:33 <mekeor> thanks :)
07:08:44 <mekeor> wanna talk more? join #haskell-blah =)
07:09:10 <zhulikas> sounds like fun!
07:09:17 <zhulikas> whoa
07:09:22 <zhulikas> I didn't expect it to be a real channel
07:09:24 <zhulikas> :D
07:09:30 <mekeor> :)
07:09:49 <MagneticDuck> Wait, I can't find that channel...
07:09:56 <jay_gridley> guys, so I need my code http://hpaste.org/64370 to parse strings between '' (apostrophes) instead of "", so when I type 'test' it should be parsed as string, but I am getting syntax error instead
07:10:33 <srhb> jay_gridley: Wow, wild indentation.
07:10:50 <MagneticDuck> Hm, I've never seen anybody actually type in the brackets and semicolons!
07:11:00 <srhb> Same.
07:11:38 <mekeor> Shame.
07:12:06 <hpc> people do it in lambdabot all the time
07:12:14 <hpc> but same, in a file
07:12:19 <srhb> I can barely read that.
07:12:24 <mekeor> there are even people who write if (...) then { ... } else { ... }
07:12:24 <MagneticDuck> Me too.
07:13:13 <MagneticDuck> jay_gridley: Why don't you just use indentation? It's way easier! Brackets are for compilers... and... C.
07:13:20 <zhulikas> :D
07:13:20 <MagneticDuck> I hate C
07:13:34 <mekeor> i don't love it.
07:13:50 <jay_gridley> just started with Haskell, many year in Java
07:13:50 <srhb> What imports are needed for that snippet, jay_gridley?
07:13:59 <MagneticDuck> For example, in objective C, you have to use isEqualString or something like that to test the equality to two strings.
07:14:06 <stulli> Why can't i have newtype X = Int _and_ newtype Y = Int?
07:14:33 <jay_gridley> module Main where  import System.IO import Text.Parsec import qualified Text.Parsec.Token as P import Text.Parsec.Language
07:14:46 <srhb> jay_gridley: Thanks
07:14:46 <hpc> stulli: Int is the constructor for X
07:15:01 <hpc> stulli: newtype X = X Int
07:15:21 <stulli> hpc: Ow, right! Thanks for pointing out
07:15:22 <hpc> i don't think you can even have "newtype X = Int"
07:15:58 <int-e> hey how else would you write one-liners in Haskell? ;-)   {import Data.List;import Data.Function;main=mapM_ print$fix((0:).scanl(+)1)}
07:16:03 <geekosaur> you can, because the type namespace is separate from both the type constructor and data constructor namespaces
07:16:12 <hpc> stulli: sometimes it might help to think in GADT syntax
07:16:15 <hpc> newtype X where
07:16:19 <hpc>   X :: Int -> X
07:16:44 <geekosaur> and Int is not used as a data constructor, at least not by GHC
07:16:50 <hpc> @src Int
07:16:51 <lambdabot> data Int = I# Int#
07:17:14 <MagneticDuck> ??? I've never seen anything like that before...?
07:17:29 <stulli> hpc: a newtype is defined in terms of GADT?
07:17:54 <hpc> stulli: no, it's just a different style of defining data types
07:18:02 <int-e> MagneticDuck: the # stuff? don't worry about it, that's a ghc implementation detail
07:18:03 <mekeor> newtype is like data without |, right?
07:18:05 <hpc> which is required to do GADTs
07:18:20 <stulli> ok
07:18:22 <hpc> mekeor: a newtype is exactly one constructor with exactly one parameter
07:18:42 <hpc> newtype A stuff = A oneThing
07:18:50 <hpc> where "stuff" can be as many type params as you want
07:18:54 <geekosaur> MagneticDuck, # suffix is a GHC internal thing, conventionally indicating an unboxed type
07:18:57 <mekeor> yea, so as i said…
07:19:08 <mekeor> ah, okay…
07:19:09 <hpc> mekeor: it's a bit more than what you said :P
07:19:15 <mekeor> okay, right
07:19:18 <stulli> When i do newtype X = X Integer i have to add an instance for (Num Position)
07:19:18 <hpc> but more or less, yeah
07:19:27 <stulli> (in my program)
07:19:37 <hpc> stulli: "newtype Position" you mean? yeah
07:19:52 <hpc> stulli: there's an extension that lets you derive type classes for newtypes
07:19:58 <bmm> I've got this problem: http://pastebin.com/KUtFb1jm Mentioned by somebody else earlier. I have no idea how to get past it, any suggestions? Summary: cannot configure unix-2.4.2.0. It requires base >=4.2 && <4.4.
07:19:59 <mauke> The paste KUtFb1jm has been copied to http://hpaste.org/64371
07:20:00 <hpc> forget what it's called
07:20:13 <hpc> but then you can just do "newtype Position = X Integer deriving (Num, ...)
07:20:21 <hpc> whatever the superclasses are for Num
07:20:24 <stulli> hpc: yes. all i wanted is to quickly define aliases for Integer that won't mix
07:20:30 <mekeor> bmm: ah… i have that problem too often, too…
07:20:34 <mekeor> hate it…
07:20:46 <jay_gridley> foks, can you recommend me some IDE/editor for Haskell (Windows platform)?
07:20:53 <hpc> jay_gridley: notepad++
07:21:00 <hpaste> srhb annotated “Re-define "stringLiteral" token in Parsec.Token” with “Re-define "stringLiteral" token in Parsec.Token (annotation)” at http://hpaste.org/64370#a64372
07:21:02 <bmm> mekeor: how do you get around it, it's the result of a cabal install cabal-install :)
07:21:03 <mekeor> jay_gridley: Geany
07:21:14 <MagneticDuck> jay_gridley: Hmmm, I like Sublime editor, actually.
07:21:17 <mekeor> bmm: idk… which GHC version?
07:21:26 <srhb> jay_gridley: I've cleaned it up slightly so that maybe someone more experienced can now parse your code. It's still an unholy mess though. :)
07:21:26 <mekeor> or, does that matter? idk
07:21:29 <geekosaur> bmm, base is part of the compiler, so you are limited to versions of the unix library compatible with your installed ghc
07:21:32 <mekeor> bmm: ask hpc
07:21:44 <bmm> mekeor: 7.4.1 at the moment
07:21:56 <mekeor> cool, nice.
07:22:00 <bmm> geekosaur: aah, so the whole problem is trying to do 7.4.1 on unix :)
07:22:08 <stulli> hpc: I think it is GeneralizedNewtypeDeriving btw
07:22:09 <hpc> mekeor: i don't know packages lol :P
07:22:12 * geekosaur *eyeroll*
07:22:13 <hpc> stulli: ah, groovy
07:22:24 <jay_gridley> srhb: sorry, I am really new in Haskell, I have to get used to it
07:22:28 <geekosaur> in any case the unix libreary appropriate for your compi;ler should have come with your compiler
07:22:48 <geekosaur> and replacing bootlibs (libraries that come with the compiler) is perilous and can easily break your compiler
07:22:59 <srhb> jay_gridley: Don't apologize, I'm just saying. You may be better off asking how to do what you want to do and start from scratch. I believe it is more readable with my annotation, though.
07:23:10 <mekeor> geekosaur: so what does he have to do then?
07:23:14 <mekeor> go sleeping?
07:23:28 <bmm> geekosaur: ok, so I should get cabal to understand that the base libary is already somehwere else? That sounds like a plan.
07:23:45 <geekosaur> mekeor, the question is why e wants to build the unix library when there should already be one present
07:23:58 <mekeor> ah, right
07:24:05 <geekosaur> (...I think.  hm, wait)
07:24:16 * mekeor waits
07:24:45 <geekosaur> yes, it's a bootlib
07:24:57 <geekosaur> replacing it is a really bad idea, so why is e trying to replace it?
07:25:10 <jay_gridley> and what about Leksah IDE? Any experience someone?
07:25:22 <mekeor> geekosaur: is your "h" key dead?
07:26:05 <mekeor> jay_gridley: tell me if *you* have =) (i'm interested in it… but it requrires GHC 6.* (when you wanna compile it), unfortunately…)
07:26:21 <mekeor> s/if/when/
07:26:21 <bmm> jay_gridley: I only started with Haskell a month or so ago, but I would not suggest leksah. The way it rewrites cabal files made me angry ;)
07:26:40 <mrcarrot> jay_gridley: i tried it and it is probably nice for bigger projects, but as mine are so far smaller one-file projects i am more efficient with just vim
07:27:20 <jay_gridley> I've trying eclipse + eclipseFP, but it is way slow!
07:29:17 <srhb> jay_gridley: If you're experienced with either Emacs or Vim, they will do the job just fine.
07:29:18 <jay_gridley> so, stick to my problem :-) I am trying to re-define stringLiteral token from Parsec library to parse strings surrounded in '' instead of default "", my approach is here: http://hpaste.org/64370#a64372, but still can force Parsec to use my string parser (myStringLiteral), aby ideas? Thanks
07:29:23 <geekosaur> mekeor, you see no problem in assuming gender, I am perhaps for this place odd in not doing so
07:30:08 <srhb> geekosaur: I thought we agreed on xhe!
07:30:27 <albel727> haha
07:30:29 <albel727> oh wow
07:32:58 <Botje> jay_gridley: .. but which parser are you running?
07:33:22 <Botje> what parser are you feeding to runparser?
07:34:33 <jay_gridley> Botje: I am just trying to run lexical parser (lexer), do not have any syntactical parser yet
07:35:08 <Botje> jay_gridley: I get that. but how are you testing it?
07:35:09 <jay_gridley> maybe I am running it wrong, I am quite newbie in haskell
07:35:22 <jay_gridley> I load file into ghci
07:35:36 <Botje> yes, and then?
07:38:10 <jay_gridley> Btoje: after that just type in some lexical structures, but I am not sure, if it is right way :-(
07:38:30 <Botje> can you annotate your hpaste with your input?
07:38:50 <Botje> because your paste currently defines a *new* parser.
07:38:58 <Botje> which means you have to write code that actually uses it.
07:39:20 <jay_gridley> ahh, and can you help me, how to do that?
07:39:44 <Botje> what, help you write a parser for pascal?
07:40:14 <jay_gridley> no no, how to test lexer I am trying to do in that snippet
07:40:47 <Botje> you write a parser that uses the tokenparser you just defined.
07:41:17 <zhulikas> I am kinda lost... how can I decode data from Ptr Word8 ?
07:41:34 <zhulikas> GHC.Ptr.Ptr Word8
07:41:45 <Botje> so you do something like parseTest (p.stringliteral lexer) "'this is my test string'"
07:41:51 <ClaudiusMaximus> zhulikas: with Storable, probably
07:41:57 <zhulikas> 0x00000000040f53a0 is not very human-readable
07:42:33 <Botje> zhulikas: it's a pointer to a chunk of memory. you probably want to grab its contents using one of the bytestrings.
07:42:43 <zhulikas> O.o
07:42:51 <zhulikas> you mean computer memory?
07:42:58 <Botje> yes.
07:43:01 <zhulikas> ok...
07:43:14 <zhulikas> well, nice
07:43:19 <zhulikas> thanks
07:44:13 <Botje> zhulikas: there are *BS variants of loop and dispatch
07:44:19 <Botje> that give you nice bytestrings instead of Ptr Word8
07:44:37 <zhulikas> uhm...
07:45:06 <zhulikas> I see
07:45:16 <Botje> zhulikas: .. or you could tell us what you're trying to do and how that involves Ptr Word8
07:45:31 <Botje> I'm just guessing what you want to do based on your earlier questions.
07:45:44 <zhulikas> yes, that's what I am trying to do :D
07:45:57 <zhulikas> I am trying to parse that pcap package with Network.Pcap
07:46:06 <zhulikas> and most obvious way to read it is using next function
07:46:12 <zhulikas> but as you just said, there is also dispatchBS
07:46:15 <zhulikas> so I will try that instead
07:46:17 <Botje> there's also a nextBS.
07:46:28 <Botje> if you want to read all packets *anyway* might as well use loopBS or dispatchBS
07:48:03 <zhulikas> hehe
07:48:29 <zhulikas> now I need to figure out what can I do with ByteString
07:49:07 <Botje> address individual bytes, of course.
07:49:09 <zhulikas> I will use dispatchBS in the final version, but now I still need to figure out how this stuff works
07:49:29 <zhulikas> care to elaborate?
07:49:52 <Botje> IP packets contain a header and a payload
07:50:12 <zhulikas> well, nextBS gives me a header and data
07:50:17 <zhulikas> so that given ByteString contains only the data
07:50:19 <Botje> a conversation between client and server typically involves several packets
07:50:22 <Botje> yes.
07:50:41 <t7> is there a plugin for ghc that uses djynn to infer the term for a type if it can be solved?
07:50:45 <t7> that would be cool
07:51:01 <Botje> the assignment you were given says you only need to process packets on two specific ports, so i'd start with filtering out all packets that do not match that criterion.
07:51:17 <bmm> Ah, I found my problem with cabal install cabal-install and ghc-7.4.1: unix is 2.5.0 and cabal-install  build-depends: unix >= 1.0 && < 2.5. Thank you all for pointing towards the packages and libraries!
07:51:18 <Botje> and then you have to do some research on the protocol they speak
07:51:50 <Botje> either by finding a specification or staring at the payload until you see what each packet means
07:52:10 <zhulikas> well, wow.
07:52:53 <tomodo> REALLY!!
07:52:56 <tomodo> http://blog.printf.net/articles/2012/02/23/computers-are-very-good-at-the-game-of-go
07:53:24 <geekosaur> bmm, I think you need an unreleased cabal-install with 7.4.1.  (not certain though, hopefully someone else knows.  I know a newer cabal library is needed, but that's a bootlib)
07:54:05 <geekosaur> that is, you'l need to find the repo for cabal-install (should be linked from the hackage page)
07:58:21 <zhulikas> well, I am lost.
07:58:22 <zhulikas> PktHdr {hdrSeconds = 1297814400, hdrUseconds = 985864, hdrCaptureLength = 257, hdrWireLength = 257}
07:58:29 <zhulikas> that's not something I could use to filter packets
07:58:48 <zhulikas> ahhh
07:58:50 <zhulikas> I see
07:59:02 <zhulikas> that's probably the description of actual packet (header+data)
07:59:03 <zhulikas> right?
07:59:12 <geekosaur> that's the pcap header, the actual packet including its frame and protocol headers is payload
07:59:18 <zhulikas> and now I need to read byte by byte that given byteString
07:59:24 <zhulikas> ah, ok
07:59:45 <bmm> geekosaur: thank you!
07:59:47 <Botje> yes
07:59:56 <Botje> so grab a copy of the IP and UDP specifications and start cracking!
07:59:59 <zhulikas> yeah
08:00:04 <zhulikas> I'm on it
08:00:16 <zhulikas> but one more thing - what I could actually use this PktHdr for then?
08:00:21 <geekosaur> ...also the frame specification for the actual transport (e.g. Ethernet)
08:00:21 <zhulikas> ok, it says the length
08:00:25 <zhulikas> that's useful
08:00:31 <geekosaur> length and timestamp
08:00:48 <zhulikas> timestamp = time when received?
08:00:51 <geekosaur> yes
08:01:15 <geekosaur> hdrSeconda and hdrUseconds (the latter is microseconds)
08:01:55 <zhulikas> damn, I didn't expect it to be so difficult :D
08:02:01 <zhulikas> ok, thanks
08:03:20 <geekosaur> packet traces are necessarily very low level, it is rather painful.  this is why most of us use tools like wireshark
08:03:29 <Botje> zhulikas: there is this package called 'etherbunny' that defines some data.binary getters
08:03:59 <Botje> but it hasn't seen updates in a while.
08:04:15 <Botje> if nothing else you can reuse the IP packet parsing
08:04:22 <zhulikas> so, just to be sure... in UDP 0-15 bits are source port address. So if I take 16bits from given ByteString and convert it to Word16, I should get source port address?
08:04:30 <Botje> yes.
08:04:35 <zhulikas> nice
08:04:37 <Botje> zhulikas: but take a look at Data.Binary
08:04:41 <geekosaur> it should only need updating for bugs
08:04:54 <Botje> and that etherbunny thing.
08:05:08 <geekosaur> not like they change the definition of Ethernet frames or TCP4 headers every few months
08:05:11 <Botje> it allows you to specify your packet format a lot nicer.
08:05:20 <Botje> geekosaur: but but but .. the evil bit!
08:05:51 <zhulikas> A network analysis toolkit for Haskell, based on the Network.Pcap library. Currently not very useful, but getting there.
08:05:54 <zhulikas> nice description :D
08:07:34 * geekosaur briefly wonders how far one would get with something to translate the protocol modules for wireshark to Haskell using Data.Binary.Get
08:07:44 <Botje> zhulikas: http://hackage.haskell.org/package/network-data
08:08:02 <Botje> this is a bit more maintained.
08:08:08 <Botje> and now I really should start on my paper
08:08:09 <Botje> <<
08:08:36 <zhulikas> thanks
08:10:17 <MagneticDuck> Hello all again, I was wondering what the easiest / most powerful methods there are to make graphics with Haskell? And by that, I mean creating image files.
08:10:28 <MagneticDuck> Vector graphics would be preferable.
08:11:07 <MagneticDuck> That is, vector in the program, but rasterized when written to the file.
08:11:21 <MagneticDuck> Any ideas? Any projects? Any packages?
08:13:40 <MagneticDuck> 'lo?
08:14:09 <i_am_neuron> Hi haskellers, I'm trying to use Parsec for simple parsing tasks, here's the source: http://hpaste.org/64376. Does anybody know why the 'message' parser there accepts a string "2 + a" (I expect parse to fail with it)?
08:15:20 <t7> does "the set of all sets that do not contain itself" contain itself ?
08:15:47 <t7> the answer is potato
08:16:43 <MagneticDuck> Is it nap time here on #haskell? :D
08:16:58 <Taneb> It's alway naptime here on #haskell.
08:17:12 <MagneticDuck> Yeah, well I've seen some very active moments.
08:17:38 <MagneticDuck> Just a few hours ago, I asked a question about buffering and about 5 people pounced on me with about the same answer. :D
08:17:52 <MagneticDuck> ...within about 5 seconds from time asked.
08:18:32 <t7> MagneticDuck: have you searched on hackage?
08:18:51 <MagneticDuck> Well, to tell you the truth, I'm being lazy.
08:19:05 <MagneticDuck> No. But what are your opinions?
08:19:23 <MagneticDuck> I'm doing that right now.
08:19:27 <t7> my opinion is to look on hackage
08:20:25 <MagneticDuck> Okay, I found a few packages around "wumpus".
08:21:37 <i_am_neuron> Is there anybody around to answer a really simple Parsec question? Struggling with this: http://hpaste.org/64376
08:21:49 <zhulikas> hmm, if ByteString is a Word8 vector, but I need 16bit number, I need to take two Word8's from ByteString and make a Word16 from it?
08:21:56 <zhulikas> how can I do that
08:22:15 <MagneticDuck> i_am_neuron: Sorry, I'm a newbie here. :)
08:22:47 <MagneticDuck> Alright, two questions pending. Anyone? Help!
08:22:51 <Taneb> zhulikas, \x y -> fromIntegral x + fromIntegral y
08:22:57 <Taneb> Myabe?
08:23:03 <zhulikas> naaah, can't be that easy
08:23:04 <zhulikas> :D
08:23:07 <zhulikas> I'll try
08:23:20 <Taneb> No wait, won't work
08:23:32 <Taneb> zhulikas, \x y -> (256* fromIntegral x) + fromIntegral y
08:23:41 <ClaudiusMaximus> @hoogle getBE
08:23:41 <lambdabot> No results found
08:23:55 <MagneticDuck> Yeah, just make sure to type-cast it!
08:23:55 <zhulikas> @hoogle fromIntegral
08:23:55 <lambdabot> Prelude fromIntegral :: (Integral a, Num b) => a -> b
08:24:23 <MagneticDuck> Word16 is an instance of Num?
08:24:33 <Azel> Yes
08:24:48 <MagneticDuck> Okay, but Word8 isn't? Hmm?
08:25:05 <Taneb> Word8 most certainly is
08:25:07 <Azel> Word8 is also
08:25:23 <MagneticDuck> In that case, why do you need fromIntegral, Taneb?
08:25:32 <Taneb> To get rid of the bounding
08:25:42 <MagneticDuck> Oh
08:25:48 <Taneb> > 700 :: Word8
08:25:48 <lambdabot>   188
08:25:54 <MagneticDuck> Ouch
08:26:03 <Azel> Arithmetic on fixezd size types is defined as modulo 2^size
08:26:36 <Taneb> I've got an IORef inside an IORef, and I've got a function that takes an IORef and returns IO () after performing an action... I want to perform the function on the inner IORef
08:26:37 <MagneticDuck> Okay. Yeah, that's Haskell: the last thing you want to do is give an error! Instead, mod it.
08:26:56 <MagneticDuck> Or wait, it's in other languages, too?
08:27:02 <MagneticDuck> I guess so.
08:27:22 <Botje> zhulikas: look at Data.Binary
08:27:23 <zhulikas> <Taneb> zhulikas, \x y -> (256* fromIntegral x) + fromIntegral y
08:27:34 <zhulikas> does that actually mean, that first Word8 is the left byte of Word16 ?
08:27:35 <parcs`> i_am_neuron: why would you expect it to fail?
08:27:36 <Botje> i_am_neuron: your parser doesn't fail because it only eats a bit of the input.
08:27:44 <Taneb> zhulikas, I believe so
08:27:48 <zhulikas> ok, nice
08:27:53 <Taneb> With the big bits at the front?
08:28:02 <Botje> i_am_neuron: if you want to force parsec to parse the whole thing, use something like message <* eof
08:28:11 <i_am_neuron> Botje: Is there a way to force it to consume everything
08:28:14 <i_am_neuron> Botje: Ah
08:28:27 <Azel> C defines at least unsigned arithmetic as modulo 2^size, so it is consistent for existing languages
08:28:36 <i_am_neuron> @hoogle <*
08:28:36 <lambdabot> Control.Applicative (<*) :: Applicative f => f a -> f b -> f a
08:28:37 <lambdabot> Control.Applicative (<**>) :: Applicative f => f a -> f (a -> b) -> f b
08:28:37 <lambdabot> Control.Applicative (<*>) :: Applicative f => f (a -> b) -> f a -> f b
08:28:43 <zhulikas> damn, I got only 256
08:28:45 <mekeor> <* is like <<
08:28:57 <Botje> not quite.
08:29:06 <mekeor> er…
08:29:10 <mekeor> :t (<<)
08:29:10 <Botje> a <* b evaluates a, then b, and returns whatever a returned
08:29:11 <lambdabot> Not in scope: `<<'
08:29:12 <ClaudiusMaximus> zhulikas: http://www.haskell.org/hoogle/?hoogle=getWord16+%2Bbinary+%2Bcereal
08:29:22 <Azel> And I suppose having different behaviour for signed and unsigned types would violate the principle of least astonishment
08:29:23 <Botje> a << b evaluates b, then a, and returns what a returns
08:29:29 <mekeor> :t (>>)
08:29:30 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m a -> m b -> m b
08:29:49 <mekeor> there is no (<<).
08:29:55 <t7> @hoogle x -> y -> f -> (f x y)
08:29:55 <mekeor> i meant, flip (>>)
08:29:56 <lambdabot> Text.Parsec.Prim State :: s -> SourcePos -> u -> State s u
08:29:56 <lambdabot> Text.ParserCombinators.Parsec.Prim State :: s -> SourcePos -> u -> State s u
08:29:56 <lambdabot> Data.Generics.Twins gmapAccumQr :: Data d => (r' -> r -> r) -> r -> (forall e. Data e => a -> e -> (a, r')) -> a -> d -> (a, r)
08:30:07 <i_am_neuron> Botje: works now, thanks (I really should've fixed this myself)
08:30:23 <t7> @hoogle x -> y -> (x -> y -> z) -> z
08:30:23 <lambdabot> Prelude flip :: (a -> b -> c) -> b -> a -> c
08:30:23 <lambdabot> Data.Function flip :: (a -> b -> c) -> b -> a -> c
08:30:23 <lambdabot> Data.Foldable foldl :: Foldable t => (a -> b -> a) -> a -> t b -> a
08:30:23 <mekeor> i_am_neuron: i have lots of you! =)
08:30:25 <Taneb> I think you mean flip seq
08:30:35 <Taneb> flip (>>) is monadier
08:30:40 <mekeor> :t (>>)
08:30:40 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m a -> m b -> m b
08:30:43 <mekeor> :t (*>)
08:30:43 <lambdabot> forall (f :: * -> *) a b. (Applicative f) => f a -> f b -> f b
08:30:47 <Botje> mekeor: no, that still executes b before a.
08:31:00 <mekeor> Botje: ah, okay…
08:31:00 <Taneb> :t flip seq
08:31:01 <lambdabot> forall a a1. a1 -> a -> a1
08:31:10 <Botje> a <* b is do a - do b - return a
08:31:17 <Botje> a << b is do b - do a - return a
08:31:26 <mekeor> ok
08:31:32 <Taneb> :r \a! -> id
08:31:34 <Botje> yes, it's tricky :)
08:31:36 <Taneb> :t \a! -> id
08:31:36 <lambdabot> parse error on input `->'
08:31:48 <mekeor> Botje: but >> is like *> , right?
08:31:50 <Taneb> (Is ! GHC's strict variable thing?)
08:31:55 <Botje> mekeor: totally.
08:32:01 <mekeor> good. :)
08:32:04 <t7> :t fix
08:32:05 <lambdabot> forall a. (a -> a) -> a
08:32:06 <longh> MagneticDuck: http://projects.haskell.org/diagrams/ ?
08:33:15 <byorgey> MagneticDuck: yes, try diagrams!  There's a new release coming out soon.  You can also come ask questions in #diagrams.
08:33:27 <MagneticDuck> Okay, thanks!
08:33:46 <MagneticDuck> It reminds me of good old mathematica! I loved graphics in Mathematica.
08:34:19 <MagneticDuck> ...except different.
08:34:24 <byorgey> hehe
08:34:25 <MagneticDuck> I'm reading some of the code.
08:34:49 <MagneticDuck> Yeah, I love saying that. "This day is like a hedgehog, except not."
08:35:13 <byorgey> MagneticDuck: well, then you are going to love luite's project once it is actually launched.
08:35:28 <MagneticDuck> byorgey: What's that?
08:35:30 <srhb> Diagrams depends on GTK, doesn't it>
08:35:48 <liyang> cairo I expect.
08:35:58 <MagneticDuck> cario?
08:36:10 <byorgey> srhb: not inherently.  the cairo backend does, but there is also a postscript backend and we're working on an SVG backend
08:36:18 <srhb> byorgey: Oh, nice!
08:36:27 <Taneb> Yes!
08:36:29 <Taneb> Yeeeees!
08:36:31 <srhb> byorgey: I would love to see the PS and SVG backends, would make it much more portable
08:36:35 <Taneb> I know what I'm doing now
08:37:14 <byorgey> MagneticDuck: imagine the interactivity of ghci + the visual "notebook" interface of Mathematica + a wiki + beautiful design, all in your browser
08:37:34 <MagneticDuck> And haskell?
08:37:42 <MagneticDuck> Of course, I expect. :D
08:37:45 <byorgey> MagneticDuck: yes, also the Haskell of ghci =)
08:38:00 <hey_lu> byorgey: is that already in progress?
08:38:09 <MagneticDuck> Wow! I'd love that!
08:38:09 <byorgey> i.e. you type Haskell expressions just like in ghci except some of them might evaluate to images or whatever.
08:38:16 <srhb> Was that the channel that Apfel... talked about?
08:38:19 <MagneticDuck> Yeah, like in Mathematica.
08:38:21 <srhb> Apfelmaus
08:38:22 <jay_gridley> Botje: thanks, finally I am able to do somethink with it :-)
08:38:25 <byorgey> hey_lu: yes.
08:38:31 <Botje> jay_gridley: yay!
08:38:34 <srhb> channel -> challenge
08:38:41 <hey_lu> byorgey: and can I try it?
08:38:50 <zhulikas> well, I am not quite sure how to apply Get monad from data.binary to my ByteString
08:38:52 <zhulikas> :|
08:38:56 <byorgey> srhb: it's similar, although the project I'm talking about was started a while ago, independent of apfelmus's challenge
08:39:00 <byorgey> but the ideas are in the air =)
08:39:05 <byorgey> hey_lu: not yet, sorry!
08:39:16 <srhb> byorgey: Exciting things!
08:39:25 <byorgey> indeed! =)
08:39:42 <zhulikas> oh, wait
08:39:45 <zhulikas> sorry, nevermind
08:39:51 <Botje> zhulikas: http://hackage.haskell.org/packages/archive/binary/0.4.1/doc/html/Data-Binary.html#v:decode
08:39:56 <zhulikas> yes....
08:40:05 <zhulikas> I accidently skipped that one
08:40:06 <zhulikas> that pge
08:40:08 <zhulikas> page*
08:40:20 * byorgey goes back to working on the new diagrams release
08:43:49 <byorgey> does anyone know if there's a platform-independent way to change the working directory?
08:44:06 <byorgey> I found 'changeWorkingDirectory' in the unix package but I want something that will work on Windows too
08:44:29 <byorgey> (or maybe the concept of a current working directory is inherently platform-specific?)
08:45:24 <hpc> byorgey: posix, perhaps?
08:45:37 <hpc> perl has chdir, which appears to be platform-independent
08:46:15 <hpc> POSIX.setCurrentDirectory if google is giving good results
08:47:02 <liyang> http://hackage.haskell.org/packages/archive/directory/latest/doc/html/System-Directory.html#v:setCurrentDirectory might do the trick.
08:47:27 <byorgey> liyang: aha, that's it!
08:47:27 <liyang> At least it claims to be system-independent.
08:47:29 <byorgey> liyang++
08:49:15 <roconnor> > ("a",[1]) `mappend` ("b",[2])
08:49:16 <lambdabot>   ("ab",[1,2])
08:49:22 <hpaste> MagneticDuck pasted “Simple IO problem” at http://hpaste.org/64380
08:49:25 <MagneticDuck> Hey, I have a really simple question: how would I make a console program that would write a prompt, like "give me input: ", wait for the user to enter the input ON THAT LINE, and then return some processed input? putStrLn works, but not putStr. I tried setting the buffering type, but it didn't so anything. Help?
08:49:54 <liyang> Skimming through the diagrams docs. Interesting idea with the bounding functions. :)
08:50:21 <byorgey> liyang: thanks, it actually wasn't my idea, although I've fleshed it out quite a bit
08:51:07 <byorgey> MagneticDuck: if setting the buffering type didn't do anything then you must have done it wrong.
08:51:09 <ddarius> MagneticDuck: Flush stdout.
08:51:40 <MagneticDuck> byorgey: Well I put "setBuffering NoBuffering"...
08:51:45 <MagneticDuck> ddarius: Will try
08:52:16 <byorgey> MagneticDuck: try  hSetBuffering stdout NoBuffering ?
08:52:38 <MagneticDuck> Oh, wait, hFlush stdout worked. Thanks all.
08:53:23 <ddarius> @hoogle setBuffering
08:53:23 <lambdabot> System.IO hSetBuffering :: Handle -> BufferMode -> IO ()
08:53:23 <lambdabot> GHC.IO.Handle hSetBuffering :: Handle -> BufferMode -> IO ()
08:53:30 <ddarius> Where are you getting a setBuffering?
08:53:34 <MagneticDuck> Yeah, both worked! Thanks!
08:53:42 <MagneticDuck> :)
08:55:10 <MagneticDuck> Yeah, the first time I tried hSetBuffering, I used stdin. :P
08:55:44 <MagneticDuck> It is a bit confusing when stdin and stdout are the same place.
08:57:29 <srhb> MagneticDuck: Could you annotate with your solution? I dropped from the channel for a while there.
08:57:50 * ddarius thinks MagneticDuck is making this confusing.  stdout and stdin aren't the same "place" at all.  Thinking about them as "places" also doesn't make a lot of sense.
08:58:17 <MagneticDuck> ddarius: Yeah, well they're "pipes" if that makes it better.
08:59:06 <MagneticDuck> Alright, srhb, I'm almost done.
09:00:20 <ddarius> Even as pipes, one is going from the keyboard to your program and the other is going from your program to the screen.
09:00:58 <MagneticDuck> True. But the input pipe is displayed on the console, so there's a pipe from the keyboard to the screen too, at some level.
09:01:35 <MagneticDuck> Sorry, I was doing something else there, srhb. Here it is:
09:01:55 <hpaste> MagneticDuck pasted “IO solution” at http://hpaste.org/64381
09:05:08 <eyebloom> Is it possible to have a set of functions S.Set (a->b)?
09:05:17 <dolio> No.
09:05:17 <ddarius> eyebloom: Yes.
09:05:35 * ddarius should look for C# to Android thing.
09:05:44 <eyebloom> How would you instantiate Ord on the function type.
09:05:57 <ddarius> Not all functions that produce sets require an Ord constraint.
09:06:06 <ddarius> And you can just provide an Ord constraint.  Nothing is stopping you.
09:06:19 <ddarius> If you want a -useful- set of functions, though, you are more limited.
09:06:44 <ddarius> @hoogle Data.Set.singleton
09:06:44 <lambdabot> Data.Set singleton :: a -> Set a
09:06:53 <ddarius> > S.singleton id
09:06:54 <lambdabot>   Overlapping instances for GHC.Show.Show (a -> a)
09:06:54 <lambdabot>    arising from a use of `...
09:07:10 <ddarius> > S.length (S.singleton id)
09:07:10 <lambdabot>   Not in scope: `S.length'
09:07:15 <ChristianS> MagneticDuck: i think you could also use  hFlush stdout  after  putStr , instead of turning off buffering completely. might be more efficient if you have lots of output to print.
09:07:37 <Azel> > S.size (S.singleton id)
09:07:38 <lambdabot>   1
09:07:54 <eyebloom> I'm more asking what the ordering principle would be within the Ord instance.
09:08:06 <MagneticDuck> ChiristainS: Okay. I'm looking for all the advice I can get!
09:08:06 <eyebloom> If the instance is just a function.
09:08:20 <eyebloom> I have to apply it to get any information out of it.
09:08:24 <ddarius> eyebloom: That question is not at all obvious from your original question.
09:08:46 <eyebloom> Sorry. Working it out over here.
09:10:49 <eyebloom> Basically I'm using Set because I don't want duplicate members and I want arbitrary order.
09:11:19 <eyebloom> But Set needs Ord so that it can organize it's internal tree.
09:11:27 <byorgey> eyebloom: equality on functions is not, in general, computable.  Hence neither is an ordering.
09:11:41 <byorgey> you can possibly do it if you restrict yourself to certain types of functions.
09:12:20 <Taneb> eyebloom: data OrdFunc = OrdFunc Integer (a -> b)
09:12:27 <byorgey> but I would question whether this is really what you want.
09:12:34 <Taneb> Then be very careful about whe you put in it
09:12:38 <byorgey> eyebloom: can we back up a level or two?  what are you actually trying to accomplish?
09:13:11 <eyebloom> I have a simple graph structure that you can query adjacent vertices from a particular node.
09:13:49 <eyebloom> In some cases I need to indicate that an adjacent node has just been added to the graph domain.
09:14:12 <eyebloom> So instead of outputing a set of vertices from my adjacency function
09:14:44 <eyebloom> I instead give a set of functions which yield a vertex.
09:14:58 <byorgey> function that yield a vertex given what?
09:15:08 <byorgey> i.e. what is their input?
09:15:23 <ddarius> In general, it just doesn't make sense to put functions in a set as byorgey started leading toward but then veered away.
09:15:31 <hpaste> bmm pasted “Quickcheck ghc-7.4.1” at http://hpaste.org/64384
09:15:36 <eyebloom> Given whatever is partially applied to the function.
09:15:45 <ddarius> I.e. the problem is deeper than Set wanting an ordering relation for tree balancing.
09:15:51 <eyebloom> type Adjacent a = Gr a -> (Gr a, Vertex)
09:15:58 <bmm> pfff. I got ghc-7.4.1 building, then I had to build cabal-install head, now QuickCheck won't compile: http://hpaste.org/64384 . Anybody have any pointers?
09:16:12 <byorgey> I didn't veer away, I'm trying to help eyebloom figure out how to do whatever they want to do without using sets of functions.
09:16:32 <ddarius> byorgey: You veered away in the very same sentence.
09:16:49 <eyebloom> The simplest function just contains a vertex. const :: AbstractNode a => Vertex -> Adjacent a
09:16:51 <ChristianS> eyebloom: why not store all the partially applied arguments instead of the function itself (which, without the partial application, will probably always be the same)?
09:17:11 <eyebloom> ChristianS:
09:17:34 <byorgey> eyebloom: this is not making sense.
09:17:36 <eyebloom> ChristianS: That would mean I martial the function application later with a case.
09:18:37 <liyang> Perhaps instead of a -> b you can use Map a b instead.
09:18:58 * liyang isn't really following this conversation so ignore him if that makes no sense.
09:19:49 <eyebloom> Which I could do it just means boilerplate with each particular functionality.
09:22:03 <dmwit> kowey: pong
09:22:10 <ktklam9> hi, in what logical category would least square minimization be in Hackage?
09:22:12 <byorgey> eyebloom: why is it so important to not have duplicate outputs?  i.e. why not just a list of functions?
09:22:44 <byorgey> just ensure by construction that you do not generate duplicates.
09:22:56 <dmwit> kowey: I managed to get gtk2hs to build on Windows, but I don't know how anybody else ever did. (Because I had to hack gtk2hsc2hs to do it, and none of the "guides" online mention anything like that.)
09:23:07 <eyebloom> I think that's what I have to do. And then move the outputs into a set of vertices later. I think that's probably the best way.
09:23:27 <dmwit> ktklam9: Maybe statistics, machine learning, or something like that.
09:23:37 <ddarius> ktklam9: There is no logic currently.  Just look through the current ones and pick one.  Please don't make another.  You can be in multiple categories as well.
09:24:37 * ddarius thinks some hackage admin should go through and merge categories.
09:24:45 <ddarius> Or at least merge them in the package listing.
09:25:33 <MichaelBurge> @pl f (x:xs) = x:xs
09:25:33 <lambdabot> f = liftM2 (:) head tail
09:25:47 <ddarius> That's actually sort of impressive.
09:26:12 * ChristianS always wondered why the "base" package is in the "Unclassified" category...
09:26:23 <jeff_s_> I just tried font-lock with haskell-mode for the first time. Is -> supposed to disappear?
09:26:26 * dmwit thinks the categories are basically unhelpful at this point and should just be removed
09:27:36 <ddarius> dmwit: They should be treated as tags and a tag navigation interface should be provided.  It should also be easier to change the tags and to get a feel for which tags are popular to avoid different tags for the same thing.
09:27:55 <ddarius> But certainly, with just a giant list, it's actually of negative value.
09:30:24 * ddarius should really probably upgrade to an Ubuntu from this decade.
09:33:40 <byorgey> jeff_s_: no. probably means your font does not have a glyph for "right arrow" or something like that
09:33:59 <byorgey> I'm guessing font-lock tries to replace -> with a single right-arrow character
09:34:21 <jeff_s_> I would think courier has that glyph, but maybe not. Not a big deal.
09:34:48 <jeff_s_> Does anyone think that "ChanReader" is a confusing name for a type that is a read-only channel? I don't want the type to be confused with the Reader monad.
09:35:08 <jeff_s_> The alternate name I thought of is ReadOnlyChan, but it's rather longer.
09:35:13 <jeff_s_> or ChanReadOnly
09:38:54 <MagneticDuck> Nah.
09:39:06 <MagneticDuck> Gosh, everyone is so silent.
09:39:47 <MagneticDuck> You could just about hear a virtual pin drop!
09:40:06 <Taneb> * read a virtual pin drop
09:40:06 <MagneticDuck> Sometimes the IRC has moments like this.
09:40:11 <Taneb> This is a text-based medium
09:40:17 <liyang> jeff_s_: RO/WO/RW perhaps?
09:40:37 <byorgey> > (length "ChanReader", length "ReadOnlyChan")
09:40:38 <lambdabot>   (10,12)
09:40:53 <byorgey> rather == 2?
09:41:26 <MagneticDuck> Ah names. Everyone who's written at least a small program knows how annoying they are to pick.
09:41:56 <Taneb> I generally end up with "magic" and "blerg" somewhere
09:42:07 <Taneb> magic is usually defined as join (***)
09:42:13 <jeff_s_> Yes, and this is not a big library.... Maybe I should request that the Reader and Writer monads be removed, and then I can use the names I want without any confusion.
09:42:24 <MagneticDuck> LOL
09:42:28 * hackagebot algebra 2.0.7 - Constructive abstract algebra  http://hackage.haskell.org/package/algebra-2.0.7 (EdwardKmett)
09:43:08 <jay_gridley> guys, what does this means? ... return (foldr (maybe id (:)) "" str)
09:43:39 <jay_gridley> str <- between (char '\'')  (char '\'' <?> "end of string")  (many stringChar)
09:43:49 <jay_gridley> what that foldr does?
09:44:03 <MagneticDuck> You know what foldr is, right?
09:44:14 <ceii> :t maybe if (:)
09:44:15 <lambdabot> parse error on input `if'
09:44:17 <ceii> :t maybe id (:)
09:44:18 <lambdabot> forall a. Maybe a -> [a] -> [a]
09:44:36 <jay_gridley> it applies something to the list from right side
09:45:05 <ceii> this one takes a list of "Maybe Char"s and extracts the non-Nothing ones
09:45:19 <liyang> Otherwise known as catMaybes.
09:45:24 <zhulikas> how can I get Lazy ByteString from a regular one?
09:45:44 <jay_gridley> ceii: thanks
09:45:49 <rostayob> zhulikas: fromChunks and toChunks
09:45:52 <zhulikas> yeah...
09:45:54 <zhulikas> it takes an array
09:45:59 <zhulikas> I have only a value
09:46:04 <zhulikas> and [b] or b:[] doesn't work
09:46:10 <jeff_s_> zhulikas - BS.concat . LBS.toChunks
09:46:15 <rostayob> zhulikas: you can concat them
09:47:30 * hackagebot gtk-mac-integration 0.1.0.4 - Bindings for the Gtk/OS X integration library.  http://hackage.haskell.org/package/gtk-mac-integration-0.1.0.4 (HamishMackenzie)
09:47:37 <zhulikas> well, toChunks takes a lazy one
09:47:49 <zhulikas> so BS.concat . LBS.toChunks cannot be applied to regular ByteString
09:47:53 <zhulikas> (I think so)
09:48:35 <dmwit> kowey: Also, it seems we may be in different timezones. Got a suggestion for a more appropriate conversation medium? =P
09:48:46 <dmwit> ?localtime kowey
09:51:33 <ddarius> @src ShowS
09:51:33 <lambdabot> type ShowS = String -> String
09:51:38 <sm> wow, regex-tdfa was hard to build with 7.4.1 on a 1G VPS
09:51:40 <ddarius> @src String
09:51:40 <lambdabot> type String = [Char]
09:52:06 <sm> it zooms up to 580M & kept getting OOM-killed
09:52:21 <ChristianS> zhulikas: toChunks converts a lazy ByteString into a list of strict ByteStrings.
09:52:44 <zhulikas> I need to convert a strict ByteString (single) to a lazy ByteString
09:52:57 <zhulikas> and L.fromChunks takes [strict ByteString]
09:53:02 <zhulikas> but I have a single one!!
09:53:03 <zhulikas> :D
09:53:03 <ddarius> sm: GHC is a GHC compiled program and thus has the same RTS options including ones that limit the maximum heap size.
09:53:48 * ddarius will leave it to zhulikas to figure out how to make a list from a single element.
09:53:54 <zhulikas> oh, come on...
09:53:55 <zhulikas> :|
09:54:10 <ChristianS> zhulikas: sample question: how to you convert a into [a] ?
09:54:16 <zhulikas> oh, wait
09:54:21 <zhulikas> there was a compile error
09:54:26 <zhulikas> and I though that's with b:[]
09:54:32 <zhulikas> hehe
09:54:40 <zhulikas> it works :|
09:54:51 <ddarius> b:[] = [b]
09:54:55 <zhulikas> yesh
09:55:03 <MagneticDuck> > b:[] == [b]
09:55:04 <lambdabot>   True
09:55:09 <ddarius> > [b]
09:55:09 <zhulikas> ffs
09:55:10 <lambdabot>   [b]
09:55:10 <zhulikas> I know that
09:55:28 <MagneticDuck> Yeah, just poking it in. :D
09:55:35 <MagneticDuck> Everyone has days like that. :)
09:57:28 <sm> ddarius: good hint! I'll try that
09:57:38 <MagneticDuck> Could somebody explain to me how they wrote GHC for the first time, if GHC is written in haskell and compiled by GHC?
09:57:53 <MagneticDuck> Or maybe hugs is written in a foreign language...
09:58:12 <MagneticDuck> Anyone? :D
09:58:14 <zhulikas> Data.ByteString : A time and space-efficient implementation of byte vectors using packed Word8 arrays
09:58:17 <zhulikas> and it has a function
09:58:17 <zhulikas> O(1) take n, applied to a ByteString xs, returns the prefix of xs of length n, or xs itself if n > length xs.
09:58:31 <zhulikas> should I expect here to give a number of Word8 elements, or a number of bits?
09:59:12 <jay_gridley> I have a string = 'this is '' my string' and I want to replace the double '' inside of string to single ' => 'this is my ' string', is there any easy way ho to do that?
10:00:03 <MagneticDuck> You mean replace a pattern in a string? Didn't entirely understand the question.
10:00:17 <ddarius> MagneticDuck: There were Haskell compilers when GHC was written.
10:00:56 <ddarius> Admittedly, HBC, which was used to build early versions of GHC, is also written in Haskell.
10:01:25 <mhitza> hy guys, how do I tell ghc where to look for modules?
10:01:38 <jay_gridley> MagneticDuck: yes yes, replace it ('' => ')
10:02:11 <MagneticDuck> Yeah. There is a fairly simple way.
10:05:04 <byorgey> mhitza: that question is quite vague.  Are you having a specific problem?
10:06:03 <mhitza> byorgey, yes, I have generated code by Thrift which I'd like to use. The code is generated in my project directory under the gen-hs folder and I'd like ghc to lookup the imported modules from there as well
10:07:12 <byorgey> MagneticDuck: see http://en.wikipedia.org/wiki/Bootstrapping_(compilers)
10:08:48 <byorgey> mhitza: -i<dir>
10:08:58 <sm> ddarius: cabal install regex-tdfa --ghc-options='+RTS -M300m' worked well. That's a very handy thing for VPS users to know, thank you
10:08:59 <byorgey> mhitza: see http://www.haskell.org/ghc/docs/latest/html/users_guide/separate-compilation.html#search-path
10:09:06 <mhitza> byorgey, thank you
10:10:20 <byorgey> mhitza: it turns out your question was not vague at all, it was just that I could imagine lots of other scenarios that might lead someone to ask that, and I wanted to make sure I was answering the right question =)
10:11:03 <mhitza> byorgey :)
10:12:17 <zhulikas> ahaha
10:12:53 <hpaste> zhulikas pasted “ze binaries” at http://hpaste.org/64392
10:13:11 <zhulikas> gentlemen
10:13:25 <zhulikas> please take a look and tell me if I am doing it right
10:14:27 <zhulikas> and, well
10:14:33 <zhulikas> I see looping is implemented not right
10:14:37 <zhulikas> but don't look at that
10:17:51 <zhulikas> pretty please
10:19:21 <yitz> zhulikas: B.take n gives you a single bytestring as its result
10:19:32 <zhulikas> yes
10:19:40 <Taneb> This import list has to be unique.
10:19:40 <zhulikas> and n is a number of bytes as I figured out
10:20:08 <zhulikas> so B.take 2 should give me 16 first bits what is equal to source address in UDP packet
10:20:10 <Taneb> import Control.Monad
10:20:18 <Taneb> import Data.IORef
10:20:23 <Taneb> import Data.Map (Map,adjust)
10:20:28 <Taneb> import qualified Data.Map as M
10:20:30 <zhulikas> but is this the right approach of decoding binary?
10:20:34 <Taneb> import Data.Set hiding (map)
10:20:39 <Taneb> import Data.Time.Calendar
10:20:40 <zhulikas> ofcourse the code itself is messy and stuff...
10:20:42 <Taneb> import Data.Tree
10:20:42 <Taneb> import System.Exit
10:20:44 <yitz> zhulikas: you really want to use the binary or cereal package for this
10:20:53 <zhulikas> I use Data.Binary
10:21:05 <zhulikas> but I didn't figure out a way to use Get and Put monads from Data.Binary
10:21:50 <Taneb> Has anyone else ever used that combination of modules in a non-contrived program?
10:21:58 <zhulikas> though working with decode from Data.Binary is ok for me
10:23:06 <yitz> zhulikas: do { s <- getWord16be; de <- getWord16be; return (s, de) }
10:23:29 <zhulikas> what
10:23:37 <zhulikas> getWord16be from where?
10:23:55 <zhulikas> it needs a state monad
10:23:56 <yitz> zhulikas: Data.Binary.Get
10:24:01 <zhulikas> oh, come on :D
10:24:07 <zhulikas> I don't know how to initialize it
10:24:21 <zhulikas> don't tell me to use get method from Data.Binary.Get
10:24:23 <zhulikas> :|
10:24:48 <yitz> zhulikas: you just feed your input stream into the runGet function
10:24:54 <yitz> @hoogle runGet
10:24:55 <lambdabot> No results found
10:25:00 <yitz> hmmph
10:25:07 <zhulikas> runGet :: Get a -> ByteString -> a
10:25:13 <yitz> right
10:25:21 <zhulikas> so, runGet myStream should return (Get ByteString) ?
10:25:47 <zhulikas> or, wait.
10:25:48 <yitz> runGet (how to deserialize it) (input stream)
10:26:00 <zhulikas> runGet myStream :: L.ByteStream
10:26:02 <zhulikas> right ?
10:26:49 <yitz> where "how to deserialize it" is a value in Get a for some type a, and then the result is just a, outside the monad.
10:27:14 <yitz> in my example, a = (Word16, Word16)
10:27:17 <zhulikas> oh, so it actually returns a value without a monad
10:27:21 <yitz> right
10:27:25 <zhulikas> @hoogle a -> Get a
10:27:26 <lambdabot> Did you mean: a -> RequestMethod
10:27:26 <lambdabot> Prelude id :: a -> a
10:27:26 <lambdabot> Data.Function id :: a -> a
10:27:30 <zhulikas> what about it
10:28:05 <yitz> zhulikas: return
10:28:17 <zhulikas> @hoogle return
10:28:17 <lambdabot> Prelude return :: Monad m => a -> m a
10:28:18 <lambdabot> Control.Monad return :: Monad m => a -> m a
10:28:18 <lambdabot> Control.Monad.Instances return :: Monad m => a -> m a
10:28:26 <zhulikas> aaaa :D
10:28:36 <zhulikas> return stream :: Get
10:28:36 <zhulikas> ?
10:29:00 <yitz> zhulikas: it just trivially inserts the value into the monad. in this case that means similute as if that vaule was decoded, without reading any bytes.
10:29:16 <zhulikas> I completely forgot about return
10:29:23 <zhulikas> and thanks, that's great
10:29:27 <zhulikas> now I can take advantage of any monads :D
10:29:44 <yitz> zhulikas: np :) the Get monad really really simplifies things
10:29:51 <zhulikas> yeah, I know
10:29:55 <zhulikas> according to it's methods
10:30:01 <zhulikas> but I just didn't knew how to put something inside Get
10:30:01 <zhulikas> :D
10:30:12 <zhulikas> awesome!
10:31:47 <Kuba> is there any predefined function that returns first Just element or Nothing if list is empty?
10:32:00 <yitz> Kuba: listToMaybe
10:32:10 <yitz> @type listToMaybe
10:32:11 <lambdabot> forall a. [a] -> Maybe a
10:32:33 <Kuba> naah
10:32:38 <yitz> > (listToMaybe [3,4,5], listToMaybe [])
10:32:39 <lambdabot>   (Just 3,Nothing)
10:33:00 <Kuba> > listToMaybe [Nothing, Nothing, Just 5]
10:33:01 <lambdabot>   Just Nothing
10:33:08 <Kuba> ;]
10:33:09 <albel727> heh
10:33:32 <yitz> > maybeToList $ Just 42
10:33:33 <lambdabot>   [42]
10:34:10 <Kuba> headNothing [] = Nothing
10:34:10 <Kuba> headNothing (x:xs) = if x == Nothing then headNothing xs else x
10:34:12 <ddarius> > msum [Nothing, Nothing, Just 3, Just 4, Nothing]
10:34:13 <lambdabot>   Just 3
10:34:29 <ddarius> Kuba: Don't use (==) to test constructors.
10:34:33 <mekeor> :t maybeToList
10:34:34 <lambdabot> forall a. Maybe a -> [a]
10:34:37 <ddarius> > msum []
10:34:38 <lambdabot>   No instance for (GHC.Show.Show (m a))
10:34:38 <lambdabot>    arising from a use of `M3146114002...
10:34:46 <ddarius> > msum [] :: Maybe [Int]
10:34:47 <lambdabot>   Nothing
10:35:04 <Kuba> ddarius: cool, thanks
10:35:30 <Kuba> :t msum
10:35:31 <lambdabot> forall (m :: * -> *) a. (MonadPlus m) => [m a] -> m a
10:35:59 <yitz> > let readMany = unfoldr $ listToMaybe . concatMap reads . tails in readMany "The numbers are 7, 11, and 42." :: [Int]
10:36:01 <lambdabot>   [7,11,42]
10:37:05 <Kuba> ddarius: btw, why shouldn't I use constructors for ==?
10:37:30 <ddarius> I said you shouldn't test for constructors using (==).
10:37:38 <DanBurton> I think I just broke patch-tag.com >.>
10:38:08 <Kuba> ddarius: okay, but why?
10:39:11 <ddarius> 1) Pattern matching is nicer, cleaner, and faster, 2) you add unnecessary constraints on your code, and 3) related to being faster, pattern matching is potentially more defined; it certainly is more clearly defined.
10:39:19 <ddarius> :t \x -> x == Nothing
10:39:20 <lambdabot> forall a. (Eq a) => Maybe a -> Bool
10:39:33 <ddarius> Now I can't pass Just id to that function.
10:40:10 <Kuba> mhm
10:40:14 <Kuba> ddarius: thanks!
10:40:59 <yitz> DanBurton: the home page still works at least
10:42:55 <jay_gridley> guys, how to replace some pattern in string?
10:43:23 <DanBurton> yitz: yeah its ok now. I was having trouble creating a repo, and then it said it was down, and then right afterwards it started working perfectly
10:43:46 <yitz> DanBurton: thanks for fixing it. you are very responsible.
10:43:52 <jeff_s_> For read-only channels, what would be better for naming? "import qualified Control.Concurrent.Chan.ReadOnly as ROChan; ROChan.readChan" or "import Control.Concurrent.Chan.ReadOnly; readReadOnlyChan"? The second is more consistent with the existing naming system for Control.Concurrent, but uses longer names.
10:46:10 * ddarius feels jeff_s_ has spent -far- too much time thinking about this.
10:46:22 <MagneticDuck> Poor jay_gridley! He asked his question an hour ago and still hasnt gottena good answer. I cant because Im on my iPod right now... help him!
10:46:26 <ben> What's a read-only channel good for? How does stuff go into it?
10:46:36 <jeff_s_> ddarius gets the prize for the correct answer.
10:47:10 <sutats> Could someone please help me with parallel processing the file list in http://hpaste.org/64355 (the first line with mapM in the main function)? Naively, I would want to split the list into 4 chunks and process each chunk on a separate core.
10:47:33 <jeff_s_> ben - using the normal channel that was used to build the ro-channel, or a write-only channel.
10:48:14 <jay_gridley> MagneticDuck: I found, that I could use Data.String.Utils module, but can not find it in cabal
10:48:25 <bgamari> Does anyone have a good handle on how to use HaXml?
10:48:33 <zhulikas> yitz, I am not quite sure how can I put this into my function: do { s <- getWord16be; de <- getWord16be; return (s, de) }
10:48:56 <bgamari> I have yet to find a document which describes how to parse a string and use the combinators on the output that doesn't feel like a hack
10:49:29 <bgamari> Or does anyone else have any other suggestions for XML parsing in Haskell?
10:49:43 <bgamari> It seems as though there are several options, but none are well documented
10:50:17 <majuscule> Can someone help me understand this line or direct me towards some appropriate documentation? I'm having trouble finding it. `state <- readState $ State { st3=pm, st2=0 }`
10:50:32 <monochrom> the combinator suite of HaXml is incomplete. you are better off writing your own recursions over HaXml's tree.
10:50:39 <majuscule> I don't understand what the dollar sign does, and google won't let me search for a dollar sign
10:50:47 <bgamari> monochrom: ahh, hmm
10:50:48 <bgamari> alright
10:50:49 <MagneticDuck> jay_gridley: When I get back to my computer Ill post some code. However, Im not sure if Ill be using what the libs have. Im not well aquainted with them yet: Ill just write it from scratch.
10:50:50 <monochrom> on the up side, there is nothing to learn
10:51:13 <bgamari> Would people consider HXT to be a better option?
10:51:38 <yitz> zhulikas: so let's say you defined that separately, like: decodeSandDe :: Get (Word16, Word16); decodeSandDe = do { s <- getWord16be; de <- getWord16be; return (s, de)
10:52:11 <monochrom> the combinator suite of HXT is complete. you never need to know the tree. on the down side, since the combinator suite is so complete, there are hundreds to learn.
10:52:18 <yitz> zhulikas: so then, insted of the two "let" lines in your paste, you could write: let (s, de) = runGet decodeSandDe packet
10:52:28 <yitz> *instead
10:52:55 <zhulikas> hmm
10:53:06 <monochrom> (of course, you can go to HXT's tree directly and ignore the combinators. but doing that defeats the point of HXT)
10:53:07 <jay_gridley> MagneticDuck: nice, maybe using only standard libs are better approach, but I have to go now, can you send me an e-mail (gridley.jay@hotmail.com) with that code?
10:53:15 <bgamari> monochrom: sure
10:53:22 <bgamari> Perhaps I'll give HXT a try then
10:53:24 <yitz> @type ($) -- majuscule
10:53:25 <lambdabot> forall a b. (a -> b) -> a -> b
10:53:25 <strager> majuscule: Hoogle: http://www.haskell.org/hoogle/?hoogle=%24
10:53:38 <bgamari> monochrom: My problem with HaXml wasn't even the combinators per se
10:54:04 <yitz> :t ($) -- majuscule, this is how to write it at the GHCi prompt
10:54:05 <lambdabot> forall a b. (a -> b) -> a -> b
10:54:38 <bgamari> monochrom: The output of the parsing code didn't even remotely match the input of the combinators
10:54:46 <MagneticDuck> jay_gridley: sure thing! Glad to help.
10:55:01 <jay_gridley> MagneticDuck: thanks so much, see you
10:55:32 <jay_gridley> \leave
10:56:19 <zhulikas> ok, so my approach worked as well. I just need to figure out how yours work :D
10:56:24 <nand`> yitz: “do { s <- getWord16be; de <- getWord16be; return (s, de)” or (,) <$> getWord16be <*> getWord16be
10:56:40 <Enigmagic> bgamari: we use xml-enumerator for rss/atom parsing
10:56:43 <yitz> nand`: yes, either one
10:57:40 <zhulikas> runGet :: Get a -> ByteString -> a
10:57:44 <zhulikas> so Get a is actually a function
10:57:47 <zhulikas> I thought it
10:57:49 <zhulikas> I thought it's a type
10:58:05 <zhulikas> hmm, interesting
10:58:52 <zhulikas> ok
10:59:02 <zhulikas> so now I can get Word8/16/32/64 values
10:59:24 <zhulikas> kewl
10:59:40 <majuscule> strager: thank you! So basically, it just calls a function on and b correct?
10:59:49 <zhulikas> so
10:59:50 <zhulikas> decode :: Binary a => ByteString -> a
10:59:53 <zhulikas> this actually does the same thing
10:59:56 <strager> majuscule: Yes.
11:00:02 <zhulikas> only it's easier and simplier using Get, right?
11:00:09 <strager> majuscule: Look at the code for ($).  (Click "source" on the right side of the page.)
11:00:12 <bgamari> Enigmagic: I'll have a look
11:01:19 <Enigmagic> bgamari: i think the xml-conduit package is it's natural successor, depending on if you prefer conduits or enumerators
11:03:29 <ddarius> ($) is basically the identity function.
11:03:43 <hpc> :t (f $)
11:03:44 <lambdabot>     Ambiguous occurrence `f'
11:03:44 <lambdabot>     It could refer to either `L.f', defined at <local>:15:0
11:03:44 <lambdabot>                           or `SimpleReflect.f', imported from SimpleReflect at State/L.hs:73:0-32
11:03:49 <hpc> pah
11:04:04 <ddarius> Incidentally, I don't believe the ($) was even necessary in the code you pasted.
11:04:28 <ddarius> :t L.f
11:04:29 <lambdabot> forall t t1. (t -> t1) -> t -> t1
11:04:34 <majuscule> strager: thank you! the notation is very confusing to me, but I think i'm getting it. I one other line in my project is also confusing me greatly. It's a loop. It uses similar formatting, which calls an iterator function on a strange variable `\stat`, I don't understand what that notation means. Here is the first line of the loop: `loop state $ \stat -> do`
11:04:40 <ddarius> @undefine
11:05:09 <ddarius> majuscule: You might want to invest some time reading an introduction to the language then.
11:05:17 <bgamari> Enigmagic: So I've gathered
11:05:31 <bgamari> Enigmagic: Seems like it's pretty minimal; it does the parsing but not much more
11:05:35 <strager> majuscule: ^ what ddarius said.  \ creates a new lambda.
11:05:45 <bgamari> which means I need to write my own combinators
11:06:01 <bgamari> not necessarily a bad thing, but it does mean a bit more code
11:06:08 <majuscule> bgamari: strager: thank you
11:06:16 <strager> majuscule: f a b = a b -- This is equivalent to: f = \a b -> a b
11:06:19 <ddarius> I would imagine xml-enumerator/xml-conduit are more about just reading in/writing out XML, not about doing any (tree) parsing on it.
11:06:32 <strager> i.e. everything between \ and -> is a parameter list.
11:06:37 <Enigmagic> bgamari: there are some (using cursors) but it's not a dom replacement .. http://hackage.haskell.org/packages/archive/xml-conduit/0.5.2/doc/html/Text-XML-Cursor.html
11:06:55 <strager> majuscule: Hoogle would have answered \ too: http://www.haskell.org/hoogle/?hoogle=%5C
11:07:11 <majuscule> strager: oh very cool, thanks
11:07:30 * hackagebot privileged-concurrency 0.2 - Provides privilege separated versions of the concurrency primitives.  http://hackage.haskell.org/package/privileged-concurrency-0.2 (JeffShaw)
11:08:05 * ski ponders unprivileged concurrency
11:08:20 <bgamari> Enigmagic: Ahh, I see
11:08:31 * hpc ponders ski's preponderance of ponderance
11:08:43 <ddarius> ski: Privileged concurrency is only for the top 1%.
11:17:31 * hackagebot OpenCLWrappers 0.1.0.1 - The OpenCL Standard for heterogenous data-parallel computing  http://hackage.haskell.org/package/OpenCLWrappers-0.1.0.1 (EmilKarlson)
11:24:29 <ddarius> *sigh*
11:24:36 * ddarius might actually start writing Scala code.
11:24:46 <Kuba> ddarius: scala is cool :)
11:25:28 <mm_freak_> i don't understand why it's so hard for langauge inventors to come up with a lightweight syntax
11:26:08 <mm_freak_> it feels like they desparately need all those curly braces and parentheses
11:26:32 <strager> "whitespace is evil!"
11:26:39 <strager> I must be able to write all of my code on one line.
11:26:50 <mm_freak_> you can in haskell
11:27:02 <strager> Can you write multiple function declarations on one line in Haskell?
11:27:14 <strager> Or import lines or data definitions?
11:27:15 <Qualquercoisa> can anyone help me define split' a l = ([x | x <- l, x <= a], [x | x <- l, x > a]) recursively?
11:27:17 <mm_freak_> f x = y; g x = y
11:27:32 * hackagebot persistent 0.8.0.1 - Type-safe, multi-backend data serialization.  http://hackage.haskell.org/package/persistent-0.8.0.1 (MichaelSnoyman)
11:27:49 <strager> Cool; thought that didn't apply to toplevel functions for some reason.  (Maybe because I've never seen it.)
11:27:51 <ddarius> My issues with Scala have little to nothing to do with its syntax.  But, I can target Dalvik with it and Scala, despite all its fucked-uppedness, is still significantly better than Java.
11:28:02 <mm_freak_> Qualquercoisa: see 'partition' from Data.List
11:28:08 <ddarius> strager: You can write an entire module on one line.
11:28:18 <mm_freak_> > partition (< 5) [1,3,5,7,9,2,4,6,8,10]
11:28:19 <lambdabot>   ([1,3,2,4],[5,7,9,6,8,10])
11:28:34 <ddarius> You can even write multiple modules on one line, but few if any implementations support multiple modules per file.
11:29:04 <mm_freak_> strager: there is nothing fundamentally different about the "where" from the module declaration
11:29:21 <mm_freak_> module X where { …; …; … }
11:29:33 <strager> I see.  Never thought of it that way.
11:29:47 <mm_freak_> Qualquercoisa: or are you practising?
11:29:51 <ben> that's fairly gross
11:30:02 <Qualquercoisa> thank you mm_freak_, i'm currently trying to solve some exercises for my class
11:30:12 <mm_freak_> Qualquercoisa: then, of course, write it yourself =)
11:30:36 <mm_freak_> Qualquercoisa: hint:  f p (x:xs) | … = let (…, …) = f p xs in …
11:31:06 <strager> Qualquercoisa: Try unrolling the comprehensions into minifunctions (with filter).  Then rewrite the use of filter to a recursive call.
11:31:13 <mm_freak_> there are nicer ways to write it, but that's a simple way to start
11:31:44 <strager> By minifunctions I mean let or where declarations.
11:31:45 <strager> =X
11:32:36 <mm_freak_> Qualquercoisa: think about how to express the result of "f p (x:xs)" in terms of "f p xs"
11:33:40 <Qualquercoisa> thank you, i'm trying to solve it
11:37:32 * hackagebot composition 1.0.0.0 - Combinators for unorthodox function composition  http://hackage.haskell.org/package/composition-1.0.0.0 (DanBurton)
11:38:15 <DanBurton> My first darcs-ized project =D
11:38:23 <luite> hehe a .********** b
11:38:35 <DanBurton> just in case ;)
11:38:43 * irene-knapp blinks
11:38:45 <companion_cube> darcs-ized of the moon
11:39:38 <jhbolle> How would you fullscreen a window over several monitors?
11:40:19 <Philippa> DanBurton: any chance of haddocks?
11:40:49 <DanBurton> Philippa: it's got haddocks, but the new version just uploaded, so it hasn't been generated by hackage yet
11:40:54 <DanBurton> the older versions have the docs
11:41:50 <DanBurton> and the actual code is the exact same. The only difference was I decided this was version 1.0, removed the dependency on base, added NoImplicitPrelude, and added links to the darcs repo
11:41:56 <hpaste> zhulikas pasted “y u no work” at http://hpaste.org/64395
11:42:22 <zhulikas> src/Main.hs:34:27:
11:42:23 <zhulikas>     Couldn't match expected type `UDPPackage'
11:42:23 <zhulikas>                 with actual type `Get UDPPackage'
11:42:23 <zhulikas>     In the first argument of `getSource', namely `p'
11:42:23 <zhulikas>     In the second argument of `($)', namely `getSource p'
11:42:23 <zhulikas>     In the expression: print $ getSource p
11:42:35 <zhulikas> oh wait, not what I wanted
11:43:21 <hpaste> zhulikas pasted “y u no work 2” at http://hpaste.org/64396
11:43:30 <DanBurton> zhulikas: it's better to include the error message in the hpaste as a comment
11:43:32 <zhulikas> and error message
11:43:35 <zhulikas> ok
11:43:40 <zhulikas> next time :D
11:43:52 <hpaste> zhulikas pasted “error message” at http://hpaste.org/64397
11:43:57 <DanBurton> ;)
11:44:10 <zhulikas> sorry :D
11:44:40 <zhulikas> so, any clue?
11:46:04 <zhulikas> don't mind that 100 number
11:46:27 <DanBurton> checking it out
11:47:59 <DanBurton> right so the problem is
11:48:19 <DanBurton> decodePacket doesn't produce an IO action, it produces a Get UDPPackage
11:49:13 <DanBurton> I'm guessing you'll need to either do something like:
11:49:21 <zhulikas> well, yes
11:49:24 <DanBurton> let p = runGet $ decodePacket ...
11:49:26 <zhulikas> so printOut produces IO
11:49:30 <zhulikas> and it does in the last line
11:49:43 <DanBurton> or p <- getToIO $ decodePacket ...
11:50:03 <zhulikas> @hoogle getToIO
11:50:03 <lambdabot> No results found
11:50:21 <zhulikas> ah, I see
11:50:56 <DanBurton> yeah go with runGet
11:51:01 <DanBurton> http://hackage.haskell.org/packages/archive/binary/latest/doc/html/Data-Binary-Get.html
11:51:25 <zhulikas> hmm
11:51:52 <zhulikas> damn it, I was hoping to separate that part of the code in a different function
12:02:33 * hackagebot arithmoi 0.2.0.3 - Efficient basic number-theoretic functions.  Primes, powers, integer logarithms.  http://hackage.haskell.org/package/arithmoi-0.2.0.3 (DanielFischer)
12:02:35 * hackagebot privileged-concurrency 0.3 - Provides privilege separated versions of the concurrency primitives.  http://hackage.haskell.org/package/privileged-concurrency-0.3 (JeffShaw)
12:12:01 <zhulikas> @hoogle m a -> n a
12:12:01 <lambdabot> Data.Generics.Aliases unGM :: GenericM' m -> forall a. Data a => a -> m a
12:12:01 <lambdabot> Data.Foldable toList :: Foldable t => t a -> [a]
12:12:01 <lambdabot> Language.Haskell.TH.Syntax qRunIO :: Quasi m => IO a -> m a
12:12:49 <Algo> http://okmij.org/ftp/Computation/Generative.html woot
12:13:47 <zhulikas> @hoogle m a -> a
12:13:47 <lambdabot> Network.BufferType buf_empty :: BufferOp a -> a
12:13:48 <lambdabot> Data.Monoid getDual :: Dual a -> a
12:13:48 <lambdabot> Control.Parallel.Strategies runEval :: Eval a -> a
12:14:22 <zhulikas> I don't know how I managed to fix it...
12:14:25 <zhulikas> and why does it work...
12:14:30 <TheShamanoid> hello there guys
12:14:35 <zhulikas> but somehow I managed to get rid of a monad O.o
12:15:03 <jeff_s_> zhulikas - some functions do that, like fromJust
12:15:14 <zhulikas> but that was a total accident
12:15:20 <zhulikas> and I was struggling with it not working
12:15:28 <Shamanoid> i need help with a frustrating "parse error incorrect indentation" problem
12:15:44 <Shamanoid> anyone kind enough to take a look at my code and tell me what is wrong?
12:15:48 <zhulikas> and BAM I just removed Monad from return type and some return calls
12:16:17 <jeff_s_> Shamanoid - use hpaste to paste your code: http://hpaste.org/
12:16:20 * ski wonders what code zhulikas is talking about
12:16:31 <zhulikas> ah, some code I wrote here for the last 5 hours :D
12:16:33 <Shamanoid> thank you jeff, will d
12:18:30 <Kaidelong> @. pl unpl (f .) . (g .)
12:18:30 <lambdabot> ((f . g) .)
12:19:32 <Shamanoid> hmm, when i posted it on hpaste, i got  completely messed up code
12:19:44 <Shamanoid> is geany a good IDE for haskell?
12:19:51 <Kaidelong> is there a name for that kind of transformation?
12:20:14 <Kaidelong> looks almost like the associative law
12:20:23 <zhulikas> Shamanoid, I (as a noob) prefer Leksah for it's integrated ghci
12:21:02 <jeff_s_> I use Aquamacs, but all I use is its indentation cycle.
12:21:08 <magicman> Kaidelong: That's a Functor law for the ((->)r) FUnctor.
12:21:08 <jeff_s_> (er, haskell-mode)
12:21:18 <magicman> *Functor
12:21:21 <Kaidelong> oh! that's true
12:21:23 <Kaidelong> . is fmap
12:21:32 <rwbarton> it is also the associative law for (.)
12:21:39 <Kaidelong> fmap f . fmap g should be the same as fmap (f . g)
12:22:25 <jeff_s_> Is there a quick way to convert code in layout format to normal format?
12:22:30 <Kaidelong> ran into this trying to translate a C switch statement
12:24:20 <zhulikas> @hoogle Word16 -> Int16
12:24:20 <lambdabot> Unsafe.Coerce unsafeCoerce :: a -> b
12:24:20 <lambdabot> Control.OldException throwDyn :: Typeable exception => exception -> b
12:24:20 <lambdabot> Control.DeepSeq ($!!) :: NFData a => (a -> b) -> a -> b
12:24:24 <zhulikas> any ideas?
12:24:36 <zhulikas> @hoogle Word16 -> Int
12:24:36 <lambdabot> Foreign.Storable alignment :: Storable a => a -> Int
12:24:36 <lambdabot> Foreign.Storable sizeOf :: Storable a => a -> Int
12:24:36 <lambdabot> Data.Generics.Schemes gsize :: Data a => a -> Int
12:24:39 <ski> Kaidelong : distribution ?
12:25:22 <Kaidelong> ski: mmm that makes more sense really
12:25:23 <magicman> zhulikas: fromIntegral?
12:25:40 <Kaidelong> anyway does "WindowMessage -> IO ()" look like a sensible type for mainWindowProc?
12:26:16 <hpaste> Shamanoid pasted “Incorrect indentation” at http://hpaste.org/64398
12:26:41 <Shamanoid> can somebody check if there is something inconsistent with this code?
12:27:06 <zhulikas> magicman, thanks
12:27:16 <Shamanoid> i'm writing a recursive function that has aother recursive function inside it
12:27:51 <rwbarton> Shamanoid: what is your actual question?
12:28:07 <ddarius> rwbarton: His question is "can someone count parentheses for me?"
12:28:23 <rwbarton> ah, gotcha
12:28:32 <ddarius> Also, beyond that, he has a syntax error in the pattern for the top-level function declaration.
12:28:33 <c_wraith> @faw Can someone count parentheses for me?
12:28:33 <lambdabot> The answer is: Yes! Haskell can do that.
12:28:42 <jeff_s_> Shamanoid - put parens areound (x:xs), and put an extra ) on the end.
12:28:43 <c_wraith> haha.  faw.  nice typing, me
12:29:04 <hpaste> Qualquercoisa pasted “Split” at http://hpaste.org/64399
12:29:14 <Shamanoid> i'm sorry all i did to learn haskell was read a website called learnmehaskellforgood
12:29:53 <Shamanoid> thanks to everyone who helped
12:30:33 <Qualquercoisa> How can i change the foldr into a recursive call to split? http://hpaste.org/64399
12:31:09 <Shamanoid> but a quick question, i noticed that some code where a list can be represented as x:xs without parenthesis, when is it possible?
12:32:28 <Shamanoid> also thank you jeff for answering a question in a topic you are more knowledgeable in without bragging about it and making fun of others.
12:32:39 <hpaste> ski annotated “Incorrect indentation” with “Correct indentation” at http://hpaste.org/64398#a64400
12:33:06 <ski> Shamanoid : also, you should strongly consider not using tabs at all
12:33:39 <ion> shamanoid: (:) isn’t special at all, the same rules apply to it as to all other infix operators.
12:34:06 <ion> shamanoid: Just remember that function application has a higher precedence than any infix operator.
12:34:49 <ion> sin 2+foo is parsed as (sin 2)+foo; sin (2+foo) is different.
12:34:56 <ion> sin 2:foo is parsed as (sin 2):foo; sin (2:foo) is different.
12:35:37 <Shamanoid> i see
12:35:57 <ski> Shamanoid : see the above annotation of the paste
12:36:02 <Shamanoid> thanks for the info ion, will keep that in mind
12:36:32 <Shamanoid> also, ski i was about to ask you why you dont recommend using tabs, i will check that hpaste now
12:37:07 <ski> (also, i took the liberty of fixing you're recursive call for `check_values', opting to not pass `a',`b' around in arguments)
12:37:27 * ski sighs
12:38:00 <Shamanoid> thanks very much, looks much more neater
12:40:23 <ski> anyway, if you're using tabs, you should make sure to *only* use tabs for indentation (no indentation spaces) and also you should make sure to break the line after every layout-introducing keyword (i.e. `where',`let',`of',`do') which is starting a layout block of more than one line
12:40:53 <ski> Shamanoid : if you think that's hard to recall, you're safer off with not using tabs at all (only spaces) for indentation
12:44:18 <t7> does anyone have a super tiny implementation of the hindley milner type inference algo in haskell? please
12:45:17 <Philippa> how tiny is super tiny?
12:45:25 <t7> like 100 LOC :)
12:45:33 <Philippa> hmm, that might be pushing it slightly
12:45:44 <Philippa> though 200 isn't such an issue
12:45:44 <MostAwesomeDude> t7: Why?
12:45:54 <bmm> What is up with the Crypto package. The html in the release points to a darcs repo that does not exist and the README and html don't match. I can't find the homepage or latest (which I need :) )
12:46:02 <t7> i found one in python but its not purely function and its a bit hard to follow
12:46:04 <Philippa> but honestly? You can find code to do unification on hackage, you should be able to code the rest up yourself from there?
12:46:31 <ddarius> @hackage wired
12:46:31 <lambdabot> http://hackage.haskell.org/package/wired
12:47:29 <t7> i thought there was like 4 parts to hm, and unification was just one?
12:47:54 <`Jake`> Do you guys listen to music while coding?
12:48:12 <Taneb> Yes
12:48:13 <MostAwesomeDude> `Jake`: Sure. Are you looking for suggestions?
12:48:13 <t7> dubstep while coding perl
12:48:20 <`Jake`> Yeah
12:48:21 <jeff_s_> I used to, but not anymore.
12:48:28 <t7> ambient while coding everything else
12:48:37 <Taneb> Mainly the Homestuck music
12:48:41 <Philippa> t7: unification is by far the easiest to mess up
12:48:43 * ski . o O ( "Polymorphic Type Inference" by Michael I. Schwartzbach in 1995-03 at <http://www.brics.dk/~mis/typeinf.pdf> )
12:48:55 <`Jake`> dubstep seems to be a little bit too distracting for me
12:48:59 <Philippa> ski: I ported Cardelli's old, imperative code once upon a time
12:49:12 <Philippa> I'd rather go liquid than dubstep for coding
12:49:30 <ski> `Jake` : sometimes
12:49:30 <MostAwesomeDude> I prefer prog.
12:49:43 <Philippa> but honestly? I think there's about a quarter of DI's streams I'll happily listen to while coding depending on what mood I'm in
12:49:53 <Philippa> (but I don't recommend gabber)
12:49:56 <Taneb> I can listen to anything, but if I can make out the lyrics,  I get distracted
12:50:07 <t7> thanks ski, i will try to grok this one :)
12:50:28 <ski> (e.g. demoscene music, game music. anything purely instrumental that is enjoyable)
12:50:47 <`Jake`> thank you all
12:50:58 <jeff_s_> sk - I like pages 17-19 the best.
12:51:47 <Philippa> ski: blatant vocal samples are okay for me too. So half of Jet Set Radio's soundtrack (preferably the PAL/De La release)
12:52:52 * ddarius can sing and code, but usually doesn't listen to music nowadays when coding.
12:53:18 <xz> anyone know what happened to kiwilight.com and archhaskell?
12:53:19 <brisingr> say I want to make an abstract system that accepts continuous data (e.g. from sensors) and processes it according to sporadic inputs (e.g. human interaction). How would I do that elegantly using haskell?
12:54:11 <hash`> Hi. Is there a monad/functor that has the property of having two types such that when sequence is applied to it if they're all of the first type, it returns FirstType [...], but if any are of the second type it returns SecondType [...] such that all members of [...] where of type SecondType?
12:54:46 <hash`> The idea is I check to see if all my data is valid, and if there are any that aren't I want to see them and them only.
12:55:01 <Taneb> Sounds a bit like Either?
12:55:12 <hash`> Yes, though either isn't a monad or functor, is it?
12:55:17 <jeff_s_> Yup, sounds like Either [a] [b]
12:55:22 <jeff_s_> Sure, Either is a monad.
12:55:27 <MostAwesomeDude> Either a is a monad.
12:56:02 <hash`> So if I have [Left 5, Right 6] I can apply sequence to it?
12:56:07 <t7> could someone give me an example of a type that can't be expressed in HM but can in system F?
12:56:22 <ddarius> hash`: You can, but you will get Left 5
12:56:36 <MostAwesomeDude> > sequence [Left 5, Right 6]
12:56:37 <lambdabot>   Left 5
12:57:03 <hash`> > sequence [Left 5, Right 6, Left 7]
12:57:03 <lambdabot>   Left 5
12:57:08 <Taneb> > sequence [Right 5, Left 6]
12:57:09 <lambdabot>   Left 6
12:57:31 <hash`> That's close enough, one error tells me a lot.
12:57:34 <hash`> Thanks!
13:00:49 <hash`> Now I knos why I thought it wasn't a monad. When I bring up ghci and I do the same thing I get the error No instance for (Monad (Either t))
13:01:11 <Taneb> :m + Control.Monad.Instances
13:01:15 <hash`> Thanks!
13:01:30 <Taneb> No problem
13:01:48 <Taneb> Wow, there're 900 people in this channel
13:02:01 <Taneb> 901
13:02:48 <hash`> Haskell is becoming popular :)
13:03:09 <Taneb> It's gotta be the most populat "unpopular" language
13:03:11 <ski> we fear Haskell is doomed to succeed
13:03:50 <hash`> Is there a road map for Haskell, or does it just evolve?
13:04:10 <Taneb> Haskell Prime is the closest thing to a roadmap
13:04:14 <tomodo> people like us aren't told about The Plan
13:04:50 <c_wraith> well.  haskell the language spec is driven by haskell prime.  GHC is driven by whoever wants to write cool extensions
13:05:03 <c_wraith> (and the language spec, but that's slower)
13:05:36 <jeff_s_> I still find the record system to be kind of disgusting, but I'm getting used to it.
13:06:04 <MostAwesomeDude> jeff_s_: data-lens helps with that.
13:06:10 <hash`> Speaking of which, is there any way to "copy" a record instance with a few of its fields over-written?
13:06:35 <jeff_s_> It does, but it has its own problems - like not trivial to learn. Probably it's because I've been lazy about learning it.
13:06:44 <c_wraith> hash`: yes.  recurd update syntax.  foo { bar = baz }
13:07:00 <c_wraith> hash`: you can specify multiple updates, comma-separated.
13:07:05 <hash`> So let x = y { z = 5 } ?
13:07:10 <c_wraith> sure
13:07:11 <jeff_s_> which isn't as nice as OCaml's syntax: {foo with bar = baz}
13:07:11 <hash`> Nice.
13:07:26 <hash`> why is the OCaml syntax better?
13:07:37 <jeff_s_> I find it confusing that "foo {...}
13:07:41 <MostAwesomeDude> I like the lens syntax: let x = z y 5
13:07:41 <jeff_s_> " is a single term.
13:07:49 <jeff_s_> {foo with ...} makes it obvious.
13:08:17 <ski> jeff_s_ : hm .. is nested record update nicer in O'Caml ?
13:08:44 <hash`> Is this a general consensus, that the syntax could be better?
13:08:46 <c_wraith> I wonder if just having anonymous record update would clear up a bunch of the issues.
13:08:55 <jeff_s_> it's probably no better. I haven't used OCaml in a while though, so I don't want to say for sure.
13:09:01 <c_wraith> yes, record update syntax is *definitely* a wart
13:09:11 <c_wraith> because it isn't a function
13:09:26 <jeff_s_> yes, exactly, tahnk you c_wraith. It looks like function application, but it's not.
13:09:27 <c_wraith> so to use it in places where you want to use a function, you need to make it a lambda
13:09:57 <hash`> Interesting. In Go when there's a syntax change there's an upgrade script that guarantees to correctly upgrade all old code. This is different than, say, Python 2.x to 3 where it's impossible.
13:10:09 <hash`> Is Haskell syntax strongly specified enough to allow such a script?
13:10:38 <jeff_s_> hash - I think template haskell basically already does things like that.
13:10:42 <c_wraith> so, like, with State, you end up with things like «modify $ \s -> s { foo = bar }».
13:11:06 <hash`> I see.
13:11:10 <ski> jeff_s_ : i don't think that's the same thing
13:11:46 <jeff_s_> Hm, I guess you're right. I'm confusing template haskell with what camlp4 does.
13:12:12 <osa1> I'm writing some data structures in haskell, mostly for learning purposes, what is the easiest way to measure some times of some operations and memory usage?
13:12:22 <hash`> If there's consensus and a method, talking should be upgraded to acting :)
13:12:32 <hash`> Or at least bug filing.
13:12:37 <jeff_s_> osa1: http://book.realworldhaskell.org/read/profiling-and-optimization.html
13:14:03 <c_wraith> hmm.  I wonder if record update could be made anonymous, such that it results in actual functions.  «data F = F { a :: Int, b :: String } ; foo = F 0 ""», then you could do something like «foo {b =} :: String -> F»
13:14:21 <c_wraith> This seems like it wouldn't step on any existing syntax
13:14:37 <c_wraith> And would make record update actually a function
13:17:07 <c_wraith> Oh, but it wouldn't help with the modify case
13:18:09 <c_wraith> unless you could do «{b = "foo"} :: F -> F».  However, *that* would step all over existing syntax.  *sigh
13:18:38 <parcs`> what about \{b = "foo"}
13:19:18 <hash`> Hmmm. I wonder about sub-modifications. I.E., data X = X { x :: Int }, data Y = Y { y :: X }. Is there a nicer way than let z' = z { y = { x = 5 } }
13:19:29 <hash`> Assuming that even works.
13:19:32 <c_wraith> well, that'd be a mild improvement.  There's still a missing case, though...  And that's read/write of a subfield as one operation
13:20:05 <c_wraith> which is what hash` is talking about
13:20:05 <parcs`> \{b %= (++ "foo")} ?
13:20:09 <hash`> *nods*
13:20:36 <c_wraith> That'd be stealing something from existing operator space.  Not so nice.
13:20:37 <parcs`> what are good examples of record systems implemented in other languages?
13:20:43 <hash`> I've seen a language where this is the syntax... let z' = z where .y.x = 5
13:21:08 <hash`> Which is really nice. The only downside is for two updates it likes this:
13:21:30 <hash`> let z' = z where .y.x = 5 where .y.x' = 6
13:21:41 <c_wraith> \{b \= (++ "foo")}    ... it's ascii soup
13:21:53 <hash`> AKA Perl.
13:23:45 <c_wraith> heh.  So, what would the type of \{b \=} be? F -> (String -> String) -> F
13:23:58 <hash`> Any solution should handle multiple updates of differing depths with aplomb.
13:25:28 <hash`> Also, should it be letrec or let in Lisp terminology, i.e. recursive within the expression.
13:27:52 <ski> well, it'd be nice to both get a name for the old contents, and (possibly) define the new one recursively
13:28:09 <mhitza> if I create a module and have "module name where" at top, every single definition will be exported, right?
13:28:23 <ski> yep
13:28:43 <mhitza> ok, thanks :)
13:29:44 <hash`> Since you're creating a new object, recursive should be simple. I.E. using the more imperitive syntax let z' = z where .x = .y where .y = 5
13:30:16 <hash`> If you want to refer to the old object you do z.x or z.y
13:30:25 <ski> hash` : no, you actually need to say `z1 = z0 { y = (y z0) { x = 5 } }'
13:30:26 <lukish> How can it possible to import modules in ghc?
13:30:28 <lukish>  echo "29371923471239" | ghc -e "getContents >>= putStrLn . intersperse \".\" . splitEvery 3 . reverse"
13:30:29 <hash`> If only there were an operator to get at record fields.
13:30:34 <lukish> <interactive>:1:46: Not in scope: `splitEvery'
13:30:54 <lukish> I need to import Data.List.Split
13:31:34 <ski> hash` : referring to the old object like that is cumbersome for nested updates
13:31:50 <hash`> ski : Hmmm.
13:32:03 <ski> (especially if you're modifying the result of a large expression)
13:35:37 <johnbender> for pure functions is composition ever _not_ associative?
13:36:05 <Philippa> nope
13:36:10 <Cale> johnbender: No, it's always associative
13:36:11 <johnbender> Philippa: thank you
13:36:11 <ski> function composition is associative
13:36:16 <johnbender> thanks
13:36:16 <Cale> Even for non-pure functions
13:36:21 <johnbender> Cale: !
13:36:23 <johnbender> great
13:36:42 <hpc> isn't that a free theorem or something?
13:36:43 <johnbender> thanks all!
13:37:06 <efie> where is my mistake? http://hpaste.org/64404
13:37:09 <Cale> Well, in the latter case, it's one of the monad laws :)
13:37:19 * ski . o O ( operads )
13:37:19 <hpc> @free comp :: (b -> c) -> (a -> b) -> (a -> c)
13:37:20 <lambdabot> g . k = p . f => f . q = f1 . h => g . comp k q = comp p f1 . h
13:37:50 <Cale> (f <=< g) <=< h = f <=< (g <=< h)
13:38:01 <Cale> Where <=< is the Kleisli fish ;)
13:39:55 <stulli> efie: if i see it correctly the parenthesis are unbalanced
13:40:27 <efie> stulli: ah.. thanks ..
13:40:29 <efie> !
13:40:42 <brisingr> I want to make a system that accepts a continuous stream of data and processes it based on an intermittent stream of "commands". how can I do it?
13:41:50 <brisingr> it would be perfect if it would also be a monad
13:42:32 <Cale> brisingr: could you be a bit more concrete?
13:43:38 <Cale> brisingr: Should the result be indeterministic based on exactly when the commands come in relative to the data? Or will there be some way of telling how the streams are meant to be interleaved?
13:43:40 <brisingr> Cale: a hypothetical system that takes sensor inputs, processes it then outputs it, but also accepting user commands _while_ it is doing that
13:43:54 <stulli> I have a nice pattern in my code but don't know how to take advantage of it: http://hpaste.org/64405
13:43:58 <Cale> Okay. So probably just standard concurrency stuff?
13:44:02 <brisingr> yes
13:44:58 <stulli> Could somebody take a quick look and see if there is a quick way to make scale?
13:45:35 <stulli> I'm a little exhausted after working the whole day on this euler problem...
13:45:36 <Cale> lukish: "import Data.List.Split" should work
13:45:45 <Cale> lukish: sorry I missed your question before :)
13:46:00 <Cale> brisingr: Look into forkIO, Chan and MVar to start with, I think.
13:46:12 <brisingr> Cale: thanks
13:46:49 <ski> and possibly `SampleVar'
13:47:00 <Eduard_Munteanu> I guess some select()-based approach might work too, but I'm unsure what's the best way to get to a select().
13:47:18 <Cale> Yeah, SampleVar might be nice for reading from sensors, when you might not want to process every datapoint.
13:47:29 <lukish> Cale: where should I write it?
13:47:32 <Cale> (but you also don't want to process the same datapoint twice)
13:47:36 <lukish> $> echo "29371923471239" | ghc -e "import Data.List.Split;  getContents >>= putStrLn . intersperse \".\" . splitEvery 3 . reverse"
13:47:41 <Cale> oh
13:47:42 <lukish> Is not working
13:49:47 <Cale> hmm, odd
13:50:56 <lukish> I've read some man ghc
13:51:02 <lukish> But nothing usable
13:51:08 <lukish> For importing modules
13:51:48 <Cale> hmm, this works:
13:51:49 <Cale> echo "29371923471239" | ghc -e ":m + Data.List.Split Data.List" -e "getContents >>= putStrLn . intercalate \".\" . splitEvery 3 . reverse"
13:52:40 <Cale> echo "29371923471239" | ghc -e "import Data.List.Split" -e "import Data.List" -e "getContents >>= putStrLn . intercalate \".\" . splitEvery 3 . reverse"
13:52:43 <Cale> also works
13:53:32 <lukish> Ow
13:53:39 <Cale> Eduard_Munteanu: The best way to get a select() is to use forkIO :)
13:53:48 <lukish> Cale: thanks
13:54:02 <Cale> Eduard_Munteanu: because it'll use better things like epoll/kqueue when available :)
13:54:46 <Eduard_Munteanu> Ah.
13:57:53 <Cale> augh, you know you've messed something up when you get type errors in which a monad parameter has mysteriously been replaced by Set :)
14:00:15 <ivanm> Cale: :o
14:00:31 <Cale> Yeah, it was just something derpy :)
14:01:51 <Enigmagic> herp
14:02:10 <ktklam9> hi, how can I verify that my tail-recursive function is being optimized by the GHC?
14:02:52 <mauke> what does that even mean
14:03:10 <ivanm> ktklam9: by profiling?
14:03:24 <srhb> The right way would be to inspect the result and look for the loop I suppose.
14:03:41 <ivanm> compile and profile with -O0 vs compile and profile with -O and see what the timing for the particular function is?
14:03:51 <Cale> Yeah, you could -ddump-simpl
14:04:00 <Cale> or whatever that flag was
14:04:06 <ski> checking whether something is tail-recursive is usually easy
14:04:37 <Cale> tail recursive is not always good under lazy evaluation
14:05:09 <Cale> you could also -ddump-asm and read the assembly output :)
14:05:30 <srhb> That would probably be easiest, really. aside from just profiling and assuming, when the result is faster.
14:06:18 <ktklam9> uhh... -O0 and -O2 giving approximately the same time
14:06:33 <Cale> ktklam9: Is it consuming tons of memory?
14:06:42 <ktklam9> but I guess if I call the function 100000 times and the stack doesn't blow up, I would assume it's optimized by the GHC right?
14:06:58 <Cale> ktklam9: You have to be careful. There is no call stack in GHC compiled programs.
14:07:09 <Cale> There is a stack, but it's a pattern match stack, not a call stack.
14:07:16 <srhb> If you're evaluating strictly, then yes, you can assume that.
14:07:26 <srhb> (More or less)
14:07:33 <ivanm> ktklam9: program runtime or profiling for that function?  because the former could be unrelated to your function unless it is your entire program
14:07:35 <mauke> ktklam9: no
14:07:47 <Cale> However, you will tend to get stack overflows if you mess things up with attempts at tail-recursion.
14:08:08 <Cale> (provided you're doing something like foldl of a strict function over a long list)
14:08:40 <Cale> However, GHC's strictness analyser is pretty clever. Compiling with -O2 can remove stack overflows :)
14:09:13 <ivanm> Cale: is that in -O1 as well or just -O2 ?
14:09:23 <Cale> Um... I think it's in -O1 as well
14:09:35 <Paprikachu> it's not the responsibility of the compiler to remove bugs of your program. i would consider this a bug, rather than a feature.
14:10:20 <Cale> Paprikachu: The fact that there is a bounded stack is a bit of a problem in the first place.
14:10:55 <Paprikachu> if the compiler detects it, it should give you are warning. silent removal is evil.
14:11:12 <Cale> It's not like it detects a stack overflow and removes it as such
14:11:46 <Paprikachu> what is it like?
14:11:49 <Cale> It just causes the program to not leave pattern matches on the stack quite as much, by strictly evaluating things when it won't change the behaviour of the program.
14:12:07 <Cale> (when it knows that they'll be needed later)
14:13:06 <Paprikachu> it actually does affect the behavior.
14:13:13 <Cale> It is the compiler's responsibility to manage resources. Stack overflow is like a resource exhaustion problem, rather than a real bug in those cases where it is removable.
14:13:27 <Paprikachu> when compiling wiht -O2 it works, when not it doesn't
14:13:59 <Paprikachu> the compiler doesn't know pretty much about resources.
14:14:07 <Cale> The fact that the stack is bounded is an infelicity of the compiler in the first place. Just letting the stack grow as the heap does would be perfectly reasonable, but would be obnoxious when programs go wrong on some OSes :)
14:14:10 <ski> replacing a non-terminating program with a terminating one would otoh be unacceptable
14:14:33 <Enigmagic> Cale: you can disable the stack check
14:14:41 <Enigmagic> it will grow chunk at a time
14:15:02 <Paprikachu> the program should just crash regardless of compiler options.
14:15:33 <Paprikachu> there could be an option to force the compiler to do it, that would be okay.
14:15:33 <mauke> Paprikachu: I take it you don't like scheme
14:16:12 <Paprikachu> scheme?
14:16:27 <mauke> you don't know scheme? your opinion is invalid
14:16:37 <ski> (Scheme doesn't have tail-call optimization, though)
14:16:46 <MostAwesomeDude> Scheme *requires* TCO.
14:16:49 <t7> implementations have to
14:17:06 <stulli> repaste: http://hpaste.org/64405 Would that be a canditate for a monad? I just can't wrap my head around this pattern.
14:17:19 <ski> (it has "proper tail recursion" as a guaranteed property of the language, which is different from an optimization an implementation might choose to employ)
14:17:20 <Paprikachu> depends on how you define "to know a language"
14:17:36 <Paprikachu> i know that it does exist
14:17:42 <Paprikachu> but that's it
14:17:57 <tomodo> ski, what's the difference?
14:18:46 <ski> tomodo : it's exactly specified (in an abstract way) when you get it and you can rely on this
14:19:03 <t7> it means you can write code in a recursive style without worrying about stack overflow
14:19:21 <mauke> t7: what would a non-recursive style look like?
14:19:31 <t7> a while loop
14:19:36 <mauke> scheme has no while loop
14:19:46 <t7> set!
14:20:03 <ski> e.g. MIT-Scheme stores info about the last 100 or so calls, regardless of whether they're tail-calls or not. the reason it can do this and still claim to have "proper tail recursion" is because it can still support an unbounded number of active tail-calls in bounded space
14:21:02 <tomodo> ski: I understand
14:21:04 <ski> mauke : there is `do', and things like Riastradh's <http://mumble.net/~campbell/tmp/foof-loop.txt>, also see <http://groups.google.se/group/comp.lang.scheme/msg/60dcac5ea812398>
14:21:06 <tomodo> thank you
14:21:27 <ski> tomodo : "Proper Tail Recursion and Space Efficiency" by William Clinger at <http://www.cesura17.net/~will/Professional/Research/Papers/tail.pdf> might be interesting
14:22:07 <shergill> anyone here have experience with using haskell with hadoop streaming/pipes api?
14:22:08 <ski> (of course, stuff like `do' are implemented in terms of tail-recursion, though)
14:23:27 <duairc> Is it possible to define an equivalent of unsafeInterleaveIO for all MonadFixes?
14:31:49 <lukish> $> echo "29371923471239" | ghc -e "import Data.List.Split" -e "getContents >>= (putStrLn . reverse . concat . intersperse \".\" . splitEvery 3 . reverse)"
14:31:52 <lukish> 293.719.234.712.39
14:31:54 <lukish> Why?
14:32:16 <lukish> > reverse . concat . intersperse "." . splitEvery 3 . reverse $ "29371923471239"
14:32:17 <lambdabot>   Not in scope: `splitEvery'
14:32:40 <lukish> Well, it's "29.371.923.471.239"
14:32:44 <lukish> Actualy
14:33:43 <lukish> Cale: any ideas?
14:35:30 <Jafet> > map (take 3) . takeWhile (not.null) . iterate (drop 3) . reverse $ "29371923471239\n"
14:35:31 <lambdabot>   ["\n93","217","432","917","392"]
14:35:44 <Jafet> :t interact
14:35:44 <lambdabot> (String -> String) -> IO ()
14:42:14 <lukish> Jafet: reverse . concat . intersperse "." . splitEvery 3 . reverse is doing what I need
14:42:27 <lukish> Problem is in getContents >>=
14:43:08 <mauke> lukish: \n
14:43:25 <Jafet> Operator error.
14:44:01 <lukish> Oh
14:44:11 <lukish> Fixed it with echo -n
14:44:52 <ion> «printf '%s'» > «echo -n»
14:45:10 <lukish> Why?
14:45:15 <magicman> > intercalate "." ["123","456","789"]
14:45:16 <lambdabot>   "123.456.789"
14:45:47 <magicman> (minor, but useful to know. concat . intersperse x is in Data.List as intercalate)
14:46:19 <lukish> Yes, forgot about it
14:49:09 <hpaste> ski annotated “I see a pattern...” with “why not ...” at http://hpaste.org/64405#a64413
14:49:35 <ski> @tell stulli <http://hpaste.org/64405#a64413>
14:49:35 <lambdabot> Consider it noted.
14:50:23 <ion> lukish: There’s some unportability with the various echo parameters (e.g. -n is a BSD extension and -e is a GNU extension AFAIU). It’s very difficult to guard against unintended consequences from a string to be printed that happens to begin with a dash. The POSIX standard encourages you to use printf instead of echo.
14:50:31 <ski> duairc : how would it work in `Maybe' or `[]' ?
14:54:26 <ion> lukish: (Also from unintended consequences from strings that happen to contains backslashes.)
14:55:11 <duairc> ski: I don't really know. All I have is an intuitive idea that MonadFix and unsafeInterleaveIO do the "same kind of thing", but I find the former a lot easier to use.
14:55:26 <ion> POSIX-compliant echo prints '\0101' as A, GNU echo prints '\0101' as \0101.
14:55:50 <ski> duairc : i'm not sure i see how they do the "same kind of thing" ..
14:56:22 <mauke> \0101 as A? that's just crazy
14:56:32 <ski> @type mfix
14:56:32 <duairc> ski: Well mfix can be defined in terms of unsafeInterleaveIO: mfix f = unsafeInterleaveIO (mfix f) >>= f
14:56:33 <lambdabot> forall a (m :: * -> *). (MonadFix m) => (a -> m a) -> m a
14:56:33 <ski> @type System.IO.Unsafe.unsafeInterleaveIO
14:56:34 <lambdabot> forall a. IO a -> IO a
14:56:36 <Draconx|Laptop> ion, POSIX says that the behaviour of echo when the string contains a backslash is implementation-defined.
14:57:16 <Draconx|Laptop> ion, so both behaviours you describe are acceptable and compliant with the standard, provided that it's documented.
14:57:21 <ski> duairc : no, that's not correct
14:57:55 <ski> duairc : `mfix (\x -> ..x..)' should perform the effects of `..x..' *once*
14:58:22 <vodik> Draconx|Laptop: and gnu grep will do \0101 just fine if you give it -e
14:58:48 <ion> Ah, i read too hastily. The POSIX text only says: «The historic System V echo and the requirements on  XSI  implementations in this volume of IEEE Std 1003.1-2001 are equivalent to: printf "%b\n" "$*"» (which does process backslash sequences).
14:58:58 <ski> > '\0101'
14:58:59 <lambdabot>   'e'
14:59:25 <duairc> ski: http://www.haskell.org/ghc/docs/latest/html/libraries/base/src/System-IO.html#fixIO This is actual MonadFix instance for IO, it's similar to mine except that it does some mucking about with MVars
15:00:20 <ski> duairc : yes, the mutable cells are essential for the `IO' case
15:00:43 <ski> duairc : note how that doesn't call `unsafeInterleaveIO' on `fixIO k'
15:01:07 <ski> the behaviour is different from what you were suggesting
15:02:50 <duairc> ski: Okay, I think I understand. In any case it's still implemented in terms of unsafeInterleaveIO which is the real point I was trying to make.
15:03:21 <ski> @src Maybe mfix
15:03:21 <lambdabot> mfix f = let a = f (unJust a) in a where unJust (Just x) = x
15:03:24 <ski> @src [] mfix
15:03:25 <lambdabot> mfix f = case fix (f . head) of
15:03:25 <lambdabot>            []    -> []
15:03:25 <lambdabot>            (x:_) -> x : mfix (tail . f)
15:04:39 <ski> anyway, i don't think the `unsafePerformIO' generalizes (apart from the `unsafeInterleaveST' case)
15:05:04 <ski> if you can figure out any way (even partial) in which to generalize, i'm all ears
15:05:24 <duairc> Okay :) That's what I suspected. It's headwrecking thinking about this stuff.
15:05:30 <ski> (possibly there could be stuff for `STM' as well, i'm not sure)
15:07:40 * hackagebot shelltestrunner 1.2 - A tool for testing command-line programs.  http://hackage.haskell.org/package/shelltestrunner-1.2 (SimonMichael)
15:08:30 * ski sees no `unsafeInterleaveSTM' nor a `MonadFix STM'
15:09:24 <hpc> can STM perform IO?
15:09:32 <hpc> (by which i mean, can you write liftIO for it)
15:10:25 <hpc> i don't think unsafeInterleaveSTM would actually be unsafe
15:10:44 <hpc> oh no, yes it would
15:11:02 <geekosaur> hpc, no.  or, you "can" by means of various unsafeThingies, but you lose everything that makes STM useful in the process
15:11:10 <hpc> yeah
15:11:26 <hpc> sounds about right
15:14:31 <duairc> ski: Wait, I think I just understood what "`mfix (\x -> ..x..)' should perform the effects of `..x..' *once*" means. Damn. I think I want an mfix that peforms the effects of '..x..' each time.
15:14:52 <duairc> I'm trying to write this function: http://hpaste.org/64415
15:15:29 <hpc> :t forever
15:15:30 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m a -> m b
15:15:51 <hpc> @src forever
15:15:51 <lambdabot> Source not found. It can only be attributed to human error.
15:15:56 <hpc> pah
15:16:06 <hpc> duairc: you can write that with regular fix
15:16:19 <ski> @where MonadFix_Cont
15:16:20 <lambdabot> "Value recursion in the continuation monad" by Magnus Carlsson in 2003-01-07 at <http://www.carlssonia.org/ogi/mdo-callcc.pdf> (there's also slides at <http://www.carlssonia.org/ogi/mdo-callcc-
15:16:20 <lambdabot> slides.pdf>)
15:16:25 <ski> duairc : ^ might be interesting
15:17:26 <duairc> hpc: How?
15:17:39 <ski> hpc : i suspect duairc might want a `repeatM' (that works with e.g. `IO')
15:17:50 <hpc> ah
15:17:54 <ski> @type replicateM
15:17:55 <lambdabot> forall (m :: * -> *) a. (Monad m) => Int -> m a -> m [a]
15:18:01 <fryguybob> hpc: The assumption that no IO happens in STM goes beyond the effects of that IO happening twice (in GHC).
15:18:08 <hpc> :t sequence . repeat
15:18:08 <lambdabot> forall (m :: * -> *) a. (Monad m) => m a -> m [a]
15:18:54 <r0adrunner> hi
15:18:54 <lambdabot> r0adrunner: You have 1 new message. '/msg lambdabot @messages' to read it.
15:19:33 <r0adrunner> anyone got hsmagick to work???
15:20:05 <ski> hpc : now try that in `IO' :)
15:20:41 <hpc> ski: :P
15:21:59 <duairc> ski: So MonadFix isn't what I thought it was then? If mfix was as I defined it above, my code would do what I want it to do, but unfortunately it isn't and so it doesn't.
15:22:29 <ski> duairc : you can use `mfix' in `IO' to create cyclic structures with `IORef' or `MVar' e.g.
15:26:44 <Shamanoid> guys why doesnt the _ work in a guard?
15:27:35 <sipa> _ is used in pattern matching for thing you don't care about
15:27:40 <sipa> they are not bound to any variable
15:27:50 <sipa> what would _ mean in an expression?
15:28:08 <hpc> Shamanoid: function patterns | boolExpr = ...
15:28:09 <Shamanoid> but when i use them in a guard i get a "pattern syntax"
15:28:58 <liyang> Shamanoid: perhaps it's ‘otherwise’ you want.
15:29:07 <Shamanoid> for example i want to say " | function [] _ _ csp = csp"
15:29:32 <Shamanoid> i.e if one f the variables of a function is an empty list, return csp
15:30:36 <liyang> In that case you just write “function [] _ _ csp = csp”. No guards necessary.
15:31:03 <ski> @type let newCyclicIORef :: (Data.IORef.IORef a -> a) -> IO (Data.IORef.IORef a); newCyclicIORef f = mfix (Data.IORef.newIORef . f) in newCyclicIORef
15:31:04 <lambdabot> forall a. (GHC.IORef.IORef a -> a) -> IO (GHC.IORef.IORef a)
15:31:07 <ski> @type let newCyclicIORefT :: Data.Traversable.Traversable t => (t (Data.IORef.IORef a) -> t a) -> IO (t (Data.IORef.IORef a)); newCyclicIORefT f = mfix (Data.Traversable.mapM Data.IORef.newIORef . f) in newCyclicIORefT
15:31:08 <lambdabot> forall (t :: * -> *) a. (Data.Traversable.Traversable t) => (t (GHC.IORef.IORef a) -> t a) -> IO (t (GHC.IORef.IORef a))
15:31:23 <sipa> Shamanoid: can you give an example?
15:31:40 <ski> ^ sometimes handy, when constructing cyclic structures via `IORef'
15:31:48 <Shamanoid> i tried that, i end up with a "parse error on input |"
15:32:20 <liyang> There shouldn't be any ‘|’s.
15:32:32 <Shamanoid> if you are saying that no guards needed is right, it must mean i have an issue with the rest of the body
15:33:11 <liyang> Shamanoid: http://hpaste.org/
15:34:00 <ski> > let foo | True = () in foo
15:34:00 <lambdabot>   ()
15:34:11 <hpaste> Shamanoid pasted “rookie code” at http://hpaste.org/64416
15:34:32 <vodik> Shamanoid: intending
15:34:51 <vodik> Shamanoid: line 10 is intended too far
15:35:19 <Shamanoid> i'm having an issues making this work, i fix an issues i end up with 10 more
15:36:04 <vodik> Shamanoid: you're mixing tabs and spaces too
15:36:18 <Shamanoid> what is intended again/
15:36:20 <Shamanoid> ?
15:36:21 <ski> Shamanoid : i suggest replacing the tabs with spaces
15:36:33 <Shamanoid> i'm using 2 spaces now
15:36:36 <hpaste> vodik annotated “rookie code” with “rookie code (annotation)” at http://hpaste.org/64416#a64417
15:37:02 <hpaste> hpc annotated “rookie code” with “rookie code (annotation)” at http://hpaste.org/64416#a64418
15:37:13 <Shamanoid> but when i paste the code from geany to the website it becomes a mess
15:37:20 <hpc> lol
15:37:37 <vodik> Shamanoid: i know, thats because you formatter things wrong
15:37:58 <vodik> Shamanoid: set your editor to expand tabs to spaces
15:38:09 <hpc> or don't, and type spaces yourself
15:38:10 <hpc> :P
15:38:13 <ski> Shamanoid : that's probably because you're using tabs, and your editor displays tabs as not 8 spaces
15:38:28 <hpc> either works, but it's best to get in the habit of not hitting tab at all
15:38:57 <Sgeo> > do { a <- [1,2]; b <- [1,3]; c <- [1,5]; return ((a,b,c), a+b+c)) }
15:38:57 <lambdabot>   <no location info>: parse error on input `)'
15:39:02 <vodik> Shamanoid: writespace matters in haskell
15:39:08 <ski> (in `haskell-mode', `TAB' is bound to `indent-for-tab-command')
15:39:27 <Sgeo> > do { a <- [1,2]; b <- [1,3]; c <- [1,5]; return ((a,b,c), a+b+c) }
15:39:27 <lambdabot>   [((1,1,1),3),((1,1,5),7),((1,3,1),5),((1,3,5),9),((2,1,1),4),((2,1,5),8),((...
15:39:56 <Shamanoid> i'm working on not using the tab at all now
15:40:41 <vodik> Shamanoid: or just have your editor automatically convert it to spaces
15:40:50 <ski> (hpc : it's also possible to use tabs solely for indentation, i know some do)
15:40:53 <vodik> (for vim) :set expandtab
15:42:02 <Shamanoid> there is an option in geany that says detect indentation type from file
15:42:06 <Shamanoid> will that work?
15:42:29 <ski>   (setq-default indent-tabs-mode nil)  ; for emacs
15:46:46 <Shamanoid> i set the tab indentation to 1, but it still inserts a significant space
15:47:19 <mauke> "significant space"?
15:48:28 <mauke> Preferences > Editor > Indentation > Type > (*) Spaces
15:49:02 <Shamanoid> http://i.imgur.com/jzYju.png
15:49:21 <mauke> set width to 4 or something
15:49:26 <mauke> and change "tabs and spaces" to "spaces"
15:50:03 <Shamanoid> that was what it was previously :s
15:52:42 * hackagebot anansi-pandoc 0.1 - Looms which use Pandoc to parse and produce a variety of formats.  http://hackage.haskell.org/package/anansi-pandoc-0.1 (JohnMillikin)
15:57:42 * hackagebot BiobaseFasta 0.0.0.3 - Iteratee-based FASTA parser  http://hackage.haskell.org/package/BiobaseFasta-0.0.0.3 (ChristianHoener)
16:15:03 <cool_beans> Hello!
16:15:03 <hpaste> rribeiro pasted “Strange infered type” at http://hpaste.org/64420
16:15:13 <rribeiro> Hello all!
16:15:30 <rribeiro> Someone could explain to me a strange type infered by GHC?
16:15:39 <cool_beans> I'm checking out "Learn You a Haskell for Great Good!", and I'm wondering - how does he get the coloured interactive terminal?
16:15:57 <rribeiro> In my opinion it isn't given the most general type for a function
16:16:19 <rribeiro> could someone explain me why this is happening?
16:16:45 <rribeiro> I've put the code on hpaste: http://hpaste.org/64420
16:19:11 <cool_beans> hello?
16:19:13 <cool_beans> anybody home?
16:19:17 <Sgeo> Hi
16:19:25 <cool_beans> I'm checking out "Learn You a Haskell for Great Good!", and I'm wondering - how does he get the coloured interactive terminal?
16:19:37 <cool_beans> shameless copy-paste
16:19:41 <cool_beans> no shame here
16:19:42 <mux> rribeiro: http://hackage.haskell.org/trac/ghc/blog/LetGeneralisationInGhc7
16:19:48 <Sgeo> Where do you see a colored terminal?
16:19:58 <cool_beans> http://learnyouahaskell.com/starting-out#ready-set-go
16:20:19 <parcs`> that's just syntax highlighting
16:20:19 <mauke> cool_beans: that's not a terminal, that's a web page
16:20:26 <Sgeo> That's not a real coloring
16:20:31 <cool_beans> oh god
16:20:32 <cool_beans> I hate him
16:20:40 <Shamanoid> its's a cool idea though
16:21:00 <shachaf> There exist REPLs that are syntax-highlighted.
16:21:05 <shachaf> But I don't know of any for Haskell.
16:21:21 <mauke> emacs?
16:21:32 <shachaf> Does emacs syntax-highlight ghci?
16:21:56 <mauke> I don't know
16:22:13 <cool_beans> notepad++ has it
16:22:21 <cool_beans> oh wait
16:22:23 <cool_beans> ghci
16:22:25 <cool_beans> never mind
16:22:28 <cool_beans> ignore my statement
16:22:58 <shachaf> bpython syntax-highlights Python.
16:24:18 <rribeiro> mux: So, local bindings aren't generalized anymore in ghc ?
16:25:12 <mapreduce> I'm sure emacs could be set to haskell-mode in your ghci buffer.
16:25:22 <shachaf> WinHugs does a little bit of it, it seems.
16:25:37 <shachaf> Maybe only for output, not for input, though.
16:29:22 <Shamanoid> guys i want to create a type that only allows three possible strings
16:29:56 <monochrom> @quote string
16:29:56 <mauke> then you don't want strings
16:29:56 <lambdabot> JaffaCake says: not all IOError -> String functions are created equal :)
16:30:11 <monochrom> @quote hiding.information
16:30:11 <lambdabot> AlanPerlis says: The string is a stark data structure and everywhere it is passed there is much duplication of process. It is a perfect vehicle for hiding information.
16:30:16 <monochrom> there
16:30:53 <Shamanoid> i want to say something like  "type new = a list of 3 possible strings"
16:31:08 <mauke> no
16:31:39 <ski>   data NonString = NotAString | AlsoNotAString | YetAnotherNonString
16:32:25 <mauke> Maybe (Maybe ())
16:32:42 <Shamanoid> hmm, so it isn't possible
16:32:56 <mapreduce> @google haskell enum
16:32:58 <lambdabot> http://zvon.org/other/haskell/Outputprelude/Enum_c.html
16:32:58 <lambdabot> Title: Haskell : Enum
16:33:01 <ski> it's not possible. and i don't think it would be desirable in this case
16:33:24 <Jafet> I want my variable transmission to have three speeds
16:33:43 <mauke> data Boolean = True | False | FileNotFound
16:34:10 <Shamanoid> i think that is what i want
16:34:31 <ski> @djinn Maybe (Maybe ()) -> Maybe (Maybe (Maybe Void))
16:34:31 <lambdabot> f a =
16:34:31 <lambdabot>     case a of
16:34:31 <lambdabot>     Nothing -> Nothing
16:34:31 <lambdabot>     Just b -> case b of
16:34:32 <lambdabot>               Nothing -> Nothing
16:34:34 <lambdabot>               Just _ -> Just Nothing
16:34:43 <Shamanoid> data Order = GreaterThan | Equal | LessThan
16:34:43 <ski> .. bah
16:34:47 <Shamanoid> makes sense right?
16:34:52 <magicman> @src Ordering
16:34:52 <lambdabot> data Ordering = LT | EQ | GT
16:34:53 <mauke> Shamanoid: already exists
16:34:59 <Jafet> @djinn Maybe (Maybe ()) -> Maybe (Maybe Void)
16:34:59 <lambdabot> f a =
16:34:59 <lambdabot>     case a of
16:34:59 <lambdabot>     Nothing -> Nothing
16:34:59 <lambdabot>     Just b -> case b of
16:34:59 <lambdabot>               Nothing -> Nothing
16:35:01 <lambdabot>               Just _ -> Just Nothing
16:35:15 <magicman> :t compare
16:35:16 <lambdabot> forall a. (Ord a) => a -> a -> Ordering
16:35:32 <Shamanoid> but i think i have to create it, not allowed to import anything
16:35:39 <ski> @index Ordering
16:35:39 <lambdabot> Prelude
16:35:44 <magicman> Fair enough.
16:35:44 <Shamanoid> hmmm
16:35:50 <ski> Shamanoid : it's already imported automatially
16:35:52 <Shamanoid> if thats the case, then i think i can use it
16:36:05 <mauke> .oO( and you wanted to use strings for that?! )
16:36:06 <ski> @index compare
16:36:07 <lambdabot> Prelude
16:36:25 <Shamanoid> the question is very misleading, it says the function will return "GT"
16:38:58 <ski> > (sortBy (comparing length `mappend` compare) . words) "The quick brown fox jumps over the lazy dog"  -- example use of `compare'
16:39:00 <lambdabot>   ["The","dog","fox","the","lazy","over","brown","jumps","quick"]
16:41:30 <monochrom> you had always used coins to fasten and loosen screws. clumsy but worked. one day, someone introduced screwdrivers to you. screwdrivers would be the perfect fit if you used the correct end, but no, you preferred the round end. to fit the round end to screws, you go to a home-renovation channel and ask, "how do I carve hard plastic into small shapes I want?"
16:42:44 * hackagebot BiobaseFasta 0.0.0.4 - Iteratee-based FASTA parser  http://hackage.haskell.org/package/BiobaseFasta-0.0.0.4 (ChristianHoener)
16:43:59 <monochrom> that is how and why some people have fights with haskell's type system
16:47:04 <mauke> there's a lwall quote that applies here
16:47:22 <mauke> "Q. Why is this so clumsy?  A. The trick is to use Perl's strengths rather than its weaknesses."
16:47:39 <monochrom> you had always used strings (perl) or subclasses (java) to encode trees. clumsy but worked. one day, someone introduced haskell's algebraic data types to you. algebraic data types are already trees, exact equivalence, but no, you preferred to ask #haskell, "how do I carve out strings and subclasses in haskell's type system?"
16:48:12 <mauke> why would you use strings to encode trees in perl? and how?
16:48:29 <MostAwesomeDude> Shamanoid: Why can't you import things?
16:48:41 <monochrom> I don't know. the same reason I used coins to fasten and loosen screws
16:48:42 <Sgeo> UPDATE
16:48:44 <Sgeo> oops
16:49:07 <Shamanoid> assignment instructions
16:49:12 <monochrom> there was a time I owned coins but no screwdrivers. like I said, clumsy but worked
16:49:22 <dibblego> dmwit: are you about?
16:49:35 <dibblego> is it partial lenses that are suited to union types?
16:49:39 <monochrom> however, I did not carve the round end of the screwdriver when I finally got one!
16:49:50 <mauke> monochrom: that doesn't answer the "how?" part!
16:50:25 <monochrom> that one I don't know either. I haven't tried. but pretty sure some perler did it
16:50:54 <MostAwesomeDude> Shamanoid: Oh, this is homework? :c
16:50:59 <mauke> well, I know one incident where a coder reinvented arrays
16:51:06 <mauke> as pairs of strings
16:51:11 <monochrom> you know how "if all you have is perl or turing machine, all data look like strings"? :)
16:51:29 <mauke> no, I don't
16:51:41 <mauke> why do you think perl is strings only?
16:51:55 <mauke> tcl I could understand ...
16:51:58 <monochrom> well, you probably heard the hammer-nail thing. now just combine with the turing tarpit
16:52:11 <monochrom> oh, ok, I'll say tcl next time :)
16:52:21 <mauke> "if all you have is haskell or lambda calculus, all data looks like functions"
16:52:29 <hpc> mauke: if all i had was perl, everything would look like hash tables
16:52:36 <Shamanoid> MostAwesomeDude: in university, we call it assignment. As it isn't known wether or not the place you live at is classified as "home"
16:52:44 <hpc> because associative data structures are better than nothing
16:52:45 <mauke> hpc: yeah, that's probably closer to the truth
16:52:49 <Shamanoid> whether*
16:52:56 <monochrom> perl isn't string only, but its regex convenient biases people towards strings
16:53:14 <mauke> monochrom: [citation needed]
16:53:16 <hpc> mauke: well, hashes and function pointers
16:53:29 <hpc> functional perl is waaaay fun to write
16:53:40 <MostAwesomeDude> Shamanoid: Actually, I usually call it "bullshit gruntwork," but I'm cynical.
16:53:41 <mauke> monochrom: "haskell isn't string only, but its parsec convenient biases people towards strings"
16:53:44 <hpc> and not remotely as ugly as it sounds
16:54:28 <hpc> "its monad convenience biases people towards IO"
16:54:29 <mauke> hpc: yeah, the fact alone that there's a simple and direct translation from lambda calculus to perl is a major plus in my book :-)
16:54:55 <hpc> you would like my IRC bot's source code
16:55:04 <monochrom> that is actually true. several times people have already asked "I'm trying to write foo :: Parser String" or "foo :: Parser [String]"
16:55:08 <mauke> not if it uses church encoding for everything
16:55:23 <hpc> it's some simple init stuff, followed by a massive eval that loads the actual bot
16:55:31 <hpc> all the functionality is in a hash of function pointers
16:55:35 <hpc> and i can reload it whenever
16:55:41 <hpc> for bugfixes and stuff
16:55:47 <mauke> hmm. that's basically what perl does anyway
16:55:52 <mauke> the symbol table is a hash
16:55:59 <mauke> 'require' evals code
16:56:03 <hpc> heh
16:56:05 <mauke> or 'do' in this case
16:56:11 <hpc> the irony was not lost on me
16:56:16 <Shamanoid> MostAwesomeDude: when doing this work decides whether i will live beside garbage cans or live in an apartment, i am forced to call it life-changing work
16:56:29 <MostAwesomeDude> Shamanoid: 'k.
16:56:52 <hpc> it even does mueval in a less insane way than lambdabot
16:56:59 <Shamanoid> MostAwesomeDude: life is a b*tch :D
16:57:35 <Shamanoid> MostAwesomeDude: and society is much more worse than lets say "religion"
16:58:28 <Shamanoid> MostAwesomeDude: if you don't go to school, get a uni degree and find a decent job, then you aren't "normal"
16:58:29 <mauke> "This made me wonder, suddenly: can telnet be written in perl?"  "Of course it can be written in Perl. Now if you'd said nroff, that would be more challenging..."
16:59:33 <mike-burns> Oh you still need a CS degree to get a software job?
16:59:36 <mike-burns> I thought they fixed that.
17:00:02 <monochrom> shapr is not "normal". he got a decent job, then went to school.
17:00:07 <Shamanoid> mike-burns: how else will you prove you know what you claim you know
17:00:30 <mike-burns> Your GitHub account, usually.
17:01:22 <Shamanoid> mike-burns: makes sense....
17:01:37 <johnsingleton> I don't understand Resource Transformers!
17:01:47 <Shamanoid> mike-burns: and doesn't require to pay money for education you can otherwise get for free.
17:01:51 <mike-burns> I got a stack of 119 resumes the other day. A quick  grep -vi github   got it down to a manageable 15.
17:02:16 <johnsingleton> or rather, how at all to make use of them '
17:02:33 <Shamanoid> mike-burns: i will take that as a career advice, create a github account
17:02:44 <Pseudonym> mike-burns: Is github one of the job requirements or desirable skills?
17:02:46 <johnsingleton> I am trying to use the authenticate-oauth package, and it makes use of them, but I have no idea how to use it in something like, say, snap
17:03:01 <Pseudonym> Or can you only afford people under the age of 30?
17:03:06 <mike-burns> Hah.
17:03:23 <johnsingleton> Pseudonym: ouch
17:03:36 <Shamanoid> does that mean that only people younger than 30 use github?
17:03:51 <mike-burns> You want us to explain a joke?
17:03:58 <majuscule> mike-burns: i host my own git repositories! don't do that to me :-(
17:04:08 <mike-burns> I host mine own, too.
17:04:18 <majuscule> so you'd throw out your own resume?
17:04:19 <majuscule> :-/
17:04:24 <mike-burns> I also have a GitHub account.
17:04:43 <Shamanoid> sounds like a good idea for a facebook competitor, teenbook - no parents = more fun
17:04:45 <majuscule> so i need to use a proprietary service to be considered for hire? :-(
17:05:01 <Pseudonym> Why would someone need a github account if they've never hosted a project there or contributed to a project there?
17:05:13 <mike-burns> They wouldn't.
17:05:28 <johnsingleton> What about bitbucket or google code? ;)
17:05:36 <monochrom> that is like HR saying "I find out whether the applicants have FB accounts"
17:05:36 <Pseudonym> Or hell, sourcefourge.
17:05:42 <mike-burns> Hah, sourceforge.
17:05:42 <MostAwesomeDude> He's talking about an all-things-considered approach, I think.
17:05:43 <Pseudonym> sourceforge
17:05:47 <johnsingleton> I feel like Google code is the older, wiser brother of GH
17:06:19 <Pseudonym> mike-burns: Unless you start the project yourself, you can't dictate where the project is hosted.
17:06:45 <mike-burns> I'm very sure people hiring for other positions use different metrics for whittling down a stack of resumes.
17:07:03 <mike-burns> i bet some even use uni degrees.
17:07:06 <Pseudonym> I'm just curious how this is relevant to the particular position.
17:07:10 <Pseudonym> It may well be.
17:07:21 <mike-burns> This position was for a Ruby dev.
17:07:36 <hash`> In my last job we just called the candidate, asked if he knew what a hash table was, and if we heard typing in the background said, "Thanks, but the job's been filled."
17:07:38 <drdo> So i guess the idea is to include every possible public repository hosting site name in your resume
17:08:00 <Pseudonym> drdo, you could be selective.
17:08:20 <johnsingleton> one of the questions we ask people is "have you ever created and released a public project yourself?"
17:08:27 <Pseudonym> If there's GNU Savannah and nothing else...
17:08:52 <johnsingleton> a library, program, website, etc
17:09:05 <BMeph> What if there's CPAN, and nothing else?
17:09:08 <johnsingleton> it shows "initiave" I guess.
17:09:20 <Pseudonym> BMeph: Then you wouldn't hire them as a Ruby dev.
17:09:24 <johnsingleton> CPAN counts
17:09:34 <Shamanoid> i knew creating a website is necessary to get a good job in the computer industry!
17:09:42 <drdo> I think "java" is a good keyword to filter out resumes
17:09:48 <mike-burns> Hah yes.
17:09:59 <Pseudonym> Actually, I applied for a job once where I gave by email address as firstname@lastname.org.
17:10:02 <mike-burns> I wasn't the only person going through resumes, don't worry.
17:10:03 <johnsingleton> Shamanoid: by "website" I obviously mean "website that does stuff" ;)
17:10:09 <hpc> drdo: if "java" was the deciding factor for working somewhere, i wouldn't want to take the job anyway
17:10:10 <Pseudonym> They said, and I quote, "how did you do that?"
17:10:12 <hpc> :P
17:10:19 <Pseudonym> My response: Sorry, what are you hiring me for again?
17:10:21 <mike-burns> hpc: I assume drdo meant the opposite.
17:10:27 <drdo> hpc: I meant if you include "java" your resume doesn't even get looked at
17:10:28 <hpc> oh
17:10:30 <hpc> OH
17:10:34 <hpc> yes, do that instead
17:10:48 <BMeph> Pseudonym: What THAT that Ruby dev company? ;)
17:11:01 <majuscule> johnsingleton: do you weigh big names over lots of small projects at all? I've got about 10 public projects, average lines ~100, max 800. is it worth it to spend a lot of time finding something to contribute to a big name, even if it might be marginal?
17:11:01 <Pseudonym> Actually, it was a WAN engineer position.
17:11:19 <Pseudonym> I had to sit an exam. Apparently I got the highest mark of anyone not already working for the telco in question.
17:11:31 <BMeph> Pseudonym: Get. OUT! =8*O
17:11:37 <hpc> Pseudonym: clearly you cheated
17:11:50 <dmwit> dibblego: Hm, partial lenses?
17:11:53 <Pseudonym> Clearly everyone working for the telco cheated.
17:12:07 <Pseudonym> FWIW, I have Java on my resume, but I have 60+ languages on my resume.
17:12:32 <Pseudonym> That could be a red flag to some, I suppose.
17:12:34 <Axman6> Pseudonym: what're the more interesting ones?
17:13:03 <Pseudonym> Axman6: You mean like sendmail?
17:13:17 <BMeph> sendmail is a language?
17:13:19 <MostAwesomeDude> I get my work by reference; the resume is a formality.
17:13:21 <Pseudonym> It's Turing-complete.
17:13:33 <Pseudonym> I don't include it as a language, but I mentally include it.
17:13:37 <hpc> heh
17:13:59 * BMeph restrains himself from saying something about his mom being Turing-complete...
17:14:04 <johnsingleton> majuscule: well, it obviously depends on what they are. I think there is a certain X factor to it all. And by X factor I guess I mean something that might solve a problem for a lot of people. Example of one such project someone actually did: a graphical SQL client that works natively on the mac for analytics databases.
17:14:26 <johnsingleton> majuscule: the project itself was smallish, but had a very high cool factor.
17:14:46 <Pseudonym> I include Goedel, Oberon, RenderMan SL and Erlang.
17:14:51 <johnsingleton> one other such project: one of our people wrote a DSL for implementing map reduce.
17:14:58 <hpc> BMeph: your mom's effective topos has a well-defined bottom!
17:15:06 <tazjin> Has anyone used the relatively new couchdb-conduit package yet?
17:15:16 <Pseudonym> Oh, and Ada.
17:15:33 <hash`> FYI - When I get a resume I pick the things that seem least likely and and interview them based on that. I.E. the guy who once said he wrote a video driver but had never heard of NVidia or ATI, back when ATI was a company
17:15:38 <Jafet> (Are you Turing-hard?)
17:15:39 <Axman6> Ada is lovely
17:15:49 <Pseudonym> Back to the topic, if the Ruby community tends to use github, I get that filtering mechanism.
17:15:54 <Axman6> well, ugly, but amazingly powerful and well thought out
17:16:14 <Pseudonym> It's no uglier than any other Wirth language.
17:16:28 * BMeph points and agrees
17:16:28 <johnsingleton> I'm probably in the minority but I kinda hate Ruby and rate against RoR developers
17:16:44 <mike-burns> Eh, it's just a programming language.
17:16:54 <johnsingleton> mike-burns: you know what I mean
17:17:05 <johnsingleton> I mean the OMFGROR crowd
17:17:20 <Pseudonym> No programming language is just a programming language.
17:17:21 <mike-burns> RoR devs used to be super obnoxious but in the past ... I dunno, six months, they've become slightly smarter.
17:17:32 <mike-burns> I think a lot of them learned something besides Ruby, finally.
17:17:41 <Pseudonym> It's a platform, and a community, and a suite of libraries, and a suite of tools.
17:17:53 <hash`> Hmmm, first time I've gotten this: Irrefutable pattern failed for pattern
17:17:55 <mike-burns> OK, yes, I completely agree.
17:18:12 * BMeph looks to see if he has his FALSE interpreter on his résumé...
17:18:28 <johnsingleton> mike-burns: did you see this: https://www.destroyallsoftware.com/talks/wat
17:18:38 <johnsingleton> the one for Ruby is hilarious
17:18:39 <mike-burns> johnsingleton: yeah! It's super well delivered.
17:18:43 <Pseudonym> So what's your language to learn this year?
17:18:45 <johnsingleton> haha
17:18:48 <johnsingleton> WATMAN!
17:19:57 <johnsingleton> also David Heinemeier is a toolbag
17:20:07 <johnsingleton> again, just my opinion ;)
17:21:22 <mike-burns> He has nice sneakers.
17:21:27 <mike-burns> And he's a total prick.
17:21:41 <mike-burns> (But also a nice guy IRL, one-on-one.)
17:21:54 <johnsingleton> probably true
17:22:21 <johnsingleton> I hear George Bush is really nice, one-on-one ;) *ducks*
17:23:13 <hash`> *looks around* I thought this was the #haskell channel.
17:23:28 <hpc> hash`: you're looking for #haskell-blah
17:23:35 <dibblego> yeah #haskell-blah please guys
17:23:43 <hpc> hash`: the topic there is everything but haskell, so that's where all the on-topic talk happens
17:23:46 <hpc> :P
17:23:50 <hash`> :)
17:23:58 <luite> he can't count comma's
17:24:00 <hpc> here's where we talk about random stuff and alienate newbies
17:24:13 <hash`> hpc : Got it.
17:24:14 <albel727> it works.
17:24:43 <BMeph> hash` is fine; johnsingleton needs to /join there.
17:25:09 <scooty-puff> is there anything along the lines of tuple sections, but for records?
17:25:19 <johnsingleton> hehe ok ok
17:25:20 <BMeph> ...never mind.
17:25:23 <dibblego> scooty-puff: data-lens perhaps
17:25:32 * BMeph "Pshaw"s at hpc.
17:25:35 <scooty-puff> dibblego, k, i'll check that out
17:25:53 <johnsingleton> so I'd like to talk about my total lack of ability to understand how to use a resource transformer ;)
17:26:20 <johnsingleton> I'm using this library here: http://hackage.haskell.org/package/authenticate-oauth-1.0.0.1
17:26:53 <johnsingleton> and I've got a function like: getToken' = withManager $ \manager -> getTemporaryCredential authConfig manager
17:27:31 <johnsingleton> returning: ResourceIO m => m Credential
17:28:16 <johnsingleton> and what I'd LIKE to do is use Credential elsewhere (inside of a Snap splice), but I just can't seem to get it right
17:29:50 <Axman6> byorgey: /22
17:29:54 <Axman6> whoops
17:30:03 <Axman6> sorry byorgey
17:31:25 <johnsingleton> actually, you know what, I may have just solved my problem.
17:32:17 <byorgey> Axman6: no worries =)
17:32:27 <shachaf> byorgey: /24
17:32:37 * shachaf will not apologize for that.
17:32:46 <byorgey> thanks for the numbers guys
17:33:08 <Shamanoid> @index SortBy
17:33:08 <lambdabot> bzzt
17:33:37 <shachaf> Numbers? I gave you a subnet mask.
17:33:55 <shachaf> Oh, that waasn't a mask, was it.
17:35:57 <mbetter> is there a utility for transforming the imports of a haskell source file to explicitly list the names imported?
17:36:17 <ivanm> I believe not
17:36:26 <bgamari> Who's responsible for http://hpaste.org/64384 ?
17:36:29 <ivanm> comment it out, and see what ghci bitches about? :p
17:36:36 <bgamari> It was pasted 4 hours ago
17:36:44 <mbetter> ivanm: hah, that's my current method
17:36:51 <bgamari> I'm seeing the exact same issue
17:37:02 <mbetter> it seems like it would be pretty straightforward to do, i think i'll make one
17:38:20 <bgamari> Namely a bad interface file in template-haskell
17:38:31 <ivanm> that's a weird error
17:39:29 <bgamari> Ahh, I see
17:39:30 <bgamari> http://hackage.haskell.org/trac/ghc/ticket/5704
17:40:24 <bgamari> damn, I can't believe 7.4.1 was released with that
17:41:24 <drdo> tazjin: I started using it, didn't like it
17:42:22 <tazjin> drdo: Any reason? I want to look into it mainly because it uses Aeson instead of Text.JSON
17:43:39 <drdo> tazjin: I don't see why we need that runCouch function, it just got awkward to use
17:44:11 <drdo> I just wrote my own library and moved on
17:44:21 <adasfdasf> Can haskell be used to do visual computing software? Is it performatic?
17:44:38 <ivanm> depends on what you mean by "visual computing software"
17:45:44 <dibblego> !seen roconnor
17:46:19 <hpaste> johnsingleton pasted “How can I use this?” at http://hpaste.org/64422
17:46:41 <adasfdasf> ivanm: opencv
17:46:46 <johnsingleton> I'm stuck totally stuck. any help would be greatly appreciated.
17:46:54 <ivanm> there's been some work on it IIRC
17:47:00 <ivanm> @google opencv haskell
17:47:03 <lambdabot> http://hackage.haskell.org/package/HOpenCV
17:47:03 <lambdabot> Title: HackageDB: HOpenCV-0.1.2.2
17:47:23 <ivanm> johnsingleton: is that snap?
17:47:35 <johnsingleton> ivanm: yes
17:47:47 <johnsingleton> where I am consuming it is, yes
17:47:56 * ivanm makes a wild guess that it needs a liftIO
17:47:57 <johnsingleton> the other thing is authenticate-oauth
17:48:16 <ivanm> snap has it's own IRC channel; maybe ask there?
17:48:33 <johnsingleton> ivanm -- I don't think it really has anything to do with snap?
17:48:39 <johnsingleton> I just don't understand resource transformers
17:48:53 <tazjin> Uhh, so I just tried to run ./configure for ghc 7.2 on an OSX 10.6 machine and got: utils/ghc-pwd/dist-install/build/tmp/ghc-pwd: Bad CPU type in executable
17:48:58 <ivanm> well, the people there might have a better idea of all that stuff and how it works together :p
17:49:13 <johnsingleton> ivanm: true -- I'll give that a shot
17:52:02 <geekosaur> tazjin, I think that's a known problem with the 7.2 release, someone did a build on 10.6 but I would have to dig to see what availability it has
17:54:06 <johnsingleton> ivanm: it *was* a liftIO that was needed btw ;)
17:54:14 <ivanm> heh
17:54:51 <johnsingleton> ivanm: I don't quite understand *why* however
17:55:10 <ivanm> just to get the class right? *shrug*
17:56:07 <johnsingleton> what exactly is happening with liftIO? it lifts a computation from the IO monad… But I was in the ResourceIO monad
17:56:15 <Axman6> @hoogle FileExists
17:56:16 <lambdabot> No results found
17:56:21 <Axman6> hmm
17:56:55 <adasfdasf> is haskell simpler than FORTH?
17:57:02 <Axman6> maybe
17:57:18 <Axman6> they're completely different, so it's extremely hard to say
17:57:51 <ivanm> but we don't have as many cool-looking books as FORTH does :(
17:57:59 <byorgey> johnsingleton: what is the type of getToken?
17:58:13 <ivanm> http://schmitz.blogdns.net/bernard/wp-content/uploads/2007/10/atari-forth-1.jpg
17:58:42 <albel727> someone still uses forth?
17:58:43 <johnsingleton> byorgey: ResourceIO m => m Credential
17:59:29 <byorgey> johnsingleton: OK, well you were using it in a context where it needed to have type  Handler App App Credential
17:59:36 <tomodo> hello byorgey
17:59:40 <Axman6> albel727: it's quite popular for systems programming, since it doesn't use a heap and can run extremely efficiently on constrained devices
17:59:55 <adasfdasf> I dont know, but I'm reading the book Thinking Forth
17:59:59 <byorgey> johnsingleton: and the error message says there is no ResourceIO instance for Handler App App.
18:00:09 <byorgey> johnsingleton: using liftIO would force getToken to have type  IO Credential
18:00:12 <johnsingleton> byorgey: right…..
18:00:15 <byorgey> hi tomodo
18:00:23 <albel727> Axman6: wow. that's interesting to know. thanks. =)
18:00:35 <johnsingleton> boyrgey: ok, so why does that work then?
18:00:51 <Axman6> albel727: there was a somewhat interesting set of articles recently that showed how to basically implement forth in haskell (well, something that works like most stack languages anyway)
18:00:57 <byorgey> johnsingleton: Handler App App  must have a  MonadIO instance.
18:01:02 <tomodo> did you hear about the latest news byorgey
18:01:04 <johnsingleton> byorgey: Ah.
18:01:07 <byorgey> @type liftIO
18:01:07 <lambdabot> forall a (m :: * -> *). (MonadIO m) => IO a -> m a
18:01:12 <Axman6> also @adasfdasf
18:01:26 <byorgey> liftIO takes an IO computation into a computation of some other monad, as long as it has a MonadIO instance
18:01:28 <albel727> heh. is there any practical merit to such implementation though?
18:01:48 <Axman6> probably not. but it was type safe, and almost trivial to implement in haskell
18:01:49 <johnsingleton> byorgey: I see. So stupid question time: can I have done that *without* the liftIO method?
18:02:01 <byorgey> johnsingleton: I haven't the foggiest idea.
18:02:07 <johnsingleton> like, what if I had a monad to move into that *didn't* have a liftIO method.
18:02:11 <albel727> oh. so it was to demonstrate the power of haskell. I see.
18:02:19 <byorgey> johnsingleton: to answer that question you would have to know something about snap, which I don't
18:02:26 <adasfdasf> forth can be booted without OS
18:02:33 <byorgey> tomodo: what news?
18:02:39 <tomodo> http://blog.printf.net/articles/2012/02/23/computers-are-very-good-at-the-game-of-go
18:03:03 <Axman6> johnsingleton: you can't execute IO without having access to the stream of IO the program is executing (ie, what's executed from main, and forkIO/OS)
18:03:16 <johnsingleton> boyrgey: I mean in general. Given some monad that doesn't have a lift method. How does the lifting work?
18:03:19 <tomodo> http://gogameguru.com/man-machine-match-final-results-game-commentary/
18:03:24 <johnsingleton> sorry, it's a little abstract at this point
18:03:51 <johnsingleton> like, I get that if I need to get it in that type I can use that method, but what is it doing in the background?
18:04:13 <byorgey> tomodo: ah, interesting
18:04:18 <johnsingleton> I guess I could just read the source.
18:04:52 <byorgey> johnsingleton: you want to read about monad transformers
18:05:11 <johnsingleton> boyrgey: you would be right. I will. Thank you.
18:05:45 <johnsingleton> bourgey: but just as a FYI to me, on a scale of 1 to 10, how far along are monad transformers on the way to having a mastery of Haskell?
18:05:58 <johnsingleton> like, is that considered advanced knowledge or introductory?
18:06:09 <tomodo> I think this is just incredible
18:06:19 <tomodo> in so many ways
18:06:36 <byorgey> johnsingleton: I'd say intermediate.  But also, it is not really linear =)
18:07:01 <tazjin> can cabal reinstall _all_ currently installed packages?
18:07:02 <johnsingleton> heh
18:07:19 <Shamanoid> guys what do you advice someone who is trying to implement a difficult algorithm but is finding it difficult putting things together?
18:07:24 <byorgey> the path to mastery of Haskell is more like a random walk through a fifteen-dimensional space.
18:07:39 <byorgey> Shamanoid: simplify.
18:07:46 <tomodo> byorgey: you can become a 6-dan at haskell
18:07:50 <johnsingleton> byorgey: that is the best explanation I have ever heard.
18:07:57 <johnsingleton> hah
18:08:04 <byorgey> =)
18:08:13 <Shamanoid> does't help
18:08:18 <ivanm> byorgey: eh, I find it easier to visualise it as an n-dimensional space
18:08:19 <johnsingleton> Shamanoid: by putting it together, what do you mean?
18:08:28 <ivanm> bringing actual values into it just cheapens it somehow :p
18:08:29 <Axman6> Shamanoid: break it into smaller parts
18:08:59 <Shamanoid> but the problem is when i break it into smaller parts i struggle putting the parts together
18:09:03 <johnsingleton> Shamanoid: also, is it a well-documented algorithm or something that is novel?
18:09:27 <Shamanoid> constraint satisfaction problem algorithm
18:09:49 <johnsingleton> Shamanoid: do you just mean "thinking functionally" about the problem?
18:09:55 <tomodo> I'm amazed at Tromps accurate bet and being willing to put that much money on it, played at 2-dan level
18:10:22 <tomodo> and we were all expecting AI not to progress until there was a breakthrough in algorithms, but it did without that
18:10:42 <Shamanoid> i'm studying AI
18:10:46 <tomodo> me too
18:10:49 <johnsingleton> e.g., you know how you'd attack it in an imperative language?
18:11:00 <tomodo> did you use haskell for any AI?
18:11:05 <Shamanoid> should i throw the AI algorithm assignment and go have some sleep
18:11:12 <fryguybob> byorgey: can you speed up your walk with Metropolis–Hastings?
18:11:15 <tomodo> what algorithm is it
18:11:21 <Shamanoid> AC-3
18:11:41 <Shamanoid> tomod what university?
18:11:53 <tomodo> I am study by myself
18:12:28 <Shamanoid> using my super powers, i concluded you are somewhere in europe
18:12:29 <byorgey> fryguybob: *I* sure can't, because I don't know what that is.  But maybe you can =)
18:13:14 * fryguybob does not know what it is either, but it was part of his reading last week.
18:13:15 <Shamanoid> tomodo: it is good to study by yourself.
18:13:22 <tomodo> yes
18:13:52 <Shamanoid> so do you know anything helpful about the AC-3 algorithm?
18:14:41 <tomodo> no
18:15:00 <Shamanoid> i like your short answers, straight to the point
18:16:03 <shapr> @remember monochrom shapr is not "normal". he got a decent job, then went to school.
18:16:03 <lambdabot> Good to know.
18:16:06 * shapr cackles
18:16:25 <majuscule> I've got a data structure called State containing an int, and I am trying to compare it to an int. I am getting the error: `Couldn't match expected type `Int' with actual type `State -> Int'`
18:16:26 <shapr> mike-burns: I think you can do anything you want, but going off the beaten path is more expensive in terms of time and money.
18:16:45 <majuscule> I feel like I must be missing something basic
18:17:14 <Shamanoid> i always used to believe that everyone is of equal intellect, all that matters is who works hard. Seeing all those smart students finish such a difficult assignment in 2--3 days but taking me a whole week is very discouraging
18:17:47 <shapr> But hard work always beats raw intellect.
18:17:50 <Shamanoid> i think i will change careers and become a drug cartel leader in north africa
18:18:05 <Shamanoid> it has always been my "badass" dream
18:18:06 <shapr> hm, the price of failure is different
18:18:10 <shapr> you don't get fired, you get dead
18:18:18 <shapr> ouch
18:18:44 <shapr> Shamanoid: Also, working at something earlier is another way to work smarter instead of harder.
18:18:58 <shapr> Shamanoid: Try to do all your homework six weeks early, and you'll suddenly seem like the smartest guy in the class.
18:19:04 <Shamanoid> dead is good, because you won't have time to feel sad for the lodd, you will be dead
18:19:10 <Shamanoid> for the loss*
18:19:21 <shapr> I'd rather learn from my mistakes and do more awesome stuff.
18:19:46 <Shamanoid> shapr are you an atheist?
18:19:49 <shapr> nope
18:19:51 <roconnor> dibblego: here
18:19:55 <shapr> I am a Christian.
18:20:03 <Shamanoid> i see....
18:20:19 <Shamanoid> well i'm a between Islam and Atheism
18:20:25 <dibblego> roconnor: cool mate, was just sending you emails :)
18:20:27 <Shamanoid> leaning more towards Islam...
18:20:40 * shachaf sighs.
18:20:40 <roconnor> dibblego: ah; I didn't know you were tony
18:20:40 <shapr> Religious conversations belong on #haskell-blah, not #haskell
18:20:59 <Shamanoid> but i dont knnow, i always think about whether or not there is a reason to work hard in life
18:21:01 <shapr> I wish I were already done with my homework, so I could write more Haskell!
18:21:08 <tomodo> is god real?
18:21:11 <shapr> Shamanoid: Yes, you get more toys.
18:21:17 <shachaf> There is no way this discussion can lead anywhere productive in this channel.
18:21:23 <roconnor> @instances Real
18:21:23 <shapr> tomodo: Once again, that conversation belongs on #haskell-blah
18:21:23 <lambdabot> Double, Float, Int, Integer
18:21:26 <otters> God was written in Haskell
18:21:28 <roconnor> tomodo: nope
18:21:37 <Shamanoid> alright, i will stop
18:21:38 <Axman6> shapr: life without working hard is fucking boring imo
18:21:52 <Axman6> not that i work particularly hard, but i'm also pretty bored most of the time
18:21:56 <shapr> ha
18:21:57 <shachaf> Shamanoid: Now look what you've started.
18:22:03 <shapr> Axman6: that's totally quotable :-)
18:22:49 * shapr tweets
18:22:53 <Axman6> go for it
18:22:56 <tomodo> sharp Shamanoid
18:23:03 <tomodo> want to asnwer my questions??
18:23:07 <tomodo> in #haskell-blah
18:23:13 <Shamanoid> tomodo: ?
18:23:55 <majuscule> Why can't I compare State -> Int with Int?
18:24:11 <mauke> compare how?
18:24:16 <Axman6> majuscule: how do you expect to compare an Int with a fiunction?
18:24:19 <roconnor> majuscule: you can only compare values of the same type
18:24:28 <roconnor> mauke: and that type has to be an instance of Ord
18:24:46 <Shamanoid> tomodo: it's just that as an egyptian who used to live in abu dhabi, i see all those "locals" growing up t become chairmen of rich companies without breaking a sweat
18:25:09 <Shamanoid> tomodo: not even a highschool certificate
18:25:11 <shapr> Shamanoid: also likely belongs on #haskell-blah
18:25:23 <Shamanoid> alright, i will seriously stop this time
18:25:28 <tomodo> I think we need a -blah without shachaf
18:25:31 <shapr> ask Haskell questions!
18:25:33 <shapr> tomodo: Be nice
18:25:40 <tomodo> I am nice
18:25:47 <Shamanoid> back t the haskell assignment
18:25:50 <Shamanoid> to*
18:25:58 <mauke> tomodo: that belongs in #haskell-blah
18:26:28 <majuscule> Axman6: I must be fundementally misunderstanding something, so i really appreciate your help. I defined a structure, like `data myStruct = myStruct { a :: Int, b :: Int }`, and I am trying to compare one of these ints with another int in another function. Sorry if this is really silly :-/
18:26:45 <mauke> majuscule: that's a syntax error
18:27:12 <mauke> and you're not comparing two ints, otherwise you wouldn't have gotten that error
18:28:30 <tomodo> I just wanted to see elsewhere from my own mind
18:28:31 <monochrom> type name has to begin with a capital letter
18:29:57 <monochrom> and you can surely be more specific than "one of these ints". is that "a"? is that "b"?
18:32:10 * ski suspects maybe majuscule is confused about `a :: Int' vs. `a :: State -> Int'
18:33:03 <shergill> i use ghci and hoogle for exploratory messing around with stuff. often i feel the need to inspect the source of some function to get a better understanding of what's happening. is there a way to get linked to either the haddock documentation or the raw source from ghci/emacs?
18:35:11 <Cale> you can use :info to find out what module things are in
18:35:14 <Shamanoid> guys, i have a dataset that is like this "[AV (String, Int)]", i want to sort it such that Int part is in ascending order
18:35:16 <Cale> But no hyperlinks
18:35:31 <Cale> Shamanoid: what's AV?
18:36:01 <shergill> hmm nothing more elegant than having to run a google search manually in firefox?
18:36:06 <Shamanoid> Cale: a type
18:36:14 <ski> Shamanoid : defined how ?
18:36:31 <Shamanoid> Cale: AssignedVariable = AV (String,Int)
18:36:34 <byorgey> /win/win 9
18:36:37 <Axman6> Shamanoid: we can't read minds, we need to know more detail than you're giving us
18:36:41 <tomodo> I feel that
18:36:47 <Shamanoid> there is "newtype" before that
18:36:47 <Cale> Shamanoid: okay, so that's basically just a pair
18:36:52 <tomodo> you create a hostile environment to forbid communication on a certain issue
18:37:07 * Axman6 -> lunch
18:37:20 <Cale> Shamanoid: sortBy (comparing (\(AV (s,n)) -> n))
18:37:24 <Shamanoid> Cale: how do i ask haskell to sort the second part of the tuple
18:37:25 <ski> Shamanoid : something like `sortBy (comparing (snd . unAV))', i think
18:37:50 <ski> (assuming you define `unAV')
18:39:03 <Shamanoid> i see, i will try to implement that
18:39:34 <ski> (Cale's version is basically the same as mine)
18:40:49 <ski> @hoogle comparing
18:40:50 <lambdabot> Data.Ord comparing :: Ord a => (b -> a) -> b -> b -> Ordering
18:41:03 <shergill> i guess querying lambdabot is slightly better
18:41:30 <tomodo> I feel bad about it
18:41:32 <Shamanoid> i already wrote a function like that
18:42:30 <ski> @where hoogle
18:42:30 <lambdabot> http://haskell.org/hoogle
18:42:30 <ski> @where hayoo
18:42:31 <lambdabot> http://holumbus.fh-wedel.de/hayoo/hayoo.html
18:46:45 <tomodo> don knuth
18:51:15 <Shamanoid> can somebody explain to me the sortBy function?
18:51:28 <mauke> what do you not understand?
18:51:31 <Shamanoid> i want to know the way it goes through a list
18:51:38 <fryguybob> @src sortBy
18:51:39 <lambdabot> sortBy cmp = foldr (insertBy cmp) []
18:51:44 <Shamanoid> -G_-
18:51:46 <mauke> huh?
18:51:48 <Jafet> It can go through the list in any way it likes, as long as the result is correct.
18:52:02 <tomodo> I'm pissed off
18:52:24 <Shamanoid> tomodo, i'm sorry was it me you were referring to the whle time?
18:52:30 <tomodo> no
18:52:46 <tomodo> someome is making fun of me in the other channel
18:53:01 <Jafet> tomodo: good, you're pissing us off here.
18:53:01 <Shamanoid> haskell-blah?
18:53:04 <mauke> tomodo: what other channel? and why are you complaining here?
18:53:05 <Jafet> Behave or be behoven.
18:53:20 * Shamanoid googles behoven
18:53:25 <mauke> heh
18:53:38 <Jafet> (It's a Finnish word)
18:53:48 <tomodo> I don't think I get treated fairly
18:54:04 <mauke> tomodo: do you have anything to say about Haskell?
18:54:12 <Shamanoid> i didn't know it was possible to express the word behave that way
18:54:14 <mauke> because I think you're completely off-topic here
18:54:46 <Shamanoid> mauke: that belongs in #haskell-blah
18:54:56 <tomodo> even a good day can turn sick
18:55:11 <mauke> Shamanoid: why?
18:55:35 <adnauseam> because we're only people - and this is retarded
18:55:41 <Shamanoid> mauke: such general questions belong in #haskell-blah
18:55:49 <mauke> Shamanoid: no, they don't
18:56:00 <Shamanoid> mauke: such responses belong in #haskell-blah
18:56:01 <adnauseam> sigh - someone's wrong on the internet
18:56:17 --- mode: ChanServ set +o mauke
18:56:17 --- mode: mauke set +q *!*@cpc10-sgyl30-2-0-cust352.sgyl.cable.virginmedia.com
18:57:30 <adnauseam> yeah that's one way to solve an argument haha
18:57:45 <adnauseam> the channel can go back to being relevant again
18:58:17 --- mode: mauke set -o mauke
19:12:24 <edwardk> trying to figure out a nice representation for (unordered) multivariate distributions that allows for mixed continuous/discrete distributions
19:13:05 <edwardk> fortunately i mostly care about the pdf/pmf and random sampling and not the cdf or quantile functions
19:13:17 <roconnor> edwardk: discrete distributions can be represened by continuous distributions using delta functions, no?
19:14:35 <edwardk> roconnor: well, i'm preferring to instead split them into mass and density. where jumps in the càdlàg cdf are mass and slopes are density, then accounting for the percentage of it overall that is made up of jumps lets you split mixed distributions into their purely continuous and discrete components
19:15:03 <edwardk> you just sample a bernoulli trial with that percentage, and tree off to the continuous or discrete distribution respectively
19:15:14 <roconnor> edwardk: what about a cantor distribution?
19:15:22 <edwardk> not constructive, so irrelevant ;)
19:15:32 <roconnor> edwardk: I would beg to differ :D
19:15:36 <edwardk> fair nuff
19:15:55 <edwardk> i'm largely ignoring devil's staircase-type distributions
19:15:58 <roconnor> why would you say that the cantor distribution isn't constructive?
19:16:02 <edwardk> since i mostly care about this for gibbs sampling
19:16:51 <edwardk> hrmm maybe it is
19:17:04 <roconnor> okay, that is beyond my understanding; but I'm surprised that you can get a reasonable answer by such distributions.
19:17:31 <roconnor> edwardk: what do you mean by undorderd multivariate?
19:17:40 <roconnor> *unordered
19:18:47 <edwardk> roconnor: pick random complex numbers, i dont have an Ord instance on that type. the marginals with respect to the real and imaginary components are ordered, but i can't define a nice joint cdf
19:19:32 <edwardk> but as i only need the pdf/pmf for the bayesian stunts i want to pull thats fine
19:19:37 <roconnor> to pick a random complex number I need something like a measure.
19:21:12 <edwardk> not necessarily. i can give you a discrete distribution saying you have a 1/4 chance of i, and a 3/4 chance of 0.5, which is kinda silly, i can also have nice marginals and a copula or just an expression in terms of another basis
19:21:39 <edwardk> but i'm not talking about theoretically unordered/unmetrizable here
19:21:54 <edwardk> i'm caring about the implementation as a typeclass when i say that
19:22:31 <roconnor> anyhow; I'd be inclined to use generalized functions, but I'm guessing that I know less about the topic than you do.
19:23:17 <edwardk> effectively thats what i'm doing, but for what i want to calculate i don't care about the cdf at all, just its derivative, and the 'deltas' where it jumps
19:24:10 <edwardk> the deltas are mass and the places where the derivative exist are the density, and the split on a bernoulli parameter lets you reason about both independently and sum and otherwise calculate expectations correctly
19:24:43 <roconnor> do you need deriviatives of the delta function?
19:24:51 <edwardk> class Distribution d where density :: d -> Range d -> Double; mass :: d -> Range d -> Double; discretion :: d -> Double -- % of probability supplied by mass
19:25:22 <edwardk> delta is used when describing the cdf, which is the integral of the function i care about, so yes
19:26:00 <edwardk> but by splitting it into density and mass you can deal with each technique in isolation
19:26:01 <alang> the deltas occur in the pdf, causing jumps in the cdf, no?
19:26:07 <roconnor> what alang said
19:26:17 --- mode: ChanServ set +o mauke
19:26:17 --- mode: mauke set -q *!*@cpc10-sgyl30-2-0-cust352.sgyl.cable.virginmedia.com
19:26:32 <roconnor> edwardk: I'm wondering if you need derivatives of your pdfs
19:26:46 <edwardk> alang: yes, sorry
19:26:46 <edwardk> i'm at the point of playing around with representations, because i've done this in particular cases and am not working up a framework
19:27:19 <edwardk> it'd be kinda nice, but i don't need it for gibbs sampling
19:27:52 <roconnor> I should look up what gibbs sampling is
19:28:01 <dolio> roconnor: How do you describe the Cantor distribution constructively?
19:28:17 --- mode: mauke set -o mauke
19:28:26 <edwardk> on an unrelated note, given a bunch of random samples with known derivatives do you know a good way to integrate using the extra slope information?
19:29:07 <roconnor> dolio: you can defined its cdf and integrate it over any interval.
19:29:15 <edwardk> er i guess that is a related note because the pdf would be the integrand in question
19:29:39 <alang> edwardk: known derivatives of the cdf?
19:29:49 <dolio> roconnor: Isn't the cdf discontinuous?
19:29:55 <roconnor> dolio: yep
19:29:58 <roconnor> nice and constructive
19:30:19 <dolio> What?
19:30:34 <edwardk> alang: just in general when doing monte carlo integration, if i can give you the derivative as well as the answer for the sample points, can i derive anything extra from that?
19:30:41 <roconnor> edwardk: BTW, Jaynes spits on randomized algorithms
19:30:53 <edwardk> roconnor: ?
19:31:15 <dolio> roconnor: Did you mean, "no, it is continuous"?
19:31:26 <alang> edwardk: I don't know anything about monte carlo integration, but you can do spline smoothing
19:31:42 <alang> don't know if that helps
19:31:52 <edwardk> http://www.stat.uiowa.edu/~nshyamal/22S175/DI.pdf describes the basic approach to mixed distributions i'm fiddling with
19:32:01 <majuscule> I'm trying to get the output of a command and using `r <- readProcess "amixer get Master" [] []` but I keep getting `readProcess: amixer get Master  (exit 127): failed`, however the command works perfectly in a terminal. what could be going wrong?
19:32:15 <mauke> majuscule: you're using xmonad
19:32:18 <edwardk> alang: the problem is i only have simple sample points in isolation with their slopes, i don't want to sort them
19:32:24 <majuscule> mauke: awesomewm
19:32:32 <mauke> oh? interesting
19:32:43 <dolio> I guess it's continuous but not differentiable at a lot of places?
19:33:13 <mauke> majuscule: then the problem is that you don't have a program called "amixer get Master" in your path
19:33:51 <majuscule> mauke: interestingly, `amixer` alone works. but `amixer get Master` is a correct command
19:33:51 <edwardk> alang: monte carlo integration is just sampling the integral from a to b of f(x) dx randomly between a and b, and taking the average of the answers (or factoring h(x) into the pdf of some distribution p(x) and an f(x) residue and sampling that distribution using the law of the unconscious statistician)
19:34:02 <mauke> majuscule: no, it isn't
19:34:11 <mauke> majuscule: you don't have a program called "amixer get Master"
19:34:16 <majuscule> OH
19:34:17 <majuscule> duh
19:34:18 <roconnor> edwardk: E.T. Jaynes says "From the study of several such examples, we propose as a general principle: Whenever there is a randomized way of doing something, there is a nonrandomized way that yields better results from the same data, but requires more thinking."
19:34:18 <majuscule> right
19:34:23 <majuscule> thanks i'm an idiot
19:34:54 <edwardk> roconnor: well, goodie for him =P
19:35:02 <tomodo> im an idiot too
19:35:04 <roconnor> dolio: The cdf is continuous
19:35:09 <roconnor> dolio: sorry I misread you
19:35:19 <tomodo> even I can se thatg
19:35:38 <edwardk> roconnor: i however, like actually getting results out of bayesian tools, rather than sitting around on my duff for 6 months trying to derive a closed form for normalization constants that are irrelevant to the questions i'm asking
19:35:53 <mauke> tomodo: hi, are you ignoring me?
19:36:27 <roconnor> edwardk: E.T. Jaynes used computers extensively to evaluate solutions to problems with no closed form solutions.
19:36:37 <edwardk> yes
19:36:54 <edwardk> but i have a known tool i'm simply trying to duplicate so folks can use it in haskell.
19:37:01 <roconnor> edwardk: he is fine with computers, but the idea of getting better results by adding random data, he would consider that nonsense.
19:37:06 <edwardk> i'm not trying to engage the issue of randomization from a philosophical perspective
19:37:15 <tomodo> roconnor
19:37:16 <roconnor> oh okay
19:37:30 <tomodo> what about game playing AI such as zen19
19:37:33 <roconnor> edwardk: If you have a known tool, why the question about randomization?
19:38:01 <roconnor> tomodo: randomization definitely has a place in game theory.
19:38:18 <roconnor> tomodo: not so much in statistical inference.
19:38:22 <edwardk> what i have is a bunch of code for implementing various metropolis-hastings algorithms that i want to port down from the gpu into a toolbox for use in haskell
19:38:25 <tomodo> i see
19:38:42 <edwardk> where all the times i'd worked with it previously i'd gone and implemented special cases of the approach
19:39:21 <roconnor> IIRC, in game theory you need to use randomization to pick optimal strategies inside the convex hull of pure (non-random) strategies.
19:39:35 <edwardk> and i am looking to implement a nice 'general form' for it in haskell to a.) firm up my insights into code i've already written for it but also b.) provide a framework where other people can exploit it more easily
19:39:39 <roconnor> er, not to pick strageties but to perform stragegies
19:39:41 <roconnor> bah
19:40:00 <TheShamanoid> ohhh mama
19:40:14 <TheShamanoid> shit, why can i speak...
19:40:28 <edwardk> i usually use it for metropolis light transport, but the same techniques are used for bayes using gibbs sampling
19:40:40 <tomodo> what do i do if I am sad upset hurt
19:40:51 <roconnor> edwardk: if I derandomize metropolis light transport, will I be rich?
19:40:52 --- mode: ChanServ set +o mauke
19:40:52 --- mode: mauke set +q $a:tomodo
19:40:56 <edwardk> so i figured it'd be nice to have a library for talking about mcmc, gibbs sampling, etc.
19:40:58 <edwardk> roconnor: yes
19:41:03 <roconnor> $_$
19:41:16 <Shamanoid> mauke: why are you s aggressive
19:41:35 <mauke> Shamanoid: because I care
19:41:37 <edwardk> roconnor: if you derandomize bugs and get something faster you'd also be famous =P
19:41:47 <roconnor> edwardk: bugs?
19:41:47 <MostAwesomeDude> He doesn't appear agressive at all.
19:41:53 <edwardk> bayes using gibbs sampling
19:42:32 <roconnor> edwardk: what if I'm not faster, but instead more accurate.
19:42:39 <roconnor> I guess that amounts to the same thing.
19:42:52 --- mode: mauke set -o mauke
19:43:10 <edwardk> its used to generate random samples from a distribution for which you can't easily compute the normalization constants for the cdf
19:43:14 <edwardk> it really is all about speed
19:43:35 <edwardk> since its already correct
19:44:15 <roconnor> well, the random sampling is used to compute an integeral in the end.
19:44:57 <edwardk> or in general compute a bunch of statistics of the distribution, so various l-estimators, m-estimators, etc. get applied in practice
19:45:10 <roconnor> which are all integrals, no?
19:45:51 <edwardk> you may have a hard time phrasing l-estimation that way
19:46:01 <dolio> Haven't you heard? Integrals are meaningless.
19:46:08 <edwardk> dolio: hah
19:46:22 <roconnor> well, I guess I have a lot to learn before becoming rich. :/
19:46:28 <edwardk> roconnor: hah
19:48:58 <roconnor> The idea of a deranomized algorithm would be to get as accurate of an approximation to the integral, or whatever, with fewer samples than MC integration requires.
19:49:35 <roconnor> all I need to do is be as smart as Jaynes.
19:50:35 <dolio> Or you could be smarter, and realize he was wrong about everything being derandomizable. :)
19:51:57 <edwardk> ultimately it is a competition between the smarter algorithm designer's thinking speed and the slope of moore's law
19:52:30 <roconnor> dolio: well he does go on to say "Perhaps this principle does not have quite the status of a theorem, but we are confident that, whatever one is willing to do the required extra thinking, it will be confirmed."
19:53:13 <sutats> Could someone please help me with parallel processing the file list in http://hpaste.org/64355 (the first line with mapM in the main function)? Naively, I would want to split the list into 4 chunks and process each chunk on a separate core.
19:53:40 <MigZ> hi guys, any reason why ghc --make would suddenly stop making the final executable? It creates the .hi and .o but not the final exe
19:54:10 <JoeyA> MigZ: Do you have "module Foo where" at the top of your file?  (where Foo is not Main)
19:54:35 <edwardk> roconnor: well, to be fair i often replace a pure monte carlo with monte carlo using sobel sequences, etc. when i know there isn't an aversarial relationship between me and the data i'm sampling
19:54:35 <JoeyA> Doing so will cause ghc to treat it as a separate module, rather than the main module.
19:54:47 <edwardk> roconnor: which can be viewed as a weak form of derandomization
19:55:06 <JoeyA> MigZ: Thus, drop the "module Foo where" from your main module.
19:55:07 <edwardk> er sobol sequences
19:55:34 <MigZ> JoeyA, ah right. I must have changed that when I was going in and prettying up the code... thanks!
19:55:56 <JoeyA> By the way, if you're using GHC 7 or later, you can omit --make (it's default now)
19:56:18 <parcs`> as an alternative to JoeyA's solution you can pass --main-is Foo.main
19:56:41 <JoeyA> parcs`: Ah, good to know
19:57:19 <adu> edwardk: are you talking about coding competitions?
19:58:27 <edwardk> adu: no, i'd be more concerned with places where i'm doing lots of them next to one another and it could introduce a moire-like pattern rather than random noise in metropolis light transport, or where a competitor could control some of the data points, etc.
19:59:35 * adu is lost
20:02:20 <edwardk> http://www.youtube.com/watch?v=GMDfy_B0rvQ&list=UU5YhYCGJyApXE1PKhlSbUgw&index=1&feature=plcp shows metropolis light transport (being done in this case in near realtime on a gpu) -- it uses randomized sampling in a fundamental way, the error show up like static
20:03:12 <edwardk> if you aren't careful, then things like the the sobol sequence sampling i mentioned can introduce a more regular moire pattern in exchange for converging slightly faster
20:04:28 <adu> edwardk: fascinating
20:04:41 <edwardk> what was the last thing i said before i disconnected?
20:04:44 <adu> so that's a kind of ray tracing?
20:04:48 <edwardk> yeah
20:05:00 <adu> "if you aren't careful,"...
20:05:09 <edwardk> its ray tracing by being smarter about where you cast the rays basically
20:06:06 <edwardk> "our eyes tend to wash out and ignore the static but latch on to moire pattern noise, so this makes it worse over all"
20:07:30 <majuscule> Using Text.Regex.Posix, how do I return only the match inside parentheses, for example, `let t = "test" =~ "t(e)st" :: String` would return "e"
20:07:50 * hackagebot ghc-mod 1.10.10 - Happy Haskell programming on Emacs/Vim  http://hackage.haskell.org/package/ghc-mod-1.10.10 (KazuYamamoto)
20:19:21 <djahandarie> Anyone here know much about UIllinois' undergrad CS dept?
20:20:00 <djahandarie> They seem to have a number of people who are into the 'right' thing (pl theory, theorem proving, math), but I oddly haven't heard of them ever before in my life
20:20:56 <adu> pl= programming language?
20:21:02 <djahandarie> Yep
20:21:08 <adu> I like those!
20:21:12 <djahandarie> :P
20:21:46 <adu> although, they're all starting to blend together
20:21:54 <djahandarie> :)
20:23:03 <adu> what's really funny is I'm starting to see curly braces in Ruby, and parentheses in Python, and ":-" in Haskell, and when I look again, they're not there...
20:23:29 <ski> `:-' in Prolog, maybe you mean ?
20:23:34 <adu> yes
20:24:16 <ski> adu : maybe you should learn a lisp, now ?
20:24:18 <djahandarie> Prolog, Haskell, pretty much the same anyways.
20:24:20 <djahandarie> :^)
20:24:31 <adu> ski: right now I'm working on scheme
20:24:37 <djahandarie> (That's my liar nose.)
20:24:41 <ski> djahandarie : well, there are *some* small differences :)
20:24:47 <adu> syntax-rules has always mystified me
20:24:54 <ski> adu : that's good for you ! :)
20:25:22 <ski> basic use of `syntax-rules' isn't so complicated
20:25:28 <adu> I've been preparing to blog about syntax-rules
20:25:48 <adu> well, what's odd is that most info about scheme's macro system talks about syntax-case
20:26:45 <adu> I was also considering overviewing a handful of macro/templating systems
20:26:50 <ski> well, `syntax-case' isn't in a standard
20:26:50 <ski> (or maybe it went into R^6RS, i don't recall)
20:27:08 <ski> adu : you should check out MetaML/MetaOCaml
20:27:14 <adu> syntax-case is optional in R6RS, and it's not in R7RS *yet*
20:27:31 <ski> (not quite macro system, but staged programming, which is related)
20:28:05 <adu> my last entry was a survey, I really like comparing things
20:28:12 <ski> "Macros as Multi-Stage Computations: Type-Safe, Generative, Binding Macros in MacroML" by Steve Ganz,Amr Sabry,Walid Taha is interesting
20:28:48 <ski> (and is related to MetaML)
20:28:50 <adu> in case you're interested, my blog: http://straymindcough.blogspot.com/
20:31:46 <ski> adu : "Proposal for Division Operators in Scheme" <http://mumble.net/~campbell/tmp/division.txt> might be interesting re the "divmod" post
20:32:09 <adu> that looks like R7RS
20:33:25 <ski> well, now that you mention it, istr people taking that proposal up in the R7RS process
20:33:56 <adu> yes, those exact names are in R7RS, with one addition: (centered/ …) which represents what I call divmod_rnn
20:34:11 <zzo38> In my idea of new programming language I have written part of specification already. There are similarity to Haskell. But, some of my ideas are: One type of kind # might be (unsafe "i8"). And all monomorphic types of kind ? (even if they have polymorphic components) are automatically instances of (\x -> Prelude.typeOf :: x -> Prelude.Type) although it is not implied so you need to mention it explicitly if you use it.
20:34:25 <zzo38>  (The other thing, various things are put into the prelude which isn't what Haskell does) And I don't know, if this seem at all sensible to you or not.
20:34:30 <zzo38> Do you knkow?
20:35:01 <adu> zzo38: what?
20:35:41 <mlh> majuscule: I /think/ you're looking for the Perl style capture vs non-capture.  I don't think Haskell (or at least text.regex.posix) gives you thaose
20:35:49 <mlh> I came up with
20:35:56 <mlh> > ("test" =~ "t(e)st" :: [[String]]) !! 0 !! 1
20:35:57 <lambdabot>   "e"
20:36:08 <ski> zzo38 : what is `Prelude.Type' for ?
20:36:09 <otters> :t (=~)
20:36:10 <lambdabot> forall source1 source target. (RegexMaker Regex CompOption ExecOption source, RegexContext Regex source1 target) => source1 -> source -> target
20:36:26 <zzo38> ski: Like the Data.Typeable.TypeRep in Haskell
20:36:36 <adu> ski: I think zzo38 is talking about "deriving Typeable" on everything
20:36:45 <zzo38> Except in this case it is built-in
20:36:55 <adu> sounds like JS
20:37:16 <zzo38> adu: Yes, like that. But still, it is a class that you must mention in a constraint if you want to be able to use it on a polymorphic type.
20:37:18 <ski> zzo38 : i'm just wondering why you need it, if you're providing this built-in to the language
20:37:38 <majuscule> mlh: thanks. that is what i'm looking for. thnks for trying to figure something out, but i think it'l be infeasible with my more complicated requirements. I ended up chopping away at the string with `drop` and `take` and got a working solution
20:38:05 <zzo38> ski: That's why. It is so that you can make things that you can compare types or you cannot compare types, when something has a polymorphic type such as a field of a constructor of a datatype.
20:38:05 <hpaste> Shamanoid pasted “Stupid Question” at http://hpaste.org/64424
20:38:32 <Shamanoid> question supplied in paste
20:39:03 <Shamanoid> i should say "where" but ....
20:39:13 <zzo38> ski: Now do you know the reason?
20:39:37 <JoeyA> Shamanoid: map (eliminate...) (v:vrs) ?
20:39:39 <ski> not really
20:39:46 <JoeyA> (v:vrs) prepends v to the list.
20:40:05 <ski> zzo38 : maybe you'd be interested in looking at Clean's `Dynamic' at <http://clean.cs.ru.nl/download/html_report/CleanRep.2.2_10.htm> ?
20:40:37 <Shamanoid> alright i will give that a try
20:40:46 <ski> @type fromDynamic
20:40:47 <lambdabot> forall a. (Typeable a) => Dynamic -> Maybe a
20:40:47 <ski> @type toDyn
20:40:48 <lambdabot> forall a. (Typeable a) => a -> Dynamic
20:40:49 <ski> @type cast
20:40:50 <lambdabot> forall a b. (Typeable a, Typeable b) => a -> Maybe b
20:40:59 <JoeyA> Shamanoid: Or is eliminate_inconsistent_vals polymorphic, so you need a type annotation to disambiguate?
20:41:30 <ski> zzo38 : if you only want those operations, `Type'/`TypeRep' seems extraneous -- so i'm wondering for what purpose you want them ?
20:42:33 <zzo38> ski: So that you can specify whether or not you can compare types of something having a polymorphic type.
20:42:36 <Shamanoid> JoeyA: (v:vs) worked
20:43:02 <Shamanoid> JoeyA: thanks
20:43:06 <JoeyA> no problem
20:43:12 <ski> Shamanoid : is `CSP' a list type ?
20:44:57 <ski> zzo38 : i don't understand. you could have a constraint corresponding to `Typable' in Haskell without having `typeOf'. i also don't understand what you mean re "polymorphic types" (itym "universal(ly quantified) types") here
20:45:48 * ski wonders if Shamanoid maybe wants a `map' or a `foldr'
20:45:55 <Shamanoid> ski: CSP -> Constraint Specific Problem, it is tuple containing (String,[(String,Int))
20:46:18 <zzo38> ski: OK. But can you explain better how you mean? Yes I do mean a universally quantified types
20:46:30 * ski would have expected s/Specific/Satisfaction/
20:47:12 <sangeeag> hey is somone there?
20:47:17 <Shamanoid> ski: actually that code is completely wrong, i already implemented such a thing in a previous function
20:47:29 <ski> zzo38 : well, it seems to me `TypeRep' is in many cases an implementation detail of `Dynamic' -- so i'm wondering if you have any direct use for it, apart from implementing `Dynamic'
20:47:44 <ski> sangeeag : someone is here
20:47:58 <ski> sangeeag : do you have a Haskell question ? :)
20:48:02 <zzo38> ski: See my extensible-data package for one possible example in Haskell.
20:49:25 <sangeeag> can somebody help me? i need to do a function called removeFst that given an Int m and a list of ints it needs to remove the first ocurrence of m and return the list if m doesnt appear it returns the original list
20:50:09 <sangeeag> thanks for your help im new in this thing called functional programming thanks for your help
20:50:30 <JoeyA> Is this homework?  (it's okay if it is, we just need to know)
20:51:09 <sangeeag> haha mm no it isnt, basically i need to learn haskell to start working with a lecturer at the university
20:51:17 <JoeyA> Ah
20:51:41 <sangeeag> sadly in my undergraduate program it is not obligatory to learn the functional paradigm
20:52:08 <JoeyA> sangeeag: So can you figure out a type signature for the function you're describing?
20:52:34 <sangeeag> joey excuse my ignorance what the heck is a type signature
20:52:36 <sangeeag> ?
20:52:36 <ski> zzo38 : should i look at `Data.Extensible.Product' or what ?
20:52:47 <JoeyA> :t map
20:52:47 <lambdabot> forall a b. (a -> b) -> [a] -> [b]
20:52:54 <zzo38> ski: All of the modules use Typeable.
20:53:01 <ski> zzo38 : i see `typeOf' and `unsafeCoerce' in there, but i'm not sure why you call `typeOf'
20:53:01 <JoeyA> ^ That's an example of a type signature.
20:53:03 <sangeeag> ah i undetrstood yes
20:53:24 <ski> zzo38 : yeah, i wasn't talking about `Typeable', i was talking about `TypeRep' (and thus `typeOf')
20:53:27 <sangeeag> i guess it is Int -> [Int] -> [int]
20:53:40 <adu> I
20:53:43 <sangeeag> removeFst :: Int -> [Int] -> [int]
20:53:59 <adu> s/i/I/
20:54:03 <JoeyA> Right, except for a little typo: int should read Int
20:54:14 <sangeeag> or removeFst (Int, [Int]) -> [int] But I think is the first one
20:54:17 <JoeyA> Haskell treats lowercase identifiers in type signatures as type variables.
20:54:33 <adu> sangeeag: s/i/I/
20:54:37 <ski> sangeeag : the first one is more idiomatic, yes (but both would work)
20:54:39 <zzo38> ski: Why do you not understand why? Maybe if you pay attention more you can understand the reason. Although each module uses it in a slightly different ways. That is, Typeable, TypeRep, typeOf, all of them are related.
20:54:40 <sangeeag> yes it is excuse me
20:55:16 <sangeeag> thnaks ski
20:55:38 <ski> (no need to ask us to excuse you, there's nothing to excuse)
20:55:41 <sangeeag> ok guys do you have any idea im still thinking as a c++ programmer
20:56:02 <ski> sangeeag : i think you should try recursion, using a base case, and a recursive case
20:56:06 <JoeyA> sangeeag: The next step is to do some pattern matching on the list.
20:56:21 <JoeyA> removeFst (x:xs) = ...
20:56:41 <JoeyA> You'll also need removeFst [], to handle the case when the list is empty.
20:57:15 <JoeyA> The (x:xs) pattern unpacks the cons cell into x (the first item) and xs (the remaining items).
20:57:52 <JoeyA> err, removeFst needle (x:xs)
20:58:05 <sangeeag> ok i think i might have a solution
20:58:14 <sangeeag> but i have another question
20:58:22 <adu> I know, I could blog about Haskell!
20:58:28 <ski> zzo38 : well, i'm just jumping in here trying to understand ..
20:58:43 <sangeeag> whats the difference if i define the type signature as Int -> [Int] -> [int] or as (Int, [Int]) -> [int]?
20:58:47 <ski> zzo38 : .. why do you have types as keys in `HashMap TypeRep Any' ?
20:59:03 <ivanm> sangeeag: well, you generally never want to return [int]
20:59:06 <JoeyA> sangeeag: Stop repeating the [int] typo, please
20:59:09 <ivanm> since that's just a type variable ;)
20:59:17 <adu> sangeeag: s/i/I/
20:59:23 <ivanm> the former makes it easier for partial application
20:59:50 <sangeeag> wait explain me why is so important to write Int with upper case
20:59:57 <sangeeag> adu.
20:59:59 <sangeeag> adu:
21:00:07 <ivanm> sangeeag: Int is a concrete type
21:00:12 <JoeyA> sangeeag: Int -> [Int] -> [int] is the same as Int -> [Int] -> [a]
21:00:13 <ivanm> fixed-precision integral values
21:00:15 <ski> sangeeag : the former would specify it as a curried function, the latter as an un-curried function -- with the former, you'd call it like `removeFst m list', with the latter as `removeFst (m,list)'
21:00:39 <adu> sangeeag: well, Haskell is case-sensitive, that should be reason enough
21:00:56 <Eduard_Munteanu> @djinn Bool
21:00:56 <lambdabot> f = False
21:00:59 <Eduard_Munteanu> @djinn bool
21:00:59 <lambdabot> -- f cannot be realized.
21:01:25 <zzo38> ski: I thought it was obvious? The reason is the types are the field labels; so you can add them anywhere including in other modules.
21:01:25 <sangeeag> ok I already understood thanks and apologize me for being that jackass
21:01:48 <sangeeag> JoeyA: what is needle?
21:02:39 <ivanm> @wn needle
21:02:39 <ski> zzo38 : ok, so you need to create a new type for each new field label ?
21:02:40 <lambdabot> *** "needle" wn "WordNet (r) 3.0 (2006)"
21:02:40 <lambdabot> needle
21:02:40 <lambdabot>     n 1: the leaf of a conifer [syn: {acerate leaf}, {needle}]
21:02:40 <lambdabot>     2: a slender pointer for indicating the reading on the scale of
21:02:40 <lambdabot>        a measuring instrument
21:02:42 <lambdabot> [6 @more lines]
21:02:46 <adu> sangeeag: when searching, what you're looking in is called the haystack, and what you're looking for is a needle
21:02:54 <zzo38> ski: Yes. That is how it works.
21:03:03 * ski thinks that sounds a bit strange
21:03:18 <zzo38> (You also need to create an instance of the class, in order to set a default)
21:03:54 <ski> can you have several records, each indexed by all these field labels ?
21:04:22 <zzo38> ski: If you look at it, you can see that each record type uses different field labels.
21:05:35 <ski> (zzo38 : btw, i would like to romove the `Any' stuff, replacing this with a map that allows each key to specify the type of the corresponding value -- that should get rid of many if not all the `unsafeCoerce's, i hope)
21:06:20 <ski> (of course, i don't think there's any such `HashMap' variant atm, so it'd have to be built)
21:08:20 <zzo38> ski: Yes, that is exactly how it is. And I noticed the author of "hashable" package has added hash for TypeRep, soon after I have posted the first version of my package; I wonder if they did that for a related reason or not?
21:09:15 <ski> zzo38 : i.e. i was thinking about something like `HashMap1 :: (* -> *) -> (* -> *) -> *' with `lookup :: Eq1 key => HashMap1 key value -> key i -> Maybe (value i)'
21:10:15 <ski> where `class Eq1 f where eq1 :: f a -> f b -> Maybe (Equal a b)' with `data Equal :: * -> * -> * where Refl :: Equal a a'
21:10:49 <zzo38> OK, that is some kind of idea. Yes I do understand you.
21:11:18 <ski> hm, though i wonder how to combine this with default values ..
21:11:59 <zzo38> I do know there are other packages for extensible record types and extensible datatypes you can add more constructors, but they often have many classes and from what I have seen, they need to be chained together instead of allowing to define anywhere.
21:12:09 <ski> i suppose each field label type would have to determine an element type, so that you could specify a default value for that type
21:12:37 <sangeeag> hey dudes how do i put the operator different in haskell??? what is (!=) in java?
21:12:47 <zzo38> ski: Yes. That is how I have done it. I also implemented dependent defaults where the default value can depend on something.
21:12:47 <sangeeag> no the same as != in java
21:12:57 <ski> zzo38 : hm. your extensible records are global-extent, yes ?
21:13:15 <zzo38> ski: What do you mean by global-extent?
21:13:15 <ski> sangeeag : `/='
21:13:30 <ski> > 3 /= 4
21:13:31 <lambdabot>   True
21:13:33 <ski> > 3 /= 3
21:13:34 <lambdabot>   False
21:13:44 <sangeeag> thanks
21:13:58 <ski> zzo38 : lives as long as the program
21:14:08 <ski> (s/program/process/)
21:15:15 <ski> zzo38 : at least "Extensible lists: Add to a list at compile-time in many modules" seems to suggest that there's one such list which is constructed by contributions from many modules
21:16:03 <ski> zzo38 : maybe "Extensible products" doesn't do that kind of thing, though
21:17:24 <zzo38> ski: Extensible lists are constant at runtime. Extensible products are different
21:17:48 <sangeeag> removeFst :: Int -> [Int] -> [Int] removeFst m []                  = [] removeFst m (x:xs) | x /= m     = [x] ++ (removeFst m (x + 1))                    | otherwise  = removeFst m (x + 1)
21:18:18 <vyom> can I run a script in cabal configure to do some autogeneration before I do a cabal build?
21:18:43 <sangeeag> this is the code i get this error message: GS.hs:96:58:     No instance for (Num [Int])       arising from a use of `+'     Possible fix: add an instance declaration for (Num [Int])     In the second argument of `removeFst', namely `(x + 1)'     In the second argument of `(++)', namely `(removeFst m (x + 1))'     In the expression: [x] ++ (removeFst m (x + 1)) Failed, modules loaded: none.
21:19:09 <sangeeag> can somebody tell me what am i doing wrong?
21:20:00 <zzo38> I have some other obscure question, is it allowed for the main module to export the main which has been imported from some other module, or does it have to export its own main?
21:20:14 <ivanm> I think it can re-export another
21:20:20 <ivanm> but you'd have to explicitly re-export it
21:21:43 <Eduard_Munteanu> I guess you could import that other module qualified, if in doubt.
21:21:54 <zzo38> ivanm: Yes I do intend to explicitly re-export it of course
21:22:19 <byorgey> sangeeag: the second argument of removeFst is a list, but you are passing it (x + 1)
21:22:26 <byorgey> (x + 1) is not a list.
21:23:42 <sangeeag> so how could I pass it (x+1:xs) maybe?
21:24:02 <ski> zzo38 : (re extensible) ok
21:24:34 <Jafet> sangeeag: what is removeFst?
21:25:08 <ski> Jafet : see above
21:25:22 <sangeeag> is a function tha receives an Int m an a list of Ints and return a new lsit without the first occurence of m if m happens
21:25:34 <ski> (`removeFst m xs' should remove the first occurance of `m' in `xs', doing nothing if none present)
21:25:35 <Jafet> ski: If it is defined as code that doesn't work, that's not very useful
21:25:56 <Jafet> Oh, above the above.
21:26:02 * ski nods
21:27:40 <Jafet> sangeeag: and why do you write (removeFst m (x+1))? What should it mean?
21:28:35 <ski> sangeeag : you should probably use `xs' somewhere in the recursive clause, no ?
21:29:14 <sangeeag> Jafet : I need to obtain a list starting from the next element, for example if x is an element of the list and i am currently checking x i need to analize a sublist that starts from x+1 to the end of the list
21:29:32 <sangeeag> Jafet: but I dont know how to do that
21:29:41 <Jafet> Is x+1 part of the list?
21:29:58 <byorgey> sangeeag: if the input list is (x:xs), then xs is the remainder of the list
21:30:22 <Jafet> sangeeag: suppose (x:xs) matches [1,3,5]; what is x, and what is xs?
21:30:24 <byorgey> x+1 means to add 1 to the value of x, it doesn't have anything to do with the next element in the list
21:30:50 <Jafet> Apparently the socratic method is not approved here
21:31:24 <shachaf> Jafet attempts to corrupt the youth.
21:31:27 <edwardk> jafet: its approved, just tends to get drowned out in other answers
21:31:51 <sangeeag> so I'm screwed up
21:32:18 <Jafet> No, I goad the youth into corrupting themselves.
21:39:55 <zzo38> Someone in this channel once said that there should not be "Int" type in the prelude, when I was mentioning my own idea of new programming language. I agree; now my idea is, not to have any "Int" type at all; use "Integer" if you want unbounded or "Int8"/"Int32"/whatever if you want a specific number of bits.
21:42:24 <dmwit> zzo38: Yep, seems like good practice.
21:44:06 <zzo38> dmwit: I forget who told me there should not be "Int" in prelude; was it you? Nevertheless, I do agree now that instead you should specify unbounded or the number of bits explicitly. (Some people didn't want Int8 and so on in the prelude either; but I disagree about that since this is new programming language it is not Haskell)
21:45:10 <Jafet> zzo: and what about Double?
21:45:12 <zzo38> But my also idea is, the unsigned variants of those types, "Natural", "Nat8", "Nat16", "Nat32", and so on; in addition to the "Integer" and "Int8" and so on for signed.
21:45:36 <Sgeo> :t let y f = f (y f) in y
21:45:36 <zzo38> Jafet: I have thought about floating point numbers a little bit but not much; but if you have any idea then please tell me.
21:45:36 <lambdabot> forall t. (t -> t) -> t
21:46:03 <dmwit> zzo38: Those are called Word8, Word16, and Word32 in Haskell.
21:46:28 <zzo38> dmwit: I know that. But in this one I intend to call it Nat8, Nat16, and Nat32 instead.
21:48:54 <zzo38> I don't know what you prefer; I would like to know but do not intend to change it anyways (it would be possible for anyone to make up their own alternative preludes and that stuff changing all te names and so on, too)
21:54:47 <majuscule> I'm trying to `state <- volumeUp state`, which works inside a function, but when I put it inside an `if..then..else` clause I get an error on `<-`. I'm looking at the docs and I see <- can only be used in do expressions, so I think the answer is to inclose the command in a "do" clause? but then I start getting type errors. I'm very confused and I feel like I'm missing something basic. Is there some advice anyone could give or documentation I should focu
21:55:16 <dmwit> zzo38: I have no objection to Nat{8,16,32}
21:55:39 <shachaf> majuscule: do { x <- y; if x then z else w }
21:55:55 <shachaf> majuscule: But you'll be best off reading about what "do" actually does and what it gets translated to.
21:55:55 <zzo38> dmwit: OK.
21:55:57 <dmwit> majuscule: What errors do you get? You should post some code and the exact error.
21:55:59 <shachaf> It'll make more sense after that.
21:56:00 <dmwit> ?hpaste
21:56:00 <lambdabot> Haskell pastebin: http://hpaste.org/
21:57:50 <zzo38> Tell me if anything else in Haskell you don't really like their names or implementations or whatever. One thing I already have, is that monads are defined in terms of join instead of >>= but tell me if you have anything else (also tell me of the names fmap/return/join and so on should be changed; maybe "map" instead of "fmap"?)
21:57:54 * hackagebot xturtle 0.0.16 - turtle like LOGO  http://hackage.haskell.org/package/xturtle-0.0.16 (YoshikuniJujo)
21:59:22 <DanBurton> list operations should be typeclassed
21:59:38 <shachaf> No they shouldn't.
21:59:46 <DanBurton> so that you don't have to qualify or hide list-like structures
21:59:53 <majuscule> shachaf: I tried `do { State -> State; if dir < 2 then state <- volumeUp state else state <- volumeDown state}` but still no luck. I am looking at the `do` documentation, but i don't follow exactly. it says it's syntactic sugar for a monad, ex. do { x; result <- y; foo result }, but I don't understand what that means. From what you told me, wich the x<-y in the front, I assumed you meant that I needed to notate the type of the do function, in this case 
21:59:55 * ski wonders who'll think of `Int36'. it feels left out
22:00:18 <shachaf> majuscule: You need an additional do block. I have to go, will be back later.
22:00:19 <zzo38> DanBurton: Do you mean like Data.Map and Data.Set and so on?
22:00:36 <majuscule> shachaf: thanks for your help already
22:00:37 <DanBurton> zzo38: yes. Particularly Data.Sequence, which should be used a lot more than it currently is
22:01:03 <ski> zzo38 : add a `local' construct
22:01:24 <DanBurton> scumbag shachaf, contradicts me but doesn't give reasons, and leaves >,<
22:01:59 <zzo38> DanBurton: O, OK. Yes I do understand. One of my ideas is already, that what [] means is a macro, so you can change that macro if you want to, so that the Haskell [] can now be called List and make [] a macro pointing to List and so on. Same thing with many other stuff.
22:02:04 <zzo38> ski: Explain better please?
22:04:10 <majuscule> Can anyone else help me figure out this if..then..else statement? I now tried `if dir > 2 then do { State -> State; state <- volumeUp state; return state} else do { State -> State; state <- volumeDown state; return state}` trying to follow shachafs advice, but it still gives an error about the <-
22:04:51 <ski> zzo38 : like `local <decls> in <decls> end' in SML
22:04:51 <DanBurton> majuscule: what's that "State -> State" part at the beginning of your do blocks?
22:05:55 <majuscule> DanBurton: I thought it'd be to notate the type of the do function, but apparently I was wrong about how that works. What I'm trying to do is update `state` using either `volumeUp` or `volumeDown` depending on the value of `dir`
22:06:10 <zzo38> ski: I don't know about SML. But I think I understand you. I do not currently intend to have such a thing, but might change my mind in future. It is also possible that it might be possible to implement such things using macros.
22:06:26 <DanBurton> what I would do is something more like this: `do state' <- (if dir > 2 then volumeUp else volumeDown) state; return state'`
22:06:49 <DanBurton> actually it depends on the volumeUp / volumeDown functions
22:07:08 <zzo38> DanBurton: You don't even need return in there, or do.
22:07:17 <ski> that can be simplified to `(if dir > 2 then volumeUp else volumeDown) state'
22:07:22 <DanBurton> zzo38: indeed
22:07:46 <DanBurton> ski: indeed
22:07:54 * hackagebot wai-app-file-cgi 0.5.5 - File/CGI/Rev Proxy App of WAI  http://hackage.haskell.org/package/wai-app-file-cgi-0.5.5 (KazuYamamoto)
22:08:27 <majuscule> Err, I'm actually getting an error without the return statement, but with it it works!
22:08:35 <majuscule> DanBurton: thank you!!
22:09:45 <DanBurton> majuscule: =) if you want deeper explanation of why that works, or if you want us to review your code for good style, just ask
22:09:55 <majuscule> DanBurton: is there any chance you could attempt to explain why it doesn't work the way I first tried with a simple if..then..else? I've been reading and reading and am having trouble getting grips on this. I think it has something to do with functions needing to have no side effects or something?
22:10:31 <sangeeag> JoeyA: ski: thank you I did it
22:10:44 <DanBurton> majuscule: well first of all, don't think of "do" as a function. I suspect if you removed the "type signatures" then it would've worked the way you had it already
22:10:48 <sangeeag> and also ivanm:
22:11:58 <DanBurton> majuscule: secondly, think of if...then...else as an expression. When the condition is true, the expression evaluates to the "then" branch, otherwise it evaluates to the "else" branch.
22:12:25 <majuscule> DanBurton: I would love for someone to look over the code when it's done but it's still a mess as i'm figuring everything out. This is my first time using haskell and I am trying to write my own bindings for a griffin powermate using haskell-powermate and looking at mpdmate for reference. I had tried it without the "type signatures" and it did not work, maybe I had a typo or something bizarre, i'll try again in a minute for fun
22:12:27 <DanBurton> majuscule: it's a common mistake for people with experience in other languages to think of if/then/else in Haskell as a control flow mechanism, when it isn't really that
22:12:45 <ski> sangeeag : if you want to, you could show how you did it
22:13:00 <ski> sangeeag : we might be able to suggest some improvement
22:13:20 <zzo38> I happen to prefer   bool <falsepart> <truepart> <condition>   instead of   if <condition> then <truepart> else <falsepart>   in Haskell myself, but this is just my opinion.
22:13:38 <majuscule> DanBurton: forgive my ignorance, but how is it NOT a flow control method? Even in the working code that is exactly what it is doing no?
22:13:59 <ski> zzo38 : that is sometimes to be preferred, yes
22:14:13 <DanBurton> majuscule: it's not control flow, it's...erm..."evaluation" flow. It is an *expression* that evaluates to a value.
22:15:04 <DanBurton> while in C-like languages, if expressions *don't* evaluate to a value, they just direct execution of effects
22:15:12 <zzo38> ski: So, in my own idea of new programming language, I am writing specification, it won't have if/then/else expressions
22:15:28 <zzo38> DanBurton: In C, there is ? : operator which is condition in expression, though.
22:15:35 <DanBurton> true
22:15:52 <ski> zzo38 : will you have functional `case' and `fold' constructions, like Charity ?
22:16:06 <DanBurton> and it *is* correct to think of Haskell's if FOO then BAR else BAZ as being equivalent to FOO ? BAR : BAZ
22:16:17 <zzo38> ski: What are functional `case' and `fold' constructions?
22:16:41 <ski> (something like `(case Nothing -> ... ; Just x -> ..x..) foo' instead of `case foo of Nothing -> ... ; Just x -> ..x..')
22:16:47 <ski> @where Charity
22:16:47 <lambdabot> http://pll.cpsc.ucalgary.ca/charity1/www/home.html
22:16:51 <ski> zzo38 : also see ^
22:17:29 <zzo38> ski: Yes, exactly my idea, although the syntax would be  \{ Nothing -> ...; Just x -> ..x.. } foo   (if there is only one pattern, you can omit the {})
22:17:38 <DanBurton> case expressions are basically a straightforward generalization of if/then/else
22:17:53 <DanBurton> zzo38: looks like Scala
22:18:09 <ski> (and something like `(fold [] -> ... ; a : r -> ..a..r..) as' instead of `foldr (\a r -> ..a..r..) (...) as')
22:18:16 <zzo38> DanBurton: Without the {} and with only one pattern, it is the same as the \ in Haskell.
22:18:37 <ski> zzo38 : ok. you may find Charity interesting to look at, then
22:18:43 <MaskRay__> is there any tutorial on multiplate and related concepts (i can't grasp what the haskellwiki says)
22:19:58 <ski> MaskRay__ : try asking roconnor ?
22:20:13 <ski> not here atm, though
22:20:18 <ski> preflex: xseen roconnor
22:20:18 <preflex>  roconnor was last seen on freenode/#haskell 2 hours, 27 minutes and 47 seconds ago, saying: dolio: well he does go on to say "Perhaps this principle does not have quite the status of a theorem, but we are confident that, whatever one is willing to do the required extra thinking, it will be confirmed."
22:20:55 <zzo38> ski: I have seen some thing in Charity before; one of my complaints with Charity is the license conditions. I don't care if proprietary implementations exist but the main ones should be free softwares, in my opinion.
22:21:27 <ski> zzo38 : yeah, i'm only pointing you to it to look at the ideas
22:22:48 <zzo38> ski: Yes, OK. I tried to read the document but it is only PostScript. I don't have that on my computer; I can load DVI file and PDF file (DVI preferred) but I don't have PostScript.
22:22:51 <ski> zzo38 : specifically here so you can better understand how that `fold' expression would work
22:23:29 <ski> zzo38 : you might try `ggv' for PostScript
22:23:46 <majuscule> DanBurton: errr actually, it seems like that code isn't working. I've pastebinned the whole thing, it's not too long, the do { if statement is below the only commented line. When I run the do { if, the volume functions run but the state itself doesn't get updated. When I comment that and uncomment the other, the state always gets updated with volumeDown. http://dpaste.com/708372/
22:24:40 <zzo38> ski: OK. (But I also dislike PostScript and PDF)
22:24:51 <DanBurton> majuscule: for future reference, you can use http://hpaste.com/new/haskell which has the added benefits of Haskell syntax highlighting and automatic style suggestions
22:24:58 <DanBurton> majuscule: I'll take a look at the code you've got
22:25:20 <majuscule> DanBurton: good to know, thanks
22:25:41 * ski prefers PS to PDF
22:25:50 <majuscule> DanBurton: err, authorization required?
22:26:08 <zzo38> ski: Can you explain why? I prefer DVI.
22:26:12 <DanBurton> majuscule: o_O crap wrong link
22:26:27 <DanBurton> majuscule: http://hpaste.org/new/haskell -- note the .org >,<
22:26:36 <majuscule> i see i see
22:26:37 <majuscule> haha
22:26:52 <ski> zzo38 : possibly irrational, but PS doesn't seem as bloated. haven't much experience with DVI
22:27:05 <ski> zzo38 : and you ?
22:28:22 <ski> MaskRay__ : oh, you have a `do' inside a `do'
22:28:24 <ski> er
22:28:28 <ski> majuscule : ^
22:28:49 <zzo38> ski: OK. I think DVI is a simple and reasonable format, possibly a similar reason than you. I think PS and PDF are both full of dumb stuff but different dumb stuff than each other. But still, at least PS does not have stupid stuff like audio that cannot be printed out and so on
22:28:50 <majuscule> ski: :-/ what're the implications of that
22:28:51 <ski> majuscule : replace `do state <- (if dir < 2 then volumeUp else volumeDown) state; return state;' with `state <- (if dir < 2 then volumeUp else volumeDown) state'
22:29:36 <Rc43> Hi, guys.
22:29:38 <MaskRay__> ski: really appreciate your tip
22:29:38 <ski> majuscule : also note that the `;' here typically would be line-breaks when written in a file
22:29:44 <hpaste> DanBurton pasted “powermate: my suggestions” at http://hpaste.org/64425
22:29:56 <ski> MaskRay__ : glad to be of service
22:30:54 <ski> (majuscule : i.e. we just wrote `;' before to avoid having to write it in several lines on IRC)
22:30:58 <zzo38> Probably a few of ideas of new programming language is things that many people hate, but I intend anyways; these include do-notation and layout syntax.
22:31:14 <DanBurton> majuscule: there is no notion in Haskell of modifying a variable, unless you use explicit functions such as newRef and modifyRef
22:31:30 <Rc43> What means `| m -> s` in `class Monad m => MonadState s m | m -> s where`? How is this syntax named?
22:31:47 <nyingen> Rc43: looks like a 'functional depedency' or fundep
22:31:53 <Jafet> @quote fundep
22:31:53 <lambdabot> Veinor says: just remember: you can't spell fundeps without fun.
22:31:55 <DanBurton> majuscule: rather, you need to indicate that a new state results from changing the volume from the old state.
22:32:04 <ski> majuscule : `do' inside `do' is fine, but can be flattened -- in this case it caused the inner `state <- ...' binding to not be visible after the whole inner `do', which is why the state didn't appear to update
22:32:09 <zzo38> Rc43: Functional dependencies
22:32:23 <nyingen> Rc43: google for the docs. they seem to have fallen into disfavor, with type families taking their place
22:32:28 <Rc43> Cool, thanks. Didn't know about such thing.
22:32:34 <zzo38> Rc43: It mean that there must be a single type "s" for every type "m" having a instance of this class.
22:32:45 <zzo38> (So, "m" implies "s")
22:33:16 <Rc43> nyingen, disfavor? Why?
22:33:17 <ski> majuscule : see the third law at <http://www.haskell.org/haskellwiki/Monad_laws> for how one can flatten a `do'-inside`do'
22:33:17 <majuscule> DanBurton: ahhh thank you. I think the difference between "changing" and "updating" a variable is a bit strange to me, but this seems to make sense.
22:33:39 <majuscule> ski: i'll look at that now, thank you
22:34:06 <shachaf> majuscule: Am back. Did you figure it out?
22:34:24 <majuscule> shachaf: with a great deal of additional help :-)
22:34:25 <DanBurton> majuscule: one dangerous thing about "do" notation is that it might look like you are changing or updating a variable by using "foo <- bar" where you have defined foo previously. It doesn't actually update foo, but rather, creates a new value named "foo" which shadows the old one.
22:34:35 <shachaf> DanBurton: DId you figure it out?
22:35:09 <DanBurton> shachaf: figure out why you oppose typeclassing list operations? nope, not yet.
22:35:51 <DanBurton> shachaf: I assume you meant to direct that question at majuscule, though? ski and I have been chatting with him about stuff
22:36:35 <majuscule> shachaf: I did with your help and DanBurtons
22:36:42 <shachaf> DanBurton: No, I meant you.
22:36:56 <shachaf> But then I realized that it would be a long and redundant discussion, so never mind.
22:37:08 <nyingen> Rc43: http://www.haskell.org/haskellwiki/GHC/Type_families has some good info
22:37:10 <shachaf> See if you can figure out a reasonable way to make it work, I guess.
22:37:30 <Rc43> nyingen, ok, thanks
22:37:32 <ski> Rc43 : in `class Monad m => MonadState s m | m -> s where ...`, the FD means `forall m. unique s. MonadState s m', meaning `forall m s0 s1. (MonadState s0 m,MonadState s1 m) => s0 = s1' meaning that for each type `m', there can be at most one `s' such that `MonadState s m' -- there can't be two instances `MonadState s0 m',`MonadState s1 m' for different types `s0',`s1' (but the same type `m')
22:37:50 <DanBurton> shachaf: well that's true. I've been working on trying to make it work without just dumping every list operation ever into one huge typeclass and providing tons of defaults. So far no luck
22:38:51 <ski> Rc43 : this kind of thing is sometimes needed to avoid ambiguity with class methods, and sometimes the restriction is sensible because of what the class is intended to model
22:38:54 <DanBurton> me and my Sexy will be playing with the list typeclasses idea, though. Probably for the next week or so.
22:38:56 <Rc43> ski, it is related to existential types?
22:39:06 <Rc43> *is it
22:39:20 <shachaf> DanBurton: Operations that make sense to do on sequences vary by the type of sequence.
22:39:27 <augur> aristid!
22:39:38 <ski> Rc43 : iirc, you can use associated types (a special case of `type'/`data' families) instead in many cases, but not all
22:39:45 <ski> Rc43 : not particularly
22:39:47 <shachaf> In the case that the operation that you want is iteration, toList would be the only operation you need, because lists themselves *are* iteration.
22:40:26 <ski> Rc43 : informally, we read the `m -> s' as "`m' determines `s', given `MonadState s m'"
22:40:42 <Rc43> ski, ok, it's clear
22:40:51 <DanBurton> shachaf: given the operations "empty :: List a", "cons :: a -> List a -> List a", and "uncons :: List a -> Maybe (a, List a)" you can implement pretty much every operation on sequences. The problem, of course, is that implementing with only these primitives is very slow for some operations.
22:41:59 * ski wonders whether DanBurton has something like <http://srfi.schemers.org/srfi-101/srfi-101.html> in mind
22:42:26 <Jafet> Oh noes, we must describe everything in no more than one type class.
22:42:35 <DanBurton> ski: something like that.
22:43:18 <DanBurton> Jafet: Actually, so far I have about 4. the Empty typeclass, the Cons typeclass, the UnconsMay typeclass, and the List typeclass
22:43:43 <Jafet> All hail the new sequence hierarchy!
22:43:57 <DanBurton> Jafet: the question is, how to break up List into even more typeclasses, so that appropriate default implementations can be overridden conveniently
22:44:43 <shachaf> DanBurton: Why even use empty and cons?
22:45:08 <shachaf> uncons :: [a] -> Maybe (a,[a]) and cons :: Maybe (a,[a]) -> [a] are obviously inverses.
22:45:29 <Jafet> shachaf: to enable optimisations
22:45:32 <DanBurton> shachaf: so you're suggesting I combine "cons" and "empty"
22:45:36 <DanBurton> interesting
22:45:40 <shachaf> I'm not suggesting anything.
22:45:58 <shachaf> I wouldn't even make this type class if I were me.
22:46:00 <shachaf> Wait, I am me.
22:46:14 <DanBurton> well, you're *mentioning* a "cons" which is my "cons" and "empty" combined
22:46:16 * ski is suggesting `Monoid' and `singleton'
22:46:23 <shachaf> DanBurton: Yes.
22:47:01 <shachaf> Same as unfoldr :: (b -> Maybe (a,b)) -> b -> [a]; foldr :: (Maybe (a,b) -> b) -> [a] -> b
22:47:01 <DanBurton> ski: quite possibly a better idea than what I have so far.
22:49:00 <DanBurton> ski: but with only Monoid and Singleton, how do you do the equivalent of "uncons"?
22:49:21 <ski> @type GHC.Exts.build
22:49:21 <lambdabot> forall a. (forall b. (a -> b -> b) -> b -> b) -> [a]
22:49:23 <ski> @type flip (flip . foldr)
22:49:24 <lambdabot> forall b a. [a] -> (a -> b -> b) -> b -> b
22:49:48 <ski> DanBurton : yeah, some more is needed
22:50:28 <zzo38> Well, in my own idea of programming language (currently called Ibtlfmm, but it may change), all classes can automatically be split anywhere and combined anywhere; effectively they are already split and their combination is actually a type synonym, although it is actually slightly more compliciated than that, to do other things too
22:50:48 <ski> one alternative would be a `fold :: r -> (a -> r) -> (r -> r -> r) -> List a -> r' thing, that assumes it gets passed `zero' and `plus' operations satisfying monoid laws
22:51:26 <ski> preflex: rot13 Ibtlfmm
22:51:26 <preflex>  Vogyszz
22:51:44 <zzo38> ski: Try  map pred
22:52:11 <ski> @run map pred "Ibtlfmm"
22:52:12 <lambdabot>   "Haskell"
22:53:01 <DanBurton> Ibtlfmm is a rather...unpronounceable name
22:54:30 <DanBurton> zzo38: that sounds like a cool concept, but also potentially quite confusing
22:54:47 <zzo38> I thought of the slight similarity to "Iuckqlwviv Kjugobe", but "Ibtlfmm" is even more unpronounceable....... But still, it might be rename to something other than "Ibtlfmm" in future; it is not even complete first draft yet (is only partial so far).
22:54:56 <ski> zzo38 : hm, reminds me of classes in Clean (but may be more powerful)
22:55:36 <zzo38> DanBurton: OK, well, is not yet complete yet so it might change in future a little bit, possibly?
22:55:40 <Jafet> Haskell Extended Logic Language with a Pronounceable, Acronymic, Initialled Name
22:55:51 <Jafet> aka. Ibtlfmm
22:56:10 <zzo38> ski: O, OK. I don't know Clean but OK idea.
22:56:14 <DanBurton> Jafet: hell pain? o_O
22:56:43 <shachaf> > map succ "Haskell Extended Logic Language with a Pronounceable, Acronymic, Initialled Name"
22:56:44 <lambdabot>   "Ibtlfmm!Fyufoefe!Mphjd!Mbohvbhf!xjui!b!Qspopvodfbcmf-!Bdspoznjd-!Jojujbmmf...
22:56:46 <Jafet> What's hell pain? It shortens to Ibtlfmm.
22:57:09 <zzo38> DanBurton: Or else, "HELLwaPAIN" if preferred, I suppose... I prefer "HELLwaPAIN" over "hell pain" but still I will have "Ibtlfmm" as the current draft name.
22:58:06 * ski stares blankly
22:58:07 <shachaf> "wa" is "and" in Arabic.
22:58:08 <zzo38> Jafet: In what kind of shorten?
22:58:27 <zzo38> shachaf: OK. I didn't know that.
22:58:32 <DanBurton> My idea of a programming language is code named "Hype" - H for haskell, yp for "Python" ...except backwards... and "e" for...something.
22:59:11 <Jafet> 'e' is so 1990s, don't use it
22:59:45 <Eduard_Munteanu> e for esolang :P
22:59:47 <DanBurton> I have also contemplated "Hip", though I dislike it, since it reminds me of old people with bone problems
23:00:48 * ski . o O ( <http://strlen.com/amiga-e> )
23:01:16 * ski contemplated "Contagion"
23:02:21 <DanBurton> Data.Sequence is such a magical data structure.
23:06:10 <newbie12333> how do i ask for help in this room?
23:06:38 <ski> you just ask your question
23:08:42 <zzo38> newbie12333: Simply write in here what you need help with.
23:10:46 <DanBurton> newbie12333: if it involves more than, say, 2 lines of code, you can paste your code at http://hpaste.org/new/haskell
23:13:50 <DanBurton> ugh. I just had an ugly thought about using existentials. But it's not entirely ugly, which makes it tempting.
23:15:35 <DanBurton> never mind, it wouldn't work. So here's a question though:
23:15:42 <Shamanoid> ask away
23:15:59 <DanBurton> the Num typeclass has defaulting, and apparently so does Floating
23:16:04 <DanBurton> but no other typeclasses do?
23:16:19 <hpaste> newbie1212 pasted “Haskell Unfold” at http://hpaste.org/64426
23:16:26 <DanBurton> How hard would it be to extend GHC to allow defaulting for any typeclass?
23:16:56 <Jafet> GHC already has some extended defaulting
23:17:17 <Jafet> In GHCi, forall a. a is defaulted to ()
23:17:33 <DanBurton> but I want custom defaulting
23:17:42 <DanBurton> for my own typeclasses
23:17:54 <newbie12333> could anyone help me with the unfold question above?
23:18:04 <DanBurton> e.g. if I make "class MaybeC m where ..", I want it to default to Maybe
23:18:34 <DanBurton> newbie12333: a Pole is not a number, so using `div` 2 doesn't really make sense
23:18:49 <Jafet> Patches welcome
23:19:09 <newbie12333> k. so if i were to write a function to reduce the size of a given pole to 1/2 or 1/3, what do i have to do?
23:19:11 <Jafet> Well, it might cause problems for type inference.
23:19:29 <zzo38> For my own idea, if I put defaulting at all, they will all be custom defaulting. Using string literals, numeric literals, etc as values will be defined using macros that tells it what to do in those cases; although value of type of kind + can be written numeric literals always works same way, and a few other things like that
23:19:32 <DanBurton> How does it work for Num/Floating? Is it hacked on?
23:19:46 <DanBurton> newbie12333: do you have to use an unfold?
23:19:55 <Jafet> There are no problems with those because they aren't sufficiently polymorphic
23:19:59 <newbie12333> yes need to use unfold.
23:20:00 <zzo38> I also don't like that defaulting is only for specific classes and is built-in to program
23:20:16 <Jafet> For sufficiently polymorphic defaulting, there will invariably be problems
23:20:37 <Jafet> Eg. default (Foo a b) (Foo a (T a))
23:20:52 <newbie12333> apparantly, i have not been able to wrap my head around anamorphism.
23:20:55 <DanBurton> newbie12333: and I assume "unfold" is a function that was defined specifically for the Pole type? Can you paste the definition of that, too?
23:21:22 <newbie12333> oh, no, unfold - > the unfold function built in haskell -> prelude.
23:21:43 <DanBurton> newbie12333: that would be "unfoldr", but the problem is, that only works on lists.
23:22:07 <DanBurton> unless you're using a different Prelude
23:22:15 <zzo38> It look like your Pole type is like [()] type
23:22:19 <newbie12333> my bad.
23:22:20 <newbie12333> unfold :: (a -> Maybe a) -> a -> Pole
23:22:33 <newbie12333> unfold g z = case g z of Nothing -> Base ; Just z' -> Ext $ unfold g z'
23:22:44 <dobblego> [()] is natural numbers
23:22:53 <DanBurton> ahhhh that makes sense
23:22:54 * ski thinks newbie12333 probably needs to define a recursive function
23:22:58 <newbie12333> that would be my unfold function
23:23:02 <zzo38> dobblego: Yes I know how that works
23:23:04 <DanBurton> hence the attempt to use it as if it were a number
23:23:22 <Veinor> dobblego: itym lazy natural numbers
23:24:09 <zzo38> halve [] = []; halve (() : () : x) = () : halve x;
23:24:24 <newbie12333> that is not using unfold though.
23:24:51 <DanBurton> newbie12333: so the function you want to write is "halve :: Pole -> Pole"
23:24:57 <Jafet> What a whiner
23:25:32 <newbie12333> yeah. so i have other data that is defined. for instance -> oneFoot = Ext Base
23:25:34 <DanBurton> newbie12333: You'll probably want to write it as "halve = unfold someFunc" where someFunc :: (Pole -> Maybe Pole)
23:25:37 <zzo38> What exactly are you trying to unfold?
23:26:01 <newbie12333> Using unfold, define the function halve that reduces a flagpole to half its original height.
23:26:08 <DanBurton> newbie12333: you just have to think of the right function of type (Pole -> Maybe Pole) that will make it work
23:26:39 <shachaf> DanBurton: Why would unfold have that type?
23:26:57 <DanBurton> shachaf: his unfold is specialized to Poles
23:27:21 <DanBurton> shachaf: it's a significant simplification of unfoldr
23:27:40 <Jafet> The Polish unfold
23:27:48 <newbie12333> ;)
23:28:27 <DanBurton> newbie12333: in order to complete this task, you need to really understand the concept behind unfold. So tell me, what, conceptually, does your Polish unfold do?
23:28:29 <shachaf> Oh, newbie12333 gave a type for an unfold function.
23:28:45 <shachaf> newbie12333: Is this homework? You don't seem to know what you're trying to do.
23:29:08 <Jafet> You just answered your own question then
23:29:21 <newbie12333> its sort of a lab exercise. i've hit my head on the desk a couple of times
23:30:02 <newbie12333> shachaf - > thats why my name is newbie :). i m past 2 weeks with haskell.
23:30:12 * DanBurton has been operating under the assumption that this was homework, given the way the question was asked
23:30:12 <shachaf> Maybe that's why you're finding it difficult. Your head is one of the most important parts of solving a Haskell problem.
23:30:38 <DanBurton> newbie12333: welcome to Haskellism!
23:30:58 <newbie12333> Agreed. It looks like it would take years to get productive in this language, if at all.
23:31:23 <shachaf> I like that. "if at all".
23:31:40 <newbie12333> so given my situation -> I hear you that i am basically trying to use a div on a non-natural type.. i.e. not a Num type.
23:31:41 <DanBurton> newbie12333: nah, once you unlearn a few things, it's really quite simple to understand the basics of haskell
23:32:02 <DanBurton> newbie12333: also, you're using unfold completely wrong
23:32:04 <Jafet> It is sadly true. There are very few products using Haskell.
23:32:08 <newbie12333> o
23:32:34 <DanBurton> this is why I say you should think about unfold more. Try to explain how it works
23:32:59 <newbie12333> okie, let me look @ it again and use my brains. i like brain exercise.
23:32:59 * Sgeo hits Jafet with a few tuples
23:33:31 <DanBurton> @slap Sgeo
23:33:31 * lambdabot orders her trained monkeys to punch Sgeo
23:34:03 <shachaf> newbie12333: I think your confusion is much deeper than an answer to this problem could help with. You should go back to whatever introduction you were using and read about how types and functions work some more.
23:34:12 <Sgeo> Sadly, those trained monkeys are all using lazy I/O in a bad way. They won't punch me unless someone tries to look at my bruises.
23:34:24 * DanBurton looks
23:34:33 <Sgeo> Ow!
23:34:35 <shachaf> The bruises don't actually exist until Sgeo has been punched.
23:34:38 <shachaf> It's foolproof.
23:34:39 <LBuser23> @pl \x -> (f <$> g x)
23:34:39 <lambdabot> (f <$>) . g
23:34:54 <shachaf> (f <$>) <$> g
23:35:02 <Sgeo> Someone should tell Schrodinger that lazy I/O is contraindicated.
23:35:03 <Jafet> You're looking at bruises given to Sgeo months ago.
23:35:25 <DanBurton> shachaf: actually, the monkeys wrapped the new, soon-to-be-punched Sgeo in a thunk, making him unviewable until their job is done
23:35:56 <newbie12333> typically - fold -> reduce -> fold would take a function (so its called a higher order function) and apply it to a list of values. so if we have fold (double) [list of numbers]
23:36:07 <newbie12333> and if we have a double function defined, it would double the list of numbers..
23:36:32 <DanBurton> @type concat ((f <$>) <$> g)
23:36:33 <lambdabot>     No instance for (SimpleReflect.FromExpr [[a]])
23:36:33 <lambdabot>       arising from a use of `g' at <interactive>:1:20
23:36:33 <lambdabot>     Possible fix:
23:36:47 <DanBurton> @type \f g -> concat ((f <$>) <$> g)
23:36:48 <lambdabot> forall a a1. (a -> a1) -> [[a]] -> [a1]
23:37:42 <newbie12333> can anyone give me an example of unfold as we understand it? i always thought map is the opposeite of fold.
23:37:51 <newbie12333> but it looks like fold and unfold are the ones.
23:38:32 <DanBurton> newbie12333: fold takes a list, and "reduces" it to a "single value".
23:38:47 <DanBurton> newbie12333: unfold takes a seed, and "produces" a list out of it
23:38:59 <Eduard_Munteanu> newbie12333: no, you can write map in terms of folds but not the other way around.
23:38:59 <shachaf> Why is map the opposite of fold?
23:39:11 <shachaf> s/list/value of type T/
23:39:28 <shachaf> You can also write map in terms of unfolds!
23:39:32 <DanBurton> > let myMap f = foldr (f . (:)) [] in myMap (+1) [1,2,3]
23:39:33 <lambdabot>   No instance for (GHC.Num.Num [a])
23:39:33 <lambdabot>    arising from a use of `e_11123' at <in...
23:39:46 <shachaf> And given both folds and unfolds, you can write *anything*.
23:39:51 <DanBurton> whoops wrong way around
23:40:00 <DanBurton> > let myMap f = foldr ((:) . f) [] in myMap (+1) [1,2,3]
23:40:01 <newbie12333> so basically i solved my problem like this
23:40:01 <lambdabot>   [2,3,4]
23:40:17 <newbie12333> ok, i will wait until you post, DanBurton.
23:40:26 <DanBurton> newbie12333: no you go ahead
23:40:53 <newbie12333> so basically, i did a Integer -> Pole
23:41:08 <newbie12333> and in my function, whatever i did -> halve = unfold(\n -> if n > 0 then Just (n `div` 2) else Nothing) seem to work
23:42:22 <newbie12333> ok, i did it wrong. you go ahead DanBurton.
23:42:33 <DanBurton> newbie12333: that, I believe, would actually produce a pole of length log(n) where n is the length of the original
23:42:34 <newbie12333> sorry for interrupting.
23:42:51 <Eduard_Munteanu> You didn't interrupt anything :)
23:43:00 <newbie12333> thanks, you guys are nice!
23:43:02 <DanBurton> he interrupted my boredom
23:43:21 <Eduard_Munteanu> I'm not sure what Pole is, a Peano-like representation for the Integer?
23:43:43 <DanBurton> newbie12333: so going through integers is not the best way to do this. it could get the job done, but less learning would happen that way
23:44:22 <newbie12333> hmm. that is what. because i had my one foot pole defined and it would not take it.
23:45:13 <newbie12333> would work with integers -> its a little tricky [cheating] way.
23:46:12 <majuscule> I have a looping main function, and I want to call a function only if event A happens X amount of time after event B. How can I do this? What comes to mind is using a date function to store the current time and compare it, but I'm wondering if there's a simpler way
23:46:20 <hpaste> DanBurton annotated “Haskell Unfold” with “Haskell Unfold (annotation)” at http://hpaste.org/64426#a64427
23:47:20 <DanBurton> majuscule: if you are checking how much time passes between events A and B, then I can't think of a simpler way than capturing the time at each event and comparing.
23:47:47 <newbie12333> thank you DanBurton. I will read about some unfold to uncover it and get going with your path. :)
23:48:04 <Eduard_Munteanu> @hoogle getCPUTime
23:48:04 <lambdabot> System.CPUTime getCPUTime :: IO Integer
23:48:43 <DanBurton> majuscule: perhaps if you are dealing with multiple threads, when one event fires, it could disable something and set a timer to re-enable it after X amount of time
23:48:51 <Eduard_Munteanu> Erm, no. You probably want something that uses the "wall clock".
23:49:06 <DanBurton> @hoogle getCurrentTime
23:49:06 <lambdabot> Data.Time.Clock getCurrentTime :: IO UTCTime
23:49:06 <lambdabot> Data.Time.LocalTime getCurrentTimeZone :: IO TimeZone
23:49:52 <newbie12333> googled you. Leksah looks better than my gedit. emacs that i want to use have too much learning curve.
23:50:18 <majuscule> DanBurton: thank you again!
23:50:22 <majuscule> Eduard_Munteanu: thanks !
23:59:10 <DanBurton> whoa, didn't realize I'm still the latest on the Monad Tutorial timeline xD http://www.haskell.org/haskellwiki/Monad_tutorials_timeline#year_2011
23:59:16 <DanBurton> quick, someone write a monad tutorial
23:59:28 <zzo38> I have a question, if I have   http://hpaste.org/64428   and I want to parse the [[DictionaryEntry]] into (VerbID, ObjectInput, ObjectInput) even with these possibly complicated situations. How to do?
23:59:40 <shachaf> Quick, someone erase DanBurton's monad tutorial from history.
