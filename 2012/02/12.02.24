00:00:00 <elliott> wp lists kludge as primary spelling
00:00:01 <mekeor> JoeyA: ah
00:00:19 <elliott> Moral of the story: Never trust Eric S. Raymond.
00:00:28 <povman> http://catb.org/jargon/html/K/kludge.html
00:01:32 <povman> vim 'plugins' make me anxious
00:02:32 <povman> all editors are terrible
00:03:01 <povman> Vanity of vanities, saith the Preacher, vanity of vanities; all editors is vanity
00:20:12 <MaskRay> povman: vim may not be that bad
00:20:25 <srhb> xs >>= f for lists is simply concatmap with the exception that f must return a list?
00:20:55 <tikhonjelvis> MaskRay: That's quite an endorsement there
00:21:14 <opqdonut> srhb: no, it is _exactly_ concatMap
00:21:15 <opqdonut> :t concatMap
00:21:16 <lambdabot> forall a b. (a -> [b]) -> [a] -> [b]
00:21:27 <opqdonut> ^ see, f has type a -> [b], so it has to return a list
00:21:50 <MostAwesomeDude> :t >>=
00:21:51 <lambdabot> parse error on input `>>='
00:21:54 <opqdonut> @src [] (>>=)
00:21:54 <lambdabot> xs >>= f     = concatMap f xs
00:21:55 <MostAwesomeDude> :t (>>=)
00:21:56 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m a -> (a -> m b) -> m b
00:22:09 <ChristianS> actually, vim is the greatest editor ever (not that the topic belongs here)
00:22:23 <srhb> Ah, yes. Thanks.
00:23:08 <povman> MaskRay: I'm pretty proficient with it, i just hate the scripting language and how half the features are built-in and the other half are tacked on. I was going to try yi in the hope that these things could be unified but keep everything else good about vim.
00:23:10 <srhb> Just the argument are flipped. OK. :)
00:23:12 <MaskRay> tikhonjelvis: i switched from emacs since vim has better completion support with neocomplcache
00:24:00 <tikhonjelvis> I was just commenting on your strong language: "may not be that bad".
00:24:04 <osa1> what's a good way to debug haskell apps? in imperative style I was mostly printing some values to trace and debug the code
00:24:17 <srhb> osa1: Seems like a fair approach.
00:24:30 <opqdonut> quickcheck tests are great
00:24:41 <opqdonut> and the ghci debugger is powerful but somewhat hard to learn
00:24:44 <opqdonut> to use properly
00:25:02 <ion> (<$>) is like fmap but with the exception that the first parameter must be a function.
00:25:40 <osa1> srhb: but this time I have to wrap every values with IO (), and when I decide to remove debug prints remove that IO () again ..
00:25:51 <elliott> osa1: Debug.Trace?
00:25:58 <shachaf> ion: Quite the exception, that is.
00:26:01 <elliott> ion: wat
00:26:10 <Cale> osa1: Perhaps try splitting the code up into smaller definitions and testing them separately.
00:26:24 <elliott> oic
00:26:39 <Cale> If they produce the correct results independently, then they have to produce those same results in context.
00:26:42 <tikhonjelvis> In a lot of cases, you can just test individual functions easily in GHCi.
00:26:49 <Cale> yeah
00:27:05 <osa1> hmm, Debug.Trace looks good
00:27:20 <opqdonut> yeah I thought you meant Debug.Trace when you said "trace" earlier :)
00:27:30 <osa1> another question, which vim plugins are you using for haskell support
00:27:36 <srhb> Shim.
00:28:01 <MaskRay> povman: i agree with you partly, vimscript `just works' while emacs lisp is a bit awful and has expelled quite a few potential users i think
00:28:41 <srhb> MaskRay: On the other hand, vimscript is awful and has expelled quite a few potential users I think, while Emacs Lisp just works.
00:28:44 <Cale> I don't use anything special, just the built-in syntax highlighting, and some options in my .vimrc
00:28:54 <elliott> srhb: FSVO works.
00:29:00 <elliott> It's dynamically scoped, man.
00:29:06 <srhb> :-)
00:29:20 <srhb> Yeah, the dynamic scope is horrendous.
00:29:27 <elliott> osa1: A helpful pattern is "myFunc x | trace x False = undefined" -- at the top of your function definition.
00:29:31 <elliott> That'll trace any arguments that come in.
00:29:35 <tikhonjelvis> Eh, I don't mind the dynamic scoping.
00:29:36 <hpaste> Cale pasted “My .vimrc” at http://hpaste.org/64267
00:29:44 <elliott> You can get more elaborate, e.g. myFunc x y z | traceShow ("myFunc", x, y, z) False = undefined
00:29:50 <srhb> I was just making a point. ;)
00:29:55 <Cale> heh, the :GhciRange lines are actually broken
00:30:21 <MaskRay> povman: the amicable yet not well-designed language attacts many users to contribute their own plugins
00:30:27 <Cale> I did play around with some extensions before, but I haven't bothered reinstalling them
00:30:43 <srhb> Hmm. No "set hidden". Heretic!
00:31:27 <Cale> srhb: I don't even understand what the documentation for that option means
00:31:49 <elliott> http://dailyvim.blogspot.com/2009/04/set-hidden.html apparently.
00:32:09 <srhb> It lets you actually have buffers in the background for real.
00:32:35 <Cale> I never want buffers in the background
00:33:15 <Cale> If I have something open, I probably opened it because I want to look at and/or edit it, and there's no point in not having a tab or split for it :P
00:33:31 <srhb> Just goes to show how differently people use Vim. Without :bufdo and hidden buffers I'd be so very sad. :-)
00:34:01 <Cale> What do you use hidden buffers for?
00:34:17 <srhb> I never really close buffers ever.
00:34:19 <opqdonut> err, I have an lhs file and when I try to do "ghci file.lhs" it gives me a lexical error on a line that looks like this: '# Some text'
00:34:30 <Cale> I tend not to keep vim running very long at all
00:34:41 <Cale> It stays open as long as I have a file to edit
00:34:41 <opqdonut> wtf? shouldn't it be ignoring everything besides the lines marked with > ?
00:34:47 <Cale> and then I close it :P
00:34:55 <srhb> Cale: Yes, I've seen that paradigm. :-)
00:35:42 <Cale> srhb: What do you use :bufdo for?
00:35:50 <Cale> (I didn't know that command existed)
00:35:52 <opqdonut> oh, it's thinking the lines starting with # are preprocessor macros
00:35:55 <opqdonut> :D
00:36:13 <srhb> Cale: I tend to need to do changes over multiple files very often.
00:36:21 <srhb> Cale: Multiple SIMILAR files, I should say
00:36:27 <Cale> hmm, okay
00:36:34 <srhb> Cale: Defining a macro and running it across all buffers saves me hours of work
00:36:42 <opqdonut> hmm, it even fails with -XNoCPP
00:37:06 <elliott> opqdonut: cpp
00:37:08 <elliott> oh
00:37:14 <elliott> weird, are you sure?
00:37:20 <elliott> does the CPP in the file override that?
00:38:01 <Cale> I actually don't use many of the features of vim that aren't shared by most text editors. If you put me in front of something which can convert tabs to spaces automatically, I'll be pretty much fine.
00:38:15 <elliott> Cale: sed
00:38:17 <Cale> Syntax colouring is nice, but I don't really care that much
00:38:24 <elliott> sed
00:38:27 <Cale> heh
00:38:29 <elliott> (with syntax colouring library)
00:38:43 <srhb> Cale: Hehe, OK. The same for me really, except I need my text objects and modal editing. Everything else is (mostly) fluff.
00:39:26 <danr> Cale: M-x untabify in emacs ;)
00:39:27 <tikhonjelvis> Oh my. As an Emacs user, I am not sure I can use an editor with a finite amount of features :P
00:39:32 <opqdonut> elliott: I added whitespace so that no line begins with #, and it worked
00:40:02 <Cale> danr: (setq-default indent-tabs-mode nil)
00:40:24 <opqdonut> elliott: ahh, " (This is because ghc treats ‘#’ characters in column 1 as introducing line numbers.)"
00:40:27 <opqdonut> says pandoc's manual
00:40:32 <danr> untabify is if you have someone else's file written with tabs, of course!
00:40:34 <elliott> Cale: Consider using http://dd-sh.intercal.org.uk/ex1/.
00:40:36 <elliott> opqdonut: Ah.
00:40:50 <maus> Hi all. I'm trying to write a Yesod widget for displaying a list of words. I'm getting strange error message while compiling the template: http://pastebin.com/6XKtqQ0C
00:40:52 <mauke> The paste 6XKtqQ0C has been copied to http://hpaste.org/64268
00:40:55 <elliott> Cale: It has text replacement, so it should fit your requirement.
00:41:25 <srhb> Real programmers use...
00:41:54 <Eduard_Munteanu> Real programmers use.
00:42:06 <elliott> Real programmers us
00:42:11 <ion> > cycle "real programmers use "
00:42:12 <lambdabot>   "real programmers use real programmers use real programmers use real progra...
00:42:13 <Cale> I could probably get by, though to thwart your pedantry I should probably have made mouse support for selection and cursor positioning a requirement.
00:42:33 <elliott> Cale: You can't implement those with dd!
00:42:40 <elliott> OK, maybe with a /dev file.
00:43:06 <Cale> It has text replacement, but it doesn't appear to do it automatically either.
00:43:08 <srhb> I can see it now. A fully fledged modern text editor implemented only with dd and an intricate shell script to string everything together
00:43:09 <elliott> Also you'd need, like, actual visual display for that.
00:43:16 <Cale> I want spaces to be inserted when I press tab
00:43:17 <elliott> dd-ex is too hardcore for that.
00:43:34 <elliott> Cale: Rewire your keyboard.
00:43:35 <srhb> Maybe lift the requirements a bit. Allow cat
00:43:37 <ion> You could plot stuff to graphics memory with dd of=/dev/mem.
00:43:49 <elliott> Or have a little robot that watches for you pressing tab and presses backspace + 4 spaces every time.
00:43:51 <Cale> srhb: extra requirement, it must consist of a single long shell pipeline
00:43:57 <srhb> Cale: :D
00:44:18 <srhb> "See what UNIX can do!!111@
00:44:27 <srhb> <eveverything explodes>
00:44:53 <Cale> I once wrote an IRC bot for evaluating Mathematica expressions as a single long shell pipeline.
00:45:19 <ion> cale: URL?
00:45:25 <Cale> Using netcat, and a fifo to tie the loop together
00:45:42 <Cale> I'm not sure I have the code for it still...
00:46:56 <geekosaur> extra credit, bash and zsh both have tcp functions built into the shell (well, in zsh's case it's an extension module) :)
00:47:48 <Cale> Yeah, it's probably on my old machine with the failing hard drive.
00:50:31 <Cale> It was basically a whole bunch of grep and sed munging of the input (read from fifo) to put it in a suitable form for the commandline version of mathematica and do some cursory checks to try to prevent abuse, and then some more junk to process the output of that into a suitable form to write back to IRC, piped into netcat, whose output was written to the fifo
00:51:34 <srhb> Sounds both beautiful and terrifying.
00:52:58 <Cale> The processing required was cut down a bit by the fact that mathematica can be told to print to stderr :)
00:53:09 <ion> hah
00:59:38 <ChristianS> unix pipes are a quite acceptable functional programming language -- provided you can live with the limitations that each function can only take one parameter and that all your parameters are strings
01:00:28 <Cale> ChristianS: indeed
01:00:49 <merijn> ChristianS: I've actually been thinking about implementing my own shell to work around that (the single parameter thing, I don't think type values are that desirable in a shell)
01:01:47 <Cale> I think typed values would be quite nice, but you can't really half ass them, and so it would take a complete revision of everything to actually make that nice to use.
01:01:55 <tikhonjelvis> There's always eshell :)
01:02:23 <merijn> Cale: I've used powershell for a bit, that has typed values. The problem is: you're restricted to using them in ways anticipated by whomever defined the values
01:02:33 <merijn> Using the differently takes quite a bit of work
01:02:34 <elliott> (Does the same objection not apply to Haskell?)
01:02:53 <merijn> And of course you are forced to implement all required operations before something is minimally useful
01:03:00 <Cale> merijn: I'm thinking something like having all the programs have types in Haskell's type system :)
01:03:26 <merijn> elliott: I don't think so, because my shell commands are usually *a lot* more ad hoc than my haskell code (or really code in any language)
01:04:42 <merijn> Sometimes (often?) it's just faster to through a couple of grep's and sed's in a row instead of writing something to properly parse your data
01:05:06 <ChristianS> indeed
01:05:19 <merijn> s/through/throw
01:05:26 <merijn> wtf was my mind thinking there? >.>
01:06:09 <Cale> merijn: Though if your data could be provided in a structure where it didn't need to be parsed, that would be quite nice :)
01:06:35 <Cale> (and it only requires rewriting all the programs ever to make that happen ;)
01:06:57 <imc> just use emacs :)
01:07:16 <imc> (and i'm a vimmer...)
01:07:18 <merijn> Cale: Hence, my point that stuff like powershell's typed data is nice iff you only use data in anticipated ways
01:11:37 <osa1> what does being boxed mean in data structures? (I saw it in vector module)
01:12:05 <OpensHell> it's the default, it means that the field is lazy just as you would expect
01:12:29 <elliott> osa1: it means the data is stored as a pointer rather than directly inline inside the structure
01:16:18 <Cale> osa1: You might have noticed that you can store any type of values in a list, say, and apply polymorphic functions like map to apply functions across the entire list. The way that works is not by compiling a separate copy of the map function for every type that you use it at, but by making sure that all the values look the same way in memory.
01:16:38 <Cale> osa1: (at least in GHC's implementation, and there are good reasons why that other scheme wouldn't work out so well)
01:17:42 <Cale> osa1: The uniform representation that GHC uses is that all (boxed) values are pointers to code. (and the code will either compute the value, the first time you need it, or immediately return the computed value if it's already been computed)
01:18:05 <tikhonjelvis> It's like Integer vs int in Java, if you're familiar with Java.
01:18:32 <tikhonjelvis> I mean, it's like that regardless of how familiar you are with Java, but my comment would only help you if you were.
01:18:51 <Cale> By contrast, unboxed values have different sizes in memory, and so require special treatment. Polymorphism doesn't work on unboxed values, and neither does lazy evaluation.
01:19:52 <Cale> As for the consideration that you might compile different versions of a polymorphic function for each of the types it's applied at, consider something like...
01:22:12 <ion> ACTION likes nested ACTION commands
01:22:25 <Cale> > let f :: (Show a) => Integer -> a -> String; f 0 x = show x; f n x = f (n-1) (x,x) in [f k () | k <- [0..]]
01:22:26 <lambdabot>   ["()","((),())","(((),()),((),()))","((((),()),((),())),(((),()),((),())))"...
01:22:28 <ion> Meh, WeeChat stripped the \x01s away.
01:22:39 <osa1> Cale: tikhonjelvis: it helped a lot, thanks. so when are unboxed structures useful?
01:22:46 <tikhonjelvis> ion: I saw some s. I have no idea what they signify though.
01:22:48 <OpensHell> performance!
01:22:50 <Cale> osa1: When you want to be really space efficient
01:22:50 <ion> Meh 2, wrong channel.
01:23:03 <OpensHell> less indirection, less memory usage
01:23:27 <merijn> Also, if you want to avoid laziness for space reasons
01:23:34 <tikhonjelvis> locality
01:24:16 <osa1> being boxed/unboxed is not related with being mutable/immutable, right?
01:24:19 <Cale> right
01:24:20 <merijn> tikhonjelvis: Does that really help? Considering how little haskell lets you control locality?
01:24:46 <Cale> There are both boxed and unboxed versions of both mutable and immutable arrays :)
01:25:04 <Cale> Array is immutable boxed
01:25:10 <tikhonjelvis> I imagine if you're doing some operation on arrays it would help.
01:25:11 <Cale> UArray is immutable unboxed
01:25:23 <Cale> IOArray is mutable boxed
01:25:39 <elliott> IOUArray is an array of debts.
01:25:52 <Cale> hehe
01:25:56 <ion> :-)
01:26:08 <Cale> yeah, IOUArray is the mutable unboxed one :)
01:26:47 <merijn> Supposing I want to work with mutable global state I might as well use TVar's rather than IORef's and worrying about locking, right?
01:26:50 <ion> @remember elliott <Cale> Array is immutable boxed  <Cale> UArray is immutable unboxed  <Cale> IOArray is mutable boxed  <elliott> IOUArray is an array of debts.
01:26:50 <lambdabot> Nice!
01:27:13 <danr> elliott: ^^
01:27:36 <Cale> merijn: If you're working from multiple threads, it might be preferable.
01:27:49 <Cale> merijn: You might also want to consider if MVars would be enough
01:27:56 <t7> Whats a good project idea, i wanna play with STM
01:28:15 <elliott> "what's a good project" --> http://prog21.dadgum.com/80.html
01:28:25 <merijn> Cale: Yeah, I'm just checking whether I didn't massively misunderstand the proper use case of TVar's :p
01:28:54 <Cale> merijn: I usually don't use *global* state in the sense of unsafePerformIO'ing things
01:29:12 <t7> maybe a project idea generator :S
01:29:22 <t7> concurrent ofcorse
01:29:50 <merijn> t7: Structural editor, xmonad implementation for OSX's native GUI, interactive shell with haskell/ghci support?
01:30:08 <Cale> merijn: But instead, what I'll tend to do is pre-apply  readIORef/writeIORef  or another pair of accessors accordingly, and then I can pass the resulting things around to the bits of code which need access to that piece of state.
01:30:12 <tikhonjelvis> OS X even has X in its name. Why would you want anything else?
01:30:43 <merijn> tikhonjelvis: Because most OSX programs don't use X? This includes the open source ones...
01:31:04 <tikhonjelvis> I was being facetious
01:31:17 <merijn> Cale: Well, I wasn't really thinking of truly global, but in the context of accessible to multiple/most threads
01:31:22 <Cale> merijn: This has a couple advantages... I've occasionally found that I want to introduce other semantics to updating the state, and switching from IORef to MVar/Chan/SampleVar/TVar etc. gives all sorts of other behaviours without changing the interface of anything.
01:31:41 <Cale> and of course, I can stick in things like logging pretty easily
01:32:19 <merijn> Cale: Sometimes I think I'm worrying to much about being functional with my ideas, getting in the way of actually implementing stuff
01:32:45 <t7> im really bummed out that data parallel programming didnt seem to work with haskell (by work i mean run fast)
01:32:47 <Cale> and the other advantage is that I can control read and write permissions basically, by only passing the read end to the part of the program which is supposed to be reading
01:32:48 <merijn> I guess the solution would be to say "fuck it" and start implementing everything in IO, just to get it done. Before worrying about functionalness
01:33:02 <merijn> t7: Did you look at Data Parallel Haskell?
01:33:09 <Cale> merijn: Well, you can do that, and be a bit functional about it, like this :)
01:33:14 <elliott> (also repa)
01:33:19 <t7> yeah i seen spj talk about it a few times
01:33:23 <merijn> I think they were also working on neat things like compiling to CUDA
01:33:36 <Cale> t7: It's getting there, gradually :)
01:33:46 <t7> well he said "after 3 years it didnt work"
01:33:54 <Cale> t7: It's supposed to be "usable" in 7.4.1, but I haven't had a chance to try it yet.
01:34:01 <merijn> Cale: Yeah, but I think I worry to much about functional perfectionism rather than getting things done. While it's probably best to err on the side of "getting things done"
01:34:16 <Cale> It's not yet as fast as they'd like it to be, but it's supposed to actually work.
01:34:33 <Cale> merijn: I am the same way
01:34:59 <Cale> merijn: I tend to sit and think about things for probably too long, and be overly cautious.
01:35:08 <tikhonjelvis> At least some of the time, a bit of worrying now will save you time where a bit of "getting things done" would mire you in complications shortly.
01:35:16 <Cale> Usually it doesn't hurt quite so badly to throw away code and redo it though.
01:35:28 <Cale> So I really need to lose that habit to some extent.
01:35:35 <Cale> yeah
01:35:46 <Cale> It *is* a reasonable approach too.
01:36:08 <Cale> To just sit back for a while and think about your program for a long time, and then write it all out at once.
01:36:18 <merijn> tikhonjelvis: Sure, but you can always stop and think when you hit complications
01:36:22 <t7> you guys should write a really minimal haskell compiler in haskell
01:36:38 <merijn> Whereas if you start with thinking you can potentially never hit a point where you start writing
01:36:41 <t7> with modularity like clang
01:36:58 <merijn> t7: What would this modularity accomplish?
01:37:02 <t7> for testing out new features
01:37:16 <OpensHell> t7: like UHC?
01:37:19 <t7> and easy intergration into vim and emacs yadda yaddy ya
01:37:24 <merijn> That already exists? Just look at the number of feature pragmas available
01:37:26 <OpensHell> not really "minimal"
01:37:32 <Cale> GHC has a lot of forms of modularity, but a good deal of the code is still scary
01:37:48 <merijn> Cale: Yes, but how unscary can you make a production compiler
01:38:08 <OpensHell> but it's designed to experiment with new language features
01:38:10 <Jafet> A minimalistic compiler will not be used for anything important, and therefore will not be useful for testing new features.
01:38:15 <Cale> I wonder if GHC still has any monads in it which don't use the Monad class :)
01:38:32 <Jafet> Most of GHC is mandatory to what it does
01:38:35 <Cale> It did for quite a while at least
01:39:02 <Cale> (not for any reason other than the fact that the code was written before the Monad class existed :)
02:08:26 <anoob> I am using GHCi. I type x = 2 and get a parse error on input '='
02:08:32 <anoob> why :)
02:08:40 <tikhonjelvis> You need to type let x = 2
02:08:48 <tikhonjelvis> because it's GHCi
02:09:07 <anoob> tikhonjelvis: OK :)
02:09:20 <anoob> i will do that#
02:09:41 <anoob> it works
02:09:47 <tikhonjelvis> The upcoming version of GHCi will let you just type x = 2.
02:10:09 <keep_learning> anoob, you can post your code at http://hpaste.org/
02:10:12 <anoob> nice
02:10:13 <LtWorf> tikhonjelvis: that's good news!
02:10:22 <elliott> tikhonjelvis: Are you sure?
02:10:30 <elliott> I thought the top-level decl support omitted that.
02:10:30 <tikhonjelvis> That's what I've heard.
02:10:43 <tikhonjelvis> I've been too lazy to build it myself though.
02:10:47 <elliott> Just tested. It doesn't.
02:10:52 <srhb> I thought so too. Daw, how sad.
02:10:55 <elliott> Also, it's not really "upcoming", GHC 7.4.1 has been out for weeks :)
02:11:17 <srhb> Is there an official plan for when GHC 7.4.1 is packaged in a Haskell Platform?
02:11:18 <tikhonjelvis> Well, it's "upcoming" for people who don't have it yet, like me :)
02:11:21 <anoob> having to say let is just asking too much for a programmer
02:11:27 <srhb> anoob: It is.
02:11:38 <srhb> It makes me feel... camly. ;_;
02:11:47 <tikhonjelvis> anoob: You could write your functions in a file and load them into GHCi.
02:11:52 <keep_learning> anoob,  sorry I did not i in GHCi :)
02:13:00 <elliott> I use Emacs for my GHCi experiments.
02:13:07 <elliott> Using a scrap file for definitions is really convenient.
02:13:10 <elliott> Especially since I can see them at a glance.
02:13:21 <tikhonjelvis> I have a string of scrap files.
02:13:39 <tikhonjelvis> When one stops compiling but I don't care enough to fix it, I just start another one...
02:13:43 <tikhonjelvis> Maybe I am too lazy.
02:13:45 <elliott> haha
02:13:56 <elliott> I start a new file for each thing.
02:15:52 <anoob> i just download ghci
02:16:17 <tikhonjelvis> I should garbage collect some of the old files I'm not using any more.
02:16:23 <anoob> i will try to leanr it
02:16:28 <anoob> learn
02:17:04 <elliott> lpsmith: wouldn't "foldr (\x xs -> element x `mappend` xs) mempty" be better as "mconcat . map element"?
02:17:41 <lpsmith> elliott, yeah
02:17:59 <lpsmith> I have a bias towards writing things as right folds without thinking
02:18:02 <elliott> oh, maybe that wouldn't be a good producer thingybob...
02:18:05 <elliott> because mconcat is a class method
02:18:08 <ion> anoob: Generally if you have “x = 2” in Haskell code, everything in the same scope above and below the definition sees it. That doesn’t quite fit GHCi’s sequential behavior. But yeah, they’re making it behave like “let” apparently.
02:18:11 <elliott> although its default implementation is with foldr
02:18:20 <lpsmith> elliott, no, it should still be a good producer
02:18:28 <elliott> *consumer, I think
02:18:36 <ion> @type mconcat . map ?element
02:18:37 <lambdabot> forall a a1. (Monoid a, ?element::a1 -> a) => [a1] -> a
02:18:37 <lpsmith> though actually getting it to fuse might be more fragile
02:18:38 <ion> @type foldMap ?element
02:18:39 <lambdabot> Not in scope: `foldMap'
02:18:44 <ion> @type Data.Foldable.foldMap ?element
02:18:45 <lambdabot> forall a m (t :: * -> *). (?element::a -> m, Data.Foldable.Foldable t, Monoid m) => t a -> m
02:19:07 <elliott> what ion said :P
02:19:33 <lpsmith> But I'm not sure how often it fuses at the moment anyway,  actually,  I should add an INLINE pragma.
02:20:18 <elliott> hmm, so how is mconcat a good producer if it's a class method?
02:20:37 <lpsmith> because it's a foldr
02:20:44 <lpsmith> class methods are a different issue
02:20:57 <lpsmith> Now, to get it to fuse the class method will need to be inlined
02:20:57 <keep_learning> Could some one please tell me how to install a library from HEAD. I am trying to install dph-examples from HEAD. I used git clone https://github.com/ghc/packages-dph
02:21:03 <elliott> mconcat is not a foldr necessarily
02:21:05 <elliott> @src Monoid
02:21:05 <lambdabot> class Monoid a where
02:21:05 <lambdabot>     mempty  :: a
02:21:05 <lambdabot>     mappend :: a -> a -> a
02:21:05 <lambdabot>     mconcat :: [a] -> a
02:21:08 <lpsmith> which also implies that you will need to have a specific-enough type
02:21:09 <keep_learning> and inside dph-examples folder
02:21:15 <elliott> and mconcat has a default implementation as foldr mappend mempty
02:21:19 <keep_learning> i run cabal configure and cabal build
02:21:22 <ion> keep_learning: cd to the directory, cabal install
02:21:23 <elliott> but yes, OK, if the instance is available it should work
02:21:46 <lpsmith> right, but to actually fuse you need the foldr inlined :)
02:22:05 <lpsmith> which might not happen because of class-polymorphism.  At that point you need a specialize, at least.
02:22:33 <lpsmith> but it's still a good producer.  =)
02:22:42 <keep_learning> ion, thank you
02:24:07 <lpsmith> so yeah, that's why i wrote it as a foldr,  so hopefully things happen as they need in order for fusion to actually happen more often.
02:24:25 <lpsmith> though maybe that's a superstition on my part, I dunno
02:24:48 <lpsmith> but also,  I often think of foldr before a lot of other solutions
02:26:03 <elliott> I tend to think of foldrs before recursive solutions, I think.
02:26:40 <ion> foldMap also defaults to a foldr (a Prelude.foldr in the case of lists), but i don’t know whether it gets inlined automatically or not.
02:27:15 <elliott> lpsmith: I note that you could allow the same instance code to also be used to produce values of a "generic structure" by maintaining an Aeson.Value field in Json or such, that's evaluated lazy so that the computational effort is only spent ifi t's used,
02:27:18 <elliott> *if it's used.
02:27:21 <elliott> Dunno if that would be worthwhile.
02:28:31 <lpsmith> Yeah, that statement doesn't make sense to me,  you'd have to clarify what you are thinking.
02:29:00 <elliott> lpsmith: well (simplifying) you have "newtype Json = Json Builder" right now, and you build it up with combinators.
02:29:12 <lpsmith> right
02:29:29 <elliott> Say we wanted to give the optional ability to also recover the equivalent of an aeson Value (i.e. generic JSON type) from these Json values, without changing instances or sacrificing efficiency.
02:29:48 <lpsmith> But like, seriously,  some novice asked a simple question with a simple answer in reddit a while ago,  and literally my first thought wasn't all or whatever,  it was foldr.
02:29:57 <elliott> You could define "data Json = Json {-# UNPACK #-} !Builder GenericValue". All the combinators would build up a GenericValue in the obvious manner.
02:30:07 <elliott> that way, the only cost you pay is some pointers and thunks
02:30:13 <elliott> and the GenericValue is only computed if you actually evaluate it
02:30:31 <elliott> the Builder becomes essentially an optimised "cached" serialisation of the GenericValue constructed at the same time as it
02:30:32 <c_wraith> don't underestimate the cost of thunks, though
02:30:46 <lpsmith> you can't unpack a builder :)
02:30:52 <elliott> c_wraith: oh, yes, certainly, it'd need measuring
02:30:57 <elliott> lpsmith: why not?
02:31:03 <c_wraith> it's a function
02:31:11 <elliott> ah
02:31:21 <elliott> right, omit the unpack then :)
02:31:36 <elliott> anyway, it's just an idea, since then it'd have the full semantic power of aeson
02:31:36 <lpsmith> but yeah, I was actually thinking about that very idea a little bit when writing the post.  Though a different implementation
02:31:44 <elliott> while maintaining the speed
02:31:46 <lpsmith> although I wasn't thinking about implementation too much
02:31:46 <elliott> (mostly)
02:32:18 <elliott> lpsmith: the nicer way would be to abstract the "JSON type" with a typeclass full of combinators... so that you could plug in BuilderBasedJson or GenericJson or whatever
02:32:24 <elliott> but that might end up having more overhead
02:32:30 <elliott> and is probably overkill :P
02:32:44 <lpsmith> that might be a little trixsy though,  with my combinators and getting say a Vector out instead of a json syntax
02:33:04 <elliott> yes, well, small matter of programming and so on
02:33:13 <elliott> i'm here to give vague ideas :)
02:33:20 <lpsmith> well, if you want to play around with it,  by all means
02:33:39 <lpsmith> I've actually stumbled across a vaguely similar problem in postgresql-simple this week
02:33:44 <elliott> i might, don't know if i'll have the time to
02:35:02 <lpsmith> ozgun ataman made a nice suggestion that's going to really going to change and break some things in version 0.1
02:35:18 <lpsmith> in the way that QueryResults are converted
02:35:29 <lpsmith> better api,  faster,
02:36:00 <lpsmith> so I tried to figure out how to maintain backwards and forwards compatibility, and I couldn't quite figure out a sane way to do it
02:36:28 <elliott> backwards compatibility? this is haskell!
02:36:46 <elliott> if we can break every program that uses Eq/Show constraints from Num constraints... :)
02:37:12 <rostayob> backwards compatibility is for the weak
02:37:14 <lpsmith> I say we boycott <>
02:37:45 <elliott> lpsmith: ooh, what are our demands? I propose: Applicative superclass for Monad
02:38:01 <lpsmith> alway import hiding <>, even if you don't use any other <> anywhere else in your program.   Even if you define it yourself :-P
02:38:08 <lpsmith> I tend to redefine ++ though
02:38:11 <OpensHell1> <> = mappend?
02:38:14 <lpsmith> yes
02:38:17 <OpensHell1> ugh
02:38:18 <OpensHell1> why not ++
02:38:30 <t7> lets all switch to agda
02:38:44 <elliott> Let's not.
02:39:00 <t7> who needs type classes anyway mirite
02:39:01 <rostayob> t7: agda and haskell are different lol
02:39:17 <lpsmith> yeah, that ain't happening.   I'd love to learn agda,  but I hardly have the time.   But that said,  no way in hell my real-world projects are getting anywhere close to adga anytime soon;
02:39:45 <rostayob> right now you can't use agda in the real world
02:39:45 <tikhonjelvis> lpsmith: I've heard that exact exuse for disregarding Haskell :)
02:39:49 <rostayob> imho
02:39:58 <rostayob> tikhonjelvis: agda is completely different
02:40:01 <elliott> <lpsmith> yeah, that ain't happening.   I'd love to learn haskell,  but I hardly have the time.   But that said,  no way in hell my real-world projects are getting anywhere close to haskell anytime soon;  <rostayob> right now you can't use haskell in the real world
02:40:03 <elliott> tikhonjelvis: ha, snap
02:40:04 <merijn> rostayob: edwardk and the one other "commercial users Agda" disagree ;)
02:40:10 <t7> i actually prefer coq to agda *ducks*
02:40:15 <rostayob> merijn: link?
02:40:37 <rostayob> you might want to write parts of your program in agda, maybe
02:40:43 <rostayob> and then integrate that in haskell code
02:41:10 <lpsmith> elliot,  and for many real world purposes,  Haskell was not viable when I started learning Haskell :-P
02:41:20 <lpsmith> That changed sometime in the last 5 or 6 years.
02:41:24 <OpensHell1> a big part of my liking haskell is its performance, how is agda's? (yes, i know, langauges don't have performance)
02:41:34 <lpsmith> Or rather,  Haskell reached a tipping point in that respect
02:41:41 <merijn> rostayob: I saw a quote in some completely unverified location of someone saying "oh, so you're the one other commercial user of Agda!" to edwardk, but I can't seem to find it right now :\
02:41:46 <t7> OpensHell1: you dont run agda programs
02:41:51 <t7> just compile them
02:41:51 <lpsmith> (I mean,  it's always gradual improvement, making the potential real-world uses bigger.)
02:41:51 <rostayob> merijn: it was probably a joke...
02:41:53 <Jafet> The agda compiler is reasonably fast
02:42:09 <OpensHell1> i care more about performance of generated programs
02:42:17 <merijn> rostayob: I know, I was trying to be funny too. But it seems I have failed
02:42:22 <elliott> Agda programs used to use Peano naturals I think.
02:42:23 <rostayob> it's not that much about performance, for one with agda to do IO you *have* to go through the FFI
02:42:24 <elliott> Probably that has changed now.
02:42:32 <elliott> Or else I doubt the programs people have written would work :)
02:42:34 <rostayob> so interfacing with the real world must be done with Haskell
02:42:42 <rostayob> elliott: they are compiled natively
02:42:44 <elliott> rostayob: the standard library has IO though...
02:42:46 <rostayob> or they can be anyways
02:42:52 <rostayob> elliott: it's just a few haskell functions
02:42:53 <elliott> perhaps not enough
02:42:53 <elliott> right
02:43:34 <rostayob> Jafet: is it really? I thought that MAlonzo confused GHC a lot with all those coerces
02:44:00 <elliott> I think there might be a commercial user of Agda.
02:44:04 <elliott> But that's just a vague recognition.
02:44:42 <rostayob> I mean I can imagine total programming languages to be useful in some settings
02:44:44 <rostayob> but agda is just not mature enough, imho
02:44:50 <rostayob> and the focus of the community seem to be towards theorem proving anyways
02:45:00 <lpsmith> oh, there's commerical use for anything
02:45:04 <lpsmith> almost anything
02:45:05 <elliott> I wouldn't say that's true, what with the web framework, FRP stuff...
02:45:11 <OpensHell1> so agda is better at avoiding success than haskell?
02:45:12 <aristid> rostayob: probably because it can be reasonably be used for that right now.
02:45:21 <OpensHell1> interesting.
02:45:28 <lpsmith> the question is,  how generally useful is the technology in a commercial setting
02:45:31 <aristid> OpensHell1: much better
02:45:32 <rostayob> aristid: yes but it's a vicious circle then :D
02:45:46 <aristid> rostayob: why, is theorem proving a bad thing? :)
02:45:51 <elliott> OpensHell1: So's INTERCAL.
02:45:52 <lpsmith> it's all about the particulars of what you are trying to do.
02:45:52 <rostayob> aristid: no, absolutely
02:46:02 <rostayob> aristid: but agda started with the idea of being viable as a programming language as well
02:46:23 <DanBurton> are there mathematical symbols for "max" and "min"?
02:46:52 <tikhonjelvis> I've only ever seen them as max/min, but sometimes with weird brackets.
02:46:54 <rostayob> DanBurton: apl uses the ceil operators
02:46:58 <tikhonjelvis> I'm hardly a mathematician though.
02:47:00 <OpensHell1> DanBurton: yes, arrows
02:47:01 <rostayob> can't type them here
02:47:04 <OpensHell1> \uparrow \downarrow
02:47:17 <tikhonjelvis> ↑ ↓?
02:47:21 <OpensHell1> yes
02:47:24 <OpensHell1> Dijkstra used them iirc
02:47:27 <lpsmith> stepcut's implemented an irc bot in agda
02:47:37 <aristid> DanBurton: agda uses ⊔ for max and ⊓ for min
02:47:57 <DanBurton> do you write the arrows infix? like 3 ↑ 4
02:48:02 <OpensHell1> DanBurton: yes
02:48:09 <rostayob> lpsmith: I'm not saying you can't do that. I'm just not sure you want to do that in the end
02:48:16 <OpensHell1> but the operators from lattice theory are also fine
02:48:19 <OpensHell1> join / meet
02:48:22 <rostayob> when you actually have to ship a product
02:48:25 <aristid> wait, i copied them the wrong way round
02:48:29 <lpsmith> Though,  my question is can you let the IRC bot run indefinitely without running out of memory?   Last I heard (and granted I'm not an agda expert and things _may_ have changed)  the answer was no
02:48:34 <harlekin> Hello. I am looking at the vect package, namely the module Data.Vect.Float.Base. I can clearly see that there is an Eq Vec3 instance exposed on Hackage, but when I try to test Vec3 0 0 0 == Vec3 0 0 0 in ghc, it says there is no Eq instance declaration. Why is that?
02:48:37 <lpsmith> rostayob, yes, exactly
02:48:56 <elliott> harlekin: what evrsion of vect do you have?
02:48:59 <rostayob> DanBurton: APL uses ⌈ and ⌊
02:49:03 <elliott> is it the version you're looking at the documentation for?
02:49:08 <DanBurton> oh boy Lattices. I need to include those too; I'm making a sexier Prelude
02:49:08 <lpsmith> Also,  GHC has a pretty nice I/O manager at this point,  agda on the other hand...
02:49:32 <elliott> Memory leaks and bad IO didn't stop Ruby.
02:49:42 <harlekin> elliott: 0.4.7. Yes, it is.
02:49:45 <aristid> rostayob: what i think might be feasible... before you can start developing the product, sometimes you might want to understand the basic ideas better, ideas about the basic data structures of the program and such, and something like agda might help with that :)
02:49:45 <lpsmith> hah!
02:49:45 <rostayob> elliott: bad IO is different from nonexistant IO
02:49:58 <tikhonjelvis> I suspect the Ruby demographic and the Agda demographic do not overlap too much.
02:50:04 <elliott> tikhonjelvis: WE CAN FIX THAT.
02:50:09 <tikhonjelvis> But maybe I'm too critical of Ruby...
02:50:12 <elliott> It's the only way to ensure Agda doesn't kill Haskell.
02:50:24 <tikhonjelvis> Channelling Ruby programmers into it?
02:50:28 <aristid> tikhonjelvis: there is one guy in #agda who's a ruby programmer
02:50:30 <rostayob> aristid: I personally think that a tool like gda is totally useless to ship a product :P
02:50:31 <elliott> *ahem* I'm hiring Agda ninja rockstars.
02:50:32 <rostayob> right now anyways
02:50:41 <rostayob> tikhonjelvis: yeah, larrytheliquid is a ruby programmer
02:50:44 <elliott> Also we're going to use node.js for something. I don't know what, but I need to include it.
02:51:01 <aristid> rostayob: i'm not talking about shipping. i'm talking about understanding the problem better :)
02:51:05 <elliott> Don't know Agda? No problem! It's like Ruby, but faster.
02:51:12 <lpsmith> copumpkin was a ruby programmer before he was a Haskell programmer
02:51:13 <tikhonjelvis> elliott: You must have a NoSQL database!
02:51:17 <elliott> Also, it has Unicode. You like Unicode, right?
02:51:24 <elliott> tikhonjelvis: Yes! Indeed! Agda has support for talking to no SQL database.
02:51:28 <lpsmith> now copumpkin is an adga programmer :-P
02:51:28 <elliott> That is, there are no SQL databases it can talk to.
02:51:35 <rostayob> aristid: I'm pretty sure that wouldn't help the vast majority of programmers
02:51:48 <aristid> rostayob: probably not *shrug*. some of them tho.
02:51:57 <lpsmith> all hail copumpkin!
02:52:11 <mm_freak_> does anyone else making the experience that -fno-cse is a healthy flag?
02:52:14 <aristid> and hail his evil twin pumpkin, too
02:52:15 <elliott> Also, it's way beyond Web 2.0. It's Web S (S (S Z))).
02:52:20 <elliott> (Floating point support not yet implemented.)
02:52:22 <mm_freak_> CSE causes space leaks all the time for me
02:52:28 <elliott> mm_freak_: bugreport?
02:52:32 <tikhonjelvis> Bah, floating point numbers are overrated anyhow.
02:52:41 <mm_freak_> elliott: for 7.0.3?
02:52:44 <aristid> peano naturals is where it's at
02:52:55 <tikhonjelvis> So are negative numbers.
02:53:00 <elliott> mm_freak_: well, sure, if someone else will test it
02:53:14 <aristid> tikhonjelvis: rationals and fixed-point decimals are overrated, too
02:53:26 <OpensHell1> rationals are fairly useful
02:53:38 <mm_freak_> elliott: first let me see whether it happens in newer versions
02:53:49 <OpensHell1> the real numbers? too continuous for me
02:54:17 <tikhonjelvis> Pfft, real numbers have no place in the read world anyhow.
02:54:23 <tikhonjelvis> real world**
02:54:40 <mm_freak_> but in any case, i'm happy to report that GHC/haskell outperforms GCC/C when it comes to Integer-intensive number theory =)
02:54:48 <mm_freak_> at least with -fno-cse =P
02:54:58 <OpensHell1> mm_freak_: are you using llvm?
02:55:21 <mm_freak_> OpensHell1: no, just the regular native code compiler, and i doubt that LLVM would make a difference here
02:55:41 <OpensHell1> ah, I found for some type of programs that -fllvm helps a lot
02:55:52 <mm_freak_> you can well write faster code in C, but then you would have to use the very inconvenient mpn_* functions of GMP
02:55:58 <mm_freak_> and the speed difference wouldn't be worth it
02:56:20 <OpensHell1> probably not for GMP-heavy programs
02:56:50 <lpsmith> mm_freak_, how are you doing modular exponentiation?   GMP,  or your own haskell implementation?
02:57:00 <mm_freak_> lpsmith: the arithmoi library
02:57:26 <lpsmith> mm_freak_, you finally released the library you were working on?  =)
02:57:28 <lpsmith> Congrats!
02:57:35 <mm_freak_> no, it's not mine
02:57:43 <Jafet> You cannot link to GMP for Integer without modifying GHC
02:57:47 <mm_freak_> arithmoi is by daniel fischer
02:58:00 <mm_freak_> and it's great, albeit having quite a low level interface
02:58:16 <Jafet> The most annoying part is implementing extgcd yourself
02:58:23 <mm_freak_> Jafet: arithmoi uses GMP functions through the integer-gmp package of GHC
02:58:30 <mm_freak_> you don't have to
02:58:35 <lpsmith> Jafet, I'm not sure you have to modify GHC
02:58:48 <Jafet> I thought integer-gmp didn't provide any of these things.
02:58:48 <mm_freak_> Math.NumberTheory.Moduli> invertMod 2 12827
02:58:48 <mm_freak_> Just 6414
02:58:49 <lpsmith> You do have to do a lot of special GHC wizardry
02:58:51 <mm_freak_> =)
02:59:01 <lpsmith> You can't use the regular FFI
02:59:08 <Jafet> Certainly, Prelude.gcd doesn't use GMP's gcd...
02:59:09 <lpsmith> GHC doesn't use the regular FFI for the gmp
02:59:19 <lpsmith> Jafet, for bigints I think it does
02:59:30 <Jafet> (Despite there being a gcdInteger#!)
02:59:39 <mm_freak_> Jafet: using GMP primitives i wrote a C version of a (large Integer)-heavy algorithm
02:59:57 <lpsmith> somebody was working on a fast numbertheory package
03:00:06 <lpsmith> that wasn't daniel fischer
03:00:17 <lpsmith> was that one of  mm_freak_ or Jafet ?
03:00:24 <mm_freak_> primitives like mpz_powm, mpz_sqrt, mpz_probab_prime_p, mpz_invert, etc.
03:00:37 <mm_freak_> the haskell version together with arithmoi outperformed it!
03:00:47 <Jafet> @hackage arithmoi
03:00:47 <lambdabot> http://hackage.haskell.org/package/arithmoi
03:00:49 <OpensHell1> mm_freak_: cool, i've always been rolling my own stuff for finite fields
03:00:57 <Jafet> What is this sorcery
03:00:59 <OpensHell1> mm_freak_: a PITA tbh
03:01:05 <mm_freak_> lpsmith: i /am/ working on it
03:01:25 <lpsmith> ahh :)
03:01:30 <lpsmith> that's what I thought
03:01:36 <mm_freak_> it's a package for fast modular arithmetic even with CRT optimization, and now it's based on arithmoi =)
03:01:42 <lpsmith> I see
03:01:50 <mm_freak_> the main feature of my library is that the modulus becomes a type argument without losing any speed
03:01:55 <lpsmith> Well, I look forward to a release :)
03:01:55 <OpensHell1> i just want a Num instance for GF(p^m) and so some calculations :(
03:02:16 <mm_freak_> x :: Mod (CrtMod n)
03:02:23 <mm_freak_> a CRT-optimized finite ring modulo n =)
03:02:45 <mm_freak_> and yes, with Num, Eq, etc. by using implicit configurations =)
03:02:46 <OpensHell1> mm_freak_: are you doing field extensions / polynomial rings / and stuff like this?
03:02:54 <Jafet> I don't see arithmoi using GMP anywhere...
03:03:28 <mm_freak_> OpensHell1: field extensions are planned, but right now i can't even give a release date for the first revision of the library
03:03:50 * elliott is sceptical about this GMP arithmoi claim too
03:04:25 <OpensHell1> mm_freak_: yeah sure :) i can live with what i have now since i work in a field that is fixed, i just defined the stuff once and now i can work with it.
03:04:28 <mm_freak_> well, i know that it uses some interesting algorithms, for example for primality checks it doesn't use the common M-R test
03:04:31 <Jafet> In fact, it uses quotRem for extendedGCD, which is going to be something like fifty times slower than mpz_extgcd
03:05:20 <mm_freak_> mpz_probab_prime_p with 15 iterations is definitely slower than isPrime from arithmoi, while giving a weaker guarantee, as far as i understood
03:05:33 <mm_freak_> i have tested the speed, but i can't say anything about the number-theoretical claim yet
03:05:38 <Jafet> Ballie-PSW is a well-known test, although with no heuristic argument of correctness
03:05:54 <Jafet> It performs one probab_prime_p test and one Lucas pseudoprime test.
03:06:04 <mm_freak_> and integerSquareRoot really reaches mpz_sqrt speed
03:06:39 <mm_freak_> i'm trying to avoid invertMod, so i can't really compare it to mpz_invert
03:07:01 <mm_freak_> most algorithms use it only once per run
03:07:11 <mm_freak_> and most often i invert 2
03:07:36 <Jafet> I would be surprised at that too. integerSquareRoot n = heron n (fromInteger . appSqrt . fromIntegral $ n)
03:07:49 <Jafet> Are you comparing to GMP 3 or something?
03:08:04 <Jafet> Or some strange build of GMP
03:08:21 <mm_freak_> GMP 5.0.4, arch linux, x86_64
03:08:55 <mm_freak_> i'm finding it strange that you find haskell code there…  the library claims it uses efficient algorithms through the integer-gmp package
03:09:51 <Jafet> integer-gmp only exports a small number of GMP procedures, those necessary to implement Integer.
03:10:17 <mm_freak_> not sure, i haven't ever looked at the source code of arithmoi…  i can just say that i'm happy with its speed
03:10:31 <mm_freak_> no need to write C code with the inconvenient GMP interface, at least for me
03:12:39 <mm_freak_> and with all the number-theoretical stuff ready-made for you, it's really handy…  it even has ECM factorization and can derive totients from it right away, stuff like that
03:12:45 <Jafet> Perhaps the C code is prone to copying integers unnecessarily, or some other unix occupational hazard
03:13:04 <mm_freak_> dunno, i'd rather expect it to have something to do with allocation
03:13:21 <OpensHell1> did you try FORTRAN ? :)
03:13:33 <mm_freak_> with GMP-FORTRAN? =P
03:13:36 <Jafet> And the differences happen to cancel each other out.
03:14:22 <mm_freak_> very well possible, but i really don't want to work with mpn_* or provide a custom heap =)
03:14:33 <mm_freak_> though probably i could use this little GC package for C
03:16:12 <mm_freak_> no, i don't want to go back to C…  it was a real PITA to find a HashMap equivalent that can deal with GMP integers as keys…  i ended up building an array, sorting it and then using bsearch()
03:16:24 <mm_freak_> C is horrible, when it comes to data structures
03:16:59 <mrcarrot> C is simple and horrible. it is just syntactic sugar for asm
03:16:59 <c_wraith> It frees you to use whatever data structure you want, by providing you none!
03:17:19 <OpensHell1> that's correct, i recently copied some code from OpenBSD to make a binary search tree
03:17:36 <OpensHell1> they have hashtables as well, i'm sure
03:17:41 <c_wraith> it was syntactic sugar for asm when it was first designed.  ASM has come a long way since then, though.  It's not a particularly good representation of any current asm
03:17:47 <rostayob> mrcarrot: asm + a heap + structs + portability...
03:17:49 <mm_freak_> @remember <c_wraith> It [C] frees you to use whatever data structure you want, by providing you none!
03:17:49 <lambdabot> I will remember.
03:18:18 <OpensHell1> i don't mind separating the programming language and the standard libraries so much
03:18:19 <rostayob> mrcarrot: + a standard library
03:18:38 <mm_freak_> OpensHell1: there are hash table implementations in C, lots of them
03:18:48 <mm_freak_> but they deal either with strings or with ints
03:19:14 <OpensHell1> ah. the OpenBSD binary search tree was generic in its compare function. (generic at compile time, at least)
03:19:54 <rostayob> C is not that bad. It could be better, but that's true for everything
03:20:08 <mm_freak_> yeah, i used bsearch()…  the sorting was the most expensive operation (tens of millions of GMP numbers to compare)
03:20:09 <rostayob> but it's quite adequate
03:20:12 <OpensHell1> i don't mind C so much either, for its purpose. it could be a lot better in various ways, sure
03:20:19 <OpensHell1> C++, otoh...
03:20:41 <mm_freak_> C++ would have helped there actually with the boost library
03:21:03 <OpensHell1> sure, and/or STL
03:24:42 * hackagebot wai 1.1.0.1 - Web Application Interface.  http://hackage.haskell.org/package/wai-1.1.0.1 (MichaelSnoyman)
03:24:45 * hackagebot wai-app-static 1.1.2 - WAI application for static serving  http://hackage.haskell.org/package/wai-app-static-1.1.2 (MichaelSnoyman)
03:27:16 <matthiasgorgens> but C++ is evil.
03:27:53 <matthiasgorgens> they recently acquired some form of type inference.
03:28:12 <matthiasgorgens> a step in the right direction at least.
03:28:46 <OpensHell1> ah, the days where you had to write std::vector<int>::const_iterator it
03:29:20 <james_ubc0> okay so i've been reading lyah and im really not getting how this thingy is working http://pastebin.com/2vvsV0Ln
03:29:22 <mauke> The paste 2vvsV0Ln has been copied to http://hpaste.org/64271
03:29:24 <matthiasgorgens> those iterators are inherently stateful, aren't they?
03:29:46 * hackagebot wai-eventsource 1.1.0.1 - WAI support for server-sent events  http://hackage.haskell.org/package/wai-eventsource-1.1.0.1 (MichaelSnoyman)
03:29:49 * hackagebot wai-extra 1.1.0.1 - Provides some basic WAI handlers and middleware.  http://hackage.haskell.org/package/wai-extra-1.1.0.1 (MichaelSnoyman)
03:29:50 * hackagebot wai-handler-launch 1.1.0.1 - Launch a web app in the default browser.  http://hackage.haskell.org/package/wai-handler-launch-1.1.0.1 (MichaelSnoyman)
03:29:52 * hackagebot warp 1.1.0.1 - A fast, light-weight web server for WAI applications.  http://hackage.haskell.org/package/warp-1.1.0.1 (MichaelSnoyman)
03:29:54 * hackagebot warp-static 1.1.0.1 - Static file server based on Warp and wai-app-static  http://hackage.haskell.org/package/warp-static-1.1.0.1 (MichaelSnoyman)
03:30:12 <merijn> james_ubc0: Do you understand what $ does?
03:30:26 <matthiasgorgens> james_ubc0: what part of that don't you understand?
03:30:38 <james_ubc0> oh god
03:30:40 <james_ubc0> didnt see that
03:30:45 <james_ubc0> that was silly sorry >_<
03:30:52 <merijn> james_ubc0: :)
03:32:01 <mrcarrot> the "cryptic" error messages of ghc is maybe the biggest trouble for a beginner
03:32:26 <OpensHell1> they are hard to improve, especially in the presence of type classes
03:33:08 <matthiasgorgens> Isn't there a compiler specifically aimed at giving nicer error messages?
03:33:16 <OpensHell1> there's Helium
03:33:30 <mrcarrot> i think i read something like on wikipedia too.. but i have never been giving it a try
03:33:40 <rostayob> matthiasgorgens: some people prefer Hugs messages
03:33:40 <OpensHell1> it's used at Utrecht University
03:33:51 <OpensHell1> it does not have overloading
03:34:04 <rostayob> (I certainly did when I started)
03:34:57 * hackagebot shake 0.2.8 - Build system library, like Make, but more accurate dependencies.  http://hackage.haskell.org/package/shake-0.2.8 (NeilMitchell)
03:34:59 <matthiasgorgens> oh, yeah, utc it's called, isn't it?
03:35:03 <matthiasgorgens> or uhc?
03:35:14 <OpensHell1> uhc is something else, although it could be based on it, i don't know
03:35:18 <OpensHell1> uhc is a full-blown haskell compiler
03:35:21 <matthiasgorgens> ok.
03:36:29 <james_ubc0> okay actually going back, one thing i dont uderstand...
03:36:42 <james_ubc0> after i input "abcd "
03:36:53 <james_ubc0> it returns ~~~~~
03:37:00 <james_ubc0> why 5 instead of 1?
03:37:00 <merijn> Yes
03:37:14 <merijn> james_ubc0: Because you called main 5 times and main prints ~ at the end
03:37:41 <merijn> Every time c doesn't match space it will recurse and call main. But the putChar at the end of main is not magically skipped
03:38:03 <james_ubc0> right right right
03:38:48 <james_ubc0> so if i want this to behave like java i'd put and if ' ' at the end instead?
03:39:12 <merijn> If you want it to behave like java you'd do something like
03:39:28 <mrcarrot> james_ubc0: replace when with if
03:40:56 <james_ubc0> riiiiiight right right...
03:41:01 <hpaste> merijn annotated “pastebin.com/2vvsV0Ln” with “pastebin.com/2vvsV0Ln (annotation)” at http://hpaste.org/64271#a64272
03:41:20 <merijn> I might've screwd up the indentation of if, but you get the idea
03:41:45 <merijn> oh, hmm. The original used tabs, apparently
03:42:00 <merijn> Imagine the indentation looks remotely non-awful :p
03:42:48 <james_ubc0> cool
03:43:17 <james_ubc0> so when is just like and if statement except false is always return () correct?
03:43:34 <Cale> There are tabs in the original
03:43:55 <quicksilver> precisely, james_ubc0
03:44:04 <quicksilver> when is just defined using if and return ()
03:44:10 <quintessence> @src when
03:44:11 <lambdabot> when p s = if p then s else return ()
03:44:27 <james_ubc0> why have it then?!?!
03:44:30 <Cale> james_ubc0: Make sure to turn on whatever option in your editor replaces tabs with spaces automatically for you
03:44:45 <quicksilver> james_ubc0: saves a little typing / slightly easier to read
03:46:04 <Cale> james_ubc0: It's not primitive, it's just a definition in a library
03:46:27 <Cale> We make definitions of things whenever a common pattern arises
03:46:52 <Cale> It's common to want to carry out some action when a condition is true, and do nothing otherwise, and when captures that idea.
03:47:17 <merijn> james_ubc0: Because it can be easier to read?
03:47:30 <james_ubc0> i guess
03:47:40 <merijn> Why have for loops if while loops can do the exact same thing?
03:48:00 <Jafet> longjmp
03:48:44 <OpensHell1> why have while loops if goto can do the same thing?
03:48:45 <ion> Why have while loops if if+goto can do the exact same thing?
03:50:01 <mekeor> why loops at all?
03:50:13 <james_ubc0> lol okay i get it
03:50:16 <mekeor> why programming at all?
03:50:28 <mekeor> james_ubc0: give it up. programming sucks
03:50:28 <Cale> hehe, yeah, just give me a fixed point combinator ;)
03:50:44 <mekeor> :] just kidding
03:51:20 <merijn> james_ubc0: It's actually a nice example of one of the benefits of laziness and first class actions. You can define your own new syntax. Defining something like 'when' in the form of if/else can't really be done in Java or C
03:53:13 <shachaf> That's not defining your own new syntax.
03:53:28 <shachaf> The only reason you think of it as syntax is that "if" is syntax. :-)
03:54:23 <merijn> shachaf: It's not in Haskell, I just meant that it's something you can't do in C/java without extending the language itself. I just couldn't think of a proper short way of describing that :p
03:54:25 <Jafet> Sin tax?
03:54:47 <Jafet> Abnormal order evaluation
03:57:47 <osa1> what's the difference between Prelude.. and Control.Category.. ?
03:58:03 <ceii> osa1: the latter is a generalization of the former
03:58:11 <ceii> to compose things other than functions
04:05:01 <osa1> ok, a simple question about arrows and hakyll, I'm learning haskell and I don't know much about arrows yet, but as far as I understand, hakyll could be using monadic compilers and do notation instead of arrows in compiler composition, am I right?
04:05:42 <tomodo> hello!!!
04:05:51 <mekeor> hi, tomodo
04:06:29 <tomodo> does anyone want to talk about alpha-beta pruning for connect 4
04:06:29 <ceii> osa1: the thing about monads is that you can't do much with a monadic value besides "run" it
04:06:51 <ceii> because composing two monadic values embeds a Haskell function in the composed value
04:07:16 <ceii> and you can't inspect a function in any way, besides applying it to some arguments
04:07:27 <osa1> ceii: ok, but isn't what we are doing with hakyll compilers is exactly running?
04:07:32 <tomodo> I want to program it!
04:07:35 <danr> tomodo: if you have a specific question, just ask :)
04:08:04 <tomodo> I'll define an "evaluation function" which estimates how good a game in progress is
04:08:12 <ceii> I don't know how hakyll is implemented, but my guess is it inspects the static structure of those compilers first
04:13:44 <danr> tomodo: there is a probelm with games like connect four where such an evaluation function is hard to express. Compare to evaluating a board of chess, where a lot of information is available as pieces remaining and board control
04:14:22 <danr> tomodo: putting the fact that connect-4 is actually solved, you might want to be interesed in a more monte-carlo approach
04:14:23 <tomodo> that's a good point danr
04:14:45 <osa1> how does deriving from Monad work?
04:14:46 <tomodo> I am trying to learn alpha-beta game AI
04:15:11 <tomodo> the first game I tried has too big branching factor so it was took a long time to move
04:15:15 <danr> tomodo: then I'd suggest another game, such as checkers or chess :)
04:15:39 <tomodo> I thought those would be more complicated
04:15:48 <danr> tomodo: 8x8 checkers (english draughts) is quite minimal
04:15:54 <tomodo> ok
04:29:35 <Taneb> I've got a weird phantomly error
04:30:16 <Martty> is it haskell related?
04:30:20 <Taneb> Yes
04:30:47 <Taneb> But it's to do with the JuicyPixel package?
04:31:03 <Taneb> *JuicyPixels library
04:31:46 <Taneb> *** Exception: .\Data\Vector\Generic.hs:244 ((!)): index out of bounds (9000,900
04:31:47 <Taneb> 0)
04:31:49 <Taneb> That's the error
04:32:24 <Taneb> It's from somewhere me calling pixalAt on a 30 by 100 image
04:32:52 <elliott> You're passing a pixel out of range or such.
04:33:47 <nand`> Can I pattern match on a binding in a do block? ie do (a,b) <- listOfTuples; ...
04:34:08 <Taneb> The highest coord I ask for is (29,99)
04:34:23 <Taneb> Unless it's to do with (0,0)?
04:35:30 <nand`> Oh, I was missing the “do”
04:35:32 <nand`> nvm
04:40:10 <hpaste> Taneb pasted “Problem” at http://hpaste.org/64273
04:40:20 <Taneb> There's the code
04:40:26 <lorrien3> Ther's the code?
04:40:29 <lorrien3> Where?
04:40:42 <Taneb> <hpaste> Taneb pasted Problem at http://hpaste.org/64273
04:40:48 <Taneb> That I was having trouble with
04:40:53 <lorrien3> is that a link for a virus?
04:40:53 <Taneb> It's not the best code in the world
04:41:07 <lorrien3> it's in python?
04:41:16 <Taneb> Haskell
04:41:32 <lorrien3> in haskell language?
04:41:38 <elliott> yes, that's Haskell code.
04:41:38 <Taneb> YEs
04:41:38 <merijn> Taneb: Could you be more specific what the problem is?
04:41:45 <Taneb> I would If I knew
04:41:45 <elliott> <Taneb> *** Exception: .\Data\Vector\Generic.hs:244 ((!)): index out of bounds (9000,900
04:41:55 <elliott> <Taneb> 0)
04:42:06 <merijn> oh, I missed the start of the questions apparently
04:42:15 <lorrien3> where am I? These people are geeks!!!
04:42:24 <clsmith> hey. is there a function to split by some Eq? e.g., i want to split "a:b:c" by ':'. i've been hoogling and hoogling but i can't find one >.>
04:42:30 <elliott> lorrien3: you seem confused.
04:42:42 <elliott> clsmith: look at the split package
04:42:43 <clsmith> (:: Eq a => a -> [a] -> [[a]])
04:43:06 <elliott> lorrien3: you are in #haskell, the channel for the haskell programming language.
04:43:14 <Taneb> brb
04:43:15 <elliott> if you don't know anything about haskell you probably don't want to be here
04:43:32 <lorrien3> that's why I'm leaving, right here, right now
04:43:39 <t7> has any progress been made on that ghci in the browser gsoc proposal?
04:43:53 <clsmith> elliott: ah, thanks. that didn't come up when i hoogled for 'split'. i guess it doesn't search all of hackage
04:44:12 <elliott> clsmith: try hayoo.
04:44:17 <elliott> @where hayoo
04:44:17 <lambdabot> http://holumbus.fh-wedel.de/hayoo/hayoo.html
04:45:26 <clsmith> ahh, cool. all we need now is a hing :)
04:48:05 <t7> can someone buy hoogle.com
04:48:15 <t7> i keep trying it in by accident
04:48:41 <Taneb> When I said brb, I have course meant bbl
04:50:56 <Jafet> I'd rather waste money on morphi.sm
04:51:03 <aristid> t7: wtf. hoogle.com redirects to a weird site
04:57:15 <nand`> Expires on 30 March 2012
04:59:47 <t7> it must get millions of hits a month
04:59:55 <t7> h is next to g
05:00:21 <t7> (on my keyboard)
05:00:56 <nand`> Oh, I didn't even see the resemblance to google. I thought you were mentioning using it as an alternative to the Hoogle search
05:01:07 <merijn> nand`: He was
05:01:26 <nand`> I see
05:01:32 <merijn> The resemblance to Google probably makes it to expensive to buy, though
05:01:43 <nand`> Most likely
05:01:47 <t7> i said that too
05:01:49 <merijn> I already did my part by registering lambdacats :p
05:02:03 <t7> well i implied it
05:02:15 <james_ubc> so uh another IO question, what's the [(),()] thing at the end when we execute sequence . map print [1,2]
05:02:20 <nand`> I didn't realize people still type Google.com when using the search engine, what year is this?
05:02:40 <nand`> james_ubc: look at the type of print, and then sequence
05:02:43 <elliott> james_ubc: the result of executing each print
05:02:45 <elliott> you want sequence_
05:02:47 <merijn> james_ubc: print is type "IO ()"
05:02:57 <t7> some old people goto yahoo and search for google
05:03:16 <merijn> :t sequence
05:03:17 <lambdabot> forall (m :: * -> *) a. (Monad m) => [m a] -> m [a]
05:03:21 <merijn> :t sequence_
05:03:21 <lambdabot> forall (m :: * -> *) a. (Monad m) => [m a] -> m ()
05:03:30 <Phlogistique> I heard some web browsers are installed by OEMs in Japan without an address bar
05:03:35 <james_ubc> yeah im confused
05:04:00 <quintessence> james_ubc: sequence gives you back a list of results, and print returns ()
05:04:06 <quintessence> sequence_ throws away the results
05:05:24 <james_ubc> so err why at the end? >_<
05:05:46 <t7> I think today i will write a software rasterizer
05:07:38 <elliott> james_ubc: ghci prints the result of the computation at the end
05:07:48 <elliott> the prints happen as part of the execution, then the result [(),()] is printed
05:08:14 <james_ubc> RIGHT!
05:08:23 <james_ubc> okay so it's just a ghci quirk
05:08:29 <james_ubc> no?
05:08:38 <james_ubc> since ghci prints everything with type IO
05:09:03 <t7> ghci prints everything it can
05:09:17 <t7> show $ IO ()
05:09:21 <t7> > show $ IO ()
05:09:22 <lambdabot>   Not in scope: data constructor `IO'
05:09:28 <t7> well its printed as "()"
05:09:39 <Taneb> Back
05:14:07 <t7> whats a fast mutable sctructure simular to a C array? eg. i wanna index from 0 .. length
05:14:53 * hackagebot urldecode 1.0.0.0 - Decode percent-encoded strings.  http://hackage.haskell.org/package/urldecode-1.0.0.0 (BenedictEastaugh)
05:15:21 <otk> http://yow.eventer.com/events/1004/talks/1054
05:15:43 <otk> probably most here have seen it but SPJ giving a lecture at yow
05:17:15 <OpensHell1> t7: Data.Array.Mutable iirc
05:17:34 <mux> t7: use the vector package
05:18:53 <t7> ah cool
05:18:58 <t7> is that in the platform?
05:19:17 <rostayob> t7: yes
05:32:01 <snipermil> hi
05:32:14 <t7> @hoogle system
05:32:15 <lambdabot> System.Process system :: String -> IO ExitCode
05:32:16 <lambdabot> System.Cmd system :: String -> IO ExitCode
05:32:16 <lambdabot> package system-argv0
05:54:55 * hackagebot AC-MiniTest 1.1.1 - A simple test framework.  http://hackage.haskell.org/package/AC-MiniTest-1.1.1 (AndrewCoppin)
05:58:42 <Kyril> er... how do i quit ghci? >_>
05:58:50 <Paprikachu> :q
05:59:12 <Kyril> thanks :)
06:01:13 <td123> you could also send EOF
06:01:23 <t7> @hoogle [m a] -> m [a]
06:01:23 <lambdabot> Prelude sequence :: Monad m => [m a] -> m [a]
06:01:24 <lambdabot> Control.Monad sequence :: Monad m => [m a] -> m [a]
06:01:24 <lambdabot> Language.Haskell.TH.Syntax sequenceQ :: [Q a] -> Q [a]
06:02:26 <t7> @src mapM
06:02:26 <lambdabot> mapM f as = sequence (map f as)
06:04:27 <hpc> @src sequence
06:04:27 <lambdabot> sequence []     = return []
06:04:28 <lambdabot> sequence (x:xs) = do v <- x; vs <- sequence xs; return (v:vs)
06:04:28 <lambdabot> -- OR: sequence = foldr (liftM2 (:)) (return [])
06:14:21 <Kuba> hey
06:15:10 <nand`> > iterate (concatMap (\seq -> show (length seq) ++ [head seq]) . group) "1"
06:15:12 <lambdabot>   ["1","11","21","1211","111221","312211","13112221","1113213211","3113121113...
06:15:22 <nand`> I wonder if this can be expressed more elegantly
06:16:17 <hpc> nand`: you can probably reverse \seq -> blah
06:16:21 <hpc> nand`: then do it applicatively
06:17:30 <nand`> I'm not sure if that counts as “more elegantly”
06:17:57 <nand`> @pl (\seq -> show (length seq) ++ [head seq])
06:17:57 <lambdabot> ap ((++) . show . length) (return . head)
06:19:20 <hpc> @pl \seq -> (head seq) : (show . length $ seq)
06:19:20 <lambdabot> liftM2 (:) head (show . length)
06:19:41 <hpc> or, (:) <$> head <*> (show . length)
06:20:38 <nand`> > iterate concatMap (reverse . ((:) <$> head <*> show . length) . group) "1"
06:20:39 <lambdabot>   Occurs check: cannot construct the infinite type: a = [a]
06:21:10 <nand`> > iterate (concatMap (reverse . ((:) <$> head <*> show . length)) . group) "1"
06:21:11 <lambdabot>   ["1","11","21","1211","111221","312211","13112221","1113213211","3113121113...
06:21:24 <nand`> longer than before :)
06:21:47 <mux> > iterate (concatMap (show . length &&& return . head) . group) "1"
06:21:48 <lambdabot>   Couldn't match expected type `[b]'
06:21:48 <lambdabot>         against inferred type `(GHC.Base...
06:22:01 <mux> > iterate (concatMap (show . length &&& (++) . return . head) . group) "1"
06:22:02 <lambdabot>   Couldn't match expected type `[b]'
06:22:02 <lambdabot>         against inferred type `(GHC.Base...
06:22:06 <nand`> :t (&&&)
06:22:07 <lambdabot> forall (a :: * -> * -> *) b c c'. (Arrow a) => a b c -> a b c' -> a b (c, c')
06:22:16 <mux> nah, using &&& makes no sense
06:22:26 <nand`> mux: consider mixing it with
06:22:35 <nand`> :t uncurry (:)
06:22:36 <lambdabot> forall a. (a, [a]) -> [a]
06:23:33 <t7> @hoogle Ptr
06:23:34 <lambdabot> Foreign.Ptr module Foreign.Ptr
06:23:34 <lambdabot> Foreign.Ptr data Ptr a
06:23:34 <lambdabot> GHC.Exts data Ptr a
06:23:57 <nand`> > iterate (concatMap (reverse . uncurry (:) . (head &&& show . length)) . group) "1"
06:23:59 <lambdabot>   ["1","11","21","1211","111221","312211","13112221","1113213211","3113121113...
06:24:06 <nand`> Even longer :)
06:24:19 <nand`> hmm
06:24:55 <nand`> > iterate (concatMap (uncurry (++) . (show . length && return . head)) . group) "1"
06:24:55 <lambdabot>   Couldn't match expected type `GHC.Bool.Bool'
06:24:56 <lambdabot>         against inferred type ...
06:25:21 <nand`> Bool?
06:25:33 <nand`> oh.. ohhh
06:25:36 <nand`> > iterate (concatMap (uncurry (++) . (show . length &&& return . head)) . group) "1"
06:25:38 <lambdabot>   ["1","11","21","1211","111221","312211","13112221","1113213211","3113121113...
06:28:11 <nand`> > iterate (concatMap ((++) <$> show . length <*> return . head) . group) "1"
06:28:12 <lambdabot>   ["1","11","21","1211","111221","312211","13112221","1113213211","3113121113...
06:28:17 <nand`> that'll do
06:28:46 <danr> nand`: nice :)
06:29:39 <ion> return . head → drop 1
06:29:47 <ion> take 1, that is
06:30:03 <nand`> > iterate (concatMap ((++) <$> show . length <*> take 1) . group) "1"
06:30:05 <lambdabot>   ["1","11","21","1211","111221","312211","13112221","1113213211","3113121113...
06:30:05 <nand`> that it is
06:30:39 <danr> hmm interesting, it seems like a number greater than 3 will never occur
06:30:46 <mux> yes
06:30:49 <osfameron> nand`: heh, I remember my dad teasing me with that problem
06:30:57 <mux> it's quite easy to show that you never have digits > 3
06:31:44 <nand`> If you had digits >3 they'd be of the form “nnnn” which would have been summarized (2n)n instead
06:32:54 <nand`> (or in the case of “xnnnno” it'd be (x+n)nno)
06:33:07 <t7> @hoogle Ptr a -> a
06:33:08 <lambdabot> Foreign.Ptr ptrToIntPtr :: Ptr a -> IntPtr
06:33:08 <lambdabot> Foreign.Ptr ptrToWordPtr :: Ptr a -> WordPtr
06:33:08 <lambdabot> Prelude id :: a -> a
06:33:23 <t7> wtf am i supposed todo with this
06:33:45 <nand`> @hoogle Ptr a -> IO a
06:33:45 <lambdabot> Foreign.Storable peek :: Storable a => Ptr a -> IO a
06:33:45 <lambdabot> Foreign.Marshal.Alloc free :: Ptr a -> IO ()
06:33:45 <lambdabot> Network.Socket.Internal peekSockAddr :: Ptr SockAddr -> IO SockAddr
06:34:01 <t7> ah eff it
06:34:07 <t7> back into the IO monad we go
06:34:18 <nand`> unsafePerformIO . peek :: Ptr a -> a
06:34:20 * nand` hides
06:34:54 <Taneb> Did anyone look at my problematic code?
06:35:46 <ion> > iterate ((++) <$> show . length <*> take 1 <=< group) "1"
06:35:48 <lambdabot>   ["1","11","21","1211","111221","312211","13112221","1113213211","3113121113...
06:36:07 <nand`> oh my
06:36:16 <nand`> :t (<=<)
06:36:17 <lambdabot> forall b (m :: * -> *) c a. (Monad m) => (b -> m c) -> (a -> m b) -> a -> m c
06:36:51 <hpc> nand`: take the definition of (.), replace function application with (=<<)
06:36:56 <hpc> @src (<=<)
06:36:56 <lambdabot> Source not found. Maybe if you used more than just two fingers...
06:37:28 <hpc> (f <=< g) x = f =<< g x
06:37:30 <ion> (f <=< g) x = g =<< f x
06:37:40 <ion> err, sorry
06:37:42 <hpc> :P
06:38:06 <Jafet> Damn the torpedoes
06:38:19 <nand`> I like how []'s join makes concat redundant
06:39:22 <tazjin> Hey, is there a performance difference between compiling code into an executable and running that or using runhaskell?
06:39:50 <hpc> tazjin: yes; runhaskell compiles to bytecode the same way ghci does
06:40:06 <Jafet> Therefore runhaskell compiles faster!
06:40:10 <hpc> it misses out on optimizations and whatnot, in code that isn't compiled
06:40:24 <hpc> if you compile something to .hi/.o files, then run it
06:40:29 <hpc> there shouldn't be a performance difference
06:40:38 <hpc> except probably a little bit
06:40:50 <tazjin> Ah, okay. Thanks :]
06:41:05 <hpc> so if you wrote a short script that sorted a bajillion numbers, it would run just as fast if you used sort
06:41:09 <hpc> but slower if you used mySort
06:41:34 <ion> And even slower if you used hisSort.
06:41:43 <hpc> haha
06:41:56 <Jafet> Don't be out of sorts.
06:42:31 <hpc> obviously you would write a function that takes a sorting function and applies it to a list
06:42:37 <hpc> and call it "sort polymorphism"
06:42:45 <hpc> just to ruin all hopes of another level of ghc type trickery
06:43:27 <nand`> sort polymorphism = ($)
06:43:38 <hpc> exactly
06:43:48 <Jafet> That sounds expensive.
06:43:48 <hpc> that's why the dollar sign looks like an 'S' too
06:43:50 <hpc> for "sort"
06:44:03 <t7> how do i use Data.Array.MArray.freeze with a StorableArray (Int, Int) Word8  ?
06:44:11 <nand`> which is unique in that it's actually a polyglot with perl
06:44:21 <nand`> then again every program is a polyglot with perl
06:47:02 <ion> t7: As for your earlier question, http://hackage.haskell.org/packages/archive/base/4.5.0.0/doc/html/Foreign-Marshal-Unsafe.html
06:48:17 <ion> t7: It might be perfectly appropriate to use unsafeLocalState to peek at a local pointer without other side effects.
06:48:37 <t7> i think  i will just copy the data.
06:48:49 <t7> when i work out how to use this StorableArray
06:49:51 <losvedir> ion: that was pretty cool how you generated the 1, 11, 21, . . . sequence
06:50:14 <ion> losvedir: It was originally nand’s code (i think), i just golfed a bit.
06:50:41 <t7> ffs i just wanna access the pixel data
06:50:46 <t7> it shouldnt be this awkward
06:51:21 <losvedir> ion: ah, didn't scroll up far enough. the golfing was neat, too, though :)
06:55:40 <t7> @hoogle (a -> b -> c) -> b -> a
06:55:40 <lambdabot> Data.Foldable foldl :: Foldable t => (a -> b -> a) -> a -> t b -> a
06:55:40 <lambdabot> Data.Foldable foldl' :: Foldable t => (a -> b -> a) -> a -> t b -> a
06:55:40 <lambdabot> Prelude foldl :: (a -> b -> a) -> a -> [b] -> a
06:55:46 <hpaste> harlekin pasted “AStar test case” at http://hpaste.org/64277
06:55:48 <t7> @hoogle (a -> b -> c) -> b -> a -> c
06:55:48 <lambdabot> Prelude flip :: (a -> b -> c) -> b -> a -> c
06:55:49 <lambdabot> Data.Function flip :: (a -> b -> c) -> b -> a -> c
06:55:49 <lambdabot> Data.IntMap fold :: (a -> b -> b) -> b -> IntMap a -> b
06:59:09 <t7> all my code is in the IO monad
06:59:12 <t7> nooooooooo
07:00:03 <luite> t7: it's quite common for large programs to live mostly in the IO monad, with only relatively small pure functions
07:00:59 <danr> luite: I wound envisage to revise code like that
07:01:54 <t7> @hoogle peek
07:01:55 <lambdabot> Foreign.Storable peek :: Storable a => Ptr a -> IO a
07:01:55 <lambdabot> Foreign.Marshal.Array peekArray :: Storable a => Int -> Ptr a -> IO [a]
07:01:55 <lambdabot> Foreign.Marshal.Array peekArray0 :: (Storable a, Eq a) => a -> Ptr a -> IO [a]
07:04:48 <singpolyma> How come sometimes I need to add "module Main where" to the top of a Haskell file to get it to work right in ghci and sometimes I don't?
07:06:43 <luite> danr: really? in my experience it's just how it is, not a bad thing. for example in iterative numerical algorithms you can usually make the step function pure, but in order get progress reports and be able to pause/resume the calculation, you need a lot of "control logic" in IO, that's often more code, for me.
07:06:48 <luite> with web applications it's even worse, much of the code must be able to access the request body/params, or the database. there's often a bit of pure code when running the templates, but that tends to be relatively small (and with yesod, generated through TH)
07:07:42 <luite> those are the area's that I have most experience with, don't know about many others... I'd imagine that for example games are similar
07:24:37 <singpolyma> How come sometimes I need to add "module Main where" to the top of a Haskell file to get it to work right in ghci and sometimes I don't?
07:24:56 <hpaste> liyang pasted “runCC?” at http://hpaste.org/64278
07:25:09 <liyang> Continuations… is there a common name for ‘runCC’ here?
07:25:47 <quintessence> singpolyma: what goes wrong when you don't?
07:25:50 <t7> http://stackoverflow.com/questions/9433259/image-codec-png-to-immutable-pixel-data
07:26:41 <hpaste> liyang annotated “runCC?” with “runCC? (annotation)” at http://hpaste.org/64278#a64279
07:27:40 <singpolyma> quintessence: ghci just says the functions from the file are not in scope when I try to run them
07:29:21 <t7> oh god i keep using vim bindings in ms word :P
07:30:45 <DarkUnicorn> oh god you are using ms word
07:34:16 <mrcarrot> today i took a look at pandoc and markdown... really nice stuff for writing things with those times when you think latex is a bit of exaggregation
07:36:07 <t7> DarkUnicorn: yes i havea  job
07:41:22 <wgeorg> Hello everyone. I use the haskell-platform-2011.4.0.0 with GHC 7.0.4, quite happily. There is however the small issue of ghci crashing when using some of the GSL commands, so I would like to upgrade to ghc 7.4.1 to fix this. The naive way of just installing ghc 7.4.1 seems to mess with cabal and dependencies. Hence the question: Is there a clever way of upgrading to 7.4.1 on the current haskell platform?
07:42:03 <OpensHell1> no. the haskell platform is tied to a GHC verison.
07:42:30 <OpensHell1> you could try it but it's not supported and not very likely to work i think
07:42:52 <td123> it would be great for a new haskell-platform to get pushed out with every stable release of ghc :)
07:43:02 <OpensHell1> td123: it takes work.
07:43:12 <td123> I know, I'm just saying
07:43:13 <OpensHell1> td123: people are working on a new release now
07:43:55 <OpensHell1> td123: it might take a few months though :(
07:43:58 <cwb> Hi there, I'm having trouble getting Crypto installed; it gives what seems like a programming error (but I realise that's unlikely): Data/Digest/SHA2.hs:111:4:
07:44:02 <cwb>     Could not deduce (Show a) arising from a use of `showHex'
07:44:11 <OpensHell1> cwb: sigh. ghc 7.4.x ?
07:44:12 <cwb> GHC 7.4.1
07:44:21 <td123> didn't mean to sound demanding, just stating an opinion :P
07:44:40 <cwb> OpensHell1: What did I miss?
07:44:41 <wgeorg> OpensHell1, I see, thanks. I was thinking about forcing it; mostly get mixed up between versions and dependencies, though.
07:44:47 <OpensHell1> cwb: they changed the Num class, Show and Eq are no longer implied
07:44:48 <td123> cause you have distros like arch which either have to use old ghc versions or drop haskell-platform
07:45:20 <cwb> OpensHell1: So I need to clone the repo and change the source?
07:45:21 <OpensHell1> td123: yup, of course a release soon would be the ideal situation :)
07:45:36 <OpensHell1> cwb: yes, if you want it to compile on this GHC version.
07:45:54 <td123> OpensHell1: btw, arch is dropping haskell-platform and using the latest ghc :P
07:45:56 <cwb> OpensHell1: Ok, many thanks!
07:46:27 <OpensHell1> cwb: this is haskell's way of avoiding success, breaking code in releases :)
07:46:36 <ville> td123: meaning exactly what to us end users?
07:47:55 <td123> meaning you wont be able to do pacman -S haskell-platform anymore, it will be put in the aur though
07:50:13 <ville> guess I never used that anyway
07:50:30 <td123> ville: decision had to be made cause you can't have both latest ghc and haskell-platform
07:50:46 <ville> yeah I just had the ghc package rather
07:51:08 <danr> lusory: ok yesod is a good example :) but I think your example with iterative interactive numerical algorithms could be expressed with monads as writer, continuation and coroutine
07:51:20 <cwb> OpensHell1: Haha!
07:51:43 <wgeorg> Ok, a conceptual questions. I have the current ghc and haskell-platform installed with prefix /scratch/mylocal I can then successfully compile ghc-7.4.1 and put it in /scratch/mylocal. But then I'm not sure how to process. Cabal seems to be unhappy if I just call cabal install to compile some packages that will go in ~/.cabal. Any hint on how I might proceed?
07:51:58 <danr> luite: sorry i meant to send that to you rather than lusory
07:55:35 <luite> danr: hm, you still need to stack your ContT on top of IO if you want to allow the user to stop your calculation, right? same for coroutine? if not, do you have any examples for this type of problem?
07:56:02 <gfredericks> I am trying to install git-annex, and don't know much about the Haskell ecosystem; am I better off using cabal or trying to get it to compile by hand?
07:56:23 <gfredericks> (assuming I don't know anything about cabal and don't have it installed)
07:57:22 <cmccann> gfredericks, how'd you manage to not install Cabal? I thought it was included with GHC.
07:57:35 <cmccann> (the cabal-install program is another matter)
07:58:23 <gfredericks> cmccann: I don't know? maybe I don't have GHC yet...
07:58:31 * gfredericks tries to figure out if that's plausible
07:58:37 <cmccann> gfredericks, well, what do you have installed?
07:58:47 <gfredericks> xmonad! that's haskell
07:58:54 <gfredericks> could I have xmonad w/o ghc?
07:59:02 <cmccann> yes, but not with full functionality
07:59:06 <gfredericks> ah
07:59:20 <cmccann> though actually I'm not sure how it works if you try to install it separately
07:59:40 <cmccann> so you're an xmonad user, but not otherwise familiar with haskell?
07:59:49 <cmccann> just trying to get a sense of where you're coming from :]
08:00:01 <gfredericks> I'm a bit familiar with the language itself, but much less with setting it up and such
08:00:13 <gfredericks> I generally use debian-based systems
08:00:17 <cmccann> ok
08:00:35 <cmccann> well, last I heard debian-based systems tend to be way behind the curve in keeping haskell stuff up to date :P
08:00:36 <ion> Hah! showsPrec _ (Foo …) = showString "Foo<" . shows something ++ showString ">" compiles now that (++) is mappend in Overture. Took me a couple of seconds to figure out why a list looked like [Expr<63,Expr<128,Expr<62]>]>,Expr<62]>]>,Expr<128,Expr<62]>]>,Expr<62]>] (growing exponentially by length) instead of the correct [Expr<63>,Expr<128>,Expr<62>].
08:00:50 <cmccann> hahahahaha
08:01:30 <gfredericks> cmccann: for git-annex in particular the older ubuntu versions don't have it in apt-get at all, and the latest version of ubuntu has an old version of git-annex; so it seemed best to sidestep all that and install it myself
08:01:40 <cmccann> gfredericks, yes, probably
08:01:48 <gfredericks> but it has haskell dependencies obviously and I don't know how to get them
08:01:59 <cmccann> if you want to be anywhere near current stuff in haskell you might as well get used to building stuff yourself
08:02:05 <gfredericks> so you're saying I should not start with 'sudo apt-get install ghc6'?
08:02:32 <cmccann> the latest GHC is 7.4, that's bleeding-edge or so
08:02:39 <cmccann> the stable-ish version is 7.0
08:02:41 <cmccann> I think
08:02:49 <gfredericks> cmccann: so would getting cabal set up solve my problems?
08:02:52 <cmccann> I dunno, I upgrade pretty aggressively
08:03:01 <cmccann> well, if you don't have GHC you need it
08:03:07 <gfredericks> right
08:03:32 <Philippa> cmccann: stablish would be what's in the Platform - 7.2.2, IIRC
08:03:40 <cmccann> 7.2 isn't in platform, is it?
08:03:56 <cmccann> no, it's 7.0.4
08:04:03 <OpensHell1> no 7.2 is considered "experimental"
08:04:04 <luite> nope, next version will be 7.4
08:04:07 <gfredericks> not familiar with "Haskell Platform", but the GHC site recommends it -- should I install that instead?
08:04:08 <cmccann> that was a source of much complaint as I recall
08:04:22 <cmccann> hm
08:04:35 <luite> install the platform or 7.0.4 unless you know you want 7.4.1 :p
08:04:53 <cmccann> okay, quick poll, given what gfredericks said above would 7.0.4/platform be better?
08:05:03 <ion> I get my bleeding-edge GHC by adding "$HOME/.ghc/bin:$HOME/.cabal/bin" to my PATH, downloading the binary package from http://www.haskell.org/ghc/download_ghc_7_4_1#x86linux and installing it to ~/.ghc and bootstrapping cabal-install from “darcs get --lazy http://darcs.haskell.org/cabal/”. Something similar applies to stable versions of both, too. Probably get the stable version of cabal-install from…
08:05:07 <ion> @hackage cabal-install
08:05:07 <lambdabot> http://hackage.haskell.org/package/cabal-install
08:05:08 <gfredericks> oh I just noticed git-annex is rather specific about this: http://git-annex.branchable.com/install/
08:05:19 <gfredericks> it says "The Haskell Platform (GHC 7.4 or newer)"
08:05:36 <gfredericks> guess I should've read that more carefully first
08:05:41 <parcs`> ion: why reinstall cabal?
08:05:51 <ion> The Haskell Platform might be a good idea if you want a stable version, but OTOH it might have a bunch of stuff you don’t need.
08:05:59 <ion> parcs: Reinstall? I was talking about bootstrapping.
08:06:02 <cmccann> ...haskell platform, 7.4 or newer. er, does that even exist?
08:06:12 <luite> gfredericks: right, 7.4 should work fine, though you might expect a few more difficulties with packages because it's relatively new
08:06:35 <cmccann> gfredericks, anyway, if it tells you to use GHC 7.4 then you should use that
08:06:46 <cmccann> I didn't think there was a haskell platform release out yet with it, though
08:07:20 <parcs`> ion: ah
08:07:32 <ion> I’ve had to add a Show/Eq constraint to a bunch of stuff i’ve cabal-installed with 7.4.1. That might be too inconvenient for a beginner.
08:07:34 <gfredericks> oh and the HP page says I need to install GHC 7.0.4; now I don't know who to believe
08:08:06 <cmccann> gfredericks, 7.4 was recently released, so things are a bit in flux. sorry about that.
08:08:24 <cmccann> it's an awkward time to be getting started fresh :T
08:08:28 <gfredericks> oh okay so HP will still work if I install 7.4
08:08:39 * cmccann doesn't know, hasn't used the HP
08:09:04 <gfredericks> and then when I go to the GHC page to install it like the HP page said, it recommends I use HP instead O_O
08:09:12 <cmccann> ignore that disclaimer, heh
08:09:35 <cmccann> anyway, as far as I know the haskell platform mostly just gives you a pre-set chunk of useful stuff, a base to build from that's stable and works together
08:09:40 <gfredericks> okay; downloading a 7.4.1 binary
08:09:59 <cmccann> so you don't actually need it for anything if you're willing to strike out on your own
08:10:04 <cmccann> and you may not have a choice on that anyway
08:10:28 <cmccann> a GHC binary doesn't come with cabal-install, right?
08:11:15 * cmccann thinks it doesn't but isn't sure
08:11:28 <gfredericks> is this the sort of thing i'm supposed to `make && make install`?
08:11:33 <etpace> What's the correct term for a value such as "Just 5", "[6]", "Left 1", "Boxed Values"?
08:11:56 <cmccann> gfredericks, yeah, that just does some configuration and installs it
08:12:15 <cmccann> you need root privileges to install system-wide and all the usual
08:12:31 <gfredericks> and then I test it out by running `ghc`?
08:12:36 <gfredericks> ghci?
08:12:40 <cmccann> sure
08:12:44 <OpensHell1> etpace: that depends on what you mean exactly. do you mean that the value is "inside" a Functor?
08:13:07 <gfredericks> ghci knows what "3+4" is
08:13:10 <gfredericks> so I guess it worked
08:13:11 <cmccann> etpace, "boxed" means something very different
08:13:16 <cmccann> gfredericks, yep
08:13:35 <cmccann> now you probably want cabal-install to avoid hassling with stuff
08:13:57 <cmccann> do you have something called "cabal" in your path? I expect not
08:14:00 <gfredericks> nope
08:14:13 <gfredericks> ghc-pkg
08:14:19 <gfredericks> is what I get from `apropos cabal`
08:14:25 <gfredericks> and ghc-pkg6
08:14:31 <cmccann> right, ok
08:14:37 <gfredericks> but that could be leftover from stuff that came with xmonad?
08:14:57 <gfredericks> ghci is definitely 7.4.1
08:15:18 <cmccann> yeah, maybe you did have a ghc 6 somewhere
08:15:36 <cmccann> anyway
08:15:46 <cmccann> grab this: http://www.haskell.org/cabal/release/cabal-install-0.10.2/cabal-install-0.10.2.tar.gz
08:15:47 <gfredericks> so how do I get cabal? cabal website says cabal is packaged with cabal
08:15:51 <gfredericks> ah, thx
08:16:11 <danr> luite: this blog post http://random.axman6.com/blog/?p=231 uses couroutines to abstract IO away from user interaction, would such an approach work for the example you had in mind?
08:16:47 <cmccann> note that you should already have the Cabal library (used for building stuff, included with GHC), what you need is the cabal command line tool, called cabal-install to distinguish them
08:17:18 <cmccann> there should be a bootstrap shell script in that tarball
08:17:27 <cmccann> it will grab a couple dependencies for you and install them
08:17:49 <gfredericks> this readme is helpful
08:18:19 <cmccann> gfredericks, see also http://www.haskell.org/haskellwiki/Cabal/How_to_install_a_Cabal_package
08:18:36 <cmccann> which I finally managed to turn up, heh
08:19:01 <gfredericks> Setup: At least the following dependencies are missing:
08:19:01 <gfredericks> base >=4 && <3 && >=2 && <5,
08:19:01 <gfredericks> filepath >=1 && <1.3,
08:19:02 <gfredericks> unix >=2.0 && <2.5
08:19:09 <gfredericks> :/
08:19:15 <cmccann> the bootstrap script should give you all the dependencies needed to use the instructions on that wiki page
08:19:25 <gfredericks> that was the output of the bootstrap script
08:19:32 <cmccann> oh boy
08:19:55 <gfredericks> among other more innocuous things
08:20:05 <cmccann> right, nobody updated it for the stuff that's included with GHC 7.4
08:20:06 <cmccann> awesome
08:20:32 <cmccann> the wonky constraints on base look promising as well
08:20:33 * cmccann sighs
08:20:36 <gfredericks> :)
08:21:53 <gfredericks> it's like trying to compile a program in a statically-typed language
08:22:11 <cmccann> ok, sorry, had to run AFK for a moment
08:22:54 * cmccann looks at the dependencies for cabal-install
08:23:06 <cmccann> did you catch what the bootstrap script tried to install?
08:23:34 <gfredericks> shall I pastie the whole output?
08:23:38 <cmccann> sure
08:23:39 <srhb> Erm how do I trigger the monomorphism restriction again? I'm trying to demonstrate a hated feature in Haskell, but I can't seem to remember what exactly it does. Go figure. :-)
08:23:56 <gfredericks> cmccann: any reason I can't just run it again and use that output?
08:23:56 <cmccann> gfredericks, do the same for the output of "ghc-pkg list" while you're at it
08:24:37 <srhb> Oh right, I remember now
08:24:40 <cmccann> srhb, top-level bindings that look like values but depend on an instance selection
08:24:44 <luite> danr: right, that could make it easier to separate pure and io parts of the code, but the benefit looks greatest when you have some deeply nested structure
08:24:51 <cmccann> pointfree arithmetic will do it
08:25:09 <cmccann> or monadic actions (parsec parsers are a great way to see this)
08:25:27 <gfredericks> cmccann: http://pastie.org/3447357
08:25:44 <t7> why does imageData return a StorableArray (Int, Int) Word8   when each pixel is > 1 Word8
08:26:22 <luite> danr: tnx though, I'll think about it more the next time i write such an algorithm
08:26:23 <gfredericks> cmccann: http://pastie.org/3447362
08:27:08 <cmccann> ok
08:27:20 * cmccann looks at the bootstrap script
08:28:18 <efie> i have a list of list of strings, how can i print them out to the terminal?
08:28:41 <efie> * a list of lists of strings, i meant
08:29:07 <OpensHell1> so you have [[String]] ?
08:29:11 <efie> yes
08:29:22 <MostAwesomeDude> :t (unwords . unwords)
08:29:23 <lambdabot>     Couldn't match expected type `[Char]' against inferred type `Char'
08:29:23 <lambdabot>       Expected type: [String] -> [String]
08:29:23 <lambdabot>       Inferred type: [String] -> String
08:29:34 <OpensHell1> putStrLn . unlines . map unlines $ xs
08:29:38 <MostAwesomeDude> Oh, wait. I'm still asleep.
08:29:38 <hpc> :t unlines .: unwords
08:29:39 <lambdabot>     Couldn't match expected type `[String]'
08:29:39 <lambdabot>            against inferred type `Char'
08:29:39 <lambdabot>       Expected type: [String] -> [[String]]
08:29:39 <t7> why does my StorableArray have bounds of (0,0), (47,1919)
08:29:49 <t7> this is nothing close to my image bounds
08:29:50 <hpc> pah
08:30:00 <t7> anyone else used pngload?
08:30:05 <t7> im not having much luck
08:30:11 <t7> i used it fine with OGL
08:30:20 <hpc> :t unlines . map unwords
08:30:21 <lambdabot> [[String]] -> String
08:30:22 <t7> but i wanna access the data myself
08:30:52 <MostAwesomeDude> :t unwords . (map unwords)
08:30:53 <lambdabot> [[String]] -> String
08:30:59 <MostAwesomeDude> hpc: Thinking the same thing.
08:32:06 <efie> thank you
08:35:32 <quintessence> t7: what are the dimensions supposed to be?
08:35:50 <quintessence> (in particular: does that array have the right number of bytes in it?)
08:35:53 <t7> its just the x and y are the wrong way round
08:36:03 <t7> also x is * 3 for 3 channels
08:36:24 <hpc> t7: that's expected; it's an array of Word8
08:36:30 <cwb> Ok, I'm getting lost here and suspect there's a simple answer. I'm trying to install some packages with 7.4.1 and get recursive dependency errors: Cabal-1.14.0-c6d4670bd950298f6fdaae76fea539be is unusable due to missing or recursive dependencies:
08:36:32 <cwb>       directory-1.1.0.2-5ce8ec4d96e120807d0ed0cb6a25d0c4 process-1.1.0.1-dd810a368ec79f28445811c5f39bd53a
08:36:45 <hpc> not sure why it's transposed, but it could have to do with matrix math
08:36:48 <cwb> Any ideas how I might fix that?
08:38:14 <cmccann> gfredericks, still there?
08:39:59 <t7> hpc yeah its the wrong way round in memorez :(
08:40:13 <gfredericks> cmccann: yep
08:40:42 <quintessence> t7: it's the way C expects it (which is why it works for OGL)
08:40:51 <cmccann> gfredericks, so I think the dependencies on cabal-install are horked up and won't work on GHC 7.4
08:41:00 <gfredericks> w00p!
08:41:16 <t7> i duno why people dont put top left pixel at 0 :|
08:41:22 <gfredericks> makes me curious why git-annex thinks it can be installed via cabal
08:41:31 <lispy> hello
08:41:43 <elliott> cmccann: hmm?
08:41:45 <cmccann> like I said, stuff is wonky because of 7.4 being recent
08:41:45 <elliott> on cabal-install itself?
08:41:49 <elliott> gfredericks: use darcs cabal-install
08:41:51 <elliott> don't patch .cabal files or anything
08:41:58 <elliott> for cabal-install
08:42:10 <cmccann> elliott, yeah, look at http://hackage.haskell.org/package/cabal-install
08:42:19 <cmccann> particularly the dependency on unix
08:42:21 <gfredericks> darcs? I need a another package manager to get the package manager?
08:42:25 <cmccann> and what version of base that needs
08:42:51 <danr> luite: np I find couroutines quite amazing :)
08:43:20 <elliott> cmccann: yes
08:43:28 <elliott> which is why you're mean to use darcs cabal-install with 7.4 :p
08:43:41 <cmccann> elliott, gfredericks is just trying to get a haskell program built from source, and its instructions said to use GHC 7.4
08:43:58 <cmccann> and obviously expecting anything to work correctly or be simple for a newcomer right now is unreasonable
08:44:00 * cmccann sighs
08:44:12 <geekosaur> 7.4 is explicitly experimental, no?
08:44:14 <elliott> ah
08:44:30 <gfredericks> maybe 7.4 isn't necessary if I can just get cabal to work
08:45:01 * hackagebot lambda-ast 0.0.12 - Lambda Calculi Abstract Syntax Trees  http://hackage.haskell.org/package/lambda-ast-0.0.12 (JonathanFischoff)
08:45:14 <gfredericks> if I install 7.0 will the bootstrap script likely work?
08:45:32 <cmccann> I'd expect so
08:45:37 <q0tw4> 7.4 will work well if you use sources from darcs/git or sometimes fixed by hand
08:45:50 <cmccann> but at the moment I don't know if any expectation of things working is reasonable :T
08:45:58 <gfredericks> so just download and do the `make install` and it will overwrite 7.4? or do I need to cleanup 7.4 somehow?
08:46:06 <dylukes> Anyone on 7.4 running into "internal error: evacuate(static): strange closure type 603975781" all over the place?
08:47:07 <sm> gfredericks: no, just go for it
08:47:21 <gfredericks> kay, I'll do 7.0.4
08:47:43 <sm> 7.2.x is just as good I expect
08:48:01 <cmccann> gfredericks, once you have cabal-install working you can always install GHC 7.4 again
08:48:11 <gfredericks> okay 7.2.2 then
08:48:25 <cmccann> cabal-install itself will be fine, it's just the dependencies to build it fresh that are horked up
08:48:57 <sm> me, I wanted the latest cabal-install anyway, and that route was less work
08:50:48 <sm> unless I'm forgetting some cabal file tweaks.. anyway good morning all
08:51:48 <laufer> @pl \x -> (x, x)
08:51:49 <lambdabot> join (,)
08:53:19 <gfredericks> okay got 7.2.2, ran script:
08:53:20 * cmccann grumbles about how ridiculous this all is just to get basic build tools working
08:53:21 <gfredericks> Setup: At least the following dependencies are missing:
08:53:22 <gfredericks> base >=4 && <3 && >=2 && <5, unix >=2.0 && <2.5
08:53:41 <gfredericks> so that's an improvement -- we went from three lines of dep info to one
08:54:00 <nand`> Programming in front of the compiler is like physics; you observe a system, make deductions, use these to build models then find methodology to arrive at your solution. Programming (with) the compiler is like mathematics; your thoughts, your system, your rules, your experiments
08:54:42 <cmccann> gfredericks, looks like that won't work either, 7.2.2 seems to come with unix-2.5 which is the main problem here
08:54:52 <gfredericks> so 7.0.4 then?
08:55:05 <hpc> programming with an untyped interpreter is like literature
08:55:25 <cmccann> gfredericks, guess so
08:55:27 <hpc> "everything is jesus, except the boat, which is a metaphor for suffering"
08:55:31 <cmccann> that has unix-2.4.2 at least
08:56:24 <liyang> Programming with PHP is like taking a bad acid trip.
08:56:33 <gfredericks> at least this doesn't take a half an hour each time
08:58:14 <nand`> hpc: Nice one
08:58:53 <cmccann> seriously though, GHC 7.4 was released nearly a month ago, why is it apparently impossible for someone like gfredericks to get it installed and working without jumping through all these hoops?
08:59:06 <cmccann> it's kind of embarrassing.
08:59:12 <lispy> cmccann: No
08:59:15 <lispy> cmccann: Haskell platform
08:59:38 <lispy> cmccann: the ghc download page even warns people about using it if it's newer than what appears in the platform
09:00:04 <gfredericks> lispy: the HP page tells you to go get ghc
09:00:11 <lispy> The ghc release cycle is intentionally ahead of the platform release cycle so that maintainers have a chance to sort this out
09:00:47 <lispy> the tax for using a ghc that isn't in the platform is sending patches for broken builds
09:01:04 <gfredericks> w00, cabal succeeded
09:02:15 <cmccann> lispy, eh, I guess
09:02:42 <elliott> (too bad the haskell platform sucks :p)
09:02:49 <gfredericks> on the bright side, the irc channel is quite helpful :)
09:03:00 <cmccann> it still seems kind of ridiculous to me that something like cabal-install still has dependencies that are seemingly impossible to satisfy with just a fresh 7.4
09:03:06 <nand`> I tried to help some guy get his ghc installation (and xmonad) to work for like half an hour
09:03:11 <nand`> turns out he was using debian sid
09:03:17 <elliott> cmccann: cabal-install hasn't been hackage released in ages
09:03:18 <nand`> never again
09:03:22 <elliott> the darcs version contains the modular solver and stuff too
09:03:29 <elliott> it should probably be used even on 7.0.4 :P
09:03:29 <DanBurton> gfredericks: congrats
09:03:44 <gfredericks> okay -- any reason I shouldn't now cabal install git-annex --bindir=$HOME/bin ?
09:04:06 <cmccann> elliott, having to get cabal-install from darcs doesn't strike me as reasonable either
09:04:15 <DanBurton> try a --dry-run first?
09:04:19 * gfredericks doesn't even know what darcs is
09:04:19 <lispy> I think having a cabal/cabal-install mirror on hackage would help
09:04:28 <cmccann> gfredericks, a DVCS written in haskell
09:04:39 <gfredericks> ah ha
09:04:45 <bartavelle> I'm not sure if this is relevant or not, but if you are into using other peoples binaries, here is ghc 7.4 + cabal built on lucid : http://www.banquise.net/bin/ghc-7.4.1-with-cabal.7z
09:04:49 <lispy> believe it or not, linus looked at darcs before making git
09:05:11 <gfredericks> and it wasn't sufficient?
09:05:16 <DanBurton> darcs is the Haskell version of git. meaning: really neat, with small cult fanbase
09:05:23 <gfredericks> :)
09:05:37 <gfredericks> the --dry-run didn't do anything disturbing, so on to the wet run
09:05:53 <lispy> Darcs at the time had really bad performance (still does for some things) and he wanted something that was good at a particular workflow
09:06:27 <lispy> He liked monotone but it was in C++ and the lead dev was on vacation when he tried to approach them
09:06:36 <lispy> But now who knows about monotone?
09:06:53 <Clint> unfortunately some people are still using monotone
09:07:15 <DanBurton> unfortunately some people are still using CVS and SVN
09:07:23 <lispy> cult of linus really did a number on the dvcs ecosystem
09:07:40 <lispy> For me though, it's all about github
09:08:04 <lispy> If github used hg I'd probably be using it instead
09:08:05 <hpc> DanBurton: svn isn't so bad
09:08:11 <Clint> sadly svn is going to be around as long as people need centralized access control
09:08:21 <tgeeky_> uhhh
09:09:39 <dolio> lispy: You could use bitbucket.
09:10:06 <lispy> dolio: I've never actually used hg; I meant I would have switched from darcs to hg if hghub was the cool site
09:10:15 <dolio> Oh.
09:10:23 <dolio> Isn't patchtag cool enough for you? :)
09:10:40 <lispy> Oh boy, I don't want Thomas Hartman to hear me say "no" :)
09:10:49 <lispy> He's a nice guy, but github is simply better
09:10:57 <dolio> There's, like, a bunch of nethack repositories on there.
09:10:58 <Phlogistique> dolio: patchtag is a site for hosting code; github is a social network.
09:11:14 <dolio> Oh. Great.
09:11:27 * shergill heard from a friend that with darcs it's not really easy to to resurrect the copy of your working tree as it was at a particular time. is that true?
09:11:44 <lispy> shergill: compared to git yes
09:11:55 <Phlogistique> how so?
09:12:01 <Clint> compared to git nothing in darcs is really easy
09:12:13 * nand` <3 git
09:12:25 <Phlogistique> Clint: uh? I think the whole point of Darcs was being easier than git
09:12:34 <lispy> shergill: the reason it's hard in darcs is that history gets rewritten when merging
09:12:37 <elliott> wat
09:12:40 <elliott> darcs predates git by three years
09:12:41 <Clint> darcs predates git by far
09:12:44 <elliott> erm two
09:12:53 <elliott> in fact darcs was the second open-source DVCS iirc
09:13:01 <Phlogistique> s/the point of darcs/\0 nowadays/
09:13:02 <lispy> shergill: More specifically, the order of updates can be reordered as long as the result is equivalent
09:13:13 <elliott> i think patch theory is as equally prominent if not moreso nowadays
09:14:15 * mrcarrot wonders when darcs will be ready for real use...
09:14:24 <lispy> shergill: Anyway, in darcs its still possible but the name of that "state" is much larger.  It's a list of the history in a special format known as the "context"
09:14:32 <shergill> lispy: hmm wouldn't the 'result is equivalent' criterion ensure that it'd be easier (instead of more difficult) to resurrect your copy of the working tree as it was at a particular time?
09:15:05 <lispy> shergill: You would think so, but the notion of what came before and after is lost when you reorder things
09:15:44 <rwbarton> Who can really say whether git came "before" or "after" darcs, then.
09:16:00 <lispy> heh
09:16:12 <shergill> lispy: right so in darcs you have to specify more than a time, you want to specify the set of commits at that time
09:16:27 <lispy> Darcs should be able to just cherry pick the parts of git that are good :) (joking aside, that does happen)
09:16:46 <shergill> that doesn't seem like a hard thing to maintain, but perhaps i'm getting something wrong
09:17:20 * cmccann considers trying to install xmonad this weekend
09:17:20 <hpc> rwbarton: easy; you just rewrite history :D
09:17:52 <mrcarrot> cmccann: that is a good decision
09:19:06 <cmccann> mrcarrot, I had a program on Windows that I used as a sort of "manual tiling window manager" and I really miss it on linux so I'm thinking I should probably just go all in and use xmonad :P
09:19:43 <elliott> you won't regret it
09:19:44 <elliott> probably
09:19:49 <elliott> I didn't, at leat
09:19:52 <elliott> *least
09:20:02 <mrcarrot> cmccann: if you want my quick 'n dirty configuration, pm me...
09:20:02 <rwbarton> elliott won't regret you switching to xmonad.
09:20:08 <cmccann> haha
09:20:08 <elliott> Exactly.
09:20:16 <mrcarrot> i am addicted to tiling wm
09:20:17 <tgeeky_> cmccann: actual window manager?
09:20:20 * shergill tried xmonad once. it was too extreme a change; migrated to awesome instead
09:20:30 <cmccann> tgeeky_, hm?
09:20:44 <tgeeky_> cmccann: there's a great (but nonfree) window manager called "actual window manager" for windows
09:20:46 <sm> Clint you nut, there are many things far easier in darcs than in git
09:20:49 <elliott> shergill: yeah, lua instead of haskell... much easier :P
09:21:08 <tgeeky_> cmccann: I liked it so much I paid for it
09:21:16 <shergill> elliott: not a fan of the language. but more the design decisions. i like having a bit of mouse control
09:21:23 <cmccann> tgeeky_, oh, no, it was a program that let me define a bunch of keyboard shortcuts for positioning and sizing windows
09:21:24 <shergill> and being able to have floating windows
09:21:26 <MostAwesomeDude> Awesome isn't about the configuration, IMO; it just worked out for me the best out of the tiling WMs I tried.
09:21:35 <Clint> sm: like accidentally recording the output of compilation :P
09:21:41 <tgeeky_> cmccann: it does that. not quite as well as that keyboard scripting language for windows
09:21:44 <MostAwesomeDude> I *loathe* Lua, but whatever. It seems like every tiling WM has weird configuration files.
09:21:45 <cmccann> and I mostly used it to rapid-fire shuffle things into quadrants/columns/&c. as needed
09:22:13 <shergill> tgeeky_: autohotkey?
09:22:19 <tgeeky_> shergill: that's the one
09:22:41 <mrcarrot> i tried awesome once... and i thought it was really sluggish. i went straight to dwm, used it for pretty long time until i gained again interest for haskell and a switch was not possible to avoid
09:22:44 * cmccann can't recall what the program he had was called
09:22:58 <MostAwesomeDude> dwm/wmii are too minimal. Totally unusable.
09:23:02 <sm> Clint: pff I've never done that
09:23:09 <Clint> i do it practically every day
09:23:09 <cmccann> but I got really addicted to having my windows non-overlapped and organized neatly
09:23:29 <mrcarrot> dwm is definitely usable
09:23:33 <sm> Clint: how ? do you add -r a lot ?
09:24:01 <MostAwesomeDude> mrcarrot: We'll have to agree to disagree, then. BTW, when you say "sluggish," how do you mean? You might have had a less-than-optimal X setup.
09:24:03 <Clint> -a -l -m "blah"
09:24:35 <mrcarrot> MostAwesomeDude: just really old computers... such that i got for free because nobody wants them.
09:24:53 <MostAwesomeDude> mrcarrot: Probably shitty video cards. Happens.
09:25:11 <sm> Clint: ok if you do that you need to be configuring your boring file no ?
09:25:42 <mrcarrot> MostAwesomeDude: of course... but a wm should behave well even like that. and the memory usage was pretty high with awesome. i am not against awesome, but it was not for me at that point
09:25:51 <Clint> sm: that doesn't sound easier than git
09:26:00 <mrcarrot> and now i have a nice wm written in haskell, what could be better?
09:26:16 <tazjin> I'm trying to create an instance of Text.JSON.JSON for Text to use it with Text.JSON.Generic. Basic serialization works with this: http://hpaste.org/64281 but toJSON and fromJSON from Text.JSON.Generic don't work with this. Can I fix that?
09:26:17 <sm> ok, but I stand by my claim
09:26:23 * Clint chuckles.
09:27:11 * shergill checks his awesome memory usage: 11.5 mb
09:27:19 <sm> there *are* many things easier in darcs. I insist :)
09:27:28 <MostAwesomeDude> mrcarrot: Well, the WM shouldn't really influence general responsiveness, and I run awesome on a variety of hardware and haven't seen anything I'd consider sluggish. I'm not saying that you didn't have issues, but maybe the issues were with something else in/on your system.
09:27:36 <MostAwesomeDude> mrcarrot: But if you're happy with what you've got, then whatever.
09:28:07 <shergill> sm: for the curious, like what?
09:28:28 <shergill> i would imagine reordering commits would be easier
09:28:33 <sm> for one, simply the conceptual model. darcs' is far simpler for non-experts to grok
09:28:33 <shergill> than say running rebase --interactive
09:28:59 <tgeeky_> is it possible for someone to say 'for non-experts to grok'
09:29:05 <tgeeky_> why, yes it is
09:29:11 <sm> course it is
09:29:22 * cmccann should try darcs at some point, since he certainly doesn't understand git's conceptual model
09:29:48 <tgeeky_> i don't think that there's so much a conceptual model, as a model
09:29:55 <gfredericks> cmccann: git's the simplest thing! mutable references, immutable objects, directed acyclic graph...
09:29:55 * Clint twitches.
09:30:00 <tgeeky_> there are some good documents on git's internals though
09:30:10 <cmccann> gfredericks, ok then. :T
09:30:17 <gfredericks> I think the git internals are easier to understand than the CLI :)
09:30:18 <cmccann> gfredericks, speaking of which, did you get the install to work?
09:30:26 <hpaste> DanBurton pasted “Category .: challenge” at http://hpaste.org/64282
09:30:34 <gfredericks> git-annex-3.20120123 depends on pcre-light-0.4 which failed to install.
09:30:43 <cmccann> hooray
09:30:59 <shergill> http://sitaramc.github.com/gcs/
09:31:06 <shergill> git for computer scientists
09:31:34 <cmccann> shergill, sounds promising
09:31:37 * cmccann bookmarks
09:32:02 <elliott> cmccann: i recommend http://perl.plover.com/yak/git/
09:32:10 <elliott> for understanding git's underlying model
09:32:18 <elliott> note: it's stupid... but it works
09:32:21 <cmccann> heh
09:32:41 <cmccann> well, I do have some rough idea of the underlying model, glib remarks to the contrary. not a deep understanding, but something.
09:32:59 <cmccann> what I really never got the hang of is how that relates to using the actual CLI commands
09:33:29 <gfredericks> yeah the CLI can be confusing
09:34:00 <gfredericks> but I suspect Scott Chacon's Strange Loop talk might clear some of it up
09:34:01 <cmccann> DanBurton, btw, I doubt that's going to be possible
09:34:14 <gfredericks> pcre-light-0.4 failed during the configure step. The exception was:
09:34:16 <gfredericks> ExitFailure 1
09:34:21 <elliott> gfredericks: hpaste full output
09:34:21 <cmccann> heh
09:34:24 <elliott> that just tells us somethign went wrong, not what
09:34:25 <DanBurton> cmccann: I'm tending to get the same idea >,< but I don't quite understand why
09:34:39 <gfredericks> elliott: I don't see anything else helpful
09:34:42 <shergill> cmccann: using something like magit really makes dealing with git easier
09:34:46 <shergill> easier than the cli, i feel
09:34:56 <cmccann> DanBurton, Category alone doesn't give you first-class "functions"
09:35:10 <elliott> gfredericks: if you want help, hpaste the whole log... otherwise nobody can help at all
09:35:12 <cmccann> so in general you can't do anything useful with stuff like (cat a (cat b c))
09:35:24 <elliott> (what's the topic?)
09:35:35 <rwbarton> DanBurton: the kind of the arguments a and b in "cat a b" need not even be *
09:35:59 <DanBurton> rwbarton: wat o_O
09:36:11 <rwbarton> I mean you could have a class Category (cat :: (* -> *) -> (* -> *) -> *) where ... with the same definition
09:36:19 <rwbarton> now your (.:) doesn't even kind check
09:36:29 <rwbarton> so clearly, you can't implement (.:) in terms of Category methods
09:36:40 <DanBurton> mind = blown
09:36:51 <DanBurton> but thanks, that makes a lot of sense
09:37:26 * cmccann suspects that DanBurton would need something like ArrowApply to write that
09:37:49 <cmccann> though Arrow carries a lot of extra baggage that isn't needed
09:37:49 <gfredericks> I think it is working.
09:38:17 <DanBurton> I'm writing a pet Prelude, and my rule of thumb is that all operators must be typeclassed
09:39:08 <cmccann> DanBurton, you might want to skim some basic category theory to figure out how things fit into place with that
09:39:17 <cmccann> but Category itself is extremely limited
09:39:24 <gfredericks> cmccann: holy crap it worked. Much thanks.
09:39:46 <cmccann> gfredericks, no prob
09:39:55 * cmccann still thinks it should have been much easier to begin with
09:40:07 <gfredericks> making things easy is hard
09:41:21 <cmccann> DanBurton, but if you really want nice generic versions of stuff like (.:) you're going to hit the fact that Arrow is silly and awkward while Category is very minimal
09:41:55 <DanBurton> "arrow is silly and awkward"?
09:42:27 <DanBurton> elaborate
09:43:06 <hpc> DanBurton: the presence of arr pushes arrows into uncomfortable design decisions
09:43:09 <hpc> :t arr
09:43:10 <lambdabot> forall b c (a :: * -> * -> *). (Arrow a) => (b -> c) -> a b c
09:43:26 <cmccann> DanBurton, mostly because of "arr". it's hard to do anything interesting with generic Arrow combinators that doesn't boil down to writing it for functions and using "arr"
09:43:35 <hpc> you HAVE to have some way to transform an arbitrary function into an arrow
09:43:43 <cmccann> on the other hand Arrow still doesn't allow currying
09:43:44 <hpc> and most of the arrow code breaks if you don't
09:44:01 <hpc> :t curry
09:44:01 <lambdabot> forall a b c. ((a, b) -> c) -> a -> b -> c
09:44:16 <cmccann> for that you need ArrowApply, at which point you've got something basically equivalent to a monad
09:44:31 <hpc> in which case, just use Monad
09:44:38 <hpc> (<=<) works just as well as (<<<)
09:45:34 <cmccann> DanBurton, so basically there's not much point to defining generic Arrow functions, except for a few that are simple and common
09:45:44 <cmccann> I tend to do "fst = arr Prelude.fst" and such
09:46:07 <cmccann> but that's about it
09:46:16 <DanBurton> interesting. thanks for the elaboration :)
09:46:37 <cmccann> (note that fst would be a primitive in a less-silly Arrow that didn't include arr)
09:47:47 <cmccann> fst, snd, and (&&&) are what you need for Category + tuples to work in the expected way
09:48:10 <elliott> (...but you also want associative laws and cancellation of units!)
09:48:23 <DanBurton> well, when I say I'm writing a pet Prelude, I mean I'm writing a pet every single library ever, based on GHC.Exts -- so I'll probably try rewriting the Arrow libraries while I'm at it xD
09:49:01 <nand`> is anybody *not* writing a pet Prelude?
09:49:19 <elliott> me
09:49:28 <geekosaur> are pet preludes the new monad tutorials?
09:49:31 <cmccann> elliott, I think that's a given with fst/snd/(&&&)
09:49:32 <DanBurton> nand`: it's the next rite of passage after writing a monad tutorial
09:49:44 <cmccann> elliott, you only need those separately if you're using (***)
09:50:06 * hackagebot LambdaPrettyQuote 0.0.0.8 - Quasiquoter, and Arbitrary helpers for the lambda calculus.  http://hackage.haskell.org/package/LambdaPrettyQuote-0.0.0.8 (JonathanFischoff)
09:50:12 <cmccann> i.e. I'm skipping past the GArrow stuff to something more powerful :P
09:50:15 <elliott> cmccann: I don't agree...
09:50:19 <nand`> DanBurton: makes sense. What comes afterwards?
09:50:28 <elliott> well hmm
09:50:29 <nand`> Proposing a language extension?
09:50:32 <DanBurton> nand`: um...pet Haskell compiler?
09:50:38 <elliott> cmccann: no, not quite
09:50:41 <elliott> cmccann: because there is no way to get a constant () in
09:50:47 <elliott> you still need a ~> (a,()) or such
09:50:55 <elliott> but yes, then you can build the rest up from that I think
09:52:26 <cmccann> elliott, wouldn't (a ~> ()) be what you need?
09:52:50 <elliott> cmccann: oh. yes. since you have information loss already
09:53:04 <elliott> cmccann: ...have fun as soon as you want to model e.g. linear lisp or such :)
09:53:38 <cmccann> linear as in linear logic? :P
09:54:00 <elliott> http://www.pipeline.com/~hbaker1/LinearLisp.html etc.
09:54:06 <elliott> where (a ~> ()) is *not* ok, you throw away the a
09:54:19 <elliott> (GArrows can support this since it has duplication and discarding of information in separate classes)
09:54:19 <cmccann> fst and snd aren't any better :P
09:54:26 <elliott> right, that's what i meant by you already have it
09:54:51 <cmccann> and yes, I'm defining a categorical product, which is the "expected" behavior of tuples
09:55:43 <srhb> Is there a read that returns a maybe something?
09:55:48 <cmccann> and linear logic models a category with products and coproducts so what's the problem :P
09:56:00 <hpc> :t reads -- srhb
09:56:01 <lambdabot> forall a. (Read a) => String -> [(a, String)]
09:56:12 <cmccann> srhb, https://github.com/isomorphism/Overture/blob/master/src/Overture/Data.hs#L117
09:56:15 <cmccann> ;]
09:56:32 <elliott> srhb: yes, reads, pretend the [] is a Maybe
09:56:34 <elliott> historical reasons
09:56:44 * cmccann thinks readEither is nicer
10:01:44 <cmccann> elliott, incidentally, do you know if the GArrow stuff works with a full model of linear logic? it seems to be heading that way but I wasn't sure if it could express everything properly
10:02:40 <elliott> i think so, yes.
10:02:44 <elliott> it might be one of the examples
10:02:45 <cmccann> wasn't sure how the exponential operators would fit in, for instance
10:02:59 <elliott> well you don't have to do them, necessarily
10:03:02 <elliott> have you seen the diagrams? they're cool
10:03:11 <elliott> http://www.cs.berkeley.edu/~megacz/garrows/flattening.examples/index.html
10:03:21 <cmccann> and it doesn't seem to have any way to talk about linear negation, though that's not required I guess
10:03:38 <elliott> cmccann: well you just add specific features as new typeclasses
10:03:44 <elliott> the compiler only has to know about the few primitive classes
10:04:22 <cmccann> yeah, but this is stuff that'd expect to be primitive
10:04:36 <cmccann> or to be necessary for desugaring linear programs
10:04:37 * cmccann shrugs
10:04:45 <cmccann> I didn't spend much time looking at it
10:05:43 <cmccann> it also seems to be conflating structural rules with connectives, e.g. GArrowDrop and GArrowCopy are used to describe products and coproducts
10:06:22 <elliott> well
10:06:25 <elliott> look at http://git.megacz.com/?p=ghc-base.git;a=blob;f=GHC/HetMet/GArrow.hs;h=4649ad06f9685a3ef4a1480b6e6a046aa5a39265;hb=HEAD for the actual definitions
10:07:04 <elliott> also, this is fun: http://git.megacz.com/?p=ghc-base.git;a=blob;f=GHC/HetMet/GArrowFullyEnriched.hs;h=b24c6b6febf14974313968288e0fcdcb99b87d93;hb=HEAD
10:07:44 <cmccann> and yeah, I saw the definitions
10:10:03 <cmccann> elliott, anyway, the GArrow stuff is neat anyway, I'm just not sure if it would work well for modeling full linear logic
10:11:01 <elliott> yeah, perhaps not
10:11:03 <elliott> closer, though :P
10:11:17 <cmccann> well, yeah
10:11:20 <cmccann> but that's not hard :P
10:12:21 <scooty-puff> does anyone have any experience using shake?
10:12:27 <cmccann> but linear logic is one of my current fascinations so it's the main thing I was hoping for :[
10:13:09 <scooty-puff> i have a project that includes a cabal package (executable), some java code, and something that requires the executable from the cabal package - this sounds like an appropriate use of shake to me
10:14:05 * cmccann heads out to grab lunch
10:14:19 <scooty-puff> just wasn't sure if any shortcuts to  the cabal stuff - could just do a system call to cabal configure, build, etc., but would be nice if other means too (though by far not necessary)
10:18:18 <keep_learning> Hello all
10:20:18 <keep_learning> I am trying to install ghc HEAD ( http://www.haskell.org/ghc/dist/current/dist/ ) for Mac OS X 10.7.3
10:20:39 <keep_learning> Could some one  please tell me which package I should install ?
10:39:48 <greglnelson> i have just finished learn you a haskell for great good, which book should i go to next? i ultimately want to do some web FRP type stuff
10:40:41 <greglnelson> i am very thankful for haskell community report http://www.haskell.org/communities/11-2011/html/report.html there are just so many different resources i feel overwhelmed
10:40:44 <hpc> greglnelson: wikibook, perhaps
10:40:49 <hpc> @where wikibook
10:40:49 <lambdabot> http://en.wikibooks.org/wiki/Haskell
10:40:52 <hpc> @where rwh
10:40:52 <lambdabot> http://www.realworldhaskell.org/blog/ http://book.realworldhaskell.org/read/
10:41:37 <hpc> i can't really help with FRP, but there's some cool CPS tricks you can apply to web dev
10:41:57 <greglnelson> like seaside, to resume on server side?
10:42:48 <hpc> greglnelson: dunno what "seaside" means
10:43:25 <greglnelson> its a smalltalk web framework http://en.wikipedia.org/wiki/Seaside_%28software%29
10:43:53 <greglnelson> thank you for your help hpc!
10:44:10 <hpc> greglnelson: actually, exactly like that
10:45:29 <hpc> there's also tricks you can use to auto-close HTML tags, backtrack to a 500 page, etc
10:46:31 <Clint> how should i go about debugging a stack overflow?
10:47:14 <hpc> Clint: look for places where to evaluate something, you need to evaluate lots of other stuff
10:47:45 <hpc> Clint: lemme find a link, sec
10:48:22 * Clint was hoping there was some switch to flip to be told "you have a million event handlers" or something
10:48:25 <hpc> http://blog.ezyang.com/2011/04/the-haskell-heap/
10:48:52 <dmwit> Clint: Got any loops that are counting up by adding one to a variable? That's a common spot.
10:49:07 <dmwit> Basically any accumulator on a "strictish" type.
10:49:22 <Clint> there are loops but they aren't counting
10:50:06 <darkb> Hey, I was trying GHC as a library (http://www.haskell.org/haskellwiki/GHC/As_a_library), and I'm curious to know if it's possible to load haskell modules into the current session, so it's accessible from other parts of the program
10:50:08 <hpaste> Clint pasted “stack overflow suspect” at http://hpaste.org/64283
10:50:14 <Clint> i'm guessing that the problem is there
10:50:51 <darkb> Currently the loaded Modules are only visible within the runGhC scope
10:53:21 <Claudius1aximus> @where rts-xc
10:53:21 <lambdabot> ghc --make -prof -auto-all -rtsopts -osuf .p_o foo.hs && ./foo +RTS -xc
10:53:57 <sclv> You can sorta load modules dynamically using, e.g. hsplugins and related.
10:54:02 <Claudius1aximus> or is stack overflow not an exception so that wouldn't help, hmm
10:54:17 <darkb> @sclv I want to do it using GHC APIs
10:54:17 <lambdabot> Unknown command, try @list
10:55:42 <sclv> well you can't directly.
10:55:55 <darkb> what do you mean by "directly" ?
10:55:56 <sclv> you use a package like hsplugins designed to do it.
10:56:02 <sclv> as in using the ghc apis alone
10:56:16 <sclv> you need some extra work on top of them. which is precisely what hsplugins gives you.
10:56:19 <darkb> Hmm, but hsplugins is built on GHC APIs
10:56:34 <sclv> headdesk
10:56:37 <geekosaur> it usee that to get symbols
10:56:50 <geekosaur> ggetting symbols is only part f what is needed, and ghc-api doesn't provide the rest
10:57:25 <geekosaur> (more precisely ghc-api is used to read .hi files)
10:58:58 <darkb> I'm not following
10:59:55 <darkb> I can load the modules in a new session, and invoke functions from there as long as I'm within runGhc scope
11:00:24 <darkb> I want to do the same, but just load them into the current session
11:00:36 <darkb> I assume there is a way to do that using GHC APIs
11:00:42 <darkb> GHCi already does this
11:01:23 <geekosaur> ghci includes its own linker, which is not part of ghc-api
11:01:43 <geekosaur> (this is also why ghci isn't availabhle on all the platforms ghc and ghc-api are)
11:02:48 <darkb> OK .. so How hs plugins are going to solve my problem then? are they providing some sort of a linker, or they are running everything inside a runGhc call ?
11:03:22 <darkb> This was my next attempt .. to run everything inside runGhc
11:04:02 <geekosaur> hs-plugins uses dlopen() which is provided by the system
11:04:14 <geekosaur> (making ghci do so is an open bug)
11:04:48 <darkb> @ geekosaur, Thanks for the answer. do you have any link that explain this in more details ?
11:05:07 <darkb> ( GHCi Linker I mean)
11:05:25 <darkb> I'm grabbing hs plugins sources now to take a look
11:05:52 <geekosaur> there are details on the ghc trac
11:06:08 <darkb> what is the status of hs plugins ? I read on stackoverflow it's problematic, the author didn't elaborate on what is problematic in plugins
11:06:14 * geekosaur not sure he can get link right now, somewhat mobile
11:06:35 <geekosaur> hs-plugins used to be problematic because it rolled its own .hi file parser that broke with every new ghc release.
11:06:37 <darkb> ok .. thanks . I'll google it
11:06:47 <geekosaur> it uses ghc-api for that now, so it doesn't break any more
11:06:54 <darkb> Good
11:08:02 <darkb> I'll try to write a sample code to run everything inside a runGhc call, and will see how things will go
11:10:27 <darkb> btw, when I call setSessionDynFlags with packageFlags = [ExposePackage "ghc"]  I was getting duplicate symbol error
11:10:41 <darkb> that was when I ran it from ghci
11:11:12 <monochrom> geekosaur: that is old information. http://hackage.haskell.org/packages/archive/plugins/1.5.1.4/doc/html/System-Plugins-Load.html is purely ghc-api, no dlopen
11:12:01 <monochrom> I mean http://hackage.haskell.org/packages/archive/plugins/1.5.1.4/doc/html/src/System-Plugins-Load.html
11:12:25 <Clint> Claudius1aximus: that's interesting.. i get a huge amount of output before any exception
11:13:19 <darkb> @ monochrom Thanks I'm grabbing hs plugins code now, I'll go though it soon
11:13:28 <Claudius1aximus> Clint: yeah it spits out a trace on every exception, but i don't think stack overflow is an exception so it might not be that useful
11:13:42 <sclv> monochrom: I see a few C imports hanging out at the bottom of that file.
11:15:33 <hpaste> Clint pasted “RTS-xc” at http://hpaste.org/64284
11:15:44 <monochrom> they belong to GHC RTS
11:15:46 <Clint> ClaudiusMaximus: i get that without any obvious exception
11:16:26 <monochrom> see for example your lib/ghc-7.0.3/include/rts/Linker.h
11:16:32 <Enigmagic> ClaudiusMaximus: stack overflow throws an exception
11:17:24 <ClaudiusMaximus> Enigmagic: oo, cool - catchable?
11:17:47 <ClaudiusMaximus> Clint: i think it's printed when thrown, before it's caught/handled
11:17:50 <Enigmagic> ClaudiusMaximus: i would imagine so but i haven't tried
11:18:03 <Clint> hmm
11:18:10 <Enigmagic> -xc prints when it's thrown not when it's caught (or not caught)
11:18:22 <Enigmagic> there is a global unhandled exception handler that you can use to print uncaught exceptions
11:18:52 <Enigmagic> :t setUncaughtExceptionHandler
11:18:53 <lambdabot> Not in scope: `setUncaughtExceptionHandler'
11:19:03 <Enigmagic> :t GHC.Conc.setUncaughtExceptionHandler
11:19:04 <lambdabot> (GHC.Exception.SomeException -> IO ()) -> IO ()
11:20:28 <monochrom> then, look at GHC-API's ObjLink module to see that it is the same C imports
11:22:20 <Clint> so it doesn't memory-bloat when i'm using +RTS -xc, but it does when i don't
11:22:22 <Clint> what could that mean?
11:27:04 <jfischoff> Anyone know the best way to determine the kind of a PlainTV with Template Haskell?
11:27:38 <Enigmagic> Clint: are you throwing exceptions at all?
11:28:04 <Clint> not right now
11:28:35 <Clint> it's just behaving with -xc and sucking up memory like crazy without
11:29:22 <Enigmagic> have you tried heap profiling?
11:29:46 <Clint> no i have not
11:29:53 <Enigmagic> that's what i'd start with
11:30:09 <Enigmagic> stack overflows typically mean you have a big thunk chain
11:30:30 <Enigmagic> if -xc isn't helpful then perhaps some other clues will show up in the heap profile
11:34:24 <Clint> (550)onAmi/pluginLoop/initPlugin/main   214034640
11:34:54 <Clint> so what's that telling me?
11:35:43 <Enigmagic> install hp2pretty and look at the output svg chart instead
11:49:32 <RomyRomy> hm, a question on the term 'syntactic sugar' for programming in general--- would you say this word encompasses the parentheses and semicolon in, for example "orchid();"
11:49:55 <mauke> no
11:50:16 <c_wraith> syntactic sugar means "things that are shortcuts for other syntax the language has"
11:50:26 <byorgey> RomyRomy: no, because the parentheses and semicolon cannot be translated into other, simpler syntax.
11:51:12 <faj> you could just skip the semicolon
11:51:30 <c_wraith> faj: depends on the language.  not true in C.
11:52:22 <lukish> How can I calculate permutation? f ["a", "b", "c"] ["c", "a", "b"] == [2, 3, 1]
11:52:26 <RomyRomy> c_wraith and byorgey  i see, thank you
11:52:45 <mauke> @hoogle findIndex
11:52:45 <lambdabot> Data.List findIndex :: (a -> Bool) -> [a] -> Maybe Int
11:52:45 <lambdabot> Data.ByteString.Char8 findIndex :: (Char -> Bool) -> ByteString -> Maybe Int
11:52:45 <lambdabot> Data.ByteString.Lazy.Char8 findIndex :: (Char -> Bool) -> ByteString -> Maybe Int64
11:54:24 <mauke> :t let f xs ys = mapMaybe (\x -> elemIndex x ys) xs in f
11:54:25 <lambdabot> forall a. (Eq a) => [a] -> [a] -> [Int]
11:55:05 <mauke> :t let f xs = flip mapMaybe xs . flip elemIndex in f
11:55:06 <lambdabot> forall a. (Eq a) => [a] -> [a] -> [Int]
11:55:13 <byorgey> > let f xs ys = mapMaybe (\x -> elemIndex x ys) xs in f ["a","b","c"] ["c", "a", "b"]
11:55:14 <lambdabot>   [1,2,0]
11:55:16 <mauke> > let f xs = flip mapMaybe xs . flip elemIndex in f "abc" "cab"
11:55:17 <lambdabot>   [1,2,0]
11:55:19 <byorgey> nice!
11:55:25 <losvedir> :t mapMaybe
11:55:26 <lambdabot> forall a b. (a -> Maybe b) -> [a] -> [b]
11:55:57 <mauke> > let f xs = succ . flip mapMaybe xs . flip elemIndex in f "abc" "cab"
11:55:57 <lambdabot>   No instance for (GHC.Enum.Enum [GHC.Types.Int])
11:55:58 <lambdabot>    arising from a use of `G...
11:56:03 <adimit> mapMaybe is basically catMaybes.map
11:56:05 <hpaste> antonh_ pasted “compile error” at http://hpaste.org/64286
11:56:14 <mauke> > let f xs = flip mapMaybe xs . flip elemIndex in succ . f "abc" "cab"
11:56:15 <lambdabot>   [2,3,1]
11:56:17 <byorgey> instead of mapMaybe it might make more sense to use mapM
11:56:28 <dmwit> > let f = map snd . sort . flip zip [1..] in f "cab"
11:56:29 <antonh_> can you help me figure out what is wrong with my function?
11:56:29 <lambdabot>   [2,3,1]
11:56:34 <mauke> antonh_: precedence
11:56:43 <mauke> antonh_: you're trying to redefine (:)
11:56:46 <mauke> well, no
11:57:00 <mauke> you're trying to pattern match using (:) but 'createOrder a x' is not a valid pattern
11:57:04 <byorgey> antonh_: a pattern like  x:xs  must be in parentheses
11:57:33 <byorgey> mauke is talking like an unhelpful compiler
11:58:16 <mauke> you have to learn to think like a compiler in order to defeat the compiler
11:58:35 <monochrom> I wouldn't say unhelpful. you need to know what the computer sees.
11:58:54 <antonh_> i added parenthesis now and got another error, i'll probably figure the rest out by myself. thank you :)
11:59:27 <monochrom> "a" vs "ant"
11:59:30 <byorgey> antonh_: note also  [foo] ++ blah  is better written   foo : blah
11:59:47 <mauke> also that thing is a map
12:00:03 <byorgey> so it is
12:00:46 * shergill adds parentheses when in dout
12:00:48 <antonh_> monochrom, yeah, you where right on that. it compiles now
12:00:50 <shergill> *doubt
12:01:16 <antonh_> mauke, how could i do that with map?
12:01:34 <mauke> createOrder = map . Order
12:01:45 <mauke> @unpl createOrder = map . Order
12:01:45 <lambdabot> createOrder c = map ((Order) c)
12:01:47 <antonh_> and do i gain anything by doing it with map?
12:01:57 <mauke> obviously correct code
12:02:01 <mauke> also easier to understand
12:02:02 <byorgey> much shorter code
12:02:23 <ChristianS> shergill: adding parentheses when in doubt is a good first step, but as second step you can use hlint which will tell you when you can safely remove the parentheses
12:02:56 <dmwit> code reuse leads to fewer bugs because 1. you don't screw up the copy and paste process and 2. a fix to the central code fixes bugs in all uses
12:03:35 <dmwit> I suppose this presupposes the judgment "fewer bugs is better".
12:03:52 <c_wraith> dmwit: except when you're reusing code that actually should be doing different things, and your bug fixes for one case break the other case.
12:04:20 <c_wraith> lesson learned from running into this in practice - only re-use code when you're actually sure it is correct
12:04:23 <monochrom> code reuse leads to more bugs because of wrong reuses
12:04:36 <adimit> dmwit: unless you're an entomologist, less bugs is always persumed to be good!
12:04:41 <ddarius> Programmer's lead to the most bugs.
12:04:56 <c_wraith> what? users lead to all bugs
12:05:03 <dmwit> ddarius: Here comes an 's'!
12:05:07 <c_wraith> if they didn't use it like that, the bug wouldn't be a problem
12:05:30 <monochrom> computers lead to all bugs.
12:05:30 <dmwit> main = map 3 -- code reuse, babay!
12:06:18 <monochrom> what is babay? :)
12:06:28 <antonh_> haha! createOrder is completely redundant :)
12:06:31 <byorgey> how is babay formed?
12:06:41 <dmwit> It's a stylized pronunciation, GOSH
12:07:00 <monochrom> you, what, pronounce IRC content?!
12:07:12 <dmwit> You don't?
12:07:17 <monochrom> I don't
12:07:42 * byorgey sometimes even subvocalizes things he is typing in IRC
12:08:06 <monochrom> f ["a","b","c"] ["c", "a", "b"]  <--- pronounce this
12:08:26 <mauke> ᵖʳᵒⁿｏｕｎce sı̣ɥʇ
12:10:15 <dmwit> pronouns: this, that, these
12:10:41 <hpc> pronou!
12:10:52 <int> Hi, I have a question. What is faster to manipulate? a lazy bytestring or a strict bytestring?
12:10:57 <mauke> int: no
12:11:05 <hpc> int: depends
12:11:17 <hpc> see also: mauke's answer :P
12:11:32 <mauke> int: I also have a question. what is longer? a lazy bytestring or a strict bytestring?
12:11:45 <geekosaur> :)
12:11:53 <monochrom> I think lazy bytestring is more environmentally friendly
12:12:11 <geekosaur> sometimes
12:12:18 <monochrom> but "strict" is one letter longer than "lazy"
12:13:01 <int> sorrt, I'm new to haskell..   suppose the byte sequences are the same length. does it matter? what are the differences?
12:13:15 <hpc> int: a lazy bytestring is a list of strict bytestrings
12:13:47 <hpc> so a lazy bytestring can represent an infinite stream or something like that
12:13:49 <ChristianS> strict bytestrings are notably faster as keys in maps and such. lazy bytestrings are often better (less memory, possibly higher speed) for IO, especially if your files may get large.
12:13:53 <hpc> and can sometimes do other sharing stuff
12:13:56 <monochrom> you need to describe a specific task before it is sensible to ask which approach is better
12:14:03 <byorgey> int: the point is that asking "which is faster" does not make any sense outside of a particular context.  If you show us some code we might be able to help you figure out whether you should use strict or lazy bytestrings in that particular context.
12:14:18 <ddarius> monochrom: Two tasks.
12:16:25 <monochrom> why two tasks?
12:21:37 <ddarius> monochrom: Comparatives usually need two (or more) objects.
12:22:19 <monochrom> yes, one task, two approaches, evaluate which of the two approaches is better for that task
12:23:07 <dmwit> twotypesonetask.com
12:23:19 <dmwit> for some dirty, dirty curry action
12:24:59 <adimit> aw, I already had my *hopes* up…
12:25:14 <adimit> … and it turns out it's not real :_P
12:25:44 <shergill> heh
12:27:00 <minsa> test
12:30:35 <salisbury> What is the formal name for a function that a certain class stipulates must be defined?
12:31:00 <Franciman> what's the best book for a complete tractation on Haskell, to you?
12:31:22 <monochrom> "method"
12:32:05 <dmwit> ?where lyah
12:32:05 <lambdabot> http://www.learnyouahaskell.com/
12:32:07 <dmwit> ?where rwh
12:32:07 <lambdabot> http://www.realworldhaskell.org/blog/ http://book.realworldhaskell.org/read/
12:32:09 <dmwit> ?where gentle
12:32:09 <lambdabot> http://www.haskell.org/tutorial/
12:32:23 <dmwit> Franciman: Those are good introductions, if that's what you meant by "tractation".
12:32:29 <dmwit> ?where report
12:32:29 <lambdabot> http://www.haskell.org/onlinereport/haskell2010/ (more: http://www.haskell.org/haskellwiki/Definition)
12:32:36 <hpc> @wn tractation
12:32:36 <lambdabot> No match for "tractation".
12:32:36 <dmwit> And that's a good reference.
12:32:49 <hpc> @where wikibook
12:32:49 <lambdabot> http://en.wikibooks.org/wiki/Haskell
12:33:02 <hpc> and that's just to mention everything :P
12:33:06 <dmwit> The GHC manual is also a good reference, but is arguably not about Haskell. =)
12:33:14 <salisbury> monochrom: thanks, is acceptable to define a method that runs in a certain monad
12:33:33 <Franciman> okay, thanks very much :)
12:33:54 <salisbury> say: class X x where {  someFunc :: a -> a -> m a }
12:35:41 <salisbury> or rather { someFunc :: x -> x -> m x }
12:36:18 <hpc> what would you call mempty then?
12:37:04 <ciaranm> hpc: "0", obviously
12:38:45 <salisbury> ... I should have said 'is it acceptable'
12:45:45 <monochrom> if you write "class X x where {  someFunc :: a -> a -> m a }", why is x not used? if you write class X x where { someFunc :: x -> x -> m x }, where does m come from?
12:46:35 <salisbury> monochrom: the version with 'a' was a typo.
12:46:53 <salisbury> the m in the second version is a specific monad, say the IO monad.
12:47:13 <monochrom> if you are trying all combinations, you are missing: class X m where { a -> a -> m a }
12:47:48 <monochrom> alright, you want class X x where { x -> x -> IO x } ?
12:47:55 <salisbury> yes
12:48:06 <monochrom> yes you can do that
12:49:05 <salisbury> thanks
12:54:55 <darkb> How do you manage multiple GHC installation ?
12:55:48 <dmwit> darkb: There's nothing to manage, really.
12:55:49 <hpc> carefully
12:56:16 <dmwit> darkb: There's just different executables, named ghc-<version>, ghc-pkg-<version>, ghci-<version>, and links from ghc, ghc-pkg, and ghci to the one you installed most recently.
12:56:45 <hpc> you can change these links yourself by just calling ln
12:56:53 <darkb> what about cabal packages
12:57:08 <dmwit> darkb: They carefully manage their installed packages separately, so there's no confusion about building a library with one version and linking with another or anything like that.
12:57:30 <darkb> they has GHC version in the path, for example /usr/local/lib/plugins-1.5.1.4/ghc-7.0.3
12:57:32 <dmwit> darkb: If you want to install a package for a particular version, just use --with-compiler ghc-7.4.1 or similar.
12:58:08 <dmwit> You might need --with-hc-pkg ghc-pkg-7.4.1, too, though I think there might be some magic tied to trying to guess the right hc-pkg based on the compiler.
12:58:09 <darkb> OK, so if I installed plugins with 7.0.3, and now got 7.4.1 installed, will it work, or do I have to install it again
12:58:20 <dmwit> You will need to install them all again.
12:58:38 <darkb> because they are not registered with  ghc-pkg ?
12:59:09 <darkb> do I need to have different installation folders for .cabal ?
12:59:28 <darkb> and switch between those based on ghc version?
13:00:14 <dmwit> question one: no, because they are registered with ghc-pkg-<old version> but not ghc-pkg-<new version>
13:00:24 <dmwit> question two: no, the management is transparent to you
13:00:40 <dmwit> (there are versioned folder names inside the .cabal and .ghc directory structures)
13:00:46 <dmwit> question three: see question two
13:03:32 <adimit> Can anybody here help with the HDBC bindings to PostgreSQL? I'm trying to insert ARRAY types into a database, but postgres just yells at me.
13:06:48 <darkb> Thanks dmwit
13:07:05 <darkb> I'll give it a try on a VM so I don't mess up with my machine
13:07:08 <adimit> http://hpaste.org/64288 ← something like this happens.
13:11:22 <ChristianS> adimit: toSql "{12,1}" -> looks to me like you're trying to insert a string, which postgres might not like in that column
13:11:56 <ChristianS> no idea to what haskell datatype postgres array correspond, maybe lists?
13:12:14 <adimit> ChristianS: There's no Convertible [a] SqlValue.
13:12:31 <adimit> Postgres *does* accept '{a,b,c}' as string representation of arrays.
13:13:06 <adimit> here's all the instances: http://hackage.haskell.org/packages/archive/HDBC/2.3.1.1/doc/html/Database-HDBC.html#t:SqlValue
13:14:54 <dmwit> darkb: I recommend looking around inside .ghc and .cabal a bit before you start.
13:15:06 <dmwit> darkb: It will make you a lot more confident that you know where things are going.
13:15:30 <ChristianS> hm, maybe hdbc cannot handle arrays? they're not a standard sql type, maybe you would need to postgres-specific library?
13:16:03 <dmwit> darkb: The thing to keep in mind is that GHC is in charge of tracking what's installed (so finished, built libraries go in .ghc), and cabal is in charge of deciding what to install and kicking off the build process (so sources and documentation go in .cabal).
13:17:20 <adimit> ChristianS: Actually, there's mention of ARRAY in the SQL standard.
13:17:40 <adimit> HDBC doesn't have explicit support, no. But I've found a way, methinks.
13:17:58 * ChristianS is curious
13:18:03 <monochrom> not entirely true. metadata go into .ghc. files go to somewhere else
13:18:29 <adimit> Postgres *does* after all accept string reps of arrays. *but* when postgres considers something failed, it *ignores* everything until the end of the transaction.
13:18:51 <adimit> Which means that I have to call disconnect :: Connection -> IO (), then re-connect in order to force a new transaction.
13:19:24 <adimit> I wonder if commit :: Connection -> IO () would work. So I was getting error messages from before, even though I was using syntax that was actually valid!
13:19:51 <adimit> well, silly stuff, anyway. I always feel so dirty when interacting with impure systems ^^
13:19:57 <ChristianS> adimit: hm, so your error was unrelated to the array insertion?
13:20:15 <adimit> ChristianS: I was using a malformed array insertion syntax at first, which tainted the rest of my session.
13:21:10 <adimit> inserting arrays is actually possible. something like: prepare conn "INSERT INTO test (array_val) VALUES (?)" >>= (flip execute) [toSql "{1,2,3}"] *does* wokr.
13:21:14 <adimit> *work*
13:21:22 <ChristianS> adimit: ok, i see. good to know that that syntax works, just in case. i use both haskell and postgres, though not yet both together...
13:22:14 <adimit> ChristianS: postgres is pretty good, and the HDBC bindings are ok, if a bit simplistic. I'll just add that you should definitely watch postgres' log if you're gonna try HDBC+PGSQL
13:22:33 <adimit> was making the mistake of relying only on GHCi's output.
13:23:51 <lebro> why would learning haskell be a better choice than learning lisp?
13:25:07 <ChristianS> lebro: fewer parentheses, more type-safety, more fun
13:27:00 <mekeor> lebro: monads seperate IO (impure stuff) from purely functional stuff; haskell's type system is probably stricter and thus safer. haskell's allows also infix operators and is thus more intuitiv… blah
13:27:42 <Philippa> monads're easier to deal with than arbitrary CPS
13:28:46 <mekeor> also, lisp is old. you should use scheme if you wanna use a lispy lang at all, IMO.  oh, and a big advantage of haskell is this channel ;)
13:32:56 <hpc> mekeor: clisp is just as "old" as haskell :P
13:33:40 <lebro> i see, thanks for the responses.
13:34:20 <lebro> still on the fence, though. going to idle in here and #lisp for awhile
13:34:35 <lebro> see who throws a better party etc etc
13:35:16 <mekeor> hpc: excuse me.
13:35:58 <hpc> > throw "party"
13:35:58 <lambdabot>   Not in scope: `throw'
13:36:04 <hpc> noooooooooo!
13:36:18 <mekeor> lol :D
13:36:47 <Martty> > catch my drift
13:36:48 <lambdabot>   Not in scope: `my'Not in scope: `drift'
13:37:14 <lebro> hah
13:43:47 <dmwit> "old" isn't really a merit or a demerit, in my opinion.
13:45:09 <mekeor> you're right. so, i just revoke that.
13:45:43 <mekeor> (well, i revoke it as a disadvantage but still it's true…)
13:48:32 <nexion> if I have a type class ClientData (defined at http://hpaste.org/64295), is it possible for a function to take a "TVar ClientData" as a parameter and determine exactly which ClientData it is?
13:49:19 <dmwit> If ClientData is a type class, then TVar ClientData is not a real type.
13:49:40 <nexion> makes sense
13:50:38 <dmwit> You might want to consider what it is your function is going to do with the information about which instance it's instantiated at, and just add that as a method to the class, instead.
13:54:42 <nexion> I used to have ClientData being a type which had "cdOtherData" with data specific to the type of client it is (customer, operator, unregistered)
13:55:00 <nexion> but all over the codebase, I had to patternmatch even if I know for sure that it's an operator, for example
13:55:34 <tgeeky> edwardk: ping
13:55:34 <nexion> all of them share just 2 fields
13:55:46 <edwardk>  pong
13:56:12 <hpc> nexion: once you strongly type something, it means you know what it will be at compile-time
13:56:21 <hpc> is this true for your program?
13:56:34 <hpc> (and i mean known everywhere)
13:57:00 <nexion> yep
13:57:40 <mekeor> i want to install a program which needs GHC 6.12.  what can/should i do?  just "cabal install ghc-6.12" ??
13:57:55 <c_wraith> cabal can't handle installing ghc
13:58:02 <mekeor> oh
13:58:02 <c_wraith> just grab a binary distro for it
13:58:14 <c_wraith> and install it locally
13:58:31 <monochrom> you can use "./configure --prefix=blah" to control where to put it
13:58:35 <mekeor> c_wraith: er.. what? how do you mean exactly?
13:58:42 <mekeor> ah
13:58:56 <monochrom> http://www.haskell.org/ghc/download_ghc_6_12_3
13:59:06 <mekeor> thanks for link =)
14:00:03 <nexion> hpc: I have a tail-recursive function which calls recv on the client's socket and then handleMessage after parsing; this function doesn't care which of the 3 types of ClientData it's dealing with, but handleMessage will want to know
14:03:24 <mekeor> monochrom: okay. downloaded. unpacked. now? >.>
14:04:46 <cbm80> is "IsString" the superclass, for lack of a better word, for all things stringlike? ie. String, ByteString and Text?
14:05:17 * hackagebot threads 0.4.0.2 - Fork threads and wait for their result  http://hackage.haskell.org/package/threads-0.4.0.2 (RoelVanDijk)
14:05:24 <monochrom> "./configure --prefix=blah" and "make install" or "sudo make install" or whatever
14:05:28 <geekosaur> sort of.  it's the class defining things that the OverloadedStrings compiler extension can convert literal strings into
14:05:40 <monochrom> in fact, "less INSTALL" first
14:05:51 <geekosaur> so, those, but it has also been abused by regexes and occasionally other things
14:06:02 <cbm80> ah ok
14:06:28 <monochrom> (is this the first time you install GHC?)
14:06:50 <c_wraith> regexes really should be QQs. move compiling them to an efficient representation to compile-time.  As well as the error messages.
14:07:10 <geekosaur> arguably so should the other strings :)
14:07:10 <hpc> QQ regexes would be awesome
14:07:23 <hpc> QQ CFGs even awesomerer
14:07:59 <geekosaur> turning "foo" into the runtime coercion (fromString "foo") is less than ideal, this has been discussed in -cafe I think
14:15:55 <nexion> (to continue my previous question) http://hpaste.org/64299 - Is it possible for function "test" to match myData to MyData1 vs MyData2 (such as in a "case" statement) and pass it to a function that requires MyData1 and is not general?
14:16:22 <nexion> it seems that should be possible
14:16:53 <dmwit> nexion: Yes, as I said: add a method to MyClass that does this.
14:17:50 <nexion> what would its type signature be?
14:18:11 <dmwit> What is the type signature of the (monomorphic) function you're going to call?
14:18:16 <dmwit> Just polymoprh that signature.
14:18:46 <dmwit> Classes *are* Haskell's mechanism for type-based dispatch.
14:20:28 <mekeor> monochrom: argh! GHC 6.12 required libgmp.so.3 which it can't find although i installed lib32gmp-dev lib32gmp10 lib32gmpxx4 libgmp-dev libgmp10 libgmp3-dev libgmpxx4ldbl… -.-  what can i do?   (according to "sudo apt-file find libgmp.so.3" there's no package in the debian-repos which contains such a file…)
14:21:37 <monochrom> that's strange. although I'm just on ubuntu, libgmp3-dev suffices
14:21:48 <geekosaur> should be libgmp3 (without the -dev, but then libgmp3-dev should have pulled it in as a dep)
14:22:46 <geekosaur> ip-10-212-142-121:3759 Z$ dpkg -S /usr/lib/libgmp.so.3
14:22:46 <geekosaur> libgmp3c2: /usr/lib/libgmp.so.3
14:22:47 <monochrom> libgmp3-dev brings in libgmp3c2, and that ends the story
14:22:47 <geekosaur> actually
14:23:01 <mekeor> geekosaur: there's no libgmp3
14:23:43 <nexion> dmwit, could you please give me an example? I'm not yet seeing how I could achieve this
14:23:48 <monochrom> libgmpxx4ldbl also brings in libgmp3c2
14:24:49 <monochrom> IIRC ubuntu already installs libgmp3c2 by default, no user intervention necessary
14:25:21 <monochrom> but I'm more than happy to accept that debian is more disorganized
14:25:32 <mekeor> so what can_i/do_i_have_to do?
14:25:50 <mekeor> monochrom: heh -.- :) :/ :(
14:26:28 <monochrom> http://packages.debian.org/search?searchon=contents&keywords=libgmp.so.3&mode=exactfilename&suite=stable&arch=any
14:27:34 <monochrom> re-install debian?
14:27:42 <mekeor> i am testing here, actually, but thanks
14:27:46 <mekeor> monochrom: :D
14:28:10 <monochrom> http://packages.debian.org/search?searchon=contents&keywords=libgmp.so.3&mode=exactfilename&suite=testing&arch=any
14:30:26 <mekeor> wtf?
14:30:48 <monochrom> is yours amd64 or i386?
14:30:55 <mekeor> there's no package called "ia32-libs-core" here
14:31:05 <mekeor> monochrom: i am amd64
14:31:19 <monochrom> http://packages.debian.org/search?suite=wheezy&arch=amd64&mode=filename&searchon=contents&keywords=libgmp
14:31:50 <monochrom> apparently they call it lib32gmp10 and libgmp.so.10 . I say make a symlink.
14:32:14 <Clint> er
14:32:16 <mekeor> that stuff sucks man… but okay, i'll symlink
14:32:17 <Clint> there's a reason for the soname change
14:32:22 <mekeor> oh
14:32:33 <mekeor> Clint: which?
14:32:37 <monochrom> "testing" is "wheezy", is that right? that's what the web page tells me
14:32:40 <Clint> correct
14:32:49 <mekeor> monochrom: yep
14:32:53 <Clint> what are you trying to do
14:32:58 <mekeor> is…
14:33:07 <monochrom> GHC 6.12 wants libgmp.so.3
14:33:13 <mekeor> exactly
14:33:17 <Clint> install libgmp out of squeeze
14:33:25 <monochrom> actually almost all GHC binary tarballs do
14:33:33 <mekeor> Clint: O_O
14:33:39 <mekeor> Clint: O_O
14:33:43 <monochrom> oh haha
14:33:45 <mekeor> Clint: O_O
14:33:54 <mekeor> Clint: how?
14:34:10 <Clint> mekeor: http://packages.debian.org/squeeze/libgmp3c2
14:34:21 <Clint> alternately set up additional apt sources and pinning
14:34:27 <Clint> but it's quicker to install that .deb by hand
14:34:49 <mekeor> i'm sorry for the following vulgar expressions: that fucking stuff is really sucking man!
14:34:58 <monochrom> I guess http://packages.debian.org/wheezy/ghc is built against libgmp10 so they don't have this problem
14:34:59 <Clint> or you could install ghc6 from squeeze
14:35:33 <mekeor> Clint: so, download it and then "dpkg -i ..." ?
14:35:36 <Clint> yep
14:36:24 <monochrom> ghc6 from squeezy wants libgmp3c2 from squeezy too. doesn't solve more problems.
14:36:55 <mekeor> Clint: worked fine! thank you very much! you, too monochrom! thanks :)
14:36:58 <monochrom> or rather, begs the question :)
14:38:00 <Clint> it also raises the question of why you would want to run 6.12
14:38:50 <mekeor> monochrom: okay, so i have ghc 6.12 in ~/.anotherGHCversion/bin/ghc now. how can i compile a package using that ghc version? by modifying the makefile?
14:39:12 <mekeor> Clint: Epigram (#epigram) needs 6.12 -.-
14:39:16 <monochrom> play with PATH
14:39:28 <mekeor> play?
14:39:39 <monochrom> play with PATH in makefile, if you like
14:40:14 <monochrom> PATH=$HOME/.anotherGHCversion/bin:/bin:/usr/bin:/usr/local/bin:...
14:41:28 <mekeor> monochrom: i'll try to change "HC = ghc" in makefile to "HC = ~/.anotherGHCversion/bin/ghc"
14:41:44 <monochrom> that may also work
14:41:49 <mekeor> ping
14:42:34 <mekeor> hmm
14:43:09 <mekeor> now i get "<command line>: cannot satisfy -package mtl"…
14:43:40 <mekeor> probably that epigram also needs an old version of MTL?
14:44:11 <Clint> i believe ghc 6.12 won't be able to use any of the libraries compiled with ghc 7
14:44:24 <parcs`> :t undefined :: _
14:44:25 <lambdabot> parse error on input `_'
14:45:01 <mekeor> Clint: oh man…
14:45:14 <mekeor> parcs`: AFAIK you can't use _ in type signatures
14:45:29 <geekosaur> that's Agda
14:46:04 <mekeor> ok
14:46:43 <parcs`> :t undefined :: __
14:46:44 <lambdabot> forall __. __
14:46:59 <ben> heh
14:47:06 <mekeor> what?!
14:47:15 <mekeor> :t undefined :: ____
14:47:15 <ben> :t undefind :: hurf
14:47:16 <lambdabot> forall ____. ____
14:47:16 <lambdabot> Not in scope: `undefind'
14:47:21 <ben> :t undefined :: hurf
14:47:22 <lambdabot> forall hurf. hurf
14:47:26 <ben> _ is a lowercase letter
14:47:27 <mekeor> nice
14:47:34 <mekeor> ben: Ah!
14:47:55 <mekeor> er
14:48:16 <mekeor> ben: but then ____ shouldnt work either
14:48:35 <parcs`> > isUpper '_'
14:48:36 <lambdabot>   False
14:48:40 <ben> it's just a bunch of letters, it's a type variable
14:48:54 <mekeor> oh, right
14:52:44 <monochrom> mekeor: if you have cabal you can use it with ghc 6.12. it's just a standalone executable. but you need to play with PATH so cabal calls up the right ghc. you want cabal install --dry-run --constraint='mtl<2' mtl
14:53:46 <monochrom> actually cabal install 'mtl==1.*' is shorter
14:54:06 <monochrom> and oh, skip my --dry-run, I put it there for probing
14:56:05 <mekeor> monochrom: well, i installed mtl-1.1.1.1 before you suggested that… it still doesnt work…
14:56:21 <monochrom> you need "she" next
14:56:39 <mekeor> i have it already
14:57:36 <monochrom> "have it" as in built against ghc 6.12?
14:57:51 <mekeor> oh, er, no
14:58:06 <mekeor> i just did "cabal install she" before doing anything else
14:59:12 <monochrom> well, if epigram wants the module ShePrelude rather than the executable "she", you will have to build it against whichever ghc you actually use
14:59:37 <monochrom> but really I don't know what epigram wants
14:59:44 <mekeor> me, too
15:00:10 * mekeor is annoyed
15:02:01 * mekeor gives up for now. –.–
15:03:55 <monochrom> you probably want to know half of http://www.vex.net/~trebla/haskell/sicp.xhtml to put things into perspective
15:08:05 <adnauseam> elo - is anyone using vim with haskell mode ?
15:12:54 <tgeeky_> i hope anyone using vim is
15:13:16 <adnauseam> trying to set it up ;p it's bitching
15:16:44 <Cale> .___. Why do so many people seem to think that the limit as x -> a of f(x) tells you anything about the value of f(a)? Whenever the 0^0 thing comes up, 90 people are ready with this spurious argument to show how it must be undefined because such and such limit.
15:17:28 <Cale> If there's anything which one should learn in a first course on calculus, it's that the limit as x -> a of f(x) tells you absolutely nothing at all about the value or definedness of f(a).
15:17:46 <monochrom> my interpretation: when people try to define 0^0, they want to maximize continuity when doing so
15:20:46 <tgeeky_> i'm confused about why 0^0 comes up?
15:20:47 <Cale> I guess people are way too used to their functions being continuous, and aren't shown enough examples of functions with many discontinuities in them.
15:21:07 <Cale> tgeeky_: It comes up on every math forum at least once a month.
15:21:26 <otk> 0^0? heh
15:21:26 <shachaf> People like Cale bring it up.
15:21:38 <shachaf> SOmebody once asked a question about 0^0, many years ago, and we're still seeing the echoes.
15:21:44 <otk> LOL
15:21:49 <tgeeky_> but how do we get from "lim (x -> arbitrary) f(x) = ..." to 0^0?
15:22:03 <monochrom> I am really fine to defining 0/0 = pi, for example. it does not have to be related to lim x->0 x/x
15:22:23 <Cale> tgeeky_: Things like lim (x,y) -> (0,0) x^y (which doesn't exist)
15:22:36 * cmccann can't quite understand why anyone would care more about a limit than obviously more useful stuff like the empty product or combinatorial interpretation
15:22:39 <mekeor> monochrom: :D
15:22:50 <monochrom> did you just have a 0^0 argument again in #math? I can go there and troll with "I want to define 0/0 = pi and Cale supports me" if you like
15:22:57 <cmccann> hahaha
15:23:11 <tgeeky_> well, if we get to choose here, let's make it: tau = 2*pi
15:23:14 <tgeeky_> 0/0 = tau.
15:23:25 <monochrom> ok, I'll use tau!
15:23:31 <ben> 0^0 is a much easier and less controversial problem in C.
15:23:36 <mekeor> :D
15:23:37 <tgeeky_> actually, this isn't a mathematically insane idea, I don't think
15:23:41 <monochrom> then it is "Cale and all of #haskell approves"
15:24:06 <mekeor> except mekeor
15:24:45 <tgeeky_> monochrom: we've had a discussion and we're pretty sure we've solved it. Oleg is working on the proof, but come on now - it's Oleg. Just go ahead and change your books accordingly."
15:25:04 <monochrom> you can consider lim x->0 x^x though
15:25:26 <tgeeky_> monochrom: in the reals?
15:25:40 <mekeor> ℝ
15:25:49 <monochrom> oh, I guess lim x->0+ x^x is better
15:25:53 <niteria> 0^0 = 1 most of the time
15:26:19 <mekeor> rather '0^0 := 1' though
15:26:22 <tgeeky_> Cale: and people think of their functions continuous for the same reason they imagine their women like supermodels. Because the associated mathematics was invented for that purpose.
15:26:22 <cmccann> I think I'll go with 0^0 = six and three quarters
15:26:26 <cmccann> I mean what else would it be
15:26:30 <tgeeky_> Cale: so, historical raisins.
15:27:16 <tgeeky_> niteria: are there any other mathematical assignments that have 'most of the time' attached to them? :o
15:27:17 <monochrom> anyway, we programmers care the most about continuity
15:28:12 <niteria> tgeeky_: yeah, set is measurable (most of the time)
15:28:25 <monochrom> the limit of the sequence ⊥, f ⊥, f (f ⊥) ... can be not a fixed point of f if f is not continuous
15:28:31 <niteria> or function is analitical (most of the time)
15:28:52 <monochrom> for this reason, all programming languages restrict you to continuous functions
15:29:17 <monochrom> (one way to obtain discontinuity is unbounded non-determinism)
15:29:43 <Saizan> even in languages without that limit you can only build continuous functions
15:29:56 <tgeeky_> what!? that sounds wrong to me
15:29:57 <niteria> do you copy-paste ⊥ or is there an easier way?
15:30:14 <monochrom> I load up SCIM and type \perp
15:30:29 <tgeeky_> are we seperating ourselves from a number theoretic domain? all of this sounds like it's the Reals or "worse"
15:30:43 <monochrom> but I offer my http://www.vex.net/~trebla/symbols/select.html if you're desperate
15:32:24 <Saizan> tgeeky_: you can assign topologies to any type
15:32:37 <niteria> cool I always wanted to use ζ and ξ on teh internets
15:32:48 <monochrom> the space of programs is worse than the reals, yes. you can give it a topology, and it will be a non-Hausdorff topology. actually, perhaps it is better, not worse. I don't know.
15:33:45 <kyagrd> Anyone familiar (or, heard of) \mu-\tiled{\mu}-calculus and pi-calculus?
15:33:48 <monochrom> but usually you don't even use topology. you just use lattice theory. joins and meets and limits of chains.
15:34:04 <Saizan> in a turing complete language is easy to define open sets as the ones characterized by functions A -> ()
15:34:12 <Saizan> *it's
15:35:21 * Saizan knows \mu-calculus
15:35:27 <kyagrd> People study \mu-\tilde{\mu} calculus since they can encode control operators in them.
15:35:47 <kyagrd> But, just wondering that pi-calculus can encode pretty much the same thing and maybe more.
15:36:24 <kyagrd> In addtion, it seems non-trivial to extend \mu-calculus to polymophic system.
15:36:57 <kyagrd> Pi-calculus already works with polymophic type system (That's what I've heard ...)
15:37:20 <dmwit> nexion: Sorry, parents are visiting now.
15:37:37 <dmwit> nexion: But give an example of what you want to do on-channel and I'm sure someone will help you.
15:38:21 <kyagrd> So, other than \mu-calculus being a proof term for sequent logic, is there any practical use that can beat pi-calculus? Just had a thought cause work was boring in the afternoon :)
15:39:07 <kyagrd> ugg typo polymophic ->polymorphic
15:40:02 <Nisstyre> Why doesn't "(map id) . group" work?
15:40:42 <Saizan> ?type map id . group
15:40:43 <lambdabot> forall a. (Eq a) => [a] -> [[a]]
15:41:01 <Saizan> looks fine and the same as group, define "not work"
15:41:12 <Nisstyre>     Couldn't match expected type `[b0]'
15:41:12 <Nisstyre>                 with actual type `[a0] -> [[a0]]'
15:41:23 <Nisstyre> when I try and call it with a list of integers
15:41:37 <Nisstyre> er
15:41:39 <Nisstyre> wrong error
15:41:46 <Nisstyre>     No instance for (Num ())
15:41:46 <Nisstyre>       arising from the literal `8'
15:41:50 <tgeeky_> 18:41 <tgeeky_> > (map id) . group $ [2,4,6,8,1,3,5,7]
15:41:50 <tgeeky_> 18:41 <lambdabot>   [[2],[4],[6],[8],[1],[3],[5],[7]]
15:41:50 <tgeeky_> 18:41 <tgeeky_> > group $ [2,4,6,8,1,3,5,7]
15:41:50 <tgeeky_> 18:41 <lambdabot>   [[2],[4],[6],[8],[1],[3],[5],[7]]
15:42:03 <tgeeky_> whoops, wrong way to do that.
15:42:09 <Nisstyre> http://codepad.org/qG1beo3E
15:42:30 <Saizan> Nisstyre: that's the monomorphism restriction
15:42:43 <Nisstyre> Saizan: so I I have to give it a type annotation manually?
15:42:49 <Nisstyre> *I
15:43:01 <Saizan> Nisstyre: yeah, or make f's argument explicit
15:43:10 <Nisstyre> Saizan: can you explain why it can't infer the types here?
15:45:12 <geekosaur> Nisstyre, http://www.haskell.org/haskellwiki/Monomorphism_restriction
15:45:38 <geekosaur> that which many of us consider mistake #1 in the design of haskell
15:45:47 <Saizan> Nisstyre: it's not that it can't infert the types, it just refuses to allow f to be polymorphic because it doesn't have any arguments, syntactically
15:46:14 <geekosaur> (mind, there *are* some good reasons for it, but it's an artificial and extremely annoying restriction)
15:46:22 <kyagrd> In GHC you can turn that off by -XNoMonomorphismRestriction http://stackoverflow.com/questions/4575040/what-is-xnomonomorphismrestriction
15:47:10 <Nisstyre> fair enough
15:50:16 <Saizan> ghci would also infer f :: [Integer] -> [[Integer]] here
15:50:42 <Saizan> becuase it interprets the MR as triggering module-wise
16:13:29 <DanBurton> are there any Haskell compilers that *don't* support NoImplicitPrelude?
16:24:15 <srhb> Does anyone know where wx_macu_media-2.8 comes from? I've installed wxmac through homebrew, but cabal install wxcore still complains about that one
16:28:00 <mux> dreixel: are you around?
16:35:23 <krobertson> I'm working on adding haskell support to Cloud Foundry (VMware's open source PaaS) and was wondering if anyone could give me pointers to make the dependency installing easier
16:35:48 <krobertson> building happens as a secured used, so dependencies are lost between builds
16:35:55 <krobertson> used/user
16:36:55 <krobertson> so ideally, would be nice to have it look for shared libraries in one place but build its own in another, and I could have it move new packages over to the shared repository afterwards
16:46:19 <DanBurton> suppose I want to write a test that fully evaluates 2 values, and quits with exitSuccess if the first was faster than the second, and exitFailure if the second was faster than the first. How could I go about doing that?
16:55:35 <mux> DanBurton: I suppose I would use two threads and an MVar
17:00:57 <DanBurton> mux: that makes sense
17:02:01 <DanBurton> I ended up making a very ad-hoc "time" function using getCurrentTime. I imagine it's quite imprecise, but it served my needs
17:30:34 <kejoki> anyone using archlinux w/ ghc 7.2?
17:31:51 <parcs`> i used to. now i use 7.4
17:32:47 <kejoki> parcs`: did you start w/ source?  pacman still wants to give me 7.0.x
17:33:01 <slack1256> parcs`: I guess you compiled from source right?
17:33:05 <td123> parcs`: which pkgrel are you using?
17:33:21 <slack1256> in the compiler notes says that now "is easier than ever"
17:35:37 <parcs`> i used the 7.2 in testing until 7.4 was released (and 7.2 was deleted from testing) and then i made a pkgbuild for 7.4
17:35:50 <kejoki> duh
17:35:54 <kejoki> testing
17:36:25 * kejoki just escaped from ubuntu
17:36:36 <parcs`> 7.2 isn't in testing anymore though
17:36:44 <td123> do you guys actually use the haskell pkgs coming w/ arch or do you just install cabal-install and use that?
17:37:42 <parcs`> no way
17:37:54 <parcs`> those packages are too buggy
17:38:10 <td123> heh fair enough
17:38:15 <parcs`> sometimes a package fails to register with ghc, sometimes it fails to unregister
17:39:49 * slack1256 wonders if he should join the haskell-archlinux project
17:40:42 <td123> there is currently a cleanup going on with haskell on arch :)
17:40:56 <kejoki> <off topic>beats me why distros want to put package packages into their package managers anyway.  cabal handles this for haskell, cpan handles it for perl ... </off topic>
17:41:53 <geekosaur> kejoki, linux package managers are generally of the opinion that they have complete control over everything
17:42:06 <td123> kejoki: problem is, if you want to package something like darcs or xmonad, you have to package its depends
17:42:40 <geekosaur> so, you get interesting breakages if you install anything via not-their-package-manager, then later install something via their package manager that has an overlpping dependency
17:42:41 <td123> kejoki: i agree with you though, if you try to package a giant 3rd party repo, you're going to fail hard
17:44:16 <kejoki> geekosaur: I'll do what I do for Perl, I guess.  Compile from source and use the standard repo.
17:44:40 <td123> kejoki: what are you trying to do?
17:45:36 <kejoki> td123: just get the latest, and keep the distro out of handling my dev setup.
17:46:30 <geekosaur> the problem there is when something unexpectedly drags the distro's idea of the world in.  like, someone decides they've heard anjuta is a great generl IDE
17:46:31 <td123> kejoki: if you wait like a week, 7.4.1 will either be in testing or stable repos for arch
17:46:58 <geekosaur> (which it is, but it's also written in haskell... depending on the distro, oops, it just pulled in the distro's ghc etc.)
17:48:26 <kejoki> td123: I'll look.  but I have to go with geekosaur on this.  I don't want someone's "you obviously will want to set it up this way" slapping me in the head.
17:49:57 <parcs`> it's not really arch's fault that a package manager has to jump through hoops in order to get ghc to recognize a package though
17:50:11 <slack1256> td123: i don't think so, the wait for the haskell-plataform which is scheduled for may
17:50:18 <slack1256> *they
17:50:25 <vodik> geekosaur: its not anjuta, anjute is the gnome ide
17:50:30 <geekosaur> I'm actually kinda on both sides there, as a developer I often need versions not available from the distro, as a sysadmin it's a lot easier to go with the distro because it's nearly impossible to get things back into sanity if the distro and a separate install conflict
17:50:52 <vodik> archlinux has a nice cabal2arch app too, fwiw
17:51:16 <vodik> but specific library version dependancy issues need to be resolved
17:51:31 <geekosaur> I'm misremembering yeh sorry
17:51:43 <td123> slack1256: arch isn't waiting for HP
17:51:48 <geekosaur> one of them, there's a nice IDE that was written in haskell
17:51:49 <td123> slack1256: it's dropping HP
17:51:57 <geekosaur> and gtk2hs specifically
17:52:08 <vodik> leksah?
17:52:23 <vodik> (anjuta is all vala now i think)
17:54:14 <slack1256> td123: what? (cool) where did you read that?
17:54:24 <geekosaur> possibly.  actually I think an early anjuta was gtk2hs but the gnome folks rebelled (because, y'know, ghc is bsd licensed)
17:54:55 <geekosaur> slack1256, I've heard that from multiple sources recently as well
17:55:24 <geekosaur> arch wants to track recent releases, haskell platform is still on ghc 7.03 because 7.2/7.4 are considered experimental compiler versions
17:55:31 <slack1256> cool
17:56:11 <geekosaur> (arch should perhaps provide overlays for both; 7.2/7.4 *are* experimental, it's a bad idea to make them the ststro standard)
17:56:17 <`Jake`> #hardware
17:56:19 <geekosaur> distro
17:56:19 <`Jake`> oops
17:56:30 <geekosaur> lots of experimental type system extensions/changes
17:56:51 <td123> slack1256: http://mailman.archlinux.org/pipermail/arch-general/2012-February/025061.html
17:57:56 <geekosaur> also 7.4 has dropped the Show and Eq contexts for Num, which means a lot of programs compliant to current standards will not build unmodified (the *next* haskell standard will reflect that change, but h98 and h2010 say it's present)
17:57:58 <vodik> geekosaur: thats how arch rolls. python3 is default too
17:58:27 <geekosaur> vodik, but GvR at least gives them what to rely on.  GHC central says 7.2 and 7.4 are experimental
17:58:58 * kejoki throws up his hands
17:59:01 <vodik> true, but i wouldn't be suprised if we end up with 7.2 or 7.4
17:59:19 <kejoki> (shouldn't've swallowed them in the first place.)
18:00:20 <td123> geekosaur: then why does http://www.haskell.org/ghc/download list 7.4.1 as current stable?
18:00:22 <slack1256> well at least with ghc 7.4 you can use llvm >=209
18:00:53 <slack1256> *2.9
18:01:12 <hpaste> wilfredh pasted “Numeric type error” at http://hpaste.org/64302
18:01:45 <vodik> td123: i think its experimental language wise, not compiler wise
18:02:08 <vodik> could be wrong
18:03:10 <wilfredh> newbie error: I don't know how to make Haskell happy with my arithmetic. I don't see why `ceiling $ 1.5 * 10 :: Integer` type-checks fine but my function doesn't work. Any tips? http://hpaste.org/64302
18:03:30 <wilfredh> s/function doesn't work/function doesn't type check/
18:05:16 <vodik> wilfredh: try ceiling $ 1.5 * fromIntegral 5
18:05:22 <jcbmdfplq> wilfredh: 10 has type (Num t) => t, it is coerced into a fractional in your example
18:06:09 <vodik> wilfredh: or change the functions type
18:06:38 <jcbmdfplq> so you can't expect to naievely replace a concrete integer 10 with a integer value
18:09:00 <wilfredh> much appreciated, thanks :)
18:09:46 <parcs`> slack1256: llvm 3 worked with 7.2 too
18:10:31 <parcs`> well, for me anyway. lots of people reported the contrary :P
18:10:31 * hackagebot couchdb-enumerator 0.3.6 - Couch DB client library using http-enumerator and aeson  http://hackage.haskell.org/package/couchdb-enumerator-0.3.6 (JohnLenz)
18:10:33 * hackagebot runmemo 1.0.0.0 - A simple memoization helper library  http://hackage.haskell.org/package/runmemo-1.0.0.0 (DanBurton)
18:10:44 <vodik> parcs`: i think the point is its greater than 7.0, which is what arch ships
18:12:42 <td123> can anyone point me to anything stating 7.4 is experimental?
18:13:57 <geekosaur> I'm not seeing it and mya have misunderstood.  7.2 was explicitly experimental, looks like they put some extra protections and such around the most experimental parts of 7.2 (polykinds, safe haskell)
18:14:13 <byorgey> 7.4 is definitely not experimental.  It includes some experimental features.
18:14:20 <geekosaur> (in 7.4 that is)
18:14:56 <byorgey> polykinds is new in 7.4.
18:15:32 <byorgey> and as with all such features, you have to explicitly enable an extension if you want it, so it doesn't affect normal use.
18:16:23 <shachaf> byorgey: Except that (I hear) it does.
18:16:34 <shachaf> Because it breaks kind inference when the extension is turned off, or something.
18:16:49 <byorgey> oh, heh, I think you're right
18:22:18 <td123> I still can't figure out where to get cabal-install to build with ghc 7.4.1
18:23:01 <td123> seems hackage is ood and the one included with ghc sources depends on an older version of Cabal than which is included :P
18:35:41 <JoeyA> @hoogle Map k1 (Map k2 v2) -> Map k2 (Map k1 v2)
18:35:41 <lambdabot> No results found
18:35:54 <JoeyA> I guess I'll have to roll my own transpose for Data.Map
18:36:07 <JoeyA> Or is there a library or such implementing this function?
18:36:37 <saml> is snap recommended? i want to make a web site
18:37:12 <parcs`> snap will do that
18:37:37 <geekosaur> JoeyA, I don't kno of a transpose per se but there is a bimap library on hackage
18:37:39 <saml> is there any serious web site written in haskell?
18:38:04 <geekosaur> (i.e. a map which tracks k->v and v->k)
18:38:52 <JoeyA> geekosaur: Thanks
18:41:36 <parcs`> saml: yes
18:41:58 <m3ga> saml: www.haskellers.com is done in yesod
18:42:27 <gentleben> saml: i don't think there is much at scale
18:42:50 <saml> okay. should i use python instead?
18:44:05 <gentleben> why?
18:44:23 <gentleben> what are you trying to do?
18:45:22 <luite> actually the major frameworks are used in production, only not very visible unfortunately
18:47:35 <saml> i'm trying to make social networking flickr like mega web site and be rich
18:49:02 <luite> saml: definitely use haskell then, it scales great and can handle extremely concurrent workloads
18:49:32 <saml> yah i know it's web scale compliancy
18:50:17 <gentleben> saml: mostly it does not matter
18:50:19 <bill```> your application code won't be your bottleneck for a *long* time (if ever), so use whatever you want
18:50:45 <luite> saml: 'webscale' doesn't even come close to describing how awesome haskell is for this
18:51:27 <saml> bottleneck is GraphicsMagick in my case. And, I have C library already written. I was looking to create HTTP api
18:52:27 <edwardk> preflex: xseen sclv
18:52:27 <preflex>  sclv was last seen on freenode/#haskell 7 hours, 38 minutes and 45 seconds ago, saying: monochrom: I see a few C imports hanging out at the bottom of that file.
18:52:44 <ddarius> edwardk reminds me.
18:52:49 <gentleben> luite: lets not go crazy
18:52:51 * ddarius pokes copumpkin.
18:54:31 <luite> gentleben: why not?
18:55:27 <gentleben> its just another technology with its own advantages and shortcomings
18:55:31 <edwardk> ddarius: ?
18:55:37 <ddarius> "My white huggy jacket is web-scale!"
18:56:06 <saml> man cabal is so slow
18:56:15 <mauke> you can't spell webscale without cale
18:56:17 <saml> i mean , cabal update
18:56:30 <Cale> mauke: lol
19:29:26 <nand`> saml: make it fully anonymous, decentralized, encrypted and base it on garlic routing + DHT or similar methods of serverless p2p routing... written in haskell
19:29:28 <nand`> that would be super neat
19:29:30 <nand`> I'd use that
19:34:54 <shergill> nand`: is garlic routing the smelly cousin of onion routing?
19:36:06 <nand`> shergill: It's like onion routing that globs messages together into a single encrypted chunk
19:36:14 <nand`> to make it harder to track the data flow
19:36:21 <shergill> ah
19:36:29 <nand`> (messages from multiple users, obviously)
19:36:37 <shergill> yeah
19:36:53 <nand`> i2p is an example of garlic routing
19:37:44 <shergill> are there any other differences wrt onion routing? any performance implications?
19:39:12 <nand`> garlic routing should be slower; but I think that's the only difference
19:39:25 <nand`> It's not exactly a scientific term :P
19:42:04 <shergill> yeah that's what i'd reckoned (about it being slower), but (and perhaps i'm misremembering) i heard about i2p being more the craze with torrent enthusiasts. given TOR's unsuitability for torrent traffic, i'd have thought i2p would be an even worse choice (increased data protection notwithstanding)
19:43:27 <xil> hi. Is there a good package for making sounds?
19:44:13 <nand`> i2p is nothing like tor
19:45:15 <nand`> shergill: torrents + tor don't mix well because torrents were designed for an open network; which has a number of implications. i2p's internal file sharing network is a redesigned version of the torrent protocol adapted to the i2p dark net
19:45:56 <shergill> nand`: ok that makes sense now
19:46:31 <nand`> If you're interested we could take this to PMs or something :P
20:04:08 * ddarius finds that Bjarne Stroustrup understands type classes better than many Haskell users.
20:04:45 <adnauseam> didn't he author c++ ?
20:13:12 <shergill> haskellers which package do you prefer for doing matrix computations? i know about hmatrix
20:14:33 <shergill> *haskellers,
20:30:13 <AfC> shergill: repa?
20:33:22 <shergill> AfC: any personal experience with it?
20:38:20 <shergill> for those interested in similar stuff: http://stackoverflow.com/questions/5196394/which-haskell-array-implementation-to-use-aka-what-are-the-pros-and-cons-of-eac
21:01:39 <vodik> anything to look into specifically if c2hs, when using get/set to implement a storable instance, is casting things to Ptr ()?
21:02:53 <vodik> it generates code like this: (\ptr -> do {peekByteOff ptr 0 ::IO (Ptr ())})
21:04:21 <AfC> shergill: sorry, no. It seems well documented, though, both http://www.haskell.org/haskellwiki/Numeric_Haskell:_A_Repa_Tutorial and http://repa.ouroborus.net/
21:04:40 <AfC> shergill: I'd heard it recommended before I realized I knew its author
21:04:54 <shergill> heh
21:10:14 <Jafet1> vodik, Haskell isn't damaged: it doesn't have casts
21:10:48 <bsrkaditya_> Can function arguments start with an underscore?
21:10:58 <Jafet> Presumably that type signature is specifying the type of the expression.
21:11:38 <nand`> > let foo _bar = _bar in foo 5
21:11:39 <lambdabot>   5
21:11:52 <Jafet> Should they?
21:13:24 <vodik> Jafet: is there any way to tell c2hs not to put the :: IO (Ptr ()) part in? this is code i moved from hsc2hs and it works just find if its not there
21:14:22 <Jafet> Do you know why it is put there?
21:14:30 <Jafet> Also, do you know that c2hs isn't hsc2hs?
21:14:50 <Kaidelong> has anyone here used win32 (the package on hackage)?
21:16:01 <Kaidelong> I'm hoping there are some samples and snippets lying around
21:16:02 <vodik> Jafet: yes i do
21:17:05 <Jafet> Perhaps it thinks you're using it in a context of ()
21:17:46 <vodik> what do you mean?
21:19:05 <Jafet> I don't know. Why don't you paste the problem?
21:20:46 <vodik> http://hpaste.org/64303
21:21:22 <vodik> when i run c2hs on it, the get/set statements come out like this:
21:21:47 <DanBurton> > Left "foo" `mappend` Right "bar"
21:21:48 <lambdabot>   No instance for (Data.Monoid.Monoid
21:21:48 <lambdabot>                     (Data.Either.Either...
21:21:52 <hpaste> vodik pasted “c2hs part2” at http://hpaste.org/64304
21:22:15 <DanBurton> What do you guys think? Is it sensible to define Monoid a => Monoid (Either e a) ?
21:22:32 <DanBurton> kind of like the Maybe monoid
21:22:58 <DanBurton> > (Nothing `mappend` Just "foo", Just "foo" `mappend` Just "bar")
21:22:59 <lambdabot>   (Just "foo",Just "foobar")
21:23:04 <nand`> DanBurton: would have to be (Monoid a, Default e) => Monoid (Either e a) if I'm not mistaken
21:23:26 <nand`> otherwise how will you write mempty :: Either e a
21:23:26 <DanBurton> oh right for mempty
21:23:38 <nand`> seems a bit pointless to me though
21:23:47 <nand`> just write fromEither :: Either e a -> Maybe a
21:23:50 <nand`> and use the Maybe monoid
21:23:58 <DanBurton> in my custom prelude, + acts as mappend, and is separate from mempty
21:24:04 <nand`> since you're losing the contents of Left in the first place due to monoid laws
21:25:08 <nand`> this way you don't need the somewhat arbitrary Default e restriction either
21:25:25 <Jafet> vodik: I don't know if c2hs is meant to be used in that way
21:25:48 <Jafet> GHC lets you unsafeCoerce between any Ptr a, as a last resort
21:26:19 <Jafet> I suppose you should ask someone who knows a lot about c2hs
21:28:22 <ddarius> DanBurton: Yes, it is certainly a semi-group, but not a monoid.
21:29:18 <vodik> Jafet: yeah, i've figured im not doing something right
21:41:03 <nyingen> @quote
21:41:03 <lambdabot> Speck says: "That's like cheating. It isn't even programming. You just tell it what to do and it does it." -- My friend upon seeing some Haskell code
21:41:17 <nyingen> declarative code ftw
21:42:51 <greglnelson> @quote
21:42:51 <lambdabot> JonFairbarn says: I think we should call it "Abstraction Oriented Programming". It's got the "oriented" buzzword in it, and we don't need to tell folk that "abstraction" means more than one thing to
21:42:51 <lambdabot> us until we're sure they're OK.
21:43:47 <greglnelson> @quote
21:43:47 <lambdabot> Plugin `quote' failed with: getRandItem: empty list
21:43:59 <greglnelson> ha ha ha
21:44:14 <greglnelson> @quote
21:44:14 <lambdabot> RobertXCringely says: If automobiles had followed the same development cycle as the computer, a Rolls-Royce would today cost $100, get a million miles per gallon, and explode once a year, killing
21:44:15 <lambdabot> everyone inside.
22:09:50 <albel727> @quote
22:09:50 <lambdabot> hakko says: most programmers have a lot of religious issues about their work, yes.
22:09:56 <albel727> @quote
22:09:56 <lambdabot> seydar says: what's the nick of the drug addict who wrote learn you a haskell? and i mean that in the best possible way.
22:10:08 <albel727> @quote
22:10:08 <lambdabot> cheezey says: i think i love you
22:10:54 <adnauseam> lol drug addict
22:11:44 <adnauseam> @quote
22:11:45 <lambdabot> gosu says: Type parameters are covariant. This is not sound, and that does not matter.
22:11:49 <shergill> declarative code ftw indeed
22:12:21 <shergill> isn't there a haskell package called this/these?
22:15:30 <DanBurton> hrm. getting a bit tired of working on my pet Prelude, but at the same time I don't want to step away from it right now
22:15:55 <DanBurton> the conventions I set for myself are exhausting
22:21:56 <ill_logic> Hey all, coming in with a question related to something I asked about recently, so some of you may recognize. http://pastebin.com/KVmXksct I got this monad to do what I want, but it's not really a monad. My question is, can I even achieve what I'm trying here with a monad?
22:21:58 <mauke> The paste KVmXksct has been copied to http://hpaste.org/64305
22:22:09 <ddarius> @hackage these
22:22:09 <lambdabot> http://hackage.haskell.org/package/these
22:23:26 <ill_logic> I'm doing this to learn monads. I likely missed the point altogether, I'd gladly be told so if that's the case. I guess I understood that monads sortof pass their "state" onto the next one down. Really though it's more like they can pass their state on up from below. But then it violates the laws.
22:23:27 <shergill> DanBurton (and others who've been hacking on haskell awhile): i've seen quite a few people work on custom implementations of Prelude. what gives? is it just to get a deeper intelligence of the language or something more?
22:25:16 <ddarius> Monads are not about state passing.
22:25:50 * hackagebot type-unary 0.1.18 - Type-level and typed unary natural numbers, inequality proofs, vectors  http://hackage.haskell.org/package/type-unary-0.1.18 (ConalElliott)
22:26:09 <ill_logic> What are they about?
22:26:32 <ill_logic> Maybe and Either seem to pass a state.
22:26:35 <ill_logic> List does not
22:26:43 <ddarius> What state are Maybe and Either passing?
22:27:07 <ill_logic> I sortof assumed it was about tweaking the sense of what sequence meant.
22:27:22 <ill_logic> Well, maybe passes on Nothing, which trumps the subsequent operations.
22:27:44 <ill_logic> Either (which I haven't really used, so I could be getting this wrong) will pass on Left "errormessage", right?
22:27:57 <ill_logic> That's a state in some sense.
22:28:01 <ddarius> Why does List not "pass state" then?
22:32:15 <shergill> ill_logic: think of it as a computation within a context. in the case of lists the computation context (which gets passed) is one of nondeterministic computation
22:33:18 <shergill> in the case of Maybe the context being passed is that of optional failure
22:33:56 <ill_logic> ddarius: I think the distinction I'd make between passing state and not, has to do with what goes on in the monadic type's level. with Maybe a, the a and the operations on it have no interest in the Maybe wrapping it. But the Maybe can have a value outside of it.
22:34:12 <ill_logic> The List is just a collection of values either way.
22:34:15 <shergill> also, look at typeclassopedia
22:34:26 <shergill> @where typeclassopedia
22:34:26 <lambdabot> http://www.haskell.org/haskellwiki/Typeclassopedia
22:34:57 <ddarius> Maybe is just a collection of values.  Maybe is identical to a list that can hold at most one element.
22:35:22 <adu> ill_logic: define "trump"?
22:35:47 <ill_logic> where did I say "trump"?
22:36:05 <adu> "Well, maybe passes on Nothing, which trumps the subsequent operations"
22:36:56 <ill_logic> Well the value on the Maybe level renders any values irrelevant that would have been returned by the rest of the do
22:38:00 <adu> Where are all those tutorials, you know, a Monad is a nuclear submarine full of rotting oranges, or something...
22:38:19 <ill_logic> Is this an academic exercise? I'm describing what I think I understand, i'm happy to admit I'm wrong, I'm just trying to figure out where I'm at in my understanding of monads.
22:38:58 <adu> ill_logic: in my honest opinion, it is futile to model a monad
22:39:19 <ill_logic> In terms of burritos sure
22:39:37 <ill_logic> But I'm trying to make one, this isn't about oranges
22:39:56 <adu> ill_logic: what a monad _is_ is anything that implements that interface, trying to think about what it's doing, or what it "has" isn't always going to work
22:40:33 <ill_logic> So I just have to deal with enough of the things that properly implement that interface to understand the sort of thing that does?
22:40:44 <adu> yes
22:40:49 <ill_logic> I'm assuming by now that you have an intuitive enough understanding.
22:40:51 <adu> I don't understand every monad
22:41:11 <adu> but I understand Maybe, Either, IO, and [], and that get's me by
22:41:25 <monochrom> I am more inclined to ask "define 'understand'"
22:41:34 <adu> lol
22:41:52 <ill_logic> Do you guys really want people to use this language :P
22:42:27 <ill_logic> I know it oughtn't be that intimidating.
22:42:38 <ill_logic> I'm taking a look at Typeclassopedia
22:42:42 <shergill> ill_logic, adu: http://youtu.be/-OxnN2pxMAg?t=49s
22:42:45 <adu> ill_logic: I definitely want people using it, I think if more people used Haskell, then Bugtraq would become a ghost-town
22:43:25 <dolio> Apples, oranges and bread?
22:43:54 <monochrom> @quote nlogax monad
22:43:54 <lambdabot> nlogax says: because people don't go "but what are arrays, *really*???" about JS or whatever. i can use monads, i can use JS arrays..
22:44:28 <adu> my friend says that about time, all the time
22:44:33 <monochrom> that is my view. you use arrays, you use monads. you don't talk about "what is"
22:44:55 <adu> "but *really* time is an illusion"
22:44:56 <tikhonjelvis> What? Understanding that an array is just a silly object is the only way not to mess up in JavaScript.
22:45:06 <tikhonjelvis> Also, I have no context, so you can feel free to ignore me.
22:45:07 <nyingen> I think part of the problem is that 'monad' has a formal definition in category theory (?) but from the viewpoint of a practical programmer, it's just a typeclass implementing certain operations
22:45:13 <monochrom> in fact, "what is an array in javascript" goes pretty deep and counterintuitive, but why should you care
22:45:35 <tikhonjelvis> E.g. if you think arguments is an array, you are going to make mistakes.
22:45:56 <ill_logic> There's a reason people don't talk about arrays but they talk about monads. Don't be silly.
22:46:22 <adu> monochrom: indeed, some JS programmers don't know that arrays are illusions
22:46:25 <tikhonjelvis> People talk about JavaScript arrays, just not on #haskell. In fact, JavaScript is surprisingly confusing.
22:46:27 <cmccann> the difference is that it's easy to think you understand how arrays work, but still make mistakes
22:46:46 * cmccann thinks javascript arrays are harder to actually understand than monads
22:46:54 <tikhonjelvis> Like the people submitting a bug to Chrome about enumerating numerical properties of an object first. That annoyed me.
22:47:01 <ill_logic> There's a reason I easily understood the concept of a sized collection of things, but I'm having trouble understanding monads.
22:47:07 <companion_cube> what are *really* people??
22:47:36 <tikhonjelvis> I personally found pointers just as difficult to get as monads.
22:47:40 <adu> ill_logic: what's the problem?
22:47:49 <tikhonjelvis> And pointers are important for understanding arrays (but not in JavaScript).
22:47:52 <adu> tikhonjelvis: pointers are monads
22:48:34 <ill_logic> adu: Well if you want me to describe the problem in a direct sense, I'm not sure I get the sort of thing that follows all these laws.
22:48:49 <ill_logic> Actually, the first question I came in here to ask, which I don't think has been answered
22:48:50 <tikhonjelvis> Do you understand what a functor is?
22:48:57 <ill_logic> Is, can I do what I'm trying to do here.
22:48:57 <monochrom> I know the reason. the reason is you just go ahead to use arrays without thinking, and you don't accept that you should also just go ahead to use monads without thinking.
22:49:12 <adu> ill_logic: what are you trying to do?
22:50:05 <ill_logic> adu: In the shorter sense, I'm trying to create a monad that returns an error state if more than 5 operations are done. Just as an exercise in arrays. In the larger sense, I'm following the advice somebody gave me, which is that I'd understand it if I tried making one.
22:50:53 <companion_cube> interesting
22:50:58 <ill_logic> monochrom: In what sense? I've used a Maybe monad. I guess I've used the list monad. I'd like to have a better sense of what's going on.
22:51:09 <adu> that's a good exercise
22:51:21 <companion_cube> ill_logic: it all boils down to the implementation of (>>=)
22:51:22 <ill_logic> Damn, I said "just as an exercise in arrays" I meant "just as an exercise in monads"
22:51:27 <ill_logic> or "just as an exercise"
22:51:28 <adu> ill_logic: so what is an "operation"?
22:51:34 <ill_logic> you guys got me mixed up :P
22:51:38 <companion_cube> (and to the type, too)
22:51:58 <ill_logic> For whoever asked, I don't understand Functors yet. I could go back and deal with that if that's recommended.
22:52:04 <monochrom> you haven't used the State monad yet. it will help your project.
22:52:24 <adu> ill_logic: Category theory? or fmap?
22:52:32 <ill_logic> monochrom: It looks like the state monad  relies on keeping the state in the inner type, not the monadic type. Is that basically the only way to carry over state?
22:52:51 <ill_logic> adu: I don't really know functors on any level.
22:53:01 <monochrom> yes
22:53:30 <tikhonjelvis> Functors are really simple at the haskell level, happily.
22:53:31 <ill_logic> ok. so I guess that answers my question. What I'm doing can't be done without playing with the inner type, if I want a proper monad.
22:54:04 <adu> fmap
22:54:09 <adu> :t fmap
22:54:10 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
22:55:20 <ill_logic> Can I ignore the polymorphism for now?
22:55:25 <tikhonjelvis> yeah
22:55:45 <tikhonjelvis> Just think of it as fmap :: Functor f => (a -> b) -> f a -> f b
22:56:02 <adu> ill_logic: just think about fmap like this if f is the list monad, the type becomes [a] -> [b]
22:56:05 <tikhonjelvis> That is, a functor is a type that you can map a function over.
22:56:45 <adu> :t map
22:56:46 <lambdabot> forall a b. (a -> b) -> [a] -> [b]
22:56:50 <adu> see?
22:57:06 <cmccann> :t \f xs -> xs >>= return . f
22:57:07 <lambdabot> forall (m :: * -> *) a a1. (Monad m) => (a -> a1) -> m a -> m a1
22:57:08 <ill_logic> OH got it
22:57:13 <ill_logic> yes adu thanks.
22:57:22 <ill_logic> So fmap is a generalization of map.
22:57:25 <adu> yes
22:57:27 <ill_logic> sorry, the other way around.
22:57:32 <ill_logic> er, no I had it right
22:57:35 <tikhonjelvis> yes you did
22:57:52 <tikhonjelvis> So functors make sense intuitively, right?
22:58:04 <ill_logic> almost, let me think
22:59:01 <tikhonjelvis> Can you come up with some examples of other functors?
22:59:17 <ill_logic> I'm trying to think of fmap for Maybe
22:59:35 <tikhonjelvis> that's a good exercise
23:00:20 <ill_logic> fmap f Just a = Just (f a) ..... fmap f Nothing = Nothing
23:00:22 <ill_logic> ?
23:00:35 <adu> (Just a)
23:00:37 <ill_logic> actually fmap f (Just a) = Just (f a) ..... fmap f Nothing = Nothing
23:00:38 <adu> but yet
23:00:42 <adu> yes
23:00:44 <tikhonjelvis> heh
23:00:52 <ill_logic> cool, yes I got it.
23:00:56 <tikhonjelvis> Can you think of some other examples?
23:01:37 <ill_logic> My Haskell exprience may be limited, perhaps I cannot.
23:01:50 <ill_logic> There are probably tools I could be using  but am not.
23:01:54 <tikhonjelvis> Ignore Haskell. Just think about what other sorts of data types would work like that.
23:02:08 <adu> can you define "instance Monad Maybe"?
23:02:31 <ill_logic> Well I was looking at the definition earlier so I could probably cheat and do it from memory.
23:04:21 <ill_logic> I guess an unordered set? That would have a similar relationship as a list.
23:04:46 <adu> i suppose
23:04:50 <tikhonjelvis> Heh, that's actually a little bit difficult because of the way the Haskell type system works.
23:04:57 <adu> but that is pretty complicated in Haskell
23:05:01 <ill_logic>  You could define one for a tuple, but then you'd have to decide whether to apply f to the first item, every item, or waht.
23:05:24 <ill_logic> yeah I'm not really creative, I can't think of what else to use a functor for
23:05:27 <strager> What about Either?
23:05:51 <tikhonjelvis> Either also works. It's basically just like Maybe.
23:05:58 <strager> What about Control.Monad.State?
23:06:04 <ill_logic> I mean yeah, but we mentioned that before. I thought it'd be too obvious. Instead of Nothing -> Nothing it'd be Left "error" -> Left "error"
23:06:09 <tikhonjelvis> yep
23:06:31 <ill_logic>  well tikhonjelvis said to ignore Haskell so I'm assuming Monad.State isn't what was intendedn
23:06:34 <tikhonjelvis> You could also do it for trees.
23:06:47 <strager> Collections are easy to think about =]
23:06:50 <cmccann> ill_logic, speaking of tuples, what if the types are different? like if you have (a, b)
23:06:50 <tikhonjelvis> Umm, yeah, I don't think thinking about the State monad will help much until you get to monads :)
23:07:17 <ill_logic> cmccann: yeah that crossed my mind. so you'd have to be restrictive about what f was applied to, or what the types of the tuple could be
23:07:24 <Kaidelong> anything that can produce a value can be treated like a functor, pretty much
23:07:34 <Kaidelong> covariant functor at least
23:07:49 <Kaidelong> like "getLine" gets a line from the console or with a list you can get the head
23:08:05 <ill_logic>  I think I get the idea though. If I have anything with type a, and I can think of how to propagate f throughout all the a's to turn them into b's, I'm set.
23:08:15 <tikhonjelvis> yeah
23:08:28 <strager> Pretty much.
23:08:33 <monochrom> you can define some kind of tree structure: data Tree a = Leaf a | Branch (Tree a) (Tree a). this is a functor too.
23:08:50 <cmccann> ill_logic, in Haskell the question resolves itself because (a, b) means ((,) a b) and you can only write a Functor instance using the last type parameter
23:08:53 <Kaidelong> things that consume values give you contravariant functors
23:08:58 <adu> ill_logic: the problem is that you would need to sort a list to represent a set faithfully, which requires that you add "Ord a =>" to every function, which makes it no longer a monad, you would have to make MonadOrd or something
23:09:17 <tikhonjelvis> adu: You could have an inefficient set with just Eq, couldn't you?
23:09:23 <tikhonjelvis> But it's still the same idea.
23:09:46 <ill_logic> Is there a set type in the library?
23:09:57 <adu> Data.Set
23:09:58 <Kaidelong> there is a Data.Set in the platform yes
23:10:31 <ill_logic>  Cool.
23:10:43 <ill_logic> Ok, so I'm presuming that this was a step to get me to understand Monads?
23:10:48 <tikhonjelvis> yes
23:10:52 <Kaidelong> you reading LYAH?
23:11:01 <cmccann> ill_logic, Functor is more fundamental than Monad in many ways
23:11:14 <tikhonjelvis> And simpler to understand initially, I think.
23:11:17 <cmccann> and any Monad can also be a Functor (but not the other way around)
23:11:35 <adu> ill_logic: when I was starting to learn Haskell, I would find it insightful to think of monads as a way of overloading ';'
23:11:50 <strager> adu: That's how I explain >>= sometimes.
23:12:05 <Kaidelong> cmccann: is that true for monads in general or the haskell ones in particular?
23:12:17 <ddarius> Monads -are- functors.
23:12:23 <tikhonjelvis> with stuff stuck on them
23:13:05 <cmccann> it's more true for monads in general, because the Monad type class lacks the Functor constraint it ought to have :P
23:13:09 <Kaidelong> would something stop you from deriving a monad from a contravariant functor?
23:13:29 <Kaidelong> if it wasn't also covariant
23:14:28 <ddarius> No contravariant functor is a monad.
23:14:30 <cmccann> Kaidelong, monads are defined as endofunctors, which excludes contravariant functors by definition, as those are functors to the opposite category
23:14:45 <Kaidelong> okay
23:14:53 <Kaidelong> thank you
23:15:23 <ddarius> I guess you could say C^op -> C^op is a contravariant functor, but this isn't really helpful.
23:15:58 <ddarius> Really covariant and contravariant as applied to a functor don't make sense out of some context.
23:16:46 <Kaidelong> @hoogle m b -> (a -> m b) -> m a
23:16:47 <lambdabot> Test.QuickCheck.Arbitrary shrinkList :: (a -> [a]) -> [a] -> [[a]]
23:16:47 <lambdabot> Control.OldException catch :: IO a -> (Exception -> IO a) -> IO a
23:16:47 <lambdabot> Network.HTTP.Base catchIO :: IO a -> (IOException -> IO a) -> IO a
23:16:50 <cmccann> there's also Cont which is sort of doubly-contravariant but that's not really relevant either
23:18:05 <ill_logic> Alright, thanks a lot guys. I'm gonna get going, and I will check out Typeclassopedia. It looks  good so far.
23:19:53 <Kaidelong> wanna ask again if anyone knows whereI can see good examples of how to use Win32, or if I should rather look at docs for C and try to adapt those
23:21:23 <Kaidelong> I've only just started learning the FFI so perhaps after I get that down I will not be looking for samples
23:21:38 <Kaidelong> but I was hoping there might be some out there int he wild
23:23:58 <Jafet> What's P(uses Windows|uses Haskell)?
23:24:13 <sanjoyd> P(uses Windows) * P(uses Haskell)
23:24:20 <cmccann> Jafet, ⊥
23:25:11 <cmccann> hm, I think I may finally have an encoding for "par" that actually works in my linear logic stuff
23:25:21 <cmccann> that only took forever and a half to figure out
23:26:30 * cmccann suspects that "par" was created mostly to troll people
23:26:42 <cmccann> I mean who comes up with a symbol like ⅋ anyway
23:27:30 <tikhonjelvis> Hey, reusing symbols by flipping them is a long mathematical tradition: ∀ ∃...
23:27:40 <sanjoyd> .
23:28:52 <cmccann> tikhonjelvis, true
23:29:08 <cmccann> I stand by my suspicion of trolling though
23:29:27 <tikhonjelvis> Hey, long mathematical tradition and trolling are in no way mutually exclusive :)
23:33:50 <LtWorf> tikhonjelvis: lol
23:34:37 <vodik> anyone here familiar with c2hs?
23:34:48 <vodik> how would one deal with Ptr ()?
23:36:56 <Cale> vodik: what do you mean by "deal with"?
23:37:47 <DanBurton> why do you have a pointer to unit?
23:38:41 <vodik> im trying to use c2hs to {# get/set ... #} a c structure. however the struct uses void * and points to itself (its linked list actually)
23:38:57 <vodik> when i used hsc2hs, i could peek/poke its fields just fine
23:39:35 <vodik> but playing with get/set, it likes to explictly cast the explanded section's pokeByteOff to Ptr ()
23:39:45 <vodik> and i can't cast that, as far as i know
23:46:42 <adnauseam> hrm, what does !! stand for in (someFunction !! 2) ?
23:47:16 <tikhonjelvis> it's indexing in the list
23:48:31 <adnauseam> oh so 2nd element from the list someFunction returns ?
23:48:38 <tikhonjelvis> third
23:49:04 <tikhonjelvis> Also, in this case someFunction is deceptively named—it's actually just a list, not a function
23:49:06 <adnauseam> oh - yeah i keep not noticing the 0 in my head
23:50:20 <adnauseam> does that mean, that even if i have map returning a list inside of someFunction, i should just name someFunction someList ?
23:50:33 <tikhonjelvis> Umm
23:50:52 <tikhonjelvis> What it means is that !! is an operator which takes a list and a number, so its first argument has to be a list.
23:50:54 <adnauseam> i'm just wondering - since you've called it deceptive
23:51:11 <adnauseam> oh i see
23:51:19 <tikhonjelvis> If you've defined it like someFunction = map fn someList, you should call it a list.
23:51:49 <adnauseam> that i'll do - should make things easier to understand
23:52:13 <ddarius> (!!) converts lists to partial functions from integers.
23:52:45 <adnauseam> hrm
23:52:46 <tikhonjelvis> Yes it does. But that is a bit of a nonsequitor.
23:52:52 <ddarius> If we had a natural number type and a stream type, (!!) would be part of the (natural) isomorphism between (Nat -> a) and (Stream a)
23:53:06 <ddarius> It's more than a bit of a non-sequitor.
23:53:37 <tikhonjelvis> a stream type?
23:53:55 <ddarius> data Stream a = Cons a (Stream a)
23:54:02 <tikhonjelvis> How is that different from a list?
23:54:05 <adnauseam> hrm stream type = data that's not exactly catigorized ?
23:54:11 <nanothief> Can't be empty
23:54:14 <tikhonjelvis> ah
23:54:28 <nanothief> well actually can't be non-infinity
23:54:28 <tikhonjelvis> I realized that just after asking the question :P
23:54:47 <adnauseam> but is it a list of the stream type that's not allowed to be empty then ?
23:54:52 <tikhonjelvis> That's actually what I imagine a stream to be, so it makes sense.
23:55:11 <augur> adnauseam: streams just cannot be finite in length
23:55:22 <augur> adnauseam: because there's no non-recursive constructor
23:56:06 <adnauseam> ill cross that bridge when i get to it :p
23:56:08 <ddarius> augur: You could have types with no non-recursive constructors that are not finite.
23:56:14 <ddarius> s/finite/infinite/
23:56:56 <augur> how so?
23:57:02 <nanothief> data NotInfinity a = NotInfinite (Maybe (NotInfinite a))
23:57:18 <augur> that has a non-recursive case tho
23:57:29 <augur> it doesn't necessarily recurse on NotInfinite
23:58:07 <nanothief> it only has one constructor, and it is recusive. It just uses Maybe to break the cycle
23:58:15 <augur> it doesnt recurse tho
23:58:24 <augur> its argument is a Maybe (NotInfinite a)
23:58:27 <augur> not a NotInfinite a
23:59:10 <augur> NotInfinite (Maybe (NotInfinite a)) ~ Maybe (NotInfinite a) ~ Nil | Recurse (NotInfinite a)
23:59:33 <nanothief> it was the only thing I could think of that would match what ddarius said
