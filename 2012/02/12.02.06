00:00:20 <NothingMan65> Alright, thanks folks, you guys are super D duper.
00:00:49 <edwardk> merijn: ok, then change it to minimize sum of squares ;)
00:00:55 <Jafet> > [(x,y) | x <- [0..4], y <- [x..4]]
00:00:56 <lambdabot>   [(0,0),(0,1),(0,2),(0,3),(0,4),(1,1),(1,2),(1,3),(1,4),(2,2),(2,3),(2,4),(3...
00:01:16 <Jafet> > [(x,y) | x <- [0..4], y <- [0..x]]
00:01:17 <lambdabot>   [(0,0),(1,0),(1,1),(2,0),(2,1),(2,2),(3,0),(3,1),(3,2),(3,3),(4,0),(4,1),(4...
00:01:28 <edwardk> > sortBy (compare `on` (\(x,y) -> x*x + y*y)) $ (,) <$> [0..10] <*> [0..10]
00:01:29 <lambdabot>   [(0,0),(0,1),(1,0),(1,1),(0,2),(2,0),(1,2),(2,1),(2,2),(0,3),(3,0),(1,3),(3...
00:01:34 <edwardk> better?
00:01:34 <merijn> NothingMan65: Anyway, you can just use sortBy and write your own helper if ordering is really a problem
00:02:16 <hughfdjackson> would it not be easier just to flip the tuple members?
00:02:25 <NothingMan65> That's cute!  Thanks
00:02:37 * hughfdjackson is speaking out of ignorance of how to do that :p
00:02:40 <edwardk> hughfdjackson: probably
00:03:29 <yitz> > sortBy (compare `on` (\(x,y) -> x^3 + y^3)) $ (,) <$> [0..10] <*> [0..10] -- yitz is feeling cubic today
00:03:30 <lambdabot>   [(0,0),(0,1),(1,0),(1,1),(0,2),(2,0),(1,2),(2,1),(2,2),(0,3),(3,0),(1,3),(3...
00:04:28 <edwardk> anything reasonable stronger than 1.0 should work
00:05:03 <Jafet> How sloppy. Your code should take an arbitrary L_p norm as a parameter.
00:05:04 <yitz> edwardk: what do you have against the L1 norm?
00:05:35 <edwardk> absolutely nothing.
00:05:44 <edwardk> i even rather prefer it.
00:05:55 <danr> > flip (,) <$> [1..3] <*> [1..3] -- hughfdjackson
00:05:57 <lambdabot>   [(1,1),(2,1),(3,1),(1,2),(2,2),(3,2),(1,3),(2,3),(3,3)]
00:06:10 <hughfdjackson> =/
00:06:11 <edwardk> some of my best friends have an L1 norm
00:06:19 <hughfdjackson> okay, my effort is clumsy as heck
00:06:27 <hughfdjackson> but it produces what he asked for in ghci
00:06:35 <Jafet> If you use the L1 norm, you are aligned with the Axis.
00:06:42 <hughfdjackson> let flip (x, y) = (y, x)
00:06:43 <danr> Jafet: ^^
00:06:45 <hughfdjackson> map a flip
00:06:51 <hughfdjackson> where a is the array of tuples
00:07:13 <hughfdjackson> oh wait
00:07:18 <hughfdjackson> it totally doesn't u.u bah!
00:07:23 <hughfdjackson> *ahem* ah well
00:07:27 <hughfdjackson> all in the spirit of practice :|
00:07:38 <yitz> hughfdjackson: flip map a flip
00:11:28 <erus`> whats the easiest way to walk a directory tree?
00:11:48 <Jafet> find
00:12:04 <erus`> i need to check every file against a condition
00:12:09 <merijn> bash shell script *ducks*
00:12:10 <erus`> and then do something if its met
00:12:34 <erus`> merijn: its a windows server unfortunately, so im gonna write a little haskell script
00:12:48 <erus`> real world haskell (tm)
00:13:24 <Jafet> On Microsoft Windows, resource forks you
00:14:50 <hughfdjackson> erus`: can't attest to its goodness or otherwise : http://rosettacode.org/wiki/Walk_a_directory/Recursively#Haskell
00:15:25 <erus`> ah cool
00:15:31 <erus`> thats easy
00:24:25 <dp_wiz> how to perform an IO () inside another monad (happstack ServerPartT)?
00:24:36 <erus`> liftIO
00:24:59 <erus`> i expect
00:27:12 <donri> in deed
00:27:41 <donri> @where ops
00:27:41 <lambdabot> shapr Cale glguy dons sjanssen dcoutts Saizan dibblego conal Philippa bos arjanb xerox Heffalump kosmikus wli Pseudonym Igloo quicksilver monochrom Lemmih jmcarthur copumpkin
00:27:44 <donri> please ban uruguayo
00:29:00 <donri> because http://i.imgur.com/4Eu87.png
00:29:09 <erus`> censorship
00:29:40 <donri> dp_wiz: what are you doing specifically?
00:29:48 <donri> dp_wiz: if it's for querying acid-state it provides monadio variants
00:30:16 <dp_wiz> donri: i'm logging a request in happstack-lite
00:30:36 <donri> dp_wiz: happstack already has request logging
00:31:05 <donri> need to configure hslogger though
00:31:43 <donri> updateGlobalLogger rootLoggerName $ setLevel INFO -- for example
00:32:01 <donri> import System.Log.Logger
00:35:00 * hackagebot ghc-mod 1.10.0 - Happy Haskell programming on Emacs  http://hackage.haskell.org/package/ghc-mod-1.10.0 (KazuYamamoto)
00:35:02 * hackagebot mix-arrows 1.2 - Mixing effects of one arrow into another one  http://hackage.haskell.org/package/mix-arrows-1.2 (MiguelMitrofanov)
00:43:14 <rtharper> Anyone know who to speak to about posting an "Upcoming Event" on Haskell.org?
00:44:20 <donri> rtharper: just edit http://www.haskell.org/haskellwiki/Template:Main/Events
00:50:00 * hackagebot xournal-types 0.3.2 - Data types for programs for xournal file format  http://hackage.haskell.org/package/xournal-types-0.3.2 (IanWooKim)
00:51:19 <rtharper> thanks a ton, donri
00:53:18 <koala_man> what's the MonadPlus instance for STM?
00:54:00 <wavewave> hxournal 0.6.4 is out!
00:54:16 <danr> retry and orElse
00:54:19 <danr> koala_man: ^
00:55:00 * hackagebot hxournal 0.6.4 - A pen notetaking program written in haskell  http://hackage.haskell.org/package/hxournal-0.6.4 (IanWooKim)
00:55:02 * hackagebot happy 1.18.9 - Happy is a parser generator for Haskell  http://hackage.haskell.org/package/happy-1.18.9 (SimonMarlow)
00:55:43 <koala_man> hmm
00:56:01 <koala_man> oic
00:56:04 <koala_man> danr: thanks!
00:57:18 <danr> koala_man: np :)
00:58:09 <koala_man> danr: could I have seen that in the documentation somehow?
00:58:27 <danr> if you click source in the upper right corner here http://hackage.haskell.org/packages/archive/stm/2.1.1.2/doc/html/Control-Monad-STM.html
00:58:52 <koala_man> ah, of course
00:58:55 <koala_man> thanks again!
00:58:59 <danr> :)
01:02:47 <Philonous__> I keep seeing people refer to "Types of kind *", but isn't that redundant?
01:03:29 <mux> what about types of kind * -> * ? or new named kinds ?
01:03:42 <mux> concrete types of kind * would be redundant though
01:04:54 <Philippa> yeah, "type" is commonly used the same way as "term". There's even an equivalence with "value" available given the presence of first-class functions
01:05:13 <Philippa> we don't see a lot of types in Haskell that aren't beta-normalised
01:07:26 <Philonous__> I forget that "Type" is supposed to to "stuff that lives on the type level" rather than "something that is inhabitable by values" or even "Set". Does that mean that Constraints are types?
01:07:31 <Philonous__> to be*
01:07:58 <rtharper> Philippa: beta normalised?
01:08:14 <mux> in GHC 7.4.x at least, yes; there's even a new Constraint kind corresponding to those
01:08:16 <Philonous__> The thought of a Type "True" makes me cringe
01:14:21 <Philippa> rtharper: There's a face of the lambda cube, many pure type systems etc etc where you can have functions at the type level. It's a perfectly normal thing to see in a dependently-typed language, for example
01:14:40 <Philippa> we don't generally bother with the rule in Haskell because there wouldn't be a lot to beta-reduce :-)
01:14:59 <rtharper> Okay, so you mean beta normalised in the sense of a term representing a type that is in beta normal form
01:15:00 <rtharper> right okay
01:15:02 <rtharper> I'm with you
01:16:11 <Philippa> we don't really have a positive term/name for values that aren't functions in Haskell, either - just "non-function" or the like
01:17:12 <Jafet> "Things which haven't been generalised yet"
01:18:34 <Philippa> that's a negative definition too :-)
01:18:59 <Jafet> Oh, so you're a pro-generalisation hippy
01:19:21 <Philippa> no, I'm using it in the logical sense - you're defining it by an absence again
01:19:33 <Philippa> (absence of having generalised, absence of being a function)
01:23:13 <erus`> Philonous__: why?
01:24:33 <Jafet> He should save the cringe for the type False
01:25:30 <rtharper> join ##470
01:25:33 <rtharper> oops
01:26:01 <Philonous__> Jafet:  I'm Talking about True :: Bool, "data False where" would be a perfectly acceptable type.
01:26:13 <frerich> Nice, and I thought '/join 0' gets you to the secret channel.
01:27:08 <Jafet> /join #*******
01:28:04 <Jafet> @djinn a -> Not a -> b
01:28:04 <lambdabot> f a b = void (b a)
01:28:04 <Philippa> Philonous__: what's wrong with True :: Bool :: Set or similar?
01:28:27 <Philonous__> It's just because I like to think of Types as Sets
01:28:41 <Philippa> here, have a universe
01:29:26 <Philippa> really, impredicative types should freak you out far more :-)
01:29:36 <quicksilver> Philippa: thanks, just waht I needed.
01:29:45 <quicksilver> "for the man who has everything : somewhere to put it all"
01:34:18 <erus`> I can parallelize this tree walk :3
01:34:51 * frerich wishes there was a 'Moon' data structure.
01:35:24 <ddarius> @google "moon data structure"
01:35:26 <lambdabot> http://david-in-tokyo.blogspot.com/2005/11/e17-creation-of-moonclock-module-part_06.html
01:35:26 <lambdabot> Title: David @ Tokyo: E17: Creation of a Moonclock module - Part 1
01:37:07 <Philippa> frerich: you'll have to settle for the pony package?
01:42:21 <erus`> @pl \x -> notElem "." x && notElem ".." x
01:42:21 <lambdabot> ap ((&&) . notElem ".") (notElem "..")
01:43:41 <jaykay_> .
01:45:02 * hackagebot process-conduit 0.0.0 - Conduit for process  http://hackage.haskell.org/package/process-conduit-0.0.0 (HideyukiTanaka)
01:47:53 <ddarius> null $ intersect [".", ".."] x
01:49:32 <mauke> :t \x -> all (`notElem` x) [".", ".."]
01:49:34 <lambdabot> [[Char]] -> Bool
01:49:50 <Peaker> @index intersect
01:49:51 <lambdabot> Data.List, Data.Set
01:50:10 <mauke> :t flip all [".", ".."] . flip notElem
01:50:11 <lambdabot> [[Char]] -> Bool
01:50:24 <ivanm> is this definition correct? http://www.haskell.org/haskellwiki/Higher_order_function
01:50:45 <ddarius> ivanm: That's the typical definition.
01:50:54 <erus`> @filterM
01:50:54 <lambdabot> Unknown command, try @list
01:50:56 <ddarius> E.g. see wikipedia.
01:51:00 <erus`> @hoogle filterM
01:51:00 <lambdabot> Control.Monad filterM :: Monad m => (a -> m Bool) -> [a] -> m [a]
01:51:00 <lambdabot> Data.Graph.Inductive.Query.Monad graphFilterM :: GraphM m gr => (Context a b -> Bool) -> GT m (gr a b) [Context a b]
01:51:03 <ivanm> never heard of the "returns a function as result" aspect
01:51:11 <ivanm> and having an argument about it on SO :p
01:51:30 <erus`> @hoogle (a -> Bool) -> [m a] -> [m a]
01:51:30 <lambdabot> Control.Monad mfilter :: MonadPlus m => (a -> Bool) -> m a -> m a
01:51:31 <lambdabot> Data.IntMap filter :: (a -> Bool) -> IntMap a -> IntMap a
01:51:31 <lambdabot> Data.Sequence dropWhileL :: (a -> Bool) -> Seq a -> Seq a
01:51:41 <Jaxan> ddarius: why is "or returns a function as result" part of the definition? I mean practically every function taking more arguments is such a function...
01:51:51 <quicksilver> "practically every" ?
01:52:04 <Jaxan> ;D
01:52:08 <ddarius> Jaxan: That's not true in C.
01:52:09 <quicksilver> but, you don't have to curry functions. That's just a haskell thing.
01:52:20 <Jaxan> ah, ok
01:52:22 <quicksilver> You can perfectly well have multiple arguments A x B x C --> D
01:52:41 <Palmik> Hi guys, I have a weird problem with simple recursive parser here http://hpaste.org/57521 Could anyone help me out?
01:52:47 <Jaxan> I assumed it was in a haskell context
01:52:56 <ivanm> Jaxan: yeah, it is
01:53:07 <ivanm> and this guy keeps arguing that "Int -> (Char -> Char)" is a HOF
01:53:12 <ddarius> It is.
01:53:26 <rostayob> ivanm: why wouldn't that be a hof?
01:53:45 <ivanm> rostayob: I've only ever heard HOFs be defined as being "takes a function as a parameter"
01:53:55 <rostayob> ivanm: no, they're of even if they return functionx
01:53:58 <rostayob> *functions
01:54:08 <rostayob> (Int, Char) -> Char is not a hof
01:55:26 <rostayob> ivanm: if there is more than one "->" in a type signature, it's a hof :)
01:55:43 <Philippa> though it may /also/ be first order, yeah :-)
01:56:09 <Philippa> (it's common to call the fragment of STLC that doesn't allow functions as parameters first order, for example)
01:56:09 <ivanm> I have never heard of that part of the definition before, that's all
01:56:26 <Peaker> Terminology arguments, yuck.
01:56:31 <rostayob> Philippa: what's a STLC?
01:56:36 <rostayob> ah
01:56:37 <Philippa> Simply-Typed Lambda Calculus
01:56:40 <rostayob> simply typed lambda calculus
01:56:42 <rostayob> right
01:57:02 <rostayob> acronyms!
01:57:15 <Philippa> Peaker: there are some plenty sensible ways of resolving something that starts as a terminology argument
01:57:33 <Jafet> As opposed to complicatedly typed lambda calculus
01:57:40 <ddarius> Really the point is not to enumerate a list of things you can do with "functions" for them to be "higher order."  The intent is that a language supports higher order functions if they are first-class, i.e. you can do with them -anything- you could do to any other value, including taking them as parameters, returning them as results, storing them in data structures.
01:57:42 <Philippa> ivanm: "or returns" makes a lot more sense in algol-flavoured languages
01:58:19 <bharath_g> all functions which take more than one argument in haskell are hofs
01:58:25 <rostayob> bharath_g: no
01:58:28 <rostayob> well...
01:58:29 <bharath_g> why not
01:58:31 <Philippa> just not interestingly so
01:58:33 <ddarius> bharath_g: All functions in Haskell take only one argument.
01:58:39 <ivanm> Philippa: yeah, it's a rather trivial aspect in Haskell
01:58:49 <rostayob> I'd say (a, b) -> c is not higher order while "taking two arguments"
01:58:54 * frerich wonders how you plan to agree on what a higher-order function is if you don't even agree on what a function is in this context.
01:58:55 <Jafet> Well then, bharath's statement is true.
01:59:03 <Jafet> It's a statement about an empty set
01:59:04 <ddarius> Jafet: It is true.
01:59:08 <rostayob> ehe
01:59:08 <Philippa> frerich: aren't isomorphisms a PITA?
01:59:19 <bharath_g> (a,b)->c takes only one argument the tuple (a,b)
01:59:25 <bharath_g> a->b->c
01:59:37 <Philippa> it's not that people are disagreeing about what functions are: they're disagreeing about what they /aren't/ in a given statement :-)
01:59:51 <ddarius> If you have the isomorphism between (a,b) -> c and a -> b -> c, then your language -definitely- supports higher order functions.
01:59:55 <rostayob> bharath_g: 1) it's terminology, in SML you'd say that that function takes two arguments. a -> b -> c takes an "a" and returns "b -> c", two arguments
02:00:02 <yitz> Palmik: what do expect to get from "aaa_bb_ccc___"?
02:00:03 * hackagebot hxournal 0.6.4.0 - A pen notetaking program written in haskell  http://hackage.haskell.org/package/hxournal-0.6.4.0 (IanWooKim)
02:00:07 <rostayob> ops. there should be a 2) after the . :P
02:00:25 <yitz> *you
02:00:43 <frerich> Philippa: Maybe. I'm thinking, a very tasty burrito could probably be considered a higher-order burrito.
02:00:54 <rostayob> bharath_g: in general you can talk about functions that with products as arguments as functions with multiple arguments... or at least that's the terminology in some functional languages
02:01:41 <Palmik> yitz, "aaa<em>bb</em>ccc_<em>_</em>_" I guess.
02:01:46 <rostayob> In SML most functions are actually defined like that, which is irritating
02:02:37 <yitz> Palmik: well no, just "aaa", then it leaves remainder of the rest
02:02:53 <yitz> Palmik: so strong never sees the trailing ___
02:03:17 <Palmik> Wait, strong is initiated by __
02:03:42 <Palmik> Right now it produces "aaa<em>bb</em>ccc___"
02:03:48 <yitz> Palmik: yeah but then it requires a trailing __ after the first LinePart.
02:04:06 <yitz> Palmik: but it doesn't find that. so it just fails, and you move on in the choice.
02:04:40 <Palmik> yitz, what did you mean by the "just "aaa""?
02:05:19 <yitz> Palmik: the strong parser wants __, then a *single* LinePart, then a following __.
02:05:48 <yitz> Palmik: same with em, it only works in your example because there is a single LinePart inside.
02:06:16 <Palmik> Aaah, you are right. :)
02:06:37 <yitz> Palmik: but obviously you are on the right track
02:10:07 * hackagebot process-conduit 0.0.1 - Conduit for process  http://hackage.haskell.org/package/process-conduit-0.0.1 (HideyukiTanaka)
02:12:43 <Palmik> yitz, thanks, lets see if I can fix it. :)
02:15:01 <erus`> i keep thinking they should make a C with typeclasses and currying and stuff but in the end i just want everything that haskell has
02:15:08 <erus`> might aswel be haskell :P
02:15:20 <mreh> this library flux has made a monad out of the openGL callbacks
02:16:51 <Philippa> you could create a reasonable language that's approximately haskell as a compile-time metalanguage for C
02:17:38 <Philippa> you'd be allowed what amount to run-time HOFs, you'd just have to build their encoding
02:22:26 <koala_man> would it be right to say that instances of MonadPlus are monads whose category also forms a monoid?
02:24:00 <quicksilver> short answer, koala_man, that doesn't make sense
02:24:11 <quicksilver> although some permutation of those words, with some extra words added, might be right.
02:24:32 <quicksilver> "monads whose category" isn't right - that suggests each monad "has" a category.
02:25:01 <quicksilver> in fact if you look at the type of mplus:
02:25:05 <quicksilver> @type mplus
02:25:06 <lambdabot> forall (m :: * -> *) a. (MonadPlus m) => m a -> m a -> m a
02:25:18 <quicksilver> it's not one monoid, it's a family of monoiads - one at each 'a'.
02:25:43 <koala_man> a monad has a functor, and the functor's codomain forms a category?
02:25:57 <Palmik> yitz, weird, I thought that simply changing parseLineParts like this http://hpaste.org/57522 should do the trick, but then even a simple "__aaa__" is transformed to "__aaa__". I have also tried to introduce the many1 just into the parseStrong and parseEmphasize also without any luck (the result was then "__"). Interestingly, if I introduced the many1 just to parseStrong, the result was <em><em>aaa</em>/em>
02:26:18 <Palmik> I'm obviously overlooking something, again.
02:26:40 <quicksilver> a family of monoids at each 'a' (with some extra naturality conditions) is called a monoidal category.
02:26:55 <quicksilver> koala_man: all functor's codomains form categories.
02:27:09 <quicksilver> s/'s/s'/;
02:27:14 <koala_man> yes
02:27:47 <koala_man> so a monad whose functor forms a monoidal category?
02:28:08 <Philippa> quicksilver: I'd expect "the" category of a monad to be the one the endofunctor operates on, YMMV?
02:28:51 <bharath_g> what is '~' in haskell
02:28:59 <quicksilver> Philippa: sure, that's fair enough.
02:29:16 <quicksilver> Philippa: but the monoids are many, not one, and they're in the image.
02:29:33 <Philippa> with a little wiggle room to include the subcategory that you have to target in practice in Haskell
02:29:52 <quicksilver> koala_man: also there is no real agreement on how strong the rules are that we expect MonadPlus instances to obey.
02:30:14 <Philippa> yeah, it's a monoid family rather than a monoid though it's not uncommon to bend that distinction where it's obvious that the latter has no sensible meaning
02:30:25 <quicksilver> although since instances have to be polymorphic we get a bunch of naturality conditions for free.
02:41:53 <danr> @free (a -> b) -> [a] -> [b]
02:41:53 <lambdabot> Pattern match failure in do expression at Plugin/Free/FreeTheorem.hs:54:20-34
02:42:41 <eikke> @free a -> b -> a
02:42:41 <lambdabot> Extra stuff at end of line
02:53:29 <erus`> :t filterM
02:53:30 <lambdabot> forall a (m :: * -> *). (Monad m) => (a -> m Bool) -> [a] -> m [a]
02:53:42 <dmwit> ?free foo :: (a -> b) -> [a] -> [b]
02:53:42 <lambdabot> g . h = k . f => $map g . foo h = foo k . $map f
02:54:21 <dmwit> ?free foo :: a -> b -> a
02:54:21 <dmwit> danr, eikke: You need to name your functions. =)
02:54:21 <lambdabot> f . foo x = foo (f x) . g
02:54:51 <erus`> @hoogle (a -> b -> c) -> (m a) -> (m b) -> (m c)
02:54:51 <lambdabot> Control.Monad liftM2 :: Monad m => (a1 -> a2 -> r) -> m a1 -> m a2 -> m r
02:54:52 <lambdabot> Control.Applicative liftA2 :: Applicative f => (a -> b -> c) -> f a -> f b -> f c
02:54:52 <lambdabot> Data.IntMap intersectionWith :: (a -> b -> c) -> IntMap a -> IntMap b -> IntMap c
02:55:22 <danr> dmwit: thanks :)
02:55:42 <danr> ?free map
02:55:43 <lambdabot> g . h = k . f => $map g . map h = map k . $map f
02:59:21 <bartavelle> how am I supposed to work with a library that wants standard bytestrings, and another that outputs the lazy kind ?
02:59:26 <bartavelle> err
02:59:28 <bartavelle> the other way around
02:59:41 <Jafet> @hoogle toChunks
02:59:42 <lambdabot> Data.ByteString.Lazy toChunks :: ByteString -> [ByteString]
02:59:42 <lambdabot> Data.ByteString.Lazy.Char8 toChunks :: ByteString -> [ByteString]
02:59:42 <lambdabot> Data.Text.Lazy toChunks :: Text -> [Text]
03:00:24 <Jafet> Okay, I can tell you it isn't called toChunks
03:00:28 <bartavelle> ;)
03:00:40 <bartavelle> but it is a bytestring function ?
03:01:05 <bartavelle> I thought hell would break loose if I fed something strict to something that expects something lazy
03:01:18 <quicksilver> well they're just a different type
03:01:26 <quicksilver> hopefully getting a type error isn't "all hell" for you
03:01:35 <quicksilver> otherwise haskell programming will be stressful.
03:01:46 <bartavelle> well I thought they wanted lazy for a reason, probably from a performance point of view
03:01:50 <bartavelle> hehe
03:01:57 <quicksilver> toChunks/fromChunks are the basic conversions
03:02:11 <quicksilver> toChunks converts a lazy BS to a list of strict BSes
03:02:18 <quicksilver> and fromChunks does the converse
03:02:39 <quicksilver> a lazy BS *is* a list of strict BSes, so this is just exposing the representation cleanly.
03:02:50 <bartavelle> ah !
03:03:30 <bartavelle> yes this works cleanly now
03:03:32 <bartavelle> thanks
03:04:59 <erus`> @hoogle find
03:04:59 <lambdabot> Data.List find :: (a -> Bool) -> [a] -> Maybe a
03:05:00 <lambdabot> Data.Foldable find :: Foldable t => (a -> Bool) -> t a -> Maybe a
03:05:00 <lambdabot> Data.List findIndex :: (a -> Bool) -> [a] -> Maybe Int
03:43:43 <guest1984> I'm looking for a tutorial/examples on how to use Text.PrettyPrint (in particular, examples related to changing line length -- no matter what I do everything gets printed on one line), any suggestions?
03:43:54 <erus`> can you see a pattern in these numbers [1, 3, 4, 7, 8, 10, 11, 15 ...
03:44:55 <erus`> its the number of bits that change when you increment a binary number
03:45:24 <erus`> i wanna count the total for a n-bit word enumerated through every value
03:46:17 <ceii> erus`: is http://oeis.org/A005187 what you're looking for?
03:47:02 <erus`> yes
03:48:00 <guest1984> For example, how can I use PrettyPrint to print a list of String separated by "," with a maximum line length of 80?
03:48:04 <erus`> that is a very hard to read website
03:56:02 <sopvop> ghc 7.4.1 :(    Kind mis-match     The second argument of `Result' should have kind `*',     but `()' has kind `()'     In the type `Data.HashTable.ST.Basic.HashTable s Int (Result str ())'
03:56:56 <mux> sopvop: using the DataKinds extension?
03:57:21 <sopvop> Nope
03:57:52 <sopvop> TemplateHaskell, QuasiQuiotes, FlexibleContexts
03:57:56 <mux> sopvop: what package is this?
03:58:14 <sopvop> peggy, doubt anyone else uses it :)
03:58:28 <mux> hashtables 1.0.1.2?
03:58:29 <mux> oh.
03:58:37 <mux> not on hackage?
03:59:02 <sopvop> On hackage, but not 7.4.1 ready. Had to cabal unpack alot of stuff.
04:00:00 <sopvop> Just how can I tell ghc what () has kind * ? :)
04:00:50 <sopvop> the Result is just data Result str a
04:00:51 <sopvop>   = Parsed SrcPos Char str a
04:00:51 <sopvop>   | Failed ParseError
04:00:55 <ceii> it's supposed to default to *, and you'd need '() to refer to the lifted data constructor instead
04:01:03 <ceii> no idea what's happening
04:01:14 <mux> it's weird that this happens without DataKinds
04:01:37 <mux> sopvop: can you maybe extract a short test case from this code that exhibits this problem and pastebin it?
04:02:10 <sopvop> I'll try, but can't promise anything
04:06:17 <hpaste> erus` pasted “What am i doing wrong?” at http://hpaste.org/57526
04:08:23 <ceii> erus`: you don't want to recursively walk "." and ".."
04:08:42 <erus`> ah good point
04:09:04 <Jafet> Does Windows use "." and ".."?
04:09:16 <erus`> yup
04:09:21 <mux> erus`: not only that, you need to check for any loop
04:09:21 <Botje> also, use slashes to separate your directories
04:09:27 <Botje> since they work on every platform :)
04:09:31 <dp_wiz> What is currently preferred interface to PostgreSQL? (to use with happstack)
04:09:35 <mux> symlinks/hardlinks can easily cause loops
04:09:43 <ceii> no, use System.FilePath.</>
04:09:49 <Jafet> Use </> to separate directories
04:10:11 <Jafet> But even that barely scratches what Windows can do
04:10:28 <wferi> Hi! Is there a way in GHC to embed the current source file name and line number into a string without resorting to some preprocessor?
04:10:59 <Jafet> wferi: pattern match failure
04:11:10 <Jafet> > let f 1 = () in f 2
04:11:11 <lambdabot>   *Exception: <interactive>:3:4-11: Non-exhaustive patterns in function f
04:11:27 <wferi> Jafet: not in an error message :)
04:11:35 <nand`> you can always catch the error
04:11:38 <erus`> ok i filter out . and .. and its still not working as expected
04:11:40 <wferi> I'd like to output it
04:11:41 <nand`> then extract the numbers
04:11:43 <nand`> but that's a hack
04:11:52 <wferi> nand`: exactly
04:11:57 <wferi> any better way?
04:12:12 <frerich> erus`: A small remark, your main function is actually just 'getCurrentDirectory >= walk'
04:12:17 <frerich> >>= even
04:12:24 <ceii> wferi: there's no "right way" at least
04:12:24 <Jafet> unsafePerformIO $ catch (evaluate (let f 1 = () in f 2)) return
04:12:53 <wferi> I'd do that in Perl, sure... :/
04:13:08 <MostAwesomeDude> i think wferi is looking for a way to trace his execution.
04:13:17 <wferi> no, MostAwesomeDude
04:13:32 <MostAwesomeDude> @hoogle trace
04:13:33 <lambdabot> Debug.Trace module Debug.Trace
04:13:33 <lambdabot> Debug.Trace trace :: String -> a -> a
04:13:33 <lambdabot> Debug.Trace traceShow :: Show a => a -> b -> b
04:13:35 <Jafet> I think wferi is trying hard to cut corners on error handling.
04:13:36 <wferi> I'd just like to annotate my program's output by source code locations
04:13:53 <wferi> mates, no errors anywhere
04:14:04 <Jafet> Surely you can come up with more meaningful labels than line numbers?
04:14:22 <MostAwesomeDude> Does GHC provide any macros for this stuff?
04:14:33 <wferi> well, file names would be needed as well
04:14:37 <Jafet> It does not.
04:14:38 <wferi> or module names at least
04:14:55 <wferi> my program output a largish config file
04:14:58 <Jafet> And rightly so--most conceived uses for this are ill-conceived.
04:15:16 <wferi> and I'd like to trace back parts of it to their origins
04:15:38 <quicksilver> what's wrong with using a preprocessor?
04:15:55 <ceii> wferi: look at this maybe? http://hackage.haskell.org/package/file-location-0.4.1
04:16:06 <quicksilver> I think GHC doesn't include __LINE__ functionality because they expect you to use a preprocessor for that.
04:16:10 <ceii> though I'd rather not know how it's implemented >>
04:16:32 <wferi> quicksilver: well, if there's no better way, I'll bite the bullet
04:16:56 <hpaste> sopvop pasted “ghc-prim:GHC.Tuple.() has kind ()?” at http://hpaste.org/57528
04:17:03 <sopvop> mux: since that stuff is QQ generated, I've -ddump-splice and it looks like that.
04:17:09 <MostAwesomeDude> GHC doesn't provide these macros; I just checked. So you get to build this yourself.
04:17:12 <sopvop> Guess neet to change tuple to unit?
04:17:17 <wferi> I'm looking through the Located stuff in module GHC
04:17:48 <frerich> erus`: your program works fine for me if "." and ".." is filtered from what getDirectoryContent yields
04:17:50 <wferi> rather elaborate, but I'm not sure it's what I need
04:17:52 <Jafet> wferi: why not give meaningful names to the sections of your output?
04:18:10 <erus`> frerich: in runghc ?
04:18:20 <mux> sopvop: hah, it definitely looks like there's a TH/DataKinds mixup here
04:18:20 <wferi> Jafet: the output is unstructured
04:18:20 <Jafet> I don't understand this pressing need for line numbers.
04:18:29 <ceii> oh, file-location uses TH
04:18:30 <frerich> erus`: Yup
04:18:31 <wferi> a long list of definitions
04:18:32 <hpaste> erus` pasted “still no worky” at http://hpaste.org/57529
04:18:35 <jonkri> can a acid state database be used by two applications at the same time?
04:19:16 <mux> sopvop: this is Core though, right? can you reduce this to a readable haskell one-liner that wouldn't depend on any specific package?
04:19:17 <ceii> erus`, no worky how?
04:19:27 <Jafet> It doesn't matter what your output is--for each line number that you would have put in, replace it with a correspondingly more meaningful and contextual english label.
04:19:44 <yitz> dp_wiz: google postgresql on the haskell-cafe list. there was recently an interesting conversation between the authors of two packages comparing their approaches.
04:19:47 <Jafet> Line numbers are not a property of a program.
04:20:08 <wferi> but they are free
04:20:17 <Jafet> You get what you pay for!
04:20:23 <wferi> and I'd have to come up with good conceptual names
04:20:25 <MostAwesomeDude> Why not trace with the names of your functions instead?
04:20:29 <yitz> dp_wiz: one is a direct binding to libpsql (or whatever it's called), and the other is within a larger db interface framework, perhaps it was hdbc.
04:20:37 <wferi> which I mostly do not use
04:20:47 <alang_> mokus_: hello
04:21:04 <wferi> MostAwesomeDude: I'd be fine with that
04:21:17 <erus`> ceii http://hpaste.org/57530
04:21:31 <Sicp> I CAN HAS KELL?
04:21:35 <wferi> if that doesn't mean I'll have to enter all my function names twice :)
04:22:44 <Jafet> ...no, use a preprocessor!
04:23:04 <MostAwesomeDude> wferi: derp = trace "Derpin'!" $ ...
04:23:23 <wferi> ok, thanks ;)
04:23:33 <erus`> ceii: can you run my code for me
04:23:49 <MostAwesomeDude> I mean, are you trying to track down a bug, or are you wanting to prettify your output?
04:24:22 <wferi> not to prettify, just to make it more easy to track back to the piece of code which generated it
04:24:34 <dp_wiz> (sry for newbish spam, but..) How is there with evented/async io in haskell? I.e. i use python's gevent which lifts all sockets to libev pool and with no config app can handle tons of sim. connections. Is there any hoops i could jump through to fully utilize system iowait time?
04:24:40 <wferi> ok, it's prettyfying, I guess...
04:26:18 <MostAwesomeDude> wferi: Well, is it a permanent part of the output? If so, you should explicitly write up the code for generating it.
04:26:28 <erus`> oh shit im an idiot
04:26:30 <Jafet> dp_wiz: http://shootout.alioth.debian.org/u64q/performance.php?test=threadring
04:26:38 <MostAwesomeDude> Even if you hax it with a preprocessor, you'll still gonna have to write up your rationale in comments. :3
04:26:40 <bobry> nice to know 0% of the packages on Hackage is ready for 7.4
04:26:44 <erus`> doesFileExist is checking agains just the file name
04:26:50 <Palmik> Hmm, I still can not figure out the problem with this simple parser http://hpaste.org/57531 -- could someone point me in the right direction? (Code, non-working examples with actual and expected output are all in the paste)
04:26:57 <bobry> took 20 minutes to get cabal-install to compile %)
04:27:33 <Jafet> doesPlatonicFileExist
04:27:50 <wferi> MostAwesomeDude: yes, it would be output as comments. I'd code it up once, then I'd like to make effortless use of it.
04:27:57 <MostAwesomeDude> dp_wiz: What's your question, exactly? Are you just asking for comfirmation that Haskell has some sort of concurrent networking?
04:28:28 <ceii> erus`: also, filtering against [".",".."] doesn't work because you get qualified paths
04:28:40 <bobry> dp_wiz: http://www.haskell.org/haskellwiki/GHC/Concurrency
04:28:45 <erus`> ceii: no i dont
04:28:48 <erus`> thats the issue
04:28:50 <wferi> MostAwesomeDude: location info would  be perfect, but that's too verbose and fragile to add by hand whenever I add some new code
04:29:00 <ceii> erus`: oh, I messed up something somewhere
04:29:02 <ceii> forget that
04:29:26 <ceii> but you're right about the doesFile Exist part
04:29:37 <jonkri> assuming that acid state databases cannot be used by two applications at the same time, is there a way that i can have a happstack application listen to two ports instead of one, performing different actions depending on what port that is accessing the server?
04:30:11 <erus`> @hoogle (</>)
04:30:11 <lambdabot> System.FilePath.Windows (</>) :: FilePath -> FilePath -> FilePath
04:30:11 <lambdabot> System.FilePath.Posix (</>) :: FilePath -> FilePath -> FilePath
04:30:36 <quicksilver> jonkri: yes, surely, there must be?
04:30:53 <quicksilver> can't believe an app server wouldn't be able to listen on multiple ports.
04:30:59 <quicksilver> but, worst case, front-end proxy
04:31:14 <quicksilver> real deployments often have front-end proxies anyway for loads of different reasons.
04:32:17 <Peaker> Using Haskell as a scripting language is great fun.. I think it's nicer than Python even for that purpose
04:32:41 <Peaker> import unqualified everything, just make a mess, it's a script! The liberty :)
04:34:54 <nand`> Peaker: yes but how do you embed it into other programs? or do you mean just standalone scripts?
04:34:58 <Jafet> {-# LANGUAGE CPP #-} #include "~/.ghci"
04:35:06 <yitz> Peaker: there should be import Cale to give a lambdabot-like environment
04:35:26 <Peaker> yitz: :)
04:35:39 <Peaker> nand`: I'm writing a Haskell script to generate my Tupfiles... turning out to be nice and usable
04:35:59 <nand`> yes it's nice for that purpose
04:36:35 <Jafet> Palmik: parse it on a piece of paper
04:38:05 <rata_> hi
04:38:13 <jonkri> quicksilver: good advice, thanks
04:38:42 <Jafet> Then, if you like, scan in that piece of paper so someone can look at it and explain which part of parsec's greedy matching behaviour you misunderstood
04:38:50 <quicksilver> jonkri: your front-end proxy could either map the URL space, or add an extra header, to distinguish the two "apps"
04:40:04 <jonkri> quicksilver, aha. :) i think i will go with mapping the url space :)
04:41:12 <osa1> is there a way to see documentation of a function in ghci or do I have to visit haskell web page?
04:41:15 <statusfailed> is this bad code? tail (xs >>= (',':) . show
04:41:27 <statusfailed> add last bracket :p
04:42:17 <Jafet> Did it eat its veggies?
04:42:32 <ceii> it'd be a lot clear if you applied tail to xs directly
04:42:47 <statusfailed> ceii: wouldn't that do something else?
04:42:48 <ceii> wait, no that's not it
04:42:51 <ceii> right
04:43:20 <Jafet> > "[" ++ intercalate ", " [1, 2, 3, 4, 5] ++ "]"
04:43:21 <lambdabot>   No instance for (GHC.Num.Num [GHC.Types.Char])
04:43:21 <lambdabot>    arising from the literal ...
04:43:31 <Jafet> > "[" ++ intercalate ", " (show <$> [1, 2, 3, 4, 5]) ++ "]"
04:43:32 <lambdabot>   "[1, 2, 3, 4, 5]"
04:43:47 <otters> > show <$> [1..5]
04:43:48 <lambdabot>   ["1","2","3","4","5"]
04:43:53 <otters> never thought of it that way
04:44:17 <statusfailed> > [1..5] >>= return . show
04:44:19 <lambdabot>   ["1","2","3","4","5"]
04:44:36 <otters> > [1..5] >>= show
04:44:37 <lambdabot>   "12345"
04:44:48 <statusfailed> oh :P
04:44:56 <otters> but that's concatmap
04:45:05 <otters> on the plus side, it's an easy way to join ""
04:45:09 <statusfailed> yeah that's what I wanted
04:45:39 <statusfailed> [1..5] >>= (", " ++) . show
04:45:43 <statusfailed> > [1..5] >>= (", " ++) . show
04:45:44 <lambdabot>   ", 1, 2, 3, 4, 5"
04:46:00 <statusfailed> eh, i'm gonna leave it. seems fine to me~
04:46:16 <dp_wiz> intercalate looks best (:
04:46:23 <byorgey> > intercalate ", " . map show $ [1..5]
04:46:25 <lambdabot>   "1, 2, 3, 4, 5"
04:46:29 <ceii> statusfailed: ^ intercalate is what you want
04:46:55 <statusfailed> awww, but I only just learned about monads~
04:47:30 <Jafet> Why not use applicatives
04:47:33 <Jafet> > concat $ (++) <$> ("": repeat ", ") <*> (show <$> [1..5])
04:47:35 <lambdabot>   "12345, 1, 2, 3, 4, 5, 1, 2, 3, 4, 5, 1, 2, 3, 4, 5, 1, 2, 3, 4, 5, 1, 2, 3...
04:47:36 <byorgey> statusfailed: sadly for you, there are still a few tasks for which monads are not the best solution =)
04:47:43 <Jafet> Hrm wait
04:47:48 <statusfailed> hoho
04:48:16 <byorgey> Jafet: looking for ZipList?
04:48:40 <Jafet> I left it at home
04:49:31 <otters> there are tasks for which monads are not the right solution?
04:49:36 <otters> with monads, we can make them the right solution
04:49:56 <ceii> there are tasks for which the Identity monad is a great solution
04:50:04 <dp_wiz> monads' like violence?..
04:50:08 <ceii> btw Haskell provides special syntax for the Identity monad
04:50:15 <ceii> you can just write non-monadic code
04:50:22 <otters> surely not
04:50:23 <otters> oh
04:50:24 <otters> right
04:50:27 <otters> ho ho
04:51:12 <Jafet> But you can't possibly write non-monadic code. All code exists in the Identity monad.
04:51:18 <mietek> Are there any recommended tutorials for writing web apps in Haskell?
04:51:32 <byorgey> actually Haskell only provides special syntax for the Identity applicative functor
04:51:36 <mietek> Which framework is recommended; Yesod? Snap?
04:51:43 <donri> happstack
04:51:56 <dp_wiz> mietek: start with happstack-lite
04:52:00 <edwardk> snap
04:52:10 <edwardk> but it depends on what you want to do
04:52:16 <ceii> byorgey: one more argument for (|>) :: a -> (a -> b) -> b in the Prelude
04:52:32 <byorgey> ceii: that still wouldn't be special syntax =)
04:52:39 <ceii> right
04:52:59 <byorgey> but I would approve of such an operator in the Prelude.
04:53:23 <Jafet> ceii: also known as (€)
04:53:37 <ceii> aaaaargh not unicode, please!
04:53:48 <Jafet> (flip ($).)
04:53:57 <ceii> lol
04:54:19 <erus`> how do i catch a getModificationTime error ?
04:54:26 <erus`> catch has the wrong sig
04:54:33 <quicksilver> Control.Exception.catch
04:55:40 <erus`> :t catch
04:55:41 <lambdabot> forall a. IO a -> (IOError -> IO a) -> IO a
04:55:49 <erus`> :t getModificationTime
04:55:50 <lambdabot> Not in scope: `getModificationTime'
04:56:31 <ceii> getModificationTime :: FilePath -> IO System.Time.ClockTime
04:56:51 <CarmineM74> Hi everybody! Haskell newbie here, I'd like to ask a question about some code i wrote attempting to pass Project Euler Nr. 11.
04:57:21 <ceii> getModificationTime f `catch` \e -> handle-your-error-here :: IO ClockTime
04:57:28 <rata_> CarmineM74: ask
04:57:39 <CarmineM74> at come point, I wrote: matrixText <- readFile "20x20.log", and reading readFile signature
04:57:46 <CarmineM74> I expected an IO String return value
04:58:04 <CarmineM74> which, from what i understand, could be unwrapped to get the String via "<-" operator
04:58:33 <rata_> CarmineM74: yes
04:58:38 <CarmineM74> Then I defined a function :: String -> [[Int]]
04:58:43 <donri> mietek: I suggest you try the documentation for each of the big three web frameworks as found on their respective websites.
04:58:46 <donri> @where web
04:58:47 <lambdabot> http://happstack.com/ http://snapframework.com/ http://yesodweb.com/
04:58:53 <CarmineM74> which I called passing the result of readFile call.
04:59:19 <CarmineM74> The compiler complained that it was expecting an IO type somewhere in the definition of the aforementioned function.
04:59:41 <CarmineM74> The compail disappeared as soon as I modified the type into :: String -> IO [[Int]] and put
04:59:47 <CarmineM74> a return in the function.
05:00:17 <rata_> CarmineM74: paste it somewhere
05:00:30 <CarmineM74> @rata_: Ok
05:00:30 <lambdabot> Unknown command, try @list
05:00:38 <ceii> @where hpaste
05:00:38 <lambdabot> http://hpaste.org/
05:01:19 <khanzor> CarmineM74: that's exactly right, if you want the value from that String -> [[Int]] back in your monadic computation, it needs to be in the monad. What you probably want to do is use 'let', i.e. let res = f matrixText; return res;
05:02:06 <CarmineM74> The code I pasted at: http://pastie.org/3327618
05:02:43 <ceii> CarmineM74: <- is used to run an IO action
05:03:17 <ceii> if you simply want to give a name to a pure value, use "let matrix = matrixFromText matrixText"
05:03:38 <CarmineM74> khanzor: Thanks for the explanation.
05:03:42 <khanzor> CarmineM74: you can get rid of the return from matrixFromText, and use 'let matrix = matrixFromText matrixText'
05:03:54 <ceii> (or use return to go from a to IO a, but that's kind of redundant)
05:04:16 <erus`> i get a segmentation fault :(
05:04:21 <erus`> this never happens on windows
05:04:30 <ceii> erus`: that's pretty cool
05:04:57 <erus`> haskell is not ready for the desktop
05:05:10 <CarmineM74> ceii and khanzor. Thanks a lot for the explanation!
05:05:11 <erus`> 2012 is not the year of haskel on the desktop
05:05:28 <CarmineM74> I thought that "<-" could have worked the same way as "let x = "
05:05:33 <CarmineM74> in the context of a monad.
05:05:59 <ceii> 2012 is the year of the desktop on the internet
05:06:15 <erus`> maybe its time to learn powershell
05:06:41 <ceii> also, the year in which MPTCs become standard Haskell
05:06:47 <ceii> which is way more important
05:07:50 <osa1> is there a way to see documentation of a function in ghci or do I have to visit haskell web page?
05:07:56 <hpaste> Khanzor pasted “Unsugared” at http://hpaste.org/57533
05:08:13 <khanzor> CarmineM74: see that paste :)
05:08:25 <sopvop> ghc: panic! (the 'impossible' happened) - "impossible", heh. Guess DataKinds not yet working
05:08:27 <ceii> osa1: there isn't, much to everyone's shame
05:08:59 <shachaf> osa1: Fortunately those two aren't mutually exclusive.
05:09:22 <quicksilver> you don't have to visit the haskell website
05:09:26 <khanzor> CarmineM74: not quite, <- is syntactic sugar which really creates a variable for the next function
05:09:29 <quicksilver> you can visit your local copy of the haskell library docs
05:09:35 <quicksilver> which the platform generously supplies you with
05:09:45 <quicksilver> and which the excellent cabal-install updates every time you install a new package.
05:09:47 <CarmineM74> khanzor: Thansk again for your patience! I saw your paste and it makes perfect sense now. :)
05:09:58 <ceii> quicksilver: osa1 (~sinan@78.189.172.153) has left #haskell ("Konversation terminated!")
05:10:08 <khanzor> CarmineM74: well done! took me a lot longer to get my head around this :)
05:10:25 <quicksilver> ceii: nonethless my vital nugget of advice is no doubt appreciated by the hundreds of other people in the channel :)
05:11:00 <ceii> quicksilver, sure, I also hope the #haskell logs are kept forever and easily searchable :)
05:11:37 <johnsingleton> say I have a type like, "Maybe Y" and in the type Y I have another type, [M], accessible by m(). So I can write m Y = [M]. I have a case expression that looks like: case m of Nothing -> return (); Just y -> …, I want to add an expression that matches when Y has an empty list [M] -- can something like that be done?
05:11:37 <johnsingleton> \
05:11:45 <shachaf> Logging is evil.
05:12:00 <shachaf> ceii: Did you use to have a different nick or something, by the way?
05:12:27 <quicksilver> ceii: the haskell logs are indeed kept for ever.
05:12:27 <johnsingleton> I can hpaste if any of that was unclear...
05:12:27 <byorgey> johnsingleton: Just [] ->  ...   ?
05:12:42 <quicksilver> ceii: but the haskell hivemind is probably more powerful.
05:12:59 <johnsingleton> byorgey: But the list in is Maybe Y [M]
05:13:18 <johnsingleton> I think that would work if I had Maybe [Y]
05:13:21 <johnsingleton> ?
05:13:30 <rwbarton> It would.
05:13:32 <byorgey> johnsingleton: what does  Maybe Y [M] mean?
05:13:43 <rwbarton> I think you'd better hpaste whatever it is you're talking about.
05:13:54 <johnsingleton> byorgey: ya, I'll paste ;)
05:13:58 <byorgey> yeah, I think so too, ok =)
05:14:43 <quicksilver> johnsingleton has magically altered the kind of Maybe?
05:14:58 <quicksilver> Maybe :: * -> * -> * -- but only sometimes
05:15:11 <hpaste> johnsingleton pasted “Case this!” at http://hpaste.org/57534
05:15:14 <Saizan> must be kind polymorphism
05:15:36 <johnsingleton> line 28
05:16:15 <johnsingleton> I want to catch the case when Yammers has an empty list of messages
05:16:48 <byorgey> johnsingleton: oh, so   Just (Yammers { messages = [] })
05:17:10 <byorgey> or without record syntax you could do   Just (Yammers [] _)
05:17:16 <johnsingleton> byorgey: doh!
05:17:20 <johnsingleton> that's what I was looking for
05:18:09 <johnsingleton> what exactly happens when you have an expression on the left in the case
05:18:29 <sipa> hmm?
05:18:30 <johnsingleton> like in the example of "Just y" -- m is unwrapped and bound to y
05:18:30 <quicksilver> you can't actually have an expression
05:18:36 <quicksilver> you can only have a pattern
05:18:50 <quicksilver> however patterns do resemble expressions
05:18:52 <quicksilver> but they're limited
05:19:01 <quicksilver> they can only contain constructors and variables
05:19:39 <johnsingleton> ok, so in the example of, above: Just (Yammers [] _) -- say I wanted to USE the empty list on the left -- how could I detect an empty list and (for whatever reason) use it on the right
05:19:40 <johnsingleton> ?
05:20:13 <johnsingleton> does that make sense?
05:20:27 <johnsingleton> I can clarify if I said that weird
05:20:41 <ClaudiusMaximus> johnsingleton: as-patterns, Just (Yammers foo@[] _) = ... foo ...
05:20:42 <Botje> I think you want "Just (Yammers xs@[] _)" ...
05:20:48 <quicksilver> it's a bit weird though
05:20:55 <quicksilver> if you know it's empty why would you need to use it on the right? :)
05:20:58 <Botje> although that doesn't make much sense, indeed
05:21:07 <Botje> either do Just (Yammers xs _) -> case xs of ...
05:21:07 <johnsingleton> ClaudiusMaximus: that's a new one!
05:21:11 <Botje> or do two pattern matches
05:21:20 <Palmik> Jafet, right. The problem was with the greedy behaviour of the "between" I used. It now works mostly as I would expect (except for strong nested in emphasize or vice versa) http://hpaste.org/57535
05:21:21 <johnsingleton> ah, ok, I see
05:21:48 * johnsingleton adds "as-patterns" to required reading list ;)
05:23:25 <Philippa> they're a piece of cake
05:23:26 <dmwit> There's no more reading to do. You just saw everything they can do.
05:23:58 <Philippa> yeah, if p is a pattern then variable@p is one too and variable is bound to whatever p matches. Simple as
05:24:03 <johnsingleton> heh, in essence it just allows you to bind an expression to a variable?
05:24:16 <dmwit> name@pattern binds the additional identifier "name" to the entire value that matches "pattern"
05:24:21 <int-e> if p is a pattern and v a variable then v@p is a pattern that matches the same values as p and binds v to the matched value.
05:24:25 <ClaudiusMaximus> oh, wferi left - just after i wrote up some toy code to add context information to output...
05:24:35 <johnsingleton> ah, but it's only with patters
05:24:39 <johnsingleton> patterns
05:24:42 <johnsingleton> makes sense
05:24:44 <dmwit> johnsingleton: You keep using the word "expression", but that has a technical meaning.
05:25:01 <int-e> to bind variables to expressions use let or where :)
05:25:09 <johnsingleton> dmwit: I am trying to stop ;)
05:25:34 <johnsingleton> (1 + 1) is expression
05:26:19 <johnsingleton> I believe the difference is that expressions evaluate to something. patterns just match or don't match something
05:26:29 <johnsingleton> is that the gist of it?
05:26:32 <int-e> yes
05:27:30 <johnsingleton> okay, coolness. I'll try to keep the imprecision to a minimum ;)
05:28:27 <ClaudiusMaximus> @tell wferi http://hpaste.org/57536
05:28:27 <lambdabot> Consider it noted.
05:33:55 <Peaker> > nubBy (/=) [1,2,3,1,4,2]
05:33:55 <lambdabot>   [1,1]
05:35:19 <rtharper_> @src nubBy
05:35:19 <lambdabot> nubBy eq []             =  []
05:35:19 <lambdabot> nubBy eq (x:xs)         =  x : nubBy eq (filter (\ y -> not (eq x y)) xs)
05:35:30 <rtharper_> ah, there we go then
05:36:00 <Peaker> I want a quick way to find the first duplicate item :)
05:36:10 <Peaker> I think head . nubBy (/=)   should do it
05:36:50 <rtharper_> I suppose, since it nubBy (/=) shoudl get rid of a lot of elements fast
05:37:14 <rtharper_> > nubBy (/=) [2,1,3,4,1]
05:37:14 <lambdabot>   [2]
05:37:21 <rtharper_> there is that problem =p
05:37:38 <rata_> Peaker: group
05:37:45 <rata_> :t Data.List.group
05:37:46 <lambdabot> forall a. (Eq a) => [a] -> [[a]]
05:38:40 <rata_> something like head . filter (not . null . tail) . group
05:38:43 <ksf> has anyone yet tried to abuse the new kind stuff for heterogenous records?
05:38:52 <rata_> > head . filter (not . null . tail) . group $ [2, 1, 3, 4, 1]
05:38:54 <lambdabot>   *Exception: Prelude.head: empty list
05:38:57 <ksf> I somehow feel like it, but I'm intimidated by oleg's legacy.
05:39:00 <rata_> hmmm
05:39:25 <byorgey> rata_: you have to sort first
05:39:28 <ksf> rata_, "drop 1"
05:39:49 <rata_> byorgey: but if you sort, you won't get the first duplicate
05:39:51 <ksf> ...and "take 1"
05:39:52 <byorgey> tail isn't the problem, group always gives you nonempty lists
05:39:59 <byorgey> rata_: but if you don't sort...
05:39:59 <Peaker> rata_: you'd have to sort first
05:40:02 <byorgey> > group [2,1,3,4,1]
05:40:03 <lambdabot>   [[2],[1],[3],[4],[1]]
05:40:10 <ksf> yeah, it barfed on head.
05:40:20 <Peaker> I think nubBy (/=) is nice
05:40:24 <Peaker> (for first dup)
05:40:28 <ksf> nubBy is exponential.
05:40:38 <ksf> ...because it solves the general case.
05:40:40 <byorgey> Peaker: rtharper_ already demonstrated that it doesn't work.
05:40:54 <rtharper_> > nubBy (/=) [2,1,3,4,1]
05:40:55 <lambdabot>   [2]
05:41:12 <dmwit> nubBy surely isn't exponential
05:41:12 <ksf> nubSortBy could be O(n log n)
05:41:24 <ksf> on unsorted lists?
05:41:38 <byorgey> exponential?
05:41:41 <dmwit> Perhaps you meant quadratic?
05:41:51 <ksf> oh, quadratical.
05:41:53 <rtharper_> should be n^2, shoudln't it?
05:41:56 <ksf> still, *slow*.
05:41:58 <byorgey> nubBy has to examine EVERY SUBSET
05:42:03 <byorgey> ;)
05:42:54 <Palmik> Jafet, alright, "fixed" it with one more try combinator. :)
05:42:59 <byorgey> no one has yet actually demonstrated working code to find the first duplicate.
05:43:00 <rtharper_> byorgey: not every subset
05:43:08 <ksf> yep, it can surely be made faster on sorted lists.
05:43:30 <ksf> ...replacing x `elem` ls with x == l
05:43:33 <byorgey> rtharper_: I was joking, as if it were actually exponential
05:43:39 <rtharper_> ...oh
05:43:40 <rtharper_> sorry =p
05:43:45 <byorgey> no worries =)
05:44:16 <ksf> that's quite a price to pay just to preserve ordering.
05:44:18 <dmwit> Oh, wait, is there an outstanding code golf challenge?
05:44:26 <dmwit> I just started paying attention.
05:44:27 <ksf> which, in the common case, is a thing you don't care about.
05:44:46 <byorgey> dmwit: yes.
05:44:59 <byorgey> dmwit: find the first duplicate element in a list.
05:45:08 <byorgey> ideally in O(1) time.
05:45:17 <dmwit> O(1) seems a bit much =P
05:45:19 <byorgey> =)
05:45:23 <ksf> doable.
05:45:26 <ksf> you can fuse it with sort.
05:45:45 <ksf> a mere constant factor, then.
05:45:57 <dmwit> > let isDuplicate (x:xs) = x `elem` xs in head . head . filter isDuplicate . tails $ [1,2,5,3,1,5]
05:45:59 <lambdabot>   1
05:46:07 <ClaudiusMaximus> > let xs = "zomg does this work??1" in xs // (S.toList . S.fromList) xs
05:46:08 <lambdabot>   Couldn't match expected type `GHC.Arr.Array i e'
05:46:09 <lambdabot>         against inferred t...
05:46:16 <ClaudiusMaximus> > let xs = "zomg does this work??1" in xs \\ (S.toList . S.fromList) xs
05:46:18 <lambdabot>   "o s o?"
05:46:37 <rwbarton> > let xs = "zomg does this work??1" in xs \\ nub xs
05:46:38 <Tinned_Tuna> :t S.toList
05:46:38 <lambdabot>   "o s o?"
05:46:38 <lambdabot> forall a. S.Set a -> [a]
05:46:56 <dmwit> Aw, xs \\ nub xs is much more beautiful.
05:46:58 <cmccann> byorgey, I have an O(1) element to find the first duplicate in a list but it doesn't work on all types
05:47:07 <cmccann> er, O(1) algorithm
05:47:10 <ksf> S.fromList is n log n
05:47:15 <byorgey> haha, let me guess, it only works on [()]?
05:47:16 <Tinned_Tuna> cmccann: that was confusing for a minute :-p
05:47:22 <ksf> which is the thing I'm advocating all the time.
05:47:25 <cmccann> byorgey, good guess :D
05:47:38 <ksf> unlike nub, you lose the ordering.
05:49:07 <Peaker> byorgey: oh, thanks
05:49:25 <ClaudiusMaximus> > let xs = ys ++ (0:zs) ; (ys, zs) = splitAt 100 [0..] in listToMaybe (xs \\ nub xs)
05:49:29 <lambdabot>   mueval-core: Time limit exceeded
05:50:02 <cmccann> byorgey, though in some ways there's a meaningful point there, in that the opposite--finding duplicates for a list of any type--is impossible
05:50:46 <dmwit> nub [\x -> 3 + x, \x -> if goldbach_conjecture then 3 + x else 4 + x]
05:51:38 <rata_> > let {f [] = []; f (x:xs) = filter (==x) xs} in head $ filter (not . null . f) (tails [2,1,3,1])
05:51:40 <lambdabot>   [1,3,1]
05:51:49 <rata_> > let {f [] = []; f (x:xs) = filter (==x) xs} in head . head $ filter (not . null . f) (tails [2,1,3,1])
05:51:51 <lambdabot>   1
05:52:06 <rata_> > let {f [] = []; f (x:xs) = filter (==x) xs} in head . head $ filter (not . null . f) (tails [2,3,1,5,3,4])
05:52:08 <lambdabot>   3
05:52:32 <dmwit> isn't not . null . filter (==x) much more cleanly written as elem x?
05:52:32 <rata_> it's a little bit long, there must be something more concise for finding the first duplicate
05:52:47 <rata_> hahahaaha yes
05:52:48 <dmwit> And then it collapses to the solution I posted about eight minutes ago.
05:52:59 <rata_> I missed it
05:53:05 <dmwit> But xs \\ null xs is much more beautiful anyway. =)
05:53:39 <rata_> how does that work?
05:53:48 <dmwit> err
05:53:53 <dmwit> xs \\ nub xs -- of course
05:54:10 <ClaudiusMaximus> > let  xs = ys ++ (0:zs) ; (ys, zs) = splitAt 100 [0..] ; isDuplicate (x:xs) = x `elem` xs in head . head . filter isDuplicate . tails $ xs
05:54:11 <rata_> ok
05:54:12 <lambdabot>   0
05:55:20 <cmccann> on a completely different note, anyone know of interesting work on using full linear logic for the basis of a type system? all I've managed to turn up are models of linear logic embedded in other languages, or stuff using a restricted subset
05:56:26 <dmwit> cmccann: http://dl.acm.org/citation.cfm?id=1708027 maybe?
05:56:37 <dmwit> uh
05:56:49 <dmwit> http://www.cis.upenn.edu/~stevez/papers/MZZ10.pdf to avoid the paywall
05:56:57 <cmccann> was about to ask
05:56:58 <tromp__> > let x="hello, world" in x \\ nub x
05:56:59 <lambdabot>   "lol"
05:57:19 <dmwit> haha
05:57:35 <dmwit> ?remember tromp > let x = "hello, world" in x \\ nub x
05:57:35 <lambdabot> Done.
05:58:03 <tromp__> @pl \x -> x \\ nub x
05:58:03 <lambdabot> (line 1, column 9):
05:58:04 <lambdabot> unexpected "\\"
05:58:04 <lambdabot> expecting variable, "(", operator or end of input
05:58:12 <tromp__> @pt \x -> x \\ nub x
05:58:13 <lambdabot> Maybe you meant: ft pl
05:58:26 <dmwit> ap (flip (\\)) nub
05:58:38 <dmwit> ?pl \x -> x `otherOperator` nub x
05:58:38 <lambdabot> ap otherOperator nub
05:58:44 <dmwit> Aw, no flip.
05:58:58 <dmwit> Yes, I see.
05:59:19 <tromp__> > ap (\\) nub  "hello, world"
05:59:20 <lambdabot>   "lol"
06:00:31 <ClaudiusMaximus> :t let ($\) = error "most annoying operator name?" in ($\)
06:00:32 <lambdabot> forall a. a
06:00:48 <cmccann> dmwit, oh, I've read this already. it was one of the more useful I'd found, so thanks anyway, heh. know of any others?
06:02:10 * dmwit is not an expert, I just happened to attend the same institution as the authors
06:02:40 <cmccann> ah well
06:02:54 <jonkri> facebook doesn't have a "green bar" either. i'm confused
06:02:58 <jonkri> sorry, wrong channel
06:04:08 <cmccann> dmwit, it's a subject where I have the nagging suspicion that there must be more to it than what I'm aware of
06:04:32 <cmccann> and is tangentially relevant to some other stuff I'm doing right now
06:04:43 * cmccann will continue looking
06:08:06 <dmwit> cmccann: I'm not 100% sure what you're looking for, honestly.
06:08:15 <khanzor> if i wanted to build a server for a chat room, what kind of techniques should i look into? is this something that FRP would be well suited?
06:08:28 <dmwit> Surely most of the papers that discuss linear logic include a little language+semantics, right?
06:08:58 <khanzor> s/this something that/this something for which/
06:09:20 <cmccann> dmwit, if I was 100% sure what I'm looking for I'd have found it already :P
06:09:26 <dmwit> Mostly, though, linear logic is meant to be a tool to make some problem easier (or some easy bug harder), so I would expect it to be most useful when embedded in another language.
06:10:00 <dmwit> khanzor: What's wrong with, e.g., IRC?
06:10:33 <Algorith> Does memoization occur for every single function throughout the entire program execution?
06:10:51 <dmwit> cmccann: You might be interested in affine type systems, as well, in case you didn't know that was a thing.
06:10:58 <khanzor> dmwit: nothing, except i'd like to build something myself, as an exercise
06:11:28 <dmwit> Algorith: Memoization is not done at all.
06:11:29 <cmccann> dmwit, probably true, but it's how linear logic works standing on its own that I'm curious about, and embedding tends to lean on the host language here and there
06:11:46 <ksf> Algorith, it occurs for no function, unless you memoize manually.
06:12:01 <ksf> in which case exactly that which you memoize is going to be memoized.
06:13:02 <Algorith> oh k
06:13:20 <cmccann> dmwit, actually I hadn't thought to look for affine logic-based type systems, thanks for mentioning that
06:13:21 <ksf> Algorith, also see http://stackoverflow.com/questions/5032750/how-to-tell-whether-haskell-will-cache-a-result-or-recompute-it/5032920
06:14:08 <ksf> and then there's http://hackage.haskell.org/packages/archive/data-memocombinators/0.4.3/doc/html/Data-MemoCombinators.html
06:15:03 <dmwit> khanzor: If you'd like to learn about FRP, making a chat server seems like a reasonable way to do it.
06:15:21 <quicksilver> "As a top-level definition, primes never gets out of scope, thus the head of the list it points to is never garbage collected"
06:15:26 <quicksilver> I call RUBBISH!
06:15:28 * hackagebot hakyll 3.2.6.0 - A static website compiler library  http://hackage.haskell.org/package/hakyll-3.2.6.0 (JasperVanDerJeugt)
06:15:30 * hackagebot amrun 0.0.0.2 - Interpreter for AM  http://hackage.haskell.org/package/amrun-0.0.0.2 (DanielSeidel)
06:15:31 <Algorith> thanks, I'm reading up on it :)
06:15:40 * quicksilver deducts a quicksilver point from barsoap.
06:15:50 <dmwit> khanzor: You should be able to make quite a beautiful codebase without it, too, if you prefer that.
06:17:12 <dmwit> quicksilver: Presumably he's speaking about GHC. Is that claim inaccurate for GHC?
06:17:54 <dmwit> Oh, I guess it depends on how polymorphic primes is, huh?
06:17:57 <quicksilver> dmwit: Garbage collection happens when you are no longer reachable, this is different from the static, lexical notion of scope.
06:18:18 <dmwit> Yes, okay.
06:18:18 <khanzor> dmwit: I'm a little intimidated by the idea of working out how to handle state shared between multiple calls, and it seemed like (and this is ignorance speaking) that FRP might be a good way to deal with that, but that's just an impression i've formed by hearing vague references to FRP being good for gaming
06:18:24 <quicksilver> dmwit: identifiers can perfectly well be "in scope" for chunks of code and still get GCed, because they are no longer reachable.
06:18:31 <quicksilver> dmwit: I know you know this, but since you asked :)
06:18:40 <ksf> quicksilver, in ghci.
06:18:48 <ksf> ...primes *never* gets out of scope.
06:18:50 <dmwit> Yes, that makes it clearer which part of the sentence you were objecting to. =)
06:18:53 <ksf> ...until you terminate the whole thing.
06:18:59 <quicksilver> the confusion betwee scope/reachability is common in statements about GC.
06:19:02 <dmwit> ksf: Yes, but it's not the scope that's important.
06:19:09 <quicksilver> ksf: yes, in ghci everything remains reachable
06:19:09 <dmwit> ksf: That's what quicksilver is saying.
06:19:20 <quicksilver> FSOV "everything" ;)
06:19:33 <dmwit> khanzor: "multiple calls"?
06:19:35 <quicksilver> everything with a name in scope for ghci is reachable, since you could type it again.
06:20:20 <ksf> quicksilver, "thus the head of the list it points to (and thus its tail/the rest of the computation) is never garbage collected. "
06:20:25 <ksf> that's not *wrong*.
06:20:28 <khanzor> dmwit: well, multiple clients updating some sort of shared state
06:20:39 <ksf> it might leave out some boring detail, yes.
06:20:52 <quicksilver> the "thus" part is wrong.
06:21:05 <quicksilver> it's not never GCed because it's top-level. That's not relevant.
06:21:11 <quicksilver> it's never GCed because it remains reachable.
06:21:30 <ksf> "thus", in natural language, doesn't imply absence of other reasons.
06:21:47 <quicksilver> things which are not top-level may be permanently reachable and thus never GCed; conversely things which are top-level may cease to be reachable and therefore get GCed.
06:21:58 <ksf> but not in ghci.
06:21:58 <quicksilver> surely it implies some connection, ksf?
06:22:15 <quicksilver> not in ghci, no.
06:22:19 <ksf> things on the ghci top-level never get gc'ed (unless you redefine them)
06:22:28 <ClaudiusMaximus> module Main where { import Data.Int(Int32) ; list :: [Int32] ; list = [0..] ; main :: IO () ; main = print (last list) } -- runs in constant space when compiled
06:22:35 <ksf> and anyway that's orthogonal to the issue at hand.
06:22:46 <quicksilver> OK, to be fair, he carries on to say "in compiled programs, there is no top-level scope like in ghci"
06:22:53 <quicksilver> but that's also a strange thing to say.
06:23:01 <quicksilver> there is still a top-level in compiled programs.
06:23:15 <quicksilver> what ghci does is keep the top-level reachable.
06:23:16 <ksf> well I wouldn't have started with the ghci semantics if the op hadn't asked about ghci.
06:23:40 <quicksilver> fair enough.
06:23:43 <quicksilver> (you are barsoap?)
06:23:45 <dmwit> oooo, ksf is barsoap?
06:23:53 <ksf> yep.
06:23:58 * dmwit adds a line to his mental Internet personality graph
06:24:04 <quicksilver> I didn't register that your answer was so specfically ghci slanted
06:24:22 <quicksilver> after all the behaviour in question (memoization of primes) occurs compiled too
06:24:47 <quicksilver> now I re-read your answer I do see that you mention ghci clearly
06:24:50 <quicksilver> (sorry)
06:24:58 <ksf> the question is absolutely ghci-related
06:25:20 <quicksilver> is it?
06:25:25 <quicksilver> he uses ghci to explain what he means
06:25:36 <ksf> "Why does this happen? Is it a GHCI feature or what?"
06:25:42 <quicksilver> but the behaviour of primes being memoized would have occurred in a compiled program.
06:25:48 <ksf> yep.
06:26:04 <ksf> and that's why I explained the ghci toplevel-scope thing.
06:26:21 <quicksilver> yes, and my answer to that sub-question would have been "No, it's not GHCI-specific, although GHCI does keep all these things reachable....
06:27:04 <ksf> well, CAFs exist in both compiled code and ghci.
06:27:34 <Peaker> I thought CAFs were not the same as top-level definitions?
06:27:36 <ksf> and CAFs is what the answer is actually about, all that ghci stuff is to unconfuse some details.
06:27:43 <ksf> nope.
06:27:55 <ksf> "Any super combinator which is not a lambda abstraction."
06:28:38 <Peaker> oh you meant GC reachable by ghci there?
06:28:57 <ksf> yep.
06:29:14 <ksf> http://stackoverflow.com/questions/5032750/how-to-tell-whether-haskell-will-cache-a-result-or-recompute-it/5032920
06:29:21 <ksf> the CAF in question is at the top level
06:29:32 <quicksilver> ksf: OK, so my real beef is in this part "never gets out of scope" .... "is never garbage collected"
06:29:35 <quicksilver> ksf: it's not about scope.
06:29:40 <quicksilver> it's about reachability.
06:29:46 <quicksilver> leaving ghci to the side.
06:30:22 <ksf> s/gets out of scope/becomes unreachable/?
06:32:19 <quicksilver> ksf: yes.
06:32:36 <ksf> http://stackoverflow.com/posts/5032920/revisions
06:32:37 <ksf> better?
06:33:08 <quicksilver> I think you intended s/exists/exits/ in the green text ?
06:33:13 <quicksilver> but yes, for me that is much better.
06:33:24 <quicksilver> you might consult dmwit for a second opinion :)
06:33:46 <ksf> oops
06:34:10 <ksf> all hail stackexchange, it didn't make a new revision just for a single character change.
06:34:49 * quicksilver hails stackexchange as required.
06:35:41 <ksf> ...and I fixed that ghastly conditional.
06:35:52 * quicksilver finds stackexchange's combo of QnA/forum/persistent wiki quite curious but has to admit it appears to be working very well in some cases.
06:36:28 <quicksilver> one of the weakest things about google as a knowledge base is it frequently brings up blog posts (for example) which are extremely *relevant* and were correct when written, but are now three years out of date.
06:36:29 <ksf> ...not using "would" twice in conditionals just doesn't make sense to germans.
06:36:48 <quicksilver> stackexchange with its updatability might mitigate this.
06:37:23 <quicksilver> although I don't know if the community has a convention on when you make a clean break and just annotate a question as "this question made sense in 2006 but in 2012 it's just the wrong question - please see X"
06:37:44 <rwbarton> what's really annoying is how often blog engines make it difficult-to-impossible to find out when a post was written
06:38:12 <rwbarton> or sometimes you get the month and day but not the year, that's real helpful!
06:39:30 <ksf> or you get clearly nonsensical dates like 25/01/11
06:39:50 <ksf> er no, that makes sense.
06:39:59 <ksf> 01/25/11 doesn't.
06:40:12 <Botje> blame the murricans
06:40:17 <mekeor> how can i do "map (**2) [1..100]" parallel ?  (i mean, in multiple processor-cores or so.) (just a general question refering to parallel programming in haskell. i just wanna get the general concept of haskell for those thing...)
06:40:52 <Saizan> i'd look at the parallel package
06:40:52 <ksf> http://hackage.haskell.org/packages/archive/parallel/2.2.0.1/doc/html/Control-Parallel-Strategies.html
06:41:15 <dmwit> Or use data-parallel Haskell.
06:41:20 <cmccann> quicksilver, questions that will obviously be out of date in the very near future are considered to not belong on SO to begin with, and on more reasonable time frames I think it'd be acceptable to either leave a comment or post an answer (if an up-to-date solution is known)
06:41:22 <mekeor> so, its not that trivial, right?
06:41:28 <Philippa> wow, not copying from a logical spec lets me write some really fun lines in a typechecker these days
06:41:28 <rwbarton> It is that trivial
06:41:32 <ksf> > parMap rpar (**2) [1..100]
06:41:33 <lambdabot>   [1.0,4.0,9.0,16.0,25.0,36.0,49.0,64.0,81.0,100.0,121.0,144.0,169.0,196.0,22...
06:41:42 <Philippa> check (Lam i ty b) = Fun ty <$> local (addBinding i ty) (check b)
06:41:56 <mekeor> ksf: oO -- that's parallel ?  nice! cool =)
06:42:11 <Philippa> how does SO sort the answers you see? Score, then date?
06:42:18 <rwbarton> score, then random
06:42:24 <dmwit> accepted first
06:42:26 <cmccann> yeah
06:42:45 <cmccann> not sorting by date was an intentional design decision if memory serves me
06:42:54 <cmccann> to discourage thinking of answers as a discussion thread
06:42:58 <ksf> the rpar is overkill, though.
06:43:39 <rwbarton> also to reduce the incentive to be the first answerer (the answer on top is more likely to get upvoted)
06:44:15 <ksf> rwbarton, eat my "enlightened" badge.
06:44:29 <cmccann> nah, they gave up worrying about the quick-draw syndrome last I checked
06:44:45 <ksf> two of them, even.
06:44:51 <ksf> 'First to answer and accepted with at least 10 upvotes. This badge can be awarded multiple times. '
06:45:12 <cmccann> if the question is easy enough that multiple people can answer it well enough to get upvoted within minutes, then they can just deal
06:45:29 * hackagebot vcsgui 0.0.1 - GUI library for source code management systems  http://hackage.haskell.org/package/vcsgui-0.0.1 (StephanFortelny)
06:45:50 <cmccann> ksf, I have 42 "enlightened" badges :P
06:46:12 <Philippa> would it be worthwhile if I spent time mucking about on SO, then?
06:46:14 <ksf> nerd.
06:46:17 <Philippa> mostly I've been avoiding it
06:46:28 <cmccann> Philippa, depends on what you expect to get out of it
06:46:28 <dylukes> That moment when you realize applicative notation makes sense.
06:46:40 <dylukes> Like, when you realize you're somewhat comfortable with it.
06:46:51 <dylukes> Very satisfying.
06:47:06 <cmccann> ksf, also 119 "nice answer" badges and a bronze tag badge for "monads", haha
06:47:09 <Philippa> (I seem to have a somewhat 'nonstandard' conceptual framework, which probably has value for me to write up more but also makes things harder work)
06:47:30 <Philippa> dylukes: that's not actually what I like about the checker line, but sure
06:47:36 <dylukes> what?
06:47:36 <quicksilver> cmccann: I was thinking of questions like "How do I avoid this problem in GHC" which turns out to be an entirely 6.12-specific problem (although this wasn't clear to the asker, perhaps)
06:47:46 <Philippa> do you have any idea how many times I've written that out in do notation instead?
06:47:53 <Philippa> (or close variations thereof)
06:48:03 <dylukes> Written what out?
06:48:11 <dylukes> I was non sequitur'ing
06:48:17 <quicksilver> cmccann: then 4 years later another problem manifests in GHC 9.8 which appears symptomatically similar (same or similar error message) but is in fact a totally different issue.
06:48:22 <dylukes> In case I accidentally responded to something someone said before.
06:48:27 <Philippa> ah, I pasted this a screen or two above: check (Lam i ty b) = Fun ty <$> local (addBinding i ty) (check b)
06:48:27 <quicksilver> cmccann: I hit things like that with google searches all the time.
06:48:59 <cmccann> quicksilver, ah, well if nothing else SO displays the post date prominently :P
06:49:09 * quicksilver nods
06:49:17 <rwbarton> Philippa: from browsing through it briefly, I think you would find http://cstheory.stackexchange.com more interesting
06:49:20 <cmccann> but yeah it'd surely be acceptable to edit/comment/&c. to indicate
06:49:58 <dylukes> Philippa: I was just commenting in reaction to the parsers I'm writing again.
06:50:07 <cmccann> anything that improves the useful content of the site without unduly interfering with other users is probably fine
06:50:11 <dylukes> I find myself perfectly comfortable with <*>, <*, *>, <$, <$>, <|>, etc
06:50:19 <dylukes> (<**> too!)
06:50:22 <dylukes> Like, they don't feel weird anymore.
06:50:23 <Philippa> rwbarton: looks like a potentially fun source of info, less sure it's somewhere I'd want to post a lot
06:50:31 <dmwit> dylukes: Start using idiom brackets, then.
06:50:41 <Philippa> dylukes: cool. I don't actually like them (mostly) for parsers though, I prefer a pointed notation
06:50:53 <dylukes> Idiom brackets?
06:51:01 <dylukes> Philippa: some parsers require do notation, others are ugly in it.
06:51:21 <dylukes> in do notation*
06:51:22 <dylukes> decl :: MonadParser m => m Decl
06:51:22 <dylukes> decl = Decl <$> var <* symbol "=" <*> obj
06:51:26 <dylukes> I think this looks good in applicative form.
06:51:46 <dmwit> https://personal.cis.strath.ac.uk/~conor/pub/she/idiom.html
06:51:50 <cmccann> dylukes, idiom brackets are where you consume a mixture of alcohol and Conor McBride papers until your vision gets blurry enough that you can't actually see the Applicative operators anymore
06:51:56 <Philippa> yeah, but it'd look pretty good as a monad comprehension too
06:52:08 <mux> I want bananas and barbed wire operators
06:52:15 <ksf> and people do browse and upvote old answers.
06:52:23 <dylukes> @quote cmccann Idiom brackets are where you consume a mixture of alcohol and Conor McBride papers until your vision gets blurry enough that you can't actually see the Applicative operators anymore.
06:52:24 <lambdabot> No quotes match. Maybe you made a typo?
06:52:30 <dylukes> @remember cmccann Idiom brackets are where you consume a mixture of alcohol and Conor McBride papers until your vision gets blurry enough that you can't actually see the Applicative operators anymore.
06:52:31 <lambdabot> It is forever etched in my memory.
06:52:56 <cmccann> ksf, yes, I get 4 or 5 upvotes on old answers most weeks
06:53:07 <Philippa> if I had idiom brackets in GHC I'd certainly be a lot less grouchy about the need to use join when you're putting something monadic at the start
06:53:22 <Philippa> but I'm not at a stage where I want to play with she yet
06:54:02 <Philippa> does SO have a good way of handling situations where one or more people have standard concepts they use in answers but don't want to have to repeat constantly?
06:54:16 <quicksilver> dylukes: what I don't like about that, is that it requires understanding of the relative precedences (or fixities) of those operators.
06:54:30 <cmccann> Philippa, hyperlinks? :P
06:54:31 <dylukes> quicksilver: right, but once you do understand them,
06:54:32 <dylukes> it's easy.
06:54:48 <quicksilver> short of BODMAS-like rules, I think it's hard to remember relative precedence and best to avoid binary operator expressions which rely on correct precedence to comprehend.
06:54:52 <Philippa> cmccann: yeah, but to something on-site or my own space?
06:54:53 <dylukes> It's not obvious for a newcomer, yes, but to someone else who "speaks the language" it's much more succinct.
06:54:55 <dylukes> Like anything.
06:55:19 * cmccann thinks all Applicative-y operators ought to simply have the same fixity
06:55:45 <Philippa> quicksilver: I think Applicative's a case where it's better to learn the normal form first and hash out the fixity when you first have to implement one yourself (at which point you'll trip up a few times)
06:55:59 <cmccann> and then one step lower precedence for stuff like (<|>)
06:56:16 <cmccann> that gives you the usual multiplication-before-addition behavior
06:56:45 <quicksilver> cmccann: that sounds sane to me, but it ought to be prominently written down and adhered to and explained :)
06:56:46 <dylukes> g2g
06:56:49 <Philippa> cmccann: I've a feeling it's necessary for <$> and <*> to have different fixity if you want the normal form to parse without brackets?
06:57:00 <Philippa> (which I sure as hell do)
06:57:10 <cmccann> they have the same fixity now
06:57:26 <cmccann> would you rather change that?
06:57:36 <Philippa> huh, so they do. Fair enough
06:58:15 <Philippa> I do find myself wanting a variant of <*> that calls pure on the RHS, can't remember what if anything borks that
06:58:44 <cmccann> what doesn't match is (=<<), I sometimes give it a synonym (=<$) that's also infixl 4
06:59:29 <Philippa> yeah, that'd be nice to have standardised
06:59:42 <Philippa> really, anything that encourages more use of the applicative subset of monads is good
06:59:45 <ksf> Philippa, <*
06:59:54 <ksf> or, wait, that's not what you mean.
07:00:06 * cmccann also uses (=<*) for (<*>) with a join at the end
07:00:09 <ksf> <*>> I'd say.
07:00:28 <ksf> ...and <<*>
07:00:28 <Philippa> yeah. I'm thinking stick a euro sign in the middle instead of a dollar because the other side's what's pure
07:00:31 <cmccann> for Applicative-y expressions that start with (a -> b -> m c) style functions
07:00:49 <cmccann> ksf, (<<*>) would be  (<$>) wouldn't it?
07:01:03 <ksf> yep
07:01:07 <ksf> symmetry, though.
07:01:27 <Philippa> cmccann: I'd rather stick the join at the front if that's happening
07:02:01 <ksf> you can, btw, just use "pure".
07:02:04 <cmccann> Philippa, sometimes it's tidier to do it inline, but it can also obscure the order of effects when that matters a lot
07:02:56 <Philippa> ksf: sure, but it makes it harder to filter out "what's being applied in the DSL?" before checking the properties of individual parameters when you read it
07:03:25 <kallisti> what's a good library for controlling the behavior of a web browser, or emulating a web browser (giving Haskell access to the DOM or an API to do things like click links etc).
07:03:40 <kallisti> does such a thing exist?
07:03:56 <rostayob> kallisti: you mean like selenium?
07:04:17 <kallisti> yes that's one I've considered.
07:04:29 <kallisti> but is there a better alternative. The Selenium bindings for Haskell don't look so great.
07:04:35 <rostayob> anyways, I doubt something like that exists. afaik selenium actually runs a browser and clicks stuff
07:04:49 <kallisti> yes it does.
07:04:56 <cmccann> it's not a trivial problem
07:05:10 <cmccann> you either have to hook into an existing browser, which is going to be awkward at best
07:05:16 <kallisti> or implement your own
07:05:20 <kallisti> without a GUI
07:05:22 <rostayob> kallisti: which is a PITA.
07:05:24 <cmccann> or you have to write most of a browser yourself
07:05:55 <quicksilver> selenium is, as far as I know, the only solution which actually runs the javascripts.
07:06:23 <quicksilver> for simply parsing HTML and fetching further links, of course, there are spider-type libraries for many many languages.
07:06:25 <rostayob> because again, it runs the actual browser, I think it's firefox
07:06:37 <quicksilver> selenium can use firefox, IE, safari
07:06:40 <quicksilver> possibly opera
07:06:51 <ClaudiusMaximus> compile haskell to javascript, use as firefox plugin ? (random idea...)
07:07:08 <cmccann> ClaudiusMaximus, I would not be surprised if that was not the easiest solution
07:07:14 <cmccann> and was about to suggest it myself, heh
07:07:17 <rostayob> quicksilver: oh, that's interesting
07:07:24 <cmccann> er, if it was the easiest
07:07:30 <cmccann> ugh too many negatives there
07:07:36 <rostayob> is there even an usable Haskell to JS compiler out there?
07:07:37 <quicksilver> it's like a magic trick, rostayob, it's really disappointing when you learn how it's done
07:07:50 <quicksilver> it doesn't hook into the browser at all
07:07:58 <quicksilver> it runs as a man-in-the-middle proxy and injects javascript.
07:08:18 <quicksilver> haskell -> JS: several exist, yes.
07:08:26 <quicksilver> ghcjs is the most recently updated I think
07:13:00 <mekeor> ksf: is it normal that "parMap rpar" isn't executed on multiple cores?
07:13:10 <Philippa> dammit, I want to do something cute that I think do notation's going to make fuglier than necessary
07:13:40 <Philippa> that is: I want to exploit fail on pattern match failure, and immediately catch (or rather, chuck it through an operator that adds an error message)
07:13:51 <ClaudiusMaximus> mekeor: compile with -threaded and use +RTS -N at runtime?
07:14:14 <mekeor> ClaudiusMaximus: like "./myprog +RTS -N" ?
07:14:23 <ClaudiusMaximus> mekeor: yeah
07:14:26 <quicksilver> Philippa: I reckon you could add the error message first
07:14:33 <quicksilver> which would be ignored if it doesn't fail
07:14:53 <quicksilver> Just y <- magic_stuff <?> "magic stuff was unJust!!!"
07:15:12 <quicksilver> ...given a suitable monad which had place to stuff error messages
07:15:36 <mekeor> ClaudiusMaximus: works!! thanks =)
07:16:01 <Philippa> quicksilver: yeah, that's hard work :-( I might just use the extra do
07:16:08 <quicksilver> :)
07:16:42 <Philippa> that, and strictly speaking I'm going to end up with two things that look like error messages anyway
07:16:48 <Philippa> <!> for errors, <?> for locations
07:17:09 <Philippa> (this is all pedagogical, I imagine several people here'll get a kick out of the blog post when it's done)
07:18:10 <rostayob> quicksilver: I knew it was pretty hacky, I never wanted to know the details ehehe
07:18:17 <cmccann> hm, I wonder if annotation-in-case-of-failure would be a plausible use for my hybrid error/writer monad
07:18:21 <rostayob> quicksilver: I said usable Haskell -> JS
07:18:30 <quicksilver> rostayob: relative term
07:18:47 <quicksilver> I'm sure ghcjs can be made usable if someone actually cares enough to want it to work
07:18:51 <quicksilver> apparently, no one does
07:19:10 <rostayob> quicksilver: ghcjs goes from Core to JS right?
07:20:03 <quicksilver> I know no more about it than can be be determined from the github page and the mailing list posts made about it :)
07:21:28 <rostayob> ahah, I was looking at the ghcjs repo, and guess what chrisdone is doing?
07:21:40 <rostayob> kallisti: https://github.com/chrisdone/ji , "Library for controlling the web browser from Haskell."
07:21:43 <Philippa> cmccann: I have use cases for writer/error/writer, even :-)
07:25:30 * hackagebot pandoc 1.9.0.3 - Conversion between markup formats  http://hackage.haskell.org/package/pandoc-1.9.0.3 (JohnMacFarlane)
07:25:45 <cmccann> Philippa, I don't mean a transformer stack, I've trying to think of a use for a single monad that's a hybrid error/writer
07:26:07 <cmccann> i.e. a data type that's either-or-both
07:28:14 <Philippa> cmccann: how would that differ from the stack? (or at least /a/ stack)?
07:28:26 <Philippa> RWS works because the three constituent transformers commute
07:28:31 <mux> heh, I have needed a OneOrBoth type once in the past
07:28:35 <mux> it made the code a lot clearer
07:29:17 <mux> http://code.mumux.org/automata/src/120d63e6991e/Data/Automaton/Class.hs -- there it is, on line 27
07:29:18 <cmccann> Philippa, well, it's a different type, since either-or-both doesn't factor neatly into simple sums and products
07:29:31 <mux> yeah, it's a mess if you try to define it using Either and/or Maybe
07:29:45 <cmccann> mux, here's mine: https://github.com/isomorphism/these
07:30:34 <mux> whoa, you've added tons of utility functions around it that I didn't need
07:30:43 <mux> and various instances
07:30:50 <cmccann> Philippa, but the main difference is that the value in the writer component is also the error value
07:31:05 <mux> the instances are rather comical to read, with all the This/That/These
07:31:35 <Philippa> aaah. So sort of equivalent to taking Error and wrapping it in such a way as to force an error logging discipline?
07:31:36 <cmccann> mux, that may have something to do with why those constructor names were chosen :]
07:31:55 <kallisti> rostayob: hmm, well it certainly looks a bit better than the Selenium bindings. I wonder how it compares in terms of performance/features.
07:32:07 <Philippa> (hrmm, not entirely if you want to log stuff that's caught completely)
07:32:18 <cmccann> Philippa, I don't know, that's why I'm wondering. my first thought was logging minor errors or aborting on major ones, keeping everything you've logged
07:32:52 <cmccann> Philippa, and then using a combination of catch/censor to handle failed computations and optionally keep their logged value
07:32:53 <Philippa> eh, let me rephrase: can I build this by wrapping an ErrorT WriterT stack? (that is: log persists across throws)
07:33:24 <mkscrg> cabal question: i have a number of executables with the same ghc-options and the same build-depends. is there a way to specify those globally?
07:34:04 <dcoutts> mkscrg: no, not unless your package also has a lib (at some stage the plan is to allow private libs to help in this case)
07:34:15 <Philippa> cmccann: alternatively, what would an interpreter implementation look like? :-)
07:34:26 <cmccann> Philippa, building the exact same type doesn't work well with other transformers
07:34:33 <kallisti> rostayob: actually this library doesn't look complete just yet. :/
07:34:45 <cmccann> because (A + B + A*B) doesn't factor cleanly
07:35:08 <rostayob> kallisti: ok, it was worth a try :)
07:35:12 <cmccann> Philippa, here's the monad transformer in question btw: https://github.com/isomorphism/these/blob/master/Control/Monad/Trans/Chronicle.hs
07:36:01 <mkscrg> dcoutts: OK, say it has a lib. do the build-depends and ghc-options for the lib carry over to the executables?
07:36:14 <kallisti> rostayob: in the future when it matures I'll likely switch over to it.
07:37:18 <cmccann> Philippa, given that it's hard to create an equivalent type using existing monad transformers it seems to me that there should be some distinctive use case for this monad that can't be replicated easily otherwise
07:37:24 <cmccann> but I'm not sure what it would be
07:37:29 <Philippa> cmccann: I have to admit I'm finding the terminology shift (seemingly) needlessly confusing but hey
07:37:37 <Philippa> I'm still not seeing what's hard so long as you're willing to wrap a bit
07:38:09 <Philippa> (seems to me the obvious use case is enabling debugging?)
07:38:19 <dcoutts> mkscrg: no, but you can have an exe depend on the lib in the same package
07:38:41 <mkscrg> dcoutts: ah, i follow. thanks
07:39:53 <Philippa> cmccann: am I missing something about how the monad (transformer) behaves, or do we just have very different attitudes about using transformers?
07:40:21 <cmccann> Philippa, not sure what you mean
07:41:16 <cmccann> you can't replicate that exactly using reader and error monads with the same type for the second value, you'd need a maybe in the writer or something and then have to recombine stuff appropriately
07:41:30 <Philippa> what's "that"?
07:41:49 <Philippa> yes, I'm expecting to have to transform the monoid in the writer
07:41:51 <cmccann> the monad transformer data type itself
07:42:01 <Philippa> external or internal view?
07:42:12 <cmccann> it's not a straightforward composition of other transformers, that's all
07:42:24 <Philippa> oh, right. Yeah, not arguing with that but I also don't see that as a big issue
07:42:47 <Philippa> I do a lot of stuff that's not a straightforward/trivial composition to get the semantics I want
07:43:46 <cmccann> Philippa, what I'm wondering about is what semantics would be natural for this case because it's a very simple data type that can't be built directly from other transformers
07:45:44 <Philippa> cmccann: I don't think the indirection's going to be all that heavy, have a go at it?
07:46:19 <Philippa> you're basically combining a couple of operations and wrapping the writer monoid, no?
07:46:20 <cmccann> I think you can fake State using Reader and a Writer of state value transformations, but the direct implementation makes some natural semantics clear that wouldn't be if you jumped through all the hoops to build it
07:46:41 <Philippa> yeah, I don't think this is that though?
07:47:28 <cmccann> imitating this would be about as awkward as imitating state that way, I think
07:47:45 <Philippa> partly because the transformers do different things - one threads a monoid alongside the return value one, the other provides control flow
07:47:47 <cmccann> and I don't know why you'd want to do either instead of having the desired semantics expressed directly
07:48:14 <Philippa> the transformer version might well end up as higher level code
07:48:20 <Philippa> have a go at it, if you're wondering?
07:48:27 <cmccann> but the control flow also uses the monoid value, they're not entirely separate
07:48:40 <Philippa> it modifies it rather than using it, no?
07:48:57 <Philippa> it's just a wrapped control operator that tweaks the other component a bit
07:49:22 <cmccann> I'm not really sure what you're getting at to be honest
07:49:59 <Philippa> I suspect it'll only be clear if one of us implements it in terms of transformers. I've got some other stuff I'm trying to work on unfortunately - if you get one working I'd be willing to golf it a bit for clarity though
07:50:24 <cmccann> I really don't see much point
07:50:51 <Philippa> It might reveal some of the structure you're wondering about
07:51:19 <Philippa> (the Reader/Writer example is bad because /Reader and Writer are defineable as wrappers of State/)
07:52:15 <cmccann> implementing state in terms of writer works differently than writer in terms of state, though
07:52:40 <Philippa> certainly. But it's a strong hint that you're going to get additional, incidental complexity
07:54:04 <cmccann> likewise with this monad you can ignore part of it to get error or writer back, but building it in terms of them requires extra plumbing
07:54:11 <cmccann> it seems like a pretty close comparison
07:54:34 <Philippa> we haven't built it in those terms: we haven't seen what extra plumbing there is
07:54:39 <Philippa> I suspect it's rather less
07:55:07 <cmccann> er, both cases seem pretty straightforward to me
07:55:13 <Philippa> I wouldn't be surprised if it's to the point where the code's readily transformable into something close to yours, in fact
07:55:23 <dainanaki> I'm trying to figure out some way to restrict some free type variable 'a' to be constrained to only non-IO types. Is there some way to do something along these lines?
07:55:28 <rhyceU> though not strictly haskell related, I'm running into a problem with haskell-mode and flymake -- whenever I turn flymake on I get an error about a null string -- the issue is described here, https://github.com/pheaver/haskell-mode/issues/4 - but the suggested fix doesn't seem to solve my problem
07:55:41 <rhyceU> has anyone experienced this?
07:55:58 <cmccann> dainanaki, not really, and if you need to do that you're probably chasing the wrong solution. why do you want to do that?
07:56:48 <dainanaki> cmccann, idle curiousity.
07:57:09 <Philippa> cmccann: anyway, right now this discussion is clearly wanking without someone implementing it. I have to say that *I would go to the transformers first* myself, because it leaves me less room to screw up - it seems to me that it's a genuinely higher-level description of the same thing. That's what I meant about a difference of attitude earlier. But we're not going to know until someone bothers
07:57:09 <Philippa> - and you won't know if it leads to your 'natural semantics'
07:57:34 <cmccann> dainanaki, keep in mind that (IO a) values are still values, you can pass them around in pure code as opaque chunks
07:58:04 <cmccann> there's nothing impure about something of type (IO a) except insofar as you use it to define the value of "main"
07:58:17 <dainanaki> right, that's what I thought.
07:58:27 <dainanaki> Just curious.
07:59:07 <cmccann> Philippa, I'd avoid the transformers for exactly the same reason because this can't be expressed directly as the composition of existing transformers.
07:59:24 <Philippa> and I can't see the value of that criterion
07:59:31 <cmccann> implementing it manually leaves more room to screw up because it's not inherent to the type
07:59:48 <Philippa> right, why do you want more room to screw up?
08:00:02 <cmccann> manually as in kludging together transformers
08:00:11 <cmccann> rather than defining the actual monad I want and being done with it
08:00:16 <Philippa> whatever else it is, it's not kludging
08:00:44 <Philippa> your argument seems to amount to "non-trivial composition of abstractions is bad, mmm'kay?" - can you distinguish it from that?
08:00:57 <cmccann> as far as I can tell implementing the same monad transformer using reader and error would be more complicated and more error-prone
08:01:09 <cmccann> Philippa, because it's not composing existing abstractions
08:01:12 <Philippa> I see fewer "moving parts" to screw up
08:01:16 <Philippa> it most certainly is
08:01:27 <cmccann> it's using other abstractions that mean different things, and implementing something else on top of them
08:01:38 <cmccann> ok, I really don't know what you're getting at and this is pointless
08:01:59 <Philippa> "mean different things" - I don't see where this comes from
08:02:13 <Philippa> or at least, how it's both true and usefully falsifiable
08:02:40 <Philippa> what stops me from using your argument to prevent any use of abstractions that isn't a sequence of runFoo calls?
08:02:50 <cmccann> the abstraction of the monad transformer in question is not a combination of the abstractions offered by reader and error
08:03:07 <Philippa> I disagree. It appears that I disagree with your definition of combination
08:03:25 <cmccann> it's an interdependent mixture of the two, which is exactly what separate abstractions avoid
08:03:28 <Philippa> if you added the word trivial before it, I would agree: I wouldn't see the value of that judgement as stated though
08:04:00 <Philippa> it's two things wired together. That's not inappropriate, nor is it inherently a kludge
08:04:17 <Philippa> you are still most certainly using the control flow provided by error and the data flow provided by writer
08:04:48 <cmccann> it's wiring together the internals of the two, not wiring together computations using them
08:04:52 <Philippa> I would even describe the functionality in terms of the concepts I use to describe error and writer-used-for-logging
08:05:07 <Philippa> ! No, it doesn't touch their internals. At no point do I need to look inside the transformer
08:05:11 <cmccann> yes you do
08:05:18 <Philippa> no, I don't. I plan on wrapping them
08:05:39 <Philippa> unless I've missed something /really major/ that should be perfectly viable. What have I missed?
08:05:57 <cmccann> what transformer stack do you intend to use?
08:06:01 <Philippa> (hint: when I talk about transforming the monoid going through Writer, that's another wrapper)
08:06:37 <Philippa> ErrorT on top of Writer(T) - so Error's fundamental control flow doesn't disrupt the data flow
08:06:45 <Philippa> (I intend to do that when I want to using censor)
08:08:50 <cmccann> well, for one thing that doesn't distinguish the right-only case
08:09:13 <cmccann> though I'll grant that I'm not sure when distinguishing that from a writer value of mempty would be useful
08:09:30 <cmccann> but it still fails to represent the same thing exactly
08:09:45 <Philippa> me either. But for the sake of argument: wrap the polymorphic thing in the right with something that tells you when to ignore the left
08:10:31 * hackagebot cityhash 0.3.0.0 - Bindings to CityHash  http://hackage.haskell.org/package/cityhash-0.3.0.0 (AustinSeipp)
08:10:56 <Philippa> oh, wait, right-only - the success, no log case, right? Yes, that really really should be equivalent to an mempty log
08:11:12 <cmccann> for the logging semantics, yes
08:11:35 <cmccann> but it's still distinguishable and could potentially be significant for other semantics
08:12:09 <Philippa> well, let me know if you find one? I suspect a proof that it shouldn't be can be had
08:12:43 <Philippa> I'm certainly happy that it captures the one use case and the informal semantics that I had in mind, obviously YMMV
08:13:23 <cmccann> the "no log" case carries only that one bit of information, obviously, and could be handled by putting the log type in Maybe
08:13:46 <cmccann> with an appropriate monoid instance to combine the result of any errors
08:14:08 <Philippa> yeah. And you're starting to get more structure to throw the maths at again, no?
08:14:39 <Philippa> you can see why I consider this a higher-level description, even if we still disagree?
08:15:03 <cmccann> no, it still sounds lower-level to me to be honest
08:15:17 <cmccann> and more error-prone
08:15:17 <Philippa> the "moving parts" all have analysable properties now
08:15:50 <cmccann> I don't see this as having fewer or more analyzable moving parts than the direct implementation, really
08:16:25 <Philippa> you've got a lot more mathematical properties 'for free', simply because most of the time you're not dealing with raw functions
08:16:30 <cmccann> all the writer and error transformers give you are things that are inevitable to the type anyway
08:16:41 <rhyceU> does anyone here use aquamacs?
08:17:17 <Philippa> cmccann: all the better reason to connect that meaning to potential problem domains!
08:18:16 <cmccann> e.g. when combining error and writer you have to make sure to add errors to the accumulated log
08:18:17 <Philippa> if I'm going for the "ignore the right-only case" semantics, I've got a strictly problem-domain description of the semantics that's matched by the code. That's exactly what I mean by higher-level
08:18:36 <cmccann> whereas implementing it directly makes the necessity of that clear from pattern matching
08:18:41 <Philippa> well yes, that's exactly what your wrapped error functions are going to be there for
08:19:06 <cmccann> yes, in any case it can all be wrapped up in a small module, that's obvious
08:19:17 <cmccann> code merely using the monad needn't know the difference at all
08:19:50 <cmccann> but manual plumbing between transformers strikes me as a more error-prone internal implementation than letting case analysis show what's where
08:20:24 <Philippa> if we were working with a solid proof assistant, I might be convinced
08:20:50 <Philippa> IME, case analysis in Haskell is worryingly fragile: the wrapped error call approach doesn't have to do any
08:21:53 <Philippa> I'm also inclined to the view that pattern matching is getting on for as low-level in Haskell code as general recursion is unless dictated by the problem domain
08:22:08 <Philippa> (so, y'know, if you're writing a typechecker you're stuck with it and fair enough...)
08:22:40 * cmccann shrugs
08:22:43 <cmccann> matter of taste I suppose
08:23:20 <cmccann> but using error and writer to implement it still feels hackish and opaque to me
08:23:28 <Philippa> yeah. I'm willing to call it a day there: I'm far more interested in establishing that I have a viable position than that I have the One True Way
08:23:52 <mekeor> @pl \x -> "foo"++x
08:23:53 <lambdabot> ("foo" ++)
08:23:57 <Philippa> *nod*. What I will say is that it's a very "mechanical" approach - it's almost "OO monad design"
08:23:59 <mekeor> oops hehe
08:24:26 <cmccann> Philippa, for what it's worth I'm pretty dubious about monad transformers in general
08:24:26 <Philippa> I can understand that being very offputting to a significant proportion of Haskellers :-)
08:24:38 <Philippa> yeah, that would definitely make the difference
08:24:44 <cmccann> they're not compositional or well-behaved in full generality
08:25:06 <cmccann> unlike say functor composition of Applicative instances
08:25:24 <Philippa> yeah. I'd like to have some better-understood classes of transformer that are, but I've got a couple of notions I'm basically happy with for now
08:25:24 <cmccann> or certain combinations of monad transformers
08:25:37 <Eduard_Munteanu> I wonder what'd help there. Some notion of subtyping?
08:25:52 <cmccann> i.e. if your entire stack commutes with each other you're obviously fine
08:26:04 <Philippa> I've forgotten the keywords for the research thread I thought looked good on that front - the interesting bits seem to be about control flow rather than data flow
08:26:07 <cmccann> on the other hand a layering of ErrorT and StateT with a ContT in the middle is sheer madness
08:26:38 <Philippa> no argument there! I'd go so far as to say you should almost never leave ContT 'raw'
08:26:40 <cmccann> Eduard_Munteanu, with that, composing monad transformers?
08:27:01 <cmccann> ErrorT is almost as bad as ContT in some ways
08:27:03 <Eduard_Munteanu> cmccann: rather composing different stacks
08:27:04 <Philippa> ('almost' never - the best use cases I know of require more reflection than Haskell has)
08:27:14 <cmccann> it can mess with other transformers almost at badly, it just can't do as many mind-bending things on its own
08:27:19 <Philippa> well yes, exceptions are a limited form of continuation
08:27:22 <Eduard_Munteanu> "interoperation" is a better word though.
08:27:43 <Philippa> though I don't think "almost as badly" is quite fair. But I seem to be happier with the effects of different transformer orders than many
08:28:09 <Philippa> (I played a lot of Games Workshop's games with shitty rulesets, the notion of rules having priority is natural to me and I proceed from there)
08:28:17 <cmccann> Eduard_Munteanu, you can't really compose stacks as such, that implies they're both applied to a monad and monads in general don't compose, that's why we have transformers to begin with
08:28:54 <Eduard_Munteanu> cmccann: nah, I rather mean juggling data between two different stacks.
08:29:01 <kallisti> what does it mean by "compose stacks"
08:29:50 <cmccann> Philippa, I don't like hidden non-local control flow unless it has well-defined properties
08:29:54 <Philippa> cmccann: you can certainly compose stacks of monad transformers! Just not the applied ones that we use
08:30:18 <Philippa> kallisti: when you stick one monad transformer on top of another, that's composing two single-transformer stacks. Generalise from there
08:30:23 <Eduard_Munteanu> cmccann: like composing an RWS function with an RS one more easily
08:30:25 <cmccann> I take "stack" to mean as applied to a monad
08:30:36 <Philippa> we *also* talk about stacks that have a monad at the bottom (in fact the most common case), but...
08:30:46 <cmccann> transformers are functions between monads and compose in the obvious way to create new transformers
08:31:06 <cmccann> so if you want to call that a stack as well that's fine, but I'd just call it a monad transformer :P
08:31:07 <Philippa> yeah, but then how do I discuss the components of the transformer as a sequence?
08:31:19 <Philippa> it has more structure than just being a function
08:31:25 <kallisti> data SomeMonad  = forall m. Monad m => SomeMonad m
08:31:28 <Philippa> (on monads!)
08:31:29 <kallisti> [SomeMonad]  -- Monad stack.
08:31:33 <kallisti> am I doing it right? :>
08:31:49 <cmccann> Eduard_Munteanu, oh, like lifting between compatible stacks in some sense?
08:31:57 <Eduard_Munteanu> Yeah.
08:31:58 <Philippa> kallisti: I've done things close to that, except I had an explicit compose function I then folded along the list :-)
08:32:06 <Philippa> (wasn't transforming monads but reified modules)
08:32:11 <Eduard_Munteanu> cmccann: lifting kinda sucks for commutative stacks.
08:32:14 <homie> holy....you all on monads or what ?
08:32:18 <homie> lol
08:32:19 <cmccann> Eduard_Munteanu, yes
08:32:30 <Philippa> homie: a bit deeper than 'just' monads, but yeah
08:32:44 * kallisti is on top of a large monad stack.
08:32:52 <Philippa> Eduard_Munteanu: agreed, lift (possible exception: liftIO) is an implementation artefact that should be removed with extreme prejudice
08:32:55 <Eduard_Munteanu> You can do the MonadReader trick and do some autolifting, but it still sucks to generalize.
08:32:56 <cmccann> Philippa, it has as much structure as a function with type (Integer -> Integer) does as a function on integers :P
08:33:25 <cmccann> Eduard_Munteanu, auto-lifting also makes it very easy to create very fragile code
08:33:40 <cmccann> when your transformers aren't commutative
08:34:11 <Philippa> cmccann: If you stick a newtype around it, sure. Otherwise, not so much - you can do a lot based on it with type classes, for example
08:34:24 <Philippa> (also, if we're going for turing completeness the classic's Nat rather than Integer :p)
08:34:46 <chipdude> I've been looking for an env var that tells cabal the default --install-db rather than having to make sure to specify it on each cmdline.
08:34:47 <cmccann> e.g. a constraint like (forall m. MonadState s m, MonadError e m) is basically nonsense, you can't tell what the semantics of combining those classes is
08:34:55 <Eduard_Munteanu> Yeah. Though I kinda wish there was a way to ask the compiler to autogenerate the stack and lifting for various combos instead of writing stuff like RWS.
08:34:57 <chipdude> Can't find it ye.  link link?
08:35:14 <Philippa> cmccann: yeah, you need an additional constraint telling you whether Error 'dominates' State or vice versa
08:35:26 <kallisti> cmccann: that's because you haven't provided the full type, duh.
08:35:33 * hackagebot wai-middleware-headers 0.1 - cors and addHeaders for WAI  http://hackage.haskell.org/package/wai-middleware-headers-0.1 (SeanHess)
08:35:39 <Philippa> otherwise, no rights. But sometimes that's appropriate: you want to support either of transactional or non-transactional semantics, say
08:35:52 <cmccann> kallisti, yes, that's sort of my point
08:35:59 <dcoutts> chipdude: you can specify in the ~/.cabal/config file
08:36:22 <Philippa> (I talked about that on LtU a while back, IIRC there were a few 'ugh' responses and then a while later someone wrote a paper where that was a significant idea...)
08:36:34 <Philippa> (...to be fair, I never bothered implementing it!)
08:37:00 <Philippa> (any time you care, you can create new classes to encapsulate the semantics you care about and manually add instances...)
08:37:20 <cmccann> yes
08:37:20 <Eduard_Munteanu> Actually for RWS you need no lifting whatsoever, but you get my point.
08:37:33 <cmccann> and if you're doing something nontrivial with multiple transformers, you probably should care
08:37:40 <kallisti> could you do this: (MonadErrorT m (t s) a, MonadState s t)
08:37:50 <cmccann> that's why I say they're not really compositional in general
08:38:33 <chipdude> dcoutts: thanks
08:38:37 <dolio> You know, when you combine effects using coproducts, and probably Lawvere theories, you don't know how they interact, either.
08:38:40 <cmccann> you know you have a monad, but what it actually does can be ambiguous enough that it's impossible to write generic functions on generic stacks
08:38:46 <dolio> You just specify at the end.
08:39:04 <cmccann> at least, assuming you want to know what your function actually does
08:39:26 <Philippa> Eduard_Munteanu: that's because RWS is equivalent to a wrapped stack :-)
08:39:56 <Philippa> y'know, sometimes I want that much polymorphism
08:40:12 <Philippa> that said, I also rabidly wrap my stacks/stack fragments
08:40:32 <cmccann> anyway, if you know what you're doing monad transformers are useful but it requires some non-obvious discipline in using them to avoid shooting yourself in the foot
08:40:33 * hackagebot data-treify 0.3.2 - Reify a recursive data structure into an explicit graph.  http://hackage.haskell.org/package/data-treify-0.3.2 (ConalElliott)
08:40:49 <Philippa> if it's a bunch of stuff that's intended to interact and I can't give it a pretty set of interfaces as a collection of entities, it'll have to be one entity instead
08:40:56 <kallisti> in the few instances I've used monad transformers I haven't found them non-obvious.
08:41:14 <cmccann> Philippa, and while it sounds like you're a perfect example of someone with the appropriate and understanding, I hope you can see why I dislike the whole notion on principle
08:41:22 <Eduard_Munteanu> Stuff like STT can get really hairy.
08:41:32 <Philippa> if you've only got one control flow transformer in the stack, you're probably not going to put anything worse than a pea in your foot so long as you write and test the monad first
08:41:55 <Philippa> cmccann: oh, certainly. I find they're necessary, but I wish we had equivalents for a bunch of the Arrow ops for Applicatives
08:42:09 <Philippa> (keeping the value-oriented nature rather than the function-oriented nature of arrows)
08:42:52 <Philippa> I often build a transformer stack only to mostly use the Applicative subset anyway
08:42:55 * cmccann prefers function-oriented code anyway and uses Kleisli composition a lot, heh
08:42:57 <Eduard_Munteanu> Is it just as bad for arrow transformers, btw?
08:43:22 <Philippa> sometimes I can find a few sensible operations that're where all the context-sensitivity happens and abstract those
08:43:22 <cmccann> Eduard_Munteanu, Kleisli arrows imply that it can't be less bad :P
08:43:33 <Philippa> for ArrowApplies
08:43:46 <Eduard_Munteanu> Yeah, I guess so.
08:44:09 <cmccann> Eduard_Munteanu, that said arrows are probably better behaved "in the middle"
08:44:30 <Philippa> if there's no instance of ArrowApply it can be better - I don't think the pseudo-product structure screws you up too badly for example, though I wouldn't be surprised if context-sensitivity does
08:44:34 <cmccann> composition is likely to be as well-behaved as it can be
08:45:07 <Philippa> (but Apply is obviously a whole new world of hurt - it accidentally the whole turing)
08:45:15 <Eduard_Munteanu> I wonder if you could constrain what combos you can make by parametrizing arrows with one more type, or something like that. Though I guess you want dependent types to avoid really ugly type hackery.
08:45:35 * hackagebot cpphs 1.13.3 - A liberalised re-implementation of cpp, the C pre-processor.  http://hackage.haskell.org/package/cpphs-1.13.3 (MalcolmWallace)
08:45:40 <cmccann> Eduard_Munteanu, constrain which part?
08:46:00 <Eduard_Munteanu> cmccann: constrain the way you can stack transformers.
08:46:08 <cmccann> oh
08:46:20 <cmccann> sure you can always do stuff like that
08:46:26 <cmccann> with the caveat that you may not want to use the result
08:46:32 <Philippa> I really need to write up "monads as inverted objects" sometime
08:46:38 <Sugarlake> Hi, how can you mapM_ over Map.Map?  I always get the error: "Couldn't match expected type `[((Int, Int), Foo)]' with actual type `Data.Map.Map Vector Foo'" . Vector is just (Int, Int)
08:46:49 <Philippa> I mean, not actually under that name and probably as a follow-on to my version of what ended up as monads as computations, but still
08:47:05 <Philippa> cmccann: did my description of my version of the monad as OO-like make sense to you?
08:47:31 <Philippa> (I've even envisaged scenarios where you might want a monadic 'message broker'...)
08:47:48 <kallisti> Sugarlake: are you using Control.Monad.mapM_ or Data.Foldable.mapM_ ?
08:47:55 <cmccann> Philippa, mostly, though I'm not convinced it's a fruitful analogy
08:48:19 <Philippa> you know every monad corresponds to an abstract state machine?
08:48:23 <kallisti> Sugarlake: the latter will sequence a monadic function over a Map. The former only works with lists.
08:48:33 <Sugarlake> kallisti, i'm using the Prelude version
08:48:34 <cmccann> kallisti, the latter won't include the keys though
08:48:40 <cmccann> which Sugarlake seems to want
08:48:41 <kallisti> ah.
08:49:06 <maurer> cmccann: What are you deriging that from?
08:49:08 <maurer> *deriving
08:49:17 <Eduard_Munteanu> Philippa: they do? Not a finite state machine in particular, I presume.
08:49:25 <kallisti> Philippa: mapM_ f = void . sequence . map f
08:49:34 <cmccann> maurer, what's "that"?
08:49:35 <kallisti> Philippa: just change map to mapWithKey or something
08:49:51 <cmccann> er
08:50:00 <Eduard_Munteanu> kallisti: you mean Sugarlake
08:50:01 <Philippa> Eduard_Munteanu: rl kicked in, will get back on that
08:50:06 <maurer> cmccann: That Sugarlake wants the key
08:50:07 <kallisti> Philippa: oh yes
08:50:11 <kallisti> sorry :P
08:50:14 <Philippa> (also, I might've screwed up which abstract * machine I meant)
08:50:21 <cmccann> maurer, oh, from the example type given
08:50:23 * kallisti is bad at computer.
08:50:27 <cmccann> seemed to expect a k/v pair
08:50:29 <kallisti> Sugarlake: ^ see above.
08:50:30 <Philippa> aaand back
08:50:38 <Sugarlake> but shouldn't mapM_ just work with with a Map because Map is an instance of the Foldable class?
08:50:46 <Philippa> Eduard_Munteanu: you know that you can always pull off a deep embedding of the corresponding (DS)L, right?
08:50:55 <maurer> Sugarlake: Yes, it will, if you use the mapM_ from Data.Foldable
08:50:58 <kallisti> Sugarlake: yes but like cmccann said it only maps over the values not the keys
08:51:04 <maurer> Sugarlake: They are worried that you want the function to work on the keys as well
08:51:12 <Eduard_Munteanu> Philippa: not sure what you're alluding to, ANF?
08:51:25 <kallisti> Sugarlake: if you want keys you'll have to use something equivalent to what I suggested.
08:51:36 <Sugarlake> i want to map over the (key, values)
08:51:42 <Philippa> I'm not alluding, but yes, you get a language with Monadic Normal Form as its syntactic skeleton and you write an interpreter for it that's equivalent to your run function
08:51:49 <kallisti> or if you want any of the other Data.Map mapping functions that isn't :: (a -> b) -> Map k a -> Map k b
08:52:05 <cmccann> given that you're using mapM_ anyway and want to use the entire structure
08:52:12 <cmccann> you might as well just convert it to a list
08:52:16 <cmccann> and then mapM_ over that
08:52:17 <kallisti> Sugarlake: then yes you'll want void . sequence . mapWithKey f
08:52:24 <Philippa> Eduard_Munteanu: with me?
08:52:30 <Eduard_Munteanu> Yeah.
08:52:41 <Sugarlake> isn't an conversion to list very inefficient?
08:52:55 <cmccann> Sugarlake, no less efficient than traversing the map in general
08:52:59 <cmccann> which is what you're doing anyway
08:53:07 <Philippa> you know the old-school monad types, like State when nobody bothered with a newtype, or List?
08:53:07 <Sugarlake> ah ok, thanks
08:53:14 <Sugarlake> i'll do the list thing then
08:53:17 <Philippa> they correspond to the state of the interpreter in that deep embedding
08:53:42 <kallisti> Sugarlake: ah yes. if you're just throwing away the result anyway then converting to a list is a good choice.
08:53:46 <cmccann> Sugarlake, remember that "conversion" here doesn't mean "turn it into a list, then mapM_ over that"
08:54:00 <Eduard_Munteanu> Philippa: State as type instead of newtype?
08:54:12 <cmccann> Sugarlake, it means "turn it into a lazy list that will produce elements of the Map on demand"
08:54:35 <Philippa> Eduard_Munteanu: yeah, s -> (s, a)
08:54:51 <Philippa> structural rather than nominal, if you prefer
08:54:57 <Eduard_Munteanu> Yeah.
08:55:09 * kallisti demands -XStructuralTyping
08:55:10 <Sugarlake> sounds cool, so it's more like a loop than a "conversion to list"
08:55:24 <kallisti> yes in Haskell a list is equivalent to a linear loop.
08:55:24 <Philippa> cmccann: having got that far we've got one machine and our code is running in it, yes?
08:55:32 <Eduard_Munteanu> Sugarlake: lists pretty much correspond to loops in Haskell, on many occasions :)
08:55:45 <cmccann> Philippa, don't worry, I'm following along, just a bit distracted
08:55:46 <Philippa> (which differs from OO in that OO is all machines passing messages to each other)
08:55:51 <Sugarlake> Eduard_Munteanu, that's nice
08:56:19 <Eduard_Munteanu> Sugarlake: in some cases there's even no list involved in the final program, if deforestation manages to get rid of it
08:56:20 <Philippa> heh, sure. I'm going slightly slow because if I skip a step of working it's likely to produce a WTF, but I'll leave that to Eduard_Munteanu then
08:56:36 <Philippa> Eduard_Munteanu: what's the difference between a program and a message or sequence of messages?
08:57:03 <Eduard_Munteanu> Philippa: uh...
08:57:23 <Eduard_Munteanu> I'm unsure what you mean there :)
08:57:24 <Philippa> well, one difference we already have is that programs go /in/ the machine whereas messages show up at the interface :-)
08:58:00 <kallisti> Sugarlake: of course there is some overhead in the conversion process. using the various Data.Map.map* functions is going to a bit faster than something like: fromList . map f . toList
08:58:22 <kallisti> Sugarlake: however, since you're discarding the result by using mapM_, there's no need to convert back to a Map.
08:58:53 <Philippa> but aside from that, I'm tempted to say not a lot directly: if you had an ST monad full of monad-machine-states and you kept feeding individual machines programs you'd be half way to having OO again
08:59:05 <cmccann> Sugarlake, lazy lists where elements are both generated and consumed on demand, where only one element is needed at a time, are almost exactly the same as an iterative loop on the generated values
08:59:19 <Philippa> (The other half being giving them ways to refer to each other and thus send messages via the substrate of the ST monad)
09:00:05 <Philippa> incidentally, if you think about this you're probably starting to image control flow that looks like it's a glyph for summoning cthulhu - and then realising that it's 3d and consists of 'towers'. Make sense?
09:00:16 <Sugarlake> kallisti, thank you. that's good to know. I'm always afraid of all these list things, sounds so inefficient. But if the compiler basically makes a loop then this should not be so bad
09:00:44 <mekeor> i've got an indentation-problem which i described here, on hpaste:
09:00:45 <hpaste> mekeor pasted “indentation of "if then else"” at http://hpaste.org/57539
09:01:06 <tgeeky> did someone just ask of a glyph for summoning cthulhu makes sense?
09:01:40 <cmccann> ia! ia! cthulhu fhtagn!
09:01:44 <Philippa> mekeor: stick then and else in a space to shut it up? I find it's a good idea to do that with hanging parts of blocks anyway
09:01:48 <kallisti> Sugarlake: yes, optimization of non-strict programs is quite a bit different than optimizing their strict counterparts. Coming from another language, it can be non-obvious what is and isn't going to be inefficient.
09:01:52 <Eduard_Munteanu> Philippa: well not that last image :), but I guess State as as an automata makes sense. Would non-deterministic automata fit all monads?
09:02:22 <maurer> @remember Philippa incidentally, if you think about this you're probably starting to image control flow that looks like it's a glyph for summoning cthulhu - and then realising that it's 3d and consists of 'towers'. Make sense?
09:02:22 <lambdabot> I will never forget.
09:02:27 <Philippa> Eduard_Munteanu: all Monads AFAIK, yes. The transformations are reasonably standard PL semantics tools by now
09:03:04 <Philippa> Eduard_Munteanu: I'm guessing you can picture the "argh, the control flow!" bit, want me to explain the 'towers'?
09:03:12 <rwbarton> mekeor: your example does not have an indentation problem.
09:03:26 <mekeor> Philippa: well, yes, it works with "then" and "else" more indented as "if".. but i like my original indenation-style..
09:03:35 <kallisti> Sugarlake: in fact there's a thing called "list fusion" which is a set of compile-time syntactic substition rules that, in some cases, can "fuse" many list consumers into a single one.
09:03:36 <mekeor> rwbarton: so, it's rather a bug of hlint than my fault?
09:03:39 <mekeor> nice! =)
09:03:44 <rwbarton> Uh...
09:03:45 <Sugarlake> kallisti, yeah. i'm mostly using C
09:03:53 <cmccann> mekeor, if GHC accepts it then it's fine
09:03:53 <mekeor> rwbarton: that's what i wanted to hear. thanks.
09:03:55 <rwbarton> I suppose hlint also replaced "condition" by "foo" etc. in your example?
09:04:01 <mekeor> cmccann: yes it does.
09:04:11 <Philippa> mekeor: yeah. It doesn't generalise though :-( I use a substantially bigger indent for tree-shaped structure to differentiate
09:04:12 <mekeor> rwbarton: no... i did that.. hehe
09:04:14 <Eduard_Munteanu> Philippa: well, I guess I know a bit what you mean there, if I picture monad functions a -> m b as messages accompanied by state transitions.
09:04:30 <rwbarton> What I'm trying to say is, I'm mildly annoyed when people simplify their problems to the point of no longer being problems at all, and rely on #haskell to mind-read the actual problem.
09:04:59 <rwbarton> I imagine you've encountered this problem inside a do-block.
09:05:06 <mekeor> rwbarton: me?
09:05:12 <rwbarton> Yes
09:05:18 <mekeor> rwbarton: er.. yes.
09:05:22 <Philippa> rwbarton: I took the 'problem' as "WhyTF is the warning appropriate?"
09:05:24 <cmccann> well, it's ideal to simplify problems precisely to the point where all irrelevant information is removed and nothing else
09:05:39 * hackagebot hums 0.4.1 - Haskell UPnP Media Server  http://hackage.haskell.org/package/hums-0.4.1 (BardurArantsson)
09:05:43 <rwbarton> that's fair, but! you can at least test your simplified example to check that it exhibits the same problematic behavior!
09:05:44 <cmccann> and clearly someone who needs help with a problem is in an ideal position to evaluate what information is irrelevant :P
09:05:51 <hey_lu> 2
09:05:59 <hey_lu> (sry)
09:06:08 <Philippa> Eduard_Munteanu: the towers correspond to the 'dominance' relationship I mentioned earlier as well btw. The combination of that and the "3D" bit is, I think, an essential part of the image of what 'general' looks like
09:06:32 <Eduard_Munteanu> Oh, you mean monad transformers there.
09:06:41 <rwbarton> Anyways, the answer is that in a do-block, if you have a new line indented the same amount as the previous line, it's a separate "command" in the do-syntax
09:06:48 <dolio> What's the state machine that corresponds to the monad completing the rationals to the reals?
09:06:51 <Philippa> it suggests to me that layers in the OO sense are pretty fundamental and /monads and their ilk/ (meaning approx. things that correspond to these machines, but allow embedding the metalanguage back in) are the ideal skeletons for them
09:07:20 <Eduard_Munteanu> dolio: is there such a monad? :/
09:07:24 <dolio> Yes.
09:07:28 <Philippa> dolio: I forget if I made the disclaimer earlier or not, so fair enough :-) Monads whose endofunctor is on a category with a PL such as Haskell as its internal language
09:07:35 * Eduard_Munteanu can't really tell, except by looking at a monad as a closure operator, but still.
09:07:36 <mekeor> rwbarton: oh. so i should indent "then" and "else" more than "if", right? should i?
09:07:37 <damo22> where is a simple guide on haskell syntax?
09:07:48 <Philippa> or to put it another way, Monads rather than monads (and their suitable relatives)
09:07:58 <rwbarton> mekeor: that's why you see a parse error on ";", it's the ; inserted by the layout rules in the do-block
09:08:01 <Eduard_Munteanu> dolio: oh, you mean category-theoretic monads, right?
09:08:12 <cmccann> Eduard_Munteanu, those are called "monads" :P
09:08:17 <Philippa> dolio: nitpick dispatched? :-)
09:08:18 <rwbarton> mekeor: either do that, or there is also a GHC extension that lets you use if-then-else with no extra indentation inside a do block
09:08:23 <Eduard_Munteanu> Yeah, sure, but the context gets confusing.
09:08:32 <kallisti> mekeor: yes, however that only applies within a do-block. Elsewhere, you can have a then and else that are flush with the if idention level.
09:08:35 <cmccann> rwbarton, I thought mekeor said that GHC accepted the code
09:08:36 <dolio> Philippa: Maybe. I don't have further counterexamples on hand.
09:08:38 <rwbarton> I forget the name, but it might be called IfThenElse
09:08:44 <Philippa> (I'd be entirely happy if we found a good name for monads-on-PLs)
09:08:51 <mekeor> cmccann: yes, it did.
09:08:56 <crypton_> hello
09:09:01 <mekeor> hello, crypton_
09:09:01 <cmccann> Philippa, "warm fuzzy things"?
09:09:11 <hey_lu> damo22: I only know this one: http://blog.ezyang.com/2011/11/how-to-read-haskell/
09:09:12 <monochrom> how simple is simple? in any case, http://www.hck.sk/users/peter/HaskellEx.htm has summary of syntax
09:09:20 <crypton_> i have problems in installing wxhaskell on mac osx
09:09:32 <crypton_> can anyone help?
09:09:59 <rwbarton> cmccann: it isn't clear to me whether mekeor was talking about ghc vs. hlint or about if-then-else in a do-block vs. outside one.
09:10:17 <Philippa> Eduard_Munteanu: Considering my wrapper from the earlier discussion as a machine composed (unconventionally, in OO terms) from other such machines, does the original comment now make sufficient sense?
09:10:21 <rwbarton> is the IfThenElse extension part of Haskell 2010?
09:10:22 <Philippa> cmccann too, I guess
09:10:29 <dolio> Philippa: One could still be concerned that there are conceivably monads whose natural transformations aren't representable as Haskell functions.
09:10:31 <mekeor> rwbarton: ghc compiled fine. hlint printed an error. it's inside a do-block.
09:10:34 <sm> damo22: what about http://tryhaskell.org/
09:10:40 <Eduard_Munteanu> Philippa: yeah
09:10:52 <dolio> Which might throw a wrench in.
09:11:10 <dolio> But I don't have an example of that.
09:11:21 <Philippa> dolio: yeah. Let's throw a "computable" in there too, then :-)
09:11:35 <Philippa> (to the extent it's a typing problem only, I'm not worried about Haskell specifically)
09:11:36 <mekeor> rwbarton: anyway. thank you. :)
09:11:42 <Eduard_Munteanu> dolio: well, I guess 'return' for the completion to reals is one such example no?
09:11:59 <Philippa> Eduard_Munteanu: Haskell in no way embeds the reals!
09:12:00 <dolio> Eduard_Munteanu: The completion monad isn't a monad on Hask.
09:12:12 <dolio> It's on a category of some sort of metric spaces.
09:12:26 <Philippa> dolio: I deliberately made a more general statement than Hask, btw. If nothing else, monads on subcategories of Hask are awesome
09:12:28 <Eduard_Munteanu> Well, yeah.
09:12:53 <Eduard_Munteanu> So did you mean monads on Hask whose natural transformations aren't representable there?
09:13:03 <Philippa> Eduard_Munteanu: looked that way to me
09:13:11 <Eduard_Munteanu> Ah.
09:13:17 <dolio> Yes, that's what I meant.
09:13:56 <Philippa> FWIW, I believe my model stands up to IO (it's the bottom layer). Though you've got the option of playing the get out of example free card :-)
09:14:39 <Eduard_Munteanu> I'm guessing one could start with adjunctions to/from categories which contain stuff Hask can't represent.
09:14:43 <dolio> You could have a monad (T, eta, mu) such that T isn't representable as a value of * -> *, or eta isn't representable as a function with type forall a. a -> T a, or mu...
09:15:07 <dolio> Monad on Hask, or something Hask-like.
09:16:11 <Eduard_Munteanu> So you get a Hask -> Hask endofunctor, yet at least a naive η won't work.
09:17:04 <dolio> I don't have an example.
09:17:09 <dolio> Nor do I know that it's actually possible.
09:23:00 <Philippa> dolio: I do wonder sometimes how well I've internalised what I can/can't lean on the basic laws for in a computional-flavoured category
09:23:36 <Philippa> to rephrase: how good my internal heuristics are :-)
09:25:45 * hackagebot implicit 0.0.1 - Math-inspired programmatic 2&3D CAD: CSG, bevels, and shells; gcode export..  http://hackage.haskell.org/package/implicit-0.0.1 (ChristopherOlah)
09:26:45 <dolio> You can probably get around any issues by stipulating that you're using a self-enriched category.
09:27:30 <dolio> So your hom types are automatically Haskell types and whatnot.
09:27:59 <cmccann> Eduard_Munteanu, you could probably concoct something horrible using a map from Haskell types to expressions computing something of that type and then a map back that discards information in a way that makes join uncomputable
09:28:52 <dolio> Maybe that wouldn't be good enough to handle natural transformations and the like, I'm not sure.
09:28:53 <Eduard_Munteanu> Hm, perhaps something like that.
09:30:00 <cmccann> Eduard_Munteanu, like how the diagonal argument still works when applied to computable reals, but instead of implying that computable reals are uncountable it shows that the diagonal is uncomputable
09:30:58 <Eduard_Munteanu> BTW, they are uncountable, right?
09:30:58 <cmccann> note that taking a diagonal lends itself very well to being "join"
09:31:08 <Eduard_Munteanu> I'm not really familiar with that.
09:31:17 <cmccann> no, the computable reals are countable
09:31:27 <Cale> The computable reals are countable, because you can enumerate programs
09:31:27 <cmccann> if nothing else, because you can enumerate possible computations
09:31:32 <Eduard_Munteanu> Hrm, right, they have to be "smaller" than actual reals.
09:31:59 <roconnor> "actual" reals
09:32:01 <c_wraith> I like that the computable reals are countable, but any mapping from them to Naturals is non-computable
09:32:09 <dolio> You can 'enumerate' them with an uncomputable function.
09:32:35 <cmccann> dolio, you can computable enumerate computations, but not computations that produce computable reals
09:32:44 <Eduard_Munteanu> Ah, so the idea is N ~ CR, but the isomorphism isn't computable?
09:32:52 <Cale> Eduard_Munteanu: Right
09:33:00 <c_wraith> also, "actual" reals is a funny thing to call a set that consists mostly of things that cannot be described.
09:33:13 <Eduard_Munteanu> :)
09:33:21 <cmccann> Eduard_Munteanu, right, hence the diagonal being a non-computable real
09:33:29 <Cale> Well, the "actual" reals are the reals of ZFC :)
09:33:46 <sipa> c_wraith: i don't believe you! give me an example of such a thing that cannot be described!
09:33:51 <Eduard_Munteanu> Yeah, ye olde reals.
09:34:05 <Cale> sipa: There are only countably many descriptions
09:34:15 <sipa> Cale: i was kidding, i know :)
09:34:21 <roconnor> Cale: sipa is joking
09:34:26 <Cale> I figured you probably were
09:34:32 <Cale> But just to be safe :)
09:34:44 <cmccann> c_wraith, statistically speaking the reals consist entirely of things that can't be described
09:34:57 <c_wraith> statistically, it's 100%
09:35:02 <cmccann> exactly
09:35:06 <Philippa> @remember c_wraith also, "actual" reals is a funny thing to call a set that consists mostly of things that cannot be described.
09:35:06 <lambdabot> Good to know.
09:36:07 <roconnor> to be fair to Cale and his ZFC, calling uncomputable reals as undescribable is unfair.  I think there are a few describable uncomputable reals that are describable.
09:36:11 * roconnor ponders that.
09:36:23 <Cale> Sure!
09:36:27 * mux attempts to parse that
09:36:33 <cmccann> depends on how you define "describe" I suppose
09:36:36 <Cale> The computable reals are a subset of the definable ones.
09:36:43 <Guest84308> e.g. Chaitin's omega
09:36:47 <roconnor> You just need to find a predicate that (classically) implies unique existance.
09:36:52 <Cale> right
09:37:00 <sipa> roconnor: things like "the smallest natural number that cannot be described by a million english words" ?
09:37:12 <cmccann> informally "describe" could mean anything from "define" to "compute" :P
09:37:12 <roconnor> sipa: possibly
09:37:35 <cmccann> sipa, that doesn't sound well-defined
09:37:53 <sipa> cmccann: it's from a text by Chaitin
09:38:11 <sipa> to explain his number
09:39:16 <cmccann> I think self-inconsistent definitions are distinct from consistent definitions of something that can't be computed
09:39:38 <cmccann> even if the ideas are related
09:39:54 <roconnor> cmccann: you need to take a liberal understanding of sipa's use of "like" in "thinkgs like".
09:40:02 <cmccann> fair enough
09:40:05 <roconnor> as in, "very vaguely like"
09:42:13 <hpaste> mary pasted “Knapsack” at http://hpaste.org/57541
09:42:34 <heffaklump> http://hpaste.org/57541
09:42:42 <heffaklump> ^^ knapsack problem in haskell
09:42:54 <heffaklump> frustrating have tried to find error for 2 hours
09:43:10 <heffaklump> some sort of one-off bug i think because it is almost right
09:44:34 <heffaklump> wait
09:44:38 <heffaklump> i do a new one
09:47:24 <hpaste> mary2 pasted “knapsack01” at http://hpaste.org/57542
09:47:42 <heffaklump> anyoen would be so kind to investigate it?
09:48:12 <cmccann> heffaklump, a lot of that code really isn't doing things in an ideal way
09:48:43 <cmccann> which makes it hard to figure out where the issue is
09:50:34 <cmccann> heffaklump, there's a fair amount of redundant code and reimplementation of standard functions, from what I can see at a glance
09:51:33 <heffaklump> i understand
09:51:41 <cmccann> heffaklump, I can give you some advice on code style and idiom if you like
09:51:48 <cmccann> but in its current form I really can't help with the logic
10:02:52 <tromp__> cmccann, when you talk about diagonal of computable reals, how do you deal with undeterminable bits?
10:03:36 <tromp__> you cannot compute the n'th bit of a computable real with certainty
10:03:46 <cmccann> tromp__, you don't
10:03:48 <cmccann> that's the point
10:04:14 <cmccann> oh boy
10:04:42 <tgeeky> cmccann: is it Cantor that was the first with this argument?
10:05:15 <cmccann> tgeeky, it's a whole family of arguments that crop up in lots of places
10:05:23 <cmccann> and I don't think cantor was even the first to use the style
10:05:23 <tromp__> the reals for which you can compute bit n given n are some other class
10:06:14 <cmccann> tgeeky, but yes in this case it's very similar to cantor's argument
10:06:47 <tgeeky> cmccann: I guess I just meant the diagonalization argument, not the computability and bits part
10:07:06 <tgeeky> it's one of those rare cases where the person for whom it is named, actually is the inventor
10:07:23 <cmccann> the diagonalization argument is cantor's proof, yes
10:08:59 <cmccann> the broader class of proofs with similar structure may have examples predating cantor, not sure
10:11:42 <cmccann> most proofs of the form "take X, define a part of X that by construction can't be part of X, cantor and godel laugh at you from beyond the grave qed" amounts to the same idea
10:12:32 <Botje> necromancy through proof techniques? sounds like a @cstross novel :)
10:12:40 <damo22> how do i extract the Just and Nothing from a Maybe and get it to return the value or []
10:12:51 <cmccann> :t maybeToList
10:12:51 <lambdabot> forall a. Maybe a -> [a]
10:13:07 <cmccann> > maybeToList Nothing
10:13:07 <lambdabot>   []
10:13:10 <cmccann> > maybeToList (Just 5)
10:13:11 <lambdabot>   [5]
10:13:14 <cmccann> damo22, like that?
10:13:18 <damo22> yes
10:13:26 <cmccann> I think you need to import Data.Maybe for that
10:13:36 <mux> @index maybeToList
10:13:36 <lambdabot> Data.Maybe
10:13:40 <mux> yes you do
10:13:55 <byorgey> @index (+)
10:13:55 <lambdabot> Prelude
10:14:03 <byorgey> shucks
10:14:34 <cmccann> Botje, a surprising number of results related to computability boil down to roughly "godel gets the last laugh and the universe hates you"
10:15:34 <c_wraith> I wonder if I'm wandering down the same road as Wolfram, as I think to myself "computability must mean something"
10:15:51 * hackagebot dingo-core 0.2.0 - Dingo is a Rich Internet Application platform based on the Warp web server.  http://hackage.haskell.org/package/dingo-core-0.2.0 (BardurArantsson)
10:16:02 <Botje> cmccann: makes sense
10:16:12 <cmccann> c_wraith, I think the better question is whether non-computability means anything
10:20:25 <roconnor> cmccann: I would be inclined to define a non-computable fuction from A to B as a relation R : A * B -> Prop  such that forall a:A. ~ forall b:B. ~ R a b  and that forall a:A. forall b1, b2:B. R a b1 /\ R a b2 -> b1 = b2.
10:20:36 <rudyl313> if I have record-syntaxed type.. and a value of that type.. is there a way to create a duplicate of that value, where only on of the attributes is changed?
10:20:51 * hackagebot dingo-widgets 0.2.0 - Dingo Widgets  http://hackage.haskell.org/package/dingo-widgets-0.2.0 (BardurArantsson)
10:21:26 <Botje> rudyl313: foo{splot="wibble"}
10:21:41 <dmwit> roconnor: Did you include the "non-computable" bit in there somewhere?
10:21:42 <rudyl313> Botje: is foo the old value?
10:21:48 <Botje> where foo is such a record type and splot is the attribute name
10:22:21 <cmccann> roconnor, sorry, lost the context of that discussion
10:22:32 <Botje> *a value of such a record type
10:22:43 <rudyl313> Botje: ahhh gotcha
10:22:49 <Eduard_Munteanu> rudyl313: it's the constructor
10:22:49 <rudyl313> Botje: cool, I'll try that
10:22:55 * cmccann got distracted by paradoxes and amusement that encoding Curry's paradox can cause a Haskell compiler to diverge
10:22:56 <tgeeky> can we even do that in Haskell? forall a:A. ~ forall b:B.
10:23:02 <Eduard_Munteanu> rudyl313: erm, sorry, the old value
10:23:23 <dmwit> tgeeky: Not really. You can do forall a : A. (forall b : B. bleh) -> Void
10:23:24 <rudyl313> thanks
10:23:25 <Eduard_Munteanu> What's '~'?
10:23:32 <Eduard_Munteanu> Ah, negation.
10:24:33 <dmwit> ?djinn Not (Not (Not a)) -> Not a
10:24:34 <lambdabot> f a b = void (a (\ c -> c b))
10:25:53 * hackagebot dingo-example 0.2.0 - Dingo Example  http://hackage.haskell.org/package/dingo-example-0.2.0 (BardurArantsson)
10:26:00 <cmccann> ?djinn Not (Not a) -> a
10:26:00 <lambdabot> -- f cannot be realized.
10:26:08 <roconnor> dmwit: the non-computable comes from the twiddles
10:26:22 <roconnor> in forall a:A. ~ forall b:B. ~ R a b
10:26:30 <roconnor> the computable versio would be
10:26:36 <roconnor> forall a:A. exists b:B. R a b
10:27:45 <Eduard_Munteanu> ?djinn Not (Not (Not (Not a))) -> Not (Not a)
10:27:45 <lambdabot> f a b = void (a (\ c -> void (c b)))
10:28:19 * cmccann wonders if whoever writes the GHC user guide could be persuaded to make the example of causing GHC to diverge use Curry's paradox instead of Russel's
10:28:24 <cmccann> just seems appropriate
10:28:29 <dmwit> roconnor: No, I understand that the definition includes the non-computable functions that way. But it also seems to include the computable functions.
10:28:50 <dmwit> roconnor: If so, then that seems like a bad definition of "non-computable function". =P
10:28:53 <roconnor> dmwit: clearly every computable function is a non-computable function. ^_^
10:29:03 <dmwit> um
10:29:04 <dmwit> =P
10:29:22 <roconnor> dmwit: heh, you are right
10:29:27 <roconnor> I should have called these classical functions
10:29:28 <tgeeky> clearly! wait. No. wait. yes. wait. no. wait. ...
10:29:53 <roconnor> and simply notated that there are some classical functions that are not (images of) computable functions.
10:30:03 <roconnor> *noted
10:30:14 <cmccann> @quote fix.not
10:30:14 <lambdabot> syntaxglitch says: <Kleene> hey al check this out <Kleene> > fix not <lambdabot> mueval-core: Time limit exceeded <Church> well crap
10:30:15 * dmwit nods agreeably
10:30:44 <dmwit> ?quote fix\ not
10:30:44 <lambdabot> No quotes for this person. Have you considered trying to match wits with a rutabaga?
10:30:51 * dmwit sighs
10:31:39 <tgeeky> dmwit: don't feel so bad. My father was a rutabaga.
10:47:13 <kmel> Hi, couldn't find any help on #xmonad, but since it may be related.. xmonad --recompile throws an error saying it can't find modules from xmonad-contrib, but ghc-pkg lists it. How can I proceed?
10:49:13 <dmwit> kmel: Let's continue in #xmonad.
10:55:55 * hackagebot hack-handler-simpleserver 0.2.2 - A simplistic HTTP server handler for Hack. (deprecated)  http://hackage.haskell.org/package/hack-handler-simpleserver-0.2.2 (AlbertoCorona)
10:57:06 <heffaklump> why use a lang that makes it hard to do nest 2 for loops?
10:57:34 <byorgey> no idea.  do you know of such a language?
10:57:57 <heffaklump> h_s___l
10:58:01 <heffaklump> fill in the blanks
10:58:14 <byorgey> It's quite easy to do nested loops in Haskell.
10:58:31 <byorgey> > [ (x,y) | x <- [1..5], y <- [3..7] ]  -- here's one way
10:58:32 <lambdabot>   [(1,3),(1,4),(1,5),(1,6),(1,7),(2,3),(2,4),(2,5),(2,6),(2,7),(3,3),(3,4),(3...
10:58:50 <cmccann> though I don't really recommend it, plain for loops are bad practice most of the time
10:58:52 <cmccann> in any language
10:58:57 <danharaj> :t forM
10:58:58 <lambdabot> forall a (m :: * -> *) b. (Monad m) => [a] -> (a -> m b) -> m [b]
10:59:00 <byorgey> if you want monadic stuff you can do something like  forM_ [1..5] $ \x -> forM_ [3..7] $ \y -> ...
10:59:23 <heffaklump> http://hpaste.org/57542 <- the generateTables function in py is horribly annoying to translate to haskell and i cant find the error
10:59:55 <byorgey> heffaklump: Haskell makes it easy to do nested iteration/recursion.  However, it's certainly understandable that it takes a while to get used to the particular ways of structuring things in HAskell.
11:00:38 <Sicp> so I do "let array = [1,2,3,4,5]" in my script, I try to compile and I get that it's a possible indentation error?
11:00:48 <Sicp> it's "let" being used inside the script..
11:01:20 <danharaj> use hpaste.org to paste your code
11:01:32 <dmwit> Sicp: If you're writing a file, you don't need let at the top level as you do in ghci.
11:01:32 <dmwit> Just write what things are equal to.
11:01:32 <dmwit> array = [1,2,3,4,5]
11:01:32 <Sicp> yes I know but I'm asking about the error I got
11:01:32 <dmwit> (Note that [1,2,3,4,5] is not an array, though.)
11:01:34 <Sicp> it's "let" being used inside the script..not an indentation error
11:01:36 <dmwit> Sicp: Well, paste the whole file.
11:01:47 <dmwit> ?hpaste
11:01:47 <lambdabot> Haskell pastebin: http://hpaste.org/
11:01:51 <Sicp> it's nothing really...it's only that line
11:02:10 <Sicp> it works when I remove let, but errors with a nonsense error when there's let
11:02:14 <Sicp> it doesn't say that it's "let"
11:02:23 * dmwit nods appreciatively
11:02:34 <Sicp> the error is what I'm asking about
11:02:35 <dmwit> Luckily, GHC is open source -- so patch it to make a clearer error!
11:02:36 <dmwit> =)
11:02:46 <Sicp> fair enough
11:02:49 <Sicp> thanks
11:02:56 <danharaj> ghc has shitty error messages
11:03:05 <Sicp> Im being introduced to haskell through LearnYouaHaskell
11:03:09 <eviltwin_b> Sicp, standalone "let" is only valid inide a "do" block; the correct syntax is "let <bindings> in <expr>"
11:03:35 <Sicp> good source?
11:03:44 <Sicp> well, "good"...
11:03:45 <Sicp> lol
11:05:15 <c_wraith> lyah is a pretty good first intro to the language.
11:05:23 <Sicp> cool
11:05:31 <Sicp> dmwit, what I wrote above is a list, not an array
11:05:32 <Sicp> yea?
11:05:45 <dmwit> yes
11:06:00 <JoeyA> Is it dangerous for a finalizer to perform an STM transaction?
11:06:14 <dmwit> danharaj: That's not fair. I've found GHC's error messages to be quite informative in most cases.
11:06:38 <navaati> hi
11:06:58 <danharaj> dmwit: The problem is that there's no middle ground. Either you understand completely a GHC error or it's complete gibberish. :p
11:07:22 <dmwit> Yes, they take a bit of patience. But I think that may very well be unavoidable.
11:07:37 <JoeyA> I find the line number the most useful bit of information
11:07:44 <danharaj> Also indentation errors tend to tell you something completely irrelevant
11:07:45 <dmwit> Programming is (for now) an exacting task.
11:07:54 <CodeWeaverX> Greetings!
11:08:10 <cmccann> GHC's errors are usually very informative once you learn to speak GHC-ese
11:08:38 <johnsingleton> is there a tool for auto-creating .cabal files?
11:08:46 <JoeyA> cabal init
11:08:54 <johnsingleton> oh reaaaalllly
11:09:13 <cmccann> I recommend the minimal mode
11:09:26 <cmccann> or anything that tells it to not stuff the .cabal full of useless comments
11:09:57 <johnsingleton> nice
11:10:03 <johnsingleton> that's exactly what I was looking for
11:10:06 <c_wraith> those comments aren't useless the very first time you create a .cabal file
11:10:13 <c_wraith> ... They are every single subsequent time
11:11:05 <cmccann> c_wraith, yes
11:11:07 <johnsingleton> thanks!
11:11:30 <navaati> i've just seen the new features in GHC 7.4 and i'm wondering… These things like "forall k. k -> Constraint" for a kind signature, it's becoming more and more like "we're making haskell a fully dependent typed language and we don't want to admit it", eh ?
11:11:31 <navaati> (don't misunderstand me, i like it !)
11:11:40 <cmccann> not really
11:11:49 <dmwit> Come on, yes it is.
11:11:51 <dmwit> That's the point!
11:12:05 <dmwit> See how close we can get to dependent types while still being efficient and having type inference.
11:12:24 <dmwit> Meanwhile the dependent type folks are seeing how much they have to drop to become efficient and get type inference.
11:12:25 <cmccann> well, there's still a big gap when it comes to types actually depending on terms
11:12:43 <cmccann> most of the stuff added to GHC is about doing more entirely at the type level
11:13:09 <navaati> so… Real World Agda soon :trollface.jpg: ?
11:13:18 <dmwit> Right! =)
11:13:19 <NihilistDandy> Oh, god, I hope so
11:13:27 <c_wraith> ask copumpkin about writing that. I'm sure he'd be up for it.
11:13:28 <NihilistDandy> I want a nice intro Agda book so much
11:13:39 * cmccann is more hoping for Learn You an Agda
11:13:49 <NihilistDandy> ^^
11:13:59 <ion> I’d like that, too.
11:14:01 <NihilistDandy> Though I saw an incipient effort for that on github
11:14:09 <cmccann> complete with silly cartoons and such
11:14:13 <Sicp> 1:2:3:[] <-- that means add 1 and 2 and 3 to a list
11:14:15 <NihilistDandy> https://github.com/liamoc/learn-you-an-agda
11:14:24 <cmccann> haha
11:14:55 <mekeor> is there a synonym for "\x l-> find (x==) l" ?  in the same way, for example, there is a synonym for "\x l -> findIndex (x==) l", too: "elemIndex x l", too...
11:15:06 <dmwit> :t elem
11:15:07 <lambdabot> forall a. (Eq a) => a -> [a] -> Bool
11:15:07 <dmwit> :t find
11:15:08 <lambdabot> forall a. (a -> Bool) -> [a] -> Maybe a
11:15:38 <mekeor> @hoogle a -> [a] -> Maybe a
11:15:39 <lambdabot> Data.List elemIndex :: Eq a => a -> [a] -> Maybe Int
11:15:39 <lambdabot> Network.BufferType buf_concat :: BufferOp a -> [a] -> a
11:15:39 <lambdabot> Prelude asTypeOf :: a -> a -> a
11:15:39 <dmwit> ?hoogle a -> [a] -> Maybe a
11:15:40 <lambdabot> Data.List elemIndex :: Eq a => a -> [a] -> Maybe Int
11:15:40 <lambdabot> Network.BufferType buf_concat :: BufferOp a -> [a] -> a
11:15:41 <lambdabot> Prelude asTypeOf :: a -> a -> a
11:15:54 <mekeor> doesnt seem so... anyway. thanks.
11:15:54 <dmwit> great minds =)
11:16:07 <dmwit> :t find . (==)
11:16:08 <lambdabot> forall a. (Eq a) => a -> [a] -> Maybe a
11:17:39 <alang_> what are the best options for non-linear numerical optimization libraries in haskell?
11:18:49 <mux> :t (+1) :: a ~ Int => a -> a
11:18:50 <lambdabot> Int -> Int
11:19:13 <mekeor> mux: what's ~ ?
11:19:30 <mux> an equality constraint
11:19:41 <dolio> There's no reason that real dependently typed languages must be slow, other than that they're typically worked on by a team of one or two people who aren't primarily motivated by building something as industrial strength as GHC.
11:19:53 <mekeor> mux: so, a ~ Int means a equals Int ?  but for types only?
11:19:59 <mux> mekeor: yep
11:20:14 <mux> it's typically used with type families
11:20:43 <mux> such as f :: (Foo a, Foo b, FooType a ~ FooType b) => ...
11:20:47 * mekeor doesn't know type families... yet. (only type classes, of course..)
11:21:32 <navaati> now that things like type families are in ghc, what we *really* need is a big rework of the prelude using them…
11:21:52 <navaati> (rmonad i'm looking at you)
11:22:01 <NihilistDandy> I'm all for it.
11:22:01 <mux> a NewPrelude would be nice, even without using type families (but I fully agree)
11:22:32 <navaati> i don't even remember what the r in rmonad stands for…
11:22:35 <mux> there are a few things to fix in the type-class hierarchy
11:22:40 <mux> navaati: restricted
11:23:04 <navaati> wtf ? aren't they less restrictive ?
11:23:12 <cmccann> we already have a new prelude. we have many of them, in fact.
11:23:24 <mekeor> cmccann: oO
11:23:28 <mux> they're more restricted in their type, the canonical example would be the Set monad, where types need to be in ord
11:23:31 <mux> Ord*
11:23:36 <navaati> ah, yeah
11:23:37 <mekeor> cmccann: but no "official" new one, right?
11:23:40 <navaati> thanks
11:23:45 <cmccann> inventing half-baked prelude replacements is a popular passtime
11:23:50 <cmccann> mekeor, right
11:24:07 <mekeor> cmccann: will there be one? (i mean an official new prelude..)
11:24:14 <mekeor> that'd be genious!
11:24:32 <cmccann> there's no reason there can't be
11:24:34 <navaati> (it's been a long time since i seriously did haskell, i need to recall all of this…)
11:24:38 <cmccann> but that'd break a lot of code
11:24:46 <cmccann> and is part of the language specification
11:24:54 <cmccann> so it's not something that can be done easily
11:24:57 <mux> fixed numerical hierarchy, fixed Functor/Monad stuff, ditch all the FDs in favor of TFs, remove partial functions, base everything possible off Applicative/Traversable/Foldable to have much more general functions
11:25:03 <mux> hmmm, what else
11:25:03 <navaati> beside this, a nex prelude without all the libs using it is pretty useless
11:25:07 <navaati> new*
11:25:24 <ion> mux: Remove Int from Prelude
11:25:29 <cmccann> yes
11:25:29 <mekeor> ion: YEAH!
11:25:30 <rboot_> quit
11:25:31 <navaati> ion ?
11:25:38 <cmccann> and make Rational the default for Fractional constraints :P
11:25:40 <navaati> what's the problem with Int ?
11:25:41 <mekeor> navaati: Integral instead of Int!
11:25:51 <cmccann> (with defaulting to Double if a Floating constraint is present)
11:25:52 <navaati> isn't Integral a class ?
11:25:58 <mux> yes
11:25:58 <cmccann> mekeor means Integer
11:26:10 <navaati> aaah
11:26:13 <mux> oh, strict pairs in the prelude
11:26:14 <cmccann> well, Integer as the default integral type
11:26:16 <mux> by all means
11:26:17 <navaati> i don't agree
11:26:19 <mekeor> cmccann: actually, no, i don't. wouldnt it be better to use Integral a generally?
11:26:25 <cmccann> mekeor, oh right
11:26:25 <mekeor> cmccann: yep
11:26:32 <cmccann> yeah, functions should take Integral arguments
11:26:40 <mekeor> =)
11:26:50 <mux> I bet there are hundreads of isomorphic strict pair definitions in hackage
11:26:54 <navaati> ah, ok… well anyway isn't this defaulting stuff shit ?
11:26:55 <dolio> Integer is the default Integral type.
11:27:39 <cmccann> dolio, er, I meant default in the sense of what tends to be used, not the type defaulting
11:27:44 <navaati> (this learn you a Agda seems pretty good, but… it's intended to be read in github ?
11:27:49 <cmccann> and then I said something about defaulting for Rational
11:27:55 <cmccann> which was kind of unclear
11:28:18 <tromp__> > 0 + maxBound
11:28:19 <lambdabot>   Ambiguous type variable `a' in the constraints:
11:28:19 <lambdabot>    `GHC.Enum.Bounded a'
11:28:19 <lambdabot>    ...
11:28:31 <cmccann> though really if we're changing stuff there seriously should be a Natural type
11:28:42 <cmccann> a.k.a. an unsigned version of Integer
11:30:43 <dcoutts> cmccann: yes, there's a cabal init flag in the current release that turns off comments, and because I thought the same as you, for the next release it's now an interactive Q which defaults to false.
11:30:55 <dcoutts> that way beginners get the comments but advanced users do not
11:31:15 <NihilistDandy> Anyone managed to build numbers (http://hackage.haskell.org/package/numbers) on 7.4, yet?
11:32:37 <cmccann> dcoutts, ah, that sounds like a god idea
11:32:41 <cmccann> awesome
11:32:46 <cmccann> good idea even
11:32:49 <ClaudiusMaximus> class Real a where { approxRational :: a -> a -> Rational ; toRational :: a -> Maybe Rational } -- one small wish for a better Prelude
11:33:48 <ion> What’s the second parameter for approxRational?
11:34:09 <Palmik> Hmm, the example "let v = mkName "T" in [| data $v = $v |]" from here http://hackage.haskell.org/packages/archive/template-haskell/2.7.0.0/doc/html/Language-Haskell-TH.html#g:2 gives me "parse error on input `data'", when I use declarations quasi-quoter I get "parse error in constructor in data/newtype declaration"... so is it possible to splice name like that?
11:34:25 <ClaudiusMaximus> ion: one of them is the value, the other is the maximum radius to find the best rational in, i can never remember which
11:34:41 <roconnor> > approxRational 5.6 1
11:34:41 <lambdabot>   5 % 1
11:34:45 <roconnor> > approxRational 5.6 0.5
11:34:46 <lambdabot>   6 % 1
11:35:01 <roconnor> > approxRational 5.6 0.25
11:35:02 <lambdabot>   11 % 2
11:35:08 <ion> @hoogle approxRational
11:35:09 <lambdabot> Data.Ratio approxRational :: RealFrac a => a -> a -> Rational
11:35:13 <roconnor> ion: the epsilon
11:35:17 <ClaudiusMaximus> > (approxRational 0.0001 pi, approxRational pi 0.0001)
11:35:17 <lambdabot>   (0 % 1,333 % 106)
11:38:56 <sipa> :t pi
11:38:57 <lambdabot> forall a. (Floating a) => a
11:39:13 <sipa> :t pi :: E21
11:39:14 <lambdabot> Not in scope: type constructor or class `E21'
11:40:32 <roconnor> > pi :: Fixed E21
11:40:33 <lambdabot>   Not in scope: type constructor or class `E21'
11:40:39 <roconnor> > pi :: Fixed E9
11:40:40 <lambdabot>   No instance for (GHC.Float.Floating
11:40:40 <lambdabot>                     (Data.Fixed.Fixed D...
11:41:15 <tgeeky> > approxRational (2^^(1/3)) (sqrt(2))
11:41:16 <lambdabot>   Ambiguous type variable `t' in the constraints:
11:41:16 <lambdabot>    `GHC.Real.Integral t'
11:41:16 <lambdabot>   ...
11:41:22 <Flonk> EHLO
11:41:33 <roconnor> tgeeky: **
11:41:44 <tgeeky> roconnor: right. I hate this bit about Haskell :o
11:41:49 <tgeeky> roconnor: I always just want that to work :O
11:41:56 <tgeeky> > approxRational (2**(1/3)) (sqrt(2))
11:41:57 <lambdabot>   0 % 1
11:42:04 <tgeeky> bah. what a boring answer, too.
11:42:09 <roconnor>  approxRational (2^^(1/3)::Double) (sqrt(2))
11:42:14 <roconnor> > approxRational (2^^(1/3)::Double) (sqrt(2))
11:42:15 <lambdabot>   Ambiguous type variable `t' in the constraints:
11:42:15 <lambdabot>    `GHC.Real.Fractional t'
11:42:15 <lambdabot> ...
11:42:30 <roconnor> > approxRational (2^^(1/3::Rational)::Double) (sqrt(2))
11:42:31 <lambdabot>   No instance for (GHC.Real.Integral GHC.Real.Rational)
11:42:31 <lambdabot>    arising from a use...
11:42:44 <tgeeky> starstar?
11:42:57 <roconnor> @type (^^)
11:42:57 <lambdabot> forall a b. (Fractional a, Integral b) => a -> b -> a
11:42:58 <tgeeky> > approxRational (2**((1/3)::Rational)::Double)) (sqrt(2))
11:42:59 <lambdabot>   <no location info>: parse error on input `)'
11:43:05 <tgeeky> > approxRational (2**((1/3)::Rational)::Double) (sqrt(2))
11:43:06 <lambdabot>   Couldn't match expected type `GHC.Types.Double'
11:43:07 <lambdabot>         against inferred ty...
11:43:12 <roconnor> oh right, ^^ doesn't even work for floating
11:43:20 <tgeeky> roconnor: :/
11:43:34 <roconnor> @info Fractional
11:43:34 <lambdabot> Fractional
11:43:42 <roconnor>  @info always disappoints me
11:44:01 <tgeeky> roconnor: there was much discussion about the Reals and non-computability earlier. Hasn't it "been established" that, if there are numbers that are "real" or "natural", they are the algebraic integers?
11:44:02 <roconnor> is Double an instance of Fractional?
11:44:23 <roconnor> tgeeky: huh?
11:44:59 <tgeeky> roconnor: don't number theorists consider the algebraic integers ... the objects most worthy of study?
11:45:27 <roconnor> what are algebraic integers?
11:45:29 <tgeeky> probably the wrong person to ask, anyway
11:45:33 <ClaudiusMaximus> @instances Fractional
11:45:34 <lambdabot> Double, Float
11:45:58 <roconnor> ah duh
11:46:01 <tgeeky> roconnor: uhh, numbers of the form a + b*sqrt(d) / 2 where a,b in Integers, d in squarefree
11:46:04 <roconnor> ^^ takes integers
11:46:55 <roconnor> @wiki Algebraic Integers
11:46:56 <lambdabot> http://www.haskell.org/haskellwiki/Algebraic_Integers
11:47:00 <roconnor> heh
11:47:05 <roconnor> @google Algebraic Integers
11:47:07 <lambdabot> http://en.wikipedia.org/wiki/Algebraic_integer
11:47:07 <lambdabot> Title: Algebraic integer - Wikipedia, the free encyclopedia
11:47:41 <tgeeky> I maybe be using the wrong term. I might mean to say algebraic numbers, instead of integers.
11:48:06 <roconnor> Yes, I'm sure the number theorists are found of algebaric numbers
11:48:20 <byorgey> algebraic numbers include a lot more than  a + b*sqrt(d) / 2 ... ?
11:48:32 <tgeeky> byorgey: yeah, so I guess I do mean algebraic integers.
11:49:24 <byorgey> the algebraic integers include a lot more than that as well.
11:50:53 <roconnor> according to wikipedia, algebraic integers roots of monic integer polynomials.
11:51:16 <roconnor> while algebraic numbers are roots of integer polynomials.
11:51:28 * roconnor thinks that is right
11:51:34 <tgeeky> yes, it looks right.
11:51:47 <tgeeky> I don't even know what the term I'm thinking of is, then.
11:51:49 <tgeeky> Or if there is one.
11:51:51 <roconnor> this is the first I've heard about algebraic integers
11:51:52 <Eduard_Munteanu> roconnor: btw, have you managed to make a Coq lib for real numbers, as per your thesis?
11:51:59 <tgeeky> byorgey dashes my hopes again.
11:52:03 <roconnor> Eduard_Munteanu: naturally
11:52:40 <Eduard_Munteanu> roconnor: hm, is it available somewhere? Somebody in #agda was asking for such a thing
11:52:49 <roconnor> Eduard_Munteanu: it's part of CoRN
11:53:09 <roconnor> or C-CoRN, which is easier to search for
11:53:12 <Eduard_Munteanu> roconnor: ah, thanks
11:53:30 <tgeeky> byorgey: oh. I must be speaking about: integer algebraic number fields K of degree two over Q.
11:53:53 <tgeeky> roconnor: beware, first result is: http://www.c-corn.com/
11:53:54 <byorgey> that sounds more plausible
11:54:22 <roconnor> tgeeky: I feel like I shouldn't click on that link
11:54:30 <byorgey> you shouldn't
11:54:32 <tgeeky> roconnor: it's safe for work
11:54:35 <ion> tgeeky: Is that a parody site? :-D
11:54:38 <tgeeky> it's a political propaganda website
11:54:39 <byorgey> it is most definitely safe for work
11:54:55 <ion> I laughed out loud upon noticing the crying eagle. :-D
11:55:04 <roconnor> this is the best website ever
11:55:30 <Palmik> Any ideas about the example "let v = mkName "T" in [| data $v = $v |]" from http://hackage.haskell.org/packages/archive/template-haskell/2.7.0.0/doc/html/Language-Haskell-TH.html#g:2 It does not work, and you can not splice Names IIRC. Also should not it be in declaration quote at least? (Though I would love to be proven wrong, since it would be a neat way to declare new data types).
11:55:36 <byorgey> "A liberal (also
11:55:36 <byorgey> leftist) is someone who rejects logical
11:55:36 <byorgey> and biblical standards, often
11:55:41 <byorgey> for self-centered reasons."
11:55:46 <byorgey> oops, sorry for the linebreaks
11:55:56 * hackagebot pandoc 1.9.0.4 - Conversion between markup formats  http://hackage.haskell.org/package/pandoc-1.9.0.4 (JohnMacFarlane)
11:55:59 <tgeeky> byorgey: an obviously correct definition! :/
11:56:00 <Cale> http://www.sudo.ws/sudo/alerts/sudo_debug.html -- sigh
11:56:02 <DevHC> wtf is "ghc: could not execute: opt" when using -llvm?
11:56:30 <ion> devhc: Exactly that. Install it. :-P
11:56:39 <DevHC> wat?
11:56:54 <roconnor> Socialism:
11:56:55 <DevHC> wtf is opt?
11:56:56 <roconnor> A theory or system of social
11:56:57 <roconnor> organization that advocates the vesting
11:56:59 <roconnor> of the ownership and control of the of
11:57:00 <roconnor> capital, land, etc., in the
11:57:02 <roconnor> community as a whole.
11:57:03 <roconnor> gah
11:57:04 <erus`> another sudo exploit hue hue
11:57:05 <roconnor> I pulled a byorgey
11:57:05 <ion> % apt-file search bin/opt
11:57:07 <ion> llvm: /usr/bin/opt
11:57:18 <byorgey> roconnor: how rude
11:57:18 <roconnor> where is my multiline past warning?!
11:57:30 <tgeeky> roconnor: in your past
11:57:59 <Sicp> I don't understand, if it's only 1 list, I can't use cons to add another list to it, but if it's a list inside a list, I can?
11:58:11 <ion> @type (:)
11:58:12 <lambdabot> forall a. a -> [a] -> [a]
11:58:29 <ion> You can use (:) to add an “a” in front of a “[a]”.
11:58:35 <byorgey> Sicp: cons adds an element to the start of a list.
11:58:42 <byorgey> if it is a list of lists, then its elements are lists.
11:58:44 <ion> a may or may not be a list.
11:59:17 <Sicp> and if it's one list, its elements are numbers, cons adds a number (an element) to that list..
11:59:27 <Sicp> a number is not an "element"?
11:59:51 <Sicp> oh oh
11:59:53 <Sicp> nevermind
11:59:54 <Sicp> ok
11:59:56 <Sicp> :)
12:00:17 <ion> > let a = 5; b = 6; c = 7 in a:[b,c]
12:00:18 <lambdabot>   [5,6,7]
12:00:29 <ion> > let a = [5,15]; b = [6,16]; c = [7,17] in a:[b,c]
12:00:30 <lambdabot>   [[5,15],[6,16],[7,17]]
12:00:52 <Sicp> yea, seeing it run didn't do it for me
12:00:58 <Sicp> words did
12:01:17 <Sicp> I can't add a list of numbers to a list of numbers
12:01:23 <nand`> Sicp: if it helps, look at the type
12:01:25 <Sicp> I can add list of numbers to a list of lists
12:01:46 <Sicp> @type (:) gave a parse error
12:01:46 <nand`> the result of the first snippet ion evaluated was type Num a => [a] (for all intents and purposes, let's assume [Int])
12:01:47 <lambdabot> Not in scope: `gave'
12:01:47 <lambdabot> Not in scope: `parse'
12:01:50 <nand`> the second was [[Int]]
12:01:54 <jeff_s_> Is there a known problem where instances of IsString can't be used in pattern matching?
12:02:57 <sipa> jeff_s_: if they are not lists of characters, you can't pattern match them against lists of characters
12:03:35 <jeff_s_> sipa - it type checks, so something is happening.
12:03:43 <jeff_s_> Maybe I'm doing something else wrong.
12:03:49 <sipa> then what is the problem?
12:04:02 <Eduard_Munteanu> @type (:)
12:04:03 <lambdabot> forall a. a -> [a] -> [a]
12:04:41 <jeff_s_> sipa - Let me make sure I'm doign this right before I make a big deal about it.
12:05:13 <nand`> you can't effectively pattern match against a polymorphic IsString instance because there's no (IsString s) => s -> String
12:05:21 <nand`> polytypic*
12:06:36 <rudyl313> how can I extract values from an aeson object?
12:06:37 <nand`> IsString is just a String -> a black box, you can only do any form of pattern matching or processing on them if you know a concrete underlying type
12:07:03 <jeff_s_> nand - it type checks and compiles, so I was expecting it to work. I'm double checking that it isn't.
12:07:18 <jeff_s_> Rdy1313 - pattern match on the Data.Aeson.Value type.
12:08:23 <jeff_s_> rudy1313 - Also, you'll probably need to use the Data.HashMap.Lazy and Data.Vector modules (from unordered-containers and vector packages)
12:09:09 <EvanR> is there a module to provide the wacky php data structure but in haskell? ;)
12:09:17 <EvanR> known as 'array'
12:09:32 <sipa> EvanR: do you like torture?
12:09:37 <EvanR> lol
12:11:34 <argiopeweb> I feel like I'm not using enumerators right. I've got a action I want to repeat from a continuous network stream, so I have a forever inside an enumSocket. Not surprisingly, it's building up (-> *) thunks like a champ. Anyone have some tips on where I could reference some code that does things the Right Way (TM)?
12:22:49 <jeff_s_> OK I discovered part of my problem - GHC is letting me use strings to pattern match on values having type Data.Aeson.Value.
12:22:55 <damo22> how would i write a list comprehension to give me the permutations of ["Hh", "eE", "Ll","Ll", "oO"] but the order matters, ie one from each place in that order?
12:23:25 <shachaf> damo22: Why do you want to use a list comprehension?
12:23:33 <shachaf> Also, what do you actually want to do?
12:23:40 <Botje> damo22: you mean you want different capitalizations of "hello" ?
12:23:46 <damo22> yes
12:23:54 <Botje> > take 10 (sequence ["Hh", "eE", "Ll","Ll", "oO"])
12:23:55 <lambdabot>   ["HeLLo","HeLLO","HeLlo","HeLlO","HelLo","HelLO","Hello","HellO","HELLo","H...
12:24:18 <damo22> wow
12:24:23 <shachaf> That has very little to do with permutations. :-)
12:24:47 <damo22> what does the 10 have to do with it?
12:24:53 <nand`> damo22: nothing
12:25:04 <argiopeweb> Keeps lambdabot from spamming chat.
12:25:07 <Botje> damo22: or you do something like [ [h,e,l,l',o] | h <- "Hh", e <- "Ee", ... ]
12:25:07 <overflow_0f8b> hello
12:25:08 <damo22> oh to prevent spamming
12:25:09 <nand`> > sequence ["Hh", "eE", "Ll", "Ll", "oO"]
12:25:10 <lambdabot>   ["HeLLo","HeLLO","HeLlo","HeLlO","HelLo","HelLO","Hello","HellO","HELLo","H...
12:26:40 <navaati> i'm *sure* there is something to do with arrows on this problem… something like "id *** toUpper"
12:26:46 <navaati> (or maybe &&&)
12:26:53 <navaati> :t (&&&)
12:26:54 <lambdabot> forall (a :: * -> * -> *) b c c'. (Arrow a) => a b c -> a b c' -> a b (c, c')
12:27:12 <navaati> :t (***)
12:27:13 <lambdabot> forall (a :: * -> * -> *) b c b' c'. (Arrow a) => a b c -> a b' c' -> a (b, b') (c, c')
12:27:15 <nand`> navaati: *** and so on are generally (a,a) and not [a,a]
12:27:36 <navaati> nand`: yeah, but that's not the point
12:27:37 <nand`> while “sequence” takes advantage of the monad property of []
12:27:46 <nand`> hmm
12:27:49 <nand`> wait
12:27:56 <nand`> :t uncurry (:)
12:27:57 <lambdabot> forall a. (a, [a]) -> [a]
12:29:58 <rudyl313> jeff_s_:  I have the following aeson object: Object (fromList [("response",Object (fromList [("total_row_count",Number 2),("data",Array (fromList [Object (fromList [("$distance",Number 301.6199),("name",String "Stand")]),Object (fromList [("$distance",Number 2452.9426),("name",String "Stand")])])),("included_rows",Number 0)])),("status",String "ok"),("version",Number 3)])
12:30:12 <rudyl313> jeff_s_: I want to pattern match to extract the "status"
12:30:21 <rudyl313> jeff_s_: can't seem to pull it off
12:30:35 <nand`> navaati: you can use applicatives though
12:30:57 <navaati> for sure, but i like arrows :D
12:30:59 * hackagebot MFlow 0.0.3 - (Web) application server. Stateful server processes. Simple, statically correct widget combinators.  http://hackage.haskell.org/package/MFlow-0.0.3 (AlbertoCorona)
12:31:03 <nand`> I do too, comrade
12:31:07 <nand`> I do too..
12:31:32 <navaati> (arrows are the now monads ™)
12:31:37 <navaati> s/now/new/
12:31:45 <Botje> I used to be a functional programmer like you, but I took an arrow to the knee ...
12:32:06 * Botje activates sneak mode and scuttles away
12:32:30 <heffaklump> god bless java
12:32:47 <sipa> you mean the island, right?
12:33:03 <heffaklump> nesting 2 for loops when you ahve a lot of things to do in each is a nightmare in haskell
12:33:04 <Botje> no silly, the coffee
12:33:39 <sipa> imperative programming in Java often wins from imperative programming in Haskell, yes :)
12:33:53 <damo22> @index getArgs
12:33:54 <lambdabot> System.Environment
12:34:38 <cmccann> not really, I'd still rather use Haskell for imperative programming
12:34:53 <navaati> the same
12:35:03 <Jafet> The dance
12:35:08 <sipa> i'd use C++ for imperative programming :)
12:35:20 <dainanaki> :O
12:35:28 * sipa ducks
12:35:45 <heffaklump> id rather use asm than haskell
12:35:52 <heffaklump> or maybe not
12:36:00 <cmccann> heffaklump, I suspect you are making things far more difficult than they need to be
12:36:09 <damo22> @index putStr
12:36:10 <lambdabot> System.IO, Prelude
12:36:50 <cmccann> heffaklump, given the code you pasted earlier I encourage you to actually learn how to use Haskell, not continue trying to awkwardly wedge non-Haskell code into Haskell
12:37:27 <cmccann> what you were doing there is very simple and very easy in Haskell, probably easier than it is in Java or Python to be honest
12:37:27 <navaati> oh… i thought it was a troll when he said god bless java…
12:38:21 <heffaklump> so i take a new strategy
12:38:39 <heffaklump> instead of trying to translate into imperative haskell code i try something else
12:38:50 <heffaklump> but thinking in folds is hard when you are not used to it
12:39:20 <sipa> it sure requires a different way of thinking
12:39:25 <damo22> haskell is cool for string manipulation and simple patterns
12:39:26 <heffaklump> any hint on what i could do?
12:39:51 <navaati> nand`: actually you were right, applicatives are The Right Way*
12:40:04 <Eduard_Munteanu> heffaklump: depends on the actual case I guess
12:40:08 <cmccann> heffaklump, to start with, what's your purpose here? is this homework for something?
12:40:12 <navaati> (i tried to use arrows and found myself using applucatives x)
12:40:55 <nand`> heffaklump: fold (fold ..) .. sounds like something I might try
12:40:58 <nand`> for nested loops
12:41:16 <navaati> loops ? never heard about that…
12:41:28 <nand`> “loops” are a fancy way of saying lists
12:41:34 <navaati> haha
12:41:47 <heffaklump> cmccann: nope just learning haskell on my own, thought it was interesting
12:41:47 <cmccann> nand`, or a special-purpose syntax for tail recursion, in other languages
12:41:59 <c_wraith> ok, here's my silly obfuscation of the day
12:41:59 <heffaklump> i know c,java,python,asm
12:42:00 <c_wraith> > sequence . map (flip map [ toLower, toUpper ] . flip id) $ "foo"
12:42:02 <lambdabot>   ["foo","foO","fOo","fOO","Foo","FoO","FOo","FOO"]
12:42:14 <cmccann> heffaklump, what are you learning from? something like LYAH?
12:42:32 <navaati> c_wraith: wow
12:42:36 <navaati> restecp
12:43:12 <hpc> @pl flip f . flip g
12:43:12 <lambdabot> flip f . flip g
12:43:18 <nand`> > let f = sequence . map caps; caps c = [c, toUpper c] in f "foo"
12:43:19 <lambdabot>   ["foo","foO","fOo","fOO","Foo","FoO","FOo","FOO"]
12:43:25 <hpc> :t flip ?f . flip ?g
12:43:25 <nand`> easier to udnerstand and also shorter by one keystroke
12:43:26 <lambdabot> forall (f :: * -> *) b (f1 :: * -> *) a b1. (?f::f (f1 b1 -> b), Functor f, ?g::f1 (a -> b1), Functor f1) => a -> f b
12:43:58 <c_wraith> nand`: not the same functionality.  Also, my point was obfuscation
12:44:23 <cmccann> c_wraith, which is why you didn't use mapM, right? :P
12:44:27 <navaati> what is this nasty '?' syntax ?
12:44:46 <c_wraith> oh.  heh, yes, mapM would have been better
12:44:56 <sipa> navaati: implicit arguments; ignore
12:44:57 <nand`> navaati: implicit parameters
12:45:04 <c_wraith> > mapM (flip map [ toLower, toUpper ] . flip id) $ "foo"
12:45:05 <lambdabot>   ["foo","foO","fOo","fOO","Foo","FoO","FOo","FOO"]
12:45:09 <heffaklump> > mapM print [[1,2,3],[4,5,6]]
12:45:10 <lambdabot>   <IO [()]>
12:45:26 <c_wraith> I wish there was for = flip map
12:45:27 <heffaklump> >1+2
12:45:37 <cmccann> need a space after >
12:45:39 <heffaklump> > :t flip
12:45:39 <lambdabot>   <no location info>: parse error on input `:'
12:45:40 <nand`> maybe “over”
12:45:46 <nand`> for flip map
12:45:46 <heffaklump> > 1+2
12:45:47 <lambdabot>   3
12:46:01 <hpc> navaati: implicit arguments can be used in lambdabot to say "what's the type of this subexpression?"
12:46:11 <heffaklump> > map flatten [[[1,2,3]],[[4,5,6]]]
12:46:12 <hpc> :t map ?f
12:46:12 <lambdabot>   Couldn't match expected type `Data.Tree.Tree a'
12:46:12 <lambdabot>         against inferred ty...
12:46:13 <lambdabot> forall a b. (?f::a -> b) => [a] -> [b]
12:46:28 <navaati> ah, clever
12:46:29 <cmccann> implicit params can be used to get GHC to tell you the type of a subexpression in general
12:46:32 <heffaklump> > map flatten [[[1,2,3],[4,5,6]]]
12:46:33 <lambdabot>   Couldn't match expected type `Data.Tree.Tree a'
12:46:34 <lambdabot>         against inferred ty...
12:46:37 <cmccann> as far as I know that's the only thing they're actually good for
12:46:42 <heffaklump> > flatten [[1,2,3],[4,5,6]]
12:46:43 <lambdabot>   Couldn't match expected type `Data.Tree.Tree a'
12:46:43 <lambdabot>         against inferred ty...
12:46:48 <hpc> also for dynamic scope
12:46:51 <heffaklump> > :t flatten
12:46:53 <lambdabot>   <no location info>: parse error on input `:'
12:46:59 <heffaklump> > t flatten
12:46:59 <hpc> but such witchcraft will get you burned
12:47:00 <lambdabot>   Couldn't match expected type `(Data.Tree.Tree a -> [a]) -> t'
12:47:00 <lambdabot>         again...
12:47:03 <tomprince> :t flatten
12:47:04 <lambdabot> forall a. Tree a -> [a]
12:47:16 <navaati> heffaklump: it ':t' without '>'
12:47:31 <cmccann> hpc, like I said, getting subexpression types are the only thing they're GOOD for :P
12:47:43 <hpc> lol :D
12:48:09 <tomprince> Appently also getting burned ...
12:48:43 <c_wraith> :t (. flip id)
12:48:44 <lambdabot> forall b a b1. (((a -> b1) -> b1) -> b) -> a -> b
12:49:17 <c_wraith> wtf.  that looks surprisingly similar to call/cc
12:49:19 <Flonk> How do you get a random element from a list?
12:49:46 <c_wraith> Flonk: with what distribution?
12:50:03 <Flonk> equal probability for each element
12:50:23 <c_wraith> Flonk: uniform distribution requires getting the length of the list, then picking a random number in the bounds of the list, then indexing that far in
12:50:28 <c_wraith> Which is ugly, but works
12:50:39 <heffaklump> whats the best way to get matrices?
12:50:46 <heffaklump> i dont have blas and lapack
12:50:47 <c_wraith> best in what sense?
12:51:00 <heffaklump> any other matrix package that is just an easy cabal install?
12:51:50 <c_wraith> :t callcc
12:51:51 <lambdabot> Not in scope: `callcc'
12:51:54 <c_wraith> :t callCC
12:51:55 <lambdabot> forall a (m :: * -> *) b. (MonadCont m) => ((a -> m b) -> m a) -> m a
12:52:07 <Flonk> c_wraith: fair enough - how do I generate a random number?
12:52:09 <navaati> heffaklump: repa
12:52:36 <navaati> Flonk: check System.Random
12:52:44 <Flonk> navaati: I will, thanks!
12:52:46 <heffaklump> repa?
12:52:53 <navaati> it's a lib
12:53:16 <DanBurton> @hackage repa
12:53:16 <lambdabot> http://hackage.haskell.org/package/repa
12:53:23 <navaati> a package that you can install easily, and which is good for matrix
12:53:28 <navaati> yeah, this one
12:54:29 <heffaklump>  cabal install math-functions-0.1.1.0
12:54:34 <heffaklump>  doesnt work in cygwin,why?
12:54:54 <DanBurton> by "doesn't work", what do you mean, exactly?
12:55:08 <navaati> WTF cygwin ? oh god…
12:55:29 * DanBurton uses VirtualBox and ubuntu
12:56:01 * hackagebot pandoc 1.9.0.5 - Conversion between markup formats  http://hackage.haskell.org/package/pandoc-1.9.0.5 (JohnMacFarlane)
12:56:22 <navaati> DanBurton: haha, didn't thought about this solution, it's maybe… less worse ^^
12:57:22 <heffaklump> $ cabal install repa-2.2.0.1
12:57:22 <heffaklump> Resolving dependencies...
12:57:22 <heffaklump> cabal.exe: cannot configure repa-2.2.0.1. It requires base ==4.4.*
12:57:22 <heffaklump> For the dependency on base ==4.4.* there are these packages: base-4.4.0.0 and
12:57:22 <heffaklump> base-4.4.1.0. However none of them are available.
12:57:22 <heffaklump> base-4.4.0.0 was excluded because of the top level dependency base -any
12:57:23 <heffaklump> base-4.4.1.0 was excluded because of the top level dependency base -any
12:57:25 <heffaklump> wtf?
12:57:27 <DanBurton> I actually just installed a fresh Ubuntu with xmonad and ghc 7.4.1. and trying out irssi :)
12:57:47 <navaati> heffaklump: don't do this, paste on pastebin
12:59:08 <DanBurton> heffaklump: welcome to cabal's dependency hell
12:59:58 <DanBurton> heffaklump: you can try installing older versions of repa and see if it works
13:00:07 <DanBurton> heffaklump: or upgrade your ghc
13:00:56 <heffaklump> i have latest ghc
13:01:12 <DanBurton> 7.4.1?
13:02:14 <DanBurton> heffaklump: what version of base do you have? ghc-pkg list base
13:02:44 <DanBurton> it actually might be that repa says it can't build on base-4.5.0.0
13:02:51 <DanBurton> even though its probably lying
13:03:05 <heffaklump> no it is shipping
13:03:14 <heffaklump> lets go home and watch dexter season 6
13:03:17 <tty7> is there another, more readable way to do things like e.g. [x | x <- someRange] ++ [-x | x <- someRange]
13:04:10 <DanBurton> tty7: someRange ++ map negate someRange
13:04:10 <cmccann> > (\x -> [x, -x]) =<< [1..4]
13:04:11 <lambdabot>   [1,-1,2,-2,3,-3,4,-4]
13:04:13 <tty7> i intuitively tried [x, -x | x <- someRange], but that seems not to work
13:04:15 <heffaklump> can i see all the operations in repa somehow?
13:04:43 <tty7> well, that x, -x thing is a bad example ;) in fact i have a little more complicated things.
13:04:48 <DanBurton> > do x <- [1..4]; [x,-x]
13:04:49 <lambdabot>   [1,-1,2,-2,3,-3,4,-4]
13:05:03 <tty7> but i will try one of those ways
13:05:05 <nand`> DanBurton: not the same output in this example
13:05:05 <tty7> thanks :)
13:05:16 <DanBurton> tty7: comprehensions aren't quite powerful enough
13:05:18 <cmccann> > [y | y <- [x, -x], x <- [1..4]]
13:05:19 <lambdabot>   [x,x,x,x,negate x,negate x,negate x,negate x]
13:05:28 <cmccann> er
13:05:33 <sipa> haha
13:05:46 <DanBurton> switch it around
13:05:56 <tty7> cmccann: that looks good, if it works ;)
13:05:57 <DanBurton> > [y | x <- [1..4], y <- [x, -x]]
13:05:58 <lambdabot>   [1,-1,2,-2,3,-3,4,-4]
13:05:58 <sipa> > [y,x <- [1..4], y <- [x,-x]]
13:05:59 <lambdabot>   <no location info>: parse error on input `<-'
13:06:01 <tty7> :)
13:06:05 <tty7> thanks!
13:06:07 <DanBurton> so I lied. comprehensions are powerful enough
13:06:11 * cmccann can never remember how fancier list comprehension syntax works
13:06:12 <DanBurton> but I usually prefer do notation
13:07:22 <tty7> > do x <- [1..4]; [x*3, x*2, -x]
13:07:22 <lambdabot>   [3,2,-1,6,4,-2,9,6,-3,12,8,-4]
13:07:29 <nand`> map f someRange ++ map g someRange also works
13:07:43 <nand`> if it's something like [f x | x <- someRange]
13:07:55 <nand`> which can be reduced further
13:08:14 <tty7> nand`: yeah, but i would like to avoid the ++
13:08:18 <nand`> (++) <$> map f <*> map g
13:08:37 <nand`> ah
13:08:39 <DanBurton> applicative on functions always weirds me out a little
13:08:41 <tty7> if its possible to map "a list to another", kind of, that would also be well
13:08:54 <cmccann> DanBurton, don't like the Reader monad?
13:09:05 <nand`> tty7: map always maps one list to another..
13:09:07 <cmccann> tty7, what do you mean?
13:09:12 <DanBurton> cmccann: I guess I just need to get more comfortable with it
13:09:23 <tty7> i mean a function with two lists
13:09:35 <cmccann> like a zip?
13:09:38 <sipa> tty7: can you give an example?
13:09:39 <cmccann> or zipWith
13:09:39 <tty7> to get a list like [x*y | x <- list1, y <- list2]
13:09:47 <nand`> zipWith (*) list1 list2
13:09:54 <nand`> wait no
13:09:56 <cmccann> > zipWith (*) [1..3] [1..3]
13:09:56 <lambdabot>   [1,4,9]
13:10:00 <tty7> somehow like a zip. but list1 and list2 may have different lengthes
13:10:01 <nand`> zip isn't like the comprehensions
13:10:08 <tty7> > zipWith (*) [1..3] [1..2]
13:10:08 <lambdabot>   [1,4]
13:10:18 <tty7> thats not quite what i mean
13:10:22 <cmccann> tty7, what do you want it to do if one is shorter?
13:10:24 <DanBurton> > [x*y | x <- [1..3], y <- [1..2]]
13:10:25 <lambdabot>   [1,2,2,4,3,6]
13:10:27 <nand`> (*) <$> [1..3] <*> [1..2]
13:10:29 <nand`> > (*) <$> [1..3] <*> [1..2]
13:10:30 <lambdabot>   [1,2,2,4,3,6]
13:10:37 <sipa> :t curry (*))
13:10:37 <DanBurton> dat applicative
13:10:38 <lambdabot> parse error on input `)'
13:10:38 <sipa> :t curry (*)
13:10:39 <lambdabot> forall a b. (Num a, Num b) => a -> b -> (a, b) -> (a, b)
13:10:40 <tty7> it should rather result in [1,2,4,3,6] or maybe [1,2,2,4,3,6]
13:10:52 <nand`> (*) and <*> don't mix well
13:10:59 <cmccann> tty7, oh, so you want every combination of arguments?
13:11:06 <nand`> > fmap (*) [1..3] `ap` [1..2]
13:11:07 <lambdabot>   [1,2,2,4,3,6]
13:11:19 <nand`> s/fmap/map/
13:11:20 <DanBurton> if you want them to be unique, you can also use Data.Set
13:11:25 <tty7> yep. like a cartesian product
13:11:33 * MostAwesomeDude wishes there was a better early-out flavor of the list monad
13:11:39 <cmccann> tty7, then list comprehensions should work
13:11:41 <tty7> i know. they are unique anyway in my case
13:11:43 <cmccann> or the above examples
13:11:43 <Axman6> does Data.Set have an applicative instance?
13:11:47 <nand`> >nub [1,2,2,4,3,6]
13:11:49 <DanBurton> MostAwesomeDude: "early-out"?
13:11:49 <nand`> > nub [1,2,2,4,3,6]
13:11:50 <lambdabot>   [1,2,4,3,6]
13:11:56 <cmccann> > (*) <$> [1..2] <*> [1..2]
13:11:57 <lambdabot>   [1,2,2,4]
13:12:02 <cmccann> > (*) <$> [1..2] <*> [1..3]
13:12:03 <lambdabot>   [1,2,3,2,4,6]
13:12:10 <MostAwesomeDude> DanBurton: For combinatorial situations.
13:12:18 <tty7> i know, nand`, the uniqueness is not important for now
13:12:40 <dylukes> Does anyone have any thoughts of how to make this a bit niceR?
13:12:41 <dylukes> conObj = uncurry ConObj <$ symbol "CON" <*> parens (con `tupleA` many atom)
13:12:41 <DanBurton> MostAwesomeDude: I'm sure someone has written a newtype monad instance for that
13:12:49 <cmccann> > [x * y | x <- [1..2], y <- [1..3]]
13:12:50 <lambdabot>   [1,2,3,2,4,6]
13:12:52 <dylukes> (where ConObj :: Con -> [Atom] -> Obj)
13:13:03 <dylukes> MostAwesomeDude: what do you man early out exactly?
13:13:17 <nand`> :t (*) (fromList [] :: Set Int)
13:13:18 <lambdabot> Not in scope: type constructor or class `Set'
13:13:32 <tty7> cmccann: yeah. i just wondered if there is a more efficient/readable/a quicker way of doing that. as the cartesian-product-like thing seems to be somehow common to me
13:13:34 <MostAwesomeDude> DanBurton: Well, there's a couple finite-domain solvers that do that sort of thing, but they're all just StateT []
13:13:55 <tty7> cmccann: if there is nothing, i will stick to list comprehensions in those cases, or the do notation for now.
13:14:04 * DanBurton just tried to cabal install cabal-dev for new ghc, ran into dependency conflicts >,<
13:14:11 <cmccann> tty7, if you want an n-ary cartesian product using lists it's easy
13:14:19 <cmccann> > sequence [[1..2], [1..3]]
13:14:20 <lambdabot>   [[1,1],[1,2],[1,3],[2,1],[2,2],[2,3]]
13:14:31 <MostAwesomeDude> dylukes: x <- [1..100]; y <- [1..100]; z <- [1..100] -- Does this *really* need a million iterations? :c
13:14:36 <cmccann> > sequence [[1..2], [1..3], [4,5]]
13:14:37 <lambdabot>   [[1,1,4],[1,1,5],[1,2,4],[1,2,5],[1,3,4],[1,3,5],[2,1,4],[2,1,5],[2,2,4],[2...
13:14:46 <tty7> hm, i see.
13:15:08 <cmccann> tty7, you can also use liftA2 &c.
13:15:16 <tty7> > map (\[x, y] -> x*y) sequence [[1..2], [1..3]]
13:15:17 <cmccann> > liftA2 (*) [1..2] [1..3]
13:15:17 <lambdabot>   Couldn't match expected type `[[t]]'
13:15:18 <lambdabot>         against inferred type `[m a] -...
13:15:18 <lambdabot>   [1,2,3,2,4,6]
13:15:49 <tty7> > map (\[x, y] -> [x*y]) sequence [[1..2], [1..3]]
13:15:49 <cmccann> > product <$> sequence [[1..2], [1..3], [4,5]]
13:15:50 <lambdabot>   Couldn't match expected type `[[t]]'
13:15:50 <lambdabot>         against inferred type `[m a] -...
13:15:50 <lambdabot>   can't find file: L.hs
13:16:38 <DanBurton> > map (\[x,y] -> x*y) $ sequence [[1..2],[1..3]]
13:16:39 <lambdabot>   [1,2,3,2,4,6]
13:16:48 <nand`> :t product
13:16:49 <lambdabot> forall a. (Num a) => [a] -> a
13:16:50 <tty7> > map (\[x, y] -> [x*y]) $ sequence [[1..2], [1..3]]
13:16:51 <lambdabot>   [[1],[2],[3],[2],[4],[6]]
13:16:58 <tty7> lol, thanks DanBurton
13:17:07 <tty7> > map (\[x, y] -> 3*x+2*y) $ sequence [[1..2], [1..3]]
13:17:08 <lambdabot>   [5,7,9,8,10,12]
13:17:13 <tty7> looks good as well
13:17:20 <DanBurton> fun with the list monad
13:17:23 <tty7> :)
13:17:24 <elliottt> is the sdist command for cabal-install broken for anyone else?
13:17:39 <nand`> @pl \[x, y] -> 3*x+2*y
13:17:40 <lambdabot> (line 1, column 2):
13:17:40 <lambdabot> unexpected "["
13:17:40 <lambdabot> expecting pattern
13:17:42 <rostayob> elliottt: it worked for me yesterday...
13:17:53 <nand`> @pl \([x, y]) -> 3*x+2*y
13:17:53 <lambdabot> (line 1, column 3):
13:17:53 <lambdabot> unexpected "["
13:17:54 <lambdabot> expecting pattern
13:17:54 <DanBurton> elliottt: version?
13:17:56 <nand`> huh
13:18:10 <elliottt> DanBurton: cabal-install version 0.10.2
13:18:10 <elliottt> using version 1.14.0 of the Cabal library
13:18:14 <nand`> @pl f [x,y] = 3*x + 2*y
13:18:14 <lambdabot> (line 1, column 9):
13:18:15 <lambdabot> unexpected "="
13:18:15 <lambdabot> expecting variable, "(", operator or end of input
13:18:25 <nand`> @pl f (x:y:[]) = 3*x + 2*y
13:18:26 <lambdabot> (line 1, column 12):
13:18:26 <lambdabot> unexpected "="
13:18:26 <lambdabot> expecting variable, "(", operator or end of input
13:18:27 <elliottt> i rebuilt with 7.4.1 today
13:18:30 <nand`> what am I missing
13:18:46 <DanBurton> elliottt: there is a newer version, cabal-install 0.13.3
13:18:51 <elliottt> ah ha
13:18:56 <elliottt> is that on hackage?
13:19:01 <DanBurton> elliottt: I don't recall
13:19:05 <tty7> @pl [x,y] -> 3*x+2*y
13:19:05 <lambdabot> (line 1, column 7):
13:19:05 <lambdabot> unexpected ">" or "-"
13:19:05 <lambdabot> expecting variable, "(", operator or end of input
13:19:14 <DanBurton> @hackage cabal-install
13:19:14 <lambdabot> http://hackage.haskell.org/package/cabal-install
13:19:17 <tty7> @pl \[x,y] -> 3*x+2*y
13:19:17 <lambdabot> (line 1, column 2):
13:19:17 <lambdabot> unexpected "["
13:19:18 <lambdabot> expecting pattern
13:19:23 <DanBurton> nope, not yet
13:19:26 <tty7> @pl \ [x,y] -> 3*x+2*y
13:19:26 <lambdabot> (line 1, column 3):
13:19:26 <sipa> @pl \x y -> 3*x+2*y
13:19:26 <lambdabot> unexpected "["
13:19:26 <lambdabot> expecting pattern
13:19:27 <lambdabot> (. (2 *)) . (+) . (3 *)
13:19:29 <nand`> @pl f x y = 3*x + 2*y
13:19:29 <lambdabot> f = (. (2 *)) . (+) . (3 *)
13:19:48 <elliottt> i noticed that there's a cabal-install-ghc72
13:19:49 <Jafet> sum . zipWith (*) [3,2]
13:19:52 <Flonk> :t flip
13:19:53 <lambdabot> forall (f :: * -> *) a b. (Functor f) => f (a -> b) -> a -> f b
13:20:09 <elliottt> does that build better with 7.4 as well?  i had to do some nasty things to the cabal file to make it build.
13:20:54 <ivanm> elliottt: ugh, I hate it when people make "temporary" versions of someone else's packages...
13:21:07 <elliottt> ah, so i should avoid it, then :)
13:21:10 <DanBurton> I got my cabal from the darcs repo, following these instructions: http://blog.jasonknight.us/2012/02/how-to-install-ghc-741-in-ubuntu-from.html
13:21:31 <elliottt> DanBurton: i'd rather install a released version.
13:21:34 <nand`> > flip [(+3), (*3)] 5
13:21:36 <lambdabot>   [8,15]
13:21:52 <elliottt> i'll check and make sure that i've not done something silly during sdist.
13:21:58 <nand`> neat, nice way to reduce map ($x)
13:21:58 <Axman6> I think i'm going to wait for a while before upgrading to 7.4. there seems to be a huge number of cabal problems
13:22:10 <elliottt> indeed there are.
13:22:40 <rostayob> yeah, but that's almost always the case.
13:22:47 <ivanm> Axman6: there always are with any new release of GHC
13:22:52 <rostayob> expecially since, following the PVP, people put upper bounds on base
13:23:01 <ivanm> didn't help that 7.2 used a snapshot release of Cabal
13:23:16 <elliottt> yeah, that sounds like it would create some problems.
13:25:38 <strager> How do I get the ghc flags `cabal build` spits out when linking?  I'm particularly interested in the -package-conf and -package-id options.
13:26:02 <elliottt> i keep getting this message when running cabal sdist: http://hpaste.org/57554
13:26:13 <strager> (I am linking a Haskell .a into a C++ executeable, and I need to know what libraries to link in.)
13:27:09 <rudyl313> how can I convert a String to a Data.Text.Internal.Text
13:27:13 <Axman6> Scriptor: use the debug flags to print out that info?
13:27:22 <ivanm> rudyl313: pack
13:27:22 <rudyl313> there seem to be no helper methods to do so
13:27:26 <Axman6> @hoogle String -> Text
13:27:26 <lambdabot> Data.Text.Lazy pack :: String -> Text
13:27:26 <lambdabot> Data.Text pack :: String -> Text
13:27:27 <lambdabot> Prelude read :: Read a => String -> a
13:27:36 <rudyl313> thanks!
13:27:36 <ivanm> or fromString if you want a better name
13:27:38 <Scriptor> Axman6: wrong s ;)
13:27:39 <ivanm> @type fromString
13:27:40 <lambdabot> Not in scope: `fromString'
13:27:52 <ivanm> what's the IsString method
13:27:54 <ivanm> ?
13:28:02 <shachaf> fromString
13:28:04 <ivanm> Scriptor: why is he wrong?
13:28:17 <tty7> > replicate 4 2
13:28:17 <Scriptor> ivanm: as in he autcompleted the wrong nick
13:28:18 <lambdabot>   [2,2,2,2]
13:28:18 <ivanm> shachaf: oh, I *was* right, lambdabot's hoogle just doesn't know about it
13:28:21 <Axman6> because hilighted the wrong person
13:28:32 <Axman6> i meant strager not Scriptor
13:28:39 <ivanm> Scriptor: oh, I thought you were referring to his @hoogle call
13:29:25 <strager> Axman6: I need to use it for scripting.
13:29:40 <strager> Axman6: And those values are hard-coded to my specific installed version.
13:32:53 <damo22> i have a problem with simple io from haskell, when i compile my program using ghc and run it, it seems to chew all my memory and eventually run out when it tries to "unlines" a large list of strings
13:34:33 <strager> How large?
13:34:47 <tty7> > elemIndex 'c' "abcde"
13:34:48 <lambdabot>   Just 2
13:34:48 <strager> Did you try isolating it to just the unlines call and run it in GHCi?
13:35:19 <tty7> huh. how to get the 2 "out of" the Maybe Int?
13:35:39 <tty7> to do thinks like (elemIndex 'c' "abcde") * 3 or such
13:35:49 <tty7> > (elemIndex 'c' "abcde") * 3
13:35:50 <lambdabot>   No instance for (GHC.Num.Num (Data.Maybe.Maybe GHC.Types.Int))
13:35:50 <lambdabot>    arising f...
13:36:10 <damo22> strager: i dont know how to isolate it
13:36:19 <tty7> > case (elemIndex 'c' "abcde") of Just x = x * 3; Nothing = 0
13:36:20 <lambdabot>   <no location info>: parse error on input `='
13:36:40 <tty7> > case (elemIndex 'c' "abcde") of (Just x = x * 3; Nothing = 0)
13:36:41 <lambdabot>   <no location info>: parse error on input `='
13:36:42 <strager> @hoogle MAybe Int -> Int
13:36:43 <lambdabot> Did you mean: Maybe Int -> Int
13:36:43 <lambdabot> Test.HUnit.Base ListItem :: Int -> Node
13:36:43 <lambdabot> Data.Time.Calendar gregorianMonthLength :: Integer -> Int -> Int
13:36:50 <Lemmih> tty7: s/=/->/
13:36:51 <strager> @hoogle Maybe Int -> Int
13:36:51 <lambdabot> Data.Maybe fromJust :: Maybe a -> a
13:36:51 <lambdabot> Test.HUnit.Base ListItem :: Int -> Node
13:36:52 <lambdabot> Data.Maybe fromMaybe :: a -> Maybe a -> a
13:37:01 <tty7> oops, thx Lemmih
13:37:04 <hey_lu> > (*) <$> Just 4 <*> Just 3
13:37:04 <lambdabot>   Just 12
13:37:07 <tty7> > case (elemIndex 'c' "abcde") of (Just x -> x * 3; Nothing -> 0)
13:37:08 <lambdabot>   <no location info>: parse error on input `;'
13:37:11 <strager> @hoogle Int -> Maybe Int -> Int
13:37:11 <lambdabot> Data.Maybe fromMaybe :: a -> Maybe a -> a
13:37:11 <lambdabot> Test.QuickCheck.State computeSize :: State -> Int -> Int -> Int
13:37:12 <lambdabot> Data.Time.Calendar.MonthDay monthAndDayToDayOfYear :: Bool -> Int -> Int -> Int
13:37:16 <hey_lu> tty7: See ^
13:37:59 <tty7> what's that <$> and <*> there, hey_lu?
13:38:02 <DanBurton> > (fromMaybe 3 Nothing, fromMaybe 3 (Just 4))
13:38:03 <lambdabot>   (3,4)
13:38:14 <hey_lu> > fmap (* 4) $ Just 3
13:38:15 <lambdabot>   Just 12
13:38:22 <strager> tty7: Applicative operators; <$> is fmap
13:38:31 <tty7> fromMaybe looks fine (:
13:38:43 <tty7> okay, thanks!
13:38:43 <hey_lu> tty: It's from Control.Applicative, lyah tells you what it means :)
13:39:18 <tty7> i am just going through lyah, hey_lu ;) but didn't reach that part so far
13:40:14 <hey_lu> tty7: heh, have fun! :)
13:40:38 <DanBurton> > fromMaybe 0 (elemIndex 'c' "abcde") * 3
13:40:38 <lambdabot>   6
13:41:09 <tty7> > last "abcdef"
13:41:10 <lambdabot>   'f'
13:46:38 <tty7> just another "syntactic sugar" question ;)
13:47:00 <tty7> is there another way for "abcdef" ++ ['g'] ++ "hijk"
13:47:22 <tty7> (where 'g' comes from a function of course, so i cannot do "g" instead of ['g'])
13:47:41 <Axman6> use 'g':"hijk"
13:48:00 <gwern> hm, is it legit for a CLI tool to have a short option like '-% n'?
13:48:03 <tty7> (and i mean in general, not only for String and Char, but [t] and t)
13:48:14 <damo22> strager: shit no wonder i ran out of memory i didnt realise my output was 235Gb
13:48:26 <Axman6> gwern: what's the tool? does -% represent the only percentage parameter?
13:48:27 <gwern> (% doesn't seem to need to be escaped anyway)
13:48:34 <gwern> Axman6: it would, yeah
13:48:43 <Axman6> seems fine and logical to me
13:48:48 <tty7> Axman6: that would be "abc" ++ ('d' : "efg") then. even worse than ['d'], regarding the parens
13:48:48 <Axman6> better than -p for ths same thing imo
13:49:12 <gwern> Axman6: well, -p is already going to -p/--prediction
13:49:24 <gwern> (alas, probability and prediction both start with 'p')
13:49:38 <tty7> > length "abc"
13:49:39 <lambdabot>   3
13:49:49 <tty7> > "abc" !! (length "abc")
13:49:50 <lambdabot>   *Exception: Prelude.(!!): index too large
13:49:51 <tty7> > "abc" !! (length "abc" - 1)
13:49:52 <lambdabot>   'c'
13:50:15 <ivanm> tty7: you don't need parens
13:50:23 <ivanm> > "abc" ++ 'd' : "efg"
13:50:25 <lambdabot>   "abcdefg"
13:50:31 <tty7> oh, cool :)
13:50:32 <tty7> thanks
13:51:11 <ivanm> tty7: so what happens when X crashes? :p
13:52:08 <ivanm> tty7: heh
13:54:25 <JoeyA> Before I go about writing one: has anyone made a variant of TChan that separates the send and receive ends into different types?
13:54:30 <stepcut> can someone runing GHC 7.4.1 release tell me if, cabal install categories, works? It fails under GHC 7.4 rc1..
13:54:47 <tty7> ivanm: that happens.
14:06:13 <tty7> [1..100] !! 99
14:06:16 <tty7> > [1..100] !! 99
14:06:16 <lambdabot>   100
14:06:38 <tty7> what the heck is that: main: Prelude.(!!): index too large
14:06:44 <tty7> oO ?
14:07:05 <ion> (!!) is only safe when applied to an infinite list.
14:07:06 <Axman6> you used an index that was too large...
14:07:15 <tty7> it shows the first 30 elements of the list, then the error
14:07:29 <tty7> the list should have way more elements (100 or so)
14:07:32 <Axman6> whats your point?
14:07:39 <tgeeky> should have gone with 31
14:07:42 <tgeeky> should have gone with 101
14:07:46 <tty7> the index was not to large
14:07:46 <Axman6> are you sure it has that many elements?
14:07:59 <tty7> ah, wait..
14:08:07 <magicman> > [1..100] !! 1
14:08:08 <lambdabot>   2
14:08:11 <tty7> its another list than the one i was think about, probably
14:11:17 <monochrom> remember to trust the computer more than yourself
14:11:52 <ion> –Skynet
14:12:04 <Palmik> Hmm, is there some nice standard way to this "mapM' f xs = xs >>= return . map f" and "foldM' f = foldl (liftM2 f)"?
14:12:35 <mauke> >>= return . is fmap
14:13:06 <ion> @type \f xs -> xs >>= return . map f
14:13:07 <lambdabot> forall (m :: * -> *) a b. (Monad m) => (a -> b) -> m [a] -> m [b]
14:13:33 <ion> @type \f -> fmap (map f)
14:13:34 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f [a] -> f [b]
14:13:43 <ion> @type fmap . fmap
14:13:44 <lambdabot> forall (f :: * -> *) a b (f1 :: * -> *). (Functor f, Functor f1) => (a -> b) -> f (f1 a) -> f (f1 b)
14:13:58 <ion> @type \f -> foldl (liftM2 f)
14:13:59 <lambdabot> forall a2 r (m :: * -> *). (Monad m) => (r -> a2 -> r) -> m r -> [m a2] -> m r
14:15:16 <Palmik> ion, I like your (map f) <$> thanks :)
14:15:56 <Palmik> it have not occured to me :)
14:16:41 <ion> Note that you’ll almost certainly want to use foldl' instead of foldl.
14:18:34 <Palmik> This is one of the cases (TH quoting) where it does not matter (much) I guess. But it definitely will not harm. :)
14:24:33 <damo22> i want to test if a string contains multiple chars in a row of the same case... i have a lookup table of pairs such as [('a',"aA"),('b',"bB")...
14:25:18 <argiopeweb> Code at http://hpaste.org/57556 has a pretty serious space leak associated with forever in an iterator. Would someone mind advising me as to a better way?
14:25:24 <Axman6> you could probably use groupBy
14:26:05 <donri> that lookup table is rather pointless given toUpper/toLower
14:27:04 <damo22> donri: but i want to add other features like other types of characters to match
14:27:36 <damo22> Axman6: groupBy is useful thanks
14:28:04 <monochrom> that table is in an inconvenient format
14:30:14 <monochrom> the job does not care that 'a' and 'A' are somehow related, etc. the job only cares that 'A', 'B', 'C'... are one equivalence class and 'a', 'b', 'c'... are another equivalence class
14:31:08 <Axman6> @hoogle isUpper
14:31:09 <lambdabot> Data.Char isUpper :: Char -> Bool
14:31:22 <Axman6> > filter isUpper ['\0'..]
14:31:23 <lambdabot>   "ABCDEFGHIJKLMNOPQRSTUVWXYZ\192\193\194\195\196\197\198\199\200\201\202\203...
14:31:35 <Axman6> > text $ filter isUpper ['\0'..]
14:31:36 <lambdabot>   ABCDEFGHIJKLMNOPQRSTUVWXYZ
14:31:44 <Axman6> hmm, lame
14:32:01 <damo22> ['A'..'Z']
14:32:15 <damo22> > ['A'..'Z']
14:32:16 <lambdabot>   "ABCDEFGHIJKLMNOPQRSTUVWXYZ"
14:32:18 <Axman6> @hoogle Char -> Bool
14:32:19 <lambdabot> Data.Char isAlpha :: Char -> Bool
14:32:19 <lambdabot> Data.Char isAlphaNum :: Char -> Bool
14:32:19 <lambdabot> Data.Char isAscii :: Char -> Bool
14:32:21 <Axman6> @more
14:32:27 <Axman6> @hoogle+
14:32:27 <lambdabot> Data.Char isAsciiLower :: Char -> Bool
14:32:27 <lambdabot> Data.Char isAsciiUpper :: Char -> Bool
14:32:27 <lambdabot> Data.Char isControl :: Char -> Bool
14:35:38 <ion> > groupBy (compare `on` generalCategory) "fooBARbaz"
14:35:39 <lambdabot>   Couldn't match expected type `GHC.Bool.Bool'
14:35:39 <lambdabot>         against inferred type ...
14:36:13 <monochrom> you want (==) `on` generalCategory
14:36:16 <ivanm> > groupBy ((==) `on` generalCategory) "fooBARbaz"
14:36:17 <lambdabot>   ["foo","BAR","baz"]
14:36:18 <ion> yeah
14:37:01 <magicman> :t generalCategory
14:37:02 <lambdabot> Char -> GeneralCategory
14:38:04 <Axman6> :t generalCategory
14:38:04 <lambdabot> Char -> GeneralCategory
14:38:09 <Axman6> bleh, lag
14:38:11 <ion> :t generalCategory -- me too!
14:38:12 <lambdabot> Char -> GeneralCategory
14:38:22 <Axman6> @src GeneralCategory
14:38:22 <lambdabot> Source not found. Sorry.
14:38:31 <Axman6> > generalCategory 'a'
14:38:31 <lambdabot>   LowercaseLetter
14:38:36 <Axman6> > generalCategory '0'
14:38:37 <lambdabot>   DecimalNumber
14:38:45 <Axman6> > generalCategory '\0'
14:38:46 <lambdabot>   Control
14:39:20 <magicman> > map generalCategory ",+.:{"
14:39:21 <lambdabot>   [OtherPunctuation,MathSymbol,OtherPunctuation,OtherPunctuation,OpenPunctuat...
14:39:33 <magicman> Neat.
14:39:58 <Axman6> > nub $ map generalCategory ['\0'..]
14:39:59 <lambdabot>   [Control,Space,OtherPunctuation,CurrencySymbol,OpenPunctuation,ClosePunctua...
14:40:01 <rwbarton> > [minBound .. maxBound] :: [GeneralCategory]
14:40:02 <lambdabot>   [UppercaseLetter,LowercaseLetter,TitlecaseLetter,ModifierLetter,OtherLetter...
14:40:23 <magicman> http://hackage.haskell.org/packages/archive/base/latest/doc/html/Data-Char.html#t:GeneralCategory
14:40:27 <magicman> There's lots of'em!
14:40:46 <ion> @hoogle Enum e => [e]
14:40:47 <lambdabot> Prelude enumFrom :: Enum a => a -> [a]
14:40:47 <lambdabot> Prelude enumFromThen :: Enum a => a -> a -> [a]
14:40:47 <lambdabot> Prelude enumFromTo :: Enum a => a -> a -> [a]
14:41:02 <ion> @hoogle (Enum e, Bounded e) => [e]
14:41:03 <lambdabot> Prelude enumFrom :: Enum a => a -> [a]
14:41:03 <lambdabot> Prelude maxBound :: Bounded a => a
14:41:03 <lambdabot> Prelude minBound :: Bounded a => a
14:41:25 <ion> I take it there’s no standard name for [minBound .. maxBound]?
14:41:57 <ivanm> ion: nope
14:41:59 <magicman> Not that I know of...
14:42:01 <monochrom> @type [minBound .. maxBound]
14:42:01 <ivanm> at least none I've found
14:42:02 <lambdabot> forall a. (Bounded a, Enum a) => [a]
14:42:16 <monochrom> it crosses two type classes
14:43:01 <Eduard_Munteanu> > enumFromTo minBound maxBound
14:43:02 <lambdabot>   [()]
14:43:14 <ivanm> I've found it useful for QC: arbitrary = oneof [minBound .. maxBound]
14:43:22 <ivanm> @type oneof [minBound .. maxBound]
14:43:23 <lambdabot> forall a. (Bounded (Gen a), Enum (Gen a)) => Gen a
14:43:36 <monochrom> perhaps QC has it
14:43:42 <ivanm> not that I could find
14:44:32 <ion> Hmm. Is enumFrom minBound guaranteed to be equivalent to enumFromTo minBound maxBound? I.e. are there (legal) types for which enumFrom wraps around?
14:44:49 <ivanm> Int ?
14:45:04 <magicman> > [maxbound ..] :: Int
14:45:04 <ivanm> > length $ enumFrom (minBound :: Int)
14:45:04 <lambdabot>   mueval-core: NotAllowed "These modules have not been loaded:\nL\n"
14:45:08 <lambdabot>   mueval-core: Time limit exceeded
14:45:09 <ivanm> heh
14:45:13 <ion> > [maxBound-5 ..] :: [Int]
14:45:14 <lambdabot>   [9223372036854775802,9223372036854775803,9223372036854775804,92233720368547...
14:45:17 <ion> > [maxBound-1 ..] :: [Int]
14:45:18 <lambdabot>   [9223372036854775806,9223372036854775807]
14:45:27 <ivanm> huh, guess not
14:45:51 <magicman> I don't think there's anything against defining them yourself.
14:46:17 <magicman> It would make sense for enumerating days to be able to say [Monday .. Friday] as well as [Friday .. Monday]
14:46:37 <ivanm> magicman: stupid instances? yeah
14:46:53 <ivanm> magicman: should that be then [F,M], or all the days reversed?
14:47:22 <magicman> I'd expect that to be all days between Friday and Monday, inclusive. [Friday, Saturday, Sunday, Monday]
14:47:29 <Axman6> hmm, Day has an awkward enum instance then
14:47:32 <ivanm> duh, forgot the weekend... >_>
14:47:40 <ivanm> not sure if that would work
14:47:46 <ivanm> since it goes via Int
14:47:51 <magicman> Axman6: Not sure if that's actually the case.
14:48:01 <magicman> But just saying that it's not complete nonsense.
14:48:02 <Axman6> because map toEnum [fromEnum Friday .. fromEnum Monday] /= [Friday .. Monday]
14:48:15 <ivanm> Axman6: that's what I was thinking of
14:48:28 * eviltwin_b seems to recall an endless thread on -cafe (or libraries?) some time back which touched on odd Enum instances while ranting about conflating enumerations and ranges
14:48:39 * eviltwin_b seems to recall an endless thread on -cafe (or libraries?) some time back which touched on odd Enum instances while ranting about conflating enumerations and ranges
14:48:40 <magicman> Oh, is that the Enum-law? Never mind, then :p
14:48:41 <ion> Ah, the documentation for Enum says “enumFrom and enumFromThen should be defined with an implicit bound”. That settles it.
14:48:46 <eviltwin_b> aaaaaaaaa
14:48:49 <eviltwin_b> stupid client
14:49:09 <ivanm> eviltwin_b: see, your *good* twin wouldn't have had this kind of problem... :p
14:49:31 <eviltwin_b> my good twin has the basic sense not to be on irc :p
14:49:50 <ivanm> heh
14:50:02 <ion> Is the twin_a goodtwin_a or eviltwin_a?
14:50:27 <Axman6> or just a
14:50:31 <Axman6> or b
14:50:33 <shlevy> > pl f x = g x x
14:50:34 <lambdabot>   <no location info>: parse error on input `='
14:50:40 <monochrom> it is @pl
14:50:47 <shlevy> @pl f x = g x x
14:50:48 <lambdabot> f = join g
14:50:59 <damo22> > not ==
14:51:00 <lambdabot>   <no location info>: parse error (possibly incorrect indentation)
14:51:06 * hackagebot xturtle 0.0.10 - turtle like LOGO  http://hackage.haskell.org/package/xturtle-0.0.10 (YoshikuniJujo)
14:51:21 <monochrom> "not ==" suffers from english and/or cobol
14:51:25 <Axman6> damo22: that doesn't make any sense
14:51:41 <damo22> what is the symbol for !=
14:51:43 <monochrom> however, there is /= for your enjoyment
14:51:47 <Axman6> /=
14:51:51 <damo22> thank god
14:52:18 <Axman6> @hoogle Eq a => a -> a -> Bool
14:52:19 <lambdabot> Prelude (/=) :: Eq a => a -> a -> Bool
14:52:19 <lambdabot> Data.Eq (/=) :: Eq a => a -> a -> Bool
14:52:19 <lambdabot> Prelude (==) :: Eq a => a -> a -> Bool
14:54:47 <ion> @check \a b -> fromEnum (a /= b) == (fromEnum a `Data.Bits.xor` fromEnum b)
14:54:48 <lambdabot>   "OK, passed 500 tests."
14:54:48 <shlevy> Where is "join" defined?
14:55:06 <damo22> @index toLower
14:55:06 <lambdabot> Data.Char
14:55:19 <shlevy> @index join
14:55:20 <lambdabot> Control.Monad, Control.Monad.Reader, Control.Monad.Writer, Control.Monad.State, Control.Monad.RWS, Control.Monad.Identity, Control.Monad.Cont, Control.Monad.Error, Control.Monad.List
14:55:29 <ivanm> @src join
14:55:30 <lambdabot> join x =  x >>= id
14:55:37 <shlevy> Hmm... My example had nothing to do with monads though
14:55:39 <shlevy> @pl f x = g x x
14:55:39 <lambdabot> f = join g
14:55:45 <ion> shlevy: http://heh.fi/haskell/functors/#function-instance
14:55:49 <alpounet> shlevy, technically, you have a join for every monad instance
14:56:06 <alpounet> yours apply to a monad instance related to functions
14:56:09 <shlevy> Ah, didn't realize -> was a monad
14:56:13 <ion> join :: Monad m => m (m a) -> m a
14:56:19 <alpounet> well, (->) a is, for some type a
14:56:24 <ion> For the Monad (r ->) instance,
14:56:39 <ion> join :: (r -> (r -> a)) -> (r -> a)
14:56:48 <ion> @djinn (r -> (r -> a)) -> (r -> a)
14:56:48 <alpounet> that is, "all the functions taking an 'a'"
14:56:49 <lambdabot> f a b = a b b
14:57:09 <ivanm> > join (*) 3
14:57:10 <lambdabot>   9
14:57:21 <Eduard_Munteanu> shlevy: it's also a known/popular Monad
14:57:50 <Eduard_Munteanu> 'r' is a hint :)
15:01:06 * hackagebot http-proxy 0.0.7 - A library for writing HTTP and HTTPS proxies  http://hackage.haskell.org/package/http-proxy-0.0.7 (ErikDeCastroLopo)
15:02:23 <Sgeo> :t not . (==)
15:02:24 <lambdabot>     Couldn't match expected type `Bool'
15:02:24 <lambdabot>            against inferred type `a -> Bool'
15:02:24 <lambdabot>     Probable cause: `==' is applied to too few arguments
15:02:28 <Sgeo> Blargh
15:02:33 <Sgeo> :t not .: (==)
15:02:34 <lambdabot> forall a. (Eq a) => a -> a -> Bool
15:02:39 <Sgeo> That is what I was afraid of
15:02:44 <Sgeo> I don't quite understand .:
15:03:18 <Sgeo> It's for... joining two functions, where a function at the top takes two arguments?
15:03:41 <elliott> (f .: g) x y = f (g x y)
15:03:51 <elliott> Compare (f . g) x y = f (g x) y
15:03:52 <ion> http://bm380.user.srcf.net/cgi-bin/stepeval.cgi?expr=%28%28.%29.%28.%29%29+not+%28%3D%3D%29+a+b
15:05:24 <Sgeo> That makes me think .: doesn't chain
15:05:43 <Sgeo> . for all but the last ?
15:06:03 <Sgeo> So that it's one value being passed along, so to speak, which is the result of a 2-arg function?
15:06:04 <ion> > (not .: (not .: (==)) 42 43
15:06:05 <lambdabot>   <no location info>: parse error (possibly incorrect indentation)
15:06:09 <ion> > (not .: (not .: (==))) 42 43
15:06:11 <lambdabot>   False
15:06:21 <Sgeo> Oh
15:06:22 <ion> > ((not . not) .: (==)) 42 43
15:06:23 <lambdabot>   False
15:06:49 <ion> I dislike that lack of symmetry.
15:09:11 <ion> > (not . not .: (==)) 42 43
15:09:12 <lambdabot>   Couldn't match expected type `t1 -> t'
15:09:12 <lambdabot>         against inferred type `GHC.B...
15:09:16 <ion> > (not .: not .: (==)) 42 43
15:09:18 <lambdabot>   False
15:16:22 <VisionIncision> HI all, I am just starting out with Haskell as an undergrad CS student. What would you say its advantages were over say Java or C++?
15:17:00 <Axman6> it doesn't teach you that OOP nonsense
15:17:26 <VisionIncision> Ok, in your opinion why is OOP bad?
15:17:48 <Axman6> there are others here who can articulate it more clearly than I can
15:17:55 <VisionIncision> ok
15:18:00 <VisionIncision> thanks anyway
15:18:18 <elliott> VisionIncision: it's almost unlike java and c++ in basically every way
15:18:23 <ivanm> VisionIncision: Haskell teaches you good habits that cross to other languages
15:18:23 <Axman6> but you get taught the important of things like purity, elegance, abstraction much better than either C++ or Java
15:18:24 <elliott> (except for being pretty fast)
15:18:29 <ivanm> (e.g. separation of concerns)
15:18:34 <elliott> VisionIncision: this is, I feel, a major advantage, as there is almost nothing good about Java and C++
15:18:39 <ivanm> elliott: and being based upon English
15:18:43 <tromp__> haskell is pure fun
15:19:01 <elliott> ivanm: I dunno -- that C++ jargon can be pretty obscure ;)
15:19:05 <ivanm> heh
15:19:37 <ivanm> VisionIncision: also, a lot of Haskell features are being taken into other languages (not necessarily from Haskell itself, but stuff that Haskell has)
15:19:57 <ivanm> Haskell is also the only language that forces you to use STM properly :p
15:20:38 <ion> Learning Haskell certainly makes you a better programmer in every other language, too. But of course, that applies to every other (more or less) sane language, too.
15:20:54 <ivanm> ion: which other languages do you classify as "sane"?
15:20:58 <elliott> I prefer learning languages that make me worse at programming in others.
15:21:05 <Axman6> C++ and Java are not members of the set of sane languages either
15:21:07 <Axman6> >_>
15:21:11 <elliott> It's a lot more interesting.
15:21:45 <VisionIncision> Ah ok, well I keep reading articles that say Haskell improves your programming practice. What aspects of Haskell aid this?
15:21:58 <ivanm> VisionIncision: you get used to doing separation of concerns
15:22:06 <ivanm> splitting up functions into smaller, more manageable bits
15:22:24 <elliott> VisionIncision: It's not really "individual factors" so much as the entire structure of the language.
15:22:41 <ivanm> usage of higher order functions as control features
15:22:42 <ivanm> etc.
15:22:49 <ivanm> basically, what elliott said :p
15:22:53 <elliott> VisionIncision: The purely functional structure of Haskell strongly encourages structuring programs in well-defined, composable ways, and also makes it a lot easier than in other languages.
15:23:08 <Axman6> VisionIncision: you can't just print something in the middle of a function, or modify a variable. and it's actions like these which are a cause of a huge range of bugs in most other languages
15:23:41 <ion> For instance, separating pure code from impure code was something i knew would make sense to do, but no language i happened to learn before Haskell really pushed you toward doing that and it never became a practice for me before Haskell. Upon learning Haskell it became easy to do in any other language, too.
15:24:09 <VisionIncision> Ah ok, so would it be correct to say that each operation (such as printing to terminal) would be a well defined function?
15:24:09 <ivanm> and no implicit type coercion either
15:24:36 <elliott> VisionIncision: Depends what you mean by "well-defined function".
15:24:39 <Axman6> not really...
15:24:55 <Axman6> printing anything is not a function
15:24:55 <elliott> putStrLn is not really any more well-defined than <your favourite language's print function>. But it exists in a more well-defined context (the IO monad).
15:25:32 <VisionIncision> I think the best way for me to understand it is to use the language.
15:25:40 <Axman6> @where lyah
15:25:40 <lambdabot> http://www.learnyouahaskell.com/
15:25:45 <VisionIncision> I am going to order Learn You a Haskell
15:25:45 <ivanm> VisionIncision: yup!
15:25:48 <Axman6> go there, get started
15:25:55 <elliott> VisionIncision: it's available free online, btw
15:25:59 <VisionIncision> ahh, just as you sent that i said about the book
15:26:00 <elliott> if you don't need dead tree form
15:26:07 <Axman6> VisionIncision: good, but you can get started online for free too (buy the book though)
15:26:17 <ivanm> or get an eBook
15:26:20 <tromp__> i bought LYAH but still read most online, because the pics look much better in color:)
15:26:37 <ion> “I only read LYAH for the pictures.”
15:26:39 <ivanm> I bought LYAH but have never touched it... leant it to my brother though
15:26:41 <ivanm> ion: heh
15:27:01 <tromp__> i'm trying to get my wife to read it
15:27:25 <elliott> tromp__: huh, it somehow escaped my imagination that the pictures wouldn't be in colour
15:27:29 <elliott> terrible :(
15:27:41 <tromp__> yes, that was kind of a bummer when receiving the book
15:27:59 <tromp__> they're just greyscale
15:28:02 <ion> ivanm: What i meant earlier was that learning insane languages is less likely to teach you practices that make you a better programmer in all languages. I’ll let everyone make their own opinion about what those languages are. :-)
15:28:09 <tromp__> laters...
15:28:11 <ivanm> ion: I knew what you meant
15:28:18 <ivanm> I was asking what *you* considered sane! ;)
15:28:48 <VisionIncision> tromp_: what does your wife do? I keep trying to get my girlfriend to learn to program.... futile!
15:28:58 <VisionIncision> Thanks for all the input everybody.
15:29:19 <BlastHardcheese> lol women
15:29:50 <VisionIncision> lol, i think she would be good at it as well!!
15:29:55 <VisionIncision> never mind
15:30:26 <ion> ivanm: Well, Haskell for one is quite sane. That statement probably won’t start a huge language war on this channel. :-P
15:31:38 <BMeph> ion: "Insane languages," a la Dave Barbour? ;)
15:31:42 <Axman6> imo, C is pretty sane. it's relatively small and powerful
15:32:14 <VisionIncision> Fortran anyone??
15:32:20 <CodeWeaverX> Intercal.
15:34:24 <Axman6> fortran is a pretty ugly language. not sure about its sanity. it has some nice parts when compared with C though
15:35:16 <BMeph> ion: "Insane Language - def. A language where you can say the same thing over and over again and, each time, get different results."
15:35:17 <ivanm> Axman6: I quite like Fortran90+
15:36:01 <ion> bmeph: http://esoteric.voxelperfect.net/wiki/Entropy
15:38:18 <Axman6> c++; c++; c++; c++; c++; c++;
15:39:04 <ivanm> Axman6: stop giving it karma! :p
15:40:01 <elliott> preflex: karma c
15:40:01 <preflex>  c: 182547
15:40:06 <elliott> c-- c-- c-- c-- c-- c-- c-- c-- c-- c-- c-- c-- c-- c-- c-- c-- c-- c-- c-- c-- c-- c-- c-- c-- c-- c-- c-- c-- c-- c-- c-- c-- c-- c-- c-- c-- c-- c-- c-- c-- c-- c-- c-- c--
15:40:08 <elliott> preflex: karma c
15:40:08 <preflex>  c: 182503
15:40:16 <elliott> excellent.
15:40:52 <mauke> preflex: karma notepad
15:40:52 <preflex>  notepad: 3640
15:41:09 <nand`> haha
15:41:13 <MostAwesomeDude> preflex: karma MostAwesomeDude
15:41:14 <preflex>  MostAwesomeDude has no karma
15:41:15 <MostAwesomeDude> :c
15:41:37 <monochrom> @karma c
15:41:37 <lambdabot> c has a karma of 0
15:41:53 <ivanm> so, lambdabot is smarter about karma than preflex?
15:41:54 <monochrom> congratulations
15:42:02 <elliott> ivanm: dumber! special cases :(
15:42:24 <mauke> preflex: karma i
15:42:24 <preflex>  i: 2157
15:42:25 <monochrom> no, dumber. lambdabot keeps forgetting data, not persistent across reboots, that's why
15:42:34 <monochrom> @karma monochrom
15:42:35 <lambdabot> You have a karma of 9
15:42:43 <monochrom> @karma dons
15:42:43 <lambdabot> dons has a karma of 1
15:42:47 <monochrom> see?
15:42:49 <ivanm> :o
15:42:51 <mauke> preflex: karma dons
15:42:51 <preflex>  dons: 40
15:43:00 <ivanm> oh, gwern doesn't go around @flush'ing that much anymore?
15:43:20 <elliott> @flush
15:43:20 <lambdabot> Not enough privileges
15:43:22 <elliott> :(
15:43:26 <elliott> @admin + elliott
15:43:26 <lambdabot> Not enough privileges
15:43:27 <monochrom> it is really a program flaw that some human has to flush all the time
15:43:41 <elliott> lambdabot? flawed?
15:43:43 <elliott> You must be kidding.
15:43:47 <monochrom> haha
15:44:04 <ivanm> @vixen are you flawed?
15:44:04 <lambdabot> Your boys will be home for Christmas.
15:44:09 <monochrom> well yeah, she got a 2nd interview at the Pentagon, can't be that bad eh?
15:44:12 <ivanm> that's nice, but I don't have any...
15:44:50 <monochrom> that's spelling-corrected to @nixon
15:45:48 <mauke> @flosh
15:46:02 <elliott> @flash
15:46:02 <lambdabot> Not enough privileges
15:46:07 * hackagebot zlib 0.5.3.3 - Compression and decompression in the gzip and zlib formats  http://hackage.haskell.org/package/zlib-0.5.3.3 (DuncanCoutts)
15:46:09 * hackagebot bzlib 0.5.0.3 - Compression and decompression in the bzip2 format  http://hackage.haskell.org/package/bzlib-0.5.0.3 (DuncanCoutts)
15:46:50 <ivanm> monochrom: oh? I thought vixen was the chat plugin
15:46:51 <mauke> what's so hard about keeping persistent state?
15:47:32 <monochrom> the @vixen plugin is disabled
15:47:39 <ivanm> oh? why?
15:47:45 <elliott> we swapped it for nixon
15:47:48 <elliott> @nixon
15:47:49 <lambdabot> They're not like us. They smell different, they look different, they act different.  The trouble is, you can't find one that's honest.
15:48:05 <otters> arabs?
15:48:13 <mauke> preflex connects to a sqlite db and sends like three queries for each line said
15:48:53 <monochrom> what's so hard about persistence: answer: the old mindset that state should not be saved until the human says save
15:49:30 <ion> @flash gordon
15:49:31 <lambdabot> Not enough privileges
15:49:39 <lpsmith> there is not alternative instance for either?  :-(
15:49:51 <lpsmith> or is there an orphaned instance I'm not importing?
15:52:32 <lpsmith> otters, arabs would be anachronistic
15:53:05 <lpsmith> My guess would be hippies, communistists,  or Russians.
15:55:13 <lpsmith> Ok,  Italians.  I didn't see that one coming.
15:56:42 <elliott> @nixon sure is educational!
15:56:42 <lambdabot> I played by the rules of politics as I found them.
15:57:34 <Axman6> so, what do people think of the idea of having things like the Get monads in Cereal and Binary being based on attoparsec? means that all binary/cereal encoded data can be turned into an iteratee/enumeratee/conduit easily, and should remove a lot of redundant code
15:58:38 <lpsmith> if that doesn't slow down things too much,  that might not be a bad idea
15:58:41 <ivanm> Axman6: as in duplication of the parsers?
15:58:45 <elliott> It would be nice if e.g. attoparsec and blaze-builder got more unified interfaces.
15:58:50 <elliott> Then we could do away with serialisation libraries entirely.
15:58:52 <ivanm> or having binary/cereal dep on attoparsec?
15:58:58 <elliott> (Assuming attoparsec is fast enough, which I'm not sure it is.)
15:59:03 <ivanm> elliott: blaze's builder is in bytestring-0.10
15:59:09 <elliott> ivanm: right
15:59:13 <Axman6> elliott: indeed, that was my thought too
15:59:14 <elliott> point still stands
15:59:25 <elliott> Axman6: I don't think binary/cereal do any kind of backtracking at all, for instance
15:59:32 <elliott> so they're "parsers" only in a very loose sense
15:59:36 <Axman6> i also liked the idea of having ByteString being based on Vector Word8, but not sure that idea's gone anywhere
15:59:39 <ivanm> thing is, we don't have an alternative builder (since no-one uses the one in binary AFAIK)
15:59:49 <ivanm> but there are alternative parsers available
15:59:49 <elliott> Axman6: see vector-bytestring package or something
16:00:06 <ivanm> Axman6: I think it was slower than bytestring in some use cases, so it's unlikely to be the default
16:00:12 <Axman6> elliott: indeed, but by using attoparsec, we get a lot for free that the Get monads currently don't offer
16:00:14 <elliott> I believe it's still being workedo n
16:00:15 <elliott> *worked on
16:00:21 <elliott> Axman6: yes, like slowness :)
16:00:52 <lpsmith> well, the builder in bytestring 0.10 is revamped in a number of ways
16:00:54 <Axman6> attoparsec is not known for being slow...
16:00:58 <lpsmith> It looks better
16:01:21 <ivanm> lpsmith: than? I thought they were just merging in parts of blaze-builder
16:01:22 <elliott> Axman6: For a parser, sure, but backtracking and all that has /some/ overhead.
16:01:38 <ivanm> yeah, that's why kolmodin recently wrote the binary-bits package
16:01:39 <Axman6> it will likely be slower than the current get monads, but that's just a matter of optimising attoparsec
16:01:49 <ivanm> as in some use cases it out-performs the default Get monad
16:02:04 <statusfailed> Hey, fancy that, I just finish my parser and attoparsec is the topic :D
16:02:10 <ivanm> Axman6: use trifecta's applicative instance?
16:02:16 <elliott> Axman6: Say, optimising it by writing an alternate version for parsers that don't need backtracking.
16:02:21 <elliott> Leaving us with... cereal.
16:02:25 <ion> statusfailed: Yet Another Parser™? :-)
16:02:28 <Axman6> elliott: exactly what i was thinking
16:02:29 <elliott> (like the Zepto module)
16:02:32 <statusfailed> ion: indeed :p
16:02:36 <statusfailed> ion: for ARFF files :D
16:02:40 <otters> good old SI prefixs
16:02:42 <otters> prefixes
16:02:43 <statusfailed> (already exists >_>)
16:02:45 <elliott> Axman6: Well, "rename cereal to attoparsec" is an interesting proposal :P
16:02:46 <otters> shouldn't it be prefices?
16:02:48 <Axman6> elliott: well no, because we don't get partial parses
16:02:59 <elliott> otters: http://en.wiktionary.org/wiki/prefices
16:03:02 <Axman6> attoparsec can tell you when it demands more input
16:03:06 <ion> Ah, a specific parser, not a DSL for parsing.
16:03:11 <Axman6> the Get monads have to have all the data availab;le
16:03:14 <otters> (nonstandard)
16:03:16 <elliott> Axman6: Right.
16:03:34 <statusfailed> Partial _ is the bane of my debugging existence~
16:03:47 <Axman6> which means that you cannot use the Get monads in iteratee like things which are not guaranteed to give you all the data
16:04:13 <Axman6> and i see no reason why that shouldn't be available
16:05:13 <elliott> Axman6: well, because it has overhead :P
16:05:24 <elliott> but i agree, it would be nice
16:06:16 <Axman6> i don't see why there can't be a function to evaluate an attoparsec parser without backtracking if it's not present
16:06:27 <Axman6> just chuck an error if someone uses try or <|>
16:07:08 <ivanm> maybe you should just ask bos? :p
16:07:17 <elliott> Axman6: try = id
16:07:25 <elliott> so here's your implementation: const undefined
16:07:43 <lpsmith> erg,  no MonadPlus instance for (Either e) either
16:08:19 <elliott> lpsmith: Control.Monad.Error
16:08:20 <elliott> i think
16:12:13 <lpsmith> elliott, yes,  but unfortunately that has a Error constraint on the instance,  but that doesn't matter for my purposes
16:13:16 <lpsmith> oh
16:13:21 <elliott> no
16:13:23 <elliott> that's ErrorT
16:13:33 <elliott> Control.Monad.Error has the orphans
16:13:38 <lpsmith> I suppose you do need the "noMsg" for the empty
16:14:38 <lpsmith> elliott, no, the instances are in Control.Monad.Error
16:14:46 <elliott> isn't that what I said?
16:14:52 <lpsmith> err
16:14:58 <elliott> but, oh, yes, for Alternative you need Error
16:15:03 <lpsmith> elliott, no, the instances are in Control.Monad.Trans.Error  =)
16:15:20 <lpsmith> right,  because Alternative has a indentity element
16:16:05 <c_wraith> the element that indents?
16:16:37 <lpsmith> yup :D
16:17:24 <irene-knapp> haha
16:20:37 <lpsmith> ivanm, the builder to be included in bytestring duplicates the same basic interface, but the lower-level interface has been revamped
16:21:02 <lpsmith> like,  all the Write monad stuff has changed
16:29:04 <monochrom> @poll-list
16:29:05 <lambdabot> ["ConfusedWithVixenSituation","best-programming-language","food","naming","president","remove@src","sleep"]
16:29:10 <monochrom> heh, still there
16:32:52 <nyingen> debate continues to rage on -cafe about whether to repurpose the dot operator for record field access
16:33:27 <edwardk> gah
16:33:50 <edwardk> the cafe traffic on the topic has become just so much ineffectual noise
16:33:58 <nyingen> I don't understand the fixation some people have on this bit of syntax
16:34:14 <edwardk> a whole lot of people with strong opinions and none of the clout or ability to make anything happen
16:35:02 <edwardk> another overloading on . would be fine
16:35:28 <edwardk> and less scary than any of these unicode-the-world alternatives
16:35:48 <elliott> edwardk++
16:35:54 <elliott> re cafe
16:35:56 <Eduard_Munteanu> Like the unicode o for (.)? :)
16:36:02 <ivanm> lpsmith: presumably for the better?
16:36:19 <elliott> but it's been like that for months at the very least.
16:36:32 <elliott> (cafe in general :P)
16:36:56 <edwardk> elliott: yeah i made the mistake of commenting on it when it was relatively fresh, so gmail insists on showing me each and every nugget of wisdom that has been posted in that thread
16:37:14 <elliott> heh
16:37:27 <irene-knapp> you can surely turn that off
16:37:34 <Eduard_Munteanu> edwardk: don't you just move list traffic to another gmail folder?
16:37:36 <edwardk> I rather admire SPJ's ability to tune out the world some times ;)
16:37:57 <Eduard_Munteanu> Or are you cc-ed on it?
16:38:04 <edwardk> Eduard_Munteanu: i do, but then i let gmail show me 'important' stuff, which typically consists of any traffic from any of my lists that i happened to talk in
16:38:08 <ivanm> Eduard_Munteanu: even with CC-ing, the filtering should work
16:38:14 <irene-knapp> important is trainable
16:38:26 <irene-knapp> slowly
16:38:30 <ivanm> edwardk: eh, I used to use that on my android, then it stopped working/syncing :s
16:38:34 <irene-knapp> or at least, if it's not, I've been wasting my efforts trying to train it
16:38:40 <edwardk> yes, but i think you over estimate my level of interest in the topic, even to the point of turning it off ;)
16:38:51 <Eduard_Munteanu> Heh.
16:38:51 <irene-knapp> I guess I have no actual evidence that it is though :)
16:38:57 <edwardk> hah
16:39:12 <gwern> http://hackage.haskell.org/package/statistics <-- anyone know why all the tests are nonparametric?
16:39:46 <edwardk> google woud have a LOT of backed up training data on me that indicates i _do_ like it to keep my replied threads in that box though, and i'm not sure i'd like the consequences if it just silently started droping them
16:39:56 <ivanm> gwern: because the ones that are implemented are non-parametric?
16:40:02 <ivanm> and patches are probably accepted
16:40:02 <irene-knapp> ah, fair enough
16:40:30 <edwardk> gwern: you want them to be polymorphic in the choice of numeric type?
16:40:31 <ivanm> gwern: though chi-squared isn't non-parametric, is it?
16:40:33 <gwern> ivanm: I was wondering if there was some deep reason like 'an ordinary t test of normally distributed stuff is *trivial*, we need to work on the nonparametric stuff!'
16:40:35 <irene-knapp> well, I guess you'll just have to continue soldiering on, receiving emails that you don't want to receive but claiming you don't care :)
16:40:47 <ivanm> gwern: heh
16:40:54 <ivanm> my guess is that that's what bos wanted for criterion
16:40:54 <edwardk> oh that
16:41:18 <gwern> edwardk: well, it's more like 'I'm ignorant of statistics and it'd be nice if there were some haskell function which can analyze my sleep data for me'
16:41:26 <edwardk> ah
16:41:39 <gwern> 'didn't bos have a big statistics package? I should check that!'
16:41:42 <ivanm> @hoogle analyseSleepData
16:41:43 <lambdabot> No results found
16:41:45 <ivanm> awwww
16:41:45 <ivanm> ;)
16:41:54 <irene-knapp> @hoogle analyze
16:41:55 <lambdabot> No results found
16:41:55 <ion> Well, certainly
16:41:58 <ion> @hoogle analyzeSleepData
16:41:58 <lambdabot> No results found
16:42:04 <edwardk> btw_ http://hackage.haskell.org/packages/archive/statistics/0.10.1.0/doc/html/Statistics-Distribution-StudentT.html
16:42:06 <edwardk> =)
16:42:19 <irene-knapp> ?. dare I ask ....
16:42:19 <lambdabot> Plugin `compose' failed with: Unknown command: "dare"
16:42:32 <gwern> hm, I don't think chi-squared is what I want, I'm pretty sure my sleep data is distributed normally, I'm more interested in whether two sets of data are significantly different
16:42:36 <irene-knapp> ?nixon
16:42:36 <lambdabot> When the President does it, that means that it is not illegal.
16:42:55 <irene-knapp> why is it accepting my UTF8 ellipsis as an at-sign?
16:42:55 <gwern> edwardk: sure, I looked at that, but creating a distribution isn't helpful in comparing the means of two sets
16:42:56 <irene-knapp> oh well
16:43:21 <edwardk> true. was just responding to 't test' in your initial statement, before you refined what you were looking for =P
16:43:55 <gwern> (and how is a t test answerable by a function generating a t distribution anyway...
16:52:07 <arks> Is there any differenct betwenn "import some_module" and ":module +some_module" while i'm using GHCi
16:52:42 <timemage> arks, i don't think so.  at one point you couldn't import some_module
16:52:48 <aavogt> in some (older) versions of ghci they are different with respect to instances or something
16:52:51 <timemage> arks, i think the added that later.
16:54:30 <lpsmith> ivanm, yeah I think for the better
16:55:57 <arks> timemage, thx
16:56:08 <arks> aavogt, thx
16:56:47 <aavogt> arks: http://hackage.haskell.org/trac/ghc/ticket/4832 is the bug
16:57:02 <tsuraan> I'm unable to import XMonad.Util.EZConfig; I can run ghc-pkg describe xmonad-contrib, and it's listed there, so I'm not sure what the problem is.  any suggestions?
16:57:25 <aavogt> tsuraan: run ghc-pkg check
16:57:47 <tsuraan> it has no output at all
16:58:26 <tsuraan> looks like I can't import anything from xmonad-contrib
16:58:59 <aavogt> hmm, so the package is not broken
16:59:12 <tsuraan> and I did do a recache
16:59:22 <tsuraan> which also had no output, but I assume it worked
16:59:39 <tsuraan> using ghc 6.12; is that possibly too old?
17:00:26 <tsuraan> the system isn't totally hosed; I can import from other modules
17:00:34 <aavogt> one way it might not show up is if somebody ran "ghc-pkg hide xmonad-contrib"
17:00:58 <aavogt> but then when you run ghc-pkg describe, you'll see  "exposed: False"
17:01:25 <tsuraan> ghc-pkg describe says "exposed: True" for xmonad-contrib
17:01:54 <tsuraan> I'll try an unregister and a re-install.  maybe that will fix it
17:02:07 <aavogt> you don't have multiple ghcs installed?
17:02:35 <tsuraan> no, just 6.12.3
17:02:41 <aavogt> and somehow your ghc-pkg comes from a different install than your ghci or ghc
17:03:05 * aavogt can't think of any other ways to end up in that situation
17:03:12 <tsuraan> I don't think so.  it's actually 6.12.3 for all of them
17:03:22 <tsuraan> ghc, ghci, and ghc-pkg are all 6.12.3
17:03:30 <tsuraan> I just missed the tiny part
17:03:39 <aavogt> oh, you're not running ghc as a different user?
17:04:19 <tsuraan> no, I'm running everything as my normal user (tsuraan) except for the ghc-pkg recache, which I had to run with sudo
17:04:56 <tsuraan> I re-installed xmonad-contrib, and its modules are still listed as exposed, but ghci cannot import them
17:05:01 <tsuraan> so that didn't help
17:06:10 <tsuraan> hm, I wiped out my own user's .ghc and .cabal, and now it can find xmonad-contrib's modules (they are installed globally)
17:06:16 <tsuraan> that's really odd
17:32:23 <elliott> irene-knapp: that is not a utf-8 ellipsis.
17:32:25 <elliott> that is a question mark
17:33:23 <irene-knapp> elliott: hm.  perhaps at your end.
17:33:29 <elliott> no
17:33:38 <elliott> my unicode is not broken :)
17:33:42 <ion> irene-knapp: No, it was on your end.
17:33:45 <elliott> see http://tunes.org/~nef/logs/haskell/12.02.06 for an impartial observer
17:34:10 <ion> …or is it‽
17:34:12 <irene-knapp> oh, possible I guess
17:34:26 <irene-knapp> well, I can't upgrade anyway, so :/
17:35:10 <elliott> irene-knapp: xchat likes to mess up unicode. go to the network list, find freenode, check that encoding is set to utf-8
17:35:13 <elliott> (_not_ "IRC")
17:35:36 <alang_> edwardk: hello
17:35:39 <irene-knapp> no, you don't understand
17:35:51 <irene-knapp> it's an obsolete, non-source-available port of xchat to the Mac
17:35:57 <edwardk> ello
17:36:05 <irene-knapp> yes, probably in violation of the license, but since it's no longer produced, who cares
17:36:35 <irene-knapp> but it's the only halfway decent IRC client for the Mac anyone has ever pointed me to (what was that word you tried to pronounce?  Collo-what?  sorry, I can't hear you, I have a banana in my ear.)
17:36:36 <alang_> edwardk: i was wondering if you could tell me if I should expect the output of AD.jacobian to be rows or columns
17:36:41 <elliott> irene-knapp: xchat aqua is open source
17:36:48 <irene-knapp> is it?  hm
17:36:51 * elliott uses limechat on os x (and tries to not use os x as much as possible)
17:36:55 <irene-knapp> okay
17:37:00 <elliott> irene-knapp: anyway, obsolete or not, doing that should solve your unicode problem :P
17:37:05 <edwardk> look at the types, they kind of read off directly
17:37:11 <irene-knapp> or would if I even had a network list in this version ^^'
17:37:21 <irene-knapp> I have a "server list"
17:37:27 <elliott> heh, that might be a problem then
17:37:31 <elliott> it's in the server configuration, anyway
17:37:33 <irene-knapp> I doublechecked, but there's no encoding options in it
17:37:41 <elliott> meh, ok then
17:38:24 <edwardk> jacobian :: (Traversable f, Functor g, Num a) => (forall s. Mode s => f (AD s a) -> g (AD s a)) -> f a -> g (f a)
17:38:56 <edwardk> you give a function f inputs to g outputs and get back a function from f inputs to g x f results
17:38:57 <irene-knapp> thanks though :)
17:39:13 <ivanm> xchat doesn't compile against latest versions of glib though :(
17:39:28 <alang_> edwardk: got it, thanks!
17:39:35 <edwardk> the argument order is always the one that doesn't require manual transposition
17:39:42 <irene-knapp> I wouldn't want the glib version on the Mac anyway, heh
17:40:35 <edwardk> note that jacobian' makes it even more obvious by bundling the answers as it goes
17:40:37 <ivanm> irene-knapp: glib is a C library...
17:40:39 <ivanm> not gtk+
17:40:58 <edwardk> jacobian :: (Traversable f, Functor g, Num a) => (forall s. Mode s => f (AD s a) -> g (AD s a)) -> f a -> g (a, f a)
17:41:19 <irene-knapp> oh, I see, yes, sorry
17:41:27 <edwardk> transposed there woudn't be a place to put them, that didn't require you to unsafely zip things up
17:41:38 <alang_> right
17:45:08 <edwardk> alang: be warned. the ad package will occasionally give you NaNs where forward mode could give you answers using l'hopital's rule
17:45:33 <edwardk> 0 ** n is a particularly egregious example
17:46:51 <Sgeo> > 0 ** 0
17:46:52 <lambdabot>   1.0
17:46:54 <alang_> oh =\
17:47:00 <otters> > 1.0 / 0.0
17:47:01 <lambdabot>   Infinity
17:47:03 * Sgeo still doesn't quite grock that
17:47:17 <Sgeo> That should be Complex Infinity >.> (I just learned about that today)
17:47:26 <Sgeo> Or, well, "of" it
17:47:39 <otters> oooh, complex infinity
17:47:41 <otters> sounds exotic
17:47:48 <edwardk> alang_: its only those 'safe' 0/0 cases, but still its something to watch out for when using it in anger
17:47:55 <Axman6> > (1/0) :+ (1/0)
17:47:56 <otters> > 0.0 / 0.0
17:47:56 <lambdabot>   Infinity :+ Infinity
17:47:56 <edwardk> its been used on many thousands of variables though
17:47:57 <lambdabot>   NaN
17:48:08 <Sgeo> http://en.wikipedia.org/wiki/Riemann_sphere
17:48:39 <otters> ugh higher math
17:49:12 <Sgeo> Axman6, not quite what is meant by complex infinity, I think. I don't think complex infinity has an ... angle, the way purely real or imaginary or any other complex numbers do
17:49:57 <Axman6> hmm, does that actually have an angle of 45 degrees?
17:50:39 <Axman6> feels like it only can if Infinity == Infinity, and I'm not sure that even makes any sense
17:50:48 <Axman6> maths peeps, go!
17:51:24 <Sgeo> I ... think, the sphere bit means it's to the right of 0 as much as it is to the left of 0 as much as it is above 0 etc.
17:51:34 <Sgeo> I'm not sure though
17:51:55 * Sgeo checks the Simple English wiki
17:52:05 <Sgeo> Nothing
17:52:51 <Eduard_Munteanu> I don't think complex numbers have infinities either :)
17:53:00 <Axman6> mine do
17:53:05 <Axman6> lots of them
17:53:08 <Axman6> like 7
17:53:17 <Axman6> not 8 though.
17:53:19 <Axman6> that would be silly
17:53:28 <Eduard_Munteanu> Yeah, that'd be way too many.
17:53:42 <Eduard_Munteanu> 7 is ok though.
17:53:52 <ion> Eight infinities? Hah, hilarious.
17:54:46 <Eduard_Munteanu> 8∞8∞8∞8∞8∞8∞8∞8∞8
17:55:42 <Eduard_Munteanu> Mm, that could make nice padding for code comments.
17:56:11 * hackagebot husk-scheme 3.5.2.1 - R5RS Scheme interpreter, compiler, and library.  http://hackage.haskell.org/package/husk-scheme-3.5.2.1 (JustinEthier)
17:56:24 <otters> "Gently push a piece of the tube containing the intersection out of the original three dimensional space."
18:03:06 <mlh> otters: amusing, that phrase appears unannotated in the wikipedia page
18:03:29 <otters> I especially like how they specify to "gently" push it
18:03:56 <otters> like, if you push it too harshly, you'll end up in the entirely wrong dimension and have to start over
18:05:08 <deech> Hi all, I'm writing a simple script to find and replace occurences of a string in a file. I've got the find working with Parsec but I'm wondering about the best way to do a destructive replace in a file.
18:05:11 <mlh> is wiki the actual origin of that quote?  can't find other
18:05:15 <byorgey> otters: I hate it when that happens
18:05:21 <otters> byorgey: same
18:05:25 <mlh> ot .. /msg me if you like
18:05:37 <otters> last month I was trying to embed a hypersphere in R(4) space and sneezed
18:05:44 <otters> you should have seen the mess
18:06:20 <byorgey> one time I did that when I had accidentally left the axiom of choice lying around, and I ended up wiht two hyperspheres
18:06:33 <otters> heh
18:06:51 <otters> the next day, schrodinger's cat got into my laboratory and either messed with or did not mess with my stuff
18:07:08 <byorgey> hehe
18:07:17 <otters> I had to go in there and feel around for all my equipment without opening my eyes and collapsing all of it into an either intact or damaged state
18:08:38 <byorgey> sounds dangerous
18:08:46 <otters> you got me
18:08:48 <mreh> sebastien visser in the house?
18:08:56 <deech> Am I allowed to write back the same file handle?
18:09:01 <kermit> would haskell be good for combinatorial optimization issues?
18:09:18 <byorgey> deech: not without closing the file first and re-opening it
18:09:48 <argiopeweb> Is it particularly good/bad to have 1 Gen 0 GC coll and the remainder (hundreds) in Gen1?
18:10:13 <byorgey> kermit: what do you mean by "combinatorial optimization issues"? I'm not familiar with that phrase
18:10:22 <kermit> byorgey: traveling salesman..
18:10:44 <mreh> @faq can i program the Travelling salesman DSP in haskell?
18:10:44 <kermit> byorgey: shortest path computation
18:10:44 <lambdabot> The answer is: Yes! Haskell can do that.
18:10:55 <kermit> mreh: ty
18:11:02 <mreh> i've done it!
18:11:11 <mreh> i think it was for a genetic algorithm
18:11:12 * hackagebot hxournal 0.6.4.1 - A pen notetaking program written in haskell  http://hackage.haskell.org/package/hxournal-0.6.4.1 (IanWooKim)
18:11:19 <argiopeweb> Can't make it any less intractable, but that's a detail...
18:11:19 <byorgey> kermit: I don't see why not.  Though getting highly optimized performance out of Haskell code can be something of a black art.
18:11:28 <kermit> mreh: nice.. is this language better suited for it than others?
18:11:35 <deech> byorgey: Is that the best way of editing a file? Read it all into memory, edit it and write it all back? Actually I'm not aware of how I'd do it differently in another language, but I thought I'd ask.
18:12:03 <kermit> byorgey: it requires logic optimizing though, not actual execution optimization
18:12:10 <Eduard_Munteanu> deech: no, not really
18:12:15 <mreh> kermit: hard question to answer, but i always enjoy using haskell more
18:12:16 <byorgey> kermit: sure, then Haskell should work great
18:12:40 <byorgey> deech: no, I'd write to a temporary file, then the reading and writing can happen lazily and the file doesn't have to be all in memory at once
18:12:57 <byorgey> deech: once the processing is done, you can atomically copy back the temporary file contents overtop of the original file if you want
18:14:07 <Eduard_Munteanu> Or you can use strict IO and not load it all into memory.
18:14:25 <Eduard_Munteanu> Much like in say, C.
18:14:30 <byorgey> true.
18:14:52 <Eduard_Munteanu> Or iteratees, if you want something conceptually nicer. :)
18:16:25 <deech> byorgey: Yes, you are right, but I mis-stated my question. Since I was only changing a small piece of the file I was hoping not to have to write the whole file out to a temporary buffer.
18:17:04 <dolio> Iteratees are conceptually nicer?
18:17:12 <Clint> what's a good way to marshal a C linked list into a Haskell list?
18:17:55 <byorgey> deech: oh, I see.  That's definitely possible in theory, but I don't know the details of doing that from Haskell.
18:18:06 <monochrom> ivanm: http://www.vex.net/~trebla/vixen.txt
18:18:38 <damo22> Instance of Num [Int] required for definition of isUniq.... how do i allow comparison?
18:19:10 <damo22> isUniq :: String -> Bool
18:19:27 <ByronJohnson> I'd use titeratees.  iterIO is the most recent (and IMO, best) implementation of iteratees.
18:19:43 <ByronJohnson> s/titeratees/iteratees/
18:20:31 <dolio> There are two or three iteratee libraries newer than iterIO.
18:20:35 <ivanm> monochrom: ahhh, OK
18:20:36 <damo22> nm i just used head on a [Int] to remove the []
18:21:18 <elliott> ByronJohnson: conduit and pipes are more recent than iteriO. I guess you might have a more stringent definition of "iteratee" though.
18:21:24 <damo22> is [Int] the same as Int:[]
18:21:35 <ion> Head is evil. Please avoid it.
18:21:38 <ion> head, that is.
18:21:58 <ion> The type “[Int]” is the same as “[] Int”.
18:22:32 <damo22> but [2] = 2:[] ?
18:22:40 <danharaj_> gross UArray doesn't have a Functor instance.
18:22:42 <ion> [2] is a value, [Int] is a type.
18:22:52 <danharaj> I know it can't have it, but it's still gross.
18:23:09 <ion> The two []s are different (but incidentally related to each other).
18:23:17 <damo22> ok
18:23:28 <ivanm> monochrom: we should replace @vixen with @eliza (or maybe leave it as @vixen) just for the "conversation" aspects of lambdabot
18:23:36 <Eduard_Munteanu> dolio: well, aside from the strict IO approach, it's pretty much the only one that works generally, no?
18:24:06 <monochrom> further action on lambdabot is unlikely
18:24:09 <dolio> It depends what you want to do.
18:24:13 <danharaj> oh wait I should use amap.
18:24:15 <ion> The data constructor for an empty list might as well be <> and the type constructor for lists might as well be {}. If that were the case, 2:<> :: {Integer}
18:24:52 <monochrom> as you see, people can agree on removing @nixon and not act. so nevermind things that people can't agree upon
18:24:59 <Eduard_Munteanu> Yeah. Well, I do appreciate lazy bytestrings for cases when e.g. I just want to fold over them.
18:25:51 <dolio> Lazy I/O has some simple rules for using it properly that no one can seem to abide by.
18:26:01 <dolio> So lots of people recommend against it.
18:26:51 <dolio> And of course it has a laziness related problem that bites more often than usual due to I/O resources being very limited.
18:27:53 <Eduard_Munteanu> I do like that (some would say broken) model though.
18:28:04 <dolio> Yes. It's great when it works.
18:28:24 <monochrom> I used to think that just because there are simple rules for using lazy I/O properly, it is defensible
18:28:57 <elliott> kind of like C has simple rules for safe memory allocation
18:29:08 <elliott> the /rules/ are simple. the practice...
18:29:18 <dolio> Here's the rules:
18:29:24 <dolio> 1) Don't close handles yourself.
18:29:41 <dolio> 2) Don't make magic clones of handles via low-level file descriptors.
18:29:46 <dolio> That's it.
18:29:47 <Axman6> 2) never free memory, you'll probably do it at the wrong time
18:29:49 <elliott> dolio: erm
18:29:57 <elliott> 3) always make sure you force the entire thing
18:30:01 <elliott> or you'll leak handles
18:30:08 <elliott> that's one of the major problems.
18:30:10 <dolio> That's the laziness issue.
18:30:15 <dolio> Laziness leaks resources.
18:30:26 <elliott> well, you have a bad definition of rules for safety then :)
18:30:33 <elliott> anyway here are the rules for C memory allocation
18:30:37 <elliott> 1) don't access anything you didn't allocate
18:30:44 <elliott> 2) free everything you allocate (optional at the end of the program)
18:30:44 <Eduard_Munteanu> Isn't it the same thing as reachability by GC?
18:30:48 <elliott> what's everyone complaining about?!
18:30:51 <monochrom> now I see it this way: you postpone I/O just so that, in order to catch exceptions and/or close the file properly, you have to hack evaluation order to indirectly cancel the postponement. that's strange.
18:30:59 <byorgey> ivanm: replacing it with @eliza sounds fine to me
18:31:13 * hackagebot husk-scheme 3.5.2.2 - R5RS Scheme interpreter, compiler, and library.  http://hackage.haskell.org/package/husk-scheme-3.5.2.2 (JustinEthier)
18:31:36 <elliott> ivanm: Has anyone in history ever actually been entertained by the conversation aspect of lambdabot?
18:31:55 <elliott> I haven't seen lambdabot produce nearly cogent enough output for that to be entertaining (e.g. a good Markov bot might be amusing for ten minutes).
18:32:01 <ivanm> elliott: it's sometimes amusing mid-stream during a conversation, especially when a newbie doesn't know lambdabot is a bot
18:32:16 <elliott> lambdaperson
18:32:17 <otters> lambda*bot*
18:32:20 <dolio> Sometimes laziness leaks memory, which people call a space leak.
18:32:21 <Eduard_Munteanu> @eliza hi
18:32:21 <lambdabot> Hi
18:32:28 <Eduard_Munteanu> @eliza how are you?
18:32:28 <lambdabot> hOW ARe YOU?
18:32:31 <dolio> So people rewrite their program to make it not leak.
18:32:35 <elliott> dolio: Handles are a lot scarcer than memory, though.
18:32:43 <Eduard_Munteanu> Hm, I thought it didn't really work.
18:32:50 <dolio> When it happens iwth I/O, they do the equivalent of manually freeing memory and rewriting it with the wrong thing.
18:32:51 <Axman6> @elite How are you?
18:32:51 <lambdabot> h0W aR3 yOU?
18:32:53 <elliott> dolio: Also, the fix to the leak with lazy IO is very weird, in that it doesn't correspond to the fix of _any_ space leak.
18:33:04 <Eduard_Munteanu> Right.
18:33:06 <elliott> You force a bunch of stuff just to force a "magical" [] at the end.
18:33:08 <byorgey> hehehe
18:33:26 <dolio> That's how you fix certain space leaks.
18:33:31 <elliott> @eliza Can you elaborate on that?
18:33:32 <lambdabot> cAN u 3LA80RAtE On +hA+?
18:33:41 <ivanm> makes just as much sense as @vixen being interpreted as @nixon
18:33:44 <ivanm> @protontorpedo
18:33:45 <lambdabot> what makes haskell more fun than say clisp?
18:33:45 <elliott> dolio: I can't think of any.
18:33:56 <Onionnion> hi, I have a haskell script I'm trying to run and I just installed the haskell platform and its dependencies and I can't quite figure out what the command is to just run it..I'd imagine it should be 'haskell <name of file>' but apparenly haskell isn't a program installed, or is there a package I'm missing or there's a different command used to run a script?
18:34:03 <Onionnion> linux, btw
18:34:06 <ivanm> Onionnion: runhaskell
18:34:07 <ivanm> runghc
18:34:08 <ivanm> ghci
18:34:09 <ivanm> ghc
18:34:12 <ivanm> take your pick
18:34:25 <ivanm> the first two are aliases for each other, and intended for "scripting"
18:34:30 <Axman6> (those all do different thoings by default however)
18:34:32 <ivanm> ghci is a REPL environment
18:34:35 <otters> aliases for each other? :O
18:34:37 <ivanm> ghc is the compiler
18:34:51 <ivanm> otters: IIRC, runhaskell is a symbolic link to runghc on most installs
18:34:58 <ivanm> (I think it's that way round)
18:34:59 <Eduard_Munteanu> Mutual recursion ftw :P
18:35:02 <otters> I see
18:35:03 <MarconM> Onionnion: ghci
18:35:06 <Onionnion> just trying to run a script via termy
18:35:10 <MarconM> later :l script.hs
18:35:16 <mapreduce> Don't forget ghcii.sh for us Windozy folks.
18:35:19 <dolio> unfoldr (\(m, x) -> if (m > 500000) Nothing else Just (m, (m+1, x))) (0, giant_memory_hungry_value)
18:35:20 <ivanm> nah, if it's written, use runhaskell or runghc
18:35:23 <byorgey> Onionnion: in that case just  runhaskell Script.hs
18:35:44 <ivanm> unlike most languages, we make a distinction between the language and the defacto implementation
18:36:07 <Onionnion> I'm missing a module, Data.Binary.Strict.Get
18:36:12 <elliott> dolio: That doesn't really correspond to forcing a bunch of thunks that aren't being accumulated and that you don't care about the values of.
18:36:15 <ivanm> cabal install binary
18:36:19 <ivanm> Onionnion: ^^
18:36:19 <otters> hoogle
18:36:22 <otters> wait no
18:36:35 <dolio> giant_memory_hungry_value will hang around until you force the whole list or it gets collected.
18:36:51 <Onionnion> should that be superuser, ivanm?
18:36:59 <byorgey> Onionnion: no
18:36:59 <Axman6> no
18:37:07 <ivanm> Onionnion: no, that will install on a per-user basis
18:37:09 <Axman6> Onionnion: also, these are programs, not scripts
18:37:10 <ion> cmccann: (.:)’s fixity doesn’t seem to be defined.
18:37:20 <damo22> http://paste.ubuntu.com/832202/ anyone know how to improve this crappy implementation?
18:37:22 <Onionnion> ah. Thanks guys
18:37:38 <MarconM> Onionnion: do u want to run a script in haskell correct
18:37:42 <Axman6> (not that there's a clear distinction, but i would never call haskell a scripting language like python, perl or ruby
18:37:45 <byorgey> Axman6: what's the difference?
18:37:45 <ivanm> Onionnion: may I ask, what's this script you're trying to run?
18:37:57 <ivanm> just find it strange that you got a random script from somewhere with no instructions on how to run it :p
18:38:08 <Onionnion> mc2obj, ivanm
18:38:11 <Onionnion> I know how to run
18:38:15 <ivanm> byorgey: my distinction is that if it needs main, it isn't a scripting language
18:38:24 <Onionnion> the writer just didn't know linux lol
18:38:32 <MarconM> lol
18:38:32 <jeff_s_> I'm trying to find the source of a <<loop>> exception in some library code. The -fbreak-on-error suggestion from the wiki doesn't seem to be helping very much. Does anyone know of another way to find loops? (Specifically, I'm working with a fork of cassy. I want to add super column support.)
18:38:33 <Axman6> ivanm: that's not a terrible distinction
18:38:37 <ivanm> byorgey: whereas python, etc. you can just add an extra print statement on the end
18:38:43 <Eduard_Munteanu> damo22: use an actual map instead of a list, see Data.Map
18:38:48 <ivanm> jeff_s_: oh, they're always fun
18:38:51 <Onionnion> https://github.com/FalconNL/mc2obj
18:38:54 <ion> damo22: Why are a, b, c, d etc. named?
18:39:10 <damo22> no idea
18:39:25 <otters> I wouldn't use head . maybeToList
18:39:37 <ivanm> that sounds horrible
18:39:44 <Onionnion> I did cabal install binary and it's still not finding the module
18:39:45 <ivanm> use fromJust directly if you want to be unsafe
18:39:47 <otters> probably just fromJust
18:39:48 <otters> yeah
18:39:56 <byorgey> right, fromJust is better than  head . maybeToList ... and even better would be to properly deal with the Nothing case
18:40:05 <otters> that would be nice
18:40:14 <otters> in that case you can use maybe
18:40:14 <otters> :t maybe
18:40:15 <lambdabot> forall b a. b -> (a -> b) -> Maybe a -> b
18:40:15 <damo22> i told you it was crappy
18:40:19 <otters> it is
18:40:28 <damo22> i dont know haskell
18:40:33 <Eduard_Munteanu> Presumably you could find procedural description for those matches.
18:40:33 <otters> oh
18:40:34 <ivanm> actually, binary is part of the paltform, isn't it?
18:40:38 <ion> The definition of grps is rather unclear. Perhaps split the parameter to groupBy to multiple commented (or at least well named) functions.
18:40:49 <byorgey> ivanm: no, it isn't, I checked
18:40:55 <ivanm> huh, thought it was
18:40:57 <byorgey> ivanm: I was surprised by that too
18:41:02 <jeff_s_> When I program in .NET langauges, I feel like I'm using fromJust on every line.
18:41:05 <jeff_s_> It's horrible.
18:41:21 <byorgey> jeff_s_: that's because you are!
18:41:31 <otters> damo22: I'd change it to man x = maybe x id (lookup [x] alphamap)
18:41:37 <ion> Also, (\x' y' -> pos x' == pos y') can be written as (==) `on` pos
18:41:53 <Eduard_Munteanu> jeff_s_: and are you supposed to catch failure via exceptions or something like that?
18:41:58 <ivanm> Onionnion: cabal install binary-strict
18:41:59 <ion> > ((==) `on` (f :: Expr -> Expr -> Expr)) a b
18:42:00 <lambdabot>   *Exception: (==): No overloading for function
18:42:01 <Axman6> we should have an equating function, like comparing
18:42:03 <otters> or better yet, change all those tuples
18:42:11 * ivanm wonders whether binary-strict predates cereal
18:42:12 <otters> to just be ('a', "aA4@"), etc.
18:42:17 <otters> to be (Char, String) instead of (String, String)
18:42:30 <otters> then you only have to use lookup x alphamap
18:42:30 <jeff_s_> I wrap every line of non-exception handling code in Try .. Catch NullReference...
18:42:32 <ion> > ((f :: Expr -> Expr -> Expr) `on` (g :: Expr -> Expr)) a b
18:42:32 <lambdabot>   f (g a) (g b)
18:42:34 <ivanm> oh, yes it does
18:42:36 <monochrom> @quote hiding.information
18:42:36 <lambdabot> AlanPerlis says: The string is a stark data structure and everywhere it is passed there is much duplication of process. It is a perfect vehicle for hiding information.
18:42:45 <jeff_s_> Then I make sure the exception is not null.
18:42:47 <monochrom> that is why everyone uses string for everything
18:42:53 <cmccann> ion, at this point I'm pretty sure you've technically made more use of that library than I have which is slightly hilarious I guess
18:43:13 <Onionnion> ivanm: now missing data.list.key
18:43:17 <ivanm> OK, whoever wrote that script doesn't know much Haskell
18:43:21 <otters> yeah
18:43:25 <ion> axman6: I for one find “comparing” redundant. :-P
18:43:30 <Onionnion> I assume cabal install list ?
18:43:35 <elliott> jeff_s_: try -xc
18:43:38 <elliott> @where rts-xc
18:43:38 <lambdabot> ghc --make -prof -auto-all -rtsopts -osuf .p_o foo.hs && ./foo +RTS -xc
18:43:48 <Axman6> ion: it is, but it reads better than compare `on` foo
18:43:48 <ivanm> Onionnion: go to the "How to compile" section at the bottom of the README
18:43:49 <ivanm> it says what you need to do
18:44:04 <damo22> but apart from all those simple things to make the code more readable, i think the actual algorithm is poor, how can i improve it? its gonna overflow my ram before it comes up with any output
18:44:05 <ivanm> all those instructions should work on *nix as well
18:44:09 <Axman6> sortBy (comparing foo) instead of sortBy (comparing `on` foo)
18:44:17 <ion> cmccann: Well, i’m using it as my GHCi “prelude”, it’s not very surprising i end up using a bunch of stuff from it. :-)
18:44:24 <ivanm> why do people still write un-cabalised software? *sigh*
18:44:31 <Onionnion> oh my how did I not seed that
18:44:35 <otters> yep, there we go
18:44:38 <otters> broke that file
18:44:48 <ivanm> because it's down the bottom rather than up the top like most sane READMEs have it
18:44:49 <elliott> * ivanm wonders whether binary-strict predates cereal ;; binary-strict Dec 20 11:13:43 UTC 2007; cereal Tue Sep 29 00:31:30 UTC 2009
18:44:51 <otters> runhaskell mangle.hs "hello goodbye" and it fails on an empty list
18:44:58 <elliott> ivanm: however binary-strict first description "This is a strict version of the Get monad from the binary package. Ti's pretty much just a copy and paste job from the original source code. The binary team are currently unsure about their future plans w.r.t. strictness, so this is just a stop gap measure."
18:45:07 <ivanm> elliott: yeah, see my next statement :p
18:45:09 <elliott> + marked as obsolete
18:45:11 <elliott> oh
18:45:14 <elliott> all that time wasted :P
18:45:16 <Onionnion> so is ghc the compiler for haskell?
18:45:21 <elliott> Onionnion: a compiler
18:45:21 <ivanm> seems that the 0.4 series of binary-strict is by someone else though, they just took the name
18:45:22 <elliott> not the
18:45:26 <ivanm> Onionnion: the de-facto one
18:45:31 <damo22> otters: you cant use a whitespace its not defined
18:45:37 <cmccann> ion, I do too, but since it's distilled from a bunch of stuff I had in separate projects I don't always notice the gaps
18:45:37 <ivanm> OK, that is some *horrible* code in that mc2obj file
18:45:41 <otters> damo22: ...exactly
18:46:02 <ivanm> they knew how to use cmdards, but not how to use uncurry3
18:46:08 <Onionnion> how so? (never looked at haskell, good at lua and C++ basics, though)
18:46:11 <damo22> otters: i couldnt be bothered handling the whitespace, no one uses a whitespace in a password
18:46:14 <ivanm> not to mention all the Applicative stuff
18:46:18 <monochrom> "runhaskell mangle.hs" is the less-evil mangler :)
18:46:18 <ivanm> *cmdargs
18:46:20 * otters does
18:46:23 <scru> hey guys, newbie here
18:46:32 * ivanm waves idly in scru's general direction
18:46:41 <monochrom> I used 4 whitespaces in a recent password
18:46:51 <Eduard_Munteanu> scru: hi
18:46:53 <ivanm> I like spaces in passwords
18:46:58 <otters> and you're kind of forgetting special characters
18:47:01 <otters> many of which I also use
18:47:15 <ivanm> is it just me, or is the main defintion here *way* too long? https://github.com/FalconNL/mc2obj/blob/master/mc2obj.hs
18:47:25 <Eduard_Munteanu> Anybody using Unicode passwords? :P
18:47:30 <damo22> this is for a specific case im trying to handle
18:47:40 <ivanm> Eduard_Munteanu: nah
18:47:51 <ivanm> too hard when you go to a different system and want to enter the password in
18:47:55 <ivanm> e.g. using a phone
18:47:57 <ion> eduard_munteanu: Just the ASCII subset. :-)
18:47:57 <damo22> a very very long password, i need to make a dictionary for it
18:48:00 <scru> what's a good guide to learning Haskell (complete with exercises). I've been using this so far, but I sort of like having exercises to test out what I've learned so far: http://learnyouahaskell.com/
18:48:05 <Eduard_Munteanu> ivanm: but I guess it'd be easier to remember
18:48:09 <Onionnion> alright it's running
18:48:13 <Onionnion> thanks guys
18:48:17 <ivanm> scru: that's the usual recommendation
18:48:21 <monochrom> http://xkcd.com/936/ for those who think no one uses spaces in passwords
18:48:33 <ivanm> scru: there's tryhaskell.org but it only has a few lessons
18:48:34 <Eduard_Munteanu> Since a Unicode char can be a multibyte ASCII value.
18:48:35 <ivanm> @where yaht
18:48:35 <lambdabot> "Yet Another Haskell Tutorial", Hal Daume III,<http://www.cs.utah.edu/~hal/htut/>,<http://en.wikibooks.org/wiki/Haskell/YAHT>,<http://hal3.name/docs/daume02yaht.p(df|s)>,<http://darcs.haskell.org/
18:48:35 <lambdabot> yaht/yaht.p(df|s)>
18:48:36 <CodeWeaverX> scru:  Check out the book / online site "Real World Haskell"
18:48:37 <ivanm> @where wikibook
18:48:37 <lambdabot> http://en.wikibooks.org/wiki/Haskell
18:48:41 <ivanm> scru: ^^
18:48:46 <ivanm> CodeWeaverX: for a beginner?
18:48:47 <MarconM> anyone use xmonad here ?
18:48:54 <ivanm> MarconM: not on this machine, but yes
18:48:56 <ivanm> there's also #xmonad
18:48:59 <CodeWeaverX> ivanm… well, perhaps not.  But it's another resource.
18:49:05 <MarconM> ivanm: do u use trayer ?
18:49:10 <ivanm> nope
18:49:14 <ivanm> lxpanel
18:49:17 <MarconM> hunm
18:49:24 <MarconM> ivanm: its better ?
18:49:32 <Eduard_Munteanu> I sometimes do when I have to start a trayed application.
18:49:38 <ivanm> *shrug* dunno about better
18:49:38 <Eduard_Munteanu> But not normally.
18:49:46 <ivanm> I just prefer to have a slim DE wrapping around xmonad
18:49:49 <scru> what's lambdabot do?
18:49:52 <MarconM> Eduard_Munteanu: hunm ... yes sometimes i use skype or QQ
18:49:56 <damo22> let us suppose i know that a password is from a particular english sentence which i know, but its mangled with funny characters, how can i efficiently create a dictionary to break it?
18:49:57 <MarconM> i need trayer =/
18:50:02 <CodeWeaverX> Actually, RWH doesn't really have exercises either, although the chapters walk through making a rather extensive program.
18:50:07 <ivanm> to auto-start stuff, etc.
18:50:18 <Eduard_Munteanu> scru: lots of stuff, evaluate Haskell code, check types etc.
18:50:26 <MarconM> ivanm: do u start lxpanel on ~/.xinitrc
18:50:28 <Eduard_Munteanu> @hoogle lambdabot
18:50:29 <lambdabot> package lambdabot
18:50:29 <lambdabot> package lambdabot-utils
18:50:30 <CodeWeaverX> Hey, found this:  http://www.haskell.org/haskellwiki/99_questions
18:50:32 <MarconM> lxpanel &
18:50:34 <ivanm> scru: lambdabot is the in-channel bot; she lets you send messages to others, google stuff, evaluate snippets of code, search for functions, etc.
18:50:36 <Eduard_Munteanu> @hackage lambdabot
18:50:36 <lambdabot> http://hackage.haskell.org/package/lambdabot
18:50:38 <Eduard_Munteanu> @list
18:50:38 <lambdabot> http://code.haskell.org/lambdabot/COMMANDS
18:50:45 <ivanm> MarconM: no, I run lxde from my DM
18:50:51 <MarconM> DM ?
18:50:56 <MarconM> ivanm: DM ?
18:51:09 <ivanm> Display Manager
18:51:09 <otters> hmmm
18:51:13 <MarconM> \o/
18:51:13 <otters> generating all possible permutations of a string
18:51:15 * hackagebot xturtle 0.0.11 - turtle like LOGO  http://hackage.haskell.org/package/xturtle-0.0.11 (YoshikuniJujo)
18:51:18 <ivanm> GDM, KDM, LXDM, SLiM, etc.
18:51:19 <otters> there's something I haven't explored with haskell yet
18:51:21 <Eduard_Munteanu> MarconM: I just start it manually in a terminal in such cases :)
18:51:21 <MarconM> hunm
18:51:25 <Eduard_Munteanu> Rarely.
18:51:30 <MarconM> Eduard_Munteanu: cool
18:51:30 <ivanm> otters: same as all possible permutations of a list
18:51:41 <otters> yeah, I haven't explored that yet
18:51:43 <ion> (LightDM is rather nice.)
18:51:44 <MarconM> Eduard_Munteanu: do u know how to change trayer color
18:51:45 <damo22> otters, but not every permutation, only ones which match a pattern
18:51:54 <Eduard_Munteanu> Nah, never bothered :)
18:52:14 <scru> cool, thanks! i'll ty these
18:52:18 <scru> *try
18:52:22 <otters> damo22: well, you can generalize
18:52:22 <Eduard_Munteanu> The only stuff I usually run is xmobar.
18:52:38 <damo22> otters: every permutation is easy
18:52:45 <otters> how
18:53:09 <ivanm> @hoogle [a] -> [[a]]
18:53:09 <lambdabot> Data.List inits :: [a] -> [[a]]
18:53:09 <lambdabot> Data.List permutations :: [a] -> [[a]]
18:53:10 <lambdabot> Data.List subsequences :: [a] -> [[a]]
18:53:13 * Eduard_Munteanu should try LightDM sometime
18:53:15 <damo22> using cartesian product
18:53:16 <otters> bah.
18:53:16 <ivanm> > permutations "hello"
18:53:17 <lambdabot>   ["hello","ehllo","lehlo","elhlo","lhelo","hlelo","lleho","lleho","lelho","l...
18:53:30 <otters> okay fine
18:53:31 <ivanm> though that assumes there are no duplicates
18:53:38 <otters> although that's actually not what I need here is it
18:53:40 <ivanm> if there are, you need to be slightly more clever
18:53:51 <elliott> MarconM: This should probably go in -blah.
18:54:10 <ivanm> or #xmonad
18:54:21 <MarconM> yes
18:54:22 <damo22> you could do the naive way, and generate all permutations then discard the ones which dont match the pattern, but that method sucks for large sets
18:54:38 <damo22> which is what i have done
18:54:49 <otters> so I see
18:55:27 <damo22> so the problem is how do you efficiently generate only the ones which match a generalised pattern format?
18:55:32 <MarconM> i got =)
18:55:44 <MarconM> trayer --ting 0x00000 =)
18:55:50 <MarconM> tint*
18:55:58 <damo22> surely haskell is a good language to do this
18:57:04 <Axman6> aren't there libraries which will take parsers or regexs and produce all strings that will match them?
18:57:37 <damo22> hmm i wonder
18:57:59 <ivanm> Axman6: there are?
18:58:08 <monochrom> Doug McIlroy's paper "enumerating the strings of regular languages" http://www.cs.dartmouth.edu/~doug/nfa.ps.gz
18:58:23 <MostAwesomeDude> Man, why does Data.List have permutations but not combinations?
18:58:28 <Axman6> ivanm: there are
18:58:47 <Axman6> MostAwesomeDude: what's combinations do?
18:58:49 <ivanm> MostAwesomeDude: because no-one bothered to do a libraries@ proposal to add one
18:58:54 <ivanm> Axman6: all possible sub-sets
18:59:19 <Axman6> hmm, i thought that did exist
18:59:36 <ivanm> yeah, I think you can use the list monad to do that
18:59:40 <ivanm> using sequence or something?
18:59:45 <ivanm> > sequence "hi"
18:59:46 <lambdabot>   Couldn't match expected type `m a'
18:59:47 <lambdabot>         against inferred type `GHC.Types...
18:59:52 <ivanm> no, wait
18:59:53 <ivanm> eh
19:00:08 <ion> > (permutations <=< subsequences) "abc"  -- do you mean this one?
19:00:09 <lambdabot>   ["","a","b","ab","ba","c","ac","ca","bc","cb","abc","bac","cba","bca","cab"...
19:00:10 <Axman6> > filterM (const [True,False]) "hello" >>= permutations
19:00:11 <lambdabot>   ["hello","ehllo","lehlo","elhlo","lhelo","hlelo","lleho","lleho","lelho","l...
19:00:12 <MostAwesomeDude> Axman6: http://docs.python.org/library/itertools.html#itertools.combinations it's a cousin of permutations.
19:00:44 <otters> :t (<=<)
19:00:45 <lambdabot> forall b (m :: * -> *) c a. (Monad m) => (b -> m c) -> (a -> m b) -> a -> m c
19:00:59 <otk_> :t (import)
19:01:00 <lambdabot> parse error on input `import'
19:01:17 <Axman6> otk_: that's syntax
19:02:29 <otk_> hehe
19:06:44 <ion> > filter (and . (zipWith (<) <*> drop 1)) . replicateM 2 $ "ABCD"
19:06:46 <lambdabot>   ["AB","AC","AD","BC","BD","CD"]
19:07:57 <MostAwesomeDude> ion: I bet, unfortunately, that ran on eight elements instead of six.
19:07:59 <MostAwesomeDude> Creative, though.
19:08:29 <Axman6> > filter (and . (zipWith (<) <*> drop 1)) . replicateM 3 $ "ABCD"
19:08:31 <lambdabot>   ["ABC","ABD","ACD","BCD"]
19:09:17 <MostAwesomeDude> Hm, wait a minute. This is interesting. I'm gonna have to stare at this for a bit.
19:09:35 <copumpkin> MostAwesomeDude: :O
19:09:47 <Axman6> > filter (and . (zipWith (<) <*> drop 1)) . replicateM 4 $ "ABCD"
19:09:49 <lambdabot>   ["ABCD"]
19:09:54 <Axman6> > filter (and . (zipWith (<) <*> drop 1)) . replicateM 4 $ "ABCDEFG"
19:09:55 <lambdabot>   ["ABCD","ABCE","ABCF","ABCG","ABDE","ABDF","ABDG","ABEF","ABEG","ABFG","ACD...
19:10:48 <otters> > [a:b:[] | a <- "str1", b <- "str2"]
19:10:49 <lambdabot>   ["ss","st","sr","s2","ts","tt","tr","t2","rs","rt","rr","r2","1s","1t","1r"...
19:11:07 <otters> that's what damo22 really needs
19:11:46 <copumpkin> > liftA2 (=<<) zip (tail . tails) $ "ABCD"
19:11:47 <lambdabot>   [('A','B'),('B','C'),('C','D'),('A','C'),('B','D'),('A','D')]
19:12:24 <otters> except that you need (a <- "...") for every character of the string
19:12:36 <otters> how do you do that
19:13:10 <Axman6> huh?
19:13:24 <otters> so <- is a keyword, not a function
19:13:44 <Axman6> so? don't use that syntax =)
19:13:46 <copumpkin> MostAwesomeDude: what I put there doesn't cover eight elements!
19:13:49 <otters> Axman6: right
19:13:59 <MostAwesomeDude> copumpkin: I'm trying to decipher it right now.
19:14:08 <Axman6> you're just using the list monad really, which means you can break it down into using concatMap
19:14:11 <otters> but I'm just trying to figure out how to solve damo22's problem with the permutations of the password
19:15:25 <damo22>     http://hackage.haskell.org/packages/archive/regex-genex/0.2.0/doc/html/Regex-Genex.html
19:15:55 <Axman6> sounds like what i was talking about
19:16:54 <elliott> (http://hackage.haskell.org/packages/archive/regex-genex/0.3.2/doc/html/Regex-Genex.html is a newer version)
19:18:05 <otters> like, given the array ["hH","eE3","lL1","oO0"]
19:18:24 <damo22> just have to turn it into a regexp
19:18:29 <otters> how would you produce the list of every possible string made by taking a character from group 1, group 2, etc.
19:19:11 <Axman6> > sequence ["Hello","world","123"]
19:19:12 <lambdabot>   ["Hw1","Hw2","Hw3","Ho1","Ho2","Ho3","Hr1","Hr2","Hr3","Hl1","Hl2","Hl3","H...
19:19:22 <otters> ahhhhhhhhh
19:19:42 <otters> well that makes this easier
19:19:45 <Axman6> > sequence ["hH","eE3","lL1","oO0"]
19:19:46 <lambdabot>   ["helo","helO","hel0","heLo","heLO","heL0","he1o","he1O","he10","hElo","hEl...
19:20:02 <Axman6> > sequence ["hH","eE3","lL1","lL1","oO0"]
19:20:03 <lambdabot>   ["hello","hellO","hell0","helLo","helLO","helL0","hel1o","hel1O","hel10","h...
19:20:17 <Axman6> > last $ sequence ["hH","eE3","lL1","lL1","oO0"]
19:20:18 <lambdabot>   "H3110"
19:21:47 <damo22> so how do you write a regexp that prevents same case from being next to each other? lol
19:21:55 <otters> damo22: I got it
19:23:08 <damo22> otters ?
19:23:18 <otters> well I simplified your problem a bit
19:23:31 <otters> I think
19:23:32 <ion> > let comb = go (const True) where { go f (as:ass) = do { a <- as; guard (f a); (a:) <$> go (a <) ass }; go _ [] = return [] } in (comb (replicate 2 "ABCD"), comb (replicate 3 [0..3]))
19:23:33 <lambdabot>   (["AB","AC","AD","BC","BD","CD"],[[0,1,2],[0,1,3],[0,2,3],[1,2,3]])
19:24:27 <otters> damo22: https://gist.github.com/1757154
19:24:29 <otters> does that do what you intended
19:25:19 <otters> you could change the definition of mangle to mangle = sequence . map (...)
19:25:39 <damo22> otters thats pretty much what i wrote but doesnt include filtering for similar case next to each other
19:25:46 <otters> "similar"
19:25:47 <otters> hm
19:26:14 <akosch> what should I use for scraping data from HTML documents? I've tried tagsoup, but it's really limited and HXT won't parse the invalid mess that is my document :(
19:27:00 <ion> Does Text.XML.HXT.TagSoup work?
19:27:15 <damo22> if you do filter(isNextToEachOther) sequence .... it screws over your memory for large input
19:27:16 <otters> damo22: I don't understand your criteria for similar cases
19:27:21 <akosch> ion: thanks, I'll try it in a second
19:27:45 <ion> (I don’t really know whether it handles invalid HTML, i’ve only noticed its existence.)
19:28:11 <otters> damo22: what are your criteria for similar cases
19:28:58 <damo22> otters: i want only these to be returned:  mangle ["hH","iI1"] = hI Hi H1 h1 thats all i dont want hi or HI
19:29:07 <otters> why not?
19:29:36 <damo22> because i know that his password doesnt look like "PASSword"
19:29:37 <akosch> ion: i've been using lxml with python before and it is awesome. HXT look good too, sadly I'm working with ugly malformed documents
19:29:58 <otters> damo22: so reject the password if the casing is consistent throughout?
19:30:09 <damo22> otters: i tried that, and my memory blew up
19:30:16 <ion> damo22: I take it you’ve already tried John the Ripper?
19:30:17 <otters> damo22: I mean, is that what you're trying to do
19:31:03 <damo22> ion: kinda i dont really know how to use the mangling rules correctly the doco isnt clear
19:32:20 <damo22> i think the only way is to generate a regexp somehow
19:32:53 <damo22> shouldnt be too hard
19:33:43 <damo22> its a 27 character password
19:33:51 <damo22> :P
19:34:28 <damo22> and i know the exact english phrase its based on
19:35:07 <damo22> just need to do some mangling
19:38:13 <ceasarbautista> B
19:41:16 * hackagebot system-filepath 0.3.7 - High-level, byte-based file and directory path manipulations  http://hackage.haskell.org/package/system-filepath-0.3.7 (JohnMillikin)
19:41:32 <otters> damo22: think I got it now
19:42:03 <damo22> otters: you understand the problem or you have a solution? :P
19:42:08 <otters> solution
19:42:16 <damo22> :D
19:42:29 <otters> it's ugly though
19:42:32 <otters> pl can't help me here
19:42:36 <ceasarbautista> Can anyone help me with a homework problem? The question is to define a function with type: "((a -> r) -> r) -> (a -> ((b -> r) -> r)) -> ((b -> r) -> r)". The trouble I'm having is understanding where to start.
19:43:09 <blackdog> what's the attoparsec combinator you attach to get better error messages?
19:43:20 <ceasarbautista> If we label the first function c, and the second one d, then clearly I just need to partially apply some a to d.
19:43:36 <ceasarbautista> But I can't seem to fit the functions together to get of the rid the a.
19:43:46 <Axman6> ceasarbautista: we won't tell you the answer, but wer can help guide you. firstly, how many arguments does this function take?
19:44:20 <ceasarbautista> Sure. In its current form it takes two I think.
19:44:28 <damo22> otters: can you paste what youve got?
19:44:28 <otters> pl REALLY wants to make this thing a monad
19:44:44 <ceasarbautista> ((a -> r) -> r)  and  (a -> ((b -> r) -> r)).
19:44:56 <Axman6> ceasarbautista: yeah, i believe it takes too. so we've got foo a b = ...
19:45:35 <ceasarbautista> Right. So now what I want to do somehow is partially apply b with any a I think.
19:45:42 <otters> @pl \e -> (isUpper e) || (not $ isAlpha e)
19:45:42 <lambdabot> liftM2 (||) isUpper (not . isAlpha)
19:45:52 <otters> :t liftM2 (||) isUpper (not . isAlpha)
19:45:53 <lambdabot> Char -> Bool
19:45:57 <otters> ...:/
19:46:02 <otters> that breaks on my end
19:46:04 <ceasarbautista> But I don't have an a to give the function.
19:46:06 <otters> what does lambdabot have that I don't?
19:46:17 * hackagebot system-filepath 0.4.6 - High-level, byte-based file and directory path manipulations  http://hackage.haskell.org/package/system-filepath-0.4.6 (JohnMillikin)
19:46:50 <Axman6> ceasarbautista: heh, yeah i'm pretty lost now too. this is all cont monad stuff, which i go between understanding and not understanding at all
19:47:18 <otters> I get no instance for (Monad ((->) Char)) on that last thing I tried to evaluate
19:47:21 <otters> who wants to help :3
19:47:46 <Axman6> otters: you need to import Data.Function I think...
19:47:55 <MostAwesomeDude> :t liftA2 (||) isUpper (not . isAlpha)
19:47:55 <lambdabot> Char -> Bool
19:48:04 <Axman6> wherever the instance for Monad (e ->) is defined anyway
19:48:11 <otters> hm
19:48:21 <otters> I don't know where Monad (e ->) is defined
19:48:24 <otters> and it's not in Data.Function
19:48:39 <Axman6> Control.Monad?
19:48:44 <otters> seyu
19:48:47 <otters> nope
19:49:11 <otters> hoogle doesn't know what e is
19:49:27 <otters> m ((->) e) resolves to m e
19:49:55 <otters> errr, hoogle doesn't know what Monad is
19:49:59 <Axman6> ceasarbautista: can you paste the typ again?
19:50:07 <MostAwesomeDude> The instance Functor ((->) r) isn't in Data.Functor. :T
19:50:08 <ceasarbautista> Axman6: I think it has something to do with currying and uncurrying based off of lecture, but I really have no idea..
19:50:32 <otters> @hoogle Monad ((->) e)
19:50:32 <lambdabot> Warning: Unknown type Monad
19:50:33 <lambdabot> Prelude undefined :: a
19:50:33 <lambdabot> Control.Applicative unwrapMonad :: WrappedMonad m a -> m a
19:50:37 <ceasarbautista> ((a -> r) -> r) -> (a -> ((b -> r) -> r)) -> ((b -> r) -> r)
19:50:48 <otters> ^
19:51:31 <ivanm> otters: are you trying to get all Monad instances?
19:51:33 <ivanm> @instances Monad
19:51:34 <lambdabot> ((->) r), ArrowMonad a, ContT r m, Either e, ErrorT e m, IO, Maybe, RWST r w s m, ReaderT r m, ST s, StateT s m, WriterT w m, []
19:51:44 <otters> oh, that first one looks good
19:51:50 <otters> but I really have no idea how to use lambdabot :|
19:51:58 <byorgey> ceasarbautista: it doesn't have to do with currying and uncurrying =)
19:52:06 <Axman6> ok, so we have a function a :: ((a -> r) -> r). this to me says that a can give us an a for that inner function
19:52:07 <otters> damo22: https://gist.github.com/1757273 is what I got
19:52:08 <ivanm> otters: otherwise, what you wrote only makes sense in the context of writing the Monad instance for ((->) e)
19:52:10 <otters> but I'm trying to clean it up
19:52:28 <otters> ivanm: that's what I want, the monad instance for ((->) whatever)
19:52:34 <otters> and I don't know where it is
19:52:47 <ivanm> Control.Monad.Instances I believe
19:52:51 <ceasarbautista> byorgey: That's a relief. And I think I got it, although kind of poorly:  foo c d = foo c d
19:53:01 <Axman6> heh... no
19:53:02 <Ralith> Can anyone comment on the background necessary to read the paper describing and/or implement OutsideIn(X)?
19:53:11 <byorgey> ceasarbautista: that is just infinite recursion
19:53:19 <ivanm> Ralith: which paper is this?
19:53:34 <Ralith> ivanm: simonpj's one on GHC 7's new type inference engine
19:53:37 <Axman6> hmm, i think i can see where this is going
19:53:43 <ivanm> ahhh
19:53:48 <ceasarbautista> byorgey: "any function
19:53:48 <ceasarbautista> which can be assigned the given type signature is a correct solution" :P
19:53:49 <eyebloom> What is a good word for something that a symbol is being applied to i.e. in "f x" f is x's ____?
19:54:00 <Sgeo> It's not cont monad, it's reader monad
19:54:06 <ivanm> eyebloom: f is the function ...
19:54:16 <byorgey> ceasarbautista: indeed. in retrospect that was the wrong thing to say =P
19:54:18 <ivanm> Sgeo: the function Monad (which is an implicit Reader monad, not an explicit one)?
19:54:25 <eyebloom> But specifically as it relates to x
19:54:34 <ivanm> don't think there is a term
19:54:37 <Sgeo> ivanm, yes, which I thought the discussion was about
19:54:40 <byorgey> ceasarbautista: so technically that solution would get full correctness points and zero style points, and you wouldn't learn anything =)
19:54:44 <ivanm> "f is the function to which x is being applied to"
19:55:11 <ceasarbautista> byorgey: Is there a certain part I should review?
19:55:16 <Ralith> ivanm: I've only just recently started to pick up the theory and have success with experiments in the domain of types, but the system it describes sounds like a lot of fun to play with.
19:55:27 <ivanm> yeah, I have nfi
19:55:31 <ivanm> not into that stuff
19:55:33 <eyebloom> No single word....
19:55:39 <eyebloom> too bad.
19:55:51 <Ralith> damn
19:56:38 <byorgey> ceasarbautista: you will probably find lambda abstraction useful.  Also review the way that function arrow associates to the right, so e.g.  x -> (y -> z) is the same as  x -> y -> z
19:56:55 <drbean> eyebloom: applicand?
19:57:25 <eyebloom> That seems right.
19:57:33 <byorgey> Ralith: some familiarity with formal descriptions of type systems is probably required. other than that, just a lot of patience and attention to detail.
19:57:57 <eyebloom> drbean: If that the case than x is f's _____ ?
19:57:59 <Axman6> :t let foo :: ((a -> r) -> r) -> (a -> ((b -> r) -> r)) -> ((b -> r) -> r); foo x y = x y in foo
19:58:00 <lambdabot>     Occurs check: cannot construct the infinite type: r = (b -> r) -> r
19:58:00 <lambdabot>     When generalising the type(s) for `foo'
19:58:00 <lambdabot>     In the expression:
19:58:02 <eyebloom> Parameter?
19:58:23 <eyebloom> I'm thinking specifically lambda calculus.
19:58:50 <Ralith> byorgey: I've been able to make sense of the portions of TAPL that I've skimmed, and I've successfully implemented something approximating HM based on that. Think that covers it?
19:59:16 <byorgey> Ralith: sure
19:59:37 <Ralith> that doesn't sound very certain
19:59:45 <Ralith> not that I guess you are in any position to be
19:59:47 <byorgey> Ralith: yes, absolutely!!
19:59:51 <byorgey> ;)
19:59:54 <Ralith> that helps! ^^
20:00:05 <Ralith> anyway thanks
20:00:13 <Ralith> it is good to know that I won't get 40 pages in only to realize I'm way out of my depth
20:00:17 <byorgey> Ralith: if you get stuck on something, you can ping me to ask about it
20:00:24 <Ralith> much appreciated :D
20:00:59 <damo22> otters: pwmangle2: out of memory (requested 1048576 bytes)   plus it didnt restrict all the characters to be different sequential cases
20:01:31 <eyebloom> drbean: Wikipedia seams to agree with you, thanks.
20:02:09 <byorgey> ceasarbautista: anyway, that one is supposed to be difficult
20:02:17 <byorgey> ceasarbautista: feel free to discuss it with others in the class as well.
20:07:17 <eyebloom> In the expression λx. M  λx is M's ____? Abstraction?
20:10:07 <BlazeCoder> scope
20:10:47 <eyebloom> Lovely.
20:11:41 <BlazeCoder> sorry, you looked like some kinda trivia bot, that was a stab in the dark lol
20:12:30 <eyebloom> You win.
20:13:09 <eyebloom> Would you like to play again? (Y/N)
20:13:19 <BlazeCoder> lol. N!
20:13:25 <eyebloom> Fine.
20:13:40 <damo22> Press F10 to Exit to DOS
20:14:06 <eyebloom> Nooo.
20:14:56 <eyebloom> There exists a more advanced turing test, where the machine has to make you laugh.
20:15:06 <ivanm> that'd be interesting to see, since it isn't installed here...
20:15:11 <ivanm> (DOS, that is)
20:16:08 <damo22> sbv-0.9.24 failed during the building phase.
20:16:39 <damo22> (Use -XFlexibleContexts to lift this restriction)
20:16:59 <damo22> what do i do with cabal now?
20:18:28 <BlazeCoder> Cry
20:19:17 <nyingen> @quote
20:19:17 <lambdabot> Plugin `quote' failed with: getRandItem: empty list
20:19:19 <nyingen> @quote
20:19:19 <lambdabot> coedwardk says: <contrapumpkin> like yoda, I speak now <coedwardk> is that word ordering contra-diction?
20:19:28 <byorgey> eyebloom: M is the body of λx. M.  But λx  is not M's anything.
20:19:57 <ivanm> damo22: "cabal unpack sbv", edit it to add FlexibleContexts where needed, then "cabal install" within the directory
20:20:04 <ivanm> @protontorpedo
20:20:04 <lambdabot> help please
20:20:10 <ivanm> @nixon
20:20:11 <lambdabot> The Chinese use two brush strokes to write the word 'crisis.' One brush stroke stands for danger; the other for opportunity. In a crisis, be aware of the danger - but recognize the opportunity.
20:20:27 <ivanm> that one is actually almost profound...
20:20:39 <eyebloom> I see. Scope refers specifically to a variable then.
20:20:42 <byorgey> after doing "cabal unpack" and editing, don't forget to increase the version number before doing "cabal install"
20:20:59 <ivanm> oh, yeah, add a trivial ".1" to the end of the version or something
20:21:10 <ivanm> just to stop cabal-install from trying to install the one from hackage again
20:21:27 <eyebloom> In "λx. xyz " λx would be x's scope?
20:22:12 <damo22> just change the directory name?
20:22:28 <ivanm> damo22: no
20:22:42 <ivanm> the directory name is irrelevant to the build process
20:23:02 <damo22> ahh in the sbv.cabal file
20:23:08 <ivanm> yup
20:24:59 <byorgey> eyebloom: no, xyz is x's scope
20:25:11 <eyebloom> fair enough
20:25:20 <byorgey> eyebloom: the scope of a variable is the terms in which it is "visible"
20:25:21 <damo22> cSizeOf :: Maybe Int -> HasSignAndSize a => a -> Int its complaing about this line
20:25:36 <byorgey> i.e. can be referred to
20:25:51 <damo22> where do i put the -Xblahblah
20:26:20 <ivanm> damo22: the top of the file that's complaining, put {-# LANGUAGE blahblah #-}
20:26:25 <ivanm> (i.e. no -X )
20:26:31 <ivanm> and bitch to the maintainer to make a new release
20:31:30 <eyebloom> byorgey: would xyz be the scope of yz ?
20:31:46 <damo22> dammit it didnt fix the problem
20:32:30 <damo22> same error
20:32:50 <scru> @hoogle Data.List.group
20:32:50 <lambdabot> Data.List group :: Eq a => [a] -> [[a]]
20:32:51 <lambdabot> Data.List groupBy :: (a -> a -> Bool) -> [a] -> [[a]]
20:32:51 <lambdabot> package groupoid
20:34:42 <scru> Data.List > group [1, 2, 3, 4, 1, 2, 3, 4]
20:34:52 <scru> hmm...maybe not
20:35:33 <damo22> if i downloaded a cabal package manually can i still install it?
20:35:42 <strager> damo22: Yes.
20:35:48 <damo22> or will shit hit the fan
20:35:52 <strager> cabal configure && cabal install
20:40:28 <damo22> well sbv-0.9.22 is the latest that works on my system
20:43:59 <ion> > let comb :: Integer -> [a] -> [[a]]; comb n (a:as) | n > 1 = map (a:) (comb (n-1) as) ++ comb n as; comb 1 as = map pure as; comb _ _ = [] in (comb 2 "ABCD", comb 3 [0..3])
20:44:01 <lambdabot>   (["AB","AC","AD","BC","BD","CD"],[[0,1,2],[0,1,3],[0,2,3],[1,2,3]])
20:48:23 <byorgey> strager: note that 'cabal install' already does the configure step
20:48:42 <CodeWeaverX> i was gonna ask that too
20:48:45 <CodeWeaverX> heh
20:48:49 <strager> byorgey: Didn't know; thanks
20:49:07 <damo22> how do i install a module i just installed
20:49:14 <damo22> s/install/load
20:49:46 <mzero> you mean like load it so you can play with it in ghci?
20:49:50 <damo22> yes
20:50:00 <mzero>  use   :m + Acme.Missles
20:50:08 <damo22> thanks
20:50:25 <ion> or import Acme.Missiles
20:50:46 <mzero> i'm guessing that is only for 7.4's ghci
20:50:59 <ion> mostawesomedude: I think that matches with the python function’s behavior.
20:51:40 <ion> Just import Foo should work in pretty much any version, but stuff like “import qualified Foo as F” requires 7.something.
20:52:30 <mzero> huh! who knew?
20:56:22 * hackagebot sphinx 0.5.3 - Haskell bindings to the Sphinx full-text searching daemon.  http://hackage.haskell.org/package/sphinx-0.5.3 (GregWeber)
20:56:24 * hackagebot test-framework-th-prime 0.0.1 - Template Haskell for test framework  http://hackage.haskell.org/package/test-framework-th-prime-0.0.1 (KazuYamamoto)
20:57:15 <nyingen> @quote
20:57:16 <lambdabot> WilliamTaysom says: The journey to the dark side begins with the desire for power. In our case the power function
20:58:13 <JoeyA> What's the most concise way to convert [Maybe a] to [a] by taking items until Nothing is reached?
20:58:36 <JoeyA> map fromJust . takeWhile isJust would work, but can we do better?
20:59:56 <ion> catMaybes . takeWhile isJust
21:00:34 <damo22> damn i cant compile a working genex
21:00:36 <damo22> lol
21:02:38 <mzero> > let z (Just a:as) = a:z as; z _ = [] in z [Just 3, Just 2, Nothing, Just 5]
21:02:39 <lambdabot>   [3,2]
21:02:48 <mzero> no better, but only examines each Maybe a once
21:02:53 <byorgey> JoeyA: how about  foldr (maybe (const []) (:)) []
21:03:14 <byorgey> > foldr (maybe (const []) (:)) [] [Just 3, Just 2, Nothing, Just 5]
21:03:15 <lambdabot>   [3,2]
21:03:44 <JoeyA> I like that.
21:03:57 <byorgey> personally I'd probably use ion's solution, but I had fun coming up with mine =)
21:04:11 <JoeyA> > unfoldr (\(x:xs) -> fmap (flip (,) xs) x) [Just 3, Just 5, Nothing, Just 7]
21:04:13 <lambdabot>   [3,5]
21:04:24 <JoeyA> @pl \(x:xs) -> fmap (flip (,) xs) x
21:04:25 <lambdabot> ap (flip (fmap . flip (,)) . head) tail
21:04:29 <byorgey> hah, nice =)
21:04:29 <JoeyA> that's more like it
21:04:59 <JoeyA> I think I'll just add a helper function to my module.
21:05:10 <JoeyA> I'm temped to call it stopAtNothing :: [Maybe a] -> a
21:05:12 <JoeyA> err, [a]
21:05:20 <byorgey> hehe
21:05:45 * byorgey approves
21:05:50 <ion> stopAtNothing :: IO (Maybe a) -> a
21:06:45 <mzero> I think you meant    haltAndCatchFireAtNothing :: IO (Maybe a) -> IO a
21:07:04 <ion> launchMissilesAtNothing
21:07:59 <mzero> atNothing :: IO b -> IO (Maybe a) -> IO a
21:23:30 <nyingen> @quote
21:23:31 <lambdabot> u221e says: I swear, reading Haskell source code is like trying to read a Chinese newspaper
21:24:26 <nyingen> @quote
21:24:26 <lambdabot> syntaxglitch says: writing DRM isn't possible in Haskell, since it doesn't actually do anything useful GHC simply optimizes it away
21:24:43 <nyingen> nice.
21:25:33 <WEEDSTOAR> @quote
21:25:33 <lambdabot> SteveYegge says: But I'll argue that Accessibility is actually more important than Security because dialing Accessibility to zero means you have no product at all, whereas dialing Security to zero
21:25:33 <lambdabot> can still get you a reasonably successful product such as the Playstation Network.
21:26:05 <WEEDSTOAR> I find the location of the analogue sticks on the PS controller a bit flawed
21:26:24 <WEEDSTOAR> But the point is that once you have very long fingers all that stuff starts to feel unoptimal, nice and keyboards in general too.
21:27:42 <nyingen> @quote
21:27:42 <lambdabot> hiredman says: I used to think "dons" was a title, like people who were recognized as being really good at haskell were called dons
21:27:48 <nyingen> heh
21:36:41 <hpaste> DanBurton pasted “Yesod install, downgrades?” at http://hpaste.org/57561
21:38:08 <DanBurton> Question about cabal-dev ^
22:07:00 <yitz> DanBurton: cabal-dev won't break your ghc package db outside of the cabal-dev sandbox
22:07:37 <yitz> DanBurton: it means "new version" relative to what is currently in the sandboxed package db, inside the cabal-dev directory
22:08:18 <DanBurton> yitz: so I can safely cabal-dev it, and then see if the sandbox is broken or not?
22:08:59 <yitz> DanBurton: it *can* break the sandboxed package db. in which case you rm -r cabal-dev and the next time you cabal-dev install it builds all the deps again from scratch
22:09:05 <yitz> DanBurton: yes
22:09:15 <DanBurton> nice
22:09:47 <yitz> DanBurton: yes nowadays after a ghc install i cabal install cabal-dev, and then never use regular cabal again
22:10:44 <yitz> DanBurton: although it's not all that bad outside the sandbox either. you just reinstall ghc and hp and build everything again. it doesn't take that long either.
22:11:00 <DanBurton> I just use Haskell for fun; very very rarely working on a cabalized project, so cabal-dev is a bit unnecessary for me most of the time
22:11:43 <DanBurton> but I'd rather not reinstall ghc/hp just because a stray yesod dependency decides to screw things up :)
22:11:55 <yitz> DanBurton: why not cabalize, even for fun projects? it automates so many things.
22:12:12 <DanBurton> less convenience with ghci
22:12:18 <DanBurton> I'm talking little tiny scripts
22:12:25 <DanBurton> rather than "large" fun projects
22:14:05 <yitz> DanBurton: it's usually not less convenient for ghci either. in certain specific situations it's *slightly* less convenient
22:14:38 <yitz> DanBurton: and that's only for "large" fun projects :)
22:14:41 <DanBurton> do you know of any good "how to cabalize for noobs" tutorials?
22:14:50 <yitz> cabal init
22:15:15 <yitz> then edit the cabal file, following the instructions in the comments.
22:15:21 <sbagley> So I accidentally joined #haskelll and I was like, why is there nobody here?
22:15:38 <yitz> sbagley: yeah quiet today
22:15:47 <DanBurton> eerily quiet
22:15:53 <sbagley> ? too quiet.
22:16:06 <sbagley> So anyway, I'm kind of a noob, and I'm trying to figure out the bang operator.
22:16:59 <sbagley> I decided it would be fun to write a heap, and use it to heapsort things. But when I try to build a tree by foldl' pushing a big list (like, say, [1..10000]), I'm murdering my stack because it's building up too big of thunks.
22:17:04 <DanBurton> "the bang operator" as in BangPatterns?
22:17:20 <sbagley> Yeah, that's what I meant.
22:17:57 <yitz> sbagley: it's not an operator. it's syntax that marks a data type parameter or function parameter as "strict", i.e., apply seq to it just before constructing the data object or evaluating the function.
22:18:31 <sbagley> I feel like if I sprinkle my push code semi-liberally with bang patterns, it will fix the problem of my thunks getting too big, but I don't really know where I can put them.
22:18:44 <yitz> BangPatterns just extends that syntax, which is always available for data constructors, to all function declarations.
22:19:02 <yitz> sbagley: oh no don't do that
22:19:05 <DanBurton> sbagley: I have doubts about the necessity of strictness in this case.
22:20:32 <yitz> sbagley: learn about what "call by need" means, so you'll understand what order the ghc runtime evaluates things. then you'll immediately recognize the unusual situation where you need to add strictness.
22:21:11 <sbagley> Okay. Do you have a suggestion on where I can read about "call by need"?
22:21:43 <DanBurton> sbagley: I recommend posting a question to StackOverflow asking why your particular case causes memory problems, and how/whether strictness could help
22:22:33 <sbagley> DanBurton: I'm kinda intimidated by StackOverflow >_>
22:22:50 <DanBurton> looks like wadler has a whole page of papers: http://homepages.inf.ed.ac.uk/wadler/topics/call-by-need.html
22:23:28 <DanBurton> sbagley: don't be :) as long as you put some effort into making a clear question, I think you'll find the experience quite rewarding
22:24:26 <DanBurton> speaking of stackoverflow: http://stackoverflow.com/questions/5526059/what-is-call-by-need
22:24:50 <damo22> otters: i found a regexp that will do what i want: ^(?!.*[A-Z]{2}|.*[a-z]{2}|)[hH][eE][lL][lL][oO]$
22:25:08 <damo22> theres an extra | sorry
22:26:11 <sbagley> I mean, yes, I have a basic idea of the difference, but I'm not entirely comfortable with the notion of thunks, and when thunks get out of control.
22:26:18 <yitz> sbagley: there's not much to it really. things get evaluated... well, when they are needed, not before. try starting with an expression and evaluating it by hand on paper step by step, starting with the outermost operation, replacing each subexpression with its value only when needed.
22:28:35 <DanBurton> @where revdeps
22:28:36 <lambdabot> "Show reverse dependencies" at <http://hackage.haskell.org/trac/hackage/ticket/576>,"Hackage with Reverse Dependencies" by Roel van Dijk at <http://bifunctor.homelinux.net/~roel/hackage/packages/
22:28:36 <lambdabot> hackage.html>,"Reverse Dependencies" at <http://bifunctor.homelinux.net/~roel/hackage/packages/archive/revdeps-list.html>,<http://packdeps.haskellers.com/reverse> -- `bifunctor.homelinux.net' is
22:28:36 <lambdabot> broken, use `81.26.216.99' instead
22:29:44 <yitz> sbagley: the way i remember it is that sum needs to be defined as foldl' (+) 0 not foldl (+) 0. (although in practice ghc's strictness analyser gets that simple case right)
22:29:48 <yitz> @src foldl
22:29:49 <lambdabot> foldl f z []     = z
22:29:49 <lambdabot> foldl f z (x:xs) = foldl f (f z x) xs
22:29:53 <yitz> @src foldl'
22:29:53 <lambdabot> foldl' f a []     = a
22:29:54 <lambdabot> foldl' f a (x:xs) = let a' = f a x in a' `seq` foldl' f a' xs
22:30:30 <yitz> sbagley: think of how those two versions are evaluated step by step and you'll see what happens.
22:34:12 <damo22> ok can someone help me how to install a good haskell environment so i can compile regex-genex?
22:34:14 <yitz> DanBurton: cabal and cabal-dev have their own ghci command, which is often convenient
22:34:25 <damo22> i have purged all my haskell from my system
22:34:26 <yitz> but not always
22:34:43 <yitz> damo22: install the haskell platform
22:34:50 <damo22> i am running ubuntu
22:35:27 <damo22> yitz: the haskell platform?
22:35:29 <DanBurton> damo22: which ubuntu, the latest?
22:35:44 <yitz> @where haskell platform
22:35:44 <lambdabot> http://haskell.org
22:35:48 <yitz> nah
22:35:53 <damo22> DanBurton: i am running 11.04
22:35:56 <yitz> @google haskell platform
22:35:59 <lambdabot> http://www.haskell.org/platform
22:36:00 <lambdabot> Title: Download Haskell
22:36:23 * hackagebot wxdirect 0.13.1.2 - helper tool for building wxHaskell  http://hackage.haskell.org/package/wxdirect-0.13.1.2 (KidoTakahiro)
22:36:25 * hackagebot wxcore 0.13.2.1 - wxHaskell core  http://hackage.haskell.org/package/wxcore-0.13.2.1 (KidoTakahiro)
22:36:26 <DanBurton> you will probably be ok going with "apt-get install haskell-platform"
22:36:27 * hackagebot wx 0.13.2.1 - wxHaskell  http://hackage.haskell.org/package/wx-0.13.2.1 (KidoTakahiro)
22:37:10 <damo22> i dont particularly want to compile everything from scratch, the ubuntu maintainers should have made some decent binaries right?
22:37:30 <damo22> DanBurton: ok i will try that
22:38:30 <damo22> happy i386 lol
22:40:28 <DanBurton> hrm looks like natty has a rather old HP, hope 2010 isn't too old for you
22:41:03 <yitz> damo22, DanBurton: yeah i'm on ubuntu. i prefer installing via the download, not via apt.
22:41:35 <DanBurton> apt has a pretty new version for Ubuntu 11.10
22:41:43 <damo22> ah i see
22:42:10 <damo22> im too lazy to do a clean install of my OS everytime they bring out a new version
22:42:56 <DanBurton> I use Ubuntu in a VirtualBox, so I made a whole new box to install the new GHC on :)
22:43:07 <DanBurton> also trying out xmonad
22:43:11 <damo22> thats not a bad idea
22:43:38 <zzo38> How to make a safe Haskell virtual machine?
22:43:56 <DanBurton> boo...virthualenv requires base <4.5 :(
22:45:13 <DanBurton> I think I'm going to email some people tomorrow, the new GHC is out and packages should hurry up and get compatible! >,<
22:45:23 <Rmx> hey
22:45:28 <Rmx> instead of virtualhenv,
22:45:43 <Rmx> you can try to use cabal-src-install ***
22:46:13 <Rmx> frhttp://www.yesodweb.com/blog/2011/11/cabal-src
22:46:20 <yitz> i haven't tried virtualhenv, i've been satisfied with cabal-dev. does virtualhenv offer any advantages?
22:46:23 <DanBurton> I was checking out the yesod github page, which recommends both, actually
22:46:41 * ddarius woke up and read 2:17 as 7:17.
22:46:52 <yitz> ddarius: go back to sleep
22:46:57 <Rmx> if the aim is only to avoid dependency hell, it might do the trick
22:47:09 <DanBurton> ddarius: early riser?
22:47:33 <ddarius> yitz: I already got ready for work.  I was about to drive to work when I realized my car clock was saying 3-something (because I never adjusted it for daylight savings.)
22:47:48 <ddarius> It did explain why it seemed way more peaceful than a typical 7-8 in the morning.
22:48:18 <DanBurton> virthualenv works by changing your shell, which is apparently more convenient "to work on multiple packages at once"
22:48:32 <zzo38> Which are best ways for safe Haskell virtual machines?
22:48:48 <yitz> DanBurton: i work on multiple packages at once in cabal-dev without too much trouble
22:48:49 <DanBurton> zzo38: huh?
22:50:00 * DanBurton cannot imagine waking up at 2 and thinking it was 7. Probably because he doesn't usually wake up until well past 7 anyways...
22:50:25 <zzo38> DanBurton: I want to be able to run Haskell programs in a virtual machine which cannot access the outside system
22:50:55 <DanBurton> zzo38: for personal use, or for production use?
22:51:09 <ivanm> zzo38: just get a stock standard VM image, run it in your VM emulator, etc.
22:51:21 <DanBurton> for personal use, I use VirtualBox
22:51:37 <zzo38> DanBurton: For production use
22:51:45 <DanBurton> there's nothing really Haskell-specific about it
22:52:01 <DanBurton> although theoretically you can strip the VM of the operating system and just have it run the raw Haskell
22:52:16 <zzo38> I mean a virtual machine such as Java, Glulx, and so on...
22:53:37 <DanBurton> I'm not really sure what you mean; I'm no expert in the area
22:53:45 <DanBurton> but I highly recommend StackOverflow
22:54:02 <ivanm> never heard of Glulx
22:54:02 <ivanm> GHC has LLVM backend
22:54:02 <ivanm> but I don't think that's what you want
22:54:02 <damo22> *** Exception: Backend solver complains:
22:54:02 <damo22> fd:8: hFlush: resource vanished (Broken pipe)
22:54:18 <ivanm> zzo38: why do you want a VM?  GHC compiles to native binaries!
22:54:38 <ivanm> using a VM like Java's won't stop it from accessing the outside system...
22:54:50 <ivanm> after all, Java code can do system I/O
22:54:55 <ivanm> unless you're referring to Java applets
22:55:24 <damo22> anyone know how to make regex-genex work? i just installed it cleanly using apt but its throwing a broken pipe
22:55:38 <zzo38> ivanm: I mean, for example, get a Java implementation and modify it to not do system I/O
22:56:01 <zzo38> But I don't specifically mean Java or Glulx, those are examples
22:56:27 <ivanm> why do that?
22:56:47 <ivanm> zzo38: what you *really* want is to be able to sandbox your programs?
22:56:56 <ivanm> if so, get a standard sandbox application like sydbox
22:57:11 <swandance>  :|
22:57:13 <DanBurton> damo22: what exactly *is* regex-genex?
22:57:53 <damo22> DanBurton: its a tool for generating all possible strings which matches a regular expression
22:57:58 <ivanm> damo22: where from?
22:58:01 <ivanm> I don't see it on hackage...
22:58:11 <DanBurton> @hackage regex-genex
22:58:12 <lambdabot> http://hackage.haskell.org/package/regex-genex
22:58:15 <zzo38> ivanm: Not only to be able to sandbox the programs, but also to make the binaries run on multiple platforms
22:58:25 * ddarius hates how people refer to -every- function passed to a function as a "continuation" and as "using CPS."
22:58:26 <ivanm> zzo38: just recompile it...
22:58:28 <DanBurton> ivanm: ^
22:58:40 <ivanm> DanBurton: that doesn't say that it's there
22:58:43 <ivanm> it's just a ++
22:59:00 <ivanm> oh, it is...
22:59:01 <damo22> if it works as i expects, i will be able to generate a custom dictionary for brute forcing passwords quite easily
22:59:09 <damo22> s/s//
22:59:09 <ivanm> why didn't Firefox's C-f find it before then? :s
22:59:28 <ivanm> damo22: do you have yices installed?
22:59:34 <ivanm> http://hackage.haskell.org/packages/archive/regex-genex/0.3.2/doc/html/Regex-Genex.html
22:59:45 <damo22> i think i have the wrong version installed, im trying that now
22:59:58 <DanBurton> ivanm: typo? http://hackage.haskell.org/packages/archive/pkg-list.html#cat:regex
23:00:00 <Eduard_Munteanu> Hm, that sydbox thingy looks interesting.
23:00:02 <ivanm> zzo38: there is no real working VM-based implementation of Haskell
23:00:02 <ivanm> and there's no real interest in one
23:00:05 <ivanm> since none of the existing VM's capture how Haskell works
23:00:10 <ivanm> DanBurton: yeah, I must have
23:00:14 <zzo38> ivanm: That will be slow and require compile to every system, and sydbox is Linux only anyways, and so on
23:00:28 <zzo38> But I do mean, it could make a new one; it does not necessarily have to be an existing one
23:00:44 <ivanm> zzo38: sure, are you going to write an entirely new VM from scratch?
23:00:50 <ivanm> and compilation isn't *that* slow
23:00:53 <zzo38> ivanm: I don't even know how
23:00:58 <ivanm> kinda my point
23:01:02 <yitz> ivanm: there is interest and there is a need. but it's hard, and no one is working on it afaik.
23:01:43 <ivanm> yitz: yeah, but just blindly saying that there should be one doesnt exactly help
23:02:17 <zzo38> (In case you don't know, Glulx is a virtual machine for text-adventure games; so is Z-machine and TADS3. But there are other virtual machines such as Java and BEAM and so on, as well.)
23:02:31 <yitz> ivanm: i'm actually surprised that MS doesn't put more pressure on the ghc team to make sure that this exists.
23:02:34 <ivanm> so it's an interpreter for a specific format, not actually a VM
23:02:41 <ivanm> BEAM is the erlang one?
23:02:50 <ivanm> yitz: I thought MS didn't care what MSR folks did
23:02:58 <MostAwesomeDude> zzo38: Virtual machines aren't necessarily secure or sandboxable. People have yet to demonstrate a useful and secure Python VM, for example.
23:03:36 <ddarius> yitz: Why would Microsoft care at all?
23:04:29 <yitz> ivanm: right apparently not
23:04:29 <Eduard_Munteanu> Arguably the JVM has well-defined semantics and you can verify bytecode for correctness.
23:04:33 <zzo38> ivanm: Yes, BEAM is the Erlang one. What do you mean "so it's an interpreter for a specific format, not actually a VM"?
23:04:46 <companion_cube> MostAwesomeDude: doesn't pypy provide that?
23:05:06 * DanBurton wishes he could magically fix all of the deprecation warnings and outdated dependencies on hackage
23:05:11 <ivanm> zzo38: it's not a VM for an actual programming language, which makes it easier
23:05:13 <zzo38> I would agree TADS2 is "not actually a VM", though. TADS3 is different from TADS2, though.
23:05:42 <yitz> ddarius: they are funding the research, you would think they would want to get direct benefit from it where that doesn't interfere much with the goals of the research
23:05:43 <MostAwesomeDude> companion_cube: Not really.
23:06:01 <MostAwesomeDude> I mean, there's a theoretical sandbox, but it doesn't have super-fine ACLs and it slows things down quite a bit.
23:06:05 <ddarius> yitz: How does having the Simons make a VM for Haskell directly benefit Microsoft?
23:06:14 <MostAwesomeDude> AFAIK, the best sandbox out there for Python is geordi. :3
23:06:14 <ivanm> yitz: I see it more as "here's a bunch of money, go do cool stuff with it!"
23:06:15 <ivanm> same as any kind of pure research at a uni, etc.
23:06:33 <ivanm> (it's _fun_ trying to explain to business people that there's no actual real-world application of my work... :s)
23:06:35 <ddarius> (Not to mention the opportunity cost.)
23:06:42 <ivanm> ddarius: agreed
23:07:10 <damo22> It requires the @yices@ binary in PATH;  where is PATH is that the system environment variable?
23:07:17 <Eduard_Munteanu> Kinda funny considering how companies invent new languages these days.
23:07:23 <ivanm> damo22: echo $PATH
23:07:26 <ivanm> (on *nix)
23:07:29 <yitz> ivanm: yeah. which is nice. but they're not even getting the benefit from *that*, which is good PR from the fact that they are doing it.
23:07:31 <zzo38> Can you remove unsafe operations from a program which has been converted to GHC Core, and convert that into a binary intermediate format which becomes JIT compiled?
23:07:51 <MostAwesomeDude> zzo38: What about the side effects of those operations?
23:07:51 <ivanm> zzo38: there has been some work on Haskell -> Java, but not that much
23:07:54 <ivanm> there's also SafeHaskell
23:07:56 <MostAwesomeDude> Or do you turn them all into IO errors?
23:08:05 <yitz> ddarius: well of course it would be to MS's benefit if Haskell's ecosystem interacted better with the .NET ecosystem.
23:08:06 <ivanm> which helps guarantee that it won't go and wreck your system
23:08:27 <ddarius> yitz: Not really.
23:08:28 <DanBurton> ugh. I'm surprised I actually got bitten by the removal of Show as as a superclass of Num >,< building sbv in order to build regex-genex
23:08:39 <yitz> ddarius: ?
23:08:46 <zzo38> MostAwesomeDude: Turn them into compile-time errors or identity functions, whichever is appropriate for each case.
23:09:13 <ddarius> It would be a marginal improvement at best and Microsoft's ecosystem includes development tools so that would a (marginal) potential cost.
23:10:06 <ivanm> DanBurton: yay
23:10:12 <ivanm> that's what you get for being an early adopter :p
23:10:20 <DanBurton> ivanm: ikr :(
23:10:24 <Ragnaroek> ivanm: what you're working on?
23:10:39 <zzo38> ivanm: I have read a few things about Haskell -> Java. SafeHaskell has some restrictions I do not want, and anyways it is working at the source files rather than the Core files.
23:10:43 <ivanm> Ragnaroek: graph generation algorithms
23:10:56 <DanBurton> regarding Haskell -> Java, there's also Frege
23:10:56 <yitz> ddarius: well anyway all that is in the old MS-think. they're changing now, because they have to make it in the mobile space. so widest possible adoption of .NET isn't as much of a priority anymore as it was.
23:11:39 <Ragnaroek> hmm, I like graphs :)
23:11:40 <ddarius> yitz: Okay... I'm not sure how that isn't a point against your argument.
23:12:00 <DanBurton> Frege is a cute little project; I hope it matures to be a serious competitor with comparable JVM languages like Scala and Clojure
23:12:18 <zzo38> Can you compile GHC Core into Frege Core?
23:12:34 <Eduard_Munteanu> Yeah, but why F# though? Moving just certain appealing concepts from Haskell?
23:12:34 <DanBurton> no clue
23:13:01 <DanBurton> Frege is slightly different than Haskell, and I'm not even sure such a thing as "Frege Core" exists
23:13:03 <Eduard_Munteanu> I guess Haskell is a hard sell.
23:13:08 <DanBurton> Frege compiles to Java
23:13:57 <ddarius> Eduard_Munteanu: F# is based on O'Caml.  O'Caml is much closer to the other .NET languages and is/was more widely adopted than Haskell.
23:14:14 <NihilistDandy> O'Caml is also breaking my balls :/
23:14:21 <Eduard_Munteanu> I see.
23:14:29 <yitz> ddarius: my argument was based on the assumption that the wider .NET is used, the more money MS makes. may or may not have been true, but MS believed it.
23:15:31 <yitz> ddarius: which is why i am a bit surprised they never pushed for more interaction between Haskell and .NET. It seems they really did allow MSR to function as totally independent research, to their credit.
23:16:10 <ddarius> yitz: Yes, and I responded to that.  You then said that MS doesn't really care about that and cares about mobile platforms which directly contradicts what you first said and then further weakens your overall argument as Haskell has essentially nothing to offer in the mobile arena currently.
23:16:31 <yitz> ddarius: all true
23:16:44 <zzo38> I know Frege is different than Haskell. But could you still compile GHC Core into it or modify the Frege source codes to have an option to compile GHC Core codes instead of Frege codes?
23:17:01 <companion_cube> ddarius: really? Ocaml is more widely adopted than haskell ?
23:17:04 <ddarius> GHC Core is likely a lot more powerful than Frege.
23:17:21 <mrcarrot> is there any easy way to show an [IO Integer] in ghci? just for debugging (it does not matter if it is a safe way)
23:17:59 <ddarius> companion_cube: It certainly seemed to be the case some odd years ago, and I'd be far from surprised if it is still the case.  The Haskell community is just noisy.
23:18:08 <ddarius> I don't have any kind of statistics though.
23:18:42 <Eduard_Munteanu> :t sequence >=> print
23:18:43 <lambdabot> forall a. (Show a) => [IO a] -> IO ()
23:18:52 <companion_cube> > mapM (liftM show) ([return 1, return 2]::[IO Int])
23:18:53 <lambdabot>   <IO [[Char]]>
23:18:58 <yitz> mrcarrot: an IO Integer is a way to do an action, possibly interacting with the outside world, that will ultimately produce an Integer. How would you propose to show that?
23:19:42 <mrcarrot> yitz: for example: randomList=randomRIO(1,10):randomList
23:19:52 <companion_cube> ddarius: I had the feeling that Ocaml had a few niches (like theorem proving) and haskell was more used for diverse stuff like web
23:19:59 <mrcarrot> and if i have a such list how can i show it in ghci?
23:20:42 <ddarius> companion_cube: See "noisy."  Also, less French.
23:20:51 <Eduard_Munteanu> mrcarrot: what if you had an IO [Integer]?
23:21:10 <companion_cube> sorry for the french
23:22:06 <zzo38> Can make interpreter of GHC Core, somehow?
23:22:17 <ddarius> zzo38: You can just write one.
23:22:21 <Eduard_Munteanu> It's also a bit funny to see them pushing stuff like F*, although it is practical and incremental if you think about it, or at least that's what they think.
23:22:43 <mrcarrot> Eduard_Munteanu: i am actually asking more in general rather than this particular function... but for this particular function you get syntax error if you add :: IO [Integer]
23:22:44 <Eduard_Munteanu> I guess purity and laziness still sounds scary.
23:23:14 <ddarius> Eduard_Munteanu: I don't get the feeling that Microsoft is pushing F#.
23:23:16 <Eduard_Munteanu> mrcarrot: sure, that's not actually the correct type
23:23:39 <yitz> mrcarrot: what do you mean by "show in ghci"? what would you hope to see?
23:23:41 <Eduard_Munteanu> Ah, so it's just another MSR project?
23:23:50 <Eduard_Munteanu> Ok, I guess that makes sense.
23:24:01 <zzo38> ddarius: And, how would such a thing be done? I don't know very well, how to do so. Someone has suggested writing one for Glulx. I especially don't know how to write one in Glulx assembly or Inform. I also don't know how to write one in C. And even in Haskell, I don't know how to write one.
23:24:02 <Eduard_Munteanu> mrcarrot: see what sequence does
23:24:08 <Eduard_Munteanu> :t sequence
23:24:08 <ddarius> Eduard_Munteanu: No, it's not an MSR project at all.
23:24:09 <lambdabot> forall (m :: * -> *) a. (Monad m) => [m a] -> m [a]
23:24:10 <damo22> i have regex working
23:24:11 <damo22> :D
23:24:18 <NihilistDandy> On the subject of ocaml, is anyone here any good with it? I'm feeling a bit idiotic on this homework
23:24:29 <NihilistDandy> It's hard to trade down with languages :(
23:24:29 <mrcarrot> yitz: that each time i write randomList, i would get the computer to print out on the screen the list (and it would have different numbers each time)
23:24:42 <yitz> mrcarrot: but it's not a list of numbers
23:24:51 <yitz> mrcarrot: it's a list of actions
23:25:24 <yitz> mrcarrot: do you want to perform the actions and produce the numbers? then as Eduard_Munteanu says, sequence will do that for you.
23:25:40 <ddarius> Eduard_Munteanu: But C# and VB.NET are very much the "Microsoft" languages.  As someone who has an MSDN subscription, I don't get any feeling of propaganda for F# at all.  In fact, I think I'd be almost completely unaware of F# if I didn't have (minor) outside interest.
23:25:45 <mrcarrot> Eduard_Munteanu: sequence does what i wanted, thanks!
23:26:00 <ddarius> zzo38: I recommend learning.
23:26:27 <yitz> mrcarrot: rather, it will combine the list of actions into a single action. when an expression at the ghci prompt evaluates to a single IO action, ghci performs that action for you and prints the result.
23:27:02 <Eduard_Munteanu> ddarius: ah, no, hardly propaganda. It's just they seem to spend resources on getting stuff out of research and into "production" languages.
23:27:22 <ddarius> Eduard_Munteanu: F# didn't come via MSR.
23:27:26 <Eduard_Munteanu> ddarius: and I actually meant F*
23:28:03 <Eduard_Munteanu> http://research.microsoft.com/en-us/projects/fstar/
23:28:17 <ddarius> Oh, then yes, they do put some effort in that.  Research doesn't mean it can't -ever- have benefit.  There was an STM thing for C# that was tried.
23:29:56 <yitz> ddarius: it did indirectly. it came with Don Syme via MSR.
23:30:14 <yitz> and erik meijer
23:30:22 <Eduard_Munteanu> I know, but it does make me wonder whether some of Haskell's traits aren't still hella scary even for a ML programmer out there.
23:30:37 <zzo38> I don't know how. I would like to write such a thing in C, for various reasons, one is to use it with Glk (a library which cannot be used with Haskell because the main function is part of Glk itself and there are many different implementations of the Glk library too)
23:30:52 <ddarius> s/scary/undesirable/ and sure.
23:31:28 <ddarius> zzo38: You don't know how to learn?
23:31:36 <yitz> ddarius: actually the wikipedia page says that f# came from MSR.
23:32:31 <zzo38> ddarius: In this case I don't know how.
23:32:56 <ddarius> zzo38: I recommend taking up stamp collecting then.
23:34:18 <zzo38> That isn't what I meant...what I meant, I don't know what to look up to help to learn these specific thing
23:34:42 <Eduard_Munteanu> zzo38: mind you're asking Haskell how to embark on a reasonably difficult project, which normally would involve quite a bit of research. We don't even know whether it's viable to put Haskell on top of .NET
23:35:16 <Eduard_Munteanu> s/Haskell how/#haskell how/
23:35:42 <ddarius> zzo38: Finding that is part of the learning process.
23:35:47 <shachaf> @faq Can Haskell answer questions?
23:35:47 <lambdabot> The answer is: Yes! Haskell can do that.
23:36:04 <companion_cube> @faq can lambdabot not answer this question?
23:36:04 <lambdabot> The answer is: Yes! Haskell can do that.
23:36:20 <MostAwesomeDude> @faq Is #haskell really Haskell in disguise?
23:36:20 <lambdabot> The answer is: Yes! Haskell can do that.
23:36:27 <sp3ctum> @faq do i look more like?
23:36:28 <lambdabot> The answer is: Yes! Haskell can do that.
23:37:57 <zzo38> I want to be able to run Haskell programs on some virtual machines for text adventure games. I am not even sure the best way. Partially due to I did not make the Haskell compilers
23:38:33 <ddarius> The Simons didn't make the Haskell compilers before they made the Haskell compilers.
23:38:49 <huangyi> Hello, is `fromEnum` the idiomatic way to transform Word16 to Int ?
23:38:54 <ddarius> No.
23:39:05 <ddarius> Use fromIntegral for all your integral number conversion needs.
23:39:41 <huangyi> Ok, thanks.
23:39:42 <ivanm> zzo38: ummm.... the VMs for text adventure games are designed for DSLs
23:39:51 <ivanm> you can write haskell libraries to help you generate said DSL code
23:40:05 <ivanm> but the DSLs they run typically aren't turing-complete
23:40:13 <Jafet> Haskell, the best DSL
23:40:13 <zzo38> ddarius: But the Haskell compiler is written in Haskell, isn't it?
23:40:20 <ivanm> zzo38: most of it
23:40:56 <zzo38> ivanm: It depend which one. Some are different. Even then, it could be a new one not necessarily an existing one, and it doesn't have to be only text adventure game either.
23:41:22 <ddarius> zzo38: One of them is.
23:41:29 <ddarius> There isn't a "the Haskell compiler."
23:41:34 <ivanm> can you explain *why* you want this?
23:41:40 <zzo38> At what part should you do? Core? Cmm? LLVM? Compile to ARM/x86/whatever and emulate it?
23:41:47 <ivanm> ddarius: well, all the ones that are currently still being hacked on are, aren't they?
23:41:58 <BlazeCoder> For the purpose of simple text adventures, surely you could just use a .NET Language?
23:42:13 <zzo38> I don't want to use .NET
23:42:27 <ddarius> ivanm: I believe so.  HBC was originally written in LML, though that hardly counts.  YHC started in Lisp.  Hugs was always C.
23:42:30 <zzo38> I don't really want Java either, actually
23:42:31 <ivanm> possibly an LLVM output would work, and allow you to let other languages that support LLVM also output to your VM
23:42:55 <zzo38> ivanm: Yes, that would do, I suppose.
23:43:07 <ivanm> zzo38: but why do you want *Haskell* code running on a *text-adventure VM*?
23:43:20 <zzo38> I also would like LLVM->MMIX and Haskell->MMIX too; but that is something entirely different.
23:43:59 <ivanm> the usual arguments for the JVM or .Net VM is interoperability, etc.
23:44:00 <ivanm> is MMIX actually used for anything?
23:44:18 <zzo38> ivanm: For one thing, I want to try to make a text-adventure game with Haskell. So that you can have working in native and in VM.
23:44:55 <BlazeCoder> Either I'm missing the point or it seems like youre just doing something complicated for the sake of it lol
23:45:05 <zzo38> Java is OK too, I suppose, if it can modify a Java implementation to do the differences I would have needed
23:45:17 <ivanm> BlazeCoder: yeah
23:45:39 <ivanm> zzo38: it would make more sense to write a Haskell combinator library to help write these text adventure games and then output them in the required format
23:45:46 <ivanm> rather than trying to run arbitrary Haskell code
23:47:49 <zzo38> I understand; but, I want to run arbitrary Haskell codes. (It doesn't necessarily have to be an existing text-adventure VM, though)
23:49:44 <zzo38> But it is OK if some functions such as unsafePerformIO don't work, and even if none of the I/O operations work.
23:53:57 <frerich> koos: No, not at all - but it didn't attempt to.
23:56:24 * hackagebot Ebnf2ps 1.0.8 - Peter's Syntax Diagram Drawing Tool  http://hackage.haskell.org/package/Ebnf2ps-1.0.8 (PeterThiemann)
23:58:57 <damo22> inside these: " " are there any special characters that get interpreted by haskell?
23:59:05 <damo22> when storing a string
23:59:25 <damo22> from :main "STRING"
