00:09:47 <elliott> Is there a simple way to upgrade a package and every package depending on it? Or at least get a list somehow? Do I just have to resort to a reverse-dependencies tool?
00:10:08 <olsner> hmm, isn't that what cabal-install does by default?
00:10:19 <elliott> Even for "cabal install <pkg>"?
00:11:37 <olsner> that's what I recalled, yeah ... but I might be wrong if that isn't what it does :)
00:11:46 <elliott> well, let's find out :)
00:16:23 <elliott> olsner: nope.
00:16:40 <elliott> there's the useless --upgrade-dependencies but no --upgrade-dependents :|
00:18:35 <olsner> oh, "... and every package depending on it"! I read that backwards
00:18:48 <elliott> heh
00:19:15 <olsner> delete ~/.cabal and install everything again? :>
00:19:20 <elliott> --upgrade-dependencies just upgrades a bunch of packages you probably don't care about and of course will try and upgrade core packages
00:19:29 <elliott> --upgrade-dependents otoh is the only reasonable upgrade behaviour
00:19:39 <elliott> olsner: tempting, especially since it turns out i have broken packages :/
00:19:50 <olsner> --upgrade-dependents-and-uninstall-old-version
00:20:45 <elliott> ghc 7.4 should come out already to give me a good excuse
00:30:02 <Phlogistique> @pl \abcd a (b c) (b d)
00:30:03 <lambdabot> (line 1, column 12):
00:30:03 <lambdabot> unexpected "c"
00:30:03 <lambdabot> expecting operator or ")"
00:30:09 <Phlogistique> @pl \a b c d -> a (b c) (b d)
00:30:09 <lambdabot> join . ((flip . ((.) .)) .) . (.)
00:30:17 <Phlogistique> @pl \b a c d -> a (b c) (b d)
00:30:17 <lambdabot> flip =<< ((flip . ((.) .)) .) . flip (.)
00:30:37 <Phlogistique> isn't there no shorter name for this function?
00:31:39 <Phlogistique> @hoogle (a -> a -> b) -> (c -> a) -> c -> c -> b
00:31:40 <lambdabot> Data.Function on :: (b -> b -> c) -> (a -> b) -> a -> a -> c
00:31:40 <lambdabot> Data.Data gmapQr :: Data a => (r' -> r -> r) -> r -> (forall d. Data d => d -> r') -> a -> r
00:31:40 <lambdabot> Data.Data gmapQl :: Data a => (r -> r' -> r) -> r -> (forall d. Data d => d -> r') -> a -> r
00:32:07 <Phlogistique> oh!
00:32:17 <MostAwesomeDude> I was gonna say that this reminds me a lot of `on`.
00:32:58 <ddarius> @pl ap f g x
00:32:58 <lambdabot> f x (g x)
00:33:37 <ddarius> @pl const x y
00:33:37 <lambdabot> x
00:34:37 * ddarius will go to sleep now, but later ...
00:34:49 <mmaruseacph2> lambdabot @t ap
00:35:53 <Phlogistique> though I'm unsure if "((==) `on` extTrickTrick) t1 t2" is really that much better than "extTrickTrick t1 == extTrickTrick t2"
00:35:56 <MostAwesomeDude> :t ap
00:35:57 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m (a -> b) -> m a -> m b
00:36:29 * hackagebot fast-logger 0.0.2 - A fast logging system  http://hackage.haskell.org/package/fast-logger-0.0.2 (KazuYamamoto)
00:38:06 <randomclown> is there a way to declare a function as infix?
00:38:21 <randomclown> or are stuff like == just special
00:38:59 <frerich2> randomclown: I think anything with a non-alphanumeric name is infix by default, like (==) or ($) or so
00:39:34 <frerich2> randomclown: Disclaimer: there is probably an actual rule which is more precise than 'non-alphanumeric name', but this is what I gathered from reading code :-}
00:40:15 <randomclown> hm ok
00:40:15 <mjrosenb> frerich2: and : is a "capital" non-alphanumeric character :-p
00:40:30 <MostAwesomeDude> Declaring them with () and the infix notation.
00:40:42 <MostAwesomeDude> @src (==)
00:40:43 <lambdabot> x == y = not (x /= y)
00:40:52 <mjrosenb> randomclown: you can change the precedence level of any symbol (including non-infix symbols)
00:40:54 <MostAwesomeDude> :t (==)
00:40:55 <lambdabot> forall a. (Eq a) => a -> a -> Bool
00:41:34 <randomclown> so this method definition x == y = not (x /= y)
00:41:53 <randomclown> could be written as (==) x y
00:42:09 <randomclown> but they wrote x == y because it is more confusing that way
00:42:18 <MostAwesomeDude> They wrote it that way because it's infix.
00:42:43 <randomclown> doesn't brackets make it not infix?
00:43:24 <kallisti> randomclown: yes they're interchangeable
00:43:27 <kallisti> the prefix and infix notations.
00:44:22 <elliott> randomclown: More like less confusing.
00:46:08 <randomclown> x == y = dunno man, all the equal signs
00:46:41 <MostAwesomeDude> randomclown: $ doesn't have equal signs.
00:47:01 <qqMuppetpp> http://www.haskell.org/haskellwiki/Keywords#infix.2C_infixl.2C_infixr
00:47:37 <kallisti> randomclown: our minds have been twisted by Haskell to the point that such notation is completely mundane. :P
00:48:03 <kallisti> move along, nothing to see here.
00:57:28 <unknownwarrior> errormessage: Couldn't match expected type `[Char]' with actual type `IO [String]'
00:57:39 <unknownwarrior> do you know how i have to change the input list?
00:58:15 <randomclown> extract the value out of the monad
00:58:21 <randomclown> (show some code)
00:59:00 <unknownwarrior> i got this function getLines = liftM lines . readFile and its used like this : list <- getLines "pbl.hs".
00:59:05 <unknownwarrior> and now i want to go through the list
00:59:44 <unknownwarrior> but i get this error ;)
01:00:48 <randomclown> don't do the lines until you have extracted contents
01:02:24 <unknownwarrior> randomclown: sorry but i dont understand what you mean. so you say i should take the result of readFile as a list?
01:03:24 <randomclown> why not do this instead data <- readFile; return (lines data)
01:03:31 <randomclown> in your getlines
01:04:06 <randomclown> so you get IO [String] as the return for getLines
01:04:28 <randomclown> unknownwarrior:
01:05:09 <neutrino> hello
01:05:13 <randomclown> so then you can get the list out of the monad
01:05:36 <unknownwarrior> okey i tried to do what you said but i made some mistake
01:05:43 <unknownwarrior> test = lines (readFile "pbl.hs") ?
01:05:47 <neutrino> i have a date and time of the format (YY, MM, DD, hh, mm, ss). i am struggling to convert this to a unix timestamp. any tips?
01:05:58 <randomclown> let me write this up
01:09:02 <elliott> unknownwarrior: it should be liftM lines readFile
01:09:09 <elliott> oh, hmm
01:09:16 <elliott> unknownwarrior: right, your getLines is perfectly OK
01:09:21 <elliott> as is your bind of it, so it's somethingw rong with the code after it
01:10:18 <unknownwarrior> elliott: hi elliott
01:10:26 <unknownwarrior> elliott: i try to use it like a list
01:10:52 <unknownwarrior> elliott: and i get the error that it is of the type IO String iinstead of what i expect, a list of chars
01:10:59 <randomclown> http://hpaste.org/57265
01:11:05 <randomclown> unknownwarrior: there you go
01:11:31 <unknownwarrior> randomclown: wow thanks, give me a second
01:11:38 <Jafet> We need a kmc to set this straight!
01:12:38 <randomclown> ahah too much ruby
01:12:43 <randomclown> i used # as comments instead of --
01:12:45 <randomclown> god I'm retarded
01:13:05 <Jafet> I don't think it's wise to complain to god about that
01:14:01 <unknownwarrior> he says he doesnt like main = do     let list <- getLines (readFile "pbl.hs")  the "<-"
01:14:33 <randomclown> lol who
01:14:45 <elliott>     let list <- getLines (readFile "blah")
01:14:51 <elliott> randomclown: that's not even valid syntax
01:14:57 <elliott> and won't work with the getLines function unknownwarrior defined
01:15:36 <elliott> unknownwarrior: the original code you showed us was fine, we just need to see the rest
01:15:42 <elliott> since there was some error later on
01:15:42 <unknownwarrior> can i do it like this: list = getLines (readFile "blah")
01:15:53 <unknownwarrior> elliott okey
01:15:57 <randomclown> yesh
01:16:00 <randomclown> don't write the let
01:16:08 <Jafet> http://hpaste.org/57266
01:16:11 <elliott> no, "list = getLines (readFile "blah")" is also broken
01:16:19 <elliott> one, it has to be <-, two, getLines isn't used like that
01:16:27 <randomclown> but I had <-
01:16:36 <randomclown> only the let wasnt supposed to be there
01:16:36 <elliott> Jafet: additionally, data is not a valid variable name ;)
01:16:48 <elliott> randomclown: well, getLines isn't of type IO String -> IO [String], so it still won't work :P
01:16:55 <Jafet> Screw the rules
01:17:24 <Jafet> unknownwarrior: is (readFile "blah") a string?
01:17:26 <unknownwarrior> so thats what i will do with the list of lines of the file .. search "" = putStrLn "" search (x:xs) 	| x == "--a" 	= do
01:17:27 <randomclown> oh lord let me actually run it
01:18:06 <unknownwarrior> Jafet: i dont know it seems to be io string but i want a string
01:18:17 <elliott> Jafet: No.
01:18:34 <gienah> an idea: getLines f = readFile f >>= return . lines
01:18:35 <elliott> Honestly, unknownwarrior's original code was more correct than just about any of the presented corrections so far... the problem is elsewhere.
01:18:49 <elliott> gienah: getLines = liftM lines . readFile was unknownwarrior's, which is equivalent to that.
01:18:55 <unknownwarrior> okey okey guys i will hpaste my whole code including the error code, give me a sec
01:19:17 <Jafet> Hm, perhaps the clown is the one in need of that question.
01:19:56 * frerich2 thinks that with all these warriors and clowns around, my own IRC nick (my actual first name) is a bit lame. I need something cooler.
01:21:04 <frerich2> > (++)  ["dark", "shadow", "night"] <*> ["ghost", "warrior", "ninja"]
01:21:05 <lambdabot>   Couldn't match expected type `a -> b' against inferred type `[a1]'
01:21:09 <Jafet> /nick fxnmchr2
01:21:22 <frerich2> darn IRC client again!
01:21:37 * frerich2 wishes he knew why it keeps eating ''
01:21:42 * frerich2 slaps his forehead
01:21:50 <unknownwarrior> http://hpaste.org/57265 the annotation is my code
01:22:05 <Jafet> > ((++) . ["dark", "shadow", "night"]) <*> ["ghost", "warrior", "ninja"]
01:22:07 <lambdabot>   ["darkghost","darkwarrior","darkninja","shadowghost","shadowwarrior","shado...
01:22:13 <randomclown> http://hpaste.org/57268
01:22:18 <randomclown> unknownwarrior that works
01:22:43 <randomclown> and delete my extra $ too
01:24:31 <unknownwarrior> randomclown: this list that you create looks totally like what i want. so if i now got a function that should go through this list, how do i pass the list to the function?
01:24:43 <randomclown> just do it like normal
01:24:52 <randomclown> it's already extracted
01:25:29 <unknownwarrior> so .. search (getLines $ readFile "pbl.hs")?
01:26:22 <randomclown> unknownwarrior: yes
01:26:29 <bertolo> hey
01:26:36 <bertolo> data Tree a = Null | Node (Tree a) a (Tree a)
01:26:36 <bertolo> instance Show Tree a where
01:26:37 <bertolo> 	show (Null) = "-"
01:26:37 <bertolo> 	show (Tree a b c) = show a++show b++show c
01:26:40 <bertolo> whats wrong  ? -.-
01:27:00 <randomclown> need more brackets
01:27:01 <bertolo> "constructor expected" -.-
01:27:04 <bertolo> how so?
01:27:10 <bertolo> there are only 2 kinds
01:27:12 <bertolo> null or tree -.-
01:27:16 <randomclown> easy way
01:27:28 <randomclown> declare it as data Tree a = Null | Node (Tree a) a (Tree a) deriving (Show)
01:27:29 <randomclown> finished
01:27:38 <elliott> getLines :: IO String -> IO [String]
01:27:39 <bertolo> can you explain?
01:27:41 <elliott> you never want to write code like this
01:28:04 <bertolo> randomclown can you explain ?
01:28:08 <elliott> randomclown's code is _fine_, there is only one problem
01:28:09 <elliott> -- My input to Ghci:
01:28:09 <elliott> -- let list = getLines "pbl.hs"
01:28:14 <elliott> randomclown: that should be list <- getLines "pbl.hs"
01:28:26 <elliott> since getLines "pbl.hs" has type IO [String], since it's an action that reads the lines from the file, you have to extract it
01:28:32 <elliott> rather than just giving it a name
01:28:32 <randomclown> elliott well he can just fis that himself
01:28:40 <elliott> then "search list" will work fine
01:28:59 <bertolo> it doesnt work with deriving
01:29:23 <elliott> bertolo: the problem is instance Show Tree a where
01:29:26 <elliott> but it should work fine with deriving
01:29:35 <elliott> bertolo: you need parens around Tree a
01:30:01 <bertolo> only that?-.-
01:30:22 <randomclown> brackets vs parens
01:30:23 <unknownwarrior> randomclown: calling the function search with this value (getLines $ readFile "pbl.hs") does the same error like before
01:30:54 <randomclown> oh lol let me actually look at the code you are using it with
01:31:22 <unknownwarrior> http://hpaste.org/57268
01:32:02 <unknownwarrior> and i try to call it like this: search (getLines $ readFile "pbl.hs") []
01:33:01 <randomclown> unknownwarrior: here
01:33:02 <randomclown> http://hpaste.org/57268
01:33:21 <elliott> *sigh
01:33:45 <bertolo> it says undefined constructor
01:33:58 <elliott> bertolo: can you hpaste your whole code?
01:34:01 <randomclown> elliott is probably extremely disappointed with me
01:34:03 <bertolo> its 4 lines
01:34:04 <bertolo> data Tree a = Null | Node (Tree a) a (Tree a)
01:34:05 <bertolo> instance Show (Tree a) where
01:34:05 <bertolo> 	show (Null) = "-"
01:34:05 <bertolo> 	show (Tree a b c) = show a++show b++show c
01:34:09 <bertolo> only that
01:34:18 <randomclown> if you derive show delete the rest apart from the data line
01:35:25 <elliott> randomclown: it's just a little silly that you've fixed a part of unknownwarrior's program that wasn't actually broken...
01:36:07 <bertolo> am i supposed to type show (Node a b c) instead?
01:36:07 <randomclown> elliott show me how it is done.
01:36:21 <bertolo> doesnt work either way -.-
01:36:26 <elliott> I'm not sure what "it" even is.
01:36:28 <elliott> bertolo: Yes, you are.
01:36:35 <bertolo> elliott ok
01:36:48 <elliott> Can you hpaste the exact error when you use Node?
01:37:06 <unknownwarrior> randomclown: and how do i call this function?
01:37:15 <bertolo> y i can
01:37:19 <bertolo> link for pastebin please
01:37:37 <bertolo> got it
01:37:43 <randomclown> not sure where the problem is right now
01:38:23 <int> hello I have a question about Data.ByteString.Lazy. Why does the function init have O(n|c) while tail has O(1) ? Shouldn't it be the same?
01:38:41 <bertolo> elliot
01:38:43 <bertolo> http://hpaste.org/57274
01:38:43 <unknownwarrior> randomclown: is just want to know how i have to use "search"
01:38:56 <randomclown> you call it like normal, it need 2 parameters
01:39:17 <unknownwarrior> and what is the first parameter, the one that should be the list of lines of the file? how does it look like?
01:39:22 <elliott> unknownwarrior: http://hpaste.org/57275
01:39:30 <elliott> your program wasn't broken in the first place
01:39:42 <randomclown> process of elimination.
01:39:47 <randomclown> (or retardation)
01:39:56 <elliott> (note that Monad should be Control.Monad, Monad is the old name of the module)
01:40:08 <Botje_> int: random guess: bytestring chunks are stored as lists
01:40:44 <int> could be ..
01:40:45 <bertolo> im so bad at haskell, i study study study and nothing. dumbest haskell coder ever <-
01:40:45 <elliott> it's a strict list
01:40:46 <elliott> but yes
01:40:50 <elliott> it's basically [ByteString]
01:40:58 <elliott> bertolo: oh
01:41:03 <elliott> bertolo: the problem is that you use "show" on values of type "a"
01:41:08 <elliott> but you don't know that they're instances of Show
01:41:13 <elliott> instance (Show a) => Show (Tree a) where
01:41:20 <elliott> means that your instance requires "a" to be an instance of Show
01:41:25 <elliott> (btw, why are you using hugs?)
01:41:38 <bertolo> i use hugs because my teacher tell me to
01:41:39 <BlankVer1e> how to convert from Int to Int64?
01:41:52 <elliott> bertolo: :/
01:41:53 <elliott> BlankVer1e: fromIntegral
01:42:04 <bertolo> elliott switching to Ghc wont make any miracle
01:42:04 <bertolo> lol
01:42:23 <bertolo> so i am expecting a, where a is (tree a)
01:42:35 <bertolo> and i ask him to evaluate a Node and he fails
01:42:36 <bertolo> right?
01:42:50 <elliott> well... no
01:42:50 <bertolo> how can he evaluate Null then
01:42:56 <elliott> that's got nothing to do with it :P
01:43:01 <bertolo> lool
01:43:07 <elliott> you see "show b"?
01:43:13 <elliott> you're using show on a value of type "a"
01:43:17 <elliott> show :: (Show a) => a -> String
01:43:21 <unknownwarrior> thank you, elliott :) also thank you randomclown :*
01:43:22 <bertolo>  ok
01:43:26 <elliott> the problem is, you don't know "a" is an instance of Show!
01:43:33 <elliott> you have to require it with (Show a) => in the instance declaration
01:43:39 <bertolo> -.-
01:43:40 <elliott> since obviously, you can only show trees if you can show the elements of those trees
01:43:59 <bertolo> so i just need to add a constrain -.-
01:44:01 <randomclown> it's always good to have somebody that's not a clown to help you with your things
01:45:08 <elliott> yeah, but I can't generate random numbers!
01:45:22 <bertolo> you should be able..
01:45:37 <bertolo> sorry elliot
01:45:50 <bertolo> you are very kind dude, you always try but i think by brain just reached his limit
01:45:57 <bertolo> forever dumbass <-
01:46:06 <bertolo> and i have exam in 2 hours
01:46:09 <bertolo> omfg
01:46:30 <elliott> the only dumb thing is insisting you're dumb; I miss constraints off instances all the time
01:46:54 <bertolo> i dont understand how adding a constrain can solve it
01:46:56 <bertolo> even if it does
01:47:38 <elliott> bertolo: well, you need an instance of Show for a type to be able to use "show" on it; that's what the instances are for, after all
01:47:46 <elliott> so if you use show on the element type of the tree, you need an instance of Show for that type
01:48:01 <bertolo> ok
01:48:02 <elliott> when you say "instance Show (Tree a)", you're claiming to be able to show a tree with /any/ element type, no matter what it is
01:48:03 <bertolo> i get it
01:48:20 <bertolo> but Tree a is a null or a node
01:48:33 <bertolo> so im recursivly failing lol
01:50:29 <bertolo> elliot you mean i should write to instance show ?
01:50:36 <bertolo> one for Trees, other for Nodes?
01:50:57 <unknownwarrior> http://hpaste.org/57265
01:51:04 <unknownwarrior> elliott http://hpaste.org/57265
01:53:21 <bertolo> solved it
01:56:08 <bertolo> elliot i changed my tree type
01:56:20 <bertolo> instead of Node Tree a a Tree a
01:56:28 <bertolo> i did Node Tree a Int Tree a
01:56:43 <bertolo> and it worked
01:56:55 <bertolo> im still not happy that i had to do this, and i think i got your point
01:56:58 <bertolo> thanks for the help
01:57:45 <elliott> bertolo: ok
01:58:05 <elliott> unknownwarrior: ok, so search's result is a [String]
01:58:07 <elliott> how do you want to print it?
01:58:19 <elliott> (btw, that is going to give matches in /reverse/ order)
01:58:28 <elliott> (and only print once it reaches the very end, rather than incrementally)
01:59:01 <unknownwarrior> elliott: (y i noticed that) i thought search inputlist = outputlist will simply show me the list
02:00:01 <elliott> i don't quite understand what you mean
02:00:31 <unknownwarrior> um okey give me a second
02:01:48 <unknownwarrior> test 0 ys = ys;         test x ys = test (x-1) (ys+1)      example: test 5 0 : 5.
02:01:57 <unknownwarrior> it just outputs the result
02:02:07 <unknownwarrior> i thought this also works for my function search
02:06:30 * hackagebot test-framework 0.5 - Framework for running and organising tests, with HUnit and QuickCheck support  http://hackage.haskell.org/package/test-framework-0.5 (MaxBolingbroke)
02:08:42 <unknownwarrior> elliott: oh you are right i dont show the result
02:08:58 <unknownwarrior> elliott mapM_ putStr (search list []) solves this :)
02:09:02 <elliott> right
02:09:06 <elliott> you probably want putStrLn there :)
02:09:13 <unknownwarrior> ah you are right
02:11:19 <unknownwarrior> elliott: thank you alot, without you (and randomclown) i would not have been able to solve this :)
02:22:57 <zomg> I wonder if I'm just typing things in haskell for the sake of being able to type things =)
02:23:42 <zomg> I'm always creating custom data types for all sorts of stuff when using Haskell when they could be represented as lists of strings or whatever, which is what I'd probably do in some other languages
02:24:14 <zomg> But the type system just works in such a way that it seems like a good idea in haskell
02:25:29 <BlankVer1e> where is ByteString.fromForeignPtr
02:25:32 <BlankVer1e> defined
02:25:52 <zomg> @hoogle fromForeignPtr
02:25:52 <lambdabot> No results found
02:26:17 <Lemmih> Data.ByteString.Internal, I think.
02:26:36 <zomg> Looks that way
02:28:03 <BlankVer1e> http://hackage.haskell.org/packages/archive/bytestring/0.9.2.0/doc/html/Data-ByteString-Internal.html gives a 404
02:29:14 <elliott> see http://hackage.haskell.org/packages/archive/bytestring/0.9.2.0/bytestring-0.9.2.0.tar.gz for the source code
02:38:25 <neutrino> hi
02:38:36 <neutrino> what was that function that you could use to get the type of a value?
02:42:07 <elliott> you can't
02:42:14 <elliott> unless you're trying to use Typeable stuff, but you probably don't want to
02:42:34 <aninhumer> neutrino: if you mean in ghci, you can use :t
02:42:53 <aninhumer> but it's not a function
02:43:16 <neutrino> no i mean a function
02:43:30 <elliott> what are you trying to do?
02:43:31 <neutrino> i am fairly certain there was a function which allowed to do that for debugging
02:43:33 <Saizan> typeOf ?
02:43:38 <neutrino> @hoogle typeOf
02:43:39 <lambdabot> Data.Typeable typeOf :: Typeable a => a -> TypeRep
02:43:39 <lambdabot> Data.Typeable typeOf1 :: Typeable1 t => t a -> TypeRep
02:43:39 <lambdabot> Data.Typeable typeOf1Default :: (Typeable2 t, Typeable a) => t a b -> TypeRep
02:43:50 <neutrino> that is right
02:43:52 <neutrino> thank you
02:44:00 <elliott> why would you use it for debugging?
02:44:04 <elliott> you know the types of every value at compile-time
02:44:10 <elliott> so it's never going to print anything of interest
02:44:18 <neutrino> how do i know the types
02:45:44 <neutrino> it's not always apparent what type something is if there are no type annotations
02:47:00 <neutrino> i have another question: how do i use a type which is an instance of RealFrac to extract a numeric value out of it?
02:47:36 <aninhumer> as in a Num instance?
02:48:42 <neutrino> i want to get a number out of a NominalDiffTime
02:49:02 <elliott> @hoogle realToFrac
02:49:02 <lambdabot> Prelude realToFrac :: (Real a, Fractional b) => a -> b
02:49:05 <neutrino> some sort of fractional number type, any kind that will enable me to later truncate it to an integral type
02:49:20 <elliott> I think truncate will also work(?)
02:49:40 <neutrino> @hoogle truncate
02:49:41 <lambdabot> Prelude truncate :: (RealFrac a, Integral b) => a -> b
02:49:41 <lambdabot> Codec.Compression.Zlib.Internal TruncatedInput :: DecompressError
02:49:41 <lambdabot> System.Posix.Files FileNamesAreNotTruncated :: PathVar
02:49:52 <neutrino> truncate seems to be working well
02:49:53 <neutrino> thank you
03:12:33 <simon> apparently there's Text.Parsec.many and Control.Applicative.many. how do you suggest I most neatly import both without creating ambiguity?
03:12:55 <simon> (I mostly use the infix operators from Control.Applicative, and I use all kinds of stuff I hardly keep track of from Parsec.)
03:14:23 <simon> ah... import ... ((<*), (*>), ...)
03:16:09 <neutrino> sad clown smiley
03:16:14 <elliott> simon: import Text.Parsec hiding (many)
03:16:35 <elliott> there's another one or two clashes iirc but you can just hide them from parsec as you come across them
03:16:39 <elliott> since the Alternative versions are the same
03:16:44 <elliott> (indeed, they originated from parsec's combinators)
03:18:54 <simon> elliott, ah.
03:19:18 <jkramer> Ahoy
03:19:36 <jkramer> Just wondering how to get the hostname part from a Network.URI.URI
03:20:11 <elliott> jkramer: (fmap uriRegName . uriAuthority)
03:20:16 <elliott> :: URI -> Maybe String
03:21:34 * hackagebot mix-arrows 0.2 - Mixing effects of one arrow into another one  http://hackage.haskell.org/package/mix-arrows-0.2 (MiguelMitrofanov)
03:21:41 <jkramer> Isn't authority somehow related to HTTP auth? Sure it's always the hostname?
03:23:14 <jkramer> There's also authority :: URI -> String - is this the same thing?
03:25:20 <elliott> jkramer: I came up with that based on the documentation.
03:25:22 <elliott> Maybe it is.
03:25:38 <elliott> jkramer: authority is deprecated.
03:25:54 <elliott> See http://hackage.haskell.org/packages/archive/network/2.3.0.8/doc/html/Network-URI.html#g:1 and http://hackage.haskell.org/packages/archive/network/2.3.0.8/doc/html/Network-URI.html#t:URIAuth for the fields I derived that from.
03:26:35 <jkramer> Thanks
04:00:39 <elliott> Is there a standard strict list type in a common package anywhere?
04:00:47 <elliott> Strict in the elements, that is, although strict in the spine is fine too.
04:05:25 * frerich2 watches his C++ project crash with an 'iterator types incompatible' assertion and sighs
04:20:41 <mm_freak> if a record field is nonstrict and is not referred to anymore, will the GC delete it?
04:21:18 <shachaf> I doubt it.
04:27:06 <elliott> mm_freak: I suspect the record counts as a reference.
04:27:15 <elliott> mm_freak: I mean, the GC is still following pointers when you get down to it.
04:28:01 <shachaf> elliott: I think mm_freak meant that the code itself doesn't use the accessor for that field, or something along those lines.
04:28:36 <shachaf> But I wouldn't expect that level of interaction between the GC and the code.
04:29:04 <mm_freak> hmm, that's sad
04:29:38 <mm_freak> but it's also weird
04:29:46 <mm_freak> because that would mean that's true for tuples, too
04:29:49 <mm_freak> wouldn't it?
04:30:18 <elliott> Yes.
04:30:27 <elliott> Do you really expect an element of a tuple you hold a reference to, to be freed?
04:30:43 <elliott> I mean, a GC isn't a magic static analysis tool that can tell when you're not going to look at something.
04:31:02 <elliott> It just frees objects that have *no* references.
04:33:07 <gienah> weak references might help: http://www.haskell.org/pipermail/cvs-ghc/2011-October/066528.html
04:35:29 <matthiasgorgens> I want to present some introduction to beginners.  One of the example programs will be a toy-reimplementation of Unix's tail.  Is a queue the rigth data structure, or can you get away with a simple list and some lazyness magic?  I don't want the program to run out of memory on long files.
04:36:18 <elliott> matthiasgorgens: you probably want a Seq
04:36:20 <elliott> from Data.Sequence
04:36:45 <matthiasgorgens> elliott, I'll have a look.  I wanted to present the implementation of the main data structure, though.
04:36:55 <elliott> case Seq.viewl s of _ :< s' -> s' |> c
04:36:59 <matthiasgorgens> elliott, that's why I thought of a queue as two linked lists would be useful.
04:37:11 <elliott> matthiasgorgens: oh. well Seq is a 2-3 finger tree
04:37:25 <matthiasgorgens> elliott, yes, and probably the right thing to use in practice. ;o)
04:37:37 <elliott> which has great asymptotics but probably won't fit on a page :)
04:37:47 <elliott> matthiasgorgens: how would you use two linked lists for tail?
04:38:28 <matthiasgorgens> elliott, data Queue a = Queue {beginning: [a], end [a]}
04:38:36 <matthiasgorgens> When adding, you cons to beginning.
04:38:45 <matthiasgorgens> When taking, you take from head of end.
04:38:54 <matthiasgorgens> If end is empty, you reverse beginning, to make a new end.
04:38:58 <mm_freak> indeed, by empirical evidence the record itself counts as a reference
04:39:08 <elliott> matthiasgorgens: right, that part was obvious :P
04:39:11 <matthiasgorgens> When used in a linear way, this has O(1) for all operations.
04:39:25 <elliott> (that's just a list zipper, methinks)
04:39:30 <matthiasgorgens> elliott, indeed.
04:39:37 <matthiasgorgens> elliott, can be interpreted as a zipper.
04:40:17 <matthiasgorgens> elliott, and with the operations I gave, you can easily make it the zipper on the graph that's a ring.
04:40:21 <matthiasgorgens> i.e. single cycle.
04:40:54 <elliott> right. i was more wondering how you'd do tail with it
04:41:01 <matthiasgorgens> I know how to make zippers also for non-cyclic graphs.  But I don't know how to make zippers for any other cyclic graph that has O(1) in the move-to-an-adjacent-node operation.
04:41:11 <elliott> but fwiw Seq has comparatively poor constant factors so if you can get away with a simpler data structure that's often better
04:41:36 <elliott> (I once used a list zipper like that and Seq gave a massive slowdown -- like 10x+)
04:42:01 <matthiasgorgens> elliott, from the command-line you get how many chars/lines you shall display, you fill your queue from stdin until it has that number, than for each new char/line, you add and remove.  once you hit eof, you output the contents of the queue.
04:42:34 <elliott> matthiasgorgens: right
04:42:35 <shachaf> dmwit++ # category-extras
04:42:46 <matthiasgorgens> That simple queue implementation also comes with recommendations from Okasaki, for these kinds of applications.
04:43:02 <elliott> shachaf: Personally I'll miss the behemoth. :(
04:43:38 <shachaf> elliott: You can always cabal install trifecta if you want the whole thing.
04:43:51 <elliott> :D
04:44:11 <elliott> shachaf: And yet somehow it still manages to reimplement half of them.
04:44:18 <elliott> cabal should support defining the packages you *don't* depend on for packages like trifecta
04:45:06 <matthiasgorgens> any nice recommendations for the push and pop operations of the queue?
04:45:28 <ClaudiusMaximus> > let t xs [] = xs ; t (x:xs) (y:ys) = t xs ys ; tt n xs = t xs (drop n xs) in tt 10 "personally i'd do 'tail' like this"
04:45:29 <lambdabot>   " like this"
04:45:43 <elliott> matthiasgorgens: didn't you just write them?
04:46:39 <matthiasgorgens> elliott, push and pop sounds like stack-stuff, where pop is from the same place as push.
04:47:37 <matthiasgorgens> by the way, wikipedia writes (for mutable data types): "A regular singly linked list only has efficient insertion and deletion at one end. However, a small modification -- keeping a pointer to the last node in addition to the first one -- will enable it to implement an efficient queue."  Can we abuse lazyness or continuations or so for something similar?  (Don't panic, I'll present the double linked list implementation to the newbies.  I'm just int
04:48:24 <elliott> You got cut off at "just int".
04:49:08 <matthiasgorgens> ClaudiusMaximus: does that play nice with garbage collection?
04:50:05 <ClaudiusMaximus> matthiasgorgens: i think so, let me double check on a huge file...
04:51:08 <elliott> That requires lazy IO though. :(
04:51:21 <ClaudiusMaximus> elliott: ah, true
04:51:25 <matthiasgorgens> elliott, lazy IO is probably fine.
04:51:30 <matthiasgorgens> elliott, though I haven't decided on that.
04:51:31 <ClaudiusMaximus> i was using 'interact'
04:51:58 <matthiasgorgens> elliott, it's unfortunately the `standard' way of doing IO, but also one of the least usable for non-toy programs.
04:53:26 <matthiasgorgens> ClaudiusMaximus: I just tried with a very long string (join (replicate 10000 "personally ")) and that worked
04:56:06 <elliott> matthiasgorgens: For some definition of "standard", I guess.
04:56:41 * hackagebot test-framework 0.4.2.2 - Framework for running and organising tests, with HUnit and QuickCheck support  http://hackage.haskell.org/package/test-framework-0.4.2.2 (MaxBolingbroke)
04:57:07 <matthiasgorgens> elliott, it's what beginners usually come across at first, and it's in base or even prelude.
04:57:12 <matthiasgorgens> elliott, it's unfortunate.
04:58:08 <matthiasgorgens> ClaudiusMaximus: analytical, it seems like your approach would require to keep twice the `window' of content around.
04:58:24 <elliott> matthiasgorgens: Well, everyone knows the Prelude sucks :)
04:58:25 <matthiasgorgens> Which is in O(window-length).
04:58:40 <elliott> Isn't tail inherently O(window-length)?
04:59:21 <matthiasgorgens> elliott, yes, but if you take away the veil of the O, ClaudiusMaximus's approach is 2*Windowlength, while you can achieve 1*Windowlength.
04:59:35 <ClaudiusMaximus> i think it only needs 1x the window, because drop shares the tail of the list?
04:59:50 <matthiasgorgens> elliott, though here I am satisfied with anything that's O(window-length) and simple.
05:00:10 <matthiasgorgens> ClaudiusMaximus: hmm, yes, but I though you keep around too much of the beginning?
05:00:13 <matthiasgorgens> ClaudiusMaximus: maybe not.
05:02:17 <ClaudiusMaximus> hGetBuf doesn't seem to play nice with stdin from a fifo :(
05:02:41 <matthiasgorgens> ClaudiusMaximus: Hmm, I think it only needs to keep one bufferlength around.
05:03:44 <matthiasgorgens> ClaudiusMaximus: Though I'll probably stick to the queue-based implementation for my demonstatrion.  That'll show how to use data structures.  Your approach is useful, though.
05:09:33 <jeltsch> > fix error
05:09:33 <lambdabot>   "*Exception: *Exception: *Exception: *Exception: *Exception: *Exception: *E...
05:15:11 <matthiasgorgens> jeltsch: That's not how you fix errors. ;o)
05:18:41 <elliott> > break error
05:18:42 <lambdabot>   Overlapping instances for GHC.Show.Show
05:18:42 <lambdabot>                              ([[GHC...
05:18:46 <elliott> I broke it.
05:20:08 <sipa> :t break
05:20:08 <lambdabot> forall a. (a -> Bool) -> [a] -> ([a], [a])
05:22:46 <BlankVerse> is there anything similar to fromForeignPtr so that I can write a ByteString at a Ptr location?
05:24:00 <BlankVerse> :t Data.ByteString.Internal.fromForeignPtr
05:24:01 <lambdabot> GHC.ForeignPtr.ForeignPtr Word8 -> Int -> Int -> BSC.ByteString
05:24:41 <BlankVerse> I want the reverse ... take a ByteString and write at Ptr
05:25:23 <rostayob> @hoogle ByteString -> IO CString
05:25:23 <lambdabot> Foreign.Marshal.Alloc realloc :: Storable b => Ptr a -> IO (Ptr b)
05:25:23 <lambdabot> Foreign.Ptr castPtr :: Ptr a -> Ptr b
05:25:24 <lambdabot> Foreign.Ptr castFunPtrToPtr :: FunPtr a -> Ptr b
05:25:30 <elliott> BlankVerse: yes
05:25:45 <elliott> http://hackage.haskell.org/packages/archive/bytestring/0.9.2.0/doc/html/Data-ByteString.html#g:25
05:25:46 <rostayob> BlankVerse: http://hackage.haskell.org/packages/archive/bytestring/0.9.2.0/doc/html/Data-ByteString-Unsafe.html
05:26:14 <neutrino> hi
05:26:22 <neutrino> how can i replace this with something simpler? main = sequence_ $ Plot.plot X11.cons names2d : []
05:26:28 <neutrino> main :: IO ()
05:26:33 <rostayob> BlankVerse: right, what elliott said
05:26:42 <neutrino> i have never used sequence_ and am not sure how it plays with the IO monad
05:27:29 <rostayob> neutrino: you can just take the "sequence_" and ": []"
05:27:31 <rostayob> out
05:27:41 <rostayob> main = Plot.plot X11.cons names2d
05:27:46 <rostayob> neutrino: how did you get to write that code?
05:27:56 <BlankVerse> btw , is there something similar to mmapFileByteString in ReadWrite Mode
05:28:17 <neutrino> rostayob: i didn't write it, it's from the examples for gnuplot
05:28:27 <rostayob> is it really? that's a horrible piece of code
05:28:39 <neutrino> well, no, i reduced the demo to just one example
05:28:44 <rostayob> yeah
05:28:50 <rostayob> :t sequence_
05:28:51 <lambdabot> forall (m :: * -> *) a. (Monad m) => [m a] -> m ()
05:28:55 <neutrino> it was like sequence_ $ demo1 : demo2 : ... : []
05:28:59 <rostayob> sequence executes a list of monadic actions
05:29:08 <rostayob> if the action is 1, you don't need it
05:29:17 <neutrino> yes but if i do main = Plot ... then i have the wrong return type.
05:29:31 <neutrino> because notice that sequence_ returns m (), whereas Plot ... returns m a
05:29:46 <rostayob> neutrino: ok, you need to throw away the result, which sequence_ does automatically
05:29:56 <rostayob> main = Plot.plot X11.cons names2d >> return ()
05:30:20 <neutrino> that seems to have worked, thanks
05:30:26 <elliott> neutrino: actually main can have type IO a for any a
05:30:29 <elliott> technically :)
05:30:36 <matthiasgorgens> neutrino, which sequence_ are you using?
05:30:37 <elliott> neutrino: but if you import Control.Monad you can do: void $ Plot.plot ...
05:30:56 <neutrino> from Prelude
05:31:02 <neutrino> thanks elliott
05:31:39 <matthiasgorgens> sequence from Data.Traversable is actually pretty useful.
05:31:55 <matthiasgorgens> though not more useful for your current application, rostayob.
05:32:03 <rostayob> matthiasgorgens: ?
05:32:14 <elliott> sequence_ is from Data.Foldable I think.
05:32:18 <elliott> funny that it's more general than sequence :)
05:32:52 <rostayob> elliott: Data.Foldable has both
05:32:53 <matthiasgorgens> elliott, sequence from Traversable is another generalization of the Prelude function.
05:33:24 <matthiasgorgens> elliott, I can't find sequence in Foldable.
05:33:24 <rostayob> ah, no
05:33:26 <BlankVerse> does haskell's mmap library auto unmap (GC) the non-required mmaps?
05:33:47 <rostayob> matthiasgorgens: elliott was saying that the () version was in Data.Foldable
05:34:06 <matthiasgorgens> Yes, but didn't he say something about "both"?
05:34:23 <rostayob> MoALTz: no, I did, and I was wrong
05:34:27 <rostayob> oops, matthiasgorgens
05:34:30 <matthiasgorgens> oh, you're right.
05:34:34 <rostayob> BlankVerse: which mmap?
05:34:44 <BlankVerse> System.IO.MMap
05:34:52 <rostayob> BlankVerse: yeah but which package there are various iirc
05:34:57 <rostayob> simply 'mmap' right?
05:35:14 <matthiasgorgens> Data.Traversable.sequence is useful when you want IO (Maybe (IO a)) -> IO (Maybe a)
05:35:42 <BlankVerse> rostayob: yep
05:35:49 <rostayob> BlankVerse: "When the garbage collector notices there are no further references to the mapped memory, a call to munmap is made."
05:36:12 <rostayob> you can also add a finalizer yourself, it's in the docs
05:36:37 <elliott> Mathieu: Maybe (IO a) -> IO (Maybe a), surely
05:36:39 <elliott> argh
05:36:41 <elliott> *matthiasgorgens:
05:36:52 <BlankVerse> rostayob: k , thanks
05:37:08 <elliott> <rostayob> elliott: Data.Foldable has both
05:37:13 <elliott> rostayob: I really doubt Foldable has "sequence".
05:37:16 <elliott> It's not powerful enough to.
05:37:21 <rostayob> elliott: yes sorry, I corrected myself
05:37:32 <rostayob> corrected myself correcting you
05:38:28 <hpc> :t flip
05:38:29 <lambdabot> forall (f :: * -> *) a b. (Functor f) => f (a -> b) -> a -> f b
05:40:05 <elliott> rostayob: hehe
05:40:11 <elliott> i should read before replying to pings :)
05:41:47 * hackagebot websockets 0.5.2.1 - A sensible and clean way to write WebSocket-capable servers in Haskell.  http://hackage.haskell.org/package/websockets-0.5.2.1 (JasperVanDerJeugt)
05:43:17 <yitz> > concatMap (++ " correcting ") $ cycle ["rostayob", "elliot"]
05:43:18 <lambdabot>  Terminated
05:43:27 <yitz> > concatMap (++ " correcting ") $ cycle ["rostayob", "elliot"]
05:43:29 <lambdabot>   "rostayob correcting elliot correcting rostayob correcting elliot correctin...
05:44:00 <yitz> > concatMap (++ " correcting ") $ cycle ["rostayob", "elliott"]
05:44:02 <lambdabot>   "rostayob correcting elliott correcting rostayob correcting elliott correct...
05:44:26 <rostayob> yitz: :)
05:44:45 <hpc> > repeat 1
05:44:46 <lambdabot>   [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,...
05:44:55 <hpc> did lambdabot's output get shortened?
05:45:49 <byorgey> looks about the same as usual to me
05:46:15 <hpc> i must just be used to my bot's output, which is 400 characters
05:47:09 <byorgey> lambdabot's output is certainly a bit shorter than 400 characters.
05:47:57 <matthiasgorgens> elliott, just insert join after you've did the sequence.
05:50:10 <elliott> lambdabot is somewhat overly conservative with line limits
05:55:21 <BlankVerse> in the definition of ByteString as PS {-# UNPACK #-}
05:55:28 <BlankVerse> what is the meaning of UNPACK?
05:56:04 <rostayob> BlankVerse: ghc manual
05:56:27 <rostayob> BlankVerse: http://www.haskell.org/ghc/docs/7.2.2/html/users_guide/pragmas.html
06:08:35 <matthiasgorgens> ClaudiusMaximus: Your tail-example re-worked: let tail n (tails -> x) = fst $ last $ zip x (drop n x)
06:08:42 <matthiasgorgens> ClaudiusMaximus: Uses view patterns.
06:09:12 <matthiasgorgens> All the tails are shared.
06:10:13 <elliott> pretty! although using the name tail is probably a bad idea :
06:10:14 <elliott> :p
06:12:07 <matthiasgorgens> slightly better:  tail n (tails -> x) = last $ zipWith const x (drop n x)
06:12:13 <matthiasgorgens> (not the name.)
06:12:26 <matthiasgorgens> but it doesn't construct and deconstruct a tuple.
06:15:16 <hpc> @let tail' n (tails -> x) = last $ zipWith const x (drop n x)
06:15:17 <lambdabot>   ViewPatterns is not enabled
06:15:21 <hpc> :(
06:16:39 <matthiasgorgens> just replace the viewpattern with a let.
06:16:49 <mm_freak> what would that do?  give the second-last element?
06:17:07 <matthiasgorgens> @let tail' n x = let x' = tails x in last $ zipWith const x' (drop n x')
06:17:08 <lambdabot>  Defined.
06:17:18 <mm_freak> > tail' 3 "abcdefg"
06:17:20 <lambdabot>   "efg"
06:17:21 <matthiasgorgens> @tail 10 "what would that do?  give the second-last element?"
06:17:21 <lambdabot> Consider it noted.
06:17:22 <mm_freak> ah
06:17:31 <matthiasgorgens> !tail 10 "what would that do?  give the second-last element?"
06:17:40 <matthiasgorgens> > tail 10 "what would that do?  give the second-last element?"
06:17:41 <lambdabot>   Couldn't match expected type `[GHC.Types.Char] -> t'
06:17:41 <lambdabot>         against inferr...
06:17:46 <matthiasgorgens> > tail' 10 "what would that do?  give the second-last element?"
06:17:47 <mm_freak> > let tail' n = head . drop n . tails in tail' 3 "abcdefg"
06:17:47 <lambdabot>   "t element?"
06:17:49 <lambdabot>   "defg"
06:17:56 <mm_freak> > let tail' n = head . drop (succ n) . tails in tail' 3 "abcdefg"
06:17:58 <lambdabot>   "efg"
06:18:01 <mm_freak> there we go
06:18:20 <mm_freak> ah, no
06:18:23 <mm_freak> forget it =)
06:18:41 <matthiasgorgens> ok. :o)
06:25:37 <mm_freak> ClaudiusMaximus, matthiasgorgens: i question whether lists are the right data structure here…  you should definitely go for Seq or Vector, if you need such a function
06:27:19 <matthiasgorgens> @pl \x -> zipWith const x (drop n x)
06:27:19 <lambdabot> zipWith const `ap` drop n
06:30:03 <matthiasgorgens> mm_freak: actually, I'll be using a queue implemented as a pair of linked list.  I want to re-implement the Unix tail command as an example (among others) for newbies.
06:30:30 <matthiasgorgens> mm_freak: the pair-of-linked-list queues has better performance for this application, _and_ it is very simple to explain.
06:30:50 <matthiasgorgens> mm_freak: though, if you need more complicated operations you are right that Seq or Vector would be really useful.
06:31:57 <marijan> http://www.2shared.com/file/zeC04s1T/cs2d_0119_win_and_Aimbot.html
06:32:29 <elliott> looks legit
06:32:42 <matthiasgorgens> Where's the monad instance for (->) a defined?
06:33:00 <cmccann> Control.Monad.Instances, I think?
06:33:21 <matthiasgorgens> ok.
06:33:24 <rostayob> matthiasgorgens: http://hackage.haskell.org/packages/archive/base/4.4.1.0/doc/html/Control-Monad-Instances.html
06:33:27 <rostayob> too late.
06:33:44 <matthiasgorgens> Yes, works now.
06:35:24 <matthiasgorgens> Strange, it works in ghci, but not in ghc.
06:35:51 <mm_freak> matthiasgorgens: i would be very surprised if any list-based approach has better performance than Seq for arbitrary-length tails
06:35:56 <elliott> isn't it Control.Monad these days?
06:36:21 <elliott> mm_freak: maybe if the tails get larger than anyone would ever want...
06:36:29 <elliott> but Seq's constant factors make lists faster in many cases IME
06:36:32 <matthiasgorgens> mm_freak: I may find out.
06:37:34 <matthiasgorgens> works in ghc.  I was just too dumb.
06:38:19 <matthiasgorgens> @pl \n x -> last $ (zipWith const `ap` drop n) (tails x)
06:38:19 <lambdabot> (last .) . (. tails) . (zipWith const `ap`) . drop
06:38:46 <mm_freak> elliott: for this specific application i can't imagine how a list is faster, except perhaps when you store the items in reverse and never print them individually
06:40:29 <matthiasgorgens> @pl \l  t -> (l .) . (. t)
06:40:29 <lambdabot> (. flip (.)) . (.) . (.)
06:43:53 <Cale> It's strange that GHC 7.4.1 appears to be somehow worse at kind inference when PolyKinds is turned off than 7.2.x was.
06:44:13 <Cale> (It seems to be assuming more aggressively that things have kind * when they're not supposed to)
06:47:26 <matthiasgorgens> mm_freak: How would you implement with Seq?
06:49:29 <dca`> Why does !! for lists have this signature
06:49:29 <dca`> (!!) :: [a] -> Int -> a
06:49:29 <dca`> instead of smth like:
06:49:31 <funktronic> @hoogle fmap
06:49:31 <lambdabot> Prelude fmap :: Functor f => (a -> b) -> f a -> f b
06:49:32 <lambdabot> Data.Functor fmap :: Functor f => (a -> b) -> f a -> f b
06:49:32 <lambdabot> Control.Monad fmap :: Functor f => (a -> b) -> f a -> f b
06:49:32 <dca`> (!!) :: [a] -> PositiveInteger -> a
06:49:35 <dca`> ?
06:49:39 <dca`>  
06:50:05 <cmccann> more like (!!) :: [a] -> Natural -> Maybe a
06:50:21 <dca`> right
06:50:22 <cmccann> but we don't have a standard natural number type
06:50:24 <cmccann> so
06:50:31 <cmccann> oh well?
06:50:37 <dca`> :t (!!)
06:50:38 <lambdabot> forall a. [a] -> Int -> a
06:50:58 <dca`> why don't we have that?
06:51:03 <cmccann> beats me
06:51:08 <cmccann> we should
06:51:11 <srhb> dca`: Bad design choice.
06:51:35 <roconnor> dca`: probably it was thought at the time it would make the Prelude too complex and unsuitable for teaching
06:51:41 <roconnor> dca`: that's my guess
06:51:54 <dca`> [1..12] !! (-1)
06:51:55 * cmccann wonders if this is another one of those cases where people should have listened to augustss years ago
06:52:07 <roconnor> cmccann: did augustss suggest that?
06:52:21 <roconnor> it would be good to have a proper semiring class.
06:52:35 <cmccann> dunno, I just know that more than a few bad design choices in modern Haskell are things he argued against
06:52:55 <cmccann> so it wouldn't surprise me if he'd suggested other sensible things :P
06:53:00 <roconnor> dca`: I feel that there are a lot of things in the prelude "inherited" from lisp/scheme programming styles.
06:53:19 <roconnor> even thought they are not appropriate in haskell.
06:53:33 * cmccann replaces all the partial functions with ones returning Maybe
06:53:58 <dca`> isn't that bad:
06:53:58 <dca`> [1..12] !! (-1)
06:53:58 <dca`> *** Exception: Prelude.(!!): negative index
06:53:58 <dca`> ?
06:54:02 <carpi> the line "fibs@(_:xs) = ..." Is that legally valid?
06:54:06 <matthiasgorgens> http://hpaste.org/57283 has a list-based tail.  Benchmark against a Seq based one, if you look.
06:54:12 <roconnor> cmccann: I must admint making rational division return Maybe does seem like it would be ackward.
06:54:34 <matthiasgorgens> look -> like.
06:54:35 <cmccann> roconnor, unfortunately
06:54:35 <roconnor> dca`: anyhow (!!) is generally an indication of bad code.
06:54:46 <carpi> i mean not the dots
06:55:08 <cmccann> though a NonzeroRational type would have safe division
06:55:10 <matthiasgorgens> carpi, the left hand site is.
06:55:10 <roconnor> cmccann: I think you can only go so far in that direction before you really need proof objects to restore sanity.
06:55:16 <cmccann> but that quickly leads to all kinds of weird boilerplate
06:55:18 <roconnor> cmccann: otherwise you are hand coding run-time checking.
06:55:20 <cmccann> yeah
06:55:39 <cmccann> on the other hand, there's no excuse for head and tail
06:55:43 <cmccann> whatsoever
06:56:01 <carpi> the actual line is "fibs@(_:xs) = 0:1:zipWith (+) fibs xs"... so the in the left hand side, the '@' specifies that what follows is just another name for fibs?
06:56:01 <roconnor> cmccann: ya, I think that is inherited from lisp/scheme style functional programming.
06:56:23 <roconnor> cmccann: so that they feel comfortable jumping into the language.
06:56:45 <elliott> I can't help but believe all these terrible committee decisions have been made for shady reasons unknown to us
06:56:47 <matthiasgorgens> roconnor: they should have avoided success (with Scheme programmers).
06:56:49 <mm_freak> matthiasgorgens: remove first, append last
06:56:51 <elliott> and then covered up as "for beginners"
06:56:55 <roconnor> carpi: OMG, I've never seen that use of patterns before.  It's great!
06:57:04 <matthiasgorgens> mm_freak: what do you mean?
06:57:08 <neutrino> just took a huge ugly function with a lot of lambdas and 5 levels of indentation refactored it to something smaller, letter laid out, and with 2 levels of indentation. feelzgoodman
06:57:15 <elliott> surely they can't have sat there dismantling everything good about haskell 1.4 going "IT'S FOR THE LEARNERS!" at every step and kept a straight face
06:57:15 <neutrino> *better
06:57:18 <cmccann> roconnor, what, using @ and pattern bindings at top-level?
06:57:19 <roconnor> neutrino++
06:57:24 <roconnor> cmccann: ya.
06:57:32 <neutrino> the original function was from the gnuplot demos
06:57:33 <cmccann> roconnor, you can use guards on any definition as well I think
06:57:34 <roconnor> cmccann: I've used top level patterns before, but not @ ones
06:57:49 <matthiasgorgens> roconnor: can also (depends how smart your compiler is, I guess) help performance.  Because the stuff on the right hand site doesn't have to be re-constructed.
06:57:50 <elliott> :t let j@(In (Just a)) = a in j
06:57:51 <lambdabot> Mu Maybe
06:58:06 <matthiasgorgens> neutrino: did you remove all the points? ;o)
06:58:19 <cmccann> roconnor, e.g. "foo | bar > 3 = bar" &c. is valid as a top-level binding
06:58:21 <neutrino> matthiasgorgens: nope
06:58:59 <matthiasgorgens> neutrino: good.  it's always a temptation while cleaning up.
06:59:11 <neutrino> :)
06:59:40 <mauke> :t let In (Just a) = a in a
06:59:41 <carpi> roconnor: i didn't come up with that. I saw it on SO !
06:59:41 <lambdabot> Mu Maybe
06:59:47 <mm_freak> matthiasgorgens: Seq has two ends
06:59:54 <elliott> mauke++
07:00:00 <elliott> > let In (Just a) = a in a
07:00:04 <lambdabot>   mueval-core: Time limit exceeded
07:00:08 <elliott> bet we need some ugly ~ nonsense
07:00:08 <mm_freak> matthiasgorgens: see (<|), (|>), viewl and viewr
07:00:10 <elliott> > let In ~(Just a) = a in a
07:00:14 <lambdabot>   mueval-core: Time limit exceeded
07:00:19 <elliott> > let ~(In (Just a)) = a in a
07:00:23 <lambdabot>   mueval-core: Time limit exceeded
07:00:25 <elliott> wtf?
07:00:31 <elliott> oh, hmm
07:00:54 <matthiasgorgens> mm_freak: I know.  I was just asking for a concrete implementation for benchmarking.
07:01:27 <neutrino> http://hpaste.org/57284
07:01:35 <neutrino> ^ this is what i did
07:02:40 <matthiasgorgens> neutrino: that's the new version, isn't it?
07:02:59 <neutrino> the old version is above, the new below.
07:03:36 <matthiasgorgens> ok.
07:04:06 <matthiasgorgens> oh, you changed the name?
07:04:12 <neutrino> yes
07:05:46 <matthiasgorgens> some changes. ;o)
07:07:12 <neutrino> matthiasgorgens: ?
07:07:23 <neutrino> did i do something wrong there?
07:11:43 <mm_freak> matthiasgorgens: in a concrete implementation i'd use Text or ByteString, two times the desired tail length
07:11:54 <mm_freak> matthiasgorgens: nowadays probably using the conduit library
07:12:36 <matthiasgorgens> mm_freak: ok.
07:12:45 <matthiasgorgens> neutrino: no.  I just changed a bit in your paste.
07:12:48 <matthiasgorgens> http://hpaste.org/57284
07:14:04 <matthiasgorgens> neutrino: It's customary (at least I've seen this idiom a lot) to use f . g . h $ x instead of f $ g $ h $ x.
07:14:13 <matthiasgorgens> neutrino: it's more of an idio than a real advantage.
07:14:30 <elliott> There is an advantage.
07:14:32 <matthiasgorgens> In the line Graph2D.lineSpec (LineSpec.title name $ LineSpec.deflt) I saved you a pair of parens.
07:14:39 <elliott> Try refactoring the latter into a function.
07:14:41 <elliott> Then try the former.
07:14:55 <gwern> so last night while trying to fall asleep I was thinking about how one would investigate the normality of pi (or any distribution, for that matter); the obvious way being to keep a running talley of each digit you see and at the end, see how much each digit count differs from each other; this sounded a little inefficient, so I thought why not keep track of only the differences in the digit count? so you'd have a counter for each digit initialized to 0, ...
07:15:01 <gwern> ... and each time a digit comes up, increment the counter, and every time check whether every counter is non-zero; if they are, subtract the smallest counter from each counter (resetting it to 0). thoughts?
07:15:02 <elliott> (Also, (.) has less visual noise, but maybe that's not a real advantage.)
07:16:15 <matthiasgorgens> gwern: sure, would work for an empiric investigation.
07:16:53 <gwern> I was wondering if there was some XOR-based approach I was missing because this sounded similar to the old interview question 'you are given an unsorted array of 1..n minus one number; figure it out'
07:17:21 <matthiasgorgens> gwern: Though this way you'll only look at single digits.  the number 0.1234567890123456789... is not normal, but you wouldn't notice this way.
07:17:49 <gwern> that's true
07:17:55 <matthiasgorgens> gwern: interview: n * (n-1) / 2 - sum of array?
07:18:41 <gwern> matthiasgorgens: something like that. the clever answer is to fold the array with xor - whatever falls out was the number
07:19:30 <matthiasgorgens> gwern, so you're doing the sum-of-array in the field of 2, log_2 n times.
07:20:10 <matthiasgorgens> gwern: how would the xor apporach work for n=2?
07:20:15 <matthiasgorgens> gwern, or even n=1.
07:20:21 <tromp_> more challenging: given n+1 numbers in range 1..n, find a duplicate
07:20:22 <matthiasgorgens> gwern, there's something missing to the trick.
07:20:34 <gwern> matthiasgorgens: I can't say I found the problem interesting, so I forgot
07:20:41 <gwern> matthiasgorgens: if you really care, that's enough to google
07:21:19 <matthiasgorgens> gwern, yes, or just think a bit myself.  I see that the XOR will work, from a mathematical point of view.  You can also use a representation in arbitrary bases (not only two) and do some XOR-equivalent operation on those.
07:21:45 <matthiasgorgens> tromp_, is there only one duplicate?  or are the numbers arbitrary?
07:21:55 <tromp_> arbitrary
07:22:05 <matthiasgorgens> tromp_, ok, that's more challenging. ;o)
07:22:23 <matthiasgorgens> I can do it in O(n) space. ;o)
07:22:48 <tromp_> in constant space ( in addition to read-=only  input array) and linear time
07:22:52 <matthiasgorgens> actually, less.  In O(n / ln n) space.
07:23:05 <matthiasgorgens> tromp_, constant space is not possible, but O(ln n) space might be.
07:23:10 <Botje_> tromp_: ah. I was about to suggest swapping each element to its position :P
07:23:22 <matthiasgorgens> assuming that a number x take O(ln x) bits to store.
07:23:53 <tromp_> i mean constant number of words (of size O(log n))
07:24:02 <matthiasgorgens> tromp_: assuming also you read the numbers in one by one (stdin or so), and not as some kind of mmap?
07:24:51 <tromp_> numbers are given in array a[1]..a[n+1]
07:25:00 <matthiasgorgens> tromp_, array is read only?
07:25:03 <tromp_> yes
07:25:11 <matthiasgorgens> that make is easy.
07:25:17 <matthiasgorgens> or easier.
07:26:27 <matthiasgorgens> ah, it's the same trick as the prisoner's and hundred numbered boxes.
07:26:54 <tromp_> same idea but more involved
07:26:55 <matthiasgorgens> trick is (probably) to start with x, then look at a[x], and a[a[x]].
07:27:30 <matthiasgorgens> if there are duplicates, there will be attractors.
07:27:42 <matthiasgorgens> or attractors that have a bigger hinterland than themselves.
07:28:03 <matthiasgorgens> might need another idea to make it work.
07:35:46 <funktronic> when doing cabal install haskeline on os x i get complains about iconv. any ideas how to fix it? i've got the libs and all
07:36:09 <matthiasgorgens> tromp_, got a solution in linear-time and constant word space, if random-reading of the array is allowed.  I believ you can probably improve the constant factors of my solution.  I wonder how much you could achieve with an online algorithm that has to read in numbers from a stream.
07:36:47 <tromp_> i want deterministic solution
07:36:57 <tromp_> array will need to be read more than once
07:38:13 <CodeWeaver1> funktronic: something like this message thread?  http://www.haskell.org/pipermail/haskell-cafe/2009-February/054739.html
07:38:44 <funktronic> CodeWeaver1: doesn't provide a solution from what i can see
07:39:03 <CodeWeaver1> No…. probably not.  Except for the passing remarks about linking against one version of iconv via another.
07:39:18 <CodeWeaver1> I remember building haskeline at one point on OSX, but it was a while ago.
07:39:58 <CodeWeaver1> Huh, it appears that it's already been built by cabal on my 7.2.2 version… maybe as a result of my building something else.
07:40:03 <funktronic> CodeWeaver1: yeah it's a linking failure in gcc
07:40:42 <CodeWeaver1> Maybe find where all the iconv libraries are on your system, and figure out whether or not one or the other of them is causing the problem?  Kinda hardcore to figure that out.  I evidently didn't run into that problem building it with cabal, and I don't know what I can suggest.
07:41:16 <CodeWeaver1> http://blog.omega-prime.co.uk/?p=96
07:41:20 <sully> is there a way to make cabal build profiling libraries for all of the dependencies of something?
07:41:34 <CodeWeaver1> There's a few problem fixes there.
07:41:36 <elliott> no
07:41:40 <elliott> just reinstall everything
07:41:45 <CodeWeaver1> I searched for "osx iconv library haskell" in ghc.
07:41:47 <CodeWeaver1> err, in google.
07:41:47 <elliott> (cabal install --reinstall world)
07:41:56 <elliott> (after enabling profiling in ~/.cabal/config)
07:42:06 <rwbarton> "world"?
07:42:07 <sully> great
07:42:30 <rwbarton> Is that a real command?
07:42:32 <CodeWeaver1> Hope that helps, funktronic.
07:42:48 <funktronic> CodeWeaver1: look ing at it thianks
07:43:20 <funktronic> i wonder if i can manually install haskelline
07:43:29 <neutrino> hey guys i am wondering how to form this code. i was thinking of using the list monad, but i'm not sure how to do this.
07:43:57 <neutrino> i have a file with a lot of lines in it. each line can either be meaningless (i skip it), define the header of a section, or be the contents of the section
07:44:04 <neutrino> each file has multiple sections
07:44:19 <neutrino> now what i need is a list such as: [(title, content)]
07:44:38 <neutrino> the title always comes before the content; but there might be a lot of lines between them that are not interesting.
07:45:04 <neutrino> additionally, "content" is defined by the fact that the line holding the content is preceded by a line that just says "Content:"
07:45:48 <funktronic> motherfucker
07:46:21 <neutrino> i know how i could do this in, say, python where i can loop over the file and have several state variables. i could have a variable which holds the "section title" and then have a variable which holds the "section content" and update accordingly
07:46:32 <neutrino> but how would i do this with haskell ?
07:46:47 <merijn> neutrino: I would probably just write a proper parser using Parsec
07:47:03 <merijn> Assuming the format is not ambiguously defined
07:47:09 <neutrino> i can't write a proper parser, i don't have enough time and there's a lot of bs in there
07:47:16 <neutrino> i need something simpler than that
07:48:01 <merijn> Put everything in the IO monad and write it imperatively just like you'd write the python code? :p
07:48:14 <rostayob> neutrino: well, you need to write a parser of some sort.
07:48:30 <rostayob> how do you recognise titles/meaningless lines?
07:48:59 <neutrino> a title is recognized by the fact that the line starts with "_________________"
07:49:13 <rostayob> if you have 'data Line = Title String | Content String | Junk' and a function 'String -> Line', you're done
07:49:42 <neutrino> how so
07:50:29 <rostayob> neutrino: first you'd read the file, and split the lines, then you'd filter the lines and then group then
07:50:30 <elliott> rwbarton: yes
07:50:36 <elliott> well, not command, package identifier thing
07:50:53 <elliott> neutrino: Parsec parsers are a _lot_ easier to write than parsers in other languages.
07:51:03 <elliott> It's just a lightweight DSL for file formats.
07:51:09 <elliott> I wager it'll be easier than the Python solution.
07:51:21 <nand`> elliott: (excluding of course parsec-clones in other languages, like Sprache for C#)
07:51:36 <neutrino> elliott: does what rostayob said apply to parsec ?
07:51:49 <neutrino> elliott: or is parsec yet another thing
07:51:59 * hackagebot network-conduit 0.2.1.1 - Stream socket data using conduits.  http://hackage.haskell.org/package/network-conduit-0.2.1.1 (MichaelSnoyman)
07:52:11 <elliott> I don't understand what "yet another thing" means. It's just a ubiquitous library (that comes with the Haskell Platform).
07:52:22 <rostayob> even better 'data Line = Title String | Content String', and then a function 'filterLine : String -> Maybe Line', then do { ss <- readFile "foo"; let ss' = catMaybes (map filterLine ss); ...do the grouping... }
07:52:54 <neutrino> rostayob: but notice that won't work well because my "content" is identified by a line previous to said content
07:53:07 <neutrino> let me show you an example perhaps
07:53:36 <rostayob> neutrino: yeah, maybe that's better.
07:55:29 <neutrino> ok 1 sec, some of the lines are 4 megabytes big
07:55:39 <rostayob> the single lines?
07:56:15 <matthiasgorgens> neutrino, do you know how to use parsec (or attoparsec)?
07:56:27 <matthiasgorgens> oops, too late.
07:56:52 <funktronic> the fix was (in case anyone cares) is to install macports and link it against that libiconv
08:01:48 <neutrino> here it is:
08:01:50 <neutrino> http://hpaste.org/57289
08:02:39 <neutrino> perfectly, i'd get a list of tuples of the form ("001", "content-on-this-line", "commit /* implicit, FROM xid_log_event */")
08:02:59 <neutrino> matthiasgorgens: no i do not know how to use parsec, do you think it would help?
08:05:34 <neutrino> matthiasgorgens: er, i guess it's obvious it would, but is this case actually something parsec can help with?
08:05:38 <neutrino> rostayob: check out the link above
08:06:15 <elliott> neutrino: yes, it would help
08:06:23 <elliott> since you have lots of structure
08:06:37 <elliott> i.e. "state" you have to keep track of, you can't just divide on lines or whatever
08:06:58 <elliott> parsec is easy, really :P
08:09:00 <rostayob> elliott: well, parsec is not that easy for an Haskell beginner
08:09:04 <rostayob> neutrino: but yes it would help
08:10:05 <elliott> rostayob: well... when faced with tasks like this, it's easier to learn than to write a thousand-line manually-recursive monstrosity
08:10:59 <elliott> I don't think Parsec is that complicated to learn (indeed I've heard people say that Parsec is what made them truly interested in Haskell because of how simple and integrated it is for a DSL)
08:11:12 <neutrino> ok let's give it a go
08:11:23 <rostayob> elliott: I think you're overestimating the complexity here, but OK
08:11:24 <neutrino> if i can't figure it out in 2 hours i'll do the monstrosity
08:11:49 <rostayob> neutrino: actually if you can
08:11:49 <elliott> neutrino: you might find http://book.realworldhaskell.org/read/using-parsec.html helpful
08:11:59 <elliott> although some of the imports will need to be changed for latest parsec, *sigh*
08:12:09 <elliott> oh... and some of the type signatures
08:12:12 <elliott> maybe there is a better introduction these days :
08:12:13 <elliott> :/
08:12:14 <rostayob> you could get the book "Programming in haskell" which has a chapter on functional parsers
08:12:21 <neutrino> i normally don't use type signatures
08:12:30 <neutrino> rostayob: i meant 2 hours from now.
08:12:40 <neutrino> as in, until 20:07
08:12:42 <elliott> neutrino: you should
08:13:09 <elliott> but i guess you'll learn to naturally when the MR hits you :P
08:13:33 <neutrino> MR?
08:13:34 <rostayob> elliott: I wouldn't say you can learn to use parsec in 2 hrs if youre new to Haskell...
08:13:43 <neutrino> yeah
08:13:46 <cmccann> "error: insanely generic parser combinators are making the monomorphism restriction cry"
08:13:57 <neutrino> i use type signatures where necessary
08:13:59 <rostayob> neutrino: but give it a try it anyways
08:13:59 <neutrino> but other than that, no
08:14:12 <neutrino> i'm not *that* new to haskell
08:14:40 <elliott> rostayob: I dunno, why not? You don't have to learn all the intricacies.
08:14:45 <elliott> The format is pretty simple.
08:14:57 <neutrino> anyone of you using parsec got any hints on how to define this thing, where i have a fixed string on one line and a variable string on the next line?
08:15:06 <cmccann> the only tricky part is putting "try" in the right places
08:15:13 <cmccann> and getting usable error messages
08:15:31 <elliott> cmccann: I kind of hope attoparsec magically grows good error messages and String support and Parsec dies off
08:15:53 * cmccann shrugs
08:16:01 <rostayob> elliott: I don't like Parsec that much anymore, it's very low level in the end
08:16:10 <cmccann> there are other limitations in parsec that annoy me more to be honest
08:16:15 <elliott> yeah... but it's standard :P
08:16:20 <rostayob> elliott: there are alternatives in which the whole backtracking business is easier, uu-parscomg for example
08:16:25 <cmccann> elliott, and ed is the standard editor
08:16:28 <rostayob> or parslib?
08:16:38 <Enigmagic> edlin baby
08:16:40 <elliott> rostayob: well attoparsec does it the obvious way
08:16:41 <rostayob> uu-parsinglib.
08:16:43 <elliott> try = id
08:16:50 <elliott> everything backtracks
08:17:07 <rostayob> yeah, exactly
08:17:16 <rostayob> uu-parsinglib is the same iirc
08:17:44 <elliott> yeah but attoparsec doesn't scare me :P
08:17:59 <rostayob> tsk
08:18:21 * cmccann occasionally wants a parsing library that makes it easier to continue after parsing failures to produce more errors, or one that can produce incremental output at checkpoints
08:18:38 <rostayob> there is the ekmett one as well, trifecta
08:18:41 <cmccann> but haven't looked at the other libraries much yet since it doesn't come up often
08:18:44 <rostayob> completely undocumented ofc
08:19:10 <rostayob> but it has colored errors!
08:19:24 <yitz> cmccann: http://www.cs.uu.nl/wiki/bin/view/HUT/ParserCombinators
08:19:37 <rostayob> yitz: yeah, those are good
08:20:27 <rostayob> but you have to put up with the horrible, horrible style the examples are written in :D
08:20:41 <elliott> that's why it scares me!
08:20:59 <rostayob> utrecht style yo
08:21:20 <cmccann> yitz, ah, been meaning to look at the utrecht parsing stuff, sounded like it would be my best bet
08:22:10 <elliott> I wonder how gcc actually manages to keep going after errors
08:22:20 <quicksilver> badly in most cases I find
08:22:34 <elliott> I guess most of the time there's no "results" of each individual atomic piece of compilation, so it just keeps going...
08:22:40 * cmccann isn't sure what's so weird about utrecht coding style anyway
08:22:46 <quicksilver> I  normally just curse as I try to scroll up far enough to find the first error
08:22:59 <neutrino> what is utrecht style?
08:23:36 <rostayob> neutrino: the style in which a lot of programs from the university of utrecht are written in
08:23:53 <eviltwin_b> parsing C, you can resynchronize at semicolon or close brace
08:24:09 <neutrino> got an example rostayob?
08:24:12 <eviltwin_b> (or open brace, but you pop back out to unknown state at the corresponding close)
08:24:44 <rostayob> neutrino: http://hackage.haskell.org/packages/archive/uu-parsinglib/2.7.3.2/doc/html/src/Text-ParserCombinators-UU-Demo-Examples.html#Parser
08:24:49 <rostayob> I remember it being worse actually
08:25:00 <elliott> cmccann: http://hackage.haskell.org/packages/archive/uu-parsinglib/2.7.3.2/doc/html/src/Text-ParserCombinators-UU-Core.html#line-133
08:25:59 <cmccann> elliott, pf, the alignment looks off in some of those
08:26:13 <elliott> i'm sure it follows its own incomprehensible logic :)
08:26:17 <rostayob> elliott: oh god, yes that kind of thing is what I was thinking of. WHY
08:26:32 <quicksilver> don't think I understand what you're talking about?
08:26:52 <elliott> rostayob: dunno what you're talking about man. those Functor and Applicative instances are the clearest thing ever
08:26:54 <itwenty> Hi newbie here... what function from Enum typeclass should I define in my own data type so I can use ".." operator for constructing lists?
08:26:56 <quicksilver> you mean the spcaces around the \ or?
08:27:01 <neutrino> the formatting is very terrible
08:27:06 <neutrino> i like that there's a lot of comments
08:27:17 <elliott> can't you tell it's the T of the lambda of k of ph of k composed with f and lambda of k with apply2fst f composed with pf k and pr?
08:27:24 <rostayob> quicksilver: that code is completely unreadable
08:27:26 <rostayob> to me anyways
08:27:43 <rostayob> a mix of bad style and pl madness
08:27:43 <quicksilver> how would you improve it?
08:27:44 <elliott> itwenty: just give a complete Enum instance (what constitutes "complete" should be in the Enum docs)
08:27:53 <quicksilver> I'm not sure what you're complaining about specifically?
08:28:01 <cmccann> other than "T" being a terrible name and needing to clean up the alignment it seems ok to me
08:28:01 <limetree> P ap np  pl pe <|> P aq nq ql qe !!
08:28:05 <rostayob> quicksilver: the most obvious thing is the misuse of whitespace
08:28:06 <quicksilver> it's a slightly fiddlier higher-rank continuation thing
08:28:14 <rostayob> but that's superficial
08:28:24 <rostayob> the other thing is the very confusing variable names and the point-free style
08:28:34 <rostayob> it's pretty impenetrable, at least to me eh.
08:28:41 * cmccann thinks some of this would actually be clearer if it was more pointfree
08:28:44 <elliott> quicksilver: all the names are pretty terrible, the spacing is very erratic, and the compositions are confusing
08:28:55 <quicksilver> the names don't seem terrible to me
08:28:55 <cmccann> and yeah the type names are painful
08:29:00 <quicksilver> except, possibly, T
08:29:05 <elliott> it's not sufficiently abstract enough a concept to look that abstract
08:29:06 <cmccann> the local identifiers are fine
08:29:11 <elliott> evidence: every other parser library
08:29:25 <quicksilver> I think we're totally faling to communicate
08:29:29 <cmccann> there's also a lot of redundancy that I don't like but eh
08:29:32 <quicksilver> I don't know what you mean by "look abstract"
08:29:35 <eyebloom> What does a pragma such as {-# LINE 10 "Printer.lhs" #-} mean?
08:29:38 <rostayob> T ph pf pr  <*  ~(T _  _  qr)   = T ( ph. (qr.))  (pf. qr)   (pr . qr)
08:29:55 <rostayob> eyebloom: it tells the compiler what line that was in the original file
08:30:02 <rostayob> since there was some form of preprocessing
08:30:07 <Peaker> the short meaningless names are OK -- but only as long as there's actually no meaning to convey
08:30:15 <quicksilver> if you design a parser as  history parser, a future parser, and a recogniser, with higher rank types then, well, that's what it looks like
08:30:16 <Peaker> when there is meaning to convey, meaningful names are still better
08:30:19 <itwenty> elliott: you mean implement all functions of enum which I see using  ":info Enum" in ghci?
08:30:31 <elliott> itwenty: no
08:30:35 <quicksilver> you can't compare it to a parser which is implemented diffrently
08:30:35 <elliott> itwenty: complete as defined in the documentation for Enum
08:30:37 <eyebloom> I see so it could be generated say by Template Haskell?
08:30:38 <rostayob> quicksilver: I don't know. I'm not sure why, but I've always found that code very hard to read.
08:31:00 <elliott> quicksilver: it's not about the concept it's implementing
08:31:03 <elliott> it's just impenetrable code
08:31:30 <quicksilver> how would you improve it?
08:31:34 <cmccann> all that stuff in T is just a few ways of composing the same few functors
08:31:49 <rostayob> quicksilver: not receiving an answer to that question doesn't change things
08:31:53 <elliott> quicksilver: that's not really a fair question. i mean, i would rewrite that part.
08:32:03 <rostayob> elliott: we think alike.
08:32:05 <elliott> also, you don't have to be able to improve on something to recognise it's bad
08:32:12 <elliott> so the question is disingenuous
08:32:25 <quicksilver> well to recognise it's bad it helps to have some idea what would be better
08:32:35 <quicksilver> that seems me to be the sensible and concise way to encode what it encodes
08:32:49 <quicksilver> I can't see any way to make it clearer (except by writing a paper which explains how it works)
08:32:59 <rasfar> I like their use of whitespace, it maximises vertical alignments which makes it easier to read for me.
08:33:04 <cmccann> renaming T would go a long ways I think :P
08:33:05 <quicksilver> whether or not you write a paper doesn't really made it 'bad code' or 'good code'
08:33:08 <elliott> i don't really know how to respond to that other than by suspecting you're blind :P
08:33:08 <cmccann> and P and other nonsense like that
08:33:12 <rostayob> quicksilver: wait you just glanced at it and understood what it was doing?
08:33:30 <elliott> the fact that utrecht style is basically a meme makes me feel fairly confident i'm not just bad at reading code
08:33:46 <cmccann> but really, other than the type names and inconsistent vertical alignment it seems fine and readable to me, I don't know what the problem is :P
08:33:51 <quicksilver> rostayob: my contention is that there is no way of rewriting which would alter that property.
08:34:04 <quicksilver> it is genuinely an interesting way to encode a parser
08:34:13 <quicksilver> (and the reason it's done that way was a clever piece of research)
08:34:21 <quicksilver> having made the decision to encode your parsers like that
08:34:29 <cmccann> rostayob, a quick glance is enough to see that it's juggling stuff in CPS style
08:34:29 <quicksilver> well, the Applicative instance writes itself
08:34:30 <elliott> nobody is talking about the representation!
08:34:47 <rostayob> quicksilver, cmccann: yeah I can guess in a vague way what it does
08:34:51 <elliott> that would involve the representation actually being /visible/
08:34:56 <rostayob> anyway I should work
08:35:00 <quicksilver> I can't see any point in writing the applicative instance differently
08:35:42 <cmccann> quicksilver, well, the applicative instance would be clearer if it was expressed in terms of the applicative instances for the implicit functors being composed...
08:35:57 <rwbarton> since when is (<$) a class method of Functor
08:35:59 <quicksilver> cmccann: except you'd have to wrap everything in newtype to acheiev that
08:36:11 <quicksilver> and get lots of unwrapper noise
08:36:15 <quicksilver> so I'm not sure it's a win.
08:36:20 <quicksilver> maybe, though.
08:36:24 <cmccann> quicksilver, yes, but I don't mind that too much, and it wouldn't be needed for some of them
08:36:35 * elliott should get around to writing that perfect parser combinator library sometime.
08:36:35 <cmccann> the generic reader and writer functors work fine as is
08:37:14 <rwbarton> oh, apparently it actually is but it's not exported by Prelude so it doesn't show up in Haddock? that's pretty confusing
08:37:31 <quicksilver> rwbarton: it was a very recent change (AFAICR)
08:37:36 <cmccann> quicksilver, but you'd need to disentangle things a bit to get the right decomposition, so it's hard to say how well it would actually work
08:37:48 <quicksilver> cmccann: it's something haskell is particularly bad at
08:38:07 <quicksilver> cmccann: (enabling you to express class instances in a way which appeals to underlying compositionality)
08:38:38 * cmccann kind of likes building functor-y things up from reader/writer/id/const/cont/fix &c.
08:38:51 <elliott> actually: someone should get around to writing it for me
08:38:54 <elliott> that would be more convenient
08:39:32 <cmccann> elliott, what you don't realize is that uu-parsinglib is that perfect library but you'll never know because the coding style is too cryptic
08:40:49 <elliott> cmccann: no, it's not -- for a start, I didn't write it
08:40:57 <elliott> wait, that applies if someone else writes my library for me.
08:40:57 <quicksilver> cmccann: so bad at it that I seldom bother, although my reactive implementation does use :. because it copies Conor.
08:41:02 <elliott> ok, people, the offer is getting even better:
08:41:17 <elliott> if you write my perfect parser combinator library for me, I will *give you the right* to credit it to me
08:41:22 <elliott> exclusively. you're welcome
08:41:37 <monochrom> the library should write itself
08:41:46 <elliott> no, that's my serialisation library
08:41:51 <elliott> this one will merely gobble itself up once writte
08:41:54 <elliott> *n
08:41:56 <cmccann> heh
08:42:00 <rostayob> quicksilver: what's your reactive implementation?
08:42:54 <quicksilver> it's a partial implementation of the system described in Conal's paper "Simply Efficient Functional Reactivity"
08:43:05 <quicksilver> which is better than his in some ways, but incomplete.
08:44:34 <rostayob> quicksilver: hackage?
08:44:41 * sm checks out uu-parsinglib
08:46:15 <quicksilver> rostayob: nope :(
08:49:18 <rostayob> quicksilver: ok :)
08:51:37 <neutrino> ok guys, i am staring at this parsec example for parsing csv
08:51:55 <rostayob> neutrino: if you stare at code for enough time, it'll be clear
08:51:57 <neutrino> it's still not dawned on me how to parse my file
08:53:34 <neutrino> i am missing a bit here...
08:53:36 <neutrino> remainingCells :: GenParser Char st [String]
08:53:41 <neutrino> however, the documentation says:
08:53:44 <monochrom> have you learned what each parsec thing used does?
08:54:03 <neutrino> remainingCells :: GenParser Char st [String]
08:54:06 <neutrino> err
08:54:12 <neutrino> type GenParser tok st = Parsec [tok] st
08:54:32 <neutrino> i ma assuming that "tok" is the "Char", right?
08:54:39 <monochrom> yes
08:54:50 <neutrino> and st is the ... st
08:54:57 <neutrino> what is the "[String]" there?
08:55:10 <monochrom> the "answer" type
08:55:23 <neutrino> ok
08:55:35 <itwenty> elliott: OK...got it! ty for the help! :P
08:56:07 <monochrom> in less abbreviation, type GenParser tok st a = Parsec [tok] st a
08:56:17 <sm> neutrino: to simplify you can assume strings and forget about state, so type Parser = GenParser Char st and define a bunch of functions returning Parser RETURNTYPE
08:56:44 <neutrino> so if i have a fixed string, let's say "Foobar:" in my file format
08:56:47 <elliott> itwenty: I completely forget what you didn't get :)
08:57:03 <elliott> neutrino: this is why that link is a bad intro :(
08:57:04 <neutrino> then I would use GenParser Char st String, right?
08:57:10 <neutrino> wait, no
08:57:10 <elliott> GenParser doesn't exist any more, it'll just be Parser [String]
08:57:16 <elliott> to represent the same thing used there
08:57:17 <neutrino> i would use GenParser String st String ?
08:57:34 <monochrom> GenParser Char st String
08:57:36 <sm> to match it, you'll use string "Foobar:". You can choose to return that or not
08:57:44 <monochrom> or GenParser Char st ()
08:57:47 <elliott> (does anyone know of a *parser 3* intro?)
08:58:03 <neutrino> ah yes i don't need to return "Foobar:" either
08:58:10 <neutrino> so i'd use GenParser Char st () ?
08:58:29 <neutrino> elliott: do you know of a good intro for parsec, which is recent?
08:58:30 <elliott> *parsec
08:58:31 <monochrom> it's up to you
08:58:33 <itwenty>  elliott : Creating my own enum instance that expands with ".." inside lists
08:58:37 <elliott> neutrino: that's what i just asked in parens :p
08:58:38 <elliott> itwenty: ah
08:58:39 <neutrino> monochrom: aha
08:58:46 <neutrino> elliott: ah, i saw "parser" and was wondering
09:00:29 <cmccann> elliott, you might just have to write one yourself
09:00:45 <mm_freak> does anyone have experience with UHC's javascript backend?  can it really replace javascript?
09:00:55 <monochrom> GenParser is a backward compatibility thing. then again it is more special and therefore more suitable as a starting point
09:02:21 <elliott> cmccann: no way, that's time i could spend not writing my perfect library
09:02:37 <cmccann> good point
09:02:50 <cmccann> maybe I should write a parsec3 intro
09:03:26 <elliott> no way, that's time you could spend not writing my perfect library
09:03:33 <elliott> everyone drop everything, you need to concentrate on not writing my perfect library
09:03:46 <neutrino> ok let me try to define a simple parser generator which will take a string, and 1) return "foo" if the string is "Bar" 2) return "baz" if the string is "Quux" 3) return nothing, throw an error, or something, if the string is anything else
09:03:53 <monochrom> we have too many perfect libraries already, and too few perfect tutorials, in fact too few tutorials at all. (except monad tutorials)
09:04:02 <neutrino> parser generator? i guess just "parser"
09:04:16 <cmccann> monochrom, well, parsec is a monad...
09:04:20 <monochrom> why return strings?
09:04:43 <monochrom> few monad tutorials cover the "parse" part of "parsec"
09:04:47 <cmccann> "parsers are, by transitivity, like burritos"
09:05:25 <cmccann> do any monad tutorials cover the "c" though? that's important too.
09:05:34 <monochrom> anyway, I would understand why in a shell script you would return strings, but Haskell?
09:07:00 <monochrom> to some extent
09:07:00 <mm_freak> neutrino: start with a real example:  write a parser for a space-separated list of numbers or something
09:07:04 * hackagebot pipes 1.0.1 - Compositional pipelines  http://hackage.haskell.org/package/pipes-1.0.1 (GabrielGonzalez)
09:07:12 <elliott> o'reilly publishes attoparsec tutorial: exactly the same as their parsec tutorial, but 10^-18th the size
09:07:15 <mm_freak> Parser String is a type you usually wouldn't want to see
09:07:24 <monochrom> haha
09:07:28 <mm_freak> unless it's something like:  quotedString :: Parser String
09:07:41 <monochrom> @remember elliott o'reilly publishes attoparsec tutorial: exactly the same as their parsec tutorial, but 10^-18th the size
09:07:41 <lambdabot> Done.
09:07:45 <mm_freak> lol elliott
09:08:02 <mm_freak> atto-(parsec tutorial)
09:08:19 <cmccann> an attoparsec is about an inch, isn't it?
09:08:29 <c_wraith> yeah, pretty close
09:08:40 <elliott> cmccann: you mean the parsec book is a /parsec/ big?
09:08:41 <monochrom> that means the parsec tutorial is 10^18 inches?!
09:08:47 <cmccann> apparently
09:08:50 <neutrino> i think i got something
09:08:51 <elliott> for haskell programmers the scale of their projects!
09:08:51 <cmccann> it's very in-depth
09:09:12 <neutrino> mm_freak: it *is* a real world example
09:09:18 <mm_freak> not the scale of haskell projects (just their executables)
09:09:21 <monochrom> that can probably contain every parsec-using programs you have written and will write
09:09:52 <monochrom> anyway I am weary of labelling "this is a real example" "this is not a real example"
09:10:35 * cmccann prefers rational examples anyway
09:10:52 <rostayob> every example is real, simply by being.
09:11:11 <mm_freak> let's say a didactical example
09:11:22 <monochrom> it's highly subjective. everyone is in a different "reality" bubble.
09:11:39 <mm_freak> a parser just differentiating between two strings isn't really teaching writing parsers
09:11:55 <elliott> as haskell's wonderful numeric typeclasses teach us, every real is a rational
09:12:04 * hackagebot shplit 0.3 - A Haskell pattern splitter with emacs attachments  http://hackage.haskell.org/package/shplit-0.3 (ConorMcBride)
09:12:10 <elliott> so, real examples aren't real
09:12:13 <elliott> but rational examples are
09:12:17 <mm_freak> lol
09:12:20 <elliott> and natural examples are the realest of all
09:12:29 <mauke> wait, what
09:12:39 <monochrom> what you really mean is examples that helps the audience with what the audience cares about. and that requires knowing the audience.
09:12:39 <mm_freak> :t toRational
09:12:40 <lambdabot> forall a. (Real a) => a -> Rational
09:12:57 <elliott> @src Real
09:12:57 <lambdabot> class  (Num a, Ord a) => Real a  where
09:12:58 <lambdabot>     toRational      ::  a -> Rational
09:13:11 <monochrom> as opposed to someone not among the audience judging what is "real"
09:13:13 <elliott> I really want to find who named that typeclass and... I don't even know.
09:13:21 <elliott> I just want to know WHY
09:13:54 <mauke> a number is real if it can be approximated by a rational number!
09:13:55 <nicoo> elliott: Because it must have seemed to be a good idea, at the time
09:14:08 <neutrino> ok guys i have cobbled this together: http://hpaste.org/57291
09:14:09 <elliott> mauke: approximated? it says "to", not "approx"!
09:14:10 <mauke> > toRational 0.1
09:14:11 <lambdabot>   3602879701896397 % 36028797018963968
09:14:13 <nicoo> mauke: By a sequence of rationnal numbers, then :]
09:14:18 <elliott> :t approxRational
09:14:19 <lambdabot> forall a. (RealFrac a) => a -> a -> Rational
09:14:22 <elliott> see, that's for approximations!
09:14:30 <mauke> elliott: no, that's for custom approximations
09:14:44 <elliott> nonCustomApproxRational :: (Real a) => Rational
09:15:13 <neutrino> the issue now is: if i try to parse "Bar", or "Quux", then the parser does what i expect. If i try parsing "BarZorf" then it still returns "foo" which it should not. I would like it to return nothing. how do i do that?
09:15:20 <neutrino> i know i can use "eof" somehow, but i'm not sure how.
09:16:15 <neutrino> ohh amazing, i figured it out actually
09:16:29 <neutrino> now i get "Unexpected Z" which is perfect
09:16:29 <elliott> \o/
09:16:36 <neutrino> elliott: ^5!
09:16:49 <neutrino> parsec IS not difficult to figure out
09:17:13 <c_wraith> neutrino: any reason you're spelling out GenParser Char st instead of using the Parsec type alias?
09:17:14 <cmccann> what's wrong with Real as a name for "the class of types which describe a subset of the rational numbers"
09:17:23 <cmccann> that makes complete sense!
09:17:26 <c_wraith> cmccann: Seems fine to me!
09:17:36 <neutrino> c_wraith: because i am mostly copypasting from the tutorial.
09:17:49 <c_wraith> neutrino: ah. well, in that case, carry on. :)
09:18:11 <cmccann> just like Integral is the class of subsets of the integers
09:19:13 <elliott> neutrino: btw, if you're importing Text.ParserCombinators.Parsec, you might want to change that to imports of Text.Parsec and Text.Parsec.String... you might have to change a little bit of code though (the first module is the parsec-2 compatibility interface)
09:19:13 <cmccann> and Fractional is "supersets of the rationals" and Num is "supersets of the integers", since natural numbers obviously aren't numbers
09:19:14 <elliott> no big deal though
09:19:17 <c_wraith> Makes more sense than the integrals I learned about in college
09:20:19 * elliott has no idea how Num turned out so bad. was it just trying to do the absolute opposite of the (problematic) "let's just shove the entirety of abstract algebra in there" solution?
09:21:13 <cmccann> why did many of the standard type classes turn out so bad?
09:21:30 <c_wraith> elliott: it was trying to create a hierarchy that works for Int, Integer, Float, and Double...  And didn't care much beyond that.
09:22:15 <cmccann> @quote cmccann num
09:22:15 <lambdabot> cmccann says: programming is a lot easier if you avoid working with dates/times, text, or numbers. I say stick to category theory, it's simpler
09:22:17 <cmccann> @quote cmccann num
09:22:18 <lambdabot> cmccann says: Num doesn't actually make sense, though. it's like the problems with having fail in monad, except without the sensible part. so Num is basically a whole class consisting of nothing but
09:22:18 <lambdabot> fail. figuratively speaking.
09:22:20 <cmccann> there we go
09:22:23 <kallisti> what's the "precedence" of a record update?
09:22:38 <c_wraith> kallisti: binds tighter than function application
09:22:40 <elliott> c_wraith: It doesn't even work for Float/Double.
09:22:42 <kallisti> ah okay good.
09:22:46 <Lemon> what are some common examples of where the value-level constructor has the same name as the type constructor itself?
09:22:51 <elliott> c_wraith: Since they managed to eff up list ranges.
09:23:03 <c_wraith> elliott: that's Enum that got screwed up, not Num. :)
09:23:09 <rwbarton> Num works for Float/Double, it's Float/Double that doesn't work for Num
09:23:14 <Lemon> Tuples and () seem to fit the bill, but I can't really think of anything else.
09:23:17 <cmccann> floating point values aren't really numbers by most sensible definitions anyway
09:23:20 <rwbarton> Num isn't really so bad if you pretend abs and signum don't exist
09:23:22 <elliott> c_wraith: are you saying [1..10] isn't part of the "numeric typeclasses"?
09:23:23 <mjga> cmccann: it is common problem. practical people want to get a "basic" functionality to get work done, and then it is very difficult to iron out, because everything depends on it. In a way Haskell is much better, because initial designers were more sophisticated about things to be done, in a way it is worse, when there was something beautifully simple for teaching students, but totally impractical ([Char])
09:23:34 <elliott> @remember rwbarton Num works for Float/Double, it's Float/Double that doesn't work for Num
09:23:34 <lambdabot> Okay.
09:23:39 <elliott> Lemon: every transformers/mtl monad
09:23:43 <elliott> Lemon: any newtype
09:23:46 <elliott> (more or less)
09:24:21 <Lemon> the transformers/mtl monads have constructors?
09:24:47 <mjga> cmcann: it took ~10years I think for NumPy people to fix Python's numerics and array interface. Haskellers already made a lot of substitute preludes for numerics, and at least 4 different "big array libraries" still live
09:25:25 <c_wraith> Lemon: all data types have constructors
09:25:40 <c_wraith> Lemon: a better question is "are they exported?"
09:25:40 <Lemon> I meant like
09:25:45 <Lemon> ones we're supposed to use
09:25:48 <Lemon> yeah
09:26:05 <c_wraith> And the answer to that is "no"
09:26:19 <c_wraith> However, functions that do what you need are exported
09:26:45 <cmccann> mjga, partly I have just have higher expectations for haskell
09:27:07 <c_wraith> Well, getting rid of Eq and Show as superclasses of Num is a tiny step in the right direction
09:27:09 <elliott> erm
09:27:10 <cmccann> but stuff like Num seems so ridiculously short-sighted I really can't imagine why anyone thought it was sensible
09:27:16 <elliott> c_wraith: that may be your answer, but it is wrong
09:27:29 <elliott> > evalStateT $ StateT { runStateT = \_ -> return (42, ()) }
09:27:30 <lambdabot>   Overlapping instances for GHC.Show.Show (() -> m a)
09:27:30 <lambdabot>    arising from a use o...
09:27:33 <elliott> *sigh*
09:27:36 <elliott> > evalStateT (StateT { runStateT = \_ -> return (42, ()) }) ()
09:27:37 <lambdabot>   No instance for (GHC.Show.Show (m t))
09:27:37 <lambdabot>    arising from a use of `M3237268059...
09:27:40 <elliott> >_<
09:27:42 <elliott> > evalState (StateT { runStateT = \_ -> return (42, ()) }) ()
09:27:43 <lambdabot>   42
09:27:51 <elliott> proving my point with lambdabot in only 10 lines
09:28:41 <c_wraith> ok, point proven.  eventually.  But I'm sticking with "the constructors aren't actually necessary"
09:28:59 <elliott> well, sure they are -- I use StateT often
09:29:07 <Nibble> howdy, how's the state of web frameworks in haskell?
09:29:17 <Nibble> last time I checked it was really nice and snap was coming along nicely
09:29:17 <elliott> State was ubiquitous too, just look at the annoyance switching to state caused
09:29:29 <elliott> Nibble: http://yesodweb.com/, http://snapframework.com/, http://happstack.com/index.html
09:29:41 <elliott> i doubt anything went massively wrong since you last checked :P
09:29:46 <neutrino> how can i parse *any* string?
09:29:50 <elliott> Nibble: (are you really IRCing as root?)
09:29:53 <mjga> cmccann: me too, but it is getting more and more usable language, and certainly the best type system I have seen
09:29:54 <sm> funny.. if I run ghci-7.4.0.20120126 directly it segfaults, if I run it via ghci symlink it's fine
09:29:55 <neutrino> i am going to stick to the parsec2 style interface for now
09:29:56 <Nibble> elliott: yeah
09:30:00 <elliott> neutrino: you probably mean "any string until a newline"
09:30:00 <Nibble> elliott: In fact I am ;D
09:30:04 <luite> Nibble: yesod is also making good progress, the yesod book will be published at O'Reilly in a few months, probably yesod 1.0 will be released by then
09:30:06 <elliott> Nibble: fix that :(
09:30:10 <neutrino> elliott: no just "any string"
09:30:18 <neutrino> (for now)
09:30:22 <sm> string THESTRING
09:30:24 <elliott> neutrino: that won't work, because it will gobble up the entire rest of input
09:30:24 <Nibble> elliott: yeah, but I don't really care... it doesn't run on a machine worth caring about
09:30:25 <neutrino> (i know how to do the 'until newline' thing)
09:30:30 <Nibble> but it has uptime that's nice tho
09:30:34 <elliott> in fact i am not sure parsec even has a way to do that without writing your own loop
09:30:49 <Nibble> up 26days
09:30:49 <mjga> cmccann: that said, I haskell for the point of resting after work day, so that I can be fresh for more work ;-)
09:31:02 <neutrino> elliott: well what i want to do is to be able to parse "aaaaaaaaaaFoozzzzzzzzzz" where "Foo" is a hardcoded token
09:31:12 <cmccann> mjga, yes, that's partly why I have higher standards for it
09:31:24 <neutrino> Nibble: even my laptop has a longer uptime.
09:31:29 <rostayob> Nibble: 26 days is NOTHING
09:31:31 <rostayob> :D
09:31:32 <elliott> neutrino: ok, so you want "string up to Foo"
09:31:38 <elliott> Nibble: lol 26 days
09:31:43 <neutrino> elliott: you're right
09:31:52 <Nibble> rostayob: considering it has been running for that long, I find it impressive
09:32:04 <Nibble> it also runs arch linux and a pentium 4 3,8GHz
09:32:12 <elliott> neutrino: one of the combinators in http://hackage.haskell.org/packages/archive/parsec/3.1.2/doc/html/Text-Parsec-Combinator.html probably fit your need
09:32:21 <rostayob> Nibble:  18:27:30 up 391 days, 17:47,  1 user,  load average: 0.00, 0.00, 0.00
09:32:25 <rostayob> that's my box.
09:32:27 <elliott> e.g. endBy, manyTill
09:32:28 <Nibble> rostayob: nice
09:32:46 <rostayob> but it's also not doing much...
09:33:00 <neutrino> thanks elliott i didn't think what i need is called a "combinator"
09:33:25 <elliott> well, they're parser combinators :)
09:33:32 <donri> combinators are the bread and butter of parsec
09:33:34 <elliott> .Combinator just contains all the things that transform parsers to other parsers
09:33:37 <elliott> ...and aren't primitives../
09:35:43 <sm> http://www.cs.uu.nl/research/techreps/repo/CS-2008/2008-044.pdf is a nice intro to combinator parsers
09:36:24 <joeyh> huh. System.Posix.Directory.ByteString has no removeFile. I wonder where it is hidden
09:37:09 <luite> System.Directory has it here, the directory package
09:37:29 <joeyh> that operates on RawFilePath?
09:37:33 <luite> oh
09:37:40 <luite> probably not :)
09:37:48 <luite> no regular one...
09:37:58 <joeyh> ah, removeLink
09:39:32 <frerich> sm: Interesting link!
09:40:05 <frerich> I wonder, so many useful Haskell-related things are available online, but they are spread over dozens of PDFs. How do you people keep track of them? Just one big bookmark folder?
09:40:46 <sm> frerich: that's from checking out uu-parsinglib docs, just mentioned above
09:41:05 <elliott> frerich: ten printers and a mansion full of paper and ink
09:41:14 <elliott> plus a very elaborate filing system
09:41:15 <sm> I think the main solution to that is the haskell wiki
09:41:22 <sm> plus memory and google
09:41:32 <elliott> and a butler.
09:41:57 <sm> plus a few handy browser search shortcuts, eg for hackage packages and hoogle searches
09:42:04 <frerich> Actually, now that I think about it, the answer is quite obvious: this channel already consolidates a lot of different inputs.
09:42:23 <sm> yes, just not always at the time you want them
09:42:50 <sm> wiki is good for persistent stuff (but gets stale)
09:45:21 <nand`> Any good tutorials on writing a linux daemon in haskell?
09:45:31 <nand`> Also, any good sound libs that support FLAC decoding?
09:45:57 <nand`> (Planning to write a music player daemon in haskell if anybody's interested)
09:46:55 <ousado> nand`: with JACK support?
09:47:21 <nand`> ousado: no, just regular ALSA device streaming
09:47:37 <ousado> :(
09:48:12 <nand`> (for me, the quality of an audio framework is measured by how little it does. I don't even like ALSA. I like FreeBSD's /dev/pcm)
09:48:18 <nand`> so don't count on it
09:49:20 <ousado> nand`: how about just wrapping libFLAC?
09:49:27 <Ke> /dev/pcm doesn't allow for piping audio over network, does it
09:49:43 <nand`> ousado: that's probably the best bet here
09:49:46 <neutrino> hey guys... i'm missing something, and i'm getting type errors. how do i fix this code? http://hpaste.org/57292
09:49:49 <eviltwin_b> that's interesting considering the linux folks are all about how the kernel should not do audio mixing, which fbsd does
09:50:02 <nand`> eviltwin_b: that's interesting to know
09:50:05 <neutrino> it's supposed to parse something like "BarQuuxQuux"
09:50:07 <nand`> kernel mixing is evil
09:50:12 <nand`> pure pure rotten stinking evil
09:50:33 <ceasarbautista> I've recently read on SO that recursion is often an anti-pattern and that maps or fold can be used instead.
09:50:50 <mjga> eviltwin_b: kernel is large enough, and if a thing can be done efficiently outside... why not?
09:51:22 <ceasarbautista> Can someone kind of explain how that works? I saw a few examples, but overall it's still unclear how I would convert many functions from recursion to maps.
09:51:23 <eviltwin_b> my point was more asking why /dev/pcm was somehow better than alsa for minimalism, when in fact it does more
09:51:37 <eviltwin_b> also, in freebsd at least the sound modules are a bit of a mess
09:51:49 <elliott> neutrino: what error?
09:52:01 <elliott> btw, do return x === return x
09:52:09 <elliott> and do { result <- ...; return result } === ...
09:52:22 <neutrino> elliott: i am getting some sort of cryptic type error - would you like me to pastebin it?
09:52:29 <elliott> oh
09:52:33 <elliott> fooP :: GenParser Char st String
09:52:35 <neutrino> elliott: i realize, those are skimmed down from what more should be in it
09:52:38 <elliott> but you did (many barquuxP)
09:52:44 <elliott> many turns a parser of a into a parser of [a]
09:52:46 <neutrino> yes i have done many
09:52:48 <elliott> because, obviously, there's multiple results
09:52:54 <elliott> so
09:52:57 <elliott> barquuxP :: GenParser Char st String
09:53:00 <elliott> fooP :: GenParser Char st String
09:53:03 <elliott> fooP can't be many barquuxP
09:53:06 <neutrino> yes
09:53:07 <elliott> because it'd be GenParser Char st [String] if it was
09:53:10 <elliott> so your types are wrong
09:53:14 <neutrino> i tried setting fooP to [String]
09:53:14 <mjga> eviltwin_b: since he wants to make a program in Haskell, using a library, I do not think he wants to change kernel. And there are at least two packages with jack bindings on Hackage
09:53:39 <neutrino> however that gives me type errors too.
09:53:41 <elliott> neutrino: well, then the problem is
09:53:44 <elliott> parseFoo :: String -> Either ParseError String
09:53:52 <elliott> you can't change the type of your parser without changing the type of the function using it!
09:53:58 <elliott> Either ParseError [String]
09:54:29 <neutrino> ahh, alright
09:54:31 <neutrino> there we go
09:54:54 <neutrino> all this type annotation stuff is still new to me. thanks for helping me figure it out elliott
09:55:48 <neutrino> i think i'm really close to parsing this file now
09:58:58 <sm> if I download a bunch of ghc binary distributions, configure and make install each one, should I then have a bunch of working ghc[-*]-NN's, with the last installed also being available as ghc, ghci, ghc-pkg ?
09:59:15 <elliott> ehm
09:59:22 <elliott> what you should have is a rather broken system, i think
09:59:35 <elliott> sm: why not install each to a separate prefix?
09:59:39 <elliott> and then symlink versions as you wish
09:59:51 <elliott> although I think there *is* an executable suffix option, I don't know if that will work for library directories etc.
09:59:58 <elliott> I wouldntt rely on it.
10:00:19 <sm> don't ghc and cabal pretty much keep their artifacts in version-specific directories ?
10:00:45 <mjga> elliott: I thought libraries would only contain linkable objects, no executables. My cabal always compiles both usual *.o and profiling version *.p_o though.
10:01:48 <mjga> elliott: BTW I used one ghc/ghci/ghc-pkg over another. I think the best way is just to switch PATH variable between two GHC environments, there are no problems then
10:02:15 <elliott> mjga: I don't quiteu nderstand
10:02:28 <elliott> sm: well, I think so. but still: I wouldn't count on it
10:02:36 <elliott> what's wrong with multiple prefixes? /usr/local/ghc/<version> or whatever
10:02:50 <hpc> perl does that
10:02:57 <hpc> it works out quite nicely
10:02:58 <mjga> elliot: I don't think that installing ghc over another will kill the system. it will just force you to reinstall all cabal/ghc packages :-) and rebuild them. I tried
10:06:10 <sm> I thought it somewhat worked, and I'm in process of trying it again.. if not I'll try the prefix idea, the practical implications of which I'm still a little hazy on
10:07:26 <sm> I have also tried isolating ghc versions in their own virthualenvs. Looking for the simplest least-build-intensive setup
10:07:42 <mjga> sm: I think .ghc has subdir with compiler number, and .cabal stores stuff that is more neutral. so when you have two compiler versions , the only problem is to indicate to cabal which ghc+ghc-pkg to use.
10:08:59 <mjga> sm: altough I also separate ghcs and cabals into different directories, but this is only because sometimes something installs the wrong package, and suddenly all past packages become broken by default, even HP. I am too lazy to then track which series of packages have to be unregistered with ghc-pkg
10:12:27 <sm> mjga: looked at virthualenv ? it's good for that
10:13:46 <kmc> i've had no trouble installing different ghcs to different --prefixes and then setting PATH to determine which cabal, ghc, etc.
10:13:58 <kmc> but I haven't tested this setup thoroughly
10:16:38 <jeff_s_> If I have "functionName (TypeName typearg1 typearg2) = ...", is there an easy way to bind the "(TypeName typearg1 typearg2)" portion to a name?
10:17:22 <jeff_s_> or actually, it's "functionName (TypeConstructor typearg1 typearg2)".
10:18:21 <elliott> jeff_s_: foo@(TypeName ...)
10:18:35 <megajosh2> Hey, has anybody tried using the gtk package on Windows?
10:18:41 <jeff_s_> elliott- thanks!
10:18:53 <megajosh2> I'm trying to install Yi and it complains about a missing symbol in the cairo package
10:19:19 <megajosh2> The gtk-demo works so I don't know what exactly is the problem
10:19:32 <megajosh2> I'm definitely using one and only one gtk installation here too so it isn't any conflict like that
10:20:17 <megajosh2> Says it can't find '_cairo_image_surface_get_data'?
10:26:13 <mjga> sm: yep
10:29:13 <neutrino> can i make a greedy parser in parsec?
10:29:24 <neutrino> i.e. "return everything until \n"
10:29:30 <neutrino> hmm.. actually
10:29:35 <monochrom> yes
10:30:10 <int-e> manyTill?
10:30:20 <neutrino> woohoo
10:30:24 <neutrino> it works
10:30:47 <sm> I would like virthualenv to allow multiple named envs within a single project dir
10:31:19 <neutrino> can't you just make multiple copies of bin/activate ?
10:32:54 <prophet_> Hi, i get the following error when i try to install glib via cabal:
10:32:57 <prophet_> cabal: Error: some packages failed to install:
10:32:57 <prophet_> glib-0.12.2 failed during the configure step. The exception was:
10:32:57 <prophet_> ExitFailure 1
10:33:06 <prophet_> can someone help me?
10:33:53 <prophet_> i have already search google but i can't find anything that helps
10:34:13 <cmccann> is there an actual error mentioned earlier in cabal's output?
10:34:19 <int-e> prophet_: perhaps, but we need the output of configure which should be that message above.
10:34:41 <int-e> (don't paste it here, use a pastebin like hpaste.org)
10:34:50 <sm> neutrino: I think I need to do some manual renaming/symlinking to keep different .virthualenv dirs separate
10:35:02 <neutrino> sounds like fun.
10:35:04 <neutrino> go for it.
10:35:15 <sm> I am, I am
10:36:22 <sm> since virthualenv's --name option doesn't affect the directory name, I wonder what it does
10:36:27 <prophet_> hpaste.org/57293 < here is what happens
10:36:53 <int-e> prophet_: "Please install `gtk2hs-buildtools` first and check that the install directory is in your PATH (e.g. HOME/.cabal/bin)." as it says right there.
10:37:24 <monochrom> which is "cabal install gtk2hs-buildtools"
10:37:42 <prophet_> i have done that
10:37:48 <prophet_> how do i check the path?
10:37:53 <monochrom> echo $PATH
10:38:10 * cmccann guesses that prophet_ doesn't have cabal's bin dir in the path
10:38:14 <prophet_> -.- kind of dumb to ask...
10:38:19 <mjga> many people advised to use -xc to locate stack overflow. I get only CAF and filename, is there a way to get line number?
10:38:37 <Lemon> :t return
10:38:38 <lambdabot> forall a (m :: * -> *). (Monad m) => a -> m a
10:38:38 <monochrom> no, not yet
10:38:59 <prophet_> so i should add $HOME/.cabal/bin to my path?
10:39:02 <Lemon> :t pure
10:39:02 <lambdabot> forall a (f :: * -> *). (Applicative f) => a -> f a
10:39:04 <monochrom> yes
10:39:07 <prophet_> ok
10:40:24 <cmccann> Lemon, those should be the same thing for any instance of both type classes
10:40:34 <prophet_> now it works! thank you for the quick help :)
10:42:04 <mdmkolbe> Why does this Data.Generics.Alloy program fail? http://hpaste.org/57294
10:42:12 <Lemon> cmccann, Applicative implies Monad?
10:42:23 <cmccann> other way around, theoretically
10:42:39 <Lemon> well I was aware of the converse,
10:42:46 <cmccann> the type classes themselves aren't related even though they should be
10:42:51 <Lemon> but you said "any instance of both type classes"
10:43:03 <cmccann> Lemon, sorry, poor phrasing
10:43:53 <frerich> Does anybody have suggestions for naming functions which take some value representing a command and serialize it to a string to be sent over the wire? So far I have things like 'serializeCommand' and 'serializeReceiver' and 'serializeChannelName' and whatnot. It's a bit long. :-}
10:44:11 <frerich> I don't want to (ab-)use 'show' for this, I use that for debugging.
10:44:39 <Lemon> I like"serializeCommand"
10:44:44 <cmccann> show is supposed to be a form of serialization
10:44:49 <Lemon> based on your description, that's exactly what it does
10:44:56 <roconnor> frerich: make a type class and call it serialize for everything
10:45:11 <Lemon> meanwhile, you could always resort to the classic "doStuffWithThing"
10:48:00 <frerich> roconnor: I considered that as well but thought it would be an abuse to force all those types into a class just for the sake of typing less (I don't really have a function which treats them uniformly, polymorphically). but if you suggest it as well, maybe it's not so stupid after all.
10:48:24 <roconnor> frerich: that is the orignal purpose of type classes.
10:48:27 <roconnor> AFAIU
10:48:54 <Lemon> there's already a Serializable typeclass
10:49:12 <cmccann> what, you mean the original purpose of type classes wasn't convoluted metaprogramming with fundeps?
10:49:14 <cmccann> huh.
10:49:47 <roconnor> Lemon: you may want to use a different namespace. ... though I guess typeclasses cannot be renamed very easily so making a novel name may be better.
10:50:07 <Lemon> http://hackage.haskell.org/packages/archive/cereal/0.3.0.0/doc/html/Data-Serialize.html
10:50:14 <Lemon> Turns out it's called "Serialize"
10:50:27 <Lemon> also, I wasn't the one asking the question
10:50:42 <cmccann> also, making up creative names is fun
10:50:43 <roconnor> ah oops
10:51:05 <roconnor> both Lemon and frerich happend to be coloured the same in my IRC client
10:51:26 <frerich> roconnor: A namespace as in - a separate module? Or do you think of something else?
10:51:36 <roconnor> frerich: at separate module :P
10:51:52 <roconnor> Received unknown CTCP-CLIENT request from Lemon.
10:52:01 <Lemon> meh
10:52:02 <roconnor> :D
10:52:04 <Lemon> just curious
10:52:08 <roconnor> Lemon: it is Konversation
10:52:21 <Lemon> oh
10:53:24 <Lemon> your story checks out.
10:55:19 * cmccann still needs to think of somewhere to use his hybrid error+writer monad transformer
10:58:25 <mdmkolbe> Why does "fromConstr (toConstr (undefined :: Rational)) :: Rational" throw an exception?  How do I make it not throw an exception?
10:58:54 <c_wraith> give it a value other than undefined
10:59:06 <kmc> that's not the problem
10:59:36 <Saizan> @hoogle toConstr
10:59:36 <lambdabot> Data.Data toConstr :: Data a => a -> Constr
10:59:46 <Saizan> @hoogle fromConstr
10:59:47 <lambdabot> Data.Data fromConstr :: Data a => Constr -> a
10:59:47 <lambdabot> Data.Data fromConstrB :: Data a => (forall d. Data d => d) -> Constr -> a
10:59:47 <lambdabot> Data.Data fromConstrM :: (Monad m, Data a) => (forall d. Data d => m d) -> Constr -> m a
10:59:48 <kmc> «toConstr (undefined :: Rational)» will evaluate to the Constr representing :%
10:59:55 <kmc> at least, it does for me.  i don't know if that is guaranteed
11:00:18 <kmc> for types with more than one constructor, toConstr undefined would necessarily be ⊥
11:00:25 <mdmkolbe> "fromConstr (toConstr (1 :: Rational)) :: Rational" also throws an exception?
11:00:51 <mdmkolbe> s/\?/\./
11:01:04 <Saizan> what's fromConstr spec?
11:01:10 <kmc> i think fromConstr is *supposed* to return something that's full of undefineds
11:01:16 <kmc> "Build a term skeleton"
11:01:29 <cmccann> note that Rational uses strict fields in its constructor
11:01:50 <kmc> fromConstr (toConstr (Just 3 :: Maybe Int)) :: Maybe Int  ≡  Just ⊥
11:02:22 <kmc> the idea is you get a "term skeleton" and then put values into it using the other SYB stuff
11:02:45 <kmc> i don't remember the details, but you should read the SYB paper
11:03:06 <kmc> alternately tell us what you're actually trying to do
11:03:11 <mdmkolbe> This problem arose when trying to generate Data.Generic.Alloy instances for Language.Haskell.Syntax.Exts.Module which contains Rational somewhere.
11:03:48 <mdmkolbe> The actual code: http://hpaste.org/57294  (But I just need the instances generated, I don't care how.)
11:07:05 * hackagebot indents 0.3.2 - indentation sensitive parser-combinators for parsec  http://hackage.haskell.org/package/indents-0.3.2 (SamAnklesaria)
11:07:07 * hackagebot hedis 0.3.2 - Client library for the Redis datastore: supports full command set,  pipelining.  http://hackage.haskell.org/package/hedis-0.3.2 (FalkoPeters)
11:22:06 * hackagebot buildwrapper 0.4.0 - A library and an executable that provide an easy API for a Haskell IDE  http://hackage.haskell.org/package/buildwrapper-0.4.0 (JeanPhilippeMoresmau)
11:25:06 <Nibble> this may be a really stupid question, but how does type conversions actually work?
11:25:40 <Enigmagic> converting between which types?
11:25:53 <monochrom> there is almost no type conversion.
11:25:55 <byorgey> Nibble: Haskell does not have any type conversions.
11:25:57 <Nibble> I mean, not as in cast this var from int to float but more like, I have a Book and could I define a function to make it a Movie
11:26:05 <byorgey> there are only functions of type  A -> B.
11:26:09 <monochrom> yes you can
11:26:44 <Nibble> there's something I am missing, hold on
11:27:10 <frerich> Out of curiousity (I suppose somebody with an actual education can tell): would it be possible to extend hoogle so that I can enter a function (say, 'map toLower') and it tries to find equivalent functions which are shorter?
11:27:35 <frerich> I know that figuring out whether two functions are equal is a pain, but still
11:27:41 <Nibble> frerich: yes, of course it would be possible.
11:28:02 <Nibble> you would start by comparing types
11:28:11 <monochrom> I don't think anyone is willing to implement it
11:28:35 <dschoepe> Doesn't hlint do a few hardcoded things like this?
11:28:44 <kmc> frerich, @pl sort of does that.  it's like writing an optimizing compiler
11:28:46 <monochrom> yes
11:28:49 <kmc> but the target language is the source language
11:29:07 <frerich> kmc: Yes, I was actually thinking of @pl as well - at least its ability to realize that other functions can be applied.
11:29:36 <kmc> it's not just "a pain" but mathematically impossible to determine algorithmically if two functions are equal, in the general case
11:29:54 <frerich> Every now and then I have functions like 'map toLower' which seem very common to me, but searching by their signature simply returns way too many hits.
11:30:04 <kmc> the system would necessarily be limited and heuristic but might still be very useful
11:30:32 <frerich> dschoepe: I think the hlint stuff is hardcoded, yes, I saw that once somewhere
11:31:05 <frerich> It would be cool if there was something which parses a few popular packages and which can then go 'Oh look you are composing these three functions, but you can do it with just these two' or so
11:31:21 <frerich> Or, in the best case 'Instead of composing these four, just use this plain function which does just that'
11:32:06 * hackagebot happstack-server 6.5.4 - Web related tools and services.  http://hackage.haskell.org/package/happstack-server-6.5.4 (JeremyShaw)
11:32:11 <kmc> frerich, you could also do something approximate based on random-input testing
11:32:14 <kmc> a la QuickSpec
11:32:19 <kmc> www.cse.chalmers.se/~nicsma/quickspec.pdf
11:33:23 <Nibble> chalmers
11:33:26 <Nibble> THATS FROM SWEDEN
11:33:35 <Nibble> WE RULE!!! SWEDEN SWEDEN SWEDEN
11:33:50 <kmc> ...
11:34:31 <frerich> Nibble: My wife, who's swedish, claims that swedes aren't too patriotic - except for putting swedish flags on birthday cakes.
11:34:43 <sm> in a graphical gnu emacs on mac (from emacsformacosx.com), in a shell window, in a ghci session, Data.Char.ord of 'ANYNONASCIICHAR' is 32. It works ok in mac terminal. What's going on ?
11:35:09 <biio> double woo, I've had lectures with both koen and john hughes, they are both awesome
11:35:12 <Nibble> frerich: that depends on what generation, 40+ are kinda patriotic, ~20-30 aren't generally
11:35:15 <Nibble> http://fliiby.com/file/340916/lscnouu71b.html
11:38:25 <kmc> Nibble, there's a lot of Haskell-related research from Chalmers
11:38:35 <kmc> they are also developing Agda: http://wiki.portal.chalmers.se/agda/pmwiki.php
11:38:56 <Nibble> kmc: I know, I AM FROM SWEDEN
11:38:58 <Nibble> MEATBALLS
11:39:00 <Nibble> IKEA
11:39:10 <Nibble> And Agda
11:39:13 <arcatan> METABALLS
11:39:17 <Nibble> arcatan: haha
11:39:23 <arcatan> wait, wat, this is not -blah
11:39:40 <kmc> perhaps the discussion of sweden should move to #haskell-blah
11:39:55 <Nibble> kmc: it's not fun without the risk
11:40:00 <kmc> or #haskell.se :D
11:40:08 <Nibble> why not just keep the sweden diskussion here until someone comes along with something more fun
11:40:21 <Nibble> STUREPLAN
11:40:27 <kmc> because it's probably not that interesting to most of the ~900 people here
11:40:38 <cmccann> I dunno, meatballs are pretty tasty
11:40:46 <Nibble> and metaballs are kinda funny
11:41:25 <Nibble> because the joke is so... metay
11:41:48 <kmc> kids, don't smoke pot and irc at the same time
11:42:02 <kmc> in fact smoking irc at all is seriously damaging to your health
11:42:09 <Nibble> funny how the first part isn't legal in sweden
11:42:16 <Nibble> and soon the second part will not be either...
11:42:17 <CodeWeaver> My pythagorean triples program finally finished.   That is way too fricken' slow.
11:42:18 <Nibble> ACTA
11:42:26 <Nibble> anyone going to the demonstration on saturday?
11:42:31 <Nibble> CodeWeaver: how does it look like
11:42:43 <cmccann> CodeWeaver, oh?
11:42:51 <kmc> CodeWeaver, did you compile it with ghc -O2?
11:43:03 <CodeWeaver> Not yet.  May try that next. :)
11:43:11 <kmc> ghci is quite slow compared to compiled code
11:43:11 <CodeWeaver> I expect it'll still take like a half hour to run.
11:43:17 <mdmkolbe> I want to install emgm version 0.3.1 which requires (base < 4) but am running on GHC 7.0.3 (i.e. base >= 4).  Is there a way to tell cabal to try to install it anyway and see if it can run under "base >= 4"?
11:43:18 <CodeWeaver> I'll give it a go.
11:43:30 <cmccann> CodeWeaver, -O2 vs. GHCi can be an enormous difference
11:43:35 <kmc> (you can also compile a module and then interact with it from ghci)
11:43:59 <CodeWeaver> I got (11900,56019,57269)  as my answer, though, so I have to verify the sequence I got against sequences other people have gotten, to make sure I haven't missed one, or generated an extra (non-primitive) or something.
11:44:13 <neutrino> hi
11:44:23 <neutrino> i am having problems ironing out this parser
11:44:26 <Nibble> neutrino: hey
11:44:31 <rwbarton> what's the problem, find the nth primitive pythagorean triple in some specific ordering for some n?
11:44:47 <neutrino> my current code is at: http://hpaste.org/57297
11:44:53 <CodeWeaver> Yes… Given (a,b,c), ordered by b, no non-primitives.
11:45:10 <neutrino> i am having a problem defining a block which can be of variable length. it seems to be eating up everything, which is not correct.
11:45:26 <cmccann> CodeWeaver, are you using something based on my code, or your own approach?
11:45:37 <CodeWeaver> I'm not totally convinced yet that cmccann's doesn't miss one.
11:45:59 <cmccann> neither am I, but it doesn't miss any of the first 1000 or so it seemed
11:46:03 <CodeWeaver> My own approach which is fricken slow, but is very tightly coupled to generating the b's in the correct order and does a hard search.
11:46:07 <neutrino> the part making issues seems to be "garbageP".
11:46:11 <CodeWeaver> I'll run yours against mine. :)
11:46:24 <CodeWeaver> Can you paste your pastebin link again cmccann?
11:47:14 <rwbarton> neutrino, it looks like garbageP can consume any number of lines, that is, any string ending in "\n".
11:47:18 <rwbarton> I don't know what you intended it to do.
11:47:21 <cmccann> CodeWeaver, http://hpaste.org/57197
11:48:37 <k0ral> hi there, how can I define a type corresponding to an Int inside a given interval ?
11:48:47 <neutrino> rwbarton: exactly
11:49:11 <neutrino> rwbarton: i intended for it to be able to consume any number of lines, but i thought it would be limited by the further parsers used in the sectionP combined parser
11:49:21 <neutrino> rwbarton: i only want it to parse things that other parsers won't want..
11:50:49 <cmccann> CodeWeaver, do you have some goal for generating the triples, anyway? can't recall.
11:51:13 <CodeWeaver> No, not really.  Just an Euler-like challenge.
11:51:38 <CodeWeaver> I do appreciate other people taking them on to give me perspective.  I am thusly educated.
11:52:14 <Nibble> CodeWeaver: you don't happen to be CodeBlock?
11:52:26 <CodeWeaver> aroo?  No.
11:54:03 <neutrino> rwbarton: any ideas, perhaps?
11:54:23 <rwbarton> i would suggest moving the "garbage" logic into sectionHeaderP and datesHeaderP
11:54:34 <neutrino> why?
11:54:39 <neutrino> hmm
11:54:43 <rwbarton> have them discard garbage lines before the line they are looking for
11:54:45 <neutrino> ah, i see what you mean there
11:54:58 <CodeWeaver> Eh, crap, cmccann's isn't sorted by b.  I'll have to collect and resort them.  No biggy. :)
11:55:02 <rwbarton> because, if I understand what you're trying to do, you can't know what "garbage" is without knowing what kind of next line you're looking for
11:55:25 <rwbarton> you could do this uniformly for both at once
11:55:30 <cmccann> CodeWeaver, I think you can just change the sort order it uses
11:55:37 <CodeWeaver> Can I?  Okay
11:55:48 <rwbarton> withGarbage p = try p <|> (many (noneOf "\n") >> string "\n" >> withGarbage p)
11:55:57 <neutrino> rwbarton: you're right, thanks
11:56:59 <neutrino> rwbarton: but, how do i integrate this? hmmm
11:57:06 * hackagebot scion-browser 0.2.6 - Command-line interface for browsing and searching packages documentation  http://hackage.haskell.org/package/scion-browser-0.2.6 (JeanPhilippeMoresmau)
11:57:08 <neutrino> rwbarton: oh, i think i know
12:03:15 <ckid> hello, i want to go through the book "the haskell school of expression", but i already fail by importing "SOEGraphics", WinGHCi says "Could not find module `SOEGraphics':" i tried cabal install SOEGraphics but nothing is found. the same error occurcs if i try cabal install Graphics.SOE (http://hackage.haskell.org/packages/archive/HGL/3.2.0.0/doc/html/Graphics-SOE.html)
12:05:31 <kmc> ckid, "cabal install" works on a package, not a module
12:05:41 <kmc> a package is a collection of modules
12:05:45 <doserj> ckid: if you have HGL installed, "import Graphics.SOE" instead of "import SOEGraphics" should work.
12:05:48 <CodeWeaver> cmccann:  Apparently we differ within the first 1000, so, if you verified yours against a known list in that sequence, my code must be wrong.
12:06:00 <kmc> in this case the package is named HGL, as you can see at the very top of the page or in the url
12:06:18 <kmc> so you would do "cabal install HGL"
12:06:24 <CodeWeaver> cmccann:  I'm pretty sure mine guarantees the right ordering, so maybe I missed one or added one.
12:06:37 <cmccann> CodeWeaver, http://www.math.rutgers.edu/~erowland/tripleslist-long.html
12:06:41 <kmc> packages are the unit of install and versioning; they contain modules, which are the unit of namespacing and import control
12:07:26 <ckid> ok, thanks
12:07:53 <cmccann> CodeWeaver, it seemed to work the same no matter which order I used, and it matched up with the end of that list of 957 triples
12:08:42 <CodeWeaver> Hmmmm
12:09:48 <cmccann> CodeWeaver, what's the first place they disagree?
12:10:43 <ckid> kmc: if i try "cabal install HGL" it says "cabal: cannot configure HGL-3.2.0.2 It requires base ==3. * For the dependency on base ==3.* there are these packages: base-3.0.3.1 and base-3.0.3.2. However none of them are available."
12:11:02 <sm> here's an alias for switching your virthualenv (ghc & package set): https://github.com/Paczesiowa/virthualenv/issues/34
12:11:14 <phimuemue_> @type map
12:11:15 <lambdabot> forall a b. (a -> b) -> [a] -> [b]
12:11:45 <kmc> ckid, yeah, it looks like HGL hasn't been updated in about 2 years and probably won't work with GHC 7.x
12:11:54 <ckid> um ok
12:12:05 <kmc> i would google around to see if someone has a solution
12:12:06 <doserj> ckid: try "cabal install soegtk"
12:12:10 <ckid> so i should switch to a lower version?
12:12:17 <CodeWeaver> cmccann:  Damn, I lied.  We're good up to the first 1000.
12:12:26 <doserj> soegtk is the soe implementation based on gtk
12:12:34 <cmccann> CodeWeaver, haha, good, was worried there
12:12:45 <CodeWeaver> cmccann: So was I.
12:12:53 <kmc> yeah, that looks more likely to work
12:13:11 <kmc> though you'll have to get gtk2hs to install, which is sometimes tricky
12:14:43 <ckid> um yeah, there are several ExitFailure1: cairo, gtk2hsC2hs, gio, glib, gtk, pango
12:16:36 <kmc> ckid,   http://code.haskell.org/gtk2hs/INSTALL  see "Building on Windows"
12:16:37 <sm> there ought to be a simple way to share live screens here
12:17:02 <ckid> kmc: thanks i will try it
12:17:43 <ckid> the link under "windows" does not seem to work
12:18:20 <ckid> i will look somewher else for the download
12:18:24 <kmc> it will be somewhat easier to get this running on linux
12:18:32 <kmc> if you have a linux machine or VM handy
12:18:42 <kmc> anyway there are people here who have installed gtk2hs on windows (i am not one of them)
12:21:57 <ckid> kmc: yes, someone already told me that things are easier with linux. however i think then reading the book "haskell school of expression" does not make sense anymore, does it? as the book says the SOEGraphics is only for windows
12:22:50 <kmc> ckid, the successor package soegtk should work on linux
12:22:52 <kmc> not that i've used it
12:23:00 <kmc> the book is old and you will have to make some adjustments
12:23:28 <ckid> okay
12:24:27 <jedai> ckid: did you install gtk2hs-buildtools (or something like that) beforehand ?
12:24:41 <ckid> jedai: n
12:24:42 <ckid> o
12:25:03 <jedai> ckid: it's often all that's necessary (with an installation of gtk+-2.24 (not 2.22) too
12:26:58 <jedai> ckid: basically, you download the all inclusive package from Gtk, you cabal install gtk2hs-buildtools and then everything should install nicely (in the main gtk2hs anyway, you need some more libs for svgcairo for example)
12:27:12 <kmc> you will also need the gtk C library headers for your system, no?
12:27:24 <lukish> ["a", "b", "c", "d"] -> ["ab","cd"]. How can I do that? [String] -> [String]
12:27:36 <kmc> on linux, a package like libgtk-3-dev or such
12:27:38 <jedai> kmc: Yes, that's in the package for windows you can download on gtk webpage
12:27:48 <Botje_> pattern match two items at a time, append then.
12:28:11 <kmc> > let f (x:y:xs) = (x++y) : f xs; f _ = [] in f ["a", "b", "c", "d"]
12:28:13 <lambdabot>   ["ab","cd"]
12:28:21 <kmc> cool
12:28:40 <roconnor> let f ["a", "b", "c", "d"] = ["ab","cd"] in  f ["a", "b", "c", "d"]
12:28:45 <roconnor> > let f ["a", "b", "c", "d"] = ["ab","cd"] in  f ["a", "b", "c", "d"]
12:28:46 <lambdabot>   ["ab","cd"]
12:29:02 <Botje_> roconnor: it's like teaching your computer! it's magic! :)
12:29:06 <neutrino> oh damn, i almost have this parser done
12:29:31 <jedai> ckid: from gtk.org, download the "all-in-one bundle" for windows
12:29:37 <lukish> kmc: I'm looking for some pointfree variant
12:29:47 <roconnor> Botje_: I think it is the least solution to the stated problem (least in the CPO sense :)
12:31:50 <lispy> hello
12:32:13 <Botje_> > map toUpper "hallo"
12:32:14 <lambdabot>   "HALLO"
12:36:40 <CodeWeaver> cmccann:  Ran both of ours in parallel.  Verification that at 10000 elements we're still equal, plus:
12:36:41 <CodeWeaver> Value at index 10000 is (13143,56024,57545)
12:36:41 <CodeWeaver> plus running *both* of ours, compiled at -O2 finished in just under a minute.
12:36:50 <cmccann> :D
12:36:56 <CodeWeaver> I don't have a smiley that hits the floor far enough.
12:37:15 <ckid> jedai: 'caballing' gtk2hs-buildtools worked well; i extracted the all-in-one-bundle and updated the pathvariable. umm so now ... cabal install HGL should work? (or what do i have to install? :|)
12:37:24 <cmccann> are you convinced that trying with -O2 is worthwhile now? :P
12:37:34 <CodeWeaver> Just just just just HUSH YOU :D
12:37:40 <cmccann> haha
12:38:15 <jedai> ckid: Well maybe, what I can more or less guarantee is that cabal install gtk (so glib, cairo, pango...) will work,  I don't know about HGL
12:38:57 <doserj> you don't need HGL. after you installed soegtk successfully, just use "import Graphics.SOE.GTK"
12:40:09 <lukish> @pl (\[a,b] -> b ++ " - " ++ a )
12:40:09 <lambdabot> (line 1, column 3):
12:40:09 <lambdabot> unexpected "["
12:40:10 <lambdabot> expecting pattern
12:44:59 <doserj> > intercalate " - " ["Hello", "World"]
12:45:00 <lambdabot>   "Hello - World"
12:45:05 <ckid> doserj: ok, but right now it is still installing gtk, "preprocessing library gtk-0.12 .2"  now since 3 minutes, i hope that is ok!
12:45:16 <luite> yeah it can take some time
12:45:17 <neutrino> so guys, how do i get this to parse the whole file now? it's in the variable "example": http://hpaste.org/57298
12:45:38 <neutrino> i'm just missing the part where i have to parse some garbage at the end of file beyond the last "section" as i call them
12:46:11 <neutrino> if you look at "example" then you will notice that the file is composed of a garbage header, and two "sections"
12:51:27 <neutrino> but this is just so damn confusing!
12:54:10 <neutrino> rwbarton: are you by any chance still there?
12:54:30 <ckid> doserj: both cabal install gtk / install soegtk semmed to be installed without errors; but "import Graphics.SOE.GTK" does not work
12:55:36 <doserj> Graphics.SOE.Gtk, not Graphics.SOE.GTK
12:55:53 <doserj> (sorry)
12:57:39 <ckid> it works! thanks a lot for all your kind responses to these noobish questions :)
12:58:17 <frerich> Hm, cool, I think I found a Haskell niche for me: a good module for reading RSS files seems to be missing.
12:59:19 <_Mikey> http://i0.kym-cdn.com/entries/icons/square/000/006/151/tumblr_lltzgnHi5F1qzib3wo1_400.jpg
12:59:42 <_Mikey> ahh sorry I thought I was in haskell-blah for a minute..
12:59:54 <_Mikey> but seriously, that's a good idea.
13:05:49 <neutrino> aaaargh how do i do this
13:06:10 <sm> frerich: what about the feed package ?
13:07:11 * hackagebot buildwrapper 0.4.1 - A library and an executable that provide an easy API for a Haskell IDE  http://hackage.haskell.org/package/buildwrapper-0.4.1 (JeanPhilippeMoresmau)
13:07:13 <frerich> I'm currently dissecting this little piece of Haskell: 'revert (0:ft) = rs where rs = 0 : 1/(ft#rs)' <-- what does the '#' do there? 'ft' must be some list, and this function yields an infinite list; I gathered that much.
13:08:04 <DanBurton> frerich: # isn't in Prelude, what imports or language pragmas are you using?
13:08:05 <monochrom> the context may say what # is
13:08:12 <frerich> sm: That seems to be just a plugin for some GUI program called 'Manatee'. Not a general purpose RSS parser.
13:08:39 <frerich> DanBurton: There is unfortunately no context; I got this from the home page of Doug McIlroy (yes, *that* McIlroy) at http://www.cs.dartmouth.edu/~doug/
13:09:10 <frerich> He had this under the caption 'Power serious: Haskell magic', but I don't know what this does.
13:09:42 <KorriX> hello everybdy
13:09:46 <monochrom> well, apparently, the context contains "Power serious: Haskell magic", which is a hyperlink
13:09:50 <frerich> Aaah, drat - that title is a link. Clicking it shows some more definitions
13:10:00 <frerich> I didn't realize it's clickable...
13:10:09 <monochrom> you see, there is always some context
13:10:17 <monochrom> "there is no context" is always a lie
13:10:33 <frerich> monochrom: If it's always a lie, it's never a lie.
13:10:51 <KorriX> is there any good library for Haskell for manipulating processes (setting execution time limits, memory limits, checking output signal code with some of gdb elements) ?
13:10:54 <frerich> monochrom: Just a matter of what your relative system is. In my case, I was looking for context in the Haskell program :)
13:12:33 <kallisti> hmm, is there a way to, given a pointer, set it to be the null pointer? this would require a pointer to the pointer right?
13:12:41 <kallisti> (FFI. I promise it's Haskell related. :P )
13:13:10 <Athas> kallisti: yes, you need a pointer to a pointer.
13:13:34 <kallisti> okay. but mallocing a pointer just to poke it before freeing it, seems... odd.
13:13:47 <kallisti> wait, I don't think that would work either.
13:13:49 <Athas> Yes, why would you do that?
13:14:15 <kallisti> no idea. :P
13:14:21 <Athas> Remember that when you pass a pointer, it's "by value" (not exactly or necessarily, but it works as a metaphor).
13:14:26 <kallisti> right
13:14:53 <Athas> So you need a layer of indirection.
13:15:22 <kallisti> Learning C basics: Haskell Edition!
13:15:30 <CodeWeaver> *snort*
13:17:37 <kmc> <kallisti> mallocing a pointer just to poke it before freeing it   <---- sounds like a use case for alloca
13:17:49 <monochrom> perhaps an IORef (Ptr Int)?
13:17:56 <erus`> i cant help but feel a strictly normalizing language would be better than lua for wikipedia's template language
13:18:02 <kallisti> well right now I'm working on the Storable instance
13:18:08 <kallisti> for a [Hook f]
13:18:19 <kallisti> that corresponds to a C struct that is a linked list.
13:18:32 <kallisti> (but with other stuff thrown in)
13:18:32 <Athas> monochrom has the right idea, I think.  When you're doing FFI stuff, you're usually going to hide it behind an abstract data type.
13:19:00 <kallisti> so I wanted a poke of [] to set a pointer to the struct to null, but I guess that won't work.
13:19:11 <Athas> You can't poke lists.
13:19:15 <kallisti> maybe make a storable instance for IORef [Hook f]  ?
13:19:22 <kallisti> Athas: er, I meant
13:19:25 <kallisti> poke ptr []
13:19:41 <kmc> writing Storable instances is overrated
13:19:48 <kmc> sometimes you don't need them
13:19:51 <Athas> Yeah, you probably should not do that.
13:19:51 <kallisti> ...um
13:20:04 <kallisti> so....
13:20:07 <Athas> What would a Storable instance for an IORef even look like?
13:20:08 <kallisti> wait, what?
13:20:17 <Athas> You'd lose a lot of IORef properties.
13:20:22 <kallisti> basically I want...
13:20:29 <kallisti> poke something []
13:20:37 <kallisti> to set the linked list structure internally to a NULL
13:20:39 <kallisti> or
13:20:42 <kallisti> something equivalent to that effect.
13:20:44 <mauke> I don't think it makes sense to define a Storable instance for non-structs
13:20:59 <kallisti> so, just hard-code the linked list into the structure?
13:21:11 <mauke> what operations do you need?
13:21:27 <Athas> kallisti: don't use poke for that.
13:21:35 <kmc> right, Storable things are supposed to have fixed size, among other constraints
13:21:44 <kmc> just write whatever accessors / mutators you need
13:21:46 <kallisti> f :: Ptr a -> [Hook f] -> IO ()
13:21:52 <kmc> writeMyShit :: [Stuff] -> Ptr Crap -> IO ()
13:21:53 <kallisti> f :: Ptr a -> IO [Hook f]
13:22:07 <Athas> If you want to "clear" a linked list, you also have to deallocate memory, and poke could never do that.
13:22:10 <erus`> @djynn (t -> t) -> t
13:22:11 <lambdabot> -- f cannot be realized.
13:22:20 <kmc> don't worry about shoehorning it into a type class it doesn't belong in
13:22:31 <kallisti> kmc: okay, so then how do I set the pointers to the C linked list
13:22:40 <erus`> @djynn (t -> t) -> t = f x = x (f x)  you suck
13:22:40 <lambdabot> Cannot parse command
13:22:57 <kallisti> I guess it would technically be something like
13:22:59 <kmc> kallisti, using poke?
13:23:00 <shachaf> erus`: f x = undefined
13:23:10 <kmc> i think you should give us more detail about the C and Haskell APIs
13:23:17 <kallisti> writeMyShit :: Ptr (Ptr a) -> [Hook f] -> IO ()
13:23:30 <kallisti> or
13:23:34 <kallisti> writeMyShit :: IORef (Ptr a) -> [Hook f] -> IO ()
13:23:39 <Athas> Yes!  Do the latter.
13:23:39 <kmc> right
13:23:56 <Athas> Don't do pointer-fiddling in Haskell unless you really have to.
13:24:08 <kallisti> okay so I'll just write an instance of Storable for Hook, ignore the internal linked list bits
13:24:11 <kallisti> then write this function
13:24:13 <kallisti> which deals with that.
13:24:16 <kallisti> sure. that works.
13:24:44 <Athas> Then you can also pass around the IORef (which is garbage-collected - you could even add a finalizer!) as a sort of abstraction.
13:25:13 <kmc> or don't write a Storable instance for Hook
13:25:24 <kmc> i don't know what Hook is, so I can't say whether it's a good idea or not
13:25:44 <kallisti> not writing the Storable instance and writing the Storable instance are going to lead to essentially equivalent code
13:25:52 <kallisti> the difference being, well, one isn't an instance of something.
13:26:43 <kmc> ok, if that's the case
13:26:45 <kallisti> also: it's already written
13:27:07 <kmc> sometimes I don't actually create a Haskell type for the C struct
13:27:11 <kmc> like here:  https://github.com/kmcallister/hdis86/blob/master/Hdis86/C.hsc#L106
13:27:11 * hackagebot yesod-recaptcha 0.1 - Dead simple support for reCAPTCHA on Yesod applications.  http://hackage.haskell.org/package/yesod-recaptcha-0.1 (FelipeLessa)
13:27:18 <kallisti> (Hook is basically a function pointer associated with a name)
13:27:36 <kallisti> it corresponds to a C struct that is essentially the same thing but also is a doubly linked list with next and prev pointers.
13:27:47 <ckid> i installed gtk2hs-buildtools, gtk and soegtk; importing Graphics.SOE.Gtk and loading a simple file into WinGHCi works, but if i try to run the program via "main" the following error occurs:Loading package transformers-0.2.2.0 ... linking ... ghc: unable to load package `transformers-0.2.2.0'
13:28:15 <kallisti> the reason I need to emulate it, is because my Haskell code has to register callbacks with the C interface via this list of function pointers.
13:30:17 <ckid> doserj: cabal install transformers says that the package already is installed, maybe it is a problem of WinGHCi?
13:30:25 <kallisti> hmmm, perhaps I don't need a Storable instance.
13:34:58 <k0ral> :t elemIndices
13:34:59 <lambdabot> forall a. (Eq a) => a -> [a] -> [Int]
13:35:12 <k0ral> :t length . elemIndices
13:35:13 <lambdabot>     Couldn't match expected type `[a]'
13:35:14 <lambdabot>            against inferred type `[a1] -> [Int]'
13:35:14 <lambdabot>     Probable cause: `elemIndices' is applied to too few arguments
13:35:44 <mauke> :t length . elemIndices ?x
13:35:45 <lambdabot> forall a. (?x::a, Eq a) => [a] -> Int
13:36:02 <k0ral> what ?!
13:36:07 <k0ral> "?x"
13:36:43 <k0ral> what's this syntax ?
13:37:00 <epdtry> k0ral: it's a GHC extension for implicit arguments to functions
13:37:29 <epdtry> k0ral: it's useful with lambdabot because it shows you the type that GHC inferred for the variable based on how you used it
13:38:07 <k0ral> :t \x -> length . (elemIndices x)
13:38:08 <lambdabot> forall a. (Eq a) => a -> [a] -> Int
13:55:34 <erus`> is there some concept of unique types, where i can differentiate between two instances that have the same values without passing around indexes (or w/e) explicitly?
14:05:40 <dylukes> Monads monads monads?
14:05:42 <dylukes> Monads monads!
14:05:45 <dylukes> Monads XD.
14:05:52 <monochrom> are you ok?
14:05:58 <dylukes> Monaaaads XD.
14:06:00 <erus`> no state monads
14:06:07 <amiller> monadic composition
14:06:09 <dylukes> Monads. Monads monads monads.
14:06:17 <monochrom> alright, you are not ok
14:06:22 <kmc> this is the worst trolling i have ever seen
14:06:24 <dylukes> Mo-Mo-Monads!
14:06:31 <dylukes> kmc: Monads.
14:06:31 <erus`> Buffalo Buffalo Monad
14:06:36 <kmc> shut up all of you
14:06:41 <cheater> kmc++
14:06:54 <kmc> damn kids get off my lawn
14:07:15 <dylukes> withKids $ do {getOffMyLawn; never return}
14:07:26 <amiller> that's satisfactory
14:07:36 <_Mikey> witty :)
14:07:46 <erus`> ok i cant define a list type without type recursion
14:08:09 <erus`> some kinda type fix operator or something
14:09:00 <kmc> that's right
14:09:05 <kmc> http://mainisusuallyafunction.blogspot.com/2010/12/type-level-fix-and-generic-folds.html
14:11:22 <erus`> Hmm i wonder if i can re-use my de-brujn indices here :D
14:12:12 <erus`> is type checking gonna be deterministic still?
14:12:17 <erus`> i guess not
14:12:26 <erus`> how does agda do it
14:12:37 <kmc> why would it not be deterministic
14:13:13 <erus`> because Fix ( Index 0)
14:13:33 <c_wraith> that's deterministic.  Just non-terminating
14:13:42 <c_wraith> and the typechecker has a max depth
14:13:49 <erus`> yeah but if i try and type check a value against that
14:13:53 <c_wraith> it should eventually bail out with an error message
14:13:58 <erus`> welcome to the void
14:14:11 <c_wraith> (though there have been cases where it doesn't bail out with an error)
14:14:31 <erus`> so i guess i just have a recursion limit or something?
14:14:41 <erus`> (when type checking)
14:14:48 <erus`> i can live with that
14:20:51 <erus`> what do i call the parts of a sum type? sub-types or constructors or something?
14:21:47 <c_wraith> alternatives, maybe?  That interacts badly with the Alternative typeclass, though
14:22:57 <acowley> variants
14:27:55 <erus`> "Many languages support, to some extent, a universal data type, which is a type that includes every value of every other type, and often a way is provided to test the actual type of a value of the universal type. These are sometimes referred to as variants"
14:29:33 <erus`> ok i have cool types now but typechecking is no longer guaranteed to  terminate
14:32:01 <erus`> I just need to modify my Forall to have type constraints and them im haskell styleee :D
14:32:13 * hackagebot scan-vector-machine 0.0.1 - An implementation of the Scan Vector Machine instruction set in Haskell  http://hackage.haskell.org/package/scan-vector-machine-0.0.1 (AdamMegacz)
14:37:13 * hackagebot happstack-server 6.5.6 - Web related tools and services.  http://hackage.haskell.org/package/happstack-server-6.5.6 (JeremyShaw)
14:38:57 <ksf> uhhh... is "default" a reserved word?
14:39:03 <kallisti> kmc: can you translate an IORef directly to a pointer for purposes of interfacing with C?
14:39:25 <kallisti> such that, modifying the IORef also reassigns the location pointed to
14:39:26 <ksf> what arcane corner of haskell am I missing there?
14:39:39 <rwbarton> it's a declaration to control defaulting
14:39:49 <ksf> and wth does it reserve such a nice identifier name?
14:39:54 <kallisti> for example, by default Num is assumed to be Integer
14:39:59 <kallisti> > 5
14:40:00 <lambdabot>   5
14:40:01 <kallisti> that makes this possible.
14:40:06 <erus`> cana a datatype have the kind (* -> *) -> * ?
14:40:08 <ksf> (though "in" tripped me more often)
14:40:28 <kallisti> if there were no defaulting, then you would to make numbers ambiguous everywhere.
14:40:32 <kallisti> *unambiguous
14:40:37 <kallisti> > 5 :: Integer  -- like this
14:41:23 <kallisti> lambdabot: ...?
14:41:31 <kallisti> can comments not go after type annotations?
14:41:38 <kallisti> > (5 :: Integer)  -- like this
14:41:54 <lambdabot>   5
14:41:54 <lambdabot>   can't find file: L.hs
14:41:56 <erus`> i guess my Forall's need kinds as well as type classes
14:41:56 <kallisti> ah.
14:42:02 <kallisti> lag, apparently.
14:42:53 <erus`> try again with dependant types tmo
14:43:02 <kallisti> class Wrapped f where wrapF :: f -> IO (FunPtr f)
14:43:13 <kallisti> I'm finding this typeclass useful for writing Storable instances involving function pointers.
14:43:47 <kallisti> I'm wondering if it would be sensible to also include an "inverse" :: FunPtr f -> f
14:44:36 <kallisti> which begs the question: what happens when you write (f . g) h,  where g is a function created with a wrapper stub, f is a function created with a dynamic stub, and h is a normal Haskell function.
14:45:02 <kallisti> I would imagine it's not a perfect NOP; there must be some overhead involved.
14:45:07 <kallisti> +be
14:46:00 <kmc> kallisti, no, I don't think you can translate an IORef to a pointer that's useful in C code
14:46:17 <kmc> you can translate an IORef (or any other Haskell value) into an opaque value that looks like a pointer, using http://lambda.haskell.org/platform/doc/current/ghc-doc/libraries/haskell2010-1.0.0.0/Foreign-StablePtr.html
14:46:24 <kmc> but you aren't allowed to deref this pointer in C
14:46:36 <kallisti> ah
14:46:44 <kmc> it's only useful because you can pass that value back into Haskell and recover the original Haskell value
14:47:11 <kallisti> I see
14:47:20 <kallisti> isn't there a pointer with a finalizer as well?
14:47:28 <kallisti> that would be nice, since I'm dealing with linked lists here.
14:47:34 <kmc> you can attach finalizers to various stuff
14:47:44 <kmc> pointer with finalizer is ForeignPtr
14:48:05 <kallisti> I'm assuming that is also unavailable to deref in C.
14:48:10 <kallisti> if it is, that's insane.
14:48:37 <kmc> you use withForeignPtr :: ForeignPtr a -> (Ptr a -> IO b) -> IO b
14:48:56 <kmc> the (Ptr a -> IO b) code can call into C
14:49:13 <kmc> it keeps the foreignptr alive over that call, and thus prevents the finalizer from running
14:49:17 <kallisti> ah
14:49:18 <kallisti> cool.
14:49:29 <kmc> there's also unsafeForeignPtrToPtr :: ForeignPtr a -> Ptr a  but then you have to do that yourself
14:49:37 <kallisti> yes
14:49:51 <kallisti> hm, though I'd imagine ForeignPtr translate well into something like auto_ptr in C++
14:49:57 <kallisti> *translates
14:50:16 <kmc> maybe
14:50:22 <kmc> then you have to mix garbage collection and reference counting
14:51:11 <kmc> well, not with auto_ptr
14:51:17 <kmc> but with boost or C++11 shared_ptr stuff
14:51:32 <Rc43> Hi, guys.
14:52:00 <Rc43> Is it possible install haskell platform and set ghc use microsoft compiler instead mingw?
14:52:35 <kmc> doubtful
14:53:23 <kmc> definitely not with -fvia-C, but that's deprecated these days
14:53:29 <kmc> probably not otherwise
14:55:41 <kmc> kallisti, I used the unsafe ForeignPtr stuff in hdis86... the C library has a function to set the buffer it reads from, which is used over multiple calls
14:55:53 <kmc> so i converted a ByteString to a ForeignPtr and then unsafely to a Ptr
14:56:29 <kmc> but i also hang onto the ForeignPtr in the Haskell state, and touch it just before setting a new input source, or when the finalizer runs
14:56:53 <Enigmagic> instead of Data.ByteString.Unsafe.unsafeUseAsCStringLen or for some other reason?
14:58:01 <kmc> unsafeUseAsCStringLen has the same inversion of control as withForeignPtr
14:59:01 <kmc> i don't think it does anything to ensure the ByteString buffer sticks around after the wrapped action completes
14:59:58 <Enigmagic> well no, i would hope it doesn't keep the buffer around once the action completes
15:00:11 <kmc> but that's what i need
15:00:22 <kmc> the API i provide at this level is setInputBuffer :: UD -> ByteString -> IO ()
15:00:38 <kmc> UD being an abstract type for an instance of the library
15:00:52 <kmc> then you can use other methods on that UD and it will keep reading from the ByteString
15:01:02 <kmc> there's also a pure functional interface wrapping all this
15:01:21 <Enigmagic> i see
15:01:54 <Enigmagic> i'm glad none of the APIs i use are like that :P
15:02:27 <kmc> yeah, well, you have the choice
15:03:03 <kmc> the highest level interface is Config -> ByteString -> [Instruction]
15:03:06 <kmc> (it's a disassembler)
15:03:26 <kmc> if you need more control or performance, you drop down to the IO interface, which matches the operations of the underlying C library
15:03:40 <Enigmagic> i was talking about the C API not the haskell bindings
15:03:43 <kmc> but still provides memory safety, thread safety, and automatic resource management
15:04:00 <kmc> well, I think udis86 has a pretty sane API for a C library
15:04:04 <kmc> there's no global state
15:04:11 <kmc> the current buffer and everything else is stored in a struct
15:04:17 <kmc> which the user can allocate however they like
15:05:01 <kmc> and i wrote the hdis86 bindings but i did not write udis86 so i'm less biased there ;)
15:05:32 <neutrino> i shot the hdis86 but i didn't shoot the udis86
15:06:22 <kallisti> TypeSynonymInstances is a silly extension
15:06:36 <kmc> more like, it's silly that it's not in the spec
15:06:39 <kallisti> yes.
15:06:43 <kallisti> same as FlexibleContexts
15:07:03 <kmc> i can see what they were going for as far as the lack of flexibility in instances and contexts
15:07:26 <kmc> it makes instance resolution a very simple, syntax-directed process
15:07:34 <kmc> it's for the benefit of Haskell implementers
15:08:12 <acowley> <users> we are the 99%
15:08:37 <kmc> bah, everyone knows functional languages are only useful for implementing other functional languages ;)
15:08:46 <kallisti> wait what.
15:08:50 <kallisti> type NormHook = Ptr PFuncs -> Ptr Msg -> IO CSize
15:08:56 <kallisti> why can't I write an instance for this type
15:09:06 <kallisti> without FlexibleInstances
15:09:40 <kmc> because it does not have the form (C a b ...) where C is a type constructor and a,b,... are variablesz
15:09:55 <kallisti> er... wait.
15:10:05 <kallisti> so (->) doesn't count as that?
15:10:07 <kmc> it has the form C (C C) (C (C C) (C C)
15:10:09 <kmc> )
15:10:11 <kallisti> oh
15:10:11 <kmc> or something like that
15:10:25 <kallisti> so will I break anything if I turn on FlexibleInstances?
15:10:32 <kmc> with non-flexible instances you can only write (->) or ((->) a) or (a -> b) according to kind
15:10:35 <kmc> no, it is a very safe extension
15:10:41 <kallisti> okay, good.
15:10:55 <kallisti> so now I'm at.... 6 extensions
15:11:05 <kallisti> good, that means I'm writing a real Haskell program. :>
15:11:09 <kmc> yep
15:11:11 <kmc> back in my day we just turned on -fglasgow-exts and called it good
15:11:24 <kallisti> I don't remember what that includes.
15:11:26 <ion> You still can. ;-)
15:13:28 <kmc> but people will hit you with sticks
15:14:26 <ion> Oh, there’s programming that does not involve that?
15:16:14 <kallisti> this lack of first-class record setters is really cramping my style.
15:16:20 <kallisti> but I'm too lazy to set up fclabels
15:16:25 <kallisti> or what's the new thing these days?
15:16:35 <roconnor> kallisti: data-lens
15:16:49 <kmc> data-lens is basically undocumented
15:16:52 <kmc> unless i'm missing something
15:16:58 <roconnor> I should fix that
15:17:19 <kmc> are you edwardk's amanuensis now?
15:17:24 <kallisti> could you use DeriveGeneric in conjunction with some kind of lens package, perhaps?
15:17:27 <kallisti> instead of relying on TH.
15:17:36 <roconnor> kmc: he has offloaded data-lens onto me.
15:17:40 <kmc> aha
15:17:41 <kmc> cool
15:18:08 <kallisti> hm, no I don't think that's possible.
15:18:18 <kallisti> you can't rename the field names that way.
15:18:50 <cmccann> roconnor, what's data-lens offer vs. fclabels, if anything?
15:18:51 * kallisti doesn't know very much about how GHC.Generic works.
15:19:14 <ion> It would be nice to have a wiki-style online editor for documentation (perhaps WYSIWYG even) for Hackage packages where you could just edit text and have it provide patch sets to authors.
15:19:31 <roconnor> cmccann: more efficent lens compositon IIUC
15:19:56 <ion> With the intention of making adding and modifying documentation a very easy process.
15:20:06 <DanBurton> ion: that sounds like a cool idea
15:20:08 <Enigmagic> actually more efficient or theoretically more efficient?
15:20:24 <Enigmagic> would be nice to document this stuff somewhere.
15:20:45 <luite> ion: just force authors to use github :)
15:21:11 <acowley> data-lens is surprisingly usable for its lack of documentation
15:21:30 <ion> While you’re reading some package’s documentation you could just hit an inline edit button, modify the text and click submit.
15:21:43 <cmccann> if you know what a "lens" everything in data-lens is basically self-explanatory
15:22:02 <MostAwesomeDude> I wish data-lens had docs, though.
15:22:14 * hackagebot ircbot 0.2.3 - A library for writing irc bots  http://hackage.haskell.org/package/ircbot-0.2.3 (JeremyShaw)
15:22:22 <roconnor> mental note: people want more documentation for data-lens
15:25:28 <insertpseudonym> trying to figure out lambda abstractions, can someone tell me what went wrong here? "[map (\x -> if (x==y) then (x+1)) m | y<-n]" where n and m are lists of digits
15:25:42 <prof7bit> <luite> ion: just force authors to use github :)  <-- then everybody who just quickly wants to provide a little patch of maybe one or two lines would have to learn git, clone the entire repository, spend an entire day to figure out how to make a patch... not very user friendly.
15:25:54 * acowley expects the data-lens documentation to consist solely of, "a lens is a monoidal natural transformation between higher-order coalgebra functors, what's the problem?"
15:26:20 <insertpseudonym> nvm got it
15:26:26 <luite> prof7bit: people who don't learn git are useless anyway ;p
15:26:28 <Enigmagic> prof7bit: i haven't noticed that being a problem so far
15:26:52 <cmccann> acowley, I thought data-lens was just based on comonads, not anything fancier
15:26:54 <prof7bit> i will just wait until this git hype is over
15:26:56 <Enigmagic> most haskell repos are super small too
15:27:05 <acowley> github is spectacularly awesome, I wish everyone used it
15:27:07 <Enigmagic> i'm just waiting for darcs to finally die
15:27:39 <prof7bit> and github is one of the few websites that is able to freeze my browser
15:27:40 <luite> prof7bit: I agree that it's a bit more work, but you could make a link that explains the process in a few steps, users can fork, edit the files on the web and submit a pull req in a few clicks
15:27:41 <acowley> cmccann: roconnor wields the fanciness hammer with great gusto
15:27:48 <luite> they don't need to touch git or a terminal
15:28:00 <insertpseudonym> the basics of gits are pretty easy
15:28:05 <luite> and you get all the discussion and social stuffs for free
15:28:06 <insertpseudonym> it only gets hard when you fuck up lol
15:28:12 <luite> git reset --hard
15:28:20 <insertpseudonym> usually yes
15:28:21 <luite> all solved ;p
15:28:55 <insertpseudonym> also, I'm still stuck in the dark ages of manual merge resolve
15:28:58 <byorgey> luite: really, you can make edits through a web interface on github?
15:29:11 * byorgey must have missed that feature
15:29:14 <acowley> byorgey: yes!
15:29:17 <luite> byorgey: yep, 'edit this file' appears if you have write access to the repository
15:29:32 <byorgey> that's pretty neat.  but it apparently ought to be better documented.
15:29:43 <insertpseudonym> I'm fairly sure there was a proposal for an online terminal to be added as well
15:29:46 <insertpseudonym> would be interesting
15:30:11 <kmc> cmccann, roconnor, the problem I have is that even if the types tell you what every individual function does, you need some high-level guide to know where to look
15:30:16 <kmc> data-lens is pretty small so this isn't a big problem
15:30:44 <roconnor> kmc: or a tutorial
15:30:47 <kmc> but, like, trifecta
15:30:48 <ion> I *know* git. That’s not what i mean. The process of cloning a repository, making modifications and sending a patch set using some method consists of much more work than just clicking an edit button on Hackage, making a potentially small modification and hitting Submit. The latter can be done on a whim, the former has a much higher threshold for me to get started at least.
15:30:53 <kmc> there are like 50 modules here
15:31:01 <luite> byorgey: one problem is that this does make it too easy to release 'quick fixes' without testing them first :)
15:31:03 <kmc> i don't know which ones I should care about, or where to start
15:31:06 <kmc> examples are really useful for this
15:31:13 <cmccann> kmc, data-lens is probably near the limit of being able to get away with that, yes
15:31:21 <byorgey> luite: true.
15:31:23 <kmc> preferably a sequence of examples which reveals all the features of the library in some logical order
15:32:26 <insertpseudonym> okay anyone see anything wrong here "[map (\x -> if (x==y) x then (x+1) else x) m | y<-n]"?
15:33:12 <MostAwesomeDude> insertpseudonym: What is (x==y) x supposed to do?
15:33:35 <insertpseudonym> MostAwesomeDude: oh snap, I didn't see the x outside of there
15:33:55 <insertpseudonym> just a comparison
15:33:59 <insertpseudonym> ignore the x I just took it out
15:34:14 <insertpseudonym> it's a simple problem
15:34:25 <roconnor> > (True == False) 5
15:34:26 <lambdabot>   Couldn't match expected type `t1 -> t'
15:34:26 <lambdabot>         against inferred type `GHC.B...
15:34:31 <MostAwesomeDude> What's the comprehension supposed to do?
15:34:32 <insertpseudonym> given a list of digits, map their frequency to a list of size 10
15:34:43 <insertpseudonym> list of digits is n
15:34:49 <insertpseudonym> list of size 10 is m
15:34:58 <insertpseudonym> m = replicate 10 0
15:35:10 <insertpseudonym> there must be an easier way actually
15:35:19 <insertpseudonym> something more natural via arrays?
15:36:01 <ddarius> :t accumArray
15:36:02 <lambdabot> forall e a i. (Ix i) => (e -> a -> e) -> e -> (i, i) -> [(i, a)] -> Array i e
15:37:19 <acowley> insertpseudonym: is this homework?
15:37:20 <ion> > (M.fromListWith (+) . map (flip (,) 1)) "foo bar baz"
15:37:22 <lambdabot>   fromList [(' ',2),('a',2),('b',2),('f',1),('o',2),('r',1),('z',1)]
15:37:59 <insertpseudonym> acowley: yes
15:38:06 <insertpseudonym> acowley: sorry, should have clarified that
15:38:31 <acowley> insertpseudonym: have you covered some of the list processing functions from the prelude?
15:38:44 <insertpseudonym> yes
15:38:51 <insertpseudonym> the goal of the assignment is to write as short a solution as possible
15:38:55 <insertpseudonym> hence the complication
15:40:10 <ddarius> > listArray ('a', 'b') [1,2]
15:40:11 <lambdabot>   array ('a','b') [('a',1),('b',2)]
15:41:03 <insertpseudonym> ^how's the different from zip?
15:41:13 <insertpseudonym> that*
15:41:31 <MostAwesomeDude> > [ length x | x <- (sort . group) "asdfasdasa" ]
15:41:32 <lambdabot>   [1,1,1,1,1,1,1,1,1,1]
15:41:41 <MostAwesomeDude> Hm. Back to the drawing board.
15:42:10 <luite> group . sort
15:43:01 <MostAwesomeDude> Yeah.
15:43:14 <MostAwesomeDude> > zip "adfs" [ length x | x <- (group . sort) "asdfasdasa" ]
15:43:15 <lambdabot>   [('a',4),('d',2),('f',1),('s',3)]
15:43:40 <aluink> any word on when the wiki will be back up?
15:43:47 <MostAwesomeDude> I'm sure there's a more elegant expression in there that I can't see.
15:44:12 <ion> See above.
15:44:25 <gwern> @quote
15:44:25 <lambdabot> cbeust says: It took a while but Maven has finallly won over most of the Java community, Scala should probably build on top of that
15:47:46 * kallisti never thought he would be manually managing memory in a Haskell program. :P
15:59:23 <luite> I have a lazy text builder, need a blaze-builder bytestring builder, how to convert?
16:03:56 <dylukes> Is there a good way to load .x (alex) modules into GHCI?
16:05:29 <monochrom> in McIlroy's functional pearl "enumerating the strings of regular languages": "length-ordered strings, LOS, are defined as a special case of a polymorphic length-ordered list, LOL"
16:05:52 * BMeph_ LOLs
16:07:47 <amiller> i have a question for you all, what's the smallest language class (i.e. context free, context sensitive) that strings with 'length-fields' fall into?
16:08:01 <amiller> i think it's "deterministic context sensitive"
16:08:14 <monochrom> I don't know what is strings with length-fields
16:08:24 <amiller> http://en.wikipedia.org/wiki/Netstrings are the easiest example, e.g "5:hello"
16:08:28 <Jafet> If the length is given in unary...
16:08:54 <dylukes> Pascal style strings essentially.
16:09:00 <acowley> Jafet: needs more dots
16:09:01 <amiller> right, pascal style strings
16:09:17 <Jafet> unary.....
16:09:34 <acowley> Jafet is giving incrementally more specific hints!
16:09:40 <monochrom> it is certainly outside context free. I don't know all the fine distinctions outside
16:09:47 <amiller> in the science of insecurity 28c3 talk by @maradydd, she basically says "well context free strings are ideal for protocols, but length field is basically just as good" http://www.youtube.com/watch?v=3kEfedtQVOY#t=21m35s
16:09:55 <monochrom> I am very unfamiliar with context sensitive stuff
16:10:20 <amiller> good point monochrom, i do believe my question is about fine distinctions within context sensitive.
16:10:59 <amiller> i'm not familiar with them either.
16:11:34 <dylukes> amiller: In my opinion, there are two "good" ways to have variable length strings in a network protocol.
16:11:46 <dylukes> 1) You prefix with a length (in BYTES, not characters for the love of god...)
16:12:05 <dylukes> 2) You use something like COBS to frame your blob/string, so you can just read until you hit a zero.
16:12:12 <dylukes> (1) is context sentitive.
16:12:16 <dylukes> (2) requires some post-processing.
16:12:27 <dylukes> I think (2) is a saner option in general, but it's a little bit more work.
16:12:53 <monochrom> null-terminating things? the inventor of that now greatly regrets it
16:12:59 <dylukes> monochrom: No no.
16:13:05 <dylukes> COBS is pretty simple and elegant.
16:13:24 <dylukes> You take a binary blob and split it into blocks of 255 bytes... (the extra one is important)
16:13:26 <monochrom> sorry, I confess don't know COBS, what does it do?
16:13:26 <dylukes> then you go through,
16:13:31 <dylukes> and replace each \x00 byte...
16:13:37 <dylukes> with the offset until the NEXT \x00 byte
16:13:42 <dylukes> which in turn is replaced... etc etc
16:13:54 <dylukes> if it runs over into the next block, that's what the extra byte at the end is for.
16:14:04 <dylukes> then the only \x00 byte in your blob is the terminator.
16:14:23 <dylukes> It's called Consistent Overheard Byte Stuffing because the overhead is 1 byte per 255 bytes of input.
16:14:30 <dylukes> Consistently.
16:14:42 <dylukes> Here's the paper.
16:14:42 <dylukes> http://stuartcheshire.org/papers/COBSforToN.pdf
16:15:16 <amiller> how peculiar, that's interesting
16:15:23 <dylukes> To actually encode into cobs, you take each block of 255 bytes
16:15:27 <dylukes> attach a zero onto the end
16:15:27 <monochrom> well then, that's null-termination with a rather elaborate scheme for escaping in-band null, which is even worse. the inventor of null-termination regrets it for more important reasons than "what if I want to send null?"
16:15:33 <dylukes> etc.
16:15:41 <dylukes> monochrom: What are they?
16:16:43 <monochrom> it will take a while to find it again. I seem to have seen it on ACM Queue
16:16:48 <dylukes> http://queue.acm.org/detail.cfm?id=2010365
16:16:48 <dylukes> this?
16:16:58 <monochrom> yes
16:17:12 <dylukes> I can understand a lot of issues within a language or from a hardware point of view,
16:17:20 <dylukes> for in language strings.
16:17:25 <monochrom> perhaps it is not the inventor afterall. but still someone with real experience
16:17:28 <prof7bit> after the decoding of this COBS you still have to determine where your strings inside this blob begin and end
16:17:35 <dylukes> But the question I'm talking about is for network protocols.
16:17:52 <dylukes> Say you have a TCP stream.
16:18:15 <dylukes> The only *sane* way to make sure you can safely drop a packet or recover from bad data being sent by a faulty client,
16:18:25 <dylukes> is by framing each in-protocol logical packet
16:18:37 <dylukes> and the only way to do that is to have a magic marker and remove it in band.
16:18:57 <prof7bit> tcp streams don't lose packets, thats what TCP is for
16:19:07 <dylukes> You think TCP really makes any stronger guarantees than UDP?
16:19:18 <Enigmagic> i would say yes
16:19:28 <dylukes> It doesn't follow through with them though :P.
16:19:32 <Enigmagic> otherwise we'd just be using UDP
16:19:41 <dylukes> Nah, TCP has a different abstraction too.
16:19:52 <dylukes> TCP's packet loss prevention techniques aren't any better than UDP's if I recall correctly.
16:20:15 <Enigmagic> first time i've heard that
16:20:27 <amiller> i was thinking about this in the context of a secure network protocol, http://foolscap.lothar.com/docs/banana.html#auto0 warner in #tahoe-lafs asked this question a while ago
16:20:45 <dylukes> Let me put it this way,
16:20:47 <dylukes> TCP manages SYN/ACK's
16:20:52 <dylukes> which adds a level of reliability
16:21:03 <dylukes> however the reliability of those SYN/ACKs or any other TCP packets actually arriving,
16:21:07 <dylukes> isn't any better than UDP.
16:21:27 * cmccann thought TCP was about ensuring packets arrive in order and not mangled
16:21:28 <Enigmagic> right, TCP doesn't prevent a network from dropping packets
16:21:42 <dylukes> Basically, TCP handles the _majority_ of dropped packets.
16:21:59 <dylukes> But if a SYN is dropped, it's possible the other end doesn't know a packet has been dropped at all.
16:22:08 <Enigmagic> sure it does
16:22:35 <prof7bit> AFAIK a packet loss would result in a disconnect. but you would never receive any packets out of order
16:22:48 <CodeWeaver> Huh, trying to get cabal packages to build using the LLVM… but the ghc-options isn't being passed along.
16:22:51 <CodeWeaver> Any ideas?
16:22:58 <dylukes> CodeWeaver: hm?
16:23:02 <dylukes> "the LLVM" what?
16:23:06 <CodeWeaver> The compiler.
16:23:11 <dylukes> The LLVM backend to GHC?
16:23:13 <CodeWeaver> Yes.
16:23:29 <CodeWeaver> cabal isn't issuing the -fllvm switch.
16:24:26 <dylukes> You'll probably want to edit the cabal files.
16:24:39 <alpounet> CodeWeaver, pass it to cabal
16:24:40 <CodeWeaver> I can't set it via .cabal/config or via the command-line?
16:24:40 <alpounet> hm wait
16:24:44 <alpounet> i wrote a blogpost with that
16:24:50 <CodeWeaver> I'm trying, alpounet.
16:24:53 <dylukes> Maybe cabal has a way to pass flags to GHC like clang/gcc's -Xlinker -Xcompiler flags?
16:25:05 <CodeWeaver> Its supposed to be —ghc-options=-fllvm
16:25:16 <CodeWeaver> But somehow the option isn't getting there that I can see.
16:25:26 <dylukes> have you tried --flags="-fllvm"
16:25:28 <kmc> indeed it is necessary that a network drop packets for TCP to work correctly
16:25:40 <kmc> dropped packets are how TCP determines that it's sending too fast, and to back off
16:26:07 <dylukes> jlouis: You were working on something related to that with µtp right?
16:26:08 <c_wraith> Isn't there an alternate version of TCP that bases it on latency instead?  TCP Reno vs TCP Vegas? (not that I remember which is which)
16:26:24 <kmc> there are many congestion control schemes for TCP
16:26:45 <CodeWeaver> —flags isn't working...
16:26:52 <CodeWeaver> Hmmm
16:26:52 <monochrom> there is another ACM Queue for that :)
16:27:39 <kmc> dylukes, i can't tell if you're mistaken about TCP or just explaining it in a weird way
16:28:28 <dylukes> kmc: I'm just reiterating what I heard (I believe in #erlang a while back).
16:28:34 <dylukes> I'm definitely explaining it weirdly.
16:28:54 <kmc> your TCP stream is not going to arrive at the other end missing a chunk in the middle
16:29:07 <kmc> not because of something that happened in the network
16:29:18 <kmc> of course there is the potential for OS-level or application-level fuckups
16:30:51 <kmc> so when you say "The only *sane* way to make sure you can safely drop a packet or recover from bad data being sent by a faulty client"
16:31:03 <kmc> if you're using TCP, it's only the second of these that you're concerned with
16:31:06 <dylukes> I mean a logical packet.
16:31:10 <kmc> unless you are "dropping packets" at the app level
16:31:11 <dylukes> i.e, within your protocol layer.
16:31:19 <dylukes> Right, at the application protocol layer.
16:31:23 <kmc> calling read(2) and then throwing out the result
16:31:25 <dylukes> i.e., a client sends you a malformed packet.
16:31:29 <kmc> ah
16:31:35 <kmc> disconnect the client ;)
16:31:42 <dylukes> Usually, yes.
16:31:52 <dylukes> But sometimes it's worth trying to get it back.
16:32:03 <kmc> when?
16:32:16 <dylukes> When you're used a fuckwitted TCP protocol pretending to be datagram based?
16:32:39 <dylukes> And packets ARE actually distinct and its okay to miss some in most cases?
16:32:42 <dylukes> using a*
16:33:03 <c_wraith> really shouldn't be using TCP in that case
16:33:17 <dylukes> c_wraith: no shit.
16:33:26 <kmc> yeah, you might want a reliable in-order datagram protocol, or a reliable unordered datagram protocol
16:33:30 <kmc> but these are not popular
16:33:36 <kmc> RDS is known mainly for linux security holes
16:33:39 <dylukes> Let me explain this in one word.
16:33:41 <dylukes> "minecraft".
16:33:46 <kmc> "lockbox"
16:33:52 <dylukes> Markus Perrson is absolutely fuckwitted when it comes to netcode.
16:34:00 <c_wraith> Ah, and now I understand what Philippa was talking about for her ideal fighting game network protocol.  Include input histories over the last bunch of frames in each datagram so you can go to UDP
16:34:10 <dylukes> 1) Invent a crappy binary equivalent of XML, instead of just using BSON.
16:34:11 <kmc> games often use UDP
16:34:22 <dylukes> 2) Embed it in blobs in TCP packets.
16:34:24 <kmc> clearly there aren't enough ways to represent nested key-value dictionaries
16:34:24 <dylukes> Then, wait for it...
16:34:25 <dylukes> wait for it...
16:34:27 <kmc> we need about 50 more ways to do that
16:34:38 <dylukes> 3) Make later fields of the packet depend on content inside that blob.
16:34:49 <neutrino> i have x :: Maybe a and y :: Maybe b. I want to get Maybe (a, b) from those. how do i best do that?
16:35:14 <dylukes> @hoogle m a -> m a -> m (a, b)
16:35:14 <lambdabot> Data.Sequence zip :: Seq a -> Seq b -> Seq (a, b)
16:35:15 <lambdabot> Prelude zip :: [a] -> [b] -> [(a, b)]
16:35:15 <lambdabot> Data.List zip :: [a] -> [b] -> [(a, b)]
16:35:19 <c_wraith> neutrino: liftM2 (,)
16:35:19 <byorgey> neutrino: (,) <$> x <*> y
16:35:31 <dylukes> byorgey++
16:35:54 <neutrino> :t (<$>)
16:35:54 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
16:36:04 <byorgey> neutrino: of course you can also do somthing like   case x of Nothing -> Nothing; Just x' -> case y of ...
16:36:19 <dylukes> neutrino: <$> == fmap
16:36:24 <dylukes> with different precedence, and it's infix :P.
16:36:24 <neutrino> yeah byorgey i know but that sucks
16:36:30 <byorgey> indeed.
16:36:35 <neutrino> :t (<*>)
16:36:35 <lambdabot> forall (f :: * -> *) a b. (Applicative f) => f (a -> b) -> f a -> f b
16:36:47 <neutrino> so what gets applied first, dollar or asterisk?
16:36:55 <dylukes> dollar.
16:36:59 <dylukes> :t (<$>)
16:37:00 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
16:37:01 <dylukes> :t (<*>)
16:37:02 <lambdabot> forall (f :: * -> *) a b. (Applicative f) => f (a -> b) -> f a -> f b
16:37:08 <byorgey> it parses as   ((,) <$> x) <*> y
16:37:12 <dylukes> Right.
16:37:26 <byorgey> because <$> and <*> are both left associative
16:37:27 <neutrino> k
16:37:31 <dylukes> So you're partially applying (,), giving you a function (f a -> f b)
16:37:33 <neutrino> thank you guys
16:37:47 <dylukes> (where f is Maybe)
16:38:10 <dylukes> anyways
16:38:22 <byorgey> neutrino: you must promise only to use this knowledge for Good
16:38:35 <c_wraith> data Evil
16:38:39 <neutrino> @hoogle (<*>)
16:38:39 <lambdabot> Control.Applicative (<*>) :: Applicative f => f (a -> b) -> f a -> f b
16:38:55 <monochrom> instance Applicative Evil where ...
16:39:45 <dylukes> neutrino: the easy way to visualize it is
16:39:59 <dylukes> <$> takes a pure thing, and applies it to a thing inside an applicative functor
16:40:09 <dylukes> <*> takes something inside an applicative functor, and applies it to another
16:40:28 <dylukes> (<**> does the same, but from right to left)
16:40:33 <dylukes> and then you have
16:40:37 <dylukes> :t (<*)
16:40:37 <lambdabot> forall (f :: * -> *) a b. (Applicative f) => f a -> f b -> f a
16:40:39 <dylukes> :t (*>)
16:40:39 <lambdabot> forall (f :: * -> *) a b. (Applicative f) => f a -> f b -> f b
16:40:42 <kmc> that's not "visualizing" anything
16:40:43 <dylukes> :t (<$)
16:40:44 <lambdabot> forall a (f :: * -> *) b. (Functor f) => a -> f b -> f a
16:40:54 <kmc> you've just stated the type in english words, and introduced the confusing idea of "pure thing"
16:41:02 <dylukes> kmc: "thing not in an applicative"
16:41:05 <parcs`> kmc++
16:41:08 <kmc> but it might be
16:41:12 <dylukes> It's not my fault the keyword "pure" is moronic.
16:41:18 * MostAwesomeDude blames dylukes 
16:41:20 <kmc> you don't have to use it
16:41:28 <parcs`> bad dylukes! bad!
16:41:33 <dylukes> TT_TT
16:41:33 <dylukes> what
16:41:35 <kmc> you seem to think everything is "moronic" or "fuckwitted"
16:41:36 <kallisti> an easy way to think of <$> is in terms of fmap
16:41:43 <kallisti> fmap lifts a function into a parametric type.
16:41:48 <monochrom> I gather that some people love to have types transcribed to natural language
16:42:05 <dylukes> kmc: I do?
16:42:06 <byorgey> kallisti: <$> is the same as fmap.
16:42:12 <kallisti> byorgey: ...yes?
16:42:19 <mike-burns> But everything IS moronic or fuckwitted!
16:42:26 <monochrom> I, of course, oppose it, but what can you do to popular opinion? what can you do to COBOL people?
16:42:33 * shapr sighs
16:42:40 <kallisti> so if you have a function from Int -> Char, fmap allows you to have a function from IO Int -> IO Char, or [Int] -> [Char], or Maybe Int -> Maybe Char, etc
16:43:07 <kallisti> byorgey: fmap is more illustrative of the idea of lifting a function, whereas the <$> makes it a little less clear for the inexperienced.
16:43:15 <kallisti> due to the infix notation
16:43:59 <dylukes> <$> lifts a function and applies it to the thing on the right.
16:43:59 <byorgey> kallisti: "an easy way to think of X is in terms of Y" just seems an odd thing to say when X and Y are actually just two names for the same thing, that's all
16:44:17 <dylukes> <$ lifts a function/value, evaluates what's on the right, but then just results in what was on the left.
16:44:26 <kmc> "evaluates"?
16:44:33 <dylukes> "runs" the action.
16:44:47 <kmc> which is something different, and is hard to define in a generic way
16:44:50 <dylukes> It depends on the applicative.
16:44:53 <kallisti> "assumes" the position.
16:45:03 <dylukes> >_>
16:45:11 <kmc> i think it's easier to just say that (x <$ y) is  (const x <$> y)
16:45:16 <kallisti> "prepares" for lift off. etc
16:46:32 <kallisti> you could say "it does the thing" but then no one knows what you
16:46:35 <kallisti> r're talking about
16:46:42 <parcs`> :t const <$> ?a <*> ?b
16:46:43 <lambdabot> forall a a1 (f :: * -> *). (?a::f a, Applicative f, ?b::f a1) => f a
16:47:24 <nyingen> kallisti: it's best to just anthropormorphize everything
16:47:28 <nyingen> "this guy talks to that guy"
16:47:31 <neutrino_> :t const
16:47:32 <lambdabot> forall a b. a -> b -> a
16:48:09 <monochrom> the ⊥ guy is under the ⊥:⊥ guy
16:50:21 <kallisti> monochrom: would it be okay if I said that ⊥:⊥ is "more halty"
16:50:36 <monochrom> I don't know what is more halty
16:50:46 <neutrino_> it's like more salty
16:50:50 <monochrom> but I guess yes
16:50:53 <roconnor> > null (undefined:undefined)
16:50:54 <lambdabot>   False
16:51:08 <monochrom> the party line says that ⊥:⊥ has more information
16:51:37 <neutrino_> how so
16:51:57 <monochrom> it tells you there is a colon. you can rely on it
16:52:33 <monochrom> ⊥ doesn't even tell you whether it's a colon or a []
16:54:18 <neutrino_> i can see how that would be useful for colonoscopy
16:54:40 <monochrom> haha
17:08:50 <ninor> greetings, who here runs your channel bot please?
17:09:01 <parcs`> which one?
17:09:07 <ninor> *shrug*
17:09:26 <parcs`> lambdabot?
17:09:27 <ninor> i run #iosdev and i would like to set up a bot for our channel's members. however it's been /years/ since i ran eggdrops on a shell
17:09:46 <ninor> i'd appreciate some help in making this happen, so i'm just trying to track down ppl able to provide some assistance
17:10:02 <Saizan> lambdabot is not an eggdrop
17:10:24 <ninor> please, go on
17:11:36 <parcs`> do you want to write a custom irc bot for your channel?
17:12:20 <ninor> i would like to. and then i need a way to run it
17:12:32 <ninor> actually, i can write an objc program myself
17:12:36 <ninor> but how could i run that as a chan bot?
17:12:50 <shapr> IRC is a really simple protocol.
17:13:07 <Sgeo> ninor, look for libraries for IRC for Objective-C, or just use the protocol directly.
17:13:46 <ninor> then how would i run it online always?
17:13:57 <ninor> i suppose i could make a web interface to it and run it on a mac mini colo?
17:14:00 <irene-knapp> ninor: try http://linode.com/ (they charge a monthly fee)
17:14:02 <shapr> ninor: Run iosbot from your desktop as its own irc client?
17:14:03 <ninor> would sux to rent that just for this
17:14:06 <narens> hello! Where can I find out about the memory cost (in bytes) of a single STRef?
17:14:13 <irene-knapp> ninor: although it's not a Mac, so.
17:14:20 <ninor> shiz
17:14:29 <shapr> ninor: Do you have any spare systems at home you can always run?
17:14:29 <ninor> well, thanks everyone :)
17:14:32 <mike-burns> Lots of this belongs in #haskell-blah. Or, really, anywhere else.
17:14:33 <ninor> well yea
17:14:35 <Sgeo> Surely Objective-C programs can run on Linux?
17:14:36 <shapr> ninor: That's how lambdabot got by the first few years.
17:14:38 <ninor> but i don't wanna run it off of my connection
17:14:38 <irene-knapp> have you tried #macdev?  if you're looking to write something that runs on a Mac, they might be more helpful
17:14:46 <irene-knapp> Sgeo: not ? quite like you'd hope :)
17:14:49 <kmc> be sure to do all your IRC protocol parsing with fixed-size buffers, without bounds checking
17:14:53 <kmc> for efficiency, you know
17:14:56 <ninor> oh snap, i know #Objfw exists!!
17:15:02 <irene-knapp> Sgeo: the answer is yes, but it's a lot of trouble for most people
17:15:06 <Sgeo> Ah
17:15:13 <ninor> so i can make my tool run on freebsd
17:15:15 <ninor> uNF
17:15:37 <mike-burns> narens: Just so you get an answer: I don't know.
17:15:44 <ninor> thanks pplz
17:15:51 <narens> mike-burns: lol
17:15:53 <kmc> gobjc and gnustep should be enough for an irc bot
17:16:01 <ninor> objfw is better than gnustep iirc
17:16:05 <shapr> So my cs255 class assignment is a short paper on recursion, including 'when recursion is appropriate' and "advantages and disadvantages" ... as a Haskell fan, I'm not sure what to say.
17:16:24 <mike-burns> "There's an alternative?"
17:16:30 <irene-knapp> kmc: the primary issue is that the dialect of ObjC that people learn nowadays is not the GNU one
17:16:41 <irene-knapp> kmc: Apple's patches are public but have not been integrated upstream, and they are substantial
17:16:46 <ninor> different implementation of Foundation
17:16:52 <ninor> different objc runtime too
17:17:04 <irene-knapp> kmc: there has been work done to backport them (particularly the Cocotron project) but again, it's a lot of work for most people who aren't experts at this crap and don't want to be
17:17:05 <Sgeo> shapr, you could mention that in some languages, tail-call recursion might stack-overflow
17:17:07 <alpounet> narens, look for a talk about Haskell performance, by Johan Tibell
17:17:18 <alpounet> he explains how to calculate the memory cost of data types, etc
17:17:21 <Cale> shapr: Recursion is not appropriate when higher order functions will do ;)
17:17:29 <shapr> Cale: ooh, I like it!
17:18:47 <narens> alpounet: thanks, maybe I can just ask a direct question. I want to make a graph like strucutre but I don't want to have to have an adjacency map..rather i'd like one element to contain a pointer to its neighbours... what's the best way to do that?
17:19:14 <ninor> guys quick, what's "kb" mean ?
17:19:18 <ninor> first answer gets a cookie!!
17:19:24 <Sgeo> COuld be knowledgebase
17:19:25 <shapr> ninor: In what context?
17:19:30 <Veinor> kilobit
17:19:31 <shapr> ninor: keyboard? kib?
17:19:37 <ninor> interesting
17:19:44 <shapr> ninor: Would you like to learn Haskell?
17:19:53 <Sgeo> ninor, where do you see "kb"?
17:19:54 <parcs`> kite bandit
17:20:01 <ninor> i was looking for knowledgebase. i like how there were 3 perfectly valid answers quickly and at once, and yet the first was the one i was looking for
17:20:06 <ninor> this is absolutely amazing
17:20:14 <shapr> ninor: Clearly you need to learn Haskell.
17:20:23 <ninor> shapr, go on please
17:20:25 <alpounet> haha
17:20:43 <parcs`> haskell is a great programming language for writing irc bots in
17:20:43 <shapr> ninor: Have you tried writing Haskell before?
17:21:16 <shapr> Many of my early bits of Haskell were for lambdabot plugins.
17:21:31 <ninor> shapr, i never have.
17:21:46 <ninor> each time i've inquired to Haskell, i get explanations of what the code is like in some cryptic syntax form
17:21:47 <Sgeo> Are the OO parts of Obj-C statically typed? I know Smalltalk is dynamically typed
17:21:54 <ninor> but i do not speak that yet, so *shrug*
17:21:57 <kmc> Sgeo, no
17:22:06 <shapr> ninor: Would you like a quick demo of a few interesting bits?
17:22:07 <ninor> yea not totally
17:22:17 <ninor> shapr, i would appreciate that very much
17:22:28 <shapr> > somenumber = 1
17:22:29 <lambdabot>   <no location info>: parse error on input `='
17:22:31 <shapr> hrm
17:22:38 <ninor> wat
17:22:39 <kmc> ninor, http://tryhaskell.org/
17:22:41 <Sgeo> > let somenumber = 1
17:22:42 <Cale> You can @let
17:22:42 <ninor> :>
17:22:42 <lambdabot>   not an expression: `let somenumber = 1'
17:22:46 <Sgeo> oops
17:22:49 <kmc> lol
17:22:52 <Sgeo> > let somenumber = 1 in somenumber
17:22:52 <lambdabot>   1
17:22:57 <Cale> The > thing wants expressions only
17:23:03 <ninor> k already, wat?
17:23:06 <ninor> :)
17:23:09 <kmc> great job evangelizing, everyone
17:23:11 <Cale> > let x = 5 in x*x
17:23:12 <lambdabot>   25
17:23:14 <Cale> heh
17:23:15 <ninor> moment
17:23:24 <ninor> ok so declaration then expression?
17:23:30 <mike-burns> Expression.
17:23:31 <Cale> yeah, let ... in ...
17:23:31 <kmc> ninor, I suggest you ignore IRC for a while and read tryhaskell.org
17:23:39 <mike-burns> > 5 * 5
17:23:40 <kmc> and then if you are still interested, http://learnyouahaskell.com/chapters
17:23:40 <ninor> kmc, it made me go wat
17:23:40 <lambdabot>   25
17:23:48 <shapr> aw, I haven't gone over my HaskellDemo in YEARS!
17:23:50 <ninor> let me take another look at it..
17:23:55 <Cale> let <declarations> in <expression>  is an expression form which makes the declarations in scope in the given expression
17:24:03 <shapr> and I just pasted the only version I could find: http://hpaste.org/57306
17:24:13 <ninor> this is amazing. the UI in my OS has the text console at the top!
17:24:17 <ninor> tres cool so far
17:24:32 <kmc> i don't really want #haskell to consist of people typing in LYAH one sentence at a time
17:24:47 <Sgeo> shapr, "any type signatures here are just to add clarity"
17:24:52 <shapr> Sgeo: it's true!
17:24:55 <Sgeo> lies
17:24:57 <ninor> oh wow, chat interface to the channel is SO COOL and thoughtful
17:25:00 <Sgeo> add1 is overly constrained
17:25:09 <shapr> Sgeo: You are correct.
17:25:24 <shapr> Sgeo: And yet, the idea was that int was a familiar type for C programmers, et al
17:25:47 <shapr> Sgeo: How would you approach it?
17:26:05 <ninor> ok so input/output model, you give an expression and get back a value
17:26:12 <Sgeo> I guess "add clarity" isn't the same as "type signatures here are identical to the type"
17:26:24 <Sgeo> ninor, that's just the REPL, that's not how Haskell I/O in general works.
17:26:41 <augur> anyone know of intros to memory use analysis?
17:26:47 <ninor> REPL?
17:26:55 <Veinor> read, evaluate, print loop
17:27:08 <ninor> ah, like interative ruby
17:27:13 <ninor> interactive :)
17:27:16 <monochrom> from concrete to abstract, from special to general. show the special type first.
17:27:19 <Veinor> yeah
17:27:33 <Veinor> except ghci is less powerful than a proper haskell program
17:27:34 <ninor> from concrete to abstract? what is this? these are things i think about
17:27:40 <Sgeo> ninor, yes. Although the Haskell REPL doesn't quite let you do full programs. Yet.
17:27:54 <Sgeo> ninor, monochrom was talking to shapr I thinkj
17:28:01 <byorgey> it's a lot closer in 7.4.
17:28:02 <monochrom> and to Sgeo
17:28:03 <Veinor> Sgeo: 7.4 has data, type, and newtype i think
17:28:20 <Sgeo> Veinor, hence "yet". Although what else is there.
17:28:25 <Sgeo> instance
17:28:26 <Sgeo> and class
17:28:27 <Veinor> imports
17:28:29 <cmccann> 7.something has most or all top-level declarations I think
17:28:40 <byorgey> Veinor: also type families.
17:28:49 <Sgeo> Language pragmas, clearly
17:28:53 <Sgeo> >.>
17:28:56 <Sgeo> </silly>
17:29:00 <byorgey> something = 4
17:29:01 <Veinor> Sgeo: :set -XOverloadedStrings
17:29:05 <cmccann> Sgeo, and c preprocessor directives too?
17:29:06 <shapr> ninor: Got any questions so far?
17:29:09 <Sgeo> Veinor, hence why I called it silly
17:29:18 <Sgeo> Because it's already doable (albeit in a different form)
17:29:23 <Veinor> ... wait
17:29:26 <Sgeo> Haskell tutorials really need to mention language pragmas IMO
17:29:31 <Veinor> you can import qualified Data.Map as Map in ghci?
17:29:36 <Veinor> how did i not know this
17:29:42 <Sgeo> TIL
17:29:44 <mike-burns> Whaaa?!
17:29:51 <mike-burns> How?
17:30:03 <shapr> whoa, nifty :-)
17:30:06 <Veinor> Prelude> import qualified Data.Map as Map
17:30:08 <Veinor> Prelude Data.Map>
17:30:11 <monochrom> haskell tutorials need to mention that GHC comes with a user manual
17:30:18 <mike-burns> Wow!
17:30:22 <mike-burns> I live in the future, clearly.
17:32:13 <ninor> so tuple is the name give to compound values?
17:32:28 <ninor> step 6 lesson 2
17:32:30 <Veinor> to one type of compound values
17:32:38 <Veinor> ("Hello", True) is a tuple
17:32:40 <ninor> Tuples, because sometimes one value ain't enough!
17:32:51 <ninor> Veinor, what?
17:32:53 <ninor> to one type?
17:33:06 <mike-burns> It's a sequence of n elements.
17:33:15 <irene-knapp> records are another type of compound value
17:33:23 <Veinor> ninor: what do you mean?
17:33:32 <ninor> oh so there are multiple types of values in haskell?
17:33:41 <kallisti> for sure.
17:33:42 <ninor> well in objc there's 1 type of value. it's an object
17:33:43 <mike-burns> A whole bunch of 'em.
17:33:57 <mapreduce> objc has subtypes, I would guess.
17:34:00 <ninor> ok so value types == object classes?
17:34:08 <Veinor> roughly, yeah
17:34:09 <mike-burns> Don't go making OO comparisons just yet.
17:34:16 <irene-knapp> we don't have anything analogous to ObjC's classes
17:34:16 <Veinor> but only roughly!
17:34:19 <ninor> no just on basic principles
17:34:23 <ninor> sure
17:34:24 <mike-burns> There are tons of OO comparisons, but learn more Haskell first.
17:34:29 <mapreduce> I'll wait until after the watershed.
17:34:30 <irene-knapp> our "type classes" are more like ObjC's protocols
17:34:30 <ninor> yea fair enough
17:35:22 <Sgeo> What are ObjC protocols like?
17:35:31 <mike-burns> Typeclasses, apparently.
17:35:32 <kallisti> Sgeo: interfaces
17:35:34 <irene-knapp> Sg---
17:35:36 <irene-knapp> yeah
17:36:18 <keep_learning> hello all
17:36:41 <shapr> keep_learning: What are you learning today?
17:36:56 <keep_learning> shapr, Haskell more and more :)
17:37:46 <keep_learning> I am trying to do binary search on  [: :] ( Data.Array.Parallel ) but getting ./Data/Vector/Generic.hs:237 ((!)): index out of bounds (4,4)
17:38:07 <keep_learning> Is it possible that due to laziness i am getting this error ?
17:39:46 <Sgeo> Unless you mean that you're being lazy while coding or something, not really
17:39:48 <Sgeo> I think
17:39:57 <kallisti> keep_learning: what's in the parallel array?
17:40:11 <kallisti> oh nevermind
17:40:13 <kallisti> I see. :P
17:40:58 <keep_learning> Sgeo, So its logical error in code
17:41:06 <kallisti> keep_learning: I believe parallel arrays are strict.
17:41:21 <mike-burns> paste some code, maybe.
17:41:22 <keep_learning> kallisti, thank you
17:42:14 <kallisti> keep_learning: are you using Vectors elsewhere? the error seems unrelated to the stated problem.
17:42:42 <kallisti> or rather, the state problem seems unrelated to the error.
17:42:46 <keep_learning> kallisti, no i am not using Vectors any where else. I am posting the code
17:43:15 <kallisti> hm, it could possibly be an error from another library then?
17:47:57 <keep_learning> kallisti, http://hpaste.org/57307
17:48:15 <keep_learning> I suspect its paraMerge which creating problem
17:48:59 <shapr> ninor: still learning Haskell?
17:50:49 <ninor> yea it made sense
17:51:15 <ninor> so does it cause no side effects by copying values each time?
17:51:20 <ninor> into the body
17:51:36 <kallisti> into which body?
17:51:47 <kallisti> the function? not semantically.
17:52:29 <kallisti> note that Haskell can be /implemented/ with side-effects, but this doesn't mean that the language itself contains side-effects.
17:52:45 <ninor> how does it do that kallisti ?
17:53:47 <kallisti> ninor: well, there's a concept called referentially transparency. If a function is referentially transparent then for every possible argument it always returns the same result.
17:53:52 <kallisti> *referential
17:54:14 <monochrom> I am not sure why you ask about copying and side effects
17:54:42 <kallisti> ninor: for example, 2 + 2 always produces 4. there are no side-effects of performing that operation.
17:55:03 <Sgeo> ninor, don't worry too much about how Haskell is implemented
17:57:01 <Saizan> anyhow if you want to know, the implementation avoids destructive update in the first place rather than copying to avoids its problems
17:57:50 <Saizan> except when it's updating a deferred computation with its value
17:59:42 <keep_learning> kallisti, Could you please have a look at my code
18:00:02 <kallisti> keep_learning: I have no clue what's going on. sorry. try a debugger perhaps.
18:08:10 <trinithis> sianara suckas
18:08:22 <kallisti> ohh snap
18:08:45 <kallisti> ninor: I'm sure Saizan's explanation cleared everything up for you. :P
18:10:00 <Sgeo> sianara?
18:12:16 <kallisti> yes it's like sayonara but higher on the wicked burn scale.
18:13:31 <Sgeo> Oh, I thought trin was saying a thing called "sianara" sucks.
18:13:33 <cmccann> is there an official scientific unit of measurement for "wicked burns"? like, how do I quantify the precise degree of wicked burnination going on here.
18:14:14 <kallisti> I usually go by metric trinithis
18:14:16 <Sgeo> Someone should clearly make a Sianara language that sucks as.
18:14:36 <kallisti> ..
18:14:39 <Cale> shiagenara?
18:18:14 * shapr throws iphones at ninor 
18:19:09 <kallisti> I think the Dos Equis commercials are an excellent example for marketing students to study good marketing techniques.
18:19:15 * kallisti offtopic
18:20:18 <Cale> 仕上 = siage = end, being finished, なら = nara = contextual conditional -->  "siagenara" = "if it's done"
18:21:14 <ninor> shapr, hey
18:21:31 <ninor> it looks cool, but i had to take care of something work related before i can continue with lesson 7
18:21:54 <Cale> But probably that guy just didn't know how to spell or pronounce sayounara ;)
18:22:06 <shapr> ninor: You're still at work?
18:22:12 <ninor> yes?
18:22:14 <CodeWeaver> Just asked this on #ghc, but I thought I'd double-up here….  Asked this once before in here, still haven't resolved.
18:22:14 <CodeWeaver> on 7.2.2, 'm trying to instruct cabal to build hackage packages with the llvm, but none of the ways I've tried to pass -fllvm to ghc seem to make it through to what gets output on the command line in verbose mode.   ideas?
18:22:23 <shapr> ninor: Are you in one of those European timezones?
18:22:39 <ninor> no it's only 7 pm, i'm in Seattle
18:22:48 <bytbox> so... Text.JSON apparently can be compiled with MAP_AS_DICT defined to get it to act more sanely. So if I have a project that requires that sane behaviour, is there any way for me to require that type of compilation?
18:24:44 <Saizan> bytbox: i don't think so
18:25:16 <bytbox> Saizan: that's a bummer - it looks like I'm going to be distributing my own Text.JSON with the projects
18:25:20 <Saizan> CodeWeaver: tried --ghc-options=-fllvm ? or ghc-options: -fllvm in the .cabal file?
18:25:20 <bytbox> s/s$//
18:25:55 <Sgeo> What's insane about Text.JSON?
18:26:26 <CodeWeaver> Saizan: When I try the former, nothing happens.  When I try the latter in the "flags" field, nothing happens.  When I try as a line on its own, ghc_options: , then it says it doesn't know what the option is.
18:26:40 <CodeWeaver> The config file doesn't have a ghc-options by default.  Perhaps I'm using an old version.
18:26:54 <CodeWeaver> says version 1.12.0
18:27:37 <CodeWeaver> of the Cabal library
18:27:43 <Saizan> CodeWeaver: not the config file, i meant in the .cabal file of a particular package
18:28:13 <CodeWeaver> Ah, no, haven't done that.  I figured the global setting would override something said specifically in the package.
18:29:10 <bytbox> Sgeo: it wants to parse Maps as a list of ordered pairs (each of which is represented as a list), instead of a dict
18:29:14 <CodeWeaver> And there's documentaiton saying I should be able to issue it on the command line at least, if not the cabal global config.  I can try the package.  Annoying to do that to all my packages though
18:29:37 <bytbox> Saizan: the json package appears to specify MAP_AS_DICT as a flag (mapdict) - does that make it possible? (Sorry if this has an obvious answer, I'm not too cabal-fluent.)
18:30:41 <Saizan> bytbox: a cabal package can't specify flags for its dependencies, afaik
18:30:59 <bytbox> Saizan: ok, thanks
18:31:07 <bytbox> Saizan: at least I have a nicer workaround now
18:31:42 <Saizan> CodeWeaver: yeah, --ghc-options should work, how are you using it?
18:32:05 <CodeWeaver> cabal install <package> —ghc-options=-fllvm
18:32:07 <CodeWeaver> If I'm doing it on the command line.
18:32:23 <CodeWeaver> Hmmmmm
18:32:40 <Saizan> yeah, that should be it, except for the dash i suppose :)
18:33:16 <CodeWeaver> Stupid chat program merging my double dash
18:35:04 <CodeWeaver> Oh NOW it's passing through, when issued on the  command line.
18:35:42 <monochrom> oh heh
18:45:30 <CodeWeaver> So that's really weird.  I can specify the ghc-options thing on the command line and have it work now, but not via the cabal config file.
18:45:47 <CodeWeaver> Its like cabal doesn't recognize that setting in the config file.  Weird.
18:51:11 <XexonixXexillion> random question; in what version was Control.Applicative added to base?
18:54:46 <keep_learning> Hello all
18:55:10 <keep_learning> I am trying to compile a Haskell code and got this error ( http://hpaste.org/57309 ) .
18:55:22 <keep_learning> It says its GHC bug
18:55:39 <keep_learning> to whom i should send this report ?
18:57:06 <Saizan> @bug
18:57:06 <lambdabot> http://hackage.haskell.org/trac/ghc/newticket?type=bug
18:57:29 <tommd> keep_learning: if you have time it helps to test the error against the HEAD version of GHC.
18:57:34 <Saizan> but the error has a link in it
18:57:56 <keep_learning> tommd, I have time  to test with ghc head
18:58:20 <keep_learning> The only issue with me is I am not able to install the dph will  GHC
18:58:56 <keep_learning> kind of new to  ghc technicality
19:02:18 * hackagebot yesod-auth-ldap 0.0.2 - LDAP Authentication for Yesod.  http://hackage.haskell.org/package/yesod-auth-ldap-0.0.2 (MichaelLitchard)
19:07:51 <keep_learning> tommd, Do you have any link how to install libraries with GHC  Head
19:08:38 <keep_learning> I tried to install doh-par but i vector installation was creating problem
19:17:19 * hackagebot authenticate-ldap 0.0.2 - LDAP authentication for Haskell web applications.  http://hackage.haskell.org/package/authenticate-ldap-0.0.2 (MichaelLitchard)
19:28:39 <augur> anyone familiar with memory use analysis?
19:53:39 <Sgeo> http://hackage.haskell.org/packages/archive/rpc/0.0.1/doc/html/Network-RPC-Client.html what is going on here?
19:53:53 <Sgeo> When I use fetch, will compilation actually connect to the server or something?
19:54:20 <Sgeo> It.. looks it
19:59:48 <XexonixXexillion> Sgeo: It will
20:06:42 <JoeyA> Someone added a new Acme module recently, acme-strfry.  Someone should make a pure-Haskell alternative called acme-purée :D
20:07:41 <ion> @hackage acme-strfry
20:07:41 <lambdabot> http://hackage.haskell.org/package/acme-strfry
20:07:50 <cmccann> JoeyA, that would be elliott's work
20:08:26 <cmccann> I like that he thoughtfully provided interfaces for both String and ByteString
20:08:29 <JoeyA> Thanks, didn't know his IRC nick.
20:08:40 <JoeyA> He did a lot of things right, apparently.
20:08:50 <cmccann> he's also ehird on Stack Overflow and reddit for what that's worth
20:09:11 <JoeyA> Except "Stability:   experimental" is frowned upon, I think.
20:10:14 <JoeyA> Even reasonably stable libraries like ByteString say "experimental" or "provisional".
20:10:18 <DanBurton> This is weird. I am looking through some transformer code, and it seems like all of the MonadTrans instances boil down to "lift = SomeNewtype . fmap return" - is this a known pattern?
20:10:50 <JoeyA> :t fmap return
20:10:51 <lambdabot> forall a (m :: * -> *) (f :: * -> *). (Monad m, Functor f) => f a -> f (m a)
20:10:56 * ski thought ehird was someone else
20:11:08 <JoeyA> :t lift
20:11:08 <lambdabot> forall (m :: * -> *) a (t :: (* -> *) -> * -> *). (MonadTrans t, Monad m) => m a -> t m a
20:11:48 <cmccann> @src MaybeT
20:11:49 <lambdabot> Source not found.
20:11:51 <cmccann> urgh
20:11:59 <cmccann> @info MaybeT
20:11:59 <lambdabot> MaybeT
20:12:08 <cmccann> ...
20:12:08 <DanBurton> http://hackage.haskell.org/packages/archive/transformers/0.2.2.0/doc/html/src/Control-Monad-Trans-Maybe.html
20:12:13 <cmccann> anyway
20:12:15 <ion> lambdabot’s @info is one of the most useful commands.
20:12:19 * hackagebot xturtle 0.0.9 - turtle like LOGO  http://hackage.haskell.org/package/xturtle-0.0.9 (YoshikuniJujo)
20:12:23 <cmccann> :t fmap Just
20:12:24 <lambdabot> forall a (f :: * -> *). (Functor f) => f a -> f (Maybe a)
20:12:48 <cmccann> while MaybeT is (m (Maybe a))
20:13:03 <CodeWeaver> ARGH!!! i was gonna do a turtlegraphics package as my first.  arrrgh
20:13:09 <DanBurton> and WhateverT is (m (Whatever a))
20:13:31 <DanBurton> isn't it?
20:13:39 <ski> DanBurton : checked `StateT s' or `ContT o', yet ?
20:13:40 <ion> codeweaver: Nobody’s stopping you. I mean, there are five versions of everything in Hackage already. :-P
20:13:41 <CodeWeaver> hah, x11 only.  i shall do opengl and wxHaskell
20:13:47 <cmccann> DanBurton, so probably that's just a recurring pattern because most simple sum type and product type monad transformers merely insert themselves under the other monad
20:14:06 <DanBurton> ski: what is "return" for state?
20:14:09 <cmccann> monad transformers with function types tend to work differently
20:14:20 <ion> return a = state (\s -> (a, s))
20:14:21 <ski>   return a = State (\s -> (a,s))
20:14:54 <DanBurton> looks rather similar: http://hackage.haskell.org/packages/archive/transformers/0.2.2.0/doc/html/src/Control-Monad-Trans-State-Lazy.html
20:15:03 <DanBurton> :t state
20:15:04 <lambdabot> forall s a. (s -> (a, s)) -> State s a
20:15:59 <cmccann> State is roughly "ReaderT s (Writer s)"
20:16:06 * DanBurton needs to play with this some more
20:16:31 <cmccann> Cont is weird because it's two contravariant readers combined :P
20:16:36 <mgsloan> CodeWeaver - https://patch-tag.com/r/byorgey/diagrams-contrib/snapshot/current/content/pretty/src/Diagrams/TwoD/Path/Turtle.hs , looking forward to the OpenGL version!
20:17:03 <cmccann> ion, speaking of five versions of everything I've decided to invent a new stream processing library
20:17:06 <cmccann> I think we need more
20:17:12 <CodeWeaver> Will do.  I'm currently trying to get eclipseFP working on OSX smoothy and when that's sorted, I'm on the Turtle thing.
20:20:22 <mgsloan> I want to do an implementation of http://en.wikipedia.org/wiki/Cheloniidae_Turtle_Graphics at some point
20:20:53 <cmccann> ooh, neat
20:21:03 <CodeWeaver> warrgh, 3d turtles :D
20:29:00 <mzero> CodeWeaver: if eclipesFP isn't working --- Leksah 0.11 on Mac OS X is pretty nice
20:29:47 <CodeWeaver> leksah 0.11 doesn't build under 7.2.2 (so far).  And when I tried to bodge the libraries to make it build, it just got crashy
20:29:56 <CodeWeaver> But I admit, it would be fun to get that working too.
20:30:02 <CodeWeaver> *wields a mighty stick of fixing OSX issues*
20:30:06 <ChickenNoodle> Hello all :)  Haskell newbie with a question if anybody's feeling generous.
20:30:07 <CodeWeaver> *watches it turn into cheese*
20:30:21 <CodeWeaver> fire!
20:30:23 <strager> Anyone else use Vim for Haskell?
20:30:44 <ChickenNoodle> Trying to output a multi-line string but it seems that the \n is being printed as-is rather than forcing a new line
20:30:48 <mzero> I've actually never gotten Leksah to build... I just use the pre-built release installers
20:31:12 <mzero> ChickenNoodle: are you using   print   or putStr  ?
20:31:17 <strager> ChickenNoodle: Are you using show on the string?
20:31:26 <mzero> print "abc\ndef\n"
20:31:29 <CodeWeaver> Didn't help me.  But I'm not down on it.  I want it to work  So I'll give it another shot eventually.  But right now I'm mamking good progress with the author of eclipseFP.
20:31:34 <mzero> > print "abc\ndef\n"
20:31:35 <lambdabot>   <IO ()>
20:31:38 <mzero> ha
20:31:51 <ChickenNoodle> Alas just as I typed that my TA suggested putStr, which has done what I need. Thumbs up for the excellent service, you guys :P
20:32:03 <strager> http://hackage.haskell.org/packages/archive/base/latest/doc/html/src/System-IO.html#print
20:32:04 <CodeWeaver> :D
20:32:12 <strager> print = show . printStrLn
20:32:25 <mzero> @src print
20:32:25 <lambdabot> print x = putStrLn (show x)
20:32:31 <strager> er print = putStrLn . show
20:32:39 <strager> Or that.
20:33:06 <mzero> "feel the power of lambdabot"   (spoken in mighty-Thor voice)
20:33:13 <ion> > (show . putStrLn) "o hai"
20:33:14 <lambdabot>   "<IO ()>"
20:33:23 <ion> > print "o hai"
20:33:23 <lambdabot>   <IO ()>
20:33:28 <ion> Seems almost right. ;-)
20:33:59 <strager> ;P
20:34:04 <ski> ChickenNoodle : heh
20:34:09 <mzero> no launching missiles with lambdabot, eh?
20:34:25 <strager> What's the command to free an expression of points (i.e. point-free-ify)
20:34:41 <ion> @pl \a b c d e f g -> c a b b a g e
20:34:41 <lambdabot> (((const . (const .) . flip) .) .) . (flip =<< (flip .) . join . (flip .) . flip . flip id)
20:34:45 <ski> @pointless \x -> not (not x)
20:34:45 <lambdabot> id
20:35:31 <strager> Cool
20:35:57 <ski> @help pl
20:35:57 <lambdabot> pointless <expr>. Play with pointfree code.
20:36:43 <ion> @pl not . not
20:36:43 <lambdabot> id
20:37:00 <mzero> @pl \f g x -> f (g x) x
20:37:00 <lambdabot> flip flip id . liftM2
20:37:13 <ski> @pointless \x y -> not (not x && not y)
20:37:13 <lambdabot> (not .) . (. not) . (&&) . not
20:37:40 <mzero> @pl \f g x -> g (f x) x
20:37:40 <lambdabot> flip flip id . (ap .) . flip (.)
20:38:08 <ski> looking for `(>>=)' ?
20:38:53 <strager> @pl flip flip
20:38:53 <lambdabot> flip flip
20:38:54 <ion> Probably looking whether lambdabot manages to figure out it’s (=<<).
20:39:03 <strager> Wouldn't flip flip == id?
20:39:20 <ion> @type Prelude.flip Prelude.flip
20:39:21 <lambdabot> forall a b c. b -> (a -> b -> c) -> a -> c
20:39:44 <strager> Guess not ;P
20:39:55 <mzero> ski - yes, just wondering if @pl would use that
20:40:03 <mzero> @type flip id
20:40:03 <lambdabot> forall a b. a -> (a -> b) -> b
20:40:08 <mzero> :-)
20:40:54 <mzero> @type flip flip id
20:40:55 <lambdabot> forall (f :: * -> *) b a. (Functor f) => f ((a -> a) -> b) -> f b
20:41:39 <eyu100> > 1 + 1
20:41:40 <lambdabot>   2
20:41:59 <CodeWeaver> > sqrt(-peanut_butter)
20:42:00 <lambdabot>   Not in scope: `peanut_butter'
20:42:07 <eyu100> > sqrt (-1)
20:42:07 <CodeWeaver> *snort*
20:42:08 <lambdabot>   NaN
20:43:00 <DanBurton> @pl \a -> return (a, s)
20:43:00 <lambdabot> return . flip (,) s
20:43:12 <ion> > sqrt (-1) :: Complex Double
20:43:13 <lambdabot>   (-0.0) :+ 1.0
20:43:43 <CodeWeaver> > sqrt(-peanut_butter) :: SillyNumbers
20:43:44 <lambdabot>   Not in scope: type constructor or class `SillyNumbers'Not in scope: `peanut...
20:44:12 <CodeWeaver> Oh lamdabot, I have so much to teach you.
20:44:44 <DanBurton> teach lambdabot the numeric value of peanut butter?
20:45:04 <kallisti> is there a function to convert a C array to a Haskell array?
20:45:05 <eyu100> > 0 :: Complex Int
20:45:06 <lambdabot>   No instance for (GHC.Float.RealFloat GHC.Types.Int)
20:45:06 <lambdabot>    arising from the lit...
20:45:09 <kallisti> I'm finding only C array -> list
20:45:45 <eyu100> > 0 :: Complex (Complex Float)
20:45:46 <lambdabot>   No instance for (GHC.Float.RealFloat
20:45:46 <lambdabot>                     (Data.Complex.Comp...
20:45:53 <eyu100> > 0 :: Complex Float
20:45:54 <lambdabot>   0.0 :+ 0.0
20:45:57 <CodeWeaver> No, no, no.  Teach lambdabot the numeric quantity of the square root of negative peanut butter.
20:46:57 <ion> kallisti: A C array of what?
20:47:12 <kallisti> char**
20:47:18 <kallisti> is the type of the array
20:47:26 <kallisti> it has length 4, and contains strings.
20:47:39 <kallisti> right now I'm just using
20:47:51 <kallisti> ptr >>= peekArray 4 >>= mapM peekCString
20:48:03 <kallisti> is there a way to convert directly to an array instead of having an intermediate list?
20:48:50 <ion> For char *, you’d likely want to pack it as a ByteString. For char **, perhaps a list of ByteStrings?
20:49:23 <kallisti> it has a fixed size always so an array seems more appropriate.
20:49:35 <kallisti> also it's constant.
20:49:38 <ion> ok
20:49:38 <kallisti> so no updates.
20:49:58 <kallisti> for now I'll just use listArray
20:50:07 <kallisti> and I might switch everything over to ByteStrings but for now String seems fine.
20:50:22 <DanBurton> @pl lift m = StateT (\s -> liftM (flip (,) s) m)
20:50:22 <lambdabot> lift = StateT . flip (fmap . flip (,))
20:51:04 <ski> @type flip . flip
20:51:05 <lambdabot> forall a b a1. (a -> a1 -> b) -> a -> a1 -> b
20:51:43 <DanBurton> :t flip (fmap . flip (,))
20:51:44 <lambdabot> forall a (f :: * -> *) a1. (Functor f) => f a -> a1 -> f (a, a1)
20:52:04 <ion> Data.Array.Storable.unsafeForeignPtrToStorableArray :: Ix i => ForeignPtr e -> (i, i) -> IO (StorableArray i e)
20:52:30 <ion> Foreign.Marshal.Array.peekArray :: Storable a => Int -> Ptr a -> IO [a]
20:52:44 <ion> Perhaps create a list of arrays using them?
20:53:22 <DanBurton> @pl foo a = StateT $ \s -> return (a, s)
20:53:22 <lambdabot> foo = StateT . (return .) . (,)
20:53:27 <ddarius> @hoogle CString -> ByteString
20:53:27 <lambdabot> Data.ByteString packCString :: CString -> IO ByteString
20:53:27 <lambdabot> Data.ByteString.Char8 packCString :: CString -> IO ByteString
20:53:27 <lambdabot> Data.ByteString.Unsafe unsafePackCString :: CString -> IO ByteString
20:53:56 <kallisti> what's unsafe about unsafePackCString
20:54:06 <ion> It doesn’t make a copy.
20:54:13 <kallisti> oh my.
20:54:23 <ion> Do you need to make sure your C code doesn’t mutate the memory.
20:58:32 <kallisti> ion: not a list of arrays. I want Array Int String
20:59:25 <ion> Oh, so you want the inner char *s _not_ to be converted to arrays.
20:59:55 <ddarius> If you statically know that there are only four strings, I would use a tuple.
21:00:24 <ski> (.. or maybe a record)
21:07:20 * hackagebot zlib-bindings 0.0.3.1 - Low-level bindings to the zlib package.  http://hackage.haskell.org/package/zlib-bindings-0.0.3.1 (MichaelSnoyman)
21:07:22 * hackagebot hledger-lib 0.17 - Core data types, parsers and utilities for the hledger accounting tool.  http://hackage.haskell.org/package/hledger-lib-0.17 (SimonMichael)
21:11:45 <nyingen> @quote
21:11:45 <lambdabot> ryan[WTF] says: it's enterprise quality if it runs everything in a big try/catch
21:12:23 * hackagebot hledger 0.17 - The main command-line interface for the hledger accounting tool.  http://hackage.haskell.org/package/hledger-0.17 (SimonMichael)
21:12:25 * hackagebot hledger-web 0.17 - A web interface for the hledger accounting tool.  http://hackage.haskell.org/package/hledger-web-0.17 (SimonMichael)
21:12:46 <ski> @arr
21:12:46 <lambdabot> Har de har har!
21:13:05 <ion> @yarr
21:13:05 <lambdabot> Yo ho ho, and a bottle of rum!
21:14:12 <nyingen> @yow
21:14:12 <lambdabot> Couldn't find fortune file
21:14:17 <nyingen> @quote
21:14:18 <lambdabot> Brend says: Whoever chose the title "A Gentle Introduction to Haskell" is obviously accustomed to wrestling bears in piranha pits or something.
21:14:29 <nyingen> meh
21:14:43 <nyingen> I thought it was aptly named, so long as you have some FP experience
21:15:36 <ski> i found it ok
21:15:54 <mzero> @quote train
21:15:54 <lambdabot> ghc says: All of the type variables in the constraint are already in scope (at least one must be universally quantified here)
21:15:54 <ski> i think it was one of the first introductory texts
21:16:08 <mzero> booooo
21:16:20 <ski> ?
21:16:26 <mzero> @quote jello
21:16:26 <lambdabot> kmc says: a monad is like an invisible train filled with jello traveling backwards in time
21:16:31 <mzero> there - that's more like it
21:16:36 <nyingen> @quote
21:16:37 <lambdabot> PhilWadler says: The essence of XML is this: the problem it solves is not hard, and it does not solve the problem well. (POPL2003)
21:16:41 <nyingen> amen
21:17:02 <nyingen> also, XML is not a data storage model
21:17:06 <mzero> and yet --- neither does anything else
21:17:11 <nyingen> too many people seem to think it is so
21:17:21 <companion_cube> I love the quote about jello
21:17:32 <mzero> me too!
21:18:03 <cmccann> @quoth
21:18:03 <lambdabot> Olin_Shivers says: Who should I thank? My so-called ``colleagues,'' who laugh at me behind my back, all the while becoming famous on my work? My worthless graduate students, whose computer skills
21:18:03 <lambdabot> appear to be limited to downloading bitmaps off of netnews?
21:18:11 <nyingen> heh
21:18:16 <cmccann> @queue
21:18:17 <lambdabot> megeria says: i am so new to haskell that i still have the new car smell
21:18:19 <nyingen> is that the guy who wrote that scheme shell?
21:18:25 <ski> yes
21:18:32 <cmccann> @quale
21:18:32 <lambdabot> siracusa says: otherwise `maybe` not $ Just otherwise
21:19:00 * cmccann likes inventing new lambdabot commands
21:19:09 <nyingen> @quort
21:19:09 <lambdabot> Maybe you meant: quit quote
21:19:13 <nyingen> oh come on
21:19:14 <cmccann> tch
21:19:16 <cmccann> nice try
21:19:37 <nyingen> my lambdabot has a @derp command which quotes 4chan
21:19:53 <nyingen> @dorp, @dalp, etc
21:19:53 <lambdabot> Unknown command, try @list
21:20:50 <ski> "Scsh Reference Manual -- Acknowledgements" by Olin Shivers at <http://www.scsh.net/docu/html/man.html>
21:20:56 <nyingen> yup
21:20:59 <nyingen> pretty funny
21:20:59 <ski> "100% and 80% solutions" by Olin Shivers at <http://www.ccs.neu.edu/home/shivers/papers/sre.txt>
21:21:15 <nyingen> he had some other amusing stuff on the web too, IIRC
21:21:26 <nyingen> the opinions file or something, some weird collection of old BBS posts
21:23:09 <ski> "The Anatomy of a Loop -- A story of scope and control" by Olin Shivers at <http://www.ccs.neu.edu/home/shivers/papers/loop.pdf> ("Writing loops with tail-recursive functions is the equivalent of writing them with goto`s.")
21:24:33 <nyingen> http://www.ccs.neu.edu/home/shivers/opinion.html
21:24:38 <nyingen> I was thinking of this.
21:25:05 <ski> "Multi-return Function Call" by Olin Shivers,David Fisher at <http://www.ccs.neu.edu/home/shivers/papers/mrlc.pdf>
21:28:09 <Sgeo> ski, what if I feel like I don't have a choice?
21:28:25 <ski> ?
21:28:37 <saterus> can someone give me a rundown (or a link) to when i should install stuff with cabal-dev vs cabal-src?
21:29:10 <Sgeo> writing a loop with tail recursive functions
21:29:48 <monochrom> yes, recursion is like goto, I agree
21:30:04 <ski> Sgeo : then you must do it, i suppose
21:32:20 * hackagebot ghc-mod 1.0.8 - Happy Haskell programming on Emacs  http://hackage.haskell.org/package/ghc-mod-1.0.8 (KazuYamamoto)
21:34:21 <ski> (Sgeo : in case you're interested, Riastradh's looping facility <http://mumble.net/~campbell/scheme/foof-loop.txt> was inspired by that paper)
21:42:30 <nyingen> @quote
21:42:30 <lambdabot> psnl says: ndm: you should have stayed around for the part where Conor denied he was Conor.
21:44:14 <mgsloan> goto is like recursion where you're only allowed to pass around "Map String Dynamic"
21:44:41 <ski> @quote recursion
21:44:41 <lambdabot> mm_freak says: explicit recursion should only be used if necessary
21:44:47 <ski> !
21:45:40 <ski> @quote stark
21:45:41 <lambdabot> AlanPerlis says: The string is a stark data structure and everywhere it is passed there is much duplication of process. It is a perfect vehicle for hiding information.
21:45:49 * Sgeo is going to switch some of his code from explicit loop to using unfoldr
21:46:00 <Sgeo> But that's due to a fundamental algorithm change
21:46:19 <Sgeo> Which, while doing what I actually want, will also slow things down :/
21:46:21 <ski> @quote defeat
21:46:21 <lambdabot> Cale says: Computing lengths is admitting defeat
21:47:30 <ski> @quote recursion
21:47:30 <lambdabot> VerityStob says: Lisp is still #1 for key algorithmic techniques such as recursion and condescension.
21:47:37 <ski> @quote recursion
21:47:37 <lambdabot> soupdragon says: why do people keep telling the same Recursion joke over and over again?   it is baseless humor
21:47:48 <ski> @quote recursion
21:47:49 <lambdabot> VerityStob says: Lisp is still #1 for key algorithmic techniques such as recursion and condescension.
21:47:57 <ski> @quote recursion
21:47:57 <lambdabot> mmorrow says: [regarding excessive use of categorical recursion schemes] a morphasm?
21:48:08 <ski> @quote recursion
21:48:08 <lambdabot> VerityStob says: Lisp is still #1 for key algorithmic techniques such as recursion and condescension.
21:48:12 <Corey> ski: Enough.
21:48:14 * ski gives up
21:50:52 <nyingen> @quote lisp
21:50:52 <lambdabot> qwe1234 says: the lisp folks have purposefully made lisp so that static analysis is impossible.
21:50:56 <nyingen> @quote lisp
21:50:57 <lambdabot> dons says: you start with lisp, get to statically typed lisp (ML), add laziness, add whitespace to solve the parens stuff, add syntax sugar (for human programmability), and finally, add purity (i.e.
21:50:57 <lambdabot> true functional programming), and you've got haskell
21:51:31 <nyingen> @quote java
21:51:31 <lambdabot> kmc says: The actual pattern is that you *first* do a breathlessly excited post about how Haskell is ninja pirate awesome because quicksort is so short, and it has closures, and you're going to
21:51:31 <lambdabot> learn Haskell and write all your software in Haskell... then a week later you do the bitter "debunking" post. Monads are hard and Maybe isn't any different from Java's null and I was promised a pony,
21:51:32 <lambdabot>  where's my pony
21:51:51 <nyingen> @quote java
21:51:51 <lambdabot> cbeust says: [Java] was a pretty revolutionary language in 1995
21:52:05 <nyingen> it had applets and shit
21:52:09 <nyingen> @quote java
21:52:09 <lambdabot> dibblego says: Java programmers prefer referential transparency too, they just call it "design patterns" or something
21:52:15 <nyingen> hah
21:54:53 <Sgeo> 'If a cryptographer comes forward and says, "Well, theoretically, there's a bug here assuming X, Y, and Z," I'm much less interested in hearing about it versus an actual code sample demonstrating the problem. (I've been the recipient of the former, and it doesn't really get my attention much.)'
21:54:56 <Sgeo> ~Snoyman
21:55:29 <ski> nyingen : <http://c2.com/cgi/wiki?ImmutableValue> ?
21:56:24 <Sgeo> I'm not sure if it's ok that I'm feeling ... less than pleased about that quote
21:56:27 <nyingen> ski: heh
22:53:51 <jtobin> @quote statistics
22:53:51 <lambdabot> DaveBlei says: ‘machine learning’ is how you say ‘statistics’ to a computer scientist.
22:56:35 <jtobin> @quote statistics
22:56:35 <lambdabot> pozic says: statistics. a wonderful tool to control people.
23:27:20 * hackagebot uri-conduit 0.2.1 - Read and write URIs  http://hackage.haskell.org/package/uri-conduit-0.2.1 (MichaelSnoyman)
23:33:37 <erus`> Does anyone know some good software for defining and viewing (as a graph) the relationship between entities?
23:33:54 <erus`> ie. A is a B and has properties XYZ
23:41:14 <Eduard_Munteanu> erus`: graphviz perhaps?
23:42:34 <erus`> looks good
23:44:32 <Eduard_Munteanu> It's pretty commonly used to generate graphs from certain datasets, e.g. for documentation, callgraphs etc..
23:48:22 <companion_cube> graphviz is excellent
23:48:52 * elliott hopes someone goes rogue and uploads a fixed zlib package already
23:53:23 <lysgaard> I've got a HDBC PostgreSQL query where I need to escape a '?'. That is; the query should contain an '?' after argument substitution. Any idéas?
23:54:02 <ion> Doesn’t that work exactly the same way as any other query?
23:57:56 <Blkt> good morning everyone
23:59:04 <ion> Oh, you meant you need to have it *not* escape a ‘?’?
23:59:48 <lysgaard> ion: Em, yeah, maybe. What i mean is that i want to write a query that looks like this:
