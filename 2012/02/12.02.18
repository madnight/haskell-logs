00:00:12 <Saizan> aadrake: print uses show, which might be pretty slow
00:02:04 <aadrake> Saizan: I only had that in there for an apples-apples comparison with the Ruby version
00:02:24 <Saizan> yeah, but i'm not sure it's an apples-apples
00:02:36 <aadrake> Saizan: That does raise a good question though, is it possible to perform the map without any IO action?
00:02:55 <aadrake> Saizan: Without breaking it out into a separate function I mean
00:03:08 * hackagebot yjsvg 0.1.6 - make SVG string from Haskell data  http://hackage.haskell.org/package/yjsvg-0.1.6 (YoshikuniJujo)
00:04:31 <Saizan> you could do return $! foldl' (flip seq) () (map (parse json) ..)
00:04:39 <Saizan> ?type foldl' (flip seq) ()
00:04:40 <lambdabot> forall b. [b] -> ()
00:04:51 <quintessence> depends on how lazy Aeson is under the hood
00:04:55 <quintessence> though my guess is not very
00:05:16 <Saizan> the Value type seems to have strict fields everywhere
00:06:49 <Saizan> ah, it has a NFData instance
00:06:54 <Saizan> so you should use rnf
00:07:16 <Saizan> return $! rnf (map (parse json) ..)
00:07:59 <aadrake> Ah, that's why BOS used that in the test files on his github
00:08:14 <aadrake> What would I need to import to use rnf?
00:08:25 <Saizan> Control.Deepseq, from the deepseq package
00:08:38 <Saizan> (or DeepSeq?)
00:08:44 <Saizan> @hoogle rnf
00:08:45 <lambdabot> Control.DeepSeq rnf :: NFData a => a -> ()
00:09:03 <Saizan> otherwise if you want printing there's Data.Aeson.Encode
00:09:26 <aadrake> Saizan: I don't need the printing actually.  When it comes to production the output won't be printed
00:10:25 <aadrake> Saizan: No instance for (NFData (Data.Attoparsec.Lazy.Result Value)) arising from a use of 'rnf'
00:11:19 <Saizan> aadrake: the instance is for Value, so you've to pattern match the Result yourself
00:12:46 <aadrake> Saizan: I wish I could say I understand exactly what you mean, but I don't.  I've never used DeepSeq so I guess I have some research to do :)
00:13:33 <Saizan> or you could write an instance for it i guess, it's almost the same amount of code instance NFData a => NFData (Result a) where rnf (Done str r) = rnf str `seq` rnf r; rnf (Fail x y z) = rnf x `seq` rnf y `seq` rnf z
00:14:50 <Saizan> aadrake: if you add the instance above ^^^, you can keep using just rnf in main
00:15:34 <aadrake> Saizan: Should Result be the result from Aeson or Attoparsec?  I'm getting an Ambiguous Occurence complaint with that code
00:16:08 <Saizan> the one from Attoparsec
00:17:55 <aadrake> Saizan: That fixed that error, but now I have an error saying No instance for (NFData Value)
00:18:06 <aadrake> Saizan: Again from 'rnf'
00:18:39 <Saizan> aadrake: which version of aeson are you using?
00:19:41 <aadrake> Saizan: 0.4.0.1 and 0.5 are installed.  Do I need to go up to 0.6?
00:20:57 <Saizan> aadrake: nope
00:21:03 <Saizan> aadrake: let me check one thing
00:23:37 <Saizan> aadrake: weird, rnf (undefined :: Value) works fine here with Data.Aeson and Control.DeepSeq imported
00:23:55 <Saizan> and aeson-0.5.0.0
00:25:02 <aadrake> Saizan: Hmm
00:25:47 <aadrake> Saizan: Not for me, I get the same error in GHCi
00:26:13 <Saizan> can you paste the exact error?
00:26:27 <aadrake> In channel or elsewhere?
00:26:31 <Saizan> and ghc-pkg list deepseq
00:26:39 <Saizan> better on a pastebin (hpaste.org)
00:28:42 <aadrake> Saizan: https://gist.github.com/1858449
00:29:52 <Saizan> it could be that you've two deepseq
00:30:24 <Saizan> try compiling with -package deepseq-1.1.0.2
00:30:34 <Saizan> or starting ghci with that
00:31:13 <aadrake> sai
00:31:26 <aadrake> Saizan: I wonder why I have two.  All I did was cabal install deepseq
00:32:02 <aadrake> Maybe some other library needed a version at some point
00:32:06 <Saizan> aadrake: you had one already, and cabal didn't bother warning you since there was a newer version
00:32:15 <Saizan> aadrake: yeah, aeson for example
00:32:35 <aadrake> Saizan: When I tried to import it I got an error so that's why I had to install it
00:32:50 <Saizan> ah
00:33:14 <Saizan> does rnf work for Value using the older version?
00:33:54 <aadrake> Saizan: I get a different error when I try to compile with that version
00:34:25 * Saizan wonders if that's progress
00:34:31 <aadrake> I updated the gist
00:34:49 <aadrake> It seems to be a problem in the instance declaration
00:35:01 <aadrake> But honestly I don't know enough to know what's going on :)
00:35:50 <Saizan> so now it gives both?
00:36:18 <aadrake> Saizan: No, it only gives the bottom error now
00:36:46 <aadrake> Saizan: I left the others in for reference
00:37:39 <Saizan> instance NFData a => NFData (Result a) where rnf (Done str r) = str `seq` rnf r; rnf (Fail x y z) = x `seq` rnf y `seq` rnf z <-
00:37:47 <Saizan> that should dogde the issue ^^^
00:38:09 * hackagebot SDL 0.6.3 - Binding to libSDL  http://hackage.haskell.org/package/SDL-0.6.3 (DavidHimmelstrup)
00:38:32 <Saizan> it's not quite correct but it shouldn't matter if the data is correct enough
00:39:12 <aadrake> Saizan: It should be Data.Attoparsec.Lazy.Result a right?
00:39:16 <Saizan> yep
00:39:55 <aadrake> Saizan: There's a spare <- on the end.  Is that syntacticaly correct?
00:40:01 <aadrake> syntactically
00:40:07 <Saizan> ah, no, that was me pointing to it
00:40:16 <aadrake> Saizan: I thought you left something off :)
00:40:44 <aadrake> Saizan: Compiled without error
00:40:57 <Saizan> great :)
00:41:10 <aadrake> Now let's see if there is a speedup
00:41:59 <Saizan> btw, rnf stands for Reduce to Normal Form, and in general instances just structurally recurse using `seq` to force all the substructures
00:42:08 <aadrake> Saizan: Wow.  That is much faster
00:42:26 <Saizan> heh, suspected so
00:43:15 <aadrake> Saizan: The original version was about 13 seconds, the lazy verion with mapM_ went down to around 9 seconds, and now it's down to 2.7 seconds.
00:43:50 <aadrake> Saizan: Of course I have no idea what's going on or how to do anything with the parsed data, but the speed is encouraging :)
00:44:58 <Saizan> aadrake: replacing json with json' might even get faster
00:46:34 <aadrake> Saizan: This is faster than the C version actually
00:46:43 <aadrake> Saizan: By about 1100 records per second
00:47:23 <ion> How about with -fllvm?
00:47:33 <Saizan> cool, and the C version is not doing more work?
00:48:01 <aadrake> ion: Warning: -fllvm is incompatible with -fPIC and -dynamic on this platform; ignoring -fllvm
00:48:43 <aadrake> Saizan: Well, the C version just takes a set of keys and grabs all the values out of each record in the file.
00:49:22 <aadrake> Saizan: So there is some unfairness because the C version is also doing output
00:50:52 <Saizan> yeah, though if one stays away from show and String i guess, output should be pretty fast in haskell too
00:52:06 <aadrake> Saizan: Using parse' is about 0.5s slower per million records
00:52:22 <Saizan> aadrake: you meant json' ?
00:52:47 <aadrake> Saizan: Yes, my mistake.
00:52:57 <aadrake> Saizan: Wait, no
00:53:09 * hackagebot shake 0.2.7 - Build system library, like Make, but more accurate dependencies.  http://hackage.haskell.org/package/shake-0.2.7 (NeilMitchell)
00:53:35 <Boxo> When I get the contents of a normal wordpress post page with getResponseBody from Network.HTTP, characters like – get turned into gibberish (even if I putStr them), even though they're fine if I say, save the html page and load it with readFile. Known problem? Any help?
00:53:37 <aadrake> Saizan: Yes, I mean json'
00:53:47 <aadrake> Saizan: Too many windows, too many versions :)
00:55:08 <aadrake> Saizan: Now if I build in the dump to CSV functionality I can do a fair comparison against the C version
00:56:42 <Saizan> Boxo: readFile will decode the contents according to your locale, getResponseBody maybe doesn't
00:57:33 <Saizan> aadrake: the fact that json' is slower might be interesting for bos
00:57:58 <aadrake> Saizan: Only slightly over a large set of records, but still a little strange
00:58:45 <Saizan> it might just be that GHC got smarter than him about strictness :)
00:59:18 <aadrake> Saizan: That's possible
01:00:29 <aadrake> Saizan: How much work do you think it would be to add the functionality to accept a list of arguments to use as keys and then dump the values for those keys into a CSV file?
01:00:54 <aadrake> Saizan: The reason I ask is because I'm still figuring out what's going on with this return $! business
01:01:08 <Saizan> aadrake: not much if there's a good CSV lib
01:01:31 <aadrake> Saizan: So I'm not sure what my next step would be.  csv-enumerator has proven fast for me in the past, but I don't know if it's useful for this.
01:01:50 <Saizan> aadrake: ah, the return $! rnf .. part would just go away once you have a real use for the data
01:03:29 <aadrake> Saizan: So the return $! rnf ... is just a ways to do something inside IO without actually doing any IO?
01:04:03 <srhb>  Would HOpenGL be a good place to start for drawing the mandelbrot set?
01:04:04 <aadrake> Or would it be more accurate to say without performing an IO action?
01:04:33 <aadrake> srhb: http://mcfunley.com/388/haskell-mandelbrot-set
01:04:41 <Saizan> aadrake: (return $! rnf ..) is an IO action, though one that has no side-effects
01:04:51 <srhb> aadrake: Aha, thanks.
01:05:10 <Saizan> aadrake: but to compute the action itself it has to evaluate the part in the ..
01:06:12 <aadrake> Saizan: A side-effect-free IO action.  That seems like an oxymoron.
01:06:23 <Saizan> because $! is strict application and rnf is going to traverse the whole structure
01:06:44 <aadrake> srhb: No problem.  That code is old but still works as of a couple of months ago.
01:06:45 <Saizan> aadrake: heh, yeah, but (return x) is like that
01:07:22 <Saizan> aadrake: anyhow csv-enumerator looks like it has functions to print out CSV rows too, so it should be appropriate
01:08:06 <aadrake> Saizan: Still, knowing that I can incorporate this into a web service and get very fast JSON parsing is nice
01:08:40 <aadrake> Saizan: Using it for JSON to CSV conversion would be useful but I probably wouldn't have a production need for it
01:09:35 <Saizan> http://hackage.haskell.org/packages/archive/csv-enumerator/0.10.1.1/doc/html/src/Data-CSV-Enumerator.html#writeCSVFile <- that acc is worrying
01:09:44 <aadrake> Saizan: Do you think there could be further speedup from parallelization/concurrency?
01:10:46 <Feuerbach> Has anyone managed to build some packages using uhc? Here's what I get: http://hpaste.org/63898
01:11:11 <Saizan> aadrake: probably, but one has to avoid clogging the memory with too much data at a time and make big enough parallel tasks
01:12:18 <Saizan> Feuerbach: does uhc have a base package at all?
01:12:23 <aadrake> Saizan: Would you take an approach of taking a certain number of records from the lazy list and passing those off to another function or would you use a different strategy?
01:14:56 <Saizan> aadrake: i'd probably try to use parListChunk and parBuffer from Control.Parallel.Strategies, though i must say i've only read about them
01:16:17 <aadrake> Saizan: Also, if you know anyone who is appropriate, we are seeking a Data Scientist with Haskell experience: http://madvertise.com/en/2012/02/14/data-scientist-fm/
01:16:30 <Saizan> but yeah, that's more or less the idea, though i wonder how it interacts with the sequential reading from the file/splitting into lines
01:16:53 <aadrake> Saizan: The limitation would be the read speed of the disk, assuming proper chunking and allocation
01:17:20 <LostPW> maybe it is interested for you to read the ariticle from the communication of the acm "Ocamel for the masses"
01:18:05 <aadrake> LostPW: To whom are you speaking?
01:19:51 <Feuerbach> Saizan: dunno, its docs say that you can install packages using Cabal, so I wonder if anyone actually has succeeded in that
01:21:43 <aadrake> Saizan: If you do know someone who would be a good fit, you can email me at adrake@gmail.com
01:21:51 <aadrake> Saizan: Or adam.drake@madvertise.com
01:22:57 <Saizan> aadrake: noone comes to mind atm, but ok :)
01:23:38 * Saizan goes afk
01:23:44 <Feuerbach> aadrake: how many applications have you got so far?
01:24:51 <aadrake> Feuerbach: The listing has been up for 3 business days and we've had 2 very good applicants.
01:25:03 <Boxo> So I have some Strings that are apparently UTF8-encoded, and haskell doesn't like that and shows them as gibberish. So I should decode them somehow. But none of the UTF8 libraries seem to even have a function of type String -> String?
01:25:28 <aadrake> Boxo: I'm confused, Haskell is totally UTF-8 friendly
01:25:49 <Feuerbach> Boxo: http://hackage.haskell.org/packages/archive/utf8-string/0.3.7/doc/html/Codec-Binary-UTF8-String.html
01:26:20 <Feuerbach> decodeString in particular
01:26:43 <aadrake> Feuerbach: Do you ask because you have some experience trying to hire people with a Haskell background?
01:26:51 <Boxo> aadrake: well, I downloaded a html page with Network.HTTP, and the metadata say it's UTF8, but single characters in it get turned into stuff that's like "\226\128\147" when printed, and gibberish when putStr'd
01:27:40 <Boxo> ok Feuerbach...
01:28:01 <Feuerbach> aadrake: I ask out of curiosity :) I do have a bit of experience, but in a different market
01:28:39 <Boxo> that worked perfectly Feuerbach, thanks :)
01:28:44 <Feuerbach> yw
01:29:26 <aadrake> Feuerbach: What do you mean by different market?
01:34:15 <Feuerbach> we can discuss it in private
01:35:01 <dreixel> mux_: pong
01:35:59 <mux_> dreixel: hi there :) I'm having troubles dealing with recursive sum types with GHC.Generics
01:36:52 <mux_> dreixel: it seems I'm supposed to handle the recursion myself, calling from again, otherwise I never get past the first "unfolding" of a list
01:37:30 <mux_> dreixel: and it doesn't look like I've got enough information to know when to do that
01:38:10 <mux_> I'd have expected K1 R to be for those cases but it's also used for the primitive types
01:39:21 <mux_> dreixel: do you see what I mean? I'm probably not being very clear I guess
01:40:48 <aadrake> mux_: I wish I could help you but I'm still relatively new to Haskell
01:41:55 <dreixel> mux_: sorry, no, I don't quite see what you mean
01:42:01 <dreixel> what is the function you're trying to define?
01:42:48 <mux_> dreixel: a generic deepseq function, thus one that needs to go over all the elements in a list for instance
01:43:43 <dreixel> mux_: ok, I see
01:44:04 <dreixel> mux_: have you had a look at http://hackage.haskell.org/packages/archive/regular-extras/0.2.2/doc/html/src/Generics-Regular-Functions-Seq.html ?
01:44:20 <dreixel> it's generic deepseq but for another GP lib
01:44:41 <dreixel> it should be a bit similar, but regular handles recursion differently, so if that's what you're struggling with this example might not help.
01:44:45 <mux_> I haven't, but it looks very very close to what i have
01:45:08 <dreixel> anyway, in the K case you should call deepseq
01:45:08 <mux_> https://bitbucket.org/mumux/generic-deepseq/src/e901dd4d584c/Control/DeepSeq/Internal.hs
01:45:25 <mux_> I call just seq in the K case
01:45:36 <dreixel> I think you should call deepseq
01:45:42 <dreixel> (not gdeepseq)
01:46:10 <mux_> if I call deepseq i don't see how this will ever terminate
01:46:29 <mux_> deepseq calls gdeepseq, which calls itself recursively in a number of casse
01:46:38 <mux_> the K case is like the base case for me in that case
01:46:51 <dreixel> but in K you are at the children
01:47:03 <mux_> am I
01:47:04 <dreixel> so you're just going over the term and you end when you reach the leaves.
01:47:05 <mux_> ?
01:47:12 <dreixel> sure you are :)
01:47:14 <mux_> that breaks down for simples types such as Int
01:47:25 <mux_> when I reach K for those types, I'm just at the value
01:47:31 <mux_> the thing is
01:47:38 <dreixel> right, but what does deepseq do for Int?
01:47:52 <mux_> I can have this code work for lists, calling gdeepseq and from again (which is the same as calling deepseq)
01:48:01 <mux_> but then it never terminates for primitive types
01:48:08 <mux_> dreixel: it should do just a seq
01:48:17 <dreixel> right, and that's what you want
01:48:39 <dreixel> use deepseq in the K case, and try it.
01:48:46 <mux_> well ok
01:51:42 <osa1> what is `f` in this signature: fmap :: (a -> b) -> f a -> f b ? is it a type constructor?
01:52:09 <Feuerbach> osa1: yes, exactly
01:54:11 <mux_> dreixel: mmm I can't seem to have it type check now o_O
01:54:47 <mux_> dreixel: but I used to have a recursive instance like that for the "K1 R" case and as expected it wasn't terminating for primitive types
01:57:27 <dreixel> but primitive types don't even get a recursive invocation
01:57:38 <dreixel> mux_:  I really don't see why that wouldn't work
01:57:41 <dreixel> why doesn't it typecheck?
01:58:08 <mux_> primitive types don't get a recursive invocation?
01:58:10 * hackagebot digestive-functors-happstack 0.1.1.4 - Happstack backend for the digestive-functors library  http://hackage.haskell.org/package/digestive-functors-happstack-0.1.1.4 (JasperVanDerJeugt)
01:58:26 <mux_> type Rep Int = D1 D_Int (C1 C_Int (S1 NoSelector (Rec0 Int)))
01:58:31 <mux_> this is from the GHC.Generics source
01:58:50 <dreixel> yes, but you call deepseq on it, not gdeepseq.
01:59:09 <hiptobecubic> I have a predicate that is an (Either Error Bool) and i want to filter a list of [b] such that i get type (Either Error [b]) back. Is this common or do I have to invent something?
01:59:11 <mux_> I've been calling gdeepseq . from because the two classes are splitted
01:59:24 <dreixel> no, just call deepseq!
01:59:29 <dreixel> and then it'll use seq for Int
01:59:32 <mux_> ah, ok, defaulting doesn't kick in
01:59:34 <dreixel> and gdeepseq for lists, for instance
01:59:44 <mux_> how will it use seq if I'm never calling it myself?!
02:00:18 <mux_> do you mean that I should call seq for K1 P (Par0) and deepseq for K1 R (Rec0) ?
02:00:23 <dreixel> it's the Deepseq instance for Int.
02:00:32 <dreixel> no, at the K case, just call deepseq
02:00:48 <mux_> there is not a single seq call in my code
02:00:53 <mux_> it doesn't use other external classes
02:01:03 <mux_> how is the DeepSeq instance going to call seq? it's not going to happen
02:03:05 <nand`> Is there a way to “lift” a function of type Foo b :: b -> b to type :: a -> a, by somehow implementing this logic: “If a belongs to Foo, do something, otherwise return it unchanged”?
02:03:17 <nand`> err type :: Foo b => b -> b
02:03:52 <mux_> dreixel: ok, I just did that, and as expected it never returns
02:04:35 <mux_> dreixel: I suppose you meant for me to have explicit instances for the primitive types, that do call seq
02:04:57 <mux_> I can see how that would work
02:07:39 <mux_> dreixel: I guess you expected me to use the NFData class from the existing deepseq package
02:08:35 <mux_> or have something similar
02:09:18 <srhb> Given window size, how do I convert a pixel coordinate to a vertex for use in HOpenGL?
02:10:39 <dreixel> mux_: ah, yes
02:10:49 <dreixel> mux_: the primitive types should not have generic instances
02:10:59 <dreixel> I was assuming you were using NFData indeed.
02:11:30 <mux_> okay, thanks. I'm not sure if I should use this NFData class from the deepseq package or have my own
02:11:51 <mux_> the NFData from the deepseq package is supposed to work with structured types already so I'm not sure it makes sense for me
02:12:08 <mux_> but I can have something exactly the same with just instances for primitive types
02:12:13 <mux_> dreixel: how does that sound?
02:13:36 <dreixel> mux_: that should do too
02:19:34 <WarzoneCommand> is anyone using haskell-mode in emacs?
02:19:44 <srhb> WarzoneCommand: Yes
02:19:50 <srhb> WarzoneCommand: Plenty, I would imagine.
02:20:02 <WarzoneCommand> I am running into some weird situation with inf-haskell mode and I'm not sure how to solve it
02:20:21 <WarzoneCommand> suppose I am developing version 0.2 of a library, and I have version 0.1 installed locally
02:20:28 <Lemmih> srhb: Did you manage to convince your group to use Haskell?
02:20:37 <WarzoneCommand> I have two modules, say Foo and Bar. and Bar uses Foo
02:20:52 <WarzoneCommand> now in version 0.2 I added some additional functionality to module Foo, which I'm using in Bar
02:21:08 <srhb> Lemmih: Almost! If the project we decide on doesn't seem like a bad fit for Haskell for them, I think they're on. :)
02:21:11 <mux_> dreixel: actually I'm having problems with two classes like that :-/ it looks I'll have to add DeepSeq instances for all primitive types by hand, defining deepseq to seq for those
02:21:41 <WarzoneCommand> now if I want to load Bar in with inf-haskell mode it complains that it can't find the new functionality of module Foo
02:22:21 <srhb> Lemmih: How about you, all sorted?
02:22:22 <Lemmih> srhb: I'd love to help out if you do go for Haskell.
02:22:25 <WarzoneCommand> so I'm guessing it still tries to use the module Foo as installed by version 0.1 of my library
02:22:36 <srhb> Lemmih: I'll remember to pester you if I get it my way. ;)
02:22:56 <WarzoneCommand> is there a way to tell inf-haskell to just use the module as found in the local source tree?
02:22:59 <Lemmih> srhb: We're going for Python/django. Java was the other option so I'm fairly happy.
02:23:10 <srhb> Lemmih: No kidding. The improvement there is huge. ;)
02:24:03 <Lemmih> srhb: Thought about applying for GSoC?
02:24:35 <dreixel> mux_: yes, all base types will need instances
02:24:37 <srhb> Lemmih: No! I don't feel that competent at all. :P
02:25:29 <hiptobecubic> I am confused type signatures. Say I have an Either Bool (IO String).  Is that different really from an IO (Either Bool String)? How?
02:25:53 <dreixel> mux_: using NFData would be nicer because then those are already defined.
02:25:57 <mux_> dreixel: with explicit deepseq = seq definitions each time
02:26:08 <shachaf> hiptobecubic: Yes, very.
02:26:10 <srhb> Lemmih: How about you?
02:26:17 <mux_> yes, but it's also less nice because NFData is supposed to include compound types
02:26:22 <mux_> and not just primitive ones
02:26:36 <shachaf> hiptobecubic: Do you understand how String is different from IO String?
02:26:44 <hiptobecubic> shachaf, yes absolutely.
02:27:20 <hiptobecubic> shachaf, let me present the actual problem i'm working with.
02:27:23 <dreixel> mux_: but for the types for which already there is an NFData instance (like lists) yo don't really need a generic one...
02:27:24 <shachaf> hiptobecubic: Well then. What are some possible values of the two types you mentioned?
02:27:56 <hiptobecubic> Right (IO "")   or   IO (Right "")  ?
02:28:13 * hackagebot fclabels 1.1.1.0 - First class accessor labels.  http://hackage.haskell.org/package/fclabels-1.1.1.0 (SebastiaanVisser)
02:28:24 <shachaf> hiptobecubic: IO isn't a (value) constructor,
02:28:45 <shachaf> hiptobecubic: Are you sure you're not working under some "IO is a wrapper" or "IO is a taint tag" misunderstanding?
02:29:11 <hiptobecubic> shachaf, well I didn't think so. Let me think about your question again.
02:30:21 <mux_> dreixel: right. I'm still not sure; I don't like having a dependency where I could do without one
02:30:21 <shachaf> hiptobecubic: (Many people tend to be so I may have jumped to a conclusion. :-) )
02:30:23 <hiptobecubic> shachaf, it could return a Right (some action producing a string) or a Left Bool in the first case or an action producing an Either Bool String  in the second
02:30:46 <shachaf> (Left Bool) makes about as much sense as (IO "")
02:31:01 <hiptobecubic> shachaf, sure, but i don't knwo what the bool is. Left True then.
02:31:19 <shachaf> You're confusing types and values, and while that has value informally sometimes, it's probably best to be clear in this case. :-)
02:31:27 <nand`> well, in reality, a value of type IO a is a function :: RealWorld -> (RealWorld, a)
02:31:30 <shachaf> Right.
02:31:35 <shachaf> nand`: No, that's completely false in reality.
02:31:49 <nand`> shachaf: but that's what the source tells me! http://hackage.haskell.org/packages/archive/ghc-prim/0.2.0.0/doc/html/src/GHC-Types.html#IO
02:31:52 <nand`> unless I am misreading something
02:32:07 <shachaf> You're probably misreading something.
02:32:19 <shachaf> And what you're talking about is an implementation detail of GHC anyway; we're talking about Haskell.
02:32:49 <tsousa> can someone explain to me this  (a -> Bool) -> [a] -> [a] i read from LYAH but i couldnt understand very well
02:33:14 <hiptobecubic> Is it not a computation that depends on the state of the universe and returns an "a" ?
02:33:21 <shachaf> hiptobecubic: Nope.
02:33:30 <shachaf> That's a flawed analogy.
02:33:32 <nand`> shachaf: what does the haskell specification say about IO? Just that it's a black box for an action that could be executed?
02:33:37 <hiptobecubic> shachaf, do you have a replacement?
02:33:59 <shachaf> A value of type "IO a" is some abstract action that, when "executed", yields a value of type "a".
02:34:05 <hiptobecubic> tsousa, (a -> Bool)   is a function that takes a "something" and returns a bool.
02:34:46 <hiptobecubic> shachaf, how is that different than a computation which depends on the state of the universe?
02:35:02 <tsousa> hiptobecubic, and then the [a] ->[a] the function get a function and a list and return a list? is that it?
02:35:35 <hiptobecubic> tsousa, in effect yes.
02:36:00 <hiptobecubic> tsousa, i think how it really works is the function takes a function... then returns a function that takes a list... which then returns a list.
02:36:19 <tsousa> hiptobecubic, ah? lol
02:36:23 <shachaf> hiptobecubic: How is it the same?
02:36:30 <donri> also "a" is any type, but the same type in each occurance
02:36:36 <tsousa> hiptobecubic, parcial applyed?
02:37:12 <hiptobecubic> tsousa, "currying"
02:37:32 <nand`> hiptobecubic: haskell doesn't necessitate the existence of a universe
02:37:38 <nand`> at least, IO doesn't
02:37:39 <tsousa> hiptobecubic, so what is the concept of parcial applyed?
02:37:58 <nand`> tsousa: it's “partial”, “partial application” and “partially applied”
02:38:33 <nand`> shachaf: so basically what I said in my question?
02:39:04 <shachaf> nand`: What?
02:39:37 <nand`> shachaf: “a black box for an action that could be executed”
02:40:35 <shachaf> If you like.
02:40:59 <mux_> dreixel: https://bitbucket.org/mumux/generic-deepseq/src/2951069b095d/Control/DeepSeq.hs -- not so horrible this way, what do you think?
02:41:50 <nand`> that's the way I tend to explain haskell's real world interaction: haskell programs themselves do nothing. They just define an action, that *could* be executed, if some joker were to come along and do that
02:42:15 <dreixel> mux_: yes, looks fine
02:42:28 <nand`> I also like to say that Haskell can't do IO. It can just represent IO
02:42:39 <mux_> dreixel: thanks again for your help
02:43:20 <LostPW> nand thats true ... the io concept is against the functional paradigma ....which says you can in every step change a term with his expression...
02:44:05 <mike-burns> shachaf: I am thinking of going to BayHac, and also the European one, but I need to figure out scheduling details since I'll be flying to Japan immediately after.
02:44:17 <mike-burns> s/and/or/
02:44:48 <hiptobecubic> shachaf, well what kind of action is not a computation that depends on the state of the universe?
02:46:01 <shachaf> mike-burns: Fortunately for you, either one of those is closer to Japan than Boston.
02:47:12 <mike-burns> shachaf: Unfortunately, I already bought the plane ticket.
02:47:25 <shachaf> From Boston? That's unfortunate indeed.
02:47:54 <mike-burns> So I'll need to try calling and cancelling, and I don't expect that to go well.
02:49:08 <shachaf> Well, I think you know where all the cool people are going to be on Apr 20-22.
02:49:11 <shachaf> (Not at BayHac, that's for sure! We have great weather here.)
02:49:26 <mike-burns> Hah!
02:50:06 <mike-burns> The European hackathon has the most appeal right now, since that's the part of the world I want to end up living in this year.
02:50:41 <dreixel> mux_: yw! I have to go now, but feel free to ask anytime you run into problems ;-)
02:50:51 <dreixel> what's the European one
02:50:54 <dreixel> the one in Utrecht?
02:50:58 <mike-burns> Yes.
02:51:01 <dreixel> ah, great
02:51:05 <dreixel> I'll be there (here)!
02:51:20 <mike-burns> Fantastic.
02:56:55 <aristid> mike-burns: where and when is the european hackathon?
02:57:12 <Feuerbach> aristid: http://www.haskell.org/haskellwiki/DHD_UHac
02:57:32 <aristid> hmm :)
03:00:09 <aristid> hmm, a train ticket there would be almost affordable
03:00:19 <koeien> from where do you have to come?
03:01:10 <aristid> me? i'd have to come from the south of germany
03:01:33 <koeien> ah. well if you book well in advance with DB it's not that bad, but i suppose you know that :)
03:01:42 <aristid> the true south, not dschoepe's "darmstadt is in the south"
03:01:56 <aristid> koeien: yeah they say there's a ticket in two directions for 118 euros
03:02:26 <Saizan> aristid: how many km?
03:02:40 <dschoepe> aristid: You're not going to let that go, are you? :)
03:02:49 <aristid> dschoepe: :D
03:02:59 <koeien> for me everything south of koeln is "south" ;)
03:03:09 <rekado> Hi there, does anyone use cabal install with jhc?
03:03:53 <rekado> The flag --with-compiler expects a version of GHC.
03:04:31 <hiptobecubic> It should be possible to have something of type IO ( IO (a))  right?
03:04:39 <koeien> hiptobecubic: sure
03:05:02 <koeien> this is an IO action that, when performed, does some I/O and returns an IO action
03:05:09 <Saizan> rekado: use --jhc too
03:05:12 <rekado> oh, never mind, there's a --jhc flag that I missed
03:05:13 <aristid> Saizan: 529 km
03:05:24 <rekado> Saizan: thanks, I just realised that :)
03:06:08 <koeien> hiptobecubic: it's generally written as IO (IO a)
03:06:45 <Saizan> aristid: sigh, i pay 106 for 300km
03:06:57 <Saizan> aristid: (Florence-Milan)
03:07:01 <hiptobecubic> koeien, ok.
03:07:06 <aristid> Saizan: that's even inside germany
03:07:09 <aristid> i mean italy
03:07:19 <aristid> Saizan: is that two-way? my price is two-way :)
03:07:31 <Saizan> aristid: yep, two-way
03:08:36 <Feuerbach> rekado: it probably will fail because of the version of 'base'
03:08:59 <aristid> Saizan: train from italy to utrecht would be even more expensive i guess:)
03:09:14 <rekado> Feuerbach: yes, it does fail. Says it requires ghc-prim.
03:09:35 <Saizan> aristid: yeah, that might be why it refuses to show me the price
03:09:40 <rekado> I'm trying to build a project that's built on top of WAI.
03:10:13 <nand`> is there a type of StateT which only has “put”?
03:10:20 <koeien> WriterT
03:10:33 <nand`> well, something like a WriterT that can only hold one “output” element at a time
03:11:12 <shachaf> What good would that do? You'll only ever see the last value.
03:11:25 <aristid> Saizan: so you'd have to fly if you wanted to go?
03:11:40 <koeien> Saizan: you could fly to Eindhoven if you want to same money
03:11:44 <nand`> shachaf: I want to generate a side effect at some point during a long computation
03:11:47 <hiptobecubic> Well I can't decide if this thing is an Either String (IO [String]) or an IO (Either String [String])
03:11:54 <nand`> either way, I'll use a WriterT and just look at the last element
03:12:00 <nand`> WriterT on a list*
03:12:22 <dschoepe> hiptobecubic: You need the latter if you need to perform IO to decide if you want to return a Left or a Right.
03:13:00 <koeien> Saizan: there are flights from Italy, not sure where, and if it's actually cheaper in the end.
03:14:07 <hiptobecubic> dschoepe, it doesn't... well it shouldn't.... I guess i need to rewrite this
03:14:13 <shachaf> nand`: You can probably define a monoid for the behavior you want.
03:15:00 <mux_> Last looks like it would fit to me
03:15:31 <mux_> @src Last
03:15:31 <lambdabot> Source not found.
03:15:34 <mux_> pft
03:16:05 <hiptobecubic> dschoepe, well actually..... It does IO and gets a list of file names, then checks them against a pattern. If the pattern is bad it returns Left "foo", else Right ["foos"].  It *could* check the pattern first i guess. If I rewrote some things. That would be more sensible, right?
03:16:49 <gmaslov> Let's say I have a class (Intersectable a b), with an associated type (Intersection a b) and a function (intersect :: a -> b -> Intersection a b). Is it possible to make Intersectable/Intersection/intersect symmetric, without UndecidableInstances or a bunch of extra boilerplate?
03:16:53 <hpaste> gmaslov pasted “Intersection a b <-> Intersection b a” at http://hpaste.org/63900
03:17:08 <dschoepe> hiptobecubic: Yeah, I'd so say. This way you keep IO confined to the place where you actually need it.
03:17:59 <nand`> shachaf: yeah, I can make Maybe a a monoid: Nothing is the identity element and (Just a) `mappend` (Just b) = Just b
03:18:03 <dschoepe> hiptobecubic: Something like f pattern | isBad pattern = Left bla\n f pattern f | otherwise = fmap Right doIOThings would also a readable way to do that.
03:18:08 <nand`> or does that break some monad laws?
03:18:13 <nand`> monoid*
03:18:17 <koeien> gmaslov: UndecidableInstances is not necessarily a bad idea.
03:18:17 * hackagebot roman-numerals 0.5.1.1 - Parsing and pretty printing of Roman numerals  http://hackage.haskell.org/package/roman-numerals-0.5.1.1 (RoelVanDijk)
03:18:32 <mux> nand`: as I said there's a Last monoid that does just that
03:18:35 <koeien> it depends if you mind whether the compiler terminates
03:18:35 <dschoepe> nand`: That's basically what Last does, I think.
03:18:43 <nand`> I see
03:18:44 <hiptobecubic> dschoepe, my old nemesis 'fmap'...
03:18:45 <nand`> I'll use Last then
03:19:13 <mux> @src Last mappend
03:19:14 <lambdabot> Source not found. This mission is too important for me to allow you to jeopardize it.
03:19:31 <dschoepe> hiptobecubic: liftM Right doIOThings would also work, or doIOThings >>= (\foo -> return (Right foo))
03:20:24 <hiptobecubic> What is the difference between fmap and liftM ?
03:20:41 <koeien> hiptobecubic: one is for Functor, the other for Monad. really, liftM shouldn't exist.
03:20:53 <koeien> hiptobecubic: it's there due to historical reasons
03:21:02 <hiptobecubic> Right. ok sure
03:21:10 <dschoepe> I just noticed that what I just said is wrong anyway, as that'd give you an IO (Either ...)
03:21:14 <koeien> (you can use it, of course.)
03:21:55 <gmaslov> koeien: well, I'm not really sure of what situations cause non-termination. just how smart is GHC when searching for an instance? If I say "Intersectable () [Int]", it'll check "Intersectable [Int] ()", but will it keep looping, or avoid checking the same thing twice?
03:22:41 <Saizan> koeien, aristid: ah yeah, much cheaper by flight
03:23:19 <koeien> Saizan: you can also go to Amsterdam, it's closer to utrecht, but flights are more expensive.
03:23:25 <mux> gmaslov: I don't think you can achieve what you want; I've had a similar problem with length-typed vectors, where I can't get GHC to understand that a + b = b + a (at the type level)
03:23:30 <koeien> Saizan: i suppose this will be added to the HUG wiki
03:24:05 <mux> gmaslov: I think your problem and this one amount to the same
03:24:20 <gmaslov> hmm, yes, I just got an error message informing me that I somehow need to assert (Intersect a b ~ Intersect b a) for all a and b. Don't think there's a statement for that sort of thing.
03:24:26 <gmaslov> "Lemma"? :)
03:24:40 <mux> soon in GHC 8 :-P
03:25:07 <aristid> koeien: do you expect that people at the european hac will be from all around europe?
03:25:11 <mux> maybe there's a clever way around this though, I guess Oleg would know
03:25:18 * mux bbl
03:25:53 <koeien> aristid: not sure. i don't know who's coming. the dutch hug meetings are generally quite diverse (in terms of nationality). our lingua franca is English
03:26:46 <hiptobecubic> koeien, how often are the hug meetings?
03:27:18 <koeien> hiptobecubic: around 10 times per year
03:28:06 <koeien> but i've not been in some time (at least a year)
03:28:13 <aristid> koeien: it might help that there are a lot of nations around the dutch border:)
03:28:21 <koeien> aristid: only two ;)
03:29:25 <aristid> koeien: germany and belgium? well you know what i mean tho :P
03:29:31 <ion> > ala Sum Data.Foldable.foldMap [0..1000000]
03:29:33 <lambdabot>   *Exception: stack overflow
03:29:55 <ion> > (foldl' (+) 0 [0..1000000], foldl (+) 0 [0..1000000])
03:29:56 <lambdabot>   (500000500000,*Exception: stack overflow
03:30:15 <ion> Why is Sum not strict?
03:33:03 <ion> > Data.Foldable.foldr' (mappend . Sum) mempty [0..1000000]
03:33:05 <lambdabot>   Sum {getSum = 500000500000}
03:33:32 <ion> I guess there should be a foldMap'
03:34:02 <ion> or something
03:42:40 <osa1> what are must-know typeclasses for a haskell programmer? monad, functor, applicative etc.
03:42:53 <donri> @where typeclassopedia
03:42:54 <lambdabot> http://www.haskell.org/haskellwiki/Typeclassopedia
03:46:44 <ion> RunComonadCofree
03:47:43 <nand`> Is there a typeclass for a value which has a “default”, or rather, a “failed” value?
03:48:03 <nand`> I can probably use Monoid and mempty for my purpose
03:48:17 <nand`> but I'm wondering if there's a more general class that doesn't require an associative append
03:48:19 <ion> empty, mzero, (mempty)
03:48:38 <koeien> Alternative, but it includes more
03:48:56 <nand`> yeah. Otherwise, is () a Monoid?
03:49:11 <ion> See :i Monoid in ghci. Or :i ()
03:49:18 <Feuerbach> http://hackage.haskell.org/package/data-default
03:49:35 <koeien> it is.
03:49:58 <koeien> it would be perverse if it weren't
03:50:08 <nand`> Feuerbach: that looks best, thanks
03:56:10 <osa1> what was the name of the function joining lists with some elements between parts?
03:56:41 <donri> intercalate?
03:56:46 <osa1> donri: yeah, thanks
03:56:50 <koeien> intersperse or intercalate
03:57:02 <donri> yea i never remember which of those is which
03:57:10 <koeien> i don't use intersperse much
04:00:00 <ChristianS> @type intercalate
04:00:01 <lambdabot> forall a. [a] -> [[a]] -> [a]
04:00:06 <ChristianS> @type intersperse
04:00:06 <lambdabot> forall a. a -> [a] -> [a]
04:01:12 <osa1> dude, I'm learning haskell for about a week now and I still can't write a simple stupid script. btw, I have experience with python, java, c, common lisp and clojure
04:02:46 <aristid> osa1: what's your simple stupid script supposed to do, just so i can see how simple it really is?
04:04:09 <hpaste> Abraxas pasted “canReachIn3” at http://hpaste.org/63903
04:04:46 <osa1> aristid: it's supposed to show a todo list, and manipulate it(like adding, removing, setting priority).
04:05:09 <MaskRay> writing scripts in haskell is clumsy
04:05:44 <osa1> MaskRay: why?
04:06:03 <vortexion> because it's not an imperative programming language
04:06:04 <Abraxas> can somebody help with the paste?
04:06:04 <MaskRay> some string processing task may benefit with eddie(http://eddie.googlecode.com/)
04:06:13 <Abraxas> question at the top
04:06:48 <Abraxas> it's the LYAH example with the knight's moves
04:06:49 <Algorith> scripting languages also dont tend to have strong static typing
04:07:11 <MaskRay> osa1: importing various module is tedious and function names are long
04:07:28 <Abraxas> rewriting canReachIn3 such that the possible moves from start to end are shown
04:08:05 <koeien> haskell is the world's best imperative programming language
04:08:19 <Abraxas> i did a list comprehension, so failure is just the empty list...i guess a Maybe would be in order
04:08:57 <Abraxas> but it's bad style to check the list for emptiness and then return a Nothing, right?
04:09:20 <osa1> anyone knows a datetime data type?
04:09:37 <ion> vortexion: Haskell is one of the more excellent imperative programming languages, thanks to IO actions being first class objects.
04:10:03 <donri> osa1: UTCTime
04:10:11 <donri> @hackage date
04:10:11 <osa1> donri: which package contains it?
04:10:11 <lambdabot> http://hackage.haskell.org/package/date
04:10:19 <osa1> thanks
04:10:26 <donri> @hackage time
04:10:26 <lambdabot> http://hackage.haskell.org/package/time
04:10:27 <osa1> donri: this link is 404
04:10:32 <donri> it's time :D
04:10:47 <osa1> yeah thanks
04:11:08 <koeien> Abraxas: what's wrong with failure = empty list
04:11:16 <vortexion> well okay, but it wouldn't be my first choice of imperative programming language
04:11:32 <koeien> Abraxas: it's supposed to show all possible routes from A to B. if there are no, then return the empty list.
04:11:39 <koeien> vortexion: mine would, barring contra-indications
04:11:49 <vortexion> it certainly seems better for imperative programming than ML
04:11:49 <MaskRay> many shell tasks need no abstraction
04:11:58 <Abraxas> that sounds boring
04:12:20 <MaskRay> ruby is more suitable for shell scripts
04:12:27 <vortexion> ruby is great
04:13:11 <donri> stop trolling
04:13:33 <Abraxas> that sounds like it's meant to include a Maybe: "As an exercise, you can change this function so that when you can reach one position from the other, it tells you which moves to take."
04:13:45 <koeien> ah
04:13:48 <koeien> listToMaybe then
04:14:00 <koeien> :t listToMaybe
04:14:01 <lambdabot> forall a. [a] -> Maybe a
04:14:51 <Abraxas> ok predefined, spoilers :D
04:15:02 <koeien> exercise: write it yourself
04:15:07 <Abraxas> so it's just turning the list result into a Maybe result
04:15:15 <koeien> no, only the first result
04:15:24 <Abraxas> i thought it might be possible to use some kind of return in a do immediately
04:15:25 <koeien> the head of the list, if it exists
04:15:35 <Abraxas> on Maybe monad
04:15:48 <Abraxas> but mixing list and Maybe monad seems to be trouble
04:15:58 <koeien> Abraxas: yes that's not possible *within the same do block*
04:16:06 <Abraxas> yeah
04:16:23 <koeien> (for good reasons, if you like i can delve in further.)
04:16:30 <koeien> dive*
04:17:08 <ion> I haven’t been following the discussion, but you can make MonadPlus m => m a values and ask for [a], Maybe a or, say, Logic a. :-)
04:17:09 <Abraxas> canReachIn3 start end = do {pos1 <- moveKnight start; pos2 <- moveKnight end; guard (pos2 `elem` moveKnight pos1) ...
04:17:13 <Abraxas> i can start like this
04:17:16 <Abraxas> but then what
04:17:24 <Abraxas> another do block?
04:17:34 <koeien> no, you can do
04:17:42 <koeien> listToMaybe $ do { pos1 <- moveKnight start; ...
04:17:53 <koeien> or
04:18:12 <koeien> do { (x:_) <- do { pos1 <- moveKnight start; ... }; return x }
04:19:04 <koeien> oh, I meant do { (x:_) <- return $ do { ... } }
04:19:07 <koeien> but as you can see that's uglier
04:19:24 <Abraxas> yes :D
04:19:37 <Abraxas> not sure what LYAH is getting at with that exercise
04:19:46 <Abraxas> it's probably just implementing listToMaybe
04:19:52 <koeien> yup
04:20:08 <koeien> and realizing which type you want. so [[KnightMove]] -> Maybe [KnightMove]
04:20:44 <koeien> (listToMaybe is a bit unfortunaly named imo. it should just be named 'head')
04:21:44 <Abraxas> but there is more than one combination of moves
04:21:46 <Abraxas> it's a list of lists
04:21:59 <koeien> yes, but the wording seemed to implicate that you can choose any order
04:23:52 <Abraxas> hm, i am getting yours wrong, it seems
04:24:13 <Abraxas> "Couldn't match expected type `()' with actual type `[t0]'" for the pattern (x:_)
04:24:44 <koeien> do { (x:_) <- return $ do { ... }; return x }
04:24:46 <koeien> this one?
04:24:53 <Abraxas> yes
04:24:58 <Abraxas> it should be tuples, though
04:25:18 <koeien> (x:_) matches a list containing one or more elements
04:25:24 <koeien> it's not a tuple
04:26:00 <Abraxas> yup
04:26:35 <Abraxas> did you see the program?
04:26:41 <koeien> no
04:26:53 <koeien> (not sure why you don't want to use listToMaybe though :) )
04:26:56 <Abraxas> http://hpaste.org/63903
04:27:08 <koeien> could you annotate it with what you have now?
04:27:09 <Abraxas> i just wanted to try your version
04:28:13 <Abraxas> what's the style with annotations, can i just put what you have written or edit the entire thing
04:28:34 <koeien> whatever you prefer
04:29:33 <hpaste> Abraxas annotated “canReachIn3” with “canReachIn3 (experiment)” at http://hpaste.org/63903#a63905
04:30:11 <koeien> Abraxas: you forgot the "return"
04:30:17 <koeien> (x:_) <- return $ do
04:30:30 <koeien> this example makes use of 'fail'
04:30:51 <koeien> if a pattern match in a do block fails, the result is fail "Pattern match failure"
04:30:57 <koeien> fail _ = Nothing for Maybe
04:31:57 <Abraxas> right
04:32:10 <Abraxas> "The last statement in a 'do' construct must be an expression: (x : _) <- return"
04:32:16 <koeien> yes, add return x
04:33:03 <Abraxas> forgot the $ now :D
04:33:08 <koeien> err, you should also add  [start,pos1,pos2,end] after line 6
04:33:20 <koeien> otherwise GHC will infer the wrong type (you'll see)
04:33:48 <Abraxas> canReachIn3 (6,2) (6,1)    it :: ()
04:33:56 <koeien> yup
04:34:11 <Abraxas> that's not it
04:34:18 <Abraxas> ah
04:34:24 <koeien> add canReachIn3 :: KnightPos -> KnightPos -> Maybe [KnightPos]
04:34:35 <koeien> and ghc will complain somewhere
04:35:46 <Abraxas> Couldn't match expected type `[KnightPos]' with actual type `()'
04:36:11 <koeien> yes!
04:36:18 <koeien> you forgot return [start,pos1,pos2,end]
04:36:21 <koeien> :t guard
04:36:22 <lambdabot> forall (m :: * -> *). (MonadPlus m) => Bool -> m ()
04:37:22 <hpaste> Abraxas annotated “canReachIn3” with “canReachIn3 (experiment) (annotation)” at http://hpaste.org/63903#a63906
04:37:44 <koeien> I think I forgot "return"
04:37:50 <koeien> return [start,pos1,pos2,end]
04:38:10 <Abraxas> yes
04:38:26 <Abraxas> i thought that was too many returns, but yes, works
04:38:47 <koeien> cool
04:38:48 <Abraxas> but without the return it would just be a >> equivalent
04:39:05 <koeien> without the return the type of it should have been [[KnightPos]]
04:39:10 <Abraxas> result of that was (6,2) then
04:39:23 <Abraxas> head :D
04:39:42 <koeien> ah yes, that's fairly useless
04:39:53 <Abraxas> probably by accident, not sure what happened there
04:39:53 <koeien> it's good practice to add type signatures to toplevel functions
04:40:18 <koeien> x became of type KnightPos instead of [KnightPos]
04:40:38 <Abraxas> usually do, but it was all wrong before
04:40:41 <koeien> since the innermost do-block now had type [KnightPos]
04:42:18 <Abraxas> canReachIn3 (6,2) (7,3)    Nothing
04:42:20 <Abraxas> ok
04:42:29 <Abraxas> so it's just the type declaration
04:43:10 <Abraxas> i think that's exactly what i was trying to do =)
04:43:24 <koeien> cool
04:43:26 <Abraxas> use this notation to get a Maybe
04:43:57 <Abraxas> it's all automatic because of the type inference and the Monad implementation
04:44:42 <Abraxas> thanks!
04:44:44 <koeien> using fail is considered harmful by some
04:44:52 <Abraxas> sorry for typing it wrong 100 times :D
04:45:14 <koeien> personally i don't mind it that much in code that is not polymorphic in the monad
04:45:19 <hpc> if you are going to use fail, you should generally restrict it to functions that aren't polymorphic in what monad they are in
04:45:54 <osa1> can anyone help me? what's wrong with this code? http://paste.pocoo.org/show/552973/
04:46:22 <hpc> osa1: today :: IO Day
04:46:25 <hpaste> Abraxas annotated “canReachIn3” with “canReachIn3 (experiment, working) (annotation) (annotation)” at http://hpaste.org/63903#a63907
04:46:59 <Abraxas> oh there was more annotations
04:47:01 <osa1> hpaste: thanks. is there a way to get just the Day part?
04:47:15 <dougransom> @pl imp0 = (ftc0 `implies` h0) e
04:47:15 <lambdabot> imp0 = (ftc0 `implies` h0) e
04:47:15 <hiptobecubic> I have a sinking feeling that Emacs handles haskell much better than Vim :(
04:47:16 <koeien> osa1: the same way you got the zoned time. use <-
04:47:20 <Abraxas> it just adds another (annotation) instead of keeping just one, ok
04:47:31 <koeien> hiptobecubic: me too. I use evil to have the familiar keybindings
04:47:44 <osa1> koeien: but I can return Day in this function, right? I have to use do block everytime I use today function?
04:47:51 <osa1> s/can/can't
04:47:51 <hiptobecubic> koeien, it brings a tear to my eye.
04:47:51 <koeien> osa1: correct.
04:48:14 <koeien> osa1: that's because 'today' is not a Day, it's an action that, when performed, returns the current day.
04:48:17 <osa1> koeien: so in haskell if I do some IO in a functions, every functions using it have to be IO
04:48:22 <koeien> yes
04:48:42 <osa1> wow, I just enlightened
04:48:43 <hpc> osa1: not "every function", but you will need to be in IO to execute today
04:48:43 <koeien> the separation between values and actions is strictly maintained
04:48:59 <koeien> your today is *not* a function.
04:48:59 <hpc> :t fmap :: (Day -> b) -> IO Day -> IO b
04:49:00 <lambdabot> Not in scope: type constructor or class `Day'
04:49:00 <lambdabot> Not in scope: type constructor or class `Day'
04:49:06 <koeien> it's an action that, when performed, returns the date.
04:49:13 <koeien> crucial distinction that most other languages don't make
04:49:56 <hpc> osa1: you can still use non-IO functions to manipulate your Day, but you don't take the Day out of IO
04:50:08 <hpc> osa1: you bring the functions into IO, using higher order functions like fmap
04:50:54 <koeien> for example, you could write dayAfter :: Day -> Day
04:51:10 <hpc> tomorrow = do
04:51:15 <hpc>   t <- today
04:51:20 <hpc>   return (dayAfter t)
04:51:36 <hpc> or
04:51:46 <benmachine> preflex: seen BONUS
04:51:46 <preflex>  BONUS was last seen on #haskell 293 days, 18 hours, 28 minutes and 30 seconds ago, saying: yeah i think that's better as well
04:51:48 <benmachine> eep
04:51:49 <hpc> tomorrow = dayAfter <$> today -- (<$>) = fmap
04:51:54 <benmachine> I hope he hasn't died
04:54:16 <hpc> preflex: xseen BONUS
04:54:16 <preflex>  BONUS was last seen on freenode/#haskell 293 days, 18 hours, 31 minutes and 1 second ago, saying: yeah i think that's better as well
04:54:22 <hpc> hmm
04:54:48 <ion> NickServ: Last seen  : Apr 18 22:07:22 2011 (43 weeks, 4 days, 15:51:21 ago)
04:56:15 <tsousa> the only function that the functor class has it fmap right?
04:56:51 <ion> See :i Functor in ghci.
04:58:51 <hpc> alternatively... yes
04:58:56 <hpc> it's the only function ;)
04:59:13 <benmachine> it's certainly the only important one
04:59:30 <hpc> :t ($>)
04:59:31 <lambdabot> Not in scope: `$>'
04:59:35 <benmachine> :t (<$)
04:59:36 <hpc> :t (<$)
04:59:36 <lambdabot> forall a (f :: * -> *) b. (Functor f) => a -> f b -> f a
04:59:37 <lambdabot> forall a (f :: * -> *) b. (Functor f) => a -> f b -> f a
04:59:39 <hpc> pah
04:59:41 <benmachine> :>
04:59:47 <benmachine> hmm
05:00:02 <benmachine> it would be neat if lambdabot prefixed the things she said with who they were for
05:00:12 <benmachine> oh well
05:00:25 <hpc> nah
05:01:23 <hpc> what lambdabot should do is get rid of the "this command only works in-channel" stuff
05:01:44 <hpc> and change it so lambdabot takes commands from anywhere and may or may not RESPOND in PM
05:02:36 <benmachine> yeees except very often I'm doing a command to show someone else
05:02:41 <benmachine> as part of an exposition
05:02:56 <benmachine> remember also that the channel is logged and can theoretically be informative to people in months or years time
05:03:09 <alpounet> or milleniums.
05:03:12 <hpc> benmachine: i mean, for stuff like @msg
05:03:26 <benmachine> oh right sure
05:03:27 * hackagebot smallcheck 0.6.1 - A property-based testing library  http://hackage.haskell.org/package/smallcheck-0.6.1 (RomanCheplyaka)
05:03:33 <hpc> ive seen people accidentally read some pretty private stuff in logged channels
05:03:35 <benmachine> alpounet: aeons
05:03:59 <tsousa> hpc, and what is the real porpose of having a Maybe?
05:04:14 <benmachine> what's the real porpoise of Maybe?
05:05:18 <hpc> tsousa: to confuse; it's a well-kept secret in #haskell that null pointer exceptions are actually the right way to do it
05:05:25 <hpc> :P
05:07:26 <dougransom> @pl aggregate_max f1 f2 f3 x  = f1 x `max` f2 x `max` f3 x
05:07:26 <lambdabot> aggregate_max = (liftM2 max .) . liftM2 max
05:08:54 <dougransom> @pl
05:08:54 <lambdabot> (line 1, column 1):
05:08:54 <dougransom> aggregate_max f1 f2 f3 f4 f4 x  = f1 x `max` f2 x `max` f3 x `max` f4 x `max` f5 x
05:08:54 <dougransom>  
05:08:54 <lambdabot> unexpected end of input
05:08:54 <lambdabot> expecting white space, "()", natural, identifier, lambda abstraction or expression
05:09:21 <dougransom>  aggregate_max f1 f2 f3 f4 f5 x  = f1 x `max` f2 x `max` f3 x `max` f4 x `max` f5 x
05:09:36 <dougransom> @pl aggregate_max f1 f2 f3 f4 f5 x  = f1 x `max` f2 x `max` f3 x `max` f4 x `max` f5 x
05:09:36 <lambdabot> aggregate_max = (((((liftM2 max .) . liftM2 max) .) . liftM2 max) .) . liftM2 max
05:10:26 <tsousa> hpc sorry i did not understand
05:12:54 <dougransom> @type max.sin
05:12:55 <lambdabot> forall a. (Ord a, Floating a) => a -> a -> a
05:13:55 <byorgey> dougransom: you can make it a lot nicer if you have f1 .. f5 in a list
05:14:00 <byorgey> they all have to be the same type anyway
05:14:21 <byorgey> aggregate_max fs x = maximum (map ($x) fs)
05:14:25 <Peaker> dougransom: maximum (sequence fs) x
05:14:43 <Peaker> oops
05:14:54 <Peaker> @type \fs x -> maximum $ sequence fs x
05:14:55 <lambdabot> forall a t. (Ord a, Monad ((->) t)) => [t -> a] -> t -> a
05:15:03 <byorgey> nice
05:15:24 <byorgey> I think mine is more readable but Peaker gets style points for using the ((->) e) monad =)
05:15:28 <Peaker> ;-)
05:15:34 <benmachine> so I want to read lines from a file and then sort them, should I read them into a list or a Data.Sequence.Seq?
05:16:00 <dougransom> byorey - excellent, I was trying to figure out how to construct such a map.
05:16:19 <ChristianS> benmachine: sort only works as lists, as far as i know
05:16:26 <benmachine> ChristianS: Data.Sequence.Seq has a sort
05:16:31 <Peaker> benmachine: probably list, not much to gain from Seq's properties here?
05:16:46 <benmachine> Peaker: fair enough.
05:16:49 <byorgey> yeah, sorting a Seq is not any faster than sorting a list.
05:16:52 <benmachine> I'd benchmark it but I don't care that much :P
05:17:00 <dougransom> @pl aggregate_max  maximum (map ($x) fs)
05:17:01 <lambdabot> aggregate_max maximum (map ($ x) fs)
05:17:35 <gmaslov> what about reading it into a Set, then using toAscList? if there are no duplicate lines
05:17:48 <ion> \fs -> maximum . sequence fs
05:18:20 <benmachine> gmaslov: interesting.
05:18:31 * benmachine totally prematurely optimising here
05:18:47 <ion> @type \fs x -> maximum (fs <*> pure x)
05:18:47 <benmachine> am I alone in thinking it would be nice for containers to have a multiset
05:18:48 <lambdabot> forall a a1. (Ord a1) => [a -> a1] -> a -> a1
05:19:46 * koeien thought Data.List.sort was O(n log n)
05:19:56 <koeien> so asymptotically you're not going to benefit from the Set trick
05:20:05 <dougransom> peaker:thanks too,  playing with
05:21:55 <Peaker> benmachine: probably better to sort an array using some optimized sort routine than either linked list or set
05:22:31 <byorgey> benmachine: no, multiset would be nice
05:22:36 <benmachine> Peaker: my performance needs aren't *that* great
05:23:09 * benmachine notes that there is in fact a multiset library on hackage
05:24:56 <Peaker> a multiset is basically a Map k Int using unionWith (+)   (or TMap with the Sum Monoid)
05:25:34 <benmachine> mm
05:25:37 <benmachine> sure
05:25:40 <benmachine> it's not hard to replicate one
05:25:44 <benmachine> but I shouldn't have to :P
05:26:14 <dougransom> @pl aggregate_max f x = maximum (map ($ x) f)
05:26:14 <lambdabot> aggregate_max = (maximum .) . flip (map . flip id)
05:27:07 <ion> TMap, huh? I hadn’t noticed it.
05:35:50 <dougransom> @pl let f x = maximum ([sin,cos] <*> pure x)
05:35:50 <lambdabot> (line 1, column 41):
05:35:50 <lambdabot> unexpected end of input
05:35:50 <lambdabot> expecting variable, "(", operator, ";" or "in"
05:37:07 <dougransom> @pl f2 fs x = maximum (fs <*> pure x)
05:37:07 <lambdabot> f2 = (maximum .) . (. pure) . (<*>)
05:43:13 <mux> dreixel: I think we need Generic instances for a few base data-types whose constructors are not exported, otherwise we can't use those with GHC.Generics -- for instance Ratio a from Data.Ratio
05:45:05 <akosch> is there a guideline on how to name your modules and where to put them, or everyone just does what they think reasonable?
05:45:47 <osa1_> is haskell(ghc, ghci, etc) completely written in haskell(bootstrapped)?
05:45:48 <hpc> there's a logic to how modules are organized, but it isn't really documented
05:46:04 <hpc> osa1_: yes, mostly; i think the RTS is written in C
05:46:21 <akosch> hpc: what would you recommend looking at for "inspiration"? :)
05:46:51 <osa1_> ok. I was wondering how `do` block is implemented. it looks like a different language
05:46:58 <ChristianS> akosch: http://www.haskell.org/haskellwiki/Hierarchical_module_names -- try fitting your modules somewhere in a hierarchy
05:47:24 <ChristianS> and try finding names that aren't yet used by some other package
05:48:24 <byorgey> osa1_: do blocks are just syntax sugar.  They get translated into uses of (>>=), (>>), and return
05:48:25 <akosch> ChristianS: thanks, but where would you put application logic for example (I mean on the top-level)?
05:49:30 <dougransom> @type (maximum .)
05:49:31 <lambdabot> forall a (f :: * -> *). (Ord a, Functor f) => f [a] -> f a
05:49:35 <byorgey> osa1_: http://www.haskell.org/onlinereport/haskell2010/haskellch3.html#x8-470003.14
05:49:38 <akosch> ChristianS: these are more for libraries
05:49:58 <benmachine> akosch: if it helps, I wrote this http://bm380.user.srcf.net/machine/haskell/overqualified-modules because I thought everyone else was doing it wrong
05:50:02 <hpc> @undo do {a <- b; c b; d b}
05:50:03 <lambdabot> b >>= \ a -> c b >> d b
05:50:31 <benmachine> akosch: but again, it's more about libraries
05:50:44 <benmachine> I'd say in applications you do whatever makes it easy to find stuff
05:50:53 <akosch> benmachine: thanks, I'll check it out
05:51:09 <benmachine> akosch: the view expressed in that link may not be widely-held among haskellers :P
05:51:14 <benmachine> it's just what I think
05:51:32 <akosch> benmachine: I will keep that in mind :)
05:51:43 <dougransom> @type sin .
05:51:44 <lambdabot> parse error (possibly incorrect indentation)
05:51:50 <dougransom> @type (sin .)
05:51:51 <lambdabot> forall a (f :: * -> *). (Floating a, Functor f) => f a -> f a
05:52:06 <ion> @type (sin Prelude.._
05:52:07 <lambdabot> parse error (possibly incorrect indentation)
05:52:07 <hpc> benmachine: i like that post
05:52:08 <ion> @type (sin Prelude..)
05:52:09 <lambdabot> forall b a. (Floating b) => (a -> b) -> a -> b
05:52:22 <benmachine> hpc: :) thanks
05:52:30 <benmachine> I keep meaning to make a comment thingy for it
05:52:36 <benmachine> but I wrote one with a security hole in it
05:52:46 <benmachine> and so duly humbled I left it alone for a bit
05:52:52 <hpc> benmachine: personally, i like having the distinction between Control and Data
05:53:00 <hpc> but i do agree that the current separation was poorly thought out
05:53:00 <kk> @unmtl
05:53:00 <lambdabot> Plugin `unmtl' failed with: Parse error
05:53:14 <benmachine> hpc: I don't really know what that distinction is though
05:53:31 <Guest14867> @unmtl MaybeT (State s)
05:53:32 <lambdabot> Plugin `unmtl' failed with: `MaybeT (State s)' is not applied to enough arguments, giving `/\A. s -> (Maybe A, s)'
05:53:40 <benmachine> and anyway, I'd argue that if you want to put insights into how to use monads somewhere
05:53:45 <benmachine> put them in the docs, not in the module name :P
05:53:56 <Guest14867> @unmtl MaybeT (State s) a
05:53:56 <lambdabot> s -> (Maybe a, s)
05:54:10 <Guest14867> @unmtl StateT s(Maybe a)
05:54:11 <lambdabot> Plugin `unmtl' failed with: `StateT s (Maybe a)' is not applied to enough arguments, giving `/\A. s -> Maybe a (A, s)'
05:54:17 <Guest14867> @unmtl StateT s (Maybe a)
05:54:17 <lambdabot> Plugin `unmtl' failed with: `StateT s (Maybe a)' is not applied to enough arguments, giving `/\A. s -> Maybe a (A, s)'
05:54:19 <gmaslov> i thought the big idea with functional programming is that Control is Data ;-)
05:54:22 <Guest14867> @unmtl StateT (Maybe a) s
05:54:23 <lambdabot> Plugin `unmtl' failed with: `StateT (Maybe a) s' is not applied to enough arguments, giving `/\A. Maybe a -> s (A, Maybe a)'
05:54:29 <byorgey> @unmtl StateT s Maybe a
05:54:29 <lambdabot> s -> Maybe (a, s)
05:54:30 <ion> It works in private, too.
05:54:36 <Guest14867> @unmtl StateT s Maybe a
05:54:36 <lambdabot> s -> Maybe (a, s)
05:55:13 <hpc> can we make @unmtl not fail when you don't finish applying types, and return the big Λ expression?
05:55:16 <byorgey> with StateT s Maybe, the state gets thrown away when it fails.  With  MaybeT (State s), it doesn't.
05:55:44 <benmachine> hpc: in theory yes, but this means modifying lambdabot
05:55:51 <benmachine> and can of worms etc.
05:56:16 <benmachine> lb is not exactly a stellar example of haskell code, is my impression :P
05:56:31 <rwbarton> just read "Plugin `unmtl' failed with: `StateT (Maybe a) s' is not applied to enough arguments, giving" as "Success! Your answer is:"
05:57:29 <hpc> im tempted now to do a massive refactor of lambdabot and submit it to whoever runs the hackage package
05:57:40 <benmachine> hpc: oh, do
05:57:55 <benmachine> I imagine your enthusiasm *may* diminish after looking at the code
05:58:01 <hpc> ive seen the code
05:58:05 <benmachine> oh fair enough
05:58:06 <hpc> it's terrifying
05:58:14 <hpc> but all the more reason to refactor
05:58:23 <benmachine> the maintainer is down as Cale
05:58:30 <hpc> plus, i have almost no open-source coding experience
05:58:46 <ion> How about just a small, clean IRC interface to mueval to which other functionality could be added over time? :-)
05:58:58 <hpc> ion: i actually have that, in perl
05:59:01 <hpc> on another network
05:59:17 <benmachine> ion: I imagine that's what lambdabot used to be? :P
06:08:43 <louzer> Can anyone help me with, Fluffy - furry - Exercise 3
06:08:46 <hpaste> louzer pasted “Fluffy - furry - Exercise 3” at http://hpaste.org/63910
06:09:12 <louzer> I am trying to write furry :: (a -> b) -> (t -> a) -> (t -> b)
06:09:24 <osa1_> do I have to use mapM when I'm mapping with a function with side effects and no useful return value or do we have a map function for side effects?
06:09:36 <osa1_> like dolist in lisp
06:10:43 <ChristianS> osa1_: if you have no useful return value, you probably want mapM_
06:12:46 <ion> louzer: In “(a -> b) -> (t -> a) -> t -> b” you get “(a -> b)”, “(t -> a)” and “t” and you’re supposed to produce a “b”. Can you see a way to do that?
06:12:51 <Abraxas> koeien, are you still there?
06:13:51 <dougransom> @pl maximum
06:13:51 <lambdabot> maximum
06:13:57 <dougransom> @type maximum
06:13:57 <louzer> ion: yes. if f :: (a -> b) and g :: (t -> a) then (f . g) is of type b
06:13:58 <lambdabot> forall a. (Ord a) => [a] -> a
06:14:19 <dougransom> @type maximum .
06:14:20 <lambdabot> parse error (possibly incorrect indentation)
06:14:22 <hpaste> Abraxas annotated “canReachIn3” with “canReachIn3 (something like this)” at http://hpaste.org/63903#a63911
06:14:26 <dougransom> @type (maximum .)
06:14:27 <lambdabot> forall a (f :: * -> *). (Ord a, Functor f) => f [a] -> f a
06:14:46 <otters> @pl \a b c d -> b
06:14:47 <lambdabot> const (const . const)
06:15:39 <Abraxas> the version in my recent annotation of the paste...can this be written in do, without a case?
06:16:46 <Abraxas> i was just practicing to convert monad notation to do-notation and specifically list monads in list comprehension
06:17:40 <Abraxas> turned out listToMaybe returns only the head of the list
06:18:13 <louzer> ion: are you there? if f :: (a -> b) and g :: (t -> a) then (f .g) is of type b
06:19:09 <ion> @type let f :: (a -> b); f = undefined; g :: (t -> a); g = undefined in f . g
06:19:10 <lambdabot> forall b t. t -> b
06:20:12 <ion> It’s t -> b, but you’re right: that’s the correct implementation of your function.
06:22:32 <Abraxas> if i replace (x:_) with x and change the result type to Maybe [[KnightPos]], i still get Just[] instead of Nothing, that's the problem
06:23:02 <Abraxas> in the second-to-last version of http://hpaste.org/63903
06:23:28 <Abraxas> i keep thinking the last version could be written more elegantly
06:24:21 <louzer> ion: haha, thanks. i was thinking i need to convert the output to t b. lol over looked the fact that i just needed to come up with (t -> b).
07:02:44 <mux> can I escape '{' and '}' characters to use them in a .cabal file?
07:05:11 <dcoutts> mux: sadly not
07:05:31 <mux> dcoutts: too bad! thanks
07:05:48 * dcoutts notes he's been rewriting the parser to make it less ad-hoc
07:06:05 <dcoutts> with a lexer and grammar! shock horror!
07:06:24 <byorgey> =O
07:06:53 <hpaste> srhb pasted “Strechted mandelbrot” at http://hpaste.org/63912
07:06:54 * byorgey notes that mux did not specify whether the resulting .cabal file should be valid
07:07:05 <dcoutts> byorgey: heh
07:07:19 <byorgey> @faq can I use '{' and '}' in an invalid .cabal file?
07:07:19 <lambdabot> The answer is: Yes! Haskell can do that.
07:07:26 <srhb> Can anyone see how I managed to stretch that mandelbrot fractal? It's "higher" than it ought to be proportionally.
07:07:48 <srhb> And excuse the ludicrous fromIntegral usage, I'll fix that soon.
07:08:19 <mux> byorgey: heh, indeed
07:08:54 <byorgey> srhb: what are scaleReal and scaleImag for?
07:09:37 <srhb> byorgey: Scaling the x and y pixel coordinates to the interval in which I can determine if the point is in the mandelbrot set or not
07:10:08 <byorgey> but wouldn't that cause the resulting image to be distorted?
07:10:17 <byorgey> (since they don't use the same factor)
07:10:25 <srhb> byorgey: ... er.. yes. I think.
07:11:15 * srhb ought to have a 'duh' moment, but is too scared.
07:12:38 <srhb> Thanks!
07:12:53 <byorgey> scared?
07:13:13 <cmccann> hm, this seems like an excellent morning to hack on hackage
07:13:49 <ion> A.k.a. hackage on hackage
07:13:51 <byorgey> oh man, I really want type wildcards right now
07:13:52 <srhb> byorgey: It took me a moment to reach the "OF COURSE!" stage. But yes, you are absolutely right, of course. I need to put my head in a bucket of cold water I think. :-)
07:14:07 <cmccann> ion, quite so
07:14:10 <byorgey> srhb: heh, cold water is probably overkill, lukewarm water should do ;-)
07:14:20 <srhb> byorgey: I'll take that advice. :-)
07:14:40 <Rc43> Hi, guys.
07:15:12 <byorgey> hi Rc43
07:15:39 <Rc43> Can I compare references by content? For examle `do; x <- newIORef 1; y <- newIORef 2; print $ x == y` should be `true`.
07:15:50 <Rc43> I can do it by wrapping references into IORef again.
07:16:03 <Rc43> But it is not very pretty.
07:17:02 <dmwit> liftM2 (==) (readIORef x) (readIORef y) >>= print
07:17:08 <dmwit> but, uh...
07:17:11 <luite> you can't implement the regular == since it requires a type of Bool, not IO Bool
07:17:15 <dmwit> shoud that really be True?
07:17:20 <dmwit> 1 /= 2, remember =P
07:17:34 <byorgey> dmwit: IORefs are magical
07:17:37 <fryguybob> > let 1 == 2 = True in 1 == 2
07:17:38 <luite> hehe
07:17:38 <lambdabot>   True
07:17:56 <dmwit> :t on
07:17:57 <lambdabot> forall b c a. (b -> b -> c) -> (a -> b) -> a -> a -> c
07:18:01 <Rc43> lol
07:18:17 <dmwit> :t on (liftM2 (==)) readIORef
07:18:18 <lambdabot> Not in scope: `readIORef'
07:18:27 <dmwit> :t on (liftM2 (==)) Data.IORef.readIORef
07:18:28 <lambdabot> forall a1. (Eq a1) => GHC.IORef.IORef a1 -> GHC.IORef.IORef a1 -> IO Bool
07:18:36 <Rc43> dmwit, it needs to implement Eq for the content.
07:18:44 <dmwit> Rc43: And it does!
07:19:00 <dmwit> See the (Eq a1) constraint?
07:19:03 <Rc43> dmwit, and it will compare content, but if I have huge structures I can't traverse them
07:19:29 <ion> instance Eq a => Eq (IO a) where (==) = (==) `on` unsafePerformIO
07:19:29 <byorgey> comparing contents of IORefs *must* be in the IO monad.  So (==) cannot possibly be used. (as luite already pointed out)
07:19:37 <dmwit> If you have IORefs within IORefs, you will have to write the recursion yourself.
07:19:52 <dmwit> Rc43: You could plausibly implement a class for equality that does IO.
07:20:07 <chrisdone> so what's the word on hackage2?
07:20:08 <preflex>  chrisdone: you have 1 new message. '/msg preflex messages' to read it.
07:20:11 <dmwit> class IOEq a where eqRightNow :: a -> a -> IO Bool
07:20:25 <Rc43> byorgey, I will be satisfied by doing it in IO at least.
07:20:49 <nand`> > Map.fromList [(1,True), (1,False)]
07:20:50 <lambdabot>   Not in scope: `Map.fromList'
07:21:02 <dmwit> instance IOEq a => IOEq (IORef a) where eqRightNow = liftM2 eqRightNow `on` readIORef
07:21:13 <chrisdone> who currently maintains hackage?
07:21:19 <Rc43> dmwit, where is recursion? Just compare content of notequal refs for equality, but it needs to use special write functions.
07:21:59 <dmwit> instance Eq a => IOEq (Identity a) where eqRightNow = (return .) . (==) `on` runIdentity
07:22:12 <byorgey> chrisdone: Ross Paterson maintains the curent version, but is eager to stop
07:22:15 <dmwit> -- morally, instance Eq a => IOEq a, but that instance causes more trouble than it's worth
07:22:37 <dmwit> Rc43: If you have a large structure, you must traverse it. If that structure is recursive (through IORefs), then you must use recursion to traverse it. That's all I meant.
07:23:04 <byorgey> chrisdone: several people including cmccann, dcoutts, bgamari, and possibly others currently seem to be working hard on Hackage 2
07:23:16 <chrisdone> byorgey: ah, ok. i want to suggest to him to put information about hackage2 on hackage. because currently i'm looking at hackage, i'm an average haskeller with some spare time, and i want improvements on hackage, but i don't know where to look other than coming in here and hoping someone knows
07:23:22 <Rc43> dmwit, but I know that I written two structures in several cells, it is silly to traverse them, I just want to compare pointers
07:23:37 <dcoutts> chrisdone: it's all there on the hackage wiki
07:23:56 <dmwit> Rc43: I've suggested a Haskell idiom for structuring this code. What more do you want?
07:23:57 * chrisdone googles hackage wiki
07:24:04 <cmccann> chrisdone, also: http://hackage2.uptoisomorphism.net/
07:24:24 <nand`> > map (second (+1)) [(0,0), (1,1)]
07:24:25 <lambdabot>   [(0,1),(1,2)]
07:24:25 <Rc43> dmwit, just asked if there is any other possibility
07:24:36 <cmccann> chrisdone, if you use git see https://github.com/isomorphism/hackage2 and if you use darcs look at the link in the git repo description
07:24:40 <byorgey> cmccann: is that a complete mirror now?
07:24:44 <Rc43> dmwit, speed is critical for me, I am writing contest
07:24:49 <Peaker> > (map . second) (+1) [(0,0), (1,1)]
07:24:51 <lambdabot>   [(0,1),(1,2)]
07:24:55 <cmccann> byorgey, complete index, no tarballs or builds yet
07:25:01 <cmccann> byorgey, but revdeps and such work
07:25:01 <byorgey> cool
07:25:06 <dmwit> Rc43: What is wrong with this possibility?
07:25:12 <cmccann> byorgey, and still running on an EC2 micro instance :D
07:25:19 <byorgey> hehe
07:25:47 * chrisdone clones the git repo 
07:25:51 <Rc43> dmwit, you suggest to compare two trees by every value in them? So 10k nodes with other 10k nodes?
07:26:05 <dcoutts> byorgey: http://hackage.factisresearch.com/ is a complete live mirror
07:26:21 <byorgey> dcoutts: ah, sweet
07:26:22 <Rc43> dmwit, it is possible to compare by other ref, but it needs to use other write functions and it isn't pretty
07:26:42 <byorgey> Rc43: how else would you compare two trees?
07:26:56 <dmwit> Rc43: So, you want to compare two trees without looking at the trees?
07:27:03 <dmwit> That doesn't really sound plausible to me.
07:27:04 <Rc43> byorgey, pointer
07:27:14 <dmwit> You can use pointer equality as a fastpath.
07:27:17 <dmwit> IORef's implement Eq.
07:27:29 <Rc43> dmwit, it is single way to compare with O(1) as i know
07:27:50 <Rc43> IORef's implement Eq by not its content
07:27:54 <dmwit> Right.
07:28:01 <dmwit> "by content" is not pointer equality.
07:28:04 <chrisdone> dcoutts: cmccann: is there a recommended GHC version to use?
07:28:22 <dmwit> So you use IORef equality first, and if it says they're not equal, you use content equality as the slow path.
07:28:22 <cmccann> I'm using 7.4
07:28:24 <dcoutts> chrisdone: to build the server? 7.0 probably easiest
07:28:36 <chrisdone> okies
07:28:37 <cmccann> I've also built it with 7.0
07:28:38 <byorgey> traverse the trees, when you come to IORefs try comparing them by pointer; if they are unequal then you have to actually look at their contents and recurse
07:28:50 <byorgey> oh, what dmwit already said.
07:29:04 <Rc43> dmwit, there is unsafePerformIO for example, may be there is any other unsafe function returning real memory address of IORef's content
07:29:29 <ion> Speaking of 7.4.1, it seems all the stuff i want except for trifecta installed with --solver=modular --avoid-reinstalls. :-P
07:29:31 <dmwit> Ah, you want pointer equality on non-IORefs?
07:29:33 <dmwit> This is possible, yes.
07:29:40 <cmccann> chrisdone, note that pushing upstream is on hold pending me figuring out how on earth to do it
07:29:53 <Rc43> dmwit, this will satisfy me, too
07:30:04 <cmccann> so right now my git repo has some changes that dcoutts's darcs doesn't, mostly some performance improvements in a branch
07:30:05 <byorgey> ion: oh, nice.  I didn't know about those flags.
07:30:30 <dmwit> Rc43: http://www.haskell.org/ghc/docs/7.0.2/html/libraries/base-4.3.1.0/System-Mem-StableName.html
07:30:50 <dmwit> Rc43: Beware! Pointer equality is *not* a good implementation of Eq!
07:30:53 <ion> I added --upgrade-dependencies at some point, too, but i think i was just testing it and it didn’t help with getting anything installed.
07:30:57 <Rc43> dmwit, cool, thanks
07:31:11 <dmwit> Rc43: Because it terminates "too fast" for infinite loops compared to the Eq specification.
07:31:41 <dougransom> @pl fuzzyNot f = ((-) (fromIntegral 1) ) . f
07:31:41 <lambdabot> fuzzyNot = ((-) (fromIntegral 1) .)
07:31:51 <Rc43> dmwit, what the loops?
07:32:54 <dmwit> Rc43: For example, [1..] == [1..] never terminates (and shouldn't!), but let x = [1..] in do { s1 <- mkStableName x; s2 <- mkStableName; return (s1 == s2) } will terminate every time.
07:33:16 <Rc43> dmwit, understood
07:33:32 <hpc> pointer equality isn't always accurate either
07:34:05 <ion> fuzzyNot f = (1 -) . f
07:34:05 <hpc> equal values can easily be stored in different places
07:34:12 <ion> (dougransom)
07:39:44 <chrisdone> cmccann: how on earth to push with darcs?
07:39:59 <cmccann> chrisdone, how to push changes from git to darcs
07:40:57 <cmccann> note that I've managed to get changes pulled from darcs into git
07:40:59 <chrisdone> cmccann: mmkay. are the tickets on the track used by you guys? i don't see any tickets assigned to you two. should i use github for my work? we have the haskell organization on github https://github.com/haskell we could put the git hackage on there? :o just have to be in the organization and we can push
07:41:05 <byorgey> only way I know of to push changes from git to darcs is the good old-fashioned way, using patch
07:41:28 <cmccann> byorgey, well, there's darcs-fastconvert or whatever it's called
07:41:30 <chrisdone> cmccann: hm, ok. that's alright i guess. you can still rebase and merge in a normal workflow
07:41:56 <cmccann> chrisdone, the trac was dead for a while and I don't think I have an account yet
07:42:00 <byorgey> cmccann: darcs-fastconvert is old and probably shouldn't be used.  darcs-bridge (the successor to darcs-fastconvert) doesn't work for git->darcs currently
07:42:04 <cmccann> dcoutts revived it but I've been busy lately
07:42:18 <cmccann> byorgey, well, darcs-fastconvert is how I got stuff from darcs to git
07:42:19 <byorgey> cmccann: that's why I made my statement above.
07:42:26 <byorgey> cmccann: yes, it works for darcs->git
07:42:34 <byorgey> but the other direction has bugs
07:42:35 <cmccann> but yeah, I have no idea how to go about it
07:42:41 <cmccann> thus why I'm putting off pushing upstream
07:43:03 <mux> if I require at least some version of ghc, should I just use a dependency on the ghc package even if I'm not using it?
07:43:16 <cmccann> chrisdone, also, this is all semi-unofficial at this point I suppose
07:43:17 <scrutr> are there any good gui toolkits for haskell? (wrong place to ask this?)
07:43:30 <mike-burns> scrutr: No idea, but there is gtk2hs.
07:43:33 <scrutr> (hi btw)
07:43:38 <byorgey> cmccann: I know how to do it (in theory), let me know if/when you want help walking through the procedure
07:43:39 <chairdog_> run in a browser
07:43:51 <chairdog_> then your question can be converted to: are there any good html toolkits?
07:43:52 <cmccann> chrisdone, but most of the current activity has been from me and elliott, and my github repo is the current central point I guess
07:44:14 <chrisdone> mmkay
07:44:44 <Rc43> Hm, which difference between System.Mem.StableName and Data.Unique ?
07:45:44 <cmccann> byorgey, that sorta depends on what dcoutts to do as well, since he's the only darcs user hacking on this at the moment
07:45:44 <osa1_> how are you managing global state in your haskell programs? for example, I'm writing a TODO app and I have to modify a TODO list based on users actions(like adding/removing todo items) but I have no idea how can I do that
07:46:00 <scrutr> chairdog_: out of curiosity, how can Haskell be run in a browser? I always assumed that was javascript's domain
07:46:05 <dmwit> Rc43: Data.Unique is for generating IDs that your program must manage. StableName is for inspecting IDs that GHC already has and is managing for you.
07:46:40 <cmccann> byorgey, if more darcs users decide to pitch in that might force the issue though
07:46:57 <dmwit> scrutr: I like gtk2hs a lot. As for browsers, the usual approach is to write a program that runs on the server (as with PHP, python, or ruby).
07:47:03 <chairdog_> scrutr: what i meant was in a web server, with browser as client.
07:47:08 <chairdog_> scrutr: sorry for not being clear
07:47:16 <chrisdone> scrutr: this is written in haskell and runs in the browser: http://chrisdone.com/ji/chat/
07:47:30 <cmccann> osa1_, that depends on the program itself somewhat
07:47:36 <chairdog_> scrutr: i've found it nice for hacking up quick UIs for some stuff I've done
07:47:54 <Rc43> dmwit, StableNames for one value will be the same even in different programs, rigth?
07:48:19 <Rc43> dmwit, so they are real hash, but not just unique values
07:48:48 <cmccann> osa1_, but in many cases you can either manually pass around the state, use StateT to hold the state, or use ReaderT to hold some IORefs or the like
07:49:50 <cmccann> osa1_, I have a couple examples I could show you--they're not the best code in general, but they do demonstrate updating global state based on user interaction
07:50:01 <chrisdone> cmccann: are you a debian-based system?
07:50:04 <osa1_> cmccann: it would be really great, thanks
07:50:16 <osa1_> cmccann: I'm new at haskell and I don't know StateT, ReaderT etc.
07:50:17 <reltuk> If I'm changing a program that's meant to be very long running, what's the best way to verify that I haven't introduced any heap growth over time?
07:50:20 <cmccann> chrisdone, I'm on ubuntu, why?
07:50:50 <cmccann> osa1_, https://gist.github.com/1494865/a04ad443c1ef3bc4714196327901c1da2d27f94c
07:50:55 <cmccann> and https://github.com/isomorphism/lazy-tetrominoes
07:51:28 <cmccann> note that neither of those use StateT or ReaderT
07:51:40 <chrisdone> cmccann: excellent, me too. just checking
07:52:11 <cmccann> but if you notice some of the repetitive nature in how the state is handled in those, abstracting that out is the motivation for the other approaches
07:52:12 <osa1_> cmccann: I think this is better since I don't know what a monad is now :)
07:52:42 <cmccann> the gist is much better code for learning from
07:53:04 <chrisdone> hackage2 builds fine ☺
07:53:30 <cmccann> as well it should
07:53:40 <cmccann> note that you might want to use the branch in my repo
07:53:45 * chrisdone opens gitg so he can make snide remarks about the state of the git history
07:53:48 <cmccann> if you want it to run with less than 5TB of RAM
07:54:05 <chrisdone> cmccann: why 5TB of RAM? o_o
07:54:26 <mike-burns> You finished killing off String?
07:54:42 <cmccann> chrisdone, strings
07:54:44 <cmccann> strings everywhere
07:54:49 <chrisdone> haha
07:54:54 <chrisdone> strings in your hair, strings in your bed!
07:54:55 <cmccann> strings as far as the eye can see
07:55:00 <cmccann> but yeah
07:55:12 <cmccann> it inherited some data structures from Cabal that are fine for builds
07:55:18 <chrisdone> well i only have master branch here so presumably that's ok
07:55:26 <cmccann> but not so great when you want every package description in memory at once
07:55:34 <chrisdone> right. ah, yeah, the acid-state thing
07:55:53 <cmccann> chrisdone, master branch will be memory hungry, the String-genocide branch is what I was working on
07:56:19 <cmccann> mike-burns, and yes, I replaced most of Cabal's data types with String-less equivalents
07:56:19 <chrisdone> cmccann: is it ready for pushing to github?
07:56:37 <cmccann> mike-burns, see http://hackage2.uptoisomorphism.net/ which has the full index loaded now
07:56:42 <chrisdone> cmccann: strict bytestrings?
07:56:50 <cmccann> and is still running on an EC2 instance with 600MB of RAM
07:56:50 <mike-burns> Oh nice.
07:56:57 <cmccann> chrisdone, it's using Text now
07:57:20 <cmccann> chrisdone, is what ready? other than a few additional tweaks, it's all there
07:57:27 <chrisdone> cmccann: cool, push it :p
07:57:53 <mike-burns> git checkout String-genocide
07:57:55 <mike-burns> It's there.
07:58:08 <chrisdone> ahh already pushed, cool
07:58:44 <cmccann> mike-burns, it's currently using about 1.5GB RAM, of which ~120MB was resident last I checked
07:58:59 <cmccann> down from the 7GB or so that it needed before
07:59:06 <mike-burns> Nice improvement.
07:59:11 <cmccann> yes
07:59:12 <cmccann> yes it is
07:59:40 <cmccann> the EC2 micro instance still can't cope with it completely and occasionally seizes up for a few minutes
07:59:46 <cmccann> but it works well enough to poke at
07:59:57 <cmccann> so that I can toss any changes there and see them live
08:01:03 <chrisdone> ah, i won't be able to run it on my vps unless i purchase more ram
08:01:07 <cmccann> I noticed that aristid has bindings for lots of AWS stuff, I'm thinking I'll play with that and see if I can automate deployment, that would be fun
08:01:26 <cmccann> chrisdone, I'm running it on a micro instance that's nearly free
08:01:55 <cmccann> the only charges I've incurred so far are for disk I/O because of swap
08:02:05 <cmccann> and that's been like $0.20
08:03:40 <aristid> cmccann: cool
08:04:03 <aristid> cmccann: aws is a bit incomplete, of course. so if there's something missing, just add it and send me a patch :)
08:04:23 <cmccann> aristid, sure thing
08:04:57 <cmccann> aristid, did you see what I'm going to be using it for? :D
08:05:07 <aristid> cmccann: ec2 for example is missing completely. it's also a bit expensive to play with if you don't need it :)
08:05:15 <aristid> no
08:05:19 <cmccann> aristid, http://hackage2.uptoisomorphism.net/
08:05:47 <aristid> cmccann: which parts of aws? just ec2?
08:06:22 <cmccann> aristid, not sure yet, I'm pretty new to using AWS so kinda figuring things out as I go
08:06:52 <cmccann> right now I just want to deploy to a micro instance but obviously I don't need your stuff for that
08:07:19 <aristid> yeah. also aws has no ec2 support yet.
08:12:13 <cmccann> aristid, well, I'd be adding EC2 support if I do anything with it :]
08:12:40 <cmccann> since I'm going to want to spawn and terminate a few beefier instances for the build stuff
08:12:57 <cmccann> since those would be too expensive to run permanently
08:14:37 <aristid> makes sense
08:15:05 <cmccann> aristid, I'd also like better ways to handle storage but I'm still not entirely clear on how that all works...
08:15:22 <aristid> cmccann: i guess you could store the packages themselves on s3
08:15:48 <aristid> s3 support meanwhile is there but incomplete. the only aws lib with complete support is SimpleDB :D
08:16:15 <cmccann> yeah I gather you had somewhat different priorities than I do :P
08:16:33 <cmccann> but building off of your stuff ought to be much easier than starting fresh
08:18:07 <cmccann> chrisdone, btw, if you're wanting to join the hackage party there's #hackage as well
08:19:17 <parcs`> cool, you can use RecordWildCards at the top level
08:19:17 <aristid> cmccann: well i started thinking "hey i want to play with aws" and slowed a bit down when i noticed that i have no clue what i could use aws for :)
08:19:39 <cmccann> aristid, yes, having a use is a great motivation
08:19:41 <aristid> cmccann: and i started with simpledb because it seemed like a nice and small API
08:19:47 <cmccann> especially when that use is "make hackage2 work"
08:20:42 <aristid> yeah, hackage 2 is something everybody would like to have:)
08:20:51 <parcs`> especially useful for parsec's TokenParser
08:21:26 <aristid> cmccann: if there's something interesting you want added to aws, just tell me. maybe i'll bite and do it myself :)
08:22:03 <cmccann> well, like I said, I'll need to mess with EC2 instances for the build stuff
08:22:40 <cmccann> and probably some storage stuff as well but I'm not sure what yet
08:23:27 * hackagebot generic-deepseq 1.0.0.0 - Generic deep evaluation of data structures  http://hackage.haskell.org/package/generic-deepseq-1.0.0.0 (MaximeHenrion)
08:23:34 <mux> \o/
08:23:56 <aristid> cmccann: well ec2 is interesting but i didn't want to end up paying hundreds of dollars for playing with it, so i didn't tackle it at all
08:24:29 <cmccann> aristid, well, you can have a free micro instance to play with
08:25:40 <jweofijm> @pl \x y z -> x (y z)
08:25:40 <lambdabot> (.)
08:27:13 <castaway> hey folks, can someone help explain an issue I'm getting building pandoc? http://paste.scsys.co.uk/182797
08:27:40 <Boxo> Is there a working prependFile function anywhere? The one at http://fhtr.blogspot.com/2008/10/io-in-programming-languages-writing.html doesn't work; it cuts off the end of the file if the file is too long
08:27:44 <castaway> I added a PseudoPod writer.. (well, started one)
08:29:11 <theorbtwo> More specificly: MakeManPage.hs: /usr/src/perl/pandoc/dist/build/HSpandoc-1.9.1.1.o: unknown symbol `__stginit_pandoczm1zi9zi1zi1_TextziPandocziW
08:29:14 <theorbtwo> ritersziPseudoPod_'
08:29:22 <theorbtwo> (Whoops, sorry about extra line-break.)
08:30:01 * edwardk waves hello.
08:31:46 <osa1_> is there a function to remove nth element of a list?
08:32:21 <dmwit> No, and also, you shouldn't want to do that.
08:32:23 <mike-burns> Remove?
08:32:44 <dmwit> However, if you cannot restructure your code to avoid this (which is rare), you can use splitAt to implement it yourself.
08:33:00 <dmwit> What is going on??
08:33:24 <hpc> dmwit: would a netsplit by any other name be so spammy?
08:33:29 <osa1_> dmwit: why shouldn't I want to do that?
08:33:41 <castaway> freenode going haywire?
08:33:51 <dmwit> osa1_: Lists are primarily a homogeneous data structure -- used for storing pieces of data that you want to treat uniformly.
08:34:04 <dmwit> osa1_: As a result, its implementation tradeoffs include very slow indexing.
08:34:12 <edwardk> > let badIdea xs n = let { (ys, zs) = splitAt n xs } in ys ++ drop 1 zs in badIdea [1,2,3,4,5] 2
08:34:14 <lambdabot>   [1,2,4,5]
08:34:16 <dmwit> osa1_: If you want a more indexing-centric approach, you should use a Map of some kind.
08:34:59 * castaway wonders if there is a pandoc channel
08:35:10 <chrisdone> cmccann: so uh can you see my messages now?
08:35:15 <dmwit> Usually irssi collapses netsplits/netjoins into a single message. But now there are hundreds flowing past. =/
08:35:23 <dzhus> is there some testing tool like expect but in Haskell?
08:35:31 <dzhus> apart from libexpect
08:35:32 <dmwit> dzhus: QuickCheck perhaps?
08:35:36 <djahandarie> dmwit, it's not a netsplit. A netsplit is when two freenode servers lose connections two each other.
08:35:50 <djahandarie> Right now, a freenode server is losing connections to its clients.
08:35:52 <dzhus> dmwit: for external programs
08:36:05 <djahandarie> Same sort of thing, but different sort of noise :)
08:36:30 <dmwit> dzhus: Parsec, I suppose.
08:36:57 <chrisdone> use http://chrisdone.com/ji/chat/ it's more stable :p
08:39:23 <dmwit> chrisdone: But is it webscale??
08:39:48 <chrisdone> dmwit: i used css3. is that enough?
08:41:16 <scrutr> ugh. this is making my head spin
08:41:38 <scrutr> how do you implement a Queue in haskell?
08:41:49 <scrutr> or rather, define the data type
08:42:05 <ChristianS> scrutr: for queues, check Data.Sequence.Seq
08:42:08 <mike-burns> http://hackage.haskell.org/package/queue
08:42:20 <dmwit> type Queue a = ([a], [a])
08:42:35 <dmwit> You can make a beautiful, efficient queue just with that simple type.
08:42:42 <cmccann> chrisdone, whoops, sorry, I walked away to get tea, if you said anything during that netsplit I'm sure I didn't see it
08:42:51 <dmwit> Of course, you can do a bit better, and there are packages out there that do.
08:42:59 <dmwit> But for education, that type is very nearly nirvana.
08:43:05 <chrisdone> bitchin' queue http://hpaste.org/steps/63372
08:43:36 <chrisdone> cmccann: from the tunes.org logs it didn't see anything. n/m
08:43:50 <scrutr> cool: i just needed to see how someone would go about doing it. call it a mental exercise...
08:44:29 <dmwit> toList (xs, backwardXs) = xs ++ reverse backwardXs
08:45:02 <edwardk> scutr: you can even get the same asympotics out of the operations on that queue if you're careful
08:45:09 <cmccann> osa1_, I was away for a while, but did the examples I showed you help at all?
08:46:10 <edwardk> do okasaki's catenable deques show up anywhere other than edison?
08:46:29 <edwardk> i have an implementation from when i worked through purely functional data structures, but i don't think i ever posted it
08:46:38 * cmccann wonders if anyone has demonstrated that ridiculous ouroboros queue yet
08:46:47 <edwardk> ?
08:47:10 <theorbtwo> Aha, after some more research on castaway's question (did you guys not see it, or are you ignoring it?), runghc Setup.hs build --verbose shows the "ld" command-line doesn't include her new file -- where does it need to be added?  It seems to be compiled, but not linked.
08:47:30 <edwardk> https://gist.github.com/1233293 ?
08:47:38 <cmccann> edwardk, I forget where it's from, but implementing a corecursive queue by feeding it its own tail
08:48:09 <osa1_> cmccann: not much, the way you're handling global state is same with mine
08:48:21 <osa1_> cmccann: and I think other ways are related with monads
08:48:27 <osa1_> and I don't know monads
08:49:15 <edwardk> that one there looks very much like one of okasaki's with an extra monad for plumbing it
08:49:17 <cmccann> osa1_, well, I wouldn't worry about it too much, there's nothing wrong with doing it that way
08:50:07 <scrutr> what are monads?
08:50:20 <scrutr> I keep seeing them everywhere
08:50:21 <mike-burns> A monad is a typeclass.
08:50:24 <cmccann> edwardk, yeah, I think that's the same idea in that gist
08:50:26 <cmccann> see also http://hackage.haskell.org/package/control-monad-queue
08:50:40 <cmccann> which appears to cite the article I originally read
08:51:02 <castaway> hmm, adding it to pandoc.cabal seems to have fixed it...
08:51:06 <edwardk> yeah i'm looking at it, but i don't really like it. it foam pads the monad so you can't do anything like make multiple queues, etc.
08:51:17 <theorbtwo> More specificly, it is the typeclass that the desugared form of "do" requires.
08:51:33 <cmccann> edwardk, it's a curiosity more than anything else I think
08:52:33 <cmccann> edwardk, there was a SO question about it where some quick and dirty benchmarks had an obvious implementation based on Data.Seq outperform both the ouroboros style and one based on mutable references
08:52:44 <edwardk> *nods*
08:52:44 <edwardk> hah
08:52:49 <edwardk> good ;)
08:52:57 <cmccann> http://stackoverflow.com/q/7506594/157360
08:53:13 <edwardk> and if jan-willem maessen can finish his high fanout data.seq we might be able to do even better
08:53:54 <cmccann> cf. the comments from me and John L on Sjoerd Visscher's answer
08:54:11 <edwardk> yeah just mined those
08:54:52 <cmccann> (also that seems to be where the gist you linked to came from)
08:55:54 <cmccann> "I suspect the lesson to take from this is that mutability isn't magically faster, and clever algorithms are nice, but a finger tree written carefully by very smart people is probably better than anything quickly hacked together will ever be."
08:55:55 <CodeWeaverX> *wafts the scent of fresh brewed coffee over the chatroom*
08:56:18 <CodeWeaverX> I really do have to figure out finger trees.  And pennants.
08:56:20 <cmccann> probably a good lesson to learn
08:56:53 <CodeWeaverX> I fancy myself reasonably algorithmically knowledgeable, but those two caught me by surprise when I started reading functional programming papers.
08:58:45 <cmccann> osa1_, anyway, you don't need to use monads for handling state if you don't want to. if you're unhappy with how it works in your code right now I can give you some suggestions, but doing it explicitly is fine if you're happy with it
09:01:02 <cmccann> dzhus, btw, I don't know of anything equivalent to expect but it wouldn't be too hard to imitate the basic idea in pure haskell
09:01:18 <cmccann> dzhus, what do you want to use it for?
09:01:20 <osa1_> can I use `where` in a lambda?
09:01:42 <dmwit> osa1_: no
09:01:46 <dmwit> osa1_: But you can use let if you like.
09:01:48 <roconnor> edwardk:  a matrix is a row vector of column vectors, which is why a -> (Covector b r) is a linear transformation, right?
09:02:00 <cmccann> and you can attach a where to a definition in the let
09:02:53 <dmwit> cmccann: I think at that point it should be given a name.
09:03:17 <cmccann> dmwit, I said "can", not "should" :]
09:03:56 <osa1_> dmwit: I still think haskell's sytax is too complex. why can't I use where in a place I can use let?
09:04:55 <dmwit> where scopes differently when there are guards
09:05:04 <cmccann> osa1_, (let ... in ...) is an expression
09:05:15 <cmccann> whereas a where clause attaches to a definition
09:05:26 <parcs`> where is an extension to a binding
09:05:32 <dmwit> cmccann: That's accurate, but doesn't really answer the "why" question.
09:05:38 <mike-burns> If you need to use a `where`, your lambda is too hard to read. Move it out into a function.
09:05:41 <parcs`> > let x = 5 where y = 4 in 3
09:05:42 <lambdabot>   3
09:05:46 <dmwit> cmccann: You could imagine a language where (... where ...) was an expression, too.
09:06:00 <cmccann> dmwit, true
09:07:21 <dmwit> (...but then you wouldn't be able to use it to make your guards readable)
09:07:38 <dmwit> (/share computation across multiple guards)
09:08:01 <parcs`> there's probably a technical justification as to why where is the way it is
09:08:21 <dmwit> I thought I just gave the technical justification?
09:08:34 <dmwit> where and let scope differently when there are guards.
09:08:40 <dmwit> Sometimes you want one, sometimes the other.
09:14:59 <Rc43> Suppose I have a value X, then I create value (X,X). Value X will be copied twice again or reference to X will be copied inside a program?
09:15:14 <dmwit> That depends on the implementation.
09:15:22 <dmwit> GHC will use two references to the same object.
09:15:31 <dmwit> Try this in ghci:
09:15:45 <dmwit> let x = unsafePerformIO (print "evaluated" >> return 3) in (x,x)
09:16:07 <lambdanaut> I'm making a game with a mainLoop function that is recursive. Is this an ok idea or will it be a huge memory leak/stack overflow?
09:16:07 * cmccann suggests Debug.Trace there...
09:16:23 <dmwit> cmccann: Probably better, yeah.
09:16:36 <Rc43> dmwit, nice way to demonstrate
09:16:38 <dreixel> mux: yes, abstract datatypes are always problematic
09:16:47 <cmccann> lambdanaut, I can't imagine many cases where a game loop could lead to either of those
09:16:58 <dreixel> mux: I have left that out of the first release, but if you'd need them we can think of what's the best way to deal with it
09:17:00 <dmwit> lambdanaut: That sounds like a pretty normal implementation strategy.
09:17:08 <lambdanaut> ok cool (:
09:17:09 <cmccann> assuming that this is an interactive game and you need to get input and display the current state each time
09:17:16 <lambdanaut> ^ yeah that
09:17:59 <cmccann> lambdanaut, since I just dug this out for someone else, take a look at https://github.com/isomorphism/lazy-tetrominoes
09:18:08 <cmccann> it's not very good code but it does work
09:18:43 <lambdanaut> :D
09:19:38 * cmccann really needs to write something less horrible to show people as an example
09:20:42 <dmwit> cmccann: uptoisomorphism.net gets the no-www Mark Of Shame
09:20:44 <lambdanaut> what is the SDL.delay for?
09:20:56 <lambdanaut> in the mainloop
09:21:04 <lambdanaut> gameLoop*
09:21:14 <cmccann> lambdanaut, it's a time delay
09:21:34 <lambdanaut> for keeping the fps all cool?
09:21:36 <cmccann> but not a very well-written one, heh
09:21:45 <cmccann> it's not that smart, it's just a 20ms delay
09:21:52 <cmccann> no matter how long rendering took
09:21:55 <cmccann> pretty terrible
09:22:06 <cmccann> but that's the rough purpose, yes
09:22:11 <lambdanaut> It's good code for a simple tetris game shuttup you nerd!
09:22:19 <cmccann> dmwit, what
09:22:26 <dmwit> http://no-www.org/
09:23:07 <cmccann> dmwit, heh
09:23:16 <cmccann> it's not like I actually have anything there anyhow
09:23:22 <cmccann> and there's no www on the hackage2 instance!
09:23:24 <dmwit> Yeah, I noticed. =)
09:24:37 <chrisdone> copumpkin: :)
09:24:41 <mux> dreixel: I was pondering about that, how much do we hurt abstraction, if at all, if even abstract data types have Generic instances? I mean, it's quite clear that having a Generic instance for an abstract datatype means you can tamper with its internal structure (right?), but how bad would that be in practice? I'm not sure
09:26:12 <hpc> dmwit: http://www.www.extra-www.org/
09:26:55 <dmwit> hpc: =)
09:28:48 <edwardk> mux: i tend to give the abstract data types fake constructors when i work with the existing Data.Daata
09:29:08 <edwardk> i haven't manually created fake versions of GHC.Generics though
09:30:04 <mux> edwardk: fake constructors ?
09:30:06 <edwardk> e.g. make a fake 'fromList' constructor that has a list in it
09:30:27 <edwardk> that way you can traverse into that constructor and you can see a list
09:30:39 <edwardk> and generic show for the container will show it as fromList [1,2,3,4] or whatever
09:31:11 <chrisdone> edwardk: Data.Dāta? :p
09:31:26 <edwardk> http://hackage.haskell.org/packages/archive/heaps/0.2/doc/html/src/Data-Heap.html see the Data instance for heaps in there
09:31:35 <edwardk> chrisdone: =)
09:31:51 <edwardk> i have a Data.Data1 around here somewhere maybe i should use that convention instead
09:31:58 <edwardk> Data.Daata, Data.Daaata
09:32:12 <dmwit> How about adding to the module hierarchy like this?
09:32:13 <cmccann> sounds like a good plan
09:32:19 <dmwit> Data.Data.Data, Data.Data.Data.Data
09:32:22 <cmccann> :D
09:32:25 <edwardk> dmwit: even better
09:32:33 <hpc> why let Data have all the fun?
09:32:39 <hpc> Data.Bender.HAL9000
09:32:41 <chrisdone> edwardk: haha, like cdddr. perfect!
09:33:33 <edwardk> mux: in any event i find that that approach to Data rather than the 'crapping out and erroring' approach works much better than the one provided by say Data.Set, etc.
09:34:00 <mux> edwardk: I'm not sure this pertains to what I was talking about
09:34:02 <edwardk> i've been meaning to propose a patch to containers to fix the containers in there to have usable if still opaque'ish generics
09:34:13 <hpaste> Mandai pasted “Separating in digrams (pairs)” at http://hpaste.org/63915
09:34:37 <edwardk> well, your 'giving abstract types generic' instances proposal is generally bad, since it lets you see too many implementation details
09:34:37 <Mandai> Can someone help me, I can't see what's wrong
09:34:49 <edwardk> and you can break invariants of the data structure using the generic api
09:35:00 <mux> right
09:35:04 <dreixel> yes, I think I agree with edwardk
09:35:08 <edwardk> so if you have any invariants, then making traditional generic instances is generally considered a bad idea
09:35:11 <mux> at some significant cost though, which is why I was wondering how bad it is
09:35:21 <edwardk> the approach i just mentioned avoids that
09:35:37 <dreixel> the other extreme is to represent them as an empty datatype
09:35:38 <edwardk> and lets you still do generic programming 'through' the container
09:35:44 <dreixel> and allow no generic behavior whatsoever
09:36:03 <dreixel> (at least it wouldn't throw an error, as syb does, though)
09:36:13 <edwardk> yeah, i don't really like that one though, since now random bits of structures will turn on and off depending on if you use set, etc.
09:36:15 <mux> dreixel: yeah, I was thinking about that, like having a representation type but containing no value
09:36:26 <edwardk> dreixel: the throwing of the error is the useless behavior i'm complaining about ;)
09:36:30 <mux> so that you can't do to . badthings . from
09:36:52 <edwardk> the fromList/toList thing at least lets you preserve your structural invariants
09:36:58 <mux> nevermind that, you couldn't do anything useful then
09:37:11 <mux> edwardk: sounds like some kind of a datatype view
09:37:36 <dmwit> Mandai: Your indentation is all screwed up.
09:37:41 <edwardk> mux: exactly. its quotienting out what is safe to be manipulated through generics
09:37:46 <mux> I guess that makes sense
09:37:53 <dmwit> Mandai: If you're going to mix tabs and spaces, you must do it consistently.
09:38:13 <edwardk> but i do find that allowing people to muck with hidden invariants that they can't even read the documentation for and have to mine the source code to get at is a bad idea
09:38:17 <dmwit> Mandai: You might like to ask your text editor to show you the difference between tabs and spaces.
09:38:18 <dreixel> edwardk: but, for Set, say, you would really create a generic representation with fake constructors?
09:38:22 <Mandai> dmwit:Thanks, I'll look into it
09:38:23 <edwardk> it makes for very brittle apis, people depending on minor versions
09:38:44 <dmwit> Mandai: In vim, try :help 'listchars'
09:38:45 <Mandai> dmwit:  not the first time I'm hurt from idendentation
09:38:51 <edwardk> dreixel: yes, a single 'fromList' constructor, which contains a list of the elements of the set. then when you deserialize it bck into a set you just use that
09:38:58 <mux> edwardk: on the other hand, those "views" would have to be given explicitely by the type implementation, right?
09:39:06 <edwardk> mux: sure
09:39:06 <dmwit> Mandai: Dunno how to do it in emacs or other editors, but I'm sure it's possible.
09:39:08 <Mandai> dmwit: I'm with notepad++, but I'm sure there's an option to show it
09:39:22 <edwardk> mux: i've done lots of generic programming through these kinds of views it works pretty well
09:39:24 <cmccann> yes, there is
09:39:28 <dreixel> edwardk: I guess it would work ok in practice
09:39:33 <cmccann> I've used notepad++ for Haskell quite a bit
09:39:38 <edwardk> and most importantly it doesn't just randomly cause generic code to crash in practice
09:39:49 <edwardk> unlike the existing instances for Data.Set, etc.
09:39:56 <edwardk> so you get a modicum of reliability
09:40:01 <edwardk> and you preserve internal invariants
09:40:19 <edwardk> it seems to be that this or going completely opaque really are the only two correct options
09:40:20 <mux> edwardk: it would be even more appealing to me if there was a way to directly have the Generic structure of an abstract datatype without having the ability to actually create any values of this type through it, so that you can't break invariants
09:40:20 <cmccann> you can also just set notepad++ to use only spaces, which is much simpler
09:40:36 <edwardk> mux: look up geoffrey washburn's thesis
09:40:43 <Mandai> cmccann: This is what I should do
09:40:48 * dmwit promises to keep silent on his tabs/spaces preferences
09:41:11 <edwardk> http://repository.upenn.edu/cis_reports/758/
09:41:13 <Mandai> cmccann:  notepad++ sure has lots of options
09:41:24 <cmccann> you don't know the half of it
09:41:31 <cmccann> pretty sure it's built with scintilla
09:41:36 <edwardk> mux: that describes type system extensions to make 'safe' generics that can still preserve invariants by limiting their exposure
09:41:42 <cmccann> which has far more options than notepad++ displays
09:41:51 <mux> edwardk: I will read it, thanks
09:41:54 <edwardk> it was done on an ml dialect, but its good reading
09:41:59 <mux> edwardk: no way without creating type system extensions?
09:42:03 <mux> ah
09:42:47 <Mandai> cmccann:  more?!  It's already dificult to find with those avaliables
09:43:05 <mux> I'm not sure if something as crude as jsut not having a "to" method definition for abstract datatypes would be enough (or have it be error "bad boy")
09:43:44 <cmccann> Mandai, look at this: http://www.scintilla.org/SciTEDoc.html
09:44:02 <mux> dreixel: what do you think? it sounds very simple and maybe hackish but it looks to me like it would work
09:44:05 <Mandai> cmccann:  ha, i just found the tab option
09:44:32 <edwardk> how do you mean?
09:45:39 <Mandai> cmccann: settings, settings everywhere
09:45:41 <mux> edwardk: I mean that the DeriveGeneric extension of GHC would just produce a "from" method, and have the "to" method be some divergent term
09:45:49 <cmccann> Mandai, yep
09:46:19 <cmccann> SciTE is a pretty thin wrapper around the editor widget, which I'm pretty sure is the same one notepad++ uses
09:46:43 <mux> edwardk: this way (as far as I can see), you cannot produce values of this type yourself that would break the invariants, because you still don't have access to the constructors, and don't have the "to" escape hatch
09:46:55 <cmccann> SciTE is the editor I use on linux so I'm well-acquainted with how many settings it has :]
09:47:39 <mux> edwardk: but you can still access the structure of the type via "from" and get to the individual values contained in the type (is it that bad?)
09:49:06 <edwardk> mux: the problem is very few generic programming problems care about 'reading' only
09:49:57 <edwardk> in the list <-> heap i gave, the list contained all the information needed to reconstruct the heap
09:50:11 <mux> agreed, but a significant uses are 'reading' only: generic fold, generic deepseq, generic show; and making this possible without prior cooperation from a library would be very powerful
09:50:22 <mux> +few
09:50:39 <edwardk> so by providing the embedding of the heap contents into a list, and the fact that reading the list i could reinstate my invariants and give you a heap, i didn't lose anything
09:50:51 <edwardk> and i don't have to change the way everyone on the planet uses Data.Data
09:51:31 <edwardk> i don't want to expose to you that IntSet is a patricia trie and all of its branching details and internal counters
09:51:39 <edwardk> because i can currently change those in minor versions
09:51:57 <mux> I know why abstract data types are useful to begin with ;-)
09:52:01 <mux> what about what I just said?
09:52:20 <edwardk> i just don't see where it has a benefit over the approach i just gave
09:52:46 <mux> the difference is being able to derive those functions without prior cooperation from a library
09:52:52 <edwardk> and moreover i don't see how you'd get that big of a change pushed through
09:52:54 <mux> without a priori knowledge of generics from the library
09:53:06 <mux> well that's not my concern, at least for now
09:53:09 <mux> I'm just wondering
09:53:41 <edwardk> well, i still think generic show from abstract data is a bad idea without the generic data helping you to expose what is meaningful in its content
09:53:43 <hpaste> o1iver pasted “could not deduce from context” at http://hpaste.org/63916
09:54:00 <mux> fair point
09:54:25 <hpaste> o1iver pasted “error” at http://hpaste.org/63917
09:54:28 <edwardk> i build lots of data structures that internally have functions, etc. but which can be contorted into ones that don't. the former can't use your generic show, but they can provide virtual constructors
09:55:11 <edwardk> and the main concern i have is that by doing so you effectively force every change to any ADT to be a major version change
09:55:16 <edwardk> because it _will_ be observable
09:55:19 <o1iver> Hey. I am getting a could not deduce from context error with a type class. It's strange because it cannot deduce the context of its own typeclass (if that's how one could explain it). Any ideas what I am doing wrong?
09:55:29 <edwardk> that is a huge PITA ;)
09:55:48 <edwardk> every major version bump i wind up flooding this channel with 50 package updates ;)
09:56:23 <mux> edwardk: that's not entirely true is that you're not exposing the real internal structure but its representation in a sum of products way, that is itself regular
09:56:32 <mux> s/is that/in that/
09:56:39 * cmccann waits for the day when hackagebot gets kicked for flooding because of edwardk
09:56:44 <o1iver> src/MDP/Types.hs:35:37:
09:56:44 <o1iver>     Could not deduce (ModifiableMDP a1) arising from a use of `stp'
09:56:44 <o1iver>     from the context (ModifiableMDP a)
09:56:44 <o1iver>       bound by the class declaration for `ModifiableMDP'
09:56:44 <o1iver>       at src/MDP/Types.hs:(25,1)-(45,42)
09:56:46 <o1iver>     Possible fix:
09:56:49 <o1iver>       add (ModifiableMDP a1) to the context of
09:56:51 <o1iver>         the type signature for
09:56:54 <o1iver>           stp' :: a1 -> ((State, Action, State), Probability) -> a1
09:56:56 <o1iver>         or the class declaration for `ModifiableMDP'
09:56:59 <o1iver>     In the expression: stp m s a s' p
09:57:01 <o1iver>     In an equation for `stp'': stp' m ((s, a, s'), p) = stp m s a s' p
09:57:04 <o1iver>     In an equation for `stps':
09:57:06 <edwardk> but i'm showing you a bunch of numbers, invariants, and crapping out on random functions
09:57:06 <o1iver>         stps m ps
09:57:09 <o1iver> whoops... sorry!
09:57:12 <cmccann> o1iver, please use hpaste :]
09:57:36 <edwardk> for instance my heaps package would still fail under your definition since it contains a function in the outer most constructor
09:57:42 <o1iver> cmccann: yeah sorry I right clicked by mistake!
09:57:50 <mux> edwardk: you're taking an example that cannot be implemented usefully with plain generics to begin with
09:57:59 <mux> or rather, meaningfully
09:58:04 <edwardk> the function?
09:58:13 <edwardk> the function there is captured from the environment
09:58:20 <edwardk> just so i can use Ord in Foldable later
09:58:27 <edwardk> its entirely determined
09:58:34 <edwardk> and the container itself can be meaningfully generic
09:58:56 <mux> use the generic deepseq example, if you wish
09:58:58 <edwardk> but there is no way that without the assistance of me, the library author, you can see that from the perspective of Data.Data
09:59:09 <o1iver> Ok I figured it out!
09:59:11 <mux> it has a meaningful implementation for any type's representation
09:59:24 <mux> gshow as probably a bad example to begin with
09:59:56 <edwardk> well, there i have a magic deepseqonce container that will break your invariant ;)
10:00:00 <mux> you're going to show useless stuff if you try to implement it, but that's orthogonal to my proposition
10:00:01 <edwardk> (i actually do) =)
10:00:28 <mux> show it to me :-)
10:00:32 <edwardk> the useless stuff is either stuff i don't want you to see or that i should be free to change
10:00:38 <edwardk> sure, let me dig it up
10:00:43 <edwardk> its actually kinda simple
10:01:28 <mux> it's quite possible that the real use cases for what I'm suggesting are two few to bother with it
10:01:36 <mux> s/two/too/ damnit
10:01:37 <edwardk> basically what you do is make a data type that holds onto the value and a thunk, such that forcing that other thunk deepSeq's the first. then the DeepSeq instance just forces the thunk
10:02:33 <edwardk> https://gist.github.com/456448 -- its fairly old
10:02:58 <osa1_> how can I write a ByteString to a file?
10:03:07 <osa1_> do I have to convert it to a string?
10:03:27 <hpc> osa1_: there's functions for that in the BS modules
10:03:32 <mux> osa1_: the ByteString module exposes a few I/O functions, including functions to write to files
10:03:46 <osa1_> ok, thanks
10:03:50 <mux> edwardk: well you're breaking things by making a weird instance..? I don't get the point
10:04:08 <edwardk> mux: i basically just don't think the extra marginal utility of supporting those is worth the costs in other areas. that nfonce thing can greatly change the asymptotics of my code
10:04:22 <edwardk> the ability to safely have minor revisions with no observable changes
10:04:28 <mux> that may very well be true
10:04:42 <mux> there would be no more problems with minor revisions though to be honest
10:04:54 <scrutr> is readFile safe to use? How can it close the file handle if it reads lazily (except if you read until EOL)?
10:04:54 <mux> you don't care if you break code that deliberately exposes itself to your internal structure
10:05:12 <edwardk> i go out of my way to make .Internal modules that give you access to lots of guts of my code
10:05:15 <edwardk> others dont
10:05:24 <mux> that's useful to have, sure
10:05:26 <edwardk> both are reasonable styles
10:05:42 <mux> for the BS modules, it has allowed many powerful modules based on bytestrings
10:05:56 <edwardk> technically that means i violate the PVP all over the place, because i don't consider changes to .Internal modules as breaking
10:06:05 <edwardk> yes
10:06:15 <edwardk> and its almost entirely the reason why I hate Data.Text
10:06:43 <edwardk> well, hated
10:07:05 <edwardk> this summer, it finally exposed Data.Text.Internal after much badgering
10:07:32 <edwardk> but i don't think generics are the right backdoor to get at that information
10:07:53 <mux> real datatype views would be cool to have
10:07:55 <edwardk> when i can make much smaller changes and get generics that are fully safe to use and preserve that hiding
10:08:18 <hadriano`> aunt
10:08:42 <edwardk> scrutr: it closes it when it reaches the end
10:08:53 <edwardk> scrutr: this makes it safe to use in some contexts, but not all
10:09:09 <edwardk> e.g. if you reasonably expect to write to or move the file later in the same process, don't use readFile
10:09:20 <edwardk> there is a whole school of thought on why Lazy IO is bad
10:09:33 <mux> if you know you're going to hold onto the whole file in memory at once anyways, a strict bytestring is much better
10:10:40 <mux> I mean there a readFile function there too
10:21:49 <The_Journey> hi, is there any Haskell compiler that targets the JVM?
10:22:56 <edwardk> not really. there used to be a couple of bridge projects, but nothing that is currently alive
10:23:19 <edwardk> http://code.haskell.org/JVM-Bridge/
10:23:35 <koeien> it's quite a challenge to retain reasonable performance
10:26:23 <napping> I think the bridge projects were generating JNI interfaces
10:26:37 <edwardk> yeah
10:26:59 <edwardk> our little language here is almost haskell and runs on the jvm, but we haven't convinced them to open source it ;)
10:27:03 <CodeWeaverX> It'd kinda be hardcore, but interesting, to generate java byte code.
10:27:24 <edwardk> we just interpret, and have good ffi to java/scala
10:27:29 <CodeWeaverX> I wonder if anyone's done LLVM to JVM.  Then you'd have a path.
10:27:39 <The_Journey> how should I go about making a Haskell program cross-compatible then?
10:27:57 <edwardk> The_Journey: what are your goals?
10:28:00 <napping> JNI is fine if you want to call libraries, not if you want to get a portable jar
10:28:48 <The_Journey> edwardk: I have a program that I want to be able to run on Windows and possibly Android
10:29:42 <edwardk> well, ghc runs on windows, and kmc ported it to android
10:29:50 <edwardk> so i'd just write decent code in ghc
10:30:15 <edwardk> and you get portability to windows/mac/linux/android/gotonlyknowswhatelse
10:32:37 <CodeWeaverX> How on earth did kmc port it to android
10:32:51 <BMeph> Is there a simple, single representation that allows one to both use and distinguish between regular and cyclical lists?
10:33:29 <edwardk> BMeph: you can always do a little tortoise and hare search to find whether or not you are looping
10:33:41 <edwardk> you might need observable sharing or unique node ids though
10:34:11 <CodeWeaverX> Mmm, cycle detection.
10:34:15 <edwardk> http://en.wikipedia.org/wiki/Cycle_detection
10:35:44 <hiptobecubic> I'm kind of surprised at the number of references to the IO monad as a "wrapper" or a "taint" etc.
10:35:49 <hiptobecubic> in RWH i mean.
10:35:50 <BMeph> edwardk: Odd. I just thought of a clunky, yet effective implementation for it.
10:36:00 <jfischoff> how do you implement ReadP +++ symmetric choice operator in Parsec. Do you put 'try' everywhere?
10:36:31 <edwardk> BMeph: you can always use data PossiblyCyclic a = C { content :: [a], cyclic :: Bool }
10:36:43 <edwardk> but you always have the seam
10:36:49 <BMeph> hiptobecubic: Anything particularly surprising about it, or is it just a general reaction? :)
10:37:22 <hiptobecubic> BMeph, well I'm pretty constantly reminded in here that those are not a correct interpretation.
10:38:01 <argiopeweb> edwardk: Can you direct me to kmc's android port? 3 google searches have failed to turn up anything.
10:38:44 <edwardk> argiopeweb: it was work for hire for RyanT5000's game company. i don't know if it was open sourced, but they did open source the iPhone port
10:38:50 <edwardk> not sure where that went though
10:39:09 <edwardk> jfischoff: good question. since ReadP is a list of successes parser
10:39:15 <argiopeweb> Ah, got it. I'll see what I can find based on that.
10:39:57 <edwardk> jfischoff: so unlike parsec both branches can succeed and return parses
10:40:33 <edwardk> otoh, the list of successes approach means you can't really give good error messages =(
10:40:53 <jfischoff> yeah thats okay
10:41:13 <jfischoff> the parsing is more for testing anyway
10:41:50 <edwardk> you can probably do something where you capture the current input state, then parse one, then rewind and parse the other and return a list in parsec, which you manually deal with upsream
10:41:57 <edwardk> but thats a PITA ;)
10:42:32 <edwardk> otoh, you don't get the parallel sweep that makes ReadP efficient
10:42:45 <edwardk> so it'd leak like a sieve
10:43:08 <jfischoff> cool, I think the simple answer is going to be to use readP
10:43:11 <jfischoff> :)
10:43:13 <jfischoff> thanks
10:48:27 <tgeeky> edwardk: that might be a feature for someone else
10:48:33 <tgeeky> 'leaking like a sieve'
11:03:18 <gandsnut> Anybody care to comment on employment outlook for H programmers?
11:04:09 <copumpkin> gandsnut: it's a bit of a weird situation, I think
11:04:25 <gandsnut> I saw a 'Net article some time ago that listed Haskell programmers as earning far above other languages...
11:04:47 <zeratul> When I was in the UK, even mentioning Haskell on my LinkedIn account got interest from the financial sector.
11:04:47 <copumpkin> gandsnut: many employers seek out haskell programmers even to do things other than haskell, but they do it precisely because people don't usually approach haskell because it will be lucrative
11:06:18 <copumpkin> gandsnut: learning a language like haskell on your own time (often) shows that you're passionate about learning and are able to work with advanced concepts, and all that jazz
11:06:33 <copumpkin> if you look at it as resume-padding, you're defeating the value of haskell as an indicator of that :)
11:06:37 <copumpkin> but it's bound to happen at some point
11:07:10 <chrisdone> indeed, i've been approached by financial sector peeps due to functional programming experience
11:07:11 <jmcarthur> this works both ways, too. if an employer is attracted to the kind of person that would learn haskell, that, to me, seems to be evidence of the kind of employer i would like to work for
11:07:21 <Enigmagic> headhunters i've talked to typically say haskell developers typically have more advanced degrees as well, so that may lead to higher salaries either way
11:07:23 <copumpkin> jmcarthur: yeah
11:08:06 <copumpkin> anyway, it's hard to say overall :) I think that apart from jobs, haskell is extremely useful to learn
11:08:14 <copumpkin> it pretty much changed how I looked at much of programming and math
11:08:35 <copumpkin> even if I were stuck writing PHP I'd appreciate knowing it
11:08:46 <Enigmagic> or you'd cry more :)
11:08:52 <copumpkin> lol
11:09:20 <gandsnut> I'm browsing the H web site...  Is there a learning environment for Windows?  I'm presuming there is for Linux...
11:09:32 <Eduard_Munteanu> What's up with finance guys and Haskell?
11:09:55 <Enigmagic> are we dirty? :(
11:10:55 <copumpkin> gandsnut: not much of a learning environment at all. There are some free books and there's chrisdone's tryhaskell.org, but I don't think there's much else for windows specifically
11:11:07 <copumpkin> chrisdone: what's up by the way? :)
11:11:08 <Eduard_Munteanu> gandsnut: dunno about learning, but there's a Haskell Platform available for Windows. That should be enough to go through e.g. LYAH.
11:11:30 <gandsnut> Sorry, "LYAH"?
11:11:31 <osa1> can you recommend me a library to writing serial port on linux? I'll try to communicate with arduino
11:11:34 <Eduard_Munteanu> @where lyah
11:11:34 <lambdabot> http://www.learnyouahaskell.com/
11:11:39 <Eduard_Munteanu> gandsnut: ^^
11:11:45 <gandsnut> Thx
11:12:43 <Eduard_Munteanu> @where platform
11:12:43 <lambdabot> http://hackage.haskell.org/platform/
11:13:51 <gandsnut> Is it possible that one can find work in H w/o "formal" education in it?
11:13:57 <copumpkin> Eduard_Munteanu: a lot of freedom to work with whatever technologies they want to work with, as long as they can make money, possibly? or the budgets to hire the programmers they want?
11:14:09 <Varifold> gandsnut, what do you mean by "formal" education in Haskell?
11:14:23 <copumpkin> gandsnut: possibly, but it'll take a long time to get to an employable level in haskell in particular
11:14:27 <chrisdone> copumpkin: hey man. did you see my little chat thing? http://chrisdone.com/ji/chat/
11:14:32 <copumpkin> you'll learn a lot along the way and it'll make you a better programmer all around
11:14:42 <copumpkin> chrisdone: nope!
11:15:26 <gandsnut> Well, one can take classes in higher education in various languages, I took 2- and 4-year courses in 'C', Pascal, Cobol, etc.
11:16:00 <copumpkin> most schools don't teach haskell
11:16:04 <gandsnut> If I approach Haskell completely on my own, is that going to have any weight when approaching an employer?
11:16:08 <copumpkin> so most of us learned it for fun on our own time
11:16:19 <copumpkin> gandsnut: sure, it's a good sign in general
11:16:25 <Varifold> gandsnut, I doubt that there are courses for Haskell specifically. My university, for instance, uses Haskell to introduce undergraduates to theoretical computer science, but even that approach is a rarity.
11:16:30 <copumpkin> gandsnut: but it's not like learning most other languages
11:16:37 <gandsnut> Wow "for fun on our own time".  Huh.
11:16:50 <osa1> can you recommend me a library to writing serial port on linux? I'll try to communicate with arduino
11:17:07 <copumpkin> gandsnut: I feel that on some level, the bit you quoted is what employers are looking for, more than haskell itself :P
11:17:28 <copumpkin> although haskell does also have some unique features of its own that make it more attractive to employers
11:17:36 <copumpkin> (some enlightened employers, at least)
11:18:01 <tromp__> employers like employess without side-effects
11:18:06 <copumpkin> lol
11:18:15 <Varifold> gandsnut, the advantages of Haskell have virtually nothing to do with your job prospects. Becoming a better programmer, better scientist, or even a better mathematician because of philosophy and thought processes that you acquire by learning Haskell is what you ought to be after, if you touch this language.
11:18:46 <gandsnut> I guess I'm impressed and surprised to find this many IRC people in a Haskell channel.
11:18:56 <copumpkin> gandsnut: there are very few actual jobs that involve programming haskell out there, but there are many related jobs that involve some form of functional programming, and knowing haskell well is seen as very positive in those circles
11:19:06 <Enigmagic> osa1: can you just open the serial device directly and use the bytestring APIs to read/write to it?
11:20:18 * cmccann would expect knowing Haskell to be a significant benefit for a job using something like Scala or F#
11:20:22 <jmcarthur> gandsnut: why so surprised?
11:20:22 <sanjoyd> Paul Graham puts it nicely:  even if a project may not _need_ someone who knows Haskell (he says Python, I think) for his or her knowledge of Haskell, it might benefit from having people who took the extra effort to learn such a language.
11:20:41 <osa1> Enigmagic: I think I can, but I don't want to mess with low-level details.
11:20:46 <Varifold> Haskell is a powerful, elegant and beautiful language, gandsnut. I do not see how it might surprise you that people want to learn a language like this.
11:21:41 <jmcarthur> i can see being impressed at least. 841 people in the channel is impressive (we're one of freenode's largest, i think)
11:21:48 <monochrom> person X is surprised by other people's behaviour because X assumes that everyone behaves like X
11:21:49 <gandsnut> Surprised because here I thought I had my finger on computer languages and environments... Then I find out about 'newer' languages like Scala, Squeek, Erlang, Ocaml.
11:22:01 <Enigmagic> osa1: what are you trying to do? if System.IO.openFile and Data.ByteString.hGet / hPut don't seem that complicated to me
11:22:15 <Varifold> gandsnut, none of those language is "new".
11:22:26 <Varifold> *languages
11:22:32 <jmcarthur> yeah haskell is, what, like twenty years old?
11:22:33 <copumpkin> haskell's been around for about 20 years now
11:22:37 <jmcarthur> in some form, at least
11:22:48 <cmccann> erlang is about the same age as Haskell, I think
11:22:52 <gandsnut> Not surprised that people would want to learn Haskell, hey, I'm just pleased to see 800-some people here, rather than 25...  :)
11:22:53 <osa1> Enigmagic: all I want is to write some strings to serial port. I never tried it using file io functions, I was doing it with Python and it's serial library so I don't know if using just file io functions is enough
11:22:55 <monochrom> and also the old saying "all languages are similar, you understand one, you already know the rest" is false
11:23:06 <copumpkin> gandsnut: yeah :) we are too!
11:23:08 <cmccann> both Haskell and Erlang are much older than, say, Python
11:23:29 <Varifold> monochrom, it is true if you speak about a certain family of languages which share their basic expressive principles.
11:23:33 <cmccann> if memory serves me, at least
11:23:44 <jmcarthur> it's funny that a much older language is, in my opinion, also much more modern :)
11:23:51 <cmccann> actually, Python's older than I thought, nevermind
11:23:52 <chrisdone> copumpkin: how's your work going in the us?
11:24:05 <copumpkin> chrisdone: very well! having lots of fun :)
11:24:06 <MostAwesomeDude> cmccann: Didn't we have this conversation a few weeks ago? :3
11:24:06 <Enigmagic> osa1: try it out, i thought a serial port in linux is just a regular socket
11:24:13 <Peaker_> cmccann, Python started around 1991 or so
11:24:16 <cmccann> yeah
11:24:19 * cmccann just looked it up
11:24:26 <gandsnut> Of all the languages I've worked in, pre-Visual 'C' (and pre-C++) always felt most comfortable under my fingers and conceptually to me.  I guess H is going to be a big paradigm shift.
11:24:30 <copumpkin> chrisdone: you still in italy?
11:24:35 <copumpkin> completely
11:24:54 <copumpkin> just pretend you've never programmed before at first :P
11:24:56 * cmccann might have been thinking of Ruby, which is several years younger than Python
11:25:16 <copumpkin> gandsnut: that will be easier than if you try to apply knowledge from C to haskell
11:25:24 <gandsnut> Well, singer Sheryl Crow sings "A Change Will Do You Good".
11:25:41 <jmcarthur> it's not a change as much as it is a fresh start
11:25:49 * cmccann thinks that applying knowledge from Java to Haskell is much worse than knowledge from C
11:26:01 <gandsnut> Woah, tall order to forget years of how to think/approach programming.
11:26:06 <cmccann> or any clumsy not-really-type-safe OO languages
11:26:07 <jmcarthur> yes, it is
11:26:11 <copumpkin> it'll be lots of fun, though
11:26:13 <jmcarthur> it's very hard to unlearn
11:26:14 <copumpkin> if you don't try to fight it :P
11:26:17 <jmcarthur> but very valuable
11:26:22 <copumpkin> we sound like a cult
11:26:27 <gandsnut> "Let the Force _flow_ through you"?
11:26:46 <monochrom> set up a virtual machine in your mind. not a tall order. every dumb computer can do it.
11:27:05 <cmccann> forgetting everything else is overrated, though, you don't need to do that. you just need to remember that many assumptions you may have won't hold
11:27:19 <gandsnut> A good cult.  No coolaid.
11:27:29 <jmcarthur> i don't think it's overrated at all
11:27:34 * copumpkin hands gandsnut some flavor aid
11:27:37 <jmcarthur> i think it's often misinterpreted though
11:27:57 <gandsnut> Yum..... <thud> <falls on floor>
11:28:00 <copumpkin> :)
11:28:04 <jmcarthur> in fact. "forgetting" is not at all the same thing as "unlearning"
11:28:05 <copumpkin> I'm gonna go out, ttyl and good luck
11:28:24 <cmccann> most of what you know from other languages is still useful as long as you don't try to use Haskell the same way you'd use other languages
11:28:41 <cmccann> jmcarthur, yeah just quibbling over terminology, probably
11:28:57 <Indecipherable> Hey
11:29:01 <gandsnut> OK, well, great feedback, much appreciated.  I'm back to the Haskell site to see about dabbling.
11:29:15 <monochrom> @quote unlearning
11:29:15 <lambdabot> DukeDave says: Haskell has the greatest unlearning curve
11:29:19 <cmccann> :D
11:29:23 <monochrom> @quote monochrom unlearning
11:29:24 <lambdabot> monochrom says: Learning is unlearning. Intuition is experience. Understanding is feeling.
11:29:24 <jmcarthur> i beg to differ. you *can* use Haskell the same you'd use other languages. it's just that you gain more if you don't
11:29:26 <chrisdone> copumpkin: what kind of work are you doing there? MAN it's busy in here! yeah i'm still here. took an italian class and started watching movies in italian (as IRC is my only social life right‽). (by the way, send me good italian tv and radio to listen to!) i was curious about at your place over via edwardk some months ago. i think i'll be sticking around here for another year yet. it's not stopping me doing my own projects ;)
11:29:48 <cmccann> jmcarthur, yes, that falls under "not useful" :P
11:30:12 <Eduard_Munteanu> Indecipherable: hi
11:30:27 <Indecipherable> I have a question, but it doesn't really involve Haskell. The language I need help with is shen (it is quiet on #shen)
11:30:28 <jmcarthur> i think applying imperative programming knowledge to haskell in the form of IO or ST is very useful
11:30:41 <cmccann> jmcarthur, yes, that's actually true
11:30:53 <Indecipherable> In regard to pattern-matching
11:31:03 <cmccann> jmcarthur, writing C in Haskell leads to uglier Haskell but prettier C :]
11:31:05 <monochrom> "shen" sounds more like someone's name
11:31:21 <gandsnut> I'm thinking if/when I can claim Haskell mastery, it will look good on a resume, right next to languages "LOGO" and "PL/1"  --  (ha)
11:31:28 <copumpkin> chrisdone: oh, cool. We're doing various sorts of financial calculations in scala in a very haskell-flavored manner :)
11:31:34 <jmcarthur> and applying object oriented experience to haskell is also useful (although to say what form it takes places a controversial definition on what OO is)
11:31:48 <Eduard_Munteanu> http://en.wikipedia.org/wiki/Shen_(programming_language)
11:31:59 <Indecipherable> Basically, to implement a range function, how would you go about doing it?
11:32:02 <gandsnut> Again,thanks for the feedback.
11:32:11 <copumpkin> chrisdone: you should come over :) but I'm not sure about visa arrangements
11:32:14 <cmccann> jmcarthur, I have my own obviously correct definition of OO that may or may not agree with anyone else, yes
11:32:22 <Indecipherable> range(1,5) --> list from 1 ... 5
11:32:23 <jmcarthur> so do i :)
11:32:31 <copumpkin> mine is obviously the most correct
11:32:34 <gandsnut> Bye
11:32:38 <copumpkin> bye :)
11:33:35 <otters> I still don't get the difference between newtype and data, and I'm looking at the wiki
11:33:51 <Eduard_Munteanu> :t enumFromTo   -- :P
11:33:52 <lambdabot> forall a. (Enum a) => a -> a -> [a]
11:33:56 <Indecipherable> What I need to know is not the Haskell code, but rather the theory on how pattern matching can be used to implement the function
11:34:00 <jmcarthur> otters: newtype has the operational behavior of type, but the type system behavior of data
11:34:12 <otters> hmm
11:34:14 <otters> okay
11:34:21 <cmccann> otters, ignoring performance issues and runtime representation, not much
11:34:32 <monochrom> eh? shen looks really nice
11:34:36 <jmcarthur> i think the difference between  Foo _
11:34:38 <jmcarthur> _oops
11:34:56 <jmcarthur> i think the difference between  Foo _|_ = _|_ and Foo _|_ /= _|_ is significant
11:35:11 <otters> yeah
11:35:12 <otters> "/"
11:35:15 <chrisdone> copumpkin: right. edward said you were doing stuff like that, sounds fun :) how painful was it for you to get a visa to work in the us?
11:35:26 <copumpkin> chrisdone: I'm a US citizen :)
11:35:41 <jmcarthur> that was actually a bad claim
11:35:53 <copumpkin> chrisdone: simplifies things enormously
11:36:01 <cmccann> jmcarthur, it's significant but honestly not that much in my experience
11:36:02 <monochrom> then again, if we can name languages after Pascal and Haskell, we may as well name a language after Shen :)
11:37:08 <ChristianS> otters: useful rule of thumb: if you can use newtype, use it (that's when you only have one constructor with one argument). otherwise use data.
11:37:14 <otters> I see
11:37:35 <Indecipherable> What must the first thing to be matched be?
11:37:37 <jmcarthur> cmccann: to me, newtype Foo = Foo Int instead of data Foo = Foo !Int is also a form of documentation (that Foo is meant to behave something like an Int rather just just involve the use of an Int)
11:37:44 <jmcarthur> *rather than just
11:37:46 <chrisdone> copumpkin: ah, you have dual citizenship?
11:38:08 <Eduard_Munteanu> Indecipherable: I don't think you really need pattern-matching
11:38:24 <jmcarthur> s/behave/be/
11:39:00 <cmccann> jmcarthur, yes, but that's a fairly subtle distinction and not really something to worry about for anyone who needs to ask what the difference is :P
11:39:03 <Eduard_Munteanu> You rather need to check a condition somehow.
11:39:18 <Indecipherable> Well
11:39:23 <Indecipherable> What I tried was
11:40:28 <Indecipherable> if Start does not equal End, the function calls itself again with Start+1 and End
11:40:40 <Indecipherable> But I still got stack overflow
11:40:56 <Indecipherable> And It doesn't add anything to a list
11:41:07 <monochrom> and what happens when Start equals End?
11:41:47 <copumpkin> chrisdone: yep
11:41:50 <Eduard_Munteanu> You probably want to add Start to range(Start + 1, End).
11:42:23 <Eduard_Munteanu> As long as Start <= End.
11:43:02 <Indecipherable> It was in the form: If Start \= End then range(Start+1, End)
11:43:23 <Eduard_Munteanu> What about range(3,3) then?
11:43:25 <jmcarthur> it's true that a general rule of thumb is that if your data type has only one constructor with one field, you probably want newtype instead
11:43:33 <Indecipherable> Shouldn't is just automatically stop when Start finally equals End?
11:43:43 <Eduard_Munteanu> Indecipherable: also your function doesn't seem to produce anything
11:43:46 <jmcarthur> especially if the field is strict anyway
11:43:59 <monochrom> it depends on the rest
11:44:04 <Indecipherable> Yes
11:44:24 <Indecipherable> It should produce a list (which the current code does not include)
11:45:04 <Eduard_Munteanu> Indecipherable: you want to cons something at each step.
11:45:13 <frusen> hey, i am trying to create a program that handles program arguments. http://pastebin.com/jrvbT7cx <- that is my code but i have a question about line 34. how do i change "words.txt" to the actuall value passed?
11:46:47 <Saizan> frusen: put a fresh variable there
11:46:57 <Saizan> frusen: ah, no
11:47:01 <napping> like | Input file `elem` args -> do x <- readFile file
11:47:11 <napping> ah, right
11:48:05 <Saizan> it's better done with find and pattern guards i guess
11:48:06 <monochrom> "case () of" is a yucky hack
11:48:37 <Indecipherable> Yes, but how do I not cons it to an empty list every time?
11:48:57 <Eduard_Munteanu> Indecipherable: you don't cons it to an empty list
11:49:00 <napping> frusen: if you were matching on a single argument at a time, you could get the words
11:49:09 <napping> then maybe use mapM
11:49:21 <frusen> i used this before: http://pastebin.com/A0AZtYNz
11:49:21 <Eduard_Munteanu> Indecipherable: you cons it to the rest of what your function produces, which eventually turns out to be an empty list
11:50:28 <monochrom> range(1,5) shall cons 1 to range(2,5). clearly, range(2,5) is not going to be an empty list
11:50:30 <napping> that's more like what I was thinking
11:50:31 <Eduard_Munteanu> Indecipherable: think   range(3,5) = 3 : range(4,5) = 3 : 4 : range(5,5) = 3 : 4 : 5 : range(6,5). Now think that range(6,5) should give.
11:50:56 <Eduard_Munteanu> s/that/what/
11:51:20 <Eduard_Munteanu> By '
11:51:23 <frusen> napping: what i want to do is to be able to pass both --hash and --input
11:51:25 <Eduard_Munteanu> By ':' I mean cons.
11:51:27 <napping> If you remove the [] it will expect a single argument, then you could put the case in a function and mapM it over input
11:51:39 <frusen> napping: but i don't know how to check for that
11:51:43 <napping> the way you've written it with exitWith it will never do more than one thing
11:52:29 <frusen> i know, but i don't have a clue what to do
11:52:53 <frusen> i want to be able to do this: ./md5 --hash 0asdka2... --input words.txt
11:53:12 <Saizan> frusen: http://pastebin.com/QhnHAW76 <- cheap hack
11:54:19 <Saizan> frusen: needs {-# LANGUAGE PatternGuards #-}
11:55:00 <Saizan> ah, if you want to handle more than one argument then disregard my code
11:55:55 <nand`> @hoogle Monad m => (m a, m b, m c, m d) -> m (a, b, c, d)
11:55:55 <lambdabot> No results found
11:56:05 <frusen> i try to find a way to store the hash and the content of a file in one variable each and then further down do my processing
11:56:12 <frusen> trying to match the hash with something in the file
11:56:26 <frusen> i am struggling with finding a solution
11:57:07 <napping> frusen: the usual solution is to process the whole list of arguments
11:57:13 <otters> @hoogle Monad m => (m a, m b) -> m (a, b)
11:57:13 <lambdabot> No results found
11:57:30 <napping> Do you want multiple hashes or inputs?
11:57:49 <frusen> napping: no, just one of each
11:58:02 <frusen> but i want to be able to have either infront of the other
11:58:23 <frusen> ./md5 --hash blabla --input words.txt or ./md5 --input words.txt --hash blabla
11:58:41 <napping> Then something with pattern guards might work
11:58:59 <MostAwesomeDude> :t \(ma, mb) -> do { a <- ma; b <- mb; return (a, b) }
11:58:59 <lambdabot> forall (m :: * -> *) t t1. (Monad m) => (m t, m t1) -> m (t, t1)
11:59:09 <MostAwesomeDude> And so on.
11:59:19 <napping> The more general pattern is to define a record which holds all the information you want to get from the arguments, then process the list to fill out a default record
11:59:51 <napping> but here something like | [file] <- [f | Input f <- args], [hash] <- [h | Hash h <- args] -
12:01:49 <napping> instead of Input .. `elem` args
12:02:11 <frusen> napping: that was really helpful!
12:02:42 <frusen> thanks so much
12:02:58 <frusen> this solved my problem :)
12:08:30 <napping> great. I hope it works out.
12:08:58 <darrint> What's the idomatic way to get encodeInt :: Int -> ByteString or encodeInt :: Int -> Text?
12:13:24 <Guest87645> Just to make sure I'm understanding, type classes support multiple inheritance but don't suffer from the same problems that OO languages have with Multiple inheritance because it addresses a more narrow subset of language functionality?
12:13:28 <ChristianS> darrint: pack . show  i would think
12:13:56 <mandaya> Guest87645: I wouldn't try to understand typeclasses that way
12:14:14 <tgeeky> and there are type families in haskell, too
12:14:31 <mandaya> they're analagous to OO interfaces but subtley different
12:15:58 <Guest87645> Ok, makes sense but I'll have to read more about type families
12:16:33 <hiptobecubic> RWH, chapter 9 is really sexy.
12:19:13 <monochrom> I don't know what "addresses a more narrow subset of language functionality" means.
12:19:54 <monochrom> multiple inheritance's only problem is implementation inheritance. haskell doesn't have that. java's "Interface" doesn't have that either. end of story.
12:20:27 <Guest87645> Makes sense, input and output. Multiple inheritance has a large implication when it means inheriting method impletations from a base class but much less when just inheriting signatures. Inheritance with interfaces is a great example and explained my question.
12:22:45 <chrisdone> monochrom: tell us more stories Uncle Monochrom, oh, please! something scary, like the one about the "monomorphism" restriction!
12:24:21 <monochrom> C supports the monomorphism restriction :)
12:24:44 <aristid> it begins quite scary
12:24:52 <nand`> why does “a:b:c:_ <- sequence $ repeat foo” stack overflow but “[a,b,c,d] <- sequence $ replicate 4 foo” doesn't?
12:25:01 <nand`> is sequence strict?
12:25:06 * chrisdone screams in horror and clutches his lambda-patterned quilt
12:25:34 <monochrom> to gain parametericity in C, interface with Haskell through FFI :)
12:26:23 <monochrom> "is sequence strict" is an ill question on multiple fronts
12:26:24 <chrisdone> @src sequence
12:26:24 <lambdabot> sequence []     = return []
12:26:25 <lambdabot> sequence (x:xs) = do v <- x; vs <- sequence xs; return (v:vs)
12:26:25 <lambdabot> -- OR: sequence = foldr (liftM2 (:)) (return [])
12:27:20 <monochrom> sequence (repeat x) terminates or non-terminates depending on the monad used
12:29:00 <nand`> monochrom: the monad in question is StateT ProgramState MPD a
12:29:22 <monochrom> then it non-terminates
12:29:32 <chrisdone> > head $ (evalState $ sequence $ map return [1..]) ()
12:29:32 <lambdabot>   1
12:29:38 <chrisdone> =)
12:29:41 <Guest87645> mono, what is a monad?
12:29:43 <monochrom> you will find it fun that using Control.State.Lazy terminates it
12:29:58 <monochrom> a monad is a nice type class in haskell
12:30:05 <chrisdone> monochrom: that was the only lazy monad i could think of. what other popular ones are there?
12:30:14 <nand`> monochrom: ah, I forgot about that
12:30:26 <monochrom> to a large extent, Control.Monad.ST.Lazy is another one
12:31:14 <chrisdone> ah, nice one
12:32:13 <hpaste> monochrom pasted “lazy ST example” at http://hpaste.org/63925
12:32:37 <monochrom> that one is a nice trick I learned recently from the mersenne twister code
12:33:13 <monochrom> apparently, it's a case of sequence, isn't it?
12:36:08 <hpaste> monochrom annotated “lazy ST example” with “lazy ST example version 2” at http://hpaste.org/63925#a63926
12:36:11 <chrisdone> monochrom: what does that code specifically demonstrate? it does look like sequence
12:36:52 <monochrom> it shows how to use Control.ST.Lazy and terminate early and mutate state on demand
12:39:49 <chrisdone> monochrom: hm… if you evaluate map (example!!) [1..5] you get [1..5]. but what if you evaluate example!!4 -- do you get 0?
12:40:15 <monochrom> 4
12:40:46 <chrisdone> (or 5, i suppose, if !!0==1, but anyway)
12:41:02 <chrisdone> so it guarantees ordering. it's not clear to me why
12:41:21 <chrisdone> ah, nevermind, it is
12:44:45 <monochrom> I could use your haskell json service to show you, if it supported Control.Monad.ST.Lazy :)
12:45:02 <chrisdone> (ಠ益ಠ)
12:45:04 <monochrom> http://www.vex.net/~trebla/haskell/testbed.cgi :)
12:46:13 <chrisdone> monochrom: hang on
12:47:45 <chrisdone> monochrom: any other modules?
12:47:52 <monochrom> Data.STRef
12:48:33 <monochrom> do you support the syntax "import ... as L"?
12:49:04 <frusen> hmm, i'm trying to validate if a string is a legit MD5 hash. that is 32 characters long and contains the numbers 0-9 and characters a-f. i can't figure out how to do this matching
12:49:22 <chrisdone> monochrom: actually all imports are ignored for "security"
12:49:51 <monochrom> well then I can't write "L.runST" anymore
12:50:05 <chrisdone> monochrom: i suppose i could allow a set of modules
12:50:49 <frusen> napping: do you have any tips?
12:51:03 <RichyB> frusen, (\string -> (all (elem "0123456789abcdefABCDEF") string) && (length string == 32))
12:51:56 <RichyB> Oh, replace "elem" with "flip elem"
12:52:00 <RichyB> frusen, (\string -> (all (flip elem "0123456789abcdefABCDEF") string) && (length string == 32))
12:55:10 <hpaste> chrisdone pasted “tryhaskell filter” at http://hpaste.org/63927
12:55:15 <chrisdone> monochrom: that's what i'm doing ^
12:56:07 <chrisdone> so… i'll try allowing imports filtered… when i can find which place of the constructor they're in :p
12:56:16 <frusen> RichyB: thanks, that looks like something i'd be after, let's see if it does the job
13:00:10 <RichyB> frusen, it's just the problem statement restated.
13:00:57 <RichyB> frusen, test (length s) == 32 checks the length
13:01:49 <RichyB> frusen, all (predicate) list, returns True iff (predicate element) is True for every element in list
13:02:19 <reltuk`> is there a standard Monoid for Kleisli arrows under composition?
13:02:23 <RichyB> frusen, and ((flip elem "0123456789abcdefABCDEF") char) returns True iff char is in "0123456..."
13:03:31 <RichyB> reltuk, Wouldn't that only work for identity arrows?
13:04:30 <Saizan> it'll work for any arrows with the same domain and codomain
13:05:19 <Saizan> however we have Endo but not one generalized to Category
13:05:28 <reltuk> it would be like Endo...basically wondering if there is already a Monoid instance that I could use to monadic version of "ala Endo foldMap"
13:06:05 <edwardk> reltuk: there isn't a stock Kleisli Endo monoid
13:07:08 <edwardk> i used to have a Data.Monoid.Categorical in monoids, which offered a GEndo which worked with any Arrow, so you could use it with Kleisli
13:07:12 <edwardk> but thats kinda overkill =)
13:08:06 <chrisdone> lol. damn it. i put in control.monad.st in my browser and i get someone's blog. damn you, bloggers! *shakes fist*
13:08:22 <chrisdone> http://control.monad.st/ ~_~
13:08:40 <reltuk> 'k, thanks everyone :-)
13:10:13 <frusen> RichyB: thank you, i got it working just as i wanted it!
13:13:15 <RichyB> frusen, cheers. ☺
13:14:18 <nyingen_> is that codepage 437
13:21:04 <chrisdone> monochrom: there we go
13:21:32 <chrisdone> monochrom: your paste now works
13:21:38 <chrisdone> if print is removed
13:22:13 <hpaste> chrisdone annotated “tryhaskell filter” with “allowed imports” at http://hpaste.org/63927#a63930
13:25:16 <chrisdone> my haskell programs often use lots of memory
13:25:29 <chrisdone> when ran for more than a day
13:25:59 <chrisdone> i think tomorrow i will sit down and learn how to use the profiler as part of my normal development workflow
13:27:26 <gentleben> chrisdone: I have the same problem
13:35:42 <chrisdone> gentleben: right. i'm not really doing anything memory intensive. it's just… collecting over time where somewhere in the program things just aren't being collected. hpaste idles around 25mb, like at the moment, but some days it can go up to 150 and then 300
13:35:42 <chrisdone> gentleben: i have ghc 6.12.3 on my server, i read in one of the 7.*'s that it now frees memory back to the OS that it's not using. i didn't realise it *didn't* do that. i don't know how substantial that is, there wasn't much detail, just a one-liner in the changelog. at any rate i will try running the profiler and pump a bunch of requests at it
13:35:42 <chrisdone> gentleben: my only fear is that i will become a speed and space junkie, trying to squeeze every bit of efficiency out, like back in my asm/c days :p
13:36:24 <gentleben> chrisdone: I slowly accumulate memory
13:36:47 <gentleben> over days until it uses gigs
13:37:09 <gentleben> i am not a memory junkie but the app should have an upper bound on memory usage
13:37:27 <gentleben> and there are not good enough tools to figure out why
13:37:39 <chrisdone> gentleben: wow. yeah, definitely time for profiling and strictifying and unboxing kind of stuff and ghc flags and all that, i suppose :)
13:37:46 <chrisdone> gentleben: did you already try the profiler then?
13:37:51 <gentleben> yeah
13:37:59 <chrisdone> no indication of what's using the memory?
13:38:26 <gentleben> the profiler stops generating data after a while
13:38:35 <chrisdone> :/
13:38:35 <gentleben> maybe it just stops writing it to disk
13:38:57 <gentleben> and it can take like 12 - 14 hours for the usage to start growing
13:39:10 <gentleben> so right now it just exits every iteration
13:39:11 <chrisdone> yeah, hard to repro
13:39:14 <gentleben> and then restarts
13:39:19 <gentleben> which is totally ghetto
13:39:50 <chrisdone> i've started doing that for my apps. i use `angel' to auto-restart apps incase they fail due to memory usage, and i kill ones i notice are using too much. very sketchy, very php.
13:40:36 <chrisdone> monochrom: YOU'RE WELCOME
13:40:46 <duairc> It feels like this program should be invalid somehow, but it isn't: http://hpaste.org/63933
13:41:31 <cmccann> duairc, haha, nice
13:41:46 * cmccann doesn't see why the program would be invalid though
13:41:48 <chrisdone> what are data kinds? :o
13:41:57 * chrisdone opens the ghc manual
13:42:03 <duairc> :D
13:42:12 <cmccann> chrisdone, well they're like data types
13:42:19 <cmccann> except instead of a type, it's a kind
13:42:26 <cmccann> and instead of values, they contain types
13:42:30 <cmccann> it's all very simple
13:42:31 <chrisdone> i know what a kind is. i mean what's that DataKind extension
13:42:37 <chrisdone> ☺
13:42:55 <cmccann> yeah, I think that enables the data type promotion stuff
13:43:17 <cmccann> to get magic type-level counterparts of plain old data types
13:44:25 <chrisdone> ah, nice
13:45:10 <duairc> cmccann: I've defined a kind with no types, so it sort of feels like that should cause an error at the type level, or something
13:46:40 <RichyB> chrisdone, you _should_ be a space and speed junkie.
13:46:52 <cmccann> duairc, well, you can write "blah x = ()" with the type "Void -> ()", right?
13:46:59 <RichyB> You should join the GHC team and keep bumming bytes and cycles. :)
13:47:27 <chrisdone> RichyB: (*ﾉﾟOﾟ) i should?
13:47:43 <duairc> cmccann: True. It still feels very weird to be able to do that though!
13:47:57 <RichyB> chrisdone, yes, that way you can make all *my* Haskell programs run faster. ;)
13:48:14 <chrisdone> RichyB: (  ￣ー￣)
13:49:08 <RichyB> I might sound intensely selfish, because I am, but you should do things that benefit me! ^_^
13:49:20 <watermind> F# type providers seem really neat
13:49:30 <watermind> is there anything similar on the works for haskell?
13:50:11 <cmccann> duairc, it's just like in logic, a material implication (A -> B) makes sense even if A is known to be false.
13:50:19 <chrisdone> watermind: what's a type provider?
13:51:14 <watermind> the idea seems to be types and typed data provided by online services
13:51:27 <cmccann> sounds like a baked-in version of the stuff people use TH for all the time :P
13:51:48 <watermind> so you could for instance say,  type Data = some SQL connection
13:52:06 <cmccann> does it do anything that isn't straightforward to implement with TH?
13:52:15 <maurer> watermind: I'm not entirely sure why you'd need a language extension for that?
13:52:15 <cmccann> insofar as anything is ever straightforward with TH that is
13:52:46 <mike-burns> Sounds like something that would make a useful package on Hackage.
13:53:10 <watermind> cmccann: good point probably can be done in TH didn't even think of that
13:53:25 <watermind> maurer: well, how would you do it without a language extension?
13:53:45 <watermind> maurer: unless the service is providing the types as valid code in your language
13:54:08 <cmccann> if nobody's written something similar yet it's probably because using TH is a pain
13:54:26 <Peaker> I wish TH didn't have to import every package the code might use
13:54:33 <watermind> I've never really played with TH
13:54:38 <chrisdone> Peaker: tell me about it!
13:54:43 <cmccann> I wish TH was nicer in general but oh well
13:54:44 <Peaker> at the syntax level, why does TH need the imports?
13:55:17 <Enigmagic> i don't find TH very terrible
13:55:35 <maurer> watermind: So, at some level, a "Type Provider" just sounds like a module that marshals back and forth between the strings you're sent and the type you want to view it as.
13:55:38 <cmccann> watermind, glancing at the F# documentation it seems a bit unclear so I'm not entirely sure what this is all supposed to do
13:55:39 <Peaker> TH is at least extremely fragile
13:55:51 <Peaker> first thing to break in every new release
13:55:56 <maurer> watermind: So would, for example, an Attoparsec parser or a Data.Binary not provide this?
13:56:06 <cmccann> but if you have a clear idea of what something similar in Haskell might do taking a stab at it with TH might not be too bad
13:56:16 <Enigmagic> i haven't had to update any of my TH packages for 7.0, 7.2 or 7.4
13:56:23 <Peaker> maybe a new future-proof interface for TH could allow applying old TH code when the new code doesn't use new extensions
13:56:40 <Peaker> Enigmagic: code that uses TH breaks with a new GHC
13:56:48 <hpaste> chrisdone pasted “Every time I compile” at http://hpaste.org/63935
13:56:53 <chrisdone> Peaker: ^
13:56:54 <chrisdone> ;_;
13:57:07 <Peaker> arrg
13:57:08 <watermind> maurer: yes something like that
13:57:10 <Enigmagic> Peaker: except for mine i guess?
13:57:16 * Enigmagic has a lot of TH code
13:57:25 <Peaker> chrisdone: I'd rather write some boilerplate than suffer through that
13:57:41 <Peaker> Enigmagic: do you pattern-match against any part of the AST?
13:57:48 <Enigmagic> Peaker: yes sir
13:57:50 <Peaker> the AST keeps changing
13:57:54 <maurer> watermind: Basically, it seems to me (though I could be wrong) that the "Type Provider" interface is superceded by typeclasses.
13:57:55 <Enigmagic> uniplate
13:58:14 <Peaker> Enigmagic: what does uniplate do?
13:58:23 <cmccann> lets you ignore parts of the AST you don't care about
13:58:27 <Enigmagic> Peaker: makes it so TH code doesn't break every release
13:58:30 <watermind> cmccann: I'm still watching the talk as we speak, the given examples consist of accessing large databases, and automatically extract types and typed data
13:58:36 <cmccann> so that intermediate stuff won't break your code if it changes
13:58:53 <Peaker> Enigmagic: oh I see -- I feel it is fundamentally wrong/risky
13:59:12 <cmccann> it's exactly the sort of thing that uniplate is for
13:59:16 <Peaker> Enigmagic: to assume that having a certain type in any position means the same predictable thing
13:59:19 <Enigmagic> peaker: if unit tests pass i don't care that much
13:59:22 <watermind> cmccann: plus the possibility of some automagic from within the programming environment, such has subscribing to data packages etc
13:59:24 <cmccann> use a generic traversal and then match only on the bits you care about
13:59:26 <chrisdone> i have some small TH which migrated from ghc 6.12.3 to ghc 7.2.2 with no changes (in fact all 17k lines of code worked fine), depends on what you're doing i suppose…
13:59:45 <watermind> maurer: not really, I don't see why that would be the case
13:59:58 <Peaker> maybe uniplate's "wrongfulness" is worth it
14:00:20 <Peaker> but maybe there's a better way.. i.e: explicit catamorphisms instead of pattern matchers
14:00:23 <cmccann> watermind, yeah, sounds like bog standard TH stuff, though it seems more common in Haskell to define data types and then generating serialization or such for them
14:00:29 <Peaker> and then new TH keeping old catas in it
14:00:36 <maurer> watermind: instance SpecificServiceBinary SomeType
14:00:47 <maurer> When you expect a SomeType, you now just use the marshaling method
14:01:03 <maurer> (assuming you're talking to the service that SpecificServiceBinary corresponds to
14:01:12 <chrisdone> watermind: cmccann: i thought i heard something similar where the type provider might be a database schema?
14:01:18 <Enigmagic> Peaker: if you come up with something better i'm happy to use it
14:01:28 <chrisdone> watermind: cmccann: which actually be useful
14:01:43 <chrisdone> hm. i'm missing words from my sentences, i think it's time to go to bed
14:01:46 <watermind> maurer: but you'd have to provide SomeType...
14:01:52 * cmccann shrugs
14:01:53 <watermind> maurer: that's what you want to avoid
14:02:02 <cmccann> wouldn't surprise me if the yesod guys had something like that in the works
14:02:17 <cmccann> type safety via unholy TH hackery is their shtick
14:02:20 <chrisdone> cmccann: they do
14:02:34 <watermind> maurer: you don't want to have to construct the datatypes, and keep them update has the diversity of data grows
14:02:42 <chrisdone> haskelldb had type generation since forever but not via th
14:02:58 <watermind> chrisdone: that is interesting
14:03:46 <maurer> watermind: Then the dox they have up aren't fully describing what they claim they'll do...
14:04:11 <watermind> maurer: maybe, haven't looked at it
14:04:21 <chrisdone> cmccann: you sound a bit like a lisper :p
14:04:27 <zeratul> I'm not sure I see the benefit with relation to type safety in F#. As I could imagine it would work by the compiler generating stubs to functions which are then linked up at runtime in according to some WSDL or SQL schema. As these schemas can change, you just end up having to handle essentially type mismatch exceptions, where is the safety in that.
14:05:21 <chrisdone> zeratul: if the schema changes while the program is running such that it can break the program, that sounds like a human error…
14:05:46 <watermind> zeratul: you can avoid that by typechecking the program before running it though
14:05:57 <watermind> i.e. recompiling it
14:05:59 <chrisdone> right. (isn't that the point?)
14:07:58 <zeratul> My understanding was that at least with webservices is that you're not baked into some typed interface, but you generate stub methods which are dispatched via web to a serialized web service interface (which is xml)
14:08:10 <zeratul> As there isn't versioning with that, there isn't a compile time check you can do.
14:09:03 <zeratul> If the specification isn't what you thought it was, i.e. it's changed since you fetched the schema. Well, you're out of luck.
14:09:55 <Enigmagic> zeratul: soap webservices have a defined schema in xml
14:10:22 <Enigmagic> dealing with soap without a code generator is terrible
14:11:13 <zeratul> That's kind of my point, you know that the interface can change after you write the program and have to deal with that. Providing support for strongly typed interfaces that are ephemeral seems counter-intuitive.
14:11:42 <Enigmagic> not really
14:11:50 <Enigmagic> handshake agreements are ok
14:12:06 <Enigmagic> "dont change this without telling me or i will beat you with a stick"
14:12:17 <Enigmagic> i find that works pretty well
14:13:17 <zeratul> You could be right, but a little off topic anyway I suppose :)
14:14:56 <watermind> zeratul: so at this point in the talk he mentioned that the import can take options specifying e.g that the program should only work if your connected to the service, or that is should store the schema so you can work offline, and whether this stored schema should be always updated, etc
14:16:06 <zeratul> Ah ok, that seems a little more sane.
14:18:43 <watermind> another neat difference between having this as part of the language, rather than say, implemented via TH, is that tools can take advantage of it. In this case that means autocompletion for accessing the information in these schemas
14:19:21 <watermind> and other bells and whistles like subscribing databases etc
14:19:51 <pmade> I'm trying to understand how Control.Monad.Writer works.  How can I have ghci show me the definition of (>>) for Writer?  Or at least tell me which source file to read since Writer has a few different files.
14:23:08 <RichyB> pmade, Control.Monad.Writer is part of the mtl library, for which you can find the source code (IIRC) on Hackage.
14:23:56 <pmade> RichyB: That's true.  I've been reading it, but it's several files (Lazy, Strict, etc.) and I'm not sure which file I should be looking at.
14:24:37 <pmade> In ghci if I do ":t (>>)" it tells me where to look for Monad, but I don't know who to ask it for the definition of (>>) for Writer.
14:25:04 <RichyB> :i Writer is more likely to be illuminating.
14:25:58 <pmade> RichyB: okay, I'll start there.  Thank you.
14:27:11 <RichyB> The top level module Control.Monad.Writer probably imports and re exports Control.Monad.Writer.Lazy.
14:45:18 <monochrom> thank you chrisdone!
14:46:12 <monochrom> . o O ( Control.Monad.ST.Lazy.runST (do thank_chrisdone; chrisdone_welcomes) )
14:48:33 <Enigmagic> It's not just you! http://hackage.haskell.org looks down from here.
14:48:34 <Enigmagic> meh
14:48:58 <Enigmagic> right in the middle of rebuilding my 7.4.1 tree with debug symbols
14:55:44 <chrisdone> monochrom: :p
14:58:40 <yescalona> omg, #haskell have more users than #python, nice how this grow up :)
14:58:56 <CodeWeaverX1> :)
14:59:50 <Mango_Man> python is lame
15:00:12 <Mango_Man> actually forget i said that, don't want to start a flame war haha
15:00:18 <average_drifter> anyone playing Hobowars2 here ?
15:00:38 <mux> holy jeebus, 831 people
15:00:46 <duairc> Is hackage down?
15:01:15 <mux> haskell is failing more and more in the "avoid success at all costs" department
15:01:39 <jedai> I think the motivation of people on both channels are different, a lot of people stay on #haskell because there are interesting discussion, much more than on #python which essentially answer basic questions (that's a sweeping generalization but it seems mostly true to me)
15:03:07 <hiptobecubic> jedai, there's definite truth to taht
15:03:17 <Enigmagic> duairc: it appears that way
15:03:48 <duairc> :(
15:03:51 <hiptobecubic> I'm in here because you people are always way over my head, I'm in there because I need to repay my debts
15:12:56 <hpaste> mzero pasted “Rank2Types mess” at http://hpaste.org/63936
15:13:19 <mzero> hiho - I'm having a bit of an ExistentialQuantification crisis
15:13:31 <edwardk> mzero: ?
15:13:35 <mzero> can't quite figure out how to make Rank2Types work... or better how to avoid them
15:14:00 <mzero> the hpaste is  a bit long, but it was the most minimal example I could conjure
15:14:17 <mzero> note that as written it won't compile, line 34 is the problem
15:14:32 <mzero> though frankly, I'd be open to ideas for a different way to structure this code
15:14:52 <edwardk> mzero: ao why are you quantifying rather than just expressing the problem directly?
15:15:26 <edwardk> hrmm
15:15:28 <mzero> So - here is the issue: I have lots of code that wants to run     StateT FooState m    actions ---
15:15:37 <edwardk> ok
15:16:04 <mzero> but that code needs to be able to work if the m is either IO or State BarState
15:16:26 <hanshoglund> anybody had troubles browsing hackage latetely?
15:16:42 <mee> hanshoglund: yeah, just now
15:16:42 <mzero> both of those are instances of some class    say    PosixLike m    so that the actions the code does with the StateT FooState m   are limited to that class
15:16:53 <mzero> (you can see this kind of set up in the hpaste)
15:16:54 <mzero> NOW
15:17:01 <edwardk> if you insist on the existsts on Runner you probably are going to need to put some constraints in there
15:17:05 <hanshoglund> mee: browser timeout too?
15:17:10 <edwardk> because otherwise all you know is that it has kind * -> *
15:17:11 <mee> yep
15:17:20 <mzero> some other code ---- call it main ---- wants to pick, based on a flag, for the   main code to be run in    IO or in State Bar
15:17:27 <Mango_Man> Hey guys, sorry to barge in, but what's better: conditional evaluation using pattern matching and guards, or nested if-then-else statements?
15:17:36 <Mango_Man> obviously guards are more succinct and clean
15:17:44 <edwardk> data Runner where Runner :: Monad m => Run m -> Runner
15:17:47 <Mango_Man> but are there any benefits to if-then-else?
15:17:52 <mzero> okay
15:18:08 <edwardk> at the very least you'll need something like that otherwise you won't be able to do anything with m
15:18:15 <Saizan> Mango_Man: nope
15:18:21 <mzero> basically, I'm trying to get the Runner object to hide up the fact that in one case there is an extra state object to carry around
15:18:35 <mee> if-then-else is just sugar for case expressions, yeah?
15:18:43 <Saizan> yes
15:19:06 <Mango_Man> but you can't check, say, a < 0 with cases
15:19:15 <mzero> Mango_Man: patterns and case evaluation are the same, and most "primitive" -- guards and if-then-else are equivalent
15:19:44 <Mango_Man> oh okay thanks
15:19:44 <mzero> edwardk: I have that constraint on run   Logger m =>
15:19:50 <mzero> but I ineed it in Runner too, you think?
15:19:52 <Saizan> case a < 0 of True -> ..; False -> ..
15:20:47 * DanBurton likes case expressions better than if-then-else
15:20:49 <edwardk> but your real problem is that the function you get from deconstructing Runner on line 34 is for some existential type, and the Foo m a you pass in is for what is probably a completely different type.
15:20:58 <Mango_Man> Saizan: dang, didn't know that. i thought you could only pattern match with cases
15:21:08 <edwardk> so this approach is mucked up in other ways
15:21:10 <Mango_Man> *nvm that's pattern matching
15:22:00 <edwardk> why do you need this big ball of existential mud in the first place though?
15:22:13 <mzero> Isn't the point of the for all m. on data Runner to imply that the thing inside the Runner (a Run m) works for any m?
15:22:14 <edwardk> you can make all the combinators you want, as long as they are parametric in choice of Logger or what not
15:22:30 <edwardk> the forall m in Runner is outside of the constructor, that makes it an existential
15:22:32 <edwardk> not a universal
15:22:40 <mzero> I don't want it, actually - I'm trying to avoid it
15:22:57 <edwardk> data Foo = Foo (forall a. a) is universal data Foo = forall a. Foo a is existential
15:23:21 <mzero> aha
15:23:26 <edwardk> why not just do
15:23:30 <mzero> sure
15:23:55 <mzero> can I put the constraint inside too?
15:23:57 <edwardk> runInIO :: (forall m. Logger m => m a) -> IO a
15:24:29 <edwardk> runIoState :: Monad m => (forall n. Logger n => n a) -> StateT whatever m a
15:24:33 <edwardk> er runInState
15:24:40 <edwardk> and then just say runInIO x = x
15:24:53 <edwardk> or something like that
15:25:02 <edwardk> then throw out the whole 'Runner' concept entirely
15:25:11 <mzero> because I've got a giant IO action that wants to occasionally run some Foo actions
15:25:30 <mzero> so I can't just compose up a big Foo action and pass it to either runInIO or runInState
15:26:15 <mzero> and Foo has state that must be carried from occasional Foo action to occasional Foo action
15:26:29 <edwardk> make class MonadFoo m where liftFoo :: Foo m a -> m a
15:26:46 <edwardk> or Foo SomeConcreteMonad a -> m a
15:27:01 <edwardk> then just write code that is parametric in MonadFoo as well
15:27:38 <edwardk> in general, if you need an existential there is a fair bet you are thinking about the problem backwards ;)
15:27:47 <mzero> I agree on that
15:27:49 <mzero> :-)
15:28:14 <copumpkin> nuh uh!
15:28:31 <edwardk> or you're in agda ;)
15:28:43 <copumpkin> I'd break use of existentials into phantom-eliminating existentials and OO-polymorphism-like existentials
15:28:56 <edwardk> yeah
15:29:09 <copumpkin> although for the former, I generally use higher-rank continuations
15:29:16 <edwardk> what he has here is an OO-polymorphism-style one
15:30:00 <mzero> indeed (I think) -- the original version was essentially a plain vanilla continuation
15:30:06 <edwardk> so why do your Foo m a actions exist in that form?
15:30:10 <edwardk> rather than
15:30:24 <mzero> it was     data Runner :: Runner { run :: Command -> IO (Result, Runner) }
15:30:32 <edwardk> someFooAction :: Logger m => Foo m a
15:30:34 <edwardk> you could use
15:30:48 <mzero> they are all of that form, actually
15:30:56 <edwardk> someAction :: (MonadState FooState m, Logger m) => m a
15:31:29 <mzero> (context: I've got a "Test" implementation of Posix --- so have   class PosixLike m     with IO as and instance, and  State PosixState as another)
15:31:48 <edwardk> sure
15:32:22 <edwardk> replace MonadState with class MonadFooState m where fooState :: (FooState -> (a, FooState)) -> m a
15:32:24 <mzero> (then there is, well,     StateT ShellState m    --- a shell built onto of something PosixLike)
15:32:37 <edwardk> then someAction :: (MonadFooState m, Logger m) => m a
15:33:15 <edwardk> so to run it in IO you allocate an IORef and read/write to it?
15:34:59 <edwardk> or you just plumb it through hidden away
15:35:04 <mzero> I don't see how that solves the issue:      I'm going to have some    action in IO    and it wants to be given something that will let it run a     StateT ShellState m    where someone else has picked the m
15:35:52 <edwardk> um, but then how do they supply the embedding from m back into IO or whatever other monad you are living in?
15:36:22 <mzero> well - notice that in runner the result is in IO
15:36:40 <mzero> so, if the underlying m is IO, it just runs it
15:37:09 <mzero> if it is in    State FooState     then it runs it directly on the squired away state in the continuation
15:37:18 <mzero> and returns, in IO  (result, new continuation)
15:38:46 <edwardk> so what you have right now is Runner -> Foo m a -> IO (a, Runner) -- this is just a state transformed IO in disguise
15:38:59 <edwardk> Foo m a -> StateT Runner IO a
15:39:30 <mzero> this version worked fine, with no high order type trickery:   data Runner :: Runner { run :: Command -> IO (Result, Runner) }     it worked where there were two runners, one using IO underneath, the other using State PosixState     and   they   called some function    doCommand :: PosixLike m => Command -> StateT ShellState m a
15:39:45 <edwardk> yeah
15:39:54 <edwardk> so why the craziness? =)
15:40:38 <adu> edwardk: some people enjoy it
15:41:13 <edwardk> i tend to go as crazy as anyone, i just don't like to add epicycles without purpose
15:43:45 <mzero> because I wanted to generalize it to:   data Runner :: Runner { run :: StateT ShellState m a -> IO (a, Runner) }
15:43:58 <edwardk> what i meant by that is that since the only properties that Foo has is that its got access to a Logger supplied by the user, and that there exists a map from Foo m a -> StateT Runner IO a, i wonder if you'd be better off replacing Foo m a _with_ StateT (something) IO a
15:44:09 <mzero> and I don't see how to do that w/o type gymnastics (which in general I don't like)
15:44:35 <edwardk> what is wrong with exactly what you wrote there?
15:45:12 <jgrimes> Hi. How would one implement a zipper for a graph (in particular a direct graph) ?
15:45:21 <edwardk> oh with the appropriate Logger constraint on m and universal
15:45:26 <jgrimes> does anyone know if this already exists somewhere, and my google skills have failed me?
15:45:26 <mzero> aha
15:45:34 <mzero> and the universal (for a)
15:45:58 <edwardk> data Runner = Runner { run :: forall m a. Logger m => StateT ShellState m a -> IO (a, Runner) }
15:46:11 <edwardk> rather newtype Runner
15:46:33 <mzero> isn't that what I've got effectively (just splitting out Run?)
15:46:45 <edwardk> no you have an existential around Runner
15:46:51 <edwardk> and are missing the Logger constraint
15:47:11 <mzero> okay - putting those in....
15:47:26 <quintessence> jgrimes: Norman Ramsey published something about a zipper for control flow graphs
15:47:56 <quintessence> jgrimes: http://www.cs.tufts.edu/~nr/pubs/zipcfg-abstract.html
15:48:08 <quintessence> there may well be more recent/relevant things out there though
15:49:23 * Sgeo wants a language like Haskell in a CL+SLIME-like or Smalltalk-like environment, I think
15:49:33 <jgrimes> quintessence: hmmmmm, yeah this may be the best I can do for now.
15:49:56 <drdo> Sgeo: Oh yes i miss slime so much when writing haskell
15:50:14 <edwardk> you want runInIO to effectively be supplying the Logger, and runInState likewise?
15:51:17 <napping> Have you tried 7.4.1?
15:52:55 <hpaste> mzero annotated “Rank2Types mess” with “Rank2Types mess (annotation)” at http://hpaste.org/63936#a63937
15:53:19 <mzero> edwardk: yes, exactly
15:53:27 <edwardk> one sec
15:53:53 <edwardk> got runInIO right, fixing runInState
15:53:58 <mzero> I want the Runner value passed to the server (running in IO) to take a Runner, and use it when it needs to execute one of those actions
15:54:55 <edwardk> @hpaste
15:54:55 <lambdabot> Haskell pastebin: http://hpaste.org/
15:55:25 <hpaste> edwardk annotated “Rank2Types mess” with “RankNTypes less of a mess” at http://hpaste.org/63936#a63939
15:55:27 <hpaste> edwardk annotated “Rank2Types mess” with “RankNTypes less of a mess” at http://hpaste.org/63936#a63940
15:56:15 <mzero> okay!
15:56:19 <edwardk> that what you are looking for?
15:56:28 <mzero> well.. if it works!  :-)
15:56:35 <edwardk> it works
15:56:43 <mzero> now- is there a better way to structure all of this mess to not have to do that double, nested for all?
15:57:04 <mzero> or, since it insulates the rest of the code, perhaps I should just turn the other way and not worry that it's hiding there
15:57:22 <edwardk> well, the outer forall is really a forall, the inner forall being in negative position is an existential in diguise
15:58:09 <edwardk> but overall, this is probably as clean as this design will get
15:58:22 <mzero> has no idea what that actually means!  "negative position"?
15:58:51 <edwardk> a -> b -- the 'a' is in 'negative' position and the 'b' is in positive position, you flip sign every time you go over a -> to the left
15:58:57 <mzero> can't I think of a forall m. SomeClass m =>   as a requirement that the dictionary be passed?
15:59:10 <edwardk> fmap can map b, but a would map 'backwards' there
15:59:16 <edwardk> or contravariantly
16:00:35 <edwardk> well, honestly. i'd probably just make a monad that had Logger actions directly and which gave access to FooState, and make a runMyMonad instead of all of this
16:01:20 <mzero> well, the thing is... all of this is being used from web server actions --- and I was really trying to not plumb my monad morass into that monad morass!
16:01:34 <edwardk> e.g just make people work in RST MyLogger FooState IO, etc.
16:01:45 <mzero> So if I could just pass a Runner as a plain old data value in at the top, I'd avoid all that monad composition
16:01:52 <edwardk> *nods*
16:02:43 <SubtleArray> Hi folks. I was wondering. Is there a way to break from a function that's calling itself? For example:
16:02:45 <hpaste> SubtleArray pasted “breaking from a function that's calling itself” at http://hpaste.org/63941
16:02:46 <mzero> (also I was being clever: and letting getOpts pick a Runner instance and set it in an Options record.... and later just pulling it out and passing it)
16:02:57 <edwardk> *nods*
16:03:16 <edwardk> well, you now at least have an encapsulated mess ;)
16:03:25 <mzero> SubtleArray: put the recursive call under a conditional of some sort: a if-then-else, or a case
16:03:38 <edwardk> as an aside you don't need the ()'s around Monad in class (Monad m) => Logger m where
16:04:09 <mzero> I know, I just put them in there for style - I sort of like that the constraint, even if only one, is "parenthetical"
16:04:22 <SubtleArray> mzero: That's exactly what I did. :D I used a case. I thought just ending with putStr would stop it, but it keeps going. Does Haskell have a break?
16:04:23 <edwardk> (it is one of my quests to rid the world of needlessly prophylactic parens ;)
16:04:46 <mzero> no, you can't break -- make sure the recursive call only appears in one branch of the case
16:05:02 <mzero> you have to have the recursive call *inside* the case
16:06:14 <hpaste> mzero annotated “breaking from a function that's calling itself” with “breaking from a function that's calling itself (annotation)” at http://hpaste.org/63941#a63942
16:06:16 <hpaste> SubtleArray pasted “Case in my tail recursion” at http://hpaste.org/63943
16:06:25 <JoeyA> hackage.haskell.org seems down
16:06:38 <mike-burns> SubtleArray: You'll need to paste the whole function.
16:06:39 * mzero ...he said parenthetically!
16:07:06 <SubtleArray> mzero: checking annotation
16:07:08 <mzero> edwardk: okay, so I'm not nuts - if I don't want to hack my monads onto the monads in the web server stack, this is the way to go
16:07:25 <edwardk> its a way to go at least ;)
16:08:48 <mzero> or perhaps a way to think about it is --- if one is going to use the continuation pattern (or the original simple version of Runner), and you want the input to the continuation to be generic on something hidden within the continuation, then, well, this is what you have to do
16:09:10 <SubtleArray> mzero: Nice to know I did it right. I must be overlooking something. I do have a function call in the middle of the function. I might need to paste the whole thing.
16:10:01 <mzero> paste the whole thing
16:10:16 <mzero> thanks, edwardk -- you've been a big help!!!
16:10:55 <mzero> ("forall" makes me feel like a Haskell noob all over again!)
16:12:30 <SubtleArray> I think I see what's going on... Above my last case statement I have another case statement that calls a function that calls the function I'm recursing through. Hahaha. If I can clean this mess up a bit, it might act a little better.
16:12:54 <SubtleArray> I'd hate to waste anyone's time here with my sloppy code, especially if I can fix it myself. Lol. I'll work on it and be back if I can't sort this out.
16:13:09 <SubtleArray> Thank you mzero, mike-burns for your time.
16:19:45 <hpaste> applicative annotated “breaking from a function that's calling itself” with “breaking from a function that's calling itself (annotation)” at http://hpaste.org/63941#a63944
16:20:07 <mike-burns> Heh.
16:22:25 <SubtleArray> Checking annotation.
16:23:50 <SubtleArray> mike-burns: Nice. Thank you. How long have you been using Haskell?
16:24:20 <mike-burns> I didn't paste that; applicative did.
16:24:39 <SubtleArray> I thought I would be able to learn Haskell in a couple weeks... A month later, I'm still struggling. >_<
16:24:48 <mike-burns> I've been at it for a few years.
16:25:02 <mike-burns> If someone paid me to do it, I'd be better.
16:25:27 <zomg> SubtleArray: sounds about what I thought
16:25:28 <zomg> :D
16:25:48 <zomg> Assuming you'd have 8 hours to put into it every day, you could prob pick it up faster
16:25:51 <SubtleArray> :) It's such a strict language...
16:26:09 <zomg> I dunno, it's not that strict if you think about it
16:26:14 <zomg> It has type inference for one
16:26:32 <mauke> it's rather lazy
16:26:34 <noteventime> Some people would argue it's lazy
16:26:43 <SubtleArray> zomg: Yeah, type inference is nice, but not being able to do a = a + 1 has bit me in the arse a few times.
16:26:46 <mike-burns> My girlfriend learned Haskell pretty well in a couple of months. She put about 6 hours a day into it.
16:26:58 <mauke> > let a = a + 1 in ()
16:26:59 <lambdabot>   ()
16:27:31 <SubtleArray> Is there a way to set a variable in a case statement?
16:27:39 <zomg> SubtleArray: well at least you can do that with different numbers without first having to explicitly cast them like in certain other languages =)
16:27:40 <mike-burns> Use `let'.
16:27:41 <SubtleArray> That would REALLY be nice. I could then get rid of one of thee functions.
16:27:49 <mauke> SubtleArray: variables aren't set
16:27:54 <mauke> they're bound
16:28:13 <mike-burns> Only Chuck Norris can set variables.
16:28:49 <SubtleArray> "7" -> do { putStr (reply) ; let takelog = [] } Like something like this doesn't work.
16:28:59 <SubtleArray> mike-burns: LOL
16:29:15 <noteventime> SubtleArray: You could use the writer monad
16:29:16 <mike-burns> SubtleArray: Move the IO out from that function.
16:30:23 <SubtleArray> mike-burns: The IO, as in the do?
16:30:30 <mike-burns> As in the putStr .
16:31:27 <SubtleArray> But I kind of need that. >_<
16:31:34 <vodik> SubtleArray: does every case manipulate takelog?
16:31:51 <SubtleArray> vodik: I just want to kill that variable.
16:31:56 <SubtleArray> After it prints a string.
16:32:10 <vodik> SubtleArray: you can always do, takelog = case ... of
16:32:11 <SubtleArray> If status == "7"
16:32:27 <vodik> Starfire: and then have putStr (reply) >> return []
16:32:34 <vodik> err SubtleArray ^
16:32:35 <noteventime> (x, takelog) <- runReaderT $ case ... "7" -> do { putStr reply ; tell [] } ...
16:32:38 <SubtleArray> Mmm...
16:32:38 <noteventime> Or something like that
16:32:54 <SubtleArray> I see.
16:33:01 <SubtleArray> * tries that *
16:36:43 <SubtleArray> This is what I meant about Haskell being strict. :D So much work to kill a variable. >_< But I still think the benefits outweigh the learning curve. Trying to do NLP in C++ would have required about 20 times more code.
16:37:08 <mike-burns> It's just a different way of thinking from how you'd do it in C or asm.
16:37:44 <Martty> NLP?
16:37:53 <SubtleArray> Natural language processing.
16:38:19 <SubtleArray> mike-burns: Yeah, but still... lol
16:38:26 <noteventime> SubtleArray: One has to get rid of the notion of a variable as being variable :)
16:38:37 <SubtleArray> Lolwut?? >_<
16:39:30 <Jafet> When mass confusion is imminent, they should not be called variables.
16:39:46 <noteventime> When you say let x = ... you aren't assigning a value to a memory cell, you're introducing a name for the right hand side
16:41:00 <SubtleArray> noteventime: Fair enough. But it would be kind of awesome if I could introduce these names to new values. :D
16:41:23 <Jafet> Use C++ then
16:41:33 <mike-burns> The algorithm should follow the data structure.
16:41:49 <noteventime> SubtleArray: You can reuse names, but anyone who was referring to the "old version" of that name, would still get the old value
16:42:00 <SubtleArray> I'm not criticizing Haskell. Just whining slightly. I wouldn't be using Haskell if I didn't like it.
16:42:05 <SubtleArray> Jafet: No.
16:42:28 <Jafet> I regularly rewrite Haskell programs in C++, where they run incredibly faster
16:42:57 <Jafet> Though that requires a fine understanding of the implementations of Haskell and C++
16:43:13 <SubtleArray> Jafet: I thought Haskell could run as fast as C?
16:43:19 <SubtleArray> ++
16:43:22 <Jafet> Haskell isn't an athlete
16:43:26 <Jafet> Languages don't run
16:43:28 <Martty> and of the machine
16:43:51 <SubtleArray> * uses runhaskell *
16:44:53 <Jafet> The Haskell report makes almost no mention of efficiency. Any discussion of performance refers invariably to compiled Glasgow Haskell.
16:45:35 <Jafet> Note that runhaskell does not compile Haskell to machine code, only bytecode
16:45:50 <Jafet> Or more accurately, runghc
16:45:58 <SubtleArray> Jafet: Right, another thing I love about Haskell. The code can be compiled or ran.
16:46:00 <ozgura> hackage down? http://www.downforeveryoneorjustme.com/http://hackage.haskell.org
16:46:47 <Jafet> downfordownforeveryoneorjustmedotcomorjustme.com
16:49:13 <byorgey> ozgura: seems down, yes
16:50:27 <ozgura> byorgey: do we need to let someone know?
16:51:19 <byorgey> ozgura: I assume whoever needs to know already does, or will when they wake up.
16:51:21 <xpika> is there a hackage mirror? it seems to be down.
16:51:28 <byorgey> although of course if EVERYONE assumes that...
16:52:06 <ozgura> I'll just send an email to cafe. Maybe they'll see from there.
16:53:38 <byorgey> there's a mirror (running a development version of Hackage 2) at http://hackage.factisresearch.com/
16:53:55 <byorgey> but I think it's up-to-date so you can at least use it for downloading package tarballs
16:54:10 <byorgey> although I don't think it has any documentation built, etc.
16:56:38 <luite> http://hdiff.luite.com/packages/archive/ also contains an up-to-date archive
17:00:30 <duairc> I had no idea there were mirrors! Thanks for those links!
17:06:04 <rostayob> is the projects.haskell.org mailman dead?
17:06:15 <rostayob> the QuickCheck mailing list doesn't seem to work
17:07:14 <nyingen_> I tried to email someone with a @haskell.org address a few days ago, and today got a bounce message
17:07:23 <nyingen_> may be related
17:07:50 <carter> yeah, its down for me too
17:08:42 <byorgey> hmm, Haddock can't handle Unicode?  I have a .hs file where one of the comments contains the character é encoded as UTF-8, and the Haddock output when viewed in my web browser has a little box there
17:08:55 <byorgey> and the page encoding is detected as UTF-8.
17:09:09 <byorgey> and I highly doubt my font does not have a glyph for é.
17:10:34 <byorgey> looks like Haddock output the byte 0x02.
17:10:56 * byorgey is sad =(
17:11:28 <hpc> byorgey: what encoding is the browser claiming the file is?
17:11:33 <geekosaur> is $LANG set in your environment?  probably need to make sure it's in a utf8 locale, otherwise haddock is probably assuming iso8859-1 source
17:11:35 <byorgey> UTF-8
17:11:48 <byorgey> hmm, yeah, could me
17:11:53 <byorgey> could *be
17:12:10 <byorgey> $LANG is set to en_US.utf8
17:12:36 <geekosaur> (although these days haddock ~ ghc and I wonder if the need for a LANGUAGE UnicodeSource applies somehow)
17:12:51 <hpc> > BS.pack "é"
17:12:52 <lambdabot>   Couldn't match expected type `GHC.Word.Word8'
17:12:52 <lambdabot>         against inferred type...
17:13:03 <hpc> @hoogle String -> ByteString
17:13:03 <lambdabot> Data.ByteString.Char8 pack :: String -> ByteString
17:13:03 <lambdabot> Data.ByteString.Lazy.Char8 pack :: [Char] -> ByteString
17:13:03 <lambdabot> Data.String fromString :: IsString a => String -> a
17:13:08 <geekosaur> there's that weirdness where ghc assumes (or used to assume) iso8859-1 source anyway unless told otherwise by a LANGUAGE pragma
17:13:30 <hpc> > fromString "é" :: ByteString
17:13:31 <lambdabot>   Not in scope: type constructor or class `ByteString'Not in scope: `fromStri...
17:13:59 <byorgey> geekosaur: oh, really?
17:14:12 <hpc> never heard of that
17:14:22 <hpc> i can use π as an identifier in my files no problem
17:14:27 <byorgey> I'd never heard of that either.  What's the language pragma?
17:14:59 * byorgey tries UnicodeSource
17:15:25 <geekosaur> ok, maybe it's dead.  I'm thinking back some time ago, and it's quite possible that it's irrelevant now that the runtime has utf8 support
17:15:43 <alpounet> > fromString "é" :: BS.ByteString
17:15:44 <lambdabot>   Not in scope: `fromString'
17:16:06 <alpounet> > Data.String.fromString "é" :: BS.ByteString
17:16:07 <lambdabot>   Not in scope: `Data.String.fromString'
17:16:09 <rostayob> geekosaur: I think that the report specifies UTF8 as input
17:16:12 <alpounet> meh
17:16:32 <byorgey> it turns out I was using GHC 7.0.4, I'm going to try 7.4.1 now
17:16:41 <rostayob> I think you're referring to the language extension to use alternative symbols (\rightarrow instead of ->, \forall instead of forall, etc)
17:16:47 <geekosaur> the report does, but ghc lagged there for a while.  same way the runtime did
17:16:59 <hpc> Minuscule é U+00E9 E9
17:17:01 <rostayob> geekosaur: uhm, ok
17:17:18 <rostayob> it's been utf8 since 6 at least iirc
17:17:28 <byorgey> aha, it works fine with GHC 7.4.1
17:17:39 <geekosaur> hm, likely UnicodeSOurce is that extension, I am (mis)remembering a different extension which was an admitted hack
17:17:49 <byorgey> (without UnicodeSource)
17:18:11 <hpc> > showIntAtBase 2 return 0xE9
17:18:11 <lambdabot>   Couldn't match expected type `GHC.Types.Char'
17:18:12 <lambdabot>         against inferred type...
17:18:14 <byorgey> problem solved then, because there's no reason I need to use GHC 7.0.4 to generate documentation
17:18:16 <hpc> :t showIntAtBase
17:18:17 <lambdabot> forall a. (Integral a) => a -> (Int -> Char) -> a -> String -> String
17:18:33 <hpc> > showIntAtBase read 2 0xE9
17:18:34 <lambdabot>   No instance for (GHC.Num.Num GHC.Types.Char)
17:18:34 <lambdabot>    arising from the literal `2...
17:18:45 <hpc> > showIntAtBase (head . show) 2 0xE9
17:18:46 <lambdabot>   No instance for (GHC.Num.Num GHC.Types.Char)
17:18:46 <lambdabot>    arising from the literal `2...
17:19:03 <hpc> > showIntAtBase 2 (head . show) 0xE9 ""
17:19:05 <lambdabot>   "11101001"
17:19:37 <hpc> hmm
17:19:57 <hpc> i don't see how that can get turned into the byte 0x02
17:21:05 <hekate> Hi, I've noticed every time I try to get the latest version of GHC to try to start learning Haskell again, there's all sorts of dependency issues that popup, and I was thinking this was probably because of what I'm using: Ubuntu 10.04. What are you all using that lets you run the latest version of GHC and thus use cool things like Yesod? Arch Linux? Thanks.
17:21:25 <hpc> hekate: what version of ghc do you have now?
17:21:43 <hpc> er, or are trying to get
17:21:55 <noteventime> hekate: Isn't there some Ubuntu PPC for the newer GHC versions?
17:22:20 <hpc> afaik, ubuntu has 7.0.4, which is quite new
17:22:33 <hpc> it's just missing data kinds and some other insane type wizardry
17:22:40 <hpc> but you can definitely yesod with it
17:22:44 <hpc> apt-get install ghc
17:22:50 <noteventime> Err, not PPC, whatever those extra repos are called
17:23:02 <hpc> community, i think
17:23:26 <hekate> noteventime: yes, there's a PPA for haskell-platform that is the pre-req for a lot tools like Yesod web framework which I was trying to start using
17:23:51 <hekate> hpc: Glasgow Haskell Compiler, Version 6.12.1, for Haskell 98, stage 2 booted by GHC version 6.12.1
17:24:32 <hekate> hpc: when I try to get yesod from cabal it always fails, I have to go hunting for various C libs to get it to compile, and even then it fails still
17:24:51 <hekate> So I was thinking maybe I'm using the wrong tools for Haskell?
17:25:13 <hpc> im checking hackage and it's failing hard
17:25:37 <geekosaur> hackage is apparently down (again)
17:25:39 <hpc> hekate: apt-get install libghc-yesod-dev
17:25:53 <hekate> hpc: oh cool, I didn't know about that thanks!
17:26:06 <hpc> apt won't have all the libs, and definitely not the latest versions
17:26:12 <hekate> not there :9
17:26:15 <hpc> but the packages are definitely going to work with each other
17:26:25 <hpc> and the depends are all handled
17:26:34 <hekate> not avail hpc :(
17:26:49 <noteventime> hekate: Otherwise yes, Arch has good Haskell packages :)
17:26:52 <hpc> hmm
17:27:03 <hekate> I'm thinking it's part of haskell-platform (which is in Ubuntu's universal packages for 10.10 and up iirc)
17:27:19 <hekate> that's why I had to try to get haskell-platform from the PPA...which is behind...
17:27:32 <hpc> you said you were on 10.04?
17:27:38 <noteventime> Also, the obvious and unhelpful question, why are you still running 10.04?
17:27:42 <hekate> yes, which is LTS
17:27:42 <hpc> ah, yes
17:27:49 <noteventime> Oh, right
17:28:01 <hekate> Long term support noteventime, so usually packages are still supported for a long time, that's why
17:28:26 <hekate> odd that haskell wasn't, only second time I've come across thsi problem, other time was with silly LaTeX software
17:28:56 <hpc> just googled, ubuntu doesn't have a package for yesod
17:29:06 <jwatzman> Could someone kindly explain why both sides of the "if" branch in this code have to be the same type, even though I have given a type signature which should match both? http://hpaste.org/63945
17:29:28 <hekate> I see. noteventime, I'll see about switching to Arch thanks.
17:29:49 <hpc> jwatzman: oneOrTheOther x = if (x > 0) then 5 else "five"
17:29:56 <hpc> jwatzman: what's the type of oneOrTheOther?
17:29:56 <geekosaur> jwatzman, that's not how types work.  the caller will decide the type, you don;t get to pick one
17:30:30 <noteventime> jwatzman: "Num a => a" means your expression must be able to take on the type of _any_ Num
17:30:31 <byorgey> jwatzman: for something to have type  Num a => a  it must be able to have *any* numeric type.  (42 :: Integer) does not have type  Num a => a.
17:30:51 <byorgey> although 42 by itself does have that type.
17:30:53 <jwatzman> noteventime: byorgey: ah, ok, that makes more sense. thank you
17:30:55 <noteventime> Not just _some_ Num
17:31:39 <byorgey> jwatzman: in any case, the branches of an if expression must have the same type, period.
17:31:44 <byorgey> that is just how if-expressions work.
17:32:07 <hpc> :t \p x y -> if p then x else y
17:32:08 <lambdabot> forall t. Bool -> t -> t -> t
17:32:21 <noteventime> At least until Haskell gets dependent types :>
17:32:33 <hpc> noteventime: that day gets closer and closer all the time :P
17:32:38 <jwatzman> byorgey: right, I was just trying to make that type be "Num a => a" but got it mixed up in my head, and didn't end up doing that.
17:33:02 <byorgey> jwatzman: fair enough.
17:33:48 <noteventime> hpc: I've been asking myself if, with all the type magic around, people will notice once it does or if it will be a by product of mixing a bunch of other type magic :P
17:35:10 <hpc> noteventime: or perhaps what if haskell started as a traditional imperative language
17:35:19 <hpc> then ever so gradually transformed into what it is now
17:37:06 <mhitza> If I where to have a compound value as a key in my Map structure, what should that structure derive?
17:37:17 <DanBurton> hackage seems a bit slow today
17:38:14 <zachk> it seems down for me
17:38:23 <DanBurton> mhitza: Map keys need to be an instance of Ord
17:38:38 <hpc> :t fromList
17:38:39 <lambdabot> forall a (m :: * -> *). (MonadRandom m) => [(a, Rational)] -> m a
17:38:46 <hpc> o.O
17:38:48 <DanBurton> wat
17:38:58 <hpc> :t Map.fromList
17:38:59 <lambdabot> Couldn't find qualified module.
17:39:04 <hpc> :t M.fromList
17:39:04 <DanBurton> :t M.fromList
17:39:05 <lambdabot> forall k a. (Ord k) => [(k, a)] -> M.Map k a
17:39:05 <lambdabot> forall k a. (Ord k) => [(k, a)] -> M.Map k a
17:39:07 <DanBurton> xD
17:39:17 <hpc> the key needs to be Ord
17:39:31 <mhitza> and where I could see exatcly the Ord type class because hackage is down ?
17:39:41 <DanBurton> @info Ord
17:39:41 <lambdabot> Ord
17:39:54 <DanBurton> -_- for some reason I keep hoping that will give useful info
17:40:00 <mhitza> :)
17:40:12 <geekosaur> @src Ord
17:40:13 <lambdabot> class  (Eq a) => Ord a  where
17:40:13 <lambdabot>     compare      :: a -> a -> Ordering
17:40:13 <lambdabot>     (<), (<=), (>), (>=) :: a -> a -> Bool
17:40:13 <lambdabot>     max, min         :: a -> a -> a
17:40:23 <mhitza> thank you geekosaur
17:40:33 <DanBurton> there you go ^ the typical way to define an instance is to imlement "compare"
17:40:41 <DanBurton> the rest can be defined in terms of that
17:40:53 <DanBurton> well actually the typical way is to use "deriving Ord"
17:41:01 <geekosaur> minimal is either compare or (<=), IIRC
17:41:34 <DanBurton> without Hackage I'm so unsure >,<
17:41:41 <geekosaur> (that is, the default provides definitions of all the functions, where compare and (<=) are defined in terms of each other and everything else in terms of compare)
17:42:55 <DanBurton> geekosaur: you're right. compare or <= for the minimal complete definition. I found the docs installed locally on my machine :D
17:44:34 <hpc> it's possible to write the Ord class so a minimal complete definition is any of the 7 functions
17:44:37 <hpc> i think
17:44:42 <hpc> but it's extraordinarily convoluted
17:45:32 <Jafet> Cheat by defining a == b = not $ a < b || b < a
17:45:35 <DanBurton> given Eq is a "superclass" of Ord, sure, it *could* be done.
17:45:43 <DanBurton> (meaning, it is a given)
17:45:48 <byorgey> hpc: heh, you have to define them in a cycle, so each one depends only on the next?
17:45:59 <byorgey> sounds tricky =)
17:46:01 <hpc> byorgey: yeah; the tricky part is max/min
17:46:47 <DanBurton> I can't imagine that would be very efficient
17:47:06 <DanBurton> would ghc magicks make it as efficient as a sane definition?
17:47:08 <hpc> compare a b | a == b = EQ; | max a b == a = GT; | otherwise = LT
17:47:13 <hpc> DanBurton: probably not
17:47:36 <mhitza> ok, and how do I enable the TypeSynonymInstances without the compile time flag?
17:47:50 <DanBurton> mhitza: in your source file, as a LANGUAGE pragma
17:47:53 <Jafet> With the compile-time pragma
17:48:04 <DanBurton> {-# LANGUAGE TypeSynonymInstances #-}
17:48:23 <mhitza> DanBurton, thanks :)
17:48:27 <Jafet> Or the compile-time cabal compile-time flag
17:49:36 <JoeyA> http://www.downforeveryoneorjustme.com/hackage.haskell.org  :(
17:49:56 <hpc> oh hey, back up
17:50:00 <DanBurton> ugh. I'm trying to cabal-dev install something :( my first "serious" cabalized hobby project
17:50:06 <hpc> oh no, just cached
17:50:42 <DanBurton> guess it'll have to wait.
17:51:12 <hpc> DanBurton: cabal install foo --super-secret-server
17:51:15 <hpc> :D
17:52:05 <JoeyA> hackage.haskell.org should be hosted in a bunker
17:52:15 <JoeyA> But then you'll remote in and see something like: *** Exception: Prelude.head: empty list
17:53:18 <JoeyA> I wonder if anyone's written a module for using the type system to encode exception safety properties.
17:53:25 <JoeyA> E.g. interruptible, atomic
17:53:28 <JoeyA> uses STM
17:53:46 <noteventime> hpc: With all the imperative languages pretending to be functional we're probably more likely to see the opposite (in a few years Haskell will be called imperative because that's how all the imperative languages look and they have more political weight behind them by tradition) :)
17:53:54 * DanBurton wonders if --super-secret-server really exists >.>
17:54:35 <noteventime> (Or would that be the dual rather than the opposite)
17:54:43 <JoeyA> Maybe we should do it like It's a Wonderful World.
17:54:53 <JoeyA> Come on, come on, what do you need, pal?  What do you need?
17:55:15 <DanBurton> my professor has interesting things to say about "object oriented". specifically, he says Haskell is object oriented, because the focus is on the data and functions, rather than effects
17:55:17 <JoeyA> I've got 176 packages here, what do ya need?
17:55:50 <DanBurton> JoeyA: got any aeson? :O
17:55:59 <JoeyA> Do I ever?
17:56:04 <JoeyA> err, Do I ever!
17:56:25 <JoeyA> https://github.com/bos/aeson
17:56:37 <DanBurton> ironically, the library I need is actually "hashable"
17:57:04 <OODavo> It occurs to me that if Haskell had some way to support variadic arguments to functions, there'd be far greater orthogonality in the standard libraries. No liftM{2,3,n}, for example.
17:57:06 <JoeyA> https://github.com/tibbe/hashable.git
17:57:28 <DanBurton> OODavo: but it does...in a sort of twisted wa. check out printf
17:57:30 <DanBurton> *way
17:58:00 <DanBurton> JoeyA: I hereby dub thee "gitbot"
17:58:30 <JoeyA> Just tar -xf your packages, and look at the .cabal file to find the source.
17:58:42 <JoeyA> If only I had some way to automate this.
17:59:07 <Jafet> OODavo: see HList
17:59:09 <JoeyA> One annoying thing I encounter when getting packages from repositories: it's unclear where to go for releases.
17:59:22 <byorgey> JoeyA: I'm actually working on a tool to automate that (among other things =)
17:59:35 <DanBurton> nice
17:59:51 * OODavo investigates printf.
18:00:06 <OODavo> That's… terrifying.
18:00:12 <DanBurton> xD
18:00:21 <DanBurton> @google how does printf work in haskell
18:00:23 <lambdabot> http://stackoverflow.com/questions/7828072/how-does-haskell-printf-work
18:00:23 <lambdabot> Title: How does Haskell printf work? - Stack Overflow
18:00:23 <Jafet> I find C's printf more terrifying
18:00:38 <mhitza> is this something doable ( http://codepad.org/by21XPHl ) I'm trying, or just batteling a failed cause ? :)
18:00:39 <DanBurton> the answer here is a little more paltable ^
18:01:06 <OODavo> Okay, so it is possible. Would it also be possible to set up a varidic liftM, through the same mechanic?
18:01:18 <DanBurton> mhitza: actually, that is already defined for you
18:01:24 <mauke> mhitza: why are you trying to redefine the Ord instance?
18:01:25 <quintessence> mhitza: you need to use a newtype if you want your own Ord instance, tuples (of Ord things) have one defined already
18:01:27 <JoeyA> mhitza: Use newtype instead of type.  Oh, and what DanBurton just said.
18:01:38 <byorgey> OODavo: in principle I suppose, but for variadic liftM the usual idea is to use  f <$> x <*> y <*> z <*> ...
18:01:41 <DanBurton> mhitza: I'm pretty sure there are automatic Ord instances for tuples, given an Ord instance for each part of the tuple
18:01:41 <JoeyA> (,) already has an Ord instance.
18:01:43 <mhitza> so I could just use a tuple as a key in a Map?
18:01:43 <JoeyA> :i (,)
18:01:46 <mauke> mhitza: yes
18:01:50 <JoeyA> @info (,)
18:01:50 <lambdabot> (,)
18:01:57 <DanBurton> dat @info
18:02:02 <mauke> there is no @info
18:02:08 <mhitza> :)
18:02:09 <JoeyA> (,).  That's all you know, and all you'll ever need to know.
18:02:28 <JoeyA> @info waffles
18:02:28 <lambdabot> waffles
18:02:42 <mauke> @info do { 42 }
18:02:42 <lambdabot> 42
18:02:44 <JoeyA> @info I'm not very helpful, am I?
18:02:44 <lambdabot>  Parse error at end of input
18:02:44 <geekosaur> oh, is @info turning into @echo by edit distance or something?
18:02:49 <mauke> undo
18:02:49 <noteventime> Does anyone know if there is some formal, interesting way to view the "duality" between algebraic data types ("closed" set of possible values of the type but "open" set of operations) and object oriented types ("open" set of possible values but a "closed" set of operations)?
18:02:56 <Jafet> OODavo: yes, but the resulting liftMn may be too polymorphic to be useful.
18:02:56 <geekosaur> ah
18:03:11 <Jafet> printf is already almost too polymorphic to be useful
18:03:19 <DanBurton> mauke: that...explains a lot.
18:03:47 <Jafet> @instances Ord
18:03:48 <lambdabot> (), (a, b), (a, b, c), (a, b, c, d), (a, b, c, d, e), All, Any, Bool, Char, Double, Dual a, Either a b, First a, Float, Int, Integer, Last a, Maybe a, Ordering, Product a, Sum a, [a]
18:04:19 <DanBurton> Any has an Ord instance? O_o
18:04:28 <mauke> sure, why not?
18:04:30 <noteventime> JoeyA: "Parse error at end of input" (I?), does that mean Lambdabot has no self awareness?
18:04:49 <Jafet> That is not the Any you are looking for.
18:04:53 <JoeyA> @info fix error
18:04:53 <lambdabot> fix error
18:05:02 <nyingen_> > True > False
18:05:03 <lambdabot>   True
18:05:14 <DanBurton> @src Any
18:05:14 <lambdabot> Source not found. My mind is going. I can feel it.
18:05:19 <OODavo> Too polymorphic to be useful?
18:05:30 <DanBurton> :t liftM
18:05:31 <lambdabot> forall a1 r (m :: * -> *). (Monad m) => (a1 -> r) -> m a1 -> m r
18:05:36 <mauke> :t getAny
18:05:37 <lambdabot> Any -> Bool
18:05:45 <Jafet> > Any True `mappend` Any False
18:05:46 <lambdabot>   Any {getAny = True}
18:05:55 <Jafet> > All True `mappend` All False
18:05:56 <lambdabot>   All {getAll = False}
18:06:10 <DanBurton> oh it's *that* Any
18:06:42 <quintessence> @instances Monoid
18:06:42 <lambdabot> (), (a -> b), (a, b), (a, b, c), All, Any, Dual a, Endo a, First a, Last a, Maybe a, Ordering, Product a, Sum a, [a]
18:07:14 <DanBurton> OODavo: since all functions are curried, if you have a 3-arg function and you use liftMn, it's unclear whether you want to lift just 1 argument, or 2
18:07:45 <DanBurton> that's wasn't well phrased, but you get the idea?
18:08:01 <Jafet> Naturally, liftMn must be polymorphic.
18:08:36 <Jafet> You will probably need to give a type annotation for nearly each time you use it. But it's not so bad. I don't think you need UndecidableInstances.
18:08:58 <OODavo> Ah, I see.
18:10:03 <quintessence> you could probably make it take a (proxy) type-level number for how many to lift
18:10:50 <Jafet> If you're feeling kind.
18:11:22 <quintessence> (ba-dum tsch?)
18:12:55 <DanBurton> lol @ the advertising on downforeveryone - web hosting 99.9% uptime :)
18:13:34 <DanBurton> oh burning question
18:13:51 <DanBurton> is there a way besides copy/paste that I can embed README.md into my .cabal file?
18:14:32 <DanBurton> I want the same-ish documentation to show up both on hackage and github
18:14:38 <edwardk> by getting a shell script to copy and paste for you? =)
18:14:39 <DanBurton> at least for the landing page
18:14:46 <DanBurton> edwardk: -_-
18:14:57 <edwardk> the main issue is the formatting is different for each
18:15:16 <edwardk> i had a similar problem, and finally just gave up maintaining README.md's
18:15:28 <DanBurton> aw
18:15:28 <edwardk> i think i still have one for 'ad' but thats about it
18:15:46 <edwardk> i just make the homepage link point to the hackage page for the package
18:15:48 <DanBurton> I guess once it's on hackage your readme.md can just say "look at the cabal page"
18:15:52 <edwardk> yeah
18:16:08 <Jafet> "If it's up"
18:16:20 <edwardk> that and i just let github yell at me for not adding README's
18:16:21 <DanBurton> Jafet +1 clever
18:17:47 <edwardk> OODave: the problem with variadic liftMn is that it really is ambiguous, some times i really do want to only liftM the first two args of 3
18:18:03 <edwardk> OODave: hence the foo <$> bar <*> baz idiom
18:18:10 <edwardk> safer in general
18:19:15 <clintm> I don't guess there's a recent list of hackage mirrors around that someone knows about? I tried bitcheese, but that's apparently down as well.
18:19:45 <DanBurton> conspiracy?
18:19:50 <edwardk> clintm: there is the one cmccann put together to test hackage 2
18:20:20 <clintm> edwardk: I saw that... yesterday, I think, but it didn't have any actual packages in it then.  I'll take a look again though.
18:20:35 <edwardk> i think he said something today about it having everything now
18:21:03 <byorgey> clintm: hackage.factisresearch.com
18:21:16 <clintm> byorgey: awesome - thanks!
18:21:46 <byorgey> also http://hdiff.luite.com/packages/archive/
18:21:53 <byorgey> someone ought to stick those in the /topic
18:22:36 <Jafet> Simply linking to them from hackage should work
18:22:49 <Jafet> If they bother to stay updated, that is
18:22:58 <clintm> Jafet: wait, am I the only one that can't connect to hackage? ugh
18:23:07 <Jafet> Are you?
18:23:12 <Veinor> clintm: nope :(
18:23:14 <clintm> Jafet: apparently.
18:23:22 <clintm> oh, apparently *not*!
18:24:03 <JoeyA> Someone post an article on Slashdot about Haskell getting taken down by SOPA.  A lil publicity can't be a bad thing.
18:25:38 <nyingen_> no, we need to avoid success at all costs
18:25:49 <nyingen_> in fact, maybe that's why hackage is down
18:26:17 <DanBurton> we were getting a little too successful
18:26:46 <cmccann> edwardk, it has the full index but no tarballs
18:26:50 <cmccann> probably not too useful :]
18:27:32 <edwardk> cmccann: doh
18:44:28 * DanBurton thinks it would be cool to distribute packages via torrent
18:45:07 <DanBurton> actually it would be cool to host the whole web as sort of a torrent. all static-y content, anyways
18:46:12 <clsmith> torrents are kind of inefficient for small files :p
18:46:24 <clsmith> does anyone know if it's possible to get ghc to output *unoptimised* ghc core?
18:47:03 <DanBurton> wait when it says "archive of just the latest versions of all the packages (230MB tar file)"...does that mean *all* of the libraries on Hackage, in only their latest version, can be compressed into 230MB?
18:49:38 <Eduard_Munteanu> clsmith: maybe  -ddump-prep ?
18:50:51 <Jafet> DanBurton: I find that surprisingly large
18:51:24 <Jafet> Probably a few packages like gtk2hs bumping up the mean
18:55:52 <clsmith> Eduard_Munteanu: hmm, that looks very close, but it doesn't quite look like genuine core. which is odd.
18:56:10 <clsmith> i.e., it has Rec instead of %rec, and no %module, and so on. it's quite different to -fext-core
18:56:39 <Jafet> The GHC manual has all the needless verbosity options somewhere
18:59:57 <Jafet> http://www.haskell.org/ghc/docs/latest/html/users_guide/options-debugging.html
19:00:11 <Jafet> I propose that you just Goldilocks it.
19:02:11 <clsmith> it's weird though, cause -ddump-ds and -ddump-prep are similar but totally different from -fext-core, and -fext-core matches the ghc core described in "An External Representation for the GHC Core Language"
19:12:58 <nyingen_> @quote
19:12:58 <lambdabot> Dijkstra says: "It is practically impossible to teach good programming style to students that have had prior exposure to BASIC: as potential programmers they are mentally mutilated beyond hope of
19:12:58 <lambdabot> regeneration."
19:13:31 <Jafet> Don't tell augustsson
19:13:44 <DanBurton> @quote spj
19:13:44 <lambdabot> spj says: "In summary, Haskell is a language everybody talks about and nobody uses."
19:14:04 <otters> @quote Java
19:14:04 <lambdabot> gwern says: The Java programmers will welcome us as liberators! I estimate that we will need 50,000 haskellers at most and will be able to wind up the occupation quickly
19:14:10 <nyingen_> I encountered BASIC recently. All the example code in this DSP book is written in it
19:14:16 <shachaf> preflex: seen augustss
19:14:16 <preflex>  augustss was last seen on #haskell 102 days, 3 hours, 47 minutes and 11 seconds ago, saying: > div (-1) 2
19:14:24 <otters> aww
19:14:29 <otters> > div (-1) 2
19:14:30 <lambdabot>   -1
19:14:40 <shachaf> Hmph.
19:14:43 <shachaf> Gone the way of dons.
19:14:50 <DanBurton> u_u
19:14:53 <otters> v_v
19:15:16 <shachaf> This is all off-topic, by the way.
19:15:23 * shachaf part of problem.
19:15:34 <gwern> disappointing. I thought maybe that div expression sends a terminator to your house
19:15:42 * DanBurton blames lambdabot's @quote feature
19:15:48 <shachaf> gwern: It does.
19:15:57 <DanBurton> > quot (-1) 2
19:15:58 <lambdabot>   0
19:19:44 <JoeyA> Is there an Applicative instance or something I can use to combine left-folding functions?
19:20:01 <JoeyA> Namely, I want to fold over a big lazy list to do some counting.
19:20:16 <JoeyA> e.g. data Stat = Stat {totalCount :: Int, totalSize :: Int}
19:20:55 <JoeyA> (make that !Int)
19:21:27 <DanBurton> "combine left-folding functions"? so you want to take a "count" and a "size" and combine them into one traversal?
19:21:48 <JoeyA> Well, I want to do one traversal, but I'd like to define the folding functions separately if I can.
19:22:01 <JoeyA> Count -> Item -> Count, and Size -> Item -> Size
19:22:08 <DanBurton> sounds like the stuff of arrows
19:22:10 <JoeyA> Where type Count = Int, and type Size = Int (in this case)
19:23:10 <JoeyA> (Count -> Item -> Count) -> (Size -> Item -> Size) -> ((Count, Size) -> Item -> (Count, Size))
19:23:16 <JoeyA> That's a specific instance.
19:24:15 <JoeyA> I suppose the general instance would be: ((a -> b) -> x -> (a -> b)) -> (a -> x -> a) -> (b -> x -> b)
19:24:32 <JoeyA> (I know some of those parens are redundant)
19:24:38 <DanBurton> @hoogle a x (a y x) -> a z (a y z) -> (a (x,z) (a y (x,z))
19:24:38 <lambdabot> Parse error:
19:24:39 <lambdabot>   a x (a y x) -> a z (a y z) -> (a (x,z) (a y (x,z))
19:24:39 <lambdabot>                                 ^
19:24:47 <DanBurton> @hoogle a x (a y x) -> a z (a y z) -> (a (x,z) (a y (x,z)))
19:24:48 <lambdabot> No results found
19:24:50 <DanBurton> aw
19:24:55 <JoeyA> @hoogle ((a -> b) -> x -> (a -> b)) -> (a -> x -> a) -> (b -> x -> b)
19:24:56 <lambdabot> No results found
19:25:28 <JoeyA> @djinn ((a -> b) -> x -> (a -> b)) -> (a -> x -> a) -> (b -> x -> b)
19:25:30 <lambdabot> f _ _ a _ = a
19:25:36 <JoeyA> pfft
19:25:36 <alpounet> hah
19:25:38 <DanBurton> wat
19:26:00 <DanBurton> I guess that makes sense..
19:26:01 <MichaelBurge> Is there a guide somewhere on compiling a new GHC on an ancient Linux, by recompiling all needed libraries in your home directory?
19:26:17 <DanBurton> :t &&&
19:26:18 <lambdabot> parse error on input `&&&'
19:26:22 <DanBurton> :t (&&&)
19:26:22 <alpounet> :t (***)
19:26:23 <lambdabot> forall (a :: * -> * -> *) b c c'. (Arrow a) => a b c -> a b c' -> a b (c, c')
19:26:23 <lambdabot> forall (a :: * -> * -> *) b c b' c'. (Arrow a) => a b c -> a b' c' -> a (b, b') (c, c')
19:26:58 <alpounet> JoeyA, maybe (***) would be useful for you here
19:26:59 <DanBurton> yeah *** is what you want
19:27:12 <nyingen_> MichaelBurge: I was in that situation a couple of days ago. I gave up
19:27:13 <DanBurton> just flip Count -> Item -> Count
19:27:20 <DanBurton> so that its Item -> Count -> Count
19:27:35 <DanBurton> wait a minute
19:27:41 * DanBurton goes off to play in ghci
19:27:47 <copumpkin> > let (!$@#) = (+) in 5 !$@# 6 -- when you're angry at haskell
19:27:48 <lambdabot>   11
19:30:20 <DanBurton> @hoogle (a x y, a x b) -> a x (y,b)
19:30:21 <lambdabot> No results found
19:30:38 <JoeyA> :t (***)
19:30:38 <lambdabot> forall (a :: * -> * -> *) b c b' c'. (Arrow a) => a b c -> a b' c' -> a (b, b') (c, c')
19:31:00 <DanBurton> I swear the thing I just hoogled is a thing
19:31:17 <DanBurton> an arrow x -> y, and an arrow x -> b, you can combine them into an arrow x -> (y,b)
19:31:31 <JoeyA> @djinn ((a -> b) -> x -> (a -> b)) -> (a -> x -> a) -> (b -> x -> b)
19:31:31 <lambdabot> f _ _ a _ = a
19:31:37 <JoeyA> oops
19:31:50 <JoeyA> @djinn (a -> x -> a) -> (b -> x -> b) -> ((a,b) -> x -> (a,b))
19:31:51 <lambdabot> f a b (c, d) e = (a c e, b d e)
19:31:58 <DanBurton> @pl \(f,g) x -> (f x, g x)
19:31:58 <lambdabot> uncurry (liftM2 (,))
19:32:15 <clsmith> i want a tool in my text editor so i djinn the selected function type
19:32:26 <alpounet> copumpkin, haha
19:32:30 <clsmith> instant boilerplate
19:32:35 <MostAwesomeDude> What's djinn do, anyway?
19:32:41 * shachaf wonders how long it'll take to build GHC.
19:32:45 <copumpkin> MostAwesomeDude: it proves things for you
19:32:49 <MostAwesomeDude> Find the simplest function satisfying a signature?
19:32:51 <DanBurton> @pl \f g x -> (f x, g x)
19:32:51 <lambdabot> liftM2 (,)
19:33:05 <alpounet> DanBurton, it's &&&
19:33:07 <roconnor_> what is hdiff.luite.com ?
19:33:16 <DanBurton> alpounet: but &&& isn't all there is to it
19:33:22 <clsmith> that's what @djinn does, yeah. i think djinn in general does more complex stuff, but i don't understand that stuff :p
19:33:40 <DanBurton> alpounet: wait, never mind. &&& is all there is to it.
19:33:41 <JoeyA> MostAwesomeDude: It finds an implementation satisfying a given type signature.
19:33:49 <JoeyA> A type signature can also be thought of as a proof.
19:34:01 <shachaf> roconnor_: http://hdiff.luite.com/ has a reasonable explanation. :-)
19:34:01 <alpounet> heh, yeah, unless i'm missing something it is
19:34:04 <JoeyA> For example, a -> b -> a can be read as: A implies that... B implies A.
19:34:11 <copumpkin> JoeyA: the proof is the value
19:34:24 <clsmith> the type is the proposition?
19:34:33 <shachaf> It's a diff thing that luite runs that also has a mirror of at least some of Hackage.
19:34:43 <clsmith> i never quite got the implication of curry-howard
19:34:56 <shachaf> The implication, eh?
19:35:02 <shachaf> You might call it "the function of curry-howard".
19:35:10 <monochrom> hahaha
19:35:14 <clsmith> lol
19:35:15 <JoeyA> lol
19:36:19 <roconnor_> shachaf: good observation
19:38:47 <hpaste> DanBurton pasted “Playing with arrows” at http://hpaste.org/63948
19:40:52 <JoeyA> Cool, I didn't know you could do data declarations in GHCi now.
19:41:04 <DanBurton> yeah ghc 7.4 goodness
19:42:16 <monochrom> only thing you can't do is "module X where"
19:42:43 <monochrom> also, {-# pragma #-} is ignored
19:42:51 <JoeyA> But you can lift cars like they're plush pillows.
19:43:09 <monochrom> but if you're in the mood of hand-typing a type class and its 100 instances right in ghci, you can
19:43:19 <DanBurton> @faq can haskell lift cars like they're plush pillows?
19:43:19 <lambdabot> The answer is: Yes! Haskell can do that.
19:43:31 <JoeyA> @type lift cars
19:43:32 <lambdabot> Not in scope: `cars'
19:43:35 <DanBurton> Mr. Curry, my hat's off to you
19:43:52 <JoeyA> @type lift
19:43:53 <monochrom> I can't lift cars like they're plush pillows, if the plush pillows are of the same mass as the cars
19:43:53 <lambdabot> forall (m :: * -> *) a (t :: (* -> *) -> * -> *). (MonadTrans t, Monad m) => m a -> t m a
19:44:05 <JoeyA> heh
19:44:21 <JoeyA> What if you're on the moon?
19:45:08 <DanBurton> with reference to the other side of the world, by "dropping" a car you are "lifting" it, because it goes in the "up" direction for the other side of the world.
19:45:55 <JoeyA> You mean there are people on the other side of the world?
19:46:21 <JoeyA> How do they stay on the ground?
19:47:02 <JoeyA> </offtopic banter>
19:48:10 <JoeyA> DanBurton: Thanks for pasting the arrow example.
19:48:23 <mhitza> can someone clarify me why I get the expected type ([Count] -> [Count]) instead of Int http://hpaste.org/63949 ?
19:50:01 <JoeyA> I think you want maximum, not max.
19:50:02 <JoeyA> :t max
19:50:03 <lambdabot> forall a. (Ord a) => a -> a -> a
19:50:05 <JoeyA> :t maximum
19:50:06 <lambdabot> forall a. (Ord a) => [a] -> a
19:50:13 <DanBurton> :t elems
19:50:15 <lambdabot> forall i e. (Ix i) => Array i e -> [e]
19:50:15 <JoeyA> > (max 1 2, max [1,2,3])
19:50:16 <lambdabot>   Overlapping instances for GHC.Show.Show ([t] -> [t])
19:50:16 <lambdabot>    arising from a use ...
19:50:17 <dev360> I have a noob question. Im importing a library that I wrote that has a datatype that has a bunch of fields, but it doesnt seem to recognize any of the fields in this external program. Is there a special syntax to import the fields? When I type 'myFieldName instanceOfDataType' then it says not in scope: myFieldName.
19:50:19 <DanBurton> :t M.elems
19:50:20 <lambdabot> forall k a. M.Map k a -> [a]
19:50:27 <JoeyA> > (max 1 2, maximum [1,2,3])
19:50:28 <lambdabot>   (2,3)
19:50:39 <DanBurton> :t M.filter
19:50:40 <lambdabot> forall a k. (Ord k) => (a -> Bool) -> M.Map k a -> M.Map k a
19:50:43 <mhitza> yeah, JoeyA
19:50:48 <mhitza> thanks
19:50:59 <JoeyA> dev360: import Foo(Thing(..))
19:51:14 <JoeyA> Or import Foo(Thing(Constructor1, Constructor2))
19:51:27 <JoeyA> You'll also need to do the same in your exports
19:53:21 <dev360> JoeyA: Thanks, I was missing it in the exports!
19:53:38 <CodeWeaverX> Is hackage still outta whack?
19:54:05 <monochrom> oh, it is not responding. interesting
19:54:15 <DanBurton> CodeWeaverX: it appears so
19:54:16 <CodeWeaverX> It's been out all day.  Most frustrating.
19:54:19 <monochrom> this is now happening once a month or something
19:54:32 <DanBurton> I wonder if hackage 2.0 improves on this
19:54:53 <DanBurton> or if it's a software issue at all
19:56:20 <hpaste> DanBurton annotated “Playing with arrows” with “Playing with arrows (more) -- JoeyA” at http://hpaste.org/63948#a63950
19:59:12 <DanBurton> question about modules: is it possible for things in the "examples" folder to be run from the examples folder and also know where to find the stuff in the src folder without precompiling it? https://github.com/DanBurton/netspec
19:59:13 <JoeyA> DanBurton: Interesting.  I'll see if I can write a three-argument version.
20:00:13 <alpounet> DanBurton, using the -i option ?
20:00:39 <alpounet> smth like that
20:02:50 <DanBurton> nice, I think that does the trick
20:03:04 <DanBurton> runhaskell -i.:../src foo.hs
20:03:19 <alpounet> yeah
20:03:47 <alpounet> was using it to test multiple packages at once (like client & server) that shared some code
20:05:00 <DanBurton> cabal doesn't provide any "unregister" feature does it? You just have to do it with ghc-pkg unregister?
20:05:12 <alpounet> no, cabal doesn't
20:05:46 <nyingen_> preflex: seen dcoutts
20:05:46 <preflex>  dcoutts was last seen on #haskell 12 hours, 37 minutes and 39 seconds ago, saying: chrisdone: to build the server? 7.0 probably easiest
20:05:53 <alpounet> haven't been caring much about these stuffs since i started using cabal-dev though :p
20:06:19 <DanBurton> cabal-dev is kinda hard to use today >,<
20:06:32 <DanBurton> what with hackage down and all
20:10:35 <alpounet> go straight to the repositories hah
20:19:34 <dev360> I have another noob question.. I dont know if the structure of my code is wrong, but I have a series of case statements where I want to do something if a field is true, but do nothing if its false.. I cant figure out how to write this. https://gist.github.com/c79702fc05159be988f5
20:20:06 <DanBurton> dev360: sounds like you want "when" from Control.Monad
20:21:54 <DanBurton> dev360: also it would be better to replace the isNothing and isJust guards with another case statement
20:22:04 <DanBurton> dev360: I'll work on an annotated version
20:23:23 <quintessence> dev360: "return ()" is the standard do-nothing action in any monad
20:23:49 <DanBurton> dev360: remember, "return" in Haskell doesn't pop you all the way out of the funtion like it does in other languages
20:24:02 <dev360> quitessence - ok, my concern was that it would pre-empt the rest of the case statements.. or is that assumption wrong?
20:24:17 <dev360> oh okay I see. Think I read that somewhere but it escaped my mind
20:24:17 <DanBurton> dev360: yep, wrong ;)
20:25:08 <astor> hackage down?
20:25:29 <DanBurton> astor: sadly, yes. It's been down for a good while today
20:25:57 <dev360> DanBurton - ok so I think I got it to work with just False -> return () .. as opposed to when ... I guess its not as short, but it compiles :)
20:27:00 <shachaf> dev360: That function is very unidiomatic.
20:27:19 <hpaste> DanBurton pasted “dev360 -- a little cleaner” at http://hpaste.org/63951
20:27:51 <DanBurton> yeah the processQuoteTimeSeries taking in a string to represent the field is rather bad form
20:28:04 <shachaf> Ugh, I didn't even notice that.
20:28:11 <DanBurton> lol.
20:28:13 <shachaf> DanBurton: There is certainly more rewriting to be done.
20:28:28 <hpaste> “Joey Adams” annotated “Playing with arrows” with “Playing with arrows (5 fields)” at http://hpaste.org/63948#a63952
20:28:28 <dev360> shachaf - Im open to suggestions - I havent developed sensibility for haskellisms yet :) .. thanks for your input btw
20:28:32 <DanBurton> shachaf = hlint++
20:29:03 <shachaf> More like hlint-- if I provide messages like "There is certainly more rewriting to be done.".
20:29:40 <DanBurton> JoeyA: lol :)
20:29:54 <JoeyA> DanBurton: liftStat was a good idea, thanks.  Now I'll try to figure out how to compose them in a more reasonable fashion
20:29:59 <dev360> DanBurton: thanks for taking the time - I really appreciate it!
20:30:20 <JoeyA> other than saying liftStat (fa, (fb, (fc, (fd, fe)))) Stat{..}
20:31:05 <DanBurton> JoeyA: yeah, frankly, the arrow functions aren't very pretty for dealing with functions in more than one argument
20:33:24 <DanBurton> dev360: if hackage weren't down I'd recommend you cabal install hlint
20:33:54 <DanBurton> also, make use of ghci -Wall as sort of a second hlint
20:34:10 <dev360> DanBurton: oh I see. Is there a vim extension for it by any chance?
20:34:23 <DanBurton> quite possible, I'm not aware of any though
20:35:27 <DanBurton> google reveals this: https://github.com/vim-scripts/hlint
20:35:54 <dev360> nice
20:36:11 <DanBurton> personally I prefer emacs ;)
20:36:41 <dev360> Ive never tried. Honestly, I feel like I got into vim almost by peer pressure but I like it :p
20:37:28 <DanBurton> I used to be a vimmer, but then I was a TA for my college's intro to programming class, and the professor had the students using emacs
20:37:51 <DanBurton> I love that professor, he taught C++ as if it were Racket xD
20:38:20 <dev360> Im not familiar with racket
20:38:43 <levi> How do you teach C++ as if it were racket?
20:38:54 <levi> Racket is the language formerly known as PLT Scheme
20:38:59 <mjrosenb> dev360: new scheme
20:39:21 <DanBurton> that's why it was so awesome
20:39:46 <DanBurton> he didn't teach them mutation
20:39:51 <DanBurton> until near the very end of the class
20:40:09 <hpaste> “Joey Adams” annotated “Playing with arrows” with “Converting liftStat to accStat using <$> and <*>” at http://hpaste.org/63948#a63954
20:40:18 <DanBurton> which utterly confused a few people that had previous experience with C
20:40:30 <levi> Are there any course notes or anything for this C++ course?  I'm intrigued.
20:40:40 <levi> (online, I mean)
20:40:59 <DanBurton> JoeyA: oohh pretty. Should've known applicative magic was the way to go
20:41:43 <DanBurton> the function instance of Applicative and Monad still weirds me out. I really need to get used to it.
20:41:53 <JoeyA> Well, liftStat won't be quite as pretty once I drop in real names like statCount and the like.
20:42:54 <DanBurton> JoeyA: yeah, it's weird but it seems like there is yet a better way
20:43:18 <JoeyA> (A -> A) -> (Stat -> Stat), (B -> B) -> (Stat -> Stat)
20:43:34 <JoeyA> I suppose those could be combined with (.).
20:43:48 <JoeyA> These functions can be defined somewhat conveniently with record syntax, I think.
20:44:57 <JoeyA> mapA :: (A -> A) -> (Stat -> Stat); mapA f s@Stat{a=a} = s{a=f a}
20:45:23 <DanBurton> I bet lenses and a state monad would clean things up a tiny bit. Not sure if it's worth the added complexity though
20:45:38 <JoeyA> I think my best bet is to simply define the fold functions separately, and define accStat in-place.
20:45:53 <DanBurton> yeah, guess so
20:45:55 <JoeyA> I still get the separation I want.
20:46:07 <SubtleArray> Hi folks. I've been struggling with this problem for a few hours now... Is there a way to bind (set / define) a variable in an if statement? Example: If a = 10 then let b = 20 else b = 30.
20:46:28 <DanBurton> SubtleArray: well sure. you just did. :) the problem is they lose scope
20:46:38 <Jafet> b = if a == 10 then 20 else 30
20:47:10 <SubtleArray> Wait, let me try that...
20:47:13 <DanBurton> SubtleArray: that's the trick ^ just remember if statements are an expression that evaluate to a value
20:47:45 <Jafet> Actually, you may find it rewarding to return to C++ and rewrite programs in SSA form.
20:48:00 <DanBurton> SSA?
20:48:06 <SubtleArray> Jafet: Nah. What fun would that be? >:P
20:48:15 <Jafet> Single-assignment.
20:48:29 <DanBurton> where does the other S come from? o_O
20:48:29 <SubtleArray> Jafet: Thank you for the help though. That did the trick.
20:48:53 <Jafet> @google single static assignment
20:48:55 <lambdabot> http://en.wikipedia.org/wiki/Static_single_assignment_form
20:48:55 <lambdabot> Title: Static single assignment form - Wikipedia, the free encyclopedia
20:49:22 <Jafet> @google is my friend
20:49:24 <lambdabot> http://www.youtube.com/watch?v=7-NOZU2iPA8
20:49:25 <lambdabot> Title: Jesus Is My Friend by Sonseed - YouTube
20:49:33 <DanBurton> ...
20:49:36 <SubtleArray> lol
20:50:56 <JoeyA> That's the Christian rick-roll.
20:51:00 <nyingen_> I wrote a lambdabot plugin that pulls the lead paragraph from wikipedia articles, but it fails to find the lead in about 1/3 of cases
20:51:15 <nyingen_> also it doesn't handle disambig pages
20:51:54 <nyingen_> I would have submitted it to the lambdabot maintainer, but I was too lazy to address these deficiencies
20:52:03 <DanBurton> wikipedia should have their own url shortener service
20:52:25 <DanBurton> wiki.pe/asdf
20:53:04 <DanBurton> nyingen_: you should throw the code at Cale and see if he does something with it
20:53:27 <hpaste> “Joey Adams” annotated “Playing with arrows” with “Defining accStat directly, using RecordWildCards to make it a little less tedious” at http://hpaste.org/63948#a63956
20:53:35 <Jafet> People should learn to touch type
20:53:51 <JoeyA> The quick brown fox jumps over the lazy dog.
20:54:00 <JoeyA> The quick brown fox jumps over the lazy dog.
20:54:14 <DanBurton> no fair, the second one you could've just pressed the up arrow
20:54:16 <nyingen_> able was i ere i saw elba
20:54:42 <JoeyA> The first one I typed in QWERTY, the second one I typed in Dvorak.
20:55:00 <nyingen_> are you a dvorak typist?
20:55:05 <JoeyA> nyingen_: No fair, you could have used reverse
20:55:24 <ddarius> @google functional programming ssa
20:55:26 <lambdabot> http://www.cs.princeton.edu/~appel/papers/ssafun.ps
20:55:40 <ddarius> @google functional programming static single information
20:55:45 <lambdabot> http://homepages.inf.ed.ac.uk/stg/workshops/TFP/papers/SingerTFP2003.pdf
20:55:45 <lambdabot> Title: Static Single Information from a Functional Perspective
20:55:53 <JoeyA> nyingen_: I learned Dvorak and used that for a long time, then went back to QWERTY for better compatibility.
20:56:03 <DanBurton> > let xs = "able was i er" in xs ++ drop 1 (reverse xs)
20:56:04 <lambdabot>   "able was i ere i saw elba"
20:56:26 <JoeyA> Vim and Emacs assume QWERTY in their default bindings for directional letters.
20:56:46 <ddarius> It takes very little to make vim usable with Dvorak.
20:57:01 <nyingen_> I'm a dvorak typist, and I just use the vim keys as-is
20:57:08 <DanBurton> scumbag JoeyA, learns dvorak but doesn't reconfigure vim/emacs
20:57:13 <nyingen_> their not being on the home row in dvorak doesn't seem to make much difference to me
20:57:54 <JoeyA> I hardly even use the directional keys, anyway.
20:58:15 <nyingen_> the real problem I ran into is nethack
20:58:21 <JoeyA> (err, directional letters.  I usually use the normal arrow keys)
20:58:30 <shachaf> The only key I use in vim is '.'.
20:58:31 <nyingen_> I had to install a hotkey to switch to qwerty so I could play nethack
20:58:32 <shachaf> I typed a really good command at the beginning.
20:58:41 <cmccann> nyingen_, would you like your possessions identified?
20:58:56 <nyingen_> cmccann: hah. yeah, I lost some characters due to forgetting to switch before pounding keys
20:59:20 <cmccann> t - a cursed scroll of unsafePerformIO
20:59:32 <ddarius> shachaf edits his .vimrc in emacs so that when vim opens it writes out what he wants.
20:59:39 <nyingen_> yoou know, I don't know why unsafePerformIO is so maligned
21:00:01 <DanBurton> because it's not purely functional, like everything else is
21:00:07 <Jafet> It's not maligned. It's just chaotic neutral.
21:00:08 <DanBurton> it offers an escape hatch from the ivory tower
21:00:11 * ddarius assumes nyingen_ doesn't know why unsafeCoerce is so maligned either.
21:00:19 <nyingen_> seems to be a bit like a bow and arrow: "now, don't go shooting your sister with this..."
21:00:31 <nyingen_> i.e., the horrors are almost entirely theoretical
21:00:36 <shachaf> ddarius: What I want happens to be to edit my .emacs so that when emacs opens it it writes out what I want.
21:00:55 <Sgeo> nyingen_, except every place except for one small area is now your sister.
21:01:08 <DanBurton> nyingen_: it's not the horrors so much as the principle. Haskell is touted as this "pure" experience, but then there's unsafePerformIO
21:01:21 <shachaf> It is more than principle.
21:01:40 <DanBurton> shachaf: elaborate?
21:01:50 <cmccann> well, the principle is that code should behave sensibly
21:02:06 <nyingen_> I would be more concerned about haskell if it *didn't* have something like unsafePerformIO
21:02:08 <cmccann> which is of more than theoretical value I think
21:02:12 <DanBurton> the Princess Bride principle? xD
21:02:12 <shachaf> cmccann: If you're principled you won't use IO at all, either with unsafePerformIO or without it. :-)
21:02:38 <DanBurton> @quote princess.bride
21:02:38 <lambdabot> mzero says: functional programming has a property that is often lacking in other languages... at dinner last night we were discussing it, and I dubbed it: "The Princess Bride" property --- which is,
21:02:38 <lambdabot> that a piece of code means what you think it means
21:03:26 <JoeyA> I'm less concerned about unsafePerformIO as I am about concurrency and exceptions and how it's hard to write reliable programs that handle these correctly.
21:03:42 <nyingen_> have you tried Erlang?
21:03:46 <JoeyA> Nope
21:03:56 <cmccann> nyingen_, that seems an extremely odd position, I'd much prefer that unsafePerformIO be completely unnecessary
21:04:01 <DanBurton> Haskell libraries basically provide Erlang, but well-typed
21:04:17 <MostAwesomeDude> cmccann: Not a fan of trace?
21:04:34 <nyingen_> cmccann: it seems extremely useful, even unavoidable, in some cases
21:04:40 <Jafet> Haskell does not have unsafePerformIO.
21:04:41 <JoeyA> There's plenty of hidden dangers when doing stuff in the IO monad.  Some operations are interruptible, while others aren't.
21:04:48 <Jafet> Glasgow Haskell has unsafePerformIO.
21:04:52 <cmccann> MostAwesomeDude, it's still a hack. proper debugging is better.
21:05:05 <DanBurton> cmccann: it is completely unnecessary, unless you want to implement efficient IO libraries like the Par monad and whatnot
21:05:15 <JoeyA> The type system won't stop you from missing a Control.Exception.bracket.
21:05:22 <MostAwesomeDude> cmccann: By "proper," do you mean only debugging in the IO monad?
21:05:31 <Jafet> It is sometimes a bad idea to refer to Glasgow Haskell as Haskell, because this can confuse people.
21:05:32 <DanBurton> most Haskellers never need to reach for unsafePerformIO, just leave it to a couple library-writers
21:05:33 <MostAwesomeDude> Because many of us try to not live entirely in IO.
21:05:43 <cmccann> MostAwesomeDude, no, I mean debugging provided by the runtime. it's nothing something that should be impl
21:05:45 <cmccann> ergh
21:05:55 <cmccann> should be implemented manually.
21:05:58 <Ayvee> DanBurton: Erlang's supervision trees too?
21:05:59 <DanBurton> JoeyA: it could though
21:06:23 <shachaf> unsafePerformIO is justified for cases like http://reddit.com/comments/jarp0
21:06:24 <MostAwesomeDude> cmccann: Sometimes one just needs a printf() in the middle of an algorithm. I'm very glad that such a thing exists.
21:06:31 <DanBurton> Ayvee: I don't think any libraries provide that out of the box, but I could imagine it being implemented
21:06:35 <adnauseam> @help
21:06:35 <lambdabot> help <command>. Ask for help for <command>. Try 'list' for all commands
21:06:40 <nyingen> I would love it if I could do Erlang-style programming in Haskell (minus the dynamic typing)
21:06:45 <adnauseam> @help list
21:06:45 <lambdabot> list [module|command]
21:06:45 <lambdabot> show all commands or command for [module]. http://code.haskell.org/lambdabot/COMMANDS
21:06:53 <adnauseam> @help ghc
21:06:53 <lambdabot> ghc. Choice quotes from GHC.
21:07:02 <adnauseam> @help ghc interactive
21:07:02 <lambdabot> ghc. Choice quotes from GHC.
21:07:08 * adnauseam scratches head 
21:07:20 <wavewave> hi.
21:07:23 <nyingen> @hc
21:07:23 <lambdabot> Maybe you meant: ghc rc
21:07:25 <nyingen> @ghc
21:07:25 <lambdabot> ghc says: Urk! Inventing strangely-kinded void TyCon: [..] (* -> *) -> * -> *
21:07:26 <shachaf> adnauseam: If you want to experiment with lambdabot it might be simpler to do it in /msg.
21:07:28 * adnauseam waves
21:07:40 <cmccann> nyingen, I still fail to see how unsafePerformIO is ever "extremely useful" except for very elaborate performance tuning and technically pure FFI bindings
21:07:49 <adnauseam> hah, aye, better do
21:07:52 <nyingen> cmccann: that's what I mean, though
21:07:59 <q0tw4> I can't connect to hackage.haskell.org :(
21:08:17 <DanBurton> shachaf: dat link T_T
21:08:18 <Ralith> Sgeo: as I understand it, monadic flow control is not particular to IO.
21:08:42 <adnauseam> gah, how do i start ghc 7 in interactive mode ?
21:08:47 <Sgeo> Sure, but all IO stuff is monadic.
21:08:52 <wavewave> q0tw4: I can't, either.
21:08:55 <shachaf> adnauseam: ghci or ghc --interactive
21:09:05 <Ralith> is that not merely incidental?
21:09:18 <adnauseam> oh, perfect thanks
21:09:21 <shachaf> Hackage is currently down. Maybe someone should put that in the topic.
21:09:26 <shachaf> Wait, no one ever reads the topic.
21:09:29 <Ralith> one could perhaps make a monadic I/O library for another language, thereby mitigating the need for verbose wrapping syntax.
21:09:54 <DanBurton> put up a banner on hackage.haskell.org -- oh wait
21:10:04 <Sgeo> Ralith, sure, but Haskell does it by default.
21:10:12 <Sgeo> So it is a cultural issue, sure.
21:10:21 <Ralith> laziness aside, that's an artifact of the standard library, not the language.
21:10:32 <Ralith> insofar as that the two are separate, which I would argue they certainly are.
21:10:34 <Jafet> We could recruit volunteers in this channel to constantly answer people who report that hackage is down
21:10:44 * shachaf nominates Jafet.
21:10:49 <Ralith> because it is vastly easier to extend or replace the standard library than the language itself.
21:10:52 * DanBurton nominates shachaf
21:11:01 <shachaf> Laziness has very little to do with how IO is done in Haskell.
21:11:18 <shachaf> This channel has too much off-topic discussion.
21:11:22 <shachaf> We need a dictator.
21:11:29 * DanBurton nominates lambdabot
21:11:44 <Sgeo> shachaf, you missed the discussion elsewhere, in which I think Ralith and I both thought the other had incorrect views relating to such things
21:11:46 <ski> (too much ?)
21:12:02 <DanBurton> one thing that bites you in IO that you think is laziness (which is wrong) is that the default is line buffering
21:12:10 <DanBurton> so if you do putStr, it won't necessarily show up
21:12:15 <Jafet> Yes, we spend all day discussing monad tutorials, unsafePerformIO and hackage mirrors.
21:12:19 <wavewave> do we have a mirror of hackage now?
21:12:29 <DanBurton> @where hackagemirror
21:12:29 <lambdabot> I know nothing about hackagemirror.
21:12:37 <Sgeo> As far as I can tell, the most incorrect beliefs on both sides are what we thought the other was thinking.
21:12:39 <Ralith> DanBurton: that's much more entertaining in strict languages where people can't rationalize it at *all*
21:12:41 <cmccann> dcoutts has a full mirror running on hackage2, I think
21:12:42 <Sgeo> I may be mistaken in that too.
21:12:46 <Ralith> Sgeo: sounds right to me!
21:12:53 <cmccann> my hackage2 doesn't have the tarballs still so is of little use :P
21:13:01 <DanBurton> Ralith: most strict languages don't have line buffering on stdout by default though
21:13:12 <Ralith> DanBurton: tell that to stdio.h
21:13:18 <mhitza> http://hackage.factisresearch.com was postead earlier in here
21:13:33 <ddarius> The Android soft keyboard doesn't have square brackets!
21:13:42 <Ralith> and iostreams, of course
21:13:45 <wavewave> cmccann: I need to see some documentation, so probably your server can be useful for that purpose.
21:14:08 <Ralith> DanBurton: really, what strict languages are you thinking of? I can't come up with any whose conventional simple terminal I/O bindings aren't buffered.
21:14:17 <cmccann> wavewave, nope, there's no builds either so no haddocks. sorry :T
21:14:22 <DanBurton> @where+ hackagemirror http://hackage.factisresearch.com/package/monadacme
21:14:22 <lambdabot> Done.
21:14:28 <cmccann> it shows the packages and the dependencies and that's about it
21:14:29 <wavewave> cmccann: I see ;-)
21:15:54 <wavewave> mhitza: Thanks.. however, it doesn't seem to have haddock document.. :-T
21:16:04 <cmccann> yeah, no builds there either
21:16:25 <cmccann> you can set cabal to build haddocks locally and just install what you need
21:17:18 <cmccann> it sticks the haddocks in ~/.cabal/share/doc or something like that
21:17:26 <wavewave> cmccann: yeah.. I was lazy to do that.
21:17:48 <cmccann> I set my cabal config to build docs precisely so that they'd already be there when I needed them but was too lazy to do that :P
21:18:28 <wavewave> local hadock build does not show source code btw.
21:18:41 <cmccann> yeah, it's not as nice :[
21:19:05 <Jafet> Sure it can
21:19:11 <wavewave> I made my own script for making haddock show source code..
21:19:26 <Jafet> You need to pass a particular option through cabal
21:19:27 <wavewave> Jafet: it can do that with --hyperlink-source
21:19:44 <wavewave> Jafet: but not with global enable documentation.
21:19:51 <Jafet> You wrapped haddock with a shell script?
21:20:01 <wavewave> Jafet: yes... sort of...
21:20:21 <Jafet> I wrote a shell script to retroactively rebuild documentation
21:20:32 <wavewave> cabal install --enable-documentation, cabal haddock --hyperlink-source, cabal copy...
21:21:03 <wavewave> not enabling documentation in .cabal.
21:21:17 <wavewave> because it installs documentation without source again.
21:21:48 <wavewave> s/.cabal/".cabal/config"/
21:22:28 <wavewave> I want maintainer to make hyperlink-source be default.
21:23:28 <Jafet> Maintainer of what?
21:23:55 <wavewave> Jafet: cabal-install.  I mean.
21:24:11 <wavewave> I want to ask ..
21:35:03 <yitz> it's actually good if we keep mentioning here that hackage is down.
21:35:37 <yitz> perhaps someone at galois is still awake and will hear about it
21:35:54 <djahandarie> lispy isn't around?
21:36:09 <yitz> preflex: seen lispy
21:36:09 <preflex>  lispy was last seen on #haskell 1 day, 11 hours, 38 minutes and 33 seconds ago, saying: But not $
21:37:35 <yitz> it's usually pretty hopeless when this happens on a weekend though. nothing is likely to happen until tomorrow evening GMT.
21:38:12 <nyingen> :(
21:38:23 <yitz> @where hackagemirror
21:38:23 <lambdabot> http://hackage.factisresearch.com/package/monadacme
21:43:23 <bill```> i picked a bad night to get into haskell, eh?
21:43:47 <astor> hackage.factisresearch.com - I just installed yesod from scratch to test it.  worked like a charm. just update ~/.cabal/config to point to it.
21:44:07 <bill```> cool, thanks
22:02:13 <quintessence> @pl \x y z -> f x y <*> z
22:02:13 <lambdabot> ((<*>) .) . f
22:06:05 <nyingen> @quote
22:06:05 <lambdabot> shachaf says: isTrue :: Bool -> Bool; isTrue = unsafeCoerce
22:06:51 <nyingen> @quote
22:06:51 <lambdabot> medfly says: Haskell is zero maintenance because you can't get anyone to maintain it. (:
22:18:30 <lispy> yitz: ping
22:19:04 <lispy> I've been away from computers all day. I'm not sure why hackage is down.
22:19:44 <gentleben> what is hackage worth?
22:20:07 <gentleben> worth to have?
22:21:10 <lispy> very much worth
22:21:16 <lispy> Oh
22:21:21 <lispy> do you mean, how much does it cost?
22:22:04 <gentleben> no
22:22:14 <gentleben> cost and worth are very different
22:22:22 <aszlig> hm, what about changing the infrastructure so that hackage is using mirrors by default?
22:22:38 <gentleben> what about just a cdn
22:22:41 <aszlig> i guess this would also involve signing package content
22:22:49 <gentleben> it doesn't seem that hard
22:23:06 <Schadenfreude__> exit
22:23:33 <aszlig> setting up the infrastructure doesn't _sound_ that hard but is quite time consuming
22:23:58 <aszlig> especially if you want nice-to-haves such as anycast
22:24:51 <aszlig> because setting up a cdn between different datacenters will involve using anycast or an application based solution
22:25:57 <aszlig> where the latter could be solved within cabal-install and the likes, but this won't apply if you're using web browsers
22:28:44 <vodik> if im writing a foreign function interface, are there any tools that let me debug memory management, if i have to use alloc or malloc?
22:28:58 <vodik> anything to trace this?
22:29:49 <aszlig> what about gdb?
22:30:49 <vodik> i thought gdb does know anything about haskell's calling convensions
22:30:56 <vodik> *doesn't
22:31:33 <lispy> vodik: Can you elaborate on what you want to do? Haskell is garbage collected, so what is that you want to track?
22:32:31 <vodik> well i use malloc to build up a linked list structure defined in a c header do i can pass a haskell list to this library
22:33:04 <vodik> i make a ForiegnPtr out of this by using the libraries free-link-list function
22:33:24 <vodik> and while it all looks okay, i was curious if its possible to verifiy it
22:33:56 <vodik> gah, sorry for the typos, its almost 3am
22:35:32 <hpaste> vodik pasted “FFI” at http://hpaste.org/63958
22:35:38 <vodik> like this
22:36:02 <vodik> well, without the unsafePerformIO actually
22:46:01 <dreixel_> mux: I've lost your message, can you perhaps repeat what you got when deriving Generic Complex?
23:06:40 <lispy> vodik: I'm unaware of any tool for what you want.  Have you attempted to use valgrind on it?
23:07:57 <lispy> vodik: the rules with foreign ptrs are pretty simple though
23:08:05 <lispy> vodik: and they have finalizers
23:08:32 <vodik> yeah, that i understand
23:09:03 <vodik> and yeah, i tried valgrind, but its hard to tell anything from it
23:09:10 * lispy nods
23:09:23 <vodik> it says there's still free memory, but god knows if its me of haskell
23:09:28 <lispy> right
23:09:45 <vodik> rather still reachable
23:09:47 <vodik> oh well
23:09:56 <Eduard_Munteanu> vodik: if you're interested in debugging allocations in C code, perhaps something like ElectricFence helps.
23:10:12 <vodik> Eduard_Munteanu: thanks, i'll look into that
23:10:22 <ion> Valgrind, too!
23:10:44 <Eduard_Munteanu> Well, I'm assuming Valgrind gets bogged down by GHC's RTS noise.
23:11:14 <Enigmagic> Instruments on OSX seems to work fine tracking down native leaks
23:11:35 <vodik> Eduard_Munteanu: seams like it does
23:23:24 <SmartViking> @src abs
23:23:24 <lambdabot> Source not found. Where did you learn to type?
23:41:58 <ivanm> SmartViking: abs would be instance-specific
23:42:03 <ivanm> and probably using internal methods
23:42:07 <ivanm> @src Int abs
23:42:07 <lambdabot> Source not found. Listen, broccoli brains, I don't have time to listen to this trash.
23:42:19 <ivanm> yeah, not specified in lambdabot's database
23:42:39 <ivanm> preflex: seen chrisdone
23:42:39 <preflex>  chrisdone was last seen on #haskell 8 hours, 47 minutes and 6 seconds ago, saying: monochrom: :p
23:43:04 <ivanm> @tell chrisdone zomg, haskell-emacs finally lets me open .hs files properly without them being in a project!!! :D Thanks!
23:43:05 <lambdabot> Consider it noted.
23:43:20 <mgsloan> "chrisdone was last seen sticking his tongue out"
23:44:05 <ivanm> heh
23:45:08 <ion> mgsloan: http://youtu.be/npEtaxjgJQ0
