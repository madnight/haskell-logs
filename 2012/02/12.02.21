00:03:13 <Enigmagic> xrl: i think you're missing an arg to MoreFrame/FinalFrame
00:03:18 <Botje> xrl: MoreFrame and FinalFrame each need an argument
00:03:45 <xrl> Botje: I want to return the incomplete constructor
00:04:10 <xrl> I used to track More/Final as a field of Message, now I just want different instances of Message
00:04:23 <Botje> okay.
00:04:25 <xrl> err, different /values/ of Message
00:04:30 <xrl> is that Haskell-y? :)
00:04:45 <Botje> what happens if you uncomment the type declaration above it?
00:05:27 <xrl> I thought the type class had to parameterized, but I got this working: http://hpaste.org/64093
00:05:32 <xrl> I removed the return
00:05:58 <Enigmagic> :t (<$>)
00:05:58 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
00:06:02 <xrl> because it was AP.Parser (m (BS.ByteString -> Frame))
00:06:35 <mmcdermo_> :quit
00:07:31 <Botje> ah, of course :)
00:09:03 <xrl> Botje: any idea why it does need to be parameterized like (data Maybe a = Just a | Nothing)?
00:09:09 <xrl> *it doesn't
00:09:54 <donri> because it's not polymorphic?
00:10:41 <xrl> donri: oh, it's not? :)
00:11:47 <donri> Frame is not
00:12:12 <donri> it's fixated to ByteString
00:12:31 <donri> data Frame a = MoreFrame a | FinalFrame a -- polymorphic, parametric
00:12:45 <traviscline> beginner haskell programmer here, finished this for a class, pointing out style issues would be helpful: https://gist.github.com/9ef1f85fed6ab2951638
00:12:55 <t7> i was watching some video about C++ concepts... everyone is just moving toward haskell
00:13:09 <traviscline> (know about $ but chose to avoid it here)
00:13:26 <xrl> donri: very cool, thanks for differentiating!
00:13:30 <donri> traviscline: try pasting on hpaste.org and you get hlinting
00:13:55 <hpaste> tmc pasted “simple interp” at http://hpaste.org/64094
00:14:24 <traviscline> donri: thanks
00:14:29 <donri> those warnings and errors at the bottom are expandable if you click them
00:14:36 <Ptival> traviscline: why do you pattern match on the length of the list rather than its shape?
00:14:40 <traviscline> yep, gotcha
00:14:41 <Botje> traviscline: your parse_input could case on xs directly.
00:15:05 <traviscline> Ptival: meaning like (x:y:xs) ?
00:15:07 <Botje> case xs of  ["quit"] -> ... ["add", x] -> ...
00:15:09 <Ptival> traviscline: yes
00:15:21 <Ptival> cf. Botje ^
00:15:48 <traviscline> because I didn't think to / am new
00:15:50 <Ptival> parse_input ["quit"] = Quit
00:15:51 <traviscline> but i'll explore that
00:16:04 <Botje> traviscline: also, you could use the reads function to ask haskell if a given string is a number
00:16:29 <Botje> but that parses prefixes to maybe not really nice.
00:16:39 <Botje> and [isDigit x | x <- xs ] === all isDigit xs
00:17:46 <Botje> you can hoist valid_integer to the top level, as it doesn't depend on any other value in parse_input
00:18:19 <traviscline> Botje: i had it there but squirreled it away, roger
00:18:46 <Botje> and you don't need to give an explicit type for z
00:24:02 * hackagebot conduit 0.2.2 - Streaming data processing library.  http://hackage.haskell.org/package/conduit-0.2.2 (MichaelSnoyman)
00:25:57 <traviscline> Botje: thanks for you input,   https://gist.github.com/9ef1f85fed6ab2951638 a little closer to idiomatic?
00:27:28 <Botje> looks nicer, yes
00:27:46 <Botje> I'd move expr back to parseInput, as it's only used there
00:29:03 <Botje> validInteger could be used elsewhere in your program
00:29:05 <traviscline> Botje: i thought the where clause only applies to a single pattern
00:29:49 <Botje> ergh. right
00:29:57 <Botje> nevermind then :)
00:30:44 <traviscline> cool, should probably put a type on it
00:30:45 <traviscline> thanks again
00:32:15 <t7> Maybe Int doesnt reduce
00:32:26 <t7> so its storeed as an application?
00:34:15 <traviscline> Botje: https://gist.github.com/9ef1f85fed6ab2951638 think I like this best
00:35:31 <Botje> looks nice
00:35:39 <Ptival> yes
00:37:01 <traviscline> my reuse of "expr" in different places is a little blah
00:37:13 <traviscline> but ah well. thanks guys
00:37:33 <frerich> traviscline: This is just cosmetic, but you could consider making the 'validInteger' function behave better for infinite lists of non-digits (in which case it could bail out early, but right now it tries to compute the length of the list first). Pattern matching could be one way to do this.
00:38:14 <frerich> traviscline: So 'validInteger [] = False' and 'validInteger xs = all isDigit xs' (and in the second version you could then consider removing the 'xs' unless you think it makes the code harder to read)
00:43:11 <mysticc> It is a kind of design problem .. Here is my basic design  http://paste.pocoo.org/show/554353/ .. I want to change my design of FT so that somehow I can figure out in perform that is there any W constructor in op or not .. actually I want to perform some additional operations on first W constructor .... I still cant figure out how to do that ..
00:47:09 <MichaelBurge> Is there a good reason why you can't have different numbers of arguments when defining a function - say to specialize it? Say, with "f a 7 = a + 10; f a = (+a)" so that 7 is treated specially.
00:49:20 <mysticc> MichaelBurge: f a = (+(a+3)).. I think I still dont understand your problem ?
00:49:41 <frerich> MichaelBurger: You can have the same effect if you say 'f a 7 = a + 10' and 'f a x = a + x'
00:50:25 <frerich> Sorry, MichaelBurge, that was for you.
00:50:28 * frerich is hungry...
00:50:58 <MichaelBurge> is there a technical reason why it would be hard to add, though?
00:51:58 <mysticc> MichaelBurge: cant you use guards here ... or something like that
00:52:22 <frerich> MichaelBurge: I suspect there is, but I don't know enough Haskell to say what exactly it is.
00:52:28 <srhb> MichaelBurge: It really would destroy much of the expectations you get from the type systems, if different number of variables were allowed, Of course, you can just make it return a lambda that ignores its result
00:52:39 <srhb> Say f 7 = \_ -> (+a)
00:52:52 <srhb> Say f x = \a -> doSomething a
00:53:07 <srhb> ignores its argument, rather.
00:53:25 <Botje> MichaelBurge: i'd say it's just laziness.
00:53:38 <MichaelBurge> What is 'a' in the first definition, srhb?
00:54:10 <srhb> > MichaelBurge Oh sorry, that is not defined
00:54:11 <lambdabot>   <no location info>: parse error on input `,'
00:54:56 <srhb> Say f 7 = \a -> (+a)
00:55:49 <mysticc> Anyone to my problem ??
00:56:24 <srhb> MichaelBurge: Or if you want a different number of arguments, you would have to do f 7 _ = ...
00:56:36 <srhb> Where you ignore the second argument
00:56:44 <srhb> (It would still have to be passed!)
00:56:47 <MichaelBurge> srhb: If f actually masqueraded as 2 different functions that take different arguments, I could see it destroying the type system
00:57:03 <srhb> MichaelBurge: Yes, so this whole question is a bit weird. Why would you ever need it?
00:57:05 <MichaelBurge> but what if the definitions are assumed to all have the same type
00:57:06 <MichaelBurge> ?
00:57:15 <srhb> MichaelBurge: They actually are, or this would fail
00:57:59 <srhb> On the inside the lambdas returned do have to have the same type, for instance
00:59:00 <MichaelBurge> It's come up a few times when listing out a bunch of cases and having a special default case at the end, but I was just curious if allowing it caused some big technical issue
00:59:39 <srhb> MichaelBurge: What you mentioned. The outer function would not have a well-defined type
01:00:16 <MichaelBurge> f :: Integer -> Integer -> Integer
01:00:32 <MichaelBurge> 'f x y = x + y' and 'f x = (+ x)' have that same type, don't they?
01:00:36 <MichaelBurge> yet they have different numbers of arguments
01:01:07 <srhb> not really, due to currying they are exactly the same
01:01:35 <tomodo> is functional programming good for AI?
01:01:47 <srhb> tomodo: Historically it's what AI has been done in.
01:01:48 <mysticc> MichaelBurge: Thats Eata reduction in lambda calculus ..
01:02:04 <tomodo> I write an AI in lisp, but I had to do SET-CDR! edit
01:02:15 <mysticc> MichaelBurge: f x a = (+x) a is same as f x = (+x) ...
01:02:58 <mrcarrot> which ones should i hide out of mtl, monads-fd and monads-tf
01:03:30 <MichaelBurge> But if you list both of them then, the compiler will complain about them having different numbers of arguments
01:03:30 <mrcarrot> at this moment it does not matter for me, but i do want to use the right one already now
01:03:46 <MichaelBurge> try it with 'f a x = a + x' and 'f a = (a+)' in the same file
01:03:57 <mrcarrot> so far i have always been hiding random packages
01:06:09 <srhb> MichaelBurge: Compiler's problem - it doesn't let you mix those styles. Not a big problem, since you gain nothing from doing it and add more confusion
01:09:04 * hackagebot yjsvg 0.1.11 - make SVG string from Haskell data  http://hackage.haskell.org/package/yjsvg-0.1.11 (YoshikuniJujo)
01:10:42 <davv3> heya. any way i can convert C code to haskell? like quick?
01:10:58 <vodik> davv3: convert or just use?
01:10:59 <srhb> davv3: Nope.
01:11:09 <davv3> im hoping to make use of a better random number generator
01:11:24 <Botje> davv3: wrap the code in a library and use the FFI?
01:11:25 <vodik> davv3: compile the c code, use the foreign function interface?
01:11:40 <vodik> @wiki ffi
01:11:40 <lambdabot> http://www.haskell.org/haskellwiki/ffi
01:11:42 <pikhq> davv3: If you're moderately insane, you can do a naive rewrite. This is not a good idea.
01:11:59 <davv3> pikhq: haha.
01:12:02 <davv3> vodik: thanks
01:12:16 <pikhq> You'll have more CInt and malloc in your source than all other Haskell combined!
01:12:21 <davv3> but http://www.haskell.org/haskellwiki/ffi is void
01:12:29 <pikhq> But it's doable.
01:12:54 <vodik> davv3: http://www.haskell.org/haskellwiki/FFI_Introduction
01:13:21 <vodik> davv3: you can also google the "ffi haskell cookbook"
01:13:36 <vodik> to see some example
01:14:24 <davv3> vodik: awesome
01:17:59 <mysticc> MichaelBurge: http://stackoverflow.com/questions/8745597/defining-a-function-by-equations-with-different-number-of-arguments
01:18:09 <mysticc> MichaelBurg: http://stackoverflow.com/questions/8745597/defining-a-function-by-equations-with-different-number-of-arguments
01:19:04 * hackagebot xturtle 0.0.15 - turtle like LOGO  http://hackage.haskell.org/package/xturtle-0.0.15 (YoshikuniJujo)
01:19:18 <mysticc> Any help in my problem .. It is a monad design problem .. Here is my basic design  http://paste.pocoo.org/show/554353/ .. I want to change my design of FT so that somehow I can figure out in perform that is there any W constructor in op or not .. actually I want to perform some additional operations on first W constructor .... I still cant figure out how to do that ..
01:22:23 <vodik> mysticc: you mean doing somthing like this instead of W a x c -> do ...
01:22:40 <vodik> mysticc: op@(W a x) -> do ...
01:23:04 <vodik> mysticc: then you have access to both a and x AND W (as the variable op)
01:23:37 <vodik> mysticc: of if its the first W?
01:23:50 <vodik> mysticc: StateT or use an IORef
01:23:58 <vodik> *or if its
01:26:27 <MichaelBurge> mysticc: Thanks for that link - I guess it actually is more confusing than I thought
01:29:23 <mysticc> vodik: http://paste.pocoo.org/show/554364/ .. What I want is in myTransaction2 when first myWrite is executed in perform , I want to perform some additional IO operations .. and at the end of myTransaction2 , If it contained a myWrite operation I want to perform some more operations ..
01:30:11 <mysticc> so basically I want to differentiate between transactions with only myRead and both myRead and myWrite
01:30:21 <vodik> mysticc: so you want to store some state then?
01:30:59 <mysticc> vodik: Actually I want to perform some log operations which are basically IO ..
01:31:23 <vodik> right, but i mean, if you want to track the number of transactions commited, you want state
01:31:37 <vodik> because your concerned about the _first_ transaction
01:32:07 <mysticc> vodik: I am only concerned about  whether my transaction contains a myWrite or not ..
01:32:53 <vodik> mysticc: is myWrite packaged up in the FT data?
01:33:23 <mysticc> Actually FT is a file transaction monad .. and I want to differentiate between pure read transactions and read write transactions .. myWrite is myWrite a v = W a v (return ())
01:33:39 <mysticc> its defined there ..
01:33:54 <vodik> mysticc: you might want to look at how gtk2hs does options then
01:34:15 <vodik> just a sec
01:34:30 <tomodo> you want the type to say whether you did writing or not??
01:34:43 <mysticc> tomodo: actually yes ..
01:35:00 <mysticc> my perform function definition is like atomically of STM ..
01:35:15 <vodik> mysticc: http://hackage.haskell.org/packages/archive/glib/0.11.2/doc/html/src/System-Glib-Attributes.html#AttrOp
01:35:20 <vodik> mysticc: look at AttrOp
01:35:34 <vodik> mysticc: defines read, write, both monadic and pure
01:36:02 <mysticc> vodik: Thanks .. let me look into it ..
01:36:14 <vodik> you could do something simliar with how you structure transactions
01:36:36 <vodik> and then its a matter of simple pattern matching (now look at the set function)
01:39:05 * hackagebot IOSpec 0.2.5 - A pure specification of the IO monad.  http://hackage.haskell.org/package/IOSpec-0.2.5 (WouterSwierstra)
01:39:15 <t7> are there any staticly typed languages without GC (with a nice type system like haskell) ?
01:40:17 <danr> t7: C?
01:40:34 <t7> which part of C's type system is nice?
01:40:34 <danr> modulo the "nice" type system part
01:40:38 <danr> :p
01:40:50 <Ralith> t7: *ML?
01:40:50 <lambdabot> Ralith: You have 1 new message. '/msg lambdabot @messages' to read it.
01:41:00 <t7> i think i have found a hole in the market !
01:41:05 <quicksilver> all the MLs I'm aware of are GCed.
01:41:22 <quicksilver> you can do some reading on the region analysis stuff
01:41:29 <quicksilver> some of those guys implemented some toy non-GCed languages
01:41:33 <quicksilver> but AFAIR they are all just toys.
01:41:40 <Ralith> oh, right
01:41:47 <Ralith> didn't bitlisp have a non-GC mode?
01:41:49 <Ralith> er
01:41:50 <Ralith> bitC
01:42:12 <vodik> bitc looks interesting
01:42:18 <Ralith> it's rather dead
01:42:28 <Ralith> or was last I checked, anyway
01:42:34 <Ralith> never hit critical mass
01:43:13 <Ralith> a real shame
01:43:22 <vodik> yeah, they had some interesting benchmarks
01:44:09 <t7> is it lazy by default?
01:44:12 <vodik> mailing list is still active, however
01:44:29 <t7> it says it has thunks
01:44:35 <quicksilver> being lazy and non-GCed is very challenging isn't it?
01:45:28 <vodik> looks like bitc has been supplimented by ats reading the mailing list
01:47:19 <t7> now we just need a bitJavascript
01:47:45 <t7> i keep meaning to check out the uhc javascript thing
01:53:17 <merijn> t7: Habit?
01:54:23 <merijn> t7: Strict haskell dialect aimed at systems programming, so it has support for explicit memory management (in the kind system too, because "types, fuck yeah!")
01:54:33 <merijn> Then you get nice things like type checked pointers :)
01:55:27 <t7> oh wow :)
01:55:30 <merijn> http://hasp.cs.pdx.edu/
01:56:15 <merijn> Language report was fairly interesting, but no clue how much is currently vaporware
01:56:57 <t7> it looks dead :(
01:57:30 <merijn> Last I emailed they were still working on it (halfway last year)
01:58:32 * Ralith has been looking into doing something like that himself for a while
02:05:16 <ivanm> gmail classified the latest -cafe message as important mainly due to the words in the email
02:05:22 <ivanm> that email is blank and has no subject... >_>
02:05:45 <merijn> :D
02:10:15 <xil> hi everyone. Can someone help me make some sense of this error?
02:10:17 <hpaste> xil pasted “huh? error?” at http://hpaste.org/64097
02:10:32 <xil> the do expression isn't in IO it's in Parsec
02:11:13 <tikhonjelvis> sepBy returns a list; you probably just want one item
02:11:15 <xil> oh damn me; rubber ducking
02:11:32 <xil> tikhonjelvis: you're right. Specifically, the function this is in IS tables
02:11:44 <xil> it should say "table" there, without the plural
02:12:03 <tikhonjelvis> Have you heard of Applicatives?
02:12:42 <xil> assume I haven't, but keep in mind that I am very tired and writing this in a rush, hence the particularly awful code
02:12:48 <tikhonjelvis> ah
02:12:58 <xil> but I've seen applicatives if you mean the monad
02:13:06 <xil> just never looked into it's actual use/purpose
02:13:15 <xil> what are they?
02:13:31 <nze> i just tried to compile the haskell platform (2010.2) and it failed me; i'd much appreciate it if someone could take a look at the output of make at http://pastebin.com/hgysgRAN and tell me what went wrong
02:13:34 <mauke> The paste hgysgRAN has been copied to http://hpaste.org/64098
02:13:39 <Botje> xil: they basically allow you to say sepBy tables eol <* eof
02:13:54 <Botje> xil: where <* means "execute these two actions and return whatever the first produced"
02:13:59 <tikhonjelvis> That's the practical advantage :)
02:14:05 <ivanm> nze: are you using an existing version of GHC?
02:14:08 <ivanm> if so, which version?
02:14:17 <ivanm> oh, it says up the top
02:14:24 <xil> lol, that seems like a very specific thing. Is it that common a need?
02:14:29 <tikhonjelvis> Applicatives are a special case of functors, but they're more general than monads.
02:14:31 <nze> ivanm: 6.12.3
02:14:39 <ivanm> nze: the solution is to get a newer version :p
02:15:01 <tikhonjelvis> That is, more things are applicative functors than monads.
02:15:13 <nze> ivanm: that's the recommended version for that haskell platform though
02:15:26 <ivanm> nze: a newer version of the platform
02:15:35 <ivanm> not quite sure why that error comes up
02:15:36 <tikhonjelvis> Consequently, there are things you can express with monads but not applicatives. On the other hand, applicatives lead to neater code in some cases, especially parsing.
02:15:48 <ivanm> as it appears to be a version mis-match, which shouldn't happen...
02:16:11 <ivanm> nze: just to confirm: you did ./configure && make ?
02:16:12 <quicksilver> applicatives aren't required for <*
02:16:19 <xil> tikhonjelvis: very interesting. I'll have to look into it more in the morning, but I could use something like that right now
02:16:21 <ivanm> oh, wait, forget that, stupid misreading
02:16:25 <quicksilver> <* could have been written for monads and would have been just as useful for parsing.
02:16:28 <ivanm> nze: you need to install the C OpenGL library headers
02:16:38 <ivanm> OpenGL-dev or something on debian, ubuntu, etc.
02:16:43 <quicksilver> it just happens that <* turns out to exist in a slightly more general setting than monads
02:16:50 <tikhonjelvis> Aren't all monads also applicative functors?
02:16:51 <quicksilver> but don't be tricked into think it's anything clever
02:16:54 <quicksilver> (yes)
02:16:54 <xil> quick other question: my did ghc --make mything.hs but it didn't produce an executable?
02:16:56 <ivanm> nze: would a random guess of you're starting COMP1100 at ANU be correct?
02:17:10 <quicksilver> it's just a nice shorthand operator.
02:17:22 <tikhonjelvis> *> is just >>
02:17:27 <quicksilver> a <* b = do { x <- a; b; return x }
02:17:32 <quicksilver> would be a monad definition.
02:17:33 <tikhonjelvis> with a different precedence, I think
02:17:39 <ivanm> xil: was there a main definition in mything.hs ?
02:17:49 <tikhonjelvis> Why don't they have a << operator anyway?
02:18:05 <tikhonjelvis> They even have a =<<...
02:18:11 <xil> ivanm: oh does there need to be a Main module? there's a main function, but not a Main module
02:18:16 <ivanm> @hoogle (<<)
02:18:17 <lambdabot> Control.Category (<<<) :: Category cat => cat b c -> cat a b -> cat a c
02:18:17 <lambdabot> Control.Arrow (<<<) :: Category cat => cat b c -> cat a b -> cat a c
02:18:17 <lambdabot> Control.Arrow (<<^) :: Arrow a => a c d -> (b -> c) -> a b d
02:18:24 <ivanm> xil: I said main *definition*
02:18:29 <ivanm> I meant main :: IO ()
02:18:38 <ivanm> since it technically isn't a function ;)
02:18:57 <xil> haha
02:19:13 <xil> well I didn't declare the type, but I did have a main = ...
02:19:23 <nze> ivanm: incorrect for the random guess :) i'm trying to install haskell at my university workspace where we have a libc from 2007 and no way to install software through a package manager. so i installed the latest version of ghc i could get to compile and now haskell-platform fails :/
02:19:25 <ivanm> and it compiled without errors?
02:19:49 <nze> ghc? yes, it seemed so
02:19:50 <xil> yes, just didn't link or produce an executable
02:19:56 <ivanm> nze: OK, so if you actually want the Platform rather than GHC + cabal-install, you need to do a local install of OpenGL (C lib)
02:20:04 <ivanm> nze: that comment about GHC was aimed at xil
02:20:06 <xil> when I put a Main module it does
02:20:06 <ivanm> ;)
02:20:09 <tikhonjelvis> nze: Heh, your university setting sounds familiar :P
02:20:17 <ivanm> xil: did you call the module anything?
02:20:25 <ivanm> tikhonjelvis: to just about every university out there? :p
02:20:35 <ivanm> the only way it differs from others is that it has *nix :p
02:20:39 <xil> ivanm: I had called it something other than Main, but no longer
02:20:47 <ivanm> yeah, that could have been it
02:20:48 <tikhonjelvis> Heh, my school is even more fun because we still have some Solaris labs...
02:20:52 <ivanm> then you need to add --main-is I think
02:21:05 <nze> ivanm: great, i'll go get opengl then >.<
02:21:07 <tikhonjelvis> The Linux lab is actually updated though, so I can't complain. But I do anyhow :)
02:21:26 <ivanm> nze: or just install GHC yourself (get the GHC source or the pre-built binary), then get the bootstrap script for cabal-install
02:21:33 <xil> ivanm: ah, haha. I'm fine sacrificing the module name for Main. Thanks for clearing that up =]
02:21:35 <ivanm> and just use cabal-install to install any other libraries you want
02:21:44 <merijn> ivanm: Not to my university, our new central IT dept doesn't know *nix so the CS department has unrestricted root to most of the unix machines :D
02:22:00 <tikhonjelvis> heh, wow
02:22:09 <ivanm> merijn: even students? :o
02:22:29 <merijn> ivanm: Just faculty and doctoral students, of course
02:22:39 <tikhonjelvis> One of the IT people at my school is also a Haskell user.
02:23:03 <merijn> ivanm: I don't consider bachelor/master students to be part of the department
02:23:20 <tikhonjelvis> pfft, just because we contribute nothing...
02:23:27 <tikhonjelvis> give or take
02:23:27 <merijn> tikhonjelvis: You do
02:23:31 <merijn> Cheap slave labor :)
02:23:39 <tikhonjelvis> I personally don't, yet...
02:24:16 <ivanm> merijn: oh, I can ask to have root access to my machine
02:24:24 <ivanm> (as a PhD student)
02:24:36 <ivanm> I just haven't been bothered so I don't get tempted to spend time "tuning" it :p
02:24:51 <ivanm> though the version of Ubuntu installed on it is getting rather long in the tooth... :@
02:24:55 <Botje> ivanm: you can always reboot it with a livecd :)
02:24:58 <merijn> Like the token gentoo guy who spends half his day recompiling? :)
02:25:30 <ivanm> merijn: I used to use Gentoo, and now use Exherbo ;)
02:25:37 <Botje> ... and the other half complaining on forums.gentoo.org?
02:25:39 <tikhonjelvis> Heh, the IT guy at the company I worked at over the summer was a Gentoo guy. Linux was not officially supported, but got more unofficial support than Windows :P
02:25:51 <ivanm> heh
02:26:20 * merijn is still too cool for linux
02:26:57 <merijn> Also, working on the kernel a little bit doesn't not inspire much faith :p
02:27:20 <merijn> And (worse!) the linker is abysmal when you're used to OSX's linker
02:27:52 <merijn> There should be a law against single pass linkers in 2012 :<
02:28:10 <Botje> isn't that gold project fixing stuff?
02:32:09 <Rc43> Hi, guys.
02:32:19 <Rc43> I am reading about lazy evaluation.
02:32:41 <Rc43> Is it right, that every expression is memoized if it is evaluated lazilly?
02:34:50 <gwicke> Rc43: no, it is not memoized
02:34:51 <Botje> that would be a horrible memory leak.
02:35:42 <Rc43> `So when the evaluation engine sees an expression it builds a thunk data structure containing whatever values are needed to evaluate the expression, plus a pointer to the expression itself. When the result is actually needed the evaluation engine calls the expression and then replaces the thunk with the result for future reference.`
02:35:48 <Rc43> `future reference`
02:35:55 <Rc43> It is about other?
02:37:04 <Rc43> Or it detects multiple usage of expression and memoize temporarily for near usages?
02:37:08 <Botje> Rc43: this means that a value is only computed once.
02:37:09 <tikhonjelvis> What that means is that a lazy value, when it gets forced, stays forced. It does not mean everything gets memoized.
02:37:47 <Rc43> Ok.
02:37:54 <ziman> (and only named expressions get thunks)
02:38:03 <quicksilver> it means if two pieces of code have references to the same value
02:38:16 <quicksilver> then they will only compute it once (whichever of them actually uses it first)
02:38:44 <quicksilver> or, in fact, if one piece of code has two refrences that is also the same situation from a different level of zoom
02:38:49 <Botje> Rc43: the last thing you described is common subexpression elimination (CSE), which is something GHC is very reluctant to do
02:41:10 <Rc43> quicksilver, you mean, that if there is no reference to thunk then garbage collector clean it, else it is storaged (so for multiple expressions it is possible to evaluate common subexpression only one) ?
02:41:22 <Rc43> *cleans
02:41:32 <quicksilver> yes
02:41:37 <quicksilver> if there is no reference, it will go away
02:41:47 <quicksilver> if there are still references, then it will remain and other code can use it
02:41:54 <quicksilver> (and it will not have to be evaluated again)
02:42:05 <quicksilver> note that this doesn't occur for *general* subexpressions
02:42:11 <quicksilver> it occurs specifically for named values
02:43:22 <Rc43> quicksilver, for example `let x = 2*y in x*x`, but not in `(2*y)*(2*y)`?
02:43:29 <quicksilver> yes.
02:44:59 <FooBarWidget> I'm trying to install monad-control, but cabal gives this error:
02:45:00 <FooBarWidget> Building monad-control-0.3.1...
02:45:00 <FooBarWidget> Control/Monad/Trans/Control.hs:93:7:
02:45:00 <FooBarWidget>     Could not find module `Data.Functor':
02:45:01 <FooBarWidget>       Use -v to see a list of the files searched for.
02:45:29 <FooBarWidget> what's going on? I'm trying to install git-annex (which depends on monad-control) and the Haskell Platform for Mac OS X 2011.4.0.0 64-bit
02:45:39 <FooBarWidget> I'm not a haskell developer so I don't understand the errors
02:48:57 <mysticc> @hoogle Data.Functor
02:48:57 <lambdabot> Prelude class Functor f
02:48:57 <lambdabot> Data.Functor class Functor f
02:48:57 <lambdabot> Control.Monad class Functor f
02:50:33 <Rc43> `You can prepend a ~ in order to make pattern matches lazy.`
02:50:34 <q0tw4> base Data.Functor
02:50:46 <Rc43> How can we match pattern without partial evaluating?
02:50:50 <mysticc> FooBarWidget: Dont know about  mac , but Data.Functor comes with base ..  what version of ghc and base are you using ?
02:51:11 <FooBarWidget> $ ghc --version
02:51:11 <FooBarWidget> The Glorious Glasgow Haskell Compilation System, version 6.10.4
02:51:23 <FooBarWidget> cabal list base says this:
02:51:24 <FooBarWidget> * base
02:51:24 <FooBarWidget>     Synopsis: Basic libraries (backwards-compatibility version)
02:51:24 <FooBarWidget>     Default available version: 3.0.3.2
02:51:24 <FooBarWidget>     Installed versions: 3.0.3.1, (4.1.0.0)
02:51:25 <FooBarWidget>     License:  BSD3
02:53:00 <q0tw4> FooBarWidget: you need for newer verision of base :(
02:53:51 <ChristianS> FooBarWidget: better update the whole compiler, ghc 6.10.4 is pretty old
02:53:58 <FooBarWidget> how do i do that? i've already installed the latest version of the haskell distribution for mac
02:54:07 <mysticc> Rc43: pattern is not evaluated in case of lazy matching .. checkout http://www.haskell.org/tutorial/patterns.html
02:54:16 <FooBarWidget> http://hackage.haskell.org/platform/mac.html
02:54:31 <q0tw4> minimum 4.2.0.0
02:55:10 <ChristianS> FooBarWidget: no idea, i'm a happy non-mac user, sorry
02:56:13 <q0tw4> FooBarWidget: it is possible to download just compiller without platform
02:56:29 * mysticc love linux ..
02:57:51 <FooBarWidget> i'll be right back, I'm going to relocate to another room
03:03:58 * mrcarrot loves openbsd
03:04:50 <nze> cabal install X11 fails: http://pastebin.com/Z1upAYEg
03:04:50 <nze> why?
03:06:25 <nze> shouldn't the package contain include/HsXlib.h ?
03:09:25 <FooBarWidget> q0tw4: how do I do that? if I go to www.haskell.org -> Download Haskell -> Mac
03:09:33 <FooBarWidget> then I'm redirected to the exact download page that I started with
03:10:01 <FooBarWidget> oh wait
03:10:07 <FooBarWidget> doh, never mind, my mistake
03:10:23 <FooBarWidget> I apparently also had ghc installed from MacPorts
03:10:28 <FooBarWidget> and the MacPorts version comes earlier in $PATH
03:10:38 <FooBarWidget> $ /usr/bin/ghc --version
03:10:38 <FooBarWidget> The Glorious Glasgow Haskell Compilation System, version 7.0.4
03:14:27 <zomg> They oughta just drop Glasgow from the name and just call it The Glorious Haskell Compilation System
03:14:30 <zomg> =)
03:16:30 <quicksilver> ah, but glasgow haskell is the language it compiles, no?
03:17:21 <q0tw4> http://www.haskell.org/ghc/download
03:18:32 <benmachine> quicksilver: well, it can just compile glorious haskell instead :)
03:29:01 <imc> benmachine, quicksilver: you have my vote, for what it matters
03:29:08 <imc> +Glorious Haskell
03:31:25 <byorgey> I think large parts of it are still marked "copyright Glasgow University", but it hasn't had anything particularly to do with Glasgow for many years now
03:49:42 <hpaste> jamil pasted “jamil” at http://hpaste.org/64100
03:50:16 <jamil_1> hi all
03:50:32 <jamil_1> noob here
03:51:03 <jamil_1> http://hpaste.org/64100 <-- n-queens problem
03:51:28 <jamil_1> need some review/best practices suggestion
03:53:41 <sam4> I want to add two lists of numbers
03:53:54 <sam4> so I want to perform something like zipWith (+) l1 l2
03:54:13 <sam4> but if l1 and l2 are of different sizes, then I want to pad the shorter one with zeros before adding
03:54:20 <sam4> what is the best way to implement this?
03:55:38 <quicksilver> let (a,b) = if length l1 < length l2 then (l1,l2) else (l2,1) in zipWith (+) (a ++ repeat 0) b
03:55:50 <quicksilver> if there is a neater way it doesn't occur to me offhand
03:55:59 <quicksilver> s/(l2,1)/(l2,l1)/;
03:56:39 <quicksilver>  writing your own recursion directly will save you the call to length.
03:57:02 <quintessence> and make it lazier
03:57:37 <quicksilver> indeed
03:57:45 <matthiasgorgens> sam4, I'd wrap it up in mabes.
03:57:47 <matthiasgorgens> maybes.
03:58:04 <matthiasgorgens> wrap l = (map Just l ++ Nothing)
03:58:33 <matthiasgorgens> and then use a modified zipWith that take two defaults, and goes on until it hits two Nothings.
03:58:47 <matthiasgorgens> that modified zipWith will be useful as a library function to have around.
03:59:01 <sam4> I see...
03:59:40 <matthiasgorgens> you can even offer a variant that includes the wrapping with Maybes into the function.  (I.e. offer your original function also as a library function.)
03:59:52 <Saizan> i think it makes more sense to have a zipWith' :: (a -> a -> a) -> [a] -> [a] -> [a]
03:59:57 <Saizan> without the detour to Maybe
04:00:20 <matthiasgorgens> quicksilver's solution isn't very lazy.  it forces both lists with length before it starts any work, and doesn't work on infinite lists.
04:01:49 <quicksilver> Saizan: don't you need an extra "a" to use as defaults in that case?
04:02:11 <quicksilver> or were you thinking of repeating the last item of the shorter list
04:02:19 <matthiasgorgens> Saizan: I like my zipWith to take lists of two different types.
04:04:45 <matthiasgorgens> Saizan: but your type would be viable, if you want to just copy over the overlapping parts of the longer list, like in the example where you pad a sum with 0s.
04:32:36 <Saizan> matthiasgorgens: yep, i was thinking of the latter case, though an extra 'a' would also be good
04:34:45 <Taneb> I've written a program that calculates factorials.
04:34:57 <Taneb> I think it's quicker than product . enumFromTo 1
04:35:09 <rostayob> what do I need to do to contact the QuickCheck mantainer? The mailing list doesn't seem to work
04:35:32 <hpaste> factorials pasted “Taneb” at http://hpaste.org/64103
04:35:47 <Taneb> Dammit, I got the title and the author mixed up
04:36:07 <ion> @quote pastes
04:36:08 <lambdabot> No quotes match. My mind is going. I can feel it.
04:36:11 <ion> @quote paste
04:36:11 <lambdabot> chrisdone says: [on hpaste as motivational tool] When I added hlint I was like 'hey Neil, check this', and he was all 'Oh noes! I must fix all the bugs!'
04:36:15 <ion> meh
04:36:15 <hpaste> Taneb pasted “factorials” at http://hpaste.org/64104
04:36:21 <Taneb> That's better
04:37:29 <Taneb> So, anyone gonna look?
04:39:47 <dreixel> > pl \x -> x
04:39:48 <lambdabot>   <no location info>: parse error on input `\'
04:40:00 <Taneb> @pl \x -> x
04:40:00 <lambdabot> id
04:40:01 <dreixel> @pl \x -> x
04:40:01 <lambdabot> id
04:40:03 <quicksilver> I think maybe people just aren't that compelled by fast factorials, Taneb :)
04:40:09 <quicksilver> did you have a particular question about it?
04:40:21 <Taneb> Nah, I'm mainly trying to satisfy my ego
04:40:24 <dreixel> @pl \f o a b -> f (o a b)
04:40:25 <lambdabot> (.) . (.)
04:40:29 <dreixel> oh, amazing.
04:41:22 <Taneb> Now... why did I need fast factorials?
04:47:41 <danr> @pl \f g x y z -> f (g x y z)
04:47:42 <lambdabot> (.) . (.) . (.)
04:48:44 <dreixel> @pl flip map "abc" (flip map "def" . (,))
04:48:44 <lambdabot> map (flip map "def" . (,)) "abc"
04:48:59 <dreixel> I love this plugin.
04:49:23 <Taneb> How would I go about timing something?
04:49:41 <ion> taneb: criterion
04:51:42 <Taneb> ion, right
04:56:14 <dreixel> @pl map ((\y -> map y "b") . (,)) "a"
04:56:14 <lambdabot> [[('a', 'b')]]
04:56:57 <Taneb> @pl \x -> x ^ f n x
04:56:57 <lambdabot> ap (^) (f n)
04:57:15 <dreixel> @pl map ((\y -> map y "def") . (,)) "abc"
04:57:16 <lambdabot> map (flip map "def" . (,)) "abc"
05:19:16 * hackagebot yesod-core 0.10.2.1 - Creation of type-safe, RESTful web applications.  http://hackage.haskell.org/package/yesod-core-0.10.2.1 (MichaelSnoyman)
05:23:01 <mysticc> Does ghc-pkg unregister also deletes the associated files ?
05:23:21 <hpc> no
05:23:26 <hpc> it doesn't need to
05:23:33 <mysticc> hpc: Why ?
05:23:46 <hpc> because each version of a package gets its own directory
05:24:14 <mysticc> hpc: So if I want to cleanup my system , I will have to manually delete the files ?
05:24:51 <hpc> yeah; i don't know which files are safe to delete, so you will probably want to wait for someone else to help
05:25:12 <quicksilver> rm -r ~/.ghc ~/.cabal
05:25:22 <quicksilver> I have that in a cron job to run every four hours
05:25:31 <quicksilver> it's annoying reinstalling packages when I need them but it's less hassle in the long run.
05:25:47 <mysticc> quicksilver: I only want to delete some packages ..
05:25:47 <Saizan> seriously?
05:26:09 <quicksilver> no.
05:26:11 <quicksilver> please don't do that :)
05:26:31 <quicksilver> you can just delete the package dirs you don't need, they are clearly numbered.
05:26:38 <mysticc> also how to search in the synopsis of a package .. cabal list string .. only searches in the name I think ..
05:28:41 <hpc> mysticc: i just use a search engine
05:29:00 <hpc> site:hackage.haskell.org/packages your search terms here
05:44:18 * hackagebot dimensional 0.10.2 - Statically checked physical dimensions.  http://hackage.haskell.org/package/dimensional-0.10.2 (BjornBuckwalter)
05:46:01 <ion> Does anyone have an opinion about which statically-checked physical dimensions package is the best?
05:49:18 * hackagebot dimensional-tf 0.1.1 - Statically checked physical dimensions, implemented  using type families.  http://hackage.haskell.org/package/dimensional-tf-0.1.1 (BjornBuckwalter)
06:17:23 <masterbater> You stupid "Diarrhea of the mouth" nuck.  Up with shmit on black ass brown  Hackel meal McJellicker.  Harky Mc Jallillashter.  Smuggin Mah Hellihole.  Harb amin mon mif jalellamon brooms of mushkin boy a munchkin maggity von heffrin.  Shtooty mic blackened.  Shooty hick black and flubberdy bij ass rijjal.
06:17:25 <masterbater> Shniggen munuh lik leggal  perritolma penis pran chella  maloney day breeze  Paahster jam ban wikkle.   Hella mah lun mick hella malole.  Hella minull mic mella manoh.  The roadline, it's illegal.  Trully mulla mih nole.  I'm a relladge-o-melladge-o-ram.  Come on you fuckin dag asses.
06:17:27 <masterbater> Damned ram bastions.  McJellio oper Smelly gruthergrarin trilaxals.  withers ground ring air  Puggle dee maggle dee mack traggle  Jeremy sniggle. Jeremy spoken, in next day  I brusht boyered, I kicked a ball!  mellaminorf  troll protectors, trolls on the road!  troll protectors, their stones of power glow!
06:17:29 <masterbater> Fleeberty dith bub, a hick now a hither they humpty tance Hunchell munch a reg uhl schoolio tress nael Chuck a lick a loon baby tunes Weerz mellicorp To the wack ann watching machine wells darilla raptor plexing
06:17:30 <masterbater> Shligga ligga millik hole Shligga ligga millik hole regamakio mathjul hah there Just like in Bart Simpson the Magazine! Ban ricky ban glicky jallo whip! menario mibs Pahorp pahilla thin meffrin slujjal jeggy moran magomorph baleener
06:17:32 <masterbater> I spell it throwt, you spell it throat, the real way to spell it is throwt throwt THROWT!  Hux a mex a lig dwarf  dudikolan mail street.  Rella manae, Rella Manae, Rye dut duh!  I'm living on budgy placky street.  Reggal dee deck shweener  Hicker trellalicker
06:17:35 <masterbater> What part of that doesn't make sense to you robo  I'm rang dang smacking it up to the reck a heek a horn drom.  Rag agg big chacka lo datey fifty.  Sniggital maggal  Shelly a jelly a jew lillaputan meglamarian necks booga man  Rejja mella mic jeggal  Baika looka reg tag
06:17:38 <masterbater> Throat a pelly proat raick axe.  It doesn't eat muggo whip.  It's a piece of paiper.  Scrubbity ass ragamahoun.  Raggity ass maga muffin.  Where's songy brother?  Where's spongy brother?  Jellanie mic flyer.  Paloody pluck bag ack.  Paloody pluck bag ack.
06:17:38 <masterbater> Whyn you call it throat throwt.  I'm a baffy hoe.  Flivvy a niv von neffran.  Purity and prudence  I'm suing for diaper damage.  Scragg a billy blunk rake  rast eye heeker, playmus guy  I don't know what a rubbity dabby is.  Scrunny maloo lef heel hole.  Scrunny maloo lef heel hole.
06:17:40 <niko> !ops
06:17:41 <masterbater> Arthie shlellijge.  Arthie shlellidge.  Talking about a bee turning into a guano root.  today I'm doing pasta, i crumble it and pan fry it.  Fuckin frosty.  david hippa lappa pomprin.  Is anyone here a hemp hole?  Yeah, well shnijjy mc millicker: i know billy knalavolitz.
06:17:42 <masterbater> The Baby Faced Assassin pond.  yrummin!   Shmega melanie goetz  I'm smacking it up to the electrify beam, smacking it to the galactify beam!  Smackin the penis with the erectify beam!  When will another green skroan the horrified scream
06:17:44 <masterbater> Rubbity dag daggy dib dib, daggy daggy dib dib, daggy daggy diggy diggy dib, throwt a welly wheel wall  Reppity shcrep bam bam rep rep paranep  Shnubbity shnib up bam bam  Givin' me twice, i a molst a meeka pleck. Givin' me twice, a molst a meeka pleck.
06:17:46 <masterbater> Jeminee smucking smiggle.  Halittle halorst hamerrian sects nep tep hotep gargle dee gook mackie mchellic hole.  My niqqer dee dag sparky.  Ponto comical blessnor I'm dain dead.  Razor renzor manellik s-meg smeg you're all smegs.  We're hovvy hella pruss miss puss  Smelly mudga munaqqal  Posta wicka holma melancholy laggam
06:17:49 <masterbater> Shmelly a mellac.  Cloaky active camoflauge mail bow  Warez into a whoop coup daddy deam, I filed a lawsuit with G.L.E.A.M.  Dag a ricka bleg nagg.  Richel reprezhnik rally mic hoe whip.
06:17:51 <masterbater> fucking ass licking piss sucking cunt.  Threnthie oh pod throonis Tragallellah.  bweeey eeeiw!  bweeeeey ail!  shnib polmans mahhal wourney  Track a mix a meg norge
06:20:34 <quicksilver> niko: you were looking for @where ops
06:20:43 <quicksilver> still freenode notice that kind of spam pretty fast
06:21:35 <james_ubc> quick question, is Int/Integer the same as Integral? if not what's the diff? I'm reading off of lyah right now and it's really screwing with me
06:21:56 <mysticc> I think #haskell should also follow a policy like #python , allowing only regitered nicks to enter .. what say quicksilver
06:22:19 <mauke> james_ubc: Int/Integer is not a thing. Int is a type. Integer is a type. Integral is a class
06:23:17 <hpc> james_ubc: many numeric types are Integrals - Integral provides functions that they all have in common
06:23:47 <hpc> Int is a word-sized integer, like "int" in C (technically, it's only guaranteed 29 bits or so)
06:23:48 <frerich> Hm, funky, I didn't immediately recognize what 'masterbater' wrote as spam. It looked a lot like one of my sample Haskell programs (modulo the vulgarity ;-)) which combined different types of words to form more or less amusing sentences.
06:24:09 <hpc> Integer is an arbitrary-sized integer - other languages would have a bigint library to do the same thing
06:25:45 <danr> hmm not that it matters, but it seems like masterbater used some kind of markov chain technique from a totally nutcase database...
06:26:08 <james_ubc> okay thanks!
06:26:34 <james_ubc> that makes a ton of sense :D
06:28:25 <quicksilver> mysticc: nah.
06:28:36 <quicksilver> mysticc: we're open an inclusive. Nick registration is a massive barrier.
06:30:43 <hpc> nick registration breaks tryhaskell.org
06:31:04 <hpc> and pretty much everything else with throwaway "go here for questions" links
06:40:55 <donri> and spam here isn't *that* big a problem
06:44:26 * hackagebot unix-bytestring 0.3.5.3 - Unix/Posix-specific functions for ByteStrings.  http://hackage.haskell.org/package/unix-bytestring-0.3.5.3 (WrenThornton)
06:46:35 * mysticc really hate spammers 
07:10:19 <ion> That spammer’s behavior was even slightly amusing (as long as it doesn’t happen more often). :-P
07:16:04 <mysticc> Anybody using arch linux here ?
07:16:46 <adimit> I want to take the rightmost 4 bytes of an Int (or Int32) and convert it into a ByteString. Is there any "canonical" way of doing this, or will I have to use Data.Bits or somesuch?
07:17:21 <merijn> Int32 logically only has 4 bytes so all of them are the rightmost 4 :p
07:17:46 <rostayob> mysticc: the best thing is to just ask what you need to ask
07:17:50 <adimit> (that's why I said "or" — I do have Ints, but I *can* transform an Int into an Int32)
07:18:14 <merijn> Unfortunately I have no helpful answer to the rest of the question :\
07:18:27 <mysticc> rostayob: Is ghc-7.2 or higher available in any repo ? because I cant find it ..
07:18:41 <rostayob> mysticc: just use the generic binaries.
07:18:54 <parcs`> the generic binaries don't work on arch linux
07:18:58 <mysticc> rostayob: ??
07:18:59 <rostayob> parcs`: what? why?
07:19:10 <parcs`> gmp version issues
07:19:35 <rostayob> mysticc: ah. then I don't know. YOu could compile ghc but maybe you don't want to do that.
07:20:08 <rostayob> mysticc: in general, GHC development is too fast for most distros, and the best thing is to go with your own GHC(s) + cabal
07:20:11 <parcs`> mysticc: check out the arch-haskell mailing list. i believe magnus therning has a custom repo with ghc 7.4.1 prebuilt
07:20:32 <mysticc> parcs`: thanks .. let me check
07:21:04 <bitbucket_> mysticc: Some of the arch-haskell devs are working on bringing GHC up to date on Arch. It should be official within a couple of weeks.
07:21:16 <parcs`> i wouldn't count on it :P
07:21:32 <td123> work is going to begin this weekend
07:23:29 <td123> the problem with arch is that it tried to use haskell-platform, even though it doesn't fit the rolling release model
07:23:45 <mysticc> bitbucket_: Shouldn't the dev version be in some repo .. I really hate building from src ...
07:24:25 <bitbucket_> Yes, Magnus Therning has a repo with ghc-7.4, only for the x86_64 architecture though
07:24:31 * hackagebot data-pprint 0.2.1.3 - Prettyprint and compare Data values  http://hackage.haskell.org/package/data-pprint-0.2.1.3 (PeterDivianszky)
07:24:34 * hackagebot dia-base 0.1.1.1 - An EDSL for teaching Haskell with diagrams - data types  http://hackage.haskell.org/package/dia-base-0.1.1.1 (PeterDivianszky)
07:24:36 * hackagebot dia-functions 0.2.1.2 - An EDSL for teaching Haskell with diagrams - functions  http://hackage.haskell.org/package/dia-functions-0.2.1.2 (PeterDivianszky)
07:24:37 <rostayob> mysticc: the current haskell platform comes with GHC 7.0.2
07:24:47 <rostayob> mysticc: so it makes sense for archlinus to have that only
07:24:50 <bitbucket_> td123: Arch is abandoning the HP as far as I know
07:24:53 <rostayob> *archlinux :{
07:24:55 <rostayob> :P.
07:24:56 <td123> bitbucket_: it is
07:25:00 <rostayob> too fast for keyboards.
07:27:06 <td123> bitbucket_: reason being you can't have both the HP and up to date packages
07:27:49 <bitbucket_> Yes, sticking with the HP has always seemed counter to the "Arch Way" to me. Glad they are leaving it behind
07:28:22 <rostayob> I disagree. You should release and use packages that work with the haskell platform
07:28:33 <rostayob> again GHC development is too fast and too backwards incompatible
07:29:03 <rostayob> for example is arch had 7.4 right now loads of stuff wouldn't work
07:29:14 <mysticc> I think they should provide flexibily and allow user to choose what they want ..
07:29:32 * hackagebot activehs-base 0.3.0.1 - Basic definitions for activehs  http://hackage.haskell.org/package/activehs-base-0.3.0.1 (PeterDivianszky)
07:29:38 <rostayob> mysticc: archlinux doesn't support multi-versioning of packages
07:29:44 <parcs`> you can always downgrade to an older version of ghc
07:30:02 <rostayob> mysticc: it'd be a mess to provide 3 or 4 version of GHC along with the whole environment
07:30:04 <bitbucket_> IMO, a lot of people choose Arch because they want to stay on the bleeding edge; stability is less of a concern
07:30:17 <td123> rostayob: there are multiple gcc versions in the aur
07:30:51 <rostayob> bitbucket_: GHC is different, every version breaks something
07:31:13 <rostayob> gcc doesn't have the notion of packages
07:31:32 <matthiasgorgens> bitbucket_: what fun would computers be, if they woudn't break. ;o)
07:32:14 <bitbucket_> Well, some people are always going to want the stability of HP, and others will want to stay very current. Arch can't officially support both cases, so better to stick with the distro's general philosophy of staying up to date
07:32:36 <parcs`> and, like i said, you can always downgrade
07:32:39 <rostayob> bitbucket_: the HP is up to date.
07:33:06 <rostayob> bitbucket_: and the GHC that comes with the last HP is the version you're supposed to use, the new ones are more of a preview
07:33:16 <parcs`> (but you can't upgrade to a version that doesn't exist -- well, you can, but the average user won't bother)
07:33:33 <bitbucket_> rostayob: But plenty of people want to use the new features that have been introduced in 7.2 and 7.4
07:33:43 <bitbucket_> The community moves quickly
07:33:50 <rostayob> bitbucket_: yes, and those people can use the binaries, compile the source. forcing everyone to use those it's silly
07:34:00 <rostayob> since loads of stuff on hackage won't work
07:34:05 <td123> as to the breakage comment, it's an accepted fact about arch that it's usually the first distro to get a new package version
07:34:16 <bitbucket_> No one is being forced, and anyway, I'm not involved in making the decision, I'm just agreeing with it personally :)
07:34:32 <rostayob> bitbucket_: well if you only offer 7.4, for example...
07:34:34 * hackagebot activehs 0.3 - Haskell code presentation tool  http://hackage.haskell.org/package/activehs-0.3 (PeterDivianszky)
07:34:45 <rostayob> most people using GHC want to use it to play with the new language extensions.
07:34:45 <parcs`> what major package is still broken on ghc 7.4?
07:35:01 <rostayob> parcs`: I don't know, but I'd bet a lot of them.
07:35:19 <rostayob> even just because there is an upper bound on base in the cabal file
07:35:29 <td123> iirc magnus got all the packages in the arch repos to compile against ghc 7.4
07:35:57 <bitbucket_> td123: That's what he stated in the recent mailing list thread, yes
07:36:11 <rostayob> yeah but you'll never be able to keep up with hackage, arch probably includes a handful of packages
07:36:20 <td123> rostayob: it does
07:36:24 <rostayob> td123: ?
07:36:26 <td123> err
07:36:34 <td123> rostayob: it does include only a handful :P
07:36:39 <rostayob> yeah, exactly
07:36:44 <rostayob> and most people will need more
07:37:01 <parcs`> the more people who use bleeding edge software, the faster the community will react to stabilize things, i think. suggesting that
07:37:22 <rostayob> parcs`: bah. I think a 6 months window (HP) is more than adequate
07:38:40 <Taneb> <parcs`> what major package is still broken on ghc 7.4? <-- HUnit, which is required for Criterion
07:38:53 <rostayob> also really, who *needs* GHC 7.4 *now*? no one
07:38:58 <rostayob> it's just people wanting to play with it
07:39:03 <rostayob> and there's nothing wrong with that eh
07:39:10 <Taneb> For one
07:39:12 <td123> rostayob: you can say that to any package on arch really
07:39:32 <rostayob> td123: then I don't understand that logic
07:39:33 <luite> I program only works with 7.4 :(
07:39:39 <luite> err
07:39:40 <luite> my
07:39:53 <rostayob> luite: the program you wrote to test out DataKinds? yes
07:40:20 <luite> hehe I'm not even using those, but the ghc api changes each version
07:40:33 <bitbucket_> rostayob: It's the same as when Arch linked /usr/bin/python to python3 while most people continue using python2. Arch just stays current, even when the majority of the community lags behind
07:40:53 <parcs`> Taneb: hmm, good to know
07:41:04 <bitbucket_> Other distros are better if you want more stability than that
07:41:06 <rostayob> bitbucket_: staying with the HP is not lagging behind!
07:41:14 <rostayob> it's at most 6 months old
07:41:30 <bitbucket_> It is from the Arch point of view. The latest released version is the current version from that perspective
07:41:34 <td123> rostayob: the problem is that ghc and hp get released at different rates
07:41:38 <bitbucket_> 6 months old is still old
07:41:53 <rostayob> whatever. It's a totally pointless logic
07:42:05 <mekeor> bitbucket_: well, it'd be still a baby
07:42:15 <rostayob> this need of having the last version *now* even if you don't know why
07:42:25 <td123> rostayob: there is a point
07:42:28 <rostayob> bitbucket_: then why not ship builds of the head of the repo?
07:42:36 <rostayob> td123: which one/
07:42:38 <mekeor> bitbucket_: IMO >40years is old… like my parents…
07:42:40 <td123> rostayob: are you familiar with arch's philosophy?
07:43:35 <td123> rostayob: arch basically uses the latest _stable_ version upstream
07:43:38 <rostayob> td123: I've used rolling releases, and they're a good thing, but when you start to use the bleeding edge version over a 2 months old one while introducing a lot of breakage for your users it's stupid
07:44:08 <bitbucket_> rostayob: Consensus has been fairly strong among Arch users that this is the way they want it to work. If that isn't for you, then something like Debian would be a better choice.
07:44:23 <bitbucket_> No one is making you use a distro you don't like :)
07:44:24 <rostayob> td123: an imperative like that doesn't make sense. you should choose the latest version that works well, not the last version period
07:44:55 <rostayob> bitbucket_: guess what I use ubuntu eheh. but arch is a good distro and in fact they've been using the HP GHC
07:44:56 <hpc> rostayob: theoretically, that is the latest stable version
07:44:58 <silver> well when arch had gcc 4.6 it still failed to correctly build a lot of stuff, so I'd say arch is testing, bleding edge etc.
07:44:58 <rostayob> same for gentoo
07:45:03 <hpc> (theory /= practice, etc)
07:46:22 <td123> rostayob: another benefit for using the latest is that you don't backport anything
07:46:39 <rostayob> td123: "benefit"? it depends
07:46:40 <quicksilver> but you may have to forward port things.
07:46:42 <td123> rostayob: if you saw any of debian's packages, you would cry from how much backporting they do
07:46:45 <parcs`> Taneb: are you sure hunit breaks on 7.4?
07:46:52 <quicksilver> if a distribution switches to the new GHC as soon as it comes out
07:46:56 <parcs`> http://hackage.haskell.org/package/HUnit-1.2.4.2 says it was built successfully
07:46:56 <mysticc> rostayob: I just updated every thing to ghc-7.4 from unofficial repo and nothing seems to be broken ..
07:46:57 <quicksilver> then they have no libraries.
07:47:04 <quicksilver> every GHC upgrade breaks all of hackage.
07:47:14 <rostayob> mysticc: try to install stuff from hackage.
07:47:34 <parcs`> quicksilver: you're exaggerating :P
07:47:43 <rostayob> parcs`: no, most stuff breaks
07:47:44 <hpc> it breaks binary compatability
07:47:44 <td123> rostayob: I thought we went over this, all libs in arch's repos have been successfully rebuilt against ghc 7.4
07:47:50 <rostayob> if anything for upper bounds in cabal
07:48:13 <rostayob> td123: that still leaves the user on its own when installing from hackage. anyways i'm tired of this discussion :P
07:48:16 <rostayob> back to study
07:48:28 <mysticc> I reinstalled all the packages on his system on ghc-7.4 including cabal :)
07:48:35 <td123> rostayob: who do you suppose will push poeple to fix their packages for 7.4?
07:49:06 <rostayob> td123: most haskell dev are aware of that, and if not when the new haskell platform comes out
07:49:14 <mysticc> I reinstalled all the packages on his system on ghc-7.4 including cabal
07:49:31 <yrlnry> How the the implementers of lambdabot's @pl command decide what would be considered primitive?
07:49:43 <td123> rostayob: so you would prefer that the breakage get fixed after hp gets released?
07:49:45 <rostayob> yrlnry: an hard-coded things
07:49:55 <rostayob> *list
07:50:12 <rostayob> td123: I said, most haskell are aware of GHC version, and they update pretty quickly
07:50:18 <yrlnry> How did the *implementers* decide what would be in the hard-coded list.
07:50:21 <rostayob> anyways I back to study
07:50:35 <rostayob> yrlnry: they're smart people
07:50:36 <Taneb> parcs`, does for me
07:50:37 <silver> sometimes mere users do trivial porting
07:50:39 * rostayob goes away
07:50:45 <silver> for example in gentoo overlay
07:50:50 <hpc> yrlnry: how easy it would be to teach @pl how to rewrite terms using them, presumably
07:50:57 <parcs`> Taneb: is it a compile error or a dependency error or?
07:51:08 <mysticc> rostayob: study .. what actually ??
07:51:14 <rostayob> mysticc: machine learning
07:51:27 <mysticc> rostayob: which university r u in
07:51:31 <bobbybrown> I have a question: how would I go about making a image rotator for a website using haskell? would I just use yesod and work from there?
07:51:37 <rostayob> mysticc: ... why?
07:51:39 <bobbybrown> at the moment I use JQuery
07:51:42 <hpaste> Taneb pasted “cabal install HUnit” at http://hpaste.org/64112
07:51:43 <yrlnry> I know an algorithm for reducing an arbitrary lambda-expression to just S and K, or to a shorter expression of just S, K, C, B, and I; is there a paper or something that describes the algorithm that @pl uses to reduce terms to flip, ap, etc.?
07:51:54 <Taneb> parcs`, look at hpaste
07:52:02 <rostayob> mysticc: anyways imperial college. ciao
07:52:03 <mysticc> rostayob: Just wondering ... If you dont mind :)
07:52:07 <hpc> bobbybrown: as in, an image that changes without user input?
07:52:15 <rostayob> mysticc: no problem ehe
07:52:17 <hpc> bobbybrown: that would have to be done client-side
07:52:21 <bobbybrown> yea, it just rotates through images
07:52:25 <hpc> which means javascript, always
07:52:29 <bobbybrown> ohh
07:52:35 <bobbybrown> I couldnt use yesond or snap at all?
07:52:35 <yrlnry> Aha: http://www.haskell.org/haskellwiki/Pointfree#Background
07:52:37 <bobbybrown> damn
07:53:01 <hpc> you could still use yesod or snap, it would just be on the wrong side of the divide
07:53:10 <hpc> but both of them can serve js just fine ;)
07:53:47 <parcs`> Taneb: not sure why that is happening but it probably doesn't have to do with hunit. i just installed it successfully on ghc 7.4
07:53:57 <byorgey> yrlnry: isn't it essentially the same algorithm?
07:54:21 <jacobian> is there a way to use lhs2TeX and still get previews in auctex?
07:54:36 <jacobian> And is there a way to pipe through lhs2TeX before going through pdflatex
07:54:51 <Taneb> parcs`, hmm
07:55:13 <byorgey> jacobian: .lhs files using lhs2TeX are valid LaTeX files, so there's no reason you can't get auctex previews
07:55:21 <byorgey> jacobian: perhaps you just have to do  M-x latex-mode ?
07:55:34 <yrlnry> byorgey:  Is it?  Suppose someone hands you a set of combinators and asks if they form a complete set. How do you decide?  And if they are, how do you rewrite arbitrary terms into that set?  If this is obviously the same for all complete sets of combinators, I don't see how.
07:56:18 <rwbarton> well, if the set contains both S and K, I don't have to work very hard to decide.
07:56:41 <byorgey> yrlnry: oh, I have no idea, I just thought @pl was just using some Haskell equivalents of S, K, C, B, I
07:56:50 <rwbarton>  @pl isn't a general "rewriting in terms of basis combinators" algorith-producing engine.
07:56:55 <byorgey> S = ap; K = const; C = flip; B = (.); I = id
07:56:56 <yrlnry> Right.
07:57:12 <yrlnry> Maybe that is what it's doing.
07:58:14 <sclv> yrlnry: https://github.com/benmachine/pointfree
07:58:16 <byorgey> although I guess @pl uses other stuff too like  join, (>>=), fmap, ...
07:58:26 <yrlnry> Right.
07:58:54 <yrlnry> Maybe it does SKCBI first, then reduces certain subterms via the definitions of join, etc.
07:58:59 <yrlnry> I should just look at the code.
07:59:02 <yrlnry> Thanks, brent.
07:59:05 <sclv> look at Rules.hs
07:59:09 <byorgey> yrlnry: that what I would guess it's doing, but I don't actually know
07:59:10 <Taneb> Generally, S = ap, K = const, C = flip, B = (.), I = id.
07:59:11 <sclv> its a bunch of ad-hoc rewrite rules.
07:59:12 <yrlnry> sclv:  thank you.
07:59:21 <sclv> in a mini-dsl
07:59:39 <Taneb> SKI doesn't quite work in Haskell due to infinite types
08:00:06 <hpc> it works if you assume Y is primitive though
08:00:09 <hpc> kind of
08:00:27 <sclv> + Transform.hs has the pure pointfree part of the algo
08:00:27 <quicksilver> it should work with the right explicitly defined recursive type
08:00:31 <byorgey> jacobian: sure, you can pipe through lhs2TeX before pdflatex.  I usually just create a Makefile to do it
08:00:31 <yrlnry> The machine area of my office has a CD-ROM sitting around that the sysadmin has labeled "SIIX" for some reason.  Every time I pas it, I think about how it is not well-typed.
08:00:54 <byorgey> jacobian: there is also https://launchpad.net/rubber  which I think actually knows about lhs2TeX
08:01:00 <quicksilver> data L = L (L -> L) or something similar
08:01:06 <hpc> @src Mu
08:01:06 <lambdabot> newtype Mu f = In { out :: f (Mu f) }
08:01:11 <Taneb> hpc, Y is none of SKI
08:01:22 <hpc> quicksilver: that's Mu Endo
08:01:25 <jacobian> byorgey, thanks
08:01:43 <quicksilver> hpc: I daresay :)
08:02:01 <Taneb> :t \f -> (\x -> f (x x)) (\x -> f (x x))
08:02:02 <lambdabot>     Occurs check: cannot construct the infinite type: t = t -> t1
08:02:02 <lambdabot>     Probable cause: `x' is applied to too many arguments
08:02:02 <lambdabot>     In the first argument of `f', namely `(x x)'
08:02:36 <parcs`> :t \f -> (\x -> f (outR x x)) (InR (\x -> f (outR x x)))
08:02:36 <lambdabot> forall a. (a -> a) -> a
08:02:47 * byorgey tries to think of a joke involving InMuEndo
08:02:58 <hpc> @src Endo
08:02:58 <lambdabot> Source not found.
08:03:12 <hpc> :t InR
08:03:13 <lambdabot> forall a. (Rec a -> a) -> Rec a
08:03:17 <hpc> @src Rec
08:03:17 <lambdabot> newtype Rec a = InR { outR :: Rec a -> a }
08:03:19 <Abraxas> i am practicing writing instances...in the "instance Applicative Maybe" for "Nothing <*> _" i was trying to apply the Applicative law "fmap g x = pure g <*> x"...so i was thinking how Nothing can be the equivalent of "pure g" in that equation
08:03:31 <matthiasgorgens> Do you guys know where those imperative people got their meaning of the word "Functor" from?
08:04:08 <hpc> matthiasgorgens: "function"
08:04:23 <hpc> a "functor" is a "function container"
08:04:34 <hpc> more or less
08:04:50 <parcs`> Abraxas: it can't
08:04:51 <matthiasgorgens> so they just arrived at the same word as the category theory people by chance?
08:05:17 <hpc> matthiasgorgens: the CT people also got it from "function", but for better reasons :P
08:05:23 <hpc> so... kind of a coincidence
08:05:25 <matthiasgorgens> good. :o)
08:05:29 <matthiasgorgens> I knew we were superior.
08:06:00 <parcs`> Abraxas: perhaps use a combination of this law "u <*> pure y = pure ($ y) <*> u" and "fmap f x = pure f <*> x" to reason about the nothing case on the left
08:07:26 <Abraxas> i am satisfied with the answer "it can't" ;)
08:07:28 <yrlnry> I wonder who coined "functor".
08:07:38 <yrlnry> I don't think the CT people invented it.
08:07:49 <Taneb> :t inR
08:07:49 <yrlnry> Probably it was invented by analogy with "operator".
08:07:50 <lambdabot> Not in scope: `inR'
08:07:57 <Taneb> @hoogle inR
08:07:58 <lambdabot> Data.Ix inRange :: Ix a => (a, a) -> a -> Bool
08:07:58 <lambdabot> Text.ParserCombinators.ReadP chainr :: ReadP a -> ReadP (a -> a -> a) -> a -> ReadP a
08:07:58 <lambdabot> Text.ParserCombinators.ReadP chainr1 :: ReadP a -> ReadP (a -> a -> a) -> ReadP a
08:08:58 <hpc> yrlnry: it comes from linguistics, it seems
08:09:06 <Abraxas> i'm not too lazy to think about it, just don't have that much time and different priorities
08:09:11 <hpc> https://en.wikipedia.org/wiki/Functor -- see citation [2]
08:09:41 <yrlnry> Very interesting, thanks.
08:09:43 <hpc> Abraxas: pure = Just - draw your own conclusions :P
08:10:02 <hpc> but yeah, "it can't" is about as good an answer as any
08:10:49 <hpc> is it just me, or is anyone else bothered by wikipedia citations that can't be accessed for free?
08:11:21 <jacobian> <byorgey> jacobian: .lhs files using lhs2TeX are valid LaTeX files, so there's no reason you can't get auctex previews
08:11:22 <adimit> hpc: bothered yes, but there really isn't another way.
08:11:33 <jacobian> Are they really though, since they have the code environment, which doesn't really exist.
08:12:23 <byorgey> jacobian: oh, sorry, you're right
08:12:36 <byorgey> jacobian: still, I'd be surprised if auctex didn't do something useful anyway
08:12:48 <jacobian> previews is blowing up in my face unfortunately...
08:12:53 <byorgey> oh =(
08:14:28 <byorgey> jacobian: I usually just keep a pdf viewer open next to emacs, and with a proper Makefile set up I can just run M-x compile (which I have bound to a particular key combination) to refresh
08:14:59 <byorgey> so recompiling to see the most recent output is pretty fast and doesn't interrupt my train of thought
08:15:05 <jacobian> That might be the better solution
08:18:11 <matthiasgorgens> byorgey: you might even set up an inotify-wait in linux, and recompile whenever you save in emacs.
08:18:29 <matthiasgorgens> people save their files all the time anyway.  they are already trained to do that.
08:19:28 <byorgey> matthiasgorgens: good idea
08:19:34 * hackagebot resource-simple 0.1 - Allocate resources which are guaranteed to be released.  http://hackage.haskell.org/package/resource-simple-0.1 (ShaneOBrien)
08:19:53 <QinGW> @src httpduid
08:19:54 <lambdabot> Source not found. BOB says:  You seem to have forgotten your passwd, enter another!
08:19:56 <hpc> or make it run a compile every few seconds on the swap file
08:20:00 <byorgey> sadly my desktop machine here at school does not seem to have inotifywait installed.
08:25:42 <matthiasgorgens> hpc, but polling is ugly. :o)
08:31:59 <Abraxas> LYAH says "pure x = [x]" for instance Applicative []...is it possible to write pure = [] instead?
08:32:13 <hpc> Abraxas: no; it would break the laws
08:32:33 <Taneb> pure = (:[])
08:32:35 <hpc> also it's not well-typed
08:32:58 <hpc> :t [] :: a -> [a]
08:32:59 <lambdabot>     Couldn't match expected type `a -> [a]'
08:32:59 <lambdabot>            against inferred type `[a1]'
08:32:59 <lambdabot>     In the expression: [] :: a -> [a]
08:33:27 <Anpheus_> What property of the lambda calculus / logic behind types makes functions of the form: "test :: forall a. a -> Boolean" poorly formed if the function returns true for some input and false for others?
08:33:30 <Abraxas> i read ([] a) is allowed to rewrite [a], but that's only in type signatures?
08:33:41 <Enigmagic> :t (:[]) :: a -> [a]
08:33:41 <hpc> Abraxas: yes
08:33:42 <lambdabot> forall a. a -> [a]
08:33:50 <hpc> at the type level, [] :: * -> *
08:33:56 <hpc> at the value level, [] :: [a]
08:34:26 <hpc> those asterisks are kinds, which aren't that important
08:34:27 <Anpheus_> Is there a name for the lack of ability to inspect the argument leading to a contradiction when the function can take any input of any type and return differing output?
08:35:02 <bgamari> Man, why does implementing an vector Unbox instance have to be so painful?
08:35:05 <hpc> Anpheus_: that is a really hard question to parse, could you rephrase it?
08:35:16 <bgamari> The boilerplate required is just ridiculous
08:35:18 <Abraxas> is there show for "pure f", if i was able to declare pure of type []?
08:35:56 <Abraxas> instance, i man
08:35:59 <Abraxas> mean
08:36:13 <Anpheus_> Well, a function whose type was "a -> Boolean" in say, System F, can't inspect the contents of "a" and therefore cannot return anything but either True or False in all instances, no?
08:36:34 <bgamari> Would it be possible to leverage GHC Generics to automatically derive Unbox instances as is done in cereal?
08:36:35 <hpc> Anpheus_: ah
08:36:41 <Anpheus_> that is, we could define a function that always returns true, or always returns false, but not one that for some types and some instances returns True and some types and some instances returns False
08:36:45 <hpc> Anpheus_: i think the closest term would be "parametricity"
08:37:04 <hpc> there's a paper on it floating around, but i barely understand it
08:39:07 <Abraxas> oh parametricity, something else i need to figure out
08:40:00 <hpc> one of these days i need to learn parametricity beyond just "the obvious stuff"
08:40:24 <Abraxas> do you have any good sources for that?
08:40:40 <hpc> there's a paper, but i forget what the title is
08:40:46 <hpc> @where parametricity
08:40:46 <lambdabot> I know nothing about parametricity.
08:40:51 <hpc> :(
08:41:05 <Abraxas> haha
08:43:08 <tgeeky> it seems like what Anpheus_ is talking about is universal covering of something in SystemF?
08:44:55 <Abraxas> maybe this? http://www.cs.sfu.ca/CourseCentral/831/burton/Notes/July14/free.pdf
08:45:13 <tgeeky> Anpheus_: i'm a little confused. If you imagine specifying every single type in a dictionary, and map all of them to [True, False], then what is left that's missing from your function to fully specify it?
08:45:19 <matthiasgorgens> isn't there also something about free theorems?
08:45:51 <matthiasgorgens> where you use the parametricity, to prove stuff about all function of type, say, (a->b) -> [a] -> [b]
08:46:13 <tgeeky> (just a guess) aren't free theorems existence proofs?
08:46:37 <tgeeky> http://homepages.inf.ed.ac.uk/wadler/topics/parametricity.html
08:46:41 <tgeeky> hpc: probably one of those?
08:47:08 <hpc> will check out
08:47:10 <hpc> brb
08:47:11 <matthiasgorgens> tgeeky, thanks that also has the "theorems for free!" paper that I tried to refer to.
08:47:24 <Abraxas> and i just linked to it, too :D
08:47:46 <matthiasgorgens> Abraxas: I didn't check that out.  PDFs are scary.
08:48:05 <Abraxas> or the first one that comes up on google scholar
08:48:22 <tgeeky> PDFs are essential to reading about haskell
08:48:32 <Abraxas> par. and unboxing with unpointed types
08:49:16 <matthiasgorgens> tgeeky, yes, but I didn't want to fire up my pdf reader on a whim.
08:49:35 <Abraxas> well i guess there is little chance to understand that within the next two days, is there?
08:49:36 <matthiasgorgens> tgeeky, and for the "theorems for free" paper you can read the PS instead. ;o)
08:49:49 <matthiasgorgens> Abraxas: the theorems for free paper is quite accessible.
08:50:24 <t7> http://hackage.haskell.org/packages/archive/base/latest/doc/html/src/GHC-Base.html whats all the stuff at the top of the page?
08:52:27 <tgeeky> t7: tex formatting,
08:53:17 <tgeeky> something is wrong with hackage or something, I've noticed this showing up here and there
08:54:15 <dino-> I've been re-reading the Typeclassopedia the past few days. I had originally looked at it in the TMR pdf. Interesting that the discussion of Pointed was removed in the translation to Haskellwiki.
08:54:32 <Abraxas> hey, i am reading it right now
08:54:39 <Abraxas> it's really good
08:54:42 <tgeeky> t7: actually, that's "normal"
08:55:04 <tgeeky> t7: I think that's a "literate haskell" file written with TeX annotations. It looks the same on previous versions
08:55:14 <hpc> dino-: Pointed doesn't have any laws anymore
08:55:28 <t7> haddock cant parse literate haskell?
08:55:33 <hpc> dino-: the law it had was a free theorem
08:55:49 <tgeeky> t7: this part is done by 'hscolor', I think -- the rendering of source code into pretty html
08:55:52 <hpc> which means it's automatically true for any instance that typechecks
08:56:03 <tgeeky> t7: and it looks like hscolor doesn't do anything with text markup except pass it through
08:56:57 <dino-> hpc: I found it helpful to view the whole progression from Functor to Monad as a series of layers being added to get there.
08:57:05 <sm> hi dreixel.. your naming idea sounds ok, what about multiple tests in a file though
08:57:36 <hpc> dino-: it really helps if you think that applicative doesn't have pure, and monad doesn't have anything but join
08:58:39 <dino-> hpc: hm, ok. I'll keep at it with the New Typeclassopedia.
08:58:49 <dino-> Abraxas: Yes, it's really very good.
08:59:35 * hackagebot shakespeare-js 0.11.1 - Stick your haskell variables into javascript/coffeescript at compile time.  http://hackage.haskell.org/package/shakespeare-js-0.11.1 (GregWeber)
08:59:46 <hpc> dino-: incidentally, you might actually end up noticing why people call monads "monoids in the category of endofunctors"
08:59:53 <hpc> mempty = pure, mconcat = join
09:00:09 <hpc> or something along those lines
09:00:57 <dino-> hpc: I hope I notice some of these things. For all the time I've been writing Haskell, there's still lots that seems opaque to me.
09:01:31 <hpc> @quote category.in.the
09:01:31 <lambdabot> No quotes match.
09:02:18 <Eduard_Munteanu> @quote in.the.category
09:02:19 <lambdabot> xerox says: And I guess cones are functors in the category of ice cream flavours
09:02:43 <dreixel> sm: I hadn't thought of that.
09:02:44 <dino-> What got me here, btw, is that I'm running into the sadness of no-first-class-records. So started reading about things like fclabels and Data.Accessor. And saw in there references to Category. And realized I had better study some more!
09:02:54 <benmachine> hpc: something like fmap f . point = point . f?
09:03:07 <hpc> benmachine: yeah
09:03:07 <Abraxas> is join more common than bind?
09:03:16 <parcs`> is CPS'd ReaderT more efficient than normal ReaderT?
09:03:16 <dreixel> sm: I'd say if you want to use files for input/output then you can only have one test per file
09:03:19 <dreixel> sm: sounds reasonable?
09:03:22 <hpc> Abraxas: join is easier to implement for the really cool monads
09:03:33 <hpc> bind is more used, because do-notation
09:03:34 <Eduard_Munteanu> Abraxas: not really. Some specializations of 'join' might be relatively common.
09:03:37 <Eduard_Munteanu> :t concat
09:03:38 <lambdabot> forall a. [[a]] -> [a]
09:03:40 <Abraxas> hold on, it's not the same, then?
09:04:00 <hpc> Abraxas: you can define either in terms of the other
09:04:04 <hpc> (plus fmap0
09:04:14 <hpc> *fmap)
09:04:20 <Eduard_Munteanu> Abraxas: CT people prefer to speak about join
09:04:28 <Abraxas> never heard about join, so i am just forgetting about it now
09:04:35 <hpc> :t join
09:04:35 <lambdabot> forall (m :: * -> *) a. (Monad m) => m (m a) -> m a
09:04:38 <hpc> @src join
09:04:38 <lambdabot> join x =  x >>= id
09:04:46 <hpc> --OR--
09:04:59 <hpc> join x = do {x' <- x; x'}
09:05:21 <sm> dreixel: could be, or if you have multiple tests in the file any without the inline data will use the same external data file
09:05:45 <sm> but when does it look for external data exactly.. all in the inline data clauses are optional IIRC
09:06:37 <sm> what about an explicit notation like <<<2 somedata.stderr
09:06:59 <dreixel> sm: what about using it if it's present?
09:07:06 <dreixel> sm: and if both are present, error
09:07:23 <sm> that seems like it might get a little surprising/unclear
09:07:59 <Y_Less> Is it possible to declare a class instance for a type that isn't a list, and another one for types that are? If I do "instance X [a] ..." "instance X a ..." it complains, and IncoherentInstances and OverlappingInstances don't help.
09:08:26 <sm> what if I want to test only <<<=.. will it use an test.stdout file that happens to be there ?
09:09:06 <dino-> What are your opinions on the records libs? fclabels? data-accessor? Important to avoid TH for this?
09:09:48 <hpc> dino-: lenses are good
09:11:40 <dino-> hpc: there's lenses and data-lens. Interestingly, somebody in this Stackoverflow discussion really disliked lenses more than the others: http://stackoverflow.com/questions/5767129/lenses-fclabels-data-accessor-which-library-for-structure-access-and-mutatio
09:12:22 <dino-> So this is about what I get from the internet-at-large. No clear indication of which is better.
09:14:15 <lispy> ?tell yitz I put my excel writing library on hackage, see SpreadsheetML
09:14:15 <lambdabot> Consider it noted.
09:14:30 <sm> dreixel: try it how you think best, I must say I like {<<<,>>>,>>>2} FILEPATH though.. similar to the /REGEXP/ syntax, and means your test will complain predictably if auxiliary files get deleted
09:14:35 * hackagebot SpreadsheetML 0.1 - Write support for Excel's SpreadsheetML format  http://hackage.haskell.org/package/SpreadsheetML-0.1 (JasonDagit)
09:14:36 <rostayob> dino-: hpc was referring to "lenses" as in the idea of lenses
09:14:39 <rostayob> not the package
09:14:50 <sm> gotta run, bbl
09:15:07 <rostayob> dino-: also, note that edkmett will be biased towards data-lens because it's his packages. still, data-lens is really nice and his are good points
09:15:55 <rostayob> *ekmett
09:19:16 <dino-> rostayob, hpc: Ok. Thank you.
09:19:36 * hackagebot lambda-ast 0.0.4 - Untyped Lambda Calculus Abstract Syntax Tree  http://hackage.haskell.org/package/lambda-ast-0.0.4 (JonathanFischoff)
09:22:58 <nyingen> dino-: I tried data-accessor for awhile and then switched to fclabels
09:23:17 <nyingen> I preferred fclabels so much that I rewrote all my old code to use it
09:23:40 <Cale> http://www.cs.utexas.edu/users/EWD/ewd09xx/EWD975.PDF -- cute generalisation of Pythagoras' theorem.
09:23:42 <quicksilver> nyingen: are you looking forward to rewriting it all again to use data-lens now?
09:24:04 <nyingen> if there were a compelling reason, I would
09:24:12 <quicksilver> :)
09:25:05 <nyingen> my main use for fclabels/etc is in the StateT IO stack that a lot of my programs seem to use
09:25:19 <nyingen> syntactic sugar for mutating the state is really helpful
09:28:28 <conal> Cale: nifty. thx!
09:31:38 <j0br> I have hidden a package with ghc-pkg hide, how du i 'unhide'?
09:31:50 <hpc> ghc-pkg unhide?
09:32:03 <j0br> does not exsist
09:32:04 <hpc> er, expose
09:36:02 <dreixel> sm: you have a point with the explicit syntax. But I imagine using it without ever placing the input/output in the file itself. And then having to name the files in the test is boring.
09:36:23 <dreixel> sm: if you remove the test file you'll still get an error, though, because the output will certainly not match...
09:38:49 <Y_Less> OK, a better version of my question, since this is what I was trying to solve initially. How could I write a function to take a list of arbitrary dimensionality and a number, and return a list the same size and shape as the original, but full of the input number? The depth recursion is the issue - I feel I could do it if I could get a class instance to recognise "not a list", then just have
09:38:49 <Y_Less> a class function call itself repeatedly.
09:40:40 <lispy> Cale: doing a bit of math reading lately?
09:41:05 <Cale> lispy: Just random stuff I come across on the web :)
09:41:32 <hpc> Cale: where is your internet, and how is it more interesting than mine
09:41:40 <lispy> hehe
09:41:52 <lispy> ?remember hpc Cale: where is your internet, and how is it more interesting than mine
09:41:52 <lambdabot> Done.
09:42:42 <rwbarton> did dijkstra not know about the law of cosines?
09:44:36 * hackagebot th-instances 0.1.0.3 - A place to collect orphan instances for Template Haskell  http://hackage.haskell.org/package/th-instances-0.1.0.3 (JonathanFischoff)
09:44:41 * hackagebot LambdaPrettyQuote 0.0.0.2 - Parser, pretty printer, quasiquoter, and Arbitrary helpers for the untyped lambda calculus.  http://hackage.haskell.org/package/LambdaPrettyQuote-0.0.0.2 (JonathanFischoff)
09:47:04 <Cale> rwbarton: He probably did, but this presentation still has a rather nice symmetry to it :)
09:47:15 <dmwit> Y_Less: Define a new type, e.g. data DeepList a = Nil a | Deeper (DeepList [a]), or use a base type, e.g. newtype Base a = Base a and write instance DeepMap (Base a), instance DeepMap a => DeepMap [a]
09:47:26 <dmwit> err
09:47:37 <dmwit> instance DeepMap (Base a), I mean, not instance DeepMap a
09:48:53 <dmwit> Another possibility is to write base instances for each possible contained non-list type you care about, e.g.
09:49:12 <dmwit> instance DeepMap Int, instance DeepMap Double, instance DeepMap Bool, and then finally an instance DeepMap a => DeepMap [a]
09:49:41 <dmwit> Y_Less: The reason this looks complicated is that you haven't considered the following question:
09:50:08 <monochrom> Dijkstra's point is heuristics and presentation
09:51:47 <dmwit> Suppose I apply deepMap (const 3) to a value of type [[Int]]. Should it use the base case right away and return a single 3? Or use the list case once and then the base case, returning a [Int] containing threes? Or use the list case twice and then the base case, returning a [[Int]] containing lists of threes?
09:52:11 <dmwit> The rule that answers this question is that class instances must not overlap -- no type should have two matching instances.
09:55:55 <Y_Less> dmwit: Thanks. I understand the issues of why this happens with regards to instaces, I was looking for a way around that issue to always use the highest possible depth of list instance. I'll see how your alternate methods go.
10:02:21 <Y_Less> dmwit: Also, I thought -XOverlappingInstances was supposed to allow multiple instance declarations and pick the most specific, so would get "[d]" for any list and only resort to "d" on non-lists?
10:03:02 <dmwit> OverlappingInstances only applies when the two instances have the same behavior.
10:03:07 <dmwit> IncoherentInstances is for when they don't.
10:03:24 <dmwit> Or perhaps I'm remembering wrong, let's look at the documentation!
10:03:59 <hpc> i thought overlapping instances was "pick the most specific one", and incoherent was "there's a tie for specificity, so who cares"
10:04:53 <hpc> http://www.haskell.org/ghc/docs/6.12.2/html/users_guide/type-class-extensions.html -- somewhere here
10:05:06 <dmwit> Yes, you seem to be correct.
10:05:13 <dmwit> http://www.haskell.org/ghc/docs/latest/html/users_guide/type-class-extensions.html#instance-overlap for the "somewhere"
10:06:23 <c_wraith> does incoherent instances ever do what anyone needs?
10:06:57 <hpc> oh, incoherent instances is when you have something like
10:07:03 <hpc> instance C [a]
10:07:07 <hpc> instance C [Int]
10:07:39 <hpc> f :: C [b] => stuff
10:08:22 <hpc> er
10:08:24 <hpc> im misreading
10:09:22 <Abraxas> i seem not to understand the trivial monad: http://blog.sigfpe.com/2007/04/trivial-monad.html
10:09:44 <Abraxas> what's the problem with fmap?
10:09:59 <c_wraith> Abraxas: that's not the most trivial monad possible, but I guess that's not your fault. :)
10:10:07 <Abraxas> using it twice like this? fmap (+2) . fmap (+2) $ (W 1)
10:10:45 <byorgey> Abraxas: what do you mean, what's the problem?
10:10:45 <c_wraith> you can do that
10:10:49 <dmwit> Y_Less: Okay, I just sat down and tried to write it myself to see what went wrong.
10:10:55 <Abraxas> "fmap doesn't do what we want either."
10:11:04 <c_wraith> Abraxas: look at the type of f, there
10:11:30 <dmwit> Y_Less: My attempt began "class DeepConst f where deepConst :: a -> f b -> f a". And then we can see why OverlappingInstances (neither IncoherentInstances) doesn't help: both instance heads are "DeepConst []".
10:11:30 <byorgey> Abraxas: yes, using fmap you can increment twice.  The point is you cannot apply *f* twice.
10:11:35 <byorgey> Abraxas: i.e. you have to use f.
10:11:37 <dmwit> Y_Less: So there is no way to choose between them.
10:11:49 <byorgey> Abraxas: imagine if f was something really complicated and we didn't know what it did, but we wanted to apply it twice.
10:12:10 <dmwit> Y_Less: (instance contexts are *never* used to decide which instance to pick, even with all extensions turned on)
10:12:29 <Y_Less> Ok, thanks anyway
10:12:34 <byorgey> Abraxas: I think that paragraph doesn't explain it very well.
10:12:53 <Abraxas> ah ok, so this wasn't supposed to say there is the same problem with fmap
10:13:08 <Abraxas> yeah, reading on would help and all that
10:13:17 <dmwit> Y_Less: ...did that help you understand whatever it was you didn't understand?
10:13:18 <dino-> nyingen: Ok. I was thinking of fclabels. There is some good tutorial material available.
10:13:23 <dmwit> Y_Less: If not, don't thank us yet. =P
10:13:55 <byorgey> Abraxas: I think what it is supposed to say is that having fmap doesn't help you apply f twice.
10:14:17 <dino-> tbh, I would probably want to make use of templates to do the monkey-work, and I see data-lens also has a Template module for that.
10:14:42 <Abraxas> thanks, typeclassopedia author =)
10:14:42 <nyingen> fclabels also has TH functions to derive the accessors for you
10:15:18 <dmwit> Abraxas: The "problem" is that functions that might wrap some things up end up making more and more layers of wrappings. Although our API includes an fmap that knows what to do with wrappings, it doesn't include a function that can collapse multiple layers of wrappings into a single one.
10:15:24 <Abraxas> i see, that's probably what it means
10:15:33 <dmwit> Abraxas: I'm pretty sure that's what he means when he says "fmap doesn't do what we want either".
10:15:43 <Abraxas> makes sense
10:15:50 <byorgey> Abraxas: =)
10:16:49 <dmwit> Oh, I see this was already explained somewhat. Well, maybe hearing it worded several different ways is nice anyway.
10:17:16 <Y_Less> I understand the problem more and why I can't do it this way, but that doesn't really help much as now I need to find a different way.
10:17:40 <dmwit> Y_Less: This stinks a bit of an XY problem. Is there a higher-level goal you're trying to achieve?
10:17:54 <dmwit> Y_Less: (If this is just an academic question, then the two answers I outlined above should be a starting point.)
10:22:47 <Y_Less> I've got code which can take an arbitrary list (representing a n-dimensional array), and a list of integers, and shift the original list by values specified in the integer list (where each value specifies the shift in one dimension). The code can rotate the array so values leaving one end enter the other or extend it so blank spaces are filled with the edge value, but not fill the gaps with
10:22:47 <Y_Less> a blank value. At least not any generic way, I will probably be able to do it with a whole other set of code, but that comes back to my finding another way of doing it. Guess I'll have to though.
10:27:00 <parcs`> @djinn (n r -> m r) -> ((a -> m r) -> m r) -> ((a -> n r) -> n r)
10:27:00 <lambdabot> -- f cannot be realized.
10:27:56 <parcs`> so i guess (forall a. m a -> n a) -> ContT r m a -> ContT r n a can't be implemented?
10:28:34 <dmwit> Y_Less: Have you considered using an Array, or REPA?
10:28:38 <parcs`> yeah, even transformers restricts the type of mapContT to m a -> m a
10:28:47 <dmwit> ?hackage repa
10:28:47 <lambdabot> http://hackage.haskell.org/package/repa
10:29:21 <mauke> @djinn (n r -> m r) -> ((a -> m r) -> n r) -> ((a -> n r) -> n r)
10:29:21 <lambdabot> f a b c = b (\ d -> a (c d))
10:29:22 <hpc> parcs`: what if m = IO?
10:29:53 <hpc> er, ignore me
10:30:45 <Y_Less> dmwit: Yes, I'm actually already using that, but I had a list implementation for reference. Anyway, I've solved it now and it turned out to be really not that bad!
10:30:57 <parcs`> oops, i meant
10:31:04 <parcs`> @djinn (m r -> n r) -> ((a -> m r) -> m r) -> ((a -> n r) -> n r)
10:31:05 <lambdabot> -- f cannot be realized.
10:31:41 <parcs`> @djinn (m r -> n r) -> (n r -> m r) -> ((a -> m r) -> m r) -> ((a -> n r) -> n r)
10:31:41 <lambdabot> f a b c d = a (c (\ e -> b (d e)))
10:31:45 <Taneb> :t flip (.) . (.)
10:31:45 <lambdabot> forall b a b1 (f :: * -> *). (Functor f) => (a -> b1) -> (f b1 -> b) -> f a -> b
10:31:59 <parcs`> stupid continuations
10:32:22 <SomeoneElse> @pl \f g x -> (f x) (g x)
10:32:22 <lambdabot> ap
10:32:42 <parcs`> @pl \x -> x x
10:32:42 <lambdabot> join id
10:36:17 <Y_Less> Worked even better once I actually made the compiling and type correct function do the right code too!
10:37:03 <SomeoneElse> @pl \x y z = xyzzy (foo x) (bar z) (baz y)
10:37:03 <lambdabot> (line 1, column 8):
10:37:03 <lambdabot> unexpected "="
10:37:03 <lambdabot> expecting pattern or "->"
10:37:09 <SomeoneElse> @pl \x y z -> xyzzy (foo x) (bar z) (baz y)
10:37:10 <lambdabot> (. baz) . flip . (. bar) . xyzzy . foo
10:37:54 <tgeeky> Y_Less: is there a name for the operation you are doing on n-d arrays?
10:38:59 <nexion> do I need to install special versions of all the cabal packages that my app uses to profile it?
10:42:32 <jfischoff> nexion: you probably have to install packages with the -p flag
10:42:48 <jfischoff> nexion: are you installing packages from hackage?
10:43:14 <nexion> yup.. I used cabal install <package name>
10:43:28 <jfischoff> nexion: if so take a look at cabal help install
10:43:50 <nexion> I see
10:43:52 <jfischoff> there are a bunch of options for installing with profiling
10:44:20 <tgeeky> you may want to edit your cabal config file so profiling is automatically installed
10:44:32 <tgeeky> it will make all builds go twice, but no biggie if you have a fast system
10:44:42 <nexion> sounds like the next step is to learn to create a cabal config
10:44:55 <tgeeky> or just edit the one you have
10:46:07 <jfischoff> vim ~/.cabal/config will show it most likely
10:46:48 <nexion> set to: library-profiling: True
10:47:11 <nexion> what's the best way to reinstall all of the packages? I've got about 10 of them that I use
10:49:11 <dmwit> nexion: Maybe something like cabal install --reinstall `ghc-pkg list --user`
10:49:29 <dmwit> Or maybe `ghc-pkg list --user | tail` or some such nonsense.
10:51:43 <nexion> would it help if I was to write a .cabal file for my project?
10:52:06 <dmwit> Not really.
10:52:33 <dmwit> A recursive re-install is on the wishlist, I think, but not yet implemented.
10:57:21 <tgeeky> dmwit: watcha workin on now? still edit-lenses and such?
10:59:41 <denis_> hello guys
11:00:27 <denis_> who can give me a short explanation of monads? :D
11:00:58 <denis_> when should i use them, what can i use them for?
11:01:07 <denis_> now its your turn :D
11:01:14 <nyingen> well, monads are like fajitas
11:01:25 <naig> mac os x: ghc 7.0.4 and xcode 4.2 - can i do anything about the fact ghc tries to execute nonexistent gcc-4.2 from /Developer?
11:01:39 <naig> build from source?
11:01:39 <t7> monads are like monoids
11:01:43 <nand`> denis_: read LYAH
11:01:44 <c_wraith> denis_: my short explanation is "Ignore them for now.  They're not nearly as important as some people make them sound.  Eventually, they'll make sense without you really caring 'what they are'"
11:01:51 <dmwit> tgeeky: Yes indeedy!
11:01:52 <t7> but in the catagory of endofunctors
11:02:10 <nyingen> indeed, I still don't really know what a monad is, but I have no trouble using monadic functions
11:02:11 <hpc> metaphors are like similes
11:02:29 <copumpkin> t7: a slightly different definition of monoid from the algebraic one, though
11:02:30 <dmwit> denis_: There are several good expositions on monads online.
11:02:34 <dmwit> ?where AAM
11:02:34 <lambdabot> http://mauke.dyndns.org/stuff/haskell/All_About_Monads.pdf
11:02:39 <hpc> nyingen: a monad is just a type that has those functions you use so much
11:02:46 <dmwit> ?where sigfpe
11:02:46 <lambdabot> http://sigfpe.blogspot.com/
11:02:49 <dmwit> ?where invented
11:02:49 <lambdabot> http://blog.sigfpe.com/2006/08/you-could-have-invented-monads-and.html
11:02:54 <nyingen> oh, I meant in terms of category theory and all that. natural transformations or some shit
11:02:57 <denis_> i would like to ignore them but my prof would not appreciate it :)
11:02:58 <hpc> oh
11:03:01 <dmwit> ?where typeclassopedia
11:03:01 <lambdabot> http://www.haskell.org/haskellwiki/Typeclassopedia
11:03:13 <nyingen> I tried to get through that material, but i'm no mathematician
11:03:16 <dmwit> denis_: Try those three.
11:03:21 <hpc> nyingen: a CT monad is just fmap, return, join
11:03:22 <dmwit> denis_: There's also
11:03:24 <nand`> nyingen: I found http://www.haskell.org/haskellwiki/Category_theory/Monads to be quite helpful for this
11:03:30 <dmwit> ?google io monad for people who simply don't care
11:03:30 <hpc> just in "a category", rather than in Hask
11:03:30 <nand`> if you take the time to read it, or rather, the pages before it
11:03:32 <lambdabot> http://blog.sigfpe.com/2007/11/io-monad-for-people-who-simply-dont.html
11:03:32 <lambdabot> Title: A Neighborhood of Infinity: The IO Monad for People who Simply Don't Care
11:04:34 <nand`> nyingen: “fmap” is a functor (or rather, half of it), “return” and “join” are the natural transformations, but those are just fancy names
11:04:45 <nyingen> ok
11:05:36 <hpc> to really learn more, learn what a category is
11:05:38 <denis_> i am going through state monads the example with the tree where you want to replace the elements with numbers :)
11:05:44 <xil> hi everyone. I'm having some trouble debugging a parse error I got from Parsec. What would be really convenient would be to be able to see what Parsec did around the failure. Does anyone have a recommendation for how I can do that? I can't just putStrLn because it's not the IO monad, right?
11:06:16 <denis_> thanks for your help guys :)
11:07:02 <nexion> I got the libraries reinstalled with profiling and can build with '-prof -auto-all'
11:07:08 <hpc> @quote oasis
11:07:08 <lambdabot> chromatic says: My productivity increased when Autrijus told me about Haskell's trace function. He called it a refreshing desert in the oasis of referential transparency.
11:07:11 <hpc> xil: ^
11:07:11 <nexion> next I try: ./Main +RTS -p
11:07:14 <nexion> right?
11:07:29 <xil> hpc: oh right. I forgot about trace! Thanks =]
11:07:36 <hpc> xil: if you only need it for debugging though; it breaks way too many rules to use for anything else
11:07:37 <nexion> that gives me "Most RTS options are disabled. Link with -rtsopts to enable them."
11:07:38 <kallisti> if the main thread in Haskell exits, does that exit the entire program?
11:07:52 <hpc> (standard disclaimer; dunno if you know it or not)
11:08:04 <Enigmagic> kallisti: yes
11:08:14 <kallisti> ah okay
11:08:19 <hpc> if you want to wait for other threads to die, you have to wait :P
11:08:21 <k0ral> hi
11:08:22 <nand`> denis_: I'd go through the maybe or list monads first
11:08:27 <nand`> those are easiest to understand in my opinion
11:08:34 <xil> hpc: yeah just debugging =]. I've heard about it not being good for other things, but a reminder is always good =P
11:08:47 <hpc> denis_: definitely Maybe first; [] is a bit bamboozling to visualize
11:09:12 <kallisti> so is System.Exit thread exit or program exit?
11:10:06 <Enigmagic> kallisti: thread
11:10:08 <nand`> The [] monad is best visualized as a tree: https://s3.amazonaws.com/lyah/concatmap.png
11:10:13 <Enigmagic> "Note: in GHC, exitWith should be called from the main program thread in order to exit the process."
11:10:28 <nand`> in this example:
11:10:48 <kallisti> ah okay
11:10:49 <nand`> > [1,2] >>= \num -> ['a','b'] >>= \letter -> return (num, letter)
11:10:50 <k0ral> I'm writing a type SomeState -> FilePath, than can be resolved during runtime to generate all FilePath used accross the app; how would you name such type ? I'm in lack of inspiration :)
11:10:50 <lambdabot>   [(1,'a'),(1,'b'),(2,'a'),(2,'b')]
11:10:58 <nand`> or
11:11:11 <nand`> > do { num <- [1,2]; letter <- "ab"; return (num, letter) }
11:11:11 <lambdabot>   [(1,'a'),(1,'b'),(2,'a'),(2,'b')]
11:11:14 <nand`> or
11:11:25 <nand`> > [ (num, letter) | num <- [1,2], letter <- "ab" ]
11:11:25 <lambdabot>   [(1,'a'),(1,'b'),(2,'a'),(2,'b')]
11:11:37 <hpc> or
11:11:49 <hpc> > (,) <$> [1,2] <*> "ab"
11:11:50 <lambdabot>   [(1,'a'),(1,'b'),(2,'a'),(2,'b')]
11:11:52 <nand`> > (,) <$> ... yeah
11:11:53 <lambdabot>   <no location info>: parse error on input `...'
11:11:59 <hpc> :P
11:12:15 <nand`> > liftM (,) [1,2] "ab" -- rather
11:12:16 <lambdabot>   Couldn't match expected type `[GHC.Types.Char] -> t'
11:12:16 <lambdabot>         against inferr...
11:12:20 <nand`> hmm
11:12:24 <nand`> > liftM2 (,) [1,2] "ab" -- rather
11:12:25 <lambdabot>   [(1,'a'),(1,'b'),(2,'a'),(2,'b')]
11:20:49 <nexion> [pav@orianna servers]$ ghc -prof -auto-all -rtsopts -o WebGateway Liberty/WebGateway/Main.hs
11:20:49 <nexion> [pav@orianna servers]$ ./WebGateway +RTS -p
11:20:49 <nexion> WebGateway: Most RTS options are disabled. Link with -rtsopts to enable them.
11:20:54 <nexion> did I specify -rtsopts in the wrong place?
11:21:20 <k0ral> @hoogle (a -> b) -> (a -> c) -> a -> (b, c)
11:21:21 <lambdabot> No results found
11:21:59 <k0ral> surprised this doesn't exist
11:22:36 <opqdonut> :t liftA2 (,)
11:22:37 <k0ral> how would you name such (a -> b) -> (a -> c) -> a -> (b, c) ?
11:22:37 <lambdabot> forall a b (f :: * -> *). (Applicative f) => f a -> f b -> f (a, b)
11:22:49 <opqdonut> substitute a-> for f
11:23:02 <rwbarton> @type (&&&)
11:23:02 <opqdonut> err, make that a0-> :)
11:23:03 <lambdabot> forall (a :: * -> * -> *) b c c'. (Arrow a) => a b c -> a b c' -> a b (c, c')
11:23:10 <opqdonut> rwbarton: that too
11:23:24 <k0ral> oh, that's one level of abstraction higher than what I'm used to think about
11:23:44 <rwbarton> apparently for hoogle, too
11:24:32 <Rmx> Hi,
11:25:00 <Rmx> Do you know a good library to connect handle to printer port (LPT)
11:25:02 <mekeor> Hi, Rmx
11:25:21 <Rmx> I need to send data on printer port
11:25:30 <Rmx> and can't figure where to start
11:27:21 <mmcdermo> What's the most efficient way to determine if any element in one list is contained in another?
11:27:42 <mmcdermo> I'm trying https://gist.github.com/ea47d705eb29307c4ab8
11:28:00 <hpc> mmcdermo: any (`elem` list2)
11:28:02 <roconnor> hash tables
11:28:03 <lambdabot> roconnor: You have 1 new message. '/msg lambdabot @messages' to read it.
11:28:25 <rwbarton> it depends on the sizes of the lists
11:28:39 <hpc> mine will work for an infinite-sized list1, sometimes
11:28:46 <mmcdermo> hpc: that's elegant, thank you
11:28:47 <hpc> (emphasis on "sometimes")
11:29:17 <dmwit> Rmx: It's pretty uncommon to go directly to the printer port these days. Usually you go through the operating system's printer facilities.
11:29:17 <mmcdermo> Is hashtable the same order complexity?
11:29:24 <hpc> if the lists aren't sorted, what i gave has the best asymptotic complexity you can pull off
11:29:27 <roconnor> mmcdermo: sorry, I was joking around.
11:29:39 <dmwit> Rmx: So I just want to double-check: are you writing a printer driver or working on an embedded system? If not, you don't want to connect to the printer port.
11:29:40 <Cale> For finite lists, you could convert both to sets, and use set intersection, which is O(n+m), iirc.
11:30:22 <mmcdermo> hpc: Sort of what I was thinking when I looked at the soln
11:30:37 <tromp__> your's is O(m n), hpc
11:30:39 <rwbarton> hpc: Unsorted lists can be converted to sorted lists
11:30:44 <Rmx> just to turn llamps on and off
11:30:48 <Rmx> lamps*
11:31:00 <Cale> Or yeah, just sort them and walk down both.
11:31:03 <hpc> rwbarton: that brings total time above O(mn) though
11:31:07 <rwbarton> Nope.
11:31:17 <rwbarton> Well, as I said earlier, it depends on the sizes of the lists.
11:31:19 <tromp__> hpc's is best for unsortable, un-hashable data:)
11:31:30 <rwbarton> for example if m = 1, your solution is best :)
11:31:32 <Cale> which would be O(n log n + m log m)
11:31:48 <hpc> oh, i see
11:31:49 <Cale> actually, the set solution is also that, because of the conversion
11:32:41 <tromp__> logically it's a set intersection
11:32:44 <Rmx> dmwit : I found a binary package to send and recieve binary strings,
11:33:13 <Rmx> dmwit : Do i just need to use win32 apI  "type LPTSTR = Ptr TCHAR"
11:33:25 <t7> @hoogle liftM2
11:33:26 <lambdabot> Control.Monad liftM2 :: Monad m => (a1 -> a2 -> r) -> m a1 -> m a2 -> m r
11:33:36 <dmwit> Rmx: I don't know anything about Windows, sorry.
11:34:27 <rwbarton> actually, maybe sorting the shorter list and then doing binary search in it for each element of the longer list is better than anything else I can think of
11:34:42 <Rmx> dmwit : and connect handle to it ?
11:34:53 <Rmx> ok, let's imagine you're under linux
11:35:14 <Rmx> you just conext the Handle with "mkFileHandle"
11:35:23 <Rmx> that's all ?
11:35:48 <hatds> so Data.Text uses the default codepage for the IO functions.. can I change the default?
11:35:56 <mmcdermo> rwbarton: that seems pretty efficient indeed.
11:38:43 <Veinor> How do I get ghc to accept the type signature (MonadIO m, MonadState s m, HasAcid s st) => m ()
11:39:20 <hpc> Veinor: impredictive types
11:39:20 <rwbarton> Rmx: on linux I imagine it would involve opening some file under /dev and then twiddling it with some ioctl
11:39:53 <hpc> Veinor: or possibly one of the other typeclass extensions
11:40:03 <rwbarton> Veinor: what doesn't it like about it?
11:40:19 <rwbarton> does HasAcid have a functional dependency from s to st?
11:40:24 <Veinor> rwbarton: no
11:40:38 <rwbarton> then you don't want ghc to accept that type signature
11:40:41 <hpaste> “Ben Gamari” pasted “Vector + cereal memory usage” at http://hpaste.org/64123
11:40:55 <bgamari_> Can anyone explain the extreme memory usage of the above?
11:41:24 <bgamari_> If I run it on 500kB of input, the peak memory consumption is 25MB
11:41:24 <rwbarton> Veinor: because the value may depend on the choice of st, but you have no way to specify that choice
11:41:33 <bgamari_> I've added the obvious strictness annotations
11:42:05 <bgamari_> It appears that vector is accumulating a bunch of Record objects, which are supposed to be packed into a more compact, unboxed form
11:42:58 <Veinor> rwbarton: the thing is, I was able to get it to accept it somehow: http://hackage.haskell.org/packages/archive/snaplet-acid-state/0.1/doc/html/src/Snap-Snaplet-AcidState.html
11:43:41 <hpaste> “Ben Gamari” annotated “Vector + cereal memory usage” with “Vector + cereal memory usage (profile)” at http://hpaste.org/64123#a64124
11:43:42 <hpaste> “Ben Gamari” annotated “Vector + cereal memory usage” with “Vector + cereal memory usage (profile)” at http://hpaste.org/64123#a64125
11:43:44 <rwbarton> what am I looking at?
11:44:31 <Veinor> createCheckpoint has the signature createCheckpoint :: (MonadIO m, MonadState s m, HasAcid s st) => m ()
11:44:34 <bgamari_> As seen in the annotation, a fair amount of allocations are also made by >>=./.ks in cereal
11:44:43 * dmwit observes that getting GHC to type-check a function does not necessarily imply that there is a term calling that function that also typechecks
11:45:07 <roconnor> dmwit: try undefined
11:45:22 <o1iver> Hey. Is there any way I can simply reset ghc-pkg to how it would be after a clean install?
11:45:27 <dmwit> roconnor: doesn't always cut it; I've found places it doesn't
11:45:41 <rwbarton> yeah I think there is or used to be a bug in GHC where it would allow you to write unusable values but only if you don't give a type signature
11:45:43 <o1iver> or just autofix everything?
11:45:44 <Cale> bgamari_: the allocations will often but not always correlate well with what's actually consuming heap. You should perhaps run a heap profile.
11:46:09 <Cale> (some allocations may just immediately be garbage and not take up heap space)
11:46:33 <bgamari_> Cale: I'm looking at it
11:46:59 <bgamari_> There's no one culprit, at least by type
11:47:24 <bgamari_> a lot of Success objects, a lot of -> * (presumably unevaluated thunks?)
11:48:11 <bgamari_> But pretty much everything is increasingly linearly with time until it finishes reading the data
11:48:30 <bgamari_> Whereas, as far as I can tell, the only allocation done should be at the beginning when I allocate the fixed-length vector
11:48:52 <bgamari_> everything else should be short-lived and immediately written into said vector
11:50:14 <Veinor> o1iver: what broke?
11:50:31 <bgamari_> Things like Word8 and Word32, which are only intermediate results used during parsing, are for some reason accumulated
11:50:52 <Cale> what about -hc?
11:50:54 <o1iver> Veinor: I couldn't install happy. So i reinstalled GHC/cabal-install and now a lot of stuff is broken (dependency ... doesn't exist)
11:51:48 <rwbarton> Veinor: but you see the problem, right--there is no way to ever use createCheckpoint
11:51:55 <Veinor> rwbarton: yeah
11:52:01 <rwbarton> okay
11:52:02 <Veinor> i told the author that fundeps would probably be a good idea
11:52:06 <rwbarton> sounds good
11:52:15 <Enigmagic> bgamari_: try changing the return $ to return $! on 147
11:52:30 <bgamari_> Cale: Reflects what is shown in the annotation; >>=.\.ks'
11:52:42 <rwbarton> I sort of thought this issue was fixed in recent GHC, so that it would reject definitions like createCheckpoint
11:53:54 <o1iver> Veinor: I just unregisterest all problem packages (about 20) and now ghc-pgk check returns no problems, but still when install happy it says "cannot satisfy -package Cabal-1.10.1.0"
11:54:01 <o1iver> any ideas what could be causing this?
11:54:13 <Enigmagic> bgamari_: i think you'll probably need to dig into the core to see where it's allocating thunks if it's not immediately obvious from the profile
11:54:35 <mauke> @where aam
11:54:35 <lambdabot> http://mauke.dyndns.org/stuff/haskell/All_About_Monads.pdf
11:54:41 <mauke> @where+ aam http://www.haskell.org/haskellwiki/All_About_Monads
11:54:41 <lambdabot> Good to know.
11:54:42 <bgamari_> Enigmagic: Definitely helped
11:54:45 <mauke> @flush
11:54:45 <lambdabot> Not enough privileges
11:54:56 <mauke> @flush
11:54:58 <bgamari_> Enigmagic: Still not perfect, but we're getting there
11:55:40 <shachaf> mauke: Is mauke.dyndns.org supposed to be up?
11:55:45 <mauke> shachaf: no
11:55:58 <mauke> mauke.hopto.org is, though
11:56:00 <shachaf> What happened to it?
11:56:09 <shachaf> Ah.
11:56:27 <bgamari_> Enigmagic, Cale: It seems that >>=.\.ks' is still showing up pretty prominently however
11:56:33 <bgamari_> Enigmagic: I'll take a look at the Core
11:56:49 <bgamari_> Any ideas what >>=.\.ks' even is?
11:57:38 <Enigmagic> bgamari_: not offhand no, i haven't used the profiler on 7.4.1 yet
11:59:55 <tromp__> apologies for a shell question: is there any other operator besides ! on exit status?
12:00:11 <mauke> what do you mean by "operator"?
12:00:31 <tromp__> i want to run a pipeline zip bla && rsync foo && ...
12:00:41 <deech> Hi all, is there a more elegant way of inserting Debug.Trace.trace statements in the middle of monadic code? It's tedious to keep re-indenting the code that comes after "trace".
12:00:49 <tromp__> but gzip has the nasty habit of returning status 2 in case of warnings
12:00:55 <tromp__> and i dont mind warnings
12:01:48 <o1iver> I am trying to install directory, but it fails with "Not in score: `fileSystemEncoding'". Why is that happening?
12:01:58 <tromp__> so i want to express: gzip bla; $? != 1 && rsync ...
12:02:58 <bgamari_> If I have a record field, field::![MyType]
12:03:07 <mauke> [ $? -ne 1 ] && rsync
12:03:08 <bgamari_> this means that field is strict in the spine only, correct?
12:03:31 <mauke> bgamari_: I don't think so
12:03:45 <mauke> it's strict in the first node
12:03:50 <tromp__> thx, mauke
12:03:51 <bgamari_> ouch
12:03:54 <mauke> i.e. it'll always be [] or (:) _ _
12:04:23 <bgamari_> Is there any way to specify a completely strict list?
12:05:07 <dmwit> data StrictList a = Nil | Cons !a !(StrictList a)
12:05:18 <Veinor> o1iver: what does ghc-pkg list | grep Cabal show?
12:05:25 <bgamari_> without redefining []?
12:06:02 <dmwit> smart constructors and functions
12:06:13 <hpc> dmwit: probably with an unpack pragma at that point, too
12:06:35 <bgamari_> I'm just very confused; it seems to me like vector's replicateM should force everything as it's generated
12:08:14 <o1iver> Veinor: I just deleted .ghc and .cabal and am starting again. I will see if it works now
12:08:39 <bgamari_> Can anyone think of a better way to accomplish the goal of the program?
12:09:00 <bgamari_> namely, to read a bunch of binary records into a fast, space efficient data structure
12:09:29 <bgamari_> I have yet to stumble upon a reasonably solution to this; binary IO has been a real sticky point in my Haskell usage
12:09:30 <o1iver> Veinor: ok it worked now! Thanks.
12:09:52 <bgamari_> In Python it's more or less trivial (although getting a nice interface around the records is a bit trickier)
12:10:04 <nexion> is there a library that can decode a URL similar to Codec.Binary.Url's "decode", except working with lazy ByteString? (perf reasons)
12:10:10 <Enigmagic> bgamari_: deepseq is the only way i know of evaluating a list
12:10:18 <bgamari_> Enigmagic: Alright, I'll give it a try
12:10:35 <bgamari_> I do wish I understood why vector wasn't forcing this though
12:11:24 <Cale> bgamari_: how about just using a Vector instead of a list if you want it to be strict?
12:12:23 <Cale> bgamari_: What are you planning on doing with the records once you've loaded them into the structure?
12:12:45 <DanBurton> dmwit: do you think augustss would oppose if I change the date-based versions for "numbers" to PVP? e.g. the new one could be 3000.0.0.0
12:12:48 <bgamari_> Cale: Iterate over them in a few ways
12:13:29 <bgamari_> Cale: The list shouldn't ever survive, it's irrelevant when I unbox my record (it turns into bit flags)
12:13:42 <dmwit> DanBurton: I'm not really sure.
12:13:51 <bgamari_> Cale: For the most part, I only really need the times (Word64s)
12:14:46 <DanBurton> I'll G+ him and see
12:15:07 <bgamari_> Cale: I've considered using an iteratee/conduit/enumerator approach in the past, but this makes things a bit awkward
12:15:30 <Cale> bgamari_: heh, indeed, I've never actually gone so far as to use one of those in anger
12:15:47 <dmwit> DanBurton: The "numbers" library seems to predate the PVP as we know it. So it might make sense to convert to the PVP.
12:15:48 <bgamari_> Cale: heh
12:16:23 <bgamari_> Cale: By the way, the list I'm referring to is on line 142
12:17:00 <DanBurton> dmwit: I figured as much
12:17:25 <DanBurton> revdeps shows it actually has one other dependency other than lambdabot :)
12:17:40 <bgamari_> The problem itself is unfortunately quite awkward: I have binary records, but the timestamp field is too short (36 bits), so I occassionally get wraparounds; I therefore want to expand the timestamp field to 64 bits
12:18:17 <bgamari_> This means I first need to read from the file into a vector of records with 64-bit timestamps (my Record data type) using cereal
12:18:33 <bgamari_> Then I have to implement an Unbox instance for Record so I can store them reasonably efficiently
12:18:53 <bgamari_> So the solution ends up being quite messy
12:19:32 <bgamari_> But more importantly, the reading process seems to be very inefficient due to these heap issues
12:19:53 <bgamari_> I can't tell you how many hours I've spent trying to get this right
12:20:22 <bgamari_> Interfacing with the outside world is not haskell's strength in this case
12:21:06 <hpc> bgamari_: sounds like you might want to read the file in as [Word8], perhaps
12:21:40 <hpc> though 36 bits is a very awkward size
12:23:59 <bgamari_> hpc: Indeed it is
12:24:22 <bgamari_> hpc: I'm reading as a ByteString and using cereal to read the records
12:25:08 <DanBurton> for a repo on github, is it encouraged or discouraged to include your .gitignore file? e.g. for a cabalized project, you add /dist to .gitignore
12:25:35 <DanBurton> in other words, should you .gitignore your .gitignore?
12:26:01 <KorriX> hello everyone
12:26:09 <hpc> DanBurton: include the gitignore in your repo
12:26:25 <KorriX> is there any way to display correctly unicode characters in haddock ?
12:26:29 <hpc> DanBurton: as a courtesy to new users who could easily commit temporary crap
12:26:36 <hpc> just by accident
12:27:08 <hpc> it's also a nice bit of "these dirs pop up normally" documentation
12:27:19 <carter> hey all, is there a good way to define a hashable instance for a hashset from unordered-containers, because the "obvious" way would require adding an ord constraint on the members of the hashset
12:27:23 <hpc> or "don't put shit in here" docs :P
12:27:24 <DanBurton> hpc: cool, thanks :)
12:27:54 <carter> and doing that would make hashset no better than normal data.set for my purposes
12:28:07 <DanBurton> carter: the members don't have to be Orderable, they just have to be Hashable to some representation which is Orderable
12:28:21 <DanBurton> Orderable meaning Ord
12:28:23 <osa1_> does anyone know which library contains Timer package?
12:28:25 <carter> DanBurton: woooooo, thanks
12:28:26 <carter> good point
12:29:04 <DanBurton> @where hayoo -- osa1_
12:29:04 <lambdabot> http://holumbus.fh-wedel.de/hayoo/hayoo.html
12:29:36 <hpc> DanBurton: whoa, lambdabot does that?
12:29:50 <hpc> (ignore comments, that is)
12:30:11 * mekeor didn't know either…
12:30:59 <DanBurton> hpc:  not really, I think the @where command just looks at the first token
12:31:12 <DanBurton> @where lambdabot hackage google
12:31:13 <lambdabot> http://haskell.org/haskellwiki/Lambdabot
12:31:17 <carter> DanBurton: that does raise the question of whether defining the hashing via say --- hashSet = hashList . sort . map hashElem . toList  is a good hash function
12:32:07 <carter> because while that does give us a hash function such that equal sets hash to the same #, that a) is n lg n
12:32:44 <carter> that also adds quite a bit of structure to how its hashing
12:32:52 <carter> but maybe i'm overthinking
12:36:01 <Veinor> i bet that implicit parameters see more use as a typechecking tool than as an actual thing
12:37:31 <kallisti> Veinor: yep
12:45:11 * hackagebot web-routes 0.27.1 - Library for maintaining correctness and composability of URLs within an application.  http://hackage.haskell.org/package/web-routes-0.27.1 (JeremyShaw)
12:45:12 * hackagebot web-routes-happstack 0.23.1 - Adds support for using web-routes with Happstack  http://hackage.haskell.org/package/web-routes-happstack-0.23.1 (JeremyShaw)
12:45:55 <DanBurton> dmwit: Lennart gave the OK on G+, I'll be uploading a new version soon :)
12:51:09 <clsmith> this might be a bit abstract, but if you have a function which only uses constructors and each of its arguments exactly once, could you theoretically allow it to be used in a pattern match?
12:52:21 <mike-burns> Yup, too abstract.
12:52:31 <hpc> clsmith: not... really, i think
12:52:35 <hpc> clsmith: check out view patterns
12:54:21 <dolio> The answer is yes, and SHE will allow you to do it with pattern aliases.
12:56:39 <albel727> what. ambiguous use of SHE acronym again?
13:02:11 <hpc> @where SHE
13:02:11 <lambdabot> http://personal.cis.strath.ac.uk/~conor/pub/she/
13:02:26 <hpc> haha
13:06:45 <bgamari_> Under what conditions will functions appear in Core?
13:07:07 <bgamari_> The getMany function appears strongly in the profile, yet I can't find it at all in the Core
13:07:39 <bgamari_> Other than in the fired rules
13:08:27 <Alexey_L> Hi
13:08:50 <mekeor> Alexey_L: hi
13:08:58 <Alexey_L> I am looking for some help trying to figure out basic Haskell
13:09:20 <Brax> @eval let {k :: a -> m b; k=undefined}
13:09:30 <mekeor> Alexey_L: play up!
13:09:33 <Brax> let {k :: a -> m b; k=undefined}
13:09:44 <mekeor> Alexey_L: go ahead!
13:09:48 <Eduard_Munteanu> Brax: let ... in ...
13:09:51 <mekeor> Alexey_L: Fire away!
13:10:00 <mekeor> Alexey_L: get cracking!
13:10:05 <mekeor> Alexey_L: shoot!
13:10:16 * mekeor is sorry for trolling a lil bit
13:10:17 <nand`> Alexey_L: read LYAH if you haven't already
13:10:25 <mekeor> @where LYAH
13:10:25 <lambdabot> http://www.learnyouahaskell.com/
13:10:26 <Alexey_L> Was wondering if someone can help me with this. I am trying to define a section which would take a value and return true or false based on whether the (mod value 13 == 0)
13:10:35 <Brax> let {k :: a -> m b; k=undefined} in :t fmap k
13:10:44 <Botje> @pl \x -> x `mod` 13 == 0
13:10:45 <lambdabot> (0 ==) . (`mod` 13)
13:11:03 <nand`> @type (==)
13:11:03 <lambdabot> forall a. (Eq a) => a -> a -> Bool
13:11:08 <nand`> ^ so you see it already returns a Bool
13:11:13 <mekeor> Alexey_L: replace "section" with "function", please!
13:11:23 <Brax> @type let {k :: a -> m b; k=undefined} in fmap k
13:11:24 <lambdabot> forall a (m :: * -> *) b (f :: * -> *). (Functor f) => f a -> f (m b)
13:12:04 <Alexey_L> Nice. Great help, guys. Thanks a lot. Will continue working through the book...
13:12:41 <Brax> "But what is the type of fmap k? Well, it’s m a -> m (m b)."
13:13:09 <Brax> typeclassopedia, right before join is explained
13:13:26 <Brax> so that's just f=m in order to justify join's def?
13:13:32 <mekeor> @let myCircle x = x++myCircle x
13:13:33 <lambdabot>  Defined.
13:13:35 <hpc> Brax: yes
13:13:42 <mekeor> > myCircle "foo"
13:13:43 <lambdabot>   "foofoofoofoofoofoofoofoofoofoofoofoofoofoofoofoofoofoofoofoofoofoofoofoofo...
13:14:13 <Brax> but isn't that confusing, because that should not be the same m?
13:14:48 <hpc> Brax: f and m don't have to be the same, yes
13:14:49 <int-e> > cycle "foo"
13:14:50 <lambdabot>   "foofoofoofoofoofoofoofoofoofoofoofoofoofoofoofoofoofoofoofoofoofoofoofoofo...
13:14:54 <hpc> Brax: but when they are, we can do nice things
13:14:58 <hpc> like write join
13:15:36 <Brax> never mind, it was obvious
13:15:57 <Brax> two sentences before this: "We are given a value x of type m a, and a function k of type a -> m b, so the only thing we can do is apply k to x."
13:18:29 <int-e> > concat $ iterate ('o':) "f"
13:18:30 <lambdabot>   "fofoofooofoooofooooofoooooofooooooofoooooooofooooooooofoooooooooofoooooooo...
13:18:58 <nand`> :t iterate
13:18:59 <lambdabot> forall a. (a -> a) -> a -> [a]
13:19:30 <carter> edwardk -- switching to unordered containers saved the day
13:19:53 <kallisti> what would be the best way to force the main thread to wait until all other threads exit?
13:19:59 <carter> memory consumption went from peaking at like 45 gb to ~ 1.5 gb
13:20:17 <shachaf> carter: Sounds like a celebration is un order!
13:20:30 <shachaf> What were you using before unordered-containers?
13:20:40 <shachaf> kallisti: An MVar is standard.
13:20:46 <kallisti> ah
13:20:53 <kallisti> yeah that's the only solution I could think of.
13:21:24 <carter> shachaf : or why the hashmap package should have <DEPRECATED, please use unordered>
13:21:25 <carter> on it
13:21:26 <mekeor> iterate is great. but unfortunately, there's no iterate for monads or so, like this: `myMonadicIterate f x = f x >>= myMonadicIterate f'
13:21:27 <kallisti> hmm, so I'd want the mVar to store a count?
13:21:31 <carter> even though its actively maintained
13:22:14 <mekeor> kallisti: does "mvar" mean "mutable variable"?
13:22:29 <kallisti> um, I actually have no idea what the m stands for.
13:22:40 <kallisti> but, no IORef is more like a mutable variable in that sense.
13:22:51 <donri> managed variable?
13:22:57 <kallisti> maybe "message" variable.
13:22:57 <Enigmagic> kallisti: i typically use a list of MVars
13:23:01 <shachaf> kallisti: That's one way.
13:23:11 <shachaf> You can use an MVar per thread.
13:23:13 <mekeor> so is it mutable or not?
13:23:15 <kallisti> Enigmagic: oh, block on all of them
13:23:16 <kallisti> that's sensible.
13:23:20 <donri> docs describe them as "mutable variables"
13:23:28 <mekeor> so, i was right =)
13:23:34 <kallisti> Enigmagic: MVar () right?
13:23:38 <Enigmagic> kallisti: yeah
13:23:46 <Enigmagic> kallisti: then just call mapM_ takeMVar
13:23:48 <kallisti> unless of course you have some kind of result
13:23:55 <shachaf> I find it vaguely annoying that people use MVar () instead of a more specialized type.
13:24:01 <shachaf> Although it doesn't matter.
13:24:15 <Enigmagic> type ThreadExit = () ? :P
13:24:23 <shachaf> I mean type Foo = MVar ()
13:24:29 <kallisti> type BlockerThing = MVar ()
13:24:33 * kallisti best namer of things.
13:24:36 <Cale> The name does come from "mutable variable", but you probably should probably pronounce it as "em-var" anyway so that people know what you're talking about. :)
13:24:54 <Enigmagic> adding a thread join function would probably be easier
13:24:54 <parcs`> :t let mapContT f m = ContT $ \k -> f (runContT m return) >>= k in mapContT
13:24:55 <lambdabot> forall (m :: * -> *) r (m1 :: * -> *) a r1. (Monad m1, Monad m) => (m r -> m1 a) -> ContT r m r -> ContT r1 m1 a
13:25:12 * hackagebot numbers 3000.0.0.0 - Various number types  http://hackage.haskell.org/package/numbers-3000.0.0.0 (DanBurton)
13:25:21 <parcs`> why is it that the 'transformers' package only provides a 'mapContT :: (m r -> m r) -> ...' ?
13:25:30 <parcs`> instead of m r -> n r
13:26:06 <parcs`> is it because it's trying to avoid any monad constraints on m and n?
13:27:44 <parcs`> hmm, ContT r m r doesn't look right :P
13:28:07 <parcs`> :t Cofree
13:28:08 <lambdabot> Not in scope: data constructor `Cofree'
13:28:12 <parcs`> :t CoFree
13:28:13 <lambdabot> Not in scope: data constructor `CoFree'
13:28:45 <mekeor> `ap' and `fmap' are nearly the same, right?
13:28:46 <mekeor> :t ap
13:28:47 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m (a -> b) -> m a -> m b
13:28:49 <mekeor> :t fmap
13:28:50 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
13:28:59 <mekeor> oh no
13:29:03 <mauke> ap is powerfuller
13:29:23 <mauke> :t ap . return
13:29:24 <lambdabot> forall (m :: * -> *) a b. (Monad m) => (a -> b) -> m a -> m b
13:29:27 <shachaf> mauke: Given return.
13:29:40 <mauke> ap is Monad m =>
13:29:45 <edwardk> carter: woohoo!
13:29:50 <carter> edwardk yeah
13:30:07 <nand`> mekeor: they are the same for all monads which also have well-behaved Functor instances
13:30:15 <nexion> what can I do to get calls to library functions to show up in the -p profiling report?
13:30:16 <edwardk> carter: tibbe will be really happy to hear that =)
13:30:20 <carter> yeah
13:30:35 <carter> the part after loading up the map is slow, but thats expected
13:30:47 <mekeor> nand`: ah.
13:30:47 <nand`> err, I'm thinking of liftM not `ap`
13:30:51 <carter> 'cause its sort of doing a very very very inefficient combinatorial enumeration
13:30:55 <mekeor> nand`: oh.
13:31:02 <carter> but building the map now can be done on a MB air
13:31:17 <nand`> `ap` is the same as <*> for all monads which also have well-behaving applicative instances
13:31:40 <carter> maybe I should have a look at if HashMap.Lazy also is space safe
13:31:48 <shachaf> nand`: A monad can have a well-behaved Applicative instance and still have (<*>) /= ap
13:32:01 <nand`> shachaf: examples?
13:32:09 * carter runs off to find out
13:32:10 <shachaf> (Unless your definition of well-behaved includes "(<*>) = ap", in which case that's a tautology.)
13:32:14 <shachaf> ZipList.
13:32:21 <mekeor> > ap [(+1),(+2),(*3)] [1,2,3]
13:32:22 <lambdabot>   [2,3,4,3,4,5,3,6,9]
13:32:50 <nand`> shachaf: ZipLists are not monads
13:32:54 <nand`> unless I'm mistaken
13:33:00 <mekeor> > ap [(+1),(+2),(+4)] [8,16,32]
13:33:01 <lambdabot>   [9,17,33,10,18,34,12,20,36]
13:33:12 <benmachine> kallisti: http://hackage.haskell.org/package/threads
13:33:42 <Brax> i think the first thing i should ever have read is typeclassopedia
13:33:46 <benmachine> kallisti: http://hackage.haskell.org/packages/archive/threads/0.4.0.1/doc/html/Control-Concurrent-Thread-Group.html see 'wait'
13:33:48 <shachaf> nand`: instance Applicative [] where pure = repeat; (<*>) = zipWith id
13:34:00 <rwbarton> you can also reverse the order of the effects in (<*>)
13:34:27 <Brax> but maybe there IS something i actually learned all this time and it's just subconscious :D
13:34:42 <Brax> ly helping with typeclassopedia
13:35:04 <mekeor> > let myListAp f x = concatMap (\g->map g x) f in myListAp [(+1),(+2),(+4)] [8,16,32]
13:35:05 <lambdabot>   [9,17,33,10,18,34,12,20,36]
13:35:11 <carter> edwardk: yup, lazy datastruct == insta thrash
13:35:51 <kallisti> benmachine: nice
13:36:06 <mekeor> > let myFunctorAp f x = concat (fmap (\g->fmap g x) f in myFunctorAp [(+1),(+2),(+4)] [8,16,32])
13:36:06 <lambdabot>   <no location info>: parse error on input `in'
13:36:19 <mekeor> > let myFunctorAp f x = concat (fmap (\g->fmap g x) f) in myFunctorAp [(+1),(+2),(+4)] [8,16,32]
13:36:19 <lambdabot>   [9,17,33,10,18,34,12,20,36]
13:36:46 <shachaf> You're going to want a more general version of "concat" there. :-)
13:36:53 <mekeor> oh, right
13:37:02 <shachaf> (And also to call it Monad instead of Functor, if you use join.)
13:37:04 <benmachine> shachaf: I think my notion of well-behaved would demand that (<*>) and ap agree if both defined
13:37:07 <mekeor> shachaf: is there a functorConcat ?
13:37:09 <benmachine> otherwise it's too surprising
13:37:24 <shachaf> mekeor: It's called "join", and it's part of Monad.
13:37:32 <mekeor> shachaf: okay.
13:37:44 <shachaf> mekeor: The only thing you get with Functor is fmap, as you can figure out by looking at the definition.
13:37:45 <mekeor> cool :)
13:37:57 <mekeor> shachaf: yep
13:38:17 <mekeor> shachaf: can you write a `myMonadicAp' please?
13:38:18 <shachaf> benmachine: I suppose. In that case the word "also" is silly there.
13:38:22 <mandaya> :t join
13:38:23 <lambdabot> forall (m :: * -> *) a. (Monad m) => m (m a) -> m a
13:38:27 <mandaya> :t (>>=)
13:38:28 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m a -> (a -> m b) -> m b
13:38:30 <shachaf> mekeor: It's left as an exercise to the reader.
13:38:39 <mekeor> :)
13:38:39 <shachaf> (Or you can /msg lambdabot @src ap)
13:38:44 <mekeor> hehe
13:39:34 <mauke> :t liftM2 id
13:39:34 <lambdabot> forall a2 r (m :: * -> *). (Monad m) => m (a2 -> r) -> m a2 -> m r
13:40:49 <mekeor> why not use join instead of concat and fmap or even liftM instead of map everywhere?
13:41:19 <benmachine> mekeor: because sometimes it helps type inference to use a more specific function
13:41:36 <benmachine> mekeor: particularly if the type inference is going on in the brain of the person reading your code :)
13:42:07 <mekeor> benmachine: that's right, okay. but, in principle, it'd work, right?
13:42:36 <nand`> except where the monomorphism restriction applies or the compiler complains because of not being able to infer the type, yes
13:42:46 <benmachine> mekeor: it's theoretically possible for there to be a situation where concat would work but join wouldn't, because of ambiguous types
13:42:49 <nand`> in general it should always work if you provide the type manually
13:42:57 <benmachine> mekeor: however in the majority of cases this won't actually be a problem
13:44:05 <mekeor> nand` and benmachine: discuss! you have different opinions!
13:44:34 <benmachine> no, if you provide the type manually then it will always work
13:44:56 * shachaf wonders if there should be a #haskell-beginners
13:45:01 <nand`> mekeor: what I and benmachine said are not contradictions
13:45:09 <nand`> shachaf: I think this channel is quite friendly to beginners
13:45:22 <benmachine> :t fold
13:45:23 <lambdabot> Not in scope: `fold'
13:45:23 <mekeor> nand`: i didnt say contradictional.. i said different :P
13:45:27 <shachaf> I'm not saying it's unfriendly.
13:45:47 <benmachine> @let fold = Data.Foldable.fold
13:45:48 <lambdabot>  Defined.
13:46:01 <benmachine> :t fold . join . pure
13:46:02 <lambdabot> forall (t :: * -> *) m. (Data.Foldable.Foldable t, Monoid m, Monad t, Applicative t) => t m -> m
13:46:08 <shachaf> Data.Foldable.fold is evil.
13:46:09 <nand`> mekeor: The first sentence I said was just a paraphrased version of what benmachine said, ambiguous types
13:46:12 <mekeor> nand`: it not only is friendly to beginners, it also has to…
13:46:14 <benmachine> hmm
13:46:16 <nand`> shachaf: how so?
13:46:16 <benmachine> :t fold . join . pure . pure
13:46:17 <lambdabot>     Ambiguous type variable `t' in the constraints:
13:46:17 <lambdabot>       `Data.Foldable.Foldable t'
13:46:17 <lambdabot>         arising from a use of `fold' at <interactive>:1:0-3
13:46:20 <benmachine> there we go
13:46:24 <benmachine> :t fold . concat . pure . pure
13:46:25 <lambdabot> forall m. (Monoid m) => m -> m
13:46:30 <benmachine> yay for contrived examples :P
13:46:46 * mekeor wonders if there should be #haskell-professionals or so
13:46:47 <benmachine> shachaf: why so
13:47:15 <shachaf> benmachine: It's pretty much Data.ToList.
13:47:26 <nand`> shachaf: I don't think this channel's activity is high enough to warrant separation yet, but that may be due to timezones.
13:47:29 <shachaf> It uses some arbitrary ordering.
13:47:33 <benmachine> I guess I could use that instead if it would make you happy :P
13:47:43 <benmachine> but yes and no
13:48:00 <benmachine> surely it's only "pretty much" toList as far as monoids are "pretty much" lists anyway
13:48:17 <benmachine> lists are the free monoid, so of course there's going to be a connection there
13:48:36 <shachaf> The point is that an instance of Foldable is completely arbitrary.
13:48:44 <shachaf> Let's say you have a binary tree. What Foldable instance are you going to use?
13:48:55 <benmachine> shachaf: this is a fair point
13:49:07 <benmachine> but is it much more arbitrary than e.g. Ord on tuples?
13:50:07 <nand`> shachaf: these kind of ambiguities pop up elsewhere though, for example list and ZipList.. I don't know if there's a reasonable solution to this though, other than just newtyping every instance
13:50:09 <shachaf> Or derived Ord in general. Perhaps not.
13:50:26 * shachaf doesn't know what nand` is talking about.
13:50:52 <nand`> shachaf: maybe I'm misunderstanding you. You said “fold” is bad because there are many different ways to implement it (with different behavior)?
13:50:59 <benmachine> shachaf: we're spoiled by things like Functor where there is at most one instance, most type classes can't be that elegant :P
13:51:10 <cmccann> the Ord isntance on tuples is sheer nonsense for most semantics assigned to tuples
13:51:21 <cmccann> but it's convenient, because it lets tuples be sorted for stuff like Data.Map
13:51:30 <benmachine> cmccann: I don't know that I agree with that
13:52:03 <benmachine> I don't know of any total ordering on tuples apart from lexicographic, and then you just have to pick a priority and it might as well be the reading-order one
13:52:17 <benmachine> I mean, if you wanted to guess what the tuple ordering was
13:52:22 <cmccann> right, because total ordering on tuples doesn't make any inherent sense
13:52:25 <nand`> How is the Ord instance for (,) defined? case comparing fst .. of EQ -> comparing snd; .. ?
13:52:29 <shachaf> benmachine: If type classes were first-class or something I'd object less.
13:52:30 <cmccann> there's no ordering on (X, Y) coordinates
13:52:36 <benmachine> it's *possible* for you to be wrong (unlike Functor) but you probably wouldn't be :P
13:53:10 <benmachine> cmccann: there *is*, it's just that if you're talking about (x,y) as numbers then the ordering isn't interesting because the other structure on the set totally ignores it
13:53:44 <benmachine> but if they're not numbers that's not so much of a problem
13:54:03 <`Jake`> Wow, it's awesome to code with a US-Keyboard if you never had one before...
13:54:05 <cmccann> anything that's truly the cartesian product of two unrelated types has the same problem
13:54:08 <benmachine> nand`: it has that effect, yes
13:54:21 <Botje> `Jake`: unless you're writing scheme :P
13:54:29 <benmachine> cmccann: you could view tuples as fixed-length lists, in that context the ordering is natural
13:54:31 <cmccann> lexicographic ordering is obvious and simple, but it rarely has anything to do with what values of the type mean
13:54:39 <nand`> `Jake`: I found the transition to US from German layout to be quite positive for writing code in general
13:55:09 <mm_freak_> i have a german keyboard with a custom xmodmap
13:55:13 * hackagebot zeromq3-haskell 0.1.3 - Bindings to ZeroMQ 3.x  http://hackage.haskell.org/package/zeromq3-haskell-0.1.3 (ToralfWittner)
13:55:20 <`Jake`> Yeah, I used american layout with a german keyboard until now, but that is not too great
13:55:31 <cmccann> benmachine, and how often do we have to remind people learning the language that tuples aren't lists? :P
13:55:39 <mm_freak_> common programming symbols are easy to access for me without giving up conveniently writing german text
13:55:51 <benmachine> cmccann: well, what we're really saying is that (,)s aren't []s
13:56:03 <nand`> mm_freak_: US Interlingual works well. (I have a German layout as well, having \ in between Z and left shift is perfect), and it binds ä and so on to Alt Gr + Q
13:56:11 <Eduard_Munteanu> mm_freak_: do you mean for special german symbols?
13:56:22 <nand`> Personally I think (,) shouldn't have an Ord instance, in favor of using sortBy and comparing instead
13:56:40 <mm_freak_> Eduard_Munteanu: yes, and also for the swapped Z/Y
13:56:47 <cmccann> nand`, in theory that would be nice, in practice using Ord for lookups is kind of useful
13:56:49 <aristid> mm_freak_: with altgr-intl, i can _almost_ conveniently type german text :) alt-q, alt2-y and alt2-p make the umlauts
13:56:57 <Eduard_Munteanu> mm_freak_: I'm telling the editor to replace certain sequences with symbols when I write diacritics in my native language.
13:57:05 <`Jake`> Well, if I'll need to write a german text I'll just switch to the german layout for a second
13:57:14 <mm_freak_> Eduard_Munteanu: that's also a good option
13:57:24 <cmccann> this is why I wish we had three Ord classes, one for partial/total orders that actually mean something, and one for arbitrary total orders to use with Data.Map &c.
13:57:29 <Eduard_Munteanu> a-la Agda mode
13:57:30 <Eduard_Munteanu> :)
13:57:31 <mm_freak_> but having to type altgr-combinations for every umlaut would suck =)
13:57:34 <aristid> Eduard_Munteanu: like "o is replaced with ö?
13:57:35 <nand`> cmccann: But shouldn't the snd field be irrelevant for lookups, assuming multiple allowed values?
13:57:44 <nand`> if using tuples as a map
13:57:56 <aristid> mm_freak_: it does, but right now at least i type more agda code than german text :D
13:57:57 <cmccann> nand`, I mean as keys in Data.Map or the like
13:58:09 <cmccann> where you don't care what the ordering is, you just use it to define the data structure
13:58:11 <mm_freak_> aristid: i type haskell =)
13:58:22 <aristid> mm_freak_: haskell is less intense about the \ :D
13:58:24 <Eduard_Munteanu> aristid: yeah, that would do, although I use \a for ă for example
13:58:47 <Eduard_Munteanu> Works fine with xetex.
13:58:55 <nand`> cmccann: Oh, I see now. Yeah, it can be useful for that. But doesn't it suffice to write something like newtype Thing = (,) deriving (Ord)?
13:59:09 <nand`> if you need it for that purpose
13:59:22 <`Jake`> It's weird to have such a small Backspace key
13:59:27 <Eduard_Munteanu> And I don't like to write latex code for that.
13:59:28 <benmachine> nand`: why not just do that in the first place :P
13:59:32 <mm_freak_> but i'm also a typography enthusiast — nothing to do with types =P…  you can see that by my use of real ellipses and real em/en-dashes =)
13:59:35 <cmccann> nand`, it suffices but seems unnecessary
13:59:58 <mm_freak_> btw, i once was asked to stop doing that in #math
14:00:00 <cmccann> I'd rather have type classes to distinguish "these can be sorted for lookups" vs. "these have a meaningful ordering"
14:00:12 <benmachine> cmccann: I like the principle of the idea but I don't think it would be convenient to use
14:00:26 <Eduard_Munteanu> mm_freak_: why, do they see boxen? :)
14:00:31 <cmccann> benmachine, it would be convenient iff it had full support from most libraries
14:00:37 <mm_freak_> Eduard_Munteanu: probably they use ASCII =)
14:00:41 <Eduard_Munteanu> I'd expect #math to leverage unicode for notation.
14:00:43 <aristid> mm_freak_: #math hates unicode?
14:00:44 <cmccann> it's not something that can be retrofitted on
14:01:03 <mm_freak_> probably it's relaxed now
14:01:05 <benmachine> cmccann: well, no, you'd still be looking at up to three operators for <= that would be defined identically in many cases
14:01:07 <nand`> cmccann: yeah, that would be good for stuff like map which just needs some way to arbitrarily sort instances. They'd work just as well if compare was defined “the wrong way round”
14:01:26 <benmachine> cmccann: maybe one of them is a partial order, so it returns Maybe Bool, but it invariably returns Just
14:01:29 <cmccann> benmachine, the "sortable for data structures" doesn't need the nice operators
14:01:31 <Eduard_Munteanu> TBF, unicode fonts aren't great.
14:01:32 <benmachine> that kind of thing is blah
14:01:34 <`Jake`> zOMG
14:01:41 <rwbarton> especially monospace unicode fonts
14:01:53 <`Jake`> just noticed that I have Euro on the american keyboard?
14:01:55 <cmccann> reconciling partial and total ordering is more problematic though, yeah
14:01:57 <aristid> mm_freak_: it probably depends on the networks, but i think that utf-8 has gained enormously in terms of irc acceptance.
14:01:58 <mm_freak_> dejavu sans mono is great for haskell source code with unicode symbols
14:02:00 <benmachine> cmccann: I guess I'm just not convinced that very many errors are of the flavour "accidentally compared things which don't have a natural ordering
14:02:03 <benmachine> "
14:02:12 <Eduard_Munteanu> mm_freak_: yeah, but it's missing a lot of symbols
14:02:18 <aristid> mm_freak_: it's also the best programming font
14:02:23 <nand`> mm_freak_: I strongly advocate the usage of “unicode quotation marks” wherever possible for that matter
14:02:26 <rwbarton> well, the ellipsis character looks pretty dumb in my terminal
14:02:37 <Eduard_Munteanu> rwbarton: the only one that seems relatively complete is unifont, but it's rather ugly IMO
14:02:40 <benmachine> I have keys bound for unicode quotation marks but most of the time I can't be bothered >_>
14:02:43 <mm_freak_> Eduard_Munteanu: can't confirm that…  note that i'm writing haskell with haskell-mode's substitution feature
14:02:49 <mm_freak_> i'm not actually using unicode
14:02:51 <Eduard_Munteanu> At least when using larger point sizes.
14:03:03 <Brax> "Is the composition of two monads always a monad? As hinted previously, the answer is no. For example, XXX insert example here."
14:03:19 <Brax> secret
14:03:24 <cmccann> benmachine, many errors are caused by code not expressing its intent clearly, and I think clarity of meaning is worth pursuing in general
14:03:31 <aristid> Eduard_Munteanu: aren't editors supposed to try to use other fonts for missing symbols?
14:03:55 <mm_freak_> rwbarton: it looks pretty dumb in any terminal with a fixed width font, but you can configure irssi to expand unicode to ASCII
14:03:57 <nand`> aristid: that should be the job of the text rendering library
14:04:13 <mm_freak_> it then replaces "…" by "..."
14:04:14 <Eduard_Munteanu> aristid: yeah, though Emacs seems to take bad decisions in those respects for me :)
14:04:39 <mm_freak_> Eduard_Munteanu: note, the beauty of many fonts depends on your anti-aliasing settings
14:04:52 <mm_freak_> for my screen no antialiasing seems to look best
14:04:58 <nand`> … looks fine in my terminal, using fixed width Terminus
14:05:09 <benmachine> cmccann: I suppose so. I'm just not convinced of the cost/benefit payoff in this case
14:05:10 <rwbarton> or... people could just type ASCII in the first place.
14:05:12 <Eduard_Munteanu> Hm, perhaps I should play with those settings.
14:05:18 <cmccann> benmachine, neither am I!
14:05:28 <benmachine> cmccann: as an aside, I've seen the tuple Ord instance used intentionally in cabal-install code, I think
14:05:28 <cmccann> it's something I'd do if I were building a language from the ground up
14:05:29 <rwbarton> I mean, it doesn't look awful. Just less good than the alternative.
14:05:35 <mm_freak_> nand`: nothing wrong with how it's rendered in isolation, but this squeezed ellipsis looks weird with the rest
14:05:46 <cmccann> I don't think it's at all worth trying to "fix" in Haskell
14:05:48 <aristid> Eduard_Munteanu: i think most antialiasing today is geared towards TFTs
14:06:09 <benmachine> cmccann: of course, that sort of case *could* be replaced with use of mappend/mconcat on Ordering, but actually doing that is a fair bit more verbose
14:06:16 <Eduard_Munteanu> aristid: mm, though isn't that called subpixel AA/hinting?
14:06:24 <aristid> Eduard_Munteanu: yeah
14:06:32 <Eduard_Munteanu> I have that disabled.
14:06:48 <Eduard_Munteanu> Otherwise I get funny colors on my CRT.
14:08:00 <nand`> Eduard_Munteanu: you can configure it to use grayscale colors only, that's what I do, so I don't get rainbows everywhere but still reasonably smooth symbols at smaller font sizes. It's especially needed because my standard system font does not come with extra bold/italic typesetting so it's done by simply distorting the character, which produces lots of ugly aliasing without hinting
14:08:37 <Eduard_Munteanu> Oh, hm.
14:09:15 <everythingWorks> >>
14:09:18 <everythingWorks> nrand :)
14:09:20 <aristid> nand`: do you also have a TFT? :P
14:09:21 <everythingWorks> nand*
14:09:26 <aristid> -TFT+CRT
14:09:32 <nand`> This can be achieved by setting the monitor sub-pixel setting to “none”, for what it's worth
14:09:33 <mm_freak_> aristid: i have flat screens everywhere, yet disabled AA looks best for me
14:09:41 <mm_freak_> or perhaps i just don't like clear lines on screens =)
14:09:48 <nand`> aristid: I do not; but it still annoys me
14:09:49 <mm_freak_> wait a minute
14:09:56 <mm_freak_> no, i mean full AA without hinting
14:10:00 <aristid> mm_freak_: oO. well, if there are rainbow pixels, the AA is configured wrong.
14:10:03 <mm_freak_> it's not AA i disable, it's hinting
14:10:33 <aristid> i.e. you are not supposed to notice the colored subpixels
14:11:24 <mm_freak_> Eduard_Munteanu: play with your hinting settings, not the AA itself
14:11:38 <Eduard_Munteanu> mm_freak_: yeah, I have AA on.
14:11:42 <c_wraith> CRTs should not use subpixel antialiasing
14:12:05 <mm_freak_> in KDE i usually choose between slight and no hinting
14:12:21 <bgamari_> Arg, I suspect Data.Vector.Unboxed.replicateM builds a list and then fills the vector
14:12:25 <Eduard_Munteanu>   [3]   10-no-sub-pixel.conf *
14:12:45 <mm_freak_> bgamari_: no, it doesn't (for me)
14:12:47 <bgamari_> I could use Data.Vector.Unboxed.Mutable.replicateM, but this would require that Get be a monad transformer
14:12:53 <bgamari_> mm_freak_: Hmm, alright
14:13:04 <bgamari_> mm_freak_: It builds the vector incrementally?
14:13:13 <bgamari_> there goes that hypothesis
14:13:26 <bgamari_> I'm completely baffled in that case
14:13:37 <bgamari_> There must be an easier way to do this
14:13:50 <mm_freak_> bgamari_: not sure how it does it internally, but my guess is that it just allocates the full vector and then writes the values one after another
14:14:10 <bgamari_> mm_freak_: That is how I would have guessed too
14:14:25 <mm_freak_> i.e. it starts with an uninitialized vector (Unbox values have an "uninitialized" value)
14:14:35 <mm_freak_> s/values/types/
14:14:58 <bgamari_> mm_freak_: The I realized it doesn't need to be run in a monad; it could use ST internally, but then it would have to lift the monad it was working with into ST
14:15:09 <bgamari_> rather in a PrimMonad
14:15:41 <bgamari_> Which would require STT, but this isn't safe with some monads
14:16:20 <bgamari_> mm_freak_: Not to mention the fact that replicateM seems to be generating lists which scale linearly with the vector size
14:18:25 <Tyr42> Can I have some examples of CCC or other programming contest problems written in haskell?
14:18:45 <bgamari_> Is there any way to get the profiler to tell you of what type the allocations for each SCC were?
14:19:39 <cmccann> bgamari_, using a heap profile?
14:19:44 <cmccann> you can get type information that way
14:23:49 <bgamari_> cmccann: Yes, but I can't get both SCC and type information at the same time
14:24:09 <bgamari_> cmccann: -hy gives types, but doesn't annotate them with which SCC they came from
14:24:15 <cmccann> well, you can filter by either type or SCC
14:24:20 <cmccann> and then get a breakdown for the other
14:24:23 <mhitza> Tyr42, codejam ? http://www.go-hero.net/jam/11/solutions/0/1/Haskell
14:24:25 <cmccann> but that's not quite the same
14:24:57 <Tyr42> mhitza: thanks
14:25:14 * hackagebot algebra 2.0.5 - Constructive abstract algebra  http://hackage.haskell.org/package/algebra-2.0.5 (EdwardKmett)
14:40:15 * hackagebot algebra 2.0.6 - Constructive abstract algebra  http://hackage.haskell.org/package/algebra-2.0.6 (EdwardKmett)
14:46:49 <adimit> If I use putMVar x, are the contents of x copied? I'm trying to communicate a relatively big data structure between threads, which is why I'm asking.
14:48:22 <mm_freak_> adimit: no
14:48:38 <adimit> mm_freak_: thanks.
14:49:21 <mm_freak_> adimit: you never copy unless you change, and that can only be a problem with non-ADTs like arrays
14:49:23 <Axman6> adimit: since the value will never changem, there's no need to copy. the MVar just has a reference to the original value (which may even be a thunk)
14:49:55 <adimit> Axman6, mm_freak_, thanks. That's kinda what I already thought, but I wanted to make sure :-)
14:51:19 <lpsmith> sodium looks cool.  I should hook it up to PostgreSQL's listen/notify and do something cool with it.
14:51:53 <lpsmith> I'm not sure what seems cool enough, though
14:53:12 <DanBurton> hrm, say I have data Choice = Rock | Paper | Scissors. What's the simplest way to write an IO action that randomly selects a choice?
14:53:21 <DanBurton> derive enum?
14:53:29 <dmwit> randomR (minBound, maxBound)
14:53:35 <dmwit> err...
14:53:37 <dmwit> randomRIO, of course
14:53:58 <dmwit> :t randomRIO (minBound, maxBound)
14:53:59 <lambdabot> forall a. (Bounded a, Random a) => IO a
14:54:32 <dmwit> Wait, what?
14:54:39 <dmwit> ?src Bounded
14:54:40 <lambdabot> class  Bounded a  where
14:54:40 <lambdabot>     minBound, maxBound :: a
14:54:46 <dmwit> ...oh, Random
14:54:50 <dmwit> ?src Random
14:54:51 <lambdabot> class Random a where
14:54:51 <lambdabot>   random    :: RandomGen g => g -> (a, g)
14:54:51 <lambdabot>   randoms   :: RandomGen g => g -> [a]
14:54:51 <lambdabot>   randomR   :: RandomGen g => (a,a) -> g -> (a,g)
14:54:51 <lambdabot>   randomRs  :: RandomGen g => (a,a) -> g -> [a]
14:54:53 <lambdabot>   randomRIO :: (a,a) -> IO a
14:54:55 <lambdabot>   randomIO  :: IO a
14:55:42 <harlekin> What is the last argument to VertexArrayDescriptor in Haskell's OpenGL binding?
14:56:10 <DanBurton> so the data type also needs to be an instance of Random
14:56:27 <dmwit> DanBurton: Yeah, so, the question still stands. I understand.
14:56:29 <mauke> tunnel through Enum
14:56:37 <dmwit> But yeah, tunnel through Enum or so.
14:56:45 <sipa> hi noname120
14:56:51 <noname120> Hi sipa
14:56:57 <noname120> let try to convince me
14:56:58 <dmwit> :t liftM toEnum (randomRIO (fromEnum minBound, fromEnum maxBound))
14:56:59 <lambdabot>     Ambiguous type variable `a' in the constraints:
14:56:59 <lambdabot>       `Bounded a'
14:56:59 <lambdabot>         arising from a use of `minBound' at <interactive>:1:34-41
14:57:15 <sipa> noname120: there's a bot here that allows evaluating haskell expressions
14:57:18 <sipa> > 5+4
14:57:19 <lambdabot>   9
14:57:38 <noname120> ok sips
14:57:44 <noname120> * sipa
14:57:58 <noname120> Is it an OOP language ?
14:58:05 <mauke> no
14:58:11 <noname120> :/
14:58:24 <DanBurton> aw no Random in the derive package :(
14:58:26 <mauke> you misspelled :)
14:58:43 <adimit> There's a chapter in RWH about making a threadManager so that one thread can wait for another to finish. Is there a library on hackage that I could use instead of implementing their code?
14:58:49 <adimit> Here's what I mean:  http://book.realworldhaskell.org/read/concurrent-and-multicore-programming.html#id673306
14:59:11 <DanBurton> mauke: false. Haskell is an OOP language. It is not, however, a class-based language, which is what most people think of when they say OOP
14:59:19 <UsedMeAWotsit> @pl \p f -> p >>= return . f
14:59:19 <lambdabot> (. (return .)) . (>>=)
14:59:20 <noname120> ok
14:59:24 <mm_freak_> adimit: to wait for a thread you really just need to create an MVar ()
14:59:25 <noname120> too bad
14:59:38 <mauke> DanBurton: how do you define OO?
15:00:05 <DanBurton> mauke: the usual way: an orientation around "objects", meaning, that the emphasis is on data and not on effects
15:00:06 <mm_freak_> adimit: this is how i do it:  putMVar cmdChannel (QuitMsg (putMVar quitVar ())) >> takeMVar quitVar
15:00:11 <monochrom> in that sense mauke's answer is still right
15:00:39 <UsedMeAWotsit> Quick question: Anyone know of a built-in/standard-library operator equivalent to flip fmap or flip liftM ?
15:00:48 <mauke> DanBurton: that is not "usual" in any way I recognize
15:01:32 <DanBurton> mauke: according to my loony professor, it was "usual" back when the term OO was undefiled. You know, when they started making CLOS
15:01:44 <UsedMeAWotsit> Basically, I'd love to avoid saying: foo >>= return . bar  all the time.
15:02:15 <adimit> mm_freak_: thanks, that makes sense :-)
15:02:17 <DanBurton> UsedMeAWotsit: that pattern has a known simplification. foo >>= return . bar === fmap bar foo
15:02:30 <UsedMeAWotsit> DanBurton: Yes, I know.
15:02:31 <aristid> UsedMeAWotsit: no, but it's a matter of two lines in your code to write it yourself
15:02:41 <DanBurton> UsedMeAWotsit: so what's your beef with putting the args in the opposite order?
15:02:52 <UsedMeAWotsit> DanBurton: Hence my original question "Anyone know of a built-in/standard-library operator equivalent to flip fmap or flip liftM?"
15:03:12 <UsedMeAWotsit> DanBurton: The key thing is I want it in operator form.
15:03:24 <dolio> bar <$> foo
15:03:35 <monochrom> it is not in a standard library. feel free to define one yourself.
15:03:37 <DanBurton> dolio: except <$> has the same order as fmap
15:03:37 <nand`> <$> is not flip fmap
15:03:59 * DanBurton wonders if unicode has a backwards $ sign
15:04:07 <tgeeky> DanBurton: nope, I don't think so
15:04:11 <nand`> let <€> = flip <$> in ...
15:04:26 <monochrom> I second €
15:04:29 <aristid> is € a valid operator charachter?
15:04:35 <monochrom> yes
15:04:35 <tgeeky> yes
15:04:48 <aristid> > generalCategory '€'
15:04:49 <lambdabot>   CurrencySymbol
15:04:57 <UsedMeAWotsit> Well, I was going to invent my own, as >>=: but figured I should check to make sure there wasn't one first.
15:04:58 <monochrom> I think lambdabot supports it too
15:05:05 <aristid> hmm.
15:05:14 <aristid> UsedMeAWotsit: fair enough
15:05:23 <nand`> hmm
15:05:26 <UsedMeAWotsit> Actually, I seem to recall that something uses >>$, but I forget what does.
15:05:27 <monochrom> > let x € y = y <$> x in id € [0]
15:05:28 <lambdabot>   Couldn't match expected type `a -> b' against inferred type `[a1]'
15:05:39 <dolio> DanBurton: I thought "The key thing is I want it in operator form." was an answer to "What's your beef with ...", but I guess it wasn't.
15:05:40 <monochrom> ha, wrong order
15:05:46 <monochrom> > let x € y = y <$> x in [0] € id
15:05:47 <lambdabot>   [0]
15:06:04 <nand`> Possible language extension: a `flip fmap` b, would be desugared to (flip fmap) a b
15:06:17 <dmwit> DanBurton: Huh, writing randomEnum :: (Bounded a, Enum a) => IO a is surprisingly tricky without any extensions.
15:06:18 <nand`> ie. allowing arbitrary expressions inside `
15:06:38 <hpc> nand`: until you want to nest the ````````
15:06:51 <mauke> dmwit: can't be that hard
15:06:53 <sekuhara> nand's active everywhere i see
15:06:53 * mauke tries
15:06:59 <sekuhara> <-- noir, nick taken
15:07:08 <nand`> sekuhara: It's a common name
15:07:15 <monochrom> wait, don't you need (Bounded a, Random a, Enum a) for randomEnum?
15:07:21 <DanBurton> my arrow fu is weak. Isn't this predefined as something? \f -> first f >>> second f
15:07:22 <sekuhara> i know, actually i wonder how i managed to reg it on rizon
15:07:24 <hpc> :t randomEnum
15:07:25 <lambdabot> Not in scope: `randomEnum'
15:07:25 <nand`> hpc: I don't see what's wrong with simple nesting rules here
15:07:43 <dmwit> mauke: I did it, but I was surprised at my result. =)
15:07:44 <dolio> DanBurton: join (***)
15:07:48 <nand`> a `b c `d e` f` g would desugar to ((d e) (b c) f) a g
15:07:52 <DanBurton> @t join (***)
15:07:52 <lambdabot> Maybe you meant: tell thank you thanks thx ticker time todo todo-add todo-delete topic-cons topic-init topic-null topic-snoc topic-tail topic-tell type . ? @ ft v
15:07:57 <DanBurton> @type join (***)
15:07:57 <lambdabot> forall (a :: * -> * -> *) b c. (Arrow a) => a b c -> a (b, b) (c, c)
15:08:02 <DanBurton> nice
15:08:24 <monochrom> "I said, "you are amazing"" is what's wrong with simple nesting
15:08:25 <ddarius> monochrom: That would defeat the point.  Int has a Random instance.
15:08:28 <hpaste> dmwit pasted “randomEnum” at http://hpaste.org/64134
15:08:33 <nand`> hpc: ambiguity can be removed by forcing the whitespace, ie. a `b` c ≠ a `b `c
15:08:39 <hpc> nand`: why wouldn't it desugar to f ((b c) a (d e)) g?
15:08:41 <nand`> or rather lack thereof
15:09:27 <DanBurton> dmwit: interesting "forUnificationOnly" hack :)
15:09:31 <_Vi> {- The program: -}  B.readFile "q.mkv" >>= \contents -> B.writeFile "qq.mkv" contents     {- The question: -} Why for each read syscall I see two write syscalls (the first writes 0 bytes: 'write(4, "", 0)  = 0')
15:10:08 <dmwit> Of course, it's much, much easier with ScopedTypeVariables. =)
15:10:31 <nand`> hpc: two solutions: either assume ` f` ≠ `f ` ≠ `f` or disallow nesting ` in general
15:10:44 <hpaste> dmwit annotated “randomEnum” with “with ScopedTypeVariables” at http://hpaste.org/64134#a64135
15:11:00 <hpc> i would go with disallowing nesting
15:11:18 <monochrom> I second disallowing nesting
15:11:21 <hpc> backticks are visually very small, which makes it hard to count whitespace
15:11:39 <dmwit> `(   ...    )` allows nesting
15:11:43 <nand`> agreed then, chances are if you're nesting ` your code needs refactoring
15:11:43 <hpc> and there's no precedent for significant whitespace in anything but separating identifiers
15:11:50 <dmwit> ...and is backwards compatible with ``
15:12:03 <nand`> it's really only intended for stuff like `flip fmap`
15:12:05 <hpaste> mauke annotated “randomEnum” with “randomEnum (annotation)” at http://hpaste.org/64134#a64136
15:12:06 <dolio> You mean "w `x `f` y` z" would be different than "w `x` f `y` z"?
15:12:08 <dmwit> Of course, I've only read the last two sentences.
15:12:29 * cmccann agrees with using `( ... )`
15:12:40 <monochrom> well, by the time you get to `(x)`, you may as well go with «x», which is good for nesting
15:12:43 <mauke> dmwit: what do you think about my version?
15:12:50 <dmwit> mauke: I like it a lot!
15:13:01 <dmwit> mauke: However, I don't think it disproves the "surprisingly difficult" claim. =)
15:13:07 <nand`> dolio: yes. One would be (f x y) w z and the other would be either y (x w f) z or x w (y f z) depending on whether that's left associative or right associative, I don't know
15:13:16 <mauke> it could use a bit more fix
15:13:27 <dolio> nand`: That's pretty evil.
15:13:42 <nand`> monochrom: « is fairly tricky to type though. I thought Haskell avoided using unicode characters where not necessary?
15:13:55 <nand`> dolio: yeah, which is why it's not a good solution :)
15:14:09 <ddarius> mauke's solution is closer to the typical way of handling such situations (other than using scoped type variables.)
15:14:19 <monochrom> as it turns out, it's just meta-<-< over here
15:14:30 <nand`> > fst `id ` (1,2)
15:14:31 <lambdabot>   1
15:14:36 <nand`> oh, that's allowed?
15:14:52 <nand`> that puts the nail in the coffin :)
15:15:57 <nand`> monochrom: Alt Gr + [ for me, but that's beside the point. Haskell doesn't use unicode arrows instead of -> etc. for a reason
15:16:25 <nand`> I believe being able to type on a standard ANSI keymap is a reasonable goal
15:16:28 <monochrom> the reason is it was designed 20 years ago.
15:16:39 <mauke> "ANSI"?
15:16:58 <ddarius> Indeed.  Haskell didn't support Unicode syntax until 1.3 I believe.
15:17:08 <nand`> oh, wait, ANSI is the physical layou
15:17:13 <nand`> t*, QWERTY then
15:17:18 <monochrom> do you know what the world was like 20 years ago?
15:17:38 <tgeeky> who cares! that's not even old enough to be history yet
15:17:40 <mauke> "ANSI is the physical layout"?!
15:17:54 <tgeeky> nand`: I think you might have that exactly backwards, but I suspect it's at least wrong
15:18:00 <monochrom> like, the corpse of the USSR was still warm
15:18:03 <hpc> @remember nand` oh, wait, ANSI is the physical layout
15:18:03 <lambdabot> Good to know.
15:18:08 <nand`> “Today, most keyboards use one of three different mechanical layouts, usually referred to as simply ISO (ISO/IEC 9995-2), ANSI (ISO 9995-3), and JIS (JIS X 6002-1980)”
15:18:21 <nand`> source https://en.wikipedia.org/wiki/Keyboard_layout
15:18:23 <mauke> "mechanical"?
15:18:39 <geekosaur> and as everyone knows, wikipedia is always 100% reliable
15:18:42 <nyingen> pfft, wikipedia. anyone can edit that!
15:18:43 <tech2> I remember when languages had their odd special characters and it was a challenge to write in some of them... smalltalk, I'm looking at YOU!
15:18:58 <nand`> geekosaur: are you suggesting this information is false?
15:19:03 <monochrom> and you would not ask new acquaintances for email addresses, or even cell phone numbers
15:19:05 <ddarius> tech2: It had one which had _ as a substitute.
15:19:09 <Brax> what does T mean if it wasn't defined: "parametric polymorphism (types of the form /forall X: T)"
15:19:13 <tgeeky> as defined on wikipedia, mechanical means "the placement and <i> keys </i> of the keyboard"
15:19:13 <mauke> oh, I see
15:19:26 <Brax> from the free theorems paper by wadler
15:19:29 <mauke> it's the physical layout
15:19:32 <tech2> ddarius: the assignment arrow?
15:19:35 <mauke> not what the keys are mapped to
15:19:44 <nand`> mauke: exactly
15:19:54 <mauke> nand`: so completely irrelevant
15:19:58 <nand`> The physical layout of the keys and their numeric codes, rather.
15:20:05 <mauke> because it tells you nothing about what characters you can type
15:20:06 <nand`> mauke: Yes, thus  nand` │ oh, wait, ANSI is the physical layout
15:20:15 <nand`> I did retract my statement
15:20:18 <ddarius> Brax: He's probably using it as a metavariable for an arbitrary type expression.
15:20:20 <Brax> tautology?
15:20:52 <mauke> nand`: ah. I understand
15:24:08 <accel> I'm working on a project where I'm basically stuck using java due to legacy reasons. What is the closest thing to Haskell on Java?
15:24:24 <c_wraith> scala with scalaz
15:24:27 <monochrom> "mechanical layout" means the robot had to know this layout in order to mechanically enter stuff through the keyboard. "but why through the keyboard, why not through USB?" you ask. well, 20 years ago, there was no USB, and overall robot-to-computer interfaces were pretty crude, full of mechanical layouts
15:24:44 <nand`> Fun fact: the “ANSI” (aka ISO/IEC 9995-3) standard actually includes the keyboard map as well, which includes « and » as well (overloaded on the z and x keys), so that turns my earlier argument against itself :)
15:26:10 <nand`> (In particular, it defines the positions of the “commond secondary groups” accessible via modifiers to the actual physical key locations, it does not standardize the main keys (A-Z and so on))
15:26:47 <nand`> since 2002
15:27:35 <accel> c_wraith: thanks
15:29:39 <ddarius> monochrom: We had serial, parallel, SCSI, ethernet, etc. etc. 20 years ago.
15:30:04 <monochrom> I was just joking
15:31:12 <nand`> @remember monochrom "mechanical layout" means the robot had to know this layout in order to mechanically enter stuff through the keyboard. "but why through the keyboard, why not through USB?" you ask. well, 20 years ago, there was no USB, and overall robot-to-computer interfaces were pretty crude, full of mechanical layouts"mechanical layout" means the robot had to know this layout in order to mechanically
15:31:12 <lambdabot> Done.
15:31:14 <nand`> enter stuff through the keyboard. "but why through the keyboard, why not through USB?" you ask. well, 20 years ago, there was no USB, and overall robot-to-computer interfaces were pretty crude, full of mechanical layouts
15:31:16 <nand`> blah
15:32:00 <nand`> Multi-line copying is something I still have to figure out
15:32:01 <monochrom> you love my saying so much, you remember it twice :)
15:33:40 <hpaste> “Ben Gamari” pasted “Cereal is unfortunate” at http://hpaste.org/64139
15:33:52 <bgamari_> Anyone have any idea what cereal is leaking?
15:34:32 <hpaste> “Ben Gamari” annotated “Cereal is unfortunate” with “Cereal is unfortunate (profile)” at http://hpaste.org/64139#a64140
15:35:16 <scooty-puff> so i was wondering if someone could perhaps point me in the right direction on this algorithm problem (not haskell related, though i will be implementing it in haskell - if i should take this somewhere else, please say so)
15:35:24 <bgamari_> I don't actually parse anything, yet cereal generates 60MB of heap allocations
15:36:05 <monochrom> probably normal behaviour for G.replicateM
15:36:09 <DanBurton> @pl do x <- randomIO; print x; return x
15:36:09 <lambdabot> (line 1, column 17):
15:36:09 <lambdabot> unexpected ";"
15:36:09 <lambdabot> expecting letter or digit, variable, "(", "`", "!!", ".", operator or end of input
15:36:27 <DanBurton> @undo do x <- randomIO; print x; return x
15:36:27 <lambdabot> randomIO >>= \ x -> print x >> return x
15:36:46 <DanBurton> @pl randomIO >>= \ x -> print x >> return x
15:36:46 <lambdabot> liftM2 (>>) print return =<< randomIO
15:37:04 <bgamari_> monochrom: How so?
15:37:16 <DanBurton> an so in other words, another case where I'm wishing for idiom brackets
15:37:25 <bgamari_> mm_freak_: Any idea here?
15:37:30 <monochrom> BS.readFile also allocates memory and reads the file begin-to-end even though you discard it later
15:37:55 <bgamari_> monochrom: Right, but the file is only 500kBytes
15:38:15 <nand`> DanBurton: In this case I would introduce a “side effect” helper function :: m a -> (a -> m b) -> m a
15:38:24 <bgamari_> monochrom: Most of the allocations are of type Success, -> *, and []
15:38:33 <nand`> @hoogle m a -> (a -> m b) -> m a
15:38:34 <lambdabot> Prelude (>>=) :: Monad m => m a -> (a -> m b) -> m b
15:38:34 <lambdabot> Control.Monad (>>=) :: Monad m => m a -> (a -> m b) -> m b
15:38:34 <lambdabot> Control.Monad.Instances (>>=) :: Monad m => m a -> (a -> m b) -> m b
15:38:49 <bgamari_> monochrom: ARR_WORDS is only 10% of the heap
15:39:11 <kadoban> i've found some interesting pages on making haskell input much faster than the nieve way, is there also such information for output?  like, are there huge improvements to be had in outputting long lists of Ints somehow?
15:40:34 <bgamari_> Should I be looking for anything in particular while grokking Core for heap issues?
15:40:37 <dmwit> kadoban: Actually, "show" isn't as agregiously inefficient as "read" is.
15:40:56 <dmwit> kadoban: "read" really is parsing Haskell expressions, and then restricting to a subset of them that happen to look like numeric literals.
15:41:19 <dmwit> > read "  (  ((-0x32) )\t)  " :: Int
15:41:20 <lambdabot>   -50
15:41:32 <kadoban> hmm, okay, good to know.  i guess i won't worry too much about it until it comes up then
15:41:46 <alpounet> bgamari_, probably worth investigating the replicateM here
15:42:10 <dmwit> I mean, the same basic tricks are applicable. Use ByteString/Text and hand-tuned builders for output if it really becomes a bottleneck.
15:43:15 <nand`> > read "-5"
15:43:15 <lambdabot>   *Exception: Prelude.read: no parse
15:43:18 <nand`> > read "-5" :: Int
15:43:19 <lambdabot>   -5
15:43:32 <bgamari_> alpounet: If only I knew how
15:43:39 <bgamari_> alpounet: The Core produced is quite inpenetrable
15:43:48 <kadoban> dmwit: is there a "show" that does a -> ByteString, or even something similar for specific types (like ints?)
15:43:53 <dmwit> > read " ( -0x32e7 )" :: Int
15:43:54 <lambdabot>   -13031
15:43:57 <dmwit> wow
15:44:01 <bgamari_> alpounet: and even the implementation itself is pretty dense
15:44:18 <dmwit> kadoban: I'm sure there is somewhere. I don't know off the top of my head what to look for.
15:44:38 <bgamari_> alpounet: In that I'm not too familiar with the "Stream" concept that the function is built upon
15:44:47 <kadoban> okie, no biggie. ill take a look around through the docs
15:46:22 <alpounet> bgamari_, well, looking at http://www.haskell.org/haskellwiki/Numeric_Haskell:_A_Vector_Tutorial#Parsing_Binary_Data may give a clue as to how to proceed?
15:46:30 <alpounet> this is for Binary, but that shouldn't be much different
15:46:41 <alpounet> (i have only been using Binary for serialization, so can't help here)
15:46:59 <alpounet> 'cause i don't see why you replicate considering you're getting the content from a file
15:48:27 <nand`> kadoban: You mean something like (Serializable a) => a -> ByteString?
15:48:34 <dmwit> Oh, I misunderstood that result.
15:48:42 <dmwit> > read " ( -32e7 ) " :: Int
15:48:43 <lambdabot>   -320000000
15:48:53 <dmwit> > read " ( -0o32e7 ) " :: Int
15:48:54 <lambdabot>   *Exception: Prelude.read: no parse
15:48:59 <bgamari_> alpounet: Point taken
15:49:53 <kadoban> nand`: it's mostly for things like sphere online judge. like, for one problem i need to print several thousand "\n" separated integers
15:50:04 <dmwit> > (5e7 `div` 4e7, 0x5e7 `div` 0x4e7)
15:50:05 <lambdabot>   Ambiguous type variable `t' in the constraints:
15:50:05 <lambdabot>    `GHC.Real.Fractional t'
15:50:05 <lambdabot> ...
15:50:32 <alpounet> bgamari_, moreover, the parse function written there probably lets laziness quick in, so that the vector is filled as the file content is un-serialized
15:50:39 <dmwit> > let readDiv = div `on` read in (readDiv "5e7" "4e7", readDiv "0x5e7" "0x4e7")
15:50:40 <lambdabot>   (1,1)
15:50:59 <nand`> kadoban: And you're running into problems using regular show and stdout?
15:51:07 <nand`> Or just curious?
15:51:33 <kadoban> nand`: so, i'm not sure if that's what i want. i don't see Serializable in hoogle...usually that'd be not-necessarily human readable, yes?  sort of both just curious and the other. my answer to one question is taking too long, but it may not be output's fault
15:51:45 <alpounet> s/quick/kick/
15:53:01 <nand`> I'd imagine if spoj is parsing thousands of numbers that your program writes to stdout then it should be adequately timed as for that not to be too much of a problem; but I've run into some performance issues when testing haskell programs on spoj as well in the past, and there are a number of discussions going on in its haskell forums about increasing the time limit
15:53:17 <dmwit> nand`: Surely spoj is not doing any parsing at all.
15:53:26 <dmwit> nand`: Just a byte-by-byte comparison to the correct answer.
15:53:29 <dmwit> (Or similar.)
15:53:33 <nand`> dmwit: Yeah, that's what I meant
15:53:39 <nand`> I did not mean “parsing” that literally
15:53:40 <nand`> I meant “reading”
15:54:19 <nand`> They might still do some processing though to ie. allow \r\n instead of \n, I'm not sure
15:54:44 <kadoban> ya, sounds like i probably shouldn't worry about it i guess...at least not until after i profile and such
16:07:09 <bgamari_> alpounet: I rewrote it just using bytestring; things are much better. Thanks!
16:07:24 <bgamari_> I feel silly for struggling so long trying to get cereal to work for such a simple problem
16:07:59 <cmccann> bgamari_, out of curiosity, is this something hackage-related you're working on? :]
16:08:12 <bgamari_> cmccann: heh, I wish
16:08:31 <bgamari_> cmccann: This is for work
16:08:35 <cmccann> ah, well
16:08:41 <cmccann> I could hope :P
16:08:57 * cmccann is feeling a bit discouraged about the whole thing
16:09:38 <bgamari_> cmccann: Things aren't that far off it seems
16:09:52 <bgamari_> cmccann: The lack of available man-hours is a bit unfortunate
16:09:58 <bgamari_> cmccann: but it will happen eventually
16:10:05 <bgamari_> cmccann: I'll hopefully have some time this weekend
16:10:31 <cmccann> bgamari_, I'm mostly just frustrated about acid-state at the moment
16:10:39 <cmccann> and the general poor performance of the whole thing
16:10:51 <cmccann> given that hackage is like 99% static content really
16:11:25 <alpounet> bgamari_, glad you solved your problem!
16:12:23 <alpounet> cmccann, there was quite some agitation these days about hackage2
16:12:35 <alpounet> has anyone actually written something?
16:12:58 <bgamari_> cmccann: Is there really much of a problem?
16:13:24 <bgamari_> cmccann: My last mirror attempt got to the Ps and the interface is quite snappy
16:13:33 <cmccann> bgamari_, strictly speaking it's not a major problem, it just seems absurd that it takes several minutes to start up the server and consumes that much RAM
16:14:17 <MagneticDuck> haskell
16:14:26 <alpounet> several minutes? seriously?
16:14:36 <cmccann> it just makes development work more of a pain and I'm concerned that if new features degrade performance it could become a serious problem
16:14:53 <bgamari_> alpounet: I put some time into organizing the wiki and ticket tracker
16:15:05 <bgamari_> alpounet: so at least we know what needs to be done
16:15:14 <bgamari_> or at least have a lower bound on the amount of work required
16:15:20 <bgamari_> which isn't too bad
16:15:23 <cmccann> alpounet, it loads the entire package index into memory at startup using acid-state, which consumes gigabytes of RAM and takes several minutes. nearly half an hour on my EC2 instance.
16:15:48 <cmccann> I have it running on EC2 here: http://hackage2.uptoisomorphism.net/
16:15:53 <cmccann> as you can see it actually runs okay
16:16:00 <luite> a micro instance?
16:16:01 <cmccann> once it finally starts up
16:16:02 <cmccann> yes
16:16:05 <luite> whoah :)
16:16:15 <cmccann> which really ought to be sufficient to run a site like hackage
16:16:25 <bgamari_> On that note, my mirror attempts inevitably fail at PlslTools with HTTP 400
16:16:26 <cmccann> it's mostly static and doesn't have that much data
16:16:29 <bgamari_> cmccann: Have you seen this?
16:16:30 <alpounet> bgamari_, yeah but you were already involved in hackage right?
16:16:40 <bgamari_> alpounet: Nope
16:16:41 <luite> hmm, dcoutts siad that hackage uses a lot of traffic
16:16:45 <cmccann> bgamari_, nope, I haven't used the mirror client
16:16:46 <alpounet> oh, ok
16:16:57 <bgamari_> cmccann: Fair enough
16:17:11 <cmccann> luite, yes, but traffic should be the only limiting factor, not straining the server just to run it idling
16:17:15 <bgamari_> I'll have to look into this I guess
16:17:35 <luite> cmccann: yeah but I mean that amazon traffic is relatively expensive
16:17:47 <cmccann> the copy running on EC2--which doesn't have any tarballs, note--generates craploads of I/O requests just because of swapping due to the GC
16:17:57 <alpounet> cmccann, is the package index THAT large?
16:18:38 <cmccann> alpounet, it's a ~4MB tarball
16:18:56 <cmccann> actually loading it into memory takes over a GB
16:19:13 <alpounet> wow
16:19:18 <cmccann> I think it took more like ~6GB before I replaced a bunch of Strings with Text
16:19:33 <alpounet> that's still odd
16:20:12 <alpounet> cmccann, do you know where the code that generates the index is?
16:20:18 <cmccann> I don't think I'm crazy to think that a site serving mostly static content with < 10MB of meaningful data shouldn't need 2GB of RAM and take 30min to start up
16:20:24 <cmccann> even on an EC2 micro instance
16:20:54 <zeratul> Is there an explanation of Data.Data somewhere that is suitable for stupid people?
16:20:56 <dmwit> :t scanl
16:20:57 <lambdabot> forall a b. (a -> b -> a) -> a -> [b] -> [a]
16:21:03 <dmwit> :t scanl max
16:21:04 <lambdabot> forall a. (Ord a) => a -> [a] -> [a]
16:21:05 <cmccann> alpounet, I downloaded the tarball from hackage's front page
16:21:11 <mandaya> "A OR B.
16:21:15 <mandaya> What's the value of that? True? False?
16:21:16 <alpounet> cmccann, there's definitely smth wrong here
16:21:19 <mandaya> You don't know unless you have the values of A and B. What's that? Oh. It's state."
16:21:21 <dmwit> scanl max 0 [1,5,3,4,7,9,9,9,8]
16:21:23 <mandaya> why do I still read /r/programming?
16:21:24 <dmwit> > scanl max 0 [1,5,3,4,7,9,9,9,8]
16:21:25 <lambdabot>   [0,1,5,5,5,7,9,9,9,9]
16:21:50 <luite> cmccann: does it serve all package archives from disk?
16:22:01 <cmccann> alpounet, I spent last evening trying to figure out a sensible way to at least load things on demand rather than pull it all into memory at once
16:22:06 <cmccann> but was thwarted by the design of acid-state
16:22:15 <dmwit> :t scanl1
16:22:16 <lambdabot> forall a. (a -> a -> a) -> [a] -> [a]
16:22:17 <cmccann> luite, the actual tarballs I'm not sure how it handles
16:22:42 <jfischoff> zeratul:what do you want to know how to do?
16:22:54 <cmccann> I'm just dealing with the index, i.e. the content of all the .cabal files basically
16:23:00 <lispy> ?tell mekeor Yes, isabelle is (quite) actively developed and widely used. As far as theorem provers go, it's one of the most widely used and actively developed.
16:23:00 <lambdabot> Consider it noted.
16:23:04 <cmccann> plus stuff like user accounts and build logs and whatnot
16:23:28 <alpounet> cmccann, yeah but come on
16:23:32 <alpounet> several GB?!
16:23:38 <alpounet> where the hell can it come from
16:23:52 <cmccann> I don't know
16:24:30 <cmccann> I at least cut out the multiple GB of Strings
16:24:52 <zeratul> jfischoff: Essentially I'm trying to figure out whether I can use it to decompose the fields of an adt
16:25:09 <csabahruska> hi
16:25:09 <zeratul> sadly I have a small brain and it doens't seem to be enoug
16:25:11 <zeratul> h
16:25:34 <jfischoff> zeratul: do you need to use Data.Data?
16:25:53 <zeratul> Nope, it was just looking like it might have something that can do it
16:26:00 <alpounet> cmccann, nobody motivated to investigate this?
16:26:01 <zeratul> If you have some better suggestion..
16:26:11 <cmccann> the current heap profile is dominated by a mixture of something called ARR_WORDS which I assume is array data, (:), and "Bin" which I believe is internal nodes of Data.Map
16:26:29 <cmccann> alpounet, well, investigate what?
16:26:35 <jfischoff> zeratul: I am more familar with the new Generics
16:27:08 <csabahruska> May I ask an DSL related question? I'd like to know more about HOAS -> Closure conversion. Why is it important? Is it necessary?
16:27:10 <cmccann> I mean, it uses lots of memory and loads everything up-front, there's not much to investigate
16:27:13 <zeratul> Could you tell me where that is so I could have a look?
16:27:47 <cmccann> at this point I doubt there's much that can be fixed by simple changes
16:27:53 <jfischoff> zeratul: I pm'ed you
16:27:54 <cmccann> it either needs to use less data, or not use it all at once
16:28:21 <cmccann> and those are both difficult without abandoning a major dependency used for a lot of functionality
16:28:39 <alpounet> cmccann, that still looks way too big for what the server actually has to keep in memory
16:29:03 <cmccann> well, define "has to keep in memory".
16:29:09 <alpounet> well
16:29:09 <cmccann> it's clearly a very inefficient way to do things
16:29:12 <alpounet> the package index
16:29:15 <alpounet> and maybe a few other stuffs
16:29:21 <alpounet> 2GB?!
16:29:28 <cmccann> but I don't think there's anything it's not USING, is the problem
16:30:07 <cmccann> alpounet, you don't have to tell me it's absurd :P
16:30:17 <cmccann> I'm the one who's been complaining about this on IRC every few days
16:30:34 <cmccann> and has spent multiple evenings profiling and refactoring to try and trim things down
16:30:36 <bgamari_> cmccann: Have the acid-state people said anything about this
16:30:37 <alpounet> cmccann, yeah but maybe some data representations that aren't suited for this
16:30:39 <alpounet> i don't know
16:30:43 <alpounet> but seriously 2GB this is insane!
16:30:48 <cmccann> alpounet, well
16:30:49 <bgamari_> I mean, it's built to be an in-memory acid store
16:30:56 <cmccann> the data representation is basically "Cabal"
16:31:08 <bgamari_> but still, perhaps they can provide some guidance
16:31:21 <cmccann> bgamari_, I don't know, but based on how acid-state works I'm not optimistic
16:31:41 <bgamari_> I agree, the in-memory assumption seems pretty central to its design
16:31:42 <cmccann> as far as I can tell it's either "all or nothing" loading, or you give up any sort of transactional guarantees
16:31:46 <alpounet> cmccann, some people in #happs may be of help
16:31:55 <luite> hm, 2GB would be ~100kB per package
16:32:07 <bgamari_> cmccann: Is it using ixset?
16:32:17 <cmccann> luite, count "package versions" not "packages", note
16:32:25 <luite> yeah
16:32:31 <cmccann> bgamari_, no, but I'm not sure how that would help
16:32:32 <luite> just over 20k on my mirror atm
16:32:37 <bgamari_> it wouldn't
16:32:40 <cmccann> heh
16:32:54 <luite> 20067
16:33:04 <cmccann> it's mostly got lots of Data.Map and lists (many now being Vector)
16:33:09 <cmccann> filled with Cabal's data types
16:33:19 <cmccann> which are mostly records full of craptons of metadata and package info
16:33:53 <cmccann> which is why I said above that I'm not sure how to avoid this without removing a major dependency
16:34:04 <cmccann> either acid-state and its all-in-memory-at-once assumption
16:34:18 <cmccann> or Cabal and it's massive records types
16:35:14 <cmccann> which means either replacing the whole persistence model, or reimplementing only the necessary bits of Cabal
16:35:45 <luite> or using a non-micro instance
16:35:53 <bgamari_> cmccann: I have 500 packages names in my mirror
16:36:00 <dcoutts> cmccann: if we can get each PackageDescription down to say 10k in memory then we can hold the whole lot in memory in just 400Mb
16:36:01 <bgamari_> it's using 367M virtual
16:36:22 <bgamari_> cmccann: That's names, not versions I believe
16:36:24 <jgrimes> if I have several nested, hierarchical data types, would it be possible to make a zipper to traverse these?
16:36:24 <cmccann> luite, yes, it would run acceptably on a larger instance, but it shouldn't need to
16:36:25 <yezariae1y> I installed the newest ghc. However when I run cabal install dph-par, there are dependency conflicts with base. any suggestions here?
16:37:32 <dcoutts> cmccann: ah, mm, no it's worse due to GC.
16:37:55 <cmccann> dcoutts, worse in which way?
16:38:18 <dcoutts> cmccann: the standard GC means the heap is ~3x the live data
16:38:23 <cmccann> I'm assuming GC is why my micro instance is swapping a lot despite not being used for anything
16:38:27 <dcoutts> with compacting gc it's ~2x
16:38:29 <arkx> yezariae1y: dph-par has not been updated to work with the latest version of GHC.
16:38:34 <cmccann> ah
16:39:38 <dcoutts> cmccann: still, I expect we could get it down to 1Gb ish
16:39:54 <cmccann> I'd hope we could get it even lower than that
16:39:59 <dcoutts> but what for?
16:40:05 <yezariaely> arkx: so I hace to wait for the new package to be published
16:40:20 <dcoutts> cmccann: to target a lot less than that I think you would want to be looking at a passive archive
16:40:52 <arkx> yezariaely: see http://hackage.haskell.org/package/dph-examples
16:40:55 <cmccann> dcoutts, well, I'd hoped to make it easy for people to set up personal hackage mirrors using the same codebase
16:41:15 <cmccann> and that requires it to run decently on mid-range hardware without consuming lots of resources
16:41:17 <dcoutts> cmccann: with all the UI, or just a mirror to use with cabal-install?
16:41:45 <cmccann> with the basic UI ideally, but not builds or stuff that's obviously more expensive
16:42:11 <cmccann> there's also the simple fact that hackage isn't exactly getting smaller
16:42:18 <dcoutts> cmccann: doing it without the UI would be straightforward and could use minimal resources
16:42:46 <cmccann> and there are various features I'd like to try adding
16:42:55 <dcoutts> but for more interesting features, having the full package index available without complex caching seems like a good thing
16:43:05 <cmccann> and I'd rather not have to worry about it being close to the edge of acceptable performance
16:43:34 <cmccann> yeah
16:43:36 <dcoutts> cmccann: well not performance, you mean memory use
16:43:40 <alpounet> dcoutts, by the way, would you happen to know how is the package index generated?
16:43:48 <alpounet> i'd sort-of need to generate one
16:43:51 <dcoutts> perf is fine if there's enough memory
16:44:06 <cmccann> eh, I take performance to mean general resource requirements, but yeah
16:44:09 <dcoutts> alpounet: generated in what sense?
16:44:23 <dcoutts> cmccann: right, perf drops off a cliff if you have to swap
16:44:41 <dcoutts> alpounet: or what context are you referring to?
16:44:44 <alpounet> dcoutts, the format used
16:44:54 <alpounet> that kind of stuffs
16:44:56 <dcoutts> alpounet: the on disk 00-index.tar.gz format?
16:44:57 <alpounet> is it available somewhere?
16:45:10 <dcoutts> yes, it's described on the wiki and in the code
16:45:11 <alpounet> dcoutts, well, the one hackage has, ideally, which i guess is the same?
16:46:20 <cmccann> anyway, I need to head out for a bit, sorry for yet another round of complaining :P
16:46:37 <dcoutts> cmccann: no, I'm glad you're working on making the data compact
16:47:13 <cmccann> dcoutts, I'm just not sure where to go from here without ripping a lot deeper into things
16:47:23 <cmccann> to avoid more of Cabal's data types
16:47:50 <cmccann> or whatever else
16:48:26 <dcoutts> cmccann: do you know which ones are still a problem?
16:48:36 <dcoutts> like versions and version ranges?
16:48:38 <bgamari_> cmccann: Frankly, if I were to run a personal mirror, I'd probably only keep the last few version
16:49:00 <cmccann> dcoutts, I'm not sure how to measure that directly
16:49:19 <bgamari_> cmccann: But I agree that the current situation is a bit memory intensive
16:49:22 <cmccann> but my heap profiles show an even mixture of types/constructors so there's not any one thing completely dominating
16:49:22 <dcoutts> cmccann: might be useful to make a test prog that reads the whole 00-index.tar
16:49:59 <dcoutts> cmccann: so we can get a figure for average package mem use
16:50:12 <dcoutts> and a easier context to try changes
16:50:13 <cmccann> in fact I'm not sure that packages are the only issue at this point
16:50:17 <dcoutts> right
16:50:24 <dcoutts> another reason to separate
16:50:39 <cmccann> I've also got a lot of memory use that I think is the Data.Maps that hackage uses to store things
16:50:41 <dcoutts> cmccann: or yo try the -fminimal configuration with fewer features enabled
16:51:03 <dcoutts> bgamari_: there's a difference between keeping the package tarballs and keeping the metadata
16:51:12 <bgamari_> dcoutts: Certainly
16:52:24 <Veinor> hmm, i think i might try yesod
16:52:38 <cmccann> dcoutts, having already replaced Cabal's types with Text-based equivalents I'm thinking of trying to strip out more fields that aren't needed much by hackage
16:52:58 <dcoutts> cmccann: have you tried sharing?
16:53:17 <dcoutts> cmccann: e.g. there's a lot of repeated package names that could be shared
16:53:18 <cmccann> I also wonder if using something besides Data.Map might be more efficient
16:53:26 <dcoutts> that's also plausible
16:53:36 <cmccann> dcoutts, hm, a good point
16:53:45 <cmccann> not sure how the sharing would work with acid-state though
16:54:08 <cmccann> would it preserve that? or would I need to somehow munge the packages after loading to re-share?
16:54:15 <dcoutts> cmccann: it'd have to be done on loading
16:54:35 <cmccann> or do it explicitly by replacing fields with id values and persisting shared text separately, I guess
16:54:45 <dcoutts> that'd be a lot less convenient
16:54:48 <cmccann> yeah
16:55:01 <cmccann> hm
16:55:03 <dcoutts> I was thinking of simply doing an in-mem identity transform
16:55:08 <cmccann> yeah
16:55:25 <dcoutts> increaseSharing :: PackageIndex -> PackageDescription -> PackageDescription
16:55:26 <cmccann> though I'm less than thrilled at making it take even longer to start up fresh
16:55:39 <cmccann> I really wish acid-state could do on-demand loading somehow :T
16:55:52 <dcoutts> cmccann: I doubt it's really that slow if it doesn't swap
16:56:15 <cmccann> it's still pretty slow even on my desktop, without swapping
16:56:36 <dcoutts> the in-memory part would not be the slow bit
16:56:37 <cmccann> just not the ridiculous level I get on EC2
16:57:47 <cmccann> I'm also not entirely sure how to do the sharing transformation anyway, since I don't think acid-state lets you get directly at the data
16:58:43 <cmccann> and depending on aspects of its internal behavior seems dubious
16:59:36 <dcoutts> cmccann: we can think about it another time, but I think it's plausible
16:59:50 <cmccann> and to be honest I'm not really happy with acid-state in general
16:59:51 <dcoutts> it's easy for inserts/updates
17:00:04 <dcoutts> it's just load from checkpoint that needs something
17:00:49 <cmccann> but I guess if I can make some sharing work in the short term at least that gives me time to work on stuff that's less annoying
17:01:10 <cmccann> ugh, sorry for being so negative :T
17:01:14 <dcoutts> :-)
17:01:50 <cmccann> so, anyone have suggestions on a more space-efficient key-value lookup structure than Data.Map?
17:02:23 <cmccann> my first instinct would be some sort of trie with a large fanout
17:03:01 <alpounet> cmccann, i think tibbe wrote a blog post about that
17:03:06 <alpounet> (alternatives to Data.Map)
17:03:09 <nyingen> dcoutts: are you still maintainer of c2hs?
17:03:13 <cmccann> alpounet, hm, got a link?
17:03:19 <alpounet> hm
17:03:27 <dcoutts> nyingen: one of them, yes
17:03:46 <tibbe> cmccann: my hash-array mapped trie implementation
17:03:46 <nyingen> dcoutts: it doesn't seem to build on 7.4.1 due to lack of -XDatatypeContexts in Attributes.hs
17:03:57 <tibbe> cmccann: what kind of data are you storing?
17:03:58 <dcoutts> nyingen: ah ok, thanks
17:04:09 <cmccann> tibbe, hackage :P
17:04:13 <nyingen> dcoutts: it's obviously easy to put that in, but latest ghc seems to think that's deprecated
17:04:15 <dcoutts> tibbe: lots of packages, key is name and version
17:04:30 <cmccann> right now it has lots of Data.Map stuff full of users, packages, &c.
17:04:30 <nyingen> just fyi
17:04:34 <tibbe> dcoutts: naively I would think the actual packages would take most of the space :)
17:04:36 <dcoutts> nyingen: I'd fix it by dropping the use of data type contexts instead
17:04:41 <dcoutts> tibbe: they do
17:04:42 <tibbe> database? :)
17:05:17 <cmccann> tibbe, actually Data.Map nodes are a significant chunk of my heap profile
17:05:21 * hackagebot LambdaPrettyQuote 0.0.0.6 - Parser, pretty printer, quasiquoter, and Arbitrary helpers for the untyped lambda calculus.  http://hackage.haskell.org/package/LambdaPrettyQuote-0.0.0.6 (JonathanFischoff)
17:05:38 <tibbe> cmccann: so I would say my new HashMap implementation, except it's not out yet
17:05:49 <tibbe> cmccann: are you trying to store all of hackage in memory?
17:05:52 <edwardk> tibbe: thought you might like to know there was a guy on earlier who swapped from hashmap to unordered-containers and went from 45gigs of memory to 1.5, you made his day ;)
17:06:11 <glguy> tibbe: I think he is dealing with the fact that hackage2 wants to store all of hackage in memory
17:06:16 <cmccann> tibbe, it loads the entire package index and all metadata into memory, yes
17:06:28 <cmccann> i.e. the parsed contents of all the .cabal files
17:06:46 <cmccann> and while I still think that's slightly silly it has its benefits and I can't really change that easily
17:06:49 <tibbe> edwardk: sweet :)
17:07:07 <cmccann> I already removed most uses of String in favor of Text
17:07:08 <tibbe> edwardk: they hash map implementation is actually a better version of IntMap at the moment. We ought to port the improvements back to intmap
17:07:10 <cmccann> which helped a lot
17:07:20 <edwardk> tibbe: *nods*
17:07:32 <tibbe> edwardk: however,  I don't think it's that much smaller. It likely solved some laziness issues for him
17:07:37 <edwardk> yeah
17:07:44 <edwardk> it was
17:07:58 <tibbe> cmccann: is the index updated or is it read-only (I guess the former)\
17:07:58 <edwardk> is there already a hackage package for dealing with l-estimators?
17:08:15 <cmccann> tibbe, so what would you recommend for a space-efficient replacement for Data.Map, storing data that's mostly static?
17:08:30 <cmccann> well, it's updated whenever a package is uploaded, of course
17:08:32 <tibbe> cmccann: let me think
17:08:35 <dcoutts> tibbe: there are updates, but reads dominate
17:08:44 <cmccann> but yeah, mostly it's just sitting there being read
17:08:51 <edwardk> started building an admittedly rather inefficient version and wondered if it might be of general use
17:08:55 <tibbe> cmccann: and it has to be a persistent (immutable) data structure?
17:09:00 <cmccann> and I assume updates won't touch multiple nodes most of the time
17:09:10 <cmccann> tibbe, it has to be storable with acid-state I guess
17:09:23 <tibbe> yeah
17:09:33 <tibbe> :/
17:09:33 <cmccann> otherwise I don't care
17:09:41 <cmccann> it's probably not the approach I would have used to be honest
17:09:52 <dcoutts> cmccann: what would you do ooi?
17:09:57 <tibbe> me neither, but I guess it what we got
17:10:25 <tibbe> so the smallest map type I know of is my HAMT structure which is in the "hamt
17:10:34 <tibbe> " branch of my unordered-containers repo on github
17:11:01 <tibbe> now, you can specialize a Map by hand to work with your types, via copy-n-paste, but that's clearly non-optimal
17:11:23 <tibbe> do you need it solved now now now?
17:11:50 <cmccann> tibbe, well, when do you want hackage2 to be ready? :P
17:11:57 <cmccann> "a year ago" is a valid answer btw
17:11:59 <tibbe> cmccann: is the Bin nodes that dominate?
17:12:03 <cmccann> yes
17:12:11 <tibbe> let me check the source for those again
17:12:39 <glguy> if it is a balanced binary tree  I would expect as many bin nodes as tip nodes as data nodes, roughly
17:13:33 <wavewave> hi.
17:13:35 <tibbe> cmccann: so my current HashMap uses slightly more memory
17:13:51 <james_ubc> holy... i think i just wrote half a program while sleeping
17:13:51 <cmccann> glguy, yes, but Tip wouldn't use as much heap
17:14:00 <tibbe> cmccann: you're losing 4 words per element in Map due to the polymorphic fields use to hold the key/value
17:14:07 <cmccann> dcoutts, anyway, I'm not entirely sure what I'd do, I'd need to try a few proof-of-concept implementations
17:14:31 <tibbe> cmccann: you will need a wide fanning tree, but I don't know of one except my HAMT
17:15:00 <cmccann> tibbe, a wide fanout trie was my initial thought, but I'm far from an expert
17:15:14 <tibbe> cmccann: it's hard to do well
17:15:18 <Igloo> Aren't you only talking about a factor of 2 improvement or something? Is hackage really on such a knife edge that this matters?
17:15:33 * dcoutts doesn't think it is
17:15:50 <tibbe> here's something more worrying, will it be over the edge in one year?
17:15:59 <cmccann> tibbe, that's a lot of my concern
17:16:07 <tibbe> we don't want the memory usage to scale O(n) with the number of packages
17:16:17 <Igloo> Well, in that case you have a year to come up with something better, but in the mean time we can use hackage 2 with Data.Map
17:16:22 <tibbe> unless n is very small
17:16:28 <tibbe> sure
17:16:29 --- topic: set to '["Haskell Platform 2011.4: http://bit.ly/Clv5r ","GHC 7.2 and cabal-install: http://is.gd/LXRBhh (all archs not just mac)","Paste code/errors: http://hpaste.org/new/haskell ","GHC 7.4.1: http://is.gd/vkWMMa ","Haskell News: http://reddit.com/r/haskell ","The Haskell programming language http://haskell.org ","Logs: http://bit.ly/5mwtRQ ","admin/spam issues: #haskell-ops"]' by ChanServ
17:16:30 <tibbe> get it out there
17:16:36 <tibbe> then we can rip out acid-state
17:16:41 <cmccann> I also (personally) want it to run on lower-end servers than dcoutts expects it to use
17:16:55 <wavewave> alpounet : you are still here. ;-)
17:16:59 <dcoutts> tibbe: and what would you do btw?
17:17:08 <tibbe> dcoutts: use a database!
17:17:11 <dcoutts> gah
17:17:14 <alpounet> wavewave, yup
17:17:16 <tibbe> they had decades of tuning for this
17:17:23 <dcoutts> tibbe: but it's horrible
17:17:27 <wavewave> I am now in Korea.
17:17:39 <tibbe> dcoutts: mysql-simple by bryan is quite nice
17:17:42 <tibbe> and it works :)
17:17:46 <Igloo> cmccann: So is the simple solution actually causing problems for you now?
17:17:50 <tibbe> has anyone used acid-state at scale?
17:18:01 <tibbe> Igloo: that's what I asked :)
17:18:05 * Igloo has little idea how big hackage is, or how fast it's currently growing
17:18:09 <alpounet> wavewave, hah, well, if you want to talk a bit about your issues, i'm still around for an hour or so
17:18:15 <cmccann> Igloo, simple solution being what, I think I missed some context there
17:18:22 <dcoutts> Igloo: it's currently about 40k package versions
17:18:25 <alpounet> Igloo, currently, cmccann's instance takes like 2GB of memory
17:18:32 <Igloo> cmccann: Being use Data.Map
17:18:46 <cmccann> and it demands all 2GB up front, because acid-state loading everything
17:19:07 <cmccann> Igloo, if I can't find a suitable replacement then yeah, I'm not set on that
17:19:22 <tibbe> also note at GCs start to get bigger pause times at 3-4 GB heaps
17:19:23 <cmccann> I'm just looking for any other places where I can make incremental improvements
17:19:48 <wavewave> alpounet : continuing we talked last time, the simplest example of fficxx currently is provided by HFastJet and HFastJet-generate in my github
17:20:04 <Igloo> dcoutts: How many unique packages?
17:20:14 <tibbe> cmccann: are you using a 32-bit or 64-bit GHC?
17:20:33 <alpounet> wavewave, could you send me a link?
17:20:33 <cmccann> hm, not sure actually
17:20:35 <tibbe> cmccann: gotta get off the shuttle, back in 15 mins
17:20:40 <cmccann> 'k
17:20:40 <tibbe> cmccann: use a 32-bit one!
17:20:42 <alpounet> a lot happened on #haskell since we talked about this :P
17:20:46 <tibbe> cmccann: ghc --info
17:21:00 <tibbe> brb
17:21:09 <wavewave> alpounet: yeah.. I am like a man from the past.
17:21:34 <dcoutts> Igloo: oh, sorry, ~20k versions of ~4k packages
17:21:47 * cmccann goes to make a cup of tea
17:22:04 <Igloo> Hmm, OK
17:22:32 <wavewave> alpounet: http://www.github.com/wavewave/fficxx ,  http://www.github.com/wavewave/HFastJet , http://www.github.com/wavewave/HFastJet-generate
17:24:43 <glguy> cmccann: You could save a few bytes by assuming that all the package names start with an 'H' ;)
17:24:45 <wavewave> alpounet: in HFastJet-generate, in lib/Application/HFastJetGen/Data/FastJet.hs, c++ binding is defined in haskell data type.
17:25:54 <wavewave> alpounet: I am going to make a txt file for this c++ binding (almost like c++ header file) and parser for that to haskell datatype. then I will announce fficxx package
17:26:20 <alpounet> wavewave, that looks neat!
17:27:10 <alpounet> but having some kind of "tutorial" that would take the reader from a (simplistic) C++ library to having a binding to that library and then building a simple program that uses this binding, would be awesome!
17:27:42 <wavewave> alpounet: yes.. that's what I want to do!
17:28:02 <alpounet> great
17:28:16 <alpounet> if you need someone to proof-read it, do not hesitate to ping me
17:28:47 <wavewave> alpounet : by the way, real full example is in http://www.github.com/wavewave/HROOT-generate  see lib/HROOT/Generate/ROOT.hs  that's where ROOT C++ binding is defined.
17:29:02 <wavewave> alpounet : thanks!
17:30:22 * hackagebot atmos-dimensional-tf 0.1.1 - dimensional-tf wrapper on atmos package  http://hackage.haskell.org/package/atmos-dimensional-tf-0.1.1 (GregHorn)
17:31:55 <alpounet> no problem
17:35:24 * hackagebot atmos-dimensional 0.1.1 - dimensional wrapper on atmos package  http://hackage.haskell.org/package/atmos-dimensional-0.1.1 (GregHorn)
17:40:23 * hackagebot husk-scheme 3.5.3.2 - R5RS Scheme interpreter, compiler, and library.  http://hackage.haskell.org/package/husk-scheme-3.5.3.2 (JustinEthier)
17:40:56 <lispy> psh, r5rs? I thought everyone moved to arc
17:41:00 * lispy kids
17:41:27 <cmccann> lispy, wrong quantifier, you want "there exists a person who moved to arc"
17:41:42 <lebro> lmao
17:41:46 <tibbe> cmccann: back
17:42:20 <cmccann> tibbe, I appear to be using 32-bit GHC
17:42:43 <tibbe> cmccann: good
17:43:35 <tibbe> cmccann: if it wasn't clear from the discussion before, I don't think we have a great option to Map
17:44:02 <cmccann> tibbe, yes, and I gather you are in the process of writing one
17:44:31 <tibbe> cmccann: yes
17:44:56 <cmccann> and using Map isn't significant enough to justify anything too drastic
17:45:00 <cmccann> as far as hackage is concerned
17:45:23 * hackagebot bdelta 0.1.1.1 - Simple, fast binary diff/patch  http://hackage.haskell.org/package/bdelta-0.1.1.1 (JoeyAdams)
17:45:25 * hackagebot bytestring-delta 0.1.0.1 - Simple, fast binary diff/patch  http://hackage.haskell.org/package/bytestring-delta-0.1.0.1 (JoeyAdams)
17:45:43 <cmccann> so if there's no direct replacement(s) to help with the specific cases hackage needs then I guess I'll stick with Map for now
17:45:51 <dmwit> How come adding '--constraint "random-fu installed"' to my cabal install line doesn't prevent it from re-installing random-fu?
17:46:29 <tibbe> cmccann: sounds good
17:46:34 <hpc> dmwit: that might mean "add random-fu as a dependency"
17:46:35 <tibbe> long term I say switch to a real data store
17:46:44 <hpc> (disclaimer: i don't cabal)
17:47:53 <dcoutts> dmwit: that should work
17:48:11 <dcoutts> dmwit: any idea which solver?
17:48:35 <hpaste> dmwit pasted “cabal install --constraint” at http://hpaste.org/64145
17:48:40 <dmwit> dcoutts: How can I check?
17:48:49 <dmwit> cabal-install 0.11.2
17:49:27 <dcoutts> dmwit: you may have the modular solver there and I'm not sure if it respects those constraints yet
17:49:37 <dmwit> ah
17:49:55 <dcoutts> dmwit: I'm afraid I don't recall the exact dev version where we changed the default solver
17:49:57 <dmwit> Am I using an unstable version by accident? =P
17:50:16 <dcoutts> dunno about unstable, but yes an intermediate development version
17:50:20 * dmwit checks whether this is installed from a repository or from somewhere more stable
17:50:40 <dmwit> Do you recommend that I downgrade?
17:50:50 <dcoutts> dmwit: or upgrade :-)
17:50:55 <cmccann> tibbe, do you think would anything work as a Map replacement for particular key types? it looks like the vast majority of these are using pretty simple key types, mostly Text
17:50:56 <dmwit> Yes, I see 0.10 is the newest thing on Hackage.
17:50:59 <dcoutts> it follows an odd/even convention
17:51:11 <cmccann> and a few Int keys, which makes me wonder why those aren't using IntMap
17:51:17 <dmwit> Alright, I'll upgrade and see what the newest cabal can do. =)
17:51:28 <dcoutts> dmwit: wait a sec
17:51:40 <dcoutts> dmwit: can you paste the same command with -v ?
17:51:55 <dmwit> Sure.
17:52:12 <tibbe> cmccann: IntMap is actually a bit larger (but faster) than Map
17:52:44 <cmccann> there aren't many using Int keys anyway
17:52:53 <hpaste> dmwit annotated “cabal install --constraint” with “cabal install --constraint (annotation)” at http://hpaste.org/64145#a64146
17:52:55 <cmccann> lots of Text-like keys though
17:53:02 <tibbe> cmccann: the only way I know to use less memory (except for using a HAMT) is to create a specialized TextMap (or MyTypeMap) which unpacks the key. That requires cut-n-pasting lots of code.
17:53:13 <tibbe> cmccann: that time would be better spent porting hackage2 to a database.
17:53:24 <dcoutts> dmwit: yeah, looks like it's just ignored
17:53:42 <dmwit> Great, I'll upgrade and hope that it gives me an error message instead.
17:54:00 <cmccann> tibbe, pretty sure porting it to use a database would take longer :P
17:54:07 <cmccann> but neither is appealing in the short-term
17:54:13 <wavewave> does  new version of cabal have --hyperlink-source as default when --enable-documentation?
17:54:46 <tibbe> cmccann: at least the database route would be long term sustainable. For now I would stick with Map.
17:56:26 * cmccann still hates using standard databases for this kind of thing
17:56:55 <dmwit> dcoutts: By the way, you are stupendously helpful. Thanks.
17:56:59 <dmwit> dcoutts++
17:57:05 <dcoutts> :-)
17:57:07 * dcoutts -> bed
17:57:13 <cmccann> layers of cruft and workarounds and impedance mismatch that everyone tolerates because standard DBs have been (ab)used for these purposes so often they've been heavily optimized for efficient misuse >:[
17:57:50 <alpounet> cmccann, yeah, but you at least have to drop the in-memory storage
17:57:54 <mmcdermo> quit
17:57:55 <alpounet> that just won't work on the long-term
17:58:36 <cmccann> alpounet, it would work fine if it only needed memory comparable to the raw tarball :P
17:59:01 <dcoutts> alpounet: I think it'd work pretty well if we can get the constant factors under control
17:59:39 <alpounet> cmccann, dcoutts, well, it depends on how much you can think a package would take in memory
17:59:42 <cmccann> having <10MB of data in memory is perfectly reasonable I think
17:59:49 <alpounet> you think a package can*
18:00:01 <dcoutts> and in particular it doesn't need to grow linearly with new package versions
18:00:24 <alpounet> cmccann, yeah but 2GB, that's really huge
18:00:38 <dcoutts> alpounet: it's not that large really, it means 600Mb of live data
18:00:40 <cmccann> alpounet, I'm the last person you need to be telling that to :P
18:01:03 <alpounet> dcoutts, oh right, the GC
18:01:23 <lispy> cmccann: what is the total on-disk size?
18:01:51 <dcoutts> lispy: 7.2 Gb
18:01:54 <cmccann> lispy, the original archive from the real hackage is 3.7MB or so
18:01:58 <wavewave> interesting discussion.
18:02:08 <cmccann> (the index, that is)
18:02:35 <dmwit> dcoutts: Just in case you didn't go to bed yet, the new cabal-install seems not to be reinstalling random-fu in its plan. =)
18:02:45 <dcoutts> dmwit: ah good
18:02:56 * dcoutts really did mean to go to bed!
18:03:04 <dmwit> =)
18:03:10 <dmwit> I know that feel.
18:03:11 <cmccann> dcoutts, heh, sorry to keep distracting you :P
18:03:12 <tibbe> cmccann: database or no database. You need to store large amounts of data on disk in serialized form somehow. You could use something like LevelDB or some other NoSQL database if you prefer.
18:04:52 <cmccann> tibbe, yeah, I'd need to look at the options
18:05:34 <cmccann> actually I should probably step back and figure out just how difficult it would be to remove acid-state
18:05:58 <cmccann> I'm starting to suspect that I've overestimated the difficulty of doing so
18:05:58 * dmwit got what he asked for, but not what he wanted
18:06:05 * dmwit asks again, with a better question this time
18:07:14 <cmccann> tibbe, at any rate, thanks for your time and input :]
18:07:16 <wavewave> cmccann: would you remind me of what was the problem with acid-state? too slow loading time?
18:07:43 <tibbe> cmccann: no problem
18:07:55 <tibbe> cmccann: feel free to drop me an email if you run into more performance issues
18:07:58 <cmccann> wavewave, one problem is that it requires loading everything into memory up-front, which causes the loading time issue
18:08:23 <cmccann> tibbe, hackage2 performance issues have been all I've run into for the last week or whatever, haha
18:08:31 <cmccann> remember that it used to use String everywhere
18:08:50 <cmccann> you can imagine what THAT did to the memory use
18:11:40 <wavewave> cmccann: thanks
18:12:19 <cmccann> wavewave, I have other complaints about acid-state, but those aren't directly related to the performance issues
18:12:35 <cmccann> why, are you thinking of using it?
18:13:01 <cmccann> for the things it does handle well it seems very nice to use
18:13:23 <DanBurton> UGH...accidentally sent my announce to the haskell mailing list without a subject *FACEPALM*
18:13:24 <cmccann> I just don't think it's a good idea for large amounts of data, or multiple chunks of data with complex interrelations
18:13:40 <wavewave> cmccan: i am using it.. but now I am thinking to abandon it. In my case, i may move to PostgreSQL.
18:14:29 <cmccann> wavewave, well, if storing everything in one structure that you load into memory up-front is fine, then I wouldn't worry about it
18:14:44 <DanBurton> what do you guys think, should I resend with a proper subject, or just leave it?
18:15:24 <cmccann> DanBurton, think of some extra information to add, use that as an excuse to send a reply, fix the subject while you're at it :P
18:15:41 <wavewave> cmccann: found that I want to have some relational database feature now.
18:15:45 <dmwit> I wonder what the relationship between "rvar" and "random-fu" is.
18:15:47 <DanBurton> cmccann: lol :)
18:15:50 <hpc> even better, while reaching for that extra information, find the solution and just not send it :P
18:16:23 <cmccann> wavewave, oh, well if you want relational data support then yes, acid-state won't really help :]
18:16:46 <cmccann> I mean, you could implement a relational data structure and persist that, but that'd be pretty silly
18:17:28 <wavewave> cmccann: that's right. I found myself did it finally.
18:17:37 <alpounet> you'd still need to load it up all in memory though, right?
18:18:02 <cmccann> alpounet, yes, as far as I can tell acid-state is all-or-nothing for any single persisted value
18:18:19 <cmccann> and there are no ACID guarantees on operations involving multiple persisted values
18:18:26 <alpounet> only used it once, for a toy happstack project
18:18:33 <alpounet> but yeah that's how i remember it
18:19:05 <cmccann> I mean, to be fair there are lots of cases where just loading everything at once is completely reasonable
18:19:16 <cmccann> if you have a modest chunk of data that you want to persist
18:19:27 <alpounet> well
18:19:28 <cmccann> but once you get into any sort of bulk data storage it's just not going to scale well
18:19:43 <alpounet> if you have 5 millions records
18:19:48 <alpounet> that starts getting annoying
18:19:51 <cmccann> yes
18:20:25 <cmccann> really, anything where you have a collection of complex types that you add to on a regular basis is not going to work well
18:20:42 <cmccann> but if you have a mostly fixed chunk of data, that isn't going to grow, it'd be fine
18:22:55 <wavewave> problem for me is haskelldb does not look well maintained
18:30:28 <luxurymo_> hey all. new to haskell and wondering how i can write the proper type signature for this function: factors n = [x | x <- [1..(n^1/2)], not (x `mod` 3 ==0), not (x `mod` 2 ==0)]
18:30:51 <hpc> :t let factors n = [x | x <- [1..(n^1/2)], not (x `mod` 3 ==0), not (x `mod` 2 ==0)] in factors
18:30:52 <lambdabot> forall a. (Fractional a, Integral a) => a -> [a]
18:31:16 <wavewave> luxurymo_ : just    check with factors :: Double (or other absurd type) and see the error message.
18:31:22 <hpc> that's the signature, but no sane type will be an instance of both those type classes at once
18:31:52 <hpc> luxurymo_: define the function in a file without a type signature, then check it in ghci
18:32:11 <luxurymo_> oh right i forgot you could do that
18:32:11 <hpc> or ":t let definition in function name"
18:32:12 <luxurymo_> awesome
18:32:14 <wavewave> luxurymo_ : for me, this is the fastest way to find a signature if it's strange.
18:32:14 <luxurymo_> thank you
18:32:55 <DanBurton> :t (^)
18:32:56 <lambdabot> forall a b. (Num a, Integral b) => a -> b -> a
18:33:11 <wavewave> or what hpc suggests. my method is good when you don't use ghci.
18:33:21 <DanBurton> methinks n ^ 1 / 2 isn't doing what you think its doing
18:33:29 <DanBurton> > 3 ^ 1 / 2
18:33:29 <lambdabot>   1.5
18:33:32 <luxurymo_> haha probably not
18:33:42 <lispy> > 3 ^ 0.5
18:33:43 <lambdabot>   Ambiguous type variable `t' in the constraints:
18:33:43 <lambdabot>    `GHC.Real.Fractional t'
18:33:43 <lambdabot> ...
18:33:47 <lispy> > 3 **0.5
18:33:48 <lambdabot>   1.7320508075688772
18:33:49 <DanBurton> > 3 ** 0.5
18:33:49 <lambdabot>   1.7320508075688772
18:33:51 <hpc> :t (^^)
18:33:51 <lambdabot> forall a b. (Fractional a, Integral b) => a -> b -> a
18:33:58 <hpc> :t (**)
18:33:59 <lambdabot> forall a. (Floating a) => a -> a -> a
18:34:09 <DanBurton> hpc: the happy face combinator? (^^)
18:34:32 <hpc> i prefer the boobs combinator
18:34:35 <hpc> :t (.) (.)
18:34:36 <lambdabot> forall a b (f :: * -> *) (f1 :: * -> *). (Functor f, Functor f1) => f1 (a -> b) -> f1 (f a -> f b)
18:35:11 <luxurymo_> i want to get each number from 1 to (n to the power of one half)
18:35:41 <DanBurton> there are a couple ways to approach that problem
18:36:05 <DanBurton> > filter (\x -> x * x <= 100) [1..]
18:36:09 <lambdabot>   mueval-core: Time limit exceeded
18:36:09 <DanBurton> whoops
18:36:17 <DanBurton> > takeWhile (\x -> x * x <= 100) [1..]
18:36:18 <lambdabot>   [1,2,3,4,5,6,7,8,9,10]
18:36:49 <DanBurton> or you could write the integer square root algorithm
18:37:00 <DanBurton> or go through floating point to discover the square root
18:37:06 <luxurymo_> hmm
18:37:24 <DanBurton> > [1 .. floor (sqrt (fromIntegral 100))]
18:37:25 <lambdabot>   [1,2,3,4,5,6,7,8,9,10]
18:37:35 <luxurymo_> whats the \x syntax? im only familiar with the regular list comprehensions of [x | x <- [some list]]
18:37:52 <DanBurton> it's an "anonymous function"
18:38:27 <DanBurton> it's like defining a function, but not giving it a name. The function's input is "x", and its output is x * x <= 100
18:38:52 <DanBurton> then I give that function to takeWhile, and apply it to the infinite list [1..]
18:38:54 <cmccann> wavewave, sorry, had to run AFK suddenly
18:38:54 <shachaf> It's a more fundamental thing than the "f x" syntax (or list comprehensions).
18:39:15 <cmccann> but I'm not terribly familiar with the state of DB libraries in Haskell anyway :T
18:39:59 <luxurymo_> DanBurton, so the full thing means bind x to everything from the list where x * x is less than/equal to 100?
18:40:38 <shachaf> luxurymo_: No. This isn't a list comprehension.
18:40:55 <luxurymo_> oh
18:40:58 <DanBurton> luxurymo_: not exactly. The full thing means take from the left side of the list until you find a number x for which x * x <= 100 is false
18:41:08 <DanBurton> "the list" being [1..]
18:41:33 <DanBurton> > takeWhile even [2,4,6,7,8,10]
18:41:33 <lambdabot>   [2,4,6]
18:41:36 <luxurymo_> so this part: \x -> means?
18:41:44 <shachaf> "takeWhile PREDICATE (x:xs)" is "x : takeWhile PREDICATE xs" if (PREDICATE x) is True, otherwise it's []
18:41:46 <mauke> luxurymo_: "this is a function of x"
18:41:49 <luxurymo_> x is the input to the function?
18:41:49 <shachaf> luxurymo_: It's a function.
18:41:59 <mauke> luxurymo_: \PARAMETER -> BODY
18:42:07 <luxurymo_> its like some_function x = ?
18:42:10 <shachaf> luxurymo_: You might want to read an introduction to Haskell syntax. I understand that LYAH is popular.
18:42:13 <luxurymo_> just anonymous?
18:42:13 <DanBurton> luxurymo_: yes exactly
18:42:24 <mauke> luxurymo_: 'foo x = y' is just a weird way of writing 'foo = \x -> y'
18:42:25 <luxurymo_> shachaf, yeah im going through that now
18:42:41 <shachaf> luxurymo_: Yes. some_function x = ... is a short-hand, in a sense.
18:42:49 <DanBurton> I thought LYAH did anon functions before list comprehensions
18:43:00 <luxurymo_> dont believe so
18:43:01 <shachaf> mauke: Well, a weird way of writing foo = \x' -> case x' of x -> y :-)
18:43:28 * shachaf finds the phrase "anonymous function" kind of silly.
18:43:41 <DanBurton> nope I was wrong
18:43:52 <luxurymo_> im trying to learn to think functionally. i have a background in java and haskell is blowing my mind. im going through some problems on project euler and the first step for one of them is to figure out how to get a list of all prime numbers from 1 to n
18:43:59 <cmccann> shachaf, obviously those are functions that hang out on 4chan
18:44:02 <luxurymo_> how would you guys approach this functionally?
18:44:03 <DanBurton> shachaf: why? it makes perfect sense. The function is there but it has no name. It is anonymous.
18:44:18 <shachaf> DanBurton: But almost all functions are "anonymous"..
18:44:22 <shachaf> s/.$//
18:44:39 <shachaf> A term that comes from languages where the default/only mode of defining functions is with a name, I guess.
18:45:00 <shachaf> luxurymo_: Project Euler may not be the best approach to learning a programming language.
18:45:18 <shachaf> Although the first few problems are OK, sort of. It has a bit of a strange emphasis for that, even so.
18:45:40 <DanBurton> shachaf: you're refering to, e.g. the function (+ 3) which is "anonymous" though it doesn't fit the lambda syntax?
18:45:54 <cmccann> a lot of early project euler problems are good writing pretty-looking but inefficient solutions in very few lines of Haskell :P
18:46:13 <shachaf> DanBurton: Or the "f x" in "f x y".
18:46:21 <luxurymo_> ive done a ton of the problems in java
18:46:40 <luxurymo_> and as im going through LYAH im dabbling in some just to solidify the little bit of haskell ive learned
18:46:57 <DanBurton> makes sense I guess.
18:47:09 <shachaf> luxurymo_: There are probably hundreds of web pages on the Internet that discuss getting lists of prime numbers in Haskell.
18:47:26 <DanBurton> @hackage primes
18:47:26 <lambdabot> http://hackage.haskell.org/package/primes
18:47:29 <shachaf> They're probably better thought-out than any 30-second response anyone in IRC could give you, too.
18:47:45 <parcs`> what's the name of that package with the first 1000 fibonacci terms in a big list?
18:48:13 <DanBurton> parcs`: there's a package for that? o_O
18:48:24 <shachaf> (Well, except in this IRC channel, where people get the same questions so many times that they memorize theit preferred answers to them and compete with each other on who can type them out the quickest.)
18:48:46 * cmccann read that as "memoize their preferred answers"...
18:48:57 <shachaf> cmccann: That too.
18:49:55 <DanBurton> Memo.list Memo.char (answerQuestion :: String -> String)
18:50:08 <parcs`> DanBurton: yes. the sad part is that it's probably not a joke
18:50:59 <DanBurton> we should make a lambdabot extension, sort of like @quote or @where, that spits out a registered answer given a particular question string
18:51:41 <parcs`> http://hackage.haskell.org/package/gutenberg-fibonaccis
18:51:44 <nyingen> cmccann: I was about to ask in here about why DataTypeContexts is deprecated, but I decided to search google first, and landed on an answer you wrote on stackoverflow about this very question
18:51:58 <shachaf> DanBurton: Or we could just, you know, write out the answers on the wiki or something and provide links.
18:51:58 <cmccann> nyingen, haha
18:52:04 <shachaf> That way they don't have to fit in IRC lines.
18:52:04 <accel> What is a good paper on the theory (not actual implementation) of Haskell's type system?
18:52:08 <cmccann> nyingen, and that's a big part of the value of SO
18:52:16 <shachaf> DanBurton: See, like in nyingen's case.
18:52:19 <accel> What is a good paper on the theory (not actual implementation) of Haskell's type system? I.e. I'm looking for CLRS :: Boost = ??? :: GHC ?
18:52:21 <DanBurton> parcs`: wow...lol :)
18:52:30 <nyingen> cmccann: Indeed. I'm increasingly finding it a very useful resource for searching
18:52:35 <nyingen> though I don't have an account on it
18:52:37 <DanBurton> shachaf: I suppose that would be the simlest way
18:52:42 <cmccann> they have crazy google rank, so I often tried to answer for posterity as much as the direct questioner
18:52:51 <nyingen> a good policy
18:53:23 <DanBurton> yeah, SO gets top hits on a lot of stuff
18:53:48 <DanBurton> and for good reason
18:55:19 <DanBurton> accel: "on the theory of Haskell's type system"? what sort of theory are you looking for?
18:55:19 <cmccann> nyingen, on average I get maybe 4 or 5 upvotes a week for very old answers, I think
18:55:20 <dmwit> Hm, this algorithm that checks random guesses is getting better answers faster than the exhaustive search.
18:55:24 <dmwit> Maybe I shouldn't be surprised.
18:55:30 <cmccann> which I suspect is because of people finding stuff from google or the like
18:55:42 <nyingen> yeah, I wonder whether I should make an account just for voting
18:55:54 <shachaf> dmwit: But is it getting the *best* answer faster?
18:56:08 <dmwit> Oh, no.
18:56:17 <shachaf> We just don't know.
18:56:18 <dmwit> I expect it will take approximately 200x longer to get the best answer.
18:56:22 <accel> DanBurton: the type of theory that alows me to re-implement it from scratch
18:56:29 <DanBurton> dmwit: out of curiosity, what is your search space?
18:56:33 <dmwit> But who cares -- I wasn't going to run the exhaustive search to completion anyway. =P
18:56:35 <shachaf> dmwit: But it might never get it. :-)
18:56:49 <dmwit> DanBurton: The best combinations of ingredients to learn potions in Skyrim. =)
18:57:01 <dmwit> (A very important problem, you understand.)
18:57:09 <DanBurton> accel: are you looking for something deeper than the Haskell Report?
18:57:25 <shachaf> dmwit: Hah.
18:57:28 <DanBurton> dmwit: a noble cause. I expect a hackage repository ;)
18:57:37 <DanBurton> *package
18:57:46 <accel> DanBurton: I haven't read the 2010 report; the report I did read felt more like "this is Haskell" rather than "here's how you implement a haskell-like type system"
18:57:50 <nand`> dmwit: Just sample it with the appropriate perks ;)
18:57:50 <shachaf> Have you tried casting KENDALL on it?
18:58:07 * cmccann casts FROTZ
18:58:20 <dmwit> nand`: And how do you get the perks without making potions?? =)
18:58:28 <DanBurton> accel: well it isn't Haskell-specific, but I highly recommend Pierce's "Types and Programming Languages"
18:58:38 <shachaf> Hmm, KENDALL was from Zork Zero?
18:58:43 <nand`> dmwit: by gathering a bunch of the same ingredients and making them over and over again, you get the same amount of points for any potion you make :)
18:58:50 <shachaf> Oh, yes, How to Win at Double Fanucci.
18:59:04 <accel> DanBurton: hmm; I might even own it; let me check my vast bookshelf
18:59:08 <shachaf> Or, wait.
18:59:11 <dmwit> Anyway, I thought the perk only let you get the first two effects of each ingredient.
18:59:24 <shachaf> No, it's introduced in ZGI.
18:59:52 <shachaf> Three undertrumps after an opponent discards a Trebled Fromp, though.
18:59:57 * shachaf stops offtopicking.
18:59:58 <dmwit> Also, the wiki claims that not all potions give the same experience. So I don't trust you any more. =)
19:00:21 <shachaf> Oh, yes, this was sort of on-topic.
19:00:30 <accel> DanBurton: yep, I own it; pehraps I should start reading it
19:01:08 <cmccann> shachaf, I wrote a very minimal text adventure to demonstrate how to write an interactive console application in Haskell once, does that make it on-topic-ish?
19:01:09 <shachaf> dmwit: There was a game -- Zork: Grand Inquisitor -- in which there was a complicated set of constraints for what makes a "valid spell", where to make a spell you fed a blank piece of paper through different machines in different orders.
19:01:11 <dmwit> Oh, I see, the +1 effect can be stacked up to three times. Yeah, that would do it. But programming a solution is more fun. =)
19:01:27 <dmwit> shachaf: ho boy
19:01:35 <shachaf> dmwit: You could write a computer program to solve all the constraints and figure out how to make the spell.
19:01:57 <shachaf> ...Or you could cast "KENDALL: Make complicated things simple" at the instructions, and it would just give you the correct sequence.
19:02:03 <cmccann> haha
19:02:07 <dmwit> hahaha
19:02:08 <dmwit> awesome
19:02:14 <cmccann> that's very Zork
19:02:14 <shachaf> But it took several playthroughs before I realized that. :-)
19:02:23 <shachaf> cmccann: This was a graphical game, mind you.
19:02:25 <Cale> Here's my mace in Skyrim: http://cale.yi.org/share/Screenshot%20-%20Mace%20of%20Molag%20Bal.png -- I'm pretty sure it's not quite optimal.
19:02:36 <Cale> But it one-shots dragons anyway, so whatever.
19:02:49 <shachaf> And also half-Enchanter half-Zork, or something like that.
19:03:16 <shachaf> If anyone here played _The Neverhood_ and remembers the mouse-cheese puzzle -- you could just follow the mouse's nose to the cheese, instead of mapping the whole game out.
19:03:31 <Cale> My armour rating is somewhere in the 900's
19:03:35 <nand`> Cale: Did you make sure to wear a circlet underneat a falmer helmet when smithing/enchanting it?
19:03:42 <dmwit> Cale: Armor tops out at 576...
19:03:42 <nand`> I got my bow's damage to something like 1500 without arrows
19:03:53 <nand`> dmwit: hard cap is 85% reduction but the number goes higher
19:03:55 <nand`> has no effect though
19:04:01 <Cale> dmwit: Yeah, so it gets silly after a point.
19:04:02 * nand` thinks this might be off-topic
19:04:09 <DanBurton> @where haskell-blah
19:04:09 <lambdabot> I know nothing about haskell-blah.
19:04:15 <dmwit> yeah
19:04:49 <accel> I'm trying to build a DSL in haskell for describing weapon construction in skyrim. What cases should I handle?
19:04:50 <shachaf> cmccann is never in -blah, though.
19:04:55 <Cale> I guess it still helps if you get hit with an effect which would otherwise reduce your armour rating.
19:05:08 <Cale> But I'm not sure how often that ever happens.
19:05:08 <nand`> (for what it's worth, it's possible to one-shot Alduin on Master difficulty with an arrow (to the knee))
19:05:13 <dmwit> Cale: Huh, how do I get my inventory to look like that?
19:05:14 <cmccann> one active IRC channel is enough for me
19:05:21 <Cale> dmwit: SkyUI
19:05:21 <nand`> dmwit: It's a mod, SkyUI iirc
19:05:30 <rasfar> um, at some point Char supported multibyte and all my old code using "interact" etc. broke.  I used System.IO.Binary from MissingH to deal with it.
19:05:35 <Cale> It is the one most essential mod for Skyrim ever.
19:05:43 <rasfar> Now with a fresh compiled GHC installation, thought I'd ask if there's a better alternative?
19:05:56 <dmwit> Also: is there a mod that makes the game do sane things to your stolen items?
19:06:00 <Cale> A distant second I would say is the high detail map.
19:06:02 <Eduard_Munteanu> Cale: neat, I remember the UI was terribly complicated
19:06:09 <nand`> You get used to it
19:06:12 * Eduard_Munteanu only tried it on a friend's computer.
19:06:26 <sipa> Cale: what's not quite optimal about it?
19:06:26 <Cale> Eduard_Munteanu: It's not so much complicated as shitty and obviously designed for use with a joystick.
19:06:46 <Eduard_Munteanu> Yeah, you can't even point and click properly IIRC.
19:06:46 <nand`> Cale: High detail map? Do you mean the LOD modification so you can zoom into the world map more closely / see less clouds?
19:07:00 <rasfar> I mean, I know about some of the alternatives, but just wondering if there's anything wrong with continuing to use System.IO.Binary inthose situations.
19:07:12 <Cale> http://skyrim.nexusmods.com/downloads/file.php?id=4929
19:07:15 <nand`> Eduard_Munteanu: the worst part was the “Yes / No” dialogs, since these didn't have E/Tab bindings like everything else; so you *had* to click those. If it weren't for those it would be reasonably usable
19:07:27 <Cale> ^^ that thing (I use the non-paper one, with all the roads)
19:08:03 * rasfar (i'll assume it's quite fine, but that Data.Binary would be preferred)
19:08:21 <nand`> Cale: Neat. I stopped playing the game a month or two ago; that mod wasn't around by the time. It never ceases to impress what the TES community comes up with. Just a shame their toolset doesn't allow functional scripting!
19:08:25 <nand`> Or even Haskell integration
19:08:57 <Eduard_Munteanu> Nice way to get it back ontopic :P
19:08:59 <accel> is it turing complete?
19:09:00 <Cale> Eduard_Munteanu: Yeah, menus which had few enough options to be presented entirely on the screen at once would still be displayed with the selected item centred on the screen, which caused many of the items to be needlessly hidden (scrolled out of view) so you couldn't click on them.
19:09:24 <cmccann> Eduard_Munteanu, hey, it's better than more of my complaining about hackage
19:09:32 <nand`> accel: It should be. Eduard_Munteanu: I tried..
19:09:48 <Eduard_Munteanu> :)
19:11:10 <nand`> The most/least fun part about Skyrim was the aeons of color correction HLSL I had to write to make the game world not be so terribly green
19:12:02 <accel> what?
19:12:05 <accel> you rewrote the shaders?
19:12:14 <nand`> accel: Partially, yes.
19:12:25 <accel> what is this skyrim people talk about, is it ana ctual game, or a game engine, like Ogre3D, that people hack on?
19:12:28 <nand`> accel: DirectX wrapper layer with shader injection
19:12:42 <Eduard_Munteanu> I guess the green stuck on ever since FO3.
19:12:49 <nand`> accel: It's an actual game, using an engine created by Bethesda.. Creation I think it's called, which is itself based on Gamebryo code still iirc
19:13:00 <Eduard_Munteanu> Cryo?
19:13:14 <nand`> No, gamebryo (the Oblivion engine)
19:13:40 <accel> does skyrim require a net connection to install/play ?
19:13:40 <Eduard_Munteanu> Ah, hm, perhaps I misremember the name.
19:13:41 <Cale> nand`: You might also like: http://skyrim.nexusmods.com/downloads/file.php?id=7654
19:13:47 <nand`> accel: No
19:14:16 <nand`> Well, partially. I believe you require Steam to register it, but it can be bought, installed and played locally
19:14:20 <Eduard_Munteanu> accel: doesn't even have multiplay AFAIK
19:14:42 <Cale> accel: Do you know about Morrowind or Oblivion? It's the next part in that series.
19:14:49 <Cale> (The Elder Scrolls)
19:15:14 <accel> Cale: I stopped @ baldur's gate.
19:15:17 <nand`> Cale: I have reason to suspect that may include some of my code :)
19:15:24 * Eduard_Munteanu liked the TES series a lot.
19:15:44 <Cale> nand`: In that case, thankyou :)
19:16:01 <Eduard_Munteanu> Oh, we have a modder.
19:16:08 <Cale> accel: Maybe you'd remember Daggerfall?
19:16:24 <Cale> (that came out in 1996 :)
19:16:35 <nand`> The best elder scrolls game was Arena
19:16:40 * nand` ducks
19:16:50 <Eduard_Munteanu> nand`: can't you edit or at least customize the shaders a bit from the TES editor though?
19:17:07 <Eduard_Munteanu> Arena is actually freeware now.
19:17:11 <nand`> Eduard_Munteanu: Maybe you can now, but the Creation Set wasn't out by the time
19:18:26 <Cale> It makes me a little bit sad that it seems you can't get away with using text for speech in games anymore, but we're still not quite beyond having finite sources of in-game speech. Somehow repetitiveness is far less offensive in a textual form.
19:19:06 <nand`> Eduard_Munteanu: you can modify the ingame parameters using scripts though; what I did was disassembled and reverse engineered the original shader code in order to write my own version of it with better HDR, adaptation, bloom, color correction and so forth
19:19:15 <nand`> Since the parameters weren't flexible enough
19:19:18 <Cale> (Someone stole my sweet roll, and I am *pissed*.)
19:19:48 <nand`> Cale: I had a mod which reduced the activation distance for random NPC greetings to where you'd have to be running into them
19:19:49 <Eduard_Munteanu> Nice.
19:19:54 <nand`> Made the game much more bearable
19:19:55 <shachaf> Cale: Well, speech synthesis is also not really good enough yet.
19:20:02 * shachaf is fine with text for speech, though.
19:20:02 <Cale> shachaf: right
19:20:10 <Cale> shachaf: I would be too
19:20:12 <hughfdjackson> Cale: its because you can read at your speed
19:20:12 <accel> skyrim has speech synthesis? so the dialogue is not pre-recorded?
19:20:20 <Eduard_Munteanu> accel: it is pre-recorded
19:20:21 <accel> computer games have changed since I lst played
19:20:21 <nand`> shachaf: Works in games based on robots :)
19:20:23 <nand`> Make it happen
19:20:25 <hughfdjackson> how can you skim speech? :p
19:20:27 <dmwit> accel: No, it's all voice actors.
19:20:29 <nand`> accel: it doesn't
19:20:31 <Cale> hughfdjackson: yeah, and you can skip over bits of text you know that you don't care about
19:20:38 <hughfdjackson> ^^ quite
19:20:46 <shachaf> Cale: Unless the game introduces artificial delays. :-(
19:20:52 * cmccann would mind speech less if terrible voice acting wasn't the norm in most video games
19:20:53 <hughfdjackson> in evidence, i submit how irritating those unskipable text sequences are
19:20:56 <hughfdjackson> *shakes fist*
19:20:57 <Eduard_Munteanu> Dunno, I like my RPGs immersive.
19:20:57 <nand`> It doesn't, you can just keep clicking
19:21:11 <nand`> Except for “cutscenes”, which revolve around NPCs walking around and interacting
19:21:12 <shachaf> Which you then have to read over and over again because you keep dying and have to restore to set save points.
19:21:18 <Eduard_Munteanu> Cale: you can enable subtitles though
19:21:55 <nand`> shachaf: Fortunately Skyrim has quicksave. Whenever I get done playing one of those games my finger twitches to the F5 key every few seconds
19:22:29 <Cale> Eduard_Munteanu: I do. I often play with headphones at night and my Linux audio drivers decided to become shitty somewhat recently, capping my headphone volume at something ridiculously low.
19:22:49 <shachaf> Ugh, Linux audio drivers.
19:23:17 <Cale> I was completely fine with Linux audio when just plain ALSA was the norm.
19:23:39 <nand`> I just stream all of my audio to a PCM device
19:23:48 <Eduard_Munteanu> Cale: wine?
19:23:48 <Cale> I'm not sure the current problems can actually be blamed on the PulseAudio people, but somehow once distros started adopting PA, everything went downhill for me.
19:23:51 <nand`> Unfortunately applications which don't have their own mixers and so on simply breaks..
19:23:51 <Cale> Eduard_Munteanu: yeah
19:24:09 <shachaf> What a mess.
19:24:10 <Eduard_Munteanu> Cale: yeah, I always hear people complaining about pulseaudio support in wine, if that's your case
19:24:24 <Cale> Eduard_Munteanu: I'm not even running PA, everything is much worse if I do.
19:24:25 <Eduard_Munteanu> Though straight ALSA is still a viable option.
19:26:02 <Cale> Now in newer distros (I tried a few on a new blank hard drive) I have even more obnoxious problems, and I can't really reasonably update things.
19:26:41 <Cale> In particular, they all seem to do this super-obnoxious jack detection BS where they pin your speaker volume at zero as soon as you plug in a set of headphones.
19:27:29 <Cale> and I just get a single Master volume control and nothing else
19:27:43 <Eduard_Munteanu> Try something more minimal, like Arch, but dunno, if it's an ALSA issue then ... :/
19:27:45 <nand`> Cale: Using an external receiver/sound card helps here; the computer will just be configured to stream PCM to it
19:28:03 <Cale> nand`: I've considered buying a small mixer
19:28:06 <nand`> You could try using a source based distro and compiling without PulseAudio support or something
19:28:11 <Cale> But it's so dumb
19:28:26 <nand`> Cale: You can DIY one for very cheap
19:29:16 <rasfar> I love my small mixer...
19:29:26 <shachaf> nand`: You can just uninstall pulseaudio usually.
19:29:32 <Cale> It's just upsetting that my machine already contains the hardware to do this, but because the people maintaining these projects seem to think that everyone wants and expects their desktop computer to behave the same way as their iPod, it doesn't work.
19:29:39 <nand`> shachaf: Well it may be the case that some program brings it in as a dependency
19:29:42 <shachaf> s/sand`/Cale/
19:29:45 <Cale> shachaf: That no longer helps in the new distros
19:29:47 <shachaf> s/sa/na/
19:29:48 <Eduard_Munteanu> Or just don't install it, I don't think Wine will pick it up by default :/
19:29:58 <shachaf> Cale: How new do they need to be for that?
19:30:02 <Cale> shachaf: (but it does in the version of Ubuntu that I'm running)
19:30:21 <Cale> I'm running natty
19:30:22 <shachaf> Cale: I recently reïnstalled a new computer with a fresh OS.
19:30:38 <shachaf> I initially installed Ubuntu, but the new version of it is so horrible that I switched to Debian.
19:30:40 <Eduard_Munteanu> Well, Ubuntu pushes a lot of stuff like that.
19:30:50 <Cale> shachaf: I tried Debian and had lots of the same issues.
19:30:55 <nand`> I'm using debian squeeze so that's old enough to be largely unaffected by modern “trends”
19:30:56 <Cale> Which made me extremely sad.
19:31:01 <Cale> ah
19:31:07 * shachaf is running testing.
19:31:17 <shachaf> Yes, they messed a lot of things up too.
19:31:20 * shachaf doesn't get it.
19:31:21 <Cale> Gnome 3 is junk
19:31:26 <nand`> I use xmonad :)
19:31:26 <shachaf> Yes.
19:31:29 <nand`> I thought everybody in #haskell would
19:31:35 <Cale> I can't really stand tiling WMs
19:31:36 <Eduard_Munteanu> Yeah, sure :)
19:31:36 <shachaf> Was 2010 the year of Linux on the Desktop? And then 2010 ended?
19:31:40 <rasfar> Some don't care for tiling WMs
19:31:49 <nand`> shachaf: Every year is the year of the Linux desktop :)
19:32:14 <nand`> Cale: Compositing/floating window manager written in Haskell... make it happen!
19:32:34 <Cale> 2011 is the year of Linux UI designers' somehow being infected with the delusion that they're designing mainly for tablet PCs with touchscreen-only and no mouse.
19:32:39 <cmccann> nand`, waiting for the year of the Haskell desktop eh
19:32:44 <Eduard_Munteanu> Well, fluxbox or stuff like that is ok if you don't want tiling WMs.
19:32:48 <shachaf> Cale: No mouse and especially no keyboard.
19:32:53 <Cale> lol
19:32:54 <nand`> cmccann: I'm waiting for the Reduceron to take off
19:33:22 <Eduard_Munteanu> Now the problem is getting the distro off your back.
19:33:23 <rasfar> Eduard_Munteanu: yeah, there are decent options.  Would be great to have it in Haskell though.
19:33:24 <Cale> You'd think there would be enough people frustrated by this that the solutions would just happen.
19:33:32 <nand`> Cale: fortunately Linux is all about possibilities so you're not forced to use what the maintainers thought would be good for you, just netinstall and use your own favorites. It's not like Windows 8's Metro situation
19:33:40 <Cale> nand`: sure...
19:33:41 <Eduard_Munteanu> Wasn't there something that decorated xmonad windows?
19:33:45 <Eduard_Munteanu> Or do I misremember?
19:33:49 <nand`> Cale: only problem is the bugs you'll inevitably run into..
19:33:56 <Cale> nand`: Right.
19:34:06 <nand`> Again, xmonad. Easily fixed :)
19:34:09 <Cale> nand`: and dependencies on software that you don't like
19:34:20 <Eduard_Munteanu> Oh, well, I guess it's still tiling.
19:34:46 * cmccann really should give xmonad another try, couldn't get it to work last time for unknown reasons
19:34:51 <nand`> Eduard_Munteanu: Window decorations for a tiling wm... so it wastes extra space?
19:34:54 <Cale> If someone wrote an xmonad mode which did a perfect emulation of Metacity, I would use it ;)
19:35:13 <nand`> cmccann: Any symptoms?
19:35:16 <shachaf> Cale: You mean GNOME2 Metacity, surely. :-)
19:35:19 <Cale> yes
19:35:24 <Cale> Of course :)
19:35:26 <shachaf> I wish xmonad was better than it is.
19:35:29 * hackagebot hp2html 0.2 - A tool for converting GHC heap-profiles to HTML.  http://hackage.haskell.org/package/hp2html-0.2 (IavorDiatchki)
19:35:40 <Eduard_Munteanu> http://www.haskell.org/haskellwiki/Xmonad/Screenshots#Decorated_Layouts
19:35:53 <cmccann> nand`, don't remember, mostly trouble getting it to start up correctly and not have things break in weird ways
19:35:59 <cmccann> I didn't spend much time on it, I was mostly curious
19:36:11 <rasfar> my floating WM has all 1-pixel borders
19:36:27 <Eduard_Munteanu> cmccann: whatever you do, use xmobar, the alternative kinda sucked from what I remember.
19:36:29 <nand`> Eduard_Munteanu: oh, that's reasonable
19:36:33 <shachaf> I wish Ion3 was better than it is.
19:36:36 <shachaf> Was.
19:36:45 <nand`> I ran into a lot of problems with xmobar but I managed to fix them by now
19:36:45 <Eduard_Munteanu> I don't use decorations though.
19:36:56 <Cale> I used pwm for a little while on university machines.
19:36:57 <rasfar> (or maybe it's 2 px)
19:37:09 <Cale> and I used E16 for a rather long time
19:37:21 <cmccann> is there a good guide to getting xmonad set up and working?
19:37:40 <shachaf> cmccann: There's whatever's linked to from xmonad.org
19:37:42 <shachaf> And the wiki.
19:37:52 <nand`> cmccann: I used http://xmonad.org/tour.html
19:37:55 <shachaf> Enlightenment and Ion were the only interesting floating window managers I've seen, I think.
19:38:03 <shachaf> FSVO "floating", in Ion's case.
19:38:16 <shachaf> But it had a floating mode with features that no other floating WM that I know of has.
19:38:21 <nand`> There's also http://www.haskell.org/haskellwiki/Xmonad/Config_archive/John_Goerzen%27s_Configuration#disclaimer
19:38:36 <Cale> But I've gotten really addicted to my gnome 2 panel applets (most of which, of course, do not have reasonable equivalents in gnome 3), and running E16 and Gnome at the same time works, but is a little silly.
19:38:55 <Cale> (I'm not sure if it works in Gnome3 or not, haven't tried that...)
19:38:56 <shachaf> Cale: "Panel applets? Panel? What's that?"
19:38:59 <nand`> #xmonad tends to get back to you for what it's worth
19:39:09 <Eduard_Munteanu> Cale: you can run Gnome + xmonad, although I've never tried
19:39:36 <NihilistDandy> I used xmonad on OS X, for a bit
19:39:36 <lambdabot> NihilistDandy: You have 1 new message. '/msg lambdabot @messages' to read it.
19:39:44 <NihilistDandy> Wow, that's a first
19:39:58 <nand`> shachaf: Does it have Aero Shake? Everybody knows that's the most important feature for a floating window manager to have :rolleyes:
19:40:05 <Cale> shachaf: pwm was closely related to ion
19:40:20 <shachaf> Ion3 lets you make "floating virtual desktops" that contain windows inside.
19:40:26 <Cale> It was by the same author
19:40:30 <shachaf> And does tabbing in a reasonable way, if I remember correctly.
19:40:52 <Cale> but apparently before he got into the whole tiling thing
19:40:56 <shachaf> Oh.
19:41:20 <Cale> Actually, didn't tuomov hang out here long ago?
19:41:39 <shachaf> Well, the author has become bitter and given up on the whole "free software" thing and switched to Windows and mathematics.
19:41:41 <NihilistDandy> http://leib.be/sascha/the-nil-programming-language/
19:41:47 <NihilistDandy> The new paradigm
19:41:51 <shachaf> preflex: seen tuomov
19:41:51 <preflex>  tuomov was last seen on #ghc 3 years, 45 days, 3 hours, 40 minutes and 37 seconds ago, saying: not someone else's packaged crap
19:42:03 * shachaf can't really blame him, exactly.
19:42:04 <cmccann> excellent last words
19:42:12 <dncr> to abstract away from getLine and putLine, is there a monad where you can only (get) from one stack and only (put) to another?
19:42:27 <Cale> Yeah, he did.
19:42:31 <nyingen> ion3 was pretty cool. I used it exclusively until I found xmonad
19:42:47 <nand`> dncr: reader and writer?
19:42:58 <shachaf> dncr: Well, there are functions :: [a] -> [a]...
19:43:06 <shachaf> nand`: That's not really what Reader is.
19:43:16 <nand`> oh yeah, reader is for sharing constant input
19:43:21 <cmccann> dncr, how about something like http://hackage.haskell.org/packages/archive/Catana/0.2/doc/html/Control-Monad-Catana.html ?
19:43:23 <dncr> nand`: doesn't (ReaderT a (Writer a) ()) only deal with one.. ya
19:43:32 <Eduard_Munteanu> :t interact
19:43:33 <lambdabot> (String -> String) -> IO ()
19:43:50 <shachaf> interact is an example of the [a] -> [a] approach. :-)
19:43:55 <mauke> newtype a State
19:43:57 <Eduard_Munteanu> :t interact (unlines . f . lines)
19:43:58 <lambdabot>     No instance for (SimpleReflect.FromExpr [String])
19:43:58 <lambdabot>       arising from a use of `f' at <interactive>:1:20
19:43:58 <lambdabot>     Possible fix:
19:44:12 <Eduard_Munteanu> :t interact (unlines . ?f . lines)
19:44:12 <lambdabot> (?f::[String] -> [String]) => IO ()
19:44:16 <shachaf> You can write your own monad for it but I don't know of one that has exactly those primitives.
19:44:42 <nand`> mauke: That might be what I would use as well but it doesn't guarantee you're only popping from and only pushing to another stack
19:44:51 <dncr> well i guess i have to write the (>>=)
19:45:03 <cmccann> also, I wrote this to prove an irrelevant point: http://hpaste.org/56776
19:45:04 <shachaf> Hmm, you can make synonyms for ImplicitParams in GHC 7.4.
19:45:18 <Eduard_Munteanu> dncr: you could just wrap State and Writer
19:45:35 <cmccann> the hpaste there wraps interact in a monad that lets you read input and write output
19:45:49 <Eduard_Munteanu> Actually, wrap just State, Writer is already pretty much convenient.
19:46:07 <Cale> One thing I've thought would be cool to try would be a floating WM which gradually rearranged the unfocused windows such that at least a little bit of each one was showing. The background motion might be distracting though.
19:46:07 <mauke_> data S a = S{ input, output :: [a] }
19:46:14 <nand`> yeah writer on the list monoid most definitely covers one half
19:46:17 <cmccann> (said monad being essentially "Cont ([a] -> [a])" fwiw)
19:46:23 <Eduard_Munteanu> Of course, you could use transformer versions of that and stack them over IO if you need.
19:46:33 <dncr> mm
19:46:38 <shachaf> cmccann: Aren't they all?
19:46:42 <mauke_> newtype HerpDerp a = HD (State (S String)) deriving (Functor, Applicative, Monad)
19:47:02 <cmccann> shachaf, I mean more literally
19:47:19 <nand`> Cale: I can only imagine. Speaking of which, that gives me an idea -> a window manager which uses your eye movement (tracked via IR camera)
19:47:20 <shachaf> Well, sure.
19:47:42 <shachaf> A Newtype of Monad.
19:48:08 <mauke_> getline = HD $ do { S (x : xs) ys <- get; put (S xs ys); return x }
19:48:23 <mysticc> nand`: What will it do with that ..
19:48:33 <mauke_> putline y = HD $ do { S xs ys <- get; put (S xs (y : ys)) }
19:49:01 <dncr> this is "IO" in a purer sense
19:49:13 <Eduard_Munteanu> nand`: hm, that could be interesting. I know it's already been done for looking around in some flight simulators.
19:49:22 <nand`> mysticc: I was thinking along the lines of what Cale said but if you look at the unfocused windows it would spread them out so you can view them better; or you could look at the taskbar to show previews and so on. Depending on the accuracy it might be possible to navigate just by looking at something and pressing a button
19:49:27 <nand`> I don't know how advanced this field is yet
19:49:42 <nand`> Eduard_Munteanu: Isn't that just tracking head movement generally?
19:49:58 <nand`> As opposed to eyeball movement. I know the latter *has* been done in some car systems which detect whether or not you look at the road
19:50:03 <Eduard_Munteanu> Hm, not sure.
19:51:01 <Eduard_Munteanu> Yeah, I think it's head-tracking after all.
19:53:48 <rwbarton> I've wished for "keyboard focus follows vision" before.
19:54:39 <nand`> rwbarton: That would be great for tiling window managers. Using mod+j/k to navigate through a medium-sized stack of windows is sometimes awkward
19:54:49 <nand`> rwbarton: only problem is.. if you look away but want to keep typing
19:55:00 <shachaf> Right, that's the only problem.
19:55:01 <nand`> rwbarton: Maybe if you hold down mod and look at a window it follows focus
19:55:16 <rwbarton> right
19:55:25 <rwbarton> you need to deal with that case somehow, but it's not the common case
19:55:26 <shachaf> I've wished for a "do what I want" key on the keyboard.
19:55:29 * hackagebot Catana 0.3 - A monad for complex manipulation of a stream.  http://hackage.haskell.org/package/Catana-0.3 (DustinDeWeese)
19:55:37 <rasfar> Cale: I think you'd get used to the background motion fairly quick.
19:55:40 <shachaf> If someone only implemented that, it would render all the other keys obsolete.
19:55:55 <nand`> rasfar: The easiest option is just to go mad
19:55:58 <nand`> if that counts
19:56:13 <nand`> shachaf: Apple has been trying for a while
19:56:23 <nand`> Recent attempts have not been very successful
19:56:45 <rasfar> nand`: i've actually worked in the eye-tracking area!
19:56:48 <Eduard_Munteanu> Hm, there's stuff like this... http://code.google.com/p/linux-track/
19:57:15 <nand`> rasfar: How accurate are recent technologies (preferably something that could easily become consumer-affordable)?
19:57:30 <rasfar> it's been 4 years or more...
19:57:46 <nand`> head tracking would work to switch focus between monitors, at least
19:57:56 <nand`> But mod+e/w work just as well for this
19:58:05 <rasfar> back then, we could "count eyeballs" fairly quickly from signage in public areas (not that i advocate this sort of thing...)
19:58:13 <rasfar> s/quickly/reliably
19:58:40 <shachaf> Don't count until you see the whites of their eyes.
19:58:56 <rasfar> more or less! we used IR reflection off the cornea I think
19:59:14 <miggyx_> Hi guys, what's the most efficient way to join two Strings? Any way to avoid ++ ?
19:59:34 <nand`> miggyx_: Don't use strings, not directly
19:59:36 <Eduard_Munteanu> miggyx_: if you already have two strings, no
19:59:50 <shachaf> miggyx_: Well, if you have two lists and you want to append them together, there isn't anything more efficient you can do.
19:59:51 <dibblego> miggyx_: joining two strings x, y will always be proportional to the length of x
20:00:01 <shachaf> But you can build up the strings in a different way.
20:00:08 <shachaf> For example, what DList/ShowS does.
20:00:24 <Eduard_Munteanu> Or you could use Seq for efficient access to both ends.
20:00:40 <Eduard_Munteanu> Data.Sequence, that is.
20:00:43 <nand`> Sequences are strings on steroids
20:00:50 <nand`> ultimately it's about using the right type for the job
20:00:53 <shachaf> Seq gives you many other things than "efficient access to both ends".
20:00:54 <Eduard_Munteanu> (but again, that doesn't help if you already have two strings)
20:01:02 <Cale> miggyx_: One option is to use functions which add something to the beginning of their String parameter.
20:01:05 <miggyx_> cool, I'll take a look. The strings I'm using are pretty small, just I have to join them a lot
20:01:23 <shachaf> Seq is an alternative to spine-strict lists, which may not be what you want.
20:01:38 <shachaf> miggyx_: You might consider using something DList-like.
20:01:39 <Cale> miggyx_: Then (++) becomes (.), "" becomes id, and "foo" becomes ("foo"++)
20:01:53 <shachaf> Which is what Cale is just describing. :-)
20:02:09 <Cale> miggyx_: at the end, you apply the resulting function to the empty string
20:02:24 <monochrom> the way to avoid (++) is to use both (.) and (++). the world is an irony.
20:02:28 <Cale> ;)
20:02:29 <nand`> miggyx_: basically in Cale's suggestion you build the resulting string “in one go”
20:02:30 <shachaf> But keep in mind that DList isn't always an obvious win even when using it "as intended".
20:02:33 <nand`> so you only have to traverse once
20:02:38 <Cale> Well, f . g is computed in O(1) time
20:02:45 <Cale> while xs ++ ys takes O(length xs) time
20:02:58 <Cale> If xs is only ever small constants, you're fine
20:03:03 <monochrom> anyway, I am boggled by how much information you can generate in the utter lack of context
20:03:03 <nand`> miggyx_: If you just need to append to the end consider building the string backwards and using reverse on the result
20:03:06 <nand`> if that's an option
20:03:10 <shachaf> monochrom++
20:03:14 <Cale> monochrom: ;)
20:03:16 <shachaf> This channel does that too much.
20:03:43 <Cale> It's a standard trick that everyone should learn about at some point, so no harm in talking about it :)
20:03:53 <Cale> (even if it's not quite the right thing for his specific case)
20:04:10 <shachaf> Cale: Well, would it be better to write it up once and then provide a link to it? :-)
20:04:19 <miggyx_> every day I learn so much new stuff just trying to get to grips with Haskell
20:04:52 <Cale> shachaf: I'm sure someone has
20:05:04 <Cale> shachaf: But I'd have to find the link, and it's easier just to type this again
20:05:05 <nand`> might be something on the haskell wiki
20:05:06 <Cale> ;)
20:05:07 <monochrom> Cale's collected work is at http://bit.ly/5mwtRQ
20:05:08 <shachaf> But it's so short and so tempting to just type it...
20:05:19 <nand`> monochrom: hehe
20:05:20 <shachaf> monochrom++
20:05:22 <shachaf> Hah.
20:05:36 <cmccann> monochrom, pf, that content is barely 10% Cale by weight
20:05:36 <shachaf> That collection sadly has a lot of duplicates.
20:05:42 <nand`> grep Cale *
20:05:48 <Cale> My collected work is in the minds of the people I've talked to.
20:05:54 <nand`> and bring popcorn
20:06:09 <shachaf> Cale: Sadly, that collection also has a lot of duplicates.
20:06:17 <Cale> YAY DUPLICATES
20:06:20 <nand`> It seems to leak a lot of memory as well
20:06:23 <cmccann> solution: never talk to the same person twice
20:06:35 <nand`> cmccann: Or never say the same thing twice
20:06:49 <Cale> My goal is to copy pieces of my brain into other people's brains.
20:06:58 <nand`> Cale: Effectively making yourself immortal
20:07:08 <nand`> Assuming these people can adequately re-copy you
20:07:29 * shachaf will interpret Cale's statement physiologically.
20:07:32 <nand`> Cale: You'll become a psychological virus though; are you fine with that?
20:07:35 <Cale> Yeah, and of course, the bits of people whose brains my brain has copied along the way too.
20:07:42 * cmccann remarked at one point that he thinks Cale is a good role model that more people should imitate 
20:07:47 <cmccann> so I guess it's working
20:07:51 <shachaf> Cale: I thought it was Cales all the way down.
20:08:53 <Cale> cmccann: You probably think that because my notion that I'm a good role model that others should imitate got into your head somehow ;)
20:09:30 <shachaf> monochrom imitates Cale by staying in Toronto and not going to Hac Boston.
20:09:36 <Cale> trololol
20:09:44 <shachaf> I guess a lot of the people in Toronto do that.
20:10:11 <monochrom> you Bostonians should come to Toronto
20:10:17 * shachaf is not a Bostonian.
20:10:37 <cmccann> Cale, well, I was mostly advocating your style of patiently dumping unbounded quantities of helpful information on anybody convenient
20:10:47 <Cale> :)
20:10:53 <nand`> And then confusing them 5 seconds later
20:10:55 <nand`> > 1 2
20:10:56 <lambdabot>   1
20:10:57 <faded> Is it easy to use Haskell Libraries in Yesod or Haskell web frameworks in general?
20:11:09 <monochrom> yes
20:11:16 <nand`> faded: import <name of library here>?
20:11:17 <shachaf> cmccann: Don't you live in ~Boston?
20:11:22 * cmccann said something to the effect of suspecting that someone could be physically attempting to stab Cale and he would continue patiently telling them about Haskell
20:11:29 <cmccann> shachaf, no, still in michigan
20:11:30 <Cale> heh
20:11:43 <faded> oh just making sure, because everything else has a reputation of being kinda difficult
20:11:46 <faded> haha
20:11:49 <nand`> cmccann: How can you physically stab Cale when he lives in the minds of so many people?
20:12:00 <shachaf> cmccann: That's ~Boston from here.
20:12:02 <shachaf> Are you moving to Boston?
20:12:03 <nand`> faded: confusing, not difficult :)
20:12:14 <nand`> All comes down to a good introduction and the right mindset
20:12:18 <monochrom> stab all people in parallel. the skynet knows how to do this.
20:12:50 <cmccann> shachaf, interviewed for a job out there but it didn't work out, so no immediate plans
20:13:05 <shachaf> Oh.
20:13:16 <shachaf> In that case I guess you're moving to CA.
20:13:23 * shachaf isn't sure that there are any other places.
20:13:36 <Cale> There's always Portlandia
20:13:53 <cmccann> shachaf, based on living in michigan I see no evidence to the contrary
20:14:17 <cmccann> on the other hand I'm looking for work a little more urgently at the moment so maybe I'll end up moving, who knows
20:14:55 <nand`> cmccann: best be a job writing Haskell
20:15:10 <cmccann> nand`, if you know of any I'd be happy to hear about it :P
20:15:38 <nand`> Wouldn't it be great to get paid for dumping helpful information onto #haskell?
20:16:00 <bill```> lambdabot would be a 1%er
20:16:50 <shachaf> cmccann: According to dons, there are "plenty" of Haskell jobs.
20:17:27 <cmccann> shachaf, alas they tend to be occupied by people with better qualifications than myself :P
20:18:50 <shachaf> cmccann: There are qualifications other than "volume of crazy type system hacks"?
20:19:03 <cmccann> apparently!
20:19:21 <monochrom> there is one about "volume of crazy hackage uploads"
20:19:28 <shachaf> Oh, I suppose.
20:20:17 <nand`> I believe qualification quality is directly proportional to the average number of language extensions required to compile each file in your haskell collection
20:20:53 <cmccann> ok, what I'm getting from this is that the only qualified haskell programmer is edwardk ;]
20:20:53 <monochrom> is that why everyone is racing to use PolyKinds?
20:21:08 <companion_cube> {-# LANGUAGE QualifiedProgrammer #-}
20:21:26 <Cale> Everyone is racing to use PolyKinds because kind inference is broken now if you don't turn it on.
20:21:31 <Cale> ;)
20:21:35 <edwardk> cmccann: ?
20:21:36 <shachaf> cmccann: Doesn't one of the qualifications involve documenting your code or something?
20:21:45 <faded> Got any advice for someone who wants create a new Haskell library?
20:21:47 <shachaf> Cale: How?
20:22:18 <monochrom> help improve an existing library first
20:22:19 <edwardk> cale: sadly, without the syntax for them, i'm stuck not actually taking advantage of them until 7.6 or so =(
20:22:35 <edwardk> faded: write it, rewrite it, rewrite it again, ship it ;)
20:22:47 <edwardk> in between ask for help ;)
20:22:47 <Cale> shachaf: GHC defaults lots of things to * prematurely where it used to look at the whole module at least to work out the kinds of type parameters
20:23:08 <cmccann> edwardk, just commenting on "volume of hackage uploads" + "number of language extensions used" as qualifications for a haskell programmer :P
20:23:10 <shachaf> Cale: In violation of the Report?
20:23:13 <Cale> yes
20:23:14 <edwardk> ah
20:23:40 <edwardk> cmccann: clearly you need to put a high score table in your hackage version ;)
20:23:44 <Cale> Also, PolyKinds + ScopedTypeVariables -> panic
20:24:03 <Cale> which basically means that you now have to give a lot of explicit kind signatures
20:24:05 <cmccann> edwardk, I probably will, in the sense of showing interesting statistics
20:24:10 <monochrom> PolyKinds + ScopedTypeVariables -> accomplishment unlocked :)
20:24:22 <cmccann> at least assuming I ever stop being frustrated with acid-state and Cabal and start working on useful features
20:25:01 <lispy> cmccann: how is the database port going?
20:25:04 <monochrom> oh, you're working on hackage 2? that's crazier than crazy hackage uploads
20:25:08 <nand`> cmccann: being able to see a chart of which language extensions are most used might be humorous/interesting
20:25:28 <shachaf> That's true. Uploading Hackage itself is the ultimate Hackage upload.
20:25:32 <monochrom> like, you don't upload to hackage. you upload hackage itself :)
20:25:36 <cmccann> monochrom, I'm not sure how you've missed my complaining about it every couple days, but yes
20:25:43 <lispy> seeing which language extensions are most used would be good feedback for the Haskell' committee, help direct them
20:26:01 * mee imagines something like John Baez' Crackpot index
20:27:09 <cmccann> lispy, hahaha :P
20:27:18 <monochrom> I didn't notice because I have been away every couple days
20:27:29 <cmccann> lispy, I've actually been looking through some DB libraries and trying to figure out how hard it would be to switch over though
20:27:36 <shachaf> lispy: Yes, especially with all those package that use {-# LANGUAGE NoNPlusKPatterns #-}
20:27:40 <cmccann> monochrom, probably for the best
20:28:15 <lispy> cmccann: I have experience with Takusen
20:28:22 <lispy> cmccann: I'm even listed as a maintainer
20:28:27 <faded> Where should I begin if I want my library to be used with a specific web framework?
20:28:33 <lispy> cmccann: but it's harder to understand
20:28:41 <faded> like, this library can only be used with web frameworks
20:28:46 <faded> or yesod only
20:29:05 <monochrom> yesod has very good tutorials examples etc
20:29:07 <lispy> faded: start in what sense?
20:29:24 <nand`> lispy: those are the lines along which I was thinking as well (re: language extensions)
20:29:34 <monochrom> essentially, yesod has a real manual
20:29:50 <lispy> the yesod manual has gone to press at O'Reilly, IIRC
20:30:23 <faded> lispy: normally you just write a library and upload and its accessable to haskell
20:30:43 <nand`> faded: Try to collaborate with a more experienced haskell programmer if possible
20:30:44 <faded> ill go through that process, but i want the library i make to be exclusive to web frameworks
20:30:47 <nand`> avoid many design mistakes
20:31:14 <nand`> faded: It's generally a good idea to make your library as general as possible; no need to restrict it for the sake of restricting
20:31:30 <nand`> if it's impractical or serves no purpose outside web frameworks then that's that and nobody will use it outside those domains
20:31:34 <cmccann> lispy, the main thing is that I'd really rather not deal with lots of hassle to finagle a bunch of square haskell types into round db tables
20:31:58 <nand`> No need to artificially make it “exclusive” though
20:32:25 <cmccann> lispy, and there are a lot of pre-existing types inherited from Cabal so anything that relies on building types to fit the DB doesn't help me that much
20:32:25 <lispy> cmccann: I have a co-worker who really likes making schemas. I was talking to him today and he's kind of interested, but only if you're ready/willing to use a db
20:32:59 <cmccann> lispy, I'm willing to entertain the idea but I really don't want to disrupt the structure of the existing code too much
20:33:13 <lispy> cmccann: I'll pass that on
20:33:41 <lispy> cmccann: I think if we got him involved we'd end up with a nice database model
20:34:07 <cmccann> lispy, and while I like a nice database model I don't know if the types that already exist are going to fit neatly in
20:34:08 <lispy> nice types on the haskell side, nice relational model on the db side, and a module or two to translate as needed
20:34:51 <lispy> cmccann: Well, I think he would probably take the haskell types, figure out what they mean, and then express that from scratch in the db.  Then link them together.
20:35:46 <cmccann> lispy, hm
20:35:51 <cmccann> well I don't want to commit to anything
20:36:45 <lispy> No worries
20:36:57 <cmccann> also, replacing acid-state isn't necessarily my top priority, plus I might end up refactoring the types anyway which moots some of the concerns about disruption
20:37:32 <lispy> I think one of the worst things we can do is not address the scalability
20:37:50 <lispy> So, if by not replacing acid-state you are still able to address scalability, then it's probalby okay
20:38:57 <cmccann> lispy, well, there's no obvious reason that it should use so much memory
20:39:17 <cmccann> I'm thoroughly dissatisfied with acid-state at this point but if I can reduce the memory use it'll be tolerable for now
20:39:41 <nand`> ~50 GB isn't enough for you?
20:39:54 * lispy thinks it may be time to go read
20:40:07 * lispy received, "Conceptual Mathematics" today
20:40:15 <cmccann> lispy, basically it comes down to either breaking away from Cabal and its data types (parsed .cabal files full of metadata being the main memory hog here)
20:40:33 <cmccann> or breaking away from acid-state and using more scalable persistence for the bulky Cabal types
20:40:38 <cmccann> or, eventually, both
20:41:30 <lispy> So you want to get to the point that only the index is in memory ACID?
20:42:20 <cmccann> I want to either "make things compact enough to keep it all in memory comfortably" or "not keep everything in memory"
20:43:02 <cmccann> I don't particularly care which, except that I'd rather not have to rewrite large parts of hackage if I can avoid it
20:48:50 <nand`> cmccann: Personally I think not keeping everything in memory is the more reasonable option for a single machine, it's also more scalable. Otherwise you'll find yourself scrambling to compress more and more just to keep on using the former approach. Alternatively, if you want to go that way, it may be sane to scale the number of database servers instead and use internal routing to get the right one
20:49:14 <cmccann> nand`, yeah
20:49:25 <rasterfar> Echoing an earlier comment by faded: is there a proper starting point for toying with a Haskell language extension (via GHC)?  My searches aren't turning up much, I'm thinking I should just look at sources for existing extensions?
20:49:57 <cmccann> nand`, but given that the compressed tarball is only a few MB I'm thinking that inefficiency is the biggest issue here
20:50:07 <cmccann> there's really not that much data involved here
20:50:15 <cmccann> and it has a lot of redundancy
20:50:27 <rasterfar> Are such doings still under the moniker of Haskell' ?
20:50:40 <nand`> cmccann: keep a huffman tree in memory then and share it among all objects?
20:50:53 <nand`> It's mostly plaintext is it not
20:51:01 <shachaf> cmccann: Which compressed tarball? 00-index.tar.gz
20:51:01 <cmccann> yep, lots of text
20:51:15 <cmccann> shachaf, yes
20:51:42 <shachaf> rasterfar: Haskell' is about standardizing changes to the Haskell Report itself, not about GHC exeensions.
20:52:47 <rasterfar> ok. would you say using existing extensions' source and "reverse engineering" is the best starting point, or are you aware of any blog accounts of previous extension projects you mihgt point me to?
20:53:25 <rasterfar> (probably there's some really obvious wiki documentation I've overlooked...)
20:53:45 <rasterfar> I admit I only poked around for 5 minutes!
20:54:06 <Saizan> i don't think there's too much in common between the implementation of different extensions, except for handling the flags
20:54:18 <rasterfar> I suppose the technical process of integrating an extension is in a constant state of flux/
20:54:34 <Saizan> though you might look at a specific extension that's in the same area of yours
20:55:02 <rasterfar> alright, thanks!
20:55:32 * hackagebot network-socket-options 0.2 - Type-safe, portable alternative to getSocketOption/setSocketOption  http://hackage.haskell.org/package/network-socket-options-0.2 (JoeyAdams)
20:56:36 <rasterfar> are most extension developers also regular contributors to GHC?  If that were the case, it could be a rocky road for me, heh.
20:57:34 <Saizan> i know there are extensions made by "outsiders"
20:57:51 <rasterfar> so it's not formally impossible :)
20:58:22 <rasterfar> okay here goes....
20:58:37 <Saizan> i suspect it's mostly a problem of which part of the compiler you want to touch :)
20:59:00 <rasterfar> as little as possible i'm thinking lol
20:59:19 <rasterfar> oops, cafe is closing fast -- back in 10
21:04:45 <AfC> cmccann, nand`: not sure what you're talking about having just joined, but a rare visit to Slashdot today led me to an interesting article about off-the-beaten-track techniques for optimizing compression of a MASSIVE mailstore. http://mailinator.blogspot.com.au/2012/02/how-mailinator-compresses-email-by-90.html might be of interest.
21:05:27 <shachaf> It's not really all that massive.
21:06:12 <cmccann> yes, the problem at hand is more about eliminating anti-compression of modest amounts of data, rather than applying compression to immodest amounts of data
21:06:31 <shachaf> Well, Mailinator's store isn't all that massive, I meant.
21:06:39 <cmccann> ah
21:06:46 <cmccann> well, hackage even less so :P
21:06:48 <shachaf> They have the advantage that they can evict any email they want to.
21:06:53 <shachaf> Since it's all just temporary.
21:06:59 <shachaf> And it's all stored in RAM on one machine.
21:07:25 <shachaf> It sounds like "write a better Mailinator compression algorithm" would be a fun Netflix-style challenge, though.
21:08:23 <cmccann> yeah, it's an interesting (if somewhat unnecessary) problem
21:09:55 <nand`> “One minute might be a few million viagra spams, the next minute might be all about fake rolex watches.” <- at least they acknowledge their target demographic
21:10:31 <cmccann> people who receive a lot of spam?
21:10:45 <nand`> cmccann: aka e-mail in general
21:10:50 <cmccann> yes
21:10:54 <tikhonjelvis> That's the whole point--you get a temporary address from them and sign up for dubious services so your own doesn't get spammed.
21:10:55 <nand`> spam platform
21:11:08 <nand`> tikhonjelvis: Oh, okay. I did not know that :)
21:11:16 <cmccann> yeah
21:11:26 <cmccann> it's pretty clever, actually
21:11:35 <nand`> Yeah, I know the concept from spambox.us
21:11:36 <tikhonjelvis> Yeah, I've used it before and it's great.
21:11:49 <nand`> which redirects mail to your actual address for a set timeframe
21:11:50 <tikhonjelvis> And they constantly rotate their domains which is great too.
21:11:59 <nand`> spambox has a huge amount of domains as well
21:12:13 <tikhonjelvis> If they didn't, it would be too easy to block them.
21:14:05 <parcs`> uh oh: *** Exception: compiler/rename/RnPat.lhs:535:39-79: Irrefutable pattern failed for pattern gres@(gre : _)
21:15:48 <nand`> I wonder how they know they get a lot of newsletters, this implies they've at least looked at the mail contents for investigative purposes
21:15:57 <nand`> Or at the very minimum the addressess
21:16:04 <procyborg> hi
21:16:29 <rasfar> hi procyborg, ca va?
21:17:35 <parcs`> > let f@~x = () in ()
21:17:36 <lambdabot>   ()
21:18:25 <nand`> > map generalCategory "f@~x"
21:18:26 <lambdabot>   [LowercaseLetter,OtherPunctuation,MathSymbol,LowercaseLetter]
21:19:10 <quintessence> Interesting, you can derive Typeable for GADTs but now Show?
21:19:20 <parcs`> now?
21:20:10 <rwbarton> Typeable doesn't really care what the values of the type are at all
21:20:13 <companion_cube> this mailinator thing is pretty interesting
21:20:15 <mysticc> @hoogle when
21:20:15 <lambdabot> Control.Monad when :: Monad m => Bool -> m () -> m ()
21:20:15 <lambdabot> System.Posix.Terminal WhenDrained :: TerminalState
21:20:15 <lambdabot> Test.QuickCheck.Property whenFail :: Testable prop => IO () -> prop -> Property
21:20:17 <rwbarton> so that's not too surprising
21:22:28 <quintessence> oh, StandaloneDeriving works, so it's probably just that it doesn't try to figure out what superclass constraints it needs
21:27:11 <eyebloom> Is there a way to curry a function out of order?
21:27:32 <tikhonjelvis> (`fn` arg)
21:27:43 <tikhonjelvis> More generally, you can use flip.
21:27:56 <tikhonjelvis> :t flip
21:27:57 <eyebloom> What if it has multiple arguments
21:27:57 <lambdabot> forall (f :: * -> *) a b. (Functor f) => f (a -> b) -> a -> f b
21:28:04 <shachaf> eyebloom: I don't think "curry" is the word you want here. currying is a transformation of the form ((a,b) -> c) -> (a -> b -> c)
21:28:51 <shachaf> eyebloom: You can make combinators for applying any-positioned argument if you like, but it'll probably be clearer to just use a lambda.
21:29:00 <eyebloom> Hmm, (3+) is 3 curried into + is it not?
21:29:14 <eyebloom> :t (3+)
21:29:15 <lambdabot> forall t. (Num t) => t -> t
21:29:17 <glguy_> :t curry
21:29:18 <lambdabot> forall a b c. ((a, b) -> c) -> a -> b -> c
21:29:19 <shachaf> No. (+) is applied to the argument 3.
21:29:34 <shachaf> "curry" has a specific meaning which is distinct from "apply".
21:29:36 <dolio> (+) is already curried.
21:29:40 <glguy_> (3+) is partial application
21:29:49 <eyebloom> Is see.
21:29:53 <cmccann> :t curry
21:29:53 <lambdabot> forall a b c. ((a, b) -> c) -> a -> b -> c
21:29:54 <shachaf> Partial application, also known as application. :-)
21:30:36 <eyebloom> Then the right question is is there a way to partial apply out of order. (Sorry I come from python land.)
21:30:50 <shachaf> eyebloom: My answer above still applies.
21:31:01 <eyebloom> Such as instead of f x y z  : f _ _ z
21:31:13 <eyebloom> arbitrary colon.
21:31:34 <quintessence> :t flip
21:31:35 <lambdabot> forall (f :: * -> *) a b. (Functor f) => f (a -> b) -> a -> f b
21:31:37 <shachaf> (\x y -> f x y z)
21:31:47 <rasfar> eyebloom, this is amazing, you have hit the language extension I am contemplating exactly
21:32:07 <eyebloom> You know what they say about great minds.
21:32:07 <rasfar> underscores and all...
21:32:35 <cmccann> :t flip . fmap flip
21:32:36 <lambdabot> forall (f :: * -> *) a (f1 :: * -> *) b. (Functor f, Functor f1) => f (f1 (a -> b)) -> a -> f (f1 b)
21:32:37 <dolio> Vetoed.
21:32:39 <eyebloom> rasfar: seems like a no brainer.
21:32:40 <mzero> eyebloom:  if the function takes two arguments, say foo a b    and you want to apply the b (leaving a function that takes a)  then idiomatic Haskell is to write    (`foo` 7)
21:32:40 <rasfar> maybe we'll find out whether there's any need.
21:32:46 <cmccann> :t flip . fmap Prelude.flip
21:32:46 <lambdabot> forall (f :: * -> *) a a1 c. (Functor f) => f (a1 -> a -> c) -> a -> f (a1 -> c)
21:32:52 <cmccann> argh
21:32:52 <shachaf> I second dolio's veto.
21:32:56 <cmccann> :t flip <<< fmap Prelude.flip
21:32:57 <lambdabot> forall (f :: * -> *) a a1 c. (Functor f) => f (a1 -> a -> c) -> a -> f (a1 -> c)
21:33:06 <cmccann> :t Prelude.flip <<< fmap Prelude.flip
21:33:07 <lambdabot> forall a b a1 c. (a -> a1 -> b -> c) -> b -> a -> a1 -> c
21:33:13 <rasfar> it does.  flip and PL works, but it looks like hell.  and rather than have the programmer write boilerplate to permute argument order, the compiler can do it.
21:33:18 <cmccann> :t Prelude.flip <<< fmap Prelude.flip <<< fmap (fmap Prelude.flip)
21:33:18 <lambdabot> forall a b a1 a2 c. (a -> a1 -> a2 -> b -> c) -> b -> a -> a1 -> a2 -> c
21:33:54 * cmccann has a type-hackery generalized flip that does the kind of argument rotation as the above functions
21:34:03 <eyebloom> rasfar: the other extension I'm hoping for is optional warnings for non-explicit fix-point expressions.
21:34:06 <rasfar> i was just looking to see if such an extension already exists, but it appears not (so far)
21:34:06 <mzero> eyebloom: if you want more, it is idiomatic to use a lambda, which is generally easier than all this flipyness:   (\a b -> fixMyThirdArg a b 42)
21:34:07 <nand`> > filter (`elem` "aeiou") "Hello, world!"
21:34:08 <lambdabot>   "eoo"
21:34:35 <tikhonjelvis> flipyness is a good word
21:34:44 <mzero> :-)
21:34:46 <eyebloom> truthiness
21:34:47 * rasfar confesses more interest in the former than the latter...
21:35:37 <rasfar> flippyness is possible; I have been calling it "generalised sections" but I'm so naive that I've been afraid to mention it.
21:36:22 <rasfar> Started thinking/writing about it in 2002 ... but life intervened and my knowledge of Haskell and GHC has barely kept afloat.
21:36:52 <rasfar> just compiled GHC last night, thought it would be a good time to really attempt this!
21:36:58 <glguy_> Are there any libraries for showing simple math expressions (I just need Num) visually which preserve sharing?
21:37:04 <nand`> let apFst = id; apSnd = flip; alThd f c = \a b -> f a b c; ...
21:37:06 <glguy_> I don't mind having to use monadic operators or something
21:37:14 <nand`> foo `apThd` 42
21:38:05 <rasfar> While the topic is fresh, if anyone can think of objections to this on any grounds, please pipe up.
21:38:13 <eyebloom> rasfar: As syntactic sugar it would be a lot cleaner looking then a lambda a flip or even an explicit infix.
21:38:42 <dolio> Yes. I've used languages with it, and it leads to people writing unclear code.
21:38:47 <tikhonjelvis> Hmm, could you use type-level numbers and make it more general?
21:39:05 <dolio> map (foo (g _) x) (h _)
21:39:07 * rasfar attends to dolio carefully...
21:39:09 <quintessence> dolio: scala?
21:39:13 <glguy_> Unclear code? Yup, Haskell already supports that!
21:39:14 <dolio> quintessence: Yes.
21:39:31 <eyebloom> glguy_: :)
21:39:39 <rasfar> tikhonjelvis: if I understand correctly, the whole thing can be flattened in one pass...
21:39:51 <rasfar> that was my conclusion last night at least
21:39:51 <eyebloom> glguy_: so does every language.
21:40:06 <quintessence> I think the problem in scala is more that it's hard to see the scope of the (implicit) lambda
21:40:12 <rasfar> you'd need "preprocessor" for each call context
21:40:25 <rasfar> (autogenerated i mean)
21:40:38 <eyebloom> rasfar: message me if you start working on this.
21:40:44 <dolio> foo (g _) =?= foo $ g _
21:40:48 <rasfar> eyebloom: fair enough!
21:41:15 <rasfar> do I go "/msg eyebloom" ?  here goes
21:41:20 <glguy_> Factor supports that as a library
21:41:28 <quintessence> Something like (\-> f _ 10 _) would be a little less ambiguous
21:41:38 <nand`> rasfar: He quit the server so I doubt that would arrive
21:41:48 <rwbarton> Mathematica has this goofy Foo[a, #, c] & syntax
21:42:08 <rasfar> thanks nand`
21:43:01 <rwbarton> where & is like quintessence's \-> but in postfix form
21:43:18 <rasfar> of course it could lead to unreadable code; it would have to be used with discretion.
21:44:49 <dolio> Matter of fact, what does "map (foo (g _) x) (h _)" mean?
21:45:18 <rwbarton> it seems less a matter of unreadable code and more a matter of the syntax being ambiguous, at least on the face of it
21:45:51 <nand`> dolio: \a b -> map (foo (g a) x) (h b) maybe?
21:46:05 <mzero> gosh - I think the rarity of needing to partially apply a function to some argument than the first or second is such that it isn't worth complicating the language at all
21:46:10 <shachaf> nand`:  How do you figure out where to put the lambda?
21:46:17 <mzero> practically, this just doesn't come up in my code base that often
21:46:17 <nand`> shachaf: I didn't. I took a wild guess
21:46:23 <nand`> that's the problem
21:46:23 <shachaf> The obvious solution is to replace every _ with (\x->x).
21:46:37 <shachaf> {-# LANGUAGE CPP #-} #define _ (\x->x)
21:46:38 <dolio> nand`: I can tell you, that's not what the equivalent Scala code means.
21:46:52 <rwbarton> could you show the actual equivalent Scala code?
21:47:18 <dolio> h(_).map(foo(g(_))(x))
21:47:43 <glguy_> it burns us!
21:47:49 <dolio> Drink that in.
21:47:52 <nyingen> urk
21:47:57 <rasfar> dolio: that would make more sense with a map12
21:48:05 <rasfar> s/12/2 sorry
21:48:15 <mzero> wow - all this to avoid computer science's smallest lambda syntax? rlly?
21:48:29 <dolio> The foo(g(_)) is something you'd actually use in scala, too.
21:48:30 <rasfar> map2 (foo (g _) x) (h _) as bs
21:48:40 <dolio> because often times foo(g) would be illegal.
21:48:53 <dolio> So you're stuck with foo(g(_)) or foo(g _)
21:48:54 <rasfar> always in-order of course; out of order is my other extension...  (best to keep these separate)
21:49:12 <colah_> Is there any sort of Haskell meetup in Toronto? I've been searching for a while and didn't find anything. If there isn't something, I'm going to start one.
21:49:14 <quintessence> I think avoiding the names is the win and avoiding the lambda is the problem
21:49:34 <dolio> Anyhow it means: a => h(a).map(foo(b => g(b))(x))
21:49:42 <rasfar> i confess i don't see the need for lambda
21:50:14 <dolio> Or if you kept it as: map(foo(g(_))(x))(h(_)), it'd be: map(foo(a => g(a))(x)(b => h(b)), I believe.
21:50:16 <rwbarton> is that a => (h(a).map(foo(b => g(b))(x))) ?
21:50:34 <rasfar> i'm probably not quick enough to follow up all objections now, but i have a good feeling about this, it's withstood years of occasional scrutiny
21:50:40 <dolio> rwbarton: Yes.
21:50:52 <nand`> \ -> (or more generally, replacing any distinct instance of _ in the right hand side of a lambda by a new identifier which would be appended to the left hand side of the nearest lambda) might work to save you a few keystrokes;
21:50:59 <nand`> but then you run into situations such as nesting those
21:52:09 <dolio> rwbarton: x => e is a lambda expression in Scala.
21:52:39 <colah_> ... just checking in case I missed something, before I make a fool of myself by starting a group that doesn't exist :)
21:52:55 <colah_> er... for starting a group that already exists.
21:53:11 <nand`> (\a -> f _ 42 _ a) could be assumed equivalent to (\a b c -> f b 42 c a)
21:53:14 <rasfar> f a _ (g c _ e) _ w => f' a c e w
21:53:15 <colah_> I seem to be doing a good job of making a foo of myself as it is :P
21:53:26 <rasfar> the f' is generated based on the calling context
21:54:11 * rasfar i feel so naked coming out with this among so much more knowledgeable people; please be kind...
21:54:28 <quintessence> rasfar: is g supposed to be in that second version?
21:54:36 <rasfar> some function
21:54:46 <rasfar> it would have to appear in f'
21:55:46 <shachaf> colah_: There are a few people in Toronto in here.
21:55:54 <shachaf> You might ask them.
21:56:00 <rasfar> this basically would replace boilerplate which I've written on numerous occasions.  the boilerplate seems never to get me in trouble, and looks to be easy to automate.  but I am not a very profound Haskell coder, certainly, so problems may arise...
21:56:38 <rasfar> (too bad eyebloom left when they did, wierd)
21:56:52 <rasfar> oh your back!
21:56:56 <quintessence> having free variables that are applied (g) treated differently from ones that aren't (a c e w) seems strange
21:57:05 <rasfar> eyebloom: did you get me IRC message with my email?
21:57:43 <rasfar> s/your/you're ch!
21:58:14 <eyebloom> Sorry I did not. I'll be off to sleep soon. Try again.
21:58:38 <rasfar> eyebloom: i have no idea how to reach you.  sleep away, but let's exchange emails, please ping me with yours when you get this...
22:02:28 <rasfar> i'm off as well; not sleepy but homesick and no home internet...  always a pleasure folks!
22:03:24 <colah_> shachaf: I'll definitly be inviting everyone. I want to interact with other Haskellers in real life :)
22:04:51 <shachaf> colah_: Note that at least one of these people is apparently not a fan of interacting with other Haskellers in person.
22:04:59 <shachaf> But maybe he'll make an exception if they're in Toronto.
22:08:20 <colah_> shachaf: They're free to not come. It would just be nice for those of us who'd like to meet others. :)
22:09:08 <colah_> I've reserved March 7th at hacklab.to .
22:09:35 <nyingen> I wish I could meet some haskellers
22:09:58 <colah_> Are you in Toronto? I hear there's going to be a Haskell meetup... :P
22:10:11 <nyingen> heh, alas no. Though I visited toronto recently
22:11:21 <nyingen> closest major meetup to me would be hackphi, I think, but that's still 12 hours away
22:11:45 <shergill> curious, but while we're on the topic of meetups. any haskellers in montreal?
22:13:28 <nyingen> (crickets)
22:14:21 <mzero> of course, it is 1am in Montreal -- perhaps Montreal Haskellers are asleep
22:14:43 <geekosaur> that was my thought, except I'm in the same time zone.  (but I also have various sleep issues...)
22:15:04 <shergill> ditto, geekosaur
22:15:37 <nyingen> I am also in that time zone
22:16:29 <nyingen> Also, my wife and I honeymooned in montreal. We had a great time. If there were a haskell meetup there, I'd try to attend :)
22:18:30 <shergill> it definitely is a fun place, more so in summers :)
22:21:17 <NiceOneBrah> question: Part of why I want become skilled with Haskell is that I think it will make programming various projects easier and/or faster than if I were using other languages (Ruby, Python, Java, etc.). Can anyone share from personal experience the extent to which this is true or false?
22:23:48 <nyingen> NiceOneBrah: I used perl for 10 years. Now i write all that stuff in haskell instead, mostly due to massively improved maintainability and much less need to debug.
22:25:10 <cmccann> NiceOneBrah, I would say that Haskell offers the best compromise between ease of development, efficiency of the resulting program, and ability to reduce bugs
22:25:34 <nyingen> I agree with that, and I would add that Java is the worst language there is
22:25:43 <cmccann> if you just want raw ease of quick prototyping I think you'd do better elsewhere, but I wouldn't want to maintain those codebases
22:26:06 <cmccann> if you want absolute assurance of bug-free code, you need something that'll be a lot harder to get things done with in the short term
22:26:12 <nyingen> cmccann: I actually disagree with that. I find haskell fairly easy to "prototype" in, depending on what prototyping means to you
22:26:28 <mzero> I pro to in Haskell all the time
22:26:37 <mzero> proto!!!
22:26:38 <nyingen> the one thing I don't use haskell for is web apps, but I've never actually tried any of the haskell web frameworks
22:26:45 <cmccann> if you want maximal speed, you probably want to stick to something closer to the metal
22:27:07 <cmccann> but if you want a balance of everything I think Haskell is the best out there
22:27:17 <shachaf> mzero: we no ur a pro to, u dont need to tell us
22:27:47 <cmccann> nyingen, it is, but assuming equal skill with the language I think other languages would be faster, for suitable definitions of prototyping of course
22:27:49 <mzero> well, his other languages were Ruby, Python, Java -- so I don't think speed will be an issue
22:28:15 <nyingen> Java can be pretty fast, but that doesn't mean anyone should use it
22:28:48 <mzero> go for it, NiceOneBrah -- learn it, and comeback here, 'cause we've got your back
22:29:01 <shergill> nyingen: i think haskell beats java in the speed benchmarks?
22:29:05 <cmccann> yeah, as a rule of thumb I'd say that Haskell can give you comparable ease of initial development to something like Python, comparable speed to something like Java, and more maintainable code than both combined
22:29:22 <mrcarrot> i think NiceOneBrah did not talk about performance of the program, but rather how fast a program is made (the actual coding)
22:29:35 <nyingen> cmccann: The only major bump I've found with haskell speed-wise is the space leaks
22:29:39 <cmccann> shergill, that's probably comparing crazy optimized Haskell though
22:29:57 <nyingen> debugging my first space leak was very educational, but compelled me to learn iteratees and never touch lazy i/o again
22:30:25 <nyingen> I'm not sure whether iteratees are something that should be pushed on beginners, but they're very useful
22:30:36 <cmccann> assuming idiomatic Haskell that avoids some obvious performance issues you're still going to get decent performance, but probably not at the level of "dons spent a week fine-tuning this"
22:30:50 <DanBurton> conduits are supposed to be easier to use than iteratees
22:31:10 <cmccann> eh, lazy I/O in the sense of "unsafeInterleaveIO" is just a bad idea and shouldn't be exposed to beginners at all
22:31:12 <nyingen> yeah, iteratees seem to be something of a moving target
22:31:21 <mrcarrot> nyingen: i think that most tutorials are pushing recursion before foldl and foldr and that is why some beginners program eats a lot of memory
22:31:36 <mrcarrot> using an accumulator reduces the memory usage
22:31:45 <nyingen> yeah, true
22:31:55 <NiceOneBrah> interesting responses! thanks for the feedback, guys
22:31:57 <DanBurton> with a strict accumulation function, that is
22:31:58 <cmccann> frankly I think simple imperative-style monadic code using recursion is highly underrated as a way to handle I/O
22:32:07 <NiceOneBrah> yea I was referring to speed of development opposed to the spead of computation
22:32:24 <nyingen> NiceOneBrah: what kind of apps are you interested in?
22:32:39 <DanBurton> cmccann: agree. we're pretty quick to shoot down imperative style, but it's not always bad
22:32:49 <cmccann> NiceOneBrah, before learning Haskell my language of choice for fun tinkering and hobby projects was Python
22:32:56 <nand`> The key thing about haskell is the fact that it can become many things; if you want to quickly prototype some ugly code using lots of MVars and a big IO block then you can
22:33:04 <lpsmith> cmccann, of course it's underrated.   You have the big advantage of properly implemented tail calls
22:33:12 <lpsmith> Which is itself underrated
22:33:14 <cmccann> the fact that I don't use Python much anymore tells you something of course :]
22:33:15 * DanBurton started learning Haskell as a way to "be a better Python programmer"...hah.
22:33:27 <DanBurton> hooked
22:33:32 <NiceOneBrah> nyingen, well my friend is a structural engineer and one thing I want to build is a utility that will extract point loads from autocad .dwg files and perform some computations
22:33:46 <nyingen> NiceOneBrah: that's actually the kind of thing I do with haskell
22:33:50 <cmccann> but I think that in terms of "development speed" I'm marginally slower in Haskell than Python but that debugging the Python takes a LOT longer
22:34:04 <nand`> I started Haskell because I was getting sick of C#, wouldn't go back now if I got the best payment in the world for it
22:34:06 <shergill> NiceOneBrah: i still use python some, but have been moving more and more towards haskell. like cmccann said, it has one of the better compromises between the various tradeoffs. one thing that i do miss, and i might end up developing on my own time is having something like pymacs for haskell
22:34:08 <NiceOneBrah> I found a C library named libreDWG and was thinking about making a haskell wrapper around it and then adding more stuff in haskell
22:34:21 <mrcarrot> NiceOneBrah: as soon as it is a lot of calculations involved, haskell really shines bright
22:35:29 <nand`> mrcarrot: I wouldn't say it's *the* best tool, it really depends on the algorithm and whether or not you can easily design it in a functional style that can also be optimized
22:35:29 <cmccann> nand`, lucky you, I'm a C# developer and looking for a new job probably doing C# because I don't know of any jobs where I could use Haskell instead :P
22:35:53 <nand`> cmccann: when I do write C# I tend to use lots of lambdas and LinQ expressions :)
22:36:00 <NiceOneBrah> nyingen, do you have any experience with libraries or have any potential pitfalls to watch out for?
22:36:08 <nand`> C# manages to consistently come up with the ugliest way to represent types
22:36:16 <cmccann> nand`, yes
22:36:24 <DanBurton> cmccann: try a job in academia? :)
22:36:37 <mrcarrot> nand`: how about F# for you? i have never used F# or C#, but both runs on .net, so is it not possible to use both in the same project?
22:36:42 <nand`> Func<Func<int>,Func<Func<int>,Func<int>>> is the type of the curried (+) operator
22:36:43 <nyingen> NiceOneBrah: not with dwg specifically. But haskell has a pretty nice FFI (way of making C wrappers), so I think learning about it would be well worth it for your project
22:37:04 <cmccann> NiceOneBrah, writing bindings to C libraries is pretty straightforward
22:37:04 <nand`> mrcarrot: I haven't looked at F# much since I got mixed reviews; especially about integrating the two
22:37:11 <cmccann> there are lots of examples of those on hackage, too
22:37:14 <NiceOneBrah> nyingen, sweet. yea I noticed that RWH has a chapter devoted to it so that could be pretty cool
22:37:37 <cmccann> NiceOneBrah, connecting Haskell is C++ is much harder, but C is pretty easy
22:38:26 <companion_cube> is it hard to pass back haskell functions to C?
22:38:28 <NiceOneBrah> cmccann, interesting. I'll have to check out hackage and go through some examples
22:39:18 * cmccann was put off looking at F# because of a certain unprofessional and obnoxious F# enthusiast
22:39:39 <nand`> I've never really seen Haskell used as an integrated language for larger systems; is this domain simply underrepresented or is there a good reason it's uncommon?
22:39:46 <nyingen> cmccann: I think that guy put a lot of people off F#
22:39:49 <cmccann> which I admit isn't fair to the F# language itself, but oh well
22:40:31 <nand`> cmccann: Is this some common or well-known figure you are citing or was it #haskell-specific?
22:40:39 <nand`> s/citing/referencing/
22:40:51 <cmccann> nand`, I don't really feel like going into it
22:41:09 <cmccann> there's a lot of history there
22:41:11 <nand`> Then don't :)
22:41:19 <cmccann> most of which doesn't involve me and I'm happy to keep it that way
22:42:07 <shergill> wow he *really* must've been quite obnoxious
22:42:39 <nand`> Does F# has monads etc or is its type system not that powerful?
22:42:43 <nand`> have*
22:42:49 <cmccann> nand`, yes and yes
22:42:50 <levi`> It's got 'workflows'
22:42:56 <cmccann> it has built-in monad-ish syntax
22:43:07 <cmccann> but the type system isn't powerful enough to handle them otherwise
22:43:21 <cmccann> for the same reasons you can't do them in C# basically
22:43:30 <nand`> well, I know .NET has monads in general via LinQ, at least I think those are monads (.SelectMany is yet another representations of >>=/join etc. iirc)
22:43:48 <cmccann> no, these are explicitly monads with a do-block sort of thing
22:43:48 <nand`> and by “monads in general” I really mean “one monad”
22:43:49 <mandaya> huh, if they were going to introduce a monadic syntax, why not make the type system powerful enough to include them?
22:44:03 <mandaya> there are other abstractions of equal power you can access that way
22:44:07 <cmccann> rather than LINQ and its weird existential some-kind-of-monad thing
22:44:11 <mandaya> why arbitrarily restrict them?
22:44:20 <nand`> the IEnumerable<T> monad
22:44:50 <cmccann> mandaya, limited by interop with other .NET languages I suppose?
22:45:00 <edwardk> @hpaste
22:45:00 <lambdabot> Haskell pastebin: http://hpaste.org/
22:45:17 <hpaste> edwardk pasted “L-estimators” at http://hpaste.org/64153
22:45:23 <cmccann> and yeah, IEnumerable is more (exists m. Monad m) with only monomorphic return(s), or something like that
22:45:31 <edwardk> slowly coming together
22:47:36 <mandaya> cmccann: hmm, I guess that makes sense if the type system is somehow built into the .NET framework, but I always thought they were a compile time annotation...why would the run time care?
22:47:51 <nand`> edwardk: I made it to about line 50 until I realized I didn't understand a word past “LANGUAGE” :)
22:48:07 <cmccann> mandaya, reflection
22:48:08 <nand`> So take that as positive feedback -> fascinating
22:48:11 <edwardk> nand`: =P
22:48:16 <mandaya> cmccann: ahhh, right
22:48:36 <edwardk> nand: basically it sorts a bunch of numbers and then samples them at various points to compute statistics
22:49:26 <edwardk> L takes some number for how big the sample is and gives back and intmap of what coefficients should be multiplied by the value of the nth item
22:50:07 <edwardk> so median for instance, just takes n and tries to divide it in 2, and returns that it should sample the middle entry. (or average the middle 2 if there are an even number)
22:50:54 <nand`> edwardk: so you can combine sampling patterns before you actually get any data?
22:51:10 <edwardk> r1 - r10 are mostly noisy and irrelevant, after that its a bunch of things for computing different quantiles, trimming and adjusting the outliers of your input so you can make stats that are more robust
22:51:36 <edwardk> nand`: yeah, you can for instance use 'trimmed 0.20 mean' and it'll throw out the top and bottom 20%
22:51:44 <nand`> That's very neat
22:52:17 <edwardk> or 'winsorized 0.20 mean' and it'll replace the top and bottom 20% with the next smallest/largest
22:55:15 <edwardk> the various r{n}'s are for when you want to do something slightly smarter when computing quantiles than just rounding up/down. like linearly interpolating or interpolating when you (think you) know something about the distribution of the data being sampled
22:57:41 <edwardk> figured i'd use these as training wheels to get ready to do something fun with M-estimators using AD
23:35:40 * hackagebot hssourceinfo 0.0.2 - get haskell source code info  http://hackage.haskell.org/package/hssourceinfo-0.0.2 (YoshikuniJujo)
