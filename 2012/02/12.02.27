00:00:25 <zzo38> DanBurton: Maybe I will some time (but I do not intend to erase the other one). And I intend to use fmap/return/join instead of bind; to me >>= is just the convenient shortcut when you want to combine join with fmap
00:01:17 <DanBurton> shachaf: you should write a monad tutorial
00:01:28 <Sgeo> What about monad tutorials for other languages?
00:01:37 <Sgeo> cl-macro-monads iirc
00:01:46 <Sgeo> err
00:01:48 <Sgeo> cl-monad-macros
00:01:54 <Sgeo> Although I guess that's not a monad tutorial
00:03:36 <DanBurton> zzo38: Is there some additional structure you can assume about the [[DictionaryEntry]]?
00:04:35 <zzo38> DanBurton: Each word of input becomes the corresponding [DictionaryEntry] found in the map. And then it might need error handling and stuff too. Maybe I haven't explain well, but I can give examples too if wanted.
00:05:02 <DanBurton> well I actually need to go to sleep tonight
00:05:24 <DanBurton> I leave you at the mercy of my fellow Haskellers
00:07:25 <majuscule> How do I get a UTCTime from an IO UTCTime or vice versa?
00:08:35 <ChristianS> majuscule: utcTime <- getCurrentTime -- in the IO monad
00:08:44 <ChristianS> majuscule: vice versa: return utcTime
00:08:56 <zzo38> majuscule: You generally shouldn't do that. But you can get an IO UTCTime from an IO (IO UTCTime); this operation is called join. In general you want to map the values so you use >>= which combined fmap with join. To do a to IO a you use return
00:09:27 * shachaf sighs.
00:09:45 <shachaf> majuscule: A value of type UTCTime and a value of type IO UTCTime are completely different.
00:09:59 <majuscule> I'm confused :-( . getCurrentTime is returning an IO UTCTime
00:10:08 <shachaf> x :: IO UTCTime isn't a "wrapper" around a UTCTime, or something like that.
00:10:18 <shachaf> majuscule: It's not returning an IO UTCTime; it *is* an IO UTCTime.
00:10:26 <shachaf> @quote shachaf ls
00:10:26 <lambdabot> shachaf says: getLine :: IO String contains a String in the same way that /bin/ls contains a list of files
00:11:12 <shachaf> majuscule: This is answered in the FAQ.
00:11:14 <shachaf> Read the FAQ.
00:11:15 <zzo38> majuscule: That is becase, the value of type (IO UTCTime) is means the I/O action to access the current time. You can do map on it inside using fmap or <$> and if that is also IO you can join them together using join, and you can use >>= to do both ways together (the most common way).
00:11:16 <shachaf> @where faq
00:11:16 <lambdabot> http://www.haskell.org/haskellwiki/FAQ
00:11:55 <zzo38> majuscule: The functions in Haskell are all pure functions, so if you want I/O then you need the IO type to specify the action to perform
00:12:22 * shachaf thinks zzo38's explanations will only confuse anyone who doesn't already know what he means.
00:13:09 <zzo38> shachaf: Maybe, but I think my explanation will actually explain what it is rather than others which you cannot really understand a monad and stuff from, and think it is something that it isn't or vice versa, if you follow the other tutorials.
00:13:45 <shachaf> zzo38: Everyone says that about their own explanation.
00:13:53 <shachaf> I think majuscule would be best off reading the FAQ.
00:14:02 <zzo38> But, yes, exactly it is correct, it *is* an IO UTCTime.
00:14:18 <zzo38> But that won't help unless you know what an IO UTCTime is and what it means.
00:14:27 <majuscule> zzo38: I think I follow it in theory, i'm just having trouble when i try to put it into practice. i appreciate the explanation though
00:16:33 <majuscule> So I'm updating a variable that is a structure with a member variable type UTCTime. When it was an IO UTCTime, I assigned like so: `state <- state { a=b,c=d,time=(getCurrentTime) }`, which isn't converting it from an IO operation into a UTCTime.
00:17:13 <majuscule> i'm looking intofmap, <$> and >>=
00:17:26 <shachaf> majuscule: There are several things wrong with that line. I think you'll be best off going back to whatever introduction you were using and reading about Haskell syntax and types again.
00:17:45 <shachaf> majuscule: Here's a good rule of thumb: You should never have the same identifier on the left side and on the right side of a "<-".
00:17:48 <zzo38> majuscule: <$> is just the infix of fmap. join is the other operation. And >>= is just the combination of fmap and join (very useful in many cases).
00:18:01 <shachaf> So "x <- ... x ..." is pretty much always a bad idea.
00:18:11 <shachaf> They're not the same x.
00:19:23 <Enigmagic> :t mfix
00:19:24 <lambdabot> forall a (m :: * -> *). (MonadFix m) => (a -> m a) -> m a
00:19:25 <Enigmagic> :P
00:19:27 <Saizan> (that's a bit debatable, sometimes it's better to shadow than to add 's)
00:19:41 <shachaf> I foresaw both Enigmagic's and Saizan's responses.
00:19:52 <Enigmagic> :)
00:19:55 <Saizan> anyhow, state { ... } doesn't have the right type for being on the RHS of <-
00:19:55 <shachaf> And they are both completely irrelevant here.
00:20:28 <Saizan> shachaf: i think i'd write this like state <- return $ state {..} actually
00:20:32 <shachaf> Saizan: That is correct. As I said, there are several things wrong with that line, which is why majuscule should try something simpler first to understand what "do" and "<-" and "{}" mean.
00:20:35 <zzo38> majuscule: For example,   you have   print :: Show x => x -> IO ();   which takes a value and makes the IO action that send the display of that value to output. And then    getCurrentTime :: IO UTCTime;   which is IO action to access current time. So, you can map the values of the type inside (UTCTime):    (print <$> getCurrentTime) :: IO (IO ());    ........
00:20:41 <majuscule> ahhhrg, I wrote that off the top of my head. i'm really sorry :-(. It's actually `state < readState $ State {..}` . AHA. Well I was about to say I was confused about what readState does in that line to start with, but now I see readState actually does `State -> IO State`, which is very similar to what I need! What's bizarre to me is that all it does it `readState state = do return state`, which seems like it's not really doing anything at all
00:21:02 * shachaf wonders whether Saizan is just joking now.
00:21:05 <majuscule> Sorry i'm reading docs and trying things and typing all as fast as i can
00:21:13 <shachaf> majuscule: "return" does something very different from nothing.
00:21:15 <Saizan> shachaf: nope
00:21:26 <zzo38> ... so now, you can     join (print <$> getCurrentTime) :: IO ()   which you put the action the function result in, afterward, to combine it. You can use it together commonly, like this:    getCurrentTime >>= print     Try writing that in GHCi and see it can work.
00:21:41 <Saizan> majuscule: it's just givin back the state you're passing it
00:21:41 <shachaf> Saizan: You'd pass things through >>= in order to be able to shadow?
00:21:53 <Saizan> shachaf: yeah
00:22:41 <shachaf> Saizan: At any rate at this stage of learning I think any sort of shadowing will be unhelpful for majuscule.
00:23:43 <Saizan> majuscule: anyhow, to answer your actual question, you've to use <- to get a handle on the result of calling getCurrentTime before you can put it into the State record
00:23:45 <zzo38> majuscule: Can you understand it now, what I mean? Did you try the     getCurrentTime >>= print    example? You can figure out its type is   IO ()   and how it will be IO action, for example main can be of that type and it compile, but you can also enter IO action directly in GHCi to perform them.
00:24:09 <shachaf> Saizan: I would not use the word "calling" there. getCurrentTime is not a function.
00:24:16 <shachaf> But yes. :-)
00:24:28 <shachaf> But majuscule should probably understand what "IO" means.
00:24:33 <Saizan> majuscule: e.g. do t <- getCurrentTime; state <- readState $ State {a = b, c = d, time = t}
00:24:57 <Saizan> seeing some correct code in the meantime can't hurt :)
00:25:16 <shachaf> Saizan: That is true.
00:25:22 <zzo38> shachaf: Yes, exactly it should be understand what "IO" means.
00:25:23 * shachaf is just a grumpy old grump these days.
00:25:30 <shachaf> I should probably stay away from IRC.
00:25:49 <Saizan> no!
00:25:56 <Saizan> don't leave us!
00:26:59 <sajith> People, what's a good way to pass on an [Int] as 'Ptr CLong' via FFI?  (Is this a bad idea?)
00:27:23 <Saizan> anyhow calling is quite weird, i'm more likely to use it for getCurrentTime than for (+1)
00:27:44 <majuscule> zzo38: I definitely understand the IO type, I'm still trying stuff in ghci
00:28:04 <shachaf> sajith: Well, you'll need to turn it into a contiguous array in memory first.
00:28:10 <shachaf> sajith: There's probably a function for that.
00:28:22 <majuscule> Saizan: that works, thank you, but why can't I do `state <- readState $ State {a=b,c=d,time=(t<-getCurrentTime)}`?
00:28:33 <Saizan> there's Foreign.Marshal.Array
00:28:47 <shachaf> majuscule: Because that's completely not what "<-" does.
00:28:57 <zzo38> majuscule: You will need to ensure to load the correct modules. >>= and print are in Prelude, you need Control.Applicative for <$>, and you need Control.Monad for join.
00:28:59 <Saizan> majuscule: <- is not an operator, it's part of the do-block syntax, and it doesn't nest within expressions
00:29:34 <zzo38> You can ask for the type of anything in GHCi by using the :type command.
00:29:34 <shachaf> majuscule: As I suggested before, you should really spend some time learning how IO works.
00:29:37 <Eduard_Munteanu> @undo do {t <- getCurrentTime; state <- readState $ State {a = b, c = d, time = t}}
00:29:37 <lambdabot>  Parse error at "}" (column 77)
00:29:40 <shachaf> majuscule: Did you read the FAQ entries that I mentioned?
00:29:55 <Saizan> majuscule: learning how do-notation desugars to uses of (>>=) should clarify this, but some have proposed extensions to it that work almost like that too :)
00:30:01 <Eduard_Munteanu> @undo do { t <- getCurrentTime; state <- readState $ State {a = b, c = d, time = t} }
00:30:01 <lambdabot>  Parse error at "}" (column 79)
00:30:04 <ski> @undo do {t <- getCurrentTime; state <- readState $ State {a = b, c = d, time = t}; frob state}
00:30:04 <lambdabot> getCurrentTime >>= \ t -> readState $ State{a = b, c = d, time = t} >>= \ state -> frob state
00:30:18 <Eduard_Munteanu> Oh, right.
00:30:29 <Saizan> yeah, i forgot the ...
00:30:37 <majuscule> shachaf: i did read the faq, i'm still going over it, i'll be up all night :-)
00:30:50 <shachaf> majuscule: You'll want the bit labeled "Introduction to IO"
00:30:58 <shachaf> @google introduction to io in haskell
00:31:00 <lambdabot> http://www.haskell.org/haskellwiki/Introduction_to_IO
00:31:00 <lambdabot> Title: Introduction to IO - HaskellWiki
00:31:44 <ski> @wiki Introduction to IO
00:31:44 <lambdabot> http://www.haskell.org/haskellwiki/Introduction_to_IO
00:32:58 <mgsloan> Is there a canonical set of typeclasses for generalizing Set / Map / IntSet / IntMap / (->) ?
00:33:39 <mgsloan> Foldable / Traversable / etc help, but these are the things that I've found have been necessary: https://github.com/mgsloan/crdt/blob/master/src/Data/CRDT/Classes.hs
00:35:58 <Saizan> i don't think there's a widely used class for that, though there's edison that i know of
00:36:25 <Saizan> its API probably shows its time though
00:36:32 <Eduard_Munteanu> mgsloan: I find that odd considering a Map may or may not contain a value for a specific key, while a function "has" to be total
00:36:34 <sjoerd_visscher> some of those classes are in the keys package
00:37:31 <Eduard_Munteanu> Ah, Enumerable k and you only consider instaces of k -> Bool.
00:37:34 <mgsloan> Eduard_Munteanu: The Codomain of Map k v is "Maybe a"
00:37:52 <mgsloan> yeah, I looked at Keys.  I like mine better
00:38:17 <Saizan> representable-functors should also be relevant
00:38:26 <zzo38> In my own idea of programming language, I was thinking about changing name of return/join to eta/mu but you might want to use name of Greek letters for other purpose so probably I won't do that; but tell me if you dislike return/join and want other name; maybe unit/join? Or something else? And then something for comonads too? Any idea?
00:39:23 <frerich2> mgsloan: A nitpick which is not an answr to your question, but which came to my mind when reading your code: I think it would be nice if 'size' wouldn't use 'Int' but instead something more generic - some 'Num' type, maybe.
00:39:24 <ski> zzo38 : `extract',`scaffold',`preserve' for comonads
00:39:33 <Eduard_Munteanu> Or counit, cojoin etc.
00:40:16 <Eduard_Munteanu> zzo38: OTOH, you can let it decide which return/join that is based on the types involved.
00:40:20 <mgsloan> frerich2: Thanks for reading!  I did think about that.  I'm considering having it yield (forall a. Integral a => a) even
00:40:53 * ski suggests renaming `Either' to `CoProduct'
00:41:05 <Saizan> Co,
00:41:32 <ski> yeah, `(a,b)' should be renamed to `a * b' or `Product a b'
00:41:39 <zzo38> ski: In fact I was thinking of that too; I was thinking of renaming Either to Sum, though, and Maybe to Succ or Successor.
00:42:51 <t7> im reading a 'step-by-step guide' and the author is using this type: ErrorT String (ReaderT TIEnv (StateT TIState IO)) a
00:43:03 <t7> i got trolled hard
00:43:08 <ski> @unmtl ErrorT String (ReaderT TIEnv (StateT TIState IO)) a
00:43:08 <lambdabot> TIEnv -> TIState -> IO (Either String a, TIState)
00:44:30 <zzo38> ski: Yes, it could be (,) to Product, but then, having a macro so that you can use (,) for short, and the macro also for more (,,) and (,,,) and so on
00:45:02 <ski> zzo38 : why not `(*)',`(**)',`(***)',&c. ?
00:46:07 <zzo38> ski: Well, I can think of it. Even then it can be a macro which does such things.
00:46:33 <ski> (otherwise it will be hard to support both tuples of types, and tuple types)
00:47:12 <ski> (in general, we want records of types, as well)
00:47:52 <zzo38> Yes, OK
00:50:22 <mgsloan> no reason to not make homogeneous tuples a part of the whole index-able / update-able stuff
00:51:18 <mgsloan> ski - it seems like you'd definitely need some typeclass foolery in order to get (a ** b ** c) == (a, b, c)
00:53:10 <t7> ski, goto sleep
00:53:11 <ski> mgsloan : that, or make it special syntax (just like `(a , b , c)')
00:53:42 <ski> (which is how SML and O'Caml does it)
00:54:18 <zzo38> I was thinking, macros; this way it can even be redefined by writing other macros.
00:54:19 <mgsloan> yup
00:54:33 <cemycc> Hi, I want to write a function with n number of arguments ? How can I make this in Haskell and how can I use the arguments ?
00:54:58 <ski> cemycc : what number is `n' ?
00:55:06 <srhb> When I check :i Functor, I see among other things (GHC.Base.<$) :: Functor f => a -> f b -> f a. What is this? I've never seen <$
00:55:10 <zzo38> cemycc: By currying, for example:    f :: Int -> String -> String; f x y = .....   now you have 2 argument, x :: Int and y :: String
00:55:33 <ski> srhb : `a <$ fb = fmap (const a) fb'
00:55:41 <cemycc> ski: n is a unlimited number, so I can write as much arguments I want
00:55:51 <zzo38> srhb: <$ is just shortcut
00:55:58 <ski> cemycc : what would be the type of the function ?
00:56:00 <srhb> I see
00:56:45 <cemycc> ski: You mean what type of data will return ? Integer
00:57:05 <ski> cemycc : no, i mean its complete type
00:57:36 <ski> (a specific example might be good, to make this more concrete)
00:58:44 <zzo38> One of the things I was intending to do with my "extensible-data" package in Haskell, is to invent a roguelike game called "extensible-roguelike"; if you want to add more items, classes, kind of creatures, spells, rule variants, game interface macros, etc, then you just need to add a file and it will work.
00:59:05 <cemycc> ski: Can you point me to a link to get more info about function type ?
00:59:07 <zzo38> Tell me if you have opinion?
01:00:05 <ski> cemycc : consider e.g. `ord :: Char -> Int', `Char -> Int' here is the type of `ord', and is a function type
01:00:24 <ski> it says that `ord' is a function that accepts arguments of type `Char' as input and returns results of type `Int'
01:02:28 <cemycc> ski: I understood now, thanks
01:02:31 <ski> cemycc : now consider `take :: Int -> [a] -> [a]', the function type here says that `take' is a function accepting arguments of type `Int', and returning a result which is again a function : this function accepts an argument of type `[a]' (i.e. a list with elements of type `a'), and returns something of type `[a]' (a list of elements of type `a', for the same type `a')
01:03:08 <ski> in short, we say that `take' accepts two arguments, one `Int', and one `[a]', and returns a `[a]'
01:03:25 <ski> but note that we don't have to apply all the arguments
01:03:46 <majuscule> I'm trying to run a command on a condition. I'm using a control monad `when :: Monad m => Bool -> m ()`, and I've got the Bool, but I can't figure out how to pass it a function. createProcess returns an IO (Maybe Handle, Maybe Handle, Maybe Handle, ProcessHandle), which means that the following does NOT work : `when (diffUTCTime (time) (stLastPress state) > 0.8) ( createProcess (proc "amixer" ["set", "Master", "toggle"]) )`, but I'm struggling to think 
01:03:50 <ski> > take 2 [0,1,2,3,4]
01:03:51 <lambdabot>   [0,1]
01:03:53 <ski> > (take 2) [0,1,2,3,4]
01:03:54 <lambdabot>   [0,1]
01:04:08 <ski> > map (take 2) [[],[0],[1,2],[3,4,5],[6,7,8,9]]
01:04:09 <lambdabot>   [[],[0],[1,2],[3,4],[6,7]]
01:04:24 <ski> in reality, all functions in Haskell take exactly one argument
01:05:06 <ski> cemycc : now the problem is, if you want a function to, *curriedly*, take `n' arguments after another, what would the type of the function be ?
01:05:23 <ski> cemycc : also, when would the function know it has gotten its last argument ?
01:05:49 <ski> note that one might use the function like with `map' above, where not all arguments are given at the same time
01:06:26 <ski> cemycc : that said, there are some ways to hack this, in some cases at least
01:06:39 <ski> > printf "%s" "x" :: String
01:06:40 <lambdabot>   "x"
01:06:41 <ski> > let x = 3 in printf "%s = %d" "x" x :: String
01:06:42 <lambdabot>   "x = 3"
01:07:31 <sajith> shachaf, Saizan: Been staring at Foreign.Marshal.Array. Thanks for the hint!
01:07:52 <ski> > let xs = [3,4,5] in intercalate "; " (map (printf "%s = %d" "x") xs) :: String
01:07:53 <lambdabot>   "x = 3; x = 4; x = 5"
01:07:59 <ChristianS> majuscule: true starting with something simple that works (e.g. when True createProcess ... ) and work it out from there
01:08:19 <ChristianS> majuscule: also, you seem to use many unnecessary parentheses
01:08:29 <ski> cemycc : note that i have to explicitly say `:: String' here, to tell it when it should accept no more arguments
01:08:50 <cemycc> ski: I have understood now about function arguments, so for my function the first argument will be n ( the number of arguments ) and after the n arguments. It will accept Int and a list of ints right ?
01:09:15 <ChristianS> majuscule: sorry, actually when True (createProcess ...), there the parentheses are necessary
01:09:42 <ski> cmccann : well, if you pass a *list*, then you don't need the `Int' (the list contains its own size, so to speak) -- and passing a list is fine (assuming the elements have the same type)
01:10:02 <majuscule> ChristianS: that doesn't work either :-/ expected type '()'
01:11:11 <ski> cmccann : however, *if* you don't want to pass a *list*, but one argument after another, like in `foo 3 x0 x1 x2' (instead of `foo 3 [x0,x1,x2]' or better `foo [x0,x1,x2]') -- *then* you *need* dependent types to type this, and Haskell doesn't have that (Agda does, and Coq)
01:11:44 <ski> cmccann : you can see this if you try to write the type of such a function : you can't do this in Haskell
01:11:53 <ski> argh
01:11:58 <ski> cemycc : ^
01:12:26 <ddarius> You can produce something that will do at least something similar to that in Haskell.
01:12:47 <ski> cemycc : anyway, the trick that `printf' uses *can* be employed, but it's not clear whether it's really a win
01:12:59 * hackagebot HaskellLM 0.1.0 - Pure Haskell implementation of the Levenberg-Marquardt algorithm  http://hackage.haskell.org/package/HaskellLM-0.1.0 (KietLam)
01:13:03 <ski> ddarius : well, not with `Int', no ?
01:14:22 <ddarius> You could do the same kind of printf trick and turn it into a runtime error, or you could omit the Int.
01:14:37 <srhb> > fmap (+1) Nothing
01:14:38 <lambdabot>   Nothing
01:14:48 <srhb> Which rules are at work here? Is it the fail of Maybe?
01:14:59 <ski> no, it's `Functor'
01:15:04 <ski> @src Maybe fmap
01:15:04 <lambdabot> fmap _ Nothing       = Nothing
01:15:04 <lambdabot> fmap f (Just a)      = Just (f a)
01:15:05 <cemycc> ski: I have understood now, thanks for the help
01:15:14 <ski> @type printf
01:15:15 <lambdabot> forall r. (PrintfType r) => String -> r
01:15:22 <srhb> ah yes of course
01:15:31 <ski> cemycc : if you're interested, you may want to study how `printf' does it
01:16:08 <majuscule> what is a '()'
01:16:15 <ddarius> @src ()
01:16:15 <lambdabot> data () = ()
01:16:18 <ChristianS> majuscule: ok, then the error is in your createProcess. try  when True (print "Cool")
01:16:20 <ski> majuscule : empty tuple
01:16:31 <ddarius> :t when
01:16:32 <lambdabot> forall (m :: * -> *). (Monad m) => Bool -> m () -> m ()
01:17:14 <ski> majuscule : often used with monadic actions, when you're not interested in the monadic result, but just in the effects of the action
01:17:39 <shachaf> ddarius: By the way, is putting punctuation inside of quotation marks a new habit for you?
01:17:47 <ski> majuscule : if you know any of C,C++,Java,C#, it corresponds more or less to `void' there
01:18:19 * ski idly wonders why it's not `when :: Monad m => Bool -> m a -> m ()'
01:18:42 <ddarius> shachaf: No.
01:19:34 <BMeph> ski: It's simple to make such a when from the current one. Going the other way, not so much. :)
01:20:42 <majuscule> Ahrg, everything you guys are saying makes sense but it's just not all clicking together. I can run a `print "test"`, but I can't use any function i try to run command. I see print is an IO ()
01:21:08 <shachaf> ddarius: I saw an old post of yours that didn't do it. But I suppose that might have been an anomaly.
01:21:52 <shachaf> Anomalice can be irritating.
01:23:01 <ChristianS> @type System.Process.createProcess
01:23:02 <lambdabot> System.Process.Internals.CreateProcess -> IO (Maybe GHC.IO.Handle.Types.Handle, Maybe GHC.IO.Handle.Types.Handle, Maybe GHC.IO.Handle.Types.Handle, System.Process.Internals.ProcessHandle)
01:23:23 <majuscule> I got it working with `( do s <- runCommand "amixer set Master toggle"; return () )` but that feels wrong?
01:23:23 <ChristianS> majuscule: you sure you want to throw the newly created process away?
01:23:32 <majuscule> ChristianS: yes
01:23:47 <majuscule> runCommand might be better?
01:24:02 <ski> @type let otherWhen  = (. liftM (const ())) . when in let when = (. liftM (const undefined)) . otherWhen in when  -- BMeph
01:24:03 <lambdabot> forall (m :: * -> *) a1. (Monad m) => Bool -> m a1 -> m ()
01:25:57 * BMeph finds "const undefined" suspect and dubious.
01:26:18 <shachaf> It's seq that one should be suspicious of.
01:26:21 <ski> well `when :: Monad m => Bool -> m a -> m ()' should have no business looking at the `a' there
01:26:26 <ChristianS> majuscule: no idea, but you should be able to invoke createProcess in the same whay you invoked runCommand
01:26:53 <shachaf> ski: BMeph may have meant that const undefined ~= undefined, other than seq.
01:27:27 <ddarius> BMeph: Given the other one, if you want the current one, you just provide a type signature.
01:27:27 <ski> shachaf : yeah, i suppose you can simplify it in that way
01:28:46 <ChristianS> majuscule: actually, i think you could just drop the "s <- " if you don't want to use it anyway
01:29:00 <BMeph> It's not exactly what I mean, but I think it's an "alternative" means of saying what I meant. I think 'seq' has a logic "smell" as well, to mix metaphors.
01:29:17 * ski actually thinks `mapM_ :: Monad m => (a -> m ()) -> ([a] -> m ())' might be more sensible
01:29:41 <ski> (used together with `ignore :: Functor f => f a -> f ()', when appropriate)
01:30:51 <ski> (BMeph : either way, it seems simple to go in the other way)
01:35:41 <t7> did anyone read that thing on reddit about visual functional programming
01:35:44 <t7> looks cool
01:36:29 <Phlogistique> what thing
01:36:33 <ddarius> Java defaults class members to public if a accessibility modifier isn't provided?
01:36:38 <imc> t7: link?
01:36:52 <imc> ddarius: not the last time i've checked..
01:36:55 * ski thought it defaulted to package visibility
01:41:24 <dobblego> ddarius: no, it depends a lot
01:42:26 <Eduard_Munteanu> I wonder if LabVIEW counts as visual functional programming.
01:42:29 <dobblego> there is no "default"
01:43:09 <ski> dobblego : does it depend on the accessibility of the surrounding construct, or what ?
01:43:34 <dobblego> yes, the enclosing class often specifies the access modifier, but not in all cases
01:47:33 <t7> I wish there was a haskell without this restrictive type system. Im fed up of having to fiddle with my code before it will even compile! We need the power of dynamic duck types
01:49:04 <ddarius> t7: Haskell doesn't even make sense without its type system.
01:49:05 <t7> the speed of rtti with the safety of dynamic types
01:49:31 <pokoko222_> someone does quantum programming in haskell?
01:49:44 <t7> theres a package on hackage for that
01:50:22 <mgsloan> t7 - just wait a while longer and we'll have a decent "jigger this code around till the types check" button
01:50:54 <pokoko222_> I heard there is a library for it
01:51:00 <t7> hopefully it will just randomly switch out terms
01:54:12 <ivanm> I don't think the type system is restrictive
01:54:21 <ivanm> it just doesn't let you do stupid things
01:58:06 <Jafet> It restricts dumb people from using it
02:00:04 <zhulikas> hey, a question about udp packages
02:00:11 <zhulikas> I still trying to solve stuff from yesterday
02:00:16 <zhulikas> http://i.imgur.com/NgX47.png
02:00:24 <zhulikas> this is what I actually have as a packet
02:01:10 <zhulikas> so data is inside udp, udp is inside IPv4, IPv4 is inside Ethernet packet?
02:01:15 <Phlogistique> ivanm: it doesn't let you do a lot of things, some of which are stupid
02:02:33 <Eduard_Munteanu> In some ways, I think it's harder to remember various implicit conversion rules and foresee way things interact, in comparison to Haskell's "policy".
02:02:35 <sopvop> don't you dare touching my type safety with you dirty duck quaks
02:03:18 <Eduard_Munteanu> *the way
02:03:24 <t7> i might whip up a dynamicly typed language with the syntax of haskell and post it on /r/haskell
02:03:29 <t7> just for the lulz
02:03:45 <sopvop> like lisp?
02:03:50 <Saizan> zhulikas: that would be what i'd expect
02:03:56 <Eduard_Munteanu> t7: you probably want weakly-typed, not dynamically typed
02:03:58 <zhulikas> but what about that "Wire" ?
02:04:06 <zhulikas> or is it like - the whole package
02:04:17 <Phlogistique> "with the syntax of haskell" 11:03:23 < sopvop> like lisp?
02:04:47 <Eduard_Munteanu> Does Lisp even have a syntax? :P
02:05:17 <Jafet> No, it has too many.
02:05:35 <Eduard_Munteanu> Funny how static and strong typing on one hand, and dynamic and weak typing on the other seem to be the choices.
02:05:49 <sopvop> there is nothing special in haskell syntax without type system.
02:06:06 <Eduard_Munteanu> Or how it has to be either static or dynamic in an extreme way.
02:06:21 <t7> sopvop: function application without braces, pattern matching etc etc
02:06:26 <Eduard_Munteanu> (actually my problem is with dynamic-all-the-way typing, rather)
02:07:00 <Eduard_Munteanu> "Make up a nice lie, tell me I'm wrong at the last possible moment" :)
02:10:27 <Jafet> @quote python.way
02:10:27 <lambdabot> Jafet says: it's more fashionable nowadays to do it [write code] the python way, pretend your code works when you write it and hope it works when you run it
02:11:35 <Eduard_Munteanu> Hm, true :)
02:11:36 <Saizan> tbf the "way" should include writing tests too
02:12:12 <Saizan> so at least the hoping is not all done in production :)
02:12:23 <Eduard_Munteanu> Though when I brought this up in another channel, somebody commented it might be hard to design half-way static languages. Not sure if that's true though.
02:12:51 <Eduard_Munteanu> (assuming there are relatively good reasons to use features that require dynamic typing)
02:13:03 <hpaste> chra pasted “Type families, help?” at http://hpaste.org/64429
02:13:12 <Saizan> Eduard_Munteanu: Wadler has some papers on that
02:13:15 <Eduard_Munteanu> Of course, I pointed out we already do that in case of e.g. partial functions on lists.
02:13:42 <Eduard_Munteanu> Like 'head'.
02:14:03 <Eduard_Munteanu> (or language-provided array bounds checking)
02:14:07 <Saizan> chra: your snoc function won't work
02:14:22 <chra> Saizan: Why?
02:14:33 <Saizan> chra: because the typeclass parameters appears only as an argument to the type family
02:14:52 <Eduard_Munteanu> Saizan: hm, any particular paper name you remember? TBH, I think there is *some* truth to that.
02:15:48 <Saizan> chra: and since you could well have two different types A and B which have Builder A ~ Builder B then from knowing Builder a ~ String you can't deduce a ~ String and so it can't decide which instance to use
02:16:29 <Eduard_Munteanu> I should probably look for "latent typing" though.
02:17:07 <chra> Saizan: I think I see. Any suggestion on how to make it work?
02:17:29 <Saizan> chra: or in your case it can't deduce a ~ α from Builder a ~ (Builder α)
02:18:13 <Saizan> chra: there are ways like making Builder a data family or adding a dummy alpha argument to snoc
02:18:22 <Saizan> chra: though not sure how well they fit here
02:18:39 <Eduard_Munteanu> In any case, I'm not yet clear which features actually make a good case for partially-dynamic typing (aside from partiality which I mentioned, if you see that as checking "dependent" types at runtime)
02:20:26 <Saizan> chra: this class seems to be in the same area btw http://hackage.haskell.org/packages/archive/reducers/0.1.7/doc/html/Data-Semigroup-Reducer.html
02:20:27 <Eduard_Munteanu> (though you can apply the same argument for any traditional assertion, hm)
02:20:36 <Saizan> Eduard_Munteanu: it was something about assigning blame
02:20:47 <Eduard_Munteanu> Thanks, lemme google.
02:21:20 <Saizan> http://homepages.inf.ed.ac.uk/wadler/topics/blame.html
02:21:25 <Eduard_Munteanu> Right, found "Well-typed programs can’t be blamed"
02:21:29 <harlekin> @pl (\(a, b) (a', b') -> (a + a', b + b'))
02:21:29 <lambdabot> uncurry (flip flip snd . (ap .) . flip flip fst . ((.) .) . (. (+)) . flip . (((.) . (,)) .) . (+))
02:21:53 <harlekin> > (***) (+) (0, 0) (1, 3)
02:21:54 <lambdabot>   Couldn't match expected type `b' -> c''
02:21:54 <lambdabot>         against inferred type `(t, ...
02:22:15 <MaskRay_> > ((+) *** (+)) (0,0) (1,3)
02:22:16 <lambdabot>   Couldn't match expected type `t1 -> t'
02:22:16 <lambdabot>         against inferred type `(b ->...
02:32:20 <chra> Saizan: Thanks, got it working.
02:37:03 <t7> whats the bottom upside-down symbol for?
02:38:19 <Eduard_Munteanu> t7: ⊤ ?
02:38:28 <t7> yeah
02:38:41 <Eduard_Munteanu> That the unit type, or top. It's like () in Haskell.
02:38:45 <Eduard_Munteanu> *that's
02:38:49 <t7> ah ok
02:40:35 <mm_freak_> the symbol is a bit weird
02:40:50 <ddarius> Really?
02:40:56 <mm_freak_> it suggests "most defined"
02:41:00 <ddarius> It's a generic symbol for the top of a lattice.
02:41:05 <mm_freak_> but that's a void concept in agda
02:41:18 <mm_freak_> because every value is fully defined
02:41:36 <ddarius> The information lattice is hardly the only lattice out there.
02:41:50 <Eduard_Munteanu> Well, ⊤ has a few distinct meanings.
02:42:29 <Eduard_Munteanu> For example, IIRC TAPL mentions ⊥ <: ... <: ⊤ at some point.
02:42:43 <ddarius> Eduard_Munteanu: Yes, that would be the subtyping lattice.
02:43:22 <Eduard_Munteanu> I'm not sure what that ⊤ would be concretely, though.
02:43:24 <ddarius> If you were doing abstract interpretation ⊤ would mean yet another thing, yet it would still be the top element of a lattice.
02:43:56 <Eduard_Munteanu> I'd guess a "union" of all types.
02:43:59 <ddarius> Eduard_Munteanu: In that case, the subtyping case, it the type that is the supertype of all types.
02:44:09 <Eduard_Munteanu> Ah.
02:44:15 <ddarius> If you took out primitive types in Java, it would be Object.
02:44:28 <Eduard_Munteanu> Hm, makes sense.
02:45:02 <ddarius> I believe Any in Scala serves that role, though I may be mixing it up.
02:45:09 <t7> about 5 pages into any type systems pdf the words just dont make sense anymore. I know what each of the words mean but the meaning of the sentence is lost on me
02:45:11 <t7> :(
02:45:15 <t7> i wish i did CS
02:45:32 <ddarius> I doubt you'd be much better off with a typical CS degree.
02:45:39 <ddarius> (Bachelor's degree)
02:45:56 <ddarius> You don't need to go to school to learn.
02:46:01 <Eduard_Munteanu> I guess in Haskell, it could be  forall a. a  (trivially)?
02:46:33 <ddarius> Haskell doesn't have subtyping so there is no subtyping lattice.
02:47:02 <ddarius> If you want to say instantiation induces a subtyping relationship, then yes, that would be the top element.
02:47:03 <Eduard_Munteanu> You can introduce a compatible subtyping relation, though.
02:47:47 <Saizan> i was used to it being the bottom
02:48:13 <Eduard_Munteanu> X <: X forall X, but I'm unsure you'd have a top barring polymorphic types.
02:48:29 <Saizan> and exists a. a the top
02:48:40 <Eduard_Munteanu> Oh, right.
02:48:48 <ddarius> Saizan: That's a different lattice.
02:49:33 <Eduard_Munteanu> So I guess you can only get it as   data Top = forall a. Top a   ?
02:49:41 <majuscule> My first haskell program is finished!
02:49:52 <majuscule> dylanll.com/git/powermate.git
02:49:59 <ddarius> Eduard_Munteanu: That's something different than what you were talking about originally.
02:50:11 <Eduard_Munteanu> Yeah.
02:50:42 <Eduard_Munteanu> But that's a bit more familiar now that Saizan mentioned it.
02:52:21 <Eduard_Munteanu> However I think that's not quite it, since Void doesn't fit in Top. You'd need a naked existential perhaps?
02:52:23 <ddarius> The lattice that Saizan is talking about would be one where A < B if there is a total function from A -> B (or, taking a logical perspective, it's the lattice induced by implication.)
02:53:03 <Eduard_Munteanu> Mm, so it's not subtyping.
02:53:13 <ddarius> It's not subtyping.
02:53:27 <ddarius> Subtyping is about types.  This would be more about values.
02:53:34 <efie> how can i check if a string consists only of literals and not of any numbers?
02:53:45 <ChristianS> majuscule: cool, but you have put everything in the IO monad, which is very unnecessary. there is no reason why the update... + volume... functions return IO State instead of just State.
02:54:07 <ChristianS> the readState function is completely unnecessary
02:54:27 <Eduard_Munteanu> ddarius: I guess my original bot <: ... <: top (trivial again) was subtyping, but bot ~ top?
02:54:39 <ChristianS> rule of thumb: most of your program should be pure, IO functions should be kept to the necessary minimum.
02:54:41 <Eduard_Munteanu> where ~ denotes isomorphism
02:54:57 <efie> is there a function which checks if a Char is a literal?
02:55:13 <zhulikas> @hoogle isLiteral
02:55:13 <lambdabot> No results found
02:55:16 <zhulikas> nope
02:55:16 <Jafet> Heh, isomorphism: the ultimate handwave
02:55:42 <majuscule> ChristianS: I definitely see what you mean about returning IO States, I'm going to try to fix that now. But I don't really know how else I'd organize the program besides calling it in main :: IO ()
02:55:57 <Jafet> efie: what is a literal?
02:56:27 <Jafet> Eduard_Munteanu: how is subtyping defined?
02:56:35 <Eduard_Munteanu> Yeah, I'm thinking any top one could provide would end up being isomorphic to bot. And you'd end up with a diagonal subtyping relation taking the isomorphism into account.
02:57:10 <ChristianS> majuscule: main is always in the IO monad and some other functions will probably be there too (otherwise your program couldn't modify the state of the world, which would make it fairly pointless).
02:57:13 <efie> jafet: i think the correct word is character?: a, b , ... z ,A ... Z
02:57:13 <ddarius> Eduard_Munteanu: If you use instantiation to define your subtyping relationship, you won't have a (unique) bottom element.
02:57:14 <Eduard_Munteanu> Jafet: mm, I'm just introducing a minimal subtyping relation that's compatible with Haskell.
02:57:26 <ChristianS> you can call pure functions from IO code, just not the other way around
02:57:34 <ChristianS> try keeping most of your functions pure
02:58:02 <Eduard_Munteanu> I see.
02:58:06 <Jafet> efie: isAlpha detects letters.
02:58:29 <Jafet> > isAlpha 'λ'
02:58:30 <lambdabot>   True
02:58:40 <Eduard_Munteanu> Agda also seems to have a notion of subtyping used in the typechecker, but the language doesn't really provide subtyping.
02:58:41 <efie> Jafet: letters! ok, thanks
02:58:43 <Jafet> Eduard_Munteanu: ...which one?
02:59:26 <Eduard_Munteanu> Jafet: I started with the diagonal one, and tried to figure if there was a top for that.
02:59:56 <ddarius> If you only have X <: X and nothing else, then there is no top or bottom unless you only have one type.
03:00:02 <t7> in hindley milner type args must be monotypes. the type of 'id' is a quantified type, right? so how can 'id id' work?
03:00:28 <ddarius> t7: You instantiate each to a monotype.
03:00:32 <Jafet> Sorry, I don't know about diagonal subtyping
03:00:47 <Eduard_Munteanu> Jafet: I mean it's just the reflexive relation. X <: X forall X
03:01:01 <Jafet> What ddarius said, then
03:02:29 <Saizan> for a sane subtyping relation you should have G , x : B |- e : T and G |- A <: B imply G , x : A |- e : T, no?
03:02:39 <Eduard_Munteanu> t7: note the type of "id id"
03:02:41 <Eduard_Munteanu> :t id id
03:02:42 <lambdabot> forall a. a -> a
03:03:06 <Jafet> If you use structural subtyping, then top contains every computable data structure
03:03:49 <Jafet> Well, top isn't a type then
03:04:21 <t7> how do i instantiate a type scheme? :3
03:04:38 <Saizan> and that doesn't work if you take forall a. a as top, because it's easy to construct terms that don't typecheck if you can change the type of "undefined"
03:05:16 <t7> i feel like it should not be taking me weeks and weeks to understand and implement HM :(
03:05:48 <ddarius> t7: If you have to learn all the background as well, then you feel wrong.
03:05:51 <Eduard_Munteanu> Hm, indeed. You also don't have ⊥ <: X, forall X.
03:07:51 <Eduard_Munteanu> t7: if you could instantiate that to a polytype you'd end up with a rank-2 type
03:09:07 <t7> Eduard_Munteanu: what happens when i apply a forall a. a -> a   to another   forall a. a-> a
03:09:34 <Jafet> Rename variables and unify.
03:09:53 <t7> i allways thought you get a (forall a. a -> a) -> (forall a. a -> a)         applied to (forall a. a -> a)
03:10:03 <t7> but the forall has to be at the start of the type
03:10:23 <Eduard_Munteanu> t7: you can easily move it there
03:10:58 <Eduard_Munteanu> (forall a. a -> a) -> (forall b. b -> b)  <=>  forall b. (forall a -> a) -> b
03:11:25 <Eduard_Munteanu> Erm... forall b. (forall a. a -> a) -> b
03:12:08 <Eduard_Munteanu> You can actually write that in Haskell if you enable Rank2Types (at least).
03:13:19 <Eduard_Munteanu> Bah, another mistake... forall b. (forall a. a -> a) -> b -> b
03:13:22 <t7> which leaves me with (?)   forall a, b. (a -> a) -> (b -> b)
03:13:32 <Eduard_Munteanu> No.
03:14:00 <Eduard_Munteanu> You can't remove the other one.
03:15:16 <Eduard_Munteanu> But that's valid Haskell + Rank2Types.
03:15:40 <t7> how can it infer b though...
03:16:06 <t7> oh i guess that why im left with a b -> b
03:16:08 <Saizan> HM would type let foo = id id as if it was System F's (adding let to it)  let foo = /\ a. id [a -> a] (id [a]), btw
03:16:14 <Eduard_Munteanu> To actually write "id id" you need ImpredicativeTypes AFAIU, and you need to spell out the type signature yourself.
03:16:25 <ddarius> Eduard_Munteanu: No you don't.
03:16:27 <Eduard_Munteanu> (same thing for Rank2Types)
03:16:42 <Eduard_Munteanu> ddarius: to write the impredicative "id id"
03:16:48 <ddarius> It infers that id :: A -> A and then the outer id :: (A -> A) -> (A -> A)
03:17:15 <Eduard_Munteanu> Sure, plain "id id" works fine...
03:17:16 <t7> omg
03:17:17 <Eduard_Munteanu> > id id 5
03:17:18 <lambdabot>   5
03:17:45 <Jafet> Were you talking about chocolate chip mint id id?
03:18:28 <zhulikas> @type id id id
03:18:28 <lambdabot> forall a. a -> a
03:18:40 <Eduard_Munteanu> Or am I mistaken? (Presumably that's what you also need to get runST to compose, IIRC)
03:18:51 <ddarius> I think this is the first time I've ever heard someone say "chocolate chip mint" rather than "mint chocolate chip."
03:19:26 <Jafet> I typed the topping before I remembered to type a flavour.
03:19:27 <t7> you Americans always think about food
03:19:41 <mux> hmmm, chocolate flavoured parametric polymorphism
03:20:03 * ddarius doesn't think he's ever had mint ice cream topped with chocolate chips.
03:21:21 <t7> "lambda-bound variables are monomorphic, Let-bound variables are polymorphic" is that true?
03:24:00 <shachaf> t7: In Haskell 98.
03:24:35 <t7> so you couldn't write id as \x -> x   in haskell 98?
03:24:58 <ddarius> t7: No, that's not what that means.
03:25:31 <Eduard_Munteanu> Oh, hm, I see what ddarius meant, my mistake. Actually the first 'id' in 'id id' gets that type, IIUC.
03:27:24 <ddarius> > (id True, id 'a')
03:27:25 <lambdabot>   (True,'a')
03:27:34 <ddarius> > (\id -> (id True, id 'a')) id
03:27:35 <lambdabot>   Couldn't match expected type `GHC.Types.Char'
03:27:35 <lambdabot>         against inferred type...
03:28:30 <Eduard_Munteanu> ddarius: I guess that works iff ImpredicativeTypes is enabled?
03:31:09 <Saizan> Eduard_Munteanu: you'd also need a type annotation somewhere, and hope GHC takes the hint
03:31:53 <Eduard_Munteanu> I see.
03:40:10 <Eduard_Munteanu> I wonder, does impredicativity affect inference per se, or does it just share difficulties (impossibility) inherent with rank-2/k/n types?
03:47:31 * Saizan doesn't know
03:52:34 <Jeanne-Kamikaze> would anyone know about an array like structure implementing Storable ?
03:53:44 <Saizan> iirc StorableVector
03:54:40 <Jeanne-Kamikaze> ah, ok thanks :)
03:55:03 <Saizan> oh, StorableArray might be a simpler option
03:55:08 <Saizan> from the array package
03:57:49 <zhulikas> how can I get a date (yyyy-MM-dd HH:mm:ss) from a timestamp?
03:59:28 <zomg> zhulikas: timestamp...?
03:59:41 <zomg> String milliseconds from unix epoch?
03:59:58 <zomg> *Int
04:00:08 <alpounet> zhulikas, http://www.haskell.org/ghc/docs/latest/html/libraries/time-1.4/Data-Time-Format.html see formatTime
04:00:14 <zhulikas> Word32 seconds
04:00:23 <zhulikas> or Word32 microseconds
04:00:26 <zhulikas> no milliseconds in this case :)
04:00:28 <zomg> Yeah probably what alpounet said will work
04:00:35 <zhulikas> ok, thanks
04:08:33 <osa1> IO inside post in haskellwiki( http://www.haskell.org/haskellwiki/IO_inside ) is great, do we have posts like that but for IORef's or other mutable data structures?
04:10:27 <shachaf> That post looks more misleading than great -- I'm very suspicious of the RealWorld IO analogy.
04:11:19 <shachaf> It looks like it has some discussion of IORefs. Anyway, once you understand IO, the various constructs on top of it like IORefs should be relatively straightforward/understandable from reading the documentation.
04:13:43 <osa1> shachaf: why? what's wrong with RealWord analogy?
04:18:58 <quintessence> There's a case to be made that saying "IO is a State monad where the state type is something you can't construct, inspect, or copy" isn't any more informative than saying "IO is a monad".
04:22:23 <hpaste> keep_learning pasted “exporting modules in cabal file” at http://hpaste.org/64435
04:22:36 <keep_learning> hello all
04:23:05 <keep_learning> I have created a library and trying to export it  executable's cabal file
04:23:27 <keep_learning> but it complaining that it dependencies are missing .
04:24:10 <keep_learning> Could some one please tell me how to show the path of library to test module
04:24:34 <quicksilver> quintessence: except it's actually *disinformative* since it's wrong.
04:25:08 <ChristianS> keep_learning: there is no hypersparse library on hackage, maybe that is the problem?
04:25:27 <quicksilver> quintessence: it's about as informative as saying "the IO type is a small, endangered species of peruvian tree shrew, uncommonly fond of cucumbers and vegemite".
04:26:04 <keep_learning> ChristianS, No its my library
04:26:29 <keep_learning> in sparse-matrix/hypersparse
04:26:40 <quintessence> keep_learning: did you cabal install the library or just build it in place?
04:28:07 <ChristianS> keep_learning: hm, did you locally install it using cabal install?
04:28:17 <keep_learning> quintessence, I am trying to build cabal file for test executable which imports library hypersparse
04:28:26 <keep_learning> ChristianS, no
04:28:40 <ChristianS> then cabal won't be able to find it
04:28:52 <keep_learning> ChristianS, So i need to install it locally then test executable will get it ?
04:29:05 <ChristianS> i suppose so
04:29:28 <quintessence> I think you can register it in-place without installing it, but I'm not 100% sure
04:29:59 <keep_learning> ChristianS, quintessence thank you
04:32:09 <zhulikas> @hoogle [Word8] -> Word16
04:32:10 <lambdabot> Data.List genericLength :: Num i => [b] -> i
04:32:10 <lambdabot> Unsafe.Coerce unsafeCoerce :: a -> b
04:32:10 <lambdabot> Control.OldException throwDyn :: Typeable exception => exception -> b
04:32:16 <zhulikas> :(
04:38:12 * hackagebot cpsa 2.2.8 - Symbolic cryptographic protocol analyzer  http://hackage.haskell.org/package/cpsa-2.2.8 (JohnRamsdell)
04:50:29 <sap> is there an instance of MonadFix for ContT?
04:51:03 <mm_freak_> sap: no
04:51:23 <mm_freak_> not that it's impossible, but nobody has come up with a reasonable pure implementation of MonadFix for ContT
04:51:41 <mm_freak_> what is the corresponding greek letter for T?  tau or theta?
04:51:48 <hpc> τ
04:51:52 <mm_freak_> thanks
04:51:58 <hpc> (according to pressing 't' on a greek layout)
04:52:13 <sap> mm_freak: so, we do not know for sure that there is none, we just haven't yet come up with one?
04:52:38 <hpc> :t mfix
04:52:38 <sap> mm_freak: or is it that it cannot be pure?
04:52:39 <lambdabot> forall a (m :: * -> *). (MonadFix m) => (a -> m a) -> m a
04:52:39 <hpaste> Shamanoid pasted “Stupid Code 2” at http://hpaste.org/64436
04:52:47 <hpc> @unmtl Cont t a
04:52:47 <lambdabot> (a -> t) -> t
04:53:05 <shachaf> Theta presumably corresponds to þ
04:53:11 <Shamanoid> guys can somebody help me with the code i posted
04:53:14 <hpc> mfix :: (a -> (a -> t) -> t) -> (a -> t) -> t
04:53:21 <hpc> @djinn (a -> (a -> t) -> t) -> (a -> t) -> t
04:53:21 <lambdabot> -- f cannot be realized.
04:53:53 <shachaf> That doesn't mean anything.
04:53:58 <shachaf> @unmtl Identity a
04:53:58 <lambdabot> a
04:54:03 <shachaf> @djinn (a -> a) -> a
04:54:03 <lambdabot> -- f cannot be realized.
04:55:53 <hpc> it could be that Cont doesn't have a pure mfix definition, because 'a' is in a negative position?
04:56:48 <shachaf> a is in a negative position there?
04:57:01 <hpc> i think
04:57:04 <hpc> (a -> t) -> t
04:57:11 <Shamanoid> http://hpaste.org/64436  <~~~i reckon some of you can spot the problem from first look
04:57:38 <shachaf> I must not understand what "negative position" means, then.
04:58:09 <hpc> shachaf: probably me, actually :P
04:58:43 <Phlogistique> shachaf: remove the second "where"
04:58:47 <Phlogistique> oops
04:58:49 <Phlogistique> Shamanoid: ^
04:58:53 <Phlogistique> you need only one
04:59:16 <sap> hpc: what would it mean to have an *impure* instance?
04:59:28 <quicksilver> negative position means to the left of an odd number of (->)
04:59:31 <shachaf> Fix your indentation while you're at it. It's all over the place.
04:59:41 <shachaf> This is because you're using tabs. Stop using tabs.
04:59:44 <quicksilver> although there is a subtlety about how you count them
04:59:45 <hpc> quicksilver: ah, gotcha
04:59:50 <quicksilver> (a -> t) -> t is positive.
04:59:52 <quicksilver> (in a)
04:59:53 <hpc> thought it meant to the left of a (->) at all
04:59:55 <zhulikas> @hoogle Word8 -> Char
04:59:56 <lambdabot> Unsafe.Coerce unsafeCoerce :: a -> b
04:59:56 <lambdabot> Control.OldException throwDyn :: Typeable exception => exception -> b
04:59:56 <lambdabot> Data.Generics.Text gshow :: Data a => a -> String
04:59:57 <shachaf> What quicksilver said, then.
05:00:01 <zhulikas> any thoughts on that?
05:00:03 <Phlogistique> Shamanoid: read what shachaf just said above too.
05:00:12 <shachaf> hpc: -1 * -1 = 1 :-)
05:00:45 <quicksilver> you have to fully bracket before you count.
05:00:45 <hpc> @free mfix :: (a -> (a -> t) -> t) -> (a -> t) -> t
05:00:46 <lambdabot> (forall x p q. g . p = q . f               =>                g (h x p) = k (f x) q) => g . f1 = f2 . f => g (mfix h f1) = mfix k f2
05:01:11 <shachaf> hpc: If in foo :: ...x... x is in the positive position, that means that foo "gives you an x", in some sense; if it's in the negative position, that means that you "give it an x".
05:01:18 <sap> zhulikas: if you cannot find anything better, try (ord . fromIntegral) (not tested)
05:01:23 <quicksilver> @djinn a -> ((a -> t) -> t)
05:01:24 <lambdabot> f a b = b a
05:01:37 <Shamanoid> hmm
05:01:58 <Shamanoid> but the second where is for a definition that is in the first where
05:02:11 <hpc> quicksilver: in any event, i don't see how you can get an 'a' out of that mfix type
05:02:29 <hpc> sap: i mean, using mutation or other spooky things
05:02:34 <sap> zhulikas: sry, it was (chr . fromIntegral)
05:02:40 <DarkUnicorn> is there a standard-function to get all unique values from a list based on a custom compare function which decides if two values are equal?
05:02:40 <zhulikas> sure
05:02:51 <quicksilver> hpc: well, how do you get a out of (a -> a) ?
05:02:51 <shachaf> DarkUnicorn: nubBy?
05:02:55 <quicksilver> hpc: which is the normal fix type.
05:03:02 <quicksilver> hpc: fix is not logical.
05:03:11 <quicksilver> in fact, fix is inconsistent.
05:03:17 <shachaf> fix is broke
05:03:36 <shachaf> Or maybe functions :: (a -> a) are broke.
05:03:50 <shachaf> The point is, don't fix it.
05:04:01 <DarkUnicorn> shachaf: exactly. thank you!
05:04:04 <hpc> what is the current mfix for ContT?
05:04:29 <Shamanoid> Phlogistique: but the second where is for a definition that is in the first where
05:04:46 <Phlogistique> Shamanoid: yeah. You don't need it.
05:05:00 <Phlogistique> remove the "where" and fix your indentation.
05:05:02 <shachaf> DarkUnicorn: Of course, it could be more efficient if you could use a custom compare function that returned Ordering instead of Bool.
05:05:08 <mm_freak_> sap: we haven't come up with one
05:05:12 <shachaf> DarkUnicorn: But I don't think there's an easy library function for that.
05:05:34 <Shamanoid> Phlogistique: still same error :(
05:05:35 <hpc> :t (>>=)
05:05:36 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m a -> (a -> m b) -> m b
05:05:43 <shachaf> ContT ain't mbroke.
05:05:59 <DarkUnicorn> shachaf: its a short list and i only need it to work around a problem in yesod, so its enough for now :)
05:06:07 <Shamanoid> Phlogistique: error at definition of updated_csp
05:06:27 <Phlogistique> Shamanoid: have you fixed your indentation?
05:07:17 <Shamanoid> Phlogistique: how do i do that? do i write everything again using spaces instead?
05:07:36 <sap> mm_freak_: thank you, i conclude that it is not a trivial problem and keep my ugly workaround
05:08:01 <shachaf> Shamanoid: Using most text-editing programs nowadays, you don't need to type the non-whitespacey parts of it.
05:08:02 <Phlogistique> Shamanoid: replace tabs with spaces
05:08:21 <Phlogistique> shachaf: I think you meant the opposite.
05:08:32 <shachaf> I did?
05:08:41 <Phlogistique> (or your editor rocks)
05:08:46 <shachaf> I mean "retype".
05:08:54 <Phlogistique> oh.
05:09:02 <shachaf> You don't have to type the whole thing all over again, just the parts that are tabs now.
05:09:30 <Phlogistique> yeah. but it looks like Shamanoid is using "cat" as a text editor.
05:11:35 <zhulikas> @hoogle m a -> m b
05:11:35 <lambdabot> Control.Monad forever :: Monad m => m a -> m b
05:11:36 <lambdabot> Foreign.ForeignPtr castForeignPtr :: ForeignPtr a -> ForeignPtr b
05:11:36 <lambdabot> Foreign.Ptr castFunPtr :: FunPtr a -> FunPtr b
05:11:37 <sipa> cat is not an editor; it does not *edit*
05:11:41 <shachaf> There is always ed. It is standard, after all.
05:11:46 <zhulikas> @hoogle m [a] -> m [b]
05:11:47 <lambdabot> Data.List transpose :: [[a]] -> [[a]]
05:11:47 <lambdabot> Prelude mapM :: Monad m => (a -> m b) -> [a] -> m [b]
05:11:47 <lambdabot> Control.Monad mapM :: Monad m => (a -> m b) -> [a] -> m [b]
05:11:49 <mm_freak_> sap: what do you need ContT for?  surely there is an alternative monad that has MonadFix
05:12:07 <sap> mm_freak_: inversion of control
05:12:08 <Phlogistique> shachaf: yeah, and you *can* use it to replace tabs with spaces without retyping the whole text
05:12:21 <mm_freak_> sap: that's a broad term…  could you be more specific?
05:12:44 <sap> mm_freak_: some imperative-like code that produces "syscalls" that are handled by the surrounding code
05:12:51 <Shamanoid> Phlogistique: i'm actually using geany
05:13:21 <Phlogistique> Shamanoid: good for you; it is usually easier to use than ed.
05:13:35 <sap> mm_freak_: the surrounding code then handles the calls and continues the imperative code ... basically some kind of green threads
05:13:38 <iago> hi, is there a performance difference between IORef and STRef?
05:13:51 <mm_freak_> sap: what about real threads?
05:13:58 <mm_freak_> iago: (supposedly) no
05:14:05 <hpc> iago: unlikely; you couldn't use them in comparable situations anyway
05:14:14 <mux> I was about to answer "in theory no, but in practice I'm not sure"
05:14:33 <Philippa> hpc: well, you can translate ST code to IORef+IO just to bench it
05:14:35 <mm_freak_> iago: IO is really a special case of ST, so they should have the same underlying implementation
05:14:40 <liyang> I think IORef and STRef share the same implementation. Let me check.
05:14:51 <Philippa> yeah, isn't IORef STRef RealWorld#?
05:15:02 <mm_freak_> yeah, that's what i would think
05:15:14 <sap> mm_freak_: hm, i could use channels and message-passing to make calls and return the result
05:15:19 <mux> that doesn't necessarily mean the performacne is identical
05:15:21 <liyang> Philippa: I think so, or at least I've see something along those lines in the libs.
05:15:55 <sap> mm_freak_: but that would make the whole code impure with lots of IO
05:15:58 <yitz> the proof is in the pudding, and the pudding is in the benchmarks
05:16:01 <mm_freak_> sap: yes…  a useful idiom is:  do resultVar <- newEmptyMVar; putMVar cmdVar (DoSomething (putMVar resultVar); result <- takeMVar resultVar
05:16:14 <mm_freak_> sap: there is nothing wrong with impure code
05:16:51 <mm_freak_> what you want to avoid in haskell is imperative code…  impure code is much less compelling
05:17:01 <mm_freak_> but since your code is imperative anyway…
05:17:10 <sap> mm_freak_: i'm writing a simulation, not a production-level library. i thought i'd keep it simple and pure
05:17:30 <mm_freak_> sap: have you checked to monad-coroutine package?
05:18:22 <mm_freak_> sap: it doesn't give you MonadFix, but it gives you a more domain-specific language for your purpose
05:18:41 <otters> @src [] (>>=)
05:18:42 <lambdabot> xs >>= f     = concatMap f xs
05:18:52 <sap> mm_freak_: only the "client" code is imperative. @monad-coroutine: hmm, i'll have a look at it, but it sounds like it is basically the same thing
05:19:33 <mm_freak_> sap: your code might look nicer with monad-coroutine
05:19:51 <iago> mm_freak_, hpc, mux: thanks
05:21:00 <liyang> From "base" GHC.IORef: newtype IORef a = IORef (STRef RealWorld a)
05:21:01 <sap> mm_freak_: ok. MonadFix isn't necessary anyway. the client code uses pointers. with MonadFix i thought i could avoid introducing null pointers.
05:24:19 <mm_freak_> sap: are you making a language interpreter?
05:25:55 <sap> mm_freak_: no, the focus is on syscalls. the "client" program merely serves the purpose of generating a realistic sequence of syscalls
05:27:04 <sap> mm_freak_: of course the client programs' behaviour depends on the answers to the syscalls, so there is a resemblance to an interpreter in a way
05:31:43 <zhulikas> how can I get a number from 5 bytes?
05:32:33 <keep_learning> quintessence, Hi
05:35:08 <yitz> zhulikas: what kind of number do you want, and how is it represented in those 5 bytes?
05:35:40 <zhulikas> all I know is it's description and length in bytes
05:35:43 <zhulikas> Best bid price(1st) 5
05:36:12 <yitz> zhulikas: so do you think it is an integer? and can you guess its endienness from the context?
05:36:30 <zhulikas> I can guess it's 5 digits and not a number
05:36:37 <zhulikas> because otherwise it does not make sense to me
05:36:55 <yitz> oh so it might by ascii digits?
05:37:00 <yitz> *be
05:37:05 <zhulikas> uhm... actually, yes, ascii
05:37:20 <zhulikas> does that mean, that every byte is a character?
05:37:47 <yitz> zhulikas: if it's ascii (or utf-8 unicode, which is the same in this context) then yes
05:37:58 <zhulikas> awesome
05:38:04 <zhulikas> it makes so much more sense now :D
05:38:36 <zhulikas> hmm
05:38:56 <yitz> zhulikas: get it either as Text and use Text.Read.decimal, or as a String and use read or reads.
05:38:59 <zhulikas> unpack :: ByteString -> [Word8]Source
05:38:59 <zhulikas> O(n) Converts a ByteString to a '[Word8]'.
05:39:11 <wern> Are there any elegant ways of passing around state references without creating horribly long type signatures in every function? Do you group them in records? Or do go you to great lengths of keeping state at the "top level"?
05:39:26 <zhulikas> so... map (chr . fromIntegral) (unpack $ take 5 bytestring) should give me 5 digits
05:39:41 <Botje> wern: use a type alias
05:39:51 <alpounet> wern, one solution would be to use the state monad here
05:40:09 <yitz> zhulikas: if you're still in the Get monad like yesterday, there should be something nicer than that for you :)
05:40:14 <zhulikas> :D
05:40:18 <zhulikas> I'm still there
05:40:22 <zhulikas> but made some progress!!
05:40:31 <yitz> good :)
05:40:46 <zhulikas> I looked into the packages with wireshark and found out where exactly is the relative data stored
05:51:47 <wern> an example: In an expensive foreign C call "font <- createTextureFont "Arial.ttf" in a render tree, how would you go about to make this reference available to all text rendering functions (living in the IO monad) without polluting type signatures of dozens of rendering functions?
05:52:00 <dylukes> If I'm getting an internal error in GHC,
05:52:16 <dylukes> is there way to get a backtrace through the thunks or something? To try to figure out what's triggering the RTS error?
05:52:38 <Botje> wern: you could use a ReaderT
05:52:45 <Botje> since a texturefont won't change much
05:53:54 <wern> Botje: thank you, will read more about it
05:54:49 <Botje> and use a type Render a = ReaderT (some render stuff) IO a
05:56:31 <Botje> or you use an IORef and some getter functions.
05:58:18 * hackagebot nme 0.2 - Bindings to the Nyctergatis Markup Engine  http://hackage.haskell.org/package/nme-0.2 (StephenWeber)
06:03:44 <sap> mm_freak_: had a glance at monad-coroutine ... it doesn't look like the suspension can consume an argument. so i guess i really do need Cont
06:09:48 <mm_freak_> sap: huh?  see Yield
06:10:47 <quintessence> sap: You may be able to get away with Operational instead of Cont.  You define your commands as constructors of some (G)ADT and get a Monad instance and an easy way to write interpreters for it.
06:11:36 <t7> let in Hindley milner seems redundant... ? why not use a bind and an application?
06:11:43 <sap> m_freak_: what i meant: the surrounding code has to pass an argument to the suspension when it continues ... so yield should return something
06:12:11 <quintessence> t7: let gets generalized, but applications don't
06:12:53 <quintessence> > (\x -> (x 'a', x [])) (\a -> a)
06:12:54 <lambdabot>   Couldn't match expected type `[a]'
06:12:54 <lambdabot>         against inferred type `GHC.Types...
06:13:05 <sap> quintessence: my commands are already constructors of an ADT. i'll look for Operational
06:13:19 * hackagebot network-conduit 0.2.2 - Stream socket data using conduits.  http://hackage.haskell.org/package/network-conduit-0.2.2 (MichaelSnoyman)
06:14:07 <t7> > (\f -> (f 123, f [])) id
06:14:07 <lambdabot>   No instance for (GHC.Num.Num [a])
06:14:08 <lambdabot>    arising from a use of `e_1123' at <int...
06:14:46 <t7> > let f = id in (f 123, f [])
06:14:47 <lambdabot>   (123,[])
06:14:58 <t7> i never knew this :|
06:15:42 <t7> im gonna hire a professor to sit and go through this with me
06:15:58 <mux> tried rent-a-simon.com ?
06:18:10 <t7> has anyone got spj's phone # ?
06:20:16 <wern> Is it more functionally sound to avoid direct font rendering/drawing in dozens functions (receiving the graphic context), and instead pass some sort of render object around, and reunder it the end with a few specialized functions?
06:21:32 <mm_freak_> sap: i see…  honestly i'd just use concurrency
06:21:47 <mm_freak_> it's simple and allows for parallelism
06:26:35 <quintessence> wern: Option 2 sounds cleaner to me.  You might want to look at the diagrams package for some examples of the style.
06:28:15 <t7> can i implement hindley-milner with debruijn indices rather than variable names?
06:28:24 <t7> i cant find examples of it online
06:32:32 <wern> quintessence:  it sound cleaner to me as well, I just worry about performance when passing a hundreds of primitives (rectangles, text, images) around in a render object, all for a responsive GUI
06:33:19 <dylukes> @seen kmc
06:33:19 <lambdabot> Unknown command, try @list
06:33:26 <dylukes> preflex, seen kmc
06:33:26 <preflex>  kmc was last seen on #haskell-in-depth 20 hours, 19 minutes and 44 seconds ago, saying: so i feel you would drop down to the underlying untyped syntax in a majority of cases
06:36:57 <t7> > (\x -> x 123) (\x  -> x)
06:36:58 <lambdabot>   123
06:37:49 <dylukes> Is anyone here on OS X?
06:40:13 <ion> > 123 (\x -> x)
06:40:13 <lambdabot>   123
06:40:35 <zhulikas> > (\ -> 123)
06:40:36 <lambdabot>   <no location info>: parse error on input `->'
06:40:39 <zhulikas> ok :\
06:41:16 <ion> What would be the type of that? “-> Integer”? :-P
06:41:24 <zhulikas> :: Integer ? :D
06:41:30 <ion> That’s known as “123”.
06:42:04 <zhulikas> > (\x -> 123) ()
06:42:04 <lambdabot>   123
06:42:07 <zhulikas> \o/
06:42:20 <zhulikas> any other ways of getting 123?
06:42:42 <Eduard_Munteanu> > 123 123
06:42:42 <lambdabot>   123
06:42:48 <ion> 1 + 122, 2 + 121, 3 + 120, …
06:43:07 <zhulikas> @type 123
06:43:08 <lambdabot> forall t. (Num t) => t
06:43:15 <zhulikas> @type 123 123
06:43:16 <lambdabot> forall t t1. (Num (t1 -> t), Num t1) => t
06:43:19 <zhulikas> dafuq
06:43:29 <Eduard_Munteanu> zhulikas: da Caleskell :P
06:46:07 <zhulikas> > [5] : return ()
06:46:08 <lambdabot>   Couldn't match expected type `[t]' against inferred type `()'
06:46:23 <zhulikas> @type ()
06:46:23 <lambdabot> ()
06:46:34 <Eduard_Munteanu> :t (:)
06:46:35 <lambdabot> forall a. a -> [a] -> [a]
06:46:44 <quintessence> > (5 + abs) (-4)
06:46:45 <lambdabot>   9
06:47:19 <zhulikas> > (+) 5 4
06:47:19 <lambdabot>   9
06:47:19 <zhulikas> :|
06:47:51 <quintessence> (zhulikas: lambdabot has a nonstandard instance Num n => Num (a -> n) where {fromInteger = pure; (+) = liftA2 (+); ...})
06:48:38 <zhulikas> hmmm
06:48:57 <zhulikas> ah!
06:49:14 <zhulikas> answer to my question came during writing the actual question
06:49:21 <zhulikas> and you will never find out what I wanted to ask!!!!
06:49:26 <quintessence> Socrates strikes again
06:50:36 <dylukes> > (+) 3
06:50:36 <lambdabot>   Overlapping instances for GHC.Show.Show (t -> t)
06:50:36 <lambdabot>    arising from a use of `...
06:50:53 <dylukes> > ((+) 3) + 1
06:50:54 <lambdabot>   Overlapping instances for GHC.Show.Show (t -> t)
06:50:54 <lambdabot>    arising from a use of `...
06:51:00 <dylukes> ((+) 3) + 1 + 2
06:51:07 <dylukes> >((+) 3) + 1 + 2
06:51:16 <dylukes> > ((+) 3) + 1 + 2
06:51:17 <lambdabot>   Overlapping instances for GHC.Show.Show (t -> t)
06:51:17 <lambdabot>    arising from a use of `...
06:51:26 <dylukes> quintessence: what happened to the nonstandard instance?
06:51:48 <quintessence> > ((+) 3) + 1 $ 1
06:51:49 <lambdabot>   5
06:52:12 <zhulikas> > repeat 1
06:52:13 <lambdabot>   [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,...
06:52:18 <zhulikas> y u stop :|
06:53:49 <quintessence> :t (+ 3) + 1
06:53:50 <lambdabot> forall a. (Num a) => a -> a
07:07:13 <t7> :t \ a b -> a b a b a
07:07:14 <lambdabot>     Occurs check: cannot construct the infinite type:
07:07:14 <lambdabot>       t = t1 -> t -> t1 -> t -> t2
07:07:14 <lambdabot>     Probable cause: `a' is applied to too many arguments
07:07:29 <t7> :t \ a b -> b a b a b
07:07:29 <lambdabot>     Occurs check: cannot construct the infinite type:
07:07:30 <lambdabot>       t = t1 -> t -> t1 -> t -> t2
07:07:30 <lambdabot>     Probable cause: `b' is applied to too many arguments
07:10:13 <shapr> t7: What started your interest in the HM type inference algorithm?
07:10:33 <t7> it seemed like the next logical step from systemF omega
07:10:47 <t7> i been working my way through the lambda calculi
07:11:52 <shapr> Have you read Types and Programming Languages by Benjamin Pierce?
07:12:11 <rostayob> t7: wait, HM and System F are different thing. HM is an algorithm for type inference
07:12:24 <t7> i started but I dont understand alot of the notation
07:13:05 <Eduard_Munteanu> Like what?
07:13:10 <t7> rostayob: yes but it cant be applied to system f? you have to use a different term syntax
07:13:14 <shapr> t7: I had that problem when I started reading TaPL, I asked lots of questions here.
07:13:52 <zhulikas> @hoogle [m a] -> m [a]
07:13:52 <lambdabot> Prelude sequence :: Monad m => [m a] -> m [a]
07:13:53 <lambdabot> Control.Monad sequence :: Monad m => [m a] -> m [a]
07:13:53 <lambdabot> Language.Haskell.TH.Syntax sequenceQ :: [Q a] -> Q [a]
07:14:15 <shapr> t7: I'm taking a discrete math class at uni and it seems the symbols are from logic, as in intuitionistic and the other flavor I forgot :-)
07:14:25 <zhulikas> @hoogle [Maybe a] -> [a]
07:14:25 <lambdabot> Data.Maybe catMaybes :: [Maybe a] -> [a]
07:14:26 <lambdabot> Data.Maybe maybeToList :: Maybe a -> [a]
07:14:26 <lambdabot> Prelude sequence :: Monad m => [m a] -> m [a]
07:15:01 <shapr> t7: I have TaPL in my closet at the moment, did you have a question about a particular page or section?
07:15:32 <t7> no i will have to start reading it again from the top
07:15:58 <t7> Its all the proof stuff that i have never really seem or studied before
07:16:52 <shapr> t7: Yah, I know that feeling. This is actually from the ground up, though quite dense: http://en.wikipedia.org/wiki/Propositional_calculus
07:17:03 <shapr> t7: I'm finding it easier to learn this sort of thing in smaller chunks in my class
07:17:16 <shapr> But having exposure to it in the Haskell world is really helping me understand it.
07:17:22 <Eduard_Munteanu> Proofs like "straightforward induction on terms"? :D
07:17:56 <shapr> Yah, that's craziness at first :-)
07:20:17 <shapr> t7: In any case, many of the symbols are explained on that wikipedia page, I hope that helps.
07:21:19 <rostayob> faj: HM cannot be applied to system F
07:22:31 <rostayob> oops, it was for t7
07:22:33 <dzhus> Why Prelude has no `infinityN`/`infinityP`?
07:23:21 <yitz> dzhus: what do you want those to do?
07:23:50 <dzhus> yitz: infinityP = 1 / 0
07:23:51 <rostayob> dzhus: Haskell floats are not IEEE
07:23:52 <alpounet> -inf and +inf
07:24:47 <yitz> > isIEEE 1.0 -- rostayob
07:24:47 <lambdabot>   True
07:25:24 <rostayob> yitz: what's isIEEE?
07:25:31 <rostayob> I guess is not in the report anyways
07:25:33 <dzhus> alpounet: Not in scope
07:25:34 <zhulikas> HHMMSSuu. With T.readTime defaultTimeLocale "%H%M%S" string :: TimeOfDay I can parse HHMMSS, but how can I include uu? I didn't see such formatting anywhere
07:25:50 <rostayob> yitz: or maybe my memory is failing me :P
07:26:25 <alpounet> dzhus, i was just answering yitz
07:26:36 <yitz> rostayob: they don't fully support the ieee api, perhaps that's what you meant
07:27:10 <rostayob> yitz: what I remember is that haskell floats are not required to be IEEE
07:27:30 <dzhus> There's isInfinite but not infinity itself.
07:27:39 <dzhus> So depressing.
07:27:43 <yitz> zhulikas: which format symbol from C are you thinking of?
07:28:04 <zhulikas> I was just given a format HHMMSSuu in the task
07:28:28 <zhulikas> http://www.haskell.org/ghc/docs/7.0.2/html/libraries/time-1.2.0.3/Data-Time-Format.html
07:28:31 <zhulikas> and I can't see it here
07:28:37 <zhulikas> anything for uu
07:28:45 <yitz> rostayob: well, sure. then you would return False for isIEEE. all existing compilers use ieee for Float and Double currently, i think.
07:29:34 <yitz> rostayob: you could invent other instances of RealFloat that either are or are not IEEE.
07:30:19 <yitz> weird - preflex just changed its nick.
07:30:34 <zhulikas> he did not
07:30:55 <yitz> preflex: help
07:30:56 <preflex>  try 'help help' or see 'list' for available commands
07:31:10 <zhulikas> help help with HHMMSSuu
07:32:17 <rostayob> yitz: yeah, I would have guessed that that's why there is no pre-defined "infinity"
07:32:24 <yitz> zhulikas: Data.Time formatting is modelled after C. It more or less supports what you would expect to find there. For anything beyond that, you'll have to parse it yourself.
07:33:26 <zhulikas> so if Data.Time supports picoseconds through %q, I should convert my microseconds to picoseconds and give it as part of an input?
07:33:49 <yitz> rostayob: ieee is a very stateful api, so it's annoying to support in haskell.
07:34:15 <yitz> zhulikas: not sure. try a sample input in ghci and see what you get.
07:42:40 <antonh_> i have a list of list that looks like this: [[1,4], [2], [3,5]] how does the function look for treating each element at the time (in the order specified in the example) until the list, and all the sublists, is empty?
07:43:08 <dzhus> antonh_: this list is invalid
07:43:13 <Borgvall> hi i have a problem with haddock.
07:43:17 <hpaste> Borgvall pasted “haddock error” at http://hpaste.org/64447
07:43:58 <Borgvall> haddock gives me the error "haddock module header parse failed: Cannot parse header documentation paragraphs" with above code
07:44:43 <Borgvall> it seems line 10 triggers it, but i have no clue why
07:45:59 <Borgvall> i have also tried to use the @ @ code annotation instead of >
07:47:06 <Borgvall> however haddock then generates module links, where i wanted string literals
07:47:17 <antonh_> dzhus, my list is not invalid
07:47:47 <Borgvall> is it not possible, to use string literals in haddock example code?
07:49:36 <quintessence> Borgvall: you can escape quotes with a backslash
07:51:33 <Borgvall> quintessence: i thought ">" should use literate mode as is
07:52:26 <quintessence> hmm, yeah
07:53:38 <Borgvall> it also will look very garbled in this case
08:21:16 <jay> Hi all!
08:21:53 <Guest98496> can anybody help me with the function am trying to create?
08:23:29 <parcs`> yes!
08:25:41 <Guest98496> parcs? was that yes for me?
08:27:51 <parcs`> yes!
08:30:01 <jay7557> Any Haskell experts free to help?
08:30:39 <Clint> none
08:31:24 <hpaste> jay7557 pasted “error while trying to create funtion” at http://hpaste.org/64448
08:34:04 <Entroacceptor> jay7557: it helps if you paste the code which produces your error
08:34:29 <fryguybob> @instances-importing Data.Bits Bits
08:34:30 <lambdabot> Int, Integer
08:34:39 <hpaste> jay7557 pasted “error while trying to create funtion” at http://hpaste.org/64450
08:35:14 <jay7557> Entroacceptor! I have pasted the code.
08:36:03 <fryguybob> @type xor
08:36:04 <lambdabot> forall a. (Bits a) => a -> a -> a
08:36:17 <fryguybob> jay7557: String does not implement the Bits type class.
08:37:04 <jay7557> OK.. How would you suggest to write it?
08:37:27 <rostayob> jay7557: maybe 'zipWidth xor' will do what you want
08:37:31 <fryguybob> :t ord
08:37:32 <lambdabot> Char -> Int
08:37:57 <fryguybob> :t chr
08:37:57 <rostayob> jay7557: the thing is, strings might have different lengths, so it's not clear how you would go to define a xor
08:37:57 <lambdabot> Int -> Char
08:38:20 <fryguybob> @src String
08:38:20 <lambdabot> type String = [Char]
08:39:01 <jay7557> What I want to do it to create function which gets arguements at command line and then gets a string as a key which scrambles the two input and displays it
08:40:33 <hpaste> keep_learning pasted “module import” at http://hpaste.org/64452
08:40:46 <jay7557> rostayob :: I have to use infinite cycle of the string I enter
08:40:49 <keep_learning> Hello all
08:41:25 <zhulikas> @hoogle Word32 -> Word32 -> Real
08:41:25 <lambdabot> Warning: Unknown type Real
08:41:25 <lambdabot> Data.Function on :: (b -> b -> c) -> (a -> b) -> a -> a -> c
08:41:25 <lambdabot> Prelude curry :: ((a, b) -> c) -> a -> b -> c
08:41:28 <zhulikas> woops
08:41:37 <gmaslov> map chr $ zipWith (xor `on` ord) (cycle key) input
08:42:17 <keep_learning> I am trying to import a module ( SparseMat_1D ) from /sparse-matrix/hypersparse/src/SparseMat_1D.hs  in  /sparse-matrix/test/Main.hs
08:42:24 <keep_learning> but getting this error
08:42:26 <keep_learning> http://hpaste.org/64452
08:42:27 <zhulikas> @hoogle Word32 -> Word32 -> Fractional a
08:42:27 <lambdabot> Warning: Unknown type Fractional
08:42:27 <lambdabot> Prelude asTypeOf :: a -> a -> a
08:42:27 <lambdabot> Network.BufferType buf_append :: BufferOp a -> a -> a -> a
08:42:31 <zhulikas> ffs.
08:42:31 <rostayob> jay7557: you can use 'cycle' to get an infinite string, and then 'zipWidth xor'
08:42:48 <zhulikas> how can I get a real number from two Ints?
08:43:07 <rostayob> zhulikas: what do you do with the two ints?
08:43:14 <zhulikas> dunno
08:43:16 <zhulikas> fool around
08:43:17 <zhulikas> why
08:43:19 <rostayob> no i mean
08:43:25 <zhulikas> I have epoch time
08:43:30 <rostayob> it's not clear to me how a Int -> Int -> Real would work
08:43:36 <zhulikas> but seconds and milliseconds are in two variables
08:43:36 <rostayob> what do the two ints represent
08:43:42 <rostayob> ok
08:43:46 <zhulikas> so I need seconds.milliseconds
08:43:51 <rostayob> so you want to divide the second int by 1000
08:44:05 <int-e> keep_learning: the  hs-source-dirs:  field is wrong (lines starting with -- are comments, you should remove these minus signs)
08:44:10 <zhulikas> seconds is the part on the left from floating point and milliseconds is on the right
08:44:25 <rostayob> > let f s m = fromIntegral s + fromIntegral m / 1000 in f 2323 323
08:44:25 <lambdabot>   2323.323
08:44:29 <rostayob> zhulikas: there you go
08:44:32 <zhulikas> kewl
08:44:34 <zhulikas> thanks
08:44:40 <gmaslov> I want to force a pure computation in between doing stuff in IO, so the results are instantly available later. Writing "computation `seq` return ()" seems to work (why?), so I'm thinking to define "ioSeq :: a -> IO ()" which does this. Am I crazy?
08:44:53 <jay7557> rostayob :: Would that go in my function or main ?
08:45:05 <rostayob> jay7557: would what go?
08:45:15 <jay7557> the map chr $ zipWith (xor `on` ord) (cycle key) input
08:45:49 <int-e> gmaslov: there's 'eval' in Control.Exception  for this purpose.
08:46:11 <int-e> gmaslov: err 'evaluate'
08:46:19 <gmaslov> int-e: ah, thank you, that's exactly what I was looking for!
08:47:11 <int-e> gmaslov: but in principle, yes, that works.  or   let !_ = a   and a couple of other things, but 'evaluate' makes the intent clearer, I think.
08:48:56 <rostayob> jay7557: in your functio
08:48:58 <rostayob> n
08:49:04 <jay7557> ok
08:49:45 <hpaste> keep_learning annotated “module import” with “module import (annotation)” at http://hpaste.org/64452#a64453
08:50:20 <hpaste> jay7557 pasted “Error!” at http://hpaste.org/64454
08:50:39 <keep_learning> int-e, Its giving error
08:50:46 <keep_learning> http://hpaste.org/64452
08:51:12 <hpaste> jay7557 pasted “error” at http://hpaste.org/64455
08:51:30 <quintessence> @hoogle on
08:51:30 <lambdabot> Data.Function on :: (b -> b -> c) -> (a -> b) -> a -> a -> c
08:51:30 <lambdabot> Control.Exception.Base onException :: IO a -> IO b -> IO a
08:51:30 <lambdabot> Control.Exception onException :: IO a -> IO b -> IO a
08:53:47 <int-e> keep_learning: oh, since the directory would actually be '../src'. which works but is a hint that you're not using cabal correctly.
08:55:42 <int-e> keep_learning: can you add a corresponding 'executable' stanza to hypersparse.cabal? possibly with a flag enabling it (which can be done by adding  buildable: false  to the executable stanza when it's not supposed to be built)
08:57:32 <keep_learning> int-e, thank you
08:58:31 <keep_learning> int-e,  actually I just wanted to import a module from another directory. I am not sure how to do this .
08:58:53 <keep_learning> int-e, one idea is that install hypesparse as library and
08:59:24 <keep_learning> add build-depends: hypersparse
09:00:00 <keep_learning> but I don't want to install library. I just wanted to import a module
09:03:13 <int-e> keep_learning: as a quick hack, using ../src should work, or maybe using a symlink. the proper way would be to install hypersparse as a library, I think.
09:04:01 <alpounet> keep_learning, use the -i option
09:04:01 <keep_learning> int-e,  yes. Installing library seems good option to me
09:04:13 <alpounet> (to ghc)
09:04:26 <alpounet> of course, only if it is for a quick test or smth like that
09:04:49 <alpounet> otherwise you really should add it to the dependencies in the cabal file
09:14:04 <edwardk> preflex: xseen koninkje
09:14:05 <preflex>  koninkje was last seen on freenode/#haskell 12 days, 12 hours, 29 minutes and 35 seconds ago, saying: * koninkje wonders what APL used for map
09:15:33 <xplat> edwardk: when were you going to tell me that thing you thought of about iteratees?
09:15:56 <edwardk> i suppose i can go through it now ;)
09:16:21 <xplat> excellent!
09:16:30 <edwardk> ##iteratees?
09:16:36 <xplat> yes
09:23:37 <msieradzki> is Cabal-1.14.0 supposed to almost instantly get broken in ghc 7.4.1 win32?
09:23:54 <rostayob> msieradzki: "Almost instantly get broken" = ?
09:23:58 <msieradzki> it says it depends on missing process and directory
09:24:22 <msieradzki> which are bundled in ghc 7.4.1 already and that breakage happens after I try to install first package wtih cabal install hoogle
09:24:49 <msieradzki> versions and hashes specified by "depends on broken packages" refer to packages from installer package in --global
09:25:02 <dmwit> No, that's not supposed to happen.
09:25:33 <msieradzki> is there anything else that I can do to check what exactly is broken?
09:25:40 <msieradzki> not just which packages but why it says they are
09:25:43 <dmwit> Try adding --constraint "process installed" and --constraint "directory installed" after rolling back to the versions that come with GHC and before trying to install hoogle again and see what happens.
09:25:56 <dmwit> msieradzki: ghc-pkg check will give more detailed information.
09:26:20 <msieradzki> .haddock something doesn't exist
09:26:24 <msieradzki> does it count as broken?
09:26:26 <dmwit> msieradzki: And then, sadly, you should get used to checking cabal install --dry-run before doing a real install and check that none of the packages that come with GHC are going to be reinstalled.
09:27:03 <msieradzki> dmwit, why? I kind of had some problems before with such things but what exactly is the reason for it
09:27:16 <dmwit> Can you make the question more specific?
09:27:20 <dmwit> Why what?
09:27:22 <msieradzki> that it tries to reinstall packages that require reinstalling of packages that are base GHC and can't be reinstalled from cabal-install
09:27:37 <msieradzki> why should I dry run and check if ghc isn't being reinstalled
09:27:54 <msieradzki> like Cabal or basic packages bundled with system package db
09:27:59 <dmwit> Because cabal-install attempts not to be GHC-specific, and with other compilers, who knows, that might work.
09:28:23 <dmwit> I'm sure a patch with a list of packages that come with GHC and shouldn't be upgraded that prints a warning or something wouldn't be rejected, if you want to try hacking on cabal-install.
09:30:29 <msieradzki> dmwit what should I do if somehow dry run tells me it'll reinstall something basic?
09:30:43 <msieradzki> hmm 1 sec I'll remove user package db and check dry run
09:30:47 <dmwit> Don't install it.
09:31:01 <dmwit> Ask for more details about why it's going to try to reinstall something basic.
09:31:14 <dmwit> Then try relaxing the dependencies in the packages that are forcing a reinstall.
09:31:19 <dmwit> If it works, then you're good to go.
09:31:29 <dmwit> If it doesn't hack the package that doesn't work and send a patch to the maintainer.
09:33:16 <dmwit> (The way to ask for more details is to add a constraint that conflicts with the chosen installation plan. It will likely give you an error saying why that constraint can't be satisfied.)
09:33:29 <zhulikas> @hoogle [a] -> a -> Bool
09:33:30 <lambdabot> Prelude elem :: Eq a => a -> [a] -> Bool
09:33:30 <lambdabot> Data.List elem :: Eq a => a -> [a] -> Bool
09:33:30 <lambdabot> Prelude notElem :: Eq a => a -> [a] -> Bool
09:37:10 <zhulikas> how can I sort a [DataType] by some property of DataType?
09:37:15 <zhulikas> let's say it has TimeOfDay
09:37:17 <zhulikas> and I want to sort by that
09:37:21 <dmwit> :t sortBy
09:37:22 <lambdabot> forall a. (a -> a -> Ordering) -> [a] -> [a]
09:37:32 <zhulikas> well, ordering
09:37:33 <dmwit> :t sortBy . comparing
09:37:34 <lambdabot> forall a a1. (Ord a1) => (a -> a1) -> [a] -> [a]
09:38:19 <zhulikas> @hoogle comparing
09:38:19 <lambdabot> Data.Ord comparing :: Ord a => (b -> a) -> b -> b -> Ordering
09:38:44 <msieradzki_> dmwit, I've got to say some packages would be easier to update if they had been on github and not on some weird darcs :)
09:38:47 <msieradzki_> like hoogle :)
09:39:14 <dmwit> So... darcs is weird but git is normal?
09:39:22 <dmwit> Funny, considering darcs significantly predates git.
09:40:09 <linduxed> predating does not exclude weirdness
09:40:10 <msieradzki_> github
09:40:15 <Enigmagic> haskell predates java
09:40:19 <alpounet> github /= git
09:40:22 <msieradzki_> it's not about VCS but about easy of pull request
09:40:26 <msieradzki_> ease*
09:40:44 <dmwit> git push and then navigating a website is easier than darcs send?
09:41:12 <msieradzki_> by a lot
09:41:16 <dmwit> wut
09:41:21 <msieradzki_> for a newbie that is
09:41:30 <dmwit> double wut
09:42:18 <msieradzki_> as far as I remember packages with git/github tend to get updated often when it comes to silly things like Cabal < 1.13 and such
09:42:22 <dmwit> This makes no sense to me. Learning a command *and* a website seems like strictly more work than learning a command.
09:42:32 <msieradzki_> while some of darcs only ones wait like a month or more
09:42:55 <dmwit> Now that is a significantly different claim than the one you started with.
09:43:02 <Enigmagic> dmwit: accepting pull requests on github doesn't involve any commands (most of the time)
09:43:06 <Enigmagic> you just click 'ok'
09:43:10 <dmwit> I can't speak to the correlation between revision control system and update frequency.
09:43:38 <dmwit> Enigmagic: msieradzki_ doesn't seem to be talking about being on the receiving end of a patch
09:44:22 <Enigmagic> alright
09:45:03 * dmwit shrugs
09:45:18 <dmwit> I didn't mean to make this an "us vs. them" thing anyway. I think github is great. I think darcs is great, too.
09:45:54 <dmwit> I just don't like seeing such vague criticisms as "weird". =P
09:49:42 <msieradzki_> dmwit, it's not vague at all you can replace it with "1% of newcomers to haskell know it" vs 90% of familiarity of git(hub)
09:50:44 <bill```> maybe esoteric is a better word than "weird"
09:50:51 <dmwit> Yeah, or "unpopular".
09:50:58 <bill```> relatively esoteric :)
09:51:05 <dmwit> I've never considered popularity to be a technical merit, or else I wouldn't have learned Haskell.
09:51:28 <Clint> i only learned haskell because it's popular
09:51:38 <msieradzki_> it's practical merit, if you're learning all these new things and have issues with them you want at least SOME of your tools to be stable andknown, nothing special about that
09:51:41 <parcs`> dmwit: you would have learned haskell about now, then
09:51:52 <msieradzki_> it's not that I want to learn darcs just to get my haskell packages installed
09:51:54 <msieradzki_> I really don't care
09:51:55 <dmwit> parcs`: heh
09:52:17 <dmwit> msieradzki_: If you're entering the Haskell community, you will need to learn darcs.
09:52:40 <msieradzki_> over my dead body ;)
09:52:40 <gentleben> you should seldom need darcs
09:52:46 <Enigmagic> dmwit: really? i never learned darcs
09:52:49 <gentleben> i may have used it once
09:52:57 <bill```> that has not been my experience either
09:53:15 <Clint> i definitely have been forced to use darcs more than i'd like
09:53:17 <alpounet> well, darcs' basics are pretty simple anyway
09:53:22 <dmwit> For a counterpoint, I use darcs every day.
09:53:30 <parcs`> i like darcs better than git
09:53:43 <parcs`> aside from the performance problems that i will never encounter
09:53:49 <gentleben> dmwit: that seems like a choice
09:53:52 <msieradzki_> I'm not talking about technical merit or any of these just to say that flamewar isn't really needed
09:54:12 <dmwit> gentleben: No, it's a function of whether you hack on the things you use, and whether the things you use use darcs.
09:54:29 <dmwit> The things I use happen to use darcs. Perhaps the things you use don't.
09:54:29 <gentleben> msieradzki_: don't bother, cabal + git mirrors are fine for most things
09:54:51 <dmwit> gentleben: Wait, you mean you hack on the things you use and don't contribute those hacks back to the community?
09:54:59 <Dodek> hey, i have a typeclasses Foo and Bar and want to make every instance of Bar also to be an instance of Foo
09:55:02 <Dodek> how do i do it?
09:55:06 <dmwit> In that case, you haven't entered the Haskell community, so the "you will need to learn darcs" clause of course doesn't apply to you.
09:55:15 <dmwit> If false then unicorns exist.
09:55:17 <Clint> you don't need to use darcs to send patches
09:55:27 <gentleben> dmwit: I don't contribute fixes back to anything that has used darcs
09:55:35 <dmwit> gentleben--
09:55:36 <gentleben> everything has used github
09:55:38 * hackagebot git-annex 3.20120227 - manage files with git, without checking their contents into git  http://hackage.haskell.org/package/git-annex-3.20120227 (JoeyHess)
09:56:04 <dmwit> Dodek: class Foo a => Bar a
09:57:16 <Dodek> dmwit: this is not what i mean. i have a typeclass Foo, and I noticed that for every type that is an instance of Bar, you can also make it an instance of Foo
09:57:23 <newbie12333> can anyone tell me an equivalent to composite + decorator pattern [adding new functions] on haskell work?
09:58:00 <dmwit> Dodek: You "can't" do that.
09:58:03 <Dodek> dmwit: so it would rather be something like instance Bar a => Foo a where ..., but it does not work
09:58:04 <newbie12333> my understanding is that you just add the functions and haskell does not provide a dynamic extendability like OOP does
09:58:19 <dmwit> Dodek: (I put the "can't" in quotes, because you can do it with a lot of extensions, but it isn't useful and it isn't recommended.)
09:58:20 <parcs`> Dodek: there is no way to do that is haskell land. there is a way to do that in haskell + ghc extensions land, though
09:58:38 <Dodek> oh, ok.
09:58:47 <dmwit> Dodek: One thing I have seen done sometimes is like this:
09:59:00 <Dodek> i don't think that assignment lets me use ghc extensions, so i'll stick with vanilla haskell
09:59:16 <parcs`> you can create a newtype BarWrapper a = BarWrapper a and instance Bar a => Foo (BarWrapper a) where...
09:59:29 <mike-burns> newbie12333: I don't recommend translating OO design patterns until you understand the functional ones first.
09:59:42 <mike-burns> They DO translate, but it's not useful to know how until you understand more.
09:59:45 <dmwit> Dodek: If the Foo typeclass includes foo :: a -> Int, then you can define defaultFooImplementationGivenBar :: Bar a => a -> Int, and the instance Foo Bleh where foo = defaultFooImplementationGivenBar
10:00:30 <newbie12333> mike-burns: so lets say today i have 2 kind of variants -> data Animal = Cow
10:00:32 <newbie12333> and Dog
10:00:40 <mike-burns> newbie12333: I bet you want sum types.
10:00:42 <newbie12333> and if i want to write a function called eat
10:00:49 <newbie12333> i just write a function eat.
10:00:56 <dmwit> data Animal = Cow | Dog
10:01:10 <newbie12333> but later, if i want to write a function called sleep...
10:01:22 <newbie12333> i just go and write a function called sleep, correct?
10:01:24 <mike-burns> Right.
10:01:45 <rwbarton> The problem that the pattern you're talking about is designed to solve does not exist in Haskell.
10:01:56 <zhulikas> what would be the right way to try some computation and if it succeeds, return Just result, otherwise return Nothing?
10:01:59 <zhulikas> how to handle the error?
10:02:06 <rwbarton> (which is not to say that Haskell doesn't have some corresponding problem in some other area.)
10:02:11 <parcs`> what is success? what is a computation?
10:02:32 <newbie12333> but, lets say that both animals in my structure sleep the same way... but they dont eat the same way. how do i go about making this dynamic?
10:02:44 <newbie12333> eatCow and eatDog?
10:02:44 <zhulikas> parcs`, I am reading the time from a string and sometimes I have "" instead of an actual value
10:02:47 <newbie12333> 2 functions?
10:02:48 <zhulikas> so it throws an error
10:03:07 <rwbarton> sleep x = print "sleeping"
10:03:20 <rwbarton> eat Cow = print "eat some grass"; eat Dog = print "eat some dog food"
10:03:24 <rwbarton> no dynamic anything
10:03:29 <newbie12333> k
10:04:10 <Saizan> zhulikas: use reads instead of read
10:04:25 <newbie12333> thanks.
10:04:30 <newbie12333> that clears it up.
10:04:58 <newbie12333> how about this though. lets say I have a data Animal = Cow | Dog
10:05:16 <newbie12333> do i just add it to the structure?
10:05:48 <newbie12333> like adding a new variant later to an already existing structure?
10:05:54 <dmwit> What is "it"?
10:06:00 <zhulikas> > it
10:06:01 <lambdabot>   Not in scope: `it'
10:06:03 <rwbarton> did you accidentally part of your question?
10:07:46 <zhulikas> Saizan, actually parseTime handles errors with Maybe
10:08:22 <Tesseraction> newbie12333: well you can do case a of
10:08:47 <Tesseraction> so case a of   Cow = "eat grass"   Dog = "eat meat"
10:09:06 <Tesseraction> uh
10:09:10 <Tesseraction> sorry not =
10:09:11 <Tesseraction> ->
10:09:17 <Tesseraction> Cow -> "eat grass"
10:09:35 <zhulikas> @hoogle [a] -> IO ()
10:09:36 <lambdabot> Control.Concurrent.Chan writeList2Chan :: Chan a -> [a] -> IO ()
10:09:36 <lambdabot> Test.HUnit.Base listAssert :: ListAssertable t => [t] -> Assertion
10:09:36 <lambdabot> Graphics.Rendering.OpenGL.GL.Framebuffer clear :: [ClearBuffer] -> IO ()
10:09:49 <newbie12333> to add new function, we can do pattern matching too though
10:12:24 <Tesseraction> newbie12333: ?
10:12:51 <dmwit> newbie12333: Perhaps you had better try to write a program and report back when that fails, instead of postulating what might go wrong.
10:12:59 <alpounet> zhulikas, what would such a function do ?
10:13:19 <zhulikas> ahh, nothing
10:13:23 <zhulikas> mapM_ print
10:13:24 <zhulikas> :)
10:13:38 <alpounet> then it'd be Show a => [a] -> IO ()
10:13:40 <dmwit> I can't believe how often I use mapM_ print instead of print.
10:13:42 <alpounet> :p
10:13:44 <dmwit> There really should be a name for it.
10:14:12 <Rishi_> Hi
10:14:16 <Tesseraction> "convenient print"
10:14:19 <quintessence> print'em?
10:14:24 <Entroacceptor> printM
10:14:29 <tromp__> mapM_print, obviously:)
10:14:33 <Rishi_> printM
10:14:37 <alpounet> printM_, then
10:14:41 <Rishi_> root
10:14:46 <Entroacceptor> dwim
10:14:48 <Rishi_> shasd
10:14:55 <zero_> is there anyway to make a fun :: String -> [String] and perform some IO inside at the same time?
10:15:01 <dmwit> zero_: No.
10:15:12 <tromp__> only by cheating
10:15:14 <Entroacceptor> zero_: yes, but you don't want to do that
10:15:19 <dmwit> zero_: (Yes, but you should not unless you can prove it can be done without IO.)
10:15:33 <Tesseraction> death to IO
10:15:48 * Tesseraction smashes monitor and keyboard
10:15:56 <dmwit> In other words, you should first write it without doing any IO inside. If that works, and the algorithm to do it would be more efficient if you allowed yourself to do some IO, then we will tell you how to take the next step.
10:16:05 <tromp__> but why do you want fun to launch missiles:-?
10:16:36 <dmwit> If it doesn't work, then we will not tell you how to do it. =)
10:17:06 <zero_> Ok, ill explain my situation in detail then, im trying to write a program that can get the path between 2 websites by exploring the links
10:17:23 <zero_> i already created a tree and an exploration algorithm that works (for integers)
10:17:29 <zero_> given a function that expands each node
10:17:47 <zero_> but this function, in this case, needs to perfom io (look for links of the website)
10:17:52 <dmwit> NO.
10:18:00 <dmwit> You cannot erase the IO from that operation.
10:18:19 <alpounet> it would be absurd to erase the IO here
10:18:30 <mike-burns> You need IO to look for links?
10:18:31 <tromp__> heresy!
10:18:34 <dmwit> You will need to adjust the algorithm that expands the tree, or do the entire website crawling process up front.
10:18:43 <alpounet> you can separate some of the logic from the IO part
10:18:56 <alpounet> and have it operate on Strings or w/e
10:19:00 <alpounet> and then call it in the IO part
10:19:14 <alpounet> but taking the whole thing out of IO, no, doesn't make sense
10:19:23 <newbie12333> Functional programming does not provide that kind of extendability - > For instance, if we define data Shapes = Rectangle | Circle etc. New functions can be added one by one. Additionally, even for the same hierarchal structure, we might have to add 2 different functions for doing the same ask if they are not compatible. Alternatively, on a function level (size, depth function), pattern matching can be used whi
10:19:29 <mike-burns> main needs to be IO.
10:19:42 <mike-burns> newbie12333: Either summarize or link.
10:19:43 <quintessence> zero_: if you want to interleave the website-visiting with the graph search, you need to have your algorithm accept a String -> IO [String] instead, and therefore its return type will be in IO
10:19:51 <newbie12333> k
10:20:20 <zhulikas> @hoogle [Char] -> Int
10:20:20 <lambdabot> Test.HUnit.Base Label :: String -> Node
10:20:21 <lambdabot> Prelude error :: [Char] -> a
10:20:21 <lambdabot> Prelude length :: [a] -> Int
10:20:24 <ChristianS> newbie12333: can you define a typeclass if you want extendability.
10:20:24 <quintessence> newbie12333: it sounds like you're talking about the expression problem.  </clippy>
10:20:30 <zhulikas> @hoogle digitToInt
10:20:30 <lambdabot> Data.Char digitToInt :: Char -> Int
10:20:56 <zero_> ohhh ok... yeah I think I'll do that then, my graph searching algorithm does not accept IO nodes
10:21:31 <zero_> ill have to change it then
10:21:35 <zero_> thank you!
10:21:40 <quintessence> zero_: you can make it over an arbitrary Monad m if it's pure right now, it doesn't have to be specific to IO
10:28:50 <laufer> @pl \(x, y) -> (x, y + 1)
10:28:50 <lambdabot> second (1 +)
10:29:18 <mike-burns> :t second
10:29:19 <lambdabot> forall (a :: * -> * -> *) b c d. (Arrow a) => a b c -> a (d, b) (d, c)
10:29:45 <fryguybob> ls
10:30:05 <xplat> :t asTypeIn
10:30:05 <lambdabot> forall a b. a -> (a -> b) -> a
10:30:44 <xplat> > second `asTypeIn` (\second -> second (1 +))
10:30:44 <lambdabot>   Overlapping instances for GHC.Show.Show
10:30:45 <lambdabot>                              ((c ->...
10:30:50 <xplat> :t second `asTypeIn` (\second -> second (1 +))
10:30:50 <lambdabot> forall c d. (Num c) => (c -> c) -> (d, c) -> (d, c)
10:33:01 <zhulikas> @hoogle try
10:33:01 <lambdabot> Control.OldException try :: IO a -> IO (Either Exception a)
10:33:01 <lambdabot> System.IO.Error try :: IO a -> IO (Either IOError a)
10:33:01 <lambdabot> Control.Exception.Base try :: Exception e => IO a -> IO (Either e a)
10:33:35 <hpaste> zhulikas pasted “not entirely error-proof” at http://hpaste.org/64457
10:33:50 <zhulikas> sometimes it still fails to read
10:35:21 <MagneticDuck> use reads
10:35:28 <MagneticDuck> > :t reads
10:35:28 <lambdabot>   <no location info>: parse error on input `:'
10:35:38 <MagneticDuck> > @t reads
10:35:39 <lambdabot>   <no location info>: parse error on input `@'
10:36:00 <MagneticDuck> Wait, how do I get lambdabot to return the type?
10:36:24 <zhulikas> @type reads
10:36:24 <lambdabot> forall a. (Read a) => String -> [(a, String)]
10:36:32 <MagneticDuck> Ah, that's better.
10:36:45 <zhulikas> @hoogle reads
10:36:46 <lambdabot> Prelude type ReadS a = String -> [(a, String)]
10:36:46 <lambdabot> Text.ParserCombinators.ReadP type ReadS a = String -> [(a, String)]
10:36:46 <lambdabot> Text.Read type ReadS a = String -> [(a, String)]
10:36:55 <zhulikas> hmm
10:36:58 <zhulikas> which one it is
10:37:20 <MagneticDuck> Yeah, it will return nothing if the read fails, and a tuple with the read value and the string that it didn't use.
10:37:30 <MagneticDuck> And the first one it.
10:37:42 <MagneticDuck> *type* the first definition is.
10:37:49 <zhulikas> so...
10:38:04 <zhulikas> reads "000000" :: Int
10:38:07 <zhulikas> does not work
10:38:30 <zhulikas> ok
10:38:37 <zhulikas> reads "000000" :: [(Int, String)]
10:38:45 <MagneticDuck> Yeah, that's right.
10:41:49 <hydo> Is there a clever solution to the problem with regard to generics where, in my instance, I'm parsing json with aeson that has elements with generic names, yet all of my types need to be something like data thing = thing { thing_name :: ..} instead of data thing = thing { name :: .. } because I'll inevitably have name clashes?
10:42:03 <hydo> ugh, tried to be succinct, should have made it a paste/gist.
10:42:27 <hydo> well, I guess it's not so bad.
10:42:40 <strager> I think the only "clean" way is to put the data definition into its own module.
10:42:49 <hpaste> MagneticDuck pasted “Entirely error-proof” at http://hpaste.org/64458
10:43:09 <hydo> strager: ok, that was going to be my fallback.  nice to see I wasn't too far off track. :)
10:44:00 <MaybeJust> i cant install gtk
10:44:03 <strager> MagneticDuck: The value of Just $ read chars :: [(Int,String)]
10:44:13 <MaybeJust> i used to have Graphics.GUI.gtk working on another computer
10:44:19 <MaybeJust> isnt that nstall avilable anymore?
10:44:28 * hydo raises a single eyebrow at 'entirely error-proof', and usually anything having to do with tech that includes 'always' or 'never' in the description.
10:44:32 <strager> MagneticDuck: You want Just . fst . head $ read chars
10:44:48 <MagneticDuck> No, you're confusing it with reads
10:44:55 <strager> oh, sorry
10:45:03 <strager> So why the paste?  =]
10:45:40 <Enigmagic> hydo: deriveJSON takes a function that is used to rename fields
10:46:03 <hpaste> MagneticDuck pasted “ARRRRGHH! where statement parse error” at http://hpaste.org/64459
10:46:19 <MagneticDuck> I'm having some trouble with my code that I just posted.
10:46:28 <hydo> Enigmagic: whoa... really?  Looking... crap, I don't doubt you, I'm just aggravated at myself that I didn't research it completely before asking.
10:46:42 <quintessence> MagneticDuck: where goes on whole definitions, not expressions
10:46:44 <strager> What's the parse error, MagneticDuck?
10:46:49 <MagneticDuck> It gives me the error on compile: "parse error on input 'where'
10:46:58 <MagneticDuck> And it happens on the where statement.
10:47:07 <quintessence> you can put it on the top (outside the if) or you can use let inside
10:47:19 <strager> It's as quintessence said; put the where clause on the definition of calcRPN
10:47:24 <Enigmagic> hydo: yep.. in prior versions it wasn't really well documented (circa 0.3 or 0.4) but it seems like it is now
10:47:25 <MagneticDuck> Okay, I'm confusing this with mathematica's "module" again!
10:47:38 <MagneticDuck> Okay, I'll do that.
10:49:38 <MagneticDuck> Thanks, worked! Working with another annoying error though now... :P
10:55:27 <hydo> Enigmagic: Thanks a lot for your help.
10:57:20 <Enigmagic> hydo: np
10:59:14 <hydo> Now if only generics supported some sort of facility for record field names...
11:00:00 <hydo> I need to keep levelling up in haskell so I can add, or at least better reason about, these sorts of problems.
11:05:11 <rostayob> is UHC being actively developed? The last version is dated 2010
11:05:22 <MagneticDuck> BTW, I have to go. I promised jay_gridley to email him some code the other day, but I missed his email. If he comes online, tell him that I posted the code on hPaste under a post names "FindNReplace". Thanks!
11:05:42 <dmwit> MagneticDuck: ?tell him yourself!
11:05:57 <MagneticDuck> He's not online, and I don't have his email. As I said, I have to go.
11:06:01 <dmwit> ?help tell
11:06:01 <lambdabot> tell <nick> <message>. When <nick> shows activity, tell them <message>.
11:06:10 <clintm> :)
11:06:15 <dmwit> MagneticDuck: The question mark in my message to you was not a typo. =)
11:06:18 <MagneticDuck> how do I do that?
11:06:27 <dmwit> ?tell MagneticDuck how to use ?tell
11:06:27 <lambdabot> Consider it noted.
11:06:35 <dmwit> MagneticDuck: Now say something.
11:06:53 <newbie123331387> ?
11:06:55 <clintm> heh
11:07:03 <MagneticDuck> Hey jay_gridley, the code is posted on hpaste, under a post named FindNReplace.
11:07:03 <lambdabot> MagneticDuck: You have 1 new message. '/msg lambdabot @messages' to read it.
11:07:13 * dmwit facepalms
11:07:26 <clintm> high definition facepalm action
11:07:40 <hpaste> newbie1212 pasted “Time Travelled” at http://hpaste.org/64460
11:07:49 <MagneticDuck> Okay, I really need to go. Could somebody do it for me? Thanks. Got to run!
11:08:46 <ChristianS> hm, some people are slow learners, it seems...
11:09:05 <MagneticDuck> Sorry! I really have to go now...
11:09:06 <newbie12333> can someone please explain me the use of the above functions in order to calculate the distance travelled?
11:09:26 <clintm> or maybe not used to irc or bots?  seems like an out of place thing to not get for a haskell programmer.  Though I didn't see his paste.
11:09:53 <newbie12333> are you referring to me, clintm?
11:10:00 <dmwit> newbie12333: no
11:10:06 <clintm> newbie12333: naw, MagneticDuck
11:10:10 <dmwit> newbie12333: Is the ':' in your paste supposed to be a '>'?
11:10:11 <newbie12333> if so, i am not a haskell programmer. i am a newbie :P
11:10:26 <dmwit> newbie12333: Also, nothing in that paste looks like a distance to me, so you'll have to be more specific about what you want to calculate.
11:10:55 <clintm> newbie12333: imo, haskell == chess, so I'm a newbie as well. :)
11:11:14 <newbie12333> yes sir, its supposd to be ->
11:11:57 <enquora> anyone aware of anything attempting html -> pdf without using external programs/code - such as latex?
11:12:33 <dmwit> "without using external programs/code"?
11:12:36 <ChristianS> enquora: hmm, there's pandoc, but pandoc does invoke latex...
11:12:47 <enquora> pandoc uses latex
11:12:52 <dmwit> What could you possibly hope to do without using code?
11:13:02 <enquora> external code
11:13:10 <dmwit> What does "external" mean?
11:13:21 <clintm> external programs?
11:13:23 <enquora> invoking latex/context
11:13:25 <enquora> yes
11:13:31 <newbie12333> basically, i am trying to claculate how many feet it would take from go from point a to point b
11:13:34 <vodik> enquora: open up firefox, print to pdf
11:13:34 <zerax> What is the basis of your requirement to not use external tools?
11:13:53 <ChristianS> enquora: you would have to look whether there is a pdf writer written in haskell (I'm not aware of one)
11:13:58 <newbie12333> i am having problems understanding those para s
11:13:59 <enquora> been doing it for years, and it isn't reliable enough
11:14:04 <vodik> i think he means he wants to convert from html->pdf, while pandoc would do html->tex->pdf
11:14:08 <enquora> and it's a pita to deploy
11:14:18 <enquora> vodik: yep
11:14:31 <clintm> enquora: I know of nothing that will do that - I had to come up with something quite a while ago, but my solution was pretty bad and somewhat team-specific.  I'd love to hear if you find any sort of native solution.
11:14:34 <vodik> enquora: google pdf webkit rendering
11:14:46 <enquora> vodik: that's what we're using now
11:15:07 <vodik> enquora: mkpdf?
11:15:17 <enquora> wkhtmltopdf
11:15:24 <enquora> unfamiliar with mkpdf
11:15:32 <enquora> will google that, thks
11:15:36 <alpounet> really, we don't have a library for writing to PDFs ?
11:15:50 * clintm looks at shakakai ...
11:15:53 <enquora> alpounet: writing to PDFs isn't the problem
11:16:10 <enquora> It's doing expressive typesetting using HTML layout semantics
11:16:26 <vodik> enquora: as far as i know, mkhtmltopdf is the only rendering engine -> pdf system
11:16:50 <enquora> vodik: will take a look.
11:16:55 <stulli> newbie12333: Ist the -: a typo?
11:16:56 <lambdabot> stulli: You have 1 new message. '/msg lambdabot @messages' to read it.
11:18:01 <enquora> vodik: can't find mkhtmltopdf. is it different in any significant way from the wkhmtltopdf app?
11:18:22 <vodik> sorry, typo on my part
11:18:58 <DanBurton> at first glance, mkhtmltopdf looks like a nonsensical jumble of letters
11:19:05 <BobHorner> ..
11:19:27 <DanBurton> camel casing would help: mkHtmlToPdf
11:20:43 <enquora> alpounet: to clarify, the problem here isn't writing to a PDF structure, it's typesetting. That's a very different problem.
11:21:15 <ChristianS> enquora: there is nothing that equals latex for typesetting, i'm afraid to say
11:21:26 <enquora> I know ;-(
11:21:36 <alpounet> oh, ok
11:21:43 <clintm> I think I'm the last holdout that finds mk_html_to_pdf easier on the eyes/brain.
11:22:07 <dmwit> html2pdf
11:22:22 <dmwit> in the honored tradition of ps2pdf and friends
11:22:35 <ClaudiusMaximus> epub is based on xhtml/css2 iirc, so maybe epub->pdf tools could be used
11:22:37 <enquora> need support for CSS 3, especially flexible box layout.
11:22:50 <quintessence> if this were #ocaml it would be pdf_of_html
11:23:24 <enquora> quintessence: thks. I'll switch tongues if it works ;-)
11:23:40 <alpounet> hah
11:24:44 <MaybeJust> i used to have Graphics.GUI.gtk working on another computer
11:24:45 <MaybeJust> isnt that nstall avilable anymore?
11:24:58 <dmwit> cabal install gtk
11:25:00 <enquora> quintessence: Google doesn't know this language or library, apparently. Must be a very obscure language ;-)
11:25:27 <dmwit> MaybeJust: You will have to cabal install gtk2hs-buildtools first, though.
11:25:54 <dmwit> MaybeJust: If you are on Windows, there are installation instructions on the gtk2hs website.
11:26:21 <quintessence> enquora: I was just late to the mkhtmltopdf name golf game, not suggesting something actually useful sorry =/
11:26:31 <enquora> ah
11:26:34 <t7> rostayob: you are fighting a losing battle on reddit ;p
11:26:41 <newbie12333> dmwit: basically using para, Ext and toInt, I am trying to calculate how many feet it takes to start at a base, climb down, then to one foot below the top, and then down agsain  m and then to two feet below the top. :P
11:27:18 <enquora> The only thing I know of that really does the job is PrinceXML. :-(
11:27:31 <rostayob> t7: it's not over
11:27:45 <enquora> and it doesn't handle CSS flexible box layout
11:28:05 <MaybeJust> whata bout windows 64bit?
11:28:15 <dmwit> newbie12333: None of these explanations have helped me at all, again, because none of the code you posted screams "distance" or "feet" to me.
11:28:46 <ChristianS> ?tell jay_gridley MagneticDuck tells you that he posted the code on hpaste under a post names "FindNReplace".
11:28:46 <lambdabot> Consider it noted.
11:28:49 <t7> to be fair, haskell syntax does look pretty 'out there' to someone who has never used it
11:28:50 <dmwit> newbie12333: Can you try describing how you want to compute a thing, rather than the English name for the thing you want to compute?
11:29:14 <dmwit> ChristianS: That's very kind of you. I was about to ?tell MagneticDuck to learn ?tell when he got back. =P
11:29:33 <monochrom> haha
11:30:04 <ChristianS> dmwit: nobody is stopping you ;-) the other question is whether he will actually get your message...
11:30:21 <hpaste> MaybeJust pasted “gtk - failed install” at http://hpaste.org/64461
11:30:39 <newbie12333> dmwit: I want to calculate distance travelled. lets say we have a pole of a certain height (10 feet)
11:31:03 <dmwit> MaybeJust: Did the earlier packages successfully install? What version of the GTK bundle did you use?
11:31:50 <dmwit> MaybeJust: (Nothing about this error looks 64-bit specific to me.)
11:31:58 <newbie12333> dmwit: so i want to calculate 10 (climb to the top) + climb to the bottom (10) + one foot below the top (9) + down again (9) + two feet below the top (8) + down again 8
11:32:07 <MaybeJust> pkg-config no such package on cabal
11:32:21 <dmwit> MaybeJust: No, pkg-config is not a Haskell program.
11:32:27 <dmwit> MaybeJust: It should be included in your GTK bundle.
11:32:44 <dmwit> MaybeJust: (Part of the instructions include adding gtk's \bin directory to your PATH; did you do that?)
11:34:33 <quintessence> newbie12333: the datatype you have has members like Base, Ext Base, Ext (Ext Base), ...
11:34:52 <quintessence> newbie12333: and I take it you want a function of type Pole -> Int?
11:36:35 <MaybeJust> ¨where is pkg on windows?
11:37:09 <KLaufer> newbie12333 is asking a good question
11:38:08 <dmwit> MaybeJust: It's very difficult to help you if you ignore all the debugging questions people ask you.
11:39:16 <KLaufer> i know its you
11:39:17 <johnbender> is anyone familiar with category theory willing to review a gist for me?
11:39:22 <MaybeJust> i didnt app pkg to my path ebcause i dont know where it is.
11:39:37 <dmwit> MaybeJust: Where did you unpack your GTK bundle?
11:39:40 <johnbender> https://gist.github.com/7242a7434195565b4a9d
11:40:01 <johnbender> comments are welcome at the bottom and in a private message
11:40:08 <MaybeJust> when i tried to install gtk it complained about glib then i tried that and it wants pkg-config
11:40:12 <johnbender> and/or
11:40:13 <MaybeJust> I auotinstalled haskell
11:40:26 <MaybeJust> it is in C:\Program Files (x86)\haskellblah
11:40:40 <dmwit> MaybeJust: The first step, before installing the gtk2hs Haskell bindings to GTK, is to install the GTK library.
11:40:58 <dmwit> Did you do this?
11:42:02 <newbie12333> hmm, thanks, that will help me get started. i just didnt get what the fxn was doing.
11:44:28 <dmwit> MaybeJust: If not, try grabbing the 2.22 all-in-one bundle from http://www.gtk.org/download/win64.php
11:44:56 <dmwit> MaybeJust: Further instructions are inside the zip and at http://code.haskell.org/gtk2hs/INSTALL (you need the instructions from *both* places).
11:46:09 <dmwit> MaybeJust: I have to go, but ?tell me how things go.
11:50:50 <stulli> newbie12333: You need to understand partial application to understand para.
11:52:09 <stulli> Or doesn't he? Now i'm confused...
11:52:15 <stulli> newbie12333: Better not listen to me :)
11:53:14 <jay7557> Hi all !
11:53:23 <jay7557> Help please!
11:53:47 <jay7557> I am trying to create function which gets two inputs which are strings
11:53:56 <jay7557> one is text and the other is key
11:54:14 <t7> go on :)
11:54:29 <jay7557> and want to encrypt every single character to its bit equivalent
11:54:55 <jay7557> if i make function called.. scramble :: String -> String -> String
11:55:09 <jay7557> scramble text key =
11:55:18 <jay7557> so if i enter
11:55:31 <jay7557> scramble "qwerty" "abc123"
11:55:48 <jay7557> it would convert it to bit equivalent
11:56:05 <jay7557> and encrypt the string
11:56:30 <jedai> encrypt how ? xor ?
11:56:35 <jay7557> ye
11:56:38 <jay7557> xor
11:56:52 <mauke> > 'q' `xor` 'a'
11:56:53 <lambdabot>   No instance for (Data.Bits.Bits GHC.Types.Char)
11:56:53 <lambdabot>    arising from a use of `D...
11:56:59 <jedai> What if the key isn't the same length as the text, do we cycle it ?
11:57:05 <quintessence> jay7557: zipWith, Data.Char.ord, Data.Char.chr, and Data.Bits.xor are some functions you'll want to look at
11:57:06 <jay7557> ye
11:57:08 <mauke> > chr (ord 'q' `xor` ord 'a')
11:57:09 <lambdabot>   '\DLE'
11:57:18 <jay7557> cycle it
11:57:26 <quintessence> > cycle "abc"
11:57:26 <lambdabot>   "abcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcab...
11:57:49 <jay7557> yes
11:57:50 <jedai> jay7557: Ok, then quintessence answer now has all the functions you'll need :)
11:58:30 <jedai> Though you may add "on"
11:58:34 <jedai> @hoogle on
11:58:34 <lambdabot> Data.Function on :: (b -> b -> c) -> (a -> b) -> a -> a -> c
11:58:34 <lambdabot> Control.Exception.Base onException :: IO a -> IO b -> IO a
11:58:34 <lambdabot> Control.Exception onException :: IO a -> IO b -> IO a
11:59:03 <jay7557> I am getting so many error messages
11:59:11 <jay7557> a different everytime
11:59:41 <jay7557> how can i convert string to char
11:59:49 <jay7557> and then xor with key then?
11:59:54 <Palmik> jay7557, check the recommended functions.
12:00:08 <monochrom> wrong question. convert char to a number type.
12:00:18 <jedai> jay7557: String is just a synonym for [Char]
12:00:37 <jay7557> yes a list
12:01:03 <jay7557> is there any library where i can convert that to number
12:01:15 <jedai> jay7557: Read quintessence answer please
12:01:23 <jay7557> ok
12:01:49 <monochrom> why do askers love monologues so much?
12:02:30 <monochrom> as though their goal of asking is to enjoy asking
12:03:17 <Skola> we have a psychologist
12:08:50 <Palmik> Hmm, any ideas for functions that only take few lines to write (with standard libs only) and are good candidates to showcase QuickCheck to relative Haskell newcomers? I would like to use something different from what is in RWH and wiki so that students can use them as complementary material.
12:10:34 <Palmik> I already have few small examples (testing reimplementations of standard functions, sometimes with a twist) and palindrome testing, but I'm sure there are even better examples.
12:11:48 <quintessence> how about Gray codes?
12:11:52 <scooty-puff> does anyone know of any unification algorithms other than the robinson one?
12:13:27 <Palmik> quintessence, hmm, that might be interesting, will think about it. Thanks. :)
12:14:05 <MaybeJust> when getting a maybe value then i shouldnt use case x of Just y but instead use some monadic operations right?
12:14:58 <jay7557> can I use intersperse from Data.List to separate and xor with key ?
12:16:10 <jedai> MaybeJust: Well that depends
12:16:18 <Palmik> MaybeJust, depends what you want to do with the value and in what context. Sometimes case is perfectly OK.
12:16:46 <quintessence> MaybeJust: usually using the maybe function or pattern matching is clearer if you only have one Maybe.  The monadic version only starts to win when you have several operations that return a Maybe and you want to handle all the Nothings the same way.
12:17:09 <jedai> MaybeJust: the Maybe monad is mainly useful to chain computations that can fail without having to handle every call with a case
12:18:01 <jedai> But to be honest, I very rarely write a case just to differentiate between Nothing and Just: I use maybe or fromMaybe
12:18:36 <Palmik> MaybeJust, I think this is rather relevant and nice http://learnyouahaskell.com/a-fistful-of-monads#getting-our-feet-wet-with-maybe
12:18:40 <jedai> The case is only useful if you have to pattern match the inside of Just too
12:19:49 <Palmik> And can be often replaced with maybe.
12:25:42 <MaybeJust> how can i make a doubly inked list? and keep pointer to both head and tail? and can i keep the length in the list as well
12:25:45 * hackagebot imm 0.1.0.0 - RSS-to-maildir tool  http://hackage.haskell.org/package/imm-0.1.0.0 (koral)
12:26:28 <edwardk> MaybeJust: the short answer is you don't want to do that
12:27:06 <edwardk> MaybeJust: you can make a catenable deque that gives you everything you want from that representation and which is purely functional
12:27:45 <jedai> MaybeJust: Maybe you could tell us what you want to do with that double-linked list ?
12:28:01 <edwardk> you can also make a terribly imperative IO based doubly linked list
12:29:44 <jedai> And you can "tie the knot" but then you can't modify your list
12:31:29 <jedai> Or rather, you can but only but you can't share any of the spine, which is _really_ suboptimal...
12:32:40 <Cale> MaybeJust: If you don't know about Data.Sequence and finger trees already, they might interest you :)
12:33:09 <Cale> http://www.soi.city.ac.uk/~ross/papers/FingerTree.html
12:33:19 <Cale> http://hackage.haskell.org/packages/archive/containers/0.4.2.0/doc/html/Data-Sequence.html
12:35:02 <DanBurton> finger trees have a lot of really cool properties
12:36:01 <MaybeJust> can i prevent a function from being exported froma a module?
12:36:23 <Lemmih> MaybeJust: Yes.
12:36:31 <DanBurton> MaybeJust: you'll have to give an explicit export list to the module
12:36:49 <DanBurton> /s/to/in
12:36:50 <MaybeJust> can i calc len of a list with fold?
12:37:06 <DanBurton> you can do anything to lists with fold
12:37:08 <t7> :t fold
12:37:08 <lambdabot> Not in scope: `fold'
12:37:18 <t7> :t foldl
12:37:19 <DanBurton> anything that can be done to a list can be done with a fold
12:37:19 <lambdabot> forall a b. (a -> b -> a) -> a -> [b] -> a
12:37:33 <DanBurton> although it's not always the intuitive way to do it
12:37:38 <t7> > foldl (+ 1) 0 [1..10]
12:37:39 <lambdabot>   Occurs check: cannot construct the infinite type: a = b -> a
12:37:41 <MaybeJust> > foldl (\x,y->x+1) 0 [1..10]
12:37:42 <lambdabot>   <no location info>: parse error on input `,'
12:37:54 <MaybeJust> > foldl (\(x,y) -> x+1) 0 [1..10]
12:37:55 <lambdabot>   Occurs check: cannot construct the infinite type: t = b -> (t, t1)
12:38:13 <DanBurton> > foldl (const (+1)) 0 [1..10]
12:38:13 <lambdabot>   11
12:38:26 <DanBurton> eleven...wait what
12:38:36 <t7> > length [1..10]
12:38:37 <lambdabot>   10
12:39:01 <DanBurton> > foldl (const foo) bar [a,b,c]
12:39:02 <lambdabot>   Not in scope: `foo'Not in scope: `bar'
12:39:07 <MaybeJust> > foldl (\x,y -> x+1) 0 [1..10]
12:39:08 <lambdabot>   <no location info>: parse error on input `,'
12:39:12 <DanBurton> > foldl (const f) z [a,b,c]
12:39:13 <lambdabot>   f c
12:39:15 <dmwit> :t foldl (const (+1))
12:39:16 <lambdabot> forall a. (Num a) => a -> [a] -> a
12:39:20 <MaybeJust> > foldl (const (+1)) (-1) [1..10]
12:39:21 <lambdabot>   11
12:39:28 <MaybeJust> wtf
12:39:31 <DanBurton> oh silly me
12:39:32 <mauke> please stop failing
12:39:35 <dmwit> > foldl (const (+1)) id [5] -- =)
12:39:36 <lambdabot>   Overlapping instances for GHC.Show.Show (a -> a)
12:39:36 <lambdabot>    arising from a use of `...
12:39:45 <DanBurton> lol
12:39:55 <dmwit> -- =(
12:40:00 <MaybeJust> how do i do an anon fun with 2 vars?
12:40:07 <DanBurton> dmwit: needs to be applied to something
12:40:08 <dmwit> MaybeJust: \x y -> ...
12:40:17 <MaybeJust> > (\x,y->x+y) 5 6
12:40:17 <lambdabot>   <no location info>: parse error on input `,'
12:40:19 <DanBurton> > foldl (const (+1)) id [5] 0
12:40:20 <lambdabot>   6
12:40:23 <MaybeJust> > (\x y->x+y) 5 6
12:40:24 <lambdabot>   11
12:40:26 <MaybeJust> ah
12:40:34 <MaybeJust> > foldl (\(x y) -> x+1) 0 [1..10]
12:40:34 <DanBurton> the problem is we are all using foldl
12:40:35 <lambdabot>   <no location info>: Parse error in pattern
12:40:40 <MaybeJust> > foldr (\(x y) -> x+1) 0 [1..10]
12:40:41 <lambdabot>   <no location info>: Parse error in pattern
12:40:44 <DanBurton> > foldr (const (+1)) 0 [1..10]
12:40:45 <lambdabot>   10
12:40:46 <MaybeJust> > foldr (\(x y) -> y+1) 0 [1..10]
12:40:47 <lambdabot>   <no location info>: Parse error in pattern
12:40:52 * DanBurton wins
12:41:08 <mauke> > foldl (\z x -> z + 1) 0 [1 .. 10]
12:41:09 <lambdabot>   10
12:41:25 <mauke> > foldl (\z -> const (z + 1)) 0 [1 .. 10]
12:41:26 <lambdabot>   10
12:41:29 <DanBurton> > foldr (const f) z [a,b,c]
12:41:30 <lambdabot>   f (f (f z))
12:41:33 <mauke> > foldl (\z -> const (succ z)) 0 [1 .. 10]
12:41:34 <lambdabot>   10
12:41:42 <mauke> > foldl (const . succ) 0 [1 .. 10]
12:41:44 <lambdabot>   10
12:42:57 <Skola>  /quit
12:42:58 <MaybeJust> dmwit: ok now i have the bundle, whats next?
12:43:25 <KorriX> hello
12:43:40 <DanBurton> KorriX: hello. MaybeJust: "the bundle"?
12:44:15 <dmwit> MaybeJust: According to the instructions: extract it to a path that doesn't have spaces, then follow the instructions in the text file to change your system's PATH.
12:44:24 <mightybyte> Does cabal allow multiple package repositories to be used?
12:44:42 <dmwit> DanBurton: He's installing gtk(2hs) on Windows.
12:44:45 <KorriX> if i have data Test = A | B | C, is there any method to map over all of Test value construnctors ?
12:45:13 <dmwit> KorriX: Can you give a few sample input/output pairs of this mapping function?
12:45:37 <dmwit> KorriX: Or did you mean something like "create a list with all the values of Test in it"?
12:45:49 <MaybeJust> dmwit: i have extracted and added to put, what do i need to do in haskell?
12:45:53 <dmwit> KorriX: If the latter, derive Enum and write [A .. C], or derive Enum and Bounded and write [minBound .. maxBound].
12:46:23 <dmwit> MaybeJust: At a command line, does "pkg-config --cflags gtk+-2.0" print a bunch of stuff?
12:46:37 <KorriX> you are genious ! only what i need is derive (Enum, Show) :D
12:46:49 <dmwit> MaybeJust: If so, then the next step is "cabal install gtk2hs-buildtools" followed by "cabal install gtk", I think.
12:47:00 <DanBurton> mightybyte: I think it can support that. Simultaneously...maybe not.
12:47:21 <mightybyte> DanBurton: Yeah, I'm interested in simultaneously.
12:48:04 <dmwit> MaybeJust: You must also add cabal's installation directory to your path.
12:48:15 <DanBurton> from what I've heard...currently no, it can't, but it probably will in the eventual future
12:48:22 <dmwit> MaybeJust: The install instructions at http://code.haskell.org/gtk2hs/INSTALL have more details.
12:48:44 <DanBurton> mightybyte: what's your use case?
12:49:32 <dmwit> MaybeJust: (This is now the third time I have pointed you at those instructions. We wrote those instructions for a reason; please read them.)
12:49:46 <mightybyte> DanBurton: Just generic manaagement of complex projects.
12:50:20 <mightybyte> At the moment my particular motivation is fixing things in other cabal projects that I can't get merged upstream for whatever reason.
12:51:19 <mightybyte> The bottom line is that the Haskell infrastructure is fine for simple projects, but very painful when you start to maintain unreleased versions of multiple interdependent projects.
12:52:50 <DanBurton> u_u
12:53:22 <mightybyte> The key word there is unreleased.
12:53:54 <MaybeJust> i have inlcued the path to gtkbundle/bin/ where pkg-config is but it still doesnt find it
12:54:14 <mightybyte> It's fine for things that get pushed to hackage.  But if you're not ready to push to hackage yet, or if you're developing a number of proprietary libraries that won't get pushed to hackage, then it's quite painful.
12:54:45 <MaybeJust> wait maybe
12:55:19 <t7> i hate the british government
12:55:33 <MaybeJust> yes pkg config clags prints
12:55:39 <t7> im moving to iceland or somewhere where free speech means something
12:55:44 <MaybeJust> but i forgot to restart cmd prompt thats why i think maybe willw ork jow
12:56:58 <MaybeJust> the british government hates you
12:59:38 <MaybeJust> > map (fmap (+1)) [Just 5, Just 6, Nothing]
12:59:39 <lambdabot>   [Just 6,Just 7,Nothing]
12:59:58 <MaybeJust> > fmap (+1) [Just 5, Nothing]
12:59:58 <lambdabot>   No instance for (GHC.Num.Num (Data.Maybe.Maybe t))
12:59:59 <lambdabot>    arising from a use of...
13:00:21 <MaybeJust> > liftM (liftM (+1)) [Just 5, Nothing]
13:00:22 <lambdabot>   [Just 6,Nothing]
13:02:13 <hpaste> MaybeJust pasted “pango” at http://hpaste.org/64463
13:04:32 <dmwit> MaybeJust: Hm, not sure.
13:04:41 <dmwit> I didn't see that when I built gtk2hs over the weekend.
13:04:58 <dmwit> MaybeJust: Is that from "cabal clean" or from some other command?
13:05:18 <MaybeJust> from the install. it is preprocessing gtk now
13:05:27 <dmwit> Okay, seems it wasn't a problem, then. =)
13:10:58 <hpaste> MaybeJust pasted “gtk install” at http://hpaste.org/64464
13:11:06 <MaybeJust> then it just seems to hang there
13:11:40 <dmwit> Does it hang for more than five minutes?
13:11:49 <dmwit> It took about three minutes to preprocess gtk on my machine.
13:16:06 <MaybeJust> lets see, i wait 5min and see
13:21:39 <MaybeJust> Preprocessing library gtk-0.12.2...
13:21:40 <MaybeJust> Failed to remove file dist\build\Graphics\UI\Gtk\Embedding\Embedding_hsc_make.ex
13:21:40 <MaybeJust> e; error= DeleteFile "dist\\build\\Graphics\\UI\\Gtk\\Embedding\\Embedding_hsc_m
13:21:40 <MaybeJust> ake.exe": permission denied (Det går inte att komma åt filen eftersom den
13:21:40 <MaybeJust> används av en annan process.)
13:21:40 <MaybeJust> Failed to remove file dist\build\Graphics\UI\Gtk\Gdk\EventM_hsc_make.exe; error=
13:21:40 <MaybeJust>  DeleteFile "dist\\build\\Graphics\\UI\\Gtk\\Gdk\\EventM_hsc_make.exe": permissi
13:21:41 <MaybeJust> on denied Used by another process
13:21:58 <MaybeJust> any ideas what other process that could be? im just having mirc and chrome up
13:23:32 <DanBurton> sounds like one of those annoying windows admin permissions problems
13:23:46 <DanBurton> possibly
13:25:06 <MaybeJust> where is dist\build?
13:26:39 <MaybeJust> but it says "used by another process"
13:29:30 <dmwit> MaybeJust: Likely, that "other process" is foo.exe itself. Probably what's happening is cabal is trying to run foo.exe, and then delete foo.exe, but the deletion is happening before foo.exe is "finished" exiting.
13:29:43 <dmwit> No idea what would cause that, but it should be fine if there are a few extra such files lying around.
13:38:57 <MaybeJust> i pressed ctrl-c and it went on to compile gtk
13:39:00 <MaybeJust> build
13:39:16 <MaybeJust> 3 out of 207
13:39:28 <MaybeJust> warning pattern matches are overlapped
13:40:59 <dmwit> Yes, the next project (after making a GHC 7.4-compatible release) is cleaning up as many warnings as possible.
13:43:56 * DanBurton wonders what the ETA is for GHC 7.6
13:44:32 * roconnor wonders what the EPSILON is for GHC 7.6
13:44:46 <MaybeJust> it sems hung on 207 out of 207
13:44:51 <dmwit> Given the epsilon for the last few versions, I predict magic.
13:44:52 <DanBurton> roconnor: T_T
13:44:55 <MaybeJust> @lambdabot hold your thumbs
13:44:55 <lambdabot> Unknown command, try @list
13:45:05 <MaybeJust> @list hello
13:45:05 <lambdabot> No module "hello" loaded
13:45:19 <ski> stulli : did it help ?
13:45:21 <MaybeJust> @Data.Map
13:45:21 <lambdabot> Unknown command, try @list
13:45:27 <MaybeJust> @list Data.Map
13:45:28 <lambdabot> No module "Data.Map" loaded
13:45:29 <MaybeJust> @list Data
13:45:30 <lambdabot> No module "Data" loaded
13:45:32 <DanBurton> @list
13:45:32 <lambdabot> http://code.haskell.org/lambdabot/COMMANDS
13:45:59 <MaybeJust> does compiling Graphics.UI.Gtk normally take long?
13:46:04 <ion> roconnor: I see what you did there.
13:46:11 <MaybeJust> oh oh oh wait
13:46:43 * DanBurton proposes we all ditch graphics and stick to ascii. even for games.
13:47:15 <ion> But i *like* my Dungeon Crawl in Unicode. :-(
13:47:31 <hpaste> MaybeJust pasted “cant load dll” at http://hpaste.org/64469
13:47:37 <DanBurton> ok, unicode then :P
13:47:45 <MaybeJust> cant i use it from ghci?
13:48:12 <DanBurton> MaybeJust: do you have the dll it needs?
13:49:00 <dmwit> hm
13:50:23 <MaybeJust> i has libcairo-script-interpreter-2
13:50:45 <MaybeJust> it hangs on Linking Main.exe when I compile
13:51:32 <MaybeJust> it loads in ghc but doesnt run when calling main
13:51:40 <roconnor> DanBurton: All the games written in Coq use ASCII art
13:52:06 <MaybeJust> command prompt is scrolling down at super speed, ghc is doing...something
13:52:18 <DanBurton> games...written in Coq...*brain explodes*
13:52:25 <MaybeJust> Coq. isnt that a proofprogram?
13:52:37 <roconnor> http://coq.inria.fr/V8.2pl1/contribs/Coqoban.html
13:54:13 <DanBurton> Coq is an "interactive theorem prover"
13:54:34 <tromp__> perfect for a theorem proving game
13:54:35 <otk> DanBurton: what game?
13:54:41 <hpaste> MaybeJust pasted “gtk app compile” at http://hpaste.org/64470
13:55:10 <roconnor> otk: sokoban
13:55:23 <otk> ty
13:55:26 <ski> @where CPDT
13:55:26 <lambdabot> "Certified Programming with Dependent Types" by Adam Chlipala (aka Smerdyakov) (in progress) at <http://adam.chlipala.net/cpdt/>, "about practical engineering with the Coq proof assistant"
13:55:33 <otk> http://coq.inria.fr/V8.2pl1/contribs/Coqoban.html for the lazy
13:56:09 <DanBurton> @where sf
13:56:10 <lambdabot> "Software Foundations" by Pierce,Casinghino,Greenberg,Sj�berg,Yorgey in 2011-06 at <http://www.cis.upenn.edu/~bcpierce/sf/> about "the mathematical theory of programming and programming languages",
13:56:10 <lambdabot> "It develops basic concepts of functional programming, logic, operational semantics, lambda-calculus, and static type systems, using the Coq proof assistant."
13:56:38 <otk> i like how coq code looks very ML
13:56:56 <otk> (well, his does)
13:57:04 <otk> http://coq.inria.fr/V8.2pl1/contribs/Coqoban.Coqoban_engine.html
13:57:22 <ion> “using the Haskell-script ksok2coqsok.hs. Sorry, I don't speak Ocaml :-S” What a strange thing to say. “I wrote this in $randomlanguage0. Sorry, I don’t speak $randomlanguage1 :-S”
13:57:41 <MaybeJust> sigh, utter fail
13:58:03 <rampion> i'm trying to find an article I read a while back about using type classes to construct predicates about type level naturals.  Anyone know what I'm talking about?
13:58:10 <dmwit> MaybeJust: Perhaps you need to add --make to your command line?
13:58:16 <dmwit> I thought that was default, but maybe not.
13:58:48 <rampion> simple stuff, like showing two naturals were equal, or one was less than the other
14:00:22 <roconnor> ion: coq users would expect/perfer the script written in OCaml since you need OCaml anyways to compile Coq.
14:00:31 <MaybeJust> when i do import in ghci, it doesnt actually load the module until i use it?
14:00:50 <MaybeJust> dmwit - how?
14:00:52 <monochrom> possibly. shouldn't matter.
14:00:59 <MaybeJust> I do: ghc -Wall Main.hs
14:01:18 <ion> maybejust: :m + Module seems to make sure it gets imported.
14:01:19 <dmwit> MaybeJust: ghc --make -Wall Main.hs
14:01:26 <monochrom> which ghc version?
14:01:37 <dmwit> monochrom: 7.0.4
14:01:58 <otk> in terms of proof assistance, looks like haskell has 'Agda'
14:02:02 <monochrom> then "--make" is default
14:02:02 <otk> (irrelevant)
14:02:09 <dmwit> Okay, I was wondering about that.
14:02:27 <dmwit> I wonder if something extra needs to go in the environment to tell Windows where to look for DLLs.
14:02:32 <roconnor> I'd like to see sokoban implemented in Agda
14:03:14 <MaybeJust> how do i make a an exe filed called somehting specifik?
14:03:21 <monochrom> yes, one environment variable has all the DLL directories. I forgot its name.
14:03:34 <dmwit> MaybeJust: -o foo.exe
14:04:25 <monochrom> at some point, you should just read the GHC user guide. it's installed on your disk too. your start menu has it somewhere.
14:06:06 <rampion> MaybeJust: if you have your Main module in a file called Foo.hs, and you do ghc —make Foo.hs, you'll end up with an executable called Foo.exe
14:07:49 <MaybeJust> if i dont do makwe what happens?
14:08:21 <rampion> well, I'm not on a windows box, so I can't be sure
14:08:45 <rampion> but I think it just compiles the object file (for static linking), instead of the executable
14:08:53 <rampion> Foo.o
14:12:45 <MaybeJust> > fmap remember monochromius
14:12:46 <lambdabot>   Not in scope: `remember'Not in scope: `monochromius'
14:24:33 <paf31> @djinn a -> a
14:24:34 <lambdabot> f a = a
14:27:50 <c_wraith> @djinn (s -> (s, a)) -> (a -> s -> (s, b)) -> (s -> (s, b))
14:27:50 <lambdabot> f a b c =
14:27:51 <lambdabot>     case a c of
14:27:51 <lambdabot>     (d, e) -> b e d
14:28:06 <c_wraith> favorite djinn trick.
14:28:15 <c_wraith> (making it do beginner-level homework)
14:28:25 <henux> I really like Haskell :)
14:29:21 <dmwit> c_wraith: Until you explained, I thought the trick was spelling words in the last line of code.
14:29:27 <DanBurton> henux: most people here do too xD
14:31:40 <shachaf> @djinn a -> b -> c -> d -> e -> f -> g -> h -> i -> j -> k -> l -> m -> n -> o -> (h,e,l,l,o)
14:31:40 <lambdabot> f _ _ _ _ a _ _ b _ _ _ c _ _ d = (b, a, c, c, d)
14:31:56 <shachaf> Drat and double-drat!
14:31:59 <DanBurton> lol
14:32:26 <DanBurton> @djinn a -> b -> c -> d -> e -> f -> g -> h -> i -> j -> k -> l -> m ->  n -> o -> (h,e,l,l,o)
14:32:26 <lambdabot> f _ _ _ _ a _ _ b _ _ _ c _ _ d = (b, a, c, c, d)
14:32:29 <DanBurton> doh
14:32:37 <DanBurton> I didn't mean to copy the newline with it
14:32:47 <albel727> @help djinn
14:32:47 <lambdabot> djinn <type>.
14:32:47 <lambdabot> Generates Haskell code from a type.
14:32:47 <lambdabot> http://darcs.augustsson.net/Darcs/Djinn
14:32:59 <monochrom> beginner homework doesn't seem to be about writing parametrically-polymorphical functions
14:33:34 <c_wraith> monochrom: well.  implementing (>>=) for state is beginner-level.  Even if no teacher ever assigns it.
14:33:34 <shachaf> monochrom: Is there any other kind?
14:34:11 <DanBurton> @djinn a -> b -> c -> d -> e -> f -> g -> h -> i -> j -> k -> l -> m -> n -> o -> ((a,b,c,d,e,f,g,h,i,j,k,l,m,n,o), (h,e,l,l,o))
14:34:12 <lambdabot> f a b c d e f g h i j k l m n o =
14:34:12 <lambdabot>     ((a, b, c, d, e, f, g, h, i, j, k, l, m, n, o), (h, e, l, l, o))
14:34:25 <DanBurton> well that's...anticlimactic
14:34:31 <monochrom> i.e., beginner homework seem to be more often "write tic-tac-toe" than "write f :: (s -> (s, a)) -> (a -> s -> (s, b)) -> (s -> (s, b))"
14:35:57 <dmwit> ?djinn a -> b -> c -> d -> e -> f -> g -> (e -> l -> l -> o) -> i -> j -> k -> l -> m -> n -> ((a,b,c,d,f,g,i,j,k,m,n),o)
14:35:57 <lambdabot> f a b c d e f g h i j k l m n =
14:35:57 <lambdabot>     ((a, b, c, d, f, g, i, j, k, m, n), h e l l)
14:36:03 <dmwit> hah
14:36:11 <monochrom> cunning!
14:36:13 <DanBurton> lol
14:36:17 <dmwit> Not quite what I intended, but sort of worked out anyway. =P
14:36:38 <monochrom> oh, you intended "h e l l o"?
14:36:44 <DanBurton> just add a p
14:36:48 <dmwit> Yes, and I see how to get it, but don't want to spam.
14:37:16 <monochrom> I still say you're cunning! :)
14:37:29 <dmwit> =D
14:37:36 * DanBurton queries lambdabot just to make sure
14:38:05 <t7> @djinn a -> b -> c -> d -> e -> f -> (f -> e -> d -> c -> b)
14:38:05 <lambdabot> f _ a _ _ _ _ _ _ _ _ = a
14:38:13 <t7> :O
14:38:30 <DanBurton> wait what
14:38:40 <dmwit> You can erase the parentheses in that type.
14:38:44 <dmwit> (->) associates right already
14:38:50 <DanBurton> oh right
14:39:01 <t7> @djinn a -> b -> c -> d -> e -> f -> ((f -> e )-> (d -> c) -> b)
14:39:01 <lambdabot> f _ a _ _ _ _ _ _ = a
14:39:12 <DanBurton> when i saw the parens on the right, my brain inserted similar parens on the left
14:39:41 <t7> @djinn a -> b -> c -> d -> e -> f -> (f -> (e -> d) -> c -> b)
14:39:41 <lambdabot> f _ a _ _ _ _ _ _ _ = a
14:40:01 <t7> you win this time...
14:40:18 <DanBurton> @djinn (a -> b -> c -> x -> y -> z) -> q -> (o -> m -> g -> b -> b -> q)
14:40:18 <lambdabot> f _ a _ _ _ _ _ = a
14:41:52 <dmwit> f _ wtf _ _ _ _ _ = wtf
14:42:34 <henux> would you say haskell is better than scheme ?
14:42:47 <ion> mu
14:42:51 <dmwit> ion++
14:42:53 <henux> its more modern and easier to write complicated mathematical expressions with it
14:43:13 <monochrom> wait, what do you mean by "mu"?
14:43:32 <dmwit> The question sucks.
14:44:01 <monochrom> I agree with that
14:44:09 <henux> ok
14:44:31 <henux> okay what are your thoughts about scheme vs. haskell?
14:44:38 <monochrom> lately it seems trendy to begin one's career in #haskell by "is haskell better than ___" or "haskell vs ___, fight!"
14:44:50 <henux> no im just interested
14:45:09 <henux> interested about how haskell compares to something like scheme
14:45:14 <hpc> > "haskell" > "scheme"
14:45:15 <lambdabot>   False
14:45:22 <hpc> question answered :D
14:45:29 <tech2> henux: assuming you wanted an unbiased answer, why would you think of asking in here?
14:45:56 <tech2> the question location reeks somewhat of selection bias.
14:46:30 <monochrom> if you already know both, you already know the comparison. if you don't already know both, you should first know both.
14:47:32 <quintessence> I think it's legitimate to ask what haskellers think of scheme (and vice versa), even knowing the answers are going to be from a biased perspective
14:48:02 <ion> But that’s not what he asked.
14:49:03 <dmwit> Both Haskell and Scheme are lambda calculi under the hood. The primary differences are that Scheme is strict and untyped, while Haskell is lazy and typed (with HM-style type inference).
14:49:44 <dmwit> There are endless discussions on the web about the pros and cons of typing and laziness, if you care to have some more detail.
14:49:53 <henux> ion: i asked what are your thoughts
14:50:13 <monochrom> pretty sure "mu" is his thoughts, whatever that means
14:50:23 <henux> i got that part, yes
14:50:29 <t7> obviously untyped is better
14:50:35 <henux> but the question was not excluded nor directed to him in general
14:50:44 <tech2> mu == 'I do not have, or cannot give, a meaningful answer given the status of the question'
14:50:58 <henux> t7: why?
14:51:07 <monochrom> hmm, why is it called mu? :)
14:51:09 <t7> because you cant type the y combinator
14:51:18 <t7> also look at python, thats untyped
14:51:24 <t7> much better than haskell
14:52:00 <dmwit> monochrom: Because it's like Chinese or something, man.
14:52:32 <henux> im at step25, and every time i type "Spartacus" in the console, i get "Terminated!"
14:52:50 <dmwit> (In case the question is serious, there's a page on Wikipedia about it: http://en.wikipedia.org/wiki/Mu_(negative) )
14:52:51 <MaybeJust> import qualified Graphics.UI.GLFW as GLFW, what happened to GLFW?
14:52:57 <MaybeJust> MU system
14:53:21 <henux> now it works
14:53:23 <henux> hmm, odd
14:53:38 <dmwit> "Terminated!"?
14:53:47 <henux> yes
14:53:48 <dmwit> Are you using lambdabot to evaluate things on the command line for some reason?
14:54:02 <henux> no, im using the web interface in haskell.org
14:54:08 <henux> and taking the tutorial
14:54:20 <dmwit> ah
14:54:22 <monochrom> step 25 wants you to enter a string literal. you have to include the two double-quotes.
14:54:23 <henux> but i got it working by going one step back and then proceeding again
14:54:44 <henux> monochrom: i did so by pressing the "Spartacus" link in the help window
14:54:55 <henux> monochrom: which copies it to the console verbatim
14:55:03 <monochrom> I see
14:55:08 <henux> but i got it working now
14:55:25 <monochrom> dmwit: it's tryhaskell.org
14:55:44 <monochrom> and it's lesson6 there
14:56:03 <henux> yes, tryhaskell.org, not haskell.org
14:56:57 <mdmkolbe> I suspect "cabal install" has been compiling "-O1".  How do I check what it did on already installed packages?  How do I get it to recompile all installed packages at "-O2"?
14:58:28 <monochrom> yes, -O1 is the default. some packages add "ghc-options: -O2" to get -O2, e.g., bytestring
14:58:34 <dmwit> I don't think compile lines are recorded.
14:59:06 <dmwit> I also don't think there is (yet) a convenient way to recompile many packages at once.
14:59:08 <monochrom> unfortunately .caba/config does not let you set -O2 across the board
14:59:34 <mauke> it doesn't?
14:59:40 <mauke> then what have I been doing?
14:59:57 <monochrom> however you can remember to enter "cabal install --enable-optimization=2" every bloody time
15:00:00 <mauke> nothing, apparently
15:00:10 <dmwit> Where "convenient" means "automatically chase dependencies and reinstall those, too", mauke.
15:01:15 <dmwit> Are you saying you added this feature to cabal-install? If so, that's totally awesome.
15:01:43 <monochrom> .cabal/config only has the boolean "optimization: True/False". True means -O1
15:02:05 <dmwit> ReallyTrue/True/False/FileNotFound
15:03:39 <MaybeJust> blarf how do I get this gtk2hs working
15:03:56 <alpounet> windows?
15:05:24 <MaybeJust> yes
15:05:33 <MaybeJust> something with the DLLs
15:05:34 <dmwit> MaybeJust: Still can't find the DLLs, or is it something else now?
15:05:41 <MaybeJust> #windows cant help either
15:06:25 <zerax> What's the problem MaybeJust?
15:08:51 <MaybeJust> http://hpaste.org/64470
15:09:45 <zerax> Ah, so you think it's not finding the correct glib dll?
15:10:17 <MaybeJust> http://hpaste.org/64469
15:10:26 <MaybeJust> yes something like that
15:11:13 <zerax> I recall this suffering. gtk2hs is horrid to build on windows.
15:11:23 <dmwit> (gtk2hs is already built)
15:11:32 <dmwit> Maybe http://msdn.microsoft.com/en-us/library/windows/desktop/ms682586(v=vs.85).aspx will help?
15:12:53 <dmwit> Believe it or not, PATH also controls where DLL lookup goes, not just executable lookup.
15:12:57 <dmwit> (WHAAAAT)
15:13:26 <dmwit> MaybeJust: Are the DLLs in gtk's \bin directory?
15:14:26 <zerax> Basically if it's in the PATH, it'll find it. But remember that if you change the PATH you'll need to restart your command prompt as the new instance of cabal takes it from the environment when it was launched.
15:15:15 <MaybeJust> i have relaucnehd cmd prompt because i remembered that problem since earlier
15:15:39 <MaybeJust> but you mean i have to reinstall gtk?
15:15:45 <dmwit> no
15:15:53 <dmwit> You should not have to reinstall gtk.
15:16:29 <MaybeJust> maybe those problems from before actually were problems
15:17:26 <dmwit> Could you hpaste the output of "dir c:\gtk" (or wherever you installed gtk)?
15:17:27 <MaybeJust> and gtk../bin/ is int he path
15:21:30 <hpaste> MaybeJust pasted “dir gtk” at http://hpaste.org/64471
15:22:30 * dmwit points at libcairo-script-interpreter-2.dll and screams at Windows, "It's THERE!".
15:24:16 <MaybeJust> how do i quit the prelude?
15:24:22 <rampion> ?
15:24:25 <byorgey> dmwit: =(
15:24:31 <dmwit> {-# LANGUAGE NoImplicitPrelude #-}
15:24:48 <byorgey> MaybeJust: perhaps you mean quit ghci?
15:24:58 <byorgey> i.e. stop seeing  Prelude>  ?
15:25:00 <zerax> :q
15:25:20 <hpaste> MaybeJust pasted “oops” at http://hpaste.org/64472
15:25:21 <dmwit> Reboot the machine. It's the only way.
15:25:27 <byorgey> in that case you should note that zerax was in fact answering your question, not making a face
15:26:08 <MaybeJust> haha i caued ghc.exe panic the impossible happened
15:26:13 <MaybeJust> worth reporting?
15:26:14 <zerax> That panic looks funny
15:26:16 <dmwit> MaybeJust: Oh, what, all this time you've been installing using the 64-bit GTK libraries, but your GHC is 32-bit.
15:26:44 <byorgey> MaybeJust: probably not, since you're using 7.0.4 so it's probably reported and fixed by now
15:27:06 <dmwit> MaybeJust: (At least according to the "GHC version 7.0.4 for i386-unknown-mingw32" line.)
15:27:22 <dmwit> MaybeJust: If you're using 32-bit GHC, you should probably use one of the 32-bit GTK bundles.
15:27:50 <dmwit> e.g. http://ftp.gnome.org/pub/gnome/binaries/win32/gtk+/2.24/gtk+-bundle_2.24.10-20120208_win32.zip
15:27:56 <MaybeJust> how do you know im using 32 bit ghc?
15:28:18 <MaybeJust> oh mingw32?
15:28:23 <dmwit> MaybeJust: From your last paste, "GHC version 7.0.4 for i386-unknown-mingw32".
15:28:24 <dmwit> yeah
15:28:38 <dmwit> Also "i386", which is not x86_64.
15:32:34 <MaybeJust> there is no 64 bit for windows?
15:33:21 <dmwit> I guess not!
15:33:48 <gentleben> there is 64 bit windows
15:34:01 <dmwit> There is no 64-bit GHC binary for Windows.
15:34:07 <gentleben> that may be
15:34:17 <gentleben> there didn't used to be one for osx
15:34:28 <gentleben> when i first started using haskell
15:36:52 <dmwit> "A full and faithful functor is a functor which is both full and faithful." Thanks, nlab!
15:40:37 <dibblego> roconnor: ping
15:40:55 <roconnor> ack
15:41:06 <roconnor> rst
15:41:26 <dibblego> yo mate, why does your data-lens github contain Ed's data-lens as well, when the one on hackage is only two modules?
15:42:07 <roconnor> because I'm now the maintainer of data-lens, and so I decree that partial-lens be merged into data-lens.
15:43:09 <dibblego> ok sweet mate, I might send you a couple of patches in the next couple of hours
15:43:16 <roconnor> ok
15:44:19 <MaybeJust> do all mathematical structures exist in reality?
15:44:33 <dmwit> Yes.
15:44:37 <alpounet> your question doesn't make much sense
15:44:42 <dmwit> I have a big "2" sitting next to me on my desk.
15:44:46 <alpounet> mathematical structures are abstractions
15:45:20 <roconnor> MaybeJust: mathematical structures exist as much as software exists.
15:45:22 <alpounet> of things that are tied to reality as part of models of it in some mathematical / physics / chemistry / biology / whatever framework
15:45:59 <MaybeJust> Tegmark's sole postulate is: All structures that exist mathematically also exist physically.
15:46:50 <ulidtko> how to stop ghci to do type defaulting?
15:47:03 <dmwit> :set -XNoMonomorphismRestriction
15:47:29 <dmwit> You will probably also need {-# LANGUAGE NoMonomorphismRestriction #-} in the file you're loading, if you're loading a file.
15:47:41 <dmwit> (The file and the input on stdin are treated separately.)
15:47:42 <ulidtko> yeah i am
15:48:16 <ulidtko> hm, so top-level functions are not gonna be polymorphic by default?
15:48:27 <dmwit> hm?
15:48:36 <dmwit> No, this makes them be polymorphic by default.
15:48:46 <dmwit> Without this, they are monomorphed in certain situations.
15:48:51 <hpc> the monomorphism restriction is
15:49:09 <hpc> "top level definitions that look like 'name = expr' are defaulted"
15:49:10 <dmwit> ?wiki monomorphism restriction
15:49:11 <lambdabot> http://www.haskell.org/haskellwiki/monomorphism_restriction
15:49:21 <hpc> so "id x = x" is still polymorphic
15:49:33 <hpc> "id = \x -> x" is of type () -> ()
15:49:40 <dmwit> um
15:49:41 <hpc> or something like that
15:49:49 <dmwit> I think only class-polymorphic things are defaulted.
15:49:55 <hpc> ah
15:50:01 <ulidtko> I have this declaration:
15:50:01 <ulidtko> mean sample = sum sample / length sample
15:50:12 <ulidtko> and it defaults to Int and fails to type-check
15:50:15 <dmwit> ulidtko: That is not polymorphic to begin with.
15:50:22 <dmwit> ulidtko: That's not defaulting, that's the type of length:
15:50:23 <dmwit> :t length
15:50:24 <lambdabot> forall a. [a] -> Int
15:50:25 <quintessence> ulidtko: that's not defaulting, that's the type of length
15:50:27 <dmwit> ulidtko: Perhaps you want
15:50:27 <hpc> :t (sum sample)
15:50:28 <lambdabot>     Couldn't match expected type `[a]'
15:50:28 <lambdabot>            against inferred type `Gen a1 -> IO ()'
15:50:28 <lambdabot>     In the first argument of `sum', namely `sample'
15:50:30 <dmwit> :t genericLength
15:50:31 <lambdabot> forall b i. (Num i) => [b] -> i
15:50:41 <ulidtko> owhh...
15:50:46 <hpc> yes, that
15:51:23 <dmwit> ulidtko: Integer is the default, not Int, so if you see Int you can be sure it's not defaulting. =)
15:55:25 <MaybeJust> Loading package cairo-0.12.2 ... linking ... ghc.exe: unable to load package `cairo-0.12.2'
15:55:32 <MaybeJust> i installed win32 bundle and changed the path
15:55:42 <MaybeJust> do i have to reinstall buildtools and gtk?
15:56:21 <dmwit> You shouldn't need to reinstall buildtools, but you probably will have to reinstall gtk and its dependencies.
15:56:46 <dmwit> So that means glib, gio, cairo, pango, and gtk (in roughly that order).
15:58:18 <MaybeJust> but i just call cabal?
15:59:53 <dmwit> MaybeJust: Yes, something like
16:00:02 <dmwit> cabal install --reinstall glib gio cairo pango gtk
16:01:07 * hackagebot epic 0.9.3 - Compiler for a simple functional language  http://hackage.haskell.org/package/epic-0.9.3 (EdwinBrady)
16:01:09 * hackagebot idris 0.9.2 - Functional Programming Language with Dependent Types  http://hackage.haskell.org/package/idris-0.9.2 (EdwinBrady)
16:01:59 <shergill1> possiby noob question: what's the environment variable which specifies the module search path for ghc/ghci?
16:02:03 <shergill1> *possibly
16:02:15 <dmwit> It's not an environment variable.
16:02:25 <MaybeJust> i did cabal install --reinstall gtk, hope that works
16:02:31 <shergill1> no wonder i couldn't find it in the docs
16:02:32 <dmwit> MaybeJust: That will not work.
16:03:05 <byorgey> shergill1: -i
16:03:16 <byorgey> ghc -idir ...
16:03:24 <dmwit> shergill1: Many more details here: http://www.haskell.org/ghc/docs/7.0.3/html/users_guide/separate-compilation.html
16:03:40 <shergill1> dmwit: thanks
16:04:49 <Axman6> anyone know a cross platform way to find the size of a file?
16:06:27 <shergill1> ah yeah i was already looking at that. so one solution for me (to keep from having to specify the -i flag everytime) is to alias 'ghc' i suppose. any other ideas?
16:06:55 <geekosaur> Axman6, as far as I can tell the only cross platform way to do it is open and read :/
16:07:13 <shergill1> Axman6: what platforms?
16:07:24 <byorgey> Axman6: all you need is a cross platform way to delete a file.  That reduces the problem to finding a cross-platform way to compute (const 0).
16:07:33 <shergill1> heh
16:07:34 <geekosaur> :p
16:08:02 <Enigmagic> fseek/ftell?
16:11:26 <Enigmagic> Axman6: system-fileio:Filesystem.getSize might do what you want too if you want to get the length by name not handle
16:12:32 <Axman6> hmm, i was hoping there'd be something that came with the haskell platform, and that doesn't does it?
16:14:16 <geekosaur> Axman6, I think it's been discussed but not happened, except possibly in the form of a library on hackagwe which is an incomplete emulation of the unix library on windows
16:14:32 <Axman6> bleh
16:15:15 <geekosaur> (actually if someone wants to do a service for the haskell community that doesn;t require a lot of high level haskell understanding, working up a nice simple compatibility layer for this kind of stuff would be nice)
16:15:18 <Axman6> not looking forward to having to read in a bytestring and get its size all in memory. should be ok though, the files will be rather small
16:16:26 <dmwit> ?hoogle hFileSize
16:16:26 <lambdabot> System.IO hFileSize :: Handle -> IO Integer
16:16:26 <lambdabot> GHC.IO.Handle hFileSize :: Handle -> IO Integer
16:16:28 <dmwit> -- ?
16:16:59 <Axman6> hmm, that works... sort of
16:17:06 <Axman6> yeah i guess i can make that work
16:17:56 <geekosaur> this in particular there are simple functions in the unix and win32 libraries but nowhere is there a wrapper that delegates by OS
16:18:01 <dmwit> :t \fp -> System.IO.withFile fp ReadMode System.IO.hFileSize
16:18:02 <lambdabot> Not in scope: data constructor `ReadMode'
16:18:09 <dmwit> :t \fp -> System.IO.withFile fp System.IO.ReadMode System.IO.hFileSize
16:18:09 <collin> hi all..just got a little confused with read.."read "123" :: Int" but not "read "a" :: Char" but yet there is a Char instance of Read?
16:18:10 <lambdabot> FilePath -> IO Integer
16:18:20 <dmwit> > read "'a'" :: Char
16:18:21 <lambdabot>   'a'
16:19:14 <mauke> collin: a is not valid syntax for a Char
16:19:39 <dmwit> Related:
16:19:53 <dmwit> > read "\"foo\""
16:19:54 <lambdabot>   *Exception: Prelude.read: no parse
16:19:57 <dmwit> > read "\"foo\"" :: String
16:19:58 <lambdabot>   "foo"
16:20:23 <alpounet> rekahsoft, chars are not wrapped up in quotes, but ' '
16:20:28 <alpounet> @type 'a'
16:20:29 <lambdabot> Char
16:20:33 <alpounet> type "a"
16:20:35 <alpounet> @type "a"
16:20:36 <lambdabot> [Char]
16:21:11 <rekahsoft> mauke: and..awe..stupid on me..haskell has eval right?
16:21:18 <dmwit> No.
16:21:35 <rekahsoft> would explain why read functions like we just mentioned./
16:21:35 <dmwit> It has the GHC API, which provides some similar capabilities.
16:22:00 <dmwit> The existence of eval is not required to explain the behavior of read.
16:22:20 <rekahsoft> i'm looking for a function that turns a digit (0-9) to the respective Char
16:22:25 <geekosaur> read is a wrapper which uses the type it has been requested to return to select a parser to run
16:22:32 <dmwit> :t intToDigit
16:22:32 <lambdabot> Int -> Char
16:22:49 <rekahsoft> and :( no eval..how does ghci work then?
16:23:12 <rekahsoft> or is it a haskell interpretter written in haskell?
16:23:21 <dmwit> Yes, it is exactly that.
16:23:47 <rekahsoft> dmwit: sweet :) thanks :)..i did a hoogle for it but didn't come up successful
16:23:58 <MaybeJust> i wrote a haskell interpreter in brainfuck before brainfuck was invented, beat bthat!
16:23:59 <mauke> @hoogle Int -> Char
16:23:59 <lambdabot> Data.Char chr :: Int -> Char
16:23:59 <lambdabot> Data.Char intToDigit :: Int -> Char
16:23:59 <lambdabot> Data.Text index :: Text -> Int -> Char
16:24:52 <dibblego> roconnor: what do you think about a dependency on Control.Newtype so that you can have: newtypeLens :: Newtype a b => Lens a b ?
16:25:15 <dmwit> > map intToDigit [0, 5 .. 40]
16:25:16 <lambdabot>   "05af*Exception: Char.intToDigit: not a digit 20
16:26:34 <ulidtko> how to elegantly read stdin as a list of lines in haskell?
16:26:57 <dmwit> :t fmap lines getContents
16:26:57 <lambdabot> IO [String]
16:27:12 <ulidtko> thank you
16:27:17 <roconnor> dibblego: that would make the package not haskell 98
16:27:27 <dibblego> roconnor: yeah good point
16:27:38 <HugoDaniel> ulidtko: interact ?
16:27:51 <HugoDaniel> :t interact
16:27:51 <lambdabot> (String -> String) -> IO ()
16:27:54 <HugoDaniel> ;)
16:28:02 <dmwit> :t lines . getContents -- because Cale
16:28:02 <lambdabot> IO [String]
16:28:14 <HugoDaniel> :D
16:28:46 <ulidtko> hmmm... how dot composition worked on IO String?
16:28:52 <dmwit> :t (.)
16:28:53 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
16:29:08 <alpounet> this is a "custom" (.), not the one provided in the standard library
16:29:09 <dmwit> In \bot, (.) = fmap
16:29:24 <ulidtko> oh.
16:30:19 <ulidtko> @hoogle <$>
16:30:19 <lambdabot> Data.Functor (<$>) :: Functor f => (a -> b) -> f a -> f b
16:30:19 <lambdabot> Control.Applicative (<$>) :: Functor f => (a -> b) -> f a -> f b
16:30:21 <HugoDaniel> ulidtko: if you are trying something fancy like piping to your app, then interact is the best choice
16:31:00 <dmwit> What makes interact preferable to getContents?
16:31:19 <ulidtko> laziness should rule them equivalently well
16:31:39 <MaybeJust> sigh
16:31:46 <HugoDaniel> just sugar
16:31:57 <MaybeJust> Loading package cairo-0.12.2 ... linking ... ghc.exe: unable to load package `cairo-0.12.2'
16:32:06 <ulidtko> HugoDaniel: i'm sketching a minimalistic to force someone in love with haskell
16:32:13 <HugoDaniel> and approach, interact being more functional, nothing
16:32:13 <ulidtko> *minimalistic script
16:32:24 <dmwit> MaybeJust: hpaste "ghc-pkg check"?
16:32:42 <MaybeJust> why does the haskell platform install into the program files of x86 when it s only 32bit?
16:32:53 <HugoDaniel> ulidtko: show em the power of currying :)
16:33:00 <HugoDaniel> b*tches love currying
16:33:06 <dmwit> MaybeJust: "x86" means "32-bit"
16:33:15 <dmwit> MaybeJust: "x86_64" means "64-bit"
16:33:42 <MaybeJust> uoh
16:34:27 <t7> show them monad transformers
16:34:31 <t7> lololol
16:36:42 <hpaste> MaybeJust pasted “windows perm ghc-pkg” at http://hpaste.org/64473
16:38:43 * dmwit sighs in MaybeJust's general direction
16:38:47 <dmwit> I don't know.
16:38:49 <dmwit> I just don't know.
16:39:09 <dmwit> Screw Windows with a giant screwdriver and a giant screw.
16:40:44 <dibblego> roconnor: did you intend to leave off Control.Comonad.StaredStore in exposed-modules?
16:41:21 <roconnor> dibblego: I haven't decided.  I'll probably expose it.
16:41:37 <roconnor> er
16:41:39 <dibblego> oh ok, thanks
16:41:40 <roconnor> I need to expose it
16:41:48 <dibblego> just wasn't sure if it was a conscious decision
16:41:49 <roconnor> I just haven't gotten around to it
16:41:53 <dibblego> cool
16:42:02 <dmwit> (If it's not exposed, it should be in other-modules, just so you know. Any module not listed somewhere in your cabal file is a mistake.)
16:42:24 <roconnor> ya, I haven't really cabalized it :D
16:42:31 <roconnor> yet
16:43:15 <dibblego> wouldn't you need to expose it since Data.Lens.Multi.Common uses it?
16:43:26 <dylukes> I'm trying to install happy, but it's not seeing my packages...
16:43:41 <dylukes> http://cl.ly/EaXI
16:43:49 <roconnor> dibblego: ya, I need it expose it.
16:44:00 <dibblego> ok
16:44:08 <roconnor> dibblego: multi-lens hasn't been cabalized yet
16:44:14 <roconnor> but feel free to patch it :D
16:44:39 <dibblego> okey dokey, nah I might leave that to you, since it's obviously on top of your mind -- I just wanted to check where you are at with it
16:44:54 <dibblego> I'll do some patching to Lens and PartialLens
16:46:02 <dylukes> It's just seemingly ignoring mtl...
16:46:14 <roconnor> dibblego: I'm planning to change the associativity of (^.)
16:46:19 <roconnor> since it is wrong.
16:46:26 <dibblego> ok
16:46:43 <roconnor> so if you plan on using that operator, you should go ahead and change the associativity.
16:46:48 <dibblego> ok
16:46:57 <dmwit> dylukes: The default for Setup.lhs is a global install.
16:47:06 <dmwit> dylukes: Add --user to the configure step.
16:47:09 <dylukes> ah, thanks!
16:47:22 <dmwit> dylukes: (Any reason you didn't just "cabal install happy"?)
16:47:29 <dibblego> I am going to add getLOr :: PartialLens a b -> a -> b -> b and isL :: PartialLens -> a -> Bool
16:47:35 <dylukes> dmwit: I don't have cabal installed yet :P.
16:47:41 <dylukes> GHC 7.0.3+ is broken on OS X 10.8
16:47:54 <dylukes> so I'm bootstrapping 7.5 (HEAD) from 7.0.2...
16:47:56 * dmwit nods sympathetically
16:47:59 <dylukes> but I need a few dependencies first :).
16:48:10 <roconnor> dibblego: oh good.  I have no idea what operations Partial Lens should have :D
16:48:18 <dylukes> "Could not find module `Control.Monad.Writer':
16:48:18 <dibblego> and I am thinking about how to write product (***), choice (|||) and codiagonal :: *Lens (Either a a) a
16:48:18 <dylukes>       There are files missing in the `mtl-2.0.1.0' package,"
16:48:18 <dylukes> fml
16:48:42 <dibblego> choice should probably be some kind of Alternative instance
16:49:06 <dylukes> dmwit: so, I'm also unable to install Network...
16:49:09 <dylukes> "* Missing (or bad) header file: HsNet.h"
16:49:10 <dylukes> :\
16:49:20 <roconnor> Lens (Either a a) a fairly straightforward
16:49:24 <roconnor> *is
16:49:29 <dylukes> Did i miss something from the binary distribution?
16:49:44 <dibblego> yeah but maybe there is a type-class for it, so I can also have PartialLens (Either a a) a and other *Lens
16:49:58 <dibblego> this is what I am trying to sort out at the moment
16:50:08 <dmwit> dibblego: Be careful calling it codiagonal.
16:50:16 <dmwit> That implies some laws that it probably doesn't satisfy.
16:50:18 <dibblego> dmwit: ?
16:50:29 <dibblego> oh, it doesn't satisfy them?
16:50:59 <dmwit> Like uniqueness -- aren't there two perfectly good choices for the codiagonal?
16:51:07 <roconnor> dmwit: nope, only 1
16:51:10 <dmwit> (Do these lenses have a "create"?)
16:51:14 <roconnor> nope
16:51:16 <dibblego> no create
16:51:17 <dmwit> aha
16:51:31 <dylukes> dmwit: bah, I'm trying to get cabal installed to make the rest a bit easier
16:51:39 <dylukes> irene-knapp: oy
16:51:40 <dylukes> you
16:51:47 <dylukes> Can I have your cabal-install binary :3?
16:53:00 <monochrom> I have a linux x86 32-bit cabal executable
16:53:09 <dibblego> yeah I might twiddle the cabal file too -- it's not building as is
16:53:37 <MaybeJust> this is bullcrap
16:54:21 <dylukes> Anyone here on OS X ?
16:54:58 <dylukes> actually...
16:55:02 <dylukes> HP should include it.
16:55:11 <dylukes> I can just use HP to bootstrap shit.
16:55:18 <MaybeJust> if the package list isnt up to date then what happens?
16:55:38 <dylukes> dmwit: I've typed some combintion of `tar xf ...`, `cd ...`, `runhaskell configure`... way too many times.
16:55:43 <dylukes> I miss cabal <3
16:55:49 <monochrom> hehe
16:56:42 <niez> which gui toolkit should I use for real world application? (not bindings, I'm looking for purely functional build from ground up in haskell)
16:57:54 <dmwit> MaybeJust: Then it tries to install old versions of things.
16:58:01 <dmwit> s/it/cabal-install/
16:58:02 <Enigmagic> niez: do you have a purely functional OS to run it on?
16:58:25 <niez> Enigmagic, where can I gen one?
16:58:29 <niez> get*
16:58:43 <MaybeJust> dmwit: check will show if cairo installed correctly?
16:59:10 <dmwit> MaybeJust: check is a diagnostic. If it reports errors, it will give a clue to what's wrong; if it doesn't report errors, we must think of another diagnostic.
16:59:11 <MaybeJust> i cant even change the permission
16:59:25 <niez> Enigmagic, no
17:00:21 <Enigmagic> niez: there will be bindings somewhere then
17:00:43 <bill```> MaybeJust: do you have UAC on?  by default, programs can't write to their installation dirs under program files
17:00:49 <bill```> (as of vista)
17:01:02 <MaybeJust> UAC?
17:01:02 <dmwit> There are several GUI packages based on FRP that use bindings, but I don't think any of them have been used in real-world GUIs yet.
17:01:03 <bill```> they have to write to %homedir%/appdata/local or /roaming
17:01:05 <MaybeJust> w7
17:01:13 <dmwit> The only world-tested alternatives are pure bindings.
17:01:17 <bill```> yeah, haskell can't write to its own installation directory
17:01:28 <MaybeJust> yes i have soem stuff in roaming and soem under haskell platofrm
17:01:41 <bill```> writes to program files by the stuff installed there will fail
17:01:50 <bill```> iirc, you can disable UAC and it will work
17:01:52 <MaybeJust> how do i change that?
17:02:08 <bill```> i don't remember, i stopped programming windows machines a few years ago
17:02:18 <bill```> google "windows disable UAC"
17:02:24 <sipa> You can actually program them?
17:02:28 <bill```> you can try
17:02:48 <bill```> also lol @ ghc trying to use / as a path separator on windows
17:02:57 <bill```> second class citizen
17:04:49 <bill```> MaybeJust: there was a feature that let writes to Program Files transparently go to the local/roaming directory, but i don't remember what it's called either... and i don't remember if programs had to explicitly use it, so i can't really be of any more help, sorry
17:06:10 <BMeph> Has anyone else examined dmbarbour's RDP stuff? I'd like to see how it compares to FRP on "infrastructure" issues.
17:11:45 <krey_> o/, for the first time, I need to use haskell for numerical computation. any recommendations on libraries?
17:13:18 <copumpkin> > [5 | True]
17:13:19 <lambdabot>   [5]
17:13:20 <DanBurton> what kind of numerical computation?
17:13:23 <copumpkin> > [5 | False]
17:13:23 <lambdabot>   []
17:15:07 <DanBurton> krey_: you might find the repa package useful, and friends such as repa-algorithms
17:15:43 <krey_> DanBurton: I need to add an multiply floating point numbers. sick stuff really
17:16:23 <ion> Prelude has that.
17:16:26 <rostayob> krey_: I don't think you need any special library too add and multiply Floats.
17:16:28 <DanBurton> krey_: looking for something more complicated than the Num typeclass?
17:17:08 <dibblego> class Codiagonal f where codiag :: f (Either a a) -> a -- does anyone know where I might find this?
17:18:12 <krey_> DanBurton, rostayob: cool, i'm happy to use floats. when/why do people stop using them?
17:18:31 <rostayob> krey_: do they?
17:19:23 <DanBurton> krey_: people stop using just plain floats when they need high performance arrays of floats
17:19:26 <DanBurton> then they use repa
17:19:33 <dibblego> class Choice {- name? -} f where (|||) :: f a c -> f b c -> f (Either a b) c -- and this?
17:19:45 <DanBurton> or so I'm told
17:19:59 <rostayob> dibblego: ArrowChoice?
17:20:05 <rostayob> :t (|||)
17:20:05 <DanBurton> @hoogle (|||)
17:20:06 <lambdabot> Control.Arrow (|||) :: ArrowChoice a => a b d -> a c d -> a (Either b c) d
17:20:06 <lambdabot> forall (a :: * -> * -> *) b d c. (ArrowChoice a) => a b d -> a c d -> a (Either b c) d
17:20:20 <dibblego> rostayob: yeah the problem is f is not a full Arrow
17:21:02 <rostayob> dibblego: then I don't know.
17:21:18 <rostayob> also, that 'f' is misleading. I'd think it's a functor :P
17:21:25 <dibblego> ok ta
17:22:01 <rostayob> dibblego: out of curiosity, what's the type in question?
17:22:06 <dibblego> f=Lens
17:22:19 <dibblego> (and some variations on that)
17:22:25 <krey_> rostayob: I guess I could just premature optimise less :)
17:22:26 <Axman6> krey_: use Double instead of Float please, there's no reason not to, unless you have lots and lots of them, and memory usage is an issue
17:22:26 <Axman6> they are exactly the same speed on modern machines, and Double gives much better accuracy
17:22:27 <krey_> Axman6: float is single precision?
17:22:27 <Axman6> yes
17:22:27 <krey_> omg
17:22:27 <krey_> double it is!
17:23:05 <rostayob> dibblego: well, you're right
17:23:07 <krey_> thanks for helping guys!
17:23:19 <dibblego> I might search semigroupoids
17:23:58 <dibblego> !seen edwardk
17:24:00 <dibblego> @seen edwardk
17:24:00 <lambdabot> Unknown command, try @list
17:24:14 <Axman6> preflex: seen edwardk
17:24:14 <preflex>  edwardk was last seen on #haskell-blah 4 hours, 12 minutes and 24 seconds ago, saying: =)
17:24:19 <dibblego> ta
17:28:13 <ion> krey: People also refrain from using floats when the precision semantics aren’t appropriate for what they’re doing. E.g. when PHP had a bug where int i = …; if (i > INT_MAX) … didn’t work and they fixed it with float i = (float)…; if (i > INT_MAX) …, that wasn’t an appropriate place to use floats.
17:29:56 <Jafet> So that was an approximate bugfix?
17:30:04 <ion> Also, anything related to money.
17:30:07 <ion> jafet: Indeed.
17:30:27 <dmwit> ?check \x -> not (x > maxBound)
17:30:28 <lambdabot>   "OK, passed 500 tests."
17:30:38 <Jafet> Hey guys, we fixed this bug to within 10^-6.
17:32:08 <c_wraith> ion: have a link to this story?
17:33:26 <ion> Was just searching for it. http://use.perl.org/~Aristotle/journal/33448
17:34:04 <Jafet> c_wraith: http://tunes.org/~nef/logs/haskell/12.02.27
17:34:04 <ion> I found it at http://www.reddit.com/r/lolphp originally.
17:34:21 <mike-burns> Hah.
17:34:40 <c_wraith> man, I forgot about that.  How could I forget that?
17:36:22 * geekosaur now has double the headache he started out with.  waaaaaaaaaat??!
17:37:07 <Tesseraction> ion: ahaha wow
17:37:15 <DanBurton> @hoogle [Maybe a] -> [a]
17:37:16 <lambdabot> Data.Maybe catMaybes :: [Maybe a] -> [a]
17:37:16 <lambdabot> Data.Maybe maybeToList :: Maybe a -> [a]
17:37:16 <lambdabot> Prelude sequence :: Monad m => [m a] -> m [a]
17:37:39 <DanBurton> hrm is there something I can use that is equivalent to "map fromJust . takeWhile isJust"?
17:38:16 <dmwit> catMaybes
17:38:21 <dmwit> Oh, you already saw that.
17:38:22 <hpc> @src catMaybes
17:38:23 <lambdabot> catMaybes ls = [x | Just x <- ls]
17:38:24 <c_wraith> Not really
17:38:30 <otters> > sequence $ map Just [1..10]
17:38:31 <lambdabot>   Just [1,2,3,4,5,6,7,8,9,10]
17:38:32 <dmwit> catMaybes . takeWhile isJust -- c_wraith
17:38:32 <DanBurton> catMaybes takes all of the Justs
17:38:32 <c_wraith> catMaybes isn't close to that functionality, either
17:38:34 <hpc> oh
17:38:40 <DanBurton> I want to stop at the first Nothing
17:38:43 <dmwit> DanBurton: catMaybes feels nicer than map fromJust
17:38:45 <hpc> what dmwit said
17:39:02 <DanBurton> > catMaybes [Just 3, Nothing, Just 4]
17:39:03 <lambdabot>   [3,4]
17:39:08 <DanBurton> I want it to be [3]
17:39:18 <dmwit> > catMaybes . takeWhile isJust $ [Just 3, Nothing, Just 4]
17:39:19 <lambdabot>   [3]
17:39:36 <DanBurton> ah
17:39:43 <DanBurton> well that's a little nicer
17:40:01 <dmwit> unfoldM :: m (Maybe a) -> m [a] -- from monad-loops
17:40:26 <dmwit> ...not really the right type, is it?
17:40:27 <DanBurton> hrm? how does that work
17:40:44 <DanBurton> if m = Identity, then that's just maybeToList
17:40:59 <dmwit> No, it's worse than maybeToList.
17:41:20 <dmwit> It's unfoldM (Identity Nothing) = Identity []; unfoldM (Identity (Just a)) = Identity (repeat a)
17:41:31 <dmwit> ...but too strict to ever return in the latter case, probably.
17:41:36 <ProblemOfficers> hm
17:41:47 <DanBurton> ah yes
17:42:37 <dmwit> DanBurton: Anyway, I don't think there's anything significantly better than using takeWhile.
17:42:43 <ProblemOfficers> Why doesn't Haskell have uniqueness typing instead of all that Monad mumbo jumbo?
17:43:04 <dmwit> ProblemOfficers: Remind me: what's known about type inference in the presence of uniqueness typing?
17:43:42 <dmwit> (Does uniqueness typing have a different name for PL researchers? Is it just linear typing or affine typing or something like that?)
17:44:22 <ProblemOfficers> http://en.wikipedia.org/wiki/Uniqueness_type
17:44:35 <c_wraith> linear typing and uniqueness typing are not the same..  They're related, but in opposite directions
17:44:47 <DanBurton> I fail to see how uniqueness typing replaces monads
17:44:59 <rwbarton> or vice versa
17:45:08 <c_wraith> It doesn't.  It provides an alternative mechanism to implement IO
17:45:49 <Jafet> Surely something that appeals to a C programmer is a good replacement for the blogosphere-adopted mumbo jumbo.
17:46:59 <ion> Uniqueness types are like fajitas.
17:47:54 <hpc> metaphors are like similes
17:48:57 <c_wraith> similes are metaphors
17:49:08 <ion> recursion is recursion
17:49:09 <c_wraith> (quantum trolling)
17:49:14 <DanBurton> metaphors are like similes
17:50:40 <hpc> bad analogies are like french haiku
17:50:56 <hpc> (your challenge: explain why)
17:51:44 <ion> bad analogies
17:51:50 <ion> are like french haiku poems
17:51:56 <ion> challenge: explain why
17:52:10 <dmwit> Oh my $DEITY.
17:52:11 <DanBurton> bonus challenge: explain how this relates to Haskell
17:52:15 <dmwit> http://www.reddit.com/r/lolphp/comments/ps6x5/0x0_wat/
17:53:33 <rwbarton> dmwit: yeah that was a good one
17:54:49 <rwbarton> copumpkin: maybe I should recreate my python quiz as /r/lolpython
17:54:57 <copumpkin> yes!
17:58:16 <ivanm> is something wrong with my browser that there are no nicks on that lolphp post?
17:58:51 <bill```> they're being hidden using css
18:00:16 <rostayob> jeez reddit is slow today.
18:00:30 <Tesseraction> it likes to be so, recently
18:10:03 <nyingen> @quote
18:10:03 <lambdabot> cheezey says: your'e an idiot.
18:10:11 <nyingen> @quote
18:10:11 <lambdabot> FogCreek says: Since throwing away a large code base and starting from scratch is typically a bad idea, the final decision was to have an intern write a compiler to translate a subset of ASP into
18:10:11 <lambdabot> PHP.
18:13:15 <DanBurton> apparently...people don't want their bosses to know how they make fun of PHP?
18:14:31 <bill```> having a job is better than not having a job a lot of the time
18:15:10 <hpc> i know people who have left jobs because the commute was more expensive than a day's work
18:28:25 <JoeyA> "... write a compiler to translate a subset of ASP into PHP" I'm thinking: that doesn't sound like a bad idea.  A big undertaking, though.  Is something wrong with me?
18:28:48 <pfn> that sounds like an awesome idea...
18:29:03 * pfn hopes JoeyA has a good <sarcasm> detector
18:29:19 <DanBurton> JoeyA: yes.
18:33:08 <gwern> > (1.2 - 0.93) / 0.076
18:33:09 <lambdabot>   3.5526315789473673
18:33:33 <gwern> hm, that can't be right. that's way too big an effect size for fish oil and axiety
18:34:14 <ion> That’s exactly what i thought.
18:35:42 <gwern> ion: so what did you do?
18:38:32 <shergill1> what's the way to redirect io in haskell? eg. i have a function foo::String -> IO() and another function bar::String -> IO(). i'd like to chain these functions together so that bar operates on the stuff printed out by foo. so the behavior i want is something like unix pipes
18:38:51 <mauke> I don't think that's easily possible
18:39:01 <zhzhxtrrk> should I pass -threaded flag to ghc to enable multi-threads support?
18:39:05 <hpc> shergill1: you would write foo/bar in a more sensible way
18:39:15 <mauke> zhzhxtrrk: what do you mean by thread support?
18:39:21 <hpc> zhzhxtrrk: what kind of threads do you want more of?
18:39:29 <zhzhxtrrk> os threads
18:39:34 <zhzhxtrrk> parallel
18:39:54 <shergill1> hpc: i'm not really in a position to change foo =/
18:40:02 <hpc> :/
18:40:04 <zhzhxtrrk> http://www.haskell.org/haskellwiki/Parallelism#Multicore_GHC
18:40:04 <mauke> shergill1: why not?
18:41:21 <shergill1> mauke: because it's not written by me? foo in this case is the 'lambdabot "where"' function defined in ghci on acid (http://www.haskell.org/haskellwiki/GHC/GHCi#GHCi_on_Acid)
18:41:50 * gwern frowns. if this darn study would just have given effect sizes I wouldn't be stuck trying to calculate them myself
18:41:51 <Axman6> zhzhxtrrk: OS threads suck
18:42:02 <zhzhxtrrk> I know that
18:42:06 <mauke> Axman6: no, they don't
18:42:23 <zhzhxtrrk> direct operate with os threads sucks
18:42:50 <mauke> shergill1: er. what are you doing with "where"?
18:43:34 <DanBurton> explicitly using OS threads in Haskell sucks. Use Haskell's lightweight threads and let the GHC runtime handle scheduling to real threads.
18:43:36 <shergill1> mauke: i want it to open my browser with the result (in case it finds the query string)
18:44:03 <mauke> shergill1: sounds like it would be easier to write your own "where"
18:44:55 <DanBurton> zhzhxtrrk: anyways, yes. you should compile with -threaded
18:45:43 <DanBurton> zhzhxtrrk: then run the program with +RTS -N2 to use 2 OS threads, or -NX for X threads
18:45:56 <deicide> hi guys
18:46:13 <deicide> i've just started learning haskell and am trying to grasp monads
18:46:19 <mauke> deicide: why?
18:46:22 <deicide> im wondering why the signature for bind
18:46:37 <deicide> isn't more naturally expressed as
18:46:40 <deicide> m a -> (m a -> m b) -> m b
18:46:43 <deicide> instead of m a -> (a -> m b) -> m b
18:46:50 <deicide> mauke: what do you mean?
18:46:54 <DanBurton> deicide: that seems rather odd. Usually people learn a bit more of Haskell; you don't have to learn monads right away
18:46:57 <byorgey> deicide: that would just be function application.
18:47:03 <mauke> (why are you trying to grasp monads?)
18:47:07 <shergill> mauke: perhaps. but now i'm more interested in figuring out a way to accomplish this. it seems unreasonable (to me) for there not to be a way to accomplish this
18:47:13 <mauke> deicide: with that signature bind would be useless
18:47:24 <monochrom> m a -> (a -> m b) -> m b is more useful and natural
18:47:28 <DanBurton> deicide: the difference between those two signatures is exactly the power that monad gives you over regular functions
18:47:49 <deicide> well, im sure that you guys are right... im not suggesting that that's a BETTER signature
18:47:50 <mauke> shergill: why do you think there would be a way?
18:47:59 <deicide> im just wondering why
18:48:00 <monochrom> if you want more symmetry, consider: (>=>) :: (Monad m) => (a -> m b) -> (b -> m c) -> (a -> m c)
18:48:01 <zhzhxtrrk> ok, get it.
18:48:05 <Jafet1> mauke: PHP!
18:48:06 <DanBurton> the ability to "bind" an action to a function that produces another action
18:48:42 <mauke> deicide: well, what could you do with foo :: m a -> (m a -> m b) -> m b?
18:49:00 <deicide> umm
18:49:01 <byorgey> deicide: there is no higher principle to which we can appeal to explain "why" that is the type.  That is the type because that is the type.
18:49:14 <mauke> byorgey: I don't agree
18:49:15 <deicide> map a computation directly into another computation?
18:49:17 <byorgey> don't try to understand why. Just try to understand the type.
18:49:18 <DanBurton> if that weren't the type, it wouldn't be bind. because bind has that type
18:49:18 <dolio> deicide: Can you write (>>=) with a function of your type?
18:49:35 <monochrom> I wouldn't know how to use (Monad m) => m a -> (m a -> m b) -> m b, other than just reducing it to (Monad m) => m b
18:49:44 <shergill> mauke: because there's a way to get stuff from stdin. all this requires is for stdout to be redirected to stdin, execute foo, get contents from stdin, undo redirection, feed result to bar
18:49:51 <deicide> mauke: map a computation directly into another computation?
18:50:18 <monochrom> maybe you can show me useful examples
18:50:24 <mauke> shergill: stdout can't be "redirected" to stdin in that way
18:50:31 <deicide> this is my absolute first exposure to monads
18:50:32 <mauke> deicide: how?
18:50:33 <deicide> im just reading
18:50:33 <deicide> http://www.haskell.org/haskellwiki/Monads_as_computation
18:50:54 <deicide> it explains bind
18:50:55 <byorgey> deicide: I think you'll make a lot more progress if you back up and learn about other aspects of Haskell and its type system first
18:50:56 <deicide> as "If x is a computation, and f is a function from potential results of that computation to further computations to be performed, then x >>= f is a computation which runs x, then applies f to its result, getting a computation which it then runs. The result of this latter computation is the result of the combined one."
18:51:08 <Axman6> hmm, so this is annoying. writing some code that's getting a stack overflow, nothing new there, but since it's code i'm expecting first year students to write, i can't use most of the tricks i'd usually use (extra strictness, better data structures etc). I need to somehow get a histogram of the number of occurances of each byte in a bytestring without blowing the stack
18:51:16 <hpc> byorgey: someone should make http://www.haskell.org/haskellwiki/Monads_as_Monads
18:51:21 <hpc> :D
18:51:27 <mauke> deicide: yes, and >>= is the only way to get at the results of the computation
18:51:32 <DanBurton> byorgey already made it. it's called typeclassopedia :D
18:51:32 <Jafet> @quote dolio monads
18:51:32 <lambdabot> dolio says: Monads are just monads in the 2-category of categories.
18:51:44 <ski> (mauke : in general)
18:51:51 <mauke> deicide: if you take that away, you only have a computation
18:51:56 <hpc> Jafet: that's so delightfully useless
18:52:08 <deicide> oh wow
18:52:13 <byorgey> hpc: hehe
18:52:19 <deicide> i just realized that that was a kinda stupid question...
18:52:22 <deicide> it's like...
18:52:23 <deicide> take a type
18:52:25 <deicide> take a function
18:52:27 <deicide> apply that function
18:52:30 <deicide> hurray!
18:52:35 <DanBurton> exactly
18:52:52 <mauke> Axman6: foldl'/Array?
18:52:55 <DanBurton> that is why bind is special. it allows a different sort of "function application"
18:53:01 <deicide> byorgey: what aspect of its type system are you referring to?
18:54:11 <deicide> DanBurton: but i don't understand how simply "unboxing" that first computation makes that much of a difference. could you explain more?
18:54:23 <mauke> deicide: it's not a box
18:54:32 <DanBurton> yes that ^
18:54:33 <mauke> unless you consider boxes made of magic
18:54:39 <byorgey> deicide: nothing in particular.  Just enough so that you can intuitively and immediately see why  m a -> (m a -> m b) -> m b  is an uninteresting type
18:54:55 <monochrom> deicide: I think you read too many essays and too little concrete examples (actual code and what they do)
18:55:01 <hpc> deicide: more relevantly perhaps, why (a -> m b) -> (m a -> m b) is an interesting type
18:55:08 <deicide> byorgey: i know, I realized the trivialness of my question
18:55:13 <hpc> deicide: (that is, the type of (=<<))
18:55:25 <deicide> monochrom: haha probably
18:55:29 <DanBurton> deicide: =) don't worry, everyone here secretly loves talking about monads
18:55:40 <deicide> haha i figured
18:55:43 <deicide> #haskell ffs
18:55:45 <DanBurton> even the ones that pooh-pooh monad tutorials
18:55:47 <mauke> deicide: for an unhelpful example, consider a box that when you open it, secretly clones the universe and gives you different results in each world
18:55:58 <monochrom> you can almost justify any ridiculous type by talking yourself into it. doesn't mean you can write actual useful code
18:56:00 <Jafet> It's the closest we'll ever get to being astronauts.
18:56:43 <mauke> deicide: in some cases it will turn 1 universe into 0, effectively destroying the world :-)
18:56:55 <DanBurton> > [1,2,3] >>= (\x -> [x, -x])
18:56:55 <lambdabot>   [1,-1,2,-2,3,-3]
18:57:05 <DanBurton> is that considered useful? ^
18:57:19 <mauke> DanBurton: no, I've never needed that :-)
18:57:21 <deicide> DanBurton: nevertheless, why does simply replacing <m a> with <a> in that function signature radically change its functionality?
18:57:33 <DanBurton> mauke: you haven't done enough code golf/obfuscation then xD
18:57:34 <deicide> (im trying to reword my question without referring to boxes :))
18:57:53 <hpc> @djinn m a -> (m a -> m b) -> m b
18:57:54 <lambdabot> f a b = b a
18:58:05 <hpc> @djinn m a -> (a -> m b) -> m b
18:58:05 <lambdabot> -- f cannot be realized.
18:58:07 <mauke> deicide: consider e.g. m = []
18:58:11 <DanBurton> deicide: it's not just that. It's that the m has to be a monad. Monad is a type class that classifies type constructors such as IO, Maybe, List, etc
18:59:00 <DanBurton> you cannot write that function for all such types, which is why there is a typeclass to classify the "special" ones that *can*
18:59:23 <deicide> oh ok
18:59:33 <deicide> so it's not that that particular type signature has intrinsic value
18:59:42 <Jafet> > flip id <$> [1,2,3] <*> [id,negate]
18:59:43 <lambdabot>   [1,-1,2,-2,3,-3]
19:00:03 <deicide> but that it offers a useful methodology for classification?
19:00:04 <DanBurton> well, it does have intrinsic value. it's just not possible for all types. it's only possible for "Monads"
19:00:21 <deicide> i suppose my question is then
19:00:26 <deicide> why is it unique
19:00:27 <byorgey> deicide: try some examples already =)
19:00:35 <deicide> what about it makes it only possible for "monad" types?
19:00:48 <DanBurton> think of it the other way around
19:00:52 <DanBurton> it *is* unique
19:01:00 <byorgey> monad types are those for which it is possible.
19:01:02 <DanBurton> and we will call types that satisfy this uniqueness "monads"
19:01:11 <DanBurton> so then the question is why is it unique
19:01:22 <DanBurton> well the answer is because not all types can fill the role of "m"
19:02:20 <DanBurton> so then I suppose you could ask: why can't all types fill the role of "m"?
19:02:52 <deicide> i suppose
19:03:26 <deicide> more pressingly, what is the commonality between these types which subjugates them into those signatures?
19:04:15 <mauke> huh?
19:04:24 <monochrom> http://homepages.inf.ed.ac.uk/wadler/topics/monads.html#marktoberdorf "monads for functional programming" is essentially the only thing you should read. none of those postmodern essays about "computation". (what is "computation"?) real, motivating examples instead.
19:04:48 <DanBurton> are you trying to understand monads at a purely theoretical level, or at a as-used-by-Haskell level?
19:05:14 <deicide> im just exploring a buncha languages right now
19:05:46 <DanBurton> I highly recommend http://learnyouahaskell.com
19:05:58 <deicide> alright
19:06:00 <DanBurton> it's a nice "exploring" level book on Haskell
19:06:13 <monochrom> "monad as computation" is in the same genre as "survivial of the fittest". what is "fittest"? answer: those who survive. what is "computation"? answer: those who are monads.
19:06:15 <adnauseam> <3 lyah
19:06:26 <deicide> i actually have "Introduction to functional programming" by Bird
19:06:44 <deicide> Introduction to functional programming using haskell*
19:06:45 <deicide> by bird
19:06:55 <deicide> what to do? :o
19:07:02 <DanBurton> deicide: how comfortable are you with higher order functions, foldr, map, etc?
19:07:22 <deicide> i'd fare fairly well
19:07:29 <deicide> i've read sicp
19:07:39 <deicide> learned most of scala
19:07:41 <deicide> etc.
19:07:46 <deicide> (minus monads :()
19:07:49 <DanBurton> you could probably skim the first few chapters then, whichever book you read on Haskell
19:07:56 <deicide> :'(
19:08:08 <ski> well, you need to learn the type system of Haskell
19:08:22 <DanBurton> @where typeclassopedia -- also comes highly recommended
19:08:22 <lambdabot> http://www.haskell.org/haskellwiki/Typeclassopedia
19:08:35 <monochrom> bird's book is good too. tons of actual code and zero postmodern essay.
19:08:48 <deicide> is it significantly different from other statically typed languages? e.g. scala?
19:08:58 <monochrom> actual code and actual behaviour is what to understand
19:09:08 <monochrom> concrete before abstract. special before general.
19:09:52 <DanBurton> the things that set Haskell apart from similar languages like Scala, ML, etc: 1) laziness by default. 2) effects are encoded in the types. 3) ghc has cool language extensions coming out all the time
19:10:14 <deicide> what do you mean by #2?
19:10:14 * ski thinks Scala and the MLs aren't that similar
19:10:25 <shergill> mauke: sorry about the delay. why do you feel that stdout can't be "redirected" to stdin 'that way'? what did you mean by 'that way'? functions like createProcess/readProcess are able to accomplish it
19:10:27 <ski> deicide : no side-effects
19:10:41 <deicide> oh i gotchu
19:10:51 <DanBurton> deicide: in ML and Scala, you can have a function with input type of Unit, or output type of Unit
19:10:57 <DanBurton> those usually indicate a side effect of some sort
19:11:08 <deicide> dont you have IO in haskell?
19:11:11 <deicide> or RealWorld
19:11:13 <DanBurton> in Haskell, effects are more explicit
19:11:14 <deicide> or w/e
19:11:15 <mauke> shergill: I don't "feel", I know. createProcess doesn't do this
19:11:26 <monochrom> notice for example how you can write "getChar >>= \c -> putStrLn (if 'c' then "nice" else "bad")" with the standard type of (>>=). with your proposed type IO a -> (IO a -> IO b) -> IO b, you can't do that.
19:11:33 <DanBurton> deicide: the way GHC models IO is with a State monad using a RealWorld token, yes
19:11:49 <mun> hi
19:11:58 <deicide> monochrom: haha i know
19:12:02 <monochrom> err, getChar >>= \c -> putStrLn (if c=='c' then "nice" else "bad")
19:12:04 <DanBurton> mun: hello!
19:12:12 <deicide> i realized a while ago that that was a completely stupid question
19:12:28 <mauke> shergill: at least on unix, a Handle is a wrapper around a file descriptor + some buffers
19:12:42 <mun> i have a question more about logic: if a model M = {a,b} and a model N = {a,b,c} where a b and c are propositional variables, then what could one say about the relationship between M and N? how about that M 'subsumes' N?
19:12:50 <mauke> shergill: output functions write into a buffer, which is periodically flushed to the file descriptor
19:13:02 <shergill> mauke: agreed.
19:13:18 <mauke> shergill: for interprocess communication, pipes are used
19:13:22 <DanBurton> mun: in general, or in Haskell specifically?
19:13:28 <mun> DanBurton, in general.
19:13:56 <mauke> shergill: pipe() creates a pair of connected file descriptors. then dup2() is used to overwrite the file descriptors 0, 1, 2 (stdin, stdout, stderr) with pipe ends
19:13:58 <deicide> monochrom: thanks for the wadler paper
19:14:00 <DanBurton> mun: in general, I'd say N <: M (<: meaning "is a subtype")
19:14:03 <deicide> it looks good thus far
19:14:33 <DanBurton> mun: but Haskell doesn't have record subtyping like that, or any subtyping at all except sort of at the typeclass level, so beware
19:14:40 <mun> DanBurton, but in terms of propositional logic, is there a relation between M and N?
19:14:48 <mauke> shergill: I see two problems with doing this from within a process
19:15:03 <shergill> mauke: right. and there is a function in GHC.IO.Handle which accomplishes this redirection i believe: hDuplicateTo
19:15:06 <DanBurton> mun: no clue. I'm unfamiliar with the terms of propositional logic
19:15:09 <mauke> shergill: 1) the state of the buffers is unknown. you'd effectively reach in and mess with Handle internals
19:15:21 <mauke> shergill: 2) potential deadlock
19:15:27 <mun> DanBurton, right. thanks.
19:15:34 <DanBurton> mun: "subsumes" sounds sort of like "is a subtype" though, so that's looking like a good conclusion
19:16:26 <byorgey> other way around, M <: N.
19:16:41 <shergill> mauke: wouldn't 1 be solved by flushing the buffers?
19:16:56 <mauke> shergill: you can't flush input buffers
19:17:33 <shergill> mauke: the output buffer i meant. why would you be concerned of the input buffer at all?
19:17:38 <DanBurton> byorgey: wait, isn't it the way I said? if N has {a,b,c} and M has {a,b}, then N <: M because N is more specific
19:17:43 <shergill> /s/of/with
19:17:46 <mauke> shergill: good question
19:18:02 <deicide> DanBurton, byorgey: if i wanted to learn more about the theoretical underpinnings of language theory, e.g. category theory, type theory, lambda calculus, etc. is there a particular text you guys would suggest?
19:18:21 <DanBurton> deicide: Types and Programming Languages
19:18:25 <DanBurton> @where tapl
19:18:25 <lambdabot> http://www.cis.upenn.edu/~bcpierce/tapl/
19:18:43 <deicide> what prerequisites does it assume?
19:18:48 <DanBurton> maybe not category theory, but it's got good stuff on types and lambda calculus
19:18:52 <DanBurton> it's pretty self-contained
19:19:02 <dolio> TaPL doesn't have anything about category theory, if I'm not mistaken.
19:19:19 <byorgey> you are not mistaken.
19:19:37 <dolio> Not that you necessarily need it.
19:19:46 <byorgey> DanBurton: X <: Y means "X is a subtype of Y" means "X can safely be used anywhere a Y is expected".  If you are expecting to get something from {a,b} it would not work to get a c.
19:20:18 <byorgey> DanBurton: M is more specific because it has fewer values.
19:20:33 <DanBurton> byorgey: oh right, you mean in terms of "the values of X are {a,b}". I was thinking in terms of record syntax
19:20:51 <mauke> shergill: I don't understand what hDuplicateTo does
19:21:08 <byorgey> oh, in terms of record syntax I agree. but mun was asking about sets of propositional variables.
19:21:27 <mun> yeah
19:21:28 <DanBurton> right; my mistake.
19:21:59 <shergill> mauke: redirects, if this guy is to be believed: http://nominolo.blogspot.com/2010/04/haskell-tip-redirect-stdout-in-haskell.html
19:22:25 <mauke> shergill: that still doesn't tell me what it does
19:22:33 <deicide> DanBurton: are you sure? the introduction refers to "graduate seminars" and stuff, so doesn't that imply a full college cs curriculum? (im still in high school :'()
19:23:16 <mauke> hmm. but we are in the same process and in haskell space
19:23:20 <DanBurton> deicide: hrm..it's true that a CS undergrad degree is the ideal prereq for that book
19:23:36 <byorgey> deicide: it is a graduate-level textbook, but it should be accessible to a motivated high schooler who knows some ML and Scala and Haskell
19:23:55 <deicide> ok
19:23:57 <shergill> mauke: perhaps this will then? http://www.haskell.org/ghc/docs/6.12.1/html/libraries/base/GHC-IO-Handle.html#v%3AhDuplicateTo
19:24:00 <mun> byorgey, hold on. but isn't it that the value of c is unknown in M, so isn't it more general than N?
19:24:07 <mauke> shergill: no
19:24:07 <byorgey> deicide: familiarity with mathematical induction is the one thing I can think of that would be helpful that you may or may not have
19:24:16 <ski> deicide : Haskell has I/O, but no I/O *side*-effects (as ML and Scale does have)
19:24:26 <shergill> mauke: look at the source in that case?
19:24:27 <krey_> what the best way for a man to get his matrices when he needs them (det, mult, inv)?
19:24:32 <deicide> haha don't worry, i've had to do more than my fair share of mathematical induction
19:24:37 <mauke> shergill: have you tried that? I have :-)
19:24:55 <deicide> (concrete mathematics will do that to you)
19:25:09 <byorgey> deicide: ok, you should be good then.  I don't promise you'll be able to make it *all* the way through the book on a first read, but you will certainly get something out of reading as far as you can
19:25:22 * DanBurton wishes he read TAPL in high school
19:25:22 * byorgey <3 concrete mathematics
19:25:36 <deicide> DanBurton: what aspects of a cs undergrad does it presume?
19:25:48 <DanBurton> deicide: no clue xD
19:26:12 <deicide> byorgey: alright thanks. but what's ML exactly?
19:26:14 <DanBurton> deicide: i am currently reading it as a CS undergrad senior,
19:26:18 <byorgey> not much actually
19:26:21 <DanBurton> @where ML
19:26:21 <lambdabot> I know nothing about ml.
19:26:25 <DanBurton> o_O
19:26:31 <DanBurton> shame on you, lambdabot. shame.
19:26:32 <byorgey> deicide: oh, it's a programming language, I thought you mentioned it earlier, but maybe you didn't
19:26:38 <shergill> mauke: i did, but didn't really dig into 'how' hDuplicateTo works. as for 'what' it does, i trusted the documentation
19:26:43 <deicide> haha nah
19:26:53 <mauke> shergill: but the documentation is vague
19:26:57 <deicide> Java, Lisp, Scala, and attempting haskell :)
19:27:06 <byorgey> oh, I see, someone else mentioned it
19:27:16 <DanBurton> then again, what is the "official" link for ML? sml? ocaml?
19:27:16 <deicide> but i see the name "ML" mentioned it all over the place when i first started to read about haskell
19:27:23 <shergill> mauke: the documentation tells you what it accomplishes. it's not the job of the documentation to explain how it does that. for that you have the source =/
19:27:32 <mauke> shergill: no, it doesn't tell me what it does
19:28:16 <mauke> shergill: e.g. a big question is: will programs started after 'hDuplicateTo h stdout' also write to h?
19:28:20 <mauke> or will they see the old stdout?
19:28:23 * DanBurton wonders what a Haskell-tainted version of TaPL would be like, rather than the current ML taint
19:29:26 <deicide> oh kwl
19:30:13 <deicide> the guy who wrote "Tapl" is apparently from upenn, so if i get in, i can ask him all about it :)
19:30:32 <DanBurton> byorgey is at upenn :)
19:30:37 <byorgey> deicide: yes, you can =)
19:30:40 <deicide> (why all these abbreviations for books??? :()
19:30:58 <deicide> byorgey: haha i applied there
19:30:59 <DanBurton> tapl, lyah, yamt, rwh, abbreviations are kewl
19:31:02 * byorgey and dmwit are both at upenn
19:31:11 <byorgey> deicide: cool, good luck!
19:31:20 <shergill> mauke: stuff sent to stdout will get redirected to h. that's how i read it
19:31:22 <deicide> is the cs department legit?
19:31:28 <byorgey> deicide: very
19:31:32 <deicide> i know that upenn is more known for business
19:31:35 <mauke> shergill: will this affect new processes?
19:31:46 <deicide> but it has a decent ranking for cs as well
19:31:55 <byorgey> deicide: we don't pay any attention to the dumb business students
19:32:06 <deicide> haha
19:32:12 <DanBurton> does anyone? :)
19:32:21 <byorgey> other business students? sometimes?
19:32:26 <shergill> mauke: i don't know. but it should be easy to find out
19:32:37 <deicide> byorgey: wait, so does the cs department there have a slant towards programming language theory?
19:33:05 <byorgey> deicide: the CS department as a whole is quite diverse.  But there is an excellent PL group (of which I am a part)
19:33:39 <deicide> aight
19:33:48 <adnauseam> pl group  ? :o
19:33:56 <byorgey> deicide: http://www.cis.upenn.edu/~plclub/
19:34:10 <deicide> i know that yale has a nice pl group as well
19:34:39 <AfC> You know, PL as in PL/SQL! :)
19:34:57 <deicide> DanBurton: what are all these abbreviations?
19:35:00 <deicide> "tapl, lyah, yamt, rwh"
19:35:22 <DanBurton> tapl = types and programming languages. lyah = learn you a haskell. yamt = yet another monad tutorial. rwh = real world haskell
19:35:25 <adnauseam> woah nice
19:35:29 <monochrom> "high-schooler who know some ml and haskell and scala" must be a very bored high-schooler to have time caring even a bit about all those 3 languages :)
19:35:52 <adnauseam> bless them
19:35:57 <adnauseam> need more high schoolers like that
19:36:06 * DanBurton spent much of his high-schooler time playing super smash brothers melee
19:36:30 <DanBurton> precious memories...but not quite as useful as Haskell
19:36:33 <deicide> skyrim and cod3 :)
19:36:37 <byorgey> APL, STLC, CIC, GHC...
19:36:40 <deicide> monochrom: haha no
19:36:45 <deicide> cool story
19:36:53 <deicide> i started cs by hacking this game called runescape
19:36:57 <deicide> thought it was very beautiful
19:37:15 <deicide> stereotypical field-of-interest romance from there
19:38:02 <cheater_> @where tapl
19:38:03 <lambdabot> http://www.cis.upenn.edu/~bcpierce/tapl/
19:38:06 <cheater_> @where lyah
19:38:06 <lambdabot> http://www.learnyouahaskell.com/
19:38:09 <cheater_> @where yamt
19:38:09 <lambdabot> I know nothing about yamt.
19:38:14 <cheater_> @where rwh
19:38:14 <lambdabot> http://www.realworldhaskell.org/blog/ http://book.realworldhaskell.org/read/
19:38:20 <cheater_> there you go adnauseam
19:38:24 <DanBurton> @google yet another monad tutorial
19:38:26 <lambdabot> http://mvanier.livejournal.com/3917.html
19:38:43 <Guest26576> @where sicp
19:38:44 <lambdabot> The Wizard book : "Structure and Interpretation of Computer Programs" at <http://mitpress.mit.edu/sicp/> by Hal Abelson,Gerald Jay Sussman with Julie Sussman, videos at <http://swiss.csail.mit.edu/
19:38:44 <lambdabot> classes/6.001/abelson-sussman-lectures/>
19:39:13 <deicide> omg those videos are so legit
19:39:21 <DanBurton> @where+ yamt http://mvanier.livejournal.com/3917.html
19:39:21 <lambdabot> Okay.
19:39:47 <DanBurton> I can't click on that link when it's broken in half, lambdabot T_T
19:40:18 <deicide> DanBurton: http://ocw.mit.edu/courses/electrical-engineering-and-computer-science/6-001-structure-and-interpretation-of-computer-programs-spring-2005/video-lectures/
19:40:37 <DanBurton> you're too kind :)
19:40:59 * BMeph wishes that as a high-schooler, he could've studied such fun languages, instead of the BASIC, C and Pascal he got stuck with instead... :(
19:41:04 <DanBurton> we should patch lambdabot to not break links in half, though
19:44:30 <DanBurton> ugh. missed the guild wars 2 beta sign up :(
19:44:53 <ski> DanBurton : SML and O'Caml are both MLs. then there's Alice ML, and also MetaML/MetaOCaml -- and more distant stuff like Coq and Ur
19:45:27 <ski> deicide : ML was the programming language they pioneered type-inference. today it is a family of languages, including SML and O'Caml
19:45:45 <BMeph> ski: Don't forget Mythryl (though I'm sure you'd like to...;)
19:45:50 <DanBurton> F# is an ML, isn't it?
19:45:56 <ski> yep
19:46:09 <ski> a derivative of O'Caml (with some things removed, i think)
19:46:17 <deicide> type-inference... to get the benefits of static type checking without its verbosity, correct?
19:46:24 <ski> yep
19:46:31 <deicide> aight
19:46:56 <ski> Haskell's type-system, with type-inference was inspired from the  Hindley-Milner one of ML
19:47:51 <deicide> lol, i tried to read a book written on lambda calculus and combinators by hindley... fell asleep in minutes
19:48:10 <Cale> Type inference is really important for making powerful type systems usable.
19:49:06 <BMeph> Cale: Really? And all this time, I thought it was for making usable systems powerful... ;)
19:49:35 <Cale> You can invent extremely powerful and expressive type systems, but if you force programmers to add type annotations to everything, it completely obliterates the use of your language for smaller programs.
19:49:43 <ski> BMeph : hm, was it you who mentioned that one recently to me ?
19:49:53 <deicide> haha FP for java... oh the angle brackets
19:50:32 <nyingen> and every other kind of bracket
19:50:37 <BMeph> ski: Might have; hopefully, I'm not the only esotericist around this joint. :)
19:50:58 <DanBurton> Fun<Int, <Fun<Int, Int>>> fun
19:51:10 <DanBurton> currrying: not fun
19:51:43 <ski> BMeph : hm, no, it was retlor
19:51:52 <deicide> ok fp in java reminded me of another question... what is a product type?
19:52:30 <DanBurton> it's like a tuple
19:52:42 <ski> deicide : `A * B' is a product type of `A' and `B' means that each value of type of `A * B' contains one value of type `A' and one value of type `B'
19:53:02 <ski> deicide : in Haskell, the product type of `A' and `B' is written `(A,B)'
19:53:07 <deicide> isn't that a tuple?
19:53:16 <ski> no, it's a tuple type
19:53:32 <byorgey> tuple types and tuple values have the same syntax.
19:53:43 <ski> unfortunately in Haskell, tuple types syntactically looks like tuples *of* types (a completely different thing)
19:53:44 <byorgey> which is either fortunate or unfortunate depending on your point of view.
19:53:46 <deicide> that's what i meant -.-'
19:53:55 <deicide> tuple type*
19:54:08 <ski> (in ML, the tuple type / product type of `a' and `b' is written `a * b')
19:54:27 <ski> product types correspond to the cartesian product of sets
19:54:43 <deicide> so product types are essentially tuple types?
19:54:46 <ski> with `A * B' being the set `{(a,b) | a \in A /\ b \in B}'
19:54:56 <ski> yes, it's the same things, just different names
19:55:19 <mauke> (1, 2) ∈ ℕ×ℕ
19:55:46 <deicide> oh i never thought about tuples as cartesian products
19:55:47 <otters> those are sexy looking Ns
19:55:51 <deicide> huh that's very interesting...
19:55:53 <ski> the name "*product* type" comes from the fact that when `A' and `B' are finite types/sets, then the number of values of type `A * B' is the product of the number of values of type `A' with the product of the number of values of type `B'
19:56:00 <ski> @src Bool
19:56:00 <lambdabot> data Bool = False | True deriving (Eq, Ord)
19:56:02 <ski> @src Ordering
19:56:03 <lambdabot> data Ordering = LT | EQ | GT
19:56:20 <deicide> ski: what do you mean by "finite"?
19:56:25 <ski> `Bool' has two values, and `Ordering' has three values, and `(Bool,Ordering)' has six values, `6 = 2 * 3'
19:56:32 <mauke> deicide: non-infinite
19:56:35 <ski> (not counting partially defined values)
19:56:39 <deicide> the example given by mauke, for instance, theoretically has an infinite number of values
19:56:57 <deicide> ℕ
19:58:04 <ski> similarly the name "sum type" comes from the fact that the number of values of type `A + B' is the *sum* of the number of values of type `A' and the number of values of type `B'
19:58:17 <ski> the sum type of `A' and `B' is in Haskell written as `Either A B'
19:58:40 <ski> so `Either Bool Ordering' has five values, because `2 + 3 = 5'
19:58:57 <deicide> ski:
19:58:59 <deicide> but the product type
19:59:00 <deicide> ℕ×ℕ
19:59:05 <deicide> has an infinite number of values
19:59:10 <wyvern> is this the right place to get help with the 'ideah' haskell plugin for intellij?
19:59:12 <ski> there's also exponential types `A^B', written in Haskell as `B -> A'
19:59:21 <ski> deicide : yes ?
19:59:43 <otters> exponential types?
19:59:44 <otters> omg
19:59:59 <ski> wyvern : could be, if you can find anyone here who knows about that thing
20:00:13 <deicide> but didn't you say "`A' and `B' are finite types/sets"
20:00:36 <ski> otters : yeah, `Bool^Ordering' (actually written `Ordering -> Bool' in Haskell) has eight values, `2^3 = 8'
20:00:53 <DanBurton> wyvern: it's unlikely that many people here use intellij for haskell coding. Feel free to ask, but if you don't get a prompt response, you might want to try StackOverflow instead
20:00:54 <mauke> deicide: no
20:00:56 <otters> sooo
20:01:01 <otters> (->) is the exponential type operator
20:01:01 <byorgey> deicide: "*when* `A' and `B' are finite types/sets, then...."
20:01:10 <byorgey> otters: yep
20:01:19 <ski> deicide : no, i said that *in the case* that `A' and `B' are finite types, the number of elements of the product type of `A' and `B' is the product of the number of elements of `A' and the number of elements of `B'
20:01:22 <otters> What about the kliesli arrow
20:01:27 <otters> kleisli
20:01:41 <deicide> ah ok
20:01:44 <byorgey> otters: what about it?
20:01:54 <otters> is it the same thing?
20:02:13 <deicide> so you were referring to the finite case in order to determine the number of values in the new product type
20:02:14 <byorgey> otters: what is "the Kleisli arrow"?
20:02:19 <ski> deicide : the product type `A * B' is defined even if `A' and `B' aren't both finite, but the name "product type" derives from that special case
20:02:42 <deicide> gotcha
20:02:48 * ski presumes otters means `Kleisli m' for some monad `m'
20:03:00 <otters> http://www.haskell.org/ghc/docs/latest/html/libraries/base/Control-Arrow.html#t:Kleisli
20:03:10 <ski> deicide : for some fun, we can now start with
20:03:13 <ski> @src []
20:03:13 <lambdabot> data [] a = [] | a : [a]
20:03:35 <ski> deicide : and rewrite this into `List a = 1 + a * List a'
20:03:36 <wyvern> DanBurton: out of curiosity, what do people generally use? just vim/emacs/etc ?
20:03:57 <wyvern> I know intellij upside down and backwards, at least from a java perspective, though i'm decent with vim
20:04:40 <DanBurton> vim and emacs are pretty common
20:04:42 <ski> deicide : then, we can imagine expanding this into `List a = 1 + a + a^2 + a^3 + a^4 + ...' -- saying essentially that an element of type `List a' is either an empty tuple, or an element of `a', or a pair of elements of `a', or a triple of elements of `a', &c.
20:04:45 <deicide> wait, so List is a product type?
20:04:50 <DanBurton> leksah is also sometimes used
20:05:02 <deicide> :O
20:05:12 <byorgey> List is a sum type.
20:05:19 <DanBurton> and then ides like eclipse/intellij are...there. but few people seem to actually use them for Haskell
20:05:24 <ski> deicide : no, but considering `(:) :: a -> List a -> List a', this is almost the same as `(:) :: (a,List a) -> List a' -- and you have a product type in there
20:05:27 <byorgey> it's a sum of 1 (the unit type) and a product type (a * List a).
20:05:45 <ski> deicide : i.e. in Haskell terms, we could redefine it as `data List a = Nil | Cons (a,List a)'
20:05:48 <wyvern> DanBurton: good to know. Well, I'll give this a shot anyway... It's asking for my GHC 'home directory' and I'm not sure what that should be.
20:05:52 <deicide> ogawd this is hurting my head :(
20:06:01 <wyvern> I do have ghc installed (via my distroy) and haskell-platform (built by hand)
20:06:19 <wyvern> s/distroy/distro/
20:06:34 <ski> deicide : then, we could further redefine it as `newtype List a = L (Either () (a,List a))' -- and writing `(Either () (a,List a))' with "algebraic notation" makes it into `1 + a * List a'
20:07:10 <wyvern> it doesn't seem to like /usr/lib/ghc-7.0.4 (where a bunch of stuff was installed)
20:07:21 <deicide> oh i see the correspondance now :o
20:07:29 <deicide> (Either () (a,List a)) <-> 1 + a * List a
20:07:39 <ski> deicide : ok, if what i'm saying is incomprehensible to you, you may want to wait before attempting to understand it -- i just mentioned this as a fun way to think of types
20:07:42 <deicide> whao, that's pretty cool
20:07:54 <shapr> MostAwesomeDude: oh hai!
20:08:00 <deicide> ski: no this amazing
20:08:18 <ski> deicide : btw, this is (one reason) why it is called *algebraic* data types
20:08:54 <deicide> wait
20:08:57 <deicide> i might be completely off
20:09:02 <deicide> but is this an instance of godel numbering?
20:09:20 <ski> not quite
20:09:31 <DanBurton> wyvern: try /usr/bin
20:09:42 <ski> it would be gdel numbering if we also encoded each of these types in the type of natural numbers
20:09:53 <DanBurton> wyvern: I think you probably have to point it to where the actual ghc executable is, and it's probably not actually in /usr/lib/ghc-7.0.4/
20:10:05 <wyvern> ah, I see
20:10:11 <ski> deicide : what is even more fun is that we can take the *derivative* of "algebraic" type expressions like this -- and this makes sense and is actually useful :)
20:10:31 <wyvern> Hah. It wanted /usr. Odd. :)
20:11:01 <MostAwesomeDude> shapr: Hai :3
20:11:09 <deicide> by derivative
20:11:30 <deicide> are you referring to d/dx?
20:11:35 <ski> yes
20:11:49 <deicide> how is that meaningful?
20:12:01 <deicide> the rate at which lists grows?
20:12:18 <wyvern> ski: I'm getting more into all this type stuff; what are good references for this? I've already got Pierce's Types and Programming Languages on my list.
20:12:20 <ski> well, often you are interested in keeping track at a specific *position* in some data structure
20:12:52 <ski> it turns out that derivatives of types are related to this
20:13:28 <ski> e.g. you might have a list of workspaces, each containing a list of windows
20:13:52 <ski> also, you have a *current* workspace, and in that one, a *currently focused* window
20:14:07 <deicide> uh huh
20:14:11 <deicide> an element in a list of lists
20:14:23 <ski> or, you might have some kind of tree, and are focusing on a subtree of that tree
20:14:44 <ski> in any case, you might want to make local changes to the element/node that is the current one
20:15:05 <ski> and you might want to move locally around, to the previous element, or to the pareent node or the first child node, say
20:15:19 <ski> consider the case of lists
20:15:49 <ski> a good way to represent a list with a current position is the type `([a],a,[a])'
20:16:21 <deicide> that's a sum type composed of two product types right?
20:16:42 <ski> values of this type will be of form `(front,x,back)', representing the list `front ++ [x] ++ back', with the element `x' marked/focused
20:16:58 <ski> no, that's a product type of three factors
20:17:09 <ski> `List a * a * List a' in the previous notation
20:17:34 <deicide> oh right
20:17:47 <ski> in fact, it's better to reverse `front'
20:18:06 <ski> so that `(front,x,back)' represents the list `reverse front ++ x : back'
20:18:17 <ski> that way you can define
20:18:45 <ski>   moveForward (front,x,next:back) = (x:front,next,back)
20:19:08 <ski>   moveBackward (previous:front,x,back) = (front,previous,x:back)
20:19:34 <ski> otherwise, one'd have to do `front ++ [x]' is the `moveForward' case, which is inefficient to do repeatedly
20:19:43 <deicide> yep
20:20:03 <ski> anyway, what does this have to do with derivatives ?
20:20:18 <ski> well, starting from a type, say `List a'
20:21:12 <ski> consider the type that we get if we take each value of type `List a', and "cross over" one value of type `a' in every such element
20:21:30 <ski> the type `List a' contains elements of the shape
20:21:33 <ski>   []
20:21:34 <ski>   [x0]
20:21:36 <ski>   [x0,x1]
20:21:39 <ski>   [x0,x1,x2]
20:21:41 <ski>   ...
20:22:00 <ski> the elements we get in this new type conceptually looks like
20:22:04 <ski>   [_]
20:22:09 <ski>   [x0,_]
20:22:13 <ski>   [_,x1]
20:22:22 <ski>   [x0,x1,_]
20:22:27 <ski>   [x0,_,x2]
20:22:34 <ski>   [_,x1,x2]
20:22:36 <ski>   ...
20:23:10 <ski> note specifically that when we "cross over" an element, we don't just remove it : we remember where the crossed-over element originally was
20:23:22 <mauke> that's just a list with a hole in it
20:23:27 <ski> yes
20:24:04 <ski> it turns out that it is useful to think of this new type as `d (List a) / d a'
20:24:17 <ski> let's take a tree example
20:24:41 <ski>   data Tree a = Leaf a              | Branch (Tree a) (Tree a)
20:24:47 <ski> elements of this type will look like
20:24:54 <ski>   Leaf x0
20:25:02 <ski>   Branch (Leaf x0) (Leaf x1)
20:25:16 <ski>   Branch (Branch (Leaf x0) (Leaf x1)) (Leaf x2)
20:25:28 <ski>   Branch (Leaf x0) (Branch (Leaf x1) (Leaf x2))
20:25:44 <ski>   Branch (Branch (Leaf x0) (Leaf x1)) (Branch (Leaf x2) (Leaf x3))
20:25:46 <ski>   ...
20:26:08 <ski> elements of the type `d (Tree a) / d a' will look conceptually like
20:26:13 <ski>   Leaf _
20:26:19 <ski>   Branch (Leaf _) (Leaf x1)
20:26:23 <ski>   Branch (Leaf x0) (Leaf _)
20:26:30 <ski>   Branch (Branch (Leaf _) (Leaf x1)) (Leaf x2)
20:26:37 <ski>   Branch (Branch (Leaf x0) (Leaf _)) (Leaf x2)
20:26:41 <ski>   Branch (Branch (Leaf x0) (Leaf x1)) (Leaf _)
20:26:43 <ski>   ...
20:26:54 <deicide> ok i gotta admit
20:27:01 <deicide> you're losing me
20:27:02 <ski> deicide : hopefully you should understand the basic idea now
20:27:05 <ski> ok
20:27:11 <deicide> but the idea is conceptually fascinating
20:27:22 <deicide> that you can use things like derivatives in type theory...
20:27:35 <ski> anyway, the type `d (List a) / d a' represents a list with a "hole" in it
20:27:42 <shachaf> deicide: Well, you can see what the derivative is more directly by looking at the type as an algebraic expression.
20:27:47 <shachaf> Or did people already go over that?
20:28:01 <ski> to represent a list with a marked element, we just have to add the element back (but still remember where it was "removed" from)
20:28:16 <ski> this is the type `a * (d (List a) / d a)'
20:28:23 <ski> now, starting from
20:28:28 <ski>   List a = 1 + a * List a
20:28:32 <ski> one may algebraically derive
20:28:37 <shachaf> ski: Isn't the a already part of the derivative?
20:28:46 <ski>   d (List a) / d a  =  List a * List a
20:29:05 <ski> i.e. to represent a list with a hole, just take a pair of the list before the hole, and the list after the hole
20:29:08 <deicide> ski: from where can i acquire a background to understand what you're talking about? :)
20:30:32 <mauke> http://strictlypositive.org/diff.pdf
20:30:47 <deicide> ski: bridge this conceptual gap for me
20:31:18 <tromp__> ski, what is the meaning of -1 in the algebraic view of types?
20:31:22 <deicide> a derivative is a function which gives the instaneous rate of change at certain points in the domain of the function
20:31:28 <ski> deicide : well "The Derivative of a Regular Type is its Type of One-Hole Contexts" by Conor McBride in 2001 at <http://strictlypositive.org/diff.pdf> is more or less the starting point of this idea
20:31:42 <deicide> how does that relate to holes in types?
20:32:05 <ski> (though there's probably stuff in theory of species and generating functions and algebraic combinatorics which precedes it to some extent)
20:32:18 <krey_> how do I get e (Euler's number) in haskell?
20:32:26 <mauke> > exp 1
20:32:27 <lambdabot>   2.718281828459045
20:33:03 <mauke> > deriv exp x
20:33:03 <lambdabot>   1 * exp x
20:33:07 <ski> tromp__ : well, `-1' would be a type `MinusOne' such that `Either () MinusOne' was isomorphic to `Void' -- such things doesn't exist in normal interpretations at least
20:33:20 <krey_> mauke: cheers
20:33:41 <mauke> > deriv (2 * sin) x
20:33:42 <lambdabot>   2 * (1 * cos x)
20:33:42 <ski> deicide : well, that is a strange puzzle i don't understand (i'm not sure whether anybody understands it yet)
20:33:57 <shachaf> krey_: e corresponds to the type Bag, of course. :-)
20:34:01 <shachaf> Er, Nat.
20:34:20 <krey_> shachaf: huh?
20:34:22 <ski> deicide : but the fact is that this "Type of One-Hole Contexts" satisfies the usual derivative laws like `d (f a * g x) / d a  =  f a * (d (f a) / f a) + () *'
20:34:37 <mee> ski, do the aforementioned exponential types have another name?
20:34:41 <shachaf> Bag x = 1 + x + x^2/2 + x^3/6 + ... = e^x
20:34:44 <shachaf> Obviously. :-)
20:35:01 <ski> er `d (f a * g x) / d a  =  f a * (d (g a) / d a) + (d (f a) / d a) * g a'
20:35:05 <deicide> ok ill give it another go after i learn some more type theory :)
20:35:35 <ski> mee : maybe "implicational types" sometimes -- apart from the obvious "function types", i.e.
20:35:36 <deicide> ski: at this point, papers like the one you showed still scare the hell outta me
20:35:43 * krey_ wonders what shachaf's obsession with Bags is
20:35:56 <shachaf> krey_: I guess you weren't talking about types anymore, were you?
20:36:09 <ski> deicide : yea -- at least for me, the way i learned to read papers like that was by trying to read them :)
20:36:20 * hackagebot structured-mongoDB 0.3 - Structured MongoDB interface  http://hackage.haskell.org/package/structured-mongoDB-0.3 (DeianStefan)
20:36:42 <deicide> i need to get over the notation first
20:37:11 <ski> deicide : though i probably started with simpler ones, like the monad paper someone mentioned to you, and other monad and other type system papers by Philip Wadler, Simon Peyton-Jones, and others
20:37:14 <deicide> atm, im just trying to get a broad view of many aspects of cs
20:38:02 <ski> deicide : yea, i understand how the notation can be a barrier. i distinctly remember when i saw someone on usenet explaining that the division-looking horizontal line in typing rules (and other inference rules) meant
20:38:27 <deicide> yeah
20:38:31 <deicide> like
20:38:34 <deicide> the problem
20:38:37 <deicide> is the intimidation
20:38:59 <ski> deicide : anyway, for completeness, the type `d (Tree a) / d a' can be encoded in Haskell as `data DTree a = Hole | InLeft (DTree a) (Tree a) | InRight (Tree a) (DTree a)'
20:39:14 <deicide> like... i know that horizontal bar means inference rules
20:39:16 <deicide> but when i see it
20:39:21 <deicide> im like
20:39:28 <deicide> :o *run away
20:40:03 <monochrom> do you also run away if you see French?
20:40:23 <ski> (because `DTree a  =  d (Tree a) / d a  =  d (a + Tree a * Tree a) / d a  =  1 + d (Tree a * Tree a) / d a  =  1 + (d (Tree a) / d a) * Tree a + Tree a * (d (Tree a) / d a)  =  1 + DTree a * Tree a + Tree a * DTree a')
20:40:24 <mauke> oui
20:40:27 <deicide> actually, yes
20:40:32 <deicide> french scares the crap outta me
20:40:38 <deicide> every day during french class
20:40:43 <deicide> i duck for cover
20:40:58 <Modius> Does haskell's standard IO lib or other have stuff that can replicate the functionality of .net's "asynchronous" IO primitives?  (Maybe I don't grok enough haskell/that this is the default)
20:40:59 <lambdabot> Modius: You have 1 new message. '/msg lambdabot @messages' to read it.
20:41:10 <mauke> ceci n'est pas une fifo
20:41:11 <ski> deicide : i think you need to just try to continue even if you don't understand everything. also ask about specific things which you don't understand
20:41:19 <deicide> ok
20:41:29 <deicide> actually, i should make an account on freenode...
20:41:40 <deicide> too bad they don't let mibbit be a webclient..
20:41:49 <deicide> this webchat thing is soo minimalistically ugly
20:42:05 <ski> deicide : still, some papers are more theory-heavy-wise (and don't explain as much basics) as others, so try some other paper if one paper seems hard -- you may be able to return to the first one later
20:42:06 <mauke> can't you just use a real client?
20:42:28 <deicide> ski: alright
20:42:39 <deicide> i think i need to read some more books before i start delving into the papers
20:42:46 <deicide> mauke: what do you suggest?
20:43:02 <mauke> deicide: what OS are you on?
20:43:13 <deicide> the ones i've encountered look almost as bad (or worse, e.g. mIRC) as this webchat business
20:43:17 <shachaf> Modius: I don't know what .NET's asynchronous I/O primitives are like, but GHC 7's I/O manager will turn "blocking" I/O operations into asynchronous OS calls that only "block" its lightweight userspace threads, not OS threads.
20:43:19 <deicide> atm, im using windows
20:43:19 <ski> deicide : well, getting a basic intuitive grasp of the most important concepts in the type system of Haskell would be good, yes
20:43:29 <ski> :)
20:43:45 <mauke> I have no real experience with irc on windows
20:44:06 <ski> deicide : do you prefer terminal-based or GUI clients ?
20:44:14 <deicide> haha GUI clients
20:44:40 <deicide> (does that make me unpro?)
20:44:44 <ski> deicide : you might try X-Chat 2 <http://www.silverex.org/download/>
20:44:52 <deicide> ski: well, i think i know the basic type system at least (unless you're talking about higher-kinded types or something)
20:46:07 <ski> well, at least function types (like ones of kind `* -> *' and `* -> * -> ... -> *') is probably needed for understanding derivatives of types
20:47:16 <ski> otherwise i think you just need to become familiar with how to read (and think about) inference rules (especially ones for type systems)
20:47:48 <deicide> function types aren't conceptually difficult
20:48:10 <deicide> any exposure to higher-order functions and currying should make understanding any chain of * -> * -> etc. a cinche
20:49:54 <deicide> it's mapping that understanding of types to its implications that's kinda difficult
20:49:58 <ski> higher-order types are possibly a bit more difficult to get used to (compare first-order functions vs. higher-order functions) -- but conceptually it's the same idea : parameterize a definition by abstracting out parts (whether they have kind `*' or `* -> *' or `(* -> *) -> * -> *')
20:49:58 <deicide> like
20:50:09 <deicide> the bind signature
20:50:13 * ski nods
20:50:28 <deicide> m a -> (a -> m b) -> m b
20:50:33 <deicide> isn't difficult to understand per se
20:50:48 <deicide> but what it means and how it fits into its functionality
20:50:52 <ski> but understanding what it's good for might be more difficult ?
20:50:53 <deicide> that's the more difficult part
20:50:57 <deicide> yep
20:53:12 <ski> re keeping track of a current position. if you want to keep track of a current sub-tree of a tree, this is a tree *zipper*, zippers are related to derivatives of types (but isn't the same thing)
20:54:35 <ski> (in the derivative example for trees above, an *element* of the tree was removed, using this we can keep track of a current *element*. if we want to keep track of a current *sub-tree*, then we need a tree zipper)
20:55:10 <deicide> <mauke> I have no real experience with irc on windows
20:55:14 <deicide> what os do you primarily use?
21:00:00 <nyingen> deicide: he programs on the bare metal
21:00:19 <deicide> lol
21:03:10 <deicide> brb
21:03:34 <nyingen> (and by bare metal, we mean bare silicon, a non-metal)
21:07:31 * ski . o O ( <http://en.wikipedia.org/wiki/Metallic_hydrogen> )
21:11:48 <monochrom> indeed, the phrase "bare metal" is most ironic when describing someone who supposedly know the hardware
21:14:26 <monochrom> another one is "explain, in plain English, which functions to call in what order". in plain English, functions are organized and attended, not called.
21:16:23 <nyingen> that's a very strange definition of "plain english"
21:16:24 * hackagebot type-unary 0.2.0 - Type-level and typed unary natural numbers, inequality proofs, vectors  http://hackage.haskell.org/package/type-unary-0.2.0 (ConalElliott)
21:17:21 <Cale> In my English, functions are applied, not called ;)
21:32:56 <gentleben> bare metal is when there are no ops peeps involved
21:33:12 <gentleben> adding VMware
21:33:21 <gentleben> and their other stuff
21:39:58 * mgsloan inadvertently starts his own containers API https://github.com/mgsloan/crdt/blob/master/src/Data/CRDT/Classes.hs
21:47:05 <beginner> hai
21:47:09 <beginner> a question
21:47:19 <shachaf> Where?!
21:47:21 <beginner> let say I have a function add that takes to argument
21:47:32 <beginner> is the only way to pass a negative integer
21:47:45 <beginner> is by surrounding them in brace?
21:48:22 <beginner> i.e: add 1 (-1)
21:48:55 <shachaf> beginner: Yep.
21:49:09 <shachaf> Otherwise it'll get parsed as subtraction, i.e. (add 1) - (1)
21:49:16 <shirt> if i writeTVar and then retry, the write still happens, right?
21:49:32 <beginner> alright, thanks
21:51:42 <ddarius> shirt: No.
21:52:10 <shirt> ddarius: say what?
21:52:47 <ski> > let negative_integer = -1  in  abs negative_integer
21:52:48 <lambdabot>   1
21:53:32 <ski> shirt : that's the point of `retry', to cancel the transaction so far, and retry from the start
21:54:34 <shirt> hm....
21:54:48 <yezariaely> can I tell haskell during compilation to print all the infered subtypes?
21:55:11 <yezariaely> I kind of am stuck somehow within my where, I want to know the subtypes for the variables it infers
21:56:07 <tsanhwa> @hoogle gets
21:56:08 <lambdabot> Data.Monoid getSum :: Sum a -> a
21:56:08 <lambdabot> Control.Monad.Trans.RWS.Lazy gets :: (Monoid w, Monad m) => (s -> a) -> RWST r w s m a
21:56:08 <lambdabot> Control.Monad.Trans.RWS.Strict gets :: (Monoid w, Monad m) => (s -> a) -> RWST r w s m a
21:56:16 <strager> I often end up explicitly typing things to make sure I'm doing things right.
21:59:19 <ski> @type Control.Monad.State.gets
21:59:20 <lambdabot> forall s a (m :: * -> *). (MonadState s m) => (s -> a) -> m a
22:06:35 <beginner> > 1 + 1
22:06:35 <lambdabot>   2
22:06:48 <nyingen> > True /= False
22:06:49 <lambdabot>   True
22:10:46 <yezariaely> Ah, I found a solution. I can annotate a subexpression with a definitely wrong type and it will show me the infered oe
22:10:49 <yezariaely> one
22:16:36 <liyang> yezariaely: you can use () for that. Or data Dunno = Dunno.
22:16:47 <dmwit> data Void
22:17:09 <dmwit> forall a. a -- is a good type for that, too
22:17:27 <liyang> There's no constructor for Void though.
22:17:36 <dmwit> liyang: Oh, you noticed? =)
22:17:51 <shachaf> Void main()
22:17:53 <dmwit> That's what makes it a good choice: you *know* the thing doesn't have that type, because nothing has that type.
22:17:57 <dmwit> (except undefined, of course)
22:18:21 <JoeyA> :t fix error
22:18:22 <lambdabot> [Char]
22:18:31 <liyang> dmwit: I mean in that you can't put Dunno down where an expression is expected.
22:21:01 <laufer> @pl (\x xs ys -> (x:xs):ys)
22:21:01 <lambdabot> ((:) .) . (:)
22:36:03 <krey_> does readFile do anything funny?
22:36:17 <mauke> yes
22:36:42 <krey_> mauke: what is it?
22:36:51 <mauke> lazy I/O
22:37:03 <nyingen> zing!
22:40:51 <hpaste> krey_ pasted “krey_ failz” at http://hpaste.org/64475
22:41:12 <krey_> mauke: can you tell me why the paste above fails?
22:42:00 <mauke> fails how?
22:42:24 <krey_> mauke: [*** Exception: Prelude.read: no parse
22:42:34 <krey_> fails for any number in place of 2
22:42:38 <mauke> seems pretty obvious
22:43:00 <mauke> it fails because read throws an error
22:43:54 <krey_> but the error happens always at the end
22:44:03 <mauke> eh?
22:44:08 <krey_> (previously I printed out lines successfully processed)
22:44:19 <mauke> looks like the beginning to me
22:45:07 <laufer> @pl (\x xs ys -> if p x then ys else x:xs)
22:45:07 <lambdabot> ap ((.) . flip . if' . p) (:)
22:47:14 <hpaste> krey_ annotated “krey_ failz” with “krey_ failz (annotation)” at http://hpaste.org/64475#a64476
22:47:19 <ddarius> http://cache.spreadshirt.net/users/563000/562298/articleFamilies/698/698_designImage_large.jpg
22:47:50 <mauke> krey_: proves nothing
22:48:04 <mauke> also this is not a test case
22:48:25 <krey_> mauke: what am I messing up again?
22:48:27 <mauke> I can't run this
22:48:45 <krey_> what should I change?
22:49:02 <mauke> *** Exception: cs-training.csv: openFile: does not exist (No such file or directory)
22:49:17 <mauke> remove readFile; hardcode data
22:52:34 <hpaste> krey_ annotated “krey_ failz” with “krey_ failz (annotation) (annotation)” at http://hpaste.org/64475#a64479
22:52:53 <krey_> mauke: fair enough, I did as you said, the error persists
22:53:21 <mauke> and now we can see why
22:53:40 <mauke> > read "1,1,0.766126609,45,2,0.802982129,9120,13,0,6,0,2" :: [Double]
22:53:40 <lambdabot>   *Exception: Prelude.read: no parse
22:54:15 <mauke> > read "[1,1,0.766126609,45,2,0.802982129,9120,13,0,6,0,2]" :: [Double]
22:54:16 <lambdabot>   [1.0,1.0,0.766126609,45.0,2.0,0.802982129,9120.0,13.0,0.0,6.0,0.0,2.0]
22:55:29 * krey_ hides in shame
22:55:33 <krey_> thanks mauke
22:56:29 * hackagebot HaskellLM 0.1.1 - Pure Haskell implementation of the Levenberg-Marquardt algorithm  http://hackage.haskell.org/package/HaskellLM-0.1.1 (KietLam)
23:13:19 <laufer> @pl (\x xs ys -> (f x):ys)
23:13:19 <lambdabot> const . (:) . f
23:52:05 <Axman6> @hoogle Handle -> ByteString -> IO Int
23:52:05 <lambdabot> System.IO hGetBuf :: Handle -> Ptr a -> Int -> IO Int
23:52:05 <lambdabot> GHC.IO.Handle hGetBuf :: Handle -> Ptr a -> Int -> IO Int
23:52:05 <lambdabot> System.IO hGetBufNonBlocking :: Handle -> Ptr a -> Int -> IO Int
23:52:17 <Axman6> @hoogle+
23:52:17 <lambdabot> GHC.IO.Handle hGetBufNonBlocking :: Handle -> Ptr a -> Int -> IO Int
23:52:17 <lambdabot> System.IO hGetBufSome :: Handle -> Ptr a -> Int -> IO Int
23:52:17 <lambdabot> System.IO hPutBufNonBlocking :: Handle -> Ptr a -> Int -> IO Int
23:52:27 <Axman6> @hoogle+
23:52:27 <lambdabot> GHC.IO.Handle hPutBufNonBlocking :: Handle -> Ptr a -> Int -> IO Int
23:52:27 <lambdabot> Text.Regex.Base.RegexLike matchCount :: RegexLike regex source => regex -> source -> Int
23:52:27 <lambdabot> Prelude flip :: (a -> b -> c) -> b -> a -> c
23:52:37 <Axman6> :(
23:53:09 <ChristianS> Axman6: what do you want to do?
23:53:39 <shachaf> write()?
23:53:51 <shachaf> Well, not quite the system call, but something along those lines.
23:54:01 <Axman6> a function that i can give a (lazy) bytestring, write it out, and tell me how many bytes it's written (so i don;t have to call length on the bytestring)
23:55:07 <Axman6> though actually, these bytestrings aren't too big, so i could convert them into a strict bytestring and use that
23:56:05 <monad_> Is there a possibility to match against several constants in a case statement like: case expr of 1 | 0 -> foo; _ -> bar
23:56:09 <osa1> what is the canonical json library for clojure?
23:56:15 <ChristianS> hm, there is Data.ByteString.Lazy.hPutNonBlocking :: Handle -> ByteString -> IO ByteString
23:56:15 <osa1> r/clojure/haskell
23:56:16 <ChristianS> "Similar to hPut except that it will never block. Instead it returns any tail that did not get written. This tail may be empty in the case that the whole string was written, or the whole original string if nothing was written.
23:57:13 <ChristianS> osa1: aeson, i think (though personally it looks overkill to me, but i never tried)
23:57:20 <Enigmagic> foldM (\ !acc el -> B.hPut handle el >> return (B.length el + acc)) 0 (Bl.fromChunks yourLazyByteString)
23:57:28 <shachaf> ChristianS: I don't think Axman6 is looking for non-blocking behavior.
23:58:40 <osa1> ChristianS: ok, I hava a huge JSON file exported from a mysql database, is it OK to load it at once? or is there a way to lazily parse it?
23:58:49 <c_wraith> ChristianS: actually, aeson is pretty slick, though there's a bit of a tough stretch at the start of the learning curve.  Once you get used to it, it's pretty simple to write code that just works nicely.
23:58:57 <shachaf> length on a small lazy ByteString is probably not that bad, either, in most case.
23:59:32 <c_wraith> osa1: aeson isn't good for that.  it uses too many strict structures internally to read lazily
23:59:33 <Axman6> Enigmagic: yeah, i might do that instead
23:59:39 <shachaf> Converting the ByteString to a strict ByteString might actually make sense if it's made up of a bunch of very small chunks -- will hPut do a system call per chunk?
23:59:48 <osa1> c_wraith: so what are my alternatives?
