00:00:02 <DijkstraGroupie> Axman6: Yeah, I wanted to get to this point.
00:00:14 <ski> no, there is a simple graph-rewriting operational semantics which you can assume is what happens, unless the compiler manages to do some more clever improvement
00:00:38 <DijkstraGroupie> Axman6: The compiler might be very smart, but if I am too stupid to understand in what ways this compiler is smart, the compiler's "smartness" is worth nothing.
00:01:00 <Axman6> this is true of pretty much any compiler, if you're interested in performance
00:01:28 <DijkstraGroupie> Axman6: Of course, but I never expect, say, a C++ compiler to fundamentally change the evaluation strategy of a function.
00:01:55 <Axman6> why would you in haskell too?
00:02:06 <DijkstraGroupie> Axman6: Of course I would not in Haskell.
00:02:11 <ski> DijkstraGroupie : in particular, if you pass an expression as an actual parameter to a function, only as much of that expression is evaluated as to determine which defining equation of that function to use (as a first step, then more can be evaluated later)
00:02:29 <Axman6> > 3^2397 -- seems pretty fast to me
00:02:30 <lambdabot>   456717405653619457158287937858369746809611633557468378057351180523271444724...
00:02:33 <DijkstraGroupie> ski: I understand what laziness means. You don't have to tell me.
00:02:58 <DijkstraGroupie> ski: But a "non-smart" implementation of laziness would be terribly inefficient.
00:03:12 <ski> (so far i haven't been talking about laziness, just by-name)
00:03:17 <ski> DijkstraGroupie : why ?
00:03:20 <DijkstraGroupie> Axman6: I would like to know in what specific ways a Haskell compiler should be smart.
00:03:33 <Axman6> DijkstraGroupie: do you know anything about haskell?
00:03:55 <Axman6> because giving you answers will depend pretty strongly on your understanding of the language
00:04:04 <DijkstraGroupie> Axman6: Other than the syntax and what the result of the computations performed should be, nope.
00:04:20 <Axman6> that sounds like a no. time to go learn and come back later ;)
00:04:28 <ski> DijkstraGroupie : why would a non-smart implementation of laziness be terribly inefficient ?
00:05:09 <DijkstraGroupie> ski: Say I have a sorting function that takes a comparison function and a list as its parameters.
00:05:53 <DijkstraGroupie> ski: An optimizing compiler could inline the comparison function.
00:06:18 <ski> not if the comparision function depended on run-time input
00:06:25 <Axman6> inlining is one key optimisation that is made amazingly simple in pure languages like haskell
00:06:26 <ion> How is that related to laziness?
00:06:27 <DijkstraGroupie> ski: Of course.
00:06:35 <ski> DijkstraGroupie : but do go on
00:07:30 <DijkstraGroupie> ski: How does the compiler decide whether it can inline the comparison function?
00:07:59 <ski> are you talking about GHC here, or generally ?
00:08:17 <DijkstraGroupie> ski: I want to understand the principles.
00:08:32 <Axman6> but optimisations are pretty compiler specific
00:09:04 <DijkstraGroupie> Oh, I just came up with (what I think is) a better example.
00:09:06 <ski> well, if it knows the definition of the function at this point, it *can* inline -- doing that isn't always a good idea, though
00:09:11 <Sugarlake> franco00, your problem is that the files are DOS encoded. So when you run it under Linux you have to remove character 13 (Carriage Return)
00:09:24 <DijkstraGroupie> Say you define a function that is more easily evaluated if its list parameter is an array instead of a linked list.
00:09:36 <ddarius> Inlining is an important transformation, but, by itself, not the difference between blazing fast and terribly inefficient.
00:10:09 <ion> -funroll-loops -O999
00:10:19 <DijkstraGroupie> Does the compiler detect the oportunity to optimize the program by switching from using a linked list to using an array?
00:10:21 <franco00> Sugarlake: I thought so, but I made a new file in linux (with vim), and I have still a similar problem. Unfortunately I cannot upload it now, since I am on a win machine with no access to the other one... I am on armhf, maybe that could be a problem_
00:10:31 <ddarius> DijkstraGroupie: Does a C++ compiler?
00:10:46 <DijkstraGroupie> ddarius: Nope. Of course I have to know when to use vectors and lists.
00:10:48 <silver> DijkstraGroupie, ask at #ghc
00:11:04 <silver> or look at source
00:11:08 <ddarius> DijkstraGroupie: Are you aware of any language implementation that does that?
00:11:21 <DijkstraGroupie> ddarius: Of course not.
00:11:28 <ski> DijkstraGroupie : in general that would be semantics-changing. in special cases it might not matter, but it sounds hard to me to check for that
00:11:34 <Axman6> DijkstraGroupie: that's often not a great idea in haskell, because our linked lists can be infinitely long
00:11:34 <DijkstraGroupie> ddarius: But Haskell invites you to always use lists instead of arrays.
00:11:43 <Axman6> no it doesn't
00:11:55 <ion> It certainly doesn’t indeed.
00:12:35 <DijkstraGroupie> ddarius: Well, true, a language cannot *invite* you to do anything, but...
00:12:40 <Jafet> In fact, there are more than three interfaces to arrays!
00:12:45 <Sugarlake> franco00, it definitely  works with unix encoding. Go into vim and do ": set fileformat=unix" then save the file
00:13:00 <Sugarlake> franco00, it should work
00:13:01 <Jafet> Clearly it is encouraged to use them.
00:13:17 <franco00> Sugarlake: can you paste the output? should I put the fileformat thing in my linux machine too?
00:13:55 <DijkstraGroupie> What the heck is this "do" thing?
00:13:58 <ddarius> Haskell has more array types than any language I know.
00:14:30 <silver> DijkstraGroupie, syntax sugar for chaining monadic stuff with >>
00:14:30 <Sugarlake> franco00, when i search for "bru" for example i get: BRUNO VITUMO \n ascd \n  ac \n  dsc \n  ad
00:14:44 <Sugarlake> franco00, without unix encoding nothing is printed
00:14:45 <silver> <- is for >>=
00:14:54 <franco00> Sugarlake: so it works as expected....
00:15:05 <ion> silver: That was an excellent explanation.
00:15:14 <Jafet> A female deer.
00:15:19 <DijkstraGroupie> Why so many array types?
00:15:22 <franco00> thanks Sugarlake , I probably did something wrong with vim
00:15:31 <Sugarlake> franco00, just do what i told you: ": set fileformat=unix" then save in VIM
00:16:16 <franco00> Sugarlake:  I will do it as soon as possible, still I consider quite a bug, for I created a new file on the linux machine (with vim palla.txt). That should be default imho.
00:16:53 <ski> DijkstraGroupie : sometimes you want mutable arrays, sometimes immutable ones are ok
00:17:10 <Sugarlake> franco00, when you do just ":set fileformat" then VIM prints the current format. it should display (unix) not (dos)
00:17:11 <Axman6> DijkstraGroupie: the original array types weren't really designed for speed. more recent implementations (vector, repa, and the data parallel array stuff) are more aimed at performance
00:17:12 <DijkstraGroupie> ski: Okay. That one I get.
00:17:37 <Jafet> Probably because some programmer wanted arrays to work like they did in their favourite language, and so wrote another one
00:17:40 <Axman6> for repa and DPH, they aim to give you parallelism for free basically (something that you can't do easily in non-pure languages)
00:18:04 <franco00> okie dokie Sugarlake , and thanks again
00:18:35 <DijkstraGroupie> Axman6: Besides functions that perform I/O, all my functions written in imperative languages are pure.
00:19:04 <Jafet> Then frankly, it sounds like you haven't done much programming.
00:19:23 <Axman6> DijkstraGroupie: no they're not, you mutate variables all the time
00:19:40 <DijkstraGroupie> Axman6: But they do not mutate the state of non-local variables.
00:19:41 * Axman6 -> out
00:19:47 <Axman6> so?
00:19:54 <Axman6> also, i highly doubt that
00:20:43 <DijkstraGroupie> Axman6: Why do you doubt that? After a lot of effort wasted debugging my programs, I decided that this style of programming would make my programs more understandable.
00:20:53 <DijkstraGroupie> (To me at least)
00:21:26 <quintessence> DijkstraGroupie: no objects with internal mutable state?
00:21:58 <DijkstraGroupie> quintessence: I have never been a fan of OOP, but AFAIK, objects are parameters to their own methods.
00:22:09 <DijkstraGroupie> (non-static methods)
00:22:22 <Jafet> "He uses an imperative language, he can't possibly know the true meaning of purity"
00:22:40 <Jafet> "Therefore we must argue with him instead of suggesting that he read LYAH"
00:22:45 <Jafet> @where lyah
00:22:46 <lambdabot> http://www.learnyouahaskell.com/
00:24:09 <ski> @quote world's.best
00:24:10 <lambdabot> SPJ says: Haskell is the world's best imperative language.
00:24:37 <Jafet> @quote undoubtedly
00:24:37 <lambdabot> _pizza_ says: i think Haskell is undoubtedly the world's best programming language for discovering the first few dozen numbers in the Fibonacci sequence over IRC
00:24:55 <franco00> hahah nice one
00:24:55 <DijkstraGroupie> What does that even mean? :S
00:26:26 <ski> > fix (\fibs -> 0 : 1 : zipWith (+) fibs (tail fibs))  -- presumably variations of this
00:26:27 <lambdabot>   [0,1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765,10946...
00:27:02 <DijkstraGroupie> ski: I know what, but... how come that is an imperative program?
00:27:26 <ski> i don't think it is
00:27:30 <DijkstraGroupie> ski: That program is an expression.
00:27:34 <yitz> > fix $ (1 :) . (1 :) . (zipWith (+) <*> tail)
00:27:35 <lambdabot>   [1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765,10946,1...
00:27:42 <ski> yitz : heathen
00:27:54 <franco00> I prefer the fib:fibs variation to the zipWith one
00:27:54 <DijkstraGroupie> ski: And imperative programming is all about programs being distinct than expressions.
00:27:57 <ion> > fix ((-55:) . scanl (+) 34)
00:27:58 <lambdabot>   [-55,34,-21,13,-8,5,-3,2,-1,1,0,1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,...
00:27:58 <yitz> ski: haha
00:28:03 <franco00> feels clearer to me
00:28:10 <ski> (yitz : .. for starting at `1' instead of `0', i.e.)
00:28:19 <yitz> ski: indeed
00:28:38 <ski> DijkstraGroupie : i don't agree
00:29:12 <Jafet> Imperative programming is all about programs being imperative.
00:29:50 <Jafet> Scheme, where every block is an expression, is imperative.
00:30:41 <ski> to me, imperative programming is about (sequencing and) side-effects, primarily state, but also jumps, continuations, exceptions, non-determinacy, &c.
00:35:07 <quintessence> "doing" "actions" with "control flow", you might say
00:35:16 <yitz> > let phi :: CReal; phi = (1 + sqrt 5)/2 in map (floor . (+0.5) . (/ sqrt 5) . (phi **)) [1..]
00:35:19 <lambdabot>   [1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765,10946,1...
00:35:27 <ddarius> Pure Prolog is an imperative language to ski.
00:35:59 <ski> hehe
00:36:32 <Jafet> quintessence: "if you get what I mean"
00:37:08 <ddarius> "I'm not aware of too many things.  I know what I know if you know what I mean."
00:37:31 <quintessence> monads let you make up your own actions and control flow constructs, and the do-notation lets you write things in an imperative style
00:37:48 <Ptival> what are you even discussing?
00:38:53 * ski . o O ( <http://en.wikipedia.org/wiki/ISWIM> )
00:39:23 <ski> Ptival : i don't know
00:42:06 * hackagebot ghc-mod 1.10.1 - Happy Haskell programming on Emacs  http://hackage.haskell.org/package/ghc-mod-1.10.1 (KazuYamamoto)
00:46:20 <drbean> The link in the ISWIM article to http://en.wikipedia.org/wiki/Algebraic_data_types is the first thing I have read that has made sense.
00:52:27 <ddarius> > takeWhile (/= 0.0) $ iterate (join (*)) 0.5
00:52:28 <lambdabot>   [0.5,0.25,6.25e-2,3.90625e-3,1.52587890625e-5,2.3283064365386963e-10,5.4210...
00:52:37 <ddarius> > last $ takeWhile (/= 0.0) $ iterate (join (*)) 0.5
00:52:38 <lambdabot>   5.562684646268003e-309
00:54:30 <ion> > fix (\n -> encodeFloat 1 (fst (floatRange n) - floatDigits n))
00:54:31 <lambdabot>   5.0e-324
00:55:07 <ion> > fix (\n -> encodeFloat 1 (fst (floatRange n) - 1)
00:55:08 <lambdabot>   <no location info>: parse error (possibly incorrect indentation)
00:55:22 <ion> > fix (\n -> encodeFloat 1 (fst (floatRange n) - 1))
00:55:23 <lambdabot>   2.2250738585072014e-308
00:56:53 <ion> > last (takeWhile (/= 0) (iterate (* 0.5) 1))
00:56:53 <lambdabot>   5.0e-324
00:58:05 <ddarius> > floatRange 1.0
00:58:06 <lambdabot>   (-1021,1024)
00:58:49 <ddarius> > let x = scaleFloat 512 1.0 in (x, x*x)
00:58:49 <lambdabot>   (1.3407807929942598e154,Infinity)
00:59:21 <ddarius> > let x = scaleFloat -511 1.0 in (x, x*x)
00:59:22 <lambdabot>   Overlapping instances for GHC.Show.Show (GHC.Types.Int -> a -> a)
00:59:22 <lambdabot>    arisin...
00:59:28 <ddarius> > let x = scaleFloat (-511) 1.0 in (x, x*x)
00:59:29 <lambdabot>   (1.4916681462400413e-154,2.2250738585072014e-308)
00:59:55 <ddarius> > let x = scaleFloat (-512) 1.0 in (x, x*x)
00:59:56 <lambdabot>   (7.458340731200207e-155,5.562684646268003e-309)
01:00:02 <ddarius> > let x = scaleFloat (-513) 1.0 in (x, x*x)
01:00:03 <lambdabot>   (3.7291703656001034e-155,1.390671161567e-309)
01:00:18 <ddarius> > let x = scaleFloat (-514) 1.0 in (x, x*x)
01:00:19 <lambdabot>   (1.8645851828000517e-155,3.4766779039175e-310)
01:01:33 <ddarius> > isDenormalized (scaleFloat (-514) 1.0 ^ 2)
01:01:34 <lambdabot>   True
01:02:33 <sipa> :t (^)
01:02:34 <lambdabot> forall a b. (Num a, Integral b) => a -> b -> a
01:03:03 <sipa> @src (^)
01:03:03 <lambdabot> x ^ 0            =  1
01:03:03 <lambdabot> x ^ n | n > 0    =  f x (n-1) x
01:03:04 <lambdabot>   where f _ 0 y = y
01:03:04 <lambdabot>         f x n y = g x n
01:03:04 <lambdabot>           where g x n | even n  = g (x*x) (n `quot` 2)
01:03:05 <lambdabot>                       | otherwise = f x (n-1) (x*y)
01:03:09 <lambdabot> _ ^ _            = error "Prelude.^: negative exponent"
01:06:15 <Liii> I have a function that reads one line the time from an input value. Passing around the list with the rest of the input is messy, it has to be passed to and returned from every call and every clause of this function. Is there a special kind of monad that could be used to hide the input that I read from? Or should you do this with the state monad?
01:07:20 <Jafet> ReaderT Fulfils Much
01:07:32 <ski> Liii : a parsing monad ?
01:07:32 <Liii> Im thinking about sort of a state monad, but that you only can mutate by removing on "element" at the time.
01:07:50 <jeltsch> I just discovered that Gtk2Hs cannot be build with GHC 7.4.1. See, for example, here: http://stackoverflow.com/questions/8963325/glib-gremlin-with-ghc-7-4
01:08:05 <jeltsch> Is there a solution to this problem?
01:08:11 <dcoutts> jeltsch: try the darcs version, I pushed a few fixes
01:08:27 <ski> Liii : you can easily define a wrapper around a state monad that enforces that stuff is only removed from the state
01:08:28 <jeltsch> dcoutts: I’ll try. Thanks.
01:08:36 <Liii> But Reader only changes env with local function, does not seem like a perfect fit.
01:08:45 <Liii> Ill look att det parse monad.
01:08:53 * jeltsch recognizes that it is the first time that he has to install a HEAD version in order to make things work with GHC 7.4.1.
01:09:03 <dcoutts> jeltsch: oh actually someone helpfully posted that as an answer in the stackoverflow page
01:09:18 * jeltsch recognizes that it is not the *first*, but the *third* time. ;-)
01:09:48 * jeltsch recognizes that he has only read the first answer before asking. :-(
01:09:59 <jeltsch> dcoutts: Sorry. :-(
01:10:02 <dcoutts> np
01:10:16 <dcoutts> I see the second answer is higher rated but not "accepted"
01:11:05 <Jafet> Welcome to stack overflow, where the points don't matter
01:12:34 <ion> hehe
01:12:44 <Peaker> Liii: Parser monads are indeed restricted state monads
01:12:55 <Liii> Ok
01:13:10 <ddarius> Usually with backtracking and failure as well.
01:13:18 <rahul_> Hi. if i have two functions [a] -> b and [a] -> c and if i compose them with &&&, is there any chance compiler will optimize this and fuse the loops?
01:13:43 <rahul_> like: (f &&& g) xs, where f :: [a] -> b, g :: [a] -> c, xs :: [a].
01:13:53 <ski> Liii : if you just want to get items, <http://hackage.haskell.org/package/monad-supply-0.1> might be simpler -- otoh, it might be more interesting to build the monad yourself
01:14:10 <Jafet> No, there isn't any. Even if they are both folds.
01:14:15 <ion> Supplies!
01:14:30 * ski . o O ( "supplies for the quick" )
01:14:51 <Liii> ski: Finding just the right library feels kind of nice also...
01:16:54 * ddarius tries to figure out how to write g x = f x / x so that it is c at 0 given f' 0 = c.
01:17:34 <ddarius> and f 0 = 0.
01:18:16 <ski> Liii : what should happen if you attempt to read a line, but the list is empty ?
01:18:24 * ddarius needs a representation for mathematically continuous functions.
01:18:33 <Liii> MonadSupply, seem just right, but theres not so much docs so I have to try it out. Cheers ski.
01:18:42 <ddarius> (That's not the representation that I'm trying to produce ...)
01:19:12 <Liii> You should be able to check if there are more input and handle that in different ways.
01:20:35 <ski> so that case will happen in your code, then ?
01:23:03 <Liii> Yes.
01:23:21 <Jafet> g x = lim (\x -> 0) (f x / x)
01:23:37 <Jafet> Er wait
01:23:43 <ski> @pl g x = lim (\x -> 0) (f x / x)
01:23:43 <lambdabot> g = lim (const 0) . ((/) =<< f)
01:23:51 <Liii> I dont see a way to check for that in the supply monad...
01:25:14 * ski neither
01:25:23 <Jafet> g x = lim (\w -> x) (\w -> f w / w) // fwiw
01:25:34 <ddarius> 0
01:25:53 * Jafet resist the urge to suggest iteratees
01:26:22 <ddarius> I suspect the supply monad is intended for infinite supplies.  You can change a finite supply into an infinite one by simply return Nothing once it is exhausted, and otherwise Just the next value.
01:26:35 <ddarius> This is a little ugly.
01:26:46 <Jafet> That won't work, unless you also supply lookahead.
01:27:02 <ski> `supply' for `SupplyT s' matches on `x:xs'
01:27:07 <Jafet> Hm, it might work
01:27:26 <ski> (with no `[]' case)
01:28:21 <jeltsch> Why doesn’t the gtk2hs darcs repository contain gtkglext and gtksourceview? Have these been abandoned?
01:28:47 <dcoutts> jeltsch: the main gtk2hs repo contains the core packages, the other packages are in separate repos
01:28:47 <ski> Liii : are you wanting to do "general parsing" or something more restricted ? -- possibly that's not an easy thing to answer, for you
01:29:14 <dcoutts> jeltsch: the other packages have different sets of contributors and release cycles, so it's easier that way
01:29:37 <Rmx> Is there a GHC pragma wich allow the compiller to evaluate some of the pure expressions during compilation time to save time after
01:29:37 <Liii> Heh, well its not a parser
01:29:40 * ski wonders how Liii would want to check for empty input -- back-tracking, or look-ahead, or something else ?
01:29:47 <dcoutts> jeltsch: I think they're all at http://code.haskell.org/$pkg
01:30:42 <ski> Liii : it might be reasonable to express it as one, even if you (currently) don't think of it as one (hard for me to tell)
01:30:47 <Liii> And Im not totally sure how I want to do this, but the problem seemed to be general enough to have a canonical solution.
01:31:14 * ddarius doesn't know where this thought that back-tracking or look-ahead is needed to tell when input is exhausted is coming from.
01:31:24 <Rmx> let's say I write plop = sum [0..1000]
01:31:24 <Jafet> Rmx: named expressions are generally evaluated at most once, so there is usually no need for this.
01:31:42 <Jafet> GHC calls them CAFs.
01:31:51 <Liii> Its not an error when there are no more input, you just continue in different ways when there is and when there is not.
01:32:00 <ski> if you just want `Supply', but also want to check for the end of input, you can do what ddarius suggested (or rewrite it yourself from scratch, it's not hard)
01:32:04 <Rmx> is there a way to tell ghc to compute it before create the executable ?
01:32:10 <jeltsch> dcoutts: Okay, thanks.
01:32:43 <ski> Liii : is this the time when you paste some code ?
01:33:15 <Jafet> Rmx: no.
01:33:28 <Rmx> this is strange, don't you think ?
01:33:31 <Jafet> In fact, plop is polymorphic, so there is no way to evaluate it ahead of time.
01:33:47 <Rmx> ok, so let's assume it's Int
01:33:57 <Jafet> Still no. Again, there is usually no need for this.
01:34:15 <Rmx> I saw numerous examples of code where such expressions were written.
01:35:00 <Rmx> People don't usually take the time to speed things up by manually replacing those expressions by their result
01:35:17 <Liii> ski: Hm, yeah that would be a lot clearer, but I dont have anything thats really working, just a non working mess... Ill have to be back some later time for that.
01:35:28 <ddarius> lift $(sum [1..1000])
01:35:52 <ddarius> Rmx: Indeed they don't.  Mostly because it doesn't matter.
01:36:15 <Jafet> Rmx: doing that slows programming down.
01:36:55 <Palmik> Hi guys, I have this simple TH code: http://hpaste.org/57621 but it does not do exactly what I want (see http://hpaste.org/57622 for what it does / what I want), could someone help me out? I'm probably missing something really simple (TypeSysInstD is not probably what I want).
01:36:59 <Rmx> I'm not sure to agree, but I can't really argue, so you probably won
01:37:05 <Liii> I guess in my case it would be enough if there was a supply function that simply returned a Maybe s.
01:37:32 <Rmx> I still don't understand why can't we ask GHC to precompilate some expressions for us
01:37:48 <Liii> I could take the SupplyMonad and just make an adoptation that does that.
01:38:20 <Rmx> I can't see any drawbacks to support such functionality
01:38:37 <Jafet> If you really want it, you can propose it on the GHC trac and submit a patch.
01:38:47 <Rmx> ok
01:38:52 <Rmx> thanks for your answers
01:41:11 <Baughn> Rmx: To some degree, the rewrite functionality can do that, but..
01:41:17 <ddarius> As can TH.
01:41:17 <Baughn> I mean, when combined with constant folding
01:41:37 <ddarius> As can turning up the inlining threshold.
01:41:43 <Baughn> But to do this in general, we'd need to be able to serialize arbitrary values
01:45:32 <Rmx> or preprocessor ?
01:45:53 <Rmx> I mean, I think it must be easy to build a small application
01:45:57 <Rmx> parser*
01:47:07 * hackagebot grapefruit-frp 0.1.0.1 - Functional Reactive Programming core  http://hackage.haskell.org/package/grapefruit-frp-0.1.0.1 (WolfgangJeltsch)
01:47:07 <Rmx> that just read the code, evaluate given expressions in ghc, then replace the code by the output, and add the commented code after
01:47:09 * hackagebot grapefruit-records 0.1.0.1 - A record system for Functional Reactive Programming  http://hackage.haskell.org/package/grapefruit-records-0.1.0.1 (WolfgangJeltsch)
01:47:11 * hackagebot grapefruit-ui 0.1.0.1 - Declarative user interface programming  http://hackage.haskell.org/package/grapefruit-ui-0.1.0.1 (WolfgangJeltsch)
01:47:35 <yitz> Rmx: yes, there is TH, that's what ddarius said.
01:47:39 <Rmx> oh
01:47:42 <Rmx> arf
01:48:03 <Rmx> TH = template haskell
01:48:28 <Rmx> ok, didn't know.
01:48:32 <Rmx> I'll go this way
01:48:33 <Rmx> thanks
01:48:38 <yitz> Rmx: you can use TH to tell GHC to do what you want in specific cases.
01:48:47 <dcoutts> Rmx: and for simple things, ghc will just inline/evaluate anyway
01:48:59 <Rmx> ok
01:49:04 <yitz> Rmx: to do it more generally and automatically, you'd have to define exactly in which cases you want this to happen
01:50:02 <yitz> Rmx: for example, you probably don't want the compiler to pre-compute [1..] for you and put it in your program.
01:50:20 <Rmx> sure! :)
01:50:43 <Rmx> but it would be nice for exampel to precompute the firsts elements of some infinite lists
01:50:56 <Rmx> let's say prime numbers up to 200, or so things
01:51:01 <yitz> Rmx: and as dcoutts points out, for many of the simple cases it already happens
01:51:37 <Rmx> hm.. inlining, yes, but evaluations is by default lazy
01:51:40 <yitz> Rmx: you're clearly going to have to specify that explicitly in each case. i wouldn't want my compiler doing that quietly behind my back.
01:51:48 <Rmx> yeah sure
01:51:55 <Rmx> that's what I want
01:52:06 <Rmx> all must be explicit
01:52:13 * hackagebot grapefruit-ui-gtk 0.1.0.1 - GTK+-based backend for declarative user interface programming  http://hackage.haskell.org/package/grapefruit-ui-gtk-0.1.0.1 (WolfgangJeltsch)
01:52:15 * hackagebot grapefruit-examples 0.1.0.1 - Examples using the Grapefruit library  http://hackage.haskell.org/package/grapefruit-examples-0.1.0.1 (WolfgangJeltsch)
01:52:17 <yitz> Rmx: so that's TH.
01:52:35 <ddarius> Laziness actually enables inlining.
01:53:00 <Palmik> Hi guys, I have this simple TH code: http://hpaste.org/57621 but it does not do exactly what I want (see http://hpaste.org/57622 for what it does / what I want), could someone help me out? I'm probably missing something really simple (TypeSysInstD is not probably what I want). <-- Any ideas?
01:53:05 <Rmx> I'm not so much speaking about inlining
01:53:13 <Rmx> more about precalculating expresion
01:53:14 <Baughn> @where fix
01:53:14 <lambdabot> I know nothing about fix.
01:53:30 <Baughn> @find fix
01:53:31 <lambdabot> Not in scope: type variable `fix'
01:53:38 <Jafet> @index fix
01:53:39 <lambdabot> Control.Monad.Fix, Control.Monad.Reader, Control.Monad.Writer, Control.Monad.State, Control.Monad.RWS, Control.Monad.Identity, Control.Monad.Error
01:53:48 <Baughn> Oh, thanks. ..wait, monad?
01:54:02 <Jafet> Supplies
01:54:20 <Jafet> :t Data.Function.fix
01:54:21 <lambdabot> forall a. (a -> a) -> a
01:54:29 <ddarius> Rmx: How would non-strictness negatively impact that?
01:55:06 <Rmx> I think there wouldn't be so much impact.
01:55:30 <Rmx> let's say we want to create a app who display the sum of the 100 000 firsts prime numbers
01:55:39 <Rmx> why not to definie it as a sum
01:55:50 <Rmx> let GHc precalculate it during some minutes
01:56:10 <Rmx> and then produce an executable that only consist in a "print result"
01:56:36 <ddarius> How is that relevant to the question I asked?
01:56:36 <Rmx> yeah, this case is stupid; one could have use a file text to store the result once for all, I agree
01:56:40 <Jafet> Sure. Write a TH program that precalculates this sum and writes it in the program.
01:56:43 <Rmx> hum..
01:57:07 <Rmx> ddarius, so I probably didn't understand your question, sorry
01:57:30 <Rmx> Jafet, yes, I opened the TH doc, will start soon :)
01:58:57 <Rmx> I thought it was a standard in every language to be able to do this without having to use other database lib or tools.
01:59:28 <Jafet> I don't know any language with such a standard
01:59:36 <Rmx> yeah, it's strange o_O
01:59:52 <Jafet> Perhaps you should find out why you are thinking strangely.
02:00:00 <Rmx> I'm trying ^^
02:00:35 <Rmx> really, storing things in the executable is the easiest way to do when you don't care about some extra memory in Ram
02:02:30 <Rmx> bits* in ram
02:03:07 <Baughn> Rmx: I agree. Nevertheless, I don't know any language that provides it by default.
02:03:10 <Baughn> It's very odd.
02:03:33 <Rmx> yeah!
02:03:48 <emph> Hey! Got a question regarding haskell-mode for emacs. I'm a emacs/lisp beginner so I havn't been able to solve it myself. Lets say i define a function; test = do bla bla. I then want the next line to be indented 4spaces, now it's 2. How do I change this behavior?
02:04:00 * ski . o O ( MetaML/MetaOCaml )
02:04:16 <Baughn> emph: M-x customize-group haskell-indentation
02:04:31 <ski> Rmx : do you know any such language ?
02:04:36 <Rmx> no :(
02:04:38 <Baughn> emph: Assuming that's the indentation module you're using
02:04:41 <emph> Ok, thanks. Will try it!
02:04:48 <emph> Yes
02:05:02 <Rmx> but people argue that memoizing is great and all, and they don't use the de-facto memoizing tool
02:05:07 <Baughn> emph: However, be aware that the default is 2 for a reason. :P
02:05:09 <ski> Rmx : so you're implying that Haskell is your first programming language ?
02:05:18 <emph> How come Baughn ?
02:05:23 <Rmx> no
02:05:30 <Rmx> I know C well
02:05:34 <Baughn> emph: It's easy, especially for beginners, to end up with deeply nested code
02:05:36 <emph> Is it said to be prefered in the Haskell Report?
02:05:45 <Rmx> and some other languages too
02:05:51 <Baughn> Not to my knowledge, but the haskell report only defines *requirements*. :P
02:06:11 <ski> Rmx : then how come you "thought it was a standard in every language to be able to ...", if you can't name any such language ?
02:06:16 <Baughn> emph: Also, other people will be using 2-space indentation, and may mess up your style in patches. However, you can override the indentation variable per-file to avoid that one.
02:06:25 <Rmx> no, but it appeared as an evidence to me
02:06:30 <Baughn> (Since per-file overrides will work on other machines too ;)
02:06:48 <emph> Ah ok so the 2 spaces is kind of standard? In that case I will continue to use it
02:06:58 <Rmx> that there were a way to do so.
02:07:33 <Rmx> I don't get the point to recalculate things over and over each time you launch a software
02:07:45 <Rmx> and everything around tends to the same conclusion
02:07:48 <Jafet> Rmx: http://www.ioccc.org/1988/applin.c
02:08:28 <Rmx> Jafet: ?
02:09:07 <Jafet> How to precompute primes in C.
02:09:07 <dcoutts> Rmx: precalculating things sounds easy, but actually it's hard (except in trivial examples like list of primes) because things are usually only partially constant
02:09:27 <dcoutts> Rmx: this leads into a lovely area of research called partial evaluation
02:11:57 <Palmik> OK, for anyone who is wondering what was wrong with the TH code I posted -- nothing, it's OK, just the generated code is different from the one displayed using -ddump-splices.
02:12:20 <Palmik> Context: http://hpaste.org/57621 http://hpaste.org/57622
02:13:38 <Rmx> dcoutts: I believe you. I just think People's laziness induce trivial examples not being precalculated :)
02:13:56 <Rmx> (not always*)
02:14:06 <dcoutts> Rmx: so most trivial examples are non-recursive, and that's solved by inlining
02:14:17 <dcoutts> most more complex examples are only partially static
02:14:46 <dcoutts> the in-between ones I guess are mostly large data structures that could have been data files
02:15:07 <Rmx> yes
02:15:36 <Rmx> I guess I was targeting those in-between. data files don't suits me
02:15:41 <Rmx> I'll go TH way
02:16:51 <Rmx> maybe I'm just wrong..
02:17:00 <Rmx> I now start to feel like it's a waste of time
02:17:24 <Rmx> I can just stop being lazy and write those horribles numbers or lists in my code, in separate files..
02:18:24 <ski> Rmx : <http://www.metaocaml.org/> might be interesting, re staged programming
02:22:38 <Rmx> I'm not sure about what they call delay computation, but for code visibility, it would be indeed cool to write "a = [precompute|  67**7 + 256 +12]" without  being afraid of performance loss
02:22:50 <Rmx> people would understand the detail of the formula
02:23:08 <Rmx> it would make code sharing more pleasant.
02:25:37 <Rmx> dcoutts : it's differenf from inlining, isn't it ?
02:26:42 <Baughn> Rmx: Well, I'm relatively sure constant folding works for /that/. :P
02:27:01 <Baughn> Rmx: Unless you have unusual Num instances or it can't narrow it down to a single type, of course
02:27:10 * Baughn sweatdrops
02:27:50 <dcoutts> Rmx: that numeric example would be handled just by inlining and constant folding
02:28:06 <Rmx> ok
02:28:41 <dcoutts> Rmx: inlining is usable very widely in a pure lazy FP language
02:28:48 <Rmx> I start to see why my question was partially irrelevant :)
02:28:51 <dcoutts> much more so than in C
02:29:18 <dcoutts> the restriction is that GHC never inlines recursive functions
02:29:27 <Rmx> I didn't realise those steps in compilations were pretty much doing what I was saying.
02:29:45 <Rmx> ah, great! ok.
02:30:00 <Rmx> is it possible to inline manually recursives functions, so ?
02:30:52 <Rmx> and hm... constant folding works for expressions that would require 10 min to calculate o_O ?
02:31:37 <Rmx> I guess constant folding must also not be compatible with lazy lists
02:31:56 <Rmx> or with anything else lazy
02:32:02 <Rmx> or with map, or..
02:33:19 <Rmx> do you think "plop = sum [1..10000]" will be optimised during inlining and constant folding step ?
02:33:35 <dcoutts> Rmx: no, it's perfectly compatible
02:34:05 <Rmx> hm... so my question was totally irellevant o_O ?
02:34:13 <dcoutts> Rmx: but remember I said that ghc will not inline recursive functions
02:34:20 <Rmx> arf
02:34:26 <Rmx> sum is recursive.
02:34:30 <dcoutts> so your example of sum [1..10000] will not be inlined
02:34:39 <dcoutts> [1..10000] is also recursive
02:35:03 <Rmx> thanks for the lesson :)
02:35:15 <Rmx> Good afternoon!
02:35:25 <dcoutts> you're welcome :-)
02:42:30 <burbul> Could someone tell me where in a cabal file I could add the option -rtsopts ? I've tried putting it under ghc-options: , but that doesn't work.
02:42:48 <dcoutts> burbul: that should work
02:42:55 <dcoutts> there's no other place to put it
02:42:56 <burbul> (I get an error message "postparse.exe: Most RTS options are disabled. Link with -rtsopts to enable them.")
02:43:30 <dcoutts> burbul: perhaps paste your .cabal file somewhere
02:44:13 <donri> burbul: ghc-options need to be in the executable section
02:44:16 <burbul> http://hpaste.org/57623. Thanks for looking at this...
02:44:35 <donri> that's missing indentation
02:44:49 <burbul> [ I'm not very used to cabal at all -- I'm just using it because Leksah requires me to. ]
02:45:08 <burbul> So that cabal file is generated by Leksah
02:45:14 <burbul> And I just pasted in the -rtsopts
02:45:30 <burbul> What should I indent?
02:45:46 <dcoutts> donri: it's not wrong, it's Cabal-1.0 format
02:45:53 <donri> oh ok
02:46:12 <burbul> My commandline looks like
02:46:20 <burbul> "$alms/postparse/postparse/dist/build/postparse/postparse" +RTS -sstderr "......."
02:48:03 <burbul> (I haven't played with RTS before either...  I'm just following the instructions from http://www.haskell.org/haskellwiki/Performance )
02:49:08 <burbul> Could it be related to this: http://hackage.haskell.org/trac/ghc/ticket/5114 ??
02:50:13 <donri> you may need to cabal clean to force the rebuild
02:50:48 <dcoutts> burbul: mm, it's odd, it works for me, running cabal build -v shows that it is calling ghc --make with the -rtsopts flag
02:51:26 <burbul> am cleaning
02:51:55 <dcoutts> burbul: and when you re-run, use cabal build -v
02:52:04 <dcoutts> so you see how cabal calls ghc
02:52:14 <burbul> Cleaning did the trick -- thanks!
02:52:42 <dcoutts> burbul: ooi, what does cabal --version say?
02:52:52 <dcoutts> and are you building using cabal, or using leksah?
02:52:54 <burbul> cabal-install version 0.10.2
02:52:54 <burbul> using version 1.10.1.0 of the Cabal library
02:53:02 <burbul> Using leksah
02:53:05 <dcoutts> ohh
02:53:14 <burbul> ohh?
02:53:21 <dcoutts> see "cabal build" notices when the .cabal file has changed and re-configures
02:53:29 <dcoutts> perhaps leksah does not
02:53:32 <burbul> ahh
02:53:35 <burbul> Thank you.
02:54:15 <burbul> I can run the test now, and it says that 20 percent of the time is spent in garbage collection, which seems very reasonable. Thanks!
03:01:37 * dcoutts notes that in ghc-7.4+ you no longer need the annoying -rtsopts for many common +RTS flags
03:02:02 <dcoutts> including -s that burbul was presumably using
03:02:15 <donri> plus ghc itself is sensitive to changing build options
03:05:34 <burbul> Is there an easy way to tell what version of ghc I have? (I just looked through ghc --help, but I can't see anything)
03:05:53 <donri> ghc -V
03:06:28 <burbul> Seems I have 7.0.3.  Possibly I should upgrade... just worried that it will break Leksah!
03:07:05 <burbul> Actually, could I ask one  more question?  Where might I find the equivalent of ~/.cabal/config on a Windows system?
03:07:18 <burbul> (I want to enable profiling, as outlined here: http://stackoverflow.com/questions/1704421/cabal-not-installing-dependencies-when-needing-profiling-libraries)
03:07:30 <dcoutts> burbul: %HOME%/cabal
03:10:15 <burbul> Can't find a HOME environment variable... I have HOMEPATH, but it doesn't have cabal under it
03:10:48 <donri> presumably C:\Users\burbul or somesuch?
03:10:50 <snorble> burbul: it is in Appdata\Roaming\cabal (on windows 7)
03:10:51 <dcoutts> oh, I thought windows had that
03:10:59 <burbul> XP
03:11:11 <donri> Documents and Users, then
03:11:33 <burbul> HOMEPATH=\Documents and Settings\Username   is where I've been searching
03:11:42 <donri> ah yea
03:11:52 <dcoutts> burbul: in ghci: System.Directory.getAppUserDataDirectory "cabal"
03:11:53 <snorble> there is a hidden application data directory there
03:12:13 <burbul> thanks!
03:12:31 <dcoutts> which calls some win32 function and the real location varies between windows versions
03:13:01 <Jedai> burbul: ghc 7.0.3 is very reasonable, you should probably stay with it until the Haskell Platform with GHC 7.4 is released (except if you really want to try GHC 7.4 now !)
03:13:50 <Jedai> burbul: cabal help gives you the directory where the config is (in the last line)
03:14:06 <burbul> Jedai: thanks!
03:14:29 <burbul> I've found the config and I'm now running ' reinstall world' in the hope of getting profiling running...
03:19:44 <burbul> Unfortunately I'm still getting
03:19:47 <burbul>     Could not find module `Data.Interned.String':
03:19:47 <burbul>       Perhaps you haven't installed the profiling libraries for package `intern-0.8'?
03:20:22 <burbul> "cabal install -p intern" doesn't do anything...
03:21:37 <rtharper> dcoutts__: ping?
03:22:35 <snorble> burbul: if you already have it install you'll need --reinstall
03:23:15 <burbul> I thought the 'reinstall world' (from the stackoverflow link) would take care of that...
03:23:31 <burbul> I'm trying reinstall now
03:28:10 <burbul> It works -- thanks! You're all fantastic!
03:36:35 <burbul> Am I right in thinking that >total alloc = 2,065,170,448 bytes  (excludes profiling overheads)
03:36:56 <burbul> Indicates something is going wrong with memory allocation? (There's no way the application should be using anything like 2GB.)
03:42:41 <Jafet> I've had programs use several TB
03:43:02 <Jafet> Of course, it's only a problem if the garbage collector doesn't periodically recycle them.
03:43:23 <byorgey> burbul: note that doesn't mean it was using 2GB *all at once*
03:43:36 <rostayob> Jafet: several TB of memory?
03:43:39 <burbul> Ah, I see, it's the cumulative usage, rather than the max one time .
03:43:41 <rostayob> ah, ok.
03:43:43 <burbul> *at one time
03:43:43 <byorgey> just that it allocated 2GB in total over the course of execution
03:43:51 <byorgey> right
03:44:02 <burbul> yes, that makes sense -- doesn't go above 5MB according to task manager.
03:44:19 <Jafet> It also had a maximum residency of 4GB or so
03:44:38 <burbul> I just can't figure out why my damn program is slow...
03:44:59 <burbul> When I profile I get that 100% of the time is being spent in MAIN and 0% in everything else, which isn't very helpful
04:12:20 * hackagebot haxr 3000.8.5 - XML-RPC client and server library.  http://hackage.haskell.org/package/haxr-3000.8.5 (GracjanPolak)
04:17:10 <MarconM> anyone here use emacs-haskell-mode
04:20:19 <khanzor> MarconM: using it right now :)
04:20:54 <khanzor> MarconM: well, i'm using the haskell major mode in aquamacs
04:52:05 <ozgura> hi. in ghc heap profiling, via -hy, what does * mean?
04:52:23 <ozgura> using ghc 7.4.1 btw.
04:54:11 <nand`> how do I import a hidden package? Specifically, I want to include Network.MPD.Commands.Util but GHC tells me it is hidden in package “libmpd”
04:54:20 <nand`> Or do I have to rewrite the package itself
04:54:29 <nand`> then again that might be the best idea in the long run
04:56:22 <NothingMan65> Hey guys!  STArray with strings?
04:56:29 <NothingMan65> (=
05:03:11 <donri> nand`: isn't it enough to list it in your build-depends?
05:03:25 <nand`> donri: I don't have a cabal project file though, this is a single file
05:03:53 <donri> nand`: so write one :)
05:12:24 * hackagebot Paraiso 0.2.0.1 - a code generator for partial differential equations solvers.  http://hackage.haskell.org/package/Paraiso-0.2.0.1 (TakayukiMuranushi)
05:31:48 <megajosh2> Hey, has anybody here successfully installed the curl package from Hackage on Windows?
06:13:19 <tigger> does anyone know if this is in ghc 7.2.1 and higher: http://hackage.haskell.org/trac/ghc/ticket/4340?
06:15:52 <byorgey> tigger: the ticket is still open, so no
06:16:54 <tigger> how do most packages do the alignment thing and make it cross platform? c2hs?
06:17:43 <Doggmann> hi
06:18:18 <byorgey> hi Doggmann
06:18:37 <Doggmann> guampa 'hey
06:19:09 <Emanoooo> hey peeps
06:19:29 <byorgey> hi Emanoooo
06:20:03 <Doggmann> guampa ' share my dick
06:20:09 <byorgey> @where ops
06:20:09 <lambdabot> shapr Cale glguy dons sjanssen dcoutts Saizan dibblego conal Philippa bos arjanb xerox Heffalump kosmikus wli Pseudonym Igloo quicksilver monochrom Lemmih jmcarthur copumpkin
06:20:23 --- mode: ChanServ set +o quicksilver
06:20:27 --- mode: quicksilver set +b *!*jojo@196.34.164.*
06:20:27 --- kick: Doggmann was kicked by quicksilver (thanks but no thanks)
06:20:40 <Emanoooo> So were u from byorgey	
06:20:50 --- mode: quicksilver set +b *!*emanuel@196.34.164.*
06:20:50 --- kick: Emanoooo was kicked by quicksilver (Emanoooo)
06:21:40 <Sgeo> Clearly, e just wanted to know if byorgey used to be from someplace.
06:21:45 <quicksilver> it was the same IP as Doggman
06:21:51 <quicksilver> so I assumed negative intent
06:22:10 <byorgey> quicksilver: indeed, I was about to mention that right before you kicked Emanoooo
06:22:19 <byorgey> I thought two people joining from the same IP address and saying "hi" boded ill
06:22:29 <quicksilver> it is sad, that that be true.
06:22:39 * Sgeo just wanted to make a joke about the bad spelling
06:22:41 <Sgeo> >.>
06:22:52 * Sgeo apparently is bad at jokes.
06:22:56 <byorgey> Sgeo: I got it =)
06:23:14 <quicksilver> no, I got the joke Sgeo ;)
06:23:19 <quicksilver> I was going to explain my action anyway
06:23:19 <byorgey> I did used to be from someplace actually.
06:23:24 <quicksilver> it wasn't directed at you
06:23:32 <quicksilver> byorgey: they chucked you out though, didn't they?
06:23:44 <quicksilver> join us noplacers, it's like an uncommunity.
06:23:49 <byorgey> yep
06:23:56 <yrlnry> I used to be from someplace too, but now I'm only from Philadelphia.
06:24:06 <byorgey> heh
06:24:39 <sipa> maybe we can create an asocial network through which we can uncommunicate
06:25:13 <yrlnry> My wife pointed out that native Philadelphians will not consider you a Philadelphian or "from Philadelphia" unless you were born there.  Whereas in contrast, the idea that you can't be a New Yorker without having been born there is just laughable, even to native New Yorkers.
06:26:53 <frerich> yrlnry: In Hamburg, Germany, many people don't consider you to be a 'native Hamburgian' unless you're living there in the third generation.
06:27:20 <yrlnry> There we see the difference between Europe and the U.S.A.
06:28:07 <yrlnry> I gather that a similar thing happens in Japan, that there are nth-generation Japanese who have to be careful that nobody finds out that their ancestors came from Korea in 1874.
06:30:56 <Philippa> hmm. If I have <!> for annotating terminal errors, is it bad that I'm tempted to use <!...> for non-terminal ones?
06:32:04 <byorgey> hehe, I like it =)
06:32:35 <byorgey> I think that is the longest operator I have ever seen which is actually semi-reasonable
06:33:04 <Philippa> yeah, though mostly because ... is mildly more practical than the single-char unicode equivalent
06:33:17 <byorgey> yeah
06:33:55 <donri> <elliott> |\/|/-\|-|-|=|\||} is my preferred mappend operator
06:34:27 <Philippa> were you around the other day when I explained that I'm using <?> for locations in which errors may occur (by analogy to Parsec's operator) and <!> for (replacing) error messages? With <!+> adding to the end of existing messages
06:34:34 <Philippa> ?
06:34:42 <Philippa> I'm pretty sure donri was :-)
06:34:58 <Igloo> donri: Sorry, you'll need to use |\/|/-\|-|-|=|\||> instead
06:35:31 <Philippa> just think of the outcry because 1337! isn't an operator
06:42:25 <matthiasgorgens> Does the standardlib have a function like merge::Ord a => [a] -> [a] -> [a]
06:42:31 <matthiasgorgens> which does the obvious thing?
06:42:40 <Rmx> :t |\/|/-\|-|-|=|\||
06:42:41 <lambdabot> parse error on input `|\/|/-\|-|-|=|\||'
06:42:49 <Rmx> :t (|\/|/-\|-|-|=|\||)
06:42:50 <lambdabot> Not in scope: `|\/|/-\|-|-|=|\||'
06:42:54 <Rmx> hm...
06:42:57 <Jaak> @hoogle Ord a => [a] -> [a] -> [a]
06:42:57 <lambdabot> Prelude (++) :: [a] -> [a] -> [a]
06:42:58 <lambdabot> Data.List (++) :: [a] -> [a] -> [a]
06:42:58 <lambdabot> Data.List insert :: Ord a => a -> [a] -> [a]
06:43:14 <byorgey> matthiasgorgens: actually, it doesn't
06:43:30 <matthiasgorgens> @hoogle Ord a => [[a]] -> [a]
06:43:31 <lambdabot> Prelude concat :: [[a]] -> [a]
06:43:31 <lambdabot> Data.List concat :: [[a]] -> [a]
06:43:31 <lambdabot> Data.List sort :: Ord a => [a] -> [a]
06:43:38 <matthiasgorgens> hmm, ok.
06:43:43 <byorgey> seems like that would be an obvious/nice thing to add though
06:43:45 <rata_> hi
06:44:01 <Jaak> @hoogle Ord a => Set a -> Set a -> Set a
06:44:02 <lambdabot> Data.Set (\\) :: Ord a => Set a -> Set a -> Set a
06:44:02 <lambdabot> Data.Set difference :: Ord a => Set a -> Set a -> Set a
06:44:02 <lambdabot> Data.Set intersection :: Ord a => Set a -> Set a -> Set a
06:44:48 <Jaak> there actually is Set.union tho
06:45:14 <matthiasgorgens> yes, and sets are sorted.
06:45:26 <matthiasgorgens> but they can't be infinite.
06:46:24 <byorgey> I wonder if  Set.toAscList (Set.union (Set.fromAscList xs) (Set.fromAscList ys))  is lazy
06:46:25 <quicksilver> yes, sorted list merge is a good function and should exist
06:46:32 <quicksilver> I don't think it does, though
06:46:48 <quicksilver> byorgey: nope, size-balanced trees are not at all lazy
06:46:57 <quicksilver> locating one element forces the entire skeleton IIRC.
06:47:06 <byorgey> ok, fair enough.
06:47:14 <quicksilver> because it forces the balancing operations
06:47:18 <byorgey> right.
06:47:27 <matthiasgorgens> I have merge (x:xs) (y:ys) = sort [x,y] : merge xs ys
06:47:32 <matthiasgorgens> plus handling for finite lists.
06:47:43 <byorgey> I don't think that works.
06:48:01 <byorgey> > let merge (x:xs) (y:ys) = sort [x,y] : merge xs ys   in   merge [1,2,3,4]  [5,6,7,8]
06:48:02 <lambdabot>   [[1,5],[2,6],[3,7],[4,8]*Exception: <interactive>:3:4-49: Non-exhaustive pa...
06:48:13 <matthiasgorgens> byorgey: plus handling for finite lists:
06:48:18 <matthiasgorgens> merge [] ys = ys
06:48:19 <matthiasgorgens> merge xs [] = xs
06:48:23 <byorgey> matthiasgorgens: I wasn't talking about that part.
06:48:31 <matthiasgorgens> oh, ok.
06:48:38 <matthiasgorgens> byorgey: but I see the problem.
06:48:40 <quicksilver> it's wrong on many many levels
06:48:53 <quicksilver> well, OK that's harsh
06:48:56 <quicksilver> it's wrong on two levels :)
06:49:07 <quicksilver> (1) it produces [[a]] not [a], (2) it gets it wrong.
06:49:29 <matthiasgorgens> merge (x:xs) (y:ys) = let [one, two] = sort [x,y] in one : merge (two:xs) ys
06:49:33 <byorgey> matthiasgorgens: you can only decide on one element at a time to put in the output
06:49:44 <matthiasgorgens> > let merge (x:xs) (y:ys) = let [one, two] = sort [x,y] in one : merge (two:xs) ys
06:49:45 <lambdabot>   not an expression: `let merge (x:xs) (y:ys) = let [one, two] = sort [x,y] i...
06:49:56 <matthiasgorgens> > let merge (x:xs) (y:ys) = let [one, two] = sort [x,y] in one : merge (two:xs) ys in merge [1,2,3,4]  [5,6,7,8]
06:49:56 <rtharper> just write this as an unfoldr =p
06:49:57 <lambdabot>   [1,5,6,7*Exception: <interactive>:3:4-79: Non-exhaustive patterns in functi...
06:50:16 <byorgey> matthiasgorgens: that doesn't quite work because you have to put 'two' back on the front of the correct list
06:50:27 <matthiasgorgens> oh, that new version is also wrong.
06:50:37 <matthiasgorgens> byorgey: yes, I do have to do that.
06:50:39 <byorgey> matthiasgorgens: don't bother using  sort [x,y], just compare x and y to see which is smaller and then decide what to do based on that.
06:51:40 <rtharper> agreed
06:52:08 <CodeWeaverX> i was about to ask why you were sorting a merge of two presumablly already sorted lists.
06:52:40 <rtharper> merge (x:xs) (y:ys) = if x < y then x : merge xs (y:ys) else y : merge (x:xs) ys
06:52:41 <CodeWeaverX> costly.  you can do the merge in one linear pass.
06:52:45 <matthiasgorgens> merge xs ys = let [(low:xs'),ys'] = sortBy (comparing head) [xs,ys] in low : merge xs' ys'
06:53:11 <CodeWeaverX> stop with the sorting already ;)
06:53:14 <matthiasgorgens> CodeWeaverX: I'm not sorting the already sorted lists.
06:53:18 <byorgey> heh, I think that works, but it's kind of ugly =)
06:53:26 * rtharper likes his better, still =p
06:53:34 <matthiasgorgens> byorgey: but that way I get to avoid the case analysis.
06:53:49 <rtharper> which you want to do because...?
06:54:08 <matthiasgorgens> rtharper: leads to duplication, or almost the same code again.
06:54:14 <matthiasgorgens> almost the same code as my current version.
06:54:58 <CodeWeaverX> oh, clever sorting of a list of lists.  i see.
06:55:12 <byorgey> I will certainly grant that your version avoids code duplication.  It's actually rather clever.
06:55:22 <byorgey> but I still think it's ugly ;)
06:55:50 <CodeWeaverX> i stand corrected.  still seems seriously heavy-duty for a two-element-one-extraction behaviour.
06:57:07 <matthiasgorgens> I'm checking out the priority-queue package.  perhaps that supports infinite lists.
06:57:28 <matthiasgorgens> as a fun exercise I'm thinking of using Lists as Comonads for the merge.
06:58:29 <matthiasgorgens> CodeWeaverX: We can also write a small helper function to sort 2-tuples.
06:58:36 <EvanR> anyone know of a uploader module
06:58:40 <EvanR> for a web app
06:59:01 <CodeWeaverX> matthias: interesting approach.
06:59:23 <matthiasgorgens> CodeWeaverX: Though I'm not sure if that can be made to work.  A zipper will work.
06:59:42 <CodeWeaverX> still, rtharper's simple merge handles infinite lists.
07:00:45 <CodeWeaverX> Actually it's not obvious to me why yours wouldn't.
07:00:53 <matthiasgorgens> CodeWeaverX: Mine does.
07:01:09 <matthiasgorgens> CodeWeaverX: It's basically exactly the same approach as rtharper's.
07:01:12 <CodeWeaverX> Oh.  Sorry, guess I came into the middle of this.
07:01:13 <khanzor> EvanR: what framework are you using?
07:01:18 <megajosh2> Hey, I was trying to get help on building curl with windows earlier
07:01:26 <megajosh2> Well, the curl package
07:01:29 <CodeWeaverX> I'll stand back and learn. :D
07:01:50 <matthiasgorgens> CodeWeaverX: I mean my last code, of course.  The earlier ones didn't work. ;o)
07:01:52 <khanzor> EvanR: I believe there are some references to that in both the yesod and the snap documentation, but i could be mistaken
07:02:00 <megajosh2> It installed, but when I use the package with any Haskell program, the console is flooded with errors about undefined references
07:02:07 <megajosh2> Any idea what could be going wrong?
07:02:32 <Sgeo> Haskell is a very kind language. Data kinds, constraint kinds, poly kinds...
07:02:53 <megajosh2> I put libcurl.a and libcurldll.a somewhere that mingw would see it
07:02:56 <EvanR> khanzor: rails ;) but i was asking here to see what haskell had
07:03:28 <hpc> @hoogle (%)
07:03:29 <lambdabot> Data.Ratio (%) :: Integral a => a -> a -> Ratio a
07:04:53 <matthiasgorgens> rtharper: you are organizing the Fun in the Afternoon workshop, aren't you?
07:06:30 <argiopeweb> Network.Socket.sendMany doesn't seem to attempt to detect connections which have been unexpectedly disconnected and ends up blocking when the kernel's TCP buffer fills. This affects Network.Enumerator due to its use of sendMany. Am I missing something, or do I need to reimplement using send directly (and checking for 0 sends)?
07:08:32 <Sgeo> http://www.yesodweb.com/blog/2012/02/persistent-0-8
07:08:38 <Sgeo> http://www.reddit.com/r/haskell/comments/pg8bq/the_new_persistent_mysql_complex_data_structure/
07:08:44 * Sgeo is starting to be a bit irked
07:09:42 <rtharper> matthiasgorgens: yes
07:10:43 <quicksilver> Sgeo: don't let DataKinds fool you. Data are cruel.
07:10:43 <hpaste> megajosh2 pasted “linker complaints” at http://hpaste.org/57627
07:11:07 <megajosh2> That's all of the errors, if it helps
07:11:56 <quicksilver> that looks like you need to install some SSL implementation first
07:12:06 <quicksilver> I'm afraid I can't tell you what
07:12:11 <quicksilver> maybe the curl package has some hints in its docs?
07:12:14 --- mode: quicksilver set -o quicksilver
07:13:13 <johnthejohn> What does the underscores do in something like this: (0, _, _, _)?
07:14:34 <koala_man> johnthejohn: a stand-in that matches anything when you don't care about what it is
07:14:35 <synonymous> In pattern matching it matches a quadruple with the first element 0 while the rest of the elements are arbitrary
07:14:55 <johnthejohn> Thank you.
07:20:21 <hpaste> nand` pasted “MPD Browser” at http://hpaste.org/57628
07:34:25 <weltensegler> Hello, i just discovered, that when i import a big module into my Main module without using it anywhere, then the compiled binary still grows a lot. Why is that and can it be circumvented?
07:35:49 <rata_> weltensegler: why would you like to import a module you don't use? how are you importing it?
07:36:15 <rata_> (and which OS are you using?)
07:38:19 <weltensegler> rata_: i initially used that module but later didn't need it anymore. I import it using "import Mymodule". I am using Debian Testing. I guess, this suggests importing only those parts of the module i really use?
07:39:44 <rata_> weltensegler: yes, that's what's recommended.. or import it qualified
07:41:12 <weltensegler> rata_: Will a qualified import prevent the unnecessary growth?
07:42:28 <rtharper> Ahhh, why would anyone use Map without treating Maybe as a monad...
07:42:31 <rata_> weltensegler: don't know
07:42:50 <rtharper> Oh right, you were probably worked into a case of case writing frenzy and didn't stop to read your own code
07:43:00 <taotree> I saw an email from last year on haskell-cafe that someone was working on a typechecker for haskell-src-exts... does anyone know if that is in a state to try out yet? I need a typechecking solution that is fast (and preferrably lightweight)
07:43:18 <rtharper> (by "you" I have course mean "I")
07:43:45 <weltensegler> rata_: i checked: it doesn't.
07:44:01 <rata_> weltensegler: so it still grows?
07:47:41 <weltensegler> rata:_ Yes it does. It also grows the same amount if i only import a small data type out of that module by "import Mymodule (Mydatatype)".
08:11:16 <Taneb> elliottt, are you the one whom I would know as elliott, or are you someone else?
08:12:19 <weltensegler> rata_: i opened a question on stackoverflow. Thanks anyway!
08:12:41 <rata_> weltensegler: sorry for not being able to help, I don't know much about ghc internals
08:13:00 <rata_> I hope stackoverflow is able to answer
08:13:05 <weltensegler> rata_: No problem. Neither am i :)
08:13:49 * weltensegler is going home. Cheers
08:14:01 <Sgeo> Taneb, considering that elliott is logged in...
08:14:06 <Taneb> Hmm
08:14:24 <Sgeo> Also, elliottt's supposed RL name doesn't match elliott's.
08:14:27 <Sgeo> >.>
08:14:37 <Taneb> Because I managed to convince myself I'm a figment of elliott's imagination
08:14:48 <Taneb> And I should really check those kinda things first, eh?
08:15:16 * byorgey is pretty sure elliott and elliottt are distinct
08:15:29 <rata_> question to english speakers: what's a better abbreviation for third: thd or thr?
08:15:41 <Taneb> trd
08:15:51 <hey_lu> 3rd ;)
08:16:05 * cmccann would use thd if three letters is really required
08:16:50 <cmccann> also yes there are at least four distinct people in this channel named elliott, it's absolutely ridiculous
08:16:56 <nand`> thd most likely, ”trd” sounds like “thread” or “tread” and thr is completely off
08:17:04 <Taneb> Anyway
08:17:27 <rata_> well, as Taneb pointed out, there's also trd
08:17:43 <rata_> ahh... ok
08:17:51 <cmccann> unfortunately thrd is the only thing that actually follows the pattern of both fst and snd
08:17:51 <rata_> so thd is leading
08:18:00 <nand`> 3rd is nicest but unfortunately probably not a valid name
08:18:07 <cmccann> i.e. keeping both the first and last consonant clusters
08:18:17 <byorgey> nand`: I would read 'trd' as 'turd'
08:18:22 <rata_> cmccann: well, I can use thrd too
08:18:24 <nand`> cmccann: wouldn't that be frst then?
08:18:27 <eyebloom> What is the most popular FRP implementation?
08:18:30 <cmccann> byorgey also has a very good point
08:19:25 <byorgey> eyebloom: I have no idea what the most *popular* one is.  The one I would recommend to you, if you're interested in playing with FRP, is reactive-banana
08:19:58 <eyebloom> That's what it seems like.
08:20:06 <cmccann> nand`, eh, true, though I think there's actually a distinction there which I don't remember enough linguistics to figure out
08:20:09 <xivix> What's that thing that converts an expression to pointfree?
08:20:16 <Sgeo> @pl \x -> x
08:20:16 <lambdabot> id
08:20:29 <cmccann> or install pointfree from hackage
08:20:35 <xivix> Sgeo: Thanks.
08:20:52 <cmccann> xivix, pl is short for "pointless"
08:20:57 <cmccann> for what it's worth
08:21:07 <xivix> cmccann: Witty.
08:21:10 <Sgeo> @pl \do re mi fa so la ti -> do do ti la so fa me re do
08:21:13 <lambdabot> (const .) . (flip =<< ((flip . ((flip . ((flip . (flip .)) .)) .)) .) . flip . ((flip . ((flip . (flip .)) .)) .) . flip flip me . ((flip . ((flip . (flip .)) .)) .) . flip . ((flip . (flip .)) .) .
08:21:13 <lambdabot> flip . (flip .) . flip . join id)
08:21:39 <xivix> Sgeo: Just what I was looking for!
08:22:01 <nand`> I read @pl as “perl”
08:22:37 <xivix> @pl \f a b -> x a (y a b)
08:22:38 <lambdabot> const (liftM2 (.) x y)
08:22:46 <Sgeo> openparens const dot closeparens dot openparens flip reversebind openparens
08:22:58 <Sgeo> Doesn't quite roll off the tongue
08:23:09 <Sgeo> Wait.
08:23:14 <Sgeo> flip =<<?
08:23:18 <Sgeo> Oh
08:23:24 <Sgeo> Derp
08:23:31 <Sgeo> It's not flip (=<<)
08:23:31 <nand`> not flip (=<<) :)
08:23:34 <cmccann> heh
08:23:40 <xivix> reversebind is sad. =<<
08:23:48 <nand`> >>= is too
08:23:59 <Palmik> Hi guys, was something like this ever done (the example is in the first 35 lines, the implementation is under that) http://hpaste.org/57629
08:24:06 <nand`> I suggest we rename them <<= and =>>
08:24:11 <nand`> in effort to make haskell a happier language overall
08:24:13 <xivix> nand`: sad AND upside-down
08:24:32 <cmccann> nand`, isn't that what the comonad package uses?
08:24:46 <nand`> comonads can have =<< and >>= then
08:24:58 <nand`> if haskell is happy then cohaskell is sad
08:25:30 <xivix> is liftM2 equivalent to any other functions?
08:25:46 <Sgeo> Taneb, I may have failed to update you on occasion, due to only checking for Ngevd
08:25:49 <Sgeo> liftA2
08:25:50 <cmccann> xivix, liftA2 :P
08:25:50 <donri> liftA2?
08:25:57 <xivix> of course
08:26:05 <Taneb> Sgeo, I follow the RSS. It's 'k
08:26:08 <byorgey> xivix: it can also be implemented in terms of (>>=) and return
08:26:23 <nand`> and fmap and `ap`   and   <$> and <*>
08:26:25 <byorgey> (doing so is a good exercise)
08:26:47 <Sgeo> \f a b -> return f `ap`a `ap` b
08:26:49 <cmccann> liftM2 on ZipList is zipWith, for what that's worth
08:26:53 <flux> hmm, Ambiguous module name `Prelude': it was found in multiple packages: base haskell98-2.0.0.1 and sudo ghc-pkg hide haskell98 doesn't make it go away. suggestions?
08:27:03 <cmccann> well, liftA2 is at least
08:27:06 <flux> also ghc-pkg list shows haskell98 and haskell2010 in blue, I guess it means hidden
08:27:13 <byorgey> Palmik: this is a system for record types/selectors/etc.?
08:27:27 <xivix> So the pointfree expression it gave me,  const (liftM2 (.) x y) ,  takes advantage of functions being monads or something?
08:27:40 <flux> (I'm compiling ImplicitCAD)
08:27:43 <Palmik> byorgey, yes.
08:27:58 <flux> ((and the error comes from 'cabal install'))
08:28:00 <cmccann> byorgey, btw I don't think you use SO but if you did this would be a good place to plug combinatorial species: http://stackoverflow.com/q/9190352/157360
08:28:17 <cmccann> :t liftM2 (.)
08:28:18 <lambdabot> forall a b (f :: * -> *) (m :: * -> *). (Functor f, Monad m) => m (a -> b) -> m (f a) -> m (f b)
08:28:24 <cmccann> oh right, Caleskell
08:28:29 <cmccann> :t liftM2 (Prelude..)
08:28:30 <lambdabot> forall b c a (m :: * -> *). (Monad m) => m (b -> c) -> m (a -> b) -> m (a -> c)
08:28:35 <rata_> is there a beautiful way in Prelude to transform a Bool in Maybe, to propagate the error in (x == y >> checkSmtg >> return z)?
08:28:39 <byorgey> Palmik: yes, I think something like this has been done.  For example check out the 'has' and 'records' packages on Hackage.
08:28:51 <byorgey> rata_: guard
08:29:21 <cmccann> in fact, guard is for any MonadPlus
08:29:28 <byorgey> cmccann: thanks for the link
08:29:33 <cmccann> so that also filters things out in the list monad &c.
08:29:34 <rata_> byorgey: oh thanks! didn't know about it
08:29:37 <xivix> @pl \s l -> s ++ l ++ s
08:29:37 <lambdabot> liftM2 (.) (++) (flip (++))
08:29:45 <xivix> uuuugly
08:30:05 <flux> actually I hided base as well (although it sounded like a bad idea), but still the same error pops up..
08:30:24 <xivix> cmccann: what's Caleskell?
08:30:36 <nand`> Cale's Prelude
08:30:43 <cmccann> byorgey, I bring up combinatorics in my answer but don't know enough to show much interesting other than mentioning the bijection between trees and 7-tuples of trees
08:30:44 <nand`> :t flip
08:30:45 <lambdabot> forall (f :: * -> *) a b. (Functor f) => f (a -> b) -> a -> f b
08:30:47 <nand`> ^ stuff like that
08:30:52 <cmccann> xivix, what lambdabot uses
08:31:07 <xivix> nand`: what's the advantage of it?
08:31:11 <cmccann> confusing people
08:31:15 <nand`> ^
08:31:16 <byorgey> cmccann: yeah, in particular the theory of species actually gives meaningful ways to interpret things like division
08:31:25 <nand`> > 1 2
08:31:26 <lambdabot>   1
08:31:43 <xivix> Does it enforce that Monads are also Functor and Applicative instances?
08:31:50 <byorgey> cmccann: also the connection to generating functions sheds a little bit more light on "why" all these algebraic manipulations of data types make sense
08:31:51 <Cale> It's not really a Prelude
08:32:03 <flux> shame on me, the third google hit fixed that.. the problem was broken .cabal-file, the dependency on haskell98 could just be removed. although it still doesn't compile.
08:32:06 <Cale> It's just Pristine.hs and L.hs in lambdabot
08:32:07 <cmccann> byorgey, yeah, I touch on that briefly at the end of my answer
08:32:17 <byorgey> OK, I hadn't actually read it all yet
08:32:26 <cmccann> haha yeah that might take a while
08:32:29 <cmccann> :T
08:33:04 <Palmik> byorgey, hmm, interesting. Does "has" or "records" allow you to store multiple selectors in one list for example, it does not seem so on the first glance. They more or less resemble lenses.
08:33:16 <byorgey> Palmik: I really have no idea.
08:33:32 <byorgey> just pointing you to some potentially related stuff.
08:33:39 <Palmik> OK, thanks. :)
08:33:45 <flux> nope, cannot make it compile. oh well, apparently Debian unstable has too new stuff..
08:34:04 <byorgey> Palmik: I think there are others too, but those are the ones I could find in a minute of searching/recalling
08:35:43 <cmccann> byorgey, a funny thing is that I hadn't actually realized that the copairing definition corresponded to multiplying exponentiated terms until I started writing that :P
08:36:05 <cmccann> was thinking "I should rephrase some of that stuff as... hey, wait"
08:37:06 <quicksilver> Palmik: oleg did something on this
08:37:32 <cmccann> quicksilver, that's true for all values of "this"
08:37:33 <cmccann> :P
08:38:33 <cmccann> @quote already.did.it
08:38:33 <lambdabot> syntaxglitch says: every time I have a cool idea about something that might work in Haskell, I go check Oleg's stuff and find that 1) he already did it 2) thought it out better 3) did it incidentally
08:38:33 <lambdabot> while working on something way more interesting
08:38:53 <quicksilver> Palmik: I think it is covered in http://okmij.org/ftp/Haskell/types.html#HList
08:39:12 <quicksilver> Palmik: however you may also find stuff by googling "hlist records" and "hlist labels"
08:39:22 <quicksilver> you could also look at fclabels.
08:39:22 <byorgey> cmccann: hehe, yeah
08:39:26 <CodeWeaverX> I'm guessing Oleg is a big name here.  I'll have to poke around hackage for him.
08:39:44 <Palmik> Yay for reinventing the wheel then. :D
08:39:50 <CodeWeaverX> But I've had the same sort of experience.  "I could do this in Hask-oh."
08:40:12 <quicksilver> my personal opinion is that all of this is a bit ugly and that data-lens is the right general pattern for these problems
08:40:12 <Jafet> Units do not start with capital letters
08:40:29 <cmccann> CodeWeaverX, Oleg is sort of a reclusive mad genius for functional programming in general
08:40:36 <quicksilver> admittedly you don't get abstraction over labels from data-lens in an easy way
08:40:44 <CodeWeaverX> Excellent.  Every community needs those reclusive mad geniuses.
08:41:00 <CodeWeaverX> I approve, and aspire.
08:41:01 <CodeWeaverX> :P
08:41:05 <quicksilver> cmccann: and linguistics, and probability, and all kinds of stuff.
08:41:07 <quicksilver> cmccann: http://okmij.org/ftp/README.html
08:41:34 <cmccann> CodeWeaverX, I don't think he actually uploads anything on hackage, just writes papers, sends enlightening missives to haskell mailing lists, and puts things on his site. sometimes other people upload his stuff to hackage though.
08:42:01 <CodeWeaverX> cmccann:  Oooh, he has minions to do the boring stuff!
08:42:24 <CodeWeaverX> Does he say "throw the switch!"
08:42:50 <nand`> a real haskell programmer does not use a compiler
08:43:07 <CodeWeaverX> nand`: win.
08:43:19 <mekeor> nand`: what instead?
08:43:23 <nand`> a type checker
08:43:25 <nand`> nothing else
08:43:30 <CodeWeaverX> An abacus?
08:43:41 <CodeWeaverX> maybe quantum tennis balls.
08:44:02 <mekeor> nand`: hmm..  why?
08:44:37 <nand`> mekeor: because actually compiling and executing haskell code involves the ugly IO black box. true haskell stays pure
08:44:44 <cmccann> nah, Oleg just calls himself with a continuation, compiles the code, invokes the continuation to jump back in time, then uses the compiled code to get the continuation in the first place
08:45:08 <mekeor> nand`: ah, i see.
08:45:14 <nand`> it's all in your mind
08:45:16 <nand`> like mathematics
08:45:22 <CodeWeaverX> That is so reminiscent of the best programming video in the universe.
08:45:36 <mekeor> nand`: something i still dont understand is whether haskell/monads is pure or not.
08:46:05 <nand`> haskell is pure as long as all you do is define programs, the moment you execute anything it becomes impure
08:46:07 <nand`> that's the way I see it
08:46:32 <cmccann> monads aren't magic
08:46:38 <cmccann> they're as pure as the rest of the language
08:46:48 <Saizan> mekeor: one can say that you only purely define descriptions of side effects, which the RTS executes for you
08:47:02 <CodeWeaverX> If any of you haven't seen this, watch it now.  Or when you have an hour in fits and starts.
08:47:02 <CodeWeaverX> http://blip.tv/open-source-developers-conference/temporally-quaquaversal-virtual-nanomachine-programming-in-multiple-topologically-4466153
08:47:02 <CodeWeaverX> You will feel insufficiently geeky.
08:47:16 <mekeor> Saizan: RTS?
08:47:19 <nand`> Basicall what Saizan said. Something like getLine >>= putStr just defines an “action”, in a pure way
08:47:20 <Saizan> mekeor: then the results get passed back to the rest of your program to compute the next side effect etc..
08:47:29 <nand`> actually executing this action is where things get ugly, and is out of the scope of haskell
08:47:30 <Saizan> mekeor: RunTime System
08:47:49 <Saizan> *the next description of side effects
08:48:10 <nand`> and then of course there's unsafePerformIO
08:48:22 <CodeWeaverX> Shh!  Don't summon the Impure Beast by saying its name!
08:48:35 <nand`> but I would call that a bastard of necessity
08:48:56 <mekeor> heheh
08:49:10 <mekeor> what's the problem with unsafePerformIO?
08:49:17 <mekeor> it's not pure?
08:49:25 <mekeor> @hoogle unsafePerformIO
08:49:25 <lambdabot> System.IO.Unsafe unsafePerformIO :: IO a -> a
08:49:25 <lambdabot> Foreign unsafePerformIO :: IO a -> a
08:49:32 <mekeor> O_O
08:49:32 <CodeWeaverX> It allows pure code to execute impure actions.
08:49:38 * byorgey unsafePerformIO lumbers drooling into the room, looks around, and eats mekeor
08:49:46 <mekeor> IO a -> a -- WTF?
08:49:58 <nand`> it allows a “back door” to IO
08:50:00 <CodeWeaverX> mekeor finally gets it… just before being consumed.
08:50:02 <byorgey> good! WTF is the reaction you are supposed to have.
08:50:13 <nand`> it's only recommended for actions which have zero side effects, but still involve external calls or something
08:50:14 <CodeWeaverX> Isn't that always the way
08:50:18 <mekeor> byorgey: haha :D
08:50:33 <mekeor> nand`: i see.
08:50:34 <CodeWeaverX> You can do some clever things with it if you're very very very very… very very careful.
08:50:45 <nand`> for example, I see it used when there's some sort of program-wide constant, that's still unique per execution, but ultimately dynamic
08:50:55 <byorgey> you don't have to be very very very very very careful.  You just have to understand what you're doing.
08:51:08 <nand`> basically, calling unsafePerfomIO x twice should return the same result for it to be pure
08:51:09 <CodeWeaverX> Like do something which is effectively pure, but requires a set of impure steps within the IO monad.
08:51:34 <nand`> see http://hackage.haskell.org/packages/archive/base/latest/doc/html/System-IO-Unsafe.html#v:unsafePerformIO
08:51:51 <CodeWeaverX> Well, okay, byorgey, but that's all I meant.  Even not being completely fluid in Haskell, I recognize how big a gun it is to shoot yourself in the foot with.
08:52:09 <CodeWeaverX> More like your whole leg.
08:52:26 <nand`> unsafePerfomIO $ shoot Foot
08:52:38 <conal> unsafePerformIO is (like) adding implicit side-effects to math. Suddenly reasoning can't be trusted.
08:52:57 <CodeWeaverX> I expect that Weird Untraceable Suitcases Full Of Bad could result from the program assuming such an operation is pure when it clearly isn't.
08:53:23 <mekeor> can it cause problems using it? i mean, that's just in contradiction to the definition of a monad! so, doesn't the haskell-compiler/typechecker have problems with unsafePerformIO??
08:53:45 <CodeWeaverX> It's there precisely so the typechecker doesn't have a problem with it.  It's a dirty backdoor.
08:54:07 <mekeor> so, it's also not written in haskell itself?
08:54:09 <CodeWeaverX> How about a concrete example?  Lazy loading of files into a list on the fly from a file would be implemented with it.
08:54:30 <nand`> oh, it type checks just fine.. IO a -> a is a valid type signature, even if it's impossible to (purely) realize
08:54:36 <byorgey> mekeor: indeed, it needs special compiler support.  But then again, IO already needs special compiler support.
08:54:37 <nand`> so is unsafeCoerce :: a -> b
08:54:39 <CodeWeaverX> As the list is evaluated, sometimes a file has to be accessed.  It is 'effectively' pure as long as the file doesn't change.
08:54:49 <byorgey> @remember CodeWeaverX Weird Untraceable Suitcases Full Of Bad
08:54:49 <lambdabot> Done.
08:55:04 <CodeWeaverX> …but it requires a backdoor to IO.
08:55:07 <byorgey> CodeWeaverX: I think that would actually be done with unsafeInterleaveIO.
08:55:12 <CodeWeaverX> Oh come on, at least quote my whole sentence. :D
08:55:19 <CodeWeaverX> byorgey, okay, fair enough.  A cousin beast.
08:55:28 <CodeWeaverX> But my point basically stands.
08:55:34 <nand`> :t unsafeInterleaveIO
08:55:35 <lambdabot> Not in scope: `unsafeInterleaveIO'
08:55:38 <nand`> @hoogle unsafeInterleaveIO
08:55:39 <lambdabot> System.IO.Unsafe unsafeInterleaveIO :: IO a -> IO a
08:55:47 <byorgey> @forget CodeWeaverX Weird Untraceable Suitcases Full Of Bad
08:55:48 <lambdabot> Done.
08:55:50 <byorgey> @remember CodeWeaverX I expect that Weird Untraceable Suitcases Full Of Bad could result from the program assuming such an operation is pure when it clearly isn't.
08:55:50 <lambdabot> It is stored.
08:55:55 <CodeWeaverX> Hahahahahaha
08:56:12 <CodeWeaverX> I didn't expect you to actually do that.  But thanks. :D
08:56:17 <byorgey> =)
08:56:37 <Sgeo> It's not in contradiction to the definition of a Monad
08:56:45 <Sgeo> Just to how IO in Haskell generally operates.
08:56:48 <Sgeo> :t runIdentity
08:56:49 <lambdabot> forall a. Identity a -> a
08:57:06 <byorgey> right, some monads do support  M a -> a
08:57:12 <Sgeo> runIdentity is 100% safe.
08:57:14 <byorgey> Stream is another example.
08:57:37 <nand`> IO is strange in general
08:57:46 <CodeWeaverX> Alright, back online later Heehee
08:57:51 <nand`> for example a >> b should never need to evaluate a
08:57:53 <nand`> except for IO
08:58:05 <byorgey> nand`: uh, that's not true.
08:58:10 <nand`> oh wait
08:58:11 <byorgey> > Nothing >> Just 3
08:58:12 <lambdabot>   Nothing
08:58:14 <nand`> [1,2] >> [3,4]
08:58:16 <nand`> right
08:58:26 <yitz> @let runIdentity = error "And you thought it was 100% safe."
08:58:27 <lambdabot>  Defined.
08:58:34 <conal> IO is strange in that it's not denotative.
08:58:58 <Sgeo> conal, IO denotates 10 with some old typewriters </stolen-joke>
08:59:04 <conal> :)
08:59:05 <conal> or, in Peter Landin's
08:59:35 <conal> term, IO is not "genuinely functional" and merely masquerades as such.
08:59:51 <conal> a "functional looking notation".
09:00:05 <Eduard_Munteanu> I don't really get that joke, I suppose I should read up on denotational semantics some more :D
09:00:15 <conal> (from the seminal "next 700 programming languages" paper)
09:00:34 <yitz> conal: a mechanism by which we can leverage the type system to isolate the parts of our programs that are still not denotational
09:00:38 <Eduard_Munteanu> (firstworldproblems)
09:00:43 <conal> yitz.
09:00:54 <conal> yitz: yeah.
09:01:09 <conal> wow. "yitz" and "yeah" fused in my virus-addled brain.
09:01:16 * conal has a cold today.
09:01:17 <yitz> conal: but we'll get there eventually
09:01:25 <nand`> conal: that can't be type safe
09:01:38 <conal> yitz: get to consistently denotative programming?
09:01:54 <yitz> yes i believe someday we will
09:02:14 <conal> yitz: i'm glad to hear that! i do too.
09:02:20 <yitz> conal: maybe you should change your nick to codal for today
09:02:26 <conal> :)
09:03:00 <conal> here's an angle i like: most of haskell is good for equational reasoning. in contrast, IO is bad for incorrect equational reasoning.
09:03:09 <nand`> if the universe is a simulation in haskell, can IO actions inside this universe be represented in a type safe way (from the vantage point of the simulation)?
09:03:29 <nand`> well, they can already be represented in a type safe way
09:03:31 <conal> i.e., the type serves mainly to "block" incorrect equations, as bob harper put it.
09:03:32 <nand`> wrong question
09:03:34 <Sgeo> State monad?
09:03:40 <nand`> Sgeo: that's what I was thinking
09:03:59 <Sgeo> How do you force lazy Haskell to bother to do the simulation?
09:04:23 <c_wraith> Sgeo: hire a guy with whip
09:04:25 <conal> the state monad is deterministic, unlike IO
09:04:32 <nand`> because some funny joker once asked Haskell what the billionth line of conversation in #haskell was about and now we're stuck in this
09:04:51 <yitz> conal: reactive-banana on the one hand and conduits/pipes on the other are continuing to dig the tunnel from both ends.
09:05:00 <Sgeo> Hmm, I guess I'm thinking there's no main, because it doesn't need to communicate with the world outside the simulation
09:05:38 <Sgeo> But it does need to run the actual simulation
09:05:42 <yitz> conal: the yesod people are thinking of trying to incorporate rb into the framework in some places
09:05:42 <nand`> there is a main, it just doesn't have type IO ()
09:06:00 <conal> yitz: ah. neat. i hadn't heard.
09:06:12 <yitz> conal: so i think the two tunnel-digging teams can already faintly hear the sounds of each other's shovels
09:06:14 <Sgeo> Unless the program is physical just a simulation inside itself.
09:06:20 <Sgeo> rb?
09:06:23 <Sgeo> Oh
09:06:24 <nand`> reactive-banana
09:06:52 <tty7> huh? the lazy IO drives me crazy..
09:07:12 <Sgeo> tty7, it's a parlor trick, don't actually use it for stuff.
09:08:07 <hpaste> tty7 pasted “crazy IO” at http://hpaste.org/57633
09:09:00 <nand`> shouldn't that be putStrLn $
09:09:01 <Sgeo> tty7, that has nothing to do with lazy IO
09:09:08 <jfischoff> finally starting to understand the new GHC.Generics
09:09:08 <tty7> hm, okay
09:09:19 <tty7> yep, nand`, should be putStrLn $
09:09:41 <Sgeo> tty7, note that if compiled, output won't be output until a newline occurs
09:09:44 <tty7> the output is "xyz\nEnter smth: You just said this: xyz"
09:09:46 <Sgeo> Due to buffering
09:09:56 <tty7> hm?
09:10:06 <Sgeo> You can import System.IO and use hSetBuffering stdout NoBuffering
09:10:12 <Sgeo> Or you can hFlush stdout
09:10:16 <Sgeo> After outputting the text.
09:10:33 <Sgeo> Because otherwise, the console won't output the line, usually it waits for a newline
09:10:41 <Sgeo> This is not especially a Haskell thing
09:14:57 <kadoban> hmm. is there some easy way in general to get haskell to not buffer output?  i'm printing an infinite list, and if i do "take 2" on it, i get immediate results, otherwise it just sits there so far
09:15:27 <Sgeo> kadoban, does it sit there forever in GHCi?
09:15:53 <tty7> Sgeo: ah. so if i'd use putStrLn instead of putStr it would work as expected?
09:15:54 <Sgeo> kadoban, and sits there where?
09:15:57 <Sgeo> tty7, yes
09:16:01 <tty7> thanks :)
09:16:03 <Sgeo> yw
09:16:37 <kadoban> Sgeo: it's supposed to be printing, but it doesn't, i assume it's buffering because there should be some quick values at the front
09:16:58 <kadoban> Sgeo: would it be different in ghci? i have a compiled version so far (using ghc)
09:17:17 <Sgeo> kadoban, GHCi is automatically set to NoBuffering
09:17:22 <Sgeo> So if that's the issue...
09:17:26 * hackagebot ftp-conduit 0.0.4 - FTP client package with conduit interface based off http-conduit  http://hackage.haskell.org/package/ftp-conduit-0.0.4 (MylesMaxfield)
09:17:49 <kadoban> Sgeo: oh, how do i set that? (i'm almost positive that that's the issue)
09:18:12 <Sgeo> hSetBuffering stdout NoBuffering
09:18:16 <Sgeo> :t hSetBuffering
09:18:17 <lambdabot> Not in scope: `hSetBuffering'
09:18:25 <Sgeo> @hoogle hSetBuffering
09:18:26 <lambdabot> System.IO hSetBuffering :: Handle -> BufferMode -> IO ()
09:18:26 <lambdabot> GHC.IO.Handle hSetBuffering :: Handle -> BufferMode -> IO ()
09:18:31 <kadoban> thanks
09:18:33 <Sgeo> yw
09:19:51 <cmccann> conal, I've been hacking on a library inspired partly by a mixture of your FRP work and things likes conduits/pipes, the result of which should give composable stream processing with lots of simple algebraic properties and a clean semantics for having active vs. passive values and combining them in general
09:20:44 <conal> cmccann: nifty! i'm glad to hear you have an eye on semantics & properties.
09:21:26 <cmccann> it's more about abstract processing for sequentially varying values than it is an attempt to do either FRP or something conduit-like
09:22:21 <cmccann> conal, I'm mostly aiming for it to be transparently semantics-preserving
09:22:48 <conal> cmccann: good luck with it.
09:23:37 <CodeWeaverX> *wafts the scent of fresh coffee over the chatroom*
09:23:59 * Cale immediately goes to make a cappuccino for himself
09:24:11 <CodeWeaverX> \o/
09:25:52 <stepcut> in GHC 7.0.4, If I do, data Bark = Bark deriving Typeable, and then do typeOf, It returns 'Main.Bark'. But in GHC 7.4, it returns the unqualified 'Bark'. Any idea how to get fully qualified name again?
09:26:33 <cmccann> conal, the goal is that e.g. layering it over something that expresses "values at a point in time" would lift that to "streams of time-varying values" in a way that preserves the time-based semantics for all stream operations
09:27:03 <conal> cmccann: yep.
09:27:19 <kallisti> challenge: find a legitimate reason to name a variable optimus' in a Haskell program.
09:27:42 <CodeWeaverX> *nearly snorts coffee*
09:27:45 <CodeWeaverX> DARN YOU TO HECK
09:27:46 <CodeWeaverX> :D
09:28:13 <donri> stepcut: tyConModule?
09:30:33 <stepcut> oldTypeOf t = let tr@(TypeRep f con rep) = typeOf t in tyConModule con ++ "." ++ show tr
09:30:58 <c_wraith> holy crap. google+ wants me to follow xah lee
09:31:19 <donri> is he infamous around here too?
09:31:33 <c_wraith> well, he was, a long time ago
09:40:01 <hpaste> paf31 pasted “Illegal Tuple Constraint” at http://hpaste.org/57637
09:40:03 <gwern> > ((25 + 475 + 800) / 3) * 2007 - 1999
09:40:04 <lambdabot>   867701.0
09:40:33 <gwern> > ((25 + 475 + 800) / 3) * (2007 - 1999)
09:40:34 <lambdabot>   3466.6666666666665
09:40:38 <gwern> CURSE YOU PEMDAS
09:40:47 <hpaste> paf31 annotated “Illegal Tuple Constraint” with “Illegal Tuple Constraint (annotation)” at http://hpaste.org/57637#a57638
09:40:48 <CodeWeaverX> hahaha
09:43:32 <morphles> Anye more compact ways to write "\x y -> id x" ?
09:43:48 <morphles> Any*
09:43:50 <c_wraith> const
09:43:51 <paf31> anyone familiar with ConstraintKinds: should it be considered a bug that this http://hpaste.org/57637 typechecks but that the type cannot be used?
09:44:05 <c_wraith> also, "id x" is just "x"
09:44:11 <hpc> @src const
09:44:11 <lambdabot> const x _ = x
09:44:20 <morphles> c_wraith: thanks
09:45:13 <hpc> paf31: constraint kinds is on in the file, but not the ghci session
09:45:43 <paf31> aha thanks
10:00:57 <gwern> > 0.05 / 7
10:00:58 <lambdabot>   7.1428571428571435e-3
10:01:53 <alistra> > 0.0/9999999999999999
10:01:54 <lambdabot>   0.0
10:02:04 <alistra> > 9999999999999999.0 /0.0
10:02:04 <lambdabot>   Infinity
10:02:08 <alistra> :3
10:02:19 <alistra> > Infinity * 0.0
10:02:20 <lambdabot>   Not in scope: data constructor `Infinity'
10:02:34 <alistra> > ( 9999999999999999.0 /0.0 ) * 0.0
10:02:34 <lambdabot>   NaN
10:02:52 <BlazeCoder> Infinity = 100, Infinity * 99999.0
10:03:06 <BlazeCoder>  > Infinity = 100, Infinity * 99999.0
10:03:15 <BlazeCoder> bot don't like me
10:03:31 <alistra> no leading space
10:03:33 <donri> needs more let, less whitespace and more lowercase
10:03:50 <BlazeCoder> lol. my bad.
10:04:54 <donri> can't assign to identifier starting with an upper cased letter because that'll attempt to pattern match on a data constructor
10:06:06 <Sgeo> > (1/0) == (-1/0)
10:06:07 <lambdabot>   False
10:06:17 <Sgeo> Hmm
10:06:32 <Sgeo> > 0 == (1/(-1/0))
10:06:33 <lambdabot>   True
10:06:37 <Sgeo> Hrm
10:07:05 <Sgeo> I think there is supposed to be a way to get at -0
10:07:23 <Sgeo> > (1/(-0))
10:07:24 <lambdabot>   -Infinity
10:07:28 * hackagebot stm-conduit 0.2.0 - Introduces conduits to channels, and promotes using  conduits concurrently.  http://hackage.haskell.org/package/stm-conduit-0.2.0 (ClarkGaebel)
10:14:42 <Jedai> > (1/(-1/0))
10:14:43 <lambdabot>   -0.0
10:14:52 <Sgeo> Yay!
10:14:56 <Jedai> Sgeo: That's it ^
10:15:00 <Sgeo> > (1/(-1/0)) == 0
10:15:01 <lambdabot>   True
10:15:03 <Sgeo> Blargh
10:15:12 <Sgeo> What did I do to that thing to make it false
10:15:22 <Jedai> Sgeo: the Eq instance for Double is crappy
10:15:36 <Jedai> -0 == 0
10:15:50 <c_wraith> > (0/0) == (0/0)
10:15:51 <lambdabot>   False
10:15:51 <Jedai> Sgeo: It's not even transitive
10:16:11 <Jedai> Or reflexive...
10:16:37 <c_wraith> It conforms to the IEEE 754 spec.
10:16:50 <c_wraith> Which, for Double, is probably what you want.
10:17:06 <c_wraith> If you want saner behavior, use a type that isn't defined by IEEE 754 :)
10:17:33 <cmccann> Jedai, equality on floating point values is crappy, that's how they work
10:18:28 <Jedai> cmccann: Yes, I know it's not Haskell problem :)
10:18:55 <cmccann> and given the choice between "no Eq or Ord instance for floats", "ignore the IEEE spec", and "crappy instances" the latter is probably the least painful to use
10:19:12 <Jedai> cmccann: And in a way the "equality" on IEEE 754 types is perfectly defined and try to do its best, it's just not really an equality
10:19:44 <cmccann> the IEEE spec defines the operations the way it does for good reasons where doing calculations on floats is concerned
10:19:46 <Sgeo> > (-0) < 0
10:19:47 <lambdabot>   False
10:20:03 <Sgeo> > (1/((-1)/0)) < 0
10:20:03 <lambdabot>   False
10:20:11 <cmccann> the problem is that floating point values are actually not, in most intuitive senses, numbers
10:20:17 <Jedai> cmccann: Right, it's perfectly legitimate in my opinion, the problem is that so many people try to use it ignorant of the limitation and strength of the standard floating values
10:20:21 <c_wraith> Yeah, IEEE 754 is very well-designed for the goals they set about achieving.
10:20:27 <roconnor> when implent Haskell, compare (0/0) (0/0) is going to return an error.
10:20:46 <roconnor> *when I
10:20:46 <c_wraith> It's just that those goals are not "arbitrary numbers"
10:20:50 <Sgeo> > compare (0/0) (1/0)
10:20:51 <lambdabot>   GT
10:20:55 <Sgeo> oh, yay
10:20:58 <cmccann> roconnor, ugh, no, have a partial ordering class
10:21:02 <Jedai> c_wraith: It's especially miles better than everything we had before (especially the "every" part...)
10:21:09 <Sgeo> > compare ((1/0) * 0) (1/0)
10:21:10 <lambdabot>   GT
10:21:16 <Sgeo> > compare ((1/0) * 0) (-1/0)
10:21:17 <lambdabot>   GT
10:21:20 <Sgeo> Hm
10:21:24 <Sgeo> > 0/0
10:21:25 <lambdabot>   NaN
10:21:29 <roconnor> > compare (1/0) (0/0)
10:21:30 <lambdabot>   GT
10:21:31 <Sgeo> NaN < Infinity?
10:21:36 <Sgeo> !!!!!
10:21:47 <Sgeo> Wait
10:21:56 <roconnor> cmccann: I can do that but it won't be Haskell
10:21:57 * Sgeo mixed up what GT meant
10:22:04 <Sgeo> But ... that's a bit messed up
10:22:17 <Sgeo> It makes some sort of sense that 0/0 would be comparable to non0/0, but
10:22:27 <roconnor> Sgeo: I think comparing anything with NaN should be an error.
10:22:28 * hackagebot highlighting-kate 0.5.0.2 - Syntax highlighting  http://hackage.haskell.org/package/highlighting-kate-0.5.0.2 (JohnMacFarlane)
10:22:33 <cmccann> Sgeo, here, read this: http://stackoverflow.com/a/6399798/157360
10:22:34 <tromp__> > 1/0
10:22:35 <lambdabot>   Infinity
10:22:35 <johnsingleton> how can I rewrite a function like this without the lambda? filesForUser uid = getDirectoryContents "../data" >>= \t -> return (filter (/= "users") t)
10:22:44 <tromp__> > 1/(-0)
10:22:45 <lambdabot>   -Infinity
10:22:50 <roconnor> Sgeo: also, gcd 0 0 is 0
10:22:55 <roconnor> *should be
10:23:05 <johnsingleton> I'm not sure, with the wrap at the end, how to do it like that...
10:23:10 <cmccann> roconnor, I'm not sure that introducing more ways to create _|_ is an improvement on anything
10:23:12 <tromp__> > gcd 0 0
10:23:13 <lambdabot>   *Exception: Prelude.gcd: gcd 0 0 is undefined
10:23:13 <roconnor> @pl getDirectoryContents "../data" >>= \t -> return (filter (/= "users") t)
10:23:13 <lambdabot> filter ("users" /=) `fmap` getDirectoryContents "../data"
10:23:41 <johnsingleton> roconnor: what does @pl do?
10:23:48 <roconnor> johnsingleton: removes lambdas
10:23:55 <Sgeo> cmccann, how do you come up with that example, exactly? Did you work it out on paper, or trial and error, or what?
10:24:03 <johnsingleton> very awesome
10:24:05 <roconnor> @pl \x -> x
10:24:05 <lambdabot> id
10:24:17 <cmccann> roconnor, but I won't reiterate my argument since I'm pretty sure I said the same thing in the comments on that SO post I linked to, also to you :P
10:24:36 <cmccann> Sgeo, I shamelessly pilfered it from someone else and modified it slightly
10:24:57 <cmccann> the original used nearly the same list, and applied sort to it
10:25:06 <cmccann> hilarity ensued
10:25:44 <tromp__> > 0^0
10:25:45 <lambdabot>   1
10:25:51 <cmccann> Sgeo, all I did was tweak the list slightly and then put it in a data structure that relies on a sensible Ord instance to work
10:26:01 <roconnor> cmccann: I see we have had this conversation before :D
10:26:02 <Sgeo> PartialOrd and BSOrd?
10:26:03 <tromp__> if they can get 0^0 right, why cant they get gcd 0 0 right?
10:26:20 <gwern> > let f (i,p) = p < ((i * 0.05) / 10) in map f (zip [1..] [0.01093, 0.08252, 0.08645, 0.1805, 0.2229, 0.2668, 0.4309, 0.5296, 0.8779])
10:26:21 <lambdabot>   [False,False,False,False,False,False,False,False,False]
10:26:25 <cmccann> roconnor, so it seems :D
10:26:26 <Sgeo> How is 1 the right answer for 0^0?
10:26:43 <Cale> Sgeo: Several reasons...
10:26:51 <roconnor> @djinn Void -> Void
10:26:51 <lambdabot> f a = a
10:26:55 <cmccann> Sgeo, combinatorially makes the most sense to me
10:26:56 <roconnor> Sgeo: ^^
10:27:03 <tromp__> that's my point, gcd 0 0 is even more well-defined than 0^0
10:27:20 <Cale> Sgeo: Firstly, it's an empty product. You want x^(a + b) = x^a x^b, and x^0 = 1 makes that happen.
10:27:30 <Sgeo> cmccann, pretty much what you said in your comments I think
10:27:32 <tromp__> or should i say less ambiguous
10:27:35 <cmccann> Sgeo, if you have zero objects and zero places to put them, there's exactly one valid arrangement, which is "put nothing nowhere"
10:27:46 <Cale> Sgeo: Combinatorially, n^m when n and m are natural numbers is the number of functions from a set of size m to a set of size n
10:28:04 <Cale> Sgeo: There is one function from the empty set to itself, specifically, the empty function.
10:28:07 <Sgeo> cmccann, oh, thought you were replying to the PartialOrd/BSOrd comment
10:28:47 <cmccann> Cale, the empty product evaluating to the multiplicative identity is also a good justification, yeah
10:28:51 <yrlnry> Surely gcd 0 0 → 0?
10:29:00 <Cale> > gcd 0 0
10:29:01 <lambdabot>   *Exception: Prelude.gcd: gcd 0 0 is undefined
10:29:04 <Cale> yeah
10:29:09 <Cale> it should be 0
10:29:12 <tromp__> there is one empty string over any alphabet, including the empty alphabet
10:29:15 <cmccann> Sgeo, oh, heh. BSOrd works for me, sure :P
10:29:21 <gwern> > let f (i,p) = p < ((i * 0.05) / 6) in map f (zip [1..] [0.01834, 0.1854, 0.2986, 0.4256, 0.7518, 0.7944])
10:29:22 <lambdabot>   [False,False,False,False,False,False]
10:29:41 <cmccann> Sgeo, obviously it stands for Binary Search because the main use case is allowing things like Data.Set to work, right
10:30:00 <yrlnry> "We must define x^0=1 for all x , if the binomial theorem is to be valid when x=0 , y=0 , and/or x=-y . The theorem is too important to be arbitrarily restricted! By contrast, the function 0^x is quite unimportant."
10:30:11 <Sgeo> Uh, yeah, sure, that's what it stands for.
10:30:22 <rata_> is there something like foldM for nested monads? (like IO (Maybe a))
10:30:48 <cmccann> Sgeo, yes, that's obviously it. it is so obvious I cannot imagine any other possible meaning.
10:30:54 <Cale> Another argument for the convenience of 0^0 = 1 is power series identities such as that for exp(x) = sum over k >= 0 of x^k / k!
10:31:09 <Cale> which doesn't work out at x = 0 unless 0^0 = 1
10:31:52 <Cale> (you'd always end up separating off the constant term just to avoid that problem)
10:31:54 <cmccann> Cale, perhaps a better question is does anything other than 0^0 = 1 make sense outside of a few limited cases
10:32:01 <yrlnry> Really there is no difficulty with 0^0.  It is just barely more complicated than the question of whether 0 is even.
10:32:24 <johnsingleton> why is it that applying fmap as an infix allows it to work for that case? I'm not sure I understand
10:33:13 <Cale> johnsingleton: in what case?
10:33:24 <erus`> http://imgur.com/wR5h5 <- a picture drawn on an opengl texture from 3d :D
10:33:26 <Cale> johnsingleton: f `fmap` x is the same as  fmap f x
10:33:26 <yrlnry> Oh, and x^a * x^b = x^(a+b) fails for x=0 unless you say 0^0 = 1, not 0^0=0.
10:33:34 <yrlnry> What a catastrophe that would be.
10:33:35 <erus`> UV unwrap stylee
10:33:35 <monochrom> you mean filter ("users" /=) `fmap` getDirectoryContents "../data" ?
10:33:42 <johnsingleton> monochrom: yes
10:33:42 <Cale> yrlnry: right, I mentioned that :)
10:33:59 <monochrom> if you don't write infix, fmap (filter ("users" /=)) (getDirectoryContents "../data")
10:34:05 <johnsingleton> fmap filter ("users" /=) getDirectoryContents "../data" doesn't work… oh wait
10:34:09 <Cale> It's crucial for defining natural powers recursively
10:34:35 <monochrom> always add more parentheses first. remove them later, and paranoidly
10:34:40 <yrlnry> Heh.  I only got there because i realized it was an important special case of your expansion of exp().  You wouldn't get the exp() homomorphism to work right without 0^0=1.
10:34:58 <johnsingleton> monochrom: heh, ya
10:35:00 <johnsingleton> whooops
10:35:00 <monochrom> I mean s/paranoidly/conservatively/
10:35:17 <byorgey> yrlnry: sorry, I must be missing something, how does x^a * x^b = x^(a+b) fail for x=0  if  0^0 = 0 ?
10:35:39 * gwern sighs. when I do that multiple corrections on my stats data, none of my sleep data reaches significance. statistics is a harsh mistress!
10:35:43 <Sgeo> 5 * 1/5 = 1
10:35:55 <Sgeo> Wait
10:36:04 <byorgey> but surely 0^{-1} is not defined.
10:36:26 <johnsingleton> so, if I understand the signature of fmap correctly, the result wraps inside of b's type, correct? Functor f => (a -> b) -> f a -> f b
10:36:41 <monochrom> x^5 = x^(5+0) = x^5 * x^0. at least you it.
10:36:53 <johnsingleton> so if my type signature is filesForUser :: Integer -> IO [String] -- why does that work
10:36:58 <byorgey> johnsingleton: "the result wraps inside of b's type" -- this doesn't make much sense to me
10:37:03 <johnsingleton> shouldn't that evaluate to: filesForUser :: Integer -> IO [FilePath]
10:37:11 <monochrom> s/at least you it/at least you want it/
10:37:13 <byorgey> johnsingleton: FilePath = String
10:37:31 <johnsingleton> ah, ok
10:37:47 <monochrom> "f a" does not mean wrapping. never.
10:38:05 <c_wraith> data Wrap a = Wrap a
10:38:11 <Sgeo> f = Identity
10:38:11 <byorgey> monochrom: but that seems to be true whether 0^0 = 0 or 1.
10:38:28 <byorgey> if x = 0 then both sides are 0.
10:38:53 <johnsingleton> sorry for messing this up, but I thought the point of the return function was to wrap a type in whatever monad you are working with.
10:38:55 <Cale> It's surprising how seemingly unimportant edge cases like that can force you to realise a lot of nice things about the general case
10:38:59 <monochrom> then invoke the number of functions from {} to {}
10:39:06 <Cale> (regarding 0^0)
10:39:20 <byorgey> (note, I have been fully convinced that 0^0 should be 1 for a long time, just trying to understand this particular argument)
10:40:17 <funktronic> 0^0 is 1
10:40:28 <DrSyzygy> byorgey: Is it the argument that compares lim x->0 0^x with lim x->0 x^0 ?
10:40:30 <monochrom> the point of return is not wrapping either. the point of return is "return 5 >>= f" = "f 5", i.e., so that in the context of >>=, you pass on 5 to the next action.
10:40:53 <byorgey> johnsingleton: it's just that the idea of "wrapping" can be misleading, as if return took a single value and put it in some sort of "wrapper", but it's more general than that
10:41:01 <Cale> byorgey: oh, heh, you're right, 0^(a+b) = 0^a 0^b will work out either way
10:41:05 <funktronic> 0^0 = x^(1-1) = x^1*x^-1 = x/x = 1
10:41:22 <johnsingleton> monochrom: Ah! that makes much more sense!
10:41:24 <jklvxnasd> there is one function from the empty set to the empty set
10:41:27 <johnsingleton> thank yoU!
10:41:28 <jklvxnasd> so obviously
10:41:35 <funktronic> although 0/0 can really be anything
10:41:36 <Cale> funktronic: I don't understand that first step there
10:41:46 <Cale> 0^0 = x^(1-1)?
10:42:03 <byorgey> DrSyzygy: no, yrlnry said "x^a * x^b = x^(a+b) fails for x=0 unless you say 0^0 = 1, not 0^0=0"
10:42:05 <johnsingleton> and it also explain my question about how/why using fmap works there
10:42:09 <funktronic> Cale: idea is to simplify to 1
10:42:17 <funktronic> Cale: but the x/x = 1 step isn't correct
10:42:22 <yrlnry> Yeah, I don't know any more why I said that.  ‽
10:42:30 <funktronic> since if x=0 it can be whatever
10:42:34 <funktronic> it depends what kind of 0
10:42:36 <johnsingleton> ugh, my typing is terrible today. many apologies.
10:43:01 <byorgey> ok, fine, I wasn't trying to be an annoying jerk, I just thought there was something I was missing =)
10:43:21 <funktronic> whenever i encounter a 0 in my math i tear down the entire process
10:43:43 <Cale> funktronic: But involving division here seems weird to me :)
10:44:14 <yrlnry> byorgey:  I did not for one second imagine that you were trying to be an annoying jerk.
10:44:31 <byorgey> yrlnry: thanks =)
10:44:54 <yrlnry> How is Noah?
10:45:04 <yrlnry> Wait, is that right?  I mean your kid.
10:46:22 <byorgey> yep, that's right, he's great!
10:46:26 <yrlnry> Aha, review of my logs confirms that you claimed earlier he was noah.
10:46:38 <byorgey> I still claim that.
10:46:50 <yrlnry> Probably the safest strategy in the long run.
10:47:06 <byorgey> he might get confused otherwise.
10:53:51 <monochrom> "referential transparency"? :)
10:54:07 <tards> anybody know how to do the following basic problem? to compute the sum of the first n odd natural numbers...i.e. if n is is 5 it will sum 1+3+5
10:54:32 <c_wraith> tards: I'm sure most of us know how to do it.  What have you tried so far?
10:54:57 <monochrom> 1+3+5+7 seems to be (0+2+4+6) + 4
10:55:03 <nand`> tards: that would be 1+3+5+7+9
10:55:07 <nand`> the first 5 odd numbers
10:55:07 <tards> i can get it on jave but im struggling with the recursion on haskell as ive only just started it
10:55:20 <tards> yeah sorry
10:55:22 <monochrom> and (0+2+4+6) + 4 seems to be (0+1+2+3)*2 + 4
10:55:40 <tards> *java
10:55:55 <Redshift64> .,.?
10:56:09 <Redshift64> oh
10:56:10 <c_wraith> tards: you don't need any direct recursion for this
10:56:19 <monochrom> you could do recursion in java, too. you could also do functional programming in java. use no variables. allow yourself parameter passing only
10:56:23 <c_wraith> tards: just break the problem down into pieces.
10:56:38 <c_wraith> tards: your first piece: create a list of odd naturals
10:56:39 <monochrom> parameter passing and return value
10:57:10 <c_wraith> second piece: get the first n entries from that list
10:57:12 <tards> okay c_wraith
10:57:16 <nand`> the solution looks like n²
10:57:16 <Jedai> tards: I'm guessing that sumOdd n = (n+1)*n `div`2 isn't good ?
10:57:17 <c_wraith> third piece: add them together
10:57:24 <danharaj> can you create new kinds with the new kind extensions?
10:57:28 <donri> monochrom: I don't think byorgey thinks one noah's as good as any other.
10:57:28 <Jedai> oops
10:57:29 <nand`> sumOdd n = n*n -- confirm?
10:57:42 <tards> yes n=n*n
10:58:04 <Jedai> sumOdd n = (n+1)^2 `div` 4
10:58:08 <donri> > let n=n*n in n
10:58:11 <monochrom> then "referential uniqueness"
10:58:12 <lambdabot>   mueval-core: Time limit exceeded
10:58:18 <nand`> @pl sumOdd n = n*n
10:58:18 <lambdabot> sumOdd = join (*)
10:58:21 <donri> shouldn't that be an occurs check failure
10:58:27 <nand`> >let sumOdd = join (*) in sumOdd 7
10:58:37 <elliott> donri: no
10:58:40 <nand`> > let sumOdd = join (*) in (sumOdd 7, 1+3+5+7+9+11+13)
10:58:41 <lambdabot>   (49,49)
10:58:43 <elliott> donri: why would it be?
10:59:08 <nand`> donri: no that's plain recursion
10:59:23 <byorgey> donri, monochrom: that's the thing, he keeps mutating though.
10:59:40 <byorgey> pretty soon he'll be doing destructive updates to our house, too.
11:00:06 <c_wraith> byorgey: you need to work on developing immutable offspring.  Or maybe an immutable house.
11:00:11 <Jedai> Ok, basing yourself on the nth odd number gives a much simpler formula... :)
11:00:15 <byorgey> c_wraith: hmm, yes...
11:00:25 <c_wraith> "No, the door doesn't open.  We just build a new house that's the same, except the door is already open"
11:00:32 <monochrom> immutable children defeats the point of having children
11:00:34 <byorgey> hahaha
11:00:42 <byorgey> but the new house shares everything else with the old house
11:00:50 <monochrom> only vampires and control freaks wish for immutable children
11:01:18 <Jedai> tards: what's the input ? number of odd numbers to sum or last odd number to sum ?
11:01:48 <nand`> the way he formulated the problem it would be the former, but his example showed the latter
11:02:11 <tards> the number of odd numbers to sum
11:02:17 <nand`> n² then
11:02:36 <c_wraith> nand`: I think you're missing the point of basic intro homework. :P
11:02:44 <tards> so if n is 3 then it sums the first 3 odd numbers i.e. 1+3+5
11:03:05 <monochrom> the point of basic intro homework has not been told at all
11:03:10 <nand`> c_wraith: are you going to tell me it's wrong to answer f(x) = (x²+x)/2 when the problem is “write a function that adds up all of the numbers from 0 to x” next?
11:03:25 <Jedai> nand`: Yes !!! ;)
11:03:48 <nand`> O(1) vs O(n), it should get extra points
11:03:52 <c_wraith> nand`: actually, yes.  That tells you what the sum of those numbers would be, if you were to add them.  It does not actually add them.
11:04:18 <monochrom> there is an addition in x²+x
11:04:19 <nand`> c_wraith: touche, but the question was “find the sum” in this case
11:04:38 <nand`> monochrom: one ≠ all
11:05:02 <monochrom> in fact I wouldn't care "find the sum" vs "add these". same difference
11:05:56 <Jedai> tards: I would suggest the syntax [0,10..50] which evaluate to the list [0,10,20,30,40,50]
11:06:14 <c_wraith> nand`: I suppose you've got a point. But I still suspect this is an intro homework question, and finding a closed form (whatever you define that to mean..) for the calculation is missing the point.
11:06:15 <donri> all for one, one for all
11:06:34 <Jedai> tards: adapt it to produce your list of odd integer until (2*n-1) and sume them all !
11:06:35 <elliott> if we try a little harder, we can be even less helpful :)
11:06:49 <nand`> > let f =  sum . flip take [1,3..] in f 5
11:06:50 <lambdabot>   25
11:06:56 <Jedai> elliott: It was pretty good already I think :)
11:06:56 <c_wraith> Jedai is actually trying to help...
11:07:03 <monochrom> the thing is almost none of you are in that class, and so almost none of you know what the point is
11:07:22 <Jedai> Or use take...
11:07:26 <nand`> c_wraith: That's why it's best to just provide both versions in cases like this :)
11:07:31 * hackagebot happstack-data 6.0.1 - Happstack data manipulation libraries  http://hackage.haskell.org/package/happstack-data-6.0.1 (JeremyShaw)
11:07:33 * hackagebot happstack-state 6.1.3 - Event-based distributed state.  http://hackage.haskell.org/package/happstack-state-6.1.3 (JeremyShaw)
11:07:45 <c_wraith> monochrom: then we can be told if the standard thing is wrong. But why waste time asking whether it's something other than the standard thing?
11:08:22 <nand`> bonus points if you include the reasoning behind sum [1..x] = (x²+x)/2
11:08:28 <monochrom> "the" standard thing? there are approximately 5 standard things
11:09:15 <Jedai> nand`: I usually write it (x+1) * x / 2, it's a bit more self-explicative
11:11:15 <monochrom> anyway I am not saying that you should wait for the asker to clarify or reveal extra information either. clearly, the asker is not going to reveal anything.
11:12:42 <nand`> here's my reasoning http://pastebin.com/KhfXSY0j
11:12:43 <mauke> The paste KhfXSY0j has been copied to http://hpaste.org/57640
11:12:46 <nand`> can it be simplified?
11:12:52 <nand`> aka shortened
11:13:06 <monochrom> yes, first, use hpaste :)
11:14:24 <byorgey> nand`: yes, http://pastebin.com/KhfXSY0j
11:14:25 <mauke> The paste KhfXSY0j has been copied to http://hpaste.org/57640
11:14:30 <byorgey> blargh what
11:14:37 <byorgey> sorry, not what I meant to paste
11:14:45 <byorgey> http://www.cut-the-knot.org/ctk/pww.shtml
11:15:44 <monochrom> usually, they do this: f(3)+f(3) = (1+3) + (2+2) + (3+1) = 4 + 4 + 4 etc
11:15:47 <nand`> “This applet requires Sun's Java VM 2 which your browser may perceive as a popup. Which it is not.”
11:15:49 <nand`> ugh
11:16:03 <Clint> you lost me at "applet"
11:16:16 <monochrom> of course, replace "3" by "x". I'm just tired of "x-1", "x-2", "x-3"...
11:16:39 <byorgey> nand`: oh, sorry, let me find you a better link.
11:16:43 <nand`> monochrom: that's also an interesting perspective
11:17:53 <mm_freak_> > let mapEach n f = zipWith ($) (cycle (f : replicate (pred n) id)) in mapEach 5 ('!':) (repeat "ha")
11:17:54 <lambdabot>   ["!ha","ha","ha","ha","ha","!ha","ha","ha","ha","ha","!ha","ha","ha","ha","...
11:18:35 <nand`> more like mapEach 5 (++"!")
11:21:29 <mm_freak_> nand`: doesn't really matter
11:21:52 <mm_freak_> just wanted to share a nice mapEach implementation =)
11:22:30 <nand`> I know, it looks intriguing
11:22:57 <mm_freak_> :t \n f = zipWith ($) (cycle (f : replicate (pred n) id))
11:22:58 <lambdabot> parse error on input `='
11:23:03 <mm_freak_> :t \n f -> zipWith ($) (cycle (f : replicate (pred n) id))
11:23:04 <lambdabot> forall b. Int -> (b -> b) -> [b] -> [b]
11:29:50 <elliott> mm_freak_: hmm... mapEach n f = zipWith ($) $ mapEach n (const f) (repeat id)
11:30:01 <elliott> perhaps replaceEach is a better primitive
11:57:07 <hpaste> “Ertugrul Söylemez” pasted “Infinite lazy list of natural numbers together with all of their divisors” at http://hpaste.org/57641
11:59:03 <cmccann> byorgey, turns out you got a nod in an answer to that SO question anyway, with a link to your pearl about species :D
11:59:56 <mm_freak_> elliott: i just needed it for the above paste =)
12:00:22 <byorgey> cmccann: hah, excellent =)
12:00:40 <cmccann> byorgey, from sigfpe, actually
12:01:56 <mm_freak_> another sieve again, but this time not necessarily with high performance in mind
12:03:02 <byorgey> cmccann: ah, cool
12:03:08 <mm_freak_> should have around the same performance as the list-based infinite prime sieve, which isn't fast anyway
12:03:28 <byorgey> cmccann: at this point it looks like I don't really have that much to add =)
12:04:45 <cmccann> byorgey, yes, and letting sigfpe explain things while citing something you wrote is a good strategy overall I think
12:04:56 <byorgey> agreed! =D
12:07:04 <elliott> cmccann: in these, have you considered generalising zipThese to that align thing (from http://pchiusano.blogspot.com/2010/06/alignable-functors-typeclass-for-zippy.html)? OneOrBoth is just These so it seems like an interesting generalisation, but maybe it belongs in another package...
12:09:21 <cmccann> elliott, I think it makes sense in that package
12:10:03 <cmccann> since it's pretty tied to the semantics of having an inclusive or type
12:10:07 <elliott> these package, this package, that package :)
12:10:14 <cmccann> heh
12:10:43 <elliott> it'd also give you (Maybe a, Maybe b) -> These a b (as uncurry align)
12:11:09 <otters> these
12:11:09 <otters> hm
12:11:32 <cmccann> you can't get that from two Maybes, though
12:11:54 <elliott> er, right, silly me
12:11:59 <elliott> never mind :)
12:12:10 <cmccann> otters, "these" means https://github.com/isomorphism/these
12:12:26 <erus`> can anyonly point me to some superfast polygon fill routine please? i guess it involves triangulation and then scanline generation or something
12:12:29 <elliott> err, who's the person to ping about spam again? Poonigbyte is advertising that racist forum.
12:12:35 * hackagebot hint 0.3.3.4 - Runtime Haskell interpreter (GHC API wrapper)  http://hackage.haskell.org/package/hint-0.3.3.4 (DanielGorin)
12:14:02 <elliott> oh, marienz... but I just told #freenode anyway
12:14:26 <Clint> how does one run a pkg-config-like command from cabal when it's not pkg-config?
12:14:53 <elliott> Clint: I don't think you can... maybe with a custom build type
12:15:39 <Clint> meh
12:15:47 <CodeWeaverX> erus`:  Why not google for
12:15:47 <CodeWeaverX> polygon fill algorithm
12:15:47 <CodeWeaverX> There's lots of variations, but a fast scan-line version on convex polygons generally involves doing two modified Bresnham's Line algorithms in parallel on the left and right sides to find each horizontal line that needs to be filled in.
12:16:16 <cvprog> hello world what is wrong with ( x, y) <- [("string), (90)]
12:17:51 <nand`> cvprog: type mismatch
12:17:55 <nand`> oh wait
12:17:59 <nand`> you're in a do block aren't you
12:18:13 <byorgey> cvprog: there is no matching " at the end of the string.  Also  [("string"), (90)] is the same as ["string", 90] and it's not allowed to have elements of different types in a list.
12:18:22 <byorgey> cvprog: perhaps you meant [("string", 90)] ?
12:18:31 <byorgey> i.e. a list containing a single element, which is a tuple.
12:18:39 <cvprog> nand`: ill try
12:18:40 <nand`> you're probably thinking of (x, y) <- [("string", 90)]
12:19:08 <byorgey> nand`: could be a list comprehension.
12:19:27 <nand`> which is incidentally no different from just defining x and y as "string" and 90 in this case
12:20:21 <cvprog> byorgey: no instance of (fractional [char])
12:20:41 <nand`> cvprog: that's telling you strings aren't numbers
12:20:46 <nand`> you're trying to use a string as a number. stop that
12:20:55 <cvprog> ;#
12:20:58 <cvprog> ;#
12:21:01 <cvprog> ;3
12:21:08 <cvprog> oops shift lock
12:21:31 <byorgey> > 3.4 + "hello"
12:21:33 <lambdabot>   No instance for (GHC.Real.Fractional [GHC.Types.Char])
12:21:33 <lambdabot>    arising from the ...
12:21:34 <nand`> you can disable the capslock key (if you meant that, unless you're talking about sticky keys, which can be disabled as well)
12:22:06 <edusaur> is the IO Monad the sole cause of impurity in Haskell functions?
12:22:20 <nand`> no
12:22:22 <cvprog>  In the expression: [("vlc"), 0.1]
12:22:22 <cvprog>     In an equation for `myXOpacity': myXOpacity = [("vlc"), 0.1]
12:22:38 <nand`> there are a few other unsafe functions
12:23:15 <mekeor> is it possible to install two different versions of a package with cabal? (e.g. the base-package)
12:23:46 <mekeor> in principle, yes, right?
12:24:00 <nand`> would surprise me if not
12:24:11 <nand`> then again, cabal isn't a package manager
12:24:15 <nand`> you may have to download the old version yourself
12:24:35 <byorgey> it is possible in general, but DO NOT attempt it with 'base'!
12:24:45 <mekeor> byorgey: why?
12:24:54 <elliott> mekeor: You are not allowed to change the versions of the boot packages.
12:25:17 <mekeor> it just sucks that lots of packages dont work with base-4.5 --  argh
12:25:18 <gwicke> hello, I am looking for a name that plays on a bijection between wikitext and DOM
12:25:18 <elliott> Which are the about ~10 (IIRC) packages that GHC depends on.
12:25:20 <nand`> I guess because your version of GHC requires them to be at that version
12:25:23 <mekeor> elliott: oh
12:25:27 <elliott> base is one of these.
12:25:28 <gwicke> or between chaos and a tree..
12:25:52 <byorgey> mekeor: the solution to that is to fix those packages, or email the maintainers, or wait a bit to upgrade your GHC
12:26:10 <byorgey> mekeor: usually the fix is as simple as increasing the version bound on the 'base' dependency
12:26:29 <mekeor> byorgey: yes
12:32:38 <noteventime> Nc
12:33:30 <cvprog> how can i get ["vlc",0.1] to represent x and y  from right to left ?
12:34:13 <Axman6> that's a type error
12:34:48 <Axman6> well, unless you have an instance for Num String, Floating String
12:35:10 <Enigmagic> or impredicative types
12:35:11 <hpc> that's an instance you don't want, btw
12:35:37 <Axman6> hpc: "Hello" + 0.1 is a bad thing? D:
12:36:18 <hpc> @let watman = repeat 16 "NaN" ++ " Batman!"
12:36:18 <hpc> > watman
12:36:19 <lambdabot>  <local>:3:9:
12:36:19 <lambdabot>      Couldn't match expected type `[Char] -> m'
12:36:19 <lambdabot>             aga...
12:36:19 <lambdabot>   Not in scope: `watman'
12:36:22 <hpc> argh
12:36:27 <hpc> @hoogle String -> Int -> String
12:36:27 <lambdabot> Test.QuickCheck.Text number :: Int -> String -> String
12:36:27 <lambdabot> Test.QuickCheck.Text short :: Int -> String -> String
12:36:28 <lambdabot> Prelude drop :: Int -> [a] -> [a]
12:36:50 <elliott> hpc: concat . replicate n
12:36:55 <hpc> gotcha
12:36:57 <elliott> hmm, is there not a name for that?
12:36:58 <hpc> @undefine
12:37:02 <hpc> you get the point though :P
12:37:20 <hpc> in perl it's the 'x' operator
12:37:28 <hpc> "wat" x 3 = "watwatwat"
12:37:36 * hackagebot leveldb-haskell 0.0.1 - Haskell bindings to LevelDB  http://hackage.haskell.org/package/leveldb-haskell-0.0.1 (KimAltintop)
12:37:45 <hpc> they at least had the sense to make it different from (*)
12:38:15 <nand`> :t 0.1
12:38:16 <lambdabot> forall t. (Fractional t) => t
12:38:46 <cmccann> elliott, btw if you're forking these in order to add the align stuff I was already doing that myself
12:41:15 <elliott> cmccann: oh, ok :P i already wrote instances and everything, too!
12:41:36 <cmccann> elliott, haha oh well
12:42:06 <cmccann> I wasn't done yet so if you've got a bunch of stuff already then ok
12:42:31 <cmccann> I wanted to tweak a couple things though
12:42:38 <cmccann> like it makes sense to me to have align and alignWith
12:42:39 <elliott> well, not that much :P I did define some instances for the equivalent of unzipThese, though
12:42:50 <elliott> yeah, I had that too :P
12:42:54 <cmccann> heh
12:43:05 <elliott> unfortunately I don't think an efficient Map instance is possible without peeking at the internal representation :(
12:43:33 <cmccann> hm, why not?
12:43:46 * cmccann hadn't gotten to Map yet
12:44:07 <elliott> well, the only way to "zip" two Maps is to go via lists, because Map doesn't expose any kind of "combining" like that... except, hmm
12:44:19 <elliott> aha, I can do it with unionWith
12:45:00 <cmccann> yeah, that should work
12:45:10 <elliott> do you want to continue writing yours or shall I? no point duplicating work, after all
12:45:20 <cmccann> inject both to This and That, then merge in the obvious way
12:46:03 <cmccann> sounds like you're ahead of me and I've got other stuff I should be doing anyway
12:46:10 <cmccann> what module did you use?
12:46:28 <johnsingleton> I remember reading about a pragma or something like that that would temporarily cause ghci to export everything -- does anyone know what that is?Did I imagine that… Some google sleuthing reveals nothing, so I am tempted to say yes…
12:46:30 <elliott> Data.Align, though I was considering Control.Align for the Applicative analogy
12:46:39 <elliott> but I hate the Data vs. Control distinction anyway :P
12:46:53 <cmccann> yeah it's kinda silly
12:47:05 <cmccann> calling it Alignable seems better to me though
12:47:09 <worldsayshi> Q: Is there a way to only get the first compilation error when loading a module in ghci? (I'd like to work with them one at a time)
12:47:33 <elliott> cmccann: well, I was calling it Align because Alignable has empty, and I was omitting empty; the blog post author called Alignable-without-empty Align
12:47:39 <elliott> but maybe I should include empty after all
12:47:47 <elliott> gives more laws, too
12:47:56 <cmccann> this is modeled after Applicative in some ways but it's a bit removed from the "lifting currying" part that makes Applicative more of a control structure
12:48:17 <elliott> well it's analogous to the f (), f a -> f b -> f (a,b) form of Applicative I think
12:48:25 <cmccann> it is
12:48:42 <cmccann> but (a, b) is a lot more meaningful
12:49:00 <elliott> I guess I'll go write that Map instance :P
12:49:18 <cmccann> I mean, how would you replicate the chaining behavior of (<*>) here?
12:49:32 <cmccann> the actual uses of this remind me more of Foldable and Traversable
12:49:48 <cmccann> which is why I stuck mine in Data.Alignable
12:50:28 <cmccann> anyway the only not-completely obvious things I have are an instance for ZipList and using align and alignWith instead
12:53:07 <cmccann> elliott, anyway go ahead and do the stuff you had in mind and I'll merge and add anything else I want on top of that
12:53:27 * cmccann doesn't care that much about the module name, btw
13:06:20 <elliott> hmm, do any standard typeclasses end in -able?
13:06:33 <elliott> most seem to be named after concepts or the operation itself (Eq, Ord)
13:06:45 <elliott> although I suppose Ord is more "orderable"
13:06:53 <donri> Typeable? define standard
13:07:39 <elliott> oh, Foldable/Traversable
13:07:49 <elliott> I don't like Foldable though, so it doesn't count.
13:11:09 <elliott> hmph, yet again Set can't be an instance of a typeclass
13:11:32 <Phlogistique> Setable would be a nice name
13:17:16 <scolobb> Hello :-) Are there people around to whom I could talk about this http://hackage.haskell.org/trac/summer-of-code/ticket/1590 and that http://hackage.haskell.org/trac/summer-of-code/ticket/1582 ? :-)
13:17:39 <scolobb> I'd like to try to get into GSoC this year, and I love Haskell :-)
13:19:44 <ivanm> scolobb: try emailing cabal-dev's maintainer and Duncan Coutts (Cabal's maintainer)
13:19:48 <ivanm> for the first one
13:20:03 <ivanm> for the second one, ask the GHC devs
13:22:39 * hackagebot stm-conduit 0.2.1 - Introduces conduits to channels, and promotes using  conduits concurrently.  http://hackage.haskell.org/package/stm-conduit-0.2.1 (ClarkGaebel)
13:25:02 <scolobb> ivanm: Thank you :-)
13:25:07 <ivanm> np
13:25:30 <scolobb> I've seen this person Johan Tibell listed among GSoC admins last year
13:25:59 <scolobb> I wrote him a couple short messages regarding the cabal-dev idea, but, as I understand it, he's on a vacation now
13:26:16 <scolobb> Does he normally hang out online often, when he's not on vacation?
13:26:32 <cmccann> he's in here pretty regularly I think?
13:26:33 <scolobb> (I haven't yet received a single bit of feedback from heim)
13:26:50 <scolobb> Is he know as tibbe here ?
13:27:27 <cmccann> I think that's him, yes
13:27:37 <ivanm> I don't think tibbe is the cabal-dev maintainer...
13:27:56 <arcatan> preflex: xseen tibbe
13:27:56 <preflex>  tibbe was last seen on freenode/#ghc 5 days, 19 hours, 24 minutes and 54 seconds ago, saying: I don't want to teach wrong things
13:27:59 <ivanm> Rogan Creswick and Jonathon Daugherty are
13:28:12 <ivanm> oh, right, as the GSoC admin
13:28:13 <elliott> who do we have to bother to get Set to be a GADT with the Ord instance in it?
13:28:21 <c_wraith> tibbe is on vacation right now, also
13:28:22 <ivanm> elliott: libraries@
13:28:30 <ivanm> elliott: or use Heffalump's rmonad package
13:28:35 <scolobb> ivanm: I'll mail the people you've told me, as well, of course, since they are the devs
13:28:48 <scolobb> But getting in touch with tibbe would be desirable, that's why I'm asking :-)
13:28:56 <scolobb> Thanks for information, everyone :-)
13:29:15 <cmccann> elliott, that would actually work in this case, wouldn't it?
13:29:28 <cmccann> since it doesn't for Applicative &c.
13:29:51 <ivanm> though how would you do a comparison between Sets for ordering?
13:31:36 <elliott> cmccann: it works for Align/Unalign
13:31:46 <elliott> because they don't have any way to inject values
13:31:49 <cmccann> yeah
13:31:55 <elliott> although adding empty to Align(able) would break that
13:31:57 <cmccann> whereas Applicative can't avoid the context on pure
13:32:00 <elliott> (but it'd also break the Map instance, so)
13:32:00 <cmccann> no, empty is fine
13:32:06 <elliott> oh, right
13:32:11 <elliott> no function arrow
13:32:12 <cmccann> you can create a Set without the constraint
13:32:16 <openjoke> ciao !list
13:32:29 <elliott> ivanm: using rmonad is the most pessimal solution to this problem I can think of :P
13:32:33 <elliott> oh well, who uses Sets, anyway?
13:32:39 * hackagebot hashring 0.0.0 - Efficient consistent hashing.  http://hackage.haskell.org/package/hashring-0.0.0 (MichaelCraig)
13:32:44 <elliott> openjoke: i suspect you're in the wrong place
13:32:57 <cmccann> elliott, nobody, everyone uses lists for everything
13:32:59 <openjoke> i suppose yes
13:33:06 <cmccann> it's really the only data structure you need
13:33:24 <elliott> cmccann: um, excuse me, the One True Data Structure is clearly Free []
13:33:49 <elliott> (as seen in Ursula!)
13:34:03 <tromp__> pairs are all you need
13:34:06 <elliott> *Ursala
13:35:33 <cmccann> well, lists are just Free ((,) a) () anyway
13:36:01 <donri> Bool is the only type you need
13:36:06 <elliott> oh, you don't need the element type, of course
13:36:14 <elliott> Free Maybe ()
13:37:00 <elliott> anyway, if Free [] can produce programs like http://web.archive.org/web/20081025070234/http://www.basis.uklinux.net/ursala/queen.fun and http://web.archive.org/web/20081025060906/http://www.basis.uklinux.net/ursala/extra.fun, who can argue with its perfection?
13:37:24 <elliott> (n.b. that language is serious)
13:37:35 <cmccann> haha
13:37:41 <rwbarton> "extra fun" indeed
13:37:50 * hackagebot texmath 0.6.0.2 - Conversion of LaTeX math formulas to MathML or OMML.  http://hackage.haskell.org/package/texmath-0.6.0.2 (JohnMacFarlane)
13:38:06 <elliott> its compiler has a mode to print the AST of compiled expressions
13:38:10 <elliott> needless to say, it's more readable than the input
13:39:13 <cmccann> heh
13:41:55 * elliott wonders if there's a clever way to do align on Seq...
13:42:51 * hackagebot Ebnf2ps 1.0.10 - Peter's Syntax Diagram Drawing Tool  http://hackage.haskell.org/package/Ebnf2ps-1.0.10 (PeterThiemann)
13:43:40 <scolobb> Do you think I can bother Edward Kmett with my questions about LLVM and sandboxed builds?
13:44:07 <scolobb> Hm, I can't anyway, since I don't have his E-mail :-(
13:44:34 <elliott> preflex: xseen edwardk
13:44:34 <preflex>  edwardk was last seen on freenode/#haskell 16 hours, 21 minutes and 55 seconds ago, saying: yes, but the version without the silly extra variable has quite nice aesthetics ;)
13:45:01 <scolobb> Aha, preflex is great, thank you
13:45:29 <Eduard_Munteanu> scolobb: he's often around
13:45:40 <scolobb> That's great :-)
13:45:46 <Axman6> what does edwardk have to do with llvm?
13:45:51 <scolobb> I'll wait for him and terrorize him
13:46:00 <scolobb> Axman6: He's listed as GSoC 2011 admin
13:46:07 <Axman6> hmm, ok
13:46:11 <mm_freak_> scolobb: you can also leave him a message…  just type:  @tell edwardk YOURMESSAGE
13:46:45 <scolobb> mm_freak_: Wow :-) Is this another lambdabot magic?
13:46:53 <mm_freak_> yes =)
13:47:09 <Axman6> @tell scolobb pow!
13:47:10 <lambdabot> Consider it noted.
13:47:16 <scolobb> I need a T-shirt with "I love lambdabot" :-)
13:47:16 <lambdabot> scolobb: You have 1 new message. '/msg lambdabot @messages' to read it.
13:47:39 <elliott> Some of us are VERY well-acquainted with lambdabot's messaging feature.
13:47:56 * Axman6 isn't sure how to take that
13:47:56 <elliott> Almost *too* acquainted, in fact.
13:47:59 <scolobb> Thanks for the suggestion :-)
13:48:05 <Axman6>  @tell hookups?
13:48:18 <elliott> Axman6: the unending saga of lambdabot pinging me with message notifications at random intervals throughout the #haskell day :P
13:48:33 <scolobb> Huh :-D
13:48:40 <scolobb> lambdabot is the channel pet, seemingly :-)
13:48:46 <Axman6> #haskell does not have days, the sun never sets in #haskell
13:48:52 <scolobb> Does anyone feed him?
13:48:56 <Axman6> her
13:48:57 <scolobb> Axman6, do you? :-)
13:48:59 <Axman6> @botsnack
13:48:59 <lambdabot> :)
13:49:04 <scolobb> Oh, sorry, her :-)
13:50:02 <nand`> http://www.haskell.org/wikiupload/1/13/Lambdabot.png <-- ain't she a beauty?
13:50:25 <scolobb> nand`: Oh, she certainly is :-)
13:50:50 <scolobb> Someone has to give her a gift for the Valentine's
13:50:55 <albel727> hehe
13:51:50 <albel727> south park style, though.
13:51:57 * albel727 votes for anime-style version.
13:52:11 <Damn3d> I gave a teacher a valentine gift once.. She was really fat
13:52:16 <Damn3d> so I sent her a piece of ham via mail
13:52:39 <scolobb> Damn3d: You do know how to make people happy :-D
13:52:47 * albel727 has an inckling, that it didn't go all that well.
13:52:51 * hackagebot derive-trie 0.2.1 - Automatic derivation of Trie implementations.  http://hackage.haskell.org/package/derive-trie-0.2.1 (AndreasBaldeau)
13:52:53 * hackagebot regexp-tries 0.2 - Regular Expressions on Tries.  http://hackage.haskell.org/package/regexp-tries-0.2 (AndreasBaldeau)
13:53:27 <Damn3d> scolobb On her birthday we gave her a box of chocolates
13:53:32 <Damn3d> she didn't notice it was empty :)
13:53:37 <Damn3d> but it was for her good
13:53:41 <Damn3d> it's unhealthy anyway
13:56:07 <scolobb> Damn3d: Oh wow :-D
13:56:30 <scolobb> Your therapy sounds, heh, effective, maybe :-D
14:07:55 * hackagebot TCache 0.9.0.3 - A Transactional cache with user-defined persistence  http://hackage.haskell.org/package/TCache-0.9.0.3 (AlbertoCorona)
14:19:52 <elliott> ok, I think that's quite enough instances for one day
14:20:13 <cmccann> no, you must write all the instances.
14:20:36 <CodeWeaverX> At least in this instance.
14:21:57 <elliott> cmccann: All of them? :(
14:22:16 <cmccann> yes. all of them!
14:22:38 <elliott> I have Identity, Maybe, [], ZipList, Tree, Seq, Map k, IntMap. Isn't that all the types?
14:23:35 <cmccann> hm
14:24:10 <cmccann> I was actually trying to decide if there's an obvious instance for (->)
14:24:19 <elliott> Yes, there is.
14:24:26 <cmccann> that's neither trivial nor superfluous
14:24:44 <elliott> Well, (liftA2 align) is the correct instance, because you can consider (i -> v) an i-indexed structure of vs.
14:24:55 <nand`> elliott: instance for what?
14:24:58 <elliott> And of course, there's such an i for every fixed shape of a ZipList.
14:25:05 <elliott> (which obviously have These for all the results)
14:25:11 <cmccann> yeah, of course.
14:25:20 <elliott> Then consider (i -> Maybe v), which is an i-indexed structure of vs with holes in them; liftA2 align does the right thing there, too. etc. etc.
14:25:43 <elliott> nand`: Align(able)
14:25:48 <cmccann> but any sort of "always full" container is a little silly for this, but yeah I guess that does make more sense than any other (->) instance
14:26:11 <elliott> I've held off on defining any instances that look like liftA2 <anything>, because those instances can be annoying in general.
14:26:21 <elliott> like instance Monoid Maybe that everybody seems to hate
14:26:33 <elliott> instance (Monoid a) => Monoid (Maybe a), whatever
14:26:41 <cmccann> well, isn't that because there are multiple instances that make similar sense?
14:26:55 <cmccann> if there's only one lifted instance that's sensible there's no reason not to add it
14:27:31 <dmwit> instance Semigroup a => Monoid (Maybe a)
14:27:42 <elliott> cmccann: Exactly, but it's easy to manually lift, so adding lifted instances en masse is a bad idea in case you accidentally give one that has another, less trivial implementation.
14:28:04 <cmccann> elliott, ok. fair enough.
14:29:05 <elliott> hmm, maybe Unalign(able) belongs in its own module
14:29:15 <cmccann> what about instances for monad transformers and stuff like that?
14:29:34 <cmccann> note that these already depends on mtl/transformers because I have a These transformer
14:31:10 <elliott> those would be reasonable, although I was wondering if any monad transformers might actually have non-lifting instances... for instance, ListT does
14:31:20 <elliott> (ignoring the fact that ListT is not, in fact, a monad transformer)
14:31:29 <cmccann> right
14:31:44 <cmccann> on the other hand you might be able to get instances that you wouldn't have otherwise
14:32:10 <_Mikey> high guys!
14:32:24 <cmccann> like I don't know what's up with ErrorT these days but if you have some way to fill in the Left case you should get an instance for Either
14:32:31 <_Mikey> is there a good source on the rules and regulations of haskell whitespacing?
14:32:42 <elliott> oh, I forgot about Either
14:32:58 <elliott> _Mikey: Many people follow https://github.com/tibbe/haskell-style-guide/blob/master/haskell-style.md.
14:33:25 <elliott> cmccann: you need (Semigroup e) for the Either instance, though
14:33:29 <elliott> but yes
14:33:37 <cmccann> elliott, right, and that's kind of meh
14:34:03 <cmccann> but if ErrorT still gives you a default error value then you can use that
14:34:15 <elliott> cmccann: oh, I don't think there is a "reasonable" instance, actually... e.g. what is align (Left 42) (Right "abc")?
14:34:30 <_Mikey> thanks elliott I'm now following.
14:35:07 <cmccann> elliott, I would expect it to follow the behavior of Maybe
14:35:31 <cmccann> which again makes sense if we're talking the "error monad" version
14:35:38 <cmccann> but not necessarily for plain Either
14:35:58 <elliott> right, I suppose ErrorT does have a reasonable instance
14:36:04 <cmccann> similarly I wouldn't bother with instances like (,)
14:36:07 <cmccann> or These
14:36:08 <cmccann> for that matter
14:36:21 <cmccann> even though you could kludge some constraint onto them to make it work
14:36:34 <elliott> I thought about giving a These instance but then my brain started hurting.
14:36:47 <cmccann> but the monad transformers often take care of that for you so in that case why not
14:36:52 <elliott> I can't figure out any laws for unalign :(
14:37:08 <rwbarton> I suspect this Ursala language actually is a joke, even though the manual explicitly claims it's not.
14:37:14 <elliott> or rather, how to express why (\a -> (fmap foo a, fmap foo bar)) isn't a valid instance for all functors
14:37:19 <elliott> since it can "duplicate" effects
14:38:06 <elliott> rwbarton: I can authoritatively say that nobody in the esoteric programming language community has ever produced a language as confusing as Ursala.
14:38:13 <hpaste> “_Mikey” pasted “Whitespace woes” at http://hpaste.org/57646
14:38:14 <elliott> Okay, not authoritatively. But surely.
14:38:24 <cmccann> elliott, is that the generalized version of unzipThese?
14:39:17 <rwbarton> It's hard to believe the author really wrote things like "They either work on the first try or are easily corrected by a quick inspection of the decompiled code" with a straight face.
14:39:24 <_Mikey> I'm not using tabs, and I think it should compile but I'm still getting indentation problem.
14:39:43 <elliott> cmccann: yeah; only [] and ZipList have "non-obvious" instances I can think of, and even those are just for performance
14:39:54 <elliott> but consider, e.g. IO
14:40:04 <elliott> you can't give IO a reasonable unzip instance, because it'll duplicate the effects
14:40:09 <cmccann> right
14:40:13 <elliott> actually I think MonadZip has a law along those lines
14:40:29 <elliott> http://hackage.haskell.org/packages/archive/base/4.5.0.0/doc/html/Control-Monad-Zip.html -- right, the naturality law
14:40:45 <cmccann> zipThese and unzipThese don't really work as inverses, but insofar as you can do that they should give the same thing you started with
14:41:02 <cmccann> and I'd expect the same of align and unalign in whatever way makes sense
14:41:52 <elliott> yeah
14:41:59 <cmccann> my only real requirement with unzipThese was that I expect it to not discard information
14:42:10 <elliott> I suppose Unalign(able) should have Align(able) as the superclass, then
14:42:20 <cmccann> the only thing you inevitably lose is the knowledge that zipping the lists together will never be Nothing and Nothing
14:42:32 <cmccann> which is partly the point
14:42:57 <elliott> yes, otherwise the result type would be... f (These a b) :P
14:42:58 <cmccann> and why I didn't write it more like partitionEithers
14:44:13 <elliott> clearly the Traversable-equivalent for Alignables should be called Alignaversable
14:45:15 <cmccann> that is definitely an entirely reasonable name for a thing to have.
14:45:49 <elliott> ThingThatCanBeTraversedInAnyFunctorThatHasAnAlignableInstanceDotDotDotAble
14:46:24 <cmccann> ok.
14:47:00 <cmccann> spelling out the ellipsis is a nice touch.
14:47:19 <elliott> the committee sadly rejected my proposal to make the ellipsis character valid in identifiers.
14:47:34 <cmccann> that's terrible.
14:47:55 <Pseudonym> I realise it's the 21st century, but 7-bit ASCII is still the standard.
14:48:12 <elliott> Pseudonym: Are you mistaking me for someone who's serious?
14:48:20 <_Mikey> :)
14:48:27 <cmccann> and besides, the standard for my code is "whatever my editor supports"
14:48:29 <elliott> anyway, unicode is already allowed in haskell identifiers, ellipsis is just the wrong type of character
14:48:33 <elliott> it works as an infix operator, IIRC
14:48:40 <cmccann> I use a dumb code editor, not even anything fancy.
14:48:45 <scolobb> elliott: You've got two double characters in the nick.  That's a sure indicator of someone how's serious.
14:48:46 <scolobb> :-)
14:48:53 <Pseudonym> No, I'm musing openly.
14:48:55 <cmccann> anyone whose editor can't cope with what mine uses has other issues than unicode.
14:49:21 * elliott doesn't think 7-bit ASCII is still the standard anywhere except for the kind of places people who think 7-bit ASCII is still the standard hang out
14:49:32 * Pseudonym still edits Haskell code from low-powered devices SSHed to remote machines.
14:49:35 <elliott> that sentence is more deeply-nested than most lisp programs.
14:49:55 <cmccann> the modern standard for text encoding is incorrectly-displayed unicode.
14:49:57 <Pseudonym> Unicode doesn't always make it through multiple levels of translation.
14:49:59 * _Mikey chuckle
14:52:42 <_Mikey> so elliott
14:52:55 <_Mikey> the whitespace rules aren't special for if statments?
14:53:13 <_Mikey> just nested blocks and keep them the same width in till the end of the block?
14:53:23 <_Mikey> only spaces naturally
14:55:49 <hpaste> “_Mikey” annotated “Whitespace woes” with “Whitespace woes (annotation)” at http://hpaste.org/57646#a57647
14:56:16 <elliott> _Mikey: Don't format it like that.
14:56:19 <elliott> Use:
14:56:20 <elliott> if a
14:56:22 <elliott>   then b
14:56:24 <elliott>   else c
14:56:35 <hpaste> “_Mikey” annotated “Whitespace woes” with “Whitespace woes (annotation) (annotation)” at http://hpaste.org/57646#a57648
14:57:13 <_Mikey> hmm ok
14:57:46 <rwbarton> can you actually use do syntax like this?
14:57:57 <rwbarton> > do { let { x = 3 }; let { y = 5 }; x + y }
14:57:58 <lambdabot>   8
14:58:00 <rwbarton> :O
14:58:09 <rwbarton> we need a name for this design pattern
14:58:15 * cmccann prefers to use "if x then foo" on one line
14:58:23 <cmccann> then align "else" with "then"
14:58:44 <rwbarton> in my code the "else" line would often begin on column 90 then
14:59:02 <elliott> can you do bold in Haddocks?
14:59:21 <cmccann> rwbarton, that's one of the reasons I do it that way
14:59:33 <cmccann> to discourage myself from very long lines
14:59:39 <rwbarton> trying to take advantage of the trend towards wide-screen monitors, I see.
15:00:00 <cmccann> no, I usually keep my code under 80 columns
15:00:11 * ddarius doesn't.
15:00:12 <Enigmagic> i restrict myself to 20 columns
15:00:33 <ddarius> Well, I guess I do typically, but only because most lines of code aren't going to reach anywhere near 80 columns.
15:00:42 <hpaste> “_Mikey” annotated “Whitespace woes” with “Whitespace woes (annotation) (annotation) (annotation)” at http://hpaste.org/57646#a57649
15:00:51 <mauke> I use chinese characters to keep my identifiers short
15:01:02 <cmccann> mauke, oh that's a good idea
15:01:15 <_Mikey> not sure if serious
15:01:16 <cmccann> wait, do those count as lowercase?
15:01:19 <scolobb> mauke: Heh, that's cool
15:01:24 <cmccann> ...and does that even make sense?
15:01:27 <Pseudonym> "My function name means crisis AND opportunity!"
15:01:33 <gatlin> While we're on about code aesthetics (I see ddarius is here) I have one final question about this -> https://gist.github.com/1755736 … it'll probably make some cry but I'm interested in seeing how perhaps Maybe could be beneficial
15:01:40 <_Mikey> :D
15:02:26 <mauke> > let 壊 = 42 in 壊
15:02:26 <lambdabot>   42
15:02:43 <_Mikey>   not bad..
15:02:56 <Enigmagic> cmccann: last i checked they're not lowercase
15:03:00 <elliott> cmccann: btw, your per-module documentation doesn't show up in haddocks
15:03:02 <Enigmagic> according to mr unicode
15:03:14 <mauke> > generalCategory '壊'
15:03:15 <lambdabot>   OtherLetter
15:03:46 <elliott> gatlin: Aw, you didn't get rid of containsEmpty yet.
15:03:58 <cmccann> elliott, argh, I never understand how haddocks work
15:04:05 <elliott> cmccann: Badly.
15:04:09 <elliott> And undocumentedly.
15:04:11 <cmccann> oh, ok.
15:04:12 <elliott> (Ironically.)
15:04:15 <elliott> -ly.
15:04:18 <cmccann> now I understand everything.
15:04:22 <cmccann> but yeah
15:04:24 <gatlin> excising containsEmpty is causing me quite a bit of syntactic anguish
15:04:44 <cmccann> feel free to fix it if you're feeling motivated :P
15:05:07 <gatlin> because f not containing an empty clause is a property of the formula that must be known before executing certain actions
15:05:43 <hpaste> “_Mikey” annotated “Whitespace woes” with “Whitespace woes (I'm going to crack this!)” at http://hpaste.org/57646#a57650
15:07:13 <gatlin> elliott, if you have any more patience for me I don't know how to enforce this restriction without a Bool
15:07:14 <elliott> sigh, you have to give a complete export list if you want chunks of documentation not attached to any export
15:08:02 <elliott> gatlin: well, easier to fix would be the isNothing/fromJust in unitpropagate
15:08:51 <elliott> gatlin: apart from that, (chooseLiteral f) is a Just iff not (containsEmpty f), yes?
15:08:53 <cmccann> elliott, yeah that annoys me
15:09:13 <cmccann> especially since I can't even use my preferred export list format well if I want documentation chunks in it
15:09:24 <gatlin> how do I go about checking if I was able to retrieve a unit without checking to see if my result isNothing?
15:09:29 <elliott> I use named chunks, so it's less of a problem
15:09:31 <elliott> gatlin: pattern matching
15:09:44 * cmccann considers inventing a sensible documentation syntax and writing a converter from that to haddock, and whether that might be easier than using haddock directly
15:09:53 <elliott> gatlin: whenever you go to use a boolean or a conditional, try and use pattern-matching first
15:10:17 <elliott> cmccann: I would hate Haddock a lot less if it used Markdown
15:10:28 <cmccann> that would be step one
15:10:31 <cmccann> because seriously
15:10:35 <elliott> I considered adding Pandoc support to it once, but then I realised that that would multiply the number of boot libraries by 1000.
15:10:51 <elliott> (Seriously, look at those dependencies: http://hackage.haskell.org/package/pandoc)
15:10:57 <gatlin> elliott: thanks, I'll ruminate on this
15:10:58 <cmccann> yeah, I know
15:10:59 <cmccann> sigh
15:11:11 <elliott> Maybe we just need a lightweight Markdown converter without any dependencies.
15:11:20 <elliott> Sounds like a pain to write, though.
15:11:20 <magicman> Haplo is scheduled between Monday February 13 02:00 UTC and Monday February 13 04:59 UTC.
15:11:41 <elliott> cmccann: your export list style is weird :P
15:12:04 <cmccann> I dunno, markdown is pretty simple at heart
15:12:26 <cmccann> even a subset of markdown with all the essential formatting would probably be easy to parse
15:12:56 <elliott> everything's simple at heart
15:13:11 <elliott> then someone needs more than the heart and you hear "WHY CAN'T THIS THING JUST BE NORMAL MARKDOWN?!" off in the distance...
15:13:28 <cmccann> yeah well
15:13:38 <cmccann> the answer is "it's still better than haddock"
15:14:10 <_Mikey> would redoing haddock from scratch be better ^^
15:14:44 <elliott> no, haddock, do not render 'Data.Align' as the word "Align"
15:15:04 <elliott> oh, even better
15:15:10 <elliott> it tries to link to the Align type in the Data module
15:15:10 <_Mikey> :)
15:15:12 <elliott> thanks!!
15:15:23 <mm_freak_> elliott: what about a lightweight fork of pandoc?
15:15:57 <mm_freak_> after all you probably only need a markdown reader for the internal document format of haddock, whatever that is
15:16:02 <elliott> mm_freak_: that sounds like more work than just writing a markdown-only parser from scratch, to be honest
15:16:25 <elliott> does Haddock do non-HTML docs? I forget
15:16:32 <mm_freak_> not sure…  though markdown seems simple, parsing it is probably not
15:17:36 <elliott> wtf! haddock! you broke my code formatting!
15:21:54 <gatlin> if I have l = Just 1, why can I not write fmap (-) l to receive Just −1 ?
15:22:09 <ion> @type (-)
15:22:10 <lambdabot> forall a. (Num a) => a -> a -> a
15:22:11 <ion> @type negate
15:22:12 <lambdabot> forall a. (Num a) => a -> a
15:22:43 <ion> > fmap (-) (Just 1) <*> Just 5
15:22:43 <lambdabot>   Just (-4)
15:22:56 <ion> > (-) 1 5
15:22:57 <lambdabot>   -4
15:23:28 <gatlin> > 5 + (-2)
15:23:29 <lambdabot>   3
15:23:53 <gatlin> I guess what confused me is that I can use (-) as a unary function
15:24:37 <ion> That’s a controversial exception in Haskell.
15:25:13 <ion> It’s not actually (-) as a unary function, it’s just that (-x) is parsed as negate x.
15:25:23 <gatlin> That makes sense
15:26:00 <mm_freak_> that's why we need this awkward subtract function
15:26:03 <mm_freak_> :t (- 3)
15:26:03 <lambdabot> forall a. (Num a) => a
15:26:09 <mm_freak_> :t (subtract 3)
15:26:10 <lambdabot> forall t. (Num t) => t -> t
15:26:14 <tromp__> > let x = 2 in -x
15:26:15 <lambdabot>   -2
15:27:11 <elliott> cmccann: I've sent a pull request for what I have now
15:31:11 <elliott> cmccann: oh, you already pulled it!
15:31:14 <elliott> i'll close it :P
15:31:43 <nand`> there's also “negate” for when you need \x -> (-x)
15:32:15 <nand`> oh ion mentioned this
15:33:05 <gatlin> in the code that I am continually trying to make more idiomatic, I have already included this
15:33:41 <gatlin> I'm concurrently working through Learn You a Haskell, so I thought I'd use fmap just to see what it feels like
15:46:10 <pfn> gatlin, I'm reading it too, and it's starting to all fly over my head, I think I'm getting bored of learning without doing
15:46:38 <pfn> (up to the monoids and functors section)
15:47:05 <elliott> most people go through haskell tutorials too quickly, which leads to burnout like that.
15:47:25 <gatlin> yeah. That's why I came in here, pfn: I wrote some initial garbage that resembled the racket (that I originally wrote it in) and now I want to learn more about monads and state by making something like this
15:47:27 <Axman6> LYAH needs more (/some) exercises
15:47:47 <elliott> yeah i agree
15:47:56 <nand`> definitely
15:48:01 <nand`> why not contribute some
15:48:07 <elliott> but a lot of "flying over head" problems are caused by going quickly to start with (because everything looks simple) and suddenly finding yourself not knowing what's going on because you skipped over the important parts
15:48:16 <gatlin> I'm beginning to see how I can keep using Maybe to define my Formula, elliott. Maybe Formula => Nothing if it contains an empty clause, or Just Formula otherwise, meaning I can pattern match
15:48:26 <pfn> well, it's mostly the verbage, I'm tired of reading and trying to comprehend everything
15:48:38 <pfn> I just want my side-effects and easily please  :)
15:48:54 <Axman6> NO!
15:48:54 <nand`> what I like to do is go through some programming problems, then go through those same problems later on when I learn more and see if I can improve them
15:48:55 <otters> you can't have side effects :3
15:48:56 <gatlin> rather, I could write dpll and unitpropagate to make use of Maybe
15:49:17 * nand` recommends 99 haskell problems
15:49:22 <elliott> gatlin: right
15:49:45 <gatlin> a ray of light just shined out of the ceiling; maybe this is the beginning of wisdom?
15:49:46 <pfn> the other flipside is that I'm coming to haskell after being very comfortable with scala
15:49:53 <otters> shone
15:49:58 <otters> wait
15:49:59 <otters> no
15:50:09 <gatlin> otters: faulty bulb, my mistake
15:50:11 <gatlin> :)
15:50:11 <pfn> so I get lots of the concepts already, but don't wanna deal with going over all the details
15:50:16 <elliott> gatlin: bundling the check (containsEmpty) with the access (chooseLiteral)
15:50:24 <elliott> (same with getUnit)
15:50:25 <Axman6> does thwere exist already something that can be usef for say: foo :: (a -> a -> a) -> Maybe a -> Maybe a -> Maybe a, where the result is either of the Maybe inputs if the other is Nothing?
15:50:28 <pfn> well, a lot of the concepts minus monads and monoids
15:51:17 <elliott> Axman6: you can define it as foo f p q = liftA2 f p q <|> p <|> q... can't think of a more direct way to express it off-hand
15:51:30 <Axman6> yeah :\
15:51:36 <elliott> pfn: Er, Scala uses monads.
15:51:41 <Axman6> not that i actually need it, just curious
15:51:49 <pfn> elliott, yeah, and that's an area I'm still vague on
15:52:01 <gatlin> elliott: at this point containsEmpty exists in my code because otherwise I'd have the same check twice and it makes sense to factor it out, so-to-speak
15:52:04 <pfn> which is why I'm looking at it from another perspective (haskell) to see if I can grok it better
15:52:05 <elliott> (And monoids are by far the simplest "typeclass with scary name". There's not even any parametrisation.)
15:52:22 <elliott> gatlin: mm, no
15:52:25 <elliott> gatlin: you can simply remove it
15:52:31 <elliott> gatlin: because chooseLiteral/getUnit already "do the check"
15:52:33 <pfn> I've just read to the part that's getting hazy and am getting lazy
15:52:37 <gatlin> oh you're right
15:52:47 <gatlin> yeah, an empty clause won't satisfy either
15:52:52 <PatrickRobotham> elliott: Do you think monoids are less scary than functors?
15:53:04 <gatlin> okay, this time the light isn't just the damned bulb
15:53:05 <elliott> gatlin: right -- the reason you check containsEmpty is so that you can fromJust the results of them
15:53:07 <elliott> so... :)
15:53:13 <elliott> PatrickRobotham: Yes.
15:53:20 <Axman6> pfn: monads are amazingly simple in general, and that's why people get so hung up on them, they expect them to 'be more' than they are. it's much easier to just use some different ones (list, Maybe, Either, IO, Binary's Get and Put) than it is to 'understand monads'
15:53:21 <elliott> There's not even the "higher-orderness".
15:53:33 <elliott> You have a value, and a function, and the function is associative.
15:53:40 <pfn> Axman6, indeed, I use Option[T] in scala all the time...
15:53:40 <elliott> And the value is an identity.
15:53:50 <pfn> I never use Either[A,B] though...
15:53:54 <pfn> seems like such a pita
15:53:59 <nand`> monad is just a tuple (F : C->C, η : Id -> F, µ : F∘F->F)
15:54:05 <nand`> that satisfies the monad laws
15:54:12 <Axman6> it's made much less of a pita by using it as a monad ;)
15:54:50 <PatrickRobotham> nand`: F is fmap, η is return, µ is bind?
15:54:53 <PatrickRobotham> not bind, join
15:55:07 <nand`> join yes
15:55:10 <pfn> although, I'm a bit confused by haskell convention where stuff is said to be suffixed with ' if it's strict?
15:55:21 <Axman6> sometimes
15:55:24 <PatrickRobotham> Hooray! I'm a category theorist! :P
15:55:31 <nand`> F is not just fmap, it's also Monad m => m
15:55:32 <Axman6> foldl' is the stricter version of foldl
15:55:44 <elliott> pfn: That's not really all that much of a convention.
15:55:47 <nand`> F map both morphisms and objects
15:55:50 <nand`> functors*
15:55:51 <elliott> pfn: ' just means "alternate", mostly. Or "helper"
15:55:51 <PatrickRobotham> nand`: Ok, F is a functor.
15:55:55 <pfn> like an example in learnyouahaskell is let line' = reverse line; is it being strict
15:55:56 <nand`> PatrickRobotham: yes
15:56:00 <pfn> or "prime"
15:56:02 <elliott> No.
15:56:06 <elliott> It's prime, as in mathematics.
15:56:13 <pfn> I see
15:56:18 <elliott> foldl' is called foldl' because... well, just because.
15:56:29 <elliott> But _generally_, a local definition of foo' will be "the next foo" or a helper definition for foo.
15:56:31 <nand`> ' means just “slightly modified version of this” in most cases
15:56:31 <pfn> damn you learnyouahaskell for saying it's strict and then using it as prime without really saying that's a convention, either
15:56:36 <nand`> and foldl' is, well, a modified version of foldl
15:56:38 <Axman6> pfn: in the language, it has no special meaning, it can come anywhere in a normal name after the first letter: i'llMakeFunctionsThat'llLookLikeThis
15:56:42 <elliott> A global definition will be a strict version or an alternate interface.
15:56:43 <pfn> (conventionally)
15:56:43 <elliott> Usually.
15:56:58 <elliott> Wow, I never realised how much of a mess ' for strict is.
15:56:59 <pfn> Axman6, right, I realize that, and learnyouahaskell said by convention, it typically denotes a strict usage
15:57:04 <elliott> Thankfully it doesn't come up much.
15:57:09 <nand`> strict should be !
15:57:11 <nand`> imo
15:57:43 <nand`> is that even a valid name?
15:57:46 <elliott> No.
15:57:47 <nand`> > let foo! = 5 in foo!
15:57:48 <lambdabot>   <no location info>: parse error on input `='
15:57:50 <nand`> shame
15:57:53 <elliott> It's also a valid operator.
15:57:56 <elliott> And clashes with bang patterns.
15:58:07 <Axman6> does it actually?
15:58:18 <Axman6> foo! a /= foo !a
15:58:27 <nand`> bang patterns can be prefix !
15:58:30 <Axman6> > genericClass '!'
15:58:30 <lambdabot>   Not in scope: `genericClass'
15:58:41 <nand`> whereas ! would be defined as valid in names when it is not the first character
15:58:42 <Axman6> > genericCategory '!'
15:58:43 <lambdabot>   Not in scope: `genericCategory'
15:58:51 <Axman6> usuk
15:58:52 <elliott> Axman6: Well, it confuses with bang patterns, at the very least.
15:58:53 <nand`> > 5!
15:58:54 <lambdabot>   <no location info>: parse error (possibly incorrect indentation)
15:59:12 <Axman6> > generalCategory '!'
15:59:13 <lambdabot>   OtherPunctuation
15:59:48 <cmccann> :t (!)
15:59:49 <lambdabot> forall i e. (Ix i) => Array i e -> i -> e
16:01:38 <otters> :t (!!)
16:01:39 <lambdabot> forall a. [a] -> Int -> a
16:01:43 <cmccann> elliott, and yes I noticed your commits and pulled the changes like a minute after you pushed them :D
16:01:50 <otters> @src (!)
16:01:51 <lambdabot> arr@(Array l u _) ! i = unsafeAt arr (index (l,u) i)
16:01:58 <otters> ofc
16:03:25 <cmccann> also the meaning of a name like foo' is "this is subtly different from 'foo' but I couldn't be arsed to think of a different name for it"
16:03:29 <cmccann> for the record
16:04:11 <elliott> foo', pronounced "fooish"
16:04:17 <cmccann> works for me.
16:04:35 <elliott> hmm, I sure hope I can think of a better name than Alignaversable for this typeclass
16:04:39 * cmccann thinks that he and elliott have this naming convention thing pretty much handled between them
16:04:42 <otters> should be pronounced foo-prime
16:05:07 <nand`> I like to use ' for helper functions
16:05:26 <cmccann> I like to use it for contractions
16:05:28 <nand`> eg. someFun = someFun' some initial params
16:05:31 <cmccann> "let isn'tFoo = ..."
16:05:33 <nand`> where someFun' ...
16:06:03 <elliott> don't
16:06:11 <elliott> (http://hackage.haskell.org/package/acme-dont, for those not In The Know)
16:06:15 <cmccann> :D
16:06:17 <Axman6> let foo'd = ...
16:06:27 <cmccann> Axman6, perfect
16:06:29 <elliott> wait, that's Control.Monad.void
16:06:34 <elliott> oh, no
16:06:36 <elliott> it isn't :)
16:06:43 <elliott> it's Control.Monad.void except also discarding the side-effects, obviously
16:07:04 <Axman6> bracket toFoo foo'd foo = ...
16:07:26 <nand`> “The Acme.Dont module provides the indispensable don't command, ported from Perl.” <- hehe
16:07:38 * cmccann renames "arr" to "arrow'd"
16:07:54 <hpc> @quote yarr
16:07:54 <lambdabot> hpc says: yarr, arr be rather arr-bitrary
16:08:02 <elliott> grr, I need empty for these instances, but can't implement it for Tree
16:08:17 <elliott> although I'm not sure the Tree instance even makes sense.
16:08:32 <cmccann> why wouldn't it?
16:08:53 <elliott> well, the zippy treatment of the list is kind of weird
16:09:15 <elliott> actually, an instance for Forest would work
16:09:19 <elliott> since empty = []
16:09:24 <elliott> unfortunately that would be overlapping and also useless
16:09:28 <cmccann> yeah
16:09:57 <elliott> I would probably have just added a subclass with empty by now if I could think of a name for it.
16:10:59 <cmccann> well, it's sort of a dual to pure
16:11:12 <elliott> yes, it's also a dual in that you need it to define any reasonable laws :P
16:11:19 <cmccann> but not the usual dual
16:11:50 <elliott> it also gives Unalign some more laws... I'm tempted to just remove the Tree instance and add it in
16:11:52 <cmccann> roughly pure means you have "f ()" automatically
16:12:03 <cmccann> whereas empty means you have "f Void"
16:12:13 <elliott> the only problem I can think of is that you couldn't give an instance for infinite streams
16:12:20 <elliott> but those zip properly by definition anyway
16:12:25 <cmccann> yeah
16:12:34 <elliott> ...although, unalign /does/ make sense on those
16:12:39 <elliott> and Unalign currently requires Align. grr.
16:12:51 <elliott> cmccann: empty means you have (f a), no?
16:12:52 <pfn> when I use a partially applied function like (++"!"), how does that work?
16:12:57 <elliott> I mean, it's just empty :: f a
16:13:03 <cmccann> elliott, yes
16:13:06 <elliott> oh, right, fmap absurd
16:13:09 <cmccann> yes
16:13:24 <cmccann> just like how you get pure from "f ()"
16:13:24 <pfn> e.g. (++"!") "foo" => "foo!" ?
16:13:44 <elliott> pfn: (++"!") is just (\x -> x ++ "!")
16:13:58 <elliott> (incidentally, you can translate the tuple form of applicatives to Contravariant as (f Void, f a -> f b -> f (Either a b)), but I'm not sure it's actually useful for anything)
16:14:14 <cmccann> yes, I have a definition of that lying around somewhere
16:14:23 <elliott> but it does let you have an instance for Not
16:14:38 <cmccann> along with every fundamental contravariant functor instance
16:14:40 <cmccann> all one of them
16:14:43 <elliott> (I was trying to figure out wtf the contravariant analogue of a monad might be)
16:14:43 <pfn> elliott, hmm, I guess that makes sense, so it's a syntax convenience rather than partial application?
16:14:55 <elliott> (it might be a -> f (f a))
16:15:04 <cmccann> elliott, that doesn't make sense though
16:15:05 <elliott> (I was mostly making up functions based on laws of logical negation :P)
16:15:18 <cmccann> contravariant functors aren't endofunctors
16:15:20 <cmccann> that's the point
16:15:32 <elliott> cmccann: yeah, but I can dream :'(
16:15:38 <elliott> pfn: no, it's a partial application
16:15:47 <elliott> pfn: ("!" ++) === (\x -> "!" ++ x) === (++) "!"
16:15:50 <cmccann> you can have monads on the opposite category obviously
16:15:51 <elliott> i.e. the application of (++) to "!"
16:15:55 <elliott> (++ "!") corresponds to flip (++) "!"
16:16:05 <cmccann> and you can use adjunctions involving contravariant functors to get a monad on Hask
16:16:09 <cmccann> well
16:16:11 <pfn> hmm, ok
16:16:12 <cmccann> one adjunction
16:16:20 <cmccann> since that's basically all that exists
16:17:41 <elliott> hmm, you can deduce from the full laws that fmap This empty = fmap That empty = fmap (join Both) empty
16:17:47 <elliott> is that enough to deduce that forall f. fmap f empty = empty?
16:18:22 <pfn> elliott, so flip basically makes it f :: a -> b -> c into f' :: b -> a -> c?
16:18:25 <cmccann> I would think empty being empty of parametric data is kind of obvious
16:18:32 <cmccann> because "empty :: f Void" :P
16:18:33 <elliott> @type flip
16:18:34 <lambdabot> forall (f :: * -> *) a b. (Functor f) => f (a -> b) -> a -> f b
16:18:40 <elliott> argh
16:18:41 <cmccann> ha ha.
16:18:42 <elliott> CAAAAAAAAAALE
16:18:46 <elliott> pfn: yes, it does exactly that.
16:18:48 <cmccann> :t Prelude..flip
16:18:49 <lambdabot> parse error on input `Prelude..'
16:18:51 <elliott> flip :: (a -> b -> c) -> (b -> a -> c)
16:18:53 <cmccann> :t Prelude.flip
16:18:54 <lambdabot> forall a b c. (a -> b -> c) -> b -> a -> c
16:18:54 <pfn> indeed
16:19:07 <pfn> thanks
16:19:07 <elliott> ignore lambdabot. it's a bit weird.
16:19:25 <cmccann> it's not her fault :[
16:20:03 <elliott> cmccann: right, but does that mean that if you add a law `fmap f empty = empty`, you can drop the `align a empty = fmap This a` and `align empty b = fmap That b` laws?
16:20:15 <elliott> but keeping `align empty empty = empty`
16:20:24 <elliott> erm
16:20:26 <elliott> not keeping that, that's not even a law
16:20:43 <cmccann> align depends on structural information though
16:21:07 <rwbarton> what is align?
16:21:23 <elliott> rwbarton: http://pchiusano.blogspot.com/2010/06/alignable-functors-typeclass-for-zippy.html
16:21:36 <elliott> the union equivalent of zipping's intersection... if that makes any sense to you :P
16:21:39 <cmccann> rwbarton, a generalization of zippy applicatives that preserve maximum size
16:21:47 <cmccann> e.g. for lists it pads the shorter
16:21:51 <cmccann> instead of truncating the longer
16:22:14 <cmccann> and elliott is currently adding it to my these package
16:22:19 <elliott> oh, you can't give empty for Identity either... but that instance is kind of useless anyway
16:22:19 <cmccann> cf. https://github.com/isomorphism/these
16:22:58 <cmccann> yeah I'm really not seeing the value to align for clearly fixed-size structures
16:23:15 <cmccann> since it should coincide completely with Applicative
16:23:18 <elliott> it just lets you use generic code on them, I suppose... but they're kind of silly, yes
16:23:55 <cmccann> this is basically about structures with structural indices and optionally missing elements
16:24:03 <elliott> maybe I'll call the Traversable-equivalent "Tralign"
16:24:12 <elliott> that's even better than Alignaversable
16:25:39 <vblm> Given the string "test", how do I get the list ["te", "es", st"]?
16:26:09 <elliott> vblm: using the split package, http://hackage.haskell.org/packages/archive/split/0.1.4.2/doc/html/Data-List-Split.html
16:26:14 <elliott> splitEvery 2
16:26:20 <vblm> elliott: Thanks.
16:26:43 <albel727> sounds like homework. in which case, tail + zip is the right answer.
16:26:44 <byorgey> that's not quite the same
16:26:45 <rostayob> does anybody have experience with uu-parsinglib? I picked it up after a while and I'm having some problems. Specifically, if I try to run this simple parser, I get "*** Exception: cannot compute minimal length of right hand side of monadic parser": http://hpaste.org/57652
16:27:09 <byorgey> splitEvery 2 "test" = ["te", "st"]
16:27:17 <elliott> oh, right
16:27:19 <elliott> vblm: sorry
16:27:22 <elliott> I misread your example
16:27:39 <cmccann> > take 2 <$> takeWhile (not . null) (iterate (drop 2) ['a'..'z'])
16:27:41 <lambdabot>   ["ab","cd","ef","gh","ij","kl","mn","op","qr","st","uv","wx","yz"]
16:27:47 <cmccann> oh yeah
16:27:48 <cmccann> me too
16:27:49 <cmccann> heh
16:27:59 <byorgey> but yes, look into "tails", "map", and "take"
16:28:19 <vblm> Thanks, will look into it.
16:28:27 <elliott> hmm, it's really annoying that you can't give Unalign sensible laws without empty, but you can't give an Align instance for streams (but can give an Unalign instance) :(
16:29:09 <vblm> albel727: Not homework, just trying to learn the language. Thanks for the tip.
16:29:16 <elliott> huh, ZipList has no Foldable instance.
16:29:27 <cmccann> ZipList is missing lots of instances if memory serves me
16:29:42 * cmccann needs to add some of those to Overture
16:30:01 <cmccann> there are several missing instances for ((,) a) as well I think
16:31:29 <rostayob> no one uses uu-parsinglib? is there like a quick-start tutorial? I need to write a tiny parser and I wanted to learn to use them for a long time
16:31:35 <elliott> I really wish Map's internal representation was exposed through some .Internal module.
16:31:42 <rostayob> the only proper documentation seems to be a 55 pages long tutorial
16:31:54 <cmccann> rostayob, it's a research project at heart, isn't it?
16:32:10 <cmccann> you might want to look for published papers related to it I guess
16:32:14 <cmccann> I dunno
16:32:30 <rostayob> cmccann: yeah, the thing it's 2am and I just wanted a 20 lines parser. too bad
16:32:42 <rostayob> and I really don't know where to go from that error
16:33:03 <cmccann> sorry, I got nothin'
16:33:11 <rostayob> cmccann: thanks for the attention :P
16:34:40 <albel727> vblm: I've jumped to conclusions. Sorry. I didn't mean to offend.
16:35:51 <rostayob> ok, good ol' parsec, here I come.
16:36:21 <elliott> or at least SOME way of getting at a Map's tree structure
16:36:28 <elliott> without going through lists.
16:36:32 <byorgey> rostayob: if you want something with even less documentation you could try trifecta ;)
16:36:42 <rostayob> byorgey: oh, that.
16:36:59 <elliott> haha
16:37:08 <rostayob> the thing is that I almost enjoy reading undocumented code and figuring it out
16:37:13 <rostayob> but I don't want to now
16:37:28 <vblm> albel727: No offense taken, your tip helped me get in the right direction. I have "f n = zip n (tail n)" right now. Working my way towards list of strings.
16:37:48 <rostayob> I'm almost done doing all the agda tutorial exercises and I need to write the a parser in Haskell for the FFI thing, so I don't want to get too distracted :P
16:39:41 <elliott> ok, there _must_ be a better way of expressing these six unalign laws I just came up with
16:39:45 <rostayob> wow, trifecta is the pinnacle of un-documentation
16:40:44 <rostayob> for a library that big anyways
16:41:45 <rostayob> Haskell                         72            949           1546           4995
16:41:50 <nyingen> rostayob: a general weakness of the haskell community is a lack of cookbook-style documentation
16:41:56 <rostayob> where are those 1.5k lines of comments?
16:42:12 <nyingen> this has been discussed, but I'm not sure much is being done about it. Sometimes you can dig up a blog post or two
16:42:30 <rostayob> nyingen: it hasn't been a big problem for me since, as I said, I usually learn a lot more reading the source
16:42:32 <rostayob> but yeah
16:42:36 <rostayob> if you need to hack something quickly
16:42:38 <rostayob> it's a pain
16:42:42 <nyingen> I agree
16:42:46 <rostayob> and well trifecta doesn't even have API docs!
16:43:00 <nyingen> Haskell is very readable in my experience, so reading a library's source to figure out how it works is not the daunting task it might be in, say, C++
16:43:09 <elliott> Data.Map.split is so close to offering access to the raw tree structure, but not quite :(
16:43:24 <nyingen> but yes, sometimes you want to get started quickly, and whoops, no examples whatsoever
16:43:33 <rostayob> nyingen: again, it depends (for example *imho* uu-parsinglib is quite unreadable)
16:44:22 <nyingen> extensive abstraction over types in libraries can also be confusing. "so, uh, how am I supposed to instantiate this thing?"
16:46:36 <elliott> with a large stick
16:47:15 <tromp__> :t State.splitAt
16:47:16 <lambdabot> Couldn't find qualified module.
16:47:26 <tromp__> :t \n->State(splitAt n)
16:47:27 <lambdabot> Not in scope: data constructor `State'
16:47:32 <elliott> tromp__: state, lowercase
16:47:45 <tromp__> :t \n->Control.Monad.State(splitAt n)
16:47:46 <lambdabot>     Not in scope: data constructor `Control.Monad.State'
16:47:59 <tromp__> : state
16:48:03 <tromp__> : tstate
16:48:06 <rwbarton> ...
16:48:09 <tromp__> :t state
16:48:10 <lambdabot> forall s a. (s -> (a, s)) -> State s a
16:48:37 <elliott> does anyone have any suggestions for how to implement something like sequenceA/traverse on Data.Map /outside/ of Data.Map?
16:48:55 <elliott> i.e. getting at something like the tree structure and rebuilding it without just destructing the whole thing and building it back up from a list
16:49:32 <tromp__> :t state.splitAt
16:49:33 <lambdabot> forall a. Int -> State [a] [a]
16:49:42 <rwbarton> you have to somehow know about the left-to-right order
16:57:46 <slack1256> haskell is my first language, but i don't know how to choose a data-structure, there is something i should read?
17:02:04 <Eduard_Munteanu> slack1256: depends on the application. General knowledge about algorithms (and data structures, as usually stated) helps there.
17:03:40 <Eduard_Munteanu> slack1256: is there anything in particular you're wondering about?
17:05:42 <mike-burns> slack1256: How To Design Programs.
17:05:56 <mike-burns> It's free online, and it's a good intro to data structures and programming.
17:07:26 <elliott> Huh, I didn't realise anybody liked HTDP.
17:08:10 <slack1256> mike-burns: How To design Programs? is that a book.
17:08:11 <gatlin> I love HTDP
17:08:15 <mike-burns> slack1256: Yes.
17:08:28 <slack1256> cool will check it out on my library
17:08:31 <gatlin> I'm new to Haskell but I plan on teaching Racket to programming newbies
17:08:35 <gatlin> and that's the book I'll be using
17:08:54 <mike-burns> I taught TeachScheme!, and the book was a basis for the curriculum.
17:08:59 <Axman6> @google how to design programs
17:09:01 <lambdabot> http://www.htdp.org/
17:09:01 <lambdabot> Title: How to Design Programs
17:09:10 <gatlin> Typed Racket actually provides a rather polite introduction to Haskell, too, in a limited way
17:09:49 <slack1256> i'm ok with this :D
17:10:21 <slack1256> the thing is that i'm a pure math student, so i know more about algorithm than about DS.
17:11:10 <gatlin> From what I understand of it, Haskell is a good choice for someone into pure math because programming Haskell is in a lot of ways programming in abstract algebra
17:12:49 <mm_freak_> gatlin: the former statement is true, but the latter isn't necessarily
17:12:53 <cmccann> don't overestimate how close Haskell is to the maths
17:13:12 <cmccann> we abuse abstract algebra the way physicists and engineers abuse other kinds of math
17:13:21 <gatlin> I try not to. For example, I know that monads / functors don't map exactly to their descriptions in category theory
17:13:37 <mm_freak_> you can program haskell without knowing much math
17:13:52 <monochrom> I'm sorry to tell you that haskell is just a programming language and will not classify groups of order 21 for you, if you mean that by "abstract algebra"
17:13:56 <mike-burns> Haskell is still programming.
17:13:58 <mm_freak_> the only real requirement is that you understand what an equation is…  not how to solve it or anything, but really just what it means
17:13:58 <elliott> Arrangable... Alignaverse...
17:14:20 <elliott> Versealignadoodle... this is going nowhere
17:14:25 <cmccann> mm_freak_, to be fair it's difficult to program much in Haskell without learning some math along the way
17:14:31 <mike-burns> Nah.
17:14:37 <cmccann> but that has more to do with the Haskell community than the language
17:14:38 <monochrom> also filter (0 ==) [0..] takes forever to reduce to normal form
17:14:40 <mike-burns> Unless math means something new now.
17:14:47 <mm_freak_> cmccann: you'll inevitably learn some logic, but you won't necessarily know you do
17:14:51 <tromp__> @let splitsAt n=takeWhile(not.null).evalState(sequence.repeat.state.splitAt$n)
17:14:52 <lambdabot>  Defined.
17:15:02 <Grace12> Hello
17:15:20 <elliott> monochrom: you can fix that using the infinite search stuff, for ascending lists :P
17:15:22 <gatlin> I know it's only a programming language, and I understand that my statement is flawed in a number of ways but I also think it has an iota of merit
17:15:53 <mm_freak_> let's go with:  that statement is highly controversial
17:16:04 <monochrom> "fix"? is there anything to repair there?
17:16:12 <tromp__> > splitsAt 2 "hello"
17:16:14 <lambdabot>   ["he","ll","o"]
17:16:19 <cmccann> monochrom, yes, errors
17:16:27 <mm_freak_> but note that people without any programming experience have a much easier and more enjoyable time learning haskell than a highly experience C++/PHP programmer
17:16:39 <Grace12> How many cases to check if a proposition is tidy?
17:16:40 <mm_freak_> slack1256 has a real advantage there
17:17:01 <cmccann> yes
17:17:03 <monochrom> what errors?
17:17:11 <MaskRay> > splitEvery 2 "hello"
17:17:12 <lambdabot>   Not in scope: `splitEvery'
17:17:31 <mike-burns> A very experienced dev will also have no issue with Haskell. Someone who only knows one PL will have an issue with their next paradigm, no matter what.
17:17:40 <cmccann> monochrom, as in "fix error", except without enough context to be clear, never mind :P
17:17:54 <Grace12> tidy means either that proposition called p  for example, p = True or p = False or p will not contain True or False!
17:18:13 <elliott> monochrom: totally!
17:18:16 <monochrom> there is no error. it takes forever, and I intend it to take forever, my specification is satisfied
17:18:18 <elliott> re: repair
17:18:20 <gatlin> mm_freak_ absolutely which is why I advocate functional programming first. Write functions that actually are functions (ie, they are referentially transparent) and introduce side effects as what happens when your function or program is not so. Also, that this is ultimately necessary
17:18:21 <mm_freak_> imperative programming itself is so flawed…  i had to teach a friend C++ and she had a high math background:  i had to teach her to forget all of that and think on an incredibly primitive level
17:18:38 <elliott> Grace12: ?
17:18:53 <slack1256> mm_freak: i wish, i'm still have 2 years to go.
17:19:28 * cmccann thinks there is a case to be made that the patterns of thought one learns from mathematics are helpful when programming Haskell relative to having no background in math or programming at all
17:19:36 <Grace12> I am working on some haskell code to write a function to check whether a proposition is tidy
17:19:45 <khanzor> it's like the difference between writing a recipe (imperative), and writing the menu (declarative)
17:19:47 <monochrom> please re-word your definition of tidy. your previous one is a parse error
17:20:12 <elliott> has anyone written a declarative recipe yet?
17:20:18 <monochrom> preferably the verbatim wording given to you, not your "understanding"
17:20:22 <tromp__> tidy is literal free?
17:20:27 <mike-burns> If you don't know how to do both declarative and imperative programming, all of your programming will suffer, regardless of the language.
17:20:44 * gatlin agrees with mike-burns
17:21:01 <Grace12> p = F or p = T or p contains no constants. that mean tidy
17:21:10 <monochrom> declarative recipe example: "sudo make me a sandwich" :)
17:21:17 <cmccann> elliott, a declarative recipe is a photo of what the dish should look like
17:21:19 <cmccann> :P
17:21:22 <elliott> haha
17:21:31 <cmccann> maybe some constraints like
17:21:34 <cmccann> "should be tasty"
17:21:43 <Axman6> Grace12: we need more context to help you. your question is meaningless so far
17:21:46 <elliott> I'm imagining a tree structure with each "combination" of components at the top of each tree, or something
17:21:55 <mm_freak_> that might be a reason why the transition from imperative to declarative programming appears to be so hard for many people…  it's the opposite direction, which is even harder:  regain the knowledge you lost when you learned C++
17:22:06 <khanzor> well, like "Trout with cream cheese, a dash of dill, and beetroot patties"
17:22:09 <monochrom> there are constants other than "T" and "F"?
17:22:15 <gatlin> I wonder what the AnsProlog description of a meal would be
17:22:26 <khanzor> vs. "Fry fish; create sauce; create beetroot"
17:22:35 <mm_freak_> or the FRP description of a steak =)
17:22:53 <gatlin> Over time, it sizzles
17:23:04 <Grace12> For example, I have this proposition: ((P|Q)&(P&Q)). I want to check if this is tidy or not. In reality, this is tidy.
17:23:22 <monochrom> ok, show me an untidy proposition
17:23:33 <tromp__> T|F
17:23:50 <Grace12> (T&P) is untidy
17:24:04 <Grace12> anything that have T or F in the proposition is untidy.
17:24:33 <Rotaerk> if I google "untidy proposition", the second result is a wikipedia page on sluts
17:24:42 <monochrom> haha
17:24:59 <tromp__> tidy T = True; tidy F=True; tidy x = disjoint (atoms x) [F,T]
17:25:17 <roconnor> sounds like a job for uniplate!!
17:25:42 <monochrom> god, no, you need a lisp interpreter
17:26:15 <monochrom> FRP description of steak: at time n, steak enters stomach
17:26:36 <mm_freak_> that doesn't cover everything
17:26:59 <monochrom> that's fine for now
17:27:14 <mm_freak_> if the steak isn't english, you return it and the process repeats…  also there is some way the cow goes from the farm to your plate
17:27:50 <Axman6> oh man, i was confused trying to figure out what cogoes could mean
17:28:03 <mm_freak_> Axman6: it's the dual to goes
17:28:25 <Grace12> I was thinking about scanning through the string, and if I find a T or F, it is not tidy; otherwise it is tidy; Is it the right way to go? Thanks.
17:28:27 <Axman6> is that leaves? I think not, becuase if you're leaving, you're also going somewhere else
17:28:33 <mm_freak_> my home cogoes to me
17:28:40 <monochrom> FRP recipe for tartar steak: enter beef into mincing arrorw, enter vegies into mincing arrow, enter spice into mincing arrow...
17:28:55 <aib> Grace12: (P&P) isn't tidy, is it?
17:28:55 <Axman6> Grace12: why not parse it into a simple data structure, and then you can work with that instead?
17:29:21 <Grace12> aib: yup, it is tidy
17:29:41 <aib> what an odd definition of "tidy"
17:29:59 <Grace12> Axman6: I have a structure already
17:30:11 <tromp__> tidy means no unnecessary constants
17:30:18 <mm_freak_> to sum up, a proposition is tidy, iff it has no constants?
17:30:32 <Axman6> cmccann: then why not use that?
17:30:37 <Axman6> uh, Grace12
17:30:43 <aib> (P | !P) is constant, though
17:31:54 <mm_freak_> if you want to cover that, is it even solvable?
17:32:03 <elliott> cmccann: hmm, can you think of any way to simplify these laws? http://hpaste.org/57653
17:32:07 <mm_freak_> it probably is, unless you have recursion
17:32:14 <elliott> the These vs. flip These part is especially ugly :(
17:32:25 <aib> mm_freak_: I was thinking about it. it doesn't seem to be NP, like BSAT
17:33:30 <aib> mm_freak_: I would probably turn the expression into DNF and remove the redundant minterms
17:33:53 <monochrom> perhaps it is a syntactic definition, not a "simplify it as much as possible" definition
17:34:20 <aib> well you could look for T/F with a regex :)
17:34:39 <monochrom> we say that "x occurs free in x - x" despite do-gooders trying to simplify x-x to 0 first
17:35:38 <cmccann> elliott, perhaps the last two could be combined by specifying it with (These a b <$ a)?
17:35:55 <elliott> cmccann: do you mean <$ c?
17:35:57 <cmccann> combined with the first three I think that amounts to the same thing
17:35:59 <cmccann> er
17:36:00 <cmccann> yes
17:36:11 <aib> I was thinking about simplification, though. yeah, converting to DNF would work. O(4^n) with the simplest algorithm (generate truth table -> DNF -> check each minterm against itself)
17:36:18 <elliott> hmm... yes, you might be right
17:36:22 <elliott> having trouble convincing myself of it, though :)
17:36:23 <aib> against others*
17:36:48 <cmccann> elliott, yeah I'm not 100% certain and I have a cake in the oven so I'm distracted right now
17:37:31 <monochrom> declarative cake recipe? :)
17:37:33 <Grace12> where can I import from to get disjoint and atoms?
17:38:46 <elliott> monochrom: cmccann is using a contravariant cake recipe. all he has to do is be able to turn a cake back into its ingredients
17:40:05 <monochrom> I want his ability to turn back events!
17:40:36 <cmccann> sadly, no
17:40:47 <cmccann> I'm sure my cake recipe is like a monad somehow though
17:40:50 <cmccann> most things are
17:40:58 <elliott> life is like a monad tutorial
17:41:02 <monochrom> imagine! to solve a murder mystery, go to the scene and the corpse, invoke his rewind ability, the murderer emerges
17:41:07 <elliott> you can get in... can't get out
17:41:10 * elliott THE DEEPEST THINKER
17:41:59 <monochrom> that reminds me! I took a relevant picture last night...
17:42:46 <cmccann> pics or it didn't happen :V
17:42:50 <cmccann> wait...
17:44:46 <monochrom> http://www.vex.net/~trebla/tmp/mucho-burrito.jpg :)
17:45:17 <cmccann> is "mucho" some sort of burrito transformer here
17:45:45 <elliott> "Haskell as most mainstream non-mainstream language?" that's an... interesting title
17:47:12 <monochrom> think of the maximum [minimum xs | xs <- blahblah].
17:47:23 <hpc> cmccann: it transforms radioactive waste into burritos by way of spacesuit
17:47:36 <monochrom> which is analogous to "there exists x such that for all y"
17:47:40 <cmccann> hpc, oh of course. makes perfect sense.
17:49:11 <ion> The ship in the bottle analogy is much better.
17:50:19 <tgeeky> ion: The analogy in a bottle analogy is betterer.
17:51:05 <monochrom> @quote ship
17:51:06 <lambdabot> Cale says: I plan on forming a symbiotic relationship with sandtrout, which, as they merge with my body, will sustain me as I slowly turn into a sandworm, and make use of my billions of other
17:51:06 <lambdabot> memories and prescience to rule over everyone and everything for millenia.
17:51:07 <ion> Is bettererer… = best?
17:51:14 <ion> like 0.999… = 1
17:51:29 <tgeeky> ion: no, but if something is bettererer, then it might be best
17:51:32 <monochrom> except tgeeky did not write more than one dot
17:51:33 <elliott> hmm, is that the origin of Caleskell?
17:52:12 * elliott sure is interested in knowing the context of that Cale quote.
17:52:14 <tgeeky> elliott: it sounds like a creation myth, for sure.
17:52:32 <cmccann> sounds like Dune
17:52:40 <Cale> Yeah, it's Dune :P
17:53:36 <cmccann> the (>>=) must flow!
17:54:08 <monochrom> oh great, monad as sandworm
17:54:30 <monochrom> and applicative as Dune mythology
17:54:30 <tgeeky> isn't it the spice, which must flow
17:54:45 <tgeeky> or should I not use 'the'?
17:54:51 <ion> Monad as a spice container analogy
17:54:56 <monochrom> yeah, FRP must flow, too
17:55:14 <elliott> monad as tired monad tutorial joke :)
17:55:50 <elliott> monads are just like tired monad tutorial jokes. you can put anything you want into the context of one, replace the analogy inside, and you can turn a meta-tired monad tutorial joke into a tired monad tutorial joke
17:55:54 <tgeeky> i'm in favor of burrito tutorials, because I can eat burritos.
17:56:17 <elliott> (we didn't always use to make ~3 monad tutorial jokes per day, did we?!)
17:56:27 <Axman6> the State must flow!
17:56:36 <tgeeky> maybe they were funnier, back then, in prehistory
17:56:49 <ion> Quantity makes up for quality.
17:57:00 <tgeeky> ion: same is true with burritos!
17:57:22 <hash`> Are there any reasons not to use -XGenerics?
17:57:34 <tgeeky> hash`: nope
17:57:34 <hydo> burritos are how we used to explain the OSI network layer... thing.  And seives used by archaeologists how we explained subnetting.  Being 'raised' by old UCB-beard wielding admins has it's upsides.
17:57:39 * cmccann should write a burrito tutorial and explain how to prepare them by analogy to monads
17:57:43 <hash`> Awesome. I'll use them then.
17:57:51 <elliott> we need to start cracking down on them. unfunny monad tutorial joke -> 10 minute ban. unoriginal monad tutorial joke -> 1 hour ban. burrito monad tutorial joke -> 1 day ban
17:57:54 <hydo> cmccann: I'd read that.
17:58:00 <elliott> criticising the moand tutorial joke policy -> indefinite ban
17:58:06 <tgeeky> me too, but only because elliott wrote it
17:58:16 <elliott> proposing the monad tutorial joke policy -> instant op powers
17:58:19 <ion> cmccann: You should.
17:58:23 * hackagebot hxournal 0.6.4.3 - A pen notetaking program written in haskell  http://hackage.haskell.org/package/hxournal-0.6.4.3 (IanWooKim)
17:58:27 <elliott> cmccann: haha, yes
17:58:37 <tgeeky> s/elliott/ccmcann/
17:58:52 <cmccann> haha
17:58:55 <tgeeky> lol
17:58:59 <ccmcann> the truth at last!
17:59:01 <tgeeky> that was more effective than I thought!
17:59:12 <tgeeky> let's see...
17:59:16 <tgeeky> s/tgeeky/ChanServ/
17:59:26 <elliott> s/.*/lambdabot/g
17:59:43 <DanBurton> Yes! Haskell can do that!
17:59:50 <cmccann> haha
17:59:51 <tgeeky> DanBurton: lol
17:59:55 <ion> Hah. cmccann and ccmcann are hashed by WeeChat to the same color by chance.
18:00:06 <tgeeky> ion: goldenrod?
18:00:33 <tgeeky> I learned the other day, from some BBC documentary, that the earth used to have bright purple oceans!@
18:01:07 * elliott cites all his lies to "some BBC documentary".
18:01:14 <tgeeky> twenty shillings to the first person who can correctly explain why
18:01:20 <ion> elliott: hah
18:01:27 <elliott> Fish are actually aardvarks in disguise. I learned this the other day from some BBC documentary.
18:01:40 <DanBurton> tgeeky: what's the exchange rate of bitcoin <-> shillings?
18:01:53 <tgeeky> DanBurton: 1 pico <-> 1 nano
18:02:52 <tgeeky> no takers? #haskell makes me a sad panda bear
18:03:11 <elliott> You'd have to pay me to explain why.
18:03:43 <tgeeky> that was the propisition. I don't know how much a shilling is.
18:03:55 <elliott> tgeeky: Shillings aren't money.
18:04:02 <elliott> They're ex-money.
18:04:12 <SirFrancisDrake> that's sad
18:04:19 <tgeeky> in my experience, that makes them more valuable?
18:04:31 <cmccann> they're just pining for the fjords
18:05:13 <tgeeky> anyhoo, since you're all clearly dying to know: the answer is, because they were being bathed in UV light, and releasing violet pigments was their evolutionary defense
18:05:54 <elliott> Thanks. I was, in fact, dying.
18:06:01 <luite> oceans released violet pigments in their evolutionary defense?
18:06:05 <rwbarton> not just dying, but clearly dying.
18:06:12 <tgeeky> luite: no, single celled organisms in oceans did.
18:06:13 <quintessence> I once learned from a BBC documentary that oceans evolve.
18:06:28 <tgeeky> I think the oceans were pretty 'meh' about the whole thing.
18:07:12 <luite> dunno, maybe they thought being purple was quite rad
18:07:14 * elliott chose to interpret it as the oceans' evolutionary defence.
18:07:16 * tgeeky is picturing the "Prey I don't alter it any further" baby.
18:07:17 <elliott> You've ruined it. :(
18:07:41 * hydo eyes 5EXAABGOF suspiciously...
18:10:06 * tgeeky wonders what the name for 10,000 and maybe 1 billion years is
18:10:09 <tgeeky> a billinnea?
18:10:30 <hydo> petayears?
18:11:15 * tgeeky is disappointed that 9/10 of the results for 1 petayear are about PETA
18:11:16 <hydo> peta-dollars... man, I could listen to Jow Armstrong read the phone book.  At least through to Andersen.
18:11:28 <hydo> JOE, I mean.
18:11:33 <hydo> stupid, dumb fingers.
18:12:06 <tgeeky> http://www.youtube.com/watch?v=Py_IndUbcxc <-- nazis, in space
18:12:39 <elliott> http://hackage.haskell.org/packages/archive/type-level/0.2.4/doc/html/Data-TypeLevel-Num-Aliases.html oh, wow.
18:15:14 <cmccann> elliott, that is an absolutely ridiculous number of numbers.
18:15:59 <tgeeky> i think my browser crashed loading it.
18:16:06 <hydo> ow.. my chrome hurts opening that.
18:16:18 <cmccann> imagine how GHC feels compiling it
18:16:23 <elliott> cmccann: http://en.wikipedia.org/wiki/List_of_numbers
18:16:27 <rwbarton> iirc it also causes any Haskell executable that uses that module to be ridiculously large
18:16:30 <hydo> op! there we go.  chrome came back all prize-fighter style.
18:16:40 <rwbarton> like 50M or something
18:16:40 <tgeeky> i'm going to submit a patch request, asking why 5001 wasn't include, and stating that I need it for some reason.
18:16:51 <elliott> that message at the top used to just say "This list is incomplete; you can help Wikipedia by expanding it."
18:16:55 <elliott> which was much funnier :(
18:16:58 <cmccann> haha
18:17:12 <luite> lol the source code is rather short :)
18:17:31 <elliott> haha: runIO (putStrLn "Generating and compiling a zillion numerical type aliases, this might take a while")
18:17:43 <elliott> wait... why can't they just define a TH splice for it?
18:17:45 * cmccann prefers http://en.wikipedia.org/wiki/List_of_lists_of_lists
18:17:47 <luite> yeah I remember seeing that message
18:17:48 <elliott> if they're OK using TH
18:17:59 <elliott> i.e. $(nat 424)
18:18:58 <tgeeky> haha. the list of lists of lists, includes "list of lists of lists"
18:19:12 <cmccann> well, it is
18:19:14 <tgeeky> I guess that solves uhh... Russel's paradox
18:19:37 <elliott> tgeeky: no, that's not a paradox
18:19:41 <elliott> you need a negation in there for rusell
18:19:43 <elliott> *russell
18:19:57 <tgeeky> quite right. silly me.
18:20:03 * tgeeky lightly smacks himself on his hand with a ruler
18:20:09 <cmccann> yes, that would be "List of lists that do not contain themselves"
18:20:10 <elliott> wikipedia would never be inconsistent, silly
18:20:17 <elliott> unless we could find a reliable source
18:20:24 <cmccann> which is of course included in the list of lists of lists
18:20:39 <tgeeky> cmccann: we should mirror the page, remove it, and link the two :O
18:22:19 <tgeeky> you could also just make a page of "a list of lists of lists known to be universally quantified (or exhaustive)"
18:22:58 <elliott> X = List of Xs
18:23:02 <tgeeky> you could start with the list of sproadic groups
18:23:03 <elliott> the only entry is X = List of Xs
18:26:21 <andy__> is it possible to have an unexported type synonym expand to its equivalent type in the external signature?
18:26:27 <andy__> or does this happen anyways?
18:30:40 <elliott> andy__: no, you have to export it I think
18:30:51 <elliott> ok, I don't think, I know :)
18:47:17 * cmccann wonders why exclusive or and material implication aren't defined in Data.Bool
18:47:32 <cmccann> I guess xor amounts to inequality but that's not very clear
18:47:52 <roconnor> cmccann: xor is /=
18:47:59 <roconnor> cmccann: implication is <=
18:48:17 <elliott> (<=) <-> (->)
18:48:26 <cmccann> yeah that's pretty obfuscated though :P
18:48:52 <elliott> Bool needs a Bits instance
18:48:53 <cmccann> would make me stop and think about what it means
18:48:55 <cmccann> haha
18:48:59 <elliott> then it'd have or
18:49:01 <elliott> xor
18:49:07 <elliott> i'm not joking :(
18:49:18 <cmccann> but
18:49:22 <cmccann> it only has one bit
18:49:25 <roconnor> cmccann: after a while you get used to <= as implication
18:49:29 <cmccann> how can it have Bits
18:49:31 <cmccann> :[
18:49:41 <elliott> int8 only has 8
18:49:47 <elliott> how can it have Bits
18:49:53 <elliott> you need at least 10
18:50:13 <cmccann> well you don't say "one bits" do you?
18:50:22 <cmccann> that's just absurd.
18:50:24 <BMeph> elliot: It has 1000 of them! ;þ
18:50:42 <BMeph> Er, *elliott ^^
18:53:00 <byorgey> implication is <=, haha
18:53:17 <byorgey> a <= b   -- check whether a => b
18:55:50 <roconnor> to be fair, implication was often written as ⊂ which looks vaguely like <=
18:57:05 <dolio> I thought it faced the other way.
18:57:25 <lpsmith> yeah, that's one aspect of mathematical notation I'm not particularly fond of
18:58:00 <dolio> Although you can also interpret implication as subset, which would be that.
18:58:20 <lpsmith> but yeah,  implication is <=  :-P   Maybe we should therefore use erlang's =< lexeme instead.
18:58:37 * hackagebot alternative-io 0.0.0 - IO as Alternative instance  http://hackage.haskell.org/package/alternative-io-0.0.0 (KazuYamamoto)
18:58:51 <tgeeky> a `implies` b
18:58:54 <tgeeky> solved
18:59:27 <roconnor> dolio: acording to wikipedia you are right :/
18:59:41 <dolio> roconnor: I have a book somewhere that uses that notation.
19:01:51 <roconnor> why does google have limited preview on dover books?
19:02:29 <roconnor> oh maybe this book isn't out of copyright :/
19:03:20 <DanBurton> tgeeky: that's cheating
19:04:29 <dmwit> People get confused when I use multiple-letter variable names in my math.
19:06:34 <DanBurton> d x / d foo
19:06:49 <dolio> That's why you should only use one-letter variable names in your Haskell.
19:07:56 <DanBurton> lately I have been tempted to write a minimalistic lambda calculus that forces you to use single-letter variables. What's more, it would force you to use certain conventions, e.g. inputs that are used in the "function" position of function application must be "f" "g" or "h"
19:08:50 <rwbarton> that's basically how FORTRAN worked
19:09:44 <ion> dmwit: You should stop using multiple-letter constants in your math, too, for their benefit. Replace sin, cos and tan with s, c and t for instance.
19:12:03 <damo22> is there any reason why regex genex would slow down after it has created most of the strings from a regex?
19:12:43 <ivanm> it's implementation?
19:12:48 <damo22> converting the regex to a finite state machine and then walking all paths?
19:13:19 <ivanm> I meant as in the fact that there's a bug in it's implementation, or that the actual thing it's trying to do means it *will* slow down at some point
19:13:45 <damo22> well i can think of one way it could slow down
19:13:50 <tgeeky> DanBurton: I was thinking about requiring that infix operators all had regular-word aliases in my personal version of H`
19:13:56 <eviltwin_b> it's trivial to produce a regex that will match an infinite number of strings...
19:14:20 <damo22> eviltwin_b: no this program generates all strings that match a particular regexp
19:14:36 <ion> eviltwin_b: Such as the empty regexp.
19:14:37 <tgeeky> damo22: regex-genex?
19:14:51 <damo22> tgeeky: yes
19:14:54 <ivanm> tgeeky: a package on hackage
19:14:56 <tgeeky> damo22: does the 'fast' version do that (the non-smt / yices one)?
19:15:02 <tgeeky> yes, I've used it.
19:15:21 <damo22> tgeeky: im not sure i didnt try them both, im running the yices one
19:15:56 <hydo> is RWH still the best resource for "i want to use this library in my code but I've never used the FFI before." ?
19:15:57 <tgeeky> damo22: if you aren't using backreferences or whatever, the "pure" version is... several times faster
19:16:01 * Boxo once write a lambda calculus where multiple-letter variables had to be in all caps
19:16:06 <Boxo> *wrote
19:16:08 <tgeeky> hydo: yes, I think so
19:16:13 <hydo> cool, thanks!
19:16:26 <damo22> tgeeky: its output 1.8Mb so far and its spitting out 1 string per 4 seconds now
19:16:45 <xil> hi everyone. I have to map something onto a list and I'd like to also get the length of the list. Is there a way to do that without traversing the list twice?
19:16:58 <tgeeky> damo22: yeah. just subsitute genex with genexPure or whatever, and see what happens
19:17:22 <tgeeky> damo22: basically, get the SMT solver out of the way
19:17:32 <ivanm> xil: not by using length and map as-is
19:17:44 <ivanm> you have to use a custom fold
19:18:00 <ivanm> IIRC, dons covered this in some old blog posts about parallelising the mean function
19:18:07 <xil> ivanm: well I know I could technically use mapAccum and do the counting by hand, but I was just hoping there was some shortcut
19:18:08 <ivanm> @google donsbot haskell (mean OR average)
19:18:11 <lambdabot> http://donsbot.wordpress.com/2010/02/21/smoking-fast-haskell-code-using-ghcs-new-llvm-codegen/
19:18:11 <lambdabot> Title: Smoking fast Haskell code using GHC’s new LLVM codegen « Control.Monad.Writer
19:18:20 <ivanm> well, that might link to it...
19:21:01 <DanBurton> @src mapAccum
19:21:02 <lambdabot> Source not found. Just what do you think you're doing Dave?
19:21:15 <DanBurton> @botslap -- it's Dan
19:21:15 <lambdabot> Unknown command, try @list
19:21:19 <tgeeky> damo22: If you have success or failure, let me know. @tell me, I'm going to bed I think
19:21:21 <DanBurton> @botsmack
19:21:22 <lambdabot> :)
19:21:31 <tgeeky> damo22: I'd also like to know what regex you're using, just for curiosity's sake
19:21:54 <damo22> tgeeky: just a long [aA][bB][cC]...
19:22:20 <tgeeky> damo22: oh. you really need to use the pure version. It'll be done nearly instnatly.
19:22:51 <wavewave> hi .
19:23:03 <tgeeky> wavewave: hello, good sir. I saw you were up late coding last night :o
19:23:11 <wavewave> ?
19:23:24 <tgeeky> wavewave: hxournal commit last night at like 3am? :o
19:23:30 <wavewave> ah...
19:23:49 <wavewave> thanks for watching my project ;-D
19:24:04 <dmwit> ?botsnack
19:24:04 <lambdabot> :)
19:24:06 <damo22> if i have a function that returns [String] how do i output each string to a new line without buffering?
19:24:17 <tgeeky> wavewave: you say that, but it's in a from-far-away with stalker binoculars kind of watching :o
19:24:37 <wavewave> tgeeky : yeah... I imagined that..
19:25:08 <wavewave> anyway, new version came out just some minutes ago.
19:25:38 <wavewave> I am kinda thinking that I am rather addicted to sending a new version hhe.
19:25:38 <tgeeky> wavewave: i think tomorrow I'll install it on my laptop and test with a wacom tablet. prepare for fumbling patch requests!~!
19:25:56 <wavewave> tgeeky : great!!
19:26:12 <tgeeky> for now, however, sleep beckons. night all!
19:26:39 <DanBurton> tgeeky: sweet lambda-filled dreams to you
19:27:27 <wavewave> don't forget subscribing hxournal mailing list http://groups.google.com/group/hxournal
19:28:00 <cmccann> ooh, hey. tablet input? can it use the pressure as well? I was thinking about doing something using that recently but wasn't sure how to get the input working
19:28:24 <tgeeky> cmccann: I don't know about pressure, but I think he said tablet input works :o
19:28:35 <wavewave> cmccann: not pen pressure yet.. but at least it gets xinput , so subpixel resolution.
19:28:50 <cmccann> ah. kinda need pressure for my purposes.
19:29:00 <wavewave> in fact, implementing pen pressure is not that difficult..
19:29:13 <cmccann> ah, hm
19:29:27 <wavewave> just original xournal implementation is rather ugly.. so I was postponing it.
19:30:02 <wavewave> cmccann : since you need it.. I will put that on my top priority ;-)
19:30:38 <cmccann> wavewave, well, I don't need it in hxournal, I was just hoping someone had already implemented it so I could look at that and figure out how to do it in my own program
19:31:02 <wavewave> ah... then.. actually I can help you.
19:31:33 * cmccann is after drawing, not writing
19:33:39 <cmccann> and I'm frustrated with finding non-terrible software for drawing
19:34:02 <wavewave> I am using only x,y coordinate now but I know where z coordinate is stored in gdk object.
19:35:01 <Jafet> Inkscape purportedly supports drawing tablets.
19:35:24 <cmccann> it does
19:35:28 <cmccann> so does GIMP
19:35:33 <cmccann> neither is really very good for just drawing
19:35:36 <damo22> http://paste.ubuntu.com/834804/ anyone know why i can compile this using ghc?
19:35:42 <damo22> s/can/cant
19:35:55 <wavewave> https://github.com/wavewave/hxournal/blob/master/lib/Application/HXournal/Device.hsc
19:36:15 <dmwit> damo22: --make, perhaps?
19:36:19 <dmwit> (How old is your GHC?)
19:36:32 <damo22> 6.12.3
19:36:32 <ion> cmccann: How about mypaint?
19:36:33 <DanBurton> damo22: can you runghc it?
19:36:34 <wavewave> see that part.. then axes variable has z information.
19:36:38 <dmwit> damo22: then yeah, --make
19:36:59 <damo22> yay!
19:37:11 <wavewave> anyway.. i will implement pressure sensitivity support very soon. then you will see it more clearly.
19:37:13 <lpsmith> I think Control.Applicative needs a <$!>  and <*!>
19:37:58 <cmccann> ion, hm, not sure if I looked at it before or not, I remember trying several and finding them all buggy and/or lacking features I did need
19:37:58 <wavewave> cmccann: in fact, hxournal is already a good drawing program in my opinion, hehe
19:38:30 <wavewave> just for doodling-like drawing, of course.
19:38:45 <cmccann> yeah, I'm more talking the "digital painting" sort of thing
19:38:57 <wavewave> cmccann: i understand it...
19:39:02 <wavewave> like alias sketchbook pro.
19:39:13 <wavewave> ah.. now autodesk..
19:40:43 <ion> I wish i had the energy to implement a time axis, multitrack audio recording (synchronized to drawing) and non-linear editing to hxournal. That would be nice for Khan Academy style videos.
19:41:18 <cmccann> so I need lots of practical stuff for handling layers and controlling lines/brushes/&c.
19:41:50 <wavewave> ion: hehe.. I already got your request before.
19:41:54 <wavewave> ;-)
19:42:09 <cmccann> I've mostly used GIMP but it's been an unending headache in multiple ways
19:42:11 <ion> Yeah, i’m just saying i wish i had the energy to work on that myself.
19:42:38 <wavewave> ion: soon, hxournal will support scripting..  that's my plan...
19:42:45 <ion> cool
19:42:54 <wavewave> ion: so you can contribute to it by yourself. ;-)
19:43:39 <wavewave> recording is not very difficult.. hxournal already use time coordinate for rendering purpose.
19:45:54 <wavewave> haskell is a really productive language.. it shines when project got bigger and bigger.
19:46:44 <wavewave> recently I newtyped all coordinate type.. canvas coordinate, desktop coordinate, page coordinate. screen coordinate.
19:47:05 <wavewave> I found lots of bugs very early.
19:47:10 <cmccann> that's a great way to keep your sanity
19:47:26 <ion> :-)
19:48:00 <wavewave> and the decision to change to newtype is very doable since compiler will find all place where you need to change your code.
19:48:02 <cmccann> I can't even recall how many hours I've spent tracking down bugs of the "using display coordinates as world coordinates" variety
19:48:30 <wavewave> cmccann: exactly.. that's what happened to me one month ago.
19:48:37 * hackagebot ParserFunction 0.0.7 - Utilities for parsing and evaluating mathematical expressions.  http://hackage.haskell.org/package/ParserFunction-0.0.7 (EnzoHaussecker)
19:48:56 <cmccann> mostly that was back when I liked writing in games in Python
19:49:36 <wavewave> also giving different monoid definition for the same type is very helpful.
19:49:47 <wavewave> for example.. bounding box algebra.
19:50:00 <wavewave> Intersect monoid algebra and Union monoid algebra.
19:50:06 <cmccann> oh yes, absolutely
19:50:49 <wavewave> another necessary technique is using lens..
19:51:12 <wavewave> if your data structure has model - view relation.
19:51:37 <wavewave> lens must be taught somewhere in popular book.
19:52:21 <cmccann> meh, don't talk about that, you'll make me tempted to write my own book
19:52:25 <damo22> wow the genexPure function works a charm!!!
19:52:38 <wavewave> cmccann: please!!
19:53:03 <MaskRay> Hi Haskellers, I'm puzzled by the snippet extracted from Data.Lenses :(ircbot should give the src soon): Can you explain the underlying mechanism of `test'?
19:53:18 <cmccann> it would probably start with "chapter 1: only using total functions"
19:53:26 <xil> Question: <$> == flip map?
19:53:29 <damo22> genexPure = 7Mb binary
19:53:34 <MaskRay> http://hpaste.org/57655
19:53:35 <cmccann> that would also be chapters two through fifty-six
19:53:49 <wavewave> cmccann: that's a little difficult by the way.. for example, when using Map and lookup..
19:53:51 <rwbarton> chapter 0: introduction to agda
19:53:53 <Axman6> xil: <$> = fmap
19:54:00 <BMeph> cmccann: Please, also: include something prominent about syntax... ;)
19:54:02 <Axman6> :t (<$>)
19:54:02 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
19:54:03 <Axman6> :t fmap
19:54:05 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
19:54:31 <xil> Axman6: I remember once trying to use "for" when I wanted "flip map" and someone recommended some function with angle brackets
19:54:51 <cmccann> wavewave, yeah, it's not entirely avoidable, but still
19:55:06 <cmccann> xil, you can use an operator section, e.g. (<$> xs)
19:55:31 <Jafet> (`map` xs)
19:55:32 <wavewave> I was trying very hard to eliminate partial function... but quite hard and couldn't figure out a good way..
19:56:09 <wavewave> need some guideline.
19:56:24 <wavewave> you know.. I am still a newbie in haskell.
19:56:44 <BMeph> Yeah, to really get good use out of total functions, you have to be able to specify your types precisely.
19:56:58 <cmccann> wavewave, I dunno, hxournal looks pretty substantial, not sure if you can claim to be a newbie anymore :P
19:57:31 <cmccann> BMeph, strategic use of Maybe also goes a long way
19:57:42 <wavewave> indeed, last three months, my haskell ability got improved very much.
19:57:58 <NihilistDandy> wavewave: Wow, I might have to check that out. Just got a Wacom
19:57:59 <wavewave> good well-motivated project is the best thing to learn a language. ;-)
19:58:03 <cmccann> plus compromises of the "hide representation, preserve invariants" sort
19:58:43 <wavewave> NihilistDandy : ;-) great
19:59:06 <wavewave> NihilistDandy : could you check it now?
19:59:11 <NihilistDandy> It looks pretty great.
19:59:22 <NihilistDandy> I hope it'll compile on OS X :D
19:59:35 <wavewave> ah... that will be a problem.
19:59:43 <CodeWeaverX> NihilistDandy:  Greetings!  Hope all is well.
19:59:56 <j2jxx>  /query
20:00:03 <NihilistDandy> Hey CodeWeaverX. How goes?
20:00:04 <wavewave> first... mac os x, there is no way to detect wacom in X11
20:00:20 <NihilistDandy> Oh, really? That's unfortunate
20:00:29 * Axman6 spits on X11
20:00:33 <wavewave> yeah. that's unfortunate..
20:00:58 <wavewave> but I  am not sure with some homebrew X11...
20:01:12 <wavewave> X11 with apple has no support of Xinput extension.
20:01:17 <NihilistDandy> wavewave: What about XQuartz?
20:01:43 <wavewave> that's what I don't know.. maybe it's possible
20:02:05 <NihilistDandy> hmm
20:02:08 <NihilistDandy> I'll look around
20:02:15 <eviltwin_b> XQuartz doesn't help (it's the same line as Apple X11, in fact Lion's X11 was almost exactly the current XQuartz release)
20:03:22 <NihilistDandy> It seems that it's possible to use it in GIMP. Hmm
20:03:37 * hackagebot cityhash 0.3.0.1 - Bindings to CityHash  http://hackage.haskell.org/package/cityhash-0.3.0.1 (AustinSeipp)
20:03:39 <wavewave> if anyone figure it out, please let me know... (just write about it in issues in hxournal.) I also have mac with wacom tablet.. I am eager to solve this, too.
20:03:58 <wavewave> oh.. is it possible?
20:04:08 <wavewave> GIMP on X11?
20:04:13 <NihilistDandy> Apparently so, yes
20:04:23 <MaskRay> Hi Haskellers, I'm puzzled by the snippet extracted from Data.Lenses :http://hpaste.org/57655: Can you explain the underlying mechanism of `test'?
20:04:25 <wavewave> okay.. I will look at it.
20:04:31 <gnuemacs> Could some one recommend some good well-motivated projects? I'm a haskell newbie, thanks
20:04:41 <eviltwin_b> the problem is that X11 on OS X is just a protocol adapter, what it sees is filtered through Core Graphics etc. and there's simply no way to turn the processed device input back to what X11 wants to see
20:04:54 <NihilistDandy> gnuemacs: Rewrite all the code you've ever written in Haskell :D
20:05:04 <ivanm> wavewave: apparently if you get X11 elsewhere (via macports or something I guess) it'll work
20:05:29 <wavewave> ivanm: yeah... I didn't dare to try it yet..
20:05:58 <wavewave> in fact, I am thinking of it quite seriously now.
20:06:00 <eviltwin_b> (it might simply just work, if it relies on being able to get at individual devices directly it's unlikely though)
20:06:30 <gnuemacs> NihilistDandy: so simple? Ok, I will do as that, thanks
20:07:23 <ivanm> eviltwin_b: internet says mac's x11 doesn't like wacom in general
20:07:24 <wavewave> gnuemacs : just do what you most want.
20:07:42 <eviltwin_b> that wouldn't surprise me greatly
20:08:14 <ivanm> wavewave: http://clearcove.ca/2008/12/tablet-pressure-support-on-os-x-for-x11-gimp-and-inkscape/ ?
20:09:20 <elliott> MaskRay: btw, i do not recommend using Data.Lenses
20:09:46 <wavewave> ivanm: thanks!
20:10:15 <elliott> MaskRay: it's unmaintained, not used by any other packages, and the representation is not very good
20:10:52 <cmccann> wavewave, oh and btw, thanks for the pointer to the hxournal code, I bookmarked it for when I get the chance to work on the project of mine that needed tablet input
20:11:12 <wavewave> cmccann: ;-)
20:11:55 * chriss_ hi there
20:12:05 <elliott> hi
20:12:06 <parcs`> hi
20:12:09 <Enigmagic> omghi2u
20:12:11 <Enigmagic> !!!
20:12:41 <wavewave> hi
20:13:23 <gnuemacs> Hola
20:13:40 <NihilistDandy> Привет!
20:13:44 <MaskRay> elliott: thank you for your advice. i've merely attempted to learn Lenses' design.
20:14:19 <MaskRay> i think i have some superficial understanding with http://hpaste.org/57655 now
20:14:31 <elliott> MaskRay: it's basically transforming state monads
20:14:51 <elliott> i.e. Lens big small = forall a. State small a -> State big a
20:15:20 <elliott> since State can get and modify, it allows access... e.g. getL lens x = evalState (lens get) x
20:15:37 <elliott> that hpaste is just weird, though :P
20:15:55 <elliott> i have no idea what the ST is about
20:16:01 <wavewave> hmm.. I didn't know that lens need ST
20:16:21 <MaskRay> elliott: how to tell whether a pkg is maintained or not from the hackage description?
20:16:29 <wavewave> this is rather weird implementation I think
20:16:36 <ivanm> MaskRay: if it says it's unmaintained, then it isn't :p
20:16:42 <ivanm> if it doesn't have a maintainer, it isn't
20:17:03 <ivanm> if it's been a while since a release has been made and it no longer builds on new GHC, then it probably isn't (but try emailing the listed maintainer first)
20:17:10 <cmccann> also, many maintained packages will get at least a few minor updates occasionally, if the last upload date was over a year or two ago it's time to be suspicious
20:17:33 <Enigmagic> cmccann: unless you write perfect code, like me
20:17:34 <Enigmagic> :P
20:17:44 <elliott> MaskRay: look at the upload date
20:17:48 <MaskRay> ivanm: i cannot found information about 'unmaintained' from http://hackage.haskell.org/package/lenses
20:18:04 <elliott> also the linked repository hasn't been commited to since 2010
20:18:04 <ivanm> MaskRay: that one possibly could be
20:18:16 <ivanm> there's a github listed; check if there's been any recent activity?
20:18:29 <ivanm> if there hasn't been any activity since that release, it adds suspicioun
20:18:37 <cmccann> if the void package has a dozen versions despite existing entirely for the sake of not having any values to use, I think even the most perfect package needs updates now and then
20:18:38 <elliott> i mean, not to say there's necessarily any bugs or anything
20:18:48 <elliott> but the representation it uses is kinda lame anyway, so :P
20:18:58 <ivanm> and the answer to that is "no"
20:19:06 <ivanm> elliott: yeah
20:19:07 <edwardk> cmccann: hahah
20:19:13 <ivanm> cmccann: that's just edwardk though... ;)
20:19:19 <edwardk> well, there was a ghc version where it crashed the compiler
20:19:21 <cmccann> hahahaha
20:19:26 <MaskRay> maybe it's mature? so no longer modified...
20:19:31 <elliott> cmccann: My favourite thing about void is that it depends on semigroups just to give this incredibly useful instance:
20:19:32 <elliott> instance Semigroup Void where
20:19:32 <elliott>   a <> _ = a
20:19:32 <elliott>   times1p _ a = a
20:19:33 <edwardk> so i had to make it use 'data' for that version
20:19:39 <cmccann> elliott, :D
20:19:49 <edwardk> elliott: =)
20:19:55 <elliott> edwardk: thank you for letting us combine all 0 values of Void in abstract, high-level ways :P
20:19:59 <cmccann> edwardk, it still makes a hilarious point of comparison :D
20:20:02 <edwardk> important
20:20:22 <edwardk> well, its a canonical example of something that _can't_ be made a monoid ;)
20:20:24 <ion> elliott: :-D
20:20:30 <cmccann> elliott, well, that shows the value of semigroups, since clearly there's no mon--yeah, what he said :P
20:20:52 <elliott> We need a type that doesn't let you do `mempty = undefined`.
20:21:00 <elliott> Call it "Void!".
20:21:20 <edwardk> and the alternative was that semigroup depended on it, which would make ~30+ other packages transitively depend on it that don't care about the special case
20:22:00 * cmccann has both semigroups and void in his personal prelude replacement anyway
20:22:20 <edwardk> hrmm, i wonder, does data kinds work with empty data decls?
20:22:20 <MaskRay> all STRefs associated with members unreferenced by `to :: (Functor f) => a -> (c -> f (a -> b)) -> c -> f b' are untouched
20:22:25 <CodeWeaverX> I'm guessing that's a rite of passage…. defining your own Prelude.
20:22:29 <MaskRay> thus their State doesn't get modified
20:22:30 <edwardk> can i make an uninhabited kind?
20:22:35 <cmccann> hm
20:23:11 <CodeWeaverX> Funny… I'd have been shot for suggesting defining my own stdio.h…. mind you, I get strange looks for embracing haskell these days anyway so. ;)
20:24:00 <MaskRay> then a second scan collects these untouched States with touched and generates `updates'
20:24:13 <cmccann> well, in other languages people just tend to accept crappy standard libraries as a fact of life
20:24:25 <elliott> edwardk: It would be weird if it didn't work with that special case.
20:24:55 <cmccann> Haskell has an unfortunate tendency to make people raise their standards until Haskell itself stops measuring up :P
20:25:02 <CodeWeaverX> hahahahahaha
20:25:12 <CodeWeaverX> Y'know, I believe that.
20:25:16 <edwardk> hrmm bah, i can be polymorphic over the value in that kind, so it seems to be inhabitable
20:25:34 <edwardk> data Void; data Nope :: Void -> * where Nope :: Nope a
20:26:23 <NihilistDandy> cmccann: And then everyone moves to Agda, right? :D
20:26:36 <cmccann> that's one possible end result :P
20:26:41 <elliott> edwardk: that doesn't mean the kind itself is inhabited, does it?
20:26:44 <tigger> I don't know enough about haskell, but is there any reason why swig (to interface with C++) is available for languages like python but not for haskell, is it just that know one has had the time to do it? Or is there something deeper that makes this pursuit harder?
20:26:45 <elliott> or hmm, I guess Nope types
20:26:50 <edwardk> yeah
20:26:54 <elliott> edwardk: isn't that just the equivalent of undefined :: Void? :P
20:27:10 <cmccann> tigger, a bit of both possibly
20:27:14 <edwardk> well, if there was a way to shut off polymorphism it'd be better ;)
20:27:19 <elliott> tigger: GHC has its own special troubles with C++.
20:27:55 <cmccann> wouldn't swig paper over most of the C++ headaches though
20:28:05 <tigger> elliott: interesting, could you describe further?
20:28:16 <CodeWeaverX> Ultimately, it wouldn't really matter if it's C or C++ as long as someone took the time to write the bridge.
20:28:18 <cmccann> I thought that was the point of swig give or take
20:28:37 <CodeWeaverX> I'm not saying it wouldn't be some work, but…. I mean if you can use FFI to get out to C, you can get anywhere.
20:29:05 <edwardk> now if we got rid of those pesky types you could use something like boost::python ;)
20:29:11 <CodeWeaverX> wxWidgets as a case in point
20:29:25 <cmccann> my impression is that wrapping the C++ with a C interface
20:29:29 <cmccann> and then using the FFI to that
20:29:38 <cmccann> is actually often the easiest way
20:29:38 <CodeWeaverX> Eh, whatever works, man, whatever works. :D
20:29:43 <cmccann> which is kinda sad :P
20:29:52 <CodeWeaverX> People trying to use C++ libraries or code from C run into similar issues.
20:29:58 <elliott> tigger: I don't know details.
20:29:59 <CodeWeaverX> I expect you get used to it.
20:30:02 <elliott> But GHCi especially hates C++.
20:30:09 <cmccann> well, I hesitate to use "whatever works" and "C++" in the same sentence
20:30:14 <CodeWeaverX> ahahhahaha
20:30:21 <cmccann> elliott, it's in good company
20:30:25 <elliott> CodeWeaverX: wxHaskell wraps wxWidgets' C++ API with a very involved C binding.
20:30:30 <elliott> It's many hours of work in itself.
20:30:30 <CodeWeaverX> Having spent … geez… I feel old… couple decades fiddling with C++, I sympathize.
20:30:35 <CodeWeaverX> I believe it.
20:30:56 <tigger> im just wondering why python and those other scripting languages seem to be able to interact so nicely with guis, and other c++ libs. It might just be that so many people have put so much effort into getting the swig interface working
20:31:12 <cmccann> tigger, more effort is part of it, certainly
20:31:37 <cmccann> there's also the fact that Haskell is statically typed and so the interface needs to conform to that
20:32:08 <cmccann> which is awkward when interfacing with languages that don't really have a meaningful static type system, such as C++ :P
20:32:19 <tigger> cmccann: thats true, but I imagine langauges like ocaml would be similar, and ideas could be borrowed?
20:32:24 <cmccann> probably
20:32:28 <MaskRay> elliott: is data-lens preferred for lenses?
20:32:30 <cmccann> and ocaml is supported by swig if memory serves me
20:32:43 <cmccann> so I suspect "effort" is the biggest obstacle, as it often is
20:32:50 <tigger> gotcha
20:32:55 <cmccann> tigger, why, are you volunteering? :P
20:33:07 * Enigmagic thinks something better could be done with template haskell and clang
20:33:32 <cmccann> "better" and "template haskell" also don't belong in the same sentence fyi
20:33:33 <elliott> MaskRay: I use and recommend data-lens, and it's popular. fclabels is also fairly popular.
20:33:39 <wavewave> in fact, I have my own C++ FFI generator library.
20:33:55 <Enigmagic> cmccann: *shrug*
20:34:00 <elliott> cmccann: "Dying in a pit of eternal hellish pain would be better than debugging this Template Haskell code."
20:34:15 <wavewave> called fficxx
20:34:16 <tigger> cmccann: I don't think I know enough haskell. I was working on porting this program to haskell, but its in C++. there are python bindings with swig, so I was curious about why not haskell. I'll just have to warp it with C I think
20:34:20 <cmccann> data-lens is more streamlined and moves some stuff you might not want into supporting packages I think
20:34:28 <cmccann> which itself appeals to many people
20:34:30 <wavewave> not so good yet.. sometime it will be on hackage.
20:34:40 <cmccann> elliott, ok, point granted.
20:35:10 <tigger> wavewave: oh cool!
20:35:20 <Enigmagic> i guess you guys haven't had to debug much regular haskell either :P
20:35:24 <wavewave> tigger: if you want to see, see http://github.com/wavewave/fficxx
20:35:46 <wavewave> HROOT is a library on hackage using that code.
20:35:49 <cmccann> wavewave really seems to be on a roll with interesting projects for someone claiming to be a newbie :D
20:36:07 <wavewave> I am still learning...
20:36:22 <wavewave> For other language, I can say that I mastered it.. but haskell is not..
20:36:31 <wavewave> everyday, I learn something.
20:37:15 <wavewave> anyway, I am a little shy on fficxx yet.. but if anyone is interested in it, please check it out and comment on it.
20:37:31 * cmccann has little interest in touching anything related to C++ to be honest
20:37:46 <cmccann> but anything that might help people write bindings is awesome and a half
20:38:00 <CodeWeaverX> Ten years ago I would have sent the armies of Stroustrup against you for your insolence.
20:38:16 <hydo> holy hell, you don't know how good we've got it in Haskell until you start diving into calling C.  We have it really, really, good over here.
20:38:16 <CodeWeaverX> ;)
20:38:17 <elliott> MaskRay: (template haskell stuff is available in data-lens-template)
20:39:15 <tigger> wavewave: cool! yeah lots of cool projects! are there any tips to figuring out the directory structure, or what stuff is where for fficxx btw?
20:39:53 <wavewave> tigger: let me recall myself ;-P
20:40:16 <MaskRay> i need to grasp Comonad first before digging into Template Haskell
20:40:58 <rwbarton> elliott: btw, about Align, it occurred to me that if your functor is actually a functor from Kleisli Maybe to Hask (so it supports maybeFmap :: (a -> Maybe b) -> f a -> f b), then an Alignable instance is making your functor lax monoidal w.r.t. the cartesian monoidal structure on Kleisli Maybe
20:41:15 <wavewave> tigger : the problem is that this code was originally tightly bound to HROOT. so I am not sure whether it's completely independent now from HROOT..
20:41:33 <elliott> rwbarton: *now* I get it!
20:41:42 <rwbarton> because OneOrBoth is the cartesian product in that category (a -> Maybe (OneOrBoth x y) ~ (a -> Maybe x, a -> Maybe y))
20:41:48 <elliott> OneOrBoth = These, btw
20:41:53 <elliott> cmccann: that needs to go in the documentation, don't you think?
20:41:53 <rwbarton> okay
20:42:04 <cmccann> elliott, sounds good to me
20:42:29 <rwbarton> I don't really know what to make of this aside from that it tells you what (some of) the laws should be
20:42:31 <tigger> wavewave: crap this seems too pro haha
20:42:40 <MaskRay> elliott: i depressed, data-lens is not well documented
20:42:59 <cmccann> data-lens really is pretty self-explanatory if you know what lenses are, to be fair
20:43:08 <elliott> MaskRay: meh, there's not all that much to it; http://hackage.haskell.org/packages/archive/data-lens/2.0.2/doc/html/Data-Lens-Common.html is the core of it, the rest is just convenience for state monads
20:43:20 <elliott> in particular, the pseudo-imperative and stock lenses sections can be ignored entirely
20:43:32 <rwbarton> (also a -> Maybe Void ~ () so empty :: f Void is the "unit" part of the structure)
20:43:42 <elliott> rwbarton: are the laws different to the ones we already have?
20:44:12 <wavewave> tigger :  in my repository.. you can find HROOT-generate and HROOT.
20:44:25 <rwbarton> Are those laws written down somewhere? Are they the ones below the class definition on that page you linked me to earlier?
20:44:50 <rwbarton> There should be an associativity law as well which will be a bit fiddly to write down
20:44:52 <wavewave> HROOT-generate is generating HROOT package source code.
20:44:53 <hpaste> elliott pasted “rwbarton” at http://hpaste.org/57656
20:44:58 <elliott> rwbarton: the blog post has them
20:45:05 <wavewave> similarly, HFastJet-generate and HFastJet .
20:45:12 <elliott> rwbarton: they boil down to:
20:45:24 <elliott> rwbarton: align a empty = fmap This a; align empty b = fmap That b; align a a = fmap (join Both) a
20:45:32 <elliott> (with the "zippy" align rather than the "zipWithy" align)
20:45:51 <edwardk> MaskRay: comonad is just like monad, but the arrows run the wrong way
20:46:02 <edwardk> extract :: f a -> a  instead of return :: a -> f a
20:46:11 <cmccann> rwbarton, and for context, it's all ending up here: https://github.com/ehird/these/blob/master/Data/Align.hs
20:46:13 <tigger> wavewave: is there something root does that makes automating bindings easier?
20:46:24 <edwardk> extend :: (f a -> b) -> f a -> f b  instead of (=<<) :: (a -> f b) -> f a -> f b
20:46:25 <rwbarton> so also "These (These a b) c" and "These a (These b c)" are isomorphic and the maps f a -> f b -> f c -> {These (These a b) c/These a (These b c)} should be equal up to that isomorphism
20:46:27 <elliott> rwbarton: (except it has "empty" now, it doesn't in that version)
20:46:38 <edwardk> duplicate :: f a -> f (f a) instead of join :: f (f a) -> f a
20:46:54 <rwbarton> er, insert an f before {
20:46:55 <MaskRay> edwardk: monad tutorials are all around while comonad's is few...
20:47:02 <wavewave> tigger: http://github.com/wavewave/HFastJet-generate/tree/master/lib/Application/HFastJetGen/Data/
20:47:05 <edwardk> maskray: lets work through one
20:47:14 <edwardk> consider the comonad for (,) e
20:47:19 <wavewave> tigger : here.. you define C++ interface..
20:47:20 <edwardk> so (e, a) are its values
20:47:25 <edwardk> extract :: (e, a) -> a
20:47:36 <edwardk> the definition should be pretty straightforward to guess ;)
20:47:53 <tigger> wavewave: oh thats a nice example!
20:48:09 <rwbarton> elliott: your first two laws are the unit laws for the lax monoidal structure, I'm not sure what to make of the third one (yet)
20:48:18 <wavewave> tigger : I didn't make some automatic header file  parser yet... that's too difficult to me.
20:48:31 <edwardk> maskray: then extend :: ((e, a) -> b) -> (e, a) -> (e, b) -- only has one reasonable definition as well
20:48:43 <elliott> hm, wait.
20:48:44 <wavewave> tigger: anyway, it's a kind of code that only I can understand.. now.. so I am a little shy..
20:48:52 <elliott> never mind
20:49:11 <elliott> rwbarton: well, the intuition is that the union of a shape with itself is that shape
20:49:13 <tigger> wavewave: haha yeah it looks pretty pro though
20:49:20 <wavewave> I would like to polish it some time soon..
20:49:24 <elliott> rwbarton: and so every hole should be filled (with the same values in both, of course)
20:49:27 <rwbarton> yeah, I see where it is coming from, just not sure how it would fit into this point of view
20:49:30 <elliott> rwbarton: plus, it doesn't duplicate effects
20:49:35 <rwbarton> right
20:49:37 <elliott> as in, consider that such a law can't hold for IO
20:49:39 <wavewave> tigger: anyway.. HROOT itself is pretty usable library.. hehe
20:49:39 <rwbarton> that seems like an extra law
20:49:49 <elliott> yes, but a useful one, I would say
20:49:58 <edwardk> maskray: turns out that every comonad you can write down turns out to give you a monad transformer, so you can actually figure out what monad is related to any given comonad
20:49:58 <edwardk> (every comonad in Haskell that is)
20:50:06 <MaskRay> extend :: ((e, a) -> b) -> (e, a) -> (e, b) , yeh
20:50:10 <hpaste> elliott pasted “unalign” at http://hpaste.org/57657
20:50:14 <elliott> rwbarton: you might be interested in that, too ^
20:50:18 <tigger> wavewave: okay I'll check it out, when I get a chance to. thanks for ur help
20:50:18 <wavewave> although the binary becomes too large...
20:50:36 <elliott> rwbarton: (the default implementation is problematic precisely because it might duplicate effects)
20:50:47 <wavewave> some time soon, I will put that on the hackage at least.
20:50:50 <edwardk> extend f w@(e, _) = (e, f w)
20:50:51 <MaskRay> edwardk: so (,) e is the reader comonad?
20:50:55 <edwardk> yep
20:51:47 <edwardk> and Monoid m => m -> a   -- is a comonad that bears a strong resemblance to the writer monad
20:52:00 <edwardk> extract f = f mempty
20:52:12 <edwardk> extend for that is a bit tricky to work out first time though
20:53:03 <elliott> cmccann: (please convince me not to call unalign "skew")
20:53:19 <MaskRay> edwardk: from the point of shape, reader comonad is like writer monad while writer comonad is like reader monad
20:53:54 <augur> edwardk: any papers you could recommend?
20:54:21 <edwardk> maskray: yep. there is a reason, given that there is an adjunction between (,)e and (->) e
20:54:28 <rwbarton> elliott: how about this for another law--align (fmap f x) (fmap g y) = fmap (bifmap f g) (align x y)
20:54:31 <edwardk> augur: on comonads?
20:54:36 <augur> edwardk: not on anything specific, just good stuff in general
20:54:44 <rwbarton> or i guess it follows from parametricity
20:55:08 <elliott> rwbarton: what type does bifmap take there?
20:55:21 <rwbarton> bifmap :: (a -> a') -> (b -> b') -> These a b -> These a' b'
20:55:41 <elliott> ah. (I guess a Bifunctor instance would be a good idea)
20:55:42 <edwardk> maskray: state and 'store' are related similarly. one is (,) e . (->) e, the other is (->)e . (,) e
20:55:43 <cmccann> elliott, I'd probably use something ridiculous like "misalign" so don't ask me
20:55:55 <elliott> rwbarton: yes, that seems good to me
20:56:07 <rwbarton> @free F x -> F y -> F (G x y)
20:56:07 <lambdabot> Pattern match failure in do expression at Plugin/Free/FreeTheorem.hs:54:20-34
20:56:15 <rwbarton> @free align :: F x -> F y -> F (G x y)
20:56:15 <lambdabot> Plugin `free' failed with: Plugin/Free/FreeTheorem.hs:(202,0)-(291,23): Non-exhaustive patterns in function freeTheorem'
20:56:30 * MaskRay take time to digest
20:56:33 <edwardk> s -> (s, a)   and (s, s -> a)  -- i flipped the args usually used in State to make it clearer
20:56:40 <cmccann> elliott, for context my contravariant version of Applicative was called "Inapplicative" and had a function called "impure" if that gives you any idea of my approach to naming things :P
20:56:42 <elliott> rwbarton: you broke @free!
20:56:43 <edwardk> working out the store comonad is a good exercise
20:56:51 <rwbarton> how did I do that
20:56:54 <elliott> cmccann: can't say my names are much better :P
20:56:56 <rwbarton> @free align :: G x y
20:56:56 <lambdabot> Plugin `free' failed with: Plugin/Free/FreeTheorem.hs:(202,0)-(291,23): Non-exhaustive patterns in function freeTheorem'
20:56:58 <rwbarton> @free align :: G x
20:56:58 <lambdabot> $map_G f align = align
20:57:07 <rwbarton> I see
20:57:09 <elliott> single-arg types only it seems
20:57:19 <rwbarton> @free align :: (x,y)
20:57:20 <lambdabot> $map_Pair f g align = align
20:57:29 <rwbarton> close enough
20:57:29 <edwardk> extract :: (s, s -> a) -> a is pretty easy. the extend is a little trickier
20:57:33 <rwbarton> @free align :: F x -> F y -> F (x, y)
20:57:34 <lambdabot> $map_F ($map_Pair f g) . align x = align ($map_F f x) . $map_F g
20:57:40 <cmccann> elliott, or even, say, names like "data These a b = This a | That b | These a b" because seriously
20:58:09 * cmccann is also prone to stuff like "newtype Fix f = Fix { broke :: f (Fix f) }
20:58:13 <edwardk> cmccann nice names
20:58:16 <cmccann> in conclusion, don't ask me to name things :P
20:58:28 <edwardk> Nu { old :: … }
20:58:30 <CodeWeaverX> All data types become
20:58:39 <rwbarton> nutype
20:58:44 <cmccann> oh yeah, edwardk likes my naming schemes, if you needed even more evidence not to trust them ;]
20:58:47 <CodeWeaverX> data Cmccann = Cmccann1 ....
20:58:54 <edwardk> hah
20:59:00 <MaskRay> it's really necessary to update http://www.haskell.org/haskellwiki/Comonad
20:59:01 <elliott> cmccann: I keep mixing up This and That mentally :(
20:59:11 <CodeWeaverX> What about TheOther?
20:59:16 <CodeWeaverX> totally doesn't get enough playtime.
20:59:31 * elliott would have gone for First a | Second b | Both a b or maybe One a | Other b | Both a b
20:59:41 <cmccann> elliott, "this and that" sounds right to me but "that and this" is wrong
20:59:55 <cmccann> so the constructors and type parameters use that order
20:59:56 <elliott> cmccann: yes, that's what I have to reason mentally every single time I use them :P
21:00:33 <elliott> haha, http://www.haskell.org/haskellwiki/Comonad is a quality page
21:00:40 * cmccann shrugs
21:00:54 <cmccann> they're silly but I've actually gotten kind of attached to the names for These :T
21:01:11 <cmccann> now the function names for ChronicleT, those are just goofy
21:01:18 <cmccann> but I never expect that to be useful anyway
21:01:20 <cmccann> :P
21:01:37 <wavewave> edwardk: nice! the page gives the very definition!
21:01:49 <edwardk> hah
21:01:58 <edwardk> it is at least correct ;)
21:02:46 <wavewave> in fact.. one can say even shorter : Comonad : as the name suggests
21:02:53 <elliott> cmccann: what would you call `these id id`?
21:02:58 <elliott> I guess it's not that useful...
21:03:55 * ski is reminded of a Pascal book which insisted on naming types in the plural. `weekdays',&c.
21:04:26 <elliott> @pl \x y -> f x (g y z)
21:04:26 <lambdabot> (. flip g z) . f
21:04:27 <cmccann> elliott, it's sort of a counterpart to fromThese I guess
21:04:32 <elliott> @pl \y -> f x (g y z)
21:04:33 <lambdabot> f x . flip g z
21:04:37 <elliott> oh well
21:05:46 <cmccann> I think what this really needs are some Monoid-based utility functions
21:05:54 <cmccann> because padding with mempty is a pretty likely use
21:07:52 <elliott> cmccann: yeah, I just gave a Bifoldable instance
21:07:56 <elliott> which gives (Monoid m) => These m m -> m
21:08:14 <elliott> which is nice
21:08:15 <cmccann> yeah
21:08:25 <elliott> also these definitions are really pretty:
21:08:29 <elliott>     bifoldr f g z = these (`f` z) (`g` z) (\x y -> x `f` (y `g` z))
21:08:30 <elliott>     bifoldl f g z = these (z `f`) (z `g`) (\x y -> (z `f` x) `g` y)
21:08:41 <cmccann> haha, nice
21:09:02 <cmccann> the nice thing about single-letter variables is that they're the same width
21:09:11 <elliott> edwardk: I don't quite understand Bifoldable1.
21:09:17 <elliott> What does it give you over Bifoldable?
21:09:31 <elliott> Oh, Semigroup rather than Monoid.
21:09:48 <cmccann> so you don't have to utrecht up your code to get nice vertical alignment
21:09:53 <cmccann> which is convenient
21:10:36 <Saizan> utrecht?
21:10:50 <elliott> Saizan: no, don't ask!!!
21:10:54 <cmccann> hahaha
21:11:09 <elliott> Saizan: http://hackage.haskell.org/packages/archive/uu-parsinglib/2.7.3.2/doc/html/src/Text-ParserCombinators-UU-Core.html#T
21:11:12 <MaskRay> @djinn ((m->a)->b) -> (m->a) -> (m->b)
21:11:13 <lambdabot> f a b c = a (\ _ -> b c)
21:12:26 <elliott> oh! i suddenly understand cmccann's weird import ordering
21:13:02 <cmccann> hm?
21:13:23 <cmccann> what didn't you understand :?
21:13:33 <elliott> wait, never mind
21:13:39 <elliott> I thought it was alphabetic, but it's not :P
21:13:42 <elliott> Prelude coming last confused me
21:14:05 <cmccann> oh yeah I'm not as consistent about that as I should be :[
21:14:37 <elliott> i'm more confused by how you select whether to use an explicit import list or not, heh
21:14:59 <cmccann> I do have an idiosyncratic sort of order that I like them in but I mess it up all the time, sigh
21:15:14 <elliott> ooh, Bifunctor supercedes mapThis/mapThat/mapThese
21:15:19 <elliott> as first/second/bimap
21:15:33 <elliott> i wonder which set of names is more confusing :P
21:15:47 * elliott wrote the instance without realising it was already there, heh
21:15:49 <cmccann> explicit import lists usually indicate that I want a few specific definitions
21:16:34 <elliott> the tradeoff between redundant over-specialised names and people not being able to find the functions they want is annoying
21:17:12 <cmccann> sort of a "specific things from an otherwise irrelevant module" vs. "everything in this module is relevant unless excluded" idea
21:17:29 <cmccann> at least in terms of what I was thinking when I wrote that part :P
21:18:11 <cmccann> there was/is a lot of messy stuff in these, cf. the dumb typo rampion found :T
21:18:28 <cmccann> anyway, I like having specialized names for the type
21:18:37 <cmccann> and defining the type class functions using those
21:18:42 <dmwit> Is "Utrecht" the official name for that kind of alignment? =P
21:18:47 <dmwit> (I do that all the time.)
21:18:58 <cmccann> and putting a note in the haddocks for the specialized version about what it corresponds to
21:19:25 <elliott> the best packages are just a type definition with fifty bajillion instances
21:19:30 <cmccann> utrecht is when you line things up by sticking a bunch of mysterious whitespace everywhere, apparently :P
21:19:32 <elliott> or, they would be the best packages, if haddock didn't suck so much
21:19:58 * elliott usually uses chunks of named documentation to note which instances to use to accomplish various things (cf. the Data.Align reference in Data.These)
21:20:03 <elliott> but even that's not totally satisfactory
21:20:04 <rwbarton> but the things are not even lined up correctly
21:20:36 <cmccann> ah, like edwardk's packages? import fifty of his other packages to get twice that many type classes, define a couple data types, then hundreds of lines of instances :P
21:21:42 <elliott> cmccann: well, I did just write 6 or so instances from one of edwardk's packages... so: exactly! :P
21:21:47 <cmccann> :D
21:21:51 <elliott> except I actually document which instance to use to do things, hehe
21:22:25 <Saizan> http://bit.ly/5mwtRQ",  "admin/spam issues: #haskell-ops"]
21:22:26 <Saizan> 07:15  Topic set by copumpkin [Sat Dec 17 23:06:48 2011]
21:22:32 <Saizan> sorry
21:22:56 <cmccann> anyway, I do like having specific names (which don't even need to be exported by default, I guess), as well as having alphanumeric synonyms for most operators
21:22:59 <cmccann> but that's me
21:23:50 * elliott isn't sure what exported "by default" means
21:23:52 <rwbarton> the Unalign instance for [] is just a better implementation of the default definition, right?
21:24:20 <cmccann> elliott, oh, in the sense of stuff being reexported by a central module
21:24:27 <cmccann> which is something else I tend to do a lot
21:24:55 <elliott> rwbarton: yes
21:25:08 <cmccann> like how Prelude has Maybe but not some other stuff that's in Data.Maybe
21:25:08 <elliott> rwbarton: there are no "non-default" instances so far
21:25:45 * elliott wishes Haddock had a way to "expand" an instance inline, showing like the class definition, but with the header changed to "instance ...", and all the types specialised to the instance
21:25:56 <elliott> and with instance-specific haddocks
21:25:58 * cmccann wishes for a pony
21:26:01 <elliott> also that
21:26:29 <cmccann> though I guess there's always http://hackage.haskell.org/package/pony
21:27:17 * ski wishes one could put type signatures on instance methods
21:27:45 <glguy> ski: put them inline?
21:27:57 <cmccann> ski, you can, you have just to prefix them with the special -- syntax for writing instance type signatures :P
21:28:39 <ski> cmccann : but then they aren't checked
21:28:55 <ski> glguy : hm ?
21:29:01 <glguy> show = (\ () -> "()") :: () -> String
21:29:05 <glguy> something like this?
21:29:53 <ski> it's not as clear
21:30:08 <elliott> I think (These a) might be an Extend.
21:30:23 <ski> (does it work to put constraints there ?)
21:31:16 <elliott> oh, hmm, maybe not
21:31:44 <elliott> or at least, there's two obvious instances
21:33:48 <cmccann> well, there are instances for ((,) a) and (Either a)
21:34:33 <elliott> but is duplicate (This x) = This x or That (This x)?
21:35:09 <cmccann> I am suspicious that one of those might violate relevant laws
21:35:43 <cmccann> of course there's no comonad so we can't use that for comparison
21:37:16 <cmccann> shouldn't duplicate be "extend id"?
21:37:33 <cmccann> or does that not help
21:37:44 <elliott> I didn't bother defining extend :P
21:37:47 <cmccann> guess it probably doesn't.
21:38:21 <cmccann> no, wait
21:38:28 <cmccann> extend gives you something of the parametric type
21:39:05 <cmccann> so it seems like it ought to use that
21:39:13 <elliott> I wonder if figuring out what all that reducers stuff is about is worth it, considering the blog post that started all this mentions that align lets you do things with them.
21:39:32 <zzo38> How can you make a extensible product type which fields of any types can be added in later on even in different modules? I have managed to do that but it uses unsafeCoerce and various things and I am not sure of its efficiency or how much memory it leaks.
21:40:27 <cmccann> probably, it seems interesting
21:40:30 <elliott> this i gotta see
21:40:40 <elliott> zzo38: can you paste your implementation?
21:41:03 <cmccann> ok, and on that note I should probably be heading out
21:41:06 <zzo38> elliott: http://sprunge.us/YjgH
21:45:10 <cmccann> elliott, thanks for all your help on all this these stuff, btw :D
21:45:10 <edwardk> cmccann: re utrecht: so true. i have never figured out the set of tabstops or whatever that they use!
21:45:10 <cmccann> ..."this these stuff" oh my god why did I call it that
21:45:10 <cmccann> edwardk, yeah it just confuses me :T
21:45:10 <zzo38> But is there a better way?
21:45:10 <elliott> zzo38: you can do typedEq without unsafeCoerce...
21:45:10 <elliott> use Data.Typeable.cast
21:45:10 <zzo38> O, I didn't know that, thanks for telling me that.
21:45:11 <elliott> typedEq x = maybe False (x ==) . cast
21:45:11 <elliott> I would assume the same applies to putExtProd but don't know
21:45:11 <zzo38> But still, is there any better way to do this kind of things? (Note: I do not use all the extensions I specified; I put them there when trying other things and did not remove them yet)
21:45:11 <cmccann> edwardk, usually I end up staring cross-eyed at it for a while in hopes that the alignment is actually some sort of ASCII art magic-eye picture
21:45:11 <edwardk> you might be onto something
21:52:50 --- mode: sendak.freenode.net set +o ChanServ
21:52:52 <cmccann> and the only obvious use for it is as a logging+error monad
21:52:53 <Ralith> Sgeo: memory?
21:53:31 <cmccann> edwardk, but really the main goal was to come up with goofy names for the operations in defines
21:53:37 <edwardk> hah
21:54:11 <cmccann> well, that and because there's no good way to create it from other types, since (A + B + A*B) doesn't factor nicely
21:54:45 <edwardk> yep
21:54:55 <elliott> Aw, I can either have a (Monoid c, Apply m) => Apply (ChronicleT c m) instance, or a Bind instance
21:54:59 <elliott> for the Bind instance I need (Monad m)
21:55:12 <cmccann> but yeah the name is to suggest both keeping a record of stuff and having an end to what's recorded, for the writer and error aspects
21:55:17 <elliott> or else Bind m, Monad m in the Bind instance header and duplicate the code for (>>=) since Bind can't be required there
21:55:45 <edwardk> elliott: you wind up duplicating code in Bind instances a lot
21:56:00 <edwardk> thats the price of it not being a real superclass of Monad
21:56:12 <zzo38> You still have not answered my original question
21:56:57 <elliott> edwardk: I just went with instance (Monoid c, Apply m, Monad m) => Bind (ChronicleT c m) where (>>-) = (>>=)
21:57:20 <elliott> that instance needs pure/return anyway
21:57:42 <elliott> ooh, Alt!
21:57:53 <edwardk> yeah, the monads that don't admit a 'bind transformer' tend to be the ones with crappier monadplus instances, btw ;)
21:58:01 <edwardk> hahaha
21:58:11 * edwardk watches elliott dash around like a kid in a candy store
21:58:16 <elliott> cmccann: hmm, why no (Monoid a, Monoid b) => Monoid (These a b) instance?
21:58:21 <zzo38> edwardk: In my opinion, Applicative should be a superclass of Monad, liftPair should be a method of Applicative, and join should be a method of Monad. (Functor is already a superclass of Applicative, so that works; and <*> and >>= should still be class methods too)
21:58:35 <elliott> edwardk: no MonadPlus instance, there's no zero
21:58:35 <cmccann> elliott, probably just forgot
21:58:40 <elliott> well, there is with Monoid
21:59:13 <elliott> cmccann: oh, because This mempty vs. That mempty vs. These mempty mempty
21:59:14 <edwardk> i'd rather not have liftPair in favor of a baked in liftA2, some applicatives that 'zipWith' style is more natural for and the liftPair model forces you to introduce an extra structure you probably don't need just to tear it down
21:59:46 <cmccann> note that the Chronicle stuff all needs a Monoid constraint on the This type anyway
22:01:01 <edwardk> clearly you need to CPS Cronicle so you can make instances of MonadSpec, etc. ;)
22:01:31 <cmccann> elliott is the one writing instances here it seems
22:01:35 <cmccann> I should be heading to bed
22:01:43 <zzo38> edwardk: OK, yes some other people have said the same thing. I just wanted it due to mathematical purposes and that you can write your own fmap separately (or even derive Functor since it is a unique way to do so)
22:01:47 <elliott> actually I don't know what (These a x <!> These b y) should be
22:01:53 <edwardk> and you need a representable-trie instance for it
22:02:05 <edwardk> it should be the same as the monadplus instance
22:02:14 <edwardk> <!> = <|> when possible
22:02:26 <elliott> I don't know what the MonadPlus instance is
22:02:26 <edwardk> and behaves like an annotated <> when not
22:02:32 <edwardk> you have a semigroup?
22:02:38 <elliott> yep
22:02:48 <elliott> I guess I'll just use (<>) then
22:02:49 <edwardk> is it compatible?
22:03:06 <elliott> let's say yes!
22:03:07 <edwardk> not sure it works
22:03:24 <elliott> well
22:03:29 <elliott> it doesn't encode "error-handling"
22:03:38 <elliott> This a <> That y = These a y
22:03:46 <elliott> it's... error-writer, as always :P
22:03:48 <edwardk> well, the main concern i'd have is that <!> is compatible in the sense of the monadplus laws with the monad you have
22:04:11 <cmccann> edwardk, btw, what do you make of this type: data And f g r where And :: ((a, b) -> r) -> f a -> g b -> And f g r
22:04:13 <edwardk> for at least one sense of the left distributive or left catch law
22:04:20 <elliott> which ones? the mzero ones don't apply, after all
22:04:22 <cmccann> assuming that f and g are Functors
22:04:52 <Sgeo> error-writer?
22:05:03 <elliott> Sgeo: yes.
22:05:05 <cmccann> because I know what the type is for and it works but I'm trying to make sense of why because I need to find a dual of it...
22:05:52 <edwardk> the distributive law. return a <!> b = a   or (a <!> b) >>- k = (a >>- k) <!> (b >>- k)
22:06:13 <edwardk> return a <!> b = return a would be the left catch equivalent
22:06:17 * elliott pushes a bunch of instances
22:06:23 <cmccann> :D
22:06:38 <edwardk> if one of those holds you can make it 'Alt' with a clear conscience ;)
22:07:00 <elliott> edwardk: the first one doesn't hold. the latter one... might.
22:07:24 <elliott> it's hard to tell :P
22:07:38 <tkahn6_> elliott: i dig the names you have for your functions
22:07:48 <elliott> not mine!
22:07:50 <elliott> it's cmccann's library :P
22:07:51 <cmccann> hahahaha
22:07:57 <tkahn6_> cmccann: i dig it
22:08:00 <cmccann> which names?
22:08:15 <zzo38> I think it doesn't make sense to have two different laws like that; instead make a separate class for each one, with the Alternative superclass for left catch and MonadPlus superclass for distributive, but no extra class methods
22:08:15 <tkahn6_> confess, absolve, retcon
22:08:45 <cmccann> ah yes, the goofy Chronicle names, those were way too much fun to come up with, heh
22:09:05 <tkahn6_> it's so anthropomorphic, love it
22:09:27 <cmccann> I also like how Data.These is full of names like "isThis" and "mapThat"
22:09:30 <edwardk> zzo38: in reality they are two classes, in practice nobody is in a hurry to break it out because it'd be hard
22:09:42 <tkahn6_> easter egg: mapThatAss
22:09:45 <elliott> I think cmccann has a script set up to automatically push anything I do
22:10:20 <elliott> ok, now to figure out why haddock is mangling <$> in monospaced text *sigh*
22:10:21 <cmccann> you mention pushing it, of course I'm going to merge the changes :P
22:10:27 <tkahn6_> another idea: create aliases such that 'this' becomes 'dat'
22:10:27 <cmccann> because haddock
22:10:40 <tkahn6_> mapDat
22:10:45 <edwardk> zzo38: as a result i never write code that is polymorphic in terms of the underlying monadplus unless i don't use non-determinism in the code, to a degree where the two laws coincide, or unless i explicitly lift someone else's monadplus semantics in a preserving way
22:10:50 <tkahn6_> and then mapDis
22:11:07 <edwardk> zzo38: i don't think most other people think about it that much though ;)
22:11:21 <elliott> oh wow
22:11:28 <elliott> cmccann: the instances list haddock generates is now a thing of majesty
22:11:38 <edwardk> elliott: welcome to my world
22:11:42 <elliott> hahahahaha
22:11:51 <cmccann> :D :D
22:12:07 * elliott can't imagine edwardk ever actually writes code specialised to a concrete type
22:12:21 <elliott> datatype construction by constraint composition
22:12:37 <elliott> @remember edwardk <elliott> cmccann: the instances list haddock generates is now a thing of majesty  <edwardk> elliott: welcome to my world
22:12:37 <lambdabot> Nice!
22:12:44 <edwardk> hah
22:13:07 <edwardk> i like polymorphism
22:13:09 <edwardk> it makes me happy
22:13:37 <cmccann> see, this is why we need to get -XPolymorphismRestriction implemented
22:13:37 <edwardk> i spent so long in c++ writing templates that when i got here it was a little TOO easy. ;)
22:13:44 <edwardk> i felt really uncomfortable with it for a while
22:14:01 <edwardk> hah
22:14:35 <cmccann> tkahn6_, ok, after grepping some old piles of junk code it seems a previous incarnation was, in fact, "Dis a | Dat b | Dese a b"
22:14:40 <cmccann> but that was a bit too silly, even for me
22:14:50 <tkahn6_> cmccann: haha nice!
22:15:48 <cmccann> I also had a variant that included the case where neither value was present
22:16:02 <cmccann> the constructor for which was "Nuthin"
22:16:11 <cmccann> I honestly don't know what I was thinking there.
22:16:22 <cmccann> I guess it seemed like a good idea at the time.
22:16:31 <elliott> haha
22:16:49 <elliott> edwardk: right, but then you solved the "easy" thing
22:17:05 <elliott> finally putting haskell on the same level of c++ when it comes to difficulty of abstraction
22:17:19 <zzo38> If you have the neither value it is like (Maybe a, Maybe b) isn't it?
22:17:40 <cmccann> zzo38, yes, which is clearly the most ridiculous aspect of that type
22:18:24 <Eduard_Munteanu> More like Maybe (Either a b)
22:18:39 * hackagebot shakespeare 0.10.3.1 - A toolkit for making compile-time interpolated templates  http://hackage.haskell.org/package/shakespeare-0.10.3.1 (MichaelSnoyman)
22:18:41 * hackagebot shakespeare-js 0.11.0.1 - Stick your haskell variables into javascript/coffeescript at compile time.  http://hackage.haskell.org/package/shakespeare-js-0.11.0.1 (MichaelSnoyman)
22:18:43 * hackagebot shakespeare-text 0.10.5 - Interpolation with quasi-quotation: put variables strings  http://hackage.haskell.org/package/shakespeare-text-0.10.5 (MichaelSnoyman)
22:18:44 <Eduard_Munteanu> Oh, you want both, not none :)
22:19:41 <cmccann> the same code with the aforementioned type also appears to include a module called AbstractNonsense with my own hand-rolled versions of Contravariant and Bifunctor, for whatever reason
22:19:58 <elliott> hmm, how do you put comments in haddock?
22:19:59 <cmccann> I also renamed mappend to (++) so at least some things never change
22:20:02 <elliott> -- --
22:20:07 <elliott> serious question, actually :P
22:21:22 <cmccann> beats me, I don't understand haddock
22:22:28 <cmccann> hey, you're right, the instance list for These is starting to look respectable
22:22:57 <cmccann> I can still see them all in one screen though, so clearly we need more
22:23:15 <ion> It’s annoying Haddock doesn’t add links to the instance definitions.
22:23:29 <cmccann> aim for the stars, elliott, aim for the stars: http://hackage.haskell.org/packages/archive/algebra/2.0.4/doc/html/Numeric-Map.html
22:23:31 <edwardk> ion: yeah
22:23:37 <zzo38> Looking at dependent-sum package, your These type also seem to be a possible (DSum X) if you have: data X a b c where { A :: X a b a; B :: Maybe a -> X a b b; };
22:23:40 <elliott> cmccann: jesus christ
22:23:45 <edwardk> ion: at least it finally started putting in the haddock comments on the instances somewhere
22:23:45 <cmccann> :D
22:24:01 <elliott> i actually looked at the categories package
22:24:07 <edwardk> haha
22:24:09 <elliott> and i think it could give us like five more instances at the cost of my sanity
22:24:11 <edwardk> forgot about that one =)
22:24:45 <hpaste> elliott pasted “haddock” at http://hpaste.org/57659
22:24:52 <elliott> cmccann: believe it or not, the above is perfectly aligned
22:25:02 <edwardk> http://hackage.haskell.org/packages/archive/algebra/2.0.4/doc/html/Numeric-Covector.html is the one i tend to use
22:25:26 <elliott> edwardk: "Complicated" indeed.
22:25:32 <zzo38> Before when looking at dependent-sum package they gave an example GADT called Tag to use (DSum Tag) but I realized that the tag can also be a GADT with parameters and/or constraints, or a functor, or a contrafunctor, or a datatype family
22:26:05 <cmccann> heh, Complicated
22:26:15 <cmccann> that one's definitely my kind of name :P
22:26:21 <edwardk> =)
22:26:25 <MaskRay> coreader is called Env and cowriter is called Traced
22:26:49 <edwardk> class Distinguished r => Complicated r where i :: r -- obviously =P
22:27:08 <cmccann> I'd also like to note that edwardk has a "Discontinuation" comonad
22:27:12 <edwardk> class Distinguished t where e :: t -- gives you the distinguished element of the vector space usually used for 1
22:27:13 <cmccann> that's just beautiful, really
22:27:26 <Eduard_Munteanu> Is that how you get complex numbers? You complicate reals? :)
22:27:26 <edwardk> too bad its largely useless
22:27:28 <zzo38> cmccann: I have seen the discontinuation comonad
22:27:33 <edwardk> Eduard_Munteanu: exactly =)
22:27:41 <elliott> edwardk: instance Distinguished PhoneHome
22:27:50 <cmccann> edwardk, alas, though I've occasionally tried to find a use for it just because I like the name
22:28:23 <elliott> Come on, that one was good.
22:28:31 <edwardk> what i do is define complicated for things like the free vector using data C = E | I as the set.
22:28:40 <edwardk> then complex numbers are C -> R
22:28:48 <elliott> OK, edwardk has to come up with a name for Tralign.
22:28:59 <elliott> Tralign is like Traversable except it uses Align rather than Applicative.
22:29:03 <cmccann> yeah I couldn't think of anything good
22:29:10 <zzo38> But about dependent sums, what are other examples of dependent sum in Haskell and why is it called a dependent sum?
22:29:15 <edwardk> or when you realize that that is a representation of a representable functor, data Complex a = Complex a a
22:29:31 <elliott> e.g. getZipList $ sequenceAlign [ZipList [1], ZipList [1,2]] --> [[1,1],[2]]
22:29:44 <elliott> (whereas getZipList $ sequenceA [ZipList [1], ZipList [1,2]] --> [[1,1]])
22:30:18 <edwardk> one of my coworkers very much loves the whole alignable concept. i confess i mostly give him crap about it rather than provide constructive results ;)
22:30:36 <cmccann> I think that's where this is all coming from anyway
22:30:43 <cmccann> via SO
22:30:55 <elliott> yeah, http://stackoverflow.com/a/9199185/1097181 -> http://pchiusano.blogspot.com/2010/06/alignable-functors-typeclass-for-zippy.html
22:31:12 <edwardk> yep
22:31:13 <edwardk> thats him
22:31:16 <cmccann> which inspired elliott to ask about adding that to my these package
22:31:21 <elliott> who cares if it's a good concept? it lets us write lots of instances
22:31:25 <ion> http://www.haskell.org/hoogle/?hoogle=alignable
22:31:30 <elliott> and make the package bigger and have lots of laws and haddocks
22:31:34 <cmccann> yes
22:31:48 <elliott> so that people know it's serious theory
22:31:53 <edwardk> sadly it is _useful_
22:31:59 <cmccann> oh dear
22:32:08 <elliott> edwardk: Yes, it is: If your functor is actually a functor from Kleisli Maybe to Hask (so it supports maybeFmap :: (a -> Maybe b) -> f a -> f b), then an Align instance is making your functor lax monoidal w.r.t. the cartesian monoidal structure on Kleisli Maybe, because These is the cartesian product in that category (a -> Maybe (These b c) ~ (a -> Maybe b, a -> Maybe c)).
22:32:14 <cmccann> we can let that slide if we dress it up with enough category theory I think
22:32:17 <elliott> (What's the problem?)
22:32:22 <cmccann> haha
22:32:26 <elliott> I think we'll have to start paying rwbarton royalties for that one.
22:32:34 <edwardk> hah
22:32:58 <edwardk> thats actually completely coherent
22:33:03 <cmccann> well yeah
22:33:08 <elliott> Why wouldn't it be?!
22:33:12 <elliott> We're real Haskell programmers.
22:33:16 <cmccann> and it actually makes a lot of sense
22:33:36 <edwardk> wait
22:33:41 <elliott> Anyway, edwardk can't possibly come up with a name worse than Traversalignable or Alignaversable.
22:33:43 <elliott> I hope.
22:33:58 <edwardk> Tralignable?
22:34:06 <ivanm> TrainLineAble
22:34:31 <elliott> edwardk: Tralign is what I have now :P
22:34:49 <edwardk> dangerous. sounds like there might be a graph involved. then ivanm will badger you with questions about it ;)
22:34:51 <elliott> If I don't get something better than that it'll become Trainline.
22:35:05 <edwardk> hah
22:35:12 <elliott> class Railway t where ...
22:35:29 <ion> instance Transport Tycoon
22:36:06 <edwardk> i've got nothing
22:36:15 <edwardk> thats part of why i never like this type =P
22:36:18 * cmccann considers something like "Crosswalk"
22:36:21 <elliott> hahaha
22:36:46 <elliott> cmccann: cross makes me think cross-section
22:37:13 <cmccann> well, the whole traversable thing is kind of going sideways through stuff
22:37:15 <cmccann> I dunno
22:37:30 <cmccann> Traversable is a crappy name to begin with anyway
22:37:35 <elliott> "walk" is good, though
22:37:44 <elliott> aligned walk...
22:37:45 <elliott> whoa
22:37:46 <cmccann> yeah I like that
22:37:48 <elliott> trains do aligned walks through tracks
22:37:52 <cmccann> heh
22:37:55 <elliott> Trainline!
22:38:07 <elliott> maybe just Walk :P
22:38:31 <cmccann> Walk sounds a little too open-ended but I think it's the right idea
22:38:50 <elliott> Walkthrough?
22:39:03 <elliott> Crosswalk or AlignWalk are pretty good, really
22:39:11 <cmccann> then again after This, That, and These I probably have no room to complain
22:40:05 <cmccann> AlignWalk is kinda clumsy-sounding
22:40:09 <cmccann> but I like the idea
22:40:22 <edwardk> you kind of want something that indicates the sort of hand over hand nature of traversing it, but i haven't got anything
22:40:37 <elliott> edwardk: "hand over hand" sounds like crossing to me
22:40:53 <cmccann> yeah I'm still not getting anything better than Crosswalk
22:41:06 <elliott> crosswalk is decent; it provides a nice name for the traverse-equivalent operator, too
22:41:19 <elliott> sequenceAlign retains its bad name, though :P
22:41:24 <cmccann> I'd consider something about ladders earlier for the hand-over-hand aspect but that always ended up sounding misleading to me
22:41:45 <cmccann> yeah sequence is a standard name there so better to stick with it
22:42:03 <edwardk> Ascendable/Climbable/Surmountable? =)
22:42:23 <cmccann> edwardk, all ends up sounding too much like an unfold or something that generates data
22:42:29 <elliott> cmccann: yeah, sequenceAlign is just so long :P
22:42:29 <edwardk> yeah
22:42:33 <elliott> can't do sequenceA since A = Applicative
22:42:36 <elliott> sequenceL?
22:42:38 <elliott> aLign
22:42:48 <cmccann> could be worse
22:42:50 <elliott> you're Lining them up :P
22:42:56 <cmccann> ok
22:43:03 <cmccann> I'm satisfied
22:43:21 <elliott> weren't you going to bed like an hour ago?
22:43:27 <cmccann> yes except
22:43:29 <edwardk> sleep is overrated
22:43:29 <cmccann> instances
22:43:31 <cmccann> and silly names
22:43:45 <cmccann> but yeah I really should get some sleep :?
22:44:08 <elliott> when you wake up, do not be alarmed if your package has 20 dependencies and 1,000 more lines of source code
22:44:10 <elliott> it'll just be the instances
22:44:13 <cmccann> :D :D :D
22:45:01 <cmccann> elliott, soon you'll have three hundred packages and a script that pushes to hackage everytime you look at a file
22:45:13 <cmccann> that seems to be where this path leads
22:45:21 <elliott> hmm, alignWith could be called liftL2... that's kinda silly though
22:45:27 <elliott> cmccann: haha
22:45:29 <elliott> atime-based hackage uploads
22:46:11 <cmccann> speaking of which this probably qualifies as worthwhile enough to put on hackage by now, with the align stuff in there
22:46:39 <cmccann> I never got around to getting myself a hackage account but I know you have one since you uploaded a remarkably useful package a bit ago
22:47:10 <elliott> haha
22:47:12 <ion> Data.Crosswalk.crossdress
22:47:21 <elliott> hmm, now I actually have to describe crosswalk
22:47:23 <elliott> and come up with laws
22:47:24 <elliott> oh dear
22:47:35 <cmccann> haha
22:47:42 <matthiasgorgens> @pl \a f fail ->  a fail . f fail
22:47:42 <lambdabot> liftM2 (.)
22:47:44 <companion_cube> System.Ministry.SilliWalk
22:47:51 <companion_cube> Silly*
22:48:23 <elliott> does traverse have laws?
22:48:25 <elliott> no, of course not
22:48:53 <matthiasgorgens> @pl     return result fail succeed input = suceed result input
22:48:53 <lambdabot> return = const . const . suceed
22:48:54 <cmccann> it should have some
22:48:58 <matthiasgorgens> +c.
22:49:05 <cmccann> though possibly only trivial ones implied by parametricity
22:49:06 <elliott> cmccann: it has none in the class documentation
22:49:18 <matthiasgorgens> @pl    return result fail succeed input = succeed result input
22:49:18 <lambdabot> return = const . flip id
22:49:34 <edwardk> elliott: now its almost exactly like one of my packages ;)
22:49:44 <elliott> edwardk: no, i'm writing documentation
22:49:47 <cmccann> haha
22:50:09 <edwardk> so am i. just not typically at the rate i generate new packages
22:50:18 <elliott> haha
22:50:39 <elliott> actually, Data.Align reminds me of your packages for some reason
22:50:50 <ion> @remember elliott <edwardk> elliott: now its almost exactly like one of my packages ;)  <elliott> edwardk: no, i'm writing documentation
22:50:50 <lambdabot> Okay.
22:50:55 <elliott> I think it's the "superior variant on some standard typeclass" thing :P
22:51:02 <elliott> *of
22:51:23 <elliott> "Structures structureUnzipping for structures of non-uniform shapes." -- current Crosswalk description
22:51:44 <cmccann> I think as a matter of policy classes that don't define laws should declare that by with a line saying "instances of the class Foo should obey the following laws: I AM THE LAW"
22:51:59 <elliott> :D
22:52:09 <edwardk> do you have zippable in there?
22:52:16 <elliott> currently Crosswalk has one law
22:52:17 <elliott>  crosswalk f = sequenceL . fmap f
22:52:31 <elliott> edwardk: no, it's not really related to These after all
22:52:35 <elliott> edwardk: don't you have that in one of your packages?
22:52:44 <edwardk> i mean the instance
22:52:49 <elliott> ah
22:52:52 <edwardk> its in keys
22:53:13 <elliott> no, I think I saw it but decided not to depend on that whole package for the single instance :P
22:53:19 <edwardk> bah =P
22:53:40 <edwardk> that is one instance that needs to become its own package since its the only thing in there that doesn't need type families
22:53:48 <edwardk> but i haven't been willing to break up that module
22:53:48 <elliott> edwardk: so, and I will regret asking this, but what's all that reducers stuff about
22:53:50 <edwardk> too much pain
22:54:05 <elliott> I hear Align lets me do stuff with them.
22:54:22 <edwardk> take a look at http://hackage.haskell.org/packages/archive/reducers/0.1.7/doc/html/Data-Semigroup-Reducer.html
22:54:44 <elliott> I did :P
22:54:47 <edwardk> a reducer is a semigroup m with the ability to inject values. unit :: c -> m
22:54:59 <edwardk> snoc and cons are just optimized versions combined with <>
22:55:10 <elliott> mostly I'm wondering what they're actually used for
22:55:17 <cmccann> reducing things?
22:55:19 <edwardk> http://hackage.haskell.org/packages/archive/reducers/0.1.7/doc/html/Data-Semigroup-Generator.html
22:55:37 <elliott> edwardk: ah, I see
22:55:39 <edwardk> provides a 'source' of values, and reducers provide a way to tear them down
22:55:48 <elliott> edwardk: so e.g. it's sort of like foldMap
22:55:54 <edwardk> exactly
22:55:59 <elliott> right
22:56:07 <elliott> ok, that makes sense
22:56:11 <edwardk> but since it incorporates the embedding you can usually say one thing fewer
22:56:33 <elliott> apparently I can lift Reducers to an Align f
22:56:44 <elliott> so I guess I'll do that now :P
22:56:47 <edwardk> http://hackage.haskell.org/packages/archive/reducers/0.1.7/doc/html/Data-Generator-Combinators.html gives a bunch of examples. look at the code for that module
22:56:53 <elliott> ok; thanks
22:57:25 <edwardk> but Foldables are always able to be made into Generators
22:57:32 <edwardk> but things like ByteStrings are also generators
22:57:42 <edwardk> think 'monomorphic foldable'
22:57:49 <elliott> (the problem with Traversable is that traverse is the more useful form but laws and instances are nicer as sequenceA :( )
22:57:58 <elliott> (weird to have Crosswalk laws in terms of sequenceL)
22:58:18 <edwardk> well
22:58:32 <edwardk> with distributive there is the clear dual notion to traverse
22:58:45 <edwardk> but its less useful than another notion which does the fmap in the wrong place
22:59:06 <edwardk> so i'm not surprised you feel the need to shuffle it around
22:59:19 <elliott> haha
22:59:56 <elliott> crosswalk (uncurry align) :: (Align f, Crosswalk t) => t (f a, f b) -> f (t (These a b))
23:00:09 <elliott> that looks like an incredibly useful operation. I have no idea what it does, though
23:01:34 <cmccann> "this is possible and sounds useful but I'm not sure where" has been the main motivation behind these from the begining
23:01:43 <cmccann> so I'd say that's perfectly reasonable
23:01:52 <cmccann> :P
23:03:15 <edwardk> hah
23:03:43 <cmccann> also, naming the package "these" is proving to be an incredible boon for constructing confusing sentences
23:03:53 <cmccann> that alone might make the whole thing worthwhile
23:04:51 <elliott> would you say that Traversable structures can be traversed "through" an Applicative?
23:04:59 <elliott> or "in" an Applicative? or "by" an Applicative?
23:05:00 <hpaste> “Matthias Goergens” pasted “Monadic Parsing” at http://hpaste.org/57662
23:05:11 <matthiasgorgens> how do I make the compiler happy with that paste?
23:05:20 <elliott> cmccann: we need to make sure she is combined with these things at some point
23:05:26 <matthiasgorgens> Is it possible to avoid a newtype declaration?
23:05:30 <cmccann> hahaha oh dear
23:05:33 <elliott> matthiasgorgens: make a newtype instead
23:05:48 <elliott> even if that did work, it'd fail because your instance is overlapping with the ((->) r) monad
23:05:59 <edwardk> elliott: i would say its a distributive law =P
23:06:13 <elliott> edwardk: trying to write haddocks here!!! :P
23:06:34 <cmccann> well, "distributes over" seems intelligible to me
23:06:34 <matthiasgorgens> elliott, that'll make all my combinators ugly..  Ok, if I have too.
23:07:08 <matthiasgorgens> thanks.
23:07:31 <elliott> cmccann: I'm trying to complete the sentence "Functors supporting traversal [???] an alignable functor."
23:07:31 <cmccann> and if anything I'd phrase it as the Applicative going "through" the Traversable
23:07:33 <zzo38> Why are dependent sum types called dependent sum types anyways?
23:07:59 <elliott> cmccann: e.g. Functors supporting traversal in an alignable functor.
23:08:03 <elliott> Functors supporting traversal through an alignable functor.
23:08:23 <cmccann> ah
23:09:08 <cmccann> hm
23:09:32 <cmccann> perhaps "into"?
23:10:05 <elliott> hmm, perhaps
23:10:09 <cmccann> the functors swapping places is what you're really trying to express here
23:10:15 <elliott> yay, Crosswalk (These a) instance written
23:10:21 <elliott> feels like the package has come full circle
23:10:28 <cmccann> :D
23:11:09 <elliott> hmm
23:11:13 <elliott> there's Bitraversable
23:11:18 <elliott> are you thinking what I'm thinking???
23:11:54 <cmccann> hmm yes
23:11:58 <cmccann> this sounds promising
23:12:37 <elliott> Bicrosswalk!
23:13:25 * cmccann refrains from suggesting puns on "doublecross"
23:13:39 * hackagebot msgpack 0.7.1 - A Haskell implementation of MessagePack  http://hackage.haskell.org/package/msgpack-0.7.1 (HideyukiTanaka)
23:13:41 * hackagebot ghc-mod 1.10.2 - Happy Haskell programming on Emacs  http://hackage.haskell.org/package/ghc-mod-1.10.2 (KazuYamamoto)
23:13:43 <elliott> excellent refraining
23:13:43 * hackagebot msgpack-rpc 0.7.0 - A MessagePack-RPC Implementation  http://hackage.haskell.org/package/msgpack-rpc-0.7.0 (HideyukiTanaka)
23:13:49 <cmccann> yes
23:13:57 <cmccann> I am an excellent refrainer
23:14:11 <elliott> class (Bifunctor t, Bifoldable t) => Bicrosswalk t where
23:14:11 <elliott>     bicrosswalk :: (Align f) => (a -> f c) -> (b -> f d) -> t a b -> f (t c d)
23:14:39 <elliott> I don't really have any intelligent commentary left at this point.
23:14:54 <cmccann> well it's pretty self-explanatory really
23:15:03 <elliott> hmm, is Maybe a Crosswalk?
23:15:13 <elliott> crosswalk f Nothing = empty feels wrong
23:16:03 <cmccann> hm
23:16:12 <cmccann> it sort of makes sense
23:16:14 <elliott> compare, e.g.
23:16:16 <elliott> *Data.Align> Data.Traversable.traverse id (Just (return 42)) :: [Maybe Int]
23:16:16 <elliott> [Just 42]
23:16:16 <elliott> *Data.Align> Data.Traversable.traverse id Nothing :: [Maybe Int]
23:16:16 <elliott> [Nothing]
23:16:35 <elliott> then again the (These a) instance does the exact same thing
23:16:42 <elliott> and crosswalk f [] is obviously empty
23:16:47 <elliott> so it seems like empty _does_ replace the base case in some manner
23:17:06 <elliott> I mean
23:17:06 <cmccann> empty replaces pure/return
23:17:10 <elliott> const Nothing <$> empty
23:17:11 <cmccann> which I think is the significant point
23:17:14 <elliott> is the obvious RHS
23:17:15 <elliott> which is = empty
23:17:19 <elliott> so yeah
23:17:37 <elliott> crosswalk f = maybe (const Nothing <$> empty) (\a -> Just <$> f a)
23:17:43 <elliott> --> maybe empty (fmap Just . f)
23:17:57 <cmccann> sounds good
23:18:39 * hackagebot msgpack 0.7.1.1 - A Haskell implementation of MessagePack  http://hackage.haskell.org/package/msgpack-0.7.1.1 (HideyukiTanaka)
23:18:51 <elliott> ok, it's Bicrosswalk time
23:19:16 <cmccann> also time for me to actually sleep for reals
23:19:29 <cmccann> so have fun :P
23:19:29 <elliott> yeah, I wouldn't stay around for whatever becomes of this thing either
23:19:49 <cmccann> I expect to wake up and find at least a dozen new instances
23:19:53 <cmccann> if not more
23:20:09 <elliott> more like a trillion
23:20:18 <elliott> Triprocrosswalkegory
23:20:19 <alang_> Having trouble linking packages that use hmatrix, getting errors of the type "undefined reference to `cblas_*'". Any suggestions?
23:20:20 <elliott> -able
23:20:49 <elliott> awww, (,) isn't a Bicrosswalk
23:20:52 <elliott> needs a Monoid constraint
23:20:56 <cmccann> :[
23:21:11 <cmccann> that's okay, I'm sure you'll find plenty of other instances
23:21:15 <cmccann> anyway
23:21:18 <cmccann> I'm out
23:21:43 <elliott> ok, wait.
23:21:47 <elliott> cmccann: you need to see this one last thing:
23:21:49 <cmccann> argh
23:21:50 <cmccann> ok
23:22:01 <hpaste> elliott pasted “insatnce Bicrosswalk These” at http://hpaste.org/57665
23:22:11 <cmccann> insatnces, ok
23:22:24 <cmccann> ahahahahaha
23:22:24 <elliott> i think i just defined a class
23:22:25 <cmccann> yes
23:22:27 <elliott> for which the only possible instance is These
23:22:28 <cmccann> beautiful
23:22:36 <elliott> ok go to bed
23:22:41 <cmccann> hahaha
23:22:45 <cmccann> right
23:23:39 * hackagebot MFlow 0.0.4 - Web application server with stateful, type safe user interactions and widget combinators.  http://hackage.haskell.org/package/MFlow-0.0.4 (AlbertoCorona)
23:25:47 <zzo38> Can anyone please answer either of my questions, about extensible products, or the one about dependent sums?
23:31:15 <zzo38> Does nobody know the answer to my questions?
23:31:22 <zzo38> (Including this one?)
23:32:04 <elliott> @tell cmccann class (Bifunctor f) => Bialign f where { biempty :: f a b; bialign :: f a b -> f c d -> f (These a c) (These b d); bialignWith :: (These a b -> e) -> (These c d -> f') -> f a b -> f c d -> f e f' }
23:32:05 <lambdabot> Consider it noted.
23:33:39 * hackagebot msgpack 0.7.1.2 - A Haskell implementation of MessagePack  http://hackage.haskell.org/package/msgpack-0.7.1.2 (HideyukiTanaka)
23:34:33 <hpaste> “Matthias Goergens” pasted “Monadic Parsing, again” at http://hpaste.org/57666
23:35:04 <matthiasgorgens> how can I get around the "Parsing.hs:19:21: Not in scope: type variable `a'" error?
23:35:17 <matthiasgorgens> a forall should do it, but the compiler complains about that too.
23:35:40 <elliott> matthiasgorgens: Parser (forall a. ...)
23:35:50 <elliott> If it complains, you did not turn on the appropriate extension.
23:35:53 <elliott> forall is not standard Haskell.
23:37:41 <matthiasgorgens> I tried turning on ExistentialQuantifications.
23:37:46 <matthiasgorgens> Oh, I switched to record syntax.
23:37:50 <elliott> matthiasgorgens: No.
23:37:55 <elliott> You don't want ExistentialQuantification.
23:37:59 <matthiasgorgens> And now the compiler tells me that I need rankNtypes.
23:38:00 <matthiasgorgens> and that worked.
23:38:13 <elliott> The forall has to be inside the field, not the constructor.
23:38:15 <matthiasgorgens> oh, and RankNTypes was enough.
23:38:23 <matthiasgorgens> no existentialquantifications necessary.
23:38:31 <matthiasgorgens> newtype Parser result = Parser
23:38:31 <matthiasgorgens>     { getParser :: forall a .
23:38:31 <matthiasgorgens>       (ParseError -> a) -- failure continuation
23:38:31 <matthiasgorgens>       -> (result -> Input -> a) -- success continuation
23:38:31 <matthiasgorgens>       -> Input
23:38:31 <matthiasgorgens>       -> a -- result
23:38:32 <matthiasgorgens>     }
23:38:45 <matthiasgorgens> works with
23:38:46 <matthiasgorgens> {-# Language RankNTypes #-}
23:39:15 <matthiasgorgens> (Sorry for the spam, but I think since nobody's really busy here, it wasn't worth it using hpaste.)
23:44:44 <Peaker> zzo38: what are your questions?
23:45:50 <zzo38> Peaker: [1] Best way to make extensible product types so that you can add fields even in different modules? [2] What are other example of dependent sum and why is it called that?
23:46:10 <zzo38> [3] Do you like this question?
23:47:21 <Peaker> zzo38: I don't understand (1) -- given an open world assumption -- how does a value of this product can even exist?
23:47:40 <matthiasgorgens> @pl let helper fail succeed = (getParser a) fail $ \result -> getParser (f result) fail succeed
23:47:40 <lambdabot> (line 1, column 92):
23:47:40 <lambdabot> unexpected end of input
23:47:40 <lambdabot> expecting variable, "(", operator, "$", "$!", "`seq`", ";" or "in"
23:47:44 <matthiasgorgens> @let helper fail succeed = (getParser a) fail $ \result -> getParser (f result) fail succeed
23:47:45 <lambdabot>  <local>:2:23: Not in scope: `getParser'
23:47:45 <lambdabot>  
23:47:45 <lambdabot>  <local>:2:54: Not in scope: `getP...
23:47:48 <matthiasgorgens> @pl helper fail succeed = (getParser a) fail $ \result -> getParser (f result) fail succeed
23:47:49 <lambdabot> helper = ap ((.) . getParser a) (flip . flip (getParser . f))
23:47:55 <matthiasgorgens> better not.
23:47:59 <zzo38> Peaker: You should need defaults values, I think. I did make an implementation but am unsure if it is best way
23:48:32 <elliott> hey, Align gives rise to the "lift a binary function on Maybe where it uses one of the arguments if the other is Nothing" behaviour people keep wanting!
23:49:07 <elliott> liftL2 op, where liftL2 f = alignWith (these id id f)
23:49:10 <elliott> cool
23:49:55 <matthiasgorgens> @pl     return result = Parser $ const ($ result)
23:49:55 <lambdabot> return = Parser . const . flip id
23:50:10 <zzo38> Peaker: Do you know the second question though?
23:52:27 <Blkt> good morning everyone
23:52:35 <Peaker> zzo38: not a DT expert.. not sure what a dependent sum is
23:53:53 <zzo38> Peaker: I found a "dependent-sum" package for Haskell, on Hackage, it gives a simple example. I also read a few things on Wikipedia but it doesn't explain everything either.    data DSum tag = forall a. tag a :=> a;    is how they define it in that package
23:54:46 <Peaker> zzo38: the wiki also confuses me -- they say "dependent sum" but then the example is a pair/product...
23:55:06 <zzo38> Peaker: Yes that confused me too
23:55:07 <Peaker> maybe it means:  (T, x:T) ?
23:55:14 <Peaker> though not sure why that's a "sum"
23:55:28 <Peaker> maybe because it sums all possible 'x's from all possible T's?
23:55:39 <Peaker> yeah that must be it :)
23:56:00 <elliott> hmm, is there a standard typeclass for functors f that can do f (Maybe a) -> f a, where the Nothings are "discarded"?
23:56:14 <elliott> e.g. branches of a tree with Nothing will be removed, [Just 3, Nothing, Just 4] -> [3, 4]
23:56:26 <elliott> for f = Maybe it's join
23:56:27 <zzo38> There is an example using a GADT:    data Tag a where { AnInt :: Tag Int; AString :: Tag String; };   but I realize the tag could be a GADT having parameters and/or constraints, or it could be a functor, or contrafunctor, or a datatype family, but I don't know if these are really what a dependent sum is supposed to be.
23:56:51 <Peaker> elliott: there's mzero/empty
23:57:10 <zzo38> elliott: I think it is MonadPlus:  (>>= maybe mzero return)
23:57:50 <elliott> MonadPlus is way way wayyy too much in this case
23:58:10 <elliott> Peaker: yeah, not quite enough though
23:58:13 <elliott> (and Applicative is too strong)
23:58:18 <Peaker> zzo38: having the type of the sum depend on which value it is -- makes sense why that's a "dependent sum" I guess...  (SomeType, (x:SomeType)) is a generalization of this
23:58:19 <zzo38> Yes but it is there
23:58:23 <elliott> there's no need to be able to combine two values necessarily
23:58:26 <elliott> just discard parts of the structure
23:58:55 <elliott> oh well, I bet edwardk has it somewhere :P
23:59:08 <Peaker> elliott: what are you some example instances of your method?
