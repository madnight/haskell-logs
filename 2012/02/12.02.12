00:04:40 <wavewave> that rendering problem is solved!
00:05:00 <wavewave> hxournal has a true pressure sensitivity support.
00:06:08 * ddarius thinks his poppler is too old to build the version of Gtk2hs that hxournal wants or that cabal thinks he should have.
00:06:31 <ddarius> I can probably build without that support though...
00:06:34 <wavewave> ddarius : poppler has some problem.
00:06:46 <wavewave> just build without it..
00:06:57 <wavewave> use -f-poppler option.
00:07:10 <wavewave> cabal configure -f-poppler
00:07:29 <wavewave> you need to unpack packages first.
00:08:48 <wavewave> now hxournal is much superior than xournal in pressure sensitivity support.. hehe.
00:09:38 <wavewave> original xournal implementation is just changing line width following pressure..
00:10:29 <wavewave> hxournal is calculating contour for it. This means I can use arbitrary pen tip then that will give very different caligraphic feeling.
00:11:33 <wavewave> of course, this pen feeling can be easily parameterized by higher order function.
00:14:29 <wavewave> so happy :-D
00:15:19 <scolobb> wavewave: Congratulations :-)
00:16:00 <wavewave> thnx ;-)
00:42:14 <osa1__> how can I implement a Functor instance for this type: data ITree a = Leaf (Int -> a) | Node [ITree a] ?
00:42:19 * hackagebot uri-conduit 0.2.1.1 - Read and write URIs  http://hackage.haskell.org/package/uri-conduit-0.2.1.1 (MichaelSnoyman)
00:43:16 <ddarius> fmap f (Leaf x) = Leaf (fmap f x); fmap f (Node xs) = Node (fmap (fmap f) xs)
00:47:19 * hackagebot conduit 0.2.1 - Streaming data processing library.  http://hackage.haskell.org/package/conduit-0.2.1 (MichaelSnoyman)
00:48:09 <Jafet> That's a lot of fmaps
00:48:38 <Jafet> Four fmaps
00:51:05 <c_wraith> ddarius: huh? I was pretty sure that Type doesn't have a functor instance
00:51:32 <c_wraith> the Leaf constructor is contravariant
00:52:09 <c_wraith> oh.  no it's not.  nevermind
00:52:23 * c_wraith is too tired to tell the difference between odd and even.  time for sleep, I think
00:54:25 <ddarius> wavewave: Are most of the menu options supposed to be grayed out?  Also it seems to be having trouble finding the icons?
00:54:37 <ddarius> (This is 0.6.4.3 for reference.)
01:03:27 <ddarius> wavewave: Disregard the icons thing.
01:03:44 <SmartViking> Is [1 ..] syntactic sugar?
01:05:22 <ddarius> SmartViking: Yes.
01:05:33 <MaskRay> desugars to `enumFrom 1'
01:06:30 <MaskRay> analogs are enumFromThem enumFromTo enumFromThenTo
01:07:28 <SmartViking> Ah ok
01:10:32 <ddarius> wavewave: Minor issue: If I go to eraser, change the color (via the icons) and then go back to the pen, it will be one whatever color the pen was previously (or really this happens generally.)
01:13:25 <ddarius> wavewave: Overall though, it seems reasonably nice so far.
01:14:32 <wavewave> ddarius: yes. I noticed that bug.. will be fixed soon. thanks for your feedback!
01:16:57 <wavewave> the ui components are not yet synchronized well overally.
01:26:47 <kuznero> Hi All!
01:30:30 <hpaste> Kuznero pasted ‚ÄúHow to optimize case parser of‚Äù at http://hpaste.org/63531
01:30:53 <kuznero> Can anyone please have a look into this small issue I have?
01:31:13 <neutrino> hi guys i am having problems adding error detection to this function, when i add "error" and try to run this program then ghc hangs
01:31:52 <hpaste> neutrino pasted ‚Äúerror hangs up ghc‚Äù at http://hpaste.org/63532
01:32:24 <wavewave> ddarius : please report some issues : http://groups.google.com/group/hxournal
01:32:47 <neutrino> the function is called "aggregateCost" and you can see i have two variables defined with alternatives (timeCostPairs/timeCostPairs2, out/out2), if i use the second one then the thing just doesn't want to finish compiling
01:32:54 <neutrino> why is that so?
01:33:04 <neutrino> how can i make this thing work better?
01:33:15 <wavewave> ddarius : hope that this tool is useful for you :-)
01:38:01 <kuznero> I need to optimize: case (fp :: GenParser Char ParserState String) of Just f -> notFollowedBy' f; Nothing -> return ()
01:38:13 <kuznero> into something like: fmap notFollowedBy' fp
01:38:36 <kuznero> Is there any way I can do this somehow?
01:41:18 <ddarius> maybe (return ()) notFollowedBy' fp
01:42:30 <kuznero> ddarius: thanks - seems to be much more clear
01:43:54 <neutrino> no takers on ghc hanging up? :p
01:44:19 <ddarius> neutrino: Cut it down to a smaller example that still exhibits the problem.
01:44:53 <Rc43> Hi, guys.
01:45:02 <Rc43> Look at it http://hackage.haskell.org/packages/archive/Thrift/0.6.0/doc/html/src/Thrift-Server.html#runBasicServer
01:45:10 <Rc43> runBasicServer takes a PortNumber
01:45:13 <Rc43> which is
01:45:23 <Rc43> defined here http://hackage.haskell.org/packages/archive/network/latest/doc/html/src/Network-Socket-Internal.html#PortNumber
01:45:45 <Rc43> Why I can give just Int as an argument?
01:45:56 <Rc43> It is auto-cast or something?
01:46:08 <neutrino> actually
01:46:17 <neutrino> i get it to compile but it doesn't *execute*
01:46:21 <Rc43> According to `newtype` I must use PortNum 12312, right?
01:46:38 <ddarius> Rc43: No.
01:46:54 <neutrino> why would something compile but never finish executing? how can i figure out what a haskell program is doing?
01:47:32 <neutrino> Rc43: isomorphic types take literals of the types they're isomorphic to... or something.
01:47:38 <ddarius> neutrino: Noe.
01:47:49 <neutrino> no? ok explain this to me then
01:48:17 <yezariaely> cabal install array returns Data/Array/IArray.hs:1:13: Unsupported extension: Trustworthy
01:48:18 <ddarius> Numeric literals are overloaded and can be a value of anything in Num.  PortNumber is in Num.
01:48:19 <Rc43> neutrino, what you have talked about is a type, or not?
01:48:22 <yezariaely> anyone can help me with that?
01:48:27 <neutrino> ddarius: oh
01:48:46 <neutrino> Rc43: never mind that, ddarius's explanation is valid, mine wasn't
01:50:58 <Rc43> ddarius, why we can't use `type` without constructor (`PortNum`) ?
01:51:49 <ddarius> The fromInteger definition does endianness conversion, I believe.
01:52:24 <Rc43> ddarius, am I right that `newtype X = Constructor Y` declares that X is equal to Y?
01:52:41 <neutrino> ddarius: i'm trying to find a minimal case but i'm failing, maybe we can figure it out some other way?
01:52:54 <neutrino> ddarius: let's talk about the error function
01:52:54 <ddarius> Rc43: No.  They are isomorphic but distinct.
01:53:18 <neutrino> if i want to use the error function, it needs to be inside a function of value * -> IO a, right?
01:53:24 <ddarius> neutrino: You have an infinite loop somewhere in your code (or perhaps your code is horribly inefficient) find it and fix it.
01:53:43 <neutrino> no it's efficient, this happens only when i add this error handler.
01:53:53 <neutrino> and there is no infinite loop otherwise that i know of
01:53:58 <`Jake`> via /msg NickServ koenigx3
01:54:05 <`Jake`> oops
01:54:10 <Rc43> ddarius, so where conversion is declared? PortNumber isn't instance of Num.
01:54:23 <`Jake`> taht was stupid
01:54:58 <neutrino> ddarius: let's say there's an infinite loop somewhere, how can i find out what functions the program is looping through?
01:55:09 <ddarius> Rc43: How do you know that?
01:56:26 <ddarius> @google site:haskell.org/ghc "-xc"
01:56:27 <lambdabot> http://www.haskell.org/ghc/docs/7.0.1/html/users_guide/runtime-control.html
01:56:27 <lambdabot> Title: 4.16.ÔøΩRunning a compiled program
01:56:29 <Rc43> ddarius, there is only one instance in source file and no import with name related to port
01:56:55 <yezariaely> `Jake`: http://docs.dal.net/docs/nickserv.html#6.1
01:56:57 <neutrino> i guess good old printf debugging
01:56:58 <ddarius> Rc43: You need to check every single module your program imports (transitively) to verify whether or not an instance is in scope.
01:57:34 <ddarius> Rc43: Or more simply, you can do :info PortNumber in GHCi and it will tell you that PortNumber is an instance of Enum, Eq, Ord, Integral, Num, Ord, Real, Show
01:57:35 <`Jake`> Thanks, I've already done it ;-)
01:57:44 <yezariaely> hehe
01:57:52 <neutrino> ddarius: thanks a lot
01:59:12 <neutrino> hmm, i get an error that there are no profiling libraries for gnuplot :/
01:59:24 <neutrino> i need to start breaking up this program, it's getting unwieldy.
01:59:36 <Rc43> ddarius, yes, it is true, thanks
01:59:40 <Rc43> > instance Num PortNumber -- Defined in Network.Socket
01:59:41 <lambdabot>   <no location info>: parse error on input `instance'
02:01:08 <yezariaely> cabal install array does not work for me, any suggestions? (Data/Array/IArray.hs:1:13: Unsupported extension: Trustworthy)
02:01:32 <Rc43> ddarius, also, why haskell automatically uses fromInt? it is "hardcoded" thing?
02:02:52 <ddarius> There is no fromInt.  fromInteger or fromRational are used on numeric literals as defined by the Report.  The latter is used for numerals of the form 4.6 or such.
02:03:40 <Rc43> ok, thanks, now it is clear
02:04:56 <MaskRay> yezariaely: Safe Haskell. you may need 7.4
02:05:19 <yezariaely> MaskRay: ah sure, thanks for the hint!
02:10:24 <neutrino> hey ddarius, instead of using "error "aaa"" i used "seq (putStrLn "bbb") someValue" and it's hanging up as well
02:10:39 <neutrino> can it be that the function i am in currently breaks if i try to do any sort of IO?
02:12:26 <neutrino> oh man, this is so stupid
02:12:47 <neutrino> now i know what the problem is! i'm comparing the length of infinite lists V_V
02:13:17 <neutrino> why doesn't haskell just say "infinity" :||||||
02:14:03 <ceii> neutrino: because Haskell's Ints are hardware integers, they don't have an infinity value
02:14:49 <hpaste> Kuznero pasted ‚ÄúParsing across multiple lines until several newlines‚Äù at http://hpaste.org/63533
02:14:57 <ceii> well, beside that, being able to recognize an infinite list for sure would allow you to solve the halting problem...
02:15:14 <kuznero> Gents, please have a look... I'm going crazy with this one already
02:15:59 <neutrino> ceii: well i'm doing "repeat 1", that's sure to be recognizable
02:16:20 <neutrino> giving up for all cases when only some cases are unsolvable is less than what i came to expect :|||
02:17:06 <ceii> neutrino: well, assume length (repeat 1) returned Infinity
02:17:34 <ceii> it'd then have to print Infinity for every infinite list of ones, no matter how it's generated
02:17:40 <ceii> they're all equal, after all
02:20:18 <neutrino> no that would just mean sometimes you'd be able to prove its length is infinity and sometimes you'd be stuck in an infinite loop
02:20:48 <neutrino> there's nothing wrong with doing your job faster at some times and slower at other times
02:20:59 <neutrino> especially if "slower" means "never getting it done"
02:21:59 <Axman6> neutrino: haskell has no introspection, so length just knows it's been given a list, not what produced the list
02:22:48 <Jafet> Whoever is advertising Haskell to the public should remove the statement that it has dwim.
02:23:06 <ceii> also, for better or worse, the usual semantics of Haskell consider non-termination to be a distinct value
02:23:21 <neutrino> yea Axman6, not nice
02:23:26 <Jafet> Oh wait, the people who say Haskell has dwim are the ones who think it has dwim.
02:23:36 <neutrino> what is dwim
02:23:42 <ceii> so 1 == seq (very_long_computation) 1 but 1 /= very_long_computation
02:24:01 <neutrino> ceii: i have no idea what that just proved
02:24:17 <ceii> that wasn't a proof
02:24:49 <neutrino> why have you brought that up
02:24:50 <ceii> I was just trying to illustrate that, semantically speaking, all that matter is that something eventually, theoretically returns a value
02:25:08 <kuznero> Parsec gurus, please help ... http://hpaste.org/63533
02:25:15 <neutrino> and why did you want to bring that up
02:25:24 <neutrino> i think you're arguing past me
02:25:40 <ceii> I might be, sorry
02:25:41 <neutrino> anyways: practical question
02:25:41 <Axman6> neutrino: what would you like length (repeat 1) to return?
02:25:55 <Axman6> there is no Int whose value makes sense
02:26:04 <neutrino> Axman6: i would like there to be a function which can tell that repeat 1 is infinity-long.
02:26:15 <Axman6> good luck with that
02:26:22 <neutrino> Axman6: then make it an algebraic type or something
02:26:32 <neutrino> Axman6: well i can do it on paper ..
02:26:37 <Axman6> but as mentioned earlier, i'm pretty sure being able to do so boils down to being able to solve the halting problem
02:26:42 <neutrino> Axman6: but sadly haskell isn't mathematics
02:26:45 <Jafet> I would like Peano arithmetic to be decidable
02:26:48 <ceii> neutrino: actually, you can have a function natLength :: [a] -> Nat
02:26:53 <Axman6> there's nothing stopping you doing that
02:26:58 <Jafet> I would also like a pony
02:26:58 <ceii> with data Nat = Zero | OnePlus Nat
02:27:18 <neutrino> ok, let's put this aside for a second
02:27:28 <ceii> but then equality on Nat isn't completely decidable
02:27:34 <Axman6> data Listy a = Repeat a | EnumFrom a | EnumFromTo a a | EnumFromThenTo a a a | Cons a (Listy a)
02:27:49 <Rc43> Why PortNumber is automatically converted from Integer with fromInteger but Text with fromString - not?
02:27:54 <Axman6> any whatever else you need there
02:27:56 <neutrino> i am creating an error (using the function "error") somewhere in my code. it's in a function which lacks a useful bit of information i could show in the error to help people in fixing their input data so that it can be parsed.
02:28:12 <neutrino> this data is available in the function calling the function that calls error.
02:28:20 <ceii> kuznero: I'm not very good with Parsec, but I think you should add a "try" to your {sp; return [[]]} clause
02:28:21 <neutrino> let's say foo calls bar and bar calls error
02:28:39 <Jafet> Rc43: integer literals are not of type Integer; they are of type Num a => a
02:28:40 <ceii> the way it is, even if sp fails the input it has consumed will not come back
02:28:42 <neutrino> how can i grab that error inside foo, and throw a new error?
02:28:55 <Axman6> you can't in pure code
02:28:57 <Jafet> String literals are of type String, unless you use OverloadedStrings.
02:29:03 <Rc43> Jafet, literals = raw code?
02:29:04 <kuznero> celi: thanks, let me try
02:29:07 <Axman6> neutrino: use something like Maybe or Either
02:29:13 <neutrino> can i use something instead of error ?
02:29:13 <Jafet> I assume that's what you're referring to.
02:29:18 <Axman6> of course
02:29:34 <neutrino> what can i use, other than maybe/either ?
02:29:45 <Axman6> error should only ever be used as a last resport. we have much saner ways of handling error conditions in Haskell
02:29:48 <neutrino> because those don't feel semantically tied to actually carrying errors
02:29:56 <Axman6> eh?
02:30:03 <Axman6> why would you not just use Maybe?
02:30:29 <Nibble> Maybe Because
02:30:35 <neutrino> because if i look at a function's type and i see Maybe then it's not clear to me that "Nothing" means an error.
02:30:43 <Rc43> Jafet, but if we have integer literals as Num how we will get that it is PortNumber and where is fromInteger usage?
02:30:47 <Axman6> the whole point of the Either monad is for propogating errors and terminating as soon as one occurs, and giving you some information about the error
02:31:02 <neutrino> aha
02:31:05 <Jafet> Rc43: fromInteger is used magically to convert the literal to PortNumber.
02:31:05 <Axman6> neutrino: that's always been the convention used in haskell
02:31:10 <kuznero> celi: that did the trick! Thank you very much... was staring at this code for so long time already :)
02:31:21 <neutrino> Axman6: hrm.
02:31:39 <Axman6> if something might fail to return a result, you use Maybe, because it MAY return a result. and if you get Nothing, it means you encountered a condition where you cannot return a result, ie, an error
02:31:51 <Jafet> Rc43: Num is one of the magical type classes in Haskell.
02:32:52 <Rc43> Jafet, you have talked that integer literals is Num. When it becomes integer? (if we use fromInteger then we need to have integer)
02:32:57 <Rc43> *are
02:33:57 <Jafet> They are always of type Num a => a. Their values determined by fromInteger :: Integer -> a.
02:34:16 <Axman6> Rc43: anything of the form "n+" where n is a digit, will be read as fromInteger (read x),
02:34:26 <Sgeo> Pretend that Integer literals could be made from i123
02:34:40 <Sgeo> Then 123 is just fromInteger i123
02:34:51 <Sgeo> (There is no such i syntax)
02:34:51 <Rc43> Jafet, Axman6, understood, thanks
02:35:16 <Axman6> it's one of the few pieces of "magic" in haskell
02:35:26 <Rc43> Can I enable any flag or something to avoid writting "fromString ..." ?
02:35:35 <Sgeo> OverloadedStrings?
02:35:40 <Axman6> (otherwise we'd have to write (read "123") everywhere, instead of 123
02:36:09 <Sgeo> {-# LANGUAGE OverloadedStrings #-} at the top of the file
02:36:26 <Sgeo> Then "ABC" is a IsString a => a instead of a String
02:36:27 <Rc43> Sgeo, thanks
02:36:39 <Rc43> Sgeo, btw, what is i123?
02:36:47 <neutrino> there is no such thing
02:36:48 <Sgeo> Rc43, syntax that doesn't exist in Haskell
02:36:56 <Rc43> Sgeo, ok
02:37:00 <neutrino> it was just a mental shortcut
02:45:51 <Rc43> >     inputPorts   <- (Config.lookup  config "portsInput"   :: IO (Maybe [PortNumber]))
02:45:52 <lambdabot>   not an expression: `inputPorts   <- (Config.lookup  config "portsInput"   :...
02:45:54 <Rc43> awful
02:51:00 <Sgeo> Rc43, that only makes sense inside a do block
02:51:10 <Sgeo> Oh, right, lambdabot is not GHCi
02:51:18 <Sgeo> You can do that same exact thing in GHCi
02:51:22 <Rc43> Sgeo, it was ust quoting
02:51:31 <Rc43> *just
02:52:01 <Rc43> got accustomed to use >
03:07:47 <Rc43> http://hackage.haskell.org/packages/archive/configurator/0.2.0.0/doc/html/Data-Configurator-Types.html#t:Configured
03:08:03 <Rc43> I can use list of values in config only with low-level getMap?
03:08:30 <Rc43> lookup from http://hackage.haskell.org/packages/archive/configurator/0.2.0.0/doc/html/Data-Configurator.html require to type be Configured
03:09:08 <Rc43> but there is no instance Configured for [A], and this class is internal, so I can't add one more
03:09:23 <Rc43> where A is any except Char
03:13:28 <Rc43> and I can't to use Value because ut us internal, too
03:15:42 <Aune> Why are letters not allowed in operator names? Im sure there is a good reason but it feels like using operators like <x> to represent operators like cartesian product would help cleaning up my namespaces a little.
03:17:20 <Jafet> But cartesian product is denoted by √ó.
03:17:32 <ksion> Aune: Because otherwise you'd not be able to write a+b or similar expressions without whitespace.
03:17:57 <ksion> Not like it's big downside, but it's a design decision for language's syntax.
03:18:11 <Aune> ksion, oh. then I think I understand
03:18:49 <Jafet> Use Agda; functions can be infix and mixfix
03:18:50 <ksion> a<x>b could be ambigous, for example, or parsed into single name.
03:19:05 <Twey> You can √ó, or <*> if you hate Unicode
03:19:13 <Jafet> :t (<*>)
03:19:14 <lambdabot> forall (f :: * -> *) a b. (Applicative f) => f (a -> b) -> f a -> f b
03:19:19 <Aune> It is a design desision to be able to write f . g as f.g
03:19:31 <Aune> I think I get it now
03:20:23 <Jafet> I wonder if an identifier can be whitespace
03:21:20 <Aune> Now I understand why. So is the usual solution to use unicode characters or do people use other ways to be able to reach a large amount  of short operator names?
03:21:37 <Jafet> > generalCategory '‚ÄÜ'
03:21:38 <lambdabot>   Space
03:22:32 <ksion> It's common to use multiple characters &&&, use "brackets" <*>, or both -|||- .
03:22:47 <Jafet> The most common method is to use type classes.
03:23:55 <ksion> Authors of type classes had to invent operators, though.
03:25:37 <Jafet> > a * b + pi / 4.0 - f x
03:25:38 <lambdabot>   a * b + pi / 4.0 - f x
03:26:14 <Twey> Do it Agda-style ‚Äî data (:√ó:) a b = a :√ó: b
03:26:31 <Twey> (Haskell's upper-case constructors bug me now‚Ä¶ they're data values, dammit!)
03:27:00 <Jafet> if_then_else_
03:27:27 <Twey> data (:x:) a b where (√ó) :: a -> b -> a :√ó: b
03:35:29 <Aune> Well, I guess unicode is the solution for me then. Operator © here I come :)
03:52:30 * hackagebot persistent-postgresql 0.8.1.2 - Backend for the persistent library using postgresql.  http://hackage.haskell.org/package/persistent-postgresql-0.8.1.2 (FelipeLessa)
04:16:20 <golberg> ciao
04:27:33 * hackagebot yesod-auth 0.8.1.1 - Authentication for Yesod.  http://hackage.haskell.org/package/yesod-auth-0.8.1.1 (MichaelSnoyman)
04:37:44 <teneen> The following code does not work with ghc 7.4.1, it's from the ghc documentation for TypeFamilies
04:37:46 <teneen> data family T a
04:37:48 <teneen> data    instance T Int  = T1 Int | T2 Bool
04:37:50 <teneen> newtype instance T Char = TC Bool
04:38:11 <teneen> Malformed head of type or class declaration: family T a
04:39:23 <MaskRay> prepend {-# LANGUAGE TypeFamilies #-} to your src
04:40:34 <teneen> it's there
04:41:43 <Omnicidal> so this is actually a language eh
04:42:14 <donri> language extension
04:42:18 <koeien2> haskell is a programming language
04:42:34 * hackagebot hinduce-examples 0.0.0.2 - Example data for hInduce  http://hackage.haskell.org/package/hinduce-examples-0.0.0.2 (RobertHensing)
04:43:07 <Omnicidal> looks.....funky
04:43:18 <koeien2> it's quite different from other languages
04:43:21 <koeien2> do you know any?
04:43:44 <Omnicidal> yes
04:43:51 <koeien2> which?
04:44:14 <Omnicidal> c/c++(sort of), java, c#, php, python
04:44:22 <koeien2> ah
04:44:27 <koeien2> yes it's quite different from all of those
04:44:43 <koeien2> haskell is functional, which means that instead of changing state, we write functions
04:45:15 <koeien2> so in C you'd write  unsigned f = 1; for (unsigned i = 1; i <= n; i++) f *= i;
04:45:32 <koeien2> you are changing the value of f and i in the loop
04:45:37 <koeien2> in haskell you can write
04:45:49 <koeien2> f 0 = 1; f n = n * f (n-1)
04:46:25 <teneen> Is there any example of a good use case for top-level associated types? I can really only see good use for ones embedded in type classes
04:48:21 <ddarius> teneen: Type families are "top-level associated types."  Associated types are essentially just sugar for type families.
04:48:51 <teneen> ddarius: OK thanks for clarifying this
04:49:58 <teneen> ddarius: do you mean by sugar that associated types are just converted into type families at the end?
04:52:03 <teneen> When should TypeFamilies be used instead of associated types?
04:52:38 <exFalso> hello there, does anyone know how to get ghc 7.4.* for arch?
04:54:01 <exFalso> i'll just build from source i guess
04:55:12 <ion> Add ~/.ghc/bin:~/.cabal/bin to your PATH, get the GHC binary package, install it to ~/.ghc, get cabal-install from the Cabal (not cabal-install) darcs repository, run bootstrap, done.
04:55:20 <ddarius> teneen: I recommend reading this: http://www.haskell.org/haskellwiki/GHC/Type_families
04:56:31 <exFalso> ion: thanks i'll try that
04:56:53 <Flonk> Hi
04:57:39 <exFalso> ion: well the question is how to get the binary package:)
04:59:24 <mekeor> will haskell ever support dependent types?
04:59:31 <mekeor> Hi, Flonk
05:00:26 <ion> @where ghc
05:00:26 <lambdabot> http://haskell.org/ghc
05:00:34 <exFalso> mekeor: check out agda for dependent types
05:00:47 <ion> ‚ÄúDownload‚Äù, ‚ÄúLinux (your architechture)‚Äù
05:01:42 <exFalso> thank you!
05:06:20 <statusfa1led> How does the arrow 'do' notation correspond to the arrow operators
05:06:21 <statusfa1led> ?
05:07:16 <ion> statusfa1led: http://www.haskell.org/arrows/syntax.html
05:07:26 <statusfa1led> ion: oh, nice one, thanks
05:07:40 <statusfa1led> I also have a possibly dumb other question
05:07:50 <statusfa1led> actually nevermind, i'm googling more first
05:11:43 <stulli> exFalso: Try http://www.kiwilight.com/~magnus/$repo That was on the arch-haskell mailing list some days age. Haven't tried it myself though (sticking with 7.03 here).
05:11:55 <HugoDaniel> hi
05:13:58 <stulli> exFalso: Here is the actual mail: http://www.haskell.org/pipermail/arch-haskell/2012-February/001902.html
05:14:15 <ion> cmccann: How about replacing all Prelude functions that take a parameter only for its type (such as floatRange) with ones that take a Proxy instead? See e.g. https://gist.github.com/1188115
05:14:17 <danmaftei> i really like haskell, and want to use it more, but isn't its laziness bad for data-intensive tasks? i feel like i have to work extra hard to get around the laziness which would hurt speed & space.
05:14:18 <stulli> only for x86_64 it seems
05:15:13 <statusfa1led> danmaftei: What specifically about the laziness?
05:15:35 <statusfa1led> you mean like streaming?
05:15:41 <danmaftei> 1 sec
05:15:59 <danmaftei> she puts it way better than i could: http://users.aber.ac.uk/afc/stricthaskell.html
05:17:31 <danmaftei> i forget the exact issues i ran into when i built an n-gram character model, but ultimately i had to make my data structures strict
05:17:45 <danmaftei> i was of course using foldr and foldl' correctly, doing tail recursion, etc.
05:18:08 <danmaftei> i think ultimately it is due to reading large data files
05:18:20 <exFalso> stulli: awesome!
05:18:34 <statusfa1led> danmaftei: I think Iteratee IO may be a solution to that kind of problem
05:18:41 <statusfa1led> don't quote me on that
05:18:44 <statusfa1led> i'm looking into the same sort of thing
05:20:01 <statusfa1led> danmaftei: http://www.haskell.org/haskellwiki/Enumerator_and_iteratee
05:21:46 <ion> cmccann: Skimming through Prelude‚Äôs documentation, floatRadix, floatDigits and floatRange seem to be the only functions like that.
05:22:28 <ion> cmccann: Or perhaps provide alternative functions like the ones in the gist.
05:31:07 <lukish> > > fmap (+1) ("pemis",3)
05:31:08 <lambdabot>   <no location info>: parse error on input `>'
05:31:17 <lukish> > fmap (+1) ("pemis",3)
05:31:18 <lambdabot>   ("pemis",4)
05:31:23 <lukish> WHY?
05:32:02 <hpc> @src (,) fmap
05:32:02 <lambdabot> fmap f (x,y) = (x, f y)
05:32:37 * hackagebot persistent-template 0.8.1.1 - Type-safe, non-relational, multi-backend persistence.  http://hackage.haskell.org/package/persistent-template-0.8.1.1 (MichaelSnoyman)
05:33:16 <MaskRay> > second (+1) ("pemis",3)
05:33:17 <lambdabot>   ("pemis",4)
05:33:38 <ion> @type fmap `asTypeIn` \fmap -> fmap undefined (undefined :: (String, Integer))
05:33:39 <lambdabot> forall b. (Integer -> b) -> (String, Integer) -> (String, b)
05:35:26 <neutrino> do you think that the fact haskell is becoming popular means that people will be less likely to adopt new solutions to problems which were solved less-nicely in the past?
05:35:27 <ion> Functor :: (* -> *) -> Constraint; (,) a :: * -> *
05:35:40 <neutrino> for example we have a lot of monads that could be functors, as i understand?
05:36:08 <neutrino> or: now we have conduits. but will everything where conduits bring an advantage end up being updated to use them?
05:36:18 <kallisti> neutrino: all monads, by definition, are functors.
05:37:30 <neutrino> you're changing the subject
05:38:05 <kallisti> neutrino: uh, no?
05:38:14 <statusfa1led> ion: I don't suppose there's a tool for decomposing arrow notation to those normal operators?
05:38:20 <kallisti> you brought up a point. I explained why it doesn't matter.
05:38:50 <kallisti> neutrino: there are other solutions to streaming IO that don't involve conduits. I'm not sure I understand what you're getting at.
05:40:33 <kallisti> why would people not use libraries that are available to them in order to solve problems? Ignorance, perhaps? What does popularity have to do with the ignorance of programmers?
05:41:18 <irene-knapp> not wanting to depend on a library that may not be as well-maintained as it first appears
05:41:35 <kallisti> irene-knapp: ah, yes. which is also unrelated to the popularity of the language.
05:41:44 <irene-knapp> indeed
05:41:49 <irene-knapp> I just read neutrino's question
05:41:51 <irene-knapp> and I don't really get it
05:42:20 <kallisti> as far as I can tell it's something like "will stupid people use Haskell"; the answer is, and has always been, yes.
05:42:28 <irene-knapp> haha, yes
05:42:46 <irene-knapp> well, I think it's more like
05:42:52 <irene-knapp> will the language develop greater inertia
05:43:03 <irene-knapp> to which I'd say that that's a community issue, not a popularity issue
05:43:29 <irene-knapp> we are actually developing some (cf. the records debacle), but in general we've historically had a great attitude towards change
05:43:39 <irene-knapp> LANGUAGE pragmas are a great innovation for handling it
05:45:01 <neutrino> irene-knapp: yes, something like what you said
05:45:05 <irene-knapp> :)
05:48:03 <Control> I used to think Python was great. But Haskell has ruined it for me.
05:48:08 * irene-knapp nods
05:48:21 <Guest19310> it seems hackish
05:50:54 <ksion> Nah, it's not that bad. Surely it can look like math hacked into programming, but you can do stuff in it.
06:03:30 <parcs`> statusfa1led: don't think so, except for the old "http://hackage.haskell.org/package/arrowp". in ghc, arrow notation gets translated directly to an intermediate language, not haskell
06:07:59 <neutrino> does haskell have eval?
06:08:13 <koeien2> no
06:08:15 <neutrino> say if i had a piece of code in a string, and wanted to evaluate it and get its value.
06:08:19 <neutrino> can i do that?
06:08:23 <koeien2> no, not directly
06:08:32 <koeien2> you will need to ship a haskell compiler
06:08:37 <neutrino> oh ok
06:08:46 <koeien2> is there something specific you want to solve?
06:08:59 <neutrino> nope
06:09:09 <neutrino> just wondering what the worst thing you can do with haskell would be
06:09:17 <koeien2> oh, unsafeCoerce
06:09:19 <luite> neutrino: fortunately you can just use ghc as a library, using the ghc api or the hint package, that makes it even easier
06:09:25 <hpc> neutrino: there's the hint package
06:09:26 <neutrino> there should be like a contest for creating terrible haskell
06:09:49 <luite> neutrino: you do get huge executables that way, but you basically get interpret :: String -> a in return
06:09:50 <neutrino> except you don't win in it, you just lose.
06:10:00 <neutrino> luite: cute
06:10:14 <koeien2> yes, you ship a haskell compiler that way
06:10:20 <koeien2> it's a large beast
06:10:22 <neutrino> yes
06:10:29 <neutrino> how big is the executable this way ?
06:10:38 <hpc> ghc-sized
06:10:40 <luite> I think it adds around 25MB
06:10:57 <koeien2> that's not so bad.
06:10:58 <neutrino> not so bad
06:11:28 <hpc> neutrino: the best worst part of unsafeCoerce is that you can write a lot of legitimate functions with it
06:11:32 <hpc> @src null
06:11:33 <lambdabot> null []     = True
06:11:33 <lambdabot> null (_:_)  = False
06:11:44 <hpc> ^ can be null = unsafeCoerce
06:11:47 <hpc> as can
06:11:50 <hpc> @src isJust
06:11:51 <lambdabot> isJust Nothing = False
06:11:51 <lambdabot> isJust _       = True
06:12:16 <koeien2> that's by accident, right?
06:12:25 <hpc> you can even do isLargeInteger :: Integer -> Bool; isLargeInteger = unsafeCoerce
06:12:26 <koeien2> the ordering of the constructors aligns
06:12:33 <neutrino> you guys seen this? http://www.youtube.com/watch?v=Nbv9L-WIu0s&feature=related
06:12:34 <hpc> koeien2: yeah
06:12:40 <neutrino> puts your 25 meg compiler in perspective
06:12:45 <hpc> @src Integer
06:12:45 <lambdabot> data Integer = S# Int#
06:12:45 <lambdabot>              | J# Int# ByteArray#
06:13:17 <koeien2> neutrino: interesting
06:13:36 <neutrino> very enjoyable to watch
06:13:39 <neutrino> those guys are fun
06:14:10 <koeien2> the accent (is it australian?) is a bit weird
06:14:15 <neutrino> no idea
06:14:19 <neutrino> probably
06:14:25 <hpc> neutrino: love the description: "Grab your sandals and/or fake beards as our two brave coders tear apart a handful of common UNIX utilties which they grew up alongside, with adult supervision from a genuine greybeard."
06:15:15 <otters> @src Int#
06:15:15 <lambdabot> Source not found. That's something I cannot allow to happen.
06:15:23 <cmccann> koeien2, the ordering of the constructors is probably meant to give a sensible derived instance for Ord
06:15:33 <luite> neutrino: is the ubuntu ls statically linked?
06:15:38 <cmccann> for Maybe and Bool, at least
06:16:11 <koeien2> why does Maybe instantiate Ord anyway?
06:16:23 <cmccann> koeien2, why wouldn't it?
06:16:24 <hpc> koeien2: because nothing < something?
06:16:35 <koeien2> Nothing is either positive or negative infinity
06:16:40 <koeien2> well it's useful for Data.Map I suppose
06:16:48 <cmccann> no, Nothing is just nothing
06:16:57 <cmccann> it's a thing that isn't something
06:17:40 <koeien2> i don't see why Nothing should be smaller than everything else, why is that the canonical choice?
06:17:50 <byorgey> It isn't.
06:17:58 <byorgey> It's just the choice the standard library happens to make.
06:17:58 <cmccann> it's more traditional than canonical
06:18:00 <hpc> it's the "practical" one
06:19:09 <irene-knapp> yeah, I personally wouldn't have put Maybe in Ord
06:19:13 <cmccann> note that Left is less than Right, which makes it consistent with the Left-as-error use of Either
06:19:29 <irene-knapp> I also don't like the naming in Either :)
06:19:52 <irene-knapp> it makes it annoying when I want to have a type that actually does represent relative directions :)
06:20:13 <cmccann> irene-knapp, you should look at my these package, it's probably worse and might make you tolerate Either more easily :P
06:20:21 <irene-knapp> hmm, haha
06:20:25 <irene-knapp> that's an amusing description
06:20:26 <irene-knapp> perhaps.
06:20:31 <irene-knapp> I think I saw it once actually
06:20:39 <cmccann> data These a b = This a | That b | These a b
06:20:43 <irene-knapp> haha!
06:20:44 <cmccann> that is ideal naming there
06:20:54 <hpc> i think "left as smaller" sets a nice convention
06:20:57 <irene-knapp> well, it's better-ish
06:21:00 <hpc> both for Ord instances and for recursive data types
06:21:08 <irene-knapp> I think otherwise :)
06:21:36 <cmccann> yeah, [] follows the same convention since you mention it
06:21:42 <irene-knapp> hmm, true
06:21:46 <cmccann> the empty list is equivalent to Nothing and comes first
06:21:53 <byorgey> the thing about Ord is that it's often used for putting things in Sets or using them as keys in Maps
06:21:55 <cmccann> so Maybe behaves like a list of length 0 or 1
06:22:07 <byorgey> in which case the semantics really doesn't matter, it just matters that there exists *some* ordering
06:22:20 <luite> so why not make Complex an instance of Ord then? ;p
06:22:24 <cmccann> byorgey, oh dear, I better stay out of that can of worms :P
06:22:24 <byorgey> so having no Ord instance for types just because we can't agree on the proper semantics would be really annoying
06:22:29 <irene-knapp> byorgey: yes.  but imo there should be two typeclasses.
06:22:29 <koeien2> hmm, but then it's lexicographical ordering
06:22:38 <irene-knapp> Ord and Key, perhaps
06:22:46 * cmccann wants three, actually
06:22:46 <irene-knapp> with instance (Ord a) => Key a
06:22:48 <irene-knapp> oh?
06:23:02 <byorgey> irene-knapp: ah, well I can agree with you there.
06:23:05 <cmccann> partial ordering, total ordering, and bogus non-semantic ordering for data structures
06:23:06 <irene-knapp> ah, okay
06:23:15 <irene-knapp> cmccann: yes, that would indeed be nice
06:23:25 <irene-knapp> I agree that differentiating partial and total makes sense
06:23:37 <irene-knapp> although it would make more sense with dependent types :)
06:23:45 <cmccann> Sgeo suggested the third be called "BSOrd", which I'm certain stands for "Binary Search Ordering" because it's meant for Data.Map
06:23:51 <irene-knapp> since without them you can't do most of the things you would hope that you can with total orderings
06:23:53 <byorgey> hahaha
06:24:08 <irene-knapp> I would call it KeyOrdering or just Key, as I said
06:24:18 <cmccann> irene-knapp, yes, but that's not as funny
06:24:21 <irene-knapp> yes, yes
06:24:26 <irene-knapp> you males and your humor :)
06:24:46 <irene-knapp> well, anyway.
06:25:49 <cmccann> byorgey, I have a habit of ranting about this whenever someone brings up Ord and floats
06:25:59 <koeien2> or Eq and floats
06:26:09 <cmccann> Ord is much worse
06:26:20 <hpc> Eq at least makes a modicum of sense
06:26:23 <cmccann> IEEE semantics give a well-defined partial order, which Ord can't express
06:26:23 <byorgey> cmccann: so, about once a week then?
06:26:43 <cmccann> but we try to match IEEE where possible, so the Ord instance doesn't behave the way you'd expect either
06:26:47 <koeien2> well nan == nan is false
06:26:49 <cmccann> it's the worst of both worlds
06:27:09 <cmccann> and can actually break stuff like Data.Map in non-trivial ways
06:28:01 <cmccann> (note that while equality on floats is dubious with arithmetic involved, treating it as identity on persistent values is sensible)
06:31:43 <danmaftei> hi. i'm unsure if i should use strict or lazy I/O. i need to construct a translation table given two aligned toy corpora (each is ~500KB). in other words, i will need to place about 1MB of data into a single data structure, and then i'll be iteratively updating that data structure until convergence. would lazy or strict IO be better, or does it not matter?
06:32:00 <irene-knapp> not really relevant
06:32:17 <cmccann> if you need any control over how your input occurs, don't use lazy IO
06:32:21 <koeien2> i'd use strict IO if it sufficies.
06:32:26 <irene-knapp> what structure you use for the table is more important
06:32:47 <irene-knapp> one that supports shared structure between old and new versions as much as possible (ie, in the parts that don't differ) will help you substantially
06:33:20 <irene-knapp> some library authors like to call such structures "lazy" but it's really a different concept
06:33:36 <hpc> lazy IO and lazy evaluation are different things
06:33:45 <hpc> as is sharing :P
06:33:56 <irene-knapp> and data structures that behave well with regard to sharing and updating are different again - yes
06:34:51 <danmaftei> ok, so in this scenario lazy vs strict IO won't make any difference.
06:34:56 <irene-knapp> correct
06:35:42 <danmaftei> i'm a little unclear on when lazy I/O is problematic. are all problems ultimately because hClose is strict and the reading functions are lazy?
06:35:55 <irene-knapp> I guess you could say that, yes
06:35:56 <hpc> pretty much, yeah
06:36:12 <hpc> more generally, it's because you can't make any guarantees about when IO will happen
06:36:22 <hpc> er, can't make as many guarantees
06:36:24 <irene-knapp> it's a FAQ in here "why did I read zero bytes" when the handle was closed before any data was forced
06:36:36 <irene-knapp> I think that's the main problem people have with it
06:37:21 <koeien2> leaking file descriptors
06:37:29 <irene-knapp> oh, hm, maybe
06:37:59 <cmccann> you also lose the ability to do anything other than "read input in an unspecified way"
06:38:10 <cmccann> you can't e.g. track how many bytes have been read
06:38:47 <danmaftei> so, in my scenario, i'd only be using readFile. since my first step is to construct my translation table (which requires reading both corpora in full), the handles will be closed afterwards without any issues and i can go on my merry way. hope i got that right
06:38:49 <irene-knapp> hmm.  true.
06:39:11 <hpc> readFile is the happy function, yes
06:39:12 <koeien2> if you're using lazy IO, the garbage collector will do it "at some point"
06:39:16 <hpc> :t readFile
06:39:17 <lambdabot> FilePath -> IO String
06:39:20 <irene-knapp> danmaftei, sounds right
06:39:21 <koeien2> if you're using strict IO, it's deterministic
06:49:36 <ruby> If I have a function strict in its argument, how can I turn it into a function that is lazy in its argument?
06:49:55 <cmccann> if it's strict because it needs to inspect the argument, it's going to be strict
06:50:09 <koeien2> that's not possible.
06:50:36 <koeien2> do you have an example? what do you want to do?
06:50:54 <koeien2> well sometimes you can do it
06:50:59 <koeien2> @src zip
06:51:00 <lambdabot> zip (a:as) (b:bs) = (a,b) : zip as bs
06:51:00 <lambdabot> zip _      _      = []
06:51:06 <koeien2> oh
06:51:09 <koeien2> bad example.
06:51:15 <cmccann> @src zipWith
06:51:15 <lambdabot> zipWith f (a:as) (b:bs) = f a b : zipWith f as bs
06:51:16 <lambdabot> zipWith _ _      _      = []
06:51:19 <cmccann> meh
06:51:43 <koeien2> well if you'd write it as zip [] _ = []; zip _ [] = [];  ...
06:51:48 <koeien2> you can interchange these two lines
07:00:24 <ChristianS> anyway, zip is not strict in its arguments (i would say), it will only evaluate the head of each list, but not the rest
07:01:13 <koeien2> it won't even do that
07:01:13 <cmccann> @src unzip
07:01:14 <lambdabot> unzip = foldr (\(a,b) ~(as,bs) -> (a:as,b:bs)) ([],[])
07:01:17 <cmccann> there we go
07:01:20 <cmccann> that's what I was trying to remember
07:01:44 <koeien2> strict means f _|_ = _|_
07:02:15 <koeien2> since zip _|_ = _|_ it's strict.
07:02:41 * hackagebot Octree 0.2.2 - Simple unbalanced Octree for storing data about 3D points  http://hackage.haskell.org/package/Octree-0.2.2 (MichalGajda)
07:02:51 <cmccann> ooh, an octree
07:03:37 <mekeor> what is ~ ?
07:03:43 <koeien2> irrefutable pattern
07:03:47 <mekeor> huh?
07:03:53 <neutrino> we've grown octrees?
07:04:03 <cmccann> mekeor, it matches anything like just "x" would
07:04:04 <mekeor> http://www.haskell.org/haskellwiki/Keywords#.7E
07:04:05 <neutrino> totally got to clean this yard up.
07:04:25 <cmccann> and then doesn't actually force the argument until the values are needed
07:04:37 <cmccann> so it makes the pattern match less strict
07:04:48 <cmccann> which is safe with single-constructor types like (,)
07:04:53 <cmccann> and lets unzip be lazy
07:04:58 <mekeor> cmccann: ah
07:05:06 <mekeor> okay. i see.
07:05:16 <rwbarton> in this case you can rewrite it as \(a,b) x -> (a:fst x,b:snd x)
07:05:18 <mekeor> so, without ~ it's not lazy??
07:05:25 <koeien2> correct
07:05:26 <kallisti> > zip [1..] [-1,-2..]
07:05:27 <lambdabot>   [(1,-1),(2,-2),(3,-3),(4,-4),(5,-5),(6,-6),(7,-7),(8,-8),(9,-9),(10,-10),(1...
07:05:32 <mekeor> that's bad.
07:05:36 <koeien2> no
07:05:54 <kallisti> > zip`ap`negate $ [1..]
07:05:55 <lambdabot>   No instance for (GHC.Num.Num [a])
07:05:55 <lambdabot>    arising from a use of `e_11' at <inter...
07:06:00 <mekeor> so, ~ is the opposite to ! right ?
07:06:05 <ChristianS> > zip [1] [2,undefined]
07:06:05 <kallisti> > zip`ap`map negate $ [1..]
07:06:05 <lambdabot>   [(1,2)]
07:06:06 <lambdabot>   can't find file: L.hs
07:06:21 <kallisti> what.
07:06:30 <mekeor> @hoogle !
07:06:30 <lambdabot> Prelude (!!) :: [a] -> Int -> a
07:06:31 <lambdabot> Data.List (!!) :: [a] -> Int -> a
07:06:31 <lambdabot> Data.IntMap (!) :: IntMap a -> Key -> a
07:06:39 <mekeor> ,more
07:06:44 <rwbarton> it's not a function
07:06:50 <koeien2> ! is magic
07:06:53 <mekeor> rwbarton: but hoogle knows keywords
07:06:55 <koeien2> it's sugar for seq
07:07:05 <mekeor> ah, okay
07:07:06 <rwbarton> oh true, for some reason it is pretty far down the list
07:09:22 <kallisti> mekeor: note that the only thing that becomes strict is the constructor matching. The lack of ~ doesn't force variables in pattern.  (actually this is probably obvious but I just wanted to clarify)
07:12:04 <Cale> AUGH, 27 new messages...
07:12:13 <Cale> All in this thread on (.)
07:12:28 <byorgey> control-D!
07:12:48 <Cale> What's with this thread anyway? Don't people know that (.) is composition, and if you don't think that, you're not a Haskell programmer?
07:13:00 <byorgey> haha
07:13:44 <Cale> You know what would be better for record selection? Almost any other string of symbol characters.
07:14:15 <Cale> Or... not symbol character
07:14:16 <Cale> s
07:14:21 <rwbarton> `dot`
07:14:24 <Cale> make it look like a function
07:14:31 <ddarius> Cale: But then it wouldn't be like Java!
07:14:33 <byorgey> To really confuse things, we could use ‚àò for record selection
07:14:37 <Cale> ahaha
07:14:39 <CondT> functional makes more sense than OO for me now. lets say i have a matrix class. i dont want to do M1.mul(M2)(destructive) and M1.mul(M2)->M3 is kind of weird. I want to do Matrix.mul(M1,M2)->M3. where Matrix is a small class just defining a matrix then I have a file MatrixOperations that takes Matrices as inpus and returns a new matrix instead of modifying the old one. makes more sense!
07:14:39 <Cale> perfect
07:15:00 <CondT> but i guess there are times when OO makes sense.
07:15:03 <mekeor> byorgey: hehehe
07:15:29 <Cale> CondT: When OO makes sense, I believe Haskell does it better than most typed "OO languages"
07:15:47 <Cale> Even just Haskell 98 without any special features.
07:15:55 <Cale> In fact, even without typeclasses.
07:16:14 <Cale> Just having first class functions gets you better OO than most typed OO languages do.
07:17:57 <ddarius> Higher order functions are a poor man's objects.
07:19:39 <ChristianS> then it's better to be poor
07:20:14 <kallisti> Cale: I actually like ' for record selection
07:20:26 <kallisti> however it would require a change to variable identifiers.
07:20:29 <monochrom> OO is poor man's higher-order functions
07:20:36 <Younos> :)
07:20:51 <monochrom> runtime type check is poor man's dependent types
07:20:57 <zomg> CondT: regarding your matrix example, that's just a sample of poor api design, not really a sample of why functional is better than oo ;)
07:20:58 <kallisti> but a function would be good too. why not just have lenses builtin to the language?
07:21:21 <otters> I really need to figure out what lenses are
07:21:35 <monochrom> lenses are a pair of getters and setters
07:21:41 <otters> ...
07:21:42 <otters> is that it?
07:21:57 <monochrom> getters and setters are poor man's lenses :)
07:22:01 <donri> otters: http://www.scs.stanford.edu/11au-cs240h/notes/zipper.html
07:22:02 <otters> I see
07:22:19 <donri> otters: http://happstack.com/docs/crashcourse/AcidState.html#ixset_lens
07:23:30 <CondT> zomg: yes but what do you think is better? it is better to have a small matrix class functions in a separate file rather than doing m1.mul(m2) right?
07:38:45 <dan_lo> so I just completed the interactive tutorial on tryhaskhell.org. Really cool stuff. I want to learn Haskell, but I only have experience with imperative languages (C, Python, JS, etc). Can someone recommend me a Haskell book targeted at experienced imperative programmers new to Haskell and functional programming?
07:39:05 <koeien2> @where LYAH
07:39:06 <lambdabot> http://www.learnyouahaskell.com/
07:39:08 <koeien2> @where RWH
07:39:09 <lambdabot> http://www.realworldhaskell.org/blog/ http://book.realworldhaskell.org/read/
07:39:33 <koeien2> tbh your experience is not necessarily going to help much in some respects
07:39:38 <mee> they will seem slow at first, but bear with them
07:39:44 <zomg> CondT: well I really think that the matrix data and the operations you can perform on the data are quite closely related, thus it would make sense to me to have them in the same module (be it OO style or functional)
07:40:25 <dan_lo> yeah it feels like Alegbra class as much as imperative programming now, I guess :P
07:41:19 <dan_lo> I think I'll read RWH based on the FAQ on the LYAH website. thanks.
07:42:49 <Omnicidal> i'm on the edge
07:42:57 <Omnicidal> wondering if I want to put effort into learning this or not
07:42:57 <Omnicidal> lol
07:44:44 <pcavs> I'm trying to load the generated HBase.hs thrift code, but get an error specifying that it can't find HBase_Iface.hs which is in the same folder, how can I debug this situation?
07:45:23 <statusfa1led> Is there a license like BSD which forbids redistribution under "GPL-style" licenses- i.e. ones which force you to make your changes available?
07:45:42 <koeien2> i doubt it
07:45:59 <koeien2> why would you want that?
07:46:04 <statusfa1led> curiosity
07:46:24 <statusfa1led> the BSD-GPL flamewar would get more interesting if people started using one like that~
07:46:25 <mekeor> statusfa1led: lol. that's evil!
07:46:28 <statusfa1led> yes :D
07:46:49 <statusfa1led> well that whole BSD argument is "forcing people to share is evil"
07:47:00 <statusfa1led> so why not have a license that "forces people not to have to share"
07:47:11 <mekeor> statusfa1led: you want them (i mean the one who fork the source code) to be able to make it "copyright" but not to "copyleft", that's evil!!!
07:47:17 <statusfa1led> hahah
07:47:23 <statusfa1led> yes that's right
07:47:44 <statusfa1led> well that seem to be the logical course of action if you believe the argument
07:47:48 <statusfa1led> I don't particularly have an opinoin
07:47:53 <statusfa1led> opinion*
07:48:12 <mekeor> statusfa1led: you could visit #fsf for that question, too, btw.
07:48:26 <Clint> statusfa1led: the openssl license sort-of explicitly forbids linking with gpl
07:48:29 <statusfa1led> mekeor: i'd rather not be torn limb from limb~
07:48:37 <statusfa1led> Clint: oh, nice
07:48:55 <Clint> s/linking/something/
07:49:24 <Clint> it's one of the worst licenses in the world
07:49:25 <statusfa1led> oh, the "you may not impose any further restrictions"
07:49:40 <statusfa1led> Clint: so you think that's a bad idea? :P
07:49:42 <irene-knapp> to be fair
07:49:51 <irene-knapp> GPL would also forbid linking with GPL, if it didn't have an exemption for itself
07:50:07 <Clint> statusfa1led: last paragraph of http://www.openssl.org/source/license.html
07:50:24 <Clint> of course i think it's a bad idea
07:50:25 <statusfa1led> hahah
07:50:53 <statusfa1led> There are those that consider the GPL to 'infect' code.
07:50:55 <Azel> statusfa1led: Not sure that could not be avoided by first redistributing it under a more classical BSD...and that would go against the principle of "forcing the hand of people is evil"
07:50:59 <statusfa1led> aaaaaaaand FLAME ON
07:51:13 <statusfa1led> Azel: oh true
07:51:20 <Clint> i don't understand the BSD love when MIT is so much better
07:51:21 <Clint> but i digress
07:51:34 <irene-knapp> what is the distinction between BSD and MIT, again?
07:51:45 <statusfa1led> I thought they served identitcal purpose
07:51:50 <statusfa1led> I am terrible at typing today
07:51:50 <donri> I don't understand the MIT love when ISC is so much better
07:53:07 <daimrod> the wtfpl is the best.
07:53:28 <Clint> bsd is poorly written, requires you to modify it to replace the name of the copyright holders, sometimes has advertising requirements or other clauses that nobody actually complies with
07:53:31 <donri> really though, apache 2 is the most well-design liberal license
07:53:31 <koeien2> the GPLv3 is a bit wordier and it allows for more compatibility afaik
07:53:34 <irene-knapp> hmmm
07:53:35 <statusfa1led> daimrod: hahah, awesome
07:53:35 <irene-knapp> I see
07:54:19 <Azel> daimrod: The most liberal licence...behind putting everything in the public domain, but that's not always possible
07:55:09 <killy9999> hello everyone
07:55:21 <koeien2> hi killy9999
07:55:29 <statusfa1led> Azel: see "public domain" section: http://sam.zoy.org/wtfpl/
07:57:39 <pcavs> Anyone been able to use Thrift.BinaryProtocol ? I get the following error (http://hpaste.org/63541)
07:59:58 <statusfa1led> awwwww, I can't get hakyll to build :(
08:01:09 <tomberek> what's the latest on haskell to android? is in an ARM issue?
08:01:50 <statusfa1led> Lambdroid?
08:01:54 <statusfa1led> sounds awesome
08:02:31 <hpaste> statusfailed pasted ‚ÄúHakyll Build Failure‚Äù at http://hpaste.org/63542
08:02:52 <statusfa1led> Can anyone point me in the right direction to fixing that build failure ^ ?
08:03:49 <irene-knapp> > showHex (fromIntegral $ pi * (2 ** 62) :: Word64) ""
08:03:50 <lambdabot>   Ambiguous type variable `a' in the constraints:
08:03:50 <lambdabot>    `GHC.Float.Floating a'
08:03:51 <lambdabot>  ...
08:03:57 <irene-knapp> > showHex (fromIntegral $ (pi :: Double) * (2 ** 62) :: Word64) ""
08:03:58 <lambdabot>   No instance for (GHC.Real.Integral GHC.Types.Double)
08:03:59 <lambdabot>    arising from a use ...
08:04:04 <irene-knapp> > showHex (realToFrac $ (pi :: Double) * (2 ** 62) :: Word64) ""
08:04:05 <lambdabot>   No instance for (GHC.Real.Fractional GHC.Word.Word64)
08:04:05 <lambdabot>    arising from a use...
08:04:11 <irene-knapp> > showHex (floor $ (pi :: Double) * (2 ** 62) :: Word64) ""
08:04:12 <lambdabot>   "c90fdaa22168c000"
08:04:21 <irene-knapp> > showHex (floor $ (pi :: Double) * (2 ** 61) :: Word64) ""
08:04:22 <lambdabot>   "6487ed5110b46000"
08:04:27 <irene-knapp> > showHex (floor $ (pi :: Double) * (2 ** 60) :: Word64) ""
08:04:28 <lambdabot>   "3243f6a8885a3000"
08:04:36 <irene-knapp> yay
08:04:40 <irene-knapp> @botsnack
08:04:40 <lambdabot> :)
08:05:41 <aavogt> statusfa1led: I would try calling  "ghc-pkg unregister citeproc-hs HTTP-4000.1.1 network-2.3.0.2", then start over
08:05:53 <aavogt> or maybe quickest is to wipe out your ~/.ghc and ~/.cabal
08:06:22 <monochrom> .ghc would do
08:06:26 <statusfa1led> aavogt: aaaghh but I have so much installed ;_;
08:07:09 <aavogt> well you can instead unregister all your packages with seem to be broken
08:07:24 <aavogt> which probably takes at least a few tries to get them all
08:08:05 <monochrom> there are also times you have to remove a non-broken package because its presence breaks other packages
08:08:50 <monochrom> in fact when the presence of a user package breaks a global package, the right thing to do is not to remove the broken global package
08:09:53 <monochrom> my http://www.vex.net/~trebla/haskell/sicp.xhtml will lose your innocence
08:10:28 <statusfa1led> D:
08:13:31 * cmccann suggests nuking everything from orbit.
08:13:56 <cmccann> that's the simplest way to fix weird package issues
08:14:18 <statusfailed> cmccann: that's usually my approach...
08:14:25 <statusfailed> is there something like distcc for haskell...? :D
08:16:33 <aavogt> monochrom: most of the disasters in there are related to bugs in 6.12 have been fixed, right?
08:18:46 <hpaste> killy pasted ‚Äúnoob question‚Äù at http://hpaste.org/63544
08:18:59 <killy> guys, I have a noob question about lists
08:19:28 <killy> I created a big list. Getting its head is fast, getting its last element is slow - that's obvius
08:19:29 <koeien2> sure, what's it?
08:19:52 <killy> now I reverse the list - that's fast, 'cause Haskell is lazy, right?
08:20:10 <koeien2> let rev_list = ... only creates a definition, it does not compute anything
08:20:14 <cmccann> not really
08:20:15 <ddarius> killy: Why do you think that?
08:20:16 <killy> so the list gets reversed when I try to get head of the new list
08:20:21 <cmccann> yes
08:20:27 <killy> yes, exactly, so far everythings fine
08:20:48 <killy> now tell my why getting the last element of the reversed list is so fast?
08:21:11 <killy> 0.07 secs comparing to 2.13 secs for the original list
08:21:17 <statusfailed> optimisation?
08:21:19 <statusfailed> (maybe?)
08:21:36 <cmccann> killy, are you only getting the last element, or are you forcing its value?
08:21:56 <cmccann> if the list elements themselves need to be computed, that will only happen once
08:22:07 <cmccann> similarly if computing the original list takes a while
08:22:39 <killy> so when I call last on the original list that's when it gets created and that's why it's so slow?
08:22:43 <killy> I get it now
08:22:50 <ddarius> killy: Do the same thing as in the past, except do 'last list' twice.
08:22:52 <cmccann> it could be.
08:23:01 <killy> I did, that was very fast
08:23:02 <cmccann> there are lots of ways you could observe that behavior.
08:23:42 <killy> wow, I;m just starting with Haskell, but I'm impressed that it's so perfectly logical (so far at least :) )
08:24:24 <cmccann> yes, things behaving in a consistent and logical way is one of Haskell's strengths
08:24:56 <killy> oh, BTW thanks to everyone who helped me yesterday with installing Leksah - the solution was quite easy (as all solutions are when you know them)
08:25:54 <killy> it turned out that packages from suse repo are broken. Getting GHC binaries and installing haskell-platform from source solved the problems
08:26:28 <irene-knapp> > log 2 8
08:26:29 <lambdabot>   0.6931471805599453
08:26:34 <irene-knapp> > log 8 2
08:26:35 <lambdabot>   2.0794415416798357
08:26:40 <irene-knapp> > lg 8
08:26:41 <lambdabot>   Not in scope: `lg'
08:26:59 <ksf> what am I supposed to pass as the type arguments to isInstance?
08:27:11 <koeien2> irene-knapp: you're a victim of Caleskell, I think
08:27:13 <ksf> http://www.haskell.org/ghc/docs/7.4.1/html/libraries/template-haskell-2.7.0.0/Language-Haskell-TH.html#v:isInstance
08:27:18 <irene-knapp> koeien2, nope?
08:27:22 <cmccann> > log 2
08:27:23 <lambdabot>   0.6931471805599453
08:27:26 <irene-knapp> > logBase 2 8
08:27:27 <lambdabot>   3.0
08:27:28 <koeien2> > logBase 2 8
08:27:28 <leod> anybody know a neat way to check if any two adjacent elements in a list are equal?
08:27:29 <lambdabot>   3.0
08:27:40 <irene-knapp> > ceiling $ logBase 2 7
08:27:41 <lambdabot>   3
08:27:43 <irene-knapp> excellent
08:27:43 <koeien2> > log 8 2 -- this is only possible with some weird instances
08:27:44 <lambdabot>   2.0794415416798357
08:27:47 <irene-knapp> > ceiling $ logBase 2 8
08:27:48 <lambdabot>   3
08:27:59 <irene-knapp> oh, yes, I see
08:28:00 <koeien2> leod: any (zipWith (==) xs (tail xs))
08:28:02 <ksf> leod, zipaptail
08:28:16 <cmccann> :t zip `ap` tail
08:28:16 <leod> nice :)
08:28:17 <lambdabot> forall b. [b] -> [(b, b)]
08:28:17 <c_wraith> koeien2: don't you wan't or?
08:28:17 <leod> thanks
08:28:18 <edwardk> probably the Num instance for (a -> b)
08:28:25 <koeien2> c_wraith: er, yes.
08:28:28 <koeien2> ty.
08:28:37 <edwardk> > log 2 3
08:28:37 <lambdabot>   0.6931471805599453
08:28:39 <koeien2> i always confuse them
08:28:39 <edwardk> > log 3 2
08:28:40 <c_wraith> wtf, "wan't"...  still too tired
08:28:40 <lambdabot>   1.0986122886681098
08:28:47 <Omnicidal> you wa not???
08:28:49 <edwardk> > log 2 4
08:28:50 <lambdabot>   0.6931471805599453
08:28:53 <edwardk> yep
08:28:58 <Omnicidal> D:
08:29:07 <edwardk> > 2 3
08:29:08 <lambdabot>   2
08:29:18 <ksf> ...all I want to do is to have a TH function that figures out which instances are missing, on its own.
08:29:22 <cmccann> edwardk, that instance is great for sowing confusion
08:29:27 <edwardk> yeah
08:29:35 <ksf> I'm sick and tired of having to figure that out by myself.
08:29:43 <edwardk> its still useful though
08:30:59 <ksf> ah, first the class, then the data type.
08:31:04 <cmccann> ksf, yes
08:31:10 <cmccann> the class by its name
08:31:20 <cmccann> whereas the type can be something other than a single type name
08:31:23 <edwardk> ksf: you can do that. byorgey published the trick
08:31:35 <cmccann> think about how you'd ask if "Either a" is an instance of Functor
08:31:50 <edwardk> ksf: basically you try to make the instance and it'll fail, but you can catch that and try something else
08:32:32 <byorgey> hmm, I'm not sure whether it would work for instances
08:32:49 <byorgey> the trick I wrote about is where you try to reify a name, and if it fails you know that name hasn't been defined
08:32:50 * cmccann notes that the reifyInstances function apparently looks up "instaces"
08:32:51 * hackagebot mecab 0.3.0 - A Haskell binding to MeCab  http://hackage.haskell.org/package/mecab-0.3.0 (HideyukiTanaka)
08:32:56 <edwardk> ah
08:33:07 <byorgey> oh, but if there's a reifyInstances function...
08:33:10 <edwardk> i only vaguely remembered it
08:33:18 <byorgey> I don't know, you could possibly adapt it.
08:33:18 <edwardk> guess that would take care of it
08:33:21 <cmccann> ksf, what exactly are you trying to do, again?
08:34:51 <cmccann> ksf, also note that reifying a class will give you a list of instances
08:36:14 <cmccann> the isInstance thing is more about checking if a specific type is an instance and (I assume) implies doing the usual instance selection stuff to find a match
08:36:48 <cmccann> there may also be "instaces" involved in there somewhere :P
08:41:11 <aavogt> you might run into problems deciding which names are actually equal for your instances
08:41:23 <aavogt> $( reify ''Num >>= \(ClassI _ is) -> stringE . show $ map ci_dfun is ) -- gives you:
08:41:28 <aavogt> "[GHC.Real.$fNumRatio,GHC.Num.$fNumInteger,GHC.Num.$fNumInt,GHC.Float.$fNumFloat,GHC.Float.$fNumDouble]"
08:42:25 <aavogt> so based on that list you might be ok to write  instance Num Rational, but then it turns out that Rational = Ratio Integer
08:42:36 <cmccann> yeah
08:42:48 <sam2> anybody familiar with Data.Reflection?
08:42:52 <aavogt> or maybe your instance is actually allowed by some extensions (overlapping instances or whatever)
08:42:54 <cmccann> but I'm not sure what ksf wants to accomplish
08:43:05 <cmccann> all I know is that TH is annoying
08:43:14 <cmccann> it's just a matter of which kind of annoying ksf has to deal with
08:43:43 <sam2> I'm having trouble understanding reifiesNum
08:44:54 * aavogt has gotten Data.Reflection to do stuff but somehow the annotations ended up taking more space up than actual parameters
08:45:07 <tkahn6_> sam2: this is the original paper if you haven't seen it, http://www.cs.rutgers.edu/~ccshan/prepose/prepose.pdf
08:45:37 <tkahn6_> sam2: not saying that will necessarily be useful
08:45:37 <aavogt> edwardk might be the person to ask about why it got changed to use proxy etc.
08:45:54 <cmccann> ccshan is Oleg's PR guy, right? :P
08:46:15 <aavogt> @ty reflect
08:46:16 <lambdabot> forall a (m :: * -> *). (MonadLogic m) => Maybe (a, m a) -> m a
08:46:17 <sam2> hm.. thanks tkahn6 let me skim through it
08:56:08 <tkahn6_> sam2: i find that haskell is pretty unique in that RTFM actually helps a lot, usually the papers are really approachable. good luck
08:59:04 <Omnicidal> whenever i see "RTFM" i think "Read the fuckin manual!"
09:00:02 <Mike___> Hello again ^.^
09:00:07 <Enigmagic> Omnicidal: and for good reason
09:00:10 <Mike___> Is there a function that clears my console?
09:00:22 <tkahn6_> clear
09:00:34 <Mike___> just that?
09:00:40 <parcs`> is there a simple quasiquoter that returns the input string verbatim?
09:00:40 <tkahn6_> u mean ghci or bash?
09:00:45 <Mike___> ghci
09:01:15 <Enigmagic> :! clear
09:01:16 <Enigmagic> :)
09:01:36 <Mike___> :O
09:01:47 <donri> @hackage string-qq
09:01:47 <lambdabot> http://hackage.haskell.org/package/string-qq
09:01:55 <tkahn6_> Enigmagic: it's pretty cool that that works
09:02:38 <Mike___> it works? O_o
09:03:42 <donri> parcs`: (for you)
09:03:49 <mauke> Mike___: ctrl-l
09:04:51 <Mike___> do ctrl-l ?
09:04:57 <Mike___> that would work?
09:05:21 <Mike___> 2 good to be true ^.^
09:05:29 <mauke> ... how hard would it be to just try?
09:05:34 <mauke> instead of writing three lines on irc, I mean
09:06:07 <monochrom> for fear of exploding the computer, it is safer to ask first
09:06:22 <Mike___> i tried -.-
09:06:43 <monochrom> so that people you trust will lie to you and guide you to explode the computer instead
09:06:49 <Mike___> ahahah
09:06:51 <Mike___> that is funny
09:06:58 <mauke> Mike___: and what happened?
09:07:15 <donri> what OS are you using anyway
09:07:28 <tkahn6_> i think he's using windows
09:07:41 <Mike___> 61:10:     Not in scope: `l'
09:07:42 <tkahn6_> try :!cls Mike___
09:07:43 <Mike___> I am
09:08:02 <mauke> Mike___: what did you do to get that error?
09:08:07 <Mike___> 61:5:     Illegal bang-pattern (use -XBangPatterns):     ! cls
09:08:16 <tkahn6_> Mike____ you need the :
09:08:18 <mauke> Mike___: what did you do to get that error?
09:08:28 <Mike___> cause i typed do ctrl-l
09:08:28 <Mike___> -.-
09:08:39 <parcs`> donri: thanks
09:09:02 <monochrom> the ctrl key and the L key
09:09:06 <mauke> Mike___: even if that made sense, where did you get the "do " from?
09:09:09 <tkahn6_> lol
09:09:20 <Mike___> a friend of mine told me to try that
09:09:26 <tkahn6_> wat
09:09:38 <monochrom> see what I mean by "people you trust"
09:09:48 <Mike___> ok, so I have this
09:09:48 <Mike___> gereMenuMain c = do     :!cls
09:09:57 <tkahn6_> what
09:10:00 <Mike___> and, I get an error on another line
09:10:07 <otters> @src uncurry
09:10:07 <lambdabot> uncurry f p = f (fst p) (snd p)
09:10:09 <tkahn6_> no type that in a fresh line
09:10:10 <mauke> Mike___: that doesn't look like ghci
09:10:12 <tkahn6_> with no stuff
09:10:18 <otters> @src curry
09:10:18 <lambdabot> curry f x y = f (x, y)
09:10:20 <Mike___> its from my code
09:10:30 <tkahn6_> i don't know what is going on
09:10:31 <Mike___> 63:7:     parse error on input `<-'
09:10:36 <Mike___> that is from ghci
09:11:04 <tkahn6_> Mike___: you want to clear the console inside of your program
09:11:06 <tkahn6_> ?
09:11:11 <Mike___> yes tkahn6_
09:11:15 <mauke> what console?
09:11:19 <Mike___> ghci
09:11:24 <mauke> what if there is no ghci?
09:11:25 <Mike___> durring the code execution
09:11:35 <Mike___> I know what you mean
09:11:44 <Mike___> it wouldn't be cross platform
09:11:48 <ddarius> ...
09:11:58 <mauke> no, that's not what I mean
09:12:06 <tkahn6_> Mike___: System.Process.system("cls")
09:12:19 <Mike___> what did you mean mauke ?
09:12:20 <monochrom> mauke means: complied program, standalone executable
09:12:28 <Mike___> oh...
09:12:31 <Mike___> hmm...
09:12:40 <Mike___> havnt got that far to think about that.. but it is a good point
09:12:43 <mauke> I mean more than that
09:12:44 <tkahn6_> Mike___: http://hackage.haskell.org/packages/archive/process/1.0.1.1/doc/html/System-Process.html#v%3Asystem
09:12:45 <monochrom> that is why you should not be bent on "in ghci"
09:13:22 * ddarius is not sure how Mike___ has come to be writing programs.
09:13:29 <JoeyA> Does this come across as readable to anyone?  (ReaderT .) . flip . (. sdHandle)
09:13:37 <Mike___> Ok, so, the commands that "mess up" with my console are the ones that I need to be carefull with when working with them?
09:13:47 <mauke> what
09:13:53 <hpc> JoeyA: not really; @pl output?
09:13:56 <tkahn6_> Mike___: i have given you the solution
09:13:58 <JoeyA> Yes
09:14:09 <JoeyA> It's easy to end up with obfuscated point-free code, but I'd like to identify patterns that happen to be useful often.
09:14:19 <Mike___> I know tkahn6_ , and I'm thankfull, im just talking about this point here
09:14:23 <tkahn6_> i see
09:14:27 <hpc> what's the type of sdHandle, and the type of that whole expression?
09:14:36 <Mike___> what do you mean ddarius ?
09:14:41 <JoeyA> sendWith :: (Handle -> a -> IO ()) -> a -> ServeM ()
09:14:48 <JoeyA> type ServeM = ReaderT ServeData IO
09:14:59 <JoeyA> sdHandle selects a Handle from the ServeData structure.
09:15:03 <hpc> ah
09:15:11 <monochrom> I think "x . flip . y" is a bit cryptic because of flip (rather than flip op) being a pipeline stage
09:15:45 <JoeyA> So at best, (ReaderT .) . flip . (. foo) can be thought of as a pattern to select something out of the ReaderT context and do something to it.
09:15:56 <hpc> ah
09:16:20 <JoeyA> I wonder if I should add it to the wiki.  There's already a "swing" mentioned there, though.
09:16:21 <hpc> :t asks
09:16:22 <lambdabot> forall r a (m :: * -> *). (MonadReader r m) => (r -> a) -> m a
09:16:42 <JoeyA> Well, the callback operates in the underlying monad, rather than the ReaderT.
09:17:01 <JoeyA> e.g. sendWith hPutStrLn "Hello"
09:17:06 <Mike___> tkahn6_: I still can't get it to work. Not in scope: `System.Process.system'
09:17:41 <tkahn6_> Mike___: you might have to install it
09:17:46 <hpc> so it's kinda like
09:17:56 <tkahn6_> Mike___: cabal install process
09:17:59 <hpc> (r -> m a) -> t r m a
09:18:06 <hpc> for certain values of t/m
09:18:18 <hpc> i like it
09:18:28 <JoeyA> err, I think you need an extra parameter
09:18:42 <Mike___> ok tkahn6_ .. now I'm a little bit confused.. what do you mean by cabal install process?
09:18:49 <JoeyA> sendWith :: (Handle -> a -> IO ()) -> a -> ReaderT ServeData IO ()
09:18:49 <rwbarton> @type ReaderT
09:18:50 <tkahn6_> Mike___: nvm
09:18:50 <lambdabot> forall r (m :: * -> *) a. (r -> m a) -> ReaderT r m a
09:19:13 <JoeyA> imma write a generic version and paste it.
09:19:14 <hpc> oh derp, i do
09:19:23 <hpc> rwbarton: lol
09:20:15 <ddarius> hpc: For t = (->)
09:26:12 <exFalso> hello, in the following code: http://hpaste.org/63545 does anyone know why * doesnt accept the monomorphic kind Bin?
09:26:46 <hpaste> ‚ÄúJoey Adams‚Äù pasted ‚ÄúThe "wallet" combinator‚Äù at http://hpaste.org/63546
09:26:54 <JoeyA> hpc: ^
09:27:25 <ddarius> exFalso: Since the compiler couldn't figure out what kind Proxy should have, it defaulted to * -> *.
09:28:12 <exFalso> ddarius: i thought that * is a polymorhpic kind that can be specialised into any
09:28:18 <JoeyA> I could say wallet = (ReaderT .) . flip . (.), but that would be slightly less fun.
09:28:35 <JoeyA> And for the sendWith example above, I wouldn't be able to use it inline conveniently.
09:29:18 <mjga> hi, I wonder whether quickcheck can help me verifying higher order functions, like fmap, or fold?
09:29:30 <JoeyA> Err wait, that wouldn't work.
09:30:01 <monochrom> that would require generating "randomly chosen functions"
09:30:33 <koeien2> why is that impossible?
09:30:36 <JoeyA> JiggyBlkMn is sending spam through private messages.
09:30:45 <monochrom> possible. hard. I wouldn't bother.
09:30:47 <rostayob> exFalso: whatever you say, you're wrong
09:30:48 <tsousa> in this example why do i need an fmap? http://dpaste.com/702041/
09:30:57 * monochrom is a lazy bum
09:31:11 <exFalso> rostayob: i am wrong
09:31:21 <mjga> tsousa: let instead of <- would help
09:31:33 <exFalso> rostayob: you just stackoverflow'd
09:31:49 <rostayob> exFalso: don't you have to add :: Bin to Proxy as well?
09:32:06 <tsousa> mjard, yes ok but why do i need an fmap
09:32:10 <exFalso> rostayob: thats what i want to avoid, i -want- that kind to be polymorphic
09:32:29 <exFalso> that Proxy has many applications
09:32:35 <rostayob> exFalso: haskell kinds are not polymorphic
09:32:49 <rostayob> exFalso: maybe PolyKinds?
09:32:50 <ddarius> exFalso: * is a specific kind.
09:33:16 <exFalso> PolyKinds suddenly solved the issue
09:33:22 <exFalso> thank you good sir
09:33:31 <mjga> tsousa reverse list :: [a], fmap reverse list :: m [a], every expression in "do" must have a (Monad m) => m a type
09:33:33 <rostayob> exFalso: I am good, yes.
09:33:44 <ddarius> If you do :k Proxy, it will presumably say forall k. k -> * now.
09:33:47 <monochrom> PolyKinds is a very new extension. also incomplete, in flux, don't hold your breath, etc
09:33:51 <tsousa> mjard, i dont know what an monad is
09:33:53 <ddarius> Before it would've said * -> *.
09:35:06 <mjga> tsousa: Monad a = Complicated action returning type a
09:35:31 <tkahn6_> tsousa: basically calling getLine does a computation in the IO monad, and so you have to promote reverse to be in that IO monad
09:37:11 <mjga> second question: my code QuickChecks okay, but has a bug. How to increase "thoroughness" of QuickCheck testing?
09:37:25 <tsousa> tkahn6_, what is the IO monad?
09:37:32 <rostayob> exFalso: btw, I got the only copy of this http://www.cs.kent.ac.uk/people/staff/sjt/TTFP/ out of the library. Ah.
09:37:55 <donri> mjga: what do you mean?
09:37:57 <tkahn6_> tsousa: it's a way to separate unpure code from pure code
09:38:17 <tsousa> tkahn6_, eheh no ideia what you just said lol
09:38:27 <tkahn6_> tsousa: getting a line of input is not really pure you have to deal with icky things like consoles and files and input streams
09:38:53 <tkahn6_> tsousa: reversing a list is pure, like adding two numbers is pure
09:39:48 <tkahn6_> tsousa: so in order for your pure function to live in that icky unpure world, you have to lift it into that world, that's what fmap does
09:40:05 <tkahn6_> so then reverse can operate on the string that getLines gives you
09:40:14 <tkahn6_> @type getLine
09:40:14 <lambdabot> IO String
09:40:22 <mjga> donri: I have a property that quickchecks okay 90% of runs, so I wonder if my test cases are not generated with a wrong seed or something
09:40:38 <mjga> @type reverse
09:40:39 <lambdabot> forall a. [a] -> [a]
09:40:50 <tkahn6_> that means that getLine returns a String that's inside the IO monad, meaning that it's in that unpure world
09:40:54 <tkahn6_> @type reverse
09:40:55 <lambdabot> forall a. [a] -> [a]
09:41:09 <tkahn6_> @type fmap reverse
09:41:10 <lambdabot> forall a (f :: * -> *). (Functor f) => f [a] -> f [a]
09:41:11 <koeien2> it means that getLine is an action that, when executed, yields a String
09:41:46 <tkahn6_> tsousa: see Learn you a haskell
09:41:48 <koeien2> i'm not sure what you mean by "returns a String that's inside the IO monad"
09:41:48 <tkahn6_> @where LYAH
09:41:48 <lambdabot> http://www.learnyouahaskell.com/
09:42:15 <tsousa> tkahn6_, i am reading it, but he presents that example before monads, monads is only in the next chapter
09:42:20 <tkahn6_> koeien2: are you being obtuse or do you really not know what i mean
09:42:36 <koeien2> tkahn6_: i know it, i should have said that it's misleading imho
09:42:52 * hackagebot serialport 0.4.4 - Cross platform serial port library.  http://hackage.haskell.org/package/serialport-0.4.4 (JorisPutcuyps)
09:42:52 <koeien2> or potentially misleading
09:43:02 <tkahn6_> koeien2: he doesnt' even know why he needs to use fmap, just trying to make it simple, yes it's misleading
09:43:22 <tkahn6_> tsousa: just go through it, it'll be explained
09:43:24 <monochrom> then don't use fmap. it can always be eliminated.
09:43:47 <koeien2> you can just do x <- getLine, and use (reverse x)
09:43:58 <koeien2> or, x <- getLine, let x' = reverse x, and use x'
09:44:22 <monochrom> do { x <- getLine; putStrLn (reverse x) } or getLine >>= \x -> putStrLn (reverse x).
09:46:15 <monochrom> tell the story of (>>=). tell that getLine's semantics is to, in the context of getLine>>=f, pass on the user's line to f. pass on, not "return". similarly, tell that "return 5" means passing on 5, not "return 5".
09:47:43 <monochrom> <monochrom> the point of return is not wrapping either. the point of return is "return 5 >>= f" = "f 5", i.e., so that in the context of >>=, you pass on 5 to the next action.
09:47:44 <monochrom> <johnsingleton> monochrom: Ah! that makes much more sense!
09:47:49 <hpaste> Mike___ pasted ‚Äúdo statement‚Äù at http://hpaste.org/63549
09:48:05 <Mike___>  The last statement in a 'do' block must be an expression    nm <- lerNome
09:48:09 <monochrom> anecdotal evidence that the pass-on story is better, from a few days ago
09:48:12 <Mike___> could I get some hel pleasE? :s
09:48:25 <koeien2> Mike___: yeah, you can't use <- in the last line of a do expression
09:48:32 <Mike___> oh ok, thankyou
09:48:34 <koeien2> Mike___: if you want to test it, add "return ()"
09:48:40 <mjga> Mike___: just add "return nm" in a new line
09:48:40 <Mike___> ok, thanks alot
09:48:44 <koeien2> or remove the "nm <- "
09:48:57 <koeien2> mjga: that doesn't typecheck.
09:50:14 <dougransom> @pl       xval ii = (fromIntegral ii) * width + low
09:50:14 <lambdabot> xval = (low +) . (width *) . fromIntegral
09:50:22 <vyom> I am about to use CmdArgs library for a commandline app.. do you recommend anything else that is better?
09:52:34 <Enigmagic> vyom: i use it for all my apps, it seems like the best one out there
09:52:45 <vyom> Enigmagic: cool.. thanks
09:52:53 * hackagebot digestive-functors 0.2.1.0 - A general way to consume input using applicative functors  http://hackage.haskell.org/package/digestive-functors-0.2.1.0 (JasperVanDerJeugt)
09:55:34 <adimit> vyom: there's also ReadArgs, GHC's getopt, multiarg, ui-command, and probably others.
09:55:40 <adimit> try to look for them on hackage.
09:56:25 <adimit> I've had mixed experiences with cmdargs ‚Äî it's simple on the surface, but can get tedious and inflexible, and I find its defaults hackish.
09:56:48 <adimit> i.e. the annotations are impure, which can lead to frustrating behaviour with multi-modal programs.
09:57:42 <Enigmagic> adimit: there are pure and impure versions
09:57:49 <Enigmagic> modules rather
09:57:54 * hackagebot digestive-functors-snap 0.1.3.0 - Snap backend for the digestive-functors library  http://hackage.haskell.org/package/digestive-functors-snap-0.1.3.0 (JasperVanDerJeugt)
09:58:31 <monochrom> "digestive functor" sounds scary. it sounds like it wants to devour me.
09:58:49 <donri> and then snap your neck
09:59:17 <chairdog> yeah i was just googling it
09:59:22 <adimit> Enigmagic: I know. But the pure annotations aren't as typesafe, plus they're more tedious to write.
09:59:41 <Enigmagic> adimit: have you looked at this? http://hackage.haskell.org/packages/archive/cmdargs/0.9.2/doc/html/System-Console-CmdArgs-Quote.html
10:00:36 <adimit> Enigmagic: yes. It requires template-haskell and I find it pretty complicated ‚Äî overkill for most purposes, really.
10:00:37 <Enigmagic> i think ultimately something like the applicative args parser would be my first choice
10:01:14 <Enigmagic> if all the args parser people would just work on improving one or two packages we'd have a clear winner already :(
10:01:24 <adimit> I agree. I've used cmdargs on several occasions, but haven't been very satisfied with its flexibilty.
10:01:43 <adimit> yeah, but most people like to work on their own code, rather than somebody else's.
10:02:14 <adimit> And then they think "Hey, I know what's easy to write and still missing: a really *good* command line parser. I'm gonna make the best one there is!"
10:02:15 <Enigmagic> i understand why, it's just sad to see 100000 billion nearly identical packages for "easy" problems like args processing
10:02:30 <adimit> And then they see it'snot that easy, and the whole thing is just an ugly bikeshed.
10:02:42 <Enigmagic> *nod*
10:02:49 <chairdog> i used to work in distributed systems monitoring and basically the same thing happened there.
10:03:01 <chairdog> every university had their own implementation of distributed systems monitoring done right.
10:03:21 <adimit> yeah, ultimately I resorted to stuff like config <- liftM (parseWithParsec.concat) getArgs
10:03:56 <adimit> or rather intercalate " ", not concat.
10:04:04 <adimit> or just unwords,
10:06:48 <Enigmagic> what would be nice is a lower level set of cmdargs combinators with the cmdargs generics style crap bolted on top
10:07:09 <adimit> ‚Ä¶ and you're half-way motivated to write your own command args parser now?
10:07:14 <Enigmagic> nah :P
10:07:23 <irene-knapp> @seen chrisdone
10:07:24 <lambdabot> Unknown command, try @list
10:07:28 <irene-knapp> :seen chrisdone
10:07:33 <irene-knapp> preflex: seen chrisdone
10:07:34 <preflex>  chrisdone was last seen on #haskell 14 days, 6 hours, 59 minutes and 45 seconds ago, saying: dzhus: sounds like you're trying to parse it into the wrong type?
10:07:35 <Enigmagic> i only maintain about 20 little apps that work well enough with cmdargs
10:07:49 <Enigmagic> i'd rather spend my time working on other stuff
10:07:50 <donri> preflex: xseen chrisdone
10:07:51 <preflex>  chrisdone was last seen on freenode/#haskell 14 days, 7 hours and 2 seconds ago, saying: dzhus: sounds like you're trying to parse it into the wrong type?
10:15:15 <dougransom> @pl weightedVal x = (fromIntegral x)*(xval x)
10:15:16 <lambdabot> weightedVal = liftM2 (*) fromIntegral xval
10:17:56 * hackagebot hedis-pile 0.4.0 - Caching mandatory data with Redis  http://hackage.haskell.org/package/hedis-pile-0.4.0 (AlexanderDorofeev)
10:19:03 <statusfailed> Hey arch haskellers, how can I use this guy's repo? http://www.kiwilight.com/~magnus/
10:19:06 <exFalso> hmm PolyKinds cant specialise (* -> *) to (SomeKind -> SomeKind)
10:19:16 <statusfailed> someone posted earlier but I had to restart irssi so I lost scollback
10:19:43 <exFalso> statusfailed: just download the pkg.tar.xz
10:19:45 <byorgey> exFalso: I think you mean "generalize"
10:20:09 <statusfailed> exFalso: pacman -U it? ok- how do I remove that package later if I want to?
10:20:11 <byorgey> exFalso: and no, something that constructs a data type will always end with   -> *   even if the input kind can be polymorphic
10:20:36 <donri> statusfailed: https://wiki.archlinux.org/index.php/Pacman#Repositories
10:20:40 <exFalso> statusfailed: yes, and you can just do a pacman upgrade which will downgrade it to 7.0.3
10:21:19 <exFalso> byorgey: well i have a constructor that has kind (Bin -> Bin -> Bin)
10:21:54 <byorgey> exFalso: ok
10:22:07 <exFalso> byorgey: and * -is- the polymorphic kind isnt it? (with -XPolyKinds)
10:22:16 <byorgey> exFalso: no
10:22:22 <byorgey> exFalso: * still means the same as it used to.
10:22:59 * hackagebot wai-middleware-cache-redis 0.1.4 - Redis backend for wai-middleware-cache  http://hackage.haskell.org/package/wai-middleware-cache-redis-0.1.4 (AlexanderDorofeev)
10:23:01 <byorgey> a polymorphic kind would look something like  forall k. k -> k -> * (for example)
10:23:11 <byorgey> not sure exactly the concrete syntax GHC uses to display it.
10:23:57 <byorgey> * -> *  is already as concrete as you can get, there is no polymorphism to specialize
10:24:11 <byorgey> oops, gotta run
10:24:23 <exFalso> byorgey: thanks, i'll read up a bit more on this
10:24:40 <dougransom> @pl weightedYVal  x = (fromIntegral x)* (f . xval) x
10:24:40 <lambdabot> weightedYVal = liftM2 (*) fromIntegral (f . xval)
10:24:42 <statusfailed> donri: I just get "database file does not exist" when I point to http://www.kiwilight.com/~magnus/ghc74/
10:24:57 <statusfailed> with [Magnus]\nServer=http://www.kiwilight.com/~magnus/ghc74/
10:26:04 <statusfailed> I'll just use -U- probably shouldn't rely on random repositories on the net :D
10:26:06 <donri> statusfailed: i think you need to call it ghc74
10:26:35 <statusfailed> donri: you mean with no / ?
10:26:44 <donri> I mean [ghc74] Server = ...
10:26:58 <statusfailed> oh I see
10:26:58 <td123> statusfailed: does he provide the PKGBUILD somewhere?
10:27:05 <stulli> statusfailed: make a pacman -Su or -Suy before
10:27:51 <statusfailed> Hmm, [ghc74] still doesn't work
10:28:05 <statusfailed> td123: there's no PKGBUILD file in that directory
10:28:08 <statusfailed> i'm not sure if that's what you mean
10:28:44 <td123> I mean, I wanted to see how he builds it
10:29:28 <stulli> statusfailed: I ran into the same problem today and a pacman -Suy resolved the problem. Not sure why it doesn't work for you though.
10:30:05 <statusfailed> stulli: oh, because i'm a doofus
10:30:21 <statusfailed> stulli: I didn't let it run long enough and figured "no database file for ghc74" meant on the server
10:30:25 <statusfailed> hurrr.
10:30:34 <statusfailed> thanks :)
10:30:41 <stulli> np :)
10:32:02 <statusfailed> oh weird, what should pacman -S take to identify it? I've tried ghc74, ghc-7.4.1-1.x86_64 and more combinations
10:32:42 <statusfailed> and "ghc" brings up the 7.0.3 version
10:33:06 <exFalso> did you do pacman -Sy?
10:33:32 <exFalso> also, try -Ss ghc for search
10:34:33 <statusfailed> Ah ok, so it's ghc74/ghc
10:34:45 <statusfailed> aaaaaand package ghc-7.4.1-1-x86_64 does not have a valid architecture
10:34:50 <statusfailed> so I guess that was a waste of time :D
10:35:15 <exFalso> do you have a 64bit machine?
10:35:20 <td123> statusfailed: I have a ghc 7.4.1 package available :P
10:35:26 <statusfailed> I do
10:35:34 <statusfailed> (have a 64-bit machine)
10:35:38 <statusfailed> td123: 64bit? :D
10:35:47 <td123> statusfailed: http://pkgbuild.com/~td123/
10:35:51 <statusfailed> <3
10:36:03 <statusfailed> I tried to build from source but I got segfaults :(
10:36:04 <td123> only catch is, you have to use cabal
10:36:10 <statusfailed> wait a minute. DO I have a 64 bit machine?
10:36:17 <td123> lol..
10:36:23 <statusfailed> I forgot i was on a VM D:
10:36:29 <koeien2> lol.
10:36:37 <koeien2> uname -a, you can see it there.
10:36:37 <td123> well I have an i686 pkg also in that dir :P
10:36:45 <statusfailed> <3<3
10:36:48 <Mike___> excuse me, i've been reading abou t random numbers generator
10:36:53 <Mike___> and there is something i dont understand
10:36:54 <Mike___> rollDice :: IO Int   rollDice = getStdRandom (randomR (1,6))
10:37:02 <Mike___> where does the randomR number come from?
10:37:09 <ddarius> > 60 * 800
10:37:10 <lambdabot>   48000
10:37:18 <ddarius> > 48000 / 3500
10:37:19 <lambdabot>   13.714285714285714
10:37:38 <parcs`> Mike___: what do you mean?
10:37:42 <parcs`> what module do is come from
10:37:44 <parcs`> ?
10:37:45 <Mike___> http://hackage.haskell.org/packages/archive/random/1.0.0.2/doc/html/System-Random.html
10:37:49 <Mike___> I read about it here
10:37:54 <Mike___> And saw an example
10:37:56 <exFalso> Mike___: randomR uses the standard seed from getStdRandom to get a number between 1 and 6
10:38:13 <Mike___> oh
10:38:23 <Mike___> Not in scope: `randomR'
10:38:26 <Mike___> But I get that
10:38:29 <exFalso> ah
10:38:37 <exFalso> did you do import System.Random?
10:38:54 <Mike___> oh
10:39:00 <Mike___> ok, it's just like a library
10:39:04 <Mike___> Do I need to download it?
10:39:11 <parcs`> yeah
10:39:12 <statusfailed> oh my god it's a 32 bit machine
10:39:13 <parcs`> cabal install random
10:39:15 <statusfailed> what the fuck!!!
10:39:22 <Mike___> whats cabal install ?!?
10:39:32 <statusfailed> I NEVER KNEW
10:39:53 <exFalso> cabal is a "package manager" for haskell modules
10:40:03 <mauke> parcs`: what if it's already installed?
10:40:03 <Mike___> where is that package manager?
10:40:25 <exFalso> well i think ghc comes with it
10:40:40 <exFalso> just type "cabal install random" in your shell and see what happens :)
10:40:45 <Mike___> Prelude> cabal install random  <interactive>:0:1: Not in scope: `cabal'  <interactive>:0:7: Not in scope: `install'  <interactive>:0:15: Not in scope: `random'
10:40:55 <exFalso> not in ghci, in your shell
10:41:04 <Mike___> im using windows -.-
10:41:11 <exFalso> ah
10:41:20 <exFalso> hmm cant help you then sorry :S
10:41:21 <Mike___> i know, it would be alot easier in linux
10:41:37 <eyebloom> or Mac OS
10:41:53 <mekeor> Mike___: what do you wait for then? install an unix-like OS! ;)
10:41:59 <Mike___> i have one xD
10:42:00 <Mike___> fedora
10:42:08 <mekeor> alright then
10:42:08 <exFalso> http://www.haskell.org/haskellwiki/Cabal-Install#Windows
10:42:16 <Mike___> but atm i have everything on windows
10:42:25 <eyebloom> You should be fine staying on windows.
10:42:26 <Mike___> and have a tight schedule to deliver work
10:42:27 <Mike___> :s
10:42:43 <Mike___> I did use to work alot with linux when I worked
10:42:50 <Mike___> now, i'm studying again, so im back to windows.. :s
10:42:57 <exFalso> i think windows 7 has powershell or something like that
10:43:10 <Enigmagic> it also has something called "command prompt"
10:43:12 <mekeor> studying is actually just a reason for linux, IMO... anyway.
10:43:14 <Enigmagic> it's been around since win95
10:43:26 <Mike___> depends...
10:43:29 <yoaha> and is complete rubbish Enigmagic
10:43:34 <Mike___> on the tools you're using
10:43:38 <Enigmagic> it works just fine for running "cabal install"
10:43:51 <yoaha> fair enough
10:43:51 <Mike___> so am i missing something?
10:44:02 <exFalso> check out the link above
10:44:11 <Mike___> thanks
10:44:16 <mekeor> #haskell is not about OS discussion. we all know that linux is better but for discussing that join ##linux or ##kernel or #gnu or #fsf or #freesoftware
10:44:44 <statusfailed> td123: awsum, I can compile again! thanks!
10:44:47 <companion_cube> #lispmachine
10:45:11 <dougransom> @pl  fdoubletri x = tri3 x + tri4 x
10:45:12 <lambdabot> fdoubletri = liftM2 (+) tri3 tri4
10:45:50 <parcs`> Mike___: import System.Process then type `system "cabal install random"` in ghci
10:46:48 <dougransom> @pl \x->sin x + cos x
10:46:48 <lambdabot> liftM2 (+) sin cos
10:46:51 <Mike___> thatnks alot parcs
10:47:10 <Mike___> i guess i have to update it
10:47:12 <Mike___> but its easy
10:47:26 <td123> statusfailed: np :) I will try to get arch's ghc up to date, and probably drop haskell-platform
10:48:00 <Mike___> parcs`:  just one question. when i execute import System.Process
10:48:03 <Mike___> what does that mean?
10:48:17 <statusfailed> td123: Woohoo! :D
10:48:19 <td123> statusfailed: (I was brought onto the team recently to work on ghc and ruby)
10:48:26 <statusfailed> I'm guessing you were posting on that mailing list thread recently
10:49:04 <parcs`> Mike___: 'import System.Process' brings all the names exported in System.Process to scope
10:50:31 <td123> statusfailed: unfortunately ruby will be worked on first, then ghc :/
10:51:10 <statusfailed> td123: Still, it's good that someone is on the case
10:51:22 <Mike___> Ok, everything is working smooth
10:51:26 <Mike___> but I tried to do something
10:51:31 <Mike___> I wanted to use a pattern with random
10:51:32 <Mike___> rollDice :: Int -> IO Int rollDice i = rollDiceType
10:51:34 <td123> statusfailed: ya, what you have is probably going to be the final version of ghc on arch :P
10:51:37 <Mike___> and i get an error
10:51:55 <Mike___> Couldn't match expected type `IO Int'             with actual type `a0 -> IO a1' In the expression: rollDiceType In an equation for `rollDice': rollDice i = rollDiceType
10:52:01 <statusfailed> td123: good to know! is it just testing that's delaying release then?
10:52:56 <td123> statusfailed: no, the packages which are in the repos are holding it back
10:53:20 <mekeor> where can i look up the minimal complete required functions for a type class (in particular Num and Integral) ?
10:53:49 <statusfailed> td123: Oh right
10:54:04 <td123> statusfailed: I use cabal so I don't get held back though :P
10:54:07 <plucas> Why does ghci segfaul when I give it the input "-1/3" (or hyphen int slash int)? (I understand that -1/3 is not negative one third, but what is causing the segfault?)
10:54:18 <exFalso> Mike___: whats rollDiceType?
10:55:05 <Mike___> It's a pattern that I'm trying to make
10:55:22 <Mike___> to get different random numbers based on the int
10:55:58 <exFalso> you mean you want the int to be the seed for the generator?
10:56:10 <parcs`> plucas: it shouldn't
10:57:01 <plucas> parcs`: so this shouldn't happen?: http://pastebin.com/rpe1vcpq
10:57:03 <mauke> The paste rpe1vcpq has been copied to http://hpaste.org/63553
10:57:12 <Mike___> yup
10:57:44 <Mike___> mvm
10:57:46 <Mike___> i fixed it
10:57:48 <Mike___> mybad
10:57:50 <Mike___> thanks anyway
10:58:04 <exFalso> you dont need to use the IO monad then by the way
10:58:22 <exFalso> as you are providing the seed you dont need the global one
10:59:17 <exFalso> take a look at mkStdGen: http://hackage.haskell.org/packages/archive/random/1.0.0.1/doc/html/System-Random.html
11:01:58 <parcs`> plucas: hmm, ghc 6.10 is pretty old
11:02:03 <parcs`> where are you getting your ghc?
11:02:11 <plucas> parcs`: macports
11:03:05 <plucas> yeah 6.10.4 is the current macports version
11:03:16 <parcs`> i'm not familiar with mac + ghc but i think you should be installing through the haskell platform (http://hackage.haskell.org/platform/mac.html) if you're on a mac
11:03:17 <plucas> maybe I'll get a newer one manually‚Ä¶ wonder if this gets fixed
11:03:59 <ksf> @hoogle k -> Mak k a -> [a]
11:04:00 <lambdabot> Warning: Unknown type Mak
11:04:00 <lambdabot> Data.Graph.Inductive.Query.BFS bfs :: Graph gr => Node -> gr a b -> [Node]
11:04:00 <lambdabot> Data.Graph.Inductive.Graph newNodes :: Graph gr => Int -> gr a b -> [Node]
11:04:04 <ksf> @hoogle k -> Map k a -> [a]
11:04:05 <lambdabot> Data.Map (!) :: Ord k => Map k a -> k -> a
11:04:05 <lambdabot> Data.Map findWithDefault :: Ord k => a -> k -> Map k a -> a
11:04:05 <lambdabot> Data.Map member :: Ord k => k -> Map k a -> Bool
11:04:12 <plucas> ok - I thought on one of the haskell.org pages it suggested macports as an option
11:04:13 <plucas> thanks
11:04:47 <ksf> lookupMany?
11:05:04 <ksf> should be needed often enough to warrant a definition.
11:08:16 <magicman> What do you expect it to do? A "Map k a" only has at most one 'a' per 'k'.
11:08:29 <kallisti> awwww yeah
11:09:27 <irene-knapp> > showHex 169 ""
11:09:27 <lambdabot>   "a9"
11:13:21 <Peaker> The MonadPlus instance of IO is non-sense, isn't it?  launchMissiles >> mzero /= mzero
11:14:35 <Peaker> it seems the law that:  x >> mzero = mzero    is a bit restrictive (The effects must be discard-able)
11:14:55 <Enigmagic> iirc one of the monadplus functions just calls error
11:15:56 <hpaste> Mike___ pasted ‚Äúrandom‚Äù at http://hpaste.org/63554
11:16:04 <Enigmagic> maybe i'm thinking of something else
11:16:31 <Mike___> Is there any type of cast I can do to get rid of this error
11:16:32 <Mike___>  Couldn't match expected type `Int' with actual type `IO a0'  In the return type of a call of `rollDiceType'  In the expression: rollDiceType (i)  In an equation for `rollDice': rollDice i = rollDiceType (i)
11:16:42 <Enigmagic> i seem to recall guard working for IO but i don't have a MonadPlus IO instance on my system now..
11:17:14 <Peaker> Control.Monad.Error has an instance, iirc
11:17:24 <Peaker> that uses IO exceptions
11:18:32 <Mike___> I'm trying to put into r an Int type, but that function only return Int IO
11:20:08 <Enigmagic> Peaker: yep that's the one
11:20:19 <Enigmagic> i like the informative error when it fails too :^) *** Exception: user error (mzero)
11:20:24 <Mike___> I'm sorry if I'm still not thinking properly about my problems -.- But I'm still trying to get into Haskell :s
11:21:36 <mekeor> where can i look up minimal complete definitions (of type classes)?  (in particular, the hackage site of Prelude doesnt mention the minimal complete definition of Enum.)
11:23:08 <sanjoyd> mekeor: I'd ask djinn. :)
11:23:10 <Peaker> Enigmagic: isn't that an IO exception?
11:23:17 <mekeor> sanjoyd: how?
11:23:20 <mekeor> @djinn Enum
11:23:21 <lambdabot> Error: Undefined type Enum
11:23:33 <Enigmagic> Peaker: yeah
11:24:11 <Peaker> it must be, because mplus successfully catches it
11:24:11 <sanjoyd> mekeor: what are the functions that are needed to declare a type an Enum?
11:25:12 <sanjoyd> @djinn a->a
11:25:12 <lambdabot> f a = a
11:25:17 <sanjoyd> @djinn Int->a
11:25:18 <lambdabot> Error: Undefined type Int
11:25:31 <sanjoyd> Okay, I don't think I know what I was talking about.
11:25:42 <sanjoyd> Is there some way I can "tell" djinn about pre-existing types?
11:25:50 <sanjoyd> @djinn (Num t)=>t->a
11:25:51 <lambdabot> Error: Class not found: Num
11:25:57 <sanjoyd> :/
11:26:03 <Eduard_Munteanu> @djinn () -> a
11:26:03 <lambdabot> -- f cannot be realized.
11:26:21 <Eduard_Munteanu> Pretty much the same thing :)
11:26:30 <sanjoyd> Yeah.
11:26:44 <sanjoyd> But is there some way I could tell djinn about pre-existing types?
11:27:04 <Eduard_Munteanu> Dunno about that, haven't used it much.
11:27:45 <geekosaur> I don't believe so, at least not as implemented in lambdabot
11:28:16 <otters> @djinn a -> b
11:28:16 <lambdabot> -- f cannot be realized.
11:28:23 <otters> @djinn a -> [a]
11:28:23 <lambdabot> Error: Undefined type []
11:28:32 <otters> so djinn doesn't do anything useful?
11:28:46 <Eduard_Munteanu> BTW, is "f cannot be realized" a positive disproof?
11:28:56 <Eduard_Munteanu> Or just "I couldn't make it"?
11:29:02 <otters> as in, a -> b cannot exist?
11:29:11 <sipa> can you come up with an example?
11:29:12 <azaq23> @djinn (a -> b) -> a
11:29:13 <lambdabot> -- f cannot be realized.
11:29:13 <Eduard_Munteanu> Yeah.
11:29:13 <sanjoyd> otters: not without assuming something about b, I think.
11:29:15 <sipa> except const undefined?
11:29:26 <otters> uh
11:29:29 <otters> assuming b isn't a
11:29:35 <Eduard_Munteanu> No, not taking undefined into account.
11:29:37 <otters> just const b
11:29:53 <azaq23> @djinn (a -> b) -> (b -> c) -> a -> c
11:29:53 <lambdabot> f a b c = b (a c)
11:29:54 <Eduard_Munteanu> I'm asking if djinn deals with decidable propositions.
11:29:54 <otters> > let f x = 3 in f "foo"
11:29:55 <lambdabot>   3
11:30:08 <magicman> @djinn (a -> a) -> a
11:30:09 <lambdabot> -- f cannot be realized.
11:30:20 <magicman> Apparently it doesn't do fix :p
11:30:23 <dolio> Eduard_Munteanu: If the algorithm doesn't find an implementation, there isn't one.
11:30:25 <Peaker> azaq23: flip (.)
11:30:31 <Eduard_Munteanu> I see, thanks.
11:30:37 <cmccann> Eduard_Munteanu, pretty sure that if djinn says it can't be realized then it's impossible as a total function
11:30:40 <sanjoyd> dolio: but can't use that to prove anything?
11:30:53 <sanjoyd> dolio: as in, curry-howard + godel?
11:30:55 <cmccann> djinn does indeed ignore fix and won't use it
11:31:03 <dolio> It's a meta-theoretic property.
11:31:09 <Eduard_Munteanu> @djinn (() -> a) -> Void
11:31:09 <lambdabot> -- f cannot be realized.
11:31:19 <dolio> It doesn't mean that there's a proof of the negation of the theorem.
11:31:20 <sanjoyd> dolio: what is a meta-theoretic property?
11:31:24 <Eduard_Munteanu> Yeah, I see.
11:31:40 <Eduard_Munteanu> At least not from within djinn.
11:32:00 <dolio> The language djinn deals in isn't as strong as Peano Arithmetic, either.
11:32:26 <dolio> Or Robinson arithmetic.
11:32:51 <dolio> It's propositional logic.
11:32:51 <Eduard_Munteanu> Presumably that's one reason you can't stick arbitrary definitions into it.
11:33:24 <sanjoyd> dolio: but then we'd have functions that can be defined whose definitions djinn can't figure out, right?  Like fix, above?
11:33:40 <dolio> fix doesn't exist in djinn.
11:33:47 <Peaker> sanjoyd: "fix" is not a total function
11:33:57 * sanjoyd looks up total function.
11:34:46 * ddarius needs a heavier kettlebell.
11:34:59 <irene-knapp> oh
11:35:04 <irene-knapp> a weightlifting thingy
11:35:06 <irene-knapp> had to google it
11:35:38 <sanjoyd> Peaker: so djinn can derive only those functions which are provably terminating?
11:36:08 <dolio> It can decide theorems in propositional logic.
11:36:12 <cmccann> sanjoyd, yes, but deriving non-total functions is much easier.
11:36:16 <cmccann> just use "undefined" for everything.
11:36:25 <sanjoyd> cmccann: right.
11:36:26 <dolio> Which correspond to certain Haskell types.
11:36:50 <dolio> Or, theorem schemas, more accurately, I guess.
11:37:19 <ddarius> We can Skolemize to get theorems.
11:37:23 <dolio> @djinn Either a (Not a)
11:37:24 <lambdabot> -- f cannot be realized.
11:37:31 <dolio> @djinn Not (Either a (Not a))
11:37:31 <lambdabot> -- f cannot be realized.
11:37:44 <dolio> Only intuitionistic theorems, too.
11:37:46 <sanjoyd> I have a hunch that Godel's theorem and fixed point combinators are deeply related somehow -- both use the idea of self-reference to introduce chaos.  Unfortunately I don't know enough math to go beyond this.
11:37:47 <cmccann> @djinn (Either a (a -> r) -> r) -> r
11:37:47 <lambdabot> f a = a (Right (\ b -> a (Left b)))
11:38:05 <ddarius> @djinn-add class EM a where em :: Either a (Not a)
11:38:13 <ddarius> @djinn ((a -> b) -> a) -> a
11:38:14 <lambdabot> -- f cannot be realized.
11:38:40 <ddarius> @djinn Not (Not a) -> a
11:38:40 <lambdabot> -- f cannot be realized.
11:38:46 <ddarius> Oh, duh.
11:38:54 <ddarius> @djinn EM a => ((a -> b) -> a) -> a
11:38:54 <lambdabot> f a =
11:38:55 <lambdabot>     case em of
11:38:55 <lambdabot>     Left b -> b
11:38:55 <lambdabot>     Right c -> a (\ d -> void (c d))
11:39:10 <sanjoyd> @djinn-add data List a = Cons a (List a) | Nil
11:39:10 <lambdabot> Error: Recursive types are not allowed: List
11:39:36 <ddarius> @djinn EM a => Not (Not a) -> a
11:39:36 <lambdabot> f a =
11:39:37 <lambdabot>     case em of
11:39:37 <lambdabot>     Left b -> b
11:39:37 <lambdabot>     Right c -> void (a c)
11:41:29 <Peaker> is the law "m >>= (\x -> mzero) == mzero" really useful? It ruins it for IO, ST, and any monad that has irreversible effects
11:41:58 <dolio> No. Lots of MonadPlusses don't follow it.
11:42:08 <ddarius> @djinn ((a -> b -> b) -> a -> l -> b) -> l -> Maybe b
11:42:08 <lambdabot> f _ _ = Nothing
11:42:23 <Taneb> Is a semigroup just a monoid without mzero?
11:42:27 <dolio> mzero is only consistently a left zero.
11:42:41 <dolio> Taneb: Yes.
11:42:42 <ddarius> @djinn (l -> Maybe (a, l)) -> ((a -> b -> b) -> a -> l -> b) -> l -> Maybe b
11:42:42 <lambdabot> f a b c =
11:42:43 <lambdabot>     case a c of
11:42:43 <lambdabot>     Nothing -> Nothing
11:42:43 <lambdabot>     Just (d, e) -> Just (b (\ _ f -> f) d e)
11:43:21 <Taneb> And a MonadPlus is a Monad that is a Monoid
11:44:40 <dolio> It's a Monad m such that (m a) is a monoid forall a, and the monoid structure interacts with the monad structure in a certain way.
11:44:47 <dolio> To make it sort of ring-like.
11:45:10 <Mike___> Can someone give me a little help with my random? :S
11:48:00 * hackagebot highlighting-kate 0.5.0.3 - Syntax highlighting  http://hackage.haskell.org/package/highlighting-kate-0.5.0.3 (JohnMacFarlane)
11:51:28 <th0b0r0> hey there. I'm having some nasty problems with regex-posix atm. Running regex-posix-0.95.1 and regex-base-0.93.2. Unfortunately, I can't do a ' "foo" =~ "foo" :: Bool ' after importing Text.Regex.Posix.
11:51:31 <hpaste> th0b0r0 pasted ‚Äúregex-base issue‚Äù at http://hpaste.org/63556
11:51:32 <th0b0r0> Any ideas?
11:52:56 <th0b0r0> oh and running ghc 7.0.2
11:56:59 <Sgeo> Why am I looking at a language that is fanatical about point-free?
11:57:21 <Sgeo> @pl \a b c -> c b a
11:57:21 <lambdabot> flip (flip . flip id)
11:58:09 <clsmith> what is lambdabot's 'djinn'?
11:58:29 <clsmith> inferring the code from the type?
11:58:46 <elliott> yes
11:58:53 <elliott> @djinn (a -> b -> c) -> (b -> a -> c)
11:58:53 <lambdabot> f a b c = a c b
11:59:01 <clsmith> that is incredibly fantastic
11:59:14 <elliott> it's just a toy, it's not really actually useful :P
11:59:17 <elliott> (most of the time)
11:59:53 <clsmith> the best things in life are toys :3
12:01:32 <clsmith> :djinn b -> (a -> b) -> Maybe a -> b
12:01:41 <Taneb> @djinn (a -> b) -> (a, a) -> (b, b)
12:01:42 <lambdabot> f a (b, _) = (a b, a b)
12:01:47 <clsmith> @djinn b -> (a -> b) -> Maybe a -> b
12:01:47 <lambdabot> f a b c =
12:01:48 <lambdabot>     case c of
12:01:48 <lambdabot>     Nothing -> a
12:01:48 <lambdabot>     Just d -> b d
12:02:02 <clsmith> amazing.
12:02:03 <clsmith> :p
12:02:11 <ddarius> There are a lot of things Djinn can be usefully used for.
12:02:59 <ddarius> The idea also generalizes (albeit not to a complete procedure usually) and is the basis for the "term inference" in many dependently typed languages like Agda, as well as (semi-)automated theorem provers in general.
12:04:37 <hpaste> Mike___ pasted ‚Äúrubik‚Äù at http://hpaste.org/63557
12:04:55 <Mike___> Can someone please point me what am I doing wrong with that pattern? q_q
12:08:43 <clsmith> Mike___: are you sure you want to 'do' anything?
12:08:47 <nand`> http://pastebin.com/VG17WQW9
12:08:54 <Mike___> yeah i fixed that
12:09:00 <nand`> I can't figure out what's wrong here
12:09:01 <Mike___> and the (n) brakcet
12:10:04 <Mike___> I was trying to simplefy my code with patterns
12:10:04 <clsmith> Mike___: ok.
12:10:09 <Mike___> I have it working in another way
12:11:10 <Mike___> I could really use some help working with random though : /
12:11:22 <Mike___> I've been trying to get it to work, and nothing
12:12:48 <hpaste> Mike___ pasted ‚Äúrandom‚Äù at http://hpaste.org/63559
12:20:18 <fryguybob> Mike___: Perhaps you want to use randomRIO.
12:20:32 <Mike___> hmm, what is that?
12:20:35 <noddy2OOO> e
12:20:42 <noddy2OOO> (sorry)
12:20:50 <fryguybob> instead of getStdRandom (randomR ...)
12:21:55 <Mike___> oh..
12:22:12 <fryguybob> Instead of an if in  baralhaCubo  use a guard
12:22:14 <scolobb> :t randomRIO
12:22:15 <lambdabot> forall a. (Random a) => (a, a) -> IO a
12:22:40 <scolobb> Gives you a value in a range of values
12:22:58 <fryguybob> > let f n | n < 1 = "less" | otherwise = "more" in (f 0, f 5)
12:22:59 <lambdabot>   ("less","more")
12:25:04 <SubtleArray> Good day, Haskellers. Just a quick, minor question. I made 2 functions: returnLowers = nub.map (filter isLower) and lowerCase = nub.map (map toLower). Is there a way to write these 2 functions as 1 function?
12:25:51 <hpaste> Mike__ pasted ‚Äúrandom‚Äù at http://hpaste.org/63560
12:25:55 <alpounet> SubtleArray, what do you mean?
12:26:02 <Mike___> is that what you meant fryguybob ?
12:26:12 <Mike___> I still can't get it to work
12:26:29 <alpounet> @type nub . map (filter isLower)
12:26:30 <lambdabot> [[Char]] -> [[Char]]
12:26:32 <scolobb> SubtleArray: You can of course parametrise the whole stuff
12:26:39 <alpounet> @type nub . map (map toLower)
12:26:40 <lambdabot> [[Char]] -> [[Char]]
12:26:49 <scolobb> doSomething f1 f2 = nub.map (f1 f2)
12:26:55 <alpounet> they have the same type but don't do the same thing
12:26:57 <scolobb> But why would you need that?
12:27:44 <scolobb> As alpounet says, these are essentially different functions; can't see a point in writing them as a single function
12:27:53 <SubtleArray> alpounet: I'm trying to create a function that strips the numbers and characters from a list, and then lower cases everything to make it easier for the pattern matching I want to do.
12:28:27 <fryguybob> Mike___: No
12:28:31 <SubtleArray> The maybe sloppy way I'm doing it works. :D I was just wondering if I could combine my 2 lovely functions into 1 nicer function.
12:28:45 <dougransom> @pl add_tuple (a1,a2) (b1,b2) = (a1+a2,b1+b2)
12:28:46 <lambdabot> add_tuple = uncurry (flip flip snd . (ap .) . flip flip fst . ((.) .) . flip flip (+) . (((.) . (.) . (,)) .) . (+))
12:28:59 <dougransom> lol
12:29:38 <fryguybob> Mike___: randomRIO  and the type of  rollDice :: Int -> IO Int
12:29:56 <parcs`> Mike___: have you read LYAH yet?
12:30:13 <Mike___> parcs`: quick read -.-
12:31:05 <alpounet> SubtleArray, what's the point of the "filter isLower" then?
12:31:25 <SubtleArray> scolobb: I'm trying to process user input. To make it easier, I need to strip out any symbols, and lower case everything.
12:31:30 <alpounet> if in the end it's gonna get lowered anyway.
12:31:48 <otters> what an elegant function
12:31:50 <alpounet> or maybe i misunderstood your question.
12:33:08 <SubtleArray> alpounet: The program basically works like this: The user will type in a sentence. That sentence is turned into a list of words. And those words are pattern matched to generate a response. It's very crude natural language processing.
12:33:43 <SubtleArray> alpounet: But to make it work, I need to lowercase the user's input, and get rid of all symbols. Lol
12:33:52 <zomg> Regex? :P
12:33:59 <parcs`> Mike___: reading LYAH will help you understand the basics better than this channel will
12:34:21 <Mike___> I just thought random would be easy to use -.-
12:34:26 <Mike___> And that I had missed something
12:34:27 <parcs`> it is
12:35:08 <parcs`> you missed LYAH :)
12:35:18 <Mike___> i thought it would be like. randomnum :: Int -> Int n = random(10)
12:35:22 <Mike___> or somthing like that
12:35:31 <elliott> no, it's just that asking 1000 questions here is marginally more efficient than reading LYAH because people keep answering them
12:35:31 <zzo38> Can someone who has the new GHC please modify my "extensible-data" package to work with it and then upload another version but with a setting that tells it not to download onto computers with the old GHC?
12:35:31 <SubtleArray> Mike___: I highly recommend this video series as well. http://bit.ly/c9functional It's helped me a lot.
12:35:37 <parcs`> no, go read LYAH to understand why
12:35:52 <zzo38> So that my version will be downloaded on computer with old GHC?
12:35:54 <scolobb> SubtleArray: I'm sorry, I have to be away right now, so consider me out :-(
12:35:59 <JiXiY> @pl (\x -> drop 1 (map (split ";") (lines x)) )
12:35:59 <lambdabot> drop 1 . map (split ";") . lines
12:36:06 <elliott> zzo38: why not just make it work on both GHCs
12:36:07 * monochrom has stopped answering
12:36:16 <elliott> zzo38: your only problem is a too-restrictive version constraint
12:36:18 <elliott> afaict
12:36:34 <alpounet> SubtleArray, ok so maybe you should filter out all the symbols you don't want, byfor example doing filter (\c -> not (c `elem` "abcdef...etc...ABCDEF...etc..."))
12:36:56 <alpounet> and then just apply your map toLower
12:37:24 <monochrom> anyway, randomRIO is as easy to use as getLine
12:37:33 <fryguybob> Mike___: If it was like that your function would not always give the same value when given the same input.
12:37:34 <Mike___> SubtleArray: thanks
12:37:42 <otters> :t split
12:37:43 <lambdabot> forall g. (RandomGen g) => g -> (g, g)
12:37:47 <zzo38> elliott: As far as I know there are two problems with that: [1] The new Any type has a kind parameter [2] Reifying class instances is different type
12:38:34 <SubtleArray> alpounet: That's kind of what I'm doing. :D My functions work fine, they just look awful. Lol. Or maybe they look fine?
12:39:07 <alpounet> SubtleArray, well, having your two functions isn't really necessary i think
12:39:16 <alpounet> since you would nub & map twice
12:39:19 <alpounet> you're doing smth like
12:39:22 <elliott> zzo38: well, you can use CPP
12:39:24 <kallisti> elliott: people are asking and answering questions about a programming language on a programming language channel? I'm shocked.
12:39:30 <alpounet> nub . map f and then nub . map g
12:39:31 <elliott> #if __GLASGOW_HASKELL__ < 741 or something
12:39:32 <kallisti> horrified even.
12:39:45 <SubtleArray> alpounet: Exactly.
12:39:48 <alpounet> SubtleArray, so you could probably do nub . map (f . g) ?
12:39:54 <elliott> kallisti: that is not the same as trying to write a program without even basic knowledge of the language and asking a question every time it goes wrong because you're too lazy to read LYAH
12:39:57 <alpounet> well, g . f
12:40:07 <SubtleArray> alpounet: brb - I'll give it a try.
12:40:27 <kallisti> elliott: hey man, if they already know C, then they basically know every programming language.
12:40:33 <kallisti> why bother reading stuff.
12:40:54 <dougransom> @pl add_tuple (a1,a2) (b1,b2) = (a1+b1,a2+b2)
12:40:55 <lambdabot> add_tuple = uncurry (flip flip snd . (ap .) . flip flip fst . ((.) .) . (. (+)) . flip . (((.) . (,)) .) . (+))
12:41:30 <monochrom> fewer and fewer people know C, actually
12:41:42 <kallisti> C++, maybe?
12:42:07 <monochrom> fewer and fewer people know C++, too
12:42:40 <Enigmagic> because they're dying?
12:42:55 <Enigmagic> i'll probably know C++ for at least another 40 or 50 years
12:43:00 <dougransom> @pl       temp = [( x*(f x), f x )| nn<-[0..n-1], let x = xval nn ]
12:43:01 <lambdabot> (line 1, column 6):
12:43:01 <kallisti> I wouldn't say they're dying. becoming less common, sure.
12:43:01 <lambdabot> unexpected "="
12:43:01 <lambdabot> expecting variable, "(", operator or end of input
12:43:16 * ddarius would be very surprised if the number of C or C++ programmers was decreasing.
12:43:26 <ddarius> Particularly C.
12:43:46 <dougransom> @pl      temp = [( x*(f x), f x )| nn<-[0..n-1], let x = xval nn ]
12:43:46 <lambdabot> (line 1, column 6):
12:43:46 <lambdabot> unexpected "="
12:43:47 <lambdabot> expecting variable, "(", operator or end of input
12:44:05 <dougransom> @pl       [( x*(f x), f x )| nn<-[0..n-1], let x = xval nn ]
12:44:06 <lambdabot> (line 1, column 1):
12:44:06 <lambdabot> unexpected "["
12:44:06 <lambdabot> expecting white space, "()", natural, identifier, lambda abstraction or expression
12:44:09 <kallisti> don't most colleges use C++ in their curriculum at some point? Isn't that still a thing?
12:44:17 <Enigmagic> i don't think pointfree works with list comprehensions
12:44:17 <zzo38> elliott: I don't really like using CPP with Haskell it is messy and something. In addition, I cannot find documentation for the new type of reified class instances in Template Haskell (it says the name of the type but not its description). And even then I can't test it. Can you test it?
12:44:32 * kallisti took data structures last semester in C++.
12:44:34 <monochrom> people forget things, too
12:44:35 <dougransom> Engigmagic: I think you are right.
12:44:40 <kallisti> I would say that it's pretty well-suited for a data structures course.
12:44:43 <elliott> zzo38: no.
12:44:52 <kallisti> better than say, Python. or Java even.
12:44:55 <alpounet> Enigmagic, yeah, but are you using C++ often?
12:45:02 <Enigmagic> alpounet: yes
12:45:08 <Enigmagic> haskell, c++ and python
12:45:18 <Enigmagic> in that order
12:45:26 <zzo38> Who people in here have GHC 7.4?
12:45:33 <alpounet> Enigmagic, not so long ago, i wrote some C++. I hadn't written any in two years.
12:45:39 <alpounet> oh man, i felt stupid.
12:45:51 <ddarius> C#, C++, Haskell, x86 assembly are my typical languages of choice, though the first only for work.
12:46:34 <monochrom> if you used C for a few course at school 40 years ago, but since then it's all COBOL job for you and you stopped touching C (even for leisure) since then, I won't say you still know C
12:46:42 <kallisti> what did Microsoft gain out of creating C#?
12:46:48 <alpounet> Enigmagic, of course, i still know C++ pretty well, but i just forgot about some subtleties, some traps etc
12:47:04 <ddarius> kallisti: Some use out of all there JVM implementation technology.
12:47:22 <ddarius> Also, C# is way better than Java.  C# has significantly improved my opinion of Microsoft.
12:47:33 <kallisti> well, sure. I'm just wondering what the material gain was.
12:47:40 <ddarius> C# is also -the- Microsoft language currently.
12:47:41 <kallisti> to invest (I assume) money into its design and implementation.
12:47:58 <ddarius> kallisti: They had already invested the time and money.
12:47:58 <Enigmagic> ddarius: no technology was carried over from their jvm to the clr. experience maybe but no code
12:48:27 <Enigmagic> due to lawsuits etc
12:48:51 <ddarius> The experience is very likely much more valuable than the code.
12:48:52 <monochrom> higher C# mindshare means less software written for non-windows
12:49:06 <kallisti> has anyone used F#? I've never really put time into learning anything about it.
12:49:14 <SubtleArray> alpounet: I can't get it to work. I don't want to waste too much of your time on this. I'll put it to the side and try to figure something out later. Thank you for the help.
12:49:32 <Enigmagic> ddarius: for design yeah but it's still $$$ to start from scratch
12:49:39 <clsmith> F# has loops and stuff. weird.
12:49:49 <monochrom> of course, there is also a dose of NIH
12:50:11 <kallisti> clsmith: yes as far as I know it's intended to be multi-paradigm.
12:50:37 <zzo38> I generally prefer to use programming language make it working with many operating systems. This includes C, and Haskell, and AWK, and TeX, and a few others. TeX is a completely frozen programming language and Plain TeX is a frozen format file; all documents written with it work as well 20 years ago as it will 100 years in the future.
12:50:45 <ddarius> Enigmagic: Yes, but savings on maintenance cost and being able to escape from the shadow of backwards compatibility that strangles Java has its value too.
12:51:06 <clsmith> zzo38: and yet TeX is a complete ugly macrohack ;p
12:51:49 <monochrom> C‚ôØ :)
12:52:13 <clsmith> i don't quite understand the obsession with VMs
12:52:16 <zzo38> clsmith: I happen to like TeX (especially Plain TeX), and METAFONT. METAFONT is best program for typefaces and logos. There is no need using others
12:52:32 <clsmith> sure, they can runtime optimise a little, but they're much slower to start, take tons of memory, and i think are much more work
12:53:42 <clsmith> i suppose they might provide easier debugging? i don't know really.
12:53:51 <ddarius> clsmith: They also allow you to port code relatively trivially and they give the VM designer a large amount of control over what the VM can access.  It is also much easier to do reflection.
12:54:10 <ddarius> It also saves work on backends.  F#, C#, and VB.NET all target the CLR.
12:54:59 <zzo38> One format likely to run on many computers is the iNES format, although bugs in emulators might cause some programs to fail in some emulators (or even on real NES/Famicom hardware). Some emulators are very badly written especially ones in DVD players, from what I have read.
12:55:07 <clsmith> a shared modular backend would do the same thing, like GCC does. reflection is a good point though
12:55:37 <ddarius> A shared backend would only give you the savings on backends.
12:56:50 <ddarius> It's not clear what other options you or kallisti feel Microsoft should have taken instead.
12:57:31 <zzo38> I cannot even get C preprocessor to work in a reasonable way with literate Haskell. Do you know if there is a way to make custom (-pgmF) preprocessors access C preprocessor symbols?
12:57:46 <clsmith> oh, i'm not particularly biased there. i'm just talking about how, for instance, i like how haskell compiles to machine code instead of having to have VM architectures like JVM/CLR
12:58:01 * hackagebot system-fileio 0.2.5 - Consistent filesystem interaction across GHC versions  http://hackage.haskell.org/package/system-fileio-0.2.5 (JohnMillikin)
12:58:03 * hackagebot system-fileio 0.3.5 - Consistent filesystem interaction across GHC versions  http://hackage.haskell.org/package/system-fileio-0.3.5 (JohnMillikin)
12:58:25 <zzo38> It isn't filesystem interaction which is the problem......
12:58:30 <clsmith> 0.2.5 was short-lived
12:58:40 <monochrom> heh
13:00:19 <zzo38> But still, the differences in the Any type and in Template Haskell are the differences. Can someone with GHC 7.4 please try to manually install my package from source to see if it works?
13:00:46 <ion> 0.2.5 is probably a maintenance release for a ‚Äú0.2‚Äù branch.
13:01:06 <clsmith> oh, probably
13:01:09 <ddarius> Mr. Ion being Mr. Reasonable.  Pshaw.
13:01:16 <clsmith> lol
13:03:55 <ddarius> GCC allegedly has a CLI front-end (as well as backend), so you could compile .NET languages to machine code.  You can sort of do that with csc, but I don't think you can get an independent executable out of it.
13:04:37 <Enigmagic> ngen doesn't produce an independent executable
13:05:34 <ddarius> Enigmagic: I know, but that doesn't mean some other tool couldn't cut it out of the assembly and add a basic CLR (lacking the JIT components.)
13:05:57 <ddarius> But I don't think such a tool exists, at least in any supported manner.
13:06:05 <Enigmagic> ddarius: there are cases where the ngen code can't be used iirc
13:06:20 <Enigmagic> where the clr will still fall back on the jit
13:06:59 <Enigmagic> main benefits for ngen are image sharing, faster startup times and potentially better optimized code
13:07:01 <Sgeo> What similarities/differences do Factor models have with FRP?
13:07:44 <clsmith> hmm, would reflection in haskell 'make sense'? i suppose it would, but would be monadic?
13:08:21 <ddarius> clsmith: Some things (particularly updates) would need to be, other things don't need to be (particularly basic introspection.)
13:08:39 <Peaker> Wouldn't use of Typeable classify as a sort of reflection?
13:08:46 <ddarius> Things like Typeable and Data already provide basic introspection.
13:09:20 <dougransom> @pl    t0 = TestCase (assertNearlyEqual (centroid tri1 testDomain npoints)  testCentre)
13:09:21 <lambdabot> t0 = TestCase (assertNearlyEqual (centroid tri1 testDomain npoints) testCentre)
13:09:30 <donri> also TH/reify in some cases
13:13:01 * hackagebot http-proxy 0.0.9 - A library for writing HTTP and HTTPS proxies  http://hackage.haskell.org/package/http-proxy-0.0.9 (ErikDeCastroLopo)
13:13:44 <danmaftei> how come `print` doesn't handle UTF-8 input but `putStr` does? (using ghci)
13:14:00 <elliott> danmaftei: how does print not handle utf-8 input?
13:14:01 <rostayob> danmaftei: print = putStrLn . show
13:14:11 <rostayob> @src print
13:14:11 <lambdabot> print x = putStrLn (show x)
13:14:27 <rostayob> danmaftei: there is no difference watsoever in terms of encoding.
13:14:35 <danmaftei> ok, so it's about show then
13:14:39 <rostayob> danmaftei: yes.
13:14:42 <rostayob> if you're showing strings
13:14:52 <danmaftei> well, i don't know unicode that well, but it shows up as \xyz
13:14:54 <elliott> danmaftei: if you mean that it escapes certain characters, then yes, it does
13:14:55 <danmaftei> xyz are digits
13:14:58 <elliott> because show produces a string literal
13:15:02 <rostayob> danmaftei: yes, it escapes them
13:15:04 <elliott> it is for debugging purposes
13:15:10 <elliott> what is the problem and what behaviour do you desires?
13:15:13 <elliott> *desire
13:15:36 <rostayob> danmaftei: if you have Strings, use putStrLn. If you want to show strings that way and other values with Show, you're in trouble.
13:15:46 <danmaftei> oh, no problem, i was just curious. i am reading multi-lingual corpora and would like to print parts of my data structures to stdout, but i can use putStr for that
13:15:56 <rostayob> possible escapes: type classes + UndecidableDependencies, Typeable
13:16:06 <rostayob> danmaftei: ok :)
13:16:49 <danmaftei> so what is it about string literals that causes certain characters to be escaped? and, which ones get escaped? (non-ascii?)
13:17:14 <elliott> it's just for debugging
13:17:22 <elliott> imagine if it printed control codes in ghci when you tried to show a binary string
13:17:39 <elliott> print is not for general output, it is for debugging / cheap serialisation
13:17:45 <rostayob> danmaftei: not only non-ascii, a lot of non-letters
13:17:50 <danmaftei> ahh
13:18:01 <danmaftei> thanks
13:18:03 <alpounet> SubtleArray, well ok. If you wanna get back to this, just ask here, pasting your code. But if it's working and efficient enough, that's fine i guess :)
13:18:04 <rostayob> > show "\\"
13:18:04 <lambdabot>   "\"\\\\\""
13:18:33 <hiptobecubic> I have a list of strings and I want to print them all to stdout.   At first I thought  map putStrLn list, but map isn't monadic. So then I thought something with liftM, but I'm not sure I get how that works
13:18:38 <hpaste> doug pasted ‚Äúlong line‚Äù at http://hpaste.org/63561
13:18:49 <rostayob> hpaste: mapM_
13:18:50 <donri> mapM_
13:18:52 <ion> @type mapM_
13:18:52 <lambdabot> forall a (m :: * -> *) b. (Monad m) => (a -> m b) -> [a] -> m ()
13:19:01 <rostayob> yes. it's definitely mapM_.
13:19:31 <ion> Yes. mapM_ indubitably.
13:19:33 <dougransom> how do I syntactically enter a list or statement that is longer than one line in my text editor (i.e. http://hpaste.org/63561)
13:20:03 <rostayob> dougransom: [ blah\n, foo\n, bar ]?
13:20:21 <rostayob> you  can even do newlines when applying functions
13:20:36 <hiptobecubic> thanks
13:20:51 <rostayob> main = foo
13:20:53 <rostayob>        bar
13:20:57 <rostayob> dougransom: ^^^ this would work
13:21:14 <danmaftei> my other encoding question is, i've got some old europarl corpora here in ISO-8859-x (french, greek, estonian, etc.) i can readFile just fine, but trying to print to stdout (with either putStr or print) gives me 'hGetContents: invalid argument (invalid byte sequence)'. does hGetContents expect only a particular encoding, and thus quits ungracefully on other input?
13:21:40 <danmaftei> (i iconv-ed them into UTF-8, so this is another curiosity question)
13:21:44 <donri> readFile is likely getting the preferred system encoding
13:21:45 <dougransom> I see, I misunderstood the indentation.  tx.
13:22:02 <donri> look into the text and bytestring packages
13:23:23 <monochrom> but then usually the preferred system encoding is UTF-8
13:23:41 <rostayob> dougransom: emacs helps with indentation. actually, emacs helps, period.
13:24:23 <ion> Is Emacs the most absorbent pad?
13:24:27 <fritschy>   
13:24:32 <fritschy> sorry ;)
13:24:37 <rostayob> ion: yes.
13:24:38 <Jeanne-Kamikaze> is it me or did someone push a version of haddock to hackage that requires a ghc version that hasn't been released, rendering all packages that rely on haddock broken ?
13:24:38 <monochrom> dougransom: indent line 3 to be deeper than line 2, that's all you need
13:24:51 <elliott> Jeanne-Kamikaze: GHC 7.4.1 has been released.
13:25:13 <elliott> I don't quite understand what you mean by "broken", though.
13:25:30 <Jeanne-Kamikaze> won't install because it doesn't satisfy that restriction
13:25:38 <elliott> You should not install Haddock.
13:25:39 <monochrom> haddock comes with GHC. try not to "cabal install haddock". except if you know what you're doing.
13:25:40 <elliott> It's a boot lib.
13:25:45 <rostayob> Jeanne-Kamikaze: the current haddock is for GHC 7.2. also, haskell platform.
13:25:54 <elliott> monochrom: even if you do not know what you are doing, is upgrading a boot lib ever a good idea?
13:25:55 <Jeanne-Kamikaze> funny enough. I'm running arch linux and this is the first time I don't get an update early
13:26:11 <elliott> Arch's GHC is two versions behind.
13:26:18 <monochrom> upgrading a boot lib is a crime
13:26:23 <elliott> it's on 7.0.3, there has been 7.0.4, 7.2.1, 7.2.2, 7.4.1 since then
13:26:29 <rostayob> upgrading a boot lib: not even once.
13:26:34 <Jeanne-Kamikaze> then the package maintainer will have a taste of my wrath
13:26:47 <rostayob> Jeanne-Kamikaze: also, *do not mix distro and cabal packages*.
13:26:53 <dougransom> @pl intersect f1 f2 x = min (f1 x) (f2 x)
13:26:53 <lambdabot> intersect = liftM2 min
13:26:56 <rostayob> that's a crime as well, and the haskellpolice will get you.
13:27:08 <rostayob> Jeanne-Kamikaze: the best thing is to go with the stock binaries + cabal.
13:27:17 <Jeanne-Kamikaze> well cabal only lists ghc 7.0.3
13:27:23 <ion> Hear, hear
13:27:40 <elliott> Jeanne-Kamikaze: 7.2.1 was in testing but 7.2 was pretty buggy, so it disappeared.
13:27:48 <Jeanne-Kamikaze> I'm not sure if I should cabal install cabal, since cabal install I've installed from the distro's repos
13:27:55 <ion> I tend to install GHC from the binary to ~/.ghc and cabal-install to ~/.cabal. Works very nicely.
13:28:15 <ion> ‚Ä¶and make sure no distro packages are installed.
13:28:15 <nand`> How can I pass extra flags to cabal for it to pass to GHC when building? Like -XFlexibleInstances
13:28:41 <rostayob> nand`: what do you mean "to cabal"?
13:28:47 <rostayob> in cabal files? Language-Extensions
13:28:54 <ion> nand: It‚Äôs documented in Cabal‚Äôs documentation, but you‚Äôll more likely want {-# LANGUAGE FlexibleInstances #-} in the source files instead.
13:28:55 <nand`> I meant at command line
13:29:01 <Jeanne-Kamikaze> alright then I'ma get the cabal and ghc from hackage then, thanks for the tips
13:29:14 <rostayob> nand`: what does that mean? mass options to what?
13:29:18 <nand`> ion: They're not my source files, I guess I can edit them
13:29:21 <poltak> Hello. Is this the appropriate place to ask for assistance with a tiny problem on my xmonad config (xmonad.hs)? Or should I find an #xmonad channel?
13:29:21 <rostayob> when you do cabal install?
13:29:25 <nand`> rostayob: yes
13:29:34 <rostayob> nand`: why would you want to do that?
13:29:38 <clsmith> poltak: an xmonad channel is probably better :p
13:29:42 <rostayob> put language pragmas at the top of the files
13:30:03 <nand`> rostayob: because it's not my project yet it fails to build, the error says XFlexibleInstances may help so I want to quickly test that
13:30:22 <elliott> Jeanne-Kamikaze: You can't get GHC from Hackage.
13:30:26 <nand`> if the file does require it I'm wondering why it isn't there already
13:30:28 <ion> jeanne-kamikaze: The cabal-install package still hasn‚Äôt been updated. If you get GHC 7.4.1, install cabal-install from here: darcs get http://darcs.haskell.org/cabal/
13:30:40 <elliott> nand`: --ghc-options="-XFlexibleInstances"
13:30:45 <rostayob> nand`: mhm. maybe it's old source code that assumed -fglasgow-exts?
13:30:48 <elliott> 7.2/7.4 (one of the two) changed semantics.
13:30:53 <elliott> rostayob: It's TypeSynonymInstances.
13:31:04 <elliott> It used to let you give an instance that expanded to a flexible one without giving FlexibleInstances.
13:31:06 <rostayob> elliott: mh?
13:31:12 <elliott> instance Foo String -- worked without FlexibleInstances
13:31:12 <Peaker> I don't understand why breaking Num constraints is OK but adding Applicative superclass for Monad is taboo
13:31:16 <elliott> yet instance Foo [Char] would not
13:31:23 <rostayob> elliott: oh. ok
13:31:30 <rostayob> when did this change?
13:31:38 <elliott> Peaker: the argument I've seen is "but then what about when we discover a mid-way element in the hierarchy?", which seems ludicrous
13:31:42 <elliott> rostayob: 7.2/7.4, I forget which
13:31:43 <shachaf> elliott: How can instance Foo String work?
13:31:46 <poltak> clsmith: alright, thanks :)
13:31:49 <elliott> shachaf: ?
13:31:52 <Peaker> elliott: then we can make it more fine-grained
13:32:06 <rostayob> shachaf: with TypeSynonimInstances it did
13:32:20 <shachaf> How does it makes sense for it work without FlexibleInstances?
13:32:28 <nand`> elliott: thanks. That made it build
13:32:43 <nand`> that would also explain why it won't build for me
13:32:47 <nand`> I'll message the maintainer
13:32:52 <rostayob> shachaf: who knows. but I remember it working, actually.
13:32:55 <elliott> shachaf: It just did.
13:32:56 <elliott> It was a bug.
13:32:59 <elliott> That's why it was fixed.
13:33:01 * hackagebot hmpfr 0.3.3.1 - Haskell binding to the MPFR library  http://hackage.haskell.org/package/hmpfr-0.3.3.1 (MichalKonecny)
13:33:30 <shachaf> elliott: Oh, I see.
13:33:39 <shachaf> I thought you meant it was added on purpose.
13:33:59 <shachaf> This is why type synonyms should use CPP instead of being part of the langauge.
13:34:54 <th0b0r0> Heya. If I've got a data type called MyData and have implemented the (+) function from the Num class. What do I need to do to make it work with foldl/foldr? ghc tells me that I need to implmeent the Num [MyData] class. but how would I go about this?
13:35:33 <donri> are there some famous monads besides Q that are not currently applicatives?
13:36:11 <SubtleArray> alpounet: Will do. I plan on posting the source code after its done, and I was just worried about offending other Haskellers with the redundancy in the code. :D But it works fine, so I probably shouldn't worry.
13:36:15 <shachaf> th0b0r0: You sound confused.
13:36:20 <th0b0r0> shachaf: oh i am.
13:36:28 <shachaf> th0b0r0: You should probably provide more context, in that case.
13:36:34 <shachaf> What does "work with foldl/foldr" mean?
13:36:37 <ion> Prelude.fold{l,r} only work with lists. If you want it to behave like lists, make it an instance of Foldable and use its functions. But this is probably what you *actually* want.
13:36:46 <ion> err. probably *not* what you actually want.
13:37:06 <nand`> What is ‚ÄúMyData‚Äù?
13:37:47 <th0b0r0> MyData is a data type.
13:37:51 <th0b0r0> just called it MyData here.
13:38:06 <elliott> donri: no
13:38:12 <elliott> well, hmm, maybe STM?
13:38:16 <elliott> no, I think that's Applicative too
13:38:40 <th0b0r0> Now what I've done is add an implementation for (+) in Num MyData and therefore can manually add two instances of MyData. but I can't do foldl/foldr.
13:38:51 <th0b0r0> does that make any more sense?
13:38:55 <rostayob> th0b0r0: no.
13:38:56 <rwbarton> not really
13:38:57 <rostayob> :t foldr
13:38:58 <lambdabot> forall a b. (a -> b -> b) -> b -> [a] -> b
13:39:06 <rostayob> th0b0r0: foldr has nothing to do with the Num class.
13:39:07 <rwbarton> however you probably just left out the initial value for the fold or something
13:39:17 <rostayob> th0b0r0: so your problem lies elsewhere :)
13:39:24 <rwbarton> like foldl (+) xs when you meant foldl (+) 0 xs
13:39:37 <th0b0r0> rwbarton: thanks.
13:40:19 <th0b0r0> rwbarton: forgot the initial value :S
13:40:19 <cmccann> elliott, so I found the(?) hackage2 source sitting around in a darcs repo
13:41:09 <donri> http://code.haskell.org/hackage-server/ should be it
13:41:28 <osager> hi all how to exit a function in haskell ? for example if n==1 then exit
13:41:37 <nand`> return ()
13:41:38 * nand` ducks
13:41:42 <osager> ok
13:41:49 <nand`> osager: that may or may not be waht you want
13:41:50 <cmccann> donri, yeah
13:41:52 <osager> let me try
13:42:07 <shachaf> osager: nand` is saying deliberately wrong things for the sake of a joke.
13:42:10 <donri> osager: you need to produce some value of the correct type
13:42:11 <shachaf> It happens a lot in this channel.
13:42:12 <ion> osager: What does your code look like currently?
13:42:13 <elliott> cmccann: now we just need to take control of hackage.haskell.org
13:42:15 <osager> my function type is
13:42:26 <osager> fun:: Int-> IO ()
13:42:27 <cmccann> elliott, take a look: http://hackage2.uptoisomorphism.net:8080/
13:42:30 <shachaf> What do you actually want to do?
13:42:34 <shachaf> Exit the program?
13:42:36 <nand`> shachaf: what, me saying deliberately wrong things or people saying deliberately wrong things?
13:42:41 <donri> osager: in the case of IO (), return () can certainly be what you want
13:42:43 <nand`> and that wasn't necessarily wrong
13:43:07 <nand`> I just don't know if it was appropriate
13:43:16 <elliott> cmccann: that's the best set of packages you could possibly choose
13:43:19 <rwbarton> you should think of 'fun' as a function which returns an IO action (which indeed it is)
13:43:21 * elliott sets cabal-install to use it
13:43:28 <nand`> osager: if your function is recursive, then return () will essentially ‚Äúreturn‚Äù from the recursion
13:43:31 <elliott> cmccann: wow, this is so much faster than the official hackage
13:43:33 <rwbarton> you always have to return an action, but that action can be 'return ()' which does nothing
13:43:37 <Peaker> osager: What does your function do?
13:43:49 <elliott> you can browse the tarballs online?! :D
13:43:50 <cmccann> elliott, yes, I hand-picked only the best
13:43:53 <nand`> for example, let f 0 = return (); f n = f (n-1) in f 5
13:44:02 <ion> cmccann: Oh, btw, did you notice my message about Proxy?
13:44:14 <donri> return puts a value in a monadic context, it doesn't short-circuit or anything
13:44:16 <osager> Peaker: my function will terminate if n == 1, but it does nothing when it terminates
13:44:16 <nand`> or for something more useful, f n = putStrLn "foobar" >> f (n-1)
13:44:24 <cmccann> ion, don't think so, what was it?
13:44:26 <Peaker> osager: what does your function do if n /= 1?
13:44:38 <elliott> cmccann: this just makes me want it on the main site :( ... as long as the awkward "Reverse dependencies" thing gets fixed
13:44:43 <osager> it is recursive
13:45:07 <Peaker> osager: functions always return a value, throw an error or turn in an infinite recursion/loop -- there is no "terminate" :)
13:45:11 <osager> let me just try return ()
13:45:22 <Peaker> osager: it's better to understand what you are doing than to randomly try things out :)
13:45:28 <nand`> Peaker: except when it segfaults
13:45:33 <osager> :)
13:45:34 <cmccann> elliott, I'm not sure how complete it is, I just hacked a couple things to get it built and put it on EC2 :P
13:45:58 <Peaker> osager: what is the purpose of your function, or the type of your function?
13:46:00 <osager> i'm trying to implement this small cycle length algorithm
13:46:08 <osager> let me describe it to you
13:46:09 <nand`> the type is Int -> IO ()
13:46:11 <ion> cmccann: I was just wondering whether it would be useful for Overture to provide alternative versions of Prelude functions that take a value only for its type, taking a Proxy instead. Or even replace those Prelude functions. At least floatRadix, floatDigits and floatRange are like that. See e.g. https://gist.github.com/1188115
13:46:33 <osager> 1:input n
13:46:37 <osager> 2 print n
13:46:41 <elliott> ion: haha, fixP is an awesome function
13:46:46 <osager> 3: if n = 1 then STOP
13:47:02 <elliott> ion: (though you could define it more simply as ($ Proxy))
13:47:11 <osager> else if n is odd then n<-3*n+1
13:47:19 <osager> else n<-n div 2
13:47:35 <nand`> osager 1 = return (); osager n = print n >> if odd n then osager (3*n+1) else osager (n `div` 2)
13:47:44 <nand`> osager: but I wouldn't do it that way
13:48:09 <ion> elliott: I feel somehow a bit safer if the actual implementation makes it behave correctly even without a type annotation. :-)
13:48:13 * elliott whispers: scanl
13:48:20 <nand`> osager: in your situation I would write a function Int -> [Int]
13:48:28 <nand`> then separate the ‚Äúoutputting‚Äù part from the ‚Äúcalculation‚Äù part
13:49:01 <nand`> osager 1 = []; osager n | odd n = n : osager (3*n+1) | even n = n : osager (n `div` 2)
13:49:51 <cmccann> ion, hm, yeah I think that's a good idea overall
13:50:35 <Peaker> osager: you should separate the input/output part from the computational part
13:50:50 <osager> i would love to do it
13:50:54 <osager> but no idea how
13:51:03 <sir_blunderbrain> \help
13:51:13 <osager> because as the computation goes along, i'd like to see some itermediate results
13:51:20 <osager> and then i have to use IO
13:51:22 <donri> you can use Debug.Trace for that
13:51:25 <osager> to print stuff
13:51:36 <shachaf> No, you don't need to use Debug.Trace.
13:51:45 <nand`> osager: nope, lazy calculations
13:51:53 <shachaf> Well, depends on what you want to do.
13:52:14 <elliott> nand`'s first osager can be implemented with nand`'s second osager, and the former fits osager's pseudocode.
13:52:18 <osager> wait, let me write the algorithm in hpaste
13:52:34 <hpaste> scooty-puff pasted ‚ÄúGADT and Phantom type issues..‚Äù at http://hpaste.org/63564
13:52:35 <nand`> let osager 1 = []; osager n | odd n = n : osager (3*n+1) | even n = n : osager (n `div` 2) in osager 5
13:52:38 <nand`> > let osager 1 = []; osager n | odd n = n : osager (3*n+1) | even n = n : osager (n `div` 2) in osager 5
13:52:39 <lambdabot>   [5,16,8,4,2]
13:52:46 <nand`> ah
13:52:49 <nand`> > let osager 1 = [1]; osager n | odd n = n : osager (3*n+1) | even n = n : osager (n `div` 2) in osager 5
13:52:50 <lambdabot>   [5,16,8,4,2,1]
13:53:03 <nand`> then just output elements from that list one at a time
13:53:30 <scooty-puff> anyone have any advice for the previous paste?
13:53:50 <scooty-puff> can give code if the error message isn't enough
13:54:11 <hpaste> osager pasted ‚Äúpseudo code‚Äù at http://hpaste.org/63565
13:54:20 <elliott> osager: we already saw that
13:54:57 <osager> elliott: i left out the last line
13:55:07 <osager> in my direct past here
13:55:30 * nand` is tempted to write a solution with IORefs and continuations just to match the pseudocode accurately
13:55:50 <rwbarton> think how easy it would be in the BASIC DSL
13:55:52 <dougransom> @pl fuzzy_union f1 f2 x  =  max (f1 x) (f2 x)
13:55:53 <lambdabot> fuzzy_union = liftM2 max
13:56:36 <Pseudonym> S' max
13:57:54 <ksion> Is there a package that lists all Hackage modules as namespace tree, similar to http://www.haskell.org/ghc/docs/latest/html/libraries/ for those shipped with GHC?
13:58:01 <ksion> s/package/page
13:59:20 <flebron> Hey. The reason one can see foldl not working on infinite lists is that one has ? f x_3 $ f x_3 $ f x_2 $ f x_1 start, but short citcuiting the evaluation of this expression can't happen: There's no first function call that could short circuit. In contrast, in foldr, one has f x_1 $ f x_2 $ f x_3 $ ?, so if f x_i _ = k for some constant k and index i, then the computation can stop at the ith step without looking any further. Is
13:59:20 <flebron>  this analysis correct?
14:00:01 <cmccann> flebron, it's not really about short-circuiting
14:00:31 <donri> ksion: http://lambda.haskell.org/platform/doc/current/index.html for the platform is a start
14:00:32 <cmccann> flebron, but otherwise I think you have the basic idea, the outermost function application effectively needs the entire list
14:00:46 <osager> sorry pc failure just now
14:00:48 <hpaste> nand` annotated ‚Äúpseudo code‚Äù with ‚Äúpseudo code (annotation)‚Äù at http://hpaste.org/63565#a63566
14:00:49 <donri> ksion: you can also configure cabal to generate haddock with a shared index for packages you install
14:00:51 <osager> did anyone just reply to me ?
14:01:03 <flebron> Right, there is no outermost function application in a foldl on an infinite list.
14:01:06 <nand`> osager: see my paste
14:01:15 <osager> ok
14:01:23 <ksion> donri: Oh, that would be pretty cool too.
14:02:01 <Jafet> > foldl1 f [a,b,c,d,e]
14:02:02 <lambdabot>   f (f (f (f a b) c) d) e
14:02:05 <Jafet> > foldr1 f [a,b,c,d,e]
14:02:06 <lambdabot>   f a (f b (f c (f d e)))
14:02:32 <flebron> If one discovers that f x_i y = k, that still doesn't tell one what to do about the f x_{i+1} k that one has to do next, unless one uses some sort of inductive argument, far outside the realm of current compilers.
14:02:45 <donri> ksion: distros also tend to do this for you somewhere in /usr/share/doc
14:02:57 <elliott> <donri> ksion: you can also configure cabal to generate haddock with a shared index for packages you install
14:03:01 <elliott> No... no you can't.
14:03:01 * hackagebot hmpfr 0.3.3.2 - Haskell binding to the MPFR library  http://hackage.haskell.org/package/hmpfr-0.3.3.2 (MichalKonecny)
14:03:04 * hackagebot hmpfr 0.3.3.3 - Haskell binding to the MPFR library  http://hackage.haskell.org/package/hmpfr-0.3.3.3 (MichalKonecny)
14:03:13 <donri> elliott: oh?
14:03:17 <elliott> I mean, it generates haddocks, but I've never seen any index.
14:03:29 <elliott> (Also it can't do the source links, making it fairly useless :( )
14:03:41 <cmccann> flebron, well there might possibly be an outermost function application on a possibly infinite list. how do you know? better check the next list element and see...
14:03:46 <donri> well fedora has file:///usr/share/doc/ghc/html/libraries/index.html which is automatically kept updated
14:03:55 <donri> perhaps that's haddock not cabal, though
14:04:04 <cmccann> elliott, huh? I have a huge index of every package I have installed
14:04:09 <elliott> hmm
14:04:14 <elliott> I didn't realise cabal-install made an index, but KO
14:04:15 <elliott> *OK
14:04:18 <elliott> maybe I've just not looked hard enough :)
14:04:32 <donri> elliott: you can pass arbitrary options to haddock from cabal-install
14:04:41 <cmccann> it's ~/.cabal/share/doc/index.html on my machine
14:04:44 <b0fh_ua> @pl \x -> (x,x)
14:04:45 <lambdabot> join (,)
14:04:46 <donri> --haddock-option or something like that
14:04:52 <elliott> donri: sure, if you want to pass it every single time you install :P
14:05:04 <donri> alias? :P
14:05:04 <flebron> cmccann: Right, so unless you do some sort of inductive argument saying "I needn't bother checking", you still need to check f x_{i+1} k.
14:05:19 <Jafet> @pl \x -> (fromIntegral x, fromIntegral x)
14:05:19 <lambdabot> liftM2 (,) fromIntegral fromIntegral
14:05:28 <flebron> Does this have a generalization in terms of catamorphisms?
14:05:54 <cmccann> flebron, and while "you" could do that sort of argument, GHC can't, so yes
14:06:03 <flebron> Right.
14:06:22 <cmccann> flebron, a catamorphism presumes a finite structure and would be a right fold anyway I expect
14:06:27 <Jafet> You can try, armed with a StablePtr
14:06:44 <masylum> hi
14:08:47 <hpaste> masylum pasted ‚Äúforce evaluate IO‚Äù at http://hpaste.org/63567
14:09:17 <masylum> I'm really new to haskell
14:09:28 <masylum> and I came across with a doubt
14:09:56 <cmccann> @faq can Haskell put masylum's mind at ease?
14:09:57 <lambdabot> The answer is: Yes! Haskell can do that.
14:09:59 <masylum> if I have a list of IO (), how can force to evaluate it?
14:10:05 <elliott> oh boy
14:10:06 <monochrom> doubt is good. keep that doubt. doubt all languages.
14:10:06 <cmccann> masylum, mapM_
14:10:09 <cmccann> :t mapM_
14:10:10 <lambdabot> forall a (m :: * -> *) b. (Monad m) => (a -> m b) -> [a] -> m ()
14:10:16 <elliott> masylum: "force to evaluate" is the wrong terminology
14:10:18 <c_wraith> not sequence_ ?
14:10:22 <elliott> evaluation and forcing is irrelevant
14:10:22 <cmccann> er
14:10:26 <cmccann> yes, sequence_
14:10:27 <masylum> what would be a better term?
14:10:28 <cmccann> sorry
14:10:36 <monochrom> "execute"
14:10:40 <masylum> ok
14:11:19 <masylum> gonna investigate about mapM_ :)
14:11:31 <elliott> sequence_ is more appropriate here.
14:11:34 <elliott> :t sequence_
14:11:35 <lambdabot> forall (m :: * -> *) a. (Monad m) => [m a] -> m ()
14:12:05 <alpounet> SubtleArray, come on, you won't offend people by writing Haskell code!
14:12:39 <osager> anyone know what does mapM_ print means ?
14:12:54 <osager> there is no print function
14:12:56 <osager> in haskell
14:13:00 <c_wraith> :t print
14:13:00 <elliott> Yes.
14:13:01 <lambdabot> forall a. (Show a) => a -> IO ()
14:13:02 <elliott> There is.
14:13:07 <c_wraith> that looks like a function to me
14:13:13 <osager> ok
14:13:27 <osager> i've always heard putStrLn
14:13:48 <masylum> terrific! sequence works like a charm!
14:13:49 <osager> and the underscore after mapM
14:13:53 <zzo38> If you have GHC 7.4 then please notify me; so that you can help me to figure out what changes to make to "extensible-data" package making it work with both old version and new version of GHC
14:13:54 <osager> is it necessary ?
14:14:32 <c_wraith> :t mapM_
14:14:33 <lambdabot> forall a (m :: * -> *) b. (Monad m) => (a -> m b) -> [a] -> m ()
14:14:36 <c_wraith> :t mapM
14:14:37 <lambdabot> forall a (m :: * -> *) b. (Monad m) => (a -> m b) -> [a] -> m [b]
14:14:41 <osager> ok
14:14:45 <osager> wow
14:14:47 <c_wraith> not *necessary*
14:14:50 <c_wraith> But cleaner
14:14:56 <c_wraith> It makes it clear you're ignoring the return value
14:15:02 <osager> such subtle difference
14:16:16 <monochrom> wrong. the underscore is very necessary. unless you care nothing about consuming memory. or about the aspect of infinite lists ruining termination.
14:16:26 <monochrom> s/aspect/prospect/
14:16:45 <osager> i havn't read the chapter on monad yet in real world haskell so i didnt run into this yet
14:16:45 <monochrom> s/termination/production/
14:16:48 <osager> lol
14:16:57 <c_wraith> infinite lists ruin the prospect of termination in mapM_ print, too
14:17:09 <monochrom> yes, I have a correction
14:19:42 <monochrom> mapM and sequence remember a lot of things for building a new list to give back to you later, so that you have the joy of throwing it away. mapM_ and sequence_ deny you that pleasure.
14:19:45 <osager> thanks everyone, this is a great place
14:19:48 <osager> goodnight
14:20:24 <zzo38>  Please help me to make my package work on GHC 7.4 but I still want it to work in old version too
14:22:07 <Jafet> But if the list isn't bound to any name, isn't it promptly forgotten?
14:22:14 <Jafet> @src sequence
14:22:14 <lambdabot> sequence []     = return []
14:22:14 <lambdabot> sequence (x:xs) = do v <- x; vs <- sequence xs; return (v:vs)
14:22:15 <lambdabot> -- OR: sequence = foldr (liftM2 (:)) (return [])
14:22:56 <monochrom> also it may excite you to know that they do not build the list gradually, but rather they remember information in some other format, and only at the end convert that information to the list, which is to say they do more than twice as much work as you think. all the more ecstacy for you when you trash it all
14:23:17 * elliott is elated personally
14:24:38 <monochrom> it is promptly forgotten, only after all the energy is spent
14:24:55 <arthuraa> I'm trying to install dclabel compiling with ghc 7.4.1 and I'm getting an error about the SafeImports extension not being recognized... what should I do?
14:25:27 * cmccann suggests raging against the heavens
14:25:34 <zhasha> what's the current preference for drawing vector graphics?
14:25:44 <arthuraa> done that already... XD
14:25:50 <monochrom> try ghc 7.0.4 instead
14:26:18 <arthuraa> monochrom: I was doing that before, but then I was getting another error when compiling one of its dependencies... =(
14:26:48 <cmccann> elliott, btw, did you mess around with the site at all? I didn't look at it much beyond getting it running
14:27:00 <elliott> cmccann: well, I clicked a bunch of links :P
14:27:15 <arthuraa> I think it was related to the CApiFfi extension
14:27:31 <cmccann> elliott, oh well that sounds pretty thorough then.
14:28:20 <cmccann> but it had so many useful packages to install!
14:28:26 <monochrom> the huge amount of memory occupied is also promptly freed, I might add
14:28:29 <elliott> I already have all of those installed! Well, not really.
14:31:28 <Peaker> What happened to haskell.org that ghc downloads became reasonable/fast?
14:32:17 <Peaker> I wish we didn't need to create suffixedByUnderscore_ variants, with a bit of optimization/rewrite-rule technology
14:32:33 <monochrom> general lost of interest in Haskell so that you have little or no competition :)
14:32:46 <Peaker> heh.. ghc 7.4 is awesome ;-)
14:32:50 <cmccann> avoid success! :D
14:32:50 <Peaker> Love all the changes I've seen yet
14:33:20 <Peaker> if they only fix Monad to subclass Applicative, that would be a brave release :)
14:33:29 <elliott> <Peaker> I wish we didn't need to create suffixedByUnderscore_ variants, with a bit of optimization/rewrite-rule technology
14:33:35 <elliott> Peaker: but mapM_ has really different semantics to mapM
14:33:46 <elliott> IMO blurring that distinction is a bad thing
14:33:49 <randomclown> man the arch linux packagers are never gonna update ghc
14:33:54 <Peaker> elliott: How are the semantics different for type-var a=() ?
14:34:01 <elliott> like relying on foldl (+) 0 to work thanks to strictness analysis
14:34:02 <elliott> Peaker:
14:34:04 <elliott> @src mapM
14:34:04 <lambdabot> mapM f as = sequence (map f as)
14:34:07 <elliott> @src sequence
14:34:07 <lambdabot> sequence []     = return []
14:34:08 <lambdabot> sequence (x:xs) = do v <- x; vs <- sequence xs; return (v:vs)
14:34:08 <lambdabot> -- OR: sequence = foldr (liftM2 (:)) (return [])
14:34:08 <elliott> @src sequence_
14:34:09 <lambdabot> sequence_ ms = foldr (>>) (return ()) ms
14:34:21 <monochrom> Control.State.Lazy can show you the different semantics of sequence and sequence_. in fact, sequence is cheaper and more terminating in this case.
14:34:36 <elliott> I would be very surprised if no "m" differs in behaviour there
14:34:47 <elliott> it seems like sequence could easily "get stuck' when sequence_ wouldn't, though I have no evidence
14:34:55 <elliott> Peaker: anyway, massive space complexity difference in any case
14:34:57 <Peaker> elliott: the only difference is that mapM will return a list that's equivalent to a natural
14:35:20 <monochrom> err nevermind, wrong comparison
14:35:45 <elliott> Peaker: I bet sequence vs. sequence_ in something like the lazy state monad can be showed to differ
14:35:49 <Peaker> elliott: the space-use difference is really a GC issue IMO.. The result of mapM coule be deduced unreachable before mapM finishes running
14:36:26 <Peaker> The reason I started caring about sequence vs. sequence_   is when I started writing Parsec parsers
14:36:42 <Peaker> suddenly, I needed a "skip" version of each parser, to not accumulate the result -- which meant a *lot* of code duplication
14:36:57 <Peaker> in Parsec's case, the framework could automate it by composing a skip-parser alongside a real parser
14:37:18 <Peaker> but ghc could actually deduce it in the general case, for the simply-typed cases which throw the results away
14:37:30 <zhasha> what does everyone use for rendering vector graphics?
14:37:40 * elliott wonders if you can prove sequence_ = void . sequence with the monad laws
14:37:46 <Peaker> zhasha: I use graphics-drawingcombinators for my graphics' needs
14:37:49 <elliott> zhasha: diagrams?
14:38:05 <Peaker> elliott: or the Applicative laws (sequence does not need Monad)
14:38:56 <Peaker> graphics-drawingcombinators is a beautiful library.. it misses cropping though, we intend to add it when we need it in our project
14:42:33 <lispy> cmccann: rehash here then?
14:42:40 <cmccann> if you want
14:42:51 <cmccann> I mean, I'm completely clueless
14:42:59 <cmccann> I just compiled some stuff and put it on EC2 :P
14:43:17 * cmccann tends to operate on the basis of "I do what I must because I can"
14:43:34 <lispy> heh
14:43:38 <lispy> cmccann: Well, this is cool
14:43:42 <CodeWeaverX> For the sake of all of us?
14:43:50 <lispy> cmccann: I like that I can add tags
14:43:57 <cmccann> I have no idea who is, has, or intends to do things with it at this point
14:44:04 <cmccann> the last activity in the darcs repo was months ago I think
14:44:11 <kallisti> hm
14:44:12 <lispy> star ratings w/comments would be nice too, like amazon book reviews.
14:44:27 <lispy> cmccann: from the hackathon I would presume
14:44:31 <kallisti> couldn't you generalize the idea of overloaded numeric constructors to constructors of any ADT?
14:44:32 <cmccann> I'm sorely tempted to dump the code into my github and start hacking on it but I'm not sure if that would be rude
14:44:39 <lispy> kallisti: yes
14:44:47 <elliott> cmccann: I say go for it
14:44:49 <cmccann> lispy, and a few months after that it looked like. but not much else.
14:44:50 <kallisti> so.... we should have that. :P
14:44:58 <elliott> cmccann: if what edwardk says is true it is basically abandoned
14:45:02 <Peaker> cmccann: why would it be rude to fork on github?
14:45:07 <lispy> kallisti: that would actually be an interesting thing.  If done well, then it would make DSLs very easy.  It could also make it hard to reason about Haskell code :(
14:45:35 <kallisti> it would also allow you to pattern match on "abstract" constructors.
14:45:51 <kallisti> which I think would be quite nice. For example, pattern matching on things that have a notion of uncons.
14:45:56 <cmccann> Peaker, well it was in darcs originally so some people might not appreciate that :P
14:45:58 <Jafet> kallisti: fromInteger :: Integer -> MyADT
14:46:01 <lispy> cmccann: I think dcoutts would like to avoid moving it to github, but I would be more inclined to contribute from there. The ideal is to use a 2-way conversion like darcs-bridge
14:46:14 <cmccann> yeah, thing is
14:46:18 <cmccann> github is nice for getting contributions
14:46:23 <lispy> Yes
14:46:29 <kallisti> Jafet: I'm not sure what you're trying to say.
14:46:45 <Jafet> Me neither
14:46:49 <lispy> I've had like 10x the pull requests compared to the number of dpatches I received, in less time to boot.
14:46:51 <cmccann> and frankly I think community involvement is more important at this point than leaving it in darcs
14:46:52 <kallisti> that's.. how you would do it I suppose.
14:47:13 <cmccann> but I don't know if that's really my call to make and I don't want to step on toes
14:47:33 <lispy> cmccann: Well, it's always possible to send patches back up stream, right?
14:47:36 <Peaker> cmccann: sending patches back to darcs should be easy?
14:47:37 <kallisti> class From a b where from :: a -> b
14:47:48 <lispy> cmccann: even if it's just running darcs record in the git repo, right?
14:48:17 <lispy> cmccann: More importantantly, if you did it and got traction on github then it won't matter.
14:48:24 <kallisti> and then, basically, the from call happens implicitly when referring to the constructors of type b.
14:48:25 <cmccann> to be honest I've never used darcs and haven't been motivated to learn so far
14:48:27 <elliott> cmccann: It's open source, man.
14:48:31 <lispy> cmccann: They are looking for a maintainer
14:48:41 <kallisti> also, I guess, you would need the inverse in order to do pattern matching, or am I mistaken?
14:48:51 <elliott> It sounds like the main obstacle to Hackage2 is that nobody wants to maintain an instance of it.
14:48:52 <monochrom> yes, need inverse
14:48:53 <Peaker> cmccann: I don't know darcs well, but this sentence made it easy for me: "darcs repo is just a set of patches" :)
14:49:00 <cmccann> elliott, open source doesn't mean there can't be ill will and hurt feelings :P
14:49:10 <elliott> cmccann: But it does mean you can revel in them!
14:49:17 <cmccann> ... >:[
14:49:25 <zzo38> I changed the base version for my package how long will it take to report a build failure?
14:49:31 <Mike___> Hello again. I'm getting a parse error, when trying to write to a file. Everything compiles right, and when it tries to write I get an error. Would anyone mind to give a look?
14:49:44 <lispy> cmccann: Anyway, I don't see why it creates hurt feelings. You're not competing with the other repo as you'd still be able to share changes with them
14:49:48 <Peaker> cmccann: it's a nicer model than git, in theory (in practice it works less well in various ways)
14:49:49 <monochrom> open source warfare. battlefield 2012.
14:50:00 <mike-burns> cmccann: Email the existing maintainer and tell him what you're doing.
14:50:08 <cmccann> Peaker, I suppose not, but revision control is sort of a holy war topic
14:50:10 <Peaker> in git you have both merge (tracked history, have to take all) and cherry-picking (untracked history, can take any),  in darcs you just have cherry-picking (tracked history, can take any) and guarantees that if you take same patches, you get same result, no linearization of history
14:50:20 <cmccann> mike-burns, good idea, who is that?
14:50:21 <kallisti> I could see instances of From that would make reading Haskell difficult. But in many cases I think it would be quite beneficial.
14:50:29 <mike-burns> This is barely about git vs. darcs; this is about Github vs ... whatever.
14:50:41 <monochrom> darcs wars episode I in 3D
14:50:45 <elliott> <lispy> cmccann: They are looking for a maintainer  <mike-burns> cmccann: Email the existing maintainer and tell him what you're doing.
14:50:47 <mike-burns> cmccann: No idea, really. Was hoping you knew!
14:50:49 <cmccann> mike-burns, github vs. a directory on code.haskell.org
14:50:49 <elliott> cmccann: email yourself
14:50:52 <lispy> cmccann: in this case it would be dcoutts, but I say just do it.
14:50:59 <Peaker> cmccann: I've been heavily burnt by git on a large project due to the very issues that darcs aims to solve (and git users who weren't burnt yet find unimportant).. OTOH, darcs isn't suitable for the size of the project it happened on :)
14:51:17 <hpaste> Mike___ pasted ‚Äúrubik‚Äù at http://hpaste.org/63575
14:51:19 <kallisti> for example you could write code using pattern matching on [] and :, and then it could be generalized to any value with an instance From (t a) [a]
14:51:20 <elliott> cmccann: I think anyone who is upset that you personally choose to use git to track your useful changes to the code hasn't got a leg to stand on.
14:51:32 <Peaker> I'm hoping that darcs can scale, so we can have something that's good in both theory and practice
14:51:32 <elliott> cmccann: I mean, if you want to contribute upstream, I'm sure you'll be able to convert things to darcs if necessary.
14:51:37 <elliott> But if it's not even maintained, it's irrelevant.
14:51:40 <cmccann> Peaker, yeah, but as mike-burns points out this is about GitHub, not git itself
14:51:52 <kallisti> one problem would be that if it's not made implicit at the type level as well, then your types become pretty messy.
14:51:58 * elliott doesn't see why GitHub is relevant any more than putting a git repo on a personal site or whatever
14:52:12 <Peaker> elliott: have you used github?
14:52:35 <irene-knapp> github is actually really nice, and has done a great deal to sell git
14:52:37 <monochrom> if you put something on github, someone else will find it
14:52:42 <cmccann> elliott, GitHub is relevant because it's nice enough to justify simply using git rather than messing with alternatives :P
14:52:45 <Peaker> elliott: it's really nice, since it lets you make a publicly-visible/distributable fork really easily.  Forking projects has become pain-free
14:52:49 <mike-burns> elliott: Pull requests, Issues, users, community.
14:53:00 <Peaker> elliott: then these forks are also usable to integrate back upstream painlessly
14:53:01 <elliott> Yes... I use GitHub all the time. I'm talking about in the context of whether cmccann will upset anyone.
14:53:02 * hackagebot extensible-data 0.1.0.1 - Sums/products/lists/trees which can be extended in other modules  http://hackage.haskell.org/package/extensible-data-0.1.0.1 (AaronBlack)
14:53:05 <elliott> I don't need evangelism :P
14:53:22 <cmccann> yeah, elliott forked a tiny little package of mine and edwardk-ified it
14:53:32 <Peaker> elliott: oh, misread what you meant :)
14:53:32 * lispy chants, "Just do it, cmccann"
14:53:43 <cmccann> lispy, yeah, might as well I guess
14:53:49 <Peaker> what's edwarkification?
14:53:49 <elliott> If I put the hackage2 repo up on github, would it end the dilemma?
14:53:52 <lispy> what is your github id?
14:53:54 <kallisti> I think typeclasses are probably not the way to implement this kind of abstract constructor idea.
14:54:05 <monochrom> if you write something to your own disk, no one will get offended. if you post it on a public blog site, someone will get offended. now s/public blog site/github/
14:54:22 <Peaker> kallisti: why not just write the "catamorphisms"/folds that do the pattern matching in various ways?
14:54:35 <hpaste> SubtleArray pasted ‚ÄúFinding matches between lists‚Äù at http://hpaste.org/63576
14:54:50 <cmccann> lispy, https://github.com/isomorphism/ is my github if that's what you were asking
14:54:53 <SubtleArray> Woah, that was cool.
14:55:07 <kallisti> Peaker: I had no idea how that's related, actually. sorry.
14:55:08 <cmccann> elliott, nah, I'll do it
14:55:15 <mike-burns> I was looking for Hackage2 on Github a month ago, so I'm thrilled it might be there soon.
14:55:25 <lispy> cmccann: sweet. following you now
14:55:46 <Peaker> SubtleArray: comparing against [] is usually bad style, use the "null" function (or "not . null"), so you don't pull in an Eq constraint (even if in this case that constraint exists anyway)
14:56:28 <Peaker> kallisti: the "maybe" function basically does the pattern matching against Just/Nothing for you.  You could write similar functions to do pattern matching on a maybe using other virtual constructors
14:56:34 <Peaker> kallisti: (and for any type)
14:56:58 <cmccann> mike-burns, did you see the copy I have running, btw?
14:57:05 <mike-burns> Not yet!
14:57:07 <mike-burns> Link?
14:57:09 <cmccann> mike-burns, http://hackage2.uptoisomorphism.net:8080/
14:57:18 <mike-burns> Sweet.
14:57:28 <lispy> cmccann: what was the setup time lie?
14:57:29 <lispy> lie*
14:57:35 <lispy> like* (3rd time is the charm)
14:57:40 <mike-burns> Hah. I love that only Acme is on there.
14:57:45 <mike-burns> Also, this is snappy!
14:57:49 <SubtleArray> Peaker: Null doesn't work. The compiler complains about it being "not in scope."
14:57:53 <cmccann> lispy, with or without the endless bickering with cabal and packages that didn't build on 7.4?
14:58:03 <monochrom> "null" is not "Null"
14:58:04 <elliott> SubtleArray: maybe because you capitalised it? :)
14:58:16 <monochrom> > "null" == "Null"
14:58:17 <lambdabot>   False
14:58:25 <SubtleArray> I tried capitalized and lowercase.
14:58:31 <lispy> cmccann: assuming an older ghc :)
14:58:34 <cmccann> lispy, and also the time screwing around with a spare-cycles-on-a-pocket-calculator size EC2 instance to get things running there
14:58:36 <monochrom> intelligence. noun. ... 5. the ability to perform computer functions
14:59:00 <monochrom> > null [4]
14:59:01 <lambdabot>   False
14:59:01 <elliott> cmccann: as your first change, turn "Reverse dependencies" into "Dependers" :P
14:59:20 <cmccann> lispy, ignoring extraneous issues... cabal install and then run it I guess? there wasn't any set-up inherent to hackage I don't think
14:59:38 <lispy> cmccann: so < 4 hours is reasonable?
14:59:51 <SubtleArray> My main problem is with the code not working. >_< It only works with 1 list comprehension. When I try to add another, it gets mad.
14:59:57 <kallisti> Peaker: yes, by what mechanism do you have virtual constructors.
15:00:14 <mike-burns> SubtleArray: I wasn't following closely, sorry; can you hpaste what you have now?
15:00:29 <SubtleArray> http://hpaste.org/63576
15:00:34 <Peaker> kallisti: basically, pattern-matching on any set of constructors can be expressed by a function that takes a function for each of the cases, and calls the right function for the case
15:00:55 <Peaker> kallisti: and give that function the fields inside the constructor
15:01:04 <cmccann> lispy, yeah I don't know if it even took me that long with all the headaches
15:01:13 <SubtleArray> I simplified the code to make it easier to read. I want it to return a string if a match is found between 2 lists.
15:01:15 <Peaker> kallisti: you can write this function for the "real" constructors, or for virtual constructors that cover the same type's cases
15:01:42 <mike-burns> > [ if null x then "Water" else "" | x <- [1,2,3], y <- ["swim", "dive", "walk"], y == x]
15:01:42 <lambdabot>   No instance for (GHC.Num.Num [GHC.Types.Char])
15:01:43 <lambdabot>    arising from the literal ...
15:01:51 <SubtleArray> But I want to compare the input between multiple lists in the same function.
15:01:54 <cmccann> lispy, certainly much less than that if you ignore the time spent getting stuff it depends on to install vs. hackage2 itself
15:02:29 <mike-burns> > [ if null x then "Water" else "" | x <- ["1","2","swim"], y <- ["swim", "dive", "walk"], y == x]
15:02:30 <lambdabot>   [""]
15:02:32 <Peaker> in zlib:  "#if MIN_VERSION_base(4,4,0)" makes my cabal build yell: "Stream.hsc:86:21: error: missing binary operator before token "(""
15:02:41 <mike-burns> SubtleArray: `null x' worked for me there.
15:02:44 <elliott> Peaker: turn # to ##
15:02:58 <Peaker> elliott: what changed?
15:03:04 <elliott> nobody knows
15:03:11 <elliott> the #endif, too
15:03:21 <Peaker> elliott: thanks
15:03:32 <SubtleArray> mike-burns: Still getting complaints about "not in scope". Perhaps I need to import another module?
15:03:47 <SubtleArray> For the Null
15:03:49 <lispy> cmccann: thanks for putting it on github.  I'm schedule for some away-from-computer-time.  I'll stop by later to see how things are going.
15:03:59 <kallisti> Peaker: the benefit of a language extension would be that you get the syntactic clarity of pattern matching.
15:03:59 <cmccann> lispy, I'll have it up in a few minutes
15:04:06 <cmccann> had a couple other things I need to finish first
15:04:24 <romeus> hello : )
15:04:30 <romeus> trying to run a program and get the following error: Prelude.chr: bad argument: 2022855
15:04:35 <lispy> cmccann: also, http://hackage.haskell.org/package/darcs-fastconvert
15:04:36 <romeus> Read online that this might have something to do with stale hi files
15:04:42 <romeus> I'm on Ubuntu Natty, where do I find these files and how to do I fix this problem?
15:05:03 <mike-burns> SubtleArray: Are you explicitly hiding Prelude?
15:05:07 <cmccann> lispy, oh nice
15:05:10 * lispy leaves
15:05:11 <Peaker> kallisti: It's quite verbose, though, that I generally prefer "maybe", "either", etc over explicit "case" statements
15:05:22 <elliott> romeus: your program may be just broken
15:05:25 <elliott> does it use "chr"?
15:05:40 <romeus> elliott: not my program, just one I installed and that was working find until recently
15:05:55 <romeus> find = fine : )
15:06:08 <kallisti> Peaker: what's the catamorphism (is that what you're talking about? I don't know what a catamorphism is) for lists?
15:06:08 <SubtleArray> mike-burns: Explicitly hiding Prelude?
15:06:20 <Peaker> kallisti: foldr
15:06:26 <kallisti> ah
15:06:42 <lispy> cmccann: and this: http://lists.osuosl.org/pipermail/darcs-users/2010-September/025251.html
15:06:56 <mike-burns> SubtleArray: Guess not, then. Which version of ghc?
15:06:56 <Peaker> foldr takes a (cons case, nil case).. though foldr also does the recursion, which may be done separately
15:07:21 <elliott> SubtleArray: please hpaste your whole file, too
15:07:42 <Peaker> OpenGLRaw compilation on ghc 7.4 is generating a whole lot of warnings
15:08:44 <rostayob> alzamos: yo
15:09:02 * mike-burns hits reload on isomorphism/hackage2 excitedly and continuously.
15:09:15 <rostayob> mike-burns: hackage2? nonsense.
15:09:25 <elliott> rostayob: http://hackage2.uptoisomorphism.net:8080/
15:09:31 <SubtleArray> mike-burns: I'm using GHC version 7.0.3, and the Leksah IDE. The code actually works fine. My only issue is getting 2 list comprehensions to run one after the other. Is that possible?
15:09:49 <mike-burns> SubtleArray: What are you doing with the values?
15:10:08 <rostayob> elliott: oh well. another pillar of vaporware software crumbles.
15:10:14 <elliott> SubtleArray: If you don't have "null", something is seriously wrong.
15:11:25 <SubtleArray> elliot: I just checked the type of null. I have it, but my list comprehension doesn't like it. Lol.
15:11:43 <mamina> Can anibody help me with this http://alturl.com/n53kn ?
15:12:04 <mike-burns> NSFW.
15:12:15 <mike-burns> And that picture's from, like, 1995 or something.
15:12:17 <arthuraa> I think I've found something... cabal is passing __GLASGOW_HASKELL__=704 even though it is using ghc 7.4.1. Anyone knows how to make it use __GLASGOW_HASKELL__=741?
15:12:19 <Axman6> @where ops
15:12:19 <lambdabot> shapr Cale glguy dons sjanssen dcoutts Saizan dibblego conal Philippa bos arjanb xerox Heffalump kosmikus wli Pseudonym Igloo quicksilver monochrom Lemmih jmcarthur copumpkin
15:12:31 <rwbarton> 704 means 7.4
15:12:37 <elliott> mamina: Your indentation is messed up. Try converting tabs to spaces.
15:12:55 <elliott> Oh, my psychic powers have failed me.
15:13:03 <arthuraa> rwbarton: I thought it meant 7.0.4
15:13:03 <mike-burns> SubtleArray: What do you want to happen with the results from these two list comprehensions?
15:13:16 <th0b0r0> Can anyone tell me why adding the quartersForDay function causes my program to go into an endless loop on startup?
15:13:19 <hpaste> th0b0r0 pasted ‚Äúsnippet‚Äù at http://hpaste.org/63577
15:13:32 <int-e> arthuraa: 6.12.1 defined it as 612 :-)
15:13:32 <SubtleArray> mike-burns: This is what my program does so far: It takes the user's input, strips out symbols, and splits it into a list. I then want to take this list and return a string if a match is found between the user input and the variables like "waterAction" and so on. http://hpaste.org/63576
15:13:37 <rwbarton> since there are versions like ghc 6.12.1 etc. the format is xyy for ghc x.y.z
15:14:03 <mamina> elliot, there are no tabs in what I wrote, what do you mean?
15:14:05 <SubtleArray> mike-burns: That function works fine when I only define 1 variable, and have 1 list comprehension. But when I add another list comprehension, it reports errors.
15:14:38 <elliott> mamina: I can't tell whether you're a really specialised troll, or actually pasted the wrong link.
15:14:58 <Cale> Did someone call an op?
15:15:16 <elliott> Yes, though I can't figure out whether it's actually warranted yet.
15:15:19 <mike-burns> Cale: op requests are related to mamina .
15:15:24 <Cale> okay
15:15:37 <Cale> mamina: check that link you posted, heh
15:15:45 <mamina> Ok sorry...
15:15:50 <elliott> try hpaste.org
15:15:53 <mamina> I'll be back
15:15:59 <mike-burns> SubtleArray: Can you re-write those two list comprehensions as one?
15:16:00 <elliott> o_o
15:16:01 <rwbarton> lolwut
15:16:03 <irene-knapp> I wonder if that was a threat
15:16:18 <elliott> that was... interesting
15:16:21 <irene-knapp> not very :)
15:16:47 <hpaste> SubtleArray pasted ‚ÄúThe Error‚Äù at http://hpaste.org/63578
15:17:02 <mike-burns> th0b0r0: If you define quartersForDay as `undefined', the program loads?
15:17:10 <elliott> SubtleArray: "Warning:"
15:17:12 <th0b0r0> mike-burns: if i comment out quartersForDay, yes.
15:17:13 <elliott> SubtleArray: not error
15:17:27 <elliott> SubtleArray: you have a redundant "do", I suspect
15:17:34 <elliott> "do x" where x is a single statement is just "x"
15:17:35 <rwbarton> anyways that code surely can't do what you want
15:17:40 <rwbarton> however I have no idea what you want it to do
15:17:46 <SubtleArray> elliot: I'll post the entire code in just a moment. Gotta fix it up a little so you all don't laugh at it. >_<
15:17:59 <elliott> SubtleArray: but your code compiles, it is just a warning.
15:18:07 <th0b0r0> rwbarton: you mean me?
15:18:10 <elliott> still, only use "do" when you're actually using do notation (<- binds, multiple statements, etc.)
15:18:11 <rwbarton> I meant SubtleArray
15:18:15 <th0b0r0> ok :)
15:18:41 <SubtleArray> mike-burns: I think I could write the 2 list comprehensions as one... That could probably solve the issue.
15:18:55 <rwbarton> what do you want to do with the list comprehensions?
15:19:03 <rwbarton> you can't just randomly write a bunch of expressions one after another
15:19:26 <rwbarton> (well, in this case you actually *can*, but...)
15:20:39 <th0b0r0> mike-burns: funny thing is, that I'm not eve ncalling quartersForDay anywhere :S
15:21:09 <mike-burns> th0b0r0: That's why I wonder if setting its body to `undefined' will affect anything.
15:21:44 <th0b0r0> mike-burns: oh, sorry. setting the body to undefined works just fine.
15:22:12 <mike-burns> th0b0r0: That's exciting. I have no idea what's going on, sadly.
15:22:32 <th0b0r0> :D wish I had some new(er) ghc available
15:24:05 <rwbarton> th0b0r0: if you're sure that replacing the definition "map (splitInInterval day) seconds" by "undefined" makes your program terminate, that would be odd.  more source code context would be helpful
15:24:41 <th0b0r0> actually, just doing a quartersForDay day = [(splitInInterval day (seconds !! 0))]
15:24:49 <th0b0r0> causes the program to not terminate again.
15:25:20 <th0b0r0> rwbarton: I'll post the source; it's not pretty though ;)
15:26:08 <hpaste> th0b0r0 pasted ‚ÄúThe Source‚Äù at http://hpaste.org/63579
15:26:47 <th0b0r0> we're talking about lines 73/74
15:26:47 <mike-burns> th0b0r0: I wonder if your indentation is an issue.
15:26:59 <th0b0r0> mh, let me check, mike-burns
15:27:20 <kqr> if i have a data type (similar to an enum) and i want to randomise some of the possible values, what class should i derive?
15:28:05 <th0b0r0> mike-burns: hah, yeah. seems to be the case.
15:28:26 <th0b0r0> if I put splitInInterval & quartersForDay outside of the main function, the program terminates again
15:28:29 <th0b0r0> good to know i guess
15:28:35 <rwbarton> oh
15:28:54 <th0b0r0> but, out of curiosity, shouldn't this be working?
15:29:01 <monochrom> that's strange
15:29:08 <rwbarton> so my guess is something involving defaulting
15:29:12 <rwbarton> wait
15:29:14 <rwbarton> yes
15:29:28 <rwbarton> the non-undefined definition forces seconds :: [(NominalDiffTime, NominalDiffTime)]
15:29:31 <mike-burns> Really, incorrectly-indented Haskell code isn't supposed to work.
15:30:24 <monochrom> "is this code correctly indented" is undecidable. therefore, the computer gives it a try...
15:30:57 <rwbarton> oh nice
15:31:05 <rwbarton> > [0..95] :: NominalDiffTime
15:31:06 <lambdabot>   Not in scope: type constructor or class `NominalDiffTime'
15:31:12 <rwbarton> well it's
15:31:25 <rwbarton> [0s, 0.0000000009s, 0.0000000018s, ...]
15:32:09 <JoeyA> What's a good term for an action that has no effect on the world?  (e.g. newEmptyMVar)
15:32:23 <JoeyA> "Pure" is already used to refer to pure values.
15:32:26 <th0b0r0> right. thanks for your help :)
15:32:29 <monochrom> autistic action  <duck>
15:32:29 <elliott> JoeyA: unsafePerformable :P
15:32:51 <elliott> JoeyA: perhaps "idempotent", since that's what such a term is usually required for
15:33:04 <elliott> well, for some values of usually
15:33:09 <elliott> but it doesn't mean the same thing ofc
15:33:33 <JoeyA> Well, hClose is idempotent, but it isn't effect-free.
15:34:07 <SubtleArray> mike-burns: I see what the problem is now. Haskell doesn't like how I'm trying to pull my C++ tricks on it. Ha. It's reading the second list comprehension as another do. So the only way (I think) I can fix this problem is by trying to cram everything into 1 list comprehension, or making a different function for each pattern match.
15:34:27 <SubtleArray> Basically, I think I've figured it out. Thank you and elliot for your help.
15:34:34 <mike-burns> Wonderful.
15:34:47 <monochrom> "internal affairs" :)
15:36:02 <hpaste> Mike___ pasted ‚Äúrubik‚Äù at http://hpaste.org/63580
15:36:10 <monochrom> ( http://www.imdb.com/title/tt0338564/ is the origin of Departed)
15:36:15 <Mike___> *Main> main *** Exception: Prelude.read: no parse
15:36:34 <Mike___> Could some one tell me why when I try to write to a file, I get that error
15:36:46 <Mike___> Everything compiles up nicely
15:37:08 <fryguybob> > read "hello" :: Int
15:37:08 <lambdabot>   *Exception: Prelude.read: no parse
15:37:32 <monochrom> in fact,
15:37:39 <monochrom> > read "hello" :: String
15:37:40 <lambdabot>   "*Exception: Prelude.read: no parse
15:38:05 <monochrom> lerNome is supposed to just getLine and be done with it. no readIO for String.
15:38:13 <fryguybob> > read "\"hello\"" :: String
15:38:14 <lambdabot>   "hello"
15:38:41 <monochrom> and what fryguybob demonstrates if you insist on readIO for String
15:38:44 <JoeyA> "impotent" is a pretty good word for "has no effects", I suppose
15:39:02 <monochrom> "impotent" is pretty strong
15:39:39 <Jafet> Can't launch wing attack plan R without IO.
15:39:57 <JoeyA> agreed
15:40:02 <elliott> JoeyA: I think effect-free is ill-defined.
15:40:05 <monochrom> there is so much misunderstanding about Read and Show for String. or rather unfounded presumptions
15:40:11 <elliott> Is writing to a file and immediately removing it effect-free?
15:40:19 <gdoteof> Wondering if anyone wants to share some wisdom or preferences.  I am going to build essentially a time tracking tool.. I haven't written anything in haskell
15:40:20 <elliott> If no, what if the MVar that is created gets swapped out?
15:40:21 <JoeyA> elliott: I actually mean it in a concurrency setting.
15:40:26 <monochrom> like, people don't even test their hypotheses. they just assume they know.
15:40:47 <gdoteof> looking to use yesod probably; it will be a webapp.  mostly looking for recommendations on a db engine
15:40:47 <JoeyA> elliott: I would call that "atomic", unless it's possible for the file to dangle in the event of an error.
15:41:21 <monochrom> the swap file doesn't count
15:41:24 <JoeyA> elliott: readMVar is a good example of "atomic".
15:41:32 <JoeyA> It isn't effect-free, but it's pretty close.
15:41:50 <gdoteof> Its a pretty simple set of features.. add tables, add players, track players times at tables, and pull arbitrary reports of time
15:41:57 <JoeyA> newMVar is what I would call effect-free; it has absolutely no effect on program variables
15:42:02 <JoeyA> (unless you count RTS internals)
15:42:14 <gdoteof> acid state seems incredibly sexy; but i think id like to keep things not reliant on ram
15:42:42 <mike-burns> gdoteof: I like Postgres, but I've never done it in Haskell.
15:43:02 * hackagebot xournal-types 0.4 - Data types for programs for xournal file format  http://hackage.haskell.org/package/xournal-types-0.4 (IanWooKim)
15:43:03 * hackagebot xournal-render 0.6 - Xournal file renderer  http://hackage.haskell.org/package/xournal-render-0.6 (IanWooKim)
15:43:23 <Axman6> JoeyA: wouldn't newMVar have to allocate a new MVar for every call? that's a form of side effect
15:43:41 <elliott> JoeyA: <elliott> If no, what if the MVar that is created gets swapped out?
15:43:49 <JoeyA> It gets GCed; you don't have to think about its interaction with other MVars and threads.
15:43:54 <elliott> JoeyA: I don't see a concrete difference between newEmptyMVar and createFileAndThenEnsureIt'sDeleted.
15:43:57 <monochrom> the swap file doesn't count
15:43:59 <JoeyA> (until you do something with the MVar)
15:44:09 <elliott> monochrom: OK, assume GHC has to create a file and ensure it's deleted to initialise an MVar.
15:44:14 <elliott> Which it is perfectly within its rights to.
15:44:18 <JoeyA> elliott: In the latter example, the program may crash, and leave the file lying around.
15:44:40 <monochrom> that is hypothetical and I refuse to consider it
15:44:42 <elliott> JoeyA: No, it's exception-safe and signals are blocked.
15:44:51 <elliott> monochrom: You have to consider hypothetical scenarios when defining a concrete concept.
15:44:55 <JoeyA> elliott: kill -9
15:45:10 <mike-burns> What if the filesystem is read-only?
15:45:11 <elliott> JoeyA: Also you're on Windows.
15:45:20 <Mike___> *** Exception: tabela.txt: openFile: permission denied (Permission denied)
15:45:20 * elliott thinks JoeyA is missing the point of his thought experiment somewhat.
15:45:35 <monochrom> not such wild crazy implementational ideas
15:45:53 <JoeyA> I'm just fishing for some terminology.
15:46:17 <Peaker> Can anyone with upload rights upload a fix to a broken hackage package?
15:46:31 <mike-burns> Yes, technically.
15:46:37 <alpounet> the maintainer isn't answering emails?
15:46:41 <Peaker> The "bitmap" package is broken since "unsafePerformIO" in Foreign was deprecated, and will not issue a small fix (he's waiting to issue a big rewrite fix)
15:46:51 <elliott> Peaker: If the maintainer says no, then don't do it.
15:47:01 <Mike___> could it be that I have permission issues to my file and am unable to write to it?
15:47:07 <elliott> Mike___: Yes.
15:47:22 <Mike___> thank you
15:49:08 <Peaker> People using open unqualified imports cause a lot of wreckage :(  I barely allow myself that pleasure when working on throwaway scripts
15:49:24 <kqr> is there a way to evaluate list elements in parallell?
15:49:42 <Axman6> yes, see Cintrol.Parallel
15:49:48 <Axman6> Control*
15:49:55 <Peaker> http://hackage.haskell.org/packages/archive/parallel/3.1.0.1/doc/html/Control-Parallel-Strategies.html  -- parMap
15:50:09 <Axman6> @hoogle parMap
15:50:10 <lambdabot> Control.Parallel.Strategies parMap :: Strategy b -> (a -> b) -> [a] -> [b]
15:50:28 <Axman6> @hoogle Strategy a -> [a] -> [a]
15:50:29 <lambdabot> Control.Parallel.Strategies parMap :: Strategy b -> (a -> b) -> [a] -> [b]
15:50:29 <lambdabot> Control.Seq withStrategy :: Strategy a -> a -> a
15:50:29 <lambdabot> Control.Parallel.Strategies withStrategy :: Strategy a -> a -> a
15:50:50 <Axman6> @hoogle Strategy a -> Strategy [a]
15:50:50 <lambdabot> Control.Parallel.Strategies evalList :: Strategy a -> Strategy [a]
15:50:51 <lambdabot> Control.Parallel.Strategies parList :: Strategy a -> Strategy [a]
15:50:51 <lambdabot> Control.Parallel.Strategies seqList :: Strategy a -> Strategy [a]
15:50:58 <Axman6> better
15:51:26 <kqr> is there any information on how strategies work, for someone who has no idea?
15:51:55 <elliott> there's a paper referenced in that doc i think
15:52:01 <kqr> okay
15:52:03 <Jafet> I believe there are two strategies in the library
15:52:12 <kqr> r0, rseq and rpar?
15:52:13 <Jafet> A parallel strategy, and a non-parallel strategy
15:52:17 <kqr> yeah
15:52:18 <elliott> Peaker: You can't guilt me into explicit import lists!! Okay, maybe I've been guilted into doing it already.
15:52:19 <kqr> looks like it
15:52:22 <kqr> it's a little clearer now
15:52:24 <Jafet> You should probably use the parallel strategy
15:52:36 <elliott> Jafet: There are N strategies, just some of them are primitive.
15:53:01 * hackagebot xournal-parser 0.4 - Xournal file parser  http://hackage.haskell.org/package/xournal-parser-0.4 (IanWooKim)
15:53:03 * hackagebot stm-chans 1.2.0.2 - Additional types of channels for STM.  http://hackage.haskell.org/package/stm-chans-1.2.0.2 (WrenThornton)
15:53:05 * hackagebot xournal-builder 0.1.1 - text builder for xournal file format  http://hackage.haskell.org/package/xournal-builder-0.1.1 (IanWooKim)
15:53:07 * hackagebot hxournal 0.6.5 - A pen notetaking program written in haskell  http://hackage.haskell.org/package/hxournal-0.6.5 (IanWooKim)
15:53:09 * hackagebot stm-chans 1.2.0.3 - Additional types of channels for STM.  http://hackage.haskell.org/package/stm-chans-1.2.0.3 (WrenThornton)
15:56:00 <Peaker> according to PVP, if you increase C in A.B.C, that doesn't signify potential breakage, right?
15:56:07 <Peaker> I forget if it's C or D
15:56:30 <rostayob> Peaker: it's C
15:56:48 <rostayob> A and B are major version numbers, and they should be the upper bound
15:57:09 <rostayob> Peaker: also, there is no D
15:59:20 <jrm> Is it possible to run xmobar in withdrawn mode, so it can be place in the fluxbox slit?  Or is there any other way to maximize windows and not have them cover xmobar?
16:02:58 <Peaker> rostayob: thanks.
16:02:59 <cmccann> hey, edwardk
16:03:20 <Peaker> I am now hosting a copy of the bitmap package on github, and sent the maintainer another email, if he refuses to fix it I think I ought to upload a fixed version myself
16:03:23 <edwardk>  cmccann heya heading out door to move more stuff
16:03:26 <cmccann> pf
16:03:28 <edwardk> sorry
16:03:30 <cmccann> edwardk, http://hackage2.uptoisomorphism.net:8080/ :D
16:03:33 <cmccann> that's all
16:03:35 <edwardk> nice
16:03:40 <edwardk> i
16:03:51 <edwardk> i'll check it when i get back
16:03:56 <cmccann> 'k
16:05:45 <mike-burns> Hey it's on Github now!
16:05:50 <cmccann> yep
16:05:53 <mike-burns> cmccann: Thanks for doing this.
16:06:01 <cmccann> how much were you refreshing that page? :P
16:06:18 <mike-burns> cmccann: Every minute for a while, but it slowed to every 10 minutes.
16:06:30 <cmccann> haha
16:06:43 <cmccann> well, it's there now, happy hacking
16:06:44 * mike-burns clones
16:10:28 <alanthonyc> (<- lurking)
16:11:34 <SubtleArray> Hi peoples. Just a small question. Is there a way to call the first element of a tuple that's embedded in a list? For example: [(1, "dog"), (2, "cat")]. Is there a way just to call "cat"?
16:12:08 <Saizan> what do you mean by "call"?
16:12:16 <SubtleArray> Like a !! 0
16:12:32 <rwbarton> fst
16:12:37 <sipa> :t snd
16:12:38 <lambdabot> forall a b. (a, b) -> b
16:12:40 <SubtleArray> Ah ha!
16:12:46 <SubtleArray> Thank you.
16:12:54 * mike-burns is concerned.
16:13:11 <mike-burns> Your algorithm is suspicious if it got you there, SubtleArray .
16:13:52 <SubtleArray> mike-burns: I know, right. Lol. But I think I'm on to something. I'll show you once I get it together.
16:14:13 <elliott> cmccann: Will you accept a patch changing "Reverse dependencies" to a shorter string?
16:14:27 <cmccann> that's really bothering you isn't it
16:14:29 <cmccann> :P
16:14:32 <elliott> IT LOOKS AWFUL
16:14:34 <cmccann> :D
16:14:49 <cmccann> sure whatever I'll accept anything sensible
16:15:10 <monochrom> revdep?
16:15:18 <rwbarton> seicnedneped
16:15:20 <elliott> monochrom: I was going to go for "Dependers"
16:15:31 <elliott> or "Depended on by"
16:15:33 <cmccann> I'm not claiming to be the official maintainer therefore I feel no obligation to stonewall all possible changes for the sake of being all formal and official
16:15:38 <elliott> haha
16:15:42 <monochrom> and forward dependencies are... dependees?
16:15:59 <hpc> "dep grep", perhaps?
16:16:07 <monochrom> note: I do not actually oppose it! just a few days ago I said "debugee"
16:17:05 <elliott> monochrom: yes, indeed
16:17:16 <elliott> "Depended on by" is probably the most reasonable
16:17:21 <elliott> considering "by" is already used in those fields
16:18:02 * hackagebot wai-middleware-cache-redis 0.2.0 - Redis backend for wai-middleware-cache  http://hackage.haskell.org/package/wai-middleware-cache-redis-0.2.0 (AlexanderDorofeev)
16:18:04 * hackagebot lhe 0.5 - Parser and writer for Les-Houches event files  http://hackage.haskell.org/package/lhe-0.5 (ScottLawrence)
16:18:35 <cmccann> how about "packages weighing down upon this one as if it carries the world upon its shoulders"
16:18:52 <elliott> ++
16:19:09 <monochrom> hahaha
16:19:15 <mike-burns> Sounds about right.
16:20:02 <monochrom> <lambdabot> packages weighing down upon this one as if it carries the world upon its shoulders: mueval-core: time limit exceeded
16:23:54 <monochrom> from a post in glasgow-haskell-users: "I tried compiling myself"
16:25:04 <Axman6> "I was deemed impure"
16:25:05 <mike-burns> hackage2 is simple to build and run. Hooray!
16:25:07 <hpc> monochrom: "type error: expected "ACTGTT" but got "ACCTGT""
16:25:10 <covi> Hi all. How do I 'generate' a fibonacci list?
16:25:26 <Axman6> covi: prepare for the impending can of worms
16:25:35 <covi> Axman6: ??
16:25:37 <kallisti> > let concat xss = [x | xs <- xss, x <- xs] in concat [[1,2,3],[4,5,6]]
16:25:38 <lambdabot>   [1,2,3,4,5,6]
16:25:42 <Axman6> @google haskell programmer evolution
16:25:43 <lambdabot> http://www.willamette.edu/~fruehr/haskell/evolution.html
16:25:44 <lambdabot> Title: The Evolution of a Haskell Programmer
16:25:57 <elliott> http://hackage2.uptoisomorphism.net:8080/packages/reverse
16:26:03 <elliott> cmccann: this thing needs dependencies in its DB :P
16:26:14 <cmccann> elliott, upload some packages then
16:26:18 <hpc> covi: FibonacciFactory.getInstance().getNumberArray(new Integer(100)).toList() :P
16:26:19 <mike-burns> > let fibs = 0 : scanl (+) 1 fibs in take 8 fibs
16:26:20 <cmccann> I added the ones I thought were useful
16:26:20 <lambdabot>   [0,1,1,2,3,5,8,13]
16:26:22 <cmccann> :D
16:26:47 <elliott> cmccann: :(
16:26:56 <Axman6> covi: what do you mean by 'generate' anyway?
16:27:03 <cmccann> mike-burns, glad to hear it, I had to jump through some hoops to get it building at first :P
16:27:23 <mike-burns> cmccann: I'm just on Haskell Platform, using cabal-dev. Pretty boring.
16:27:25 <cmccann> I bumped a couple dependencies to newer versions as you may have noticed
16:27:57 <mike-burns> I had to install one Debiant package (libcrypto++), but that's it.
16:28:18 * cmccann has a hodgepodge of different GHC versions and old packages lying around, it's terrible
16:30:01 <mike-burns> Now to figure out how to use Hackage2 ...
16:30:35 <covi> hpc: ??
16:30:47 <covi> mike-burns: I don't understand the 'scan1' and '(+)'
16:30:56 <hpaste> SubtleArray pasted ‚ÄúMy beastly list comprehension that almost works‚Äù at http://hpaste.org/63581
16:31:00 <hpc> covi: bad joke, ignore me ;)
16:31:03 <covi> Axman6: I mean in imperative lang I can do this easily by looping..
16:31:15 <mike-burns> covi: It's a scanl, not scan1. Like "scan left".
16:31:28 <mike-burns> covi: You'll want to loop in Haskell, too. I used the scanl loop in my example.
16:31:53 <mike-burns> :t scanl
16:31:53 <lambdabot> forall a b. (a -> b -> a) -> a -> [b] -> [a]
16:31:54 <mike-burns> :t (+)
16:31:55 <lambdabot> forall a. (Num a) => a -> a -> a
16:32:13 <Axman6> > let fibs = 0 : 1 : zipWith (+) fibs (tail fibs) in fibs
16:32:14 <lambdabot>   [0,1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765,10946...
16:32:27 <covi> I see. Thanks guys.
16:32:36 <kallisti> @hoogle t a -> t b -> t (a,b)
16:32:37 <lambdabot> Data.Sequence zip :: Seq a -> Seq b -> Seq (a, b)
16:32:37 <lambdabot> Prelude zip :: [a] -> [b] -> [(a, b)]
16:32:37 <lambdabot> Data.List zip :: [a] -> [b] -> [(a, b)]
16:32:43 <kallisti> :(
16:32:45 <Axman6> covi: do you understand anything you've been told?
16:33:02 <mike-burns> I think he understands that we're not going to be very helpful.
16:33:05 <kallisti> :t uncurry zip
16:33:06 <lambdabot> forall a b. ([a], [b]) -> [(a, b)]
16:33:11 <kallisti> much better
16:33:15 <hpc> covi: actually, here's a serious explanation of what Axman6 gave
16:33:28 <hpc> uh, sec, lemme paste some stuff first
16:33:44 <Axman6> covi: also, you should learn that loops are poor mans recursion ;)
16:34:07 <cmccann> loops are just syntactic sugar for tail recursion
16:34:12 <kallisti> poor men are recursion's loops.
16:34:16 <cmccann> for primitive compilers that can't optimize it otherwise
16:34:16 * kallisti helpful.
16:34:32 <SubtleArray> mike-burns: Here's the new list comprehension. It's SO close to working. http://hpaste.org/63581 I just need to figure out what I'm overlooking.
16:34:54 <covi> I'll learn what you suggested :)
16:35:18 <mike-burns> SubtleArray: You've made a HashMap.
16:35:25 <Axman6> > lt fibs = 0 : 1 : [x + y | (x,y) <- zip fibs (tail fibs)] in fibs
16:35:25 <SubtleArray> And there aren't any warnings or errors. :)
16:35:26 <lambdabot>   <no location info>: parse error on input `='
16:35:37 <Axman6> > let fibs = 0 : 1 : [x + y | (x,y) <- zip fibs (tail fibs)] in fibs
16:35:37 <lambdabot>   [0,1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765,10946...
16:35:44 <SubtleArray> *looks up Haskmap*
16:35:47 <SubtleArray> Hash
16:36:49 <mike-burns> SubtleArray: http://hackage.haskell.org/packages/archive/containers/latest/doc/html/Data-Map.html
16:37:08 <SubtleArray> mike-burns: I'm on it. :D I see they have a whole module just for this kind of thing.
16:37:47 <mike-burns> SubtleArray: They're a rather powerful data structure, for a variety of reasons.
16:39:18 <SubtleArray> Woooooo! It works!
16:39:22 <mike-burns> Nice.
16:39:22 <hpc> covi: http://hpaste.org/63582
16:39:42 <elliott> SubtleArray: You shouldn't be using do notation there, by the way.
16:39:42 <SubtleArray> I just forgot to put the matchLocation function in my main IO.
16:39:46 <elliott> You should use let...in or a where clause.
16:39:54 <elliott> It only works with do notation because [] happens to be a monad.
16:40:15 <kallisti> what's the best way to convert a string of binary to an Int?
16:40:19 * kallisti can't remember.
16:40:30 <hpc> kallisti: you mean a "001010101" string?
16:40:35 <kallisti> yes
16:41:04 <hpc> > let str2bin = read . ("0b"++) in str2bin "01010110" :: Int
16:41:05 <lambdabot>   *Exception: Prelude.read: no parse
16:41:15 <hpc> oh, doesn't read binary
16:41:23 <SubtleArray> mike-burns: Thanks again.
16:42:07 <SubtleArray> elliot: But the function only works with do. >_<
16:42:22 <otters> @pl \x -> idx == (fst x)
16:42:23 <lambdabot> (idx ==) . fst
16:42:40 <covi> hpc: thx so much :)_
16:42:44 <SubtleArray> elliot: I get parse errors when I try where.
16:43:13 <SubtleArray> elliot: Do where or in depend on any extra functions?
16:43:31 <hpc> covi: and when you get a chance, check out lyah
16:43:33 <hpc> @where lyah
16:43:33 <lambdabot> http://www.learnyouahaskell.com/
16:44:48 <covi> hpc: sure, I was trudging through it, just finished first several chapters :)
16:44:49 <elliott> SubtleArray: I'm not sure what you mean.
16:44:54 <elliott> Your syntax is probably just wrong; what are you trying?
16:45:12 <elliott> do notation does something totally different to what you want there, it just happens to coincide with the right thing in this one particular instance
16:45:31 <SubtleArray> I also changed 'then read (snd y)' to just 'then snd y'. Makes the output cleaner.
16:45:42 <SubtleArray> elliot: I'm just changing the word do to where.
16:46:06 <MaskRay> TransformListComp?
16:46:13 <SubtleArray> I'm a C++ programmer trying to be a functional programmer...
16:46:59 <elliott> SubtleArray: Well, that's not enough.
16:47:06 <elliott> SubtleArray: You put where definitions after the expression.
16:47:08 <elliott> foo = blah
16:47:10 <elliott>   where ...
16:47:11 <Axman6> SubtleArray: you poor thing :(
16:47:24 <elliott> LYAH probably covers let...in and where, someone point SubtleArray to the right chapter :P
16:47:44 <hpc> http://learnyouahaskell.com/syntax-in-functions#let-it-be
16:47:57 <elliott> thanks hpc, you're even faster than google
16:48:23 <SubtleArray> Thanks, folks. :D
16:48:36 <SubtleArray> But do I really need to change the do if it works?
16:48:42 <SubtleArray> Or will I run into problems later?
16:48:45 <mike-burns> SubtleArray: You need to understand why it works.
16:48:49 <Cale> Has anyone else had trouble with 7.4.1 being really lax about generalising type variables?
16:49:09 <elliott> SubtleArray: You shouldn't have written the do in the first place.
16:49:23 <elliott> To start with, a general rule of thumb is that you only need do to combine multiple statements in IO.
16:49:26 <elliott> Outside of that, don't use it.
16:49:30 <SubtleArray> I thought it was self-explanatory. I'm telling it to do stuff, and then I put the stuff after it. Haha.
16:49:39 <Cale> (and inferring types for top level bindings in which type variables are not generalised)
16:49:39 <mike-burns> Hah. Yipes.
16:49:58 <mike-burns> SubtleArray: `do' is rather powerful and certainly doesn't do what you think it does.
16:50:00 <mike-burns> Whatever that is.
16:50:04 <SubtleArray> I kid. I know do a *little* better than that, but not completely. I didn't know it was for IO specific operations.
16:50:10 <elliott> it's not
16:50:17 <elliott> but pretend it is :)
16:50:23 <hpc> for now at least
16:50:30 <elliott> it's for monadic computations. don't ask what those are.
16:50:46 <Cale> It's not quite specific to IO, but there's a specific sort of interface something has to provide to use do notation, and the IO library provides it (It's called Monad)
16:51:41 <Cale> The list library also provides it, and you can use do-notation like list comprehensions:
16:51:52 <SubtleArray> I see. I'll read up on where and see if I can rewrite this function using where instead of do.
16:51:56 <Cale> > do x <- [1,2,3]; y <- [4,5]; z <- [6,7,8]; return (x,y,z)
16:51:57 <lambdabot>   [(1,4,6),(1,4,7),(1,4,8),(1,5,6),(1,5,7),(1,5,8),(2,4,6),(2,4,7),(2,4,8),(2...
16:52:20 <hpc> > [(x,y,z) | x <- [1,2,3], y <- [4,5], z <- [6,7,8]]
16:52:21 <lambdabot>   [(1,4,6),(1,4,7),(1,4,8),(1,5,6),(1,5,7),(1,5,8),(2,4,6),(2,4,7),(2,4,8),(2...
16:52:32 <Cale> (which should be enough convincing that it's not simply for IO :)
16:53:07 <hpc> SubtleArray: for now though, ignore it because do-notation code looks way to imperative to the untrained eye
16:53:18 <Cale> Functions also implement the Monad interface, and you can use do notation to distribute a function parameter "environment" to a bunch of functions:
16:53:24 <otters> I'm sure there's a good reason you can't declare instances in ghci
16:53:33 <elliott> Cale: are you sure that's helpful at this stage of learning? :P
16:53:39 <Cale> > (do x <- id; y <- reverse; z <- map toUpper; return (x,y,z)) "hello"
16:53:40 <lambdabot>   ("hello","olleh","HELLO")
16:53:46 <Cale> Just giving examples :)
16:53:49 <otters> o_O
16:53:52 <hpc> Cale: just let it be enough to know it exists ;)
16:53:57 <otters> oh wait, ((->) e) is a Monad instance right
16:54:01 <Cale> yes
16:54:06 <otters> that explains it
16:54:13 <Cale> :)
16:54:14 <hpc> SubtleArray: if you are going through LYAH, monads will be covered in one of the later chapters
16:54:20 <hpc> SubtleArray: you'll be good and ready for them at that point
16:54:23 <otters> @instances Monad
16:54:24 <lambdabot> ((->) r), ArrowMonad a, ContT r m, Either e, ErrorT e m, IO, Maybe, RWST r w s m, ReaderT r m, ST s, StateT s m, WriterT w m, []
16:54:56 <otters> @src ((->) r) (>>=)
16:54:57 <lambdabot> Source not found. Maybe if you used more than just two fingers...
16:55:03 <otters> dammit lambdabot
16:55:06 <hpc> hmm
16:55:07 <elliott> @src (->) (>>=)
16:55:07 <lambdabot> f >>= k = \ r -> k (f r) r
16:55:10 <otters> ...oh
16:55:13 <mike-burns> I appreciate lambdabot 's sass.
16:55:19 <hpc> do ArrowMonad and Kleisli cancel each other out?
16:55:21 <otters> so er
16:55:33 <hpc> like, would their composition yield the same monad instance as if neither was there
16:55:36 <Cale> hpc: I would be upset if they didn't.
16:55:54 <otters> wait
16:56:02 <otters> so >>= on -> isn't function composition
16:56:03 <SubtleArray> hpc: I think I almost have it. I'm trying to make sense of this now. http://www.haskell.org/haskellwiki/Let_vs._Where
16:56:03 <otters> what is it
16:56:27 <Cale> It's a funny lifted application (in reverse order)
16:56:40 <otters> it's like
16:56:41 <elliott> fmap on (->) is function composition
16:56:45 <cmccann> hpc, well, Kleisli = ReaderT
16:56:45 <Cale> (f =<< x) r
16:56:46 <otters> f >>= g = f (g x) x
16:56:53 <otters> so it's
16:57:06 <hpc> @unmtl ReaderT r m a
16:57:07 <lambdabot> r -> m a
16:57:16 <cmccann> and ArrowMonad forces the input to be () if memory serves me
16:57:20 <hpc> cmccann: with different type order, but yeah
16:57:23 <otters> so f has to take two args?
16:57:27 <hpc> never noticed that before
16:57:30 <cmccann> so you've basically got a ReaderT with () for the environment
16:57:34 <Cale> otters: you have that backward
16:58:01 <otters> Cale: explain
16:58:11 <Cale> (f =<< x) r = f (x r) r
16:58:28 <Cale> you had f and g swapped
16:58:30 <cmccann> hpc, sadly MonadTrans and Category need different type parameter orders, otherwise they really could be the same :P
16:58:39 <hpaste> SubtleArray pasted ‚ÄúMy new, do-less, function‚Äù at http://hpaste.org/63583
16:58:41 <otters> I see
16:58:47 <otters> oh, wait
16:58:52 <SubtleArray> There. :D
16:58:59 <Cale> So that's like function application, only it applies everything to r first
16:59:04 <otters> I see
16:59:07 <Cale> kinda
16:59:24 <hpc> cmccann: amazing how flipping a few arguments totally warps your perspective on something
16:59:35 <mandaya> woah
16:59:39 <mandaya> I've never thought of it like that
16:59:57 <maloi> how can i infer the type of (.)(.)(.)?
17:00:23 <Pseudonym> :t (.)(.)(.)
17:00:24 <lambdabot> forall (f :: * -> *) a b (f1 :: * -> *). (Functor f, Functor f1) => (a -> b) -> f (f1 a) -> f (f1 b)
17:00:26 <elliott> SubtleArray: you should really say not (null x) rather than x /= [] though
17:00:34 <hpc> maloi: http://hpc.dyndns-web.com:8000/blog/view.cgi?id=4 -- should help you work it out yourself
17:00:38 <mike-burns> Or use a Data.Map.
17:00:45 <hpc> :t let (.) = (Prelude..) in (.) . (.)
17:00:46 <lambdabot> forall a b c a1. (b -> c) -> (a -> a1 -> b) -> a -> a1 -> c
17:00:58 <Cale> actually, I like the Functor approach for understanding the resulting type
17:01:10 <Cale> It makes it a lot easier to guess if you think of it as fmap . fmap
17:01:18 <hpc> true
17:01:19 <maloi> i know the type but cannot infer it by myself
17:01:34 <elliott> maloi: just use unification
17:01:35 <maloi> thx hpc...i'll have a look
17:01:37 * cmccann wonders if Cale would like the back and forth operators :P
17:01:44 <SubtleArray> elliot: Woah... null x worked that time. No warnings or errors.
17:01:44 <Cale> What are those?
17:01:48 <elliott> cmccann: STOP, HE'LL PUT THEM IN LAMBDABOT!
17:01:50 <hpc> maloi: be warned, im a horrible writer :P
17:01:52 <elliott> SubtleArray: you probably want "not (null x)"
17:01:53 <cmccann> :t (<<<) >>> (<<<) >>> (<<<)
17:01:54 <elliott> for x /= []
17:01:54 <lambdabot> forall (cat :: * -> * -> *) b c a a1 a2. (Control.Category.Category cat) => cat b c -> (a2 -> a1 -> cat a b) -> a2 -> a1 -> cat a c
17:02:05 <cmccann> :t (>>>) <<< (>>>) <<< (>>>)
17:02:06 <lambdabot> forall c c1 (cat :: * -> * -> *) a b c2. (Control.Category.Category cat) => cat a b -> ((cat b c2 -> c1) -> c) -> (cat a c2 -> c1) -> c
17:02:10 <hpc> oh god what
17:02:17 <Cale> :D
17:02:20 <alpounet> ewww
17:02:23 <cmccann> back and forth and back and forth
17:02:28 <otters> holy crap
17:02:36 <otters> :t (&&&) >>> (&&&)
17:02:37 <lambdabot> forall (a :: * -> * -> *) b c c' c'1. (Arrow a) => a b c -> (a b c' -> c'1) -> a b c' -> (a b (c, c'), c'1)
17:02:37 <cmccann> one gives you fmap for Reader, the other is fmap for Cont
17:02:38 <SubtleArray> elliot: Phew... That worked too.
17:02:50 <elliott> cmccann: ha, got a pull request in before you could apply it
17:02:59 * cmccann shakes his fist
17:03:05 <sam8> I'm not sure about the keyword forall in haskell
17:03:10 <sam8> why do we need it?
17:03:16 <sam8> or when do we need it?
17:03:20 <otters> we <3 redundancy
17:03:26 <hpc> sam8: higher ranked types
17:03:31 <hpc> :t runST
17:03:32 <lambdabot> forall a. (forall s. ST s a) -> a
17:03:47 <SubtleArray> elliot: Thanks again, folks. It's been very educational. Now I think these functions are done.
17:03:49 <mike-burns> SubtleArray: If keywords were a Data.Map, you could instead write:  map (\x -> findWithDefault "no match" x keywords) xs
17:03:53 <hpc> the inner forall magic is important, as it ensures at the type level that STRefs can't leak from their respective actions
17:03:57 <mike-burns> (I think.)
17:04:15 <hpc> ST is the "IO but not IO" monad
17:04:39 <hpc> you can do pointery things, but you can't mess with the outside world, so it all looks like normal haskell to the surrounding code
17:04:39 <sam8> I'm not sure if I quite understand for forall does then...
17:04:43 <elliott> for definitions of IO equal to "mutable state"
17:04:46 <Axman6> "IO without actual I or O" monad
17:04:56 <mike-burns> Also, SubtleArray , it's suspicious that matchLocation produces [String] instead of e.g. [Location] .
17:05:24 <SubtleArray> mike-burns: True, but I already spent a half day working on these. Haha. I'll use more of the modules for the next app. But it's good to know they exist. It'll definitely make life easier.
17:05:39 <mike-burns> Heh, fair enough.
17:05:40 <hpc> sam8: don't worry, i don't either - i just know what the typechecker does with it and try to stay away as much as i can
17:06:03 <sam8> hm2026 alright then I guess
17:06:07 <sam8> thanx
17:06:37 <SubtleArray> mike-burns: These functions are just an over-engineered solution for narrowing down the users input into a few words so they can be easily pattern matched later.
17:06:50 <Cale> http://hpaste.org/63585 <-- the type error that I am currently facing down
17:07:22 <SubtleArray> I'm trying to do some natural language processing.
17:07:22 <hpc> Cale: gadzooks
17:07:23 <Cale> I have no clue why it seems to think that a can't unify with ()
17:08:03 * hackagebot copilot-language 0.6 - A Haskell-embedded DSL for monitoring hard real-time  distributed systems.  http://hackage.haskell.org/package/copilot-language-0.6 (LeePike)
17:08:10 <Cale> actually, wait
17:08:33 <Cale> ah, it introduced that a0 itself
17:08:45 <Cale> forNodes is perfectly general over the result type
17:08:57 <Cale> and it failed to generalise the a0 that it introduced
17:09:11 <Cale> and then complained at me for unifying it with ()
17:09:15 <Cale> wtf ghc
17:09:32 <elliott> cmccann: btw, I didn't actually try to compile that change to see if I did it right or anything :P
17:09:39 <otters> I still don't get (->) (>>=)
17:09:55 <hpc> Cale: it's also introducing x1, n1
17:09:59 <Cale> otters: did you see my do-notation example?
17:10:08 <otters> yes
17:10:12 <otters> do-notation examples never help me
17:10:17 <alpounet> otters, maybe should you try to write down the type of >>= for (->) ?
17:10:19 <elliott> otters: it passes along the result of the left-hand side and also the value itself
17:10:26 <Cale> hpc: hmm
17:10:26 <otters> I see
17:10:28 <rwbarton> well it seems to have decided that a = RAM bi ei bo eo (GM x) a0?
17:10:31 <elliott> otters: foo >>= k = \x -> k (foo x) x
17:10:37 <Cale> hpc: it sure did
17:10:40 <elliott> otters: so, as we know, k (for any monad) takes the "result" of foo
17:10:41 <rwbarton> oh hm
17:10:42 <rwbarton> nm
17:10:47 <otters> elliott: alright
17:10:49 <elliott> otters: which is applying it to the "environment" (x)
17:10:54 <otters> so why would anybody do this?
17:10:56 <elliott> otters: and then returns a monadic action
17:11:01 <elliott> which requires the environment itself
17:11:05 <elliott> the function monad is useful
17:11:07 <elliott> for instance
17:11:10 <elliott> > join f x :: Expr
17:11:11 <lambdabot>   f x x
17:11:15 <elliott> join f = \x -> f x x
17:11:17 <elliott> in the function monad
17:11:19 <Cale> hpc: The typechecker in 7.2.2 and 7.4.1 has been doing some really crazy things to me.
17:11:36 <kallisti> why is factorial called factorial?
17:11:46 <cmccann> elliott, that's okay, I'm not actually responsible for this thing, remember
17:11:53 <hpc> kallisti: very good question
17:11:59 <elliott> cmccann: hehe
17:12:13 <elliott> cmccann: whoa, creepy, it's actually linked everyone to their github accounts: https://github.com/isomorphism/hackage2/commits/master
17:12:14 <kallisti> otters: are you familiar with the Reader monad?
17:12:22 <Cale> hpc: I had a whole swath of top-level bindings without explicit type signatures (because they just did obvious things to extract/set/modify bits of the state in a state monad), and it inferred types for them which it failed to generalise all the type variables in.
17:12:23 <otters> nope
17:12:24 <mike-burns> kallisti: I assume it's from "factors".
17:12:40 <Cale> hpc: none of them were usable as a result
17:12:46 <kallisti> mike-burns: that would make sense, I guess.
17:13:19 <cmccann> elliott, oh hey, yeah. I think github picks up on that by email or something.
17:13:34 <kallisti> otters: well, the Reader monad and the function monad are the same.
17:13:52 <kallisti> so, if you learn one, you learn the other! it's a special two for one deal.
17:13:56 <kallisti> >_>
17:13:57 <otters> I see
17:14:01 <otters> well I'm working on it
17:14:16 <Cale> (however, the problem went away when I gave the same type signature as it inferred, but with all the variables forall'd)
17:14:22 <kallisti> otters: so perhaps learning it from the Reader perspective will make it more clear.
17:15:44 <hpc> Cale: smells like a bug in ghc's type inference code
17:15:51 <hpc> assuming your "obvious" is the same as mine :P
17:16:09 <Cale> hpc: yeah
17:16:14 <rwbarton> does it help if you give a type signature to the argument of forNodes?
17:16:34 <Cale> rwbarton: I'm about to try specialising forNodes and giving a type signature to that
17:16:35 <kallisti> otters: a common thing that happens in the "real world" is a situation where you have a computation whose result depends on a lot of environmental information. For example, your computation might depend on the results of parsing a config file.
17:16:50 <otters> well yeah
17:17:00 <otters> but I don't understand how >>= on functions applies
17:17:18 <kallisti> otters: well, considering how you would pass this environment information around.
17:17:28 <kallisti> -ing
17:17:36 <hpc> otters: it would just be an extra parameter you pass to every function
17:17:41 <otters> okay
17:17:47 <kallisti> without using something like the Reader monad, you would simply explicitly pass that environment around to all of your functions.
17:17:50 <kallisti> yes.
17:17:55 <otters> okay
17:18:33 <QinGW> How to install HaRe under GHC 7.04?
17:18:38 <otters> so
17:18:41 <otters> okay
17:22:51 <kallisti> otters: I recommend learning the Reader monad first.
17:22:59 <otters> I'll try
17:23:33 <kallisti> otters: the function monad is mostly interesting because of other functions that can be defined in terms of >>= and return
17:23:45 <kallisti> such as fmap and ap
17:23:55 <otters> in "Reader r a" what do r and a represent?
17:24:02 <kallisti> otters: r is your environment
17:24:04 <otters> wait, r is the enivornment
17:24:07 <otters> *ron
17:24:09 <otters> okay
17:24:13 <kallisti> a is the result of the computation.
17:24:16 <otters> okay
17:24:24 <kallisti> instance Monad (Reader r) where ...
17:25:07 <Axman6> @unmtl Reader r a
17:25:08 <lambdabot> r -> a
17:27:03 <kallisti> otters: normally >>= just grabs the result of the reader computation, while ignoring the environment
17:27:30 <kallisti> otters: however if you do this:  ask >>= (\r -> ...)
17:27:45 <wavewave> hi
17:27:57 <otters> so asks is for convenience and not fundamentally different from ask
17:27:57 <kallisti> r refers to the (otherwise implicit) environment
17:28:09 <kallisti> otters: yep
17:28:12 <otters> hmm
17:28:17 <otters> I should probably rewrite my project to use reader
17:28:22 <otters> remove some redundancy
17:28:28 <kallisti> otters: yes it's quite a common pattern.
17:30:12 <kallisti> otters: newtype Reader r a = Reader (runReader :: r -> a)
17:30:40 <kallisti> notice that the only field to the constructor Reader is just a function r -> a
17:30:53 <kallisti> so Reader r a is completely equivalent to r -> a
17:31:24 <kallisti> or, well, it's isomorphic. obviously they're not equivalent in Haskell because they have different types.
17:31:59 <kallisti> otters: ask = Reader id
17:32:40 <otters> okay
17:32:53 <kallisti> so ask is a Reader that, when ran, takes its environment and returns it.
17:33:31 <otters> :t runReader
17:33:32 <lambdabot> forall r a. Reader r a -> r -> a
17:33:35 <otters> oooh
17:33:43 <otters> so runReader actually returns the computation result of the environment
17:33:47 <otters> neato
17:34:09 <kallisti> yes that's how you pass the environment in.
17:34:26 <kallisti> runReader someReader myEnv
17:34:35 <wavewave> my first calligraphic hxournal artwork showing haskell : http://ianwookim.org/hxournal/gallery.html
17:34:48 <shapr> wavewave: very cool!
17:35:25 <shapr> Too bad my x61t doesn't support pressure-sensitivity.
17:35:30 <kallisti> otters: this is a bit more complicate:  m >>= k  = Reader $ \r -> runReader (k (runReader m r)) r
17:35:39 <shapr> On the good side, hxournal makes it easier for me to take notes in classes where TeX falls short.
17:35:40 <wavewave> x61t does support it as I know.
17:35:53 <cmccann> wavewave, nice!
17:35:58 <shapr> Huh, do I need a different stylus?
17:36:17 <wavewave> no... it is wacom, isn't it?
17:36:27 <shapr> Yes
17:36:37 <wavewave> yes.. then you don't need any special thing..
17:36:56 <wavewave> if you cannot use it, that's maybe your linuxwacom driver problem.
17:37:12 <wavewave> btw, my notebook is x41t
17:37:29 <kallisti> otters: so k receives the result of running m with some environment r (which will be given to us later)
17:37:43 <otters> I see
17:37:49 <otters> okay unrelated to readers question
17:38:02 <shapr> wavewave: Ah, that has the first touch/stylus wacom screen on the thinkpad, I think.
17:38:06 <otters> I wanna test my project that is using the Paths_* module
17:38:11 <shapr> wavewave: Do you use Linux, and get pressure sensitivity as well?
17:38:13 <otters> without having to build it and then test it
17:38:14 <otters> because that's a pain
17:38:28 <wavewave> shapr: yes.. as always!
17:38:41 <kallisti> otters: well, of course, you'll need to compile the part of the program you want to test.
17:39:14 <otters> well, can I just replace getDataFileName with a dummy if it's not in "compiled" form?
17:39:25 <otters> like with a preprocessor directive?
17:39:38 <kallisti> otters: sure you can replace it with some constant value.
17:39:51 <otters> guess I should research directives on my own
17:39:56 <kallisti> getDataFileName = return "something"
17:40:13 <otters> I guess I could remove it if building
17:40:20 <otters> but I'd rather not leave that up to me to make the mistake
17:40:23 <otters> of not removing it
17:40:24 <wavewave> x41t came out in 2005... so i am testing hxournal in very harsh condition. hihi.
17:40:31 <kallisti> otters: I'm not sure I really understand the problem.
17:40:38 <kallisti> otters: just comment out the code and replace it with a dummy
17:40:49 <wavewave> my performance requirement is to work well in x41t.
17:41:06 <otters> kallisti: I want to know if there's a ghc pragma that will allow me to have a dummy getDataFilePath if I'm running the code "in development", and use the actual one if it's "in production"
17:41:19 <shapr> wavewave: I assume it will work well on my x61t then
17:41:24 <otters> or a compiler directive
17:41:27 <kallisti> otters: there's a CPP "extension"
17:41:27 * shapr cabal installs hxournal
17:41:35 <kallisti> otters: also a compiler option.
17:41:46 <otters> which?
17:42:05 <kallisti> http://google.com
17:42:07 <wavewave> it should work. I think ezyang's tablet was x61t and I watched hxounal running on his computer in last HacBos.
17:42:09 <otters> bah
17:42:11 <otters> fine
17:43:11 <kallisti>  /topic Welcome to the official Haskell spoonfeeding community!
17:43:43 <otters> hey, depends on how significantly faster it is for me to ask and for you to tell me than it is for me to google around
17:43:59 <kallisti> I'd have to google as well because it's not something I've ever needed to use.
17:44:02 <otters> oh, okay
17:44:04 <otters> see, there you go
17:44:04 <kallisti> I'd imagine it's something like CPP or something.
17:44:13 <otters> well CPP gave me enough information
17:44:16 <otters> thanks
17:45:19 <kallisti> otters: if you understand Reader, now it's time to learn State!
17:45:32 <otters> not sure if I understand Reader yet
17:45:36 <otters> but there should be no reason not to
17:45:43 <kallisti> then Writer. then RWS (that one's easy).
17:46:11 <otters> damn google
17:46:18 <kallisti> otters: well at the very least you probably understand the interface.
17:46:22 <otters> yeah
17:46:29 <otters> if not the inner workings
17:47:01 <kallisti> the implementation of >>= is basically just specify what happens once we actually receive the environment via a call to runReader
17:47:09 <kallisti> *specifying
17:47:31 <kallisti> or well, that's... what run
17:47:38 <kallisti> *runReader does.
17:48:07 <kallisti> so all the other functions on Readers are just defining what runReader is in terms of other Readers.
17:48:23 * kallisti isn't sure that he's actually helping. :P
17:48:35 <otters> well, I kinda get you
17:48:36 <otters> sorta
17:48:44 <kallisti> return a = Reader $ \_ -> a
17:48:46 <kallisti> this one is simple enough
17:48:59 <kallisti> fmap f m = Reader $ \r -> f (runReader m r)
17:49:01 <kallisti> perhaps this as well.
17:49:37 <otters> oh yes
17:49:53 <kallisti> we don't know what the environment value is yes
17:50:01 <kallisti> s/yes/yet
17:50:04 <kallisti> thus the lambda
17:53:13 <kallisti> otters: the code inside the lambda is what happens when runReader is called.
17:53:20 <kallisti> with a given environment
17:53:24 <otters> alright
17:53:48 <otters> oh wow now I understand the wiki's IRC bot example
17:54:07 <otters> it only just occurred to me now that "asks socket" is actually "ask and then apply the function 'socket' to the result"
17:54:10 <otters> and socket is just an accessor
17:54:12 * otters moron
17:55:04 <kallisti> well, it's not always clear when you're still learning the basics.
17:55:27 <otters> yeah
17:55:40 <kallisti> otters: if you get Reader then State is fairly similar.
17:56:35 <hpaste> scooty-puff pasted ‚ÄúType Checking Issue‚Äù at http://hpaste.org/63586
17:56:47 <scooty-puff> anyone have any advice?
17:56:58 <scooty-puff> i can put the definitions of Successors and Stmt if required
17:57:44 <kallisti> otters: the difference is that State allows you to both read and write to the implicit data.
17:59:07 <kallisti> (though Reader actually does allow you to locally modify the environment via the local function, but you can't effect the environment for subsequent computations via this mechanism)
17:59:15 <kallisti> *affect
17:59:29 <wavewave> shapr : did you succeed?
17:59:53 <kallisti> local :: (MonadReader r m) => (r -> r) -> m a -> m a
17:59:59 <shapr> wavewave: I had to update gtk2hs build tools first, it's building now.
18:00:09 <wavewave> oh.. right.
18:00:21 <kallisti> otters: local takes a function that modifies the environment, and a Reader to execute within this modified environment.
18:00:31 <scooty-puff> local has got to be one of the more useful ways to use MonadReader imo
18:00:48 <wavewave> shapr: also check hxournal google group. I am announcing things there.
18:01:04 <shapr> I will, thanks!
18:01:14 <mandaya> what are flexible instances, and is there any reason I wouldn't want to enable them?
18:01:31 <mandaya> I have something that won't type check, but says it will with flexible instances
18:01:36 <wavewave> instance SomeClass (T X) where
18:01:42 <kallisti> scooty-puff: there are situations where you have a completely read-only state that is so pervasive that your code benefits from using Reader rather than explicitly passing it as a parameter.
18:01:53 <wavewave> mandaya : if you want this kind of things, then you need it.
18:02:03 <mandaya> ahh, thanks
18:02:12 <mandaya> that's exactly what I'm trying to do
18:02:17 <wavewave> symmetrically.. if you want
18:02:40 <wavewave> f :: (SomeClass (T X)) => ....
18:02:49 <wavewave> then you need FlexibleContexts
18:03:22 <wavewave> mandaya: they are pretty standard.. I think they will be in the next version of haskell standard.
18:03:29 <scooty-puff> so speaking of http://hpaste.org/63586, do GADTs not use the normal means of type checking?
18:03:47 <mandaya> does that mean that if I want to make a list of something an instance of a class, I have to use flexible instances?
18:03:55 <mandaya> or do lists get promoted to a single type?
18:04:02 <scooty-puff> i.e. if you have A a -> B a, it can be used as A Int -> B Int, etc., right?
18:04:08 <wavewave> mandaya: that's what you want.
18:04:11 <kallisti> is there anything like Writer but over MonadPlus instead of Monoid?
18:04:16 <shapr> wavewave: I had the urge to make a trig graphing gtk app, is the hxournal source a good place to look for example gtk2 code?
18:04:23 <mandaya> (asking to make sure I understand what's going on)
18:04:30 <scooty-puff> kallisti, you could make a newtype wrapper and define a monoid for that
18:04:37 <mandaya> I already added the flexible instances declaration
18:04:37 <kallisti> I suppose it would be easy enough to -- yes that
18:04:46 <wavewave> shapr: I think it's too big for such purpose..
18:04:52 <wavewave> shapr : just refer to my gist.
18:05:21 <wavewave> shapr: http://gist.github.com/wavewave
18:05:48 <wavewave> I am trying to put things on there whenever I learn some new skills.
18:06:53 <wavewave> mandaya, [SomeType] as an instance of some class can be different from [] as a generic instance of more higher order class.
18:07:17 <wavewave> anyway.. [SomeType] is of kind *, and [] is of kind * -> *
18:07:19 <kallisti> > let fac 0 = return 1; fac n = tell (Product n) >> fac (n-1) in runWriter (fac 5)
18:07:19 <lambdabot>   (1,Product {getProduct = 120})
18:07:39 <mandaya> wavewave: right, but doesn't [SomeType] desugar to List SomeType?
18:07:59 <wavewave> mandaya: for example, consider [SomeType] as an instance of Show class
18:08:05 <kallisti> I guess return () would be more appropriate
18:08:22 <wavewave> mandaya: then you cannot have : instance Show [] where
18:08:31 <wavewave> because [] is * -> * kind.
18:08:36 <mandaya> right
18:08:42 <wavewave> mandaya: so flexible instance is needed.
18:08:52 <mandaya> ok, that's what I was wondering
18:08:57 <mandaya> thanks!
18:09:14 <wavewave> flexible instance must be in the standard.. I do not understand why it was not included in haskell2010.
18:10:03 <wavewave> shapr: btw, what's trig graphing?
18:12:07 <kallisti> s/flexible instance/flexible contexts/r =~ s/flexible contexts/type synonym instances/r
18:12:57 <kallisti> they should all be part of the SensibleInstances extension
18:13:19 <wavewave> kallisti: ah.. yes.. type synonym instances, too.
18:15:02 <shapr> wavewave: I want to type in any old sine curve and have it graphed.
18:15:19 <kallisti> wavewave: I'm guessing there was just too many revolutionary changes. They didn't want to do anything too radical.
18:15:37 <kallisti> wavewave: I mean FFI, pattern guards, and hierarchical module names are all pretty extreme.
18:16:15 <elliott> The FFI and hierarchical module names are hardly new.
18:16:37 <kallisti> (whoosh)
18:17:21 <kallisti> I've never actually used pattern guards.
18:17:44 <kallisti> simply because I never think to use them. I bet I could simplify some of my existing code.
18:19:40 <wavewave> shapr: gnuplot doesn't do it for you well?
18:19:57 <wavewave> shapr : btw, there are some package for that.. chart?
18:20:33 <wavewave> shapr: Yeah.. Chart ..
18:20:50 <wavewave> http://www.dockerz.net/software/chart.html
18:21:07 <wavewave> pretty impressive package.
18:22:06 <shapr> Sure, but I'd rather write it myself to learn the basics of gtk2hs.
18:22:26 <shapr> Any ideas about: Loading package double-conversion-0.2.0.4 ... <command line>: can't load .so/.DLL for: stdc++ (libstdc++.so: cannot open shared object file: No such file or directory) ?
18:22:56 <shapr> I certainly have libstdc++ installed...
18:23:17 <hpaste> scooty-puff pasted ‚ÄúType Checking Issue, Simplified‚Äù at http://hpaste.org/63590
18:23:35 <scooty-puff> heres i simplified example of the problem i had earlier
18:24:08 <scooty-puff> for some reason f is monomorphic, i think..
18:24:21 <scooty-puff> even though the instance declaration defines it as polymorphic
18:24:22 <shapr> wavewave: Any ideas about this? http://hackage.haskell.org/packages/archive/hxournal/0.6.1.0/logs/failure/ghc-7.2
18:24:35 <elliott> scooty-puff: yes, it is
18:24:41 <elliott> scooty-puff: because the "a" is quantified at the instance level
18:24:52 <elliott> you want "instance TestStuff (forall a. a -> Test a)  where" which is not a valid instance
18:24:54 <elliott> (afaik)
18:25:00 <elliott> so you'll need a wrapper around it
18:25:06 <elliott> data Foo = Foo (forall a. a -> Test a)
18:26:42 <scooty-puff> elliott, thanks!  been trying to get around this one all day
18:27:24 <shapr> Lots of pingout suddenly...
18:27:28 <scooty-puff> elliott, did just try adding RankNTypes to verify that a forall in the instance wasn't valid (you're right, it isn't - unless need a diff language extension)
18:28:23 <shapr> wavewave: Are you building hxournal with ghc-7.4 ?
18:29:48 <sam8> Hi can someone help with the error that I get?
18:29:49 <sam8> http://hpaste.org/63591
18:33:29 <lispy> sam8: if you write it without the type defs, does it make more sense?
18:33:45 <lispy> sam8: in particular, I'm never really sure how the type class contraints expand out
18:34:41 <lispy> sam8: From the error message it seems like some rank2-something-or-another happened
18:34:43 <covi> I was mind-blown by this:
18:34:46 <covi> fib             = 1 : 1 : [ a+b | (a,b) <- zip fib (tail fib) ]
18:35:07 <lispy> > fix $ \fibs -> 1 : 1 : zipWith (+) fibs (tail fibs)
18:35:07 <lambdabot>   [1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765,10946,1...
18:35:12 <sam8> hm2026 I see2026 let me look back at the code
18:35:59 <lispy> covi: your mission, if you choose to accept it, is to figure out how the version with fix works :)
18:36:49 <covi> lispy: fix? I just couldn't quite figure out how that statement magically and correctly generates the fibo sequence
18:37:11 <sam8> lispy: What is rank2-something-or-another ?
18:37:13 <kallisti> lispy: no don't do it! it's too dangerous! his brain will explode!
18:38:09 <covi> Guys I need your help :) I tried several tutorials and there's no clear explanations.
18:38:17 <Mike___> Can someone please help me with random? I've tried to read LYAH, looked at working examples, and still cannot know how to implement it in my code >_<
18:38:31 <lispy> sam8: foo :: a -> (forall b. b) -- this is an example of a rank2 type
18:38:40 <lispy> sam8: I'm just guessing though based on the error.
18:39:00 <lispy> covi: explanation of what, your original version? or fix?
18:39:30 <covi> lispy: the original
18:39:46 <scooty-puff> http://stackoverflow.com/questions/3957192/rankntypes-for-instance-declarations
18:39:51 <lispy> covi: do you understand what zip does?
18:40:15 <nand`> fwiw, in your original definition you can replace that zip list comprehension with zipWith (+) fibs (tail fibs)
18:40:17 <scooty-puff> the answer is related to the problem i had, but i post it because someone mentioned going from MonadPlus to Monoid - think this is that but the other way around (maybe not - just skimmied)
18:40:50 <lispy> > zip [1..] "I like pizza"
18:40:51 <lambdabot>   [(1,'I'),(2,' '),(3,'l'),(4,'i'),(5,'k'),(6,'e'),(7,' '),(8,'p'),(9,'i'),(1...
18:41:14 <lispy> covi: it just pairs up the elements of its arguments
18:41:23 <lispy> covi: zip = zipWith (,)
18:41:25 <wavewave> shapr: I haven't installed ghc-7.4 yet.
18:41:41 <wavewave> shapr : are you using ghc-7.4 ?
18:42:06 <covi> (dunno what 'fix' is)
18:42:53 <covi> lispy: I understand what zip does. And I understand after the 'first step of the construction', fibs = [1, 1, 2], but I don't understand what happens next
18:44:10 <wavewave> shapr : if you got libstdc++.so error, that's common problem of a package using double-conversion. Workaround is to make a symbolic link of libstdc++.so.6 with name libstdc++.so somewhere in path.
18:44:47 <wavewave> I heard that bug was eliminated in ghc-7.4.. but I am not sure..
18:44:59 <shapr> I'm using ghc-7.0.3
18:45:30 <wavewave> shapr: okay. then.. at least almost same set up as me. (7.0.4)
18:45:50 <lispy> covi: after the first step, fibs isn't _just_ [1,1,2]
18:45:55 <wavewave> shapr: were you bitten by stdc++ problem?
18:45:56 <td123> shapr: what distro?
18:46:17 <lispy> covi: it has more hanging off the right had side of that list
18:46:23 <lispy> hand*
18:46:48 <shapr> td123: ubuntu 11.10
18:47:06 <shapr> wavewave: Yes, I'm looking around for the right place to symlink...
18:47:15 <alpounet> aleator_, pinf
18:47:15 <lispy> covi: in particular, if you take the definition of fibs and expand things out, you might see what I mean
18:47:16 <alpounet> ping*
18:47:25 <wavewave> I just put it in /usr/lib ;-P
18:48:22 <lispy> fibs = 1 : 1 : [a+b|(a,b) <- zip fibs (tail fibs] is fibs = 1 : 1 : [a+b|(a,b) <- zip (1 : 1 : ...) (tail (1 : 1 : ...)]
18:48:55 <shapr> wavewave: done, time to try the build once again...
18:49:11 <lispy> covi: if you start expanding it this way, be careful, it's unbounded in size :)
18:51:03 <shapr> w00t! It runs!
18:51:13 <wavewave> ;-)
18:51:39 <wavewave> should not be followed by 'it crashed'
18:52:33 <wavewave> shapr: does your pen work?
18:52:39 <covi> lispy: my network is unstable. Did I miss anything?
18:52:48 <lispy> covi: Just this I think
18:53:00 <lispy> fibs = 1 : 1 : [a+b|(a,b) <- zip fibs (tail fibs], that becomes fibs = 1 : 1 : [a+b|(a,b) <- zip (1 : 1 : ...) (tail (1 : 1 : ...)]
18:53:01 <shapr> wavewave: yah, but I don't get any pressure sensitivity
18:53:06 <td123> shapr: k, nvm
18:53:08 <shapr> wavewave: touch and pen both work though
18:53:15 <wavewave> shapr : there is menu in options
18:53:25 <shapr> wavewave: and no crashes :-) though a bit much debug output on the command line
18:53:27 <wavewave> it's disabled as a default.
18:53:31 <shapr> wavewave: I enabled it
18:53:58 <covi> lispy: So, it's better not to think of it in a sequential way?
18:54:03 <lispy> covi: in haskell, when you have a definition like, foo = bar, and you see foo, you can replace with bar. Try using that to expand out the definition of fibs.
18:54:11 <wavewave> shapr: okay... then.. your x11 setup is not complete for it I guess.
18:54:36 <shapr> :-(
18:54:37 <wavewave> shapr:anyway. enjoy!
18:54:47 <shapr> I will, thanks for writing this!
18:54:51 <lispy> covi: if you think about it sequentially in the right way you may arrive at the right understanding, but if you're new to this example it's unlikely.  So, you can tihnk of it sequentially, but it takes practice.
18:55:21 <wavewave> shapr :  I think you can find the solution well.. there are many x61t linux users as I know.
18:55:54 <covi> lispy: thanks. will try to work it out
18:56:07 <shapr> wavewave: Yah, I'll poke at it when my homework is done.
18:56:15 * shapr goes off to learn more trig
18:56:28 <wavewave> shapr: ;-)
18:56:39 <MaskRay> > let fib = 1 : scanl1 (+) fib in take 10 fib
18:56:40 <lambdabot>   [1,1,2,4,8,16,32,64,128,256]
18:57:41 <MaskRay> > let fib = 1 : scanl (+) 1 fib in take 10 fib
18:57:42 <lambdabot>   [1,1,2,3,5,8,13,21,34,55]
18:59:16 <MaskRay> > let fib = fix ((1:) . scanl (+) 1) in take 10 fib
18:59:18 <lambdabot>   [1,1,2,3,5,8,13,21,34,55]
18:59:25 <sam8> Please help on the code
18:59:25 <sam8> http://hpaste.org/63593
19:00:30 <sam8> is this because MyType is not concrete type?
19:01:09 <lispy> sam8: I think it's because of the use of 'type'
19:01:46 <lispy> I could be wrong, because I don't understand why it cares about Integer there
19:02:00 <wavewave> sam8 : are you defining existential type?
19:02:07 <sam8> this is mind boggling
19:02:09 <lispy> It's saying that it wants a to be Integer
19:02:14 <sam8> what are existential types?
19:02:18 <wavewave> use data instead of type
19:02:39 <wavewave> but do not use that in this case.
19:02:55 <wavewave> just change type signature of your function
19:03:24 <wavewave> keyGen' :: Num a => a -> a -> a -> (a,a) ...
19:04:03 <sam8> instead of using type?
19:04:14 <wavewave> this is actually equivalent to what you were trying to do.
19:04:18 <wavewave> yes.
19:04:38 <sam8> so type does something? other than renaming types?
19:04:56 <wavewave> sam8 : there was some discussion long time ago on whehter allowing what you wrote or not..
19:05:01 <Sgeo> Not "rename" so much as "give an alternative name"
19:05:30 <wavewave> sam8 : but it's too complicated in implementer point of view.. so it's not allowed.
19:05:53 <wavewave> anyway  that function signature is exactly the same.
19:06:21 <sam8> I see2026
19:06:39 <elliott> erm
19:06:51 <elliott> wavewave: using data won't actually help there because it still doesn't match the semantics sam8 wants
19:06:52 <elliott> but yeah
19:07:09 <wavewave> elliott: yeah.. data is different..
19:07:14 <elliott> wavewave: but what sam8 wrote _is_ "valid"
19:07:19 <elliott> sam8 just also has a type error
19:07:27 <elliott> oh hmm
19:07:37 <elliott> why does that even work, there's a variable there never quantified
19:07:46 <elliott> ...meh
19:08:01 <sam8> wait2026 can't data work?
19:08:45 <wavewave> data works in different sense.. unnecessary internal rep.
19:08:45 <elliott> no
19:09:02 <wavewave> I mean with new data constructor..
19:09:38 <wavewave> and add general + operation for the new existential data type.
19:09:56 <wavewave> but that's just unnecessary..
19:10:01 <sam8> I see...
19:11:03 <wavewave> just think like hiding your constraint (Num a) in type synonym is not allowed.
19:11:21 <cmccann> haha, that's hilarious, it tries to default to Integer because of the ambiguous Num constraint
19:11:30 <cmccann> and then fails because... it can't default the type?
19:11:42 <elliott> cmccann: it fails because each "a" is diffeerent
19:11:54 <wavewave> constraints are lifted towards left side..
19:11:58 <elliott> cmccann: ((Num a) => a) -> ((Num a) => a) defaults to (Num a) => a -> Integer
19:12:01 <elliott> and a ~/~ Integer
19:12:03 <elliott> so it fails
19:12:04 <elliott> I /think/
19:12:10 <lispy> keyGen' :: (forall a. Num a => a) -> ((forall a. Num a => a) -> ...), right?
19:12:26 <cmccann> elliott, well yeah
19:12:35 <lispy> oh, boy, I think my parens are off.  I meant them to nest to the right.
19:13:16 <lispy> I never quite understood what GHC does with 'type' expansions.  Part of why I avoid it.
19:13:45 <lispy> It seems to do the right thing in cases like, type Foo = Bar Int, but otherwise it seems to confuse things
19:13:47 <maloi> how do i get from
19:13:47 * shapr adds water to his type
19:13:53 <maloi> @unpl (.)
19:13:53 <lambdabot> (\ a b c -> a (b c))
19:13:55 <maloi> to
19:14:06 <maloi> @unpl (.) (.) (.)
19:14:06 <lambdabot> (\ c e f i -> c (e f i))
19:14:26 <maloi> i don't get it :(
19:14:53 <SonicvanaJr> If a machine I have /w 2
19:15:02 <SonicvanaJr> opps, sorry
19:15:34 <lispy> maloi: let a = (.), b = (.)
19:16:03 <lispy> (\(.) (.) c -> (.) ((.) c))
19:17:02 <lispy> @unpl (\(.) (.) c -> (.) ((.) c))
19:17:03 <lambdabot> (\ (.) (.) c b d g -> c (b d g))
19:17:07 <lispy> heh
19:17:16 <wavewave> hmm : there is LiberalTypeSynonyms extension..
19:18:00 <wavewave> looks like it allows something like  type Type = forall a. Num a => a
19:18:05 <lispy> :t (\(.) (.) c -> (.) ((.) c))
19:18:06 <lambdabot>     Conflicting definitions for `.'
19:18:06 <lambdabot>     Bound at: <interactive>:1:2-4
19:18:06 <lambdabot>               <interactive>:1:6-8
19:18:08 <maloi> lispy: thx but that last step is what i don't get actually :)
19:18:33 * wavewave is reading 7.4.4 of latest ghc user's guide
19:19:05 <cmccann> wavewave, liberal type synonyms mostly just let you use them partially applied in type signatures, I think
19:19:37 <cmccann> with some entertaining consequences, like being able to encode church numerals in type synonyms and do basic arithmetic
19:19:45 <lispy> maloi: when you say, 'last step' you mean the substitution I did or the step after it?
19:20:04 <wavewave> cmccann: i see.. is this new addition?
19:20:09 <maloi> the step fter it (where u used @unpl)
19:20:23 <cmccann> ...basic arithmetic on church numerals, by the way, including exponentiation but not subtraction I guess
19:20:44 <cmccann> hm
19:20:55 <lispy> maloi: rename c to something like, z so it doesn't conflict, then use that substitution where (\a b c -> a (b c))
19:21:07 <cmccann> I should try to write the Ackerman function with type synonyms again, last time the thing that stopped me was needing polymorphic kinds
19:21:21 <cmccann> this is obviously an excellent idea
19:21:29 <cmccann> but anyway
19:21:36 <wavewave> hmm.... difficult.
19:22:02 <wavewave> Impredicative types.. LiberalTypeSynonyms... PolymorphicKinds..
19:22:03 <Mike___> is it hard to check if a file exists, and if not, create it?
19:22:20 <lispy> This is Haskell we solve more general recursion problems in the type system before 8am than most people solve all day.
19:22:26 <wavewave> that's hard :-P in my experience.
19:22:41 <cmccann> I'm not sure what's up with impredicative types these days
19:23:21 <wavewave> cmccann: I heard that it would be back around 7.4 time.. but i didn't follw.
19:23:39 * lispy doesn't like impredicative types
19:23:49 <lispy> So if they are gone, that's fine with me :)
19:23:52 <wavewave> those stuffs are too mind-boggling. now i am getting myslef away from it.
19:24:09 <serversale> I am selling dedicated servers (VDS) in different countries, windows xp, 2003,2008, seven, linux! write to PM who need them.
19:25:00 <cmccann> wavewave, but yes liberal type synonyms allow you to use quantifiers and whatnot as well in places you can't otherwise
19:25:12 <cmccann> but once all the synonyms are expanded the type still has to follow the same rules
19:26:29 <Mike___> Well, I've got all my work nearly done, keep having one single problem
19:26:32 <Mike___> if anyone can help me
19:26:53 <lispy> It's pretty amazing how little the core type system has changed even after all the front end type extensions.
19:27:07 <Mike___> *** Exception: tabela.txt: openFile: permission denied (Permission denied)
19:27:17 <lispy> Mike___: are you on windows?
19:27:23 <Mike___> yes I am
19:27:31 <wavewave> then.. it has a lock.
19:27:31 <lispy> Mike___: are you trying to have multiple readers on a file?
19:27:43 <Mike___> http://hpaste.org/63595
19:27:48 <Mike___> I think I only have one
19:27:58 <Mike___> oh well
19:28:01 <Mike___> now that you mention it
19:28:07 <Mike___> i do call main at the end again
19:28:12 <Mike___> and it calls the reader again
19:28:14 <Mike___> for the same file
19:28:54 <lispy> oh
19:28:59 <wavewave> Mike___ : use withFile if possible.
19:29:18 <lispy> I bet this is a problem with lazy readFile
19:29:21 <Mike___> what do you mean?
19:29:55 <lispy> readFile doesn't close a file until you've requested all the contents
19:29:59 <wavewave> your file is in open state until what you need has been read completely.
19:30:13 <wavewave> becaues lazy evaluation
19:30:15 <lispy> This is something I consider to be a bug in the Prelude
19:30:19 <Mike___> Is that possible if the file is empty?
19:31:04 <wavewave> hmm I didn't know readFile still leave a file open even if it finished.
19:31:07 <maloi> lispy: thx, i think i got it now
19:31:29 <wavewave> so withFile is safe in that behavior?
19:31:45 <lispy> you could test this theory by changing the last line of readTabela to be seq (length t) (return (read t))
19:32:18 <wavewave> btw, these days, I am using iteratee for all such operations to avoid such problem.
19:32:28 <Mike___> I tested something
19:32:32 <Mike___> i oppened the file
19:32:37 <Mike___> and tried to change it and save
19:32:39 <Mike___> it doesnt let me
19:32:43 <Mike___> it says it's beeing used
19:33:10 <Mike___> but, if i close ghci, it lets me change it
19:34:25 <Mike___> lispy: i tried what u said
19:34:26 <Mike___> *** Exception: Prelude.read: no parse
19:36:12 <lispy> Mike___: that means that t wasn't a valid string for [(Int,String)] which is not surprising considering t = "", right?
19:37:30 <rasfar> just got the darcs source (using darcs) -- watched the last bit of the get, it was bash scripts, lots of them.  Thought that was amusing...
19:37:35 <Mike___> hmm, but it shouldnt be happening
19:37:55 <lispy> rasfar: the entire test suite is bash scripts
19:38:04 * hackagebot rezoom 0.0.3 - Github resume generator  http://hackage.haskell.org/package/rezoom-0.0.3 (JoelTaylor)
19:38:06 * hackagebot highlighting-kate 0.5.0.4 - Syntax highlighting  http://hackage.haskell.org/package/highlighting-kate-0.5.0.4 (JohnMacFarlane)
19:38:19 <rasfar> why not quickcheck?
19:38:49 <lispy> rasfar: it uses that too for some unit testing, but what do you use to make sure all the units fit together?
19:39:35 <rasfar> lispy: i dunno, just being querulous
19:39:46 <lispy> rasfar: also, there is probably no end to legitimate 'why not foo?' questions when it comes to the darcs source :)
19:40:05 <lispy> it used perl at one point
19:40:15 <rasfar> maybe i'll genuinely penetrate the source this time; not the first time i obtained it...
19:40:18 <lispy> I can't even remember why the perl was converted to bash
19:41:42 <lispy> rasfar: You might find this a handy read: http://blog.codersbase.com/2009/03/type-correct-changes-safe-approach-to.html there are links to pdf of my thesis and slides
19:42:22 <elliott> <wavewave> hmm I didn't know readFile still leave a file open even if it finished.
19:42:25 <elliott> wavewave: it closes once you force the []
19:42:29 <elliott> welcome to lazy IO
19:42:53 <lispy> readFile doesn't have to be this way.  It's this way because of an unsafePerformIO buried inside the definition in the prelude
19:42:58 <rasfar> lispy: yes i would, how did you guess.  exactly my present interest.
19:43:23 <lispy> rasfar: psychic :)
19:43:26 <rasfar> it's *your* thesis, geeze!
19:43:38 <rasfar> we shall talk.....
19:43:42 <lispy> heh
19:43:50 <lispy> I should probably reread it then to know what it says ;)
19:43:59 <rasfar> hee
19:45:07 <elliott> lispy: *unsafeInterleaveIO
19:45:35 <lispy> elliott: how do you define unsafeInterleaveIO?
19:46:38 <lispy> Okay, so ghc doesn't define it interms of unsafePerformIO, but I think you can use unsafePermforIO to define unsafeInterleaveIO
19:46:48 <elliott> you can use unsafePerformIO to define return too
19:46:53 <elliott> unsafeInterleaveIO is considerably more benign
19:47:00 <elliott> (not benign, but more benign)
19:48:00 <lispy> unsafeInterleaveIO io = return $ unsafePerformIO a -- I think this works
19:48:22 <lispy> er, a should be io
19:49:39 <otters> so I can't find the bit in the lambdabot documentation where it explains online.rc
19:49:48 <otters> ahh
19:49:51 <otters> there is an example
19:49:53 <elliott> lispy: yes, it does, but so?
19:50:10 <otters> elliott why aren't you a lambdabot admin
19:50:20 <elliott> lispy: you can define perfectly safe things with unsafePerformIO too, but more importantly, you can't define unsafePerformIO with unsafeInterleaveIO
19:50:29 <elliott> otters: good question! Cale: Why aren't I a lambdabot admin?
19:50:35 * elliott doesn't actually want to be a lambdabot admin.
19:50:43 <otters> I'll be an admin if elliott doesn't want it
19:50:51 <otters> the easiest way to learn is with unlimited power
19:51:20 <elliott> quite
19:51:58 <rasfar> (lispy: actually we're looking at different problems but your thesis will help for sure, thank you)
19:53:18 <lispy> rasfar: this document is now old, but it should help you understand how 'record' is implemented: http://wiki.darcs.net/Internals/Record
19:55:10 <rasfar> super.  i've been through the Internals docs before, and skimmed some papers, but my project keeps getting sidelined.
19:55:33 <lispy> rasfar: what is your project?
19:55:45 * lispy wonders if we should move to #darcs
19:56:08 <rasfar> sure, let's go to #darcs for this...
19:58:04 * hackagebot ghc-mod 1.10.3 - Happy Haskell programming on Emacs  http://hackage.haskell.org/package/ghc-mod-1.10.3 (KazuYamamoto)
19:59:08 <otters> uh oh
19:59:15 <otters> lambdabot "Could not find module `ShowIO'"
19:59:24 <otters> google is not helping me very much
19:59:39 <lambdabot> Maybe I'm just being contrary today.
20:00:19 <mzero> otters - I've never heard of that module, either
20:00:19 <albel727> 0_0
20:00:24 <otters> me neither
20:00:39 <mzero> what is generating it?
20:00:46 <mzero> er, generating that error
20:00:48 <otters> any eval statement
20:00:55 <otters> for example, > 1
20:01:08 <Pseudonym> > 1
20:01:08 <mzero> > 1
20:01:09 <lambdabot>   1
20:01:09 <lambdabot>   1
20:01:14 <otters> well, not this one
20:01:21 <otters> I'm trying to run one myself
20:01:26 <otters> installed it from cabal
20:01:38 <otters> and it's breaking a bit
20:01:42 <mzero> ah
20:02:18 <otters> a la https://gist.github.com/1813830
20:04:55 <otters> then there's this even more intriguing error https://gist.github.com/1813837
20:05:00 <Guest36865> does anybody have 7.4.1 running?
20:05:04 <lispy> Guest36865: yes
20:05:15 <lispy> Guest36865: Several of us :)
20:05:18 <Guest36865> i'm seeing some weird behavior, can you run a couple of expressions for me?
20:05:27 <lispy> okay
20:05:36 <Guest36865> :m + Data.Bits Data.Int
20:05:49 <Guest36865> (5 :: Int8) `shiftL` (-1)
20:05:52 <Guest36865> I get 0 for this
20:05:55 <Guest36865> which is bogus
20:06:29 <mauke> Guest36865: no, -1 is bogus
20:06:37 <Enigmagic> shouldn't you use shift instead of shiftL /
20:07:02 <Guest36865> do you get 0 as well?
20:07:24 <mzero> "Shift the argument left by the specified number of bits (which must be non-negative)."
20:07:53 <lispy> hmm, 6.10.1 returns 2
20:07:57 <Guest36865> with ghc 7.0.4 I get 2
20:08:05 <Enigmagic> sounds like undefined behavior giving you undefined results
20:08:15 <td123> Guest36865: I also get 0
20:08:17 <Guest36865> yeah, I thought they all managed negatives correctly by doing the right thing
20:08:31 <td123> Guest36865: on ghc 7.4.1
20:08:35 <mauke> Guest36865: what "right thing"?
20:08:38 <Enigmagic> if you have postive or negative values, use shift. that's what it's for
20:09:12 <Guest36865> regardless, it's a behavioral change in ghc
20:09:19 <Guest36865> just wanted to confirm
20:09:32 <Enigmagic> undefined behavior is undefined
20:09:47 <Enigmagic> it could change for compiled vs interpreted too
20:09:54 <Enigmagic> or the version of gcc or llvm you're using
20:11:10 <mzero> it's probably dependent also on what processor you're running on -
20:11:32 <mzero> not all CPU architectures implement shifts for "non-simple" values the same way
20:12:08 <mzero> hence, shift is normalized, and shiftL and shiftR are only defined to work for a subset of inputs
20:12:41 <Guest36865> sure, I've no problem with undefined
20:12:47 <Guest36865> just behavioral change in ghc was surprising
20:13:11 <Guest36865> i wonder what it could break (i.e., if there was any code that relied on this)
20:17:10 <hpaste> Mike___ pasted ‚Äúaa‚Äù at http://hpaste.org/63599
20:17:29 <Mike___> now I am sure that I'm outputting data in the corect format
20:17:34 <Mike___> but can't write to file >_<
20:17:53 <Mike___> *** Exception: Prelude.read: no parse
20:17:59 <Mike___> would someone help me with this bit?
20:18:45 <SmartViking> I'm new to Haskell, is this a silly way to write the fibonnacci sequence:
20:18:47 <SmartViking> fib 0 x y = x
20:18:49 <SmartViking> fib n x y = fib (n-1) y (x+y)
20:18:53 <mzero> first off - you can use multi-line string literals
20:19:05 <Cale> elliott: lol, most of the people in lambdabot's admin list don't seem to exist anymore
20:20:36 <elliott> Cale: I'll stop existing then :D
20:20:42 <Cale> elliott: you should have admin privileges now...
20:20:47 <mzero> Mike___:  the problem isn't reading a file - it is that the file must have a parse error
20:20:59 <mzero> read isn't really the right tool for the job here
20:21:00 <elliott> Cale: wat
20:21:05 <elliott> ok :P
20:21:14 <elliott> i wasn't being serious but ok, haha
20:21:17 <Cale> Well, you asked for them
20:21:21 <Saizan> SmartViking: not so much, though accumulators like x and y don't work so well in a lazy language
20:21:27 <Cale> and you seem to be around a lot
20:21:28 <mzero> unless you are willing to require the the file be in exactly the format of a list of tuples
20:21:38 <elliott> fair enough
20:21:47 <elliott> i'll only misuse them on saturdays
20:21:52 <elliott> :P
20:22:13 <Saizan> SmartViking: replacing the second line with "fib n x y = fib (n-1) y $! x + y" would be better
20:22:52 <Saizan> > let fibs = 0 : 1 : zipWith (+) fibs (tail fibs) in fibs -- more idiomatic
20:22:53 <lambdabot>   [0,1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765,10946...
20:22:58 <Mike___> mzero: well, I do want to write it exactly as a list of tupples, and read it back as a list of tupples
20:23:17 <mzero> okay - are you certain the file is correctly formatted?
20:23:38 <Mike___> well, I used putStr just before writting the content to check for that
20:23:40 <mzero> using read will cause it to fail with no indication of where
20:23:53 <Mike___> [("mike",63)
20:23:58 <Mike___> this is what it's writting
20:24:07 <Mike___> type Nome = String type Pontos = Int type Jogador = (Nome,Pontos) type Tabela = [Jogador]
20:24:07 <mzero> and it's wrong! no closing brace
20:24:18 <Mike___> why not? it should have one
20:24:35 <mzero> no - what you pasted didn't have one
20:24:38 <Mike___> it comes back from a function as a list of tupples of the type tabela
20:24:41 <SmartViking> Saizan: Ok, thanks.
20:24:57 <mzero> so either you mispasted, or the file is missing the closing square bracket
20:25:00 <Mike___> something is stealling a brace
20:25:02 <Mike___> >_<
20:25:19 <Mike___> i did try this before
20:25:48 <Mike___> writeTabela t = writeFile "tabela.txt" ((show t)++"]")
20:25:52 <Mike___> cause i did notice the brace
20:25:56 <Mike___> but, it's the same..
20:26:10 <Mike___> but i thought that the error overlapped the brace on the output
20:26:37 <Mike___> dont know if that is the best way to do it... might no tbe
20:27:16 <mzero> well - not reading Portugese (I'm guessing) it is a bit hard to read the code --- but I'm a little surprised how much of it is in IO
20:27:40 <Mike___> im guessing thats bad practice
20:27:48 <Mike___> im new to haskell.. thats why :s
20:27:51 <mzero> yes -
20:28:02 <mzero> I'm guessing this is a Rubic's cube?
20:28:06 <Mike___> yup
20:28:10 <Mike___> and it's working
20:28:13 <Mike___> except for the score
20:28:23 <Mike___> which should be being written into file at the end
20:28:45 <Mike___> insereOrdenado :: Tabela -> Jogador -> Tabela insereOrdenado t (n,p) = (n,p):t
20:28:54 <Mike___> thats what outputs the file format of the tupple
20:28:58 <Mike___> before being written
20:29:13 <Mike___> is it wrong?
20:29:34 <Mike___> list of tupples*
20:30:55 <mzero> looking at your writeTabela and readTabela routines - they look fine, actually
20:31:10 <mzero> I'm a little surprised that this could happen
20:31:13 <Mike___> what about insereOrdenado
20:31:24 <mzero> that shouldn't matter, right, it is pure, no?
20:31:26 <Mike___> is that the correct way to out put the list of tupples ?
20:31:44 <Mike___> well, everything outputs fine
20:31:50 <Mike___> i play the game fine
20:31:54 <Mike___> it crashes wjen trying to write
20:32:07 <mzero> Mike___: sure - that is fine
20:32:19 <mzero> oh - that is a different story
20:32:58 <Mike___> [("mike",147)*** Exception: Prelude.read: no parse
20:33:00 <Mike___> as you can see
20:33:04 * hackagebot extensible-data 0.1.0.2 - Sums/products/lists/trees which can be extended in other modules  http://hackage.haskell.org/package/extensible-data-0.1.0.2 (AaronBlack)
20:33:07 <Mike___> before the ***
20:33:19 <Mike___> is the putstr of the items going into the file
20:33:32 <Mike___> and the *** is the exception itself
20:33:57 <mzero> AH
20:33:58 <mzero> got it
20:34:02 <Mike___> oh god
20:34:06 <Mike___> please tell me you got it
20:34:09 <mzero> you start the game with an empty score file
20:34:13 <Mike___> yes
20:34:17 <mzero> HAH
20:34:25 <mzero> okay - brace yourself
20:34:29 <Mike___> omg O_O
20:34:32 <mzero> when your program starts
20:34:37 <mzero> it calls readTabela
20:34:41 <Mike___> yes
20:34:56 <mzero> which ends with     return (read t)
20:35:06 <Mike___> so.. i guessing that fails
20:35:16 <Mike___> and i end up with an empty table
20:35:19 <mzero> notice that at that very instance, the read isn't applied to the t, which a the start is the empty string
20:35:26 <mzero> no
20:35:55 <Mike___> so, how can I go around that issue?
20:35:58 <mzero> all that was returned there, at the end of readTabela, was the "promise" to   read t   should the table ever be needed
20:36:01 <mzero> a "thunk"
20:36:07 <mzero> turns out
20:36:20 <mzero> you don't ever demand (use) the table anywhere --- until you write it out
20:36:25 <lispy> add back the seq and use reads
20:36:32 <elliott> Mike___: the file should start out as []
20:36:35 <mzero> even prepending an item on the front doesn't need it!
20:36:35 <elliott> not empty
20:36:51 <Mike___> oh ok
20:36:56 <elliott> because "" isn;t valid read syntax for a list
20:37:06 <mzero> so it fails after writing the front entry, and while trying to write the rest of the table, finally demands the read t to happen...
20:37:06 <elliott> thus the error
20:37:08 <lispy> > reads [] :: [(Int, String)]
20:37:09 <Mike___> and im going to read about how to check if the file exists, and if it doesn't, ill create it with [] inside of it
20:37:09 <lambdabot>   []
20:37:25 <mzero> and BOOM on reading while you're writing
20:37:27 <Mike___> that would be correct right?
20:37:30 <lispy> > reads "" :: [(Int, String)]
20:37:31 <lambdabot>   []
20:37:32 <mzero> good- don't try to fix this with seq
20:37:38 <mzero> that would be the wrong way
20:37:56 <elliott> Mike___: just create the file and catch the already exists exception
20:38:01 <mzero> you might be better off using reads instead of read -- which will let you process the error
20:38:05 <lispy> Well, actually pulling the data out when the readFile happens is not wrong.
20:38:09 <elliott> its safer than checking separately
20:38:12 <Saizan> i'd go with reads myself, so that if someone edits the file it won't get screwed
20:38:49 <Mike___> ok
20:38:59 <Mike___> so, i can read about reads in LYAH ?
20:39:09 <Mike___> and see how it works
20:40:04 <mzero> do you know where the library docs are -- on your machine or on-line?
20:40:12 <mzero> (not sure LYAH has reads in it)
20:40:39 <mzero> (and what OS are you on)
20:40:53 <Mike___> windows
20:41:10 <Mike___> what about if
20:41:14 <mzero> if you have Haskell Platform installed, you should have all the docs -- but I don't know where they put them on that platform
20:41:19 <mzero> on line you can start here:  http://lambda.haskell.org/platform/doc/current/frames.html
20:41:29 <Mike___> when I run the application for the first time, I chek if the file exists, if it doesnt, I can create a new one with [] inside of it
20:41:34 <Mike___> does this seem ok?
20:41:43 <Saizan> Mike___: reads returns a list of pairs whose first element is the parsed value and second element is the rest of the string
20:41:51 <elliott> <elliott> Mike___: just create the file and catch the already exists exception
20:41:58 <Saizan> Mike___: if the parse fails it'll return an empty list
20:42:00 <elliott> <elliott> its safer than checking separately
20:42:03 <lispy> Mike___: reads is described in LYAH here at the bottom in an "Excuse me" box: http://learnyouahaskell.com/input-and-output
20:42:05 <cmccann> bah, I guess I still can't write the ackermann function using only type synonyms.
20:42:22 <mzero> well, sure - that'll work - if anyone hand edits the file, it may go BOOM again --- but then again - what would you do - just report that the file is borked and quit on start up?
20:42:23 <cmccann> I think I'd need rank-N polykinds :[
20:43:04 * hackagebot wai-logger 0.1.3 - A logging system for WAI  http://hackage.haskell.org/package/wai-logger-0.1.3 (KazuYamamoto)
20:43:06 * hackagebot wai-logger-prefork 0.1.3 - A logging system for preforked WAI apps  http://hackage.haskell.org/package/wai-logger-prefork-0.1.3 (KazuYamamoto)
20:57:46 <ben_> hi guys, could any arch users point me to any resources on getting ghc/haskell-platform upgraded to the latest version?
20:59:04 <zzo38> How can turn off layout in pragmas?
20:59:44 <elliott> you can't
21:01:17 <zzo38> Can they implement turn it off?
21:02:18 <Guest36865> does anyone remember which CPP name GHC defined for it's version info?
21:02:23 <elliott> sure. will they? unlikely
21:02:25 <Guest36865> __GHC_VERSION__?
21:02:28 <elliott> Guest36865: __GLASGOW_HASKELL__
21:02:34 <Guest36865> ah thanks
21:02:45 <otters> hey guys
21:02:53 <otters> if I'm using the Reader monad
21:02:56 <zzo38> Is there a way to access C preprocessor symbols in custom -pgmF preprocessors?
21:03:31 <Bob___> Hi there!
21:03:38 <otters> and I want to call another Reader typed function from one Reader typed function
21:03:42 <zzo38> otters: The Reader monad is like (->) so you can use that, unless you need a transformer in which case you can use ReaderT.
21:03:47 <otters> oh
21:03:58 <otters> no, I mean
21:04:07 <zzo38> Can you give an example of what you mean?
21:04:30 <otters> well if I want to have two separate functions that access the environment and I want to call one from the other
21:04:37 <otters> hang on
21:04:44 <otters> I'll make an example
21:06:09 <zzo38> Unless you need a transformer, I suggest using (->) as the type for the monad; it makes many things simpler
21:07:19 * rasfar misses home internet, gotta leave the cafe... bye
21:08:07 <zzo38> But show me an example because I fail to understand what you mean.
21:09:01 <otters> zzo38: I think what I'm trying to do is compose readers
21:09:09 <otters> but this is redundant: https://gist.github.com/1814177
21:09:17 <otters> I think
21:09:37 <otters> err, wait.
21:09:39 <otters> ignore that one
21:09:42 <otters> that's a terrible example
21:10:06 <otters> Yeah I think I actually don't know what I'm trying to do
21:10:23 <zzo38> I suggest not even using Reader
21:10:30 <zzo38> Since (->) is an equivalent monad
21:10:33 <otters> well
21:10:44 <otters> that was a highly simplified example
21:10:58 <otters> the actual context I'm using it in is a good fit for Reader
21:11:15 <zzo38> readTest = showTest . length; showTest = show; main = print (readTest "foo");
21:11:24 <otters> yeah
21:12:27 <zzo38> (It works with do-notation as well; simply replace both "ask" and "runReader" with "id")
21:13:03 <zzo38> (I just don't like do-notation and don't use do-notation myself)
21:13:05 * hackagebot wai-app-file-cgi 0.5.2 - File/CGI/Rev Proxy App of WAI  http://hackage.haskell.org/package/wai-app-file-cgi-0.5.2 (KazuYamamoto)
21:13:08 <otters> ohhh, wait
21:13:23 <otters> I just solved it :<
21:13:28 <otters> my problem
21:13:54 <zzo38> With (->) monad is simple:  fmap = (.); return = const; join f x = f x x;
21:13:59 <zzo38> otters: Good.
21:14:55 <otters> basically if I have two functions that are supposed to take the same environment and do different things with it
21:15:38 <zzo38> otters: Use liftA2
21:15:52 <otters> foo = do { someResult <- bar; ... }
21:15:56 <otters> where bar is of the same type
21:16:40 <zzo38> Yes that will do it, whether Reader or (->)
21:16:49 <otters> I really should've just tried that first
21:17:24 <zzo38> Yes
21:18:07 * hackagebot mighttpd2 2.5.2 - A classical web server on WAI/warp  http://hackage.haskell.org/package/mighttpd2-2.5.2 (KazuYamamoto)
21:18:57 <zzo38> But I really suggest, unless you are using ReaderT to transform another monad, just use (->) as the monad. It is a monad, and you can use do-notation with it if you want to (but I wouldn't recommend using do-notation for everything)
21:19:10 <Axman6> anyone know of a nice package that can give you 'fuzzy' dates, from something like a UTCTime? say you give it the current time and the time you're after, and it can turn it into 'Today","Tomorrow", "Next Tuesday" etc?
21:19:14 <otters> Hmmm
21:21:19 <zzo38> Axman6: Write one if there is no such thing.
21:21:35 <Axman6> zzo38: yeah, considering doing just that.
21:24:36 <otters> hmm
21:25:28 <otters> so if I have this right
21:26:34 <otters> f x = (do { f1 <- foo; f2 <- bar; return (f1,f2) }) x
21:27:10 <otters> is equivalent to f x = let f1 = foo x; f2 = bar x in (f1, f2)
21:27:36 <SubtleArray> Hello peoples. If anyone is there. Is it possible to pattern match 3 indexes at once? For example: findMatch ("a":"b":"c") = "perfect match"
21:27:47 <otters> except pointfree is a bit easier with do-notation
21:27:54 <Axman6> SubtleArray: indexes? what?
21:27:56 <SubtleArray> That's not working, but it would be wonderful if it did. Lol
21:27:59 <zzo38> Yes that is the case. You could omit the x in your first one, and in the second one you can also do   liftA2 (,) foo bar
21:28:05 <otters> Right
21:28:11 <Axman6> do you mean, f ("a":"b":"c":[])?
21:28:15 <otters> but I just mean theory
21:28:26 <Axman6> SubtleArray: what exactly are you trying to match?
21:28:28 <SubtleArray> Axman6: Apologies. I'm always using the wrong words.
21:28:37 <zzo38> Or, if there is the liftPair function, which is not standard but I think it should be a method of Applicative, use:  liftPair (foo, bar)
21:29:06 <SubtleArray> Axman6: One second. Trying to find a good way to explain this.
21:29:29 <Axman6> SubtleArray: are you trying to match the exact list ["a","b","c"]?
21:29:48 <zzo38> Are you sure it is a bit easier with do-notation? Do it that way if you want to, but to me it isn't
21:29:50 <SubtleArray> Axman6: Yes.
21:30:06 <Axman6> then, you can just use f ["a","b","c"]
21:30:11 <Axman6> that is a pattern
21:30:22 <otters> oooh, -> is a monad
21:30:37 <ion> No, ‚Äú(->) r‚Äù is one.
21:30:41 <otters> okay
21:30:44 <otters> -> r is a monad
21:30:44 <otters> sorry
21:30:49 <nyingen> Axman6: is it the case that any combination of constructors is a valid pattern?
21:31:02 <nyingen> leaving aside n+k patterns
21:31:05 <ion> No, ‚Äú(->) r‚Äù is one. :-P
21:31:07 <Axman6> maybe?
21:31:23 <Axman6> i can't think of any that aren't, unless they're type errors...
21:31:29 <otters> okay well I guess pedantry is part of being a good programmer
21:31:31 <nyingen> Axman6: I was going to boldly state that, but then I second-guessed myself
21:31:33 <ion> ‚Äú-> r‚Äù looks more like ‚Äú(-> r)‚Äù which is completely different.
21:31:54 <nyingen> Axman6: I'm pretty sure it's true
21:31:54 <otters> how is (-> r) different from (->) r?
21:31:59 <ion> ‚Äú(->) r‚Äù would be ‚Äú(r ->)‚Äù using the section syntax.
21:32:01 <SubtleArray> Axman6: I'm getting an error. Couldn't match expected type `[Char]' with actual type `Char'
21:32:05 <zzo38> ion: Yes
21:32:17 <Axman6> :t ["a","b","c"]
21:32:18 <lambdabot> [[Char]]
21:32:21 <Axman6> "t "abc"
21:32:24 <Axman6> :t "abc"
21:32:25 <lambdabot> [Char]
21:32:44 <SubtleArray> It works when I do this ["a":"b":_], but gets upset when I try to do a complete match.
21:32:47 <ion> Like ‚Äú(/) 5‚Äù is the same as ‚Äú(5 /)‚Äù.
21:32:50 <zzo38> The definition of (->) monad:   fmap = (.); return = const; join f x = f x x;   Even on paper this can be worked out and it is seen that the types are correct.
21:32:52 <Axman6> SubtleArray: did you actually mean you wanted to match "abc"?
21:33:15 <Axman6> because "a" is a string by itself, short for 'a':[]
21:33:32 <SubtleArray> Axman6: No, there are 3 different elements / indexes / parts of a list I want to match.
21:33:41 <zzo38> (I have figured it out myself on paper; actually I do more Haskell programming on paper than other programming languages)
21:33:55 <Axman6> SubtleArray: i really have no idea what you want, you're going to have to be more clear
21:34:02 <nyingen> > let f ["a", "b", "c"] = True in f ["a", "b", "c"]
21:34:03 <lambdabot>   True
21:34:04 <SubtleArray> Axman6: Right. There are infact words I want to match.
21:34:04 <ion> @@ @djinn @type fmap `asTypeIn` \fmap -> fmap undefined (undefined :: a -> b)
21:34:05 <lambdabot>  f a b c = a (b c)
21:34:11 <chairdog> SubtleArray: are you trying to match (a:b:c) not [a:b:c] ?
21:34:21 <Axman6> give examples of exact inputs you expect to succeed with this match
21:34:43 <ion> @@ @djinn @type join `asTypeIn` \join -> (join undefined :: a -> b)
21:34:45 <lambdabot>  Error: Undefined type Inferred
21:34:45 <lambdabot>  Cannot parse command
21:34:45 <lambdabot>  Cannot parse command
21:34:46 <SubtleArray> chairdog: I'm doing natural language processing. When certain combinations of words are sent to this function, I want it to start other functions.
21:35:01 <mandaya> Anyone know how I can convert a CInt to an Int? For some reason I can't find the documentation... could have sworn it was easy
21:35:12 <ion> mandaya: fromIntegral
21:35:21 <mandaya> thanks
21:35:23 <chairdog> > let (x:y:_) = ['a', 'b', 'c', 'd'] in x
21:35:24 <lambdabot>   'a'
21:35:29 <chairdog> SubtleArray: like that?
21:35:36 <cmccann> ion, btw sorry I didn't get to fixing the Overture stuff this weekend after all
21:35:46 <cmccann> the hackage2 shenanigans distracted me
21:36:06 <ion> cmccann: Oh, nothing to apologize for. I‚Äôm in no hurry. :-)
21:36:14 <JoeyA> atomicModifyIORef is not interruptible inside of an exception mask, correct?
21:36:26 <ion> And time spent on Hackage 2 is well spent.
21:36:36 <nyingen> there's a Hackage 2?
21:36:49 <SubtleArray> chairdog: Not quite.
21:37:21 <ion> Hm, perhaps Hoogle can figure this out based on the type.
21:37:23 <cmccann> yeah, I'm looking into getting the build stuff working as well on my demo site
21:37:23 <ion> @hoogle CInt -> Int
21:37:23 <SubtleArray> Still trying to find a way to explain this... It's so damn complicated.
21:37:24 <lambdabot> Foreign.Storable alignment :: Storable a => a -> Int
21:37:24 <lambdabot> Foreign.Storable sizeOf :: Storable a => a -> Int
21:37:24 <lambdabot> Prelude fromEnum :: Enum a => a -> Int
21:37:24 <chairdog> SubtleArray: can you paste an example that doesn't work?
21:37:32 <ion> Oh, it can‚Äôt.
21:37:34 <cmccann> nyingen, sort of
21:37:45 <chairdog> SubtleArray: what input do you have (in Haskell)?
21:38:17 <mandaya> ion: yea, I tried before I asked :)
21:38:48 <otters> is getDataFileName all that Paths_* exports?
21:39:14 <nyingen> hackage is a great resource, but it's becoming a bit unwieldy
21:39:17 <nyingen> I'm really eager to see what's next
21:39:22 <ion> It should have some kind of a heuristic for what the user might be looking for. Perhaps mine all the code in Hackage for a database of how much each function, type etc. is being used by people.
21:39:28 <SubtleArray> chairdog: I'll start from the top. The program takes user input and splits it into a list of words. I need a pattern match function that can launch functions based on certain patterns that are found.
21:39:30 <cmccann> nyingen, http://hackage2.uptoisomorphism.net:8080/
21:39:49 <cmccann> that's a copy of the current hackage2 code that I grabbed from the repo and put on a server
21:39:50 <ion> fromIntegral is probably being used more than Storable.alignment for instance.
21:40:18 <nyingen> cmccann: looks promising
21:40:37 <mandaya> and given the issue I just bumped into, type reduction on the search would be awesome :P
21:40:37 <zzo38> Will I require an account for Hackage2 or can I use the same one I already have?
21:40:43 <SubtleArray> chairdog: For example: If the user input is ["load", "file"], I need a function like this - function ["load":"file"] = loadFile
21:40:49 <cmccann> zzo38, beats me
21:41:05 <nyingen> SubtleArray: oh, you're processing commands?
21:41:08 <cmccann> I'm not sure if there was ever a migration plan fully decided
21:41:27 <SubtleArray> nyingen: Yes, from naturally typed sentences.
21:41:51 <Axman6> so you mean ["load","file"]
21:41:58 <zzo38> Does Hackage2 support priority builds? So that, for example, new packages have priority for generating their documentation, and if there is an older version of a package not built yet when the new one has also not been built yet, the new one has priority, and so on
21:42:11 <cmccann> no idea
21:42:14 <SubtleArray> Axman6: Yes.
21:42:19 <chairdog>  case ["hi", "there"] of { "hi":_ -> "dofoo" ; "bye":"now":_ -> "dobye"; ; _ -> "what???" }
21:42:22 <chairdog> oops
21:42:23 <chairdog> > case ["hi", "there"] of { "hi":_ -> "dofoo" ; "bye":"now":_ -> "dobye"; ; _ -> "what???" }
21:42:24 <lambdabot>   "dofoo"
21:42:42 <chairdog> > case ["monkeys", "are", "here"] of { "hi":_ -> "dofoo" ; "bye":"now":_ -> "dobye"; ; _ -> "what???" }
21:42:43 <lambdabot>   "what???"
21:43:02 <augur> chairdog: what are you doing
21:43:06 * hackagebot copilot-libraries 0.3 - A Haskell-embedded DSL for monitoring hard real-time  distributed systems.  http://hackage.haskell.org/package/copilot-libraries-0.3 (LeePike)
21:43:13 <chairdog> augur: thats what SubtleArray is trying to do
21:43:20 <chairdog> patterns to match string lists
21:43:24 <dibblego> can I tell cabal-install to use a non-hackage server on the fly? perhaps by specifying a different config file?
21:43:34 <nyingen> I think we're supposed to tell him to switch to Agda at this point
21:43:36 <chairdog> SubtleArray: you can match lists like that
21:43:49 <cmccann> dibblego, you can set that in the config file
21:43:52 <cmccann> I know that much
21:44:06 <dibblego> cmccann: yes I can achieve that, but I was hoping to do it on the fly
21:44:12 <SubtleArray> chairdog: I see... So a case expression will do the trick?
21:44:38 <cmccann> dibblego, well, there are packages that muck with your cabal config to fake separate build environments
21:44:48 <cmccann> you can probably twist one of those to your purposes
21:44:52 <cmccann> but that's only sort of on the fly
21:44:53 <chairdog> SubtleArray: well you don't need to use a case expression - you can do it as  myfunc "hi":_ = ...   too, I think, but I don't know how to put that into lambdabot to show it here
21:45:01 <dibblego> cmccann: what packages do that?
21:45:02 <cmccann> more like on the slow glide
21:45:19 <cmccann> virthualenv is the only one I can think of off the top of my head
21:45:26 <dibblego> ok ta
21:45:31 <nyingen> chairdog: he could also use some kind of map, or write a grammar in Parsec or happy or whatever
21:45:39 <elliott> chairdog: no
21:45:42 <elliott> myfunc ("hi":_) = ...
21:45:43 <nyingen> it's unclear what would be best, since we don't know what he's really trying to do
21:46:15 <chairdog> nyingen: yeah
21:46:21 <nyingen> SubtleArray: if you're trying to process some kind of command language, for which you can define a grammar, have a look at Parsec
21:46:32 <chairdog> yeah parsec is nice
21:46:34 <zzo38> I would like to make Cabal support prefix config, where you can specify multiple servers each with a package name prefix. The prefixes could be separated from the package name by . or + or something; preferably some characer not used in package names
21:46:36 <wavewave> cmccann: I drew some figure with my program. see http://ianwookim.org/hxournal/gallery.html
21:46:45 <chairdog> thats one of my main uses of haskell for quick hacky things
21:46:54 <nyingen> Parsec is pretty easy to get up and running with, I use it all the time
21:47:06 <SubtleArray> Parsec and case. Looking them up now.
21:47:07 <cmccann> dibblego, why do you need to use a non-hackage server, anyway? :]
21:47:30 <dibblego> cmccann: we have an internal server and I don't like the way we have distribution set up
21:47:39 <cmccann> wavewave, nice!
21:47:58 <mzero> wavewave: +1
21:48:00 <wavewave> heavy test..
21:48:06 * hackagebot rezoom 0.0.4 - Github resume generator  http://hackage.haskell.org/package/rezoom-0.0.4 (JoelTaylor)
21:48:06 <cmccann> dibblego, well, let me know if you get something working nicely
21:48:17 <cmccann> because I'm currently mucking with the hackage2 codebase
21:48:20 <zzo38> I want to use Hackage and non-Hackage servers together
21:48:22 <chairdog> SubtleArray: i think your specific error that you were hitting was because you were trying to match ["hi":_] rather than ("hi":_) without the [].
21:48:42 <dibblego> cmccann: I just have a bunch of scripts and users can put our server in ~/.cabal/config but I don't like that set up
21:48:49 <chairdog> SubtleArray:  not that that helps your higher level how-to-implement deciscion
21:48:51 <SubtleArray> Thanks for the help, folks. I really appreciate it. I don't think I would have made it this far without this IRC. :D
21:49:55 <nyingen> SubtleArray: Parsec lets you write things like "look for string 'load', then a filename consisting of valid characters. If found, call function (loadFile fileName), else return 'error: invalid command'"
21:50:07 <nyingen> sounds like what you might be looking for
21:50:14 <cmccann> dibblego, yeah that sounds less than ideal :T
21:50:32 <dibblego> cmccann: I'm not sure how hackage2 works
21:51:00 <cmccann> dibblego, well, the main thing it does is sit in a darcs repo and collect dust
21:51:08 <cmccann> I'm still figuring out what else :P
21:51:20 <dibblego> cmccann: does it help with distributing proprietary haskell packages?
21:51:23 <dibblego> ok
21:51:36 <cmccann> it's pretty easy to set up and run I can tell you that much
21:52:53 <cmccann> dibblego, I dropped it on github since that's more convenient for many people: https://github.com/isomorphism/hackage2
21:53:03 <dibblego> ok ta
21:53:13 <cmccann> I have no idea whether it helps you at all though!
21:53:48 <wavewave> cmccann , mzero : thnx. ;-)
21:53:49 <dibblego> I just don't want to deal with the whinging of distribution when I tell them to use a haskell package
21:54:01 <dibblego> I will spend days writing code to avoid it
21:54:08 <zzo38> I also like Parsec and used it a lot. But monadic stuff is rarely ever useful with Parsec
21:55:45 <zzo38> Boney: What request? Asking to do what?
21:56:06 <Boney> zzo38: look in #ghc.
21:58:06 * hackagebot copilot 2.0.8 - A stream DSL for writing embedded C programs.  http://hackage.haskell.org/package/copilot-2.0.8 (LeePike)
22:11:53 <SubtleArray> chairdog: If you're still there, I got it to work with a case expression. Parsec looked really good, but the documentation was too long. >_<
22:13:20 <nyingen> SubtleArray: It is long, but I'd encourage you to persevere. It's extremely useful for this sort of thing :)
22:14:13 <nyingen> Though frankly I found the parsec tutorial to be of limited use. I just had to try stuff and see how it worked. Soon, I was implementing a Logo interpreter
22:14:50 <SubtleArray> nyingen: I will. :D After I finish this app, I'm going to take a break just to study syntax and modules. Thing is, I just spent a month studying Haskell syntax, and I'm itching to get something done already.
22:15:05 <nyingen> Understandable
22:17:14 <SubtleArray> nyigen: On my research list I have map, fold, parsec, and case. I need to know all those better for the kind of work I enjoy doing, I think.
22:17:32 <nyingen> SubtleArray: Once I learned how to use Parsec, I liked it so much I tried to find things like it in other languages, only to discover that it's not really possible without some of Haskell's special features (lazy evaluation in particular)
22:18:12 <nyingen> It's a very elegant solution to the whole "I need to parse commands into functions" problem
22:18:17 <SubtleArray> nyigen: I noticed in irssi my name highlights when you address me. Does the same thing happen when I type your name, or is there a command for that?
22:18:25 <nyingen> it's an irssi feature
22:18:34 <nyingen> or at least, it's part of the default config
22:20:28 <SubtleArray> nyigen: Trying to find good tutorials has been tough. The Learn You a Haskell is nice, but it spends SO much time on syntax. I might give Real World Haskell a try after I finish the c9 functional programming videos.
22:21:32 <elliott> LYAH doesn't spend all that much time on syntax.
22:21:49 <SubtleArray> nyingen: Parcec sounds reall nice. I'll look for something that covers it in a concise way. I have experience with programming already, with C++, Python, and some other languages. This is why I don't have much patience for long winded documentation. Lol
22:25:23 <nyingen> SubtleArray: yeah, RWH is pretty good
22:25:47 <SubtleArray> elliot: For me it seemed like it focused almost entirely on syntax. I have a hard time learning that way, with basics first. I learn best through examples, seeing code and being explained how it worked. I liked the pace of Write a Scheme in 48 Hours more.
22:26:32 <SubtleArray> being explained = having it explained
22:26:35 <SubtleArray> So tired...
22:26:43 <SubtleArray> 1:28am here in Chicago. I should go to sleep.
22:27:34 <Enigmagic> sleep is for the weak
22:27:40 <SubtleArray> Thanks again, everyone. May the monads be with you. ^_^
22:27:58 <SubtleArray> Enigmagic: I wouldn't sleep if my body didn't demand it. :D
22:28:17 <cmccann> any time someone wants example code to learn from I have to resist the urge to send them to oleg's site
22:28:28 <Enigmagic> heh
22:28:40 <Enigmagic> though actually i thought he had the best iteratee docs
22:28:47 <Enigmagic> kinda surprising
22:28:49 <cmccann> not saying much
22:28:50 <cmccann> but yeah
22:28:51 <cmccann> :P
22:28:57 <Enigmagic> :)
22:29:05 <cmccann> I always found his presentation of the idea pretty straightforward
22:29:29 <Enigmagic> i always have this feeling i should be using netwire or reactive-banana or something
22:29:46 <cmccann> I need to finish my own stream processing library at some point here
22:30:01 <cmccann> not that it's really the same thing as those
22:30:07 <wavewave> okay.. now it's hitting the limit.
22:30:38 <Enigmagic> i do a lot of graph processing and have to shoehorn stuff in
22:30:54 <Enigmagic> though today i'm fixing bugs in the llvm mangler :(
22:31:05 <cmccann> shoehorn stuff in how?
22:31:34 <Enigmagic> i don't have linear data flows
22:31:54 <Enigmagic> mostly by using ADTs and case statements
22:32:07 <Enigmagic> kinda ghetto i'd say
22:32:26 <cmccann> nonlinear as in variable ratio of inputs to outputs, or nonlinear as in merging inputs that aren't in synch?
22:32:40 <Enigmagic> yes and yes
22:32:45 <cmccann> haha
22:33:18 <cmccann> those are both things that I'm trying to give a more structured treatment of in my library
22:33:38 <Enigmagic> next thing i need is the ability to synchronize streams across machines :P
22:34:14 * cmccann has abstract-ish streams that treat inputs and outputs uniformly
22:34:21 <Enigmagic> do you have code up somewhere?
22:34:30 <cmccann> no, not yet
22:34:37 <cmccann> too much of a mess
22:34:45 <cmccann> and keep being sidetracked by other things
22:34:48 <wavewave> hxournal works pretty well as drawing program at least at this level.. see updated one. http://ianwookim.org/hxournal/gallery.html
22:34:50 <cmccann> like hackage2 at the moment
22:35:08 <Enigmagic> the project that will never ship
22:35:14 <wavewave> all lines are vectors.
22:35:26 <cmccann> what, hackage2? or my stream processors? :P
22:35:31 <Enigmagic> hackage2 it seems
22:35:47 <Enigmagic> hackage could benefit from a faster ship cycle :_)
22:35:53 <cmccann> well, http://hackage2.uptoisomorphism.net:8080/
22:36:00 <cmccann> that's the current hackage2 code
22:36:15 <cmccann> that was collecting dust in a darcs repo so I put it on a server to play with :P
22:36:21 <Enigmagic> will it fix it so google doesn't link to some random ass old version of a package?
22:36:33 <cmccann> google works in mysterious ways
22:36:45 <Enigmagic> well yeah, but will it fix it? :)
22:37:02 <cmccann> wavewave, those really do look nice :D
22:37:21 <cmccann> and I have no idea, I'm still trying to figure things out and get it set up :P
22:37:22 <wavewave> cmccann: thanks.. ;-)
22:37:57 <wavewave> I am finding a potential for this program as a drawing program. ;-D
22:38:06 * hackagebot sbv 1.0 - Symbolic bit vectors: Bit-precise verification and automatic C-code generation.  http://hackage.haskell.org/package/sbv-1.0 (LeventErkok)
22:38:15 <cmccann> so it seems!
22:38:28 <cmccann> I guess it makes sense that it'd work nicely for lightweight sketching
22:38:36 <cmccann> since that's not far from what it's made for anyway
22:39:10 <wavewave> yes. some little support for caching may do a better job.
22:39:56 <wavewave> this picture is 1.6MB without compression.
22:40:15 <wavewave> all in x y z coordinate (z is pressure)
22:40:22 <cmccann> Enigmagic, anyway, my streams support a notion of active and passive choice for interleaving streams, so you can let either the input or output drive the logic
22:40:48 <zzo38> Another idea of Haskell extension would be -XClosedTypeClasses, which allows you to define a class with instance declarations inside of the "where" of that class, and then you cannot define any more instances because it is closed. And then constraints with that type will be stronger and can imply a lot more things, and more optimizations can be done too
22:41:12 <cmccann> as well as a synchronized merging that behaves like you'd expect zipping streams would
22:42:11 <Enigmagic> cmccann: well if you get it up somewhere send me a pointer. i'm going to have to migrate some of our libraries over to conduit (due to yesod) and don't like maintaing a large mix of conduit/enumerator/(and an interal library) dependent packages
22:42:35 <cmccann> Enigmagic, sure
22:42:44 <cmccann> it's not exactly intended as a replacement for any existing libraries though
22:42:55 <Enigmagic> i'd like to get it down to conduit for our internal webpages and something better than enumerator and a crappy library we hacked together over a year
22:43:17 <cmccann> it's more low-level and abstract I guess
22:44:07 <Enigmagic> yeah i'm curious. mostly i do routing, merge sorts and some basic circuit type operations like latches
22:44:44 <Enigmagic> some sources are event driven and others are pull based
22:45:36 <cmccann> the part I'm stuck on right now is the inverse of the "zipping" merge, which... is almost the same except for what aspects are isolated after merging
22:46:10 <cmccann> it's tricky because it lets me encode functions as a pair of an input and an output value in a single stream
22:46:44 <cmccann> after which it needs to create the illusion that the two ends are separate in certain ways
22:47:23 <cmccann> but the whole thing lets me merge streams uniformly, and match inputs to outputs in whatever fashion
22:47:47 <cmccann> basically treating inputs as negative values and canceling them out
22:48:21 <cmccann> but yeah, the push/pull choice bit actually works nicely
22:48:33 <cmccann> it's only the synchronized stuff that's problematic :[
22:49:02 <Enigmagic> we had some stuff like that in dryad but i find it easier to reason with (personally) in c++ than in haskell
22:49:10 <Enigmagic> haven't been able to figure out a good system in haskell
22:49:29 <cmccann> my system is kind of convoluted internally but I think the external API is very nice
22:49:47 <Enigmagic> i care more about the interface :_)
22:49:55 <Enigmagic> thats why i work on making debugging easier
22:50:11 <Enigmagic> so only one smart person needs to debug the complicated stuff
22:50:57 <cmccann> the gist of it is that there's a set of primitives that can be combined into a type representing the shape of a single step
22:51:30 <cmccann> then you can build the behavior of the stream up using a monadic interface where you apply actions at the end of the stream
22:52:02 <cmccann> and when you're done you tell it to either halt or repeat forever and seal it off to just get a stream
22:52:14 <cmccann> and then all the merging and canceling stuff I mentioned above
22:53:06 <cmccann> so for a stream that produces an active choice between two inputs it'd have a type like (Stream (In a `With` In b))
22:53:32 <cmccann> and then using the monadic interface you'd be able to do some sort of "read from the left side" action
22:53:51 <Enigmagic> cmccann: dryad had a bunch of cool shit in it to rewrite the graph while it was executing, rollback parts that were invalid (due to the graph changing or inputs failing) and hook up to arbitrary data feeds and sinks
22:54:39 <Enigmagic> you'd code based on inputs and outputs, and attach little properties that would rewrite the graph around your code
22:54:40 <cmccann> I'm mostly sticking with a static structure, but with a lot of step-by-step flexibility
22:55:22 <Enigmagic> for what i use static structure is preferred
22:55:47 <Enigmagic> rewriting was mostly done for optimizations or implementing folds
22:57:03 <cmccann> anyway, I'll let you know when I get something usable ready
22:57:13 <Enigmagic> sweet
22:57:25 <cmccann> would you be interested in seeing just the interleaving aspect if I can get that going?
22:57:33 <Enigmagic> yep
22:59:19 <cmccann> ok, cool
22:59:25 <cmccann> I'll try to make time for that this week if possible
22:59:51 <Enigmagic> i'll be watching builds break all week porting stuff to 7.4.1. :)
23:00:01 <cmccann> heh
23:00:14 <cmccann> yeah I just had to deal with a bunch of that tonight :P
23:00:31 <Enigmagic> trying to switch to -dynamic/-shared too
23:03:53 <Mike___> I'm so proud!! :D~~~~~
23:03:54 <cmccann> anyway, I need to get some sleep
23:03:56 <Mike___> look what i did :o
23:03:56 <Mike___> insereOrdenado t (n,p) = reverse(drop (length(sortBy(compare `on` snd) ((n,p):t))-10) (reverse(sortBy(compare `on` snd) ((n,p):t))))
23:03:58 <Mike___> ^.^
23:04:03 <Mike___> My first real expression ;O
23:04:34 <cmccann> Enigmagic, got an email I should contact you at when I get the stream stuff uploaded somewhere, or should I just try to catch you on IRC?
23:05:44 <Enigmagic> i'm usually here but i'm not always paying attention
23:05:47 <Enigmagic> email is better :)
23:05:56 <cmccann> a'ight
23:05:58 <cmccann> works for me
23:06:29 <Enigmagic> cool
23:06:37 <cmccann> anyway, sleep, so seeya
23:06:46 <Enigmagic> likewise
23:06:48 <Enigmagic> later
23:07:04 <glguy> Mike___: is it necessary to sort the list before taking its length?
23:07:54 <Mike___> hmmm....
23:08:12 <Axman6> what's the -10 for?
23:08:18 <Axman6> seems pretty magic
23:08:24 <Mike___> because, it it's lenght is greater than 10
23:08:27 <Mike___> i take elements from it
23:08:42 <Axman6> ok
23:08:44 <wavewave> cmccann: see ya
23:08:50 <Mike___> i know i probably could do it with alot of less stuff
23:08:59 <Mike___> but, thats just the way i solved my problem -.-
23:09:08 <Mike___> and it looks awsome *_*
23:14:23 <mm_freak_> having 'arr' in Arrow is a common complaint, just recently a new blog post appeared on reddit‚Ä¶  IMO there is no reason to remove 'arr', but it really gives evidence that we need a third type class between Category and Arrow
23:14:55 <mm_freak_> that way you can have the interface you want without breaking existing code
23:14:57 <dibblego> removing arr is the same argument as moving return and pure, which is a good idea
23:15:06 <dibblego> s/moving/removing
23:15:59 <mm_freak_> dibblego: i wouldn't remove arr, i'd add a SideChannel class and be Arrow an extension of that adding 'arr' (and possibly (&&&))
23:16:19 <db81> Guys. I'm writing a small programmette with TagLib and it's got functions like open :: String -> IO (Maybe TagFile) and then tag :: TagFile -> IO (Maybe Tag) and so on.
23:16:20 <dibblego> yes, same as return/pure and mappend/mempty, etc.
23:16:31 <db81> What is a neat haskellish way to sequence those
23:16:32 <db81> ?
23:16:59 <dibblego> fmap, fmap+(<*>), fmap+(<*>)+(>>=), fmap+point, fmap+(<*>)+point, fmap+(<*>)+(>>=)+point
23:17:01 <ddarius> edwardk has a fairly good argument that splitting return/pure into its own class is pretty pointless.
23:17:13 <dibblego> yes I agree with that too
23:17:41 <mm_freak_> and i agree with edwardk there
23:17:52 <dibblego> I did this in Scala a while ago, for similar reasons to edwardk, then we discussed it
23:18:08 <dibblego> there are many desirable properties of the absence of return/pure/arr
23:21:33 <byorgey> db81: use MaybeT
23:22:13 <byorgey> db81: the MaybeT constructor has type   m (Maybe a) -> MaybeT m a
23:22:35 <glguy> ?hoogle MaybeT
23:22:36 <lambdabot> Data.Maybe maybeToList :: Maybe a -> [a]
23:22:36 <lambdabot> Control.Monad.Trans.Maybe MaybeT :: m (Maybe a) -> MaybeT m a
23:22:36 <byorgey> MaybeT m   is a monad so you can then sequence things normally, e.g. using >=>
23:22:36 <lambdabot> Control.Monad.Trans.Maybe newtype MaybeT m a
23:22:51 <byorgey> then use runMaybeT to project back out
23:23:06 * hackagebot ghc-mod 1.10.4 - Happy Haskell programming on Emacs  http://hackage.haskell.org/package/ghc-mod-1.10.4 (KazuYamamoto)
23:29:12 <db81> byorgey: wow, looks nice. Thanks
23:35:21 <ddarius> :t (MaybeT .)
23:35:22 <lambdabot> Not in scope: data constructor `MaybeT'
23:35:37 <ddarius> :t (Control.Monad.Trans.MaybeT .)
23:35:38 <lambdabot>     Not in scope: data constructor `Control.Monad.Trans.MaybeT'
23:35:48 <ddarius> :t (Control.Monad.Trans.Maybe.MaybeT .)
23:35:48 <lambdabot> forall (m :: * -> *) a (f :: * -> *). (Functor f) => f (m (Maybe a)) -> f (Control.Monad.Trans.Maybe.MaybeT m a)
23:53:07 * hackagebot wai-logger 0.1.4 - A logging system for WAI  http://hackage.haskell.org/package/wai-logger-0.1.4 (KazuYamamoto)
23:56:33 <Mike___> Can anyone tell me how to pause my script untill i press any key for example..
23:58:07 * hackagebot wai-app-file-cgi 0.5.3 - File/CGI/Rev Proxy App of WAI  http://hackage.haskell.org/package/wai-app-file-cgi-0.5.3 (KazuYamamoto)
23:58:09 * hackagebot mighttpd2 2.5.3 - A classical web server on WAI/warp  http://hackage.haskell.org/package/mighttpd2-2.5.3 (KazuYamamoto)
23:58:14 <donri> Mike___: getChar
23:59:42 <Mike___> thankyou
