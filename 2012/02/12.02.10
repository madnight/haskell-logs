00:07:41 <osa1> I'm getting "It is a member of the hidden package `haskell98-2.0.0.1'." error, anyone know what does that mean?
00:10:31 <osa1> I can't import System.Random, or Data.Random
00:10:40 <ivanm> osa1: which version of GHC?
00:11:04 <ivanm> osa1: but if this is using Cabal, then you probably haven't listed either haskell98 or base as one of the build-depends
00:11:15 <osa1> ivanm: latest, I downloaded it yesterday
00:12:19 <osa1> ivanm: I don't have cabal installed on my system, I just installed ghc
00:12:35 <MichaelBurge> You want the entire Haskell Platform, then
00:12:37 <MichaelBurge> not just GHC
00:14:13 <osa1> MichaelBurge: I get configure: error: The Haskell Platform version 2011.4.0.0 requires ghc-7.0.4 error when I ./configure haskell platform
00:14:28 <osa1> my ghc should be latest version since I downloaded it yesterday from haskell homepage
00:15:04 <osa1> yeah I have ghc 7.4.1
00:15:35 <MichaelBurge> Does your distribution have a package for Haskell?
00:15:58 <osa1> MichaelBurge: no, opensuse 11.4
00:16:19 <osa1> MichaelBurge: I have to downgrade my ghc, right?
00:18:19 <ivanm> System.Random should exist
00:18:19 <ivanm> and haskell98 doesn't come with GHC-7
00:18:19 <ivanm> also, ghc *comes* with Cabal
00:18:52 <osa1> ivanm: yeah somehow I don't have cabal
00:18:57 <osa1> but have ghc and ghci
00:19:01 <ivanm> you *do* have cabal
00:19:02 <ivanm> ghc-pkg list Cabal
00:19:06 <MichaelBurge> The message you got was a cabal error
00:19:14 <ivanm> what command did you do to get that error?
00:19:44 <osa1> ivanm: I loaded a file with "import Data.Random" to ghci
00:19:57 <osa1> ivanm:    Cabal-1.14.0  << output of ghc-pkg list Cabal
00:23:50 <osa1> so, do I have any options other than installing older version of ghc?
00:23:56 <osa1> and then compiling haskell platform
00:25:44 <MacMagnus> is it possible to transform a String into a function?
00:25:45 <NothingMan65> In runSTUArray, how would I "writeArray arr i e" with the contents where "e" is the contents from a call to readArray ?
00:27:12 <ivanm> osa1: it's in the random package I think
00:27:50 <osa1> ivanm: so "load Random"? I got the same error
00:27:52 <ivanm> which doesn't come with GHC by the looks of things
00:29:01 <MacMagnus> i want a function like... String -> (a -> a), is that possible?
00:30:45 <osa1> ivanm: this shouldn't be that hard. can anyone explain my how can I generate some random numbers with ghc 7.4.1 and no third party libraries?
00:30:48 <MostAwesomeDude> MacMagnus: Well, remember, -> associates to the right.
00:30:53 <ziman_> :t const id :: String -> (a -> a)
00:30:54 <lambdabot> forall a. String -> a -> a
00:31:32 <ivanm> well, you can try just using the Random module
00:32:25 <ivanm> or just get cabal-install (Use the bootstrap script to install it) and "cabal install random"
00:32:32 <osa1> ivanm: I can't improt Random module, Could not find module `Random'
00:33:59 <MacMagnus> well, what i want to do is to get String's to behave like a function that take argument(s)...
00:34:06 <osa1> "cabal is part of the Haskell Platform, so make sure you install that first" great because I can't install haskell platform with latest version of ghc
00:34:27 <Jafet1> @hackage cabal-install
00:34:27 <lambdabot> http://hackage.haskell.org/package/cabal-install
00:36:24 <osa1> Jafet: ./bootstrap.sh also doesn't work on my system because of some dependencies, do we have a binary distribution for 64bit linux
00:36:52 * osa1 is about to install ubuntu and download from package manager
00:37:28 <piis3141> MacMagnus: what is it that you want to do?
00:38:05 <Jafet> osa1: uh, go get those dependencies
00:38:13 <Jafet> What kind of dependencies don't you have?
00:38:16 <ivanm> why doesn't bootstrap.sh work?
00:38:24 <osa1> Jafet: unix >=2.0 && <2.5
00:38:26 <osa1> lol
00:38:34 <osa1> I'm not sure if it's joking ..
00:39:10 <MacMagnus> piis3141: i want to make a irc-bot that can run haskell
00:39:19 <MacMagnus> piis3141: haskell-functions
00:39:34 * hackagebot relit 0.1.3 - Literal for regular expression  http://hackage.haskell.org/package/relit-0.1.3 (KazuYamamoto)
00:39:35 <piis3141> MacMagnus: only one function has type (a -> a) by the way
00:39:48 <piis3141> have a look at http://www.haskell.org/haskellwiki/GHC/As_a_library
00:39:54 <Jafet> Oh, are you talking about GHC 7.4
00:40:02 <osa1> Jafet: yes
00:40:06 <Jafet> I don't know if cabal-install is fixed yet
00:40:12 * ivanm glares at his internet connection
00:40:14 <donri> MacMagnus: mueval, hint, safe haskell (7.2+)
00:40:19 <MacMagnus> piis3141: thanks, Im new to haskell so thanks :)
00:40:26 <Jafet> If it hasn't been fixed, then use the replacement cabal-install on hackage.
00:41:55 <Jafet> piis: don't forget const undefined
00:41:59 <piis3141> MacMagnus: this may be of use as well: http://hackage.haskell.org/packages/archive/plugins/1.0/doc/html/System-Eval-Haskell.html
00:47:41 <Sgeo> On the one hand, ooh, Yesod 0.10, on the other, Yesod's been ticking me off lately (although admittedly I never actually used it)
00:49:34 * hackagebot test-framework-th-prime 0.0.2 - Template Haskell for test framework  http://hackage.haskell.org/package/test-framework-th-prime-0.0.2 (KazuYamamoto)
00:50:01 <piis3141> Jafet: that has type b -> a
00:51:38 <Jafet> \a -> undefined :: a
00:51:57 <Jafet> Er, \a -> undefined `asTypeOf` a
00:54:35 * hackagebot hfoil 0.1.2 - Hess-Smith panel code for inviscid 2-d airfoil analysis  http://hackage.haskell.org/package/hfoil-0.1.2 (GregHorn)
00:54:40 <piis3141> ah ok
01:13:41 <qnikst> hello, and you advice how can I run additional source in conduits, i.e:
01:15:13 <qnikst> I've got code src $= CT.decode ascii $= CL.map (\t -> case (decode t of Left e -> pack ("error"++e); Right (t,_) -> {-here I want to run another source that will feed sink with data-}
01:15:44 <qnikst> CL is counduit List, CT is conduit text
01:39:37 * hackagebot cabal-sort 0.0.4 - Topologically sort cabal packages  http://hackage.haskell.org/package/cabal-sort-0.0.4 (HenningThielemann)
01:54:40 * hackagebot cmdargs 0.9.3 - Command line argument processing  http://hackage.haskell.org/package/cmdargs-0.9.3 (NeilMitchell)
02:01:42 <hey_lu> anikst: you'd have to run a whole conduit in there and have it output a ByteString...
02:06:43 <wicope> hi, where i found a useful predefined functions and operators in Haskell. thanks
02:07:38 <donri> @hackage base
02:07:38 <lambdabot> http://hackage.haskell.org/package/base
02:07:42 <donri> is a good place to start
02:07:50 <donri> @where platform
02:07:50 <lambdabot> http://hackage.haskell.org/platform/
02:07:57 <donri> also links to docs
02:16:28 <FilipeHaskell> hey hey
02:24:42 * hackagebot darcs-scripts 0.1 - Shell scripts for support of darcs workflow  http://hackage.haskell.org/package/darcs-scripts-0.1 (HenningThielemann)
02:29:06 <clj_newb> ping
02:31:35 <hey_lu> pong :p
02:44:44 * hackagebot cabal-scripts 0.1 - Shell scripts for support of Cabal maintenance  http://hackage.haskell.org/package/cabal-scripts-0.1 (HenningThielemann)
02:46:26 <MaskRay> what's the difference between haskelldb-hdbc-sqlite3 and hdbc-sqlite3?
02:47:16 <MaskRay> the former seems to be a higher-layer framework
02:49:45 * hackagebot cabal-sort 0.0.4.1 - Topologically sort cabal packages  http://hackage.haskell.org/package/cabal-sort-0.0.4.1 (HenningThielemann)
03:00:57 <irene-knapp1> :t breakAt
03:00:58 <lambdabot> Not in scope: `breakAt'
03:01:00 <irene-knapp1> :t break
03:01:00 <lambdabot> forall a. (a -> Bool) -> [a] -> ([a], [a])
03:01:04 <irene-knapp1> :t split
03:01:05 <lambdabot> forall g. (RandomGen g) => g -> (g, g)
03:06:51 <gregATio> im finally starting to feel comfortable with Haskell it feels so good
03:13:30 <osa1> it's said in Prelude's curry's documentation that curry converts uncurried function to a curried function, but how can I create a uncurried function?
03:14:00 <zenzike> MaskRay: yes, the former is the backend for haskelldb, which you can think of as a higher abstraction on databases than hdbc
03:14:03 <gregATio> apply
03:14:08 <Jafet> :t curry
03:14:09 <lambdabot> forall a b c. ((a, b) -> c) -> a -> b -> c
03:14:24 <Jafet> > curry (\(a,b) -> a + b) 1 2
03:14:25 <lambdabot>   3
03:18:51 <jonkri> would it be useful if i created a small package that provided Data.Email with an Email type for quickly accessing alias and host name as well as a String -> Maybe Email function for e-mail validation?
03:19:00 <osa1> hmm, so creating a function creates a curried function by default but creating a lambda creates an uncurried function?
03:19:52 <gregATio> osa1: creating a lambda creates a function which is curried by default
03:20:49 <gregATio> i.e. you dont have to supply all of its arguments
03:21:04 <merijn> jonkri: You're assuming valid emails have a hostname
03:21:44 <merijn> jonkri: My advice, just give up and don't check e-mail validity (or, if you must check just blindly send a confirmation e-mail and check whether the link in it was clicked)
03:22:19 <donri> (or use browserid)
03:22:26 <merijn> jonkri: The e-mail RFC will make your brain melt in what it allows and people who think they can get it right routinely mess it up. (Alternatively, if you have a high tolerance for pain and encode all possibilities, godspeed to you)
03:22:36 <gregATio> jonkri: is it the format you are worried about or wheterh the host actually exists?
03:22:49 <gregATio> if its the format , simple regex would do wouldnt it?
03:23:17 <merijn> Take for example all the freaking websites who tell me that + is not a legal character before the @, bunch of idiots >.>
03:23:40 <gregATio> good way to avoid spam though :-/
03:23:44 <mee_> merijn++
03:23:48 <merijn> gregATio: What do you do when someone insists on using a bangpath address? (Incidentally, still legal in the e-mail RFC)
03:23:56 <jonkri> gregATio, merijn: yes, it is the format i'm interested in only. and unless i remember incorrectly, there is a (non-simple) regular expression in the rfc
03:24:29 <merijn> Hell, did you know its legal to have an @ before the @? :D
03:24:35 <gregATio> merijn: change your rege
03:24:35 <merijn> Just needs proper quoting :)
03:24:57 <gregATio> but it doesnt need to be email rfc conformant
03:24:59 <merijn> (And suddenly a million web developers cried out in anguish)
03:25:05 <gregATio> it just needs to be pragmatic
03:25:27 <merijn> gregATio: Sure, but in general the most pragmatic thing is to just let the mail server worry about mail delivery :p
03:25:34 <gregATio> it depends on whether you are writing a practical email validation program or a theoretic one :P
03:25:56 <gregATio> depends on whether you are wanting to save bandwith merijm
03:26:01 <gregATio> merijn:
03:30:51 <Phlogistique> gregATio: how much bandwitdth are you saving by not sending one email to an invalid mail adress?
03:31:18 <Phlogistique> now here's an email validation regexp: .+@.+
03:31:20 <rostayob> @pl \c cs -> f (c : cs)
03:31:20 <lambdabot> (f .) . (:)
03:31:34 <rostayob> @pl \c -> f (c : cs)
03:31:34 <lambdabot> f . (: cs)
03:34:29 <merijn> Phlogistique: Not sure that works for bang paths :p
03:35:42 <Phlogistique> merijn: yes, sorry :)
03:39:33 <gregATio> what im saying is perhaps you have website
03:39:51 <gregATio> where you have asked people to enter an email address
03:41:03 <merijn> Yes, then you mail them once with a confirmation link and voila, address confirmed
03:41:33 <gregATio> so the user submits the form to you and you then send the form to a mailserver to validate the email address (bandwith) gets used, then when it fails the webserver tells you its wrong (bandwith)
03:41:46 <gregATio> and then multiply this by the number of users
03:42:41 <merijn> s/bandwidth/insignificant amount of bandwidth/g
03:43:13 <gregATio> lol
03:43:57 <merijn> A confirmation e-mail is what? A couple hundred of bytes? Less than the current average webpage >.>
03:44:05 <gregATio> same reason theres lots of client side validation in javascript for webforms
03:44:18 <merijn> Client side validation is only to help users
03:44:34 <merijn> I should hope, because otherwise the programmer is a clueless idiot
03:45:01 <Phlogistique> gregATio: also the bandwidth would have been cheaper than the time you have spent speaking here
03:45:02 <gregATio> provides a faster experience
03:45:08 <gregATio> lol
03:45:25 <gregATio> you have forgotton to mulitply it by the number of users
03:45:30 <merijn> Phlogistique: Not to mention the time to write said code
03:45:39 <Phlogistique> gregATio: no I have not
03:45:40 <merijn> Bandwidth is still cheap in the gigabyte range
03:45:54 <luite> merijn: it's an extra step for the user
03:46:12 <gregATio> it takes time to contact a mailserver
03:46:13 <luite> I prefer single sign on things for that reason
03:46:19 <gregATio> this detracts from user experience
03:46:26 <merijn> luite: Sure, but I'm not advocating verifying e-mails
03:46:35 <merijn> luite: I'm just stating the best way to do it if you have to
03:46:54 <Phlogistique> gregATio: why do you want to verify emails that much?
03:47:09 <luite> meh just use a sso service that provides validated emails :)
03:47:31 <merijn> luite: The problem then becomes "which one?"
03:47:31 <gregATio> lol : its not even me that wants to do it
03:47:56 <gregATio> i just said " you may want to use regular expressions IF you want to save bandwidth"
03:47:56 <merijn> Phlogistique: He just sidetracked me from my original argument against someone who wanted to verify e-mails :p
03:47:59 <gregATio> geez
03:48:03 <luite> merijn: browserid is very easy to use, but unfortunately not yet very widely used
03:49:17 <merijn> I'm still mildly skeptical about this and openid like business
03:49:46 <merijn> I'd prefer just anonymous keys, should be more than enough for most sites. But I fear that'll never take off in the non tech crowd :\
03:49:57 <Phlogistique> openID looks pretty hard to implement
03:50:12 <merijn> What if I don't want them to have my e-mail, for example?
03:50:19 <Phlogistique> the good point is that everybody has one
03:50:29 <Phlogistique> merijn: use yopmail
03:51:00 <merijn> That's not useful as a persistent identity :p
03:52:08 <Phlogistique> why not
03:53:12 <merijn> Giving a different e-mail address that sends to a real one doesn't work if you use it as persistent address, since then you can't discard it
03:53:57 <gregATio> :|
03:55:55 <luite> merijn: openid is a bit annoying imho, since logging in gives you only the key, you still need separate unique user-visible identifiers (username/handle, email? but you still need to verify email addresses, unless your openid provider provides one, but that's even more work to implement)
03:57:18 <merijn> luite: OpenID is not really a great solution, imo
03:59:31 <rata_> is it always recommended to use Data.{IntMap a, IntSet} instead of Data.{Map Int a, Set Int}?
04:00:00 <luite> merijn: I'm using BrowserID now, maybe I'll add some others later
04:01:43 <merijn> rata_: Well, it'll never hurt :p
04:09:47 * hackagebot grapefruit-frp 0.1.0.2 - Functional Reactive Programming core  http://hackage.haskell.org/package/grapefruit-frp-0.1.0.2 (WolfgangJeltsch)
04:09:49 * hackagebot grapefruit-records 0.1.0.2 - A record system for Functional Reactive Programming  http://hackage.haskell.org/package/grapefruit-records-0.1.0.2 (WolfgangJeltsch)
04:19:46 * hackagebot grapefruit-ui 0.1.0.2 - Declarative user interface programming  http://hackage.haskell.org/package/grapefruit-ui-0.1.0.2 (WolfgangJeltsch)
04:19:49 * hackagebot grapefruit-ui-gtk 0.1.0.2 - GTK+-based backend for declarative user interface programming  http://hackage.haskell.org/package/grapefruit-ui-gtk-0.1.0.2 (WolfgangJeltsch)
04:19:51 * hackagebot grapefruit-examples 0.1.0.2 - Examples using the Grapefruit library  http://hackage.haskell.org/package/grapefruit-examples-0.1.0.2 (WolfgangJeltsch)
04:25:18 <MaskRay> is there off-the-shelf function to quote a string which will be used as a table name in hdbc-sqlite3?
04:28:36 <efie> can anyone tell me what i did wrong? http://pastebin.com/MeqwHte9
04:28:38 <mauke> The paste MeqwHte9 has been copied to http://hpaste.org/63390
04:29:13 <koeien> getDirectoryContents "."
04:30:10 <efie> thank you!
04:31:43 <efie> um but i would like to start the program and then enter a name of a specific path
04:32:16 <efie> ups.. nevermind, my mistake
04:32:46 <koeien> right, then path <- getLine and use getDirectoryContents path
04:33:32 <efie> yes, thanks :)
04:35:17 <burbul> I'm applying a sequence of complex manipulations to a single object, which is more or less a big tree. Is there a way to tell Haskell to fully evaluate the tree after each manipulation, rather than lazily allowing all the manipulations to run into each other?
04:36:28 <koeien> that is possible.
04:36:33 <koeien> look up NFData
04:39:50 * hackagebot pqc 0.5 - Parallel batch driver for QuickCheck  http://hackage.haskell.org/package/pqc-0.5 (KidoTakahiro)
04:42:09 <confluency> Hello
04:42:17 <mreh> confluency: hi
04:42:21 <koeien> confluency: hi!
04:42:36 <confluency> Does anyone know if there is a channel where I could get help with pandoc?
05:07:36 <Flonk> Hullo
05:07:43 <koeien> hi Flonk
05:07:43 <Taneb> Hello
05:10:16 <efie> this http://hpaste.org/63393 renames files in a directory to ".. .jpg" if they are not already a .jpg file. is there a way to write the function "renameToJpg" more functional using Higher order function? like taking a list of strings and renaming them if  a predicate is true..
05:10:46 <Botje> efie: look at the endsWith function
05:10:50 <Botje> uh
05:10:52 <Botje> no
05:10:54 <Botje> isSuffixOf
05:11:07 <Botje> :t ".jpg" `isSuffixOf`
05:11:08 <lambdabot> parse error (possibly incorrect indentation)
05:11:12 <xplat_> is there a safe getEnv that won't asplode if the environment variable does not exist?
05:11:14 <Botje> :t (".jpg" `isSuffixOf`)
05:11:15 <lambdabot> [Char] -> Bool
05:11:15 <jonkri> there are more people in here than in #javascript, that's pretty cool :)
05:11:49 <khanzor> i heard there were a lot more closures over there than here...
05:11:57 <Flonk> :D
05:12:05 <jonkri> :D
05:12:31 <rwbarton> efie: your renameToJpg only renames the first non-jpg file
05:12:31 <Botje> efie: as for your other questions .. forM_ files $ \f -> unless (isJpg f) (renameFile ...)
05:14:04 <ClaudiusMaximus> @hoogle IO a -> IO (Maybe a)
05:14:04 <lambdabot> System.Timeout timeout :: Int -> IO a -> IO (Maybe a)
05:14:05 <lambdabot> Control.Applicative optional :: Alternative f => f a -> f (Maybe a)
05:14:05 <lambdabot> Prelude Just :: a -> Maybe a
05:14:19 <xplat> @hoogle String -> IO (Maybe String)
05:14:20 <lambdabot> System.Posix.Env getEnv :: String -> IO (Maybe String)
05:14:20 <lambdabot> System.Directory findExecutable :: String -> IO (Maybe FilePath)
05:14:20 <lambdabot> Network.CGI getCookie :: MonadCGI m => String -> m (Maybe String)
05:14:43 <xplat> @hoogle getEnv
05:14:43 <lambdabot> System.Environment getEnv :: String -> IO String
05:14:44 <lambdabot> System.Environment getEnvironment :: IO [(String, String)]
05:14:44 <lambdabot> System.Posix.Env getEnv :: String -> IO (Maybe String)
05:14:54 * hackagebot oi 0.0.5 - Purely Functional Lazy Interaction with the outer world  http://hackage.haskell.org/package/oi-0.0.5 (NobuoYamashita)
05:15:16 <xplat> didn't someone prove OI doesn't work?
05:15:32 <ClaudiusMaximus> :t (Just `fmap` undefined) `catch` \_ -> return Nothing
05:15:33 <lambdabot> forall a. IO (Maybe a)
05:18:37 <Botje> §
05:20:08 <khanzor> has anyone had any fun with yesod/persistent?
05:20:19 <khanzor> i'm struggling to be able to query it for an item
05:20:28 <burbul> (Rather belatedly: thanks, koeien!)
05:20:44 <xplat> okay, it's a little ridiculous that you have to choose between writing your own getEnv over getEnvironment, losing portability, or using spoon to get a safe getEnv when even C has it :-/
05:20:47 <khanzor> i can't quite work out how to create an id for the the autogenerated types
05:21:48 <ClaudiusMaximus> xplat: why spoon and not regular catch?
05:22:16 <xplat> er, you're right :)
05:22:45 <xplat> anyway, even catch is weird, it's not exactly an exceptional condition that an env variable is unset
05:22:45 <ClaudiusMaximus> but yes, seems a bit silly to have exceptions here
05:24:24 <Flonk> Did freenode just barf up for everyone?
05:24:34 <yrlnry> no.
05:24:51 <Flonk> Okay
05:25:04 <parcs`> khanzor: by id you mean primary key?
05:25:24 <efie> rwbarton: thanks for the hint
05:27:52 <khanzor> parcs`: yeah, i think i must just be a spastic
05:28:30 <khanzor> parcs`: all this autogenerated stuff makes it hard for me to reason about what is required and where (hopefully it'll get easier with exp)
05:31:29 <parcs`> you can do something like "Key (toPersistValue (4 :: Int))" to create a primary key yourself, but you don't usually have to do that :P
05:34:15 <Botje>    
05:34:46 <efie> botje: thanks for your solution, now all files are covered, but there is one exception: http://hpaste.org/63394 do you think i should check for ".." by adding them to the isJpg  method?
05:35:34 <Botje> efie: you could add them to the unless clause
05:35:56 <Botje> efie: also, you can put the unless and the renameFile call on separate lines
05:36:06 <Botje> efie: also, you should use / to separate paths, is more portable
05:36:09 <Botje> (and yes, it works on windows)
05:36:28 <Botje> or you should ask System.FilePath (iirc) to do it for you
05:36:49 <rwbarton> @type (</>)
05:36:50 <lambdabot> Not in scope: `</>'
05:36:57 <khanzor> parcs`: wow! thanks! it type checks (slash cackle)
05:37:01 <rwbarton> @hoogle </>
05:37:01 <lambdabot> System.FilePath.Windows (</>) :: FilePath -> FilePath -> FilePath
05:37:01 <lambdabot> System.FilePath.Posix (</>) :: FilePath -> FilePath -> FilePath
05:37:08 <efie> botje: thanks :)
05:37:09 <Botje> yes, that. thanks rwbarton
05:39:27 <parcs`> khanzor: great :)
05:39:52 <jeff_s_> I just successfully used my first monad transformer ever!
05:40:06 <Botje> jeff_s_: AchievementT unlocked!
05:40:31 <jeff_s_> thanks :)
05:41:11 <matthiasgorgens> jeff_s_: you probably used monad transformers before.  And just didn't realize it.
05:41:20 <matthiasgorgens> Like with lots of abstractions.
05:41:32 <jeff_s_> Possibly
05:41:34 <matthiasgorgens> I guess you did while mowing the lawn, or bringing the kids to school. :o)
05:42:05 <jeff_s_> I used the lawn-mowing monad transformer to take the kids to school on my tractor.
05:42:20 <mzero> is Sean Leather around? if so, can you /msg me?
05:43:12 <carpi_> is it possible to call python functions from haskell?
05:44:54 * hackagebot cabal-sort 0.0.4.2 - Topologically sort cabal packages  http://hackage.haskell.org/package/cabal-sort-0.0.4.2 (HenningThielemann)
05:44:56 * hackagebot json2yaml 0.3.0 - Utility to convert a file from JSON to YAML format.  http://hackage.haskell.org/package/json2yaml-0.3.0 (MichaelSnoyman)
05:45:56 <lukish> Is it necessary to call python function from haskell?
05:46:17 <matthiasgorgens> carpi_: it is definitely possible if you go via the C route.
05:46:39 <matthiasgorgens> carpi_: I don't know whether there's a direct foreign function call interface.
05:46:44 <jeff_s_> You could send function calls to a python interpreter via its stdin I suppose.
05:47:06 <matthiasgorgens> jeff_s_: that's possible, but would be like building a rube-goldberg machine.
05:47:27 <matthiasgorgens> carpi_: I guess you are talking about cpython?
05:47:29 <jeff_s_> matthias - isn't that what it amounts to either way?
05:47:31 <matthiasgorgens> and ghc?
05:47:46 <carpi_> matthiasgorgens: python2.7 and ghc
05:48:14 <matthiasgorgens> http://hackage.haskell.org/trac/summer-of-code/ticket/1547
05:48:34 <matthiasgorgens> carpi_: did you do some web searching for `haskell python ffi' or so?
05:49:11 <carpi_> i google 'haskell python' and i got something that was relevant from 2009...
05:50:05 <carpi_> the thing is.. i am trying to write an application related to qr codes. unfortunately.. haskell doesn't have a proper library for decoding and encoding qr codes.. though i would really prefer to do this in haskell
05:54:54 <gwern> lpsmith: yes?
05:55:30 <dca> what is the latex symbol for subtyping?
05:59:19 <jeff_s_> OK - maybe my celebration was a bit premature. I think I want a writer inside of a reader, so I did it backwards.
05:59:59 * hackagebot bindings-libzip 0.1.0.4 - Low level bindings to libzip.  http://hackage.haskell.org/package/bindings-libzip-0.1.0.4 (SergeyAstanin)
06:00:01 * hackagebot LibZip 0.2.0.4 - Bindings to libzip, a library for manipulating zip archives.  http://hackage.haskell.org/package/LibZip-0.2.0.4 (SergeyAstanin)
06:01:35 <Saizan> SPJ really wants to take (.) away to use it for field selection?
06:01:42 <yrlnry> Madness.
06:02:01 <yrlnry> What does he propose as a replacement name for (.)?
06:02:04 <yrlnry> o?
06:02:18 <parcs`> ∘
06:02:49 <parcs`> (i don't know this proposal :P)
06:02:55 <parcs`> his*
06:03:06 <parcs`> Saizan: where do you read that?
06:04:44 <quicksilver> I am very surprised by various of SPJ's opinions on field selectoin
06:05:06 <quicksilver> I wonder if he's being unduly influenced by a few loud minority voices
06:05:49 <cmccann_> well, ∘ sounds good to me
06:06:10 <Saizan> parcs`: i've seen him quoted on the most recent haskell-prime thread
06:06:23 <Entroacceptor> oh please, don't
06:06:24 <cmccann_> I don't see much reason to use (.) for field selection though
06:06:28 <Entroacceptor> ° would bebetter
06:06:46 <cmccann_> unless it was as part of some sort of unifying-records-and-modules thing
06:10:30 <osa1> I'm getting this errors while installing yesod: http://paste.pocoo.org/show/548848/ can anyone help me?
06:11:16 <xplat> (.) for field selection is a scary proposal
06:12:00 <xplat> i can't see any way that would be a good idea except in conjunction with a serious break-the-world revision of ... everything
06:12:40 <tazjin> Guys, what is this: http://hackage.haskell.org/packages/archive/acme-inator/0.1.0.0/doc/html/Acme-Inator.html ?
06:13:06 <Botje> the Acme thing suggests it's probably a joke
06:13:35 <dschoepe> tazjin: It's best used in conjunction with this, I guess: http://hackage.haskell.org/package/acme-dont
06:13:37 <dschoepe> :)
06:13:53 <tazjin> I am
06:13:54 <tazjin> this
06:13:55 <tazjin> the, uhh
06:13:56 <donri> (.) isn't so mad, qualified modules are uppercased and composition whitespaced
06:14:03 <tazjin> I'm gonna take a bath I think. #confused
06:14:18 <DarkUnicorn> osa1: did you try do install the failing packages separatly? syb and lifted-base?
06:15:00 * hackagebot HaRe 0.6.0.2 - the Haskell Refactorer.  http://hackage.haskell.org/package/HaRe-0.6.0.2 (ChrisBrown)
06:15:19 <osa1> DarkUnicorn: cabal install syb returning ExitFailure 1
06:15:38 <donri> ooh hare upgrade, will it build on recent ghc now?
06:16:36 <DarkUnicorn> osa1: no more specific error message?
06:16:57 <osa1> DarkUnicorn: http://paste.pocoo.org/show/548850/
06:17:27 <osa1> DarkUnicorn: or this: http://paste.pocoo.org/show/548851/
06:18:57 <dcoutts> donri: ah yes, cool indeed, lets hope so. I talked to Chris last year, he was fairly keen on getting it working again (also to use as the basis of a new research project)
06:19:17 <DarkUnicorn> osa1: did you du a "cabal update" before "cabal install yesod"?
06:19:32 <DarkUnicorn> s/du/do
06:19:44 <osa1> DarkUnicorn: yes
06:19:53 <quicksilver> donri: I think it's fairly made to make f.g and f . g mean totally different things.
06:21:06 <donri> that's already the case: import qualified Just -- or whatever
06:22:33 <DarkUnicorn> osa1: i would try a fresh start (delete the .cabal dir), i think its a problem with already installed packages, i just did a fresh install of yesod without problems
06:23:19 <osa1> DarkUnicorn: which version of ghci are you using?
06:24:37 <DarkUnicorn> osa1: 7.0.3
06:25:09 <donri> yay hare builds on 7.0.4
06:25:12 <osa1> DarkUnicorn: ok, I downgraded my ghc from 7.4.x to 7.0.4, and deleted .cabal
06:25:36 <osa1> and I think I have a different error this time
06:25:55 <osa1> let me paste
06:26:13 <osa1> http://paste.pocoo.org/show/548860/
06:28:04 <Entroacceptor> why not use => for records
06:29:16 <quicksilver> donri: yes, but it's a restricted case only involving uppercase on the left
06:29:25 <quicksilver> donri: (although I still think it is bad / was a mistake to do that)
06:29:29 <DarkUnicorn> osa1__: sorry i have no idea
06:29:56 <osa1__> DarkUnicorn: ok, thanks
06:32:08 <covi> Hi guys. Is haskell suitable for practical development?
06:32:31 <Clint> seems to be
06:32:34 <DasIch> covi: it is
06:32:50 <DasIch> covi: at least there are people using it for serious projects
06:33:01 <covi> Can you refer to famous projects developed in haskell?
06:33:03 <covi> DasIch: ^
06:33:11 <DasIch> covi: xmonad
06:33:13 <covi> As of now I only know xmonad
06:33:25 <DasIch> covi: ghc itself
06:33:35 <quicksilver> darcs
06:33:38 <qnikst> yesod
06:34:12 <covi> thanks, will check it out. What do you use haskell for?
06:39:00 <wubu> haskell n00b here - wondering if there is a console editor i can use in mac instead of the xcode implementation
06:41:05 <td123> vim, emacs are probably the 2 big ones, there's also yi which I never played with
06:42:16 <covi> wubu: vim is THE editor
06:43:12 <wubu> yeah i use vi a lot but i haven't figured how to tie it to haskell
06:43:41 <covi> wubu: what do you mean by tie?
06:43:59 <wubu> i mean like key bindings etc
06:44:25 <wubu> is there a way for me to evaluate expressions i write in vi and have them show up in vi?
06:44:37 <covi> wubu: #vim
06:44:46 <wubu> okay
06:45:02 <wubu> thanks
06:47:52 <ChristianS> hi, does anybody here know whether there is a way in pandoc to specify the kind of typographic quotes to use with the -S option or for latex output?
06:48:26 <ChristianS> i can set the language via  -V lang=de-DE  but that doesn't change the quotes from english to german
06:48:36 <ChristianS> or is there a better channel/forum to ask about pandoc?
06:53:56 <rata_> hi
06:54:25 <rata_> is there something like Lisp's cond expression in Haskell?
06:55:32 <shapr> if ?
06:55:37 <shapr> if x then y else z ?
06:56:02 <shapr> I forget how cond works.
06:56:15 <rata_> shapr: yes, but nested
06:56:31 <shapr> As in, multiple conditions?
06:56:36 <rata_> yes
06:56:57 <Botje> rata_: you can fake it with a case
06:57:01 <rata_> something like cond test1 -> expr1 test2 -> expr2 ...
06:57:08 <Botje> case () of _ | cond1 -> ...; _ | cond2 -> ...
06:57:17 <donri> case True of cond -> ...
06:57:17 <shapr> hoi Botje !
06:57:26 <donri> uh
06:57:29 <shapr> hm, time for class
06:57:30 <donri> no :D
06:57:31 <Botje> hallo shapr!
06:57:48 <quicksilver> you can write cond :: [(Bool,a)] -> a
06:58:01 <Botje> or that.
06:58:34 <quicksilver> :t snd . head . filter fst
06:58:35 <lambdabot> forall b. [(Bool, b)] -> b
06:58:41 <Botje> add a bit of sugar,too: (-->) = (,)
06:58:46 <quicksilver> blows up if nothing matches though.
06:58:54 <quicksilver> and that's what I was going to suggest next, yes, Botje :)
06:59:30 <Botje> that was also the first time *ever* I had used implication in code
07:00:11 <covi> Why doesn't haskell allow the [] index notation, instead of !!
07:00:31 <srhb> covi: Um. "because".
07:00:33 <Botje> because mixfix operators are nasty.
07:00:34 <overflow_0f8b> i'm thinking about making a stargate singularity animation, it's some kind of fluid motion surface filled with some gradient, any ideas what is the function of the fluidsurface's colors ?
07:00:46 <donri> you should rarely use !! anyway
07:00:54 <srhb> I mean, it's just a design choice, and !! is a nice infix operator which you shouldn't use anyway.
07:03:59 <rata_> Botje: can you use where variables in guards?
07:04:25 <uniquenick> how do I define functions with pattern matching in ghci?  like fact 0 = 1 fact n = ....?  if I use let for both, then one over-writes the other
07:04:42 <Botje> rata_: i don't know that by heart
07:04:49 <Botje> uniquenick: define them both at once.
07:04:57 <Botje> let fact 0 = 1; fact n = n * fact (n-1)
07:05:01 * hackagebot yesod-markdown 0.3.3 - Tools for using markdown in a yesod application  http://hackage.haskell.org/package/yesod-markdown-0.3.3 (PatrickBrisbin)
07:17:05 <rata_> thanks Botje, it worked =)
07:19:19 <kniu> @pl \(x, y) -> (succ x, succ y)
07:19:19 <lambdabot> succ *** succ
07:19:30 <kniu> :i ***
07:19:41 <kniu> @hoogle (***)
07:19:41 <lambdabot> Control.Arrow (***) :: Arrow a => a b c -> a b' c' -> a (b, b') (c, c')
07:19:57 <kniu> gah, arrows
07:20:39 <erus`> > (suc *** suc) (1,2)
07:20:40 <lambdabot>   Not in scope: `suc'Not in scope: `suc'
07:20:46 <erus`> > (succ *** succ) (1,2)
07:20:47 <lambdabot>   (2,3)
07:28:45 <tromp__> how is (2,3) an Arrow a => a (b, b') (c, c') ??
07:29:26 <tromp__> oh wait
07:29:27 <copumpkin> it isn't
07:29:30 <tromp__> ic
07:29:50 <tromp__> a = (->)
07:30:14 <copumpkin> yep
07:34:57 <jeff_s_> If I have a ReaderT inside of a ReaderT, how do I ask one vs. the other?
07:35:36 <donri> jeff_s_: lift, perhaps?
07:35:37 <tromp__> use more lifting
07:35:46 <jeff_s_> What if I'm not strong enough?
07:35:58 <donri> the type system is strong enough
07:36:55 <tromp__> i'd expect multiple instance errors if you have a ReaderT inside of a ReaderT
07:37:34 <tromp__> or overlapping instances or whatever it's called
07:37:40 <donri> why?
07:37:56 <tromp__> because most monadic ops are auto-lifted
07:38:29 <lysgaard> I'm compiling a program on a Arch linux box running x86_64. Then I want to run it on a box running x86_64 Ubuntu. What do I have to tell the compiler for that to work?
07:39:01 <cmccann> tromp__, it'd be ambiguous if the both ReaderT have the same environment type
07:39:38 <cmccann> but that's simply ambiguous in every sense so you need to specify somehow
07:39:44 <cmccann> manual lifting will always work, as far as I know
07:40:09 <tromp__> yes, manual lifting will resolve any ambiguity
07:42:06 <tromp__> hmm, wait. manual lifting to the lower level will resolve it. but isn't a lift to higher level still ambiguous?
07:42:40 <gergo> Hey! I'm newbi in haskell, and I cannot make a function from an expression that works in ghci with a constant. My expression is [ x | x <- [2,3..floor(sqrt(70))], 70 `mod` x == 0]. But I wanna use it as a function with a variable instead of the constant 70.
07:42:42 <tromp__> let's say my monad is ReaderT (ReaderT Identity)
07:43:01 <tromp__> then how do i get in outer one?
07:43:19 <quicksilver> tromp__: "lift" is never ambigous.
07:43:23 <Botje> tromp__: lift (ask ...)
07:43:30 <Botje> uh, just lift ask, actually.
07:43:35 <quicksilver> :t ask
07:43:37 <lambdabot> forall (m :: * -> *) r. (MonadReader r m) => m r
07:43:45 <Botje> gergo: so make it into a function.
07:43:49 <quicksilver> problem with ask is it's MonadReader
07:44:00 <quicksilver> and so I think you have an overlapping instance although I'm not sure ?
07:44:10 <quicksilver> is there a non-overloaded ask for cases like this?
07:44:28 * quicksilver can't remember which instances there are and would have to try it.
07:44:47 <Botje> gergo: let fun constant = [.... constant ]
07:46:13 <Leftmost> Given a list [b_0, b_1, ..., b_n, 0], I want to build a list [b_0 + b_1, b_1 + b_2, ..., b_n + 0]. I'm not even entirely sure how to approach this in Haskell. Any suggestions?
07:46:45 <gergo> I can declare it, but it does not work.
07:46:46 <elliott> Leftmost: zipWith (+) xs (tail xs)?
07:46:56 <elliott> > let xs = [a,b,c,d,0] in zipWith (+) xs (tail xs)
07:46:57 <lambdabot>   [a + b,b + c,c + d,d + 0]
07:47:21 <elliott> > let fibs = 0 : 1 : zipWith (+) fibs (tail fibs) in fibs
07:47:22 <lambdabot>   [0,1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765,10946...
07:47:51 <gergo> When I wanna call it, I got error about ambiguous type variables...
07:48:05 <Leftmost> Cheers, elliott. Much appreciated.
07:48:11 <mbazs> [1..]
07:48:16 <aristid> > [a..]
07:48:17 <lambdabot>   *Exception: not a number
07:48:30 <elliott> Leftmost: basically, zipWith foo [a,b,c] [d,e,f] --> [foo a d, foo b e, foo c f]
07:48:49 <elliott> Leftmost: so zipWith (+) [a,b,c] [d,e,f] --> [a+d, b+e, c+f]
07:49:05 <elliott> in this case, we want to offset all the elements by one to produce the list to zip with, thus the tail
07:49:10 <Leftmost> Didn't even think to tail xs. Still adjusting to functional thinking.
07:53:38 <cmccann> quicksilver, how about "ReaderT return"
07:53:58 <quicksilver> that kind of thing works,yes
07:54:11 <quicksilver> I just can't remember which instances they defined for ReaderT towers
07:56:06 <hpaste> “Dylan Lukes” pasted “multiple list comprehension matches” at http://hpaste.org/63398
07:56:33 <dylukes> I don't recall how to do the second clause of this comprehension...
07:56:50 <gergo> I've already figured out, that if I remove thr floor and sqrt functions it works.
07:57:12 <gergo> It's just not good enough for me.
07:57:20 <ClaudiusMaximus> > (length.nub.take 5)[2**53..]
07:57:22 <lambdabot>   1
07:58:13 <dylukes> I guess it wants the right hand side to be a list...
07:58:15 <dylukes> and it's not...
07:58:23 <quicksilver> dylukes: then don't use <-
07:58:33 <quicksilver> or do you want the binding semantics?
07:58:40 <quicksilver> (fail with [] if the pattern doesn't match) ?
07:58:46 <dylukes> I want the binding.
07:58:53 <dylukes> Since I need length args
07:58:54 <quicksilver> then, FunObj args _ <- [obj]
07:59:02 <quicksilver> but you should feel dirty as you do it.
07:59:04 <dylukes> :<
07:59:09 <dylukes> how should I be doing it?
07:59:10 <rwbarton> how about just
07:59:11 <dylukes> Defining functions
07:59:12 <quicksilver> no that's not what I meant.
07:59:13 <dylukes> ?
07:59:22 <rwbarton> Decl var (FunObjs args _) <- decls
07:59:33 <dylukes> rwbarton == genius.
07:59:34 <quicksilver> if you just want args, that's fine, just do "let FunObj args _ = obj
07:59:40 <quicksilver> or what rwbarton said which is smarter
07:59:46 <dylukes> can you have let's inside comprehensions...?
07:59:47 <quicksilver> my point was about pattern match failure behaviour
07:59:50 <quicksilver> yes.
08:00:06 <rwbarton> how does pattern match failure in let bindings interact with list comprehension?
08:00:09 <weltensegler> How do i convert a Ratio Int into a Float?
08:00:14 <dylukes> I just want to build an association list of var, argcount
08:00:19 <rwbarton> poorly I guess? (i.e. error)
08:00:35 <mbazs> Hi guys. A total virgin here. This is my first visit. So. I'm trying to understand monads, especially the State. My question would be that why State is implemented by a newtype'd function (i.e: s -> (a, s)). What is the point? Thx!
08:00:47 <rwbarton> > [ y | x <- [Just 3, Nothing], let Just y = x ]
08:00:48 <lambdabot>   [3,*Exception: <interactive>:3:34-43: Irrefutable pattern failed for patter...
08:00:59 <monochrom> realToFrac can convert Ratio Int to Float
08:01:35 <dylukes> Okay.
08:01:35 <dylukes> https://gist.github.com/1790917
08:01:40 <dylukes> Here's the complete code then.
08:01:45 <dylukes> Any thoughts on how to clean it up?
08:01:51 <dylukes> It's very haskelly, and I'm quite happy with the way it works though.
08:02:12 <lysgaard> Is there any reliable way to compile a static binary on a Arch linux box and then run it on an Ubuntu box? Both x86_64.
08:02:49 <weltensegler> monochrom, i think realToFrac can convert in the opposite direction.
08:03:02 <dolio> mbazs: Do you mean, 'what's the point of the newtype'?
08:03:02 <lambdabot> dolio: You have 1 new message. '/msg lambdabot @messages' to read it.
08:03:22 <Enigmagic> > realToFrac (1 % 3) :: Float
08:03:23 <lambdabot>   0.33333334
08:03:55 <byorgey> > realToFrac ((1 :: Int) % 3) :: Float
08:03:56 <lambdabot>   0.33333334
08:04:26 <byorgey> mbazs: you mean why is it implemented with a newtype? or why is it a function? or both?
08:04:48 <mbazs> I'm wondering why is it a function.
08:04:55 <weltensegler> monochrom, Enigmagic, sorry you are right! Thank you.
08:05:30 <byorgey> mbazs: the idea is to model "stateful" computations as functions which take an old state and give you a result along with a (possibly updated) state.
08:05:56 <mbazs> dolio: I understand newtype as I know:)
08:05:59 <quicksilver> without really understanding it, dylukes it looks good to me.
08:06:00 <byorgey> mbazs: for example, the computation which evaluates to 3  but also increments the state can be represented by the function   \s -> (3, s+1)
08:06:59 <byorgey> mbazs: but directly using such functions is annoying because you have to pass the state around manually, it is easy to screw up and pass the wrong state, etc.
08:07:17 <byorgey> so the State monad hides the details of passing the state between computations
08:07:30 <cmccann> byorgey, in that stackoverflow question from the other day the question's author is asking if there are any papers on finite differences and/or interpretations of numerical analysis regarding types, know of anything?
08:08:02 <byorgey> cmccann: re: finite differences I think sigfpe has a post or two on the topic
08:08:09 <byorgey> cmccann: no idea re: numerical analysis
08:08:13 <cmccann> i.e. further reading after your paper on species and mcbride's derivative stuff
08:09:51 <cmccann> byorgey, well he's asking sigfpe anyhow, so if that's all you know of I probably don't need to jump in, haha
08:09:59 <byorgey> ok =)
08:10:45 <cmccann> just figured I'd ask, given that wanting more after reading your species stuff was the motivation, heh
08:11:04 <mbazs> byorgey: thank you! So with the help of the (>>=) you're chaining these functions to also update/propagate the state along with the result, am I right?
08:11:13 <byorgey> mbazs: yes, exactly
08:11:29 <mbazs> Ahh :)
08:11:30 <cmccann> mbazs, note that (>>=) takes a function with a type like (a -> m b)
08:11:54 <cmccann> if you expand the definitions of the types you end up with a chain of functions equivalent to (a, state) -> (b, state)
08:12:41 <mbazs> I'll save this conversation and it'll be grepped :)
08:13:32 <mbazs> I'm from the imperativeness and it's very tough for me to understand something like a function returns a function :)
08:15:39 <byorgey> yep, it definitely takes some getting used to
08:16:15 <mbazs> Thank you both. My another question would be that why a Monad's type variable cannot be restricted on a typeclass.
08:16:51 <cmccann> because it can't
08:16:55 <cmccann> :T
08:17:02 <cmccann> there's no serious, deep reason
08:17:32 <mbazs> But it should be?
08:17:59 <cmccann> well, it's part of classes like Functor and Monad that they're parametric, and restricting the type variable goes against that
08:18:25 <cmccann> but it would make sense to consider "parametric within this restricted subset of types", such as Ord instances
08:18:42 * elliott isn't sure that *is* useful, actually.
08:18:50 <elliott> For instance, you couldn't use ap on the Set monad.
08:18:57 <eyebloom> What does it mean conceptually when a type variable "escapes its scope".
08:19:03 <elliott> You'd be forced to write (f <$> x <*> y) rather than (pure f <*> x <*> y).
08:19:17 <elliott> There might be typeclasses it makes sense for, but Ord isn't one.
08:19:38 <cmccann> I didn't say it would always be useful, I said it makes sense
08:19:42 <cmccann> :P
08:20:04 <cmccann> but yes, Ord breaks the assumption that you can use currying through the functor
08:20:05 <rwbarton> even f <$> x <*> y won't work
08:20:07 <mbazs> I'm losing sessions. Elliot, are you talking in our issue? :)
08:20:14 <elliott> rwbarton: oh, yes, indeed
08:20:19 <elliott> mbazs: <mbazs> Thank you both. My another question would be that why a Monad's type variable cannot be restricted on a typeclass.
08:20:23 <elliott> is what I was responding to
08:20:27 <mbazs> ok
08:20:42 <b0fh_ua> Hi all! I have Data.ByteString.Lazy - how can I convert it to Data.ByteString.UTF8?
08:20:45 <elliott> mbazs: it's not possible, you can make an alternate version of the Monad typeclass that allows it, but it's quite awkward and ugly, and wouldn't be all that useful
08:20:53 <elliott> even if it does mean we can't e.g. use do notation on Sets and the like
08:21:15 <cmccann> elliott, you'd have to uncurry everything, use a zip-style function instead, and then map over that
08:21:15 <elliott> b0fh_ua: Data.ByteString.UTF8 reuses the underlying strict ByteString type, doesn't it?
08:21:24 <elliott> cmccann: sounds like arrows
08:21:31 <DanBurton> eyebloom: a type variable "escaping its scope" doesn't mean anything conceptually, afaik, because it is an error if it "happens"
08:21:42 <cmccann> that's because Arrow doesn't support currying either
08:21:53 <elliott> cmccann: yeah
08:22:01 <mmos1127> I want to do something like "getDirectoryContents" but I want to get only the sub-directories, or only the files
08:22:09 <eyebloom> What is the error trying to describe?
08:22:38 <elliott> eyebloom: it would be easier to explain what the problem is if you showed the code GHC is complaining about :)
08:22:47 <elliott> I mean, conceptually it means a type variable is escaping its scope.
08:22:50 <cmccann> eyebloom, it means you're doing something confusing and hard to explain probably :P
08:22:54 <elliott> probably you're using existentials or GADTs wrongly
08:23:07 <DanBurton> the error describes a nonsensical situation
08:23:08 <cmccann> you really can't get type variables with a scope to escape doing boring simple things
08:23:18 <yoaha> consolidated - you are doing something wrong
08:23:19 <b0fh_ua> elliott: well, not really
08:23:39 <elliott> b0fh_ua: yes it does, I just checked
08:23:44 <cmccann> DanBurton, it's not really nonsensical
08:23:55 <elliott> b0fh_ua: so just convert lazy -> strict bytestring
08:23:55 <DanBurton> cmccann: then what is it?
08:24:18 <elliott> DanBurton: It's nonsensical in the same way that every possible error GHC outputs is describing a nonsensical situation.
08:24:19 <cmccann> DanBurton, it means that you have a term whose type would be existential
08:24:27 <cmccann> which GHC doesn't support directly
08:24:30 * DanBurton sometimes stabs in the dark and says wrong things so the smart people will correct him >.>
08:24:33 <eyebloom> The solution is to fiddle with type signatures until it works. I understand that. I'm just looking for a translation of the error.
08:24:56 <elliott> b0fh_ua: specifically look at toChunks
08:25:00 <eyebloom> So that I can understand why it continues to arise in my code.
08:25:03 <cmccann> the CPS-style encoding of existentials that we use wraps them via contravariant universal quantification
08:25:05 <elliott> b0fh_ua: and Data.ByteString.concat
08:25:19 <elliott> eyebloom: No, that is not the solution.
08:25:21 <mbazs> OK, thanks for the answers (maybe someone could tell me how to save all of this in irssi:)). My third question is that what on Earth are applicative functors are good for, and what is that thing that says that monads are a developed form of app. functors?
08:25:27 <cmccann> so if you try to smuggle that existential outside of the CPS wrapper GHC gets cranky
08:25:43 <cmccann> mbazs, logs are kept and posted online for this channel
08:25:50 <cmccann> so you don't need to save it yourself if you don't want to
08:25:56 <elliott> eyebloom: We can teach you the actual source of the problem, but if you're looking to learn it's best to use a concrete situation. Otherwise, the explanation will sound exactly like what GHC is telling you, because that's what the conceptual description is.
08:26:09 <mmos1127> I want to do something like "getDirectoryContents" but I want to get only the sub-directories, or only the files
08:26:16 <elliott> mbazs: you can just bookmark http://tunes.org/~nef/logs/haskell/12.02.10 or such
08:26:21 <cmccann> mbazs, check out the bottom of this page: http://tunes.org/~nef/logs/haskell/12.02.10
08:26:27 <elliott> mbazs: for applicative functors, I suggest reading the Typeclassopedia
08:26:36 <mbazs> Thx
08:26:37 <elliott> mbazs: which answers all that question and more far better than could be done on IRC
08:26:41 <elliott> mbazs: http://www.haskell.org/haskellwiki/Typeclassopedia
08:26:46 <mbazs> Oh, sorry.
08:26:56 <elliott> sorry for what? :)
08:27:18 <mbazs> That I asked a question which is written down somewhere else:)
08:27:25 <elliott> it's fine to ask :)
08:27:44 <cmccann> mbazs, popular opinion seems to like this description of Applicative: http://stackoverflow.com/a/3242853/157360
08:28:00 <b0fh_ua> elliott: http://hpaste.org/63399
08:28:16 <monochrom> in fact, in the future, asking is a more valuable skill than answering, since answers are already written down somewhere. to find them, you have to know how to ask
08:28:17 <elliott> b0fh_ua: ok, what's the problem you're having with that code?
08:28:32 <elliott> cmccann: popular opinion indeed :D
08:28:33 <b0fh_ua> it complains that it expects BL.ByteString but actually there is B8.ByteString
08:28:50 <cmccann> elliott, it got me a gold badge a few days ago :P
08:29:06 <monochrom> whereas schools seems to stay at the train-you-to-answer state forever
08:29:12 <elliott> b0fh_ua: what type does ZL.decompress have?
08:29:23 <elliott> also, can you hpaste GHC's exact error?
08:29:30 <b0fh_ua> elliott: http://hackage.haskell.org/packages/archive/zlib/latest/doc/html/Codec-Compression-GZip.html#v:decompress
08:29:42 * cmccann starts training people to go ask monochrom 
08:29:43 <elliott> ok, so it takes and returns a lazy bytestring
08:30:08 <b0fh_ua> elliott: http://hpaste.org/63400
08:30:14 <mbazs> My biggest trouble is that (for example) on RWH it is written down exactly, but I'd need a deeper explanation that _why_ is that something is better than the other one. And this is I cannot really find.
08:30:17 <monochrom> that will be good training because I hold a very high standard on questions
08:31:15 <mmos1127> I want to do something like "getDirectoryContents" but I want to get only the sub-directories, or only the files
08:31:19 <elliott> mbazs: I think LYAH is better at explaining the notions behind the concepts rather than how to use them, but you might find it a bit too beginner-level depending how far on you are
08:31:25 <gergo> Is there any way to not use the else part ot the if sentence?
08:31:26 <eyebloom> I think my code is too messy at this time to go into hpaste.
08:31:51 <monochrom> "what is the best parser library?" 0 marks. "I get a type error, what to do?" (no code or incomplete code) 0 marks.
08:32:11 <elliott> b0fh_ua: ok, that's correct
08:32:15 <elliott> b0fh_ua: your declared type signature is wrong
08:32:19 <elliott> getFeedContent :: Curl -> String -> String -> String -> IO BL.ByteString
08:32:22 * cmccann imagines monochrom as a drill sergeant at "how to ask questions" boot camp
08:32:26 <elliott> BL.ByteString = lazy bytestring, you want B8.ByteString
08:32:45 <Flonk> Is there a way to tell ghci to tell ghci to stop putting stuff to stdout? I mean like lambdabot does, just showing the first couple of characters and then putting a '...'
08:33:01 <Flonk> I'm piping ghci's output to another program, and I could just do it there
08:33:06 <Flonk> But you know, lazyness and everythin
08:33:23 <cmccann> mbazs, for what it's worth my SO post that I linked to above does give some motivation for Applicative, maybe that would help you
08:33:32 <DanBurton> monochrom: asking is easy, as long as you ask lambdabot about what Haskell can do :)
08:33:36 <Flonk> Maybe overwrite putStr in a fancy way or something?
08:33:40 <monochrom> haha
08:33:50 <mbazs> elliott: Yes, I've attended LYAH, but it seemed a bit hard to me:) RWH seemed easier.
08:33:58 <eyebloom> monochrom: right but the question is really, what does this mean, or what's another way of saying this. not neccessarily what to do. That's really asking - where to look.
08:33:58 <kniu> @pl \x y -> f x y
08:33:58 <lambdabot> f
08:34:14 <elliott> mbazs: Really? LYAH is much easier to follow than RWH, IMO.
08:34:15 <kniu> @pl \x y -> f x (g y)
08:34:16 <lambdabot> (. g) . f
08:34:28 <elliott> mbazs: In fact I'd say, if you find RWH easier, that mgiht be why you aren't getting the deeper explanations you desire.
08:34:28 <DanBurton> @faq can Haskell solve world hunger, create world peace, and cure cancer? Also, make delicious waffles?
08:34:28 <lambdabot> The answer is: Yes! Haskell can do that.
08:34:43 <elliott> Flonk: instead of writing the expression `e`, write the expression `putStrLn . take 100 . show $ e` or such
08:34:48 <DanBurton> That Mr. Curry is a talented dead man.
08:34:53 <monochrom> eyebloom: wording the question to hide your real question also gets 0 marks
08:34:55 <elliott> (for pure values, IO actions will need `e >>= putStrLn . take 100 . show`)
08:34:55 <mbazs> cmccann: Thanks!
08:35:08 * hackagebot copilot-language 0.5 - A Haskell-embedded DSL for monitoring hard real-time  distributed systems.  http://hackage.haskell.org/package/copilot-language-0.5 (LeePike)
08:35:38 <Flonk> elliott: It's a bot, and now some people just spam it with '!haskell take 9001 (cycle "PENIS! ")'
08:36:00 <Flonk> elliott: I could take away their rights, but the first option is more preferrable :)
08:36:04 <monochrom> if you want to know where to look, you write "where to look", verbatim.
08:36:37 <Flonk> elliott: derp! I know what you mean
08:36:41 <kallisti> anyone familiar with HXT?
08:36:52 <Flonk> elliott: Just append that to every expression
08:36:52 <donri> somewhat
08:36:54 <mbazs> All in all, may I ask that how many of years have you spent to get here?
08:37:02 <elliott> Flonk: pretty much (although be careful about parens and such)
08:37:13 <elliott> Flonk: but, why not handle it in your bot layer?
08:37:14 <eyebloom> I don't think "What does this mean." is attempting to reword or hide anything. I'm not sure what you are driving at.
08:37:19 <monochrom> if you don't know what you want, that's also 0 marks. asking a good question relies on firstly knowing what you want.
08:37:19 <elliott> just only read a certain number of bytes from GHC, or such
08:37:25 <elliott> hmm, I guess that isn't practical with hint
08:37:31 <kallisti> donri: if I've selected a title element, does getText grab the text inside or is the text treated as a child node distinct from the title element?
08:37:43 <cmccann> monochrom, where do I look to find out what I want to look for?
08:37:56 <monochrom> search engines
08:37:57 <Flonk> elliott: Because I think ghci would still evaluate the whole thing
08:38:07 <elliott> eyebloom: If you want the true meaning behind it devoid of context, then GHC has already told you that. If you want some insight into what the problem is and how to fix it beyond just shuffling type signatures, show us some example code where you don't understand the source of that error.
08:38:13 <elliott> Flonk: right
08:38:38 <donri> kallisti: i'm doing exactly that here https://github.com/dag/kibr/blob/master/src/Test/Kibr/Http.hs#L36
08:38:47 <DanBurton> monochrom: knowing what you want and knowing what you need are to very different things, though. Most people want their code to magically work, but they don't know what they need to accomplish such.
08:39:01 <Flonk> elliott: That take 100 thing sounds like a plan though, thanks!
08:39:06 <kallisti> donri: ah so the text node is treated seperately
08:39:07 <cmccann> @faq is Haskell what I need to make my code magically work?
08:39:08 <lambdabot> The answer is: Yes! Haskell can do that.
08:39:12 <monochrom> oh, sure, knowing what you want is just a necessary condition
08:39:13 <mmos1127> I want to do something like "getDirectoryContents" but I want to get only the sub-directories, or only the files
08:39:15 <cmccann> DanBurton, problem solved
08:39:23 <DanBurton> unsafePerformMagic
08:39:30 <monochrom> "how do I solve math problems?" 0 marks.
08:40:00 <elliott> mmos1127: Run it, then filter out the entries that don't meet your desired criteria?
08:40:30 <dylukes> quicksilver: what'dya mean without really understanding it
08:41:40 <mmos1127> elliott: I'm not sure how to determine that, looking at the return values of getDirectoryContents. E.g. "foo" could be a file named foo, or a directory named "foo". There is a way to run another IO computation-- doesFileExist and doesDirectoryExist -- as a test. But that feels like a hack.
08:42:00 <DanBurton> Haskell should have a macro like coq's eauto that automagically finishes whatever you were doing in the "obvious" way.
08:42:10 <cmccann> djinn? :P
08:42:15 <Paste> www.paste.co.il
08:42:49 * DanBurton muses about the possibility of integrating djinn with Template Haskell
08:42:59 <cmccann> DanBurton, I've done that
08:43:08 <DanBurton> cmccann: links or it didn't happen
08:43:11 <cmccann> the main problem is getting the type
08:43:16 <hpaste> eyebloom pasted “Scope escaping.” at http://hpaste.org/63401
08:43:29 <cmccann> DanBurton, it was a gimmicky hack, not worth using
08:43:36 <cmccann> it only worked in very limited circumstances
08:43:38 <DanBurton> cmccann: aw
08:43:51 <ovechkin> how do you convert a Num to a list of Nums?
08:44:12 <ovechkin> i essentially want 1234 => [1,2,3,4]
08:44:46 <cmccann> DanBurton, it let me write things like "class Functor Foo where fmap = $(magic)"
08:44:49 <DanBurton> ovechkin: can we assume Integral instead of Num?
08:44:51 <donri> > map read $ show 1234
08:44:52 <lambdabot>   Couldn't match expected type `[GHC.Types.Char]'
08:44:52 <lambdabot>         against inferred ty...
08:44:56 <DanBurton> ovechkin: or do we have to deal with decimals
08:45:01 <cmccann> and then the splice would find the type of its context, use djinn to conjure up a term, and provide that
08:45:09 <ovechkin> DanBurton: we can assume integral
08:45:10 <alpounet> hint: 1234 = 1 * 10^3 + 2 * 10^2 + 3 * 10^1 + 4 * 10^0
08:45:14 <tromp__> > "1234" >>= digitToInt
08:45:15 <lambdabot>   Couldn't match expected type `[b]'
08:45:15 <lambdabot>         against inferred type `GHC.Types...
08:45:21 <cmccann> DanBurton, but it relied on it being very easy to find out what type was needed
08:45:26 <DanBurton> > map digitToInt "1234"
08:45:26 <donri> > map (read . (:[])) $ show 1234
08:45:27 <lambdabot>   [1,2,3,4]
08:45:27 <lambdabot>   can't find file: L.hs
08:45:42 <DanBurton> lambdabot forgets where L.hs is sometimes... o_O
08:45:45 <mbazs> [x | x<-[1..], x `mod` 2/=0]
08:46:15 <MostAwesomeDude> > (map digitToInt) . show $ 1234
08:46:16 <lambdabot>   [1,2,3,4]
08:46:31 <elliott> did Paste just spam a /pastebin/?
08:46:37 <donri> those parens don't do nothing methinks
08:46:42 <monochrom> "1234 = 1 * 10^3 + 2 * 10^2 + 3 * 10^1 + 4 * 10^0" is a less useful hint than "1234 = 123*10 + 4"
08:46:50 <DanBurton> @let intToDigList :: Integral a => a -> [Int]; intToDigList = map digitToInt . show;
08:46:51 <lambdabot>  Defined.
08:46:57 <DanBurton> > intToDigList 1234
08:46:59 <lambdabot>   [1,2,3,4]
08:47:01 <DanBurton> ta-da
08:47:13 <MostAwesomeDude> I always over-parenthesize. It's like my tragic flaw.
08:47:19 <donri> @hoogle digitToInt
08:47:19 <MostAwesomeDude> Or is that a pathetic flaw?
08:47:19 <lambdabot> Data.Char digitToInt :: Char -> Int
08:47:30 <MostAwesomeDude> Maybe it's a parenthetic flaw. :3
08:47:36 <DanBurton> MostAwesomeDude: try Lisp? :)
08:47:49 <donri> maybe you have paren[t]s issues
08:47:49 <alpounet> monochrom, nah, just the unrolled version
08:48:08 <cmccann> MostAwesomeDude, it's a (tragic) flaw (I guess)
08:48:21 <monochrom> the last thing you want is the complete unrolling
08:48:25 * DanBurton was under-parenthesized as a child...
08:48:29 <tromp__> > show 1234 >>= return . digitToInt
08:48:31 <lambdabot>   [1,2,3,4]
08:49:16 <elliott> :t bool
08:49:17 <lambdabot> Not in scope: `bool'
08:49:18 <elliott> :t if'
08:49:19 <lambdabot> Not in scope: `if''
08:49:21 <elliott> hmph
08:49:21 <elliott> > if'
08:49:22 <lambdabot>   Not in scope: `if''
08:49:25 <elliott> huh
08:49:31 <mbazs> :i Monad
08:49:57 <DanBurton> tromp__: "foo >>= return . bar" is discouraged, hlint suggests "fmap bar foo" instead
08:50:00 <elliott> mbazs: do you mean @src?
08:50:02 <elliott> :info is ghci-only
08:50:02 <monochrom> "123*10 + 4" suggests a very specific recursion scheme: get the 4, now recurse to process 123. the complete unrolling "1 * 10^3 + 2 * 10^2 + 3 * 10^1 + 4 * 10^0" requires the reader to reverse-engineer the recursion scheme
08:50:03 <cmccann> DanBurton, if you really want I can dig the code up later but it's not really worth much
08:50:04 <elliott> @src Monad
08:50:05 <lambdabot> class  Monad m  where
08:50:05 <lambdabot>     (>>=)       :: forall a b. m a -> (a -> m b) -> m b
08:50:05 <lambdabot>     (>>)        :: forall a b. m a -> m b -> m b
08:50:05 <lambdabot>     return      :: a -> m a
08:50:05 <lambdabot>     fail        :: String -> m a
08:50:26 <DanBurton> cmccann: you should blog about it
08:50:27 <mbazs> Ahh :)
08:50:38 <cmccann> DanBurton, I should have a blog to begin with probably
08:50:45 <tromp__> right DanBurton, i was trying to be obscure:)
08:50:56 <DanBurton> tromp__: -___-
08:51:05 <DanBurton> cmccann: -___-
08:51:10 <DanBurton> :)
08:51:44 <DanBurton> cmccann: I started a "blog" as a github repo with literate haskell files. Well, one so far...
08:52:40 <ovechkin> DanBurton: i'm really new to haskell. is digitToInt defined in Prelude?
08:52:51 <DanBurton> ovechkin: I think it's in Data.Char
08:52:54 <cmccann> DanBurton, I wanted to do more with the code but hit an obstacle that I wasn't really up for tackling
08:52:54 <DanBurton> @hoogle digitToInt
08:52:55 <lambdabot> Data.Char digitToInt :: Char -> Int
08:53:03 <ovechkin> thanks
08:53:11 <Mike____> Hello, was wondering if I could get some help on the output of a structure in haskell
08:53:20 <merijn> > digitToInt 'a'
08:53:21 <lambdabot>   10
08:53:25 <merijn> > digitToInt '1'
08:53:26 <lambdabot>   1
08:53:34 <merijn> > digitToInt 'z'
08:53:35 <lambdabot>   *Exception: Char.digitToInt: not a digit 'z'
08:53:46 <DanBurton> cmccann: so put it on github with --TODO and maybe The Internet will fix it for you
08:53:46 <cmccann> DanBurton, specifically, that the only way to get the type of an expression in general seems to be asking GHC
08:53:57 <mbazs> Can someone show me an example in C++ which describes 'forall'? Is 'forall' is like a C++ template type parameter of a template, or is it like a template member function?
08:54:04 <cmccann> and apparently GHC really doesn't like it when you try to use the GHC API from a TH splice
08:54:23 <elliott> cmccann: fork a subprogram :P
08:54:42 * DanBurton thinks a comparison to C++ would only confuse the matter
08:54:47 <Mike____> I have a Rubik cube structure defined, and I can't seem to make a function to output each side of the cube, can anyone help me please?
08:54:47 <learning> is this the right place to ask for Haskell homework help?
08:54:58 <alpounet> monochrom, i don't necessarily think that's bad though
08:55:02 <DanBurton> learning: sure
08:55:04 <elliott> mbazs: It's nothing like any of those.
08:55:04 <merijn> Mike____: As in print to string?
08:55:11 <sclv> mike: what type do you want your function to have?
08:55:13 <neutrino> hi
08:55:18 <learning> cool
08:55:29 <merijn> learning: For asking questions when you don't understand things, yes. For asking for a solution to your problem, no.
08:55:30 <Mike____> Yes, I think that would be the best option.
08:55:33 <mbazs> elliott: Then what it's like? :(
08:55:40 <neutrino> i am having problems, i believe in readFile, i get this error: hGetContents: invalid argument (Invalid or incomplete multibyte or wide character)
08:55:47 <elliott> mbazs: It's like nothing but itself.
08:55:50 <neutrino> can someone please help me iron it out?
08:55:52 <Mike____> I have each side of the cube identified with a number, from 0 to 5.
08:55:57 <cmccann> elliott, yes, that was one obvious approach, but for something that was mostly an experimental hack to see how well it works that increased the hassle level just a shade too much
08:56:03 <elliott> mbazs: Note that in normal type declarations, there is actually an implicit "forall". That may help.
08:56:08 <elliott> mbazs: For instance, `map :: (a -> b) -> [a] -> [b]`
08:56:17 <elliott> map actually has the type `map :: forall a b. (a -> b) -> [a] -> [b]`
08:56:22 <mbazs> elliott: Yep, I know that
08:56:24 <DanBurton> neutrino, learning: if you have code you want us to review, the recommended way to show us is http://hpaste.org/new/haskell
08:56:29 <elliott> You can simply read it as "For all types a and b, map has the type ..."
08:56:41 <Botje> or a commit to GHC HEAD ;)
08:56:56 <neutrino> DanBurton: 1 sec, let me upload it for you
08:57:13 <monochrom> at every point you write "template <class T>", you add a forall there
08:57:33 <hpaste> neutrino pasted “mysqlsla-plotter” at http://hpaste.org/63403
08:57:33 <Mike____> I don't really want to paste the whole structure here, it's too much text, Would it be possible to pm someone to get some help with this?
08:57:42 <merijn> Mike____: hpaste.org
08:57:48 <mbazs> monochrom: And when I write template< template<..>  > then what it's like in Haskell?
08:58:05 <monochrom> I haven't seen that, I don't know what it means
08:58:09 <hpaste> Mike pasted “Rubik's Cube” at http://hpaste.org/63404
08:58:10 <neutrino> i am happy that the hpaste bot is back
08:58:19 <salisbury> does anyone know how to pass ghc options to haskell-mode in emacs
08:58:21 <learning> DanBurton: Okay, thanks. I just wanted to check for now. Seems to be a pretty active room. I will be back later when i get stuck with my homework.
08:58:25 <Mike____> http://hpaste.org/63404
08:58:39 <neutrino> DanBurton: this script parses a log file with parsec. if the file has a "bad" character then the program breaks.
08:58:46 <Mike____> ok, I was trying to use the function MostraCubo to show the cube sides
08:58:51 <elliott> neutrino: bad = not in the correct encoding, most likely.
08:58:54 <Mike____> but, I can0t even do a simple putStr
08:58:54 <mbazs> monochrom: When a template gets another template for a type parameter. Is this maybe like the Rank2 in Haskell?
08:58:57 <cmccann> learning, Stack Overflow is also an excellent resource for getting elliott to answer your questions
08:59:09 <elliott> cmccann: :(
08:59:23 <merijn> Mike____: You probably want to create a Show instance for Cubo
08:59:26 <merijn> :t show
08:59:27 <lambdabot> forall a. (Show a) => a -> String
08:59:30 <elliott> learning: Stack Overflow is also an excellent resource for getting cmccann to answer your questions.
08:59:49 <sclv> well, for a side at a time first.
08:59:52 <sclv> so just for a face
08:59:53 <merijn> Mike____: putStr expects a string, so you need a "Cubo -> String" function
08:59:58 <monochrom> I still don't know. do not hope that a C++ feature can be explained from scratch in 100 words or less.
09:00:04 <Mike____> mrijn, you that is it, the instance I was trying to create is nammed mostraCubo :: Cubo -> Cor
09:00:09 <Mike____> oh
09:00:21 <Mike____> ok, but i definned type Cor = String
09:00:28 <Mike____> and Cor is of the type String
09:00:37 <elliott> Cor isn't of the type String, it _is_ the type String.
09:00:49 <merijn> Mike____: Ok, but what should it print?
09:00:58 <monochrom> either I have to spend an hour investigating its semantics, or I don't know. there is nothing in-between.
09:00:59 <mbazs> monochrom: OK :)
09:01:14 <ovechkin> DanBurton: that was a pretty awesome solution. thank you
09:01:16 <merijn> You have a cube defined, when I print "monstraCubo dados" what result do you expect?
09:01:41 <Mike____> each cor for the cube. The cor the the vallue ex. "Am", and it's a string. so, if i define this mostraCubo :: Cubo -> Cor it sohuld be correct right?
09:01:41 <DanBurton> neutrino: right, that's quite a lot of code. Make another little .hs file and try to replicate the problem with as little code as possible
09:01:55 <sclv> showFace (_,a,b,c,a1,b1,c1,a2,b2,c2) = intercalate " " [fst a, fst b, fst c] ++ "\n" ++ intercalate " " [fst a1, fst b2...
09:02:34 <rwbarton> intercalate " " is also known as unwords
09:02:36 <Mike____> seperated by faces, eg. I want to print a rubik cube. The first side on top, 4 sides bellow it, and the bottom side, bellow those ones
09:02:43 <neutrino> DanBurton: i traced it down to the file containing a 0xb5 character
09:03:45 <Mike____> oh
09:04:12 <cmccann> elliott, you're what, #15 for rep gain this year on Stack Overflow as a whole? :P
09:04:27 <elliott> cmccann: It's not my fault people keep upvoting me!
09:05:28 <monochrom> struct Wh { template <class T> int ho(T); }  -->  data Wh = Wh{ ho :: forall t. t -> Int }
09:05:29 <DanBurton> bwahaha * upvotes elliott's entire history *
09:05:37 <Mike____> showFace :: Face -> String isn't this correct for what you showed me rwbarton
09:05:48 <cmccann> DanBurton, that's a good way to get the votes canceled :P
09:06:00 <DanBurton> lol
09:06:43 <elliott> monochrom: Is that true?
09:06:52 <elliott> monochrom: I believe ho can do special things depending on the choice of T.
09:06:54 <elliott> in C++
09:07:10 <hpaste> ovechkin pasted “Rn” at http://hpaste.org/63405
09:07:23 <ovechkin> DanBurton: would you mind taking a look at that?
09:07:28 * cmccann is actually surprised elliott hasn't gotten the epic badge yet
09:08:10 <monochrom> well yeah, I'm just translating types, not preserving semantics such as referential transparency or parametricity or strictness
09:08:33 <hpaste> Mike pasted “Rubik's Cube” at http://hpaste.org/63406
09:08:48 <Mike____> what would 21:40: Error: Use unwords mean?
09:08:58 <elliott> Mike____: that sounds like hlint
09:08:59 <sclv> its a suggestion
09:09:01 <elliott> hpaste gives you code suggestions
09:09:03 <elliott> "Error" is misleading
09:09:11 <elliott> Mike____: click the note to expand it
09:09:11 <sclv> intercalate " " is equiv to the `unwords` function
09:09:15 <elliott> it'll show your code and what it suggests you use instead
09:09:21 <cmccann> elliott, ah, looks like you're only a few days shy of getting the epic badge
09:09:22 <Mike____> ok
09:09:26 <Mike____> Found:   intercalate " " Why not:   unwords
09:09:34 <elliott> cmccann: oh dear
09:09:58 <sclv> it should really be: unwords [stuff] ++ "\n" ++ unwords [stuff] ++ "\n" ++ unwords[stuff]
09:10:01 <DanBurton> ovechkin: looks ok to me. is something wrong?
09:10:08 * hackagebot factual-api 0.1.2 - A driver for the Factual API  http://hackage.haskell.org/package/factual-api-0.1.2 (RudigerLippert)
09:10:14 <monochrom> struct Wh is probably the easiest way to achieve rank-2 types.  ber :: (forall t. t->Int) -> Double  -->  double ber(Wh), although you can also do ber :: Wh -> Double in haskell
09:10:15 <sclv> which you can do as unlines[unwords[stuff],unwords[stuff],unwords[stuff]]
09:10:18 <elliott> sclv: which should be unlines [unwords [...], ...] :P
09:10:32 <sclv> stereo, etc.
09:10:34 <cmccann> elliott, you're certainly much closer to it than I am >:[
09:10:40 <Mike____> god, this is so complex -.-
09:10:48 <donri> which should be replicate 3 ...?
09:10:49 <tgeeky> @type Complex
09:10:50 <lambdabot> Not in scope: data constructor `Complex'
09:10:51 <ovechkin> DanBurton: is the question flawed? i don't see how one can find an n where Rn equals 8001.
09:10:52 <Mike____> I made it so easily in C
09:11:01 <tgeeky> @type C
09:11:02 <lambdabot> Not in scope: data constructor `C'
09:11:05 <sclv> nah -- its simple, its just that there's lots of helper functions that make it even simpler once you know what they are
09:11:05 <tgeeky> bah. liar!
09:11:22 <ovechkin> DanBurton: err nvm. im thinking about it wrong
09:11:46 <elliott> cmccann: I'm sure learning's questions will help you on the way to it :D
09:11:47 <sclv> what does the Alteracoes represent in the Quadricula btw?
09:12:11 <mstsc> selling dedicated servers in different countries, only windows xp,2003,2008, seven
09:12:21 <cmccann> elliott, probably not because you'll answer all of them in like 3 minutes after they're posted :T
09:12:36 <hpaste> Mike pasted “Rubik's Cube” at http://hpaste.org/63407
09:12:41 <tgeeky> that was a quick join/spam/quit.
09:12:54 <Mike____> ok.. now i get another error...
09:13:14 <Mike____> couldn't match expected type
09:13:17 <sclv> mike -- you need to read and think and look at the types, not just copy and paste.
09:13:23 <sclv> :t unwords
09:13:24 <elliott> cmccann: hey, I took a break today! :P
09:13:24 <lambdabot> [String] -> String
09:13:24 <Mike____> yeah
09:13:30 <Mike____> I guess I know what is bad
09:13:35 <elliott> everyone else just types too slow
09:13:38 <sclv> :t unlines
09:13:38 <Mike____> but i just dont know the correct way to fix it
09:13:39 <lambdabot> [String] -> String
09:13:46 <sclv> so both unwords and unlines join text together.
09:13:55 <sclv> the former with spaces, the latter with newlines.
09:14:05 <sclv> each takes a list of strings, and produces a single string.
09:14:11 <cmccann> elliott, I just got tired of the quick-draw-then-edit nonsense
09:14:14 <sclv> that should be enough for you to think through how to write what you want
09:14:23 <aristid> @src unwords
09:14:23 <lambdabot> unwords [] = ""
09:14:24 <lambdabot> unwords ws = foldr1 (\w s -> w ++ ' ':s) ws
09:14:32 <Mike____> ok, but i think the problem is not there. The problem might be accessing my structure
09:14:44 <elliott> cmccann: I try to avoid doing that but it's so tempting :(
09:15:18 <Mike____> i have this: (_,a,b,c... and my structure is like this: [([(0,("Am",0),("Am",0),...
09:15:21 <cmccann> elliott, there's nothing wrong with it really
09:15:23 <Mike____> a corresponds to 0
09:15:25 <Mike____> i mean
09:15:35 <Mike____> _ = 0, a = ("Am",0)
09:15:46 <Mike____> so, i need to get the string "Am" into a
09:15:58 <sclv> huh?
09:16:23 <sclv> > fst (1,"a")
09:16:24 <lambdabot>   1
09:16:34 <Mike____> when i Say fst a, what does it mean?
09:16:38 <sclv> :t fst
09:16:39 <lambdabot> forall a b. (a, b) -> a
09:16:44 <sclv> get the first thing from a pair
09:16:48 <Mike____> hmm
09:16:49 <sclv> :t snd
09:16:49 <Mike____> ok
09:16:49 <lambdabot> forall a b. (a, b) -> b
09:17:29 <Mike____> Ok
09:17:35 <cmccann> elliott, so how often does your RSS reader check for new questions, anyway :D
09:17:44 <Mike____> I guess my problem is getting the structure into the function
09:17:46 <elliott> hahaha
09:17:52 <elliott> I actually just check manually whenever I have a few minutes free
09:18:02 <cmccann> pf
09:18:21 <sclv> Mike: pattern matching
09:18:35 * cmccann actually has a feed reader that checks every 5min or so and just ignores it if he's busy
09:18:35 * elliott adjusts script rate in the background, starts training the Markov answer generator on highly-voted past answers
09:18:39 <sclv> > let foo (a,b,c) = c in foo (1,2,3)
09:18:40 <lambdabot>   3
09:18:48 * elliott prepares sockpuppets to answer another ten easy questions
09:18:48 <sclv> see! you can define your own extractors
09:18:53 <elliott> *ask
09:18:56 <sclv> > let foo (a,b,c) = a + b + c in foo (1,2,3)
09:18:57 <lambdabot>   6
09:23:58 <hacklash> I'm getting a parse error I don't understand: "76:10: parse error on input `|'  ". http://hpaste.org/63408
09:24:22 <donri> hacklash: you have "date" where you mean "data"
09:24:25 <Mike____> god this is so hard -.-
09:25:07 <donri> hacklash: the confusing error message is a result of it being read as a function definition
09:25:08 <hacklash> donri: lol, thx
09:25:30 <hacklash> that's what I get for writing the program big bang style
09:25:49 <Sgeo> big bang style?
09:26:32 <Mike____> what does this meen: Couldn't match expected type 'Char' with actual type 'Collor'
09:26:42 <elliott> it means it couldn't match the type it expected, Char, with the actual type, Collor.
09:26:52 <Mike____> But collor is a String
09:26:57 <elliott> Char is not String
09:27:00 <elliott> String is [Char]
09:27:04 <Mike____> oh
09:27:11 <Mike____> so, when i use fst a
09:27:16 <Mike____> i should use fst [a] ?
09:27:36 <cmccann> Mike____, you might want to stop and spend some time with a Haskell introduction or tutorial
09:27:38 <Mike____> i used fst to fetch me a string with 2 chars
09:27:47 <cmccann> you seem to have a lot of confusion on the basics
09:27:48 <Sgeo> fst doesn't do lists
09:27:52 <Mike____> yeah, i do
09:27:53 <Mike____> -.-
09:28:05 <cmccann> trial and error like this is not going to help you learn, I suspect
09:28:34 <elliott> yes, I would suggest a deeper read of your favourite haskell tutorial :P
09:28:42 <cmccann> Mike____, what sort of learning materials have you looked at?
09:28:42 <elliott> fst operates on tuples, for a start.
09:28:44 <Mike____> seems like every single line i code, i get an error...
09:28:47 <Mike____> its so so annoying
09:28:54 <kallisti> anyone know of a hash function for Text lying around?
09:29:13 <Mike____> school classes, and that's it.. and i have exercices solved in classes
09:29:13 <elliott> kallisti: encode to bytestring, hash that
09:29:20 <kallisti> converting to String so I can use hashString from Data.HashTable seems bad.
09:29:24 <elliott> Mike____: I would strongly recommend Learn You a Haskell.
09:29:31 <elliott> Mike____: You'll find your error-per-line rate decreases drastically :P
09:29:32 <cmccann> Mike____, isn't there a textbook or something?
09:29:32 <Mike____> ok
09:29:43 <elliott> http://learnyouahaskell.com/
09:29:44 <cmccann> either way, yes, LYAH is a good place to start
09:29:57 <Sgeo> Does LYAH even touch language extensions?
09:29:58 <kallisti> elliott: what about converting to String and using hashString?
09:30:01 <elliott> (Nobody tell Mike____ that the error-per-line rate goes right back up once you reach a certain experience level.)
09:30:06 <Mike____> sigh, hope i can learn untill thuesday
09:30:11 <elliott> kallisti: That would work, and almost certainly be slower.
09:30:25 <elliott> Mike____: It'll probably take longer than that. But you should be able to get the basics down.
09:30:53 <Mike____> i really really hope not
09:30:54 <kallisti> elliott: hrm. I think I'll just borrow the algorithm used in hashString and rewrite it for Text.
09:31:20 <elliott> Mike____: You can't learn any language in 21 days, let alone 4.
09:31:22 <Mike____> Thanks anyway
09:31:45 <elliott> Haskell is further from the mainstream than most languages, so it takes even longer.
09:32:04 <Mike____> yeah.... that's the problem. C seems so easy
09:32:09 <kallisti> elliott: you forgot to put ", man" at the end of that sentence. :>
09:32:16 <Mike____> i did a work for school in c very easilly
09:32:21 <Mike____> and now, gotta do it in haskell, and its so hard
09:32:29 <elliott> That just means you're more familiar with C.
09:32:31 <kallisti> tABLE_MAX :: Int32
09:32:36 <kallisti> wow Data.HashTable
09:32:46 <elliott> Many students will be complaining about how difficult coding in C is this second :P
09:32:48 <Mike____> Thanks elliott
09:32:49 <Sgeo> I suppose I should refrain from commenting on other good languages that are easy to learn, especially if they are the polar opposite of Haskell
09:32:51 <cmccann> also, I guarantee that doing anything other than schoolwork in C is much, much harder than doing it in Haskell
09:32:54 <elliott> kallisti: tHAT_STYLE_IS_COMMON_IN_BASE
09:32:58 <kallisti> nooooo why
09:32:59 <Azel> Mike____: If your mind have an imperative bent...for a mathamatically minded person, Haskell is easier
09:33:15 <kallisti> justDoSomethingLikeThisIDunnoEverythingIsConstantWhyMakeTheDistinction
09:33:18 <elliott> kallisti: Which Data.HashTable are you using?
09:33:23 <kallisti> the one in base.
09:33:25 <elliott> If you want mutable hash tables, use http://hackage.haskell.org/package/hashtables.
09:33:36 <elliott> But you probably don't want mutable hash tables; use unordered-containers.
09:33:36 <kallisti> I was under the impression that the one in base was mutable.
09:33:39 <elliott> Yes, it is.
09:33:44 <elliott> It isn't very good.
09:33:48 <cmccann> augh, inverted caps like that is the most painful thing ever to read, why would anyone even do that
09:34:00 <elliott> cmccann: iDON'T_SEE_THE_PROBLEM
09:34:06 <elliott> wHAT'S_WRONG
09:34:17 <rwbarton> iT'S_FOR things that would be written LIKE_THIS in C
09:34:18 <cmccann> oH GOD STOP i CAN'T TAKE THIS
09:34:25 <rwbarton> aS_I'M_SURE_YOU_KNOW
09:34:34 <neutrino> i've been wondering last month whether there are any languages that use this cap style
09:34:38 <elliott> cMCCANN_YOU_FORGOT_THE_UNDERSCORES
09:34:49 <elliott> kallisti: Why do you want a mutable hash table?
09:34:59 <cmccann> pf
09:35:02 <kallisti> elliott: my rationale for using a hash table is basically that due to FFI shenanigans I'm already pretty much using IO everywhere. I realize this is probably not much of a reason at all.
09:35:05 <cmccann> you capitalized my name wrong
09:35:07 <cmccann> I quit
09:35:52 <elliott> kallisti: If you want efficiency, use the hashtables package. Otherwise, use unordered-containers. You will benefit from sharing.
09:35:59 <elliott> You can put it in an MVar if you want.
09:36:16 <kallisti> elliott: does that even do anything helpful? :P
09:36:22 <kallisti> mutability for the sake of mutability?
09:36:23 <hacklash> Sgeo: without ever trying to run the program until it was finished
09:36:47 <kallisti> elliott: why unordered-containers over, say, Map.
09:36:53 <kallisti> I'm using string keys so I have an ordering.
09:37:03 <elliott> kallisti: It's faster.
09:37:15 * cmccann wonders if a trie would be better given string keys
09:37:17 <elliott> Map is a pretty lame structure.
09:37:23 <sclv> on average -- map still wins on worst-case
09:37:32 <hpc> i_DONT_SEE_THE_PROBLEM_IT'S_HOW_YOU_NAME_CONSTANTS_IN_HASKELL
09:37:37 <elliott> kallisti: Also, Map String is awful.
09:37:42 <kallisti> yes.
09:37:42 <elliott> Since you'll be comparing whole strings a lot.
09:37:50 <kallisti> well, it would be Map Text now.
09:37:53 <kallisti> but same thing I imagine.
09:38:01 <elliott> cmccann: There are a few trie map packages on Hackage. I gather they're faster than Data.Map.
09:38:11 <elliott> kallisti: unordered-containers uses hashing, so it avoids that.
09:38:12 <cmccann> they're different
09:38:18 <elliott> cmccann: For String keys.
09:38:35 <rwbarton> let me get out my 1114112-ary tree data structure real quick
09:38:47 <kallisti> oh nice there's a Hashable instance for Text.
09:38:57 <cmccann> elliott, it amounts to radix sorting vs. comparison sorting
09:39:01 <sclv> You have a problem and think "I'll use a hash function." Now you have intermittantly colliding problems.
09:39:12 <elliott> @remember sclv You have a problem and think "I'll use a hash function." Now you have intermittantly colliding problems.
09:39:13 <lambdabot> Nice!
09:39:21 <elliott> (n.b. HashMap is not a hash table)
09:39:25 <elliott> cmccann: Right.
09:39:34 <elliott> cmccann: Map is pretty pessimal as far as list keys go, though.
09:39:43 <cmccann> yes
09:39:59 <cmccann> for pretty much the same reasons that tries work well
09:40:10 <cmccann> so I would expect that all else equal a trie should be faster :P
09:41:35 <cmccann> on the other hand, tries have nice bonus features that can be handy at times
09:42:18 <DanBurton> How exactly does one use, for example, Data.Derive.Arbitrary in order to derive Arbitrary for some type? http://hackage.haskell.org/packages/archive/derive/2.5.5/doc/html/Data-Derive-Arbitrary.html
09:42:20 <kallisti> oh look, I basically have to change nothing in my code to use hashtables.
09:42:29 <kallisti> how nice.
09:42:41 <elliott> DanBurton: people still use derive?
09:42:55 <kallisti> elliott: real programmers write Eq instances by hand.
09:43:03 <elliott> DanBurton: but, see http://community.haskell.org/~ndm/darcs/derive/derive.htm
09:43:06 <elliott> kallisti: Not that derive.
09:43:12 <elliott> That's deriving.
09:43:20 <rwbarton> DanBurton: see http://hackage.haskell.org/packages/archive/derive/2.5.5/doc/html/Data-DeriveTH.html
09:44:19 <DanBurton> well, what is the recommended way to derive Arbitrary, then?
09:44:41 <rwbarton> just like that
09:44:53 <DanBurton> mmk
09:44:54 <rwbarton> $( derive makeArbitrary ''Whatever )
09:45:12 <DanBurton> that only needs the TemplateHaskell language pragma, correct?
09:45:12 <rwbarton> I think you don't need the $() any more
09:45:14 <rwbarton> yeah
09:45:33 <kallisti> hackage docs are kind of confusing when they use types with the exact same names but defined in different packages without qualifying them
09:45:37 * cmccann tends to use $() anyway to make it easier to scan the code and see what's what
09:45:54 <cmccann> kallisti, I think you mean haddock is confusing in how it displays that :P
09:46:27 <rwbarton> foo :: C a => T -> T a
09:46:49 <kallisti> for example in Data.HashTable.IO it simply uses "HashTable" within the type aliases for LinearHashTable, CuckooHashTable, etc; despite the fact that each of the "HashTable"s mentioned are defined in different modules
09:46:50 <cmccann> rwbarton, is that the Henning.T school of naming?
09:46:57 <rwbarton> yes
09:47:09 <Sgeo> It's weird seeing ST twice everywhere
09:47:11 <kofron> hi all, i'm a relative newcomer to haskell trying to understand how i might implement a long polling client
09:47:37 <elliott> Sgeo: ?
09:47:40 <kofron> specifically i am listening to a _changes feed from couchdb and i'd like to use it as a message passing architecture
09:47:58 <Sgeo> elliott, in Haddock pages that make ST instances of stuff
09:48:08 <cmccann> kofron, to a first order of approximation the same way you'd do it in many other languages
09:48:34 <cmccann> kofron, what are you looking for, just a place to start or some more specific question?
09:49:10 <kofron> i'm listening to the _changes feed from a couchdb server
09:49:20 <elliott> you said :P
09:49:29 <kofron> when a change is made to a database that we're using as a message passing interface, i want to trap that event in haskell and dispatch it to a method that will do some work
09:50:02 <kofron> so i guess to answer your question, a little of both
09:50:22 <neutrino> hey guys is there a function which takes a list of pairs, and groups them by the fst?
09:50:30 <cmccann> :t groupBy
09:50:31 <lambdabot> forall a. (a -> a -> Bool) -> [a] -> [[a]]
09:50:46 <neutrino> splendid, thanks
09:50:48 <elliott> kofron: there's no "methods" in haskell (well, there are, but they're not that)
09:51:02 <elliott> in general, callback-based programming isn't very popular in Haskell (we tend to use Chans instead), but you can certainly do it
09:51:06 <elliott> what do you need help with?
09:51:07 <cmccann> kofron, I'm a little unclear on where the Haskell will be running and which parts are it vs. things it communicates with
09:51:12 <neutrino> @pl \x y -> (fst x = fst y)
09:51:12 <lambdabot> (line 1, column 16):
09:51:13 <lambdabot> unexpected "="
09:51:13 <lambdabot> expecting variable, "(", operator or ")"
09:51:21 <neutrino> @pl \x y -> (fst x == fst y)
09:51:21 <lambdabot> (. fst) . (==) . fst
09:51:24 <cmccann> :t (==) `on` fst
09:51:25 <lambdabot> forall a b. (Eq a) => (a, b) -> (a, b) -> Bool
09:51:28 <neutrino> that's not as readable
09:51:33 <neutrino> cmccann: thanks
09:51:33 <rwbarton> without really feeling like I have a good idea of what you want to do exactly--yeah, I'd suggest having a thread to take care of communication with the server and have it insert messages it receives into a Chan
09:51:39 <cmccann> neutrino, that's why that function exists :]
09:51:45 <elliott> @pl is not known for making code more readable.
09:51:45 <lambdabot> (line 1, column 44):
09:51:45 <neutrino> :)
09:51:45 <lambdabot> unexpected end of input
09:51:45 <lambdabot> expecting white space or simple term
09:51:50 <elliott> Shut up, lambdabot.
09:51:53 <cmccann> haha
09:52:09 <kofron> rwbarton, that's what i'm aiming at - a thread that listens to the changes feed and pumps the messages it gets into a Chan
09:52:22 <cmccann> kofron, that's pretty straightforward, then
09:52:31 <neutrino> elliott: i was talking about cmccann's code, the @pl code was obviously a hallmark of readability
09:53:18 <kofron> cmccann can you give me an idea where to get started with a long polling type request in haskell?  i'm coming from the erlang world and i'm a little lost
09:53:19 <elliott> oh
09:53:28 <elliott> neutrino: cmccann's /is/ more readable, once you know what on does
09:53:34 <elliott> that's what it's meant to be used for, in fact
09:53:42 <elliott> ((compare `on` field) is the most common example)
09:54:33 <kallisti> I can't find a way to use cabal to install shared libraries when the static libraries already exist (WITHOUT using --reinstall which is a huge waste of time)
09:54:45 <kallisti> is there a way to do that
09:54:55 <alpounet> i don't think so
09:54:59 <elliott> kallisti: --reinstall
09:55:05 <kallisti> :(
09:55:08 <elliott> + buying a new processor to save time
09:55:12 * hackagebot hspec 0.9.1.1 - Behavior Driven Development for Haskell  http://hackage.haskell.org/package/hspec-0.9.1.1 (GregWeber)
09:55:27 <elliott> or just don't use shared libs :P
09:55:30 <kallisti> this seems like it should be possible to add to cabal....
09:55:47 <kallisti> perhaps I should write a patch. :P
09:56:23 <Sgeo> :t on
09:56:24 <lambdabot> forall b c a. (b -> b -> c) -> (a -> b) -> a -> a -> c
09:56:55 <elliott> kofron: Your question is really unspecific.
09:57:08 <elliott> kofron: If you gave us an idea of the concrete thing you're unable to find a solution or pointer for, that would help.
09:57:22 <Sgeo> f `on` g is \a b -> (g a) `f` (g b)
09:57:35 <rtharper> @src on
09:57:35 <lambdabot> (*) `on` f = \x y -> f x * f y
09:58:02 <Sgeo> I guess that's clearer?
09:58:06 <cmccann> kofron, if you're coming from Erlang then I suspect the most important things to know are that Haskell threads are really cheap and immutable data is inherently thread-safe
09:58:16 <Sgeo> Unless someone gets confused by the *
09:58:21 <rwbarton> I think actually the problem is very specific but we don't know what it is.
09:58:26 <rwbarton> Are you using a C library to talk to the server?
09:58:33 <rwbarton> Does it have Haskell bindings already?
09:58:39 <rwbarton> Do they support long-polling already?
09:58:43 <rwbarton> Or are you handling the communication yourself?
09:59:11 <kallisti> elliott: so in general a ByteString -> Text conversion is going to be faster than a String -> Text conversion?
09:59:23 <cmccann> kofron, it sounds like you already know the basic design you need, and it sounds like it's all stuff that's easy to do in Haskell
10:00:00 <Sgeo> What was the thing for reading network activity?
10:00:03 <Sgeo> (Not in Haskell)
10:00:07 <dcoutts> kallisti: yes, the problem is that currently ghc-pkg doesn't track different "flavours" of the same package separately
10:00:09 <Sgeo> Wire... something, used to be Ethersomething?
10:00:23 <akosch> Sgeo: Wireshark?
10:00:37 <Sgeo> akosch, thanks!
10:00:47 <dcoutts> kallisti: e.g. static, dynamic, profiling, etc
10:01:20 <elliott> kallisti: Text -> String, is it not?
10:01:48 <Sgeo> If I want to get at something's wire protocol, should I run it in a VM if I don't want to close out of IRC?
10:01:56 <kallisti> elliott: oh, previously, yes. I'm thinking about an unrelated problem now and forgot which conversion we were previously talking about. :P
10:02:07 <elliott> Sgeo: Wireshark has filters. But this is off-topic.
10:02:39 <elliott> kallisti: It depends on the conversion. But probably.
10:02:45 <cmccann> kofron, have you looked at concurrency stuff in Haskell at all? or networking libraries?
10:02:46 <elliott> kallisti: Except that the String can skip the UTF decoding.
10:02:49 <elliott> So it's not clear.
10:03:16 <elliott> But I would avoid String anyway, since if you're using Text String probably isn't appropriate.
10:03:19 <elliott> For reasons of size or whatever.
10:03:36 <kallisti> elliott: I'm transforming C strings to Text. As far as I know there's no direct transformation from C-string -> Text, so the best option seems to be C-string -> ByteString -> Text
10:04:07 <elliott> What encoding?
10:04:32 <elliott> kallisti: But, http://hackage.haskell.org/packages/archive/text/0.11.1.13/doc/html/Data-Text-Foreign.html
10:04:39 <elliott> fromPtr in particular.
10:06:12 <kallisti> as far as I know the C code only passes the binary data around and doesn't need to know the logical encoding itself. It's an IRC bot, so, whatever the IRC network uses (most likely UTF-8)
10:06:17 <kofron> cmccann sorry, got pulled away by some lab work that needed doing
10:06:22 <Mike____> Hmm, i got a problem atm
10:06:23 <Mike____> a++b++c++"\n"
10:06:28 <Mike____> how do i get the \n to work
10:06:35 <Mike____> to go to the next line
10:06:40 <elliott> kallisti: So, you don't actually know it's Unicode text in a given encoding. Why are you using Text?
10:06:42 <kofron> cmccann i'm actually working through it at the moment.  this is really just an excuse for me to try to get more familiar with haskell
10:06:47 <Mike____> its being read as part of the string
10:07:10 <elliott> Mike____: You're printing out a String in GHCi or with print, but you want putStr.
10:07:19 <elliott> The ++"\n" itself is fine.
10:07:43 <Mike____> oh, i see
10:07:47 <hpc> @src print
10:07:48 <lambdabot> print x = putStrLn (show x)
10:07:52 <hpc> @src putStrLn
10:07:53 <lambdabot> putStrLn s =  do putStr s; putChar '\n'
10:08:02 <elliott> (I suspect GHCi.)
10:08:32 <burbul> @src sequence
10:08:32 <lambdabot> sequence []     = return []
10:08:32 <lambdabot> sequence (x:xs) = do v <- x; vs <- sequence xs; return (v:vs)
10:08:32 <lambdabot> -- OR: sequence = foldr (liftM2 (:)) (return [])
10:08:38 <Mike____> im doind everything fine, the outut comes like this: abc\na1b1c1\n etc etc
10:08:40 <cmccann> kofron, ok, that's fair. honestly it seems like you're on the right track in general, so without more details or specific questions I'm not sure what to tell you
10:08:40 <Mike____> so i must use putStr
10:08:43 <Mike____> is that right?
10:08:54 <burbul> @src mapM
10:08:54 <lambdabot> mapM f as = sequence (map f as)
10:09:06 <elliott> Mike____: What are you doing already?
10:09:08 <elliott> hpaste your program
10:09:27 <kallisti> elliott: I suppose there's not a good reason other than if I ever write logic that has to make encoding assumptions, I'll likely just assume it's UTF-8 anyway since (to my knowlege) I have no way to actually know the encoding.
10:09:40 <hpaste> Mike pasted “rubik” at http://hpaste.org/63412
10:09:59 <kofron> cmccann honestly i think i should probably just go and read and play a bit.  i'll check back when i have more specific questions
10:10:01 <kofron> thanks!
10:10:12 <Mike____> I was testing it like this: mostraCubo dados
10:10:26 <Mike____> http://hpaste.org/63412
10:11:33 <luite> tsuraan: I've opened a github ticket for your comment (on the yesod 0.10 rlease) reddit
10:12:27 <kallisti> elliott: unless there's a frequently used network that uses something than ASCII or UTF-8.
10:12:37 <kallisti> (UTF-16 possibly?)
10:12:39 <elliott> kallisti: Windows-blah is common even on Freenode.
10:12:47 <kallisti> ah
10:13:07 <elliott> You can, as a matter of policy, reject invalid Unicode and decode ByteStrings to Text as soon as they come in.
10:13:12 <elliott> That would affect the design of the rest of your system.
10:13:15 <mach7> @Mike____  do you need some help with your code?
10:13:15 <lambdabot> Unknown command, try @list
10:13:23 <elliott> mach7: don't ping with @
10:13:27 <elliott> kallisti: I'm not sure what this C library is. Are you using a C library to talk to IRC?
10:13:44 <mach7> sorry, i m new to irc
10:13:47 <aristid> i think the most common encodings on freenode are likely to be utf8 and latin1
10:13:56 <Mike____> Yes please, I'm trying to get the character "\n" do jump to the next line. but i think im doing it the wrong way
10:14:07 <kallisti> elliott: the C library is actually an IRC bot. it has a plugin system that uses shared libraries and dlsym stuff.
10:14:18 <kallisti> this is how I talk to it, basically.
10:14:21 <MostAwesomeDude> Don't even bother with encodings on IRC. There's no useful information you can really gather about which encoding people are using.
10:14:27 <Azel> mach7: The problem is just that @ begins commands for lambdabot
10:14:28 <mach7> the problem is line 20?
10:14:37 <mach7> ok, thx
10:14:51 <kallisti> elliott: I guess I'll just use ByteString nad make conversions when needed, assuming converting between ByteString and Text is reasonably swift.
10:15:00 <Mike____> yeah... i was trying to test it using. mostraCubo Dados
10:15:05 <Mike____> but it comes all in the same line
10:15:18 <rwbarton> putStr (mostraCubo dados)
10:15:23 <kallisti> elliott: so that individual plugins can decide which encoding they want.
10:15:30 <elliott> MostAwesomeDude: UTF-8 with fallback to Windows-whatever catches basically everything.
10:15:34 <mach7> putStrLn (mostraCubo dados)
10:15:42 <Mike____> like this "AmAmAm\nAmAmAm\nAmAmAm\n"
10:15:43 <Mike____> ok
10:15:47 <mach7> you want a newline after printing, right?
10:15:53 <MostAwesomeDude> elliott: Big5, Shift-JIS, Latin-1, Latin-7, CP 437.
10:16:01 <MostAwesomeDude> elliott: CP 1252 and UTF-8 are not everything. :c
10:16:11 <mach7> or you can write it like   putStrLn $ mostraCubo dados
10:16:25 <Mike____> what does the $ do ?
10:16:32 <lysgaard> > show "ødegård"
10:16:33 <lambdabot>   "\"\\248deg\\229rd\""
10:16:52 <elliott> MostAwesomeDude: On English networks.
10:16:55 <mach7> f $ g $ h x  is the same as  f(g(h x))
10:17:01 <elliott> MostAwesomeDude: Latin-1 is a subset of the Windows thing.
10:17:23 <mach7> this helps you chaining functions
10:17:23 <Mike____> oh, i see
10:17:33 <Mike____> that is usefull indeed
10:17:43 <rwbarton> printCubo would work except the type is wrong, should be IO ()
10:17:47 <rwbarton> (also the do is unnecessary)
10:17:48 <cmccann> you should use f . g . h $ x instead of f $ g $ h $ x though
10:18:06 <kallisti> ITC: stylistic preferences
10:18:10 <mach7> $ and . are functions
10:18:16 <mach7> can lambdabot print the source of this?
10:18:19 <mach7> @src (.)
10:18:20 <lambdabot> (f . g) x = f (g x)
10:18:20 <lambdabot> NB: In lambdabot,  (.) = fmap
10:18:29 <mach7> @src ($)
10:18:29 <lambdabot> f $ x = f x
10:18:47 <cmccann> kallisti, nah, there are objective benefits to that form, the code is easier to refactor
10:18:51 <Mike____> but this is not correct: printCubo :: IO String printCubo putStrLn (mostraCubo dados)
10:19:21 <mach7> printCubo = putStrLn $ mostraCubo dados
10:19:27 <elliott> cmccann: a lot of people write (f . g $ h x) :(
10:19:31 <elliott> which destroys the refactoring benefit
10:20:00 <mach7> you don't need an argument to this function, so instead of 'printCubo f = ...' write 'printCubo = ...'
10:20:07 <cmccann> elliott, I actually tend to mix things up based on which parts conceptually go together
10:20:12 <hpc> elliott: i do it sometimes if (h x) is conceptually distinct from (f . g)
10:20:45 <cmccann> e.g. (bunchOf . stringMangling . functionsGoHere $ show foo)
10:20:45 <Mike____> the problem is, it's expecting a String() and recieving ()
10:20:53 <elliott> yeah, that's okay
10:20:54 <mach7> and the putStr/putStrLn functions take only one argument, not two
10:21:01 <elliott> but a lot of people seem to bundle the last  function with the variable as a matter of policy
10:21:12 <elliott> Mike____: What's a String()?
10:21:17 <mach7> the type of printCubo should be IO (), not IO String
10:21:23 <cmccann> elliott, yeah, that's kind of silly
10:21:28 <mach7> why would you use IO String?
10:21:39 <kallisti> elliott: yes I think I've settled on ByteString (again making the assumption that conversion to/from Text is reasonably efficient; do you know if they're similarly implemented?)
10:21:40 <Mike____> oh, nvm
10:21:43 <Mike____> silly me
10:21:57 <elliott> kallisti: ByteString<->Text requires a UTF encoding/decoding step.
10:22:32 <elliott> They're both unboxed arrays, but that isn't really relevant.
10:22:52 <mach7> you can think of an 'IO a' as an action which goes to the outside world and comes back with an 'a'
10:23:28 <elliott> mach7: or gets killed in battle (consider exitFailure)
10:23:28 <lysgaard> Doing: writeFile "/tmp/test" "testøæå" results in a file with "test\248\230\229" How do I write a file with UTF-8 encoding?
10:23:37 <mach7> The print/putStr/putStrLn methods are only printing, not fetching any value from the environment
10:23:41 <elliott> lysgaard: What OS? If Unix, what is LANG set to?
10:23:54 <Mike____> oh
10:23:58 <elliott> lysgaard: Take a look at System.IO.hSetEncoding if you want to control it in-program.
10:24:01 <lysgaard> elliott: LANG is en_EN.utf-8, ubuntu linux
10:24:12 <rwbarton> What GHC version?
10:24:12 <elliott> lysgaard: en_EN?
10:24:16 <mach7> Mike: you use GHCi, right?
10:24:24 <elliott> I didn't realise that was a thing.
10:24:26 <elliott> lysgaard: http://hackage.haskell.org/packages/archive/base/4.5.0.0/doc/html/System-IO.html#v:hSetEncoding
10:24:39 <lysgaard> elliott: Sorry, I mean en_US.UTF-8
10:24:42 <Mike____> yes i am
10:24:45 <mach7> in GHCi type this: ':t putStr'
10:24:52 <Mike____> 7.2.1
10:24:57 <elliott> lysgaard: What GHC version?
10:24:59 <mach7> the :t prints the type of a function
10:25:06 <elliott> lysgaard: Oh, wait.
10:25:10 <lysgaard> elliott: 7.0.3
10:25:11 <elliott> lysgaard: Check the encoding of your Haskell file.
10:25:13 <elliott> I bet it's not UTF-8.
10:25:20 <lysgaard> elliott: Does that matter?
10:25:27 <elliott> Yes, of course.
10:25:30 <mach7> or use the lambdabot here
10:25:33 <mach7> @src putStrLn
10:25:33 <lambdabot> putStrLn s =  do putStr s; putChar '\n'
10:25:34 <elliott> GHC assumes your program is UTF-8.
10:25:35 <Eduard_Munteanu> lysgaard: what editor are you using?
10:25:43 <mach7> oh no, I wanted the type!
10:25:45 <rwbarton> how could it matter?
10:25:52 <rwbarton> isn't "test\248\230\229" not even valid utf-8?
10:26:02 <rwbarton> assuming that represents a sequence of 7 bytes
10:26:03 <mach7> @type putStrLn
10:26:04 <lambdabot> String -> IO ()
10:26:07 <Mike____> so, it seems like its ok, because, it only asks for a string
10:26:07 <elliott> I don't think GHC requires the contents of strings to be valid UTF-8.
10:26:15 <lysgaard> You are right, the program is in ASCII, but my source file is in UTF-8
10:26:25 <elliott> lysgaard: The program is in ASCII?
10:26:33 <mach7> what asks for a string?
10:26:36 <elliott> øæå aren't valid ASCII characters, anyway.
10:26:40 <Mike____> Couldn't match expected type `String' with actual type `IO ()'
10:26:48 <mach7> your function?
10:26:50 <elliott> lysgaard: But what is the program, if not the source file?
10:27:00 <rwbarton> I mean, "testøæå" :: String... there should not be any string on which writeFile produces "test\248\230\229"
10:27:04 <lysgaard> elliott: Well, the program is programmed in ASCII, but i read an UTF-8 encoded file and write to another one.
10:27:09 <Mike____> my function mostraCubo returns a string
10:27:11 <Mike____> so it sohuld be ojk
10:27:23 <elliott> rwbarton: Of course there is
10:27:32 <rwbarton> what string is that pray tell
10:27:37 <mach7> yeah, that one is ok
10:27:38 <rwbarton> assuming utf-8 encoding
10:27:40 <elliott> Oh.
10:27:42 <elliott> Well, that's harder.
10:27:44 <mach7> but the printCubo function isn't
10:27:48 <elliott> lysgaard: I'm confused. Are you using a literal string or not?
10:27:49 <Mike____> yeah
10:27:54 <elliott> lysgaard: Can you hpaste your program?
10:27:57 <Eduard_Munteanu> rwbarton: I guess the terminal encoding is UTF-8 and the editor could be using something else
10:28:02 <mach7> i assume you want something like: printCubo :: String -> IO ()
10:28:10 <Eduard_Munteanu> So it essentially translates UTF-8 to whatever it's using.
10:28:20 <mach7> or rather printCubo :: Cubo -> IO ()
10:28:20 <Mike____> i want to output the information yes
10:28:27 <Mike____> hmm....
10:28:28 <mach7> ok, than write this
10:28:37 <mach7> printCubo = print . mostraCubo
10:28:41 <Eduard_Munteanu> Assuming it detects that sort of stuff properly.
10:28:51 <elliott> mach7: I doubt print is desired.
10:28:55 <Mike____> well, if mostraCubo outputs a string, and print cube recieves a String, it should be working.!!
10:29:00 <mach7> this chains the mostraCubo with the print funtion
10:29:03 <mach7> oh, yeah, sorry
10:29:05 <elliott> Almost certainly putStr.
10:29:07 <elliott> Or putStrLn
10:29:11 <mach7> then it should be putStrLn . mostraCubo
10:29:37 <burbul> @pl sequence . (map f)
10:29:37 <lambdabot> sequence . map f
10:29:40 <rwbarton> Apparently lysgaard's LANG is en_US.UTF-8 so I would expect writeFile "/tmp/test" anything to produce valid UTF-8
10:29:52 <burbul> @help
10:29:52 <lambdabot> help <command>. Ask for help for <command>. Try 'list' for all commands
10:29:56 <burbul> @list
10:29:56 <lambdabot> http://code.haskell.org/lambdabot/COMMANDS
10:30:04 <monochrom> use a hex editor to verify. do not trust text editors or terminals
10:30:07 <mach7> you could write:  mostraCubo cubo = putStrLn (mostraCubo cubo)
10:30:22 <mach7> but mostraCubo = putStrLn . cubo   is the same, just shorter and pointfree
10:30:25 <burbul> @help pretty
10:30:25 <lambdabot> pretty <expr>. Display haskell code in a pretty-printed manner
10:30:56 <elliott> monochrom: file(1) also works
10:31:01 <elliott> (usually)
10:31:13 <lysgaard> elliott: I'm not using a string litteral. The program is quite big so i won't paste it. What it does is this: Read an utf-8 xml file. Create a ADT from it. Write a new XML file that is based on the ADT. The output file somehow has charset us-ascii.
10:31:15 <burbul> does lambdabot have a command that tells you if there's a more succinct way of saying something?
10:31:34 <mach7> http://www.haskell.org/haskellwiki/IRC_channel#lambdabot
10:31:51 <Eduard_Munteanu> burbul: succint? Not really. @pl can even produce larger code
10:32:03 <Eduard_Munteanu> @pl 5 + 2 * 3
10:32:04 <lambdabot> 11
10:32:05 <elliott> lysgaard: Well, however big it is, it's hard to help further without the program. Or at least, the parts of the program that perform IO.
10:32:08 <Eduard_Munteanu> Bah.
10:32:13 <aristid> Eduard_Munteanu: oO
10:32:20 <Eduard_Munteanu> @pl \x y z -> x + y * z
10:32:20 <lambdabot> (. (*)) . (.) . (+)
10:32:22 <aristid> Eduard_Munteanu: why did you think that would blow up?
10:32:25 <lysgaard> elliott: I can make a compressed version of the problem ;)
10:32:27 <burbul> ok, thanks
10:32:39 <Eduard_Munteanu> aristid: dunno :)
10:32:42 <elliott> lysgaard: OK, but don't change any details (like file source -> string literal).
10:32:55 <Eduard_Munteanu> Momentary lapse :)
10:32:57 <aristid> > map length ["\x y z -> x + y * z", "(. (*)) . (.) . (+)"]
10:32:58 <lambdabot>   <no location info>:
10:32:58 <lambdabot>      lexical error in string/character literal at chara...
10:33:19 <aristid> what did i do wrong" *confused*
10:33:23 <monochrom> file tells you very little, even when it is right
10:33:47 <cmccann> aristid, the \x is an escape character
10:34:00 <aristid> cmccann: oh! lol
10:34:08 <aristid> > map length ["\\x y z -> x + y * z", "(. (*)) . (.) . (+)"]
10:34:09 <lambdabot>   [19,19]
10:34:19 <aristid> Eduard_Munteanu: indeed, @pl did not shorten it :)
10:34:41 <aristid> > map length ["\\x y z->x+y*z", "(.(*)).(.).(+)"]
10:34:42 <lambdabot>   [13,14]
10:34:44 <Eduard_Munteanu> It can also produce horrible pointfree code.
10:34:58 <Mike____> oh god
10:35:00 <Mike____> it was so easy
10:35:03 <Mike____> and i was complicating it
10:35:07 <Mike____> printCubo = mostraCubo dados
10:35:09 <Mike____> just that
10:35:23 <mach7> hmm
10:35:39 <rwbarton> er
10:35:51 <mach7> that just prints out the string in it's escaped version
10:35:56 <rwbarton> somehow I doubt that is what you want!
10:36:01 <Mike____> but still got one problem, i get AmAmAm\nAmAmAm\nAmAmAm
10:36:06 <Mike____> and the \n is not working
10:36:20 <rwbarton> no kidding
10:36:21 <monochrom> do not use "print" for strings. use "putStrLn"
10:36:21 <copumpkin> > show "moo\n"
10:36:22 <lambdabot>   "\"moo\\n\""
10:36:23 <copumpkin> > show "moo\nbaa"
10:36:23 <Mike____> is that why we use putStr?
10:36:24 <lambdabot>   "\"moo\\nbaa\""
10:36:28 <copumpkin> > text "moo\nbaa"
10:36:29 <lambdabot>   moo
10:36:29 <lambdabot>  baa
10:36:34 <elliott> Mike____: printCubo is incorrect.
10:36:36 <Mike____> ohhhh
10:36:37 <rwbarton> Mike____: yes
10:36:40 <mach7> yeah, that's why
10:36:43 <elliott> Mike____: printCubo is a String. You want IO ().
10:36:43 <monochrom> "print" tells you how to escape the string. that's its purpose.
10:36:43 <copumpkin> > text "moo\npreflex: seen mauke"
10:36:44 <lambdabot>   moo
10:36:45 <lambdabot>  preflex: seen mauke
10:36:50 <elliott> Mike____: GHCi is misleading you.
10:36:51 <rwbarton> before you were typing "mostraCubo dados" into ghci, right?
10:36:52 <mach7> you don't want to see the string, you want it printed
10:36:58 <rwbarton> so why would defining "printCubo = mostraCubo dados" help?
10:37:07 <rwbarton> that just makes printCubo... the same as mostraCubo dados
10:37:15 <Mike____> yeah...
10:37:23 <mach7> printCubo = putStrLn $ mostraCubo dados
10:37:29 <mach7> is what you want
10:37:48 <burbul> @pl map f . sequence . map g $ children
10:37:49 <lambdabot> map f (sequence (map g children))
10:37:51 <monochrom> ghci has an implicit "print", so it also shows you escape codes
10:37:58 <Mike____>  Couldn't match expected type `String' with actual type `IO ()'  In the expression: putStr $ mostraCubo dados  In an equation for `printCubo':      printCubo = putStr $ mostraCubo dados
10:38:03 <Mike____> i still get an error with that
10:38:30 <monochrom> well, use putStr inside mostraCubo
10:38:41 <Mike____> oh
10:38:42 <Mike____> okok
10:39:06 <monochrom> or putStrLn
10:39:25 <mach7> printCubo :: IO ()
10:39:26 <Mike____> whats the difference between the both of them?
10:39:29 <Mike____> which is more correct?
10:39:30 <mach7> printCubo = putStrLn $ mostraCubo dados
10:39:36 <elliott> neither is more correct
10:39:40 <elliott> putStrLn prints a newline after the string
10:39:46 <Mike____> oh, got it
10:41:20 <mach7> Mike____: I recommend you use a datatype for the Cube
10:41:26 <Mike____> Thankyou mach7
10:41:27 <Mike____> worked
10:41:34 <mach7> you'r welcome
10:41:58 <lukish> I want to make a visualising of some list with length equal 10^6 (picture 1000x1000). So, I have something like [((x,y), (h,s,l))] . What should I use to create a picture from that data?
10:42:24 <kallisti> What's an easy equivalent for ByteStrings to pattern matching on (:) Strings
10:42:30 <kallisti> +for
10:42:33 <cmccann> lukish, what kind of picture? an image file?
10:42:35 <RichyB> kallisti: uncons
10:42:39 <elliott> lukish: something like http://hackage.haskell.org/package/repa-devil
10:42:46 <elliott> lukish: note that that representation is rather supremely bad
10:42:55 <rwbarton> along with
10:42:57 <rwbarton> @hackage colour
10:42:57 <lambdabot> http://hackage.haskell.org/package/colour
10:43:01 <elliott> lukish: using repa arrays would be much more efficient and let you use repa-devil more directly
10:43:02 <cmccann> yes
10:43:10 <elliott> yes, what rwbarton said, to do the conversion to rgb
10:43:12 <cmccann> since it sounds like you have HSL colors, and you'll need RGB for output
10:43:22 <cmccann> which is harder than you think to do manually
10:43:26 <elliott> lukish: [] is actually a singly-linked list, and your tuples have lots of memory overhead
10:43:53 <elliott> (http://www.haskell.org/haskellwiki/Numeric_Haskell:_A_Repa_Tutorial covers using repa and repa-devil)
10:43:56 <lukish> Yes, (x,y) could be founded from idex
10:43:58 <lukish> That's right
10:44:02 <cmccann> that said if the list is only being used as the output of something that produces points incrementally
10:44:09 <cmccann> then that's probably file
10:44:11 <cmccann> fine
10:44:11 <elliott> lukish: ?
10:44:24 <Mike____> if instead of this [(a,_,_,_,_,_)] I use [(a,_):t] can i use a recursive method to search inside it?
10:44:25 <elliott> lukish: What do you mean?
10:44:28 <cmccann> since the list will only be forced as you demand each pixel to write the image out
10:44:49 <elliott> cmccann: yeah, but that won't work with an existing lib like repa-devil
10:44:54 <RichyB> Mike____: no, tuples aren't recursive.
10:45:20 <rwbarton> lukish: btw, one warning about a weirdness of repa-devil you will almost certainly encounter, it doesn't like writing to existing files (it just silently does nothing instead)
10:45:28 <Mike____> thanks
10:45:29 <mach7> Mike____: Use a data type, not a 10-tuple
10:45:58 <cmccann> elliott, right, but if it's just writing individual pixels one at a time there's not much need for repa at all I suspect
10:46:01 <lukish> rwbarton: okay, writing to new file is ok
10:46:22 <elliott> cmccann: then what are you going to write the image with? I cannot think of any library that does not use unboxed arrays
10:46:26 <lysgaard> elliott: Ah, even more strange, my condensed problem works perfectly :S It does everything in utf-8
10:46:33 <lukish> Repa looks interesting, thanks.
10:46:49 <elliott> lysgaard: how long is your original program?
10:47:01 <keyzs> http://www.thevenusproject.com/techdb/members.php
10:47:03 <mach7> like:  data Face = {faceSide :: N, quad1 :: Quadricula, quad2 :: Quadricula, ..., quad9 :: Quadricula}
10:47:07 <keyzs> need best coders
10:47:11 <cmccann> elliott, use unboxed arrays for what?
10:47:13 <kallisti> hm, so I'm guessing there's no way to interpret a character literal as a Word8?
10:47:17 <elliott> keyzs: not on-topic
10:47:22 <elliott> cmccann: ...the input?
10:47:23 <lukish> elliott: using repa-based typeclasses I will not have that overhead?
10:47:28 <mach7> or use a list for the Quadriculas to be more flexible
10:47:31 <elliott> lukish: no typeclasses involved
10:47:32 <c_wraith> :t ord
10:47:33 <lambdabot> Char -> Int
10:47:38 <elliott> lukish: but repa will avoid all the memory overhead and have fast operations, yes
10:47:38 <RichyB> kallisti: (toEnum . fromEnum) :: Char -> Word8
10:47:43 <lysgaard> elliott: It's divided into several modules, but I could zip it and put it somewhere to share? It only depends on HaXml and mtl.
10:47:46 <elliott> lukish: (as well as more convenient ones, for your multi-dimensional array)
10:47:46 <c_wraith> :t fromInteger . ord
10:47:47 <lambdabot>     Couldn't match expected type `Integer' against inferred type `Int'
10:47:47 <lambdabot>       Expected type: Char -> Integer
10:47:48 <lambdabot>       Inferred type: Char -> Int
10:47:53 <c_wraith> :t fromIntegral . ord
10:47:54 <lambdabot> forall b. (Num b) => Char -> b
10:47:56 <c_wraith> there
10:48:19 <elliott> lysgaard: well, is the problem isolated to one module? it might be possible to figure out what's wrong without having to actually run the code
10:48:23 <cmccann> elliott, the only one I've ever used let you create a new image in-memory and then write pixels to it, so I dunno
10:48:28 <elliott> the problem = the IO in question
10:48:37 <elliott> cmccann: right, which will probably write to... an unboxed array :P
10:48:51 <kallisti> RichyB: yes but I can't do that inside a pattern. I guess I can either a) use a numeric literal at the cost of readability b) use a guard with toEnum . fromEnum
10:49:11 <elliott> cmccann: my point is just that you're not going to get any properly incremental behaviour
10:49:16 <elliott> in terms of space usage or time before IO
10:49:27 <elliott> kallisti: view pattern
10:49:51 <kallisti> elliott: good thinking. that will be bump up my language extension count. I'm trying to use as many as possible.
10:50:01 <elliott> you asked
10:50:10 <cmccann> elliott, if you're generating a huge list and then forcing it as you write each pixel the list itself would be incremental, though?
10:50:30 <kallisti> elliott: well I wasn't joking actually. :P
10:50:35 <elliott> cmccann: well, sure... the use of the overhead will be incremental
10:50:38 <elliott> I guess that counts for something :P
10:50:52 <cmccann> it's the "list as a loop" thing, yes
10:51:00 <RichyB> View types are a harmless extension. They don't mess with the type system and they barely mess with the syntax.
10:51:03 <elliott> kallisti: I would suggest not pretending Word8s are characters instead.
10:51:03 <cmccann> iterating through a bunch of things requires one iteration per thing
10:51:06 <cmccann> oddly enough :P
10:51:08 <elliott> kallisti: just define wCR, wLF and such
10:51:19 <lysgaard> elliott: Thanks for the help. I've got to go now but will be back on the problem tomorrow ;)
10:51:27 <elliott> lysgaard: ok :)
10:51:36 <RichyB> Er, view types? I meant view patterns.
10:51:48 <kallisti> elliott: well logically they are representing "characters". they're just not Chars.
10:51:54 * cmccann imagines type-level view patterns
10:52:13 <elliott> kallisti: Using ByteString to represent an ASCII string is also technically a misuse of ByteString, so no, they're not really characters.
10:52:21 <elliott> kallisti: But just use Data.ByteString.Char8 if you must.
10:52:24 <elliott> That uses Char instead of Word8.
10:52:39 <monochrom> and it's still ascii, or latin-1
10:52:46 <elliott> RichyB: well, view patterns /are/ meant to be used for "view types"
10:52:47 <kallisti> elliott: uh, what? how is that a misuse?
10:52:51 <elliott> monochrom: Right, yes.
10:52:58 <elliott> kallisti: ByteString represents a bunch of octets.
10:53:07 <elliott> The fact that ASCII is represented as a bunch of octets is irrelevant.
10:53:20 <elliott> It's the exact same reason using ByteString for Unicode data is wrong: semantic mismatch.
10:53:25 <RichyB> Eh, wanting to use Char literals as Word8 literals is not the end of the world.
10:53:30 <monochrom> 10 years ago, bytestring represented chars, that's the mindset then. now, not anymore
10:53:33 <elliott> But it's less awful in the case of ASCII because there's a closer mapping.
10:54:00 <elliott> kallisti: Oh, and half the values a ByteString element can have aren't valid ASCII.
10:54:07 <RichyB> There are plenty of use cases where that's a sane thing to do, such as writing parsers for protocols like HTML where it's much nicer to be able to just write "\r\n" than (pack [10, 13]) -- or was it 13 10?
10:54:11 <elliott> ASCII is 7-bit.
10:54:18 <kallisti> elliott: yes I'm aware. but... what is the better alternative?
10:54:21 <monochrom> however, old habits never die, so if you still think of bytestring as an old kind of chars, fine
10:54:29 <elliott> I didn't say there was a better alternative, just that it's a misuse.
10:54:29 <kallisti> Text is bad. String is bad. ByteString is bad. ......
10:54:42 <elliott> Text and String are both perfectly fine for ASCII data.
10:54:48 <elliott> However, your data isn't ASCII, if it's the same data as last time.
10:55:11 <elliott> It's an ASCII-wrapper protocol containing binary messages (presumed to be Unicode in some unknown encoding).
10:55:15 <elliott> (Also known as "a mess".)
10:55:25 * monochrom is tired of fighting this battle
10:55:39 <kallisti> well, it is. Now I'm parsing a mode string. which uses ASCII.
10:55:45 <elliott> monochrom: Unicode is more like 20 years ago now.
10:55:48 <kallisti> I'm matching on the '+' and the '-'
10:56:06 <monochrom> until China conquers the world, people are not going to appreciate that a char takes more than 8 bits
10:56:37 * kallisti was under the impression that most programmers understand the importance of using a multi-byte encoding.
10:57:03 <monochrom> as long as everyone still thinks "everyone uses english", it doesn't matter whether unicode is 20 years old or 20 centuries old.
10:57:37 <elliott> (Not that ASCII covers English, either.)
10:57:42 <mekeor> monochrom: well, it chino IS going to coquer the world... :P
10:57:44 <monochrom> Chinese is at least 3000 years old, english only 1500 or so. does it matter?
10:57:49 <kallisti> perhaps you shouldn't be fighting battles against an enemy that might not necessarily be an actual threat.
10:58:08 <elliott> kallisti: If you think people appreciate the difference between bytestrings and Unicode text, I invite you to peruse every single day in this channel ever.
10:59:13 <ChristianS> bytestrings can encode utf-8 and utf-16 just fine, you just mustn't confuse bytes withs chars
10:59:30 <hpc> technically, bytestrings can encode anything
10:59:32 <elliott> Of course they can encode it.
10:59:37 <elliott> That doesn't mean a ByteString is a text string.
10:59:39 <hpc> they're raw memory
10:59:47 <byorgey> Nat can also encode anything ;)
10:59:49 <elliott> hpc: so can Integer :P
10:59:54 <hpc> :P
10:59:55 <elliott> byorgey: *hi5*
11:00:02 <byorgey> =D
11:00:09 <monochrom> otoh you don't have to decode bytestrings if you're just scanning for \n
11:00:15 <elliott> Look, why are you people being so pedantic about the types?! I just want to represent a simple integer in a Nat.
11:00:16 * cmccann considers referring to "some sort of unicode incorrectly handled as bytes" as UTF-⊥
11:00:21 <elliott> No, I *know* my data will never be negative.
11:00:23 <kallisti> byorgey: well, any discrete set. which is kind of what we do with these computer things.
11:00:42 <elliott> No, I specifically know that it will never be a Nat. Yes, it's going to be exposed to the entire internet.
11:00:49 <cmccann> :D
11:00:58 <cmccann> elliott, spoken like a true PHP coder
11:01:13 <byorgey> kallisti: it's kind of all we *can* do. =)
11:01:18 <monochrom> however, that assumes that the only reason \n appears in your bytes is because it stands for \n, not for a part of some other char
11:01:34 <ChristianS> monochrom: which is perfectly true for utf-8
11:01:59 <elliott> IRC stops you using encodings which use the 10 byte for other things
11:02:06 <elliott> I wonder if that includes UTF-16.
11:02:11 <kallisti> byorgey: just wait. analog computing is going to be the new thing.
11:02:24 <byorgey> hehe
11:02:29 <cmccann> kallisti, eh, that doesn't really change anything
11:02:41 <hpc> cmccann: 6 months from now, in the PHP feature request list: "add negative numbers to Nat by divmoding by 2; odd numbers are negative, even are positive"
11:02:48 <elliott> hpc: :D
11:02:52 <cmccann> hpc, ahahahahahaha
11:02:55 <kallisti> is this going to segue into a "discrete universe" discussion...
11:03:07 <elliott> hpc: no this is PHP, they'd convert the integers to doubles and then take the bit-representation as a Nat
11:03:09 <hpc> number line: 0, -0, 1, -1, 2, -2, ...
11:03:53 <cmccann> hpc, I think that's even worse than my negative number encoding for makefiles
11:03:53 <elliott> hpc: Support arbitrary integers in Nat by booking a new set of rooms. [checked in by hilbert@php.net]
11:04:02 <cmccann> ha
11:04:03 <elliott> hpc: ooh, -0
11:04:05 <elliott> useful, that
11:04:18 <rwbarton> the pessimist's 0
11:04:29 <hpc> elliott: indeed; gets you past all those pesky (if x != 0) checks
11:04:35 <kallisti> 0 is a weird number.
11:04:56 <cmccann> > 1/0 == 1/(-0)
11:04:56 <byorgey> "I don't know how to stop it, there was never any intent to write a programming language..." - Rasmus Lerdorf
11:04:57 <lambdabot>   False
11:05:15 <kallisti> it almost makes sense to me that there should be a 0 and -0
11:05:23 <cmccann> > 1/0 == 1/0
11:05:24 <lambdabot>   True
11:05:29 <cmccann> > 0 == (-0)
11:05:30 <lambdabot>   True
11:05:34 <cmccann> good old floats
11:05:37 <sanjoyd`> > 1/0
11:05:38 <lambdabot>   Infinity
11:05:43 <elliott> byorgey: haha, http://en.wikiquote.org/wiki/Rasmus_Lerdorf is great
11:05:45 <sanjoyd`> > 1 `div` 0
11:05:46 <lambdabot>   *Exception: divide by zero
11:05:48 <byorgey> elliott: yep =)
11:05:50 <sanjoyd`> Oh, okay.
11:05:51 <cmccann> > 1 / (-0)
11:05:53 <lambdabot>   -Infinity
11:05:59 <elliott> "I'm not a real programmer. I throw together things until it works then I move on. The real programmers will say "Yeah it works but you're leaking memory everywhere. Perhaps we should fix that." I’ll just restart Apache every 10 requests."
11:06:09 <elliott> wow, truly preempted ruby on rails' popularity
11:06:20 <monochrom> in particular, in big5, \ can appear for one of two reasons: to stand for \ , or as the second byte of a chinese character
11:06:31 <albel727> it's possibly +NaN and -NaN.
11:06:37 <rwbarton> also in UTF-16, I would assume?
11:07:19 <monochrom> now, if you put big5 code inside a SQL query, you've got yourself a nice injection attack
11:07:33 <albel727> oh wait, I'm stupid. infinity it is, ofc. disregard me.
11:08:02 <ChristianS> rwbarton: no, in utf-16 all chars have two or four bytes
11:08:09 * albel727 forgot, when the nans are generated. 0/0 most likely.
11:08:10 <hpc> > -0.0
11:08:11 <lambdabot>   -0.0
11:08:33 <albel727> > 0/0 == 0/0
11:08:34 <hpc> albel727: 0/0, inf/inf, inf*0, inf-inf, etc
11:08:34 <lambdabot>   False
11:08:37 <sanjoyd> GADT's look a lot like dependent types.
11:08:43 <Enigmagic> > sqrt (-1)
11:08:44 <lambdabot>   NaN
11:08:51 <albel727> yeah. and by spec, nan is not equal to anything.
11:08:53 <hpc> sanjoyd: they are very close
11:09:19 <elliott> Not _that_ close.
11:09:23 <elliott> But close.
11:09:48 <RichyB> albel727: you can also get NaNs by supplying out of bounds values to log, asin, sqrt and friends. Or by trying to evaluate +inf - +inf. :)
11:10:07 <monochrom> > 2/0 + 2/0
11:10:08 <lambdabot>   Infinity
11:10:15 <monochrom> oh, subtract
11:10:17 <elliott> > 2/0
11:10:17 <monochrom> > 2/0 - 2/0
11:10:18 <lambdabot>   Infinity
11:10:19 <lambdabot>   can't find file: L.hs
11:10:23 <elliott> > 2/0 - 2/0
11:10:24 <RichyB> Or add +Inf and -Inf.
11:10:24 <monochrom> > 2/0 - 2/0
11:10:24 <lambdabot>   NaN
11:10:25 <lambdabot>   NaN
11:10:28 <elliott> batman
11:10:40 <albel727> heh =) yeah, nans are funny.
11:10:42 <hpc> @where wat
11:10:42 <lambdabot> I know nothing about wat.
11:10:55 <Taneb> Hello!
11:10:59 <monochrom> "can't find file: L.hs" seems to be a race condition that should not happen
11:11:00 <yrlnry> Also 0 · inf = NaN
11:11:11 <yrlnry> Oh, I'm 2m too late for that, sorry.
11:11:18 <elliott> monochrom: lambdabot? bugs??
11:11:23 <albel727> =)
11:11:25 <elliott> [standard sarcastic shocked response]
11:11:28 <monochrom> yeah, I'm horrified
11:11:52 <monochrom> "it can only be attributed to human errors"
11:11:56 <hpc> @where+ wat https://www.destroyallsoftware.com/talks/wat
11:11:56 <lambdabot> Okay.
11:12:04 <monochrom> wat?
11:12:12 <albel727> ok, the next two guys, who invent another ways to get nan buys each other a beer. )
11:12:50 <RichyB> > (++" batman!") . tail . (>>=) (show . (' ':)) $ [1/0 - 1/0, asin 2, sqrt -2, log -2]
11:12:50 <lambdabot>   Couldn't match expected type `[a]'
11:12:51 <lambdabot>         against inferred type `[GHC.Type...
11:12:58 <monochrom> "it takes two hands to buy each other beer"
11:12:58 <albel727> nice try )
11:13:20 <mauke> RichyB: you can't cons onto a number
11:13:30 <monochrom> "log -2" will not parse favourably
11:13:49 <RichyB> mauke: yeah, oops.
11:14:07 <hpc> > (++ " Batman!") . concat . map show [1/0 - 1/0, asin 2, sqrt -2, log -2]
11:14:08 <lambdabot>   Couldn't match expected type `[GHC.Types.Char]'
11:14:08 <lambdabot>         against inferred ty...
11:14:13 <albel727> RichyB:  anyway, since you have invented 4 methods, which is kinda 2 pairs of guys, you buy yourself 4 beers =)
11:14:23 <hpc> > (++ " Batman!") . concat . map show $ [1/0 - 1/0, asin 2, sqrt -2, log -2]
11:14:25 <lambdabot>   "*Exception: show: No overloading for function
11:14:36 <mauke> getting there
11:14:44 <hpc> 1/0 - 1/0
11:14:52 <hpc> > [1/0 - 1/0, asin 2, sqrt -2, log -2]
11:14:53 <lambdabot>   Overlapping instances for GHC.Show.Show (a -> a)
11:14:53 <lambdabot>    arising from a use of `...
11:14:57 <hpc> :t asin
11:14:58 <lambdabot> forall a. (Floating a) => a -> a
11:15:03 <hpc> :t (/)
11:15:03 <byorgey> needs moar parens
11:15:04 <lambdabot> forall a. (Fractional a) => a -> a -> a
11:15:06 <hpc> :t log
11:15:07 <lambdabot> forall a. (Floating a) => a -> a
11:15:07 <albel727> hahaha. the beer is not easy to get. )
11:15:09 <hpc> oh, we do
11:15:37 <cmccann> > read "NaN" :: Float
11:15:38 <lambdabot>   NaN
11:15:41 <hpc> > (++ " Batman!") . concat . map show $ [1/0 - 1/0, asin 2, sqrt (-2), log (-2)] -- can haskell have mandatory whitespace between operators and values now?
11:15:43 <lambdabot>   "NaNNaNNaNNaN Batman!"
11:15:58 <hpc> > read "flargle" :: Float
11:15:59 <lambdabot>   *Exception: Prelude.read: no parse
11:16:13 <byorgey> hpc: you really want to write  1 / 0 - 1 / 0  ?
11:16:27 <RichyB> Right, example corrected.
11:16:30 <RichyB> > (++" Batman!") . tail . concatMap ((' ':) . show) $ [1/0 - 1/0, asin 2, sqrt (-2), log (-2)]
11:16:31 <lambdabot>   "NaN NaN NaN NaN Batman!"
11:16:35 <hpc> byorgey: wouldn't be so bad :P
11:16:35 <byorgey> although I agree it would do nice things for negative numbers
11:16:51 <RichyB> monochrom: thank you for the help with my idiotic parse error. :)
11:17:25 <hpc> byorgey: just as long as haskell doesnt go the agda route of allowing names like foo==bar<='>>{<
11:19:02 <albel727> heh. so, hpc and RichyB are officially the winners. =) you can buy 2 beers each to yourself, but it would be more fun to buy two beers to each other =)
11:19:08 <elliott> hpc: you forgot unicode
11:19:14 <elliott> i'm revoking your agda license
11:19:27 <elliott> @check \x -> x /= NaN
11:19:28 <lambdabot>   Not in scope: data constructor `NaN'
11:19:30 <elliott> @check \x -> x /= (1/0)
11:19:31 <lambdabot>   "OK, passed 500 tests."
11:19:36 <elliott> proved
11:19:36 <RichyB> sΣ is totally a legal Haskell identifier, isn't it?
11:20:11 <hpc> :t let αλπηα = "alpha" in αλπηα
11:20:11 <RichyB> ghci thinks so. Might be a minor language extension for that.
11:20:12 <lambdabot> <no location info>: not an expression: `let'
11:20:24 <hpc> wut
11:20:38 <RichyB> hpc: the *initial* character has to be in ASCII [a-zA-Z]
11:20:59 <RichyB> But subsequent characters can be (IIRC) any unicode codepoint that counts as a character.
11:21:07 <hpc> gotcha
11:21:18 <elliott> erm
11:21:22 <elliott> RichyB: citation pls
11:21:26 <elliott> hpc: lambdabot just fails at unicode, that's all
11:21:26 <cmccann> what?
11:21:32 <cmccann> no, any lowercase letter is fine
11:21:36 <elliott> RichyB: (who on earth gave you that impression about the initial char?!)
11:21:36 <RichyB> elliott: try it in ghci and it works perfectly.
11:21:38 <cmccann> or rather
11:21:43 <elliott> yes, it does
11:21:44 <cmccann> any non-uppercase letter
11:21:45 <RichyB> Oh, [a-z] not [A-Z]
11:21:45 <elliott> which invalidates what you said
11:21:48 <elliott> no
11:21:51 <cmccann> since this is unicode
11:21:58 <elliott> it is not restricted to the latin alphabet at all
11:22:07 <cmccann> caseless letters are taken as lowercase by GHC I think
11:22:20 <RichyB> elliott: really? Oh.
11:22:50 <RichyB> Oh yeah that's it.
11:22:51 * cmccann notes that ℕ is a valid type
11:22:59 <RichyB> Σ isn't a legal function name because it's capitalised.
11:23:04 <RichyB> Duh. :)
11:23:16 <cmccann> yes
11:23:32 <RichyB> But it's a perfectly good name for, say, a data constructor for representing sums in abstract algebra or something! :D
11:23:40 <cmccann> you could use σ instead I guess :P
11:23:47 <elliott> hmm, does the conats have a standard fancy blackboardy superscripty name?
11:23:50 <elliott> *do
11:24:02 <elliott> i guess not
11:24:34 * cmccann uses Δ occasionally as a type constructor for types representing offsets or distances &c.
11:25:09 <neutrino> @hoogle Float -> Double
11:25:09 <lambdabot> Unsafe.Coerce unsafeCoerce :: a -> b
11:25:09 <lambdabot> Control.OldException throwDyn :: Typeable exception => exception -> b
11:25:10 <lambdabot> Control.DeepSeq ($!!) :: NFData a => (a -> b) -> a -> b
11:25:16 <neutrino> @hoogle Float -> a
11:25:17 <lambdabot> Unsafe.Coerce unsafeCoerce :: a -> b
11:25:17 <lambdabot> Prelude id :: a -> a
11:25:17 <lambdabot> Data.Function id :: a -> a
11:25:26 <neutrino> how do i get a Double from a Float?
11:25:29 <cmccann> neutrino, realToFrac?
11:25:49 <RichyB> @hoogle Float -> Double
11:25:50 <lambdabot> Unsafe.Coerce unsafeCoerce :: a -> b
11:25:50 <lambdabot> Control.OldException throwDyn :: Typeable exception => exception -> b
11:25:50 <lambdabot> Control.DeepSeq ($!!) :: NFData a => (a -> b) -> a -> b
11:25:52 <elliott> lambdabot's suggestion of unsafeCoerce is very helpful
11:25:54 <RichyB> ...
11:25:55 <cmccann> yes
11:25:56 <elliott> RichyB: neutrino just did that...
11:26:04 <cmccann> lambdabot knows what's best
11:26:05 <RichyB> That is possibly the least useful suggestion.
11:26:11 <elliott> hey, it works!
11:26:32 <RichyB> Only if you never evaluate the result. :P
11:26:34 <cmccann> anyway realToFrac is a nearly all-purpose conversion between fractional types
11:26:47 <RichyB> Hell, using the C FFI is more likely to work.
11:27:56 <elliott> Prelude Unsafe.Coerce> unsafeCoerce (123 :: Float) :: Double
11:27:56 <elliott> 5.55042295e-315
11:27:59 <elliott> Converted perfectly.
11:28:11 <elliott> I don't like realToFrac because its name reminds me of the Real typeclass. :(
11:28:30 <RichyB> elliott: great, now try that again on a 386. Bet you half a carrot it segfaults.
11:28:50 <elliott> I don't think GHCi can even run on a 386.
11:28:57 <elliott> Also, I would expect it to work the same if it did.
11:29:06 <elliott> unsafeCoerce's behaviour is predictable, just odd.
11:29:13 <cmccann> I still cannot begin to imagine why the class representing subsets of the rationals is called "Real"
11:29:21 <elliott> cmccann: because ML called floats "real", I bet
11:29:34 <elliott> cmccann: or the committee were constructivists, and thus take Rational to be isomorphic to R
11:29:51 <elliott> (latter is definitely more likely :P)
11:30:15 <RichyB> elliott: what? GHC works perfectly on i386.
11:30:18 <cmccann> nonsense, plenty of irrational numbers are fine constructively
11:30:28 <RichyB> Okay, you need an i686.
11:30:29 <cmccann> as long as you use a corecursive representation
11:31:22 <cmccann> then again the standard libraries really don't seem to have been designed with corecursion in mind other than "hey, lists are lazy!"
11:31:26 <RichyB> cmccann: because they're named after the thing that they attempt to emulate.
11:31:37 <lukish> I have some ghc one-liner with '' and "" quotes. How can I use it in shell with ghc -e ''?
11:31:38 <elliott> RichyB: i386 is not 386
11:31:49 <lukish> Quotes breaks all indentation
11:31:51 <elliott> "runs on i386" = runs on some subset of 386-y architectures
11:31:57 <monochrom> who says that Real is only for subsets of the rationals?
11:32:04 <elliott> @src Real
11:32:04 <lambdabot> class  (Num a, Ord a) => Real a  where
11:32:04 <lambdabot>     toRational      ::  a -> Rational
11:32:05 <elliott> toRational does
11:32:09 <elliott> cmccann: Q still has the same cardinality outside the system, though.
11:32:14 <elliott> (That of programs.)
11:32:20 <elliott> (But you can prove that R has a greater cardinality from inside.)
11:32:43 <elliott> or, hmm
11:32:57 <cmccann> elliott, and infinite lists are never actually infinite :P
11:33:02 <elliott> I'm not sure you /can/ prove |R| > |Q| in Coq with the usual construction
11:33:04 <monochrom> @src Integral
11:33:04 <lambdabot> class  (Real a, Enum a) => Integral a  where
11:33:05 <lambdabot>     quot, rem, div, mod :: a -> a -> a
11:33:05 <lambdabot>     quotRem, divMod     :: a -> a -> (a,a)
11:33:05 <lambdabot>     toInteger           :: a -> Integer
11:33:05 <cmccann> but anyway this is still computable reals
11:33:12 <monochrom> @src Num
11:33:12 <lambdabot> class  (Eq a, Show a) => Num a  where
11:33:13 <lambdabot>     (+), (-), (*)           :: a -> a -> a
11:33:13 <lambdabot>     negate, abs, signum     :: a -> a
11:33:13 <lambdabot>     fromInteger             :: Integer -> a
11:33:28 <elliott> Integral = subset of Z
11:33:30 <elliott> Real = subset of Q
11:33:44 <cmccann> Num = superset of Z
11:33:46 <cmccann> &c.
11:33:47 <elliott> Complex = subset of R, presumably
11:33:52 <monochrom> then fromInteger would say that each Num instance must be a superset of the integers, which kills Word8, which is a contradiction
11:34:04 <cmccann> there are a lot of bogus instances of Num out there, yes
11:34:06 <elliott> well, I expect toInteger/toRational to be lossless
11:34:13 <elliott> fromInteger being lossy is accepted
11:34:22 <elliott> it's only there for literals, after all
11:34:29 <cmccann> insofar as Num being terrible is accepted
11:34:29 <elliott> @instances Real
11:34:30 <lambdabot> Double, Float, Int, Integer
11:34:33 <Sgeo> You could always make a bogus Real
11:34:39 <Sgeo> That contains irrationals
11:34:40 <elliott> yes, but it'd be Wrong
11:34:48 <elliott> in a way distinct from the expected wrongness of Num
11:34:58 <carpi> is there a way to ask cabal to list the files on the filesystem that belong to a certain package?
11:35:03 <monochrom> alright, then go on with your complaints
11:35:18 <carpi> because I would like to unregister and delete a certain package
11:35:27 <monochrom> (pretty sure 20 years from now there will be no change)
11:35:41 <byorgey> does anyone know who is actually at the other end of mailman@haskell.org?
11:35:45 <elliott> monochrom: if the numeric typeclasses aren't fixed in 20 years I'm switching languages :P
11:35:53 <elliott> byorgey: gnu mailman?
11:36:19 <byorgey> elliott: who, not what. =)  I mean who (if anyone) ends up reading mail sent to it.
11:36:19 <monochrom> cabal knows nothing. lesson #1.
11:36:41 <elliott> byorgey: I assumed it was an automated address given the name, but ok
11:36:44 <monochrom> use "ghc-pkg describe" to find out where are files stored
11:36:57 <elliott> carpi: I suggest wiping your entire package database and starting over :P
11:37:01 <td123> cabal is not a package manager, learned that recently :(
11:37:16 <byorgey> elliott: I think the intention is that it goes to whoever administrates the mailman instance.
11:37:24 <monochrom> "cabal list" lies about which packages you have installed
11:37:26 <carpi> elliott: how would i do that?
11:37:28 <byorgey> at least, I thought that was the intention.
11:37:40 <carpi> monochrom: if nothing else works i think i wil try this
11:38:21 <monochrom> see my http://www.vex.net/~trebla/haskell/sicp.xhtml . eye-opener. you will never think the same of cabal again
11:38:51 <monochrom> you will find that almost every assumption you have made is vapour. all your world is undone.
11:38:52 <elliott> carpi: back up ~/.cabal/config, rm -r ~/.cabal ~/.ghc
11:39:02 <elliott> cabal update && move config back && install stuff as you need it
11:40:10 * cmccann really should revive one of his attempts at saner numeric classes now that the constraint kind stuff is around, it might help with some of the awkward bits
11:40:31 <cmccann> though I'm still not sure there's any way to make literals work sensibly without TH or hacking GHC
11:40:54 <kallisti> which function should I be using to do ByteString -> IO CString
11:41:18 <kallisti> should I convert to String and then use newArray0?
11:41:34 <cmccann> hey elliott, want to help me fix the numeric classes? just imagine how many instances you'll be able to write!
11:42:14 <xarch> hi
11:42:25 <xarch> how can I get a [Word8] from a Text?
11:42:41 <cmccann> xarch, does that even make sense?
11:43:00 <monochrom> kallisti: there are some things in Data.ByteString.Unsafe for you
11:43:19 <xarch> oh actually I found mysqelf
11:43:40 <xarch> sorry about that
11:43:42 <kallisti> xarch: you could convert to ByteString and then unpack that to [Word8]
11:43:48 <donri> depends on the encoding
11:43:49 <xarch> unpack . encodeUtf8 I think
11:44:07 <monochrom> you may actually like unsafeUseAsCString :: ByteString -> (CString -> IO a) -> IO a. make a copy of the CString.
11:44:08 <kallisti> yes, assuming that's the correct encoding.
11:44:23 <xarch> I think it is
11:44:36 <kallisti> xarch: why are you unsure?
11:44:53 <xarch> um
11:45:15 <xarch> actually there's probably no reason to be unsure
11:45:29 <kallisti> monochrom: maybe.
11:45:39 * hackagebot tamarin-prover-utils 0.1.0.0 - Utility library for the tamarin prover.  http://hackage.haskell.org/package/tamarin-prover-utils-0.1.0.0 (SimonMeier)
11:45:45 <xarch> well anyway I'm going to use a function which asks for a ByteString instead of [Word8]
11:46:04 <kallisti> xarch: why do you need ByteString exactly?
11:46:07 <kallisti> out of curiosity
11:46:16 <xarch> to hash it with SHA1
11:46:31 <xarch> http://hackage.haskell.org/packages/archive/SHA/1.4.0/doc/html/Data-Digest-Pure-SHA.html
11:46:31 <monochrom> interesting, Data.ByteString has useAsCString :: ByteString -> (CString -> IO a) -> IO a, too. this one is safer
11:46:52 <kallisti> monochrom: no that's the one I don't want.
11:47:06 <monochrom> how come?
11:47:22 <kallisti> monochrom: because it deletes the CString after the call, which isn't wanted in this case. the CString needs to linger around.
11:47:40 <kallisti> I guess I could do unsafeUseAsCString and then make a copy.
11:47:57 <monochrom> then you have to make a copy yourself. true for both useAsCString and unsafeUseAsCString
11:48:15 <kallisti> no, useAsCString makes the copy for you.
11:48:19 <kallisti> oh
11:48:19 <monochrom> but of course the unsafe version is cheaper
11:48:22 <kallisti> I see what you mean.
11:48:30 <elliott> kallisti: If you just use the CString, then GC will free your data from underneath.
11:48:37 <kallisti> yes
11:49:18 <kallisti> @hoogle newCString
11:49:18 <lambdabot> Foreign.C.String newCString :: String -> IO CString
11:49:18 <lambdabot> Foreign.C.String newCStringLen :: String -> IO CStringLen
11:49:22 <kallisti> :(
11:49:46 <neutrino> how can i force a value to evaluate in order to display it with traceShow
11:50:00 <elliott> neutrino: WHNF or NF?
11:50:02 <monochrom> but I'm thinking that maybe you should arrange your job to be done inside that function you pass, so that you don't need the cstring lingering around
11:50:16 <elliott> neutrino: i.e. to the first constructor or completely and utterly?
11:50:17 <neutrino> elliott: i don't understand your AIDU
11:50:25 <elliott> WHNF = weak head normal form, NF = normal form
11:50:41 * hackagebot tamarin-prover-term 0.1.0.0 - Term manipulation library for the tamarin prover.  http://hackage.haskell.org/package/tamarin-prover-term-0.1.0.0 (SimonMeier)
11:50:43 * hackagebot tamarin-prover 0.1.0.0 - The tamarin prover for security protocol analysis.  http://hackage.haskell.org/package/tamarin-prover-0.1.0.0 (SimonMeier)
11:50:44 <neutrino> elliott: enough that traceshow gets run
11:51:20 <kallisti> neutrino: you want to strictly evaluate the traceShow call itself then, in some other context.
11:51:50 <kallisti> (I think)
11:51:52 <elliott> neutrino: That depends on your code.
11:52:23 <elliott> neutrino: For instance, traceShow () [1, 42] -- WHNF is enough. [1, traceShow () 42] -- WHNF isn't enough.
11:53:19 <elliott> neutrino: Try importing Control.DeepSeq in GHCi and running rnf myExpr.
11:54:32 <kallisti> how do I copy a CString exactly?
11:54:41 <neutrino> thank you i will try rnf then
11:54:59 <neutrino> how can i ... make sure that the rnf gets evaluated though
11:55:03 * neutrino head asplode
11:55:20 <neutrino> falling down an infinite abbyss
11:55:25 <kallisti> neutrino: depends on your code. :)
11:55:32 <neutrino> NOOOOOOoooooooooooooo
11:55:45 <kallisti> neutrino: nah, it eventually terminates once you get to IO.
11:55:56 <neutrino> srsly, ghc should have a way of evaluating stuff.
11:56:01 <kallisti> it does.
11:56:02 <hpc> :t evaluate
11:56:02 <lambdabot> Not in scope: `evaluate'
11:56:06 <hpc> @hoogle evaluate
11:56:06 <lambdabot> Control.Exception.Base evaluate :: a -> IO a
11:56:07 <lambdabot> Control.Exception evaluate :: a -> IO a
11:56:07 <lambdabot> Control.OldException evaluate :: a -> IO a
11:56:08 <neutrino> hpc: HA
11:56:09 <hpc> @hoogle seq
11:56:09 <lambdabot> Prelude seq :: a -> b -> b
11:56:10 <lambdabot> Prelude sequence :: Monad m => [m a] -> m [a]
11:56:10 <lambdabot> Control.Monad sequence :: Monad m => [m a] -> m [a]
11:56:15 <hpc> @hoogle pseq
11:56:15 <lambdabot> GHC.Conc.Sync pseq :: a -> b -> b
11:56:15 <lambdabot> GHC.Conc pseq :: a -> b -> b
11:56:16 <lambdabot> Control.Parallel pseq :: a -> b -> b
11:56:32 <elliott> <neutrino> how can i ... make sure that the rnf gets evaluated though
11:56:36 <elliott> neutrino: Where are you trying to evaluate it?
11:56:41 <elliott> GHCi? Some other code?
11:56:47 <neutrino> well, somewhere deep in a function somewhere
11:56:56 <neutrino> it's something i execute with runhaskell
11:56:58 <neutrino> so it's ghc
11:57:19 <hpc> :t rnf
11:57:19 <lambdabot> Not in scope: `rnf'
11:57:22 <hpc> @hoogle rnf
11:57:22 <lambdabot> Control.DeepSeq rnf :: NFData a => a -> ()
11:57:26 <elliott> You sound confused about what you're trying to do. To use traceShow, you should annotate things that get evaluated.
11:57:32 <elliott> The whole point is observing the order of evaluation, after all.
11:58:27 <monochrom> what is the real question?
11:58:50 <kallisti> monochrom: I'm sorry you'll need to be more specific. What are you really asking?
11:59:17 <neutrino> elliott: well the thing is, sometimes some things don't yet have code that utilizes them
11:59:26 <neutrino> and because of laziness, they do not end up being evaluated
11:59:33 <neutrino> and traceshow doesn't show trace.
11:59:41 <hpc> kallisti: the original question is < neutrino> how can i force a value to evaluate in order to display it with traceShow
11:59:54 <hpc> kallisti: monochrom is asking "what do you want to do, not how"
12:00:09 <monochrom> that is correct behaviour. what's wrong with it?
12:00:11 <hpc> or better: "what do you need this for"
12:00:19 <kallisti> neutrino: are you familiar with seq, pseq, and $!
12:01:13 <neutrino> no
12:01:43 <neutrino> monochrom: i'm not going to answer your question
12:02:56 <monochrom> it's easy for a random stranger to say, "try deepseq, try rnf". but rnf adds its own order too. if you use rnf, you may be just seeing rnf's chosen order, not some more "natural" order. IOW you may be seeing artifacts of rnf instead.
12:03:12 <kallisti> a `seq` b partially evaluates a to what's known as weak-head normal form (something else you're probably not familiar with that I'm bad at explaining), and returns b. pseq does the same thing but ensures that a is always evaluated before b.
12:03:17 <kallisti> @src ($!)
12:03:17 <lambdabot> f $! x = x `seq` f x
12:03:32 <kallisti> neutrino: $! is strict function application, defined with seq.
12:04:29 <hpc> (weak head normal form is "patterh match on the top constructor" - for a list, (whnf x) is either ([]) or (xh:xt))
12:04:45 <hpc> ((where x, xh, xt are thunks)
12:04:46 <hpc> )
12:05:00 <elliott> neutrino: I think you should answer monochrom's question, because there is no way to evaluate anything that isn't evaluated.
12:05:12 <elliott> Just adding something local won't work; something has to be forced to be forced, by definition.
12:05:23 <elliott> There is almost certainly an easier way to achieve the debugging you're trying to do.
12:05:28 <c_wraith> by tautology, even
12:05:42 <kallisti> there's likely just a point where he needs to apply seq.
12:06:06 <elliott> neutrino: Anyway, if things aren't being utilised, why do you need to debug them?
12:06:22 <kallisti> but we have no way to know for sure without seeing code, or without teaching neutrino every detail of GHC's evaluation model so that he can find it himself.
12:06:44 <elliott> kallisti: Well, we already know they're not going to tell us what the real question is, so I guess it'll have to be the latter.
12:07:25 <kallisti> elliott: basically he wants to debug part of his program before writing the part that uses it. Seems reasonable to me. at least in many circumstances.
12:07:57 <monochrom> so craft a unit test that uses the debugee
12:08:08 <kallisti> neutrino: you may also want to write a new main that simply prints the result of calling the specific piece of code you want to test.
12:09:35 <elliott> kallisti: I don't believe anybody is sufficiently psychic to know that it's reasonable, since I've never once had to use non-local seqs when debugging with trace.
12:09:57 <elliott> But maybe we should just drop it, since neutrino has explicitly stated they don't want to give us the details we need to answer.
12:10:25 <kallisti> elliott: well, no. I didn't mean using seq was reasonable. I meant debugging something that currently isn't being used is reasonable. simply writing a quick main function as I said is probably a reasonable way to achieve that.
12:10:56 <cmccann> or you know, write some quickcheck properties to test it
12:11:23 <cmccann> anything that isn't forced by reasonable quickcheck tests probably doesn't need to be forced in most cases
12:12:17 <kallisti> neutrino: I think that's about all the help we can give with the info we have. hope that helps.
12:12:33 <elliott> I don't think they're talking to us any more.
12:12:39 <kallisti> yeah, I noticed that.
12:12:43 * kallisti shrugs.
12:17:28 <neutrino> wow you guys have really been working while i was gone
12:18:43 <elliott> For some value of "working".
12:19:12 <neutrino> < kallisti> elliott: basically he wants to debug part of his program before writing the part that uses it. << that's exactly what i'm doing
12:19:20 <jhally> ciao
12:19:23 <jhally> !list
12:19:31 <elliott> neutrino: Well, show some code or tell us the bigger picture, or we can't help.
12:20:39 <neutrino> elliott: i just didn't want to answer monochrom's question, since i stated a direct answer to it in the line he replied to with that question
12:20:44 <neutrino> so i thought he was only trolling
12:20:57 <elliott> I agree with hpc - <hpc> kallisti: monochrom is asking "what do you want to do, not how"
12:21:02 <neutrino> elliott: it's just a general thing i noticed, i often write code that generates some data
12:21:11 <neutrino> and i still am not using it anywhere, but i want to look inside
12:21:17 <elliott> well, that's what GHCi is for
12:21:20 <elliott> poking at code
12:21:44 <neutrino> it's fairly cumbersome to use ghci for many things though
12:21:49 <neutrino> like right now i'm writing this parser
12:21:50 <neutrino> btw
12:21:56 <neutrino> i was gonna ask about this
12:22:01 <neutrino> i have this parser written in parsec
12:22:34 <Mike____> Hello again,I'm trying to change 3 values between 2 structures, and cant seem to be able to do it, ive been trying alot of things
12:23:03 <neutrino> and it's defined this way, basically: it mostly parses things linewise, and first off it finds a special line which defines the beginning of a "section". then it finds a header inside that section which is sure to be there, and uses the line right under that header as one of the values returned by the parser
12:23:20 <neutrino> now, the file format has changed, and has extra things in it
12:23:36 <neutrino> between the "section beginning" and the "header" i have several optional parameters
12:24:34 <neutrino> right now the parser i am using for the "header" part looks like this: given a line, either parse the current line as a header, or throw it away and repeat for the next line
12:25:07 <neutrino> i need to somehow parse what's being thrown away for the optional stuff..
12:25:32 <neutrino> i think maybe i could just take the strings i am throwing away, concatenate them, and re-parse them? would that work?
12:25:42 <neutrino> sounds like a good idea. let me try that
12:26:00 <kallisti> > show . (fromString :: String -> ByteString) $ "hello"
12:26:01 <lambdabot>   Not in scope: type constructor or class `ByteString'Not in scope: `fromStri...
12:26:14 <neutrino> Bytestring ?
12:26:24 <neutrino> > read "asdf" :: Bytestring
12:26:25 <lambdabot>   Not in scope: type constructor or class `Bytestring'
12:26:28 <neutrino> o
12:26:35 * neutrino sucks at that
12:26:44 <kallisti> > read "asdf" :: BS.ByteString
12:26:45 <lambdabot>   "*Exception: Prelude.read: no parse
12:26:55 <kallisti> > read "\"asdf\"" :: BS.ByteString
12:26:56 <lambdabot>   "asdf"
12:26:59 <scooty-puff> :set -XOverloadedStrings
12:27:01 <kallisti> there we go. that's what I needed to know.
12:27:02 <scooty-puff> meh
12:27:05 <neutrino> interesting
12:27:15 <neutrino> scooty-puff: i wish we could do that with numbers!
12:27:22 <neutrino> -XOverloadedNums
12:27:24 <neutrino> :(
12:27:35 <kallisti> >_>
12:27:36 <neutrino> i have fromIntegral and realToFrac everywhere
12:27:42 <scooty-puff> :info IsString
12:27:46 <kallisti> neutrino: numberic literals are overloaded
12:27:47 <geekosaur> numbers are already overloaded, just make something an instance of Num
12:27:48 <cmccann> neutrino, there's always RebindableSyntax
12:27:50 <neutrino> so annoying
12:27:51 <scooty-puff> i have no clue about the commands here..
12:27:55 <neutrino> kallisti: but not non-literals :(
12:27:58 <neutrino> like length etc
12:28:08 <cmccann> that's just a limitation of the standard libraries
12:28:12 <geekosaur> also, things like genericLength
12:28:40 <kallisti> :t genericLength
12:28:41 <lambdabot> forall b i. (Num i) => [b] -> i
12:29:28 <cmccann> hm
12:30:11 <cmccann> elliott, I wonder if some of the standard list functions would be meaningful in the context of Align instances somehow
12:30:22 <kallisti> neutrino: just use overloaded functions and there's no problem. :>
12:30:34 <cmccann> elliott, particularly thinking stuff like splitAt
12:30:53 <hpaste> gatlin pasted “SAT Solver” at http://hpaste.org/63415
12:30:53 * hackagebot tamarin-prover 0.1.1.0 - The tamarin prover for security protocol analysis.  http://hackage.haskell.org/package/tamarin-prover-0.1.1.0 (SimonMeier)
12:37:48 <tromp__> @src listToMaybe
12:37:48 <lambdabot> listToMaybe []        =  Nothing
12:37:49 <lambdabot> listToMaybe (a:_)     =  Just a
12:38:08 <tromp__> @src fromList::[a]->Maybe a
12:38:08 <lambdabot> Source not found. Maybe if you used more than just two fingers...
12:38:53 <tromp__> > fromList "foo" :: Maybe Char
12:38:54 <lambdabot>   Couldn't match expected type `(GHC.Types.Char, GHC.Real.Rational)'
12:38:55 <lambdabot>         ...
12:39:11 <cmccann> :t fromList
12:39:12 <lambdabot> forall a (m :: * -> *). (MonadRandom m) => [(a, Rational)] -> m a
12:39:19 <cmccann> I don't think that's what you wanted
12:39:26 <tromp__> clearly not
12:39:35 <alpounet> @hoogle Maybe a -> [a]
12:39:36 <lambdabot> Data.Maybe maybeToList :: Maybe a -> [a]
12:39:36 <lambdabot> Data.Foldable toList :: Foldable t => t a -> [a]
12:39:36 <lambdabot> Data.Maybe catMaybes :: [Maybe a] -> [a]
12:40:19 <osager> hi all: may i know why my function give error? myfunc:: int->int
12:40:27 <osager> myfunc n
12:40:36 <osager> | n == 1 = 0
12:40:40 <cmccann> osager, int is not Int
12:40:43 <mauke> broken indentation
12:40:45 <cmccann> if that's your actual type signature
12:41:14 <cmccann> osager, also, use hpaste to show code
12:41:16 <osager> No instance for (Eq int) arising from a use of `==' In the expression: n == 1
12:41:28 <osager> ok thank you for the hpaste hint
12:41:31 <jedai> :t M.fromList
12:41:32 <lambdabot> forall k a. (Ord k) => [(k, a)] -> M.Map k a
12:41:36 <cmccann> osager, you want Int
12:41:46 <cmccann> osager, Haskell is case sensitive
12:41:51 <osager> OK cmccann i'll try
12:42:56 <osager> hpaste
12:43:02 <osager> how to use hpaste ?
12:43:19 <cmccann> @where hpaste
12:43:20 <lambdabot> http://hpaste.org/
12:44:18 <cmccann> osager, but I've already answered your question twice this time :P
12:44:43 <osager> yes cmccann i've tried. but i got a new error
12:44:56 <osager> so i want to paste the whole function code
12:45:01 <cmccann> ok
12:45:19 <osager> so i need to paste my code in hpaste.org and then copy the link here ?
12:45:35 <cmccann> yes, but usually a bot will give the link automatically
12:45:44 <osager> wow cool
12:45:46 <osager> i'll try
12:46:41 <hpaste> osager pasted “how to correct this code” at http://hpaste.org/63417
12:46:49 <zzo38> I have another proposal: If you put a question mark after the name of any extension in a LANGUAGE pragma, then it will just skip that one if it cannot support it. (It might be useful for compatibility extensions, such as NPlusKPatterns)
12:47:23 <mauke> osager: you can't use / on Ints
12:47:56 <osager> what if i want to ?
12:48:09 <cmccann> if you want integer division, use "div"
12:48:11 <zzo38> osager: You need div, I think
12:48:11 <cmccann> :t div
12:48:12 <lambdabot> forall a. (Integral a) => a -> a -> a
12:48:27 <zzo38> Another idea is -XNoLayoutPragmas which should disable layout in pragmas
12:48:28 <cmccann> if you want non-integral results, use a different type
12:48:36 <osager> OK
12:48:47 <osager> thanks
12:48:49 <dolio> zzo38: If it doesn't support the extension, what is it going to do with your code?
12:50:04 <zzo38> dolio: In my first case, for example if you enter {-# LANGUAGE NPlusKPatterns? #-} then if it does not recognize that extension, it is probably Haskell 98 which already supports n+k patterns. If it doesn't support the extension with a question mark then it parses the code as if you did not specify that extension
12:50:48 * cmccann thinks "not using n+k patterns" is the better solution in that case
12:51:08 <zzo38> cmccann: I agree; I hate n+k patterns too. But I was simply giving an example.
12:51:32 <dolio> So, this is only useful for extensions that add features that have been removed from past language versions back into the language?
12:52:17 <zzo38> dolio: Well, for any compatibility purposes at all, really. For example if a later version implements an extension which tells it to make it compatible with older version, and so on
12:52:17 <elliott> cmccann: hmm, interesting idea; what type would splitAt have? (Align f) => Int -> f a -> (f a, f a)?
12:53:00 <cmccann> elliott, I'm not sure, it just occured to me that splitAt is closely related to unalign
12:53:27 <zzo38> (Well, I did propose an extension -XNaturakNumberKind which has its own n+k patterns, usable both in type patterns and value patterns, with mostly the same purpose as Haskell98 n+k patterns but not compatible with them)
12:53:41 <elliott> cmccann: right, I was thinking that it'd have to be Unalign
12:54:03 <cmccann> elliott, the general idea being unaligning based on structural information rather than parametric
12:54:15 <cmccann> which you can't do with just unalign, I expect
12:54:49 <cmccann> but I'm trying to decide if there's any useful concepts that can be extracted beyond specific types
12:55:20 <cmccann> since this is, by definition, dealing with the non-parametric part of the type
12:55:56 <elliott> @src splitAt
12:55:56 <lambdabot> splitAt n xs           =  (take n xs, drop n xs)
12:56:34 <hpaste> osager pasted “how to print while excuting a code” at http://hpaste.org/63418
12:56:37 <elliott> cmccann: well, splitAt n = unalign . mapSplit n This That... but that's obvious :P
12:56:44 <elliott> where mapSplit applies first function to first n and second function to the rest
12:57:12 <cmccann> elliott, yes, something like mapSplit makes sense for the underlying operation
12:57:35 <hpaste> Mike annotated “rubik” with “rubik (annotation)” at http://hpaste.org/63412#a63419
12:57:56 <elliott> cmccann: hmm... presumably to generalise, we'd want to be polymorphic on the key type
12:58:04 <cmccann> something that reflects structural information into the parametric part, sort of a generalized "ask" or "get"
12:58:20 <zzo38> Are you ever going to implement -XDefaultInstances extension I have proposed? Some other people have agreed with such thing the way I wrote it, I think including Edward Kmett, but also some people in #esoteric channel.
12:58:27 <elliott> cmccann: splitAt k = unalign . mapWithKey (\k' -> if k' <= k then This else That)
12:59:00 <elliott> cmccann: which leads to the obvious generalisation splitKey p = unalign . mapWithKey (\k -> if p k then That else This)... and isn't there an edwardk package for keyed stuff? :P
12:59:11 <elliott> yep: http://hackage.haskell.org/packages/archive/keys/2.1.2/doc/html/Data-Key.html mapWithKey
12:59:16 <hpaste> ovechkin pasted “type error” at http://hpaste.org/63420
12:59:20 <cmccann> I forget exactly what that package does
12:59:24 <elliott> so... you can do interesting things for (Unalign f, Keyed f)
12:59:31 <cmccann> but yeah, the representable functors stuff is the base level
12:59:41 <elliott> cmccann: well Key [] = Int
12:59:45 <ddarius> "I totally have to agree with the crazy screaming guy on this one."
12:59:54 <ovechkin> i am trying to map a function that involves a Double over a list of Integers. what is the proper way to do this?
13:00:03 <ovechkin> code pasted in link above
13:00:51 <cmccann> or wait, yeah, the keys stuff is actually a dependency of representable-functors, nevermind
13:00:57 <elliott> cmccann: wait, that splitAt definition isn't right of course
13:01:03 <elliott> since it leaves Nothings around
13:01:09 <elliott> hmm
13:01:18 <cmccann> well, our unaligning stuff should
13:01:21 <cmccann> so that it can be recombined
13:01:46 <cmccann> insofar as align is a structural union, this is a structural difference I guess
13:02:02 <cmccann> whereas zip is a structural intersection
13:02:39 <ovechkin> elliott: any suggestions for what i should look into?
13:02:41 <cmccann> anyway, I'm happy with unaligning stuff leaving Nothings where the removed elements were
13:03:00 <cmccann> and then just discarding those as needed to implement something closer to splitAt
13:03:43 <elliott> ovechkin: hmm?
13:03:54 <elliott> ovechkin: map (foo . fromIntegral)
13:03:57 <amstan> so, i would like to try a haskell tutorial, i run archlinux
13:04:09 <elliott> amstan: http://learnyouahaskell.com/
13:04:10 <amstan> what packages should i install to get the interpreter and a base system
13:04:16 <elliott> amstan: for arch, just install the haskell-platform package
13:04:41 <amstan> elliott: cool, thanks
13:04:55 <alpounet> cmccann, elliott, what's that Align thing you've been talking about?
13:05:17 <elliott> alpounet: alignable functors
13:05:35 <elliott> alpounet: http://pchiusano.blogspot.com/2010/06/alignable-functors-typeclass-for-zippy.html
13:05:58 <cmccann> alpounet, two dozen lines from my utility library that I put on github and then it went out of control thanks to elliott
13:06:14 <elliott> alpounet: https://github.com/isomorphism/these/blob/master/Data/Align.hs is the implementation in question (additionally including Unalign, Crosswalk and Bicrosswalk; there's Haddocks inside)
13:06:15 <cmccann> and someone linking to the aforementioned blog entry
13:06:20 <amstan> i've used scheme before, so this should be fairly easy right?
13:06:21 <neutrino> hey guys how do i debug an error like this?
13:06:27 <neutrino> mysqlsla-plotter.hs: Prelude.head: empty list
13:06:30 <elliott> amstan: it'll be easier, but not easy by a long shot
13:06:30 <neutrino> that's ALL.
13:06:44 <elliott> amstan: Scheme is functional, but it's strict, impure, and dynamically-typed -- Haskell is a very different language
13:06:48 <cmccann> neutrino, well, find everywhere you're using head
13:06:52 <cmccann> and then stop using head
13:06:53 <neutrino> NOOOOOooooooooooooo
13:07:19 <elliott> amstan: common advice to beginners is to forget everything you know -- you can probably hold on to your Scheme knowledge, but you'll have to resist the temptation to skip sections of LYAH that look like things you already know :)
13:07:31 <elliott> it'll certainly be easier than someone coming from C or Python, though
13:07:49 <amstan> elliott: i was given the same advice when i started learning scheme, lol
13:08:01 <zzo38> To me, knowing a few things about mathematics helps a bit to learn Haskell programming
13:08:17 <zzo38> And reading the Haskell 2010 report
13:08:28 * cmccann came from being comfortable in Scheme and Python and found Haskell's type system the only thing that wasn't easily picked up
13:08:38 <cmccann> of course, the type system is a pretty big part :P
13:08:39 <elliott> I would very strongly anti-suggest reading the Haskell Report as introductory material.
13:08:49 <amstan> oh cool: "if a function is called twice with the same parameters, it's guaranteed to return the same result", so i'm assuming there's some optimization magic happening there?
13:08:59 <elliott> No.
13:09:03 <amstan> i remember i wrote a scheme program once and it calculated a function twice for some reason
13:09:05 <cmccann> amstan, no, that's what functions are
13:09:25 <elliott> amstan: It's a fact of the language's semantics that functions are referentially transparent.
13:09:28 <elliott> (Return the same result for all arguments.)
13:09:32 <amstan> i did something like (+ (bigfunction 2 3) (bigfunction 2 3))
13:09:36 <elliott> (And "result" includes any side-effects.)
13:09:43 <elliott> amstan: Haskell compilers do not generally perform memoisation by default, no.
13:09:47 <elliott> It hinders more than it helps performance.
13:09:54 <cmccann> amstan, that's going to be evaluated twice in almost any language
13:09:56 <elliott> However, memoising Haskell functions is very easy thanks to referential transparency.
13:10:11 <elliott> amstan: That specific example will probably share the computation thanks to GHC's common subexpression elimination.
13:10:16 <elliott> But it's very conservative, to avoid space leaks.
13:10:17 <alpounet> cmccann, elliott, alright, i guess i have some reading to do now heh, thanks
13:10:28 <elliott> alpounet: hehe, there's not all that much to it
13:10:48 <elliott> alpounet: you know how "zipping" (like on lists) discards parts of the structure that aren't shared by the arguments?
13:10:50 <cmccann> alpounet, ever wanted to zip two lists while padding the shorter instead of truncating the longer one?
13:11:07 <elliott> alpounet: alignment is just like zipping, except instead of taking the intersection of the two structures, it takes the union
13:11:13 <cmccann> that's the original motivation of the whole thing, basically
13:11:17 <ddarius> elliott: GHC rarely does common subexpression elimination.
13:11:19 <elliott> tagging each "leaf" with which structure it came from or both
13:11:32 <elliott> ddarius: I think the CSE will catch bigfunction 2 3 + bigfunction 2 3.
13:11:36 <hpaste> Gonçalo pasted “L0d” at http://hpaste.org/63423
13:11:40 <elliott> But I don't have any evidence.
13:11:41 <ddarius> elliott: Why do you think that?
13:12:05 <elliott> ddarius: It's a hunch.
13:12:12 <cmccann> elliott, I'm almost certain it won't if that's polymorphic
13:12:22 <alpounet> there was an email by SPJ stating a few rare cases when CSE occurs
13:12:38 <elliott> Oh, if it's polymorphic, yes.
13:12:42 <elliott> But on Int I would expect it to.
13:13:37 <alpounet> elliott, cmccann, yeah i get the idea, that's nice!
13:14:14 <alpounet> i just got scared. used to all these crazy edwardk stuffs
13:14:44 <elliott> alpounet: Don't worry, these is rapidly gaining edwardk dependencies in an attempt to keep up.
13:15:01 <cmccann> well, I come up with silly names and mostly forget to document stuff clearly, and elliott likes writing dozens of instances
13:15:06 <cmccann> so between us we're getting there
13:15:20 <elliott> haha
13:15:29 <cmccann> I think we need rwbarton to help with the abstract nonsense though
13:15:37 <elliott> yes
13:15:40 <elliott> that'll help with the silly names, too
13:15:41 <cmccann> that one paragraph is a good start but it's not enough
13:16:00 <alpounet> elliott, hah yeah well you still probably have something like 40 dependencies to add i guess
13:16:11 <elliott> we need a name for our unstoppable team, like Bourbaki; people won't be as impressed if it's three people
13:16:26 <elliott> (wait, do we know edwardk is one person?)
13:16:51 <cmccann> if not, he at least has a consistent figurehead for public appearances
13:17:00 <cmccann> but I suppose we can't rule it out
13:17:22 <alpounet> him being 3 or 4 persons would be more plausible than one actually
13:17:44 <cmccann> on the other hand being a collective would explain the quantity of sodapop he apparently has
13:17:59 <elliott> cmccann: well, they could have a PR guy
13:18:03 <elliott> maybe he's an entire company
13:18:07 <elliott> I'd like to see the documentation team
13:18:28 <alpounet> haha
13:18:40 <elliott> motto: "little by little"
13:19:14 <cmccann> anyway, yeah, I think the keys stuff plus unalign handles everything I was thinking of
13:19:18 <RichyB> cmccann: the consistent figurehead thing isn't guaranteed either. Plastic surgery is scarily convincing these days.
13:19:24 <chridi> hi, I've written a sic clone (very minimalistic irc client) in haskell...
13:19:25 <chridi> https://github.com/chridi/sic.hs/blob/master/sic.hs
13:19:35 <cmccann> hm
13:19:41 <elliott> cmccann: it's interesting because splitAt would correspond to Data.Map's partition.
13:19:42 <amstan> noob question: why do i get a different errors from running succ "A" and succ True
13:19:44 <chridi> can anyone give me some feedback if this is realy the way i should do it?
13:19:53 <amstan> *** Exception: Prelude.Enum.Bool.succ: bad argument
13:19:58 <elliott> amstan: because Bool is an instance of Enum
13:20:01 <elliott> it's just that True has no successor
13:20:06 <elliott> (succ False works, as does pred True)
13:20:09 <amstan> oh, lol
13:20:11 <elliott> but String isn't an instance of Enum at all
13:20:19 <amstan> what's enum?
13:20:26 <amstan> oh.. like enums in C?
13:20:29 <elliott> the typeclass (no relation to OOP) that provides succ and pred, among others
13:20:34 <cmccann> elliott, actually, I think a notion of distance between keys is partly what I'm after
13:20:48 <elliott> amstan: no, it's named after enumeration
13:20:49 <cmccann> to account for things like drop and take behaving as expected
13:20:50 <elliott> s
13:20:52 <elliott> in general
13:21:04 <elliott> amstan: hehe, maybe wait until you're a little further on before explaining typeclasses :P
13:21:24 <cmccann> enumerate :: (Enum a, Bounded a) => [a] remains one of my favorite utility functions
13:21:39 <elliott> cmccann: hmm, what do you expect take to do on a Map?
13:21:48 <elliott> left one has Justs for the smallest n keys, right one has Justs for all the others?
13:21:53 <amstan> elliott: well, i got to the succ lesson and tried calling it with different args
13:22:59 <cmccann> elliott, truncate the Map based on the key ordering, of course
13:23:07 <qpu> cool, first time i've seen "my brain just exploded" error message from ghc :D
13:23:25 <elliott> qpu: congrats!
13:23:35 <elliott> cmccann: right (no truncation)
13:23:42 <elliott> cmccann: (unalign doesn't throw away information, after all)
13:24:00 <amstan> is there a reverse of the infix operator?
13:24:04 <amstan> so i can do * 2 3?
13:24:11 <qpu> (*)
13:24:17 <cmccann> elliott, well yeah
13:24:22 <amstan> qpu: cool
13:24:22 <elliott> (*) 2 3, yeah
13:24:35 <Mike____> is it possible for haskell to recieve inputs like the function getch() in c?
13:24:44 <elliott> Mike____: that's ncurses
13:24:56 <elliott> but you probably just want hSetBufering stdin NoBuffering
13:25:01 <Mike____> i'm sorry, what is ncurses?
13:25:08 <elliott> the library that provides getch()
13:25:12 <Mike____> oh
13:25:19 <cmccann> elliott, anyway the idea is that the ordering of the Map's keys can stand in for the obvious sequential ordering in a list
13:25:25 <elliott> but you can get input without having to hit enter using hSetBuffering like that
13:25:29 <elliott> cmccann: right
13:25:38 <Mike____> exactly
13:25:51 * elliott has been trying to think of an instance of Align that isn't an instance of Unalign, or an instance of Align that is more like a "computation" than a data structure, but hasn't thought of any :(
13:25:58 * hackagebot stm-conduit 0.2.2.1 - Introduces conduits to channels, and promotes using  conduits concurrently.  http://hackage.haskell.org/package/stm-conduit-0.2.2.1 (ClarkGaebel)
13:26:04 <elliott> (a structure with a (->) in it would count, that isn't just a boring lift instance :P)
13:27:04 <fryguybob> fg
13:27:34 <elliott> fryguybob &
13:27:40 <cmccann> heh
13:28:00 <Mike____> what do you mean elliott? how would I recieve an input without having to press enter?
13:28:10 <cmccann> elliott, if you had some sort of FRP-ish thing you might be able to define align using time as the key
13:28:36 <elliott> Mike____: hSetBuffering stdin NoBuffering then just use getChar as normal
13:28:37 <fryguybob> :D
13:29:03 <cmccann> elliott, so maybe some version of the automaton arrow stuff + extra invariants on top to make it interesting
13:29:09 <elliott> cmccann: if only the entire history of FRP implementation wasn't the history of getting rid of the (Time ->) :P
13:29:13 <neutrino> hey guys how can i do this better? bar = do { x <- foo; return (snd x) }
13:29:20 <elliott> yes, automaton arrow could work
13:29:26 <elliott> neutrino: fmap snd foo
13:29:33 <fryguybob> Anyone have some tips on geting Repa to be parallel?
13:29:39 <neutrino> @type fmap
13:29:40 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
13:29:44 <gatlin> elliott: just so you know your patience wasn't in vain, my studies have (I think) yielded fruit https://gist.github.com/1755736
13:29:51 <neutrino> hmm.
13:30:07 <neutrino> elliott: thanks
13:30:23 <elliott> gatlin: hehe, looks good to me!
13:30:56 <elliott> gatlin: btw... you actually *could* use the maybe monad in one place there
13:31:03 <gatlin> :)
13:31:07 <elliott> well, you already use it with "return", but you could use the bind
13:31:27 <elliott> gatlin: btw, all of your "do"s are redundant, i.e. you can simply remove the "do"
13:31:43 <gatlin> that occurred to me
13:31:44 <elliott> but you can do (ha): dpll (SolverState f r) = do { l <- chooseLiteral f; case dpll (SolverState (simplify f l) (l:r)) of ... }
13:31:47 <elliott> to simplify your second clause
13:31:59 <cmccann> elliott, yeah, I'm thinking a bunch of halting-automaton arrows plus an absolute notion of time used to indicate when an automaton should start running
13:32:01 <cmccann> or something like that
13:32:12 <cmccann> if you have a way to compose those in parallel
13:32:15 <ddarius> "To get the full SoC documentation you would need to sign an NDA with Broadcom, who make the chip and sell it to us. But you would also need to provide a business model and estimate of how many chips you are going to sell."
13:32:16 <elliott> cmccann: hmm, do they need halting to be unaligned?
13:32:29 <cmccann> elliott, to make it non-trivial
13:32:43 <cmccann> also, I was thinking Align
13:32:52 <elliott> oh, right
13:33:20 <elliott> i'm not sure you need a "global" notion of time
13:33:24 <elliott> you can just count it globally
13:33:35 <elliott> "value of aut at time t" is just the value after running aut t steps
13:33:57 <tgeeky> elliott: what is the domain of discussion here?
13:34:18 <elliott> tgeeky: (Un)alignable functors
13:34:40 <elliott> tgeeky: zips take the intersection of the two structures; alignments take the union: http://pchiusano.blogspot.com/2010/06/alignable-functors-typeclass-for-zippy.html
13:34:42 <cmccann> elliott, yeah, I'm just thinking of vaguely plausible things that would make (un)align not reduce to merely (un)zipping streams
13:34:46 <qpu> where can i find the instance declaration for Show List… is it basically instance (Show a) => Show (List a) ?
13:34:52 <alpounet> fryguybob, what do you mean?
13:35:02 <elliott> tgeeky: plus https://github.com/isomorphism/these/blob/master/Data/Align.hs for the implementation in question + the extra typeclasses (like Unalign)
13:35:29 <alpounet> fryguybob, isn't +RTS -N2/3/whatever doing this for you?
13:35:32 <elliott> cmccann: right
13:35:50 <cmccann> not necessarily an implementation I intend to use :P
13:36:40 <qpu> oh, :info [] indicates GHC.Show, ignore my bumbling!
13:36:50 <elliott> qpu: what's List?
13:36:52 <elliott> oh, []
13:36:58 <elliott> yes, it's (Show a) => Show [a]
13:37:02 <fryguybob> alpounet: It appears not to.  I'm using sumAll on some one dimensional arrays of lenght 1024 and -N4 shows no speedup.
13:37:13 <cmccann> elliott, also I'd guess that every Align instance will have an Unalign instance
13:37:24 <elliott> cmccann: I guess that too, but can't think of any
13:37:25 <alpounet> fryguybob, no speedup at all?!
13:37:29 <alpounet> try -N3?
13:38:37 <cmccann> elliott, for that matter, does Unalign even need Align as a constraint?
13:38:38 <fryguybob> If I do +RTS -s should I see SPARKS: 0
13:38:45 <elliott> fryguybob: you compiled with -threaded -O2, right? :P
13:38:59 <elliott> cmccann: well, the nil law is important, which is why I added it
13:39:03 <fryguybob> right :D, also tried -Odph
13:39:13 <cmccann> elliott, true
13:39:33 <cmccann> elliott, but point is, I think the only restriction on Unalign instances is that they play nicely with the matching Align instance
13:39:33 <elliott> cmccann: I wanted to relate it more directly to align in the laws but that didn't happen yet
13:40:03 <elliott> cmccann: hmm...
13:40:07 <elliott> cmccann: the nil law might be redundant
13:40:16 <elliott> you can derive it from the fmap-based laws, I think
13:40:31 <cmccann> merely satisfying unalign's type signature should be possible for any Functor, without even needing an Unalign class
13:40:55 <elliott> yes, indeed, but unalign expresses something stronger
13:41:05 <cmccann> right
13:41:09 <elliott> for the same reason that the default instance doesn't always "work"
13:43:09 <cmccann> hm
13:43:17 <cmccann> ok, I'd forgotten what all was in the keys package
13:43:25 <alpounet> fryguybob, well, ask on the appropriate place (parallel-haskell ML? SO?), but maybe repa isn't partitionning the array so you just still have only one core actually doing smth?
13:43:28 <tgeeky> so can you compose an align-able and an un-alignable functor?
13:43:43 <elliott> tgeeky: not sure what you mean, compose them to produce what?
13:43:46 <elliott> oh
13:43:50 <elliott> tgeeky: it's not un-alignable
13:43:51 <elliott> it's unalign-able
13:44:04 <elliott> unalign isn't the opposite of align, more like an inverse
13:44:11 <cmccann> I'm thinking we can define some useful functions based on the key stuff + (un)align
13:44:19 <cmccann> tgeeky, think zip vs. unzip
13:44:26 <tgeeky> elliott: right, so can you compose the elements like in groups, to retain the identity?
13:44:31 <tgeeky> s/retain/generate/
13:44:52 <fryguybob> alpounet: ok.  Just making sure that there wasn't some magic switch to get things going.  I'll try and make a simpiler example.
13:44:58 <elliott> tgeeky: Unalign has Align as a superclass
13:45:01 <elliott> so I'm not sure your question makes sense
13:45:16 <tgeeky> elliott: yeah, that's what I was wondering, essentially. Could that situation be reversed?
13:45:26 <alpounet> fryguybob, no no, you really do run it in parallel only with +RTS -N<k>
13:45:27 <tgeeky> Can you write unalign first and make it a superclass of align?
13:45:31 <alpounet> that's all
13:45:40 <elliott> tgeeky: well, sure, you could
13:45:53 <cmccann> tgeeky, note the above conversation about how Unalign is only non-trivial in the context of laws relating it to Align :P
13:46:10 <elliott> (which we don't yet have :( )
13:46:11 <tgeeky> cmccann: I haven't been reading, I just am looking at this source code
13:46:17 <cmccann> ah
13:46:55 <elliott> tgeeky: it is my suspicion that not every alignable functor is an unalignable functor according to the laws we'd like but don't yet know
13:47:41 <cmccann> elliott, we probably have some potential laws relating Align to Data.Key.Zip
13:47:55 <cmccann> but they're mostly obvious
13:48:09 <elliott> cmccann: you'd need discard
13:48:10 <cmccann> "these interact like union and intersection should" :P
13:48:36 <ddarius> Complete bounded lattice?
13:49:12 <elliott> cmccann: (I think)
13:50:35 <cmccann> ddarius, given an Applicative instance compatible with Zip, I guess?
13:51:21 <neutrino> hey guys i have structured my parser like this: it takes the string, and returns 3 values it can always parse. Then there is an optional part to the input string. It gets returned by the subparsers which would normally eat up and throw away that part. I now want to write a completely separate parser, separately invoked with Text.ParserCombinators.Parsec.parse. does that sound like a good idea?
13:51:49 <neutrino> this separate thing will be used inside the original parser.
13:53:23 * cmccann doesn't think we have anything that's clearly a "full" structure to be the counterpart of nil
13:53:43 <cmccann> unless there's an Applicative instance with an appropriate pure
13:55:10 * elliott wants to know what the original blog post author meant with "injecting" a reducer into an alignable functor
13:55:12 <elliott> that sounds fun
13:55:28 <elliott> cmccann: that pure works for ZipLists but would break []
13:55:40 <elliott> (otoh []'s Align instance is already pretending to be ZipList compared to its Applicative instance)
13:55:45 <cmccann> elliott, yeah
13:56:04 <gregATio> sorry C-x C-b
13:56:25 <elliott> C-x C-b forgives you.
13:56:31 <cmccann> elliott, on the other hand Zip from keys also uses... well, zip
13:56:47 <elliott> cmccann: yeah :P
13:57:08 <elliott> cmccann: it's funny that zippy [] was the original motivation for Applicative because it wasn't a Monad
13:57:20 <elliott> and now []'s Applicative instance agrees with its Monad and everybody wants to tie the two together :P
13:57:23 <cmccann> which is why I was noting the lack of anything that gives a full structure intentionally, rather than relying on a compatible Applicative
13:57:55 <cmccann> well, I think having the instances disagree for a single type would be bad
13:58:21 <elliott> unfortunately ZipList is useless as it's too syntactically noisy thanks to the newtype wrapper :(
13:58:41 <elliott> cmccann: I'm actually not sure we always want (<*>) = ap
13:58:55 <elliott> for instance, data Partial a = Now a | Later (Partial a)
13:59:02 <elliott> (<*>) can "race" the function and argument together
13:59:08 <cmccann> we do if Applicative ever becomes a constraint on Monad like it ought to be
13:59:10 <elliott> but ap has to do the entire function first
13:59:17 <elliott> but Partial is still a monad
13:59:29 <elliott> and the racing behaviour is the obvious, best meaning of (<*>)
13:59:33 <cmccann> what we actually want is ap = (<*>) :P
13:59:49 <elliott> you can say that (<*>) and ap are equivalent modulo the number of Laters, I guess
13:59:54 <elliott> but that's silly
14:00:25 <cmccann> well
14:00:40 <cmccann> as a rule of thumb monad instances are terrible on everything that's obviously a zippy applicative
14:01:07 <cmccann> or anything that's basically indexed by a key, as with the current topic
14:01:28 <cmccann> the only non-terrible case is if it's actually a function, i.e. Reader
14:01:46 <elliott> cmccann: Partial is a totally reasonable monad :P
14:01:55 <elliott> Now a >>= k = k a; Later m >>= k = Later (m >>= k)
14:02:44 <cmccann> yes, I think that is very definitely a monad :P
14:03:26 <cmccann> specifically a free monad
14:03:45 <elliott> yeah
14:03:57 <elliott> but the zippy instance is still the most reasonable for (<*>) :(
14:04:13 <cmccann> yes
14:04:59 <cmccann> I'm not seeing why there's a difference between the instances anyway
14:05:04 <cmccann> other than efficiency
14:05:37 <elliott> cmccann: sure, if you consider Later (Later (Now (f x))) vs. Later (Later (Later (Later (Now (f x[too many )s] a matter of "efficiency"...
14:05:51 <elliott> Now f <*> Now x = Now (f x); Later f <*> Now x = Later (f <*> Now x); Now f <*> Later x = Later (Now f <*> x); Later f <*> Later x = Later (f <*> x)
14:05:53 <elliott> is the "zippy" instance
14:06:01 <elliott> which runs the two sides in parallel, effectively
14:06:13 <cmccann> oh, I see what you mean.
14:06:49 <tgeeky> 0.001% of the time, it deposits a package of fruity, chewey candy on your desk
14:07:04 <cmccann> yeah, you still want to pick one or the other :P
14:07:24 <cmccann> since every Monad instance implies an Applicative instance
14:07:32 <elliott> hmph
14:07:38 <cmccann> having Applicative decide to do something different is just confusing
14:07:55 <elliott> the two are "morally equivalent" :P
14:08:42 <cmccann> ugh, I need more tea, I'm getting confused
14:08:54 <cmccann> whatever, they should give the same answers, that's all I care about
14:09:01 <zzo38> I made these three modules for extensible-data so far:  http://sprunge.us/QdMI
14:09:05 <elliott> sure, if you ignore the Laters behind the curtain :)
14:09:21 <elliott> zzo38: type families /and/ fundeps?
14:09:38 <zzo38> elliott: Yes, it uses type families and fundeps.
14:09:46 <monochrom> tea and coffee are morally equivalent? :)
14:09:50 <cmccann> if the derived Eq instance says they're equal then I'm happy with it, otherwise it's a terrible idea
14:10:00 <elliott> zzo38: but the two are basically equivalent...
14:10:20 <elliott> cmccann: bah, such a crude method
14:10:39 <zzo38> elliott: They have different purposes, as far as I can tell, even though they have some similarities
14:10:57 <ovechkin> elliott: if a body a text has 900 unique words, the most frequent word appears 2520 times, and assuming zipf's law the frequences of the other unique words will be [x, x/2, x/3, x/4 ...]. then would it be correct to calculate the total number of words by doing sum (map floor (map (\x -> 2520 / x) [1..900]))?
14:11:04 <hpaste> fryguybob pasted “repa?” at http://hpaste.org/63428
14:11:30 <elliott> zzo38: nope, type families are pretty much meant to supercede fundeps
14:11:38 <elliott> that's why there's -fd and -tf versions of everything :P
14:12:28 <elliott> cmccann will now bring up the fact that you can't quite write TypeEq with type families :P
14:12:35 <dylukes> hm?
14:12:39 <dylukes> you can't?
14:12:57 <zzo38> elliott: See?
14:13:16 <elliott> zzo38: no, I don't see
14:13:19 <elliott> dylukes: apparently
14:13:28 <Mike____> can anyone tell me how do I compare two strings and see if they are the same?
14:13:33 <Mike____> is there any function for that?
14:13:39 <elliott> Mike____: s1 == s2
14:13:41 <zzo38> Make____: (==)
14:13:43 <elliott> Mike____: you should really read LYAH
14:13:51 <Mike____> hmm... i've been using that
14:13:53 <Mike____> thats why i asked
14:13:54 <neutrino> hi again
14:13:58 <Mike____> must be something else
14:14:05 <kallisti> does anyone know if GHC's -D option is subsequently passed to GCC? or is it only used when using CPP on the Haskell source?
14:14:05 <dylukes> Mike____: No no stop!
14:14:13 <dylukes> You need to use the string equals function!
14:14:20 <dylukes> Strings are special and unlike every other value!
14:14:22 <kallisti> -I appears to be passed to GCC.
14:14:23 <Mike____> oh
14:14:26 * dylukes is trolling you.
14:14:30 <dylukes> It's just ==.
14:14:33 <neutrino> hey guys what is the best way to abnormally terminate a function/program?
14:14:34 <Mike____> -.-
14:14:44 <rwbarton> foreign import "strcmp" strcmp :: Ptr Char -> Ptr Char -> Int
14:14:45 <dylukes> neutrino: exitWith, fail, ?...
14:14:46 <zzo38> neutrino: error
14:14:48 <dylukes> error?
14:14:49 <rwbarton> should take care of it
14:14:56 <neutrino> ok fight
14:14:59 <dylukes> rwbarton: rofl no
14:15:09 <zzo38> Well, it depends. In an IO code use exitWith or fail, in a pure code use error
14:15:11 <dylukes> neutrino: Depends what you want to do.
14:15:15 <neutrino> i'm parsing this file output by perl, and i get multiple lists
14:15:19 <dylukes> Do you want to throw an exception or exit?
14:15:29 <neutrino> i need those lists to be the same length, or a the program to terminate
14:15:37 <dylukes> In IO you can use exitWith/exitFailure/exitSuccess
14:15:55 <rwbarton> it sounds like you should probably just use error
14:15:59 <dylukes> Yeah.
14:16:07 <rwbarton> assuming this is just a program for your own use, that's the easiest way
14:16:10 <dylukes> error "Lists much be same length... blah blah blah."
14:16:35 <rwbarton> and you don't care about error message formatting / your program's exit code / etc.
14:16:38 <neutrino> ok sounds cool
14:16:39 <kallisti> the exceptiony way to do it would be to use either throw or throwIO from Control.Exception.
14:16:43 <Mike____> got it ^_^
14:16:57 <neutrino> i probably want the exit code to be non-zero, will error do that?
14:17:06 <rwbarton> I assume so
14:17:12 <dylukes> Yes.
14:17:12 <neutrino> thx
14:17:14 <kallisti> neutrino: any uncaught exception will return a failure status.
14:17:18 <dylukes> An exception triggers ExitFailure
14:17:27 <neutrino> thx guys
14:17:28 <stulli> Yay! I finally used a GADT. Not sure it was worth the effort except for learning sthg new.
14:17:49 <dylukes> GADT's are very useful :0
14:18:27 <stulli> I got the same result with defining several types
14:18:57 <dylukes> ?
14:19:02 <elliott> stulli: you can't do that in all cases
14:19:11 <elliott> for instance, you can't do any kind of polymorphism like that
14:19:20 <elliott> consider data a :=: b where Refl :: a :=: a
14:19:20 <cmccann> having returned from getting dinner
14:19:23 <dylukes> Or have shadow types...
14:19:24 <elliott> existentials, too
14:19:27 <cmccann> you can't write TypeEq with type families :P
14:19:30 <zzo38> Do you know, how to make a Haskell program to list all files in a directory with the names matching the wildcards? Notice that, in Windows and UNIX it has to do it differently! I want to make new version of Hampp to support wildcard includes (a feature which the only existing programming language I know of which has it is Icoruma)
14:19:38 <stulli> I used types for different kinds of URLs: GalleryURL, PicURL etc.
14:19:43 <dylukes> cmccann: What about with constraint kinds + type families?
14:19:43 <cmccann> because it horribly abuses overlapping instances to do terrible things
14:19:46 <elliott> cmccann: you missed error being recommended :)
14:20:07 <elliott> zzo38: http://hackage.haskell.org/package/Glob
14:20:18 <cmccann> dylukes, how would constraint kinds help? I'm not seeing it
14:20:22 <rwbarton> is TypeEq that thing that looks like it probably uses a bug in the interaction between fundeps and overlapping instances
14:20:24 <dylukes> Dunno, just a thought
14:20:34 <zzo38> elliott: Thanks
14:20:47 <elliott> cmccann: more extensions solve every problem
14:20:49 <cmccann> rwbarton, probably
14:20:55 <stulli> And now i switched to GADT. I'm probably not exhausting the full power of GADTs because it's all URLs
14:21:12 <elliott> maybe we should just build TypeEq into GHC :P
14:21:39 <dylukes> What IS TypeEq?
14:22:03 <cmccann> https://github.com/isomorphism/typewriter/blob/master/Data/Typewriter/TypeEq.hs
14:22:04 <dylukes> as in ~?
14:22:09 <cmccann> no
14:22:12 <cmccann> an equality predicate
14:22:16 <cmccann> not an equality constraint
14:22:20 <rwbarton> I remember coming across a thread on haskell-cafe or g-h-u or something in which there was vehement disagreement about whether a program using overlapping instances and functional dependencies was valid
14:22:44 <rwbarton> as I recall it was obviously invalid :P
14:22:48 <Saizan> maybe haskell-prime?
14:22:54 * elliott is really tempted to try and do it with type families
14:22:58 <cmccann> as in "TypeEq a b r" is a constraint that forces r to be one of two types depending on whether a and b are the same type
14:23:01 <elliott> but I suspect cmccann has devoted more effort to it than I would
14:23:01 <zzo38> Will the Glob package automatically make it case sensitive or case insensitive depending on the operating system?
14:23:10 <monochrom> f :: a -> a; f x = if x's type equals True's type then True else x  -- a way to break parametricity
14:23:18 <cmccann> elliott, type families restrict overlapping instances in a way that prevents it from working
14:23:20 <elliott> zzo38: it has special windows support, so I think so
14:23:22 <stulli> dylukes, elliott: I know what you mean with polymorphism in the context of GADTs but what are shadow types?
14:23:24 <Saizan> if it was haskell-prime everyone vehemently agreed except for the author :)
14:23:45 <elliott> stulli: I have no idea what shadow types are.
14:23:55 <thomw> test
14:23:58 <dylukes> Srry, I'm not sure what the actual term is.
14:23:58 <elliott> thomw: failed
14:24:02 <cmccann> phantom types?
14:24:02 <dylukes> Things like doing,
14:24:05 <rwbarton> Saizan: yeah, probably
14:24:05 <dylukes> there we go
14:24:06 <dylukes> yeah
14:24:07 <dylukes> phantom types
14:24:13 <stulli> ah, i see
14:24:16 <dylukes> http://www.haskell.org/haskellwiki/Phantom_type
14:24:25 <stulli> that's next on my list. slowly
14:24:30 <elliott> phantom types are trivial
14:24:34 <dylukes> Yeah.
14:24:36 <elliott> they're just type arguments you don't use on the right hand side
14:24:37 <dylukes> They're really simple.
14:24:40 <stulli> *slowly approaching type witnesses
14:24:51 <dylukes> They're sort of just "tags"
14:24:51 <elliott> but in this case I suspect stulli wants gadts
14:24:59 <cmccann> monochrom, pretty sure you can't do that without infesting the function's type context with all kinds of Oleg-y nonsense
14:25:01 <monochrom> data Ph a = Ph -- the phantom monad
14:25:01 <elliott> because PictureURL :: String -> URL Picture is not expressible with phantom types
14:25:15 <elliott> cmccann: maybe you can use some magic to make it work
14:25:18 <dylukes> monochrom: wut
14:25:27 <elliott> cmccann: like avoiding fundeps entirely and somehow associating them with a type family /outside/ the class
14:25:30 <dolio> There's lots of brokenness with fundeps.
14:25:31 <elliott> ooh, that gives me an idea
14:25:35 * elliott starts up GHCi
14:25:37 <dylukes> monochrom: is that useful...?
14:25:58 <cmccann> elliott, well let me know if it works but I'm pretty sure it won't :P
14:26:01 <dolio> Like, 'class C a b | a -> b ; instance C Int a'.
14:26:04 <monochrom> it is useful for destroying various presumptions, e.g., "monad as container"
14:26:08 <dolio> I think you need undecidable instances for that one.
14:26:11 <ion> dylukes: Depends on whether you’re a GhostBuster.
14:26:12 <zzo38> monochrom: Yes, I know about that (I first found it not in Haskell but in a category made from a dirgaph). However it was called Proxy because of a type in another package. And then I also found Coproxy comonad too, also in the category made from the digraph. In Haskell the Coproxy would be:  data Coproxy a;
14:26:12 <elliott> cmccann: hmm, what is TermProxy?
14:26:22 <dolio> But someone tried arguing at me that that was a sensible instance.
14:26:29 <cmccann> elliott, something from my type hackery library
14:26:47 <elliott> cmccann: right, is it necessary in the TypeEq definition?
14:26:48 * djahandarie argues at dolio
14:26:54 <cmccann> elliott, no
14:26:57 <dolio> Because functional dependencies aren't actually functional dependencies, they're something else that just have a misleading name.
14:26:58 <elliott> ok
14:27:00 <elliott> you use it, though :P
14:27:15 <elliott> you just need to express TypeEq', right?
14:27:18 <elliott> TypeEq can be done on top
14:27:30 <cmccann> elliott, it's to let me reify singleton types that I use as type-level values at the term level
14:27:43 <ksion> <monochrom>  data Ph a = Ph -- the phantom monad -- Is that a new Star Wars prequel? ;)
14:27:44 <cmccann> to avoid nonsense like (undefined :: Foo)
14:27:49 <elliott> cmccann: ah
14:27:50 <monochrom> hahaha
14:28:09 <elliott> cmccann: btw, you do not need overlapping instances, just undecidable
14:28:35 <cmccann> elliott, yeah I think TypeEq' is the sticking point
14:29:26 <cmccann> elliott, as well as doing anything using the result of TypeEq', you can't wrap it up as a type family either
14:29:33 <ion> @remember ksion <monochrom> data Ph a = Ph -- the phantom monad  <ksion> Is that a new Star Wars prequel? ;)
14:29:33 <lambdabot> It is stored.
14:29:36 <zzo38> What other opinion do you have of my extensible-data modules I posted these three modules?
14:29:50 <elliott> cmccann: it's interesting that you don't need overlappinginstances at all
14:30:17 <cmccann> TypeEq' should need overlaps
14:30:20 <elliott> it doesn't
14:30:25 <elliott> {-# LANGUAGE MultiParamTypeClasses, FlexibleInstances, TypeFamilies, UndecidableInstances, FunctionalDependencies #-}
14:30:25 <elliott> works
14:30:27 <elliott> 7.4.1
14:30:28 <cmccann> ...are you sure?
14:30:33 <elliott> maybe you need OverlappingInstances to actually use it
14:30:37 <elliott> IIRC GHC fails to warn early about that sometimes
14:30:39 <cmccann> does it actually work, or just "works if you don't use it"
14:30:42 <elliott> well, it compiles
14:30:44 <elliott> same thing :)
14:30:48 <cmccann> yeah not gonna work
14:31:00 <monochrom> hahaha, "works if you don't use it" is great
14:31:08 <ion> Yeah :-D
14:31:17 <cmccann> monochrom, in this case I think it's quite appropriate actually
14:31:24 <ion> Works until observed
14:31:26 <cmccann> that applies to a lot of type hackery
14:31:40 <monochrom> I have a noise-cancelling headphone I really like, but recently one of its internal wires is broken. so, it works if I don't use it!
14:31:57 <cmccann> :D
14:31:57 <elliott>     Conflicting family instance declarations:
14:31:58 <elliott> aw c'mon, work with me here, GHC!
14:32:06 <djahandarie> monochrom, what model? I've been looking for new headphones to not use
14:32:17 <elliott> monochrom: it also works if you use it and there's no noise and you're playing silence
14:32:27 <elliott> practically as good as new if you ask me
14:33:00 <monochrom> Sennheiser pxc  250
14:33:00 <dylukes> monochrom: Currently working on PhT transformer >.>
14:33:09 <monochrom> haha
14:33:13 <cmccann> heh
14:33:26 <cmccann> dylukes, I hope you put that on hackage
14:33:29 <dylukes> I will :)
14:33:30 <djahandarie> Is that as useless as a PhD?
14:33:47 <dylukes> I'm writing Control.Monad.Ph/.Class
14:33:49 <dylukes> :
14:33:49 <dylukes> :e
14:33:51 <dylukes> :3 *
14:33:52 <monochrom> however, pxc 250 is already pretty old technology. recently sony's "digital noise cancelling" is quite amazing
14:34:00 <zzo38> I have some other feature suggestion for type families, one is allow you to use "data instance" when the family is declared as "type family" (but not vice versa), the other one is allow multiple "data instance" with the same pattern when "data family" is declared, to allow extensible sums
14:34:43 <monochrom> of course, the Shure low-tech approach of "just physically block sound" also works great
14:35:13 <zzo38> (If you make "data instance" when "type family" is declared, it should just make a type synonym instance for an anonymous datatype)
14:35:35 <elliott> I like how PolyKinds lets you have a typeclass that's an instance of itself.
14:35:37 <ion> Is that like the geek approach of blocking romantic interest?
14:35:56 <cmccann> elliott, haha
14:36:08 <elliott> class C c where c :: c => Dict c
14:36:10 <elliott> argh
14:36:12 <elliott> class C c where c :: c c => Dict c
14:36:21 <elliott> oh, I bet that doesn't work because c gets its kind inferred wrong
14:36:25 <zzo38> Does this seem reasonable to you?
14:36:28 <elliott> (needs to be (AnyK -> Constraint))
14:36:45 <elliott> oh, then C couldn't be an instance because it's not AnyK -> Constraint
14:36:46 <elliott> hmph :P
14:37:03 <neutrino> hm
14:37:16 * cmccann thinks we need some sort of type-level asTypeOf
14:37:24 <monochrom> "typeclass that's an instance of itself" sounds too good to be true :)
14:37:31 <djahandarie> asKindOf?
14:37:42 <djahandarie> Or are we purists now.
14:38:04 <cmccann> djahandarie, well the issue is implementing it in a way that's actually convenient enough to bother with :P
14:38:09 <parcs`> class C c; instance C C works
14:38:10 <cmccann> also you might want to capitalize that a
14:38:31 <elliott> cmccann: I bet you could implement that.
14:38:54 * cmccann thinks it would need to be a type synonym to work properly though
14:39:15 <elliott> oh, wait, you can't
14:39:19 <elliott> because we can't give explicit polykind signaturse
14:39:21 <elliott> *signatures
14:39:22 <elliott> *sigh*
14:39:26 <elliott> bring on edwardkhc
14:39:27 <cmccann> elliott, that's why it would be tricky
14:39:37 <elliott> hmm...
14:39:39 <cmccann> and also why it would be useful to begin with :P
14:39:54 <elliott> cmccann: you could try and force the two types to be the same with a typeclass
14:40:01 <cmccann> to coerce kinds without writing explicit signatures
14:40:04 <elliott> cmccann: class Wow f a b where magic :: (f a b, f b a)
14:40:17 <elliott> newtype Blah a b = Blah
14:40:21 <elliott> instance Wow Blah a b where magic = (Blah, Blah)
14:40:27 <cmccann> right, the idea is to find some way to do that generally
14:40:29 <cmccann> and inline
14:40:35 <elliott> doesn't that work? I mean, the point is that you'd reuse Wow
14:40:49 <elliott> all you need is a (Wow Blah a b) constraint to get a and b to have the same kind
14:40:52 <elliott> and you can trivially discharge it
14:40:52 <cmccann> might work but I suspect this is all very touchy
14:41:06 <cmccann> I'd have to play with it to be confident it wouldn't fall over in practice
14:41:21 <elliott> cmccann: the whole type system is falling over
14:41:28 <elliott> all these extensions just let us see how ad-hoc it truly is :P
14:41:43 <cmccann> it's not ad-hoc
14:41:46 <cmccann> nor are most extensions
14:41:50 <djahandarie> The toppling tower of types
14:41:54 <cmccann> many combinations of them are
14:42:03 <cmccann> fundeps are pretty ad-hoc though
14:42:10 <cmccann> and overlapping instances is just silly
14:42:19 <paf31> to force two constructors to have the same kind, can't you use the polykinded version of the equality gadt?
14:42:53 <elliott> cmccann: well, GADTs + TypeFamilies + ConstraintKinds + DataKinds + PolyKinds is ad-hoc at the type level if you ask me
14:42:55 <cmccann> elliott, so did you get that type family thing working? :P
14:43:06 <elliott> there's so many things that you can almost do but get "gummed up" by ghc weirdness
14:43:07 <elliott> and no :(
14:43:38 <zzo38> Can you please tell me if you think there is something I might have missed or whatever in extensible-data? Or suggestions for other modules to add?
14:44:02 <cmccann> elliott, yeah that's basically where at least three mostly consistent sets of features all collide :P
14:45:10 <dylukes> rofl, monochrom
14:45:12 <dylukes> it actually is working
14:45:17 <elliott> cmccann: see, with Agda, the type-level is beautiful and expressive beyond belief
14:45:17 <dylukes> let a = undefined :: Ph Int
14:45:17 <dylukes> λ> let b = fmap (+1) a
14:45:22 <elliott> cmccann: it's the /value/ level that gets gummed up :D
14:45:38 <dylukes> elliott: What's the difference?
14:45:43 <monochrom> hrm, you can use "a = Ph :: Ph Int" instead
14:45:52 <elliott> dylukes: stop it. stop! my joke. you'll kill it :(
14:45:59 <djahandarie> Yes. Proxy > undefined
14:46:07 * hackagebot wai-middleware-cache 0.1.0 - Caching middleware for WAI.  http://hackage.haskell.org/package/wai-middleware-cache-0.1.0 (AlexanderDorofeev)
14:46:27 <cmccann> dylukes, the value level is the part you're presently using, the type level is whatever classifies the things you're working with
14:46:36 <cmccann> I think that matches the spirit of elliott's distinction :P
14:46:43 <djahandarie> dylukes, http://hackage.haskell.org/packages/archive/tagged/0.2/doc/html/src/Data-Proxy.html may be what you're trying to do, by the way.
14:46:55 <monochrom> when you finish the phantom monad transformer, you will get a PhT degree :)
14:47:14 <cmccann> monochrom, talk about a degree with no value
14:47:17 <ion> dylukes: Shouldn’t that be let a = Ph :: Ph Int?
14:47:18 <dylukes> D:
14:47:20 <monochrom> hahaha
14:47:22 <dylukes> ion: true.
14:47:28 <dylukes> djahandarie: ruining my fun
14:47:29 <dylukes> fuck you
14:47:39 <djahandarie> edwardk has already done everything you could possible do for a PhT.
14:47:48 <zzo38> monochrom: And then there is the cophantom comonad but there can be no transformer for a cophantom comonad in Haskell.
14:47:52 <dylukes> djahandarie: I hate you and edwardk
14:47:53 <dylukes> :<
14:47:55 <dylukes> Ruining my fun.
14:48:08 <djahandarie> It's okay, I'm hardly around these days.
14:48:08 <elliott> djahandarie: that doesn't have the T aspect
14:48:46 <dylukes> zzo38: Maybe with rank 2 types?...
14:49:02 <dylukes> data CoPh = forall a. CoPh a
14:49:20 <elliott> AKA data CoPh = CoPh
14:49:24 <zzo38> (I just figured them out in categories made up from digraphs. If it is a category with an initial object there will be the cophantom comonad and with a final object a phantom monad)
14:50:11 <zzo38> dylukes, elliott: Those are not the types I meant; they aren't even the correct kind. I meant:   data Ph a = Ph a; data CoPh a;
14:50:29 <zzo38> In this case, Ph is a monad (but not a comonad), and CoPh is a comonad (but not a monad).
14:50:34 <dylukes> whatever ;___;
14:51:44 <zzo38> Can a category from a digraph support any other monads/comonads than these ones and the identity functor?
14:52:07 <dylukes> So, I kind of want like
14:52:09 <dylukes> a haskell pin.
14:52:21 <zzo38> (Actually, I think it is called the free category of a quiver, or something like that)
14:53:12 <zzo38> Sorry I meant:   data Ph a = Ph; data CoPh a;
14:53:19 <zzo38> (I added an extra "a" by mistake before)
14:53:25 <dylukes> My school forbids hoodies,
14:53:25 <ion> dylukes: Wouldn’t a lower back tattoo be cooler?
14:53:33 <dylukes> unless they're hoodies for a school you're going to.
14:53:36 <dylukes> (for seniors)
14:53:44 <dylukes> I wonder if I could get away with saying "oh. Haskell is a school."
14:54:06 <elliott> http://www.haskell.edu/
14:54:16 <cmccann> there are at least a couple towns named Haskell
14:54:30 <cmccann> so probably a few schools too
14:54:43 <elliott> (that was an actual link :P)
14:54:59 <monochrom> the Haskell School of Java Programming :)
14:55:01 <dylukes> http://haskell.spreadshirt.com/oleg-already-did-it-A6499531/customize/color/63
14:55:01 <dylukes> Hah.
14:55:20 <dylukes> There's one that just says "n + k". I wonder how much rage I could inspire by wearing that into any haskell meeting.
14:55:29 <monochrom> the Haskell School of Java Programming: http://www.vex.net/~trebla/humour/Nightmare.java
14:55:41 <dylukes> what
14:55:41 <dylukes> the
14:55:42 <dylukes> fuck
14:55:51 <dylukes> "public void s() throws Nil, Cons;"
14:55:53 <dylukes> ;_____;
14:56:02 <monochrom> use "catch" for pattern-matching!
14:56:08 <dylukes> No I get that.
14:56:10 <dylukes> But
14:56:12 <dylukes> are you kidding me.
14:56:24 <dylukes> I feel inspired to do "The Haskell School of Ruby Programming" now.
14:56:26 <dylukes> :3
14:56:32 <monochrom> do you understand why I call it "Nightmare.java"? :)
14:56:35 <elliott> monochrom: i actually really like that :)
14:56:43 <elliott> it's basically how GHC implements pattern-matching, too!
14:56:43 <elliott> it's basically how GHC implements pattern-matching, too!
14:56:46 <monochrom> also the "/humour/" part in the URL :)
14:56:54 <dylukes> monochrom: No why?
14:57:02 <dylukes> Other than that it's terrifying code?
14:57:08 <monochrom> it is a joke and it is a nightmare :)
14:58:29 <zzo38> Now invent "The Haskell School of INTERCAL Programming"
14:59:18 * cmccann once tried to define an INTERCAL monad in the style of augustss's BASIC monad 
14:59:18 <dylukes> brb
14:59:34 <cmccann> but it didn't work very well
14:59:55 <elliott> cmccann: that's how you know you succeeded
14:59:56 <zzo38> cmccann: Let me see both of those things anyways
15:00:07 <elliott> zzo38: http://augustss.blogspot.com/2009/02/more-basic-not-that-anybody-should-care.html
15:00:45 <cmccann> elliott, no, I mean it actually worked better than INTERCAL by which I mean that it didn't do anything at all
15:01:01 <monochrom> haha
15:02:24 <cmccann> monochrom, btw did you see my Makefile that renders the mandelbrot set? that's almost as horrifying as your java.
15:02:59 <monochrom> I haven't seen it, but that is scary
15:03:08 <zzo38> phyrexian: Why are you posting this?
15:03:13 <elliott> @tell phyrex1an is your part message *meant* to be "PART #mediawiki :PART #haskell-game :PART #ape-project :PART #freenet :PART #erlang :PONG :adams.freenode.net"?
15:03:13 <lambdabot> Consider it noted.
15:03:15 <monochrom> only a postscript program can beat that
15:03:18 <elliott> *@ask
15:03:20 <cmccann> monochrom, https://github.com/isomorphism/esoteric-fractals/blob/master/Make/Makefile
15:03:48 <cmccann> monochrom, actually I think XSLT is worse
15:03:50 <zzo38> O, that is the part messgae is that proper?
15:04:21 <zzo38> elliott: There would be  PART #haskell :   at the front; the quotations marks are added by server
15:04:37 <cmccann> I've seen mandelbrot renderers in both postscript and XSLT, btw
15:04:58 <rostayob> elliott: http://augustss.blogspot.com/2009/02/is-haskell-fast-lets-do-simple.html , pure gold
15:05:12 <rostayob> monochrom: postscript is great!
15:05:19 <cmccann> rostayob, augustss is pretty awesome in general
15:05:25 <rostayob> cmccann: yep :)
15:05:37 <monochrom> hrm, interesting
15:06:01 <rostayob> monochrom: try this for postscript fun http://www.ioccc.org/1998/bas2.c
15:06:03 <zzo38> As far as I know you cannot use = in the Haskell BASIC implementation. Is that even a monad at all?
15:06:21 <zzo38> Or is it just a use of do-notation?
15:07:24 <monochrom> ok, so BASIC embedded in Haskell is how you get faster-than-c code?
15:07:32 <elliott> monochrom: amusingly the idiomatic Haskell was slower
15:07:36 <monochrom> @quote monochrom einstein
15:07:36 <lambdabot> monochrom says: einstein's theory implies that haskell cannot be faster than c
15:07:40 <rostayob> monochrom: makes sense
15:07:49 <elliott> we should use the BASIC module for all our tight loops
15:08:02 <moriarty> lol monochrom
15:08:23 <zzo38> How does Einstein's theory imply such things?
15:08:24 <cmccann> monochrom, enjoy reading the makefile? :D
15:08:35 <monochrom> this is pure gold for next time someone asks "can haskell be as fast as c?"
15:08:43 <monochrom> yes, that one is interesting
15:09:45 <moriarty> zzo38, through his mass-energy equivalence postulation
15:10:02 <elliott> cmccann: now do the other language benchmarks game programs in make
15:10:34 <cmccann> elliott, I'm still amused by how comparatively fast the makefile runs, given how absolutely horrible the implementation is
15:13:26 <zzo38> I don't know of any problems with allowing "data instance" to be used with "type family"; it should simply make up an anonymous datatype and then make up a synonym of it. Do you know any problems with this?
15:13:43 <rostayob> augustsson works in London? where?
15:13:59 <elliott> standard chartered, I think
15:14:03 <cmccann> yes
15:14:23 <rostayob> oh, banks :(
15:14:23 <cmccann> they employ both augustss and dons I believe
15:14:29 <cmccann> which is kinda terrifying
15:14:31 <elliott> which is a really silly company name :P
15:14:35 <rostayob> dons is not galois anymore?
15:14:36 <elliott> "standard chartered... what?"
15:14:41 <rostayob> why just banks
15:14:54 <rostayob> (for the banks reading these logs, I'm just kidding I love you)
15:14:56 <elliott> $
15:15:20 <rostayob> elliott: they use haskell because they have money?
15:15:21 <Enigmagic> and neilm
15:15:23 <cmccann> more like $$$$$
15:15:26 <rostayob> I'm not sure I see the connection
15:15:52 <elliott> rostayob: more like they pick up the haskellers because they have lots of money to give them :P
15:16:04 <rostayob> elliott: I see. it's sad
15:16:48 <Enigmagic> it's sad that someone is actually paying people to work with haskell?
15:17:03 <cmccann> it's sad they're not being paid to do something useful instead :P
15:17:13 <rostayob> Enigmagic: it's sad that if you want to work well-typed FP you have to work for banks
15:17:18 <rostayob> what cmccann said
15:17:29 <Enigmagic> there are companies doing haskell outside of banks
15:17:36 <cmccann> like galois
15:17:41 <Enigmagic> i'd rather banks only hire haskell programmers
15:17:46 <Enigmagic> more haskell programmers = more haskell companies
15:17:54 <rostayob> yeah, but most are finance-related companies
15:19:18 <Enigmagic> gotta start somewhere
15:19:30 <Enigmagic> f# was funded that way too
15:20:43 <rostayob> Enigmagic: what I'm puzzled about is why is Haskell mostly appreciated at banks. That's all.
15:21:00 <moriarty> rostayob, are you using haskell for finance?
15:21:08 <moriarty> ah, guess not
15:21:21 <smoge> anyone running haskell on linode?
15:21:35 <rostayob> moriarty: nope, I'm not working with Haskell
15:21:45 <rostayob> haskell is just a very time expensive hobby :)
15:22:10 <rostayob> I still manage to work with a functional language (Erlang) eheh
15:22:11 <moriarty> rostayob, probably it's more elegant to code in haskell
15:22:39 <Enigmagic> rostayob: probably two reaosns... 1) reliable software is important when a bug can cost billions 2) quant traders used haskell in school (or whatever) and they get a lot of leeway to use tools they like providing they make money
15:23:51 <rostayob> Enigmagic: well, a lot of people who graduated with CS have seen Haskell at school
15:24:59 <Enigmagic> rostayob: regular dev shops have a harder time justifying additional languages
15:25:40 <Enigmagic> particularly ones with mostly expensive develoeprs and terrible (compiled) code debugging tools
15:26:00 <rostayob> Enigmagic: really? I would have imagined the banks to be more conservative
15:26:17 <Enigmagic> heh not for a trading desk
15:26:43 <rostayob> mh, ok.
15:30:52 <kallisti> forkIO $! foo
15:30:59 <kallisti> this would have the effect of being really dumb, right?
15:31:25 <c_wraith> if you mean the $!, it would do nearly nothing.
15:31:32 <c_wraith> It'd force the top-level IO constructor
15:31:45 <YouOh> hi
15:31:48 <kallisti> ah right
15:32:09 <YouOh> i have a small problem
15:33:02 <YouOh> trying to install gtk with cabal results in an error when using glib >=2.31.
15:33:30 <YouOh> theres a patch file online @ http://hackage.haskell.org/trac/gtk2hs/ticket/1253 that shpuld fix the problem
15:33:39 <YouOh> how do i apply the patch
15:35:04 <moriarty> rostayob, http://research.microsoft.com/~simonpj/papers/financial-contracts/contracts-icfp.htm
15:36:16 <hash``> Does there exist a denotational semantics definition for Haskell, or a subset of Haskell?
15:37:24 <spyros> Hello i have a guestion. i m doing the tutorial. What is the difference of the 2 snippets here http://hpaste.org/63434. I thought that the : function is used only with lists
15:37:40 <elliott> hash``: no
15:37:42 <elliott> well
15:37:45 <elliott> a subset, probably
15:37:47 <elliott> Haskell has lots of subsets :P
15:40:18 <quintessence> spyros: strings are lists of Chars
15:40:41 <khanzor`> spyros: there's no difference, you can match as many head elements in a list with the (:) operator
15:41:02 <elliott> there is a difference
15:41:13 <elliott> the first pattern accepts fewer lists than the latter
15:41:27 <elliott> well, there's no difference between the whole expressions :P
15:41:27 <khanzor`> lol
15:41:33 <elliott> i wasn't joking
15:41:59 <hash``> Sorry, I'm new to IRC - not sure how to message at someone.
15:42:20 <heatsink> Try /help msg
15:42:47 <hash``> msg heatsink Thanks.
15:43:08 <YouOh> with a / in front of it :p
15:43:10 <elliott> hash``: If you just want to direct a message at someone, then use the colon.
15:43:17 <elliott> For private messages use /msg, but ask people in-channel if they're OK with it first.
15:43:33 <hash``> :elliot Got it. Thanks.
15:43:39 <hash``> Use the colon how :)
15:43:48 <elliott> hash``: like this :P
15:44:09 <heatsink> Colon doesn't do anything special, but people notice it easily
15:44:13 <hash``> elliot: Now I know how andriods in movies who can't understand subtext feel.
15:44:39 <hash``> Got it. Thanks all.
15:44:39 <elliott> heatsink: some clients only bother the user if you use "foo:" or "foo," I think
15:45:09 <heatsink> ah.  Mine doesn't care where my name shows up.
15:45:22 <heatsink> Like, I could even put the name at the end :elliott
15:45:27 <elliott> ditto for mine
15:45:33 <hash``> elliot: I'm looking to try to do a few simple proofs using an SMT solver, such as z3 or cvc3, on Haskell programs. If that means simplifying the program then that's fine.
15:45:34 <elliott> I like to know when people talk about me, not just at me :P
15:45:34 <spyros> Ok i think i got it in the next lesson. Thx for the help everyone
15:45:48 <elliott> hash``: check out http://hackage.haskell.org/package/sbv
15:46:15 <elliott> hash``: it can use z3 as a backend
15:46:20 <khanzor`> hash``: have you seen learn you a haskell for great good? i found that quite good as a starting point
15:46:34 <hash``> elliot: I give up. Haskell does everything. It's Python, only sane. There's nothing left to do.
15:46:37 <elliott> sounds like hash`` is a little above introductory tutorial level, hehe
15:46:56 <hash``> Heh.
15:47:11 <elliott> sbv doesn't really do anything to haskell programs themselves
15:47:27 <elliott> it just uses cheeky tricks to let it get what amounts to an AST from a haskell program using certain operations
15:47:39 <elliott> (e.g. you must use (.==) rather than (==))
15:47:53 <hash``> elliot: Can't blame him, probablistically if he says that to everyone who comes he's hitting a high percentage on the valid comment score.
15:48:05 <tromp__> i'm playing a Haskell Go program
15:48:22 <tromp__> called kurt :)
15:50:13 <heatsink> I recently noticed something about research papers.
15:50:21 <heatsink> Lots of papers define a variant on lambda calculus
15:50:31 <heatsink> and they give you the typing rules for the entire language
15:50:41 <heatsink> even though half of them are exactly the standard rules.
15:51:00 <heatsink> Why don't they give just the nonstandard parts?
15:51:19 <elliott> for quick reference?
15:51:20 <djahandarie> Are these papers dissertations?
15:51:27 <heatsink> no, conference papers.
15:51:48 <djahandarie> It is sometimes nice to have all the typing rules on one page if you're trying to do anything with the system
15:52:15 <heatsink> Since dissertations don't have a page limit, I wouldn't be surprised to see the entire type system.
15:52:54 <Eduard_Munteanu> heatsink: they can have lower bounds
15:54:07 <heatsink> So you're saying it's sometimes awkward to talk about the typing rules if they're not all together
15:54:10 <djahandarie> Ω(2^n) pages, where n is the number of seconds you have been working on the paper.
15:54:11 <heatsink> Lower bounds?
15:54:21 <heatsink> oh, on page counts )
15:54:29 <elliott> heatsink: well, otherwise you'd have to look up the standard ones if you forgot them :P
15:54:32 <Eduard_Munteanu> heatsink: yeah, stupid stuff like that :)
15:54:35 <hash``> elliot: Thanks. It's going to take me a while to Grok all this.
15:54:40 <elliott> who has the time to remember anything?!
15:55:02 <Eduard_Munteanu> "It has to have 60 pages". So you put in all sort of stuff :)
15:55:23 <djahandarie> heatsink, it's not hard to talk about them without the basic rules, it's hard to reason in them when you don't have all the rules.
15:56:18 <djahandarie> That isn't always the case, when say, you're doing a simple variation on the STLC. But if you're reading a paper that is only about a simple variant of the STLC they may not be assuming familiarity with the STLC in the first place.
15:58:08 <heatsink> Hmm, I think I get it
16:12:47 <Diogenes> hello :)
16:13:15 <heatsink> hello
16:13:19 <Diogenes> i I would like to ask some basic questions
16:13:21 <Diogenes> about haskell
16:13:33 <heatsink> That's nice. (go ahead)
16:13:55 <edwardk> we're pretty friendly to questions here, shoot
16:13:56 <edwardk> =)
16:14:08 <Diogenes> what does $ imply in haskell?
16:14:17 <edwardk> :t ($)
16:14:18 <lambdabot> forall a b. (a -> b) -> a -> b
16:14:25 <edwardk> its just a way to avoid putting parentheses
16:14:32 <dschoepe> @src ($)
16:14:32 <lambdabot> f $ x = f x
16:14:47 <Diogenes> hmm
16:14:48 <Diogenes> so
16:14:52 <edwardk> foo $ bar baz $ quux quaffle    is the same as foo (bar baz (quux quaffle))
16:15:03 <dschoepe> It "works" by binding less strongly than most other operator.
16:15:12 <Diogenes> i understand
16:15:13 <dschoepe> *operators
16:15:13 <Diogenes> soo
16:15:16 <hughfdjackson> is quaffle really the next in the series?
16:15:19 <edwardk> if you have a final argument and its really long its often a good element of style to use $ instead of ()'s so you don't have to track where it ends and put the closing )
16:15:26 <Diogenes> foldl $ + 0 [1,2,3]
16:15:27 <Diogenes> would work
16:15:30 <Diogenes> right?
16:15:35 <dmwit> You need more parens.
16:15:36 <edwardk> hughfdjackson: depends on who you ask
16:15:50 <edwardk> Diogenes: sadly its only useful for the last argument
16:16:02 <dschoepe> Diogenes: No, that would try to apply + to 0 and [1,2,3] and give the result to foldl.
16:16:08 <elliott> no, that would syntax error
16:16:18 <dschoepe> Also, you need to write (+) for the prefix version of +
16:16:19 <hughfdjackson> edwardk: n.n fair enough
16:16:23 <edwardk> because thats trying to apply + to 0 [1,2,3] -- but + is an operator, and not legal as the first thing, so it'll blow up with a syntax error
16:16:35 <Diogenes> okey
16:16:38 <Diogenes> but
16:16:40 * hackagebot hyphenation 0.1 - Configurable Knuth-Liang hyphenation  http://hackage.haskell.org/package/hyphenation-0.1 (EdwardKmett)
16:17:01 <edwardk> consider something like
16:17:20 <edwardk> foldl (+) 0 $ some very long series of complicated function invocations
16:17:34 <Diogenes> i c
16:17:45 <edwardk> for that last argument it can be quite handy
16:17:54 <edwardk> and its also really useful as a stopgap on the way to pointfree style
16:18:07 <edwardk> foo x = bar $ baz $ quux $ quaffle x
16:18:08 <edwardk> becomes
16:18:14 <heatsink> It's useful for pipelines, like fix (enumFrom $ foldl (+) 0 $ filter foo $ map bar)
16:18:17 <edwardk> foo x = bar . baz . quux $ quaffle x
16:18:20 <edwardk> becomes
16:18:27 <edwardk> foo = bar . baz . quux . quaffle
16:18:32 <Diogenes> that was my next question
16:18:34 <Diogenes> what does . imply
16:18:40 <edwardk> . is function composition
16:18:40 <Diogenes> in functional composition
16:18:41 <c_wraith> @src (.)
16:18:41 <elliott> (f . g) x = f (g x)
16:18:41 <lambdabot> (f . g) x = f (g x)
16:18:42 <lambdabot> NB: In lambdabot,  (.) = fmap
16:18:43 <heatsink> eh, disregard my example
16:18:55 <elliott> f . g $ x = f (g x)
16:18:55 <edwardk> f . g is 'apply g', then apply f to the result of that
16:19:08 <Diogenes> ok
16:19:08 <Diogenes> so
16:19:12 <Diogenes> a . b . c . d
16:19:21 <Diogenes> its from right to left
16:19:23 <Diogenes> apply d
16:19:27 <Diogenes> then apply c to the result
16:19:28 <heatsink> yes
16:19:28 <edwardk> (a . b . c . d) x = a (b (c (d x)))
16:19:29 <Diogenes> and so on
16:19:33 <c_wraith> not in haskell.
16:19:39 <c_wraith> haskell applies outside-in
16:19:39 <edwardk> well
16:19:40 <deggis> it's not only that #haskell is 'friendly to questions', there's often even a little fight in answering :-D
16:19:52 <Diogenes> i like that quite a bit :D
16:19:54 <edwardk> hah no comments on my hyphenation package ;)
16:20:03 <Diogenes> because its way easier for me to understand this from u guys
16:20:10 <Diogenes> rather than understanding it online while reading
16:20:13 <Diogenes> much much faster
16:20:16 <Diogenes> thank you
16:20:31 <elliott> edwardk: i saw it and thought "cool"
16:20:35 <Diogenes> but
16:20:35 <elliott> is taht good enough? :P
16:20:42 <edwardk> i only have english, french and icelandic so far
16:20:46 <Diogenes> a $ b $ c $ d $ x
16:20:46 <edwardk> need more language files
16:20:52 <Diogenes> does the same thing
16:21:01 <elliott> yes, but you can't refactor it
16:21:01 <edwardk> but they are a pain in the but to unicodify from TeX
16:21:02 <Diogenes> no no
16:21:06 <Diogenes> without the last $
16:21:27 <Diogenes> so basically . = $
16:21:30 <edwardk> Diogenes: no
16:21:35 <edwardk> you can't replace the last $ with .
16:21:36 <edwardk> =)
16:21:41 * hackagebot hedis-pile 0.2.1 - Caching mandatory data with Redis  http://hackage.haskell.org/package/hedis-pile-0.2.1 (AlexanderDorofeev)
16:21:59 <edwardk> foo $ bar $ baz = foo . bar $ baz -- but not foo . bar . baz
16:22:01 <Diogenes> hmm
16:22:08 <Diogenes> i c
16:22:14 <Diogenes> i think
16:22:35 <dmwit> Actually, (.) and ($) aren't that similar at all. They just happen to work in similar places, sometimes.
16:22:39 <edwardk> the fact that you can 'swap all but the last $'s for (.)'s is more of a cute insight
16:23:02 <dmwit> It's a bit like observing that 1^0 = 1 and 1+0 = 1 and concluding that (^) and (+) are similar.
16:23:15 <edwardk> (and a consequence of the fact that $ was given the wrong associativity historically ;)
16:23:22 <Diogenes> :)
16:23:58 <Diogenes> ok
16:24:16 <Diogenes> how do i count a certain character
16:24:22 <Diogenes> from a string
16:24:28 <Diogenes> i was looking
16:24:29 <Diogenes> at
16:24:30 <Diogenes> words
16:24:46 <Diogenes> is there a predefined function
16:24:50 <Diogenes> that would do this for u?
16:24:52 <dschoepe> > length . filter (=='e') $ "Diogenes"
16:24:53 <lambdabot>   2
16:25:05 <Diogenes> oh yes
16:25:10 <Diogenes> thats pretty straight forward
16:25:18 <Diogenes> u filter the string diogenes with the charater e
16:25:25 <Diogenes> and that returns a string only with e's
16:25:37 <Diogenes> and then u count how many chars are in that string
16:25:38 <edwardk> > length $ filter ('e'==) "Diogenes"
16:25:39 <lambdabot>   2
16:26:09 <Diogenes> hmm
16:26:30 <dschoepe> Diogenes: Note that (=='e') is (==) applied to just one argument instead of two, one could also use (\x -> x == 'e') instead.
16:26:42 <Diogenes> ok another question
16:26:46 <Diogenes> what does \
16:26:46 <Diogenes> do
16:26:50 <khanzor`> > foldr (\c a -> if c == 'e' then a = 1  else a) 0 "Diogenes"
16:26:51 <lambdabot>   <no location info>: parse error on input `='
16:26:58 <khanzor`> > foldr (\c a -> if c == 'e' then a + 1  else a) 0 "Diogenes"
16:26:59 <lambdabot>   2
16:27:00 <edwardk> \ starts a lambda. its an anonymous function.
16:27:06 <khanzor`> how embarassing
16:27:09 <Jafet> > (head &&& length) . group . sort $ "alas poor yorick i knew him horatio"
16:27:11 <lambdabot>   ("      ",17)
16:27:16 <Jafet> > map (head &&& length) . group . sort $ "alas poor yorick i knew him horatio"
16:27:17 <edwardk> (\x -> x + 1)   defines a function that adds 1 to its argument
16:27:18 <lambdabot>   [(' ',6),('a',3),('c',1),('e',1),('h',2),('i',4),('k',2),('l',1),('m',1),('...
16:27:26 <edwardk> > (\x -> x + 1)  2
16:27:27 <lambdabot>   3
16:27:30 <Diogenes> i dont know what a lambada is one second ill transnate that
16:27:37 <Cody_> > let mult x y = take x [ z | z <- [0..], z `mod` y == 0] in mult 20 4
16:27:39 <lambdabot>   [0,4,8,12,16,20,24,28,32,36,40,44,48,52,56,60,64,68,72,76]
16:28:06 <edwardk> its making up a function but not bothering to give it a name
16:28:36 <edwardk> saying that that function takes one argument, x. and that in the case i just gave, it adds one to that and returns the result
16:28:41 <heatsink> > (\x -> x + 7) 3??
16:28:42 <lambdabot>   <no location info>: parse error (possibly incorrect indentation)
16:28:46 <heatsink> > (\x -> x + 7) 3
16:28:47 <lambdabot>   10
16:28:54 <heatsink> > let x = 3 in x + 7
16:28:55 <lambdabot>   10
16:28:58 <heatsink> > 3 + 7
16:28:59 <lambdabot>   10
16:29:04 <djahandarie> > 10
16:29:05 <Diogenes> im reading :)
16:29:05 <lambdabot>   10
16:29:11 <edwardk> hah
16:29:26 <Jafet> @pl \spam -> spam spam spam $ \spam -> spam spam spam
16:29:26 <lambdabot> ($ join (join id)) . join (join id)
16:30:11 <MostAwesomeDude> :t  \spam -> spam spam spam $ \spam -> spam spam spam
16:30:12 <lambdabot>     Occurs check: cannot construct the infinite type:
16:30:12 <lambdabot>       t = t -> t -> a -> b
16:30:12 <lambdabot>     Probable cause: `spam' is applied to too many arguments
16:30:29 <kniu> hey guys
16:30:40 <kniu> how come a type definition like
16:30:57 <kniu> data Foo f = App (f Foo) (f Foo) | Bar
16:31:22 <Diogenes> !filter
16:31:24 <Diogenes> filter
16:31:32 <heatsink> Is that well-kinded?
16:31:33 <kniu> gives me the error Expecting one more argument to `Foo' In the type `f Foo'
16:31:33 <Cody_> > let anom = \x -> \y -> x * y in anom 3 23
16:31:34 <lambdabot>   69
16:31:41 <heatsink> Ah
16:31:44 <heatsink> It's not well-kinded
16:31:46 <kniu> heatsink, well I think it should be
16:31:51 <elliott> it isn't
16:31:52 <kniu> f :: * -> *
16:31:58 <elliott> Foo :/: *
16:32:01 <elliott> Foo :: (* -> *) -> *
16:32:07 <kniu> oh
16:32:07 <elliott> therefore it is not an ok argument to f by your argument
16:32:12 <edwardk> :t fmap `fmap` fmap `fmap` fmap
16:32:13 <lambdabot> forall (f :: * -> *) (f1 :: * -> *) a b (f2 :: * -> *). (Functor f, Functor f1, Functor f2) => (a -> b) -> f (f1 (f2 a)) -> f (f1 (f2 b))
16:32:14 <elliott> except Foo actually has the kind
16:32:20 <elliott> Foo :: A = (A -> *) -> *
16:32:22 <elliott> which is not accepted
16:32:23 <kniu> okay I see it now
16:32:51 <Jafet> @src Mu
16:32:51 <lambdabot> newtype Mu f = In { out :: f (Mu f) }
16:33:09 <Jafet> So, use (f (Foo f))
16:33:30 <Jafet> And thine brain asplodeth
16:33:56 <kniu> yeah I was trying to avoid that, but I guess it's unavoidable
16:34:02 <heatsink> Tis a lie! My brain is whole and un-asplodethed!
16:34:14 <Jafet> Why is it something to be avoided?
16:34:24 <kniu> extra parentheses
16:34:33 <Jafet> Go implement type-level ($)
16:36:41 * hackagebot bindings-libzip 0.10 - Low level bindings to libzip.  http://hackage.haskell.org/package/bindings-libzip-0.10 (SergeyAstanin)
16:41:41 * hackagebot LibZip 0.10 - Bindings to libzip, a library for manipulating zip archives.  http://hackage.haskell.org/package/LibZip-0.10 (SergeyAstanin)
16:48:51 <Diogenes> ok could i write smt like this ecountSetences x = length . filter (==a) $ x where a = ("," r "." or ";" or "!" or "?") and not have to do it with guards .. due to simplicity of the code purposes
16:51:39 <Diogenes> :~~~(
16:52:14 <Saizan>  /topic
16:52:27 <CodeWeaverX>  /off-topic
16:53:52 <Saizan> Diogenes: you can write  ecountSetences x = length . filter (`elem` a) $ x where a = ",.;!?"
16:54:15 <kniu> my god
16:54:25 <kniu> my head is exploding
16:54:27 <Diogenes> hmm
16:54:30 <Diogenes> so
16:54:33 <Diogenes> `elem`
16:54:38 <Diogenes> ill chek what elem is doing
16:54:45 <Saizan> ?type elem
16:54:46 <lambdabot> forall a. (Eq a) => a -> [a] -> Bool
16:54:51 <Saizan> ?src elem
16:54:51 <lambdabot> elem x    =  any (== x)
16:55:15 <Saizan> ` ` around an identifier makes it infix
16:55:16 <khanzor`> Saizan: why not point free that?
16:55:59 <khanzor`> ecountSetences = length . filter pred where pred = `elem` ",.;!?"
16:56:11 <khanzor`> or maintain the 'a' binding
16:56:45 <Diogenes> whatt
16:56:45 <Diogenes> but wheres my string
16:56:45 <Diogenes> that im passing
16:56:45 <Diogenes> into the function
16:56:49 <Diogenes> khanzor
16:56:59 <jedai> Diogenes: That's pointfree style
16:57:04 <Diogenes> wow
16:57:08 <Diogenes> never heard of pointfree style
16:57:24 <Saizan> khanzor`: to not put too many new things in front of Diogenes at once :)
16:57:38 <Diogenes> its good for me
16:57:42 <Diogenes> i want to udnerstand this
16:57:52 <jedai> Diogenes: instead of writing a function as a verb that takes argument, you write it as a composition of other verbs without mentioning the arguments (the "point" of the function)
16:58:07 <Saizan> ?src (.)
16:58:07 <lambdabot> (f . g) x = f (g x)
16:58:07 <lambdabot> NB: In lambdabot,  (.) = fmap
16:58:22 <Saizan> (f . g) = \x -> f (g x), also
16:59:37 <jedai> Diogenes: for instance you could write "(^2) . (+1)" instead of "\x -> (x+1)^2"
17:00:22 <Diogenes> but . does smt like (^2(+1))
17:00:26 <Diogenes> doesnt it?
17:00:30 <jedai> Diogenes: That is, instead of writing an expression that use the arguments, you don't mention the argument, you just write the operation you'll do on it
17:00:39 <khanzor`> Diogenes: all functions in haskell are curried, so, if i have a function Int -> Int -> Int, (say (+)), then i can just pass through the first argument
17:00:48 <khanzor`> Diogenes: so, ((+) 3)
17:00:57 <khanzor`> Diogenes: this then gives me a function Int -> Int
17:01:05 <Diogenes> true
17:01:08 <khanzor`> Diogenes: i can then pass that function, say, 5
17:01:17 <tkahn6_> also (+ 3)
17:01:34 <khanzor`> Diogenes: and i will get something that is of type Int, and is equal to 8
17:01:37 <tkahn6_> doesn't really matter because + is associative but
17:01:45 <jedai> Diogenes: (+1) is just a function that add 1 to its argument, (^2) is a function that compute the square of the argument, those are called "section", they're just operation with a hole
17:01:48 <khanzor`> (correct my terminology with that ast one)
17:02:32 <kniu> @hpaste
17:02:32 <lambdabot> Haskell pastebin: http://hpaste.org/
17:02:34 <Diogenes> int -> int -> int
17:03:24 <khanzor`> Diogenes: so
17:03:28 <Diogenes> im trying
17:03:30 <Diogenes> to understand
17:03:44 <jedai> Diogenes: So ((^2) . (+1) ) x ===> (^2) ((+1) x) ===> (^2) (x+1) ===> (x+1)^2
17:03:49 <taiyal> Are the links in the topic the current correct links to use?
17:04:00 <khanzor`> Diogenes: if i define a function which has a type Int -> Int, i can return a function of that type, rather than providing a binding to the first Int
17:04:19 <khanzor`> Diogenes: ... this sounds way more complicated than it is
17:04:44 <khanzor`> Diogenes: try defining a myAdd function as myAdd :: Int -> Int -> Int
17:04:47 <Diogenes> so the non free point thing
17:04:48 <jedai> > ((^3) . (+5)) x
17:04:49 <Diogenes> it evaluates
17:04:49 <lambdabot>   (x + 5) * (x + 5) * (x + 5)
17:04:51 <Diogenes> from right to left
17:04:54 <khanzor`> Diogenes: myAdd a b = a + b
17:04:56 <Diogenes> left to right
17:04:58 <Diogenes> sry
17:05:08 <Diogenes> ok
17:05:11 <khanzor`> Diogenes: and then just delete the b from both the definition and the implementation
17:05:25 <khanzor`> Diogenes: e.g. myAdd a = (+ a)
17:05:26 <Diogenes> (+)
17:05:34 <jedai> Diogenes: f . g applies the function f to the result of the application of g
17:05:53 <jedai> Diogenes: (f . g) x == f (g x)
17:07:01 <Diogenes> ok sorry
17:07:23 <Diogenes> i have to go i copied all this stuff and read it and ill join this channel again
17:07:26 <Diogenes> in 3 hours
17:07:30 <Diogenes> thank you very much
17:15:55 <cmccann> there, this should be useful: https://github.com/isomorphism/subtypes
17:16:14 <cmccann> and people say that Haskell doesn't support subtyping.
17:17:48 <kniu> I got some instances from GHC.Show that I don't want to import
17:17:57 <kniu> how do I not import GHC.Show?
17:18:07 <kniu> or, at least, hide those specific instances?
17:18:24 <cmccann> well, don't import it
17:18:32 <cmccann> or any other modules that import it
17:18:34 <cmccann> such as Prelude
17:19:35 <cmccann> instances are contagious, all you can do is quarantine
17:19:42 <kniu> @hoogle Show
17:19:43 <lambdabot> Prelude class Show a
17:19:43 <lambdabot> Text.Show class Show a
17:19:43 <lambdabot> Prelude show :: Show a => a -> String
17:19:50 <elliott> kniu: you can't
17:19:59 <cmccann> elliott, check out my useful new package
17:20:15 <cmccann> it's clearly much better than these
17:20:45 <elliott> kniu: see http://stackoverflow.com/questions/8728596/explicitly-import-instances/8731340#8731340
17:21:11 <elliott> cmccann: haha
17:21:50 <cmccann> elliott, for bonus fun try using the getTop function
17:22:07 <cmccann> it's hilarious that it actually lets me export it like that
17:22:18 <cmccann> it even shows up as a separate function in the haddocks
17:22:33 <elliott> haha, what type does it even have?
17:22:44 <cmccann> Top -> a, of course
17:22:52 <cmccann> or so haddock claims
17:22:59 <elliott> hahaha
17:23:58 <hpaste> “C. McCann” pasted “getTop” at http://hpaste.org/63436
17:24:02 <cmccann> :D
17:24:26 <elliott> ∀x. x indeed
17:24:45 <cmccann> more like ∃ in this case
17:25:21 <hpaste> kniu pasted “I don't even know anymore.” at http://hpaste.org/63437
17:25:43 <kniu> it compiles
17:26:03 <cmccann> infixl 0 $, nice
17:26:06 * cmccann approves
17:26:20 <kniu> but I want an easy way to instance Show (Exp ((,) (Exp f)))
17:26:27 <kniu> or something to that effect
17:26:37 <cmccann> I'm pretty sure that's not what Show is for, btw :P
17:26:50 <kniu> what
17:26:56 <kniu> do mean?
17:27:50 <cmccann> if you look at how the report describes it and Read, it's more about simple string serialization, not general text output or pretty-printing
17:27:59 <cmccann> despite that being how many people try to use it
17:28:27 <kniu> it's not pretty printing
17:28:29 <kniu> it's just
17:28:30 <kniu> printing
17:28:59 <kniu> and I'd run into the same problem with any other typeclass
17:29:19 <cmccann> yeah, that's more a general gripe, not about your problem, sorry :P
17:29:33 <elliott> kniu: Show's result should be valid Haskell syntax
17:29:44 <elliott> ideally, it should be valid Haskell syntax that, when evaluated, produces the original object
17:29:56 <cmccann> or something equivalent at least
17:30:01 <kniu> oh
17:31:14 <kniu> so I should create my own typeclass?
17:31:42 * cmccann shrugs
17:31:48 <cmccann> people misuse show all the time anyway
17:32:07 <cmccann> if you don't have a Read instance anyway I have a hard time caring that much
17:33:27 <elliott> cmccann: the same = something equivalent
17:33:31 <elliott> :p
17:34:06 <cmccann> depends on your definition of "same"
17:34:29 <cmccann> I could see an abstract type not preserving details of the internal representation
17:34:55 <cmccann> with equivalence defined as "behaves the same as far as the public API is concerned"
17:35:43 <cmccann> kniu, anyway, what was your problem, exactly? does the instance you want not work?
17:42:01 <nyingen> @quote
17:42:01 <lambdabot> Masklinn says: stability is overrated
17:42:45 <smithw> Hi, I'm writing a hash map implementation for fun, and I'm wondering whether it should be as instance of Applicative Functor / Monad typeclasses, and, if so, how would I set a "default" key for pure/return implementations
17:42:57 <smithw> *an instance
17:43:41 <cmccann> I'm not sure inserting a single value at a default key makes sense
17:43:46 <tikhonjelvis> I'm not sure it makes sense for a hashmap to be an Applicative Functor or Monad.
17:44:04 <cmccann> a more reasonable pure would be to fill the entire map with the single value at every key
17:44:14 <cmccann> but that's probably not reasonable functionality :P
17:44:25 <tikhonjelvis> How would join work for a hashmap?
17:44:44 <cmccann> diagonalization I expect
17:45:00 <tikhonjelvis> hmm
17:45:11 <cmccann> for a given key, take the map at that key, then the value at the same key in that map
17:45:29 <smithw> I'm not sure. I'm still learning, but I'm kinda tired of learn you a haskell for greater good examples, so I tried doing something on my own. that's why I'm asking :p
17:45:35 <elliott> <cmccann> a more reasonable pure would be to fill the entire map with the single value at every key
17:45:41 <elliott> (aka ReaderT k Maybe)
17:45:45 <cmccann> yes
17:46:48 <cmccann> that said if you can find a reasonable way to define a default key then that might work
17:46:55 <elliott> no, I don't think so
17:46:57 <cmccann> but you'll need to constrain the key type for the instance
17:46:58 <elliott> you need m >>= return = id
17:47:12 <elliott> say you pick a Monoid, so that you "zip" each map with mappend on the keys to try and take advantage of mappend mempty = id
17:47:22 <elliott> then it fails, because you run into the non-uniform shape problem that ZipList has
17:47:26 <cmccann> ah, right
17:47:29 <cmccann> ok yeah
17:48:57 <cmccann> smithw, ok, in summary: the only valid instance isn't sensible, and any sensible instance isn't valid.
17:49:00 <cmccann> glad to help :P
17:49:14 <smithw> I see :p thanks for trying :)
17:49:42 <smithw> what is the name of the reverse operation of pure/return? as in, "extracting" the value from its context?
17:49:47 * cmccann high-fives elliott, woohoo crushing a poor newcomer's dreams
17:50:02 <cmccann> smithw, there's no reverse in the standard libraries
17:50:18 <elliott> smithw: there is none
17:50:25 <elliott> there is no such function for IO, for instance; that would be impossible
17:50:34 <elliott> for State s, you must supply an initial value
17:50:38 <elliott> :t runState
17:50:39 <lambdabot> forall s a. State s a -> s -> (a, s)
17:50:42 <elliott> for Cont r, you need to supply a continuation
17:50:43 <cmccann> there's a reversal of the entire concept of a monad, however
17:50:43 <elliott> :t runCont
17:50:44 <lambdabot> forall r a. Cont r a -> (a -> r) -> r
17:50:45 <elliott> and so on
17:50:51 <elliott> the entire point of a monad is that there is no function
17:50:57 <smithw> I might not be expressing myself well... what >>= does when it passes the value to the function
17:51:04 <elliott> yes
17:51:08 <elliott> the whole point is that there is no such operation
17:51:12 <elliott> (>>=) doesn't necessarily pass a single value on
17:51:25 <cmccann> often, that operation wouldn't even make sense
17:51:26 <elliott> it can pass multiple. or none
17:51:29 <cmccann> as in elliott's examples
17:51:40 <elliott> a monad "extends" the language with new capabilities
17:51:46 <elliott> here's another example: the list monad
17:51:53 <elliott> there's no such function, because [] is a list, and contains no value a
17:51:57 <elliott> and what value would you return for [1,2,3]?
17:52:11 <cmccann> :t head
17:52:12 <lambdabot> forall a. [a] -> a
17:52:14 <cmccann> :]
17:52:19 <cmccann> just kidding, don't use that function
17:52:21 <cmccann> it's terrible
17:52:39 <smithw> elliott, what learnyouahaskell has led me to believe is that a list is a value in a non-deterministic context
17:52:56 <cmccann> that's one (perfectly reasonable) way of looking at lists, yes
17:53:05 <elliott> yes, which means it has 0, 1, or 23948723498234 values
17:53:08 <tikhonjelvis`> smithw: Yeah. In this case, non-deterministic means having an arbitrary number of arbitrary values of that type.
17:53:09 <smithw> so, I don't want a function that does that, I just wanted to know the operation's name, if there's one
17:53:11 <elliott> so there is no "the value"
17:53:12 <ovechkin> i defined a functoin in ghci. but i can't remember exactly how it works. is there a way to display its definition?
17:53:17 <elliott> smithw: there is no operation
17:53:29 <tikhonjelvis`> Maybe I like the word "arbitrary" too much.
17:53:37 <elliott> ovechkin: no
17:53:54 <ovechkin> ok
17:53:56 <tikhonjelvis`> ovechkin: Are you in emacs by any chance?
17:54:03 <cmccann> tikhonjelvis`, perhaps you have an arbitrary amount of fondness for the word?
17:54:03 <ovechkin> nope
17:54:16 <ovechkin> emacs has ghci?
17:54:25 <tikhonjelvis`> yeah
17:54:32 * ovechkin seriously starting to think i drop vim and try emacs for a bit
17:54:33 <cmccann> smithw, as I mentioned you can reverse the entire idea of a monad and get something that has "extract" but no "return"
17:54:35 <tikhonjelvis`> Or rather, it has a mode for interacting with an inferior GHCi process.
17:54:37 <cmccann> but that's probably not what you want
17:54:50 <tikhonjelvis`> Which, among other things, lets you search through your command history.
17:54:56 <khanzor`> ovechkin: well, i'm in emacs right now ;)
17:55:04 <ovechkin> that's pretty neat
17:55:13 <tikhonjelvis`> Heh yeah, it has an IRC client too.
17:55:18 <ovechkin> khanzor`: irc from emacs?
17:55:20 <tikhonjelvis`> Multiple IRC clients, actually.
17:55:21 <ovechkin> woah
17:55:23 <khanzor`> yeah, erc
17:55:32 <khanzor`> it's open in a tab
17:55:37 <tikhonjelvis`> They also let you search through your history :)
17:56:32 <smithw> cmccann, yeah, I was trying to formulate an idea for the hash map. it would be theoretically composed of key-value pairs, and a key value pair would be a monad in itself. this way it would make sense that the hash map would be a map, because it would be just a key-value pair in a non-deterministic context :p
17:56:35 <tikhonjelvis> The clever bit is that you use the same commands to do so in both modes. So I sometimes repeat what I said in IRC when I accidentally switch to it instead of a GHCi/shell buffer.
17:56:52 <smithw> *would be a monad
17:57:30 <smithw> what I wanted to say is that the "de-monadization" (sorry for that) of the hash map would be a key-value pair, not just the value
17:57:52 <elliott> smithw: You can't generalise the list monad to Maps just by adding keys.
17:58:04 <elliott> because it essentially jumbles up all your keys :P
17:58:22 <elliott> hmm...
17:58:41 <smithw> elliott, I realize that, I would not actually *implement* it that way, it would be the "concept" represented by the hashmap
17:58:56 <elliott> there's no difference :P
17:59:38 <elliott> return a = Map.singleton mempty a; m >>= k = Map.foldrWithKey (\key a b -> Map.mapKey (mappend key) a `Map.union` b) Map.map k m
17:59:41 <elliott> perhaps that would work.
17:59:47 <elliott> (although I think some of those functions aren't in Data.Map)
17:59:53 <elliott> ymmv, not tested, proably horribly broken
18:01:35 <smithw> elliott, yeah... I guess I should keep reading before I try any more stuff of my own :p thanks again for your help and cmccann's
18:02:46 <tikhonjelvis`> Grr, my connection keeps on randomly resetting so I'm bouncing between being called tikhonjelvis and tikhonjelvis`...
18:06:04 <sahn_> quit
18:07:21 <tikhonjelvis`> I can't quit because I don't have the connection with which I was called tikhonjelvis. I just have to wait until that connection times out.
18:11:14 <cmccann> it's so much fun when people ask questions on SO that demonstrate they haven't grasped the basic syntax of Haskell :T
18:11:54 <tikhonjelvis> particularly if they're trying to do something fundamentally un-Haskelly like mutate a list or something.
18:12:41 <elliott> cmccann: I know, right?!
18:12:58 <elliott> cmccann: it's even more fun trying to figure out wtf their code is meant to do :P
18:13:18 * cmccann upvotes elliott for giving a sound attempt to answer the confusing question :D
18:14:17 <elliott> I'm honing my psychic skills.
18:14:28 <elliott> any day now I'll be able to answer people who join here before they even ask their question
18:14:43 <cmccann> lambdabot can already do that
18:14:44 <elliott> * HaskellFan123 has joined #haskell  <elliott> You're using (/) on an Int. Use div instead.
18:14:49 <cmccann> with @faq
18:16:06 <elliott> the "algebraic data type alternatives are type names" misconception is really common for some reason
18:16:24 <elliott> we should teach GADT syntax to stop the confusion of constructor name/constructor argument type
18:16:33 <cmccann> probably because that's legitimately confusing from the perspective of someone who's completely new
18:17:20 <elliott> right. gadt syntax is less confusing!
18:17:25 <elliott> (it might be, actually :/)
18:17:45 <tikhonjelvis> type Blarg = Int is one thing but data Blarg = Int is something completely different.
18:17:48 <cmccann> the fact that "data Foo = Bar Foo; data Bar = Foo Bar" is a legal definition of two entirely unrelated types is going to trip people up
18:17:57 <elliott> cmccann: I think I also blame LYAH. it only introduces adt declarations in chapter *8*!
18:18:05 <elliott> after higher-order functions and /modules/ of all things
18:18:18 * elliott noticed this just now, trying to find a link to it :P
18:18:21 <tikhonjelvis> Well, I definitely see covering higher-order functions first.
18:18:35 <elliott> tikhonjelvis: even before showing the definition of Maybe?
18:19:01 <tikhonjelvis> I think so, yeah. But maybe it's because my functional programming roots are in Scheme...
18:19:15 <Eduard_Munteanu> I guess it also makes one wonder if there are datatypes at all :)
18:19:21 <elliott> everything is a function!
18:19:23 <cmccann> elliott, btw, ADT usually doesn't mean "algebraic data types"
18:19:35 <elliott> cmccann: yes, I know, but they're so much more common than the real meaning of ADT
18:19:36 <cmccann> Eduard_Munteanu, church encode all the things
18:19:44 <elliott> cmccann: it deserves the abbreviation more
18:19:50 <Eduard_Munteanu> That'd suck, yeah :)
18:20:14 <cmccann> agreed but TLAs are obfuscated enough I'm loathe to attempt redefinition without much greater cause
18:20:46 <elliott> AGT
18:20:49 <clsmith> that kind of makes me wonder, actually: do you think compiling haskell to a language like lambda calculus is necessarily the best approach for a compiler, or would something closer to term rewriting make (as much / more) sense?
18:20:49 <elliott> AlGebraic Type
18:21:05 <elliott> clsmith: well, lambda calculus is "closer" to the semantics
18:21:13 <elliott> but e.g. the reduceron compiles sorta-haskell down to term rewriting and it works well for them :P
18:21:15 <tikhonjelvis> Haskell is already a language "like" lambda calculus :)
18:21:22 <elliott> I think term rewriting has less obvious efficient implementations
18:21:28 <elliott> as it lets you do much more in a sense
18:21:59 <clsmith> oh? i assumed the reduceron compiled to a core-like language too. i'll have to give that a proper look
18:22:29 <Eduard_Munteanu> Modern compilers can have tons of intermediate representations.
18:22:36 <cmccann> one of these days I'm going to write my own introduction to haskell and do things right, by which I mean the way that I want to do them
18:22:51 <elliott> clsmith: the reduceron is a term rewriter at heart
18:22:52 <Eduard_Munteanu> I expect compiling Haskell to something lambda-ish isn't that odd at all.
18:23:01 <elliott> clsmith: so their low-level language is higher-level than most "high-level languages" :P
18:23:12 <clsmith> i suppose i just wonder whether with term rewriting one might be able to write more sophisticated optimisations etc by analysing the graph or something. i don't know :p
18:23:45 <elliott> I think term rewriting is kind of optimisation-hostile exactly because you can rewrite arbitrary graphs. however, the Pure term-rewriting language (successor to Q) is supposed to have fast numerics, and compiles with LLVM
18:24:11 <elliott> cmccann: pfft, I'm better at procrastinating doing that than you are
18:24:41 <cmccann> elliott, yeah, I should probably not write your book for you before I move on to not writing my own
18:24:45 <elliott> haha
18:25:04 <elliott> I wanted to not write my book, but I was busy not destroying the universe
18:25:04 <clsmith> well, 'supposedly' this term-rewriting implementation of pure lambda is the most efficient (iirc). but its benefits might peter out once you expand beyond lambda
18:25:19 <elliott> clsmith: hmm, do you have a pointer? sounds interesting
18:25:26 <clsmith> one moment...
18:25:37 <cmccann> elliott, yeah, you were asking in here the other day about getting somebody else to not write your book for you
18:25:58 <elliott> (hmm, I like how newbies tend to describe type errors as the compiler's problem)
18:26:02 <cmccann> and I didn't agree to do it, so obviously I didn't not start not writing it
18:26:14 <elliott> I didn't make a mistake, the compiler just isn't smart enough to understand me :)
18:26:46 <elliott> cmccann: This is too much double-negation. Be careful or we'll end up in classical logic.
18:27:05 <cmccann> nah it's all CPS encoding behind the scenes
18:30:16 <clsmith> elliott: my memory was a little inaccurate, but i was thinking of An Interaction Net Implementation of Closed Reduction by Ian Mackie
18:36:54 <Mike____> hello again
18:36:59 <Mike____> I got a question
18:37:25 <Mike____> so [] = list and () is what?
18:37:30 <tikhonjelvis> An empty tuple
18:37:34 <tikhonjelvis> also called "unit"
18:37:42 <tikhonjelvis> It's a type with only one value--()
18:37:50 <Mike____> oh.. and whats the best way to work with it?
18:38:10 <tikhonjelvis> It doesn't actually do much, because there's only one value.
18:38:17 <Mike____> so, if i have
18:38:23 <cmccann> :t (<<<) >>> (<<<) >>> (<<<)
18:38:24 <lambdabot> forall (cat :: * -> * -> *) b c a a1 a2. (Control.Category.Category cat) => cat b c -> (a2 -> a1 -> cat a b) -> a2 -> a1 -> cat a c
18:38:25 <cmccann> :t (>>>) <<< (>>>) <<< (>>>)
18:38:26 <lambdabot> forall c c1 (cat :: * -> * -> *) a b c2. (Control.Category.Category cat) => cat a b -> ((cat b c2 -> c1) -> c) -> (cat a c2 -> c1) -> c
18:38:40 <CodeWeaverX> cmccann, that's horrific looking.
18:38:41 <tgeeky> cmccann: to the left... to the right... to the left... to the right
18:38:44 <cmccann> :D
18:39:01 <Mike____> ("aa",0,(a,2)) for example
18:39:01 <tgeeky> CodeWeaverX: yesterday, he actually said someting like "that's pretty useful looking"
18:39:02 <cmccann> the funny thing is they actually do something useful
18:39:07 <Mike____> can i dinamicly check that?
18:39:12 <cmccann> and continue to do so as you add more back and forths
18:39:22 <tgeeky> CodeWeaverX: to which I thought ... what kind of eyes do you have? It looks like functor salad to me.
18:39:46 <cmccann> pf
18:39:48 <parcs`> Mike____: can you what?
18:39:50 <cmccann> no functors in there at all
18:39:56 <cmccann> just category
18:39:58 <tikhonjelvis> Mike____: Tuples of different lengths or that contain different types are distinct in Haskell; that is, each type of tuple is a distinct type.
18:40:19 <Mike____> hmmm
18:40:29 <otters> :t ()
18:40:30 <lambdabot> ()
18:40:32 <otters> oh neat
18:40:33 <tikhonjelvis> So (String, Int, (Int, Int)) is a different type from (String, Int).
18:40:43 * cmccann wonders if anyone can figure out what the back-and-forth operators do 
18:40:49 <Mike____> so if i have somethin like this (("Am",0,(0,0)),("Am",0,(0,1)))... i cant set up a function to recursively check each value agains another one
18:41:14 <tikhonjelvis> I think you're not thinking about tuples correctly.
18:41:21 <tgeeky> cmccann: is this a quiz and you're the teacher, or this is a plea for help?
18:41:28 <cmccann> no, I know what they do
18:41:31 <Mike____> bah -.-
18:41:33 <copumpkin> > uncurry (==) (("Am",0,(0,0)),("Am",0,(0,1)))
18:41:34 <elliott> Mike____: you would really get your problems solved faster by reading LYAH :P
18:41:34 <lambdabot>   False
18:41:36 <Mike____> lists seem easy
18:41:39 <copumpkin> > uncurry (==) (("Am",0,(0,1)),("Am",0,(0,1)))
18:41:40 <lambdabot>   True
18:41:53 <Mike____> ah ah ah
18:41:59 <tikhonjelvis> Mike____: Tuples are nothing like lists. A tuple is a unique type that's just made up of other types.
18:42:05 <parcs`> Mike____: no, tuples aren't defined recursively
18:42:10 <tikhonjelvis> So ordered pairs (Integer, Integer) would be a type.
18:42:26 <tikhonjelvis> But coordinates in three dimensions (Integer, Integer, Integer) would be a *different* type.
18:42:30 <cmccann> tgeeky, that said I'm not a teacher either because you're not going to learn anything useful from those functions
18:42:49 <tikhonjelvis> cmccann: That has never stopped my actual teachers in the past :)
18:42:54 <parcs`> wow, ekg is awesome
18:42:55 <cmccann> ok well
18:42:56 <Mike____> elliott: i have some improvements made though :D And understand just a bit better haskell ^.^
18:43:01 <clsmith> cmccann is an expert in nerd sniping :]
18:43:04 <cmccann> can't argue with that I guess
18:43:08 <cmccann> heh
18:43:46 <otters> there's no Eq instance for (a,b,c,d,e,f)
18:44:15 <elliott> uh
18:44:21 <elliott> otters: citation needed
18:44:26 <otters> says lambdabot p:
18:44:29 <otters> @instances Eq
18:44:29 <lambdabot> (), (a, b), (a, b, c), (a, b, c, d), (a, b, c, d, e), All, Any, Bool, Char, Double, Dual a, Either a b, First a, Float, Int, Integer, Last a, Maybe a, Ordering, Product a, Sum a, [a]
18:44:30 <cmccann> > (1,2,3,4,5,6) == (1,2,3,4,5,6)
18:44:31 <lambdabot>   True
18:44:36 <elliott> lambdabot is full of lies
18:44:39 <otters> indeed
18:44:41 <cmccann> lambdabot is a notorious liar
18:44:49 <tikhonjelvis> :t (.)
18:44:49 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
18:45:00 <cmccann> :t (Prelude..)
18:45:01 <lambdabot> forall b c a. (b -> c) -> (a -> b) -> a -> c
18:46:31 <res_> ... hm, when did I get silenced
18:48:19 <Mike____> so, lists area easier to work with. right?
18:48:36 <tgeeky> certainly if you have functions which expect lists
18:48:47 <cmccann> if you want to do things recursively, you want lists
18:49:04 <Mike____> ok, thanks
18:49:09 <cmccann> if you want to do things with a pre-set group of things with possibly different types, use tuples
18:49:21 <tikhonjelvis> Lists and tuples don't really overlap even though they seem to.
18:49:32 <cmccann> if you want to do things recursively with a collection containing possibly different types, you're wrong and don't actually want to do that
18:49:34 <Mike____> yeah, im starting to understand that now
18:49:50 <otters> Mike____: you need more underscores
18:49:59 <clsmith> cmccann: that's not quite true really, is it? i mean, considering polymorphism
18:50:05 <Mike____> sorry, it's just that mike is already taken -.-
18:50:09 <tgeeky> cmccann: lies. mutual recursion has many places
18:50:12 <tikhonjelvis> You could pull a Python and become __Mike__
18:50:16 <tgeeky> cmccann: and many approaches.
18:50:22 <otters> heh
18:50:25 <Mike____> ah ah ah
18:50:33 <cmccann> tgeeky, eh, true
18:50:52 <cmccann> though non-trivial uses of that probably still fall under "things a novice doesn't actually want to do"
18:50:53 <Mike____> Did any of you guys hate Haskell when starting to work with it?
18:50:55 <tgeeky> cmccann: having said that, a lot of packages offer solutions for mutual recursion but few (if any) compelling examples
18:51:00 <elliott> no
18:51:02 <tgeeky> cmccann: yeah, I had that objection in my mind...
18:51:06 <elliott> though some people did.
18:51:12 <tikhonjelvis> I liked Haskell immediately :) Except for numbers.
18:51:15 <otters> Mike____: yes, I wanted to make it stop caring about types and just let me write code
18:51:20 <parcs`> hmm, ekg doesn't seem to report most of the stats when running the binary. it works fine through ghci however
18:51:21 <otters> and then I realized I was a moron
18:51:21 <elliott> a good way to hate haskell is to try and write programs in it without reading a tutorial
18:51:24 <Mike____> exactly!
18:51:27 <elliott> or understanding data types and syntax
18:51:29 <Mike____> oh god -.-
18:51:34 <cmccann> tgeeky, there are many things it's possible to do for which the answer to "should I do this?" is "if you have to ask, no"
18:51:35 <Mike____> must be a moron -.-
18:51:41 <otters> A good way to hate Haskell is to read a bad monad explanation
18:51:43 <elliott> yes, who would do such a thing?
18:51:52 <tgeeky> cmccann: agreed.
18:52:05 <Mike____> well, I do work quite well with types in c
18:52:05 <tgeeky> cmccann: s/liar/fibber/ :)
18:52:15 <Mike____> just think haskell hates me
18:52:15 <res_> otters: and by that you mean read a monad explanation that isn't especially good, right
18:52:25 <tikhonjelvis> Another good way is to try to write some other language in Haskell. While you can always write C in Perl, writing C in Haskell is decidedly nontrivial.
18:52:25 <otters> res_: so far, I mean any monad explanation
18:52:33 <otters> everybody just seems to "know" what they are
18:52:35 <cmccann> C doesn't really have types in a the sense Haskell does
18:52:35 <res_> otters: ... yeah, pretty much
18:52:41 <cmccann> C's type system is basically the honor system
18:52:42 <otters> I have two distinct concepts in my mind
18:52:47 <res_> everyone seems to either know or not know
18:52:50 <otters> 1. The Box (Maybe, Either, etc)
18:52:55 <clsmith> i found haskell a little confusing at first. i spent a long time trying to work out how to do X, only to realise later that i was only doing X because i was used to imperative languages. and then my entire programming brain broke and reformed and now i find using non-type-checked, impure languages like python extremely stressful, because i never know what's doing what behind my back.
18:52:56 <otters> 2. The Thing that Does Something (IO)
18:52:59 <elliott> otters: read typeclassopedia
18:53:01 <clsmith> true story :p
18:53:03 <otters> won't help
18:53:05 <elliott> yes, it will
18:53:08 <res_> the ones who know just get it and explain it in ways that the people who don't know won't understand anyway
18:53:09 <tikhonjelvis> cmccann: My real point is about trying to use other langauages' idioms.
18:53:15 <otters> okay
18:53:16 <elliott> that's the container vs. computation fallacy and you should immediately forget it
18:53:17 <clsmith> the typeclassopedia helped me
18:53:31 <tgeeky> otters: typeclassopedia is an *excellent* document.
18:53:34 <otters> elliott: didn't realize there was a name for it
18:53:37 <elliott> otters: things from both those categories and neither can be monads
18:53:39 <otters> I'm even worse than I thought
18:53:44 <clsmith> although tbh i understood monads mostly after i just sort of absorbed it through osmosis over a period of about a year
18:53:51 <elliott> otters: additionally, the line between the two is indistinct and often blurred
18:53:57 <elliott> for instance, [a] is a container of a bunch of as
18:53:58 <otters> oh, good
18:54:00 <otters> this is going to be easy
18:54:00 <Mike____> I should make a blog about the stupid things i am trying to do in haskell, and later on check it -.-
18:54:02 <elliott> it also represents a nondeterministic computation with rseult type a
18:54:09 <tgeeky> It answers questions like "what kind of types (and type classes) have people found useful?" and "what are the relationships between those?"
18:54:10 <otters> right
18:54:11 <elliott> otters: it is: you just have to break down the barrier of those false categorisations
18:54:23 <elliott> but yeah, http://www.haskell.org/haskellwiki/Typeclassopedia
18:54:23 <otters> okay, I'll read it
18:54:24 <elliott> no skipping :P
18:54:32 <otters> I don't ever skip tutorials
18:54:35 <otters> heavens to murgatroyd
18:55:01 <tikhonjelvis> I, on the other hand, am never patient enough to finish tutorials...
18:55:06 <otters> holy god
18:55:10 <otters> this diagram is terrifying
18:55:11 <tgeeky> wow. someone went through the effort to convert it onto the wiki page
18:55:13 <cmccann> I'm rarely patient enough to start tutorials
18:55:16 <tgeeky> otters: it's an index
18:55:20 <Mike____> i dont really understand anything about that diagram
18:55:23 <Mike____> is that still haskell?
18:55:23 <otters> yes I know
18:55:34 <clsmith> i do find a lot of the haskellian obsession with mathematics a little daunting still. i'm trying to understand category theory. it's so far eluded me. i'm more an 'english language' student of computing >.>
18:55:39 <tgeeky> otters: you wouldn't open a book, look at the list in the back of the book, and say "holy hell! this book is terifying!"
18:55:41 <tikhonjelvis> cmccann: Heh, I'm also that way. I like just to jump in and hack something. But it's a little tricky in some cases.
18:55:42 <cmccann> I just kinda started bashing on stuff in GHC and skipped around through fragments of the wiki, RWH, the gentle introduction, and sometimes random blogs and stuff
18:55:45 <otters> naw
18:55:58 <tikhonjelvis> cmccann: That sounds more or less like how I started too.
18:56:04 <otters> okay okay so a Functor IS a container
18:56:08 <res_> "Then someone used fmap fmap fmap and my brain exploded." ... okay
18:56:09 <elliott> otters: no
18:56:12 <otters> but
18:56:13 <elliott> otters: no
18:56:14 <tgeeky> otters: you need to read it
18:56:14 <otters> that's what the wiki says
18:56:19 <elliott> does it?
18:56:19 <otters> :(
18:56:20 <otters> yes
18:56:21 <tikhonjelvis> cmccann: Except I also did most of the Write Yourself a Scheme Tutorial.
18:56:21 <elliott> well ignore that part :P
18:56:21 <cmccann> argh
18:56:24 <elliott> IO is a Functor too
18:56:26 <otters> "a Functor represents a “container” of some sort, along with the ability to apply a function uniformly to every element in the container."
18:56:32 <otters> okay
18:56:33 * cmccann sighs
18:56:33 <otters> ignoring
18:56:34 <clsmith> i read graham hutton's book on programming in haskell. that's what first led me to haskell...
18:56:34 <elliott> yeah that's a bad explanation, somebody should replace that part :(
18:56:37 <otters> so far so good
18:56:38 <tikhonjelvis> otters: Except it isn't really a container.
18:56:40 <elliott> otters: Functor is just something that can be mapped over, as simple as that
18:56:47 <otters> yeah okay I'm getting that impression
18:56:48 <Mike____> hmm, I do have a question, how would i exchange values between two tupples?
18:56:50 <elliott> it's a purely abstract concept
18:56:54 <elliott> just keep going :P
18:57:09 <tikhonjelvis> E.g. (->) a is a functor but clearly not a container.
18:57:24 <cmccann> clsmith, keep in mind that Haskell uses very little mathematics compared to #haskell :P
18:57:26 <otters> not helping
18:57:30 <clsmith> Mike____: what do you mean, 'exchange values'?
18:57:31 <elliott> cmccann: My method of learning was to slog through half of YAHT, get completely bored, forget about the language for a year, start to read LYAH, and then realise I already know the language.
18:57:31 <tikhonjelvis> heh
18:57:41 <Mike____> (a,b) = (b,a)
18:57:45 <tgeeky> otters: stop talking to us, print out the document, sit down with a pen and a highliter, and read it like you're doing schoolwork
18:57:53 <tgeeky> (print the PDF version)
18:57:55 <otters> but I don't highlight schoolwork
18:58:03 <cmccann> elliott, I stumbled in the dark for about three months, then started answering questions on SO, which was surprisingly helpful in cementing my own understanding
18:58:05 <tikhonjelvis> tgeeky: That would be a good way to get me to quit early and hate Haskell...
18:58:06 <clsmith> cmccann: haha, true i suppose
18:58:07 <Mike____> tupple a gets the value that the tupple b has, and vice versa
18:58:09 <elliott> I seem to excel at the "read some of a tutorial, give up, and realise I know the language when I actually need to use it" method.
18:58:14 <otters> guess I should look up the definition of determinism
18:58:18 <elliott> then it's just the long haul from "OK" to "good"
18:58:32 <tgeeky> tikhonjelvis: well, you don't normally approach a subject by reading an encyclopedia
18:58:41 <tikhonjelvis> cmccann: Heh yeah. I've learned a bunch of random stuff from answering questions, especially if I didn't answer them entirely correctly :)
18:58:49 <elliott> typeclassopedia is much more than an encyclopedia :P
18:59:08 * elliott hasn't learned anything from answering questions yet :(
18:59:11 <tgeeky> elliott: the format is encyclopedia :o
18:59:20 <elliott> except that things I thought made sense are confusing
18:59:22 <tgeeky> it's not a dictionary, nor an alphabet, nor a blog
18:59:24 <clsmith> it would be great to see an explanation about why monads suit IO so well. i think i understand, but i wouldn't want to write it because i'd probably just confuse everyone a lot more.
18:59:24 <tikhonjelvis> elliott: You just started answering when you already knew too much.
18:59:25 <cmccann> tikhonjelvis, you can often identify when I got the hang of a particular idea because I ended up writing a bunch of long-winded answers explaining it
18:59:31 <elliott> and difficult to explain
18:59:55 <cmccann> clsmith, I have one explanation I'd call "good" but it would probably confuse most people more than it would help
18:59:56 <elliott> tikhonjelvis: Maybe I'll start forgetting things, then :)
19:00:06 <tikhonjelvis> cmccann: For me it's almost the opposite: once I understand something, I can explain it in less words.
19:00:19 <elliott> "How do i write zip function in haskel [haskell] [homework]" "I... I don't even know any more."
19:00:29 <Mike____> LOL
19:00:34 <res_> 22:58 < Mike____> tupple a gets the value that the tupple b has, and vice versa -- ??
19:00:38 <cmccann> tikhonjelvis, the long explanations are usually 20% me figuring it out myself as I go :P
19:00:43 <res_> what do you mean gets the value
19:00:47 <Mike____> ok, let me show you a practicle example
19:01:08 <clsmith> i suspect confusion over immutability :P
19:01:17 <tikhonjelvis> cmccann: Of course the problem is that I now have the urge to explain this to random people outside of SO.
19:01:24 * elliott wrote the entirety of http://stackoverflow.com/questions/9050725/call-cc-implementation/9050907#9050907 before realising I hadn't actually answered the question, and tacked it on as an afterthought
19:01:29 <cmccann> tikhonjelvis, hahaha
19:01:31 <Mike____> tupple a = (1,2). tupple b= (2,1). I want them to be like this: tupple a = (2,1) tupple b = (1,2)
19:01:50 <tikhonjelvis> Luckily I have a friend who uses Scala and is actually interested in this sort of thing :)
19:01:52 <elliott> Mike____: that doesn't make any sense.
19:01:52 <clsmith> i think i'm right
19:01:56 <res_> ... then you define a and b the other way around
19:02:02 <elliott> Mike____: please, please read LYAH :( even if only a few chapters :P
19:02:08 <res_> you can't just up and change what you're talking about
19:02:09 <Mike____> if it were a list, would it make sense?
19:02:11 <clsmith> yeah, it would explain a lot
19:02:12 <elliott> no
19:02:13 <res_> no
19:02:15 <otters> okay "context"
19:02:17 <otters> they like that word
19:02:31 <elliott> I like "context" too, because it means nothing.
19:02:42 <elliott> But people think it means something, so they understand explanations written in terms of it perfectly.
19:02:43 <clsmith> Mike____: haskell is Very Different to most programming languages. LYAH will explain why. :p
19:02:57 <cmccann> context is another vague term for the non-parametric part of a functor, isn't it?
19:02:58 <tikhonjelvis> Also: pretty pictures!
19:03:03 <cmccann> along with "effects"
19:03:07 <tikhonjelvis> yeah
19:03:19 <res_> Mike____: it sounds very much like you are thinking of variables as places to put things
19:03:22 <clsmith> 'parametric'?
19:03:28 <elliott> clsmith: the "a"
19:03:29 <Mike____> res_ exactly
19:03:33 <cmccann> yeah
19:03:34 <tikhonjelvis> I actually found functors as "anything you can map a function over" to be really intuitive.
19:03:37 <clsmith> elliott: gotcha
19:03:52 <cmccann> clsmith, like, the parametric part of a list is the elements, the non-parametric part is the length, roughly speaking
19:03:58 <res_> Mike____: yeah, a bit of LYAH should help
19:04:14 <Mike____> i overlooked at most of it's chapters...
19:04:17 <Mike____> but ill have another go
19:04:21 <clsmith> cmccann: or the cons? :p
19:04:25 <elliott> Can we start giving out awards for reading tutorials? [BRONZE] Literate (read a chapter of a Haskell tutorial)  [SILVER] Schooled (read LYAH)  [GOLD] Ph.D. (read Typeclassopedia)
19:04:25 <clsmith> cons's...
19:04:31 <otters> :t (<**>)
19:04:32 <lambdabot> forall (f :: * -> *) a b. (Applicative f) => f a -> f (a -> b) -> f b
19:04:34 <elliott> It would motivate people!
19:04:42 <otters> so just <*> with flipped arguments?
19:04:45 <elliott> otters: no
19:04:46 <otters> lazy bastards
19:04:49 <otters> hm
19:04:50 <elliott> otters: the function goes after
19:04:52 <Mike____> LOL
19:04:54 <otters> :t (<*>)
19:04:55 <lambdabot> forall (f :: * -> *) a b. (Applicative f) => f (a -> b) -> f a -> f b
19:04:59 <elliott> otters: effect-wise
19:05:00 <otters> that looks like exactly what it is
19:05:03 <elliott> no
19:05:04 <otters> hm
19:05:07 <otters> alright
19:05:09 <elliott> consider
19:05:12 <elliott> ($) <$> func <*> arg
19:05:15 <elliott> (that's (<*>))
19:05:17 <cmccann> clsmith, that works too, since the length tells you how many cons constructors you have
19:05:18 <elliott> flip ($) <$> arg <*> func
19:05:19 <otters> right
19:05:27 <elliott> now consider that arg and func both e.g. read a line
19:05:29 <cmccann> clsmith, the point is it's the structure that fmap leaves unchanged
19:05:48 <otters> wait you're fmapping $
19:05:53 <jtobin> elliot: i've read/worked through the entirety of LYAH, much of RWH, the picnic tutorial, source of various packages.. and i still don't consider myself `literate' :)
19:05:57 <otters> oh, oh
19:06:00 <otters> okay never mind I'm with you
19:06:05 <cmccann> and I really wish we had a consistent and not misleading term for the structural/non-parametric/whatever part of a functor
19:06:08 <clsmith> cmccann: does fmap necessarily leave it unchanged? or just tend to? (i don't think it's a property.)
19:06:09 <elliott> jtobin: Literate as in "can read words written in the English language" :P
19:06:15 <Frijolenborg> anybody here believe that niggers are human?
19:06:16 <clsmith> (so long as it changes it the same way after n fmaps)
19:06:17 <cmccann> if only to discourage people from using "effects"
19:06:22 <elliott> marienz: ^
19:06:24 <tikhonjelvis> jtobin: You just need more hubris :)
19:06:37 <elliott> @where ops
19:06:37 <lambdabot> shapr Cale glguy dons sjanssen dcoutts Saizan dibblego conal Philippa bos arjanb xerox Heffalump kosmikus wli Pseudonym Igloo quicksilver monochrom Lemmih jmcarthur copumpkin
19:06:37 <quintessence> clsmith: fmap id == id, so it had better
19:06:40 <elliott> ban Frijolenborg pls
19:06:41 <cmccann> clsmith, fmap is required to by the laws for a functor instance
19:06:47 --- mode: ChanServ set +o copumpkin
19:07:06 <copumpkin> elliott: sup
19:07:09 <elliott> copumpkin: <Frijolenborg> anybody here believe that niggers are human?
19:07:15 <copumpkin> oh whoops
19:07:23 --- kick: Frijolenborg was kicked by copumpkin (Your behavior is not conducive to the desired environment.)
19:07:25 <clsmith> cmccann: what are the laws? i only knew of > fmap g . fmap f == gmap (g . f)
19:07:25 <Frijolenborg> Just visit Chimpout Forum
19:07:28 --- mode: copumpkin set +b *!~JiggyBlkM@201.130.152.147.dsl.dyn.telnor.net
19:07:28 --- kick: Frijolenborg was kicked by copumpkin (Your behavior is not conducive to the desired environment.)
19:07:39 <elliott> I wonder how many users that place has actually got from freenode.
19:07:41 <elliott> surely can't be many.
19:07:49 <cmccann> probably picked up a few trolls
19:07:50 <copumpkin> oh I visit the forum all the time
19:07:54 <copumpkin> I just don't advertise it
19:07:55 --- mode: copumpkin set -o copumpkin
19:08:01 <elliott> lol
19:08:21 <clsmith> *fmap
19:08:39 <otters> so (e ->) is a Functor instance?
19:08:40 <cmccann> clsmith, not changing the structure is pretty much it really, everything else follows
19:08:47 <tikhonjelvis> otters: yeah
19:08:48 <cmccann> otters, that's not valid syntax but yes
19:08:51 <copumpkin> otters: yeah, but you can't write it like that
19:08:52 <otters> yeah
19:08:54 <otters> I know
19:08:57 <otters> it's just easier to read
19:08:59 <cmccann> it is
19:09:04 <cmccann> and I wish it was legal syntax :[
19:09:22 <tikhonjelvis> Yeah, the first time I saw (->) e I was a little bit confused.
19:09:54 <cmccann> I was entirely too happy when I first realized that the ((->) e) Applicative gives you combinatory logic
19:10:12 <JoeyA> When the documentation says "atomicModifyIORef acts as a barrier to reordering", does this mean that after atomicModifyIORef is called, a subsequent readIORef in another thread is guaranteed to see the new value?
19:10:14 <clsmith> cmccann: so what, the actual property is that the 'context' doesn't change, and that simply implies that the composition rule?
19:10:15 <elliott> cmccann: could have saved some time by reading the paper :P
19:10:35 <elliott> clsmith: the non-parametric part stays the same, which corresponds to fmap id = id
19:10:35 <otters> so fmap :: (a -> b) -> f a -> f b
19:10:57 <elliott> (For Functors f.)
19:11:00 <otters> right
19:11:10 <cmccann> clsmith, by parametricity, if it doesn't change the non-parametric part then all it can do is apply the fmap'd function
19:11:10 <JoeyA> In other words: is it safe to share an IORef among threads if I modify it with atomicModifyIORef, and read it with readIORef?
19:11:13 <otters> but I don't really understand what that would look like specifically for a ((->) e) instance
19:11:17 <clsmith> ahh, i didn't remember seeing that
19:11:25 <elliott> otters: just keep reading :P
19:11:32 <cmccann> otters, try expanding the type signature for fmap on that instance
19:11:40 <elliott> otters: that's one of the exercises later
19:11:45 <otters> cmccann: how do you do that
19:11:53 <cmccann> manually :P
19:11:53 <Mike____> Ok, now i cant really understand something. If haskell doesnt really have variables, and as i've been reading, it's all about math operations on everything. How should we be able to make a game like rubik's cube, where we need to store values and change them from one place to another
19:11:54 <otters> on a specific instance, that is
19:11:56 <Mike____> my head is a mess
19:11:57 <otters> ...:(
19:11:57 <elliott> I would suggest only coming to IRC when you run into trouble with one of the exercises
19:12:03 <elliott> or you'll never get anywhere :P
19:12:09 <cmccann> (a -> b) -> ((->) e a) -> ((->) e b)
19:12:25 <tikhonjelvis> Especially if you get three people trying to help you at the same time :)
19:12:25 <cmccann> or (a -> b) -> (e -> a) -> (e -> b)
19:12:30 <otters> oh, I see
19:12:33 <mauke> Mike____: games don't need to modify state. you can just build a new state
19:12:33 <cmccann> otters, can you guess what that does from the type?
19:12:40 <elliott> tikhonjelvis: the stereo soundsystem is losing its charm...
19:12:44 <otters> cmccann: well, sorta
19:12:48 <elliott> most sound systems don't argue amongst themselves :P
19:13:07 <clsmith> cmccann: one last thing i've been wondering is whether 'everything' is just a 'bad functor' where any fmap f = id ? :p
19:13:11 <tikhonjelvis> It's more like a nausea-inducing 3D movie than a stereo.
19:13:33 <cmccann> clsmith, you mean an identity functor? :P
19:13:43 <elliott> clsmith: huh?
19:13:46 <elliott> that doesn't type
19:13:53 <cmccann> clsmith, "newtype Id a = Id a"
19:13:59 <otters> cmccann: it almost looks like function composition
19:14:00 <elliott> fmap f = id --> fmap :: (a -> b) -> f a -> f a
19:14:05 <elliott> otters: bingo!
19:14:07 <tikhonjelvis> I guess you can imagine an implicit functor where fmap is just function application.
19:14:08 <cmccann> otters, it is, congrats
19:14:11 <otters> oh shit!
19:14:15 * otters smarty pants
19:14:32 <cmccann> tikhonjelvis, yes
19:14:49 <tikhonjelvis> Functors all the way down :)
19:15:02 <cmccann> tikhonjelvis, the implicit identity functor is also a monad, where bind is also function application
19:15:21 <elliott> otters: btw, you may have to spend some time on the typeclassopedia exercises
19:15:30 <elliott> don't be discouraged -- they're there to help you develop a deep understanding of the underlying concept
19:15:35 <otters> I'll try
19:16:11 <clsmith> elliott: what? how does 'fmap f = id' not work?
19:16:28 <cmccann> clsmith, tikhonjelvis: just look at the instances here http://hackage.haskell.org/packages/archive/transformers/0.2.2.0/doc/html/src/Data-Functor-Identity.html
19:16:33 <cmccann> and remember that newtypes don't exist at runtime
19:16:36 <elliott> clsmith: I presumed you meant: does every "f" admit a laws-violating instance "fmap f = id"?
19:16:38 <cmccann> clsmith, the types don't work
19:16:46 <elliott> the answer is: no, that implementation does not type
19:16:51 <elliott> id :: a -> a but you're using it as f a -> f b
19:16:54 <elliott> f a =/= f b
19:17:44 <cmccann> elliott, alas, if we could use the implicit identity functor we'd be able to give return its proper type
19:18:00 <cmccann> as a natural transformation Id a -> m a
19:18:01 <tikhonjelvis> Hmm, what about fmap = const unsafeCoerce?
19:18:11 <cmccann> haha
19:18:26 <cmccann> that must be the worst functor instance possible
19:18:40 <clsmith> i think that's what i was trying to formulate, yeah.
19:18:53 <clsmith> as in, it just swallows all your fmaps
19:18:56 <elliott> cmccann: right after PolyKinds came out I wrote a Mon class that does both Monoid and Monad :P
19:19:02 <cmccann> :D
19:19:17 <cmccann> clsmith, anyway yes that makes sense and is often how things are defined in category theory
19:19:27 <cmccann> but the type system doesn't let you do it without newtype wrappers
19:19:37 <elliott> cmccann: class Mon (~>) (**) one m where mu :: one ~> m; nu :: m**m ~> m
19:19:38 <cmccann> one of the many ways that haskell really isn't suited to doing category theory
19:19:47 <elliott> (Mon (->) (,) () m) is (Monoid m)
19:19:59 <elliott> (Mon NaturalTransformation Compose Idntity m) is (Monad m)
19:20:01 <elliott> *Identity
19:20:11 <tikhonjelvis> Yeah, the parallels with the actual mathematics seems a little weird.
19:20:31 <tikhonjelvis> Of course, I haven't bothered learning much about actual category theory.
19:20:34 <cmccann> tikhonjelvis, yes, and I know just enough of the mathematics to understand some of how weird Haskell's use of them is
19:20:40 <tikhonjelvis> But I was confused about endofunctors for a while.
19:20:54 <tikhonjelvis> Then it turns out all Haskell Functors are actually endofunctors.
19:21:03 <tikhonjelvis> So I'm still confused but I don't really care (yet).
19:21:17 <cmccann> tikhonjelvis, they are and they aren't
19:21:27 <cmccann> they're functors from all of Hask to a subcategory
19:21:41 <cmccann> which means they're also endofunctors on Hask
19:21:42 <tikhonjelvis> Haskell is making some of the abstract algebra courses tempting.
19:21:45 <cmccann> depending on how you want to look at it
19:22:00 <cmccann> tikhonjelvis, probably fun but don't expect it to relate directly to Haskell much :P
19:22:05 <tikhonjelvis> Yeah
19:22:22 <cmccann> tikhonjelvis, browsing hackage.haskell.org/package/algebra might be fun though
19:22:24 <tikhonjelvis> I'm taking all the classes outside my core requirements based on how much fun they seem.
19:22:42 <tikhonjelvis> And the core requirements for my major are surprisingly minimal.
19:23:14 <tikhonjelvis> I can learn practical things when somebody's paying me :)
19:23:53 <clsmith> i wish my university had an Advanced Functional Programming module alongside its java one... the standard module ended at explaining MonadPlus and didn't go any further than that :(
19:24:22 <cmccann> they explained MonadPlus?
19:24:28 <cmccann> awesome, you should share that with the rest of us
19:24:28 <clsmith> well, i say 'explained'
19:24:32 <cmccann> because it doesn't make any sense to me
19:24:39 <clsmith> 'described' might be a better word
19:24:43 <cmccann> oh, well
19:24:46 <tikhonjelvis> Mine doesn't have any functional programming classes. But the programming language design course is sometimes taught in Haskell, I think.
19:24:46 <cmccann> in that case :P
19:24:58 <otters> hmm
19:25:06 <otters> is ((,) e) part of a tuple or what?
19:25:13 <cmccann> otters, yes
19:25:18 <cmccann> just like ((->) e)
19:25:19 <otters> okay
19:25:27 <tikhonjelvis> Happily we don't have any advanced classes in Java either (as far as I know). So it's a compromise.
19:25:33 <cmccann> otters, write it as (e,) if you want
19:25:42 <otters> okay
19:25:48 <clsmith> i've just taken MonadPlus to mean a monoidal monad. and i will ignore any attacks on this (no doubt wrong) understanding.
19:26:07 <cmccann> clsmith, that's a fine understanding that may or may not agree with all instances
19:27:45 <cmccann> though to be fair if anything is going to be agreed on, monoid behavior is probably the most likely
19:30:46 <res_> functional programming doesn't generally get taught enough
19:31:20 <cmccann> dijkstra would probably say that programming doesn't get taught enough
19:31:24 <cmccann> and I would agree
19:32:25 <tikhonjelvis> Yeah. My very first class was functional, but nothing else since :( It makes me sad.
19:32:51 <tikhonjelvis> Some other schools (I think CMU) have a lot of functional programming though.
19:33:00 <Zamarok> weird question, but.. I've been using Haskell for math and ProjectEuler problems and such, but I'm still not quite sure what a monad is lol. All I know is that they're important, and a useful tool.. what's the go-to resource for reading up on that?
19:33:27 <SubtleArray> Carnegie-Mellon University Professor Robert Harper teaches functional programming to first semester students. But because of the popularity of OOP, classes usually shift to that afterwards. :(
19:33:33 <cmccann> Zamarok, a monad is a very abstract concept that describes a bunch of common types
19:33:36 <elliott> Zamarok: Have you read LYAH?
19:33:41 <elliott> cmccann: It's not *that* abstract.
19:33:44 <cmccann> I recommend not worrying about it beyond that
19:33:44 <elliott> Zamarok: It covers monads.
19:33:58 <elliott> Beyond that, don't worry too much about it, like cmccann said; it's one in a large sea of concepts.
19:34:06 <cmccann> elliott, it's more abstract than most programming languages are capable of expressing :P
19:34:07 <Zamarok> elliott: I'm part-way through.. I guess I'll go finish that up
19:34:07 <elliott> People just focus on it because it sounds funny. :p
19:34:12 <elliott> Zamarok: Nah, take your time.
19:34:23 <Jafet> @quote monads.are
19:34:24 <lambdabot> revenantphx says: My monads are itchy.
19:34:25 <elliott> Zamarok: It's not hugely important at all, it's just a common pattern that we have a nice abstraction for.
19:34:26 <tikhonjelvis> elliott: It's pretty abstract in the sense that what it is does not trivially map to how it's used or what any particular Monad represents.
19:34:55 <Zamarok> I see. Well one more question.. I understand that the JQuery object is a monad.. how so?
19:35:04 <cmccann> ignore that
19:35:06 <tikhonjelvis> Umm. It isn't really.
19:35:06 <otters> oh boy
19:35:11 <cmccann> it's full of confusion
19:35:18 <Zamarok> that's what I was told, at least
19:35:27 <tikhonjelvis> Yeah, that was not entirely true.
19:35:29 <cmccann> it gets halfway to some sort of point but it's not going to make anything clearer
19:35:48 <cmccann> the source of the jquery monad thing, I mean
19:35:58 <tikhonjelvis> jQuery is sort of like an instance of the list type, which is a Monad.
19:36:00 <cmccann> if you've only heard that secondhand then definitely just ignore it, it doesn't help
19:36:11 <elliott> Zamarok: Ignore anything anybody says to you about monads.
19:36:12 <SubtleArray> Would it be fair to say monads are like units? Or classes in other languages?
19:36:16 <elliott> SubtleArray: No.
19:36:17 <cmccann> no
19:36:21 <SubtleArray> :(
19:36:28 <tikhonjelvis> SubtleArray: What do you mean by units?
19:36:32 <mbernste1n> Monads just sound scary.  Once you get them they're pretty amazing
19:36:32 <tikhonjelvis> units of measure?
19:36:34 <elliott> Does it matter? :P
19:36:37 <tkahn6_> SubtleArray: monads are like burritos wrapped in space suits
19:36:40 <Zamarok> elliott: lol except you though, right?
19:36:46 <elliott> tkahn6_: Not helpful for someone who actually doesn't know.
19:36:47 <elliott> Zamarok: Right!
19:36:49 <SubtleArray> I just looked up monads in my dictionary. Lol
19:36:56 <tkahn6_> elliott: i kid i kid
19:37:10 <elliott> tkahn6_: It's OK, you just forgot the essential part: they're *nuclear waste* burritos.
19:37:19 <elliott> You'll confuse newbies if you leave that bit out.
19:37:22 <elliott> Even if it seems obvious to us.
19:37:22 <tkahn6_> elliott: hahah
19:37:27 <cmccann> @quote endospacesuit
19:37:27 <lambdabot> syntaxglitch says: a monad is an endospacesuit on a burrito category
19:37:35 <tkahn6_> lol
19:37:55 <tikhonjelvis> SubtleArray: Did you find the definition from philosophy? Because that has nothing to do with Haskell/math monads.
19:37:58 <tkahn6_> SubtleArray: monads are a way of composing computations
19:38:07 <cmccann> Zamarok, on a more serious note, don't worry about what monads "are", just use the types themselves
19:38:19 <SubtleArray> tikhonjelvis: Yes.
19:38:38 <cmccann> yeah, leibniz isn't relevant here
19:38:42 <tkahn6_> SubtleArray: different monads have different semantics in what composition means
19:38:46 <SubtleArray> tkahn6: That sounds a little like a class to me... But I'm a Haskell newbie.
19:38:56 <tkahn6_> SubtleArray: well it is a type class
19:39:03 <cmccann> which is entirely unrelated to OO classes
19:39:07 <tkahn6_> yes
19:39:08 <tkahn6_> haha
19:39:09 <tikhonjelvis> SubtleArray: That's because he's describing how monads are used more than what they are.
19:39:16 <clsmith> what, monads aren't necessarily a way of composing computations?
19:39:24 <clsmith> you're confusing me, and i thought i knew what monads were
19:39:42 <tikhonjelvis> A monad is just a special type of pointed functor.
19:39:43 <cmccann> eh, they're a monoid on endofunctors, that's really all there is to say on the matter
19:39:44 <Zamarok> does every Haskell programmer wonder what the hell monads are for a while then?
19:39:52 <cmccann> jokes aside that really does get the heart of it :P
19:39:53 <elliott> Zamarok: Unfortunately.
19:39:54 <tikhonjelvis> And a pointed functor is just a special type of functor.
19:40:02 <tikhonjelvis> And a functor is just any type you can map over.
19:40:04 <tkahn6_> SubtleArray: don't worry about the category theoretic explanation
19:40:05 <Zamarok> Or maybe that would apply to 'functional programmers' and not just 'Haskell programmers'
19:40:07 <Jafet> Zamarok: no.
19:40:07 <elliott> I need a time machine so I can kill everybody who propagated the "monads are hard and scary and difficult and you must know them immediately" meme :(
19:40:12 <tkahn6_> SubtleArray: it's just pedantry at this point
19:40:26 * tkahn6_ prepares to be crucified
19:40:44 <cmccann> tkahn6_, the problem with the category theory explanation isn't that it's bad
19:40:44 <clsmith> i was confused as hell and then one day i found i could write nested data type monads and people wouldn't laugh at my code, and i realised i was ok at haskell despite not really understanding category theory. and it was a good day.
19:40:49 <cmccann> it's actually very useful
19:40:57 <tikhonjelvis> If somebody had explained what a monad *is* in terms of functors I would have understood it faster than the endless analogies.
19:41:09 <cmccann> tkahn6_, the problem is that understanding the explanation is no easier than understanding monads to begin with
19:41:21 <otters> hahaha
19:41:26 <otters> the monad tutorial fallacy
19:41:34 <tikhonjelvis> Functors, at least in Haskell, are easy. So are pointed functors. So is join. And there you have monads.
19:41:37 <Zamarok> true, because I have no idea what a functor is
19:41:41 <tkahn6_> cmccann: i don't know about that, is there anything wrong with explaining that it's a way to compose computations?
19:41:43 <clsmith> tikhonjelvis: the typeclassopedia is the closest to that, i find
19:41:44 <tikhonjelvis> A functor is anything you can map over.
19:41:49 <clsmith> it really did help me a lot, that
19:42:21 <Zamarok> tikhonjelvis: is that for the context of Haskell, or all of math?
19:42:31 <tikhonjelvis> Zamarok: Haskell
19:42:36 <cmccann> tkahn6_, it's extremely vague but probably not misleading so shrug
19:42:37 <tikhonjelvis> They're more complicated in math, I think.
19:43:02 <Zamarok> makes sense, everything is xD
19:43:04 <cmccann> no, functors and monads aren't really any more complicated in math, they're just applied to things more complicated than haskell
19:43:05 <elliott> tkahn6_: like applicative, and monoid, and ...
19:43:05 <tikhonjelvis> But for Haskell, a functor is just any type f such that there exists a function fmap of the type (a -> b) -> f a -> f b
19:43:07 <cmccann> there's a difference
19:43:14 <elliott> tkahn6_: oh, and Category of course
19:43:17 <tkahn6_> elliott: fair enough
19:43:18 <elliott> that's the closest to "compose"
19:43:25 <elliott> tikhonjelvis: No it's not.
19:43:36 <elliott> tikhonjelvis: It's any type f with such a fmap such that fmap id = id.
19:43:38 <tikhonjelvis> elliott: Well, there are also some laws about how they behave, I guess.
19:43:42 <tkahn6_> lol and now SubtleArray has been scared away
19:43:42 <elliott> Exactly one law.
19:44:02 <elliott> SubtleArray and Zamarok would do best to turn off their IRC clients for a few hours until this dies out :P
19:44:04 <cmccann> Functor is so simple that even GHC understands it
19:44:07 <tikhonjelvis> So let me be vague and restate it as a type f with a "reasonable" function (a -> b) -> f a -> f b
19:44:08 <SubtleArray> Lol. No, I'm just reading the chat and listening to a video on functional programming.
19:44:17 <cmccann> with {-# LANGUAGE DeriveFunctor #-} at least
19:44:21 <Zamarok> SubtleArray: ooh, link please?
19:44:48 <SubtleArray> http://channel9.msdn.com/Shows/Going+Deep/Lecture-Series-Erik-Meijer-Functional-Programming-Fundamentals-Chapter-1
19:45:01 <tikhonjelvis> That said, just think of a functor as any type you can map a function over.
19:45:24 <Zamarok> watched that one a few months ago
19:45:26 <tikhonjelvis> And ignore anything you learned about "functors" in Java or ML because those are different.
19:45:40 <clsmith> (side node: how is spj so enthusiastic during talks? i mean, wow.)
19:45:46 <tkahn6_> clsmith: he is awesome
19:45:51 <tkahn6_> clsmith: any talk with him is fun to watch
19:46:28 <SubtleArray> I've noticed. Programming lectures aren't supposed to be interesting, but this one is. :D
19:46:54 <elliott> of course lectures are supposed to be interesting :P
19:47:06 <tikhonjelvis> Heh, you guys should see one of my professors last semester.
19:47:08 <Zamarok> finding a good programmer that is also a charismatic presenter must be a challenge
19:47:24 <tikhonjelvis> Enthusiastic was an understatement.
19:47:25 <SubtleArray> :D
19:47:28 <elliott> finding an SPJ is a challenge
19:47:51 <clsmith> a wild spj appears!
19:47:57 <tkahn6_> his talk on the history of haskell is good
19:48:15 <tkahn6_> there are actually two versions i know of on the internets
19:48:33 <SubtleArray> I'm watching this in the hopes it'll help my C++ brain think more Haskelly.
19:48:40 <clsmith> weasels: polymorphism?
19:48:54 <weasels> what's that?
19:48:59 <weasels> errrr, pardon?
19:49:08 <elliott> clsmith: wat.
19:49:12 <clsmith> weasels: just commenting on your being otters and weasels. :p
19:49:18 <weasels> oh, yeah
19:49:19 <elliott> oh
19:49:21 <weasels> heh
19:49:21 <weasels> heh
19:49:23 <weasels> hmm
19:49:28 <tkahn6_> SubtleArray: did you do any of those 99 problems?
19:49:33 <elliott> weasels: you might want to learn what polymorphism is before monads :P
19:49:33 <weasels> garage door opener tripped the breaker
19:49:45 <weasels> I know what polymorphism is, I just worded my question poorly
19:49:47 <SubtleArray> tkahn6: Not yet. I just got started on the vids.
19:49:47 <elliott> ah
19:49:48 <weasels> :|
19:50:25 <tkahn6_> SubtleArray: i really recommend you do some of the earlier ones asap, it will kick start your transition to a functional approach
19:51:01 <tkahn6_> SubtleArray: they're not hard, but they force you to think in terms of recursion and immutability
19:51:21 <elliott> tkahn6_: The 99 problems are really low-quality IME. :(
19:51:25 <Zamarok> SubtleArray: I say do ProjectEuler problems to think Haskelly.. once I switched back to JavaScript for work, I ended up writing most functions recursively, and with barely any state change
19:51:30 <elliott> At least there's a bunch of Lisp mixed in with the Haskell and the problem statements suck.
19:51:37 <tkahn6_> yeah
19:51:43 <tikhonjelvis> They were ported from another language, I think.
19:51:47 <tkahn6_> they were
19:51:49 <elliott> Project Euler is generally recommended against for beginners, since there's a lot of numerics that trip up things like e.g. strictness before you should really be bothering with them.
19:51:49 <tkahn6_> 99 lisp problems
19:51:50 <tkahn6_> heh
19:51:54 <clsmith> SubtleArray: i was an imperative programmer for a long time before haskell, and it was a bit of a struggle to change how my brain worked. but now that it has, i find using non-functional languages limiting, and impure languages uncomforting... so it may take a bit of getting used to, but it really changes your brain for the better :p
19:51:55 <elliott> tkahn6_: 99 prolog before that, I think
19:52:18 <cmccann> elliott, we need better exercises :[
19:52:21 <SubtleArray> :D
19:52:21 <Zamarok> elliott: yep I learned that the hard way.. I still have a half finished project that segfaults for some reasons
19:52:26 <SubtleArray> Where can I find the 99 questions?
19:52:41 <clsmith> the exercises in hutton's book are quite good imo :p
19:53:00 <tkahn6_> i was getting really into haskell and then i had an interview with microsoft for an internship and i started talking about using function pointers and mapping and they were like wat
19:53:11 <cmccann> haha
19:53:21 <tkahn6_> also i said i really like linux
19:53:25 <elliott> Zamarok: segfaults?!
19:53:27 <elliott> Zamarok: please report a GHC bu
19:53:28 <elliott> g
19:53:38 <elliott> (unless you used the foreign function interface)
19:53:38 <clsmith> tkahn6_: well, microsoft employ spj!
19:53:46 <elliott> (or a function with "unsafe" in the name)
19:53:49 <elliott> (then it's a bad bug)
19:53:58 <tikhonjelvis> clsmith: Of course MSR is different from Microsoft proper.
19:54:01 <tkahn6_> clsmith: i know but i think his influence hadn't reached the xbox live people yet :p
19:54:16 <elliott> clsmith: Microsoft Research is Microsoft's do-goodery branch :p
19:54:18 <Zamarok> elliott: I think I'm just filling the stack with too many thunks.. but I dunno, not experienced enough to debug this one. It's only like 20 lines or so >_>
19:54:19 <clsmith> tkahn6_: unfortunate.
19:54:22 <tikhonjelvis> An MSR internship would be cool. I don't know if I'd do a normal Microsoft one though.
19:54:28 <elliott> Zamarok: No.
19:54:32 <elliott> Zamarok: That could cause a stack overflow.
19:54:33 <E3D3> I like learning Haskell maybe because of my 'state' & 'action' wrestlings. Its the first language that let me laugh (doing it online).
19:54:38 <elliott> A segmentation fault is a GHC bug, and you should report it.
19:54:43 <tkahn6_> clsmith: they also didn't know _any_ open source technologies i talked about working with for personal projects
19:54:44 <clsmith> yeah, i would be really happy to join MSR. not so much MS...
19:54:48 <cmccann> MSR probably has some influence on the C# team
19:54:48 <Mike____> can i do this: test :: ((Char,Int),(Char,Int)) -> (Char,Int) test ((a,_)(_,_)) = (a1,_) where a1 = a
19:54:53 <Mike____> would that make sense?
19:54:59 <elliott> no
19:55:00 <SubtleArray> Found it. http://www.haskell.org/haskellwiki/H-99:_Ninety-Nine_Haskell_Problems
19:55:02 <elliott> not even vaguely
19:55:08 <Mike____> god
19:55:15 <cmccann> Mike____, please go read a tutorial or something
19:55:18 <tikhonjelvis> cmccann: I think there's a lot of influence, in both directions even.
19:55:22 <cmccann> you are not going to get anywhere like this
19:55:34 <Mike____> i tried a tutorial
19:55:37 <Mike____> but then change the types
19:55:47 <Mike____> raizes :: (Double,Double,Double) -> (Double,Double) raizes (a,b,c) = (r1,r2) where r1 = (-b + r) / (2*a)
19:55:49 <Mike____> something like this
19:55:57 <Mike____> i was reading about that
19:56:01 <Mike____> and thought I could change it
19:56:08 <elliott> you changed the types and turned variables into _ and broke the syntax :P
19:56:14 <Zamarok> elliott: oops, you're right.. it's an overflow. Like I said, not experienced enough for that one lol.. I'll come back to it
19:56:24 <cmccann> Mike____, programming requires understanding what you're doing, not banging on random keys
19:56:26 <elliott> Zamarok: oh, ok then :P
19:56:33 <Mike____> ahaha
19:56:40 <elliott> cmccann: Only in some languages!
19:56:42 <otters> not to sound unkind
19:56:49 <cmccann> elliott, PHP isn't programming
19:56:57 <elliott> cmccann: Malbolge is.
19:56:58 <tkahn6_> cmccann: banging random keys is how you write perl
19:57:01 <Mike____> i cant believe i got an A++ on c, and ill be getting an F on haskell
19:57:05 <SubtleArray> Lol
19:57:13 <SubtleArray> :(
19:57:19 <clsmith> Mike____: it's rather a different thing :p
19:57:26 <Zamarok> is Prelude's sum function 'safe'? Or could that cause a stack overflow?
19:57:34 <Mike____> haskell is a mindf*ck
19:57:43 <otters> C is easy
19:57:48 <quintessence> Mike____: only if you learn C first
19:57:53 <tkahn6_> otters: debateable
19:57:57 <Mike____> Can't go back in time :<
19:58:02 <SubtleArray> Very different... I've used many languages, and Haskell is probably the most difficult for my huemahn brain to grasp.
19:58:06 <cmccann> C is easy as long as you don't require your program to work correctly
19:58:07 <clsmith> i do wonder what my programming would be like had i learned haskell as my first language
19:58:09 <tkahn6_> otters: writing good C code takes some skill
19:58:15 <otters> ehhh
19:58:24 <otters> yeah
19:58:27 <tikhonjelvis> If you just bang on the keyboard, you'll probably get valid Perl ;)
19:58:28 <elliott> Writing C is approx. 1000x harder than writing Haskell.
19:58:33 <Mike____> LOL
19:58:41 <clsmith> elliott: once you know both.
19:58:43 <Zamarok> C is an easy language, sure.. but doing most ANYTHING well takes skill.. C especially, cause it's so easy to fail
19:58:46 <tkahn6_> clsmith++
19:58:47 <tkahn6_> haha
19:59:18 <tikhonjelvis> Heh, writing fast C is trickier than people make it out to be. There is definitely some magic involved :)
19:59:19 <SubtleArray> Zamarok: Lol. You have a point. Easy to learn, but also easy to make mistakes.
19:59:22 <Mike____> well, back to reading for me -.-
19:59:49 <SubtleArray> Mike, have you seen this tutorial?
19:59:49 <cmccann> writing C is easy as long as y** Segmentation Fault (core dumped)
19:59:57 <tkahn6_> cmccann: hahaha
20:00:13 <SubtleArray> http://en.wikibooks.org/wiki/Haskell/YAHT
20:00:13 <Zamarok> Haskell is far harder to learn than C, I say, but after that.. no competition, writing C is for very brave souls
20:00:19 <otters> writing C is actually pretty easy.cxbb4b4646%^&*#$^˙®ø´ç¶*(O&
20:00:24 <otters> sorry, forgot NUL
20:00:31 <cmccann> yes, C is relatively easy to learn
20:00:33 <Zamarok> haha
20:00:35 <SubtleArray> It's really good. Cuts to the chase faster than manyof the other tutorials I've encountered.
20:01:14 <cmccann> on the other hand, C++ is harder to learn than Haskell and harder to use than C
20:01:15 <otters> damn x-chat
20:01:21 <cmccann> I really don't know why people still use it at all
20:01:51 <td123> cmccann: industry standard
20:01:57 <tkahn6_> cmccann: typed abstract data types are nice
20:02:07 <tikhonjelvis> It's nicer than C in some ways. Just completely crazy.
20:02:09 <otters> ugh
20:02:10 <quintessence> there exists a subset of C++ that's easier to do many things in than C
20:02:12 <clsmith> i really like the idea of proving programs' correctness, but it's a lot of work, and the languages which help you with that don't have inference etc (because it's undecidable and, stuff). i really would love such a language designed for programmers instead of mathematicians :p
20:02:14 <PiotrLegnica_> writing correct C is much harder than writing correct C++
20:02:25 <tkahn6_> cmccann: but god help you if you get an error message, templates all the way down
20:02:29 <tikhonjelvis> clsmith: Haskell?
20:02:34 <clsmith> PiotrLegnica_: i always found C++ too hard for my brain
20:02:50 <otters> and as everybody will tell you, overloading << for streams is dumb
20:02:58 <otters> I don't know why but apparently it is
20:03:21 <clsmith> tikhonjelvis: not really what i mean, i think
20:03:21 <mbernstein> C is a rather small language, I don't think it's particularly hard - you just need to be taught idiomatic ways to write it is all
20:03:27 <mbernstein> Like anything else, really.
20:03:30 <clsmith> otters: overloading in general is very confusing
20:03:32 <tikhonjelvis> Heh, since I learned C++ before C and streams before bitwise operators, I associated << with the former rather than the latter.
20:03:38 <otters> yeh
20:03:59 <otters> but it's not like << is THE lshift operator
20:04:07 <otters> well, actually
20:04:10 <mbernstein> Overloading is a poor person's pattern matching imo
20:04:25 <Zamarok> C will not complain if you want to do something stupid.. that's one of the difficult parts. You won't know how stupid your code is until a long while later, many times
20:04:41 <PiotrLegnica_> proper error propagation in C is verbose hell
20:04:50 <clsmith> i do think a language should be high level, and the compiler should do the dirty work
20:05:02 <tikhonjelvis> mbernstein: Until you get into nonstandard stuff like intrinsics.
20:05:25 <tikhonjelvis> Then it stops being small and elegant and becomes big and annoying.
20:05:36 * cmccann just finds C++ too complicated with too many things to keep track of that just get in the way of writing programs that work
20:06:33 <tikhonjelvis> I dunno, I actually liked C++. But I didn't use it too much for anything nontrivial.
20:06:46 <tkahn6_> if y'all haven't read this yet, it's a classic: http://thread.gmane.org/gmane.comp.version-control.git/57643/focus=57918
20:06:47 <Frijolenstein> Are you tired of niggers?
20:06:48 <Zamarok> Haskell is the C++ of some alternate universe out there.. I want to find it and move there
20:06:49 <Frijolenstein> I am!
20:06:56 <clsmith> ops?
20:06:56 --- mode: ChanServ set +o glguy
20:06:56 <Frijolenstein> That is why I joined Chimpout Forum!
20:07:03 <tkahn6_> linus on c++
20:07:03 --- mode: glguy set +b *!*@201.170.62.60.dsl.dyn.telnor.net
20:07:03 --- kick: Frijolenstein was kicked by glguy (Frijolenstein)
20:07:31 <tikhonjelvis> Linus is always very, umm, persuasive.
20:08:50 <tkahn6_> it's funny if you just google "linus on c++" that is the second hit and it looks like it was inorganically placed there because there's no describing text or anything, just the link
20:09:07 <cmccann> tikhonjelvis, the very soul of tact
20:09:31 <tikhonjelvis> I really liked his talk on Git.
20:09:41 <PiotrLegnica_> he's good programmer, but he shouldn't talk about C++
20:10:14 <PiotrLegnica_> there are good rebuttals online that explain that far better than I could
20:10:26 <elliott> and rebuttals to the rebuttals, and so on ad infinitum
20:10:35 <cmccann> every defense of C++ I've seen reads like someone suffering from severe stockholm syndrome to be honest
20:10:37 <tikhonjelvis> This #haskell--we all know how to argue about which language is best ;)
20:11:07 <PiotrLegnica_> in the end, it's just pointless bickering about tools
20:11:12 <Zamarok> That rant is why I never learned C++, and decided to focus on a different language
20:11:24 <tkahn6_> tikhonjelvis: his talk on git is very good
20:11:26 <tkahn6_> i recommend it
20:11:30 <otters> bah, too tired
20:11:36 <otters> I can't make heads or tails of the MonadFix section
20:11:39 <Zamarok> agreed, and his rant on SVN is good too
20:11:52 <clsmith> Zamarok: i tried to learn C++, failed, and learned haskell instead
20:11:52 <tikhonjelvis> I think his rant on SVN *is* his talk on Git.
20:11:58 <tkahn6_> "if you disagree with me you are ugly and stupid"
20:12:08 <Mike____> OMG, i cant believe myself
20:12:14 <Mike____> i rotate the rubik's cube on my own
20:12:16 <Mike____> :D~~~~~~~~~~~~~~~~~~~~~~~~~
20:12:20 <Zamarok> clsmith: same here, also C and JavaScript. I'd say we chose correctly
20:12:33 <tikhonjelvis> Really? I like JavaScript.
20:12:55 <clsmith> C and Haskell are my two favouritest languages. for different reasons, obv. :p
20:12:58 <tikhonjelvis> Also, C is neat.
20:13:02 <PiotrLegnica_> I'll pick Haskell over C++ any time (as soon as I can produce anything non-trivial), but would never pick C
20:13:05 <Zamarok> I stopped using JavaScript for a while to learn Haskell.. now I'm a web developer, so I write JS a lot.. but I write it as Haskelly as possible
20:13:08 <PiotrLegnica_> I value my time too much
20:13:08 <Mike____> hurray for me ,_,
20:13:29 <elliott> cmccann: people will defend anything
20:13:49 <tikhonjelvis> Like Java. I have met too many people who like Java too much.
20:13:55 <elliott> you can find thousands of peoples who will argue endlessly that PHP is "just a tool" as suitable as any other, and if you don't agree with them they'll just call you unreasonable
20:14:05 <tkahn6_> Zamarok: i use null as a poor-man's Nothing
20:14:05 <otters> But what about all the abstract manager framework factory factories?
20:14:09 <elliott> this is why arguing with people out to defend or attack a language is silly :P
20:14:17 <cmccann> elliott, well, it's about using the right tool for the job, which is always the tool someone is already holding
20:14:47 <cmccann> anyway the important point is that every language is objectively terrible
20:15:07 <Zamarok> tkahn6_: yea I do too when I write CoffeeScript, cause everything has to have a return val
20:15:08 <SubtleArray> Jave seems to appeal to object-oriented evangelicals.
20:15:08 <cmccann> and I use haskell because it's somewhat less terrible than any other I know of
20:15:22 <shergill> cmccann: and subjectively awesome?
20:15:29 <otters> somewhat
20:15:36 <tikhonjelvis> I'm not sure if programming languages are actually objectively horrible.
20:15:39 --- mode: ChanServ set -o glguy
20:15:46 <PiotrLegnica_> some are
20:15:56 <Zamarok> I feel compelled to share Haskell with anyone who prefers to code in Java
20:15:56 <tikhonjelvis> Yes. Some are. But I mean all of them.
20:16:12 <clsmith> i use haskell because i find myself less stressed at the end. no worrying about null everywhere. no worrying about whether f() calls g() behind my back, changing Everything. it really makes such a difference to my mental coding health.
20:16:14 * cmccann has high standards
20:16:25 <amiller> i'm at this weird stage where I want to write everything program out with a dependently typed specification but i'm no where near competent enough to actually see all the proofs through with coq
20:16:34 <cmccann> amiller, I know the feeling :P
20:16:36 <tikhonjelvis> I've found programming languages to be more expressive and easier to use than natural language for certain tasks.
20:16:41 <otters> all languages are objectively horrible
20:16:44 <clsmith> i was using python the other day and i felt like breaking down. i couldn't even typecheck. there were almost tears.
20:16:53 <cmccann> tikhonjelvis, natural languages are even worse, yes
20:17:07 <tikhonjelvis> Heh, I know exactly how you feel: I think Python is horrible even not compared to Haskell.
20:17:08 <SubtleArray> Before discovering functional programming, I used C++ for work, and Python for fun. I really like the way functional programming looks on paper. That's why I'm trying to learn Haskell now. So much potential in this language, I think.
20:17:16 <cmccann> people make fun of legalese because it's the closest you get to programming in natural language :P
20:17:17 <clsmith> tikhonjelvis: thankfully we don't use natural languages to talk to things as stupid as computers.
20:17:19 <tikhonjelvis> And yet I have to use it for my projects. It makes me sad :(
20:17:25 <amiller> i'm convinced that haskell is agda/coq on easy mode
20:17:30 <clsmith> tikhonjelvis: i use it at work :(
20:17:35 <Zamarok> speaking of typechecking... someone made a static typing system for JavaScript... it uses Haskell syntax!
20:17:36 <amiller> i don't mean that at all as a dismissal, coq and agda are both way too hard
20:17:36 <otters> easy mode?
20:17:37 <otters> :<
20:17:46 <clsmith> coq is really quite a mindfuck
20:17:51 <Zamarok> http://typedjs.com/
20:18:11 <elliott> Zamarok: posers :P
20:18:13 <clsmith> i do wish for a simpler, friendlier coq
20:18:22 <cmccann> amiller, pf, don't be chicken
20:18:24 <tikhonjelvis> hmm
20:18:39 <mbernstein> tikhonjelvis: ducked typing makes me want to cry at this point (re: python, ruby, etc)
20:18:41 <tikhonjelvis> Would it be difficult to write a simple dependently typed language?
20:18:51 <cmccann> tikhonjelvis, depends on what you mean by simple
20:19:00 <cmccann> but probably not
20:19:00 <shergill> i picked up haskell only recently, but i have to admit it's one of the prettier languages i know of. other languages which i would consider pretty/elegant: lisp, ocaml, even python. but there are definitely benefits of static typechecking which are missed in languages like python
20:19:00 <Zamarok> elliott: If only web browser could run Haskell.. until then, I have to pretend as best I can for work lol
20:19:04 <Mike____> elliott:  thanks for your help, when you told me what I did with the _ on that function, i quite understood that i was making a new variable and missing parameters
20:19:04 <mbernstein> tikhonjelvis: checking to make sure objects are actually what you except them to be is beyond annoying and tear jerking
20:19:09 <tikhonjelvis> cmccann: Umm. Trivial. Not useful--just a proof of concept.
20:19:33 <cmccann> tikhonjelvis, then yes, and I can find you a paper that does that as an example if you like
20:19:43 <elliott> Zamarok: it can
20:19:47 <clsmith> cmccann: yes please :p
20:19:49 <elliott> although it's experimental
20:20:00 <elliott> Mike____: hehe, yeah you can't use _ in an expression
20:20:00 <tikhonjelvis> There's going to be an open-ended project at the end of my compilers class, and I was thinking of trying to write a dependently typed language for it.
20:20:01 <elliott> only as a pattern
20:20:04 <amiller> lol cmccann "could i write a simple dependently typed language?" "depends on what type of simple!"
20:20:07 <PiotrLegnica_> mbernstein: in most cases you should assume they are, and not do any explicit type-checking
20:20:16 <shergill> clsmith: agreed about coq
20:20:26 <Zamarok> elliott: oh yea? Who's developing that, and for which browser?
20:20:26 <cmccann> amiller, I regret nothing
20:20:26 <PiotrLegnica_> I rarely get any type errors in Python
20:20:35 <tikhonjelvis> Python has really annoying things beyond typing. Mutable default arguments !?
20:20:40 <elliott> Zamarok: it's compiling to js
20:20:48 <elliott> various attempts have been made at it
20:20:57 <mbernstein> PiotrLegnica_: It's ruby and it's moreso the people I work with - I have to write defensively so that their errors don't make the world catch fire :(
20:20:58 <elliott> <tikhonjelvis> cmccann: Umm. Trivial. Not useful--just a proof of concept.
20:21:08 <elliott> tikhonjelvis: you can implement a dependently-typed lambda calculus in two, three pages of code
20:21:09 <amiller> tikhonjelvis, you could totally do that, the kernel language for CIC is really short, i believe agda's is as well, also epigram may be simpler than either of those
20:21:12 <elliott> augustss has a blog post doing it
20:21:19 <elliott> it will, of course, be almost impossible to write useful code with
20:21:23 <cmccann> tikhonjelvis,  http://strictlypositive.org/Easy.pdf
20:21:27 <shergill> hmm i don't think the problem with coz is in the language itself
20:21:27 * shergill could be wrong
20:21:30 <amiller> syntax sugar comes cheap
20:21:44 <elliott> you need more than syntactical sugar to make dependent programming palatable
20:21:45 <tikhonjelvis> Cool. I'll be sure to read that paper.
20:21:51 <Zamarok> bah, I'll stick with CoffeeScript for now.. I can at least write Haskelly code if I'm disciplined
20:22:12 <otters> eww
20:22:12 <tikhonjelvis> Zamarok: Have you considered something like (Clojure|paren)script?
20:22:19 <tikhonjelvis> Because lisp is nice.
20:22:19 <otters> runtime type checking
20:22:38 <Zamarok> tikhonjelvis: I have.. I am considering clojurescript, but have been overwhelmed with other things
20:22:40 <cmccann> tikhonjelvis, I like how the introduction describes type hackery in Haskell :]
20:22:45 <clsmith> i think more syntactic sugar, and more inference where possible. dare i say, more hand-holding?
20:22:54 <Zamarok> tikhonjelvis: who is clojurescript anyway? do you like it?
20:22:56 <cmccann> "a ghastly hodgepodge"
20:23:00 <Zamarok> how*, not who
20:23:22 <tikhonjelvis> Zamarok: I've never used it. I did play around with parenscript (something similarish for Common Lisp), but did nothing significant with it.
20:23:35 <clsmith> cmccann: thanks :p
20:23:57 <otters> scala's type system is amazing
20:24:26 <tikhonjelvis> I also wrote a simple lisp interpreter in JavaScript that let me embed Scheme code in <script> tags. That was neat and fun to use but obscenely slow.
20:24:35 <noddy2OOO> otters: you like it?
20:24:46 <Zamarok> tikhonjelvis: You like CoffeeScript? I love it.. it lets me get pretty similar code after compilation, so its easy to debug and check performance
20:24:50 <clsmith> i used to like lisp, but since i've used iswim-style languages it just seems so crude
20:25:04 <cmccann> I still like scheme :[
20:25:12 <clsmith> i like it conceptually
20:25:14 <tikhonjelvis> Zamarok: Nope. I don't like significant whitespace or classes or some other stuff. I like plain JavaScript more.
20:25:17 <SubtleArray> :D
20:25:18 <clsmith> just not actually using it <.<
20:25:18 <cmccann> but I've gotten kind of attached to type systems
20:25:19 <tikhonjelvis> Ooh, I like Scheme too.
20:25:24 <SubtleArray> Scheme looks like fun. Never touched it though
20:25:29 <tikhonjelvis> Nah, even using Scheme is rather fun.
20:25:45 <Zamarok> agreed Scheme is great
20:25:48 <tikhonjelvis> Even elisp is fun, and elisp is an unholy aberration as far as lisps go.
20:26:10 <noddy2OOO> which scheme do you scheme-using people use?
20:26:36 <tikhonjelvis> Umm, I used stk for class but you shouldn't use it because it sucks. Then I wrote my own, but it's even worse and doesn't implement the full standard completely.
20:26:36 <clsmith> when i did i would use chibi-scheme :p
20:26:36 * cmccann hasn't actually used it in ages :T
20:26:55 <shergill> stk here
20:27:06 <tikhonjelvis> I want to write a Scheme compiler (rather than interpreter) in the near future. It sounds fun.
20:27:18 <Zamarok> Anyway, Haskell taught me about recursive data structures.. which I utilized for a Chrome extension written in CoffeeScript.
20:27:19 <shergill> though mostly because i didn't have a choice (a programming tool was written in it)
20:27:21 <Zamarok> Any Redditors in here? It's a Reddit extension ;) https://github.com/zachfogg/RedditOC
20:27:31 <cmccann> tikhonjelvis, write a dependently-typed scheme, kill two birds with one stone
20:27:40 <tikhonjelvis> cmccann: That's actually what I was thinking.
20:27:47 <tikhonjelvis> Or rather, a dependently-typed subset of Scheme.
20:27:50 <tikhonjelvis> No mutation.
20:28:00 <cmccann> tikhonjelvis, you'll need to mangle the syntax a bit to get type annotations that aren't horrible
20:28:13 <tikhonjelvis> I can live with mangling syntax.
20:28:19 <cmccann> but yeah, some scheme-ish with dependent types would be fun
20:28:25 <cmccann> whatever unholy hybrid it ends up being
20:28:32 <tikhonjelvis> The neat trick is how much expressiveness macros give you, for free.
20:28:37 <tikhonjelvis> From the compilers point of view, that is.
20:28:42 <noddy2OOO> hey, does anyone here seriously use scala?
20:28:51 <elliott> noddy2OOO: try #scala perhaps
20:28:51 <tikhonjelvis> I don't, but I know some people who do :)
20:28:56 <noddy2OOO> no, no
20:29:03 <noddy2OOO> elliott: _here_
20:29:06 <elliott> tikhonjelvis: you don't like significant whitespace?
20:29:06 <cmccann> the only people I know of who use scala regularly complain about it a lot
20:29:15 <tikhonjelvis> elliott: Yeah, it's annoying.
20:29:21 <elliott> noddy2OOO: well it's not really a haskell question
20:29:22 <tikhonjelvis> Even (especially?) in Haskell.
20:29:30 <noddy2OOO> yup, just quit my job in scala.
20:29:38 <tikhonjelvis> Seriously, having to realign everything when I move a do kills me every time.
20:29:40 <noddy2OOO> elliott: i wanted to compare type system experience
20:29:44 <Zamarok> tikhonjelvis: I hated it at first.. but my anger faded and now I love it
20:29:52 <elliott> tikhonjelvis: If you want to see what layoutless code in Haskell likes, let me introduce you to our friend zzo38 :)
20:29:55 <elliott> *looks like,
20:30:20 <cmccann> tikhonjelvis, well stop using do blocks then
20:30:25 <cmccann> they're overrated anyhow
20:30:25 <tikhonjelvis> Haskell is actually okay (but annoying) because the structure is usually pretty evident.
20:30:45 <tikhonjelvis> E.g. it's rare you want a function with the same name immediately outside a where binding.
20:31:00 * cmccann remains ambivalent about syntactic whitespace
20:31:06 <tikhonjelvis> In languages like Python, statements make equal amount of sense at different indentations.
20:31:44 <tikhonjelvis> So I *do* use it in Haskell (and, naturally, in Python), but it makes me sad.
20:31:52 <Zamarok> that can be less confusing, but you sacrifice some ability to express yourself
20:31:58 * hackagebot hedis-pile 0.2.2 - Caching mandatory data with Redis  http://hackage.haskell.org/package/hedis-pile-0.2.2 (AlexanderDorofeev)
20:32:01 <clsmith> a sufficiently advanced editor would just realign the do block for you
20:32:13 <clsmith> (oh man i love this 'sufficiently advanced' stuff. :D)
20:32:13 <tikhonjelvis> Eh, I was actually thinking of writing that. It wouldn't be difficult.
20:32:24 <MaskRay> these sufficiently advanced editor are few...
20:32:28 <tikhonjelvis> Emacs!
20:32:33 <noddy2OOO> vim!
20:32:38 <clsmith> ed
20:32:39 <ion> grub!
20:32:42 <noddy2OOO> lol
20:32:42 <MaskRay> te
20:32:43 <tikhonjelvis> cat!
20:32:49 <shergill> lol
20:32:58 <clsmith> anyhoo, it's time to go to bed. goodnight, all
20:32:58 <tikhonjelvis> night
20:33:18 <cmccann> tikhonjelvis, btw if you do give the "dependently-typed scheme" madness a shot let me know, I'd be interested to look and/or contribute
20:33:33 <shergill> obligatory xkcd reference: http://xkcd.com/378/
20:33:37 <SubtleArray> Leksah user here. ^_^
20:33:45 <cmccann> probably'd end up being saner than the kind of language I'd create if left to me own devices
20:33:51 <tikhonjelvis> cmccann: I might. It depends on the exact details of the project and what my partner thinks.
20:33:53 <SubtleArray> And Vim for when I'm C++ing.
20:34:07 <cmccann> which would likely resemble an unholy union of Agda and APL
20:34:11 <tikhonjelvis> cmccann: I'm not so sure. I have some pretty stupid ideas of what makes a good language.
20:34:21 <elliott> cmccann: APL :)
20:34:23 <shergill> cmccann: and APL fan?
20:34:26 <tikhonjelvis> E.g. the one I'm building in my spare time lets you change operator precedence at runtime.
20:34:27 <shergill> *an
20:34:38 <elliott> who isn't?
20:34:39 <tikhonjelvis> Which I recognize as stupid, but am keeping anyhow.
20:34:45 * elliott mostly knows J, though.
20:34:47 <MaskRay> the most important feature makes me stick with emacs is tab-cycle of haskell-mode
20:34:48 <cmccann> shergill, in theory, I haven't actually made time to learn it yet. :T
20:34:52 <shergill> i guess i need to be around more haskellers
20:34:55 <cmccann> or any of its related languages, like J
20:35:21 <tikhonjelvis> MaskRay: C-c C-l and the inferior-haskell mode are also really nice.
20:35:53 <xil> hi everyone. Not necessarily Haskell specific, but how do I convert the fractional interval [0,1) to [-1,1] and (-1,1) respectively? I know it's possible, but I can't figure out how
20:35:55 <MaskRay> tikhonjelvis: yes, they are
20:35:56 <shergill> cmccann: ah. but still admiration instead of abhorrence. i don't see that very often
20:36:11 <elliott> anyone who abhors APL & friends is just trying to be as cool as dijkstra
20:36:16 <MaskRay> (substract 1) . (*2)
20:36:17 <elliott> or is boring
20:36:23 <cmccann> shergill, you should see the quotes I have in my Stack Overflow profile
20:36:34 <shergill> cmccann: link?
20:36:35 <MaskRay> misunderstood
20:36:43 <tikhonjelvis> APL is awesome. That is all.
20:36:50 <cmccann> shergill, http://stackoverflow.com/users/157360/c-a-mccann
20:36:54 <elliott> anyone who appreciates point-free style and functional programming through combinators rather than recursion can appreciate J
20:37:01 <shergill> elliott: in my experience it's more likely to be the latter
20:37:16 <MaskRay> xil: make a bijection from [0,1) to [0,1] first
20:37:30 <elliott> cmccann: oh man, don't tell dijkstra's ghost you quoted him next to Iverson
20:37:39 <cmccann> elliott, for a while I was one of the top-ranked people on SO for the J tag because of someone asking how to implement the weird pointfree verb mashup thing in other languages
20:37:48 <elliott> haha
20:37:49 <cmccann> elliott, :D
20:38:02 <elliott> it's not really a mashup, it's just that fgh = liftA2 (g) (f) (h)
20:38:08 <cmccann> yeah
20:38:09 <elliott> e.g. +%# = sum / length
20:38:13 <elliott> = liftA2 (/) sum length
20:38:16 <MaskRay> xil: pick the series of 2^k (k < 0) and assign them special map
20:38:19 <elliott> (except it works on arbitrary-dimensional arrays)
20:38:22 <elliott> (and types)
20:38:26 <cmccann> elliott, yes, I know
20:38:28 <elliott> yeah
20:38:29 <ion> In case this someone has missed this: Conway's Game Of Life in APL http://youtu.be/a9xAKttWgP4
20:38:39 <elliott> J cheats a lot by just making everything work on 1 or 2 :P
20:38:46 <elliott> 3 argument functions? yeah, we have arrays for those
20:38:58 <tikhonjelvis> ion: Yeah, that's why I think APL is awesome.
20:39:00 <elliott> ion: i love that video
20:39:21 <cmccann> elliott: http://stackoverflow.com/a/3399172/157360
20:39:29 <tikhonjelvis> The resulting program is about the length of "hello, world" in Java.
20:39:46 <elliott> oh, oops, I forgot the /
20:39:55 <elliott> +/%# = fold add / length, etc.
20:40:24 <elliott> cmccann: http://stackoverflow.com/tags/j/topusers
20:40:28 <elliott> cmccann: you're still #3 :P
20:40:34 <cmccann> hahahaha
20:40:36 <cmccann> that's hilarious
20:40:45 <Jafet> g is just an operator
20:40:54 <elliott> hmm, I'm #4 in [haskell] :| :/
20:41:04 <elliott> better ask a really stupid question to fix that
20:41:05 <Jafet> Anyone who's learnt some multivariate calculus should know that
20:41:24 <xil> MaskRay: can you explain that a bit more? I don't quite understand how that forms a bijection to [0,1]. Looks like at best it would be a bijection with (0,1], which could also be accomplished by just subtracting the interval from 1
20:41:36 <elliott> cmccann: quick, what's a really stupid question?
20:41:49 <tikhonjelvis> How about the usual IO a -> a question?
20:41:58 <tikhonjelvis> Everybody asks that! Every time.
20:42:13 <cmccann> elliott, ask how to get the string out of an IO String so that you can figure out why your output is printed in the wrong order
20:42:14 <monochrom> "how to convert IO String to Int"
20:42:35 <elliott> monochrom: :D
20:42:35 <Jafet> @quote IO.String
20:42:35 <lambdabot> shachaf says: getLine :: IO String contains a String in the same way that /bin/ls contains a list of files
20:42:37 <elliott> dammit, now I'm tempted to actually do that
20:42:39 <ion> read :: String -> Int, readIO :: IO String -> Int
20:43:03 <elliott> how to convert IO Int to Double to calculate mean with my data type data Foo = IO Int | Double
20:43:09 <cmccann> yes
20:43:10 <elliott> without recursion
20:43:11 <monochrom> "how to convert IO ByteString to Int" will stir an uproar
20:43:43 <cmccann> monochrom, to be fair that still makes more sense than using a bytestring as unicode text
20:43:45 <elliott> dons has answered 589 questions about Haskell
20:43:49 <elliott> are there even that many questions about Haskell?
20:43:57 <elliott> I say there's 580, tops
20:43:58 <Jafet> They're not unique questions
20:43:59 <tikhonjelvis> That's like 10% of them...
20:44:16 <elliott> tikhonjelvis: 10.4%, in fact
20:44:16 <tikhonjelvis> Of course, there are at least that many questions about getting stuff out of IO.
20:44:52 <tikhonjelvis> And the obligatory "look at my code that vaguely resembles Haskell and fix it" ones are pretty numerous.
20:45:09 <ion> How about a rule that on every April 1st the answer to that question is unsafePerformIO?
20:45:11 <Zamarok> the other 89.6% are probably monad-related
20:45:19 <otters> but that's the answer anyway
20:45:21 <otters> it's just stupid and terrible
20:45:23 <cmccann> also, ask why you're getting an error but don't say what error it is
20:45:30 <cmccann> and ideally, paste some code that compiles fine
20:45:36 <tikhonjelvis> Then paste in an error from some other language :)
20:45:37 <monochrom> haha
20:45:42 <ion> cmccann: Naturally
20:45:55 <ion> A multi-page STL error
20:46:01 <cmccann> speaking of monads: http://stackoverflow.com/tags/monads/topusers
20:46:06 <cmccann> :T
20:46:36 <tikhonjelvis> I'm almost exactly half way to the top users for that tag...
20:46:36 <elliott> tikhonjelvis: now I want to post a question with haskell title, tags and text, but C++ code
20:46:43 <elliott> and an error message from PHP
20:46:53 <elliott> and give it 5 minutes to see which tags it ends up having
20:47:01 <monochrom> hahaha
20:47:32 <Jafet> http://pikersden.eu/~eclipser/err.txt
20:47:50 <elliott> cmccann: why am I at the top of the 30 day chart there
20:48:00 <elliott> I don't remember answering that many monad questions :(
20:48:16 <cmccann> http://stackoverflow.com/search?q=user:1097181+[monads] :P
20:48:29 <tikhonjelvis> I think the monad tag gets applied fairly loosely to questions.
20:48:38 <cmccann> yeah it's kinda sketchy
20:48:51 <ion> jafet: hah
20:49:00 <cmccann> I should go back and retag a bunch of things to add it so I can get a silver badge
20:49:12 <monochrom> how do I convert Iteratee IO ByteString to String?
20:49:40 <elliott> monochrom: unsafeCoerce
20:49:51 <cmccann> monochrom, and then gripe an anyone who asks about unicode, tell them "it's just text, that's all"
20:50:13 <elliott> cmccann: more importantly, Iteratee IO is contravariant :P
20:50:18 <elliott> that /consumes/ a ByteString
20:50:24 <cmccann> :D
20:50:37 <ion> “How do I convert Iteratee IO to String?”
20:50:41 <monochrom> I support the plan that on April 1 we should recommend unsafePerformIO. I propose to add unsafeInterleaveIO ("to restore laziness") and unsafeCoerce ("to fix type errors")
20:50:44 <elliott> unsafeCoerce#
20:50:48 <elliott> you need the # to cast between kinds
20:51:15 <tikhonjelvis> What is a reasonable use case for casting between kinds?
20:51:24 <monochrom> and yeah, add # to all of them :)
20:51:26 <cmccann> monochrom, we should also point people to augustss's BASIC monad as an example of idiomatic code
20:51:29 <Ralith> seeing how broken you can make ghc?
20:52:13 <ion> Oh, a question about a serious project which you’ve been writing in the BASIC monad.
20:52:25 <elliott> unsafeCoerce #: unsafeCoerce Harder
20:52:30 <elliott> # is like II in Haskell film title language
20:52:49 <cmccann> unsafeCoerce# :: Electric Boogaloo
20:53:15 <tikhonjelvis> What does its type look like?
20:53:17 <Jafet> tikhonjelvis: as far as I know, there isn't one
20:53:32 <ion> I’m curious, how do you actually use unsafeCoerce# to cast between kinds?
20:53:45 <elliott> ion: # and *, for example
20:53:48 <elliott> not * -> * and * :P
20:53:59 <ion> ah :-D
20:54:08 <elliott> tikhonjelvis: unsafeCoerce# :: a -> b is how it's shown, but it's actually unsafeCoerce# :: forall (a :: ??) (b :: ??). a -> b or something I think
20:54:16 <cmccann> just the idea of casting between boxed and unboxed types makes my skin crawl :[
20:54:17 <elliott> I don't know whether it's ?? or ? or any of that rubbish, but it's the one above * and #
20:54:26 * shergill waits for the resurrection of unsafestCoerce
20:54:31 <elliott> tikhonjelvis: it's in GHC.Prim so it doesn't really have a type signature
20:54:31 <cmccann> haha
20:54:35 <elliott> it just exists, magically
20:54:40 <tikhonjelvis> Magic is good
20:54:56 <cmccann> @quote unsafestCoerce
20:54:57 <lambdabot> No quotes match. Have you considered trying to match wits with a rutabaga?
20:55:00 <cmccann> @quote unsaferCoerce
20:55:00 <lambdabot> No quotes match. Are you on drugs?
20:55:03 <cmccann> bah
20:55:21 <ion> I have a project in which i need to create a primitive function that doesn’t really have a type signature. How to do that? Thanks.
20:55:32 <cmccann> haha
20:55:55 <Jafet> @quote isJust
20:55:55 <lambdabot> ddarius says: isJust :: Maybe a -> Bool; isJust = unsafeCoerce
20:55:57 <elliott> ion: ask spj
20:56:01 <elliott> he'll help you!
20:56:15 <ion> @quote isBool
20:56:15 <lambdabot> No quotes match. I am sorry.
20:56:22 <ion> @quote isTrue
20:56:22 <lambdabot> shachaf says: isTrue :: Bool -> Bool; isTrue = unsafeCoerce
20:56:40 <tikhonjelvis> Heh, I love how lambdabot is polite towards ion but not cmccann.
20:56:50 <elliott> I am sad to report I'm actually laughing at loud at isTrue coming up again
20:56:55 <elliott> I thought I had a sense of humour :(
20:57:20 <ion> I’m quite sure it *is* in fact funny.
20:57:40 <cmccann> tikhonjelvis, lambdabot doesn't like me I guess :[
20:57:51 <elliott> @quote does lambdabot like me?
20:57:51 <shergill> cmccann: http://hpaste.org/56741 there you go
20:57:51 <lambdabot> No quotes for this person. You speak an infinite deal of nothing
20:57:56 * elliott cries
20:58:01 <shergill> your gem
20:58:17 <cmccann> shergill, haha that was fun
20:58:29 <shergill> it was something alright lol
20:59:40 <ion> @quote do you still love me?
20:59:40 <lambdabot> No quotes for this person. Your mind just hasn't been the same since the electro-shock, has it?
20:59:44 <Mike____> Is it possible to fix the encoding?
20:59:53 <Mike____> in order to use accents and all
20:59:59 <tikhonjelvis> Mike____: What do you mean?
21:00:07 <Mike____> i try to output ã á
21:00:13 <Mike____> and it gives me an utf-8 error
21:00:16 <tikhonjelvis> Hmm
21:00:28 <tikhonjelvis> > putStr "ã á"
21:00:34 <lambdabot>   <IO ()>
21:00:38 <tikhonjelvis> ...
21:00:41 <ion> mike: Are your locale settings correct? What does the locale command print?
21:00:46 <Jafet> > ord <$> "ã á"
21:00:48 <lambdabot>   [227,32,225]
21:01:04 <tikhonjelvis> > "ã á"
21:01:05 <lambdabot>   "\227 \225"
21:01:18 <Mike____> I was using if ... else ... then error "á ã"
21:01:20 <ion> > ord . "ã á"
21:01:21 <lambdabot>   [227,32,225]
21:01:38 <Mike____> other way
21:01:45 <monochrom> works for me
21:01:47 <Mike____> if then ... else error "ã á"
21:01:58 * hackagebot wai-middleware-cache-redis 0.1.0 - Redis backend for wai-middleware-cache  http://hackage.haskell.org/package/wai-middleware-cache-redis-0.1.0 (AlexanderDorofeev)
21:02:03 <tikhonjelvis> Haskell's if syntax annoys me.
21:02:12 <quintessence> that it's syntax you mean?
21:02:13 <Mike____> is it a bad practice?
21:02:15 <tikhonjelvis> yes
21:02:20 <monochrom> no
21:02:21 <Mike____> oh
21:02:25 <Mike____> what should I use instead?
21:02:32 <tikhonjelvis> I meant yes @quintessence
21:02:34 <monochrom> if-then-else is just fine
21:02:40 <Mike____> okok
21:02:50 <tikhonjelvis> So using it is fine, I just don't like that it's syntax sugar.
21:03:02 <SubtleArray> case expressions are nice for if and elses, but a little more difficult to implement.
21:03:14 <cmccann> tikhonjelvis, bet you don't like infix operators either? :P
21:03:16 <tikhonjelvis> What about just an if function? That would be nice and happy.
21:03:18 <monochrom> I would take if-then-else over "case () | x>0 -> ..." any day
21:03:24 <SubtleArray> :D
21:03:25 <tikhonjelvis> cmccann: Well, I do like lisp :)
21:03:28 <Mike____> i have this. if(n==1) then funct a b c else error "á ã"
21:03:41 <Mike____> im guessing i cant do much with error
21:03:54 <monochrom> works for me, no utf-8 error
21:03:55 <tikhonjelvis> But I just think that not only could if be a function, but it would also look *less* annoying that way.
21:03:57 <Mike____> does error quit the execution?
21:04:05 <monochrom> depends
21:04:08 <Jafet> if' True = const; if' False = flip const
21:04:20 <tikhonjelvis> flip const is just id, isn't it?
21:04:26 <ion> bool :: a -> a -> Bool -> a
21:04:26 <elliott> no
21:04:32 <elliott> flip const takes an extra arg
21:04:33 <Jafet> Mike: yes.
21:04:35 <tikhonjelvis> ah
21:04:42 <cmccann> ion, with the correct argument order, of course
21:04:45 <tikhonjelvis> yeah
21:04:46 <Mike____> ok, thanks
21:05:04 <Jafet> Mike: whatever problem you're having with UTF-8, it probably doesn't have anything to do with GHC.
21:05:46 <shergill> tikhonjelvis: why is if annoying, or is all syntactic sugar annoying to you?
21:05:55 <cmccann> ion, speaking of which I'm going to clean up a few of the glaring mistakes in Overture this weekend :P
21:06:01 <ion> ok :-)
21:06:12 <Mike____> how can i fix a utf-8 decoding error?
21:06:16 <ion> It would be nice to get it into Hackage as well.
21:06:22 <tikhonjelvis> Well, it's a bit of both: I find all uneccesary sugar annoying and I don't like the then/else.
21:06:27 <Jafet> What is decoding what?
21:06:27 * cmccann also added xor and implies because he doesn't care that you can use /= and some comparison, that's stupid
21:07:23 * monochrom prefers to use /= and <=
21:07:50 <monochrom> did you know that == for Bool is associative? :)
21:08:01 <Jafet> tikhonjelvis: [t,f]!!fromEnum b
21:08:07 <cmccann> meh, /= is tolerable but <= is just obfuscation
21:08:37 <tikhonjelvis> I actually like the proposal for a ? operator.
21:09:42 <Jafet> Use Agda then, you can define infix conditional operators
21:09:43 <monochrom> I disagree. + and * for "or" and "and" are the obfuscation. not even the right analogy a*(a+b) = a take that!
21:10:00 <tikhonjelvis> You can define ? in Haskell too, can't you?
21:10:10 <Jafet> What is ??
21:10:24 <tikhonjelvis> Erm, like the ternary operator in other languages.
21:10:25 <shergill> if?
21:10:25 <Jafet> (The C one, or the INTERCAL one?)
21:10:25 <elliott> cmccann: xor clashes with Data.Bits
21:10:26 <monochrom> max and min are the right analogy. a `min` (a `max` b) = a. once you realize that, <= is the logical next step
21:10:33 <shergill> ?:
21:10:33 <lambdabot> Maybe you meant: . ? @ v
21:10:41 <quintessence> I prefer the (if then ... else ...) and (case of ...) proposals
21:10:45 <Jafet> (?), like most other Haskell operators, are binary
21:10:49 <tikhonjelvis> Well, cond ? consequent $ alternate
21:10:52 <elliott> does anyone really use material implication on booleans?
21:11:09 <cmccann> it's the principle of the matter
21:11:15 <monochrom> I do
21:11:30 <tikhonjelvis> That said, porting some features from INTERCAL into Haskell could be a fun project.
21:11:51 <elliott> COME FROM should be easy enough
21:11:51 <Jafet> tikhonjelvis: doing that reduces the supply of $
21:11:51 <elliott> well, hmm, no
21:11:51 <elliott> you need static information
21:11:57 <Jafet> Which is something you don't want to do in these days
21:11:58 <elliott> so you'd need an arrow
21:12:00 <monochrom> my http://www.cs.toronto.edu/~trebla/transfinite.txt uses material implication
21:14:05 <cmccann> elliott, I use booleans a lot more often than Data.Bits, so meh
21:14:13 <Jafet> Another suggestion is to make `otherwise' syntax: (t otherwise f) b === flip id b $ t otherwise f, then you reclaim three short keywords
21:14:26 <ion> COME FROM is deterministic?
21:14:42 <Jafet> ion: with a sufficiently powerful type system.
21:14:44 <monochrom> @bots
21:14:45 <lambdabot> :)
21:14:48 <elliott> ion: yes, unless you have multiple COME FROMs, which intercal extensions use for threading
21:14:55 <elliott> (from the same line)
21:14:58 <cmccann> which makes sense really
21:15:00 <ion> heh
21:15:02 <cmccann> I mean, what else would it do
21:15:05 <elliott> even more fun with computed come froms
21:15:37 <Jafet> It might be possible to implement those with the reverse state monad
21:15:39 <elliott> fun fact: you can implement full continuations, as a language extension, in C-INTERCAL in about two pages of (nonportable) INTERCAL code
21:15:54 <cmccann> haha
21:15:55 <elliott> (the maintainer did it in less than a day on a dare I made :P)
21:16:07 <tikhonjelvis> nice
21:16:07 <elliott> (I... wasn't expecting it to actually happen)
21:16:07 <shergill> heh
21:16:22 <ion> :-)
21:16:27 * cmccann considers the merits of a call-with-previous-continuation function
21:16:44 <hpaste> forticulous pasted “Rat In Maze” at http://hpaste.org/63439
21:16:51 <elliott> cmccann: (lambda (f) (f (call/cc id))?
21:16:54 <elliott> )
21:16:55 <ion> call-with-random-continuation
21:16:57 <Jafet> call-with-subsequent-continuation
21:16:58 * hackagebot osm-download 0.3 - Download Open Street Map tiles  http://hackage.haskell.org/package/osm-download-0.3 (ThomasDuBuisson)
21:17:14 <cmccann> Jafet, yeah, I think having both makes sense
21:17:37 <Jafet> (Can you implement one with the other?)
21:17:45 <JoeyA> call-with-implicit-continuation
21:18:31 <shergill> cmccann: what're you calling the package? back-to-the-future?
21:18:56 <cmccann> to-be-continued
21:19:00 <shergill> heh
21:19:06 <shergill> touche
21:19:28 <cmccann> true fact, having a cute name makes it 4.7x more likely that I'll actually write something
21:19:30 <edwardk> cmccann: ahhaha
21:19:54 <cmccann> ...why do my ridiculous naming schemes always summon edwardk? :P
21:19:57 <shergill> hah
21:20:02 <cmccann> this is like the third time :D
21:20:15 <edwardk> =)
21:20:27 <cmccann> edwardk, did you see the subtypes package I put on github? :D
21:20:37 <edwardk> nope
21:20:37 <edwardk> whats it do?
21:20:48 <cmccann> exposes the subtyping relation that exists in haskell, of course
21:20:55 <cmccann> the only module is Acme.Subtype
21:20:59 <cmccann> if that gives you any idea :P
21:20:59 <edwardk> as in constraints?
21:21:01 <edwardk> hahah
21:21:04 <cmccann> no
21:21:05 <shergill> heh
21:21:06 <edwardk> okay =)
21:21:09 <cmccann> it defines Top and Bottom types
21:21:21 <cmccann> https://github.com/isomorphism/subtypes
21:21:45 <cmccann> my favorite part is that it lets me export getTop like that
21:21:51 <elliott> <cmccann> true fact, having a cute name makes it 4.7x more likely that I'll actually write something
21:21:53 <edwardk> hah
21:21:55 <elliott> "The most important thing in the programming language is the name. A language will not succeed without a good name. I have recently invented a very good name and now I am looking for a suitable language." --Knuth
21:21:58 * hackagebot gps 1.0.2 - For manipulating GPS coordinates and trails.  http://hackage.haskell.org/package/gps-1.0.2 (ThomasDuBuisson)
21:22:00 <ion> like a rock :-D
21:22:13 <otters> :t (:[])
21:22:14 <lambdabot> forall a. a -> [a]
21:22:25 <cmccann> cf. http://hpaste.org/63436
21:22:53 <edwardk> the strict :<: is less interesting than :<=: ;)
21:22:59 <elliott> cmccann: I bet you can use it as a record setter
21:23:03 <edwardk> then you can have a :<= a
21:23:03 <cmccann> and note that the haddocks display getTop as if it were a normal function
21:23:03 <elliott> cmccann: try undefined{getTop=undefined}
21:23:30 <cmccann> huh
21:23:35 <cmccann> never seen that error before
21:23:37 <cmccann> "Record update for insufficiently polymorphic field"
21:23:41 <cmccann> nice
21:24:04 <elliott> hah
21:24:23 <cmccann> edwardk, but then I'd need overlapping instances :[
21:24:38 <edwardk> or just to make it a data type
21:25:55 <elliott> edwardk: but that means it's not implicit!
21:26:06 <elliott> things being implicit is good, just like subtyping.
21:26:13 <elliott> and anything that inserts function calls that I didn't write
21:26:13 <edwardk> hah
21:26:32 <edwardk> found a bunch of utf8 hyphenation files, going to re-release hyphenation
21:26:39 <cmccann> elliott, did you see the link I put there to explain subtyping variance to Haskell programmers
21:27:05 <edwardk> now with like 67 languages
21:27:20 <edwardk> rather than english french and icelandic with a bad french hyphenation file i kinda half munged
21:27:25 <cmccann> heh
21:28:02 <edwardk> only problem is with that many i kinda need to actually make an ADT for the locales ;)
21:28:59 <tkahn6_> do you all think it would be useful to augment Data.Map with something like :: (a -> b) -> [a] -> Map a b
21:29:07 <elliott> cmccann: yes, it's a good introduction!
21:29:14 <tkahn6_> i find myself needing that frequently
21:29:23 <elliott> cmccann: I'm glad you didn't link to one of those crappy "variance tutorials"
21:29:32 <edwardk> tkahn6_: you can get there with of course just fromList and a painful map
21:29:33 <cmccann> elliott, yeah, it seemed easier than explaining OOP
21:29:34 <elliott> written by stupid FPers only a week into learning Java
21:30:02 <tkahn6_> edwardk: right it's not hard to implement, just a pain to do it
21:30:05 <tkahn6_> each time
21:30:06 <elliott> "Variance is just like the left hand side vs. the right hand side of an arrow!"
21:30:07 <edwardk> a more general version might be fromListWith
21:30:15 <elliott> no, you idiot, what about the left hand side of the left hand side?!
21:30:16 <edwardk> with a function (a -> (k,v))
21:30:25 <edwardk> but thats where the bikeshedding starts
21:30:26 <elliott> they should really just read Learn You a Java :)
21:30:28 <edwardk> and nothing happens
21:30:29 <edwardk>  ;)
21:30:46 <elliott> @hoogle fromListWith
21:30:46 <lambdabot> Data.IntMap fromListWith :: (a -> a -> a) -> [(Key, a)] -> IntMap a
21:30:47 <lambdabot> Data.Map fromListWith :: Ord k => (a -> a -> a) -> [(k, a)] -> Map k a
21:30:47 <lambdabot> Data.IntMap fromListWithKey :: (Key -> a -> a -> a) -> [(Key, a)] -> IntMap a
21:30:54 <cmccann> elliott, I think all the analogy-based design pattern tutorials scare them off
21:31:04 <elliott> cmccann: hahahaha
21:31:09 <elliott> "a visitor is just like a visitor"
21:31:13 <cmccann> :D
21:31:20 <tikhonjelvis> Also the big scary words like "polymorphism".
21:31:59 * hackagebot JuicyPixels-repa 0.1 - Convenience functions to obtain array representations of images.  http://hackage.haskell.org/package/JuicyPixels-repa-0.1 (ThomasDuBuisson)
21:32:00 <elliott> hmm... so is "class" like haskell typeclass?
21:32:03 <elliott> ad-hoc polymorphism?
21:32:09 <elliott> "no.. no... that's interface"
21:32:37 <elliott> oh, this generics stuff is polymorphism! so can I apply parametricity?
21:32:41 <elliott> "er, well..."
21:33:56 <tkahn6_> edwardk: i'm not seeing how to get what i'm talking about from fromListWith
21:34:01 <tkahn6_> edwardk: example?
21:34:23 <cmccann> you see here: t - a cursed wand of subtype polymorphism (1:2)
21:34:52 <edwardk> well a common idiom would be something like fromListWith (\k -> (k,f k)) xs
21:35:09 <edwardk> i often have a list i'm making a Map out of, but only have the keys or the values in the list and need to derive the other
21:35:14 <elliott> the deeper insight behind all these silly jokes is that most OOP programmers never learn the rich theory behind it
21:35:24 <edwardk> fromListWith (\v -> (key v, v)) xs
21:35:27 <tkahn6_> edwardk: right i was thinking about calling it something like fromListBy
21:35:28 <elliott> but the Haskell community doesn't hide the theory from the users
21:35:28 <cmccann> elliott, yes
21:35:32 <elliott> so it's a big culture shock
21:35:51 <edwardk> the 'With' idiom is pretty heavily used for 'and apply this function' in the Map and Set modules
21:35:54 * cmccann never really understood the variance stuff until learning Haskell, amusingly
21:36:01 <elliott> and it's a good thing; how many OOP programmers violate the Liskov substitution principle on a daily basis?
21:36:09 <edwardk> i learned variance when Eiffel got it horribly messily wrong
21:36:10 <elliott> that's because they don't know it, or don't understand why it matters, etc
21:36:13 <elliott> .
21:36:15 <cmccann> edwardk, hahaha
21:37:30 * cmccann considers writing a roguelike in haskell just for the sake of adding a wand of polymorphism
21:37:39 <Mike____> i think im starting to understand haskell, i've actually done one or two functions without any erros :D
21:37:43 <ion> edwardk: The same hyphenation stuff LaTeX uses?
21:38:07 <SubtleArray> Congrats, Mike. :D
21:38:09 <elliott> edwardk: what, String only?
21:38:11 <tikhonjelvis> Mike____: It's progress.
21:38:16 <Mike____> yeah
21:38:19 <edwardk> ion: yes
21:38:24 <ion> cool
21:38:28 <Mike____> i think imma be able to do the rubiks cube this weekend :D
21:38:30 <Mike____> so coool
21:38:30 <elliott> looks cool though
21:38:32 <edwardk> ion: i just got it working with all of the hyph-utf8 project files
21:38:48 <edwardk> which means it can hyphenate lots of languages i don't care about
21:38:55 <edwardk> i just wanted it for nicer diagnostic messages from trifecta ;)
21:38:58 <ion> :-)
21:39:03 <edwardk> that way i can hyphenate the english text in the pretty printer
21:39:12 <edwardk> =)
21:39:20 <elliott> now port TeX's justification engine using it :P
21:39:28 <edwardk> hah
21:39:31 <elliott> ...and write a man page formatter that uses it!
21:39:37 <elliott> hey, there's a port to JS, anything's possible :P
21:39:41 <ion> Next up: the LaTeX justification algorithm :-P
21:39:44 <edwardk> i _did_ think about porting the paragraph formatter
21:39:50 <ion> Whoops, missed elliott’s line.
21:40:09 <edwardk> it could make for an interesting pretty printer
21:40:16 <edwardk> but its serious overkill for doing command line stuff ;)
21:40:56 <edwardk> ghci> unwords $ map (intercalate "-" . hyphenate english_US) $ words "and it's a good thing; how many OOP programmers violate the Liskov substitution principle on a daily basis"
21:40:56 <edwardk> "and it's a good thing; how many OOP pro-gram-mers vi-o-late the Liskov sub-sti-tu-tion prin-ciple on a daily basis"
21:41:40 <elliott> you have to spell things out very carefully for the OOP pro-gram-mers
21:41:48 <edwardk> =)
21:41:51 <elliott> they don't un-der-stand you if you speak too fast
21:41:59 * hackagebot osm-download 0.3.1 - Download Open Street Map tiles  http://hackage.haskell.org/package/osm-download-0.3.1 (ThomasDuBuisson)
21:42:02 <cmccann> crap, that reminds me, I was going to start writing haddocks in poetic meter
21:42:08 <cmccann> bother.
21:42:08 <elliott> hahahhahahahaha
21:42:11 <SubtleArray> XD
21:42:21 <edwardk> "let me ex-plain this very care-fully. I will try not to use big words"
21:42:39 <edwardk> reminds me of that guy steele talk
21:42:52 <cmccann> was halfway through rewriting some of diagrams' docs in meter to prove a point to byorgey, too
21:42:55 <cmccann> really ought to finish that
21:42:55 <edwardk> http://video.google.com/videoplay?docid=-8860158196198824415
21:42:58 <tikhonjelvis> edwardk: Heh, I was about to say the same thing :)
21:43:02 <tikhonjelvis> I loved that talk.
21:43:02 <ion> crap, that reminds me / I was going to start writing / haddock poetry
21:43:11 <edwardk> its one of the best CS talks of all time
21:43:24 <cmccann> ion, pf, haiku are overdone
21:43:25 <tikhonjelvis> It's brilliant *and* I agree wholeheartedly.
21:44:19 <elliott> why am I still awake?! oh yeah, #haskell
21:44:31 <tikhonjelvis> Pfft, sleep is for the weak. Also: Friday.
21:44:33 <cmccann> maybe I'll poetrify the docs for these, too
21:44:43 <tikhonjelvis> Well, if you're in a different timezone, maybe Saturday.
21:44:47 <Jafet> Incorporate your type variables into limericks
21:46:53 <ion> You’re documentation should of common grammer errors to annoy people.
21:47:09 <cmccann> ion, that would annoy ME
21:47:40 <cmccann> though speaking of making documentation ridiculous
21:47:47 <ion> Even greater success
21:47:55 <cmccann> one of these days I need to write a QQ'er to parse ASCII art commutative diagrams
21:48:04 <cmccann> for expressing all these category theory-based laws
21:48:21 <ion> Unicode art!
21:48:30 <cmccann> yeah, true
21:48:34 <cmccann> might as well
21:49:32 <tkahn6_> what is this talk about
21:49:39 <tkahn6_> this is the most epic buildup eve
21:49:40 <tkahn6_> r
21:49:40 <Jafet> Along the lines of http://weegen.home.xs4all.nl/eelis/analogliterals.xhtml
21:49:44 <cmccann> tkahn6_, egregious nonsense
21:49:53 <cmccann> oh
21:49:56 <cmccann> the thing you're watching
21:50:00 <tkahn6_> guy steele's thing
21:50:02 <cmccann> I thought you mean the talk in channel
21:50:08 <tkahn6_> heh n
21:50:09 <tkahn6_> o
21:50:10 <cmccann> nevermind
21:50:15 <tkahn6_> it's always nonsense :p
21:50:18 <cmccann> yes
21:50:22 <cmccann> ignore it, watch steele
21:50:38 <tikhonjelvis> tkahn6_: Heh, once he explains it, you realize the talk is actually brilliant.
21:51:05 <ion> > co "nonsense"
21:51:07 <lambdabot>   "cononsense"
21:51:18 <tikhonjelvis> :t co
21:51:19 <lambdabot> [Char] -> [Char]
21:51:22 <tikhonjelvis> ...
21:52:10 <tkahn6_> lol
21:53:58 <Jafet> @check (==) <$> co <*> ("co"++)
21:54:00 <lambdabot>   "OK, passed 500 tests."
21:54:14 <cmccann> that sounds couseful
21:54:23 <cmccann> anyway time to sleep
21:54:25 <ion> > co "couseful"
21:54:27 <lambdabot>   "useful"
21:54:51 <tikhonjelvis> > co $ co "nuts"
21:54:53 <lambdabot>   "nuts"
21:55:02 <tikhonjelvis> ...?
21:55:50 <tikhonjelvis> lambdabot's mind confuses me
21:56:46 <SubtleArray> Is lambdabot orga or mecha?
21:57:22 <Jafet> Yes.
21:57:49 <SubtleArray> Reference from AI: Artificial Intelligence. Most underrated sci-fi movie ever.
21:58:48 <Jafet> Indeed, it's the most underrated 2001 Spielberg sci-fi movie ever
21:59:06 <tkahn6_> > co "pumpkin"
21:59:08 <lambdabot>   "copumpkin"
21:59:14 <tkahn6_> > co "pump"
21:59:15 <tikhonjelvis> ...
21:59:16 <lambdabot>   "copump"
21:59:21 <tikhonjelvis> > co $ co "nuts"
21:59:23 <lambdabot>   "nuts"
21:59:26 <Jafet> @define
21:59:33 <tkahn6_> > co $ co "pumpkin"
21:59:34 <lambdabot>   Not in scope: `co'Not in scope: `co'
21:59:37 <rekado> Hi, is it normal that GHC 7.4.1 produces much bigger binaries than 7.0.3?
21:59:46 <tkahn6_> wat
22:02:05 <Axman6> @check co . co == id
22:02:06 <lambdabot>   Not in scope: `co'Not in scope: `co'
22:02:09 <Axman6> :(
22:02:58 <tikhonjelvis> @let co = ("co" ++)
22:02:59 <lambdabot>  Defined.
22:03:04 <tikhonjelvis> > co $ co "nuts"
22:03:05 <lambdabot>   "coconuts"
22:03:09 <tikhonjelvis> finally
22:04:00 <tikhonjelvis> @src co
22:04:00 <lambdabot> Source not found. And you call yourself a Rocket Scientist!
22:04:11 <tikhonjelvis> Aw, I guess that's not how @src works.
22:04:45 <rekado> Compiled a WAI application with GHC 7.0.3 (through cabal) ---> 2.2MB
22:04:57 <rekado> Same application with GHC 7.4.1 ---> 4MB
22:05:29 <rekado> Are there new flags that must be set to shave of these additional MBs?
22:05:33 <rekado> The binaries are both stipped.
22:05:33 <ion> Oh no. 500000 of them and you’d need a larger hard disk.
22:05:58 <rekado> ion: I will run this on a router, so size is important.
22:06:37 <ion> Try -fllvm and there’s probably some way to tell llvm to optimize for size.
22:06:51 <rekado> ion: Thanks, I
22:06:53 <rekado> I'll try
22:06:59 * hackagebot warp-dynamic 0.0.1 - Dynamic configurable warp HTTP server  http://hackage.haskell.org/package/warp-dynamic-0.0.1 (HideyukiTanaka)
22:07:12 <ion> (I’m just pulling ideas out of my ass. It might or might not change anything.)
22:07:46 <rekado> that's alright. I'll have to go through llvm anyway to get a binary for ARM.
22:07:47 <ion> If there are multiple Haskell binaries on the system, dynamic linking would be useful.
22:08:18 <rekado> ion: that's unlikely to be the case.
22:11:59 * hackagebot warp-dynamic 0.1.0 - Dynamic configurable warp HTTP server  http://hackage.haskell.org/package/warp-dynamic-0.1.0 (HideyukiTanaka)
22:15:31 <glguy> It is amazing how much processing power todays smart phones possess
22:15:54 <glguy> I can't wait to you're check agda on one
22:15:54 <Jafet> Does that make them smart?
22:16:07 <glguy> Type*
22:18:33 <Enigmagic> rekado: http://upx.sourceforge.net/
22:19:38 <Enigmagic> rekado: not sure if it works for ghc compiled apps but it's worth a shot
22:21:44 <zzo38> I have:   class ExtTree v p c | c -> p, p -> v;   But how do I make it so that it requires that the "p" in one instance must always be the "c" of another instance, but with the same "v" as this instance? So that the tree for each "v" must have a root?
22:21:55 <zzo38> It won't accept cyclic superclasses.
22:23:15 <zzo38> So, how can it be done?
22:24:58 <Enigmagic> what are you trying to accomplish?
22:26:14 <zzo38> Actually it seems even if I do that, there will always be a loop; if p was of kind (Maybe *) then it might be done, and even then there has to be the way to avoid loops.
22:26:57 <zzo38> But I do not have the DataKinds extension and am not even sure if it can do that.
22:27:19 <glguy> Maybe paste an example of what you were trying to do
22:27:51 <zzo38> (The class does have methods, however; I have not mentioned them)
22:27:53 <MaskRay> seeking a list with O(1) length
22:27:59 <MaskRay> seeking a list library with O(1) length
22:28:06 <zzo38> I am trying to make a tree with typeclasses
22:28:34 <zzo38> So that the tree can be extended in other modules and then can be traced
22:30:12 <mauke> (Int, [a])
22:30:44 <ion> (Sum Integer, [a]) -- Now it’s a monoid. ;-)
22:31:16 <mauke> sweet
22:35:13 <zzo38> So, how can it do?
22:35:43 <Jafet> MaskRay: Data.Sequence.Seq
22:40:19 <zzo38> How can I prove this tree has a root? Will type families help?
22:40:29 <MaskRay> Jafet: too slow
22:41:18 <zzo38> MaskRay: It seem to me, arrays would be O(1)?
22:41:21 <MaskRay> Jafet: given up seeking such lib. i'll introduce a variable
22:41:25 <zzo38> So use arrays
22:43:57 <Jafet> data MyAwkwardList a = MyAwkwardList {-# UNPACK #-} !Word ![a]
22:46:49 <quintessence> does a strictness annotation on [a] do anything useful?
22:47:09 <edwardk> quintessence: surrounding it? no
22:48:24 <quintessence> I thought so, but after seeing what Jafet wrote I thought I'd ask
22:48:50 <Jafet> Surely that rules out undefined?
22:49:59 <edwardk> oh, that, i thought he meant in a pattern
22:50:15 <edwardk> it does ensure that the outermost constructor is forced
22:51:09 <Jafet> > let f ~(~(a, b)) = 0 in f undefined
22:51:10 <lambdabot>   0
22:51:15 <Jafet> > let f !(~(a, b)) = 0 in f undefined
22:51:16 <lambdabot>   *Exception: Prelude.undefined
22:51:21 <Jafet> > let f ~(!(a, b)) = 0 in f undefined
22:51:22 <lambdabot>   0
22:51:37 <Jafet> I'm not sure what this means.
22:55:39 <tikhonjelvis> Jafet: My guess is that because of ~ the inner pattern is only ever looked at if it needs to be forced.
22:55:44 <tikhonjelvis> But I know nothing.
23:02:36 <aadrake> I don't claim to have any real understanding of monads, but are there some parallels between monads and the new proxies that are being introduced to JavaScript? http://wiki.ecmascript.org/doku.php?id=harmony:proxies#higher-order_messages
23:03:36 <zzo38> aadrake: Monad are a kind of mathematical structure supporting certain operations and following certain laws. All monads are endofunctors (the Functor class in Haskell; although it is not currently a superclass but it should be).
23:03:43 <mauke> "Higher-order messaging builds upon catch-alls to reify the message as an object." I have no idea what you just said
23:04:55 <aadrake> mauke: I was a bit confused also.  It just seemed that the abstraction goals were similar.
23:05:05 <mauke> "This API is superseded by the newer direct proxies API."
23:05:07 <mauke> hahaha
23:05:54 <aadrake> mauke: I know you can already use functional techniques in JavaScript, but it seems like they're taking the language more in that direction.
23:06:15 <mauke> "The handler is an object that may implement the following API"
23:06:19 <mauke> "may"
23:07:13 --- mode: ChanServ set +o mauke
23:07:14 --- mode: mauke set +b $a:MrDildeaux
23:08:01 <zzo38> What does the $a: mean?
23:08:37 <ion> “Monads may follow these laws”
23:08:37 <glguy> Matches real name field
23:08:55 <glguy> Ion: sounds about right
23:08:57 <zzo38> Their real name field is "Stalkerman"
23:09:25 --- mode: mauke set -o mauke
23:10:54 <zzo38> I did this; will this work?   class ExtTree v p c | c -> p, p -> v where { treeVal :: ExtTree v pp p => c -> v; treeParent :: ExtTree v pp p => c -> p; };
23:10:54 <glguy> Zzo: oops, nickserv account name
23:11:25 <zzo38> glguy: OK
23:12:00 <tikhonjelvis> aadrake: monads really have nothing to do with proxies
23:12:12 <milkpost_> should i trust by the title that 7.4.1 is not ready for primetime yet?
23:12:24 <tikhonjelvis> Unless I'm completely off-base, proxies just let you handle property accesses (e.g. object.method) however you like.
23:12:28 <mauke> aadrake: proxies look like perl's tie/overload
23:12:45 <mauke> aadrake: the "higher-order messages" stuff is just a workaround for javascript's awful function syntax
23:13:05 <tikhonjelvis> mauke: I think it's a glorified way to overload . and [] for objects.
23:13:15 <mauke> yeah
23:13:21 <zzo38> I think the best way to learn monads is to learn category theory a bit. At least, that is what help me to learn it the best way.
23:13:32 <tikhonjelvis> zzo38: If you like math, go for it.
23:14:31 <zzo38> tikhonjelvis: Yes I do like math. Which means sometimes I write Haskell codes on paper, and even much more often than writing other programming codes on paper
23:15:48 <tikhonjelvis> zzo38: Keep in mind that the transition from math to haskell is naturally lossy.
23:16:16 <zzo38> tikhonjelvis: Yes I know.
23:18:57 <glguy> Milkpost: you should use the version of ghc in the Haskell platform if you are unsure
23:20:07 <DanBurton> milkpost came and left rather quickly...
23:20:25 <tikhonjelvis> :t maybe
23:20:26 <lambdabot> forall b a. b -> (a -> b) -> Maybe a -> b
23:20:34 <lpsmith_> :t either
23:20:35 <lambdabot> forall a c b. (a -> c) -> (b -> c) -> Either a b -> c
23:20:47 <lpsmith_> @src Maybe
23:20:47 <lambdabot> data Maybe a = Nothing | Just a
23:21:11 <tikhonjelvis> @src maybe
23:21:12 <lambdabot> maybe n _ Nothing  = n
23:21:12 <lambdabot> maybe _ f (Just x) = f x
23:21:23 <lpsmith> maybe replaces the nothing and just data constructors.
23:21:28 <lpsmith> Just like either
23:21:50 <tikhonjelvis> I know what it does :) I'm just obscenely lazy sometimes and try to avoid thinking at all costs.
23:22:14 <zzo38> I like maybe and either functions; in many of my programs I also add a bool function, since I dislike the built-in if command.
23:22:35 <lpsmith> I prefer the defintion    maybe nothing _ Nothing = nothing;  maybe _ just (Just x) = just x
23:22:48 <tikhonjelvis> Heh, I was just complaining about the if syntax a little while ago as well :)
23:23:35 <tikhonjelvis> I was thinking of using a ? operator for it, like so: condition ? consequent $ alternate
23:23:43 <zzo38> tikhonjelvis: I didn't know that. Maybe you like my bool function too?  bool :: x -> x -> Bool -> x;  Half the time I use it, the x tends to be a function
23:23:47 <tikhonjelvis> I saw it on the wiki and thought it was a good idea, but haven't bothered with it.
23:24:04 <zzo38> And you could make a infix version of bool if you want to.
23:25:03 <tikhonjelvis> >@let True ? consequent = const; False ? _ = const id
23:25:06 <tikhonjelvis> @let True ? consequent = const; False ? _ = const id
23:25:07 <lambdabot>  Defined.
23:25:14 <tikhonjelvis> > True ? 10 $ 11
23:25:16 <lambdabot>   Overlapping instances for GHC.Show.Show (a -> a)
23:25:16 <lambdabot>    arising from a use of `...
23:25:32 <tikhonjelvis> @let True ? consequent = const consequent; False ? _ = const id
23:25:33 <lambdabot>  <local>:2:0:
23:25:34 <lambdabot>      Warning: Pattern match(es) are overlapped
23:25:34 <lambdabot>               In...
23:25:39 <zzo38> tikhonjelvis: Mine is not like that; in mine the condition is the third parameter, which makes more sense to me
23:25:51 <tikhonjelvis> Eh, I'll just give up on lambdabot for now.
23:25:56 <mauke> @undefine
23:26:10 <MostAwesomeDude> > if True then 10 else 11
23:26:11 <lambdabot>   10
23:26:15 <tikhonjelvis> Does @undefine just remove the last definition?
23:26:20 <mauke> :t [const id, flip const]
23:26:21 <lambdabot> forall b a. [a -> b -> b]
23:27:58 <tikhonjelvis> Aha
23:28:07 <tikhonjelvis> @let True ? a = const a; False ? _ = id
23:28:08 <lambdabot>  Defined.
23:28:13 <tikhonjelvis> True ? 1 $ 2
23:28:16 <tikhonjelvis> > True ? 1 $ 2
23:28:18 <lambdabot>   1
23:28:24 <tikhonjelvis> > False ? 1 $ 2
23:28:26 <lambdabot>   2
23:28:30 <tikhonjelvis> There we are.
23:29:10 <zzo38> OK, that works. Still, I prefer the boolean being the third parameter rather than the first. Many people prefer it to be the first, but I prefer the third
23:29:55 <tikhonjelvis> I've always liked the ?: operator in other languages.
23:30:28 <zzo38> tikhonjelvis: I do too. I use it in C programming and other stuff too
23:30:46 <tikhonjelvis> I don't like Python's a if cond else b. But that's just me.
23:31:06 <mauke> don't you like middle-endian evaluation orders?
23:31:11 <zzo38> tikhonjelvis: Actually I agree with you about that too
23:31:41 <tikhonjelvis> It's like the way Americans write dates. I keep on wanting to write them the logical way...
23:32:08 <zzo38> I prefer Year/Month/Day order for dates
23:33:01 <tikhonjelvis> Eh, either that or Day/Month/Year make more sense than Month/Day/Year.
23:33:28 <zzo38> That will do but I still think Year/Month/Day is better
23:33:30 <tikhonjelvis> I can see where they're coming from--February the 11th, 2012--but it's still annoying.
23:34:20 <zzo38> In some cases they even add AD (or CE) with the year
23:34:55 <rsimoes2> is there variable name convention for using l:ls instead of x:xs? is the former a list of lists?
23:35:29 <zzo38> rsimoes2: I don't know. I usually use (h : t)
23:37:37 <zzo38> Do you know how to implement some features of other programming languages to make them usable in Haskell? Such as, Prolog, Lisp, TADS2, Inform 7, and INTERCAL.
23:37:52 <tikhonjelvis`> That would vary a lot depending on which feature you mean.
23:38:51 <tikhonjelvis`> Embedding a prolog in Haskell would be neat.
23:40:43 <Jafet> (How many Prolog programmers are needed to change a lightbulb?)
23:41:31 <zzo38> From Prolog: Dynamic procedures, public (inspectable) procedures, and multifile procedures. From Lisp: Lisp-style macros. From TADS2: Object class inheritance. From Inform 7: Rulebooks. From INTERCAL: Slavery, classes/lectures, and first-class backtracking (in a hypothetical variant known as CLCLC-INTERCAL)
23:41:56 <tikhonjelvis> zzo38: We already have macros in the form of Template Haskell.
23:42:12 <quintessence> (Jafet: Yes)
23:42:15 <tikhonjelvis> Objects don't really have any place here.
23:42:26 <Jafet> (quintessence: No!)
23:43:36 <zzo38> I did write a macro preprocessor for Haskell; in next version I plan to add pool strings and wildcard includes.
23:44:35 <zzo38> And it has something like C-style macros; and using this program does not prevent you from also using Template Haskell.
23:45:07 <Ralith> tikhonjelvis: not really lisp-style, are they?
23:45:25 <tikhonjelvis> Ralith: maybe you just need to squint a little :)
23:45:32 <Ralith> I tried that.
23:45:40 <zzo38> Squint a little? How would that help?
23:45:50 <tikhonjelvis> metaphorically squint
23:46:29 <Ralith> let your eyelids stand in for the parenthesis.
23:46:54 <wavewave> did anyone make MonadPlus for enumerator package?
23:46:59 * hackagebot hyphenation 0.2 - Configurable Knuth-Liang hyphenation  http://hackage.haskell.org/package/hyphenation-0.2 (EdwardKmett)
23:47:16 <MostAwesomeDude> Jafet: I give; how many Prolog programmers *does* it take to change a lightbulb?
23:47:24 <edwardk> MostAwesomeDude: no
23:47:42 <Jafet> Yes.
23:47:55 <MostAwesomeDude> a
23:48:26 <MostAwesomeDude> Sorry, force of habit. Good joke though. :3
23:48:52 <zzo38> I made up a package (not yet complete) which can make extensible products (fields can be added in different modules), extensible sums (constructors can be added in different modules), extensible lists (list items can be added in different modules), and now extensible trees. Any other ideas?
23:49:21 <Jafet> edwardk is really going to rename it to kesselrun any time now
23:49:34 <edwardk> jafet: heh
23:49:42 <zzo38> Jafet: Rename what?
23:49:52 <edwardk> i have yet to cross 12 parsecs =)
23:49:58 <Jafet> @hackage trifecta
23:49:58 <lambdabot> http://hackage.haskell.org/package/trifecta
23:50:01 <edwardk> its more like 3.5
23:50:22 <edwardk> i wrote the hyphenation package just for better error message printing ;)
23:50:58 <edwardk> the fact that it handles hyphenating icelandic is a rather odd benefit
23:51:35 <zzo38> Can this hyphenation program be used with dvi-processing? I wrote dvi-processing package but is not yet complete due to not assigning registers. Do you know a way to do this in Haskell?
23:51:49 <dmwit> zzo38: How about arbitrary fixed-points? Then you wouldn't need to write lists and trees yourself.
23:51:59 * hackagebot hyphenation 0.2.0.1 - Configurable Knuth-Liang hyphenation  http://hackage.haskell.org/package/hyphenation-0.2.0.1 (EdwardKmett)
23:52:06 <edwardk> zzo38: all it does is take a word and give you a reasonable set of points you could break it at for a given language
23:52:19 <Ralith> ooo, clang-style hilighting!
23:52:28 <edwardk> ghci> hyphenate french "anticonstitutionnellement"    ==> ["an","ti","cons","ti","tu","tion","nel","le","ment"]
23:53:08 <edwardk> ralith: you can use it to put the ~~~'s underneath and everything
23:53:10 <zzo38> edwardk: TeX implements hyphenation with customizable tables; I read about it in Computers & Typesetting volume B explains how it works
23:53:20 <edwardk> zzo38: yes, so do i
23:53:21 <Ralith> man
23:53:22 <edwardk> same tables =P
23:53:32 <Ralith> all this is making me want to move my compiler experiments into haskell
23:54:01 <Ralith> zzo38: you might have recognized the name of the algorithm in the update message.
23:54:03 <edwardk> The Liang i mention in the description of the project was Knuth's phd student
23:54:05 <edwardk> =)
23:54:16 <zzo38> Ralith: Yes I did
23:54:40 <edwardk> the project comes with a few tables
23:54:59 <zzo38> I use Plain TeX for anything I need to typeset; I have even made many macro packages, including one for chess (which is more versatile than existing ones), one for binary specials, one for calculating date of Easter, and so on. I use METAFONT to design typefaces and logos.
23:55:05 <edwardk> https://github.com/ekmett/hyphenation/tree/master/data
23:55:23 <zzo38> I think METAFONT is really the best program to design typefaces and logos.
23:55:42 <zzo38> dmwit: What is arbitrary fixed-points and how do you not write lists and trees yourself using this?
23:56:13 <edwardk> zzo38: data Mu f = In { out :: f (Mu f) }
23:56:35 <edwardk> then tie the knot through that
23:57:11 <edwardk> data ListF a b = Cons a b | Nil    -- type List a = Mu (ListF a)
23:57:29 <edwardk> its a huge pain in the neck
23:57:35 <zzo38> edwardk: I have seen something like that, but that doesn't seem to do what I am trying to do, at all
23:57:47 <srhb> I just made a simple Hello World app with wxWidgets, but the resulting frame is complete unrespnsive. All I can do is close it again. Does anyone know what might be causing it? I'm on OS X
23:58:12 <edwardk> the recursion-schemes package is designed to try to let folks use normal data types, just by supplying an extra base functor
23:58:22 <edwardk> so you can use it with normal [a], etc.
23:59:16 <zzo38> edwardk: That still looks nothing like my extensible-data package (not yet complete)
23:59:43 <edwardk> i have no idea at all about your extensible data package one way or another you simply asked about fixed points =P
