00:00:27 <srhb> The answer is "run macosx-app on the resulting binary" - and no one knows why. But it works. Shiny.
00:00:43 <zzo38> Yes but I asked someone else, not you. You should at least look at the message I was replying to
00:00:51 <zzo38> And what they were replying to my other message
00:01:12 <edwardk> good night
00:02:47 <lukish> I've asked yesterday about package for draw some images and get advice about repa-devil. I have some troubles with installing it, so are there some analogues?
00:03:11 <tikhonjelvis> What sorts of troubles, exactly?"
00:03:20 <arcatan> is there a way to install cabal-install with a fresh installation of GHC 7.4 on OS X?
00:03:55 <zzo38> Here is the current codes of extensible-data:    http://sprunge.us/OdLB
00:05:55 <lukish> tikhonjelvis: http://pastebin.com/raw.php?i=m56ViHh5
00:05:57 <mauke> The paste m56ViHh5 has been copied to http://hpaste.org/63440
00:06:25 <lukish> I'm using ghc-7.0.4
00:06:32 <zzo38> Can you figure out what to do from this codes I posted?
00:07:01 <lukish> And I don't want to update it to 7.2.2, because it currently masked in portage
00:07:14 <tikhonjelvis> lukish: Oh, I had a similar problem. I can't remember exactly how I solved it, but I think I just installed a previous version of repa-devil.
00:07:46 <lukish> tikhonjelvis: but how can I do that?
00:07:59 <mauke>   (\f e -> n (\a e' -> eo (f a) (e <> e')) ee (\a e' -> co (f a) (e <> e')) ce) ee
00:08:07 <tikhonjelvis> You can specify which version you want to install in the cabal install command.
00:08:09 <mauke> cool documentation
00:08:29 <lukish> mauke: where is it from?
00:08:32 <arcatan> maybe I should just downgrade to Haskell platform or something :|
00:08:38 <mauke> http://hackage.haskell.org/packages/archive/trifecta/0.49.1/doc/html/Text-Trifecta-Parser-Prim.html
00:09:21 <srhb> arcatan: Yeah, why not. :)
00:10:03 <srhb> arcatan: Except for the linker warnings you'll probably be fine with the platform
00:13:26 <arcatan> srhb: can't use the cool new stuff in 7.2, 7.4
00:13:41 <arcatan> though I guess I don't need them right now
00:16:28 <zzo38> Some people have asked how an extensible product type can possibly have any values. Well, how it is done, you can specify a default value for each field, and this default can depend on a value of another type which is used to index this specific extensible product rather than a different one.
00:17:36 <zzo38> Do you understand this now?
00:19:19 <lukish> tikhonjelvis: http://hpaste.org/63440 what should I do with that?
00:19:25 <lukish> The second one
00:21:20 <tikhonjelvis> Install the system package (not via cabal) that contains the devIl library. For me (on Fedora) it was called something like DevIL.
00:21:53 <tikhonjelvis> Actually, you'd want the development version. So something like DevIL-devel.
00:22:18 <tikhonjelvis> So I'd run sudo yum install DevIL-devel. But I don't know what system you're on, so I can't give a more specific command.
00:22:49 <lukish> media-libs/devil-1.7.8 looks right
00:23:00 <tikhonjelvis> Make sure you get the development version.
00:23:13 <lukish> Works now. Thanks
00:23:16 <tikhonjelvis> okay
00:24:43 <Plembo> Does anyone have any tips on how to attack a problem like this in Haskell?  http://pastie.org/pastes/3359299/text -- I have a very faint idea of how I should attack the problem, but I'm hitting a brick wall here
00:26:19 <tikhonjelvis> hmm
00:26:26 <tikhonjelvis> Do you care much about efficiency?
00:27:18 <tikhonjelvis> Actually, answer this instead: are you familiar with the idea of nondeterministic programming?
00:27:32 <Rc43> Hi, guys.
00:27:56 <Rc43> Anybody knows opensource project to join in?
00:28:45 <srhb> Rc43: Fix something that you find is lacking in some software that you're using, contribute the fix as a patch...?
00:29:00 <srhb> I think that's how it usually works.
00:29:36 <Plembo> tikhonjelvis, efficiency isn't really important
00:29:53 <tikhonjelvis> okay
00:30:00 <Plembo> tikhonjelvis, I know a bit about nondeterministic programming. But only the basic theory about it, never seen it used in code.
00:30:03 <Rc43> srnb, now I don't use anything haskell-written except ghc and cabal.
00:30:28 <tikhonjelvis> Plembo: right. Well, in Haskell, lists let you do nondeterministic programming.
00:31:22 <zzo38> Rc43: All of my projects are open source. But there aren't necessarily any of them meaningful to you.
00:31:28 <srhb> Rc43: So you want it to be a haskell project? Start looking around hackage for something that you'd like to contribute to. I'd say this is much easier once you find "hmm, I really wish foo would do bar" instead of searching for a project -and- something to do at the same time.
00:32:16 <Plembo> tikhonjelvis, I've only been using Haskell for a little over 48 hours now. The fact that lists are non-deterministic makes sense on its own, but how do I use that to my benefit in this problem?
00:32:26 <lukish> Can't find Data.Array.Repa.ByteString here http://hackage.haskell.org/package/repa
00:32:30 <zzo38> srhb: I think you are correct
00:32:32 <tikhonjelvis> Plembo: oh
00:32:59 <tikhonjelvis> Well, my high-level idea--I haven't really fleshed it out completely--is to basically build up a list of all possible paths and then choose the best one.
00:33:37 <Plembo> tikhonjelvis, so basically calculate out every possible path, and then once you're done just figure out which has the highest sum and return it?
00:33:47 <lukish> But on repa-devil tutorial page there is import qualified Data.Array.Repa.ByteString as R
00:34:13 <tikhonjelvis> Plembo: Something like that. I think you could make the code really elegant by using list's monad instance, but you probably haven't gotten there yet.
00:34:22 <srhb> Rc43: Start using Haskell for "Something (TM)" eventually you will find you want feature X. Most of the times you'll find that this feature is already in some module, but you might just stumble upon a feature that isn't there. Implement it, upload it, be a happy Open Source camper. :)
00:34:45 <Plembo> I've read the term monad somewhere, but I don't have the foggiest notion of what it does or how I would use it.
00:34:56 <tikhonjelvis> Yeah, I think you should ignore it for now ;)
00:34:59 <lukish> http://hackage.haskell.org/package/repa-bytestring found it
00:35:04 <tikhonjelvis> You'll learn about them in due time.
00:35:35 <zzo38> srhb: I know I find I want feature X, or feature Y, or feature Z, or feature @$(*U<!_(%L_*!%>X_U!+:X+UA)&M)(#*L%+)#&%:+)#%LX&#!<$YLX!U#<+$OPUAMFOJICOW<+RU)TM)U)#(*$U)+*%(#@+*$@@+)IE+@)(EI@()(+$
00:35:49 <ChristianS> Plembo: your problem sound a bit like http://en.wikipedia.org/wiki/Dijkstra%27s_algorithm , except that you're searching the longest instead of the shortest path? (but that should be easy to fix)
00:37:41 <lukish> http://hpaste.org/63442 what is that mean?
00:41:16 <rekado> I'm trying to compile haskell code for ARM through the llvmwbackend
00:41:27 <rekado> llvm backend
00:41:40 <rekado> using GHC 7.4.1
00:42:04 <rekado> has anyone got this working?
00:42:30 <rekado> llc segfaults when attempting to compile the generated code.
00:47:00 <chairdog> someone give me a clue about HXT - if I've done x <- readDocument, y <- readDocument, and can write out with writeDocument -< x -- can someone point me at what I might use to combine x and y to make a single document that I can write out?
00:47:11 <chairdog> heh that kinda sounds like a homework question.
00:47:42 <srhb> chairdog: Is it? :P
00:49:00 <chairdog> srhb: nope
00:49:16 <chairdog> srhb: i'm trying to do some xml processing but decided i would doing using a library i don't know how to use.
00:49:21 <chairdog> just to make things harder.
00:49:50 <chairdog> i want to make some html reports from summarised DMARC mail delivery reports, eventually
00:49:58 <chairdog> (which come as XML)
00:50:38 <srhb> chairdog: Define combine, then.
00:51:59 <chairdog> srhb: for now I'm trying to understand how say one file <foo><bar/></foo> and <foo><qaz/></foo> into <foo><bar/><qaz/></foo> perhaps
00:52:13 <chairdog> i dont' really know what I want to do... ;)
01:10:17 <guerrilla> is there a version of GHC that supports unicode subscript digits?
01:12:00 <guerrilla> for identifiers i meant
01:13:13 <guerrilla> oh, i guess 7.2.1 http://hackage.haskell.org/trac/ghc/ticket/4373
01:13:47 <randomclown> is there a wat to point free this code? \x -> unlines (solve `map` lines x)
01:14:05 <randomclown> way*
01:15:11 <tikhonjelvis> @pl \x -> unlines (solve `map` lines x)
01:15:11 <lambdabot> unlines . fmap solve . lines
01:15:15 <tikhonjelvis> magic :)
01:15:37 <randomclown> lol
01:15:38 <tikhonjelvis> Coincidentally, just unlines . map solve . lines should work too.
01:15:49 <randomclown> yeah because of the map thing
01:17:37 <tikhonjelvis> fmap is just map overloaded for other types
01:17:51 <srhb> Does anyone have the enableGui hack working on OS X with GHCI and wxHaskell? I get "unknown symbol `___dso_handle' and it barfs.
01:28:26 <MaskRay> how to decode [Char8] via utf8?
01:33:12 <zomg> MaskRay: I think you need to first use Data.ByteString.Char8.unpack to get a String out of it
01:33:23 <zomg> after that use one of the utf8 things, you can prob find that on google
01:33:25 <chridi> hi
01:34:23 <ChristianS> there is no Char8 type, Char8 is just a package
01:34:30 <chridi> I want to do some network stuff with haskell... which rpc module is recomended?
01:35:08 <zomg> ChristianS: yeah might have confused it with Word8 now that I think of it :D
01:35:13 <MaskRay> zomg: no result...
01:35:17 <srhb> Yeah, it is a Bytestring, not Char8, but that Bytestring is essentially [Char8]
01:35:33 <MaskRay> zomg: Codec.Binary.UTF8.Generic ?
01:38:32 <ChristianS> MaskRay: yes, you could use the utf8-string package, but you can also use decodeUtf8 (Data.Text.Encoding) from the Text package
01:39:28 <ChristianS> Text is has much richer api, but it might be slower if you don't need the advanced stuff (mapping overs chars and such)
01:39:38 <MaskRay> ChristianS: i'm actually working on an project using attoparsec. all the inner process is via Char8 instead of Char to get rid of encoding overhead
01:40:39 <ChristianS> Char8 only works for ascii or latin1. if you're input is utf8, you'll get problems
01:41:52 <MaskRay> so i'd better switch to attoparsec.text ?
01:42:21 <ChristianS> didn't look at it, but i would suppose so
01:44:29 <neutrino> hi guys
01:44:36 <neutrino> i have a hardcore problem
01:44:57 <neutrino> this haskell program typechecks but it is not correct!
01:45:01 <neutrino> how bizzarre is that
01:45:18 <zomg> Must be a bug in GHC
01:45:40 <neutrino> i made a minimal test case and the minimal test case works
01:45:44 <neutrino> i don't know wtf is going on :(
01:46:00 <sipa> phase of the moon
01:46:49 <neutrino> oh shit i just looked at the file i was parsing
01:47:03 <neutrino> it's in fact an old version
01:47:09 <neutrino> V_V
01:47:16 <neutrino> 3 hours spent debugging this :(
02:06:53 <neutrino> hmm hpaste seems laggy
02:07:38 <hpaste> neutrino pasted ‚Äúoptional parsec - problem‚Äù at http://hpaste.org/63453
02:08:23 <neutrino> hey guys, anyone know how to "make it work"?
02:08:44 <neutrino> i've got this parser, it should search for a string, and return that string and anything that was before it separately
02:09:39 <neutrino> it seems to be getting hung up if the "anything before" contains a part that starts the same way my normal string starts
02:12:07 <Jafet> If parsing fails, try, try again
02:12:26 <neutrino> hao
02:12:31 <Jafet> @hoogle try
02:12:32 <lambdabot> Control.OldException try :: IO a -> IO (Either Exception a)
02:12:32 <lambdabot> System.IO.Error try :: IO a -> IO (Either IOError a)
02:12:32 <lambdabot> Control.Exception.Base try :: Exception e => IO a -> IO (Either e a)
02:12:50 <Jafet> @slap
02:12:50 <lambdabot> Come on, let's all slap
02:14:06 <neutrino> thanks
02:14:11 <neutrino> i use "try" elsewhere already but i'm still not sure how exactly "try" works
02:14:11 <neutrino> i'll need to figure it out one day
02:14:33 <Jafet> parsec does not backtrack
02:17:10 <neutrino> aha
02:17:18 <neutrino> so "try" just rolls back?
02:17:25 <neutrino> on error?
02:17:50 <neutrino> is it like some crazy continuation passing style thing, Jafet ?
02:17:55 <Jafet> If you're a UML database analyst, yes
02:18:01 <Jafet> Otherwise it just backtracks on failure
02:18:12 <neutrino> why am i a UML database analyst
02:18:25 <neutrino> oh you mean "rolls back" ok
02:18:30 <Jafet> Because you're using amusing terminology
02:18:58 <neutrino> so does "try" hold the continuation it had at its entry point, and in case of an error uses that continuation instead of what would happen by default?
02:19:40 <Jafet> There is no continuation, it just remembers the position in the input and backtracks there.
02:19:56 <Jafet> It would be quite strange to implement this with continuations.
02:20:20 <neutrino> but "try" is not specific to parsec is it?
02:20:52 <neutrino> so that kinda makes no sense, given that most things you might want to "try" don't even have an "input position"
02:20:52 <Jafet> Text.Parsec.try is, being in the Text.Parsec module and the parsec package, fairly specific to parsec
02:21:07 <neutrino> ok
02:21:32 <neutrino> i thought it was just conveniently placed there, while actually being a general 'try' function
02:21:34 <Jafet> And Control.Exception.try is the bog-standard exception handling operator.
02:21:40 <neutrino> ok
02:21:46 <Jafet> If you want things to be rolled back, use STM.
02:22:18 * Jafet can't find the documentation for trifecta
02:24:34 <neutrino> why u pull my leg
02:25:03 <carpi> could someone please tell me the difference between "boxed" and "unboxed".. I keep seeing these words in the haskell wiki
02:25:46 <wern> While installing hlint I get a "cannot satisfy -package-id transformers-0.2.2.0-4bbbfde1fb5c4eb17cdb1963dda698f3", but "cabal info transformers" says: "Versions installed: 0.2.2.0". What am I missing?
02:27:39 <neutrino> that long random string at the end?
02:28:06 <Jafet> carpi: boxed types may contain bottom.
02:29:58 <carpi> Jafet: bottom? as in they could hold a value like 'undefined'?
02:30:15 <Jafet> Actually, you know what
02:30:24 <Jafet> http://hackage.haskell.org/trac/ghc/wiki/Commentary/Rts/Storage/HeapObjects
02:30:58 <Jafet> wern: in which package world is transformers installed? In which world are you trying to install hlint?
02:33:52 <wern> Jafet: I'm doing a local user install, transformers exist globally (system wide) only (right version number)
02:34:34 <Jafet> Then you are in a very strange world, I'm afraid
02:40:38 <wern> solved: "cabal install transformers --reinstall" fixed the problem. Don't know why the global version didn't satisfy the dependency.
03:05:10 <`Jake`> If whoever told me that is online at the moment, thank you for advising me to read learnyouahaskell.com, it's definitely more fun to learn something if the author wrote it in a funny way
03:06:17 <c_wraith> Well, I wasn't the one who recommended it, but it is something I often recommend, because of both the humor and the fact that it's not a bad intro
03:07:10 <guerrilla> i'm really confused.. i'm getting the wrong branch of an if-then-else.. http://hpaste.org/63458 i'm like 99% sure 4 >= 0.. how can this happen?
03:07:32 <guerrilla> oh wait, im retarded :)
03:08:18 <`Jake`> c_wraith: Yeah, it's really easy to understand everything in it (so far)
03:09:11 <c_wraith> Towards the end, it gets harder, but that's because it's trying to cover material that really just takes more time to learn than you'll have spent working towards it before that.
03:09:53 <`Jake`> Well, i'll try to look forward to that challenge ;-)
03:12:07 * hackagebot numeric-prelude 0.3.0.1 - An experimental alternative hierarchy of numeric type classes  http://hackage.haskell.org/package/numeric-prelude-0.3.0.1 (HenningThielemann)
03:15:46 <Plembo> Does anyone know how I can make this function more general, so I could pass it an integer and it would feedback lists of the passed parameter's size? allpaths = [[a, b, c, d] | a <- [0..3], b <- [0..3], c <- [0..3], d <- [0..3], abs (b-a) <= 1, abs (c-b) <= 1, abs (d-c) <= 1]
03:16:00 <Plembo> e.g. if I passed it 8, it would feed me back every possible list of 8 that also satisfies those other requirements
03:18:05 <ddarius> Plembo: It should go from 0-7 and also produce 8 elements?
03:18:52 <Plembo> Well, i tshould be a list with 8 elements. If element 0 is 1, then element 1 must be within 1 of 1. Then continuously do that all the way down.
03:19:10 <Plembo> To give it some context, I'm trying to map out all possible paths down a grid, assuming we can only move down, diagonally left, or diagonally right
03:19:38 <otk_> what's a good alg for common subsequences in a single sequence
03:20:02 <guerrilla> is there a prettier way to do anonymous pattern matching.. ((\(Arity n) -> Quantity n) k) is pretty silly
03:20:32 <ddarius> guerrilla: You were binding to a variable anyway in the example you gave before.  Just pattern match in the binding.
03:20:34 <donri> case k of Arity n -> Quantity n
03:21:12 <guerrilla> ddarius: yeah, i was just using it as an example :)
03:21:19 <otk_> split string in half then use LCS doesnt work really
03:21:41 <otk_> on the account that the partition of the string may be the common subseqeunce
03:22:13 <guerrilla> donri: i guess :\
03:22:15 <ddarius> > let f n = do p <- replicateM n [0..n-1]; guard (zipWith (\a b -> abs (b-a) <= 1) p (drop 1 p); return p in f 3
03:22:16 <lambdabot>   <no location info>: parse error on input `;'
03:22:35 <ddarius> > let f n = do p <- replicateM n [0..n-1]; guard (and $ zipWith (\a b -> abs (b-a) <= 1) p (drop 1 p)); return p in f 3
03:22:36 <lambdabot>   [[0,0,0],[0,0,1],[0,1,0],[0,1,1],[0,1,2],[1,0,0],[1,0,1],[1,1,0],[1,1,1],[1...
03:22:48 <Plembo> awesome, thanks so much ddarius!
03:22:50 <ddarius> Note that that is a horribly inefficient algorithm for doing this.
03:23:16 <mauke> :t inRange
03:23:17 <lambdabot> forall a. (Ix a) => (a, a) -> a -> Bool
03:24:19 <mauke> :t replicateM
03:24:19 <lambdabot> forall (m :: * -> *) a. (Monad m) => Int -> m a -> m [a]
03:27:20 <ddarius> :t array
03:27:21 <lambdabot> forall i e. (Ix i) => (i, i) -> [(i, e)] -> Array i e
03:28:01 <btvl> should it start to be worried when I get "Not in scope: `return'" ?
03:28:07 <ddarius> btvl: No.
03:28:18 <btvl> I feel much better already
03:28:37 <btvl> is that because something I imported did hide the prelude µ?
03:30:07 <ddarius> @let dp bnds f = a where a = array bnds $ map (\ix -> (ix, f a)) (range bnds)
03:30:08 <lambdabot>  Defined.
03:30:56 <ddarius> @undefine
03:31:03 <ddarius> @let dp bnds f = a where a = array bnds $ map (\ix -> (ix, f a ix)) (range bnds)
03:31:04 <lambdabot>  Defined.
03:34:16 <Franciman> hi all
03:34:24 <donri> hi one
03:35:05 <Franciman> I want to write my version of zip ( just to practice with lists and tuples ) , how can I tell zip to stop when one of the two lists given as input are finished?
03:36:09 <ChristianS> Franciman: pattern matching
03:36:09 <donri> pattern match on the empty list input and return empty lists instead of recursing
03:36:11 <Botje> pattern matching
03:36:24 <Franciman> oh it's too advanced for me
03:36:33 <ddarius> > let get a ix@(i,j) | i >= 0 && j >= 0 = a!ix | otherwise = [] in dp ((0,0), (1,1)) $ \a ix -> case ix of (0,0) -> [[]]; (i,j) -> map (ix:) $ concat [get a (i-1,j), get a (i,j-1), get a (i-1, j-1)]
03:36:34 <donri> supposedly you are recursing and building up lists with (:)
03:36:34 <lambdabot>   array ((0,0),(1,1)) [((0,0),[[]]),((0,1),[[(0,1)]]),((1,0),[[(1,0)]]),((1,1...
03:36:35 <Franciman> I've started for a couple of hours
03:36:42 <Botje> Franciman: what do you have now?
03:36:47 <Botje> maybe you just need a small nudge
03:37:47 <ddarius> I guess I'd actually want [[ix]] as the base case.
03:37:51 <Franciman> I wrote : MyZip list1 list2 = [ ( x, y ) | x <- list1, y <- list2 ]
03:39:09 <donri> that will not do what you want
03:39:18 <shachaf> Franciman: Even if that worked you wouldn't learn anything from doing it.
03:39:31 <Franciman> why?
03:39:40 <Franciman> ( to both )
03:39:40 <ddarius> shachaf: Franciman learns more by it not working.
03:39:53 <shachaf> ddarius: That's a fair point.
03:40:02 <sanjoyd> > [(x, y) | x <- [1..3], y <- [1..3]]
03:40:03 <lambdabot>   [(1,1),(1,2),(1,3),(2,1),(2,2),(2,3),(3,1),(3,2),(3,3)]
03:40:19 <Franciman> ah
03:40:20 <sanjoyd> Franciman: what you wrote is not a zip.
03:40:22 <Franciman> I didn't know
03:40:30 <Franciman> it's a combination generator
03:40:40 <Franciman> well off to lunch brb
03:40:41 <Franciman> thanks :D
03:40:52 <Franciman> I'll try again to do that and get it right this time
03:40:55 <sanjoyd> I think it is the same as:
03:40:56 <sanjoyd> > do { x <- [1..3]; y <- [1..3]; [(x, y)] }
03:40:57 <lambdabot>   [(1,1),(1,2),(1,3),(2,1),(2,2),(2,3),(3,1),(3,2),(3,3)]
03:41:06 <sanjoyd> Rather,
03:41:11 <sanjoyd> > do { x <- [1..3]; y <- [1..3]; return (x, y) }
03:41:12 <lambdabot>   [(1,1),(1,2),(1,3),(2,1),(2,2),(2,3),(3,1),(3,2),(3,3)]
03:41:29 <shachaf> Franciman: You'll probably be best off not using a list comprehension. Those things are overrated anyway.
03:41:32 <sanjoyd> Is this how Haskell desugars list comprehensions?
03:41:35 <ddarius> Some function similar to dp should be put in the array librarise.
03:41:36 <sanjoyd> shachaf: ^
03:41:43 <ddarius> sanjoyd: No.
03:41:48 <sanjoyd> ddarius: then?
03:41:51 <ddarius> Otherwise they'd be monad comprehensions.
03:41:52 <donri> sanjoyd: only with -XMonadComprehensions
03:42:03 <ddarius> @undo [(x, y) | x <- [1..3], y <- [1..3]]
03:42:03 <lambdabot> concatMap (\ x -> concatMap (\ y -> [(x, y)]) [1 .. 3]) [1 .. 3]
03:42:12 <ovechkin> why does 85/39 work. but x = 85; y = 39; x/y not work?
03:42:33 <shachaf> > let x = 85; y = 39 in x/y
03:42:34 <lambdabot>   2.1794871794871793
03:42:39 <shachaf> @where dmr
03:42:39 <lambdabot> http://www.haskell.org/haskellwiki/Monomorphism_restriction
03:42:54 <sanjoyd> @undo [(x, y) | x <- [1..3], y <- [1..3], (x + y) == 6]
03:42:54 <lambdabot> concatMap (\ x -> concatMap (\ y -> if (x + y) == 6 then [(x, y)] else []) [1 .. 3]) [1 .. 3]
03:42:57 <donri> sanjoyd: http://www.reddit.com/r/haskell/comments/oolyt/why_are_guards_in_the_list_comprehension_faster/
03:43:02 <sanjoyd> Interesting.
03:43:09 * ddarius considers starting a periodical labelled DMR to complement TMR.
03:44:00 <ovechkin> shachaf: is that monomorphism link for me?
03:44:14 <shachaf> ovechkin: Yes.
03:44:19 <ovechkin> shachaf: thanks
03:44:27 <shachaf> So is the line above it.
03:45:51 <hpaste> ovechkin pasted ‚Äúfractional integer‚Äù at http://hpaste.org/63460
03:46:08 <ovechkin> shachaf: so what is the difference between how we both entered those lines?
03:46:17 <ovechkin> why do they work differently
03:46:18 <ovechkin> ?
03:46:57 <shachaf> ovechkin: Well, for one, yours was in three lines and mine was in one, and used let-in rather than ghci's let.
03:47:08 <shachaf> Not that that changes much.
03:47:10 * hackagebot typelevel-tensor 0.1.0.3 - Tensors whose ranks and dimensions type-inferred and type-checked.  http://hackage.haskell.org/package/typelevel-tensor-0.1.0.3 (TakayukiMuranushi)
03:47:18 <shachaf> As far as why they work differently, well, you should see that link there.
03:47:33 <ovechkin> ok, thanks
03:47:54 <Axman6> so, anyone have any tips for installing 7.4.1? i'm considering just avoiding the whole mess i usually have and just deleting my ~/.{ghc|cabal} dirs
03:47:58 <shachaf> I could type out the contents of that link to explain it, but it seems a bit wasteful.
03:48:05 <shachaf> Axman6: I didn't need to delete either.
03:48:18 <shachaf> I just installed the GHC 7.4 binary package and it just worked.
03:48:21 <Axman6> do you need a later version of cabal-install?
03:48:24 <shachaf> GHC 7.0 is continuing to work.
03:48:40 <shachaf> Nope. In fact I think cabal-install may not even compile under 7.4 or something, according to vague rumours.
03:49:03 <Axman6> o.O fun
03:49:08 <Axman6> oh well, here goes
03:49:23 <shachaf> Also, you use OSX, don't you? Probably everything will be broken in that case.
03:49:30 <Axman6> indeed
03:50:29 <ddarius> Different GHCs have different package databases, so I don't know why you'd delete .ghc.
03:50:58 <Axman6> it was probably problems when using the same ghc version from different places
03:51:00 <Axman6> anyway
03:52:10 * hackagebot Paraiso 0.2.0.2 - a code generator for partial differential equations solvers.  http://hackage.haskell.org/package/Paraiso-0.2.0.2 (TakayukiMuranushi)
03:52:20 <Axman6> hmm, where does the OS X installer install ghc to... i've only got 7.2.1 in /usr/local/bin
03:54:41 <Axman6> ah, /usr/bin. that's kinda annoying. now i need to uninstall 7.2.1 from /usr/local/
03:55:13 <shachaf> Why?
03:55:17 <shachaf> Just install to /usr/local
03:55:48 <Axman6> the OS X installer doesn't install there
03:57:52 <Axman6> ok, i think i got everything
03:59:11 <Franciman> back
03:59:15 <Franciman> shachaf ah ok
04:01:44 <Franciman> well, I guess I must study more
04:02:02 <ddarius> :t elems
04:02:03 <lambdabot> forall i e. (Ix i) => Array i e -> [e]
04:02:15 <ddarius> @hoogle Array i e -> [(ix, e)]
04:02:16 <lambdabot> Data.Array assocs :: Ix i => Array i e -> [(i, e)]
04:02:16 <lambdabot> Data.Graph.Inductive.Graph lpre :: Graph gr => gr a b -> Node -> [(Node, b)]
04:02:16 <lambdabot> Data.Graph.Inductive.Graph lsuc :: Graph gr => gr a b -> Node -> [(Node, b)]
04:02:58 <ddarius> > let get a ix@(i,j) | i >= 0 && j >= 0 = a!ix | otherwise = [] in assocs $ dp ((0,0), (1,1)) $ \a ix -> case ix of (0,0) -> [[ix]]; (i,j) -> map (ix:) $ concat [get a (i-1,j), get a (i,j-1), get a (i-1, j-1)]
04:03:00 <lambdabot>   [((0,0),[[(0,0)]]),((0,1),[[(0,1),(0,0)]]),((1,0),[[(1,0),(0,0)]]),((1,1),[...
04:03:13 <ChristianS> Franciman: you could read http://learnyouahaskell.com/ , it's a good start
04:03:24 <Franciman> yeah, that's what I'm reading :)
04:03:36 <ddarius> > let get a ix@(i,j) | i >= 0 && j >= 0 = a!ix | otherwise = [] in last $ assocs $ dp ((0,0), (1,1)) $ \a ix -> case ix of (0,0) -> [[ix]]; (i,j) -> map (ix:) $ concat [get a (i-1,j), get a (i,j-1), get a (i-1, j-1)]
04:03:37 <ChristianS> great :-)
04:03:38 <lambdabot>   ((1,1),[[(1,1),(0,1),(0,0)],[(1,1),(1,0),(0,0)],[(1,1),(0,0)]])
04:04:03 <ChristianS> and if you want a spoiler, you can always ask lambdabot to  @src zip
04:05:43 <Chaze> is there another name by which 'iterate' might be known in other languages?
04:05:56 <Chaze> > iterate (+1) 0
04:05:57 <lambdabot>   [0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,...
04:06:33 <Chaze> something that generates [c, f c, f f c, ..]
04:07:26 <twanvl> I know that Mathematica calls it Nest / NestList
04:07:52 <Chaze> is there a way to define it with 'fix'?
04:08:14 <twanvl> sure, you can define any recursive function with fix
04:09:08 <Chaze> yeah, very simplistic
04:09:09 <Chaze> iterate f x = fix ((x:) . map f)
04:09:51 <Chaze> but i'm having a hard time understanding that line
04:10:32 <Chaze> now i got it :)
04:10:38 <ddarius> @src iterate
04:10:38 <lambdabot> iterate f x =  x : iterate f (f x)
04:10:47 <ddarius> @pl  iterate f x =  x : iterate f (f x)
04:10:48 <lambdabot> iterate = fix ((ap (:) .) . ((.) =<<))
04:11:00 <ddarius> @pl  iterate  x =  x : iterate f (f x)
04:11:00 <lambdabot> iterate = fix (ap (:) . (. f) . ($ f))
04:11:32 <ddarius> @pl  iterate  x =  x : iterate (f x)
04:11:32 <lambdabot> iterate = fix (ap (:) . (. f))
04:12:10 * hackagebot Grempa 0.2.1 - Embedded grammar DSL and LALR parser generator  http://hackage.haskell.org/package/Grempa-0.2.1 (OlleFredriksson)
04:13:38 <mm_freak_> Chaze: 'iterate' is a special case of 'unfoldr'
04:13:45 <mm_freak_> so "unfold" might be a good search term
04:14:01 <twanvl> another way:  iterate f = fix (\iteratef x -> x : iteratef (f x))
04:14:12 <mm_freak_> but i doubt that many other languages have this, because 'iterate' requires lazy lists at least
04:14:18 <Chaze> ah, i remember learning about unfold
04:14:29 <Chaze> basically, it does the same, except some Maybe-magic happening
04:14:35 <Chaze> so if there's a nothing, the list ends
04:14:37 <Chaze> right?
04:14:54 <mm_freak_> yes‚Ä¶  unfoldr can actually be implemented in other languages, because it allows finite lists
04:15:03 <mm_freak_> iterate always gives an infinite list
04:15:19 <Chaze> mm_freak_: its quite easy to implement a python generator
04:15:26 <Chaze> but i'm wondering if there already is one
04:16:39 <ddarius> :t let unfoldStream f s = unfoldr (Just . f) s in unfoldStream
04:16:39 <lambdabot> forall b a. (b -> (a, b)) -> b -> [a]
04:16:54 <mm_freak_> well, 'iterate' is a combinator
04:17:02 <mm_freak_> > takeWhile (< 15) . iterate succ $ 0
04:17:04 <lambdabot>   [0,1,2,3,4,5,6,7,8,9,10,11,12,13,14]
04:18:00 <Chaze> what exactly is a 'combinator'?
04:18:15 <Chaze> i have some intuition, but can't find a definition
04:19:02 <ddarius> Chaze: It has no definition.  There are formal definitions of things called "combinators," but most people use the term as in a way that may as well be synonymous with "function."
04:19:20 <mm_freak_> a higher order function‚Ä¶  the point is:  python generators are an ad hoc solution‚Ä¶  you don't get a list, you get a routine for which you have a special language construct to make it act like a list
04:19:41 <mm_freak_> so you don't get 'iterate', but an emulation of it
04:19:42 <ddarius> mm_freak_: That's not the problem.  The problem is that generators don't act like a list.
04:20:21 <Chaze> mm_freak_: yeah, but its the best thing you get without infinite lists right?
04:20:40 <mm_freak_> Chaze: you can have coroutines without infinite lists, and that's basically what generators are
04:20:48 <ddarius> You can easily implement persistent streams in Python or most languages.
04:21:22 <mm_freak_> Chaze: a close translations of generators to haskell would be conduits (or general coroutines)
04:23:37 <Plembo> If I have a list with, say, [0, 1, 3, 2], then I have a list of lists. Does anyone have any advice on how I can go about grabbing element 0 in row 0, element 1 in row 1, element 3 in row 2, element 2 in row 4 and summing the values at those locations up and returning their sum?
04:23:46 <Plembo> Just started Haskell a little over 2 days ago, so this is stumping me a bit :P
04:23:59 <srhb> Plembo: Like, the diagonal?
04:24:26 <srhb> Plembo: Start by grabbing the diagonal, then go about the rest.
04:24:31 <Plembo> srcerer, Well, the values will differ each time. E.g. one set of indexes could be [0, 0, 0, 0]. Anothe could be [2, 1, 3, 1]
04:24:32 <Plembo> etc
04:24:43 <srhb> Oh, okay.
04:24:54 <srhb> Simple, you use the first list as indices
04:25:06 <kallisti> zipWith (!) matrix indexList
04:25:09 <kallisti> er
04:25:13 <kallisti> zipWith (!!) matrix indexList
04:25:25 <Plembo> so I could do
04:25:34 <Plembo> listtoreadfrom !! 0 !! 1
04:25:39 <Plembo> to get [0][1]?
04:26:03 <kallisti> Plembo: yes. though I question that linked lists are a good choice of data structure.
04:26:13 <kallisti> if you want random access there are better structures to use.
04:26:30 <Plembo> the book I'm reading states that I should use a LL for this, as it's the only data structure I've used so far
04:26:34 <Plembo> I know !! is very inefficient, though
04:26:40 <kallisti> ah okay. that's fine I guess.
04:26:54 <kallisti> just know that Array or Vector might be a better choice.
04:27:05 <Plembo> Understood :) I haven't read about those so far
04:27:07 <Plembo> just in the third chapter
04:27:32 <srhb> Plembo: Here's a fairly simple to understand version
04:27:35 <srhb> > map (\i -> [1,2,3] !! i) [2,2,2]
04:27:36 <lambdabot>   [3,3,3]
04:28:01 <kallisti> > zipWith (!!) [[1,2,3], [4,5,6], [7,8,9]] [2,2,2]
04:28:02 <lambdabot>   [3,6,9]
04:28:17 <Plembo> ahh, very naet
04:28:22 <Plembo> I'll try that now
04:28:30 <kallisti> Plembo: do you know about zipwith yet?
04:28:32 <Plembo> I don't
04:28:37 <kallisti> zip perhaps?
04:28:49 <Plembo> I haven't read the word zip at all so far
04:28:52 <kallisti> > zip [1,2,3,4] [5,6,7,8]
04:28:52 <lambdabot>   [(1,5),(2,6),(3,7),(4,8)]
04:29:05 <mm_freak_> > zipWith f [a, b, c] [x, y, z]
04:29:06 <lambdabot>   Ambiguous type variable `c' in the constraints:
04:29:06 <lambdabot>    `GHC.Show.Show c'
04:29:07 <lambdabot>      a...
04:29:08 <kallisti> zip takes two lists and combines into a single list of tuples.
04:29:11 <mm_freak_> > zipWith f [a, b, c] [x, y, z :: Expr]
04:29:12 <lambdabot>   Ambiguous type variable `c' in the constraints:
04:29:12 <lambdabot>    `GHC.Show.Show c'
04:29:12 <lambdabot>      a...
04:29:12 <Plembo> so if my list is in, say, gameboard
04:29:17 <Plembo> and gameboard has 4 lists in it
04:29:18 <Plembo> would
04:29:24 <kallisti> zipWith generalizes this to any arbitrary 2-argument function.
04:29:31 <kallisti> so for example
04:29:35 <Plembo> zipWith (!!) gameboard [0, 1, 3, 2]
04:29:39 <mm_freak_> > zipWith f [x, y] [z, g]
04:29:40 <lambdabot>   Ambiguous type variable `c' in the constraints:
04:29:40 <lambdabot>    `GHC.Show.Show c'
04:29:40 <lambdabot>      a...
04:29:44 <mm_freak_> hmm
04:29:46 <Plembo> would that return element 0 from list 0, element 1 from list 1, element 3 from list 2, and element 2 form list 3?
04:29:50 <kallisti> zipWith (+) takes two lists and adds the elements of both together.
04:30:06 <kallisti> > zipWith f [x, y] [z, g] :: Expr
04:30:07 <lambdabot>   Couldn't match expected type `SimpleReflect.Expr'
04:30:07 <lambdabot>         against inferred ...
04:30:11 <kallisti> bah
04:30:20 <kallisti> > zipWith (*) [x, y] [z, g] :: Expr
04:30:20 <mm_freak_> > zipWith (+) [a, b] [c, d]
04:30:21 <lambdabot>   Couldn't match expected type `SimpleReflect.Expr'
04:30:21 <lambdabot>         against inferred ...
04:30:21 <lambdabot>   [a + c,b + d]
04:30:24 <mm_freak_> hah
04:30:27 <kallisti> oh right
04:31:05 <kallisti> Plembo: yes
04:31:09 <Plembo> very neat
04:31:15 <Plembo> let me see if I can make this work -- thanks a loT1
04:31:16 <Plembo> a lot*
04:31:27 <kallisti> no problem.
04:31:29 <alpounet> 3> zipWith (f :: Expr -> Expr -> Expr) ([a, b] :: [Expr]) ([c, d] :: [Expr])
04:31:33 <alpounet> > zipWith (f :: Expr -> Expr -> Expr) ([a, b] :: [Expr]) ([c, d] :: [Expr])
04:31:34 <lambdabot>   [f a c,f b d]
04:31:47 <mm_freak_> Plembo: if you do this a lot and in more complicated ways, there are also ZipLists in Control.Applicative
04:32:26 <mm_freak_> > ZipList [sin, cos] <*> ZipList [0, pi]
04:32:27 <lambdabot>   No instance for (GHC.Show.Show (Control.Applicative.ZipList a))
04:32:27 <lambdabot>    arising ...
04:32:34 <mm_freak_> > getZipList $ ZipList [sin, cos] <*> ZipList [0, pi]
04:32:35 <lambdabot>   [0.0,-1.0]
04:32:50 <Plembo> parsepath board path = sum(zipWith (!!) board path) -- bingo, there we go!
04:32:52 <Plembo> That's insane
04:32:53 <kallisti> mm_freak_: I wouldn't attempt to transition into Applicatives right now. :P
04:32:56 <Plembo> I've only been programming for a few months
04:32:59 <Plembo> and all of my experience is in Java
04:33:02 <Plembo> remarkable how concise haskell can be
04:33:33 <kallisti> map (\(i, j) -> vector ! i ! j) $ zip [0..] [2,2,2,2]
04:33:37 <ddarius> :t sum .: zipWith (!!)
04:33:38 <lambdabot> forall a. (Num a) => [[a]] -> [Int] -> a
04:33:38 <kallisti> if you ever switch to using Vector
04:33:47 <kallisti> the above code might be useful to you.
04:34:09 <mm_freak_> Plembo: that's mostly due to much less syntax noise and combinators (instead of loops)
04:34:34 <mm_freak_> zipWith is your replacement for the traditional for-loop
04:34:45 <mm_freak_> (one of them)
04:34:54 <Plembo> ahh, understood :)
04:35:30 <mm_freak_> in haskell the line between control and data structures is very blurry =)
04:35:45 <kallisti> Plembo: also zipWith short circuits on whichever list is shorter.
04:35:51 <kallisti> > zip [1,2,3] [4..]
04:35:52 <lambdabot>   [(1,4),(2,5),(3,6)]
04:36:19 <kallisti> ( zip is just a special version of zipWith; specifically zipWith (,) )
04:36:34 <Plembo> It's been tough to get the hang of haskell so far. It seems pretty neat, but definitely throws my head for a bit of a loop
04:36:39 <Plembo> I'm sure it gets easier in time
04:36:46 <Plembo> and by I'm sure, I mean I hope!
04:36:48 <kallisti> well, the basics get easier
04:37:27 <Plembo> Now that there's a function to calculate the sum of a path, I need ot figure out some way to go through a massive list of paths and find the path that has the highest sum
04:37:40 <Plembo> I'm assuming I want to do something along the lines of
04:37:50 <scolobb> Plembo: Don't want to scare you, but I've been programming in Haskell for two years (not very intensely, though), and there's still a lot of thinks I don't understand :-)
04:37:50 <kallisti> a practiced Haskell programmer will be familiar with dealing with some of the basic data structures, especially lists, since they represent the notion of a linear loop.
04:37:50 <lambdabot> scolobb: You have 1 new message. '/msg lambdabot @messages' to read it.
04:38:15 <kallisti> > maximum [1,1000,235,3]
04:38:16 <lambdabot>   1000
04:38:22 <kallisti> Plembo: hope that helps. :>
04:39:05 <Plembo> Now, given that I have to find the best path, the way I measure the quality of each path is its sum. So I'd want to find the path that has the highest sum, but I need it to return the path (rather than the sum). Is there any way to do something like
04:39:10 <Plembo> maximum [allpaths]
04:39:22 <Plembo> and then it would find which path has th ehighest sum, and simply return that path, rather than its sum?
04:39:24 <Plembo> Hopefully that made sense.
04:39:26 <kallisti> I would name  your path like sumPath or something.
04:39:27 <alpounet> there's even maximumBy
04:39:30 <ksion> > maximumBy length ["a", "bb"]
04:39:31 <lambdabot>   Couldn't match expected type `[a] -> GHC.Ordering.Ordering'
04:39:32 <lambdabot>         against...
04:39:36 <kallisti> then map sumPath to a list of paths.
04:39:39 <kallisti> and find the maximum of the result
04:39:54 <alpounet> > maximumBy (compare `on` length) ["a", "bb"]
04:39:54 <lambdabot>   "bb"
04:40:00 <kallisti> Plembo: oh, no.
04:40:02 <ksion> Ah.
04:40:04 <kallisti> it would return the maximum sum
04:40:09 <kallisti> so you'd want to use maximumBy
04:40:16 <alpounet> ksion, it asks for a function 'a -> a -> Ordering'
04:40:19 <Plembo> and for the criteria of maximumBy?
04:40:26 <kallisti> > maximumBy sum [[1,2,3], [5,6,7], [8,9,10]]
04:40:27 <lambdabot>   Occurs check: cannot construct the infinite type:
04:40:27 <lambdabot>    a = [a] -> GHC.Orderin...
04:40:31 <kallisti> er
04:40:32 <nand`> > maximumBy (comparing length) ["a", "bb"]
04:40:33 <lambdabot>   "bb"
04:40:40 <kallisti> > maximumBy (comparing sum) [[1,2,3], [5,6,7], [8,9,10]]
04:40:40 <lambdabot>   [8,9,10]
04:40:55 <kallisti> :t maximumBy
04:40:56 <lambdabot> forall a. (a -> a -> Ordering) -> [a] -> a
04:41:13 <kallisti> Plembo: maximumBy basically takes a comparison function and uses that instead of the default comparison operators.
04:41:32 <Plembo> Very neat. Now, I have this line from before:
04:41:39 <kallisti> and comparing is a nice way to compare the results of applying a function.
04:41:39 <Plembo> sum(zipWith (!!) board path)
04:41:50 <kallisti> > comparing sum [1,2,3] [4,5,6]
04:41:51 <lambdabot>   LT
04:41:54 <Plembo> That takes a list with 4 indices, and uses those indices to come to a total sum
04:41:56 <kallisti> @src comparing
04:41:56 <lambdabot> Source not found. You speak an infinite deal of nothing
04:42:01 <nand`> I like how ‚ÄúmaximumBy (comparing sum)‚Äù reads english
04:42:15 <mm_freak_> > maximumBy (comparing sum) [[1,2,3], [4,5,6], [7,8,9]]
04:42:15 <lambdabot>   [7,8,9]
04:42:19 <Axman6> comparing f x y = compare (f x) (f y)
04:42:23 <Axman6> :t on
04:42:24 <lambdabot> forall b c a. (b -> b -> c) -> (a -> b) -> a -> a -> c
04:43:08 <kallisti> Plembo: compare takes two values of any type that can be ordered, and returns a so-called Ordering value. The three possible Orderings are LT, EQ, and GT.
04:43:21 <nand`> > compare 3 5
04:43:21 <lambdabot>   LT
04:44:02 <ksion> It's like comparators from other languages than return <0, 0 or >0 as result of comparison of two objects.
04:44:02 <kallisti> comparing f x y = compare (f x) (f y)  -- so comparing applies both values to a function before comparing them. "comparing length" compares two lists by their length. "comparing sum" compares two lists by their summation, etc.
04:44:03 <mm_freak_> Plembo: do yourself a favor and don't try to reproduce java syntax‚Ä¶  function application is two "words" written in sequence:  f x or f (x), but f(x) is misleading
04:44:20 <Plembo> mm_freak_, ahh, fair point!
04:44:36 <Plembo> kallisti, that makes sense, but making the leap from there into code is still tough for me. I'm trying to take this step by step
04:44:41 <Plembo> So I already have a function that will sum up a given path
04:44:42 <nand`> I'd use sum $ zipWith (!!) board path
04:45:21 <kallisti> Plembo: you likely will want to keep the sum function seperate.
04:45:25 <Axman6> it would be nice if sortBy did a... schwartzian transform?
04:45:25 <mm_freak_> i'd use sum (zipWith (!!) board path)
04:45:26 <mm_freak_> =)
04:45:31 <kallisti> you want to return the path whose sum is the largest, yes?
04:45:36 <Plembo> correct, kallisti
04:45:49 <Plembo> So I have this list of lists (each nested list is a path)
04:45:56 <Plembo> I want to compare all of the paths and return the one with the largest sum
04:45:58 <Plembo> both its path, and its sum
04:46:00 <kallisti> okay, so if "comparing sum" takes two lists and compares them by their summations
04:46:15 <kallisti> and maximumBy takes a comparison function and a list and finds the maximum value as defined by the comparator.
04:46:25 <Plembo> comparing paths would take two lists and compares them by their sum (zipWith (!!) board path) ?
04:46:29 <kallisti> then maximumBy (comparing sum)  finds the list with the largest summation.
04:46:38 <Plembo> no
04:46:41 <Plembo> with comparing sum
04:46:48 <Plembo> err
04:46:50 <Plembo> now*, not no
04:47:16 <Plembo> ya, hmm. I'm still struggling to make sense of this. I keep falling back into thinking of this in an imperative way
04:47:20 <srhb> Plembo: Well, do you have a list of all paths?
04:47:24 <Plembo> I do, srhb
04:47:33 <Plembo> I use this function to generate them: allpaths = [[a, b, c, d] | a <- [0..3], b <- [0..3], c <- [0..3], d <- [0..3], abs (b-a) <= 1, abs (c-b) <= 1, abs (d-c) <= 1]
04:47:38 <srhb> Plembo: Then you're really close. ;)
04:47:57 <kallisti> Plembo: ah I see.
04:48:07 <kallisti> so instead of using sum you want to use your sumPath function.
04:48:11 <Plembo> Exactly, kallisti
04:48:21 <kallisti> how does  your sumPath function work? what are the arguments?
04:48:29 <Plembo> parsepath :: Gameboard -> Path -> Int
04:48:32 <kallisti> right
04:48:35 <Plembo> gameboard is a list with 4 nested lists
04:48:39 <Plembo> each list has 4 elements
04:48:42 <Plembo> path is the arrayof indices
04:48:45 <kallisti> so if you type "parsepath board"
04:48:55 <kallisti> you now have a function that takes a path and computes its sum on a specific game board.
04:49:08 <Plembo> *Mylist> parsepath [[3, 8, 2, 1], [1, 2, 5, 2], [9, 3, 8, 1]] [0, 0, 1, 0]
04:49:08 <Plembo> 7
04:49:10 <kallisti> which is exactly the kind of thing you want to pass to comparing
04:49:30 <mm_freak_> a good way to help haskell beginners is with this question:  "what's the type of ‚Ä¶?"
04:49:32 <Plembo> so I know I want maximumBy
04:49:34 <Plembo> I watn the maximum of it
04:49:36 <Plembo> in the bracket you have comparing sum
04:49:37 <mm_freak_> in this case:  what's the type of sumPath?
04:49:43 <Plembo> its return is an int
04:49:55 <mm_freak_> Plembo: write its type signature
04:49:55 <kallisti> Plembo: do you understand what comparing is?
04:50:05 <mm_freak_> sumPath :: ‚Ä¶
04:50:10 <Plembo> parsepath :: Gameboard -> Path -> Int
04:50:16 <Plembo> Gameboard = [[Int]]
04:50:18 <Plembo> Path = [Int]
04:50:25 <mm_freak_> so parsepath = sumPath?
04:50:31 <kallisti> yes
04:50:40 <Plembo> mm_freak_, ya, sorry, that's correct
04:50:52 <Plembo> So am I right so fa rin saying I have
04:50:56 <kallisti> Plembo: here's another example
04:51:08 <kallisti> > maximumBy (comparing abs) [1,-20000, 500, 400, -2]
04:51:09 <lambdabot>   -20000
04:51:16 <mm_freak_> then review the type of comparing:  comparing :: (a -> b) -> a -> a -> Ordering
04:51:18 <Plembo> oh
04:51:22 <Plembo> kallisti, that helped!
04:51:26 <Plembo> Alright, let me see if I can get somewbhere now
04:51:39 <mm_freak_> and remember:  (a -> b) -> a -> a -> Ordering = (a -> b) -> (a -> a -> Ordering)
04:51:47 <kallisti> Plembo: yes, so comparing creates a comparison function from a single-argument function. "comparing abs" is a function that compares by absolute value.
04:52:00 <mm_freak_> finally review the type of maximumBy:  (a -> a -> Ordering) -> [a] -> a
04:52:10 <Plembo> maximumBy (comparing parsepath) [[0, 1, 5, 2], [0, 0, 0, 0]]
04:52:15 <kallisti> almost
04:52:15 <Plembo> that gives me an error about maximuimBy not being in scope
04:52:16 <mm_freak_> do you see how to stick all those together?
04:52:18 <Plembo> is there a library I need to import?
04:52:20 <kallisti> but parsePath takes two arguments
04:52:28 <kallisti> Plembo: yes. Data.List
04:52:44 <kallisti> Plembo: comparing takes a single-argument function.
04:52:46 <kallisti> :t comparing
04:52:47 <lambdabot> forall b a. (Ord a) => (b -> a) -> b -> b -> Ordering
04:52:48 <mm_freak_> Plembo: your parsepath has this type:  Gameboard -> (Path -> Int)
04:53:03 <mm_freak_> the additional parentheses are intentional
04:53:13 <Plembo> (comparing parsepath [[3, 8, 2, 1], [1, 2, 5, 2], [9, 3, 8, 1]]) [[0, 1, 5, 2], [0, 0, 0, 0]]
04:53:18 <Plembo> I think there's a mistake somewhere there
04:53:20 <Plembo> but I think it's closer
04:53:24 <kallisti> Plembo: oh wait have you learned about partial application?
04:53:33 <Plembo> kallisti, never heard the term
04:53:36 <Plembo> only 30 pages into my book
04:53:38 <mm_freak_> Plembo: 'comparing' takes a one-argument function
04:53:40 <kallisti> Plembo: yes the mistake is operator precedence
04:53:50 <kallisti> Plembo: you meant (parsePath board)
04:53:50 <mm_freak_> your parsePath has two arguments
04:53:55 <Plembo> mm_freak_, how could I get around that?
04:53:57 <Plembo> I mean
04:54:02 <Plembo> how could I pass my gameboard into my path parser
04:54:13 <srhb> parsepath gameboard
04:54:16 <srhb> Simply.
04:54:18 <mm_freak_> well, haskell is a curried language, which means:  f x y = (f x) y
04:54:25 <mm_freak_> and (f x) is a function, which takes one more argument
04:54:50 <mm_freak_> so if you give less arguments, that's not an error, but the result is a function that takes the remaining arguments
04:55:04 <Plembo> ahh, understood
04:55:09 <Plembo> well, sort of. I see what you maen
04:55:09 <kallisti> Plembo: this is exactly what comparing is doing
04:55:12 <kallisti> comparing takes three arguments
04:55:13 <Plembo> but I'm not sure how to go about fixing i
04:55:14 <Plembo> it*
04:55:18 <mm_freak_> that's also reflected in this rule for function types:  a -> b -> c = a -> (b -> c)
04:55:18 <kallisti> a function and two values to compare.
04:55:23 <srhb> :t (+)
04:55:24 <lambdabot> forall a. (Num a) => a -> a -> a
04:55:25 <nand`> Plembo: which book are you reading, incidentally?
04:55:26 <srhb> :t (+1)
04:55:27 <lambdabot> forall a. (Num a) => a -> a
04:55:39 <kallisti> > comparing abs (-5) 4
04:55:40 <lambdabot>   GT
04:55:45 <Plembo> Haskell: The Craft of Functional Programming
04:55:49 <mm_freak_> Plembo: now start from bottom to top‚Ä¶  maximumBy takes a binary function
04:55:58 <mm_freak_> (a -> a -> Ordering) -> [a] -> a
04:56:02 <nand`> Plembo: I'd recommend http://learnyouahaskell.com/
04:56:45 <Plembo> kallisti, the stumbling point for me is understanding how I can use a function like that to compare all values in my list
04:56:55 <kallisti> Plembo: which function
04:57:01 <mm_freak_> then review comparing:  comparing :: Ord b => (a -> b) -> a -> a -> Ordering
04:57:03 <kallisti> parsepath?
04:57:09 <Plembo> Well, I use parsepath to parse out a single path
04:57:14 <kallisti> yes
04:57:17 <Plembo> but I want to find the greatest value of all the paths I have
04:57:21 <mm_freak_> can you add a pair of parentheses to make this function fit the maximumBy signature?
04:57:21 <Plembo> which can be in excess of 100
04:57:21 <kallisti> indeed
04:57:46 <mm_freak_> right now it takes three arguments, but what if you pass only one?
04:57:47 <kallisti> Plembo: maximumBy finds the maximum by using a comparison function on only /two/ elements at a time.
04:57:54 <kallisti> Plembo: so the fact that parsepath only deals with one is not an issue.
04:58:20 <mm_freak_> parsepath is just the function that gives the quantity to be compared
04:58:29 <mm_freak_> otherwise it's just like the regular maximum function
04:58:46 <mm_freak_> > maximumBy (comparing sin) [0..10]
04:58:47 <lambdabot>   8.0
04:58:52 <mm_freak_> 8 has the largest sine#
04:58:55 <Plembo> ohh
04:58:57 <Plembo> okay, I think I see what you mean
04:59:25 <Plembo> maximumBy (comparing parsepath) allpaths
04:59:29 <Plembo> I know I don't pass the gameboard in that line
04:59:33 <Plembo> but am I going in the right direction?
04:59:37 <kallisti> almost
04:59:42 <kallisti> but you do need to pass the gameboard
04:59:42 <ksion> > maximumBy (comparing (1/)) [2, 0.3, 1000, 0.001]
04:59:43 <lambdabot>   1.0e-3
04:59:48 <kallisti> you want to compare all of the paths against the same board
04:59:54 <kallisti> so the function you pass to comparing
04:59:58 <kallisti> should have the type
05:00:02 <kallisti> Path -> Int
05:00:27 <Plembo> Now, just to be suret hat I understand, am I unable to pass another parameter to parsepath in thsi form
05:00:28 <Plembo> maximumBy (comparing parsepath) allpaths
05:00:36 <Plembo> so is there no way I could keep the existing function definitio, and pass the game board in as well?
05:00:37 <Plembo> or
05:00:37 <kallisti> Plembo: no you can
05:00:40 <Plembo> oh, okay
05:00:53 <kallisti> (parsepath board) is a function that takes a path and returns an integer
05:01:18 <Plembo> maximumBy (comparing (parsepath board)) allpaths
05:01:21 <Plembo> I'm assuming that isn't correct
05:01:22 <Plembo> is it?
05:01:26 <kallisti> nope that's it.
05:01:36 <Plembo> Huh. Well, I can't say I understand it, but I'll gvie it a try now and see if I can trace it
05:01:51 <kallisti> Plembo: do you know which part you're stumbling on? is it the idea of currying?
05:02:10 <Plembo> kallisti, it's tough to say. Truth be told, I feel like a bit of a dolt because most of your explanations are flying right over my head.
05:02:18 <kallisti> ah, okay.
05:02:19 <Plembo> I thin kit's just the general paradigm that is tough for me to grasp so far
05:02:31 <kallisti> well, the main thing to understand is currying, first.
05:02:43 <kallisti> > replicate 3 1
05:02:43 <lambdabot>   [1,1,1]
05:02:50 <kallisti> :t replicate
05:02:50 <lambdabot> forall a. Int -> a -> [a]
05:02:55 <kallisti> Plembo: can you read this type?
05:03:00 <Plembo> kallisti, I can
05:03:12 <Taneb> :t replicate 3
05:03:13 <lambdabot> forall a. a -> [a]
05:03:18 <kallisti> good. okay, so replicate takes an integer, and a value, and constructs a list of values that has the length of the integer
05:03:24 <kallisti> now
05:03:43 <kallisti> if you just write "replicate 3", you've partially applied the function. this new function has the type a -> [a]
05:03:48 <kallisti> the type of replicate is actually:
05:03:54 <kallisti> Int -> (a -> [a])
05:04:54 <Plembo> kallisti, sorry, just to backtrack for a second
05:04:58 <Plembo> Here's what I'm trying to do so far
05:05:00 <Plembo> maximumBy (comparing (parsepath [[5, 4, 3, 1], [10, 2, 1, 0], [0, 1, 2, 0], [2, 3, 4, 20]])) allpaths
05:05:08 <Plembo> it's complaining that comparing and maximumBy are not in scope, firstly
05:05:10 <Plembo> is that an import issue?
05:05:15 <kallisti> yes you want
05:05:17 <kallisti> @hoogle comparing
05:05:17 <lambdabot> Data.Ord comparing :: Ord a => (b -> a) -> b -> b -> Ordering
05:05:22 <kallisti> import Data.Ord
05:05:23 <kallisti> and
05:05:26 <kallisti> import Data.List
05:06:20 <kallisti> Plembo: are you familiar with map?
05:06:36 <kallisti> I guess I should wait and make sure you've at least somewhat understood the above....
05:06:42 <Plembo> kallisti, I'm familiar with what maps are generally in other languages, but not in Haskell
05:06:53 <kallisti> > map f [1,2,3,4,5] :: [Expr]
05:06:54 <lambdabot>   [f 1,f 2,f 3,f 4,f 5]
05:07:01 <Plembo> oh, okay, that makes sense
05:07:11 <kallisti> > map abs [1,2,3,-5,-6,-7]
05:07:12 <lambdabot>   [1,2,3,5,6,7]
05:07:24 <kallisti> very useful function.
05:07:25 <Plembo> so it's applying a function to a list
05:07:27 <Plembo> and then returning a new list
05:07:31 <Plembo> with that function applied to each element?
05:07:31 <kallisti> yes
05:07:33 <kallisti> :t map
05:07:34 <lambdabot> forall a b. (a -> b) -> [a] -> [b]
05:07:40 <Plembo> So in the context of what I'm trying to do
05:07:48 <Plembo> I want to map parsepath to every path
05:07:54 <Plembo> and then find the maximum from the resulting list?
05:07:55 <Plembo> or am I mistkaen
05:08:00 <kallisti> correct.
05:08:03 <kallisti> but that's not what I was getting at.
05:08:07 <Plembo> oh, sorry, go on
05:08:08 <kallisti> I'm just trying to explain partial application
05:08:12 <kallisti> in a different context
05:08:14 <kallisti> okay so, replicate
05:08:17 <kallisti> > replicate 3 'a'
05:08:18 <lambdabot>   "aaa"
05:08:31 <kallisti> do you understand that?
05:08:36 <Plembo> I don't, no :(
05:08:39 <Plembo> What is replicate doing?
05:08:54 <Plembo> I mean, I see that th eresult is three as
05:08:55 <kallisti> it's repeating the value 'a' 3 times
05:08:57 <Plembo> oh
05:09:03 <Plembo> alright, that makes sense, yes
05:09:04 <kallisti> > replicate 3 "hello"
05:09:05 <lambdabot>   ["hello","hello","hello"]
05:09:05 <Plembo> :t replicate
05:09:06 <lambdabot> forall a. Int -> a -> [a]
05:09:15 <Plembo> perfect, understood
05:09:18 <kallisti> okay so.... now...
05:09:42 <kallisti> > map (replicate 3) [300,400,500]
05:09:43 <lambdabot>   [[300,300,300],[400,400,400],[500,500,500]]
05:09:57 <Plembo> so in that case
05:10:00 <kallisti> here I've partially applied replicate.
05:10:04 <hpaste> explode pasted ‚Äúnand`‚Äù at http://hpaste.org/63463
05:10:08 <kallisti> note that replicate actually has the type:
05:10:12 <kallisti> Int -> (a -> [a])
05:10:14 <Plembo> Oh, I see
05:10:15 <nand`> Can my paste be shortened or optimized?
05:10:16 <Plembo> So you've done replicate 3
05:10:20 <Plembo> and it does it to each element of the list?
05:10:23 <kallisti> meaning that if you apply an integer to replicate
05:10:26 <kallisti> then it produces a function a -> [a]
05:10:33 <kallisti> Plembo: yes
05:10:43 <nand`> oh sorry, line 4, should be [a]
05:10:48 <nand`> on the right hand side
05:11:20 <kallisti> Plembo: you can actually think of a multi-argument function as a single-argument function that returns another function.
05:11:39 <kallisti> the new function takes the next argument, which then produces a function that accepts the next argument, and so on
05:11:43 <kallisti> until there are no more arguments.
05:11:46 <hpaste> nand` annotated ‚Äúnand`‚Äù with ‚Äúexplode (annotation)‚Äù at http://hpaste.org/63463#a63464
05:12:07 <nand`> bah, still not right
05:12:11 <Plembo> I'm trying to figure out how to apply the approach you took to the path summing line I'm working on
05:12:12 <Plembo> hmm
05:12:21 <kallisti> so (replicate 3) is a function that takes a value and creates a list that repeats that value 3 times.
05:12:21 <Plembo> so I want the maximum of the resulting array
05:12:24 <Plembo> so I assume I want
05:12:25 <Plembo> maximumBy
05:12:32 <Plembo> the value that maxiumBy operates on should be an array of all of the sums
05:12:35 <Plembo> well
05:12:40 <Plembo> the result of parsing all the paths, rather
05:12:55 <Plembo> so maximumBy wants to find the maximum of applying the parsepath function to every path entry I have in my allpaths list
05:13:00 <kallisti> you want the maximal path, right?
05:13:02 <kallisti> not its sum
05:13:08 <kallisti> you want to compare /by/ the sum, but return the path, yes?
05:13:11 <Plembo> Right, I want the path itself, but I want to compare it on the basis of sum
05:13:12 <Plembo> Correct
05:13:23 <kallisti> so you want to pass maximumBy the list of paths
05:13:26 <kallisti> because you're comparing all of those paths
05:13:40 <kallisti> and then comparison function should take the sums of those paths, and compare those.
05:14:01 <kallisti> > maximumBy (comparing sum) [[1,2,3], [4,5,6], [7,8,9]]
05:14:02 <lambdabot>   [7,8,9]
05:14:04 <kallisti> as an example
05:14:08 <kallisti> you want to compare each of the lists
05:14:13 <kallisti> but you wanted to compare them by their sums
05:14:16 <kallisti> this is what maximumBy is for.
05:14:38 <kallisti> comparing is just a convenience function to produce the kind of function that maximumBy wants.
05:14:45 <zzo38> I wrote a Template Haskell quotation that won't compile unless the UndecidableInstances extension is enabled, although that extension is not needed in the module which imports this code.
05:14:46 <Plembo> I assume I'm not there yet, but is this any closer?
05:14:46 <Plembo> maximumBy(  comparing (parsepath [[5, 4, 3, 1], [10, 2, 1, 0], [0, 1, 2, 0], [2, 3, 4, 20]]) allpaths)
05:15:26 <donri> zzo38: is it needed by the code generated by your quotation?
05:15:32 <zzo38> When will they fix it so that it won't complain about these kind of errors in Template Haskell quotations?
05:15:35 <zzo38> donri: No.
05:15:37 <kallisti> Plembo: yes you have the right idea but you're confused about precedence.
05:15:46 <zzo38> So it is not even complaining correctly.
05:15:52 <kallisti> maximumBy comparisonFunction list
05:16:20 <kallisti> Plembo: currently you've only supplied maximumBy one argument
05:16:35 <Plembo> maximumBy  parsepath [[5, 4, 3, 1], [10, 2, 1, 0], [0, 1, 2, 0], [2, 3, 4, 20]]) allpaths
05:16:47 <Plembo> er, got an errant bracket at the end there
05:16:47 <kallisti> now you've given it three arguments
05:16:53 <kallisti> also a parse error on the ')'
05:16:55 <kallisti> yes
05:17:02 <statusfa1led> Is it possible to traverse a tree in such an order that it's possible to recreate the tree from just those elements listed?
05:17:04 <Plembo> maximumBy  (parsepath [[5, 4, 3, 1], [10, 2, 1, 0], [0, 1, 2, 0], [2, 3, 4, 20]]) allpaths
05:17:06 <statusfa1led> in linear time*
05:17:08 <Plembo> Is that correct?
05:17:11 <kallisti> perhaps you should name your list something like "board"
05:17:13 <kallisti> to make things easier.
05:17:16 <Plembo> alright, one moment
05:17:21 <kallisti> statusfa1led: that's the right idea but the wrong function
05:17:32 <kallisti> (parsePath board) takes a path and returns an integer
05:17:35 <kallisti> :t maximumBy
05:17:35 <lambdabot> forall a. (a -> a -> Ordering) -> [a] -> a
05:17:42 <kallisti> but maximumBy wants a comparison function.
05:17:45 <statusfa1led> actually that was unrelated to whatever was going on before :p
05:17:49 <statusfa1led> I just wanted to know :D
05:17:56 <Plembo> oh
05:17:59 <Plembo> that makes sense
05:17:59 <Plembo> so
05:18:14 <Plembo> alright, I think I get the gist of what you're saying now, let me see if I can sort this out
05:18:18 <kallisti> :t comparing
05:18:19 <lambdabot> forall b a. (Ord a) => (b -> a) -> b -> b -> Ordering
05:18:24 <statusfa1led> kallisti: unless I completely misunderstood you
05:18:27 <Plembo> maximumBy  (comparing parsepath board) allpaths
05:18:36 <kallisti> almost
05:18:41 <Plembo> :t maximumBy
05:18:41 <kallisti> you've given comparing too many arguments
05:18:42 <lambdabot> forall a. (a -> a -> Ordering) -> [a] -> a
05:18:51 <Plembo> maximumBy (comparing (parsepath board)) allpaths
05:18:55 <kallisti> yep
05:19:04 <Plembo> hah, awesome, thank you!
05:19:08 <Plembo> Now let me see if I can make this work in my code
05:19:17 <kallisti> yes it helps once you understand currying
05:19:19 <kallisti> to look at the types
05:19:49 <kallisti> comparing (parsepath board) :: Path -> Path -> Ordering
05:20:01 <Plembo> when I try to run it, I get this error: http://pastie.org/pastes/3361026/text?key=dg9oiwwyiz9i6n5zwzktxw
05:20:07 <Plembo> oh
05:20:07 <Plembo> whoops
05:20:12 <Plembo> that's my function declaration
05:20:20 <kallisti> yeah wrong integer type.
05:21:20 <kallisti> Plembo: do you understand how maximumBy and comparing both work?
05:21:36 <kallisti> > sortBy (comparing abs) [-5,-6,-4,-3,-5,2,4,6,2,5]
05:21:37 <lambdabot>   [2,2,-3,-4,4,-5,-5,5,-6,6]
05:21:54 <Plembo> Certainly better than I did before. But all of the mapping stuff so far is still a bit foggy
05:21:57 <Plembo> I think I'll get better with time
05:22:02 <kallisti> yes
05:22:06 <Plembo> For some reason it's saying that
05:22:07 <Plembo> it epxects
05:22:07 <kallisti> this is what makes Haskell so concise.
05:22:08 <Plembo> [[Int]]
05:22:12 <Plembo> but I'm passing it [[Integer]]
05:22:20 <Plembo> I can't figure out where that error is coming from
05:22:24 <kallisti> can I see the full source?
05:22:28 <Plembo> sure, one moment
05:22:39 <kallisti> it probably means you've declared something Int and something else Integer
05:22:42 <Plembo> http://pastie.org/private/dg9oiwwyiz9i6n5zwzktxw
05:23:20 <kallisti> :t sum
05:23:21 <lambdabot> forall a. (Num a) => [a] -> a
05:23:37 <Plembo> ahh, so I want to change
05:23:38 <Plembo> let's see
05:24:12 <kallisti> oh
05:24:18 <kallisti> er, nevermind
05:24:38 <kallisti> where is your maximumBy code?
05:24:44 <Plembo> I was just pasting it in ghci
05:24:47 <Plembo> I'll add it write into the script, sec
05:25:06 <Plembo> updated the link
05:25:13 <kallisti> oh btw
05:25:17 <kallisti> :t find
05:25:18 <lambdabot> forall a. (a -> Bool) -> [a] -> Maybe a
05:25:34 <kallisti> > find (==0) [1,2,3,4,5,6,2,3,4,0,3,4,1]
05:25:35 <lambdabot>   Just 0
05:25:49 <kallisti> oh wait
05:26:01 <kallisti> wait what is findelement trying to do.
05:26:10 <Plembo> I don't actually need that function anymore
05:26:14 <kallisti> right
05:26:19 <Plembo> I needed it before you told me about mapping
05:26:39 <kallisti> also (!!)
05:26:46 <kallisti> > [1,2,3,4,5] !! 3
05:26:47 <lambdabot>   4
05:27:51 <Plembo> My pastie has been updated:
05:27:51 <Plembo> http://pastie.org/pastes/3361026/text?key=dg9oiwwyiz9i6n5zwzktxw
05:28:03 <Plembo> It's still flagging an error when I run maximumBy (comparing (parsepath board)) allpaths
05:28:14 <kallisti> oh the problem is that allpaths isn't [Int]
05:28:18 <kallisti> it's [[Int]]
05:28:20 <kallisti> I think
05:29:11 <Plembo> updated the paste again
05:29:20 <Plembo> it's still complaining about the expected vs inferred type though
05:29:23 <Plembo> hmm
05:30:30 <kallisti> Plembo: er... wait
05:30:31 <kallisti> no
05:30:32 <kallisti> lol
05:30:48 <kallisti> I don't know why I'm so confused right now.
05:31:36 <kallisti> oh I see
05:31:39 <kallisti> do
05:31:43 <kallisti> board :: [[Int]]
05:31:52 <zzo38> I have two questions about this program:   http://sprunge.us/LPeK   [1] How can I make a ancestry constraint?   [2] How can I make the ExtNode constructor assert that p and c are different types?
05:31:53 <kallisti> monomorphism restriction strikes again, I believe.
05:32:36 <Plembo> here's an updated pastie
05:32:36 <Plembo> http://pastie.org/private/dg9oiwwyiz9i6n5zwzktxw
05:32:54 <kallisti> Plembo: give all of your variables explicit type signatures
05:32:56 <kallisti> and that will fix it.
05:32:57 <Plembo> but it's still complaining with : http://pastie.org/pastes/3361074/text
05:33:00 <Plembo> alright
05:33:02 <Plembo> one moment
05:33:48 <Plembo> hmm
05:34:03 <Plembo> Do you mean I should do something like
05:34:08 <Plembo> type board = [[Int]]
05:34:11 <kallisti> all /top level/ variables
05:34:12 <Plembo> or did you mean something else
05:34:17 <kallisti> board :: [[Int]]
05:34:21 <kallisti> allpaths :: [[Int]]
05:34:43 <Plembo> !
05:34:44 <Plembo> victory
05:34:48 <Plembo> Thank you!
05:34:54 <kallisti> in Haskell, integer literals are overloaded. so that "1" can refer to an arbitrary numeric type.
05:34:54 <Plembo> Not quite done yet, but this is awesome
05:34:59 <Plembo> ahh, okay
05:35:48 <Plembo> Now, at the moment it's returning the best path properly
05:35:52 <kallisti> however, there's a strange thing called the monomorphism restriction, which infers a monomorphic type for top-level function definitions if no type is specified.
05:35:53 <Plembo> but is there any way I can also make it return the sum of the best path as well?
05:35:58 <Plembo> so right now it's doing
05:36:04 <Plembo> *Mylist> maximumBy (comparing (parsepath board)) allpaths
05:36:05 <Plembo> [0,0,1,0]
05:36:06 <kallisti> for numeric literals, this defaults to the Integer type.
05:36:12 <Plembo> I'd want to return [[0, 0, 1, 0], 230]
05:36:20 <kallisti> that's impossible.
05:36:24 <Plembo> ah, okay
05:36:32 <kallisti> lists are homogenous
05:36:38 <zzo38> Plembo: Maybe this way work ([0, 0, 1, 0], 230)
05:36:46 <kallisti> ah so you want the list /and/ its sum.
05:37:01 <Plembo> zzo38, that works as well
05:37:03 <Plembo> kallisti, correct
05:37:12 <Plembo> Do we call (a, b, c) <-- something like that a tuple in haskell?
05:37:15 <Plembo> or is it called something else?
05:37:24 <kallisti> yes that's a 3-tuple
05:37:31 <zzo38> Plembo: Yes it is called a tuple (sometimes it is called a product type)
05:37:34 <kallisti> :t ('a', True)
05:37:35 <lambdabot> (Char, Bool)
05:37:39 <Plembo> okay, if I wanted to return a 2-tuple with (bestpath, array)
05:37:44 <Plembo> I guess I could just wrap my comparing call?
05:37:49 <Plembo> something like
05:38:02 <kallisti> Plembo: it kind of complicates your function a little bit, I must say.
05:38:20 <Plembo> Actually, before I go in that direction
05:38:22 <Plembo> I did have one other question
05:38:32 <Plembo> Right now my allpaths line gives me all possible paths for a 4x4 board
05:38:39 <kallisti> what you want to do is go ahead and construct a list of (Path, Int)
05:38:42 <Plembo> Is there any way to figure out how wide a board is, and then base the possible paths on that?
05:38:53 <Plembo> So if I pass it a 8x8 board
05:38:57 <Plembo> it'll generate all paths for a 8x8 board
05:39:01 <Plembo> here's my current allpaths function
05:39:05 <Plembo> allpaths = [[a, b, c, d] | a <- [0..3], b <- [0..3], c <- [0..3], d <- [0..3], abs (b-a) <= 1, abs (c-b) <= 1, abs (d-c) <= 1]
05:39:09 <res_> annoying thing about programming languages: when I'm using one, I always wish I were using a different one.
05:39:30 <btvl> is that something that's standard in haskell, or are those operators yesod specific ? http://hpaste.org/63465  (it seems <*> and <$> are from Control.Applicative, not sure about the .:? and .: )
05:39:34 <zzo38> res_: That is why there is many programming languages.
05:39:54 <rekado> has anyone had any success compiling haskell code for ARM?
05:39:59 <zzo38> Do you know how to answer my question?
05:40:06 <nand`> res_: that's why you use a language that can become every other language
05:40:09 <kallisti> Plembo: hrm
05:40:13 <kallisti> Plembo: yes it's possible.
05:40:20 <kallisti> you'd want to pass in the dimensions of the board.
05:40:33 <Plembo> now, that part makes sense
05:40:33 <Plembo> but
05:40:44 <Plembo> how do I go about specifying the rest of it? I mean, currently I say it needs 4 elements
05:40:45 <Plembo> a, b, c, d
05:40:49 <Plembo> and I have some restrictions about their values
05:41:13 <zzo38> nand`: There is no such thing, although some of these things are possible in Forth, some things possible in Haskell, some possible in C, and so on
05:41:13 <kallisti> > replicateM 4 [0..3]
05:41:14 <lambdabot>   [[0,0,0,0],[0,0,0,1],[0,0,0,2],[0,0,0,3],[0,0,1,0],[0,0,1,1],[0,0,1,2],[0,0...
05:41:17 <rekado> llvm's llc segfaults (3.0.1) or aborts (2011-07-12 from svn) when compiling GHC 7.4.1 generated llvm bytecode.
05:41:40 <kallisti> Plembo: hey look! a function I don't expect you to understand right now!
05:41:42 <res_> nand`: what, by writing compilers for other languages in them?
05:41:46 <nand`> zzo38: lisp zealots would have you believe otherwise
05:41:48 <Plembo> haha, ya, that's write above my head
05:41:57 <kallisti> Plembo: you could write it by hand via recursion though.
05:42:02 <kallisti> sounds fun.
05:42:02 <nand`> res_: no, by writing macros in the language itself
05:42:23 <Plembo> if I wanted to use replicateM
05:42:25 <Plembo> but I wanted to add my stipulations in
05:42:27 <Plembo> is there a way to do that?
05:42:35 <kallisti> yes
05:42:36 <kallisti> filter
05:42:48 <res_> nand`: how is that different from writing another language layer on top of your language
05:42:52 <kallisti> > filter (>3) [1,2,5,2,6,2,3,5,6,2,7,4]
05:42:53 <lambdabot>   [5,6,5,6,7,4]
05:42:59 <nand`> res_: It isn't
05:43:07 <Plembo> So
05:43:14 <zzo38> Forth allows you to do a large number of different things if programmed correctly; you can make it parse the rest of the program as a C code, for example
05:43:16 <kallisti> er wait
05:43:20 <nand`> res_: but you're still using the same language underneath :P
05:43:41 <kallisti> Plembo: okay so the stipulation is that abs of adjacent elements >= 1
05:43:42 <kallisti> ?
05:43:50 <res_> nand`: it's always the same turtles underneath
05:43:58 <Plembo> If I wanted a function where it takes one parameter, and then it returns all possible paths for a board of that dimension. The condition is that a given indice must be within 1 of the previous indice. So if indice 0 is 2, indice 1 can be 1, 2 or 3
05:43:59 <res_> you have to make the computer do what you want!
05:44:12 <kallisti> right
05:44:13 <kallisti> okay...
05:44:16 <kallisti> fun times.
05:44:34 <kallisti> I'll give you an example of how to do that condition on a single path.
05:45:25 <Plembo> kallisti, that's correct
05:45:41 <Plembo> I currently do it for a fixed number of elements, so I can just do: abs (c-b) <= 1
05:45:45 <Plembo> oh, sorry
05:45:49 <Plembo> the abs must be <= 1, not >= 1
05:46:12 <Plembo> so [0, 1, 2, 1] is valid, but [0, 2, 0, 4] isn't
05:46:49 <kallisti> > let path = [1,2,4,3] in all (<=1) (zipWith (abs `on` subtract) path (tail path))
05:46:50 <lambdabot>   Occurs check: cannot construct the infinite type: b = b -> c
05:47:31 <kallisti> > let path = [1,2,4,3] in all (<=1) (zipWith (subtract `on` abs) path (tail path))
05:47:32 <lambdabot>   False
05:47:36 * edwardk waves hello.
05:47:39 <kallisti> .....ooookay.
05:47:49 <kallisti> Plembo: it's time for a crash course on list functions.
05:48:05 <kallisti> okay, so you know zipWith, and you know abs, yes?
05:48:09 <Plembo> correct
05:48:14 <kallisti> > subtract 3 4
05:48:15 <lambdabot>   1
05:48:21 <kallisti> you can read that as "subtract 3 from 4"
05:48:31 <Plembo> alright, makes sense so far
05:48:37 <kallisti> okay, now, on
05:48:50 <kallisti> is a higher-order function. it takes a two-argument function and a single argument function
05:49:12 <kallisti> > ((==) `on` abs) (-5) 5
05:49:13 <lambdabot>   True
05:49:20 <kallisti> @src on
05:49:20 <lambdabot> (*) `on` f = \x y -> f x * f y
05:49:36 <kallisti> okay so
05:49:40 <Plembo> alright, that makes sense too
05:49:40 <kallisti> the code above is equivalent to
05:49:46 <kallisti> > abs (-5) == 5
05:49:47 <lambdabot>   True
05:50:13 <kallisti> so ((==) `on` abs) produces the function (\x y -> abs x == abs y)
05:50:22 <kallisti> it's basically a convenient shorthand function
05:50:41 <Plembo> understood, okay
05:50:47 <kallisti> :t all
05:50:48 <lambdabot> forall a. (a -> Bool) -> [a] -> Bool
05:51:06 <kallisti> all takes a conditional and a list, and enforces that every element of the list satisfies that condition
05:51:20 <kallisti> any is the logical-or version.
05:51:34 <kallisti> > all (==2) [2,2,2,2,2,2,2,2,2,2,2]
05:51:35 <lambdabot>   True
05:51:38 <kallisti> > all (==2) [2,2,2,2,2,2,2,2,2,2,3]
05:51:39 <lambdabot>   False
05:51:51 <Plembo> so I assume if you replaced all with any there
05:51:53 <Plembo> both would be true?
05:52:03 <kallisti> both what?
05:52:09 <Plembo> both of those statements
05:52:12 <Plembo> any (==2) ...
05:52:17 <kallisti> oh, yes.
05:52:23 <Plembo> perfect, alright, makes sense
05:52:36 <kallisti> okay so....
05:52:49 <kallisti> zipWith (subtract `on` abs) path (tail path)
05:52:53 <kallisti> do you see what is happening here?
05:53:22 <kallisti> > let path = [1,2,3] in zip path (tail path)
05:53:23 <lambdabot>   [(1,2),(2,3)]
05:53:29 <kallisti> > let path = [1,2,3,4,5,6] in zip path (tail path)
05:53:29 <lambdabot>   [(1,2),(2,3),(3,4),(4,5),(5,6)]
05:53:57 <Plembo> Is it making tuples out of it, so 12, 23, 34, 45?
05:54:08 <kallisti> Plembo: well, zip does
05:54:10 <kallisti> zipWith does not
05:54:13 <kallisti> zip = zipWith (,)
05:54:30 <kallisti> I'm just using zip to demonstrate how the elements are combined together
05:54:34 <Plembo> ahh, understood, okay
05:54:35 <kallisti> it's taking consecutive elements
05:54:42 <kallisti> and applying them to (subtract `on` abs)
05:55:13 <kallisti> > zipWith (subtract `on` abs) [1,2,1,2]
05:55:14 <lambdabot>   Overlapping instances for GHC.Show.Show ([a] -> [a])
05:55:14 <lambdabot>    arising from a use ...
05:55:21 <kallisti> oh right
05:55:31 <kallisti> > let path = [1,2,1,2] in zipWith (subtract `on` abs) path (tail path)
05:55:32 <lambdabot>   [1,-1,1]
05:55:43 <kallisti> ...oh
05:55:48 <kallisti> lol
05:55:51 <kallisti> wrong function. you don't want on
05:56:33 <kallisti> > let path = [1,2,1,2] in zipWith (\a b -> abs (b - a)) path (tail path)
05:56:34 <lambdabot>   [1,1,1]
05:56:53 <kallisti> on is incorrect because it applies the abs before applying the subtraction.
05:57:03 <kallisti> you want to apply the subtraction before taking the abs
05:57:22 <kallisti> Plembo: ...first of all, I should ask, do you know what a lambda is?
05:57:34 <kallisti> that's what (\a b -> abs (b - a)) is
05:57:35 <Plembo> I've seenit before, but I don't really know what it is, no
05:57:43 <kallisti> it defines a function
05:57:46 <kallisti> and returns that function as a value.
05:58:04 <kallisti> f = (\a b -> abs (b - a))
05:58:06 <kallisti> is equivalent to
05:58:13 <kallisti> f a b = abs (b - a)
05:58:34 <kallisti> the difference is that I can write the lambda anywhere an expression is valid.
05:58:41 <kallisti> > map (\x -> x + 1) [1..10]
05:58:42 <lambdabot>   [2,3,4,5,6,7,8,9,10,11]
05:58:42 <Plembo> understood, okay, that makes sense
05:59:10 <kallisti> so then
05:59:12 <kallisti> in
05:59:20 <res_> there's also some optimization weirdness that happens because of the difference between lambdas and named functions
05:59:30 <kallisti> zipWith (\a b -> abs (b - a)) path (tail path)
05:59:56 <kallisti> in my lambda function, a refers to an element in the list, and b refers to the next element
05:59:59 <kallisti> a and b are consecutive
06:00:04 <Plembo> alright
06:00:17 <kallisti> so the end result is this list of absolute differences.
06:00:20 <kallisti> which I then pass to all
06:00:29 <kallisti> to test that they're all <= 1
06:01:07 <kallisti> Plembo: ...I'm not sure if writing the code and then telling you what it does is the correct teaching method here. :P
06:01:22 <Plembo> kallisti, I'm trying my best to follow, but there are some parts I'm stumbling on
06:01:34 <Plembo> I guess it might make more sense once we get to the point where we construct the possible paths
06:01:53 <kallisti> Plembo: yes, just think of "path" as "any possible path"
06:01:57 <kallisti> in the above code
06:02:12 <Plembo> understood, okay
06:02:22 <ovechkin> i have a list of Fractionals and i want to see how many elements of this list it takes to equal some number x. what is a concise way to do this? i can see how to do this with recursion. but is there something better?
06:02:46 <ovechkin> i want to start summing from the first element
06:02:54 <kallisti> ovechkin: do you want to process the elements sequentially, or in any possible order?
06:03:02 <ovechkin> kallisti: sequentially
06:03:14 <yezariaely> TacticalGrace: available?
06:03:18 <kallisti> ovechkin: can the list ever be empty?
06:03:23 <ovechkin> no
06:03:36 <kallisti> > scanl1 (+) [1,2,3]
06:03:37 <lambdabot>   [1,3,6]
06:04:26 <kallisti> > length . takeWhile (<3) . scanl1 (+) $ [1,2,3]
06:04:28 <lambdabot>   1
06:04:31 <kallisti> er
06:04:56 <Plembo> kallisti, is the function that we could create substantially different from allpaths = [[a, b, c, d] | a <- [0..3], b <- [0..3], c <- [0..3], d <- [0..3], abs (b-a) <= 1, abs (c-b) <= 1, abs (d-c) <= 1] if we want ot permit a variable sized board?
06:04:59 <tech2> kallisti: that would be the list [1]
06:05:05 <Plembo> so it can get all possible paths for a 2x2 board, or a 100x100 board?
06:05:47 <kallisti> > length . takeWhile (<=6) . scanl1 (+) $ [1,2,3,4,5,6]
06:05:49 <lambdabot>   3
06:06:08 <ovechkin> oh wow
06:06:25 <kallisti> tada. :P
06:06:38 <ovechkin> thanks
06:06:46 <kallisti> ovechkin: MAKE SURE YOU UNDERSTAND IT. :P
06:07:14 * hackagebot Paraiso 0.2.0.3 - a code generator for partial differential equations solvers.  http://hackage.haskell.org/package/Paraiso-0.2.0.3 (TakayukiMuranushi)
06:07:26 <kallisti> Plembo: it will /look/ substantially different
06:07:31 <kallisti> but will basically just be a generalization of that.
06:07:35 <yezariaely> when I install accelerate using cabal install accelerate, the configure process of the cuda package (dependancy) always complains, that it does not find the cuda library. However, it is installed properly and LD_LIBRARY_PATH is set accordingly as is PATH
06:07:43 <yezariaely> anyone can help me with that?
06:07:58 <Plembo> kallisti, would it be possible to see how it would look, and I can see if I can break it down from there and understand each part?
06:08:09 <Plembo> I get the general idea of how this map stuff is supposed to work
06:08:20 <Plembo> but I'm still missing the logical leap to this situation
06:08:36 <kallisti> I'm guessing the "map stuff" is my zipWith code above?
06:08:45 <Plembo> right
06:08:50 <kallisti> Plembo: well the most concise way to generate all of the paths is  allpaths x y = replicateM y [0..x-1]
06:08:58 <kallisti> but that doesn't really explain much....
06:09:47 <kallisti> replicateM is in Control.Monad, btw
06:10:02 <kallisti> @src replicateM
06:10:02 <lambdabot> replicateM n x = sequence (replicate n x)
06:10:18 <kallisti> the magic here lies in the sequence function
06:10:23 <kallisti> :t sequence
06:10:24 <lambdabot> forall (m :: * -> *) a. (Monad m) => [m a] -> m [a]
06:11:01 <kallisti> Plembo: here's a good example of how sequence works...
06:11:23 <kallisti> let's say you have a telephone number, and you want to deterine all of the possible character sequence that the phone number represents.
06:11:47 <kallisti> so for example
06:11:56 <kallisti> the number "9" can be W X Y Z or 9
06:12:10 <kallisti> 0 is just 0, 1 is just 1, 2 is A B C or 2
06:12:13 <kallisti> ...make sense?
06:12:45 <Plembo> Yep, I'm with you so far
06:12:54 <kallisti> okay so we have a table.
06:13:01 <kallisti> table = [('0',"0"),('1',"1"),('2',"ABC2"),('3',"DEF3"),('4',"GHI4"),('5',"JKL5"),('6',"MNO6"),('7',"PQRS7"),('8',"TUV8"),('9',"WXYZ9")]
06:13:11 <kallisti> that maps the telephone numbers to their possible character representations
06:13:25 <kallisti> for the purposes of this example the code to look up the number in the table is irrelevant.
06:13:30 <Taneb> Ooh, I know what happens next
06:13:30 <kallisti> we'll just call it lookup
06:13:41 <kallisti> lookup table '9'
06:13:47 <kallisti> will return "WXYZ9"
06:13:59 <kallisti> again, for the purposes of this example, I'm ignoring the possibility that the table doesn't have the key we're looking for.
06:14:06 <Plembo> right
06:14:06 <Plembo> okay
06:14:08 <Plembo> that makes sense as well
06:15:03 <kallisti> when you use sequence on a list of lists, it treats the inner lists as a list of possibilities for what the first element is. the second inner list is a list of possibilities for what the second element is, and so.
06:15:17 <kallisti> s/the inner lists/the first inner list/
06:15:21 <kallisti> so for example.
06:15:24 <kallisti> let's say we do:
06:15:31 <kallisti> map (lookup table) "911"
06:15:46 <kallisti> which gives us ["WXYZ9", "1", "1"]
06:16:05 <kallisti> this represents the possible values that 9 represents, the possible values of 1, and the possible values of 1
06:16:08 <kallisti> in order.
06:16:18 <kallisti> > sequence ["WXYZ9", "1", "1"]
06:16:19 <lambdabot>   ["W11","X11","Y11","Z11","911"]
06:16:32 <Plembo> Understood, okay, that makes sense
06:16:48 <kallisti> let's say instead of 911 we have like.... 922
06:17:08 <kallisti> map (lookup table) "922"  would give us  ["WXYZ9", "ABC2", "ABC2"]
06:17:18 <kallisti> > sequence ["WXYZ9", "ABC2", "ABC2"]
06:17:19 <lambdabot>   ["WAA","WAB","WAC","WA2","WBA","WBB","WBC","WB2","WCA","WCB","WCC","WC2","W...
06:17:25 <kallisti> boom. combinatorial explosion.
06:17:42 <Plembo> Alright, I'm with you so far
06:17:47 <kallisti> ALRIGHTY
06:17:50 <Plembo> I can even faintly see how that could be used with my example
06:17:53 <kallisti> so now.
06:18:04 <kallisti> let's say there's no distinctions between successive elements.
06:18:47 <kallisti> we just want to say, list the possibilities of a 4x4 of integers/
06:18:58 <kallisti> in that case all of our elements that we pass to sequence would be the same
06:19:18 <kallisti> > sequence [[0..3], [0..3], [0..3], [0..3]]
06:19:19 <lambdabot>   [[0,0,0,0],[0,0,0,1],[0,0,0,2],[0,0,0,3],[0,0,1,0],[0,0,1,1],[0,0,1,2],[0,0...
06:19:30 <Plembo> makes sense, okay
06:19:38 <kallisti> so let's look back at the source of replicateM
06:19:41 <kallisti> @src replicateM
06:19:42 <lambdabot> replicateM n x = sequence (replicate n x)
06:19:51 <kallisti> if we plug in
06:19:55 <kallisti> replicateM 4 [0..3]
06:19:57 <kallisti> we get
06:20:04 <kallisti> sequence (replicate n [0..3])
06:20:10 <kallisti> which is
06:20:18 <kallisti> sequence [[0..3], [0..3], [0..3], [0..3]]
06:20:25 <dougransom> @pl f x y = f (x y)
06:20:25 <lambdabot> f = fix (.)
06:20:30 <Plembo> ahh, very crafty
06:20:31 <Plembo> I like that
06:20:40 <Plembo> so now we have a way of getting all possible path, including ones that are invalid
06:20:42 <Plembo> wlel
06:20:45 <kallisti> yep
06:20:48 <kallisti> and then we just apply a filter to those paths
06:20:55 <kallisti> we take out the ones we don't want.
06:21:10 <kallisti> rather than mucking up our definition of all possible paths with all of these conditions
06:21:15 <Plembo> with replicate
06:21:16 <Plembo> wouldn't it be
06:21:21 <Plembo> replicate n [0..n]?
06:21:35 <Plembo> so we can handle a 8x8 board?
06:21:36 <Plembo> err
06:21:40 <Plembo> a NxN board
06:21:44 <kallisti> no it would be [0..(n-1)]
06:21:48 <kallisti> if you start at 1
06:21:50 <kallisti> it would be [1..n]
06:21:52 <Plembo> oh, right
06:21:54 <Plembo> okay
06:22:10 <Plembo> Hmm, now that I'm trying to re-open ghci it keeps saying bus error
06:22:15 <kallisti> allpaths x y = replicateM y [0..(x-1)]
06:22:30 <Plembo> Mind if I reboot real quick? Not sure what's causing GHCI to not load
06:22:36 <kallisti> the y dimension defines how many elements in each sublist we want
06:22:44 <kallisti> er wait
06:22:50 <kallisti> no
06:22:57 <kallisti> the y dimension defines the total number of sublists we want
06:23:06 <kallisti> the x dimension defines the number of elements within each sublist
06:23:26 <Plembo> if my boards are square, wouldn't x and y be identical?
06:23:30 <kallisti> yep
06:23:33 <Plembo> alright
06:23:41 <kallisti> so if you always want square boards you can just use a single n argument
06:23:44 <Plembo> Do you mind if I reboot real quick so my GHCI will start working again?
06:23:47 <kallisti> not at all.
06:23:49 <Plembo> keeps asying "bus erorR" on load
06:23:52 <Plembo> awesome, thanks! I'll be right back
06:25:16 <Plembo> perfect, GHCI works again
06:25:19 <Plembo> alright, continue! :)
06:26:11 <Plembo> when I run that replicate function
06:26:12 <Plembo> say
06:26:20 <Plembo> replicateM 8 [0..7]
06:26:24 <kallisti> oh btw you'll want Control.Monad in your imports. for replicateM
06:26:27 <Plembo> it runs indefinitely
06:26:28 <Plembo> Right
06:26:35 <kallisti> indefinitely? no.
06:26:44 <Plembo> Oh, disregard, it may just take a while to complete in that case
06:26:50 <kallisti> > length $ replicateM 8 [0..7]
06:26:54 <lambdabot>   mueval-core: Time limit exceeded
06:27:06 <kallisti> Plembo: yes. a little while.
06:27:21 <kallisti> but note that Haskell is lazily evaluated.
06:27:42 <kallisti> (though since you're later calling maximumBy you'll end up exhausting every possibility to find the maximal one...)
06:28:18 <Plembo> do you think this approach is the best method to go about it?
06:28:28 <Plembo> I mean
06:28:36 <kallisti> I'm not sure what the grid represents, or the sums.
06:28:37 <Plembo> are there any other options without using Monad to do this? or no
06:28:40 <Plembo> well
06:28:58 <Plembo> The grid I'd have to evaluate in the manner I'm evaluating now. I'm wondering if there's any way to do the paths more easily
06:29:04 <Plembo> for example
06:29:13 <Plembo> allpaths = [[a, b, c, d] | a <- [0..3], b <- [0..3], c <- [0..3], d <- [0..3], abs (b-a) <= 1, abs (c-b) <= 1, abs (d-c) <= 1]
06:29:16 <Plembo> that's my current path list right now
06:29:38 <Plembo> would there be no way to allow that to take a variable for the number of elements rather than statically writing it for four?
06:29:53 <kallisti> that's essentially what replicateM does.
06:29:54 <Rc43> Hi, guys.
06:30:15 <Rc43> How can I run commands (runCommand) crossplatformly?
06:30:18 <kallisti> Plembo: are you concerned about efficiency or conciseness?
06:30:22 <kallisti> replicateM is probably  the most concise way
06:30:32 <Rc43> Or how can I get current OS?
06:30:37 <Plembo> efficiency moreso than conciseness I suppose
06:30:44 <Plembo> I guess more than anything just having a solution I might be able to understand
06:30:54 <kallisti> I doubt it's the most efficient. but it's not bad. combinatorics tends to result in slow algorithms.
06:31:06 <Plembo> well
06:31:13 <Plembo> with the replicateM approach in mind
06:31:18 <Plembo> once I do the replicate for the 8x8
06:31:24 <kallisti> Plembo: well I did kind of explain how replicateM works.
06:31:26 <Plembo> how do I go about filtering out the invalid ones
06:31:36 <kallisti> in terms of sequence, which I didn't explain I just left it as a magical black box. ;)
06:31:38 <dougransom> @pl f (g (z x))
06:31:38 <lambdabot> f (g (z x))
06:31:52 <kallisti> dougransom: f . g . z
06:32:07 <zzo38> Rc43: One way would be to use System.FilePath.pathSeparator to tell the difference between Windows and UNIX although that doesn't seem really best way to me......
06:32:11 <donri> @pl \x -> f (g (z x))
06:32:12 <lambdabot> f . g . z
06:32:22 <kallisti> Plembo: there's a handy little function called filter.
06:32:24 <kallisti> :t filter
06:32:33 <lambdabot> forall a. (a -> Bool) -> [a] -> [a]
06:32:46 <dougransom> kallisti, donri thanks - didn't know i needed the \x -> in playing with @pl.
06:33:00 <kallisti> Plembo: it takes a predicate function and a list, and returns a list such that the predicate function is true for all the resulting elements.
06:33:01 <Rc43> zzo38, it will works, yes, forgotten about it
06:33:03 <donri> otherwise it doesn't know what names are pointful
06:33:16 <kallisti> > filter (==2) [1,5,2,6,7,3,4,2,2,6,2]
06:33:17 <lambdabot>   [2,2,2,2]
06:33:21 <Plembo> so would ther ebe some way to filter
06:33:24 <Plembo> filter a, b
06:33:29 <Plembo> abs b-a <= 1
06:33:36 <Plembo> and it successively does that for each two elements?
06:33:38 <Plembo> until it gets t othe end?
06:33:40 <kallisti> Plembo: yes, with my previous code.
06:33:47 <saml> hello i am here to chat
06:33:57 <kallisti> Plembo: the all/zipWith stuff
06:34:02 <kallisti> that's your predicate function
06:34:13 <Plembo> would you be able to paste that part again? Sorry, I didn't realize that's what it was supposed to do
06:35:13 <kallisti> 09:57 < kallisti> > let path = [1,2,1,2] in zipWith (\a b -> abs (b - a)) path  (tail path)
06:35:26 <kallisti> just turn this into a function on an arbitrary path
06:35:50 <Plembo> so when I run that I get [1, 1, 1] back
06:35:58 <kallisti> oh yes
06:36:00 <kallisti> however
06:36:12 <saml> Plembo, what do you want to do?
06:36:14 <kallisti> if you apply that to all (<=1)
06:36:23 <kallisti> you get True or False
06:36:34 <saml> you want to get difference between pairs?
06:36:50 <Plembo> saml, I'm trying to get a list similar to what this results in: [[a, b, c, d] | a <- [0..3], b <- [0..3], c <- [0..3], d <- [0..3], abs (b-a) <= 1, abs (c-b) <= 1, abs (d-c) <= 1]
06:36:57 <Plembo> but I want ot be able to do it for a variable
06:37:02 <Plembo> so it can return an array that's 20 long
06:37:03 <Plembo> or 2 long
06:37:03 <Plembo> etc
06:37:06 <kallisti> on an arbitrary square dimension
06:37:11 <Plembo> right, exactly
06:37:13 * hackagebot haskell-updater 1.2.0.4 - Rebuild Haskell dependencies in Gentoo  http://hackage.haskell.org/package/haskell-updater-1.2.0.4 (SergeiTrofimovich)
06:37:20 <kallisti> > let path = [1,2,1,2] in all (<= 1) (zipWith (\a b -> abs (b - a)) path  (tail path))
06:37:22 <lambdabot>   True
06:37:26 <saml> is that valid haskell?
06:37:31 <kallisti> saml: yes
06:37:35 <kallisti> list comprehension syntax.
06:37:51 <kallisti> Plembo: do you remember how the above code works?
06:37:53 <saml> you can have arbitrary boolean filters like that?
06:37:59 <kallisti> yep
06:38:02 <dougransom> @run fix (const 9)
06:38:02 <lambdabot>   9
06:38:07 <dougransom> @run fix (const 999)
06:38:08 <lambdabot>   999
06:38:09 <Plembo> kallisti, I know how the lambda in it works
06:38:14 <Plembo> kallisti and the zipwith
06:38:22 <Plembo> but I'm not sure what the part prior to it does
06:38:27 <kallisti> oh right
06:38:30 <kallisti> I guess you've never seen let
06:38:33 <kallisti> > let x = 2 in x
06:38:34 <lambdabot>   2
06:38:36 <kallisti> > let x = 2 in x + 2
06:38:37 <lambdabot>   4
06:38:39 <kallisti> > let x = 2 in (x,x)
06:38:40 <lambdabot>   (2,2)
06:38:54 <kallisti> > let x = 2; y = 3 in x + y
06:38:55 <lambdabot>   5
06:38:57 <Plembo> oh, I see
06:38:57 <Plembo> so
06:39:03 <Plembo> all it's doing is
06:39:04 <Plembo> taking a path in
06:39:07 <kallisti> let <list of variable bindings> in <expression>
06:39:07 <Plembo> and saying if it's valid or not?
06:39:11 <kallisti> yep
06:39:17 <kallisti> sorry I guess I should have explained let earlier.
06:39:19 <Plembo> Perfect, okay. But how do we use that to discard invalid ones?
06:39:23 <kallisti> I forgot that you might not know about it.
06:39:27 <kallisti> filter
06:39:29 <kallisti> :t filter
06:39:30 <lambdabot> forall a. (a -> Bool) -> [a] -> [a]
06:39:31 <hpaste> ovechkin pasted ‚Äútype error?‚Äù at http://hpaste.org/63467
06:39:33 <saml> Plembo, if n is 2,  you want [[a,b,c] |  ..] right?
06:39:34 <kallisti> imagine that instead of using a let
06:39:37 <kallisti> you just make it a function
06:39:41 <kallisti> with an argument named "path"
06:39:44 <Plembo> right, saml
06:39:52 <kallisti> this function takes a path and returns True or False based on whether it's valid.
06:39:57 <Plembo> okay, so that function will return true if the path is valid
06:39:59 <Plembo> false if it isn't
06:40:00 <kallisti> yep
06:40:00 <Plembo> tha tpart makes sense
06:40:05 <Plembo> but I don't understand the filter part
06:40:21 <saml> abs (b-a) <= 1   is that always 1?
06:40:41 <ovechkin> kallisti: so i believe i understand what is going on in the suggestion you made. but it looks like i'm running into some sort of type issue. how do i make sense of this error? link is above
06:40:42 <kallisti> Plembo: filter applies a function to every element of a list. if it returns True, the element stays in the list, if it's false, the element is discarded.
06:40:42 <Plembo> it is, saml
06:40:50 <Plembo> oh, wow, that's neat
06:40:55 <Plembo> so I would do
06:41:20 <Plembo> filter isvalidpath pathgenerationcode?
06:41:21 <Plembo> or
06:41:32 <kallisti> filter isvalidpath (allpaths 8)
06:41:35 <kallisti> or something like that
06:41:41 <Plembo> alright, let me try that out now :) one sec
06:41:42 <kallisti> I recommend using camelcase. isValidPath, allPaths, etc.
06:41:47 <kallisti> just as a stylistic thing.
06:42:09 <kallisti> ovechkin: where's the link?
06:42:17 <kallisti> sorry can't find it. I'm blind. :P
06:42:21 <ovechkin> kallisti: http://hpaste.org/63467
06:43:04 <Plembo> kallisti, if I wanted to start breaking these functions apart
06:43:06 <Plembo> so
06:43:08 <Plembo> I'd have isValidPath
06:43:11 <Plembo> it would be
06:43:16 <ovechkin> kallisti: i just realized that i didn't show what wordCount is in that link. wordCount = sum uniqueWords
06:43:17 <Plembo> isValidPath :: [Int] -> Bool
06:43:29 <kallisti> :t scanl1
06:43:30 <lambdabot> forall a. (a -> a -> a) -> [a] -> [a]
06:46:02 <kallisti> ovechkin: hm. weird. it looks fine to me but it's a precedence thing.
06:46:11 <kallisti> I recommend getting rid of those parentheses
06:46:12 <kallisti> @src print
06:46:12 <lambdabot> print x = putStrLn (show x)
06:46:33 <kallisti> print . show . length . takeWhile (<= wordCount / 2) . scanl1 (+)
06:46:35 <kallisti> er
06:46:42 <kallisti> print . length . takeWhile (<= wordCount / 2) . scanl1 (+) $ uniqueWords
06:46:49 <kallisti> as the whole expression
06:47:32 <kallisti> Plembo: yes
06:47:36 <kallisti> you definitely want to break them apart
06:47:53 <Plembo> okay, so
06:47:56 <Plembo> for isvalidpath
06:48:03 <Plembo> is this all it needs
06:48:10 <Plembo> (zipWith (\a b -> abs (b-a)) path (tail path))
06:48:14 <Plembo> or is there more to it
06:48:16 <ovechkin> kallisti: that fixed it
06:48:22 <kallisti> Plembo: you forgot the all part.
06:48:31 <kallisti> also path isn't defined there
06:48:35 <kallisti> you need path as an argument to the function, of course.
06:48:49 <ovechkin> kallisti: so i my parens were screwed up?
06:48:50 <Plembo> isValidPath path = all (<= 1) (zipWith (\a b -> abs (b-a)) path (tail path))
06:49:08 <kallisti> ovechkin: I believe so, yes. But I wasn't able to decipher how. the error seemed to suggest that $ wasn't being used.
06:49:19 <kallisti> Plembo: that's it.
06:49:35 <kallisti> Plembo: you could also use $ instead of the parens there
06:49:46 <heffaklump> can I use QuickCheck for C code?
06:49:52 <kallisti> Plembo: as in:  all (<= 1) $ zipWith blah path (tail path)
06:50:02 <kallisti> or, as some people on this channel might prefer, you could also write it as
06:50:21 <Plembo> perfect, okay, the isvalidpath one works
06:50:30 <Plembo> which code was it that generated the path again?
06:50:32 <kallisti> Plembo: as in:  all (<= 1) . zipWith blah path $ tail path
06:50:35 <kallisti> Plembo: allpath
06:50:43 <kallisti> it used replicateM
06:50:46 <kallisti> from Control.Monad
06:50:52 <kallisti> which is a wonderful magical function.
06:50:57 <Plembo> hmm
06:51:00 <Plembo> when I try to add
06:51:03 <Plembo> allpaths x y = replicateM y [0..(x-1)]
06:51:05 <kallisti> (it's not actually magical but it seems that way at first :P )
06:51:07 <Plembo> it's saying "replicateM" isn't in scope
06:51:08 <Plembo> but I have
06:51:10 <Plembo> oh, whoops
06:51:10 <Plembo> monad
06:51:14 <kallisti> yep
06:51:34 <Plembo> allpaths x y = replicateM y [0..(x-1)]
06:51:37 <Plembo> with that declaration
06:51:39 <kallisti> Plembo: note that replicateM and sequence are functions defined for any monad. List is a monad.
06:51:58 <kallisti> you're using one particular application of the sequence function.
06:52:10 <kallisti> Plembo: yes, but you mentioned you always have a square grid
06:52:12 <kallisti> so you could just have
06:52:15 <kallisti> allpaths n = ...
06:52:29 <kallisti> but if you want rectangular grids, you'd want both the x and the y.
06:52:40 <Plembo> oh, perfect, alright, that works
06:52:44 <Plembo> so I have allpaths to generate paths
06:52:48 <Plembo> isvalidpath to see if it's a valid path
06:52:56 <Plembo> so now I need to use filter to cull down allpaths' resulting list, right?
06:53:01 <kallisti> yep.
06:53:52 <kallisti> Plembo: I've given you a lot of free code, but I think it helps to see how the thought process works when writing Haskell. you become familiar with a wide variety of different functions and then figure out which functions you want to define in order to stick them all together. :P
06:54:08 <kallisti> (that's a simplified explanation of the process)
06:54:45 <heffaklump> what is the best explanation of a monad?
06:55:19 <zzo38> heffaklump: Something in category theory, I guess.
06:56:41 <kallisti> heffaklump: the functions join and fmap
06:56:46 <kallisti> are good starting points
06:57:10 <kallisti> m >>= f = join (fmap f m)
06:57:16 <kallisti> I find this the easiest way to understand monads
06:57:28 <kallisti> rather than attempting to explain >>= directly
07:00:00 <dougransom> @pl \x=x^2
07:00:00 <lambdabot> (line 1, column 3):
07:00:01 <lambdabot> unexpected "="
07:00:01 <lambdabot> expecting letter or digit, operator, pattern or "->"
07:00:11 <dougransom> @pl \x->x^2
07:00:12 <lambdabot> (^ 2)
07:07:10 --- mode: kornbluth.freenode.net set +o ChanServ
07:18:14 <elliott> "i already declare hp as int with value 3 now my problem is when i put "hp--", it shows error [...] but if i put "--hp", the result print is 3 not 2."
07:18:24 <elliott> I would like to thank whoever chose Haskell's single-line comment syntax.
07:19:21 <NihilistDandy> :D
07:19:44 <NihilistDandy> I want to add that quote, but I cannot for the the life of me remember the syntax
07:20:07 <elliott> "@remember person quote". In this case, person is "user1151874" \:p
07:20:17 <elliott> Whoops, I have a slanty hat on.
07:20:22 <elliott> :p That's better.
07:27:30 <akosch> elliott: wow, just wow... it's a shame he can't define -- as an unary operator ;)
07:30:03 <NihilistDandy> @remember user1151874 "i already declare hp as int with value 3 now my problem is when i put "hp--", it shows error [...] but if i put "--hp", the result print is 3 not 2."
07:30:03 <lambdabot> Done.
07:30:47 <shachaf> I would recommend not having that quote in the database.
07:31:05 <elliott> NihilistDandy: Also, lambdabot doesn't take ""s around the quote.
07:31:14 <elliott> Now you get to figure out how to remove quotes.
07:31:20 <shachaf> elliott: Looks to me like lambdabot just took them.
07:31:39 <shachaf> Also, the quotes were yours, not NihilistDandy's.
07:31:42 <JoeyA> @quote declare hp
07:31:43 <lambdabot> No quotes for this person. Your mind just hasn't been the same since the electro-shock, has it?
07:31:50 <JoeyA> @quote user1151874 hp
07:31:51 <lambdabot> user1151874 says: "i already declare hp as int with value 3 now my problem is when i put "hp--", it shows error [...] but if i put "--hp", the result print is 3 not 2."
07:32:16 <JoeyA> @quote kmc imperative
07:32:16 <lambdabot> kmc says: the irony being, the abstraction that gets the most complaining and general noise [from imperative programmers] is the one that captures imperative programming
07:32:25 <JoeyA> @quote kmc best imperative
07:32:25 <lambdabot> No quotes match. Have you considered trying to match wits with a rutabaga?
07:32:53 <JoeyA> I was looking for the quote about Haskell being the best imperative language
07:33:09 <zzo38> Is there any guarantee the order of instances retrieved by using the TH reify on a class?
07:34:09 <tgeeky> elliott: things like metric (space) signatures (+---) (---+) actually still work, even with the comment syntax. The only thing is you can't do a 2d space :O
07:34:50 <tgeeky> is it inappropriate to think of it as "-- "?
07:35:24 <elliott> --| is a comment too
07:35:25 <elliott> i think
07:35:32 <elliott> also -- at eol
07:35:47 <tgeeky> yeah but I can't (or don't) type EOL
07:35:49 <monochrom> oh, I think I know why the imperative abstraction gets the most complaining and noise. it is because people want to do imperative programming and are disappointed that they have to do it through an abstraction.
07:36:14 <elliott> wait no, --| is an operator
07:36:20 <tgeeky> elliott: yep
07:36:21 <elliott> it's -- followed by anything except a valid operator character
07:37:14 * hackagebot HGamer3D-Data 0.1.4 - Library to enable 3D game development for Haskell - Data  http://hackage.haskell.org/package/HGamer3D-Data-0.1.4 (PeterAlthainz)
07:37:16 * hackagebot HGamer3D-Ogre-Binding 0.1.4 - Library to enable 3D game development for Haskell - Ogre Bindings  http://hackage.haskell.org/package/HGamer3D-Ogre-Binding-0.1.4 (PeterAlthainz)
07:37:18 * hackagebot HGamer3D-OIS-Binding 0.1.4 - Library to enable 3D game development for Haskell - OIS Bindings  http://hackage.haskell.org/package/HGamer3D-OIS-Binding-0.1.4 (PeterAlthainz)
07:37:20 * hackagebot HGamer3D-API 0.1.4 - Library to enable 3D game development for Haskell - API  http://hackage.haskell.org/package/HGamer3D-API-0.1.4 (PeterAlthainz)
07:37:22 * hackagebot bindings-levmar 1.1 - Low level bindings to the C levmar (Levenberg-Marquardt) library  http://hackage.haskell.org/package/bindings-levmar-1.1 (BasVanDijk)
07:37:25 <NihilistDandy> @hoogle (--|)
07:37:29 <lambdabot> No results found
07:42:24 * hackagebot levmar 1.2.1 - An implementation of the Levenberg-Marquardt algorithm  http://hackage.haskell.org/package/levmar-1.2.1 (BasVanDijk)
07:44:40 <Eelis> is there a conventional type class for types that have a default value?
07:44:54 <sanjoyd> Types can have a default value?
07:44:56 <elliott> Unfortunately, yes.
07:44:56 <sanjoyd> How?
07:45:03 <Eelis> elliott: what's it called?
07:45:06 <elliott> http://hackage.haskell.org/package/data-default
07:45:12 <elliott> Don't use it, please.
07:45:15 <Eelis> why not?
07:45:22 <elliott> "Default" is a meaningless concept.
07:45:26 <elliott> Why is the default integer 0?
07:45:34 <Eelis> i never said anything about integers
07:45:50 <elliott> Well, what do you actually want, rather than a default value?
07:46:00 <Enigmagic> i like default values too
07:46:06 <elliott> "Default" is too vague a concept to be a good typeclass, because it's impossible to say whether a given value is the "default" or not.
07:46:10 <elliott> It's a very domain-specific concept.
07:46:22 <Eelis> my type is a type that represents per-channel state of an irc bot. when the bot just enters a channel, it starts with an "empty" default state
07:46:22 <sanjoyd> For *, default for integers would have to be 1.
07:46:31 <elliott> sanjoyd: Exactly.
07:46:40 <Taneb> Eelis, monoid?
07:46:44 <zzo38> There is an identity, but that doesn't mean anything unless it is the identity of something.
07:46:46 <Eelis> Taneb: i don't have mappend
07:46:52 <elliott> Eelis: Why do you need a typeclass?
07:47:01 <zzo38> Which can have Monoid and so on
07:47:06 <elliott> There's no generic code you can write with a "default" value, so there's no need to overload a name.
07:47:17 <elliott> Any code using that default state will be specific to that state type, and so can just use a name directly.
07:47:30 <zzo38> I suggest, if you need defaults you should always write your own class since it is for your own specific use
07:47:45 <Enigmagic> elliott: yeah but large project have lots of record names :P
07:48:09 <Eelis> elliott: because i want to use a general purpose subState function of type   HasEmpty b => a -> State b c -> State (Map a b)
07:48:29 <Eelis> in my case, i'd instantiate 'a' with the channel name and 'b' with the type for per-channel data
07:48:34 <sanjoyd> I'd just have a top level instance of that type to serve as the default.  Like Data.Map
07:48:42 <sanjoyd> *Like empty in Data.Map
07:48:56 <zzo38> If you want default values of fields in a record, and you add fields in different modules, I have made such a package but have not yet uploaded it. In addition, it supports dependent defaults if you need them.
07:49:06 <elliott> Eelis: That seems odd, but okay.
07:49:07 <Eelis> zzo38: no, that is not what i want
07:49:14 <elliott> Enigmagic: I agree with sanjoyd, qualified imports are the soltuion there.
07:49:14 <Eelis> elliott: why does it seem odd?
07:49:29 <Enigmagic> elliott: i use qualified imports too
07:49:35 <elliott> Eelis: Well, it's a weird operation to want, I think.
07:49:46 <zzo38> Eelis: If you simply need default values of some types, then make up your own class since it probably depend what you are using it for, what kind of default you want
07:50:33 <Eelis> elliott: it means i can write the code that does stuff in a channel in  State ChannelState  instead of   State (Map ChannelName ChannelState), which simplifies the code
07:50:47 <Enigmagic> elliott: i'd be happy if mempty and mappend were split... since i really just want "def = mempty" in most cases
07:51:07 <Eelis> elliott: it means the code that does stuff in a channel only has to see the channelstate of the current channel
07:51:15 <elliott> Enigmagic: That would be terrible, seeing as mempty is meaningless without mappend. (See the Pointed fiasco.)
07:51:19 <zzo38> Enigmagic: I disagree; what is the identity if it is not the identity of anything?
07:51:23 <elliott> Eelis: It sounds like you want lenses.
07:51:27 <Enigmagic> it's the identity!
07:51:31 <elliott> Eelis: That's the "focus" operation.
07:51:31 <Eelis> elliott: i don't see how they would help.
07:51:36 <elliott> I do.
07:51:46 <elliott> You have
07:51:52 <elliott> mapLens :: Ord k => k -> Lens (Map k v) (Maybe v)
07:51:53 <elliott> focus :: Monad m => Lens a b -> StateT b m c -> StateT a m c
07:51:54 <Enigmagic> elliott: nah default isn't meaningless either
07:52:05 <heffaklump> > fmap (+1) [Just 1,Just 2, Nothing]
07:52:06 <lambdabot>   No instance for (GHC.Num.Num (Data.Maybe.Maybe t))
07:52:06 <lambdabot>    arising from a use of...
07:52:15 <heffaklump> howto?
07:52:16 <elliott> heffaklump: map (fmap (+1))
07:52:19 <NihilistDandy> elliott: Pointed fiasco?
07:52:28 <Saizan> Eelis: there is data-default
07:52:42 <heffaklump> > fmap (+1) (Just 5)
07:52:43 <lambdabot>   Just 6
07:52:45 <Eelis> elliott: which of the various lenses packages are you referring to?
07:53:01 <heffaklump> > map $ fmap (+1) [Just 1,Just 2, Nothing]
07:53:02 <elliott> Eelis: Those were from data-lens. I believe fclabels has something similar to focus.
07:53:02 <lambdabot>   Couldn't match expected type `a -> a1' against inferred type `[a2]'
07:53:09 <heffaklump> > map (fmap (+1)) [Just 1,Just 2, Nothing]
07:53:10 <lambdabot>   [Just 2,Just 3,Nothing]
07:53:21 <heffaklump> :t join
07:53:22 <lambdabot> forall (m :: * -> *) a. (Monad m) => m (m a) -> m a
07:53:31 <hpaste> ‚Äúmafscience tour‚Äù pasted ‚Äúblinkieleit 4‚Äù at http://hpaste.org/63470
07:53:35 <heffaklump> > join $ Just (Just 5))
07:53:36 <lambdabot>   <no location info>: parse error on input `)'
07:53:41 <heffaklump> > join $ Just (Just 5)
07:53:42 <lambdabot>   Just 5
07:54:02 <Eelis> elliott: i'll look at that package, thanks. i don't see how it could cheat its way out of needing a default value though
07:55:03 <Chaze> @pl foo f g h x = f (g x) (h x)
07:55:04 <lambdabot> foo = liftM2
07:55:28 <Eelis> elliott: oh, i get it, i'd end up having to mess with Maybes
07:55:45 <Eelis> ugh, that's much uglier than using Data.Default
07:55:54 <elliott> Eelis: No, I would suggest wrapping up a Map in something else that ensures you have the keys you need.
07:56:01 <elliott> Then you can initialise it with the "defaults" in a single place.
07:56:17 <Eelis> that sounds even worse
07:56:27 <otters> you could write it as
07:56:38 <otters> (<$>) succ <$> [Just 1, Just 2, Nothing]
07:56:39 <Eelis> because then i suddenly have to predict in advance all the channels the bot will ever be in
07:56:44 <heffaklump> @pl chaze a b = a+b
07:56:45 <lambdabot> chaze = (+)
07:57:03 <otters> somebody correct me
07:57:05 <otters> there's an easier way to do that
07:58:33 <sal23> in ghc core annotation, what do the elements of Vector constructor stand for ? Like this one: Vector ww_sGq ww1_sGr ww2_sGs
07:58:49 <sal23> I thought they were: Vector fp offset length
07:58:51 <otters> (succ <$>) <$> xs maybe
08:00:19 <Eelis> elliott: oh, i think i misunderstood your suggestion. i'll try it with a wrapped Map with custom Lens instance and focus. thanks again!
08:01:13 <elliott> Eelis: well, I don't know that it'll work for sure, but it might be worth a try :P
08:01:24 <Eelis> i'll let you know :)
08:02:55 <Chaze> > let foo x = (length x,sum x)
08:02:56 <lambdabot>   not an expression: `let foo x = (length x,sum x)'
08:03:11 <Chaze> let bar = liftM2 (,) length sum
08:03:24 <Chaze> why does bar not work?
08:04:06 <otters> :t liftM2
08:04:07 <lambdabot> forall a1 a2 r (m :: * -> *). (Monad m) => (a1 -> a2 -> r) -> m a1 -> m a2 -> m r
08:05:42 <shachaf> Chaze: Why don't you tell us?
08:06:10 <Botje> Chaze: what do you mean by "not work" ?
08:06:53 <elliott> :t liftM2 (<) length sum
08:06:54 <lambdabot> [Int] -> Bool
08:06:55 <elliott> argh
08:06:58 <elliott> :t liftM2 (,) length sum
08:06:59 <lambdabot> forall a. (Num a) => [a] -> (Int, a)
08:07:06 <elliott> Chaze: Looks fine to me. Do you have Control.Monad.Instances imported?
08:07:18 <shachaf> There are a bunch of reasons that I can think of, including what elliott says and the DMR.
08:07:25 <Chaze> elliott: aah. that was it!
08:07:33 <Chaze> this is like the 3rd time i stumbled upon that
08:07:39 <shachaf> But I don't know that it's a good idea to encourage the behaviour of asking questions without giving any information other than "it doesn't work". :-)
08:07:44 <shachaf> So what Botje said.
08:07:48 <Chaze> yes, sorry
08:08:03 <Chaze> i couldn't really interpret ghci's output
08:08:23 <elliott> It's useful to hpaste the error so we can see what's wrong :)
08:08:34 <elliott> shachaf: I can't stop being psychic. :(
08:09:03 <shachaf> Right. When asking a question of this sort, it's usually a good idea to provide (a) what you did (b) what you expected (c) what you got.
08:11:41 <elliott> shachaf: (a) Wrote some code. (b) It to work. (c) An error.
08:12:00 <Chaze> a) an ignorant question. b) a quick answer. c) moral teaching about the ethics of asking questions on IRC :)
08:12:20 <Chaze> sorry again. totally got your point :)
08:12:36 <shachaf> It's not really ethics. It just makes everybody's life easier, including yours.
08:12:49 <shachaf> elliott isn't psychic every time.
08:13:06 <otters> yeah I'm computing the error bars on it as we speak
08:13:35 <elliott> shachaf: Are you sure?
08:13:41 <elliott> I'm honing my skills.
08:14:20 <Jafet1> shachaf isn't not psychic every time.
08:14:29 <Jafet1> I know this, somehow
08:14:39 <shachaf> elliott: Oh, really? What number am I thinking of?
08:14:54 <shachaf> <<<26>>>
08:15:18 <elliott> shachaf: You're thinking "whatever he guesses, I'll just say something else".
08:15:38 <shachaf> Wrong! I was thinking of 26.
08:15:43 <elliott> Told you.
08:15:49 <byorgey> woah, that's what *I* was thinking shachaf was thinking!
08:17:14 * hackagebot shake 0.2.4 - Build system library, like Make, but more accurate dependencies.  http://hackage.haskell.org/package/shake-0.2.4 (NeilMitchell)
08:17:15 <otters> so "some" and "many" are defined in terms of each other
08:17:16 * hackagebot liblastfm 0.0.1.0 - Wrapper to Lastfm API  http://hackage.haskell.org/package/liblastfm-0.0.1.0 (MatveyAksenov)
08:17:22 <otters> 0_0 no comprendo
08:17:47 <shachaf> otters: Just like (==) and (/=) are defined in terms of each other.
08:17:47 <elliott> otters: some and many are... special.
08:18:00 <elliott> shachaf: No. The default definitions work for certain Alternatives.
08:18:01 <byorgey> shachaf: it's not really like that at all.
08:18:04 <otters> they don't have exactly a thorough definition
08:18:05 <elliott> Namely, those that look like parsers.
08:18:11 <otters> "one or more."
08:18:15 <otters> "zero or more."
08:18:16 <elliott> otters: Have you used Parsec?
08:18:22 <otters> nop
08:18:23 <byorgey> otters: note that 'many' has a base case where it could conceivably NOT call 'some'.
08:18:24 <elliott> Oh.
08:18:27 <elliott> Use Parsec.
08:18:30 <elliott> Then you'll understand.
08:18:32 <shachaf> Oh. Yes, it's just mutually recursive functions.
08:18:33 <otters> if you insist
08:18:48 <elliott> otters: Well, don't.
08:18:51 <elliott> Not until you have a reason to use it.
08:18:55 <elliott> But if you used it, you'd understand.
08:18:56 <otters> Yeah I'll wiat
08:18:58 <otters> wait
08:19:26 <byorgey> otters: so just because they are defined in terms of each other doesn't mean they will just recurse infinitely.
08:19:39 <otters> yeah I know
08:19:44 <NihilistDandy> I'm the only person in my Ocaml class that defined is_even and is_odd as mutually recursive
08:19:58 <NihilistDandy> All the others are imperative to the core‚Ä¶ so many if_then_else_s
08:19:59 <otters> heh
08:20:05 <nus> @type (<|>)
08:20:06 <elliott> (n `mod` 2) == 0
08:20:06 <lambdabot> forall (f :: * -> *) a. (Alternative f) => f a -> f a -> f a
08:20:07 <lambdabot> elliott: You have 1 new message. '/msg lambdabot @messages' to read it.
08:20:09 <byorgey> NihilistDandy: nice =)
08:20:10 <elliott> Oh come on.
08:20:12 <otters> let is_even = not (is_odd)
08:20:18 <shachaf> Why are they even in the type class, then?
08:20:19 <otters> let is_odd = not (is_even)
08:20:19 <parcs`> otters: 'some v'requires at least 1 'v', 'many v' requires 'some v' or defaults to '[]'
08:20:50 <Saizan> shachaf: to allow optimized versions
08:21:01 <shachaf> I suppose that's the usual justification.
08:21:02 <byorgey> > let isEven 0 = True; isEven n = isOdd (n-1); isOdd 0 = False; isOdd n = isEven (n-1) in isOdd 24
08:21:03 <lambdabot>   False
08:21:14 <NihilistDandy> byorgey: You should see some of the frightening things they come up with. They're not even *trying* to think about problems differently :/
08:21:22 <byorgey> NihilistDandy: sad
08:21:36 <shachaf> It's kind of strange that the person defining the type class singles out a few library functions as deserving the ability to optimize.
08:21:44 <Botje> NihilistDandy: it takes a while to un-learn imperative programming
08:21:45 <elliott> shachaf: They shouldn't be in Alternative.
08:21:52 <elliott> shachaf: Because they're _|_ for 99% of Alternatives.
08:22:01 <byorgey> NihilistDandy: although I'd be inclined to put at least some of the blame on the teaching. although I have no idea what you class is like.
08:22:05 <elliott> (For some value of _|_.)
08:22:17 <byorgey> and for some value of 99%
08:22:30 <NihilistDandy> Botje: The fibnum one of my classmates wrote was frightening/didn't work at all. And he insisted that it should
08:22:31 <Saizan> shachaf: yeah, and it leads to lengthy discussions on libraries@
08:22:32 <elliott> OK, I guess parsers are more than 1%.
08:22:36 <hpc> and for some value of "Because"
08:22:37 <hpc> :P
08:22:51 <elliott> shachaf: The typeclass system kind of sucks; world shocked.
08:23:12 <NihilistDandy> byorgey: The class isn't bad. The professor's a bit of an Ocaml evangelist (and somewhat dismissive of Haskell), but the type theory part is solid
08:23:32 <NihilistDandy> Strictly, it's a programming languages class, and we just happen to be using Ocaml
08:23:52 <byorgey> NihilistDandy: fair enough.  Where are you, just out of curiosity?
08:24:00 <elliott> NihilistDandy: That can all be true without the class actually being good at teaching imperative programmers.
08:24:14 <NihilistDandy> byorgey: University of Vermont
08:24:19 <NihilistDandy> elliott: True
08:24:33 <byorgey> NihilistDandy: ah, cool
08:24:52 <NihilistDandy> He does make efforts, though. UVM's programming outside of this class is very imperative-centric, though
08:25:19 <parcs`> what's the point in writing even and odd mutually-recursively?
08:25:38 <Botje> verifying your interpreter is tail-recursive for one ;]
08:25:40 <byorgey> parcs`: to illustrate mutual recursion.
08:25:49 <monochrom> to be an early example of mutual recursion
08:25:56 <Botje> (waait .. nevermind that :/)
08:25:56 <byorgey> parcs`: also if you are actually working with Peano nats it's the most obvious way to write them.
08:26:09 <NihilistDandy> parcs`: I just thought it wa cute, and I'm learning Ocaml so I wanted to try it
08:26:13 <Jafet> To be stereophonic
08:26:15 <NihilistDandy> *was
08:26:48 <monochrom> UVM makes me think University of Virtual Machines :)
08:26:48 <parcs`> does it work for negative numbers?
08:27:02 <elliott> Peano nats can't be negative!
08:27:20 <byorgey> NihilistDandy: I'm going to be giving the CS colloquium at Williams on April 13, but after a bit of googling it seems that you're about a 3-hour drive away
08:27:32 <otters> can lambdabot show me instance declarations?
08:27:38 <elliott> @src [] (>>=)
08:27:38 <lambdabot> xs >>= f     = concatMap f xs
08:27:40 <elliott> @src [] return
08:27:41 <lambdabot> return x    = [x]
08:27:43 <elliott> Sometimes.
08:27:44 <otters> Oh
08:27:50 <otters> that's what I was thinking
08:27:52 <otters> neat
08:27:53 <elliott> But like everything @src, it's woefully incomplete.
08:28:00 <otters> Well, close enough.
08:28:02 <hpc> and sometimes wrong
08:28:04 <hpc> @src (.)
08:28:05 <lambdabot> (f . g) x = f (g x)
08:28:05 <lambdabot> NB: In lambdabot,  (.) = fmap
08:28:05 <NihilistDandy> byorgey: Sounds like a fun time. Any link for info?
08:28:13 <hpc> er, sometimes different, rather
08:28:16 <NihilistDandy> monochrom: If I had my way...
08:28:23 <Jafet> @src flip
08:28:23 <lambdabot> flip f x y = f y x
08:28:29 <byorgey> NihilistDandy: I don't think it's posted yet, but I'll ping you when it is
08:28:29 <Jafet> :t flip
08:28:30 <lambdabot> forall (f :: * -> *) a b. (Functor f) => f (a -> b) -> a -> f b
08:28:48 <hpc> flip' fs x = fmap ($ x) fs
08:29:05 <SirFrancisDrake> is it possible to make both an ADT and and STM'ed ADT instances of a same typeclass, using that typeclasse's functions?
08:30:02 <byorgey> NihilistDandy: I'll probably be talking about diagrams (http://projects.haskell.org/diagrams), with a focus on how FP helps in building embedded domain-specific languages
08:30:31 <NihilistDandy> byorgey: I'll add it to my calendar for sure. Might have to skip a class, but it'll be worth it :D
08:30:41 <monochrom> I wondering if it is FP or Haskell that helps EDSL
08:31:14 <hpc> i think it's both
08:31:18 <byorgey> monochrom: well, both
08:31:21 <hpc> FP gives you the ability to get nice semantics
08:31:27 <hpc> haskell gives you a nice syntax
08:31:27 <dougransom> I understand how fix can replace direct recursion (i.e. in the fact examples), is there a practical use, or just a fun thing to know?
08:31:45 <byorgey> type classes are also nice
08:31:50 <byorgey> for EDSLs I mean
08:31:58 <hpc> dougransom: there are generalizations of fix that are hard to reproduce directly
08:32:01 <hpc> :t fixIO
08:32:02 <lambdabot> Not in scope: `fixIO'
08:32:03 <drdo> I still don't know why people say haskell is particularly good for EDSLs
08:32:06 <hpc> @hoogle fixIO
08:32:06 <lambdabot> System.IO fixIO :: (a -> IO a) -> IO a
08:32:17 <hpc> dougransom: fixIO is used in some places for memoization
08:32:30 <elliott> SirFrancisDrake: "STM'd ADT"?
08:32:39 <dougransom> hpc:thanks
08:32:45 <drdo> (coming from lisp)
08:32:48 <byorgey> dougransom: sure, if you write programs in an "open recursion" style (e.g. before applying fix), you can then "mix in" various capabilities such as memoization just by composing with some extra combinators before tying the knot with fix
08:32:59 <Enigmagic> harness the power of unsafeInterleaveIO
08:33:04 <monochrom> oh, lisp is good for EDSL too
08:33:11 <dougransom> byorgey:cool
08:33:19 <elliott> drdo: The difference is that Haskell is good at other things, too ;)
08:33:30 <byorgey> dougransom: I'm trying to find you a link...
08:33:41 <elliott> drdo: More seriously, it's about compromise: for what else it gives you, such as the type system, it does impressively well at DSLs.
08:34:33 <monochrom> but I like EDSL without needing macros
08:34:48 <drdo> elliott: The question is, do we have to make that particular choice?
08:35:24 <monochrom> "we" don't. this is why lisp hasn't died yet.
08:35:36 <byorgey> dougransom: I can't find the particular paper I was thinking of, but if you just google for "open recursion" and/or "mixins" you'll find some stuff
08:35:37 <monochrom> but haskell is also here to stay
08:35:53 <elliott> drdo: Who's we, and what's the choice?
08:35:56 <drdo> monochrom: There's plenty to improve in existing lisps
08:36:04 <elliott> drdo: And why is the existence of something Even Better an indication that Haskell's support isn't good?
08:36:05 <drdo> elliott: We is humanity
08:36:20 <drdo> elliott: It isn't
08:36:21 <elliott> Humanity doesn't really make choices. Especially not choices about which programming languages are the best.
08:36:32 <hpc> byorgey: wikipedia's open recursion article redirects to 'this'
08:36:38 <cmccann> none of them, all languages are terrible
08:36:41 <cmccann> we've been over this.
08:36:47 <hpc> er, dougransom ^
08:36:54 <hpc> so not that one :P
08:38:06 <drdo> elliott: It's just that i haven't noticed it being any easier, i've noticed it being harder, so from my point of view it's not clear why people would say that
08:38:46 <zenzike> I'm about to push a version of HDBC that's been updated so that it builds with ghc-7.4. The changes are limited to basically a single type signature that's had its class constraint changed from "(Num a) => ..." to "(Eq a, Num a) => ..." Strictly speaking, the type has changed, so doea that mean I should bump the version number from 2.3.1.0 to 2.4.0.0, or is this minor enough to just go to 2.3.1.1?
08:38:56 <cmccann> drdo, Haskell is significantly better for EDSLs than any language that doesn't support metaprogramming as powful as lisp macros :P
08:39:01 <rostayob> dcoutts: Why isn't this an instance of Applicative http://hackage.haskell.org/packages/archive/cairo/0.12.2/doc/html/Graphics-Rendering-Cairo.html#t:Render ?
08:39:31 <dcoutts> rostayob: because it was created before Applicative existed :-)  feel free to send a patch
08:40:02 <monochrom> one day I will write you an open recursion web page
08:40:18 <byorgey> zenzike: no, that can't possibly break anything
08:40:39 <byorgey> zenzike: unless someone did  import Prelude hiding (Eq) and then defined their own Eq, in which case I don't think it's worth worrying about it =P
08:40:56 <zenzike> byorgey: phew. I'm just being a bit paranoid, and want to make sure I'm not doing anything unexpected
08:41:01 <elliott> drdo: Most people aren't coming from Lisp.
08:41:08 <byorgey> zenzike: sure, your paranoia is appreciated =)
08:41:22 <elliott> drdo: Obviously if you come from the one language whose entire structure and culture is basically based around DSLs and metaprogramming, you will not find something better.
08:41:23 <cmccann> zenzike, really you're not actually changing the type
08:41:40 <drdo> elliott: Sure, but it's not easy to just strip out your mental process and try to imagine someone else's
08:42:00 <cmccann> zenzike, you're either adding superfluous information (if Num has the Eq constraint) or keeping the same type (Num and Eq both) for new versions
08:42:05 <drdo> It's not easy to unsee stuff :P
08:42:18 <elliott> drdo: HQ9+ is also really good at hello world programs and 99 bottles of beer on the wall -- but "HQ9+ does it better!" is a silly response to, e.g. a language having a particularly expressive and beautiful 99 bottles of beer program. (Ignoring the fact that that isn't very likely.)
08:42:24 <elliott> (Note: I like Lisp.)
08:42:47 <monochrom> I don't like bringing the sledgehammer of metaprogramming to work out even the most trivial EDSL
08:43:07 <cmccann> drdo, also note that the lisp approach isn't likely to work as nicely in a language that takes types mostly seriously, as Haskell does
08:43:18 <drdo> elliott: That's not at all how i put it, i just said that it was not clear to me
08:44:32 <drdo> If i thought haskell wasn't any good i wouldn't be using it would i?
08:45:20 <elliott> drdo: Didn't say otherwise, I just interpreted your initial statement differently.
08:45:34 <cmccann> drdo, let me put it this way, spend three months using Java and then you'll understand why people say Haskell is good for EDSLs
08:46:20 <nus> many have pointed out that monads are quite handy for implementing EDSLs, and monads are a native idiom for Haskell
08:46:23 <hpc> cmccann: spend 3 months in java and you'll think C++ has a good type system ;)
08:46:56 <hpc> nus: not entirely "native", but definitely an idiom
08:47:12 <cmccann> isn't Monad defined in the report?
08:47:17 <cmccann> that's pretty native.
08:47:22 <monochrom> I spent 3 months using lisp and I still say haskell is good for EDSLs. well lisp is good too by I would rather Haskell. and my 3-month tenure with lisp was before I heard of Haskell
08:47:23 <nus> hpc, f.e. they feel foreign for a CLer
08:48:07 <NihilistDandy> I definitely prefer Haskell syntax, if nothing else. :purely subjective:
08:48:40 * cmccann thinks Haskell has too much syntax
08:49:07 <hpc> i think it has a lot, but not quite too much yet
08:49:18 <monochrom> a large part comes down to this: (f (g x)). in Lisp, f may be a function (CBV) or a macro (CBN), and g may be a function or a macro. the distinction is important. the distinction is hidden by the syntax. there is no such opacity in Haskell.
08:49:24 <hpc> and the worst syntax is wrapped up in extensions
08:49:32 <NihilistDandy> Any language in which I'm not writing "This is a program that does X" and then that compiles to a working program has too much syntax :D
08:49:37 * mjga just read Simon's Marlow paper about parallelism in Haskell. Good read, if only Manuel would join him, Haskellers would be the ruling type of programmers.
08:49:53 <cmccann> hpc, maybe I should say it has more syntax than it needs, instead.
08:50:25 <elliott> Haskell needs to look like papers about Haskell.
08:50:27 <hpc> cmccann: that might be true; i can't really think of any syntax i would change though, besides unary minus
08:52:19 <cmccann> hpc, it's stuff like do vs. list comprehensions that kinda annoys me
08:52:25 <monochrom> "This is a program that does X" is too much syntax. Simplify it to "X".
08:52:41 <NihilistDandy> monochrom: Fair point
08:52:41 <monochrom> "This is a program that does X" is COBOL.
08:53:25 <hpc> "X" is not enough documentation, change it to "X; // do X"
08:53:48 <cmccann> hpc, not that I dislike either but having both seems unnecessary.
08:54:09 <monochrom> "x = x + 1 // increment x"
08:54:21 <hpc> cmccann: that's true; i consider list comprehensions to be sort of "list monad training wheels"
08:54:33 <hpc> because in do-notation it's so hard to wrap your head around what it does
08:54:51 <Jafet> List comprehensions are easy to comprehend.
08:54:59 <Jafet> That's why they're called comprehensions!
08:55:00 <cmccann> hpc, that's not how programming in the real world works. itshould be "X; // do X and Y (TODO: implement X)"
08:55:07 <Jafet> And not list apprehensions
08:55:21 <monochrom> list/monad comprehension emphasizes "monad as container". do-notation emphasizes "monad as computation"
08:55:24 <hpc> cmccann: haha; where i work we are forbidden to put "TODO" inside a comment
08:55:31 <cmccann> hpc, :D
08:55:39 <hpc> if it should be done, it gets a bug report
08:55:47 <monochrom> that is why both are here to stay
08:56:21 <Jafet> Monad comprehensions are just here for the weekend
08:56:31 <hpc> do-notation does a good job at monad-as-container too, to be fair
08:56:33 <cmccann> monochrom, I realize that but don't find it that persuasive
08:57:12 <hpc> if you look at it through C lenses, where the action is a computation that builds the container
08:57:17 <hpc> instead of it being the container itself
08:57:24 <monochrom> no, it is not meant to pesuade you to adopt either. it is meant to persuade you why enough people will use them
08:57:45 <mjga> elliott: I have things to complain about, but not ease of use of parallel. Since they upgraded to parallel GC I wouldn't complain about performance too much. Am I wrong?
08:57:46 <nand`> I never did understand why list comprehensions no longer work on all monads
08:57:53 <hpc> nand`: me either
08:57:54 <cmccann> nand`, don't they?
08:58:05 <hpc> oh wait, i think i can guess
08:58:07 <monochrom> monad comprehension has come back
08:58:17 <nand`> monochrom: since when?
08:58:19 <cmccann> http://www.haskell.org/ghc/docs/latest/html/users_guide/syntax-extns.html#monad-comprehensions
08:58:22 <cmccann> :D
08:58:23 <monochrom> GHC 7.0
08:58:24 <hpc> because [x | x <- l, predicate x] desugars to
08:58:34 <monochrom> err, 7.2
08:58:36 <hpc> do {x <- l; guard (p x); return x}
08:58:38 <hpc> :t gurad
08:58:39 <lambdabot> Not in scope: `gurad'
08:58:41 <hpc> :t guard
08:58:42 <lambdabot> forall (m :: * -> *). (MonadPlus m) => Bool -> m ()
08:58:52 <mjga> elliott: of course it is still non-trivial to insert right 'strategy' so that parallel goes in parallel. I am still trying to parallelize my executable, and would be happy if they parallelized GHC --make
08:58:55 <hpc> if you put predicates in a monad comprehension, you have a MonadPlus comprehension
08:59:04 <hpc> nand`: ^
08:59:12 <cmccann> hpc, yes, and the GHC user guide says as much :P
08:59:19 <nand`> hpc: then limit them to MonadPlus, where's the problem?
08:59:28 <nand`> still better than just lists
09:00:06 <cmccann> you can even use the generalized and parallel list comprehension extensions with arbitrary monads, I think
09:00:18 <hpc> nand`: i think it goes too far into "special case" territory then, imo
09:00:21 <Jafet> Applicative comprehensions
09:00:29 <hpc> nand`: at least, to untrained eyes - it makes perfect sense to me
09:00:32 <cmccann> Jafet, idiom brackets?
09:00:50 <Oleksis> Hello, please help me with that problem. Can't fix it for 4 hours . What's wrong ? http://doiop.com/img1826
09:01:18 <hpc> o.O
09:01:34 <zenzike> is anyone here able to add a user to hackageDB? I emailed ross a few months ago, but it seems I wasn't added to the accounts list
09:01:42 <monochrom> does not work. "You are seeing this page because the system administrator of 000webhost.com is currently checking this website for malicious content."
09:01:49 <cmccann> haha
09:01:52 <elliott> mjga: Hmm?
09:02:02 <elliott> I'm not sure what you're ersponding to.
09:02:48 <zzo38> Now my extensible-data has List, Product, Sum, and Tree. Please tell me in case I missed anything or did something wrong or other suggestion/idea/question/complaint.
09:03:17 <donri> zenzike: perhaps try again - i was added within a day
09:03:20 <carpi> is 'concat' strict?
09:03:25 <Rotaerk> zzo38, what?
09:03:29 <hpc> @src concat
09:03:29 <lambdabot> concat = foldr (++) []
09:03:37 <monochrom> yes
09:03:38 <elliott> zenzike: I think only he can.
09:03:39 <zzo38> Rotaerk: Please be more specific.
09:03:40 <elliott> try emailing again?
09:03:47 <hpc> > concat . words $ cycle "test "
09:03:48 <lambdabot>   "testtesttesttesttesttesttesttesttesttesttesttesttesttesttesttesttesttestte...
09:03:56 <zenzike> elliott: thanks, will give it another shot :-)
09:03:57 <monochrom> > concat undefined
09:03:58 <lambdabot>   *Exception: Prelude.undefined
09:04:02 <monochrom> is strict
09:04:22 <carpi> so it is strict. Thanks
09:04:31 <hpc> monochrom: strictly speaking, sure :P
09:04:32 <Rotaerk> zzo38, what're you talking about?
09:04:36 * cmccann notes that id is also strict
09:05:30 <zzo38> Rotaerk: I am talking about a few modules I made, in a package I have not uploaded, which implement extensible list, extensible product, extensible sum, extensible tree, in Haskell, so that they can be extended even in other modules and so on.
09:06:44 <zzo38> Did you understand?
09:07:03 <nus> what's an extensible list?
09:08:00 <zzo38> nus: A list where the list items can be spread out in multiple modules, which do not need to know anything about each other, except that all of them need to import the one declaring a specific extensible list, and then they can all be collected together.
09:08:51 <nus> modules in Haskell sense?
09:08:59 <zzo38> nus: Yes.
09:11:47 <flebron> Would you guys recommend LYAH for someone who already knows some Haskell (say, already knows what a mona-- fluffy kitten is), but is trying to get productive with it? Or would that be RWH?
09:12:15 <adimit> flebron: if you have something specific in mind you want to get done in Haskell, RWH is probably better.
09:12:36 <nus> zzo38, what would be, say, two exemplary Haskell modules where the list items *need* to know about each other?
09:12:47 <adimit> if you just want to extend your knowledge of the language, LYAH might be worth a look.
09:13:00 <elliott> flebron: LYAH might help cement your style and still probably covers some things you might not know (like applicative functors).
09:13:06 <ChristianS> flebron: i would first skim over LYAH to see if there's anything new there for you. then go for RWH.
09:13:08 <elliott> flebron: But RWH has practical advice.
09:13:54 <flebron> Alright, cool. I'd read some reviews on Amazon about RWH glossing over important concepts, but I'll cover those with LYAH I guess. Thanks :)
09:15:04 <elliott> flebron: The Typeclassopedia is also a very good read: http://www.haskell.org/haskellwiki/Typeclassopedia
09:15:05 <vrsparta> :help
09:15:07 <zzo38> nus: That isn't how it works. But, you might have one module, A, which declares a type to index the extensible list, and then modules B, C, and D, which all import A but not each other, add items to the list, and E, which imports all four of those modules will be able to access the entire list. However, they do not need to directly depend on each other; they can indirectly depend and continue to work. This might be useful with wildcard imports
09:15:20 <flebron> Yeah, that's where I learned about fluffy kittens :)
09:15:31 <zzo38> To add a feature to your program, simply add a file to a directory and everything else works.
09:15:48 <zzo38> And they need not know about each other.
09:17:42 <zzo38> An example might be, an extensible product where fields are added in various modules, and then you want to save the state so the list contains the functions to serialize and deserialize each field.
09:19:00 <nus> zzo38, you better call what you have in mind something other than lists, it's confusing
09:20:03 <hi5networks> anyone ever generate c structs from Haskell adts?
09:20:06 <zzo38> nus: But, it is a list. Just like other lists in Haskell. And I did already implement this, as well as other extensible data, such as sums, products, and trees.
09:21:53 <nus> other *lists*?
09:22:12 <zzo38> nus: Yes, such as [1, 4, 5, 42] and so on
09:22:14 * hackagebot HDBC 2.3.1.1 - Haskell Database Connectivity  http://hackage.haskell.org/package/HDBC-2.3.1.1 (NicolasWu)
09:22:51 <zenzike> yikes, that was easy :-)
09:25:40 <zzo38> I can show you the codes if you want, maybe it can be understand better by looking at the codes, they also contain explanations better than what I am writing here
09:27:44 <nus> zzo38, something indexable is usually called an array, though feel free to show the code
09:28:01 * elliott is not sure where nus got indexable from
09:28:19 <zzo38> nus:  http://sprunge.us/TWBh  (maybe I meant "indexable" wrong; they are type-indexed not value-indexed)
09:28:28 <kallisti> I'm honestly kind of surprised that there's no typeclass to abstract cons/uncons
09:28:40 <kallisti> in the standard library
09:28:52 <kallisti> there is MonadLogic, which abstracts uncons.
09:29:13 <elliott> Alternative/MonadPlus/Monoid
09:29:22 <elliott> > pure 1 <|> pure 2 <|> pure 3
09:29:23 <lambdabot>   No instance for (GHC.Show.Show (f t))
09:29:23 <kallisti> I suppose.
09:29:23 <lambdabot>    arising from a use of `M3016811571...
09:29:26 <elliott> > pure 1 <|> pure 2 <|> pure 3 :: [Int]
09:29:27 <lambdabot>   [1,2,3]
09:29:32 <kallisti> but what about uncons?
09:29:36 <nus> zzo38, http://www.downforeveryoneorjustme.com/sprunge.us
09:30:04 <zzo38> nus: What is that for?
09:30:17 <nus> zzo38, sprunge.us is unreachable
09:30:32 <killy> hello everyone
09:30:35 <roconnor> kallisti: http://hackage.haskell.org/packages/archive/containers/0.2.0.1/doc/html/Data-Sequence.html#t:ViewL
09:30:53 <zzo38> Is the DNS getting broken? Is not unreachable to me. But I used the command-line to reach it
09:31:02 <amstan> anyone here using kate and likes tabs? how do you format your code?
09:31:03 <roconnor> kallisti: oh, that is less abstract than I thought.
09:31:03 <kallisti> roconnor: not much of an abstraction is it?
09:31:13 <zzo38> Its IP address is currently 216.239.38.21 in case that will help
09:31:23 <roconnor> kallisti: sorry, I thought the Seq was abstracted out
09:33:01 <zzo38> nus: Does that help?
09:33:50 <nus> zzo38, no luck
09:34:13 <zzo38> Can you connect to my computer?
09:34:26 <killy> Anyone willing to help a newbie with leksah?
09:35:24 <nus> zzo38, anyway, how does what you have in mind compare with HList?
09:35:26 <killy> I'm having some installation problems
09:35:29 <SubtleArray> I use Leksah. I know a little, but not a lot.
09:35:42 <SubtleArray> killy: Which OS are you using?
09:36:03 <hpc> nus: presumably, you can at least squeeze a modicum of static analysis out of extensible lists
09:36:06 <killy> openSUSE
09:36:16 <SubtleArray> Do you have the Haskell platform installed?
09:36:43 <killy> no, I have most of the Haskell stuff installed from the distribution's repo
09:36:52 <zzo38> nus: But are you able to connect to my computer? I did see some things about HList, and it seems to have various restrictions which my program does not have
09:36:55 <killy> leskah however is not i the packages
09:37:24 <killy> and I'm having problems installing it with cabal
09:37:35 <res_> ew why does Text.XHtml spit out newlines before closing tags
09:37:53 <SubtleArray> So you've already tried typing in this cabal install gtk2hs-buildtools
09:38:05 <killy> yes
09:38:12 <killy> cabal: cannot configure old-time-1.1.0.0. It requires base >=4.4 && <5
09:38:17 <killy> and that's what I got
09:38:36 <monochrom> it is better to have for-humans whitespaces inside tags than have them outside
09:39:07 <res_> ... hm, point
09:40:09 <SubtleArray> Seems like you need a newer version of Haskell installed. Try installing the complete haskell-platform and trying again. If that doesn't work, you might want to try installing one of the Fedora binaries.
09:40:10 <Jafet> What kind of human reads XHTML?
09:40:10 <killy> it looks that either cabal doesn't recognize stuff that is installed from the packages
09:40:27 <elliott> res_: because whitespace is significant in (x)html
09:40:30 <killy> or package versions are too old
09:40:33 <zzo38> nus: Did you receive the file by now?
09:40:51 <killy> well... I can try
09:41:29 <monochrom> but it is a losing position. humans prefer the complication of: special rules regarding whitespaces right before and after tags
09:42:21 <Jafet> Humans like to pretend HTML is source code
09:42:40 <otters> it's just markup :<
09:42:52 <monochrom> I read and write XHTML
09:43:10 <Jafet> But you're superhuman
09:43:12 <monochrom> but I'm ok if you deny me as a human
09:43:26 <SubtleArray> zypper install haskell-platform should install the needed dependencies
09:43:42 <hpaste> zzo38 pasted ‚Äúextensible-data‚Äù at http://hpaste.org/63474
09:43:43 <killy> yeah, I'm browsing through the repo
09:43:56 <SubtleArray> Unless cabal has to be updated... I remember doing that for something.
09:44:02 <SubtleArray> I'm still kind of a noob myself.
09:44:15 <Jafet> Well, I don't see the point in having editable automatically generated HTML. If you want to change the HTML, change the generator
09:44:48 <zzo38> I prefer command-line what is why I use sprunge. But now I put it on hpaste, and it looks like wrong syntax highlighting because it is four literate Haskell programs concatenated
09:45:18 <CodeWeaverX> Greetings, haskellers.
09:45:51 <killy> nope, the latest version of Haskell Platform in Suse repo is 2010.2 ....
09:45:52 <SubtleArray> Hello. ^_^
09:46:32 <zzo38> The syntax highlight seems broken in more way than one.
09:46:39 <killy> and by the way - I have ghc-base in version 4.3. This explains why cabal complains that it wants 4.4 at least
09:47:14 * hackagebot HipmunkPlayground 5.2.0.6 - A playground for testing Hipmunk.  http://hackage.haskell.org/package/HipmunkPlayground-5.2.0.6 (FelipeLessa)
09:47:34 <SubtleArray> Mmmm... *searching for info*
09:48:10 <monochrom> ghc-base version and ghc version are in bijection. a newer base means a newer ghc
09:48:36 <monochrom> hell, I should say order-isomoprhism :)
09:48:53 <killy> :)
09:49:14 <killy> OK, another noob question - why is the haskell platform source so small?
09:49:32 <killy> I mean it dosn't include ghc, ghc-base, etc, right?
09:49:35 <monochrom> haskell platform source does not include ghc
09:50:40 <eyebloom> Has anyone had luck using Simon Marlow
09:50:49 <eyebloom> 's new profiler?
09:51:07 <killy> "The current Haskell Platform release includes a recent GHC release as well as some other tools (such as cabal), and a larger set of libraries that are known to work together."
09:51:20 <killy> Looks like that part of documentation isn;t up to date
09:51:38 <monochrom> that refers to binary, and it is correct. see the windows installer and the macos installer
09:51:43 <SubtleArray> Would be so nice if everything came with a binary... Depending on dependencies can suck sometimes. :(
09:53:47 <Raphaeljavaux> Hey, i've got some troubles with functional dependencies, someone could look at this ? http://paste.pocoo.org/show/549400/
09:53:54 <killy> would be nice of the packages in the repo were up to date...
09:54:03 <monochrom> binary installers are a refreshing dessert in the oasis of source tarballs and compile-everything-yourself
09:54:26 <hpaste> Carpi pasted ‚Äúneverending‚Äù at http://hpaste.org/63475
09:54:27 <carpi> could someone please tell me what I can do to solve that problem? ^^^
09:54:52 <killy> yes, they are nice if you work on windows
09:55:09 <heisenberg> hi anyone know how to list installed packages with cabal on windows ?
09:55:09 <killy> but if your on linux you just and up with software that has to bu updated manually
09:55:12 <zzo38> Tell me in case thing in http://hpaste.org/63474 your idea/question/comment/opinion/complaint maybe there is some things you might want but is missing?
09:55:18 <res_> speaking of compile-everything-yourself, remind me to never again compile ghc from source
09:55:21 <Jafet> You can't breathe in the dessert, there is no -O2
09:55:28 <monochrom> hahaha
09:55:33 <killy> lol
09:55:34 <djahandarie> Does anyone know what causes this runtime error? "hGetContents: invalid argument (Invalid or incomplete multibyte or wide character)"
09:55:40 <shergill> heh
09:55:49 <djahandarie> Google suggests it has something to do with locales, but I have no idea what locale I'd have to switch to.
09:55:52 <res_> djahandarie: a bad multibyte or wide character, presumably
09:56:17 <djahandarie> Sure, but how do I fix that? The file is 200M.
09:56:25 <killy> ok, I'll be fighting with leksah installation
09:56:29 <res_> I recall getting errors like than when putting in ... characters copied from strange encodings, I think
09:56:38 <Jafet> djahandarie: the file handle whose contents you are trying to get does not contain valid or complete multibyte UTF-8 characters
09:56:44 <Jafet> The locale probably is irrelevant
09:56:47 <killy> and in the meantime I have a different question to all you functional programing experts :)
09:57:09 <killy> I'm starting to learn functional programming
09:57:30 <SubtleArray> This page has some info on how to deal with dependency issues. It might have some info. http://www.haskell.org/haskellwiki/Leksah_Installation
09:57:33 <monochrom> you can set encoding/decoding per Handle
09:57:46 <killy> it's fun, especially fold left and fold right and I like the idea of passing functions as variables
09:57:55 <killy> (thanks SubtleArray)
09:57:59 <monochrom> of course that assumes you know which decoding you want
09:58:19 <killy> but I don;t see any diference between that and passing function pointers in C
09:58:29 <killy> except for the syntax, which is nicer
09:58:32 <monochrom> the locale is relevant if you don't set encoding/decoding yourself
09:58:58 <Jafet> You can read any text, assuming you know the language it's in
09:59:18 <monochrom> read http://www.haskell.org/ghc/docs/latest/html/libraries/base-4.5.0.0/System-IO.html#g:23
09:59:30 <Jafet> The environmental locale?
09:59:50 <kallisti> killy: the difference is that you can create functions on the fly, whereas with function pointers you have to define them as top-level functions and then address them.
09:59:55 <zzo38> HList seems to be extremely complicated compared with my program and still requires extended operations to be explicit and requires extended labels to know the previous label to form a chain. My program does not have these restrictions.
10:00:05 <kallisti> killy: also closures and currying are waaay more difficult to do in C.
10:01:02 <killy> yes, that's true, but still it would be possible to implement folds in C, providing that functions passed to fold would be programmed in the code, right?
10:01:32 <kallisti> you wouldn't be able to generalize it safely to any type
10:01:41 <kallisti> without the use of void pointers, casting, or macros.
10:01:42 <killy> point
10:01:56 <kallisti> also, closures.
10:01:59 <kallisti> still a problem.
10:02:11 <killy> don't think that closures are possible in C
10:02:17 <kallisti> but yes a fold function is certainly possible.
10:02:23 <kallisti> of some sort.
10:02:40 <killy> although I recall Paul Graham showing a C++ version of closure on his webpage :)
10:02:57 <kallisti> C++11 now has lambdas with explicit closures.
10:02:59 <Jafet> C http://codepad.org/BKZS1Ct0
10:03:14 <monochrom> if you use Data.ByteString.* to read the file, you will not need to worry about decoding, but you will have undecoded raw bytes
10:03:30 <killy> yes, making the C++ standard even more cluttered....
10:03:32 <zzo38> hpaste appears to be syntax highlighting what I specified as "Literate Haskell" as Visual Basic code.
10:03:54 <Jafet> You'd use Data.Text.Encoding to decode them, assuming it implements your encoding
10:04:08 <Jafet> hGetContents on a 200M file already sounds questionable
10:04:17 <zzo38> But if you look at the root page the list clearly says "Literate Haskell"
10:04:27 <zzo38> Can you fix hpaste?
10:10:35 <killy> wow, ghc binary distribution is almost 1GB after extracting...
10:12:16 <parcs`> it comes with 2 extra copies of each library, one for profiling and one for dynamic linking
10:12:24 <hpaste> Jafet pasted ‚ÄúTuppence‚Äù at http://hpaste.org/63478
10:12:45 <killy> and 'make install' installs everything?
10:12:55 <Jafet> It looks like Literate Haskell is meant to be illegible.
10:13:10 <res_> "ghc: panic! (the 'impossible' happened)
10:13:58 <elliott> <Jafet> The locale probably is irrelevant
10:14:05 <elliott> Jafet: No it's not.
10:14:09 <elliott> Oh, monochrom already corrected.
10:14:19 <elliott> res_: report a bug
10:14:21 <parcs`> killy: yep
10:15:55 <res_> elliott: yeah, ghc said as much, too
10:15:59 <killy> no, I don't believe this dependency hell is really happening in year 2012...
10:16:03 <res_> the message is amusing, though
10:16:18 <osa1> I can't install snap web framework with cabal, here are my logs: http://paste.pocoo.org/show/549408/ can anyone help me?
10:16:22 <Jafet> The inconceivable happened
10:16:54 <SubtleArray> I hate to say this, but I didn't have that dependency issue with Fedora and Ubuntu. >_< Suse is a great OS, but they need to keep up.
10:16:57 <monochrom> GHC's binary tarball has an INSTALL or INSTALL.txt. it says "./configure --prefix=blah" and "make install"
10:17:15 <killy> I can;t install leksah because it requires newer base (I had ghc 7.0.4), so I download ghc 7.4.1. Now when I try to compile haskell platform it complains that it works only with ghc 7.0.4 and other versions of compiler are unsupported
10:17:43 <SubtleArray> >_<
10:17:54 <monochrom> I don't believe that leksah is so updated that it wants 7.2 or 7.4
10:18:02 <elliott> killy: it's correct, haskell platform is tied to ghc version
10:18:16 <elliott> killy: you will have to install cabal-install yourself and install packages as you need it, or downgrade GHC
10:18:25 <elliott> (haskell-platform === just a collection of cabal packages)
10:18:32 <elliott> (on Unix)
10:18:34 <killy> or use  --enable-unsupported-ghc-version
10:18:46 <kallisti> sounds fun.
10:18:46 <elliott> killy: have fun spending hours fixing it when it breaks
10:18:55 <elliott> the haskell platform includes certain fixed package versions
10:18:59 <elliott> packages which are updated as new GHCs come out
10:19:00 <killy> already spending hours trying to make it work :)
10:19:14 <elliott> yes, when you could spend five minutes to install cabal-install and "cabal install whatineed"...
10:19:17 <elliott> and it'd actually work at the end of it
10:19:19 <res_> --eneable-unsupported-ghc-version ... does not work very well
10:19:33 <mekeor> is hackage slow or is my internet slow?
10:19:34 <Jafet> elliott: unless you did it in the wrong order
10:19:42 <kallisti> elliott: hours + more hours > hours + more minutes.  thus better
10:19:45 <killy> leksah requires gtk2hs which requires gtk2hs-buildtools which requires ghc-base 4.4 at least and ghc 7.0.4 has base 4.3
10:19:45 <srhb> mekeor: Hackage is crawling.
10:19:48 <SubtleArray> Reminds me of the hell I went through trying to get Eclipse to work. One of the reasons why I use vim for everything (except Haskell) is because it takes no effort to install. Lol
10:19:57 <elliott> killy: you could just install an older gtk2hs.
10:20:06 <kallisti> res_: I couldn't possibly imagine why.
10:20:08 <elliott> if leksah's bounds admit it
10:20:12 <mekeor> srhb: argh -.-
10:20:17 <mekeor> srhb: why?
10:20:23 <srhb> mekeor: No idea. It just is.
10:20:35 <srhb> mekeor: It's intermittent though.
10:20:45 <mekeor> srhb: ok. thanks anyway.....
10:20:46 <killy> ok, one more attempt, I'll download ghc 7.0.4, but I'll install it from source, not from distro pakckages
10:20:58 <killy> how can I install older gtk2hs?
10:21:06 <res_> have fun with compiling from source!
10:21:06 <Jafet> You cannot install it from source before you compile it from source.
10:21:09 <kallisti> is there a dev channel or mailing list specifically for ghc-pkg?
10:21:13 <elliott> killy: Are you sure GHC 7.0.4 will build with GHC 7.4.1?
10:21:19 <elliott> I doubt that is supported.
10:21:31 <elliott> install older gtk2hs is "cabal install gtk2hs-buildtools==somever" then same with gtk
10:21:54 <elliott> kallisti: #ghc, perhaps
10:21:54 * kallisti didn't have to compile GHC from source.
10:22:08 <kallisti> there's pre-compiled binaries.
10:22:17 <kallisti> perhaps I'm missing something..
10:22:32 <monochrom> gtk2hs requires new ghc? I don't believe that either
10:22:38 <killy> no, I meant the binary
10:22:46 <mekeor> hehe
10:22:51 <killy> not source, sorry :)
10:23:13 <elliott> indeed, I don't see why: http://hackage.haskell.org/package/gtk2hs-buildtools
10:23:56 <monochrom> whose binary?
10:25:58 <monochrom> I seriously believe that you are barking up the wrong tree. you have some other problem and you misjudge it as "this package wants new stuff"
10:26:24 <killy> quite likely
10:26:31 <monochrom> or even "this package has version mismatch"
10:27:12 <killy> ok, I'm downloading ghc 7.0.4
10:28:51 <SubtleArray> Does anyone know how to make the getLine function execute on the same line of a string? I'm trying to create a prompt like this ">" and have the user enter their input next to that prompt, but getLine always takes them to the next line.
10:29:00 <SubtleArray> If that makes any sense...
10:29:19 <Botje> SubtleArray: look up hFlush
10:29:26 <Botje> hFlush stdout, to be precise
10:29:30 <Jafet> Stop printing a newline after the ">"
10:30:12 <SubtleArray> *looking up hFlush*
10:30:15 <Sgeo> SubtleArray, it's not a feature of getLine, but a feature of what you're printing to the screen before it
10:30:31 <Sgeo> So use putStr instead of putStrLn, and use hFlush stdout after the putStr
10:30:43 <Sgeo> putStrLn puts a newline after what it prints
10:32:05 <edwardk> SubtleArray: you need to learn to flush ;)
10:32:37 <monochrom> stdout is not a toilet
10:32:46 <SubtleArray>  :D
10:32:54 <edwardk> i dunno, some of the things i send there..
10:33:02 <SubtleArray> I found this. Looks like someone else was trying to do the same thing. putStr "> "; hFlush stdout
10:33:12 <SubtleArray> But that line kind of upsets my case statement. I'll work on it.
10:33:27 <SubtleArray> Thanks. ^_^
10:33:30 <Botje> SubtleArray: why?
10:33:30 <edwardk> SubtleArray: are you trying to prompt the user and want them to be able to edit the input nicely?
10:33:32 <kallisti> SubtleArray: might need a do?
10:33:38 <edwardk> you can use haskeline for that
10:34:01 <hpaste> DanBurton pasted ‚Äúwhen isjust fromjust anitpattern?‚Äù at http://hpaste.org/63482
10:34:07 <edwardk> and that gives you a lot of extra stuff like savable history, line editing tools, etc.
10:34:21 <elliott> DanBurton: No :(
10:34:30 <elliott> DanBurton: T.forM_ m putStrLn
10:34:36 <edwardk> DanBurton: always
10:34:38 <elliott> *F.foldM_, actually
10:34:39 <elliott> er
10:34:41 <elliott> *F.forM_
10:34:43 <elliott> god dammit
10:34:46 <DanBurton> wat
10:34:47 <SubtleArray> edwardk: I'm trying to make a little natural language thing, and I'd like for there to be a "> " to give kind of prompt for input.
10:34:53 <elliott> DanBurton: import qualified Data.Foldable as F
10:34:56 <edwardk> its always an antipattern ;)
10:34:58 <DanBurton> mkay
10:35:00 <elliott> F.forM_ m putStrLn
10:35:05 <DanBurton> there we go :)
10:35:11 <edwardk> SubtleArray: look at haskelline
10:35:23 * kallisti is still not entirely convinced it's an anti-pattern...
10:35:29 <edwardk> http://hackage.haskell.org/packages/archive/haskeline/0.6.4.6/doc/html/System-Console-Haskeline.html
10:35:35 <DanBurton> isJust / fromJust is Just Nasty
10:35:49 <edwardk> kallisti: if nothing else its needlessly inefficient, since both the isJust and the fromJust are pattern matching on the input
10:36:11 <edwardk> and it would be better done with the forM_ trick elliott described above
10:37:08 <elliott> Or "case".
10:37:46 <edwardk> case tends to be more syntactically invasive and not fit well with the following statements though
10:37:47 <DanBurton> I used "case" at first, but was annoyed at how large it was for such a simple operation
10:38:04 <edwardk> forM_ m is pretty clean
10:38:17 <elliott> edwardk: yeah, case lets you handle the Nothing alternative though :P
10:38:24 <edwardk> yep
10:39:26 <killy> OK, one more attemptt to installing leksah. I've installed ghc 7.0.4 and cabal-install 1.10.2.0
10:40:35 <otters> :t (.)
10:40:35 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
10:41:10 <kallisti> :t (.).($)
10:41:11 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
10:41:21 * kallisti doesn't remember how to do that with (.)
10:41:33 <killy> elliott: cabal install gtk2hs-buildtools==0.11.2 doesn't work either
10:42:14 <DanBurton> kallisti: caleskell has a deep magic definition of (.)
10:42:22 <kallisti> DanBurton: I'm aware.
10:42:25 <elliott> killy: the latest version is fine.
10:42:33 <elliott> killy: please paste your cabal-install error from "cabal install gtk2hs-buildtools".
10:42:46 <killy> no, because I get dependency problems - that's my whole problem...
10:42:47 <killy> sure
10:43:00 <monochrom> paste everything
10:43:32 <kallisti> :t (?f$).(?g$)
10:43:34 <lambdabot> forall a b a1. (?f::a -> b, ?g::a1 -> a) => a1 -> b
10:43:44 <hpaste> killy9999 pasted ‚Äúcabal error‚Äù at http://hpaste.org/63484
10:43:47 <edwardk> :t (.).(.).(.).(.)
10:43:48 <lambdabot> forall (f :: * -> *) (f1 :: * -> *) (f2 :: * -> *) a b (f3 :: * -> *). (Functor f, Functor f1, Functor f2, Functor f3) => (a -> b) -> f (f1 (f2 (f3 a))) -> f (f1 (f2 (f3 b)))
10:44:24 <Taneb> I'm trying to think of a version of Haskell using a Scratch-like interface
10:44:45 <monochrom> then old-time is too new
10:44:55 <CodeWeaverX> Mmm fulla breakfast foodz
10:45:07 <monochrom> wait, old-time is supposed to come with ghc already
10:45:53 <killy> perhaps old-time has too old version ?
10:46:03 <killy> as you can see may ghc-base is too old
10:46:14 <monochrom> no, wrong interpretation
10:46:26 <killy> my old time is 1.0.0.6
10:46:30 <SubtleArray> Funny, all my searches for 'haskell line' are not about haskell line, but about how the code lines up, etc. Ha.
10:46:37 <elliott> SubtleArray: haskeline
10:46:43 <SubtleArray> Google needs AI.
10:47:10 <monochrom> yes and that will work fine with gtk2hs and everything. there is no reason why cabal-install would attempt old-1.1.0.0 unless something else is broken
10:47:37 <killy> well... it attempts to install it for some reason
10:47:45 <monochrom> I want to see your "cabal install --dry-run gtk2hs-buildtools"
10:47:58 <Saizan> add -v3 for more details
10:48:25 <monochrom> I bet you, Saizan, that -v3 tells you tautologies only
10:48:37 <hpaste> killy9999 pasted ‚Äúcabal error‚Äù at http://hpaste.org/63485
10:48:57 <killy> dry-run gives exactly the same output
10:49:38 <killy> -v3 gives some more info, although hard for me to tell where it goes wrong
10:50:49 <monochrom> I now want to see your "ghc-pkg list -v"
10:50:52 <DanBurton> are there any other automated code style checkers besides hlint and ghci -Wall ?
10:50:59 <DanBurton> (for Haskell)
10:51:56 <hpaste> killy9999 pasted ‚Äúcabal error‚Äù at http://hpaste.org/63486
10:52:38 <monochrom> why are there so few packages under "/usr/lib64/ghc-7.0.4/package.conf.d"?
10:53:11 <monochrom> GHC comes with like 20 packages
10:53:27 <Saizan> looks like a distro that wants to be too modular
10:53:37 <killy> I installed from my distributions repo
10:53:51 <killy> and I installed a minimum set of packages
10:54:01 <monochrom> well ok then you will have to hunt down all the missing packages
10:54:11 <killy> which are?
10:54:51 <monochrom> also it is very broken to have two instances of for example mtl-2.0.1.0. drop the "user" one
10:55:08 <Saizan> --constraint="old-time == 1.0.0.6" could also work here
10:55:18 <Rc43> Hi.
10:56:17 <killy> dropped the user packages, it's only the cache
10:56:52 <tsousa> i read some chapters from LYAH. can you guys recommend me some project to work one?
10:56:57 <tsousa> some easy one
10:57:02 <killy> hm...
10:57:12 <killy> OK, I should have more packages
10:57:19 <monochrom> http://www.haskell.org/ghc/docs/7.0.4/html/users_guide/release-7-0-2.html#id499282 has list of packages. version numbers are for 7.0.2, but the names are correct
10:57:20 <mandaya> @tsousa: something that interests you :)
10:57:21 <lambdabot> Unknown command, try @list
10:57:21 <killy> I mean I have more packages from the repo
10:57:44 <mandaya> @tsousa: wants something you'd like to have?
10:57:44 <lambdabot> Unknown command, try @list
10:57:45 <tsousa> mandaya, i really dont have any ideia lol
10:58:15 <Rc43> > runCommand "echo 'suddenly' > hello.msg"
10:58:15 <lambdabot>   Not in scope: `runCommand'
10:59:13 <mandaya> tsousa: you could always work through the scheme in 48 hours book; gives you an idea of how libraries work in haskell, and you get an interpreter to play with afterwards
10:59:38 <mandaya> tsousa: but the best idea is to pick something you'd like to have, and doing what it takes to make it work
11:00:17 <monochrom> http://www.vex.net/~trebla/haskell/sicp.xhtml#unsafeInterleave is probably too much information for you for now, the short story is that interleaving "get from repo" and "cabal install" is highly broken. you will have to decide on a point of time and say: before that time, exclusively get from repo; after that time, exclusively get from "cabal install"
11:01:02 <monochrom> and of course, "cabal install" comes with its risk of defaulting to some too-new versions that mismatches you
11:01:48 <monochrom> "get from repo" comes with its risks for not finding a package
11:02:23 <tsousa> it's best for me to read the LYAH book or change to Real World Haskell?
11:02:25 <killy> Well, I can have base packages from repo and additional from cabal
11:02:52 <elliott> killy: You have distro packages on top of a user-installed GHC binary?
11:03:06 <elliott> Are you trying to end up with as broken a system as possible?
11:03:10 <monochrom> does your repo have a meta-package for haskell platform? that simplifies the whole story. it is a good dividing point
11:03:13 <killy> no, ATM I have only distro packages
11:03:21 <monochrom> no, distro ghc and distro libs
11:03:24 <mandaya> tsousa: both are very good, if you can't pick, just use both :). They both cover material the other doesn't
11:03:49 <tsousa> the problem is that LYAH doesnt have exercises
11:03:56 <monochrom> the distro ghc is 7.0.4 which is the good part. the bad part is religious package fragmentation
11:04:01 <mandaya> ahh
11:04:01 <fryguybo1> hg branches
11:04:21 <mandaya> I like project euler for straightforward problems to work on
11:04:23 <monochrom> these fundamentalists even split out old-time as a separate rpm or something
11:04:27 <mandaya> and a ramping sequence
11:04:42 <elliott> Project Euler is probably bad for Haskell beginners.
11:05:06 <mandaya> think so? I used it pretty successfully. *shrug*
11:05:22 <elliott> How many stack overflows did you have to deal with?
11:05:37 <mandaya> not too many until I was pretty deep into them
11:05:53 <elliott> Hmm.
11:05:56 <killy> there's a meta package for haskell-platform, but for 2010.2 version
11:05:57 <mandaya> I've solved the first 50 or so in a variety of languages though
11:06:04 <killy> which is pretty old...
11:06:05 <mandaya> so maybe I'm a bad test case
11:06:20 <mandaya> but that's been my fallback need to learn a new language
11:06:58 <monochrom> project euler is a great way to learn list comprehension and then wondering why brute force is so slow and memory-hog
11:06:59 <killy> and yes, old-time is a seperate package, but yast solves dependencies so that's not a real problem
11:07:34 <elliott> looks like it didn't solve your dependency problem here.
11:07:54 <mandaya> I'll defer to more experienced people, but I like it for tackling new languages
11:08:14 <monochrom> "the distro figures out dependencies" is totally useless if the distro is not comprehensive in packages
11:08:17 <elliott> paradigm shift + dealing with strictness issues + having to write efficient programs in an unfamiliar style
11:08:22 <elliott> = not very good newbie choice
11:08:48 <killy> well... the rpm is installed
11:09:02 <killy> so the question is how to make ghc aware of it...
11:09:13 <SubtleArray> Just spend the last 20 minutes looking for this... Giving up. Begging for help now. Anyone know how to install Haskell Line? -__-
11:09:32 <monochrom> "ghc-pkg list -v" shows you what is awared
11:09:45 <killy> not much, as we have seen
11:09:55 <monochrom> then it's falling apart
11:09:56 <Saizan> SubtleArray: it's haskelline as a single word
11:10:05 <tsousa> can i code let's say a app to download some files online, as easy as i do in python?
11:10:07 <Saizan> SubtleArray: and you do it by "cabal install haskelline"
11:10:07 <killy> I mean the directory /usr/lib64/ghc-7.0.4 is full of packages
11:10:16 <elliott> SubtleArray: I already told you it's "haskeline" :P
11:10:17 <SubtleArray> I was using 3 Ls. >_<
11:10:21 <elliott> maybe too obscurely
11:10:30 <elliott> Saizan is wrong too
11:10:31 <elliott> one l
11:10:31 <monochrom> last resort is "sudo ghc-pkg recache"
11:10:32 <Saizan> SubtleArray: sorry, 1 l
11:10:36 <elliott> http://hackage.haskell.org/package/haskeline
11:10:38 <Saizan> SubtleArray: haskeline
11:10:39 <elliott> SubtleArray: "cabal install haskeline"
11:10:49 <daniel31415> hey guys - whats the most common gui-framework used in haskell - could this be wx or is it rather unusual?
11:11:01 <elliott> daniel31415: wx and gtk
11:11:05 <daniel31415> ty
11:11:16 <SubtleArray> >:U
11:11:25 <killy> nope, recache doesn;t work either
11:11:26 <SubtleArray> Thanks. *puts on glasses*
11:12:02 <SubtleArray> I was sitting here using 2 Ls and 3... Ha. No wonder I couldn't find anything.
11:13:55 <tsousa> which module you guys use to download file from the web?
11:14:21 <elliott> tsousa: http-conduit or HTTP
11:14:32 <elliott> HTTP is standard, http-conduit is more capable and has a nicer interface for simple things
11:14:39 <elliott> (standard as in "everyone has it")
11:14:45 <elliott> http://hackage.haskell.org/package/http-conduit, http://hackage.haskell.org/package/HTTP
11:20:19 <scolobb> Hello :-)
11:20:35 * shapr hugs DrSyzygy 
11:20:42 <scolobb> edwardk: Good to hear that you're going to run the GSoC this year as well
11:21:33 <edwardk> its going to be an interesting year since we're switching all the funding over to SPI, etc.
11:21:47 <scolobb> I wanted to ask you whether there are come procedures I have to undergo before I can count as a valid applicant
11:21:56 * hackagebot haskell-updater 1.2.0.5 - Rebuild Haskell dependencies in Gentoo  http://hackage.haskell.org/package/haskell-updater-1.2.0.5 (SergeiTrofimovich)
11:22:28 <scolobb> (I have reached David Terei and we have started the discussion about the ticket http://hackage.haskell.org/trac/ghc/ticket/4213 )
11:23:13 <scolobb> edwardk: Oh, sorry, I don't think I can meaningfully evaluate SPI :-(
11:23:40 <scolobb> I mean, I don't know what SPI is
11:23:49 <edwardk> basically we put everything into an umbrella organization that manages money for open source projects
11:24:00 <edwardk> so we'll have a different set of hoops to jump through
11:24:17 <scolobb> Hm, I see
11:24:36 <scolobb> I hope the switch will have minimised the number of hoops, though :-)
11:25:18 <edwardk> it will
11:25:18 <edwardk> its a very good move overall
11:25:25 <edwardk> just going to make my life interesting this month
11:26:13 <shapr> I wonder if a propaganda GSoC project counts as purely documentation?
11:26:15 <byorgey> scolobb: I don't think there are any special procedures.  It sounds like you're already doing the most important things (have conversations with people in the community, research potential projects, etc.)
11:26:35 <shapr> I want to write tutorials and demo apps for under-used libs like HaskellNet.
11:26:40 <scolobb> byorgey: OK, thank you for the feedback :-)
11:27:01 <byorgey> shapr: It should, IMO.  No idea if it does.
11:27:05 <edwardk> the best tip i can give you in ters of past acceptance of projects is to put in a couple of different proposals
11:27:29 <shapr> So, no GSoC for me then :-(
11:27:36 <scolobb> edwardk: I've seen Johan Tibell was an admin last year as well; it he's going to take up the task this year as well, there's going to be less stress for both of you
11:27:38 <edwardk> that lets the folks ranking projects have a couple of options for how to slot you in to the line up
11:27:56 <edwardk> shapr: why not? mentor to student would be fun =)
11:28:05 <byorgey> shapr: I said "I have no idea", not "it doesn't count" =)
11:28:06 <scolobb> edwardk: Yes, that's what I'm planning to do
11:28:09 <shapr> byorgey: ah :-)
11:28:24 <edwardk> scolobb i haven't pinged him to see if he's available yet. it was nice having the backup last year though
11:28:27 <scolobb> As far as I know, it's the org that decides if a project idea is valid or not :-)
11:28:55 <shapr> edwardk: Just thinking I'm most qualified to remedy gwern's "lack of propaganda" point against prior GSoCs, figured I could propose a code+advertise sort of project.
11:29:07 <scolobb> edwardk: He did say a couple words about GSoC on haskell-cafe about 4-5 days ago, but I didn't manage to get any feedback by mailing him directly
11:29:07 <edwardk> scolobb: yes. the trick is we have more applications than slots, so having more options about how to slot people in and what projects to run, ratios, etc helps a lot
11:29:08 <shapr> Like, tutorials and demo apps and cheerleading.
11:29:23 <edwardk> shapr: hah
11:29:31 <scolobb> Sounds like he's on vacation; he's offering some interesting projects ideas though, so I'm rather willing to contact him
11:29:36 <edwardk> yeah
11:29:41 <edwardk> he had a good list last year as well
11:30:19 <tsousa> Does Haskell has some limitation in writting scripts? because i do mailny it
11:31:13 <Plembo> Does anyone have any advice on how best to attack this problem: http://pastebin.com/uBXPpFLN -- basically I want to find the best path to the top row from the bottom that reuslts in the largest value. The rules are that I can only move directly down, diagonally left or diagonally right. So I can't get 0, 0 in row 0 and then 4, 4 in row 1
11:31:15 <mauke> The paste uBXPpFLN has been copied to http://hpaste.org/63489
11:31:16 <scolobb> tsousa: What's a script for you?
11:31:26 <byorgey> tsousa: what's a limitation for you?
11:31:32 <Plembo> So I imagine the firs tapproach is converting the etnire board int osomething like the bottom board, and then using that to figure ou twhich path to an element in row 1 is ideal
11:32:07 <scolobb> Plembo: Arrays and mutable arrays?
11:32:07 <tsousa> download stuff from the web, management scripts that kind of stuff but i want it to be powerfull enought for me not to change the language every time i have something bigger
11:32:22 <Plembo> scolobb, oh, one other stipulation: I must use lists
11:32:32 <scolobb> Hm
11:33:01 <shapr> Plembo: Turn the lists 'sideways', Generate a powerset, pick the largest result?
11:33:12 <scolobb> Plembo: Obviously, the initial matrix can be stored in a list of lists (just thinking aloud for a while)
11:33:26 <Plembo> Right, that's whole  I store the list currently schlobb.
11:33:46 <Plembo> shapr, I'm not entirely sure how I would do that
11:33:47 <scolobb> shapr: This problem can be solved in O(n^2) :-)
11:34:10 <mandaya> tsousa: are you stuck on the downloading files off the web problem?
11:34:19 <Plembo> I just started programmingin Haskell two days ago. I understand how to solve the problem in English, but translatnig it into Haskell is really tough so far
11:34:24 <Plembo> I know I want to find the highest valued element in row 0
11:34:33 <Plembo> to find that I have to find the best path to an item in row 0
11:34:34 <Plembo> then for row 1
11:34:36 <Plembo> so on adn so forth
11:34:37 <tsousa> mandaya, no, but it's something i do lol
11:34:48 <scolobb> tsousa: When something gets bigger, it stops being a simple script, really :-) But yeah, you can do lots of stuff with Haskell
11:35:01 <scolobb> tsousa: Not sure it's the best option for this kind of stuff though
11:35:10 <mandaya> no, I meant that you asked about that before, and I was wondering if you'd already attempted the problem
11:35:21 <mandaya> and had gotten stuck somewhere
11:35:23 <augur> whats the difference between a stream and a lazy list in haskell?
11:35:27 <augur> ive never understood this
11:35:45 <tsousa> mandaya, i will implement it today, i have a script in python
11:35:49 <scolobb> Plembo: Correct me if I'm wrong: you are trying to implement a dynamic programming algorithm?
11:35:57 <tsousa> i will try to implement it in haskell today
11:35:58 <Plembo> I believe I am, scolobb. Yes.
11:36:07 <Plembo> At least based on the solution I havein mind
11:36:19 <mandaya> the python script and the haskell version won't look very much alike
11:36:30 <mandaya> in some sense, you're better off starting from scratch
11:36:33 <scolobb> The problem with dynamic programming is that it's very often heavily based on random-accessed arrays
11:36:50 <scolobb> Where does the limitation to only use lists arise from?
11:37:00 <Plembo> I've only learned about lists so far
11:37:06 <Plembo> this is more academic than anything else
11:37:10 <Plembo> nothin gwhere I'm worried about efficiency
11:37:13 <scolobb> tsousa: What's wrong with Python for you? :-)
11:37:15 <Plembo> it's more about learning how to make it work
11:37:31 <tsousa> scolobb, nothing. i just want to learn something new
11:37:43 <mandaya> that's a good reason
11:37:49 <scolobb> tsousa: Aha :-) Then go ahead, Haskell has a lot of that to offer :-)
11:37:53 <tsousa> Haskell seems fun from what i have learned, but i had never did something more real with it
11:38:21 * scolobb can't forget how it took him ~1.5hrs to write something Like while(1){}
11:38:32 <mandaya> then yea, give the downloading files problem a shot, and let us know if you get stuck
11:38:35 <scolobb> Plembo: I see
11:38:50 <scolobb> Well, in that case there's a solution, of course
11:39:13 <tsousa> mandaya, thanks
11:39:16 <scolobb> It's far from being efficient and clever, but it does bring forward a couple specific things about functional programming
11:39:21 <SubtleArray> Why is something so simple so damn difficult... Is there no easy way to put a string before a getLine?
11:39:30 <tsousa> mandaya, i probably will learn more about monads and monoid and stuff like that
11:39:38 <elliott> augur: Streams are infinite.
11:39:41 <tsousa> i am reading the functors chapter of LYAH
11:39:49 <scolobb> SubtleArray: What do you mean "put a string before a getLine"? :-)
11:39:50 <SubtleArray> Sorry. Woo-sah... Must calm down.
11:39:55 <augur> elliott: lazy lists can be infinite too
11:40:04 <elliott> SubtleArray: it's difficult because you don't know how to do it
11:40:06 <Plembo> scolobb, exactly, that's the goal. Do you have any tips on how to attack the problem?
11:40:09 <elliott> augur: Lazy lists can be finite.
11:40:12 <augur> elliott: so do you mean that streams are /necessarily/ infinite?
11:40:14 <scolobb> Plembo: You can store the second array as a list as well
11:40:16 <elliott> data List a = Nil | Cons a (List a)
11:40:20 <elliott> data Stream a = Cons a (Stream a)
11:40:21 <scolobb> Plembo: Just a moment, lemme check
11:40:24 <Rc43> http://www.haskell.org/pipermail/beginners/2011-August/008426.html
11:40:24 <augur> ahhhh i see
11:40:28 <Rc43> Anybody knows answer?
11:40:41 <Rc43> (about cabal-dev ghci)
11:41:33 <mandaya> tsousa: LYAH has a very good explanation of those topics, but I think it takes a few readings and a lot of different examples to really get the idea
11:41:42 <SubtleArray> In my case statement I have this. [] -> getLine It's triggerd if there aren't any command line arguments. I want there to be a "> " before the cursor in the CLI to give the user some kind of indicator that the program is waiting for input.
11:41:53 <mandaya> tsousa: don't feel discouraged if you don't get it immediately, it's far from essential at this point
11:42:14 <SubtleArray> In C++, it's as simple as cout << "> "; and then cin >> userInput; Everything happens on the same line.
11:42:18 <mandaya> tsousa: they're very cool ideas though, and as long as you're here to learn new things, give it a shot
11:42:30 <SubtleArray> I'm trying to do the same thing in Haskell, but it's about 3,000,000 times more involved.
11:42:44 <scolobb> SubtleArray: Show us your current Haskell version
11:42:54 <scolobb> I mean, pastebin
11:43:23 <tsousa> mandaya, yes i am here to learn, and make some projects with it. i fact i want to do some projects. i only did some small projects, it's time for me to evolve
11:43:57 <mandaya> tsousa: yea, I'm saying don't let monads and monoids get in the way of that. Some people get hung up on it.
11:44:03 <Botje> SubtleArray: no, it's not.
11:44:17 <tsousa> mandaya, is it hard?
11:44:17 <Botje> SubtleArray: cout << "> "; does not print anything to the screen.
11:44:36 <Botje> SubtleArray: only if you do cout << "> " << flush; or set cout to not be buffered.
11:44:42 <mandaya> tsousa: they have a reputation for being hard, but it depends on your background
11:44:57 <tsousa> mandaya, how is that?
11:45:07 <SubtleArray> http://pastebin.com/raw.php?i=jnLBcJbq
11:45:09 <mauke> The paste jnLBcJbq has been copied to http://hpaste.org/63491
11:45:15 <Botje> SubtleArray: putStr "> " >> hFlush stdout >> getLine
11:45:29 <Botje> or do { putstr "> "; hFlush stdout; getLine }
11:45:37 <scolobb> Plembo: Give me a couple more seconds to see how to show you my idea with lambdabot :-)
11:45:46 <Plembo> scolobb, can do! :) Thanks a lot!
11:46:09 <mandaya> they're a very abstract concept. For some people that's hard, for others not so much.
11:46:09 <scolobb> > let mutate idx newVal list = take idx list ++ [newVal] ++ drop (idx + 1) list
11:46:10 <lambdabot>   not an expression: `let mutate idx newVal list = take idx list ++ [newVal] ...
11:46:17 <scolobb> Heh
11:46:45 <scolobb> OK, I guess I give up :-)
11:46:58 <scolobb> Nevertheless, Plembo, I think you are getting the idea now
11:47:18 <scolobb> mutate takes list and returns another list which has newVal at idx, instead of the old value
11:47:43 <dmwit> :t foldr
11:47:44 <lambdabot> forall a b. (a -> b -> b) -> b -> [a] -> b
11:47:59 <Plembo> scolobb, I'm still a bit puzzled about the jump from there to figuring out the bes tpath
11:48:00 <Plembo> I mean
11:48:10 <Plembo> and being abl eto record that path as well
11:48:22 <SubtleArray> Botje: That worked! putStr "> " >> hFlush stdout >> getLine
11:48:33 <tsousa> mandaya, but the change from the imperative to functional is a bit hard
11:48:48 <SubtleArray> What are these called in Haskell? >> I need to add them to my research list.
11:48:53 <SubtleArray> Thank you.
11:49:00 <Botje> >> is just a stupider version of >>=
11:49:01 <Ralith> tsousa: monads are simple if you just start using them.
11:49:21 <mandaya> tsousa: yea, the easiest way I found was to pretend I was learning to program from scratch. And yep, ralith is right.
11:49:24 <Botje> SubtleArray: if you're going to be doing this a lot, best make a prompt function
11:49:29 <scolobb> Plembo: Basically, mutate allows you to do list[3] = 14
11:49:37 <Ralith> I got hung up on monads for a long time
11:49:38 <scolobb> Plembo: The whole point is the following
11:49:47 <Ralith> but then I said "screw understanding these I'm just going to use them anyway"
11:49:52 <Ralith> and now I have a solid basic grasp
11:50:08 <killy> being a haskell newbie, I'm wondering what are the main applications of Haskell
11:50:21 <companion_cube> I'd say "write programs"
11:50:31 <scolobb> Plembo: When you want to change the element a[i,j], you have to invoke mutate two times (to change the element j in row i, and then to change i-th entry in the list of row)
11:50:41 <scolobb> s/list of row/list of rows/
11:50:50 <scolobb> Plembo: Am I being at least a little clear?
11:51:01 <mandaya> scolobb: wouldn't the pure list approach be easier if that's all he's familiar with?
11:51:01 <killy> yes, but in what applications does it stand above other languages
11:51:06 <tsousa> is http module on Haskell Plataform ?
11:51:09 <Plembo> That does make more sense, but the part that's unclear is where I get the values to mutate my list
11:51:10 <Plembo> I mean
11:51:18 <SubtleArray> Botje: Sounds like a good plan. Thanks again. Thanks all. Back on track now. Headache subsiding. Ha. So frustrating when I can't intuitively figure out solutions. Guess I need to read more books.
11:51:20 <Plembo> to get the bottom array in this case: http://pastebin.com/uBXPpFLN
11:51:20 <mauke> The paste uBXPpFLN has been copied to http://hpaste.org/63489
11:51:23 <Plembo> that seems like a good solution
11:51:30 <Plembo> but I can't figure out the code to accomplish that
11:52:20 <companion_cube> killy: the applications where the programmer feels more comfortable with it
11:52:34 <scolobb> mandaya: I think that's what I'm trying to do: I'm only talking about lists
11:52:46 <scolobb> (But feel free to correct, I'm far from being an expert)
11:52:56 <mandaya> scolobb: ahh, sorry, I thought you were getting into arrays
11:53:01 <Botje> SubtleArray: beating your head against the subject will eventually shake loose something :)
11:53:10 <killy> still not a good answer, I mean is Haskell good in e.g. image processing?
11:53:25 <mandaya> killy: I'm working on that :)
11:53:26 <killy> I know it's a general purpose language
11:53:50 <mandaya> killy: more seriously, there are good libraries for a variety of different things
11:53:53 <killy> but there are certainly things in which it is better and things in which it is not
11:54:27 <scolobb> Plembo: I usually consider walking from the top-left corner to the bottom-right corner
11:54:41 <mandaya> killy: I understand that it has several very good web frameworks, fantastic parallel programming support, etc.
11:54:46 <killy> Well, I'm doing image processing and I use Matlab. No doubt there are libraries, but I don;t think Haskell would be better in DSL
11:54:51 <killy> DSP*
11:55:04 <scolobb> Does it help if I suggest flipping the matrix about the secondary diagonal?
11:55:33 <scolobb> (I think I understand what you meant when you said that you had problems figuring out how to get to the last element in the last row)
11:55:37 <SubtleArray> Botje: But that's how I learned C++. :D Different paradigms require different strategies I guess.
11:56:01 <killy> mandaya: so, how's your experience with image processing in haskell?
11:56:02 <Plembo> I don't quti efollow, scolobb
11:56:29 <killy> I want to learn Haskell just for fun, but it would be great if I could apply it to my daily work
11:56:33 <Plembo> I mean, the way I'm thinking of this is, I need to find the final value using the best path to go to 0, 0. To find that I need to know the best path to an item in the next row, to do that I need to find the nest path to an item in the next row... so on and so forth
11:56:40 <Plembo> So I need to recursively search through to find the best path up to a given square
11:56:48 <Plembo> an duse that to figure out which path I should take to the next square
11:56:52 <scolobb> Plembo: Oh
11:57:03 <Plembo> then once I'm done mapping oujt the best paths to any given square, my matrix could be understood to look like the bottom matrix
11:57:10 <Plembo> and from there I just return the best path I've found through the whole array
11:57:34 <scolobb> Plembo: Do you know how to solve this problem in a language you are more familiar with?
11:57:47 <Plembo> I tried to solve it in Ruby earlier, but I stumbled there as well
11:57:55 <Plembo> recursively calculating paths is what trips me up
11:57:57 <Plembo> figuring out how to write that
11:57:57 <scolobb> OK
11:58:09 <scolobb> Plembo: That's not how this problem is usually solved
11:58:32 <scolobb> This is a canonical problem with a canonical solution, which doesn't necessitate recursively calculating paths :-)
11:58:42 <scolobb> That was what was driving me away
11:58:45 <Plembo> oh, alright, what's a bettetr approach?
11:59:07 <scolobb> Plembo: Just a moment, I'll try to find a well-illustrated explanation
11:59:11 <Plembo> thanks :)
11:59:42 <SubtleArray> killy: I've love to use Haskell for daily work to... If I can learn it. >_< I see so much potential, but... bloody hell... I've never worked so hard to learn a language.
11:59:59 <Botje> SubtleArray: fun, huh?
12:00:17 <SubtleArray> It hurts. >:U Haha
12:00:29 <Botje> it hurts because your brain is growing :)
12:00:31 <tsousa> the HTTP module is not on the haskell plataform and i dont know how to install it on windows
12:00:34 <SubtleArray> :D
12:00:46 <byorgey> anyone know off the top of their head what the precise problem/solution is when you get "Interface file is of wrong version" warnings from Haddock?
12:00:49 <killy> SubtleArray: and whta do you do for your daily work?
12:00:52 <mzero> tsousa: if you have Haskell Platform installed
12:00:58 <mzero> then you should be able to run cabal from a Command shell
12:01:06 <tsousa> yes
12:01:20 <tsousa> but there is some error because it cannot install base
12:01:31 <mzero> whoa
12:01:38 <mzero> that isn't good - you generally always have base
12:01:47 <elliott> tsousa: hpaste the error
12:01:59 * hackagebot wai-middleware-cache 0.2.0 - Caching middleware for WAI.  http://hackage.haskell.org/package/wai-middleware-cache-0.2.0 (AlexanderDorofeev)
12:02:04 <mzero> and, run    ghc-pkg list    and hpaste that too
12:02:07 <elliott> mzero: i suspect it's "dependency on something that wants a newer base" or something
12:02:10 <killy> Ha! I managed to get cabal-install running
12:02:13 <tsousa> elliott, i cant past from the terminal on windows, or i dont know how
12:02:20 <killy> also, my ghc installation is now aware of all the packges
12:02:26 <byorgey> killy: nice =)
12:02:27 <elliott> tsousa: uhh right click the title bar, there are editing options there
12:02:34 <killy> lesson learned: don't use repo packages
12:02:36 <elliott> "QuickEdit" or something lets you drag text and then you can copy it from that menu
12:02:45 <SubtleArray> killy: I work as a digital artist and web developer.
12:03:04 <SubtleArray> killy: With some Python and C++ stuff on the side.
12:03:06 <killy> I downloaded binary ghc and installed haskell platform from source
12:03:34 <mandaya> Plembo: are you familiar with the basic search algorithms?
12:03:40 <Plembo> A few of them, yes
12:03:49 <mandaya> depth first search and breadth first search?
12:03:57 <killy> SubtleArray: well, that makes applying haskell a bit difficult
12:04:02 <scolobb> Plembo: Heh, too bad, can't find a good example
12:04:06 <scolobb> OK
12:04:23 <SubtleArray> killy: Truth.
12:04:29 <scolobb> Plembo: I'll try to provide an easy explanation on you sample matrix
12:04:36 <mandaya> Plembo: cause this problem gets a lot easier if you try and implement one of those naive solutions first
12:04:42 <Plembo> alright, thanks!
12:05:08 <killy> ok, I;ve had enough haskell for today, will come back tomorrow with more problems :)
12:05:19 <scolobb> Plembo: I'll try to provide a simple explanation, but mandaya is telling the right thing
12:05:20 <mandaya> cause what scolobb is trying to walk you through is the optimized and correct version (dynamic programming)
12:05:29 <scolobb> mandaya: Indeed
12:05:30 <killy> good nigth and good luck everyone ;)
12:05:39 <killy> #join 0
12:05:44 <mandaya> but if try and tackle the problem the naive way first, you'll have a much better grasp of how to try and optimize it
12:05:51 <SubtleArray> killy: But I think (or hope) the effort will be worth it. I'm especially interested in using Haskell for developing algorithms and pattern matching. It seems perfectly equipped for that.
12:06:03 <mandaya> I think this is a fairly canonical problem in teaching dynamic programming
12:06:03 <scolobb> mandaya: Sounds good
12:06:13 <tsousa> http://dpaste.com/701662/ what is the error?
12:06:13 <hpaste> ‚ÄúDoug Ransom‚Äù pasted ‚ÄúEclipseFP Woes‚Äù at http://hpaste.org/63492
12:06:39 <scolobb> Plembo: Do you feel like trying depth-first search and bread-first search for this problem?
12:06:40 <mzero> tsousa: that isn't how imports work in haskell
12:06:44 <mzero> they aren't like Python's
12:06:57 <mzero> so you'd need to   import Network.HTTP  at the top
12:07:03 <Plembo> breadth first
12:07:13 <mzero> then need only sa   rst -> simpleHTTP    on line 8
12:07:14 <Plembo> err
12:07:15 <Plembo> yes*
12:07:20 <scolobb> There's absolutely no doubt that you are going to get a much better hang of the problem if you'll try the naive way first, as mandaya says
12:07:24 <mandaya> scolobb: good, didn't want to step on your toes but you seemed like you were lost for an explanation
12:07:24 * cmccann searches his bread
12:07:40 <Plembo> truth be told, I'm not entirely sure what's meant by a naive solution
12:07:51 <mandaya> plembo: a basic search algorithm
12:07:59 <Plembo> oh, alright
12:08:00 <mandaya> try and solve it with breadth first search
12:08:02 <scolobb> mandaya: Right :-) I wanted to find a perfect tutorial with large, colourful pictures
12:08:03 <tsousa> mzero, same stuff
12:08:06 <tsousa> didnt change
12:08:25 <scolobb> cmccann: Don't forget to look in-depth :-)
12:08:37 <dougransom> Hi, anyone using EclipseFP on OS X successfully.   MOst of the features don't work, and I think its because of some 'sudo' commands as seen in http://hpaste.org/63492.  I don't know enough about eclipse or eclipsefp to get it working.
12:08:38 <mzero> tsousa: what is the error message?
12:08:47 <mzero> do you have the HTTP package installed?
12:09:06 <scolobb> Plembo: Turn back with questions whenever you have them and tell us about your intermediate steps and final solution
12:09:15 <cmccann> scolobb, yes, but I have to look at the heel of each loaf before I move onto the slices
12:09:26 <scolobb> There should always be helpful people around
12:09:30 <tsousa> mzero, parse error on input '-> '
12:09:43 <mzero> yes - what are you trying to do there? what is rst?
12:10:04 <elliott> methinks tsousa has a dual spelling and directionality problem
12:10:10 <mzero> perhaps you meant   rep <- simpleHTTP
12:10:17 <mzero> er,    rsp <- simpleHTTP
12:10:19 <mandaya> scolobb: yea, I actually tried to find a few dynamic programming tutorials for haskell a couple of months ago, and came up pretty dry
12:10:25 <elliott> <mzero> then need only sa   rst -> simpleHTTP    on line 8
12:10:31 <elliott> guess we know who to blame, too :P
12:10:39 <mandaya> cause at some point the pure list approach doesn't work any more (too inefficient with memory)
12:10:51 <mzero> well, actually I was only removing the Network.HTTP from that line...
12:11:24 <cmccann> elliott, well what do you expect from mzero, obviously mplus'ing his advice with someone else's should equal the other person's advice
12:11:24 <tsousa> mzero, now the error is not in scope 'rst'
12:11:26 <elliott> oh :P
12:11:32 <tsousa> forget that
12:11:35 <elliott> cmccann: hah
12:11:45 <scolobb> mandaya: It might be that the reason is that dynamic programming wants random-accessed arrays, which may be slightly confusing for newbies, as they are implemented for Haskell
12:12:00 <hi5networks> is template haskell the only way to get all of the constructors of a datatype? Is there a runtime mechanism?
12:12:06 <mandaya> scolobb: right, and I was trying to figure out random access arrays
12:12:22 <elliott> I wonder why tr0lltherapy even bothers commenting in /r/haskell.
12:12:31 <kallisti> hi5networks: Data.Data I believe has some sort of mechanism to do that.
12:12:42 <kallisti> also there's the new Generic typeclass in GHC.Generic
12:12:48 <mandaya> scolobb: I got scared away back then, and I haven't gotten a chance to go back and try again
12:13:01 <mandaya> scolobb: so I was following your discussion in the hopes of being enlightened
12:13:06 <mandaya> :)
12:13:18 <kallisti> hi5networks: I've never attempted to use them though so I'm not sure how they work.
12:13:40 <hi5networks> kallisti: The thing with Data.Data is that it does AFIAK let me break apart the constructors into their various parts
12:13:50 <guerrilla> hi5networks: what do you want to do? uniplate or one of the SYB libs could be useful to you
12:13:50 <cmccann> elliott, beats me, but he's been better lately since I told him to behave :T
12:14:01 <mzero> tsousa: look at this    http://dpaste.com/701665/
12:14:10 <mzero> that runs
12:14:20 <hi5networks> guerrilla: I'm converting non recursive types into c structs
12:14:31 <guerrilla> hi5networks: then you definitely want something like uniplate
12:14:35 <elliott> cmccann: if better means "hasn't posted as much", sure :P
12:14:49 <mzero> notice that getResponseBody is an IO action --- hence the original line, as written wouldn't work as you were trying to print an IO action, not the result of running that action
12:14:51 * elliott said that after seeing http://www.reddit.com/r/haskell/comments/pki2j/in_which_i_explain_my_haskell_solution_to_project/c3q5lf2
12:15:32 <elliott> it's really weird how much vitriol haskell inspires compared to other "niche" languages
12:15:44 <tsousa> mzero, thanks
12:15:46 <hi5networks> guerrilla: I wasn't aware that uniplate would let you query information about constructors, do you know what function I should look at?
12:15:50 <scolobb> mandaya: Ah :-)
12:15:57 <guerrilla> hi5networks: /me looks
12:15:58 <kallisti> elliott: it's because we're all pretentious jerks.
12:16:03 <cmccann> elliott, that might be biased by you not seeing vitriol directed at other languages
12:16:19 <mandaya> elliot: where are you seeing the vitriol?
12:16:25 <scolobb> mandaya: Whenever Plembo comes back with more knowledge, you'll have the opportunity :-)
12:16:28 <kallisti> elliott: perl-haters are fairly common, actually.
12:16:29 <elliott> cmccann: well, I've seen my fair share of niche language communities in my time :P
12:16:34 <elliott> kallisti: perl is not niche.
12:16:46 <kallisti> okay fine I'll use your arbitrary definition of "niche".
12:16:48 <elliott> mandaya: it's mostly on reddit and random blog posts
12:17:01 <mzero> tsousa: you should take a few minutes and be sure you understand why combining the print IO action with the getResponseBody IO action needed either a) the   body <-   syntax, or b) binding  (where you could have written it     getResponseBody rep >>= print . take 100     )
12:17:07 <cmccann> well, /r/programming is kinda terrible anyway
12:17:09 <elliott> although most of the latter is perpetrated by serial offenders I guess
12:17:16 <elliott> (*cough*harrop*cough*)
12:17:24 <mzero> (damn autocorrect      getResponseBody rep >>= print . take 100    )
12:17:25 <eyebloom> I don't think Haskell is niche anymore.
12:17:27 <mandaya> elliot: /r/programming is kind of a vitriol filled place in general. everything gets hated on.
12:17:40 <elliott> mandaya: yeah it is. but it seems to leak into /r/haskell quite often
12:17:48 <elliott> hopefully I'm just imagining it :)
12:17:49 <scolobb> I think somebody should define "niche language"
12:18:07 * elliott doesn't think the definition of niche language is relevant, since it was kind of a vague observation anyway
12:18:17 <scolobb> All right :-)
12:18:21 <elliott> but e.g. tons of people hating on any really popular language is hardly surprising because it's popular
12:18:22 <tsousa> mzero, what is >>= ?
12:18:23 <mzero> tsousa: and then, if you are feeling brave, consider        main = simpleHTTP (getRequest "http://www.haskell.org/") >>= getResponseBody >>= print . take 100
12:18:54 <elliott> tsousa: (>>=) is called "bind"
12:19:02 <mandaya> I liked this graph to see what people meant by tier 1/tier 2/etc., the distinctions are fairly apparent http://redmonk.com/sogrady/2012/02/08/language-rankings-2-2012/
12:19:03 <elliott> do { x <- y; z } is the same as y >>= (\x -> z)
12:19:12 <mandaya> (stolen from /r/haskell)
12:19:33 <mzero> tsousa: >>= is pronounced "bind" and is one of the fundamental operations of a Monad, in particular IO    --- without worrying too much about Monads for the moment,    f >>= (\a -> g a)       is  what is really going on when you write     do   a <- f;  g a
12:20:12 <guerrilla> hi5networks: hmm, yeah i suppose you'd have to go directly for Data.. i thought there was something highr level here. maybe not
12:20:17 <eyebloom> mandaya: Love to see that graph animated.
12:21:14 <mzero> you can read that     "the action that would: run the action f, and *bind* the result to the a in the lambda  (\a -> g a), and then run that"
12:21:16 <hi5networks> guerrilla: Data is not powerfully enough, oh well the TH for it is not bad. It seems like there should be a ToTH class to get the TH Dec for every data type at runtime
12:21:19 <eyebloom> Haskell seems poised to move into that upper grouping.
12:21:28 <kallisti> > take 3 . drop 1 $ [1,2,3,4,5]
12:21:30 <lambdabot>   [2,3,4]
12:21:37 <mandaya> yea, and there's some talk that scala is about to make the jump
12:21:41 <elliott> hi5networks: you can get all constructors of a type with Typeable
12:21:41 <hi5networks> guerrila: err not runtime, compile time I guess
12:21:56 <hi5networks> elliot: can I break them apart
12:22:03 <cmccann> elliott, anyway I don't really mind the vitriol that much. the kind of people who go out of their way to actively dislike Haskell are almost always people I wouldn't want to deal with in any language.
12:22:27 <guerrilla> hi5networks: depends i guess on the exact context.. you coulde use one of the traversal functions in a list comprehension to `show` but that'd only work if you only care about specific instances
12:23:29 <cmccann> elliott, particularly when it's obvious that virtually nobody spouting that vitriol knows the first thing about Haskell
12:23:42 <byorgey> mandaya, eyebloom: there is no "upper grouping" in that graph, nor will there be any "jumps".  It *looks* like there is an upper grouping, but that is just an artifact.
12:23:44 <guerrilla> hi5networks: you want the type info too or just the names of the ctors?
12:24:01 <mandaya> byorgey: can you explain?
12:24:05 <byorgey> the points are plotted based on popularity *rank* so gaps in the graph do not have any real meaning
12:24:22 <mandaya> ahh
12:24:33 <cmccann> byorgey, but if I draw a circle around these points that clearly shows them to be a group of points
12:24:44 <byorgey> i.e. the only reason it looks like there is a gap between Haskell and the stuff in the upper right is because of CoffeScript, EmacsLisp and VimL being below
12:24:49 <guerrilla> `[show x | x <- children foo]` (where you'd want to cut the `show x` off at the first space. bleh, hacky
12:25:22 <mandaya> byorgey: I was reading the ranks as "people are talking about X" versus "people are using X"
12:25:29 <byorgey> it's kind of a dumb graph.  I don't know why they didn't make a log-log graph based on *actual* numbers instead of rank.
12:25:43 <elliott> cmccann: yeah, it's true
12:25:49 <mandaya> byorgey: yea, I see your point
12:26:16 <byorgey> mandaya: yes, the graph does tell you which languages are more popular than others, and which languages have relatively more questions asked than use and vice versa
12:26:29 <cmccann> byorgey, I believe you will find that there is a strong statistical correlation showing these points as likely to share the circle I've just drawn around them
12:26:39 <byorgey> cmccann: amazing!
12:26:42 <cmccann> yes
12:27:40 * elliott wonders if the Stack Overflow gods would frown upon him asking and self-answering four Haskell questions within the space of a few minutes.
12:28:33 <cmccann> elliott, possibly :P
12:28:41 <guerrilla> elliott: i think it doesn't let you do that :) you have to wait 24hours or something
12:28:55 <cmccann> I think the cap is higher than that
12:28:58 <elliott> guerrilla: hmm, do what?
12:29:13 <cmccann> ask a bunch of questions on SO in a short period of time
12:29:18 <elliott> ah
12:29:19 <eyebloom> It would be great to see a graph like this with motion over the past ten years. Based on some real numbers instead of rank.
12:29:20 <guerrilla> elliott: answer your own questions
12:29:20 <carter> is there a linke to these other version of the lang plot?
12:29:21 <lambdabot> carter: You have 1 new message. '/msg lambdabot @messages' to read it.
12:29:29 <elliott> guerrilla: well, that's explicitly allowed and I've seen people do it within minutes
12:29:31 <cmccann> guerrilla, you can answer, just not accept
12:29:54 <guerrilla> ah was it accept then
12:29:54 <guerrilla> ok
12:30:42 <carter> or is this just a discussion of the one line
12:30:51 <guerrilla> but actually, maybe it was on stackexchange. i remember that i had to wait for something when trying to self-answer
12:30:59 <cmccann> elliott, anyway, why do you want to ask and answer a bunch of questions?
12:31:35 <elliott> cmccann: I was thinking it'd be nice to have a go-to introduction (like edwardk's answer about lenses has become, f.e.) to explain the essence of all the various streaming data solutions (iteratees/conduits/pipes/etc.) and how they relate to each other, and I have sufficient free-time to write something useful about all of them... but I dunno if I can be bothered :P
12:31:53 <cmccann> hm
12:32:01 * hackagebot hedis-pile 0.3.0 - Caching mandatory data with Redis  http://hackage.haskell.org/package/hedis-pile-0.3.0 (AlexanderDorofeev)
12:32:28 <elliott> (the questions would be along the lines of "What are iteratees/enumerators?", "What are conduits?", "What are pipes?" and "What is the streaming data problem, and what solutions are available?", with the first three introducing each library in-depth and the latter summarising the basic strategy they all take and comparing them... it could all be one Q&A but it'd end up very long and the title wouldn't be useful to people coming in from Google)
12:32:40 <Azel> elliott: Perhaps you should convince someone to ask the questions in your stead, so you can answer them...
12:32:56 <carter> the pipes lib seems the most accessible for jumping in to use
12:33:07 <elliott> Azel: that would be dishonest, I think, especially since it would net me any rep were it to be accepted
12:33:20 <hi5networks> guerrilla: sorry for the delay, the names of the constructors , the types of the args, the record names if its a record
12:33:21 <cmccann> elliott, the biggest problem I see there is that it's skirting the line of what's actually Q&A vs. something that doesn't really fit SO
12:33:24 <elliott> my understanding is that asking & answering questions you already know the answer to is explicitly permitted if it's a concrete question with a useful answer
12:34:00 <cmccann> elliott, I think that's mostly intended for asking a question you had previously and already figured out
12:34:03 <hi5networks> its is encourage on some of the stackexchange sites for sure, I would just do it
12:34:09 <elliott> cmccann: mm, something like "Introduction to iteratees" seems obviously off-topic, but "What are iteratees?" seems concrete enough, even if it doesn't have one true perfect solution
12:34:17 <elliott> cmccann: well, I spent a while figuring out the answers to all those questions :)
12:34:34 <cmccann> elliott, I say ask on meta
12:34:50 * elliott probably won't bother with it, but was curious to see how much it skirts the line
12:34:56 <Azel> True...do you have a blog where you could put the answers to these questions ? That would make for a good blog posts series
12:35:44 <Azel> And would achieve the goal to have a go-to introduction to ierate.conduits/pipes...
12:36:14 <Azel> (Not very awake...I meant iteratee/conduits/pipes)
12:36:25 <elliott> Azel: I don't have an active blog, but I find SO's format more appealing for it anyway because of the wiki aspect (maybe I should make it community wiki) -- but I'll probably just ask on meta stackoverflow if I feel like doing it like cmccann says
12:37:21 <elliott> I know it's considered acceptable to document the solution to a problem you have (that might otherwise go on a blog) in SO, and I think "What are iteratees?" would be an acceptable question if somebody who didn't know ask, but I suppose the two standards might not necessarily meet
12:37:52 <cmccann> elliott, it's an odd sort of borderline, yeah
12:37:57 <cmccann> in that it's obviously useful content
12:38:05 * mzero gets depressed when he has to switch from the Haskell side of his project into the JavaScript side... :-(
12:38:37 <mandaya> mzero: way worse when you go from haskell straight into C++
12:39:52 <cmccann> elliott, also, there is the tag wiki stuff on SO but I don't know if anyone pays attention to that :[
12:40:06 <ksion> Switching to Javascript from almost anything is depressing, tbh ;p
12:40:33 <elliott> cmccann: aren't tag wikis intended more as "what should go in this tag" rather than "an introduction"? like, it'd be weird to have a quickstart haskell tutorial in the haskell tag wiki
12:40:40 <mandaya> anyone know of a good resource for learning hsc2hs and its rather specialized syntax? I'm having trouble finding a detailed source.
12:41:00 <elliott> mandaya: http://www.haskell.org/ghc/docs/latest/html/users_guide/hsc2hs.html is the detailed source
12:41:05 <elliott> in that it describes absolutely everything
12:41:16 <elliott> see also http://book.realworldhaskell.org/read/interfacing-with-c-the-ffi.html
12:41:25 <mandaya> there isn't more than that?
12:41:33 <elliott> well, that ffi chapter has stuff on it i think
12:41:41 <elliott> but the manual page describes the entire behaviour of the program
12:42:06 <cmccann> elliott, I'm not sure honestly, but there's an index of "interesting answers" in the tag wiki right now and some links to external resources
12:42:18 <cmccann> there's also an iteratee tag floating around
12:42:19 <mandaya> huh, then I must be missing some piece of the code I'm reading, because it's using additional constructs that aren't described
12:42:22 <elliott> cmccann: arguably something like "what are iteratees?" is too vague to be an SO question at all, but I think it'd be a little sad i fquestiosn like ther were closed, even if they don't 1:1 represent a "concrete" problem, they represent a problem of understanding
12:42:42 <elliott> cmccann: and yeah, the [haskell] tag wiki is nice but it seems to outsource all the info into answers, which is kind of my point :P
12:43:01 <elliott> there's a [conduit] tag too, since I created it :p
12:43:59 <cmccann> elliott, yeah, that's why questions like that are borderline. I don't think there's a consistent answer but the overall trend on SO for the last couple years has been to more strictly limit the scope of content
12:44:21 <mandaya> oh, I see my problem... c2hs and hsc2hs are two entirely different things, and I think this project is using both
12:45:33 <otters> @quote wordpress
12:45:33 <lambdabot> No quotes match. Where did you learn to type?
12:45:35 <otters> aw
12:47:45 <eyebloom> After upgrading to the latest platform I'm getting the linker error "ld: unknown option: -no_pie" I'm on OSX and I read online that to fix it I need to upgrade Xcode but it looks like that requires upgrading to Lion, which I don't want to do. Any ideas on alternative solutions.
12:51:39 <byorgey> eyebloom: what's so bad about pie?
12:51:50 <eyebloom> I like it.
12:52:01 * hackagebot yesod-paginator 0.2 - A pagination approach for yesod  http://hackage.haskell.org/package/yesod-paginator-0.2 (PatrickBrisbin)
12:52:03 * hackagebot wai-middleware-cache-redis 0.1.1 - Redis backend for wai-middleware-cache  http://hackage.haskell.org/package/wai-middleware-cache-redis-0.1.1 (AlexanderDorofeev)
12:52:03 <yertalert> Hmm, I could use some pie...
12:52:46 <cmccann> mmmm, pie
12:53:07 <eyebloom> any idea why ghc would need that option now?
12:53:17 <eyebloom> Or how to turn it off.
12:53:59 <carter> eyebloom: its in the class of ghc compiler errors where if your code still runs, its fine
12:54:21 <carter> the fix just changes some flags that aren't easy to reach, but the code still runs fine, i believe
12:55:07 <donbex> hi all
12:55:22 <eyebloom> I think  ld is not completing its task.
12:55:23 <donbex> may I ask a simple beginner question?
12:55:41 <Rc43> Which key-value storage will be most comfortable to use with haskell?
12:55:43 <Axman6> eyebloom: what's wrong with Lion?
12:55:51 <elliott> cmccann: by the way, why on earth does the comment timer reset every time you submit too early?
12:56:06 <eyebloom> I don't want to get into it.
12:56:08 <cmccann> because it hates you
12:56:11 <byorgey> donbex: ask away
12:56:33 <donbex> when in ghci, after loading the Data.List module, I type
12:56:35 <donbex> groupBy (<=) [1,1,2,3,3,4,5]
12:56:55 <donbex> sorry, (<)
12:56:59 <Rc43> I want use key-value storage for very simple data (just id and list of other ids(links)).
12:57:00 <donbex> I get: [[1],[1,2,3,3,4,5]]
12:57:09 <Rc43> And label.
12:57:17 <donbex> while I am expecting: [[1],[1,2,3],[3,4,5]]
12:57:23 <byorgey> donbex: note that groupBy is only designed to work with equivalence relations.
12:57:31 <donbex> oh, ok
12:57:50 <Botje> donbex: groupby always checks the first element of a group against others
12:58:06 <byorgey> donbex: hmm, I'm trying to think how I would implement what you are trying to do
12:58:20 <donbex> I did it with a fold
12:58:26 <byorgey> ok.
12:58:52 <donbex> I was just wandering why the Data.List implementation didn't behave like that
12:59:56 <donbex> byorgey++
13:00:12 <donbex> well, don't know how to type that correctly...
13:00:18 <donbex> thank you anyway ^^
13:00:28 <byorgey> donbex: that was correct. you're welcome =)
13:00:53 <mzero> Rc43: are you asking about persistent storage or just in memory?
13:01:56 <Rc43> mzero, it can be just in memory, but functionality to dump/load is a plus.
13:02:15 <Rc43> mzero, I have heard about memcached/redis, is it nice fo it?
13:03:22 <mzero> it is very hard to say without knowing more about your problem domain ---- for in memory you could use a very simple list of tuples, or a Data.Map   or Data.HashMap    depending on if you need the keys sorted
13:03:25 <luite> Rc43: for haskell there's acid-state that does that, if you don't need distributed storage
13:03:55 <mzero> and that is just the start -- there are database adapters of several flavors as well as some nosql solutions
13:04:35 <mzero> so - are you reading in ~50 items of some form, computing, and outputting?   just use Data.Map or Data.HashMap
13:05:23 <cmccann> byorgey, seems like an example of the general problem of "list operation with predicate defined in terms of multiple adjacent elements"
13:05:27 <mzero> are you computing a small (1 to 100) item structure on the fly in the middle of some computation --- [(Int, String, [Int])]  might be just fine
13:05:56 <cmccann> byorgey, I occasionally want a version of takeWhile like that
13:06:01 <byorgey> cmccann: yeah
13:06:13 <mzero> are you processing 1000s of persistent entries? then you'll want some external storage based solution, or perhaps one of the acid-state like things
13:06:13 <cmccann> there's probably something on hackage that does this but I've never bothered to search :T
13:06:24 <byorgey> cmccann: at one point in the past I worked a bit on adding that sort of predicate to 'split'
13:06:33 <cmccann> ah
13:06:35 <byorgey> cmccann: but it got pretty hairy and I dropped it.
13:06:45 <cmccann> didn't realize split was your package
13:06:46 <Rc43> mzero, in perspective I need to have a lot of items (>500). My prorject is like an editor, db is needed for persist data thet is edited.
13:06:51 <cmccann> and if it's not there I have no idea where :P
13:07:18 <mzero> is your choice of persistent db fixed? like it has to be MySQL?
13:07:31 <Rc43> luite, can I think about it like huge hashtable which is runned in my code?
13:07:49 <mzero> unless the items consume 100k apiece, I wouldn't consider 500 ~ 1000 items big --- I'd keep that in memory
13:08:03 <cmccann> byorgey, I have a takeUntil that operates that way in my silly Prelude replacement and I was thinking of generalizing that at some point
13:08:21 <byorgey> cmccann: sounds good
13:08:23 <cmccann> after poking around a bit on hackage to see if something existed already
13:09:07 <Rc43> mzero, what if I will need complex computations? E.g. graph reduction with some rules (so nodes are in this storage).
13:09:45 <Rc43> mzero, and I don't know, may be it will be usefull to have sql wrapping with structure between these nodes.
13:09:48 <mzero> sounds like even more reason to keep it in memory - running whole graph algorithms on graphs that are stored on disk (via SQL or otherwise) is going to be slow
13:09:59 <mzero> YAGNI, Rc43
13:10:19 <luite> Rc43: no it's a library that lets you have a transactional data structure in memory, where transactions are saved to disk, so you can reload the data. if you need some key/value store for data that fits in memory, but the data needs to be persistent (can be reloaded after application restarts), then you might find it useful
13:10:22 <Rc43> mzero, so I talked about memcached/redis at the start. they are very fast as i know
13:10:26 <mzero> in the sense of don't build/design stuff that you don't know if you're going to need --- especially if you are new to Haskell
13:11:12 <Rc43> mzero, yes, I understand, just want to get different perpectives before start
13:11:16 * cmccann probably should add split to his alternate prelude anyway
13:11:28 <Rc43> mzero, luite, thanks
13:11:37 <mzero> Haskell is one of the nicest programming languages for refactoring - just start with the simplest thing and proceed
13:11:56 <mzero> when you find you need more storage, or more something else, the refactoring will be surprisingly nice
13:12:14 <mzero> (powerful static types win BIG here)
13:12:30 <cmccann> byorgey, would you be interested in adding this sort of list function to split? or should I just toss it in my library.
13:12:57 <byorgey> cmccann: I'd be interested in adding it
13:13:03 <cmccann> ok
13:13:27 <byorgey> cmccann: as I recall, the problem was that I was trying to fit it into the existing splitting framework, and it was going to require generalizing the internals quite a bit
13:13:30 <Rc43> mzero, yes, i can write simple prototype with hashtable or list of pairs, but when i have opened ghci i deceived that it will be a bicycle
13:14:02 * mzero autocorrect FTW!
13:14:07 <byorgey> cmccann: but just throwing in a separate function should be fine, although it means the API will be not quite as elegant/integrated as one might like.
13:14:08 <cmccann> byorgey, ok, well I'll see what I can do, if it doesn't mesh with split then I can just use it myself.
13:14:33 <byorgey> cmccann: yeah, either way is fine with me.  take a look at split and see what you think.
13:14:57 <cmccann> though btw I've never actually used darcs and may not feel motivated to learn immediately, so you may have to deal with getting code lobbed over the wall instead of a nice patch :P
13:15:07 <byorgey> that's fine =)
13:15:44 <byorgey> I hope owst gets darcs-bridge fixed soon so I can start mirroring my repos on github
13:15:51 <`Jake`_> mzero: cool to see you online, I just watched your Haskell Amuse-Bouche
13:16:03 <cmccann> byorgey, incidentally, did I ever harass you for thoughts on prelude fixes?
13:16:12 <mzero> oh! yay! hope you liked it `Jake`
13:16:14 <byorgey> cmccann: not that I recall
13:16:23 <cmccann> since I know you've thought about avoiding problem stuff with students
13:16:23 <lobster2> hello
13:16:29 <lispy> byorgey: FWIW, I just converted mine to git and was done with it. I've received way more pull requests there than I ever received dpatches.
13:16:31 <`Jake`> Yeah, I was quite cool
13:16:48 <`Jake`> it*
13:16:53 <cmccann> and I'm tidying up my little lightweight prelude replacement this weekend and could use suggestions
13:17:00 <mzero> look - even crustaceans are getting into Haskell!
13:17:10 <byorgey> lispy: sure, that's one possible approach.  But I like darcs too much and/or am too stubborn.
13:17:26 <byorgey> hi lobster2
13:17:39 <byorgey> mzero: at least two!
13:17:55 <lobster2> mzero, I'm thinking of picking it up, to give me a different perspective on programming. I've only used c++
13:18:08 <lispy> byorgey: For me, collaboration was a higher priority.
13:18:18 <byorgey> lobster2: that it will certainly do.
13:18:26 <byorgey> @where tryhaskell
13:18:27 <lambdabot> http://tryhaskell.org/
13:18:30 * cmccann suspects he'd like darcs itself better
13:18:31 <cmccann> but
13:18:32 <mzero> wonderful - it will make your mind hurt is odd, but pleasent ways for a few weeks - then suddenly you'll look at C++ in a whole new way
13:18:34 <cmccann> github :[
13:18:44 <donbex> lobster2: does your nickname have anything to do with "Accelerando" by Charles Stross?
13:18:52 <byorgey> lispy: yep, fair enough
13:18:56 <lispy> cmccann: patch-tag and darcsden? But yeah, github has a lot to offer.
13:18:58 <lobster2> Like reaching some sort of techno nivanna?
13:19:01 <lobster2> *nirvanna
13:19:09 <mzero> lobster2: also look at LYAH
13:19:14 <mzero> @where LYAH
13:19:14 <lambdabot> http://www.learnyouahaskell.com/
13:19:17 <cmccann> lispy, sheer popularity is unfortunately a major factor
13:19:22 <lobster2> I'm there already
13:19:23 <cmccann> and I mean popularity of github, not git
13:19:23 <byorgey> comparing patch-tag and darcsden to github is like comparing a tricycle to a racing bike.
13:19:31 * lispy nods at cmccann 
13:19:32 <lobster2> And I don't know where I originally got my nick
13:19:46 <byorgey> sadly.
13:20:27 <cmccann> byorgey, anyway, I'd be interested to hear any gripes about the Prelude you have so I can find more things to improve
13:20:33 <lispy> Now if we could just convince ghc hq to take full advantage of github...(mirroring there is a huge step in the right direction)
13:20:47 <lispy> But, the no pull request thing I haven't yet understood
13:20:52 <byorgey> cmccann: well, there's the usual stuff about Num and partial functions of course
13:20:54 <cmccann> right now I've mostly corrected partial functions and generalized a bunch of stuff away from specific types
13:21:09 <byorgey> cmccann: like 'length'?
13:21:11 <cmccann> and replacing major type classes is too much of a hit to compatibility unfortunately
13:21:19 <byorgey> yeah, fair enough
13:21:32 <byorgey> if you are going for a drop-in compatible replacement that makes sense
13:21:40 <cmccann> not quite drop-in compatible
13:21:51 <byorgey> well, yeah, you know what I mean.
13:21:52 <osa1> is <- operator only used for IO operations?
13:21:55 <cmccann> very much not within a module using it, I've changed too much
13:22:00 <lispy> osa1: nope
13:22:20 <byorgey> I take that back, I don't even know what I mean, but anyway.
13:22:26 <cmccann> but outside of a single module yeah, as compatible as possible
13:22:29 <osa1> lispy: where can I learn more about <- operator? what is it's name?
13:22:47 <byorgey> osa1: it is not an operator, it is just syntax
13:22:58 <lispy> osa1: <- is translated at compile time to the things defined in the Monad type class
13:22:58 <cmccann> byorgey, the idea is that I can have one module using it and another using the standard prelude and not introduce extra headaches even if it's a single package
13:23:07 <cmccann> which I guess is almost "drop-in compatible"
13:23:12 <byorgey> cmccann: right.
13:23:13 <lobster2> lyah suggests GHC, is there a reason I shouldn't use it?
13:23:28 <byorgey> lobster2: no
13:23:47 <lobster2> Ok, just checking.
13:23:52 <cmccann> byorgey, anyway yeah, I have stuff like length :: (Integral z) => [a] -> z
13:24:02 <byorgey> yep, cool
13:24:10 <mzero> lobster2: and, install GHC via Haskell Platform, if you can
13:24:10 <byorgey> lobster2: quite the opposite in fact =)
13:24:22 <cmccann> which may not make sense now that I think about it
13:24:24 <mzero> lobster2: what OS are you on?
13:24:32 <cmccann> but eh
13:24:46 <lobster2> mzero, thats where they linked it
13:24:50 <lobster2> I'm on win7
13:24:52 <mzero> good
13:24:56 <lispy> osa1: do x <- y; ..., becomes y >>= \x -> ...
13:25:12 <lispy> osa1: have you seen (>>=) before?
13:25:18 <lobster2> Now I wait... Stupid slow internet :(
13:25:42 <lispy> @undo do x <- y; return x
13:25:42 <lambdabot> y >>= \ x -> return x
13:25:50 <lispy> osa1: ^^
13:25:50 <lobster2> >>= ?
13:26:01 <cmccann> yeah ok I'm not really sure why I used an Integral constraint on length, that's silly
13:26:09 <cmccann> something else to fix I guess
13:26:23 <osa1> lispy: no, I don't know what is a monad yet. I started learning Haskell about 2 days ago
13:26:32 <lobster2> 90 mb at <100 kb a sec
13:26:49 <lispy> lobster2: Don't worry about >>= yet. If you keep studying Haskell you'll run into it, but it's not necessary for starting out.
13:26:55 <lobster2> ok
13:27:08 <lobster2> I'm curious now though :(
13:27:17 <lispy> osa1: A monad is basically a structured way to inspect the values that you feed to functions
13:27:47 <lobster2> so its like a get method in c?
13:27:50 <lispy> osa1: We use a special definition that involves some monad laws, but what I just said is the intuition
13:28:19 <lispy> lobster2: Fairly different, IMO
13:28:46 <lobster2> lispy : oh, ok
13:28:50 <lispy> osa1: the monad laws enable us to safely translate between the do-notation (with the <- arrow), and the notation with (>>=) and return.
13:28:53 <NNOTM> `Jake`
13:28:55 <NNOTM> oops
13:29:31 <donbex> lispy: lol, I see it the other way round... like a structured way to wrap up values
13:29:51 <lispy> osa1: the monadic structure is so general that monads come in many different flavors.  IO, list monad, Maybe monad, Error monad, etc
13:29:51 <osa1> lispy: I think it's a way to handle side-effects in functional code?
13:30:00 <osa1> am I right?
13:30:10 <lobster2> Oh hey, notepad++ has a haskell syntax highlighter
13:30:13 <lispy> osa1: That's a very important use
13:30:51 <lispy> osa1: but it's really about structured composition of functions.  Before (and after) each function call you can inspect what you have and do something
13:31:10 <byorgey> lispy: you don't need monads to do that.
13:31:35 <lispy> osa1: For example, you could carry along an extra environment and only hand a portion of it to the next function even though the previous one return the whole thing
13:31:52 <lispy> osa1: if you did that you might end up with something like the random monad
13:32:02 <lispy> where the extra bit of environment is the random seed
13:32:38 <osa1> lispy: I was wondering how much about monads are related with haskell's type system. because, for example, clojure is taking a highly functional approach to solve problems but it doesn't have monads
13:32:43 * byorgey doesn't think trying to give intuitive ideas about monads to newbies is very helpful
13:33:12 <byorgey> osa1: sure it can.
13:33:21 <lispy> osa1: Monads and Haskell's type system are separable
13:33:27 <byorgey> osa1: Haskell doesn't "have monads" really.  they are just defined in a library.
13:33:45 <osa1> byorgey: is it a typeclass?
13:33:48 <byorgey> there is just some special syntax sugar for do-blocks.  but that's not important.
13:33:51 <byorgey> osa1: yes.
13:34:18 <cmccann> byorgey, I hear they're kind of like burritos
13:34:21 <nand`> class Monad (m :: * -> *) where ...
13:34:30 <osa1> byorgey: can I see it's declaration code somewhere?
13:34:32 <lispy> being a type class in Haskell is more like, "Hey, we have this monad thing...how to make it convenient?  Oh right, make a type class instance"
13:34:41 <lobster2> (only at 13% download)
13:34:48 <byorgey> @src Monad
13:34:49 <lambdabot> class  Monad m  where
13:34:49 <lambdabot>     (>>=)       :: forall a b. m a -> (a -> m b) -> m b
13:34:49 <lambdabot>     (>>)        :: forall a b. m a -> m b -> m b
13:34:49 <lambdabot>     return      :: a -> m a
13:34:49 <lambdabot>     fail        :: String -> m a
13:34:54 <nand`> http://hackage.haskell.org/packages/archive/base/latest/doc/html/src/GHC-Base.html#Monad
13:34:57 <nand`> ^ full source code
13:35:22 <byorgey> cmccann: yep
13:35:52 <lispy> osa1: I highly recommend the Maybe monad as a first example to play with
13:35:57 <mzero> osa1: focus only >>= and return when start thinking about that.... >> is just a convienence method, and fail is... well... fail!
13:36:12 <nand`> the list monad is good too, but Maybe is probably the ‚Äúeasiest‚Äù to understand intuitively
13:36:30 <byorgey> @where typeclassopedia
13:36:31 <lambdabot> http://www.haskell.org/haskellwiki/Typeclassopedia
13:36:37 <mzero> > Just 34 >>= maybe "nothing here"  show
13:36:38 <lambdabot>   Couldn't match expected type `Data.Maybe.Maybe b'
13:36:38 <lambdabot>         against inferred ...
13:36:41 <byorgey> osa1: you may also be interested in reading that ^^^
13:36:44 <Plembo> Does anyone know how I migh tbe able to mkae this function more general? validatePaths 4 = [[a, b, c, d] | a <- [0..3], b <- [0..3], c <- [0..3], d <- [0..3], abs (b-a) <= 1, abs (c-b) <= 1, abs (d-c) <= 1]
13:36:55 <Plembo> So it can ake validatePaths n, and then return an array that adheres ot those rules?
13:37:18 <osa1> ok, thanks. one more question, what is `f` in this signature: (a -> b) -> f a -> f b  ? is it a function? a data constructor? type constructor?
13:37:28 <nand`> osa1: type constructor
13:37:38 <nand`> with kind * -> *
13:38:00 <mzero> Plembo: you want steps of 0 or +/- 1, and only values 0..3, right
13:38:05 <lispy> osa1: That type sig may make more sense if you put in the explicit bracketing, (a -> b) -> (f a -> f b)
13:38:06 <Plembo> precisely
13:38:12 <nand`> For example, ‚ÄúMaybe‚Äù or ‚Äú[]‚Äù
13:38:16 <mzero> and you want all of them
13:38:17 <byorgey> Plembo: you can't directly generalize what you have there. but what you have is also very inefficient.
13:38:33 <nand`> in this example fmapMaybe :: (a -> b) -> Maybe a -> Maybe b
13:38:39 <byorgey> Plembo: because it has to generate *all* lists built from [0..3] and then throw a bunch of them away
13:38:49 <lispy> osa1: meaning, it takes a function (a -> b) and gives you a function (f a -> f b), where "f a" is a type
13:39:03 <Plembo> what's a more efficient approach?
13:39:22 <byorgey> Plembo: perhaps try writing a recursive function that takes as an argument the number chosen at the previous step, and the remaining length, and then returns all possible endings of the list
13:39:24 <nand`> or map :: (a -> b) -> [a] -> [b]
13:39:41 <otters> map is fmap for lists
13:39:48 <zzo38> What monads/comonads does the Lens category have?
13:39:50 <mzero> Plembo: or you can generate a list of all possible jumps:    replicateM 3 [-1,0,1]
13:39:58 <mzero> > replicateM 3 [-1,0,1]
13:39:59 <lambdabot>   [[-1,-1,-1],[-1,-1,0],[-1,-1,1],[-1,0,-1],[-1,0,0],[-1,0,1],[-1,1,-1],[-1,1...
13:40:08 <osa1> lispy: I don't understand differences between (f a -> f b) and (a -> a). isn't (f a) is a type?
13:40:16 <otters> > length $ replicateM 3 [-1,0,1]
13:40:17 <lambdabot>   27
13:40:19 <srhb> How do I sum over all the Justs in a [Maybe Integer] ?
13:40:42 <lispy> osa1: yes (f a) is a type.
13:40:42 <zzo38> srhb: sum . catMaybes
13:40:45 <otters> oh that is a good question
13:40:46 <nand`> osa1: look at the list monad for an example. [a] -> [b] is a function that takes a list of a's and returns a list of b's, (a -> b) is a function that takes an a and returns a b
13:40:52 <lispy> osa1: Can you rephrase your question?
13:41:04 <srhb> zzo38: Thanks
13:41:12 <elliott> osa1: consider f = Maybe
13:41:13 <otters> > sum []
13:41:14 <lambdabot>   0
13:41:16 <elliott> (f a -> f b) is (Maybe a -> Maybe b)
13:41:17 <nand`> osa1: ‚Äúf a‚Äù is simply the original a ‚Äúlifted‚Äù by the Functor f
13:41:26 <lispy> osa1: in the exapmle nand` just gave, [a] is the same as [] a, which is like f a
13:41:33 <osa1> lispy: since (f a) is a type, this two signattures seem like the same to me: (f a) -> (f b) and a -> a
13:41:50 <lispy> osa1: Oh.
13:41:59 <otters> well, the second is a general form of the first
13:42:00 <otters> I think
13:42:05 <nand`> osa1: they could be the same, but the latter is more general; *however* in the fmap definition the two ‚Äòa‚Äôs must be the same
13:42:06 <lobster2> (28% downloaded)
13:42:08 <lispy> osa1: f a -> f b, can unify with a type a -> b (not a -> a though)
13:42:12 <nand`> look at the full type of fmap:
13:42:14 <nand`> :t fmap
13:42:14 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
13:42:39 <byorgey> lispy: f a -> f b  can unify with  c -> c
13:42:59 <otters> if a == b
13:42:59 <byorgey> it can't unify with   a -> b  though
13:43:05 <otters> oh, wait
13:43:08 <byorgey> because that would require  f a = a
13:43:22 <byorgey> otters: yes, that's right
13:43:32 <lispy> byorgey: I alpha renamed in my head :)
13:43:37 <nand`> so fmap can't ever take the form of something like :: (a -> b) -> a -> b
13:43:41 <lispy> But, why with c -> c?
13:43:43 <donbex> otters: it is sufficient for f not to be injective on objects
13:43:45 <mzero> Plembo: now, if you do this      map sum . inits
13:43:58 <mzero> to each of those, you get a pattern from a starting number
13:44:03 <elliott> "That means IO monad is just the instance of State monad"
13:44:09 <Plembo> understood, okay, let me see if I can make that work
13:44:09 <elliott> :(
13:44:10 <mzero> and you can apply those to each of starting vlaues 0..3
13:44:25 <byorgey> lispy: f a -> f b  unifies with  c -> c   by setting  c = f a  and  a = b.
13:44:37 <nand`> newtype IO a = IO (State# RealWorld -> (# State# RealWorld, a #))
13:44:46 <lispy> Yeah, so I unconciously set a /= b and alpha renamed in a -> b
13:44:55 <mzero> should've asked - is this HW? are you asking for help understanding? or are you looking for someone to just paste the one liner
13:44:57 <osa1> lispy: I think I understand now. in the case of f a -> f b, I can pass to function Left "1" and it can return Right 1, but in the case of a -> a, it can't. am I right?
13:44:58 <mzero> :-)
13:44:59 <zzo38> Does the Lens category have automorphisms, endomorphisms, isomorphisms, monads, comonads, etc? I am sure it has the trivial ones such as identity but some others?
13:46:09 <donbex> byorgey: maybe I am spoiled by mathematics, but isn't it possible to have f a == f b with a /= b in Haskell?
13:46:22 <nand`> osa1: a -> a could be anything, including Either String Int
13:46:28 <lispy> osa1: hmm...Either String Int -> Either String Int, would work for a -> a for Left "1" -> Right 1
13:46:42 <zzo38> donbex: They will be different types but isomorphic, for example   data X a = X;   in case f = X
13:46:45 <nand`> for what it's worth, the entire fmap could be something like (Either String Int -> Either String Int) -> (Maybe (Either String Int) -> Maybe (Either String Int))
13:46:53 <zzo38> So they are the same, but different to Haskell
13:47:03 * hackagebot texmath 0.6.0.3 - Conversion of LaTeX math formulas to MathML or OMML.  http://hackage.haskell.org/package/texmath-0.6.0.3 (JohnMacFarlane)
13:47:08 <shachaf> donbex: Of course.
13:47:08 <lispy> osa1: That is unless, f a = Either String Int and you wanted to use the name a again.
13:47:38 <nand`> donbex: you can have them behave the same way
13:47:50 <nand`> they're still distinct types after application
13:48:03 <lispy> osa1: this is getting hard to talk about without standalone examples, I fear
13:48:42 <nand`> you can't pass (f a) and (f b) into a function f :: a -> a -> b even if f a and f b are isomorphic
13:48:51 <nand`> unless a==b
13:49:11 <nand`> (should probably have written that f :: a -> a -> c)
13:50:08 <donbex> nand`: thanks, I got it
13:50:22 <mzero> cmccann: here's one for your Prelude:    between :: (Ord a) => a -> a -> a -> Bool
13:51:22 <cmccann> mzero, https://github.com/isomorphism/Overture/blob/master/src/Overture/Data.hs#L149
13:51:23 <cmccann> :D
13:51:51 <cmccann> good suggestion though
13:51:59 <lispy> osa1: I'm not really sure if I helped. I think I may have just added to any confusion you may have had :)
13:52:02 <shachaf> cmccann: Overture, eh?
13:52:13 <donbex> by the way, can anyone give me some reference about getting a function satisfying a given type signature?
13:52:33 <cmccann> shachaf, it's my lightweight compatibility-oriented alternate prelude thing
13:52:39 <shachaf> @where djinn
13:52:39 <lambdabot> darcs get http://darcs.augustsson.net/Darcs/Djinn
13:52:49 <mzero> cmccann: I suppose there are questions of open/closed interval.... I would have used >= a and <= z    as I think that would be the more common usage pattern
13:52:51 <shachaf> cmccann: Yes, I figured.
13:53:04 <lispy> osa1: The older version of this website was very helpful when I was learning about monads: http://www.haskell.org/haskellwiki/All_About_Monads
13:53:10 <`Jake`> Sorry for asking an off-topic question, but can anyone tell me how to set up a real name for a freenode account? I tried to google it, but I couldn't find anything :-/
13:53:11 <mzero> though, I suppose we could call the closed intervale version    within
13:53:23 <cmccann> shachaf, trying to tidy up as much as possible without breaking compatibility with everything else
13:53:47 <nand`> eitherToMaybe = either (\_ -> Nothing) Just
13:53:48 <donbex> shachaf: thanks, even if I was thinking about the theory of it
13:53:49 <nand`> why not (const Nothing)
13:54:11 <cmccann> nand`, because I've replaced const in another module and want to avoid headaches
13:54:18 <nand`> I see
13:54:21 <elliott> what's the replcaed const?
13:54:29 <osa1> lispy: hey, thanks for your help. I'm a little bit confused because of this type stuff which is completely alien to me. I think I'll go to bed for now and look this stuff morning(it's 1 AM in my place)
13:54:43 <shachaf> donbex: Well, you can probably find some references from that.
13:54:46 <elliott> `Jake`: /msg nickserv help?
13:54:52 <lispy> osa1: Cool. People here can explain types if you get stuck.  Cheers.
13:54:54 <cmccann> elliott, a -> (b ~> a) for arrows, which is kinda ugh
13:54:55 <SubtleArray> Wiki on registering freenode names. http://www.wikihow.com/Register-a-User-Name-on-Freenode
13:55:05 <elliott> cmccann: isn't const = pure?
13:55:08 <cmccann> but useful on occasion with existing arrow-based stuff
13:55:09 <elliott> SubtleArray: that's not "real name" :P
13:55:16 <Axman6> isn't your Real Name something your client sets?
13:55:32 <`Jake`> Yeah, I know how to set up a username, but not my realname
13:55:32 <SubtleArray> It's real enough. Lol
13:55:50 <elliott> `Jake`: what IRC client?
13:55:59 <cmccann> elliott, yes, but that doesn't work with just an Arrow constraint
13:56:01 <elliott> oh, web gateway. I don't think you can. download a real IRc client :P
13:56:11 <elliott> cmccann: god gave us Applicative to save us from Arrow :P
13:56:14 <`Jake`> oh, ok, thanks
13:56:34 <cmccann> elliott, I don't really like it either but it was handy when working with stuff that already uses Arrow
13:56:48 <cmccann> I may change that part around eventually
13:56:58 <nand`> The only arrow functions I use are *** and &&&
13:57:11 <lispy> nand`: what about first and second?
13:57:14 <Stupid____> bitcoin sucks
13:57:22 <nand`> lispy: haven't used them
13:57:26 <lispy> :t first
13:57:27 <lambdabot> forall (a :: * -> * -> *) b c d. (Arrow a) => a b c -> a (b, d) (c, d)
13:57:32 <lispy> > first (1,2)
13:57:33 <lambdabot>   No instance for (Control.Arrow.Arrow (,))
13:57:34 <lambdabot>    arising from a use of `Control...
13:57:37 <Axman6> any ops about?
13:57:37 <`Jake`> why, Stupid___?
13:58:05 * lispy was thinking that (,) had an arrow instance
13:58:06 <nand`> > first (*2) (4, 8)
13:58:06 <lambdabot>   (8,8)
13:58:40 <Axman6> @src Arrow
13:58:41 <lambdabot> class Arrow a where
13:58:41 <lambdabot>     arr, pure   :: (b -> c) -> a b c
13:58:41 <lambdabot>     (>>>)       :: a b c -> a c d -> a b d
13:58:41 <lambdabot>     first       :: a b c -> a (b,d) (c,d)
13:58:41 <lambdabot>     second      :: a b c -> a (d,b) (d,c)
13:58:43 <lambdabot>     (***)       :: a b c -> a b' c' -> a (b,b') (c,c')
13:58:45 <lambdabot>     (&&&)       :: a b c -> a b c'  -> a b (c,c')
13:58:58 <zzo38> lispy: But (,) is not a category. (It is possible to make up a category out of (,) but even in that case there will be no functor from (->) to this category)
13:59:39 <lispy> More accurately, I fail at arrow :)
13:59:54 <cmccann> elliott, and remember the goal here is to work with existing code and standard libraries and unfortunately Arrow never stopped being a thing that exists in base :P
13:59:55 <lispy> I should probably sit down and properly try to use it at some point
13:59:56 <nand`> >>> is also nice when mixing it with >> or >>=
14:00:06 <donbex> zzo38: does Arrow model a comma category?
14:00:11 <nand`> so you don't have to use =<< just so the ‚Äúreading order‚Äù is correct with .
14:00:21 <elliott> cmccann: how many people actually use Arrow compared to Applicative? :P
14:00:47 * cmccann brings out his back and forth operator again
14:00:52 <cmccann> : (>>>) <<< (>>>) <<< (>>>)
14:00:54 <cmccann> :t (>>>) <<< (>>>) <<< (>>>)
14:00:55 <lambdabot> forall c c1 (cat :: * -> * -> *) a b c2. (Control.Category.Category cat) => cat a b -> ((cat b c2 -> c1) -> c) -> (cat a c2 -> c1) -> c
14:01:05 <cmccann> :D
14:01:45 <nand`> haha
14:01:46 <cmccann> elliott, it's occasionally handy with Kleisli and the automaton arrow is popular I guess
14:01:54 <nand`> have you actually used that operator
14:02:03 * hackagebot hashmap 1.3.0.0 - Persistent containers Map and Set based on hashing.  http://hackage.haskell.org/package/hashmap-1.3.0.0 (MilanStraka)
14:02:58 <nand`> :t (>>>) <<< (>>>)
14:02:59 <lambdabot> forall c (cat :: * -> * -> *) a b c1. (Control.Category.Category cat) => cat a b -> (cat a c1 -> c) -> cat b c1 -> c
14:03:11 <cmccann> nand`, no, but only because it's longer than writing it with lambdas
14:04:16 <cmccann> and I shudder to think what code might actually use (>>>) <<< (>>>) <<< (>>>) <<< (>>>)
14:07:25 <`Jake`> Thanks elliott, now i've got a real name, I think
14:07:27 <nand`> zygohistomorphic prepromorphisms most likely
14:07:37 <cmccann> nand`, no, worse
14:07:59 <cmccann> nand`, perhaps it would help if I point out that (>>>) <<< (>>>)  is fmap
14:08:24 <cmccann> for the continuation monad
14:08:47 <nand`> yeah I noticed that in the type signature
14:08:56 <nand`> if f a = cat a c1 -> c
14:09:14 <Taneb> $ cabal install gtk2hs-buildtools
14:09:15 <Taneb> Resolving dependencies...
14:09:17 <Taneb> Configuring gtk2hs-buildtools-0.12.1...
14:09:18 <ksf> @hoogle (a -> Bool) -> [a] -> [[a]]
14:09:19 <lambdabot> Prelude dropWhile :: (a -> Bool) -> [a] -> [a]
14:09:19 <lambdabot> Data.List dropWhile :: (a -> Bool) -> [a] -> [a]
14:09:19 <lambdabot> Prelude filter :: (a -> Bool) -> [a] -> [a]
14:09:19 <Taneb> cabal: alex is required but it could not be found.
14:09:21 <cmccann> and the version with four (>>>) does it twice
14:09:21 <Taneb> cabal: Error: some packages failed to install:
14:09:23 <Taneb> gtk2hs-buildtools-0.12.1 failed during the configure step. The exception was:
14:09:26 <nand`> Taneb: hpaste.org
14:09:27 <Taneb> ExitFailure 1
14:09:29 <Taneb> Any ideas?
14:09:39 <elliott> Taneb: cabal install alex
14:10:02 <ksf> http://hpaste.org/63500  <-- should be in Data.List
14:10:21 <SubtleArray> I've been curious about this, is there a way to download ALL of the cabal packages, or have an offline copy of them?
14:10:29 <lispy> Taneb: ExitFailure is usually not useful
14:10:38 <lispy> Taneb: you need to figure out where the actual error occured
14:10:43 <Taneb> elliott, seems to have worked?
14:10:47 <Taneb> No wait
14:10:47 <nand`> cat a b -> (f a -> c) -> f b -> c
14:10:51 <lispy> Taneb: if you re-run your previous command it will usually happen pretty soon
14:11:01 <ksf> ...where, "just coincidentally", words = splitsBy (== ' ')
14:11:44 <Taneb> http://hpaste.org/63501
14:12:01 <nand`> Taneb: yes
14:12:04 <nand`> bunch of warnings
14:12:12 <nand`> but Installing executable(s) in /home/nathan/.cabal/bin
14:12:13 <cmccann> nand`, I was actually looking for a simpler way to write something similar to fmap for Cont when I found that and thought it was hilarious-looking
14:12:20 <mee> ksf: agreed
14:12:34 <ksf> Taneb, considering that's alex, that's an impressively low number of warnings.
14:12:45 <nand`> hmmm. splitsBy
14:12:49 <Taneb> Get the same thing as before for cabal install gtk2hs-buildtools
14:12:50 <nand`> I was looking for that function the other day
14:12:57 <nand`> ended up rewriting it
14:13:08 <elliott> Taneb: Do you have ~/.cabal/bin in PATH?
14:13:20 <Taneb> ...How do I tell?
14:13:24 <elliott> echo $PATH
14:13:25 <nand`> echo $PATH
14:13:25 <Franciman> hi all, why doesn't this code compile : http://hpaste.org/63502 ?
14:13:26 <elliott> If not, export PATH=$HOME/.cabal/bin:$PATH and put that in your ~/.bashrc or ~/.profile or ~/.bash_profile or whatever.
14:13:31 * cmccann thinks the split package probably has something like splitsBy already
14:13:31 <lispy> ksf: propose it.  There is a library proposal workflow
14:13:33 <Taneb> ...No
14:13:38 <lispy> libraries*
14:13:38 <ksf> NOOOOOOOOOOOO
14:13:45 <ksf> *bureaucracy*
14:13:53 <elliott> Taneb: Okay, add it then.
14:14:09 <lispy> ksf: then you don't get to complain about it NOT being in Data.List
14:14:34 <ksf> I didn't complain. I expressed a wish.
14:14:42 * lispy is future proofing
14:15:03 <ksf> actually... *don't* include it.
14:15:11 <zzo38> ksf: Why?
14:15:13 <ksf> so I won't have to change my source
14:15:14 <CodeWeaverX> The downside with future proofing is so much effort goes into predicting the future, you risk the future proofed thing having no future.
14:15:17 <Taneb> elliott, how do I do that?
14:15:18 <zzo38> OK
14:15:22 <CodeWeaverX> I have no idea what we're talking about.  Hi. :)
14:15:28 <elliott> Taneb: <elliott> If not, export PATH=$HOME/.cabal/bin:$PATH and put that in your ~/.bashrc or ~/.profile or ~/.bash_profile or whatever.
14:15:59 <cmccann> @quote glguy libraries
14:15:59 <lambdabot> glguy says: libraries@ serves an important role of stopping changes from being introduced to the libraries
14:16:12 <zzo38> Why is the "cabal upload" command so slow?
14:16:35 <lispy> zzo38: it's been fast for me.  How is your connection speed to hackage.haskell.org?
14:16:38 <glguy> cmccann: Is that quote relevant to something you just read? :-D
14:16:55 <elliott> glguy: see a few lines up :P
14:16:55 <lispy> glguy: yeah, I told ksf to propose something to libraries@
14:17:02 <Taneb> Now it says it needs happy
14:17:20 <nand`> so you cabal install happy?
14:17:23 <cmccann> I would have been more timely but it took me a while to find the right quote :T
14:17:28 <zzo38> lispy: Ping requests time out, although it works in the web browser OK
14:17:30 <Taneb> nand`, that errored
14:17:43 <ksf> so the reasoning is that I should propose splitsBy to be included so that it won't ever get included so that I won't have to change my source?
14:17:50 <lispy> zzo38: Don't worry about ping, they just turn that off.
14:17:56 <lispy> zzo38: I don't know why it would be slow then
14:17:57 * ksf squints
14:18:04 <nand`> introduce it under a different name then
14:18:05 <ksf> I think you're trying to hack me, there.
14:18:06 <nand`> wordsBy?
14:18:08 <Taneb> http://hpaste.org/63503
14:18:15 <glguy> ksf: that sounds like the kind of useful function which as already been introduced to libraries@ and died under discussion
14:18:34 <cmccann> glguy, thus demonstrating the wisdom of your quote
14:18:37 <nand`> Taneb: hasn't been updated for GHC 7.4, go through the source and add (Eq a) and optionally (Show a) to the (Num a) constraint
14:18:42 <lispy> glguy: oh. lame.
14:18:49 <nand`> it even lists the POssible fix
14:19:16 <Taneb> nand`, how do I find + edit + install the source?
14:19:41 <ksf> Taneb, cabal unpack happy
14:19:44 <zzo38> Finally it says it is OK
14:20:04 <lispy> Taneb: do you really need GHC 7.4?  Using 7.0-latest would probably be easier
14:20:28 <elliott> probably easier to patch happy than uninstall + reinstall GHC + every package
14:20:34 <ksf> ...and be sure to amend the .cabal file to version happy-1.18.8.1 so you won't clash with the official update.
14:20:37 <elliott> only a matter of time before things get updated, after all
14:21:21 <ksf> we ought to have a squad for such things, btw.
14:21:30 <glguy> Taneb: for the most part if you aren't comfortable fixing things like that hpasted error message you will find GHC 7.4.1 to be frustrating
14:21:32 <Franciman> no-one can help me?
14:21:42 <ksf> some hackage gods with write access to everything for the odd version fix.
14:21:49 <elliott> glguy: Really? I've run into maybe one or two incompatibilities, total.
14:21:52 <glguy> until the Haskell Platform moves to that version of GHC it is best suited for people to use who need to update htier libraries
14:21:56 <elliott> ksf: Everyone has write access to everything on Hackage.
14:22:01 <ksf> shhh.
14:22:03 <cmccann> Franciman, you need parentheses around your patterns
14:22:04 <elliott> People are just too wimpy to upload fixes.
14:22:05 * hackagebot extensible-data 0.1 - Sums/products/lists/trees which can be extended in other modules  http://hackage.haskell.org/package/extensible-data-0.1 (AaronBlack)
14:22:06 <ksf> pretend noone has.
14:22:06 <glguy> elliott: I suspect that that is because you haven't recompiled all of your stuff
14:22:22 <elliott> glguy: I've certainly installed quite a few libraries.
14:22:41 <cmccann> Franciman, e.g. (x:xs) instead of just x:xs
14:22:46 <nand`> elliott: wait what? I've fixed (and/or improved) a number of libraries, are you saying I can just push changes?
14:22:50 <nand`> (easily)
14:22:51 <Franciman> ohh thanks so much
14:23:09 <lukish> How can I generate strings "a1b", "a2b", "a3b", ..., "a100b"?
14:23:13 <elliott> nand`: It is based on the trust system.
14:23:15 <lispy> nand`: you should always talk to the author first
14:23:29 <elliott> nand`: If you abuse the trust by making a non-maintainer upload without a very good reason, your account will end up revoked.
14:23:30 <nand`> lispy: fair enough
14:23:34 <cmccann> Franciman, otherwise it parses into things like ((zippa x):(lista1 y):lista2) which is probably not at all what you want :P
14:23:38 <CodeWeaverX> Franciman:  You also appear to be mixing pure expression evaluation with sequential evaluation in main.  The rules for main (and other IO functions) differ from expression alone.
14:23:43 <lispy> lukish: is that a homework question?
14:23:47 <elliott> I would consider trivial fixes for new GHCs grounds for a non-maintainer upload, but I don't know if everyone agrees.
14:23:54 <ksf> > [ "a" ++ show x ++ "b" | x <- [1..100]]
14:23:56 <lambdabot>   ["a1b","a2b","a3b","a4b","a5b","a6b","a7b","a8b","a9b","a10b","a11b","a12b"...
14:24:07 <nand`> I shall e-mail the original author then. Once I figure out how to write e-mails
14:24:21 <ksf> > map (\x -> "a" ++ show x ++ "b") [1..100]
14:24:23 <lambdabot>   ["a1b","a2b","a3b","a4b","a5b","a6b","a7b","a8b","a9b","a10b","a11b","a12b"...
14:24:27 <Franciman> CodeWeaverX, and how should I write simple programs ?
14:24:28 <CodeWeaverX> Franciman: I suggest you learn how to use putStrLn and show.
14:24:46 <CodeWeaverX> Well, Franciman, if you want to start with just learning haskell expressions and functions, use GHCI, and just call functions directly with parameters.
14:24:56 <CodeWeaverX> In interpreted mode.
14:25:04 <zzo38> elliott: I do not yet agree, but probably will agree with that in future but not right now
14:25:10 <Taneb> Right, I've added the Eq a, and changed the version number in the .cabal file?
14:25:15 <Franciman> ah ok
14:25:21 <CodeWeaverX> step up to using main and the IO system later.  GHCI and its interactive expression evaluation will get you a long way to learning.
14:25:28 <Taneb> How do I install it now?
14:25:31 <Franciman> well thanks again anyone
14:25:37 <Franciman> gtg now byes
14:25:45 <ksf> Taneb, "cabal install" in the same directory as the .cabal
14:25:46 <lispy> Taneb: cabal install inside the dir with the cabal file?
14:25:47 <CodeWeaverX> For example, if you didn't have main in there at all, you could just enter:
14:25:48 <CodeWeaverX> zippa [ 1,2,3 ] "Abc"
14:25:48 <CodeWeaverX> on the command line to see what that evaluates to
14:25:51 <CodeWeaverX> Later then Franciman
14:26:04 <Franciman> bye :)
14:26:24 <elliott> zzo38: wat
14:27:00 <zzo38> elliott: About trivial fixes for new GHC
14:27:05 <elliott> i see
14:27:20 <ksf> elliott, and it's exactly those political reasons why there ought to be a squad.
14:27:36 <ksf> some bunch of people where you can dump patches
14:27:39 <nand`> I'm updating libmpd's lsInfo function from (Either Song Path) to data Result = Song Song | Path Path | Playlist Playlist; is this grounds for a minor version number update or just a build number update (ie. sub-minor version)? I don't know how the hackage version numbering policy is, or if it's per-package
14:27:53 <nand`> Personally I would consider that a minor version number update due to 1. breaking API and 2. adding new features
14:28:03 <elliott> ksf: I think we need a better model of maintainership than Hackage for prominent libraries/applications like happy.
14:28:19 <elliott> There's no conceivable reason for one person to be the bottleneck in widely-used "community" projects like that.
14:28:22 <Taneb> This is looking better
14:28:22 <zzo38> The reason why I want to delay, is first post the new Haskell Platform if it is the case, and then fix the packages
14:28:41 <ksf> well, when it comes to such simple fixes it's the same thing as e.g. gentoo maintainers patching some thing or the other.
14:29:00 <ksf> they're going to communicate the patch upstream, but as far as they are concerned it's about fixing something here and now.
14:29:05 <elliott> zzo38: the Haskell Platform has a completely different release cycle to GHC
14:29:05 <Taneb> http://hpaste.org/63505
14:29:10 <nand`> ah wait, better idea, I'll submit a pull request via git
14:29:11 <elliott> so that would hold things up by months sometimes
14:29:16 <nand`> and let the author do what he wishes
14:29:24 <elliott> nand`: see the Package Versioning Policy
14:29:27 <ksf> the alternative is getting your package masked because it's broken
14:29:31 <elliott> http://www.haskell.org/haskellwiki/Package_versioning_policy
14:29:33 <zzo38> They should wait until both Haskell Platform and GHC are correctly updated
14:30:08 <ksf> I don't know about other people, but I completely ignore the platform.
14:30:36 <Taneb> Still getting errors
14:31:03 <elliott> Taneb: hpaste
14:31:09 <Taneb> http://hpaste.org/63505
14:31:25 <ksf> ugh.
14:31:27 <elliott> Taneb: haa
14:31:32 <elliott> Taneb: you get to do another patch
14:31:34 <elliott> actually
14:31:38 <ksf> remove that context from the datatype
14:31:40 <elliott> no, you can do it from the command-line
14:31:49 <ksf> it's a misfeature in any case.
14:31:56 <elliott> Taneb: cabal insatll --ghc-options="-XDatatypeContexts" c2hs
14:31:58 <elliott> *install
14:32:01 <elliott> then try again once that finishes
14:32:03 <ksf> if that leads to more errors, bail out and enable the extension.
14:32:27 <zzo38> You should implement my -XDefaultInstances so that you can have compatibility in both directions. You also need to make Cabal, so that if certain packages are installed frozen then it will skip versions of packages depending on different version so that you can work, such as if version depend on the compiler you need to keep track of that too
14:33:05 <ksf> -XDatatypeContexts, also known as -XStupidTheta
14:33:19 <Taneb> It may not seem like it, but I'm having a ball here
14:33:30 <Taneb> /Figuratively/.
14:34:13 <Taneb> Right, trying buildtools again
14:34:25 <Taneb> Same error
14:34:43 <zzo38> Does extensible-data package works for you by now?
14:35:08 <elliott> Taneb: Did the c2hs installation work?
14:35:10 <Taneb> Yes
14:35:11 <elliott> Please hpaste both installation logs.
14:35:22 <elliott> Even if it worked.
14:35:49 <lobster2> does setprompt represent namespace?
14:35:58 <lobster2> (Just learning)
14:36:21 <elliott> lobster2: setprompt?
14:36:46 <lobster2> :set prompt "ghci> "
14:36:55 <elliott> That just changes the prompt GHCi prints before the lines you enter.
14:36:59 <Taneb> http://hpaste.org/63506
14:37:07 <zzo38> Do you know about properties of Lens category?
14:37:37 <lobster2> thats it?
14:37:38 <elliott> Taneb: Ugh, oh.
14:37:47 <elliott> Taneb: cabal install --ghc-options="-XDataTypeContexts" gtk2hs-buildtools
14:37:54 <Taneb> Okay
14:39:04 <Taneb> YES
14:39:07 <Taneb> YESSSSSS
14:39:09 <Taneb> YEESSSS
14:39:11 <elliott> Now "cabal install gtk" once that works.
14:39:19 <Taneb> :D
14:39:26 <Taneb> :D :D :D
14:39:34 <Taneb> Oh joyous day, calloo, callay!
14:39:57 <Taneb> I'm so happy I can misquote a mathematician/photographer/author/poet!
14:40:11 <Taneb> And my bubble's burst
14:40:55 <ksf> you could try sacrificing a couple of parenthesis to emacs, that might invoke manatee.
14:41:21 <Taneb> http://hpaste.org/63507
14:41:28 <Taneb> Ignore the colon at the start of line three
14:42:03 <ksf> System/Glib/hsgclosure.c:110:0:
14:42:03 <ksf>      error: void value not ignored as it ought to be
14:42:05 <ksf> zomg.
14:42:08 <ksf> that must be -werror
14:42:25 <ksf> or wait, it's the other way round with that one
14:42:43 <nsxt> anyone have extensive experience using both a haskell web framework and something like Rails?
14:43:24 <ksf> old version of glib or something?
14:43:31 <ksf> that doesn't look like anything ghc-related.
14:43:44 <elliott> ksf: it's from gtk2hs' C code
14:43:49 <elliott> glue stuff by the looks of it
14:43:58 <elliott> however!
14:43:59 <elliott>      warning: passing argument 1 of ‚Äòrts_evalIO‚Äô from incompatible pointer type
14:44:00 <ksf> nsxt, the yesod people ought to have.
14:44:04 <elliott> Taneb: give up
14:44:10 <elliott> Taneb: this is due to the C API changes in GHC 7.4.1
14:44:21 <elliott> unless you're experienced in hacking FFI code, it's hopeless for you to fix that
14:44:21 <Taneb> So, I need to wait a few months?
14:44:27 <Taneb> Or years?
14:44:29 <elliott> or just downgrade ghc
14:44:43 <ksf> nah, gtk is pretty well maintained.
14:44:52 <elliott> although, hmm
14:44:54 <nsxt> ksf, yeah, i was reading about yesod and was curious as to how the dev experience compares between the two.
14:44:59 <elliott> I've heard people using gtk2hs on ghc 7.4, so what gives
14:45:16 <Taneb> I'll try doing glib explicitly
14:45:23 <nsxt> and which, given the freedom of language/framework on a new project, would be chosen
14:45:23 <ksf> I don't know rails, but would prefer yesod ;)
14:45:56 <ksf> http://www.infoq.com/presentations/Yesod
14:46:01 <ksf> that should give a good impression.
14:46:08 <nsxt> ksf, great, thanks, i'll check it out.
14:46:09 <mandaya> nsxt: I used warp (yesod's backend) to get going on a project, and it only took me a day or so to figure out and get rolling
14:46:15 <Taneb> Yep, looks like FFIs
14:46:16 <nsxt> sometimes a google "vs" doesn't quite do the trick. :)
14:46:18 <ksf> yesod is really nice, but not as feature-complete as rails.
14:46:19 <ddarius> Rails makes you want to stab yourself in the face or stab someone in the face.  I don't know if yesod has that property.
14:46:27 <ksf> it's just hasn't been around for as long.
14:46:27 <Rc43> How can I use heterogeneous types in haskell? E.g. `data Misc a = Single a | Multiple [Misc]`. I mean that argument of Multiple can contain Misc elements with different parameter.
14:46:28 <mandaya> and that's coming from someone who doesn't really do web stuff
14:46:48 <Rc43> It is extension or something else, I have seen it earlier, but forgotten.
14:47:00 <tikhonjelvis> Rc43: Are you thinking of existential types?
14:47:07 <nsxt> i do primarily web stuff, and have just wandered over into haskell land
14:47:13 <nand`> Strangely enough, the only thing I remember from trying out rails is three bloody knives and waking up in a hospital bed with a police officer standing next to me three days later
14:47:36 <tikhonjelvis> Eh, I bet rails is more pleasant than Django...
14:47:41 <ksf> nsxt, well, in case you want to pick up haskell, yesod is probably a good point to start if you're into web development.
14:47:52 <Rc43> tikhonjelvis, may be, will look now
14:48:07 <ksf> but take care, that's a gateway drug
14:48:12 <nand`> from what I've seen of yesod it feels odd due to all of the quasiquotes
14:48:32 <nand`> makes haskell seem more complex than the pure core beauty of it really is
14:48:32 <elliott> Rc43: You don't want to use existential types.
14:48:36 <elliott> What are you trying to achieve?
14:48:45 <ksf> nand`, well, the alternative is boilerplate.
14:48:52 <Rc43> elliott, graph with typed vertices
14:48:52 <nand`> ksf: true
14:49:02 <nand`> I'm just saying it's a bad introduction to haskell as a language
14:49:02 <elliott> Rc43: Ok. What's wrong with:
14:49:08 <elliott> Oh, hmm.
14:49:14 <elliott> Rc43: OK, why do you want the different parameter in Misc stuff?
14:49:21 <elliott> How do you plan to operate on such graphs?
14:49:23 <nsxt> nand`, i'm not looking at frameworks to learn haskell
14:49:27 <elliott> It's almost certainly better to make things work with a single type.
14:49:35 <nsxt> i'm just trying to get a feel for what's possible
14:49:50 <elliott> (Because you can't really work with "heterogeneous" types, as a rule; it means something's gone wrong in your type design.)
14:50:00 <ksf> nand`, well, you start out with some quasiquoted routes, a template, then splice pure haskell into *that*, and voila, you're in purer haskell that the usual main :: IO ()-newbie gets to see.
14:50:02 <alpounet> nsxt, yesod is probably the one I'd recommend too for a "not-so-small" web app
14:50:02 <nand`> nsxt: everything is possible
14:50:19 <Rc43> elliott, in real misc is `data Vertice ? = Single ? | Multiple [Vertice] | Computed ? Vertice Computation`
14:50:22 <alpounet> you have many "plugins"
14:50:26 <elliott> nand`: Lots of things are impossible.
14:50:28 <alpounet> just check the Yesod section on Hackage...
14:50:31 <nand`> ksf: I haven't worked with yesod enough to accurately comment on that, but I'll believe you
14:50:39 <tikhonjelvis> Rc43: Is ? just supposed to be some type?
14:50:40 <Rc43> Computation is a function like Vertice -> Vertice (Computated)
14:51:05 <mandaya> computated, I like that word
14:51:06 <nand`> elliott: given infinite amount of time and resources and a team of highly trained monkeys that actively develop haskell?
14:51:13 <Rc43> tikhonjelvis, it should be variable, but I don't know how to be if I need to use existential types.
14:51:20 <elliott> nand`: They still won't produce a program that can tell you whether another Haskell program halts.
14:51:24 <tikhonjelvis> Umm, you probably don't need to use existential types.
14:51:42 <elliott> I kind of wish existentials were never invented :P
14:51:47 <ion> The halting problem is trivial.
14:51:50 <Rc43> tikhonjelvis, yes, don't know
14:51:54 <ion> halts act = do act; return true  -- It halted.
14:52:06 <nand`> elliott: but that's debatable given infinite time, just brute force it and as soon as it ends you have your answer, if it doesn't halt then you just need more time to evaluate it :P
14:52:23 <elliott> nand`: It's not "decidable" if you never "decide".
14:52:24 <Rc43> Such necessity can be sign of bad design, right?
14:52:24 <ksf> someone is confusing false and bottom, here.
14:52:28 <mandaya> ion: that program doesn't halt if given something that doesn't halt
14:52:29 <ksf> must be a formalists.
14:52:33 <ksf> who let the formalists in?
14:52:35 <mandaya> you'll never get back false
14:52:41 <zzo38> ion:   halts = (True <$);    in other words, I suppose
14:52:43 <elliott> mandaya: that's the joke.
14:52:58 <mandaya> *whoosh* I guess
14:53:20 <nand`> zzo38: halts = fmap True
14:53:37 <ion> nand: True isn‚Äôt a function.
14:53:43 <zzo38> nand`: No, I don't think so
14:53:45 <ksf> the actual solution to the halting problem is infinite time travel.
14:53:47 <nand`> ah, but that would break the <$> definition as well
14:53:47 <ion> (True <$) = fmap (const True)
14:53:51 <nand`> oh
14:53:56 <nand`> <$ is distinct from <$>
14:54:07 <otters> all you need for the halting problem is a closed timelike loop
14:54:15 <otters> if the machine hasn't halted, run the loop again
14:55:01 <nand`> what if given infinite time of a higher cardinality?
14:55:52 <ksf> you merely need a section of the universe, feed it an IORef and tell it to set it to true if the program halted *an instant before you start it*.
14:55:56 <Rc43> elliott, tikhonjelvis, can I store type with value in vertice in haskell? There are some types for reflection as I know, but don't know will it be beautiful.
14:56:06 <elliott> Rc43: I suggest you rethink your design.
14:56:13 <tikhonjelvis> Rc43: What exactly are you trying to accomplish?
14:56:14 <elliott> Try and analyse why you feel the need for heterogeneous types.
14:56:18 <ksf> that might subtract matter from the universe, but then there's always tradeoffs.
14:57:06 <tikhonjelvis> Heh, one of my quick check tests failed with the string "Na Na Na Na". It's taunting me.
14:57:22 <elliott> tikhonjelvis: I think batman is testing your program.
14:57:33 <ddarius> halts _ = True
14:57:46 <nand`> halts (length [1..])
14:57:47 <Rc43> elliott, tikhonjelvis, eehhm, i think such structure is a purpose, it is modelling tool for visual languages. So, there must be types like in other languages.
14:57:57 <Rc43> (CASE, metaCASE)
14:58:03 <ion> > do do do do
14:58:04 <lambdabot>   <no location info>: Empty 'do' construct
14:58:06 <ion> whoops
14:58:10 <elliott> Rc43: you probably just want a single type with multiple constructors -- but, thinking about things like other languages will get you nowhere
14:58:14 <tikhonjelvis> Rc43: You can just create a type for the language.
14:58:15 <ion> > do do do do do do do do do do do do do do do do batman
14:58:17 <lambdabot>   batman
14:58:30 <elliott> Rc43: haskell requires structuring things differently, and trying to model other languages' techniques in it just causes pain and frustration
14:58:33 <nsxt> hmm... listening to snoyman's presentation has me wondering about the general stance towards unit testing
14:58:46 <ion> What presentation?
14:58:50 <tikhonjelvis> Rc43: E.g. LanguageValue = Number Integer | Str String | List [LangugeValue]
14:58:51 <nsxt> the presentation on yesod
14:59:01 <nsxt>     console.log args
14:59:01 <nsxt>     process.exit()
14:59:05 <nsxt> ah sorry bad paste.
14:59:21 <nsxt> http://www.infoq.com/presentations/Yesod
14:59:23 <ion> Thanks
14:59:27 <tikhonjelvis> Were you using CoffeeScript?
14:59:32 <nsxt> yes. :)
14:59:43 <elliott> nsxt: Haskellers tend to be less enthusiastic about unit testing than users of other languages; a lot of checks that are done dynamically with unit tests can be done statically using types in Haskell.
14:59:49 <elliott> nsxt: But there's still tool support for it, and it's common.
15:00:03 <lobster2> Is it that I'm just starting out, or is haskell a really straightforward language?
15:00:08 <elliott> nsxt: QuickCheck is a Haskell innovation that's basically the best thing around for unit testing pure functions.
15:00:19 <elliott> It relieves the programmer of much of the obligation to pick test cases (similar to fuzz testing).
15:00:23 <Rc43> tikhonjelvis, it is a solution, yes. But such way will decrease possibilities of language. Without it I can store in vertice everything what I want, even tree of hashtables of Vertices of Graphs :)
15:00:31 <tikhonjelvis> lobster2: The language is straightforward. Most of the interesting stuff is in libraries.
15:00:36 <nsxt> elliott, thanks.
15:00:38 <lobster2> Ah
15:00:38 <ion> I‚Äôm more enthusiastic about unit testing in Haskell than in many other languages since Haskell QuickCheck is so nice.
15:00:42 <elliott> lobster2: It's straightforward and not.
15:00:52 <lobster2> elliot, how so?
15:00:58 <Rc43> elliott, differently like what?
15:01:03 <elliott> lobster2: The core features of the language are basically straightforward, and the entire language is conceptually and theoretically simple.
15:01:31 <elliott> lobster2: However polymorphism and typeclasses can do some pretty mindbending stuff even in the core language, and language extensions can get very non-straightforward indeed.
15:01:34 <tikhonjelvis> Yeah, QuickCheck is both better and more fun to use than normal unit tests.
15:01:35 <ksf> it's simple until someone mentions zygohistomorphic prepromorphisms.
15:01:42 <nand`> haskell is very simple once you 1. understand values, 2. understand types and 3. understand kinds
15:01:55 <nand`> and technically 1 and 3 are contained in 2
15:01:58 <lobster2_> sorry, got disconnected
15:02:05 <elliott> 15:01:03 <elliott> lobster2: The core features of the language are basically straightforward, and the entire language is conceptually and theoretically simple.  15:01:31 <elliott> lobster2: However polymorphism and typeclasses can do some pretty mindbending stuff even in the core language, and language extensions can get very non-straightforward indeed.
15:02:07 <lobster2_> how is it straight forward and not straightforward
15:02:08 <lobster2_> ?
15:02:10 <elliott> see ^
15:02:18 <nand`> haskell is very simple once you 1. understand values, 2. understand types and 3. understand kinds; and technically 1 and 3 are contained in 2 lobster2_
15:02:21 <lobster2_> ah
15:02:22 <scooty-puff> i'm having trouble with ghc 7.4.1 using constraint kinds
15:02:25 <elliott> lobster2_: If you read a good tutorial and take things slowly and in order, you'll find the learning curve to be steeper than most languages, but not abrupt.
15:02:26 <tikhonjelvis> Values are stuff, types are sets of stuff and kinds are sets of types.
15:02:35 <scooty-puff> getting Not in scope: type constructor or class `Constraint'
15:02:45 <elliott> lobster2_: A lot of people fail to learn Haskell because the core language is so simple, and they speed up to the point where they pass over all the important material.
15:02:51 <scooty-puff> when using it as in the position of what is otherwise and associated type
15:03:04 <elliott> lobster2_: But yes, reasoning about Haskell code in isolation is usually a lot simpler than in other languages because of its simple core structure.
15:03:20 <nand`> lobster2_: the difficult thing about learning Haskell is learning about the things people have written using Haskell
15:03:25 <nsxt> elliott, i'm working through learn you a haskell, and then i plan on tackling "real world haskell" - do you have any other recommendations for a well-paced approach to mastery of the language?
15:03:45 <lobster2_> elliot, thanks. I'll go slower then
15:04:01 <elliott> nsxt: Once you're comfortable with writing simple programs and want to really expand your understanding, I very much recommend reading the Typeclassopedia: http://www.haskell.org/haskellwiki/Typeclassopedia
15:04:03 <tikhonjelvis> nsxt: Write lots of code.
15:04:15 <nand`> ^ force yourself to use haskell for a while
15:04:22 <elliott> And yes, write a lot of bad code and you'll learn ;)
15:04:31 <nsxt> ha, that's a given. :)
15:04:37 <nand`> at first I thought it was a pretty cool language but I never really used it so I never saw its practical potential
15:04:45 <tikhonjelvis> Also, rewrite your code when you figure out a better way to do stuff.
15:04:48 <elliott> nsxt: But the Typeclassopedia helps greatly in gaining a conceptual understanding of all the fancy abstractions that crop up often in Haskell, in the right order and with lots of exercises.
15:04:58 <nand`> always thought it was a fun theoretical timesink
15:05:11 <nsxt> yeah, the one thing that's discouraging about learn you a haskell is that all of the examples are divorced from practicality.  i know it's a general introduction, but...
15:05:16 <SubtleArray> I'm watching these lectures now. Probably the best introductory material I've found on Haskell so far. http://bit.ly/c9functional
15:05:24 <elliott> nsxt: well, they do get more practical as things go on
15:05:40 <elliott> nsxt: it's hard to be practical in the early stages where the book is basically trying to subliminally un-learn everything imperative languages taught you ;)
15:05:43 <lobster2> thank you whoever renamed me
15:05:48 <nsxt> though that one example with the right triangles, cheesy as it may seem, ugh, it made my day.
15:05:53 <elliott> lobster2: your IRC client, presumably
15:05:56 <lobster2> oh
15:06:05 <tikhonjelvis> nsxt: I really liked "Write Yourself a Scheme in 48 Hours"
15:06:07 <lobster2> well, now I feel stupid :P
15:06:12 <nand`> lobster2: thank the developers of ChatZilla then
15:06:13 <alpounet> elliott, any progress on the Align front?
15:06:17 <SubtleArray> lol
15:06:21 <lobster2> haha
15:06:21 <tikhonjelvis> It's a very practical example.
15:06:27 <elliott> nsxt: but yes, Real World Haskell should sustain your interest once you read LYAH, even if it is a bit outdated in some areas
15:06:33 <tikhonjelvis> http://en.wikibooks.org/wiki/Write_Yourself_a_Scheme_in_48_Hours
15:06:35 <nsxt> elliott, yeah.  totally different paradigm.  the more i learn about haskell though, the more i wonder why imperative programming is the more "mainstraim" paradigm
15:06:39 <nand`> nsxt: which one example are you referring to?
15:06:39 <elliott> I seem to recall the code in Write Yourself a Scheme being quite ugly :(
15:06:43 <lobster2> I think I missed something in this tutorial, in this statement
15:06:45 <lobster2> boomBangs xs = [ if x < 10 then "BOOM!" else "BANG!" | x <- xs, odd x]
15:06:53 <lobster2> what does the | mean?
15:06:54 <nand`> elliott: I experienced the same, when reading through it
15:07:00 <nsxt> nand`, let me pull it up, just a sec.
15:07:04 <ion> It‚Äôs a list comprehension.
15:07:09 <nand`> lobster2: it's just a list comprehension special syntax
15:07:11 <tikhonjelvis> elliott: It's not brilliant, but it gave me enough structure to imrpove it myself.
15:07:23 <elliott> nsxt: after you go through RWH (although you can probably skip the last chapters on things like the Foreign Function Interface until you actually need to use them), I'd stop reading material for a while and just program
15:07:28 <CodeWeaverX>  The | can be read as 'given that', like you might find in math.
15:07:36 <ion> > [ x*100 | x <- [0..9] ]
15:07:37 <lambdabot>   [0,100,200,300,400,500,600,700,800,900]
15:07:37 <nand`> > [(a,b) | a <- ["bang", "bat", "baz"], b <- [1, 2, 3]]
15:07:38 <lambdabot>   [("bang",1),("bang",2),("bang",3),("bat",1),("bat",2),("bat",3),("baz",1),(...
15:07:40 <ion> > [ x*100 | x <- [0..9], odd x ]
15:07:41 <lambdabot>   [100,300,500,700,900]
15:07:42 <elliott> nsxt: then once curiosity gets the better of you or you feel like you've plateaued, tackle the Typeclassopedia
15:07:49 <nand`> I always read it as ‚Äúwhere‚Äù
15:07:55 <geekosaur> "given x from xs where odd x"
15:08:16 <elliott> nsxt: and avoid anything calling itself a "monad tutorial" or attempting to explain monads before that!
15:08:30 <nsxt> nand`: rightTriangles' = [ (a,b,c) | c <- [1..10], b <- [1..c], a <- [1..b], a^2 + b^2 == c^2, a+b+c == 24]
15:08:30 <elliott> (though LYAH covers monads so you probably won't run into that persistent community problem)
15:08:40 <lobster2> I'm going to need to take a moment to comprehend that
15:08:42 <nand`> elliott: I always refer to http://www.haskell.org/haskellwiki/Category_theory/Monads
15:08:43 * nand` ducks
15:08:49 <nsxt> the elegance of that just... i dunno, it blew me away.
15:08:49 <elliott> /ban nand`
15:09:07 <elliott> nsxt: hehe, it's funny because you can write something very similar in Python
15:09:13 <elliott> since they grabbed list comprehensions from us
15:09:13 <nand`> nsxt: I'd consider that the opposite of elegant personally
15:09:18 <scooty-puff> is there a good place that shows information about use of constraint kinds?
15:09:19 <nsxt> because it's so easily explainable in human terms
15:09:19 <tikhonjelvis> Except the Python way is uglier.
15:09:28 <nand`> since it's brute force
15:09:35 <nsxt> nand`, really?  i'm contrasting it with how it would be done in an imperative language
15:09:37 <lobster2> wait
15:09:42 <nsxt> which would involve nested loops, gag
15:09:43 <tikhonjelvis> Also, the Python way will inevitably confuse you because of mutation.
15:09:54 <elliott> tikhonjelvis: erm, no, I mean
15:09:54 <nsxt> barring lambdas
15:09:58 <elliott> it can actually be written exactly like that
15:10:01 <elliott> because Python has list comprehensions
15:10:07 <elliott> don't get me wrong, I don't like Python and that example is nice
15:10:13 <lobster2> so boomBangs xs = [ if x < 10 then "BOOM!" else "BANG!" | x <- xs, odd x] the if statement will only be confirmed true if x is odd?
15:10:15 <tikhonjelvis> elliott: Except it would look like [x * 100 for x in xs if xs > 10]
15:10:18 <elliott> it's just funny that the representative sample for Haskell's elegance is something Python stole too :P
15:10:18 <nsxt> elliott, thanks for all of the advice/information
15:10:24 <elliott> tikhonjelvis: well, yes, the keywords are uglier :)
15:10:26 <tikhonjelvis> elliott: and then it would break if you try something nontrivial.
15:10:55 <lobster2> also what is <-    ?
15:11:04 <tikhonjelvis> In this case think of it as ‚àà
15:11:19 <mandaya> (belongs to)
15:11:27 <mdxbhmt> := ?
15:11:45 <lobster2> ok
15:11:45 <tikhonjelvis> hmm
15:11:55 <nand`> lobster2: concerning your question no, first you filter out all odd elements, (even elements get dropped silently), and *then* you use the ‚Äúif‚Äù to see if it's below 10
15:12:03 <lobster2> I still don't know set theory symbols too well
15:12:10 <lobster2> nand, thank you
15:12:16 <elliott> hehe, I do not think \in is the easiest way to explain <-
15:12:20 <ion> ‚ÄúDrawing x from xs‚Äù
15:12:22 <elliott> lobster2: x <- xs just means we take every element from the list xs and call it x
15:12:31 <lobster2> ok
15:12:32 <nand`> > [ x | x <- [1..10], odd x ]
15:12:32 <lambdabot>   [1,3,5,7,9]
15:12:39 <mdxbhmt> ion:  that's a good one
15:12:47 <nand`> > [ (x, if x<5 then "BOOM!" else "BANG!") | x <- [1..10], odd x ]
15:12:47 <lobster2> but isn't xs empty?
15:12:47 <lambdabot>   [(1,"BOOM!"),(3,"BOOM!"),(5,"BANG!"),(7,"BANG!"),(9,"BANG!")]
15:12:51 <tikhonjelvis> {x¬≤ | x ‚àà ‚Ñï}
15:12:53 <elliott> lobster2: [foo | x <- xs, odd x] means we get every odd element of xs, call it x, and turn it into foo
15:12:55 <tikhonjelvis> or something
15:13:10 <elliott> lobster2: so, e.g., [x*2 | x <- [1..10], odd x] is: get every odd element of [1..10] and multiply it by two
15:13:14 <elliott> > [x*2 | x <- [1..10], odd x]
15:13:15 <lambdabot>   [2,6,10,14,18]
15:13:19 <lobster2> ok
15:13:26 <lobster2> that I think I get
15:13:45 <nsxt> phew, thanks everyone.  lots of information to digest.
15:14:11 <lobster2> thank you very much
15:14:30 <elliott> lobster2: (what tutorial are you reading?)
15:14:47 <lobster2> http://learnyouahaskell.com/starting-out
15:14:59 <lobster2> Did I just pass the explanation of | ?
15:15:21 <lobster2> oh, I think I see what I missed.
15:15:26 <elliott> well, "The part before the pipe is called the output function, x is the variable, N is the input set and x <= 10 is the predicate. That means that the set contains the doubles of all natural numbers that satisfy the predicate."
15:15:38 <danmaftei> cabal is saying my config file has an error. never happened before. there's little info on the net. error is:
15:15:40 <ion> The
15:15:41 <danmaftei> Warning: Error parsing config file /Users/danmaftei/.cabal/config:77:
15:15:44 <elliott> i agree, could be clearer
15:15:45 <danmaftei> Parse of field 'libsubdir' failed (paths with spaces must use Haskell String
15:15:46 <danmaftei> syntax):
15:15:50 <elliott> danmaftei: hpaste.org the config file please
15:16:08 <danmaftei> sure. it's the default one though, i never touched it and it worked before
15:16:10 <ion> The | isn‚Äôt really an operator or something like that, the entire [ ‚Ä¶ | ‚Ä¶ ] construct is a distinct piece of syntactic sugar.
15:16:10 <danmaftei> 1 sec
15:16:38 <nand`> > [ (x,y) | x <- Just 5, y <- Nothing ]
15:16:39 <lambdabot>   Couldn't match expected type `[t]'
15:16:39 <lambdabot>         against inferred type `Data.Mayb...
15:16:42 <hpaste> danmaftei pasted ‚Äúconfig error‚Äù at http://hpaste.org/63508
15:16:43 <nand`> blah
15:16:44 <tikhonjelvis> Heh, finally figured out how to type ‚Ñï in Emacs...
15:16:47 <elliott> danmaftei: it sounds like the automatic config creator might have a bug with paths with spaces in them
15:16:48 <lobster2> N = natural numbers right?
15:16:53 <tikhonjelvis> yeah
15:16:58 <elliott> hmmmm
15:16:58 <elliott>   libsubdir:
15:17:06 <nand`> N is a letter. ‚Ñï :)
15:17:22 <lobster2> right, but I don't know unicode
15:17:24 <tikhonjelvis> ‚Ñï is \Bbb{N}
15:17:29 <elliott> bold N is also used for the naturals too
15:17:33 <lobster2> or any other typesets beyond the keyboard
15:17:34 <elliott> even not blackboard
15:17:42 <Rc43> Can I use existential types without bounds? (Searching better way than creating class without functions.)
15:17:45 <nand`> N
15:17:56 <tikhonjelvis> if you're using  the TeX input mode.
15:18:02 <danmaftei> elliott: there were spaces after libsubdir: but i deleted them, didn't make a difference
15:18:16 <elliott> danmaftei: comment out he libsubdir and datadir lines
15:18:25 <elliott> basically all the lines in the install-dirs section that look like just "foo:" with no comment in frnot of them
15:18:29 <tikhonjelvis> ‚Ñ§, ‚Ñô and ‚Ñù also work. It's neat.
15:18:30 <lobster2> how do I do this?
15:18:30 <elliott> (comment them by putting -- in front like the other ones)
15:18:34 <elliott> save and maybe it'll work
15:18:41 <elliott> lobster2: do what?
15:18:50 <lobster2> the TeX input
15:18:58 <tikhonjelvis> Are you in Emacs?
15:19:08 <lobster2> Emacs?
15:19:14 <elliott> hehehe
15:19:19 <elliott> maybe don't try and use unicode right now :)
15:19:20 <tikhonjelvis> It's a text editor that is also infinitely magical.
15:19:27 <lobster2> oh
15:19:33 <tikhonjelvis> it has an IRC client :)
15:19:39 <elliott> tex input is just a thing you can do in emacs... it's not really relevant to being able to type things in IRC or whatever
15:19:40 <lobster2> ah
15:19:46 <elliott> and I strongly recommend against trying to learn Emacs and Haskell at the same time
15:19:58 <lobster2> no, that does sound like a bad idea
15:20:06 <tikhonjelvis> Heh, that's sort of what I did, and now I'm crazy.
15:20:11 <SubtleArray> lol
15:20:28 <ion> Emacskell?
15:20:39 <danmaftei> ok, i don't get those errors anymore, but i do get a new one, it says the field 'word-file' is unrecognized. i guess i could comment that too.
15:20:45 <tikhonjelvis> I think you can actually make all your programs accept input like that using something called XCompose, but I'm not sure and I don't know exactly how to do it.
15:20:49 <danmaftei> what could introduce these errors if they weren't there before?
15:21:03 <elliott> danmaftei: can you try just removing ~/.cabal/config and running cabal update?
15:21:24 <elliott> but uh
15:21:28 <elliott> maybe because the field is called world-file :P
15:21:39 <danmaftei> lol
15:21:59 <danmaftei> i'll try removing & updating
15:22:05 <danmaftei> but what would change the config file automatically?
15:22:15 <lobster2> wait, going back to the set theory(no unicode):   S = {2  * x | x <-N, x greater/equal 10} the x<- N and x greater/equal 10 are seperate filters right?
15:22:28 <lobster2> (filters probably not the right worse, please correct me)
15:22:53 <elliott> danmaftei: nothing but maybe you had it in an old cabal-install version and the syntax changed
15:22:55 <nand`> going with that analogy, the x <- N would be a ‚Äúsource‚Äù not a ‚Äúfilter‚Äù, imo
15:23:04 <elliott> lobster2: yes ("statements" is the usual term I think)
15:23:08 <lobster2> oh, ok
15:23:10 <tikhonjelvis> nand`: in sets it's basically a filter
15:23:10 <elliott> nand`: well in set theory \elem really is a predicate, but yeah
15:23:18 <elliott> lobster2: don't think too hard about the set theory, hehe
15:23:23 <tikhonjelvis> You can think of , as and, can't you?
15:23:27 <danmaftei> elliott: thanks, a new and very different config file was created.
15:23:31 <nand`> haskell has nothing to do with set theory :)
15:23:33 <lobster2> elliot, but its excluding non naturals and excluding naturals less than 10
15:23:34 <elliott> lobster2: it's just a guide to help you learn list comprehensions if you are already familiar with the notation
15:23:35 <nand`> it's category theory you want
15:23:39 <lobster2> oh
15:23:42 <elliott> it's not category theory you want either
15:23:51 <nand`> but but monad comprehensions!
15:23:53 <tikhonjelvis> nand`: Except list comprehensions were lifted from set theory and mangled a bit :)
15:23:56 <lobster2> I am finding this stuff interesting to be honest
15:24:15 <nand`> lobster2: personally I'd suggest you don't get hung up on list comprehensions too much
15:24:20 <lobster2> ok
15:24:21 <tikhonjelvis> Yeah, set theory is awesome. Nobody ever taught it to mean and yet everybody expect me to know it now...
15:24:24 <nand`> they're by far not the most interesting feature of haskell :)
15:24:29 <lobster2> hahahaha
15:24:33 <tikhonjelvis> Which is fine because set theory actually makes sense.
15:24:35 <elliott> lobster2: haskell was designed by people who are almost mathematicians, so there's quite a few places where most languages would make up their own concept and name for a thing where haskell just takes an existing concept :P
15:24:37 <nand`> I personally don't use them *that* much, I think they're uglier than correct usage of higher order functions
15:24:41 <ddarius> tikhonjelvis: Not really.
15:24:44 <elliott> and then everyone gets scared of it because words like "monad" sound scary
15:24:56 <tikhonjelvis> ddarius: You don't think it makes sense?
15:25:09 <scooty-puff> is the Constraint .. kind? available anywhere other than GHC.Prim?
15:25:09 <lobster2> By the way, how are lists different from arrays?
15:25:16 <elliott> scooty-puff: GHC.Exts, I think
15:25:19 <tikhonjelvis> lobster2: Do you know what a linked list is?
15:25:23 <nand`> lobster2: lists are linked lists
15:25:24 <scooty-puff> so def GHC.<...>?
15:25:24 <Sgeo> lobster2, efficiency for different things
15:25:25 <elliott> although I heard there's a bug that makes it not importable from there
15:25:30 <lobster2> oh
15:25:33 <nand`> lists are O(n) indexable, arrays are O(1)
15:25:36 <elliott> lobster2: an array is a contiguous region of memory, Haskell lists are singly-linked lists
15:25:38 <scooty-puff> elliott, k
15:25:41 <nand`> arrays are generally also fixed size
15:25:42 <elliott> (Python lists are actually arrays, just to be confusing)
15:25:48 <lobster2> ah
15:25:48 <nand`> lists can be any size
15:25:51 <nand`> including infinite
15:25:59 <nand`> > [3..]
15:25:59 <lambdabot>   [3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,...
15:26:04 <danmaftei> the other issue on which the net isn't useful is trying to update cabal-install. it tries to install unix-2.4.2.0 for some reason, which fails due to a base version dependency (cf. hpaste)
15:26:06 <elliott> scooty-puff: (GHC.Exts is the preferred place to import ghc specific stuff)
15:26:06 <hpaste> danmaftei pasted ‚Äúcabal-install error‚Äù at http://hpaste.org/63510
15:26:06 <lobster2> right, I saw the tutorial mentioned that
15:26:09 <ddarius> tikhonjelvis: The notation makes sense, though it could be better (I tend to prefer higher order logic notation.)  Once you get into infinite sets, though, a lot of it stops making as much sense.
15:26:14 <tikhonjelvis> elliott: and JavaScript arrays are actually objects which are a sort of map.
15:26:38 <Sgeo> Lists have O(1) prepend
15:26:39 <scooty-puff> elliott, in a later release, will it maybe be importable from a less compiler specific case?  is the ConstraintKinds extension considered really new?
15:26:40 <nand`> and C# List<T> is some sort of bastardized internal representation with an indexable accessor
15:26:49 <scooty-puff> i guess i'm pretty locked in to ghc no matter what
15:26:52 <scooty-puff> just makes me feel bad
15:26:55 <tikhonjelvis> ddarius: Well, I've only done fairly basic or CSey stuff with sets in it and it's been fine so far. I'm sure it gets weirder later on.
15:27:07 <lobster2> oh god, I know almost nothing about sorting algorithms and big o notation, other than it exists
15:27:09 <elliott> scooty-puff: ConstraintKinds just came out like a week ago, so...
15:27:17 <tikhonjelvis> nand`: Isn't List<T> just an interface? I think that's what it is in Java.
15:27:17 <elliott> scooty-puff: but no, I don't expect it will be available in any portable place until another compiler implements it
15:27:22 <nand`> lobster2: I don't know how far you are but haskell lists are basically: data List a = Empty | Prepend a (List a)
15:27:25 <Sgeo> lobster2, big O notation isn't exclusively used with sorting
15:27:27 <elliott> scooty-puff: which will probably be in like ten years unless edwardk implements his :P
15:27:31 <Sgeo> We're not talking about sorting here
15:27:35 <lobster2> oh
15:27:43 <edwardk> ?
15:27:47 <nand`> tikhonjelvis: not in C#, the interface in C# is IList<T> and more generally IEnumerable<T>
15:27:50 <elliott> edwardk: constraint kinds, haskell compilers
15:27:51 <tikhonjelvis> Sorting is just the canonical "hello, world" algorithm.
15:27:54 <edwardk> ah
15:27:58 <tikhonjelvis> nand`: ah
15:28:05 <elliott> lobster2: crash course: O(1) = takes the same time no matter how big your input is. O(n) = takes time proportional to the size of the input (e.g. 2x the input size = 2x the time)
15:28:08 <elliott> lobster2: no need to learn big O notation now
15:28:14 <elliott> but that's what it means in the context of indexing
15:28:14 <edwardk> well, i have the constraint kind stuff working, its the rest of the compiler/type system i didn't bother with ;)
15:28:15 <lobster2> ok
15:28:28 <scooty-puff> elliott, k, thanks for the info
15:28:29 <elliott> any element of an array can be accessed in the same amount of time, it takes longer to access a "further-away" (= bigger index) element of a list
15:28:41 <lobster2> makes enough sense, though I'm sure there is a lot more to it
15:28:48 <edwardk> heck we even have them in the compiler at clarifi -- we just don't have many constraints to actually use ;)
15:28:52 <elliott> not really, big-O notation is very simple
15:28:56 <tikhonjelvis> Yeah. Just wait until you learn about cache coherence :)
15:29:09 <elliott> edwardk: haha
15:29:12 <lobster2> This chat has increased knowledge of my ignorance
15:29:24 <nand`> spending time with haskell tends to do that
15:29:25 <ddarius> lobster2: Knowledge in general does that.
15:29:26 <elliott> that's the best kind of learning :)
15:29:37 <ddarius> The more you learn the less you know.
15:29:43 <edwardk> lobster2: there is this lovely thing called the dunning kruger effect ;)
15:29:45 <lobster2> hahaha
15:29:54 <elliott> I remember when I knew everything. that was nice
15:30:01 <elliott> but then I spoiled it by learning things
15:30:03 <CodeWeaverX> Brief, no doubt, but nice.
15:30:20 <tikhonjelvis> The trick to knowing everything is to make most of it up as you go along.
15:30:25 <lobster2> ha
15:30:29 <edwardk> @google dunning-kruger effect
15:30:30 <tikhonjelvis> It works in CS and Math, but doesn't work in e.g. biology.
15:30:31 <lambdabot> http://en.wikipedia.org/wiki/Dunning%E2%80%93Kruger_effect
15:30:31 <lambdabot> Title: Dunning‚ÄìKruger effect - Wikipedia, the free encyclopedia
15:30:35 <tikhonjelvis> That's why I'm not a biologist.
15:30:50 <lobster2> oh wow
15:31:07 <lobster2> I think I've heard of this actually
15:31:17 <elliott> tikhonjelvis: The natural sciences are limited by those pesky things we call facts.
15:31:23 <elliott> Mathematics has no such obstacles :D
15:31:36 <nand`> if you can't solve a mathematical problem you just invent a world in which it's solvable then say it's a new branch of mathematics
15:31:37 <lobster2> hmm
15:31:53 <lobster2> ha
15:32:05 <edwardk> tikhonjelvis: depends on where you go in biology. there are lots of areas in bioinformatics where folks pretty much do what you described ;)
15:32:09 <lobster2> I have no idea if thats true or not
15:33:13 <tikhonjelvis> edwardk: and that's why I'm actually planning to do some bioinformatics stuff this summer. But that's just CS influencing biology.
15:33:24 <edwardk> tikhonjelvis: =)
15:33:32 <tikhonjelvis> We actually just got a new bioinformatics class this semester. It doesn't require any biology classes :)
15:33:52 <nand`> I can't stand physics or biology.. too much of this messy ‚Äúreal world‚Äù business going on
15:34:15 <ddarius> Bioinformatics doesn't influence biology.  Bioinformatics is just the fact that biologists need information processing like everyone else.
15:34:46 <tikhonjelvis> ddarius: My point was that the reason bioinformatics is the way it is because of the CS aspect rather then the biology aspect.
15:34:50 <lobster2> What years in college are you guys?
15:35:02 <edwardk> kinda sad that. you usually at least need organic chem to understand what is going on beyond shuffling around a bunch of letters for nucleotides and sequence matching
15:35:20 <lobster2> Also, that was a horrible sentence as far as grammar is concerned. Sorry
15:35:29 <lobster2> I think
15:35:31 <ddarius> tikhonjelvis: And my point is that's how the vast majority of programming is.  As a professional, I write software to help people do things that I don't know how to do and know little about.
15:35:55 <tikhonjelvis> edwardk: eh, shuffling letters around is interesting enough by itself
15:35:56 * ddarius should finish the organic chemistry textbook he is reading.
15:36:56 <edwardk> anyways my experience with bioinformatics is that its like any discipline. you can pick up enough to do sequence alignment, etc and you've basically become the bioinformatic equivalent of a script kiddy or sys admin
15:37:02 <alpounet> edwardk, man, are you knowledgeable in biology too?
15:37:17 <edwardk> sure. they need folks like that around, but they don't get to do anything interesting
15:37:49 <edwardk> alpounet: i think i met all the requirements for a masters in bioinformatics before i left eastern had i not stolen half the credits for the c.s. degree
15:38:05 <edwardk> and my column store was for manipulating bioinformatics and gis data
15:38:16 <alpounet> uh
15:38:18 <alpounet> alright
15:38:18 <elliott> alpounet: oh, sorry, you asked a question :)
15:38:33 <elliott> alpounet: the Align stuff hasn't changed
15:38:37 <alpounet> so we should expect a representable-genoma package, or smth?
15:39:16 <SubtleArray> lobster2: I don't think they're college students. Likely teachers. College students today don't use Emacs. :D
15:39:18 <edwardk> i don't claim to be an expert, but i at least know the domain a bit, mostly from the stand point of phylogeny, sequence alignment and metabolomics
15:39:28 <edwardk> probably not
15:39:31 <tikhonjelvis> SubtleArray: Tons of college students use Emacs!
15:39:36 <SubtleArray> Hahaha.
15:39:38 <SubtleArray> :D
15:39:41 <tikhonjelvis> No, really.
15:39:43 <nand`> lobster2: My school system doesn't have a concept of ‚Äúcollege‚Äù
15:39:45 <SubtleArray> I know, I was kidding.
15:39:47 <nand`> My country's*
15:39:52 <alpounet> edwardk, last summer, i started reading a pretty nice book
15:39:56 <alpounet> "Mathematical Biology"
15:40:05 <tikhonjelvis> nand`: I treat "college" and "university" as vaguel interchangeable words.
15:40:09 <tikhonjelvis> and hope nobody minds
15:40:10 <alpounet> was pretty bored by all the population stuffs
15:40:12 <alpounet> but the rest is pretty neat
15:40:31 <edwardk> the springer book?
15:40:43 <ddarius> "Mathematical X" where X is a branch of natural science = statistics ?
15:40:52 <alpounet> no
15:41:00 <nand`> tikhonjelvis: I actively enforce the usage of ‚Äúuniversity‚Äù to refer to the highest form of educational organization, and use college to refer to the stage before university in school systems where the secondary tier of education doesn't extend up to university
15:41:04 <alpounet> ok don't expect any homology in there
15:41:18 <nand`> but my usage may be incorrect
15:41:22 <tikhonjelvis> nand`: Yeah, it doesn't work quite like that in the US :)
15:41:27 <tikhonjelvis> nand`: it varies per country
15:41:30 <alpounet> edwardk, hm let me find it back
15:41:34 <edwardk> alpounet: lots of differential equations for population dynamics, etc?
15:41:46 <nand`> here in Germany it's Grundschule (1-4) -> Gymnasium (5-13) -> University
15:41:50 <tikhonjelvis> Here, college implies undergraduate (usually undergraduate only) while university implies everything.
15:42:06 <tikhonjelvis> Except, to make things more confusing, Universities are sometimes made up of collages.
15:42:13 <tikhonjelvis> colleges**
15:42:14 <nand`> I do not know what the term ‚Äúundergraduate‚Äù means. I shall look it up
15:42:24 <ddarius> tikhonjelvis: You might say they are a collage of colleges.
15:42:27 <tikhonjelvis> E.g. going for a bachelors degree rather than masters or phd
15:42:28 <alpounet> edwardk, yeah, there's a chapter or two about that...
15:42:31 <tikhonjelvis> ddarius: yes
15:42:33 <chridi> nand`: its for bachelor ;)
15:42:36 <edwardk> undergraduate in the states is typically the first four years of college
15:42:40 <nand`> I see
15:42:52 <alpounet> edwardk, that's the one by Murray iirc
15:42:56 <chridi> nand`: i looked it up some time ago.. im from germany too ;)
15:43:36 <tazjin> Is GHC compatible with ARM based devices like the Raspberry Pi? :]
15:43:37 <tikhonjelvis> It's confusing because I'm in the "College of Engineering" at my University
15:43:47 <edwardk> yep. skimmed it at quantum books once before they closed, but it came out after i left academia and largely stopped playing with bioinformatics
15:43:49 <tikhonjelvis> which is technically part of a larger University
15:44:29 <ddarius> edwardk: I don't consider students that don't need to publish part of academia.
15:44:33 <elliott> tazjin: It can do ARM. Dunno if it can do the Raspberry Pi.
15:44:46 <edwardk> i picked up some interest again from talking to a bunch of folks in the area here who do bioinformatics research, even got to speed up some code for them, but its mostly a slowly withering hobby
15:44:54 <tazjin> elliott: Well, it's coming out in a few weeks so I suppose we'll see ;-)
15:45:04 <elliott> tazjin: I'm sure patches will be welcome :P
15:45:11 <elliott> http://ghcarm.wordpress.com/ may interest you.
15:45:11 <ddarius> edwardk: Are you moved and do you want your books?
15:45:13 <edwardk> ddarius: i bailed before i had to take part in that part of the process ;)
15:45:32 <alpounet> edwardk, and the prof. that recommended be this book wanted to get me to write some Python during the summer to simulate some models of the brain they have
15:45:32 <alpounet> tried to get haskell on track, didn't work.
15:45:35 <ddarius> edwardk: Exactly.  I wouldn't call someone an "academic" just because they are in university.
15:45:35 <elliott> tazjin: People use GHC on the iPhone, so...
15:45:41 <edwardk> ddarius: ah. i am moved. there are a bunch of books in the garage that i'm weeding out, which you are welcome to take
15:45:58 <tazjin> ^ thanks for that link
15:46:05 <edwardk> alpounet: sounds like it won't be much fun =P
15:46:55 <edwardk> ~9 boxes of them at last count, ~5 of microsoft ecosystem stuff, a couple of boxes of cisco books and some old roleplaying books which i think will go to local gamers
15:47:36 <edwardk> mostly so i don't have to deal with them when/if we decide to move again
15:48:22 <ddarius> Yeah, I had a trash bag worth of books that I gave away when I moved from Texas to here.
15:48:24 <lobster2> back
15:49:18 <ddarius> edwardk: I find it curious that you have so many MS books.
15:49:34 <nand`> MS is a large company
15:49:53 <nand`> their research division in particular produces interesting stuff
15:50:08 <ddarius> nand`: MSR doesn't typically produce books.
15:50:19 <alpounet> edwardk, well i actually had to drop that course, and i ended up doing a thesis on a paper about hyperbolic geometry and continued fractions, which I think i had told you about
15:50:24 <ddarius> And I'm pretty sure the vast majority, if not all of Ed's MS books, are not from MSR.
15:50:44 <nand`> ddarius: fair enough, I was thinking about papers; I thought that maybe they'd produce books as well
15:50:49 <edwardk> ddarius: i like to make sure i have everything i need when i tackle some problem domain, even if that domain is random sharepoint stuff ;)
15:50:54 <lobster2> I had a sudden question related to math: How fast does a half full bath tub full of cold water(x) fill up if you fill the rest with hot water? The change would slow down as it got closer to full wouldn't it?
15:51:16 <ddarius> edwardk: Isn't Reflector everything you need.  I doubt the books are accurate/comprehensive enough.
15:51:31 <nand`> lobster2: not defined, depends on the rate of fillage
15:51:34 <lobster2> ah
15:51:42 <drdo> lobster2: That depends on the shape of your tub
15:51:56 <lobster2> oh
15:52:13 <edwardk> a lot of the microsoft stuff i have thats going out is older still, misc. old books on DCOM, random certification materials, old driver writing material for the old standards, etc.
15:52:15 <drdo> actually no it doesn't if you mean half of the volume
15:52:33 <lobster2> Assume a perfect cube, and 1/144th of the cube per second I guess
15:52:35 <edwardk> probably about half stems from the last few years, and the other half from long before
15:52:53 <edwardk> i don't think i'll need to write another device driver for windows 98 any time soon ;)
15:52:55 <drdo> lobster2: What does the water temperature matter?
15:53:12 <ddarius> edwardk: What?!  You don't want to write a 16-bit VxD?
15:53:15 <lobster2> Oh, I meant to ask the avaerage change in temperature
15:53:20 <edwardk> =P
15:53:22 <aristid> edwardk: probably not anybody else will. why do you keep that book at all?
15:53:39 <edwardk> aristid: because i just noticed it when moving =P
15:53:45 <ddarius> aristid: When the world collapses it will make good kindling.
15:53:52 <lobster2> burn the world?
15:54:07 <edwardk> yeah. when i have to choose between that and categories for the working mathematician. it'll be a much easier choice
15:54:08 <aristid> ddarius: not so many months till that, so it's good that edwardk is prepared
15:54:25 <lobster2> VxD?
15:54:33 <lobster2> virtual drive?
15:54:45 <edwardk> http://en.wikipedia.org/wiki/VxD
15:54:45 <nand`> lobster2: concerning your temperature problem, ask a physicist :)
15:54:53 <edwardk> old device driver model
15:54:58 <lobster2> thank you edwardk
15:55:07 <lobster2> nand' ya, I guess
15:56:06 <edwardk> anyways the old holographic display system i worked on used a wdm device driver, not a vxd, which is why i said windows 98. :)
15:56:16 <ddarius> Per pound, Categories for the Working Mathematician is much more expensive than a typical MS tech book.
15:56:39 <ddarius> edwardk: I hope.
15:58:16 <lobster2> Going back to the haskell tutorial, what is '/=' ?
15:58:24 <tikhonjelvis> ‚â†
15:58:37 <lobster2> oh
15:58:47 <lobster2> thank you
15:58:48 <tikhonjelvis> It makes more sense than !=, methinks.
15:59:17 <lobster2> Your right, come to think about it
15:59:20 <lobster2> (making more sense)
16:02:01 <nand`> /= is unfortunately out of bounds in the imperative world since a /= b is a = a / b
16:02:10 <nand`> and != isn't that bad either if ! is taken to meaning negation
16:02:26 <elliott> (/=) is an ugly operator.
16:02:33 <lobster2> eh
16:02:49 <lobster2> I spoke too soon
16:02:49 <nand`> I don't see why we can't use ‚â† either way, it's right there on my keyboard
16:03:13 <companion_cube> it put unicode in the coe
16:03:14 <lobster2> What kind of keyboard do you have?
16:03:16 <companion_cube> code*
16:03:20 <tikhonjelvis> nand`: What sort of keyboard do you have?
16:03:36 <nand`> tikhonjelvis: lobster2: US International layout, it's Alt Gr + .
16:03:39 <tikhonjelvis> Of course, I have an unlabelled keyboard, so I can have whatever I want on it :)
16:03:50 <lobster2> Nice
16:04:00 <nand`> I have a labeled keyboard but I sorted the letters alphabetically and randomized the numbers to throw people off
16:04:05 <tikhonjelvis> It's \ne in Emacs.
16:04:15 <geekosaur> there are imperative languages that use /= as the not-equal operator.  not many, but they do exist
16:04:23 <nand`> then there's ~=
16:04:27 <theorbtwo> There's also BASIC, which uses <>.
16:04:37 <tikhonjelvis> Python supports <> as well, no?
16:04:45 <elliott> it's deprecated
16:04:47 <elliott> and removed in python 3
16:04:49 <theorbtwo> I'm fairly fond of !=, myself, since it pairs well with ! for logical negation generally.
16:05:15 <tikhonjelvis> elliott: Yeah, I've never seen it used in real life. But I haven't seen anybody use Python 3 either.
16:05:21 <lobster2> My logic book says the not symbol is ~, does it vary?
16:05:31 <tikhonjelvis> theorbtwo: Except ! for logical negation doesn't make sense. But okay.
16:05:36 * cmccann suggests ¬¨=
16:05:48 <tikhonjelvis> ~ is reserved for bitwise negation in C-like languages.
16:05:52 <elliott> It "doesn't make sense"?
16:05:54 <lobster2> oh, right
16:05:55 <cmccann> hm that does not look right in whatever font xchat uses
16:05:55 <elliott> It's a symbol.
16:05:56 <theorbtwo> lobster2: C uses ! for logical negation, and ~ for bitwise negation.
16:05:59 <elliott> It can't not make sense.
16:06:26 <tikhonjelvis> So let's just make addition ‚òÉ then :)
16:06:27 <theorbtwo> elliott: Well, some symbols are used for what they are used for because they make *some* sort of sense.
16:06:33 <lobster2> I never learned about bits in C, I knew about !, since its ahrd not too
16:06:38 <geekosaur> also, there's no real reason that (‚â†) couldn't be defined in the Prelude
16:06:45 <lobster2> *hard
16:06:57 <theorbtwo> > and <, for example, have the big end on the big number.  (FSVO number, of course.)
16:06:58 <lambdabot>   <no location info>: parse error on input `,'
16:07:04 <geekosaur> nobody's done it yet but it's a perfectly valid operator character, not reserved or anything
16:07:04 <tikhonjelvis> Some editors display /= as ‚â† in Haskell code. I like that.
16:07:34 <tikhonjelvis> Hey, how does Haskell decide what is an operator character?
16:08:05 <theorbtwo> Depending on the font, splitting an is-not-equal-to sign can look like /= or !=.  IIRC, the textbooks my school used as a kid made it look like !=.
16:08:21 <duairc> Is there a difference between "mask $ \unmask -> forkIO $ catch (unmask foo) handler" and "mask_ $ forkIOWithUnmask $ \unmask -> catch (unmask foo) handler"? And if not, why does forkIOWithUnmask exist?
16:08:30 <tikhonjelvis> theorbtwo: Math textbooks?
16:08:59 <theorbtwo> Lots of symbols come from the first character of the word for the relevant thingy in some language or another.
16:09:02 <edwardk> tikhonjelvis: there is a small list of exceptions then its basically anything unicode says is in a couple of classes
16:09:18 <tikhonjelvis> Aha, that's basically what I thought.
16:09:22 <theorbtwo> tikhonjelvis: Yes.  Well, somewhat closer to |=, if your | is uninterupted.
16:09:49 <theorbtwo> But infinite slope, not positive slope.
16:10:01 <tikhonjelvis> How can I get what unicode thinks about some symbol in Parsec?
16:10:03 <cmccann> there are a few unicode categories that sound legal according to the report that GHC rejects, for what it's worth
16:10:29 <edwardk> yep
16:10:57 <tikhonjelvis> So is there some function Char ‚Üí UnicodeCategory or something?
16:10:58 <cmccann> for instance, anything that's marked as a bracket-y character seems to be rejected
16:11:13 <elliott> @hoogle generalCategory
16:11:13 <cmccann> :t generalCategory
16:11:14 <lambdabot> Data.Char data GeneralCategory
16:11:14 <lambdabot> Data.Char generalCategory :: Char -> GeneralCategory
16:11:14 <lambdabot> Char -> GeneralCategory
16:11:21 <cmccann> argh
16:11:30 <tikhonjelvis> thanks
16:11:31 * cmccann shakes his fist at being preempted
16:12:48 <cmccann> at any rate, GHC rejects fancy bracket and quote characters (which seems incorrect to me) as well as funny business like whitespace characters (which seems correct)
16:13:05 <tikhonjelvis> A whitespace operator would be great fun :)
16:13:24 <ion> Is GeneralCategory isomorphic to Unicode categories (or whatever they are), though?
16:13:25 <cmccann> as much as I might like to pretend that using the juxtaposition multiplication whitespace character is a good idea
16:13:34 <nand`> reimplement ‚Äúwhitespace‚Äù in haskell
16:13:46 <lobster2> How do you write comments in haskell?
16:13:52 <tikhonjelvis> -- comment
16:13:58 <tikhonjelvis> {- also comment -}
16:14:08 <tikhonjelvis> the latter form is nestable
16:14:13 <ion> > {- woo, {- nesting -} -} 42
16:14:14 <lambdabot>   42
16:14:15 <cmccann> and yes, Unicode really does include a whitespace character specifically for writing multiplication
16:14:28 <nand`> tikhonjelvis: oh wow, that's neat, never knew
16:14:42 <tikhonjelvis> cmccann: I saw a proposal about some hack with giving function Num instances which would do something similar.
16:14:50 <nand`> it throws me off that most well-established languages still don't support this
16:15:01 <cmccann> tikhonjelvis, haha, that sounds like a bad idea
16:15:13 <edwardk> tikhonjelvis: for the function Num instance, juxtaposition doesn't do what you'd think
16:15:17 <lobster2> http://hastebin.com/qehocexewi.vbs
16:15:18 <ion> I‚Äôve needed comment nesting in Haskell exactly zero times so far. Not counting the demonstration above.
16:15:46 <lobster2> Have you ever needed comment nesting in general?
16:15:50 * cmccann thinks a Num instance for church numerals would be fun
16:15:55 <tikhonjelvis> nand`: That's because nested comments aren't a regular grammar while C-style ones are, probably.
16:15:55 <tikhonjelvis> ion: It's great if you want to comment out regions of code without thinking.
16:15:55 <tikhonjelvis> Of course, with Emacs, you just use M-; and don't think anyhow :)
16:16:00 <edwardk> lobster2: yes
16:16:01 <nand`> ion: It's nice for commenting out larger portions of code which themselves contain block comments
16:16:05 <lobster2> oh
16:16:09 <edwardk> its handy when you go to comment out a large block of code that has comments in it
16:16:20 <lobster2> oh ok
16:16:22 <cmccann> it also lets you write example code in comments, which itself contains comments
16:16:23 <edwardk> think of how much of a pain that is in c/java without it
16:16:47 <edwardk> there you often find folks reverting to the #if 0   #endif CPP idiom
16:16:49 <ion> I tend to comment out blocks of code with --.
16:16:50 <edwardk> because it nests =P
16:16:52 <kaspare> yeah, #if 0/1 even better with cpp
16:17:09 <tikhonjelvis> Python doesn't have block comments, does it?
16:17:14 <kaspare> (edwardk: right beat me to it)
16:17:21 <aristid> edwardk: or write macros that attempt to escape comments, but break when the nesting goes beyong 1
16:17:23 <aristid> *beyond
16:17:36 <tikhonjelvis> So I've seem people use """ ... """ to comment stuffout. Except to do that, they also stripped out the docstrings.
16:17:41 <fryguybob>  /* ... /*/ ... // */
16:17:45 <cmccann> tikhonjelvis, hahaha
16:17:50 <lobster2> I guess commenting out code WOULD make it helpful
16:17:59 <edwardk> fryguybob: hey thats quite useful when writing palindromic programs
16:18:05 <aristid> i had the joy to make such a Visual SlickEdit macro at least not use non-ascii characters
16:18:55 <lobster2> I just never realised it
16:19:29 <fryguybob> I used some editor where the syntax highlighters saw that differently then the compiler (back in the day).
16:19:34 <tikhonjelvis> As I said, if you use a good editor, you can just have the editor take care of it for you. That works even in languages like Python.
16:19:43 <lobster2>  By the way, a variable is defined as soon as it is mentioned, am I getting that right?
16:19:49 <nand`> fryguybob: I use an editors which sees --| as a comment in Haskell
16:19:59 <nand`> editor*
16:20:25 <nand`> lobster2: a variable is defined as soon as you explicitly or implicitly define a lambda
16:20:34 <nand`> or a polymorphic type signature
16:20:46 <lobster2> what is a lambda?
16:20:55 <tikhonjelvis> nand`: What does --| do?
16:20:55 <tikhonjelvis> Œª
16:20:55 <nand`> anonymous function
16:21:00 <cmccann> lobster2, an anonymous function, e.g. \x -> (x, x)
16:21:11 <nand`> by ‚Äúimplicit lambdas‚Äù, consider:
16:21:13 <nand`> square x = x*x
16:21:26 <nand`> this is in reality a lambda, square = \x -> x*x
16:21:38 <aristid> nand`: which reality?
16:21:39 <nand`> in this case x is a variable
16:21:39 <tikhonjelvis> Also, let is like a lambda: let x = 10 in x is the same as (Œª x -> x) 10
16:21:43 <cmccann> tikhonjelvis, mangles your comments in unpredictable ways and puts some of them into the haddock pages, mostly
16:21:45 <fryguybob> > let a --| b = a - b in 50 --| 8
16:21:45 <lambdabot>   42
16:21:56 <cmccann> oh, no space in there
16:21:56 <tikhonjelvis> ah
16:21:58 <nand`> aristid: lambda calculus / system F
16:22:21 <aristid> nand`: ok :)
16:23:01 <lobster2> I thought -- was used for comments
16:23:05 <nand`> tikhonjelvis: let is not like a lambda, those expressions are simply isomorphic but I wouldn't consider them equivalent; let is simply a scoped definition, in the first example x is an unchanging name; in the second x is a variable
16:23:07 <ddarius> tikhonjelvis: That fails for several reasons.
16:23:21 <nand`> lobster2: only when it's not part of an operator :P
16:23:27 <lobster2> oh
16:23:28 <nand`> that's the confusing bit
16:23:29 <tikhonjelvis> ddarius: How does it fail?
16:23:34 <SubtleArray>  One thing I've found most confusing about Haskell, and one of the reasons why I've been using an IDE rather than an editor, is the layout. Are there any general rules to how code should be laid out in Haskell? I still don't understand it.
16:23:58 <lobster2> so what does --| and |-- represent?
16:24:20 <lobster2> *what does --| represent
16:24:24 <fryguybob> lobster2: They are just valid names for operators, not common ones.
16:24:30 <ddarius> tikhonjelvis: let is recursive, let x = x in x is not the same as (\x -> x) x, the latter doesn't even make sense since the outer x isn't in scope.  let also generalizes, let x = 2 in (x,x) :: (Float, Double) works but (\x -> (x, x) :: (Float, Double)) 2 does not.
16:24:40 <hpc> @hoogle (--|)
16:24:40 <lambdabot> No results found
16:25:00 <tikhonjelvis> I bet almost everybody uses an editor that takes care of it and so don't know the rules.
16:25:06 <lobster2> also 'in' is a keyword?
16:25:11 <aristid> lobster2: yes.
16:25:20 <lobster2> what does it do?
16:25:26 <ddarius> I'm not aware of any editor that knows all the rules of Haskell layout.
16:25:41 <fryguybob> lobster2: marks the end of a let expression.
16:25:44 <kaspare> SubtleArray: Section 2.7 of the Haskell Report explains it.
16:25:47 <lobster2> oh
16:25:49 <fryguybob> (end of the bindings)
16:26:03 <nand`> hpc: I'm not sure if --| was the actual operator
16:26:09 <nand`> it was -- followed by something
16:26:28 <SubtleArray> tikhonjelvis: I bet. :D It's so complex, but I'd like to know it well enough to be able to type code in something like gedit without getting errors.
16:26:30 <nand`> lobster2: it's a good practice in general to append a space after --, not only in haskell
16:26:34 <tikhonjelvis> ah
16:26:34 <nand`> but especially so for this reason
16:26:48 <cmccann> :t (---)
16:26:49 <tikhonjelvis> SubtleArray: Why would you want to use something like gedit?
16:26:49 <lambdabot> parse error (possibly incorrect indentation)
16:26:50 <SubtleArray> kaspare: Thank you. I'll check it out now.
16:26:53 <lobster2> that line of code still confuses me
16:27:02 <cmccann> > --------- this is a comment
16:27:03 <lambdabot>   not an expression: `--------- this is a comment'
16:27:09 <cmccann> > () --------- this is a comment
16:27:10 <lambdabot>   ()
16:27:19 <lobster2> hmm
16:27:22 <lobster2> > let a --| b = a - b in 50 --| 8
16:27:23 <lambdabot>   42
16:27:33 <lobster2> let a
16:27:35 <lobster2> >let a
16:27:39 <fryguybob> SubtleArray: One thing to watch out for is using tabs.  I choose to not mix tabs and haskell.
16:27:40 <lobster2> is valid?
16:28:09 <kaspare> (agreed about tabs!)
16:28:10 <nand`> lobster2: 1. you need a space after > for lambdabot and 2. not in regular haskell, every let needs an in somewhere. It's a special syntax in GHCi though
16:28:10 <tikhonjelvis> I suggest not using tabs for most code. But that's just me.
16:28:20 <companion_cube> +1
16:28:20 * ddarius suggests just not using tabs.
16:28:24 <nand`> I use spaces with Haskell and so should you
16:28:28 <yoklov> ddarius: what about yi?  i seem to remember it performs a full parse
16:28:38 <lobster2> ok
16:28:41 * fryguybob does not use tabs in general.
16:28:45 <nand`> 4 space per tab seems to be the convention
16:28:58 * cmccann prefers tabs in every other language but uses spaces in haskell
16:28:59 <nand`> though I have my editor set to 2 since I like indenting ‚Äúwhere‚Äù and ‚Äúlet .. in‚Äù by just two spaces
16:29:03 <tikhonjelvis> nand`: Except sometimes it's 2. Or 8.
16:29:07 <kaspare> 4 space I like, but then you get someplace where convention is 8 and layout is broken...
16:29:10 <ddarius> yoklov: The Haskell layout rule is actually pretty complicated due to one little side-condition.  I don't believe GHC implements it correctly.
16:29:15 <lobster2> I don't indent my code in anyway whatsoever. Makes it hard to read if I do (I kid)
16:29:23 <tikhonjelvis> My where's are indented by 2 in Haskell. But that's just me.
16:29:31 <cmccann> tikhonjelvis, I do that too
16:29:32 <nand`> the solution is to write one-liners
16:29:36 <cmccann> not sure where I picked that habit up
16:29:38 <SubtleArray> tikhonjelvis: Because it's the default editor in my Mint OS. :D It's a quirk I have. I like being able to use whatever editor is available to type code, whether it's gedit, emacs, or kate. I don't like depending on IDEs.
16:29:38 <nand`> ditto
16:29:41 <kaspare> 2 or 3 depending, for me
16:29:42 <nand`> it looks nicest
16:29:54 <ddarius> That said, you don't need to understand all the rules of layout to know enough to produce correct layout.
16:30:01 <lobster2> kate is a linux text editor
16:30:02 <lobster2> ?
16:30:08 <nand`> yes
16:30:11 <nand`> but also a name
16:30:11 <lobster2> ok
16:30:12 <tikhonjelvis> Bah, I refuse to dignify an computer without Emacs as useable.
16:30:29 <SubtleArray> fryguybob: Yeah, I learned that the hard way. I make sure I always use tabs as spaces.
16:30:31 <lobster2> Emacs are linux only as well?
16:30:34 <tikhonjelvis> kate is from KDE
16:30:40 <lobster2> oh
16:30:40 <tikhonjelvis> no
16:30:43 <nand`> Personally I use Sublime Text 2 in vim-mode; I'm considering trying out emacs in vim mode though
16:30:50 <kaspare> I started with Miranda which I think was layout-only.  It was hard to wrap my brain around the { ;... } alternative in Haskell.
16:30:52 <nand`> since it has better haskell support
16:31:12 <tikhonjelvis> Emacs transcends operating systems :)
16:31:12 <tikhonjelvis> I've used it on Windows, Linux, Solaris and even OS X.
16:31:21 <yoklov> ddarius: right, i never really think about it more than "indent subexpressions deeper"
16:31:31 * cmccann thinks coming from Miranda to Haskell must be an unusual experience compared to most other languages, heh
16:31:48 <ddarius> Presumably it wasn't unusual at some point.
16:31:50 <lobster2> I've never heard of Solaris.
16:31:54 <kaspare> Did layout rules change at all for do notation since its introduction?
16:32:04 <tikhonjelvis> Ironically, I haven't used it on BSD because there aren't any BSD computer labs here.
16:32:15 <lobster2> I'll be right back
16:32:20 <ddarius> kaspare: Yes.
16:32:25 <kaspare> (though so)
16:32:27 <SubtleArray> lobster2: Yes, kate it. But it can also be used to write code. It highlights syntax, etc, and you can run through command line.
16:32:39 <lobster2> ok
16:32:53 <tikhonjelvis> It's a system from Sun.
16:33:02 <lobster2> *oracle now
16:33:21 <kaspare> cmccann: you jest I expect.  Wasn't Miranda pretty much a model for Haskell??
16:33:58 <cmccann> kaspare, that's what I mean. it must be about the only language where moving from it to Haskell isn't a massive shock in multiple ways :P
16:34:01 <SubtleArray> tikhonjelvis: :D
16:34:29 <nand`> What is Gofer? Was it a precursor to Haskell or what? I've seen it used once or twice in Wadler's papers
16:34:44 <kaspare> Yeah.  It was a relief when HBC/Haskell arrived -- there was a gap after the commercialisation of Miranda where the options were less appealing.
16:34:55 <SubtleArray> Sublime is beautiful, but it costs money...
16:34:56 <cmccann> there were multiple precursors to Haskell, as I understand it
16:35:13 <cmccann> a major goal being to unify things
16:35:14 <tikhonjelvis> SubtleArray: it's also not quite as capable as Emacs, as far as I know
16:35:24 <kaspare> I think LML was one, but the syntax was MLy never took to it...
16:35:24 <nand`> SubtleArray: unfortunately it's not free and open source, yeah. That's the only doubt I have about it. It's nicer to use than regular vim though, but that's just because I can't be bothered to set vim up properly
16:35:35 <cmccann> or that's what I vaguely recall from reading a history of haskell by SPJ I think
16:35:54 <mdxbhmt> cmccann: yes, haskell was to unite all the f.p.
16:36:01 * cmccann is very much a newcomer here :T
16:36:07 <ddarius> Gofer was a Haskell variant (created after Haskell) that was used to experiment with constructor classes and multiparameter type classes and a few other extensions.
16:36:17 <kaspare> I found handwritten lecture notes by SPJ in a programming language lab at Univ. Calgary!
16:36:19 <ddarius> Functor and Monad were first makde in Gofer.
16:36:27 <nand`> ddarius: oh, that explains it
16:36:35 <kaspare> (I am rasfar by the way, but I lost my password...)
16:36:41 <ddarius> Hugs stands for "Haskell User's Gofer System"
16:36:41 <tgeeky> hum
16:37:53 <ddarius> mdxbhmt: Haskell was to unite the -lazy- functional programming languages.
16:38:05 <mdxbhmt> ddarius: yes, that would be more correct
16:38:23 <tgeeky> ddarius: succeed
16:38:28 <tazjin> I can't write imperative programs anymore o.O
16:38:47 <nand`> tazjin: just recurse
16:39:03 <mdxbhmt> Imperative is so complicated
16:39:11 <tgeeky> they're both complicated
16:39:17 <cmccann> tazjin, imperative programming languages are like monads, only with worse syntax
16:39:18 <tikhonjelvis> I still have to :(
16:39:18 <tgeeky> imperative is more difficult to reason about
16:39:28 <mdxbhmt> it seems easier to write, but then
16:40:06 <tikhonjelvis> nand`: Then you get a stack overflow except and a gigantic stack trace.
16:40:13 <nand`> How long until we get a purely functional processor architecture? The knowledge of Haskell compiling down to dirty assembly seeds doubt in my mind
16:40:30 <ddarius> Impure languages are more expressive than pure languages and that thus costs you the ability to reason about such code but gains you simplicity in writing code (more changes are local changes.)
16:40:35 <nand`> tikhonjelvis: ah, you're forced to use an imperative language that doesn't have tail call recursion?
16:40:44 <tikhonjelvis> nand`: Python :(
16:40:51 <ddarius> nand`: There are already two versions of the Reduceron.
16:41:01 <yoklov> imperative programming is just founded on intuition rather than mathematics.
16:41:09 <nand`> ddarius: Ah, I did remember something about that but forgot the name
16:41:16 <yoklov> at least, that's how i've always thought of it.
16:41:17 <nand`> When will it replace x86?
16:41:19 <laufer> @pl id
16:41:19 <lambdabot> id
16:41:29 <ddarius> Mathematics is founded on intuition.  There are certainly formal semantics for imperative languages.
16:41:40 <laufer> @pl \_ y z -> 1 + y + z
16:41:41 <lambdabot> const ((+) . (1 +))
16:41:41 <hpc> nand`: pretty much never :P
16:41:42 <mdxbhmt> ddarius: in some cases, I think the  problem stands that imperative code doesn't tell you everything on the first look, it's not explicit
16:41:53 <ddarius> mdxbhmt: That's exactly what is happening.
16:41:55 <hpc> nand`: and it probably won't replace anything else either
16:42:37 <mdxbhmt> ddarius:  and not being explicit is complicate...
16:43:01 <nand`> You can tell a lot about a Haskell function by its type signature, the same is definitely not true for imperative procedures (barring parameter names)
16:43:02 <laufer> @pl \_ y z -> 1 +(y + z)
16:43:03 <lambdabot> const (((1 +) .) . (+))
16:43:26 <ddarius> mdxbhmt: It complicates things for the reader, but it simplifies things for the writer since now I don't need to change everywhere else to make explicit a new aspect of the code.
16:43:30 <kaspare> nand`, I always had the wierd idea that FPLs were closer to architecture, because my Miranda prof was also an architecture nut.
16:43:39 <nand`> and in some languages, even with parameter names
16:43:40 <yoklov> darius: you really think mathematics is founded on intuition?  just because it can be intuitive doesn't mean thats where it originated from. (same goes for imperative programming re. mathematics)
16:43:52 <ddarius> kaspare: Combinatorial logic is all pure functional.
16:44:14 <cmccann> pf, programs are an input to the compiler, therefore the expressive power of a programming language is in contravariant position and thus equivalent to reducing the ability to express things about the compiler's output :P
16:45:03 <ddarius> yoklov: Most people don't find mathematics intuitive, but the core ideas, in my opinion, are based on human intuitions about the physical world.  Mathematics is a formalization and extrapolation of those intuitions.
16:45:05 <nand`> mathematics is ultimately founded on perception and the way the human brain processes information. Where it expanded to from there I cannot describe, but basic arithmetic follows the need for expressing relationships encountered in our daily lives
16:45:13 <nand`> one apple, two apples, etc.
16:45:25 <nand`> and by ‚Äúfounded‚Äù I really mean ‚Äúoriginated from‚Äù
16:45:31 <cmccann> ddarius, not to mention that many developments in mathematics have preceded the development of their formalizations
16:45:53 <mdxbhmt> One day, compilers will be based on AI, will compile the hell you throw at them, and scream if it's ambiguos
16:46:05 <hpc> mdxbhmt: i do hope that's a literal scream
16:46:06 <wavewave> hxournal has a new faster parser!
16:46:20 <kaspare> "Aaiii!!"
16:46:20 <cmccann> mdxbhmt, compilers like that already exist. they are called "programmers".
16:46:20 <nand`> @quote alien
16:46:20 <lambdabot> Anonymous says: The alien rulers of the galaxy must surely use a statically typed language with type inference
16:46:26 <nand`> hmm
16:46:27 <nand`> wrong quote
16:46:43 <tikhonjelvis> I like how there are multiple quotes about aliens.
16:46:46 <nand`> @quote programming with an alien
16:46:46 <lambdabot> No quotes for this person. It can only be attributed to human error.
16:46:46 <mdxbhmt> cmccann: yeah but those that screams are those who come after the programmer pass by
16:46:51 * fryguybob should try hxournal...
16:46:54 <nand`> ah, how do I search for a string like that?
16:47:04 <ddarius> nand`: @quote takes a regex
16:47:10 <mdxbhmt> hpc:  that should have some interesting consequences
16:47:11 <hpc> @quote alien
16:47:11 <yoklov> i'm not so sure. so much of math is so profoundly unintuitive, not to mention how little of math people without education in it understand.
16:47:11 <lambdabot> turbopascal says: I heard that next year, the whole [ICFP] spec will be given in a made up alien language that you will have to decipher as step I.
16:47:14 <ddarius> The simplest thing is to replace ' ' with '.'
16:47:18 <hpc> @quote alien
16:47:18 <lambdabot> lispy says: I think communicating with aliens will make unicode obsolete :(
16:47:26 <ddarius> Technically, that does something different, but it usually will find what you want.
16:47:35 <Sgeo> @quote programming.*alien
16:47:35 <lambdabot> xplat says: When I'm programming in Agda, I feel like I'm pair-programming with some god-like entity that tells me when I'm wrong. When I'm programming in Scala, I feel like I'm pair-programming
16:47:36 <lambdabot> with an alien that's about as smart as I am.
16:47:45 <nand`> @quote programming.*alien
16:47:45 <lambdabot> xplat says: When I'm programming in Agda, I feel like I'm pair-programming with some god-like entity that tells me when I'm wrong. When I'm programming in Scala, I feel like I'm pair-programming
16:47:45 <lambdabot> with an alien that's about as smart as I am.
16:47:48 <nand`> oh
16:47:50 <nand`> I'm too slow
16:48:25 <tikhonjelvis> Heh, that's a perfect quote. I'll have to pass iton to my Scala friend.
16:49:12 <nand`> mdxbhmt: one day computers will yell at you when you try to invent the perl programming language
16:49:29 <nand`> they feel the pain
16:49:33 <mdxbhmt> hahah
16:49:39 <ddarius> xplat seems pretty smart, excepting the programming in Scala, so that may be saying a lot.
16:49:45 <dylukes> Agh.
16:49:57 <tikhonjelvis> nand`: But it's so easy to make annoying language design decisions :)
16:50:01 <dylukes> We're behind #git and #jquery by just a few people...
16:50:07 <nand`> tikhonjelvis: decisions?
16:50:20 <ddarius> dylukes: 825 is hardly the high water mark for this channel.
16:50:28 <dylukes> Oh, well yeah.
16:50:28 <mdxbhmt> dylukes: each haskeller can spawn milions of green thread, it's time
16:50:43 <dylukes> We've settled above #python permanently it seems anyhw.
16:50:46 <dylukes> Before it went up and down.
16:50:56 <tikhonjelvis> are we above #python now?
16:51:01 <Dread> Why is ghci complaining about the 2nd '=' in this line? data Node = Node {isNode=Bool,isOpen=Bool,isVisible=Bool}
16:51:07 <nand`> I'm always surprised by how popular Haskell actually is
16:51:08 <ergot> hi, I'm having some issues with forkIO, if I run my program with only 1 IO thread seems to work fine but when running it with many threads at some point starts to print garbage on output
16:51:09 <dylukes> tikhonjelvis: We float around 10-30 people over #python.
16:51:18 <ddarius> Dread: Because it's a syntax error.
16:51:18 <kaspare> Have we cracked 1000?
16:51:19 <nand`> People seem to think it's a niche language but I'm seeing it mentioned more and more
16:51:22 <tikhonjelvis> It's because Haskell is awesome.
16:51:26 <dylukes> nand`: In certain contexts it's VERY mentioned.
16:51:32 <hpaste> ergot pasted ‚Äúcrawler‚Äù at http://hpaste.org/63513
16:51:35 <dylukes> i.e., IRC, SO, LtU,...
16:51:39 <nand`> tikhonjelvis: absolutely. Even the fact that it's among the fastest in those shootout benchmarks boggles my mind
16:51:39 <dylukes> Reddit.
16:51:43 <ddarius> kaspare: No.  I don't think there has been over 900, but we have been close in my experience.
16:51:44 <tikhonjelvis> Now, what suprises me is why *Python* is so popular.
16:51:44 <quintessence> Dread: you use field :: Type for the type of record fields, not field = Type
16:51:45 <dylukes> Btt on thers it's not.
16:51:49 <dylukes> nand`: The thread ring one is BS.
16:51:58 <dylukes> And those shootouts don't even represent anything meaningful
16:52:00 <ergot> I dont know if its my fault or some kind of bug in ghc/runtime
16:52:03 <tikhonjelvis> It's not a good language, it's not a fast language, it's not an interesting language...
16:52:09 <tikhonjelvis> and yet everybody tries to force me to use it
16:52:10 <yoklov> tikhonjelvis, python looks like pseudocode, why wouldn't it be popular
16:52:11 <nand`> dylukes: true enough, the entire IRC numbers thing might be biased towards haskell
16:52:12 <tikhonjelvis> successfully
16:52:13 <kaspare> I forget what the numbers were when I joined (as rasfar) in 2004, but much much less!
16:52:15 <mdxbhmt> python population is not the irc population
16:52:22 <Dread> quintessence: Thanks
16:52:25 <dylukes> mdxbhmt++
16:52:28 <nand`> tikhonjelvis: it's an easy language
16:52:40 <dylukes> http://blaag.haard.se/Why-Python-is-important-for-you/
16:52:43 <dylukes> Not a bad post.
16:52:44 <ddarius> ergot: It's your fault.
16:52:45 <nand`> no confusing brackets
16:52:49 <tikhonjelvis> Yeah, that article was dubious at best.
16:53:04 <tikhonjelvis> Of course, Java is even more popular...
16:53:19 <ergot> ddarius what could be the cause of the problem?
16:53:31 <ddarius> ergot: You probably have a mess of race conditions.
16:54:26 <cmccann> ergot, as a rule of thumb, if you don't know whether something is your own fault or a compiler bug, then it's not a compiler bug :P
16:55:03 <tikhonjelvis> Actually, it's even simpler: in general, it's not a compiler bug.
16:55:04 <mdxbhmt> ddarius: if various threads try to print at the same time is a race problem under haskell RTS?
16:55:15 <JoeyA> I'm about to write a Chan alternative that uses separate types for the read and write ends.  What would be a good name for these types?
16:55:19 <wavewave> cmccann : I am working on pressure sensitivity support in hxournal.. I will let you know when things done.
16:55:25 <mdxbhmt> ddarius: haskell won't wait a thread finish to print before switching context
16:55:29 <JoeyA> I'm thinking a good name for the read end would be Cursor or something.
16:55:38 <cmccann> wavewave, oh hey, awesome :D
16:55:42 <gregAtio> how do i find a a new file that doesnt exist yet , that vey similar to a current file in the directory
16:55:51 <JoeyA> (or Iterator, but I think programmers are sick of that name now)
16:56:19 <mapreduce> Source and Sink?
16:56:36 <JoeyA> perhaps.  So you write to the sink and read from the source?
16:56:45 <nand`> Readable, Writable?
16:56:50 * cmccann has used Entry and Egress in his code, but don't take his advice on names
16:56:50 <wavewave> cmccann : ;-) .  I already made support for wacom pen button some days ago.
16:57:08 <nand`> might be too close to Reader/Writer though
16:57:11 <cmccann> wavewave, yes, I saw that :D
16:57:21 <ddarius> mdxbhmt: It prints the characters in the correct order.  They may be interleaved though.
16:57:27 <quintessence> ChanOut, ChanIn?
16:57:31 <JoeyA> Well, the interesting thing about Readable is that you can make copies of it, and subscribe to the Writable.  It's like a pointer or iterator.
16:57:48 <mdxbhmt> ddarius: that may look like garbage depending on thread n¬∫
16:57:52 <JoeyA> gregAtio: Find a file that doesn't exist?  I don't understand.
16:57:57 <ddarius> mdxbhmt: Yes.  So?
16:58:25 <mdxbhmt> ddarius: could be whats happening with ergot
16:58:30 <ddarius> mdxbhmt: It probably is.
16:58:33 <danmaftei> what's the cleanest way to divide a number by the length of the list? is there no implicit conversion?
16:58:42 <gregAtio> joeyA i usually use find to create a new file
16:58:51 <gregAtio> C-x C-f
16:59:04 <dylukes> Same here :\.
16:59:25 <ergot> oh I didn't know that, I'm going to try serializing the printing then
16:59:26 <ergot> thanks
16:59:26 <ddarius> danmaftei: Haskell has no implicit conversions whatsoever.
16:59:33 <JoeyA> danmaftei: / fromIntegral xs
16:59:43 <dylukes> JoeyA: Sink and Source
16:59:48 * cmccann meditates upon the deep truth that a series of things performed concurrently will happen concurrently
16:59:49 <JoeyA> > 100 / (fromIntegral . length) [1,2,3]
16:59:51 <lambdabot>   33.333333333333336
17:00:03 <danmaftei> thx
17:00:22 <JoeyA> Note that length takes O(n) time to compute.
17:00:45 <dylukes> JoeyA: Trying to think of any other names...
17:00:46 <danmaftei> I know. :) no way around it, i need to parameterize a uniform distribution
17:00:52 <ddarius> More explicitly, length xs takes O(length xs) time to compute.
17:01:13 <JoeyA> I think I'll just stick with ChanRead and ChanWrite.
17:01:24 <dylukes> JoeyA: ChanR/ChanW might be nicer.
17:01:27 <dylukes> But that's just my taste.
17:01:34 <mdxbhmt> Chan always remembers 4chan..., oh the internet
17:01:35 <ergot> well actually I think the problem is not just priting, because I'm seeing data that shouldn't see
17:01:35 <JoeyA> ddarius: How long does O(length xs) take to compute?
17:01:53 <quintessence> is there reason other than convention why it's always fromA and not toB?
17:01:56 <mdxbhmt> JoeyA: it takes O(O(length xs))
17:02:07 * hackagebot mysql 0.1.1.4 - A low-level MySQL client library.  http://hackage.haskell.org/package/mysql-0.1.1.4 (BryanOSullivan)
17:02:07 <ddarius> O(length xs) (or really O(length)) is a mathematical set.
17:02:08 <JoeyA> I was going to call this package "lchan", but I didn't like what I saw when I googled it.
17:02:16 <JoeyA> I know, I'm kidding.
17:03:00 <mdxbhmt> JoeyA: TIL
17:03:22 <JoeyA> What does TIL stand for?
17:03:28 <mdxbhmt> today i learned
17:03:32 <JoeyA> oh
17:03:52 <JoeyA> dylukes: Thanks.  ChanR/ChanW sounds great.
17:04:00 <JoeyA> Now what do I call the read/write functions?
17:04:00 <dylukes> The thing is like...
17:04:04 <nand`> JoeyA: lewd
17:04:04 <dylukes> they're not really Channels anymore.
17:04:33 <JoeyA> There's a good chance the user will be importing Control.Concurrent, so I'd like to avoid using writeChan and readChan.
17:04:38 <JoeyA> (the names, that is)
17:04:58 <nand`> writeChanW!
17:05:00 <JoeyA> writeChanW and readChanR, but it's a tad repetitive.
17:05:02 <ddarius> You could use Channel and writeChannel/readChannel ...
17:05:12 <JoeyA> Sounds good.
17:05:12 <nand`> but that's too vague
17:05:21 <nand`> and doesn't make clear the distinction between Channel and Chan
17:05:29 <JoeyA> Chan(nel) is pretty vague, anyway.
17:05:35 <mapreduce> get, put
17:05:38 <ddarius> What is the difference?
17:05:43 <dylukes> mapreduce: definitely not.
17:05:48 <dylukes> those are used for serialization.
17:06:01 <mdxbhmt> IMO haskell has some pretty vague var names
17:06:05 <nand`> get/put are methods on State either way
17:06:07 <JoeyA> dupChan sounds inefficient from the reading of it.
17:06:17 <JoeyA> Internally, it works by creating another "cursor" on the stream of bytes.
17:06:24 <dylukes> I mean, dup() is similar.
17:06:28 <JoeyA> err, stream of values
17:06:28 <quintessence> broadcast/listen?
17:06:33 <dylukes> dup()'ing a file descriptor is quite cheap.
17:06:44 <dylukes> quintessence: Careful with the word "broadcast'
17:06:45 <JoeyA> quintessence: Sounds good
17:06:55 <dylukes> I wouldn't use "broadcast"
17:06:57 <dylukes> I suggest relay/receive.
17:07:01 <dylukes> Or something like that.
17:07:07 <ddarius> send/recv
17:07:07 * hackagebot hedis-pile 0.3.1 - Caching mandatory data with Redis  http://hackage.haskell.org/package/hedis-pile-0.3.1 (AlexanderDorofeev)
17:07:20 <JoeyA> Well, broadcast sends a message to all "listeners" of the channel.
17:07:22 <dylukes> ddarius's suggestion is also good :P
17:07:27 <MaskRay> i've had a superficial understanding of `foldl (++) [] (replicate n [0]'s O(n^2) behavior, as for `(...)++[0]', the stuff within the parenthesis needs to be evaluate to evaluate the whole stuff
17:07:32 <dylukes> JoeyA: Ah, then it does make sense.
17:08:05 <nand`> I vote for broadcast/listen
17:08:19 <JoeyA> The only problem with listen is that it's used by Network.Socket.
17:08:30 <dylukes> My suggestion is,
17:08:30 <JoeyA> broadcast is spared from a Hoogle result
17:08:36 <dylukes> use the most clear names and don't worry about collision.
17:08:43 <dylukes> We have modules to help with that.
17:08:43 <JoeyA> (except for Broadcast, a type constructor)
17:08:57 <dylukes> I mean, we even have Prelude.putStrLn and Data.ByteString.putStrLn...
17:09:00 <MaskRay> thus we get a recurrence formula: T(n) = T(n-1)+O(n)
17:09:17 <JoeyA> So Channel / broadcast / listen
17:09:30 <JoeyA> oh wait, two types, not one.
17:09:36 <dylukes> JoeyA: ob
17:09:37 <dylukes> oh
17:09:38 <dylukes> duh
17:09:39 <dylukes> dude
17:09:43 <dylukes> just use radio terminology
17:09:48 <JoeyA> ob?
17:09:52 <dylukes> Transmitter/Receiver
17:10:00 <JoeyA> too verbose
17:10:03 <nand`> trans/recv
17:10:04 <JoeyA> maybe...
17:10:10 <dylukes> then trans/recv makes sense...
17:10:12 <ddarius> T/R
17:10:17 <JoeyA> agreed.
17:10:17 <MaskRay> i once thought lazy evaluation could speed up which turned out to be feckless
17:10:18 <nand`> too short
17:10:22 <mdxbhmt> too short...
17:10:23 <nand`> for typeclasses
17:10:29 <JoeyA> However, I'd like to stay away from recv, since I prefer to use it for network stuff.
17:10:39 <dylukes> JoeyA: Why...?
17:10:39 <nand`> transmit listen should work then
17:11:00 <JoeyA> broadcast :: Channel a -> a -> IO ()
17:11:02 <dylukes> You do know recv *isn't* just for network stuff right?
17:11:06 <nand`> since using radio analogy you broadcast to everybody, users can simply choose to listen to it or not
17:11:08 <quintessence> MaskRay: it's not exactly that the (...) has to be evaluated multiple times, it's that ++ has to traverse (and copy) its first argument before it gets to the end
17:11:24 <JoeyA> listen :: Channel a -> IO (Radio a)
17:11:28 <dylukes> recv is for "receiving a message", from any sort of socket.
17:11:31 <dylukes> And that's what you have here.
17:11:33 <JoeyA> Though Radio reminds programmers of radio buttons.
17:11:43 <dylukes> The radio metaphor fits really well.
17:11:46 <nand`> JoeyA: that was my remotest thought
17:11:55 <dylukes> JoeyA: Don't use listen...
17:11:59 <nand`> I don't think it's possible to confuse it with radio buttons in this context
17:12:01 <dylukes> listen has other network connotations too :P.
17:12:05 <dylukes> And they're totally different.
17:12:11 <dylukes> Whereas the connotations of "recv" are the same.
17:12:20 <nand`> subscribe?
17:12:26 <JoeyA> subscribe is good.
17:12:31 <JoeyA> Except people don't *create* radios when they listen.
17:12:36 <dylukes> tuneIn :P
17:12:38 * dylukes jests.
17:12:41 <nand`> haha
17:12:45 <dylukes> Unless you really want to take the metaphor all the way.
17:12:52 <JoeyA> tuneRadio :: Radio a -> Channel a -> IO () -- tune a radio to another station
17:12:56 <JoeyA> I think I can actually implement that.
17:13:04 <dylukes> type Radio = Transceiver
17:13:06 <nand`> tuneIn 77.1 FM
17:13:08 <JoeyA> (without breaking the design, which is based on Chan)
17:13:13 <dylukes> type Transceiver = (Transmitter, Receiver)
17:13:42 <nand`> a radio that can transmit?
17:13:44 <JoeyA> Well, here's another way of looking at it: a Receiver is semantically equivalent to a lazy list of items.
17:13:44 * cmccann suggests paintBikeshed and examineBikeshed
17:13:52 <JoeyA> cmccann++
17:13:54 <dylukes> ;P
17:13:56 <dylukes> Btw, JoeyA
17:13:57 <mdxbhmt> nand`: and it transmit something diferent than sound
17:13:59 <dylukes> the advantage to the radio metaphor,
17:14:17 <dylukes> is you can take terms like Transponder, Repeater, etc..
17:15:05 <nand`> you can even use frequencies as channel unique channel descriptors
17:15:10 <nand`> as unique*
17:15:11 <MaskRay> quintessence: thanks. another problem by which i'm always haunted is the choice between foldl/foldr
17:15:24 <JoeyA> The only reason I have a Read object to begin with is to make reading the channel more deterministic.
17:15:35 <dylukes> MaskRay: foldl, foldl', foldr, etc all exist for different cases.
17:15:37 <JoeyA> In my current implementation of this package, I only provide a lazy list.
17:15:43 <dylukes> Generally foldl isn't what you want though.
17:15:48 * mdxbhmt wonders of spy movies
17:15:53 <nand`> if you want foldl you mostly want foldl'
17:16:01 <dylukes> Yeah.
17:16:12 <nand`> eg. sum as foldl' (+) 0
17:16:24 <nand`> since if you want to evaluate it, you have to evaluate it the whole way, and it's possible to evaluate left associatively
17:16:24 <dylukes> I would do foldl1' (+)
17:16:33 <nand`> dylukes: but sum [] = 0
17:16:36 <mdxbhmt> what's behind the ' in foldl' ?
17:16:37 <dylukes> Oh.
17:16:39 <dylukes> True.
17:16:42 <dylukes> mdxbhmt: "strict"
17:16:48 <nand`> @src foldl'
17:16:48 <lambdabot> foldl' f a []     = a
17:16:49 <lambdabot> foldl' f a (x:xs) = let a' = f a x in a' `seq` foldl' f a' xs
17:16:52 <JoeyA> By the way, it is possible to bypass the read end of the channel and just expose a Stream.
17:16:54 <mdxbhmt> ddarius: should strict be ! ?
17:17:05 <dylukes> mdxbhmt: It's just a hyphen as in "prime"
17:17:07 * hackagebot wai-middleware-cache-redis 0.1.2 - Redis backend for wai-middleware-cache  http://hackage.haskell.org/package/wai-middleware-cache-redis-0.1.2 (AlexanderDorofeev)
17:17:08 <MaskRay> quintessence: i heard that foldl would get performance when the function passed to it is stict on the second argument
17:17:09 * hackagebot pandoc 1.9.1.1 - Conversion between markup formats  http://hackage.haskell.org/package/pandoc-1.9.1.1 (JohnMacFarlane)
17:17:13 <dylukes> it's doesn't really mean anything.
17:17:14 <mdxbhmt> hmm
17:17:16 <mdxbhmt> ok
17:17:23 <dylukes> Usually foo and foo', means
17:17:30 <nand`> ' generally means ‚Äúslightly modified version‚Äù
17:17:30 <dylukes> that both do the same thing or have the same signature,
17:17:37 <dylukes> but it's slightly modified
17:17:37 <nand`> or ‚Äúhelper function‚Äù
17:17:44 <mdxbhmt> hmmm, i see
17:17:44 <dylukes> Yeah.
17:17:48 <dylukes> I often do stuff like
17:17:49 <MaskRay> dylukes: there's time where either is suitable. i'm seeking the better choice
17:17:52 <JoeyA> Reading it can be done in functional style: unconsStream :: Stream a -> IO (a, Stream a)
17:17:57 <dylukes> foo = runSomeMonadShitT foo' ....
17:17:59 <dylukes> where foo' = ...
17:18:11 <dylukes> MaskRay: ?
17:19:03 <MaskRay> dylukes: considering `foldl f a xs', i heard that if f is lazy on its second argument, it's better switch to foldr
17:19:09 <dylukes> @src foldl
17:19:10 <lambdabot> foldl f z []     = z
17:19:10 <lambdabot> foldl f z (x:xs) = foldl f (f z x) xs
17:19:11 <dylukes> @src foldl'
17:19:12 <lambdabot> foldl' f a []     = a
17:19:12 <lambdabot> foldl' f a (x:xs) = let a' = f a x in a' `seq` foldl' f a' xs
17:19:19 <dylukes> @src foldr
17:19:19 <lambdabot> foldr f z []     = z
17:19:20 <lambdabot> foldr f z (x:xs) = f x (foldr f z xs)
17:19:49 <cmccann> MaskRay, you should use foldr if you want the output to be a lazy data structure
17:19:50 <dylukes> :t foldl
17:19:50 <lambdabot> forall a b. (a -> b -> a) -> a -> [b] -> a
17:19:58 <MaskRay> dylukes: as foldl would create a O(n) unevaluated continuation stack and latter unwound it
17:20:08 <dylukes> That's what foldl' is for.
17:22:08 * hackagebot wai-middleware-cache-redis 0.1.3 - Redis backend for wai-middleware-cache  http://hackage.haskell.org/package/wai-middleware-cache-redis-0.1.3 (AlexanderDorofeev)
17:22:30 <dylukes> also MaskRay http://www.haskell.org/haskellwiki/Foldr_Foldl_Foldl'
17:25:50 <dylukes> MaskRay: Don't worry about it too much.
17:26:12 <dylukes> You can assess the performance later, the only time you need to be too mindful is when you're working with infinite streams.
17:26:38 <dylukes> foldr foo z xs <=> foldl' (flip foo) z xs
17:27:26 <MaskRay> dylukes: thanks. this time i got better understanding when reading this article
17:28:26 <tazjin> So a friend just asked me whether the Haskell community occasionally sacrifices animals and acts like a cult, because that would totally motivate him to join us. Thoughts?
17:28:57 <dmwit> Your friend is welcome to sacrifice animals and act like a cult if he wants...
17:29:13 <nand`> I wouldn't be against sacrificing a camel every once in a while.. and maybe some snakes
17:29:58 <Flink> I mean, sometimes after a long day of coding Haskell maybe I'll take out the ol' Sacrificial Dagger and sacrifice a squirrel or something.
17:30:04 <Flink> Usually I'm tired though and just don't feel like it.
17:30:21 <JoeyA> Will anyone be angry if I leave out a mutable receiving object for my split channel package (called broadcast-channel).
17:30:45 <nand`> radio-channel
17:31:02 <dmwit> Does anybody know how to get darcs to do something when I push a patch to a repository? I followed the instructions in the manual, and nothing happened. (I asked in #darcs, but that seems to be a bit lower-traffic, so sorry for the "cross-post".)
17:31:05 <JoeyA> That is, instead of recv :: Radio a -> IO a, it's getStream :: Stream a -> IO (a, Stream a)
17:31:20 <MaskRay> many problems which seemed to be abstruse and were left aside formerly are quite easy when i have learned other stuff
17:31:47 <JoeyA> Has anyone here written a program where multiple threads read from the same Chan simultaneously?
17:32:37 <JoeyA> I suppose it's useful for parallelism (fork multiple threads, and have them readChan on a job queue, first come first serve)
17:33:05 <nand`> yeah, I've used patterns like that a fair number of times in other languages, haven't done concurrency in haskell at all yet
17:34:02 <JoeyA> So I've decided to call the write end Channel and the receive end Stream (immutable, so getStream :: Stream a -> IO (a, Stream a).  What should I call the mutable variant of Stream?
17:34:16 <alpounet> JoeyA, have you taken a look at STM ?
17:34:22 <JoeyA> Yes
17:34:58 <mandaya> Then why not just use a TVar Stream, and use the STM to manage the concurrency issue?
17:35:29 <elliott> JoeyA: What's wrong with the existing split channel packages?
17:35:31 <JoeyA> The reason I'm implementing an alternative to Chan is because you can't create a Chan and have no listeners, as it will leak memory due to the read end never moving.
17:35:49 <JoeyA> chan-split doesn't split the channel internally, so ^ happens.
17:36:15 <elliott> Wouldn't sending a patch to chan-split be better? But okay.
17:36:21 <JoeyA> Another, unrelated problem: readChan and writeChan aren't fully exception-safe unless you use mask.
17:36:53 <JoeyA> The reason I'm avoiding STM is: I plan to use this mainly for my program's logging facility.
17:37:16 <JoeyA> I'd like to be able to log stuff in pure code if possible, without worrying about nested transaction errors.
17:37:32 <elliott> s/pure/unsafe/ :P
17:37:44 <elliott> erm
17:37:44 <JoeyA> Right
17:37:49 <elliott> wait, you're planning to use unsafe /logging/?
17:37:51 <elliott> like, for non-debugging purposes?
17:38:08 <elliott> (the correct answer is not "yes")
17:38:10 <JoeyA> No, but I don't want to eliminate the option needlessly.
17:38:23 <JoeyA> Besides, logging should be fairly efficient, and STM isn't quite that.
17:38:28 <elliott> in the same way that haskell eliminates the option of type errors
17:38:40 <elliott> sure STM is efficient, Data.Unique got a speedup from switching to MVar to TVar
17:38:44 <JoeyA> (TChan is about 4x slower than Chan, according to my na√Øve benchmarks)
17:38:49 <elliott> *from MVar
17:38:53 <Rc43> I want to create config file, written in haskell, for a haskell programm. It must be interpreted run-time. How can I do it?
17:39:08 <elliott> Rc43: http://hackage.haskell.org/package/dyre
17:39:11 <nand`> Rc43: like xmonad
17:39:34 <nand`> well, that's less interpreted at runtime and more recompiled at runtime
17:39:40 * cmccann adds unsafeCoerce to the API of all his libraries, so as not to eliminate the option of experience segfaults
17:40:34 <elliott> JoeyA: anyway it is OK to use unsafe prints for things like debugging but production logging in pure code is out of the question
17:40:52 <JoeyA> Fair enough
17:40:58 <ddarius> @hackage configurator
17:40:58 <lambdabot> http://hackage.haskell.org/package/configurator
17:41:03 <elliott> perhaps such a thing could be useful for tracking down bugs on very high optimisation level but it would only be even remotely viable (and trustable) with compiler support, otherwise compiler optimisations will break things horribly
17:41:04 <elliott> *levels
17:41:08 <elliott> erm
17:41:13 <elliott> s/high optimisation levels/high logging levels/
17:41:13 <kniu> so I wrote a typechecker
17:41:17 <kniu> = lambda {x. lambda {y. y x}}
17:41:17 <cmccann> logging pure code generally doesn't even make sense
17:41:17 <kniu> : forall ->. forall a. forall d. a -> (a -> d) -> d
17:41:25 <kniu> and I guess I did something horribly wrong.
17:41:30 <elliott> ddarius: That doesn't solve the "written in haskell" part.
17:41:38 <elliott> Admittedly, Rc43 probably doesn't really want that.
17:41:59 <elliott> kniu: forall ->... that's a new one
17:42:06 <cmccann> and if Rc43 does want that, dyre is probably the answer
17:42:08 <nand`> elliott: my thoughts exactly
17:42:21 <elliott> cmccann: well, you could use it to track down coding errors perhaps, and analyse performance by counting log entries
17:42:28 <elliott> but all those things can be done better with other tools :P
17:42:40 <cmccann> elliott, that's not logging
17:42:42 <nand`> :: forall ->. Arrow (->) => a -> b
17:42:48 <cmccann> that's debugging or profiling what the runtime does
17:42:51 <nand`> is this valid?
17:42:52 <elliott> cmccann: indeed
17:42:54 <ddarius> No.
17:42:59 <elliott> no
17:43:04 <elliott> it would be forall (->) even if it was
17:43:05 <elliott> which it isn't
17:43:12 <Rc43> elliott, can I use dyre like `ports <- readFromConfig "config.hs"` ?
17:43:23 <Rc43> elliott, can't find example like it
17:43:40 <nand`> come to think of it that would break the moment I want to define an actual function
17:44:32 <kniu> okay
17:44:45 <elliott> Rc43: it's not going to be that easy
17:44:57 <elliott> I strongly recommend using a non-Haskell configuration format like the configurator package ddarius mentioned.
17:44:57 <kniu> the thing is, that "forall ->." thing is not supposed to be there, but due to a quirk in my representation of types, it is
17:45:01 <cmccann> elliott, which was my point. wanting "logging" in pure code usually indicates a gross conceptual error several steps prior
17:45:04 <elliott> Unless you have *very* specific needs, it's not a good idea.
17:45:07 <elliott> cmccann: right
17:46:04 <Rc43> elliott, i know that i can interpret dynamically source code (with hs-plugins for example), so i can interpret config like a program and get value of variable `ports`? Dyre works simillarily or not?
17:46:10 <nand`> idiomatic solution for logging inside a grossly imperative IO block? WriterT IO?
17:46:23 <nand`> WriterT [String] IO rather
17:46:44 <cmccann> elliott, yeah, sorry, people asking how to log pure code is a pet peeve of mine after running into a few very stubborn and very confused people :T
17:47:33 <MaskRay> dylukes: foldl seems worse than foldr as it creates a huge stack only to be unwound later (in total, about 2*n chunks are created during the process)
17:47:41 <nand`> come to think of it if I'm inside a grossly imperative IO block I can just use file writes
17:47:51 <cmccann> nand`, if you're already in IO you can do just about anything, yes :P
17:47:52 <elliott> Rc43: Yes, it is possible to compile Haskell source code at runtime and use it for configuration. However it requires a slightly different approach to work well, like dyre takes. Again, I strongly recommend considering another option, it is a great pain to get working properly and only suitable for very specific applications.
17:48:04 <elliott> nand`: throw an exception for every line!
17:48:11 <elliott> but save a continuation first so you can keep going afterwards
17:48:16 <nand`> then catch them all in a logging thread
17:48:16 <elliott> you'll need ContT.
17:48:18 <elliott> yes.
17:48:22 <nand`> perfect
17:48:23 <elliott> actually
17:48:28 <elliott> have two logging threads
17:48:35 <elliott> throw exceptions at them to key out binary
17:48:43 <elliott> with throwTo
17:48:52 <elliott> it's like the actor model, man.
17:49:04 <nand`> throwTo undefined == 1; throwTo _|_ == 0
17:49:06 <Rc43> elliott, simple config  is better because of bounded behaviour?
17:49:07 <cmccann> clearly ContT r (ReaderT PileOfIORefs IO) is the best monad to use
17:49:40 <elliott> Rc43: it'll be much much much easier to code and maintain, you won't have a runtime dependency on GHC, it'll be much faster (compiling and linking is slow!), your config format will be simpler...
17:49:56 <ddarius> cmccann: The ReaderT is unnecessary.
17:50:22 <nand`> I'd use StateT instead of ReaderT since you never know when you want to change IORefs around during your grossly imperative program
17:51:22 <ParadoxQuine> hey guys, just started learning me a haskell and i'm curious if any of the haskell to javascript compilers are fleshed out enough for everyday use?
17:51:33 <cmccann> ddarius, it's a convenient way to access lots of global variables, that's all
17:51:40 <nand`> ParadoxQuine: does this imply there are multiple?
17:51:46 <ddarius> cmccann: Yes, but you can already do that with just ContT r IO
17:52:38 <elliott> type Scheme = ContT () IO -- pure functional elegance
17:53:12 <zzo38> What does "global constraint requires installed instance" mean in the build failure logs?
17:53:13 <elliott> ParadoxQuine: not really everyday use, no
17:53:24 <cmccann> ddarius, I know you can but I'd think it would be more awkward to use
17:53:29 <ParadoxQuine> nand`: it appeared to me there were a few
17:53:31 <ddarius> nand`: There are multiple.
17:53:42 <dmwit> zzo38: You probably need to give us a bit more context.
17:53:49 <elliott> zzo38: your base constraint is wrong
17:53:55 <ddarius> cmccann: It would be equivalent to use.  More awkward to define.
17:53:58 <zzo38> dmwit:  http://hackage.haskell.org/packages/archive/extensible-data/0.1/logs/failure/ghc-7.4
17:54:00 <elliott> you require 4.3.*, but 4.4 and even 4.5 are out. hackage uses 4.5
17:54:08 <elliott> therefore your package cannot build on hackage, and it rightfully errors out
17:54:19 * ddarius should probably update to a newer version of Ubuntu.
17:54:22 <nand`> It seems bizarre to me. Bizarre, but it has piqued my curiosity. So I can basically write Haskell and deploy it eg. via UserScripts?
17:54:25 <zzo38> But is 4.5 compatible with this program?
17:54:27 <elliott> this has been elliott psychic services :)
17:54:38 <dmwit> zzo38: Yes, it means that cabal will refuse to try installing a different version of base.
17:54:42 <elliott> zzo38: there is no way to know that without you testing.
17:54:42 <ParadoxQuine> elliott: Darn! I would really love to replace all my client-side js coding for personal projects with a language that properly supports functional programming
17:55:05 <elliott> ParadoxQuine: compiling full haskell to js is probably not the most practical way anyway. but UHC seems promising if you want to do it
17:55:11 <elliott> and I think ghcjs is fundamentally sound. and there's that ji thing
17:55:18 <elliott> `(http://chrisdone.com/posts/2011-12-26-ji-haskell-web.html)
17:55:27 <elliott> fundamentally sound as in, only isn't ready because of lack of polish
17:55:38 <zzo38> It seems that it isn't because it uses the Any type from GHC.Exts and they changed it to require a kind parameter
17:56:11 * cmccann would expect a Javascript-generating EDSL to be more practical in the short term at least
17:56:17 <cmccann> not sure what exists on that front though
17:56:41 <ParadoxQuine> darn, no websockets, i need websockets
17:57:06 <zzo38> Is there any compatibility package I can use?
17:57:10 <ddarius> ParadoxQuine: It probably has a javascript "FFI" that would allow you to get any functionality you wan.t
17:57:21 <ParadoxQuine> ah ok
17:57:40 <ddarius> @google "foreign import javascript"
17:57:41 <lambdabot> https://github.com/sviperll/ghcjs/issues/3
17:57:47 <cmccann> that sounds promising
17:57:49 <elliott> I think ParadoxQuine is talking about Ji.
17:57:58 <elliott> In which case there's no "JS FFI" because it's just DOM-over-HTTP.
17:58:39 <zzo38> JavaScript does not even require HTTP or HTML or DOM
17:59:36 <ParadoxQuine> hmm i'm a bit confused about what Ji is
17:59:50 <ParadoxQuine> i'm not looking to controlt he client-side via a haskell backen
18:00:15 <zzo38> For my package, it is not only the Any type (I didn't even know types could take a kind as a parameter), but the way class instances are reified in Template Haskell also change
18:00:51 * elliott was just throwing out options.
18:00:53 <ParadoxQuine> i just want to write my client-side front-end code in a...better (more purely functional, more feature rich, less broken-at-the-core, etc) language than js
18:01:16 <ParadoxQuine> elliott: yes, i appreciate all the options so far
18:01:22 <ParadoxQuine> perhaps one will suffice for my needs
18:01:59 <ParadoxQuine> i'm also looking for projects to do to learn haskell well, but web frontend, my preferred domain, doesn't provide a lot of options
18:02:21 <elliott> consider preferring other domains :p
18:02:36 <nand`> I'm looking for an alternative to JS for writing web-page userscripts
18:02:44 <nand`> something like CoffeeScript that will compile down to JS
18:03:03 <ParadoxQuine> elliott: that's hard to do :P
18:03:19 <ddarius> ParadoxQuine: Study signal processing.
18:03:30 <nand`> unfortunately the extensive JavaScript DOM API will probably make this not nearly as functional in the first place
18:03:40 <nand`> and by ‚Äúfunctional‚Äù I really meant ‚Äúusable‚Äù
18:04:14 <ParadoxQuine> ddarius: that is wayyyy out of my area of expertise/interest
18:04:33 <geekosaur> in theory someone could work out a declarative interface to the DOM, but I expect that will take  alot of work, and a lot of time before it's actually usable
18:04:42 <ddarius> ParadoxQuine: The point was to bring it within your area of expertise and interest.
18:05:12 <cmccann> geekosaur, there's several ways to approach that
18:05:40 <cmccann> geekosaur, the easiest is probably seizing control of the browser market and all relevant standards organizations by means of bribery and/or assassination
18:05:44 <cmccann> and then fix the DOM by fiat
18:06:13 <geekosaur> I'm not sure it needs fixing per se
18:06:16 <ParadoxQuine> ddarius: confused again. wouldn't that expand my area of interest to include a new one (perhaps where more haskell abounds)
18:06:35 <elliott> I think "the DOM needs fixing" is as close to a universally agreeable position as you can get.
18:06:38 <geekosaur> when I look at it, I have this feeling that it *should* be describeable in a declarative way; it just isn't currently
18:06:59 <elliott> Imperative OOP people hate it, procedural people hate it, declarative people hate it.
18:07:11 * hackagebot attoparsec 0.10.1.1 - Fast combinator parsing for bytestrings  http://hackage.haskell.org/package/attoparsec-0.10.1.1 (BryanOSullivan)
18:07:26 <zzo38> I think the DOM needs eliminiating
18:07:28 <geekosaur> (I won't argue that the DOM has problems, but I do think that *as is* it should still be possible to describe declaratively.)
18:07:42 <geekosaur> perhaps think in terms of FRP
18:07:52 <geekosaur> then again, that's still quite the open problem :)
18:10:52 <geekosaur> actually, no.  FRP is a possibility, but what I'm really reaching for is what some of the XML modules for haskell do.
18:11:27 <geekosaur> where it breaks down is where you inject javascript into the DOM, but that isn't the fault of the DOM /per se/ and isn't going to be fixed by changing the DOM...
18:11:36 <ddarius> @ask ezyang You know of a convenient place where I could corrupt the minds of MIT youth via talks?  Particularly youth interested in mathematics, engineering, and physics.  This isn't Haskell or Category Theory related.
18:11:36 <lambdabot> Consider it noted.
18:12:33 <shachaf> ddarius is corrupting minds?
18:12:51 <shachaf> What is the topic?
18:13:54 <dmwit> shachaf: mathematics, engineering, and physics, it seems ;-)
18:15:03 <ddarius> Probably a talk (series) on geometric algebra and/or another on probability theory.  Maybe one on category theory if anyone cares, though, for me, that's less engineering and physics related.
18:15:19 * cmccann endorses ddarius corrupting youth in general.
18:15:28 <cmccann> as far as I can tell that can only improve society.
18:16:20 <cmccann> ddarius, what sort of probability theory material?
18:17:14 <ddarius> cmccann: Basically cheerleading Jaynes.  The reason I'm interested in physicists and engineers is due to the clarity and tools that that can bring to those fields.
18:17:30 <cmccann> ah, good choice.
18:17:31 <ddarius> These talks (at least the initial ones) would be more of propaganda than education.
18:18:44 <cmccann> sounds thoroughly entertaining.
18:21:25 <dolio> Category theory is totally physics related. It has uses in all that m-theory nonsense. :)
18:22:20 <cmccann> category theory is everything related if you try hard enough.
18:22:30 <ddarius> dolio: M-Theory isn't physics related.  There are other applications of category theory to physics that are definitely related, but less so for me.
18:22:46 <dolio> Heh.
18:23:17 <dolio> It's physics related if you're applying for a grant.
18:23:21 <tgeeky> m-theory is as much of a theory of physics as string theory, which is "almost"
18:23:29 <dolio> But other than that....
18:24:35 <tgeeky> I get a sense that a lot of people say slightly sneering things about string, m-, brane, loop, etc -- theory. I often wonder how much is just uncomfort with something that's to difficult for us.
18:25:53 <dolio> I say sneering things about it because I've read critiques of it by people who should know what they're talking about, and found them somewhat convincing.
18:26:16 <ddarius> tgeeky: My perspective on this isn't limited to string theory, though that is usually the most "popular" and noisy example.  The same problem exists in plain quantum mechanics.  The issue is doing math and calling it physics.
18:26:31 * cmccann tries not to underestimate the ability of people who should know what they're talking about to get things wrong for irrational reasons
18:27:12 <tgeeky> ddarius: I suppose. But surely what is going on at the LHC is physics, and the QM/QFT they are doing to simulate the real detectors, etc -- is physics (if anything is)
18:28:04 <tgeeky> string, m-, etc... are all just as unassailable as QM / QFT, and in many ways, less so.
18:29:24 <ddarius> tgeeky: I agree.  QM has a strong claim to be physics but it has largely grown by extrapolating mathematically.  Mathematical physicists have taken that success and focused solely on mathematical extrapolation with little grounding at all.  I feel a lot of the confusion about QM comes from how it grew.
18:30:18 <ddarius> tgeeky: As far as I know string theory has no validated predictions and what predictions are suggested are usually infeasible to accomplish.
18:30:30 <nand`> ddarius: but we all know physics is just applied mathematics
18:30:38 <tgeeky> ddarius: I feel like, if we were to catch a glimpse of what we'll be calling "physics" in 50 years, 99% of people who call them physicists today will be very, very surprised -- including QM, QFT, string, m-, and all the rest.
18:31:43 <cmccann> tgeeky, of course, in 50 years it will seem obvious in hindsight even with what we know today :P
18:32:00 <cmccann> like, man, what took us so long.
18:32:07 <ddarius> I think (hope) the future will actually bring a "physics" that is actually much closer to "everyday" intuitions than current physics is.
18:32:19 <tgeeky> ddarius: pretty much *any* deeply geometric theory of physics (which we *used* to think was a "good thing" before relativity and QM) has its geometry at the Planck scale (or nearby), and without extra information, we have no sensible way to understand what *our* world looks like, 10^30 GeV or whatever away.
18:32:22 <ddarius> I feel there is a lot of unnecessary confusion in QM.
18:32:47 <tgeeky> is due to falling in the "not even wrong" zone that string theory is now.
18:33:09 <tgeeky> s/due do/going to be catagorized as/
18:34:26 <tgeeky> cmccann: well yes, your are correct but I mean something additional: all of the time spent complaining about how other people are currently long is likely to be in vain
18:34:50 <tgeeky> s/long/wrong/... what is wrong with me.
18:34:50 <ddarius> I also think there is a lot more flexibility within the context of even QM (i.e. not even QFT) that makes a lot of these more "advanced" models unnecessary.
18:35:21 <cmccann> tgeeky, fair enough
18:35:55 <tgeeky> cmccann: only that 1% or whatever who was *defending* his/her (ultimately) correct idea will not have wasted his/her time.
18:36:23 <tgeeky> which isn't a great model for advancing
18:36:28 <tgeeky> but *shrugs*
18:36:30 <cmccann> tgeeky, other than the time they wasted arguing about silly stuff to defend said idea :P
18:37:16 * ddarius isn't saying the string theory is wrong.  He's saying that it is math, not physics.  It may eventually be shown to be a good model of physics but currently there is no evidence for this.
18:38:25 <kaspare> This is why science should be approached as art, and kept a labour of love...
18:38:51 <kaspare> now that i caught up, gotta run...
18:40:08 <ddarius> A good model, incidentally, would be one that is good for making verifiable predictions that other models fail to predict correctly.
18:42:41 <SmartViking> 3rd time I'm trying to learn Haskell
18:50:12 <roconnor> edwardk: did you say you had a data-lens 3.0 hidden somewhere?
18:50:43 <edwardk> roconnor: check github/ekmett/data-lens
18:50:47 <edwardk> there should be a 3.0 branch
18:51:05 <roconnor> edwardk: I only see master and unboxed
18:51:20 <edwardk> i put it together so the snap guys could play with unboxed, etc. lenses
18:51:24 <edwardk> might have been named unboxed
18:51:42 * BMeph wonders if roconnor appreciates the meaning of the word, "hidden"... ;)
18:52:07 <edwardk> https://github.com/ekmett/data-lens/blob/unboxed/data-lens.cabal#L3
18:52:08 <edwardk> =)
18:52:34 <zzo38> New in version 0.2.1 of Hampp: Wildcard import/wildcard includes.
18:55:11 <roconnor> I don't suppose github will diff it for me
18:55:42 <zzo38> For example,    #W Wild.Things    imports all modules directly under Wild/Things/ in the current package, while   #J stuff/*.inc    includes contents of all .inc files in stuff/ directory in place; filenames will be sorted in alphabetical order before including (same as in Icoruma)
18:56:31 <edwardk> not sure
18:56:36 <edwardk> its really a very different design
18:56:46 <roconnor> heh
18:56:46 <edwardk> i basically made a lens class based on the cps'd lens methods
18:56:49 <roconnor> this is so not Haskell 98
18:56:59 <edwardk> well, the lens class iirc was
18:57:08 <edwardk> and then you can make a stock instance that is
18:57:11 * hackagebot hampp 0.2.1 - Haskell macro preprocessor  http://hackage.haskell.org/package/hampp-0.2.1 (AaronBlack)
18:57:18 <edwardk> but the fast versions i wanted to benchmark aren't
18:57:29 <edwardk> the hope was that internally they could be made a bit faster
18:58:44 <edwardk> the original thought was to make the core combinators agnostic about the choice of lens representation
18:58:46 <jdpage> Okay
18:58:51 <edwardk> then instances could be provided for fclabels, etc.
18:58:56 <jdpage> Noob question incoming
18:59:04 <edwardk> and then i could get out of the game of trying to pick a winner
18:59:04 <jdpage> unless there's another channel I'm supposed to go to
18:59:09 <edwardk> and just fous on USING them
18:59:15 <cmccann> jdpage, no, this is fine
18:59:27 <edwardk> but then you came along and accepted maintainership.
18:59:32 <edwardk> so now its all your problem ;)
18:59:58 <hpaste> jdpage pasted ‚ÄúI don't understand type system?‚Äù at http://hpaste.org/63517
19:00:20 <ddarius> edwardk: I thought your goal was to just implement the winner.
19:00:25 <edwardk> that too
19:00:36 <edwardk> but then i don't have to win the arguments with die-hards
19:00:37 <cmccann> jdpage, Haskell doesn't do automatic conversions from integers to fractional types
19:00:53 <jdpage> cmccann: right, which is why I included floor
19:00:59 <jdpage> cmccann: or is that not where the error is?
19:01:13 <cmccann> jdpage, it doesn't convert in either direction
19:01:19 <cmccann> length xs returns an Int
19:01:22 <jdpage> cmccann: so I should wrap length in fromInteger?
19:01:29 <roconnor> edwardk: okay
19:01:34 <ion> :t genericLength
19:01:36 <lambdabot> forall b i. (Num i) => [b] -> i
19:01:49 <cmccann> jdpage, that would accomplish what you're probably trying to do, or you can use the function ion suggested
19:01:49 <ddarius> jdpage: Int isn't Integer so that wouldn't work.
19:01:56 <edwardk> i now have a hacked up version of wadler's pretty printers that have soft hyphen support, not sure i want to put _another_ pretty printer out there though
19:02:03 <cmccann> oh yeah, use fromIntegral
19:02:13 <ion> Also, in cmccann‚Äôs Prelude substitute (Overture), length :: Integral z => [a] -> z
19:02:21 <cmccann> ion, but that's wrong, ignore that
19:02:32 * cmccann needs to fix that to match genericLength
19:02:40 <edwardk> i also have had a couple of requests to break the charsets back out of trifecta
19:02:59 <edwardk> blah, users suck =)
19:03:10 <ddarius> In a better Prelude, I would expect length to return a natural.
19:03:21 <cmccann> jdpage, at any rate, given what you're doing, you might wish to use div instead
19:03:47 <cmccann> ddarius, if I had a way to make a natural type work nicely, I would use that
19:03:57 <ion> cmccann: Oh, i didn‚Äôt pay attention to the actual class constraint, i just read it as ‚Äú(whatever) z => [a] -> z‚Äù and assumed it was an alias to genericLength.
19:04:05 <jdpage> cmccann: all these functions I don't know about!
19:04:16 <cmccann> though with length it's in covariant position so letting it convert to something other than a natural is okay
19:04:27 <cmccann> it's stuff like drop that really ought to take a natural
19:04:29 <jdpage> so once I've finished "learn you a haskell", where would I look them up?
19:04:46 <cmccann> jdpage, div is integer division
19:04:53 <cmccann> > 5 `div` 2
19:04:54 <lambdabot>   2
19:04:59 <cmccann> > 7 `div` 3
19:05:00 <lambdabot>   2
19:05:03 <cmccann> > 7 `div` 2
19:05:04 <lambdabot>   3
19:05:10 <cmccann> &c.
19:05:15 <Sgeo> Ooh, prelude substitutes
19:05:18 <Rc43> There is onError event in AutoConfig (http://hackage.haskell.org/packages/archive/configurator/0.2.0.0/doc/html/Data-Configurator-Types.html#v:onError).
19:05:29 <Sgeo> And searching Google for Haskell Overture is not as helpful as one may expect
19:05:29 <Rc43> But how can I get that config was updated?
19:05:35 <ion> jdpage: To just see what‚Äôs available, i‚Äôd recommend browsing around <http://hackage.haskell.org/package/base>. If you have something specific in mind (a function name or a type), use e.g. http://www.haskell.org/hoogle/
19:05:37 <Rc43> There is no any onReload
19:05:52 <cmccann> Sgeo, https://github.com/isomorphism/Overture
19:06:06 <Sgeo> ty
19:07:03 <jdpage> so the book I'm using said that let ... in didn't require ; between definitions if they were separated by a newline
19:07:07 <cmccann> ion, and yes, it should be genericLength, I just put the wrong constraint on there because of all the other functions that use an integer in contravariant position
19:07:19 <jdpage> but ghc is giving me compile errors if I miss them
19:07:36 <tikhonjelvis> jdpage: indentation becomes significant
19:07:38 <cmccann> jdpage, probably indentation issues
19:07:48 <ion> jdpage: Please hpaste your code and the exact error message.
19:07:48 <cmccann> @where hpaste
19:07:48 <lambdabot> http://hpaste.org/
19:07:52 <tikhonjelvis> E.g.
19:07:52 <tikhonjelvis> let a = 10
19:07:52 <tikhonjelvis>     b = 11 in
19:09:36 <shachaf> 2
19:09:51 <shachaf> Ahem.
19:10:02 <cmccann> shachaf, really? 2, huh.
19:10:07 <cmccann> good to know.
19:10:27 <ion> 42
19:10:29 * ddarius anxiously awaits shachaf breaking out into song.
19:11:21 * cmccann considers the merits of hacking GHC in order to get natural number literals without something being horribly broken.
19:12:15 <tikhonjelvis> Would you actually have to hack GHC?
19:12:19 <elliott> yes
19:12:23 <tikhonjelvis> hmm
19:12:25 <elliott> otherwise you could use negatives
19:12:28 <shachaf> cmccann: You can tell that something is wrong when someone says "2" and you say "oh, that reminds me, I wish using numbers in the type system was more convenient".
19:12:28 <jdpage> tikhonjelvis, cmccann: I feel like vim should be doing this for me :|
19:12:36 <elliott> shachaf: cmccann didn't say "type".
19:12:36 <tikhonjelvis> jdpage: Use Emacs ;)
19:12:37 <shachaf> I guess it makes sense. 2 is a number, after all.
19:12:43 <shachaf> Oh.
19:12:52 <cmccann> yes, I just want natural number values.
19:13:00 <jdpage> tikhonjelvis: I don't hate myself :<
19:13:03 <tikhonjelvis> My understanding is that -2 desugars to negate 2. Is that right?
19:13:05 <ddarius> :k 1
19:13:06 <lambdabot> *
19:13:14 <ddarius> tikhonjelvis: Yes.
19:13:19 <jdpage> tikhonjelvis: in seriousness, vim muscle-memory
19:13:22 <tikhonjelvis> So could you change the type of negate 2?
19:13:26 <cmccann> tikhonjelvis, it desugars to negate (fromInteger (2 :: Integer))
19:13:28 <tikhonjelvis> jdpage: Viper mode :)
19:13:31 <jdpage> tikhonjelvis: switching to emacs would be a massive pain
19:13:34 <cmccann> if you look at that for a while you might see the problem
19:13:45 <ion> > exp (pi * sqrt (-1)) + 1 :: Complex Double
19:13:46 <lambdabot>   0.0 :+ 1.2246467991473532e-16
19:14:16 <tikhonjelvis> Hmm, I'm not really seeing it.
19:14:17 <jdpage> tikhonjelvis: it isn't the same
19:14:29 <jdpage> if I was going to switch to emacs for a language I'd have done it already
19:14:35 <tikhonjelvis> jdpage: It's like a nicotine patch.
19:14:37 <jdpage> I was learning common lisp a while back.
19:14:41 <cmccann> tikhonjelvis, note that desugaring literals uses "fromInteger"
19:14:47 <ion> > exp (pi * sqrt (-1)) + 1 :: Complex CReal
19:14:48 <lambdabot>   0.0 :+ 0.0
19:14:48 <cmccann> which takes an Integer argument
19:14:55 <tikhonjelvis> ah
19:14:56 <tikhonjelvis> right
19:15:18 <elliott> cmccann: oh hmm
19:15:20 <cmccann> so natural number literals will work, but you'll be able to use fromInteger on integers at runtime
19:15:22 <elliott> cmccann: what if you overrode negate?
19:15:24 <cmccann> plus it has to be called fromInteger
19:15:25 <tikhonjelvis> Why is it fromInteger if it gets negated afterwards?
19:15:31 <elliott> cmccann: and put it in another typeclass
19:15:39 <elliott> and used "fromInteger" for naturals
19:15:42 <hpaste> jdpage pasted ‚Äúlet ... in ... syntax error‚Äù at http://hpaste.org/63518
19:15:46 <elliott> knowing that GHC won't pass a negative argument(?)
19:15:55 <tikhonjelvis> What if you make Num a => fromInteger :: Natural -> a?
19:16:05 <ddarius> A better Prelude would already separate fromInteger into a different type class.
19:16:09 <elliott> that won't work
19:16:09 <cmccann> tikhonjelvis, the literals aren't of type "Natural"
19:16:14 <elliott> cmccann: but yeah, why not just put negate in a subclass?
19:16:14 <tikhonjelvis> ah
19:16:20 <tikhonjelvis> so that's where it all breaks down then
19:16:29 <cmccann> elliott, you could still use fromInteger on negative Integers at runtime
19:16:36 <elliott> cmccann: yes, you could
19:16:39 <cmccann> literals would work, however
19:16:42 <elliott> cmccann: so? it gives you literals
19:16:44 <jdpage> there's the error
19:16:48 <tikhonjelvis> But wait, isn't fromInteger (-10) equal to fromInteger (negate (fromInteger 10)) ?
19:17:04 <elliott> cmccann: I mean, you can write erroring procedures if you really want to, no matter what :)
19:17:05 <jdpage> let ... in with no semicolons at the end of defs
19:17:18 <cmccann> elliott, it's fragile and confusing that fromInteger only expects naturals
19:17:20 <jdpage> oh
19:17:23 <jdpage> you know what
19:17:24 <jdpage> spaces
19:17:29 <elliott> cmccann: it doesn't have to only expect those
19:17:54 <elliott> cmccann: I mean, you can't completely fix the typeclass hierarchy in one go, Natural still has to be inconsistent vs. other types in fromInteger behaviour... but if "negate" is properly separated-out...
19:17:54 <cmccann> elliott, here, look at this:
19:17:55 <cmccann> http://hpaste.org/63381
19:17:57 <elliott> hmm
19:17:57 <elliott> actually
19:18:01 <elliott> I bet GHC uses fromInteger (-10)
19:18:03 <cmccann> that's some code I wrote about 6 months ago I think
19:18:05 <elliott> rather than negate (fromInteger 10)
19:18:23 <dmwit> jdpage: We'd also need to see the code to give you good advice.
19:18:26 <elliott> cmccann: ah
19:18:39 <ion> dmwit: No, we just need to guess his exact code. The game‚Äôs more fun that way.
19:19:10 <elliott> cmccann: I dunno, I'm in favour, because take, drop, div, etc. *really* need to take naturals ASAP :P
19:19:19 <cmccann> elliott, p.s. ignore the terrible pun in there plz
19:19:20 <ion> Speaking of CReal, it seems numbers still doesn‚Äôt build with GHC 7.4.1.
19:19:33 <ddarius> dmwit probably plays chess with all the pieces showing.
19:19:34 <elliott> cmccann: sorry, I cannot ignore or forgive
19:19:40 <elliott> you're excommunicated
19:19:44 <cmccann> :[
19:19:52 <elliott> you could even say your pun...
19:19:54 <elliott> ended your FUN
19:19:57 <cmccann> ..
19:20:01 * elliott seppuku
19:20:06 <cmccann> 2/10
19:20:10 <cmccann> :P
19:20:13 <elliott> wow, what gets 1/10?
19:20:19 <elliott> an ordinary sentence with no pun?
19:20:50 <cmccann> elliott, no, I'm setting that aside in case I need it later
19:21:01 <jdpage> dmwit: the code was posted earlier. I fixed it, though
19:21:09 <cmccann> I don't want to assume I've found the lower limit on pun quality
19:21:12 <jdpage> I had vim set to tabs instead of spaces
19:22:03 <cmccann> elliott, anyway yes, the scheme in question works, but it's kind of horrible and fragile because of the stuff mentioned in that code
19:22:08 * dmwit has noet set in vim and doesn't have problems
19:22:09 <cmccann> it's really not satisfying
19:22:31 <cmccann> however, it does work with literals so there's that
19:23:08 <tikhonjelvis> So with your code -10::Natural would be an error?
19:23:36 <cmccann> tikhonjelvis, yes, you'd get a "no instance FromInteger in blah blah syntactic negation" error or such
19:24:05 <tikhonjelvis> How do you think Word types should behave?
19:24:21 <cmccann> but fromInteger ((-10) :: Integer) :: Natural or something like that would be allowed
19:24:40 <elliott> cmccann: it's more satisfying than Num :P
19:24:45 <ion> ‚Äú42‚Äù ‚Üí ‚ÄúfromNatural 42‚Äù, ‚Äú-42‚Äù ‚Üí ‚ÄúfromInteger (-42)‚Äù, ‚Äú42.5‚Äù ‚Üí ‚ÄúfromRational 42.5‚Äù
19:25:12 <cmccann> elliott, well, replacing the rest of Num has its own issues
19:25:15 <ddarius> There are no negative integer literals.
19:25:53 <cmccann> but yeah the solution in question does work for literals so maybe it's worthwhile.
19:26:06 <tikhonjelvis> It's certainly an improvement.
19:26:26 <cmccann> it's no more wrong than things are now I suppose
19:26:38 <jdpage> Okay
19:26:46 <jdpage> that is vaguely a weird feeling
19:26:46 <tikhonjelvis> Unless I'm missing something, it's somewhat less wrong even.
19:27:00 <jdpage> having a bit of nontrivial haskell code which does what I want it to do
19:27:03 <cmccann> tikhonjelvis, it makes it easier to not be wrong
19:27:15 <cmccann> the inability to insure non-wrongness is what annoys me
19:27:29 * elliott would use an alternate prelude that just allowed natural literals and used Nat where necessary
19:27:46 <tikhonjelvis> Yeah, negative numbers are for wimps anyhow.
19:27:46 <elliott> cmccann: you could maintain compatibility with Num, I think
19:27:49 <ddarius> cmccann: I'm sure you can find someone to insure that.
19:27:54 <elliott> by simply not re-exporting Prelude.fromInteger
19:28:08 <tikhonjelvis> I mean, the whole unary - is a big hack because of math notation...
19:28:15 <elliott> the only downside for compatibility would be orphan instances if you want to use literals of someone else's numeric type in a module using it
19:28:27 <cmccann> ddarius, insurance for code correctness? nobody would offer such a policy, that's madness.
19:28:47 <ddarius> cmccann: You just need high enough premiums.
19:29:04 <tikhonjelvis> ddarius: They'd have to be higher than the benefits...
19:29:07 <cmccann> elliott, it's actually the rest of Num that I got stuck on with the library that code came from, anyway
19:29:11 <elliott> poll: would haskell be better if it didn't have standard integer types at all and no negation syntax or support in standard numeric typeclasses
19:29:26 <elliott> i think the answer may, depressingly, be "yes"
19:29:36 <ddarius> The answer is "no."
19:29:38 <tikhonjelvis> I am annoyed by the negation syntax.
19:29:43 <tikhonjelvis> Therefore: yes.
19:29:58 <elliott> ddarius: You could still build your own negative number type!
19:30:02 <elliott> :+ and :- constructors :P
19:30:04 <cmccann> I'm ambivalent on negation but I think a standard integer type is probably a good idea
19:30:19 <tikhonjelvis> I just think we don't really need a negative sign.
19:30:20 <ddarius> elliott: We can do it better without removing any of those things.
19:30:37 <elliott> ddarius: It's a hypothetical! You're not allowed to unexclude the middle. :(
19:30:43 <elliott> Bloody constructivists.
19:30:53 <tikhonjelvis> unexclude?
19:31:04 <elliott> We should use üëé as a negative sign.
19:31:11 <elliott> U+1F44E THUMBS DOWN SIGN
19:31:28 <cmccann> elliott, I can exhume the fragments of the library that hpaste came from if you want to help make it usable :P
19:31:34 <tikhonjelvis> Wow, a symbol my font doesn't support. Did not see that coming.
19:32:32 <elliott> cmccann: tempting, though I'm not particularly inclined to use a full-scale prelude replacement
19:32:44 <cmccann> elliott, it's kind of hard to replace Num without replacing everything
19:33:28 <elliott> cmccann: well like I said, you can actually make it work "with" Num
19:33:37 <elliott> cmccann: the only thing GHC cares about is which fromInteger is in scope (given RebindableSyntax)
19:33:42 <elliott> you can change that without hiding the rest of Num
19:33:50 <cmccann> about the only things you'd be able to keep are the things that would break if you tried to fix Monad as well :P
19:34:15 <elliott> so, the overhead is simply "instance FromInteger T where fromInteger = Prelude.fromInteger" for third-party Nums T
19:34:32 <elliott> actually that could be "instance FromInteger T" with DefaultSignatures
19:34:38 <cmccann> elliott, yes, and I'm pretty sure I had a module doing that in this library now that I think about it
19:35:14 <cmccann> but you're still "replacing" the Prelude even if you decide to re-export most of it anyway
19:35:19 <elliott> actually
19:35:26 <elliott> *technically* the only thing you need to hide is negate
19:35:36 <elliott> cmccann: well, yeah
19:35:40 <elliott> but compatibility is a big issue :P
19:35:50 <cmccann> elliott, yes, something I learned the hard way
19:36:00 <ion> tikhonjelvis: It‚Äôs probably one of the Unicode 6.0 emoji additions. They‚Äôre fairly recent, it‚Äôs no surprise fonts are lagging behind.
19:36:08 <elliott> ion: it's not
19:36:09 <cmccann> that's why the library that hpaste is from is lying in ruins, while Overture is on github :P
19:36:11 <elliott> it's just astral planey
19:36:23 <elliott> tikhonjelvis just hasn't seen enough Unicode around if they're surprised by that :P
19:36:28 <tikhonjelvis> What did you say the code point was again?
19:36:42 <elliott> <elliott> U+1F44E THUMBS DOWN SIGN
19:36:44 <tikhonjelvis> I also use one of the Deja Vu fonts, so I see a lot of the characters.
19:37:13 <ion> http://www.fileformat.info/info/unicode/char/1f44e/index.htm ‚ÄúVersion: Unicode 6.0.0 (October 2010)‚Äù
19:37:23 <elliott> ion: oh hm
19:37:35 <elliott> cmccann: the minimum necessary to get Nat literals working would without breaking compatibility would, I think, be: import Prelude hiding (negate) as P; class (Num a) => Negate a where negate :: a -> a; negate = P.negate
19:37:40 <elliott> cmccann: the orphan instances thing sucks though :(
19:38:55 <cmccann> elliott, still pretty sure you'd want to replace more than that
19:39:01 <cmccann> if you want to actually use the naturals
19:39:08 <cmccann> such as, say, adding them
19:39:35 <cmccann> Num itself is a problem, not just because of literals
19:39:55 <elliott> cmccann: well, you'd just give the "standard" half-broken Num instance, that's basically unavoidable
19:40:10 <elliott> without a very major overhaul
19:40:15 <cmccann> meh.
19:40:37 <elliott> that's like two error calls as opposed to the fifty scattered about Prelude because of the lack of naturals :P
19:40:52 <elliott> technically we also need Mathematician'sNat for div/mod/quot/rem
19:41:11 <cmccann> yeah nonzero values is a can of worms better left sealed
19:41:22 <cmccann> I tried that, it's painful
19:42:29 <elliott> meh, blow all computers up and force everyone to get things right this time round
19:42:32 <cmccann> but I still think that if you're disrupting things enough to do natural literals, you might as well replace Num and a few other classes while you're at it, even if you do have a compatibility layer available
19:42:57 <elliott> have you seen yap's numeric hierarchy? it seems to strike a nice balance
19:43:13 <cmccann> it's just a matter of sticking an (inherently broken) Prelude.Num instance for stuff like Natural in a corner and letting people use them if they need to
19:43:13 <elliott> although it still doesn't support naturals :P
19:43:24 <edwardk> i really don't like yap =/
19:43:34 <elliott> cmccann: "just" -- I would call having to write instances for third-party types more invasive than that
19:43:44 <edwardk> it has a lot of those 'i haven't needed it yet so obviously this distinction doesn't exist' issues
19:43:54 <elliott> edwardk: yeah it's less than i'd like
19:44:13 <elliott> but I'm not satisfied with just chucking every algebraic structure we can think of into one gigantic hierarchy
19:44:13 <edwardk> i've been meaning to rewrite algebra using polymorphic kinds and constraints
19:44:28 <elliott> because it's going to end up messy for typical numeric code
19:44:34 <edwardk> that way i can move a lot of things into constraint modifiers
19:44:47 <edwardk> Ordered :: Constraint -> Constraint
19:44:49 <edwardk> etc
19:44:59 <edwardk> Ordered (Monoid a)
19:45:00 <cmccann> yeah, I've been meaning to revisit the whole idea now that the fancy kind stuff is here
19:45:15 <edwardk> or Ordered :: (k -> Constraint) -> k -> Constraint
19:45:31 <edwardk> i probably can't do the latter until simon gets around to adding a syntax for the constraint kinds though
19:45:44 <cmccann> try to make something tidier that's not quite the towering edifice of algebraic hair-splitting that edwardk probably wants :P
19:45:45 <edwardk> er i mean for polymorphic kinds
19:45:50 <edwardk> yeah
19:46:11 <edwardk> i just want to know what the right solution _would_ look like
19:46:23 <edwardk> since nobody else seems anal retentive enough to actually build it
19:46:24 <edwardk> ;)
19:46:27 <CodeWeaverX> FOOLISH MORTALS
19:46:29 <CodeWeaverX> *cough*
19:46:30 <CodeWeaverX> Um hi.
19:46:45 <elliott> edwardk: hmm, that's interesting
19:47:17 <edwardk> the motivation or "Ordered" ?
19:47:17 * elliott has a feeling we'll be discovering new ways to use the new kind stuff in five years...
19:47:17 <elliott> edwardk: well, just the trick itself :)
19:47:40 <edwardk> i'm trying to see if i can use it to make the parallel hierarchy stuff less messy
19:47:54 <edwardk> e.g. additive abelian groups, vs. multiplicative abelian groups, etc.
19:48:12 <edwardk> a lot of the stuff i was doing in kata
19:48:15 <elliott> yes, that's one of the main problems I have with the bunch-of-algebraic-typeclasses approach
19:48:28 <elliott> they tend to duplicate things just to get (+) vs. (*)
19:48:48 <edwardk> i do that deliberately, it gets worse once you permit meets and joins
19:48:54 <edwardk> because then you often want to do the same thing for min and max
19:49:16 <edwardk> or meet/join depending on how you want to phrase it
19:49:39 <edwardk> since all 4 concepts can have to exist simultaneously for the same type when you start talking about ordered rings
19:49:57 * cmccann had some clumsy nonsense with a single class for +, *, &c. that took an extra parameter for which "operation" it was
19:50:02 <cmccann> didn't really make a lot of sense in hindsight
19:50:10 <lispy> Hello
19:50:14 <elliott> edwardk: 4 simultaneous concept algebra cube
19:50:16 <edwardk> I actually tried that
19:50:33 <lispy> So
19:50:39 <elliott> edwardk: I take it you have -1 * -1 = -1, too :D
19:50:39 <lispy> Who wants a hackage2 instance?
19:50:43 <edwardk> then the operators were defined outside of the class using the dictionary
19:50:52 <edwardk> lispy: gruen's baby?
19:50:56 <elliott> lispy: a hackage2 instance called hackage.haskell.org would be nice
19:51:04 <lispy> edwardk: I don't know gruen
19:51:15 <lispy> So what needs to be done?
19:51:19 <edwardk> lispy: matthew gruen, wikigracenotes, the guy who wrote it last year
19:51:25 <edwardk> my gsoc student that year
19:51:34 <edwardk> it needs a maintainer
19:51:49 <edwardk> that was the problem after gracenotes put it together
19:51:57 <lispy> I see
19:52:10 <lispy> I'm trying to find duncan's email
19:52:13 * elliott notes that Gracenotes is currently in the channel :p
19:52:49 <edwardk> he finished it and was all set to put it up somewhere, and then iirc, ross said 'great, now you can maintain it!' and wanted out of the dealing with hackage entirely and gracenotes paniced since, a 'google summer of code' was going to turn into a 'google lifetime of bondage'
19:52:53 <lispy> Here we go: http://www.haskell.org/pipermail/cabal-devel/2011-October/007803.html
19:53:00 <elliott> hahaha
19:53:03 <hpaste> ‚ÄúC. McCann‚Äù pasted ‚Äúawkward approach to algebraic operations‚Äù at http://hpaste.org/63519
19:53:13 <cmccann> there's an example of something that didn't work out very well
19:53:14 <cmccann> :P
19:53:18 <elliott> Google Lifetime of Bondage could be a hit
19:53:32 <elliott> cmccann: oh dear
19:53:47 <edwardk> cmccann yep, thats exactly it
19:53:58 <lispy> Perhaps it never went anywheres because that email was sent to cabal-devel
19:53:59 <cmccann> edwardk, I even had meet and join, apparently
19:54:09 <quintessence> Google Lifetime of Bondage: "We've changed our terms of service recently."
19:54:16 <elliott> hahaha
19:54:22 <edwardk> quintessence: hahahah
19:54:28 <cmccann> :D
19:54:37 <elliott> all google summer of code users will be seamlessly migrated to this new, improved user experience
19:54:40 <edwardk> lispy: well, i'll see if i can dig up some other chatter, there were several emails
19:54:44 <lispy> Why is this a 403?? http://hackage.haskell.org/trac/hackage/wiki/HackageDB/2.0
19:55:00 <elliott> lispy: welcome to the hackage trac!
19:55:05 <elliott> it was taken down for spam. it will never go back up ever.
19:55:07 <edwardk> dies all the way out to http://hackage.haskell.org/trac/hackage/
19:55:13 <elliott> I will bet money on this.
19:55:38 <elliott> so does hackage2 actually work>?
19:55:38 <edwardk> http://hackage.haskell.org/trac/ interesting
19:55:42 <edwardk> elliott: yes
19:55:47 <elliott> edwardk: like I said, someone took it down because it got spam infested or whatever
19:55:49 <elliott> "temporarily"
19:55:50 <edwardk> elliott: he did a really good job on it
19:56:08 <edwardk> elliott: its a lot cleaner and a lot nicer to work with than the existing hackage code
19:56:08 <lispy> It's hard to imagine having a project around hackage if we don't even have the previous development plan on the wiki...
19:56:08 <elliott> that was a few months ago now
19:56:20 <elliott> edwardk: does it support all that fancy rating stuff everybody wanted?
19:56:41 <edwardk> elliott: he decided to focus on getting the codebase into a state where people could add features to it easily
19:57:06 <cmccann> does it support being able to find a package that does something without reading the entire list before asking around on IRC instead?
19:57:07 <edwardk> so in the end it made a lot of the api more restful, etc. made the internals nicer to add functionality to, etc.
19:57:22 <edwardk> cmccann: thats the social part of hackage! it drives people to irc
19:57:27 <cmccann> haha
19:58:06 <edwardk> anyways my recollection was it got bounced back because ross didn't want to maintain something he'd never seen before and which was that big of a change
19:58:27 <lispy> I can't even find the cabal trac
19:58:29 <edwardk> in retrospect perhaps it would have been better had duncan and i looped him into the process earlier
19:59:13 <lispy> Oh, the cabalinstall wiki is also down
19:59:28 <lispy> Can we please just move this stuff to github or something if we're not going to bring it back up?
19:59:52 <lispy> Crucial haskell infrastructure and it's rotting :(
19:59:54 <byorgey> edwardk: so what's the plan for moving forward with it? is there one?
20:00:11 <byorgey> not that you are responsible for it, just wondering what your thoughts are
20:00:15 <edwardk> byorgey: it basically stopped after that
20:00:26 <mgsloan> This suggestion does not come with a detailed proposal, but I've been thinking that there needs to be more traditions for writing type-classes in a way that's closer to having open functions.  I realize this is somewhat covered by the whole "class alias" business, but this stuff really needs to get resolved.
20:00:40 <mgsloan> There's generally this problem with (+) :: a -> b -> c" being something you might want to define, but a more specific type is nicer for other situations.  What if, in another module, you made a subclass of the "Addable" class, but defined a new version of (+) which further refines the type, to, say, :: a -> a -> a.  Maybe this could be made attractive via some template Haskell stuff to create instances of the superclasses in terms of the subc
20:00:47 <ddarius> elliott: People discover new ways of using type classes and parametric polymorphism and higher order functions after several decades of existence.
20:00:56 <edwardk> well, the current situation is rather dysfunctional. the trick is trying to figure out a path forward that doesn't leave us without a hackage maintainer
20:01:07 <elliott> mgsloan: (+) really shouldn't have the type a -> b -> c.
20:01:21 <byorgey> edwardk: yeah
20:01:22 <elliott> ddarius: well, indeed
20:01:27 <lispy> edwardk: do we have a hackage maintainer right now?
20:01:30 <elliott> ddarius: but extensions this rich don't seem to come along that often
20:01:31 <edwardk> ideally we'd be able to fund something for maintenance, etc. but the committee really doesn't have enough money to pay anyone to do anything
20:01:32 * cmccann proposes a vote appointing edwardk supreme overlord and granting him power to appoint a hackage maintainer by fiat
20:01:44 <elliott> cmccann: what do you think his packages are for?
20:01:49 <edwardk> lispy: as i understand it ross does it as needed
20:01:53 <elliott> once you maintain over 50% of hackage you inherit the bloodline
20:01:57 <cmccann> elliott, yes, just trying to speed things along
20:02:07 <mgsloan> elliott: Or maybe AdditionOp1 a -> AdditionOp2 a -> AdditionResult a, bahaha
20:02:08 * ddarius appoints cmccann Hackage maintainer.
20:02:10 <elliott> all that needs to be done is for the current maintainer to die
20:02:12 <ddarius> We'll see how effective that is.
20:02:12 <edwardk> right now i think heffalump is our duly elected supreme overlord
20:02:20 <elliott> a bloody but effective method of administration
20:02:51 <edwardk> elliott: well, thats one way for me to get control over transformers i suppose
20:02:53 <edwardk> ;)
20:02:57 <cmccann> ddarius, ok. hm, I don't think it's working so far.
20:03:03 <mgsloan> elliott: (+) not having that type isn't really what I was trying to get at - this is a problem that afflicts all functions that have a potentially more polymorphic type
20:03:07 <ddarius> elliott: The problem isn't too many maintainers; it's too few.  Them dying doesn't help.
20:04:04 <elliott> mgsloan: I dunno, that sounds basically like bad typeclass design to me, if the type is too restrictive
20:04:13 <elliott> Opening things up completely by convention seems wrong to me.
20:04:29 <elliott> "create instances of the superclasses in terms of the subc" (got cut off there, btw) isn't practical because typeclass instances can come from anywhere.
20:04:47 <cmccann> edwardk, btw, where is the code for hackage2? kinda curious to see it.
20:04:55 <elliott> ddarius: well, there is only ever one
20:05:00 <elliott> the succession method is just a little complicated
20:05:02 <edwardk> and what happens when i define a data type in one module, then define a comonad in one where comonads derive functor, and a monad in another where monad derives functor
20:05:09 <elliott> if nobody controls over 50% of hackage, it defaults to spj
20:05:14 <edwardk> cmccann: not sure honestly. i'd email gracenotes
20:05:15 <elliott> who then appoints a new successor
20:05:27 <edwardk> elliott: i'm sure he'd love that
20:05:35 <edwardk> it'd be like after smerdyakov got banned
20:05:35 <CodeWeaverX> The successor is alive, long live the successor?
20:05:42 <edwardk> and freenode contacted him
20:06:03 * elliott can't even remember smerdyakov, let alone them being banned.
20:06:09 <elliott> and I'm pretty sure I've been around long enough to
20:06:12 <byorgey> hah, I hadn't heard that part of the story
20:06:18 <lispy> elliott: just visit #ocaml to get a taste
20:06:19 * cmccann has no idea what this story is
20:06:20 <elliott> (what did freenode contact them for?)
20:06:29 <elliott> lispy: hmm, I think I'll pass
20:07:03 <lispy> He's not a bad person, but he's hard to communicate with.  Especially if you're a newbie.
20:07:06 <byorgey> elliott: I thought edwardk meant that freenode contacted spj after smerdyakov was banned
20:07:08 <edwardk> elliott: adam chlipala. prof over at mit now, at the time big into coq/ocaml (still is), scary smart guy, but able to answer almost any question in a way that makes you feel like an idiot
20:07:13 <edwardk> elliott: yes
20:07:23 <edwardk> er byorgey: i did
20:07:35 <mgsloan> elliott - instances come from anywhere, sure, but there's nothing really preventing you from doing something like $(mkSuperclass ''SuperAddition ''Num)
20:07:59 <elliott> edwardk: oh, that's smerdyakov?
20:08:07 <edwardk> as i understand it because the simons are kind of the source of authority for haskell to be #haskell and not ##haskell or something, and he was raising a stink about being 'denied his academic rights'
20:08:07 <elliott> ok, at least I know who they are now :P
20:08:08 <mgsloan> which would get the info for superaddition - which functions it defines, and match them to a defintion out of Num
20:08:13 <edwardk> elliott: yep
20:08:16 <elliott> mgsloan: yes there is, because of the open world assumption
20:08:19 <elliott> you can't define a "default instance" like that
20:08:57 <edwardk> anyways shapr banned him after a few attempts to socialize him didn't go so well, it blew up in many ways
20:09:32 <cmccann> edwardk, sounds hilarious
20:09:41 <edwardk> for a while i had both him and shapr here in boston within a mile of each other. i kept waiting for one to get in the room with the other and for the gloves to come off, but i never did get them in the same space
20:09:43 <mgsloan> elliott - I left something off of that - a concrete type
20:09:57 <elliott> shame, I find (what I know of) his work interesting
20:10:13 <mgsloan> ya, chipala style coq!
20:10:19 <elliott> but I suppose "smart but hard to work with" applies to probably the majority of the most disruptive people in online communities
20:10:27 <elliott> mgsloan: right, with a concrete type it's easy enough
20:10:44 <edwardk> elliott: part of it is just his online persona. he's actually quite nice in person
20:10:49 <tikhonjelvis> Largely because if they weren't smart, they wouldn't matter.
20:10:55 <edwardk> but his style of humor doesn't convey well over irc
20:11:11 <edwardk> maybe i just need to send him an ircii script that randomly adds :)'s and ;)'s to his comments
20:11:20 <cmccann> heh
20:11:21 <lispy> heh
20:11:35 <tikhonjelvis> The sad (happy?) thing is that that would probably work.
20:11:37 <elliott> I just add :P to every completely serious thing I say.
20:11:43 <edwardk> and deletes the random 'but you should be using (ocaml|coq)' asides
20:11:46 <elliott> "i think you might be very confused :P"
20:12:08 <edwardk> tikhonjelvis: =)
20:12:09 <elliott> "you should read a haskell tutorial or my brain is going to explode :P"
20:12:11 <mgsloan> I think there may still be the problem if you want Num to be a subclass of superaddition, though, because in order for the splice to reference the operation in the subclass, there needs to already be an instance of Num, which can't be defined because the superclass doesn't exist yet
20:12:13 <mgsloan> arggh
20:12:15 <CodeWeaverX> I don't think you're being remotely serious. :P
20:12:25 <Eduard_Munteanu> edwardk: I think I've seen him around recently, in a related channel
20:12:40 <tikhonjelvis> Even when you know people are abusing the smilies, they still work :o
20:12:46 <edwardk> Eduard_Munteanu: he's active on ##logic, and a number of others
20:13:12 * lispy is reminded of Tom Wait's "big in japan" but with "logic"
20:13:16 <lispy> I'm big ##logic
20:13:22 <ion> I‚Äôm planning to murder everyone of you. :-P
20:13:31 <edwardk> i consciously went the opposite way of #haskell and didn't ban him from there, which has been great for me, whenever i want to get my questions answered. perhaps not so great for the population count of the channel
20:13:45 <byorgey> haha
20:13:50 <elliott> lol
20:14:02 <Eduard_Munteanu> As long as you provide stimulating questions I guess :)
20:14:14 * cmccann has a mental image of edwardk as a zookeeper with dangerous animals in cages
20:14:23 <edwardk> considering it has about the same population it did when i started the channel ~3-4 years ago
20:14:35 <lispy> I can only think of 2 bannings in my time here
20:14:46 <lispy> keal and that one guy...what was his nick
20:14:50 <elliott> we just need a variant of +q that lets certain people in the channel see things
20:14:52 <ddarius> elliott: The Smerdyakov incident happened a -long- time ago, so I'd be surprised if you were there when it happen.d
20:14:54 <tikhonjelvis> Ignoring the ranom racist forum advertisements?
20:14:56 <lispy> (the emo guy)
20:15:01 <elliott> edwardk gets his answers, channel population count is maintained
20:15:02 <byorgey> dangerous animals that lay golden eggs, which edwardk carefully collects and distributes to the awestruck visitors
20:15:03 <Eduard_Munteanu> lispy: wait, what? keal is a real person?
20:15:10 <edwardk> it does peak in september though as people wind up stuck in philosophy classes, etc.
20:15:15 <elliott> ddarius: fair enough, I thought I heard something about it being a couple of years ago
20:15:18 <lispy> Eduard_Munteanu: well, there was a live keal.
20:15:26 <ddarius> elliott: Where "a couple" is like 8.
20:15:29 <cmccann> byorgey, yes exactly
20:15:32 <mauke> preflex: seen smerdyakov
20:15:33 <preflex>  smerdyakov was last seen on ##logic 104 days, 8 hours, 44 minutes and 1 second ago, saying: Yes, having an expert outside the course staff check your answers should be considered cheating.
20:15:34 <edwardk> thats my secret. really i don't write anything. i just let others do the work and upload it to hackage behind their backs
20:15:34 <Eduard_Munteanu> @keal
20:15:34 <lambdabot> b*(Floor[v/b^p]/b-Floor[Floor[v/b^p]/b])
20:15:45 <elliott> ddarius: as is the definition of "couple" :P
20:15:58 <mgsloan> was keal the #math one?
20:16:05 <elliott> preflex: xseen protontorpedo
20:16:05 <preflex>  Sorry, I haven't seen protontorpedo
20:16:05 <byorgey> @remember edwardk thats my secret. really i don't write anything. i just let others do the work and upload it to hackage behind their backs
20:16:06 <lambdabot> It is stored.
20:16:07 <lispy> Eduard_Munteanu: keal had this rant he kept revisiting about a computation he did that started to undo his reality
20:16:15 <edwardk> =)
20:16:24 * elliott wonders when protontorpedo was about
20:16:29 <Eduard_Munteanu> Wha, heh...
20:16:42 * cmccann recalls someone mentioning that keal had legit serious mental issues
20:16:45 <Saizan> keal was kept for amusement i guess?
20:16:56 <mauke> edwardk: reading your blog makes me depressed
20:16:56 * Eduard_Munteanu kinda wants to meet the real vixen now :P
20:17:00 <lispy> Saizan: yes
20:17:01 <edwardk> mauke: ?
20:17:09 <elliott> Eduard_Munteanu: Why not the real Nixon?
20:17:10 <lispy> Eduard_Munteanu: heh
20:17:17 <lispy> ?vixen are we still on for later tonight?
20:17:17 <lambdabot> Any lady who is first lady likes being first lady. I don't care what they say, they like it.
20:17:24 <mauke> edwardk: it's so much over my head
20:17:31 <edwardk> don't worry. i don't understand it either.
20:17:32 <edwardk> ;)
20:17:47 <Eduard_Munteanu> Mm, forgot about nixon.
20:18:05 <elliott> occasionally i read one of edwardk's posts and mostly understand it, and I worry that I've missed the point in an even more fundamental manner than expected
20:18:06 <mauke> e.g. I think I'm using a codensity thing in code I pasted together but I don't understand the code, ContT, Codensity, or Yoneda
20:18:32 * ddarius huggles Yoneda.
20:18:34 <edwardk> codensity is just Cont where you can't callCC
20:18:48 <mauke> "just"
20:18:48 * cmccann takes a coinductive approach to understanding edwardk's blog, every time I read an article again I get some finite amount of new knowledge :P
20:19:21 <mauke> at least I think I know what's wrong with my parsing lib now
20:19:21 <cmccann> much easier than trying to understand the whole thing at once
20:19:28 <edwardk> i really need to write up something on the polykinded category stuff
20:19:35 <edwardk> mauke: ah found the parsing posts?
20:20:05 <edwardk> if you look at the guts of trifecta i use a cps'd monad to make it work
20:20:07 <mauke> class Stream c s | s -> c where { uncons :: s -> r -> (c -> s -> r) -> r }
20:20:18 <mauke> edwardk: I've tried looking at the guts of trifecta
20:20:26 <mauke> <mauke>  (\f e -> n (\a e' -> eo (f a) (e <> e')) ee (\a e' -> co (f a) (e <> e')) ce) ee
20:20:29 <mauke> then I ran away
20:20:32 <edwardk> hahaha
20:20:33 <elliott> the guts of trifecta, also known as the documentation
20:20:41 <edwardk> Prim is a little scary =)
20:20:45 <Eduard_Munteanu> :))
20:20:56 <elliott> unparser :: (a -> ErrState e -> ErrLog e -> Bool -> Delta -> ByteString -> It Rope r) -> (ErrState e -> ErrLog e -> Bool -> Delta -> ByteString -> It Rope r) -> (a -> ErrState e -> ErrLog e -> Bool -> Delta -> ByteString -> It Rope r) -> (ErrState e -> ErrLog e -> Bool -> Delta -> ByteString -> It Rope r) -> ErrLog e -> Bool -> Delta -> ByteString -> It Rope r
20:21:02 <edwardk> you can turn that inside out in your head
20:21:08 <elliott> it's scarier on the haddock page because all those identical functions are misaligned
20:21:17 <ddarius> It's just Church/Scott encoded for the most part.
20:21:23 <edwardk> Prim is effectively the parser i put on my blog just cps'd
20:22:36 <edwardk> elliott: if you read that as ErrLog e -> Bool -> Delta -> ByteString -> It (Result e a)  -- for some 4 constructor Result type it goes down a bit easier
20:22:38 <ddarius> Either A B ~> (Either A B -> r) -> r ~> (A -> r, B -> r) -> r ~> (A -> r) -> (B -> r) -> r
20:22:55 <cmccann> mauke, what's that for, chewing through a stream lazily while being able to look at a "current" element using continuations?
20:23:03 <edwardk> even easier if you tuple up ErrLog e, Bool, Delta, ByteString and make them into a state type
20:23:09 <mgsloan> edwardk - I'm probably going to try to adopt trifecta's text representation to be used as a buffer representation.  Mainly, I've generalized the Highlight stuff to allow for other types of marks
20:23:11 <mauke> cmccann: well, it's supposed to abstract over lists
20:23:17 <mauke> cmccann: so I can parse from e.g. arrays
20:23:27 <edwardk> mgsloan: yeah i have that as well in a test branch
20:23:41 <edwardk> mgsloan: the highlight stuff was mostly a 'downpayment' on the idea
20:23:43 <mgsloan> no way!
20:23:57 <mgsloan> well here's mine: https://github.com/mgsloan/trifecta
20:23:59 <edwardk> i also have a much simplified version of the diagnostics
20:24:00 <ddarius> edwardk stole mgsloan code before mgsloan even wrote it.
20:24:04 <mgsloan> hehehe
20:24:25 <edwardk> that time machine does wonders for my productivity
20:24:34 <edwardk> or at least the perception of it
20:24:41 <mauke> edwardk: I had a look at your trifecta slides
20:24:49 <edwardk> those are largely unrelated
20:24:52 <mauke> is the utf-8 decoding code real?
20:24:53 <edwardk> i just reused the name
20:25:08 <edwardk> the monoid for it?
20:25:24 <mauke> monoid?
20:25:33 <edwardk> i have an old monoid for parallel utf-8 parsing
20:25:58 <edwardk> http://hackage.haskell.org/packages/archive/monoids/0.1.36/doc/html/src/Data-Monoid-Lexical-UTF8-Decoder.html
20:26:07 <edwardk> kinda horrid
20:26:28 <mgsloan> one thing that I think would be very cool would be to have the Mark intervalmaps be stuck into the leafs of the rope, with local indices
20:26:30 <edwardk> but it lets you take a char reducer and feed it bytes from either end, which it'll break into utf8 character tokens
20:26:35 <mauke> ah, that looks better
20:26:54 <elliott> edwardk: that's lovely
20:26:57 <eyu100> I'm trying to make a 100x100x100 array (Data.Array), but it tells me I'm out of bounds
20:27:11 <elliott> I have this weird bias towards monoid-based solutions.
20:27:16 <edwardk> i actually consciously didn't put the marks in the rope.
20:27:39 <mgsloan> for reasons of simplicity?
20:27:39 <edwardk> in general i find that annotated ropes work better as rope and annotation as separate structures for both performance and manipulation reasons
20:28:02 <edwardk> performance, because most of the time the annotation doesn't perfectly fit the ad hoc nature of how the rope was built in chunks
20:28:05 <mauke> edwardk: I meant page 24 in http://comonad.com/reader/wp-content/uploads/2009/08/A-Parsing-Trifecta.pdf
20:28:09 <edwardk> it may be a number of random locations along it
20:28:28 <elliott> edwardk: the link in the header of that file is broken btw
20:28:28 <mgsloan> I can buy that.  It also potentially allows for multiple domains of annotation
20:28:33 <edwardk> or it may be a value for every char, etc.
20:28:36 <edwardk> yeah
20:28:38 <ddarius> And it gives you a comonad ...
20:28:41 <edwardk> i have an OLD package lying around somewhere
20:28:43 <edwardk> one sec.
20:29:14 <edwardk> http://hackage.haskell.org/package/rope
20:29:31 <edwardk> this used the separation concept. manipulating ropes as a comonad
20:29:32 <elliott> july 2011
20:29:33 <elliott> SO OLD
20:29:47 <edwardk> the bump was just to make it compile
20:29:55 <elliott> oh :P
20:30:13 <elliott> hmm, I wonder when hackage started actually gaining activity
20:30:22 <edwardk> anyways my old c preprocessor used to work with annotated ropes
20:30:22 <elliott> I never see packages before 2008 except iirc base and transformers
20:30:39 <edwardk> 2007 or so
20:30:58 <edwardk> shortly after i joined the community in 2006
20:31:20 <edwardk> because i was here just long enough to see the pain of the previous ecosystem
20:31:30 <ddarius> edwardk: I didn't think it was that old.  It seems like it was just the other year when you were talking about them.
20:31:34 <edwardk> and hackage showed up right as i was about to give up on this place
20:31:46 <elliott> heh
20:31:52 <edwardk> ddarius: i wrote the package and let the idea fester for a couple years
20:31:57 <elliott> hmm
20:32:04 <edwardk> there is an even older package as well
20:32:07 <edwardk> not sure if thats up there
20:32:12 <elliott> it's weird because I remember Hackage being pretty active back when I got started
20:32:17 <elliott> which was like 2008
20:32:18 <edwardk> ah, nope
20:32:25 <elliott> I guess it took off quickly
20:32:29 <edwardk> yeah
20:32:35 <edwardk> people recognized a good thing
20:32:42 <elliott> coinciding with haskell's big boost in popularity I guess
20:32:44 <elliott> what with RWH and everything
20:32:49 <elliott> and dons :p
20:32:51 <ddarius> Hackage and the whole LIP also seems like just the other year ago too.
20:33:01 <elliott> LIP?
20:33:03 <edwardk> hrmm, my old buffers package never made it to hackage
20:33:20 <ion> ‚Äúutf8 characters are at most 4 characters long‚Äù ‚Äì /me cringes :-P
20:33:26 <elliott> ha
20:33:30 <edwardk> ion: ouch
20:33:35 <edwardk> i clearly meant bytes ;)
20:33:41 <ion> aye
20:33:47 <edwardk> and i probably should have also said codepoints, etc.
20:33:48 <ddarius> elliott: Library Infrastructure Project.
20:33:50 <elliott> who remembers the old haddock style, and when hackage package pages used to look like the main site?!
20:33:56 <elliott> that was WHOLE YEARS AGO!
20:33:57 <edwardk> since character and glyph and codepoint are ambiguus
20:33:58 <ddarius> elliott: The thing that defined Cabal and Hackage.
20:34:00 <edwardk> er ambiguous
20:34:27 <elliott> ddarius: Huh, I assumed Cabal was significantly older... but then I've seen pre-Cabal build systems, so I don't know why I thought that.
20:34:31 <elliott> It's just so baked-in these days.
20:34:40 <ddarius> Cabal is older than Hackage, but not by much.
20:34:40 <edwardk> the old haddock stye wasn't that long ago
20:35:15 <elliott> yeah, it wasn't
20:35:16 <edwardk> elliott: meacham used to have one he supported, so did the guy behind happs
20:35:29 <edwardk> (alternative build systems that is)
20:35:31 <elliott> but every time I stumble on some ghc 6.12-era documentation from google i'm like "yow"
20:35:38 <elliott> "how did we ever stand this style"
20:35:53 <edwardk> then one of the snap guys with taste popped up ;)
20:35:54 <cmccann> even I remember the old haddock style
20:35:56 <Eduard_Munteanu> The blue haddock?
20:35:58 <cmccann> it wasn't that long ago
20:36:11 <Eduard_Munteanu> IIRC that's pretty recent :/
20:36:16 <edwardk> its within the last 2 years, because snap hasn't been around that long
20:36:17 <elliott> it's because so much has happened in the ghc 7 era, I guess
20:36:54 <edwardk> ghc 7 has been an interesting rollercoaster of progress in some areas, and glacial in others
20:37:00 <ddarius> http://www.haskell.org/ghc/docs/5.04.3/html/index.html
20:37:21 <elliott> hmm, when was that circa?
20:37:26 <ddarius> 2003
20:37:27 <elliott> wow, 2002
20:37:32 <edwardk> ddarius is old
20:37:33 <elliott> hmm, http://www.haskell.org/ghc/docs/5.04.3/html/users_guide/license.html says 2002
20:38:06 <elliott> http://www.haskell.org/ghc/docs/0.29/users_guide/user_toc.html
20:38:25 <elliott> wow, Concurrent and Parallel Haskell are that old?
20:38:29 <elliott> Haskell 1.2 era?
20:38:38 <ddarius> The whole point of GHC was parallel programming.
20:38:50 <ddarius> GHC was(is?) part of the GRASP project.
20:39:12 <edwardk> Concurrent and Parallel Haskell are Glasgow extensions to Haskell which let you structure your program as a group of independent `threads'.
20:39:17 <elliott> http://www.haskell.org/ghc/docs/0.29/users_guide/user_74.html#SEC74
20:39:18 <elliott> "The constructor `Left' is typically used for errors; it can be renamed to `Wrong' on import."
20:39:19 <edwardk> i love the scare quotes
20:39:22 <elliott> OK, who removed import renaming?
20:39:27 <elliott> And where do they live?
20:39:45 <CodeWeaverX> 223b Baker Street.
20:39:51 <ddarius> I believe it happened between 1.3 and 1.4.
20:39:52 <elliott> edwardk: If you can call that a `program'.
20:39:59 <ddarius> Maybe between 1.4 and 98.
20:40:03 <mauke> how do I programmed parallels
20:40:11 <elliott> mauke: two keyboards
20:40:11 <edwardk> elliott: i'm sure the scare quotes on that came earlier in the document
20:40:24 <ddarius> 5.04 was pre-FFI too.
20:40:40 <elliott> http://www.haskell.org/ghc/docs/3.02/users_guide/users_guide-1.html#compile-what-really-happens
20:40:41 <elliott> What really happens when I ``compile'' a Haskell program?
20:41:06 <elliott> "technically GHC does not use the process known to archaic languages as ``compiling'' but mails your program off to a group of highly-trained kittens"
20:41:42 <edwardk> wow that 0.29 doc is before constructor classes, etc
20:42:15 <elliott> "The ANSI C Haskell high-level assembler :-)"
20:42:16 <ddarius> ByteString circa 1996: http://www.haskell.org/ghc/docs/0.29/users_guide/user_66.html#SEC66
20:42:24 <elliott> hehe, i noticed that
20:42:31 <elliott> _foo is clearly inferior to foo#
20:42:40 <ddarius> Constructor classes were added in Haskell 1.3 I believe.
20:42:42 <elliott> oh, wow, it was imported unconditionally?
20:42:46 <elliott> i guess that explains the name
20:43:09 <dolio> Ah, the packed string that was slower than regular string.
20:43:16 <ion> hah
20:43:24 <edwardk> dolio: =)
20:43:44 <elliott> "Don't derive `read' for `Text' unnecessarily: When doing `deriving Text', use `-fomit-derived-read' to derive only the `showsPrec' method. Quicker, smaller code."
20:43:47 <edwardk> hence http://www.cse.unsw.edu.au/~dons/fps/Data.FastPackedString.html
20:43:48 <edwardk> =)
20:43:52 <elliott> Why did we split those up?
20:44:05 <dolio> Right.
20:44:11 <elliott> edwardk: (403, but I guess you knew that)
20:44:12 <ddarius> elliott: Because apparently it was a bad idea having them together.
20:44:21 <elliott> GHC still uses FastPackedString's API, right?
20:44:27 <edwardk> ok, http://www.haskell.org/pipermail/haskell/2006-April/017867.html
20:44:27 <elliott> as a wrapper around bytestrings
20:45:01 <elliott> edwardk: ow
20:45:43 <edwardk> then it morphed: http://permalink.gmane.org/gmane.comp.lang.haskell.libraries/4592
20:46:28 <edwardk> which held us until we wound up with Text
20:46:29 <elliott> ByteString's name is one of the most unfortunate things we're stuck with today
20:46:36 <elliott> at least Num just sows annoyance rather than rampant confusion
20:46:42 <edwardk> hah
20:46:52 <cmccann> elliott, "Real"
20:47:02 <cmccann> :]
20:47:05 <edwardk> the main problem i have with ByteString is it baked into our culture this notion of making horribly large interfaces that are designed to be used qualified
20:47:34 <cmccann> didn't Data.Map & co. start that earlier?
20:47:44 <mauke> I like that
20:47:47 <edwardk> which kind of stopped any progress on things like Edison and their ilk trying to abstract over those concepts
20:47:54 <ddarius> cmccann: Not by much if at all.
20:48:03 <elliott> well, it's better than blahMap blahByteString
20:48:04 <cmccann> ah.
20:48:15 <elliott> FiniteMap suffixed FM I think
20:48:34 <mgsloan> can't attempts at abstracting those concepts just wrap the functions bytestring exports?
20:48:35 <edwardk> actually the Data.Map goes pretty far back, but the current API.. yeah
20:48:44 <edwardk> er the code goes i mean
20:49:02 <elliott> mgsloan: the point is that it made it too convenient to ignore the problem
20:49:04 <edwardk> mgsloan: the problem is you wind up with two types named ByteString no matter what you do
20:49:23 <edwardk> I woud _really_ have liked ByteString and LazyByteString
20:49:34 <mgsloan> Yeah, that is gnarly
20:49:38 <edwardk> but now we have 2 ByteStrings, 2 WriterTs, 2 StateTs, etc.
20:49:45 <elliott> ByteArray and LazyByteArray thx
20:49:48 <edwardk> it really opened a can of worms
20:49:49 <ddarius> Ugh.  See bottom of http://www.haskell.org/ghc/docs/0.29/users_guide/user_74.html#SEC74
20:49:52 <elliott> or Blob
20:50:18 <elliott> ddarius: hahaha
20:50:26 <edwardk> ddarius: wow
20:50:30 <elliott> "They're numbers. What kind? THEY'RE JUST NUMBERS"
20:50:49 <elliott> "They MIGHT be integers, let me tell you that much."
20:50:50 * ddarius is reminded yet again to poke some Planet Haskell person about GSTs.
20:51:02 <elliott> type Bytes = [Char] -- A byte stream is just a list of characters
20:51:17 * ddarius doesn't know what the naive user expects.
20:51:20 <elliott> what, Hashable is there
20:51:37 <elliott> how many years did it take from Hashable dying off to it being reinvented with the exact same basic interface?
20:51:48 <edwardk> elliott: hah
20:51:59 <ddarius> I love the very first functions here: http://www.haskell.org/ghc/docs/0.29/users_guide/user_69.html#SEC69
20:52:00 <ion> ‚Äúa Double with seconds since 1970‚Äù Double :-(
20:52:09 <elliott> hahahaha
20:52:17 <cmccann> ion, .... :[
20:52:37 <elliott> _CMP_TAG
20:52:39 <elliott> what a great type name
20:52:52 <elliott> haha, so many sorts
20:52:56 <ddarius> The sorting section is good.
20:52:56 <edwardk> ddarius: now i know where scala got the names ;)
20:53:05 <cmccann> "nOfThem" heh
20:53:12 <elliott> mergesort          :: (a -> a -> _CMP_TAG) -> [a] -> [a]
20:53:13 <elliott> mergeSort          :: Ord a => [a] -> [a]
20:53:18 <elliott> that's the least confusing naming scheme ever
20:53:30 <cmccann> yes
20:53:31 <edwardk> =)
20:53:36 <elliott> merges0rt
20:53:45 <ion> hah
20:54:16 <ddarius> Hey at the bottom are all those Arrow functions people want.
20:54:19 <elliott> I wonder what we'll be laughing about in today's GHC docs in 16 years.
20:54:37 <ddarius> I wonder about foldPair.
20:54:48 <edwardk> elliott: probably
20:54:54 <elliott> edwardk: what, not if :P
20:54:55 <elliott> if is a given
20:55:00 <elliott> @hoogle (a->a->a) -> (b->b->b) -> (a, b) -> [(a, b)] -> (a, b)
20:55:00 <lambdabot> No results found
20:55:11 <cmccann> elliott, the whole thing probably
20:55:14 <edwardk> or at least someone will be using some interface to chat with others and mocking some aspect of it ;)
20:55:14 <elliott> probably "to turn on the monomorphism restriction, ..."
20:55:28 <cmccann> elliott, except for Num, because we'll still be stuck with that 16 years from now
20:55:30 <ion> (a->a->a, b->b->b)? Nice.
20:55:46 <elliott> cmpString :: String -> String -> _CMP_TAG
20:55:50 <elliott> hmm, was String not [Char] back in the day?
20:56:21 <ion> elliott: ‚ÄúAww! Do you remember when the Functor-Applicative-Monad structure was broken back in the day?‚Äù
20:56:29 <elliott> haha
20:56:30 <ddarius> Does anyone use mergeIO for anything anymore?
20:56:53 <elliott> ion: "wow, they didn't even realise semimonoidal ring monads were staring them right in the face the whole time?"
20:57:09 <elliott> "they spent tons of effort trying to think of decent notation for commutative monads, how did they not notice?!"
20:57:56 <elliott> I bet we discover a new hierarchy element right after someone takes the plunge and adds an Applicative superclass to Monad.
20:57:56 <cmccann> wow, compiling darcs has a lot of warnings
20:58:01 <ion> I have no idea what semimonoidal ring monads are. :-D
20:58:16 <tkahn6_> cmccann: darcs takes forever to compile
20:58:33 <Saizan> ion: neither does anyone else
20:58:42 <elliott> ion: nobody does, YET
20:58:50 <elliott> but they'll solve all our problems, in the future
20:59:54 <cmccann> we really need to get started and figure this future stuff out soon
20:59:56 <cmccann> it sounds useful
21:00:24 <ddarius> http://www.haskell.org/ghc/docs/0.29/users_guide/user_62.html#SEC62
21:00:56 <elliott> the quotes make it extra-ominous somehow
21:03:43 <tkahn6_> btw: good intro categroy theory texts?
21:03:54 <ddarius> Awodey's "Category Theory"
21:04:16 <tkahn6_> ddarius: thanks
21:06:39 <mike___> Hello, I'm having some problems with my code
21:06:42 <mike___> can anyone help me?
21:06:48 <tkahn6_> mike___: sure post on hpaste
21:06:51 <ion> No need to ask to ask.
21:07:01 <mike___> i don't think ill need to paste it
21:07:05 <tkahn6_> mmk
21:07:05 <mike___> its about the do statement
21:07:09 <mike___> sometimes i get an error
21:07:23 <mike___> parse error on input `''
21:07:41 <mike___> and i have it exactly as some of my older code
21:07:46 <tkahn6_> i think using hpaste would help
21:07:49 <mike___> ok
21:07:51 <tkahn6_> cuz that's a generic error
21:08:39 <hpaste> Mike___ pasted ‚Äúrubik‚Äù at http://hpaste.org/63520
21:08:46 <mike___> its on line 73
21:08:51 <mike___> and as you can see
21:09:02 <mike___> my do, only gives me error with im checking for the number 2
21:09:07 <mike___> it works well for the 1
21:09:16 <mike___> and the other do statements i have, are mostly working
21:10:10 <mike___> hmm, i noticed something
21:10:13 <mike___> my identation
21:10:14 <quintessence> you're mixing spaces and tabs
21:10:15 <mike___> on hpaste
21:10:16 <ion> mike: There‚Äôs some very strange indentation. And you seem to be using tabs, which is an infinite source of grief.
21:10:17 <mike___> is different from the one
21:10:20 <mike___> exactly
21:10:28 <mike___> im using notepad++
21:10:35 <mike___> would you recomend anyother good editor?
21:10:50 <tkahn6_> vim :p
21:10:55 <quintessence> emacs :p
21:11:00 <tkahn6_> flame on
21:11:00 <mike___> dont feel like going in2 linux -.-
21:11:02 <quintessence> I suspect notepad++ has a setting to just use spaces
21:11:03 <eyebloom> leksah
21:11:11 <mike___> i love the colloring
21:11:37 <tkahn6_> i'm sure there's a way to have notepad++ use spaces
21:11:46 <tkahn6_> also vim and emacs have windows versions
21:12:24 <cmccann> notepad++ works just fine
21:12:24 <mike___> gosh, it's such a shame notepad++ is giving me this trouble
21:12:30 <cmccann> just turn of tabs
21:12:43 <cmccann> I used it quite a bit on windows, it's fine
21:14:03 <mike___> thanks for the help ^.^
21:14:19 <BMeph> mike___: Settings -> Preferences -> Language Menu/Tab Settings -> check the box marked "replace by space". :)
21:14:38 <mike___> did that right now ::)
21:14:41 <mike___> thanks :)
21:15:03 <BMeph> mike___: Then you win +1 Internets. ;)
21:16:37 <mike___> ah ah ah
21:16:40 <E3D3> I'm looking for something like 'getContents' or 'getLine' but I need it for a Int. Is there something like that for a noob ?
21:17:18 <Saizan> ?ty readLn
21:17:19 <lambdabot> forall a. (Read a) => IO a
21:17:47 <Eduard_Munteanu> :t read
21:17:48 <lambdabot> forall a. (Read a) => String -> a
21:18:04 <E3D3> Yes, that seems what I need. Thanks
21:19:28 <E3D3> Works :-) Thanks
21:20:29 <MaskRay> seeking google haskell mode for vim
21:22:25 <ion> :t readIO
21:22:25 <lambdabot> forall a. (Read a) => String -> IO a
21:22:35 <JoeyA> How can I compile the RTS with -g (debugging) ?
21:23:07 <Enigmagic> edit rts/ghc.mk and add it in
21:23:42 <Enigmagic> or you can link just compile your haskell app with ghc -debug (which also comes with asserts and other things you may or may not want)
21:23:54 <ddarius> For edwardk: http://upload.wikimedia.org/wikipedia/commons/7/76/ShimadaK2007Sept09-MentosGeyser_DSC_3294%2B%2B.JPG
21:24:15 <edwardk> heh
21:24:29 <Enigmagic> (the debug rts has debug symbols enabled, i don't know why the release bits do not by default)
21:25:35 <JoeyA> Thanks, didn't know about -debug
21:28:39 <ion> http://ftp.de.debian.org/debian/pool/main/h/haskell-numbers/haskell-numbers_2009.8.9-2.debian.tar.gz has a patch for the 7.4.1 issue, btw.
21:28:44 <LordTrev> How do I use, say, Network , in ghci? As in import Network
21:28:47 <Cbin> Hi
21:29:01 <JoeyA> LordTrev: Did import Network print nothing and not work?
21:29:18 <Enigmagic> :module + Network
21:29:22 <JoeyA> You may have to install the network package.  When I ran ghci-7.4.1 and tried to import packages, I didn't get any error messages.
21:29:27 <LordTrev> Enigmagic, thanks
21:31:03 <MaskRay> i want two-line prompt
21:31:48 <MaskRay> "module0,module1,...,\n> "
21:36:27 <tkahn6_> MaskRay: :set prompt "%s\n> "
21:36:52 <MaskRay> tkahn6_: thank you
21:37:10 <tkahn6_> MaskRay: np
21:37:36 <MaskRay> ghc userguide on Monad comprehensions seems less informative, better incorporating http://hackage.haskell.org/trac/ghc/wiki/MonadComprehensions
21:39:14 <roconnor> I don't know how python programmers manage to refactor code without getting constant type errors.
21:39:28 <roconnor> er, I'm not sure if that came out right
21:40:10 <tkahn6_> roconnor: i'm working on adding a database library to apache libcloud
21:40:19 <tkahn6_> roconnor: it's all written in enterprisey python
21:40:31 <tkahn6_> roconnor: :(((((((((((((((((((((((((((((((((((((((((((((((((((((
21:40:54 <tkahn6_> it's so hard to reason about
21:42:02 <roconnor> whew
21:42:15 <roconnor> I just fixed a bunch of code by removing a polymorphic function
21:42:23 <roconnor> turn out it was just too easy to call with wrong arguments
21:49:05 <dolio> roconnor: I know what you mean. I've more than once been wrestling with type errors at work, and thought about how people complain that they have to do that in Haskell, but not in 'dynamic languages.'
21:49:17 <dolio> And how all the type errors are actual problems with my logic.
21:49:41 <dolio> Which they'd have to find anyway, by things not working right, and tracking down why.
21:50:32 <dolio> Whereas I get a bunch of line numbers where I've done things wrong.
21:50:36 <MaskRay> tkahn6_: looks pretty when the context gets huge. may i ask your preferred prompt?
21:51:09 <tkahn6_> MaskRay: heh just plain
21:51:16 <tkahn6_> but your idea is really good
21:54:05 <tkahn6_> MaskRay: this is kind of cool  :set prompt "‚ï≠‚îÄ%s\n‚ï∞‚îÄ "
21:54:21 * cmccann is still enjoying using "‚àÄx. x ‚ä¢" for his ghci prompt
21:54:54 <ion> What‚Äôs the meaning of ‚ä¢ again?
21:55:10 <MaskRay> tkahn6_: wonderful!
21:55:38 <tkahn6_> MaskRay: i have that in my zsh prompt so i thought it would work well here
21:56:13 <roconnor> ion: proves or something similar
21:56:56 <roconnor> cmccann is saying that if everything is inhabited, then whatever nonsense he is about to write follows.
21:58:23 <mike___> I hate it when my code doesnt do what i want -.-
22:00:05 <cmccann> roconnor, yes, the beauty of turing-complete programming
22:01:19 <otters> I need something witty to set my prompt as
22:01:20 <otters> ._.
22:01:50 <cmccann> otters, Œª> seems to be popular
22:01:55 <cmccann> it's nicely minimal
22:01:57 <otters> I already had that
22:02:05 <otters> maybe ">>= "
22:02:26 <otters> yeah that'll work
22:10:38 <Jafet> "print <$> "
22:10:55 <nsxt> is there a way to set a default prompt, like from an rc file or something?
22:11:00 <tkahn6_> .ghci
22:11:05 <nsxt> danke :)
22:13:37 <hpaste> Mike___ pasted ‚Äúrubik‚Äù at http://hpaste.org/63521
22:13:40 <mike___> sorry
22:13:46 <mike___> erm, I'm trying to get my if sentence
22:13:54 <mike___> at the beggining of the do sentence
22:14:02 <mike___> but i keep getting errors >_<
22:15:01 <mike___> as it is, its working
22:15:14 <mike___> but if I change the if from line 6 to line 3
22:15:20 <mike___> it stops working -.-
22:16:19 <tkahn6_> mike___:  those do statements are unecessary
22:16:31 <mike___> hm
22:16:49 <mike___> didn't know that
22:16:51 <mike___> thanks
22:17:05 <otters> aww semicolons
22:17:27 <mike___> are they bad? O_o
22:17:38 <tkahn6_> they're usually unecessary
22:17:39 <otters> they're ugly
22:17:48 <mike___> ah ah ah, so used to them
22:17:49 <mike___> :p
22:18:01 <otters> that's your problem
22:18:08 <mike___> c and php
22:18:09 <mike___> :x
22:18:13 <tkahn6_> you also might want to consider doing a pattern match for True or False
22:18:18 <tkahn6_> with your w argument
22:18:40 <tkahn6_> so you don't need to use that if/then structure
22:18:54 <mike___> hmm, sounds ncie
22:19:45 <mike___> Still got a long way to go until I can actually do some decent coding -.-
22:19:50 <tkahn6_> actually you should create a helper function that just handles what happens when w is false or true
22:19:51 <mike___> still starting though
22:20:02 <tkahn6_> and then call that after you do your menu thing
22:20:12 <tkahn6_> so you don't have to repeat that
22:20:26 <mike___> yeah.. thats the problem I had with a function
22:20:30 <mike___> I wanted to rotate the cube
22:20:36 <mike___> and keep those movements
22:20:52 <mike___> so, i actually had to keep calling the menu, and passing the cube's new state into it
22:20:57 <mike___> cause it expected to output IO
22:21:48 <mike___> I get the feeling im still doing things the hard way, but getting them stop by step
22:21:56 <mike___> step*
22:22:29 <wavewave> hxournal has pressure sensitivity support!
22:22:43 <ddarius> :set prompt "let it = "
22:25:03 <hpaste> Mike___ pasted ‚Äúrubik‚Äù at http://hpaste.org/63522
22:25:11 <mike___> ok, i got rid of those do statements
22:25:14 <hpaste> tkahn6_ annotated ‚Äúrubik‚Äù with ‚Äúrubik (annotation)‚Äù at http://hpaste.org/63521#a63523
22:25:21 <mike___> but, i cant still pass my if to the top line :s
22:25:59 <hpaste> tkahn6_ annotated ‚Äúrubik‚Äù with ‚Äúrubik (annotation) (annotation)‚Äù at http://hpaste.org/63521#a63524
22:26:11 <cmccann> wavewave, wow, you're fast
22:26:25 <tkahn6_> mike___: see my annotation
22:26:59 <cmccann> wavewave, now I almost feel guilty that I won't be able to get back to the project I wanted to use that for until next week at least :T
22:27:17 * hackagebot http-conduit 1.2.6 - HTTP client package with conduit interface and HTTPS support.  http://hackage.haskell.org/package/http-conduit-1.2.6 (MichaelSnoyman)
22:27:38 <wavewave> cmccann: ;-)
22:27:42 <mike___> thanks alot
22:27:49 <mike___> imma take some minutes to read it
22:27:54 <mike___> and understand
22:28:07 <wavewave> fast development is possible because I use haskell!
22:28:33 <wavewave> cmccann : in fact, it still has a problem..
22:28:40 <tkahn6_> wavewave: spin that propaganda :p
22:29:05 <wavewave> tkahn6_ : seriously.. this is really due to haskell
22:31:18 <tkahn6_> wavewave: what does this do? Just ra4 <- actionGroupGetAction agr "VERTSPA"
22:31:34 <tkahn6_> as in what does `Just x <- expr`
22:31:35 <tkahn6_> do
22:32:03 <wavewave> tkahn6 : that's a shame. ;-P
22:33:01 <wavewave> I know it exists... but its output is Mayb type.. so I feel lazy.. so just partial pattern matching
22:33:17 <tkahn6_> oh interesting
22:33:27 <wavewave> that's not a good habit at all.
22:33:34 <tkahn6_> what happens if it's Nothing?
22:33:38 <tkahn6_> it explodes?
22:33:40 <wavewave> then.. crashes.
22:33:43 <wavewave> yeah..
22:33:46 <tkahn6_> hahaha
22:33:58 <tkahn6_> well let's hope it's never Nothing :p
22:34:06 <tkahn6_> that's interesting though
22:34:19 <cmccann> > do { Just x <- Nothing; return x }
22:34:20 <lambdabot>   Nothing
22:34:30 <wavewave> I am eliminating those pieces..
22:34:55 <wavewave> cmccann: yeah.. if I am in maybe monad.. then it's okay..
22:35:19 <mike___> tkahn6_: I see what you did there. The problem is, I need to check it it is true before asking for any input. I'll have to change that. That's why I needed the if statement first
22:35:19 <wavewave> I do not have a proper error processing monad transformer yet in hxournal.
22:35:33 <tkahn6_> do { print "hello"; Just x <- Nothing; print x}
22:35:37 <tkahn6_> > do { print "hello"; Just x <- Nothing; print x}
22:35:38 <lambdabot>   Couldn't match expected type `Data.Maybe.Maybe a'
22:35:38 <lambdabot>         against inferred ...
22:35:50 <wavewave> although I almost have it using coroutine.
22:36:12 <tkahn6_> > do { print "hello"; Just x <- return Nothing; print x}
22:36:13 <lambdabot>   <IO ()>
22:36:17 <wavewave> my focus is usually implementing new features first.. heheh.
22:36:19 <cmccann> lambdabot doesn't like IO
22:36:26 <tkahn6_> oh i see
22:36:44 <cmccann> wavewave, yeah, I was just being devious with the Maybe stuff, heh
22:36:50 <tkahn6_> *** Exception: user error (Pattern match failure in do expression at <interactive>:1:21-26)
22:36:53 <tkahn6_> so that settles that
22:36:54 <cmccann> yep
22:37:17 <wavewave> coroutine was a great breakthrough in my coding
22:37:56 <cmccann> wavewave, anyway, remind me that I should buy you a beer or a coffee or whatever is to your taste if I'm ever on that side of the state
22:38:05 <cmccann> assuming your hostname isn't misleading
22:38:23 <wavewave> inverting control logic so that it is more similar to business logic.
22:38:27 <tkahn6_> mike___: what do you need to check is true?
22:38:34 <wavewave> cmccann: thanks!  I am in michigan.
22:38:38 <mike___> The bool value I recieve
22:38:45 <mike___> before asking for input
22:38:52 <mike___> it needs to be the first thing
22:39:06 <wavewave> now.. I will describe some remaining piece of problem.
22:39:19 <mike___> and I can0t change its position because the pattern requires n. And i dont have n at that point
22:39:34 <cmccann> wavewave, yeah, I'm in Grand Rapids... Ann Arbor is nicer :P
22:39:52 <tkahn6_> mike___: so you want different semantics than the code you posted?
22:40:06 <mike___> yup, that was my first problem
22:40:15 <mike___> i was trying to pass the if statement up
22:40:17 <tkahn6_> mike___: so you want to know if w is true before you do anything and decide whether to prompt based on that
22:40:20 <mike___> but was getting errors
22:40:25 <mike___> exactloy
22:40:41 <mike___> so, should I use two patterns or just one?
22:41:07 <wavewave> cmccann: oh.. you are in Michigan! great to know you!
22:41:34 <tkahn6_> mike___: probably two, have one where it's like gereMenuJogo c True = putStrLn "blah blah"
22:41:46 <mike___> ok
22:41:47 <tkahn6_> and then gereMenuJogo c False = ‚Ä¶ do your stuff here
22:41:48 <mike___> thanks
22:41:53 <tkahn6_> mike___: yeah gl
22:45:45 <fauxCoder> aoaoeu
22:45:45 <wavewave> See http://ianwookim.org/hxournal/gallery.html
22:45:56 <wavewave> the last screenshot is the current status.
22:46:15 <wavewave> pressure sensitivity is working... but rendering has some little problem.
22:46:30 <wavewave> overlapping path problem
22:47:08 <hpaste> Mike___ pasted ‚Äúrubik‚Äù at http://hpaste.org/63525
22:47:17 <mike___> tkahn6_: Am I doing something wrong?
22:47:55 <tkahn6_> mike___: you only want to print the menu and do everything when w is False right?
22:48:13 <mike___> exactly
22:48:16 <tkahn6_> ok
22:48:27 <tkahn6_> k you need one function with two pattern matches
22:48:57 <tkahn6_> so gereMenuJogo _ True = putStr "\n\nGANHASTE!\n\n"
22:49:18 <tkahn6_> and gereMenuJogo c False = printCubo c
22:49:19 <tkahn6_>                         n <- ler_op "rRlL0"
22:49:19 <tkahn6_>                         putStr menuJogo
22:49:22 <tkahn6_> and the rest
22:49:28 <cmccann> wavewave, looks like you're doing a line-crossing test for finding the interior of a region, or something like that
22:49:43 <wavewave> cmccann : no.. it's  cairo thing.
22:50:03 <mike___> oh
22:50:04 <mike___> ok
22:50:21 <wavewave> cmccann : when doing pressure sensitivity, I am drawing contour and fill it inside.
22:50:24 <cmccann> wavewave, well, then cairo's doing that somehow :P
22:50:44 <wavewave> but.. my contour is not real contour..
22:50:54 <wavewave> my algorithm is faulty now..
22:51:03 <cmccann> wavewave, probably has to do with the direction of the line segments or something
22:51:10 <cmccann> I don't really know how cairo works though :T
22:51:28 <wavewave> yes.. problem is how to find envelope of a shape sweeping.
22:51:48 <wavewave> exactly speaking.. not cairo problem.. it's general envelop finding problem.
22:51:57 <wavewave> my algorithm is too naive. that's the problem.
22:52:17 <cmccann> it's a tricky thing to handle correctly
22:52:17 * hackagebot dimensional-tf 0.1 - Statically checked physical dimensions, implemented  using type families.  http://hackage.haskell.org/package/dimensional-tf-0.1 (BjornBuckwalter)
22:52:31 <wavewave> when direction changes, that happens and when overlapping happens, that happens again.
22:53:20 <wavewave> generally, this is not an easy problem.. this is a common problem in font making business
22:53:52 <wavewave> I found a program called MetaFog solved this problem before for metafont.
22:54:06 <wavewave> but i couldn't find the algorithm yet.
22:54:14 * cmccann has learned all about drawing opengl triangles in the wrong orientation and then not seeing the texturing
22:54:54 <wavewave> anyway.. it's a kind of half-done now. at least it support 'pressure sensitivity'
22:55:07 <hpaste> Mike___ pasted ‚Äúrubik‚Äù at http://hpaste.org/63526
22:55:22 <mike___> Getting a parse code now :s
22:55:28 <cmccann> wavewave, yes, and again thank you for doing that so quickly :D
22:55:39 <mike___> L9
22:55:51 <mike___> tkahn6_: sorry to be bugging you again -.-
22:55:58 <mauke> what's a parse code?
22:56:06 <mauke> mike___: missing a "do"
22:56:21 <mauke> 'otherwise' is wrong there
22:56:23 <mauke> you meant _
22:56:30 <mike___> oh
22:57:21 <mike___> do, you're right
22:57:24 <mike___> i missed a do
22:57:35 <mike___> just can't understand why im still getting an errors
22:57:40 <mike___> error*
22:58:09 <tkahn6_> what error are you getting?
22:58:18 <mike___> the line right after the case
22:58:27 <mike___> probably identation
22:58:28 <mauke> what error are you getting?
22:58:45 <mike___> possibly incorrect identation
22:58:48 <mauke> what error are you getting?
22:58:55 <tkahn6_> lol
22:59:10 <tkahn6_> mike___: we can only help you if you give use the exact error messae
22:59:11 <mike___> 105:30:     parse error (possibly incorrect indentation)
22:59:38 <mauke> that paste doesn't have 105 lines
22:59:49 <hpaste> Mike___ pasted ‚Äúrubik‚Äù at http://hpaste.org/63527
22:59:51 <mauke> but you should indent more after "of"
22:59:57 <tkahn6_> yeah you need to indent those statements in your case structure
23:00:05 <mike___> it's equal to the line 13
23:00:20 <mauke> mike___: you don't need to indent so much in line 9, btw
23:00:28 <mauke> just more than line 8
23:01:09 <wavewave> cmccann: i've uploaded the code to github.. refer to Device.hsc for pressure sensitivity ;-)
23:01:22 <cmccann> wavewave, :D
23:04:19 <mike___> im starting to get upset :C
23:06:23 <hpaste> Mike___ pasted ‚Äúrubik‚Äù at http://hpaste.org/63528
23:06:47 <mauke> mike___: what is line 18 supposed to do?
23:06:51 <mike___> I'm getting an eror on the last line
23:07:10 <mike___> it's suppose to render the menu again
23:07:12 <hpaste> mauke annotated ‚Äúrubik‚Äù with ‚Äúrubik (annotation)‚Äù at http://hpaste.org/63528#a63529
23:07:34 <mike___> ohh, you can use _ like that?
23:07:46 <mauke> that's the only way you can use _
23:08:02 <mike___> I meant, I use in patterns
23:08:19 <mike___> didn't know I could use it in a do sentense too
23:08:19 <mike___> :D
23:08:33 <mike___> I'm still getting an error on the last line
23:08:41 <ski> `foo' in `do ...; foo <- bar; ...' is a pattern
23:08:41 <lambdabot> ski: You have 1 new message. '/msg lambdabot @messages' to read it.
23:08:42 <mike___> 110:37:     parse error on input `->'
23:08:46 <mauke> it is in a pattern
23:08:49 <ski> @messages
23:08:49 <lambdabot> roconnor_ said 1d 16h 21m 57s ago: page 9 of http://arxiv.org/abs/1201.3898 has extactly the eta rule we came up with last night!
23:08:55 <hpaste> mauke annotated ‚Äúrubik‚Äù with ‚Äúrubik (annotation) (annotation)‚Äù at http://hpaste.org/63528#a63530
23:09:01 <mike___> that line is the last one
23:09:50 <mauke> mike___: why does it say 37?
23:09:54 <mauke> it's on column 35 here
23:09:57 <mauke> oh wait
23:10:24 <mauke> yeah, there's something wrong with the column
23:10:27 <mike___> i think it was identation in the end
23:10:59 <mike___> mauke fixed it with his identation
