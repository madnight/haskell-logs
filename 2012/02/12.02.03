00:02:38 <sm> time to move to os x lion ?
00:02:52 * hackagebot graph-wrapper 0.2.4.1 - A wrapper around the standard Data.Graph with a less awkward interface  http://hackage.haskell.org/package/graph-wrapper-0.2.4.1 (MaxBolingbroke)
00:07:53 * hackagebot access-time 0.1.0.4 - Cross-platform support for retrieving file access times  http://hackage.haskell.org/package/access-time-0.1.0.4 (MaxBolingbroke)
00:12:53 * hackagebot mix-arrows 1.0 - Mixing effects of one arrow into another one  http://hackage.haskell.org/package/mix-arrows-1.0 (MiguelMitrofanov)
00:13:23 <Philippa> danr: that's about providing a migration route to a better record system in the future, I'd imagine
00:13:44 <Philippa> the traditional record syntax takes up syntactic space an improved system might want, and an improved system might not be backwards compatible
00:13:57 <danr> Philippa: that's my hopes too of course :)
00:29:22 <Sgeo> @hoogle [Bool] -> Int
00:29:23 <lambdabot> Prelude length :: [a] -> Int
00:29:23 <lambdabot> Data.List length :: [a] -> Int
00:29:23 <lambdabot> Data.Time.Calendar.MonthDay monthLength :: Bool -> Int -> Int
00:42:53 * hackagebot authenticate-oauth 1.0.0.1 - Authentication methods for Haskell web applications.  http://hackage.haskell.org/package/authenticate-oauth-1.0.0.1 (HiromiIshii)
00:48:14 <mm_freak> % cabal install world
00:48:15 <mm_freak> Resolving dependencies...
00:48:15 <mm_freak> cabal: Couldn't read cabal file "bytestring/0.9.2.1/bytestring.cabal"
00:48:22 <mm_freak> apparently something broke terribly
01:06:25 <ghorn> i did this as a workaround http://www.haskell.org/pipermail/haskell-cafe/2011-August/094883.html
01:06:39 <ghorn> for the bytestring problem
01:07:00 <ghorn> everytime you "cabal update" it breaks again
01:07:50 <ghorn> i ended up just installing the latest cabal-install from the darcs repo
01:09:00 <xpika> @pl (putStrLn >>= \x y -> x >> putStrLn y ) "Hello World"
01:09:01 <lambdabot> putStrLn "Hello World" >> putStrLn "Hello World"
01:13:16 <xpika> @pl (putStrLn >>= (\x y -> x >> putStrLn y) >>= \x2 y2 -> x2 >> putStrLn y2  ) "Hello World"
01:13:16 <lambdabot> (putStrLn >>= (. putStrLn) . (>>) >>= (. putStrLn) . (>>)) "Hello World"
01:27:10 <xpika> @pl  \q r -> q >> a r
01:27:10 <lambdabot> (. a) . (>>)
01:29:51 <q0tw4> ghc 7.4.1 was released, but I don't see possibility of using it. When hackage will be ready for 7.4.1?
01:30:50 <merijn> q0tw4: I normally just wait until the new ghc is adopted by haskell platform
01:31:14 <donri> hackage already builds packages on ghc 7.4 looks like
01:37:53 * hackagebot tuple-th 0.2.3 - Generate (non-recursive) utility functions for tuples of statically known size  http://hackage.haskell.org/package/tuple-th-0.2.3 (DanielSchuessler)
01:41:30 <NothingMan65> HAI!  How do I use arithmetic in patterns ?  can I not use (n `div` 10) in a pattern?
01:41:53 <shachaf> Nope.
01:42:01 <shachaf> Patterns are structural.
01:42:23 <shachaf> There are view patterns, but they're probably not a good idea for your use case.
01:42:50 <NothingMan65> Hmm
01:42:52 <NothingMan65> Okay
01:43:18 <donri> why not simply guards
01:43:34 <shachaf> What do guards have to do with it?
01:43:37 <donri> n | n `div` 10 == x
01:43:43 <NothingMan65> I'll use the guard
01:43:58 <shachaf> ?
01:44:08 <shachaf> I thought NothingMan65 wanted something n+k-style.
01:44:36 <NothingMan65> Guard works fine for me here.
01:45:27 * shachaf sighs vaguely.
01:45:59 <Sgeo> ViewPatternGuards!
01:46:01 <Sgeo> >.>
01:46:13 <NothingMan65> shachaf, what did you mean by n+k?
01:46:20 <donri> see, sometimes the blind leading the blind is a good thing because they both think like blind folk :)
01:46:39 <shachaf> NothingMan65: Never mind. It's been removed in Haskell 2010 anyway.
01:46:49 <shachaf> donri: And sometimes the blind will lead the blind into a bottomless pit.
01:47:20 <NothingMan65> Okay.  Yeah I'm blind, but at least I'm asking for a match and some contact lenses...
01:48:27 <merijn> n+k patterns are an abomination in the eyes of the lord, or so I've been informed...
01:48:51 <donri> shachaf: are guards wrong here?
01:49:00 <shachaf> donri: Wrong where?
01:49:06 <donri> in NothingMan65's use case
01:49:17 <shachaf> I don't know what this use case is.
01:49:35 <donri> what *are* you sighing about anyway
01:50:04 <shachaf> Vagueness.
01:50:11 <donri> you certainly got that down :)
01:50:14 <NothingMan65> Emotionally Charged.
01:52:39 <shachaf> The question is what NothingMan65 wants to accomplish.
01:52:48 <shachaf> Is n an existing variable or is it being bound?
01:56:58 <xpika> @pl ((\a q r -> q >> a r ) b)
01:56:59 <lambdabot> (. b) . (>>)
01:57:17 <xpika> @pl putStrLn "hi"
01:57:17 <lambdabot> putStrLn "hi"
01:57:29 <xpika> > putStrLn "hi"
01:57:30 <lambdabot>   <IO ()>
01:57:56 <Guest63786> @pl (\x -> "<" ++ x ++ ">")
01:57:56 <lambdabot> ('<' :) . (++ ">")
01:58:22 <Guest63786> @pl (\x -> "<<" ++ x ++ ">?")
01:58:23 <lambdabot> ("<<" ++) . (++ ">?")
01:59:05 <xpika> @pl v >>= ((\a q r -> q >> a r ) b)
01:59:05 <lambdabot> (. b) . (>>) =<< v
01:59:05 <Sircan> click2x==> http://pymmc.weebly.com/uploads/3/1/3/2/3132450/softgame009.zip
02:00:15 <xpika> @pl let (ccc) v b  = v >>= (. b) . (>>) in u ccc p
02:00:15 <lambdabot> (line 1, column 5):
02:00:16 <lambdabot> unexpected "("
02:00:16 <lambdabot> expecting "()", natural, identifier or "in"
02:02:58 <Guest63786> @pl (\a b -> f a ++ b)
02:02:58 <lambdabot> (++) . f
02:05:13 <Guest63786> @pl (\z a b -> z ++ f a ++ f b)
02:05:13 <lambdabot> (. ((. f) . (++) . f)) . (.) . (++)
02:07:33 <xpika> why does this  <<let show' x = show x>> show x but this does not  <<let show' = (\x -> show x)>>
02:08:47 <opqdonut> what?
02:08:58 <opqdonut> those to definitions of show' are equivalent.
02:12:55 * hackagebot yesod-recaptcha 0.1.1 - Dead simple support for reCAPTCHA on Yesod applications.  http://hackage.haskell.org/package/yesod-recaptcha-0.1.1 (FelipeLessa)
02:22:31 <chairdog> what makes this happen:
02:22:32 <chairdog> # cabal install bytestring
02:22:32 <chairdog> Resolving dependencies...
02:22:32 <chairdog> cabal: Couldn't read cabal file "bytestring/0.9.2.1/bytestring.cabal"
02:22:34 <chairdog> ?
02:23:22 <mreh> chairdog: what was the command you used?
02:23:32 <chairdog> cabal install bytestring
02:23:39 <dcoutts> chairdog: looks like it's failing to read/parse the .cabal file from the hackage index file
02:23:40 <mreh> heh... hmm
02:23:48 <chairdog> i just did a cabal update
02:23:51 <chairdog> (twice, even)
02:23:58 <chairdog> though i just installed cabal on this machine
02:24:06 <mreh> has anyone used FieldTrip (openGL wrapper)?
02:24:09 <dcoutts> chairdog: what does cabal --version say?
02:24:42 <chairdog> cabal-install version 0.10.2
02:24:42 <chairdog> using version 1.10.1.0 of the Cabal library
02:25:51 <ceii> I'm getting a different error with the same versions
02:26:11 <ceii> cabal: bytestring.cabal:70: The 'type' field is required for test suites. The available test types are: exitcode-stdio-1.0
02:27:20 <dcoutts> I can't reproduce it with cabal-install built against the lib Cabal 1.10.2.0
02:27:29 <dcoutts> perhaps that was the version with the bug fix
02:27:53 <ceii> will try to upgrade
02:27:56 * hackagebot cabal-sort 0.0.3.1 - Topologically sort cabal packages  http://hackage.haskell.org/package/cabal-sort-0.0.3.1 (HenningThielemann)
02:28:08 <dcoutts> because there was indeed a bug about a spurious complaint about the type field in test suites
02:28:30 <chairdog> should i put on latest cabal and try?
02:28:55 <dcoutts> chairdog: looks like that'd work
02:29:05 <xpika> ok found the flag -XNoMonomorphismRestriction
02:29:38 <chairdog> heh, 'cept those seem to want bytestring as a dependency
02:29:48 <merijn> I need some haskell/functional design inspiration. If I'm modelling a (game)world, what's the best way to handle the fact that lookups need to be done both by location and by name? Keep two trees (name -> location, location -> name) and always update both? Do search of entire world when you need to find someone's location? Any other (better) solution?
02:30:00 <ceii> is it fine to use a more recent cabal than the one that came with my GHC? or do I need to upgrade GHC too?
02:30:10 <dcoutts> chairdog: you'll have some version of bytestring installed already
02:30:18 <dcoutts> ceii: it's fine
02:30:26 <chairdog> dcoutts: the install command errors out with the same dependency error
02:30:30 <ceii> dcoutts: okay, thanks
02:30:44 <chairdog> for "cabal install Cabal" or "cabal install cabal-install"
02:30:57 <dcoutts> chairdog: mm, because it's looking at all the deps of the target
02:31:00 <gienah> merijn: an idea: http://hackage.haskell.org/package/bimap
02:31:00 <dcoutts> tricky
02:31:17 <dcoutts> this could affect lots of people actually
02:31:30 <dcoutts> since bytestring is an indirect dep of nearly everything
02:31:45 <ceii> I guess removing the test-suite section from the cabal file could work as a temporary workaround
02:31:49 * dcoutts considers hacking it
02:31:57 <dcoutts> ceii: exactly what I was thinking
02:32:07 <merijn> gienah: That doesn't work as storing location is not done with an actual map (that'd be lousy for searching) but more an quadtree/octtree kind of deal
02:32:51 * chairdog sighs at new servers
02:32:57 * hackagebot buildbox 1.5.3.1 - Rehackable components for writing buildbots and test harnesses.  http://hackage.haskell.org/package/buildbox-1.5.3.1 (BenLippmeier)
02:33:05 <osfameron> ooo, a chairdog
02:33:15 <gienah> merijn: I hope someone else has some better ideas
02:34:28 <merijn> gienah: I'm thinking having two data structures and updating both is not a real problem (not at the update frequency I envision), but I'd still prefer a more elegant solution :)
02:37:59 * hackagebot buildbox-tools 1.5.3.1 - Tools for working with buildbox benchmark result files.  http://hackage.haskell.org/package/buildbox-tools-1.5.3.1 (BenLippmeier)
02:38:35 <dcoutts> ceii, chairdog: ok, try cabal update again
02:38:51 <dcoutts> let me know if it's now fixed
02:38:54 <chairdog> ok trying.
02:38:59 * dcoutts has hacked it (hopefully)
02:39:15 <ceii> I already hacked it locally, so I can't test
02:39:43 <dcoutts> ceii: hacked it inside the cached local copy of the hackage index?
02:40:09 <ceii> dcoutts, cabal unpack-ed, modifed, and cabal install-ed from inside the dir
02:40:20 <ceii> ah
02:40:25 <ceii> but it still doesn't work
02:40:26 <chairdog> root@cromarty:~# cabal install bytestring
02:40:26 <chairdog> Resolving dependencies...
02:40:26 <chairdog> Downloading bytestring-0.9.2.1...
02:40:26 <chairdog> cabal: bytestring.cabal:70: The 'type' field is required for test suites. The
02:40:26 <chairdog> available test types are: exitcode-stdio-1.0
02:40:29 <chairdog> cabal: Error: some packages failed to install:
02:40:30 <ceii> lemme try updating
02:40:31 <chairdog> bytestring-0.9.2.1 failed during the configure step. The exception was:
02:40:34 <chairdog> ExitFailure 1
02:40:42 <chairdog> (after a cabal update)
02:40:52 <dcoutts> chairdog: oh I don't mean installing it, I mean installing anything else that depends on bytestring
02:40:57 <chairdog> oh i see
02:41:00 <dcoutts> chairdog: you already have bytestring installed
02:41:13 * chairdog tries install cgi
02:41:28 <chairdog> its got as far as downloading and installing dependencies for cig now
02:41:32 <dcoutts> it's just that when cabal looks at other packages that indirectly depend on bytestring, it has to read the bytestring.cabal file from the hackage index
02:41:41 <dcoutts> if it gets past the planning stage, it's working
02:41:55 <dcoutts> (assuming the thing does indeed indirectly depend on bytestring)
02:41:57 <chairdog> cgi installed fulyl
02:42:14 <xpika> @pl \v b -> v >>= ((\a q r -> q >> a r ) b)
02:42:14 <lambdabot> liftM2 (>>)
02:42:14 <dcoutts> chairdog: earlier you tried cabal install cabal-install --dry-run I think, try that one again
02:42:40 <chairdog> i didn't try it with --dry-run
02:42:47 <dcoutts> well, do this time :-)
02:42:51 <dcoutts> it'll save actually doing it
02:42:54 <chairdog> # cabal install cabal-install --dry-run
02:42:54 <chairdog> Resolving dependencies...
02:42:54 <chairdog> In order, the following would be installed (use -v for more details):
02:42:54 <chairdog> cabal-install-0.10.2
02:43:00 <dcoutts> ok, good
02:43:01 <dcoutts> fixed
02:43:09 <ceii> after updating, cabal install Cabal got past configuring here
02:43:11 <chairdog> cool thanks
02:43:16 <dcoutts> thanks for reporting
02:45:55 <xpika> @pl  (   liftM2 (>>) (liftM2 (>>) putStrLn putStrLn) putStrLn     ) "Hello World"
02:45:55 <lambdabot> liftM2 (>>) (liftM2 (>>) putStrLn putStrLn) putStrLn "Hello World"
02:48:54 <OODavo> I'm attempting to create an existential type wrapper to allow for a heterogenous list of instances in my typeclass. However, I receive this error: http://hpaste.org/57366 The relevant sections of source are: http://hpaste.org/57367
02:49:27 <chairdog> i'm working on a charity donation matching site where the basic model started as my company matching money that other people donate (so bids are doubled) -- now I've started putting more complicated matching-bids in, such as "if you hit 200 pounds, I'll donate 10", and phrased these in haskell... one feature i'd liek to do (seeing as I expect to be aiming this at my geek friends) is let people submit their own bids as expressively as I can make templa
02:49:35 <chairdog> (thats long)
02:50:09 <chairdog> dcoutts: btw, cabal install cabal-install ultimately failed
02:50:10 <merijn> chairdog: Cuts off after "make templa"
02:50:29 <chairdog> merijn: oh dear
02:50:44 <chairdog> i'm working on a charity donation matching site where the  basic model started as my company matching money that other  people donate (so bids are doubled) -- now I've started  putting more complicated matching-bids in, such as "if you  hit 200 pounds, I'll donate 10", and phrased these in  haskell...
02:50:47 <ceii> OODavo, you forgot to re-wrap the a into an Item after initItem
02:50:57 <chairdog> one feature i'd liek to do (seeing as I expect to  be aiming this at my geek friends) is let people submit their  own bids as expressively as I can make templates, rather than  havign to use one of the template bids I've made
02:51:01 <chairdog> so submit  bids as a Haskell function, just like I do. but on the  website. I could gut out lambdabot for that, right?
02:51:04 <chairdog> merijn: there
02:51:15 <ceii> you want initItem (Run a) = Run <$> initItem a
02:51:27 <OODavo> ceii: Whoops. So I do. Thank you.
02:52:08 <dcoutts> chairdog: any details on the failure?
02:52:54 <chairdog> dcoutts: http://pastebin.com/1gKC6wGu
02:52:57 <mauke> The paste 1gKC6wGu has been copied to http://hpaste.org/57368
02:57:09 <Philippa> I'm guessing I'm not alone in wishing that it was normal to provide liftIOed versions of IO operations as the default and use the awkward name for the IO-only version?
02:57:27 <quicksilver> you're Philippa
02:57:32 <quicksilver> !
02:57:38 <quicksilver> "you're not, Philippa"
02:57:54 <ceii> the usual noobs-will-be-confused argument applies
02:57:54 <quicksilver> although of course it's not that simple when there are callbacks or brackets.
02:58:06 <ceii> even moreso since this is about the scary IO monad
02:58:30 <Philippa> ceii: that's why you keep the fugly versions available :-)
02:58:42 <Philippa> then if you want nice names, import IO.noob
02:58:43 <irene-knapp> yeah, I much agree that it ought to be the norm
02:58:49 <ceii> Philippa: I didn't say I disagreed :.)
02:59:12 <Philippa> quicksilver: hmm, got an example of a way to shoot yourself in the foot with callbacks or brackets?
02:59:52 <Philippa> (I tend towards separating IO and other code fairly vigorously even if my other code's heavily monad-laden, and it's been a while since I wrote any non-trivial IO too)
03:00:34 <ceii> Philippa: to turn try :: IO a -> IO (Either IOError a) into m a -> m (Either IOError a) you need more than liftIO
03:00:35 <irene-knapp> shoot :: (MonadIO m) => m Target -> m (Hole, Blood)
03:01:27 <ceii> and we're not quite sure how to so this, see http://blog.ezyang.com/2012/01/monadbasecontrol-is-unsound/
03:02:46 <ceii> basically, liftIO only works if your IO a value is in covariant position
03:04:39 <ceii> woohoo kernel freeze
03:04:47 <ceii> my uptime is sad
03:05:07 <Philippa> ah well. I'm intentionally using a piece of IO in an instrumentation example to make things more difficult :-)
03:05:15 <Philippa> (it's only text output, but that's not the point)
03:05:21 <ceii> did I miss anything in the last 45 seconds?
03:06:07 <frerich2> I always have to think of him when Till Adam is around :)
03:06:13 <frerich2> sorry, wrong channel
03:06:34 * frerich2 types 'Alt+Tab, Cursor Up, Return' too fast.
03:12:51 <Philippa> how does everyone feel about implementing a configuration type that's tied to a Reader-like monad, where the 'field' accessors all wrap calls to ask?
03:13:23 <Philippa> (you'd need an updateable view of the same type as well, of course)
03:14:18 <ceii> Philippa, basically the standard way of querying the config would be runQuery :: Config -> QueryMonad a -> a?
03:14:19 <Philippa> the intention's to encourage using an applicative style with functions that care about config details
03:15:16 <ceii> I'm not so sure about making this the preferred interface, but it's a nice additional API to have
03:15:57 <Philippa> sort of. You'd have a monad transformer rather than just a monad in practice, so you might have main = join $ runQuery <$> getConfig <*> pure realMain
03:16:25 <Philippa> (I forget whether the fixity and precedence for <$> plays nice with using it in place of a <*> for a pure value)
03:17:10 <ceii> the fixities of <$> and <*> are chosen so f <$> m1 <*> m2 <*> m3 works
03:17:27 <Philippa> the idea is that most code should never have to care about the details of the config, and pure code should never have to care that there /is/ a config as opposed to some values it needs that might happen to've come from one
03:17:51 <Philippa> sure. Not what I asked: does f <$> m1 <$> pure1 <*> m2 work?
03:17:57 * hackagebot http-conduit 1.2.3 - HTTP client package with conduit interface and HTTPS support.  http://hackage.haskell.org/package/http-conduit-1.2.3 (MichaelSnoyman)
03:18:15 <ceii> it doesn't work, just look at the types
03:18:56 <Philippa> oh, yeah, it expects specifically a function
03:19:01 <ceii> going back to the interface, it's something clients often end un implementing on their own so why not provide it directly
03:19:20 <Philippa> so it's a different operator I want, fair enough
03:19:27 <ceii> but you definitely want to give a view of the config as a simple record pattern
03:19:37 <Philippa> no, I definitely don't!
03:19:55 <Philippa> if Haskell's record system wasn't a POS, that'd be different :-)
03:20:30 <ceii> s/record/ADT with a bunch of lenses/ then
03:21:12 <ceii> the point is, if your clients want to use a different access pattern (maybe build a custom fused monad or whatever) it's easier for them that way
03:21:31 <Philippa> right. Even then, I may well not want to: what if I want to version the config?
03:22:23 <ceii> just expose your implementation details with whatever warnings apply then
03:22:57 * hackagebot terminal-progress-bar 0.0.1 - A simple progress bar in the terminal  http://hackage.haskell.org/package/terminal-progress-bar-0.0.1 (RoelVanDijk)
03:23:46 <Philippa> eh, I know where Python is if I want it
03:24:25 <ceii> code that apills its innards everywhere is code you never need to rip open :)
03:24:31 <ceii> spills*
03:26:12 <Philippa> yeah, but it's potentially also code where you find the team idiot (possibly yourself having a bad day) has shat all over your program's guts causing myriad subtle and hard-to-trace bugs. Approaches vary: Haskell's capable of striking balances on that front that other languages can't, it's one of the things I like about it
03:26:34 <elliott> So does anything work with GHC 7.4 yet?
03:26:55 <Philippa> I hear Hello World works great!
03:27:03 <elliott> Woot!
03:27:08 <elliott> Does cabal-install require even more patching than 7.2?
03:27:16 <funktronic> Philippa: "code review"
03:28:46 <elliott> I suppose I should just try it and find out.
03:28:52 <elliott> You know... for fun.
03:29:08 <Philippa_> re
03:30:20 <Philippa_> funktronic: practices vary. It's not appropriate for someone to insist in here that they have a One True Way /after/ someone's given a reasonable motivating example for doing otherwise, rather than commenting on how they go about it instead.
03:32:57 * hackagebot hastache 0.3.3 - Haskell implementation of Mustache templates  http://hackage.haskell.org/package/hastache-0.3.3 (SergeyLymar)
03:33:19 <chairdog> is ghc linking stage much slower than it used to be a few years ago? maybe its because i'm linking in more libraries
03:33:55 <Philippa> yeah, I know I'm pushing the linker harder than I used to
03:33:56 <elliott> chairdog: try gold
03:34:22 <chairdog> elliott: url?
03:35:12 <elliott> chairdog: dunno, it's in binutils though
03:35:19 <elliott> iirc if you install ld-gold or something on debian/ubuntu it replaces your ld
03:35:25 <elliott> but otherwise is avaialble as ld.gold
03:35:44 <elliott> -pgml ld.gold should work I suppose
03:36:01 <keep_learning> Did any one here install dph for GHC-7.4.1 ?
03:37:27 <ceii> keep_learning: install dph? doesn't it come out of the box with ghc?
03:38:33 <keep_learning> ceii, No
03:39:56 <elliott> Yes it does.
03:40:03 <elliott> I... think?
03:40:14 <elliott> Oh, so it doesn't.
03:40:42 <keep_learning> There is one folder named "make"
03:41:14 <keep_learning> and when i am running make Makefile then
03:41:23 <keep_learning> its showing error ?
03:41:55 <keep_learning> Any idea how to install it for GHC-7.4.1
03:42:39 <keep_learning> http://hpaste.org/57371
03:44:20 <SirFrancisDrake> is there a way to make a global mutable TVar?
03:44:22 <SirFrancisDrake> http://hpaste.org/57372
03:44:41 <elliott> SirFrancisDrake: You need to use unsafePerformIO.
03:44:55 <elliott> You should preferably restructure your code to not need a global variable.
03:45:08 <elliott> If you really must, you should probably use http://hackage.haskell.org/package/safe-globals to declare it.
03:45:30 <ceii> but if you're just doing a quick dirty job, unsafePerformIO works fine
03:45:52 <SirFrancisDrake> I am writing a game and I need to keep lots of mutable data somewhere. I can make a local variable and pass it around every time I want to change something, but that feels worse than having a global variable
03:46:30 <SirFrancisDrake> for instance, because refactoring would take ages
03:47:54 <donri> SirFrancisDrake: why not Reader?
03:48:10 <donri> or State, uh, because you need mutability
03:48:46 <SirFrancisDrake> donri: mutability and availibility to multiple threads
03:49:02 <SirFrancisDrake> elliott: thanks for the Data.Globals link, I'll check it out
03:49:13 <donri> State monad and TVar?
03:49:13 <Jafet> Then you can't use unsafePerformIO.
03:49:31 <ceii> SirFrancisDrake: donri means using reader to pass your TVar around, instead of passing it manually
03:49:36 <Jafet> (For the same reason you can't do the same thing if you were using nearly any other programming language.)
03:49:44 <elliott> SirFrancisDrake: No, you don't want a global variable there.
03:49:51 <ceii> or more likely ReaderT on top ofIO
03:49:57 <donri> yea i guess if you pass around a mutable variable, reader suffices
03:50:16 <elliott> You want a global variable only in very specific cases (many of which involve interfacing with external libraries); not because you're writing a stateful game.
03:50:20 <Jafet> Oh, he wants unsafePerformIO newTVarIO.
03:51:10 <elliott> SirFrancisDrake: ReaderT (TVar ...) IO is what you probably want to be using.
03:51:20 <elliott> (Except you'll actually want to have multiple TVars, likely in a record, but anyway.)
03:52:17 <Jafet> data Gamestate =
03:52:20 <SirFrancisDrake> multiple TVars outside of a record, but why not put them together, actually
03:53:04 <neutrino> hi
03:53:26 <neutrino> is there a quick way to find all the packages that my program depends on?
03:53:39 <donri> cabal info?
03:53:41 <neutrino> i have this single script (which i execute with runhaskell)
03:53:46 <neutrino> no it's not in cabal
03:53:48 <neutrino> i wrote it myself
03:54:05 <donri> you should write an accompanying .cabal specification
03:54:21 <neutrino> that's... not really helping anything.
03:54:28 <neutrino> oh i have all the import in one place, is there a way to find the package name based on the module name?
03:55:34 <Jafet> Your library documentation index.
03:55:35 <donri> perhaps if you compile it properly, ghc will tell you which packages it loads
03:55:59 <neutrino> oh let me try
03:56:14 <donri> in "make" mode which is default in recent versions, otherwise ghc --make
03:57:49 <Jafet> Well, that still isn't something you can lift into your cabal file
03:57:53 <elliott> neutrino: You could try ghc -c or something.
03:58:00 <elliott> It'll error out about packages tons.
03:58:04 <elliott> Then you can use that info to make a .cabal file.
03:58:31 <Taneb> Hello
03:58:41 <Jafet> It's useless for everyone else if your cabal file has a precise minor minor diminutive version for everything
04:00:02 <neutrino> ghc -c doesn't error out, just says "compilation isn't required"
04:00:11 <neutrino> if you meant ghc -v, i'm reading through that now
04:00:36 <ceii> neutrino, remove your .o files
04:01:09 <neutrino> removing .o files just makes it compile without saying anything
04:02:03 <elliott> So has anyone been brave enough to try and get cabal-install working with 7.4 yet?
04:02:59 * hackagebot xhtml 3000.2.0.5 - An XHTML combinator library  http://hackage.haskell.org/package/xhtml-3000.2.0.5 (ChrisDornan)
04:03:03 <gienah> elliott: have you tried it recently?
04:03:35 <elliott> gienah: Tried what? 7.4 technically just came out.
04:03:50 <kosmikus> elliott: the darcs version should build with 7.4
04:04:04 <elliott> kosmikus: great, thanks
04:04:27 <elliott> it's just every other package i have to worry about then :)
04:05:41 <gienah> elliott: nevermind seems you mean a different cabal-install problem
04:08:01 <neutrino> if i have the module name, is it possible to find out what package it came in?
04:08:17 <elliott> sure, import it in ghci and see what packages it loads :p
04:08:40 <ceii> neutrino: ghc-pkg find-module My.Module
04:11:23 <Taneb> brb
04:12:03 <Taneb> Back
04:13:41 <neutrino> ceii: amazing! thanks. i keep forgetting ghc-pkg exists, i always keep thinking it's all cabal. hmm
04:14:17 <ceii> neutrino, as for finding all the packages required by a module I still haven't found anything
04:14:55 <ceii> ghc -hide-all-packages only mentions the first required package before giving up :(
04:15:48 <ceii> I really wish there was a tool to generate a stub cabal file from a list of modules
04:17:08 <neutrino> ceii: i've just grepped for "import", sed'ed some things away, and i got a list of all packages being imported
04:17:08 <dcoutts> ceii: byorgey has been working on that for "cabal init"
04:17:11 <neutrino> i can use that
04:17:39 <ceii> dcoutts: cool, tell him he rocks if you see him :)
04:17:49 <Lemmih> dcoutts: What's the story with 'cabal repl'?
04:17:58 <dcoutts> ceii: I do, every time I see him (which sadly is infrequent)
04:17:59 * hackagebot histogram-fill 0.6.0.1 - Library for histograms creation.  http://hackage.haskell.org/package/histogram-fill-0.6.0.1 (AlexeyKhudyakov)
04:18:01 * hackagebot OpenAFP 1.3.1 - IBM AFP document format parser and generator  http://hackage.haskell.org/package/OpenAFP-1.3.1 (AudreyTang)
04:18:24 <dcoutts> Lemmih: patches still sitting in my review queue
04:18:41 <dcoutts> Lemmih: if you've got time to work on them let me know :-)
04:19:33 <dcoutts> Lemmih: in more detail, the storey is they're not suitable to apply as-is, but with a bit of work it'll be fine
04:20:16 <dcoutts> so it's not a wasted GSoC as some people have suggested, but it does need some changes before we can merge
04:20:19 <shachaf> Does cabal-install work with GHC 7.4?
04:20:28 <elliott> shachaf: the darcs version, apparently
04:21:10 <kosmikus> shachaf: existing compiled cabal-install versions of course also continue working with GHC 7.4
04:21:52 <Lemmih> dcoutts: Good to know.
04:22:32 <rostayob> yeeeeeaahh GHC 7.4 is out.
04:24:13 <elliott> kosmikus: Is it the HEAD branch or the "stable 1.10 branch" that I should be usng?
04:24:22 <kosmikus> elliott: HEAD branch
04:25:12 <elliott> kosmikus: thanks
04:28:16 <prof7bit> doesn't the word "HEAD" just mean the *end* of a branch (any branch)? (git terminology is still confusing me)
04:28:53 <elliott> It means the same thing as it does in git, I think.
04:29:24 <Igloo> Our use of the word "HEAD" predates git, and I think means something different
04:29:31 <prof7bit> git is known for giving commonly known words completely different meanings
04:29:32 <Igloo> Probably "master"
04:32:25 <lispy> If you've uploaded 2.4.1.0 to hackage, is it possible to upload 2.2.3.1 to package if it' doesn't already exist?  (that is, does it check for unique version number or unique and increasing?)
04:37:59 * hackagebot pugs-DrIFT 2.2.3.20120203 - DrIFT with pugs-specific rules.  http://hackage.haskell.org/package/pugs-DrIFT-2.2.3.20120203 (AudreyTang)
04:43:30 <owst> Igloo, prof7bit: "HEAD" means "the currently checked-out branch tip" in Git, whereas "master" is "the current tip of the master branch (which may not be checked out)". GHC HEAD seems to correspond to origin/master (i.e. the tip of the remote authoritative repo), as Igloo says.
04:44:17 <owst> Where "origin" is just a name for the remote-repo that you cloned your repo from
04:48:00 * hackagebot pugs-compat 0.0.6.20120203 - Portable Haskell/POSIX layer for Pugs  http://hackage.haskell.org/package/pugs-compat-0.0.6.20120203 (AudreyTang)
04:57:45 <Botje_> huh, pugs is being developed again?
04:58:01 * hackagebot Pugs 6.2.13.20120203 - A Perl 6 Implementation  http://hackage.haskell.org/package/Pugs-6.2.13.20120203 (AudreyTang)
04:59:40 <elliott> Botje_: has been for a while, I think
05:04:21 <Botje_> oh, okay
05:04:26 <lispy> Botje_: someone has to update the reference impl when the spec changes? :)
05:05:15 <elliott> lispy: Pugs is a reference implementation now?
05:05:19 <lispy> If the people who wanted type directed name resolution were programming instead of debating it, I bet they'd be more productive...
05:05:21 <Botje_> I thought pugs wasn't feature-complete, so i didn't quite see the point in updating :)
05:05:42 <lispy> elliott: IIRC it was ready long before anything from Larry
05:05:54 <lispy> elliott: I don't know if it's complete or correct though
05:05:56 <elliott> I was under the impression that Rakudo is the reference implementation.
05:08:27 <lispy> according to wikipedia: Pugs development is now placed on hiatus,[1] with most Perl 6 implementation efforts now taking place on Rakudo; however, its source repository is still used for storing the official Perl 6 test suite.
05:10:35 <hpc> lispy: *twitch*
05:11:06 <lispy> twitch?
05:13:18 <neutrino> i wish pugs were usable as a haskell lib
05:13:24 <neutrino> so that you could call perl code from haskell
05:13:30 <neutrino> and possibly vice versa
05:13:50 <lispy> neutrino: it's usually pretty trivial to add a library stanza to a .cabal file.
05:14:01 <lispy> neutrino: Dunno if pugs uses cabal though.
05:14:21 <elliott> considering it's on hackage...
05:14:44 <lispy> Oh right.  I forgot why we were talking about it :)
05:15:31 <lispy> it would take a bit of work and it doesn't use build type simple
05:16:02 <lispy> That said, it should still be do able in < 1 hour
05:19:05 <lispy> are there any plans to bring back the hackage website?  (like trac) http://hackage.haskell.org/trac/hackage/wiki/HackageDB
05:19:15 <lispy> It's been done for quite some time
05:19:37 <elliott> (is it just me, or is the haskell infrastructure slowly falling apart?)
05:19:59 <lispy> It was actually doing quite well for a time
05:20:27 <lispy> The issue with the hackage trac is that someone spammed hundreds of bug tickets
05:20:37 <lispy> So then someone else decided to just turn it off entirely
05:20:46 <Ptival> "Lastly, ingy and Mäsak have plans afoot to revive Pugs, the original Perl 6 implementation in Haskell. So far they’ve just got it building again on current Haskell compilers, but the long-term goal is to get it running on the spec tests again and bring it closer to the current spec."
05:20:58 <lispy> Prehaps we need a third person to turn it back on :)
05:21:26 <hpc> neutrino: what would be really neat is a perl FFI
05:21:38 <elliott> How many haskellers does it take to turn on a lightbulb :)
05:21:47 <lispy> elliott: > 0
05:21:56 <elliott> (one to produce an exact replica of the lightbulb except turned on, another to destroy the original lightbulb as it's no longer in use.)
05:22:03 <Botje_> elliott: they already have, you just need to evaluate the thunk.
05:22:36 <lispy> First we must agree on the denotational semantics
05:22:39 <Ptival> do they even *need* the light on?
05:28:03 * hackagebot hjsmin 0.0.15 - Haskell implementation of a javascript minifier  http://hackage.haskell.org/package/hjsmin-0.0.15 (AlanZimmerman)
05:28:21 <lispy> Someone should write a Haskell minifier
05:28:43 <neutrino> haha
05:28:44 <ben> In javascript?
05:28:47 <neutrino> hahahahaha
05:29:07 <donri> yea so we can minify the haskell we write for uhc js
05:29:37 <lispy> donri: bah, you just had to go and make it sound reasonable
05:29:40 <lispy> ;)
05:29:46 <ceii> well, what about compile to js through uhc, minify, reverse compile to haskell?
05:29:49 <donri> O:)
05:30:06 <donri> ceii: ah, that might work!
05:31:09 <elliott> How many hours does GHC take to build these days?
05:31:36 <ceii> 7 on my netbook, which isn't a very interesting reference
05:31:59 <donri> y u no use binary releases
05:32:46 <elliott> donri: because they don't work with my distro (wontfix)
05:33:08 <elliott> and since the reason is debian stable, they will probably continue to not work for the next five years
05:35:22 <donri> y u no run fedora ^W [my currently preferred distro]
05:35:37 <Philippa> ceii: eh, that'd be interesting to compare to building on some of the ARM systems you can get now
05:35:58 <Philippa> (I'm contemplating picking up something like a raspi and having a go at getting ghci working)
05:36:32 <elliott> donri: Does Fedora still use GMP 4?
05:36:39 <elliott> That would surprise me, since IIRC even Debian testing doesn't.
05:37:06 <elliott> The only difference between the majority of the distros and mine is that I think the majority of distros still have a GMP 4 package lying around for compatibility.
05:37:23 <donri> Version     : 4.3.2
05:37:28 <ceii> elliott: can't you build one for Debian?
05:37:45 <ceii> or just put GMP-4 in /usr/local like a savage
05:38:29 <rostayob> elliott: no seriously, debian stable?
05:39:06 <elliott> rostayob: No seriously what?
05:39:15 <acowley> I'm going to go ahead and word this question stupidly: why does a comonad look like an F-algebra, and a monad look like an F-coalgebra? Specifically, why are the co's flipped?
05:39:35 <elliott> ceii: Build one what for Debian? I don't use Debian. I could install GMP 4, but building a GHC sounds like less work; GMP isn't exactly quick to build either.
05:39:36 <rostayob> elliott: isn't it overly frustrating to run debian stable on a desktop?
05:39:46 <elliott> rostayob: Who said I use Debian stable?
05:39:52 <donri> https://community.dev.fedoraproject.org/packages/gmp 5.0.2 in rawhide (aka upcoming version)
05:40:01 <ceii> elliott: but you can build your compatibility libgmp.so.3 once and be done with it
05:40:06 <rostayob> elliott: "and since the reason is debian stable..."
05:40:42 <elliott> rostayob: The reason the binaries are broken is Debian stable; i.e. the binaries are built on Debian stable, and that is why they don't work.
05:40:50 <ceii> oh
05:41:16 <rostayob> elliott: oh, I deduced you used debian stable
05:41:43 <elliott> ceii: Yeah, I could. I probably will, since this machine is pretty slow, but I was asking in case GHC got faster to build recently...
05:42:13 <ceii> I've never seen a program get faster to build as it matures :-)
05:42:18 <donri> oh, i too thought you meant you're on debian stable
05:43:10 <donri> no, you're one of them arch linux hipsters aren't you
05:43:19 <ceii> arch has gmp4 in AUR
05:43:27 <elliott> donri: Maybe :) In fairness, I don't like it!
05:43:32 <elliott> ceii: Yeah, but that's still going to take ages to build.
05:43:39 <donri> he said jokingly, recalling elliott being surprisingly non-hipstery about it
05:43:43 <ceii> I just built it in 15 minutes
05:43:47 <ceii> ...on my netbook
05:43:51 <elliott> Hmm, maybe it's GMP 5 that takes ages then.
05:44:04 <elliott> Oh well, I guess I'll give it a go.
05:44:47 <acowley> ceii: Sometimes a package gets so big it gets turned into a meta-package with no source of its own. Its compilation time grows and grows until it collapses in on itself ejecting all that compilation time into a solar system of smaller packages.
05:44:54 <acowley> The Cosmology of Code
05:45:20 <byorgey> this happened to category-extras, for example
05:45:35 <elliott> acowley: What if every single piece of code in the world is just a component split out from the Great Ur-Package?
05:45:42 <elliott> In some kind of... big... bang.
05:46:07 <acowley> elliot: I believe category-extras was an attempt at nesting another universe within our own
05:46:11 <byorgey> the Great Ur-Package was an interpreter for the untyped lambda calculus
05:46:17 <elliott> acowley: haha
05:46:21 <ceii> so is there enough energy in the software world for it to keep expanding indefinitely?
05:46:30 <elliott> it's the LHC, trying to recreate the conditions of the package big bang
05:46:30 <acowley> easily
05:46:35 <ceii> or will it all collapse back to nothingness in a few decades?
05:46:51 <acowley> this is true open source physics
05:47:00 <byorgey> ceii: people used to think it would all collapse, but it seems to keep expanding nonetheless.
05:47:17 <elliott> ceii: Eventually someone will install an emulator of every known OS on a gigantic supercomputer and run an automated process to find out and install all software it can find on it.
05:47:19 <byorgey> this has been posited to be due to the existence of undetectable "dark programmers"
05:47:20 <cmccann> byorgey, whether the universe is strongly normalizing is an open question, yes
05:47:28 <mike-burns> It collapsed in early 2000.
05:47:35 <elliott> Everyone will keep turning off their servers, because you can just buy time on the supercomputer instead, in the Cloud.
05:47:50 <byorgey> cmccann: hehe
05:47:57 <elliott> Then the last computer will go off, and the supercomputer will be unable to handle the last bit of load, and it'll expllode.
05:48:01 <elliott> Scientific fact.
05:48:22 <cmccann> elliott, makes perfect sense.
05:48:28 <acowley> elliot: so stay away from Amazon's data centers in the future?
05:48:32 <ceii> except for retrograde hippies who'll still be clinging to outdated notion of "controlling where the damn stuff is"
05:48:57 <elliott> acowley: I'm not permitted to answer that question.
05:49:02 <elliott> You saw nothing.
05:49:47 <acowley> I wonder if programming language trolls correspond to dark matter… you can't necessarily identify one by looking at him/her, but you can see the "lensing" effect they have on a community.
05:50:06 <ceii> I'm pretty sure you can usually identify them
05:50:28 <elliott> acowley: They're more like gigantic fireballs of idiocy, IME.
05:50:33 <ceii> if only by putting them in contact with normal programmers and watchning the fireworks
05:50:35 <cmccann> trolls are more like black holes, in that they eventually go away if you stop feeding them
05:50:45 <ceii> which does make them a bit like dark matter
05:50:47 <elliott> Although, I suppose that's what you'd say if there were trolls so good you just aren't noticing them.
05:50:51 <elliott> Maybe dons?
05:50:58 <acowley> hahaha
05:51:07 <elliott> I need to get my tinfoil hat.
05:52:03 <Philippa> trolling for productivity?
05:52:09 <cmccann> dons would be more of a meta-troll, since back when he was really active his mere existence seemed to provoke the anti-Haskell trolls
05:52:25 <elliott> cmccann: those were just his alternate nicks
05:52:40 * elliott looks shiftily
05:53:08 <ceii> creating all the hype around haskell by leading both the advocates and the haters
05:53:10 <ceii> sweet
05:53:12 <neutrino> how did dons provoke anti-haskell trolls
05:53:38 <elliott> Have dons and spj ever been seen in the same room together?
05:53:48 <elliott> For that matter, have the Committee?
05:53:49 <cmccann> neutrino, by talking positively about haskell a lot, in lots of places, and being too damn productive for anyone to just dismiss as a poser
05:54:08 <neutrino> doesn't sound like attracting hate to me
05:54:31 <byorgey> elliott: dons and spj have definitely been in the same room together.
05:54:33 <elliott> neutrino: you clearly weren't around at the time :)
05:54:40 <ceii> there's a big share of the commitee in that WG 2.8 photo that keeps being reused everywhere
05:54:45 <elliott> byorgey: Are you sure it wasn't a hologram?
05:54:48 <neutrino> i was, dons was very helpful to me in learning the basics
05:54:48 <byorgey> elliott: no idea whether they have had a conversation.
05:54:53 <byorgey> elliott: haha, well, no!
05:55:01 <ceii> on the other hand, the fact that this is the only photo everyone uses is pretty suspicious
05:55:15 <elliott> neutrino: every time dons posted something about haskell in /r/programming for example, there'd be a billion trolls coming out of the woodwork to complain about it
05:55:26 <neutrino> haters gonna hate
05:55:31 <acowley> ceii: Photoshop contractors are expensive
05:55:33 <cmccann> neutrino, part of it is that dons had a habit of appearing out of nowhere to shoot down misgudied criticisms of haskell
05:55:44 <cmccann> I think he had some google alerts or whatever set up
05:55:53 <acowley> the legend of donsbot
05:56:30 <cmccann> making a blog post saying "haskell is slow" was pretty guaranteed to summon him within 12 hours :P
05:56:51 <neutrino> cmccann: man i still miss him being there
05:56:55 <neutrino> what happened to dons?
05:56:59 <cmccann> new job, I think
05:57:02 <elliott> hmm, profiling/dynamic libraries are the default these days, right?
05:57:05 <elliott> when building ghc
05:57:06 <neutrino> doing what now
05:57:06 <cmccann> and much less free time for community activity
05:57:16 <neutrino> he cannot be replaced
05:57:19 <neutrino> he is worth every money
05:57:32 <acowley> neutrino: a bank came to the same conclusion
05:57:36 <ceii> assuming he _was_ a bot
05:57:37 <elliott> haha
05:57:46 <ceii> we could bid for the source code as a community
05:58:12 <acowley> we'd just end up bickering over its use of record syntax
05:58:40 <ceii> and no one would bother to update him for the new version of ghc
05:58:42 <neutrino> what is record syntax?
05:58:44 <cmccann> anyway, dons is at Standard Chartered now, I think?
05:58:44 <ceii> sad, sad future
05:58:53 <elliott> neutrino: you don't want to know!
05:58:53 <acowley> and if it uses exceptions at all, the cafe would have to shutdown from overheating
05:58:53 <byorgey> cmccann: yep
05:59:10 <elliott> acowley: I bet it uses top-level globals.
05:59:11 <cmccann> as is augustss if memory serves me
05:59:13 <byorgey> neutrino: like  data Foo = Foo { field1 :: Int, field2 :: Char }
05:59:26 <byorgey> neutrino: instead of just   data Foo = Foo Int Char
05:59:52 <neutrino> i use that for "defaults"
05:59:53 <byorgey> cmccann: yes, I think so
06:00:40 <acowley> neutrino: It lets us write code poems like, foo s x = s{x=x}
06:01:20 <acowley> elliott: In a stunning development it will turn out to be written in Java.
06:01:32 <neutrino> like i'll do this http://hpaste.org/57378
06:01:58 <ceii> I get so sad every time a Java or C# team wins the ICFP contest
06:02:08 <byorgey> neutrino: yep, that's one nice use of them
06:02:09 <neutrino> oww.
06:02:22 <neutrino> byorgey: yeah it was a bit difficult to figure out the right way to use cmdlib
06:02:30 <elliott> acowley: With LambdaVM!
06:02:35 <erus`_> shit i left my pc on
06:02:45 <neutrino> i STILL hadn't figured out if it's possible to have a parameter in cmdlib be Maybe a
06:02:55 <neutrino> the types say it should be possible
06:03:00 <neutrino> but if i try it i get some sort of errors
06:06:42 <nomemory> what's the synta
06:06:43 <nomemory> hi
06:06:54 <nomemory> what's the syntax of adding a type signature in a lambda expression ?
06:07:08 <nomemory> eg.: filterCond = (\x -> (length $ group $ sort x) == 4)
06:07:14 <nomemory> x should be Ord
06:07:27 <shachaf> filterCond :: Ord a => a -> ...
06:08:01 <nomemory> shachaf: inside the lambda ?
06:08:17 <shachaf> No, for the whole function.
06:08:19 <nomemory> or is impossible, and i shoudl declare a new function
06:08:23 <aluink> :t Entries
06:08:24 <lambdabot> Not in scope: data constructor `Entries'
06:08:31 <nomemory> oh, let me show the function
06:08:33 <shachaf> You don't need to give it a name to give it a signature.
06:08:36 <aluink> :t Codec.Archive.Tar.Entry.Entries
06:08:37 <lambdabot> Couldn't find qualified module.
06:08:50 <shachaf> By the way, don't length . group . sort. length is too strict.
06:08:59 <fryguybob> @type (\x -> x) :: Int -> Int
06:09:00 <lambdabot> Int -> Int
06:10:10 <nomemory> http://hpaste.org/57380 -> this is i want to accomplish
06:10:36 <nomemory> and this is what ghci is complaining:  Ambiguous type variable `a' in the constraint:
06:10:51 <nomemory> `Ord a' arising from a use of `sort'
06:11:27 <shachaf> If all that was necessary was a more specific type, GHC would just infer it for you.
06:11:50 <shachaf> The problem is probably in the place that's calling filterCond.
06:12:09 <elliott> nomemory: You should import Data.Char instead of Char.
06:12:31 <ceii> shachaf: aren't let bindings monomorphic by default in current GHC?
06:12:48 <shachaf> Oh, yes, the monomorphism restriction
06:12:49 <nomemory> so when I'll call filterCond in a certain context
06:12:54 <nomemory> the compire will infere the types ?
06:12:59 <shachaf> nomemory: Try filterCond x = ... instead of filterCond = \x -> ...
06:13:13 <ceii> nomemory: yes
06:13:14 <nomemory> ok
06:13:22 <nomemory> thanks
06:13:25 <nomemory> i will
06:13:45 <elliott> ceii: shachaf: That shouldn't matter.
06:13:52 <ceii> the point is, the particular form of definition you're using can't be polymorphic without an explicit type signature
06:13:54 <elliott> If it wasn't ambiguous, it could be monomorphic just fine.
06:14:03 <elliott> The error is one of ambiguity, not of types not matching.
06:14:25 <ceii> but without additional information the compiler doesn't know which monomorphic type to use
06:14:30 <nomemory> I see
06:14:36 <nomemory> well type inference is a new concept for me
06:14:42 <elliott> ceii: It won't know if you do "filterCond x = ..." either.
06:14:56 <elliott> nomemory: I suggest showing the entire definition, not just the let block.
06:15:23 <nomemory> ok
06:15:26 <ceii> elliott: but in that case it'll infer forall a. Ord a => whatever just fine
06:15:26 <nomemory> let me modify it
06:15:27 <rwbarton> if I replace the {-- comment --} with undefined then I get an ambiguous type error with filterCond = \x -> ... but not with filterCond x = ...
06:15:33 <nomemory> and i'll show you the results
06:16:04 <elliott> ceii: Well, yes, but since it's not being called anywhere, that's of rather academic benefit.
06:16:21 <elliott> Because the full, fixed code will work even with the MR.
06:16:45 <ceii> elliott: yes, of course
06:19:10 <Taneb> My clever plan to install Haskell on this OS has ran into a stumbling block
06:19:25 <Taneb> /usr/bin/install: cannot change permissions of `/usr/local/share/man/man1': No such file or directory
06:19:25 <Taneb> make[1]: *** [install_man] Error 1
06:19:25 <Taneb> make: *** [install] Error 2
06:20:30 <byorgey> Taneb: have you tried creating that directory and trying again?
06:20:44 <byorgey> I've no idea really, it's just worth trying the obvious
06:20:48 <shachaf> λ> :t (\(x :: Ord a => a) -> x)
06:20:48 <shachaf> (\(x :: Ord a => a) -> x) :: forall a. Ord a => (Ord a => a) -> a
06:20:52 <shachaf> That's an interesting type.
06:20:55 <elliott> wat
06:21:22 <byorgey> heh, weird
06:21:50 <elliott> shachaf: It looks like it's trying to make the (Ord a => a) part forall'd, but can't.
06:22:05 <elliott> Like, (x :: Ord a => a) means (x :: forall a. Ord a => a), but it looks like it's discarding the forall for some reason.
06:22:09 <shachaf> λ> :t let foo :: a -> Ord a => a; foo x = x in foo
06:22:09 <shachaf> let foo :: a -> Ord a => a; foo x = x in foo :: forall a. Ord a => a -> a
06:22:15 <byorgey> but you have to turn on Rank2Types to even get it to work at all
06:22:16 <shachaf> I didn't know GHC let you do that.
06:22:28 <cmccann> I guess it wants two copies of the Ord dictionary?
06:22:42 <fryguybob> nomemory: I don't think you want to use `group` (unrelated to the type issues).
06:22:47 <fryguybob> > (group . sort) "1001011"
06:22:48 <lambdabot>   ["000","1111"]
06:23:04 <elliott> byorgey: Ah, that backs up my guess.
06:23:14 <shachaf> byorgey: Is it actually a rank-2 type?
06:25:12 <shachaf> I note that this doesn't work in lambdabot's GHC 6.12.
06:25:48 <Taneb> What's zlib C?
06:25:57 <Taneb> Other than a library
06:26:00 <byorgey> shachaf: it doesn't look like it.
06:26:34 <shachaf> So Ord a => (Ord a => a) -> a is another way of writing (Ord a => a) -> (Ord a => a)
06:26:46 <shachaf> It's probably pretty-printing the latter as the former.
06:27:09 <cmccann> shachaf, yes, foralls and constraints can be reordered like that
06:27:26 <franco00>  I have got a simple question: I am trying to write a simple roguelike in Haskell, just as an exercise. System.Console.ANSI is really handy! But I want to display some little animations too. Is there something similar to a "TIMER" library? Is that the way to go in your opinion?
06:27:27 <cmccann> (=>) works a lot like (->)
06:27:28 <elliott> shachaf: Yes, but the latter still doesn't make any sense.
06:27:53 <shachaf> elliott: Not *any* sense?
06:28:20 <shachaf> > undefined :: forall a. a -> forall b. b
06:28:21 <lambdabot>   Overlapping instances for GHC.Show.Show (a -> b)
06:28:21 <lambdabot>    arising from a use of `...
06:28:32 <shachaf> @ty undefined :: forall a. a -> forall b. b
06:28:33 <lambdabot> forall a b. a -> b
06:28:34 <shachaf> Hmm.
06:28:43 <elliott> shachaf: Well, does it work in a file?
06:28:45 <shachaf> I didn't realize you could actually do that.
06:28:59 <shachaf> elliott: You should try it out and tell me. :-)
06:29:08 <ceii> sooo
06:29:12 <elliott> I'm lazy .
06:29:13 <elliott> *lazy.
06:29:15 <elliott> And compiling GHC.
06:29:17 <byorgey> franco00: try http://hackage.haskell.org/package/clocked , perhaps?
06:29:36 <franco00> thanks byorgey , I will look into it
06:29:36 <shachaf> I knew you would say that, elliott.
06:29:37 <elliott> byorgey: cabal-setup: The pkg-config package QtCore is required but it could not be found.
06:29:44 <elliott> that's an impressive dependency for a timer library.
06:29:53 <ceii> \(x :: Ord a => a) -> x :: Ord a => a -> a is not accepted
06:29:58 <byorgey> hah
06:30:05 <shachaf> ceii: Right, it's a different type.
06:30:11 <ceii> \(x :: Ord a => a) -> x :: Ord a => (forall a. Ord a=> a) -> a is not accepted either
06:30:26 <shachaf> Right. That's a completely different type.
06:30:32 <ceii> what the hell is this type then?
06:30:49 <elliott> ceii: It's (Ord a) => ((Ord a) => a) -> a.
06:30:50 <shachaf> It takes the dictionary twice, I guess, like cmccann said.
06:30:52 <elliott> Which is (Ord a) => a -> a.
06:31:17 <elliott> shachaf: I'm not so sure.
06:31:29 <elliott> shachaf: Desugaring (c => t) as (Dict c -> t), we get Dict (Ord a) -> (Dict (Ord a) -> a) -> a.
06:31:30 <ceii> elliott: except this type is not accepted
06:31:35 <elliott> Which is just *weird*, and doesn't make any sense.
06:32:37 <nomemory> done guys http://hpaste.org/57382
06:32:40 <nomemory> thanks for the help
06:32:48 <shachaf> λ> :t (\(x :: Ord a => a) -> ())
06:32:49 <shachaf> (\(x :: Ord a => a) -> ()) :: forall a. (Ord a => a) -> ()
06:33:04 <ceii> it makes sense in view of the dictionary translation, but it makes absolutely no sense in the predicate-on-types interpretation of classes
06:33:31 <ceii> I call leaking implementation details
06:33:37 <cmccann> btw, replacing Ord with Num and giving it a polymorphic value doesn't work
06:33:51 <cmccann> as far as I could tell
06:33:57 <shachaf> I guesλ> :t (\(x :: Ord a => a) -> compare x x)
06:33:57 <shachaf> (\(x :: Ord a => a) -> compare x x) :: forall a. Ord a => (Ord a => a) -> Ordering
06:34:04 <cmccann> (you could do this with undefined and Ord anyhow, but still)
06:34:14 <shachaf> s/I gues//
06:34:20 <shachaf> That's a funny type.
06:34:29 <fryguybob> > filter (== '1') "1001011" -- nomemory
06:34:30 <lambdabot>   "1111"
06:34:35 <shachaf> (Ord a => a) -> Ord a => Ordering
06:34:52 <nomemory> fryguybob: that's elegant
06:34:53 <nomemory> thanks
06:36:24 <cmccann> hm
06:36:51 <cmccann> I get different results if I give the mystery lambda a name, btw
06:36:57 <elliott> ceii: No, it doesn't make sense with the dictionary translation.
06:37:06 <shachaf> Yes, I just poitned out the same thing in another channel.
06:37:15 <shachaf> Or did I?
06:37:28 <quicksilver> the dictionary interpretation has no bearing on whether or not higher-rank constraints make sense.
06:37:41 <shachaf> No, I was just wrong.
06:37:58 <shachaf> quicksilver: Are there higher-rank constraints involved here?
06:38:02 <Dennis___> Can somebody explain to me what a GHC error message like " Couldn't match expected type `Network.Wai.Request'with actual type `wai-0.4.3:Network.Wai.Request' " indicates?
06:38:19 <cmccann> in particular, eta reduction also changes the type I get, e.g. "foo y = (mystery lambda) y" and "foo = (mystery lambda)" seem to differ, even with the MR turned off
06:38:33 <matthiasgorgens1> Dennis___: You probably mixed up the types somewhere.
06:38:40 <Philippa> ceii: say hello to curry-howard - predicates want proving
06:38:40 <byorgey> Dennis___: that indicates that for some reason it is getting Network.Wai.Request from two different versions of the 'wai' package
06:38:44 <matthiasgorgens1> Dennis___: How much detail do you want for your explanation?
06:38:50 <elliott> Dennis___: Your packages are broken.
06:39:09 <elliott> matthiasgorgens1: Mixed up a type with the exact same fully-qualified type from a different package?
06:39:14 <byorgey> Dennis___: probably something was compiled against an older version, but now when doing the current compilation it is picking up a newer version.
06:39:16 <Philippa> the fact we call it Dict is a historical accident
06:39:27 <Dennis___> thanks, that helps actually. probably some developer version lying around somewhere
06:39:31 <byorgey> not sure I can give an explanation of exactly why that might happen.
06:39:49 <elliott> Or Dennis___ is using two packages that depend on two different versions of WAI.
06:39:56 <elliott> And importing the "wrong" one.
06:39:57 <fryguybob> > let bits 0 = []; bits n = (n .&. 1):bits (n `div` 2) in filter ((== 4) . sum . bits) [1..40]
06:39:59 <lambdabot>   [15,23,27,29,30,39]
06:40:50 <byorgey> > let bits 0 = []; bits n = (n .&. 1):bits (n `div` 2) in map (length . filter (==1) . bits) [1..100]
06:40:52 <lambdabot>   [1,1,2,1,2,2,3,1,2,2,3,2,3,3,4,1,2,2,3,2,3,3,4,2,3,3,4,3,4,4,5,1,2,2,3,2,3,...
06:41:09 <byorgey> yum fractal
06:42:18 <elliott> cmccann: What result did you get where naming changed the type?
06:43:11 <ceii> let what = (\(x :: Ord a => a) -> x) ; let what y = (\(x :: Ord a => a) -> x) y
06:43:27 <ceii> ghci gives Ord a => (Ord a => a) -> a to what
06:43:33 <ceii> but Ord a => a -> a to what2
06:43:41 <cmccann> elliott: adding an argument collapses the Ord constraints
06:43:50 <cmccann> to just Ord a => a -> a
06:44:19 <shachaf> That's not about naming.
06:44:24 <shachaf> λ> :t (\y -> (\(x :: Ord a => a) -> x) y)
06:44:25 <shachaf> (\y -> (\(x :: Ord a => a) -> x) y) :: forall a. Ord a => a -> a
06:44:36 <elliott> cmccann: Right.
06:44:40 <cmccann> shachaf, yeah, wasn't trying to say it was, that was a bad way to phrase it
06:44:43 <byorgey> > let bits 0 = []; bits n = (n .&. 1):bits (n `div` 2) in zipWith subtract `ap` tail $ map (length . filter (==1) . bits) [1..100]
06:44:45 <lambdabot>   [0,1,-1,1,0,1,-2,1,0,1,-1,1,0,1,-3,1,0,1,-1,1,0,1,-2,1,0,1,-1,1,0,1,-4,1,0,...
06:45:25 <cmccann> hm
06:45:41 <cmccann> actually, hey, are you guys testing this with the MR disabled or not?
06:45:46 <ceii> so, does eta expansion changing the type of a term count as a bug?
06:45:51 <ceii> cmccann, yes
06:45:56 <cmccann> because that does seem to change what happens
06:46:05 <shachaf> Yes, I have it disabled.
06:46:13 <shachaf> But why is the MR relevant here?
06:46:48 <shachaf> Hmm, you can explicitly specialise Ord a => a -> a to the other type.
06:47:15 <shachaf> Which makes sense, I guess.
06:47:20 <ceii> shachaf, I can't here
06:48:00 <shachaf> λ> :t (\y -> (\(x :: Ord a => a) -> x) y)
06:48:00 <shachaf> (\y -> (\(x :: Ord a => a) -> x) y) :: forall a. Ord a => a -> a
06:48:01 <shachaf> λ> :t (\y -> (\(x :: Ord a => a) -> x) y) :: Ord a => (Ord a => a) -> a
06:48:01 <shachaf> (\y -> (\(x :: Ord a => a) -> x) y) :: Ord a => (Ord a => a) -> a :: forall a. Ord a => (Ord a => a) -> a
06:48:06 <shachaf> Oops, wrong channel for that.
06:48:06 <ceii> oh, actually
06:48:24 <ceii> I can give type Ord a => a -> a to the lambda
06:48:29 <ceii> but if I name it first
06:48:49 <cmccann> shachaf, the MR was making GHCi choke on the polymorphism more than I expected, is all
06:48:57 <ceii> s/Ord a => a -> a/Ord a => (Ord a => a) -> a/
06:49:01 <shachaf> Huh.
06:49:26 <elliott> This sounds like a GHC bug to me.
06:49:29 <shachaf> λ> :t id :: Ord a => (Ord a => a) -> a
06:49:31 <cmccann> e.g. wouldn't let me apply the raw lambda to anything
06:49:32 <shachaf> That's invalid.
06:49:44 <shachaf> But the thing I gave above is valid.
06:49:53 <shachaf> Even though specialising id to Ord a => a -> a works fine.
06:50:06 <shachaf> That looks like a bug.
06:50:24 <elliott> Someone gets to edit this IRC log down into a bug report :P
06:50:35 <shachaf> Hmm.
06:50:35 <cmccann> shachaf, ahaha I have a better one
06:50:45 <ceii> shachaf: also, let what = your lambda above ; :t what :: Ord a => (Ord a => a) -> a is invalid
06:51:00 <cmccann> shachaf, try :t id :: (Ord a => a) -> (Ord a => a)
06:51:24 <shachaf> cmccann: Invalid, just like the equivalent type I gave above.
06:51:50 <quicksilver> shachaf: "use of constraints in higher-rank positions"
06:51:55 <quicksilver> shachaf: I was not being very precise
06:52:10 <shachaf> quicksilver: Ah.
06:52:35 <cmccann> shachaf, but look at the error message, it's reordered the constraints
06:52:46 <cmccann> and then complains that it can't match the reordered form
06:53:05 <shachaf> cmccann: Hmm?
06:53:25 <cmccann> if you un-eta-reduce and give an argument with the explicit type (Ord a => a) it works, and gives id with the type Ord a => (Ord a => a) -> a
06:53:51 <shachaf> Oh.
06:54:10 <shachaf> So eta-reducing (\x -> id x) breaks the type specialization.
06:54:17 <cmccann> yes
06:54:25 <cmccann> which is a valid specialization for id, obviously
06:54:29 <shachaf> Right.
06:55:03 <nomemory> Isn't a [Char] actually a String ? Why do I encounter this error ? http://hpaste.org/57383
06:55:30 <shachaf> [Chat] is String, but String is not t -> String
06:56:06 <fryguybob> nomemory: "convert2bin" vs "convert2bin x"
06:56:41 <nomemory> true fryguybob
06:56:46 <nomemory> t -> String
06:56:53 <nomemory> was actually reffering to a function
06:57:01 <nomemory> thnaks
06:58:34 <shachaf> elliott: By the way, id :: a -> Ord a => a doesn't work in GHC 6.12.
06:58:35 <shachaf> So I think this syntax is recentish.
06:58:58 <elliott> shachaf: s/syntax/bug/
06:59:13 <lispy> Hmm
06:59:48 <lispy> What extension allows putting class constraints in that position?  I guess because it's the same as id :: a -> (Ord a => a)...so not that weird.
07:00:02 <kstt> hey
07:00:07 <lispy> Weird when viewed via C-H
07:00:10 <Taneb> Hello
07:00:24 <lispy> "Hey, give me any 'a' and I'll give you a comparable a!"
07:00:33 <shachaf> FlexibleContexts?
07:00:51 <shachaf> lispy: Well, it works in GHC 7.
07:01:04 <lispy> :t id :: a -> (Ord a => a)
07:01:05 <lambdabot>     Occurs check: cannot construct the infinite type: a = (Ord a) => a
07:01:05 <lambdabot>     In the expression: id :: a -> ((Ord a) => a)
07:01:14 <elliott> lispy: It's more like "give me an a and a proof that a is Ord and I'll give you an a".
07:01:14 <ceii> FlexibleContexts doesn't work; Rank2Types does
07:01:15 <shachaf> I don't see why it's so odd. The constraint is still in the contravariant position.
07:01:33 <elliott> shachaf: s/bug/syntax/; I misread.
07:02:33 <ceii> oops, no. FlexibleContexts does work
07:02:51 <kstt> I took a couple of hours today to squash every String in an HappStack public website. We put all the text content as String indexed by constructors. Very handy, very cool, and very safe by the way, except that long string literals can't be easily broken into multiple lines.
07:03:23 <kstt> But, well, back to the point. I eradicated every single string in this app. In favor of Text, lazy variant.
07:03:25 <ketil> Is it possible to run an arbitrary shell command as the test suite with cabal?
07:03:42 <kstt> Result : 25% drop in page rate performance !
07:03:49 <shachaf> In ghc-6.12.3, undefined :: a -> Ord b => b doesn't work without FlexibleContexts.
07:04:08 <elliott> kstt: That doesn't surprise me. Lazy Text probably has more overhead for small strings.
07:04:09 <srhb> kstt: Does a drop in performance equal an increase in time per page?
07:04:27 <elliott> kstt: It's silly to do something like that without profiling.
07:05:16 <kstt> elliott: third response, and the silly word is already here :)
07:05:47 <kstt> srhb: yes, precisely
07:06:37 <shachaf> Anyway, are we concluding that this is definitely a GHC bug?
07:06:38 <elliott> kstt: That's what happens when you do something silly :)
07:06:45 <shachaf> Can someone test it in GHC 7.4?
07:06:51 <elliott> shachaf: I can, in, like, an hour.
07:06:58 <elliott> Maybe less. It's been going for quite a while already.
07:07:36 <ceii> just tested in 7.4, it's still there
07:07:46 <shachaf> ceii: Which thing is still there?
07:07:56 <kstt> elliott: note that when I designed this website, I picked the String for literals, and some people here and there (not you, IIRC) told me "That's silly to use strings in world-facing applications".
07:07:57 <shachaf> Beta-expansion of id issue?
07:08:00 <ceii> yes
07:08:09 <shachaf> OK.
07:08:26 <shachaf> Also the beta-expansion-collapses-constraints thing?
07:08:32 <shachaf> I think those two are the actual bugs.
07:08:36 <ceii> lemme check
07:08:42 <kstt> elliott: and that was the reason that motivated me to rewrite it with Text
07:09:06 <elliott> kstt: I don't think anyone would say using strings full stop is a bad idea.
07:09:09 <cmccann> shachaf, yes, same thing
07:09:11 <kstt> the lazy variant was because HappStack and BlazeHtml seemed to provide more api for it
07:09:15 <elliott> However, using large strings is a bad idea, and you probably don't want to operate with strings over the network.
07:09:25 <elliott> That's not the same thing as replacing every String with a lazy Text :)
07:09:25 <ceii> shachaf, yes, still there as well
07:09:29 <shachaf> OK.
07:09:40 <elliott> Also, Texts are much more flexible as far as encoding goes, which is another reason to use them when dealing with network stuff.
07:10:00 <shachaf> So are those two things weird enough to merit a GHC report?
07:10:16 <elliott> shachaf: Yes.
07:10:23 <ceii> shachaf, I say yes
07:10:31 <elliott> Have fun summarising all the test cases.
07:10:39 <shachaf> What other test cases are there?
07:10:57 <cmccann> shachaf, I'm still not sure if it's a bug but it is kinda weird
07:11:08 <elliott> shachaf: All the ones in here.
07:11:16 <elliott> Everything people went "wtf" in reply to :P
07:11:17 <shachaf> elliott: That matter.
07:11:34 <shachaf> cmccann: You don't think eta-reducing-breaks-type is a bug?
07:11:39 <elliott> shachaf: ?
07:11:58 <cmccann> shachaf, it is if it changes a meaningful type
07:12:02 <shachaf> elliott: Other test cases that matter. There was a lot of redundancy.
07:12:05 <cmccann> I don't think any of the examples we found were sensible to begin with
07:12:16 <ceii> example 1 : id :: (Ord a => a) -> (Ord a -> a) is not accepted
07:12:20 <shachaf> cmccann: Well, the fact that a non-sensible type is inferred, then?
07:12:27 <ceii> example 2 : \x -> id x :: (Ord a => a) -> (Ord a -> a) is accepted
07:12:40 <shachaf> I admit that the fact that (\(x :: Ord a => a) -> x) even means anything is surprising.
07:13:04 <elliott> shachaf: Might as well show all of them.
07:13:04 <ceii> example 3 : (\x -> id x :: (Ord a => a) -> (Ord a -> a)) :: Ord a => a -> a is not accepted
07:13:04 * hackagebot th-expand-syns 0.3.0.1 - Expands type synonyms in Template Haskell ASTs  http://hackage.haskell.org/package/th-expand-syns-0.3.0.1 (DanielSchuessler)
07:13:13 <elliott> Unless you know GHC internals well enough to discern which ones are "equivalent" bugs.
07:13:33 <ceii> example 4 : (\y -> (\x -> id x :: (Ord a => a) -> (Ord a -> a)) y) :: Ord a => a -> a is accepted
07:13:42 <cmccann> I suspect this is all just weird corner cases in how GHC handles constraints vs. actual arguments
07:13:43 <ceii> I think this sums it up
07:13:44 <shachaf> ceii: I don't see why example 3 is wrong.
07:13:53 <cmccann> with the reordering and merging equivalent constraints stuff
07:13:56 <elliott> ceii: "Ord a ->"?
07:14:03 <shachaf> Ord a => (Ord a => a) -> a is a more specific type than Ord a => a -> a
07:14:11 <Saizan> shachaf: i see a (Ord a -> ..)
07:14:11 <elliott> But, um, ceii, that can't possibly work.
07:14:15 <elliott> id x :: (Ord a => a)
07:14:18 <ceii> Ord a -> is just a typo, I was retyping it
07:14:23 <elliott> You're giving the result of the function the type of the function itself.
07:14:33 <elliott> Do you mean (\x -> (id :: (Ord a => a) -> (Ord a => a)) x)?
07:14:34 <shachaf> Saizan: Er, other than that.
07:14:44 <shachaf> Saizan: I don't think the fact that it fails is wrong, if you substitute =>.
07:14:58 * quicksilver recommends alpha-converting to avoid shadowing types
07:15:06 <shachaf> quicksilver: There are no foralls here.
07:15:07 <cmccann> shachaf, not really, it wants two constraints on the same type, if you presume that for any a there's only one Ord dictionary, they're equivalent
07:15:08 <shachaf> No shadowing.
07:15:09 <ceii> example 3 is to contrast with 4
07:15:14 <quicksilver> shachaf: are you sure?
07:15:22 <ceii> it fails, but is accepted if you eta-expand it
07:15:24 <quicksilver> I think every => is a forall
07:15:25 <shachaf> quicksilver: Yes. Adding a forall makes this completely different.
07:15:27 <Saizan> shachaf: also, i don't see why id x should be a function if x isn't
07:15:30 <shachaf> quicksilver: Nope.
07:15:48 <elliott> quicksilver: No.
07:15:50 <shachaf> Saizan: OK, I was commenting on the thing I assumed ceii rather than the thing ceii actually wrote. :-)
07:15:57 <elliott> Consider a -> Ord a => a.
07:16:08 <cmccann> shachaf, it's like (() -> (() -> a) -> a) vs. (() -> a -> a)
07:16:24 <cmccann> constraints are presumed to be unique and something that GHC can conjure up, if they exist at all
07:16:31 <quicksilver> does any GHC extension actually spell out how that is interpreted?
07:16:38 <shachaf> cmccann: Hmm.
07:16:43 <shachaf> quicksilver: It didn't work in GHC 6.12.
07:16:52 <shachaf> quicksilver: So I'm assuming it's a recent thing.
07:16:56 <quicksilver> so it's new with the ConstraintKinds extension?
07:16:57 <shachaf> It makes perfect sense, though.
07:16:58 <cmccann> things are more complicated with existential types and whatnot I suppose but that doesn't apply here
07:17:04 <shachaf> Perfect-ish.
07:17:10 <shachaf> quicksilver: No, it works in GHC 7.0.
07:17:26 <kniu> the base library has ReadP
07:17:40 <kniu> how does it fare against Parsec?
07:19:33 <shachaf> Hmm.
07:19:58 <shachaf> cmccann: So, yes, I don't really get the Ord a => (Ord a => a) -> a thing.
07:20:06 <shachaf> But I'm pretty sure *something* here is a bug.
07:20:10 <elliott> shachaf: You know, it can just be closed wontfix or something if it's not a bug.
07:20:17 <elliott> Just dump all the examples in a bug report and let 'em figure it out. :p
07:20:48 <cmccann> shachaf, almost certainly a bug but I suspect a trivial one
07:20:59 <shachaf> I can't register for the GHC Trac anyway.
07:21:05 <Saizan> is "Ord a => (Ord a => a) -> a" a type ghc infers or just accepts?
07:21:11 <elliott> infers
07:21:18 <elliott> shachaf: Why not?
07:21:25 <quicksilver> definitely a bug if it infers it
07:21:32 <ceii> Saizan: infers for (\(x :: Ord a => a) -> a)
07:21:39 <ceii> oops
07:21:44 <ceii> (\(x :: Ord a => a) -> x)
07:21:45 <shachaf> elliott: Server error.
07:21:49 <ceii> happy type day
07:21:50 <cmccann> what happens is that it infers (Ord a => a) -> (Ord a => a) and then reorders the arguments
07:21:54 <ceii> typo*
07:21:57 <ceii>  /sob
07:22:06 <cmccann> is my guess, at least
07:22:07 <shachaf> cmccann: Which isn't unreasonable, as *such*.
07:22:09 <Saizan> for (\(x :: Ord a => a) -> a) i'm not surprised
07:22:13 <shachaf> That was my guess also.
07:22:20 <elliott> shachaf: Do you mean the Hackage trac?
07:22:24 <elliott> GHC trac is a separate thing, I think.
07:22:40 <Saizan> i'm not sure what else it could do for that code, rejecting seems wrong too
07:22:45 <elliott> Saizan: (Ord a) => a -> a
07:22:47 <cmccann> shachaf, right, but it does so while things are still expecting a type of the form (b -> b)
07:22:57 <elliott> Saizan: *or* (forall a. (Ord a) => a) -> (forall a. (Ord a) => a)
07:22:58 <shachaf> Yay, GHC 7.4 doesn't work with gold.
07:23:05 <Saizan> but surely you'd get a more informed opinion on the trac
07:23:07 <elliott> Because of implicit quantification.
07:23:13 <shachaf> elliott: I mean the GHC Trac.
07:23:14 <cmccann> elliott, no, adding quantifiers is probably wrong
07:23:24 <shachaf> Well, it's on http://hackage.haskell.org/trac/ghc/
07:23:33 <elliott> cmccann: But (foo :: a) is interpreted as (foo :: forall a. a) in expression context.
07:23:41 <elliott> What does (\(x::t) -> x) do?
07:24:10 <ceii> elliott: forall a. a -> a
07:24:12 <cmccann> oh, hm, good point
07:24:16 <elliott> Ugh.
07:24:17 <elliott> Is that standard?
07:24:17 <cmccann> maybe that does make more sense
07:24:33 <elliott> What about
07:24:36 <elliott> (\(x::t) (y::t) -> y)?
07:24:47 <elliott> If that's a -> b -> b, then that's really really stupid.
07:24:59 <cmccann> it's t -> t -> t
07:25:01 <ceii> forall t. t -> t -> t
07:25:05 <elliott> OK, that at least makes sense.
07:25:13 <elliott> Then the type should be (Ord a) => a -> a.
07:25:16 <ceii> yes
07:25:27 <elliott> (?a -> ?b) ==> ((Ord a) => a -> ?b) ==> ((Ord a) => a -> a)
07:25:44 <shachaf> I don't see why the type should be (Ord a) => a -> a
07:25:51 <cmccann> shachaf, what else would it be?
07:26:00 <shachaf> I mean, the argument is of type (Ord a => a)
07:26:06 <shachaf> It can't just move the Ord constraint outside.
07:26:06 <cmccann> (forall a. Ord a => a) -> (forall a. Ord a => a)?
07:26:21 <cmccann> sure it can, the constraint isn't a quantifier
07:26:23 <elliott> shachaf: Why not?
07:26:25 <shachaf> Well, it couldn't do it if it was a normal argument, anyway.
07:26:27 <elliott> Constraints float left.
07:26:35 <shachaf> elliott: Not like this they don't!
07:26:44 <quicksilver> (Ord a => a) -> (Ord a => a) is actually meaningless
07:26:46 <cmccann> shachaf, it's an argument with a single uniqe value
07:26:46 <ceii> shachaf: constraints belong to quantifiers, not occurences
07:26:47 <shachaf> (a -> b) -> c /= a -> b -> a
07:26:51 <cmccann> like my example with ()
07:26:54 <ceii> at least that's my understanding
07:26:57 <quicksilver> which is why I assumed there was an implicit forall with the =>
07:26:57 <elliott> shachaf: Anyway, (\(x::t) (y::t) -> y) proves that the "constraints" -- like quantifiers and contexts -- go to the left of the function.
07:27:01 * dp_wiz wondering if Blaze.Html produces a code tree or a series of chunks with placeholders... i.e. hello greeting = H.div $ do { H.p "hello"; H.p greeting } - Will it be squashed to "<div><p>hello</p><p>" ++ greeting ++ "</p></div>" or not?..
07:27:02 <elliott> shachaf: Because the ts there are shared.
07:27:04 <quicksilver> because that's the only way I could make it mean sometime.
07:27:16 <elliott> Except I guess an explicit forall changes that. Ugh.
07:27:20 <elliott> quicksilver: Why is it meaningless?
07:27:23 <Saizan> quicksilver: forall a. (Ord a => a) -> (Ord a => a) seems fine to me
07:27:32 <quicksilver> elliott: because it has no assigned meaning.
07:27:37 <quicksilver> types are a syntactical construct.
07:27:41 <elliott> quicksilver: That's silly.
07:27:45 <quicksilver> in the formal description of haskell types
07:27:49 <elliott> It has a perfectly reasonable interpretation.
07:27:49 <quicksilver> that example is not well-formed
07:28:02 <quicksilver> it is not a member of the language of "haskell types"
07:28:05 <Saizan> you get a function asking for an Ord dictionary and return one
07:28:17 <quicksilver> nor any of the extensions to haskell types which I'm personally familiar with.
07:28:18 <elliott> quicksilver: Then (forall a. a) is meaningless too.
07:28:32 <elliott> I don't think GHC's type system is documented anywhere.
07:28:33 <quicksilver> no, forall a . a has a meaning in a well-known extension
07:28:35 <ceii> Saizan, dictionaries are not part of the Haskell definition
07:28:48 <cmccann> you could also think of (Ord a => a) as meaning something like "Reader (Dict (Ord a)) a"
07:28:58 <quicksilver> elliott: the fact it's not documented anywhere doesn't mean it doesn't exist :)
07:29:00 <Saizan> ceii: yeah, but if we are discussin what an haskell program means we can pick models
07:29:08 <quicksilver> type systems are formal concept.
07:29:15 <elliott> quicksilver: Exactly. It also means that you can't say it has no meaning.
07:29:26 <elliott> We don't know what the semantics of GHC's type system are; we have to find out by experimentation and source-diving.
07:29:37 <quicksilver> It has no meaning within haskell98 or haskell2010
07:29:46 <shachaf> quicksilver: No one is arguing that.
07:29:46 <quicksilver> and it has no meaning within the GHC extensions that I am familiar with.
07:29:47 <elliott> Again, neither does (forall a. a).
07:29:54 <elliott> The GHC extensions have no formal specification.
07:29:58 <quicksilver> forall a . a has a meaning in a well understood extension.
07:29:59 <elliott> GHC is assigning this a meaning; the only question is whether we want it to or not.
07:30:02 <ceii> so
07:30:21 <quicksilver> well I think the question is what meaning is it assigning
07:30:29 <quicksilver> at least, that's the question I'm interested in.
07:31:14 <ceii> is it desirable for forall a. (Ord a => a) -> b to be a type distinct from both forall a. Ord a => a -> b and (forall a. Ord a => a) -> b?
07:31:20 <ceii> is what we should be asking
07:31:27 * cmccann wonders if ((=>) :: Constraint -> *) makes sense
07:32:00 <cmccann> er, ((=>) :: Constraint -> * -> *) I guess
07:32:13 <Saizan> ceii: yes
07:32:53 <ceii> I say no, because it makes no sense if you see class constraints as actual constraints, rather than sugar for dictionaries
07:33:13 <cmccann> ceii, I don't see what meaning it could have that differs from the first option
07:33:17 <Saizan> they are constraints with embedded information
07:33:40 <Saizan> which is more than just yes/no
07:34:51 <quicksilver> ceii: well, definitely distinct from the one where the forall is inside the ()
07:34:59 <Taneb> Hello!
07:35:09 <ceii> yes. guess that one was superfluous
07:35:45 <Saizan> ceii: see applicative and alternative here http://comonad.com/reader/2011/what-constraints-entail-part-2/
07:36:26 <Saizan> they wouldn't work if the Applicative (or Alternative) constraints were moved outside
07:36:49 <Saizan> (and you can make similar examples that don't involve unsafeCoerce)
07:36:52 <ceii> Saizan, I'll need a while to digest this
07:37:46 <elliott> Saizan: I don't think the type of applicative should be accepted.
07:37:56 <elliott> I mean, it's a blatantly unsafe function, so "but how would we do applicative otherwise?" isn't convincing.
07:37:59 <Taneb> Right, for lists, x >> y is concat (map (const y) x), right?
07:38:08 * hackagebot th-expand-syns 0.3.0.2 - Expands type synonyms in Template Haskell ASTs  http://hackage.haskell.org/package/th-expand-syns-0.3.0.2 (DanielSchuessler)
07:38:10 <cmccann> also, I think constraint kinds should be left out of this
07:38:16 <Saizan> btw, this would make sense even with a typeclass with no methods (hence no additional information), the important fact is that we can use gadts to prove some constraints hold
07:38:24 <elliott> Or rather, I think it should be accepted, but be equivalent to (Monad m, Applicative m) => m a -> m a.
07:38:26 <cmccann> handling constraints in types shouldn't be weirder because of an extension if you're not using it
07:38:36 <elliott> Taneb: Yes; or rather concatMap (const y) x.
07:38:39 <elliott> (Same thing.)
07:38:40 <Taneb> Yes
07:38:41 <Saizan> ContraintKinds just makes it nicer, you can do the same with plain gadts
07:38:49 <Taneb> I still don't really get >>
07:38:56 <elliott> Taneb: a >> b === a >>= const b
07:39:00 <elliott> === a >>= \_ -> b
07:39:05 <tromp_> > "hello" > "yo"
07:39:06 <lambdabot>   False
07:39:09 <tromp_> > "hello" >> "yo"
07:39:10 <lambdabot>   "yoyoyoyoyo"
07:39:19 <tromp_> > "hello" >>> "yo"
07:39:20 <lambdabot>   Couldn't match expected type `cat a b'
07:39:20 <lambdabot>         against inferred type `[GHC....
07:39:23 <elliott> (>>=) === flip concatMap, so (a >> b) === concatMap (const b) a
07:39:27 <elliott> (For [].)
07:40:01 * cmccann defines (>>>>) to do something completely unrelated to the other three completely unrelated operators made from sequences of >
07:40:39 <Taneb> > is little to do with >> or >>>
07:40:39 <lambdabot>   <no location info>: parse error on input `do'
07:41:02 <Taneb> Thanks for your input, lambdabot
07:41:09 <cmccann> well, >> and >>> don't have much relation either
07:41:31 <tromp_> :t (>>>)
07:41:32 <lambdabot> forall (cat :: * -> * -> *) a b c. (Control.Category.Category cat) => cat a b -> cat b c -> cat a c
07:41:35 <ceii> >> for indexed monads has a lot to do with >>> I guess
07:42:12 <Taneb> Is there any type for which >, >>, and >>> can all be used with
07:42:47 <quicksilver> >> and >>> are both categorical composition
07:43:10 <cmccann> Taneb, don't think there's on in the standard libraries but reasonable types exist that would
07:43:24 <tromp_> @instances Control.Category.Category
07:43:25 <lambdabot> (->), Kleisli m
07:43:56 <cmccann> @instances Ord
07:43:56 <lambdabot> (), (a, b), (a, b, c), (a, b, c, d), (a, b, c, d, e), All, Any, Bool, Char, Double, Dual a, Either a b, First a, Float, Int, Integer, Last a, Maybe a, Ordering, Product a, Sum a, [a]
07:43:57 <tromp_> neither are in Ord
07:44:18 <cmccann> yeah, you want a pointwise Ord instance for functions
07:44:31 <elliott> Or for Kleisli.
07:44:34 <cmccann> with the unwrapped reader monad and function composition
07:44:36 <elliott> No, wait, that's a function still.
07:44:40 <cmccann> same diff
07:44:52 <cmccann> and the extra monad gets in the way
07:45:00 <elliott> Why aren't there more common Categories that don't have (->)s in them? :(
07:45:23 <cmccann> because (->) is Hask :P
07:45:39 <tromp_> try to define a sensible instance Category String
07:45:40 <elliott> data C a b where Id :: C a a; Comp :: forall b. C b c -> C a b -> C a c
07:45:53 <cmccann> and most Category instances are just elaborate subcategories one way or another
07:45:57 <elliott> Actually if you had
07:45:59 <quicksilver> elliott: lenses are a good Category
07:46:07 <cmccann> lenses also contain (->)
07:46:11 <elliott> data C c a b where Lift :: c a b -> C a b; Comp :: forall b. C b c -> C a b -> C a c
07:46:19 <elliott> Unfortunately you can't give an Ord instance for that, because you need a universally-quantified constraint.
07:46:22 <elliott> quicksilver: They have a (->).
07:46:27 <elliott> tromp_: String has the wrong kind.
07:46:34 <tromp_> try to define a sensible instance Category String String, i mean
07:46:45 <elliott> Huh?
07:46:49 <quicksilver> elliott: not at the top level.
07:46:52 <djanatyn> ...hmm. I'm giving a presentation for a science project, and it says that all programming projects must use either object oriented programming, or structured programming.
07:46:54 <elliott> class Category cat where id :: cat a a; (.) :: cat b c -> cat a b -> cat a c
07:46:58 <quicksilver> depends what you meant by 'having a -> in them'
07:47:11 <elliott> quicksilver: Lens a b = a -> (b, b -> a)
07:47:13 <djanatyn> ...could haskell and functional programming be considered a part of structured programming?
07:47:14 <elliott> Looks like the top level to me.
07:47:14 <tromp_> hmm, ignore that:(
07:47:21 <shachaf> djanatyn: Haskell is structured.
07:47:25 <cmccann> elliott, that said, you could easily make a typed EDSL with a Category instance I suspect
07:47:41 <djanatyn> I checked out the wikipedia article, and it seemed to be a bit less narrowly defined then OOP
07:47:45 <djanatyn> *than
07:47:51 <quicksilver> elliott: fair point, but that's not the only way to implment them.
07:47:51 <elliott> cmccann: Yes, indeed. It only falls down once you reach Arrow.
07:47:53 <shachaf> Lens a b = a -> ((b -> a) -> b -> r) -> r
07:48:07 <elliott> quicksilver: Well, the problem is giving an Ord instance, so it's having a (->) anywhere that gums things up.
07:48:12 * quicksilver nods
07:48:15 <Eduard_Munteanu> Heh, even asm can be pretty much structured these days :)
07:48:16 <elliott> (Of course, ((->) r) for certain, fixed rs is OK.)
07:48:32 <elliott> djanatyn: "Structured" usually means "like ALGOL".
07:48:58 <djanatyn> Yeah. I'm not sure if they're going to knock off points because I'm not using Java or Python :\
07:49:01 <cmccann> djanatyn, old-school structured programming is basically what you're doing when you write straightforward imperative code in IO
07:49:41 <shachaf> Lens a b = ((b -> a) -> (b -> r)) -> (a -> r)
07:49:41 <Eduard_Munteanu> djanatyn: what do you mean? Some school project you're doing in Haskell instead of other stuff?
07:49:44 <cmccann> it's closer to what "structured programming" originally meant than most modern languages, I suspect
07:49:46 <djanatyn> My project is pretty straightforward - comparing different sorting algorithms and their performance in haskell.
07:49:48 <ceii> data C a b where Id :: C a a; K :: C a (C b a); S :: C (C t (C a b)) (C (C t a) (C t b))
07:49:55 <ceii> we all happy now?
07:50:10 <Eduard_Munteanu> If anything they should be commending you :P
07:50:24 <ceii> took me 2 minutes to type :(
07:50:32 <cmccann> djanatyn, I'd be worried about confusing whoever wrote the assignment with strange things they've never seen before :P
07:50:32 <djanatyn> I'm going to give a little bit of background information about functional programming ng and haskell first.
07:50:39 <elliott> ceii: You forgot application, and Id is redundant.
07:51:04 <ceii> elliott, oh, right
07:51:09 <elliott> Oh, I guess you can't do application.
07:51:13 <ceii> yes
07:51:14 <elliott> But you can do composition. Is that enough to get Id?
07:51:26 <elliott> data SK a b where K :: SK a (SK b a); S :: SK (SK t (SK a b)) (SK (SK t a) (SK t b)); O :: SK b c -> SK a b -> SK a c
07:51:31 <ceii> S and K are complete basis
07:51:35 <cmccann> elliott, I dislike Arrow so I'm not really on speaking terms with it
07:51:49 <Eduard_Munteanu> There's even a one-combinator calculus IIRC.
07:51:55 <elliott> cmccann: yeah, agreed
07:51:56 <ceii> I = S K K
07:52:00 <elliott> Eduard_Munteanu: Several.
07:52:07 <elliott> ceii: Yes, but you don't have application.
07:52:07 <cmccann> Eduard_Munteanu, the iota combinator is best known I think
07:52:10 <elliott> So you cannot express S K K.
07:52:13 <Eduard_Munteanu> Ah, yeah, that.
07:52:16 <ceii> oh
07:52:18 <ceii> damn
07:52:21 <ceii> :(
07:52:28 <cmccann> elliott, also, function composition is called B
07:52:40 <Eduard_Munteanu> ι ... looking like a misprinted i or l :)
07:52:45 <elliott> data Applicative cat a where Fun :: cat a b -> Applicative cat (a -> b); App :: Applicative cat (a -> b) -> Applicative cat a -> Applicative cat b
07:52:51 <elliott> then (Applicative SK) works :)
07:53:46 <Philippa> cmccann: I'd generally rather have applicative and analogues of Arrow's not-quite-product operations, certainly
07:54:47 <cmccann> Philippa, arr is a functor from Hask to the Category, and really shouldn't be required
07:55:05 <cmccann> and all of (&&&), (***), (|||), and (+++) can be meaningfully defined independently of the others
07:55:53 <cmccann> you also want fst and snd as primitives with arr gone
07:55:59 <elliott> cmccann: Just use the GArrow stuff.
07:56:07 <cmccann> and inl/inr or such for Either
07:56:18 <elliott> cmccann: Note that you can't just have fst and snd, they're not quite enough.
07:56:31 <elliott> See http://www.cs.berkeley.edu/~megacz/garrows/ for a working hierarchy, that also unifies Arrow and ArrowChoice.
07:56:33 <shachaf> λ> class Foo a
07:56:33 <shachaf> λ> data X
07:56:33 <shachaf> λ> instance Foo X
07:56:44 <shachaf> This is obviously the best feature of 7.4
07:56:49 <shachaf> Never mind all that constraint kind nonsense.
07:56:51 <cmccann> and then, after several hours and a bulk order of soda, you turn into edwardk and nobody knows what you're talking about anymore
07:57:04 <Philippa> cmccann: yeah, fair enough, it's got legacy problems
07:57:20 <Philippa> there's an awful lot of historical accidents around
07:57:21 <cmccann> elliott, not enough for what?
07:57:28 <elliott> cmccann: Well, for a usable class.
07:57:42 <Philippa> (also, having flashbacks to stuff I was kicking around something like 8 years back, but hey)
07:58:02 <elliott> cmccann: (If you don't have any requirements of usability, I offer: class Arrow a where {})
07:58:17 <cmccann> elliott, what's unusable about Category + fst, snd?
07:58:34 <cmccann> presumably any instance would have some way of constructing arrows producing tuples
07:58:41 <cmccann> and you'd have generic ways to project those
07:58:42 <shachaf> Oh, GHC Trac lets me register an account now.
07:58:46 <shachaf> Should I report the thing?
07:59:21 <elliott> cmccann: Of course it "works" if you can bring in instance-specific stuff.
07:59:26 <elliott> cmccann: But you can't write any useful generic arrow combinators.
07:59:54 <elliott> And if you're willing to rely on instance-specific stuff to write even the simplest of functions, I again recommend class Arrow a where {} :)
07:59:57 <elliott> shachaf: Yes.
07:59:59 <cmccann> elliott, you'd have useful combinators for combinations of category-derived classes
08:00:06 <elliott> cmccann: What's wrong with GArrow?
08:00:15 <shachaf> Please enter the text below to prove you're not a machine.
08:00:18 <shachaf> Um...
08:00:21 <shachaf> I think I'm a machine.
08:00:46 <shachaf> Great, now it's not working again.
08:00:52 <elliott> cmccann: It's just a category, a product, and an identity plus embeddings of cancellation/uncancellation of the identity, associativity of the product, and first/second.
08:00:54 * shachaf ought to learn to read cursive one of these days.
08:01:29 <elliott> Which are a reasonable, unified set of laws that you'd always want, and suffice to write generic operations; everything on top of that is a another typeclass.
08:01:32 <elliott> *is another
08:01:57 <cmccann> elliott, hm, trying to decide if it would suit my purposes
08:02:06 <cmccann> having the identity as a class parameter helps a lot
08:02:33 <elliott> cmccann: The instance heads get icky, and it's very hard to disambiguate each combinator because of the complete lack of restrictions ((**) -> u as a fundep helps a bit).
08:02:38 <elliott> cmccann: But that's Haskell's problem :)
08:03:58 <dainanaki> hrm, looks like monoid now has a <> operator. That breaks a lot of stuff.
08:04:54 <elliott> dainanaki: i'm starting to understand why nothing ever gets changed in base :P
08:05:26 * cmccann still would have preferred (++) for the monoid operation
08:05:38 <cmccann> rather than stealing (<>)
08:05:45 <dainanaki> indeed. It's nice that haskell is always improving the state of the libraries, but it is inconvenient in the meantime.
08:06:08 * quicksilver still would have preferred ->
08:06:10 <quicksilver> erm
08:06:10 <elliott> dainanaki: It's a pretty trivial fix in any broken code...
08:06:11 <quicksilver> =>
08:06:13 <quicksilver> !
08:06:16 <quicksilver> +>
08:06:21 <quicksilver> stupid fingers.
08:06:37 * quicksilver still would have preferred (+>). There.
08:06:43 <dainanaki> elliott, yes, but I dislike having to cabal unpack other people's libraries and tweak them.
08:07:11 <mkscrg> is the current version of cabal compatible with ghc 7.4.1? or will i have to build cabal HEAD like i had to for 7.2.1?
08:07:18 <elliott> mkscrg: darcs version
08:07:18 <Saizan> is forall a b. (O a -> a) -> b logically equivalent to forall a b. O a -> a -> b, even in classical logic? (third order propositional i guess)
08:07:34 <elliott> Saizan: What's O?
08:07:40 <mkscrg> elliott: thanks
08:07:50 <elliott> I don't see why that would be equivalent at all unless O is special.
08:08:14 <shachaf> ==elliott
08:08:21 <qpu> would it be equal if O were the identity function on types?
08:08:33 <quicksilver> no
08:08:42 <srhb> Wildly hard for me to define question, and probably not very useful.. Can I somehow "distribure" function applications around some operators? Like in this example (randomIO >>= print), could I map replicateM_ 3 onto each side of the >>= ?
08:08:49 <elliott> qpu: No.
08:08:50 <quicksilver> (a -> a) -> b is definitely not a -> a -> b
08:08:51 <qpu> oh, never mind… misread that
08:09:06 <Saizan> so i guess that's answers my question :)
08:09:07 <quicksilver> srhb: not in general, no.
08:09:15 <Saizan> s/'s//
08:09:16 * shachaf wonders if Saizan is speaking in the context of (Ord a => a) -> a
08:09:18 <srhb> quicksilver: Didn't think so.
08:09:20 <quicksilver> srhb: >>= is opaque you can't map aver both sides of it.
08:09:25 <Saizan> shachaf: i do
08:09:38 <shachaf> Saizan: Right. I was wondering about that.
08:09:40 <elliott> Saizan: (=>) isn't *that* like (->).
08:09:47 <elliott> Saizan: Because this O is special.
08:09:56 <keep_learning> Xcode 4.1 is necessary for GHC-7.4.1 or I can use Xcode 4.2 ?
08:09:59 <elliott> There is either zero or one values of (O a) for any a.
08:10:05 <elliott> i.e., (O a) values are unique.
08:10:10 <elliott> (Which is why O is like Prop.)
08:10:19 <elliott> (Err, O is like Type -> Prop.)
08:10:27 <shachaf> elliott: I don't think the interpretaion of types as propositions cares about uniqueness in particular.
08:10:42 <elliott> I'm not talking about the interpretation of types as propositions.
08:10:44 <elliott> I'm talking about instances.
08:10:50 <Saizan> shachaf: i thought classical logic couldn't be accused of caring about dictionaries
08:10:55 <elliott> ((Ord a => a) -> a) === ((Ord a) => a -> a) because (Ord a) is unique.
08:11:06 <cmccann> srhb, what do you want to accomplish?
08:11:11 <mkscrg> keep_learning: i *think* 4.2 is what the binary distribution was built with
08:11:43 <srhb> cmccann: Nothing, it was just a stray thought. It's the haskell-superpower feeling. "It must be able to do this, it an do ANYTHING!" :-)
08:11:57 <shachaf> elliott: I'm not sure how that follows from "because (Ord a) is unique"
08:12:22 <Eduard_Munteanu> I'd rather think how that translates in Agda with NCIs :/
08:12:30 <elliott> shachaf: Oh, hmm, wait, Saizan's type is not what we were talking about.
08:12:40 <elliott> It's (forall a b. O a -> (O a -> a) -> b) vs. (forall a b. O a -> a -> b).
08:12:42 <dainanaki> srhb, you could probably do what you want with template haskell and a lot of patience. Not sure I would recommend attempting that though.
08:12:56 <elliott> shachaf: Surely you can agree those are equal if (O a) has only zero or one values for every a?
08:13:02 <Saizan> elliott: classical logic doesn't care about how many proofs there are
08:13:06 <shachaf> elliott: What does it mean for "O a" to have values?
08:13:07 <srhb> dainanaki: Naw, no need.
08:13:10 <shachaf> They're all equivalent proofs.
08:13:11 <elliott> Because the only thing the former can do is pass the first argument to the function.
08:13:21 <elliott> shachaf: I'm not talking in the context of classical logic here.
08:13:22 <shachaf> What?
08:13:26 <elliott> I never claimed to be.
08:13:30 <shachaf> OK.
08:13:58 <shachaf> Saizan was, I think.
08:14:00 <elliott> The whole reason ((Ord a) => (Ord a => a) -> a) and ((Ord a) => a -> a) are equivalent is because there's only zero or one Ord instances for a given type.
08:14:00 <Eduard_Munteanu> But (Ord a => a) -> a   isn't the same thing as   (Ord a => a -> a)  , is it?
08:14:02 <elliott> Agreed?
08:14:10 <keep_learning> mkscrg, http://www.haskell.org/ghc/download_ghc_7_4_1#macosxintel It say Xcode 4.1  so I am just curious about Xcode 4.2 because its only 1.6 GB as compared to 3 GB
08:14:18 <elliott> But Saizan's type is the wrong one, it's (forall a b. O a -> (O a -> a) -> b) vs. (forall a b. O a -> a -> b) Saizan should be thinking about.
08:14:26 <Eduard_Munteanu> Isn't there some implied quantification?
08:14:49 <Eduard_Munteanu> Anyway, I'm speculating about the original question.
08:15:59 <mkscrg> keep_learning: huh. well i'm about to try it with 4.2 so i'll report back with the results
08:16:18 <mkscrg> is there a way to get the darcs HEAD of cabal without installing darcs?
08:16:20 <ski> elliott : in case you know `Ord a', `(Ord a => a) -> a' and `Ord a => a -> a' are equivalent, yes -- if you only know `Ord a' is unique you can only go from the former to the latter
08:16:47 <keep_learning> mkscrg, Thank you
08:17:31 <elliott> ski: The question has always been ((Ord a) => ((Ord a) => a) -> a) vs. ((Ord a) => a -> a).
08:17:32 <shachaf> elliott: Where did "b" get into all this?
08:17:49 <Eduard_Munteanu> ski: hm, that doesn't sound right to me (is it actually correct Haskell syntax?). I was interpreting the former as a rank-2 type.
08:18:23 <elliott> shachaf: I have no idea.
08:18:43 <elliott> Eduard_Munteanu: It's not a rank-2 type.
08:19:05 <ski> elliott : hm, i misunderstood the question then
08:19:17 <mkscrg> keep_learning: seems fine with 4.2. haven't tried to build anything serious yet but both ghci and ghc run
08:19:31 <ceii> I'm starting to make sense of this
08:19:35 <Eduard_Munteanu> Hm, I was thinking the outer 'a' could lack an Ord instance :/
08:19:49 * ski just arrived
08:19:53 <cmccann> they're the same "a", aren't they?
08:20:03 <keep_learning> mkscrg, Thank you
08:20:07 <Eduard_Munteanu> Hm, I guess so, after all.
08:20:29 <elliott> ski: Saizan's type was incorrect.
08:20:36 <shachaf> OK, I'm going to write the bug report.
08:20:44 <ceii> (Ord a => a) -> a is different from (Ord a) => a -> a because the fact a implements Ord can be a local property
08:20:47 <shachaf> What were the relevant examples again?
08:21:01 <ceii> for example, we could bring it into scope by pattern matching on a GADT
08:21:22 <ceii> example 1 : id :: (Ord a => a) -> (Ord a => a) is not accepted
08:21:23 <Eduard_Munteanu> Hm, so it's not just useless syntax after all?
08:21:33 <elliott> ceii: Nobody ever disagreed that (Ord a => a) -> a is different frmo (Ord a) => a -> a.
08:21:36 <ceii> example 2 : (\x -> id x) :: (Ord a => a) -> (Ord a => a) is accepted
08:21:44 <ceii> elliott: I did --'
08:22:07 <ceii> example 3 : (\x -> id x :: (Ord a => a) -> (Ord a => a)) :: Ord a => a -> a is not accepted
08:22:19 <elliott> ceii: Just take a = Int and assume there's no (Ord Int) instance.
08:22:24 <ceii> oops: example 3 : ((\x -> id x) :: (Ord a => a) -> (Ord a => a)) :: Ord a => a -> a is not accepted
08:22:27 <elliott> You can write the former (const 42) but not the latter.
08:22:48 <ceii> example 4 : (\y -> ((\x -> id x) :: (Ord a => a) -> (Ord a => a)) y) :: Ord a => a -> a is accepted
08:23:21 <quicksilver> Eduard_Munteanu: it is non standard and as far as I know doesn't have an intended meaning, however GHC believes it means something.
08:23:35 <quicksilver> Eduard_Munteanu: IMO the question is whether or not it's a sensible thing at all.
08:23:51 <shachaf> ceii: What's wrong with example 3?
08:23:59 <shachaf> It looks like you're generalizing the type.
08:24:02 <Eduard_Munteanu> Yeah.
08:24:14 <ceii> what's wrong is that 4 works but 3 doesn't
08:24:18 <cmccann> also, even if (Ord a => a) -> a should be the same as Ord a => a -> a, (Ord a => a) -> (Ord a => a) should still unify with b -> b
08:24:38 <cmccann> rather than being turned into Ord a => (Ord a => a) -> a first
08:24:40 <ceii> or I think it's wrong
08:25:40 <ben> Is there a "isUnevaluatedThunk" function somewhere?
08:26:06 <cmccann> ben, http://hackage.haskell.org/package/isevaluated ?
08:26:14 <cmccann> seems outdated though
08:26:17 <ben> Cool, cheers
08:26:27 <parcs`> http://hackage.haskell.org/packages/archive/tag-bits/0.1.1/doc/html/Data-TagBits.html
08:26:40 <shachaf> cmccann: Isn't Ord a => (Ord a => a) -> a just another way of writing (Ord a => a) -> (Ord a => a)?
08:26:50 <nand`> > let (--+) = (+) in 1 --+ 2
08:26:51 <lambdabot>   3
08:26:59 <nand`> it irks me that this is considered valid
08:27:18 <nand`> not only because my editor considers 3/4 of that a comment
08:27:25 <cmccann> shachaf, is (a -> (a -> b) -> b) another way of writing (a -> b) -> (a -> b)?
08:27:30 <Eduard_Munteanu> Looks like it could be valid, but have trivial semantics :/
08:28:01 <elliott> cmccann: The question is whether (a -> (a -> b) -> b) is the same as ((a -> b) -> a -> b).
08:28:02 <ceii> cmccann, if the a arguments are being automatically placed, I guess it is
08:28:09 <shachaf> cmccann: Is (Ord a, Ord b) another way of writing (Ord b, Ord a)?
08:28:13 <elliott> The answer is yes, modulo argument order, which doesn't matter with constraints.
08:28:40 * ski still wonders what the question is
08:28:41 <cmccann> right
08:28:46 <shachaf> ski:
08:28:52 <shachaf> Er.
08:28:57 <ski> shachaf :
08:29:03 <elliott> ski: (\(x :: (Ord a) => a) -> x)
08:29:08 <shachaf> (\(x :: Ord a => a) -> x)
08:29:13 <elliott> ski: gets inferred type (forall a. (Ord a) => (Ord a => a) -> a)
08:29:15 <elliott> when Rank2Types is on
08:29:16 <conal> shachaf: you can also use a curried form.
08:29:20 <elliott> the question is: "wtf?"
08:29:24 <shachaf> conal: I know. We've been doing that here.
08:29:31 <conal> ah
08:29:42 <shachaf> id :: forall a. (Ord a => a) -> (Ord a => a) -- invalid
08:29:47 <shachaf> (\x -> id x) :: forall a. (Ord a => a) -> (Ord a => a) -- valid
08:29:48 <rwbarton> I thought the question was more to do with... ^ that.
08:30:01 <cmccann> the point is, arguments can be flipped (both constraints and otherwise) and the result is equivalent
08:30:19 <cmccann> semantically equivalent, that is. not syntactically equivalent for unification purposes
08:30:22 <ski> elliott : i think `Ord a => (Ord a => a) -> a' is probably considered equivalent to `(Ord a => a) -> Ord a => a'
08:30:29 <rwbarton> btw, replacing (Ord a => a) by (forall b. b) gives the same results
08:30:44 <cmccann> there's also the question of whether constraints in covariant position make sense at all
08:30:49 <ski> similarly to how `Foo -> forall a. Bar a' is considered quivalent to `forall a. Foo -> Bar a'
08:31:03 <rwbarton> yes
08:31:08 <shachaf> rwbarton: Oh, huh.
08:31:19 <shachaf> id :: (forall a. a) -> (forall b. b) -- invalid
08:31:23 <elliott> ski: Yes, it is.
08:31:24 <shachaf> (\x -> id x) :: (forall a. a) -> (forall b. b) -- valid
08:31:27 <ceii> rwbarton, oh, right. Then should this behavious be filed under "well-known higher-rank quirks"?
08:31:31 <ski> cmccann : huh, `Num a' in `negate :: Num a => a -> a' occurs covariantly
08:31:32 <elliott> ski: That doesn't answer the "wtf?" question, though.
08:31:37 <ben> ghci> let x = length "derp" in seq x (unsafeIsEvaluated x) #=> True
08:31:41 <ben> ghci> let x = length "derp" in seq x $ unsafeIsEvaluated x #=> False
08:31:45 <ben> This is really confusing
08:31:53 <elliott> ben: Welcome to referential transparency.
08:31:53 <cmccann> ski, looks contravariant to me
08:31:57 <shachaf> That's rank-2 types, though.
08:32:01 <ski> elliott : then i don't understand the "wtf?"
08:32:19 <elliott> ski: Why is that valid, but not id :: forall a. (Ord a => a) -> (Ord a => a)?
08:32:32 <elliott> Why doesn't GHC infer the type (Ord a) => a -> a for that lambda?
08:32:38 <elliott> Or reject it?
08:32:55 <elliott> ski: Finally, why does Rank2Types matter, when it's a rank-1 type?
08:33:06 <rwbarton> ben: what happens with pseq x $ unsafeIsEvaluated x?
08:33:09 <cmccann> elliott, that's probably a parsing issue
08:33:10 <ski> cmccann : .. oh, for some reason i was talking about `Num a => ' as opposed to the `Num a' itself -- i agree the `Num a' occurs contravariantly
08:33:54 <Eduard_Munteanu> Maybe because we're wondering if that syntax makes any sense (and it'd make more sense if it implied some quantification)?
08:33:54 <ben> rwbarton: same as seq
08:34:15 <elliott> Eduard_Munteanu: It wouldn't: (\(x::t) (y::t) -> y) has type t -> t -> t.
08:34:25 <mysticc> Is there any library to do raw file reading and writing  .. like read 1 block etc ?
08:34:41 <cmccann> ski, right, we're talking about stuff like (Ord a => a) -> a
08:34:51 <cmccann> which has the Ord a constraint covariant
08:34:58 <ski> *nod*
08:35:12 <cmccann> and could be interpreted as a... CPS'd Ord dictionary?
08:35:13 <cmccann> who knows
08:35:36 <Eduard_Munteanu> Is this some ConstraintKinds magic, or some other extension?
08:35:45 <elliott> No.
08:35:50 <shachaf> No, this is in GHC 7.0.
08:35:50 <Eduard_Munteanu> (or does GHC just accept it non-standardly?)
08:35:53 <elliott> It's just Rank2Types, in GHC 7.0 all the way to 7.4.
08:35:53 <rwbarton> ben: you could try adding some trace expressions for debugging
08:35:58 <elliott> We don't know if it's standard, even.
08:36:02 <shachaf> elliott: Don't you need ScopedTypeVariables?
08:36:07 <Eduard_Munteanu> :/
08:36:08 <elliott> Ah, perhaps.
08:36:10 <elliott> *just need, presumably.
08:36:12 <cmccann> yes, for types in patterns
08:36:14 <shachaf> I'm pretty sure this isn't standard.
08:36:14 <ben> rwbarton: they seem to trace/print in the order I'd expect regardless of what that unsafe function returns
08:36:17 <ski> generally, `Foo => A -> B' should entail `(Foo => A) -> (Foo => B)'
08:36:26 <rwbarton> neato
08:36:36 <cmccann> you need RankNTypes, ScopedTypeVariables, and NoMonomorphismRestriction helps too
08:36:54 <elliott> cabal-dev users: What do you do when using Emacs for quick single-file hacks that you want to use cabal packages in? e.g. I want to use inferior-haskell-mode with a quick single-file thing to test something, but I need to use <package>. Making a directory and "cabal-dev init"ing and writing a cabal file is way too high overhead.
08:37:15 <rwbarton> what if you add a trace to the definition of x also?
08:37:16 <elliott> ben: Try -ddump-simpl.
08:37:20 <elliott> To see what Core it's using.
08:37:44 <ski> elliott : hm, to be able to type it with `Ord a => a -> a', `(Ord a => a) -> (Ord a => a)' must entail `Ord a => a -> a' ..
08:37:52 <cmccann> that said, this is probably a side-effect of some changes to the internals that allowed ConstraintKinds to be added later
08:38:02 <shachaf> These extra Ord constraints seem to be ompletely extraneous.
08:38:11 <elliott> cmccann: In 7.0?
08:38:13 * hackagebot network 2.3.0.10 - Low-level networking interface  http://hackage.haskell.org/package/network-2.3.0.10 (JohanTibell)
08:38:25 <ski> shachaf : which of them are "extra" ?
08:38:26 <elliott> cmccann: The typechecker got redone in 7.0 IIRC, but I don't see how that's related to ConstraintKinds.
08:38:34 <shachaf> ski: The ones that aren't outermost.
08:38:55 <shachaf> As someone pointed out before, constraints generally ought to be associated with quantifiers.
08:38:55 <ski> they mean potentially different things
08:39:00 <cmccann> elliott, I think a lot of the rework was on handling of constraints and contexts in ways that were probably necessary for ConstraintKinds
08:39:05 <shachaf> (\(x::Ord a => a) (y::a) -> ...)
08:39:07 <ski> shachaf : i'm not sure about that
08:39:13 <shachaf> (\(x::Ord a => a) (y::Ord a => a) -> ...)
08:39:33 <ceii> shachaf, I was the one who said that
08:39:39 <funktronic> is there a quick way to upgrade ghc ?
08:39:42 <shachaf> ski: Actually, yes, it might not be completely true.
08:39:46 <ceii> but I realized this way of thinking is incompatible with GADTs
08:40:09 <ski> ceii : how ?
08:40:16 <ceii> because a instance might be brought in scope (by a GADT pattern match) in a sub-scope of the variable's scope
08:40:33 <shachaf> (\(x::Ord a => a) (y::Ord a => a) -> compare x y)
08:41:13 <elliott> shachaf: What type does that get?
08:41:27 <cmccann> ceii, I don't know if it's incompatible with GADTs so much as GADTs require GHC to do more reordering and shuffling arguments around
08:41:34 <shachaf> (\(x::Ord a => a) (y::Ord a => a) -> compare x y) :: forall a. Ord a => (Ord a => a) -> (Ord a => a) -> Ordering
08:42:15 <ceii> like, say I have a data Wrap a where W :: Show a => a -> Wrap a
08:42:55 <ceii> I can give (\(Wrap a) f -> f a) the type forall a b. Wrap a -> (Show a => a -> b) -> b
08:43:21 <ceii> and this means I can pass a (Wrap a) for any type a, without constraint
08:43:31 <shachaf> Does that actually work?
08:43:38 <ski> i think so
08:43:47 <ski> it wraps a dictionary
08:43:58 <Eduard_Munteanu> \(W a) f, but yeah
08:44:46 <ski> (like `data Dict (c :: * -> Constraint) :: * -> * where TheDict :: c a => Dict a')
08:45:07 <shachaf> Neat.
08:45:41 <ski> (well, s/Dict a/Dict c a/, that is)
08:46:09 <eyebloom> Is ghci the best place to trace a Haskell program?
08:46:32 <ski> (hm i suppose `data Dict (c :: Constraint) :: * where TheDict :: c => Dict c' is simpler)
08:46:43 <elliott> ski: data Dict c where TheDict :: c => Dict c
08:46:46 <elliott> You don't need the ::s.
08:47:11 <ski> yeah, i just used it for clarity
08:49:10 <neutrino> hi
08:49:50 <eyebloom> hey there
08:50:15 <cmccann> ceii, you can give (\(W a) f -> f a) the type "forall a b. Wrap a -> (a -> b) -> b", you don't need that constraint
08:50:53 <rwbarton> but! you need the constraint if you want to pass that function an argument like "show"
08:51:32 <cmccann> rwbarton, don't think so
08:51:41 <elliott> Yeah, you don't.
08:51:44 <rwbarton> what?
08:51:53 <rwbarton> oh we didn't forget a
08:51:53 <elliott> cmccann: Er, you want the constraint.
08:51:55 <rwbarton> er
08:51:55 <elliott> That's the whole point.
08:52:31 <cmccann> the constraint is carried by the GADT, you don't need to write it in the type signature
08:52:40 <elliott> cmccann: ...yes, but your type doesn't work with "show"
08:52:47 <elliott> you can't write Wrap a -> String with it
08:52:54 <elliott> because you don't get the constraint
08:53:19 <rwbarton> except you can probably get the constraint from outside anyways
08:53:37 <elliott> rwbarton: If you can do that, then Wrap is pointless...
08:54:15 <cmccann> if you're passing something in that needs the constraint, you can get it from there anyway
08:54:22 <rwbarton> I'm having trouble coming up with a situation where the constraint would not be in scope
08:54:35 <rwbarton> it seems impossible to me
08:54:36 <cmccann> if you're not passing anything in, you can use the constraint from the pattern match
08:54:40 <elliott> rwbarton: Okay. Using _only_ (\(W a) f -> f a), write the function forall a. Wrap a -> String
08:54:44 <elliott> Erm.
08:54:49 <elliott> rwbarton: Okay. Using _only_ (\(W a) f -> f a) :: forall a b. Wrap a -> (a -> b) -> b, write the function forall a. Wrap a -> String
08:54:54 <rwbarton> what
08:55:03 <elliott> rwbarton: This is impossible. However, you can do it with (\(W a) f -> f a) :: forall a b. Wrap a -> ((Show a) => a -> b) -> b.
08:55:35 <rwbarton> this is what I was saying earlier
08:55:51 <elliott> The whole point of GADTs is putting constraints like these (sometimes type equality constraints) on the RHS of a case, so... I can't think of how to explain this except accusing everyone of not understanding GADTs :P
08:56:21 <ceii> the only use case I can think of is if you want get rid of an omnipresent context in every signature of your API
08:56:29 <rwbarton> however...
08:56:38 <ceii> like, you could get rid of the Ord constraints on all the Set functions
08:56:52 <ceii> by making the existence of a Set a a witness for Ord a
08:57:22 <elliott> Hmm, I suppose I could install packages locally and just use cabal-dev for larger things.
08:57:27 <elliott> But that seems annoying.
08:57:39 <elliott> Since it doesn't get rid of broken packages and the like.
08:57:51 <rwbarton> I can write Show t => Wrap t -> String with the :: forall a b. Wrap a -> (a -> b) -> b, and I'm at a loss for how I could get my hands on a value of type Wrap t where the Show t instance wasn't in scope anyways
08:58:05 <ski> hm, i wonder if `\(W a0) (W a1) -> W (asTypeOf a0 a1)' works
08:58:24 <shachaf> rwbarton: Well, you can do it for any specific type, but not polymorphically.
08:58:30 <shachaf> And polymorphism seems to be the point here.
08:58:56 <mkscrg> is cabal-dev actively being modified to work with 7.4.1?
08:59:05 <shachaf> You must admit that the type Wrap a -> String is better than the type Show a => Wrap a -> String.
08:59:08 <rwbarton> I mean, I understand the point if we were forgetting the type variable a
08:59:20 <rwbarton> well it's shorter I guess :P
08:59:22 <shachaf> If you're using Show a => Wrap a -> String, you might as well use data Wrap a where W :: a -> Wrap a
08:59:24 <elliott> mkscrg: the git version works
08:59:28 <ski> (what does "forgetting the type variable a" mean ?)
08:59:28 <shachaf> You don't get anything from the GADT.
08:59:43 <rwbarton> data Wrap where W :: Show a => a -> W a
08:59:45 <rwbarton> er
08:59:47 <rwbarton> -> W
08:59:53 <shachaf> That's an existential type.
08:59:56 <rwbarton> Yes.
08:59:59 <shachaf> Which is a different matter.
09:00:02 <rwbarton> Yes.
09:00:04 <ceii> also, you can keep the Show constraint private to those parts of the code that read it
09:00:18 <ceii> the rest of the code can just manipulate Wrap a's parametrically
09:00:35 <rwbarton> Anyways I think this discussion has devolved into nothingness.
09:00:40 <ceii> yes
09:01:10 <ceii> I've had a few epiphanies already, so I'm fine with stopping :)
09:01:13 <mkscrg> elliot: thanks. do you know why it (and also cabal) haven't made the fixes into actual releases?
09:01:27 <mkscrg> elliott*
09:03:12 <cmccann> elliott, Wrap a -> (a -> b) -> b is a more restrictive type than with the constraint, so yes, you can't give it show
09:04:15 <mroman> http://codepad.org/O6lcPyWW
09:04:18 <shachaf> It would be nice if GHC inferred the least restrictive type. :-)
09:04:23 <shachaf> By the way:
09:04:24 <mroman> ^- Can anyone give me a hint how to handle this.
09:04:28 <shachaf> I'm pleased that I can test all this in ghci.
09:04:35 <cmccann> but if you're going to give it show you need the constraint anyway, so I don't see what's gained by having the constraint inside the parentheses there
09:04:47 <mroman> Seems to be stuck in an "endless expecting digit" instead of ")" at some point.
09:05:04 <cmccann> actually
09:05:04 <cmccann> hm
09:05:13 <cmccann> GHC actually does care about the difference
09:05:19 <cmccann> interesting!
09:05:40 <shachaf> mroman: I think "parseTupel'" is consuming the number.
09:05:56 <mroman> Yes, because both are followed by a number
09:06:01 <shachaf> So n2 <- parseNumber is never getting the opportunity to.
09:06:11 <mroman> since the last number must not have a trailing ','
09:06:14 <shachaf> Then when parseTupel' is failing, the number has already been parsed.
09:06:26 <ceii> yes, all that's left is the ","
09:06:40 <shachaf> ceii: The ","?
09:06:49 <ceii> oops, no
09:06:53 <mroman> Putting parseTupel' into try solves the problem.
09:06:55 <ceii> all that's left is the ")"
09:06:57 <shachaf> You can factor things so that parseNUmber is only called once.
09:07:00 <shachaf> Or you can use try.
09:07:05 <mroman> But shouldn't it be possible without it?
09:07:16 <shachaf> It's possible without it.
09:07:24 <shachaf> First do a parseNumber, then check for either a ) or a ,
09:07:29 <shachaf> Or something along those lines.
09:07:31 <mroman> hm
09:07:36 <mroman> maybe make the char ',' optional?
09:08:01 <ceii> mroman: this makes parsing a single number ambiguous
09:08:21 <ceii> what if it's actually two numbers with the optional ',' not present in the middle?
09:08:36 <ceii> anyway, what shachaf said
09:08:37 <mroman> You mean 15 instead of 1,5?
09:08:40 <mroman> Then it's a 15.
09:08:46 <mroman> it actually works with optional $ char ','
09:09:07 <mroman> but it's the wrong way, yes ;)
09:09:24 <ceii> anyway, what shachaf said is probably cleanest
09:09:29 <funktronic> if i have  IO [Word8] what's the easiest way to convert that to a [Word8] ?
09:09:34 <cmccann> http://hpaste.org/57385 -- elliott ceii shachaf
09:09:38 <mroman> I'll give it a shot. Thanks.
09:09:52 <parcs`> funktronic: with >>=
09:10:11 <parcs`> :t (>>=) :: IO [Word8] -> ([Word8] -> IO b) -> IO b
09:10:12 <lambdabot> forall b. IO [Word8] -> ([Word8] -> IO b) -> IO b
09:10:27 <cmccann> I guess calling it a CPS-encoded dictionary actually makes more sense than I thought, hm
09:10:55 <parcs`> :t fmap :: ([Word8] -> b) -> IO [Word8] -> IO b
09:10:56 <lambdabot> forall b. ([Word8] -> b) -> IO [Word8] -> IO b
09:11:18 <danharaj> wow constraint kinds are kinda cool
09:11:35 <ceii> the new GHC is too cool
09:11:36 <cmccann> danharaj, yes
09:11:44 <ceii> we'll need months to absorb all that awesomeness
09:12:03 <shachaf> ceii: I maintain that the best part is that you can do top-level declarations in ghci.
09:12:14 <mroman> But that forces me kinda to use state?
09:12:20 <ion> URL: http://www.haskell.org/ghc/docs/7.4.1/html/users_guide/release-7-4-1.html
09:12:23 <shachaf> mroman: State? No.
09:12:37 <funktronic> :t (>>=) :: IO [Word8] -> ([Word8] -> b) -> b
09:12:37 <lambdabot>     Couldn't match expected type `b1' against inferred type `IO b'
09:12:38 <lambdabot>       `b1' is a rigid type variable bound by
09:12:38 <lambdabot>            an expression type signature at <interactive>:1:35
09:12:55 <shachaf> funktronic: -> IO b)
09:12:59 <ion> @type (>>=) `asAppliedTo` (undefined :: IO [Word8])
09:13:00 <mroman> parseTupel' should stop, if a ')' follows
09:13:00 <lambdabot> forall b. IO [Word8] -> ([Word8] -> IO b) -> IO b
09:13:14 <funktronic> ah i would like to get rid of the IO
09:13:22 <ion> Then use >>= :-)
09:13:41 <funktronic> if words is IO [Word8] then i just do words >>= foo ?
09:13:55 <ion> What exactly do you want?
09:14:16 <ion> “I’d like to get rid of the IO” is the Y in the X-Y problem.
09:14:23 <mroman> And since parseTupel' returns an Int, I can't just abort.
09:14:28 <mroman> Because I have to return an Int
09:14:50 <funktronic> i have a function foobar that takes [Word8] -> Bool and a words that is IO [Word8].
09:14:58 <parcs`> fmap foobar
09:15:00 <ion> @type fmap
09:15:01 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
09:15:35 <ion> Also, (<$>) is an inline alias of fmap.
09:16:56 <shachaf> cmccann: I don't think I quite understand this covariant constraint thing. :-)
09:17:17 <cmccann> shachaf, which part?
09:17:32 <cmccann> why there's a difference, or why I'm calling it covariant?
09:17:41 <shachaf> No, I understand your example, more or less.
09:17:44 <cmccann> or something else
09:17:50 <shachaf> It's more the (Ord a => a) -> (Ord a => a) thing.
09:17:57 <mroman> http://codepad.org/RstnGKRr <- ok. That works.
09:18:32 <cmccann> shachaf, well, given my hpaste above I think it's clear that's a meaningful type
09:18:38 <shachaf> Right.
09:18:48 <cmccann> and as such the reordering that GHC does to float the second constraint left is invalid
09:18:51 <shachaf> Maybe what's confusing me is the GHC bug. :-)
09:18:51 <cmccann> or rather, is done too soon
09:19:52 <cmccann> shachaf, changing it to Ord a => (Ord a => a) -> a is as valid as turning (a -> b) -> (a -> b) into (a -> (a -> b) -> b)
09:20:03 <funktronic> yeah it looks like that i am tryign to get riod fhte IO monad part of somethign when it is completely not allowed
09:20:05 <shachaf> cmccann: But why does argument order ever matter with constraints?
09:20:29 <cmccann> shachaf, because of things like my hpaste :P
09:20:58 * shachaf looks again.
09:21:02 <cmccann> constraints are satisfied by bringing a dictionary into scope
09:21:07 <shachaf> Where is argument order ever shuffled there?
09:21:37 <CodeWeaver> greetings
09:21:55 <cmccann> it's not, it demonstrates that the position of constraints matters
09:22:06 <shachaf> Whether they're nested or not?
09:22:17 <shachaf> Sure.
09:22:25 <shachaf> I grant that that matters.
09:22:35 <shachaf> I'm wondering in what cases you're allowed to change it and in what cases you aren't.
09:22:53 <shachaf> Is (Ord a => a -> a) a more general type than (Ord a => (Ord a => a) -> a)?
09:23:10 <cmccann> no, it's less general
09:24:18 <shachaf> So you should be able to specialise the latter into the former
09:24:21 <shachaf> s/$/?/
09:25:16 <cmccann> shachaf, you could unify a in the first with (Ord a => a)
09:26:06 <cmccann> And end up with something like (Ord a => (Ord a => a) -> (Ord a => a))
09:26:24 <cmccann> but more importantly you can unify (Ord a => a) with b in (b -> b)
09:26:28 <shachaf> I'm pretty sure (Ord a => (Ord a => a) -> (Ord a => a)) = (Ord a => (Ord a => a) -> a)
09:26:41 <cmccann> shachaf, yes, but you can't do that until after unification
09:26:56 <shachaf> Hmm.
09:27:14 <cmccann> shachaf, well, or you make GHC clever enough to transform things both ways as needed
09:27:42 <cmccann> since moving constraints around without changing variance is semantically equivalent
09:29:39 <rudyl313> how can I convert a ByteString (defined in Data.ByteString.Lazy.Internal) to a regular String? I tried using unpack from Data.ByteString.Char8 but the types don't match :/
09:30:18 <strager> T.unpack . TE.decodeUtf8 <$> getLazyByteString length
09:30:20 <strager> is what I have
09:30:29 <strager> import qualified Data.Text.Lazy as T
09:30:29 <strager> import qualified Data.Text.Lazy.Encoding as TE
09:30:49 <strager> @ rudyl313
09:31:06 <rudyl313> strager: awesome! I'll try that... thanks
09:32:41 <shachaf> rudyl313: Keep in mind that a ByteString doesn't hold characters, it holds bytes.
09:33:16 * hackagebot compdata 0.5.2 - Compositional Data Types  http://hackage.haskell.org/package/compdata-0.5.2 (PatrickBahr)
09:33:30 <rudyl313> shachaf: duly noted .. but I can call show on the bytestring and see a string prepresentation
09:34:23 <rudyl313> bottom line is I have a bytestring of JSON from a web request and I want to be able to parse the JSON .. and I'm not sure how to work with bytestrings directly
09:35:27 <elliottt> does pandoc support going from github flavored markdown with ```haskell markers, to lhs?
09:35:47 <elliott> hi elliottt!
09:35:52 <elliottt> hi elliott :)
09:36:02 <shachaf> Which one of you is the real elliot?
09:36:07 <elliottt> me!
09:36:14 * shachaf doesn't know whom to shoot!
09:36:18 <elliottt> hehe
09:36:22 <rudyl313> strager: your method work.. thanks man
09:36:27 <rudyl313> works*
09:36:35 <nand`> quick
09:36:41 <nand`> ask a category theoretical question
09:36:43 <shachaf> elliottt: Actually, elliott would never admit to being elliot.
09:37:22 <elliottt> well, technically, i'm elliott
09:37:29 <elliottt> and my first name starts with a `t'
09:38:42 <elliott> I think there are at least 4 people with the name elliott who have been in this channel.
09:38:54 <ion> Oh, nice. elliott and elliottt are colored differently. I switched from Irssi to WeeChat yesterday and it has this feature built in.
09:38:59 <hpc> haha
09:39:00 <elliottt> apparently it's much more common that i once thought
09:39:07 <elliottt> oh fancy
09:39:31 <elliott> elliottt: No, I don't think it is.
09:39:44 <elliott> I think there's just something about Haskell, honestly, because it's the first time I've ever seen more than one other person with my name.
09:39:48 <elliottt> then all elliotts are drawn to #haskell?
09:39:54 <elliottt> odd :)
09:40:06 <elliott> The extra "t" stands for types.
09:40:18 <ion> uint8_t
09:40:24 <elliottt> and the extra `l'?  lots of?
09:40:30 <elliott> elliottt: Likeable!
09:40:39 <elliottt> hah
09:40:49 <cmccann> elliott, first or last name?
09:40:53 <glguy> These self-chosen ASCII nicknames aren't working out; I propose we switch to randomly assigned integer nicknames
09:41:03 <elliott> cmccann: In what context? Mine is first.
09:41:05 <cmccann> elliott, I think you might be the only one with the first name...
09:41:25 <elliott> 465984568934573495: Agreed.
09:41:26 <ion> glguy: AFAIR, IRC only had numeric channel IDs originally.
09:41:45 <ion> I’m under the impression #42 on IRCnet originates from that time.
09:41:51 <elliott> cmccann: elliottcable too, going by /whois.
09:41:56 <cmccann> oh yeah
09:41:58 <cmccann> ok, two of each them
09:42:02 <cmccann> s/them/then
09:42:05 <elliott> /
09:42:09 <elliott> (s/$/\//)
09:42:14 <cmccann> ugh, can't type
09:42:24 <elliottt> dang, pandoc doesn't seem to deal with the github ```haskell code blocks :(
09:44:08 <ion> s|\\/|!|; s|/|#|g; s|!|/|
09:45:37 <rudyl313> I'm working on an API driver for haskell, where the API returns data in JSON format.. what's the standard way to return data to the client of the library? Should I return raw JSON as a string? Or create a type to hold the data?
09:46:34 <elliott> rudyl313: Create a type, if it's feasible; use http://hackage.haskell.org/package/aeson
09:46:38 <c_wraith> rudyl313: there are a bunch of json libraries.  Aeson is probably the best.
09:46:58 <rudyl313> ok cool.. thanks for the tip guys
09:46:59 <elliott> Don't return it at the string, at least, return it as a JSON object with aeson's type if you must
09:47:15 <rudyl313> elliott: gotcha
09:49:58 <mroman> Ok.
09:50:17 <mroman> But for distinguishing between floats and ints it is okay to use try?
09:50:48 <mroman> because that is only known after many digits have been consumed.
09:54:06 <mroman> http://codepad.org/IYweeVut
10:04:04 <dainanaki> Am I correct in thinking that FunPtrs really just point to an arbitrary address in memory? If so, when I call a FunPtr, what is the calling convention?
10:05:39 <neutrino> hi i have a hanging ghc process, i tried doing kill -15, -2 and -1 on it, what should i do?
10:06:13 <Botje_> kill -9
10:06:19 <Botje_> should kill it instantly
10:06:49 <shachaf> dainanaki: Presumably you specify the calling convention in your foreign import statement.
10:06:51 <Botje_> alternatively you can try ctrl-z in its terminal and then kill %
10:06:55 <Botje_> or hit ctrl-\
10:07:35 <dainanaki> shachaf, unfortunately these are FunPtrs which I am unable to import using foreign import syntax.
10:07:54 <shachaf> How are you getting them, then?
10:09:40 <dainanaki> Well, they are variadic functions pointers being returned from foreign code.
10:09:49 <dainanaki> the variadic part is what makes it tricky.
10:10:08 <shachaf> Have you considered making a non-variadic C wrapper to deal with this?
10:11:09 <dainanaki> That isn't acceptable for this use case.
10:12:24 <neutrino> ok kill -9 has worked, i wonder why it worked and -2/-1 didn't
10:12:27 <neutrino> thanks
10:12:50 <dainanaki> I really just need to know what the calling convention is for GHC on an x86_64 unix platform
10:12:56 <hpc> neutrino: the numbers are different signals
10:13:05 <elliott> dainanaki: There's a libffi thing to do variadic FunPtrs.
10:13:08 <neutrino> i realize
10:13:13 <neutrino> but what does 9 do that 1 doesn't
10:13:16 <hpc> neutrino: for instance, you could write a program that intercepted sigterm and didn't terminate
10:13:20 <hpc> 9 is the
10:13:37 <hpc> 9 is the "hey, OS, really kill this shit for me; ignore what the program says" signal
10:13:43 <neutrino> ok
10:13:59 <znutar> 9 can't be handled by the program, goes right to the OS
10:14:05 <hpc> the program doesn't ever see it, it just poofs
10:14:09 <neutrino> k cool
10:14:30 <ceii> ...unless it's stuck in uninterruptible sleep, then you're in hell
10:14:42 <neutrino> why did the -1 not work? normally it does
10:14:42 <znutar> which sucks because the program can't clean things up if it's in an inconsistent state w.r.t. the filesystem or whatever
10:14:43 <hpc> im sure there's somewhere on the internet that explains all the signals, but i don't know of it
10:15:07 <elliott> With DataKinds: Does anyone know how to refer to a type-level thing at term level? That is, how can I do "instance Foo Bar s where foo = s", given (s :: Word8)?
10:15:22 <ceii> -1 (and all the other signals) require a response from the process since it might want to handle them in a custom way
10:15:23 <znutar> the wikipedia page on unix signals does an ok job explaining it
10:15:48 <neutrino> ceii: yes, why did the ghc runtime not respond
10:15:50 <dainanaki> elliott, thanks, I was kind of hoping to avoid the overhead of making libffi calls if at all possible.
10:15:56 <neutrino> i do not create any handlers that i know of
10:16:02 <neutrino> so it should all work in a default way
10:16:10 <elliott> dainanaki: Have you checked the GHC commentary?
10:16:53 <ceii> elliott: no idea if that's possible at all, but have you tried ScopedTypeVariables?
10:17:24 <ceii> actually no
10:17:32 <ceii> that s should be scoped already
10:17:39 <elliott> ceii: It's on. But no, it shouldn't.
10:17:43 <elliott> The "s" is at type level, but I'm using it at term level.
10:18:07 <dainanaki> elliott: I didn't see much about FFI interaction in it, maybe I missed it?
10:18:07 <hpc> neutrino: one neat thing the GHC runtime does is when it gets one ^C, it passes it to the program; the second ^C tells the RTS to stop everything and ignore custom handlers
10:18:10 <elliott> What we need is some magical term <reflect e> where e is interpreted at "type-level" that corresponds to its term-level equivalent.
10:18:11 <ceii> yes, I mean STVs shouldn't make anything work if it didn't without it
10:18:22 <elliott> dainanaki: I was responding to your calling convention question.
10:18:25 <neutrino> hpc: i have sent like 5.
10:18:55 <dainanaki> elliott: right. I'm saying I don't see much with regards to how it handles FunPtrs
10:19:54 <byorgey> elliott: in order to reflect type-level things at the term level you need a type class to do the reflection for you
10:20:23 <elliott> byorgey: Right, but consider:
10:20:30 <elliott> class Foo s where reflect :: Proxy s
10:20:30 <acfoltzer> is there a better URL for reporting cabal bugs than http://hackage.haskell.org/trac/hackage/ ?
10:20:43 <elliott> You can implement instance Foo s where reflect = Proxy.
10:20:49 <elliott> But you can't do this if (s :: ... oh, hmm.
10:20:55 <elliott> byorgey: Thanks, that may have given me an idea.
10:21:19 <elliott> My new problem is: "instance Foo 0", "instance Foo '0", "instance Foo ('0)" are all invalid syntax. How can I give a type-level Word8 literal?
10:21:27 <byorgey> elliott: class ToNat (n :: Nat) where toNat :: Nat;  instance ToNat Zero where toNat = Zero, etc.
10:21:44 <ceii> elliott: primitive types aren't promoted yet
10:21:48 <byorgey> elliott: you can't yet promote any literals other than tuples and lists, sadly.
10:21:52 <elliott> byorgey: So the only numeric type I can use is Nat? I see :/
10:22:07 <byorgey> elliott: you can use any numeric type you can define, as long as it isn't primitive.
10:22:11 <elliott> byorgey: Are Nats really Peano? I assumed the main benefit was efficient machine-word representation.
10:22:47 <byorgey> elliott: um, I forget whether Iavor Diatchki's work on specific support for type-level Nats is in 7.4.1
10:23:02 <byorgey> I was just using Nat as an example assuming you had defined  data Nat = Zero | Succ Nat
10:23:05 <elliott> Oh, it looks like you have to define your own Nat type, going by the documentation.
10:23:09 <elliott> Right. Oh well, thanks anyway.
10:23:24 <byorgey> but if Iavor's work is in 7.4.1 then Nat is more specialer than that, and I think is more efficient as well
10:23:40 <elliott> "Nat" isn't in scope, so I guess not.
10:23:52 <byorgey> well, presumably there would be some other extension you have to turn on.
10:24:45 <elliottt> Iavor's work is still unmerged
10:24:51 <jedai> You have to import something (GHC.Nat ?)
10:24:53 <elliottt> maybe 7.6 :)
10:24:56 <byorgey> OK.
10:25:24 <jedai> elliottt: Really ? Too bad, the manual pages were interesting and promising
10:26:06 <elliottt> yeah.  he has a standalone solver working for the constraints, but it hasn't been integrated back into ghc yet.
10:26:10 <elliottt> (last i had heard)
10:26:33 <byorgey> anyway, if anyone ever has more questions about promotion/poly kinds, feel free to ping me here
10:26:48 <neutrino> what is promotion, byorgey?
10:26:51 <byorgey> but keep in mind it's work-in-progress, there are likely to be bugs and unsupported things =)
10:27:14 <neutrino> i understand it's some sort of creation of a type-level representative of a value
10:27:15 <byorgey> neutrino: a new feature that lets you automatically "promote" data types to be kinds
10:27:26 <neutrino> oh
10:27:33 * neutrino doesn't know what kinds are
10:27:46 <byorgey> neutrino: kinds classify types, just like types classify values
10:28:03 <byorgey> neutrino: * is the kind of concrete types such as 'Int' or 'Maybe Bool'
10:28:03 <neutrino> how do kinds relate to typeclasses?
10:28:19 <byorgey> they're pretty much orthogonal
10:28:25 <neutrino> oh kinds are this "shape of graph" thing
10:28:26 <byorgey> neutrino: but 'Maybe' has kind * -
10:28:29 <byorgey> argch
10:28:36 <neutrino> aren't they?
10:28:39 <byorgey> neutrino: but 'Maybe' has kind * -> *, which means it takes a type and returns a type
10:28:46 <byorgey> "shape of graph"?
10:29:00 <neutrino> yeah, the kind is the arrows-and-stars thing
10:29:03 <byorgey> yep
10:29:18 <neutrino> and depending on what's there, the same combination of arrows and stars gives us the same kind, yes?
10:29:46 <neutrino> so it's like a graph, but we erase all values. we're just left with the shape.
10:30:20 <neutrino> just a silly way for me to remember what those are
10:30:24 <byorgey> not really?
10:30:30 <byorgey> I'm not quite following you.
10:30:45 <neutrino> it's just a mental shortcut. it's likely not to make sense to anyone but me.
10:31:09 <byorgey> The kind of Maybe is * -> *, I don't see any sense in which * -> * records the "erased shape" of anything
10:31:15 <neutrino> byorgey: above, i think elliott tried promoting "0" which is a literal for an integer, so a value
10:31:44 <byorgey> neutrino: right, promotion allows you to promote a type to be a kind, and the data constructors of that type to be type constructors
10:31:50 <strager> @pl (\(a,b) -> a:b:)
10:31:50 <lambdabot> (line 1, column 16):
10:31:50 <lambdabot> unexpected ")"
10:31:50 <lambdabot> expecting white space or simple term
10:31:55 <neutrino> aha
10:31:59 <strager> @pl (\(a,b) xs -> a:b:xs)
10:31:59 <lambdabot> uncurry ((. (:)) . (.) . (:))
10:32:09 <byorgey> so if you were allowed to promote, say, Int, you would have a kind called Int, and types called 0, 1, 2, ... with kind Int
10:32:16 <byorgey> (however, you can't yet promote primitive types)
10:32:53 <neutrino> is it going to be possible soon?
10:33:15 <byorgey> neutrino: unless something goes horribly wrong it will be possible in 7.6.
10:33:28 <neutrino> does this mean we can then do Vector[n] ?
10:33:52 <hpc> neutrino: you already can, with the more appropriate type of Nat
10:33:53 <byorgey> neutrino: sure, though you can already do that if you use  data Nat = Zero | Succ Nat
10:33:56 <neutrino> as opposed to Vector2, Vector3, Vector4, ...
10:34:04 <neutrino> byorgey: aha
10:34:11 <neutrino> byorgey: i didn't know you could do that
10:34:24 * byorgey should really write a blog post or two about this
10:34:37 * byorgey adds it to his to-do list
10:34:48 <ceii> byorgey: what's the plan for promoted primitive operations? turn them into typefamilies?
10:34:49 <neutrino> byorgey: but i was also wondering if we can do sort of dependant-type stuff with promotion
10:35:10 <byorgey> neutrino: yes, you can
10:35:15 <neutrino> ok
10:35:26 <byorgey> ceii: that's an excellent question.  I don't really know.
10:35:44 <neutrino> just to make everything 100% clear for me, a type constructor is e.g. Maybe a for the type Maybe, yes?
10:36:00 <neutrino> i'm not sure what the difference between a type and type constructor is
10:36:13 <elliottt> a type constructor takes a type and makes a new one
10:36:15 <byorgey> neutrino: there's not really any difference
10:36:24 <ceii> neutrino: the type constructor is simply "Maybe". It has kind "* -> *" because it needs a type parameter to make an actual type
10:36:27 <neutrino> so Maybe is a type constructor?
10:36:29 <neutrino> ok
10:36:38 <neutrino> just like (,) is a type constructor? and [] ?
10:36:38 <byorgey> neutrino: sometimes the term "type constructor" is used specifically to talk about things with a kind other than *
10:36:48 <neutrino> byorgey: ahh
10:36:52 <byorgey> neutrino: however, I was using it more generally to just mean "types"
10:37:00 <byorgey> neutrino: in parallel with "data constructor"
10:37:02 <neutrino> ok gotcha
10:37:15 <neutrino> i think just saying "types" is easier to understand there
10:37:17 <byorgey> we don't distinguish between "data constructors" like Just and "data" like Nothing, we just call them both "data constructors"
10:37:30 <byorgey> so when you promote data constructors you get type constructors.
10:37:31 <neutrino> imo less words = better always
10:37:42 <byorgey> yes, you're probably right in this case =)
10:37:46 <neutrino> :)
10:38:12 <ceii> alright, here's your complete explanation of promotion:
10:38:16 <ceii> "stuff happens"
10:38:23 <byorgey> TOO MANY WORDS
10:38:31 <neutrino> i haven't used haskell for a long time, i know what types are :)
10:38:49 * byorgey goes to eat some spaghetti
10:38:53 <neutrino> but i've not heard about "type constructors" often enough, so in my mind they were different
10:39:07 <neutrino> but i guess someone who knows what "type constructors" are will understand "types" just as well :)
10:39:14 <neutrino> so "types" is more compatible with people ;)
10:39:26 <elliott> They aren't the same thing; I think byorgey's use was a misuse.
10:39:49 <ceii> we often use "type constructor" to refer to a basic building block for types
10:40:01 <nand`> are expressions of the type (a) functions?
10:40:07 <nand`> err
10:40:16 <nand`> bad example
10:40:17 <byorgey> elliott: I think the semantic domains for "type" and "type constructor" are fuzzier than you would like to believe.
10:40:25 <nand`> > let x = 5 in x
10:40:26 <lambdabot>   5
10:40:27 <nand`> is x a function?
10:40:31 <ceii> simple concrete types like "Int" or "Bool", and simple functions from types to types, like "Maybe" and "->"
10:40:35 <byorgey> but I agree to use "types" from now on when describing what you get when you promote a data constructor.
10:40:35 <hpc> > let x = 5 in x 5
10:40:36 <lambdabot>   5
10:40:40 <hpc> yes ^^
10:40:45 <nand`> (and no, don't mention the (Num (a -> a)) instance now)
10:40:49 <elliott> byorgey: I agree on "type" but I see "type constructor" universally used for things of higher kinds.
10:40:50 <nand`> damn
10:40:53 <nand`> too slow
10:41:09 <yrlnry> I remember having this discussion about "type" and "type constructor" before.
10:41:23 <byorgey> elliott: I was just pointing out that this is inconsistent with the use of "data constructor" to refer to both things that do and don't take arguments.
10:41:32 <hpc> handy rule: the "FOO constructors" are the things with capitalized names
10:41:33 <yrlnry> I thought the consensus was that a "type" is the same as a "type constructor" that has kind * -> *.
10:41:39 <yrlnry> Er, kind *.
10:41:40 <hpc> yrlnry: no
10:41:47 <hpc> er, yes
10:41:49 <hpc> er, maybe
10:41:57 <hpc> what i said above
10:41:57 <byorgey> see what I mean? =)
10:42:05 <yrlnry> I guess you might want to distinguish between the Int type constructor and the type that it constructs.
10:42:10 <ceii> hoc gets my vote, for what it matters :)
10:42:15 <ceii> hpc*
10:42:15 <byorgey> yrlnry: indeed.
10:42:24 <yrlnry> Okay.
10:42:28 <hpc> if it starts with a capital letter, it's a constructor
10:42:34 <hpc> (or a module name, but ignore that)
10:42:45 <ceii> you mean module constructor
10:42:46 <hpc> if it is in a value position, it's a data constructor
10:42:53 <hpc> if it is in a type position, it's a type constructor
10:43:02 <hpc> "Int" -- Int is a type constructor
10:43:09 <hpc> "Maybe a" -- Maybe is a type constructor
10:43:11 <nand`> does [] start with a capital letter :P
10:43:13 <yrlnry> Come to think of it, failing to distinguish between data and data constructors is a common source of mistakes.
10:43:22 * hackagebot vty 4.7.0.10 - A simple terminal access library  http://hackage.haskell.org/package/vty-4.7.0.10 (CoreyOConnor)
10:43:27 <hpc> "Either Int x" -- Either and Int are both type constructors
10:43:32 <hpc> Nothing is a data constructor
10:43:38 <hpc> etc, etc
10:43:50 <byorgey> hpc: yes, I like that approach.
10:43:54 <ceii> also, vector is a package but Cabal is a package constructor =)
10:44:06 <nand`> ceii: good one
10:44:12 <hpc> 'id' is a value
10:44:16 <hpc> 'm' is a type
10:44:22 <byorgey> it *is* true that historically the terms "type" and "type constructor" have sometimes been used to distinguish between things of kind * and things of kind * -> *.
10:44:28 <rwbarton> so what is "Either Int"?
10:44:30 <byorgey> for example in extending type classes to "constructor classes".
10:44:41 <byorgey> rwbarton: it is a type of kind * -> *.
10:44:52 <hpc> rwbarton: what's "Left True"?
10:44:59 <rwbarton> a value obviously
10:45:05 <nand`> rwbarton: partially applied type constructor
10:45:06 <rwbarton> I am just asking
10:45:06 <byorgey> however, I think a slavish prescriptive insistence on this terminology is not very helpful.
10:45:26 * byorgey should write a blog post about this too
10:45:34 <hpc> that too
10:45:46 <hpc> the terminology only helps you to learn what makes each one special
10:45:51 <hpc> and to ease communication
10:45:53 <jedai> hpc: rwbarton: Well now it could be a type too :)
10:46:05 <hpc> once you know the differences, just remember those
10:46:23 <dainanaki> The problem is that the words type and kind are so similar in meaning in the English language.
10:46:34 <cmccann> byorgey, a slavish adherence to consistent terminology is helpful
10:46:51 <cmccann> insistence on particular terminology may not be
10:46:59 * fryguybob_ should write a blog post about how byorgey should write more blog posts.
10:47:00 <byorgey> cmccann: I agree
10:47:24 <byorgey> fryguybob_: I agree
10:47:28 <cmccann> that said, I'd define constructor as "introduces a new, unique entity"
10:47:55 <cmccann> data constructors are the only ways to introduce data that is neither a function nor a built-in primitive
10:47:56 <byorgey> cmccann: right, that's I think what hpc was getting at, and I think that's the more useful distinction to make with "type" vs "type constructor"
10:48:16 <byorgey> and it would then be the same as the existing distinction between "data" and "data constructor"
10:48:36 <byorgey> we already have kinds to distinguish things of different kinds.
10:48:45 <cmccann> byorgey, right, "data Foo = ..." introduces a new entity Foo that can't come from anywhere else
10:48:47 <byorgey> we don't need a special term that means "something that doesn't have kind *"
10:48:56 <byorgey> cmccann: right
10:49:13 <nand`> “Maybe is a type of kind * -> *”
10:49:27 <byorgey> nand`: right. and it is also a type constructor of kind * -> *.
10:49:29 <nand`> “Maybe is a type constructor”
10:49:32 <nand`> that's like what
10:49:33 <nand`> two keystrokes?
10:49:47 <byorgey> indeed
10:50:38 <nand`> so who votes for removing the term “constructor” altogether?
10:50:47 <nand`> “Just is a value of type a -> Maybe a”
10:50:53 <byorgey> not me.
10:50:55 <mekeor> what's the difference between "foo :: a" and "foo :: *" ? (or "foobar :: * -> *" and "foobar :: a -> a") actually?
10:51:01 <cmccann> byorgey, I would also go the other way and say that "Either Foo" is not a type constructor, but Either and Foo individually are
10:51:09 <nand`> mekeor: the first is a type, the second is a kind
10:51:16 <nand`> values have types. types have kinds
10:51:18 <byorgey> nand`: but the fact that Just is a constructor means it can be used to do pattern-matching.  that's not true of any old thing of type  a -> Maybe a.
10:51:18 <nand`> does that make sense?
10:51:27 <byorgey> cmccann: exactly.
10:51:32 <nand`> byorgey: good point
10:51:36 <mekeor> nand`: cool. ty! :)
10:52:02 <cmccann> byorgey, if the language gave first-class support for known invertible functions we wouldn't need constructors
10:52:14 <cmccann> since the purpose of a data constructor is to be a trivially injective function
10:52:20 <cmccann> and pattern matching pulls the arguments back out
10:52:26 <byorgey> heh, that would be nifty
10:52:27 <nand`> so a good balance would be just using “type” for all types, and then distinguishing between “value” (of any type) and “constructor”?
10:52:36 <nand`> (value constructor is redundant with this definition)
10:52:39 <byorgey> although I'm not sure I buy the argument that that's the ONLY purpose for constructors
10:52:42 <cmccann> byorgey, it'd be like fixing n+k patterns and making that the default :P
10:52:55 <nand`> plus, using just “constructor” throws off the C++ crowd even more :P
10:52:58 <nand`> now they have classes and constructors
10:53:05 <cmccann> fair, it's certainly not the only use
10:53:18 <CodeWeaver> Huh, apparently there's anther CodeWeaver with a registered nickname on here (infrequently).
10:53:20 <CodeWeaver> How irritating.
10:53:29 <rwbarton> this type/type constructor terminology is sensible enough but it's not compatible with e.g. the Haskell 98 report
10:53:35 <nand`> yeah, there's another nand here as well. It's not exactly an original name though
10:53:42 <rwbarton> "Since Haskell is a non-strict language, all Haskell types include _|_."
10:53:53 <cmccann> byorgey, though I'd speculate that the purpose I gave implies other all uses of constructors
10:54:08 <shachaf> rwbarton: The Report's terminology isn't always great.
10:54:18 <byorgey> rwbarton: duly noted.
10:54:26 <shachaf> The Report calls getLine a function.
10:54:31 <cmccann> I think the report is using the convention of "type" means "things inhabited by values"
10:54:37 <rwbarton> no, but this kind of language is in common use and I think it's confusing to disregard the fact that people often speak this way
10:54:40 <rwbarton> yes
10:54:42 <ceii> shachaf, it is, there's an arrow in its type
10:54:48 <shachaf> ceii: There is?
10:54:54 <ceii> ah, no
10:55:00 <shachaf> http://www.haskell.org/onlinereport/io-13.html
10:55:07 <ceii> brb, lemme buy a pair of glasses
10:55:16 <nand`> getLine is an IO value
10:55:16 <byorgey> rwbarton: I agree. I'm certainly not disregarding that fact.
10:55:16 <cmccann> shachaf, RealWorld -> (RealWorld, String) ? :D
10:55:21 <shachaf> cmccann: Go away.
10:55:23 <cmccann> :D
10:55:43 <CodeWeaverX> X's in a name are always cooler, right?
10:55:46 <CodeWeaverX> :P
10:55:58 <shachaf> They are in #cohaskell.
10:56:01 <byorgey> definitely.  even cooler still would be CodeWeaverX3000
10:56:16 <CodeWeaverX> Hahahahaha
10:56:21 <CodeWeaverX> I'm not that cool.  Also I'd forget the number.
10:56:27 <shachaf> Have you considered sticking a few Xs on the other side?
10:56:34 <cmccann> CodeWeaverX, maybe if you used CodeWeaver⊗ instead
10:56:40 <cmccann> that's a much cooler x
10:56:42 <CodeWeaverX> O.o
10:56:47 <CodeWeaverX> I don't even know how to type that.
10:56:48 <shachaf> cmccann: What about ×?
10:56:51 <shachaf> That's more subtle.
10:57:01 <cmccann> shachaf, hm, subtlety is nice
10:57:12 <CodeWeaverX> Then it just looks like part of the word Weaver.  Weaverx?  How do you even pronounce that?
10:57:18 <CodeWeaverX> Wee-verkz
10:57:24 <shachaf> #not-haskell
10:57:26 <cmccann> We Aver X
10:57:47 <shachaf> We were in the middle of a pointless argument about terminology and definitions. Please.
10:57:56 <yrlnry> Most IRC servers also forbid any interesting characters in nicknames anyway.
10:58:01 <CodeWeaverX> heheheh
10:58:01 <CodeWeaverX> I think I'll stick with this.  I can live with it.  And remember it.
10:58:06 <nand`> “so a good balance would be just using “type” for all types, and then distinguishing between “value” (of any type) and “constructor”?” <-- going to amend this, this doesn't make clear the distinction between parameterless value constructors and values (eg. getLine, you can't pattern match on getLine)
10:58:15 <CodeWeaverX> shachaf:  Please, return to your mindless bantering!  I insist!
10:59:30 <cmccann> CodeWeaverX, how about 𝕮𝕺𝕯𝕰𝖂𝕰𝕬𝖁𝕰𝕽, does that work?
10:59:46 <CodeWeaverX> o.o
10:59:49 <cmccann> (this is Haskell related because I used a Haskell program to get the unicode :P)
10:59:55 <CodeWeaverX> HAHAHAHAHAHA
11:00:02 <CodeWeaverX> cmccann wins
11:00:02 <shachaf> cmccann: I see a bunch of question marks.
11:00:18 <shachaf> Which is how Haskell makes you feel, if you're doing it right.
11:00:47 <cmccann> shachaf, your font is suboptimal
11:00:47 <nand`> cmccann: I see a bunch of boxes. What language or fontset is that supposed to be from, so I can install the appropriate fonts?
11:01:05 <cmccann> bold fraktur uppercase letters
11:01:22 <cmccann> from unicode's "funny ways mathematicians write letters" section
11:01:22 <shachaf> cmccann: What's the code point?
11:01:43 <shachaf> Is this a non-BMP character?
11:01:44 <cmccann> how about "\120174\120186\120175\120176\120194\120176\120172\120193\120176\120189"
11:01:53 <cmccann> > "\120174\120186\120175\120176\120194\120176\120172\120193\120176\120189"
11:01:54 <lambdabot>   "\120174\120186\120175\120176\120194\120176\120172\120193\120176\120189"
11:01:58 <cmccann> pf
11:02:13 <shachaf> Ah.
11:02:19 <shachaf> It's not my font, it's my IRC client.
11:02:30 <shachaf> > text "\120174\120186\120175\120176\120194\120176\120172\120193\120176\120189"
11:02:31 <lambdabot>   mueval-core: <stdout>: hPutChar: invalid argument (Invalid or incomplete mu...
11:02:35 <shachaf> Thanks, lambdabot.
11:02:37 <cmccann> :D
11:03:13 <cmccann> > text "\120164\120153\120146\120148\120153\120146\120151"
11:03:14 <lambdabot>   mueval-core: <stdout>: hPutChar: invalid argument (Invalid or incomplete mu...
11:03:23 <cmccann> yeah, oh well
11:03:53 <nand`> what module is “text” from
11:07:08 <ion> drsyzygy: Some graphs (no pun intended – drawings with G₀, G₁, f₀, f₁ pointed out and examples of the various types of graphs) would be very useful in the section about graphs.
11:08:10 <DrSyzygy> ion: Yup. This here is a pure TeXing of my lecture notes -- when I gave the class, I drew a few on the blackboard.
11:08:18 <Rc43> Hi, guys.
11:08:54 <mekeor> Rc43: hi :)
11:09:19 <ion> drsyzygy: Getting them to the PDF for the rest of us would be much appreciated. :-) Or perhaps capturing the lectures on video.
11:09:45 <DrSyzygy> ion: Too late for that. However, DO notice that the pdf in its current stage is a very early alpha.
11:10:00 <DrSyzygy> I've noted your comment, and one of the things to do on my upcoming revision runs is to produce a lot more graphics.
11:10:05 <DrSyzygy> But don't expect it this week.
11:10:08 <ion> drsyzygy: Great, thanks.
11:10:19 <ion> drsyzygy: Absolutely no hurry. :-) Thanks for the effort.
11:10:24 <DrSyzygy> esp. since this is not explicitly sanctioned by my PI and the project htat pays my salary. ;-)
11:10:32 <ion> heh
11:10:40 <DrSyzygy> ion: Apart from the lack of graphs, does it seem ... fruitful? Could this be something that's of real help and support?
11:13:42 <ion> drsyzygy: I for one will find it very helpful. An “easy” (FSVO easy) guide to CT for someone who knows Haskell is something i have failed to find before, and this looks very approachable. I’m a bit stuck after the first reading of the Graphs section, but i’ll try to make some drawings for myself. That should help. Btw, one-sentence descriptions about the things in the “What do we require?” list
11:13:43 <ion> would be useful, too.
11:14:32 <strager> Is there an easy way to get a bool if something matches?
11:14:46 <strager> Like, case x of Foo -> True ; _ -> False
11:14:53 <strager> Where Foo is any pattern
11:15:36 <cmccann> that is the easy way, I think
11:16:03 <cmccann> in some cases abusing list comprehensions for the "pattern match failures return []" behavior might help
11:16:08 <cmccann> but it's the same idea
11:16:17 <ceii> isJust $ x >>= \Foo -> return () is fun but not much more readable
11:16:29 <strager> Hmm; comprehensions may work
11:16:31 <ceii> oops no, you need do notation
11:16:34 <strager> Though I try not to use them ;P
11:16:45 <ceii> isJust $ do Foo <- x ; return ()
11:16:48 <cmccann> > [True | (Just _, Nothing) <- [(Just 4, Nothing)]]
11:16:49 <lambdabot>   [True]
11:16:52 <cmccann> > [True | (Just _, Nothing) <- [(Nothing, Nothing)]]
11:16:53 <lambdabot>   []
11:17:02 <cmccann> > or [True | (Just _, Nothing) <- [(Nothing, Nothing)]]
11:17:03 <lambdabot>   False
11:17:07 <cmccann> > or [True | (Just _, Nothing) <- [(Just 4, Nothing)]]
11:17:08 <lambdabot>   True
11:17:16 <cmccann> or something along those lines
11:17:37 <cmccann> and yeah, do notation works as well
11:18:32 <ion> drsyzygy: For me the reason for getting stuck is that by the time i read “a pair of functions f₀ : G₀ → H₀ and f₁ : G₁ → H₁” the definitions of the subscript numbers have already became fuzzy in my mind (something like G_{nodes} and G_{arrows} would be much easier) and that happens recursively when things refer to f₀ and f₁. :-) (Again, f_{nodes} and f_{arrows} would be much easier.)
11:18:33 <ion> When i have drawings, reminding myself about the definitions takes just a glance instead of reading a paragraph.
11:18:48 <strager> Still not as readable =[
11:19:22 <ceii> strager: go join the "We want first-class patterns" club
11:19:37 <cmccann> or use Template Haskell
11:19:41 <ceii> so some day we'll be able to define match :: Pattern a -> a -> Bool
11:19:45 <cmccann> which is much uglier but you can hide the ugliness
11:21:03 <nand`> Is GHC 7.x easy to build from source?
11:21:24 <c_wraith> I built 7.3 from source at one point
11:21:27 <c_wraith> It wasn't too bad
11:21:27 <ceii> nand`: sure, if you're OK with waiting a few hours
11:21:32 <c_wraith> Just a matter of following directions
11:22:07 <ceii> I never had unforseen problems when building ghc from source
11:22:18 <ceii> only a *lot* of scrolling make output ^^'
11:22:58 <ion> nand: In case you just want a newer version than what’s provided by your distribution, i’ve found it trivial to get the prebuilt binary and install it to ~/.ghc (so i have ~/.ghc/bin/ghc) and cabal to ~/.cabal (so i have ~/.cabal/bin/cabal).
11:23:14 <ion> Then just add those paths to the beginning of $PATH.
11:23:27 <strager> Why isn't this working?  let xs = [Just 2,Just 3,Nothing,Just 4] in [x | x <- xs, (Just _) <- x]
11:23:39 <ceii> not prebuilt binaries! where's the romantism?
11:23:40 <ion> x isn’t a list.
11:23:49 <strager> catMaybies, basically
11:23:59 <strager> ion: oh, duh
11:24:14 <strager> So I'm back to square one I think.
11:24:30 <ceii> [x | Just x <- xs]
11:24:42 <strager> I'm an idiot.
11:24:49 <c_wraith> I did have one issue with safe haskell
11:25:02 <c_wraith> but I think recent fixes to safe haskell should make that irrelevant
11:25:16 <nand`> ion: interesting, if I just grab the binary won't I be missing a lot of obscure dependencies though?
11:25:23 <nand`> like some of the GHC. modules
11:25:48 <ceii> nand`, the binary dists come with everything
11:25:52 <nand`> ah
11:26:04 <ceii> you only need a gcc from the last 15 years and gmp-4
11:26:14 <strager> Thanks ceii
11:26:18 <c_wraith> yeah, the binary dists are the way to go unless you really want to play with an unreleased feature
11:26:47 <ceii> strager: you're welcome
11:28:09 <zzo38> I made something, seem to be, a monad from any contravariant functor, similar to the "infinite-search" package but more generalized
11:28:22 * hackagebot hledger-interest 1.4 - computes interest for a given account  http://hackage.haskell.org/package/hledger-interest-1.4 (PeterSimons)
11:28:33 <nand`> alright, I'll download the GHC 7.4.1 binary
11:28:52 <nand`> I assume it's no different than building from source considering I won't (most likely) be changing any build options
11:28:58 <zzo38> newtype FromContra f x = FromContra { runFromContra :: f x -> x }; fmap f (FromContra x) = FromContra (f . x . contramap f); return = FromContra . const; join (FromContra x) = FromContra $ \y -> runFromContra (x $ contramap (($ y) . runFromContra) y) y;
11:29:17 <zzo38> nand`: What are differences from 7.4.1 with 7.0.3?
11:29:43 <nand`> zzo38: no idea
11:29:46 <nand`> I don't have 7.0.3
11:29:56 <nand`> I have 6.12.1
11:29:57 <ceii> zzo38: release notes here: http://www.haskell.org/ghc/docs/7.4.1/html/users_guide/release-7-4-1.html
11:30:03 <ceii> they're magistral
11:31:31 <schlicht> Hey, i'm looking for interessing open source projects in haskell (or something other functional) thats looking for help. But im no expert :)
11:32:10 <zzo38> I don't really like that implementation of constraint kinds; I would like a kind called & which acts like that but with many differences, I have discussed on #esoteric some people have answered me too.
11:32:36 <cmccann> schlicht, as a rule of thumb all open source projects are interesting, otherwise nobody would start them, and they're all looking for help, because no software project is ever complete
11:32:47 <ceii> I'm pretty sure #esoteric is one of the worst possable channels to get opinions from
11:32:52 <ceii> possible*
11:32:53 <nand`> cmccann: great! that narrows it down to about 30
11:33:05 <zzo38> ceii : It might be; I meant I was discussing with one particular person who was on there
11:33:26 <zzo38> schlicht: I have one program in Haskell I was asking help with.    http://sprunge.us/gbUF
11:33:32 <cmccann> zzo38, do you have a description of your idea somewhere?
11:33:57 <zzo38> cmccann: Look at the IRC logs for the #esoteric channel. I will look and tell you the timestamp
11:34:10 <zzo38> It also described my idea for the + kind as well as the & kind
11:35:02 <cmccann> zzo38, ok
11:35:15 <schlicht> cmccann, do you know where i can find a list of os projects that uses a  functional language?
11:35:37 <schlicht> zzo38, i will take a look and try to understand what it is :)
11:35:44 <Eduard_Munteanu> schlicht: not sure about a list, but there's House
11:35:57 <schlicht> Eduard_Munteanu, House?
11:36:04 <Eduard_Munteanu> @where house
11:36:04 <lambdabot> http://programatica.cs.pdx.edu/House/
11:36:50 <cmccann> schlicht, everything on hackage, or search github by language?
11:37:11 <schlicht> cmccann, good idea!
11:37:37 <cmccann> schlicht, it might be easier if you narrow down what kind of project you'd like to contribute to, there's a lot of stuff out there
11:38:41 <zzo38> cmccann: Timestamp is 1327887287 look around there.
11:38:44 <cmccann> schlicht, it's like going to a zoo and asking someone where to find a neat animal to look at :P
11:39:23 <schlicht> cmccann, yeah and he could say, take a look at lions!
11:39:27 <schlicht> :P
11:39:31 <Eduard_Munteanu> schlicht: oh, there's this as well: http://www.haskell.org/haskellwiki/Applications_and_libraries
11:40:16 <schlicht> cmccann, im intressted in compiler construction, but im new in that area.
11:40:22 <schlicht> Eduard_Munteanu, thanks :)
11:40:28 <Eduard_Munteanu> Didn't he say something about OSes?
11:40:55 <Eduard_Munteanu> Unless "where i can find a list of os projects" was a typo.
11:41:10 <cmccann> schlicht, there's quite a bit related to that on hackage, so that might be a good start
11:41:48 <ceii> ghc is also the world's most powerful nuclear fusion compiler
11:41:56 <schlicht> cool cool, i will take a look.  i also liked if my code is actually used by someone other than myself :)
11:41:58 <ceii> and it's open-source :)
11:42:11 <mekeor> will "length" be replaced by "genericLength" in future? (and also the other functions taking an Int in Data.List..)
11:42:34 <ceii> mekeor: everyone wishes for it
11:42:39 <schlicht> ceii, yeah but i think thats a little too big for me :)
11:42:45 <ceii> but for some strange reason it hasn't happened yet
11:42:46 <cmccann> mekeor, that is one of the reasons I've started using my own replacement prelude :P
11:42:49 <mekeor> ceii: hehe :)
11:42:57 <mekeor> cmccann: hehe :)
11:43:09 <Eduard_Munteanu> There's also the option of using a different alternate Prelude altogether (though I haven't looked closely at those).
11:43:22 * hackagebot bytestring-lexing 0.4.0 - Parse and produce literals efficiently from strict or lazy bytestrings.  http://hackage.haskell.org/package/bytestring-lexing-0.4.0 (WrenThornton)
11:43:23 <Eduard_Munteanu> I mean, for your particular stuff.
11:43:25 <cmccann> Eduard_Munteanu, that's a gigantic pain though
11:43:29 * cmccann has tried
11:43:30 <nand`> Is it normal for GHC to only use one core while building? is there a flag like -j x to try and use more resources?
11:43:37 <hpc> nand`: nope
11:43:38 <Eduard_Munteanu> cmccann: hm, in what way?
11:43:48 <hpc> nand`: something ive wanted for a while
11:43:50 <cmccann> Eduard_Munteanu, incompatibility with everything everywhere
11:43:55 <ceii> nand`, cabal-install can take a -j flag
11:44:04 <ceii> since the last SoC
11:44:07 <zzo38> There is length and genericLength; I don't like either type signature. I prefer:  length :: Peanoid x => [y] -> x;    (Peanoid is a specific kind of pointed unary system)
11:44:07 <nand`> ceii: that's great, I'm using cabal-install
11:44:14 <Eduard_Munteanu> cmccann: can't everything else use the normal Prelude?
11:44:29 <Eduard_Munteanu> I mean, what's the actual problem, namespace issues?
11:44:47 <cmccann> Eduard_Munteanu, it depends on how much you're replacing
11:45:07 <cmccann> Eduard_Munteanu, but think of all the fun with different string types
11:45:23 <zzo38> cmccann: Have you looked at my things I have discussed about & and + kinds?
11:45:30 <cmccann> now imagine that using every library is like that, and on basic types like numbers
11:45:31 <Eduard_Munteanu> Oh.
11:45:53 <cmccann> zzo38, no, haven't gotten to it yet, gimme 15min or so
11:45:54 <Eduard_Munteanu> Yeah, I guess you need a relatively conservative alternate Prelude, not complete overhauls.
11:46:00 <cmccann> Eduard_Munteanu, right
11:47:32 <cmccann> Eduard_Munteanu, last time I tried it, replacing Num or Monad alone added enough incompatibility that replacing absolutely everything is probably easier than a mixture
11:48:11 <Eduard_Munteanu> cmccann: nah, I guess I'd be happy with a Prelude that at least uses typeclasses for basic operations.
11:48:22 * hackagebot nixos-types 1.3 - Data types representing the Nix language  http://hackage.haskell.org/package/nixos-types-1.3 (PeterSimons)
11:48:24 <cmccann> Eduard_Munteanu, so I gave up on that and now I just have a very conservative, 99%-compatible alternate prelude for my own projects
11:48:25 <nand`> I want a prelude with (++) = mappend
11:48:38 <Eduard_Munteanu> Fixing theoretical issues like Monads being more than monads is going to be painful, yeah.
11:48:41 <cmccann> that does things like use generic functions, eliminates partial functions like head, and yes uses (++) for mappend
11:48:43 <ion> AFAIU a new version has (<>) = mappend
11:49:01 <Eduard_Munteanu> cmccann: yeah, exactly
11:49:09 <cmccann> https://github.com/isomorphism/Overture if anyone wants to see
11:49:11 <Eduard_Munteanu> Is there anything like that on Hackage, though?
11:49:13 <cmccann> very much a work in progress
11:49:18 <cmccann> not fit for public consumption yet
11:49:35 <ion> Half of what’s in Hackage isn’t fit for public consumption anyway, just upload it. ;-)
11:49:46 <cmccann> actually don't think I ever got a hackage account set up
11:49:52 * cmccann should do that
11:49:56 <ceii> ion: <> is in the latest base, but you need to import it from Data.Monoid
11:50:16 <ion> ceii: ok
11:50:18 * cmccann would actually appreciate any feedback people have on his alternate prelude
11:50:41 <cmccann> ideas on other improvements I could make, &c.
11:50:59 <cmccann> it's really messy right now though :[
11:51:14 <zzo38> I could make up an alternate Prelude; if you added a default instance feature similar to this:   class Functor m => Monad m where { return :: a -> m a; join :: m (m a) -> m a; (>>=) :: m a -> (a -> m b) -> m b; join = (>>= id); x >>= f = join (f <$> x); }; default instance Prelude.Monad m => Monad m where { return = Prelude.return; (>>=) = (Prelude.>>=); }; default instance Prelude.Monad m => Functor m where { fmap = liftM; };   and so on
11:52:17 <ceii> cmccann: big yay for swap and dup in the Prelude
11:52:19 <ion> cmccann: Looks very nice judging from the sauce.
11:52:43 <cmccann> ceii, I think one or both of those are in the real libraries now
11:53:01 <Eduard_Munteanu> zzo38: yeah, I guess that'd be useful to preserve compatibility
11:53:22 * hackagebot hackage-db 1.2 - provide access to the Hackage database via Data.Map  http://hackage.haskell.org/package/hackage-db-1.2 (PeterSimons)
11:54:13 <zzo38> For the length and so on list operators I would have:    length :: Peanoid n => [x] -> n; (!!) :: Copeanoid n => [x] -> n -> x; replicate :: Copeanoid n => n -> x -> [x]; findIndex :: Peanoid n => (x -> Bool) -> [x] -> Maybe n;   and so on.
11:54:17 <djanatyn> is there any way that I can find out the time it takes to run a segment of haskell code?
11:54:29 <cmccann> djanatyn, have you seen criterion?
11:54:34 <djanatyn> nope
11:54:35 <byorgey> oh, hackage-db, nice =)
11:54:40 <djanatyn> I haven't really looked at anything yet.
11:54:47 <djanatyn> I was just going to use perf, but I'm not on linux
11:55:02 <jedai> djanatyn: criterion is really nice to bench code
11:55:08 <cmccann> byorgey, hey, you should look at my replacement Prelude :D
11:55:09 <djanatyn> criterion looks like exactly what I'm looking for. thanks!
11:55:17 <cmccann> since you were asking about partial functions the other day
11:55:27 <byorgey> cmccann: I was? oh! right, I was
11:55:33 <byorgey> cmccann: where is your replacement Prelude?
11:55:35 <ion> cmccann: bool :: a -> a -> Bool -> a; bool t _ False = t; bool _ t True = t (in a similar vein as maybe and either), please :-)
11:55:43 <jj_> hi there
11:55:44 <cmccann> byorgey, https://github.com/isomorphism/Overture
11:55:47 <zzo38> Eduard_Munteanu: Yes, defining the "default instance" feature like that would preserve compatibility, and explicit instances would always override default ones, and so on.
11:56:02 <zzo38> ion: I like that; I have defined that function myself in some modules (including the one I asked for help with)
11:56:07 <ion> djanatyn: Yeah, criterion is very nice.
11:56:26 <byorgey> hi jj_
11:56:31 <jj_> haskell programming is my report later, can you guys give some little advise for it? thank you
11:56:31 <cmccann> ion, that's not in there? was supposed to be, must have missed it
11:56:49 <ion> cmccann: I may have missed it, too, i just skimmed through quickly.
11:56:53 <byorgey> cmccann: nice
11:56:54 <Eduard_Munteanu> zzo38: hm, but what do you do about fail? Say you pass something that's your kind of monad to an external library.
11:57:00 <zzo38> Perhaps, do-notation should be its own class:   class DoNotation f where { doBind :: f a -> (a -> f b) -> f b; doFail :: String -> f a; }
11:57:29 <jeff_s_> What construction is "iOne c" in the insert function at http://hackage.haskell.org/packages/archive/cassy/0.2.0.3/doc/html/src/Database-Cassandra-Basic.html#insert ?
11:57:31 * cmccann has a policy of giving all simple non-recursive types an eliminator function with the lowercased name and parallel constructor/argument order
11:57:39 <jj_> wow, the "Try Haskell" is pretty good.
11:58:00 * nand` didn't like it
11:58:04 <nand`> not enough focus on functional aspects of haskell
11:58:09 <zzo38> Eduard_Munteanu: Do you think this would work, by adding an extension to change do-notation?
11:58:11 <nand`> makes it seem like “nothing special”
11:58:13 <jeff_s_> I'm pretty sure that whatever "iOne c" is, it has to have the type IO (Either CassandraException ()), but I've never seen a "let" be applied to two terms.
11:58:17 <Eduard_Munteanu> jeff_s_: it's just a let binding, defining a function
11:58:28 <byorgey> jj_: what kind of advice?
11:58:29 <jeff_s_> oh it's defining a function, I feel dumb. Thanks Eduard!
11:58:36 <jeff_s_> I don't know why that confused me.
11:58:47 <zzo38> And of course, there would be a default instance for DoNotation
11:58:52 <nand`> LYAH is better, it lets you know right off the bat about some of the awesomeness of haskell
11:59:33 <Eduard_Munteanu> zzo38: you can already rebind do syntax AFAIK
11:59:40 <jedai> zzo38: You know there already is this if you don't import the prelude (and there was an extension "Rebindable syntax" or something like that)
11:59:50 <cmccann> ion, I've actually been thinking of making a TH package to auto-generate deconstructors and related functions like that
11:59:53 <byorgey> does anyone know how one goes about creating an @haskell.org mailing list?
11:59:59 <Eduard_Munteanu> It just looks for (>>=) and such in scope.
12:00:16 <zzo38> I do know about rebindable syntax extension.
12:00:28 <ion> cmccann: Yay, ensure is nice. But isn’t ignore just (<$) flipped?
12:00:29 <cmccann> Eduard_Munteanu, including local scope, in case you want to shadow the definitions ;P
12:00:43 <zzo38> And, yes, that would do it; if you have option to change the names used for bind and fail and so on
12:00:47 <cmccann> ion, with only a Monad constraint
12:00:55 <cmccann> ion, it's kinda useless, granted
12:01:01 <ceii> cmccann: you've just set the worst part of my creativity on a rut
12:01:34 <cmccann> ion, it's there to be (<*) for writing monad combinators since I can't fix the class definitions :P
12:01:43 <hpc> byorgey: email mailman@haskell.org, perhaps
12:01:49 <cmccann> ceii, hm?
12:01:51 <jj_> just a little pointers about haskell, what its difference to other language, especially the difference of it in common language which is widely use today
12:02:02 <ceii> that part about locally rebinding do notation
12:02:09 <byorgey> hpc: I'll try
12:02:12 <cmccann> ceii, ahahaha
12:02:12 <zzo38> I do find <* and *> and <$ to be useful already
12:02:41 <hpc> byorgey: if you happen to have the right superpowers: http://www.haskell.org/mailman/create
12:02:54 <cmccann> ceii, note that replacing (==) also lets you change the meaning of e.g. numeric literals in patterns
12:03:02 <ion> cmccann: So far <* has been enough for me, but perhaps one day i’ll need a version without the Applicative constraint. :-\
12:03:11 <ceii> jj_: forget everything you know and prepare to learn programming again in the two weeks you have to make your report
12:03:14 <byorgey> jj_: we're not going to do your report for you.  have you tried looking at the information available from the haskell.org website?  e.g. you can start by looking at "What is Haskell?"
12:03:14 <hpc> :t (<*)
12:03:15 <lambdabot> forall (f :: * -> *) a b. (Applicative f) => f a -> f b -> f a
12:03:17 <ceii> the world is cruel :)
12:03:27 <byorgey> jj_: we're happy to answer specific questions.
12:03:28 <hpc> :t (<$)
12:03:29 <lambdabot> forall a (f :: * -> *) b. (Functor f) => a -> f b -> f a
12:03:31 <cmccann> ion, I have a bunch of fancy monadic unfolds that I didn't want an Applicative constraint on
12:03:34 <zzo38> <* is useful to me.
12:03:39 <nand`> I get this from cabal install xmobar, http://pastebin.com/DZATzg2J is there any sort of compatibility flag I can enable here that would fix it?
12:03:45 <jj_> oh yeah thanks for the link
12:03:47 <nand`> or do I have to get the git source and tweak that byhand
12:04:07 <jj_> i was actually browsing it a while ago and then i just got fun in trying the Try Haskell
12:04:22 <ceii> nand`, fix it by hand and send a threatening e-mail to the maintainer
12:04:35 <ceii> (a patch too, if you're a cool person)
12:04:52 <nand`> how do I access the source and write a patch?
12:05:17 <nand`> (haven't worked with cabal other than cabal install)
12:05:23 <ceii> to access the source of a released version you can use cabal unpack xmobar
12:05:40 <ceii> it'll unpack the source in xmobar/
12:06:29 <franco00> on debian, I  have installed haskell-platform but it seems I am not able to wun ghci (as is, it is not installed?) what do I have to apt-get?
12:06:33 <ceii> the xmobad.cabal file containts stuff like the maintainer's address and the bug tracker address
12:06:54 <ceii> you can also find that info on the package's hackage file: http://hackage.haskell.org/package/xmobar-0.14
12:07:00 <franco00> maybe haskell-platform-prog?
12:07:19 <franco00> *f
12:08:04 <eviltwin_b> franco00, haskell-platform should include ghci.  you may need to run "hash -r" in any open shells though
12:08:09 <zzo38> I think there are advantages of the & and + kinds as I have defined; one advantage to this + kind I wrote about is that the type for arrays with a fixed number of elements is one of the types already built-in to Haskell.
12:08:23 * hackagebot cabal2nix 1.25 - Convert Cabal files into Nix build instructions  http://hackage.haskell.org/package/cabal2nix-1.25 (PeterSimons)
12:08:47 <ceii> wow, there are actual, real people using Nix
12:08:54 <ceii> I wasn't aware of that
12:10:04 <luite> there are even Nix people sending hundreds of "please release x that depends on y version z" message because their package manager doesn't support multiple versions of a package installed at the same time
12:10:23 <franco00> eviltwin_b, I did what you suggested but still @command not found@ when trying 'ghci' and haskell platform is 'already the newest version'... puzzling
12:10:29 <ceii> I thought it did, and that was the whole point?
12:10:50 <ceii> franco00: just to make sure, what's your CPU architecture?
12:11:04 <franco00> ARM, using debian armhf
12:11:11 <eviltwin_b> I think you lose
12:11:16 <ceii> GHCi isn't available for ARM yet
12:11:20 <eviltwin_b> ghci doesm't work on all platforms ghc does
12:11:25 <franco00> ...
12:11:25 <eviltwin_b> yeh, that's what I thought
12:11:30 <ceii> though people are pretty actively working on it
12:11:34 * franco00 hangs himself
12:11:52 <franco00> you mean I have just bought a useless netbook? :|
12:12:00 <ceii> I'm glad I knew that before I started looking at ARM netbooks >>
12:12:03 <hpc> franco00: ghc still works...
12:12:09 <mauke> hugs?
12:12:20 * eviltwin_b would not have bought an arm netbook expecting stuff to just work...
12:12:20 * cmccann wonders what stops ghci from working when ghc does
12:12:22 <ceii> you'll have to make do with hugs
12:12:25 <hpc> you could probably write your own ghci with hint
12:12:31 <byorgey> wait, hugs is available on ARM?
12:12:39 <Eduard_Munteanu> franco00: the bright side is now you have a reason to hack on GHC :P
12:12:44 <cmccann> hpc, unless hint doesn't work either
12:12:47 <franco00> eviltwin_b, I thought that since the haskell platform package was there...
12:12:50 <ceii> hugs is written in portable C, isn't it?
12:12:51 <eviltwin_b> cmccann, as I understand it ghci has its own built in linker, and porting that is painful
12:12:58 <byorgey> ceii: oh, perhaps
12:12:59 <hpc> not even remotely as featureful, but it could do the job
12:13:11 <hpc> cmccann: hint is just some wrappers over the ghc api, i thought
12:13:14 <eviltwin_b> (there has been discussion of making that go away but I'm under the impression it's difficult with respect to loading/unloading packages)
12:13:29 <hpc> eviltwin_b: and bytecode
12:13:41 <hpc> ghc compiles to object files, but ghci also interprets
12:13:43 <franco00> so you suggest hugs, gentlemen?
12:13:44 <cmccann> hpc, it's the dynamic linking stuff I'm concerned about, that might impact hint, TH, ghci, stuff like that
12:13:48 <cmccann> but not normal use of GHC
12:13:53 <ceii> franco00: yes, for now
12:14:09 <franco00> well then, don't even know what hugs is, I will google
12:14:12 <ceii> I think GHCi on ARM is planned for ghc 7.6 or something
12:14:12 <eviltwin_b> right, I would not expect the bytecode to be difficult, the dynamic linking on the other hand is Hard Problem in general
12:14:13 <Eduard_Munteanu> Why? If GHC is available...
12:14:24 <hpc> ceii: oooold haskell interpreter
12:14:36 <Eduard_Munteanu> And yeah, Hugs is rather bitrotten, isn't it?
12:14:50 <mauke> Eduard_Munteanu: hello did you read what people said?
12:15:00 <ceii> it still works, but I wouldn't bet on using any external packages with it
12:15:09 <byorgey> franco00: I suggest sshing into something with ghci installed =P
12:15:20 <ceii> that, too :)
12:15:20 <franco00> byorgey, ehehe
12:16:04 <djanatyn> woo. criterion finally installed.
12:16:29 <Eduard_Munteanu> mauke: I did, I was just wondering if he really needs an interpreter
12:16:30 * cmccann wonders if it would be possible to implement a REPL inside TH
12:16:49 <mauke> ah
12:16:51 <c_wraith> cmccann: why not? runIO exists
12:17:01 <neutrino> cmccann: do you want something like ghci for repl?
12:17:05 <neutrino> er
12:17:15 <neutrino> cmccann: do you want something like ghci for haskell+th?
12:17:27 <c_wraith> however, using the ghc api from TH would be ugly, due to the global mutable state issues
12:17:27 <cmccann> c_wraith, yes, but a few things behave oddly when used from TH, in my experience
12:17:56 <cmccann> using the GHC API from TH doesn't work anyhow, last time I tried
12:18:09 <ceii> fire off an external process linked to the GHC API, communicate with it over a socket?
12:18:11 <cmccann> the dynamic linker whines about duplicate symbols
12:18:15 <ceii> this is getting awesome
12:18:23 <Sgeo> Can I hook GHCi-like features into my own programs easily?
12:18:27 <cmccann> since you're basically trying to load GHC inside GHC so you can compile while you compile :P
12:18:36 <cmccann> Sgeo, look at the hint package
12:18:37 <c_wraith> Sgeo: do you mean the repl or the haskell interpreter?
12:18:54 <Eduard_Munteanu> Albeit slow, you could write a script to compile something like main = print ...  :)
12:19:05 <franco00> Eduard_Munteanu, yes, prolly just ghc could do
12:19:08 <Sgeo> REPL I guess. cmccann, would hint support GHCi's new features?
12:19:16 <franco00> I mean, it's not I am gonna die
12:19:28 <cmccann> Sgeo, hint is a wrapper over the GHC API, it supports what it supports
12:19:37 <cmccann> if you want to do more, the GHC API itself is there
12:20:08 <cmccann> but using the GHC API directly is a bit clumsy
12:20:17 <Sgeo> Why doesn't GHCi expose a library?
12:20:22 <zzo38> Did you look at my stuff about + and & kinds, yet? In case you need URL, it is http://codu.org/logs/_esoteric/2012-01-30-raw.txt and the timestamp is starting at 1327887137 you can search for that timestamp inside of this file
12:20:56 <ceii> Sgeo: GHCi is GHC, there are GHCi-ish bits in the GHC API
12:21:00 <cmccann> zzo38, sorry, not quite yet :T
12:21:17 <ceii> but it feels a bit like whiever designed tha API rolled a die for every internal function
12:21:25 <ceii> if they got a 6 they exported it
12:21:31 <ceii> otherwise not
12:21:43 <Sgeo> o.O
12:22:06 <cmccann> the GHC code base is... interesting, anyway
12:22:09 <franco00> ceii, is there an eta for 7.6?
12:22:29 <ceii> franco00: don't ask me
12:22:56 <zzo38> Did they implement the Template Haskell fixed? The old one is both too strongly typed and too weakly typed. Suggest, [| ... |] checks only syntax, while [|| ... ||] includes the type of the expression as the type parameter of the type of the quotation.
12:23:06 <Eduard_Munteanu> franco00: you could extrapolate from http://www.haskell.org/ghc/ I guess :/
12:23:26 <Eduard_Munteanu> But I guess it's going to be a while.
12:23:31 <Enigmagic> zzo38: it's not fixed in 7.4
12:23:50 <zzo38> Enigmagic: Will they fix it in future? Do you know when?
12:24:21 <Enigmagic> zzo38: there is a trac ticket for it, go add yourself to the CC list if you're interested
12:24:35 <Enigmagic> i don't know what the ticket number is though
12:25:23 <ceii> lol @ 407 active tickets for milestone 7.4.1
12:25:28 <zzo38> Did you check http://sprunge.us/gbUF can you tell me what is wrong with it?
12:25:54 <ceii> I love open source projects
12:29:43 <neutrino> ceii: are they huge things like "implement arm support"
12:30:14 <zzo38> Another extension I had idea for, in the past, was to be able to write "case of" without any expression in between to make up a function taking that as its parameter, which is something I have often wanted and possibly other people too
12:30:25 <ceii> neutrino: you know what? take a look, here it is: http://hackage.haskell.org/trac/ghc/roadmap
12:30:33 <nand`> I previously installed a package via cabal but now I've manually installed a later version from source, which also installed itself to .cabal/bin (since I used cabal for the installation)
12:30:53 <neutrino> ceii: i think i am not knowledgable enough to evaluate those bugs..
12:30:57 <ceii> nand`, multiple versions can cohabit
12:30:58 <nand`> How do I unregister the “old” version of that package so that “cabal --reinstall install world”  doesn't reinstall that?
12:31:09 <nand`> or will that not cause any problems
12:31:20 <ceii> nand`: ghc-pkg unregister package-oldversion
12:31:41 <ceii> but there might be other packages which were built againt that version
12:31:49 <ceii> in that case ghc-pkg will complain
12:32:25 <nand`> ah, a program, not a package, sorry
12:33:02 <ceii> nand`, if it's only a program with no library then it's not registered anywhere
12:33:18 <nand`> but “cabal install world” tries to install it
12:33:26 <nand`> even though I've already built and installed my own version
12:34:56 <ceii> ah, cabal install world uses the ~/.cabal/world file as an index
12:35:00 <ceii> I'd forgotten that
12:35:45 <nand`> I see
12:36:20 <nand`> well, everything works fine now
12:36:55 <nand`> is it normal for ghc-pkg check to list a bunch of warnings about missing documentation
12:37:38 <CodeWeaverX> That's better.  IRC finally recognizes I am who I say I am.
12:37:43 <CodeWeaverX> </popeye>
12:37:46 <ceii> I think documentation generation is still off by default for cabal-installed packages
12:38:02 <ceii> to generate it you want to activate it in ~/.cabal/config
12:38:10 <nand`> okay. I'll silently ignore the errors as I do not intend to lose my internet connection
12:41:21 <zzo38> A suggestion is to call the extension with + and & kinds as NewKinds, and changes OpenKind and ArgKind back to ? and ??
12:41:21 <cmccann> zzo38, I'm not really clear what your & kind does significantly different from Constraint
12:42:18 <cmccann> other than I suppose the merged instance definitions, but that's just a syntactic nicety as far as I can tell
12:42:45 <zzo38> cmccann: I am unsure exactly how the Constraint kind works but it might be able to do this. However I still think there should be available short names for the kinds (perhaps -XNoEnglish for this purpose? similar to Perl's use English)
12:42:48 <Cale> I've always mildly disliked the ? ?? etc kind names
12:43:06 <Cale> Because I need to look them up every time I want to know which one is which.
12:43:45 <cmccann> Cale, well, at least the names are somewhat mnemonic
12:43:50 <Cale> Oh?
12:43:52 <zzo38> (And if you use -XNoEnglish and -XDataKinds together, you would be allowed to make your own data kinds named OpenKind and so on)
12:43:56 <Cale> ?? is more general than ?
12:43:57 <lambdabot> Plugin `compose' failed with: Unknown command: ""
12:43:57 <Cale> ?'
12:43:58 <lambdabot> Maybe you meant: . ? @ v
12:44:10 <cmccann> Cale, yes, the question mark is a mnemonic for "I have no idea what this means"
12:44:12 <cmccann> :D
12:44:15 <Cale> lol
12:44:19 <ceii> :)
12:44:25 <Cale> Yeah, it's not great
12:44:44 <cmccann> the name means it's easy to remember that you don't remember what it means
12:44:49 <cmccann> it's very tidy
12:45:16 <ceii> sure saves you time because you can directly start digging in the docs
12:45:23 <ceii> instead of first trying to remember
12:45:26 <cmccann> yes
12:46:48 <zzo38> If my & kind is the same as the existing Contsraint kind (or if the existing kind can be extended to do what I have specified too), then you could simply have -XNoEnglish, which if combined with -XConstraintKinds renames the kind Constraint to &
12:47:45 <Taneb> Can anyone recommend a Haskell editor?
12:47:51 <cmccann> meh, Constraint is fine, and I don't like & as a symbol for that anyway
12:47:58 <mdmkolbe> What are the "right" flags to use when running benchmarks in GHC?  Is "-O2" enough or are there more flags I should be passing?  (I'm benchmarking several generic programming systems (e.g. Scrap You Boilerplate) for a paper I'm working on.)
12:48:01 <nand`> Taneb: most people seem to like Emacs
12:48:03 <nand`> optionally with haskell-mode
12:48:04 <Cale> Taneb: I use mainly gvim. Emacs also does a good job.
12:48:15 <nand`> but vi derivatives are also good
12:48:19 <nand`> I personally use sublime text 2
12:48:20 * cmccann uses SciTE, just to be contrary
12:48:36 <nand`> because I have not been able to find a free alternative that I like
12:48:38 <stepkut> yi for the win!
12:48:47 <Cale> mdmkolbe: -O2 should be good
12:49:10 <Taneb> I reckon most things will be better than gedit
12:49:27 <ceii> I'm pretty sure OpenOffice Writer will be worse
12:49:31 <cmccann> haha
12:49:52 <nand`> mdmkolbe: -funroll-loops
12:50:15 <zzo38> And then if you add my + kind then you could call it Nat with -XNoEnglish is not selected. (Actually, it should be calle -XNoEnglishKinds rather than -XNoEnglish, probably.) Not the same as the Nat in the -XDataKinds example! And then, have a way to use normal types inside of datakinds
12:50:15 <franco00> mhhh it seems ghci on arm could be /not/ that far away http://lists.debian.org/debian-haskell/2012/01/msg00033.html
12:50:49 <cmccann> Taneb, if you just want a better dumb code editor (syntax highlighting and such, but not much more) then SciTE works okay
12:51:13 <Taneb> I have a choice of dumb code editors
12:51:48 <ceii> franco00: yes, I said 7.6 because that's the next stable version
12:52:07 <franco00> ceii, yes yes, I was just trying not to lose hope XD
12:52:12 <ceii> :-)
12:52:29 <Cale> Taneb: gedit is actually okay, just make sure no matter which editor you choose, to set it to convert tabs to spaces automatically
12:52:58 <franco00> and now,  back to trying stuff, thanks for the tips
12:52:58 <Cale> Taneb: any editor which does that should be all right
12:53:03 <mekeor> franco00: cool! wow, ty
12:53:22 * cmccann is a stubborn tab-indentation partisan, but uses spaces in Haskell
12:53:34 <franco00> mekeor, you mean the link? yeah, it was nice to read it
12:53:37 <Taneb> Cale, I do that semi-subconciously manually
12:54:10 <franco00> you can all pressgang markos on #efika XD
12:54:58 <mekeor> franco00: yep
12:55:04 <mekeor> why is there no scanl' ?
12:56:00 <ceii> mekeor: because if you traverse the list of intermediate results you'll be evaluating them already
12:57:17 <cmccann> mekeor, foldl' is useful for producing a single strict result, scans aren't really strict to begin with
12:57:36 <Cale> scanr is kinda strict
12:57:39 <Cale> in a way
12:57:50 <Cale> The first element is the hardest to evaluate
12:58:15 <c_wraith> > scanr const [1..]
12:58:16 <lambdabot>   Overlapping instances for GHC.Show.Show ([[t]] -> [[t]])
12:58:16 <lambdabot>    arising from a ...
12:58:20 <c_wraith> > scanr const 0 [1..]
12:58:21 <lambdabot>   [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28...
12:58:25 <Cale> But in a technical way, it's not :)
12:58:28 <zzo38> cmccann: You looked at my & kind but did you look at stuff about my + kind?
12:58:44 <zzo38> (In my proposal, the + kind would be a subkind of the * kind)
12:59:03 <Cale> zzo38: Can you invent good names for those please? ;)
12:59:14 <cmccann> zzo38, yeah, but there's already a type-level natural numbers proposal that I think is in the works?
12:59:30 <cmccann> and yes, those really aren't good names
12:59:39 <zzo38> Cale: I will if you implement -XNoEnglishKinds then I can invent the names that are used when -XNoEnglishKinds is not selected
12:59:57 <cmccann> if you need short names, at least use ℕ for naturals :P
13:00:16 <ceii> -XNoAlphanumericIdentifiers, yay
13:00:20 <zzo38> I don't want to use unicode!
13:00:24 <Cale> I don't see why it's important for kinds to have one-character names
13:00:39 <zzo38> It should be ASCII. If you want Unicode, use Agda
13:00:53 <Cale> Then use NaturalKind
13:00:56 <mekeor> zzo38: why?
13:00:58 <cmccann> zzo38, anyway, it's not clear to me that your ideas do anything significant beyond existing extensions and proposals and seem very ad-hoc
13:01:00 <Cale> Or NatKind
13:01:07 <Cale> Or even just Nat
13:01:26 <Cale> But we really don't need more one-character kind names.
13:01:32 <cmccann> zzo38, Haskell source is unicode, ASCII is irrelevant
13:02:03 <cmccann> and ASCII line noise is terrible, either use sensible symbols from unicode or use better names
13:02:06 <shachaf> cmccann: I think "typeable on a standard keyboard" is people's criterion more than "ASCII".
13:02:48 <cmccann> shachaf, ℕ is three keystrokes in my editor, don't see the problem ;]
13:03:01 <zzo38> Cale: Yes, I did suggest calling it Nat but you should be allowed to use -XNoEnglishKinds for disabling all those names an use the old ones such as ? and ?? and & and + and * and so on; freeing the other names
13:03:13 <cmccann> zzo38, NoEnglishKinds is a ridiculous extension, I'm sorry
13:03:22 <Cale> Yeah, that's silly
13:03:24 * hackagebot TCache 0.9.0.1 - A Transactional cache with user-defined persistence  http://hackage.haskell.org/package/TCache-0.9.0.1 (AlbertoCorona)
13:03:25 <Cale> and backwards
13:03:26 * hackagebot scan-vector-machine 0.2.3 - An implementation of the Scan Vector Machine instruction set in Haskell  http://hackage.haskell.org/package/scan-vector-machine-0.2.3 (AdamMegacz)
13:03:42 <zzo38> No, I don't want Unicode I want to use ASCII to make it compatible with ASCII programs.
13:03:47 <Cale> We want kinds to have proper names.
13:04:06 <cmccann> zzo38, you want very specific things, maybe you should make your own language instead :P
13:04:10 <zzo38> Then make up another Haskell with all the different things
13:04:10 <Cale> Not weird symbols which need to be repeatedly looked up because you only use them once in a blue moon
13:04:18 <shachaf> Cale: Fortunately in GHC 7.4 we have lots of kinds with important names.
13:04:19 <hpc> obviously what we need is -XLovecraftKinds
13:04:25 <shachaf> All of them except the important ones, inf act.
13:04:48 <hpc> which would evolve into its own language, which we will call... ZALGOL
13:04:54 <Cale> I'm okay with * having a short name, because it is the single most common kind
13:05:01 <cmccann> ? and ?? are terrible though
13:05:02 <Cale> Things which you use a lot can have short names.
13:05:16 <Cale> But yeah, ? and ?? and # and all that are all terrible names
13:06:02 <zzo38> No, -XEnglishNames should change * to a long name and -XNoEnglishNames change the new kinds Constraint and so on to short names, and if you have neither than it makes * short and the others long
13:06:11 <cmccann> zzo38, to be perfectly honest I think you're the only person who wants cryptic symbols but not unicode
13:06:16 <Cale> Well, # is almost excusable, but only because all the unboxed things use appended # as a convention
13:06:17 <zzo38> s/-XEnglishNames/-XEnglishKinds/
13:06:21 <cmccann> zzo38, so insisting on that point is a good way to have your ideas ignored
13:06:22 <Cale> But it's unnecessary
13:06:41 <cmccann> zzo38, especially since you don't seem to be well-informed on existing extensions and how they overlap with your proposals
13:06:46 <Cale> Isn't zzo38 the guy who wanted the really weird scoping thing?
13:07:16 <Cale> Or was that someone else?
13:07:16 <zzo38> Cale: What really weird scoping thing do you mean?
13:07:25 <mauke> zzo38 is the only entry in my irc killfile
13:08:30 <zzo38> So we have to invent Haskell*#?@~ which is same as GHC but also include the strange thing that many people hate
13:08:44 <cmccann> zzo38, GHC's source is available, have fun
13:09:17 <Cale> Isn't that called DDC? *poke* *jab*
13:09:23 <shachaf> zzo38 has the odd ability of somehow causing people talk about him in third person while he's around.
13:09:23 <cmccann> haha
13:10:09 <zzo38> cmccann: I know that. I don't know how to fix it, how to merge it so that new GHC feature work the same one, in this new one, and GHC programs still work except for the new extensions, or if my computer has enough memory and speed to combine GHC
13:10:45 <cmccann> <ddarius> Then learn how.
13:10:47 <cmccann> ;P
13:11:08 <dmwit> That's not what ddarius would say! ddarius would link to some obscure paper explaining GHC's internals.
13:11:38 <cmccann> dmwit, no, telling people to educate themselves is what he does when he doesn't have a paper handy.
13:11:40 <dmwit> Is the STG-machine paper still applicable to GHC?
13:11:52 <ceii> the only papers I know explaining GHC's internals are unfortunately not that obscure
13:12:31 <hpc> in the absence of papers, use the source, luke
13:12:32 <shachaf> ceii: That's just because you don't know about the obscure ones, of course.
13:12:50 <ceii> shachaf: guess that's why they're obscure
13:13:00 <zzo38> And anyways, I have seen other natural number kinds proposal it doesn't seem the same as the + kind that I have proposed. Such as, I don't know if their Nat kind can be used as inhanbited types where * kind types are expected
13:13:02 <hpc> shachaf: holy crap, that explains so much
13:13:04 <shachaf> I think it's more likely that ddarius would just ignore the conversation.
13:13:12 <shachaf> I imagine that that's what he's doing at this very moment.
13:13:15 <ceii> but I refuse to believe there's a paper about Haskell I haven't stashed away somewhere
13:13:18 <hpc> haskell is started by hipsters, who tried to avoid popularity; it becomes popular, so they make agda :P
13:13:24 * hackagebot Workflow 0.5.8.2 - library for transparent execution of interruptible computations  http://hackage.haskell.org/package/Workflow-0.5.8.2 (AlbertoCorona)
13:14:25 <Cale> http://www.haskell.org/haskellwiki/User:Zzo38/Proposal_for_more-notation <-- right, this bizarre thing
13:15:08 <zzo38> My proposal are all drafts and might be should be adjusted slightly; they are not perfect.
13:15:12 <Cale> I couldn't for the life of me understand why anyone would actually want that, and couldn't find a good example of code which was any clearer as a result of its usage.
13:16:22 <zzo38> Cale: O, well, that is why I suggestion, make up a new kind of Haskell that does include strange thing such as this things
13:16:24 <strager> @pl map fst . zip [0..]
13:16:25 <lambdabot> zipWith const [0..]
13:16:43 <strager> Genius.
13:16:44 <dmwit> Is this the simulated annealing approach to language design?
13:16:55 <dmwit> Throw a bunch of random mutations of good languages against the wall and see what sticks?
13:17:11 <zzo38> I don't know.
13:17:16 * dmwit suddenly understands PHP
13:17:32 <cmccann> dmwit, C++ too :P
13:17:37 <DrSyzygy> dmwit: oooOOOOOooooh!
13:18:14 <ion> Huh. cabal-install-0.10.2, sh bootstrap.sh: Configuring Cabal-1.10.1.0... Setup: At least the following dependencies are missing: base >=4 && <3 && >=2 && <5, filepath >=1 && <1.3, unix >=2.0 && <2.5
13:18:18 <ion> “>=4 && <3”?
13:18:42 <ion> I don’t seem the first person to have this problem. Googling.
13:18:46 <dmwit> You should not be installing Cabal.
13:18:51 <ceii> I'm going to stash that more-notation idea somewhere, in case I need to use haskell for text processing of haskell source code
13:19:22 <Cale> ion: That sort of thing happens when various dependencies together impose impossible constraints on base
13:20:37 <dmwit> If you need a newer Cabal than the one you've got, you basically have to upgrade GHC.
13:20:41 <zzo38> ceii: Do whatever you want with it it is public domain. All of those proposals I have typed, I have put them in the public domain.
13:21:25 <ceii> dmwit: dcoutts just told a few hours ago that me upgrading Cabal wouldn't be a problem
13:21:33 <ceii> and I did, and it wasn't a problem
13:21:52 <dmwit> ...huh
13:21:59 <ceii> just told me a few hours ago*
13:22:17 <ceii> I want an IRC proofreader
13:22:23 <dmwit> Are you sure he didn't tell you to upgrade cabal-install (which should indeed be fine)?
13:22:52 <ceii> dmwit: my cabal-install was built against a bad version of Cabal, so I upgraded both
13:23:24 * hackagebot MFlow 0.0.0 - (Web) application server. Stateful server processes. Simple, statically correct widget combinators.  http://hackage.haskell.org/package/MFlow-0.0.0 (AlbertoCorona)
13:23:34 <ion> Huh. I must have done something wrong when installing ghc (from ghc-7.4.1-x86_64-unknown-linux.tar.bz2) as i didn’t get a cabal to PREFIX/bin. Let’s see.
13:23:38 <mekeor> http://www.haskell.org/haskellwiki/Common_Misunderstandings#Indentation says 'that "then" and "else" must be indented deeper than the "if" statement' but i can't confirm that. i mean, i often indent "then" and "else" as deep as "if" itself as in http://codepad.org/jUWqjCVY (which compiles (apart from that you might dislike that indentation-style, do you?))...
13:23:49 <c_wraith> ion: ghc doesn't come with cabal
13:24:05 <cmccann> typing "cabal install cabal-install" always feels weird to me for some reason
13:24:08 <ion> Oh, i seem to have misparsed what dmwit said.
13:24:22 <btvl> hi, there is something I have no clue on how to model
13:24:36 <dcoutts__> cmccann: at some point I'll rename it all, Cabal -> cabal-lib; cabal-install -> cabal
13:24:37 <c_wraith> ion: usually the best way to install it is to grab the .tar.gz file, unpack it, and run bootstrap.sh
13:24:37 <ceii> ion: clarification: ghc comes with the Cabal library, but the cabal executable is part of the cabal-install package
13:24:46 <dcoutts__> cmccann: so it'll be cabal install cabal :-)
13:24:56 <mekeor> btvl: go ahead!
13:24:58 <ion> c_wraith: That’s exactly what i’m doing and what resulted in the error.
13:25:07 <btvl> I'd like to have a thread that holds a "Data.Map filename (various informations computed from the file)", that get requests from a Chan
13:25:15 <ion> (ceii also)
13:25:25 <btvl> the map is populated as the requests pour in
13:25:29 <cmccann> dcoutts__, ah, that feels slightly less unsettlingly self-referential
13:25:42 <btvl> i suppose something like the state monad would be useful to keep that Data.Map
13:25:56 <btvl> but I'm really unsure about this
13:26:17 <ceii> btvl: yes, StateT IO so you can read and write to channels as well
13:26:33 <btvl> i'll take a look
13:26:34 <ceii> or just use an IORef since you're doing IO already
13:26:41 <btvl> err
13:26:46 <btvl> not sure what that mean
13:26:49 <ion> Someone with a similar error: http://comments.gmane.org/gmane.comp.lang.haskell.xmonad/11422
13:26:50 <btvl> but i'll check
13:27:34 <btvl> should my state also hold the channel or is that bad form ?
13:28:37 <ceii> btvl: the absolute tidiest would be StateT (Map Filename ...) (ReaderT (Chan Request) IO a)
13:29:02 <c_wraith> ceii: shouldn't that a be outside the parens?
13:29:04 <ceii> so the map is read-write but the chan can be obtained but not replaced
13:29:06 <btvl> I'll now have to figure what is ReaderT then
13:29:12 <ceii> c_wraith: right
13:29:32 <ceii> btvl: but I'm not sure you need to over-engineer that much
13:29:43 <ceii> simple old parameter passing isn't that bad
13:30:24 <btvl> using the state monad is already stretching my limits so I'll keep it simple then
13:33:24 * hackagebot yap 0.2 - yet another prelude - a simplistic refactoring with algebraic  classes  http://hackage.haskell.org/package/yap-0.2 (RossPaterson)
13:44:12 <btvl> ceii : I have written a function of type "(Map Filename ...) (ReaderT (Chan Request) IO a)", how can I tell it now to work forever, starting with the empty map ?
13:44:17 <btvl> err
13:44:17 <btvl> no
13:44:30 <btvl> signature is "fileInformationMaster' :: String -> Chan FileMessage -> StateT (Map.Map String FileInfo) IO ()"
13:45:07 <btvl> ah he did quit
13:46:43 <mekeor> the more i read of http://www.haskell.org/haskellwiki/Syntactic_sugar/Cons the more i dislike syntactic sugar…
13:48:26 <glguy> mekeor: It would be hard to imagine a much different reaction to reading a wiki page full of arguments against it
13:52:23 <CodeWeaverX> Annnd back
13:53:33 <mekeor> > concatMap (:[]) [1..10]
13:53:34 <lambdabot>   [1,2,3,4,5,6,7,8,9,10]
13:56:09 <ion> Has anyone actually installed cabal-install with GHC 7.4.1? :-)
13:56:44 <CodeWeaverX> Yes, with some effort.  Had to grab the cabal-install from source to do it.
13:56:48 <CodeWeaverX> And make a tweak or two.
13:57:00 <CodeWeaverX> But I had to do that for osx, your mileage may vary
13:57:07 <ion> Alright, good to know that i’m not the only one who needs to seem a bunch of tweaks to bootstrap.
13:57:20 <CodeWeaverX> cabal-install will catch up eventually.
13:58:46 <pfn> is there a build of ghc 7.0.4 for solaris11 around anywhere?  nothing seems to pop up on google
13:58:51 <pfn> (x86)
14:00:37 <gienah> pfn: an alternative is gentoo prefix
14:00:46 <pfn> eh?
14:01:13 <gienah> pfn: to install gentoo in a prefix directory location on solaris
14:01:34 <pfn> you mean an lx zone?
14:01:55 <gienah> pfn: no: http://www.gentoo.org/proj/en/gentoo-alt/prefix/
14:02:42 <pfn> interesting
14:03:21 <pfn> I'm a bit confused on the output of this, gentoo "userspace" in solaris?  this makes it so that I can build ghc 7.x?
14:03:54 <gienah> pfn: yes in theory, with the gentoo haskell overlay
14:04:15 <pfn> interesting, and weird
14:04:16 <gienah> pfn: https://github.com/gentoo-haskell/gentoo-haskell
14:05:09 <gienah> pfn: I used to maintain a ghc spec file in spec files extra, but my solaris machine is broken so I guess it is no longer maintained
14:07:29 <gienah> pfn: looks like you are lucky there though, someone has updated it to ghc 7.2.2: http://pkgbuild.svn.sourceforge.net/viewvc/pkgbuild/spec-files-extra/trunk/SFEghc.spec?revision=4241&view=markup
14:08:39 <pfn> that's kinda handy
14:08:52 * pfn is clueless as to what's different in various ghc versions, though...
14:10:12 <gienah> pfn: so you could either use 1) the spec files extra SFEghc.spec to build ghc from the source code, and then use cabal install for everything else, or
14:10:40 <gienah> pfn: or 2: use gentoo prefix to build ghc from the source code
14:10:50 <pfn> well, I guess rpmbuild spec is the easiest approach for me, at least most comfortable
14:10:52 <mjga> dimwit: I believe that STG-machine was a book, not just a paper. Wasn't it? Then all desugaring to core is probably still valid. And I suspect that current implementation and code generation may loosely use STG-machine ideas, but is rather assembly, not interpreter-based?
14:11:01 <gienah> pfn: ok
14:11:47 <gienah> pfn: http://pkgbuild.sourceforge.net/spec-files-extra/
14:12:45 <pfn> yeah, I used to have sfe checked out locally a long while ago...
14:14:15 <mreh> conal: could you add NumInstances to FieldTrip's depency list? It's broken since you refactored it out of vector-spaces
14:14:30 <mreh> easy enough to work around though
14:14:40 <conal> mreh: oops! thanks.
14:15:45 <mreh> i wanted to try it out, see how useful it is
14:15:58 <mreh> more useful than wrangling with raw bindings to opengl
14:16:02 <mreh> i hope
14:16:37 <conal> mreh: oh, hm. there are other problems i'd forgotten about, due to an update to opengl.
14:17:02 <conal> who maintains the opengl library now?
14:17:34 <mreh> Jason Dagit <dagitj@gmail.com>, Sven Panne <sven.panne@aedion.de>
14:17:40 <mreh> that's what hackage says
14:17:58 <conal> thx. i'll contact jason.
14:18:04 <cmccann> that's lispy, isn't it?
14:18:07 <conal> yeah
14:18:54 <conal> i want to add some instances to VertexComponent & MatrixComponent, and last i looked, the methods weren't exported.
14:19:28 <conal> i don't want opengl types showing up in fieldtrip interfaces.
14:19:40 <cmccann> I should hope not
14:19:50 <cmccann> I barely want opengl types showing up in opengl's interface :P
14:25:55 <cgroza> Hello everyone. I am trying to get started with gtk and glade but xmlNew returns Nothing. I get an error from the haskell runtimu saying that a pattern failed to match. Any ideas?
14:26:41 <monochrom> http://www.haskell.org/haskellwiki/Monad_tutorials_timeline  hahaha
14:32:42 <Eduard_Munteanu> cgroza: hm, paste some code?
14:32:48 <Eduard_Munteanu> (in a pastebin, of course)
14:33:05 <cmccann> monochrom, I wonder why the influx dropped off in mid-2007
14:33:36 <mreh> conal: is there a demo i can run once i've installed it?
14:33:37 <Eduard_Munteanu> Well, when did byorgey made his point about burritos? :)
14:33:45 <Eduard_Munteanu> s/made/make/
14:33:49 <cmccann> Eduard_Munteanu, two years after that :P
14:33:53 <Eduard_Munteanu> Ah.
14:35:01 <conal> mreh: hm. in the reactive-fieldtrip package iirc, which probably won't build.
14:35:17 <cmccann> Eduard_Munteanu, http://ahamsandwich.wordpress.com/2007/07/26/monads-and-why-monad-tutorials-are-all-awful/ might be why
14:35:37 <mreh> conal: i'll try and use it from my Yampa development
14:36:19 <conal> mreh: this stuff is pretty stale. part-way in, i realized that i wanted to target GPU execution, which led to a different project.
14:37:46 <conal> mreh:  and then *that* project got tabled while waiting for a cross-platform, ghci- and opengl-friendly GUI library on which to redo my functional GUIs. tantalizingly close.
14:37:46 <mreh> conal: lost interest or did it become unfeasable?
14:38:38 <Eduard_Munteanu> cmccann: funny, one could interpret Wadler actually wrote one of those tutorials :P
14:40:28 <cmccann> Eduard_Munteanu, wadler wrote monad tutorials before they were cool
14:40:42 <cmccann> and he's exempt anyway, on account of wearing a bow-tie
14:40:47 <Eduard_Munteanu> Heh, fair.
14:40:56 <monochrom> Wadler's monad tutorial is the best
14:41:57 <Eduard_Munteanu> Wait, it's actually the first one in that article on the wiki.
14:42:05 <cmccann> yes
14:42:09 <cmccann> because it was the first one written
14:42:18 <cmccann> for reasons that are fairly obvious :P
14:42:42 <eyebloom> How does one import a data constructor from another module?
14:43:01 <cmccann> same way you import anything else
14:43:02 <mreh> import Blah (Bar(Foo))
14:43:02 <ion> import TypeConstructor (..)
14:43:19 <mreh> that only imports Foo from the type Bar
14:43:34 <ByronJohnson> eyebloom: import Module (Type(Constructor1, Cunstroct2))
14:43:50 * cmccann notes that "import Module (TypeName)" will give you the type but no constructors
14:43:50 <ByronJohnson> eyebloom: Or, to import every constructor, import Module (Type(..))
14:43:55 <cmccann> which is usually not what you wanted
14:44:30 <eyebloom> Can I also make it subordinate in the module header.
14:44:35 <ion> (I was ambiguous: “import” was English and the rest was Haskell. :-P)
14:44:38 <mreh> sure
14:45:03 <eyebloom> Thanks for the quick help
14:45:34 <eyebloom> It's surprising that you have to do this even if the type and constructor share the same name but it makes sense.
14:45:51 <ion> They’re in entirely different namespaces
14:46:12 <monochrom> precisely because they can have the same name
14:46:35 <monochrom> "data B = B ..."  "module M(B)" ok, which B?
14:46:50 <mreh> the type B
14:47:12 <cgroza> Eduard_Munteanu: here it is http://pastebin.com/ex6Jz4CX . The GUI.glade is in the same directory as the file is.
14:47:19 <mauke> I have copied your paste ex6Jz4CX to http://codepad.org/rglKJwfE - pray I don't copy it any further.
14:47:20 <monochrom> it is unsurprising that a complication is needed for disambiguation
14:47:41 <eyebloom> It makes sense.
14:48:12 * ion makes a bot that caches non-pastebin.com pastes from mauke and helpfully copies them to pastebin.com.
14:48:20 <ion> catches
14:48:44 <eyebloom> Is there a shorthand to export a type and all of it's constructors?
14:49:00 <ion> TypeConstructor (..)
14:50:17 <eyebloom> Thanks
14:58:06 <Eduard_Munteanu> cgroza: hm, and it's failing the 'Just xml' match?
14:59:56 <zzo38> Hello I need help with this program what is wrong with this program please?   http://sprunge.us/gbUF
14:59:58 <Eduard_Munteanu> cgroza: you're missing the mainGUI call, btw
15:00:57 <Eduard_Munteanu> zzo38: simple... it's too long for a question like that ;)
15:01:07 <Eduard_Munteanu> Any details?
15:01:16 <Eduard_Munteanu> Erm, specifics.
15:01:18 <Scriptor> zzo38: what specifically do you need help with, what's going wrong?
15:01:45 <zzo38> Like, it doesn't make a MIDI file. The file it makes won't load in another program.
15:01:57 <zzo38> I did put everything into chapters so that you can find the chapter which is of interest.
15:02:39 <cgroza> Eduard_Munteanu: yes. It's that pattern.
15:03:09 <cgroza> Eduard_Munteanu: I have generated the file with glade 3.
15:03:20 <cgroza> The tutorial I follow does it with glade 2
15:03:39 <cgroza> Is there any support of gtk2hs for glade 3 files?
15:04:06 <zzo38> Do you know about MIDI formats? Can you figure out what is wrong from that?
15:05:00 <dcoutts__> cgroza: yes, glade version 3 generates files that work with gtk+ 2.x so that works with gtk2hs
15:05:10 <Eduard_Munteanu> cgroza: hm, dunno. You might want to try making a simple test file with both Glade 2 and 3 and see, if they coexist on your system.
15:05:18 <Eduard_Munteanu> Ah.
15:05:35 <dcoutts__> cgroza: you just need to avoid glade-3.10+ because that is exclusive to gtk+3 rather than gtk+2
15:06:39 <dcoutts__> for example, I edit the threadscope.ui file using glade-3.8.1 (iirc)
15:08:30 <Peaker> What's the default fixity of `funcs`?
15:08:36 <cgroza> dcoutts__: Eduard_Munteanu Thanks. I will try the other version.
15:09:11 <ByronJohnson> Peaker: :i should reveal the fixity of functions
15:09:23 <ByronJohnson> Peaker: Oh.  The default is 10, IIRC.
15:09:44 <c_wraith> uh. 9?
15:09:49 <cmccann> infix 9, I think
15:09:55 <Peaker> not l or r?
15:09:58 <c_wraith> 10 isn't actually on the scale. :)
15:10:00 <cmccann> don't think so
15:10:24 <cmccann> whitespace is infixl 10 :P
15:10:57 <Peaker> > let minus = (-) in 1 `minus` 2 `minus` 100
15:10:58 <lambdabot>   -101
15:11:10 <cmccann> hm, ok
15:11:12 <Peaker> infixl apparently?
15:11:15 <cmccann> guess so
15:11:15 <mauke> > 1 `f` 2 `f` 100
15:11:16 <lambdabot>   Ambiguous type variable `t' in the constraints:
15:11:17 <lambdabot>    `SimpleReflect.FromExpr ...
15:11:39 <Peaker> > 1 `f` 2 `f` 100 :: Expr
15:11:41 <lambdabot>   Ambiguous type variable `t' in the constraints:
15:11:43 <lambdabot>    `SimpleReflect.FromExpr ...
15:13:18 <mauke> > let minus = f :: Expr -> Expr -> Expr in 1 `minus` 2 `minus` 100
15:13:19 <lambdabot>   f (f 1 2) 100
15:13:30 <mstsc> who needs Dedicated server write me!
15:14:07 <ByronJohnson> Ah, yes.  According to the report, the default is infixl 9
15:14:49 <zzo38> mstsc: What Dedicated server?
15:15:09 <elliottt> how exactly does -main-is work with ghc?
15:15:20 <elliottt> it doesn't seem to pay any attention to it when i put it in a .cabal file.
15:15:39 <c_wraith> cabal has a Main-Is: directive that it looks for for exectuables
15:15:42 <ion> Shouldn’t -XUnsafe be called -XUntrustworthy to match -XSafe, -XTrustworthy?
15:15:55 <elliottt> c_wraith: right, but in this case, i don't want Main.main to be the entry point
15:15:58 <elliottt> i want X.main
15:16:12 <elliottt> which i should be able to specify through -main-is in Ghc-options
15:16:27 <c_wraith> yes, but cabal is overriding that
15:16:41 <c_wraith> so set the Main-is directive to X
15:16:42 <elliottt> ah ha
15:16:51 <ion> > let minus = var "minus" :: Expr -> Expr -> Expr in 1 `minus` 2 `minus` 100  -- IIRC “var” is available here
15:16:51 <lambdabot>   Couldn't match expected type `SimpleReflect.Expr
15:16:52 <lambdabot>                           ...
15:17:02 <ion> Ok, nope.
15:17:05 <elliottt> c_wraith: then it just doesn't generate an executable.
15:17:20 <c_wraith> that's exciting, and  you're now beyond my knowledge :)
15:17:26 <elliottt> hehe
15:17:27 <elliottt> oh cabal.
15:18:20 <elliottt> ah ha
15:18:28 <elliottt> just name the module Main, despite its filename.
15:18:39 <elliottt> wacky.
15:19:37 <Cain_> * #haskel #haskell :Forwarding to another channel
15:19:40 <Cain_> aha, this is good.
15:19:46 <ion> > let minus = fun "minus" :: Expr -> Expr -> Expr in 1 `minus` 2 `minus` 100
15:19:47 <lambdabot>   minus (minus 1 2) 100
15:21:04 <zzo38> Can you be invited to #haskel channel?
15:23:38 * cmccann thinks this is an absolutely ridiculous number of people named elliott and would like to lodge a formal grievance with the appropriate authorities
15:23:54 <ion> > let minus = op InfixL 6 "-" :: Expr -> Expr -> Expr in 1 `minus` 2 `minus` 100
15:23:55 <lambdabot>   Not in scope: data constructor `InfixL'
15:24:09 <ion> > let minus = op Debug.SimpleReflect.Expr.InfixL 6 "-" :: Expr -> Expr -> Expr in 1 `minus` 2 `minus` 100
15:24:09 <lambdabot>   Not in scope: data constructor `Debug.SimpleReflect.Expr.InfixL'
15:25:01 <ion> cmccann: I found myself not to be confused thanks to my IRC client coloring the nicks differently (and consistently over time).
15:25:19 <cmccann> ion, what client do you use?
15:25:26 <ddarius> cmccann: Feel free to once you find the appropriate authorities.
15:25:36 <ion> cmccann: I switched from Irssi to WeeChat a couple of days ago.
15:25:44 <hpc> cmccann: the one true elliott is conal
15:25:46 <ddarius> XChat does that as well.
15:26:12 <ddarius> I imagine most clients that support color at all do.
15:26:25 <ion> Irssi doesn’t. :-P
15:26:27 <cmccann> ok. time to figure out how to turn it on then.
15:27:30 <dmwit> irssi doesn't color nicks?
15:27:39 * dmwit puzzles over his colored irssi nicks
15:27:44 <MostAwesomeDude> It's a plugin.
15:27:47 <ByronJohnson> dmwit: There's a script that does it
15:28:01 <ByronJohnson> dmwit: nickcolor.pl
15:28:02 <dmwit> Can a piece of software really be considered apart from its plugins?
15:28:07 <MostAwesomeDude> Sure.
15:28:50 <cmccann> apparently dmwit is green.
15:29:24 * cmccann hopes it doesn't decide to assign elliott and elliottt the same color
15:31:37 <ion> I tried nickcolor.pl once and found it to interact very badly with some other script i was using. And the other script (i don’t remember which anymore) was more important.
15:32:55 <tommd> dmwit: Depends, are it's memory accesses and other resources isolated?
15:33:09 <ion> Hmm. Or perhaps it broke the hilight feature.
15:34:56 <cmccann> tommd, oh btw did I remember to congratulate you on getting a gold haskell badge on Stack Overflow? that was like months ago I think.
15:36:06 <dcoutts__> elliottt, c_wraith: the ghc -main-is and cabal's main-is: field are an unfortunate coincidence of the same name with different meanings
15:37:19 <c_wraith> dcoutts__: oh, ok. even more confusion, then :(
15:38:00 <dcoutts__> cabal's main is specifies the file containing the Main module
15:38:36 <dcoutts__> ghc's -main-is specifies what module (or module and function) should be considered to be the main one
15:39:01 * pfn wonders why ghc --make is using /usr/bin/as and not /usr/gnu/bin/as
15:41:10 <c_wraith> so there's some overlap, in a way that's not pleasant
15:44:32 <tommd> cmccann: heh, thanks!  Its funny - I get a gold badge then run away from social/programmer web sites to get more things done.
15:45:32 <byorgey> preflex: seen edwardk
15:45:33 <preflex>  edwardk was last seen on #haskell-blah 3 days, 17 hours, 30 minutes and 50 seconds ago, saying: i have a data structure modeling instructions ;)
15:46:32 <cmccann> tommd, that's okay, it's not the thought that counts, it's the getting a shiny gold token of intangible accomplishment
15:46:45 <tommd> ha!
15:46:58 <byorgey> @tell edwardk in case you don't already know, semigroupoids (and I assume a lot of other stuff) is currently broken under 7.4.1 because of conflict between Semigroups.<> and Monoid.<>
15:46:58 <lambdabot> Consider it noted.
15:47:24 <cmccann> I still think (++) would have been better for Monoid...
15:47:29 <tommd> lambdabot: please tell all developers to check their packages against 7.4 - I don't like waiting for fixes to hit Hackage.
15:48:02 <byorgey> tommd: this particular case was somewhat insidious because <> got added between rc1 and rc2!
15:48:22 <byorgey> for example, I checked all my packages under rc1 and uploaded new versions many weeks ago
15:48:28 <byorgey> but I didn't bother re-testing under rc2
15:48:31 <tommd> oh, that's wehre that came from?  I just fixed our groups compiler, which uses a <> operator internally.
15:50:43 <cmccann> tommd, which is why standard libraries stealing new operators that look nice is annoying :[
15:51:12 <ddarius> Only non-standard libraries should steal nice looking operators!
15:51:14 <mauke> > 1 +̈ 2
15:51:15 <lambdabot>   <no location info>: lexical error at character '\776'
15:51:19 <mauke> :-(
15:52:20 <lpsmith> yeah,  if anything I think we should have caleskellified haskell and generalized (++) instead of (<>)
15:53:02 <lpsmith> This also breaks data-semigroup
15:54:21 <lpsmith> Fight the man!  Import Data.Monoid hiding((<>))!
15:54:42 <mauke> no, replace all ++ by <>
15:55:38 <lpsmith> of course,  generalizing ++ could have well caused problems too.  I'm curious what they'd be though.   Some types might turn out more general than intended, for esample.
15:55:45 <byorgey> the argument against generalizing (++) (with which I am sympathetic) is, of course, that newbies will now get errors about Monoid when trying to do things with lists.
15:55:51 <cmccann> lpsmith, monomorphism issues?
15:55:58 <lpsmith> cmccann, good point
15:56:16 <lpsmith> I usually have no-monomorphism-restriction on,  except at the GHCi prompt
15:56:16 <ddarius> Solution: Remove the monomorphism restriction.
15:56:29 <cmccann> byorgey, to a first order of approximation newbies don't understand errors anyway
15:56:53 <monochrom> newbies already get errors with x+[x]
15:56:54 <byorgey> cmccann: that does not give us license to make errors more confusing.
15:57:01 <monochrom> > 0 + [0]
15:57:02 <lambdabot>   No instance for (GHC.Num.Num [t])
15:57:02 <lambdabot>    arising from a use of `e_100' at <inte...
15:57:03 * cmccann is thoroughly unconvinced that avoiding generalized types helps newcomers at all, and it certainly doesn't help more experienced users
15:57:06 <lpsmith> To a first order of approximation,  I don't understand the errors anyway
15:57:07 <monochrom> "what is Num?"
15:57:54 <monochrom> another newbie error: f [x] = f x
15:58:02 <byorgey> I think the real solution would be to have "language levels" (like DrRacket has), where for beginners there is only Integer, (++) is only on lists, etc.
15:58:06 <monochrom> @type let f [x] = f x in f
15:58:07 <lambdabot>     Occurs check: cannot construct the infinite type: t = [t]
15:58:07 <lambdabot>       Expected type: t -> t1
15:58:07 <lambdabot>       Inferred type: [t] -> t1
15:58:15 <cmccann> byorgey, my impression from the kind of questions that show up on stack overflow is that special cases are actually more confusing than generalized types
15:58:17 <byorgey> then when you're ready you can switch to the generalized version
15:58:17 <monochrom> "what is occurs check, infinite type?"
15:58:31 <cmccann> especially when the only justification for the specialized forms is "to be easy for beginners"
15:58:36 <lpsmith> Yeah,  I do like that about DrRacket
15:59:31 <cmccann> it's awkward to answer questions like "I am new to Haskell and confused about the difference between map and fmap"
16:00:12 <lpsmith> to a first approximation,  fmap is map is fmap,  it's just that fmap works more often
16:00:19 <byorgey> fair enough
16:00:54 <byorgey> I suppose to a large extent "language levels" could be achieved just by several different versions of the Prelude, with the "beginner" versions giving things more monomorphic types
16:00:55 <cmccann> I can see not generalizing (.) and id to Category for beginners
16:01:10 <cmccann> because that changes a lot of things and they mostly want plain functions anyway
16:01:46 <byorgey> heck, most of the time *I* don't want (.) and id generalized to Category.  but occasionally I do.
16:01:49 <cmccann> byorgey, I truly think that's not helpful unless you intend to delay introducing type classes altogether
16:02:01 <byorgey> cmccann: I do.
16:02:08 <lpsmith> yeah, I usually don't use Control.Category
16:02:28 <byorgey> I am teaching a Haskell class right now.  Next Thursday is Week 5, when we will finally talk about type classes.
16:02:50 <lpsmith> Though I do import Prelude hiding((++))  ... (++) = mappend;  infixr 5 ++   fairly often
16:02:51 <cmccann> byorgey, in that case a monomorphic prelude would be helpful, yes
16:03:14 <cmccann> lpsmith, yeah, I do that in my replacement prelude, I hate the name mappend >:[
16:03:28 * hackagebot type-unary 0.1.16 - Type-level and typed unary natural numbers, inequality proofs, vectors  http://hackage.haskell.org/package/type-unary-0.1.16 (ConalElliott)
16:03:31 <byorgey> maybe I should make such a monomorphic Prelude for the next time I teach this class, and see how it goes.
16:03:38 <lpsmith> I haven't quite gone that far to have a standard replacement prelude yet
16:03:52 <cmccann> byorgey, numbers would be annoying, possibly
16:04:10 <lpsmith> well,  mostly monomorphic prelude
16:04:11 <byorgey> cmccann: true, because you want + to work on Ints and Integers and Doubles...
16:04:13 <ion> I’m not entirely convinced about the argument about newbies getting monoid/monad/whatever errors from ++, list comprehensions etc. Their first Google result would explain it anyway.
16:04:22 <cmccann> unless you only have one number type and arithmetic operators are monomorphic to that
16:04:39 <byorgey> cmccann: honestly, I would be OK with that.
16:04:41 <cmccann> lpsmith, here's mine: https://github.com/isomorphism/Overture :D
16:04:48 <Saizan> solution: teach typeclasses on day 1
16:04:58 <byorgey> cmccann: you can just promise them "Haskell does have floating-point numbers but we won't use them right away."
16:05:04 <lpsmith> haha,  because that's the first thing anybody should learn about Haskell
16:05:16 <cmccann> byorgey, I think that's what cdsmith did with gloss and the kids he was teaching, everything was Double
16:05:24 <lpsmith> Just like the first thing that anybody needs to learn about Java is classes, apparently
16:05:33 <lpsmith> given the way it's often taught
16:05:34 <byorgey> Saizan: in order to teach typeclasses you already have to know about polymorphism, and it's hard to motivate polymorphism without talking about higher-order functions, and ...
16:05:41 <ion> Btw, what’s the best way to have GHCi use Overture instead of Prelude? At the moment i just have an alias to ghci ~/.local/share/GHCiEnv.hs and the file has “package GHCiEnv; import Prelude (); import Overture”.
16:05:53 <cmccann> ion, use a .ghci file?
16:06:02 <byorgey> cmccann: yeah, for gloss that makes a lot of sense
16:06:08 <byorgey> cmccann: I would probably pick Integer
16:06:24 <lpsmith> cmccann, have you ever considered adding Control.Applicative to Overture?
16:06:27 <ByronJohnson> ion: I'd use -XNoImplicitPrelude and a .ghci file
16:06:30 <cmccann> byorgey, yeah
16:06:42 * byorgey goes to make some notes for next time
16:07:01 <cmccann> lpsmith, it's exported by default
16:07:36 <lpsmith> cmccann, OIC now
16:07:46 <cmccann> here's my .ghci for reference: http://hpaste.org/57388
16:07:48 <ByronJohnson> ion: All you need to do is write two lines in ~/.ghci
16:07:55 <ByronJohnson> ion: :set -XNoImplicitPrelude
16:07:58 <ion> Ah, import Prelude (); import Overture in ~/.ghci worked. Thanks!
16:08:01 <ByronJohnson> ion: import Overature
16:08:27 <cmccann> lpsmith, the module layout is kinda weird, I know :P
16:09:04 <cmccann> right now it's just a bunch of stuff I had in multiple projects lumped together, plus stuff that I don't mind importing all the time because I use it so much, like Applicative
16:09:05 <ion> byronjohnson: That didn’t actually work. Stuff like (++) is still imported from Prelude.
16:09:10 <lpsmith> cmccann, don't you need to have fixity declarations for things like (++)?
16:10:06 <cmccann> lpsmith, yes, I forgot
16:10:12 <cmccann> I also forgot to hide the Prelude version it seems
16:10:14 <cmccann> thanks :P
16:10:54 <ion> cmccann: Mind adding bool :: a -> a -> Bool -> a while you’re at it? Thanks :-)
16:11:53 <cmccann> ion, sure thing
16:13:29 * hackagebot RefSerialize 0.2.8.1 - Write to and read from Strings maintaining internal memory references  http://hackage.haskell.org/package/RefSerialize-0.2.8.1 (AlbertoCorona)
16:14:48 <ion> “Serialize” with Strings? Wouldn’t a non-text list-like type (such as ByteString) be more appropriate? (To be fair, i didn’t actually look at the package.)
16:16:44 <monochrom> @quote hiding.information
16:16:44 <lambdabot> AlanPerlis says: The string is a stark data structure and everywhere it is passed there is much duplication of process. It is a perfect vehicle for hiding information.
16:17:20 <monochrom> string is the preferred data type of "real world" programmers
16:17:24 <ddarius> Just think of all the information Shakespeare was hiding.
16:18:29 * hackagebot MFlow 0.0.1 - (Web) application server. Stateful server processes. Simple, statically correct widget combinators.  http://hackage.haskell.org/package/MFlow-0.0.1 (AlbertoCorona)
16:23:30 * hackagebot scan-vector-machine 0.2.4 - An implementation of the Scan Vector Machine instruction set in Haskell  http://hackage.haskell.org/package/scan-vector-machine-0.2.4 (AdamMegacz)
16:27:15 <ion> Mkay, haskell-src-exts won’t install because happy won’t install because the Num instance change.
16:27:25 <CodeWeaverX> There's a fix for the happy thing.
16:27:28 <CodeWeaverX> You can hack in there.
16:27:32 <CodeWeaverX> I got told about it yesterday.
16:27:46 <CodeWeaverX> You have to build it from source though using a cabal unpack.
16:27:58 <ion> Aye, i probably won’t need it before the author fixes it.
16:28:10 <monochrom> happy is unhappy :)
16:28:16 <ion> :-)
16:29:00 <ion> numbers won’t install for the same reason.
16:29:34 <ion> pointfree tries to use the State constructor.
16:33:42 <byorgey> well, the State constructor has been gone for a while now.
16:34:40 <ion> Yeah, i was wondering why it still built a while ago.
16:35:22 <ion> gwern: I take it you’ll make mueval take advantage of Safe Haskell at some point?
16:36:06 <djanatyn> wow. okay, criterion is really fun.
16:36:34 <ion> yes
16:36:38 <scooty-puff> so when will a version having constraint kinds (really just want constraint synonyms) be the current "standard" release?
16:36:46 <djanatyn> once I have a Benchmark value, what can I do with it to analyze it?
16:36:49 <scooty-puff> trying to get an idea if i can code using them..
16:36:59 <djanatyn> The stuff in Criterion.Analysis looks okay, but how can I just get the time it took?
16:37:22 <ion> djanatyn: http://hackage.haskell.org/packages/archive/criterion/0.6.0.1/doc/html/Criterion-Main.html#g:7
16:37:33 <ByronJohnson> scooty-puff: Depends on your definition "standard"
16:37:47 <ByronJohnson> scooty-puff: 7.4.1 supports constraint kinds
16:37:57 <djanatyn> bench "adding" $ nf (+3) 3 -- what do I do after I've done this?
16:38:12 <ion> See above.
16:38:31 <djanatyn> checking out the link, thanks.
16:41:08 <gwern> ion: maybe. mueval works, so I'm not sure what the point is
16:41:28 <gwern> ion: and could let other people debug Safe Haskell the hard way...
16:42:28 <djanatyn> hmm, the defaultConfig gives me a ton of stuff. is there a way to just run a command once and see how long it took with Criterion?
16:47:11 <ion> defaultConfig?
16:47:15 <ion> You mean defaultMain?
16:58:09 <djanatyn> nah, I mean defaultConfig. that's the config that defaultMain uses.
16:58:32 <djanatyn> but it's okay - I decided to use System.TimeIt. accuracy isn't *that* important, and System.TimeIt does what I need really easily.
16:58:52 <djanatyn> defaultConfig is in Criterion.Config
17:00:24 <ion> You already had ‘bench "adding" $ nf (+3) 3’. Why not just put it inside “main = defaultMain [ {- here -} ]” and be happy? :-P
17:01:11 <djanatyn> yeah, but after that it was printing out all sorts of nonsense.
17:01:34 <djanatyn> I just wanted to do something like return the time it took to run the command; not to give me an in-depth description of all the variances and everything.
17:02:42 <byorgey> the whole point of criterion is that the time it takes to run a program a single time is fairly meaningless
17:03:47 <edwardk> heya byorgey
17:03:47 <lambdabot> edwardk: You have 2 new messages. '/msg lambdabot @messages' to read them.
17:04:00 <byorgey> hey edwardk
17:04:14 <byorgey> how goes it?
17:05:45 <ion> djanatyn: But it *also* prints the time it takes to run your stuff.
17:05:56 <edwardk> not bad
17:06:32 <edwardk> i can now tease you that our implementation of polykinds works better than the ones in ghc. ;)
17:06:40 <byorgey> edwardk: awesome =)
17:07:03 <byorgey> since I did not personally work on the implementation at all, I am not offended in the least ;)
17:07:25 <ion> “our” implementation?
17:07:44 <edwardk> i went to go build a little category with the ghc ones the other day, but without the ability to actually specify them explicitly i can't type check almost anything interesting
17:07:59 <edwardk> ion: the language we use here at clarifi has polymorphic kinds, row types, and other crazy stuff
17:08:10 <copumpkin> edwardk: someone made some interesting categories with polykinds just now on reddit
17:08:17 <ion> Ah, that new language you’re making.
17:08:18 <edwardk> our in this case includes copumpkin and dolio for the most part
17:08:20 <byorgey> yeah, the inability to actually write polykinds in the surface syntax is a big impediment
17:08:30 <copumpkin> edwardk: here: http://www.typesandotherdistractions.com/2012/02/fun-with-xpolykinds-polykinded-folds.html
17:08:36 <byorgey> spj needs a new intern
17:08:52 <luite> hmm
17:09:19 <edwardk> note that he can't state that his functor has a domain and codomain that are category instances
17:09:25 <edwardk> you can't actually write that constraint in any way
17:09:38 <ion> byorgey: One called Gríma that is under #haskell’s control?
17:09:48 <edwardk> because of the kind defaulting for type families
17:10:37 <ion> The intern and SPJ http://upload.wikimedia.org/wikipedia/en/1/17/Grima_and_Th%C3%A9oden.jpg
17:10:39 <edwardk> class Category k where …     class Category (Dom f) (Cod f) => Functor f where type Dom f; type Cod f -- the types there get defaulted to * because of the parsing hack used to type check (a,b)
17:10:43 <edwardk> er kind check
17:10:46 <NihilistDandy> CodeWeaverX: What's new?
17:11:12 <edwardk> which when combined wiht the inability to write explicit polymorphic kinds conspires to make it impossible to say much
17:11:27 <edwardk> i wanted to build a category for constraints
17:11:29 <CodeWeaverX> Rebuild 7.4.1 using 7.4.1.  Took me a while to sort out the libiconv issue that goes way back (conflict with macports), but that's solved.  So that was fun and pointless.
17:11:47 <NihilistDandy> Awesome
17:11:49 <luite> CodeWeaverX: how did you slve it?
17:11:50 <CodeWeaverX> ND:  Still fighting with buildwrapper, trying to find out where the missing constructors and so on are hidden in GHC's internals.
17:12:01 <byorgey> edwardk: obviously there's no theoretical impediment, just an issue of implementation
17:12:04 <NihilistDandy> hpaste some sample errors
17:12:05 <edwardk> byorgey: sure
17:12:13 <byorgey> so I hope surface syntax for polykinds will be added soon
17:12:14 <NihilistDandy> I'll see if I see anything meaningful :D
17:12:23 <edwardk> i was going to say there definitely isn't a theoretical issue, it works fine here ;)
17:12:28 <edwardk> =)
17:12:35 <byorgey> so if you know of anyone that wants to work on it, send them to spj =)
17:12:36 <edwardk> but yeah
17:12:52 <edwardk> i'll get right on that ;)
17:13:49 <CodeWeaverX> luite:  I forced macports to uninstall libiconv.  There's another possibility, which is to force the ./configure to use the other libiconv, via telling it to search in a new path for libraries before the one macports provides.
17:14:08 <edwardk> anyways random griping aside i'm glad its in ;)
17:14:22 <luite> CodeWeaverX: oh I think I just configured it to use the macports iconv
17:14:23 <CodeWeaverX> luite:  One website among many that have worked around this:  http://blog.omega-prime.co.uk/?p=96
17:14:35 <CodeWeaverX> Sure, that's possible too.
17:15:25 <CodeWeaverX> NihilistDandy: Its not strictly an OSX issue, and the original author presumably will eventually get around to it, but I appreciate any advice.
17:15:49 <NihilistDandy> CodeWeaverX: On an unrelated note, I highly recommend homebrew over ports
17:16:11 <CodeWeaverX> NihilistDandy:  Noted.  If I get sick of ports, I'll consider it.  Most of the time I have had no issues.
17:17:04 <djanatyn> is there a way to use "seq" on pure lazy code to force it's evaluation?
17:17:36 <lpsmith> @src ($1)
17:17:36 <lambdabot> Source not found. I can't hear you -- I'm using the scrambler.
17:17:38 <lpsmith> @src ($!)
17:17:39 <lambdabot> f $! x = x `seq` f x
17:17:54 <djanatyn> oh, never mind. I didn't look at what seq was, just the type definition
17:18:07 <lpsmith> well, $! is different from seq
17:18:41 <lpsmith> the trick is to use the same value computation twice,  once on the left side of seq and at least once somewhere inside the right hand side.
17:19:11 <Eduard_Munteanu> I'm not sure what you mean by pure lazy code. 'seq' won't force IO actions or anything like that.
17:19:14 <CodeWeaverX> As long as you don't think x `seq` x does anything
17:19:45 <lpsmith> right, I suppose I should have pointed that out :)
17:20:44 <edwardk> i wonder if i can swap those type families for mptcs to get around the defaulting
17:20:49 <edwardk> brb
17:20:50 <CodeWeaverX> it was an embarrassingly long time for me to realize why that was pointless when I first encountered.
17:20:54 <djanatyn> Eduard_Munteanu: oh, true. yeah, not sure what I was thinking.
17:22:32 <djanatyn> haha, I just needed to use return. I wasn't thinking very well.
17:23:07 <Eduard_Munteanu> Well, if you needed that, then you had a type error to begin with :)
17:23:46 <CodeWeaverX> ND:  I have to take off here, so maybe we can talk about this over the weekend or in the week.  Wish I could stay longer to hash this out.
17:23:48 <edwardk> sweet. that works
17:23:49 <edwardk> muahaha
17:23:58 <edwardk> now i get to code with a horrible mishmash of the old and the new
17:24:03 <NihilistDandy> Sounds good, CodeWeaverX
17:24:06 <djanatyn>  I'm timing how long it takes various sorting functions to run
17:24:08 <NihilistDandy> Shoot me an email
17:24:11 <djanatyn> all my sorting functions are pure, obviously
17:24:21 <CodeWeaverX> Fabulous.  I'll be on here too, as time permits.
17:24:42 <edwardk> class Cat k ob | k -> ob where id :: ob a => k a a;   (.) :: (ob a, ob b, ob c) => k b c -> k a b -> k a c
17:25:20 <djanatyn> but the type signature of the timing function is IO a -> IO (Double, a)
17:25:46 <djanatyn> so I had to use return to pretend that the result of my sorting function was an IO action
17:26:57 <ion> @type let f :: a -> (Double, a); f = undefined in fmap f `asAppliedTo` (undefined :: IO a)
17:26:58 <lambdabot> forall a. IO a -> IO (Double, a)
17:27:39 <Eduard_Munteanu> edwardk: hm, a Category replacement that also brings in Arrow for ~> or Monad for Kleisli?
17:28:14 <edwardk> Eduard_Munteanu: mostly i want it for the constraint kind so my constraints package can use it
17:28:31 * hackagebot semigroupoids 1.2.6.1 - Haskell 98 semigroupoids: Category sans id  http://hackage.haskell.org/package/semigroupoids-1.2.6.1 (EdwardKmett)
17:28:33 <edwardk> and so i can have product and sum categories
17:28:42 <edwardk> which will let me reduce my dependence on semigroupoids
17:28:55 <edwardk> so that people can think of me as slightly less of a loon ;)
17:30:08 <Eduard_Munteanu> Ah. I was a bit mistaken anyway.
17:30:10 <ion> Yay, thanks for the semigroupoids fix.
17:30:28 <byorgey> edwardk++
17:30:40 <ion> @karma+ edwardk
17:30:40 <lambdabot> edwardk's karma raised to 2.
17:30:54 <ion> 2‽
17:31:15 <mauke> preflex: karma edwardk
17:31:16 <preflex>  edwardk: 29
17:31:23 <mauke> note that preflex ignores @karma+
17:31:33 <ion> preflex: karma+ edwardk
17:31:40 <mauke> it ignores that as well
17:34:30 <cmccann> it's always comforting when an elaborate implementation intended to follow a logical model ends up making logically false things clearly impossible to implement
17:34:45 <cmccann> in ways beyond the initially obvious
17:36:55 <cgroza> is there a regex library that comes with haskell by default? I don't want to introduce dependencies.
17:38:47 <edwardk> regex, regex-base and regex-posix are included in the platform
17:39:08 <mjrosenb> cgroza: nothing that comes bundled with vanilla ghc
17:39:20 <edwardk> er regex-compat, -base and -posix
17:39:23 <edwardk> http://lambda.haskell.org/platform/doc/current/index.html
17:40:01 <cgroza> how do I import it?
17:40:14 <cgroza> i get could not find module Text.Regex
17:41:07 <NihilistDandy> cgroza: Did you install the Haskell Platform?
17:41:17 <mjrosenb> cgroza: did you install ghc, or the haefb
17:41:36 <cgroza> mjrosenb: I did. The package I find in the ubuntu repos.
17:41:51 <ByronJohnson> cgroza: I suggest using caball-install.  You can run "cabal install <package>" to install a package
17:41:58 <ben> I'm still sad that cabal-install happily fails due to some messed up state of the package database instead of coming up with a plan to fix it
17:42:14 <NihilistDandy> ben: Fails on what?
17:42:19 <ben> cabal install.
17:42:28 <cgroza> Will these packages be needed to run the program?
17:42:42 <NihilistDandy> ben: What about a cabal update?
17:42:49 <ben> That doesn't fail
17:43:09 <NihilistDandy> What does ghc-pkg check tell you?
17:43:12 <ByronJohnson> ben: Which version are you running?
17:43:31 * hackagebot scan-vector-machine 0.2.5 - An implementation of the Scan Vector Machine instruction set in Haskell  http://hackage.haskell.org/package/scan-vector-machine-0.2.5 (AdamMegacz)
17:43:51 <ben> ByronJohnson: ghc 7.0.4, cabal-install 0.10.2, cabal 1.10.2
17:43:56 <ben> NihilistDandy: That I have a shitton of broken packages
17:44:11 <NihilistDandy> Any common breaks?
17:44:46 <ben> I don't even know. This happens every other week, I cabal-install something and then everything collapses.
17:44:58 <NihilistDandy> That ought not to happen
17:45:03 <ben> I agree!
17:45:16 <NihilistDandy> What caused the latest break?
17:45:21 <ByronJohnson> ben: With cabal-install 0.13.3, installations that would normally break my installation are stopped with a warning that looks like "cabal: The install plan contains reinstalls which can break your GHCinstallation. You can try --solver=modular for the new modular solver that chooses such reinstalls less often and also offers the --avoid-reinstalls option. You can also ghc-pkg unregister the
17:45:27 <ByronJohnson> affected packages and run ghc-pkg check to see the effect on reverse dependencies. If you know what you are doing you can use the --force-reinstalls option to override this reinstall check."
17:45:41 <NihilistDandy> ByronJohnson: The modular solver with --avoid-reinstalls is my new favorite thing :D
17:45:44 <ByronJohnson> ben: I never had that happen with your version of cabal-install
17:46:09 <ByronJohnson> It's really nice, yes :)
17:46:13 <ben> I don't know what caused it. I'll wait for 0.13.3 to show up in my distro then.
17:46:45 <NihilistDandy> ben: hpaste your ghc-pkg check output
17:46:49 <ByronJohnson> ben: You could install it manually, too
17:47:16 <NihilistDandy> I highly recommend the installation from source
17:47:31 <ByronJohnson> ben: It's a lot simpler than it might seem.  You can simply configure&&build&&install in the darcs repo
17:47:33 <NihilistDandy> Or bindist, at least
17:47:49 <ben> http://hpaste.org/57391
17:48:20 <ByronJohnson> I have 7.4 installed, but have cabal configured to use 7.0 until hackage becomes a bit more stable with 7.4
17:49:16 <NihilistDandy> ByronJohnson: I've actually found hackage surprisingly stable. Less cabal hacking than in 7.2, that's for sure
17:52:43 <NihilistDandy> ben: Ouch
17:57:06 <edwardk> eek
17:57:25 <edwardk> to work around the lack of ability to define type classes for polykinds i've had to do something horrid
17:57:38 <NihilistDandy> Do tell :D
17:57:47 <edwardk> class (c ~ '(a,b)) => PC a b c | a b -> c, c -> a b; instance PC a b '(a,b)
17:58:24 <DevHC> uhm, any instant modulo-n types?
17:58:35 <edwardk> seems to be the only way i can effectively define something that works like it projects out the fst kind
17:59:46 <edwardk> devhc: you want types for arithmetic mod n?
18:00:10 <c_wraith> wait, is '(a, b) different from (a, b) ?
18:00:18 <edwardk> devhc: see oleg, and ken's functional pearl implicit configurations
18:00:25 <edwardk> c_wraith: yeah
18:00:38 <c_wraith> how so?
18:01:40 <DevHC> edwardk: yes
18:01:43 <DevHC> edwardk: wat? ?
18:01:59 <edwardk> functional pearl: implicit configurations, its a paper
18:02:18 <edwardk> http://www.cs.rutgers.edu/~ccshan/prepose/prepose.pdf
18:02:20 * DevHC writes sum instant Num&Integral classes for modulo-n
18:02:34 <edwardk> devhc: the trick is the plumbing of the modulus
18:02:53 * sm updates cabal-install immediately
18:02:55 <edwardk> so that you don't try to multiple something % 3 by something % 5
18:03:15 <edwardk> the paper gives a cute trick to generate a type for the modulus term
18:03:33 <edwardk> i maintain a horribly complicated reflection package which provides a modern version of the approach from the paper
18:04:16 <edwardk> c_wraith: see http://research.microsoft.com/en-us/people/dimitris/fc-kind-poly.pdf
18:04:42 <edwardk> c_wraith: basically they define how to lift (simple) data types into new kinds.
18:05:10 <edwardk> in particular the kind (a,b) is a product kind, and the types that inhabit it are of the form '(x,y)
18:05:15 <luite> does show.typeOf always print unqualified types with ghc 7.4?
18:05:38 <edwardk> an easier example is the unit kind, which is only inhabited by the type '()
18:06:12 <edwardk> the ' is used to disambiguate because kinds and types share a namespace, whereas the original type and term did not
18:07:57 <edwardk> data Nat = Z | S Nat  -- would give give you a kind  Nat, with types Z : Nat and S : Nat -> Nat  -- if the type names Z and S were already in use you'd need to use 'Z and 'S for the inhabitants of the kind
18:08:54 <nyingen> @quote
18:08:55 <lambdabot> SleepDeprivation says: <Speck> Oh my god. Crickets in the basement. <Speck> Hundreds of them.
18:08:59 <edwardk> this lets you do things like things like make data Vector : Nat -> * -> *
18:09:45 <c_wraith> oh, blah. I got things off a level, and thought were were lifting the (,) value constructor to the type level.
18:09:53 <c_wraith> Which would make no real sense at all
18:10:00 <c_wraith> given it'd just give you the (,) type
18:10:23 <c_wraith> I forgot the extension was for lifting to the kind level
18:10:44 <cmccann> need to set your sights higher, c_wraith
18:10:45 <edwardk> that is exactly what i'm doing. i'm turning the (,) value constructor into a '(,) type constructor   which inhabits the kind given by (,)
18:10:47 <cmccann> aim for the stars
18:11:28 <c_wraith> heh.  ok, then.  I got it right, but missed the consequences of it...  That it bumps the kind up there, also
18:11:47 * cmccann really needs to spend some time this weekend seeing what he can get away with using the new GHC
18:12:02 <edwardk> sadly it seems i paint myself into a corner even with that
18:12:22 <edwardk> because as an MPTC i wind up having to talk about lots of temporaries i really don't want to carry around in the result type =/
18:13:04 <edwardk> maybe i can make a class associated type family inside the context where i have the extra variables and use that to strip them off
18:13:50 * cmccann found escaping from MPTCs to type families to be very difficult
18:14:03 <edwardk> yeah
18:14:08 <edwardk> likewise
18:14:27 <edwardk> but i'm forced to use MPTCs to work around the polykind limitations
18:14:36 <cmccann> no matter how hard I tried to wedge the output of TypeEq into being usable from type families :[
18:16:36 <edwardk> gah
18:16:39 <edwardk> it defaulted on me
18:16:44 <edwardk> it worked otherwise
18:16:52 <cmccann> aww :[
18:17:32 <edwardk> class (c ~ '(a,b)) => PC a b c | a b -> c, c -> a b; instance PC a b '(a,b) -- works ok
18:18:13 <edwardk> class PC (Fst c) (Snd c) c => P c where type Fst c; type Snd c -- starts out ok, but instance P '(a,b) where type Fst '(a,b) = a -- has defaulted to * because the type family in the first one defaulted
18:18:19 <edwardk> which is the same problem i had to start with
18:18:27 <edwardk> so i can give the type but
18:18:38 <luite> is there a way to convert to string the fully qualified type of a value?
18:18:52 <c_wraith> show . typeOf
18:18:53 <c_wraith> sort of
18:18:54 <edwardk> i can't talk about Fst '((:-),(:-)) etc
18:19:01 <edwardk> since the kind isn't *
18:19:08 <c_wraith> for things with proper Typeable instances
18:19:10 <luite> c_wraith: except sort of not with ghc 7.4 :(
18:19:19 <luite> since it seems to omit the package name here
18:19:25 <c_wraith> oh..
18:19:33 <c_wraith> you can get that info out of the typerep
18:19:37 <c_wraith> but you'll have to do it manually
18:20:30 <luite> hm, right, I see it now
18:20:41 <edwardk> :k '(Ord, ()) -- works fine, gives (,) (* -> Constraint) *
18:20:42 <lambdabot>     lexical error in string/character literal at character 'O'
18:20:57 <edwardk> but :k Fst '(Ord, ()) -- gives up, so Fst got defaulted
18:21:20 <luite> oh wait
18:21:22 <edwardk> whereas :k Fst '((),()) works, but its boring
18:21:27 <luite> that's still wrong, hmm
18:21:57 <luite> oh it isn't, I guess
18:22:45 <edwardk> even if i try to change P to something like class (c ~ '(Fst c, Snd c), PC (Fst c) (Snd c) c) => P c where type Fst c; type Snd c -- it fails to keep them general
18:23:15 <c_wraith> can you get what you need with explicit kind signatures, or will you need to copy them everywhere?
18:23:29 <edwardk> i can't use explicit kind signatures involving polykinds
18:23:33 <edwardk> they aren't implemented
18:23:40 <edwardk> thats why i have to use MPTCs to start with
18:23:42 <c_wraith> oh
18:23:48 <c_wraith> well, that's clearly a problem
18:23:49 <edwardk> this is just a subproblem because
18:24:08 <edwardk> to define a product category i'm going to need constraint family products
18:24:10 <mauke> polyyak shaving
18:24:24 <c_wraith> these yaks have a lot of polyfur
18:26:28 <edwardk> ideally i'd be able to say type family (:&&) (p : x -> Constraint) (q : y -> Constraint) (a:  '(x,y)) : Constraint
18:26:35 <edwardk> or rather
18:26:52 <edwardk> type family (:&&) (p : x -> Constraint) (q: y -> Constraint) : '(x,y) -> Constraint
18:27:04 <edwardk> but i can't give the kind, so the right hand side defaults to *
18:27:35 <edwardk> hence the yak shaving talking about Fst and Snd, etc.
18:28:27 <edwardk> this reminds me of the issue at the type level of dealing with injectivity of leibnizian substitutability, i can embed into larger types, but i can't define a 'subtractive context' as oleg put it
18:28:51 <edwardk> not without being able to name kinds
18:29:33 <edwardk> hrmm, maybe with a dummy method and a horribly kinded default definition
18:32:39 <otters> what does the cabal error message "Construct not supported at this position" mean
18:33:19 <byorgey> otters: probably that the .cabal file is improperly formatted.
18:33:37 <byorgey> otters: is this a .cabal file you made yourself, or did you get it somewhere else?
18:33:42 <otters> made it myself
18:33:58 <byorgey> otters: does it give you any other information (e.g. the position it is talking about)?
18:34:05 <otters> oh yeah
18:34:10 <otters> hang on I'll pastebin all this
18:35:47 <otters> https://gist.github.com/1734967
18:35:49 <otters> where the error is
18:35:57 <otters> "Setup.lhs: rezoom.cabal:19: Construct not supported at this position: F 19"
18:36:03 <otters> "executable" "rezoom"
18:36:15 <otters> I know it's the source-repository section, but that section is invalid no matter where I put it
18:36:23 <otters> I can't find where on the internet it tells you how to format this file
18:36:40 <ByronJohnson> otters: "Executable rezoom" would be a section under which you'd write the main-is line indented
18:37:16 <otters> you mean, I should indent the main-is line?
18:37:39 <ByronJohnson> You could write it like this:
18:37:43 <ByronJohnson> Executable rezoom
18:37:51 <ByronJohnson>    main-is: Main.hs
18:38:06 <byorgey> otters: http://www.haskell.org/cabal/users-guide/#package-descriptions
18:38:09 <otters> damn, that's it
18:38:38 <byorgey> otters: also, you can use the 'cabal init' command to help you create an initial .cabal file
18:38:46 <otters> even better
18:39:30 <otters> thanks for not being scathing like the rest of freenode
18:39:54 <byorgey> otters: anytime.  #haskell is kinda famous for that.
18:40:06 <otters> maybe I'll just move here
18:40:06 <luite> c_wraith: hm, found out that neither unqualified nor qualified works in my program, the type is IO Wolfgang.EvalRes, where the IO has to be unqualified, and the EvalRes qualified
18:40:30 <tommd> otters: despite being on IRC for years, byorgey is still learning how to be rude.  This is a common issue in #haskell
18:40:40 <byorgey> tommd: shut up
18:40:45 <byorgey> (how'd I do?)
18:40:51 <tommd> It's a good start.
18:40:56 <luite> that's beginner-level rude at best
18:41:04 <otters> this one time I went into ##c with a question about a segfault
18:41:07 <otters> (bad decision, I know)
18:41:17 <byorgey> shut up, you, uh... you PHP programmer!
18:41:24 <otters> turns out I forgot a malloc, which I think is a rookie mistake especially given that I had obviously properly used it throughout the rest of the code
18:41:25 <luite> whoah whoah whoah ;)
18:41:28 <djanatyn> hmm. I know this sounds really bad, but say I have an IO action, foo. it returns IO ()
18:41:31 <luite> don't overdo it
18:41:33 <byorgey> otters: hehe
18:41:39 <djanatyn> can I use replicate to run foo 10 times?
18:41:40 <otters> dude starts yelling at me
18:41:45 <otters> "don't even start using C until you understand memory management"
18:41:48 <otters> "go back to your book"
18:41:58 <byorgey> otters: sad, isn't it.
18:41:58 <otters> which surely took more effort than saying "you forgot your malloc"
18:42:02 <byorgey> indeed.
18:42:14 <byorgey> djanatyn: use replicateM_
18:42:17 <cmccann> :t replicateM_
18:42:18 <lambdabot> forall (m :: * -> *) a. (Monad m) => Int -> m a -> m ()
18:42:27 <djanatyn> oh, thanks. that's exactly what I'm looking for :)
18:42:30 <djanatyn> I love the M functions
18:42:37 <luite> otters: well, "you forgot your malloc" would probably have required reading your code
18:42:44 <otters> well
18:42:46 <otters> probably
18:42:47 <djanatyn> I was thinking whether or not it would be possible with mapM_
18:42:47 <byorgey> note replicateM_ is just defined as replicate followed by sequence_
18:42:54 <luite> the other one can be used as a more or less generic response to "my program crashes"
18:43:14 <otters> it was only like, fifteen lines
18:43:23 <c_wraith> luite: is that because of hint or something?
18:43:27 <cmccann> djanatyn, sequence_ is the most fundamental operation, as byorgey suggests
18:43:32 <cmccann> :t sequence_
18:43:33 <lambdabot> forall (m :: * -> *) a. (Monad m) => [m a] -> m ()
18:43:58 <byorgey> djanatyn: yes, in the sense that mapM_ id = sequence_    =)
18:44:16 <cmccann> djanatyn, both mapM_ and replicateM_ amount to the corresponding pure function followed by sequence_
18:44:40 <luite> c_wraith: yeah something like that, except the ghc api instead of hint, need to do some type juggling
18:45:05 <c_wraith> luite: you might be able to work around it by managing imports cleverly
18:45:11 <ByronJohnson> < cmccann> djanatyn, sequence_ is the most fundamental operation, as byorgey suggests — sequence_ is based on foldr
18:45:18 <cgroza> Do I need to install a package to use System.IO.Strict? I need it for the struct version of readFile.
18:45:34 <luite> I'll just hardcode some types as strings, the code was already ugly anyway, importing around 40 GHC modules :)
18:45:34 * cmccann meant to type "more" there, not "most"
18:45:55 <cmccann> foldr is the most fundamental operation on any kind of list, obviously :P
18:45:57 <ByronJohnson> cgroza: The strict package seems to provide the module System.IO.Strict
18:46:05 <mauke> cgroza: http://hackage.haskell.org/package/strict
18:46:07 <cgroza> ByronJohnson: Thanks :D.
18:46:28 <ByronJohnson> cgroza: In the future, you can use Hackage's search, Hoogle, and Hayoo for such questions
18:47:11 <luite> c_wraith: I think that the problem is that it never was the right approach, typeOf gets the type of some value in the compiled haskell program, while I try to use its string representation in the ghci context of a loaded interpreted user file
18:47:39 <c_wraith> luite: hint actually does a trick like that.  But it is fragile, since they're not guaranteed to be the same
18:48:02 <luite> yeah, but unless hint is outdated, it does it in a less clever way than it could have with ghc 7 :)
18:48:14 <luite> since you can directly import extra modules qualified with the api
18:48:28 <luite> err, unless hint has been updated
18:49:01 <c_wraith> it certainly hasn't
18:49:49 <luite> I switched to the ghc api from hint because I needed some access to HsCoreTy
18:49:50 <otters> uh oh
18:50:06 <otters> "Could not find module `Prelude'. It is a member of the hidden package `base'"
18:50:27 <otters> as "base" is the first item in my Build-Depends directive
18:51:26 <otters> new exproved .cabal file: https://gist.github.com/1735034
18:51:41 <otters> which is giving me that error
18:55:43 <ByronJohnson> otters: You need to add base to your build-depends list
18:55:53 <otters> But it's right there
18:56:05 <otters> go look at it
18:56:34 <ByronJohnson> otters: Huh.  I didn't think that'd even parse correctly
18:56:42 <ByronJohnson> otters: build-depends is written under the executable section
18:56:51 <otters> oh god
18:56:56 <otters> looks like I need to read the fm a bit more
18:59:58 <ByronJohnson> otters: It's good practice, by the way, to write version constraints for each dependency, part of which would contrain the major version (so that major API changes to your dependencies wouldn't break your code; if a dependency incorporated major changes, typically ones that break backwards compatibility, either the first or second part of the version number is increased), with the possible
19:00:04 <ByronJohnson> exception of handling base differently
19:00:08 <otters> oh, I see
19:00:17 <otters> hmm
19:00:19 <otters> thanks for letting me know
19:00:47 <ByronJohnson> You're welcome :)
19:04:09 <edwardk> hrmm some of my earlier issues were caused by not running the _repl_ with polykinds
19:04:18 <edwardk> so i may have less defaulting than i feared
19:04:39 <edwardk> i had a nice polykinded library that was being used monokinded by the repl
19:08:33 * hackagebot copilot-c99 0.2.4 - A compiler for Copilot targeting C99.  http://hackage.haskell.org/package/copilot-c99-0.2.4 (LeePike)
19:11:09 <nyingen> @quote
19:11:09 <lambdabot> <eu-prleu-peupeu> says: just haskell it
19:11:11 <nyingen> @quote
19:11:12 <lambdabot> SeanLeather says: One of the "nice" things about English is that there is often never an "always."
19:13:33 * hackagebot copilot-sbv 0.4 - A compiler for CoPilot targeting SBV.  http://hackage.haskell.org/package/copilot-sbv-0.4 (LeePike)
19:14:22 <mauke> preflex: "
19:14:25 <preflex>  <augustss> ghc had a bug once where it deleted the source file if it had a type error. Quite sensible, I think.
19:14:34 <cmccann> :D
19:14:47 <ion> @quote
19:14:48 <lambdabot> <eu-prleu-peupeu> says: just haskell it
19:14:49 <ion> @quote
19:14:49 <lambdabot> Plugin `quote' failed with: getRandItem: empty list
19:15:10 <mauke> preflex: "
19:15:12 <preflex>  <vec|code> scroll lock is a letter in the canadian language
19:15:47 <otters> haha
19:15:51 <sm> so back to the libiconv issue on mac... it broke again after upgrading to GHC 7.4.1 binary. cabal build -v3 shows it linking with -L/opt/local/lib even though I commented that out from ~/.cabal/config. Why is cabal doing that ?
19:15:53 <otters> I can just imagine ghc being that frustrated
19:16:08 <ion> I PREFER CAPS LOCK.
19:16:36 <luite> sm: just give up and rebuild ghc with the macports libiconv :p
19:16:48 <dcoutts__> sm: any installed package that has /opt/local/lib in its libdirs will cause problems because the linker paths are used to resolve all libs (annoying linker search semantics)
19:18:05 <sm> aha, things I installed previously with /opt/local/lib enabled
19:18:33 * hackagebot copilot-language 0.4 - A Haskell-embedded DSL for monitoring hard real-time  distributed systems.  http://hackage.haskell.org/package/copilot-language-0.4 (LeePike)
19:19:10 <sm> so purging my packages should help ?
19:22:23 <cmccann> edwardk, oh btw, in some code I'm hacking on I found a use for that functor zapping stuff on your blog, and may even turn out to care about the stuff you said no one cares about :P
19:22:33 <edwardk> hah
19:22:43 <edwardk> came up in discussion with someone the other day
19:22:51 <edwardk> i think sjoerd visscher or someone
19:23:10 <ion> Functor zapping? /me googles
19:25:13 <sm> yes it did help. Thanks dcoutts :) So avoid using GHC binaries + keeping macports' libiconv installed + installing any package built with macports libs visible
19:33:11 <rata_> hi
19:33:33 * hackagebot copilot 2.0.6 - A stream DSL for writing embedded C programs.  http://hackage.haskell.org/package/copilot-2.0.6 (LeePike)
19:34:04 <ski> lo
19:35:17 <otters> omg hackage checks your package for validity
19:35:18 <otters> I heart this
19:35:24 <otters> haskell won't let me do anything wrong
19:35:56 <irene-knapp> yeah, it's really nice
19:36:17 <otters> pardon me, nerdgasm
19:39:38 <otters> are you supposed to test your package with multiple versions of its dependencies?
19:40:46 <irene-knapp> it's up to you; I suspect nobody does, due to the difficulty of doing so
19:40:56 <irene-knapp> but the version ranges you specify should reflect what you actually test on
19:41:02 <otters> well, hackage's checker mentioned it
19:41:05 <otters> so I only tested on one point release
19:41:05 <irene-knapp> ahh hmm
19:41:08 <irene-knapp> right okay
19:41:21 <otters> base 4.x, HTTP 3000.2.x, etc. etc.
19:41:34 * irene-knapp nods
19:41:45 <irene-knapp> that's a reasonable approach
19:42:07 <otters> but you can't have an equals sign in that field
19:42:14 <irene-knapp> indeed
19:42:20 <irene-knapp> you can have syntax like
19:42:22 <otters> sooooooo
19:42:39 <irene-knapp> HTTP >= 3000.2 && < 3001
19:42:48 <irene-knapp> in theory, that should be correct if the HTTP package also plays by the rules
19:42:58 <irene-knapp> since the major version is supposed to change when, and only when, it breaks compatibility
19:43:18 <cmccann> you can use HTTP == 3000.*
19:43:34 * hackagebot copilot 2.0.7 - A stream DSL for writing embedded C programs.  http://hackage.haskell.org/package/copilot-2.0.7 (LeePike)
19:43:45 <cmccann> or something like that
19:43:59 <otters> cmccann: that works
19:44:00 <otters> thankee
19:51:04 <Guest__> Hello.
19:51:22 <nyingen> @quote
19:51:22 <lambdabot> sebazzz says: sebazzz> TA LOCO! tengo que encarar carajo! por los santos pelos del sobaco de jesus! lo voy a hacer! :@
19:52:58 <otters> ugh, dammit
19:53:02 <otters> my first ever hackage package is broken
19:53:15 <irene-knapp> aw
19:53:34 * hackagebot rezoom 0.0.1 - Github resume generator  http://hackage.haskell.org/package/rezoom-0.0.1 (JoelTaylor)
19:53:34 <otters> "Could not find module Rezoom.Builder"
19:53:38 <otters> yeah
19:53:43 <otters> although it builds JUST FINE on my machine
19:53:48 <irene-knapp> hmmm I see
19:53:53 <otters> maybe I missed a cabal step
19:54:02 <irene-knapp> maybe the versions of things are different on the server
19:54:09 <otters> I mean it's pretty simple, Main.hs, Rezoom/{Builder.hs,JSON.hs}
19:54:18 * irene-knapp nods
19:54:30 <otters> wat do
19:54:43 <irene-knapp> no, never mind, if it's the package you're defining that shouldn't be the problem
19:54:45 <irene-knapp> I dunno then :(
19:55:37 <otters> oh...
19:55:45 <otters> Builder and JSON aren't actually included in the package
19:55:46 <otters> ummmm
19:55:49 <irene-knapp> oh hmmm
19:56:01 <irene-knapp> it's supposed to detect that before it accepts it
19:56:17 <otters> I bet it is
19:56:24 <otters> yep
19:56:27 <otters> Rezoom is an empty directory
19:56:36 <otters> that is depressing
19:56:47 <irene-knapp> hmm yes
19:56:53 <irene-knapp> okay, did you include an other-modules: field?
19:57:41 <otters> no
19:58:01 <irene-knapp> ah, you'll need to.  it's a comma-separated list (can use multiple lines) of modules other than Main
19:58:12 <irene-knapp> unlike the main-is: field, you don't append .hs to their names
19:58:24 <irene-knapp> (you only do for main-is because it could be a .c file or whatever)
19:58:39 <otters> ah, that did it
19:58:44 <irene-knapp> excellent
19:58:44 <otters> okay thanks
19:58:59 <irene-knapp> np
20:01:32 <ByronJohnson> The difference is whether the module is referred to in the same form that's used in imports or whether it's referring to the actual filepath.  The former doesn't include the extension
20:03:02 <otters> and bam, it builds
20:03:34 * hackagebot rezoom 0.0.2 - Github resume generator  http://hackage.haskell.org/package/rezoom-0.0.2 (JoelTaylor)
20:03:41 <otters> heh
20:03:46 <otters> up a version already
20:05:40 <irene-knapp> ah well, I actually did the same thing
20:11:37 <drdo> Couldn't match expected type `http-conduit-1.2.2:Network.HTTP.Conduit.Manager.Manager' with actual type `Manager'
20:11:42 <drdo> I love these errors
20:16:00 <new2net> Hello, gentlemen. I have come to take your advice.
20:16:55 <ion> Before we begin, please provide your credit card information on the channel.
20:17:19 <Cain_> we are also a credit rating service
20:17:48 * ski wonders what our advice to new2net consists of
20:17:55 <sbagley> Hi Haskell friends! I decided it would be fun to write a priority queue in Haskell using balanced binary search trees. I've already done a little bit of work in this direction, but would you mind giving me a little advice as to how to proceed?
20:18:40 <ion> You could use Data.Sequence. :-)
20:19:07 <ion> When i read {something} Friends i can’t help thinking of Happy Tree Friends.
20:19:29 <sbagley> I probably could; I don't really know much about the contents of Data.Sequence. I'm mostly interested in the exercise of building a heap that is not in a mutable array.
20:19:33 <ski> sbagley : (a) write a `data' type definition; (b) implement `empty',`insert',`unqueue'
20:21:51 <Sgeo> If I GeneralizeNewtypeDerive Typeable for some newtype of mine, does that mean the cast function will be ok with casting between the original type and the new type?
20:22:19 <sbagley> ski: I suppose that's the trick. I'm having a hard time thinking about how to fix the heap condition after inserting something.
20:24:20 <parcs`> Sgeo: you can't derive Typeable with GeneralizedNewtypeDeriving
20:24:31 <Sgeo> o.O
20:25:53 <ski> sbagley : hm, i'm not sure i understand. i thought you wanted to use BSTs, not heaps
20:26:50 <ski> (i suppose a BST that is a heap would be list ..)
20:29:31 <sbagley> ski: You are of course right. I think I was conflating two things that I was thinking about doing. Perhaps this resolves some of my confusion.
20:30:09 <sbagley> ski: Writing a priority queue with a BST wouldn't make sense would it.
20:30:14 <Sgeo> parcs`, oh, I see
20:30:29 <Sgeo> It doesn't override the built-in deriving mechanisms
20:31:12 <ski> sbagley : well, i suppose one could use `splitMin' operations (possibly cached) .. but there's probably not much point to it, no
20:45:25 <nyingen> @quote
20:45:26 <lambdabot> MattMight says: Axiom: There's a Unix shell command to do what you want, but no one remembers what's called.
20:46:09 <nyingen> @quote
20:46:09 <lambdabot> donw says: [of JavaScript booleans] I've heard of duck-typing, and static-typing, but this is the first time I've heard of Schrödinger-typing...
20:47:44 <nyingen> @quote
20:47:45 <lambdabot> bos says: it looks like an interesting book, although i find the idea that software engineers might be ready for category theory this side of the 22nd century charmingly naive
20:53:55 <edwardk> ok, i finally got the sum category identity arrow working. now its just plumbing
20:55:56 <ski> .. presumably that quote was in response to "Category Theory for Software Engineering" by Jos Luiz Fiadeiro in 2005 at <http://homepage.mac.com/fiadeiroj/jose/CATBook/>
20:56:30 <ski> (.. actually s/Category Theory/Categories/)
20:59:36 <ski> "Documents as Categories" by Willam c. Wake in 1996-03-26 at <http://xp123.com/wwake/dissertation/model.shtml>
21:05:20 <nyingen> @quote
21:05:21 <lambdabot> DRMacIver: says: I dread to think what category theory would look like after the software engineering world had got their grubby paws on it. Enterprise variant functors. Commutative UML diagrams.
21:05:22 * Sgeo wonders if there will ever be a Haskell for Dummies
21:05:34 <Veinor> it's called learn you a haskell :)
21:05:41 <nyingen> That's actually a pretty good book
21:06:01 <Sgeo> As a kid, I probably would have looked for the For Dummies first
21:06:02 <Sgeo> >.>
21:06:06 <Sgeo> In a bookstore, I mean
21:06:08 <Balahla> Does anyone know a lib for https?
21:06:13 <Sgeo> Do any bookstores even shelve LYAH?
21:06:34 <nyingen> LYAH is the book I lend to others who ask about haskell :)
21:07:20 <ski> (nyingen : .. together with that quote goes `@quote industry.analysts')
21:07:51 <Veinor> @quote industry.analysts
21:07:52 <lambdabot> slava says: Because top enterprise industry analysts recommend that managers need to focus on Agile methodologies, SOA, B2B and Yoneda's lemma in today's rich Internet application-driven environment.
21:07:52 <lambdabot>  Don't get left behind by the AJAX craze by missing out on call center outsourcing and Yoneda's lemma!
21:07:59 <Veinor> haha
21:08:07 <Veinor> what's the context of that
21:08:09 <nyingen> heh, Yoneda's lemma
21:11:38 <nyingen> @quote
21:11:38 <lambdabot> nornagon says: i thought someone just wrote a lambdabot plugin to write lambdabot
21:19:22 <nyingen> @quote
21:19:22 <lambdabot> NathanielSBorenstein says:  It should be noted that no ethically-trained software engineer would ever consent to write a DestroyBaghdad procedure. Basic professional ethics would instead require him
21:19:22 <lambdabot> to write a DestroyCity procedure, to which Baghdad could be given as a parameter.
21:20:29 <companion_cube> :D
21:24:28 <penelope> Well, yesod is very well put together, but suffers from railsitus.
21:25:42 <Balahla> I'm having trouble with Cabal... I just can't install Curl... The error message is "curl libraries not found, so curl package cannot be built"... Can someone help me, please?
21:26:00 <Sgeo> railsitus?
21:26:11 <monochrom> do you have the C-side curl lib?
21:26:17 <penelope> The rails disease.
21:26:31 <monochrom> and not just lib, but also the "dev" files: C headers etc
21:26:38 <penelope> Balahla: what os?
21:26:51 <Balahla> Just tried to install by "cabal install curl". Windows 7.
21:27:27 <penelope> Are you in a cygwin terminal? or cmd.com?
21:27:47 <Balahla> Tried in a cygwin AND in cmd...
21:27:59 <penelope> ok:
21:28:07 <penelope> so pick your poison
21:28:39 <penelope> In windows/cmd.com, you'll have to go and install curl and curl's development libraries and headers.
21:28:54 <penelope> (with a browser and mouse clicks)
21:29:31 <penelope> In cygwin, if you run the setup thing again, search for curl
21:29:39 <penelope> Note:
21:29:53 <edwardk> to be fair, destroy baghdad could be sitting in the test suite for the more generic procedure somewhere as a usecase
21:30:06 <monochrom> haha
21:30:43 <penelope> (a long term solution might be to run linux in a VirtualBox)
21:30:44 <edwardk> i mean, we all know how hard it is to write a decent quickcheck testsuite for something with side-effects ;)
21:31:10 <Balahla> This is a Windows issue?
21:31:25 <penelope> It's a library/header file issue
21:31:32 <edwardk> when it stops running after a 1000 iterations is it because of a bug? or because you accidentally destroyed the city the server was in
21:31:54 <penelope> (It's just harder in windows, probably because I don't know windows very well anymore)
21:32:28 <Balahla> Any other library I could use for HTTPS ?
21:32:52 <penelope> If something wants curl...
21:33:50 <penelope> If you want to run the haskell in cmd.com, just go to the curl website: I'm sure they have instructions to install a source/developer version.
21:34:40 <penelope> http://curl.haxx.se/latest.cgi?curl=win32-devel-ssl-sspi
21:34:44 <Balahla> Thank you! Gonna try the curl website.
21:35:29 <monochrom> actually, what is the rail disease?
21:35:39 <penelope> Hee
21:35:56 <penelope> Rails: as in the famous ruby web framework
21:36:17 <penelope> Rails Disease:
21:37:56 <penelope> Overlooking long term issues (of scalability, extension, etc) by using ugly stuff under the rug to make the framework easy for the newbie at the expense of later growing pains.
21:38:25 <othiym23> that hasn't been true of Rails for a long time, though
21:38:43 <othiym23> you basically have to be an expert in Talmudic lore just to follow Rails' release notes anymore
21:38:44 <penelope> True.
21:38:45 <penelope> But
21:39:02 <othiym23> they're gonna sneak in a new syntax for one of the configuration languages on each release if you don't keep an eye on them
21:39:30 <penelope> It's been a while, but I still remember the horror of looking at the actual active record code...
21:39:31 * othiym23 is wearing his "ASK ME IF I'M BITTER ABOUT COFFEESCRIPT" T-shirt today
21:39:38 <penelope> :-)
21:40:19 <othiym23> penelope: arel is something approaching a real relational algebra embedded in the core of Rails, although there is a ton of legacy crud from previous versions of ActiveRecord glommed onto it
21:40:51 <penelope> Wow. I'm clearly totally behind the times then!
21:41:54 <othiym23> you're not going to get around the grim horror of Ruby's typing and the colossal pile of monkeypatching in Rails
21:42:02 <penelope> oh,
21:42:14 <penelope> it's the metaprogramming that really freaked me out.
21:42:49 <othiym23> but if you want to forego all the helpers, there's select, project, difference, etc in there that allow you to do pretty much pure set operations on something looking like relations, and it juggles it back into SQL in the background
21:43:12 <othiym23> I've been hacking Node.js for a living for the last 7 months, so Rails no longer seems that scary to me ;)
21:43:30 <penelope> Oh, you poor bunny!
21:43:41 <othiym23> nah, it's fun
21:43:53 <penelope> What do you like about it?
21:44:25 <penelope> (And here I thought it was the antichrist!?)
21:44:51 <othiym23> the whole thing is kind of a gross hack, but once you get in the flow of evented / callback-based programming (and find a few good libraries for managing some of the complexity of async programming), it's deeply impressive how fast and low-latency pretty much everything is
21:45:16 <othiym23> esp. given that JS is an interpreted language and all
21:45:51 <penelope> Hrm. But I thought this was discovered years ago, with C's poll and select?
21:45:54 <othiym23> the whole web turns into a forest of RESTful endpoints that you can do whatever you want with
21:45:56 <othiym23> sure!
21:46:23 <othiym23> but Node's value-add is that it makes it dirt simple to do that and enforces one style of programming
21:46:31 <penelope> Wait: Explain the forest of RESTful endpoints?
21:46:41 <othiym23> that constraint really forces you to think about how to solve problems asynchronously -- it's both a curse and a blessing
21:46:45 * ski . o O ( <https://developer.mozilla.org/en/Rhino_JavaScript_Compiler> )
21:47:33 <othiym23> well, my perspective is skewed because I work on a project (http://github.com/LockerProject/Locker) where the whole system is a set of tiny little web servers running as a single thing
21:48:05 <othiym23> ski: I strongly doubt Rhino's compiler is ever going to surpass v8's seasick stack of JITs
21:48:07 <penelope> oh, nice
21:48:23 <othiym23> there's like three of them running on top of each other in current versions of v8
21:48:26 <penelope> I had wanted to do a data-twitter for some time...
21:48:31 * ski knows nothing about Rhino
21:49:57 <othiym23> anyway, it's a wholly different paradigm than something like Yesod, and you can always see the seams and cracks in the frameworks (and holy yes do I miss static typechecking and Hindley-Milner), but it's sort of like the apotheosis of the Rails / Sinatra mindset and it works very well for certain classes of problem
21:51:47 <penelope> Well, to be fair, if I had to do something very quickly, it would be in ruby.
21:51:59 <kallisti> if I make a cabal package will it automatically re-install dependencies as shared libraries if I --enable-shared ?
21:52:03 <othiym23> these days, if I had to do something very quickly, it would be in Go ;)
21:52:10 <penelope> Really?
21:52:22 <penelope> As in development, not execution?
21:52:33 <penelope> kallisti: no
21:52:41 <kallisti> :(
21:52:58 <penelope> You'll need to do ghc-pkg check
21:53:07 <kallisti> maybe --enable-shared should be the default?
21:53:12 <othiym23> penelope: really
21:54:20 * kallisti has yet to try out Go.
21:54:34 <penelope> Shared libraries are still kind of unexplored country...
21:54:39 <companion_cube> wow, there is huge stack of dependenies on this Locker project
21:54:44 <monochrom> "Couldn't match expected type `main::Interactive.X' with actual type `main::Interactive.X'" hehehe!
21:55:03 <penelope> GHC can make them now, but
21:55:07 <kallisti> at this rate I'll basically end up reinstalling all of my Haskell packages with --enable-shared
21:55:15 <penelope> yes
21:55:38 <penelope> But:
21:55:51 <penelope> You could probably put that option into you .cabal
21:55:51 <othiym23> companion_cube: yes, it's not a lightweight project -- we just moved to node 0.6.x and the script we use to help people bootstrap their lockers (http://github.com/LockerProject/lockerbox) is still catching up
21:56:03 <othiym23> and I know the dependency list looks like buzzword bingo
21:56:33 <penelope> And try to uninstall as many system installed libghc-* packages as you can
21:56:39 <monochrom> (how to do it: get GHC 7.4.1, go into ghci, "data X = X Int", "let x = X 10", "data X = X Bool", "let y = X False", "data X = X", "x == y"
21:57:47 <othiym23> monochrom: stop being mean to ghci
21:58:05 <penelope> Personally, I can't wait! But I just do not have enough free time to worry about shared haskell libraries, as yummy as they sound. I'll be lazy and leave it up to the debian maintainers to do the hard work.
21:58:06 <ski> monochrom : yeah, SML has had that feature for years
21:58:29 <companion_cube> othiym23: so this project is about collecting your own personal data from sources like social networks, but the social networks still have it, am I right?
21:58:40 <othiym23> companion_cube: yes
21:59:04 <monochrom> I think SML or mosml attaches version numbers to type names so error messages don't exactly look like "Whee does not match Whee"
21:59:17 <othiym23> companion_cube: right now, it's best to think of it as a way to aggregate / deduplicate / provide a simple set of standard APIs over your data (to add value to it) rather than something to supplant your existing social media footprint
21:59:32 <companion_cube> monochrom: Ocaml does it, otoh
22:00:03 <companion_cube> othiym23: ok :). Could it be used to make a distributed social network, that said?
22:00:23 <ski> stdIn:5.1-5.6 Error: operator and operand don't agree [tycon mismatch]
22:00:23 <ski>   operator domain: ?.X * ?.X
22:00:24 <ski>   operand:         ?.X * X
22:00:24 <ski>   in expression:
22:00:24 <ski>     x = y
22:00:38 <othiym23> companion_cube: you should look at its sister project, Telehash ;)
22:00:59 <kallisti> wow this is insane
22:01:06 <companion_cube> oh, I heard about telhash
22:01:07 <kallisti> there's no option to /only/ install the shared libraries
22:01:07 <othiym23> companion_cube: the short answer is yes, but I see it as a complement to something like Diaspora or identi.ca rather than a straight-up replacement
22:01:12 <kallisti> it's just: --reinstall --enable-shared
22:01:19 <companion_cube> looked quite original
22:01:44 <companion_cube> othiym23: so, how did you get to make this for a living?
22:01:58 <companion_cube> if I can ask
22:02:18 <monochrom> mosml says "expression of type X/1 cannot have type X". it attaches version numbers.
22:02:21 <penelope> (It's the eternal question of the haskell afficiado!)
22:02:21 <othiym23> companion_cube: I work for http://singly.com/, the company that's building a hosted offering on top of the locker core
22:02:40 <companion_cube> oh ok
22:03:24 <othiym23> it just so happens that the core committers for the Locker Project and Singly's employees are largely overlapping sets
22:04:00 <ski> monochrom : ok. haven't tried mosml
22:04:00 <othiym23> although we're getting ready to launch Singly to the wider dev community in a couple weeks, and we're all anticipating / hoping that community participation in the locker side of things will increase dramatically after that
22:06:16 <penelope> nice. Can singly push too?
22:06:43 <othiym23> how do you mean, penelope?
22:07:00 <companion_cube> so, do you think many people will install this on their own computers, or do you target groups/communities?
22:07:13 <penelope> well, I gather that it can gather from my disporate social networks,
22:07:54 <penelope> but if I "share" something, I'd like to be able to just share it once, and have it broadcast on all my disperate social platforms.
22:08:09 <othiym23> companion_cube: right now there are a couple pilot projects at various campuses, mostly just run by people who are interested in the project, but Singly's focus is on getting people on Singly's platform ;)
22:08:26 <othiym23> we're very serious about the locker codebase remaining completely standalone, though
22:09:24 <othiym23> penelope: right now the focus is on getting our API into the hands of designers / dataviz / front-end devs because that's where the deduplication and aggregation provide the most leverage, but there are a bunch of spare-time projects we're working on that work towards exactly what you're talking about
22:09:34 <monochrom> ghc shared libs will not have a smooth story on linux for a while. technical reason: ld and ldconfig assumes a small stable set of directories in which all *.so's go, you just tell it to rescan those known directories. GHC assumes every different *.so to go to almost every different directories, notably, the directory name contains version number
22:09:39 <othiym23> for example, I really want to make my online music library portable between music services
22:10:50 <jtobin> you got it chief, i just sank into a pizza here anyway
22:11:09 * jtobin palms forehead..
22:11:12 <jtobin> wrong window
22:11:37 <monochrom> well, bon appetite!
22:11:46 <penelope> Now I'm hungry.
22:12:36 <companion_cube> othiym23: looks like the guy of telehash works on locker now, but is telehash still an alive project?
22:12:54 <companion_cube> where does this "bon appetite" come from?
22:12:55 <tkahn6> is it worth reading John Hughes's original paper on arrows?
22:13:09 <monochrom> from sinking into a pizza
22:13:13 <othiym23> companion_cube: absolutely (quartzjer is one of my coworkers, if it's not obvious)
22:13:16 <tkahn6> from a didactic perspective
22:13:57 <othiym23> companion_cube: the protocol is pretty mature, it's just a matter of finding applications (some people have gotten UDT running on top of Telehash, which means that it's possible to do stateful connections on top of the DHT)
22:13:59 <companion_cube> too bad there's no python implem of it
22:14:17 <jtobin> companion cube: import pizza
22:14:27 <companion_cube> want
22:15:23 * ski . o O ( <http://homepages.inf.ed.ac.uk/wadler/topics/gj.html#pizza> )
22:16:12 * companion_cube has been dreaming of a command-line pizza ordering software for a while
22:16:30 <othiym23> oh yesod, you offer me mongodb support and then snatch it away when I try to actually use it
22:18:01 <penelope> heh
22:18:09 <penelope> Not alone.
22:18:38 * ski . o O ( <http://www.grammaticalframework.org/gfss/Pizza-demo.pdf>,<http://www.cse.chalmers.se/alumni/bringert/xv/pizza/> )
22:21:40 <kallisti> ski: I've never thought in URLs. interesting.
22:22:36 <monochrom> @where +RTS-xc
22:22:36 <lambdabot> I know nothing about +rts-xc.
22:22:48 <monochrom> @where RTS-xc
22:22:48 <lambdabot> ghc --make -fforce-recomp -prof -auto-all -rtsopts foo.hs && ./foo +RTS -xc
22:23:36 * hackagebot hakyll 3.2.5.1 - A static website compiler library  http://hackage.haskell.org/package/hakyll-3.2.5.1 (JasperVanDerJeugt)
22:26:17 <othiym23> if I install Haskell Distribution 2011.4.0 over my previous install, is it going to break everything forever and make me sad?
22:26:41 <othiym23> s/Distribution/Platform/g
22:27:46 <penelope> It's going to break any cabal installs you have: in that, you'll need to install them again
22:28:37 <othiym23> does cabal have a convenient way for it to dump its state before the upgrade and then restore it afterwards?
22:28:38 * hackagebot couchdb-conduit 0.5.1 - Couch DB client library using http-conduit and aeson  http://hackage.haskell.org/package/couchdb-conduit-0.5.1 (AlexanderDorofeev)
22:29:17 <penelope> you can sort of do that manually: ghc-pkg list > cabal.state.txt
22:29:31 <penelope> edit the file,
22:29:45 <monochrom> previously built libraries are not useful for new GHC version
22:29:49 <penelope> deleting everything in your system-installed section
22:30:08 <penelope> and then run, after you've upgraded,
22:30:27 <penelope> a, say, bash script to re-cabal install them
22:30:29 <othiym23> penelope: thanks
22:30:46 <othiym23> was looking at the output of cabal list --installed --simple-output but it was looking noisy
22:30:48 <monochrom> so it is not so much "break" as in "not honoured"
22:31:00 <companion_cube> telehash seems really awesome *_*
22:31:10 <companion_cube> and json is a good choice
22:31:15 <monochrom> also, "cabal list --installed" sometimes lies
22:31:17 <penelope> while read i; do ghc-pkg unregister --force $i; done < pkg.list
22:31:37 <penelope> You'd replace ghc-pkg unregister --force
22:31:41 <penelope> with cabal install
22:31:48 <othiym23> companion_cube: it's stupidly simple to get started with it
22:32:16 <othiym23> companion_cube: we're sort of desperate to figure out how to jam it into the locker project somewhere, just to start playing with it on a larger scale
22:33:01 <othiym23> penelope: this is one of those times it kinda sucks to be on OS X instead of Ubuntu ;)
22:34:58 <companion_cube> well, you just have to start building a distributed meta-social network on top of locker using telehash
22:35:01 <companion_cube> problem solved
22:35:38 <othiym23> see, you think you're joking, but that's basically how quartzjer thinks about the world
22:35:56 <companion_cube> i was only half-joking
22:36:15 <othiym23> it's coming
22:36:17 <companion_cube> note the "meta" in "meta-social network"
22:36:33 <othiym23> I did!
22:36:52 <companion_cube> :)
22:37:04 <penelope> Now I'm thinking about what friending would mean in a meta-social networks.
22:37:10 <companion_cube> (bonus if you include irc as a social network)
22:37:10 <othiym23> playing around with lockers for a while makes clear how complicated "identity" really is on the modern web
22:37:32 <othiym23> I think we have an IRC connector in some sort of halfassed condition kicking around
22:37:48 <othiym23> but anything involving deriving social graphs from IRC usage would be hella heuristic, yo
22:37:55 <penelope> That's another thing that needs solving: context dependent identity.
22:38:16 <companion_cube> i think irc can be pretty interesting as a social graph
22:38:25 <companion_cube> people are connected to people in the same chan
22:38:42 <companion_cube> people are also hyperedges between chans
22:38:59 <companion_cube> (well, chans are hyperedges between people, and people are hyperedges between chans :D)
22:39:53 <companion_cube> penelope: indeed, identity on yelp and identity on linkedIn are almost orthogonal imhop
22:39:57 <companion_cube> imho*
22:40:08 <othiym23> uninstall-hs thru, I like you
22:41:01 <othiym23> you could write a dissertation on "Procrustean Personæ: Identity on Yelp and the Reviewer's Voice"
22:41:15 <penelope> Oh wait...
22:41:36 <penelope> Didn't I read something about yelp gatherings?
22:41:40 <othiym23> companion_cube: OK, but what about rich sets like #bash or #debian that are mostly filled with lurkers?
22:42:17 <penelope> Something about how they all turned into glutton monsters when food was in their vicinity
22:42:18 <othiym23> you'd want to have some sort of function that maps strengths to edges based on a user's level of activity on the channel, and their level of interaction with other users on the channel
22:43:07 <companion_cube> indeed
22:43:14 <penelope> Let's not forget the old usnet C++ node, with the endless flamewars.
22:43:22 <companion_cube> you can tag the hyperredge with the #nameofchan, also
22:43:39 <wavewave> i cannot believe how this single version of ghc has so many improvement.
22:43:44 <companion_cube> but the strength of an edge is like (activity/number of people)
22:44:49 * wavewave is reading ghc user's guide 
22:47:19 <penelope> http://blog.pinboard.in/2011/11/the_social_graph_is_neither/
22:49:14 * Sgeo ponders an Applyable class that is basically types that can be semantically thought of as a function
22:49:32 <Sgeo> Map a b can be thought of as a -> Maybe b for instance
22:49:44 <penelope> Aren't those just categories?
22:50:12 <othiym23> Maciej is a smart guy
22:50:27 <wavewave> Control.Category
22:50:52 <Sgeo> Does a category cat a b define a way to get from a to b?
22:51:05 <Sgeo> What's the equivalent of ($) for categories?
22:51:24 <othiym23> if I run Haskell Platform 2011.04 and OS X 10.7.3, what issues am I likely to run into?
22:52:30 <ski> @type app
22:52:31 <lambdabot> forall (a :: * -> * -> *) b c. (ArrowApply a) => a (a b c, b) c
22:53:06 <penelope> don't forget to read the original: http://code.google.com/p/daxp/downloads/detail?name=pepsi%20gravitational%20field.pdf
22:53:28 <Sgeo> ski, that.. isn't.. wait
22:53:31 <glguy> othiym23: none?
22:53:33 <Sgeo> Hmm
22:53:34 <companion_cube> penelope: the url about the social graph is interesting
22:53:49 * Sgeo remembers app for functions being uncurry ($)
22:53:54 <Sgeo> Or something
22:54:07 <othiym23> glguy: comments on https://gist.github.com/1169332 indicate that that's why he's recommending upgrading to GHC 7.2.x
22:54:23 <Sgeo> That still is only a way to transform the things
22:54:27 <ski> @type uncurry ($)
22:54:28 <lambdabot> forall b b1. (b -> b1, b) -> b1
22:54:29 <ski> @type curry app
22:54:30 <lambdabot> forall b c. (b -> c) -> b -> c
22:54:44 <Sgeo> That's not actually knowing that you can, in fact, apply something
22:55:00 <Sgeo> :t curry
22:55:00 <lambdabot> forall a b c. ((a, b) -> c) -> a -> b -> c
22:55:21 <Sgeo> curry app is not helpful here, the curry forces the app to only work with actual functions.
22:57:59 <wavewave> Sgeo: I am not so clear yet in my mind... but you can consider (const x) as  a value x in function space
22:58:07 <glguy> othiym23: I've been using it at home and work without any fuss on (now) 10.7.3 and Xcode 4.2.1
22:58:18 <wavewave> Sgeo: then consider (.) as a applicatin.
22:58:31 <glguy> othiym23: without more information I'd say that that comment is related to something very specific that that person did
22:58:41 <othiym23> glguy: thx, will leave well enough alone for now
22:58:44 <Sgeo> The point is I want to be able to use a Map a b identically to a a -> Maybe b without having to use flip lookup
22:58:51 <Sgeo> A same function, call it $, for both
22:58:51 <othiym23> although I'm definitely interested in playing around with 7.4
22:59:03 <penelope> omg
22:59:21 <Sgeo> Since the only reason Map a b is not a type synonym for a -> Maybe b is so it can store its own data for efficiency purposes, if I understand correctly.
22:59:24 <penelope> finally back to a good data nested parallism...
23:00:05 <wavewave> Sgeo: truly.
23:00:17 <ski> @type curry_ app
23:00:18 <lambdabot> forall (ar :: * -> * -> *) b c. (ArrowApply ar) => ar (ar b c) (ar b c)
23:00:29 <Sgeo> :t curry_
23:00:30 <lambdabot> forall (ar :: * -> * -> *) a b c. (Arrow ar) => ar (a, b) c -> ar a (ar b c)
23:00:42 <ski> @type uncurry_
23:00:43 <lambdabot> forall (ar :: * -> * -> *) a b c. (ArrowApply ar) => ar a (ar b c) -> ar (a, b) c
23:01:01 <penelope> Sgeo: The order is wrong
23:01:19 <ski> (Sgeo : "the curry forces the app to only work with actual functions" -- that was sortof the point)
23:02:21 <Sgeo> I guess what I want is a typeclass for data types where there's a function ($) such that theDataType $ targetType is the destinationType
23:02:52 <penelope> Also: Map is a very specific thing: it's an implementation
23:03:36 <penelope> Sgeo: What about Functor?
23:03:50 <wavewave> Category (->) ,  and   f  (:: a->b) . const a = const b ... get a value from Pointed type class.
23:04:07 <Sgeo> penelope, the result of the fmap is still part of the ... thing
23:04:23 <Sgeo> Basically, I want something that can encompass (flip lookup), for example
23:04:28 <penelope> oh
23:04:32 <wavewave> I am saying (.) as $
23:05:20 <Sgeo> wavewave, that sounds promising, but I don't quite understand it
23:05:28 <wavewave> Category (bottom) a  can be regarded as a value
23:05:54 <wavewave> the only problem of category is that it always has two type parameters
23:06:02 <wavewave> for defining $.
23:06:13 <wavewave>  function $ value
23:06:30 <wavewave> function has two type parameters (input, output) but value has only one parameter..
23:06:48 <wavewave> so now I promote value to  function with bottom as input parameter.
23:07:02 <wavewave> i.e. polymorphic to any types
23:07:33 <wavewave> then function . function (=promoted from value) = function $ value
23:07:56 <wavewave> that promotion is const in (->) type constructor.
23:08:37 * hackagebot ftp-conduit 0.0.2 - FTP client package with conduit interface based off http-conduit  http://hackage.haskell.org/package/ftp-conduit-0.0.2 (MylesMaxfield)
23:08:49 <wavewave> then later you need to escape category to get your final value..
23:09:09 <wavewave> in (->) case, you just apply your final result to bottom.
23:09:38 <wavewave> this is a pointed functor..  allowing m a -> a
23:09:53 <dobblego> is there a data structure that "turns off the appending" of a Monoid -- such a thing appears to have an associative bind without an identity (semigroup)?
23:10:06 <dobblego> er, turns off the appending of Writer
23:10:15 <penelope> I thought a pointed functor allowed: a -> m a ?
23:10:19 <dobblego> yes it does
23:10:31 <dobblego> copointed functor is m a -> a
23:10:35 <wavewave> penelope... ah.. yeah.. maybe I should say copointed.
23:11:07 <dobblego> hey edwardk
23:11:08 <penelope> Oooh. The coopointed stuff. Next on my haskell netflix.
23:11:18 <edwardk> heya
23:11:50 <dobblego> hey mate, is there a thing, which is not a monad, but does have bind, that can be applied to "Writer but without the appending"?
23:12:07 <edwardk> ?
23:12:16 <dobblego> let me show you my scribbling
23:12:19 <dobblego> http://paste.pocoo.org/show/545553/
23:12:21 <edwardk> that reads almost like a riddle ;)
23:12:30 <dobblego> yeah sorry, bit under the weather
23:12:42 <penelope> Oh: so here's a question: Can any Monad implement Applicative without reference to (>>=) or join?
23:12:59 <penelope> and by any, I mean all
23:13:02 <penelope> Or
23:13:03 <dobblego> penelope: what else would there be to reference?
23:13:03 <edwardk> i have an instance for that in the semigroupoids package
23:13:18 <dobblego> edwardk: I thought you would, that's why I asked -- care to linky me?
23:13:30 <dobblego> or perhaps, tell me its name
23:13:43 <penelope> You mean: a monad instance which can't do <*> without >>= ?
23:13:48 <wavewave> semigroupoid is package name.
23:13:50 <dobblego> and, do you split into the three like I have done? (Writer, NoWriter, EitherWriter)
23:13:59 <edwardk> look for http://hackage.haskell.org/packages/archive/semigroupoids/1.2.6/doc/html/Data-Functor-Bind.html
23:14:06 <dobblego> penelope: (<*>) is derivable from monad primitives
23:14:13 <dobblego> edwardk: sweet thanks
23:14:45 <tkahn6> hmm
23:14:56 <tkahn6> how do i check for a match with regex?
23:15:14 <edwardk> with your nowriter. where are you using the semigroup?
23:15:15 <tkahn6> doing "foo" =~ "(foo|bar)" :: Bool doesn't seem to work anymore
23:15:30 <dolio> edwardk: Mission accomplished.
23:15:32 <penelope> That is, just using pure and fmap?
23:15:32 <dobblego> edwardk: good point
23:15:49 <edwardk> you're just using the 'last' semigroup
23:15:55 <dobblego> penelope: no, you cannot build (<*>) from pure and fmap
23:15:59 <dolio> edwardk: Datalotion now loads logos from file.
23:16:09 <edwardk> dolio: hahahahaha
23:16:25 <edwardk> did you figlet all of runar's names?
23:16:35 <dobblego> edwardk: which is the 'last' semigroup exactly?
23:16:36 <dolio> Not all. Just some more choice ones.
23:17:02 <edwardk> dobblego: a <> _ = a    or _ <> a = a
23:17:19 <dobblego> yeah right of course
23:17:33 <edwardk> on re-reading your NoWriter looks like the former, which is "First" in the semigroups parlance
23:18:17 <dobblego> edwardk: do you have anything equivalent to OnOffWriter?
23:18:24 <edwardk> the on-off writer is also something that can be built with an appropriate semigroup
23:18:39 <dobblego> you mean, Bind can be built right?
23:18:54 <edwardk> yeah
23:19:01 <dobblego> yeah I think I have that
23:19:23 <edwardk> its not a monad, just something for which kleisli composition forms a semigroupoid
23:19:32 <dobblego> I was mostly just checking that, I bet I have invented something out of edwardk's semigroupoids, and what can I do better?
23:19:44 <edwardk> heh
23:19:55 <dobblego> thanks for the tips mate
23:20:19 <edwardk> now the interesting thing for me is how many monads can actually be made 'bind transformers'
23:20:25 <edwardk> and which ones precisely can't
23:20:39 <dobblego> yeah that has a feely-good thing to me too
23:20:42 <edwardk> and how on the comonad side, all of the comonad transformers can be made extend transformers
23:21:19 <edwardk> but on the monad side all the monads which suck from the standpoint of monad plus can't be made into bind transformers ;)
23:22:44 <penelope> My kitten just requsted a pretty graph of all these relations.
23:23:14 <edwardk> penelope: dmwit packaged up someone that into a new category-extras ;)
23:23:29 <edwardk> http://dmwit.com/category-extras/dependencies.png
23:23:34 <dobblego> he packaged an actual person into a hackage package?
23:23:36 <edwardk> graph ;)
23:23:40 * hackagebot ftp-conduit 0.0.3 - FTP client package with conduit interface based off http-conduit  http://hackage.haskell.org/package/ftp-conduit-0.0.3 (MylesMaxfield)
23:24:50 <dobblego> edwardk: have you got NoWriter and OnOffWriter in semigroupoids?
23:24:52 <wavewave> yoohoo.
23:25:12 <wavewave> that graph is very impressive.
23:25:20 <edwardk> NoWriter is just (,) (First x)
23:25:35 <dobblego> oh yeah of course
23:25:36 <edwardk> wavewave: he elided most of the interesting bits ;)
23:25:44 <edwardk> the other isn't really all that fundamental
23:25:55 <dobblego> I think NoWriter is a bit uninteresting, but what about OnOffWriter?
23:26:38 <edwardk> well, you can build the semigroup for that but i'm missing one of the cases for your >>= in that paste ;)
23:26:49 <dobblego> oh
23:26:50 <Taneb> Hello!
23:26:57 <dobblego> yeah forgot that
23:27:19 <dobblego> lemme bang it out
23:27:21 <wavewave> edwardk: i was exploring  your category-extra related stuff last night for understanding data-lens better
23:28:32 <Taneb> I'm trying to imagine Haskell as a web-scripting language like Javascript
23:28:40 * hackagebot hlint 1.8.22 - Source code suggestions  http://hackage.haskell.org/package/hlint-1.8.22 (NeilMitchell)
23:28:49 <wavewave> Taneb : soon it will be realized
23:28:57 <dobblego> edwardk: http://paste.pocoo.org/show/545556/ I think that is right
23:29:16 <wavewave> Taneb: uhc or ghcjs.
23:29:35 <tkahn6> guys any help with using the regex library?
23:29:42 <wavewave> Taneb : or google's pnacl?
23:29:54 <penelope> edwardk: omg. this has to stop. There must be one fundamental type, and a series of fundamental symmetry-breaking operations which lead to the zoo.
23:30:07 <edwardk> are you sure that is associative? i haven't checked
23:30:34 <dobblego> no I haven't checked
23:30:46 <edwardk> i'm guessing it probably isn't
23:30:51 <dobblego> :(
23:31:47 <dobblego> no, it isn't, but is there one that is?
23:31:52 <edwardk> probably
23:31:55 <penelope> tkahn6: it's a bit wierd. You get the info you want by specifying the type afterwords: it's heavily overloaded.
23:32:22 <tkahn6> penelope: thanks, this doesn't seem to work anymore "foo" =~ "(foo|bar)" :: Bool
23:32:45 <tkahn6> this isn't my gist, but it's the same error: https://gist.github.com/1626445
23:32:55 <edwardk> you basically have something like a Semigroup m => Semigroup (Either a m), but since you toggle both off and back on it is broken
23:33:03 <dobblego> right
23:33:15 <Taneb> I'm trying to think of something that you can go <script type="application/haskell">changeText :: Action -> IO (); changeText (Action _ textbox _) = replaceText textbox "foo"</script>
23:33:25 <tkahn6> Taneb: have you seen Roy?
23:33:30 <btvl> hi, in a "case x of" statement, how can I have the default case do nothing ?
23:33:30 <Taneb> I havenot
23:33:32 <edwardk> if you had something where Left a <> _ = Left a; Right a <> Right b = Right (a <> b); _ <> Left b = Left b you'd be associative again
23:33:37 <tkahn6> Taneb: https://github.com/pufuwozu/roy
23:33:39 <dobblego> btvl: case _ => ...
23:33:46 <btvl> ah nice
23:33:47 <btvl> thanks
23:33:59 <dobblego> the ... isn't syntax, you need to fill that out
23:34:04 <Taneb> Still not quite what I was going for
23:34:10 <btvl> well i want it to do nothing
23:34:17 <Taneb> Really, I'm imagining a browser rather than a language
23:34:24 <ski> what does "do nothing" mean ?
23:34:25 <dobblego> btvl: what does it mean to "do nothing"?
23:34:27 <tkahn6> btvl: usually written otherwise -> return ()
23:34:30 <edwardk> btvl: if you are returning an Int what does it mean to 'do nothing'?
23:34:42 <btvl> it is in an IO thingie
23:34:46 <tkahn6> i assume that's what he means..
23:34:46 <btvl> so i suppose return () will do
23:34:48 <ski> `return ()', then
23:34:56 <edwardk> case x of 1 -> 2   -- what do i do for the other branches?
23:35:03 <btvl> works perfectly
23:35:05 <Jafet1> return () does not do nothing! It returns ()!
23:35:07 <ski> (assuming the type is actually `IO ()', and not `IO Int' or something)
23:35:09 <edwardk> well, for IO () -- there is an obvious placeholder for doing nothing. return ()
23:35:24 <edwardk> there are even combinators for using it
23:35:26 <btvl> thanks
23:35:27 <edwardk> :source when
23:35:32 <edwardk> @source when
23:35:32 <lambdabot> when not available
23:35:37 <ski> @src when
23:35:38 <lambdabot> when p s = if p then s else return ()
23:35:49 <tkahn6> mad internet creditz for wheover can figure out how to do a simple boolean match with the regex library
23:36:07 <edwardk> tkahn6: the usual answer seens to be to write your own ;)
23:36:25 <tkahn6> lol there's a whole damn library for regex and they've changed it
23:36:27 <edwardk> tkahn6: however, pretend you are in perl, _then add a manual type annotation_
23:36:45 <tkahn6> "foo" =~ "(foo|bar)" :: Bool used to work
23:36:48 <tkahn6> and now it does not
23:36:56 <edwardk> the problem is the regex api was designed by someone who was fetishing the ad hoc overloading of perl's regexes
23:37:06 <edwardk> fun
23:37:12 <ski> @index when
23:37:12 <lambdabot> Control.Monad, Control.Monad.Reader, Control.Monad.Writer, Control.Monad.State, Control.Monad.RWS, Control.Monad.Identity, Control.Monad.Cont, Control.Monad.Error, Control.Monad.List
23:37:14 <ski> @source Control.Monad
23:37:14 <lambdabot> http://darcs.haskell.org/packages/base/Control/Monad.hs
23:37:16 <tkahn6> it's literally the most overengineered thing ever
23:37:47 <edwardk> then you seem to have a more recent data point than i do ;)
23:37:50 <edwardk> good luck ;)
23:38:06 <tkahn6> :///
23:38:11 <tkahn6> thanks tho
23:38:14 <penelope> Well, someone finally said it.
23:38:16 <Jafet> A sample of perl.
23:38:22 * ski isn't sure when one would want to use regexen
23:38:38 <Jafet> When parsing regular languages
23:39:21 <edwardk> they are actually quite nice for building lexers, etc.
23:39:47 <edwardk> and for recognizing the skeletons of visually pushdown languages
23:40:18 <tkahn6> i just wanna know if a string matches "\d{4}-\d{2}-\d{2}" and it's taken me like an hour and i haven't gotten anywhere
23:40:23 <tkahn6> ://///
23:41:08 <tkahn6> i mean i gues i could just write a function myself to check but _there is a regex library_
23:41:16 <Jafet> > "2012-02-03" =~ "\\d{4}-\\d{2}-\\d{2}" :: Bool
23:41:17 <lambdabot>   False
23:41:27 <edwardk> tkahn6: 10 lines later you could be bound to an external pcre manually through ffi ;)
23:41:32 <tkahn6> heh
23:41:38 <tkahn6> Jafet: that's running an older version
23:41:48 <Jafet> Use the older version!
23:41:59 <dobblego> edwardk: this appears to match your description http://paste.pocoo.org/show/545558/
23:42:02 <tkahn6> maybe i'll do that
23:42:12 <tkahn6> can u ask lambdabot what version it's using?
23:42:29 <dobblego> er wait no
23:42:35 <Jafet> Unfortunately, "use the older version" doesn't work for Data.Time.
23:42:45 <edwardk> your Off On -> On will break
23:42:48 <edwardk> yeah
23:42:54 <dobblego> http://paste.pocoo.org/show/545559/
23:42:58 <dobblego> yeah oops
23:43:04 <wavewave> tkahn6 : I have a solution
23:43:06 <penelope> there are other options...
23:43:13 <tkahn6> wavewave: k
23:43:19 <dobblego> edwardk: is that what you mean with your Either suggestion?
23:43:19 <edwardk> now i believe associativity ;)
23:43:23 <edwardk> yeah
23:43:29 <dobblego> great so do I, thanks
23:43:53 <penelope>  regex-posix
23:44:06 <tkahn6> that is 'new an improved' as well
23:44:11 <tkahn6> i've used pcre and posix
23:44:15 <wavewave> http://hpaste.org/57393
23:44:20 <tkahn6> both are 'improved'
23:44:55 <wavewave> tkahn6: see the pasted code.
23:44:58 <edwardk> you can make a semigroup that looks like that out of two other semigroups. data E a b = L a | R b; instance (Semigroup a, Semigroup b) => Semigroup (E a b) using the 'biased' selection of the L branch whenever both are present
23:45:00 <wavewave> it works for me
23:45:15 <edwardk> it doesn't really have much motivation though
23:45:35 <dobblego> yeah, I can see that possibility and its lack of motivation -- appreciate the tips a lot, thanks
23:45:37 <edwardk> i use it, my file position monoid, etc. can be seen as variations on the theme
23:45:48 <tkahn6> wavewave: weird
23:45:51 <tkahn6> maybe it's a ghci thing?
23:46:36 <edwardk> data Delta = Col Int | Line Int Int | File String Int Int  -- is another similar variation on the theme, where you gain information
23:47:11 <edwardk> trifecta uses that one all over the place
23:47:19 <edwardk> or at least a slightly better version
23:47:19 <wavewave> old regex-posix assumes String as your default but not it's not.
23:47:22 <wavewave> now it's not.
23:47:42 <edwardk> http://hackage.haskell.org/packages/archive/trifecta/0.49.1/doc/html/src/Text-Trifecta-Rope-Delta.html
23:47:48 <wavewave> because ByteString is much faster.
23:47:56 <tkahn6> ah i see
23:47:58 <tkahn6> you rock
23:47:59 <tkahn6> thanks
23:48:08 <wavewave> so use OverloadedStrings and import those modules.
23:48:16 <wavewave> you can do it in ghci too.
23:48:21 <tkahn6> yeah i see
23:48:28 <edwardk> dobblego: that semigroup in there was fun to write ;)
23:48:59 <edwardk> whats worse is that isn't even the final version =/
23:49:08 <wavewave> but since quoted string is now polymorphic, you need to typeannotate them explicitly as my pasted code.
23:49:35 <edwardk> the real version also adds ghc line directive push/pop operations
23:50:03 <wavewave> tkahn6 : this kind of library breakage is rather common.. from specific type to more general type. then you need to import some specific modules for specific instances.
23:50:21 <dobblego> why was it fun?
23:50:45 <wavewave> especially string , bytestring, text... kind of thing.
23:50:59 <edwardk> well, with the stack its kind of interesting because you have opening/closing contexts to deal with, and it becomes a model for dealing with this idiom in general
23:51:16 <tkahn6> yeah
23:51:19 <tkahn6> thank you
23:51:31 <edwardk> you are dealing with a monoid for file position in the presence of #line directives, which means you can 'return' from files you haven't even entered yet, etc.
23:51:37 <wavewave> welcome. hope you enjoy using regex in haskell again ;-D
23:51:43 <edwardk> so you wind up with a negative stack of files some times =)
23:51:43 <tkahn6> hahaha
23:58:40 * hackagebot scan-vector-machine 0.2.6 - An implementation of the Scan Vector Machine instruction set in Haskell  http://hackage.haskell.org/package/scan-vector-machine-0.2.6 (AdamMegacz)
