00:05:46 <blackdog> if i were to use "unsafePerformIO . inet_ntoa", would i be in a state of sin?
00:06:04 <blackdog> and if so, how does show do it?
00:06:47 <NihilistDandy> my brain~
00:07:21 <scolobb> damo22: What exactly do you mean by "interpreted by Haskell"?  Symbols like '\t' and '\n' are interpreted by output functions.
00:07:57 <scolobb> damo22: Expansions of command line arguments such as "*.jpg" doesn't happen, for example
00:08:00 <damo22> well i am having issues with passing regular expressions as bash arguments
00:08:05 <hpaste> smoge pasted “cmath” at http://hpaste.org/57566
00:08:08 <smoge> Hi
00:08:11 <damo22> i guess thats ot
00:08:14 <smoge> I'm getting this error with cmath
00:08:18 <smoge> any ideas??
00:08:21 <Botje> damo22: put them in ''
00:08:57 <scolobb> damo22: Do you want to pass regular expressions in GHCi into :main?
00:09:08 <scolobb> You should escape each backslash then
00:09:13 <damo22> ok
00:09:24 <scolobb> \s* -> "\\s*" , per examle
00:09:58 <hpaste> NihlistDandy pasted “Seeking pointers” at http://hpaste.org/57567
00:10:06 <smoge> `Cannot find uhc on the path`
00:10:11 <damo22> i think i will modify the program to read the regexp from a file
00:10:16 <NihilistDandy> Any help, no matter how obtuse, is appreciated
00:10:43 <scolobb> damo22: Sounds reasonable
00:10:45 <NihilistDandy> I know it's OCaml, but no one talks on their channel :/
00:11:31 <NihilistDandy> I have no idea why this, of all things, is what is tripping me up.
00:12:20 <blackdog> goddammit. showing a sockaddr involves unsafePerformIO? Why are there not villagers with pitchforks whipped into a frothing lather?
00:13:17 <smoge> Any ideas? http://hpaste.org/52658
00:13:57 <xil> hey everyone. Question about class declarations. I have a data type A that has 2 internal types, let's say Int and Double, but it could be anything. I want to be able to tell the class about Int and Double. Could I do something like "class myA (dataA, first, second)" where the instance for A would be "instance myA(A, Int, Double)"?
00:14:05 <xil> Until now I've been doing it without the tuple, forcing me to define A as "data A f s = A ...", but that doesn't limit f and s to Int and Double respectively. I would just try this but I'd like more info than I'd get from the compiler, or than I've gotten from the internet
00:15:28 <ivanm> xil: not sure I follow
00:15:34 <ivanm> data Foo = Bar Int | Baz Double
00:15:38 <ivanm> ^^ what do you want to do with that?
00:15:46 <ivanm> or are they type parameters, ala Either?
00:15:56 <scolobb> smoge: "configure: error: cannot run C compiled programs." I'd normally try build a run a sample C program of my own in this case
00:17:09 <xil> I want a class with 2 functions, one with type a -> foo and another of type b -> (foo, b)
00:17:30 <xil> for the Foo type you just declared it would be Int -> Foo and Double -> (Foo, Double) respectively
00:17:55 <xil> but that's the instance. The problem is in the class declaration. Right now I do "class myFoo (foo a b)..."
00:18:01 <ivanm> so, use type families or MPTCs + FDs
00:18:12 <xil> that went right over my head
00:18:43 <ivanm> class DualTypes a where type FirstType a; type SecondType a; firstType :: (FIrstType a) -> a; etc.
00:19:33 <xil> oh no, what I mean is that I want to be able to specify the Int and Double when using the class as a constraint
00:19:42 <ivanm> you do
00:19:45 <ivanm> when you make your instance
00:20:11 <ivanm> alternatively: class DualTypes a f s | a -> f, a -> s where firstType :: f -> a
00:20:11 <ivanm> etc.
00:20:23 <ivanm> @google AssociatedType
00:20:25 <lambdabot> http://www.haskell.org/haskellwiki/GHC/Type_families
00:20:26 <lambdabot> Title: GHC/Type families - HaskellWiki
00:20:28 <ivanm> ^^
00:22:40 <xil> when I write a function that depends on myFoo I want to write "(myFoo (Foo Int Double)) => ..." but I feel like that requires that Foo be "data Foo f s = ...", which isn't what I want
00:23:52 <xil> which is why I was thinking I should declare the class as "class myFoo (foo, first, second)" with the tuple, to signify that all of the kinds are just *
00:26:18 <ivanm> oh, so they're _type parameters_
00:26:21 <ivanm> e.g. like Either
00:26:28 <Peaker> is kind inference disabled now? Or can it see that it is * from their use inside?
00:27:05 <ivanm> class Foo a where fromFirst :: first -> a first second; fromSecond :: second -> a first second
00:27:15 <xil> ivanm: I honestly don't know, but in the mean time while we discuss this I am reading that page you linked
00:27:39 <ivanm> if you want constraints, then you'll need to use an MPTC+FD approach I think: class Foo a first second | a -> first, a -> second where <same as before>
00:27:50 <ivanm> xil: maybe actually give your use case without Foo, etc.?
00:28:05 <xil> to HPaste! One sec
00:31:00 <qnikst> hello, can you help me with one problem: http://paste.pocoo.org/show/547185/
00:32:48 <hpaste> xil pasted “class types” at http://hpaste.org/57569
00:32:57 <xil> ivanm: ^^
00:34:04 <ivanm> xil: you can't do it like that
00:34:11 <xil> yeah I know
00:34:15 <xil> but I don't know how to do it
00:34:28 <ivanm> xil: do the signal and weight types change when using the HNeural class?
00:34:38 <ivanm> otherwise, use one of the first approaches I used
00:35:21 <xil> well the idea is to write many types of network which don't necessarily have the same signal and weight types, or even some having arbitrary types and some having specific ones, but all using this class
00:35:51 <xil> and those function defined by the class need specific types to go into them depending on the network type
00:36:33 <xil> but I'm trying to make sense of your examples by relating it to that type family page you linked
00:36:50 <ivanm> lemme do an annotation
00:38:08 <ivanm> xil: there's one mis-match in your class: should the i values be up to the implementation or the caller of the methods?
00:38:17 <ivanm> you're currently saying the latter, but it looks like you want the former
00:39:03 <hpaste> ivanm annotated “class types” with “class types (annotation - TFs)” at http://hpaste.org/57569#a57570
00:39:24 <xil> it's hideously impractical for Integers to ever be used, but I felt like, "why restrict that?" so I left it up to the caller because Integral ought to define all method's those functions should need
00:40:01 <ivanm> then you need to use fromIntegral throughout your instance definitions to get them to/from the Ints you're actually using
00:40:16 <ivanm> anyway, ^^ that's the TypeFamily version
00:40:24 <ivanm> (note: haven't checked it works)
00:40:31 <ivanm> also, I don't think you defined Network properly...
00:41:31 <xil> I may not have. I wrote up Network just for the paste, whereas the other stuff I had already and thus it was more thought out
00:41:36 <xil> but here's a question
00:41:55 <xil> why "type Signal ann; type Weight ann" and not just "type Signal; type Weight"?
00:41:59 <ivanm> though why don't you use an existing ANN library?
00:42:04 <Ptival> @type liftM concat
00:42:05 <lambdabot> forall a (m :: * -> *). (Monad m) => m [[a]] -> m [a]
00:42:10 <ivanm> xil: you need to tie them in to what your class types are
00:43:24 <xil> I'll have to read more on type families to understand that then. And the reason I'm not using an existing ANN library is that my main goal is actually the type class which will allow me to write a library for using a genetic algorithm with neural networks
00:43:51 <xil> the class will allow me to interface, hopefully, with any ANN library, and I plan to write the instances for the existing libraries if I can, once the GA part of it is done
00:44:27 <xil> also, the various ANN libraries are vastly different and since I know exactly what I need it's almost ironically easier for me to code it from scratch that figure out how to make it happen with one of the libraries
00:44:44 <xil> than figure out*
00:46:24 <xil> but I'm dead tired now. Just wanted to figure out that one thing. Thanks for the help ivanm. I'll read more of that page tomorrow so I can make sense of your annotation
00:46:37 <ivanm> np
00:46:38 <xil> good night, or day depending on where you are in theworld
00:47:05 <mux> mmm, this error baffles me:
00:47:14 <mux> *Data.Vec> :t undefined :: TwoT :+: TwoT
00:47:14 <mux> <interactive>:1:14: Kind mis-match Expected kind `OpenKind', but `TwoT :+: TwoT' has kind `Nat'
00:47:42 <rostayob> mux: PolyKinds?
00:47:49 <mux> I have no idea why GHC would require this expression to have kind OpenKind (previously '?')
00:47:58 <mux> rostayob: yup
00:48:07 <rostayob> mux: you should post the rest of the code
00:48:09 <mux> or rather, DataKinds
00:48:32 <rostayob> still haven't played with that so I don't think I'll be able to help, but others will eheh
00:50:03 <mux> alright
00:50:11 <rostayob> mux: is that the classic naturals-indexed vector?
00:50:18 <mux> yes
00:50:49 <rostayob> mux: yeah paste the code :)
00:51:17 <mux> http://hpaste.org/57571
00:52:14 <mux> there seems to be a few rough edges with named kinds still
00:52:37 <rostayob> mux: mh. I thought you were using GADTs + pattern matching. at least that's what I remember from the polykinds paper
00:52:53 <mux> rostayob: this has nothing to do with the length-typed vectors code itself
00:52:59 <mux> this is plain type-level addition using named kinds
00:53:13 <mux> and it actually works fine
00:53:25 <mux> but this error at the GHCi prompt is weird
00:56:19 <ddarius> mux: What are the values of type TwoT?
00:56:25 * hackagebot yices 0.0.0.12 - Haskell programming interface to Yices SMT solver  http://hackage.haskell.org/package/yices-0.0.0.12 (KiYungAhn)
00:56:54 <mux> ddarius: well, S (S Z) would be a value of such a type; but I don't see the point of that question
00:57:11 <ddarius> Is it?
00:58:35 <mux> I think so
00:58:45 <ddarius> You don't need to think about it, you can ask GHC.
00:59:01 <mux> that'll be hard, TwoT is just a type synonym
00:59:16 <ddarius>  :t S (S Z) :: TwoT is hard to write?
00:59:26 <mux> if I feed him a value-level S (S Z) expression and ask it for its type it's going to answer Nat
01:00:16 <mux> ddarius: I tried that and get the same OpenKind / Nat kind mismatch
01:06:25 * hackagebot zlib-bindings 0.0.3.2 - Low-level bindings to the zlib package.  http://hackage.haskell.org/package/zlib-bindings-0.0.3.2 (MichaelSnoyman)
01:07:27 <Palmik> Hi guys, is it possible to splice TySynD in TH? For example [d| type $(conT name) = ... |] or do I have to use TySynD directly?
01:08:02 <Palmik> The obvious [d| type ... ] gives me Malformed head of type or class declaration: $(conT name)
01:08:21 <damo22> how can i write a function that achieves this:  noRepeatedCaseRegexp "[hH][eE3][Ll][oO0]" =  "(h(3l[O0]|El[o0])|H(3l[O0]|eL[o0]))"
01:08:26 <Palmik> s/splice/quote
01:09:39 <damo22> basically it takes permutations whenever the case clashes
01:09:41 <Botje> damo22: a recursive function should do.
01:10:26 <MadDogg> hi
01:10:29 <Botje> I guess this is homework, since every sensible regular expression library supports case insensitive matches?
01:10:41 <damo22> no this is not homework
01:11:04 <damo22> regex genex does not support it
01:11:09 <MadDogg> Botje  & damo22  hey
01:11:35 <cvprog> ack-grep
01:12:21 <Botje> damo22: you mean the CPAN module? it should be easy to adapt it and randomly switch case
01:12:41 <damo22> Botje: not the perl one, the haskell one
01:13:20 <MadDogg> Botje & damo22 hey
01:13:30 <damo22> Botje: i wish the haskell one supported lookahead matching
01:13:31 <MadDogg> cvprog hi
01:13:36 <Botje> MadDogg: yes, hello.
01:13:56 <ddarius> mux: Values are held by OpenKind (and its subkinds). 'Nat is not a subkind of OpenKind.
01:14:07 <cvprog> MadDogg: hello
01:14:13 <MadDogg> Botje ' what are you guys chatting about
01:14:30 <MadDogg> cvprog ' what are you guys chatting about
01:14:38 <Botje> haskell.
01:15:02 <Botje> damo22: i'd still look into fixing the regex-genex module first
01:15:27 <Botje> damo22: but i guess you're not able to take on that task yet ..
01:15:38 <damo22> no im not that advanced
01:16:03 <quicksilver> Botje: do "sensible regular expression" libraries support case insensitive matches which permit '3' for e and '0' for o?
01:16:27 <quicksilver> I'm not convinced case insensitivity is going to solve damo22's problem
01:16:28 <Botje> quicksilver: no, but damo22's example splits out the [hH
01:16:36 <damo22> i just want to break a stupid password
01:16:37 <Ptival> how do I filter?  [a] -> [Bool] -> [a]
01:16:41 <Botje> [hH] case into (h...)|(H...)
01:16:49 <quicksilver> yup
01:16:54 <quicksilver> the question is, hy?
01:16:59 <quicksilver> or maybe it's "why" ?
01:16:59 <quicksilver> ;)
01:17:04 <damo22> without filling my harddrive with 240Gb of words
01:17:28 <Botje> damo22: why not generate the strings yourself?
01:17:38 <Botje> damo22: I showed you how yesterday or day before that using sequence
01:17:52 <damo22> Botje: i tried that, it overflowed my memory
01:18:00 <Botje> Ptival: how would you filter that?
01:18:09 <Botje> damo22: well, you're supposed to use them
01:18:22 <Botje> or print them
01:18:24 <mux> ddarius: eh? not all values are of kind OpenKind
01:18:31 <Botje> if you just store up the entire list you _will_ run out of memory
01:18:42 <Ptival> Botje: keep the a's such that the matching Bool is true
01:18:53 <Botje> Ptival: ah.
01:19:06 <Ptival> (what else would I do? :D)
01:19:06 <Botje> Ptival: i'd combine filter and zip for that.
01:19:26 <damo22> I dont need to generate the whole list, i need to restrict the search, i believe using regex genex i can do this using 1 regexp
01:19:36 <ddarius> mux: Types that values inhabit are subkinds of OpenKind.
01:19:42 <Ptival> Botje: oh yeah got it...
01:19:59 <Botje> damo22: you can restrict the search using a recursive function or list comprehension as well ..
01:20:36 <ddarius> There are no values that inhabit the type TwoT.  TwoT is a type that inhabits the kind 'Nat which is not a subkind of OpenKind.
01:20:39 <mux> ddarius: "subkinds"? what's that now? I've never seen any such thing in the GHC docs; besides, why would named kinds not be subkinds of OpenKind?
01:20:46 <Botje> but the time you'll spend on making your regex amenable to regex-genex will be about the same or more than writing out the recursive function in teh first place
01:21:41 <damo22> Botje: would you assist me improving the restriction on the simple haskell program me and otters did?
01:21:47 <mux> ddarius: are you trying to say that this error message I'm getting is legit?
01:21:57 <ddarius> mux: It makes perfect sense to me.
01:22:37 <Botje> damo22: if you put your code so far (and what needs to be improved) on hpaste we'll take a look at it
01:23:00 <damo22> http://paste.ubuntu.com/832426/
01:23:28 <Ptival> @pl \a b -> map fst . filter snd $ zip a b
01:23:28 <lambdabot> ((map fst . filter snd) .) . zip
01:23:41 <Ptival> meh
01:24:08 <mux> ddarius: that is not my question ;-)
01:24:30 <ddarius> mux: That expression is ill-kinded for exactly the reason the compiler says.
01:24:35 <mux> ddarius: I'm glad it makes sense to you, but I want to know whether this is expected or not; I don't see any reason why named kinds defined via DataKinds shouldn't be subkinds of OpenKind
01:24:42 <ddarius> mux: It should be ill-kinded for exactly the reason the compiler says.
01:24:47 <mux> how is it ill kinded? it's not
01:25:15 <mux> :+: is defined as Nat -> Nat -> Nat
01:25:19 <mux> TwoT has kind Nat
01:25:30 <mux> thus TwoT :+: TwoT should be perfectly well kinded
01:25:42 <ddarius> Simplifying OpenKind to just *.  Every value satisfies, v :: t :: *.  The kind you have is 'Nat not *.  So there are no values.
01:25:48 <mux> and I don't see why OpenKind even comes into play, this kind should be used only for function application
01:25:50 <ddarius> mux: That is well-kinded.
01:25:53 <ddarius> It has kind Nat.
01:25:55 <ddarius> Nat is not *.
01:25:58 <mux> yes
01:25:59 <ddarius> So it has no values.
01:26:11 <mux> why is this relevant?
01:26:16 <mux> I'm using _|_ as the value here
01:26:17 <ddarius> Because undefined is a value.
01:26:17 <Botje> damo22: and what's wrong with that coe?
01:26:22 <mux> ...
01:26:36 <ddarius> undefined :: t :: *  TwoT /:: *
01:27:03 <mux> I would agree if GHC was indeed complaining about Nat not being the same kind as *
01:27:15 <mux> but it's not, it's talking about OpenKind, which should only come into play when function application is used
01:27:48 <ddarius> mux: That is -exactly- what it is saying.  OpenKind is just a superkind of * that is used to split * up for reasons that aren't really relevant.
01:28:36 <ddarius> If v :: t :: * then v :: t :: OpenKind.
01:29:28 <mux> I still see no logical reason for things to be that way, nor do I see in the GHC docs that I cannot use bottom as a value for named kinds
01:29:45 <NihilistDandy> u :: r :: TwoKind
01:29:46 <mux> for types of named kinds*
01:29:50 <ddarius> mux: It's not that you can't use -bottom- it's that you can't use -any- values.
01:29:59 <mux> yes well that amounts to the same for me
01:30:09 <mux> my question remains
01:31:27 <ddarius> mux: I don't know what you're question is.  You said you'd agree if GHC was saying Nat is not * and that is pretty much exactly what GHC is saying.
01:32:42 <ddarius> mux: This is exactly identical to the fact that you can't write: undefined :: Maybe
01:32:46 <mux> ddarius: my question is: what is the explanation for GHC to forbid having a value of a type of some named kind. Would it yield an unsound type system?
01:32:56 <ddarius> mux: It just doesn't make sense.
01:33:09 <ddarius> What values would be in it?  What values are in Maybe :: * -> * ?
01:33:52 <mux> ddarius: but really we don't care at all what values would or would not be in there. GHC allows me to have data-typed without any data constructor, and doesn't whine if I then use undefined to have values of that type
01:34:07 <mux> data-types
01:34:08 <mux> *
01:34:10 <ddarius> What values are in Maybe :: * -> *?
01:34:55 <mux> ddarius: that's not my concern; that isn't a concrete type. TwoT is as far as I can tell, even if it has no values
01:35:24 <ddarius> It is a concrete type.  It has kind * -> *.  TwoT has kind *.
01:35:28 <ddarius> sorry 'Nat.
01:35:48 <mux> eh? a type of kind * -> * is not a concrete type
01:35:59 <ddarius> Or put the other way, if Maybe is not a "concrete type" then neither is TwoT.
01:36:07 <mux> ignoring named kinds for a second, concrete types are types of kind * as far as I know
01:36:21 <ddarius> mux: Okay, then TwoT is not a type of kind *.
01:36:25 * hackagebot process-conduit 0.0.2 - Conduit for process  http://hackage.haskell.org/package/process-conduit-0.0.2 (HideyukiTanaka)
01:36:51 <mux> ddarius: okay, but that doesn't explain why it would make no sense to use a bottom value for a type of such kind
01:37:21 <ddarius> Why doesn't it make sense to use a bottom value for * -> *?
01:37:57 <mux> you're comparing Nat vs * with * -> * vs *
01:38:00 <mux> that isn't fair
01:38:05 <mux> that Nat kind could very well be *
01:38:09 <ddarius> No it can't.
01:38:19 <ddarius> And why can't * -> *?
01:38:21 <mux> it sure can, I have code where is just that
01:39:07 <mux> having a named kind here allows to reject non-sensical types such as S Int, and that is fine, but why does it suddenly becomes entirely incompatible with * ?
01:40:02 <ddarius> By using data kinds you are declaring a -new- kind, distinct from all others.  Your statement is like saying, "I declared Int and it is different from String.  Why is that?  I've certainly encoded integer values into strings elsewhere.  Why doesn't it identify them?"
01:41:27 <damo22> Botje: it doesnt restrict all characters to not be consecutive same case
01:42:09 <damo22> Botje: but if i enforce that, i get a memory overflow before any words are printed
01:42:22 <mux> ddarius: the fact that by using a named kind I get a new kind that is distinct from * doesn't tell me why I couldn't use undefined for values of types of my named kind; I'm not really complaining about Nat and * being different, this is the actual goal; but it still doesn't explain why I could not use undefined here
01:43:00 <ddarius> undefined is a value.  Values only inhabit types of kind *.  That is all there is to it.
01:43:28 <mux> so you are stating that there is no logical explanation for this behaviour
01:43:44 <Botje> damo22: can you be a bit more precise?
01:43:52 <mux> and the sole reason for it is this way stems from an agreed upon definition
01:43:54 <ddarius> Is there any logical reason I can't pass 3 to a function expecting a String.
01:43:57 <Botje> can no two adjacent characters be the same case?
01:44:05 <mux> ddarius: yes, there is.
01:44:07 <damo22> Botje: correct
01:44:32 <ddarius> mux: What is it?
01:45:21 <Botje> damo22: and what do you consider the case of 0 ?
01:46:01 <mux> ddarius: because I cannot manipulate 3 as I would manipulate a String. Whereas in my example, there is nothing preventing undefined from being of kind Nat (or actually and more precisely, of any fully saturated kind)
01:46:05 <damo22> Botje: if its not in [a-z][A-Z] i dont care about the position of surrounding chars
01:47:08 <ddarius> mux: Values don't have kinds, they have types which then have kinds.  What type is undefined such that its kind is Nat?
01:47:16 <Botje> damo22: so you should write a function that walks your password and considers two characters at a time
01:47:42 <Botje> damo22: or you can be a bit smarter and factor that alternate-casing into your password generation
01:47:53 <Botje> << food
01:47:54 <ddarius> Also how can I manipulate these new values?  Every value level construct has a type that has kind *.
01:48:07 <mux> ddarius: oh come on now, I've been saying stuff like "having an undefined value whose type is of kind Nat" like 4 or 5 times in a row, cut me some slack, you _know_ what I was saying
01:48:44 <ddarius> mux: I'm asking you what type that is?  Is it Z, or S Z, or S (S Z), or ... ?
01:49:14 <mux> ddarius: in my example, the type was perfectly defined, and it was S S S (S Z) (four)
01:49:43 <mux> missing parens, sorry
01:49:57 <mux> S (S (S (S Z)))
01:50:03 <ddarius> mux: Okay, so how can I manipulate these "values" of type S (S (S (S Z))) as I would a value of type Int say or any other type of kind *?
01:50:38 <mux> ddarius: we're talking about bottom here, so that question seems irrelevant to me; you cannot really manipulate this
01:51:03 <ddarius> I can pass undefined to a function, I can store undefined in a list.  I can return undefined.  I can apply functions to undefined.
01:51:20 <mux> sure, and you could do that with the undefined of the type & kind I 've been talking about...
01:51:34 <ddarius> mux: No I can't.  Application expects types of kind *.
01:51:41 <ddarius> Lists store types of kind *.
01:51:50 <mux> fine, you can't apply functions to this defined
01:51:51 <ddarius> Functions return values of types of kind *.
01:51:55 <mux> that doesn't change anything.
01:52:07 <mux> s/defined/undefined/
01:52:18 <ddarius> Your positing a value that can't be used in anyway like a value.
01:52:38 <mux> only because you defined it such that it can't
01:52:49 <mux> and I'm still (still, still...) asking for a logical explanation
01:52:54 <mux> I guess I'm wasting my time
01:52:58 <ddarius> mux: Well then 3 can't be used as a String only because we defined it such that it can't.
01:53:16 <ddarius> Which is a perfectly reasonable view.
01:53:17 <mux> so, I assume you are not interested in actually answering my question. fine.
01:55:06 <ddarius> mux: We could assert that 'Nat is a subkind of * somehow, but then we'd need to assert some values for the types of this kind.  Then we'd need to assert some rules about how those values behave with other values.  And what has this given us?
01:56:27 <ddarius> There is nothing "logically" keeping us from making a bunch of arbitrary rules about this stuff, but which arbitrary rules should they be?
02:01:25 * hackagebot comonad-transformers 2.0.3 - Comonad transformers  http://hackage.haskell.org/package/comonad-transformers-2.0.3 (EdwardKmett)
02:01:40 <mux> ddarius: ah, so you _are_ interested in answering my question :-P there is nothing logically keeping us from having this. thanks. to answer your followup question, the arbitrary rules would be to give us some convenience
02:02:05 <mux> as exemplified by the fact that I cannot use undefined to check type-level functions
02:02:19 <mekeor> how is the number of arguments of a function called ?
02:02:27 <mux> mekeor: the arity of a function
02:02:31 <ddarius> mux: Can you list some of these arbitrary rules and what they would be?
02:02:37 <ddarius> Also note, you can just use :k.
02:02:39 <mekeor> s/how/what/ # ?
02:02:43 <mekeor> mux: thanks! =)
02:02:47 <mux> ddarius: no I cannot just use :k here
02:03:08 <mux> using :k would only tell me that my resulting type has kind Nat
02:03:15 <mux> it wouldn't tell me the actual resulting type
02:04:06 <ddarius> And wouldn't :t undefined :: TwoT :+: TwoT just tell you that the resulting type was TwoT :+: TwoT (or at least, wouldn't that be a perfectly acceptable thing to do?)
02:05:01 <mux> ddarius: it is my understanding that it would tell me the resulting type is S (S (S (S Z)))
02:05:05 <jeltsch> I’m just trying to install cabal-install with GHC 7.4.1.
02:05:06 <ddarius> mux: Why should it?
02:05:24 <NihilistDandy> jeltsch: You'll need to grab the darcs head version
02:05:25 <mux> ddarius: because if memory serves, this is how GHC behaves if those weren't of kind Nat but of kind * instead
02:05:36 <mux> ddarius: but that's quite irrelevant to my problem/question :-P
02:05:41 <ddarius> mux: Yes, it usually normalizes in that case.  There is no compulsion for it to.
02:05:45 <NihilistDandy> jeltsch: darcs get http://darcs.haskell.org/cabal/
02:05:50 <mux> I wouldn't complain if GHC answered TwoT :+: TwoT
02:05:54 <jeltsch> NihilistDandy: Okay, I’ll try that.
02:06:01 <mux> no compulsion indeed, but that's really beside the point
02:06:32 * mux has to go. &
02:06:40 <ddarius> mux: My point is what it sounds like you want is just a :normalize (or probably :normalise considering.)  This doesn't require changing the type system.
02:07:18 <mekeor> mux: bye. we'll miss you. please come back soon.
02:07:30 <Botje> damo22: giving your stuff some more thought
02:07:58 <Botje> damo22: you could start by defining a Case datatype like so: data Case = None | Lower | Upper
02:08:07 <mux> ddarius: one final word, I really have to go; I have never actually been advocating changing the type system to allow the expression I've been writing, I've been specifically asking about the _why_ things are this way and whether there was a logical explanation for it rather than a definitional one
02:08:23 <Botje> damo22: then you write an isCompatible :: Case -> Case -> Bool, which returns False when you give it Lower Lower or Upper Upper, True otherwise
02:08:50 <damo22> Botje: good idea
02:08:59 <Botje> damo22: and you can then use that in a normal recursive function Case -> String -> [String]
02:09:16 <Botje> and you can start off the process with go None input .
02:09:30 <Botje> also, you should use mapM_ putStrLn to print all passwords instead of using unlines
02:09:30 <Eduard_Munteanu> mux: well you could use an actual DT language, if I understand your problem correctly :)
02:09:48 <damo22> :D
02:09:57 <Eduard_Munteanu> That way you don't make seemingly ugly compromises.
02:10:01 <NihilistDandy> Agda wins again!
02:10:06 <Eduard_Munteanu> Yay ^^
02:10:24 <NihilistDandy> All I want for Easter is Learn You an Agda
02:10:33 <mekeor> hahah
02:11:13 <jeltsch> NihilistDandy: Will the HEAD cabal-install work with Cabal-1.14.0, which comes with GHC 7.4.1?
02:11:21 <NihilistDandy> jeltsch: Yup
02:11:25 * hackagebot comonads-fd 2.0.2.1 - Comonad transformers using functional dependencies  http://hackage.haskell.org/package/comonads-fd-2.0.2.1 (EdwardKmett)
02:11:26 * hackagebot comonad-extras 2.0.3 - Comonad transformers requiring extensions to Haskell 98  http://hackage.haskell.org/package/comonad-extras-2.0.3 (EdwardKmett)
02:12:07 <jeltsch> Why does cabal-install need the random package these days?
02:12:15 <Eduard_Munteanu> NihilistDandy: in Agda, you're dependent on coming up with your own exercises :P. No really, but there are quite a few tutorials out there, people seem to be using Ulf's these days (should be the first one on the wiki)
02:12:20 <NihilistDandy> I feel like a hipster whenever I talk programming with people at my school. I always have to preface discussions with "you've probably never heard of it" :/
02:12:22 * jeltsch wonders if a randomized installer makes sense.
02:12:29 <Eduard_Munteanu> Hah.
02:12:46 <edwardk> it does internally have to solve a big sat problem
02:12:56 <NihilistDandy> Eduard_Munteanu: I read one of Ulf's papers, but I don't know if it was that one. I remember it being very dense, tending toward opaque.
02:13:07 <NihilistDandy> But that was a while ago
02:13:19 <Eduard_Munteanu> Not his thesis, I presume.
02:13:35 <Eduard_Munteanu> Erm, I hope.
02:14:04 <damo22> > find "/" "a/b/c/d"
02:14:05 <lambdabot>   Couldn't match expected type `a -> GHC.Bool.Bool'
02:14:06 <lambdabot>         against inferred ...
02:14:06 <NihilistDandy> It may have been. I remember the typography being a bit… jaggy
02:14:11 <Eduard_Munteanu> But yeah, I guess there's no clear cut LYAA.
02:14:19 <damo22> ?
02:14:19 <NihilistDandy> I'm looking at his AFP08 paper, now
02:14:48 <Eduard_Munteanu> Yeah, that tutorial.
02:16:25 * hackagebot free 2.0.3 - Monads for free  http://hackage.haskell.org/package/free-2.0.3 (EdwardKmett)
02:16:27 * hackagebot ad 1.3.0.1 - Automatic Differentiation  http://hackage.haskell.org/package/ad-1.3.0.1 (EdwardKmett)
02:16:31 <Eduard_Munteanu> @remember NihilistDandy I feel like a hipster whenever I talk programming with people at my school. I always have to preface discussions with "you've probably never heard of it" :/
02:16:31 <lambdabot> It is forever etched in my memory.
02:16:46 <donri> NihilistDandy: Java programmer: "you've probably never heard of it, it's a private ..."
02:17:04 <NihilistDandy> lol, donri
02:17:25 <NihilistDandy> Eduard_Munteanu: It's frightfully true. It's all Matlab and Java here
02:17:30 <NihilistDandy> A little bit of Python and VB
02:17:42 <NihilistDandy> There's one functional professor, and he's all OCaml O.o
02:18:16 <NihilistDandy> Does good research, though. Lips are a bit red from all the Kool-Aid, but these things happen
02:18:44 <Eduard_Munteanu> It's mostly Matlab, Java and C/C++ (!) here too. "So what do you code in, C++?", "No, you probably haven't heard of it, but ..."
02:19:07 <NihilistDandy> Exactly
02:19:23 <matthiasgorgens> "So what do you code in, C++?" "No" Interrupts: "So Java?"
02:19:56 <NihilistDandy> I'll get on a roll about some neat bit of type theory, and then I'll come out of the haze to a room full of blank stares
02:20:11 <matthiasgorgens> By the way, we probably have an opening in our team.  Duties will include Haskell hacking.  (Yes, we are using it in production.)
02:20:14 <Eduard_Munteanu> "Haskell?", "Yeah, a purely functional PL <throw in some more words pretending to explain>".
02:20:19 * matthiasgorgens loves shameless plugs.
02:20:36 <Eduard_Munteanu> Sometimes it's even hard to explain you're doing just C and no C++ :)
02:21:27 <rostayob> Are we complaining about how the industry is stuck in C++/Java land?
02:21:27 <chu> Here the first language is Haskell, so everyone knows it ...
02:21:37 <chu> I was thinking school.
02:21:37 <rostayob> chu: here where?
02:21:45 <chu> ANU
02:21:47 <edwardk> chu: for some variation of 'knows' ;)
02:22:01 <Eduard_Munteanu> Though honestly I've written (and still write) more C code, overall, at least for useful stuff.
02:22:03 <rostayob> chu: ANU?
02:22:32 <edwardk> yeah haskell is still probably only 5% of the code i've written in my lifetime
02:22:34 <chu> Yeah, of course. But it's the required course for Bachelor of IT, Bachelor of SE and Bachelor of CS, so you get some variations.
02:22:42 <Eduard_Munteanu> (useful as in something that makes it public)
02:22:55 <rostayob> chu: oh, it's a university. that doesn't count.
02:23:09 <NihilistDandy> Eduard_Munteanu: Right? People around here can't conceive of "just C" :D
02:23:17 <chu> Ahh, I just call university school...
02:23:23 <NihilistDandy> matthiasgorgens: Oh, really? What kind of projects? :D
02:24:36 <donri> edwardk: because it's so terse amarite
02:24:46 <jeltsch> NihilistDandy: I’ve managed to install the HEAD cabal-install now.
02:25:05 <edwardk> donri: nah, even accounting for that. just i've written a lot of other code ;)
02:25:24 <NihilistDandy> jeltsch: Awesome!
02:25:43 <donri> edwardk: what are the percentages for *correct* code though?
02:26:25 * hackagebot pointed 2.0.3.1 - Haskell 98 pointed and copointed data  http://hackage.haskell.org/package/pointed-2.0.3.1 (EdwardKmett)
02:26:43 <edwardk> the amount of code that i write that is correct? probably 0.01% =)
02:27:05 <donri> haha i mean for haskell vs others
02:27:37 <edwardk> i definitely have pretty high confidence in my haskell code
02:28:22 <edwardk> but then in c++ i wind up with pretty high confidence because i spend a ton of time analyzing everything for correctness with regards to third party exceptions, etc.
02:28:38 <donri> "5% of my code is haskell, the other 95% is broken"
02:28:39 <edwardk> and in erlang because i can let the rts deal with anything that goes wrong
02:28:49 <edwardk> and python? well, my python is crap, because all python is crap.
02:29:09 <edwardk> ;)
02:29:32 <NihilistDandy> I was asking #agda about some simple logic I was writing, and once I got everything set up, I asked "So… is that closer to right?" and the response was "Try typechecking it and tell me if it's right."
02:29:39 <NihilistDandy> It did, and my head exploded a little
02:29:41 <NihilistDandy> Love it :D
02:29:55 <NihilistDandy> edwardk: Amen to that
02:30:27 <rostayob> I don't get the python hate in here. Python has proved a nice tool, at least for me.
02:30:44 <edwardk> rostayob: i baked it into every game engine i worked on for yeas
02:30:46 <edwardk> er years
02:30:53 <edwardk> it was the best tool i had at the time
02:31:07 <rostayob> edwardk: you were a gamedev?
02:31:16 <edwardk> heck i made a fair bit of money off a palm pilot game i wrote in it even ;)
02:31:52 <edwardk> i used to license rendering technology, voice compression codecs, voxel modeling tools, lip sync code, etc. to that space
02:31:54 <quicksilver> isn't lua easier to bake into engines?
02:31:57 <rostayob> edwardk: so wait, why is it that "all python is crap"?
02:31:59 <edwardk> nowadays
02:32:25 <edwardk> because python tends to favor the development of certain well worn code paths and lots of dead code around it
02:32:43 <edwardk> talk to shapr some time about the horrors of plone development
02:32:57 <rostayob> edwardk: can you elaborate/link to some article?
02:33:05 <edwardk> and the magical incantations you need to learn and which ways you construct objects that work and don't
02:33:32 <donri> http://lucumr.pocoo.org/tags/python/ has some nice points about suck in python, from someone who likes python
02:34:13 <NihilistDandy> Sidenote, the new dep solver is awesome
02:34:36 <edwardk> rostayob: try shapr, he has enough war stories to keep you entertained ;)
02:34:37 <mekeor> NihilistDandy: dep solver ?
02:34:53 <edwardk> mine are too out of date
02:34:54 <mekeor> NihilistDandy: dependency solver? what are you talking about? >.>
02:35:04 <NihilistDandy> mekeor: In the new cabal-install
02:35:11 <mekeor> ah, okay... i see.
02:35:35 <NihilistDandy> It's much better about not… you know… shattering my package tree
02:35:41 <rostayob> edwardk: mah, he's not here now, but still all the complaints I hear about python are really vague, apart the (justified) ones related to scoping
02:36:25 * hackagebot groupoids 0.1.1.2 - Haskell 98 Groupoids  http://hackage.haskell.org/package/groupoids-0.1.1.2 (EdwardKmett)
02:36:27 * hackagebot eq 0.3.4.2 - Leibnizian equality  http://hackage.haskell.org/package/eq-0.3.4.2 (EdwardKmett)
02:36:57 <edwardk> rostayob: i don't have a good example of the plone issue i mentioned above handy, but there in general were lots of ways to build objects supplied, only typically 20% of them actually worked, because they were the ones used in the main codebase most heavily
02:37:09 <edwardk> lots of twisty if/then logic where the wrong branches were just dead code
02:37:26 <edwardk> there is a lot of crap code written in any language
02:37:50 <donri> so the problem is with plone more than python?
02:37:53 <rostayob> edwardk: those are not python complaints, those are plone complaints
02:37:59 <edwardk> python/ruby/perl just favor it more than most
02:38:02 <NihilistDandy> I'm thinking of doing something about static analysis for my honors thesis
02:38:17 <NihilistDandy> I'll have to pick a fun language to work with :D
02:38:25 <edwardk> no, but the nature of the language and the lack of types tends to favor the practice of leaving dead code around that clearly wouldn't pass any form of type checking
02:38:32 <edwardk> so in some sense it IS a language issue
02:38:44 <rostayob> edwardk: ok but this is a *very* broad argument against dynamic typing
02:38:51 <rostayob> it's not against python, it's not even against OO
02:39:26 <rostayob> while I was wondering while people here dislike python in particular :P
02:39:29 <edwardk> i made one slightly glib comment, about how all python code is crap, based on my experience. ;) i wasn't trying to stand in front of a thesis committee =P
02:39:41 <DijkstraGroupie> NihilistDandy: Sounds interesting. I would like to know to what extent a compiler for a static, strongly typed language could be made more powerful if the programmer is allowed to supply proofs of certain properties of his program.
02:39:45 <donri> for a dynamic OO language, i think python is one of the better ones
02:39:47 <rostayob> edwardk: ok ok :).
02:40:11 <Leif_Bork> When I use the stream fusion library should I avoid :
02:40:14 <Leif_Bork> ?
02:40:52 <NihilistDandy> DijkstraGroupie: Ideally, I'd like to see to what extent code can be analyzed and proofs generated automatically, even in some of the messier languages. :D
02:41:12 <donri> but i still think python has its own share of problems (like any language)
02:41:30 <NihilistDandy> But there are definite benefits to human proof as a part of static analysis
02:41:30 <rostayob> donri: well that's saying the obvious. but I like python as well
02:41:40 <rostayob> more than most languages
02:41:47 <edwardk> rostayob: we all have our little perversions =P
02:41:52 <donri> i did link you a blog that brings up many points
02:42:08 <NihilistDandy> I'm sure there's one of those PHPerverts in here, right now~
02:42:16 <DijkstraGroupie> NihilistDandy: I would like to implement an exception-less, static, strongly-typed programming language.
02:42:17 <rostayob> donri: yeah, I'm reading the "why python sucks" one, but those are mainly stdlibs complaints, more than about language design
02:42:23 <quicksilver> donri: "for a useless waste of space, python is definitely one of the better ones" ;)
02:42:39 <rostayob> and as you said, the pocoo people are not exactly the greatest python detractors anyways :)
02:42:55 <donri> rostayob: that one is also somewhat old an uninteresting
02:43:02 <rostayob> edwardk: yeah eheh. btw, I agree with you like most people here on dynamic languages
02:43:12 <donri> rostayob: http://lucumr.pocoo.org/2011/9/21/python-import-blackbox/
02:43:20 <rostayob> donri: I'll read the others when I have time, that one has an eloquent name
02:43:22 <edwardk> anyways my major python complaints tend to center around guido-isms, global lock stuff, etc. a lot of the things that drove me away from the language were those things
02:43:23 <DijkstraGroupie> NihilistDandy: For this to work, the compiler must be able to detect whether the possibility that exceptions be raised at runtime exists, and raise a *compile* error.
02:43:43 <donri> also the python3 situation is somewhat messed up
02:44:20 <matthiasgorgens> NihilistDandy: Management tools for the XenClient hypervizor.
02:44:23 <NihilistDandy> I'm not sure if that's possible with a language that can do IO (what with all those damnable nondeterministic *users*). I'm in favor of the idea, though.
02:44:26 <NihilistDandy> Harumph
02:44:45 <NihilistDandy> matthiasgorgens: Neato. What's it pay? :D
02:45:00 <NihilistDandy> I'm sure I'm too busy for it now, but I might be looking for an internship sometime :)
02:45:32 <rostayob> edwardk: yeah guido is polarising. and yeah python is not good for a lot of stuff, but it's a great scripting language. I think they got rid of some big ass global lock in PyPy
02:45:53 <quicksilver> guido van rossum taking ignorant pot shots at things he doesn't understand is amusing. or annoying. depending what kind of mood you're in.
02:45:55 <DijkstraGroupie> NihilistDandy: Actually, what I am proposing is not feasible. So I propose the following modification to my program: Instead of having the compiler prove that a risky operation (e.g. accesing an array's element given its index) will not raise an exception, it should be the programmer's task to supply the proof.
02:45:56 <donri> pypy still has a gil, last i checked
02:46:08 <edwardk> donri: sad
02:46:11 <rostayob> edwardk: http://morepypy.blogspot.com/2011/06/global-interpreter-lock-or-how-to-kill.html
02:46:25 * hackagebot keys 2.1.2 - Keyed functors and containers  http://hackage.haskell.org/package/keys-2.1.2 (EdwardKmett)
02:46:41 <rostayob> yeah, not yet but they're studying the problem
02:46:49 <edwardk> anyways, python's internals have mostly served as a lesson for me in how to build a nice toy language that really doesn't grok parallelism ;)
02:46:58 <rostayob> Jython doesn't have it apparently
02:47:17 <edwardk> jython: has lots of java synchronization primitives it can lean on
02:47:36 <NihilistDandy> DijkstraGroupie: Hmm. Interesting. What sort of proof would be required? "This function will never ask for any index above x-1, and this array is guaranteed to be of size x?"
02:47:50 <edwardk> i did used to love stackless python though
02:48:13 <edwardk> i wrote 'pocket pool' on the palm pilot using it for almost everything
02:48:19 <DijkstraGroupie> NihilistDandy: Yep.
02:48:28 <matthiasgorgens> NihilistDandy: It pays GBP.  It's in Cambridge, UK.
02:48:31 <DijkstraGroupie> NihilistDandy: So the compiler would be both a compiler and a proof assistant.
02:48:38 <edwardk> which was a hell of a way to work around the ridiculously tiny stack that thing had
02:48:57 <edwardk> and thus my slow slide into functional programming began
02:48:57 <rostayob> edwardk: I really wouldn't have imagined you were a Palm gamedev!
02:48:59 <chu> So you'd like write some Hoare logic preprocessing around the code?
02:49:18 <edwardk> i get bored and try random things =)
02:49:19 <NihilistDandy> matthiasgorgens: I'm not averse to a bit of English summer rain :)
02:49:34 <NihilistDandy> DijkstraGroupie: Sounds very Agda-y :D
02:49:43 <matthiasgorgens> NihilistDandy: Actually, Cambridge is one of the dryest places in the UK.
02:49:49 <edwardk> i also used to wear a suit and fly around the country buying ISPs and firing everyone, ran a phone company, and had a video store
02:49:51 <matthiasgorgens> NihilistDandy: Which doesn't equate to sunniest, mind you.
02:50:14 <NihilistDandy> Good, because I burn like kindling
02:50:32 <DijkstraGroupie> NihilistDandy: What is Agda?
02:50:32 <matthiasgorgens> We also have internships.
02:50:35 <NihilistDandy> edwardk: You're like Knuth but more fun :D
02:50:49 <matthiasgorgens> DijkstraGroupie: A dependently typed programming language or so.
02:50:53 <NihilistDandy> DijkstraGroupie: http://wiki.portal.chalmers.se/agda/pmwiki.php
02:50:58 <matthiasgorgens> DijkstraGroupie: If you think Haskell is too mainstream, try Agda.
02:51:16 <DijkstraGroupie> lol @ "too mainstream"
02:51:21 <NihilistDandy> It's important to get into Agda before it's cool, so we can move on when everyone gets into it
02:51:25 * hackagebot reducers 0.1.8 - Semigroups, specialized containers and a general map/reduce framework  http://hackage.haskell.org/package/reducers-0.1.8 (EdwardKmett)
02:51:33 <DijkstraGroupie> I do not care about "mainstream-ness". In fact, I wish there were a C extension with these features.
02:51:52 <NihilistDandy> matthiasgorgens: I like the sound of it. What are your feelings on American universities? :D
02:52:07 <edwardk> slowly grinding my way through getting everything updated to work with ghc 7.4.1
02:52:21 <rostayob> edwardk: "The adventurous life of edwardk"
02:53:45 <MarconM> Some brazilian here | br ?
02:54:08 <edwardk> it has some interesting scenes in it as movies go, getting thrown out a second story window, losing millions of dollars in the bubble, all sorts of highs and lows
02:55:28 <rostayob> edwardk: age?
02:55:34 <edwardk> 36
02:55:41 <rostayob> oh ok. you didn't lose time ehe
02:55:50 <tigger> is it possible to run threadscope while the program is running. Or is it only possible to look at logs after the program has completed? thanks!
02:56:10 <edwardk> giving up sleep helps =P
02:56:23 <edwardk> though sadly i'm finding i'm actually sleeping again =/
02:56:42 <rostayob> I've been sleeping 10 hrs a day lately. I don't know what's happening to me. Anyway this is -blah material
02:56:50 <chu> It eventually catches up with you!
02:57:17 <damo22> i havent slept for 2-3 days
02:57:32 <Eduard_Munteanu> DijkstraGroupie: that sounds hella difficult to do for C. You might have better luck with some specially-designed dialect of it.
02:57:56 <mekeor> damo22: O_O? crazy
02:57:58 <RC1140> hi all , im kinda new to haskell , I want to use the following lib (https://github.com/bos/riak-haskell-client) but im not sure where to start , does anyone have some basic examples to could follow
02:58:07 <edwardk> chu: true enough
02:58:39 <Eduard_Munteanu> DijkstraGroupie: or you'll end up doing what seL4 guys did, 5k lines of code, 50k lines of proofs :)
02:58:48 <matthiasgorgens> NihilistDandy: I don't have any feelings on American Universities.  I don't know them.
02:58:56 <damo22> ive tried every root exploit on the planet and now ive resorted to writing my own dictionary
02:59:05 <DijkstraGroupie> Eduard_Munteanu: I have absolutely no problem with proving facts about my programs.
02:59:07 <matthiasgorgens> NihilistDandy: Or what was your question aimed at?
02:59:47 <DijkstraGroupie> Eduard_Munteanu: In fact, that is good. That way, my desire to do less work will lead me to write intellectually manageable programs only.
02:59:48 <tigger> RC1140: not sure if you've already tried hackage: http://hackage.haskell.org/package/riak-0.6.0.0
03:00:11 <NihilistDandy> matthiasgorgens: Some people have restrictions on who they'll take based on where you're from. I just like to check. :D
03:00:13 <tigger> RC1140: version 0.6.0.1, doesn't seem to be linked to teh docs
03:00:29 <matthiasgorgens> NihilistDandy: We don't care.  We have interviews and stuff for that.
03:00:29 <RC1140> tigger: i saw that package but again , doesnt seem to have any basic docs
03:00:39 <NihilistDandy> The idea of Haskell hacking for production is an exciting thought, though
03:00:44 <matthiasgorgens> NihilistDandy: So I don't know about the immigration visa.
03:01:25 * hackagebot categories 0.59 - categories from category-extras  http://hackage.haskell.org/package/categories-0.59 (EdwardKmett)
03:01:25 <matthiasgorgens> NihilistDandy: Those pesky Brits recently made it harder to hire non-EU people.  If you are going to get a PhD, that should still be possible.
03:01:45 <matthiasgorgens> NihilistDandy: A bunch of people also work from home.
03:02:05 <matthiasgorgens> A co-worker and friend recently left the Cambridge office to work from home.  Home is Poland.
03:02:09 <NihilistDandy> Ah, unfortunately I'm only undergrad for now. I do plan to pursue graduate degree and PhD, though
03:02:17 <NihilistDandy> That's awesome
03:02:27 <NihilistDandy> *a graduate degree
03:02:29 <matthiasgorgens> He's our most knowledgable Haskeller, I'd say.
03:02:42 <NothingMan65> Sorry, big n00b here.   Wonder why I can't print "newArray (0, n) 0 :: IO (IOArray Int Int) "
03:03:03 <matthiasgorgens> I also know a fair bit in comparison.  But in addition he's way more familiar with the code base.
03:03:14 <matthiasgorgens> NothingMan65: What error message do you get?
03:03:22 <mekeor> :t newArray
03:03:23 <lambdabot> Not in scope: `newArray'
03:03:31 <edwardk> NothingMan65: there are two problems. a. an IO action isn't an array, its a computation that will yield an array
03:03:38 <mekeor> @hoogle newArray
03:03:38 <lambdabot> Foreign.Marshal.Array newArray :: Storable a => [a] -> IO (Ptr a)
03:03:38 <lambdabot> Foreign.Marshal.Array newArray0 :: Storable a => a -> [a] -> IO (Ptr a)
03:03:39 <lambdabot> Data.Array.MArray newArray :: (MArray a e m, Ix i) => (i, i) -> e -> m (a i e)
03:03:59 <matthiasgorgens> edwardk: ... and I wanted him to find the explanation himself. ;o)
03:03:59 <edwardk> second an IOArray itself can tell you how to get the contents out of it, an element at a time, but each one of those is a side-effect
03:04:22 <edwardk> matthiasgorgens: i'm merely pointing out that there is a problem
03:04:28 <NothingMan65> Okay, so roll my own print method edwardk ?
03:04:32 <edwardk> you're free to socratic him to death from there ;)
03:04:46 <matthiasgorgens> edwardk: Yes, and that's probably much less frustrating than my prodding in the right direction would have been.
03:04:51 <edwardk> NothingMan65: or convert it to something that you can print
03:05:04 <edwardk> but ultimately you will be doing so inside the IO monad
03:05:09 <NothingMan65> Would freeze convert it to an immutable array which I can print?
03:05:10 <matthiasgorgens> NothingMan65: Instead of rolling your own print, you can roll your own Show instance.
03:05:15 <NothingMan65> Okay
03:05:20 <edwardk> so there is going to be a fair bit of understanding needed
03:05:28 <edwardk> that'll help quite a bit
03:05:35 <matthiasgorgens> NothingMan65: or, hmm, that would need unsafePerformIO trickery.  Don't go there.
03:05:42 <NothingMan65> Okay.
03:05:48 <edwardk> matthiasgorgens: now who is going off on a tangent? =)
03:05:59 <Eduard_Munteanu> DijkstraGroupie: that's an understatement really, and it's probably worth it only for core functionality that doesn't change at all.
03:06:07 <matthiasgorgens> NothingMan65: do what edwardk says and ignore what I say. Including this message.
03:06:09 <NothingMan65> Well, tangents aside, what's the mostly profitable secant in terms of learning?
03:06:27 * hackagebot either 0.2.3.1 - Haskell 98 either monad transformer  http://hackage.haskell.org/package/either-0.2.3.1 (EdwardKmett)
03:06:29 * hackagebot vector-instances 2.0.4.1 - Orphan Instances for 'Data.Vector'  http://hackage.haskell.org/package/vector-instances-2.0.4.1 (EdwardKmett)
03:06:31 <edwardk> NothingMan65: how well do you understand the io monad?
03:06:38 <NothingMan65> Poorly.
03:07:12 <edwardk> ok, first question, why a mutable array?
03:07:22 <matthiasgorgens> apropos monads, I found that I only really understood monads when learning about monad transformers.  Sometimes you have to go to the more advanced topics to see how why the foundations are laid out in the way they are.
03:07:52 <edwardk> > listArray (0,10) [0..10]
03:07:52 <NothingMan65> Big array, iterative operations, dependent elements unknown at creation time.
03:07:53 <lambdabot>   array (0,10) [(0,0),(1,1),(2,2),(3,3),(4,4),(5,5),(6,6),(7,7),(8,8),(9,9),(...
03:08:00 <edwardk> okay
03:08:06 <edwardk> so you do have a reason at least =)
03:08:10 <NothingMan65> (=
03:08:23 <kowey> anybody else get "Warning: could not create symlink in /Users/foo/Library/Haskell/bin" cabal-install messages?
03:08:32 <kowey> it makes it hard to upgrade software for users :-/
03:08:38 <heffaklump> im trying to use REPA, but cant figure out how to just cretae a matrix, say 4*5
03:08:44 <edwardk> often the smartest thing to do is to still try to phrase those dependencies all in one go and use laziness to solve your problem for you
03:08:44 <heffaklump> i can only do sinlgeton
03:09:00 <NothingMan65> So, maybe I should roll my own Show instance, that should give me a good dose of learning?
03:09:07 <edwardk> but if you're forced to use an IOArray you're going to need to do a lot of manual and ugly imperative plumbing
03:09:12 <edwardk> you can't write a Show instance
03:09:19 <edwardk> it isn't possible to do anything useful in it
03:09:32 <edwardk> :t show
03:09:33 <lambdabot> forall a. (Show a) => a -> String
03:09:42 <matthiasgorgens> (That's why I said ignore me. :o)
03:09:47 <NothingMan65> Oh.
03:09:49 <NothingMan65> Okay.
03:09:49 <edwardk> you really can't sanely get _out_ of IO to return a String
03:09:57 <NothingMan65> Okay.
03:09:57 <NihilistDandy> kowey: What if you add a sudo?
03:10:22 <edwardk> you can write a showMyIOArray :: …. -> IO String
03:10:33 <edwardk> which will give you an IO action to perform that when run will calculate a string
03:10:42 <edwardk> but it ultimately needs to be an IO action
03:10:47 <NothingMan65> Okay.
03:11:06 <NothingMan65> That at least gives me a few stepping stones.  But it feels like I'm crossing the Mississippi
03:11:12 <edwardk> you are
03:11:14 <NothingMan65> (=
03:11:21 <edwardk> have you picked up a copy of real world haskell?
03:11:23 <matthiasgorgens> You'll be smarter afterwards. ;o)
03:11:39 <NothingMan65> No I haven't edwardk.
03:11:50 <NothingMan65> This isn't really for real world at this point.
03:11:51 <edwardk> done much programming outside of haskell?
03:11:55 <NothingMan65> Yeah.
03:11:59 <edwardk> then start there ;)
03:12:00 <kowey> NihilistDandy: huh, I could maybe get my user to do that... but good idea to check for permissions
03:12:08 <NothingMan65> Okay.
03:12:09 <edwardk> its available online to get you started
03:12:09 <kowey> it's complaining about files not managed by cabal
03:12:14 <kowey> which seems suspicious
03:12:38 <NothingMan65> Alright, I'll go read some more, thanks for keywords and context to get me going though.
03:12:39 <edwardk> http://book.realworldhaskell.org/
03:12:41 <NothingMan65> Appreciated.
03:13:00 <edwardk> you can read chapters there, its an o'reilly book. at least 2 of the authors wander in here from time to time
03:13:24 <heffaklump> im trying to use REPA, but cant figure out how to just cretae a matrix, say 4*5
03:13:29 <quicksilver> all three used to be a common sight
03:13:33 <edwardk> another good starting point (i usually recommend people go through them in parallel) is http://learnyouahaskell.com/
03:13:37 <quicksilver> but apparently they got some disease called "Real Jobs"
03:13:42 <edwardk> its a lot more fun, but doesn't go very deep
03:13:54 <edwardk> on the other hand, its much more methodical in its approach
03:14:11 <edwardk> RWH kinda jumbles the order a bit, so using LYAH can smooth out the learning curve
03:14:52 <NothingMan65> I think I need to read up on some deep stuff, I'll give RWH a try before heading back to LYAH again.
03:15:23 <chu> There's the wikibooks/haskell also, covers some of the more theoretical stuff.
03:15:29 <edwardk> i'm not blowing you off, just going to update a couple more modules and go back to bed ;)
03:15:34 <rostayob> NothingMan65: I'd suggest reading LYAH first, but you could try RWH first. LYAH is much more organic
03:15:58 <rostayob> NothingMan65: RWH is more like a cookbook
03:16:07 <NothingMan65> I've been through a good bit of LYAH, weaving with actual practice sessions.  Time to get cooking!
03:16:18 <mekeor> hehe
03:16:20 <NothingMan65> I'll be back!
03:16:20 <vikramverma> No love for Hutton?
03:16:25 <edwardk> the main problem is that LYAH is pretty weak when it comes to using monads
03:16:38 <NothingMan65> Me too
03:16:40 <rostayob> vikramverma: if he's an experienced programmer Hutton will be kinda boring imho...
03:16:42 <edwardk> hutton's material isn't bad, its just dated
03:16:56 <NothingMan65> "We'll define a few monads in this chapter, to show how easy it is."
03:16:56 <NihilistDandy> I like the new version of Craft of Functional Programming
03:17:01 <NihilistDandy> Lots of QuickCheck goodness
03:17:41 <vikramverma> edwardk: That's fair. And I'd say a lot of that is due to the publishing format.
03:17:50 <vikramverma> NihilistDandy: I'll check that out.
03:18:17 <rostayob> edwardk: I'd say that the code in that book is pretty usable, since it doesn't use external libraries and not much of the base libraries either
03:18:38 <heffaklump> WHAT IS SH IN REPA?
03:18:49 <rostayob> heffaklump: the shape of the array
03:18:56 <rostayob> e.g. 4*5
03:19:09 <rostayob> or 1*2*3, or whatever
03:19:35 <chu> The same guy who writes "The Craft ..." book (Simon Thompson) also has a free copy of "Type Theory and Functional Programming" on his web site.
03:20:20 <NihilistDandy> A classic :D
03:20:29 <DijkstraGroupie> chu: What's the URL?
03:20:34 <NihilistDandy> http://www.cs.kent.ac.uk/people/staff/sjt/TTFP/ttfp.pdf
03:20:47 <DijkstraGroupie> NihilistDandy: Thanks!
03:20:58 <NihilistDandy> Errata here: http://www.cs.kent.ac.uk/people/staff/sjt/TTFP/errata.html
03:22:25 <chu> And then you look for the Benjamin Pierce book!
03:22:32 <vikramverma> NihilistDandy: This looks amazing. /cc PatrickRobotham Ralith
03:23:22 <PatrickRobotham> vikramverma: Yeah i've got it.
03:23:27 <rostayob> chu: those book will not help you that much for practical haskell programming in the end
03:23:40 <rostayob> but TAPL is a nice read anyways
03:23:50 <NihilistDandy> chu: I might just have to get those. Fairly cheap on Amazon.
03:24:17 <rostayob> NihilistDandy: TaPL is not cheap last time I checked. I've got a copy to sell if you want
03:24:20 <chu> Yeah, I'm one of the few people here who isn't a programmer, just interested in the logic of the type system (I'm not a programmer at all), but yeah, I have some ideas...
03:24:47 <Philippa> TAPL and a quick summary of qualified types will get you a long way towards understanding the type system - in particular, everything you need for "what does it mean?" as opposed to "how does the compiler figure it out?"
03:24:51 <NihilistDandy> rostayob: $50 isn't too bad, all things considered
03:25:04 <Philippa> oh, that and knowing that polymorphic recursion doesn't give decidable, complete type inference
03:25:10 <edwardk> yeah
03:25:16 <edwardk> TaPL is why pugs exists ;)
03:25:37 <rostayob> NihilistDandy: I still think they're expensive... anyway seriously I'm in london and I've got two of them by mistake... so if you want one of them half price :)
03:25:52 <NihilistDandy> I'd certainly be in favor, rostayob :)
03:26:03 <Philippa> TaPL's especially good if you don't have a solid background in formal logic
03:26:11 <NihilistDandy> Though I suppose it depends what the shipping from UK to US would be :D
03:26:17 <Philippa> I was confusing the hell out of my philosophy student ex who'd been doing extra modules in it, even
03:26:25 * hackagebot wl-pprint-extras 1.6.1 - A free monad based on the Wadler/Leijen pretty printer  http://hackage.haskell.org/package/wl-pprint-extras-1.6.1 (EdwardKmett)
03:26:27 * hackagebot wl-pprint-terminfo 0.8.2 - A color pretty printer with terminfo support  http://hackage.haskell.org/package/wl-pprint-terminfo-0.8.2 (EdwardKmett)
03:26:40 <Philippa> (but then, I don't think philosophers are taught how to engineer or sugar or 'see through' stuff so much)
03:26:53 <chu> That's where I'm coming from, a philosophy of logic student.
03:26:59 <rostayob> Philippa, edwardk: those are really interesting things but I'm really not sure how much of a better programmer that kind of book makes you
03:27:48 <Philippa> 'k - have you dealt much with sub-turing logics where the usual philosophy student "all logic has contradictions" lie-to-children doesn't apply?
03:28:15 <edwardk> i dunno. i find being able to point to a problem and say thats clearly undecidable because i can reduce the halting problem to it, rather than beating my head on it for 2 years is useful
03:28:18 <Philippa> rostayob: directly? Not much. It depends what you do with it. The knowledge is pretty important though
03:28:24 <Philippa> yes, quite!
03:28:27 <edwardk> speaking from the standpoint of the guy who spent far longer than 2 years doing just that
03:28:40 <Philippa> ow. Was a heuristic solution acceptable? :p
03:28:45 <edwardk> so i will say that i'm a better programmer for having read TaPL =P
03:29:02 <rostayob> edwardk: mhm you shouldn't need TaPL to know about the halting problem...
03:29:12 <Philippa> chu: if not, then TaPL may well still be useful though you'll be able to skim the first few chapters aside from the structure of the proofs
03:29:38 <edwardk> i know the halting problem. however the reducability of type inference for system f-like languages to the halting problem wasn't something that was apparent to me prior to reading
03:29:45 <Philippa> there's a lot of PL-oriented stuff in there that is less relevant to most philosophy students (at least, per philosophical orthodoxy)
03:30:15 <rostayob> edwardk: yeah but you don't need that to reason about termination in programs, imho. mind you I really liked that book
03:30:17 <chu> I spent some time in the CS department with a guy who was working on some Haskell stuff (DDC actually) and he recommended TAPL :)
03:30:19 <edwardk> and i spent a lot of time playing with toy language designs that were ultimately much better informed after i had a more formal grounding
03:30:25 <Philippa> (the suspiciously phoenix-like fragment of the Hilbert program is very much relevant IMO!)
03:30:35 <rostayob> edwardk: if you have to design a language, that's another story :)
03:30:41 <heffaklump> WHAT IS SH IN REPA?
03:30:45 <Philippa> chu: heh, yeah I can see him doing so
03:30:58 <rostayob> heffaklump: I told you already. you've got caps lock on.
03:31:02 <MaskRay_> is TaPL abbreviated from Types and Programming Languages?
03:31:03 <Philippa> don't suppose you're likely to show to Fun in the Afternoon later this month?
03:31:06 <Philippa> MaskRay_: yeah
03:31:20 <chu> Philippa: me?
03:31:20 <Philippa> shapr and I were calling it the brick book for a while, but that didn't stick
03:31:23 <Philippa> chu: yeah
03:31:30 <rostayob> red brick book
03:31:32 <rostayob> not bad
03:31:34 <chu> Don't know what "Fun in the Afternoon" us
03:31:37 <chu> is*
03:32:01 <Philippa> http://sneezy.cs.nott.ac.uk/fun/ when it's up again
03:32:05 <chu> Something in New Zealand, but the link's dead
03:32:06 <chu> Ahha
03:32:12 <chu> If only I could properly type :p
03:32:19 <Philippa> (or maybe my system's being crappy rather than theirs)
03:32:41 <Philippa> this time round's in Oxford on the 28th
03:32:44 <edwardk> rostayob: thats pretty much what i do these days =P
03:32:55 <chu> I don't know why I said "New Zealand" must have seen .nz somewhere...
03:33:14 <Philippa> I've heard rumblings about edwinb giving a talk: if so, it's likely to be a fun practical application of formal logic
03:33:14 <chu> But probably not, I am in Australia :p
03:33:31 <matthiasgorgens> Philippa: I actually might become a speaker there.
03:33:31 <Philippa> ah, fair enough, I'd misread your location :-)
03:33:39 <Philippa> matthiasgorgens: cool, what about?
03:33:48 <Philippa> (I had a go an event or two back, though it didn't go well)
03:33:50 <jeltsch> NihilistDandy: Hi, now I’m stuck with installing darcs. Do you have an idea of how to install darcs under GHC 7.4?
03:33:52 <matthiasgorgens> Philippa: Using Haskell in the real world. ;o)
03:34:12 <edwardk> matthiasgorgens: where's that?
03:34:19 <matthiasgorgens> Philippa: We are using Haskell in production.  Since that's so novel I'm probably excused from being as brainy as the other speakers.
03:34:22 <NihilistDandy> jeltsch: If you grab the darcs head repo, it should work right out of the box. Link incoming
03:34:23 <Philippa> heh
03:34:26 <matthiasgorgens> edwardk: XenClient at Citrix.
03:34:31 <damo22> Botje: i have created some functions as you suggested but im not sure how to walk across a string by 2s
03:34:33 <Philippa> It'll be good to hear, if so
03:34:35 <edwardk> no, i mean the real world ;)
03:34:44 <jeltsch> NihilistDandy: cabal-install wants to reinstall certain packages, and I don’t know why it doesn’t just use the already installed packages.
03:34:53 <NihilistDandy> jeltsch: darcs get --lazy http://darcs.net/screened
03:35:08 <Philippa> I got a rather meh response talking about a pragmatic parsing library I was working on, but I also did a bad job of presenting on the day - I tend to find I'm more tired than I allowed for when I show up :-(
03:35:10 <jeltsch> NihilistDandy: What does “screened“ mean here?
03:35:14 <NihilistDandy> jeltsch: darcs on hackage hasn't been updated for 7.4, yet
03:35:19 <Philippa> (Oxford should be better, will be crashing with a friend there the night before)
03:35:22 <NihilistDandy> jeltsch: screened is just the unstable branch
03:35:27 <NihilistDandy> bleeding-edge
03:35:33 <matthiasgorgens> edwardk: Real World: https://en.wikipedia.org/wiki/Reality_Checkpoint
03:35:40 <jeltsch> NihilistDandy: How stable is the unstable branch? I don’t want to risk repo corruption.
03:36:03 <NihilistDandy> It's just fine, so far
03:36:07 <NihilistDandy> I haven't seen any issues
03:36:12 <edwardk> i don't know how we'll get across the reality checkpoint. you may need to smuggle me in the trunk
03:36:43 <edwinb> Philippa: it'll most likely be about embedding DLSs in Idris
03:36:50 <edwinb> er. DSLs
03:37:05 <jeltsch> NihilistDandy: Hmm, I’m using more and more unstable software because of GHC 7.4.
03:37:17 <Philippa> edwinb: yeah, I guessed that was likely :-) Looking forward to seeing it
03:37:19 <NihilistDandy> jeltsch: I'll see if I can find a more stable one. Hang on
03:37:39 <Philippa> I may have been abusing curry-howard mildly...
03:37:40 <NihilistDandy> jeltsch: darcs get --lazy http://darcs.net/
03:37:43 <heffaklump> so how do I get the matrix value at (0,0) in REPA
03:37:54 <NihilistDandy> That's what I used.
03:37:59 <jeltsch> NihilistDandy: What repository is that?
03:38:09 <heffaklump> let a = R.Rect (4,5) in a ! (0,0) ?
03:38:22 <jeltsch> Hmm: “Couldn't handle interrupt since darcs was in a sensitive job.”
03:38:29 <jeltsch> Now I have to wait …
03:38:40 <NihilistDandy> jeltsch: darcs --version says 2.9.1, so I guess unstable
03:39:23 <jeltsch> NihilistDandy: But is it more or less unstable than the other repo?
03:39:25 <NihilistDandy> Anyone know when the next Boston Haskell is?
03:39:38 <edwardk> NihilistDandy: when i get a couple of people who want to give talks
03:40:00 <NihilistDandy> jeltsch: I figure unstable is unstable. If you want a stable darcs just keep using the binary, I guess
03:40:12 <jeltsch> NihilistDandy: Binary for Fedora 16?
03:40:21 <jeltsch> I fear there isn’t one.
03:40:29 <jeltsch> Well, maybe there is one in Fedora itself.
03:40:39 <NihilistDandy> jeltsch: yum install darcs
03:40:40 <jeltsch> But I like to use a source version that I’ve patched before.
03:41:00 <jeltsch> darcs has a bug wrt. output of Unicode on the terminal.
03:41:07 <NihilistDandy> Hmm
03:41:12 <jeltsch> It sets stdout to binary mode or so.
03:41:21 <NihilistDandy> edwardk: That sounds like a challenge :D
03:41:25 * hackagebot http-conduit 1.2.4 - HTTP client package with conduit interface and HTTPS support.  http://hackage.haskell.org/package/http-conduit-1.2.4 (MichaelSnoyman)
03:41:32 <edwardk> volunteering? =)
03:42:01 <jeltsch> NihilistDandy: This seems to be necessary on Windows for some reason, but gives ugly output on Linux when using non-ASCII characters in patch names (which I like to do).
03:42:08 <NihilistDandy> If I can find the time to put together something interesting, sure. What's the shiny thing du jour in the Haskell world? :D
03:42:26 <Philippa> dirt
03:42:46 <jeltsch> NihilistDandy: My question on #darcs and the answer:
03:42:50 <Philippa> I'm having a lot of fun writing about things that firmly aren't shiny, myself. Admittedly I'm looking to build (or show how to build) something /really/ shiny in the long run
03:42:51 <jeltsch> jeltsch: Hi, what is the difference between the repos http://darcs.net/screened and http://darcs.net?
03:42:53 <jeltsch> Heffalump: nothing
03:42:55 <jeltsch> Heffalump: we've changed what http://darcs.net points to over time
03:42:57 <jeltsch> Heffalump: but right now, and for the forseeable future, it points to screened
03:43:04 <NihilistDandy> That sounds right
03:43:07 <edwardk> not sure. i might give a short talk on my revision control monad to fill the other half of the time
03:43:36 <Philippa> NihilistDandy: if you feel like bashing through some examples etc, there's a lot to be done on pushing the gains ConstraintKinds give us through the Functor family of classes
03:43:57 <Philippa> edwardk: that'd be good, yeah. I mean, I'd have to make do with slides, but hey
03:44:14 <edwardk> Philippa: i just worked through how to do constrained polykinded categories
03:44:22 <NihilistDandy> Philippa: That sounds like good fun. Any good papers on the subject to get a feel for it?
03:44:33 <edwardk> sadly without further support from the compiler it peters out after product and sum categories
03:45:20 <hpaste> edwardk pasted “categories” at http://hpaste.org/57574
03:45:33 <edwardk> NihilistDandy: ^
03:45:50 <NihilistDandy> woof
03:46:01 <edwardk> and brent yorgey's paper on giving haskell a promotion, max bolingbroke's stuff on constraint kinds
03:46:08 <edwardk> and my two articles on what constraints entail'
03:46:21 <edwardk> all put together should give you some overview of whats now possible
03:46:24 <NihilistDandy> Well, I know what I'll be reading this week :)
03:46:38 <edwardk> oh and the contents of my constraints package
03:46:44 <edwardk> which i guess i should update to 6.4.1
03:46:46 <edwardk> er 7.4.1
03:46:55 <NihilistDandy> I've got Brent's paper sitting in my reading list, and it's been begging to be read
03:46:58 <heffaklump> let a = R.Rect (4,5) in a ! (0,0) ?
03:47:04 <heffaklump> how to index the matrix in repa?
03:47:17 <matthiasgorgens> Just confirmed.  I'll be speaking at the "Fun in the Afternoon."
03:47:36 <edwardk> oh sweet constraints 0.2 does build on 7.4.1
03:47:38 <edwardk> no changes needed
03:47:56 <Philippa> there was a nice examples draft paper by... was it Dominic Orchard?
03:47:59 <Philippa> But yeah, all that stuff
03:48:15 <Philippa> (my last use was building a monad that's allowed to perform substitutions on return values)
03:49:10 <edwardk> that hpaste showcases a technique i've been using a lot to turn values of kind x -> * into kind x -> Constraint, which is just making a dictionary with the appropriate element in it
03:49:20 <Philippa> matthiasgorgens: cool, I'll look forward to it
03:49:40 <NihilistDandy> edwardk: Everytime I build something without issue on 7.4.1, I get a little excited. Equally, though, the new, nicer error messages are quite instructive, as well :D
03:49:52 <matthiasgorgens> Philippa: Yeah, at least one listener. ;o)
03:49:53 <NihilistDandy> -redundant "as well"
03:49:54 <Philippa> what's changed with the error messages, OOI?
03:50:28 <NihilistDandy> Philippa: Just useful errors for the separation of Num and Eq, mostly
03:50:31 <Philippa> (I'm mostly sticking to the Platform these days)
03:50:32 <Philippa> ah
03:50:34 <NihilistDandy> Simple fixes, not too much searching around
03:51:25 <NihilistDandy> I have a small dream of submitting a patch everytime I get a warning in cabal, but my dreams are larger than my available time
03:52:09 <edwardk> NihilistDandy: heh
03:52:28 <edwardk> the problem is i have some warnings i'm not yet willing to patch, like a ton of mkTyCon -> mkTyCon3's
03:52:33 <NihilistDandy> Mostly just all those MkTyCon that pop up
03:52:39 <NihilistDandy> Haha
03:52:48 <edwardk> i need to go through and formulate a nice breakdown of the exact version it switched
03:52:50 <NihilistDandy> *mkTyCon
03:53:03 <NihilistDandy> mmhmm
03:53:06 <edwardk> and then make a general pattern i can use across all my packages
03:53:16 <edwardk> because i write a LOT of manual typeable instances
03:53:27 <edwardk> because you can't derive typeable for anything with a higher kinded argument
03:53:32 <edwardk> BUT since we have polymorphic kinds
03:53:40 <edwardk> hopefully Typeable will just go polykinded
03:53:51 <edwardk> and i can whack all those instances
03:54:11 <edwardk> so i'm holding off
03:54:15 * Philippa wonders what a scottish theorem looks like
03:54:28 <Philippa> (obv most of us here are using a scottish language!)
03:54:57 <NihilistDandy> I'm kind of thrilled with how fast GHC development has been progressing since the 7 mark. It speaks to increasing interest without sacrificing the good parts :D
03:58:22 <heffaklump> Does import Data.Array.Repa include all submodlules like Repa.Shape etc?
03:58:24 <NihilistDandy> That's better
03:59:04 <byorgey> heffaklump: look at the documentation and see: http://hackage.haskell.org/packages/archive/repa/2.2.0.1/doc/html/Data-Array-Repa.html
04:00:10 <byorgey> heffaklump: importing Foo.Bar  does not automatically include  Foo.Bar.Baz, but Foo.Bar can explicitly re-export Foo.Bar.Baz
04:00:27 <heffaklump> eh?
04:00:39 <heffaklump> REPA=most complicated matrix package ever
04:01:37 <rostayob> heffaklump: how long have you been using haskell for?
04:01:51 <rostayob> REPA might be confusing if you're new to Haskell
04:02:05 <mux> to be fair, a lot of things are confusing if you're new to Haskell :-P
04:02:27 <dmarkey> Anyone want ahaskell  job in the UK?
04:02:29 <NihilistDandy> Wait, what's Haskell?
04:02:40 <Eduard_Munteanu> Where am I?
04:02:49 <rostayob> Eduard_Munteanu: potato
04:02:52 <damo22> what day is it?
04:02:54 <heffaklump> whats the emacs paste command?
04:03:07 <johnthejohn> I'm trying to have multiple conditions in a list comprehension and it seems to work but only if both are true and I only require one of them to be true. How would I do this?
04:03:12 <chu> C-y pastes
04:03:15 <rostayob> heffaklump: ... C-y. this is #haskell, btw
04:03:21 <NihilistDandy> C-y for yank!
04:03:25 <chu> Or M-x yank
04:03:46 <chu> NihilistDandy won.
04:04:22 <heffaklump>  let m = fromList (Z :. (3::Int), Z :. (2::Int)) [[1,2],[3,4],[5,6]]
04:04:22 <byorgey> johnthejohn: instead of   condition1, condition2  use  condition1 || condition2
04:04:37 <NihilistDandy> On an unrelated emacs note, whoever set up the default Agda highlighting needs to have their eyes checked~
04:04:48 <rostayob> NihilistDandy: it's just fixed
04:04:56 <rostayob> NihilistDandy: I have a Tango agda color scheme if you want
04:05:11 <Eduard_Munteanu> NihilistDandy: are you running emacs light on dark? That might explain it.
04:05:24 <Eduard_Munteanu> I had to lighten up the blues for that reason.
04:05:31 <johnthejohn> byorgey: Thank you. I'm amazed by Haskell already - it's compact yet so beautiful!
04:05:36 <NihilistDandy> Eduard_Munteanu: Yes, yes, I am. Very same solution, too :D
04:06:12 <NihilistDandy> rostayob: Screenshot, by chance?
04:07:09 <Aryan4> you know about natural phenomena
04:07:48 <rostayob> NihilistDandy: I just realized that I'm at work without my laptop. Ask aristid on #agda, he's got the same. it looks pretty good
04:07:59 <Aryan4> you know about natural phenomena
04:10:57 <NihilistDandy> Type synonyms as constraint synonyms… I like
04:11:05 <mekeor> (why) isn't "f x [] = x" the same as "f _ [] = const" ?
04:11:24 <mux> NihilistDandy: yeah, that's something that has been wanted for a long time
04:11:28 <rostayob> :t \x [] -> x
04:11:29 <lambdabot> forall t t1. t -> [t1] -> t
04:11:34 <rostayob> :t \x _ -> const
04:11:35 <lambdabot> forall t t1 a b. t -> t1 -> a -> b -> a
04:11:42 <rostayob> :t \x -> const
04:11:43 <lambdabot> forall t a b. t -> a -> b -> a
04:11:59 <rostayob> :t (\x -> const) :: a -> [b] -> a
04:12:00 <lambdabot>     Couldn't match expected type `a' against inferred type `b -> [b1]'
04:12:00 <lambdabot>       `a' is a rigid type variable bound by
04:12:01 <lambdabot>           an expression type signature at <interactive>:1:17
04:12:13 <NihilistDandy> mux: I'm all for anything that makes code more descriptive and saves keystrokes and refactoring time. :D
04:12:16 <rostayob> mhm?
04:12:22 <quicksilver> mekeor: because "f _ []" is fully applied.
04:12:44 <mekeor> quicksilver: aah... right...
04:13:20 <mekeor> @pl \x [] -> x
04:13:21 <lambdabot> (line 1, column 4):
04:13:21 <lambdabot> unexpected "["
04:13:21 <lambdabot> expecting operator, pattern or "->"
04:13:34 <mekeor> @pl \x y -> x
04:13:34 <lambdabot> const
04:14:02 <heffaklump> if you want to update index (1,2) in [[Integer]] list how do you do?
04:14:07 <rostayob> mekeor: you're looking for 'flip const'
04:14:33 <NihilistDandy> I love Max Bolingbroke's blog. :D
04:14:38 <mekeor> rostayob: rly? i dont think so... >.>
04:14:59 <mekeor> anyway. i'll use point-full notation.. heeh
04:15:47 <rostayob> mekeor: 'f _ x = x' is equivalent to 'flip const'
04:16:09 <rostayob> if you need to pattern match on the empty list, then you can't use const
04:16:28 <mekeor> rostayob: yep, but i was looking for a (pointless) synonym for "f x [] = x"...
04:16:33 <mekeor> yep, it's for pattern matching..
04:16:40 <mekeor> rostayob: okay. :)
04:16:58 <rostayob> mekeor: if you're goal is pattern matching, you can't express that point-free.
04:17:20 <mekeor> oh. hahaha right! lol
04:18:21 <quicksilver> well it depends how far you're prepared to go, I think
04:18:40 <koala_man> so arrows are a generalization of monads. is there a generalization of arrows?
04:18:48 <rostayob> quicksilver: if that is one of the patterns of a function, you can't point-free it
04:18:48 <heffaklump> I need: set :: Int -> Int -> Integer -> [[Integer]] -> [[Integer]]
04:18:53 <rostayob> koala_man: arrows are not a generalization of monads
04:18:56 <heffaklump> doe sit exist? whats the easiest wya to do it?
04:19:15 <MadDogg> rostayob ' hi guys
04:19:54 <NihilistDandy> koala_man: http://lambda-the-ultimate.org/node/4259
04:20:14 <NihilistDandy> @hoogle Int -> Int -> Integer -> [[Integer]] -> [[Integer]]
04:20:14 <lambdabot> Data.List zipWith4 :: (a -> b -> c -> d -> e) -> [a] -> [b] -> [c] -> [d] -> [e]
04:20:15 <lambdabot> Data.List zipWith5 :: (a -> b -> c -> d -> e -> f) -> [a] -> [b] -> [c] -> [d] -> [e] -> [f]
04:20:15 <lambdabot> Control.Monad liftM4 :: Monad m => (a1 -> a2 -> a3 -> a4 -> r) -> m a1 -> m a2 -> m a3 -> m a4 -> m r
04:21:16 <koala_man> rostayob: how so? aren't all monads arrows but not the other way around?
04:21:26 <quicksilver> @pl \x y -> if null y then x else q
04:21:26 <lambdabot> flip flip q . flip (if' . null)
04:21:31 <rostayob> heffaklump: that functiondoesn't exists because lista are not arrays, so it doesn't make much sense to do that
04:21:34 <quicksilver> ^^ you can do things like this if you want
04:21:40 <quicksilver> it's a bit of painful.
04:21:57 <rostayob> koala_man: all monads can be turned into arrows (Kleisli), but Arrows are a generalization of functions
04:22:00 <quicksilver> somethings you can do something (slightly) neater with guard.
04:22:12 <koala_man> ah
04:23:16 <rostayob> koala_man: well, I guess you could say they're a generalization of monads. It's a terminology issue I guess :)
04:23:53 <rostayob> but at the type level they're not
04:24:38 <koala_man> speaking of terminology, what do you call a function Monad m => a -> m b. a monadic function or a function on monads or what?
04:27:02 <quicksilver> koala_man: you hear monadic function quite often.
04:27:14 <quicksilver> or 'action'
04:27:25 <mekeor> :t return . show
04:27:26 <lambdabot> forall (m :: * -> *) a. (Monad m, Show a) => a -> m String
04:29:54 <mekeor> is there a way to define a type-contructor which gets a *value* ?  i mean like "type Foobar thisIsAnInteger = if thisIsAnInteger<0 then String else Double" or so ?
04:30:14 <rostayob> mekeor: no, that would be a dependent type.
04:30:22 <rostayob> mekeor: other languages can do that, btw.
04:30:31 <mekeor> ah. okay, now i see agda's purpose. alright.
04:30:55 <rostayob> mekeor: you can do that kind of stuff PolyKinds, which is a new language extensions in GHC 7.4
04:30:59 <NihilistDandy> Wait… Agda… purpose? MY MIND. MY PURITY.
04:31:13 <Cale> koala_man: I would refrain from calling it a function on monads, because the monad here is m. A function on monads would take one monad and produce another, (like a monad transformer does)
04:32:54 <koala_man> Cale: how would you refer to a monadic function that requires an additive monad?
04:35:57 <Botje> damo22: you want something like go _ [] = [[]]; go order (c:cs) = case lookup c dict of Nothing -> map (c:) (order None cs); Just xs -> [ x:res | x <- xs, isCompatible order (getCase x), rest <- go (getCase x) cs ]
04:36:18 <mux> rostayob: you can already some DT-liek stuff in Haskell using a few tricks
04:36:22 <mux> +do
04:36:26 <Botje> damo22: .. but I don't like your talk about root exploits :/
04:36:35 <rostayob> mux: yeah, but it's hacky.
04:36:53 <rostayob> I leave that to Oleg.
04:37:12 <damo22> :)
04:37:18 <mux> you cannot have types depend on values like in a full-blown DT language, but you can sometimes get nearly that by making so all possible values will have a different type
04:38:15 <rostayob> mux: well, in the case of naturals you can have type level naturals and it's not that ugly... but again it's kind of hacky
04:38:51 <rostayob> for example type-level pseudo strings/lists are already too ugly to handle imho.
04:39:04 <mux> PoliKinds make those less ugly
04:39:07 <mux> PolyKinds*
04:39:13 <rostayob> yeah, much less
04:39:21 <rostayob> (afaik, I just read the paper)
04:39:57 <mux> hm, I meant DataKinds
04:40:06 <mux> PolyKinds doesn't help at all actually, it's something else
04:40:37 <rostayob> well whatever they're called, the extension that lets you lift data declarations at the type level
04:40:40 <rostayob> the apostrophe stuff
04:40:46 <mux> I've been converting code code for length-typed vectors to use named kinds without any problem (except some minor annoyance with respect to what I can type in the GHCi prompt, was having a discussion about that earlier)
04:40:56 <mux> rostayob: yes, DataKinds
04:43:50 <mux> PolyKinds is about kind polymorphism, as the name suggests :-)
04:47:10 <hey_lu> is it possible to build the haskell platform 2011.4 with ghc-7.4?
04:48:05 <damo22> @index order
04:48:06 <lambdabot> bzzt
04:48:21 <hey_lu> until now i only had to fix a couple of 'Num a' to '(Eq a, Num a)' issues...
04:49:56 <damo22> data Case = .... deriving Eq, Order is that valid?
04:50:13 <damo22> it doesnt like the comma
04:50:15 <NihilistDandy> hey_lu: I don't know how friendly base-4.5 is with the platform, and the potential for dependency hell is less than thrilling
04:50:26 <mekeor> damo22: (Eq,Order)
04:50:47 <NihilistDandy> hey_lu: If you grab the newest versions of the libraries included in the platform, your chances are much better
04:51:17 <mekeor> damo22: does Order exist at all? don't you mean Ord or Ordering?
04:51:25 <mux> it's Ord
04:51:29 <mux> Ordering is a type
04:51:35 <mekeor> oh, right...
04:51:39 <mux> :t compare
04:51:40 <lambdabot> forall a. (Ord a) => a -> a -> Ordering
04:51:41 <hey_lu> NihilistDandy: so I should update all the packages in hp-2011.4 to the most recent on hackage, right?
04:51:43 <mux> @src Ordering
04:51:43 <lambdabot> data Ordering = LT | EQ | GT
04:51:44 <mekeor> mux: yep
04:51:48 <mux> @src Ord
04:51:48 <lambdabot> class  (Eq a) => Ord a  where
04:51:49 <lambdabot>     compare      :: a -> a -> Ordering
04:51:49 <lambdabot>     (<), (<=), (>), (>=) :: a -> a -> Bool
04:51:49 <lambdabot>     max, min         :: a -> a -> a
04:51:50 <damo22> oops
04:52:23 <NihilistDandy> hey_lu: That should work. You'll probably hit a few hiccups, but hopefully nothing serious
04:52:34 <NihilistDandy> I'll be giving it a shot this afternoon, myself
04:53:06 <damo22> Botje: i dont understand the go order (c:cs) bit... what is order for?
04:53:56 <hey_lu> NihilistDandy: thanks :) probably I'll be around then, too.
04:54:16 <NihilistDandy> hey_lu: What OS are you running?
04:54:37 <hey_lu> NihilistDandy: archlinux
04:55:00 <NihilistDandy> Fun. How is Arch, these days? I knew some people in school who were very fond of it.
04:55:55 <mekeor> NihilistDandy: may i ask how old you are?
04:56:05 <NihilistDandy> mekeor: 22
04:56:30 <mekeor> ah
04:56:33 <NihilistDandy> Currently a 3rd year transfer (from information security to math and CS)
04:56:45 <NihilistDandy> Why do you ask? :D
04:56:50 <hey_lu> I like it (been on LinuxFromScratch, Ubuntu and Fedora before). especially because the pacman is fast and it doesn't do a lot of extra stuff
04:57:16 <mekeor> NihilistDandy: because you talked about school...
04:57:30 <mekeor> hey_lu: LFS O_O
04:57:36 <NihilistDandy> LFS was a lot of fun
04:57:57 <hey_lu> mekeor: I had a lot of time at my hands and noone was guiding me...
04:58:08 <mekeor> heh
04:59:08 <Flonk> Morning
04:59:32 <dibblego> is there a documented data structure where a function has its used domain/codomain values recorded for later inspection?
05:00:40 <mekeor> morning, Flonk
05:02:16 <rostayob> hey_lu: I wouldn't use GHC 7.4 for day-to-day haskell programming right now
05:02:26 <rostayob> you'll face a lot of breakage with hackage libs
05:03:06 <hey_lu> rostayob: mhh, but it brings quite a few advantages in too (I think)
05:03:37 <hey_lu> and it's better than ghc-7.0.3 :)
05:03:45 <rostayob> hey_lu: yeah but again, right now a lot (if not most...) hackage libraries will break
05:03:54 <rostayob> GHC 7.2 is quite usable
05:04:56 <hey_lu> rostayob: I'll try that if ghc-7.4 doesn't compile my current toy project :)
05:10:21 <NihilistDandy> rostayob: I actually saw more breakage with 7.2, but that's probably just me :D
05:10:57 <rostayob> NihilistDandy: well, at the beginning. My point is: don't expect stuff to work in the first 1/2 months of a new GHC release
05:11:00 <rostayob> even more possibly
05:11:18 <NihilistDandy> Definitely
05:11:39 <NihilistDandy> Though I've been using it as an opportunity to go bug-hunting :)
05:11:45 <rostayob> it would be really nice to have somet tool to collaboratively port the important libraries quickly
05:12:05 <rostayob> mhm but mantaining backwards compatibility is tricky
05:12:53 <NihilistDandy> It's been a pile of CPPFLAGS so far :D
05:13:23 <NihilistDandy> *CPP conditionals
05:14:24 <quicksilver> rostayob: in other similar situations, people have HEAD versions of "key" libraries which are compiling against HEAD versions of the compiler
05:14:35 <Tinned_Tuna> Hi, I'm trying to get lambdabot to respond to an @seen query, but it claims it's not a valid command
05:14:36 <quicksilver> so they are ready - or almsot ready - when the release comes
05:14:43 <quicksilver> Tinned_Tuna: it's been removed from lambdabot
05:14:47 <Tinned_Tuna> crap :-(
05:14:51 <quicksilver> preflex will answer though
05:14:53 <quicksilver> preflex: seen Tinned_Tuna
05:14:53 <preflex>  Tinned_Tuna was last seen on #haskell 6 seconds ago, saying: crap :-(
05:14:56 <Tinned_Tuna> quicksilver: do you know if that info is still logged
05:15:00 <damo22> Botje: http://paste.ubuntu.com/832629/ or anyone else who can help i cant make this compile :(
05:15:26 <mekeor> preflex: seen ski
05:15:26 <preflex>  ski was last seen on #haskell 3 days, 3 hours, 16 minutes and 10 seconds ago, saying: wavewave : might be interesting re partial evaluation, types, futamura
05:15:35 <quicksilver> damo22: you could at least paste the error message :P
05:15:57 <damo22> oh crap i forgot
05:16:49 <NihilistDandy> I read that as Futurama, at first
05:19:03 <kniu> @pl \x y z -> f (f y x) z
05:19:03 <lambdabot> (f .) . flip f
05:19:10 <kniu> well hot damn
05:19:23 <Sgeo> http://nickcraver.com/blog/2012/02/07/stack-overflow-short-on-space/ I blame elliott
05:19:50 <damo22> http://paste.ubuntu.com/832632/ sorry i have included the error message here
05:20:03 <rostayob> Sgeo: what's elliott on SO?
05:20:09 <NihilistDandy> Sgeo: I blame elliott for everything
05:20:19 <Sgeo> rostayob, ehird
05:21:34 <etpace> :t (>=>)
05:21:35 <lambdabot> forall a (m :: * -> *) b c. (Monad m) => (a -> m b) -> (b -> m c) -> a -> m c
05:22:42 <rostayob> Sgeo: thanks
05:22:47 <Sgeo> yw
05:23:16 <quicksilver> damo22: OK, so "Just xs" in line 86 is the output of lookupChar
05:23:29 <quicksilver> damo22: which means it's Maybe Char (and xs is Char), right?
05:23:51 <damo22> yeah
05:24:09 <quicksilver> damo22: so, you can't do "x <- xs" if it's a char
05:24:21 <quicksilver> for <- in a list comprehension the RHS has to be a list.
05:24:56 <jeltsch> I run the command “cabal install” without any further arguments in a directory of a Cabal package I am developing. Older Cabals didn’t complain about attempts to reinstall the package. The current HEAD version does. How can I make Cabal accepting it by default?
05:25:32 <dcoutts> jeltsch: ah yes, we're still pondering how to change that
05:25:49 <jeltsch> dcoutts: What is the best practice to deal with this case?
05:26:08 <dcoutts> my preferred solution is not to complain when the thing you're reinstalling has no other existing installed packages that depend on it (ie ones that would be broken by the reinstall)
05:26:20 <dcoutts> jeltsch: for the moment you just have to use the flag it says
05:26:58 <jeltsch> dcoutts: But then also reinstalling other packages would be accepted by Cabal. I mean packages from HackageDB.
05:27:14 <jeltsch> Can I tell Cabal to only accept reinstallation of the current package?
05:27:20 <dcoutts> jeltsch: I don't mean by default, I mean on the command line
05:27:32 <jeltsch> dcoutts: I know.
05:27:32 <dcoutts> on a case by case basis
05:27:50 <jeltsch> But using the flag makes Cabal also accept reinstalls of dependencies, right?
05:27:55 <dcoutts> right
05:27:58 <jeltsch> :-(
05:28:19 <jeltsch> So there is no way to tell Cabal only to accept reinstalls of the package in which directory I am?
05:28:36 <dcoutts> jeltsch: no, not currently, and I'd not been planning that
05:28:42 <jeltsch> Hmm.
05:29:02 <jeltsch> You said, “my preferred solution is not to complain when the thing you're reinstalling has no other existing installed packages that depend on it”.
05:29:02 <dcoutts> jeltsch: I think it'll be ok if we have the warning list the packages that will be reinstalled and the ones that will be broken by those reinstalls
05:29:19 <jeltsch> But what if I’m developing two packages A and B, where B depends on A.
05:29:24 <jeltsch> I make some changes at A.
05:29:25 <dcoutts> jeltsch: if you want to avoid reinstalling things other than the current package, you have to play with the constraints
05:29:42 <dcoutts> but if we list what's going to be reinstalled then that'll be obvious at least
05:29:42 <jeltsch> Then I would usually reinstall A and then reinstall B.
05:30:05 <jeltsch> But with your proposed solution, this wouldn’t be possible anymore, right?
05:30:29 <dcoutts> jeltsch: if you don't want to reinstall both at the same time then the "right thing to do" is to warn that you're going to break B by reinstalling A
05:30:44 <jeltsch> Okay, but I cannot install both at the same time.
05:30:51 <dcoutts> can't you?
05:30:58 <jeltsch> How would I do that?
05:31:00 <dcoutts> it's easy enough to say: cabal install ./ ../B
05:31:07 <dcoutts> or whatever
05:31:19 <jeltsch> Aha, I didn’t know that you can give directories as arguments to cabal install.
05:31:25 <jeltsch> Very good. :-)
05:31:29 <dcoutts> :-)
05:31:47 <dcoutts> (also local and remote tarballs)
05:31:49 * quicksilver secretly adds a recursive package dependency to jeltsch's system. Ha! Now what?
05:32:03 <dcoutts> quicksilver: the solver will complain :-)
05:33:08 <matthiasgorgens> Is there a standard lib function to invert Ordering?
05:33:28 <quicksilver> matthiasgorgens: flip?
05:34:08 <rostayob> quicksilver: I think he means going from GT to LT, and vice-versa.
05:34:13 <matthiasgorgens> I want a function of type Ordering -> Ordering.
05:34:18 <matthiasgorgens> rostayob, yes.
05:34:34 <Botje> damo22: order is a bad name for it. it's the case of the previously chosen letter, since you stated that two uppercase or lowercase letters next to each other were not allowed.
05:34:41 <matthiasgorgens> At least max works for Ordering.
05:34:51 <rostayob> @hoogle Ordering -> Ordering
05:34:51 <lambdabot> Prelude id :: a -> a
05:34:51 <lambdabot> Data.Function id :: a -> a
05:34:51 <lambdabot> GHC.Exts breakpoint :: a -> a
05:34:54 <quicksilver> (flip compare EQ)
05:34:58 <quicksilver> I think
05:35:04 <quicksilver> > flip compare EQ LT
05:35:06 <lambdabot>   LT
05:35:09 <quicksilver> gah
05:35:13 <quicksilver> > compare EQ LT
05:35:14 <lambdabot>   GT
05:35:20 <quicksilver> just (compare EQ) then ;)
05:35:41 <quicksilver> ^^ matthiasgorgens
05:35:56 <jeltsch> hackagebot: Are you lazy?
05:35:59 <Botje> damo22: also, your code is ill-typed.
05:36:05 <matthiasgorgens> quicksilver: yeah, should work.
05:36:14 <quicksilver> "should" work?
05:36:16 <quicksilver> :t compare EQ
05:36:17 <lambdabot> Ordering -> Ordering
05:36:18 * jeltsch wonders how long it takes for hackagebot to react to a package upload.
05:36:25 <Botje> damo22: if you still want to use lookup, use (Char, ([Char],[Case]))
05:36:34 <damo22> Botje: i know i am having trouble making it work
05:36:34 <Botje> damo22: or even (Char [(Char, Case)])
05:36:35 <quicksilver> it's a function on three elements, of the right type, and gets the correct value in all three cases.
05:36:42 <quicksilver> I wonder how it could fail? :)
05:37:02 <Botje> I thought getCase would just check isDigit / isAlpha / return false for any given char
05:39:30 <hey_lu> is there a streaming/lazy version of xml-conduit's parseText?
05:41:28 * hackagebot fraction 0.1.0.1 - Fractions  http://hackage.haskell.org/package/fraction-0.1.0.1 (WolfgangJeltsch)
05:46:00 <hey_lu> i tried parseLBS, but that gave me an error in decodeUtf8
05:48:36 <jeltsch> How can I compute the parent directory of a directory given as a FilePath?
05:48:49 <jeltsch> In a platform-independent way, I mean.
05:49:56 <mekeor> jeltsch: reverse $ takeWhile (\x->x/='/' || x/='\') $ reverse filepath -- ?
05:50:11 <jeltsch> mekeor: :-O
05:50:14 <mekeor> > reverse $ takeWhile (\x->x/='/' || x/='\') $ reverse "/home/foobar/blub"
05:50:14 <lambdabot>   <no location info>:
05:50:15 <lambdabot>      lexical error in string/character literal at chara...
05:50:32 <jeltsch> mekeor: No predefined function for that?
05:50:55 <jeltsch> mekeor: Also observe that this will treat \ as a separator on UNIX, which is wrong, as \ can be part of a filename.
05:50:57 <mekeor> jeltsch: reverse $ takeWhile (\x->x/='/' || x/='\') $ reverse "/home/foobar/foo"
05:51:02 <mekeor> > reverse $ takeWhile (\x->x/='/' || x/='\') $ reverse "/home/foobar/foo"
05:51:03 <lambdabot>   <no location info>:
05:51:03 <lambdabot>      lexical error in string/character literal at chara...
05:51:09 <mekeor> > reverse $ takeWhile (\x->x/='/' || x/='\\') $ reverse "/home/foobar/foo"
05:51:10 <lambdabot>   "/home/foobar/foo"
05:51:12 <nand`> > reverse $ takeWhile (\x->x/='/' && x/='\') $ reverse "/home/foobar/blub"
05:51:13 <lambdabot>   <no location info>:
05:51:13 <lambdabot>      lexical error in string/character literal at chara...
05:51:14 <mux> uh
05:51:15 <mux> please
05:51:18 <Botje> jeltsch: there's a takeDirectory in System.FilePath.Windows and System.FilePath.Posix
05:51:19 <mux> :t takeDirectory
05:51:19 <lambdabot> Not in scope: `takeDirectory'
05:51:20 <mekeor> argh..
05:51:25 <mux> :t System.FilePath.takeDirectory
05:51:26 <lambdabot> FilePath -> FilePath
05:51:34 <Botje> they're both in the filepath package
05:51:37 <mux> > System.FilePath.takeDirectory "/foo/bar"
05:51:38 <lambdabot>   Not in scope: `System.FilePath.takeDirectory'
05:51:45 <mux> oh well
05:51:48 <jeltsch> Botje: But there is no generic takeDirectory?
05:51:50 <nand`> > reverse $ takeWhile (\x->x/='/' && x/='\\') $ reverse "/home/foobar/blub"
05:51:51 <lambdabot>   "blub"
05:51:58 <nand`> > reverse $ dropWhile (\x->x/='/' && x/='\\') $ reverse "/home/foobar/blub"
05:51:59 <lambdabot>   "/home/foobar/"
05:52:08 <jeltsch> Botje: I mean, I have to detect first, whether I’m on Windows or Unix?
05:52:15 <mekeor> nand`: hehe.. yep. that's what i tried... -.-
05:52:23 <mux> no you don't, use the System.FilePath functions
05:52:25 <Botje> jeltsch: no, apparently importing System.FilePath is smart enough
05:52:35 <Botje> it imports the right package for you
05:52:58 <jeltsch> Botje: So System.FilePath also has takeDirectory?
05:53:14 <Botje> yes, it reexports the .Posix or .Windows versions when compiled
05:53:23 <jeltsch> What package is System.FilePath in?
05:53:34 <mux> jeltsch: unsurprisingly: filepath
05:54:13 <jeltsch>  Thanks alot
05:54:16 <jeltsch> a lot
05:54:18 <jeltsch> .
05:56:19 <franco00> I have a bit of a problem with the IO part of my program. It is a simple command line program (like "maddress -q file.txt"). When it is called it of corse has to perform some checks (does the -q option exist? does the file exist?). I am doing that via (if then else), but it is quite cumbersome, is ther any other option?
05:58:07 <adnam> franco00: there are libraries on hackage for command line arg parsing
05:58:24 <jeltsch> Ist there a function that takes elements from a list as long as they are different
05:58:28 <jeltsch> ?
05:58:56 <adnam> > nub [1,2,3,1,2] -- ?
05:58:57 <lambdabot>   [1,2,3]
05:59:02 <hey_lu> jeltsch: different from what?
06:00:09 <mekeor> franco00: you mean, you're looking for alternatives to if-then-else?  if yes, then look for "when", "unless" and guards could help, too. and also case-...-of-...
06:00:23 <jeltsch> I mean: \xs -> head xs : map snd $ takeWhile (uncurry (/=) $ zipWith xs (tail xs)
06:00:48 <jeltsch> > let function = \xs -> head xs : map snd $ takeWhile (uncurry (/=) $ zipWith xs (tail xs) in function "Hello!"
06:00:49 <lambdabot>   <no location info>: parse error on input `in'
06:00:55 <franco00> mekeor: thanks
06:01:07 <jeltsch> let function = \xs -> head xs : map snd $ takeWhile (uncurry (/=)) $ zipWith xs (tail xs) in function "Hello!"
06:01:20 <mekeor> @hoogle when
06:01:20 <lambdabot> Control.Monad when :: Monad m => Bool -> m () -> m ()
06:01:20 <lambdabot> System.Posix.Terminal WhenDrained :: TerminalState
06:01:20 <lambdabot> Test.QuickCheck.Property whenFail :: Testable prop => IO () -> prop -> Property
06:01:24 <jeltsch> > let function = \xs -> head xs : map snd $ takeWhile (uncurry (/=)) $ zipWith xs (tail xs) in function "Hello!"
06:01:25 <lambdabot>   Couldn't match expected type `[a]'
06:01:26 <lambdabot>         against inferred type `[(a1, b)]...
06:01:30 <jeltsch> Hmm.
06:01:50 <jeltsch> let function = \xs -> head xs : (map snd $ takeWhile (uncurry (/=)) $ zipWith xs (tail xs)) in function "Hello!"
06:02:05 <quicksilver> > map head . groupBy (==) $ "Hello!"
06:02:07 <lambdabot>   "Helo!"
06:02:13 <quicksilver> jeltsch: ^^ is that what you meant?
06:02:13 <jeltsch> > let function = \xs -> head xs : (map snd $ takeWhile (uncurry (/=)) $ zipWith xs (tail xs)) in function "Hello!"
06:02:14 <lambdabot>   Couldn't match expected type `a -> b -> c'
06:02:15 <lambdabot>         against inferred type `[...
06:02:25 <jeltsch> quicksilver: No.
06:02:35 <quicksilver> then what did you mean?
06:02:59 <franco00> mekeor: http://hpaste.org/57578 <- just for reference
06:03:08 <jeltsch> adnam, quicksilver,hey_lu: I mean function "Hello!" = "Hel"
06:03:59 <mux> > let function = \xs -> head xs : (map snd $ takeWhile
06:04:00 <lambdabot>   <no location info>: parse error (possibly incorrect indentation)
06:04:03 <mux> oops
06:04:06 <jeltsch> > let function = \xs -> head xs : (map snd $ takeWhile (curry (/=)) $ zipWith xs (tail xs)) in function "Hello!"
06:04:07 <lambdabot>   Couldn't match expected type `GHC.Bool.Bool'
06:04:08 <lambdabot>         against inferred type ...
06:04:10 <mux> jeltsch: you're using zipWith but not giving a function
06:04:18 <mux> you meant just zip
06:04:26 <jeltsch> > let function = \xs -> head xs : (map snd $ takeWhile (curry (/=)) $ zip xs (tail xs)) in function "Hello!"
06:04:27 <lambdabot>   Couldn't match expected type `GHC.Bool.Bool'
06:04:28 <lambdabot>         against inferred type ...
06:04:40 <quicksilver> I don't think there is, no
06:04:43 <mux> but you have other problems
06:04:47 <quicksilver> @quote aztec
06:04:48 <lambdabot> quicksilver says: zip`ap`tail - the Aztec god of consecutive numbers
06:05:04 <jeltsch> let function = \xs -> head xs : (map snd $ takeWhile (uncurry (/=)) $ zip xs (tail xs)) in function "Hello!"
06:05:04 <mekeor> franco00: use do-syntax and indentation, pls
06:05:10 <jeltsch> > let function = \xs -> head xs : (map snd $ takeWhile (uncurry (/=)) $ zip xs (tail xs)) in function "Hello!"
06:05:11 <lambdabot>   "Hel"
06:05:12 <mekeor> @hoogle (&&)
06:05:12 <lambdabot> Prelude (&&) :: Bool -> Bool -> Bool
06:05:12 <lambdabot> Data.Bool (&&) :: Bool -> Bool -> Bool
06:05:12 <lambdabot> Control.Arrow (&&&) :: Arrow a => a b c -> a b c' -> a b (c, c')
06:05:28 <jeltsch> So now it works.
06:05:33 <mekeor> franco00: and "foo && bar" instead of "and [foo,bar]"
06:06:02 <franco00> mekeor: I see mekeor
06:06:18 <franco00> (I mean, using the do notation, which I kind of dislike)
06:06:28 <jeltsch> With (\x y -> abs x y >= epsilon) instead of (/=) this is also good if you have an infinite list of approximations.
06:06:36 <franco00> but it is indented, otherwise it would not work :P
06:06:40 <jeltsch> Take the last element of it, and you have the approximated value.
06:11:28 * hackagebot sphinx 0.5.3.1 - Haskell bindings to the Sphinx full-text searching daemon.  http://hackage.haskell.org/package/sphinx-0.5.3.1 (GregWeber)
06:12:47 <mekeor> franco00: http://hpaste.org/57578
06:13:57 <franco00> mekeor: yes, that's my very same paste, right?
06:14:16 <franco00> oh hell sorry didn't see the annotation
06:14:18 <franco00> thanks mekeor
06:15:20 <mekeor> franco00: import Control.Monad (unless,when); import System.Exit (exitFailure,exitSuccess)
06:18:11 <jeltsch> How do I check if some file exists?
06:18:15 <franco00> hell, I should study more before writing. thanks again mekeor
06:18:23 <franco00> jeltsch: doesFileExist
06:18:35 <franco00> System.Directory
06:21:43 <jeltsch> franco00: Thanks. Is there also a version that accepts a pattern like “*.hs”?
06:22:39 <franco00> jeltsch: http://www.haskell.org/ghc/docs/6.12.2/html/libraries/directory-1.0.1.1/System-Directory.html I would do getDirectoryContents and then filter the result
06:26:18 <jeltsch> franco00: Yes, this is also what would I do in absence of a pattern-supporting function.
06:26:56 <elliott> jeltsch: http://hackage.haskell.org/package/Glob
06:27:29 <elliott> jeltsch: globDir1 (compile "*.hs") myDirPath
06:27:37 <elliott> (or (glob "*.hs") for current directory)
06:27:39 <ChristianS> i'm looking for a pdf version of http://www.haskell.org/haskellwiki/All_About_Monads , but "You can download a PDF version here" is a dead link (Firefox can't find the server at mauke.dyndns.org.) does anyone one whether/where a pdf version still exists?
06:29:41 <Baughn> > posixSecondsToUTCTime 1328626800000000
06:29:42 <lambdabot>   Not in scope: `posixSecondsToUTCTime'
06:32:52 <elliott> Baughn: thursday
06:33:18 <Baughn> elliott: Thank you.
06:33:37 <Baughn> elliott: Though actually I was wondering where Show UTCTime has gone off to..
06:33:47 <elliott> Baughn: oh, it's not actually thursday. well, it might be
06:33:51 <elliott> but i didn't check or anything :)
06:34:09 <Baughn> elliott: Doesn't "thursday" require a functioning human civilization? :P
06:34:12 <elliott> Baughn: it's in the latest time library
06:34:16 <elliott> Baughn: exactly!
06:34:19 <elliott> it's thursday _somewhere_
06:34:41 <koeien> not at the moment.
06:34:51 <matthiasgorgens> reminds me of the man who was thursday.
06:35:19 <elliott> koeien: It's Thursday in my mind.
06:35:22 <Baughn> elliott: Prelude Data.Time Data.Time.Clock.POSIX> posixSecondsToUTCTime 0
06:35:24 <Baughn> Just saying.
06:35:36 <Baughn> Er. "No instance for (Show UTCTime)"
06:35:53 <elliott> Baughn: Dunno, then.
06:35:55 <elliott> Maybe it's new.
06:36:28 * hackagebot clocked 0.4.1.1 - timer functionality to clock IO commands  http://hackage.haskell.org/package/clocked-0.4.1.1 (SoenkeHahn)
06:36:33 <rostayob> "I'm 40. Not 40 years of age, I literally am 40."
06:37:32 <wern> Is there a simple way of "updating" a single field in a record, or do I have to supply all fields every time when I create a new record?
06:37:40 <koeien> wern: x { f = 37 }
06:37:56 <koeien> x is the "previous" value, f is a field
06:38:22 <koeien> (you might want to consider lenses)
06:38:39 <koeien> speaking of lenses, which library is generally recommended for lenses?
06:39:08 <wern> koeien: great, thanx!
06:39:11 <elliott> data-lens
06:39:15 <elliott> or fclabels, depending on who you ask
06:39:20 <elliott> (data-lens, if you ask the right people!)
06:39:25 * Baughn always used data-accessors
06:39:29 <koeien> :(
06:39:44 <koeien> what's the one with all the magic Arrow stuff?
06:41:33 <koeien> Edward Kmett recommends data-lens as well on stackoverflow
06:41:42 <elliott> edward kmett wrote data-lens :P
06:41:47 <elliott> the Arrow stuff is fclabels as of 1.0
06:41:55 <elliott> Baughn: data-accessors has a repulsive internal representation
06:42:02 <elliott> *accessor
06:42:05 <elliott> also nobody seems to use it any more, but...
06:42:07 <koeien> elliott: right, but it could have been superceded or something :)
06:42:23 <elliott> oh
06:42:26 <elliott> the internal representation was fixed
06:42:33 <elliott> ok, the main problem is "T" :P
06:47:44 <Taneb> Hello!
06:47:54 <mekeor> hello, Taneb!
06:49:53 <jfischoff> anyone tried any of the new datatype generic programming?
06:50:35 <eyebloom> How does it work?
06:50:59 <jfischoff> http://www.haskell.org/haskellwiki/Generics
06:51:26 <jfischoff> you write a few instances of a type class
06:52:20 <jfischoff> the simple example makes sense, but I'm trying to do something similar to aeson's ToJSON and looking at Bryan's code is confusing me
06:52:38 <jfischoff> which I'm sure is do to my ignorance
06:52:55 <Taneb> I had a crazy idea!
06:53:06 <Taneb> It's rather crazy
06:53:11 <Taneb> So I won't mention it
06:53:16 <adnam> a rather crazy crazy idea?
06:53:21 <mekeor> lol
06:53:27 <jfischoff> yeah you have to finish that
06:54:01 <hey_lu> Baughn: Data.Time.LocalTime has a Show instance for UTCTime
06:54:01 <mekeor> Taneb: Did you mean "really" ?
06:54:04 <adnam> this intrigues me both haskell-wise and linguistically
06:54:13 <Taneb> mekeor, I know what I meant
06:54:39 <Taneb> Basically it's using Haskell to implement Decimal numbers
06:54:43 <jfischoff> and the idea is ....
06:55:08 <Taneb> You'll see!
06:55:12 <Taneb> YOU'LL ALL SEE!
06:56:41 <kniu> @hoogle cut
06:56:42 <lambdabot> package Agda-executable
06:56:42 <lambdabot> Graphics.Rendering.OpenGL.GL.DisplayLists CompileAndExecute :: ListMode
06:56:42 <lambdabot> System.Directory executable :: Permissions -> Bool
06:57:57 <hey_lu> does anyone know a streaming/lazy version of xml-conduit's parseText?
06:59:37 <elliott> hey_lu: sinkTextDoc, presumably
07:02:40 <hey_lu> elliott: thanks, I'll try that.
07:06:30 <johnsingleton> how do I handle the case where I need a IO functionality not available in SIO, but they are in the same series of computations? e.g.: I need to read the contents of every file returned from getDirectoryContents, for example.
07:06:31 <hpaste> “_Mikey” pasted “do foo” at http://hpaste.org/57582
07:06:38 <_Mikey> hey
07:06:51 <_Mikey> can anyone help me get my head around do notation?
07:07:10 <_Mikey> is either approach to what I pasted possible?
07:07:12 <koeien> _Mikey: no
07:07:18 <_Mikey> oh
07:07:21 <koeien> the first one, yes
07:07:29 <koeien> the second one, use let a = if x /= "baz" then 10 else 20
07:07:51 <koeien> although shadowing is sometimes/generally frowned upon
07:07:52 <_Mikey> ahhh ok
07:08:05 <koeien> remember than if..then..else is just an expression
07:08:09 <koeien> that*
07:08:10 <_Mikey> sometimes leading more towards generally?
07:08:22 <koeien> depends on who you ask :)
07:08:26 <koeien> i don't like it
07:08:32 <_Mikey> oh..
07:08:45 <_Mikey> how would you approach that situation?
07:08:48 <koeien> also, in putStrLn(a), just drop the ()
07:09:01 <koeien> it doesn't harm, but it's unnecessary and ugly
07:09:01 <_Mikey> ah ok
07:09:22 <elliott> don't just drop the ()
07:09:26 <elliott> replace the ( with a space too
07:09:28 <elliott> :p
07:09:31 <koeien> :)
07:09:37 <_Mikey> :)
07:09:41 <elliott> :)
07:09:44 <_Mikey> I figured :)
07:09:46 <elliott> @botsnack
07:09:46 <lambdabot> :)
07:10:12 <_Mikey> this damn do notation gets me in an imperative mood :p
07:12:48 <E3D3> I'm an absolute noob and wondered if I could do something similar in GHCi as @src for lambdabot ?
07:13:00 <koeien> E3D3: afaik no :(
07:13:14 <E3D3> Okay Thanks (Pipo ?)
07:13:33 <Phlogistique> E3D3: you can install lambdabot locally though
07:13:59 <Phlogistique> I'm not sure what @src does, but most lambdabot features can be made accessible in GHCi, AFAIK
07:14:21 <E3D3> Is that hard/complex to do ?
07:14:24 <_Mikey> @src head
07:14:24 <lambdabot> head (x:_) = x
07:14:25 <lambdabot> head []    = undefined
07:15:00 <_Mikey> I heard its quite tricky to get lambdabot working locally
07:15:21 <_Mikey> cause it doesn't always like the latest packages, or something to that effect.
07:16:12 <byorgey> _Mikey: it ranges from somewhat tricky to exceedingly tricky, depending on your experience/facility with resolving dependency versioning problems
07:16:26 <hpaste> johnsingleton pasted “LazyIO Issue” at http://hpaste.org/57583
07:16:32 <E3D3> Then I better let it and continue concentrating on Haskell. Thanks.
07:16:35 <_Mikey> ahh
07:16:56 <koeien> E3D3: you should be aware of the existence of Hoogle. it's quite awesome
07:17:03 <koeien> @where hoogle
07:17:04 <lambdabot> http://haskell.org/hoogle
07:17:22 <koeien> it's quite easy to read the source code of functions that way
07:17:29 <koeien> although, admittedly, not as easy as @src
07:17:30 <E3D3> Thought you mean Google. Thanks again.
07:17:35 <johnsingleton> I am having an issue with lazy io -- namely, I build a list of the file contents of a series of files as decoded json objects
07:18:02 <johnsingleton> but when I get to the fold step (I am just putting them all together) I get an error about  a file handle being closed
07:18:07 <johnsingleton> any idea what's going on?
07:18:53 <johnsingleton> aside from doing something like forcing strict IO, what can be done?
07:19:25 <Saizan> are you using hClose or withFile?
07:19:48 <johnsingleton> withFile
07:19:57 <johnsingleton> previously I tried hClose, however
07:19:58 <koeien> it's possible that your handle has been "leaked"
07:20:03 <Saizan> withFile is the problem, because it closes the Handle before returning
07:20:12 <Saizan> hClose is also bad with lazy I/o
07:20:25 <hpc> :t withFile
07:20:26 <lambdabot> Not in scope: `withFile'
07:20:26 <elliott> johnsingleton: don't use lazy IO :P
07:20:28 <koeien> h <- withFile (\h -> return h)  .. use h and whoops ..
07:20:33 <Saizan> you should let hGetContents close the file when it's done
07:20:37 <koeien> yes lazy IO + closing handles = ???
07:20:41 <johnsingleton> Saizan: the problem I had before was that it was keeping all the files open -- thusly resulting in a too many open files issue
07:20:50 <koeien> yes. then lazy IO is off basically
07:21:00 <Taneb> I'm going to rewrite my Langton's Ant display code to get rid of the flickering
07:21:13 <Saizan> johnsingleton: you could try deferring the opening of the files too, if you only need a few of them at once
07:21:27 <matthiasgorgens> Suppose I want to implement some kind of resource management.  There would be function (among others) for allocation, that took a list of, say, hard disks with free disk space, and the needed MiB.  It would return a list of hard disk and how much space to take from each of them to fulfill the request.  (The current version does greedy allocation, with lots of fragmenting.  But that's fine.)  What's a nice way to write a function like that with combin
07:21:32 <johnsingleton> Saizan: I really only need one at a time
07:21:48 <matthiasgorgens> alloc :: Integer -> [(Uuid, Integer)] -> Maybe [(Uuid, Integer)]
07:22:10 <Saizan> johnsingleton: then unsafeInterleaveIO (readFile filename) might be what you want
07:22:11 <matthiasgorgens> Returns Nothing, if the request can't be satisfied.
07:22:25 <Saizan> johnsingleton: assuming you consume the whole file
07:22:31 <johnsingleton> Saizan: I do
07:22:52 <johnsingleton> Saizan: The issue is shown, here if you want to look: http://hpaste.org/57583
07:23:40 <koeien> doesn't that leak the file descriptor?
07:23:41 <mkscrg> so i'm trying to use hpc with cabal test-suite and test-framework. i'm using -fhpc and it seems to be using hpc, but the summary tables are always empty
07:23:52 <koeien> you need to force the whole output before closing the file
07:24:11 <Saizan> koeien: he does print js though
07:24:22 <koeien> Saizan: ah yes.
07:24:24 <Saizan> johnsingleton: do you get the error even with C.putStrLn js there?
07:24:43 <johnsingleton> Saizan: I'd like to remove that line ;)
07:24:50 <Saizan> johnsingleton: ah, ok
07:24:58 <johnsingleton> that feels like cheating
07:25:15 <pcavs> Can you specify the type of just a single argument?
07:25:20 <Saizan> johnsingleton: so yeah, get read of withFile and hGetContents and use the line i suggested above
07:25:27 <koeien> pcavs: f (x :: Integer) y = ...
07:25:45 <Saizan> *get rid
07:25:48 <koeien> (requires PatternSignatures)
07:25:52 <johnsingleton> Saizan: Is there a way to make it work with normal lazy IO?
07:26:14 <koeien> pcavs: but in a type sig like f :: ..., no
07:26:25 <pcavs> koeien: thanks
07:26:55 <pcavs> koeien: am I correct in thinking that that one line would only define a partial function? I.e. it's not a constraint on the type, but rather for polymorphism?
07:27:33 <koeien> pcavs: i'm not sure what you mean, but overloading in haskell is not done in this way
07:27:45 <srhb> Is there a good reason why map is not just fmap? Or is it just a remnant design choice?
07:27:45 <koeien> pcavs: i.e. the following is illegal
07:27:56 <koeien> f (x :: Integer) y = ...; f (x :: String) y = ..;
07:28:33 <hpc> srhb: hysterical raisins, mainly
07:28:49 <hpc> srhb: it has the side benefit of hiding "scary functors" from newbies until they get how map works
07:28:59 <Saizan> johnsingleton: nothing that'd be better than strict IO, and btw foldl (\acc x -> acc ++ x) [] should be replaced with concat
07:29:08 <srhb> hpc: Okay, thanks.
07:29:19 <Saizan> > foldl (++) [] ["foo","bar"]
07:29:21 <lambdabot>   "foobar"
07:29:26 <hpc> @src concat
07:29:27 <lambdabot> concat = foldr (++) []
07:29:38 <elliott> srhb: Standard THINK OF THE BEGINNERS reason.
07:29:40 <quicksilver> maybe com
07:29:44 <quicksilver> ncat was too fast!
07:29:47 <elliott> srhb: As well as historical precedent, of course.
07:29:49 <Saizan> concat does the same but it's lazier, which is good for lists
07:29:50 <johnsingleton> Saizan: oh nice
07:29:50 <elliott> Functor hasn't always been around.
07:29:52 <koeien> i'd rather have BeginnerPrelude.
07:30:07 <koeien> without overloading
07:30:07 <elliott> koeien: Strongly agreed.
07:30:27 <johnsingleton> Saizan: So what is the better way to go, with unsafe or strict?
07:30:37 <Taneb> @hoogle Maybe a -> [a]
07:30:37 <lambdabot> Data.Maybe maybeToList :: Maybe a -> [a]
07:30:37 <lambdabot> Data.Foldable toList :: Foldable t => t a -> [a]
07:30:38 <lambdabot> Data.Maybe catMaybes :: [Maybe a] -> [a]
07:30:39 <elliott> Just make everything Double (or maybe Rational with fixed-precision "floaty" ops.)
07:30:44 <johnsingleton> I mean, I don't want to do something the wrongish way
07:30:51 <hpc> johnsingleton: strict IO is easier to reason about than lazy or unsafe
07:31:03 <hpc> lazy IO is in fact implemented in terms of unsafe IO
07:31:30 * hackagebot libmpd 0.7.1 - An MPD client library.  http://hackage.haskell.org/package/libmpd-0.7.1 (JoachimFasting)
07:31:35 <maurer> hpc: You can be a little safer by using unsafeInterleaveIO I suppose
07:31:43 <hpc> probably
07:31:46 <Saizan> johnsingleton: i'd go with unsafe if i cared a lot about keeping it streaming-like, but also didn't care too much about maintainability
07:31:58 <hpc> in any event, the functions on Handle are excellent
07:32:20 <johnsingleton> Saizan: The resource management part is pretty key
07:36:33 <dolio> Lazy I/O is implemented with unsafeInterleaveIO.
07:37:48 <hpc> :t until
07:37:49 <lambdabot> forall a. (a -> Bool) -> (a -> a) -> a -> a
07:38:25 <hpc> @hoogle m Bool -> m a -> m [a]
07:38:26 <lambdabot> Text.ParserCombinators.ReadP manyTill :: ReadP a -> ReadP end -> ReadP [a]
07:38:26 <lambdabot> Text.ParserCombinators.ReadP endBy :: ReadP a -> ReadP sep -> ReadP [a]
07:38:26 <lambdabot> Text.ParserCombinators.ReadP endBy1 :: ReadP a -> ReadP sep -> ReadP [a]
07:38:57 <_Mikey> sorry
07:39:01 <_Mikey> I think I'm going crazy
07:39:08 <_Mikey> does !! modify the list?
07:39:14 <_Mikey> it only access' right
07:39:24 * quicksilver wonders if it's OK to use a neutral sounding verb like implements for Lazy I/O
07:39:24 <hpc> :t let whileM p m = do {p' <- p; if p' then m >> whileM p m else return ()} in whileM
07:39:25 <lambdabot> forall (m :: * -> *) a. (Monad m) => m Bool -> m a -> m ()
07:39:30 <johnsingleton> what units does :set +s report in -- I get a negative seconds number
07:39:47 <quicksilver> Lazy I/O is promulgated by unsafeInterleaveIO.
07:39:54 <quicksilver> promulgated sounds at least a bit nasty
07:40:00 <quicksilver> _Mikey: only access
07:40:07 <quicksilver> in fact, you can't modify lists.
07:40:15 <_Mikey> quicksilver: thanks.
07:40:16 <hpc> :t let whileM p m = do {p' <- p; if p' then m >>= \h -> whileM p m >>= \t -> return (h:t) else return []} in whileM
07:40:18 <lambdabot> forall (m :: * -> *) a. (Monad m) => m Bool -> m a -> m [a]
07:40:19 <johnsingleton> like, my execution time is: -566935.10 secs
07:40:21 <koeien> in fact, you can't modify anything!
07:40:25 <johnsingleton> huh?
07:40:35 <quicksilver> johnsingleton: weird.
07:40:39 <quicksilver> the unit is normally seconds.
07:40:42 <koeien> johnsingleton: that's bizarre and probably a bug
07:40:45 <quicksilver> I guess something is wrong on your system :)
07:40:45 <_Mikey> koeien: good point.
07:40:48 <johnsingleton> TIME TRAVEL
07:40:52 <_Mikey> YES!
07:40:57 <tgeeky> johnsingleton: no, that's not time travel.
07:41:02 <johnsingleton> my program is so efficient, it executes in negative time
07:41:16 <elliott> quicksilver: perpetrated
07:41:19 <tgeeky> johnsingleton: you must have just ran it in reverse
07:41:21 <_Mikey> source pls
07:41:24 <zomg> My program is so efficient it executes outside of time entirely
07:41:31 <mwc> O(1/n) time would be impressive
07:41:34 <hpc> tgeeky: lol, his computer is in the wrong gear?
07:41:46 <johnsingleton> ya, the clutch *has* been slipping lately
07:41:47 <ion> O(−1)
07:41:52 <koeien> johnsingleton: maybe NTP just did some magic?
07:41:56 <tgeeky> hpc: yes. damn european style gear shifts.
07:42:06 <zomg> Although I am worried it may eventually cause an invasion of demons from the 9th dimension
07:42:18 <mwc> Anybody else tried to build native Haskell support into cmake?
07:42:24 <tgeeky> zomg: string theory deamons?!?
07:42:33 <johnsingleton> ran it again, not negative anymore, but also totally wrong
07:42:41 <ion> mwc: Would that be more useful than cabal?
07:42:45 <hpc> tgeeky: no, that's the 11th dimension; these are plain old quantum demons
07:42:49 <johnsingleton> 541166.44 secs -- pretty sure that isn't right
07:42:55 <tgeeky> hpc: hehe.
07:42:57 <johnsingleton> seeing as it ran in less than a second
07:43:08 <mwc> ion: yeah, I particularly care about interop with C and Fortran libraries
07:43:13 <hpc> johnsingleton: floating point error?
07:43:22 <quicksilver> elliott: sounds good to me.
07:43:37 <maurer> mwc: You can call C and Fortran without cmake...
07:43:45 <johnsingleton> hpc: no idea -- is there something besides :set +s?
07:43:45 <mwc> ion: in a project that is natively part C
07:44:11 <jedai|2> johnsingleton: maybe unsafeInterleaveIO is playing hell with the timing of :set -s (never particularly good anyway, especially given that optiomisation may change so may thing)
07:44:18 <hpc> johnsingleton: compile it and add +RTS iforgettherest -RTS to the options you run it with
07:44:20 <maurer> mwc: http://book.realworldhaskell.org/read/advanced-library-design-building-a-bloom-filter.html
07:44:22 <mwc> maurer: yeah, I had tried to build a set of cabal hooks to build the C parts with cmake but having dependencies in cabal and in cmake is *hard*
07:44:25 <hpc> ./foo +RTS stuff ...
07:44:38 <jedai|2> hpc: +RTS -sstderr I believe
07:44:42 <maurer> mwc: This shows how to include C files in a cabal library if that helps?
07:44:45 <mwc> the dependencies cut both ways
07:44:49 <jedai|2> something like that...
07:44:51 <johnsingleton> I'm just doing it from ghci
07:44:55 <mwc> maurer: it doesn't, was way beyond that before I started this approach
07:45:22 <johnsingleton> well, point is, I'm pretty wildly impressed with how fast it performs
07:45:50 <jedai|2> Does it really perform ?
07:45:53 <mwc> basically I think it's easier to add Haskell support to a general purpose build tool than try to to turn cabal into a general purpose build tool via userhooks ;)
07:46:00 <johnsingleton> some unspecified time, under a second, it parsed 23,000 json messages, in 2000 files.
07:46:11 <johnsingleton> that to me is very very fast
07:46:34 <johnsingleton> again, I can't say how long because my timing isn't working
07:46:37 <dcoutts> mwc: oh sure, via user hooks, since that's a totally useless API, but to turn cabal into a general purpose build tool properly...
07:46:50 <Jedai> johnsingleton: Are you sure it did it or did it just fake it or put it in a thunk to do it later ?
07:47:21 <mwc> dcoutts: isn't that what hmake is for?
07:47:28 <johnsingleton> jedai: I force it to count the size of [Message] -- and each file has different #'s of messages
07:47:29 <Jedai> johnsingleton: not to be pessimistic but I tend to be suspicious when things are just a bit too good...
07:47:52 <Jedai> johnsingleton: Ok, that seems conclusive, then it's impressive :)
07:47:52 <johnsingleton> so it would *have* to perform the deserialization to evaluate it
07:48:21 <dcoutts> mwc: you mean the old thing called hmake, or something more recent?
07:48:38 <mwc> I thought there was some new interest in a project called hmake
07:48:47 <johnsingleton> Jedai: I'll take it one step farther, I'll sum up the message ids so we know we are cooking with fire
07:49:32 <dcoutts> mwc: I'm not sure what that's referring to exactly. There's Saizan's hbuild, and there's shake/openshake
07:49:33 <elliott> mwc: not shake?
07:49:40 <elliott> shake got finally released recently
07:49:42 <mwc> Saw a conference presentation on it a while ago, DSL for make-like tasks.
07:49:43 <_Mikey> in do notation is there a way to just leave the function? like return in imperative languages?
07:49:46 <mwc> Ah yeah, Shake, that was it
07:49:52 <dcoutts> elliott: sort of, reimplemented
07:50:03 <koeien> _Mikey: no.
07:50:19 <koeien> _Mikey: that would depend on the monad.
07:50:20 <dcoutts> mwc: and there's a really old tool called hmake which does what it sounds like it should
07:50:26 <koeien> _Mikey: in general, no
07:50:38 <_Mikey> koeien: aww how unfortunate, I don't think I'm in a monad.
07:50:44 <Jedai> _Mikey: no, well you can have an exception and certain other monads (other than IO) are short-circuiting, but not like return in imperative land
07:50:48 <koeien> _Mikey: I think you are. :)
07:51:00 <Jedai> _Mikey: do-notation only work in a monad...
07:51:06 <elliott> dcoutts: right
07:51:10 <dcoutts> mwc: so yes, ideally in the future we'll take something like shake and use it in Cabal's simple build system, and provide a way to add in extra custom stuff
07:51:11 <_Mikey> ahh ok
07:51:20 <_Mikey> eventually it would come out in an IO monad.
07:51:38 <_Mikey> but the function itself doesn't return an IO anything.
07:51:39 <koeien> _Mikey: in IO there is no way to do what you want. only exceptions
07:51:56 <Jedai> _Mikey: but you can do an if then else with the then branch returning a result immediately
07:51:57 <mwc> Seems like shake's DSL for would be an ideal host for Cabal's build logic
07:52:04 <koeien> _Mikey: why not ... -> Either a b  then?
07:52:10 <koeien> or ... -> Maybe a
07:52:18 <dcoutts> mwc: yes, something like it. As is it's not suitable, but it's not too far off.
07:52:23 <mwc> has that nice feature of a system built up as a tower of little languages
07:52:27 <johnsingleton> Jedai: ya, it's working
07:52:28 <_Mikey> ahh I'm  sure I can work around it ... Either could work.
07:52:37 <johnsingleton> Jedai: I get a reasonable looking sum
07:52:42 <Jedai> _Mikey: That would be exactly what you want, in imperative land you would probably not have put the rest of the code in the else-branch, that's all
07:52:45 <johnsingleton> that's just crazy town
07:53:17 <johnsingleton> I'm tempted to redo this in Java just so I can do an annoying blog post about it ;)
07:53:56 <_Mikey> johnsingleton, where's your blog?
07:54:13 <Jedai> johnsingleton: I'm pretty sure you can do it fast in Java too, though probably not as concise
07:54:21 <johnsingleton> _Mikey: http://www.the-singleton.com -- but I don't have a lot of stuff up
07:55:02 <_Mikey> Very cool.
07:55:22 <_Mikey> I might have to steal the line "Bad ass Engineer" when I get done with being a student.
07:55:24 <dcoutts> mwc: one thing that makes it harder is that your build DSL needs to be pretty complete, because for the Cabal use case it's not a single-project build system you're writing, but a kind of meta-build system, you need to be able to write in the build DSL a program that reads the .cabal file, discovers other stuff by looking at local files and then does the right thing
07:55:54 <mwc> dcoutts: yeah. Shake is primarily focused on Haskell at the moment, not replacing Make?
07:56:06 <johnsingleton> _Mikey: heheh -- just punch a few people in the face and you won't have to self-apply the title ;)
07:56:20 <dcoutts> mwc: no it is replacing make
07:56:35 <quicksilver> oooh ndm got permission to open source it?
07:56:41 <quicksilver> when did that happen. excellent news
07:56:54 <dcoutts> mwc: the current incarnation of shake requires you to write quite a bit about the thing you're building, rather than being able to write a general build prog in the shake DSL that discovers everything about the project by reading files etc
07:57:06 <dcoutts> quicksilver: no, he reimplemented it
07:57:15 <mwc> oh is that what precipitated its release? I stopped paying attention when it looked like it would be in license hell forever
07:57:18 <mwc> cool
07:57:36 <dcoutts> it is in license hell forever, but he wrote a new implementation
07:57:47 <quicksilver> shame, but excellent
07:57:49 <quicksilver> resprectively
07:57:49 <dcoutts> so the old one can stay in license hell for evermore
07:58:05 <mwc> how did that situation happen?
07:58:10 <mwc> employer?
07:58:12 <dcoutts> corporations
07:59:17 <_Mikey> license hell :(
08:05:07 <johnsingleton> Saizan: What exactly is the behavior of unsafeInterleaveIO? I'm reading the doc but I'm not sure what the import of it is… "allows IO computation to be deferred lazily. When passed a value of type IO a, the IO will only be performed when the value of the a is demanded. This is used to implement lazy file reading, see hGetContents." -- how does that impact file handle closes?
08:05:18 <mauke> ChristianS: I changed the link
08:05:45 <Baughn> Is there a correct way of using Map.fromlistWith?
08:06:00 <Baughn> I really can't tell why this program is using unbounded memory..
08:07:36 <Jedai> johnsingleton: Well it doesn't impact handle closes, it impacts handle open (in your case)
08:07:39 <Baughn> http://hpaste.org/57585 <- This program, that is
08:07:53 <Jedai> *opneing
08:08:16 <ChristianS> mauke: got it, thanks!
08:08:49 <johnsingleton> Jedai: well, I got into trouble with my first pass, because I was doing just straight lazy io, and during the fold step it ran out of file handles...
08:08:54 <Jedai> johnsingleton: Basically (I didn't read your program), without the unsafeInterleaveIO, all your files would be open together, then read one by one
08:09:14 <johnsingleton> Jedai: ahhhhh that makes sense why it works now
08:09:17 <Baughn> ..oh, wait. Of course. I get it - it's stacking min thunks.
08:09:34 * Baughn grumbles.
08:09:45 <johnsingleton> but interleaveIO pulls it when it is actually necessary
08:10:01 <johnsingleton> and once the contents have been read, it is free to close it
08:10:12 <johnsingleton> sweetness
08:10:17 <Jedai> johnsingleton: when you put the opening into unsafeInterleaveIO, the files _were not_ opened until you used the handle (you started to read it, and given that you read the whole file, the handle was closed before you needed to open the next to read its content
08:10:26 <Jedai> johnsingleton: Right :)
08:10:42 <johnsingleton> very cool
08:10:55 <johnsingleton> Jedai: I got that parser working, btw
08:11:12 <johnsingleton> apparently you can get nested elements just by chaining those .: expressions
08:11:37 <johnsingleton> mostly due to your (patient) help ;)
08:12:06 <Jedai> johnsingleton: Good, I sent you a "cleaned up" and working version for a good part of the stuff, but you weren't there anymore, good to hear you made it work :)
08:14:15 <johnsingleton> Jedai: lb delivered me the message when I logged back on ;)
08:15:33 <Jedai> johnsingleton: A bit late I guess ;)
08:16:53 <johnsingleton> new… though I have been keeping weird hours lately
08:17:00 <johnsingleton> *naw
08:20:06 <qpu_> :t arbitrary
08:20:07 <lambdabot> forall a. (Arbitrary a) => Gen a
08:20:35 <qpu_> :t generate
08:20:36 <lambdabot> Not in scope: `generate'
08:21:15 <yoaha> are there any more good guides for learning haskell? I'm particularily enjoying learnyouahaskell
08:21:33 <elliott> yoaha: LYAH is the best introductory resource
08:21:44 <elliott> probably the best resource full stop, really; there is also Real World Haskell, which some people read after LYAH
08:21:45 <srhb> yoaha: LYAH really puts you in a good position to just get at it afterwards. :)
08:21:45 <yoaha> aha
08:22:00 <elliott> it's also available free online; unfortunately it has some problems with libraries being updated since its publication
08:22:02 <yoaha> i will check out real world haskell
08:22:12 <elliott> so it's a bit out of date :(
08:22:18 <quicksilver> yeah I wish people would stop updating libraries :-/
08:22:22 <yoaha> it's quite a jump for me, but i really like the concepts and ideas thrown at me so far
08:22:29 <yoaha> i want to write something in it now !
08:22:30 <elliott> yoaha: but it's best to stick to LYAH all the way through before going on to something else, I'd say
08:22:59 <yoaha> i will do elliott
08:24:13 <hey_lu> yeah, I got a working ghc-7.4 + hp-2011.4 now (a few hours later... :)
08:25:11 <elliott> don't try and use haskell platforms with different major versions of ghc :/
08:26:08 <hey_lu> elliott: So I shouldn't use anything more recent that ghc-7.0.3? That's... weird.
08:26:39 <elliott> hey_lu: 2011.4 is for GHC 7.0.4.
08:26:56 <elliott> hey_lu: With GHCs of newer major versions, like 7.2 and 7.4, install cabal-install and just install what you need instead.
08:27:12 <elliott> HP is meant to be a "full stack" approach; mixing and matching components means you don't want the HP any more.
08:29:07 <hey_lu> elliott: okay, that makes more sense. :) but i won't do that now (as compiling/stitching together 2011.4 took several hours)
08:30:25 <johnsingleton> what options are available if I want to find substrings of a datatype like Data.ByteString.Lazy.Char8 -- isInfixOf doesn't seem to be available for it
08:31:41 <teurastaja> hey. im not a haskeller yet (still looking for a descent tutorial) but that is not the matter. for now im working in scheme im asking here because #math, #statistics and #math-software is unhelpful and i know you guys are uber-smart. so heres the problem: i wrote a sudoku generator that makes a complete grid in constant time. i want the pruning algorithm to sporadically test for uniqueness...
08:31:43 <teurastaja> ...using cnf encoding (unless you got something better)
08:32:14 <Jedai> johnsingleton: I'm pretty sure you have isInfixOf in ByteString (maybe not in this particular module) ?
08:32:22 <Jedai> ?ho isInfixOf
08:32:22 <lambdabot> Maybe you meant: hoogle hoogle+ do
08:32:24 <teurastaja> im having a hard time understanding sat-cnf papers
08:32:34 <Jedai> @hoogle isInfixOf
08:32:35 <lambdabot> Data.List isInfixOf :: Eq a => [a] -> [a] -> Bool
08:32:35 <lambdabot> Data.ByteString isInfixOf :: ByteString -> ByteString -> Bool
08:32:35 <lambdabot> Data.ByteString.Char8 isInfixOf :: ByteString -> ByteString -> Bool
08:32:57 <CodeWeaverX> Having written a sudoku solver before (which I could probably hijack into being a generator with some effort), I haven't the foggiest idea how you came up with a consistent one in constant time.  Nifty.  Wish I had an answer that didn't involve me doing the same googling you've probably already done.
08:33:35 <teurastaja> generating a sudoku in constant time is SOOOO easy
08:33:41 <CodeWeaverX> One with a unique solution?
08:33:54 <teurastaja> yes
08:33:55 <CodeWeaverX> Then you're way cleverer than me.  And I"m jealous. ;)
08:34:19 <Jedai> johnsingleton: apparently isInfixOf isn't available for lazy ByteString only for strict
08:34:23 <tgeeky> speaking of games, did anyone notice the *hugemongus* Go board in Tron : Legacy?
08:34:24 <quicksilver> well sudoku is a fixed size problem
08:34:32 <quicksilver> clearly all generators are constant time
08:34:35 <quicksilver> there's nothing to scale off.
08:34:41 <Baughn> Right, just check all the options
08:34:43 <jrslepak_> quicksilver: grid size?
08:34:44 <CodeWeaverX> Oh, well, fine.
08:34:51 <johnsingleton> Jedai: hurmmm
08:34:58 <quicksilver> if you change the grid size it's not sudoko any more
08:35:00 <CodeWeaverX> That would be the logical assumption is that n is either a side of the puzzle, or the number of cells.
08:35:01 <Baughn> jrslepak_: No generator would be constant time in grid-size. :P
08:35:13 <teurastaja> my generator is faster than any other one unless you can show me something faster
08:35:14 <jrslepak_> Baughn: of course not
08:35:18 <CodeWeaverX> In that sense my solver is constant time too.
08:35:28 <CodeWeaverX> I can claim that.  woot.
08:35:32 <jrslepak_> and so is every other one!
08:35:45 <quicksilver> teurastaja: anyhow, your question appears a bit off-topic. Let's stick to haskell please.
08:36:18 <teurastaja> yes. im not a haskeller, but all the smart people are here
08:36:18 <CodeWeaverX> I managed to rip through the 'big list' of 17-element sudokus getting each one down to the sub-10 second solution category, and very nearly all of them in fractions of a second, but it doesn't necessarily scale well with increased board size.
08:36:37 <tgeeky> http://www.lifein19x19.com/forum/download/file.php?id=612&sid=06b69da7eb732f57741b9e0952cc9c46
08:36:39 <johnsingleton> Jedai: is Data.ByteString strict? it seems to be defined there?
08:36:51 <Jedai> johnsingleton: You could use the stringsearch package, it's supposed to be very fast
08:37:19 <tgeeky> bah. that's a normal sized Go board. shows you what I know.
08:37:37 <Jedai> johnsingleton: Data.ByteString and Data.ByteString.Char8 are strict, the lazy variants have .Lazy in their name
08:37:49 <jrslepak_> teurastaja: if you want to talk about algorithms and not haskell, try #algorithms
08:37:53 <johnsingleton> Jedai: okay, let me try that
08:38:00 <elliott> teurastaja: #haskell-blah
08:38:01 <hey_lu> elliott: is there another tutorial/primer for conduit (i've glanced at the one from yesod)
08:38:17 <tgeeky> hey_lu: not yet
08:38:30 <teurastaja> yeah i tried those channels
08:38:40 <_Mikey> elliot: haskell-blah fell off.
08:38:47 <hey_lu> tgeeky: do you want to write one? ;)
08:39:14 <Jedai> johnsingleton: I would guess the isInfixOf was purposefully removed form the lazy variant (since lazy bytestring are mainly for streaming and isInfixOf may not be the friendliest operation for streaming (except if it's the only one you do)
08:39:28 <teurastaja> im fetching the code hold on
08:39:28 <elliott> hey_lu: I doubt it.
08:39:28 <elliott> _Mikey: Fell off?
08:39:37 <tgeeky> hey_lu: No, and you wouldn't want to read one if I did. :)
08:39:43 <_Mikey> elliott: isn't what it used to be
08:40:18 <elliott> _Mikey: What it is is the place for people in #haskell to talk about things that aren't Haskell. Since teurastaja said "im not a haskeller, but all the smart people are here", it seems like the most appropriate place.
08:40:19 <hey_lu> tgeeky: do you know conduit, though?
08:40:33 <Andrew___C> Is there a tool that can take a wxHaskell Main.hs and find out which dlls it depends on, or even nicer, makes a standalone installer?
08:40:34 <Andrew___C> I can't believe I'm the only person that wants to allow people to install a compiled windows binary without installing all the Haskell developer tools, but after googling for half an hour, I'm beginning to suspect I might be!
08:40:37 <mroman> http://codepad.org/WyniOVnu <- Has anybody an idea why this does not make the GtkButton red?
08:40:45 <johnsingleton> Jedai: argggg huge bummer. I have to use lazy strings because that's what Aeson gives me back… Data.ByteString.Lazy.Internal.ByteString
08:41:02 <Jedai> johnsingleton: Well use stringsearch, it's good
08:41:03 <tgeeky> hey_lu: nope
08:41:05 <mroman> It apparently has no effect.
08:41:14 <_Mikey> elliot: true. but not much smart goes on.
08:41:28 <mroman> And gt2hs apparently does not provide setters for styles.
08:41:39 <johnsingleton> Jedai: ok, cool, I'll give it a go
08:41:40 <johnsingleton> thanks!
08:41:43 <wern> which haskell data structure would you recommend for a hierarchy of stateful GUI widgets (of different kinds)?
08:41:48 <Cale> tgeeky: The oddly black border might have something to do with it. It does somehow feel larger than a wooden 19x19 board until you count it :)
08:41:49 <Jedai> johnsingleton: note that it's easy to convert between lazy and strict bytestring (though that's not always a good idea)
08:42:25 <tgeeky> Cale: yeah. I counted 18 squares on a side, and evidently "standard" go boards are 19x19. :/
08:42:32 <tgeeky> oh well. I enjoyed the movie. The costumes were beautiful
08:43:24 <quicksilver> tgeeky: a 19x19 go board does indeed have 18 squares on a side. go players count the intersections.
08:43:26 <elliott> _Mikey: That doesn't make #haskell more relevant.
08:43:32 <elliott> s/relevant/appropriate/
08:43:43 <Cale> Yeah, they are 19x19, but for some reason that struck me as maybe slightly larger than 19x19 on first glance, but it's not :)
08:43:45 <tgeeky> quicksilver: I gathered. For some reason, I found it difficult to count hte intersections
08:44:33 <Cale> It's missing the hoshi
08:44:41 <johnsingleton> Jedai: maybe this is a silly question, but is strict bs generally slower than lazy?
08:45:09 <Jedai> johnsingleton: Hmm from what I can see, aeson doesn't give back lazy bytestring apart if you especially demand it, in fact it use Text in intern (which is a good idea for a text based format)
08:45:13 <Cale> and normally the border of a goban isn't the same colour as the lines, but matches the background
08:45:30 <johnsingleton> switching from Lazy to Strict BS made my memory consumption 100x
08:45:41 <Jedai> johnsingleton: No, since lazy bs are just a pseudo list of stict bs chunks
08:46:08 <johnsingleton> I went from 78 M of memory -> 783M
08:46:11 <johnsingleton> !!!!!!
08:46:14 <hey_lu> does ghc-7.4 compile faster than 7.0.3? (or am i imagining that?)
08:47:09 <johnsingleton> oh I know why ;)
08:47:13 <Jedai> I don't really understand what you're doing, aeson doesn't gives you lazy bytestring, it only take them in input (since it's better for streaming, memory problem as you discovered)
08:47:39 <Andrew___C> Does anyone have experience of deploying a Haskell application as a standalone executable?
08:47:55 <elliott> hey_lu: I've imagined that too.
08:48:00 <elliott> It might be placebo.
08:48:15 <johnsingleton> Jedai, nm, comma in the wrong place ;)
08:48:32 <Jedai> Andrew___C: That shouldn't be too hard given that everything is statically linked by default (on the Haskell side, on the C side you have to be more cautious)
08:49:36 <Andrew___C> Jedai: it uses wxHaskell which is dynamically linked, I tried statically linking but failed
08:50:09 <Jedai> Andrew___C: Right, the C stuff is more problematic (though probably not much worse than deployment of C apps
08:50:29 <Andrew___C> Jedai: since still loads of dlls are missing. Can I find out which dlls it uses somehow, and where they are?
08:51:35 <Cale> Andrew___C: I'm not sure on windows how to get a list of DLLs which a program uses, but I know that you can deploy them in the same directory as the program and it'll find them.
08:52:11 <Cale> You'll be looking for the Windows equivalent of the ldd command on linux
08:52:21 <Andrew___C> Jedai: (as far as I know everything's LGPL so OK) The dlls just need to be somewhere on the user's %path%
08:53:57 <Andrew___C> Cale: googling ldd windows port perhaps optimistically!
08:55:07 <nand`> Jedai: sometimes that's not enough. I don't know what causes it, but apparently some programs refuse to find .dlls inside the %path%, and require it to be in the local directory instead
08:55:30 <Andrew___C> Cale: http://dependencywalker.com/ seems what I need.
08:55:30 <nand`> for example, the Haskell bindings for SDL on Windows require the sdl .dlls to be in the same directory as the compiled .exe
08:56:06 <nand`> and my last comment was @ Andrew___C as well
08:56:32 * hackagebot JuicyPixels 1.1 - Picture loading/serialization (in png, jpeg and bitmap)  http://hackage.haskell.org/package/JuicyPixels-1.1 (VincentBerthoux)
08:56:49 <ion> PNG *and* bitmap? :-P
08:57:04 <Andrew___C> nand` : hmm - some dlls didn't load from the same dir - only loaded when I put them in %system32%/andrews.dlls
09:00:56 <Jedai> ion: maybe it means png and bmp
09:03:08 <Jedai> johnsingleton: Note that if you ask it ByteString, aeson will gives you bytestrings, but if you have text (names, and so on) and not binary data, you should really ask for Data.Text values instead
09:04:42 <Andrew___C> Cale, Jedai, nand` : Thanks very much for your help. I'm off home to do some dll digging with DependencyWalker.
09:05:09 <johnsingleton> Jedai: I eventually figured that out ;)
09:05:15 <johnsingleton> my mistake
09:05:28 <Taneb> Why is "join" called such?
09:05:34 <johnsingleton> it just wants to DECODE a lazy one
09:05:50 <johnsingleton> but it will put the lazy or strict version into the data type
09:05:54 <quicksilver> Taneb: history?
09:06:11 <Cale> Taneb: Well, look at what it does in many cases, and it makes sense
09:06:21 <mekeor> Taneb / quicksilver: what's join ? (i only know join from missingH..)
09:06:34 <mekeor> @hoogle join
09:06:35 <lambdabot> Control.Monad join :: Monad m => m (m a) -> m a
09:06:35 <lambdabot> package join
09:06:35 <lambdabot> System.FilePath.Windows joinDrive :: FilePath -> FilePath -> FilePath
09:06:40 <quicksilver> :t join
09:06:43 <lambdabot> forall (m :: * -> *) a. (Monad m) => m (m a) -> m a
09:06:52 <Cale> Taneb: probably the simplest example to understand the name from is lists
09:07:02 <Taneb> Oh, I see
09:07:05 <quicksilver> in category theory it's normally called "the multiplication"
09:07:06 <Taneb> I was thinking upside down
09:07:07 <Cale> join takes a list of lists and concatenates them into a single list :)
09:07:09 <Cale> yeah
09:07:16 <quicksilver> I don't know when/where it got the name 'join/
09:07:17 <mekeor> > join (putStrLn (putStrLn "foo"))
09:07:18 <Taneb> I thought it was m a -> m (m a)
09:07:18 <lambdabot>   Couldn't match expected type `GHC.Base.String'
09:07:19 <lambdabot>         against inferred typ...
09:07:21 <Jedai> johnsingleton: yeah and if you're handling textual data you sould really use Text rather than ByteStrings (Text is the unicode friendly, text oriented couterpart of ByteString)
09:07:34 <quicksilver> which mostly makes sense with a data structure view, I guess.
09:08:00 <quicksilver> although if you squint, join :: (r -> r -> a) -> (r -> a) is like joining two paths in a dataflow picture?
09:08:03 <Jedai> johnsingleton: And aeson decodes JSON string into Text anyway, so it's probably not more costly to ask it for Text data
09:08:09 <matthiasgorgens> Can you give instance definitions local to a function?
09:08:15 <elliott> Taneb: that's comonad's duplicate :)
09:08:17 <johnsingleton> Jedai: I plan to do a lot of string matching on the data, if that makes a difference?
09:08:31 <elliott> johnsingleton: ByteString is for raw binary data, Text is for strings
09:08:48 <elliott> ByteString is unfortunately-named, it's not a string at all
09:08:50 <yshavit> I was reading through Real World Haskell yesterday, and one of the exercises is to compute the mean of a list of Nums. I can think of two approaches: one computes the sum, then the length, then divides them; the other folds the list into a (sum, length) tuple and then does the division at the end. The first requires two passes, the second creates a tuple per item. Is one of them obviously better?
09:09:13 <elliott> yshavit: The latter is better, because it's GC-friendly.
09:09:25 <yshavit> elliott: ok, thanks.
09:09:26 <elliott> yshavit: Consider trying to sum a huge list: with the fold, it can be freed as you go along it.
09:09:34 <johnsingleton> elliot / Jedai: Noted!
09:09:38 <elliott> yshavit: But with the sum and length thing, the whole list has to be kept in memory, because you're keeping it around to go over it again later.
09:09:44 <mekeor> > let mean l = sum l / length l in mean [1..100]
09:09:45 <lambdabot>   No instance for (GHC.Real.Fractional GHC.Types.Int)
09:09:45 <lambdabot>    arising from a use o...
09:09:50 <quicksilver> interestingly "join" doesnt' appear to appear in [Benton,Hughes,Moggi]
09:10:06 <Jedai> elliott: well it's a string of btes, not a string of characters :) The only problem is we see "String" and we think "text"(note that older language have type called "string" that are just bytestrings)
09:10:32 <yshavit> elliott: oh, interesting! I was thinking about GC from the standpoint of each tuple being short-lived, forgot that the list itself can be freed as it goes.
09:10:47 <Jedai> yshavit: be very careful with strictness though
09:10:48 <yshavit> elliott: for doing that, would you want a foldl? or would a foldr also work?
09:11:08 <yshavit> Jedai: in that I want it to be strict, right? or no?
09:11:14 <Jedai> yshavit: that's a classic case where you may accumulate big thunks
09:11:17 <ion> > let toAvg a = (Sum a, Sum 1); avg (Sum a, Sum n) = a / fromInteger n in avg (Data.Foldable.foldMap toAvg [5,15] `mappend` Data.Foldable.foldMap toAvg [10,20])
09:11:18 <lambdabot>   12.5
09:11:37 <yshavit> Jedai: that's what I thought. So I'd want a strict foldl?
09:11:40 <elliott> yshavit: You never want foldl.
09:11:42 <elliott> You want foldl' or foldr.
09:11:49 <elliott> yshavit: But, be careful again: foldl' isn't enough.
09:11:56 <elliott> It'll force the tuple, but you need to force the elements inside.
09:11:58 <nand`> What's the easiest way to create a simple CLI interface, sort of like ncmpcpp, in Haskell?
09:12:00 <Jedai> yshavit: Yes, you want it to be strict, so you need to use foldl' and be explicitly strict in the components of your pair (or use a strict pair) or else...
09:12:03 <nand`> Planning to write a clone
09:12:16 <yshavit> elliott, Jedai : ah, gotcha.
09:12:30 <elliott> yshavit: bang patterns help there
09:12:38 <elliott> foldl' (\(!acc,!len) n -> ...)
09:12:42 <quicksilver> nand`: that's not command line, that's curses?
09:12:57 <nand`> yeah, by CLI I just meant “text-based”
09:13:02 <quicksilver> nand`: have a look at http://hackage.haskell.org/package/vty-4.7.0.6 which is intended to be good for that kind of thing
09:13:06 <nand`> I've never used curses so I don't know if it's the right tool
09:13:07 <quicksilver> nand`: (disclaimer I've never used it :)
09:13:20 <nand`> I'll have a look at it, thanks
09:13:40 <nand`> Don't need anything more complex than a list + status bar
09:13:50 <Taneb> Hmm...
09:13:55 <yshavit> elliott: does it matter if it's foldl' (\(!acc,!len) n -> (acc+n, len+1))  or foldl' (\(acc,len) n -> (!(acc+n), !(len+1))) ?
09:14:06 <elliott> yshavit: Yes, considering the former isn't valid syntax.
09:14:06 <Taneb> You could use Maybe () for boolean logic, if you were so inclined
09:14:21 <yshavit> elliott: oh. well then.
09:14:23 <Taneb> And = (>>), Or = mplus
09:14:25 <elliott> yshavit: ((,) $! (acc+n)) $! (len+1) would work, but is rather... ugly.
09:14:45 <yshavit> elliott: okay. I think I haven't come across the bang notation yet... just $!.
09:14:47 <matthiasgorgens> can you give instance definitons for classes locally?
09:14:48 <elliott> Erm
09:14:52 <elliott> yshavit: sorry! the _latter_ is invalid syntax
09:15:01 <elliott> the former is valid.
09:15:02 <elliott> oops.
09:15:08 <Taneb> Not =... maybe ((Just ()) (const Nothing)?
09:15:10 <yshavit> elliott: ha, I'd read "latter". Two wrongs made a right. :)
09:15:23 <elliott> yshavit: (\(!acc,!len) n -> ...) is the same as (\(acc,len) n -> acc `seq` len `seq` ...)
09:15:31 <elliott> if you don't know seq, know that f $! x = x `seq` f x
09:15:33 <Jedai> yshavit: bang pattern is just for patterns (so arguments or case match), ($!) is an operator (Haskell 98, no extension, unlike bang patterns)
09:15:37 <ion> Three lefts make two wrongs
09:15:38 <elliott> and so a `seq` b = const a $! b
09:15:47 <yshavit> elliott: okay, gotcha.
09:15:59 <elliott> @remember ion Three lefts make two wrongs
09:16:00 <lambdabot> Done.
09:16:45 <Taneb> @pl maybe (Just ()) (const Nothing)
09:16:45 <lambdabot> maybe (Just ()) (const Nothing)
09:16:53 <yshavit> elliott, Jedai : I'm guessing the answer is no, but is there a way to do a "deep strict" evaluation?
09:17:09 <ion> @pl \maybe just const nothing -> maybe (just ()) (const nothing)
09:17:09 <lambdabot> ((.) .) . (. ($ ()))
09:17:15 <Jedai> yshavit: Yes, but only if your datatype is an instance of NFData
09:17:22 <yshavit> Jedai: ok
09:17:25 <ion> @unpl ((.) .) . (. ($ ())) maybe Just const Nothing
09:17:26 <lambdabot> (\ j m b c -> maybe (Just (())) (\ g _ -> g) Nothing j m (b c))
09:17:32 <yshavit> Jedai: I'll hoogle that.
09:17:49 <Jedai> yshavit: and you very rarely want to do that (it's pretty slow most of the time, since you revisit everything, including what has already be forced)
09:17:51 <ion> I quite like both versions.
09:17:59 <quicksilver> also the Control.Parallel.Stragies library has combinators for expressing "degrees of strictness"
09:18:12 <quicksilver> which are designed for parallel computation but actually would be handy for cases like this
09:18:29 <Jedai> quicksilver: good idea ! :D
09:19:21 <yshavit> quicksilver: ah, neat. Looking it up now.
09:20:02 <elliott> yshavit: With the deepseq packages, yes.
09:20:09 <elliott> yshavit: But it's usually not a good idea.
09:20:44 <elliott> yshavit: In basically all cases, you can be as strict as you need with purely "local" things like seqs on arguments or individual elements.
09:21:23 <yshavit> elliott: that makes sense -- the (!acc, !len) foldl' being a good example.
09:22:02 <elliott> Parallel computation is one of those exceptions, since you need to control the division of evaluation more explicitly.
09:26:04 <scooty-puff> are there any utility functions maybe i'm overlooking in hoopl that let you take two transfer functions, and join (not in the lattice sense) them such that you have a single transfer function producing the product of the facts?
09:30:18 <quicksilver> scooty-puff: probably more of a #ghc question
09:30:26 <quicksilver> not many people familiar with the hoopl api
09:30:31 <scooty-puff> k
09:30:32 <scooty-puff> thanks
09:30:37 <scooty-puff> #ghc on freenode?
09:30:59 <scooty-puff> nm, found it (yes)
09:31:34 <nand`> The main documentation consists of the haddock-comments and the demonstration
09:31:37 <nand`> program
09:31:47 <nand`> Don't you always love reading that?
09:32:26 <elliott> Haddocks are more useful than most manuals.
09:35:57 <navaati> BAAAAH CABAL IS SHIT CABAL IS SHIT CABAL IS SHIT
09:36:08 <navaati> i'm on a box with 512Mo of RAM and for packages with tests, the *configure* phase (actually the linking of Setup.hs) fills my RAM and make my pc freeze
09:36:16 <navaati> what the hell do i do now ?
09:36:28 <funktronic> navaati: get mroe RAM
09:36:42 <navaati> …
09:36:49 <roconnor> get more swap?
09:36:53 <dcoutts> navaati: the problem is the linking
09:36:53 <navaati> done
09:36:57 <mightybyte> navaati: Complain to the ld people
09:37:22 <elliott> navaati: use gold
09:37:29 <elliott> and buy more ram
09:37:43 <navaati> but f*ck, how can a linking phase take 400Mo of RAM oO ?
09:37:58 <dcoutts> navaati: ghc makes .a lib files with 10,000 little .o files (see libHSbase.a), this makes ld very unhappy. When you only have 1/2 GB then it pushes you into an OOM situation.
09:38:16 <navaati> ah
09:38:24 <dcoutts> navaati: if you really want to build on a machine with 512Mb ram, you can make a special build of ghc with SplitObjs=NO
09:38:42 <navaati> and to build GHC, I… :D
09:38:43 <dcoutts> but it's probably easier to build on another machine and deploy to the machine with less ram
09:39:16 <nand`> quicksilver: unfortunately I can't seem to make heads nor tails of Graphics.Vty
09:39:47 <navaati> i don't have any other i686 machine… all the others are 64 bits…
09:40:17 <navaati> seems like i'm pwnd
09:40:40 <maurer> navaati: Have you tried using gold?
09:40:46 <elliott> navaati: You can run 32-bit GHC on 64-bit machines.
09:40:47 <dcoutts> navaati: it's usually not too hard to set up a 32bit chroot on a 64bit linux box
09:41:06 <navaati> gold ?
09:41:19 <maurer> navaati: It is an alternate linker that is more memory efficient (among other things) than ld
09:41:32 <maurer> It may already be installed as ld.gold on your system
09:41:33 * hackagebot lax 0.1.0.3 - Lax arrows  http://hackage.haskell.org/package/lax-0.1.0.3 (WolfgangJeltsch)
09:41:39 <navaati> ah, i thought it was related to 'buy more ram' ><
09:41:47 <elliott> lol
09:42:01 <navaati> i'll check this, thanks
09:42:11 <JoeyA> In the comment to fixIO, it says "just in case it ends up being executed multiple times" in reference to: unsafeInterleaveIO (takeMVar m)
09:42:23 <JoeyA> Under what circumstances would the takeMVar m be duplicated?
09:42:29 <CodeWeaverX> baaaaaaaack
09:43:47 <jeff_s_> How do I get the GHC profiler to show me the execution times for all function calls, not just the ones in my executable's code?
09:44:07 <jeff_s_> I know it will be huge, I don't care. I need to find what parts of what libraries is causing problems.
09:44:25 <c_wraith> it does that by default.
09:44:42 <jeff_s_> Hm
09:45:18 <c_wraith> When something builds in profiling mode, it uses profiling versions of every haskell library it links to
09:45:27 <navaati> jeff_s_: but you need the profiling version of every lib you use
09:45:46 <elliott> c_wraith: It doesn't make SCCs for library functions, does it?
09:46:04 <Saizan> jeff_s_, c_wraith: the prof. versions of the libs aren't built with -auto-all by default, that's the problem
09:46:25 <c_wraith> blame the library authors, then. cabal gives you the tools to do that.
09:46:33 * hackagebot type-equality-check 0.0.0.3 - Type equality check  http://hackage.haskell.org/package/type-equality-check-0.0.0.3 (WolfgangJeltsch)
09:46:36 * hackagebot cereal-conduit 0.0.2 - Turn Data.Serialize Gets and Puts into Sources and Sinks  http://hackage.haskell.org/package/cereal-conduit-0.0.2 (MylesMaxfield)
09:46:38 <jeff_s_> Oh my gosh... I take it I have to change ~/.cabal/config to include that option?
09:46:52 <Saizan> jeff_s_: ghc lists cost-centres, -auto-all when building the lib will add them
09:47:07 <dcoutts> thing is, in general you don't want -auto-all in every lib
09:47:12 <dcoutts> which is why cabal doesn't do it
09:47:13 <jeff_s_> OK this is making sense to me
09:47:25 <dcoutts> but we could certainly do with a better UI for selecting which libs you do want SCCs in
09:47:36 <jeff_s_> I'll find out how to add that flag when bulding a library
09:47:41 <c_wraith> dcoutts: I've never not wanted -auto-all when profiling...
09:47:41 <elliott> c_wraith: I would not be happy if a library added SCCs to my profiling output without asking!
09:47:51 <elliott> c_wraith: -auto-all /on the libraries you use/
09:47:54 <dcoutts> c_wraith: you want it in the lib you are profiling, not all of its dependencies
09:48:04 <c_wraith> elliott: you wouldn't want to know where the time is being spent?
09:48:06 <dcoutts> or sometimes one or two specific dependencies
09:48:23 <elliott> c_wraith: I don't want a kajillion-trillion line file where my hotspot is drowned under a bunch of micro-rubbish, no.
09:48:35 <elliott> c_wraith: Also, I cannot fix performance problems in other peoples' libraries, so I do not care what they call.
09:48:41 <jeff_s_> A UI could abstract that all away.
09:48:43 <elliott> I only want to know which part of *my* code needs fixing.
09:48:43 <jeff_s_> It would be great.
09:49:54 <c_wraith> I have no trouble changing other libs.  If I'm profiling I want to know what's slow.
09:50:04 <c_wraith> I don't care if it's my code or not.
09:50:56 <elliott> c_wraith: If your code calls slow code in other libraries, profiling only your library will show you that.
09:51:20 <c_wraith> But it won't give me the slightest hint how to fix it.  I've run into this in the real world.
09:51:26 <jeff_s_> That doesn't help you fix that library, though.
09:51:40 <elliott> That's why you can put manual SCCs.
09:51:50 <elliott> Just pepper the subexpressions of your identified hot-spot with them.
09:51:54 <c_wraith> -auto-all fixed it, with much less work.
09:52:01 <jeff_s_> elliott - That is way too much effort.
09:52:07 <elliott> c_wraith: I very much doubt you have ever rebuilt all your dependencies with -auto-all.
09:52:16 <elliott> None of us are suggesting not to use -auto-all on your library.
09:52:28 <elliott> That's standard.
09:53:35 <c_wraith> I've certainly added -auto-all to other libraries that didn't have it in order to track down what part of them was making my code slow
09:53:51 <c_wraith> Would have been much simpler if they'd just started with it.
09:54:10 <dcoutts> c_wraith: but that's the thing, you want to add it selectively, not to every single lib
09:54:23 <dcoutts> note that base is not built with -auto-all (I think)
09:54:32 <jeff_s_> c_wraith - do you remember what cabal flag you used to add -auto-all to the compiler options, or did you add it in your .cabal/config file?
09:54:35 <jeff_s_> (or other?)
09:54:43 <c_wraith> Just add it to the cabal file in question
09:54:57 <jeff_s_> ok, easy enough
09:55:02 <jeff_s_> not ideal though
09:56:36 * hackagebot cereal-conduit 0.0.3 - Turn Data.Serialize Gets and Puts into Sources and Sinks  http://hackage.haskell.org/package/cereal-conduit-0.0.3 (MylesMaxfield)
09:57:18 <mightybyte> Is there any reason why there isn't something like this in the standard libraries?  https://gist.github.com/7da393563a2af5f6d072
09:57:39 <elliott> mightybyte: Because (Maybe Int) is not a number?
09:57:42 <elliott> *numeric type
09:58:02 <elliott> mightybyte: Anyway, see http://hackage.haskell.org/package/applicative-numbers
09:58:21 <mightybyte> It's really convenient
09:58:47 <elliott> mightybyte: IMO it's a symptom of wanting something like idiom brackets.
09:59:06 <elliott> It's a bit of an abuse of the typeclass mechanism to get automatic lifting.
09:59:15 <mightybyte> True
10:00:19 <elliott> mightybyte: For instance, if (m1 + m2) has the behaviour it does, why doesn't (m1 == m2)?
10:00:20 <nand`> ew, UI.NCurses doesn't provide a monad transformer for Curses
10:00:28 <nand`> I have to wrap it inside IO
10:00:35 <nand`> unless there's a better way
10:01:38 <elliott> nand`: I suggest not using that library.
10:01:42 <elliott> There are better curses libraries, IIRC.
10:01:46 <elliott> And vty, of course.
10:01:47 <nand`> elliott: for example?
10:01:54 <nand`> And I don't know how to use Vty to achieve what I want
10:02:31 <elliott> nand`: http://hackage.haskell.org/package/hscurses
10:02:31 <mightybyte> elliott: Good point, but in this case it makes sense because you can think of the notion of comparison as returning a Bool by definition.
10:03:04 <nand`> elliott: fails to compile due to the Num changes for me, didn't want to go through the hassle of fixing it for such a simple project
10:03:05 <elliott> mightybyte: Sure, it makes sense, it's just not obvious :P
10:03:30 <mightybyte> Well, that's not a good argument against it.
10:04:21 <mightybyte> In fact, I might argue that these semantics mean that Nothing has essentially the same behavior as NaN.
10:04:45 <elliott> mightybyte: Difficulty of reading isn't a good argument? Whether you can use "automatic lifting" instances basically depends entirely on the implementation details of the operation in question.
10:04:53 <elliott> It has to be in a typeclass, with a polymorphic result.
10:05:09 <elliott> At least with idiom brackets it's consistent -- (| m1 + m2 |) and (| m1 == m2 |) both do the lifting.
10:05:29 <nand`> apparently UI.NCurses also makes my terminal unable to draw text after it returns
10:05:36 <nand`> maybe I will haev to use hscurses after all
10:05:36 <mightybyte> Oh, I'm not arguing for it over something like idiom brackets.
10:05:40 <nand`> how do I fix it again?
10:05:48 <mightybyte> I actually had not heard of them until now.
10:06:29 <elliott> mightybyte: she implements them, if you're willing to play with not-fully-polished tools :P
10:06:39 <elliott> there's also a horrible typeclass hack to implement them but we don't talk about that. (and it doesn't work with infix)
10:06:53 <elliott> mightybyte: idiom brackets were actually introduced at the same time as applicatives I think (originally called "idioms")
10:07:06 <elliott> I think they may have even been the motivating notation for it
10:08:34 <djanatyn> I saw something interesting using record syntax a while ago.
10:08:57 <djanatyn> There were two different places that were the same type, and they had one type signature for them instead of the same type signature on two different lines.
10:09:01 <djanatyn> how do you do that?
10:09:45 <mightybyte> elliott: she?
10:10:04 <dolio> Strathclyde Haskell Enhancement.
10:10:18 <mightybyte> Hah
10:10:20 <albel727> now that was unexpected.
10:10:29 <noam> djanatyn: f, g :: a -> b ?
10:10:29 <Saizan> djanatyn: data R = R { f1 , f2 :: T } ?
10:10:41 <elliott> See, this is why you carefully construct sentences so that she appears in the appropriate place.
10:10:45 <elliott> Rampant confusion.
10:11:00 <albel727> heh
10:11:05 <mightybyte> Yes, very nice
10:12:09 <djanatyn> noam: that's what I wanted, thanks!
10:12:48 <byorgey> that's what SHE said
10:24:28 <mightybyte> @remember byorgey that's what SHE said
10:24:28 <lambdabot> Nice!
10:24:55 <elliott> That's a bit devoid of context :P
10:24:59 <mightybyte> elliott: At least you can't respond with lmgtfy on that one. :)
10:25:26 <mightybyte> Oh, don't worry.
10:25:55 <CodeWeaverX> I have a giant chewy cookie and a giant mug of coffee, and writing haskell.  Life is reasonably good.
10:26:59 <byorgey> elliott: that's what... never mind
10:27:14 <saml> > let f w h w' h' = if w'/h' > w/h then (h'*w/h, h') else (w', w'*h/w)  in f 20.0 40.0 2.0 0.5
10:27:15 <lambdabot>   (0.25,0.5)
10:27:26 <saml> is there a way to express that without if-else?
10:27:41 <CodeWeaverX> newton's method?
10:27:43 <CodeWeaverX> *peers*
10:27:50 <saml> one expression involving w h w'  h' ?
10:27:53 <saml> i mean, mathematical expression
10:28:44 <elliott> if' (w'/h' > w/h) (h'*w/h, h') (w', w'*h/w)
10:28:45 <byorgey> saml: (min (h'*w/h) w', min (w'*h/w) h') ?
10:29:18 <hpc> saml: let bool = {0, 1}
10:29:21 <CodeWeaverX> Ah, working out a scaling factor for width and height ratios.
10:29:38 <hpc> saml: if b then t else f = (b * t) + (not b * f)
10:29:40 <byorgey> > let f w h w' h' = (min (h'*w/h) w', min (w'*h/w) h') in f 20.0 40.0 2.0 0.5
10:29:41 <lambdabot>   (0.25,0.5)
10:29:49 <saml> byorgey, that doesn't eally test properly
10:29:56 <hpc> come up with a mathematical definition of not, and you're done
10:29:57 <saml> oh hrm..
10:30:04 <byorgey> ok, I wasn't sure if it was the same
10:30:18 <saml> how does min (h'*w/h) w'   work..
10:30:24 * saml takes out paper
10:30:58 <saml> byorgey, how did you get it so quickly? intuition?
10:31:14 <CodeWeaverX> nott = (1-)
10:31:15 <byorgey> yeah
10:31:33 <byorgey> @check \w h w' h' -> let f w h w' h' = if w'/h' > w/h then (h'*w/h, h') else (w', w'*h/w); f w h w' h' = (min (h'*w/h) w', min (w'*h/w) h') in f w h w' h' == f' w h w' h'
10:31:35 <lambdabot>   Not in scope: `f''
10:31:54 <byorgey> @check \w h w' h' -> let f w h w' h' = if w'/h' > w/h then (h'*w/h, h') else (w', w'*h/w); f' w h w' h' = (min (h'*w/h) w', min (w'*h/w) h') in f w h w' h' == f' w h w' h'
10:31:56 <lambdabot>   "Falsifiable, after 0 tests:\n3.0\n-0.5\n-3.0\n-1.25\n"
10:32:18 <byorgey> @check \(Positive w) (Positive h) (Positive w') (Positive h') -> let f w h w' h' = if w'/h' > w/h then (h'*w/h, h') else (w', w'*h/w); f' w h w' h' = (min (h'*w/h) w', min (w'*h/w) h') in f w h w' h' == f' w h w' h'
10:32:19 <lambdabot>   Not in scope: data constructor `Positive'Not in scope: data constructor `Po...
10:32:41 <saml> is that quiccheck?
10:32:51 <CodeWeaverX> I really do have to learn how to use quickcheck
10:32:52 <byorgey> yes
10:33:09 <byorgey> it passes 100 random tests here in my ghci
10:33:23 <byorgey> if you restrict it to positive widths and heights (which seems reasonable?)
10:33:53 <nand`> How do I use HSCurses to generate a menu that I can scroll through with the arrow keys?
10:34:11 <nand`> actually nvm I'll just handle the drawing code myself
10:34:39 <byorgey> saml: basically because you always want to make the adjustment which makes things *smaller*, it just computes both possible adjustments to width or height to make the ratio match, and takes the smaller of each
10:34:42 <gwern> preflex: seen chrisdone
10:34:43 <preflex>  chrisdone was last seen on #haskell 9 days, 7 hours, 24 minutes and 12 seconds ago, saying: dzhus: sounds like you're trying to parse it into the wrong type?
10:35:07 <gwern> preflex: @ask chrisdone re http://chrisdone.com/posts/2012-02-07-nice-shell.html don't bash_completion, zsh, or fish do things very similar?
10:35:07 <preflex>  Consider it noted.
10:35:11 <byorgey> saml: I mean, it compares the old width and adjusted width, and takes the smaller one, and same for the height
10:35:13 <gwern> preflex: @flush
10:36:09 <byorgey> saml: wait, now I am confused too, I don't believe myself anymore
10:37:18 <byorgey> oh, yes I do =)
10:37:36 <mjga> gwern: did you consider security implications of such automation?
10:37:55 <gwern> mjga: fortunately preflex doesn't run on my system
10:38:20 <byorgey> if w'/h' > w/h then it means w' is "too big", relatively speaking, and you then adjust w' so it has the same ratio to h' as w has to h, which is going to make w' smaller
10:38:32 <byorgey> otherwise h' is too big and you adjust h' which makes it smaller.
10:40:01 <mkscrg> does anybody here know about using hpc with test suites?
10:40:42 <mjga> gwern: I meant security implications of "nicer shell". that's why Ubuntu just _suggests_ packages when you enter command and it is not found...
10:41:15 <gwern> mjga: but that's not what he is talking about
10:41:27 <deech> hi all, is there a pre-existing method for removing a directory even if it has files? "removeDirectory" fails if the directory contains files and a hoogle search didn't turn up anything.
10:43:10 <xil> hello everyone. Question about associated types. Why do associated types have to have a non empty subset of the class variables? As per this following hpaste
10:43:15 <hpaste> xil pasted “associated types” at http://hpaste.org/57591
10:44:49 <mekeor> @pl \x -> [-x,x] -- can i write that like that at all?   i mean, is "-x" valid?
10:44:49 <lambdabot> (line 1, column 7):
10:44:49 <lambdabot> unexpected "["
10:44:49 <lambdabot> expecting lambda abstraction or expression
10:45:01 <byorgey> xil: because when 'Sig' or 'Wei' show up in a type somewhere, the compiler has to be able to figure out what instance to pick
10:45:03 <parcs`> does 'm >>= \x -> x `seq` return x` === `m >>= evaluate` ?
10:45:15 <mekeor> > let f x = [-x,x] in f 5
10:45:16 <lambdabot>   [-5,5]
10:45:36 <mekeor> @pl \x -> [-x,x] -- does @pl not understand lists?
10:45:36 <lambdabot> (line 1, column 7):
10:45:36 <lambdabot> unexpected "["
10:45:36 <lambdabot> expecting lambda abstraction or expression
10:45:41 <xil> byorgey: isn't that defined by the instance declaration? Let me fix up the paste
10:46:30 <byorgey> xil: no, I mean if you have a function in some other module whose type is  Wei -> Int,  the compiler has to resolve Wei to some type, which depends on the instance of MyNet chosen
10:46:36 <byorgey> but it has no way to know which instance to choose.
10:46:40 <elliott> mjga: what automation?
10:46:49 <elliott> oh
10:47:05 <mauke> gwern: preflex has no flush :-)
10:47:17 <mjga> elliott: chrisdone suggested shell in haskell, with automatic downloading of wrappers and completions when command is first used...
10:47:48 <elliott> mjga: just sandbox things. if you're selecting things based on input and output, then what's downloaded probably doesn't have to access anything but input and output
10:47:53 <byorgey> xil: what exactly are you trying to accomplish?  From that paste it looks to me like you should just make 'net' a parameter of Sig and Wei
10:47:59 <elliott> but, off-topic, so :P
10:48:02 <xil> byorgey: oh I see now, sort of. I don't see why that should happen because aren't the associated types limited to the class declaration, so how would they be in another module?
10:48:18 <byorgey> xil: no, they aren't limited to the class declaration.  They can be used anywhere.
10:48:40 <byorgey> xil: they are the same as type families, basically.
10:48:44 <xil> byorgey: I thought their scope was limited. Very well then, that explains it
10:48:46 <ion> (@remember elliott That's a bit devoid of context :P)
10:49:09 <xil> byorgey: yeah I figured this out from teh type families article on the haskell wiki, but I don't understand type families all that well is the thing
10:49:25 <xil> byorgey: but I understand now why I have to make net a parameter. I knew that but I was wondering why
10:50:24 <elliott>  @remember ion @remember elliott That's a bit devoid of context :P
10:51:11 <Eduard_Munteanu> p
10:51:17 <Eduard_Munteanu> Sorry.
10:51:56 <ion> q
10:51:59 <elliott> r
10:52:48 <Eduard_Munteanu> Nah, I was changing tabs, typed a p and somehow ended up pressing ctrl+m instead of ctrl+n :/
10:58:37 <tgeeky> Well, I think that explanation is just
10:58:39 <KorriX> hello everybody
10:58:39 <tgeeky> m
10:58:51 <tgeeky> KorriX: hello, one person in particular!
10:59:19 <KorriX> how to generate valid sha1 hash using Data.Digest.SHA... ?
10:59:20 <elliott> Hello, nobody.
10:59:38 <tgeeky> elliott: nobody said hello back! eek, run!
11:00:58 <mauke> KorriX: what package is that in?
11:01:47 <KorriX> Crypto
11:02:28 <mauke> KorriX: hash x
11:02:31 <kstt> hi haskell folks
11:02:46 <KorriX> but witch hash ?
11:02:54 <KorriX> in every submodule is hash
11:03:10 <applicative> hi kstt
11:03:12 <mauke> KorriX: Data.Digest.SHA1.hash
11:03:12 <tgeeky> KorriX: try it, and see if it works
11:03:13 <Eduard_Munteanu> KorriX: depends which module you import
11:03:15 <KorriX> and any of this hash functions generates sha1 like in postgres
11:03:16 <mauke> if you want sha1
11:03:36 <KorriX> SHA1.hash need another format of input data
11:03:41 <mauke> what do you mean by "another"?
11:03:47 <KorriX> [Word8]
11:03:58 <KorriX> i have [Char]
11:04:08 <mauke> you can't hash [Char]
11:04:09 <aib> following up on something earlier, what function is called to negate x when we do (-x) ?
11:04:13 <mauke> you have to convert it to bytes first
11:04:34 <ion> Data.Digest.Witch.hsh
11:05:12 <tgeeky> aib: negate
11:05:12 <ion> > (-x)
11:05:13 <lambdabot>   negate x
11:05:56 <KorriX> Digest.Witch ?
11:06:07 <KorriX> i don't have that
11:06:13 <aib> and which language feature maps (-x) to (negate x) ?
11:06:25 <ion> korrix: Ignore me, i was just making a pun about a typo.
11:06:33 <kstt> For a cpu intensive task, the bottleneck seems to be the multiplication of longish vectors of ints. Multiplication, as of zipWith (*). I'd like to improve performance. First things first, the vectors are unboxed. Now I think it could benefit from parallel computation, with a strategie of allocating large chunks to threads. Any experience or recommandation on that please ?
11:06:40 <tgeeky> aib: syntactic sugar
11:07:32 <aib> tgeeky: so I can't sugar up and overload my own functions or operators?
11:07:35 <tgeeky> aib: from http://www.haskell.org/onlinereport/exps.html <-- "Negation is the only prefix operator in haskell"
11:07:38 <ion> More like syntactic vinegar.
11:08:01 <tgeeky> aib: You can make whatever infix operators you like, I don't know if you can make prefix operators
11:08:17 <aib> tgeeky: well, "-" looks kinda like both.
11:08:24 <tgeeky> aib: and it is both
11:08:46 <Eduard_Munteanu> It's a special case, to say so.
11:08:59 <aib> I see
11:09:03 <tgeeky> aib: are you wanting to get rid of it?
11:09:09 <tgeeky> or do you have some motive in mind?
11:09:10 <aib> nah, not really. I was curious.
11:10:18 <tgeeky> aib: for further constrenation about (-), see http://hackage.haskell.org/trac/haskell-prime/wiki/NegativeSyntax
11:10:41 <aib> a single function (or operator or whatever) that could both be used as a unary and a binary operator (or a function with 1/2 parameters) would've shaken up my understanding of Haskell
11:10:56 <aib> which is pretty loose to begin with
11:11:03 <sipa> how about id?
11:11:14 <sipa> :t (id)
11:11:15 <lambdabot> forall a. a -> a
11:11:26 <sipa> :t (id :: a -> b -> (a -> b))
11:11:27 <lambdabot>     Occurs check: cannot construct the infinite type: a = b -> a -> b
11:11:27 <lambdabot>     In the expression: (id :: a -> b -> (a -> b))
11:11:39 <sipa> :t (id :: (a -> b) -> a -> b)
11:11:39 <jeltsch> I think I’ve recently seen on HackageDB an package that automatically generates from an ADT several new types that represent alternatives of that ADT.
11:11:40 <lambdabot> forall a b. (a -> b) -> a -> b
11:11:46 <Botje> aib: you can do variable-arguments functions with type classes
11:12:02 <elliott> (But don't.)
11:12:10 <jeltsch> For example, it would generate from the list type a type that only covers the empty list and a type of non-empty lists.
11:12:19 <elliott> kstt: you might be interested in repa.
11:12:22 <jeltsch> Does anyone know how this package is called?
11:12:32 <elliott> kstt: it's based on vector, and has automatically parallelisation
11:12:35 <elliott> *automatic parallelisation
11:12:40 <aib> sipa: let id = id. and as for a -> b -> (a -> b), it's a simple substitution for a->a, no?
11:13:11 <mauke> > id 2
11:13:12 <lambdabot>   2
11:13:15 <mauke> > sqrt `id` 2
11:13:17 <lambdabot>   1.4142135623730951
11:13:21 <sipa> aib: yes, but it can take two arguments
11:13:35 <ion> > id $ id sqrt `id` id 2
11:13:36 <lambdabot>   1.4142135623730951
11:13:49 <sipa> (or N)
11:14:12 <elliott> sipa: try to unify (a -> a) with (b -> (c -> (b -> c)))
11:14:21 <elliott> er, wait
11:14:27 <elliott> aib: your type is totally wrong
11:14:38 <elliott> (a -> b) -> a -> b unifies with a -> a
11:14:39 <sipa> it's (a -> b) -> a -> b
11:14:43 <elliott> but a -> b -> (a -> b) does not
11:14:55 <alistra> cannot create an infinite type b = (c -> (b -> c))
11:14:59 <aib> sorry, I was quoting sipa. must've chosen the wrong one
11:15:12 <aib> yeah, I chose the one with the error
11:16:48 <aib> I can still see how "id taking two arguments" fits the type rules. LTR association of -> and partial application, no?
11:17:46 <jeltsch> Ah, I found that package. It’s called yoko.
11:17:53 <saml> byorgey, lol
11:18:10 <saml> maybe min version is too smart
11:18:14 <saml> i'll just use if-else
11:23:53 <aib> s/LTR/RTL
11:24:09 <nand`> Anyone use HSCurses? “getCh” always returns \ESC for me if I press one of the arrow keys
11:24:51 <CodeWeaverX> nand':  I wouldn't be surprised if it returns a sequence of chars one after another, starting with esc.
11:25:01 <CodeWeaverX> maybe an 'escaped' multi-byte sequence.
11:25:25 <hpc> nand`: afaik arrow keys are several chars
11:25:31 <nand`> I see
11:25:41 <nand`> It's strange because there's a “KeyUp” which doesn't seem to do anything (but type checks)
11:25:49 <mauke> did you enable cbreak and keypad?
11:26:08 <nand`> I did nothing
11:26:29 <hpc> nand`: try pressing the arrow keys into cat
11:26:44 <hpc> to seewhat each arrow outputs
11:27:18 <mauke> nand`: cBreak True; echo False; keypad stdScr True
11:28:09 <mekeor> @pl \(x,_,_) -> x
11:28:10 <lambdabot> (line 1, column 6):
11:28:10 <lambdabot> unexpected ","
11:28:10 <lambdabot> expecting operator or ")"
11:28:10 <lambdabot> ambiguous use of a non associative operator
11:30:30 <aristid> mekeor: i think you'd need to go to hackage for that
11:30:38 <aristid> @hoogle (a,b,c) -> a
11:30:38 <lambdabot> Data.Typeable typeOf3 :: Typeable3 t => t a b c -> TypeRep
11:30:39 <lambdabot> Data.Typeable typeOf2Default :: (Typeable3 t, Typeable a) => t a b c -> TypeRep
11:30:51 <nand`> mauke: How do I use the stdScr properly? What I did until now was w <- initScr and using w everywhere
11:31:20 <hpc> nand`: ReaderT perhaps?
11:31:24 <nand`> but if I omit the initScr and replace every w by stdScr, the program simply terminates right away and afterwards my console is unusable (I have to close it and re-open)
11:31:31 <mekeor> aristid: i did it with lambda-expr... ty anyway. goodbye, agda-user
11:31:40 * hackagebot fb 0.7.1 - Bindings to Facebook's API.  http://hackage.haskell.org/package/fb-0.7.1 (FelipeLessa)
11:32:18 <nand`> hpc: good point, I'll use ReaderT
11:33:07 <mauke> nand`: don't omit initScr
11:33:19 <nand`> mauke: I just ignore the result then?
11:33:38 <nand`> same result then
11:33:44 <mauke> good question
11:35:04 <mauke> apparently initScr returns stdScr but the documentation doesn't explicitly say so
11:35:12 <mauke> :-|
11:35:54 <eviltwin_b> they assume you've read the C library docs
11:35:55 <mauke> I'mma write a test program
11:36:03 <mauke> eviltwin_b: I am reading the C docs
11:36:47 <hpc> sounds like typical C docs to me
11:37:37 <eviltwin_b> If errors occur, initscr writes an appropriate error message to standard error and exits; otherwise, a pointer is returned to stdscr.
11:38:15 <eviltwin_b> ...oh, this is the OS X docs.  ncurses docs probably suck
11:38:40 <eviltwin_b> (and I need to adjust manpath, I should have gotten ncurses docs from macports...)
11:39:27 <mauke> installing hscurses ...
11:46:13 <jrockway> asking for a friend... using data.binary, can a Get operation that fails fail in some way other than by calling "error"?
11:46:43 <jrockway> i see lookaheadM which is what we want, but I'm not sure how to get a parsing action that fails in the correct way
11:47:07 <elliott> using "fail"?
11:47:12 <elliott> it's in Monad, yannow
11:47:17 <elliott> yaknow. how do you even spell that?
11:47:47 <tgeeky> don'tchannow
11:47:57 <hpc> elliott: donchanow, but that's in canada-ese
11:48:02 <mauke> nand`: http://hpaste.org/57592 seems to work fine
11:48:48 <nand`> hmm
11:48:53 <nand`> I didn't have that finally call in there
11:49:21 <mauke> did you have endWin?
11:49:29 <nand`> I did, but as loop >> endWin
11:49:52 <mauke> what's the exit condition of your loop?
11:50:09 <nand`> well, it's handle (KeyChar 'q') = return ()
11:50:11 <nand`> but
11:50:15 <nand`> I was using ctrl+c to escape from the program
11:50:23 <nand`> that must be the reason why it broke
11:50:34 <mauke> yep
11:51:29 <statusfailed> Hmm, I want to profile my program, but I can't compile with -prof because the compiler can't find ByteString - I think that's because it needs to be compiled with -prof, too
11:51:40 * hackagebot hinduce-associations-apriori 0.0.0.0 - Apriori algorithm for association rule mining  http://hackage.haskell.org/package/hinduce-associations-apriori-0.0.0.0 (RobertHensing)
11:51:43 <statusfailed> should I recompile it, or is there an easier way?
11:51:49 <statusfailed> I just want to do heap profiling
11:52:14 <jrockway> elliott: right, ok
11:53:22 <Eduard_Munteanu> statusfailed: cabal install --reinstall -p   should help there, if you installed it with cabal install
11:53:32 <hash`> Hi. I'm trying to determine if a bytestring has accumulated enough bytes for a decode to work on it. Right now trying decode without enough bytes results in an exception.
11:53:38 <statusfailed> Eduard_Munteanu: cool, thanks
11:53:43 <nand`> hmm
11:54:09 <hash`> The end goal is to return a maybe that either decodes or returns nothing
11:54:21 <nand`> still breaks for me with `finally`, I'll try your test in a sec
11:54:33 <hpaste> nand` pasted “MPD Browser” at http://hpaste.org/57593
11:54:44 <nand`> Also how can I improve this program? Scrolling down or up causes the screen to flash
11:54:47 <nand`> since it redraws everything
11:54:49 <mauke> nand`: you're calling initScr twice
11:54:54 <Eduard_Munteanu> hash`: do you know how much you need?
11:55:10 <hash`> @Eduard_Munteanu I don't, so remainder doesn't help
11:55:11 <lambdabot> Unknown command, try @list
11:55:27 <hash`> Not in advance. It's variable length
11:55:51 <jrockway> elliott: i don't understand where i would get to control the implementation of fail.  getBytes is Int -> Get ByteString.  it calls fail, which is get's fail, which is "Get (error ...)"
11:55:54 <hash`> I'd like something that does a dry run.
11:56:06 <jrockway> hash`: i see your account works now :)
11:56:11 <Eduard_Munteanu> hash`: what library is that?
11:56:16 <hash`> Data.Binary
11:56:17 <Eduard_Munteanu> hash`: well, you could use 'spoon'
11:56:21 <Eduard_Munteanu> Oh.
11:56:53 <nand`> mauke: Where am I calling it twice
11:57:09 <mauke> nand`: lines 18, 19
11:57:09 <ion> cereal doesn’t have that fault, it returns a Maybe.
11:57:20 <nand`> the first is initCurses not initScr
11:57:29 <mauke> nand`: initCurses calls initScr
11:58:08 <jrockway> spoon is a good idea, but an evil solution to this problem, i think
11:58:12 <nand`> mauke: if I replace “w <- initScr” by “let w = stdScr” the program fails to work
11:58:19 <hash`> Spoon may work. I've already invested considerable time into Binary so I don't want to re-write it.
11:58:22 <nand`> produces no output, hangs up the terminal
11:58:24 <Eduard_Munteanu> hash`: I guess you probably shouldn't be using 'decode' if you can.
11:58:34 <mauke> nand`: does my test program work?
11:58:35 <Eduard_Munteanu> Or you can 'spoon' it, but that's not really nice.
11:58:47 <tgeeky> Eduard_Munteanu: that's George Bush's function. He's the decider.
11:58:54 <tgeeky> oh damn, decode, not decide!
11:59:03 <hash`> Ideally I would just feed data into this thing and anything waiting to read from it would stall. But I need a quick fix for a demo tomorrow
11:59:04 <Eduard_Munteanu> :)
11:59:12 <jrockway> Eduard_Munteanu: so... most Binary instances are written in terms of getBytes.  getBytes is what fails.
11:59:16 <Eduard_Munteanu> hash`: spoon it is then...
11:59:18 <Eduard_Munteanu> @hackage spoon
11:59:19 <lambdabot> http://hackage.haskell.org/package/spoon
11:59:22 <jrockway> it would be good to make the Get operation fail cleanly, so alternatives can be tried
11:59:28 <nand`> mauke: nope, same result
11:59:34 <jrockway> lookaheadM seems to exist for this purpose
11:59:43 <nand`> oh
11:59:46 <nand`> I figured out the cause
11:59:47 <nand`> it's runhaskell
11:59:51 <jrockway> but it seems you are on your own with respect to writing a Get action that returns Nothing or Just (or Left/Right)
11:59:52 <Eduard_Munteanu> Yeah, you can probably work around it using Data.Binary.Get stuff
12:00:02 <nand`> I was using runhaskell to test these, if I build it with ghc manually then run the binary it works
12:00:02 <hash`> The problem with lookAheadM is that it starts with a Maybe. I want it to become a maybe
12:00:25 <mauke> nand`: still works with runhaskell here
12:00:31 <mauke> weird
12:00:35 <nand`> definitely doesn't work with runhaskell for me
12:01:59 <nand`> doesn't matter
12:02:08 <hash`> Okay, spoon looks perfect. I'm going to try it in STM and see if it works.
12:03:27 <hpaste> nand` pasted “MPD Browser” at http://hpaste.org/57594
12:03:56 <nand`> Here's the current version, it still flickers because of the redrawing; any suggestions?
12:04:03 <jrockway> there's no way that using spoon is the correct solution to this problem
12:04:11 <jrockway> :)
12:09:10 <KorriX> any sha function form Crypto library doesn't work as i want
12:11:31 <mauke> KorriX: could it be that you have no idea what you're doing?
12:12:10 <KorriX> mauke: no :D
12:12:17 <KorriX> i had little mistake
12:12:30 <KorriX> i did not show hex digit
12:12:38 <KorriX> i had show chr x
12:12:59 <hash`> I had to use teaspoon, but it worked.
12:13:37 <ingiteflow> hi. haskell noob here coming from python. any advice on getting started?  I have learn yourself haskell, and the haskell road to logic, maths and programming
12:13:41 <hash`> My initial feeling is that it should be safe in STM. Does anyone disagree?
12:14:14 <DanBurton> ingiteflow: LYAH is a great way to go. Just install the Haskell Platform and you'll be well on your way to Haskell goodness
12:14:32 <ddarius> hash`: I disagree.
12:16:07 <hash`> What about short term? :)
12:16:43 <mauke> KorriX: http://hpaste.org/57595
12:16:47 <mauke> I wrote you a sha1sum
12:17:42 <hpaste> paf31 pasted “PolyKinds computation hangs” at http://hpaste.org/57596
12:20:35 <hpaste> paf31 annotated “PolyKinds computation hangs” with “PolyKinds computation hangs (annotation)” at http://hpaste.org/57596#a57597
12:21:17 <paf31> Can someone please help me to understand why this PolyKinds code http://hpaste.org/57596 hangs, but the second version does not?
12:21:41 * hackagebot certificate 1.1.0 - Certificates and Key Reader/Writer  http://hackage.haskell.org/package/certificate-1.1.0 (VincentHanquez)
12:21:43 <paf31> Replacing the pair newtype with a Church-encoded pair seems to solve the problem.
12:22:20 <elliott> probably a bug
12:22:23 <paf31> perhaps this is nothing to do with polykinds specifically
12:22:57 <paf31> in any case, setting a breakpoint, it looks as if the fold function is being evaluated in full before being applied
12:25:15 <elliott> well, probably not a bug
12:25:19 <elliott> but if it's related to polykinds it might be
12:25:27 <elliott> paf31: note that newtype is strict
12:25:33 <elliott> i.e. NewtypeCons _|_ = _|_
12:26:31 <paf31> hmm
12:26:42 * hackagebot tls 0.9.0 - TLS/SSL protocol native implementation (Server and Client)  http://hackage.haskell.org/package/tls-0.9.0 (VincentHanquez)
12:26:44 * hackagebot tls-extra 0.4.3 - TLS extra default values and helpers  http://hackage.haskell.org/package/tls-extra-0.4.3 (VincentHanquez)
12:28:06 <clarkg> Is there any way to get a file to be copied into /dist somewhere during a cabal build? I want to be able to run my program and have it "just work", even if it has data files it depends on.
12:28:59 <paf31> elliott: perhaps im missing something, but replacing the newtype with a data decl does not fix the issue
12:29:34 <elliott> well, i didn't read the code :)
12:29:37 <elliott> it was just a thought
12:29:42 <paf31> i need to do a bit of reading regarding what it means for a constructor to be strict :)
12:29:45 <elliott> maybe you need an irrefutable pattern
12:31:52 <mauke> clarkg: related? http://neilmitchell.blogspot.com/2008/02/adding-data-files-using-cabal.html
12:38:00 <nand`> hmm
12:40:46 <nand`> how do I get the size of a window?
12:40:54 <nand`> (in HSCurses)
12:41:10 <clarkg> mauke: Related, but doesn't work. I still can't run the executable right out of dist. I have to install it first.
12:41:21 <nand`> I need to add “take width” so that wAddStr never overflows into the next line
12:41:43 <mauke> nand`: 'take' is wrong
12:41:46 <clarkg> like, it still doesn't put the files beside the executable in dist.
12:41:52 <mauke> nand`: you want screen width, not character count
12:42:19 <nand`> mauke: but my font is monospace
12:42:34 <nand`> so the screen width should always be a certain # of characters
12:42:46 <mauke> nand`: wrong
12:43:04 <nand`> are you talking about invisible Unicode characters and stuff
12:43:22 <mauke> n̈ is two characters (width = 1), Ｑ is one character (width = 2)
12:43:48 <nand`> “n is two characters” huh
12:44:01 <nand`> and Ｑ shows with width 1 here
12:44:03 <mauke> oh, your terminal fails at rendering n-umlaut?
12:44:14 <nand`> ñ
12:44:16 <nand`> you mean that?
12:44:22 <mauke> no, that's n-tilde
12:44:45 <nand`> also how come n-umlaut isn't a single unicode code page
12:44:56 <Botje> *codepoint
12:44:58 <elliott> *codepoint
12:45:00 <nand`> point yes
12:45:06 <mauke> because no one uses it
12:45:07 <elliott> There is a single codepoint for it, and a combiner form, I believe.
12:45:14 <elliott> Oh, wait.
12:45:16 <Botje> probably because it's a combining umlaut + regular n
12:45:20 <elliott> Of course there's not one for n-umlaut.
12:45:25 <elliott> (How do you even pronounce that?)
12:45:31 <nand`> hmm, that's unfortunate
12:45:39 <mauke> nand`: scrSize
12:45:43 <ion> n̈
12:45:55 <elliott> anyway
12:45:55 <nand`> mauke: what do I use instead of take then?
12:45:59 <elliott> iirc ncurses can't even do unicode
12:46:03 <blackdog> is there an easy way to mirror hackage?
12:46:04 <elliott> but i may be wrong
12:46:04 <statusfailed> soooooo I wrote an ARFF parser with attoparsec, but there's already an arff package. Should I still put it on hackage?
12:46:06 <nand`> Is there some sort of UTF-capable take that treats combining forms are one character?
12:46:12 <Clint> elliott: it has to be compiled with wide char support
12:46:12 <nand`> elliott: it does for me
12:46:19 <elliott> blackdog: see "getting the raw data", http://hackage.haskell.org/packages/hackage.html
12:46:21 <ion> Isn’t that the very point of libncursesw?
12:46:47 <mauke> nand`: there's http://hackage.haskell.org/packages/archive/wcwidth/0.0.2/doc/html/Data-Char-WCWidth.html
12:46:58 <mauke> > wcwidth 'x'
12:46:59 <lambdabot>   Not in scope: `wcwidth'
12:47:00 <mauke> aww
12:47:10 <ion> water closet width
12:47:16 <blackdog> elliott: can you just put that on an HTTP server and fake out DNS?
12:47:19 <nand`> hmm
12:47:45 <blackdog> (i'm going to a rails camp in a remote corner of new zealand, and it'd be good to be able to have people just install haskell stuff easily. gotta fight the good fight :)
12:48:26 <blackdog> ah, nvm: http://bitcheese.net/wiki/howto/setup-hackage-mirror
12:48:27 <elliott> blackdog: dunno... I think the hackage stuff is on hackage itself (heh), and there's that yackage thing
12:49:15 <ion> which is maintained by The Royal Kilted Yaksmen.
12:49:17 <elliott> "However, this is an exception for hackage.haskell.org, added and maintained by some moron." cheerful :P
12:49:23 <blackdog> heh
12:49:27 <blackdog> well, i'm gonna fake DNS anyway
12:50:24 <blackdog> it's a weird setup there - they basically fake out the world.
12:53:26 <nand`> hmm, seems my solution is not perfect yet
12:53:41 <nand`> japanese kana still results in strings that are too wide
12:54:12 <hpaste> nand` pasted “wide take” at http://hpaste.org/57600
12:54:40 <nand`> ah, wait
12:54:42 <nand`> better idea
12:55:11 <hpaste> nand` annotated “wide take” with “wide take (annotation)” at http://hpaste.org/57600#a57601
12:55:13 <nand`> works now
12:56:28 <mauke> that looks broken
13:02:08 <parcs`> is there a cpp definition that contains the version numbers of the compiler?
13:02:25 <nand`> how do I change the colors using HSCurses? I see all of the Color methods but it's missing the obvious setForeground :: Color -> IO ()
13:02:38 <mauke> nand`: fails on takew 1 "ツ o hai"
13:03:57 <ddarius> nand`: That function sounds like the worst possible interface that could conceivably work.
13:05:56 <akosch> anyone familiar with hxt? I'm looking to drop elements which have the attribute "style". A bit like hasAttr from XmlArrow, just the opposite.
13:08:30 <hpaste> nand` annotated “wide take” with “wide take (annotation) (annotation)” at http://hpaste.org/57600#a57602
13:08:35 <nand`> mauke: should work now
13:08:42 <nand`> (and produce "" in this case)
13:09:25 <akosch> I'm not sure how to negate isA
13:09:32 <mauke> nand`: takew n _ | n <= 0 = []
13:09:58 <nand`> mauke: that will be undesired behavior
13:10:02 <mauke> no
13:10:14 <nand`> let me test it
13:11:38 <nand`> mauke: with your definition takew 1 "ツ o hai" fails as well
13:11:51 <mauke> nand`: how does it fail?
13:12:01 <nand`> produces "\12484"
13:12:13 <nand`> should be ""
13:12:49 <nand`> (the point of takew is to ensure the print won't overflow, thus it should be limited to a maximum character length on-screen)
13:13:06 <nand`> so if there's a two-wide character exactly on the edge, and I choose to include it, it will overflow
13:13:28 <mauke> nand`: http://hpaste.org/57605 then
13:14:20 <nand`> basically what I pasted
13:14:42 <nand`> oh in my paste I forgot to replace (n - wcwidth x) by n' as well
13:15:36 <mauke> nand`: ah, then your line 2 is redundant
13:15:54 <nand`> it is
13:16:15 <hpaste> nand` annotated “wide take” with “wide take (annotation) (annotation) (annotation)” at http://hpaste.org/57600#a57606
13:18:38 <nand`> I still need an answer to  nand` │ how do I change the colors using HSCurses? I see all of the Color methods but it's missing the obvious setForeground :: Color -> IO ()
13:19:10 <nand`> or, for that matter, a wAddStrEx :: Window -> Color -> Color -> String -> IO ()
13:19:58 <elliott> http://hackage.haskell.org/packages/archive/hscurses/1.4.1.0/doc/html/UI-HSCurses-Curses.html#g:10?
13:20:04 <elliott> initPair/initColor etc.
13:20:29 <nand`> elliott: that's what I'm staring at right now
13:20:29 <mauke> nand`: attrSet
13:20:30 <eviltwin_b> those create color "attributes", they don't apply them
13:21:22 <nand`> hmm
13:21:35 <nand`> seems I will need to slap a ReaderT (Pair, Pair, Pair) around my program
13:26:06 <nand`> or not, I can just use wAttrOn stdScr 262144
13:36:45 * hackagebot ParserFunction 0.0.6 - Utilities for parsing and evaluating mathematical expressions.  http://hackage.haskell.org/package/ParserFunction-0.0.6 (EnzoHaussecker)
13:41:47 * hackagebot happstack-server 6.5.7 - Web related tools and services.  http://hackage.haskell.org/package/happstack-server-6.5.7 (JeremyShaw)
13:41:49 * hackagebot fb-persistent 0.1 - Provides Persistent instances to Facebook types.  http://hackage.haskell.org/package/fb-persistent-0.1 (FelipeLessa)
13:56:48 * hackagebot memscript 0.0.2.0 - Command line utility for memorizing scriptures or any other text  http://hackage.haskell.org/package/memscript-0.0.2.0 (KiYungAhn)
14:00:52 <gatlin> Hi, all. I'm relatively new to Haskell and so I decided to write a SAT solver just to kick the tires, so to speak. I'm curious as to whether or not there is anything particularly naïve about my code.
14:01:19 <gatlin> I don't know any professional Haskell devs or I'd have bothered them first.
14:01:28 <hpc> @where hpaste
14:01:28 <lambdabot> http://hpaste.org/
14:01:34 <hpc> ^ paste and we will read
14:01:34 <gatlin> https://gist.github.com/1755736
14:01:34 <otters> aw crap
14:01:40 <hpc> or that
14:01:47 <otters> @src Data.List.sequence
14:01:47 <lambdabot> Source not found. I've seen penguins that can type better than that.
14:01:52 <otters> okay
14:01:57 <otters> @src sequence
14:01:58 <lambdabot> sequence []     = return []
14:01:58 <lambdabot> sequence (x:xs) = do v <- x; vs <- sequence xs; return (v:vs)
14:01:58 <lambdabot> -- OR: sequence = foldr (liftM2 (:)) (return [])
14:02:34 <hpc> gatlin: in the definition of dpll, i would do
14:02:48 <hpc> dpl s | condition = ...
14:02:55 <hpc>       | condition = ...
14:02:57 <hpc> ...
14:03:01 <elliott> gatlin: empty is null
14:03:07 <hpc> where theStuffYouHadInTheLetIn
14:03:20 <elliott> gatlin: it's probably better to use explicit pattern-matching throughout: i.e. completely avoid using head/tail and null
14:03:22 <hpc> lemme paste
14:03:38 <elliott> right now, if I just switch "empty f" to some other condition, I can get a runtime error, because your program assumes that the list is non-empty
14:03:53 <elliott> with pattern-matching, the "check" is integrated with the "access" part, so there's no such problems
14:04:10 <gatlin> Wow, I appreciate the helpful feedback. This code started life as a scheme program
14:04:16 <gatlin> which is probably rather obvious
14:04:22 <gatlin> so I'm trying to ween off those habits
14:04:50 <elliott> heh, it does look like a Scheme program now that you mention it :)
14:04:57 <hpc> gatlin: http://hpaste.org/57607 -- like this
14:05:20 <gatlin> hpc: that does look nicer
14:05:29 <elliott> gatlin: (and the last else is "| otherwise = ...")
14:05:54 <hpc> @src otherwise
14:05:54 <lambdabot> otherwise = True
14:06:26 <gatlin> so, where is let preferred over where?
14:06:41 <ddarius> No.
14:06:44 <hpc> gatlin: the nested 'let...in' declarations you can safely put in the where block, too
14:06:54 <hpc> probably
14:06:58 <elliott> gatlin: I always use where when I can, but in hpc's case you must
14:07:04 <elliott> because where clauses are declaration-level
14:07:08 <elliott> and you have multiple clauses
14:07:10 <ddarius> Er, where is usually always preferred.
14:07:11 <elliott> so there's no place for the let...in to go
14:07:22 <hpc> where clauses interact nicely with guards
14:07:59 <ddarius> gatlin: Your code make me cry.
14:08:02 <ddarius> +s
14:08:16 <hpc> i personally prefer let-in, just so i can see where things go
14:08:24 <elliott> See... WHERE things go
14:08:29 <elliott> HAHAHAHAHAHAHAhem.
14:08:29 <hpc> lawl
14:08:32 <gatlin> :)
14:08:44 <gatlin> ddarius: I'm legitimately going to put that on my website next to my resume
14:09:01 <hpc> @src null
14:09:01 <lambdabot> null []     = True
14:09:01 <lambdabot> null (_:_)  = False
14:09:04 <hpc> ^ = empty
14:09:10 <ddarius> I'd think it would be hard to do that illegitimately.
14:09:20 <hpc> your definition of empty fails on infinite lists
14:09:20 <gatlin> well, my claim is legitimate
14:09:29 <hpc> hah!
14:09:44 <gatlin> I certainly hope nobody gives me an infinite formula
14:09:57 <gatlin> however, empty is about to get scrubbed
14:11:05 <hpc> gatlin: so yeah, to summarize: replace if-then-else with pattern matches and guards, and replace empty with null
14:11:07 * ddarius should endeavor to write a relatively idiomatic Haskell program that also looks like a relatively idiomatic C program but makes no sense as a C program and is completely meaningful as a Haskell program.
14:11:26 <ddarius> Then replace null with pattern matching.
14:11:32 <nand`> easiest way to format something into a certain template, with maximum width? I'm thinking of something like "%title%            (%length%)" where the title would get cut off/spaces added if necessary, to keep the whole thing at a certain width
14:11:39 <ddarius> Then replace those with higher order functinos.
14:11:49 <nand`> I guess I'll just write my own formatting function, just asking if there's some obvious way
14:12:45 <hpc> nand`: i bet you could do it with a parser lib
14:12:53 <nand`> seems like overkill
14:13:05 <hpc> true
14:13:07 <nand`> oh, note, the template isn't dynamic
14:13:14 <nand`> ie. it never changes
14:13:45 <elliott> hpc: and then remove the use of null entirely
14:13:53 <elliott> and combine it with the head/tails into pattern-matches :P
14:14:18 <elliott> gatlin: (note that it may be useful to replace functions that take the head of a list, expecting it to have already been deduced as non-empty, to return a "Maybe" value instead)
14:14:18 <elliott> e.g.
14:14:28 <elliott> foo :: [Int] -> Int; foo xs = head xs
14:14:29 <elliott> -->
14:14:31 <hpc> nand`: perhaps something with 'words'? or is whitespace important?
14:14:41 <elliott> foo :: [Int] -> Maybe Int; foo [] = Nothing; foo (x:_) = Just x
14:14:54 <elliott> you can then "cascade" a bunch of Maybes to pick the first Just
14:15:20 <gatlin> elliott: I'm going to take this one step at a time but at least what you're saying makes sense
14:15:42 <nand`> hpc: how will ‘words’ help me here?
14:16:23 <hpc> nand`: it...doesn't; i blame coffee ;)
14:16:43 <elliott> gatlin: yes, gradual program transformation is the best method :)
14:16:45 <hpc> ignore me
14:16:49 * hackagebot tuple-th 0.2.4 - Generate (non-recursive) utility functions for tuples of statically known size  http://hackage.haskell.org/package/tuple-th-0.2.4 (DanielSchuessler)
14:16:50 <elliott> far less potential for error than the alternatives
14:17:23 <statusfailed> Is there a nice way to manage package version numbers in a git repo?
14:17:52 <statusfailed> or to write cabal files
14:18:41 <tgeeky> statusfailed: not that I'm aware of. I would love one.
14:33:29 <McManiaC> is there a general "Num a, Factional b => a -> b" function?
14:33:35 <McManiaC> Fractional*
14:33:58 <McManiaC> only thing I see is fromIntegral, but that doesn't apply for all Num's
14:34:12 <mauke> McManiaC: I don't think such a function would make sense
14:34:23 <hey_lu> statusfailed: git tag? ;)
14:34:50 <elliott> What is the standard MIME type for Haskell?
14:35:02 <mauke> text/plain
14:35:19 <Jedai> McManiaC: realToFrac
14:35:28 <elliott> mauke: non-standard MIME type, rather
14:35:41 <Jedai> @type realToFrac
14:35:42 <lambdabot> forall a b. (Real a, Fractional b) => a -> b
14:35:50 <McManiaC> :S
14:35:54 <mauke> still text/plain :-|
14:36:09 <otk_> found an example of frequency tables, thats interesting
14:36:14 <dolio> What does the proposed function do on complex numbers?
14:36:17 <McManiaC> Jedai: thx, I knew it
14:36:24 <otk_> time to re-write my alg
14:36:39 <Jedai> dolio: Does it even work on them ?
14:36:42 <hey_lu> elliott: gedit uses something like text/x-haskellsrc
14:36:46 <Jedai> @instances-importing Complex
14:36:47 <lambdabot> Couldn't find class `Complex'. Try @instances-importing
14:36:47 <dolio> Complex numbers are Num.
14:36:51 <elliott> hey_lu: ew
14:37:05 <elliott> "Xsrc" is weird
14:37:14 <hey_lu> elliott: at least i've seen text/x-csrc...
14:37:30 <Jedai> dolio: yes but are they Real
14:37:39 <dolio> That wasn't what was asked for.
14:37:58 <mauke> text/x-* would be nice because I can rewrite that to text/plain transparently
14:38:24 <Jedai> dolio: Well ok but what would it meean for Complex to convert them into double or anything like that ?
14:38:36 <dolio> I have no idea what it would mean.
14:38:38 <dolio> That's the point.
14:40:29 <hey_lu> elliott: my /etc/mime.types has text/x-haskell and text/x-literate-haskell
14:40:38 <elliott> hey_lu: thanks
14:50:24 <td123> anyone running ghc 7.4.1 on i686?
14:51:09 <td123> just asking, cause I might have found a bug on i686 7.4.1 or at least the test case is wrong
14:59:34 <gienah> td123: I do
15:00:40 <JoeyA> Is it possible to configure cabal to ignore {-# OPTIONS_HADDOCK hide #-}, to make it easier to read the forbidden docs?
15:01:05 <dcoutts> it's not possible to get haddock to ignore that I think
15:01:06 <gienah> td123: oops no I don't I'm on amd64
15:01:24 <pVi> hey, can someone tell me what I'm doing wrong here: http://hastebin.com/yigiwuwaso.hs
15:01:24 <pVi> Couldn't match expected type `[b]' with actual type `[a0] -> [b0]'
15:03:30 <DanBurton> pVi: the problem is (func1 xs)
15:03:46 <DanBurton> pVi: you need to also pass "f" to the recursive call
15:04:51 <DanBurton> pVi: also, it's rather dangerous to use "head xs", because xs might be the empty list. Try pattern matching on the two-or-more-elements list like so: "func1 f (x:y:xs) = (f x y) : func1 f (y:xs)
15:05:05 <nand`> Any way to make HSCurses automatically redraw itself if it detects the dimensions changing, even while blocking getCh?
15:05:10 <pVi> ahh, thanks DanBurton
15:05:12 <pVi> very helpful!
15:05:15 <DanBurton> pVi: also, I've put : where you had ++, try to figure out why :)
15:05:28 <pVi> Doesn't that prepend?
15:05:33 <DanBurton> yes
15:05:34 <pVi> I know it's faster, but I want to append
15:05:39 <DanBurton> > 1 : [2,3,4]
15:05:40 <lambdabot>   [1,2,3,4]
15:05:50 <DanBurton> > [2,3,4] ++ [1]
15:05:52 <lambdabot>   [2,3,4,1]
15:06:01 <pVi> okay, so just swap em :)
15:06:01 <DanBurton> pVi: try that, then ^
15:06:02 <pVi> got it
15:06:15 <mauke> nand`: http://hackage.haskell.org/packages/archive/hscurses/1.4.1.0/doc/html/UI-HSCurses-CursesHelper.html#v:start ?
15:06:31 <DanBurton> pVi: but the problem is, "f" produces a single "b", not a "[b]"
15:06:48 <DanBurton> pVi: so surround it with [] if you want to ++
15:07:16 <pVi> DanBurton: Can I do func1 f (x:[]) to check if there's only one element left?
15:07:22 <mauke> yes
15:07:24 <DanBurton> pVi: sure.
15:07:28 <pVi> Great :)
15:07:31 <Axman6> you can also do func [x]
15:07:40 <Dashkal> Somewhat offtopic, but someone here may know: Is there a lambda calcalus expression that works as a generator (that is, expands infinitely during beta reduction).
15:08:04 <DanBurton> Dashkal: it's called "omega", I believe
15:08:05 <elliott> (\x -> x x) (\x -> x x)
15:08:13 <DanBurton> yep that
15:08:15 <elliott> oh, that doesn't expand
15:08:20 <Axman6> like (\x -> x x x) (\x -> x x x)?
15:08:24 <elliott> right
15:08:57 <teurastaja> ((lambda (f) (ff)) (lambda (g) gg))
15:09:03 <teurastaja> oops
15:09:10 <teurastaja> ((lambda (f) (f f)) (lambda (g) g g))
15:09:16 <teurastaja> im a schemer ;P
15:09:25 <DanBurton> <- Racketeer
15:09:27 <Axman6> that doesn't expand
15:09:43 <DanBurton> it depends on your definition of "expand"
15:09:43 <teurastaja> oops]
15:09:54 <teurastaja> ((lambda (f) (f f)) (lambda (g) (g g)))
15:10:03 <ivanm> DanBurton: you mean you engage in organise crime? :o
15:10:12 <teurastaja> thats the right version lol
15:10:45 <Axman6> but it doesn't meet my definition of expanding anyway. it diverges sure, but the expressions doesn't get any bigger
15:11:04 <Dashkal> I was thinking something akin to the GoL cannon.
15:11:18 <Dashkal> doesn't need to be self-replicating, just keep making the expression longer.
15:11:53 <DanBurton> iinm the expression must in some way be self-replicating, otherwise how could it expand *infinitely*?
15:13:04 <DanBurton> anyways, with "fix = omega omega" you can write infinite lists and such just fine in lambda calculus, as in Haskell
15:13:09 <teurastaja> lazy evaluation could do that
15:13:37 <Dashkal> something that produces a steady tail of identity expressions would qualify.  Infinite growth without self replication.
15:13:54 <teurastaja> streams?
15:13:55 <DanBurton> pVi: [x] is just syntactic sugar for (x:[]) -- thought I'd mention
15:14:01 <tomprince> Well, that would be partial self replication.
15:14:03 <DanBurton> even in pattern matching
15:14:26 <teurastaja> macros?
15:14:36 <pVi> yep, thanks Dan
15:14:37 <tomprince> The only way of expanding is by copying an argument.
15:15:02 <teurastaja> continuations?
15:16:37 <teurastaja> (call-with-current-continuation (lambda (continuation) continuation))]
15:16:41 <teurastaja> oops
15:16:50 <teurastaja> hit the enter key too soon
15:16:52 * hackagebot http-proxy 0.0.8 - A library for writing HTTP and HTTPS proxies  http://hackage.haskell.org/package/http-proxy-0.0.8 (ErikDeCastroLopo)
15:18:36 <CodeWeaverX> Hi teurastaja, how goes the sudoku?
15:19:30 <teurastaja> ((call-with-current-continuation (lambda (continuation) continuation)) (call-with-current-continuation (lambda (continuation) continuation)))
15:21:22 <teurastaja> the sudoku is steady because im working on a sudoku-transpose using vectors
15:21:41 <teurastaja> instead of converting to lists and back
15:23:10 <teurastaja> but im going to have to rewrite some code although i made backups i recall
15:23:22 <akosch> I have the following code and want to add a new root node instead of two tr-s at the top-level. How would I do that? http://hpaste.org/57610
15:25:21 <tazjin> I'm trying to escape a double quote in a string
15:25:31 <tazjin> which works, but the escaping backslash is also inside the string
15:25:38 <mauke> tazjin: what
15:26:00 <Axman6> "\\\n"?
15:26:19 <tazjin> Basically this: http://klaud.tazj.in/E0Cx
15:26:53 <akosch> tazjin: ghci calls show on your string
15:27:11 <Axman6> use putStrLn to avoid that
15:27:13 <akosch> tazjin: try printing it with putStrLn
15:28:21 <tazjin> Okay, now how do I do that inside a program? I need a string that looks like ["something"] for a CouchDB query, but I end up with "[\"something\"]" (including both  backslashes and double quotes)
15:29:15 <mauke> tazjin: no, you don't
15:29:26 <akosch> tazjin: if you write "[\"something\"]" that will be interpreted as [""
15:29:37 <akosch> ["something"]
15:30:14 <akosch> tazjin: ghci just calls show on the result of every expression, so it can display it (even on strings)
15:30:37 <tazjin> yeah, but my problem is occuring outside of GHCI
15:30:42 <mauke> tazjin: what problem?
15:30:54 <nand`> mauke: that looks like what I want, unfortunately if I use that then apparently scrSize no longer updates
15:30:54 <DanBurton> every expression that isn't an IO action has an implicit "print" wrapped around it in ghci, iinm
15:31:30 <DanBurton> in caleskell, it even wraps print around IO expressions
15:31:35 <DanBurton> > putStrLn "foo"
15:31:36 <lambdabot>   <IO ()>
15:31:40 <nand`> probably because it rewrites the handler for the screen resize event
15:32:19 <DanBurton> > getLine
15:32:20 <lambdabot>   <IO [Char]>
15:32:22 <tazjin> Okay, I get that ghci calls show on everything - but this is not occuring inside GHCI. I have two strings that are built like this: qek = "[\"" ++ "Something" ++ "\"]"
15:32:22 <akosch> tazjin: I think you might have a different problem with CouchDB, what are you trying to do?
15:32:39 <mauke> tazjin: what's the problem?
15:32:44 <elliott> tazjin: Are you calling print?
15:33:03 <DanBurton> tazjin: paste a small program at http://hpaste.org/new/haskell that illustrates your problem?
15:33:17 <tazjin> http://klaud.tazj.in/DzuY <- this is the code thats causing the problem
15:33:33 <tazjin> disregard the last line
15:33:35 <mauke> tazjin: what's the problem?
15:33:36 <mauke> tazjin: what's the problem?
15:34:01 <DanBurton> we need more context; there is no apparent problem in that code, it should work as you expect
15:34:06 <tazjin> the problem is that the outcome is not ["something"] but "[\"something\"]"
15:34:11 <mauke> tazjin: wrong
15:34:13 <akosch> tazjin: I think showJSON will escape your quotes with backslashes
15:34:15 <tazjin> No, not wrong
15:34:19 <mauke> tazjin: why do you think so?
15:34:34 <tazjin> Because it does that
15:34:41 <mauke> tazjin: what is "it" and what is "that"?
15:34:48 <Axman6> tazjin: sounds to me you're using print when you want to use putStrLn
15:35:19 <tazjin> Axman6: I want to use neither of the two because I'm not doing IO here
15:35:35 <DanBurton> ghci> putStrLn $ "[\"" ++ "foo" ++ "\"]" -- ghci says ["foo"], so there's something else going on
15:36:01 <mauke> tazjin: also, why do you keep pasting screenshots instead of a program that demonstrates the problem?
15:36:16 <akosch> DanBurton: I think he's encoding his string literal into JSON which should do the same escaping
15:36:19 <nand`> maybe his code is top secret
15:36:28 <tazjin> It's just very long.
15:36:30 <DanBurton> akosch: something like that would make sense
15:36:42 <mauke> tazjin: so make it shorter
15:36:46 <DanBurton> tazjin: make a small file and try to reproduce the problem with as little code as possible
15:36:56 <tazjin> Okay, wait a few minutes.
15:37:01 <DanBurton> k :)
15:37:15 <DanBurton> actually, I need to leave; I entrust tazjin to my fellow Haskellers
15:38:25 <hpaste> “José Romildo” pasted “Error compiling Annotation with ghc-7.4.1” at http://hpaste.org/57612
15:39:07 <romildo> When compiling Annotations with ghc-7.4.1, I am getting the error http://hpaste.org/57612. Any clues?
15:39:22 <romildo> Kind mis-match
15:43:58 <pVi> what's the point of the id function? (http://zvon.org/other/haskell/Outputprelude/id_f.html)
15:44:25 <mauke> what's the point of the 0 number?
15:44:39 <otters> to put after other digits
15:44:45 <otters> to imply multiplication by your radix
15:44:46 <mgsloan> when your computer is connected to the appropriate peripherals, id tends to launch nukes at the nearest superpower
15:44:53 <mauke> I said number, not digit
15:44:58 <otters> oh
15:45:07 <otters> :t const
15:45:08 <lambdabot> forall a b. a -> b -> a
15:45:13 <otters> hm, they're not really the same thing are they
15:45:20 <Axman6> :t ap id
15:45:21 <lambdabot> forall a b. ((a -> b) -> a) -> (a -> b) -> b
15:46:11 <pVi> So... I have no idea :P
15:46:20 <hey_lu> do you know what throws 'ParseError {errorContexts = ["Hexadecimal digit"], errorMessage = "Failed reading: satisfy"}'?
15:46:31 <arcatan> pVi: sometimes you need it. usually as a parameter for some higher order function or something.
15:46:48 <Axman6> pVi: it's very useful for making code smaller in certain places. it won't be obvious until you've used haskell more
15:46:52 * hackagebot Ebnf2ps 1.0.9 - Peter's Syntax Diagram Drawing Tool  http://hackage.haskell.org/package/Ebnf2ps-1.0.9 (PeterThiemann)
15:47:01 <hey_lu> maybe 42 id $ Just anything :)
15:47:15 <hpaste> tazjin pasted “String escape problem” at http://hpaste.org/57613
15:47:24 <tazjin> there it is
15:47:24 <Axman6> hey_lu: which is great when you forget fromMaybe exists ;)
15:47:30 <mgsloan> pvI: yup, id is a no-op.  Its type, a -> a, implies the only useful behavior possible, that is, directly returning its parameter
15:47:31 <otters> :t fromMaybe
15:47:32 <lambdabot> forall a. a -> Maybe a -> a
15:47:37 <otters> god I KNEW there was an alternative
15:47:39 <otters> so annoying
15:47:49 <otters> I've been using maybe val id ... myself :/
15:48:11 <mgsloan> wow, I've been using "maybe val id" a lot too
15:48:18 <pVi> hmm, I'm not sure I 100% get it. but thanks
15:48:39 <nand`> arcatan: I'd say “always” instead of “usually”
15:48:44 <elliott> pVi: The incredibly common ($) operator is defined as id.
15:48:45 <hey_lu> Axman6: heh, thanks. but it's not in Prelude :p
15:48:53 <elliott> Apart from that, it's used as a parameter to higher-order functions.
15:48:56 <elliott> For instance,
15:49:01 <elliott> > filter id [False,False,True,True,False]
15:49:02 <lambdabot>   [True,True]
15:49:15 <arcatan> nand`: I had some idea where else you could use it but it went away. but yeah.
15:49:17 <mgsloan> pVi - for clarity "no-op" is not a haskell term, but refers to the tradition in assembly languages of having a NOP instruction that does nothing, ie does not transform the processor's state
15:49:29 <pVi> got it elliott, thanks!
15:49:42 <nand`> id &&& Just $ 42
15:49:45 <nand`> > id &&& Just $ 42
15:49:45 <Axman6> mgsloan: sure it does, the PC gets incremented!
15:49:46 <lambdabot>   (42,Just 42)
15:49:57 <otters> :t id &&& Just
15:49:57 <lambdabot> forall b. b -> (b, Maybe b)
15:49:58 <mgsloan> Axman6 - arrrgh! fair point
15:50:00 <otters> haha, arrows
15:50:02 <otters> they're so weird
15:50:02 <Axman6> =)
15:50:07 <tazjin>  so what happens when I run http://hpaste.org/57613 is that it queries the CouchDB with the following request: (@ mauke )
15:50:12 <tazjin>   /ger10502/_design/reservations/_view/allByEmp?startkey=%22%5B%5C%22FirstName%20LastName%5C%22%2C%7B%7D%5D%22&endkey=%22%5B%5C%22FirstName%20LastName%5C%22%5D%22
15:50:27 <tazjin> if you decode this URL encoding it becomes: /ger10502/_design/reservations/_view/allByEmp?startkey="[\"FirstName LastName\",{}]"&endkey="[\"FirstName LastName\"]"
15:50:46 <tazjin> as you can see it says "[\" instead of just ["
15:50:48 <tazjin> and that is the problem.
15:52:33 <arcatan> pVi: zvon.org hasn't been updated for a long time. the docs under http://hackage.haskell.org/package/base/ are up-to-date, and you can search them with Hoogle http://www.haskell.org/hoogle/
15:52:54 <gatlin> for those of you who helped me earlier, https://gist.github.com/1755736 should be a bit more idiomatic now but I still seek advice from the Gurus.
15:52:56 <mauke> tazjin: that's because qsk is a String
15:53:12 <mauke> tazjin: and to represent a String in JSON it has to add " " and escape " \
15:53:48 <pVi> arcatan: Thanks for the info. Often I'm doing basic stuff that hasn't changed and they are sometimes clearer examples.
15:53:55 <jfischoff> anyone ever looked at the source for aeson's datatype generic implementation?
15:54:04 <tazjin> What can I do to fix that?
15:54:12 <mauke> tazjin: why did you make qsk a String?
15:54:24 <tazjin> What would you have used?
15:54:48 <mauke> tazjin: qsk = ["FirstName LastName"] -- maybe?
15:55:02 <ddarius> gatlin: Still crying.
15:55:22 <gatlin> ddarius: please halp
15:55:27 <ddarius> gatlin: Step 1.  Abolish all uses of null, head, tail, and length.
15:56:28 <tazjin> mauke: Wouldn't that make it a list of strings with one element?
15:56:37 <mauke> tazjin: yes
15:56:52 * hackagebot cabal-dev 0.9.1 - Manage sandboxed Haskell build environments  http://hackage.haskell.org/package/cabal-dev-0.9.1 (JonathanDaugherty)
15:56:53 <mauke> tazjin: isn't that what you want?
15:57:29 <tazjin> That depends on how that list would be represented in JSON, as a CouchDB query.
15:58:06 <mauke> well, check what showJSON does with it
15:58:16 <tazjin> Also, I still need to add ,{} in the endkey
15:58:20 <tazjin> lets see
15:59:10 <mauke> maybe JSArray [JSString "...", JSObject (toJSObject [] :: JSObject ())]
15:59:17 <mauke> I haven't used Text.JSON, though
15:59:23 <otters> @src sequence
15:59:24 <lambdabot> sequence []     = return []
15:59:24 <lambdabot> sequence (x:xs) = do v <- x; vs <- sequence xs; return (v:vs)
15:59:24 <lambdabot> -- OR: sequence = foldr (liftM2 (:)) (return [])
16:01:28 <magicman> > sequence [[1,2],[4,5],[7,8]]
16:01:29 <lambdabot>   [[1,4,7],[1,4,8],[1,5,7],[1,5,8],[2,4,7],[2,4,8],[2,5,7],[2,5,8]]
16:01:48 <otters> can you define modules to be loaded by default in .ghci
16:01:48 <pVi> Is there a way to pass a value to a list of functions and have it pass the value through each function, similar to foldr, but not exactly the same.
16:01:52 <pVi> the opposite of map, I guess.
16:02:08 <elliott> otters: Yes.
16:02:21 <elliott> pVi:
16:02:24 <otters> wait, is .ghci just evaluated by ghci when you launch?
16:02:39 <ddarius> > sequence [f, g, h] x
16:02:40 <elliott> > ($ 42) <$> [(+1), (*2)]
16:02:40 <lambdabot>   Ambiguous type variable `a' in the constraints:
16:02:40 <lambdabot>    `GHC.Show.Show a'
16:02:41 <lambdabot>      a...
16:02:41 <lambdabot>   [43,84]
16:02:51 <ddarius> > sequence [f, g, h] x :: Expr
16:02:52 <lambdabot>   Couldn't match expected type `SimpleReflect.Expr'
16:02:52 <lambdabot>         against inferred ...
16:02:59 <elliott> > sequence [f, g, h] x :: [Expr]
16:03:00 <ddarius> > sequence [f, g, h] x :: [Expr]
16:03:00 <lambdabot>   [f x,g x,h x]
16:03:01 <lambdabot>   [f x,g x,h x]
16:03:11 <pVi> whaatt?? this channell has a build in ghci. that's amazing :)
16:03:37 <magicman> > map ($x) [f,g,h]
16:03:38 <lambdabot>   Ambiguous type variable `b' in the constraints:
16:03:39 <lambdabot>    `GHC.Show.Show b'
16:03:39 <lambdabot>      a...
16:03:43 <magicman> > map ($x) [f,g,h] :: [Expr]
16:03:44 <lambdabot>   [f x,g x,h x]
16:03:48 <mwc> Oh, you missed Vixen's more wild and carefree days
16:04:05 <mauke> @nixon
16:04:05 <lambdabot> When the President does it, that means that it is not illegal.
16:04:37 <tazjin> mauke: Now I have startkey=["something"]&endkey=["something"] - but I still need the startkey to look like ["something", {}]
16:04:53 <mauke> tazjin: did you see my other suggestion?
16:05:19 <tazjin> Ah, I missed that. Let me try
16:13:19 <tazjin> mauke: qek = JSArray [JSString $ toJSString "something", JSObject (toJSObject [] )] finally worked. Thanks :]
16:13:37 <otters> ugh, I hate the json API
16:15:26 <otters> oh boy I love when make can't find my readline installation
16:17:12 <otters> damn you, homebrew
16:19:34 <mreh_> mmm homebrew beer
16:19:50 <ArchGT> ¡salud!
16:25:06 <hey_lu> where does ParseError come from (it's in parsec, but it's the wrong one...)
16:26:49 <gatlin> ddarius: I'm trying to get rid of the final vestiges of null, head, tail, length in my chooseUnit function … but I think I could be more intelligent by making unit (which should be called hasUnit) somehow either return False or the unit clause in question
16:26:54 <otters> hmm
16:26:56 <gatlin> now, I understand there's an Either monad
16:27:07 <gatlin> but I'm a bit stumped about monads; this might be a great learning opportunity
16:29:08 <mauke> did you mean: either Nothing or Just the unit clause in question
16:29:35 <gatlin> Maybe might be a better option here
16:30:31 <gatlin> this combined hasUnit function is used in unitpropagate in a guard. I could potentially make the call in the where block, and rewrite my guards
16:31:26 <otters> oh man
16:31:38 <otters> lambdabot "..." "..." outputs the string, it doesn't return it
16:31:39 <otters> that's the worst
16:32:24 <lambdabot> Really? I only have nice things to say about you.
16:33:22 <otters> well, you suck
16:33:25 <otters> or at least your GOA binding does
16:34:24 <lambdabot> I would feel hurt if someone had given me feelings.
16:34:33 <otters> tell GOA to fix you
16:35:01 <otters> in the lambdabot command, I really don't need to know what I just typed in right after I just typed it in
16:41:03 <elliott> <gatlin> ddarius: I'm trying to get rid of the final vestiges of null, head, tail, length in my chooseUnit function … but I think I could be more intelligent by making unit (which should be called hasUnit) somehow either return False or the unit clause in question
16:41:05 <elliott> gatlin: You want Maybe.
16:41:13 <elliott> (Maybe a) is either Nothing or (Just a).
16:41:19 <elliott> i.e., Nothing :: Maybe a, Just :: a -> Maybe a
16:41:42 <elliott> You don't need to know anything about monads, either, really, since IIRC your use-case is falling back on other alternatives for Nothing.
16:52:22 <Axman6> so, anyone know if there's a nice library for parsing bitstreams? plenty of protocols and codecs require working at the bit level, and converting a bytestring into [Bool] seems wasteful
16:54:24 <sal23> how do you keep a foreignPtr alive (other than withForeignPtr function)? I am passing ptrs to some storable vectors to C, and want those vectors to live for the entire lifetime of the program
16:55:01 <Axman6> use plain Ptrs?
16:55:21 <sal23> Axman6, GHC doesn't keep track of plain ptrs for GC, from what I read
16:56:10 <Axman6> isn't that what you want? i'm confused
16:57:11 <sal23> Aman6, what I want to tell GC is that those vectors have references in C code, and so, not to run finalizers on them
16:57:33 <akosch> I get a lot of debug/warning messages from both Network.HTTP and HXT to stdout and stderr. Is this normal? How can I get rid of this?
16:57:33 <elliott> sal23: touchForeignPtrf
16:57:36 <elliott> except without the f
16:57:51 <elliott> it does nothing but count as a reference to the foreignptr
16:57:58 <sal23> elliott, yes, I was looking at that but wasn't sure if that is right…how do you untouch one then?
16:58:02 <elliott> so you can call C code that fiddles with the Ptr inside as long as you touchForeignPtr later
16:58:04 <elliott> sal23: err...
16:58:13 <mauke> sal23: you execute the touch
16:58:18 <mauke> after that it's untouched
16:58:18 <elliott> sal23: I fear I may only be contributing to a deeper confusion here :)
16:58:25 <elliott> sal23: why can't you use withForeignPtr?
16:58:36 <elliott> withForeignPtr fp $ \ptr -> my_c_code ptr
16:58:59 <sal23> elliott, simpler just to pass a list of ptrs when the vectors in question never get freed
16:59:49 <sal23> my original code has withForeignPtr but I could simplify it by using just ptrs, if there is a way to say don't free them ever
17:00:07 <elliott> Haskell does not free Ptrs willy-nilly
17:00:16 <elliott> the whole point of ForeignPtrs is that they can be GC'd
17:00:19 <elliott> why not just use a Ptr?
17:00:49 <sal23> so, I get a Ptr to storable vector using unsafeToForeignPtr, and that should keep a reference to them?
17:01:30 <sal23> this is what I was looking at for ForeignPtr documentation: This is a potentially dangerous operations, as if the argument to unsafeForeignPtrToPtr is the last usage occurrence of the given foreign pointer, then its finalizer(s) will be run, which potentially invalidates the plain pointer just obtained. Hence, touchForeignPtr must be used wherever it has to be guaranteed that the pointer lives on - i.e., has another usage occurrence
17:02:02 <sal23> but if I am passing them to C code, that doesn't apply in my case?
17:02:38 <elliott> sal23: what are you trying to achieve in a more global sense? e.g., why do you have a Ptr in the first place?
17:02:45 <elliott> but I suppose you _could_ just touch the foreignptr in the right place...
17:03:43 <sal23> elliott, just generating a list of storable vectors, getting ptr to each storable vector, and passing them to c code as an array…it is awkward if I use unsafeForeignPtr
17:03:47 <tempire> users of vim haskellmode?
17:03:51 <sal23> sorry, withForeignPtr
17:04:12 <tempire> looking for how to get it to recognize the modules in ~/.cabal
17:04:16 <elliott> sal23: ok, then it's fine to use mapM_ touchForeignPtr or whatever
17:04:53 <sal23> elliott, cool…how did you learn about foreignptr behavior btw? by crashing the programs? :)
17:05:32 <koninkje> @seen edwardk
17:05:32 <lambdabot> Unknown command, try @list
17:05:35 <elliott> by reading the documentation :P
17:05:58 <elliott> but I've crashed a lot of programs too
17:05:59 <sal23> it is not really clear from GHC documentation about the lifecycle of foreignPtr when I extract a Ptr…you are a better reader than me :)
17:06:09 <elliott> oh, well I was just commenting on the ForeignPtr part
17:06:18 <elliott> whether it interacts well with your Ptr stuff, I couldn't say
17:06:31 <sal23> yeah, that I am afraid of…FFI makes me nervous
17:06:34 <elliott> why are you using an unsafe function rather than newForeignPtr_ or such?
17:06:40 <elliott> oh, wait
17:06:41 <elliott> unsafeForeignPtrToPtr. ok
17:06:46 <sal23> yep
17:07:34 <elliott> sal23: if it helps: withForeignPtr fp k = k (unsafeForeignPtrToPtr fp) <* touchForeignPtr fp
17:07:46 <elliott> (p <* q === do { r <- p; q; return r })
17:07:58 <koninkje> if converting ForeignPtr to Ptr, the latter is only valid so long as the former is protected from collection
17:08:03 <sal23> thanks, elliott
17:08:06 <otters> :t (<*)
17:08:08 <lambdabot> forall (f :: * -> *) a b. (Applicative f) => f a -> f b -> f a
17:08:09 <elliott> I was going to say it's not exception safe, but then I realised that doesn't matter
17:08:14 <elliott> since it's just the pointer existing that matters :p
17:08:20 <sal23> elliott, what I am doing is passing storable vectors to C code which fills them up with the data from some real-time feed, and then I run a timer loop on haskell side to collect the data from the vectors
17:08:21 <elliott> GC is weird.
17:08:36 <sal23> yep, but it seems to work pretty well
17:08:41 <elliott> sal23: hmm, I would structure that differently, perhaps
17:09:17 <elliott> say, C code calls into Haskell with a raw Ptr, Haskell (unsafely, so no copying) converts it to a Vector or such
17:09:21 <elliott> and the C program controls the main lo- good god
17:09:25 <elliott> ...was what I typed when that massive netsplit happened
17:09:31 <elliott> -op
17:09:31 <MarconM> i want conf for emacs
17:09:36 <MarconM> like haskell mode
17:09:38 <sal23> elliott, yep, wondering about that
17:09:42 <MarconM> where i get ?
17:10:22 <sal23> elliott, C code never calls into Haskell…it fills up the storable vectors I passed it, and haskell periodically collects data from those vectors
17:10:39 <elliott> right, I was suggesting not doing it that way... but I don't know your code :P
17:10:53 <elliott> for instance, how do you get the C code to stop filling the vectors when you observe them from Haskell?
17:11:04 <elliott> oh, I guess you could be using mutable vectors
17:11:08 <sal23> yep, got that too :) mutexes on c side
17:11:11 <elliott> but is it really safe for C to poke them at the same time as the haskell runtime?
17:11:17 <elliott> I dunno, it all seems very risky to me
17:11:45 <sal23> haskell code calls a c function which acquires mutex…actually, yes, c code calls back but into a partial function
17:12:23 <koninkje> why not just have the C code send full buffers to a Chan, list, or similar?
17:12:37 <elliott> right, but what's the benefit over C code filling a pointer that it allocates, and then doing my_haskell_code(ptr) at periodic intervals, and then the Haskell code just stuffs that ptr into a Vector?
17:12:41 <elliott> that seems simpler to me
17:12:59 <elliott> koninkje: that would require strictly more work than my proposal, since there are no C-side functions for manipulating Haskell values like Chans
17:13:04 <elliott> so you'd have to write your own
17:13:09 <elliott> (unfortunately)
17:13:16 <koninkje> fair enough
17:13:22 <sal23> elliott, yes, I know…but we are talking about real-time data where I am getting 10+ MB of market data for US equity trading
17:13:30 <sal23> so, it is basically soft real-time
17:13:38 <elliott> sal23: ok, but I don't see how my proposal is any slower at all
17:14:43 <sal23> probably not….but I already tested a setup which works very well, and is solid, algorithmically :)
17:15:25 <Enigmagic> sal23: what are you parsing? itch?
17:15:27 <elliott> sal23: I was referring more to adjusting the setup you seem to be currently making, but OK, it's your code after all :P
17:15:51 <sal23> elliott, true…caveat emptor :)
17:16:05 <sal23> Enigmagic, real-time US equity data
17:16:26 <Enigmagic> in what format?
17:16:49 <sal23> Enigmagic, that is done by something called MAMA adapter provided by NYSE…it is in C
17:17:25 <sal23> I just call it to parse the data, and put the data into appropriate vectors
17:18:25 <Enigmagic> i see.. what i do for ITCH (nasdaq) is built a parser in Ragel, compile it with clang to llvm bitcode... munge up the llvm a little bit and import it into haskell as a primop
17:18:38 <Enigmagic> super fast and no allocations required
17:18:56 <elliott> So are all developers of Haskell finance code crazy?
17:19:03 <elliott> That's hardcore stuff :P
17:19:13 <sal23> haha
17:19:18 <Enigmagic> i guess :P
17:20:22 <sal23> elliott, you are maintaining vault library, right?
17:21:33 <Enigmagic> elliott: i made a cut down example for kospi to demonstrate... the ITCH parser handles all the message types (and it's a thousand+ lines) https://gist.github.com/d42b6c803a84b3a6d43d
17:22:00 <elliott> sal23: I'm not the maintainer, but I have quite a bit of code in there, yes.
17:22:05 <elliott> (Not that there's much code in there at all.)
17:22:55 <sal23> elliott, just curious if you found it useful
17:23:35 <elliott> I'm not using it for anything right now, but repeatedly found a need for it before it existed, so I'm sure I'll find another use for it soon :)
17:24:03 <elliott> Enigmagic: Doesn't a primop block the entire runtime?
17:24:38 <Enigmagic> elliott: on that thread yea
17:25:02 <elliott> I guess it's fast enough to not matter.
17:25:31 <Enigmagic> ~500 instructions per packet
17:25:45 <sal23> elliott, btw what is "<*" in that foreignptr code you showed me earlier?
17:25:59 <byorgey> @hoogle <*
17:26:00 <lambdabot> Control.Applicative (<*) :: Applicative f => f a -> f b -> f a
17:26:00 <lambdabot> Control.Applicative (<**>) :: Applicative f => f a -> f (a -> b) -> f b
17:26:00 <lambdabot> Control.Applicative (<*>) :: Applicative f => f (a -> b) -> f a -> f b
17:26:21 <sal23> thanks
17:26:49 <byorgey> x <* y  does the effects of both x and y (in that order), but discards the result of y and just returns the result of x
17:28:24 <MarconM> i am looking for a haskell mode for emacs
17:28:33 <elliott> MarconM: what OS?
17:28:39 <elliott> it's in debian/ubuntu repositories
17:29:52 <tikhonjelvis> Even if it isn't in your repos, it's trivial to install yourself.
17:31:26 <MarconM> elliott: Archlinux
17:32:11 <elliott> MarconM: install emacs-haskell-mode
17:32:14 <gatlin> for those keeping up with my saga: https://gist.github.com/1755736
17:32:19 <elliott> you need to configure it in ~/.emacs afterwards,t hough
17:32:41 <elliott> gatlin: notUnit is isJust, by the way.
17:32:45 <elliott> (And another problematic function)
17:33:00 <elliott> Oh, you don't actually use it.
17:33:34 <gatlin> elliott: I had been playing with Maybe before I went another route
17:33:42 <gatlin> so I left in some old code I think
17:33:59 <MarconM> elliott: ok
17:36:06 <MarconM> elliott: done
17:36:30 <MarconM> elliott: now what i must to do
17:37:03 <gatlin> I'd second that call to elliott, but I'm sure you're overloaded :)
17:38:16 <MarconM> gatlin: 0.0
17:38:37 <gatlin> I meant, Elliott is overloaded with requests
17:39:43 <MarconM> ok
17:40:47 <elliott> MarconM: http://www.haskell.org/haskellwiki/Haskell_mode_for_Emacs
17:40:58 <elliott> specifically http://www.haskell.org/haskellwiki/Haskell_mode_for_Emacs#Setup, except replace the load line with (require 'haskell-mode)
17:41:16 <elliott> gatlin: n = l * (-1) is an interesting way of saying n = -l
17:42:11 <elliott> gatlin: chooseUnit/isUnit/extractUnit are problematic, apart fromt hat it looks good
17:42:15 <elliott> *from that
17:43:19 <gatlin> I'm learning so much from you; thanks!
17:43:41 <gatlin> still trying to figure out how to word unitpropagate to make productive use of Maybe
17:44:02 <elliott> gatlin: You don't need Maybe
17:44:41 <elliott> Well.
17:44:44 <elliott> You do, in the result type.
17:44:54 <elliott> But your definition is the same as: chooseUnit ([x]:_) = x; chooseUnit (_:xs) = chooseUnit xs
17:45:45 <elliott> with the obvious problem that chooseUnit [] is undefined
17:46:54 * hackagebot process-conduit 0.0.3 - Conduit for process  http://hackage.haskell.org/package/process-conduit-0.0.3 (HideyukiTanaka)
17:47:03 <gatlin> I think I can make guarantees that, if we're using existing functions, chooseUnit won't be called with [] because that's what the check done by unit does
17:49:08 <elliott> gatlin: Yes, you can. That doesn't mean it's idiomatic style :)
17:49:18 <gatlin> :)
17:49:24 <elliott> By analogy: You can also prove that a C program never dereferences a pointer it didn't allocate.
17:49:42 <gatlin> right right, but why throw caution to the wind?
17:50:06 <MarconM> brazilian here ?
17:51:00 <elliott> gatlin: Anyway, I would suggest removing containsEmpty, since it's only being used as a "pre-check" for such things.
17:51:10 <elliott> Then the problem becomes how to express the behaviour without it.
17:51:45 <gatlin> Right. And this is where Maybe comes into play
17:51:55 <gatlin> rather than do these checks and then do something, return Just something or Nothing
17:52:09 <elliott> gatlin: Right -- you essentially want to make the transformation (if containsEmpty a then f (chooseUnit x) else y) ==> (case chooseUnit x of Just v -> f v; Nothing -> y)
17:52:41 <elliott> (you may find guard patterns helpful: you can write | Just foo <- bar = ... and it succeeds if bar is Just foo)
17:53:27 <gatlin> ah, I didn't know about the <- operator in guards
17:56:03 <elliott> To write the Maybe-based chooseUnit nicely, you really want a findP :: (a -> Maybe b) -> [a] -> Maybe b, but unfortunately I do not think there is a standard such function :(
17:56:35 <elliott> Well... there's msum . map f.
17:56:52 <elliott> But I would probably write it as: chooseUnit xs = listToMaybe [x | [x] <- xs].
17:57:36 <gatlin> ah, I was going to try to use this:
17:57:37 <gatlin> http://hpaste.org/57614
17:58:34 <elliott> Yes, that would work fine. List comprehensions are generally nicer for "complicated" matching-searches (a term I just made up), though.
17:58:43 <elliott> Explicit recursion should generally be avoided.
17:59:06 <dibblego> @remember elliott Explicit recursion should generally be avoided.
17:59:06 <lambdabot> Okay.
17:59:20 <elliott> Also, general recursion should be explicitly avoided!
17:59:44 <elliott> gatlin: Apart from that, your code looks good to me, although I am not sure why you define names for short expressions that are only used once.
17:59:54 <elliott> Specifically in dpll/unitpropagate.
18:00:07 <CodeWeaverX> I think someone recursed elliott out once too often.
18:01:26 <gatlin> elliott: because I'm easily confused but you're right - not necessary
18:01:32 <gatlin> or even useful. n = -l is kind of silly
18:01:56 <elliott> I find "sfl" more confusing than "simplify f l" :)
18:02:31 <elliott> Oh, and "or $ [ ... ]" is the same as "or [ ... ]".
18:02:53 <elliott> Oh, chooseLiteral is another problem function that I missed :P
18:04:03 <elliott> Another obvious Maybe result choice; I'd write it as {chooseLiteral = msum . map listToMaybe} but you will probably find {chooseLiteral xs = listToMaybe [ x | x:_ <- xs ]} less incomprehensible.
18:05:31 <gatlin> Data.Maybe is full of goodies
18:07:04 <huangyi> When a thread get killed, will all the child threads created by it get killed too ?
18:07:14 <huangyi> By thread, i mean haskell thread.
18:08:05 <elliott> No.
18:08:20 <elliott> However, when the main thread dies, the whole program exits.
18:08:23 <tomprince> @remember elliott Explicit recursion should generally be avoided. Also, general recursion should be explicitly avoided!
18:08:23 <lambdabot> It is forever etched in my memory.
18:09:47 <em> did you all know that Haskell is named after the same guy that Currying is named after?
18:10:05 <elliott> tomprince: You might want to @forget the original :P
18:10:11 <elliott> em: Yes.
18:10:16 <elliott> (I'm everyone.)
18:10:20 <Ralith> (he is)
18:10:28 <em> elliott: Okay well that's all I had. So I guess that takes care of it then.
18:11:20 <elliott> I'm also you.
18:11:27 <elliott> Not quite sure why I'm talking to myself.
18:11:30 <Ralith> boredom
18:11:34 <Ralith> on account of lack of company
18:11:42 <elliott> :(
18:11:44 <elliott> Maybe I'll join #ubuntu.
18:11:51 <tomprince> @forget elliott Explicit recursion should generally be avoided.
18:11:51 <lambdabot> Done.
18:12:27 <gatlin> I'm still here!
18:12:37 <gatlin> I've plenty of trainwreck code to sift through
18:21:54 * hackagebot gloss 1.6.1.1 - Painless 2D vector graphics, animations and simulations.  http://hackage.haskell.org/package/gloss-1.6.1.1 (BenLippmeier)
18:21:56 * hackagebot gloss-examples 1.6.1.1 - Examples using the gloss library  http://hackage.haskell.org/package/gloss-examples-1.6.1.1 (BenLippmeier)
18:25:58 <CodeWeaverX> Crazy…. new ghc comes out, and the packages are coming in fast and furious.
18:26:08 <CodeWeaverX> I mean, that's great, but I kinda didn't expect it.
18:31:55 * hackagebot husk-scheme 3.5.2.3 - R5RS Scheme interpreter, compiler, and library.  http://hackage.haskell.org/package/husk-scheme-3.5.2.3 (JustinEthier)
18:33:46 <nyingen> @quote
18:33:46 <lambdabot> LoganCapaldo says: Cale: do you come in a standalone command line version?
18:33:52 <Boney> Hi.  I'm trying to use MonadError (if it turns out to be suitable)
18:34:02 <Boney> How do I read this class declration:
18:34:04 <Boney> class Monad m => MonadError e m | m -> e whereSource
18:34:13 <Boney> class Monad m => MonadError e m | m -> e where
18:34:27 <Boney> What does the "| m -> e" part mean?
18:36:14 <elliott> Boney: it's a functional dependency
18:36:20 <irene-knapp> :t liftM
18:36:21 <lambdabot> forall a1 r (m :: * -> *). (Monad m) => (a1 -> r) -> m a1 -> m r
18:36:23 <elliott> it means that there can only be one "e" for every "m"
18:36:31 <elliott> e.g., if you have MonadError Foo Bar, then you can't have MonadError Quux Bar
18:36:43 <elliott> because "m" determines "e"
18:38:27 <irene-knapp> :t liftM
18:38:28 <Boney> ah ok.
18:38:28 <lambdabot> forall a1 r (m :: * -> *). (Monad m) => (a1 -> r) -> m a1 -> m r
18:38:29 <irene-knapp> er, sorry
18:38:31 <irene-knapp> wrong window
18:42:05 <Boney> elliott: can you say why this restriction is here?  It doesn't seem necessary to me.
18:42:41 <Boney> It wont effect my program, but I like generic code :-)
18:44:20 <elliott> Boney: It's not *just* a restriction.
18:44:31 <elliott> Boney: It helps the compiler figure things out.
18:45:01 <elliott> In this case, it only makes sense for a monad to have one error type, so the error type becomes "associated" with that monad.
18:45:16 <elliott> Without that, typeclass resolution would be problematic (requiring at the very least lots of manual type annotations everywhere).
18:45:51 <elliott> http://www.haskell.org/haskellwiki/Functional_dependency may help
18:48:12 <Boney> Ah, because different uses of throwError or catchError might use different error types
18:48:22 <Boney> and there's not enough information for the compiler to check that the types can be unified.
18:48:23 <clarkg> :t (<$>)
18:48:24 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
18:48:58 <Boney> (In particular the type of e can't be unified reliably)
18:49:00 <clarkg> :t (<*>)
18:49:01 <elliott> Boney: right -- it means that as soon as it knows what "m" is, it can fix "e"
18:49:01 <lambdabot> forall (f :: * -> *) a b. (Applicative f) => f (a -> b) -> f a -> f b
18:49:42 <Boney> elliott: Okay, I think that's the shortest time it's taken me to learn a haskell type system thing.
18:49:55 <Boney> learn, and understand deeply enough :-)
18:50:09 <dougransom> lambdabot  x (y z)
18:52:53 <dougransom> lambdadot  x (y z)
18:53:21 <dougransom> lambdabot @pointfree  x (y z)
18:53:38 <elliott> dougransom: Don't say "lambdabot".
18:53:51 * eviltwin_b wonders if that's a failed attempt at /msg
18:54:27 <dougransom> doh!  looking at http://www.haskell.org/haskellwiki/Lambdabot#Interacting_with_the_Bot and its not clear to me how to invoke
18:54:40 <elliott> @pl x (y z)
18:54:40 <lambdabot> x (y z)
18:54:43 <MostAwesomeDude> @pl \x y z -> x (y z)
18:54:44 <lambdabot> (.)
18:55:41 <noumena> I'm just starting to learn Haskell (and loving it) and was wondering what a recommended GUI programming library is?
18:55:45 <dougransom> got it.
18:56:06 <dougransom> @pl x . y
18:56:07 <lambdabot> x . y
18:56:19 <elliott> noumena: gtk2hs or wx
18:56:31 <elliott> but neither are very "haskelly", unfortunately
18:56:32 <CodeWeaverX> noumena:  wxWidgets or gtk2hs both of which need you to build C libraries first.
18:56:36 <dougransom> @pl a  (b c (d e)))
18:56:36 <lambdabot> (line 1, column 15):
18:56:36 <lambdabot> unexpected ")"
18:56:36 <lambdabot> expecting variable, "(", operator or end of input
18:56:43 <elliott> CodeWeaverX: or just install the development libraries...
18:56:53 <zzo38> Which Cabal category does my program Hampp (Haskell macro preprocessor) should belong to?
18:56:53 <CodeWeaverX> There's also some Functional Reactive Programming gui stuff floating around, but if you're just getting started, probably wx.
18:56:54 <elliott> noumena: the oop frameworks are behemoths and functional guis are still experimental, but they do work fine
18:56:54 <dougransom> @pl a  (b c (d e))
18:56:55 <lambdabot> a (b c (d e))
18:57:04 <CodeWeaverX> Okay, yes, you could install the development binaries if you can find them for your os.
18:57:27 <zzo38> (The current version is 0.2, just in case you wanted to know what it is)
18:57:29 <CodeWeaverX> Sorry the haskell side of wxWidgets is wxHaskell
18:57:45 <dougransom> @pointful a  (b c (d e))
18:57:45 <lambdabot> a (b c (d e))
18:57:53 <zzo38> I do also have another question: How to make package version number if it has no exposed modules?
18:57:59 <noumena> Do you guys use the GUI stuff much?
18:58:19 <noumena> I prefer command line things, but when I write little programs for friends they're always looking for the GUI
18:58:21 <CodeWeaverX> I've ever so lightly experimented, but no, not much yet.
18:58:59 <CodeWeaverX> noumena:  Yes, I know how you feel.  All the 'cool stuff' I do seems to be just fine explored on the command line but everyone wants the pretty pixels.  bah. ;)
18:59:00 <zzo38> I also mostly prefer command line things and write command line based things
18:59:01 <noumena> what does xmonad rely on? is it just interfacing with X11 libraries?
18:59:17 <Boney> noumena: Some things are inherrently graphical.  ThreadScope (a profile visualisation tool) for example.
18:59:25 <elliott> xmonad uses xlib, yes
18:59:39 <Boney> but when I can get away with it everything is CLI.
19:00:16 <noumena> wow, threadscope looks awesome
19:00:20 <Boney> or at least ncurses.
19:00:47 <noumena> yeah, i love the little ncurses style programs
19:00:51 <CodeWeaverX> noumena, if you're just getting started, don't get bogged down in the GUI stuff right away.  It's already been mentioned:  It's not very haskelly.
19:00:54 <Boney> noumena: :-D  98% of the credit goes to people who arn't me.
19:01:32 <noumena> Yeah, I agree.  I'm not gonna get too heavy into the GUI right away, but I just wanted to know for the future
19:02:01 <Entroacceptor> *insert reactive-banana advertisment here*
19:02:04 <noumena> do you guys use haskell in your jobs or is it just a hobby?
19:02:05 <CodeWeaverX> Feel free to come by here.  At some point I'll be doing that too, love to chat with someone about new haskell experiences.
19:02:38 <noumena> CodeWeaverX, appreciate it!
19:02:54 <deech> Hi all, I have documentation generated as part of a "cabal install" but there are no source links. How do I generate them?
19:04:08 <elliott> deech: --hyperlink-source
19:04:12 <elliott> oh, wait
19:04:15 <elliott> you can't, sorry
19:04:15 <zzo38> *insert reactive-apples advertisment here*
19:04:24 <elliott> not with "cabal install"
19:04:45 <Entroacceptor> zzach1: liar
19:04:51 <Entroacceptor> woops, the wrong zz
19:11:55 * hackagebot process-conduit 0.0.4 - Conduits for processes  http://hackage.haskell.org/package/process-conduit-0.0.4 (HideyukiTanaka)
19:22:07 <Sgeo> Is that perhaps an abuse of quasiquoters?
19:22:14 <abdulsattar> forkIO (threadDelay 10000 >> putStrLn "waited") Will this for 10 seconds and print waited?
19:23:01 <Sgeo> abdulsattar, I believe it's supposed ti
19:23:05 <Sgeo> lemme check
19:23:15 <rwbarton> it will wait for 0.01 seconds
19:23:36 <abdulsattar> why 0.01 seconds? 10000 ms = 10 secs right?
19:24:05 <Sgeo> Might not be ms
19:24:05 <rwbarton> What makes you think the argument is in milliseconds?
19:24:52 <Sgeo> @hoogle TimeSpan
19:24:53 <lambdabot> No results found
19:25:15 <Sgeo> threadDelay should take some type that represents an amount of time
19:25:32 <abdulsattar> Just read on hackage: it takes microseconds
19:25:46 <abdulsattar> rwbarton, Sgeo, thank you
19:26:14 <Sgeo> >.> I wasn't really helpful I think
19:27:20 <abdulsattar> Sgeo: threadDelay takes an Int, the number of microseconds
19:28:04 <Sgeo> imo it needs to be changed to not take an Int, but to take something that represents an amount of time, which can easily be made with whatever units are being expected
19:28:07 <rwbarton> yeah, but as you've discovered, that's kind of a dumb interface--why microseconds?
19:31:07 <abdulsattar> rwbarton: any other language accepts ms, the GHC folks wanted a precise time interval it seems
19:31:27 <abdulsattar> BTW, why does threadDelay work only in GHC?
19:31:50 <elliott> as opposed to what :P
19:31:57 <abdulsattar> @hoogle threadDelay
19:31:58 <lambdabot> Control.Concurrent threadDelay :: Int -> IO ()
19:31:58 <lambdabot> GHC.Conc.IO threadDelay :: Int -> IO ()
19:31:58 <lambdabot> GHC.Conc threadDelay :: Int -> IO ()
19:32:17 <elliott> i mean
19:32:22 <elliott> as opposed to what other implementation
19:32:36 <slack1256> neil mitchell used to speak about supero, a supercompiler for haskell.
19:32:50 <slack1256> but las blogpost i saw about it was in 2009, what is happening there?
19:32:54 <slack1256> *last
19:33:43 <m3ga> slack1256: nhm stopped working on it while someone else was doing a phd on the topic
19:34:04 <abdulsattar> elliott: are you talking about the threadDelay
19:34:59 <akosch> what regex module should I use with unicode? Text.Regex doesn't work.
19:35:21 <elliott> abdulsattar: Yes.
19:35:27 <elliott> in response to <abdulsattar> BTW, why does threadDelay work only in GHC?
19:35:31 <akosch> I guess that's a limitation of the posix library
19:35:32 <slack1256> m3ga: i well, at least isn't abandoned
19:35:39 <slack1256> *s/i/ohh/
19:36:12 <elliott> Sgeo: Why would it be an abuse?
19:36:45 <Sgeo> elliott, why wouldn't a string be good enough?
19:37:25 <m3ga> slack1256: not abandoned, but still a significantly difficult problem.
19:37:39 <elliott> Sgeo: Because it interpolates Haskell variables?
19:37:50 <m3ga> slack1256: https://sikhote.wordpress.com/2010/11/19/supercompilation-by-evaluation-and-rethinking-supercompilation/
19:38:37 <Sgeo> elliott, ah. Shouldn't it then be a part of some other package, rather than in this one particular use-case?
19:39:46 <slack1256> m3ga: reading...
19:42:26 <abdulsattar> elliott: Why does the threadDelay work only in GHC? I mean, isn't it defined in the Haskell 2010/98 report?
19:43:11 <monochrom> the whole of Control.Concurrent is not in Haskell 98 or 2010
19:44:54 <slack1256> abdulsattar: maybe i am wrong, but could it be for the semantics of concurrency adopted by ghc?, ghc chose Cooperative multithreading, so threadDelay in ghc would be different in another compiler
19:45:01 <elliott> Sgeo: I presume it handles shell escaping.
19:45:12 <Sgeo> Hmm, ok
19:45:15 <elliott> slack1256: GHC's concurrency model is not cooperative multithreading.
19:45:39 <covi> Hi all. What does 'xs' mean (what is it short for)?
19:45:50 <Axman6> covi: the rest of the x's
19:45:53 <mauke> it's the plural of x
19:46:12 <Axman6> foo (x:xs) says match the head of the list, and call it x, and the rest of the list is the rest of the xs
19:46:16 <slack1256> elliott: that me being dumb, sorry, i read something about ghc and not the OS handling the thread and i though i saw something about cooperative. sorry
19:46:16 <elliott> covi: (thing:things)
19:46:17 <elliott> (x:xs)
19:46:36 <elliott> slack1256: right, GHC runs several Haskell threads on several OS threads
19:46:36 <covi> I see. Thank you all :)
19:46:37 <slack1256> *though thought
19:46:50 <Axman6> ghc threads are semi cooperative afaik. they aren't exactly preemptive anyway
19:47:03 <elliott> Axman6: that applies on one CPU
19:47:11 <elliott> I wouldn't call anything with two OS threads cooperative :P
19:47:55 <Axman6> well, within a capability i don't think it's preemptive
19:48:11 <slack1256> but anyways, wouldn't the compiler decitions on concurrency affect function like threadDelay? that being the cause of them being GHC-Only
19:48:33 <elliott> I think "GHC only" just means "not in Hugs or nhc".
19:48:45 <elliott> The reason threadDelay is not available in Hugs or nhc is presumably because they don't implement it.
19:48:50 <Axman6> i think threadDelay is only available on GHC because GHC is the only compiler that supports concurrency
19:48:51 <elliott> (Does UHC use base too?)
19:49:56 <slack1256> Axman6: i think that also
20:21:58 * hackagebot cab 0.1.10 - A maintenance command of Haskell cabal packages  http://hackage.haskell.org/package/cab-0.1.10 (KazuYamamoto)
20:30:03 <ski> elliott_ : "it only makes sense for a monad to have one error type" -- why ?
20:30:14 <ski> "Without that, typeclass resolution would be problematic (requiring at the very least lots of manual type annotations everywhere)." -- hmm, there is no class method signature not mentioning all the parameters, at least
20:30:57 <elliott_> ski: well, it only makes sense in terms of MonadError :)
20:31:09 <elliott_> whether MonadError is good or not... that's up to you
20:31:58 * hackagebot dph-base 0.6.1.1 - Data Parallel Haskell common config and debugging functions.  http://hackage.haskell.org/package/dph-base-0.6.1.1 (BenLippmeier)
20:32:01 * hackagebot dph-prim-interface 0.6.1.1 - Data Parallel Haskell segmented arrays. (abstract interface)  http://hackage.haskell.org/package/dph-prim-interface-0.6.1.1 (BenLippmeier)
20:34:18 <ski> @src MonadError
20:34:18 <lambdabot> class (Monad m) => MonadError e m | m -> e where
20:34:19 <lambdabot>     throwError :: e -> m a
20:34:19 <lambdabot>     catchError :: m a -> (e -> m a) -> m a
20:34:50 <ski> elliott_ : i'm not sure what you mean by the former remark
20:37:02 * hackagebot dph-prim-seq 0.6.1.1 - Data Parallel Haskell segmented arrays. (sequential implementation)  http://hackage.haskell.org/package/dph-prim-seq-0.6.1.1 (BenLippmeier)
20:37:04 <elliott_> ski: which one?
20:37:04 * hackagebot dph-prim-par 0.6.1.1 - Data Parallel Haskell segmented arrays. (production version)  http://hackage.haskell.org/package/dph-prim-par-0.6.1.1 (BenLippmeier)
20:37:06 * hackagebot dph-lifted-base 0.6.1.1 - Data Parallel Haskell common definitions used by other dph-lifted packages.  http://hackage.haskell.org/package/dph-lifted-base-0.6.1.1 (BenLippmeier)
20:37:08 * hackagebot dph-lifted-vseg 0.6.1.1 - Data Parallel Haskell lifted array combinators.  http://hackage.haskell.org/package/dph-lifted-vseg-0.6.1.1 (BenLippmeier)
20:37:10 * hackagebot dph-lifted-copy 0.6.1.1 - Data Parallel Haskell lifted array combinators. (deprecated version)  http://hackage.haskell.org/package/dph-lifted-copy-0.6.1.1 (BenLippmeier)
20:37:17 <ski> the one about making sense
20:38:07 <elliott_> ski: well, MonadError is the typeclass version of ErrorT
20:38:11 <elliott_> which models a single error type
20:42:12 <ski> elliott_ : well, how about `ErrorT e0 (WriterT w (ErrorT e1 m))' ?
20:42:12 * hackagebot dph-examples 0.6.1.1 - Data Parallel Haskell example programs.  http://hackage.haskell.org/package/dph-examples-0.6.1.1 (BenLippmeier)
20:42:14 * hackagebot dph-lifted-vseg 0.6.1.2 - Data Parallel Haskell lifted array combinators.  http://hackage.haskell.org/package/dph-lifted-vseg-0.6.1.2 (BenLippmeier)
20:42:20 <ski> @unmtl ErrorT e0 (WriterT w (ErrorT e1 m)) a
20:42:20 <lambdabot> m (Either e1 (Either e0 a, w))
20:44:26 <Axman6> hmm, new jhc release. looks quite fun
20:45:38 <Axman6>  Want to create a varient of haskell that has 16 bit Ints, ASCII 8 bit Chars
20:45:38 <Axman6>  and pervasively uses null terminated C style strings? just create a base-tiny
20:45:40 <Axman6>  library and link it against jhc-prim.
20:46:59 * hackagebot dph-examples 0.6.1.2 - Data Parallel Haskell example programs.  http://hackage.haskell.org/package/dph-examples-0.6.1.2 (BenLippmeier)
20:47:55 <Axman6> god damn
20:47:55 <elliott_> Axman6: useful, that
20:48:21 <Axman6> elliott_: the release email is much more informative. i just thought that was cool
20:48:59 <elliott_> i was kidding :)
20:49:06 <elliott_> as in...
20:49:10 <elliott_> my sarcasm was itself kidding
20:51:59 * hackagebot dph-examples 0.6.1.3 - Data Parallel Haskell example programs.  http://hackage.haskell.org/package/dph-examples-0.6.1.3 (BenLippmeier)
20:56:42 <zzo38> Is this the proper way to make the cabal package file?   http://sprunge.us/haMR
20:56:59 * hackagebot representable-functors 2.1.2 - Representable functors  http://hackage.haskell.org/package/representable-functors-2.1.2 (EdwardKmett)
20:57:14 <ivanm> zzo38: "cabal init" can generate the basis of one
20:57:21 <ivanm> also, I would suggest *against* public domain
20:57:33 <zzo38> ivanm: Why do you suggest against public domain?
20:57:34 <ivanm> as depending on which country you're in, you might not be legally allowed to release it under public domain
20:57:41 <ivanm> ^^ just said ;)
20:58:15 <ivanm> I would suggest also providing a website URL if you have one
20:58:17 <zzo38> OK. What if I set it to PublicDomain but add the LICENSE file with WTFPL license or something like that?
20:58:24 <ivanm> and if you use darcs, git or hg give the repo
20:58:36 <ivanm> zzo38: why not BSD3 or something?
20:59:12 <ivanm> also, don't list the TODO in the Description
20:59:12 <zzo38> ivanm: There is no URL for this package (other than the Hackage), and it is a single file so there is no repository.
20:59:29 <ivanm> shove the TODO as an extra file
20:59:34 <ivanm> a README would also be a good idea
20:59:35 <zzo38> O, sorry, I didn't know don't list TODO in the Description.
20:59:47 <ivanm> zzo38: well, you can, but it gets annoying
21:00:06 <ivanm> zzo38: you'd be better off with a better description of what hampp *is* and why you would want to use it
21:00:17 <zzo38> But even if it is not in the description, I want to put in the .cabal file (possibly commented out) so that you can access it without downloading the entire package
21:00:17 <ivanm> and have some example files included as documentation
21:00:38 <ivanm> that would involve updating the .cabal file each time you change it
21:00:50 <ivanm> this is why a repo is nice: people can look *there* for a README, TODO, etc.
21:01:37 <zzo38> But I need to update the .cabal file each time I change it anyways (the minimum is to update the version number)
21:01:46 <ivanm> yes
21:01:52 <ivanm> but then you have syncing issues
21:02:01 * hackagebot adjunctions 2.0.5 - Adjunctions  http://hackage.haskell.org/package/adjunctions-2.0.5 (EdwardKmett)
21:02:03 * hackagebot kan-extensions 2.1.2 - Kan extensions, the Yoneda lemma, and (co)density (co)monads  http://hackage.haskell.org/package/kan-extensions-2.1.2 (EdwardKmett)
21:02:20 <ivanm> zzo38: when I go to a hackage page, I want to see what the package is, and why I would want to use it
21:02:33 <zzo38> O, yes; I really should fix that.
21:02:38 <zzo38> But I don't really know what to write.
21:02:49 <zzo38> Although I do agree with you about that.
21:02:50 <ivanm> excessive TODOs, Changelogs, etc. shoved into the description field just make it harder to get information
21:03:10 <zzo38> OK, then I will comment out the TODOs so that they do not appear on the description webpage.
21:03:22 <edwardk> the only package i'm anal retentive about keeping a changelog in my description field is 'ad'
21:03:33 <edwardk> mostly because i got in the habit early on
21:03:53 <ivanm> and that's got too much of a wall of text feel to it
21:04:06 <ivanm> the description should just be a brief overview of what the package is
21:04:10 <ivanm> IMHO, of course
21:04:24 <zzo38> I think you are correct; but unfortunately I don't know what to write.
21:04:30 <ivanm> use a README - especially one with some kind of markup, etc. - do a more in-depth description
21:04:37 <ivanm> zzo38: what is it?
21:04:50 <ivanm> and why would I want to bother downloading, installing and using it?
21:05:54 <edwardk> zzo38: you can start doing what i do whenever ivanm asks me that question and just say 'you wouldn't' ;)
21:05:55 <zzo38> It is Haskell macro preprocessor. You would download and use it in case you want to do preprocessor with your program. I am not really good at writing these kind of summary, but I can show you the codes in case you want to see it.
21:06:36 <ivanm> edwardk: heh
21:06:40 <zzo38> edwardk: Well, yes; not everyone is required to use it. Probably many people hate it. But in a few cases it can be useful.
21:06:45 <ivanm> zzo38: what *kind* of macros?
21:06:59 * hackagebot representable-tries 2.0.5 - Tries from representations of polynomial functors  http://hackage.haskell.org/package/representable-tries-2.0.5 (EdwardKmett)
21:07:01 * hackagebot monad-products 0.2.0.2 - Haskell 98 monad products  http://hackage.haskell.org/package/monad-products-0.2.0.2 (EdwardKmett)
21:07:06 <ivanm> how does it benefit someone? (shorter code? more concise? more readable?)
21:07:07 <edwardk> and then when he asks why you can tell him because he should be writing some kind of graph library ;)
21:07:15 <ivanm> edwardk: stfu :p
21:07:38 <koninkje> edwardk: ping!
21:07:41 <ivanm> zzo38: don't worry too much about it; it takes practice to write that kind of stuff
21:07:42 <edwardk> heya
21:07:42 <lambdabot> edwardk: You have 2 new messages. '/msg lambdabot @messages' to read them.
21:08:03 <edwardk> unification-fd?
21:08:06 <zzo38> ivanm: There built-in macros and custom macros. Custom macros are just substitution, but built-in macros include calculation, auto-increment, and so on, and can be combined. But it also has reorderable named chunks like WEB, and include files supporting.
21:08:13 <koninkje> edwardk: yeah
21:08:15 <ivanm> e.g. have a look at how the description of my graphviz package changed; it took a while before I figured "I should probably say this is for graph visualisation..." ;)
21:08:33 <ivanm> zzo38: so call it an extensible macro pre-processor or something
21:08:36 <edwardk> fire away (either here or in msg) =)
21:08:36 <zzo38> As well as being able to enter numbers such as 0b100110101 integer literals, and 0'A' is also a valid integer literal for 65
21:08:38 <koninkje> so, I'd thought about doing that design before, but it has different type-system guarantees
21:09:04 <edwardk> yes, but you break those guarantees in the case where you wind up using a GADT and lying about the argument to var
21:09:07 <koninkje> In particular, whether variables are (transparently) transportable between different monads or term types
21:09:10 <zzo38> So it actually has many features but there are also things missing.
21:09:27 <ivanm> remember also to send announcement emails to haskell@ and haskell-cafe@
21:09:42 <koninkje> So I was curious about how the differences in semantics play out in your uses
21:10:08 <koninkje> for the stuff I was doing it was good to maintain the invariant that variables can't be transported, though I can see cases where it'd be good
21:10:16 <zzo38> Probably it is difficult to know unless you look at the codes for this program (there is no proper documentation at this time)
21:10:23 <koninkje> (of course you can always transport them via fmap)
21:10:35 <zzo38> This is the program codes:   http://sprunge.us/QBAU
21:10:51 <edwardk> in yours or mine?
21:11:00 <koninkje> in mine, since fmap is trivial
21:11:05 <edwardk> i'm not sure i'm remembering enough of the issue to see where i'm giving you extra power to change variables
21:11:23 <koninkje> yours doesn't have the right kind for fmap, but it's not indexed so transportation is free/invisible
21:11:38 <edwardk> but the v is can depend on the monad
21:11:42 <edwardk> er the v can
21:11:49 <koninkje> Well, consider that I have two different universes/contexts/whatevs
21:12:08 <zzo38> I have another, unrelated question, maybe edwardk knows (although maybe not). The question is making a monad transformer from any contravariant functor.
21:12:11 <edwardk> sure, but then you make a monad with an 's' parameter which infects the 'v' iirc the ST s version does that
21:12:14 <koninkje> In my version, you have to be explicit about it if you want to take variables from one universe and move them over to the other
21:12:18 <Axman6> @djinn ((a -> r) -> r) -> (a -> ((b -> r) -> r)) -> ((b -> r) -> r)
21:12:19 <lambdabot> f a b c = a (\ d -> b d c)
21:12:21 <edwardk> zzo38: f a -> a ?
21:12:51 <koninkje> whereas in your version, the variables are "free"; i.e., their interpretation is wholly defined by the monad, rather than the universe they're in
21:12:53 * ivanm -> dinner
21:12:54 <zzo38> edwardk: For a monad (not a transformer), yes like that. A specific case of this has already been implemented in a package
21:13:01 <edwardk> the only universes you gain the ability to move between are the map based ones
21:13:19 <koninkje> how so?
21:13:48 <edwardk> pulling up the package its been a few months
21:14:11 <koninkje> If I have (Var 5). In my version that's typed as belonging to a certain class of terms; whereas in yours it can be bound to any type of term (since the interpretation is wholly dependent on the monad)
21:14:23 <edwardk> STVar s t -- has the s from the monad baked in
21:14:31 <edwardk> so you won't be swapping it between monads, etc.
21:14:50 <koninkje> sure. I was thinking of the IntVar though
21:15:07 <edwardk> v is bound to a particular class of terms too, in my version the type infects the entire monad though
21:15:30 <koninkje> right
21:15:41 <edwardk> IntBindingT t m a = IT { … }
21:15:48 <koninkje> implicitly it infects the monad in my version too
21:16:24 <edwardk> yes. and for the other monads it also infects the term, so you'd really have to work to get it out and associated with a wrong flavor term
21:16:37 <edwardk> er also infects the monad
21:16:42 <koninkje> the main difference I see is just the semantics of whether variables are transportable or not; so I wasn't sure if that was something that came up for you
21:16:53 <zzo38> But can a monad transformer be made from a contravariant functor, rather than just a monad?
21:17:00 * hackagebot http-conduit 1.2.5 - HTTP client package with conduit interface and HTTPS support.  http://hackage.haskell.org/package/http-conduit-1.2.5 (MichaelSnoyman)
21:17:19 <koninkje> edwardk: do you see what I mean about the semantics?
21:17:22 <edwardk> i figured if you really wanted that non-transportability a region parameter could give it to you
21:17:36 <koninkje> on the terms?
21:17:37 <edwardk> and most of your monads already have one
21:18:02 <edwardk> newtype IntVar s = IntVar Int
21:18:19 <edwardk> IntBindingT s t m a = ...
21:19:11 <koninkje> that's more of an artifact imo. If the variables have a type parameter, then the monad has to match with it
21:19:38 <koninkje> whereas in yours, the variables don't have the param; but the monads still must, since they provide the interpretation
21:20:34 <koninkje> The bigger issue isn't the monads though, it's the terms themselves and a question of how closely we want them to be bound to their monad (vs not)
21:20:48 <edwardk> this doesn't cause me nearly the level of cognitive dissonance it seems to cause you ;)
21:21:36 <koninkje> there's no dissonance, but there is a semantic difference; so I was curious whether it was the semantics that drove the patch, or just aesthetics
21:21:52 <edwardk> to me it seems the notion of the variable type is at least selected by the monad and term type in all cases
21:22:08 <edwardk> i'm almost always driven by pragmatics or aesthetics
21:22:26 <augur> koninkje!
21:22:26 <koninkje> proper semantics can be quite pragmatic :)
21:22:34 <koninkje> augur!
21:22:39 <augur> hows life dude
21:22:45 <koninkje> not bad
21:22:56 <koninkje> busy with grading, but good other than that
21:23:01 <edwardk> yes, but the version without the silly extra variable has quite nice aesthetics ;)
21:23:01 <tgeeky> Terrible! I took an arrow to the knee!
21:23:14 <augur> koninkje: whatchu grading
21:23:24 <CodeWeaverX> Pfft, I can fix that, tgeeky.
21:23:39 <koninkje> Q520--- "all" the math and logic you need for cognitive science
21:23:40 <tgeeky> CodeWeaverX: ACL and MCL?
21:23:47 <augur> koninkje: oh boy
21:24:03 <koninkje> it's not bad, just takes a lot of time is all
21:24:04 <tgeeky> koninkje: holy crap.
21:24:05 <tgeeky> that's a lot
21:24:20 <koninkje> tgeeky: :)
21:24:23 <tgeeky> isn't that sort of.. unknown, too?
21:24:30 <augur> koninkje: what does the logic part consist of?
21:24:44 <CodeWeaverX> No, no.  I took an arrow to the knee, and I thought my adventuring days were over.  And then I got whisked away to here:  http://pc.gamespy.com/pc/project-mercury/1217986p1.html
21:25:05 <koninkje> well, it's mainly intro to Bayesian probability theory, linear algebra (as used in machine learning etc), and a smattering of FOL
21:25:26 <augur> aha
21:25:31 <augur> so not really logic
21:25:40 <augur> figures!
21:25:50 <koninkje> augur: the logic is mostly filler at the end of term, for folks who haven't seen FOL (or haven't in a while)
21:25:50 <tgeeky> augur: there's nothing logical about the brain!
21:26:05 <augur> tgeeky: brains beg to differ!
21:26:16 <tgeeky> augur: and yet both can be true :O
21:26:20 <CodeWeaverX> My brain doesn't.  Of course my brain's been on beer for a while.
21:26:24 <koninkje> augur: FWIW, logic (proper) is what Larry Moss does. But that's also part of why he doesn't delve into it in this course
21:26:41 <augur> speaking of logic, im in a modal logic class
21:26:43 <augur> its quite interesting
21:26:59 <koninkje> ooh, just the basic stuff or more advanced things?
21:27:17 <augur> dunno what qualifies as basic and what qualifies as advanced but
21:27:26 <tgeeky> koninkje: if this is not relevant, or you don't know, or you aren't a "cognitive scientist" or whatever -- isn't the issue of the brain requiring/using/not using or requiring quantum effects still an open question?
21:27:35 <koninkje> i.e., box and diamond, in different varations; or the various temporal logic stuff
21:28:08 <augur> koninkje: well, we're doing just box and diamond right now, but we're talking about all sorts of interesting interpretations of things
21:28:30 <augur> i mean, right now we're just on the relational interpretation, but we're touching on things like distinguishability, definability, etc.
21:28:34 <koninkje> tgeeky: I'm doing a cognitive science / computational linguistics dual PhD; my MSE was computer science, and I seem to be incapable of stopping doing research on programming langages :)
21:28:58 <CodeWeaverX> That. is very cool koninkje.
21:29:19 <tgeeky> that seems to be a statement that you are qualified to answer :O
21:29:23 <CodeWeaverX> Also serendipitous.  My girlfriend is doing an undergrad very similar to that.
21:29:47 <CodeWeaverX> I'm amused.  The world is small.
21:29:53 <koninkje> tgeeky: there's still folks arguing both sides of that; though I think most cognitive scientists stay out of it, it's more of a philosophical debate
21:30:10 <koninkje> augur: /me nods
21:30:45 <tgeeky> koninkje: yeah, I figured that would be the response. That's fine. One day, it may become a physical (or neurobiological) one.
21:31:15 <augur> koninkje: http://ai.stanford.edu/~epacuit/classes/modal.html class site
21:32:20 <koninkje> augur: the temporal stuff is similar but moreso. I.e., we can think of box and dia as universal and existential quantification but on a different axis from exists/forall; temporal logics typically add a third axis, so you have modalities for "in some/every future path" vs "at some/every point along one future path"
21:32:53 <augur> ya
21:32:58 <zzo38> O, that is how temporal logics work. I did not know a lot about that.
21:33:25 <koninkje> of course, after that you start to get into fun things like modal variants of the mu/nu fixedpoint operators
21:34:27 <koninkje> ooh, you're doing dynamic epistemic logic, nice
21:35:21 <augur> well not yet we aint :p
21:35:48 <koninkje> they had a course on that at the previous NASSLLI. The dynamics makes it much more interesting
21:37:18 <koninkje> Have you gotten to any of the fun paradoxes that inspire modal logicians?
21:39:17 <koninkje> Well, I should head off to bed; early day tomorrow
21:39:23 <tgeeky>  koninkje and by inspire; you mean, crush their little souls?
21:39:40 <koninkje> yes, yes indeed :)
21:40:42 <augur> koninkje_away: no not yet
21:40:44 <augur> also night koninkje_away
21:41:05 <zhuwenxuan> what
21:41:16 <zhuwenxuan> hi
21:41:41 <CodeWeaverX> hello
21:41:51 <augur> zhuwenxuan: a girl in my modal logic class is named xuan!
21:42:18 <zhuwenxuan> where is there
21:42:26 <augur> umd
21:42:46 <zzo38> I found dependent sums package for Haskell. Using that together with type families and reflected types could make something similar to an open case construct.
21:45:01 <quintessence> :t 100undefined
21:45:02 <lambdabot> forall t a. (Num (a -> t)) => t
21:45:42 <zzo38> quintessence: What do you want that for?
21:45:57 <quintessence> I was surprised it parsed, that's all
21:46:23 <zzo38> quintessence: It does parse now you can remember that for making code-golf.
21:47:56 <Veinor> ... that's kind of scary
21:48:15 <zzo38> What one is kind of scary?
21:48:54 <Veinor> :t 100undefined
21:48:55 <lambdabot> forall t a. (Num (a -> t)) => t
21:49:04 <zzo38> Why is it kind of scary?
21:49:14 <Veinor> It seems like the sort of thing that'd be a parse error.
21:51:24 <ion> Should 1+2 be a parse error?
21:51:38 <zzo38> ion: I think not.
21:52:26 <quintessence> :t let r = undefined in 0xf00bar
21:52:27 <lambdabot> forall t a. (Num (a -> t)) => t
21:53:24 <mauke> > let rd = rd in 0xf0rd
21:53:25 <lambdabot>   240
21:56:11 <quintessence> The mind of lambdabot is a strange, strange environment.
21:56:25 <zzo38> It seems reasonable to me.
22:01:22 <quintessence> The parsing is sane if surpring, but for that to evaluate lambdabot must have something like an instance Num (a -> Integer) where fromInteger = const, which is... less sane
22:05:15 <nyingen> @quote
22:05:16 <lambdabot> U says: Ow My Damned Brain
22:16:48 <Jafet> > 1 2 3 4 5
22:16:50 <lambdabot>   1
22:17:05 * hackagebot hxournal 0.6.4.2 - A pen notetaking program written in haskell  http://hackage.haskell.org/package/hxournal-0.6.4.2 (IanWooKim)
22:33:39 <PreciousMetals> hello I just wrote a parser that uses Parsec, I don't really have a lot of experience with it so if someone could give me some tips on how to improve this then that would be appreciated :3~
22:33:43 <PreciousMetals> http://hpaste.org/57616
22:33:50 <PreciousMetals> (it parses irssi log files)
22:39:56 <frerich> PreciousMetal: I don't have much experience with Parsec, but I think there's a lot repetition there. For instance, the 'time' <- time; nickPrefix; nick' <- nick' sequence appears very often and thus would be a good candidate for being factored out.
22:40:45 <frerich> PreciousMetal: Also, the 'between (symbol1 "[") (symbol1 "]")' expression appears quite often, so that might be a good candidate for an 'inBrackets' function or so
22:42:26 <frerich> PreciousMetal: I *thought* there was an 'untilEol' parser or so, which basically does 'many (noneOf "\n")' but I cannot find it anymore. However, since you use that construct in quite a few places, it might be a good candidate for another function
22:44:07 <PreciousMetals> cool :3
22:44:48 <PreciousMetals> thank you a bunch~!
22:45:40 <frerich> PreciousMetals: You're welcome - again, I don't haev much experience with Parsec. These are all just generic refactorings to reduce code duplication.
22:55:59 <zomg> Someone is trying to turn JavaScript into Haskell!
22:56:01 <zomg> http://typedjs.com/
22:56:25 <zomg> Okay, it does seem like a reasonably good idea to give types like that =)
22:56:44 <tikhonjelvis> Eh, have you seen Roy: http://roy.brianmckenna.org/?
22:59:10 <quintessence> frerich: You may want to try out the Applicative style: Constructor <$> fooParser <* separator <*> barParser instead of do { a <- fooParser; separator; b <- barParser; return (Constructor a b) }
22:59:20 <ion> preciousmetals: Applicative functors also tend to be very useful with parsers. E.g. “do foo; a <- bar; baz; return a” → “foo *> bar <* baz”
22:59:49 <zomg> tikhonjelvis: that looks kinda icky tbh :P
22:59:54 <PreciousMetals> ion :O thanks!
23:00:08 <tikhonjelvis> zomg: I haven't actually used it. But it is really trying to turn JavaScript into Haskell.
23:00:14 <zomg> Yeah
23:00:32 <frerich> quintessence, ion: Interesting! I don't have much experience with Applicative yet (but I liked it so far!). In particular, I don't think I've used the '<*' function yet.
23:02:17 <quintessence> <* and *> do the effects of both their arguments (left then right), but they only give back the value from the one they point to
23:02:56 <quintessence> useful for sub-parsers that just have to match but that don't return anything interesting
23:03:57 <frerich> quintessence : Ah, so <* and *> do something similiar, but they are bothq uite different from <*> if I understand correctly?
23:04:11 * frerich thought they are something simliar to <*>
23:05:56 <ion> fa <* fb = (\a b -> a) <$> fa <*> fb
23:06:01 <ion> fa *> fb = (\a b -> b) <$> fa <*> fb
23:07:51 <ion> fa <*> fb ≡ (\a b -> a b) <$> fa <*> fb
23:08:08 <frerich> So instead of 'f  foo <* separator <*> bar' I could also say 'f  foo <* separator *> bar'?
23:08:25 <frerich> Oh, wait, no - I think it parses differently.
23:08:45 <frerich> 'foo <* sep *> bar' would actually yield just what 'bar' gives, right?
23:09:14 <quintessence> or liftA2 const, liftA2 (flip const), and liftA2 ($), if you prefer pointfree
23:09:33 <quintessence> frerich: I'm not actually sure about the precedence / associativity, but I think so
23:09:43 <ion> ((a <* b) *> c) is different from (a <* (b *> c)).
23:09:53 <ion> > Just 'a' <* Just 'b' *> Just 'c'
23:09:54 <lambdabot>   Just 'c'
23:09:59 * frerich nods
23:10:19 <ion> > Just 'a' <* (Just 'b' *> Just 'c')
23:10:19 <lambdabot>   Just 'a'
23:16:33 <ion> quintessence: or liftA2 id to emphasize the id-ness. :-P
23:17:05 * hackagebot hamlet 0.10.8 - Haml-like template files that are compile-time checked  http://hackage.haskell.org/package/hamlet-0.10.8 (MichaelSnoyman)
23:17:07 * hackagebot persistent 0.8.0 - Type-safe, multi-backend data serialization.  http://hackage.haskell.org/package/persistent-0.8.0 (MichaelSnoyman)
23:17:09 * hackagebot persistent-mongoDB 0.8.0 - Backend for the persistent library using mongoDB.  http://hackage.haskell.org/package/persistent-mongoDB-0.8.0 (MichaelSnoyman)
23:17:11 * hackagebot persistent-mysql 0.8.0 - Backend for the persistent library using MySQL database server.  http://hackage.haskell.org/package/persistent-mysql-0.8.0 (MichaelSnoyman)
23:17:18 <tgeeky> ohhhh boyy
23:22:13 * hackagebot persistent-postgresql 0.8.0 - Backend for the persistent library using postgresql.  http://hackage.haskell.org/package/persistent-postgresql-0.8.0 (MichaelSnoyman)
23:22:15 * hackagebot persistent-sqlite 0.8.0 - Backend for the persistent library using sqlite3.  http://hackage.haskell.org/package/persistent-sqlite-0.8.0 (MichaelSnoyman)
23:22:17 * hackagebot persistent-template 0.8.0 - Type-safe, non-relational, multi-backend persistence.  http://hackage.haskell.org/package/persistent-template-0.8.0 (MichaelSnoyman)
23:22:19 * hackagebot shakespeare 0.10.3 - A toolkit for making compile-time interpolated templates  http://hackage.haskell.org/package/shakespeare-0.10.3 (MichaelSnoyman)
23:22:21 * hackagebot shakespeare-css 0.10.7 - Stick your haskell variables into css at compile time.  http://hackage.haskell.org/package/shakespeare-css-0.10.7 (MichaelSnoyman)
23:27:23 * hackagebot shakespeare-i18n 0.0.1 - A type-based approach to internationalization.  http://hackage.haskell.org/package/shakespeare-i18n-0.0.1 (MichaelSnoyman)
23:27:25 * hackagebot shakespeare-js 0.11.0 - Stick your haskell variables into javascript/coffeescript at compile time.  http://hackage.haskell.org/package/shakespeare-js-0.11.0 (MichaelSnoyman)
23:27:28 * hackagebot shakespeare-text 0.10.4 - Interpolation with quasi-quotation: put variables strings  http://hackage.haskell.org/package/shakespeare-text-0.10.4 (MichaelSnoyman)
23:27:29 * hackagebot warp-tls 1.1.1 - SSL support for Warp via the TLS package  http://hackage.haskell.org/package/warp-tls-1.1.1 (MichaelSnoyman)
23:27:32 * hackagebot http-enumerator 0.7.3 - HTTP client package with enumerator interface and HTTPS support.  http://hackage.haskell.org/package/http-enumerator-0.7.3 (MichaelSnoyman)
23:36:02 <scolobb> Hello :-) I'd like to try to participate in GSoC-2012 under the guidance of the Haskell community.  I'd like to do some bug-fixes or other not-that-big tasks
23:36:24 <scolobb> Is this place http://hackage.haskell.org/trac/summer-of-code/report/1 the only place to search for ideas of such minor contributions?
23:36:49 <scolobb> I can see the ideas aren't that simple here :-)
23:37:03 <yitz> scolobb: normally participants take upon themselves an entire project
23:37:05 * hackagebot asn1-data 0.6.1.3 - ASN1 data reader and writer in RAW, BER, DER and CER forms  http://hackage.haskell.org/package/asn1-data-0.6.1.3 (VincentHanquez)
23:37:28 <scolobb> yitz: Absolutely
23:37:48 <yitz> scolobb: oh ok then sure
23:37:53 <scolobb> But before that, they normally start with some bugfixes to show their sanity :-)
23:38:41 <yitz> scolobb: well that's before GSoC :). But yeah, some of the projects have been far too ambitious, and for that reason were not successful.
23:39:18 <scolobb> yitz: Indeed :-)
23:39:35 <scolobb> Do you maybe know people/nicks who would like to be mentors in this summer?
23:39:55 <scolobb> The point is that I'd like to find people to talk to about the ideas which I liked from that page
23:40:27 <yitz> scolobb: look here: http://hackage.haskell.org/trac/summer-of-code/wiki/Soc2011
23:40:46 <yitz> scolobb: it's from last year's. i don't see a page for this year yet, but that should give you the idea.
23:41:16 <Jafet> lol http://hackage.haskell.org/trac/summer-of-code/ticket/1604
23:41:52 <scolobb> yitz: Thank you :-) Somehow this page wasn't linked from the official GSoC-2011 page :-/
23:42:45 <scolobb> Jafet: The ticket sounds reasonable to me :-)
23:43:56 <Jafet> It seems that most of the tickets are about Haskell, and not so much about stuff written in Haskell
23:44:10 <Jafet> To be fair, there isn't that much stuff written in Haskell that isn't about Haskell
23:45:02 <ion> Embedding Haskell in PHP
23:45:18 <scolobb> ion: HaskellScript in HTML ;-)
23:45:36 <scolobb> Jafet: Sounds sad
23:46:01 <Jafet> Not necessarily. A lot of people use Haskell to study Haskell
23:47:02 <yitz> Jafet: there is plenty written in haskell, but that's not what GSoC is about
23:48:26 <Blkt> good morning everyone
23:56:19 <DijkstraGroupie> Hello. Noob question here: How do I tell what algorithm is used to compute something in a language like Haskell?
23:57:15 <ski> you look at the source code in question, as always ?
23:57:21 <franco00> I have a bit of a problem with my haskell program. When I compile it on win32 is works as expected, but that is not so under debian. It is a simple command line address book: can I ask you to download the (very short) .hs and do what written in the instructions? www.francopetri.com/stuff/maddress.rar I am quite puzzled by the problem...
23:57:51 <DijkstraGroupie> ski: When I look at a Haskell program, what I see is a lot of definitions.
23:58:00 <DijkstraGroupie> (Definitions as in "mathematical definitions")
23:58:01 <ski> yes ?
23:58:30 <DijkstraGroupie> ski: If all of those definitions were to be evaluated at runtime, the program would be terribly inefficient.
23:58:58 <ski> i think that depends on *how* you evaluate them
23:59:35 <DijkstraGroupie> ski: Aha! So the compiler must perform some sort of optimization in order to reduce the computational complexity of the evaluation of those definitions.
23:59:41 <DijkstraGroupie> ski: Am I right?
23:59:43 <Axman6> DijkstraGroupie: that's what you think. this is why we have a very smart compiler
