00:00:29 <monad_> I added a case statement in IO Monad and want to check different constants in one case branch. Does Haskell support this?
00:00:37 <Enigmagic> shachaf: yes it will make a system call for each chunk
00:01:28 <c_wraith> osa1: I don't think there are any good ones, at the moment
00:02:18 <ChristianS> osa1: well, there are json und json2, but i don't know how good they are at laziless and whether they lack anything you need
00:02:22 <c_wraith> osa1: you can see if it fits in memory
00:02:26 <Enigmagic> monad_: look up pattern guards
00:02:38 <osa1> c_wraith: yeah I think I'll try that
00:02:59 <Enigmagic> monad_: err just regular guards
00:03:18 <ChristianS> c_wraith: why is aeson so much bettr than the alternatives?
00:03:46 <osa1> if reading xml's lazily is possible I can export the database as xml
00:04:45 <ChristianS> osa1: couldn't you just read the db directly, instead of exporting into a file?
00:05:13 <c_wraith> ChristianS: good support for automatically creating ToJSON and FromJSON instances for your type, in a couple different ways.  Really good combinators for writing manual instances, in the cases where the automatic instances don't do what you need.  High performance.
00:05:56 <osa1> ChristianS: I don't have a database server installed on my machine
00:05:56 <monad_> Enigmagic: But then I have to setup a new function only for this check. Is there no possibility like that one: case expr of 1 | 0 -> foo; _ -> bar
00:06:54 <ChristianS> monad_: the more functions your programs has, the better. keep each of your functions specialized and short.
00:07:01 <ChristianS> c_wraith: i see, thanks
00:07:20 <Enigmagic> monad_: case expr of 1 | 0 -> foo; _ -> bar should work
00:07:41 <c_wraith> except 0 isn't a boolean value
00:07:55 <monad_> Enigmagic: But does it 1 AND 0 evalute to foo and the rest to bar?
00:08:31 <Enigmagic> c_wraith: i'm tired :)
00:09:03 <ClaudiusMaximus> > case 2 of y | y == 0 || y == 1 -> "01" ; z -> show z
00:09:04 <lambdabot>   "2"
00:09:09 <ChristianS> monad_: the boolean operators  && || not  work only on booleans
00:09:52 <monad_> Enigmagic: let f expr = case expr of 1 | 0 -> "foo"; _ -> "bar" yields an error in ghci
00:10:47 <Enigmagic> monad_: case expr of x | x == 1 || x == 0 -> "foo"; _ -> "bar"
00:11:10 <monad_> <Enigmagic>: ok I will go with that
00:11:13 <ClaudiusMaximus> :t \e -> case e of 1 | ?e -> e
00:11:14 <lambdabot> forall t. (Num t, ?e::Bool) => t -> t
00:11:28 <strager> hmm, I didn't know you can add guards to case expressions.
00:11:49 <c_wraith> strager: you can attach where blocks to branches in a case expression, too
00:12:29 <strager> Yeah, I know that (though I don't use that often)
00:13:31 <monad_> let f expr = case expr of x | x `elem` [0,1] -> "foo"; _ -> "bar"
00:13:48 <c_wraith> that's a good solution
00:18:06 <ChristianS> monad_: unless i misunderstood something, you could also use if then else:  let f x = if x `elem` [0,1] then "foo" else "bar"
00:18:29 <monad_> ChristianS: Unfortunately there are more cases
00:18:40 <monad_> ChristianS: This was just a simple example
00:19:14 <monad_> let f expr = case expr of x | x `elem` [0,1] -> "foo"; 2 -> "bar", otherwise -> "barbar"
00:19:36 <monad_> I dont want to build nested ifs
00:20:18 <srhb> Does anyone use FranTK? Most of the links the Wiki refers to are dead.
00:24:30 <ddarius> srhb: Isn't that super old?
00:25:00 <srhb> ddarius: Looks like it might indeed be, yes. It should probably be removed from the GUI Libraries Wiki then, I guess, or at least carry a disclaimer.
00:25:13 <srhb> Most of that page seems horribly outdated. The Wiki is really stale in general. Spooky.
00:28:15 <Axman6> does anyone else feel it would be useful to have a function with the type Handle -> L.ByteString -> IO Int, which tells you how long the bytestring was that was written? if you need to know the length, and do the writing, using length and then writing causes the whole thing to be evaluated and kept in memory, losing any advantages you'd have from lazy construction
00:28:51 <ddarius> Axman6: What is your use case?
00:29:38 <Axman6> i've got some code that creates a bytestring lazily, whose size i need, as well as writing it to disk, but calling length on it means it gets evaluated before being written, and sticks in memory
00:31:15 <ddarius> In my experience, you usually need, or at least want, the size before writing out the value.
00:31:57 <ddarius> There's also the possibility that it may make more sense for the producer to tell you the length.
00:32:49 <Axman6> well, this is for a compression program (/assignment), and i'm writing the the number of bytes before compression instead of the bytes after
00:35:15 <Axman6> but, i also need the number of bytes written so i can print out the compression ratio
00:37:38 <ddarius> Axman6: If you were going to write a function like this, you should make it more general so that it is a fold as you output.
00:38:57 <Axman6> like, hFoldBS :: Handle -> (a -> BS.ByteString -> a) -> BL.ByteString -> IO a?
00:39:21 <ddarius> You'd need an initial value as well.
00:39:21 <Axman6> actually, there's a more general version using IO there, but anyway
00:39:26 <Axman6> yeah
00:40:06 <Axman6> Monad m => a -> (a -> BS.ByteString -> m a) -> BL.ByteString -> m a
00:41:02 <ddarius> @hoogle foldM
00:41:02 <lambdabot> Control.Monad foldM :: Monad m => (a -> b -> m a) -> a -> [b] -> m a
00:41:03 <monad_> I have a problem with a gtk-demo program: see http://hpaste.org/64480
00:41:03 <lambdabot> Control.Monad foldM_ :: Monad m => (a -> b -> m a) -> a -> [b] -> m ()
00:41:03 <lambdabot> Data.Foldable foldMap :: (Foldable t, Monoid m) => (a -> m) -> t a -> m
00:41:13 <monad_> The accelerator "Ctrl+n" does NOT work
00:41:26 <ddarius> @hoogle traverse
00:41:26 <lambdabot> Data.Traversable traverse :: (Traversable t, Applicative f) => (a -> f b) -> t a -> f (t b)
00:41:27 <lambdabot> Data.Foldable traverse_ :: (Foldable t, Applicative f) => (a -> f b) -> t a -> f ()
00:41:27 <lambdabot> Control.Parallel.Strategies parTraverse :: Traversable t => Strategy a -> Strategy (t a)
00:41:29 <monad_> Does this depend on my gtkhs version?
00:41:31 <ddarius> @hoogle traverseM
00:41:31 <lambdabot> No results found
00:42:37 <Axman6> i guess it is basically foldM . toChunks
00:42:40 <monad_> Or do I have to add an accelerator by hand? But then why are accelerators displayed in the menu?
00:42:45 <Axman6> (hand wavey)
00:48:15 <monad_> any ideas?
00:55:29 <t7> can the new GADT stuff define finite natural numbers?
00:57:49 <srhb> The old stuff could too, couldn't it? You would just need as many value constructors as your "finity" :-)
00:58:35 <t7> i want type level :3
01:27:42 <sohum> @pl \a b -> a
01:27:42 <lambdabot> const
01:27:53 <sohum> @pl \a b -> b
01:27:53 <lambdabot> const id
01:41:59 <aadrake> Morning #haskell.  I am trying to build the yesod client listed on the website, but I get an error that GHC cannot find module 'Network.HTTP.Conduit', but cabal install http-conduit says that it's already installed.  Am I missing something?
01:43:07 <pozic> aadrake: if the instructions don't work, ask to whoever distributed it and said it would work.
01:44:40 <stefan__> hi guys
01:44:47 <stefan__> i ve got a question
01:45:40 <stefan__> i use hugs with linux mint but everytime i use a class like sort i get the request it would be an undefined variable
01:45:47 <stefan__> what is my mistake?
01:46:23 <Phlogistique> stefan__: you need to give more precision
01:46:31 <Phlogistique> also, Hugs is kind of deprecated
01:47:05 <stefan__> my computer science teacher uses it
01:47:14 <stefan__> sorry about my poor englisch btw
01:47:23 <stefan__> so i thought it would work fine
01:47:30 <stefan__> what else would you recommend?
01:54:21 <Cale> stefan__: Can you say more precisely what you're putting into hugs?
01:55:07 <Cale> stefan__: The standard function 'sort' is in the module called Data.List, so that module needs to be imported in order to use it
01:55:31 <Cale> I believe in Hugs, the appropriate command is :also Data.List
01:55:34 <stefan__> where should this module be
01:55:52 <Cale> You can also just write   import Data.List   at the top of your program
01:56:19 <Cale> (which you'll have to do if you want to use sort in your .hs file, and not just at the hugs prompt)
01:56:41 <stefan__> thx that works fine
01:56:46 <Cale> great :)
01:56:56 <stefan__> are there any other classes i will need to use the programm?
01:57:08 <stefan__> (for beginners) ^^
01:58:16 <Cale> There are a lot of modules containing many useful things... It depends on the sorts of programs you tend to write, but some fairly common ones are Control.Monad and System.IO
01:58:35 <stefan__> k thanks a lot
01:58:39 <Cale> http://cvs.haskell.org/Hugs/pages/libraries/
01:58:40 <stefan__> one last question
01:58:47 <Cale> has an index of the libraries which come with Hugs
01:58:58 <stefan__> my prof gave us the file programs.hs
01:59:15 <stefan__> how could i link this to hugs
01:59:15 <stefan__> ?
01:59:34 <Cale> You can run hugs on the commandline as   hugs programs.hs
01:59:43 <Cale> or you can load it from inside hugs
01:59:54 <Cale> with  :load programs.hs
02:00:10 <Cale> (or you can use  :also  there as well)
02:00:14 <aadrake> pozic: Whomever distributed what?  http-conduit?
02:00:39 <stefan__> k again thanks a lot
02:00:43 <aadrake> pozic: In GHCI if I try to import Network.HTTP.Conduit I get an error saying it's not there, but cabal install http-conduit says it's already installed.  That's what I'm confused about.
02:01:02 <aadrake> I'm probably missing something simple.
02:01:38 <ChristianS> aadrake: does "ghc-pkg list" list the package?
02:02:07 <Cale> You can type  ghc-pkg list http-conduit
02:02:12 <Cale> and it'll filter the listing :)
02:02:39 <stefan__> square x = x*x ERROR - Syntax error in input (unexpected `=')
02:02:52 <stefan__> do you've got any explenation fpr this?
02:02:57 <Cale> stefan__: Hugs can't take new definitions on its commandline
02:03:10 <Cale> stefan__: You'll need to put definitions into a file and then load the file
02:03:22 <Cale> (it only wants expressions to evaluate)
02:03:34 <Saizan> aadrake: see if "ghci -v" prints any warning related to http-conduit
02:03:42 <stefan__> thx Cale
02:04:07 <Saizan> aadrake: assuming you've already restarted ghci after installing the package
02:04:11 <Cale> aadrake: also try ghc-pkg check  to make sure your packages are all sane
02:04:27 <Cale> (if it says nothing, it's good)
02:04:30 <Saizan> sadly ghc-pkg check doesn't tell the whole story
02:06:48 * hackagebot hxournal 0.6.6 - A pen notetaking program written in haskell  http://hackage.haskell.org/package/hxournal-0.6.6 (IanWooKim)
02:16:49 * hackagebot stm 2.3 - Software Transactional Memory  http://hackage.haskell.org/package/stm-2.3 (SimonMarlow)
02:16:51 * hackagebot hxt 9.2.2 - A collection of tools for processing XML with Haskell.  http://hackage.haskell.org/package/hxt-9.2.2 (UweSchmidt)
02:17:38 <pozic> Why can't I use code like this? do char ' '; char '$'; string "::"; many1 (noneOf " ")
02:17:51 <pozic>   No instance for (Stream s0 m0 Char)
02:18:09 <pozic> I can see it is being interpreted as too general code.
02:19:26 <pozic> How can I display whether the monomorphism restrictions applies in ghci?
02:19:41 <pozic> I added a command line flag, but I don't know whether it is used.
02:20:25 <ClaudiusMaximus> let x = 5\n :t x  -- see if it's monomorphic?
02:21:37 <pozic> ClaudiusMaximus: thanks, I know where it comes from then.
02:21:49 * hackagebot Holumbus-Searchengine 1.2.2 - A search and indexing engine.  http://hackage.haskell.org/package/Holumbus-Searchengine-1.2.2 (UweSchmidt)
02:23:18 <pozic> ClaudiusMaximus: or ... perhaps this is a bug in ghc.
02:23:32 <pozic> ClaudiusMaximus: how can I really see the status of the flag?
02:24:57 <ClaudiusMaximus> pozic: :show languages -- only lists positive flags though
02:26:05 <ClaudiusMaximus> ( so it shows -XMonomorphismRestriction , or not listed for -XNoMonomorphismRestriction )
02:28:12 <pozic> ClaudiusMaximus: I got it working.
02:28:53 <pozic> Has there been any progress on eliminating the restriction efficiently?
02:29:08 <pozic> It doesn't seem an impossible problem to solve.
02:35:58 <t7> whats 'state { ...' in f# ?
02:40:13 <ziman> iirc, it's a workflow, similar to 'do { ...' in the State monad in Haskell
02:50:54 <efie> "cabal install gtk" tells me "No packages to be installed. All the requested packages are already installed." but if I try "cabal install gtk --reinstall" it says "setup.exe: Missing dependencies on foreign libraries: * Missing C libraries: kernel32, gthread-2.0, gtk-win32-2.0, gdk-win32-2.0,[...]" Can you tell me what is wrong?
02:57:36 <geekosaur> when you initially installed it you had pointed the appropriate environment settings to wherever the C gtk+ libraries are
02:57:47 <Lemmih> efie: You're missing dependencies on foreign libraries.
02:58:06 <geekosaur> you will need to find that out and re-point them, or if those libs got removed at some point they must be reinstalled
03:01:19 <efie> geekosaur: but these c libraries were installed when first "cabal install gtk"-ed, right?
03:02:46 <geekosaur> right.  it's not enough to just be installed, though; Windows has no concept of a standard location for development libraries, so you need to point to them somehow (usually a SET command)
03:03:25 <geekosaur> but I can't provide any details there as I'm not really a windows dev and I don't really know how you do that for the mingw toolchain
03:07:42 <efie> geetkosaur: anyway thanks; I think I know how to use the enviroment variables (pkg-config-path) but I'm a little bit confused because: I followed this guide http://www.haskell.org/haskellwiki/Gtk2Hs/Windows#Install_the_GTK.2FGlade_bundle and as described there I download a GTK/Glade bundle (which is installed to ...\program files\gtk+) and then I do again "cabal install gtk" - is this installed in the same folder? or somewhere in ..  \c
03:07:48 <Axman6> > let f xs = zipWith (++) (tails xs) (inits xs) in f "Hello"
03:07:49 <lambdabot>   ["Hello","elloH","lloHe","loHel","oHell","Hello"]
03:08:26 <Axman6> > let f xs = init $ zipWith (++) (tails xs) (inits xs) in f "Hello"
03:08:28 <lambdabot>   ["Hello","elloH","lloHe","loHel","oHell"]
03:08:35 <geekosaur> efie, I do not know, as I said I'm not really a windows developer
03:08:42 <Axman6> > let f xs = sort . init $ zipWith (++) (tails xs) (inits xs) in f "Hello"
03:08:43 <lambdabot>   ["Hello","elloH","lloHe","loHel","oHell"]
03:09:13 <Axman6> > let f xs = map head . sort . init $ zipWith (++) (tails xs) (inits xs) in f "Hello"
03:09:15 <lambdabot>   "Hello"
03:09:15 <efie> jup, I just said it because maybe someone else replies :)
03:09:34 <Axman6> > let f xs = map head . sort . init $ zipWith (++) (tails xs) (inits xs) in f "Hello, world!"
03:09:36 <lambdabot>   " !,Hdellloorw"
03:10:14 <he2> hello
03:10:26 <he2> where is the differnece between type and data?
03:11:05 <Axman6> he2: type just gives a new name to another type: type String = [Char], data makes a new data type: data Maybe a  = Nothing | Just a
03:11:13 <beginner>  I am following the Microsoft C9 course, any recommendation
03:11:20 <beginner> where should I go after it?
03:11:26 <beginner> sorry not course
03:11:27 <Axman6> beginner: LYAH:
03:11:29 <beginner> lessons I mean
03:11:30 <Axman6> @where lyah
03:11:30 <lambdabot> http://www.learnyouahaskell.com/
03:11:42 <he2> Axman6, thx
03:12:01 <beginner> Axman6, the C9 lessons
03:12:13 <beginner> I think covered all the things in LYAH
03:12:31 <Axman6> do they cover zippers?
03:12:35 <Axman6> and applicatives?
03:13:04 <efie> is there a way to just reinstall gtk?
03:14:01 <beginner> Axman6, alright, you have a point there
03:15:03 <ivanm> @where RWY
03:15:03 <lambdabot> I know nothing about rwy.
03:15:11 <ivanm> efie: the C stuff or the Haskell stuff?
03:15:20 <ivanm> and I doubt that the Haskell stuff is installed to the same directory as the C stuff
03:16:40 <efie> ivanm: i am missing these libraries, i don't know if they are installend and when where (so i can not point the environment variables there)
03:16:56 <shirt> how can i start a child process that is detached from the haskell process, so that it will live on if the haskell process ends?
03:17:45 <efie> does cabal install gtk install the c-libraries or the haskell stuff?
03:18:36 <ChristianS> @where RWH
03:18:36 <lambdabot> http://www.realworldhaskell.org/blog/ http://book.realworldhaskell.org/read/
03:18:52 <ChristianS> beginner: that's ^^ for the advanced stuff
03:19:46 <beginner> thanks
03:21:51 <geekosaur> efie, it installs haskell bindings.  I think at one point it was discussed having the windows libraries bundled, but I think the cabalization of gtk2hs made it moot (no good way to distribute the C libs)
03:34:09 <dzhus> What if I need a list of values of the same type class, but of different types?
03:35:46 <shachaf> dzhus: There's a standard answer to this question -- I think it's on the FAQ -- which often goes "you don't actually want to do that, because [...]".
03:35:54 <shachaf> Sometimes you do, and you can use existential types for that.
03:36:01 <shachaf> What's the type class?
03:36:27 <shachaf> Consider that e.g. a list of things in the typeclass Show is about as useful as a list of Strings.
03:37:36 <dzhus> shachaf: I used to do pattern-matching based dispatching for different objects of single type; I switched to typeclasses to get more type-checking, but now my lists are broken.
03:38:06 <shachaf> Type classes are pretty different from sum types.
03:38:13 <shachaf> What "more type-checking" are you getting in this case?
03:39:41 <ChristianS> typeclasses are useful if you actually don't care about the type of your value, but only expect it to have a certain property (e.g. be showable)
03:39:47 <dzhus> shachaf: What if I add new constructor but forget to add new case for pattern-matched function for that type.
03:39:52 <dzhus> ChristianS: exactly
03:40:04 <geekosaur> dzhus, there's a warning option for that
03:40:08 <dzhus> ChristianS: my code relies on having one function available for objects being processed
03:40:16 <shachaf> dzhus: GHC will warn you.
03:40:46 <dzhus> geekosaur: shachaf: yes, but it's dirties
03:40:49 <dzhus> *dirtier
03:41:08 <geekosaur> dirtier than using an existential?
03:41:11 <geekosaur> I doubt it
03:41:30 <shachaf> No, it's cleaner, if you have a closed set of values.
03:41:42 <shachaf> I don't think you've provided enough information to be able to usefully answer, though.
03:41:46 <ChristianS> dzhus: but "dispatching" sounds as if you DO care about the actual type. if you don't, then i don't yet understand your problem.
03:41:47 <geekosaur> (and if your response to that is that haskell should allow typeclasses without requiring an existential, then you don't understand typeclasses)
03:41:57 <shachaf> But I can still contradict you. :-)
03:42:39 <efie> I managed the c-library thing i gues... they seem to come with the "GTK/Glade.exe"bundle which should be installed to path without spaces, so "program files\..." wont work. now i can do "cabal install glade" and there aren't any errors concerning missing c-libraries anymore
03:43:03 <geekosaur> the no-spaces thing is pretty much normal, yes
03:43:44 <yitz> dzhus: type classes are very nice when you need them, but that is not very common. it is much more common for sum types to be the right tool.
03:45:35 <yitz> dzhus: why would a type class give more type checking than dispatching on the different constructors of a sum type?
03:46:17 <dzhus> yitz: explicit typecheck failure vs. compiler warning
03:46:25 <osa1> is there a way to match Map.empty?
03:46:38 <yitz> dzhus: what is failing?
03:47:21 <ClaudiusMaximus> > M.null M.empty
03:47:22 <lambdabot>   True
03:48:11 <geekosaur> osa1, as a pattern?  I don't believe so, since constructors are not exported.  Use a guard
03:48:12 <ChristianS> osa1: not with pattern matching, you'll have to do the null check (M.null ^^ ) in a guard expression
03:48:32 <osa1> what's a guard expression?
03:48:53 <geekosaur> foo m | M.null m = ...
03:49:19 <osa1> aha, ok, thanks
03:50:11 <yitz> dzhus: a common pattern is to have different types for different kinds of data, then have a data type that means "any one of those", with a different constructor wrapping each of the types.
03:50:41 <Peaker> I haven't thought this through completely, but I'd say: sum types are useful when you need closed-data, open-code.  Type-classes are typically useful when you need closed-code, open-data.
03:50:51 <yitz> dzhus: then if you have the sum type, you pattern match on the constructors to dispatch to functions of different types to handle each case.
03:51:05 <Peaker> In a project where you control both code and data, you can live with closed-*, so it matters less
03:51:17 <Peaker> and sum types are the smaller hammer
03:51:22 <hpaste> dzhus pasted ‚ÄúPattern-matching vs. typeclasses‚Äù at http://hpaste.org/64481
03:51:40 <yitz> dzhus: that is then fully type checked, and the compiler warning lets you know if you forgot one of the cases.
03:51:45 <dzhus> yitz: yes, box type
03:51:51 <yitz> dzhus: does that match your use case?
03:52:04 <quicksilver> it's *still* a total abuse of type classes
03:52:19 <quicksilver> even when you're closed-code, open-data you absolutely do not need type classes
03:52:32 <quicksilver> you just need higher order data - a "record of functions" or whatever.
03:52:50 <shachaf> @google existential antipattern
03:52:50 <geekosaur> which is what type clases are sugar for
03:52:52 <quicksilver> you only need typeclasses if you want the compiler to automatically infer the right record of functions at compile time.
03:52:52 <lambdabot> http://lukepalmer.wordpress.com/2010/01/24/haskell-antipattern-existential-typeclass/
03:52:52 <lambdabot> Title: Haskell Antipattern: Existential Typeclass ¬´ Luke Palmer
03:52:57 <quicksilver> geekosaur: no, they are not
03:53:09 <quicksilver> geekosaur: typeclasses are absolutely not sugar for a record of functions
03:53:12 <quicksilver> they're unsugar.
03:53:19 <quicksilver> they're a benighted bitter poison.
03:53:28 <ChristianS> dzhus: use a data type (as you did originally) and just take the compiler warnings seriously.
03:53:32 <quicksilver> they're a way to make a record of functions ugly, and buggy, and confusing, and mislead people.
03:53:54 <quicksilver> what typeclasses are, is a way to ask the compiler to select something at compile time based on type information
03:53:56 <shachaf> @remember quicksilver <quicksilver> typeclasses are absolutely not sugar for a record of functions <quicksilver> they're unsugar. <quicksilver> they're a benighted bitter poison.
03:53:56 <lambdabot> Done.
03:54:06 <quicksilver> (a.k.a. adhoc overloading)
03:54:14 <ChristianS> dzhus: -Wall is your friend, just don't consider your program bug-free until all warnings are fixed.
03:54:26 <quicksilver> when you want the compiler to use its type-knowledge to select something for you *then* typeclasses the right solution.
03:54:34 <quicksilver> not because of open-world or closed-world or existential or whatever.
03:54:43 <quicksilver> (you can use existentials without typeclasses - and you should, when that's the right solution)
03:54:47 <quicksilver> remember occam.
03:55:14 <dzhus> thank you all for the discussion, I'll revert my changes
03:56:14 <shachaf> Don't consider your program bug-free even when all warnings are fixed.
03:56:29 <ddarius> Don't consider your program bug-free.
03:56:41 <dzhus> yeah, that formal methods quote
03:56:49 <Peaker> quicksilver: Yeah, I guess my classification is wrong.  Type-classes are useful w.r.t records due to: A) they sort-of sneak in higher-ranked types (e.g: Can't make a Functor record in Haskell98).  B) They can contain things records can't (with extensions), such as type indices   C) They can do type magic (ala QuickCheck)   D) They can associate interesting semantics/record-selection with types
03:57:32 <Peaker> quicksilver: IIUC, you only mentioned D
03:59:49 <Peaker> quicksilver: which Prelude type-classes do you think would have been better as records?
03:59:56 <frerich2> I recently talked to a colleague (who recently started tinkering with Haskell, just like me) and he was toying with the idea of writing 'extremist Haskell' in which functions cannot call any other functions except those which were passed as arguments. Does anybody know whether annoyances and advantages of such an approach (maybe not as dogmatic) are discussed somewhere?
04:00:38 <frerich2> It sounds cumbersome to me, but I suspect it's useful for testing.
04:01:06 <Peaker> isn't that the definition of a combinator?
04:01:25 <ChristianS> one of the beauties of haskell are all the functions available, IMHO
04:02:31 <Peaker> frerich2: so can these functions do pattern-matching?
04:03:21 <beginner> How can I express this as guards: _ && _	  = False
04:04:31 <Axman6> | otherwise = False
04:04:32 <yitz> beginner: not foo || not bar = ...
04:05:06 <yitz> beginner: more likely what Axman6 said, if it's that last possiblity
04:06:13 <beginner> other than being syntactically difference, any advantage using one over another?
04:06:22 <beginner> *different
04:06:37 <ChristianS> otherwise is a synonym for True, it will *always* match
04:07:08 <ChristianS> you can use it in the last definition of a function as catch-all
04:08:52 <beginner> ok, thx
04:12:01 <efie> I have a .hs file which imports Graphics.UI.Gtk.[Glade] and .glade-file. compiling and making a .exe-file it works, but if I run the .exe it says "libglade-WARNING **: could not find glade file 'test.glade'" It definitivly is in the same folder as the .exe and there's no typo...
04:12:50 <beginner> actually what I really wanted to do is:
04:12:56 <beginner> True  && x  | x == True = True
04:13:08 <beginner> and I want to catch anything else as False
04:13:35 <beginner> something like _ && _ = False , but using guard expression
04:13:43 <ChristianS> beginner: you don't need guards, just use pattern matching for that
04:14:09 <beginner> ChristianS, I know but I was just wondering whether there is such thing using guards
04:14:31 <ChristianS> seems pointless to me
04:28:38 <creatizmo> print "Hello!"
04:30:57 <Peaker> > putStrLn "Hello!"
04:30:58 <lambdabot>   <IO ()>
04:31:48 <Number6> print "Is it me you're looking for?"
04:32:35 <tty7> > print "> print \"Hello\""
04:32:36 <lambdabot>   <IO ()>
04:32:49 <tty7> > "> print \"Hello\""
04:32:50 <lambdabot>   "> print \"Hello\""
04:39:49 <Axman6> > text "> print \"Hello!\""
04:39:50 <lambdabot>   > print "Hello!"
04:49:34 <creatizmo> Hello from Python world! $)
04:50:41 <Phlogistique> http://the-27th-comrade.appspot.com/blog/ahJzfnRoZS0yN3RoLWNvbXJhZGVyDAsSBUVudHJ5GOFdDA lol
04:52:58 <mike-burns> Whoa, you can do monads outside of Haskell?! And other such nonsense.
04:55:04 <creatizmo> import List  --	–ê–ª–≥–æ—Ä–∏—Ç–º –®–µ–Ω–Ω–æ–Ω–∞-–§–∞–Ω–æ shannon_fano:: [(Char, Double)] -> [(Char, [Char])] shannon_fano lst = zip (map fst lst) (map (\(x, y) -> g x $ h y) $ zip (f $ map snd lst) (map snd lst))  --	–í—ã—á–∏—Å–ª–µ–Ω–∏–µ —á–∞—Å—Ç–∏—á–Ω—ã—Ö —Å—É–º–º f:: [Double] -> [Double] f lst = init $ scanl (+) 0 $ reverse $ sort lst  --	–í—ã—á–∏—Å–ª–µ–Ω–∏–µ –±–∏–Ω–∞—Ä–Ω–æ–≥–æ –ø—Ä–µ–¥—Å—Ç–∞–≤–ª–µ–Ω–∏–µ —Ä–∞—Ü–∏–æ–Ω–∞–ª—å–Ω–æ–≥–
04:55:14 <creatizmo> sorry
04:55:39 <Phlogistique> mike-burns: yeah, this post makes no sense though
04:56:10 <creatizmo> sf:: [(Char, Double)] -> [(Char, [Char])] sf lst = zip (map fst lst) (map (\(a, b) -> init $ concat $ map show $ map fst $ take (ceiling $ negate $ logBase 2.0 b) $ iterate (\(c, d) -> properFraction (2.0 * d)) $ properFraction a) $ zip (init $ scanl (+) 0 $ reverse $ sort $ map snd lst) (map snd lst))
04:56:16 <Phlogistique> what it basically says is "when you use an "if" statement, it looks a little like the maybe monad, therefore every python object is a monad"
04:56:19 <hpaste> erus` pasted ‚Äúmeh‚Äù at http://hpaste.org/64483
04:56:45 <Botje> creatizmo: please don't paste that in the channel. put it on hpaste or something.
04:56:47 <Axman6> creatizmo: please don't paste nonsense to the channel. if you want to show us the code, use a paste website like hpaste:
04:56:50 <Axman6> @where hapste
04:56:50 <lambdabot> I know nothing about hapste.
04:56:57 <mike-burns> Phlogistique: Hah, oh, I didn't read closely. That's too bad.
04:57:00 <hpc> @where hpaste
04:57:00 <lambdabot> http://hpaste.org/
04:57:01 <Axman6> @where hpaste
04:57:01 <lambdabot> http://hpaste.org/
04:58:53 <hpaste> ‚ÄúGleb Creatizmo Pospelov‚Äù pasted ‚ÄúShannon-Fano algorithm‚Äù at http://hpaste.org/64484
04:59:39 <Botje> creatizmo: that is some scary code.
05:00:06 <mike-burns> Needs more names.
05:01:24 <otters> what does that do
05:01:36 <creatizmo> =)
05:01:55 <otters> afaict it summons yog-sothoth
05:06:37 <Axman6> so, i know what shannon-fano coding does, and I couldn't for the life of me figure out how that implemented it, if it indeed does
05:11:05 <Taneb> What's the difference between boxed and unboxed?
05:13:24 <hpc> http://www.haskell.org/haskellwiki/Unboxed_type
05:15:04 <hpc> so basically, unboxed values are ones that don't get the full thunky pointery treatment of regular values
05:15:19 <Taneb> Hmm...
05:15:20 <hpc> if you stretch your brain a bit, it's like the primitive/object distinction in java
05:15:27 <Taneb> I don't know Java
05:15:31 <hpc> nvm then :P
05:18:04 <quicksilver> Peaker: interesting, (A) hadn't occurred to me. Too used to higher-rank types I guess.
05:18:22 <quicksilver> Peaker: no idea what 'magic' you mean by (C) though.
05:19:27 <quicksilver> Peaker: you can of course write "data Functor f a b = MkFunctor ((a -> b) -> (f a -> f b))
05:19:43 <quicksilver> but that doesn't force you to only write polymorphic 'instances'
05:20:31 <hpc> quicksilver: he means the magic it uses to fill in function arguments
05:20:38 <hpc> @check \xs -> xs == reverse xs
05:20:38 <lambdabot>   "OK, passed 500 tests."
05:20:47 <hpc> @check \xs ys -> xs == ys
05:20:48 <lambdabot>   "OK, passed 500 tests."
05:21:10 <hpc> (pretend those types were more interesting than [()] and ())
05:21:57 <hpc> polymorphic recursion, etc
05:22:22 <quicksilver> but that's not magic
05:22:27 <quicksilver> that's just the language working as it does
05:22:35 <quicksilver> it's not different from other typeclasses, is it?
05:22:48 <quicksilver> it does require the compiler to 'select' the right instances for the types involved
05:22:54 <hpc> quicksilver: his point is that it's one thing that makes type classes different
05:22:58 <quicksilver> which is precisely my definition of what type classes are for.
05:23:07 <quicksilver> no, his point was that it was a *different* thing from the thing I already mentioned
05:23:13 <quicksilver> as far as I can see, it's the same thing
05:23:18 <quicksilver> albeit a particularly interesting example.
05:23:23 <hpc> ah
05:23:43 <hpc> (that's pushing the edge of my scrollback)
05:23:56 <quicksilver> typeclasses are for when you want the compiler to make a choice for you, based on its type information about yoru program.
05:24:14 <hpc> kind of a limited type-case, as it were
05:24:15 <quicksilver> this can lead to great conciseness/cleverness if it ends up making many choices for you in a small space
05:24:24 <quicksilver> as in polymorphic recursion like you just suggested.
05:25:00 <hiptobecubic> polymorphic recursion?
05:25:17 <hpc> hiptobecubic: suppose you had something like
05:25:17 <quicksilver> when a function calls "itself" but at a different type.
05:25:25 <hpc> data Matrix a = Matrix [[a]]
05:25:38 <hpc> that is, a type for 2D lists
05:25:52 <hpc> instance Functor Matrix where
05:26:11 <hpc> fmap f (Matrix xss) = fmap (fmap f) xss
05:26:30 <hiptobecubic> hpc doesn't that fail though? the m a = m [[a]] ?
05:26:34 <hpc> fmap is recursive, but uses different instances
05:27:25 <hpc> er, fmap f (Matrix xss) = Matrix (fmap (fmap f) xss)
05:27:45 <hiptobecubic> Why wouldn't it translate Matrix Bool to Matrix [[Bool]] to [[[[Bool]]]]....
05:28:25 <hpc> hiptobecubic: it's how data declarations work
05:28:50 <hpc> hiptobecubic: try it in your own ghci
05:29:34 <hpc> in any event, the types of fmap are, from left to right
05:29:44 <hpc> (a -> b) -> Matrix a -> Matrix b
05:29:52 <hpc> (a -> b) -> [[a]] -> [[b]]
05:30:02 <hpc> er
05:30:10 <hpc> ([a] -> [b]) -> etc
05:30:20 <hpc> and the last is (a -> b) -> [a] -> [b]
05:30:41 <hpc> polymorphic recursion is when the next iteration uses different types
05:30:57 <hiptobecubic> oh
05:31:42 <hiptobecubic> i see, ok
05:32:00 <hpc> it doesn't look like recursion to me, personally
05:32:13 <hpc> but just because my brain interprets the different fmaps as different functions
05:33:20 <hpc> you'll see polymorphic recursion a lot in transformers code, for instance
05:33:37 <hiptobecubic> I'm not familiar with transformers yet
05:34:38 <hpc> one place you'll see it is liftIO
05:40:04 <hiptobecubic> hpc, do you do hpc? in haskell?
05:42:03 <hpc> "hpc" is a shortening of an old nickname
05:42:20 <hiptobecubic> wasn't mine, was it?
05:42:31 <hpc> no :P
05:47:11 <mint> hello everyone
05:47:26 <mint> ERROR - Cannot find "show" function for:
05:47:33 <mint> i got this line all the time
05:47:42 <antonh_> @type (%!)
05:47:43 <lambdabot> Not in scope: `%!'
05:47:47 <mint> has anybody got an idea how to solve this problem?
05:48:00 <mike-burns> What are you doing to cause this?
05:48:11 <antonh_> what is %!
05:48:27 <hpc> @hoogle (%!)
05:48:28 <lambdabot> No results found
05:48:33 <hpc> antonh_: nothing, it seems
05:49:02 <mint> i want to get the perfect numbers
05:49:27 <srhb> mint: Are you using your own datatype?
05:49:28 <antonh_> hpc, it has to be something :)
05:49:29 <hpc> @where hpaste
05:49:29 <lambdabot> http://hpaste.org/
05:49:47 <hpc> mint: can you paste your code here? ^
05:49:54 <mint> i use a data from my science teacher
05:50:12 <srhb> Which does not derive show, so it cannot be printed?
05:50:16 <mint> perfect n = sumList [ x | x <- [1.. (div n 2)], mod n x == 0] == n  sumList [] = 0 sumList (x:xs) = x + sumList xs
05:50:36 <mint> omg looks awful
05:50:43 <mint> perfect n = sumList [ x | x <- [1.. (div n 2)], mod n x == 0] == n
05:50:48 <mike-burns> You can use hpaste.
05:50:53 <srhb> mint: hpaste.org
05:50:53 <hpc> :t let perfect n = sumList [ x | x <- [1.. (div n 2)], mod n x == 0] == n; sumList [] = 0; sumList (x:xs) = x + sumList xs in perfect
05:50:54 <lambdabot> forall a. (Integral a) => a -> Bool
05:52:05 <mint> i get the same mistake again
05:52:55 <antonh_> hpc, it was not haskell specific.. (%!) was specified in the source i was reading.
05:53:36 <srhb> > perfect 10
05:53:37 <lambdabot>   Not in scope: `perfect'
05:53:41 <srhb> aw
05:54:16 <hpc> @let perfect n = sumList [ x | x <- [1.. (div n 2)], mod n x == 0] == n; sumList [] = 0; sumList (x:xs) = x + sumList xs
05:54:19 <lambdabot>  Defined.
05:54:21 <hpc> > perfect 10
05:54:23 <lambdabot>   False
05:54:29 <Entroacceptor> > perfect 6
05:54:30 <hpc> > map perfect [1..]
05:54:31 <lambdabot>   True
05:54:32 <lambdabot>   [False,False,False,False,False,True,False,False,False,False,False,False,Fal...
05:54:33 <danr> > perfect 20
05:54:35 <lambdabot>   False
05:54:45 <danr> > perfect 496
05:54:46 <lambdabot>   True
05:54:54 <hpc> > filter perfect [1..]
05:54:57 <lambdabot>   mueval-core: Time limit exceeded
05:55:05 <hpc> > take 5 . filter perfect $ [1..]
05:55:06 <danr> > take 4 $ filter perfect [1..]
05:55:06 <lambdabot>   can't find file: L.hs
05:55:09 <lambdabot>   mueval-core: Time limit exceeded
05:55:14 <hpc> > take 3 . filter perfect $ [1..]
05:55:15 <lambdabot>   [6,28,496]
05:55:18 <hpc> lol
05:55:20 <danr> success!!
05:56:13 <danr> related sequence: http://oeis.org/A094540
05:58:03 <srhb> mint: Were you maybe trying to call just "perfect"? Because the code doesn't seem to have anything wrong with it.
06:00:07 <Entroacceptor> srhb: he left
06:01:17 <Liii> "cabal install" seems to delete the source files of a package after compilation and installation. Can I make it save the source code of an installed package?
06:03:58 <Entroacceptor> Liii: does "cabal unpack"
06:04:13 <Liii> Alright, thanks!
06:04:19 <Entroacceptor> or fetch
06:10:01 <mux> I was so happy that the guy owning the mux username on bitbucket was kind enough to switch to another one to let me have it, that I didn't realize I just broke every URL pointing at my code in the haskell packages I have uploaded on hackage
06:10:11 <mux> :-/
06:10:25 <Clint> them's the breaks
06:16:50 <MagneticDuck> Hey, could somebody explain how to use lambdabot messages? Somebody was telling me about them yesterday...
06:17:05 <MagneticDuck> You know what I'm talking about>
06:17:57 <MagneticDuck> How to send a message to somebody on the IRC channel?
06:18:08 <Phlogistique> MagneticDuck: like this.
06:18:16 <Phlogistique> or like this:
06:18:27 <Phlogistique> > print 'MagneticDuck: like this'
06:18:27 <lambdabot>   <no location info>:
06:18:28 <lambdabot>      lexical error in string/character literal at chara...
06:18:32 <Phlogistique> > print "MagneticDuck: like this"
06:18:32 <lambdabot>   <IO ()>
06:18:48 <Phlogistique> oh, it doesn't work.
06:19:22 <MagneticDuck> Do I have to check my messages?
06:19:26 <MagneticDuck> ??
06:19:33 <mike-burns> /msg MagneticDuck Like this.
06:19:34 <ChristianS> @tell MagneticDuck This is how you send a message to somebody who is not currently here (or who doesn't listen).
06:19:34 <lambdabot> Consider it noted.
06:19:52 <MagneticDuck> And now, how do I read it?
06:19:52 <lambdabot> MagneticDuck: You have 1 new message. '/msg lambdabot @messages' to read it.
06:19:58 <ChristianS> mike-burns: that's not what MagneticDuck means, the lambdabot way is
06:20:04 <ChristianS> MagneticDuck: lambdabot just told you
06:20:18 <MagneticDuck> Yay! It worked!
06:20:24 <mike-burns> Oh.
06:20:48 <MagneticDuck> So, how does lambdabot do that?
06:20:54 <ChristianS> magic
06:21:14 <MagneticDuck> Along with vacuum cleaners and lightbulbs.
06:21:22 <MagneticDuck> :D
06:22:09 <ChristianS> any sufficiently advanced haskell program is indistinguishable from magic.
06:22:19 <ChristianS> except that magic doesn't usually typecheck.
06:23:39 <MagneticDuck> @tell jay_gridley Sorry I didn't send the email... I missed your address! The code's posted on hpaste.org, though, here: http://hpaste.org/64439
06:23:39 <lambdabot> Consider it noted.
06:23:40 <hiptobecubic> Freenode also has mesgserv
06:24:27 <hiptobecubic> or is it memo...?
06:24:35 <ChristianS> MagneticDuck: i already tried to relay your message to jay_gridley in the same way, but i don't know whether he got it.
06:24:45 <hiptobecubic> memoserv
06:24:55 <MagneticDuck> Okay, now he has two messages...
06:25:09 <ChristianS> lambdabot will only tell people if they speak up in the channel, so if they aren't here or don't speak, it won't help...
06:25:21 <hiptobecubic> memoserv is everywhere, i think
06:25:25 <Kunal> This is awesome!
06:25:27 <N7_> hi
06:25:29 <N7_> hello there
06:25:32 <N7_> wazup?
06:25:35 <MagneticDuck> HELLO THERE!
06:25:38 <N7_> hello
06:25:40 <N7_> who are you?
06:25:50 <Guest51845> Donald Duck's cousin?
06:25:52 <MagneticDuck> MAGNETICDUCK! I LIKE CAPITAL LETTERS!
06:25:56 <Guest51845> WOW
06:25:57 <Guest51845> REALLY?
06:26:06 <Guest51845> WE APPEAR TO BE SCREAMING
06:26:08 <Guest51845> THIS WAY
06:26:15 <MagneticDuck> Ow, ow, stop! My ears hurt!
06:26:21 <ChristianS> hiptobecubic: no, no memoserv here or in the other channels i'm in
06:26:26 <Guest51845> wel
06:26:27 <Guest51845> well
06:26:30 <MagneticDuck> welll
06:26:32 <Guest51845> I'm new to Haskell
06:26:39 <MagneticDuck> Cool.
06:26:46 <Guest51845> what kind of language is it?
06:26:52 <MagneticDuck> FUNCTIONAL!
06:26:54 <MagneticDuck> AWESOME!
06:26:55 <Guest51845> no shit
06:26:56 <ChristianS> lazy
06:26:58 <Guest51845> I already know that
06:27:02 <Guest51845> I'm lazy
06:27:14 <hiptobecubic> ChristianS, no but I think it's integrated, no? Like Nickserv
06:27:19 <Guest51845> Where do you use Haskell? Not in web sites I presume
06:27:23 <danr> @where ops
06:27:23 <lambdabot> shapr Cale glguy dons sjanssen dcoutts Saizan dibblego conal Philippa bos arjanb xerox Heffalump kosmikus wli Pseudonym Igloo quicksilver monochrom Lemmih jmcarthur copumpkin
06:27:33 <hiptobecubic> Guest51845, some people do, with yesod
06:27:44 <MagneticDuck> Guest51845: Anywhere. Desktop applications, iPhone apps...
06:27:45 <Guest51845> where else?
06:27:50 <Guest51845> standalone software?
06:27:54 <ChristianS> sure
06:28:17 <Guest51845> From what I read I can see it's a slow-performance language
06:28:21 <hiptobecubic> Well I'm pretty terrible, so I use it to inefficiently solve trivial problems.
06:28:22 <Guest51845> that allocates a lot of memory for you
06:28:27 <Guest51845> would you say it's meant for beginners?
06:28:38 <MagneticDuck> Well, that's because you're running it on a web page.
06:28:40 <hiptobecubic> Guest51845, it's not C. It's also not python, though.
06:28:46 <MagneticDuck> NO! IT'S NOT FOR BEGINNERS!
06:29:01 <hiptobecubic> It doesn't have to not be for beginners.
06:29:07 <dmwit> ?wiki Haskell in industry
06:29:07 <lambdabot> http://www.haskell.org/haskellwiki/Haskell_in_industry
06:29:15 <MagneticDuck> Yeah, true...
06:29:16 <hiptobecubic> But perhaps it's not the easiest language to learn if you don't know anything about programming
06:29:24 <ChristianS> good haskell programs can be almost as fast as c, and (if you're using laziness correctly) they don't use much memory
06:29:36 <Guest51845> The pieces of code I looked at seem rather complicated and I know a lot of languages
06:29:46 <MagneticDuck> Well, they can be!
06:29:52 <hiptobecubic> ChristianS, that's the hardest part though. Figuring out where and when you can lean on the lazy-qualities
06:30:17 <sipa> Guest51845: typically, knowing many (imperative) languages will hinder you at first when learning Haskell
06:30:25 <MagneticDuck> But you'll also see that Haskell is really elegant.
06:30:36 <Guest51845> i know many imperative languages like C, C++, Java, PHP, and so on
06:30:39 <sipa> It's really a different way of thinking about programs.
06:30:44 <ChristianS> hiptobecubic: in fact i think haskell can be harder to get for programmers than for newbies, because it's so very different from other languages.
06:31:03 <Guest51845> it's kinda confusing
06:31:05 <MagneticDuck> > unwords . reverse . words $ "this is a test"
06:31:06 <Guest51845> not intuitive
06:31:06 <lambdabot>   "test a is this"
06:31:15 * applicative had no difficulty learning Haskell before learning anything else
06:31:26 <Guest51845> unwords
06:31:26 <MagneticDuck> Well, after you get a hang of it, you'll like programming in it much better.
06:31:27 <ChristianS> @where lyah
06:31:27 <lambdabot> http://www.learnyouahaskell.com/
06:31:33 <hiptobecubic> Guest51845, it's not intuitive if you're coming from a language that does things completely differently, no.
06:31:38 <ChristianS> Guest25308: try that ^^ for a start
06:31:43 <Peaker> quicksilver: regarding magic, I mean stuff like make a function to feed arbitrary inputs to all left-sides of (->) (as QuickCheck does)
06:31:52 <applicative> It's very intuitive if you just come from thinking, though
06:31:56 <ChristianS> Guest25308: you knowledge of java and such will only make haskell more confusing for you
06:31:59 <Guest51845> I don't agree
06:32:09 <Guest51845> I think even for beginners a language like java is much more like the real world
06:32:17 <hiptobecubic> Guest51845, most people think OSX is unintuitive, after working in Windows for years, but no one seems to have trouble starting with it from scratch. (often with more success than windows)
06:32:17 <Guest51845> Person p = new Person();
06:32:19 <applicative> What is that famous line about learning lisp?
06:32:21 <Guest51845> very easy to understand ^^^
06:32:29 <sipa> Guest51845: You're used to automatically translate a given problem in your mind to some imperative algorithm for solving it, so you'll start to ask questions like "but how do I write a for loop?", while the good question is "How do I solve this problem in a functional way?".
06:32:30 <Peaker> quicksilver: We differ in opinion of course, as I think there are too few type-classes in the standard libs, and you think there are too many. Converting strict/lazy bytestrings to one another is no fun
06:32:54 <MagneticDuck> Yeah, but in Haskell, we don't even have to write "Person p = new Person();"!
06:33:03 <Peaker> Guest51845: You're projecting -- we shape our tools, then our tools shape us. It's very difficult to think outside our own mind
06:33:16 <MagneticDuck> True, Peaker.
06:33:25 <hiptobecubic> I all you have is a hammer, everything looks like a thumb, they say
06:33:28 <Guest51845> Right, it's only my opinion lol
06:33:31 <sipa> hiptobecubic: lol
06:33:32 <ChristianS> Peaker: actually, bytestring conversion is trivial
06:33:37 <Guest51845> but
06:33:40 <Guest51845> new person is plain english
06:33:46 <Guest51845> anyone who knows english will get it
06:33:48 <Guest51845> very quickly
06:33:56 <Peaker> ChristianS: and not fun. I rarely care about which bytestring I have to use, but the libraries I use are forced to care
06:33:56 <MagneticDuck> Actually, Haskell is easier to read out loud!
06:34:01 <Guest51845> while the complex haskell symboligy isn't easy to pick up by a total beginner i would say
06:34:25 <ChristianS> Peaker: well, but you should care, because their performance difference are very different.
06:34:26 <sipa> Guest51845: agree, but you shouldn't start with using all symbols - they're mainly a convenience
06:34:29 <fryguybob> Guest51845: But Person() could launch missiles yet the code looks like an equation.
06:34:42 <sipa> Guest51845: Still, you need to grasp the object-oriented mindset; It's something I know many beginning programmers have problems with as well
06:34:49 <Peaker> ChristianS: that only matters when performance is a bottleneck, which it mostly isn't.
06:34:53 <MagneticDuck> Yeah. Side effects, as we know from medicine, can be deadly! :D
06:34:55 <hiptobecubic> Guest51845, neither is PersonFactoryWidgetFactory.FactoryWidgetFactory.WidgetFactory[2].Create_Widget()
06:35:15 <Peaker> ChristianS: and when I use bytestrings that fit in a single chunk anyway, I really don't care -- but then I have to convert anyway because all libraries care
06:35:21 <Guest51845> I think the object-oriented paradigm is great because it's close to the real world and everyone can relate to objects we use everyday
06:35:26 <applicative> I think it was Steel or Abelson but here is someone's quatation from memory "I've heard it said that someone just learning how to program can pick up Lisp in a day. If you happen to already know Fortran, it will take two days."
06:35:39 <Peaker> Guest51845: No no, the universe is a pure function of time, so we want pure functions to model it
06:35:46 <Guest51845> hiptobecuib, nobody has to write that in Java at first
06:35:52 <MagneticDuck> Yeah, but really look at a program. What's it telling you? It's telling you what things *are*.
06:36:09 <MagneticDuck> Even in a game!
06:36:30 <hiptobecubic> Guest51845, no one has to write complex symbols in haskell first either
06:36:30 <Martty> clearly this channel would be better modeled by a mathematical function. a periodic one, when it comes to these discusisons
06:36:45 <Guest51845> i want my objects or variables to be as close as the real world as they can be and java is the right choice for that
06:36:49 <Peaker> ChristianS: even if considering performance, the fact libraries are forced to hard-code to either strict or lazy bytestring means I can't instantiate them for the right kind of bytestring I have, which matters for my performance
06:36:58 <Peaker> ChristianS: so it's worse in that regard, too
06:37:31 <sipa> Guest51845: sure, that is one meaningful way of modeling what you're programming
06:37:38 <Guest51845> int a = 1;
06:37:40 <sipa> Guest51845: but it's not necessarily the only or the easiest way
06:37:46 <hiptobecubic> Peaker, isn't that what typeclasses are supposed to solve?
06:37:55 <sipa> and the easiest language is always the one you already know
06:37:56 <MagneticDuck> let a = 1 in ...
06:38:04 <Guest51845> In my opinion it's the easiest way
06:38:13 <hiptobecubic> Guest51845, ... because it's the one you already know
06:38:18 <Guest51845> let? looks like basic lol
06:38:21 <Guest51845> in?
06:38:22 <Guest51845> in what?
06:38:28 <Guest51845> in the memory tubes?
06:38:28 <MagneticDuck> in an expression
06:38:43 <MagneticDuck> > let a = 2 in a ** a
06:38:43 <ChristianS> Peaker: hm, good libraries tend to have Lazy and non-lazy versions of their modules and its trivial to interchange between them by just adjusting the import.
06:38:43 <lambdabot>   4.0
06:38:47 <Guest51845> hiptbecubic, no, not because of me, for anyone
06:38:51 <Traverse> Java doesn't support multiple inheritance, that's hardly "real world"-like
06:38:54 <Guest51845> ** ?
06:38:56 <sipa> Guest51845: please, take a short time to look at the basics in lyah, then come back to comment
06:38:56 <ChristianS> Peaker: i agree that that's not always the case, though...
06:39:02 <sipa> @where lyah
06:39:03 <lambdabot> http://www.learnyouahaskell.com/
06:39:21 <MagneticDuck> Yeah, learn Haskell out to Monads, then tell us what you think! ;)
06:39:28 <MagneticDuck> You'll think differently.
06:39:35 <dylukes> Haskell isn't respecting my -pfmF flag...
06:39:42 <sipa> Guest51845: but you must accept that it will be *very* different from what you know, and willing to see that it also can have advantages
06:39:44 <dylukes> when I compile with -v it shows it's using /usr/bin/clang instead of cpphs (still)
06:39:56 <td123> I liked starting out with RWH cause it gave you a bit more exercises
06:39:57 <Guest51845> of course
06:40:21 <Guest51845> Java.own(Haskell) = true;
06:40:43 <parcs`> what
06:40:47 <hiptobecubic> Guest51845, if everyone else thought the way you do, then why are functional languages so loved and admired and get all the ladies (and fellas) worked up when they see it?
06:41:10 <Guest51845> tell me other functional languages so i can see if i already know any of them
06:41:18 <sipa> Excell
06:41:19 <Peaker> hiptobecubic: Yes, that's why I think having duplicate APIs instead of a type-class for ByteStrings and others is terrible
06:41:22 <sipa> SQL
06:41:29 <sipa> Ocaml
06:41:30 <Guest51845> Excel isn't a programming language
06:41:35 <hiptobecubic> Guest51845, yes it is.
06:41:42 <Guest51845> I know SQL and i like it
06:41:44 <Azel> Scheme, Common Lisp, O'Caml, F#, ML...JavaScript may be used as one I believe
06:41:45 <Peaker> ChristianS: imagine a library composing multiple other libraries, each having a lazy/strict variant
06:41:47 <dylukes> Peaker: Usually those sorts of typeclasses don't fit.
06:41:50 <dylukes> See "ListLike"
06:41:51 <dylukes> >_>
06:41:51 <Guest51845> VBA behind Excel is a language
06:41:53 <Peaker> ChristianS: we get a cartesian explosion of code
06:42:05 <Guest51845> JavaScript is imperative
06:42:06 <hiptobecubic> Guest51845, you never use any formulas in your cells?
06:42:06 <Traverse> sql is simply syntactic sugar for some basic logic programming
06:42:07 <td123> I think excel is turing complete :P
06:42:08 <sipa> Guest51845: Excell may not be a programming language (depending on your definition of it), but it is very functional
06:42:17 <Guest51845> Since when a formula is a language?
06:42:25 <Peaker> dylukes: Yeah, ListLike is bad, but: A) If we just had the ByteString API itself as a class, it'd already be better than the duplicate APIs.  B) The best long-term option is a bunch of small, well-designed classes
06:42:28 <hiptobecubic> Since math?
06:42:29 <koala_man> since lambda calculus
06:42:36 <sipa> Guest51845: haskell programs are formulas, and they can do everything a Java program can
06:42:55 <sipa> Guest51845: but please, read a bit first, now we're just confusing you
06:42:57 <Guest51845> so write to a database with an excel formula for me
06:43:00 <applicative> the composition of signs in construction a formula presupposes a language
06:43:08 <hiptobecubic> how is "=If[Null, 0, 1]"  not a function in a programming language?
06:43:09 <Azel> I didn't said JavaScript is a functionnal language, but that it may be used as one, and easily as that
06:43:11 <applicative> constructing, rather
06:43:15 <ion> Speaking of Excel‚Ñ¢ ‚Äúthe programming language‚Äù, http://youtu.be/_whSnPErl7c
06:43:40 <ChristianS> Guest25308: javascript is both imperative and functional, depends on the style you prefer. the same is true of ocaml and lua.
06:43:43 <Guest51845> or create a web site with an excel formula
06:43:49 <Peaker> Guest51845: these statements about "similar to the real world" are just hand-waving.. Just compare solutions to real problems
06:44:11 <Guest51845> what do you mean Peaker?
06:44:25 <sipa> Guest51845: I agreed that it may not be a programming language, and I certainly agree you can't use it for everything
06:44:27 <hiptobecubic> Guest51845, you can write an excel program to output html based on the contents of a spreadsheet or any other file, if that's what you're asking
06:44:29 <koala_man> Guest51845: listening to sockets is typically not a requirement to qualify as a programming language in theoretical cs
06:44:35 <sipa> Guest51845: But still, it is a very nice example for functional thinking
06:44:45 <Peaker> Guest51845: I mean all these things you are saying about Haskell and Java have little actual essence, and no practical meaning
06:45:04 <Guest51845> lol
06:45:11 <applicative> wow, that  Excel‚Ñ¢ rocks.
06:45:12 <Guest51845> I'm just comparing Haskell to another language
06:45:23 <Guest51845> this is a debate of ideas
06:45:34 <Guest51845> what practical meaning you want? win the lottery because of this chat?
06:45:53 <hiptobecubic> Well this is deteriorating rapidly...
06:45:55 <sipa> Guest51845: You can argue as much as you want about ideas, but the only thing that matters is how easily and how well you can write programs with it
06:45:56 <Peaker> Guest51845: then why are you comparing philosophical outlooks? Compare language features, or programs written in these languages
06:46:01 <applicative> lets write some folds
06:46:20 <Guest51845> go ahead Peaker
06:46:20 <hiptobecubic> > sum [1,2]
06:46:21 <lambdabot>   3
06:46:23 <sipa> Guest51845: and until you have at least some experience with both, i think it's hard for you to really make a comparison
06:46:24 <hiptobecubic> applicative, there
06:46:29 <applicative> excellent fold
06:46:34 <appletini> cool
06:46:34 <mike-burns> Let's not have a language war.
06:46:41 <Guest51845> sipa i was just curious about the language that's all
06:46:41 <roconnor> > deriv (sin (x^3))
06:46:42 <lambdabot>   Couldn't match expected type `Data.Number.Dif.Dif a
06:46:42 <lambdabot>                        ...
06:46:47 <Peaker> Guest51845: How do you express this in Java:  histogram = map (head &&& length) . group . sort
06:46:51 <roconnor> :(
06:46:57 <applicative> > foldr max "" (words "Guest51845: and until you have at least some experience with both, i think it's hard for you to really make a comparison")
06:46:58 <lambdabot>   "you"
06:47:09 <Guest51845> what does that do?
06:47:11 <Guest51845> what is &&& ?
06:47:16 <hiptobecubic> Peaker, well you're assuming he knows what that even means. Which, is unlikely. I don't either yet
06:47:19 <Peaker> Guest51845: (f &&& g) x = (f x, g x)
06:47:20 <applicative> ooooo &&&
06:47:21 <sipa> Guest51845: if you are interested, please read LYAH or another tutorial first; people here will be very helpful if you have questions
06:47:34 <Guest51845> ok
06:47:37 <applicative> @type (&&&)
06:47:37 <lambdabot> forall (a :: * -> * -> *) b c c'. (Arrow a) => a b c -> a b c' -> a b (c, c')
06:47:39 <Peaker> Guest51845: that is, &&& takes two functions, and makes a single function that feeds its input to the two functions, and puts the results in a tuple
06:47:48 <applicative> @type (***)
06:47:49 <lambdabot> forall (a :: * -> * -> *) b c b' c'. (Arrow a) => a b c -> a b' c' -> a (b, b') (c, c')
06:48:01 <sipa> Peaker: let's not scare him :)
06:48:07 <Guest51845> why would we want to join two functions?
06:48:09 <Peaker> I hate arrows.   (&&&) :: (a -> b) -> (a -> c) -> a -> (b, c)
06:48:13 <roconnor> > deriv atan x
06:48:14 <lambdabot>   1 * recip (x * x - 1)
06:48:28 <applicative> @type length &&& id
06:48:29 <lambdabot> forall a. [a] -> (Int, [a])
06:48:41 <Peaker> Guest51845: well, a histogram for example, can be implemented by sorting the input, grouping subsequent equal elements together, and then taking an element and the length of each group
06:48:46 <Guest51845> help
06:48:47 <Guest51845> hello world
06:48:53 <Guest51845> ???
06:48:59 <applicative> > map (length &&& id) (words "Guest51845: well, a histogram for example, can be implemented by sorting the input, grouping subsequent equal elements together, and then taking an element and the length of each group")
06:48:59 <Guest51845> commands
06:48:59 <lambdabot>   [(11,"Guest51845:"),(5,"well,"),(1,"a"),(9,"histogram"),(3,"for"),(8,"examp...
06:49:15 <applicative> > sort $  map (length &&& id) (words "Guest51845: well, a histogram for example, can be implemented by sorting the input, grouping subsequent equal elements together, and then taking an element and the length of each group")
06:49:16 <lambdabot>   [(1,"a"),(2,"an"),(2,"be"),(2,"by"),(2,"of"),(3,"and"),(3,"and"),(3,"can"),...
06:49:38 <hiptobecubic> Guest51845, you put functions together all the time in imperative languages too. You just often store the intermediate values.
06:49:39 <Guest51845> lambda bot is busting my balls lol
06:49:41 <applicative> > reverse $ sort $  map (length &&& id) (words "Guest51845: well, a histogram for example, can be implemented by sorting the input, grouping subsequent equal elements together, and then taking an element and the length of each group")
06:49:41 <lambdabot>   [(11,"implemented"),(11,"Guest51845:"),(10,"subsequent"),(9,"together,"),(9...
06:49:51 <Guest51845> pause
06:49:53 <Guest51845> pause
06:49:53 <Guest51845> pause
06:49:54 <fryguybob> Guest51845: Haskell makes it easy to compose functions in order to allow you to build programs out of small easy to reason about parts.
06:49:57 <Guest51845> what a mess
06:50:52 <applicative> > zip [1..] $ words "Guest51845: Haskell makes it easy to compose functions in order to allow you to build programs out of small easy to reason about parts."
06:50:53 <lambdabot>   [(1,"Guest51845:"),(2,"Haskell"),(3,"makes"),(4,"it"),(5,"easy"),(6,"to"),(...
06:50:53 <Guest51845> hmmmmm
06:51:08 <Guest51845> so it's all about functions huh
06:51:14 <Guest51845> lambda bot is going nuts
06:51:20 <Guest51845> lambdabot
06:51:21 <Guest51845> lambdabot hello
06:51:25 <Guest51845> lambdabot talk to me
06:51:27 <fryguybob> > text "hello"
06:51:28 <lambdabot>   hello
06:51:34 <Guest51845> text "You are my hero"
06:51:41 <Guest51845> nothing lol
06:51:45 <Guest51845> i came up empty-handed
06:51:51 <Azel> > text "You forgot a caret"
06:51:51 <lambdabot>   You forgot a caret
06:52:00 <Guest51845> text "alskdfa"
06:52:01 <Guest51845> a what
06:52:10 <Guest51845> text "hello"
06:52:11 <applicative> > filter ((== 5).length . snd ) $zip [1..] $ words "Guest51845: Haskell makes it easy to compose functions in order to allow you to build programs out of small easy to reason about parts.
06:52:11 <lambdabot>   <no location info>:
06:52:12 <lambdabot>      lexical error in string/character literal at end o...
06:52:20 <applicative> > filter ((== 5).length . snd ) $zip [1..] $ words "Guest51845: Haskell makes it easy to compose functions in order to allow you to build programs out of small easy to reason about parts."
06:52:21 <lambdabot>   [(3,"makes"),(10,"order"),(12,"allow"),(15,"build"),(19,"small"),(23,"about...
06:52:24 <Guest51845> > text "hello"
06:52:25 <lambdabot>   hello
06:52:28 <Azel> > text "Error in the name...you forgot a '>' my dear"
06:52:29 <lambdabot>   Error in the name...you forgot a '>' my dear
06:52:31 <Guest51845> > text "Ur my daddy"
06:52:31 <lambdabot>   Ur my daddy
06:52:37 <Guest51845> > help
06:52:38 <lambdabot>   Not in scope: `help'
06:52:42 <Guest51845> > commands
06:52:42 <lambdabot>   Not in scope: `commands'
06:52:43 <applicative> > text "hello" $$ text "goodbye"
06:52:43 <lambdabot>   hello
06:52:43 <lambdabot>  goodbye
06:52:54 <Guest51845> > text "I'm a virgin"
06:52:55 <lambdabot>   I'm a virgin
06:53:01 <Guest51845> > scope
06:53:01 <lambdabot>   Not in scope: `scope'
06:53:09 <Guest51845> >
06:53:11 <Guest51845> > ?
06:53:12 <lambdabot>   <no location info>: parse error on input `?'
06:53:19 <Guest51845> > location
06:53:19 <lambdabot>   Not in scope: `location'
06:53:20 <Guest51845> > info
06:53:21 <lambdabot>   Not in scope: `info'
06:53:22 <roconnor> Guest51845: feel free to PM lambdabot so you don't bore us
06:53:24 <Peaker> > group . sort $ "hello world"
06:53:25 <lambdabot>   [" ","d","e","h","lll","oo","r","w"]
06:53:32 <Guest51845> lol ok
06:53:34 <Peaker> > map (head &&& length) . group . sort $ "hello world"
06:53:36 <lambdabot>   [(' ',1),('d',1),('e',1),('h',1),('l',3),('o',2),('r',1),('w',1)]
06:53:43 <Guest51845> let's be intimate
06:53:57 <Peaker> Guest51845: understand how this implements a histogram?
06:53:59 <Guest51845> > reverse "blahblahblah"
06:54:00 <lambdabot>   "halbhalbhalb"
06:54:26 <Guest51845> Peaker I'm not even sure what a histograph is
06:54:30 <Guest51845> is that a graph?
06:54:44 <anders__> let filelist = System.Directory.getDirectoryContents           how to print each filename from filelist ??
06:54:46 <applicative> > foldr ($$) (text "")  (map text $ words "Peaker I'm not even sure what a histograph is")
06:54:47 <lambdabot>   Peaker
06:54:47 <lambdabot>  I'm
06:54:47 <lambdabot>  not
06:54:47 <lambdabot>  even
06:54:47 <lambdabot>  sure
06:54:49 <lambdabot> [4 @more lines]
06:55:12 <Traverse> Does anyone know some general algorithms for randomly selecting two non-overlapping submatrices of equal dimensions from a given matrix (implemented as list of lists) all solutions I think of turn out to be too constrained
06:55:47 <Guest51845> Are you Haskell lovers math teachers as well? or mathmaticians?
06:56:18 <roconnor> I'm a mathematician.
06:56:24 <Guest51845> how did i guess lol
06:56:33 <applicative> Haskell is dual to mathematics .  It's practically the opposite.  roconnor is selfdual
06:56:41 <roconnor> Though I prefer the term, "computer scientist"
06:56:45 <rostayob> Traverse: firstly, you shouldn't use list of lists :)
06:56:46 <hiptobecubic> Guest51845, Haskell just works well for math. I'm not a mathematician.
06:57:11 <hiptobecubic> Guest51845, I wouldn't claim to be one anyway. I started as a biologist :)
06:57:24 <Guest51845> I guess math is very important and basic to any programming language
06:57:31 <Guest51845> they both have variables
06:57:37 <Guest51845> functions
06:57:37 <Guest51845> etc.
06:57:57 <Guest51845> i like the logo
06:58:01 <Guest51845> the lambda symbol
06:58:04 <Guest51845> very cool and futuristic
06:58:11 <applicative> well, it beats the previous logo
06:58:15 <rostayob> Guest51845: the lambda means what it means since the 30s.
06:58:21 <Guest51845> which was a banana lol
06:58:29 <Guest51845> it's a greek character
06:58:38 <Traverse> well the 'matrix operation' is just one portion of the thing, the actual datatype represents a chromosome in a genetic algorithm
06:58:43 <rostayob> Guest51845: yeah but it has significance in computer science since the 30s
06:58:52 <Guest51845> right
06:58:55 <Guest51845> like other symbols
06:58:56 <Guest51845> epsylon
06:58:58 <Guest51845> alpha
06:58:58 <Guest51845> beta
06:58:59 <Guest51845> ...
06:59:01 <Peaker> Guest51845: histogram is basically a count of how many of each kind of thing there is
06:59:08 <Guest51845> How do you define variables?
06:59:09 <nand`> I accidentally called a ‚Äúpair‚Äù a ‚Äúbituple‚Äù, is that bad?
06:59:12 <Guest51845> with data types
06:59:18 <rostayob> Traverse: I guess that selecting a submatrix at random and then selecting the other one amongst the possible submatrices is not enough?
06:59:40 <Guest51845> I've seen graphs like that before, comparison between different lines
06:59:41 <rostayob> the second part is probably tricky
06:59:55 <Guest51845> how do you create a string?
07:00:03 <Guest51845> String x = "test";
07:00:20 <nand`> Guest51845: Haskell is just a specialized subgroup of computer science and computer science is just a specialized subgroup of mathematics
07:00:23 <rostayob> Guest51845: you're confused, read some introduction to Haskell
07:00:32 <Guest51845> nand everything is related lol
07:00:44 <Azel> At top-level it would be: x = "test"
07:00:44 <applicative> @where LYAH
07:00:45 <lambdabot> http://www.learnyouahaskell.com/
07:00:48 <Guest51845> just curious
07:00:51 <nand`> Guest51845: yes, but mathematics forms the basis of all models
07:00:51 <applicative> ^^^ Guest51845
07:00:56 <nand`> Haskell is just a model for computation
07:01:06 <Guest51845> x  = "test" looks very simple
07:01:09 <anders__> I know this is a stupid beginner question but i am try to read a directory, and get a List back with type filelist :: FilePath -> IO [FilePath]   I like to print this to the screen but can't find how to do that
07:01:18 <Azel> In an expression, like said above, let x = "test" in expr
07:01:24 <rostayob> anders__: mapM_ putStrLn
07:01:26 <Guest51845> mathematics can't be used to describe the universe so there.. Win for me lol
07:01:32 <applicative> > let x = "text" in reverse x
07:01:33 <lambdabot>   "txet"
07:01:36 <Guest51845> > x = "test"
07:01:37 <lambdabot>   <no location info>: parse error on input `='
07:01:44 <applicative> > let x = "text" in x
07:01:45 <lambdabot>   "text"
07:01:52 <Guest51845> > let x = "text"
07:01:53 <lambdabot>   not an expression: `let x = "text"'
07:01:58 <nand`> Guest51845: At the top level, if you define x as a String it would be something like: x :: String; x = "test"  where ; denotes a newline; or even x = "test" :: String however you can leave away the :: String since the compiler automatically infers that
07:02:11 <applicative> Guest51845: you can only give lambdabot a complete evaluable expression
07:02:18 <Guest51845> > x :: String
07:02:19 <lambdabot>   Couldn't match expected type `GHC.Base.String'
07:02:19 <lambdabot>         against inferred typ...
07:02:20 <nand`> Guest51845: have you never seen string theory?
07:02:41 <Guest51845> > echo (x :: String)
07:02:42 <lambdabot>   Not in scope: `echo'
07:02:45 <applicative> > let x :: String ; x = "14" in read x :: Int
07:02:45 <lambdabot>   14
07:02:47 <Guest51845> > print (x :: String)
07:02:48 <lambdabot>   Couldn't match expected type `GHC.Base.String'
07:02:48 <lambdabot>         against inferred typ...
07:03:00 <Guest51845> I've heard about it nand
07:03:07 <applicative> Guest51845: no, IO, lambdabot just evaluates expressions
07:03:16 <Azel> Guest51845: What can't be described mathamatically in the universe ? I'm curious
07:03:24 <Tesseraction> emotions
07:03:27 <applicative> > let echo = text in echo "hello"
07:03:27 <Guest51845> if the universe is infinite in size then you can't use math, or numbers, to measure the space between here and the inifinite, that's why math isn't good enough to describe the universe
07:03:28 <lambdabot>   hello
07:03:46 <Peaker> @where lyah
07:03:46 <lambdabot> http://www.learnyouahaskell.com/
07:03:54 <nand`> Guest51845: string theory is just mathematics; it has little to do with what we perceive the world as. It certainly is a model that attempts to describe the universe (I say attempts because nothing we say can ever be certain)
07:03:59 <nand`> about the universe, that is
07:04:01 <Azel> Which infinity ?
07:04:04 <dzhus> Records of functions approach to typeclass-vs-patterns problem discussed earlier worked like charm.
07:04:10 <Guest51845> it's just theory
07:04:16 <Tesseraction> There's more than one kind of infinity.
07:04:21 * applicative thinks *string theory*? 
07:04:34 <ChristianS> Guest51845: actually, haskell is much better with infinite structures than all other programming langs, thanks to its laziness.
07:04:44 <Guest51845> i was talking about infinite distance in kms or miles if you will
07:04:53 <Guest51845> math isn't good enough
07:04:55 <nand`> Guest51845: In my theory of the universe, ‚Äú1U‚Äù represents one universe and there are no operations on it. There, I trivially defined the universe mathematically
07:04:55 <Tesseraction> Yeah but those are countably infinite.
07:04:57 <Guest51845> sorry to burst your bubble lol
07:04:58 <ChristianS> @faq can haskell deal with the infinite?
07:04:58 <lambdabot> The answer is: Yes! Haskell can do that.
07:05:11 <mux> nand`: that isn't entirely true; there are observable consequences to string theory, we just didn't observe any of those yet :-)
07:05:16 <Azel> Guest51845: Like Tesseraction said, there is more than one kind of infinity in mathematics, so which infinity is a problem for maths ?
07:05:39 <Guest51845> nand therefore your definition of the universe is pure theory and speculative, just your personal opinion
07:05:49 <Guest51845> just like an abstract painting
07:05:50 <Guest51845> or poetry
07:06:22 <Guest51845> it may be beautiful but it doesn't have a pratical result in order to measure the infininte for example
07:06:34 <nand`> mux: That certainly may be true, it's still far-fetched though - to a human with no education in physics even the notion that matter consists of particles so small we can't see them directly sounds absurd; physics always requires a stretch in thinking and string theory is just that
07:06:55 <Azel> Infinite distance ? That would be a countable infinite, that is aleph-null
07:07:11 <mux> nand`: agreed. (I was specifically referring to those hypothetical "cosmic strings" that have yet to be observed)
07:07:38 <Guest51845> You can believe in string theory just like you can believe in god... you can't see neither of them
07:07:42 <Guest51845> or prove them
07:07:45 <nand`> Guest51845: You may argue about the usefulness of my definition as such but it's a counter-example to your argument that the universe cannot be described mathematically, and one counter-example is enough to prove a statement as incorrect; it's up to you to retract it and reformulate it in a more constrained way
07:07:49 <mux> Guest51845: wrong
07:07:58 <quicksilver> dzhus: yay :)
07:08:01 <Guest51845> you can't prove it nand
07:08:18 <quicksilver> Let's stay a bit more on-topic please.
07:08:23 * applicative is trying to think of another distracting fold
07:08:26 <Guest51845> i never said your definition is useless, in my opinion it's good....
07:08:29 <Guest51845> but
07:08:35 <Guest51845> it's just theory
07:08:37 <Guest51845> nothing more
07:08:37 <Tesseraction> "you can't prove it" is pretty meaningless in terms of on-going research
07:08:40 <nand`> #haskell-blah maybe?
07:09:06 <ChristianS> anyway, the purpose of programming languages is not to describe the universe (that's what scientific theories are for), but to solve problems, and haskell is extremely good at the latter.
07:09:37 <Guest51845> ongoing research is a great thing, i absolutely agree with it.. but before we reach any hard evidence, math is still not good enough to describe reality
07:09:48 <Guest51845> sorry lol
07:09:52 <Guest51845> math is no good without other areas
07:10:08 <sipa> math's purpose is not to describe our universe
07:10:19 <Guest51845> but it tries lol
07:10:20 <nand`> math's purpose is to describe relations
07:10:23 <Guest51845> what are numbers for?
07:10:25 <sipa> Guest51845: not at all
07:10:29 <Guest51845> you can't measure infinity with math
07:10:30 <nand`> physic's purpose is to build models of our universe
07:10:35 <Guest51845> but math tries hard
07:10:36 <sipa> it teaches us general truths that hold under well known circumstances
07:10:39 <quicksilver> Guest51845, sipa, nand` : please stick to chat about haskell programming.
07:11:04 <Guest51845> well let me say "haskell" a few times to calm down the bo
07:11:06 <Guest51845> bot
07:11:06 <Guest51845> lol
07:11:11 <Guest51845> haskell haskell haskell
07:11:15 <sipa> Guest51845: please
07:11:59 <Guest51845> well anyway if i'm about to be kicked, thanks for the chat haskell lovers, it was a nice introdution for me
07:12:09 <nand`> Guest51845: anyway since you seemed to be a bit confused about how Haskell's syntax works I recommend reading through LYAH
07:12:20 <nand`> @where lyah
07:12:20 <lambdabot> http://www.learnyouahaskell.com/
07:12:27 <td123> or rwh :)
07:12:29 <Tesseraction> What were you having trouble with in terms of syntax?
07:12:29 <mm_freak_> Guest51845: math approximates reality
07:12:43 <nand`> mm_freak_: math does not
07:12:45 <Guest51845> what is lyah?
07:12:46 <Tesseraction> oh gosh we just stopped that discussion
07:12:49 <Azel> Guest51845, there is a chan for off-topic conversation (#haskell-blah) but this one is for haskell conversations
07:12:50 <nand`> Guest51845: A book
07:12:50 <sipa> Guest51845: learn you a haskell
07:12:53 <Tesseraction> Guest25308: Learn You a Haskell
07:12:55 <sipa> Guest51845: it's very good introduction
07:12:59 <mm_freak_> nand`: ok, people use math to approximate reality
07:12:59 <sipa> +a
07:13:13 <osfameron> surely people use reality to approximate maths? ;-)
07:13:15 <applicative> if you read it for about an hour, you will have much improved questions, Guest51845
07:13:15 <mm_freak_> obviously it doesn't do anything by itself =)
07:13:23 <mm_freak_> osfameron: that too =)
07:13:38 <Guest51845> Ok, i'll take a gander, thanks
07:13:39 * applicative passes compass and straightedge to osfameron 
07:14:00 <anders__> <rostayob> Thanks
07:14:26 <rostayob> anders__: you should read up to understand how to work with IO
07:14:34 <rostayob> possibly how to work with monads in general :)
07:15:10 <mm_freak_> nowadays people seem to prefer LYAH over RWH
07:15:37 <quicksilver> LYAH is specifically a tutorial text, RWH is something halfway to a cookbook.
07:15:50 <rostayob> mm_freak_: they're different things as quicksilver says
07:15:55 <rostayob> I'd never suggest RWH to a newcomer
07:16:04 <quicksilver> RWH, unfortunately, is a bit more tied to specific libraries and is bitrotting faster :-(
07:16:09 <applicative> Guest51845: if you don't want to install our might compiler right away  you can work with LYAH's first bunch of material on the web interpreters like codepad and ideone
07:16:20 <applicative> our mighty compiler, rather
07:16:23 <nand`> I personally think LYAH is a better introduction than RWH, RWH is more useful *after* you're read LYAH
07:16:24 <td123> quicksilver: true, but it does provide more exercises :)
07:16:33 <nand`> quicksilver: yeah LYAH needs better and more exercises
07:16:36 <quicksilver> there is that.
07:16:37 <Guest51845> what program do you use to compile?  something like Visual Studio?
07:16:40 <nand`> quicksilver: Why not contribute by writing a ‚ÄúLYAH exercise list‚Äù?
07:16:46 <rostayob> I always suggests "Programming in Haskell" as well
07:16:47 <nand`> err, td123
07:16:50 <applicative> Guest51845: the GHC !!
07:16:50 <rostayob> @where GHC
07:16:50 <lambdabot> http://haskell.org/ghc
07:16:55 <rostayob> Guest51845: ^^^^
07:17:07 <rostayob> @where platform
07:17:07 <lambdabot> http://hackage.haskell.org/platform/
07:17:17 <Guest51845> i'm trying to find any screenshots
07:17:19 <applicative> it used to call itself "the Glorious Glasgow Haskell Compiler", rightly
07:17:24 <anders__> <rostayob> Ok, i have started to read a book, but have a problem that i that i test to solve i Haskell ...
07:17:26 <nand`> Guest51845: some people recommend using hugs instead of GHC when beginning because GHC's error messages can be hard to swallow
07:17:34 <nand`> I personally did not have a problem with it, you just need to learn what they mean
07:17:50 <Guest51845> i like warm hugs
07:17:51 <rostayob> nand`: that's a bad suggestion nowadays imho
07:17:55 <applicative> I thought that was true, then that it was false, but now with the new ghc typechecker it's true again
07:17:58 <rostayob> anders__: what?
07:18:06 <hiptobecubic> Why is hugs not the default?
07:18:17 <rostayob> hiptobecubic: default of what?
07:18:18 <nand`> applicative: I tend to prepend ‚ÄúGlorious‚Äù before most things haskell-related, mostly referring to it as the ‚ÄúGlorious Haskell Computation System‚Äù or ‚ÄúGlorious Haskell Programming LAnguage‚Äù
07:18:19 <antonh_> Guest51845, are you a troll? :)
07:18:24 <hiptobecubic> suggestion, over ghc
07:18:32 <Guest51845> lol
07:18:34 <rostayob> hiptobecubic: hugs development halted years ago
07:18:39 * applicative prefixes it silently
07:18:39 <hiptobecubic> oh
07:18:45 <Guest51845> hugs & kisses
07:18:48 <nand`> applicative: I like the (x ~ y) type inference failures when you do something as simple as just mismatching types
07:18:51 <Guest51845> this is getting romantic
07:18:52 <Tesseraction> A shame since I learned Haskell on hugs
07:19:02 <rostayob> nand`: no
07:19:03 <applicative> nand`: yes that's the kind of thing i'm thinking of
07:19:08 <rostayob> nand`: that happens if you use type families
07:19:10 <rostayob> or things that do
07:19:14 <applicative> it's so imaginative trying to interpret my typos
07:19:31 <rostayob> I agree that Hugs' error messages are somewhat better anyways
07:19:43 <rostayob> but you won't get a type family error unless you use type families
07:19:55 <anders__> <rostayob> i like a program that reads a directory content and give me a list, i can do i easy i eg Python but i like to test Haskell
07:19:57 <nand`> rostayob: I see. I haven't exactly looked at the new kind and type dependency-related stuff yet
07:20:08 <rostayob> nand`: type families are not that new anyways
07:20:10 <applicative> or import something that does, e.g. Data.Vector.Unboxed, which looks innocent enough
07:20:41 <applicative> anders__: what's wrong with 'getDirectoryContents' ?
07:21:01 <rostayob> yeah let's say that since hugs "forces" you not to use libraries that use extensions you are in an environment safe from weird error messages :P
07:21:01 <nand`> What's a type family either way, without going into detail? Just a generalization of type classes or something completely different?
07:21:17 <sharat87> hi, can I give cabal-install a path where to install the haskell packages? via a command line argument preferably?
07:21:18 <rostayob> but hugs has a lot of extensions too, I wonders how the errors are
07:21:46 <applicative> yeah, I think that's part of the reason its error messages are better, it doesn't have quite as powerful as imagination to work with
07:21:51 <rostayob> sharat87: --prefix?
07:21:58 <rostayob> sharat87: cabal install --help
07:22:14 <rostayob> applicative: well, it definitely has fundeps for example
07:22:31 <applicative> yeah, it's pretty sophisticated really
07:22:38 <rostayob> and those give weird error message (could not satisfy patterson condition or whatever)
07:22:43 <sharat87> rostayob: I saw --bindir, --libdir and the rest but missed --prefix. #facepalm. Thanks a lot
07:22:46 * applicative forms the Committee to Save Hugs
07:23:01 <rostayob> it also has the record thing
07:23:05 <nand`> Either way, long error messages are always good as long as they go into much detail and provide adequate context; better than seeing just some very brief message and a line number and trying to figure out what went wrong
07:23:22 <rostayob> sharat87: yw :)
07:23:25 <nand`> GHC is good on the ‚Äúproviding context‚Äù part
07:23:39 <rostayob> nand`: by that measure GHC's messages are better
07:23:43 <applicative> sharat87: why are you using a special directory?
07:23:49 <rostayob> I liked Hugs messages because they're short :P
07:24:05 <rostayob> e.g.
07:24:06 <rostayob> ERROR - Cannot find "show" function for:
07:24:08 <rostayob> *** Expression : \x -> x
07:24:09 <anders__> applicative: i use that like  let filelist = System.Directory.getDirectoryContents   but i like to print the content of  "filelist"
07:24:10 <rostayob> *** Of type    : a -> a
07:24:21 <rostayob> compared to
07:24:21 <quicksilver> the problem with GHC error messages is that to understand them you have to understand details of haskell and/or its extensions which ideally you would not need to understand the feature you're trying to use.
07:24:24 <rostayob>     No instance for (Show (t0 -> t0))
07:24:26 <rostayob>       arising from a use of `print'
07:24:28 <rostayob>     Possible fix: add an instance declaration for (Show (t0 -> t0))
07:24:30 <rostayob>     In a stmt of an interactive GHCi command: print it
07:25:14 <rostayob> quicksilver: I think even without looking at language extensions Hugs typeclasses error are much simpler
07:25:15 <nand`> The only way I can think of how to improve the latter one is to reword it to make it more clear like ‚ÄúNo Show instance for (t0 -> t0)‚Äù
07:25:54 <sharat87> applicative: I'm trying to install my project specific dependencies with-in the project... hasn't been going too well until now. How do you guys do this?
07:25:54 <rostayob> nand`: hugs actually tells you which expression it is
07:26:06 <nand`> and maybe add the parameter, ie. ‚Äúarising from a use of `print' on the expression `it'‚Äù
07:26:27 <mannenmenmannen> whsaaup`?
07:26:39 <nand`> but that might not be as simple if you're, eg. just passing ‚Äúprint‚Äù to a higher order function
07:26:48 <nand`> rostayob: do note that it's still shown though
07:26:58 <applicative_> sharat87: that's what i was wondering, have you seen cabal-dev, or what's the other one
07:27:09 <rostayob> nand`: no, it's not show
07:27:21 <rostayob> nand`: those errors were generated by me typing '\x -> x' in ghci
07:27:23 <rostayob> or hugs
07:27:23 <sharat87> applicative_: and capri, yes
07:27:30 <rostayob> *it's not shown
07:27:55 <sharat87> applicative_: I've tried cabal-dev, but couldn't get it to work. I'll get you more details in a sec
07:30:51 <mm_freak_> i see
07:30:58 <mm_freak_> then i wonder why RWH goes throught the trouble of explaining the basics
07:31:07 <mm_freak_> LYAH and RWH would well work together
07:31:19 <nand`> mm_freak_: because alternatives are a good thing
07:31:24 <nand`> you can just skip the portions that you already know
07:31:27 <rostayob> mah. RWH is and will become outdated quickly.
07:31:28 <nand`> but you can't imagine the portions that you don't
07:31:36 <rostayob> haskell libraries change fast
07:31:43 <rostayob> while LYAH will be valid for a long time
07:32:14 <rostayob> and haskell programming practices as well
07:32:17 <hiptobecubic> rostayob, the exception handling is already old.
07:32:55 * rostayob goes to buy a sandwich
07:33:15 <nand`> What I like about LYAH is that it presents concepts on the ‚Äúright‚Äù order
07:33:21 <hpc> ^
07:33:27 <nand`> instead of teaching you to go nuts with the IO monad and do notation first thing, it saves it for chapter 14 or something
07:33:30 <hiptobecubic> I liked the art.
07:33:42 <nand`> I read it without the art :( was disappointed when I found out what I missed
07:33:58 <hiptobecubic> nand`, i bet
07:34:58 <hasknoob> where do you learn about monads
07:35:10 <danr> nand`: disappointed as in you didn't like the art? or of what you'd been missing? ;)
07:35:24 <hpc> hasknoob: go through lyah in the order the chapters are in
07:35:44 <hpc> hasknoob: you'll get to monads when you're good and ready ;)
07:36:20 <hpc> (there's probably a couple of early chapters you can skip)
07:38:05 <nand`> danr: the latter
07:38:38 <nand`> hasknoob: monads are just like burritos
07:39:28 <Entroacceptor> mh, tasty burritos
07:40:48 <hiptobecubic> there were some nice monad analogies in here when i was asking about them
07:41:30 <nand`> My favorite analogy: monads are just like monads
07:41:58 <hpc> monads are just monads in the 2-category of categories!
07:41:58 <Peaker> hasknoob: do yo know what kinds are? What (* -> *) is? How type-classes work?
07:42:24 <hiptobecubic> "<duqicnk> a monad is like a train that runs backwards in time, which is made of tiny chocolate robots"
07:42:56 <hpc> we need bad analogies for continuations!
07:43:10 <hpc> "continuations are like wearing roller skates in a maple syrup factory"
07:43:28 <ion> Continuations are like GOTO.
07:43:31 <Entroacceptor> so sweet, sweet accidents
07:44:33 <flux> analogies are incomplete unless the connection is also explained :(. (in this case, perhaps poorly and in a misleading manner)
07:44:59 <hiptobecubic> continuations are like, when the thing keeps doing whatever
07:45:11 <nand`> monads are just like monads: they look like monads, behave like monads and can be used like monads
07:45:14 <nand`> flux: that better?
07:45:23 <srhb> Continuations are. Like clouds, monkeys and bananas.
07:45:23 <flux> nand`, yes!
07:45:28 <danr> yay for reflexivity analogies!
07:46:42 <edwardk> continuations are just dual to values ;)
07:48:17 <hpc> edwardk: i thought continuations were the dual of continuations
07:49:24 <edwardk> the continuation monad is what you get when you compose the adjunction that gives rise to the continuation monad the other way to get a comonad, since the adjunction froms from Hask^op -> Hask, the comonad is a comonad in Hask^op, but that isn't the same as being dual
07:50:12 <sharat87> I'm trying to install cabal-dev, but it fails with well, little information actually: http://paste.pocoo.org/show/558126/ Any ideas?
07:50:12 <edwardk> this is why i dislike the names coreader/cowriter/costate, etc.
07:50:32 <sharat87> that's the output of `cabal install cabal-dev`
07:51:43 <hiptobecubic> this page seems enlightening. although everytime i find something and ask about it here it's always torn apart and I'm publicly shamed. http://stackoverflow.com/questions/3870088/a-monad-is-just-a-monoid-in-the-category-of-endofunctors-whats-the-problem
07:53:17 <rostayob> sharat87: it is pretty informative actually
07:53:19 <rostayob> run ghc-check
07:53:23 <rostayob> sorry, ghc-pkg check
07:57:21 <sharat87> rostayob: yep, its because of me deleting the messed up ~/.cabal directory http://paste.pocoo.org/show/558131/
07:57:38 <sharat87> how can I fix this? should I reinstall haskell-platform?
07:59:42 <Entroacceptor> sharat87: try removing ~/.ghc
08:00:20 <sharat87> Entroacceptor: I'm trying to `ghc-pkg unregister` the packages that are causing the trouble. Is that the same?
08:01:12 <Entroacceptor> if you deleted .cabal, none of the stuff in .ghc will work
08:01:29 <Entroacceptor> so you'll have to unregister everything anyway :)
08:01:34 <Entroacceptor> but yes
08:01:52 <sharat87> Entroacceptor: yep, `ghc-pkg check` gives me an exit 0. Will try to install cabal-dev again :)
08:05:52 <kar> ever
08:05:58 <kar> hi everybody
08:06:49 <sharat87> Okay, so back to my original question, I am not able to use cabal-dev to setup sandbox for my project, http://paste.pocoo.org/show/558131/ Did I get the .cabal file correct?
08:07:19 <sharat87> Oops, its http://paste.pocoo.org/show/558135/ :)
08:09:41 <Entroacceptor> oh, I don't have ghc anymore Oo
08:10:27 <sharat87> Entroacceptor: have you used cabal-dev before? If not how do you manage dependencies of different projects? Just curious
08:10:27 <Entroacceptor> sharat87: does ghc-pkg list show anything
08:11:01 <sharat87> yes, it does show quite a few, but no hakyll in the list
08:11:16 <sharat87> do you want to see the output?
08:11:26 <Entroacceptor> well, if base is there... :)
08:11:41 <Entroacceptor> and yes, I have used cabal-dev
08:11:59 <sharat87> yes sir, `ghc-pkg list | grep base` => base-4.3.1.0 :)
08:12:05 <sharat87> ah ok
08:14:06 <Entroacceptor> I get cabal: test.cabal:12: Construct not supported at this position: F 12 "cabal"
08:14:16 <Entroacceptor> so your cabal file is probably wrong
08:14:22 <Entroacceptor> but I'm not that firm with it
08:15:11 <Entroacceptor> try cabal init
08:15:16 <sharat87> okay, let me look up some docs on cabal file syntax
08:15:18 <sharat87> okay
08:16:13 <JT_> I'm trying to install the Haskell platform on OSX. It refuses because it says I odn't have XCode installed. As far as I'm concerened, I do have it installed. Any ideas?
08:17:00 <Spockz`> is there a way to check whether a package has been installed (library or executable)?
08:17:24 <Entroacceptor> Spockz`: ghc-pkg list | grep $packagename
08:17:32 <nand`> Why would the Haskell Platform depend on XCode?
08:17:38 <Entroacceptor> executables not, afaik
08:17:47 <statusfailed> Is anyone planning on trying to get GHC working on the Raspberry Pi?
08:17:50 <JT_> Unsure, but it does
08:17:58 <JT_> guess it neds the toolchain
08:18:01 <nand`> statusfailed: that would certainly be neat
08:18:11 <Spockz`> Entroacceptor: for that I can check whether they are in the path as they will need to be anyway
08:18:32 <statusfailed> nand`: it looks like its possible to build with LLVM, but I don't see any recent info
08:18:57 <JT_> just trying the basic install found here
08:18:58 <JT_> http://hackage.haskell.org/platform/mac.html
08:19:08 <JT_> says I need Xcode 4, which I have
08:19:30 <JT_> package file just gives 'Please install Xcode developer tools first." and exits
08:20:17 <sharat87> Entroacceptor: Yep, the stuff generated by `cabal init` work fine. Don't know what I was missing though :) Thanks
08:20:30 <nand`> JT_: XCode and ‚ÄúXCode developer tools‚Äù are probably considered separately
08:20:35 <psye3> like my new gamepad? http://imagetoo.com/?v=448d129570.jpg
08:20:51 <nand`> sort of how like a library package is not equal to that library's development headers; I could be wrong though
08:21:39 <JT_> hmm, ok
08:21:52 <JT_> I will see if I can find some other package
08:21:58 <JT_> I'm not sure what that would be though
08:25:48 <applicative> JT_ there is something called the 'unix development tools' or something that are the crucial part.  is gcc available if you do say 'which gcc'
08:27:07 <JT_> gcc isn't in path
08:27:13 <JT_> which I guess it what it is checking
08:27:41 <JT_> trying to find the package I need
08:27:52 <JT_> but it must be well hidden
08:28:07 <JT_> apple channel everything through the app store now
08:28:21 <applicative> "The package requires Xcode 4.1 (in particular, the "Unix Development Support") to be already installed. You can find Xcode at http://developer.apple.com/ (or you may have a new enough version on your OS X installation DVD)."
08:29:01 <applicative> JT_ yeah I haven't installed XCode the new way, but the old way, there was a box to click for Unix Development Support, and it wasn't always the default that it was clicked
08:29:22 <applicative> JT_ It think mostly you need the gcc itself and some of the obvious things libgmp etc
08:30:14 <applicative> JT_ on windows they just bundle it all with the haskell platform, so in a way it's easier, strangely
08:30:16 <Enigmagic> JT_: or you can install gcc separately https://github.com/kennethreitz/osx-gcc-installer/
08:30:38 <JT_> from 4.3 is apple even distributing GCC with XCode?
08:30:59 <JT_> if you install though the app store, there is no option to install gcc, or do anything
08:31:06 <JT_> and nothing else is now supported
08:31:20 <applicative> oh  good question, i'd have thought we'd have heard complaints by now though?
08:31:28 <JT_> Enigmatic: that might be the only option
08:32:21 <JT_> I'll probably just do it on my linux machine tomorrow and forget about trying it this afternoon
08:32:34 <quicksilver> JT_: Enigmagic : yeah but also read - http://kennethreitz.com/xcode-gcc-and-homebrew.html
08:32:58 <quicksilver> apple now ship a cut down GCC-providing package
08:33:06 <quicksilver> thanks in no small part to Mr Reitz
08:33:48 <Enigmagic> quicksilver: apple ships the source, the link i sent out is the binary distro from kenneth's github
08:34:12 <quicksilver> Enigmagic: no.
08:34:15 <applicative> quicksilver: wow that's really interesting
08:34:16 <quicksilver> Enigmagic: I don't think you read that blog post?
08:34:23 <JT_> quicksilver: that's great - unfortunately you need an apple dev account to get it
08:34:29 <quicksilver> apple now ship a "command line tools for XCode" package
08:34:47 <Enigmagic> quicksilver: i see
08:34:58 <quicksilver> JT_: you need to register your apple ID to be a developer
08:35:01 <JT_> which is a bit silly for someone who just wants a try a little functinoal programming and has no interest in apple dev
08:35:07 <quicksilver> you can call that "having a dev account" if you like.
08:35:19 <JT_> yeah, okay, fair enough
08:35:20 <quicksilver> I call it "registering with apple so you can download their dev software"
08:35:31 <quicksilver> which is not a totally bizarre thing if you want ot develop on a mac.
08:35:53 <hpc> quicksilver: it's definitely objectively bizarre though :P
08:35:59 <Enigmagic> it's a pretty bizarre thing to require it to download gcc :P
08:36:03 * quicksilver nods
08:36:06 <quicksilver> yes, true.
08:36:10 <JT_> sure -  I don't really, I just wanted to try haskell this afternoon
08:36:20 <JT_> and have my mac with me
08:36:32 <quicksilver> the situation is a little unsatisfactory at various levels I agree.
08:36:46 <nand`> hpc: The entire Apple platform and ideology is bizarre in my opinion; then again Apple isn't the only culprit - Microsoft development tools require registration as well
08:36:46 <quicksilver> we have a name for this dis-satisfaction.
08:36:49 <quicksilver> we call it Apple.
08:36:58 <nand`> quicksilver: I prefer to call it ‚Äúproprietary software‚Äù
08:37:01 <Clint> the wonders of non-free operating systems
08:37:15 * applicative is a registered Apple Developer, go figure
08:37:22 <quicksilver> nand`: it's a little disjoint from that I think
08:37:25 <quicksilver> although not unrelated.
08:37:43 <Enigmagic> Clint: there are commercial compilers for linux too
08:37:48 <nand`> quicksilver: ‚Äúevil proprietary software‚Äù
08:37:58 <quicksilver> a proprietary software company could make GCC packages available without registration; a free distribution could ask you to jump through hoops to download packages if it ichose to
08:38:07 <nand`> I think you'll find it hard to argue against that definition
08:38:11 <JT_> whatever the case, the instructions on http://hackage.haskell.org/platform/mac.html don't work and don't cover these issues
08:38:17 <JT_> which I guess is likely to put people off
08:38:19 <quicksilver> yes that's bad, JT_
08:38:27 <quicksilver> the situation has changed since that was written
08:38:36 <JT_> I see, fair enough
08:38:48 <applicative> JT_ yes, it looks like they are out of date now, but that the new situation will be better, if we except the nonsense about registering
08:38:49 <quicksilver> possibly twice
08:39:38 <applicative> installing XCode is a menace, for one thing, if you accidentally hit a file with a wierd ending, suddenly the next half hour is XCode starting up
08:40:08 <Spockz`> applicative: installing that build essentials / Xcode tools package also works
08:40:19 <Spockz`> it just checks whether you have a gcc in your path if I recall correctly
08:40:51 <sharat87> Is there something for runhaskell similar to java's $CLASSPATH and python's $PYTHONPATH, basically a path where libraries are searched for?
08:40:53 <applicative> someone should write a post about the current state of things.
08:41:27 <hpc> sharat87: yes; runhaskell takes ghc flags
08:41:31 <hpc> look through those
08:42:31 <sharat87> hpc: yeah, the `ghc --help` doesn't offer anything on this, any other place I could check?
08:42:50 <Entroacceptor> cabal-dev ghci isn't enough?
08:42:50 <hpc> man ghc
08:43:36 <applicative> sharat, is there a conf file for the libraries you mean to use?  http://www.haskell.org/ghc/docs/latest/html/users_guide/packages.html#ghc-package-path
08:44:15 <sharat87> Entroacceptor: hah, for a repl yes. But everytime compiling for a small change with `cabal-dev install` is *very* slow, so I thought may be this will lead to a faster way
08:45:35 <sharat87> applicative: Oh yes, there are lots of `.conf` files. I think I'll build a GHC_PACKAGE_PATH with those :)
08:51:08 * applicative thinks he means Staatsfeind
08:54:57 <applicative> the combination of 'mad' and 'scientist' in "Haskell Job Opportunity: Data Scientist at madvertise Mobile Advertising, Berlin" makes it almost impossible not to apply
08:55:42 <sharat87> So, I built the GHC_PACKAGE_PATH with all the `.conf` files in the cabal-dev sandbox directory (without a trailing separator), and ran `runghc site.hs` says http://paste.pocoo.org/show/558155/
08:56:07 <sharat87> But doing `cabal-dev install` and `./cabal-dev/bin/site`, it runs just fine :P
08:56:53 * applicative hates to say me and Entroacceptor told him so...
08:57:37 <sharat87> But its so slow! cabal-dev stays at 'Resolving dependencies...` for like 10 whole seconds!
08:58:10 <applicative> yes but it's cabal resolving dependencies, you should be grateful
08:58:57 <sharat87> I'd prefer it resolve them when I tell it to, especially if its going to take so long
08:59:33 <applicative> is hakyll involved
08:59:42 <sharat87> The site.hs contains just `main = print "hello there"` and a runhaskell on that file finished in a blink of an eye
08:59:50 <sharat87> applicative: yes sir, it is.
08:59:59 <applicative> it depends on half of hackage
09:00:24 <applicative> that author only wrote a quarter of it...
09:00:25 <sharat87> haha, no wonder it took eons to install the first time!
09:01:06 <applicative> i think hakyll has about 40 dependencies all together
09:01:32 <sharat87> 42 and it would have conquered something ;)
09:01:59 <sharat87> so, I just have to deal with the time it takes?
09:03:36 <Saizan> use cabal-dev build
09:04:03 <Saizan> (or just cabal build if you're not actually using cabal-dev)
09:06:15 <sharat87> Saizan: YO! That works much better. Thanks :)
09:28:10 <hpaste> DanBurton pasted ‚ÄúDid I just reinvent spawn?‚Äù at http://hpaste.org/64488
09:29:20 <rwbarton> DanBurton, I assume spawn uses forkIO to run the action concurrently
09:29:37 <dskippy> Hello.
09:30:18 <shachaf> That's what spawn does. Doesn't seem to be related to memoization.
09:30:25 <dskippy> I'm confused about something. I have "let f p = p^13" and f 0.5 == 1.220703125e-4 and f 1/2 == 0.5.
09:30:43 <hpc> compose spawn and ioMemo for maximum fun
09:30:49 <DanBurton> yes but spawn is basically the same as ioMemo, isn't it?
09:30:55 <quintessence> dskippy: f 1/2 = (f 1) / 2
09:30:58 <DanBurton> because it produces an action that demands the result
09:31:09 <shachaf> It's the same except for what it does.
09:31:11 <dskippy> Oh wow
09:31:13 <shachaf> (And for the name.)
09:31:18 <dskippy> duh
09:31:20 <dskippy> thx
09:31:31 <DanBurton> which do you think is "better"?
09:31:37 <hpc> shachaf: what if you do
09:31:43 <hpc> a <- spawn foo
09:31:43 <hpc> a
09:31:44 <hpc> a
09:32:00 <hpc> -- vs
09:32:07 <hpc> a <- ioMemo foo; a; a
09:32:27 <DanBurton> what I'm getting at is: is there any situation where ioMemo is a better choice than spawn?
09:32:58 <hpc> DanBurton: if you don't know you want to perform the action
09:33:15 <rwbarton> ioMemo also gives you some stronger ordering guarantees
09:33:20 <hpc> also that
09:33:21 <shachaf> hpc: OK, I suppose you can achieve the same effect there.
09:33:39 <DanBurton> rwbarton: ordering guarantees? such as?
09:33:50 <rwbarton> such as my program runs in a single thread
09:34:15 <rwbarton> so whatever action I pass to ioMemo will have run atomically w.r.t. anything outside it
09:34:21 <shachaf> That's a pretty good ordering guarantee.
09:34:26 <DanBurton> mmm
09:34:44 <DanBurton> but given the nature of most Haskell code, that guarantee isn't very important imho
09:34:45 <hpc> DanBurton: spawn (putStrLn "one!"); putStrLn "two!"; -- what prints
09:35:06 <DanBurton> hpc: ah that makes sense
09:35:33 <hpc> afaict, ioMemo (putStrLn "one"); putStrLn "two" prints "two"
09:36:06 <hpc> ioMemo actually smells a bit like a safe version of unsafeInterleaveIO
09:36:55 <DanBurton> interesting.
09:36:56 <hpc> the side effects only happen once, when you request the value for the first time
09:37:33 <DanBurton> but it's "safe" because you can only request the value via an IO action ^^
09:37:47 <hpc> exactly
09:38:18 <hpc> and rather entertainingly, join . ioMemo = id
09:38:51 <DanBurton> I love Haskell <3
09:38:59 <shachaf> For that matter, you could use ioMemo a = do x <- a; return (return x)
09:39:11 <shachaf> Which would be a slightly different and simpler function.
09:39:11 <hpc> shachaf: that performs the IO up-front
09:39:18 <shachaf> Yes.
09:39:38 <shachaf> So does spawn, except in another thread.
09:39:40 <hpc> shachaf: at that point, you can just say "ioMemo = id"
09:40:05 <hpc> (return . return) doesn't add anything useful over return
09:40:15 <shachaf> Yep. :-)
09:40:16 <hpc> at least, not when both returns are the same
09:40:18 <hpc> :P
09:41:15 <DanBurton> sure it does, sort of. if you do "a' <- ioMemoUpFront a; a'; a'" then the action would only be performed once
09:41:53 <shachaf> If you do x <- ioMemoUpFront; blah x; blah x then the action would only be performed once.
09:41:58 <hpc> DanBurton: but then you could just do "a' <- a; return a, return a"
09:42:05 <DanBurton> indeed
09:42:13 <hpc> DanBurton: but then you could just do "a' <- a; return a'; return a'" -- rather
09:42:26 <shachaf> hpc: It's much more entertaining that "join" for spawn is actual thread "join" as well as monad "join".
09:42:49 <hpc> shachaf: oh, that it is
09:42:52 <hpc> i like it
09:42:53 <DanBurton> shachaf: an interesting unintended pun
09:43:03 <shachaf> Or is it?
09:43:30 <DanBurton> well it's more like the same word, that you thought was applied to different situations, actually suits both simultaneously with the same generalized definitionn
09:44:06 <edwardk> preflex: xseen roconnor
09:44:07 <preflex>  roconnor was last seen on freenode/#haskell 2 hours, 47 minutes and 25 seconds ago, saying: Though I prefer the term, "computer scientist"
09:45:50 <hpc> yo dawg, i heard you like haskell, so i put haskell in your #haskell :D
09:46:33 <edwardk> hpc: haskell in #haskell? it'll never happen
09:47:06 <hpc> edwardk: i assume you have joins hidden?
09:47:33 <edwardk> ah, no, just very dim ;)
09:47:39 <hpc> :P
09:48:04 <haskell> Newbie help question: New to haskell and trying to get a basic thirft interaction going, bit get errors when try tp cabal thrift package:  Simon-MacBookPro:Haskell simon$ cabal install Thrift
09:48:04 <haskell> Resolving dependencies...
09:48:04 <haskell> Configuring binary-0.5.1.0...
09:48:04 <haskell> ghc: could not execute: /Developer/usr/bin/gcc
09:48:04 <haskell> cabal: Error: some packages failed to install:
09:48:04 <haskell> Thrift-0.6.0 depends on binary-0.5.1.0 which failed to install.
09:48:05 <haskell> binary-0.5.1.0 failed during the configure step. The exception was:
09:48:05 <haskell> ExitFailure 1
09:48:32 <shachaf> I heard you like Haskell, so I pasted a bunch of Cabal output in your channel.
09:48:41 <edwardk> haskell, if you want to paste, please use hpaste
09:48:42 <edwardk> @hpaste
09:48:43 <lambdabot> Haskell pastebin: http://hpaste.org/
09:48:45 <hpc> oh hey, another simon
09:48:46 <shachaf> haskell: Please use hpaste.org for more than a couple of lines.
09:49:13 <hpc> haskell: do you have gcc?
09:49:15 <edwardk> that helps avoid flooding the channel and is far more likely to get a response =)
09:49:15 <shachaf> haskell: At any rate, the problem seems to be with your gcc installation. Do you have gcc installed?
09:49:25 <nand`> Is it just me or is that an odd path to install anything to? /Developer/usr/bin/gcc
09:49:33 <shachaf> Is it true that ddarius pronounces "Haskell" with emphasis on the second syllable?
09:49:36 <haskell> yes, have gcc
09:49:36 <hpc> nand`: apple
09:49:41 <edwardk> shachaf: yes
09:49:45 <edwardk> shachaf: so does shapr
09:49:53 <hpc> i used to
09:49:56 <haskell> but its not on that path, its usr/bin/gcc
09:50:01 <hpc> before i heard how it is said on wiktionary
09:50:12 <hpc> haskell: /usr/bin/gcc
09:50:15 <shachaf> I guess it's a Southern thing.
09:50:16 <hpc> leading slash is crucial
09:50:26 <nand`> I mostly use ‚ÄúHaskell‚Äù in German speech so emphasizing anything but the first syllable would sound particularly alien
09:50:34 <haskell> yes, slip of the finger, but where do I configure that path for cabal?
09:50:39 <hpc> ah
09:50:54 <hpc> put /usr/bin on your path, probably
09:50:54 <DanBurton> I pronounced it that way too, when I was a noob
09:51:02 <edwardk> nand`: sok, it sounds particularly alien to hear them say it ;)
09:51:11 <haskell> its is - jsut gcc at teh prompt works fine
09:51:31 <nand`> haskell: symlink /Developer/usr/bin to /usr/bin I suppose
09:51:36 <nand`> if it's truly looking at that path
09:51:37 <edwardk> DanBurton: i don't think either of them can be classified as n00bs. its just funny at times
09:51:49 <haskell> dirty
09:51:51 <hpc> or symlink gcc, if there's stuff in that directory alrady
09:51:54 <nand`> haskell: blame apple
09:51:55 <hpc> *already
09:52:04 <edwardk> i used to mangle combinators as com-BINE-ators
09:52:46 <hpc> "comBINEator" sounds like a decepticon lol
09:54:10 <nand`> hpc: or move the stuff in /Developer over to the real /usr/bin; then symlink that
09:54:21 <hpc> or that
09:54:27 <ChristianS> "kell" means "testicle", according to http://en.wiktionary.org/wiki/kell . so now we know what has-kell means. not sure if that's really helpful, though...
09:54:31 <nand`> You can't symlink if it exists either way
09:54:42 <nand`> ChristianS: Haskell is a very manly language, it would seem
09:54:43 <hpc> ChristianS: delightful
09:55:03 <DanBurton> come to think of it, I have never heard of a female using Haskell...
09:55:14 <ben> 'a female'
09:55:17 <mm_freak_> i teached haskell to a female friend
09:55:23 <hpc> DanBurton: except for all the ones that do :P
09:55:23 <ben> people aren't your biology class specimens, yo
09:55:29 <KorriX> hello
09:55:36 <DanBurton> hpc: I'm sure they exist. But I'm unaware of any.
09:55:38 <hpc> ben: no, they're his sociology specimens
09:55:43 <ion> Oh, i thought the rule was that everyone whose nick begins with ‚Äúdan‚Äù on #haskell must be female.
09:55:45 <KorriX> is there any method to export imported module in my modul ?
09:56:04 <haskell> aint no such dir as /Developer
09:56:09 <mm_freak_> KorriX: module X (module Y) where import Y
09:56:15 <KorriX> thanks
09:56:19 <DanBurton> ion: what a silly thing to think. Actually I started going by "Dan" when my younger cousin "Danielle" was born and started hogging the nickname "Danny"
09:56:32 <nand`> haskell: symlink it either way any see what happens :)
09:58:03 <applicative> haskell: http://stackoverflow.com/questions/9387983/cabal-doesnt-work-on-mac-os-x-lion-because-of-gcc-path/9388867#9388867
09:58:25 <curry> , haskell
09:58:31 <applicative> haskell, or rather the whole thread or whatever they call them
09:58:34 <hpc> applicative: get your logic out of our wild speculation
09:59:03 <DanBurton> @slap curry
09:59:03 * lambdabot jabs curry with a C pointer
09:59:19 <curry> Ouch! C pointers hurt :(
09:59:36 <DanBurton> but they're powerful
09:59:38 <mm_freak_> then keep away from Foreign.Ptr
09:59:42 <DanBurton> though dangerous
09:59:53 * DanBurton hands curry a Warm Fuzzy Thing
09:59:53 <hpc> with great power comes great segfaults
09:59:56 <hpc> or something like that
10:00:01 <mm_freak_> because there is no such thing as a "C pointer" =)
10:00:25 <curry> A C pointer is clearly something C considers to be a pointer
10:00:27 <hpc> technically, it would be an x86 pointer
10:00:31 <hpc> the CPU knows dereferencing
10:01:01 <mm_freak_> curry: what exactly?  perhaps you could call it "C pointer notation"
10:01:25 <mm_freak_> i fail to see the difference between "int *" and "Ptr CInt"
10:01:36 <curry> mm_freak_: I don't know much C, doesn't it have type safe pointers? Ie. you can only dereference something if it's defined or casted to a ‚Äúpointer type‚Äù?
10:01:43 <hpc> mm_freak_: the CInt is boxed :P
10:01:46 <mm_freak_> curry: C++ has that
10:01:55 <shachaf> mm_freak_: Surely C's semantics have different guarantees from Haskell's FFI's?
10:02:00 <rwbarton> C also has that
10:02:02 <bill```> auto_ptr, shared_ptr, weak_ptr, etc.
10:02:03 <mm_freak_> hpc: the notion of "boxed" doesn't make sense with Ptr
10:02:10 <hpc> curry: not even close :P
10:02:17 <mm_freak_> hpc: see Storable
10:02:21 <hpc> mm_freak_: ah
10:02:43 <mm_freak_> hpc: of course the Ptr itself is boxed
10:02:56 <hpc> curry: in C, the only type is "bytes"
10:03:01 <curry> mm_freak_: ‚Äúint *‚Äù and ‚ÄúPtr CInt‚Äù have different context, to put it simply; therein lies their difference. While they may be semantically and functionally the same thing, their context is difference (one is a valid Haskell type, the other is a valid C type)
10:03:01 <rwbarton> a value has to have pointer type to dereference it in C, of course you can cast pretty much anything to anything
10:03:08 <shachaf> hpc: What?
10:03:09 <curry> hpc: don't you mean chars? :)
10:03:14 <shachaf> What about all those other types?
10:03:21 <curry> shachaf: newtypes
10:03:29 <shachaf> Like float?
10:03:36 <shachaf> And functions?
10:03:39 <mm_freak_> curry: there is no techical difference except perhaps that the Ptr itself can be garbage-collected in haskell
10:03:48 <mm_freak_> and that it can be undefined or all the other haskell peculiarities
10:03:54 <hpc> shachaf: float = 4-bytes, function = pointer
10:04:10 <shachaf> hpc: I'm not sure what your point is.
10:04:13 <mm_freak_> Mu Ptr
10:04:13 <hpc> it's so easy to break gcc type checking
10:04:18 <hpc> that the types might as well not exist
10:04:29 <shachaf> Are you talking about C semantics or some implementation?
10:04:39 <shachaf> In Haskell everything is bytes too, because you can compile it to C!
10:05:06 <mm_freak_> shachaf: [0..] is bytes in haskell?
10:05:25 <curry> mm_freak_: It's an AST represented using bytes
10:05:39 <curry> enough with this silly name
10:05:45 <shachaf> mm_freak_: unsafeCoerce [0..] :: Ptr Word8
10:05:48 <shachaf> Clearly it is!
10:05:51 <ion> :-)
10:06:18 <mm_freak_> > fix id
10:06:19 <hpc> shachaf: who needs Ptr, coerce straight to Word32
10:06:22 <lambdabot>   mueval-core: Time limit exceeded
10:06:44 <mm_freak_> shachaf: Integer is definitely not bytes
10:07:00 <Enigmagic> mm_freak_: it's a byte array
10:07:03 <ion> % ghc -e ':m + Foreign Unsafe.Coerce' -e 'peek (unsafeCoerce [0..] :: Ptr Word8)'
10:07:05 <ion> [1]    5017 segmentation fault  ghc -e ':m + Foreign Unsafe.Coerce' -e
10:07:14 <mekeor> lol, curry hehe
10:07:38 <shachaf> ion: What do you know! The same thing that would happen if you started randomly casting pointers from one type to another in C.
10:07:40 <nand`> > fix $ (0:) . map (+1)
10:07:41 <lambdabot>   [0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,...
10:07:52 <ion> I think this is the first time i‚Äôve explicitly dereferenced an invalid pointer in Haskell.
10:08:50 <shachaf> Integer is a more byte-y type than most, for that matter.
10:09:03 <Enigmagic> shachaf: and it's easy to convert integers to bytestrings
10:09:28 <Enigmagic> getIntegerBytes (J# s b) = B.packCStringLen (Ptr (byteArrayContents# b), 8 * I# s)
10:09:37 <Enigmagic> for the J# constructor :)
10:10:02 <shachaf> But then you're in trouble if it was S#
10:10:28 <Enigmagic> shachaf: nah it just doesn't fit on a line https://gist.github.com/40e7d075ea51f267e847
10:11:10 <hpc> toInteger :: Int -> Integer
10:11:15 <hpc> toInteger = unsafeCoerce
10:11:45 <shachaf> Hah, that would work, actually, wouldn't it.
10:11:52 <hpc> indeed
10:11:57 <hpc> isJust = unsafeCoerce
10:12:04 <hpc> null = not . unsafeCoerce
10:12:09 <shachaf> isTrue = unsafeCoerce
10:12:18 <hpc> id = unsafeCoerce
10:12:22 <nand`> hpc wins
10:12:25 * Tinned_Tuna face palms
10:12:25 <shachaf> unsafCoerce = unsafeCoerce
10:12:36 <shachaf> Enough of this.
10:12:58 <Tinned_Tuna> Heresy.
10:12:59 <hpc> @src Mu
10:12:59 <lambdabot> newtype Mu f = In { out :: f (Mu f) }
10:13:13 <hpc> here's a good one
10:13:13 <ion> @quote isJust
10:13:14 <lambdabot> ddarius says: isJust :: Maybe a -> Bool; isJust = unsafeCoerce
10:13:15 <ion> @quote isTrue
10:13:16 <lambdabot> shachaf says: isTrue :: Bool -> Bool; isTrue = unsafeCoerce
10:13:37 <hpc> treeToLists :: Tree () -> Mu []
10:13:41 <hpc> treeToLists = unsafeCoerce
10:13:55 <hpc> it exploits newtype-ness
10:14:19 <hpc> and VERY carefully avoids an infinite type too
10:14:27 <Saizan> how is Tree defined?
10:15:29 <mekeor> @src Tree
10:15:29 <lambdabot> Source not found. Listen, broccoli brains, I don't have time to listen to this trash.
10:15:48 <nand`> I don't like @src
10:15:52 <nand`> its error messages are scary :(
10:16:05 <edwardk>  tree is cofree, not mu
10:16:34 <mekeor> i guess: data Tree a = Foo a | Bar (Tree a) (Tree a)
10:16:43 <shachaf> Mu [] is tree skeletons.
10:17:04 <nand`> mekeor: Isn't it usually data Tree a = Foo | Bar a (Tree a) (Tree a) ?
10:17:18 <edwardk> mekeor: Tree is a rose tree
10:17:26 <edwardk> data Tree a = Tree a [Tree a]
10:17:44 <nand`> edwardk: no empty trees?
10:17:49 <mekeor> oO
10:17:52 <edwardk> correct
10:18:00 <mekeor> wow
10:18:31 <edwardk> http://hackage.haskell.org/packages/archive/containers/0.4.2.1/doc/html/Data-Tree.html
10:18:38 <edwardk> hence why its a comonad =)
10:19:38 <hpaste> ben pasted ‚Äúfib‚Äù at http://hpaste.org/64490
10:19:45 <ben> ^ how can I do this without scopedtypevariables?
10:20:44 <ben> sorry, 'this' being giving go a type signature
10:21:00 <hpc> Saizan: data Tree a = Leaf a | Branch (Tree a) (Tree a)
10:21:24 <nand`> ben: I don't think you can, since go's ‚Äòs‚Äô needs to be the same as fibST's
10:21:30 <hpc> (sorry, moving from class to lounge)
10:21:31 <mekeor> hpc: as i said‚Ä¶
10:21:50 <hpc> also, i think the type can actually be
10:22:00 <hpc> spineToLists :: Tree a -> Mu []
10:22:30 <hpc> unsafeCoerce: the most versatile function
10:22:35 <nand`> ben: Instead of including ScopedTypeVariables I just leave out the type, personally
10:22:50 <ben> It feels kinda icky using things that I can't name the type of
10:23:01 <ben> like it's cheating, and once i get caught i can't get it to work anymore
10:23:03 <hpc> (im making this a blog post)
10:23:55 <nand`> ben: you can rewrite go as :: forall s. STRef s -> STRef s -> STRef s -> ST s Integer  (or whatever) and pass the parameters explicitly
10:24:00 <nand`> in that process also generalizing it
10:24:33 <hpc> nand`: STRef :: * -> * -> *
10:24:45 <ben> I've seen that version, I just tried to stay as close to a C implementation as it'd let me
10:24:46 <nand`> hpc: oh okay; I've never used it, was just guessing
10:24:48 <nand`> the same concept applies
10:25:02 <hpc> indeed
10:25:56 <ben> (I was a bit surprised that all the ST stuff doesn't get inlined or optimised out in the core)
10:26:09 <efie> I followed this ( http://projects.haskell.org/gtk2hs/docs/tutorial/glade/ ) glade tutorial, but I think something with the created .glade file ( http://hpaste.org/64489 ) is wrong. When I run the. exe file I get the following: "libglade-WARNING **: Expected <glade-interface>. Got <interface>. "
10:28:16 <hpc> efie: when you create the .glade file, pick a different "type" or whatever it's called
10:28:58 <hpc> i forget exactly what the options are, but the dropdown itself is hard to miss
10:30:22 <efie> hpc: i can choose between "GtkBuilder " (enabled) and "Libglade" - do you mean with types?
10:31:21 <hpc> efie: yes, those
10:31:28 <hpc> i think
10:31:31 <hpc> it's been a while
10:31:39 <hpc> whichever one it was before, pick the other
10:33:16 <rostayob> hpc: https://gist.github.com/1934179 this is great
10:33:41 <hpc> rostayob: :D
10:33:53 <rostayob> hpc: if you don't post it I will!
10:34:05 <hpc> rostayob: im definitely posting it
10:34:12 <rostayob> ok :)
10:34:20 <hpc> but you can post as well :P
10:34:57 <rostayob> hpc: whatever, better not to have duplicates
10:36:11 <efie> hpc: big thanks! it works (although, if I pick "Libglade" it says "objecttypclass 'action'" wont be supported and a lot of error occurs when running the .exe)
10:37:06 <hpc> efie: yeah, i learned pretty quick that glade isn't a pleasant way to make a UI :P
10:38:27 <efie> hpc: what do you use then now? i tried do this by hand without such a RAD tool, but that was struggeling too
10:38:27 * applicative , looking at that gist, has decided to report hpc and rostayob to the authorities
10:38:52 <geekosaur> libglade has been deprecated at the gtk+ level for a while, not surprising it gets warnings and such
10:39:13 <hpc> efie: i just code the UI myself
10:39:36 <efie> ok :)
10:39:40 <hpc> it's not so bad once you see how the gtk modules are laid out
10:39:49 <hpc> (okay, it's still pretty bad, but less bad than glade)
10:41:08 <efie> :D ok, i will give glade a try for now
10:46:42 <DanBurton> shachaf, hpc: I'm going to publish my code as a little library on Hackage, and I'm giving a little shout out to you for helping me reason about it. Would you prefer I refer to you by "shachaf" and "hpc" respectively, or by some other name, or not at all?
10:48:19 <hpc> DanBurton: headprogrammingczar
10:49:04 <liot> is there a way for me to tell cabal-install to look for dependencies in my user packages before the base install ones?
10:49:59 <DanBurton> hpc: as you wish. I bet that name is usually available for whatever MMO you might want to play :)
10:53:06 <DanBurton> liot: quite possibly, but I have no clue.
10:53:11 <DanBurton> @google cabal user guide
10:53:13 <lambdabot> http://www.haskell.org/cabal/users-guide/
10:53:13 <lambdabot> Title: Cabal User Guide
10:53:16 <DanBurton> check there ^
11:07:46 <sshack> hi, haskell/osx question. Is there a new cabal (or way to force use of certain gcc)? Xcode 4.3 kills  /Developer/usr/bin/gcc gets blown away in the upgrade.
11:10:36 <geekosaur> sshack, http://www.haskell.org/pipermail/glasgow-haskell-users/2012-February/021905.html
11:10:55 <geekosaur> (from which you should also be able to infer how to specify a gcc)
11:11:00 <sshack> I've *just* found that.
11:11:14 <sshack> duckduckgo failed me, google wins.
11:12:18 * hackagebot io-memoize 1.0.0.0 - Memoize IO actions  http://hackage.haskell.org/package/io-memoize-1.0.0.0 (DanBurton)
11:13:14 <sshack> geekosaur: Works now, thanks.
11:15:44 <DanBurton> @tell shachaf I credited you for helping me with ioMemo. Let me know if that's a problem, or if you want me to refer to you by a different name in the docs http://hackage.haskell.org/package/io-memoize-1.0.0.0
11:15:45 <lambdabot> Consider it noted.
11:18:33 <DrLogos> nh2 @ #haskell :  Discard this, this is a test.
11:19:05 <dzhus> http://svn.codehaus.org/groovy/trunk/groovy/groovy-core/src/main/org/codehaus/groovy/runtime/ArrayUtil.java
11:26:06 <DanBurton> dzhus: wat
11:27:54 <jay7557> Hello everybody!
11:30:08 <jay7557> does anybody have the template to get input at command line arguement?
11:30:52 <MagneticDuck> You mean, get command line arguments?
11:30:58 <MagneticDuck> For a console program?
11:30:59 <jay7557> yes
11:31:07 <jay7557> yep!
11:31:18 <MagneticDuck> getArgs
11:31:29 <MagneticDuck> You have to import System.Environment
11:31:56 <MagneticDuck> > @type getArgs
11:31:57 <lambdabot>   <no location info>: parse error on input `@'
11:32:04 <MagneticDuck> @type getArgs
11:32:05 <lambdabot> Not in scope: `getArgs'
11:32:13 <MagneticDuck> > import System.Environment
11:32:14 <lambdabot>   <no location info>: parse error on input `import'
11:32:28 <MagneticDuck> @type System.Environment.getArgs
11:32:29 <lambdabot> IO [String]
11:32:34 <MagneticDuck> Ah, that's better.
11:32:37 <jay7557> what is @type getArgs? am new to this..
11:32:46 <ion> The same as :t in ghci.
11:33:05 <ion> It prints the type of the expression.
11:33:12 <jay7557> ok
11:33:18 <MagneticDuck> @type ["hello"]
11:33:19 <lambdabot> [[Char]]
11:33:55 <jay7557> it doesn't work at ghci
11:34:06 <jay7557> does it have to be in script file?
11:34:12 <dylukes> Quick question, how can I suppress GHC spewing "warning: missing terminating ' character" warnings/errors?
11:34:26 <ion> Works for me. You‚Äôll need to provide more information than ‚Äúit doesn‚Äôt work‚Äù.
11:34:53 <MagneticDuck> jay7557: getArgs should return [] in ghci
11:34:56 <jay7557> <interactive>:1:1: parse error on input `@'
11:35:03 <dylukes> Even setting -pgmP and -pgmF to cpphs does not fix it.
11:35:04 <MagneticDuck> You have to use :t
11:35:22 <ion> jay7557: Run :help in ghci.
11:36:09 <jay7557> Oh yeah thanks it works
11:36:20 <jay7557> after I imported System in ghci
11:36:27 <jay7557> and :type getArgs worked!
11:36:35 <MagneticDuck> Oh, you should just import System.Environment.
11:36:54 <MagneticDuck> System includes all of the System modules-- IO, Environment...
11:37:15 <MagneticDuck> It's usually good practice to import just a select submodule in a small program.
11:37:56 <ion> In ghci, you can also refer to fully qualified names without importing them, e.g. System.Environment.getArgs.
11:38:20 <MagneticDuck> Yeah.
11:38:26 <jay7557> I am required to make small program which gets arguments as key and then scrambles text file
11:39:23 <MagneticDuck> Okay, you would pattern match a filepath string to one argument, and then pass that to your IO () function that scrambles the text in the file.
11:39:44 <MagneticDuck> The last function is up to you! :)
11:39:54 <MagneticDuck> Although we can help.
11:40:09 <jay7557> Would I need to create separate function or does it have to be in main
11:40:26 <jay7557> thanks MagneticDuck any help would be greatly appreciate
11:40:43 <jay7557> This Haskell errors are killing me
11:40:53 <MagneticDuck> I would create a separate function, but for a *really* small function, you could write it in a where statement for main
11:40:58 <ion> If unsure, use a separate function. :-)
11:41:15 <MagneticDuck> jay7557: post your code on hpaste.org!
11:41:19 <jay7557> ok
11:41:20 <ion> (and the error)
11:41:36 <MagneticDuck> And be sure to tell the site that you're posting it for #haskell
11:41:56 <hpaste> jay7557 pasted ‚Äúencoding‚Äù at http://hpaste.org/64494
11:42:07 <dylukes> aghghghghg, goddamn it ghc.
11:42:37 <MagneticDuck> dylukes: Sorry, can't help you there! I'm still a newbie at GHC. :D
11:42:56 <MagneticDuck> jay7557: first, scramble should be of type String -> String.
11:43:35 <MagneticDuck> Second, I'd recommend actually having (scramble :: FilePath -> IO ()) though!
11:43:54 <jay7557> ok
11:43:59 <MagneticDuck> For bigger files, you don't want to be passing around the data as a string! It can be slow.
11:44:28 <jay7557> i have changed that
11:44:28 <nh2> ??monitored
11:44:35 <MagneticDuck> Or wait... actually for your use, just use String -> String
11:45:02 <ChristianS> yes, Char is just a single letter
11:45:37 <jay7557> I have changed that
11:45:40 <edwardk> preflex: xseen dmwit
11:45:41 <preflex>  dmwit was last seen on freenode/#haskell 5 hours, 16 minutes and 33 seconds ago, saying: ?wiki Haskell in industry
11:46:09 <MagneticDuck> Alright... getContents will extract from stdin, or in this case, the terminal. This program will just spurt out scrambled text whenever you press the enter key. (The text you entered.)
11:46:47 <nh2> ??new #whoisdrlogos Who the heck is Dr. Logos?
11:46:48 <DrLogos> nh2 @ #whoisdrlogos :  Who the heck is Dr. Logos?
11:46:56 <MagneticDuck> You can use readFile.
11:47:05 <nh2> OK guys, here's our new tool which we want to try out. In #haskell, of course.
11:47:16 <jay7557> ok
11:47:26 <nh2> It's a bot (written in Haskell) that groups conversations on IRC.
11:47:26 <MagneticDuck> You understand how it works?
11:47:46 <jay7557> I am going to have a text file which will contain poem
11:48:19 <MagneticDuck> alright, so you'd write (fileStr <- readFile poemPath)
11:48:22 <jay7557> and then cat poem.text | ./scramble ABC123
11:48:37 <kuznero> Hi All!
11:48:46 <MagneticDuck> Wait, what does ABC123 do?
11:48:53 <ion> @type System.IO.interact
11:48:53 <lambdabot> (String -> String) -> IO ()
11:48:55 <jay7557> that's the key
11:48:59 <ion> jay7557: You might find that useful.
11:49:00 <MagneticDuck> Oh, I see!
11:49:11 <nh2> You can start a new conversation by typing ??new #[questiontag] [some discussion topic]. It will create a new channel on freenode for that topic and mirror the conversation in here. The aim is to allow some structure in big IRC channels where people ask questions.
11:49:26 <nh2> Let me demonstrate:
11:49:32 <MagneticDuck> Alright, I didn't understand your problem! Sorry for messing with your mind there! Use getContents.
11:49:33 <MagneticDuck> :)
11:49:42 <kuznero> Does anybody know what is the fastest way of compiling big codebase in haskell? `Cabal install` seems to be using only one core... and thus very slow...
11:49:44 <jay7557> which is used to scramble that text in poem.text
11:49:51 <MagneticDuck> BTW, I bet you're doing this from LYAHFGG?
11:49:52 <ion> magneticduck: ‚Ä¶or interact.
11:50:00 <nh2> ??new #whyhaskell Why should I use Haskell?
11:50:00 <jay7557> nah it's fine :)
11:50:00 <DrLogos> nh2 @ #whyhaskell :  Why should I use Haskell?
11:50:09 <nh2> now I /j #whyhaskell
11:50:09 <MagneticDuck> Yeah, although personally I prefer getContents.
11:50:26 <jay7557> so that's right then?
11:50:38 <jay7557> I can echo the text
11:50:49 <DrLogos> nh2 @ #whyhaskell : Hey guys, what is the difference between a strict and a lazy bytestring?
11:51:37 <kuznero> I tried doing `runghc Setup.hs install` which seems to be faster, but is this way correct?
11:51:55 <DrLogos> nh2 @ #whyhaskell : Because the conversation originated in #haskell, all answers will be broadcasted back here.
11:51:57 <MagneticDuck> DrLogos: A strict bytestring contains everything in the string in one "chunk," and so there's no buffering. A lazy bytestring will break it up into chunks, although they're usually more than just one character, unlike Strings.
11:52:21 <DrLogos> nh2 @ #whyhaskell : Posting from #haskell into a conversation is not supported yet.
11:52:45 <ChristianS> DrLogos: your approach seems pretty pointless then, i'm sorry to say
11:53:04 <MagneticDuck> jay7557: Your code is correct, except that you have to apply scramble to the string in main, and scramble takes a String and gives a String.
11:53:15 <ion> Sounds like a tool in search for a need. :-P
11:53:27 <MagneticDuck> ion: There's lots of stuff like that!
11:53:29 <jay7557> That's what the difficult thing is :D
11:53:45 <MagneticDuck> scramble?
11:53:49 <ion> You have a function :: String -> String, right?
11:53:52 <nh2> ChristianS: well, that's just because we've only worked 2 days on it, it'll come soon
11:53:52 <jay7557> yh
11:53:53 <ion> @type System.IO.interact
11:53:54 <lambdabot> (String -> String) -> IO ()
11:53:55 <MagneticDuck> Oh, I have to go, sorry!
11:54:09 <jay7557> no problem
11:54:14 <kuznero> Who's using `cabal install` instead of something else? (don't know how to ask alread... :( )
11:54:22 <kuznero> :)
11:54:37 <jay7557> Will you be back anytime soon?
11:54:52 <ChristianS> nh2: also, flooding freenode with new copycat channels seems dubious to me
11:55:26 <ion> jay7557: There are other people potentially willing to help on this channel, too. :-)
11:55:56 <jay7557> Thanks! This is place is great.
11:56:05 <jay7557> This place is great*
11:56:17 <kuznero> I hope somebody can help me too... :)
11:56:27 <kuznero> Even though I know this place is cool :)
11:56:33 <xheavenlyx> Python is back!
11:56:34 <xheavenlyx> oops
11:56:38 <jay7557> lol
11:56:56 <jay7557> I am learning the baby steps
11:57:21 <_vic> Monadic baby stept
11:57:28 <_vic> *steps
11:57:50 <jay7557> and get stuck at every step I take
11:57:52 <jay7557> :D
11:58:07 <_vic> Trial and error is good.
11:58:22 <_vic> The best way to learn
11:58:38 <kuznero> Ok, will try from another angle - is it possible to tell cabal compile sources with using multiple cores?
11:58:47 <jay7557> yeah it is but sometimes you need somebody to guide you in correct direction
11:59:04 <_vic> Yeah, and that's why we have #haskell
11:59:06 <jay7557> a little bit makes lot of difference
11:59:14 <_vic> Or the web resources
11:59:18 <_vic> But IRC is better
11:59:50 <_vic> And someday... Lynda.com video tutorials haha
12:01:18 <jay7557> Lynda doesnt know Haskell
12:01:20 <jay7557> :(
12:01:38 <_vic> But Channel9 does.
12:02:45 <rudyl313> What does the "!" mean in this statement: data Value = Object !Object
12:02:48 <_vic> Check this out  http://channel9.msdn.com/shows/Going+Deep/Lecture-Series-Erik-Meijer-Functional-Programming-Fundamentals-Chapter-1/
12:03:00 <Veinor> I have a stream of Tag objects; I want to parse this into a list of Result objects by specifying a function that takes a list of results, consumes some, and either outputs a Result or an Error. what's the monad I want?
12:03:02 <maurer> rudyl313: It means that the Object parameter is strict
12:03:02 <Veinor> rudyl313: strictness
12:03:20 <Veinor> Object undefined = undefined
12:03:21 <rudyl313> strict, as apposed to lazy?
12:03:26 <_vic> yep
12:03:28 <Veinor> yes
12:03:40 <rudyl313> hmmm, when would you want that?
12:03:58 <Veinor> performance reasons iirc
12:04:04 <_vic> Performance reasons
12:04:15 <_vic> Damn
12:04:20 <rudyl313> Also is generally okay to have a value constructor that takes a value with a type of the same name
12:04:31 <rudyl313> i.e. data Value = Object Object
12:04:57 <rudyl313> where Object is another data type
12:05:21 <Veinor> i'm unsure of why you'd want to do that in this particular case; why not data Value = Value Object (or just newtype Value = Object)
12:05:38 <rudyl313> I'm actually looking at the source for Aeson
12:05:40 <ion> As long as you don‚Äôt find it confusing and you don‚Äôt think others will.
12:06:23 <rudyl313> in my case I'm building a tree... data Tree = Branch Tree Tree | Leaf Leaf
12:06:33 <rudyl313> and I'm going to define the Leaf type somewhere else
12:06:52 <rudyl313> I'm just not sure how to name the Tree value constructor for Leaf
12:07:34 <ion> How about data Tree a = Branch (Tree a) (Tree a) | Leaf a?
12:08:20 <rudyl313> ion: well if I end up setting a to Leaf it doesn't change the fact that I have a Leaf Leaf
12:08:23 <edwardk> data Tree a = Bin (Tree a) (Tree a) | Tip a -- is a free monad btw
12:09:02 <rwbarton> I guess normally your Leaf data type would have some intrinsic meaning aside from the fact that it happens to be a leaf in some tree
12:09:03 <edwardk> rudyl313: but then you need a leaf data type with a completely different constructor name
12:09:04 <rudyl313> Tip ... thats a good name to give it
12:09:37 <ion> rudyl313: What‚Äôs the definition of your Leaf type?
12:09:44 <edwardk> instance Monad Tree where return = Tip; Tip a >>= f = f a; Bin l r >>= f = Bin (l >>= f) (r >>= f)
12:09:59 <rudyl313> edwardk: my Leaf type is probably going to have a single value constructor with a lot of fields (record syntax)
12:10:14 <rudyl313> ion: ^
12:10:26 <edwardk> rudyl313: well if its completely monomorphic thats fine, just pointing out that you can make the monad above if you leave the type argument in place
12:10:34 <ion> rudyl313: See what rwbarton said above.
12:10:52 <jay7557> thanks for the link on channel9
12:11:17 <rudyl313> rwbarton: good point.. I should rename the Leaf datatype... it's purpose is not just being a leaf
12:11:24 <jay7557> is there any tutorial to learn making function which work at command line arguements
12:11:30 <jay7557> ?
12:11:31 <rudyl313> gotta head out to lunch ... thanks for all the advice guys :)
12:11:53 <rudyl313> ion: edwardk: rwbarton: ^
12:12:17 <Gothmog_> ion: As a side note: That kind of tree can never be empty.
12:12:20 * hackagebot stm-conduit 0.2.3.0 - Introduces conduits to channels, and promotes using  conduits concurrently.  http://hackage.haskell.org/package/stm-conduit-0.2.3.0 (ClarkGaebel)
12:12:22 <ion> jay7557: It‚Äôs probably better to make a function that works for any appropriate value and then get a value from the command line arguments and apply the function to that.
12:12:43 <edwardk> Gothmog_: yeah. i gave a talk on finger trees in which i described leafy vs. node based trees and that comes up
12:13:11 <edwardk> rudyl313: http://comonad.com/reader/2010/finger-trees/ has lots of discussions about trees in the slides
12:13:18 <edwardk> rudyl313: you might want to mine through that for ideas
12:13:43 <Veinor> I have a stream of Tag objects; I want to parse this into a list of Result objects by specifying a function that takes a list of results, consumes some, and either outputs a Result or an Error. I eventually want to turn the list of tags into a list of results, maybe with an error. what's the monad i want?
12:14:16 <zhulikas> how can I recompile some specific package after changing it's source? package is global
12:14:47 <zhulikas> well, not entirely global, it's in my ~/.cabal
12:15:00 <ion> Run ‚Äúcabal install‚Äù in the root of its source tree.
12:15:23 <zhulikas> ok, thanks
12:15:34 <Veinor> maybe i want iteratee or conduit or one of those
12:17:32 <Veinor> hm no not conduit
12:22:04 <Veinor> alternately: are there any parser libraries that can handle streams of non-text data nicely?
12:24:02 <c_wraith> depends...  Do you want streaming results, too?
12:24:17 <zhulikas> ok, so I recompiled one of my packages and now build fails
12:24:24 <zhulikas> because hash is different
12:24:27 <Veinor> c_wraith: nah
12:24:36 <Veinor> I have access to the entire input at once
12:24:36 <zhulikas> damn...
12:24:46 <c_wraith> then attoparsec should be fine...  It's intrinsically byte-oriented.
12:24:57 <Veinor> well like
12:25:11 <Veinor> the thing is i'm parsing html
12:25:20 <Veinor> so i'm using tagsoup to get Tag values
12:25:25 <c_wraith> Ah
12:25:30 <c_wraith> that's what you meant
12:25:37 <c_wraith> Parsec can handle that.
12:25:44 <c_wraith> It supports parsing arbitrary token streams
12:25:54 <c_wraith> You might need to write an instance or two, though
12:28:58 <Veinor> really? it looks like i have to do things like deal with source positions
12:31:05 <c_wraith> that's just for error reporting
12:31:12 <c_wraith> if you don't care, just set them all to 0, or something
12:31:45 <Veinor> ah
12:34:03 <jay7557> exit
12:34:06 <jay7557> :q
12:34:16 <MagneticDuck> Use /leave
12:34:30 <MagneticDuck> If you're trying to leave from IRC
12:34:41 <hpc> or /quit
12:34:48 <hpc> or /disconnect, i think
12:35:00 <MagneticDuck> Hmm... don't know! I'll try.
12:35:16 <MagneticDuck> Didn't do anything.
12:37:26 <MagneticDuck> However, /quit did work!
12:37:35 <MagneticDuck> Ha ha ha.
12:37:41 <MagneticDuck> I'm back now.
12:38:47 <MagneticDuck> It's nap time again here on #haskell!
12:39:03 <MagneticDuck> Yet there are apparently 886 users...?
12:39:12 <MagneticDuck> I don't get it.
12:40:15 <byorgey> MagneticDuck: everyone is busy writing Haskell code.
12:40:28 <MagneticDuck> Yeah. I better get to work, actually.
12:41:34 <_vic> Everybody is too busy thinking about writing more concise Haskell code, actually
12:42:13 <_vic> 90% thinking, 10% coding, that's Haskell. Versus 10% thinking and 90% coding... like C
12:42:22 <_vic> or something like that
12:42:32 <hpc> _vic: C is 50% coding, 50% gdb
12:42:54 <hpc> java is 10% coding, 90% clicking IDE buttons
12:43:05 <hpc> or something like that
12:43:27 <MagneticDuck> Compared to Haskell, programming in Pascal and C is like... brute force.
12:44:28 <MagneticDuck> Haskell makes you think more about the logic of the program, less time making objects and classes that do nothing. 300 lines of code to write a find and replace function, as opposed to 47.
12:44:51 <Cale> Hello MagneticDuck! How are you doing? :)
12:44:55 <MagneticDuck> Hey there!
12:45:12 <MagneticDuck> We always seem to be offset by a hour, and never get to talk!
12:45:33 <Cale> I go to sleep and wake up at crazy times
12:45:42 <MagneticDuck> BTW, are you at work?
12:46:06 <MagneticDuck> ...do you work from home? That would explain your schedule... ;D
12:46:11 <Cale> I work from home... I'm about to start, just having a cappuccino :)
12:46:20 <MagneticDuck> Alright, that's what I guessed.
12:46:37 <MagneticDuck> That's probably the best thing about being a programmer.
12:46:53 <MagneticDuck> Coffee, I mean. And working from home.
12:47:03 <_vic> We turn coffee into code
12:47:22 <MagneticDuck> "Programmer fuel"
12:47:32 <funktronic> MagneticDuck: amphetamines ?
12:47:34 <_vic> the gateway drug
12:47:49 <Cale> .oO(Curry Howard Isomorphism proof via coffee?)
12:47:49 <MagneticDuck> funktronic: ?
12:48:28 <Cale> programmer . mathematician^-1 :: Theorem -> Code
12:49:26 <MagneticDuck> I've never had to think so hard about my code!
12:49:33 <MagneticDuck> Needless to say, I love this!
12:49:52 <MagneticDuck> I feel like I'm doing math!
12:50:01 <hpc> MagneticDuck: have you tried agda?
12:50:14 <MagneticDuck> Nope. ANOTHER programming language?
12:50:20 <hpc> it's EVEN COOLER than haskell
12:50:30 <MagneticDuck> Then why are you coding in Haskell?
12:50:42 <hpc> because agda is a proof language :P
12:50:59 <Cale> Agda is a bit less practical for everyday real-world use, but its type system is even more powerful
12:50:59 <hpc> last i tried, it took 2 gigs of RAM to compile hello world
12:51:07 <MagneticDuck> ...and a association named "australian graphic design association"
12:51:25 <hpc> MagneticDuck: the joke is that agda programers don't compile their code, they just type-check it
12:51:34 <hpc> (which is true)
12:51:47 <funktronic> hpc: it's also not web-scale. node.js doesn't even need to compile and it's totally web scale
12:52:13 <MagneticDuck> I'd like to learn Haskell first... before you scare me with even weirder programming languages!
12:53:19 <MagneticDuck> Oh, alright, I checked Wikipedia. Got the joke now.
12:54:49 <dzhus> is `process` included with GHC?
12:54:58 <dzhus> (I mean package)
12:55:10 <geekosaur> it's a bootlib, yes
12:55:28 <dzhus> I have ¬´‚Ä¶ is unusable due to missing or recursive dependencies: process-1.1.0.1-‚Ä¶¬ª
12:55:36 <zerax> There's something to be said about programming language that appear complicated to learn and whose expert users are perceived as being able to use the language to gain near omnipotence.
12:55:36 <dzhus> Does this mean that I have to rebuild my GHC?
12:55:47 <zerax> Perhaps it's some kind of formula for successful languages
12:55:54 <hpc> dzhus: or get a different version of the stuff that depends on it
12:56:15 <dzhus> hpc: it's fresh hmatrix that I've just installed. GHC refuses to locate it.
12:56:39 <hpc> what version of hmatrix, what version of ghc?
12:56:54 <ben> There's something else to be said about programming language whose build systems don't work unless you exhibit near omnipotence
12:57:09 <dzhus> hpc: GHC 7.4.1 hmatrix 0.13.1.0
12:57:10 <zerax> Also true
12:57:14 <hpc> dzhus: oh, huh
12:57:22 * hackagebot generic-deepseq 2.0.1.1 - Generic deep evaluation of data structures  http://hackage.haskell.org/package/generic-deepseq-2.0.1.1 (MaximeHenrion)
12:58:20 <zerax> Cabal does sometimes seem to present some kind of aptitude test for its users in the form of getting things to build correctly.
12:58:59 <dzhus> what could case the breakage of process? I don't recall any serious fubaring on my GHC installation, after GHC upgrade I used haskell-updater from my distro and it all workes like charm except hmatrix.
12:59:03 <geekosaur> cabal needs to not try to replace bootlibs
12:59:23 <geekosaur> ...haskell-updater?  that sounds potentially bad just from the name.
12:59:24 <Saizan> dzhus: can we get a more complete error message?
13:00:17 <hpaste> dzhus pasted ‚Äúhmatrix fail‚Äù at http://hpaste.org/64497
13:00:31 <dzhus> Saizan: ^
13:00:49 <dzhus> could it be caused by bootstrapping 7.4.1 from 7.0.4?
13:01:16 <Saizan> package process-1.1.0.1-91185c964ab744c1f3cbca1863d2ba45 is shadowed by package process-1.1.0.1-c50c4cf51a03eb87519e7fce980bbb47
13:01:42 <Saizan> dzhus: try ghc --make -package-id hmatrix-0.13.1.0-ac4f01f67b642469d48f0dae1f63b5a3 Main.hs
13:01:48 <geekosaur> shadowed bootlib.  somehow not surprised
13:01:59 <dzhus> geekosaur: who did that?
13:02:23 * hackagebot huffman 1.0.1 - Pure Haskell implementation of the Huffman encoding algorithm  http://hackage.haskell.org/package/huffman-1.0.1 (MaximeHenrion)
13:02:25 * hackagebot bsd-sysctl 1.0.7 - Access to the BSD sysctl(3) interface  http://hackage.haskell.org/package/bsd-sysctl-1.0.7 (MaximeHenrion)
13:02:38 <geekosaur> dzhus, I have no idea, I cannot see the history of your system from here
13:03:09 <dzhus> Saizan: it worked
13:04:16 <geekosaur> haskell-updater is gentoo.  I was afraid of that
13:04:31 <MagneticDuck> Arrgh! I'm having a newbie problem here... how do I use a case statement to catch the two values possibly contained by Maybe? It's impossible, right? I'm tired now... help?
13:04:33 <geekosaur> gentoo has embarked on a course that is more or less designed to destroy ghc installations
13:04:49 <dzhus> geekosaur: in what way exactly?
13:05:16 <Saizan> i thought haskell-updater managed to fix some screw ups
13:05:20 <Saizan> but i've never used it
13:05:21 <geekosaur> dzhus, updating or replacing a library that comes with the compiler is extremely dangerous and almost always causes exactly the problem you are having
13:05:27 <dzhus> after system ghc update, a simple call to haskell-updater rebuilds everything that is broken
13:05:33 <geekosaur> gentoo's haskell-updater does exactly that, by design
13:05:38 <Saizan> dzhus: anyhow your problem is that you've two installations of process-1.1.0.1
13:05:39 <dzhus> geekosaur: yes, but I've discovered process in my ~/.cabal/lib
13:05:49 <geekosaur> except it did not, it *cause* this breakage
13:06:04 <dzhus> geekosaur: and it's certainly not haskell-updater who did this to my --user db
13:06:25 <brennon_> i'm looking for something like "eval", but i can't seem to find anything in the docs?all i want to do is call the correct function based that = the value of a String
13:06:30 <geekosaur> so, what did?
13:06:49 <geekosaur> brennon_, there is a way to do eval but it is not what you want
13:06:53 <brennon_> not looking for someone to give me a complete answer--just to point me to the right docs
13:07:10 <mauke> brennon_: Map String (X -> Y)?
13:07:21 <dzhus> geekosaur: I guess some other package I installed locally via cabal-install pulled a new process installation
13:07:50 <MagneticDuck> Never mind, I must be tired! Fixed my problem. :P
13:08:17 <brennon_> mauke: i don't want to hard code a map, though
13:08:23 <dzhus> nah, I deleted process from my ~/.cabal/lib. now ghc-pkg unregister cannot find the package
13:08:25 <geekosaur> that is the way to do it, though
13:08:25 <brennon_> mauke: (that's what i'm already doing)
13:09:02 <brennon_> geekosaur: so is it not possible to dynamically determine a function to call at runtime?
13:09:23 <mauke> brennon_: how would that be useful?
13:09:39 <MagneticDuck> Alright, is there anyway to make an advanced console interface, where you can "print in place", that is rewrite something you wrote earlier?
13:09:54 <geekosaur> eval is an *interpreter* function.  haskell is compiled
13:10:20 <geekosaur> it turns out there is a way to do what you want but it means loading the compiler as a library into your program so it can be an interpreter for you
13:10:44 <hpc> it adds the entire size of ghc to your executable's size
13:10:47 <hpc> and it's ugly to boot
13:10:49 <geekosaur> if you want an interpreted function, use an interpreted language to start with
13:11:03 <geekosaur> or use a static map
13:11:05 <mdmkolbe> brennon_: If you mean dynamically *generate* a function (which is what "eval" does), then no, but if you already have the functions (or want to write a micro interpreter for a small language), then yes, you can dynamically *select* a function.
13:11:18 <MagneticDuck> For instance, make an IO () that allowed the user to delete what they wrote.
13:11:57 <MagneticDuck> Sorry, we're having two questions at the same time here...
13:12:17 <geekosaur> MagneticDuck, I wonder if you're looking for hscurses
13:12:33 <Eduard_Munteanu> MagneticDuck: perhaps you can print '\r'?
13:12:56 <Eduard_Munteanu> (carriage return)
13:13:29 <brennon_> sorry about that?wife was pestering me? ;)
13:13:36 <MagneticDuck> hscurses?
13:13:54 <brennon_> that's what i'm doing--dynamically selecting a function, not generating one
13:14:13 <brennon_> but i want the flexibility to not have to hard code a map
13:14:23 <geekosaur> MagneticDuck, as I understand your question you want to be able to update the screen in a general fashion.  hscurses is a library on hackage for doing that in a terminal context
13:14:24 <brennon_> and to take an alternative route if there is no choice
13:14:32 <MagneticDuck> Okay, I'll check that!
13:14:37 <geekosaur> (if you want a GUI context, wxhaskell or gtk2hs)
13:15:04 <geekosaur> brennon_, that is still in the realm of interpreters
13:15:26 <geekosaur> do you REALLY want to have all of ghc built into your program so you can get your "fleibility"?
13:15:48 <brennon_> alright--i'm conflating the remarks of two of you...sorry
13:16:08 <brennon_> mdmkolbe said, "if you already have the functions (or want to write a micro interpreter for a small language), then yes, you can dynamically *select* a function."
13:16:16 <mdmkolbe> brennon_: then your choises are: use GHC API to embed all of GHC in your app, write your own interpreter if you only need a small language, use DLL tricks to do plugins, or figure out a higher level way to do what you want (e.g. are you just trying to implement plugins or what?).
13:16:16 <brennon_> and that's exactly what i'm doing--writing an interpreter
13:17:10 <mdmkolbe> brennon_: Is this hard coded table, just the table of primitives?
13:17:28 <brennon_> no, a table of operators and functions
13:18:15 <geekosaur> o.O
13:18:15 <mdmkolbe> wheeeeeee
13:18:34 <mdmkolbe> brennon_: Who defines these functions and operators?
13:18:53 <mdmkolbe> brennon_: i.e. are the primitive, defined in the language or what?
13:18:56 <brennon_> it's a FORTH interpreter, so, the FORTH specification
13:19:03 --- mode: kornbluth.freenode.net set +o ChanServ
13:19:51 <brennon_> full disclosure, this is a programming assignment, so again, i'm not looking for anyone to 'give away' the answer--just to point me in the right direction
13:20:41 <geekosaur> not sure I could give it away anyway as the answer depends on how they want it implemneted.  I know how Id do it and it would not involve ghc-api
13:21:10 <mdmkolbe> brennon_: Ok, then I would call that a table of primitives (unless I'm missing something).  The usual way is "Map String (A -> B)", perhaps in a seperate file (the source of that file might be generated from a text file).
13:22:16 <brennon_> i see
13:22:25 * hackagebot hackport 0.2.17 - Hackage and Portage integration tool  http://hackage.haskell.org/package/hackport-0.2.17 (SergeiTrofimovich)
13:22:36 <brennon_> well, i'm using a map as it is--it's just not automatically generated by the source file
13:23:13 <geekosaur> how often do you need to regenerate it, though? is it really worth turning it into a dynamic lookup on every use?
13:23:17 <geekosaur> especially for primops?
13:23:25 <geekosaur> that's gonna get *expensive* at runtime
13:23:34 <brennon_> well, that's the whole point of the flexibility though, isn't it?
13:23:39 <mdmkolbe> brennon_: BTW, as a teacher myself, it is always safe to acknowledge anywhere that you got help.  E.g. A comment at the start of your source saying to asked on #haskell about using Map or whatever.
13:24:12 <brennon_> mdmkolbe: if i gather anything i'm not already doing, you can be certain that i will! ;)
13:24:13 <geekosaur> brennon_, and that is the inevitable tradeoff of such flexibility.  it costs you a lot in time, it consts you a lot in extra work, it costs you a lot in extra libraries to support the runtime lookup
13:24:15 <_vic> And your teacher will check the logs
13:24:21 <mdmkolbe> geekosaur: it's an interpreter.  there has to be a dynamic lookup
13:24:24 <geekosaur> and the question you should always ask is:  is that worth it?
13:24:30 <_vic> Or maybe your teacher is already here, lurking
13:24:41 <Eduard_Munteanu> Maybe your teacher answered already :P
13:24:46 <rwbarton> maybe mdmkolbe IS your teacher
13:24:48 <_vic> Indeed
13:25:10 <geekosaur> mdmkolbe, yes, but how dynamic?  searching a small static map is much faster than using any full reflection interface, and way way way fatser than using ghc-api for reflection
13:25:30 <mdmkolbe> geekosaur: I wasn't suggesting a reflection interface
13:25:45 <geekosaur> mdmkolbe, no, brennan_ is
13:25:50 <geekosaur> er, brennon_ is
13:26:36 <mdmkolbe> geekosaur: ah, I see
13:27:11 <_vic> brennon_: http://www.haskell.org/haskellwiki/Applications_and_libraries/Compilers_and_interpreters#Forth is of any help?
13:27:58 <mdmkolbe> brennon_: I'd suggest not looking at other Forth implementations online
13:28:12 <mdmkolbe> brennon_: that gets a little close to the edge
13:28:24 <_vic> Maybe for ideas and inspiration
13:29:00 <mdmkolbe> _vic: Possible, but *definately* needs to be acknowledged (even if no ideas from it were (intentionally) used).
13:29:49 <brennon_> twelve years in university have taught me well, but i appreciate the concern, all
13:34:25 <mdmkolbe> This is a long shot, but does anyone know Lennart Augustsson's e-mail?  I'm not able to find it online, and I need to contact him about how one of his libraries related to a paper I'm writing.
13:34:44 <giakar> ciao
13:35:25 <m3ga> mdmkolbe: you could ping him on G+
13:36:07 <Eduard_Munteanu> preflex: xseen augustss
13:36:08 <preflex>  augustss was last seen on freenode/#haskell 111 days, 21 hours, 3 minutes and 59 seconds ago, saying: > div (-1) 2
13:36:28 <Guest36887> Hey everyone ... anyone up for a quick question on haddock? I have documented a small library I am working on, and haddock refuses to document which instances exist for my data types. Is there any common mistake I could be making?
13:36:44 <Saizan> mdmkolbe: the one he uses on the haskell mailing lists is lennart at augustsson dot net
13:38:18 <mdmkolbe> Saizan: thanks, I hadn't thought to look here.  m3ga: I'll ping him on G+ if the e-mail doesn't work (gets lost in spam?)
13:40:38 <jay7557> hi
13:40:41 <jay7557> all!
13:40:59 <MagneticDuck> Hey!
13:41:00 <jay7557> how can I use.. map xor [1,2]
13:41:02 <jay7557> ?
13:41:10 <MagneticDuck> What are you trying to do?
13:41:14 <jay7557> Hey MagneticDuck
13:41:20 <jay7557> wait
13:41:34 <jay7557> ill paste to update you what I've done so far
13:41:54 <MagneticDuck> You're working on that problem where you have to scramble a file?
13:42:01 <jay7557> yes
13:42:16 <jay7557> since past 10 days actually :(
13:42:44 <hpaste> jay7557 pasted ‚Äúscramblingg‚Äù at http://hpaste.org/64500
13:43:12 <MagneticDuck> Alright, first, do you understand how Haskell deals with getting random stuff?
13:43:41 <jay7557> Nope :(
13:43:47 <Cale> jay7557: Perhaps you meant map (xor 1) 2 ?
13:43:49 <Cale> er
13:43:52 <Cale> jay7557: Perhaps you meant map (xor 1) [2] ?
13:44:03 <jay7557> no cale
13:44:06 <MagneticDuck> If you don't, http://learnyouahaskell.com/input-and-output#randomness
13:44:19 <ion> I don‚Äôt think jay7557 needs any randomness here.
13:44:25 <Cale> jay7557: map f applies the function f to each element of a list, producing a list of the results
13:44:31 <MagneticDuck> He needs to scramble a string, right?
13:44:38 <mauke> MagneticDuck: no
13:44:49 <jay7557> what I've to do it to scramble a text file with key which gets at cmd line arguement
13:44:54 <Cale> jay7557: What are you trying to do with xor and the elements of the list?
13:45:06 <Cale> jay7557: are you trying to xor all the elements together?
13:45:23 <Franciman> hi all, is Real World Haskell an approfondite enough book to learn great part of haskell?
13:45:32 <Franciman> *a good
13:45:35 <jay7557> yes
13:45:38 <ion> jay7557: Also, since you‚Äôre going to want to apply a function of String -> String to the data from standard input and print the to the output, you might want to use interact as i suggested before.
13:45:39 <Cale> > foldr1 xor [1,2]
13:45:40 <ion> @type interact
13:45:41 <bogwonch> Franciman: yup
13:45:46 <jay7557> i want to use xor on all elements in the string
13:45:48 <Cale> oh, lambdabot is still choking
13:46:05 <MagneticDuck> You strangled lambdabot! :D
13:46:09 <Cale> there we go
13:46:10 <Cale> > foldr1 xor [1,2]
13:46:17 <lambdabot>   Ambiguous type variable `a' in the constraint:
13:46:23 <Cale> > foldr1 xor [1,2] :: Integer
13:46:23 <lambdabot>    `Data.Bits.Bits a'
13:46:30 <lambdabot>   3
13:46:30 <Cale> > foldr1 xor [1,2] :: Int
13:46:33 <Cale> there
13:46:34 <Cale> heh
13:46:35 <lambdabot>   3
13:46:39 <Franciman> bogwonch, what else could I read ?
13:46:45 <jay7557> Cale.. can you see my code that I pasted earlier?
13:46:47 <Cale> It's a little slow because it's joining so many channels
13:46:57 <ion> AFAIU jay7557 wants to get a key as a parameter and data from standard input, and my guess is he wants scramble to xor the input with the key (cycled).
13:47:00 <Guest36887> Anyone here an expert with haddock?
13:47:02 <mauke> Cale: it's a zipWith
13:47:07 <Franciman> I want a deep look at Haskell
13:47:07 <bogwonch> Franciman: the typeclassopedia on the haskell wiki is fun too
13:47:13 <jay7557> yes ion
13:47:18 <Cale> jay7557: Yeah, there's a type error in that, because you're mapping ord over the String, and asking for a String result
13:47:20 <jay7557> thats what I want
13:47:20 <Cale> :t ord
13:47:25 <lambdabot> Char -> Int
13:47:39 <Cale> map ord str :: [Int]
13:47:39 <Franciman> oh ok, thanks very much :)
13:47:55 <MagneticDuck> Hey, jay7557, you are also mapping a function that takes a string and gives a string over a string...
13:48:07 <MagneticDuck> Just use putStrLn $ scramble sx
13:48:18 <Cale> right :)
13:48:22 <bogwonch> Franciman: no worries!  enjoy it... the chapter on profiling in RWH is particularly good!
13:48:22 <jay7557> what does $ do?
13:48:35 <Cale> jay7557: that's just function application with low precedence
13:48:35 <ion> magneticduck: ‚Ä¶or interact.
13:48:45 <Franciman> :)
13:48:45 <Cale> You can also just write  putStrLn (scramble xs)
13:48:49 <Cale> f $ x = f x
13:49:04 <MagneticDuck> Also, $ has a precedence of 0.
13:49:18 <Cale> but $ has really low operator precedence (while plain function application has higher precedence than any infix operator)
13:49:37 <MagneticDuck> Which means $ will take everything on the right, evaluate it first, and then call the stuff on the left and apply that.
13:49:41 <MagneticDuck> Hope that makes sense
13:50:00 <Cale> probably not in that order ;)
13:50:01 <jay7557> yeah finally it does
13:50:01 <mauke> except for the "evaluate it first" part
13:50:14 <MagneticDuck> Yeah yeah.
13:50:15 <mauke> evaluation order is not precedence
13:50:20 <MagneticDuck> I get it!
13:50:30 <jay7557> so if am not wrong it does the right hand stuff first and then feds up everything to putStr
13:50:32 <jay7557> ?
13:50:32 <MagneticDuck> Haskell is lazy, so it can evaluate it any order it wants!
13:50:39 <mauke> <insert rant about C coders here>
13:50:47 <MagneticDuck> <insert rant about C here>
13:50:53 <mauke> MagneticDuck: C is strict and it can still evaluate in any order
13:51:11 <Cale> jay7557: Well, the list to be printed will get evaluated as putStrLn demands each character from it
13:51:12 <MagneticDuck> Okay. You win. :D
13:51:17 <Cale> hehehe
13:51:28 <MagneticDuck> And a list is recursive anyway...
13:51:36 <c_wraith> actually, f $ x will always evaluate at least enough of f to get some output.  It may or may not evaluate x
13:51:51 <c_wraith> So, at least some of f will be evaluated before x
13:51:55 <MagneticDuck> True.
13:52:06 <MagneticDuck> So, f is evaluated first, actually. Sorry!
13:52:15 <MagneticDuck> Or, most of it...
13:52:23 <c_wraith> or a tiny fraction of it. :)
13:52:31 <Cale> and in general, f (g x) will evaluate f first, applying the function to the expression (g x), which may be evaluated later.
13:52:38 <jay7557> So if I was to write that in script file
13:52:43 <mauke> script file?
13:52:47 <jay7557> scramble :: String -> String
13:52:53 <jay7557> is that right ?
13:52:53 <Cale> hs = haskell script :D
13:52:57 <mauke> heh
13:52:59 <c_wraith> > take 1 ((1:) . undefined $ undefined)
13:53:01 <lambdabot>   [1]
13:53:05 <jay7557> .hs ofcourse
13:53:06 <mauke> jay7557: depends on what scramble does
13:53:29 <Cale> jay7557: That's an appropriate type, but not for your current implementation of scramble
13:53:46 <Cale> jay7557: Currently, your scramble has type String -> [Int]
13:53:47 <MagneticDuck> Yeah, your scramble should be String -> [Int]
13:53:57 <jay7557> scramble str = map xor str
13:54:07 <MagneticDuck> @type xor
13:54:08 <lambdabot> forall a. (Bits a) => a -> a -> a
13:54:17 <Cale> :t map xor
13:54:18 <lambdabot> forall a. (Bits a) => [a] -> [a -> a]
13:54:19 <MagneticDuck> It takes two parameters, map gives it 1 only!
13:54:26 <Cale> You'll get a list of functions then
13:54:40 <Cale> Which... might actually be a useful list of functions here
13:54:45 <MagneticDuck> ...which is something you probably don't know about yet...
13:54:49 <Cale> But it's still a little odd
13:55:09 <jay7557> am totally confused :(
13:55:11 <Cale> You probably want something more like zipWith xor originalString (cycle keyString)
13:55:35 <MagneticDuck> > map (\f -> f 1 2) [(+), (-), (*)]
13:55:36 <lambdabot>   [3,-1,2]
13:55:53 <jay7557> scramble str = zipWith xor (cycle str)
13:56:03 <jay7557> is this appropriate?
13:56:08 <Cale> jay7557: That works
13:56:11 <hpaste> zhulikas pasted ‚Äúany shortcuts for that?‚Äù at http://hpaste.org/64502
13:56:11 <mauke> jay7557: only by accident
13:56:20 <Cale> Maybe not by accident :)
13:56:23 <zhulikas> oh...
13:56:28 <mauke> I bet it is by accident
13:56:31 <Cale> I'll give him the benefit of the doubt :)
13:56:37 <MagneticDuck> jay7557: I'd recommend looking at http://learnyouahaskell.com/
13:56:38 <zhulikas> @hoogle Maybe a -> (Maybe a -> b) -> b
13:56:39 <lambdabot> Data.Generics.Aliases ext1Q :: (Data d, Typeable1 t) => (d -> q) -> (forall e. Data e => t e -> q) -> d -> q
13:56:49 <zhulikas> @hoogle Maybe a -> (Maybe a -> b) -> Maybe b
13:56:49 <lambdabot> Data.Generics.Aliases ext1Q :: (Data d, Typeable1 t) => (d -> q) -> (forall e. Data e => t e -> q) -> d -> q
13:56:52 <zhulikas> hmmm
13:56:55 <MagneticDuck> It covers all this strange stuff, yet starts and the very beginning...
13:56:56 <Cale> jay7557: Did you intend scramble to have two parameters? Because that implementation will certainly have two :)
13:57:21 <Cale> (because its result is a function)
13:57:27 <mauke> :t \f -> maybe Nothing (Just . f . Just)
13:57:28 <lambdabot> forall a a1. (Maybe a1 -> a) -> Maybe a1 -> Maybe a
13:57:31 <zhulikas> @hoogle m a -> (m a -> b) -> m b
13:57:32 <jay7557> initially i thought there would be two
13:57:32 <lambdabot> Foreign.Marshal.Utils withMany :: (a -> (b -> res) -> res) -> [a] -> ([b] -> res) -> res
13:57:32 <lambdabot> Data.Generics.Aliases ext1Q :: (Data d, Typeable1 t) => (d -> q) -> (forall e. Data e => t e -> q) -> d -> q
13:57:47 <Cale> Which zips the cycle of str using xor with a yet-to-be-mentioned other string
13:57:51 <jay7557> but it key get as parameter at cmd line arguement
13:57:55 <mauke> :t \f -> flip (maybe Nothing (Just . f . Just))
13:57:56 <lambdabot>     Couldn't match expected type `a -> b'
13:57:56 <lambdabot>            against inferred type `Maybe a1'
13:57:56 <lambdabot>     In the first argument of `maybe', namely `Nothing'
13:57:59 <Cale> > zipWith xor "hello" "world"
13:58:00 <lambdabot>   No instance for (Data.Bits.Bits GHC.Types.Char)
13:58:00 <lambdabot>    arising from a use of `D...
13:58:04 <zhulikas> mauke, that's for me?
13:58:07 <mauke> :t flip (\f -> maybe Nothing (Just . f . Just))
13:58:08 <lambdabot> forall a a1. Maybe a1 -> (Maybe a1 -> a) -> Maybe a
13:58:13 <Cale> > map chr (zipWith xor (map ord "hello") (map ord "world"))
13:58:14 <lambdabot>   "\US\n\RS\NUL\v"
13:58:17 <zhulikas> @hoogle maybe
13:58:17 <lambdabot> Prelude data Maybe a
13:58:18 <lambdabot> Data.Maybe data Maybe a
13:58:18 <lambdabot> Prelude maybe :: b -> (a -> b) -> Maybe a -> b
13:58:34 <Cale> > map chr (zipWith xor (map ord (cycle "hello")) (map ord "This is a longer message."))
13:58:35 <lambdabot>   "<\r\ENQ\USO\SOH\SYNL\rO\EOT\n\STX\v\n\SUBE\SOH\t\FS\ESC\EOT\v\tA"
13:58:43 <jay7557> cale that doesn't work for me
13:58:47 <Cale> > map chr (zipWith xor (map ord (cycle "hello")) (map ord "<\r\ENQ\USO\SOH\SYNL\rO\EOT\n\STX\v\n\SUBE\SOH\t\FS\ESC\EOT\v\tA"))
13:58:48 <lambdabot>   "This is a longer message."
13:58:50 <zhulikas> well, I guess I'll just use my function :D
13:58:57 <jay7557> may be i need to import data.list
13:58:59 <jay7557> i guess
13:59:08 <MagneticDuck> Data.List
13:59:16 <c_wraith> You'll need to import Data.Char for ord and chr, too
13:59:22 <MagneticDuck> Yeah.
13:59:44 <Cale> I love the way that control characters get printed in Haskell :)
13:59:59 <MagneticDuck> BTW, what context are you doing this in, jay?
14:00:04 <MagneticDuck> How are you learning Haskell?
14:00:09 <MagneticDuck> Just wondering.
14:00:26 <mauke> > map length ["\SOH", "\SO\&H"]
14:00:27 <lambdabot>   [1,2]
14:00:45 <rwbarton> > "\SO\&H"
14:00:46 <lambdabot>   "\SO\&H"
14:00:58 <mauke> trollface.jpg
14:00:58 <jay7557> am learning at university from tutorial and graham hutton's book
14:01:14 <Cale> \& shows some attention to detail :)
14:01:40 <jay7557> also refering to rhw and learnhaskellforgreatgood
14:01:46 <mauke> > map length ["\ \", "\SOH", "\SO\&H"]
14:01:46 <lambdabot>   [0,1,2]
14:01:53 <jay7557> rwh*
14:02:26 * hackagebot HSH 2.0.4 - Library to mix shell scripting with Haskell programs  http://hackage.haskell.org/package/HSH-2.0.4 (JohnGoerzen)
14:02:28 * hackagebot ftphs 1.0.8 - FTP Client and Server Library  http://hackage.haskell.org/package/ftphs-1.0.8 (JohnGoerzen)
14:04:49 <dmwit> :t \f a b -> liftM2 f a b `mplus` a `mplus` b
14:04:50 <lambdabot> forall a2 (m :: * -> *). (MonadPlus m) => (a2 -> a2 -> a2) -> m a2 -> m a2 -> m a2
14:05:14 <MagneticDuck> What's MonadPlus? A new brand of Monad?
14:05:18 <dmwit> Any nicer way to write that? I don't mind if the 'm' gets monomorphed to Maybe.
14:05:29 <dmwit> ?src MonadPlus
14:05:30 <lambdabot> Source not found. The more you drive -- the dumber you get.
14:05:33 <dmwit> eh
14:05:38 <MagneticDuck> Alright, I got it.
14:05:52 <dmwit> class Monad m => MonadPlus m where mzero :: m a; mplus :: m a -> m a -> m a
14:06:24 <MagneticDuck> It's like a number... except not!
14:06:34 <dmwit> It's like a monoid, but with kind * -> *
14:06:52 <MagneticDuck> Alright. What are some instances?
14:06:59 <dmwit> Well, Maybe, for one. =)
14:07:00 <rostayob> MagneticDuck: Maybe, []
14:07:02 <DanBurton> does mplus not require the a to be a monoid?
14:07:05 <DanBurton> @hoogle mplus
14:07:06 <lambdabot> Control.Monad mplus :: MonadPlus m => m a -> m a -> m a
14:07:08 <dmwit> > Nothing `mplus` Just 3
14:07:08 <rostayob> DanBurton: no
14:07:08 <lambdabot>   Just 3
14:07:22 <DanBurton> > Nothing `mplus` Just x
14:07:23 <lambdabot>   Just x
14:07:29 <DanBurton> > x `mappend` y
14:07:30 <lambdabot>   No instance for (Data.Monoid.Monoid SimpleReflect.Expr)
14:07:30 <lambdabot>    arising from a u...
14:07:38 <MagneticDuck> Alright, but Maybe a is only a MonadPlus given a Num?
14:07:44 <DanBurton> > Just x `mplus` Just y
14:07:44 <lambdabot>   Just x
14:07:51 <dmwit> MagneticDuck: No, Maybe is always a MonadPlus.
14:07:57 <rostayob> DanBurton: MonadPlus is a monoid in the sense that it has a binary relation and an identity element
14:08:06 <dmwit> MagneticDuck: ...and Maybe a is never a MonadPlus, because it has the wrong kind. =)
14:08:30 <MagneticDuck> Alright.
14:08:42 <MagneticDuck> Speaking of which, I better go to bed!
14:08:44 <MagneticDuck> :D
14:08:55 <DanBurton> is there a way to write MonadPlus and Monoid as the same class with PolyKinds?
14:09:09 <rostayob> DanBurton: no
14:09:22 <DanBurton> why not? Feels like there should be
14:09:26 <rostayob> how do you write the type sign for mplus?
14:09:40 <DanBurton> with poly-kinded magicks
14:09:51 <rostayob> DanBurton: that is not a good answer :P
14:10:01 <DanBurton> rostayob: it reflects my knowledge of PolyKinds
14:10:26 <rostayob> polymorphic kinds would be mostly useful to do type indexed data families and stuff like that
14:10:29 <rostayob> but in the end all values have types of kind *
14:11:38 <DanBurton> Consider a simplified example: class Zero z where zero :: z; class MZero m where mzero :: m a; it feels like there should be a way to describe both of these as the same class
14:12:00 <rostayob> you can just use Zero and use the applied type constructor that you'd use in MZero
14:12:07 <quicksilver> if you had a unit kind, a ()-kind, and you wrote atomic types like 'Int' as being members of the kind () -> *
14:12:25 <Saizan> can you have forall on the RHS of a type family instance?
14:12:39 <quicksilver> then you could have Maybe :: * -> * and Int :: () -> *, and both of them matching the polykind (k -> *)
14:12:49 <quicksilver> then I think you can unify MonadPlus and Monoid
14:13:13 <quicksilver> but your Monoid is 'wrapped' or 'lifted' by the () -> kind transformationa nd, anyway, there is no unit kind.
14:13:15 <DanBurton> suppose I had instance Zero [a] where zero = []. Then I can write instance MZero [] where mzero = zero; you can write the exact same instance of MZero for any instance of Zero
14:13:40 <dmwit> DanBurton: No, not for any instance of Zero.
14:13:51 <dmwit> DanBurton: Only for those special instances that are a type constructor applied to a type variable.
14:13:56 <rostayob> quicksilver: ok, but that's after you set up some machinery to do that
14:13:57 <DanBurton> "there is no unit kind" - isn't there now with PolyKinds?
14:14:13 <rostayob> DanBurton: do you know what PolyKind does?
14:14:17 <DanBurton> dmwit: yes, that.
14:14:24 <rostayob> it's very limited, and it's probably not what you think
14:14:30 <rostayob> I think you might be thinking of DataKinds
14:14:32 <DanBurton> rostayob: not really. And I might be confusing it with similar extensions released with it
14:14:54 <DanBurton> yes DataKinds is probably what I was thinking there
14:15:02 <dmwit> Saizan: Hm, that seems like it would solve the problem, huh?
14:15:50 <dmwit> :t \f a b -> listToMaybe . catMaybes $ [liftM2 f a b, a, b]
14:15:50 <lambdabot> forall a2. (a2 -> a2 -> a2) -> Maybe a2 -> Maybe a2 -> Maybe a2
14:16:47 <fmapE> I'm trying to profile a program with GHC. It uses the GLUT main loop, but I'm quitting the program by closing the window. When I check the .prof file afterwards, it's empty.
14:16:58 <rostayob> DanBurton: MonadZero and Monoid express different things
14:16:58 <dmwit> :t \f a b -> case (a, b) of (Just a, Just b) -> f a b; _ -> a `mplus` b
14:16:59 <lambdabot> forall t. (t -> t -> Maybe t) -> Maybe t -> Maybe t -> Maybe t
14:17:07 <rostayob> DanBurton: there is no overlap in functionality really
14:17:48 <DanBurton> rostayob: but there is overlap in meaning. Is there any MonadZero for which mzero /= mempty?
14:17:52 <dmwit> fmapE: Probably glut does an exit() syscall rather than just ending.
14:17:52 <quicksilver> Saizan: I would guess you can't because "polymorphism isn't first class"
14:18:01 <dmwit> fmapE: See if you can ask it not to do that.
14:18:09 <fmapE> OK I'll check on that
14:18:11 <quicksilver> Saizan: that would be like an 'impredicative type family' I suppose.
14:18:49 <rostayob> DanBurton: I don't know, but there are a lot of things which are a MonadPlus but aren't a Monoid
14:19:06 <rostayob> it wouldn't make much sense do mappend two 'IO a' would it?
14:19:10 <dmwit> DanBurton: Maybe not, but there are MonadZero's for which mplus /= mappend
14:19:25 <quicksilver> fmapE: if you call haskell's System.Exit explicitly instead of letting glut exit, it should be OK
14:19:31 <rostayob> anyways gotta go
14:19:38 <DanBurton> > Just 3 `mplus` Just 4
14:19:39 <lambdabot>   Just 3
14:19:43 <DanBurton> > Just 3 `mappend` Just 4
14:19:44 <lambdabot>   Ambiguous type variable `t' in the constraints:
14:19:44 <lambdabot>    `Data.Monoid.Monoid t'
14:19:44 <lambdabot>  ...
14:19:50 <dmwit> > mplus (Just (Sum 1)) (Just (Sum 2))
14:19:51 <lambdabot>   Just (Sum {getSum = 1})
14:19:56 <quicksilver> fmapE: at least I'm sure I once solved the problem you're having now and I think that's what I did
14:19:57 <dmwit> > mappend (Just (Sum 1)) (Just (Sum 2))
14:19:57 <lambdabot>   Just (Sum {getSum = 3})
14:19:58 <fmapE> actually it looks like I can just ask GLUT to return from the main loop instead of exiting explicitly.
14:20:06 <fmapE> let me try it
14:20:28 <DanBurton> so MonadPlus means just merge the structure, while Monoid means merge as deep as necessary
14:20:51 <Axman6> > 3 :: Sum Int
14:20:52 <lambdabot>   No instance for (GHC.Num.Num (Data.Monoid.Sum GHC.Types.Int))
14:20:52 <lambdabot>    arising fr...
14:20:56 <Axman6> :(
14:20:59 <dmwit> Axman6: Stupid, isn't it.
14:20:59 <quicksilver> I don't that's a clear guideline, DanBurton
14:21:17 <quicksilver> there are three possible instances for Monoid(Maybe a)
14:21:22 <dmwit> Oh, hey, DanBurton, you wrote the "composition" library?
14:21:22 <zhulikas> type inference sometimes can be a real bitch.
14:21:27 <quicksilver> that happens to be the one they chose
14:21:37 <DanBurton> dmwit: yes indeed.
14:21:46 <quicksilver> I don't think it's "more Monoid-like" than the other two
14:22:08 <quicksilver> the other two exist as newtypes I think, called First and Last (?)
14:22:27 * hackagebot testpack 2.1.2 - Test Utililty Pack for HUnit and QuickCheck  http://hackage.haskell.org/package/testpack-2.1.2 (JohnGoerzen)
14:22:34 <dmwit> DanBurton: What does "the pattern of appending asterisks is more extensible" mean in the documentation of (.*)?
14:23:02 <rostayob> DanBurton: came back just to correct myself: IO is not a MonadPlus :P
14:23:06 <rostayob> but STM is, for example
14:23:07 <DanBurton> dmwit: it's really my personal opinion, and rather vague. I used to prefer .*
14:23:15 <rostayob> now I can go :D
14:23:22 <DanBurton> dmwit: and I preferred it because for compose3 you just write .**
14:23:29 <DanBurton> compose4 .*** etc
14:23:40 <dmwit> DanBurton: (I don't even know what the alternative that we're attacking is.)
14:23:53 <DanBurton> with .: there are a lot more confusing dots if you try to extend it .:::
14:24:15 <dmwit> ah
14:24:20 <DanBurton> though theoretically it could be more compact, e.g. compose5 = .::.
14:24:28 <DanBurton> count the dots except the first
14:24:36 <dmwit> haha
14:24:41 <DanBurton> maybe I should add that to the library
14:24:43 <dmwit> Why not encode it in binary.
14:25:48 <dmwit> . .: .. .:: .:. ..: ... .::: .::. .:.: .:.. ..:: ..:. ...: ....
14:25:52 <JoeyA> Isn't it possible to make compose polymorphic in all argument counts?  Or would that make type inference NP-scary?
14:26:17 <DanBurton> dmwit: looks like braille
14:26:21 <JoeyA> lol
14:26:50 <quicksilver> JoeyA: no, because, how many arguments does "a -> b" have?
14:26:58 <shachaf> (‚†ü) looks like a good composition operator.
14:26:59 <quicksilver> you can't tell without telling the type of b
14:27:05 <shachaf> quicksilver: One argument. :-)
14:27:15 <quicksilver> so, therefore, you can't do this polymorphically without breaking parametricity
14:27:22 <JoeyA> However is needed to satisfy use, right?
14:27:27 <JoeyA> however many*
14:27:28 * hackagebot convertible 1.0.11.1 - Typeclasses and instances for converting between types  http://hackage.haskell.org/package/convertible-1.0.11.1 (JohnGoerzen)
14:27:32 <quicksilver> you can do it with overlapping instances but that's broken.
14:27:43 <JoeyA> ah, okay
14:27:43 <quicksilver> JoeyA: you can't predict how you might be used elsewhere in the code
14:27:55 * JoeyA is tempted to make a Braille Acme module
14:27:55 <quicksilver> does "id" have one argument or two?
14:27:58 <quicksilver> (or three?)
14:28:17 <fmapE> quicksilver, dmwit: that fixed it, thanks
14:28:22 <quicksilver> fmapE: yay :)
14:28:31 <quicksilver> I was sure IO was an instance of monadplus
14:28:39 <DanBurton> :t fmap fmap fmap
14:28:39 <lambdabot> forall (f :: * -> *) a b (f1 :: * -> *). (Functor f, Functor f1) => (a -> b) -> f (f1 a) -> f (f1 b)
14:28:44 <dmwit> :t print 3 `mplus` print 4
14:28:45 <lambdabot> IO ()
14:28:47 <quicksilver> :t putStr "hello" `mplus` putStr "world"
14:28:48 <lambdabot> IO ()
14:28:50 <quicksilver> it is.
14:28:51 <dmwit> IO is totally mplus.
14:28:55 <quicksilver> silly rostayob ;)
14:28:56 <dmwit> It does exception handling or something.
14:29:02 <quicksilver> not really handling
14:29:06 <quicksilver> exception ignoring :)
14:29:15 <quicksilver> try this then that
14:29:17 <nand`> Bah, why do >>= and >>> have the same fixivity? It would be great if >>> binded more strongly, then I could write something like foo >>= bar >>> someprocessing >>= baz
14:29:18 <quicksilver> it's quite a useful pattern.
14:29:34 <nand`> the laternative, baz =<< someprocessing . bar =<< foo just isn't as nice imo
14:29:37 <nand`> alternative*
14:30:04 <dmwit> Yes, (>>>) should have the same precedence as (.).
14:30:56 <DanBurton> oh so many ideas. I wonder if I will ever "finish" Sexy
14:31:58 <quicksilver> precedence is really not a scalable tool :(
14:32:40 <DanBurton> this is why we should all use lisp...?
14:33:20 <DanBurton> (>>= foo (>>= (>>> bar someProcessing) baz))
14:33:45 <dmwit> Yeah, we need precedence lattices!
14:33:48 <dmwit> WHO'S WITH ME??
14:34:05 * DanBurton listens to crickets chirp
14:34:17 <hpc> dmwit: i don't think the world health organization cares
14:34:24 <hpc> (capitalization: it's important)
14:35:37 <tgeeky_> TIL there's such a thing as iceburg lattices: https://www.google.com/search?sourceid=chrome&ie=UTF-8&q=iceberg+lattices
14:35:49 <quicksilver> dmwit: in a way, the lattice makes it worse
14:36:15 <quicksilver> dmwit: I meant, it enables you to specify more pairwise behaviour which is "good" but it increases the cognitive load on the programmer/reader even more.
14:36:31 <guglielmo> !list
14:36:37 <dmwit> Eh, I wouldn't even say it was good.
14:37:00 <quicksilver> there are twin problems - one is that a linear order is restricting, and the other is that the more rules there are to remmeber the harder it is for a mere mortal to use it.
14:37:01 <dmwit> I mean, do you really want two operators to have incomparable precedence, just because they were written in two different Hackage packages?
14:37:01 <sclv> even worse is that they named the algorithm to compute such lattices, apparently, TITANIC
14:37:13 <otters> lolol
14:37:44 <quicksilver> dmwit: yes, in many cases. operators from different packages probably shouldn't be used together unbracketed.
14:37:59 <quicksilver> something which forces bracketing of ambiguous constructs is good.
14:38:08 <dmwit> Hm, that's an interesting proposal.
14:38:17 <quicksilver> on the other hand in putative lattice haskell there would be a way to add local rules to the lattice
14:38:23 <quicksilver> only compatible ones, of course.
14:38:29 <rwbarton> i foresee many long mailing list threads about "orphan infix declarations"
14:39:20 <rwbarton> or I guess not, since they needn't be coherent across modules particularly
14:40:04 <DanBurton> I just realized something creepy. I abuse orphan(instance)s in an as-yet-unreleased package that I call "sexy"...
14:40:38 <sclv> I think abusing orphans is creepy no matter what the context.
14:41:12 <sclv> but hey, you know, who am i to judge :-)
14:41:35 <DanBurton> e.g. https://github.com/DanBurton/sexy/blob/master/src/Sexy/Instances/Monad/IO.hs
14:42:26 <nand`> Is there something like ByteString for Word16?
14:42:38 <nand`> I need to process a file containing a bunch of 16-bit integers
14:42:43 <sclv> vector
14:42:58 <nand`> has to be lazy
14:43:08 <DanBurton> you can use Data.Binary.Get I think?
14:43:49 <sclv> storable vector
14:43:49 <sclv> http://hackage.haskell.org/package/storablevector
14:44:00 <quicksilver> or just use bytestring.
14:44:05 <Axman6> that's not lazy is it?
14:44:07 <quicksilver> but read it in 16 bit chunks
14:44:20 <quicksilver> either using binary.get or, well, by hand.
14:44:21 <DanBurton> http://hackage.haskell.org/packages/archive/binary/latest/doc/html/Data-Binary-Get.html#g:7
14:44:21 <dylukes> DanBurton: Are you going to do Numbers?
14:44:32 <nand`> quicksilver: I'm trying to see if I can avoid doing manual 16-bit conversion
14:44:37 <quicksilver> rading two word8s and making a 16-bit it isn't rocket science.
14:44:37 <DanBurton> dylukes: if I ever get pasts Lists, yes
14:44:40 <sclv> storable vector has a chunkwise lazy implementation
14:44:50 <DanBurton> dylukes: any requests?
14:44:50 <quicksilver> nand`: then, Data.Binary.getWord16{le,be}
14:45:02 <nand`> my code, right now, is a one-liner: foo bs = pack $ zipWith (-) bs (snoc (tail bs) 0)
14:45:14 <nand`> basically I need to subtract every byte from the next, the last being padded with 0
14:45:27 <nand`> now I want this to subtract each 2-byte block from the next instead
14:45:51 <nand`> If there's a way that would avoid having to use manual getWord16 and putWord16, that would be nice, otherwise I'll just do that
14:45:56 <dylukes> DanBurton: I mean, I think persoanlly something like
14:46:10 <dylukes> Natural < Integer < Rational < Real < Complex would be nice.
14:46:14 <dylukes> But that's just me.
14:46:34 <DanBurton> Seems logical. I'll keep that in mind
14:46:43 <dmwit> Real?
14:46:50 <zachk> is there a way in ghci to check the typeclass of a DataConstructor?
14:47:09 <brisingr> hey, I decided to write a haskell book. Can I steal some feedback from you (I've written like 1.5 pages for now)? https://docs.google.com/open?id=0Bx0Qn4cm6WCYQzF4LXptRlBTOFMzTXZpcEhrWFY2QQ
14:47:13 <dmwit> zachk: Use :i to get its type, and :i again to inspect what instances that type has.
14:47:20 <dmwit> zachk: (In ghci.)
14:47:21 <dylukes> DanBurton: I'll see how Sexy goes with GHC 7.5 SVN...
14:47:26 <dylukes> currently it seems to be bulding.
14:47:32 <DanBurton> dmwit: it's a meme among league of legends players to say "real" instead of "really"...so I found your interjection quite amusing
14:48:12 <dylukes> dmwit: It's as good as "Float" >_>
14:48:15 <DanBurton> dylukes: good to know, keep me posted =D I'm definitely more interested in being forwards, rather than backwards, compatible
14:48:27 <dmwit> Better in some ways, worse in others, I guess.
14:48:31 <nand`> Using ‚Äúreal‚Äù instead of ‚Äúreally‚Äù isn't limited to LoL, ‚ÄúIt's real fun‚Äù is common to see instead of ‚ÄúIt's really fun‚Äù
14:48:45 <dylukes> DanBurton: Is the DatatypeC thing the best way to do it?
14:48:55 <dylukes> I'd consider naming them things like BoolLike, OrderingLike, etc.
14:48:57 <dmwit> Decidable equality is often quite a nice feature.
14:49:00 <dylukes> The C is really ugly.
14:49:13 <dylukes> Just my two cents *shrugs*
14:49:15 <DanBurton> dylukes: debateable. I'm thinking about pulling all of the base data types from "real" Prelude to ease compatability
14:49:20 <dylukes> I'll fork it and play with it.
14:49:50 <dylukes> DanBurton: I would do your own thing, and then have type aliases in a Sexy.Compat module.
14:49:57 <DanBurton> there are a lot of directions where Sexy could go. For now, I've been going the "heavily typeclassy" way
14:50:05 <dylukes> So if you're coming over from normal Prelude, import Sexy.Compat and Sexy.
14:50:16 <dylukes> If it's something new, just import Sexy.
14:50:57 <MagneticDuck> Late to the conversation! This sounds interesting...
14:51:24 <DanBurton> @where sexy
14:51:24 <lambdabot> I know nothing about sexy.
14:51:29 <tgeeky_> edwardk: ping
14:51:30 <DanBurton> @where+ sexy https://github.com/DanBurton/sexy
14:51:31 <lambdabot> Okay.
14:51:35 <edwardk> pong
14:51:52 <dylukes> DanBurton: I like the Instances/Classes/Data distinction.
14:52:16 <Axman6> DanBurton: need moar sexy details
14:52:26 <dylukes> So, what was the issue with RMonad again?
14:52:33 <dylukes> edwardk: I think you'd mentioned it before.
14:53:09 <DanBurton> @where+ sexy https://github.com/DanBurton/sexy - a Sexier Prelude (under development)
14:53:10 <lambdabot> Okay.
14:53:12 <DanBurton> @where sexy
14:53:13 <lambdabot> https://github.com/DanBurton/sexy - a Sexier Prelude (under development)
14:53:33 <edwardk> dylukes: the issue where a lot of the combinators can't be defined?
14:53:40 <MagneticDuck> A sexier prelude, eh?
14:53:42 <DanBurton> Axman6: better?
14:53:42 <dylukes> I don't recall, but do tell.
14:53:49 <dylukes> I forget what it was, just that it was there.
14:53:50 <andrus> If I have "let a=1::Int" and "let b=1::Integer", why can't I do "let c = (cast b) :: (Maybe $ typeOf a)"?
14:53:54 <edwardk> same issue as with trying to use monoid for everything instead of monadplus
14:53:56 <DanBurton> MagneticDuck: that's the idea. For now it's just less powerful and more confusing.
14:54:05 <Axman6> DanBurton: what makes it sexier?
14:54:27 <DanBurton> Axman6: the main thing I'm trying to rework is the typeclass hierarchy.
14:54:28 <dylukes> edwardk: There's an issue with that?
14:54:40 <quicksilver> andrus: because "typeOf a" isn't a type.
14:54:41 <edwardk> some times i need to know that forall a. Foo (m a) has an instance.
14:54:42 <MagneticDuck> DanBurton: hmmm, I think Ill wait till it matures!
14:54:46 <DanBurton> so that, e.g. (.) is the category (.) by default
14:54:58 <dylukes> DanBurton: btw, did you read the thing on splitting up MonadPlus?
14:54:59 <edwardk> dylukes: yes =)
14:55:04 <dylukes> edwardk: I'm not sure I follow.
14:55:05 <DanBurton> MagneticDuck: yeah, it's very raw right now. I'll post on reddit and stuff when it's more mature
14:55:19 <DanBurton> dylukes: "the thing"?
14:55:24 <andrus> quicksilver: is there a way of recovering the type for passing to cast?
14:55:40 <quicksilver> andrus: yes, there is.
14:55:41 <edwardk> you can't write foo :: (forall a. (Monad m, Monoid (m a)) => m Int -> m Double -> m (Int, Double)
14:55:42 <Axman6> cast? *spit*
14:55:43 <nand`> @hoogle Word8 -> Word16
14:55:43 <lambdabot> Unsafe.Coerce unsafeCoerce :: a -> b
14:55:44 <lambdabot> Control.OldException throwDyn :: Typeable exception => exception -> b
14:55:44 <lambdabot> Network.BufferType buf_snoc :: BufferOp a -> a -> Word8 -> a
14:55:49 <nand`> I like the first result
14:56:12 <JoeyA> heh
14:56:17 <quicksilver> andrus: it's also important to understand why that doesn't work. "$" and "typeOf" are value syntax. "a" and "Maybe" are type syntax
14:56:17 <dylukes> edwardk: hm
14:56:20 <dylukes> why not?
14:56:23 <nand`> I can probably use fromIntegral or something here
14:56:31 <MagneticDuck> DanBurton: Maybe someday your name will be remembered by Haskell programmers everywhere... but for now its a mess. :D
14:56:48 <quicksilver> andrus: erm, not "a", sorry. "$" "typeOf" and "a" are all value-level. Only "Maybe" is type-level.
14:57:06 <andrus> quicksilver: thanks
14:57:10 <DanBurton> MagneticDuck: sigh. One drawback of naming it "sexy" is there are unwanted connotations that come to mind when you describe it as "mature" and "a mess" >,<
14:57:19 <andrus> nand`: thanks
14:57:30 <MagneticDuck> Ha ha.
14:57:48 <DanBurton> maybe I should rename it WarmFuzzy
14:57:50 <MagneticDuck> Not intended
14:58:07 <nand`> andrus: ?? What'd I do?
14:58:27 <quicksilver> andrus: anyhow, try this: let a = 1::Int; b = 1::Integer; dummy :: t -> Maybe t; dummy = undefined; c = (cast b) `asTypeOf` (dummy a)
14:58:36 <andrus> nand`: ahh, I'm reading about unsafeCoerce...
14:58:56 <andrus> quicksilver: I will take a look at this
14:58:57 <nand`> andrus: then stop reading about unsafeCoerce :P
14:59:01 <Mathnerd314> DanBurton: so you're ignoring the possibility of (.) = fmap?
14:59:05 <andrus> hehe
14:59:07 <quicksilver> or, once you see what that trick is doing, you can  skip the 'dummy' since in this case 'Just' is good enough.
14:59:15 <nand`> @hoogle Word16 -> (Word8, Word8)
14:59:16 <lambdabot> Control.Monad.Trans.RWS.Lazy evalRWS :: RWS r w s a -> r -> s -> (a, w)
14:59:16 <lambdabot> Control.Monad.Trans.RWS.Strict evalRWS :: RWS r w s a -> r -> s -> (a, w)
14:59:16 <lambdabot> Control.Monad.RWS.Lazy evalRWS :: RWS r w s a -> r -> s -> (a, w)
14:59:17 <andrus> ok
14:59:18 <quicksilver> c = (cast b) `asTypeOf` (Just a)
14:59:21 <DanBurton> Mathnerd314: yeah. instead <$> is encouraged for fmap
14:59:31 <nand`> bleh, anything like this?
14:59:36 <Axman6> DanBurton: you've got Plus and subtract, I assume you're still working on the rest of the Num functions?
14:59:59 <DanBurton> Axman6: yeah. Plus, however, is way more than just a Num function.
15:00:09 <DanBurton> it's 1/2 of Monoid
15:00:13 <hughfdjackson> just out of curiousity, is the prelude especially unsexy?
15:00:16 <Axman6> yeah, i figured that. I guess it's basically Monoid?... yeah
15:00:29 <Axman6> hughfdjackson: it's got warts
15:00:35 <hughfdjackson> hehe
15:00:40 <hughfdjackson> ^^ i see
15:00:48 <DanBurton> hughfdjackson: the Prelude is quite good, but there are a few artifacts that come from backwards compatability that make it slightly annoying
15:01:02 <DanBurton> also it is very list-centric
15:01:33 <DanBurton> if I design it right, I want Sexy to encourage heavier use of Data.Sequence
15:01:47 <JoeyA> nand`: Use 'with', 'castPtr', and 'peek'?  The first byte is the least significant, since nobody cares about big endian machines anymore.
15:01:54 <Axman6> DanBurton: will you have things like a Size or Length class?
15:01:57 <DanBurton> and appropriate use of Data.Set, Data.Map etc.
15:02:12 <DanBurton> Axman6: most likely
15:02:30 <Axman6> also, Monad (and possibly several classes) should have constraint... stuff... so you can make Seq a monad
15:02:36 <Axman6> uh, Set*
15:02:41 <MagneticDuck> Ill stay in tune on this!
15:03:50 <DanBurton> Axman6: mmm I'll keep that in mind. Not the highest on the list of things to do, though
15:04:20 <dylukes> Axman6: yeah, but as edwardk was saying, there are issues with that
15:04:24 <dylukes> though I forget what they were >.>
15:04:31 <edwardk> dylukes: because in general each occurrence of Monoid (m Int) and Monoid (m Double) etc. could be using completely unrelated instances
15:04:44 <edwardk> bit distracted. i'll give a more complete explanation in a bit
15:04:46 <DanBurton> patches are welcome <3 any of you, feel free to fork and send a pull request on github
15:05:26 <Axman6> edwardk: why is that so?
15:05:48 <dylukes> Axman6: different contexts.
15:08:14 <mcwheel> @pl (\x -> h (f x) (g x))
15:08:14 <lambdabot> liftM2 h f g
15:09:53 <Mathnerd314> DanBurton: seen http://patch-tag.com/r/jmcarthur/alt-stdlib/home ?
15:10:36 <Mathnerd314> it's been abandoned, but you might be able to steal some stuff...
15:11:26 <Veinor> hmm
15:11:41 <alpounet> oh god
15:11:44 <alpounet> forgot about alt-stdlib
15:11:53 <Veinor> parsec seems to be pretty memory-intensive
15:11:59 <Veinor> (or maybe I'm doing something wrong)
15:12:18 <Rc43> Hi, guys.
15:12:28 <Rc43> Anybode used thrift with haskell?
15:13:48 <hpc> Rc43: apache rpc? sounds like something i never want to touch :P
15:14:01 <Rc43> hpc, why?
15:14:10 <rostayob> hpc: I couldn't resist http://www.reddit.com/r/haskell/comments/qadwm/improbable_uses_of_unsafecoerce/
15:14:14 <alpounet> DanBurton, i followed very closely (and contributed a tiny bit to) alt-stdlib, and have been discussing many things in there with its main author (jmcarthur) so feel free to start a discussion about problems addressed (or not) in alt-stdlib, etc etc
15:14:17 <DanBurton> Mathnerd314: cool, thanks for the link
15:14:48 <rostayob> DanBurton: how did the MonadPlus/Monoid conversation end?
15:15:01 <hpc> rostayob: oh, add stToIO
15:15:08 <hpc> @hoogle ST s a -> IO a
15:15:08 <lambdabot> Control.Monad.ST unsafeSTToIO :: ST s a -> IO a
15:15:08 <lambdabot> Control.Monad.ST runST :: (forall s. ST s a) -> a
15:15:09 <lambdabot> Control.Monad.ST.Lazy runST :: (forall s. ST s a) -> a
15:15:13 <rostayob> hpc: does that work?
15:15:14 <hpc> er, unsafeSTToIO
15:15:17 <hpc> @src ST
15:15:17 <lambdabot> newtype ST s a = ST (STRep s a)
15:15:24 <hpc> @src STRep
15:15:24 <lambdabot> type STRep s a = State# s -> (# State# s, a #)
15:15:28 <hpc> @src IO
15:15:28 <lambdabot> Source not found. Your mind just hasn't been the same since the electro-shock, has it?
15:15:47 <hpc> newtype IO a = IO (State# RealWorld -> (# State# RealWorld, a #))
15:15:59 <hpc> IO = ST RealWorld
15:16:03 <rostayob> hpc: oh yes, it should work!
15:16:30 <DanBurton> rostayob: end? Dunno...we talked about stuff, I learned a bit, and then it died off I guess. It's rare for such conversations to conclude with "the hard fast rule is X"
15:16:56 <rostayob> DanBurton: ok ehe
15:19:02 <rostayob> hpc: ok, I put it anyways :P
15:19:09 <hpc> :D
15:22:33 <gadtfly> I'm trying to parse the total volume of a quantity of alcohol.  Possible forms are, eg, "750 mL", "5x50 mL", "1.5 L".  It seems like too simple a job to warrant learning something like Parsec.  Any suggestions?
15:22:51 <edwardk> Axman6: the issue only really becomes a blocker when you use polymorphic recursion. But even without it you can run into issues where the instance of Monoid for Foo Int and the instance of Monoid for Foo Double are completely inrelated, when the MonadPlus enforces that the 'a' argument to the Monad is irrelevant to the behavior of the monoid
15:24:27 <rostayob> gadtfly: yes, that's 5 lines of parsec.
15:24:33 <Cale> gadtfly: Parsec isn't so hard, at least the basics of it. If you want something simpler, perhaps go with ReadP :)
15:24:36 <rostayob> even less
15:25:00 <gadtfly> I can't find any examples at all for ReadP.
15:25:14 <Cale> http://legacy.cs.uu.nl/daan/download/parsec/parsec.html -- this is an only-slightly-out-of-date tutorial for Parsec. The ReadP stuff is almost identical in usage.
15:25:29 <dmwit> Can I just say that "gadtfly" is an absolutely marvelous nick?
15:25:32 <gadtfly> Thanks
15:25:36 <gadtfly> :)
15:26:11 <rostayob> gadtfly: the Read instances are implemented with ReadP
15:26:25 <rostayob> or maybe are inferred automatically mhm
15:27:13 <Cale> http://www.haskell.org/ghc/docs/latest/html/libraries/base-4.5.0.0/Text-ParserCombinators-ReadP.html -- once you've read a bit about monadic parsing, just looking at what's available here should be enough to get you started pretty quickly :)
15:28:00 <rostayob> or you could read at the instances that GHC generates with -ddump-deriv!
15:28:03 <rostayob> no just kidding
15:28:20 <rostayob> gadtfly: parsec is more complex than ReadP but has nice tutorials
15:28:34 <rostayob> and you'll have to learn parsec combinators sooner or later anyways
15:28:36 <gadtfly> which is "cleaner" for such a small task?
15:30:15 <rostayob> gadtfly: the code would look very similar. ReadP types are much simpler
15:30:16 <DanBurton> fst :: (Clazz ~>) => (a,b) ~> a -- what is the Clazz that this should belong to? Category? Or a subclass of Category? If the latter, which one?
15:30:38 <rostayob> gadtfly: but if you import Text.Parsec.String you wouldn't have to worry about that too much
15:30:43 <byorgey> gadtfly: to me, that sounds like too complicated of a job to warrant doing it without something like PArsec.
15:31:08 <gadtfly> Okay, learning some parsec then.  Thanks!
15:31:24 <Cale> Parsec and ReadP are fairly comparable :)
15:31:33 <dmwit> DanBurton: I would expect that to be in a class for categories with products. I don't think there's a categorical term for these categories other than "categories with products".
15:31:41 <byorgey> DanBurton: definitely not Category, you only get pairing and projections like that in a category with products
15:32:00 <Cale> ReadP is a little simpler in implementation and capabilities, apart from the fact that it has a symmetric choice operator
15:32:09 <dmwit> Thank goodness byorgey used the same technical term I did.
15:32:13 <dmwit> =)
15:32:16 <byorgey> I expect the appropriate Clazz is defined in one of edwardk's packages
15:32:21 <byorgey> =)
15:32:22 <DanBurton> so, would I be justified in making, say class CategoryWithProduct (~>) where fst :: blah, snd :: blah ?
15:32:30 <ddarius> dmwit: Cartesian categories.
15:32:40 <byorgey> DanBurton: sure
15:32:46 <edwardk> byorgey: I have Class, not Clazz. ;)
15:32:49 <byorgey> ddarius: ahhh, right =)
15:32:55 <byorgey> hehe
15:33:07 <dmwit> DanBurton: http://hackage.haskell.org/packages/archive/categories/0.59/doc/html/Control-Category-Cartesian.html#t:PreCartesian perhaps?
15:33:25 <DanBurton> oh my
15:33:33 <edwardk> DanBurton: its a subclass of category, (Pre)Cartesian
15:33:35 <dmwit> ddarius: Ah, yup, the docs I linked to agree with you.
15:34:03 <rostayob> ah, so I guess that categories replace category-extras. good to know.
15:34:17 <edwardk> rostayob: categories is just the 'categories' from 'category-extras'
15:34:19 <dmwit> rostayob: The hackage page for category-extras now has detailed documentation on what replaces what.
15:34:25 <rostayob> oh, ok.
15:34:32 <hpc> rostayob: here's another great one
15:34:35 <gadtfly> What's the difference between importing Text.Parsec and Text.ParserCombinators.Parsec
15:34:37 <rostayob> edwardk: do you want to bet I can inhabit your Void type?
15:34:37 <edwardk> if you look at dmwit's category-extras replacement it contains links to a ton of packages i splintered it into
15:34:40 <hpc> undefined = unsafeCoerce unsafeCoerce
15:34:41 <ddarius> dmwit: Did you include a crazy dependency diagram?
15:34:51 <edwardk> rostayob: you can. its a pleasant fiction
15:34:53 <dmwit> ddarius: Yes: http://dmwit.com/category-extras/dependencies.png
15:34:59 <edwardk> and one i didn't bother with in the original category extras
15:35:04 <dmwit> ddarius: I spent a little while trying to uncross that one crossing, but gave up.
15:35:07 <DanBurton> hpc: -____-
15:35:11 <edwardk> which is what led to the current Monoidal/Comonoidal mess, which i keep meaning to remove
15:35:11 <hpc> rostayob: and for strict bytestrings, length = unsafeCoerce
15:35:15 <rostayob> edwardk: your package description is misleading. also absurd isn't of much value in Haskell :P
15:35:15 * hpc is full of these
15:35:15 <dmwit> ddarius: graphviz seemed to be ignoring my directives about placement.
15:35:30 <edwardk> i use absurd a lot
15:35:38 <byorgey> dmwit: Haddock has syntax for inline images, you know...
15:35:39 <rostayob> edwardk: you might actually trick logician into thinking that haskell types are consistent!
15:35:44 <rostayob> *logicians
15:35:48 <dmwit> byorgey: Ah! I didn't know.
15:35:55 <edwardk> sh.. you'll let them in on my ploy
15:36:07 <rostayob> hpc: lol are you trying them all?
15:36:11 <byorgey> dmwit: it's a closely guarded secret, it isn't mentioned in the manual =P
15:36:16 <hpaste> scooty-puff pasted ‚ÄúGADTs‚Äù at http://hpaste.org/64507
15:36:20 <hpc> rostayob: i have nothing better to do tonight :D
15:36:34 <byorgey> dmwit: the syntax is <<URL>>
15:36:55 <rostayob> edwardk: you use absurd a lot where? you're making poor Haskell play the theorem prover?
15:37:03 <rostayob> hpc: I'm going to add those
15:37:17 <cmccann> Haskell is a great theorem prover
15:37:19 <dmwit> byorgey: Wonderful. If there's ever a 1.0.1, that image will be inlined. =)
15:37:22 <cmccann> you can prove lots of theorems
15:37:24 <hpc> actually, i think im done; gonna go watch monk
15:37:31 <rostayob> cmccann: any theorem actually
15:37:33 <hpc> cmccann: all of them, in fact
15:37:34 <byorgey> dmwit: excellent =)
15:37:38 <ddarius> I like how 'categories' is just an minor twig unrelated to anything in category-extras.
15:37:46 <edwardk> rostayob: no, more like it makes a nice replacement for 'undefined' wherever you use Void to indicate the value isn't possible
15:37:53 <edwardk> ddarius: =)
15:38:01 <edwardk> i got bored
15:38:12 <cmccann> ddarius, I kind of want the rest of the graph to be collectively labeled "extras"
15:38:19 <rostayob> edwardk: oh ok, so it's kind of documenting
15:38:28 <dmwit> ddarius: Yeah, that really got me. And everything depends on comonad(-transformers).
15:38:30 <edwardk> rostayob: yeah
15:39:09 <ddarius> hpc: Don't worry, cmccann has a proof that he can't prove everything.
15:39:10 <edwardk> since absurd is a lot safer than undefined, since it won't bring any fresh bottoms into scope
15:39:56 <rostayob> edwardk: yeah I get your point... mhm. I might start as well, it will confuse people.
15:40:10 <hpc> ddarius: oh, well that's alright then
15:40:35 <rostayob> hpc: it doesn't work for length
15:40:41 <Veinor> length (show x) `seq` f x: the simpler alternative to x `deepseq` f x
15:40:45 <cmccann> @quote kmc prove
15:40:45 <lambdabot> kmc says: "Haskell is great, because Curry-Howard!  Proving things in the type system.  We can prove that, uh, Ints exist, unless they're ‚ä•."
15:40:46 <Ptival> am I reading #haskell, am I reading #agda, thin is the difference
15:41:01 <edwardk> dmwit: well, i have lots of packages that just depend on semigroup(oids) instead ;)
15:41:29 <edwardk> when i get a decent polykinded Category i can reduce the need to care about semigroups quite a bit
15:42:28 <rostayob> we should write a parody of RWH talking about those things
15:42:50 <hpaste> scooty-puff pasted ‚ÄúGADTs Warnings‚Äù at http://hpaste.org/64508
15:43:01 <edwardk> rostayob: i'd rather just write the serious book ;)
15:43:15 <rostayob> edwardk: I'd read that
15:43:41 <scooty-puff> http://hpaste.org/64508 - need some help - is this warning erroneous?
15:43:44 <rostayob> edwardk: I'm still not so convinced that we need to remember the names of that many abstractions :)
15:44:05 <edwardk> rostayob: *shrug* i get fairly productive use out of them =P
15:44:19 <rostayob> edwardk: yes, but you're you. you like studying those things
15:44:23 <rostayob> I probably would as well
15:44:29 <c_wraith> scooty-puff: doesn't look likei t
15:44:54 <scooty-puff> i should prob have given the def of Shape - its a gadt, where Open :: Shape O, Closed :: Shape C
15:45:02 <c_wraith> scooty-puff: I think you're legitimately missing those cases
15:45:05 <rostayob> I'm not sure the haskell programmers need to know the name instead of inventing them each time ehe
15:45:12 <scooty-puff> let me put the error when i try to
15:45:49 <shachaf> edwardk is writing a book?
15:45:54 * ddarius is pretty sure there is far more to remember in most typical APIs.
15:46:01 <edwardk> rostayob: i like being able to be parametric over them, because it enables me to focus on the portion of my algorithm that is actually interesting, and makes it much more difficult to screw up and type check
15:46:07 <cmccann> shachaf, no, he's not writing a serious book instead of not writing a parody book
15:46:12 <edwardk> in general, the general version of things is much safer to write than the specific ;)
15:46:13 <shachaf> cmccann: Ah, good.
15:46:21 <shachaf> I always thought edwardk's strategy was never to write any documentation so that everyone who wants to understand what he's talking about has to move to Boston.
15:46:24 <edwardk> shachaf: nah
15:46:30 <edwardk> shachaf: that too
15:46:37 <rostayob> edwardk: I mostly agree but you need a limit, otherwise you'd never stop abstracting.
15:46:46 <hpaste> scooty-puff annotated ‚ÄúGADTs Warnings‚Äù with ‚ÄúGADTs Warnings (annotation)‚Äù at http://hpaste.org/64508#a64509
15:47:07 <scooty-puff> c_wraith, here is one that gives an error when i try to define the missing patterns
15:47:47 <c_wraith> oh...  Your point is that types prevent those cases.
15:47:56 <c_wraith> due to Shape being a gadt
15:48:08 <c_wraith> and the compiler can see that, if you define one of those cases
15:48:28 <edwardk> rostayob: sure. but since for the most part my goal is to facilitate my own understanding, i'm generally fine ;)
15:48:35 <scooty-puff> yeah, so not sure if i should just.. put that in a sep module and ignore the warning as a compiler directive
15:48:44 <edwardk> and the grains of sand only get so fine ;)
15:48:44 <scooty-puff> *as a -> via a
15:49:35 <ddarius> One day edwardk will understand everything.  He will then spend the rest of eternity pondering what to do with that understanding.
15:50:11 <scooty-puff> c_wraith, this is both 7.0.3 and 7.4.1
15:50:20 <c_wraith> yeah, the warnings for overlapping/inexhaustive cases often struggle with language extensions.  Best you can do is just ignore the warning.
15:50:26 <scooty-puff> k
15:50:45 <Mathnerd314> ddarius: understanding is useless without the means to use it
15:52:19 <dmwit> Alright, so, looking at the current time is the standard way to seed a random number generator.
15:52:26 <dmwit> What's the standard way to seed ten random number generators?
15:52:47 <c_wraith> standard *insecure* way to seed an rng
15:52:54 <dmwit> Yes, I am okay with insecure.
15:52:57 <c_wraith> ok
15:53:10 <c_wraith> um.  seed one rng with the time, pull seeds for the next 9 out of it?
15:53:18 <dmwit> This is in an toy application whose only contribution to society is making it more fun for me to play Skyrim.
15:53:22 <dmwit> Security is not an issue. =)
15:53:33 <c_wraith> which is fine.  many rng uses don't need to be secure.
15:53:36 <c_wraith> Just wanted to make sure :)
15:53:41 <dmwit> thanks =)
15:53:51 <dmwit> Okay, pulling from the RNG itself seems reasonable, thanks.
15:55:13 <c_wraith> (also, sometimes surprising things need to be secure.  a friend of mine once cheated at whatever the big nethack tournament is by taking advantage of the fact that its rng wasn't secure.
15:55:33 <c_wraith> He only started games at times that would lead to a wand of wishing on the first level.
15:55:50 <jacobian> Any hints on how to use HsColour with utf-8 characters?
15:55:52 <dmwit> Are we talking about Adeon or whoever dying three times by kicking a /oW?
15:55:56 <dmwit> All on the same day?
15:56:01 <dmwit> Because that wasn't at a tournament...
15:56:03 <shachaf> c_wraith: NetHack's RNG has had bigger issues than that.
15:56:07 <scooty-puff> anyone involved with hoopl here?
15:56:16 <shachaf> c_wraith: In vanilla NetHack you can get unlimited wishes from a fountain by manipulating the RNG.
15:56:24 <c_wraith> dmwit: no, it was a many day online tournament.
15:56:35 <rostayob> edwardk: I'm not sure there is a limit to how fine the grains are eheh
15:56:41 <scooty-puff> was wondering if possible to get more polymorphic versions of <*>, |*><*| - for use in a type indexed writer monad
15:56:42 <shachaf> Tournaments these days use a secure RNG, of course.
15:57:04 <rostayob> edwardk: also I have to do something practical once in a while
15:57:21 <c_wraith> My point was that sometimes when you think "the quality of this rng isn't important," you're wrong. :)
15:57:37 <jacobian> Oh, NM, it works properly with utf-8
15:57:56 <edwardk> rostayob: well, ultimately they are build out of laws and operations, so you have a well founded foundation for them. ;)
15:58:12 <edwardk> you can add a single law or operation each time
15:58:36 <edwardk> which gets you something closer to what jacques carette likes, which is more fine-grained than even i like to go
15:59:19 <rostayob> I don't know who he is
15:59:23 <edwardk> i tend to try to avoid cases where you make a class that only adds laws and no operations. Letting the existence of extra operations guide my choices
15:59:48 <rostayob> the good thing is that *imho* this things are not hard in the end
16:00:21 <edwardk> has has a little language/theorem prover where he starts from the ground up and adds only single properties at a time, which has made him name a bunch of stuff i'd never even thought of
16:01:04 <edwardk> scary smart guy, somehow connected to roconnor's postdoc, up at mcmaster university, also coauthored the finally tagless paper with oleg and ken shan
16:01:24 <edwardk> and he used to run the math team at maple for several years
16:01:43 <edwardk> accomplishments not placed in any particular order ;)
16:01:44 <rostayob> I don't know that paper either :D
16:02:13 <edwardk> anyways just pointing out there is at least one person who likes things more fine grained than i do ;)
16:02:23 <rostayob> Oh I had no doubts :)
16:03:39 <rostayob> I'm still convinced I'm a programmer at heart. So I try to keep things even remotely practical ehe
16:14:24 <sully> hm
16:14:44 <sully> does anybody know what the original source describing monads as "programmable semicolons" is?
16:15:34 <edwardk> i find it eminently more practical to be able to use one name for 80 operations than clutter my namespace with 80 versions of the same abstraction, so i guess its all a matter of perspective ;)
16:16:43 <shachaf> sully: I vaguely think of dons as the source, but I have no idea.
16:16:50 <hpc> edwardk: i thought you liked having 80 abstractions :P
16:17:14 <sully> because I'd like to cite it
16:17:37 <edwardk> sure, in which case i'd have 6400 combinators. clearly ridiculous =)
16:17:47 * shachaf doesn't much like that analogy anyway.
16:18:13 <mdmkolbe> sully: I'm probably not the original source, but I've at least reinvented explaining it that way when explaining monads to by C++ programming dad ;-)
16:18:17 <sully> it fits for what I'm using it for
16:18:47 <sully> so, when looking at monads in the context of a strict language
16:18:59 <sully> I think it makes a lot of sense to look at it like programmable let binding
16:20:53 <sully> I'm also amused that, in #haskell, I can't even ask about what to *cite* for a particular monad analogy
16:21:03 <DanBurton> aw man. don't you love it when you pass one round of errors, only to find yourself assaulted by the next round
16:21:10 <shachaf> sully: "#haskell lore"
16:21:14 <sully> without people beginning to argue about monad analogies :P
16:21:30 <shachaf> sully: My preference is not to analogize.
16:21:52 <sully> sure, but I don't care :P
16:22:11 <sully> I'm not looking for opinions!
16:22:32 <shachaf> Well? "#haskell lore"
16:22:37 <sully> I'm not trying to learn monads, or trying to write a monad tutorial, I'm just trying to figure out what to cite for something :P
16:22:37 <DanBurton> analogies are like monads, not actually that big of a deal, yet sometimes useful
16:22:44 <shachaf> Just find a reference that says "everyone says it" and cite that.
16:23:30 <shachaf> Real-World Haskell uses that analogy; that's a reputable source to cite
16:24:42 <edwardk> well, by now i think its descended into a folklore quote
16:25:20 <mdmkolbe> shachaf: meh, "monads are parameterizable semicolons", "arrows are parameterizable function compositions", "applicative functors are parameterizable function applications", "continuations are saved copies of the stack".  All these quickly give non-FP people an accurate enough idea of what these things do.
16:25:37 <DanBurton> even dons attributes it to someone else: "If you recall from the dozens of other monad tutorials out there, a monad gives us a programmable ‚Äò;‚Äô" http://donsbot.wordpress.com/2007/03/10/practical-haskell-shell-scripting-with-error-handling-and-privilege-separation/
16:29:31 <rostayob> DanBurton: well. ';' captures only the >> aspect of things.
16:29:37 <rostayob> (didn't read the link)
16:30:48 <mdmkolbe> rostayob: unless your semicolons are spelled "x := e1; e2"
16:32:55 <rostayob> mdmkolbe: ?
16:33:01 <rostayob> the semicolon expresses the sequencing
16:33:03 <rostayob> not the binding
16:33:31 <rostayob> but the cool part about monads is the binding
16:34:28 <sully> right, which is why programmable let binding
16:34:53 <sully> but that's not really true over in haskell land, since let binding doesn't sequence
16:35:29 <mdmkolbe> rostayob: I'd say the binding is uninteresting in the absense of sequencing, and it is the sequence that is the more interesting aspect of monads.
16:36:18 <mdmkolbe> rostayob: ... but I'm going to invoke the monad generalization of Godwin on myself since I don't think arguing the point will be productive.
16:36:19 <rostayob> mdmkolbe: it's the opposite
16:36:25 <rostayob> having binding you can define sequencing
16:36:30 <rostayob> not the opposite
16:36:36 <rostayob> @src (>>)
16:36:37 <lambdabot> m >> k      = m >>= \_ -> k
16:36:59 <sully> sigh.
16:39:42 * mdmkolbe respectfully disagrees with rostayob, but doesn't wish to argue it further
16:39:58 <nyingen> I always viewed monads as a programmable (>>=)
16:40:20 <rostayob> mdmkolbe: I think that we can safely say that the operation that characterizes monads is bind. sequencing is just a special case
16:41:01 <rostayob> anyways, it's just terminology :P
16:41:42 <mdmkolbe> rostayob: you're talking about operators, I'm talking about effect.
16:42:08 <rostayob> mdmkolbe: "effect"?
16:42:08 <mdmkolbe> rostayob:  besides, *everyone* knows the essential operator of monads is "join". "Bind" is just an imposter ;-J
16:42:37 <rostayob> mdmkolbe: join can be defined in terms of bind, and vice-versa. but i'm sure i don't need to tell you that ehe
16:43:05 <rostayob> i just think that saying that a monad is a programmable ; is misleading, since ; means >> in most languages
16:43:05 <mdmkolbe> rostayob: I think you missed the ";-J" at the end of the last comment
16:43:11 <scooty-puff> is it possible to force a module to be exposed in a particular package?
16:43:18 <rostayob> mdmkolbe: yeah I knew you knew :P
16:43:19 <scooty-puff> that you do not have control over the source of
16:43:25 * Cale really wishes that GHC could handle foralls inside constraints.
16:43:30 <scooty-puff> i don't want to cabal unpack it, but..
16:43:39 <mdmkolbe> rostayob: ok, so I missed the ";-J" at the end of your message
16:43:55 <rostayob> I mean in SML ';' does exactly what >> does.
16:44:09 <rostayob> no binding involved.
16:44:17 <Cale> > [1,2,3] >> [4,5]
16:44:18 <lambdabot>   [4,5,4,5,4,5]
16:44:40 <rostayob> Cale: ?
16:44:50 <Cale> trollface.png
16:46:53 <Cale> (It's not *exactly* the same in SML, iiuc :)
16:47:06 <rostayob> Cale: I meant in the IO context
16:47:20 <Cale> yeah
16:47:33 <rostayob> it's not the same?
16:48:10 <Cale> It's similar for the context of IO, but is ; even really an operator in SML?
16:48:32 <Cale> I forget
16:48:45 <rostayob> Cale: I don't think it's first class if that's what you mean
16:48:47 <mdmkolbe> rostayob: by "effect" I mean the interesting semantic aspect of monads without regard to the mechanics of the operators
16:49:04 <Cale> Yeah, I was pretty sure that ; was just syntax
16:49:06 <rostayob> mdmkolbe: yeah, the interesting semantics lie in bind
16:49:24 <rostayob> Cale: but the semantics are the same of >>
16:53:14 <Cale> kinda...
16:53:27 <Cale> The things which ; separates aren't exactly like IO actions
16:53:58 <Cale> They're various sorts of declarations
16:54:03 <rostayob> Cale: no, true... but it sequences
16:54:17 <rostayob> anyways, pointless discussion :P
16:54:19 <Cale> You can sequentially define new datatypes
16:54:28 <Cale> If I'm reading the syntax correctly
16:54:39 <rostayob> Cale: well that's a different context in which ; is used
16:54:43 <rostayob> that ; is not the sequencing ;
16:55:03 <Cale> Oh, perhaps I'm not reading the right syntax tree here
16:55:29 <Cale> ah, yeah, that was in the syntax of some core language
16:55:57 <DanBurton> besides Sexy, Overture, The Other Prelude, alt-stdling, and Numeric Prelude, does anyone know of any other Prelude replacements or enhancements?
16:55:58 <rostayob> I'm talking about the (r := !r + 2; !r) ';'
16:56:21 <Cale> ah, I found it
16:56:56 <Cale> (exp1; ... expn; exp) translates into case exp1 of (_) => ... case expn of (_) => exp
16:59:02 <rostayob> Cale: right, in the same way that you could translate (a ; b) as '(\x. b) a' in a strict language
16:59:45 <mdmkolbe> Cale: Isn't that semantically equivalent to what IO >> translates to?  (The "case" just happens to be over a "real world" object.)
16:59:48 <Cale> It's sort of like >> for the identity monad, apart from the fact that evaluation is impure and you can have effects anywhere, and it's not a function.
17:00:05 <rostayob> Cale: yeah, but the result is more or less what you have for >> in IO.
17:00:40 <Cale> If you were to define the identity monad in SML, then it would be exactly >> for the identity monad.
17:01:12 <rostayob> Cale: yeah sure. I was just trying to say that saying that monads are programmable ';'s is misleading.
17:01:33 <Cale> But yeah, everything in SML is sort of like it's running in Haskell's IO monad.
17:02:08 <rostayob> I wouldn't mind SML if it wasn't for the curried operators and data constructor.
17:02:12 <rostayob> that really pisses me off
17:02:21 <rostayob> sorry, uncurried
17:02:56 <rostayob> for some reason
17:03:20 <rostayob> also the syntax, when I use SML I realize how cool Haskell syntax is
17:03:29 <rostayob> and how tricky it is to parse compared to SML
17:03:31 <Cale> The fact that data constructors are somehow not functions seems bizarre to me
17:03:53 <rostayob> Cale: they are, but they're uncurried
17:05:04 <rostayob> datatype tree 'a = Leaf a | Branch (Tree 'a) (Tree 'a)
17:05:20 <rostayob> Branch : (Tree 'a * Tree 'a) -> tree 'a
17:05:23 <rostayob> annoying
17:06:05 <Cale> ah, okay, so they're at least that level of first-class
17:06:17 <rostayob> no actually, the thing is that constructor take only one argument
17:06:18 <Cale> But yeah, why not curry them?
17:06:39 <rostayob> iirc the syntax is datatype tree 'a = Leaf of 'a | Branch of tree 'a * tree 'a
17:07:07 <rostayob> Cale: I think curried functions were considered problematic performance-wise. also, datatypes are much more uniform
17:07:26 <rostayob> also, the value restriction is very annoying.
17:07:42 <quintessence> I think the idea was that all of T's data constructors are of type a -> T for some a, and also they didn't really know what a good idea currying would turn out to be
17:08:15 <nogoodatprogramm> hello
17:08:28 <nogoodatprogramm> whats the output of this:
17:08:29 <rostayob> Cale: for the same reason SML (very restricted) standard library uses uncurried function apart from some exception
17:08:44 <rostayob> but otherwise a very nice language, I'd love an SML with haskell syntax and datatypes
17:08:45 <nogoodatprogramm> gray :: Integer -> [String] 	gray n 		| n == 0 = ["cat"] 		| n  >  0 = map (++ "A") (gray (n-1)) ++ 			        map (++ "B") (reverse (gray (n-1)))
17:08:52 <nogoodatprogramm> if n = 2
17:09:02 * rostayob goes to bed
17:09:21 <Cale> nogoodatprogramm: Why not put it in a file and try it yourself? :)
17:09:47 <nogoodatprogramm> thanks for you help
17:09:53 <nogoodatprogramm> anyone else a genius here?
17:10:14 <ion> lambdabot is.
17:10:15 <DanBurton> nogoodatprogramm: everyone in #haskell is, by definition, a genius
17:10:31 <DanBurton> except the trolls, perhaps
17:10:39 <nogoodatprogramm> so what would be the output of that simple program
17:10:49 <nogoodatprogramm> i just need a quick answer
17:10:58 <ion> Its output is ‚ÄúHello, world‚Äù.
17:11:02 <Cale> Given the name of the program and a cursory glance at what it's doing, I suspect it would produce all the gray codes on A and B, each prepended to "cat"
17:11:12 <DanBurton> nogoodatprogramm: why don't you run it and see for yourself?
17:11:13 <Cale> (of length 2)
17:11:31 <Cale> ghci can provide an answer surely much more quickly than we can
17:11:36 <nogoodatprogramm> if i could run it myself then i wouldnt come here to ask you
17:11:42 <nogoodatprogramm> so if you cant help please dont talk
17:11:50 <Cale> Okay, so copy it into a text file, named grey.hs
17:12:02 <Cale> hopefully aligned better and not smushed onto one line
17:12:04 <Cale> then run
17:12:07 <Cale> ghci grey.hs
17:12:10 <Cale> and type in
17:12:12 <Cale> grey 2
17:12:21 <Cale> Or gray 2
17:12:25 <Cale> as the case may be :)
17:12:33 <nogoodatprogramm> ok... thank you
17:13:22 <DanBurton> nogoodatprogramm: http://tryhaskell.com , or you can /msg lambdabot > anExpression
17:13:30 <DanBurton> *org
17:13:32 <DanBurton> not com
17:13:56 <DanBurton> e.g. /msg lambdabot > 2 + 2
17:14:11 <Cale> nogoodatprogramm: Is this for a course?
17:15:02 <Cale> nogoodatprogramm: I mean, if this is an exercise, the exercise is probably just to see if you have a working Haskell implementation, so you're probably better off just solving it right away rather than asking other people, because you're going to need a Haskell interpreter/compiler later.
17:16:01 <Enigmagic> heh
17:16:04 <Cale> (Quit: Page closed) <-- This quit message always seems to be paired with people who leave at annoying times.
17:16:17 <Enigmagic> Cale: if you can't help please don't talk
17:16:24 <DanBurton> lmao
17:16:44 <Cale> Web clients to IRC should be banned.
17:17:03 <Cale> Or at least, I often seem to feel that way.
17:17:06 <DanBurton> all guis should be banned
17:17:11 <Enigmagic> agreed
17:17:53 <td123> DanBurton: I can't live w/o my browser though :(
17:18:15 <Enigmagic> td123: ?
17:18:41 <Enigmagic> it's not like you have to use lynx if you use a text mode irc client
17:19:33 <td123> never mind, I interpreted his statement to generally
17:19:47 <DanBurton> I actually tried to use a vim-like plugin for Firefox; couldn't stand it because it messed up a couple keybindings that I am really used to
17:19:55 <Enigmagic> vimium for chrome rocks
17:20:08 <td123> Enigmagic: agreed
17:20:15 <DanBurton> also, everyone should use XMonad
17:20:20 <Cale> ugh
17:20:24 <Enigmagic> i use osx so no xmonad :P
17:20:26 <WolfStorm> hey, im on a mac... how do i open haskell files?
17:20:28 <Cale> I can't stand tiling WMs
17:20:36 <shachaf> Enigmagic: I talked to someone who was porting XMonad to OS X once!
17:20:42 <shachaf> Natively, I mean, not through X11.
17:20:49 <Cale> WolfStorm: for editing or...?
17:20:57 <Enigmagic> shachaf: they tried porting it once, or you talked to them once?
17:21:02 <DanBurton> Cale: why not? it works so perfectly; at first it was annoying, but it's quite liberating once you get used to it
17:21:06 <WolfStorm> editing i can just make it a txt file
17:21:08 <WolfStorm> but to run
17:21:09 <Cale> WolfStorm: If you've installed GHC, you can run ghci on them from the commandline
17:21:20 <shachaf> Enigmagic: Talked to them once.
17:21:36 <WolfStorm> i know im a total noob, but how do i get ghc?
17:21:41 <ivanm> @where platform
17:21:42 <DanBurton> @where hp
17:21:42 <lambdabot> http://hackage.haskell.org/platform/
17:21:42 <lambdabot> http://hackage.haskell.org/platform/
17:21:47 <ivanm> WolfStorm: ^^
17:21:49 <DanBurton> =)
17:21:51 <Grace12> hello everyone.
17:21:57 <WolfStorm> thanks guys
17:21:59 <Cale> DanBurton: because most programs were not designed to fit into arbitrarily shaped rectangles, and also contain a lot of visual junk which you actually want to cover with your other windows, even if you still want to see the contents of that window
17:22:00 <DanBurton> Grace12: hello
17:22:00 <WolfStorm> real help
17:22:10 <Enigmagic> shachaf: interesting, not sure i'd use it though.
17:22:11 <Cale> DanBurton: (like toolbars, etc.)
17:22:25 <DanBurton> Cale: fair point, but that's a flaw in those programs, not in XMonad
17:22:58 <Enigmagic> Cale: perhaps you need to use better programs, ones that are naturally square
17:23:08 <Enigmagic> (i also use layers of apps with transparency)
17:23:08 <Cale> If XMonad could be easily configured to be indistinguishable from metacity, I would use it.
17:23:44 <Cale> (for the programmability, though I'm not 100% sure what I'd use that for)
17:23:56 <DanBurton> "easily configured" meaning if someone did the configuration for you ;) even if the configuration itself was complicated, it's easy if you just have to copy/paste, or import, or whatever
17:24:02 <HugoDaniel> :D
17:24:10 <Cale> Right.
17:24:27 <JoeyA> cabal install seems more convenient than copy-paste :-)
17:24:31 <Grace12> I am writing a little parser using parsec. I had one of the grammar like: lower -> a | b | c ... | z. I defined the lower as lower = oneOf ['a'..'z''], but it does not work. Any suggestions? Thanks a lot.
17:24:31 <Cale> Someone would have to write a metacity-like window border mode which makes all the windows float
17:24:41 <Cale> (apart from the root)
17:24:49 <JoeyA> Then again, blame how complicated copy-paste is these days.
17:25:09 <Cale> Grace12: did you have that extra ' ?
17:25:10 * DanBurton wonders who among the xmonad nutters would be dedicated enough to do this for Cale
17:25:53 <Entroacceptor> there's bluetile...
17:26:01 <Grace12> sorry my typo, it should be: oneOf ['a'..'z'].
17:26:17 <Cale> Yeah, that should work
17:26:50 <Grace12> <Cale>: it does not work, unfortunately
17:26:57 <Cale> The problem must be elsewhere
17:27:07 <DanBurton> not entirely related, but you could also do: lower = satisfy isLower -- Data.Char provides isLower, right?
17:27:19 <Cale> lower already exists in the module where oneOf is defined though
17:27:29 <quintessence> Grace12: does it (a) not match what you expect, (b) not compile, or (c) "not work" in some other way?
17:27:30 <Cale> So you're already shadowing something which is equivalent to that.
17:27:59 <Cale> yeah, satisfy isLower would probably be smarter
17:27:59 <DanBurton> Grace12: what's the error message that you get? What do you mean exactly when you say "it does not work"?
17:28:07 <Cale> > isLower '‰'
17:28:08 <lambdabot>   False
17:28:08 <DanBurton> Grace12: if it's long, you can paste it at http://hpaste.org
17:28:11 <Cale> hrm
17:28:33 <Cale> must be an encoding issue there :)
17:28:46 <Enigmagic> Cale: it doesn't have a case, so it can't be upper or lower
17:28:54 <Cale> ghci> isLower '‰'
17:28:54 <Cale> True
17:29:52 <Cale> That's supposed to be a lowercase a with diaeresis.
17:29:58 <shachaf> Cale: You should notify the person who runs lambdabot.
17:30:02 <Cale> kekeke
17:30:12 <hpaste> Grace12 pasted ‚Äúlower‚Äù at http://hpaste.org/64515
17:30:20 <Cale> You mean I should notify lambdabot's maintainer. Oops, lambdabot doesn't have a maintainer.
17:31:12 <Cale> Grace12: you shouldn't have to redefine lower anyway, if oneOf is in scope, then so is lower.
17:31:41 <Cale> But that's just an ambiguity problem caused by Parsec's aggressive polymorphism
17:31:49 <Grace12> so lower is already defined in parsec?
17:31:56 <Cale> also, the monomorphism restriction, probably
17:31:58 <Cale> yeah
17:32:00 <Cale> it is :)
17:32:12 <Cale> lower :: (Stream s m Char) => ParsecT s u m Char
17:32:12 <Cale> lower               = satisfy isLower       <?> "lowercase letter"
17:32:32 <tazjin> > isLower '√Ñ'
17:32:33 <lambdabot>   False
17:32:45 <tazjin>  ¬Ø\(o_O)/¬Ø
17:33:00 <Cale> > 'ƒ'
17:33:01 <lambdabot>   '\65533'
17:33:03 <DanBurton> > isUpper '√Ñ'
17:33:04 <lambdabot>   True
17:33:16 <tazjin> > isLower '√∂'
17:33:17 <lambdabot>   True
17:33:21 <tazjin> > isLower '√º'
17:33:22 <lambdabot>   True
17:33:26 <tazjin> > isLower '√§'
17:33:27 <lambdabot>   True
17:33:36 <Cale> \65533 is something completely weird
17:33:57 <shachaf> 17:27 < Cale> > isLower '√§'
17:34:03 <shachaf> > isLower '√§'
17:34:04 <lambdabot>   True
17:34:07 <shachaf> What?
17:34:11 <tazjin> Yeah
17:34:13 <Cale> lol, what?
17:34:22 <Cale> Maybe my IRC client is being strange.
17:34:27 <tazjin> Cale, did you type it or copy it from somewhere?
17:34:33 <Cale> I typed it
17:34:35 <shachaf> I copied Cale's line from above.
17:34:39 <shachaf> Just then.
17:34:41 <tazjin> I'm using a German keyboard here and it recognizes it correctly
17:34:43 <Grace12> I saw strange characters.
17:34:44 <copumpkin> could differ based on whether it's composed
17:34:55 <Cale> I'm using my Compose key
17:34:58 <copumpkin> ¬®a vs √§
17:34:59 <Cale> So maybe that's it.
17:35:06 <shachaf> copumpkin: I copied whatever character my IRC client showed for Cale's previous line, though.
17:35:11 <copumpkin> but I'm not sure why it gets recognized as a single character constant then
17:35:49 <copumpkin> > isLower '¬®'
17:35:50 <lambdabot>   False
17:36:07 <Cale> > isLower '‰'
17:36:08 <lambdabot>   False
17:36:11 <Cale> lol!
17:36:14 <shachaf> > isLower '√§'
17:36:15 <lambdabot>   True
17:36:19 <Cale> > isLower '‰'
17:36:19 <lambdabot>   False
17:36:24 <copumpkin> > '√§' == '√§'
17:36:25 <lambdabot>   True
17:36:29 <shachaf> Cale: Can you record the bytes yo ur IRC client is sending out?
17:36:30 <Cale> I'm copy pasting your line in that case :)
17:36:46 <Cale> > '‰' == '‰'
17:36:47 <lambdabot>   True
17:36:49 <shachaf> This is pretty weird.
17:36:55 <Enigmagic> Cale: where do you see that question mark should be uppercase or lowercase?
17:37:08 <Cale> Enigmagic: It doesn't show up as a question mark for me
17:37:45 <Cale> Enigmagic: However, \65533 shows up as a question mark inside a hexagon when I write it to a terminal.
17:37:46 <shachaf> I'm getting an a with di√¶resis.
17:37:53 <Cale> yeah, me too
17:37:59 <Enigmagic> the joys of irc
17:38:05 <shachaf> Hmm.
17:38:16 <shachaf> I guess anyone can run a client and record the bytes it gets, actually.
17:38:29 <Cale> Maybe I should switch to pure UTF-8 mode rather than this odd Latin-1/Unicode hybrid.
17:38:37 <stepcut> I want to do, replicate 10000 foo, but I want the resulting list to *not* exploit sharing.. any ideas how to make that happen ? (I want 10000 separate copies of foo)
17:38:47 <shachaf> Cale: Wait, keep it on. I want to see what's happening now.
17:39:00 <shachaf> stepcut: Copies to what extent?
17:39:28 <stepcut> shachaf: I want all the data to be duplicated for each copy. So if I have 1000 copies, it should take up 1000 as much RAM
17:39:44 <Cale> > isLower '‰'
17:39:45 <lambdabot>   False
17:39:52 <shachaf> > isLower '√§'
17:39:53 <lambdabot>   True
17:39:57 <Cale> Okay, so that doesn't help
17:40:54 <shachaf> Let me see...
17:41:15 <Cale> Êó•Êú¨Ë™û„ÅßÊõ∏„ÅÑ„Å¶„ÇãÔºü
17:41:33 <shachaf> All shows up OK (I assume).
17:41:36 <Cale> okay
17:41:48 <applicative> stepcut, map unsafePerformIO $ replicate 100 (return foo)
17:42:12 <Cale> > isLower '‰'
17:42:13 <lambdabot>   False
17:42:25 <Cale> nope, having iBus running doesn't change anything :P
17:42:29 <shachaf> Let's try this:
17:42:49 <shachaf> Cale: Can you type it now?
17:43:12 <Cale> I can copy/paste the appropriate character (U+00E4) out of character map and it doesn't work
17:43:19 <Cale> Or from your previous lines
17:43:19 <ion> @echo √§
17:43:19 <lambdabot> echo; msg:IrcMessage {msgServer = "freenode", msgLBName = "lambdabot", msgPrefix = "ion!ion@heh.fi", msgCommand = "PRIVMSG", msgParams = ["#haskell",":@echo \195\164"]} rest:"\195\164"
17:43:24 <ion> Try that.
17:43:29 <Cale> @echo ‰
17:43:29 <lambdabot> echo; msg:IrcMessage {msgServer = "freenode", msgLBName = "lambdabot", msgPrefix = "Cale!~Cale@CPE00026f8481b6-CM00222d55727d.cpe.net.cable.rogers.com", msgCommand = "PRIVMSG", msgParams = ["#
17:43:29 <lambdabot> haskell",":@echo \228"]} rest:"\228"
17:43:38 <Cale> wow, odd :)
17:43:45 <shachaf> Aha!
17:43:47 <ion> Ok, your client seems to be sending lines in the ISO-8859-1 encoding.
17:43:57 <applicative> in the irc log one of them is appearing to me as what appears to me as  '√É¬§'
17:44:04 <Cale> Which is bizarre, since it's set to UTF-8
17:44:05 <tazjin|iso88591> > isLower '‰'
17:44:06 <lambdabot>   False
17:44:15 <tazjin> aha!
17:44:36 <shachaf> Cale: Yes, you're sending Latin-1 characters to Freenode, apparently.
17:44:42 <ion> tazjin|iso88591: What does ord '√§' return for you?
17:44:43 <Cale> Yeah, weird
17:44:46 <shachaf> Somehow my irssi recognized that and interpreted them correctly.
17:45:00 <Cale> and yet if I speak in Êó•Êú¨Ë™û, somehow that works
17:45:05 <Cale> I wonder what if...
17:45:08 <shachaf> Can you @echo that?
17:45:11 <ion> shachaf: Yeah, it falls back to ISO-8859-1 by default (IIRC) if the line isn‚Äôt valid UTF-8.
17:45:23 <Cale> > {- Êó•Êú¨Ë™û -} isLower '√§'
17:45:24 <shachaf> So that explains it.
17:45:24 <lambdabot>   True
17:45:27 <Cale> LOL
17:45:47 <tazjin|iso88591> > ord '‰'
17:45:48 <lambdabot>   65533
17:46:00 <tazjin|utf8> > ord '√§'
17:46:01 <lambdabot>   228
17:46:23 <ion> Ah, the replacement character. ÔøΩ
17:46:31 <Cale> > (ord '√§', {- È≠îÊ≥ï -} ord '√§')
17:46:32 <lambdabot>   (228,228)
17:46:39 <Cale> hmm
17:46:43 <shachaf> Cale: Too much to hope for. :-)
17:46:58 <shachaf> Can you @echo √§ with some other symbols?
17:47:15 <Cale> @echo È≠îÊ≥ï √§
17:47:15 <lambdabot> echo; msg:IrcMessage {msgServer = "freenode", msgLBName = "lambdabot", msgPrefix = "Cale!~Cale@CPE00026f8481b6-CM00222d55727d.cpe.net.cable.rogers.com", msgCommand = "PRIVMSG", msgParams = ["#
17:47:15 <lambdabot> haskell",":@echo \233\173\148\230\179\149 \195\164"]} rest:"\233\173\148\230\179\149 \195\164"
17:47:39 <tazjin|iso88591> @echo ‰ ˆ ¸
17:47:40 <lambdabot> echo; msg:IrcMessage {msgServer = "freenode", msgLBName = "lambdabot", msgPrefix = "tazjin|iso88591!~tazjiniso@port-92-205-9-148.dynamic.qsc.de", msgCommand = "PRIVMSG", msgParams = ["#haskell",":@
17:47:40 <lambdabot> echo \228 \246 \252"]} rest:"\228 \246 \252"
17:47:41 <shachaf> So your client switches to UTF-8 when it's trying to send characters outside of Latin1.
17:47:47 <shachaf> Otherwise it sends Latin1.
17:47:57 <shachaf> That is a horrible behavior.
17:48:00 <Cale> It has a mode which is *supposed* to do that, except I'm no longer in that mode.
17:48:19 * shachaf wonders whether IRC specifies to interpret things this way.
17:48:20 <ion> It has such a mode? Burn the developers with fire.
17:48:20 <Cale> I explicitly switched to pure UTF-8 mode, but apparently that's broken.
17:48:30 <tazjin|iso88591> Cale: What client is it?
17:48:33 <Cale> XChat
17:49:16 <ion> shachaf: AFAIR IRC only specifies messages to be strings of octets that don‚Äôt contain the zero byte.
17:50:01 <ion> So if your client can make sense of what another client dumps to a channel, you‚Äôre lucky. :-P
17:50:30 <ion> Fortunately a lot of users have moved to UTF-8 over the years.
17:51:06 <mauke> zachk: hi
17:51:35 <geekosaur> xchat can do utf8 fine
17:51:37 <geekosaur> BUT
17:51:52 <geekosaur> you must disconnect and reconnect from the IRC server to switch charset
17:51:56 <gfredericks> is installing cabal on a 512mb machine hopeless?
17:51:57 <Cale> I did...
17:52:05 <Cale> Maybe I'll try restarting the client altogether
17:52:08 <geekosaur> (and in older versions must restart xchat completely(
17:52:12 <geekosaur> or weird things will happen
17:52:19 <c_wraith> running ld in a 512mb machine (on ghc-generate code) is hopeless
17:52:27 <tazjin|xchat> > isLower '‰'
17:52:27 <lambdabot>   False
17:52:32 <c_wraith> your odds are better if you use a different linker, like gold
17:52:35 <Cale> > isLower '√§'
17:52:35 <lambdabot>   True
17:52:41 <Cale> woo
17:52:50 <Cale> Now it's sane :)
17:52:55 <JoeyA> In one IRC channel I've frequented, the bot is configured to automatically ban users who post invalid UTF-8.  I think that's a good policy.
17:52:56 <gfredericks> c_wraith: I recompiled the ghc with the SplitObjs set to NO, if that's what you're referring to
17:52:57 <tazjin|xchat> Cale: Still using Xchat?
17:53:01 <JoeyA> (users can ask to come back, though)
17:53:03 <Cale> yes
17:53:10 <ion> I tried gold (with GHC 7.4.1 if that‚Äôs relevant) and it didn‚Äôt work. I don‚Äôt remember the error messages anymore, but i think GHC may have used some flags it didn‚Äôt understand.
17:53:12 <c_wraith> gfredericks: it's still pretty memory-intensive
17:53:13 <Cale> But I set the charset to UTF-8 and then *restarted* it
17:53:19 <JoeyA> Maybe not a good policy for big channels, though.
17:53:28 <Cale> (I originally just disconnected and reconnected to the server)
17:53:42 <ion> joeya: *Ban*? That‚Äôs insane. :-P
17:55:06 <JoeyA> Why is that insane?
17:55:22 <tazjin|xchat> > isLower '√§'
17:55:23 <lambdabot>   True
17:55:23 <JoeyA> It's a good way to get people to configure their clients correctly
17:55:31 <JoeyA> Though a bit extreme
17:56:42 <dolio> It's a good way to have a lot of people banned from your channel.
17:56:51 * gfredericks tries gold
17:57:07 <JoeyA> I suppose it's not a good idea for a large channel, then
17:57:25 <JoeyA> (the channel in question was in the 5-15 range (of number of users))
17:58:08 <JoeyA> As I said, users could appeal.
17:58:38 <otters> > isLower '√ø'
17:58:39 <lambdabot>   True
17:58:51 <otters> > isLower '≈∏'
17:58:52 <lambdabot>   False
17:59:12 <gfredericks> woohoo, gold worked
17:59:14 <gfredericks> c_wraith: thanks!
18:05:37 <mdmkolbe> What is gold? (Other than element number 79.)
18:06:14 <ion> @google gold linker
18:06:15 <lambdabot> http://en.wikipedia.org/wiki/Gold_(linker)
18:06:16 <lambdabot> Title: gold (linker) - Wikipedia, the free encyclopedia
18:07:18 <mdmkolbe> ah, I see
18:14:49 <dibblego> what is the most appropriate way to specify the dependency in your cabal file if you use Control.Monad.Identity? I always get tangled up with mtl and friends
18:16:44 <applicative> my ghc-pkg find-module Control.Monad.Identity only lists mtl
18:17:24 <gadtfly> New to Parsec.  Is there a cleaner way to state this: priceParser = char '$' >> (fmap read $ manyTill anyToken eof)
18:18:28 <dibblego> char '$' *> read <$> manyTill anyToken eof -- perhaps
18:19:21 <ion> I‚Äôd also separate manyTill anyToken eof to a separate parser (called ‚Äúrest‚Äù or something). And in ‚ÄúpriceParser‚Äù, the ‚ÄúParser‚Äù is redundant IMO.
18:19:25 <gadtfly> Is *> the same as >>?
18:19:39 <dibblego> yes, but in Applicative not Monad, just in keeping with the theme
18:20:10 <ion> They have a different precedence, though.
18:20:22 <gadtfly> Cool, thanks.  So there's no Parsec built-in equivalent to "rest"?
18:21:40 <ion> dibblego: I‚Äôm afraid that gets parsed as (char '$' *> read) <$> ‚Ä¶
18:22:05 <ion> ¬´char '$' *> (read <$> rest)¬ª or ¬´read <$> (char '$' *> rest)¬ª
18:22:10 <dibblego> boo
18:22:27 <ion> > [1,2] *> (+3) <$> [4,5]
18:22:28 <lambdabot>   Couldn't match expected type `a -> a1' against inferred type `[a2]'
18:22:32 <ion> > [1,2] *> ((+3) <$> [4,5])
18:22:33 <lambdabot>   [7,8,7,8]
18:22:56 <dibblego> ok my gamble didn't pay off, sorry
18:24:13 <gadtfly> Thanks for the tip, in any case.  I just need a baseline to calibrate my style off of
18:25:49 <ion> I‚Äôd probably write rest as ‚Äúmany anyToken <* eof‚Äù
18:27:27 <ion> Actually, i think ‚Äúmany anyToken‚Äù may suffice.
18:27:39 <gadtfly> Oh yeah
18:28:32 <gfredericks> when `cabal install` fails with missing modules, how do I go about...fixing that?
18:29:26 <dmwit> Did you list all your modules in either the exposed-modules or other-modules sections?
18:29:39 <dmwit> It might help if you show us the exact error message.
18:29:40 <dmwit> ?hpaste
18:29:40 <lambdabot> Haskell pastebin: http://hpaste.org/
18:30:23 <hpaste> gfredericks pasted ‚Äúfoobar‚Äù at http://hpaste.org/64518
18:30:38 <gfredericks> dmwit: it's not my code, I'm just trying to install git-annex
18:30:47 <dibblego> @hoogle (a -> b) -> (c -> d) -> f a c -> f b d
18:30:47 <lambdabot> Data.Graph.Inductive.Query.Monad (><) :: (a -> b) -> (c -> d) -> (a, c) -> (b, d)
18:32:39 <dmwit> :t (&&&)
18:32:40 <lambdabot> forall (a :: * -> * -> *) b c c'. (Arrow a) => a b c -> a b c' -> a b (c, c')
18:32:52 <dmwit> dibblego: Perhaps bimap.
18:33:04 <dibblego> yeah found him in bifunctors
18:33:24 <dmwit> http://hackage.haskell.org/packages/archive/bifunctors/0.1.2/doc/html/Data-Bifunctor.html
18:33:27 <dmwit> oh, yeah, you found it
18:33:35 <dibblego> ta
18:33:57 <dmwit> gfredericks: Probably you need to complain to the maintainer.
18:34:11 <dmwit> gfredericks: Bonus points if you send him a git patch. =)
18:34:35 <gfredericks> dmwit: it would be bonus points for sure as I'd have to learn haskell first
18:34:44 <gfredericks> dmwit: thank you sir
18:35:17 <dmwit> gfredericks: This particular error looks like the cabal file should have an additional dependency (on the "text" package).
18:35:51 * gfredericks installs that
18:35:54 <dmwit> gfredericks: You should try fixing this by calling "cabal unpack git-annex", then editing the .cabal file in the resulting directory and adding "text" to the "build-depends" section.
18:36:12 <dmwit> gfredericks: Just installing text is not sufficient -- you must also fix the .cabal file as I outlined.
18:36:25 <gfredericks> how do I install after unpacking?
18:36:37 <dmwit> "cabal install" from the directory it produces
18:36:44 <gfredericks> k, will try that
18:36:47 <dmwit> (with no extra package name parameter)
18:36:55 <subhashpant> what exactly is .cabal file for?
18:37:01 <hughfdjackson> DanBurton:
18:37:04 <hughfdjackson> oops
18:37:12 <hughfdjackson> :s tab mishap, my apologies
18:37:38 <dmwit> subhashpant: It stores metadata, like dependencies, build instructions, licensing/authorship/maintainership information, etc.
18:38:22 <subhashpant> dmwit: Thanks. I will explore that. I have that getting goofed up in my eclipse all the time. my plugin does not seem to understand that a particular file is deleted.
18:39:05 <gfredericks> now I am getting more missing modules: 'GHC.Foreign' and 'Build.SysConfig'
18:39:27 <gfredericks> any way I can find out on my own what packages these correspond to?
18:40:22 <dmwit> If you have the package already installed, cabal should tell you which package it is that's hidden.
18:40:43 <dmwit> ...and you should already have the package that supplies "GHC.Foreign" installed. It comes with GHC.
18:41:20 <gfredericks> I guess it is giving up time then
18:41:30 <dmwit> No idea about Build.SysConfig. A tool for identifying the package that supplies a module would be nice; perhaps you can suggest it to the Hackage2 folks.
18:41:56 <Guest94804> hey can someone help me out. im new to haskell and im reading a problem from my book and im not too clear on it. When you map a letter to a number, does that mean you write that letter the number of times?
18:42:06 <dmwit> GHC.Foreign is in base, according to
18:42:11 <dmwit> http://www.haskell.org/ghc/docs/latest/html/libraries/
18:42:42 <tazjin> gfredericks: Which version of GHC do you have? Did you install the haskell platform?
18:42:51 <Guest94804> and you increment that letter
18:42:54 <gfredericks> I installed 7.0.4 by hand
18:42:55 <Guest94804> what does that mean?
18:42:59 <dmwit> Guest94804: Depends on the context a bit, but I would expect that to mean you have a function that produces that number as output when given that letter as input.
18:43:10 <gfredericks> dmwit: the build-depends lists "base < 5"
18:43:22 <dmwit> gfredericks: Just paste the *whole* output to hpaste.org.
18:43:28 <gfredericks> tazjin: not the platform, just ghc
18:43:54 <gfredericks> dmwit: k
18:43:59 <Guest94804> its like " map (++ "x") (variable (n-1)
18:44:13 <dmwit> ah
18:44:18 <Guest94804> the output is x, n times
18:44:29 <dmwit> Guest94804: (++) is the list-concatenation function
18:44:31 <tazjin> gfredericks: What does $ cabal info base | grep installed    say?
18:44:43 <Guest94804> what does that mean?
18:44:46 <hpaste> gfredericks pasted ‚Äúgit-annex‚Äù at http://hpaste.org/64519
18:45:00 <quintessence> > "abc" ++ "def"
18:45:02 <lambdabot>   "abcdef"
18:45:06 <dmwit> Guest94804: (++ foo) and (bar ++) are pieces of syntax that are short for (\x -> x ++ foo) and (\x -> bar ++ x), respectively.
18:45:16 <gfredericks> tazjin:  Versions installed: (4.3.1.0)
18:45:54 <Guest94804> im confused
18:46:02 <Guest94804> so what would that mean for the output?
18:46:17 <thlorenz> does anyone know an answer to my question? How can I determine size of a type in Haskell? (is that even possible) I posted the question on stack overflow: http://stackoverflow.com/questions/9492801/how-can-i-determine-size-of-a-type-in-haskell
18:46:25 <tazjin> gfredericks: You need a newer version of base
18:46:36 <Guest94804> i do x(n)x(n-1)
18:46:43 <sipa> thlorenz: in general, the size of a type is not defined
18:46:45 <gfredericks> tazjin: how do I get such a thing?
18:46:51 <dmwit> > sizeOf (0 :: Word32)
18:46:52 <lambdabot>   Not in scope: `sizeOf'
18:47:10 <sipa> thlorenz: but for usage in the FFI, there is the Storable class, with a sizeof function
18:47:19 <dmwit> thlorenz: http://hackage.haskell.org/packages/archive/base/latest/doc/html/Foreign-Storable.html#v:sizeOf
18:47:32 <thlorenz> right, but then I'd have to make my type an instance of Storable just for that
18:47:47 <dmwit> thlorenz: Yes.
18:47:48 <thlorenz> I was looking for a more generic version
18:47:49 <sipa> thlorenz: what do you need the size of a type for?
18:48:05 <thlorenz> sending data over a socket
18:48:16 <mauke> you can't send values over a socket
18:48:19 <sipa> you're going to need to serialize the data first anyway
18:48:20 <mauke> you can only send bytes
18:48:28 <thlorenz> so when I get bytes I'd know how many to read if I am reading them back
18:48:31 <dmwit> thlorenz: (Storable is one way to turn data into bytes.)
18:48:35 <thlorenz> I am serializing to Word32
18:48:36 <tazjin> gfredericks: I'm not sure, base should be provided with GHC. GHC.Foreign is included in 4.4.1.0 (GHC 7.2.2). I don't think cabal can reinstall base
18:48:55 <tazjin> The other folks will surely correct me if I'm wrong here
18:49:00 <gfredericks> I'll try 7.2.2. It was failing the other day.
18:49:00 <ion> thlorenz: As for the Data instance, with -XDeriveDataTypeable you can derive Data and Typeable. I don‚Äôt know whether that‚Äôs useful or not to get gsize to return what you want.
18:49:01 <thlorenz> dmwit: thanks, I'll look into it
18:49:10 <Guest94804> hey guys. some help please. for example: n = 4, map (++ "x") (variable (n-1)) would give an output of xxxx
18:49:26 <Guest94804> ?
18:49:39 <thlorenz> ion: looked into that as well, again trying to avoid having to make my type an instance of anything just for that
18:49:49 <sipa> Guest94804: what is "variable" ?
18:49:50 <dmwit> Guest94804: It really depends on the definition of "variable".
18:49:51 <mike-burns> > take 4 $ repeat 'x'
18:49:51 <lambdabot>   "xxxx"
18:50:10 <Guest94804> variable is just a string
18:50:15 <BMeph> > replicate 4 'x'
18:50:16 <lambdabot>   "xxxx"
18:50:17 <Guest94804> oh ok
18:50:19 <Guest94804> perfect
18:50:20 <Guest94804> thanks
18:50:20 <sipa> you can't apply a string to n-1
18:50:26 <ion> thlorenz: Well, you don‚Äôt lose anything by adding such instances.
18:50:46 <dmwit> Guest94804: If variable is a string, then the output of what you asked about is "type error".
18:50:47 <mike-burns> Oh hey wait, Guest94804 . Make sure you understand why this works!
18:51:00 <thlorenz> dmwit: actually Storable looks really promising and I should be able to just derive it, since Word32 is already an instance of it
18:51:10 <Guest94804> yeah??
18:51:17 <thlorenz> and my types are made up of Word32s only
18:51:35 <Guest94804> or, variable is in integer
18:51:39 <Guest94804> would that be good?
18:51:42 <mike-burns> Guest94804: No.
18:51:46 <dmwit> nope
18:51:47 <Guest94804> im really new to haskell
18:51:53 <sipa> Guest94804: you can only apply functions to values, not strings or integers
18:51:55 <mike-burns> Guest94804: Can you explain in English so we stop being pedantic for a moment?
18:52:16 <sipa> Guest94804: what would "5 (n-1)" mean?
18:52:21 <Guest94804> essentially, i want to print the same letter a bunch of times
18:52:29 <Guest94804> how do i do that with map
18:52:33 * dmwit avoids doing "> 5 6" to prevent early confusion
18:52:41 <mike-burns> OK, excellent.
18:52:46 <sipa> Guest94804: map (const 'x') [1..n]
18:52:55 <Guest94804> whats const?
18:52:56 <geekosaur> why do you believe map is the correct way to do it?
18:53:01 <sipa> > map (const 'x') [1..5]
18:53:02 <lambdabot>   "xxxxx"
18:53:13 <dmwit> > replicate 5 'x'
18:53:14 <lambdabot>   "xxxxx"
18:53:19 <Guest94804> is there a better way
18:53:21 <tromp__> > "hello" >> "x"
18:53:21 <Guest94804> oooooh
18:53:22 <lambdabot>   "xxxxx"
18:53:23 <Guest94804> ok
18:53:27 <Guest94804> thank you!!!!
18:53:31 <mike-burns> tromp__: Hah.
18:54:09 <dmwit> Clearly, "xxxxx" is "hello" right-shifted "x" times.
18:54:19 <tromp__> > [1..5] >> "x"
18:54:20 <lambdabot>   "xxxxx"
18:54:50 <dmwit> > "xxxxx" -- shortest one yet!
18:54:51 <lambdabot>   "xxxxx"
18:56:44 <otters> > [1..]>>'x'
18:56:45 <lambdabot>   Couldn't match expected type `[b]'
18:56:45 <lambdabot>         against inferred type `GHC.Types...
18:56:48 <otters> > [1..]>>"x"
18:56:49 <ion> > 5 (n-1)
18:56:49 <lambdabot>   "xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx...
18:56:50 <lambdabot>   5
18:56:58 <otters> there we go
18:57:25 <mike-burns> :t n
18:57:26 <lambdabot> Expr
18:58:06 <ion> > 'x'<$[0..]  -- Not shorter, just another way to put it.
18:58:07 <lambdabot>   "xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx...
18:58:31 <dmwit> > 'x'.[0..]
18:58:32 <lambdabot>   Couldn't match expected type `a -> b'
18:58:32 <lambdabot>         against inferred type `GHC.Ty...
18:58:38 <dmwit> Oh, right.
18:58:39 <ion> > const 'x'.[0..]
18:58:41 <lambdabot>   "xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx...
18:58:42 <dmwit> yeah
18:59:05 <dmwit> > ['x','x'..]
18:59:06 <lambdabot>   "xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx...
18:59:27 <mike-burns> @hoogle Int -> Char -> String
18:59:27 <lambdabot> Test.QuickCheck.Text number :: Int -> String -> String
18:59:27 <lambdabot> Test.QuickCheck.Text short :: Int -> String -> String
18:59:27 <lambdabot> Prelude replicate :: Int -> a -> [a]
18:59:33 <mike-burns> I suppose `replicate' is it.
19:01:24 <dmwit> :t let foo m = liftM2 (:) m (foo m) in foo
19:01:24 <lambdabot> forall (m :: * -> *) a1. (Monad m) => m a1 -> m [a1]
19:01:33 <ion> > fix('x':)
19:01:34 <lambdabot>   "xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx...
19:02:01 <thlorenz> actually, I celebrated too soon, Storable is not derivable
19:02:21 <dmwit> > let foo m = liftM2 (:) m (foo m) in evalState (foo get) 'x'
19:02:22 <lambdabot>   "xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx...
19:05:06 <dmwit> ?hoogle Monad m => m a -> m [a]
19:05:06 <lambdabot> Control.Monad replicateM :: Monad m => Int -> m a -> m [a]
19:05:06 <lambdabot> Prelude sequence :: Monad m => [m a] -> m [a]
19:05:06 <lambdabot> Control.Monad sequence :: Monad m => [m a] -> m [a]
19:05:22 <dmwit> :t sequence . repeat
19:05:23 <lambdabot> forall (m :: * -> *) a. (Monad m) => m a -> m [a]
19:08:42 <DanBurton> @quote
19:08:42 <lambdabot> Plugin `quote' failed with: getRandItem: empty list
19:08:46 <DanBurton> wat
19:08:57 <tgeeky_> @quote quote
19:08:57 <lambdabot> Palmik says: Do not quote me, ever.
19:08:59 <gadtfly> So there is "fromJust", and there is "lefts" and "rights"... why not "fromLeft", etc.
19:09:07 <tgeeky_> @quote []
19:09:07 <lambdabot> Plugin `quote' failed with: regex failed: (ReturnCode 7,"Unmatched [ or [^")
19:09:13 <tgeeky_> giggles
19:09:59 <gadtfly> And what is the best practice to get a value out of an either: monad comprehensions? where?
19:10:02 <DanBurton> gadtfly: sexy has fromLeft
19:10:17 <DanBurton> although it's different
19:10:35 <gadtfly> Oh, sexy, that's not going to be hard to google.
19:10:44 <shachaf> gadtfly: fromJust is a bad idea.
19:10:45 <tgeeky_> @google sexyhaskell
19:10:45 <DanBurton> gadtfly: "get a value out of an either"?
19:10:47 <lambdabot> http://www.haskell.org/pipermail/haskell-cafe/2009-April/060166.html
19:10:48 <lambdabot> Title: [Haskell-cafe] [ANN] Hack: a sexy Haskell Webserver Interface ^^
19:10:57 <DanBurton> gadtfly: pattern matching is the simplest way
19:11:02 <tibbe> Here's a seemingly simple question I don't know the answer to: how does one define an efficient foldl' for a rose tree?
19:11:05 <gadtfly> Why is fromJust a bad idea, when fromMaybe and lefts are not?
19:11:05 <DanBurton> @google dan burton sexy haskell
19:11:11 <lambdabot> https://github.com/DanBurton
19:11:13 <DanBurton> yay!
19:11:59 <shachaf> It's a pet project, not something actually usable/standard.
19:12:05 <shachaf> Well, I have no idea if it's usable.
19:12:12 <DanBurton> it's not intended to be usable at this point
19:12:27 <DanBurton> hopefully it will be somewhat usable sometime soon
19:12:31 <shachaf> My point is that it's not a recommendation for "what you should actually do".
19:12:40 <BMeph> gadtfly: Think - "What's a disadvantage of 'head'?"
19:12:54 <DanBurton> https://github.com/DanBurton/sexy/blob/master/src/Sexy/Data/Either.hs
19:13:09 <shachaf> gadtfly: Even let Just x = ... in ... is much better than ... (fromJust ...)
19:13:14 <shachaf> You should pretty much never use fromJust.
19:13:34 <DanBurton> unless it's sexy fromJust ;) but you probably shouldn't use that either
19:13:36 <shachaf> gadtfly: fromMaybe isn't a bad idea because it's total.
19:14:54 <gadtfly> fromMaybe Nothing
19:14:57 <gadtfly> ...?
19:15:10 <gadtfly> err.. fromJust
19:15:24 <DanBurton> > fromJust Nothing
19:15:25 <lambdabot>   *Exception: Maybe.fromJust: Nothing
19:15:43 <gadtfly> So... total?  I'm not seeing the difference
19:15:51 <DanBurton> @type fromMaybe
19:15:52 <lambdabot> forall a. a -> Maybe a -> a
19:15:58 <DanBurton> > fromMaybe 3 Nothing
19:15:59 <lambdabot>   3
19:16:07 <DanBurton> > fromMaybe 3 (Just 4)
19:16:07 <lambdabot>   4
19:16:22 <DanBurton> with fromMaybe you can provide a "default" in case it's Nothing
19:16:38 <DanBurton> fromJust just throws an exception
19:16:40 <gadtfly> Okay, but from Just is still there
19:16:52 <liyang> > length "fromMaybe a" > length "maybe a id"
19:16:53 <gadtfly> It just seems inconsistent
19:16:53 <lambdabot>   True
19:16:59 <DanBurton> exceptions in pure code are looked down upon in Haskell
19:16:59 <dibblego> fromMaybe Nothing is better written: join
19:17:36 <liyang> "fromMaybe a" is better written "maybe a id" :)
19:17:59 <DanBurton> @type (>) `on` length
19:18:00 <lambdabot> forall a. [a] -> [a] -> Bool
19:18:28 <DanBurton> > on (>) length "foo" "bar baz"
19:18:28 <lambdabot>   False
19:18:56 <dibblego> > on (>) length [1,2,3] [1..]
19:19:00 <lambdabot>   mueval-core: Time limit exceeded
19:19:28 <DanBurton> what, lambdabot can't determine the length of [1..]? For shame!
19:19:58 <gadtfly> Okay, so I have a Parsec result in an Either.  I don't care to catch if it fails.  Should I just write "fromJust" for myself, or is there something idiomatic I'm missing?
19:20:00 <dmwit> > on (>) (genericLength :: [a] -> Natural) [1,2,3] [1..]
19:20:01 <lambdabot>   Not in scope: type constructor or class `Natural'
19:20:11 <dibblego> no, but it can determine if the length of [1,2,3] is greater than [1..]
19:20:13 <gadtfly> err... fromLeft
19:20:26 <DanBurton> gadtfly: Left means error though, doesn't it?
19:20:38 <gadtfly> Right, sorry
19:20:39 <dibblego> length is non-total (aren't we discussing these functions at the moment??)
19:20:59 <DanBurton> @hoogle Either a b -> b
19:20:59 <lambdabot> Data.Either rights :: [Either a b] -> [b]
19:20:59 <lambdabot> Data.Typeable typeOf2 :: Typeable2 t => t a b -> TypeRep
19:20:59 <lambdabot> Prelude either :: (a -> c) -> (b -> c) -> Either a b -> c
19:21:13 <dibblego> s/->/PartialLens
19:21:18 <dmwit> gadtfly: Stop being lazy and deal with errors.
19:21:25 <dmwit> It's not that hard, just stop whining about it and do it.
19:21:26 <DanBurton> someone hoogled that already didn't they?
19:21:37 <dibblego> @hoogle PartialLens (Either a b) b
19:21:37 <lambdabot> Warning: Unknown type PartialLens
19:21:37 <lambdabot> Control.Arrow (|||) :: ArrowChoice a => a b d -> a c d -> a (Either b c) d
19:21:51 <dmwit> You'll almost certainly thank yourself later.
19:21:53 <gadtfly> It's not production anything, just a script-like thing to scrape a web-page... okay
19:22:02 <DanBurton> gadtfly: just pattern match. case parseResult of Right x -> ...; Left err -> error err
19:22:02 <gadtfly> Thanks
19:22:29 <gadtfly> kk
19:24:10 <dmwit> uh-oh: "There are problems in package ghc-7.4.0.20111219"
19:24:14 <dmwit> I done broke it.
19:26:20 <mightybyte_> Anyone know why cabal-install 0.10.2 isn't working with -w ~/ghc-7.4 for me?
19:27:03 <dmwit> Aren't ghc's usually named with three version numbers?
19:27:16 <mightybyte_> That's a directory name.
19:27:17 <dmwit> Is there really an executable named ghc-7.4 in ~?
19:27:18 <geekosaur> doesn't 7.4 require a newer version (you need to get it from the repo, it's not released yet that I've seen(?
19:27:32 <dmwit> mightybyte_: You give the compiler name, not the directory the compiler is in.
19:27:49 <mightybyte_> Ohhhhh, oops.
19:27:51 <mightybyte_> Thanks
19:28:38 <mightybyte_> The docs say "--with-compiler=PATH"
19:28:55 <geekosaur> and that tells you to use a directory how exactly?
19:29:34 <dmwit> It is a bit confusing.
19:29:51 <dmwit> "path" is usually the term used when you're talking about directories
19:30:17 <dmwit> In conclusion, while it doesn't explicitly say directory, it also doesn't explicitly say file.
19:30:29 <mightybyte_> Yeah
19:30:32 <shachaf> dmwit: PATH is the thing you use when you're talking about files.
19:30:47 <shachaf> As in FilePath.
19:31:12 <mightybyte_> I thought I had used -w with a directory at one time in the past though.
19:32:09 <dmwit> shachaf: And pray tell, what is in, e.g., $PATH?
19:32:28 <shachaf> $PATH is very different from a path.
19:32:37 * dmwit shrugs
19:32:40 <shachaf> On the other hand this is a completely pointless discussion.
19:32:42 <geekosaur> if you're going to play that card then I conclude PATH must be a *list* of directories....
19:32:47 <dmwit> No doubt you have never made any mistakes in the past.
19:32:50 <shachaf> The GHC error could surely be improved.
19:33:09 <shachaf> Huh?
19:33:14 <mightybyte_> So does -w only work with ghc's installed in specific places?
19:33:16 <dmwit> geekosaur: ~/ghc-7.4 is a list of directories, too.
19:33:21 * shachaf was with the confused here.
19:33:39 <dmwit> mightybyte_: No; it will search $PATH as usual.
19:33:49 <mightybyte_> Ahhh, I see.
19:35:24 <edwardk> @hpaste
19:35:25 <lambdabot> Haskell pastebin: http://hpaste.org/
19:36:00 <hpaste> edwardk pasted ‚Äúbayesian model api sketch‚Äù at http://hpaste.org/64522
19:36:18 <edwardk> fiddling with an API for bayesian models that looks something like that
19:38:49 <edwardk> http://www.mrc-bsu.cam.ac.uk/bugs/documentation/exampVol1/node3.html is the raw model
19:42:15 <shergill> edwardk: are you working on a bayesian inference library?
19:43:44 <edwardk> shergill: well, i've been playing with a combinator library for metropolis-hastings algorithms, and i'm seeing if i can stack a bugs model toolchain on top
19:45:57 <shergill> edwardk: by any chance does it implement don's generative code specialization technique?
19:46:51 <edwardk> shergill: not exactly. what i'm looking at is eventually just generating llvm evaluation kernels on the fly
19:47:00 <edwardk> for right now i'm just focused on getting it to execute correctly
19:47:22 <shergill> heh, a decent aim
19:47:45 <edwardk> i mostly just wanted it as a proof of concept
19:47:59 <edwardk> and to show some techniques to folks at the office
19:48:28 <edwardk> (i do a lot of related MH stuff using metropolis light transport)
19:48:53 <shergill> office being work place or gradschool research group?
19:49:09 <edwardk> and i figured it'd be nice to boil down some of the crazy stuff i do on the gpu into haskell where it can be more readily understood
19:49:10 <edwardk> work place
19:50:55 <edwardk> also, implementing it in haskell is forcing me to try to find the most general formulation of lots of stuff i use for very particular cases ;)
19:51:08 <tazjin> does cabal have an option to install just the dependencies of a package?
19:51:27 <shergill> gpu coding is ugly. hats off to you
19:51:35 <JoeyA> --only-dependencies
19:51:41 <tazjin> ty
19:52:08 <shergill> tazjin: you may want to look at cabal [command] --help as well
19:52:24 <JoeyA> tazjin: This might also be helpful: you can install multiple non-Hackage packages by naming directories: cabal install ./package1 ./package2
19:55:50 <ion> monochrom: Oh, man. Your ‚ÄúcallCC (return . fix)‚Äù turns my brain inside out. http://www.vex.net/~trebla/haskell/cont-monad.xhtml
19:59:00 <yezariaely> when running cabal-dev install for an executable package it says. Warning: No documentation was generated as this package does not contain a
19:59:03 <yezariaely> library. Perhaps you want to use the --executables flag.
19:59:10 <yezariaely> how can I get rid of this message?
19:59:29 <ion> >/dev/null 2>&1
19:59:59 <yezariaely> ion: sure, but there is a lot of other stuff, I want to see ^^
20:00:48 <applicative> the --executables flag doesn't help, yezariaely
20:00:53 <applicative> ?
20:01:48 <yezariaely> applicative: when I apply it to cabal-dev it says unknown flag. It shold be applied to haddock, but I do not know how because this is could internally by cabal-dev
20:01:58 <applicative> oh of course yes
20:02:18 <yezariaely> argh what am I writing... could=called
20:02:33 <dmwit> I think you should file a feature request for cabal. =)
20:02:44 <qu1j0t3> hello chan. any builds for powerpc on OS X 10.5?
20:03:00 <yezariaely> dmwit: :/
20:03:47 <applicative> hm if i do cabal-dev on pony, it doesn't worry it just puts the executable in /cabal-dev//bin
20:04:12 <yezariaely> dmwit: http://hackage.haskell.org/trac/hackage/ticket/517
20:04:17 <yezariaely> already there
20:05:31 <applicative> funny haddock doesn't have a 'please go away haddock' option
20:06:29 <yezariaely> applicative: you can do a cabal install --disable-documentation. Then the error message is of course gone
20:09:52 <yin> Do we still have lambdabot?
20:10:09 <yezariaely> > hello
20:10:10 <lambdabot>   Not in scope: `hello'
20:10:11 <tikhonjelvis> > 1 + 2
20:10:11 <ion> > runCont (evalStateT (do goto10 <- callCC (return . fix); modify (+ 20); a <- get; if (a < 42) then goto10 else return a) 0) id  -- ‡≤†_‡≤†
20:10:12 <lambdabot>   3
20:10:12 <lambdabot>   can't find file: L.hs
20:10:19 <ion> > runCont (evalStateT (do goto10 <- callCC (return . fix); modify (+ 20); a <- get; if (a < 42) then goto10 else return a) 0) id  -- ‡≤†_‡≤†
20:10:19 <yezariaely> lol
20:10:20 <lambdabot>   60
20:10:23 <yin> > heh. how are you
20:10:24 <lambdabot>   can't find file: L.hs
20:10:39 <yin> > gen :: [forall a.a->a]
20:10:40 <lambdabot>   Not in scope: `gen'
20:10:50 <yin> uhh...
20:11:03 <yin> Here is the question...
20:11:11 <yezariaely> *drumroll*
20:11:20 <yin> gen :: [forall a.a->a]
20:11:26 <yin> gen =[id]
20:11:56 <yin> Why doesn't (head gen 1) work?
20:12:23 <yin> Can't I apply forall a.a->a to Int?
20:12:37 <dmwit> > let gen = [id] in head gen 1
20:12:38 <lambdabot>   1
20:12:40 <dmwit> works for me
20:12:51 <yin> dmwit: put the annotation first
20:13:09 <yin> dmwit: gen = [id] alone will give you the type forall a.[a->a]
20:13:11 <mauke> > let gen :: [forall a.a->a]; gen = [id] in head gen 1
20:13:12 <lambdabot>   1
20:13:18 <dmwit> > let gen :: [forall a. a]; gen = [id] in head gen 1
20:13:19 <lambdabot>   Couldn't match expected type `a1' against inferred type `a -> a'
20:13:19 <lambdabot>    `a1' is...
20:13:26 <dmwit> > let gen :: [forall a. a -> a]; gen = [id] in head gen 1
20:13:27 <lambdabot>   1
20:13:30 <dmwit> still WFM
20:14:27 <yin> strange...
20:14:54 <yin> doesn't work for me here
20:16:38 <yin>     Couldn't match expected type `t1 -> t0'
20:16:38 <yin>                 with actual type `forall a. a -> a'
20:16:38 <yin>     Expected type: [t1 -> t0]
20:16:38 <yin>       Actual type: [forall a. a -> a]
20:17:39 <yin> should I turn on some switches? ghci doesn't tell me
20:18:45 <yin> > let gen :: [forall a. a -> a]; gen = [id] in head gen 1
20:18:45 <dmwit> ghc --version?
20:18:45 <lambdabot>   1
20:19:04 <yin> 7.0.2
20:20:28 <dmwit> Huh, yeah, that's weird.
20:20:51 <dmwit> I can reproduce that error in 7.0.4, 7.2.2, and 7.4.1
20:21:22 <dmwit> I wonder what extensions lambdabot has got turned on.
20:21:46 <yin> yep. I guess it has different settings
20:22:05 <ion> Also, lambdabot runs GHC 6.x AFAIU.
20:22:06 <applicative> I get an impredicative types error
20:22:26 <dmwit> applicative: Yeah, but with -XImpredicativeTypes
20:22:41 <applicative> we were to do that
20:22:49 <applicative> i thought it didn't do anything any more
20:22:52 <dmwit> Oh, I don't have a 6.x install lying around to test on.
20:22:53 <zachk> after doing ghci -XRankNTypes -XImpredicativeTypes
20:23:09 <zachk> I reproduced the error as well
20:23:37 <dmwit> I wouldn't be at all surprised if the behavior of IT changed between 6.x and 7.x.
20:24:08 <ion> Works in 6.12.3
20:24:33 <mauke> ok, so ghc thinks "forall a. a -> a" is not a function type
20:24:39 <mauke> takes 0 args
20:25:07 <yin> you mean it is parsed as (forall a.a) -> a? or ...?
20:25:11 <ion> It‚Äôs interesting that it still prints:
20:25:13 <ion> Œª> :t let xs :: [forall a. a -> a]; xs = [id] in Prelude.head xs
20:25:15 <ion>   :: a -> a
20:26:03 <yin> oh no. it doesn't work even if I put on parens
20:26:47 <dmwit> mauke: Is that... what?
20:27:09 <mauke> dmwit: I don't know
20:27:10 <dmwit> How did you conclude that, and what does that mean? GHC bug?
20:27:25 <mauke> dmwit: "The first argument of ($) takes one argument, but its type `forall a. a -> a' has none"
20:27:33 <ion> GHC 6.12.3:     Warning: -XImpredicativeTypes is deprecated: impredicative polymorphism will be simplified or removed in GHC 6.14
20:27:58 <shachaf> Couldn't match expected type `t0 -> t1' with actual type `forall a. a -> a'
20:28:04 <ion> It seems to print that in addition to working.
20:28:13 <shachaf> I think this might be related to that other GHC bug we were talking about a while ago.
20:29:02 <shachaf> Œª> (head xs) 1 -- error
20:29:16 <shachaf> Œª> (let y = head xs in y) 1 -- works
20:29:27 <applicative> this is the new type checker in 7.+  It works fine if you wrap forall a . a -> a which is what you're supposed to do, if I understand
20:30:41 <yin> shachaf: feels like value restriction ;-)
20:31:07 <shachaf> This is certainly a bug, though.
20:32:52 <hpaste> applicative pasted ‚Äúnonimpredicative‚Äù at http://hpaste.org/64523
20:35:25 <yin> applicative: This one works but... It looks like you know why the original one doesn't work?
20:36:05 <applicative> it went out with the new typechecker, I cant say I understand it properly.  Lennart A. has complained loudly
20:36:27 <applicative> http://augustss.blogspot.com/2011/07/impredicative-polymorphism-use-case-in.html
20:36:39 <shachaf> preflex: seen augustss
20:36:39 <preflex>  augustss was last seen on #haskell 112 days, 4 hours, 4 minutes and 31 seconds ago, saying: > div (-1) 2
20:36:44 <applicative> though ions warning says it would go with ghc-6.14
20:37:05 <applicative> please come back augustss
20:40:58 <shachaf> "I can't really explain the rational behind the change in the ghc type system (Simon say it's simpler now)"
20:41:03 <shachaf> I like that parenthesized remark.
20:41:15 <shachaf> It's obviously missing an s, but I'm not sure whether it's in the first or second word.
20:43:29 <dolio> Second.
20:43:31 <yin> a related question: Why does [id] alone has type forall a.[a->a] instead of [forall a.a->a] ?
20:43:53 <yin> >:t [id]
20:44:04 <yin> > [id]
20:44:05 <lambdabot>   Overlapping instances for GHC.Show.Show (a -> a)
20:44:06 <lambdabot>    arising from a use of `...
20:44:14 <yin> > :t [id]
20:44:15 <lambdabot>   <no location info>: parse error on input `:'
20:44:31 <yin> not familar with lambdabot commands
20:44:37 <shachaf> yin: Are you asking why that's a valid type for it or why GHC infers it?
20:44:39 <dmwit> yin: By default, HM type inference will infer type schemas with all foralls at the top-level.
20:44:56 <c_wraith> yin: because [forall a. a -> a] is an impredicative type, which ghc cannot infer
20:45:20 <yin> I see. Is there a good reason it doesn't infer it?
20:45:30 <dolio> Most schemes for having higher-rank types with inference are designed to infer the Hindley-Milner type in the absense of annotations.
20:45:33 <c_wraith> inference of impredicative types is undecidable
20:45:59 <shachaf> Most Schemes are dynamically typed.
20:46:01 <yin> for this case alone seems to be inferrable
20:46:39 <dmwit> yin: HM type inference is pretty efficient, as far as these things go. That's why Haskell went with it.
20:46:51 <dolio> Well, it isn't.
20:47:17 <dmwit> You can imagine ways of doing inference for more exciting types, but these ways are often inefficient (or undecidable).
20:47:19 <dolio> It's double exponential, but no one writes programs that cause that behavior.
20:47:31 <dmwit> dolio: "as far as these things go"
20:47:34 <c_wraith> :t id id id id id id
20:47:35 <lambdabot> forall a. a -> a
20:48:07 <yin> I mean ... there seems to be a good reason for it? Because otherwise you can't write things like (+1) : [id] ?
20:48:08 <geekosaur> yin, determining which cases it could infer is itself not decidable
20:48:24 <dolio> It's better than being double exponential plus doing non-deterministic search on top.
20:48:44 <quintessence> yin: you can write that
20:49:01 <yin> The undecidable part is polymorphic types. But now we know the type of id is forall a.a->a, then [id] can be inferred as [forall a.a->a]
20:49:04 <shachaf> doubleplusexponential
20:49:33 <yin> quintessence: I mean if the type of [id] is [forall a.a->a], then we cannot write (+1) : [id]
20:50:13 <yin> I'm just wondering whether this is a feature or a drawback -- inferring the type of [id] as forall a.[a->a]
20:52:11 <dolio> The feature is: existing programs will have identical types to what they had without the type system extension.
20:52:35 <dolio> Inferring as [forall a. a -> a] may well break existing programs.
20:52:54 <yin> dolio: so you think (+1) : [id] should not work?
20:53:13 <Kaidelong> > (+1) : [id]
20:53:14 <lambdabot>   Overlapping instances for GHC.Show.Show (a -> a)
20:53:14 <lambdabot>    arising from a use of `...
20:53:15 <dolio> That does work.
20:53:20 <Kaidelong> @ty (+1) : [id]
20:53:21 <lambdabot> forall a. (Num a) => [a -> a]
20:53:44 <Kaidelong> yin: (
20:54:01 <Kaidelong> (Num a) => a -> a and a -> a match in a sense
20:54:15 <Kaidelong> the latter can be specialized to the former
20:54:24 <yin> dolio: I confused you. I mean... if the type of [id] is inferred as [forall a.a->a] then (+1):[id] will stop to work
20:54:49 <yin> > let lid = [id] in (+1):lid
20:54:49 <dolio> Why would it stop working?
20:54:50 <lambdabot>   Overlapping instances for GHC.Show.Show (a -> a)
20:54:50 <lambdabot>    arising from a use of `...
20:54:58 <yin> :t let lid = [id] in (+1):lid
20:54:59 <lambdabot> forall a. (Num a) => [a -> a]
20:55:14 <yin> :t let lid :: [forall a.a->a]; lid = [id] in (+1):lid
20:55:15 <lambdabot>     Illegal polymorphic or qualified type: forall a. a -> a
20:55:15 <lambdabot>     Perhaps you intended to use -XImpredicativeTypes
20:55:15 <lambdabot>     In the type signature for `lid': lid :: [forall a. a -> a]
20:55:39 <yin> :set -XImpredicativeTypes
20:55:45 <dolio> Well, yes, that's poor behavior.
20:56:24 <dolio> It could notice that the result has type [forall a. Num a => a -> a].
20:56:53 <yin> So it looks like inferring the type of [id] as forall a.[a->a] even has some advantages?
20:57:25 <dolio> Yes.
20:57:50 * hackagebot clientsession 0.7.4.1 - Securely store session data in a client-side cookie.  http://hackage.haskell.org/package/clientsession-0.7.4.1 (MichaelSnoyman)
20:58:17 <dolio> There is a system called MLF that can give [id] the type forall (b > forall a. a -> a). [b]
20:58:33 <dolio> Which subsumes both forall a. [a -> a] and [forall a. a -> a]
20:58:47 <dolio> But it requires those fancier quantifiers.
20:59:23 <yin> So it is not undecidable
20:59:25 <dolio> Then (+1) : [id] :: forall (b > forall a. Num a => a -> a). [b]
20:59:42 <dolio> It still requires annotations, I think.
20:59:53 <dolio> But it has principal types.
21:00:32 <yin> It only needs annotations for parameters used polymorphically. like \f -> (f 1, f True)
21:01:04 <dolio> Yes, I think that's right.
21:01:32 <yin> cool. so it looks like not much is undecidable :-)
21:02:06 <dolio> Well, you have to commit yourself to a fancier type system than usual.
21:02:37 <Kaidelong> well so long as you're able to at least partially infer most of the types
21:02:53 <yin> yep. The implementor has to read a 320-page dissertation
21:03:50 <dolio> I mean, it also means you can't just write [a -> a].
21:04:07 <dolio> You must write: forall (b > forall a. a -> a). [b]
21:04:34 <dolio> Unless you develop some conventions.
21:04:57 <Kaidelong> can forall (b > forall a. a -> a). [b] be inferred?
21:05:04 <dolio> I think so.
21:05:30 <dolio> It's not even great to look at, though.
21:05:32 <yin> uhh.. that's bad syntax. Maybe there can be better ones
21:05:36 <dolio> For :t [id]
21:05:56 <dolio> You won't be making n00bs feel at ease. :)
21:06:52 <Kaidelong> so what exactly does that type mean?
21:07:03 <Kaidelong> arbitrary supersets of a -> a?
21:07:36 <yin> subsets, I think
21:07:50 * hackagebot stm-conduit 0.2.3.1 - Introduces conduits to channels, and promotes using  conduits concurrently.  http://hackage.haskell.org/package/stm-conduit-0.2.3.1 (ClarkGaebel)
21:07:52 * hackagebot authenticate 1.0.0.1 - Authentication methods for Haskell web applications.  http://hackage.haskell.org/package/authenticate-1.0.0.1 (MichaelSnoyman)
21:07:53 <dolio> It means that you have a variable b that can be instantiated to any type that is forall a. a -> a or an instantiation thereof.
21:07:53 <yin> bad syntax :-)
21:08:13 <dibblego> @hoogle lookupBy
21:08:13 <lambdabot> No results found
21:08:43 <dolio> So, you get [forall a. a -> a] by choosing to instantiate b with forall a. a -> a.
21:08:55 <yin> I mean the greater than sign... but that's true forall a.a->a is a subtype of Int->Int. So forall a.a->a  <  Int->Int ...
21:10:01 <Kaidelong> I wonder if this has anything to do with that trippy #> thing F# does in some type annotations
21:10:11 <Kaidelong> and why the F# people seem to prefer not to write type annotations down
21:10:36 <dolio> And you get forall c. [c -> c] quantifying a new variable c and instantiating b to c -> c, which can be done because it's an instantiation with a = c.
21:10:56 <yin> Kaidelong: maybe because their editor can do it for them?
21:11:45 <Kaidelong> yin: they just prefer letting type inference find the most generic thing possible and add annotations only when a type can't be inferred
21:11:58 <Kaidelong> or with some things like interfaces where there is no implementation to infer a type from
21:12:53 <yin> Kaidelong: second guess, because they are just escaped from Java, so they want to enjoy their freedom for sometime
21:17:51 <Kaidelong> yin: C# people also prefer using inference rather than writing types down explicitly
21:18:00 <Kaidelong> it could just be because the type system makes writing down types ugly
21:19:49 <sebz> do people generally write `f $ g $ h $ x' or `f . g . h $ x' or something else?
21:19:52 <gnuvince_> Is there a config file for ghci where I can permanently set the prompt?
21:19:58 <dibblego> does it bother anyone else that Maybe's Monoid is not the same as its MonadPlus?
21:20:06 <dibblego> gnuvince_: ~/.ghci
21:20:16 <dibblego> sebz: the latter is definitely preferred
21:20:32 <sebz> k, thanks
21:22:23 <gnuvince_> ddarius: thank you
21:28:08 <dmwit> hand-tuned search algorithm, after eight hours: 46 discoveries at a cost of 32 resources
21:28:27 <dmwit> random search, after ten minutes: 52 discoveries at a cost of 34 resources
21:28:31 <dmwit> random > smart
21:29:40 <nanothief> what was that for?
21:30:11 <quintessence> representing priors as code is hard even when you have a good prior in your head
21:30:31 <dmwit> nanothief: Skyrim alchemy: finding potions to make that will reveal new properties of ingredients.
21:31:11 <dolio> Obviously the hand-tuned search was tuned to be dumb. :)
21:31:18 <dolio> Otherwise it would have beaten the random search. :)
21:31:24 <dmwit> dolio: Not surprising, given the hand that tuned it. =P
21:31:46 <nanothief> oh, or maybe haskell has an uber random number generator
21:32:32 <Enigmagic> one that randomly generates really good values?
21:33:02 <dmwit> randomIO = unsafeCoerce -- MAGIC
21:35:22 <shergill> heh
21:35:58 <quintessence> awesomeSearch :: Ord a => (forall m. MonadRandom m => m a) -> a
21:37:11 <dmwit> I wonder if there's a good place for "improving :: Ord b => (a -> b) -> [a] -> [a]" on Hackage.
21:38:08 <dmwit> (It consumes a lazy list of a's, and produces a subsequence whose corresponding b's are increasing.)
21:40:58 <NOTtheMessiah> Any obvious way to do anything like "map print [a] <= (Show a)" (print every element in a list in a new line)?
21:40:59 <dolio> How does it choose?
21:41:21 <dolio> mapM_
21:41:38 <Cale> NOTtheMessiah: mapM_ print xs
21:41:50 <quintessence> dmwit: either that or whileSuccessive :: (a -> a -> Bool) -> [a] -> [a] should be somewhere
21:41:50 <NOTtheMessiah> okay, that makes sense
21:41:54 <NOTtheMessiah> thanks
21:42:22 <dmwit> dolio: Was that aimed at me?
21:42:28 <dolio> dmwit: Yeah.
21:42:39 <dmwit> It's greedy.
21:42:40 <dolio> Does it keep picking the best bs it sees?
21:42:42 <dolio> Okay.
21:43:12 <dolio> I mean, I could imagine by skipping some it could find longer subsequences if that's what you're after.
21:43:13 <quintessence> dmwit: oh, never mind, you meant something different.
21:43:29 <dolio> But maybe it isn't.
21:43:34 <dmwit> dolio: Oh, yeah, but we're optimizing the metric argument, not the subsequence length.
21:43:36 <Enigmagic> dolio: i think he's not looking at subsequences, just increasing values
21:44:04 <Enigmagic> i wouldn't find it particularly useful though
21:44:06 <dmwit> dolio: use case: produce a (possibly infinite) list of candidate values, and print the best one you've seen so far as you consider each one
21:45:02 <dmwit> You want long subsequences, you produce a list of all possible subsequences and call "improving length". =)
21:45:14 <dolio> :)
21:46:09 <Enigmagic> dmwit: how do you provide feedback into the optimizer?
21:46:25 <Enigmagic> unless you're really building a random function generator
21:46:31 <dmwit> I don't. random > smart, remember?
21:46:57 <Enigmagic> ah yes
21:47:07 <dmwit> (You could, though. It's just a matter of producing that feedback as you produce the [a].)
21:49:06 <Enigmagic> how would that work when no better solutions are found for an iteration?
21:49:54 <dmwit> "improving" is decoupled from the search algorithm.
21:50:10 <dmwit> Search in any way you want, and hand me a list of your best candidates.
21:50:18 <dmwit> I'll prune out the ones that temporarily got worse.
21:52:11 <Enigmagic> that'll provide a list of improving candidate solutions
21:52:13 <dmwit> For example, your search could: enumerate all possible values naively, choose random values, do simulated annealing, run a genetic algorithm, use alpha-beta search over a game tree, whatever. I don't care.
21:52:42 <Enigmagic> not the best
21:52:48 <dmwit> As long as you can produce a list of candidates (with some level of laziness), I will help you print the best ones as you find them.
21:53:14 <dmwit> Enigmagic: Yes, not the best. My use case is when the search takes a very long time, but you want some feedback about what the search is "thinking about" just now.
21:53:27 <dmwit> So it will show you the best thing it's come up with *so far*.
21:53:43 <dmwit> last (improving metric search) will give you the best thing possible, if your search is finite.
21:54:02 <dmwit> But that might take a long time, and in the meantime you might decide you're okay with a solution that is pretty good but not the best.
21:54:05 <edwardk> in game trees thats why I have always liked MTD(f) with iterative deepening
21:54:18 <edwardk> what is the problem domain?
21:54:42 <dmwit> edwardk: What ingredients I should mix in Skyrim to learn the most new effects when doing alchemy.
21:54:52 <edwardk> hah
21:54:56 <dmwit> Very useful to humanity. =)
21:55:36 <Enigmagic> :)
21:56:25 <edwardk> meh, the real pain is getting the list of ingredients you have out without a lot of tedium ;)
21:56:55 <edwardk> and do you really need any effects other than the improve restoration potion? =)
21:57:34 <dmwit> Yes, that is definitely the real pain.
21:57:41 <edwardk> with that and 5 minutes in the sewers you can punch for millions of damage
21:57:55 <edwardk> who needs anything else? =)
21:58:06 <dmwit> the sewers?
21:58:13 <edwardk> (and can armor yourself beyond the protection cap)
21:58:21 <edwardk> #haskell-blah ;)
21:59:12 <dolio> dmwit: Obviously you need smart _and_ random, for the best of both worlds.
21:59:17 <dolio> Ed's been going on about that at work.
21:59:32 <dolio> Using randomness to get smarter and whatnot.
22:01:46 <Enigmagic> dolio: a mix of both is nice
22:07:53 <sajith> people, how do I make a 'Ptr CLong' out of '[Int]'?
22:08:07 <otters> haha clong
22:09:40 <rwbarton> map fromIntegral + newArray/withArray
22:16:19 <nyingen> @quote
22:16:19 <lambdabot> wto says: I heard you like Haskell, so I put a lazy thunk inside a lazy thunk, so you don't have to compute while you compute!
22:17:01 <learner420> ahh i love these interactive terminals
22:17:09 <otters> @quote
22:17:09 <lambdabot> mrd says: interesting things happen when you enable -fmagic!
22:30:18 <subhashpant> :t map
22:30:19 <lambdabot> forall a b. (a -> b) -> [a] -> [b]
22:30:56 <hpaste> NOTtheMessiah pasted ‚ÄúMetropolis-Hastings Algorithm on the 1-D Ising model‚Äù at http://hpaste.org/64529
22:32:24 <NOTtheMessiah> okay, made my first haskell program, thoughts, criticism?
22:33:04 <NOTtheMessiah> a little bit of warning, it does basic computational statistical mechanics
22:33:13 <dolio> Using StdGen, eh?
22:33:16 <dmwit> The title of your paste uses the correct amount of technical terms for a Haskell program.
22:34:17 <dolio> swap is a little suspicious.
22:34:50 <NOTtheMessiah> ya, it could create problems if fed the wrong parameters
22:35:06 <dolio> I mean that lists are not the right data structure.
22:35:10 <dibblego> NOTtheMessiah: run hlint on it -- I can see some improvements that it would suggest
22:35:24 <dmwit> NOTtheMessiah: Perhaps you would like MonadRandom.
22:35:24 <dolio> If you're modifying random elements in the middle of them.
22:35:35 <dmwit> ?hackage MonadRandom
22:35:35 <lambdabot> http://hackage.haskell.org/package/MonadRandom
22:35:54 <NOTtheMessiah> ooh
22:36:54 <dmwit> As a convention, functions that are slightly stricter versions of other functions are typically named with a prime, so I would suggest iterate' rather than itereag.
22:37:53 <dmwit> What initSpin does with its StdGen looks plain wrong.
22:37:53 * hackagebot composition 1.0.0.1 - Combinators for unorthodox function composition  http://hackage.haskell.org/package/composition-1.0.0.1 (DanBurton)
22:37:56 * hackagebot lzma-conduit 0.1.2 - Conduit interface for lzma/xz compression.  http://hackage.haskell.org/package/lzma-conduit-0.1.2 (NathanHowell)
22:39:05 <NOTtheMessiah> noted
22:42:54 * hackagebot git-annex 3.20120229 - manage files with git, without checking their contents into git  http://hackage.haskell.org/package/git-annex-3.20120229 (JoeyHess)
22:53:43 <NOTtheMessiah> dolio: what would one typically use other than StdGen? would one normally use monadic types or something like that?
22:54:21 <dolio> I wouldn't expect anything else unless you went looking, but StdGen is kind of slow.
22:54:35 <dolio> People have written better random generators that you can get from hackage.
22:55:30 <dolio> I think mwc-random is supposed to be pretty good.
22:56:16 <dolio> There's also a Mersenne twister implementation.
22:56:58 <NOTtheMessiah> gotchya
22:57:28 <ddarius> mwc-random is advertised as better than the mersenne-twister package in just about every way.
22:57:33 <Enigmagic> when i was testing it the mersenne-twister-pure64 was faster than the mwc-random, which seems a bit backwards
22:58:06 <dolio> Yeah, that'd be surprising.
22:58:27 <dolio> mwc-random was supposed to be faster than mersenne-random, and the pure mersenne one was slower than that.
22:58:31 <dolio> Or so I thought.
22:59:00 <Enigmagic> it wasn't exactly a microbenchmark or anything, just swapped them over in our simulator and it slowed down by 3-4% (it generates a lot of random numbers)
22:59:20 <Enigmagic> could have been something else, who knows
23:01:09 <dolio> Could be that GHC is no longer optimizing mwc-random as well as it once was.
23:02:51 <Enigmagic> dolio: or it could be fixed now, this was a while back
23:03:15 <Enigmagic> probably was circa mwc-random 0.7 or 0.8
23:03:54 <Enigmagic> though i haven't seen any benchmarks of the various haskell hashing implementations head to head
23:42:09 <ion> @hoogle ParsecT s u m a -> ParsecT s u m (a, String)
23:42:09 <lambdabot> No results found
23:42:58 <ion> Is there a nice way to get the consumed input string when a parser matches?
23:53:43 <eyu100> > unamb 1 1
23:53:44 <cbm80_> can basically all occurences of List replaced with Sequence (from Data.Sequence) ?
23:53:44 <lambdabot>   Not in scope: `unamb'
23:53:50 <eyu100> > Data.Unamb.unamb 1 1
23:53:50 <lambdabot>   Not in scope: `Data.Unamb.unamb'
23:53:57 <eyu100> > lub 1 1
23:53:58 <lambdabot>   Not in scope: `lub'
23:55:30 <shachaf> cbm80_: No.
23:55:38 <cbm80_> shachaf: why not?
23:55:54 <ChristianS> cbm80_: depends on your specific use case whether Data.Sequence.Seq makes more sense or not
23:56:16 <shachaf> cbm80_: For example, infinite lists.
23:56:33 <shachaf> As well as many other examples -- they're pretty different.
23:56:36 <cbm80_> shachaf: ok that's true. the lists i use are all ifinite.
23:56:42 <cbm80_> erm finite
23:57:26 <shachaf> Lists correpond to iteration in a way that Data.Sequence doesn't.
23:57:46 <shachaf> It completely depends on what you're doing with your lists.
23:57:48 <cbm80_> shachaf: but how, sequences are foldable, too
23:58:05 <shachaf> What?
23:58:30 <cbm80_> gimme a sec
23:59:33 <cbm80_> "Additional functions for deconstructing sequences are available via the Foldable instance of Seq." says the docs
