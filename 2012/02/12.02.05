00:00:30 <ClaudiusMaximus> cool, then i might just write boilerplate for the next while - want to specialize each class at 4 types...
00:01:14 <btvl> ddarius, Couldn't match type `a0' with `a' because type variable `a' would escape its scope
00:01:28 <btvl> but it is ok, unrolling it is still readable
00:01:41 <ddarius> Yeah, that makes sense, the type of funcs would then reveal the existentially hidden type.
00:02:31 <btvl> It would have been nice if they provided a built in utility function for this purpose
00:02:33 <tikhonjelvis> Is there any way to turn off warnings about partial functions only for lambda abstractions?
00:02:51 <btvl> although I believe 99% of people only care about the file being a regular file or a directory
00:03:08 <ddarius> I think it would might work if you provide funcs with an explicit type.
00:07:00 <btvl> also, if I do in a "do" block something like { a <- vDoesExist SystemFS fullname ; s <- vGetFileStatus SystemFS fullname ; case (a and (s == "file")) .. } case I be sure "s" will only be evaluated if "a" is true ?
00:07:15 <btvl> or do I have to nest cases ?
00:08:08 <btvl> (to do it properly I should just catch the exception because there is a possible race condition here)
00:09:20 <shergill> is there a way to print the source/implementation of a function/typeclass instance in ghci?
00:09:56 <ddarius> btvl: I think what you really want to know is whether vGetFileStatus will be executed.
00:10:03 <btvl> yes
00:10:06 <shergill> or alternatively, what would be the recommended way if, say, i wanted to look at the implementation of ZipList in Control.Applicative
00:10:21 <ddarius> In which case the answer is "yes."  Operations in a do-block get executed in the order they are written.
00:10:48 <ddarius> shergill: Go to the Haddock page on Haskell and click the Source link.
00:11:11 <btvl> ddarius, what about things like readFile ? It seems to be that it opens when executed, but reads in a lazy way
00:11:22 <btvl> I suppose this is a property of readFule
00:11:46 <shergill> ddarius: is there a way to do that locally as well?
00:12:03 <ddarius> shergill: You can build the Haddock locally, or you could just look at the source of the packages.
00:13:22 <shergill> ah k. i might just resort to looking at haddock. i'm guessing there isn't a commandline tool like hoogle which would do the trick, while still saving you the diskspace
00:13:34 <ddarius> Hoogle can be used from the commandline.
00:13:54 <shergill> but hoogle doesn't show the source
00:14:22 * hackagebot wai-handler-webkit 1.1.0 - Turn WAI applications into standalone GUIs using QtWebkit.  http://hackage.haskell.org/package/wai-handler-webkit-1.1.0 (MichaelSnoyman)
00:14:48 <shergill> but thanks for the help, ddarius
00:19:22 * hackagebot servius 0.0.2 - Serve Shakespearean templates via Warp  http://hackage.haskell.org/package/servius-0.0.2 (MichaelSnoyman)
00:21:57 <wavewave> lens must be taught in popular haskell book.
01:03:01 <dzhus> When you write an ebuild for standalone haskell app, do you wrap all its dependencies in Gentoo packages, too? Do we have something like g-cpan for Hackage?
01:03:12 <dzhus> sorry wrong channel
01:11:46 <bbear> hi
01:12:07 <bbear> Some gave me a fast paced tutorial for haskell.
01:12:14 <bbear> I cannot remember which it was.
01:12:45 <bbear> It was an online book like Lyahfgg
01:12:51 <bbear> But not this one, another one.
01:13:19 <bbear> http://book.realworldhaskell.org/read/ I found it
01:13:21 <bbear> thank you.
01:13:40 <k0ral> hi, I'm looking for a function similar to splitAt, but with type [a] -> [[a]]; I could easily implement it but I was wondering if there wasn't already something like this in base ?
01:13:46 <k0ral> @hoogle [a] -> [[a]]
01:13:47 <lambdabot> Data.List inits :: [a] -> [[a]]
01:13:47 <lambdabot> Data.List permutations :: [a] -> [[a]]
01:13:47 <lambdabot> Data.List subsequences :: [a] -> [[a]]
01:14:09 <k0ral> sorry, I meant with type Int -> [a] -> [[a]]
01:14:14 <k0ral> @hoogle Int -> [a] -> [[a]]
01:14:15 <lambdabot> Prelude drop :: Int -> [a] -> [a]
01:14:15 <lambdabot> Data.List drop :: Int -> [a] -> [a]
01:14:15 <lambdabot> Prelude take :: Int -> [a] -> [a]
01:14:18 <ClaudiusMaximus> @hackage split
01:14:18 <lambdabot> http://hackage.haskell.org/package/split
01:16:11 <k0ral> ClaudiusMaximus: thank you, although I would have expected such library to be included in base
01:28:13 <bbear> Hi.
01:28:23 <bbear> I have a short question about Haskell.
01:28:47 <bbear> Does haskell is portable ? I mean, can I compile program for multiple operating system in binary form (windows, linux, etc).
01:29:11 <bbear> Are the performance of haskell somehow similar to C as far as we go a little bit far in complexity ?
01:31:56 <tech2> bbear: it's as portable as any other "high level" language, so long as you avoid certain pitfalls (things like handling filesystem paths, byte orders if you're working at a low level, etc.), it's performance is very good, depends entirely on what you're doing and how you're doing it though :)
01:32:12 <donri> bbear: in the typical case haskell performs worse but not by much than C. on the other hand it is easier to parallellize on multicores.
01:33:06 <donri> FSVO typical and worse
01:33:21 <bbear> if you'd know about o
01:33:29 <bbear> caml, does it has the same performances ?
01:36:40 <bbear> could you compare the erlang performances to the haskell performances in a multi threaded environment.
01:37:17 <srhb> Probably not.
01:37:28 <bbear> Is it suited for soft real-time applications ?
01:37:40 <bbear> (as the erlang is)
01:39:09 <MostAwesomeDude> bbear: Languages aren't slow, algorithms are slow.
01:39:31 <daimrod> and implemtations can be slow.
01:39:38 <daimrod> implementations even.
01:39:47 <rostayob> MostAwesomeDude: well, erlang is good for multi-threaded, real time applications (messaging, thread-specific GC, etc etc)
01:39:53 <donri> ...but languages lend themselves more naturally to different algorithms. like, you can write quicksort in one line of haskell, but it'll really be merge sort IIRC?
01:40:19 <ClaudiusMaximus> woah, criterion tells me my double-double implementation is faster than using Double, something weird here?
01:40:20 <DanBurton> anyone familiar with the .ghci file? I am trying to use one, but when I do, I get this: *** WARNING: /home/dan/.ghci is writable by someone else, IGNORING!
01:40:21 <MostAwesomeDude> You can write that *exact same* line of quicksort in a bunch of other languages, too.
01:40:23 <arcatan> my understanding is that you can get approximately equal performance out of GHC and OCaml, and in the both cases the best performance means writing unidiomatic code
01:40:38 <rostayob> DanBurton: well the error is quite clear here
01:40:40 <srhb> DanBurton: So chmod oa+w .ghci
01:40:46 <srhb> Oh, -w
01:40:47 <srhb> not +w
01:41:03 <tech2> srhb: and not a
01:41:12 <srhb> tech2: gah, no.
01:41:16 <DanBurton> but...why does ghci care who has write permissions?
01:41:20 <srhb> DanBurton: chmod go-w .ghci
01:41:22 <rostayob> DanBurton: consider that you can put stuff like removeFile "whatever"
01:41:26 <rostayob> in ghci
01:41:35 <srhb> DanBurton: People could schedule scripts to be run with your privileges if they could write to that file
01:41:45 <rostayob> or yeah run programs
01:41:46 <bbear> « in the both cases the best performance means writing unidiomatic code » You mean generic code ?
01:41:50 <srhb> DanBurton: As in, next time you launch ghci, you're in trouble.
01:42:02 <ClaudiusMaximus> DanBurton: it's a security feature, but annoying on systems where each user has its own group - ghci doesn't know you're the only one in the group
01:42:37 <rostayob> better safe then sorry I guess
01:42:37 <arcatan> ClaudiusMaximus: maybe your implementation omits some checks/cornercases, or otherwise does something that just happens to suit your test?
01:43:05 <arcatan> bbear: I mean code that looks like C code
01:43:09 <DanBurton> that's rather irritating, so I have to chmod it again if I ever want to change it? >,<
01:43:22 <rostayob> DanBurton: ...no?
01:43:24 <tech2> DanBurton: no
01:43:28 <rostayob> you make it writable just by the owner - you
01:43:48 <bbear> arcatan, so horrible code lengthy :o has the best performance
01:44:06 <rostayob> DanBurton: chmod oa-w
01:44:15 <mauke> chmod 644
01:44:17 <srhb> DanBurton: If your editor sets g+w on write, you should switch editor. :-)
01:44:19 <shachaf> mauke++
01:44:26 <rostayob> DanBurton: and then chmod u+w if you need too...
01:44:46 <shachaf> All this x±y nonsense is only making things more complicated.
01:45:03 <DanBurton> truth
01:45:06 <ClaudiusMaximus> arcatan: i really don't know, the difference is quite large (21ms per 666^2 adds with my data Float2 f = Float2 !f !f  (using Float2 Double) vs 28ms per 666^2 adds with Double)
01:45:11 <mauke> shachaf: it can make sense for bulk chmod with relative changes
01:45:17 <rostayob> shachaf: well the += stuff is actually immediately clear
01:45:18 <mauke> I'd still have to look it up :-)
01:45:23 <shachaf> mauke: Sure, I didn't say it always does.
01:45:25 <rostayob> if you know what the letters mean
01:45:25 <mauke> rostayob: bahahahaha
01:45:28 <DanBurton> anyways, thanks guys
01:45:32 <rostayob> mauke: ?
01:45:57 <mauke> rostayob: 644 is immediately clear to me. "oa-w and then u+w" is not
01:46:00 <shachaf> mauke: But in this case we know what permissions we want.
01:46:11 <arcatan> bbear: that's often the case, but you might be able to get good enough performance with nice code
01:46:20 <rostayob> mauke: mah, ok. I prefer that notation.
01:46:20 <tech2> mauke: u+w has no literal octal translation though.
01:46:39 <mauke> tech2: ok?
01:46:46 <shachaf> It does as a bitmask. :-)
01:46:55 <shachaf> chmod should support '&xxx' and '|xxx'
01:46:59 <tech2> mauke: so saying 644 is immediately clear to you is disingenuous.
01:47:04 <mauke> tech2: why?
01:47:17 <DanBurton> shachaf++
01:47:18 <tech2> mauke: because the two actions serve different purposes.
01:47:23 <mauke> tech2: what?
01:47:36 <shachaf> DanBurton: Also, you should learn how UNIX permissions work before doing any of this. :-)
01:47:41 <tech2> mauke: modifying an existing set of permissions versus setting them to a known value.
01:47:52 <mauke> tech2: yes, that's what I said
01:48:05 <arcatan> ClaudiusMaximus: huh, that sounds weird
01:48:07 <shachaf> tech2: 02:42 < mauke> shachaf: it can make sense for bulk chmod with relative changes
01:48:12 <DanBurton> shachaf: I know in general how they work. It was just unclear to me what ghci was complaining about, and I am not immediately familiar with how to use chmod
01:48:35 <shachaf> DanBurton: 02:40 < DanBurton> that's rather irritating, so I have to chmod it again if I ever want to change it? >,<
01:48:41 <rostayob> DanBurton: well this "general" knowledge is not enough then :)
01:48:42 <srhb> "file is readable by group and others, I want it to not be. Hmm, let me figure out this absolute mask" - when all you need to do is a relative change. What a ridiculous discussion. :)
01:48:45 <shachaf> You should certainly not be typing in random commands from #haskell
01:49:06 <DanBurton> shachaf: I was under the impression that no one could have write privileges in order for ghci to be happy
01:49:13 <mauke> srhb: I never think that way
01:49:18 <DanBurton> that misconception was cleared up rather quickly though
01:49:45 <Slipper> Try haskell platform
01:50:01 <DanBurton> Slipper: wat
01:50:36 <mauke> srhb: my thought process is more like "file is readable by group and others, I don't want that. what should the permissions be? ok, chmod $that"
01:50:42 <Slipper> it's handy
01:50:48 <DanBurton> actually, I just finished cabal-installing my pseudo-HP for GHC 7.4.1
01:51:08 <srhb> mauke: Which makes sense enough, but killing off the other method with a numeric blarrdeblarr to someone who's clearly new is just wonky. But whatever. :)
01:51:17 <mauke> srhb: I'd have to work backwards and compare with the current permissions to work out the relative changes, then 'man chmod' to figure out how to encode that
01:51:41 <Slipper> it's convinient under win system,
01:51:45 <DanBurton> oohhhh top level data decls in ghci <3
01:53:26 <Taneb> Hello
01:53:31 <DanBurton> Taneb: Hello
01:53:58 * DanBurton thinks lambdabot should have a greeting extension that automatically greets people that say "Hi" or "Hello"
01:54:05 <srhb> DanBurton: Good idea.
01:54:07 <shachaf> No.
01:54:11 <DanBurton> lol
01:54:12 <srhb> DanBurton: That might make people feel welcome though.
01:54:18 <Slipper> sure
01:54:31 <Slipper> I agree with that .
01:54:49 <DanBurton> shachaf: no?
01:55:24 <shachaf> No, it's just noise. In the case of humans saying it there's at least the arguable advantage of human interaction.
01:55:51 <DanBurton> @slap shachaf
01:55:51 * lambdabot clobbers shachaf with an untyped language
01:55:54 <DanBurton> is arguably noise
01:56:09 <shachaf> Right.
01:56:24 <shachaf> But we should aim to minimise useless bot text in the channel.
01:56:36 <mauke> having read 'man chmod' my position is now that symbolic chmod is write-only
01:56:50 <Slipper> wat
01:56:58 <mauke> the syntax is overcomplicated and it's full of weird exceptions
01:57:02 <DanBurton> @man chmod
01:57:02 <lambdabot> http://www.haskell.org/hawiki/HaskellUserLocations
01:57:08 <DanBurton> wat
01:57:34 <DanBurton> also a broken link
01:57:45 <shachaf> DanBurton: On that topic, are you aware that your own terminal has `man` support and that your own browser has Google support? :-)
01:57:46 <ClaudiusMaximus> preflex: xseen hpaste
01:57:46 <preflex>  hpaste was last seen on freenode/#haskell 7 days, 40 minutes and 9 seconds ago, saying: mekeor pasted “@ _mikey” at http://hpaste.org/57145
01:58:03 <shachaf> Not everything needs to go through the channel.
01:58:17 <DanBurton> shachaf: my browser only supports bing >.>
01:58:26 <ClaudiusMaximus> http://hpaste.org/57464
01:58:30 <DanBurton> but wtf did lambdabot think I said? I know it does small spell correction but...wat
01:58:37 <ClaudiusMaximus> DanBurton: map
01:59:12 <Slipper> Set
02:26:58 <statusfailed> snow :D
02:27:06 <sheaf_> any chance a kind soul could walk me through the issues I'm having with compiling my program on Windows? (managing fine with Linux)
02:27:25 <sheaf_> I'm missing gd, SDL and hmatrix, and not managing for various reasons
02:28:35 <sheaf_> a lot of weird stuff seems to be happening; when I update cabal it seems to remain at the same version number for instance... oh well
02:28:44 <sheaf_> I gave up for a while and tried cross-compiling but that was even worse
02:29:11 <sheaf_> dealing with packages I need in Windows is just the absolute worst
02:29:24 * hackagebot hackport 0.2.15 - Hackage and Portage integration tool  http://hackage.haskell.org/package/hackport-0.2.15 (SergeiTrofimovich)
02:33:32 <ClaudiusMaximus> arcatan: i think i figured it out - flawed benchmark, not magic..  seems i was getting infs and nans due to overflow, or something - and gc issues too, probably
02:38:58 <hpaste> ClaudiusMaximus annotated “Double-Double benchmarks” with “Double-Double benchmarks (annotation)” at http://hpaste.org/57464#a57465
02:41:07 <arcatan> heh, benchmarks and floats are both tricky.
02:51:54 <Taneb> Does GHC have an option that makes it allow types like a = a -> b?
02:53:00 <shachaf> GHC doesn't support equirecursive types, no.
02:53:04 <shachaf> You can use a newtype.
02:53:28 <ClaudiusMaximus> like newtype T b = C (T -> b)  ?
02:54:04 <shachaf> Yes (with the kind error fixed).
02:54:09 <ClaudiusMaximus> aha, yep
02:54:13 <shachaf> Not that that type seems particularly useful.
02:57:18 <chairdog> how insane is it to let arbitrary users upload haskell fragments which are then compiled in 7.4's safe mode?
02:57:39 * chairdog wanting to use haskell as a bidding language on a web portal
02:57:56 <ClaudiusMaximus> i had something like data Act a = Done a | Todo (IO (Act a)) in some code, to amortize a background rendering job over several frames in some glut-based callback hell
02:58:42 <Axman6> chairdog: well, you can alreayd use mueval, which is what lambdabot uses
02:58:58 <Peaker> ClaudiusMaximus: Callback hell is easy to translate to just "getEvents" via a bit of mainloop wrapping code
02:59:12 * chairdog was wondering if compiling it in GHC would be faster
02:59:14 <shachaf> ClaudiusMaximus: That's (Free IO), by the way.
02:59:39 * chairdog is expecting to evaluate all the bids many times per second
03:00:17 <ClaudiusMaximus> shachaf: ah, interesting!
03:03:34 <ClaudiusMaximus> Peaker: also interesting - i'm kinda used to jumping through callback hoops by now though...
03:20:44 <mjga> how to find a source for specific instance of a monad with Lambdabot?
03:21:24 <ClaudiusMaximus> @src [] return
03:21:25 <lambdabot> return x    = [x]
03:21:41 <mjga> @src [] (>>=)
03:21:41 <lambdabot> xs >>= f     = concatMap f xs
03:21:49 <mjga> ClaudiusMaximums: thx a lot :-)
03:22:37 <ClaudiusMaximus> @unmtl RWST a b c d e
03:22:37 <lambdabot> a -> c -> d (e, c, b)
03:29:21 <rostayob> mm_freak: is webwire still mantained?
03:29:41 <rostayob> it definitely doesn't work with the netwire > 1
03:36:20 <LiquidOrion> http://xrl.us/page341 can anyone help me ?? what exactly it wants
03:36:57 <ivanm> about to say, that link didn't look haskelly at all...
03:50:10 <rostayob> how do I install only the versioned versions of ghc binaries, when using the binary packages?
03:51:21 <mekeor> rostayob: "versioned versions" ?
03:51:24 <jedai> rostayob: on which platform ?
03:51:38 <rostayob> mekeor: versioned binaries, sorry
03:51:41 <rostayob> jedai: linux
03:52:36 <jedai> rostayob: well the binary package is just an archive, no ? you can just put it in its own dir and then just put versioned symbolic links
03:52:46 <jedai> in the path
03:53:24 <rostayob> jedai: ? I don't follow
03:53:50 <rostayob> when I run "sudo make install", I want to have only the binary packages put in place
03:53:55 <rostayob> *versioned binaries
03:54:02 <rostayob> anyways I'll do it manually
03:54:21 <jedai> rostayob: Yes, that was my proposition
03:54:56 <rostayob> ah, ok :)
03:55:02 <jedai> rostayob: just put it in a prefix not on the path and manually create the symbolic links
03:55:24 <jedai> rostayob: there's not too many binaries you may want to link anyway :)
03:56:36 <rostayob> jedai: wait, the thing is that ghc already ships with versioned binaries. all I want to do is to not create the unversioned symlinks
03:57:11 <nand`> sudo rm /usr/bin/ghc?
03:57:13 <jedai> rostayob: there's no "versioned binaries", they're just links
03:57:36 <jedai> rostayob: or vice-versa
03:58:07 <nand`> jedai: they're all symlinks to /etc/lib/ghc-version/ghc for me
03:58:10 <nand`> the ones in /usr/bin
03:58:19 <jedai> rostayob: I don't really see the problem with the manual solution, you're losing more time asking about it that it would take you to just do it
03:58:24 <nand`> ghc-version/lib/ghc, even
03:58:28 <nand`> *bin
03:58:52 <heffaklump> I want to write a solver for the 0-1 knapsack problem. So I need matrices, I think the best way to go is to use Data.Map, correct? Then I write a function matrixFromlist :: [Integer] -> Map (integer, Integer) integer
03:59:09 <heffaklump> To create a matrix
03:59:51 <jedai> nand`: right, so it install in a properly versioned dir and just put symlink in the path, so doing this manually (either installing then removing or just doing the mv and creating the symlink manually) should be fine and fast
04:00:10 <rostayob> jedai: No I'm not, because I often install ghc
04:00:16 <rostayob> jedai: and it's the other way around
04:00:22 <rostayob> the unversioned one is a symlink
04:00:33 <nand`> make install; rm /usr/bin/ghc
04:00:35 <jedai> rostayob: oh, that's another question then (you're working on ghc itself ?)
04:00:36 <nand`> I don't  see what's wrong with this
04:00:38 <rostayob> so I'd imagine there's a ./configure flag to prevent the symlink
04:00:56 <rostayob> nand`: then I have to create the symlink back the the original one... that's what I've been doing and it's kind of annoying
04:01:13 <nand`> rostayob: strange, I already have those
04:01:53 <nand`> rostayob: http://pastebin.com/tMJE2Mht
04:02:07 <nand`> here's what my /usr/bin folder looks like, is it not the same for you?
04:02:29 <nand`> maybe it's my package manager
04:02:35 <rostayob> nand`: yeah, it's your package manager
04:02:39 <nand`> oh okay
04:02:42 <rostayob> I'm talking about the standard GHC binaries
04:02:46 <nand`> well you could write a short haskell program to do the job then alias that :)
04:02:51 <nand`> if you're going to do it repeatedly
04:03:41 <heffaklump> btw, how do isee the type of a function in ghci?
04:03:47 <rostayob> heffaklump: :t
04:03:50 <rostayob> :t foldr
04:03:51 <lambdabot> forall a b. (a -> b -> b) -> b -> [a] -> b
04:06:48 <rostayob> nand`: also, it's more then one, there's also ghci and ghc-pkg...
04:06:59 <heffaklump> ty
04:07:09 <heffaklump> I want to write a solver for the 0-1 knapsack problem. So I need matrices, I think the best way to go is to use Data.Map, correct?
04:07:22 <rostayob> heffaklump: no
04:07:28 <rostayob> Data.Array, or something else
04:07:30 <jedai> heffaklump: sparse matrices ?
04:08:00 <jedai> You have excellent libraries on hackage for this kind of thing (hmatrix and others)
04:08:03 <heffaklump> jedai: one not sparse, one sparse
04:08:18 <heffaklump> the keep table is pretty sparse, could be
04:08:26 <heffaklump>  a 0/1 matrix
04:08:47 <heffaklump> but i want to write the matrix code to learn haskell
04:08:51 <rostayob> what's a 0/1 matrix? a matrix with just boolean values?
04:09:27 <rostayob> anyways, Map is good for (key, value) sets. it's not a matrix, it doesn't have bounds, regular shape, etc
04:09:46 <rostayob> if you want a proper matrix, you can use either Data.Array or other matrix packages.
04:09:48 <nand`> It's also bad for pattern matching
04:10:05 <nand`> ie. you can't do Matrix (c1, c2, c3,    c4, c5, c6,   c7, c8, c9)
04:10:19 <rostayob> nand`: you can't do that with most matrix packages anyways
04:10:36 <nand`> yeah, but if he makes his own he can easily make it fixed length
04:10:46 <nand`> come to think of it (,,,,,,,,) would work
04:10:51 <nand`> for a 3x3 matrix
04:11:00 <rostayob> if you want constant access and variable size you can't make your own
04:11:10 <jedai> rostayob: with view pattern you can do things like that
04:11:18 <rostayob> oh well, yeah you can just use tuples I guess, but then the size is constrained to the type...
04:11:42 <rostayob> jedai: for big matrices pattern matching is not that useful anyways, but ok
04:15:05 <jedai> rostayob: Sure, for big matrices you want to use the efficient functions provided to manipulate them (blas, lapack)
04:34:34 * hackagebot sundown 0.4.1 - Bindings to the sundown markdown library  http://hackage.haskell.org/package/sundown-0.4.1 (FrancescoMazzoli)
04:34:53 <heffaklump> Do I use cabal install or runhaskell to install a package?
04:35:39 <elliott> cabal install
04:35:46 <elliott> runhaskell is for running programs
04:36:54 <MaskRay_> runghc?
04:38:27 <mekeor> MaskRay_: runghc always uses ghc. runhaskell could also use hugs or something..
04:41:05 <MaskRay_> mekeor: didn't know that before. my distro made runhaskell a symlink to runghc
04:43:59 <kallisti> which style do you prefer for records: commas in front of fields at the beginning of a line, or commas at the end of lines?
04:46:19 <srhb> I'm confused. Why does this not work? map ((+1) . read) "123"
04:46:40 <kallisti> srhb: perhaps an ambiguous context
04:46:49 <kallisti> > map ((+1) . read) "123"
04:46:50 <lambdabot>   Couldn't match expected type `[GHC.Types.Char]'
04:46:51 <lambdabot>         against inferred ty...
04:47:00 <kallisti> > map ((+1) . read) "123" :: [Int]
04:47:01 <lambdabot>   Couldn't match expected type `[GHC.Types.Char]'
04:47:01 <lambdabot>         against inferred ty...
04:47:06 <kallisti> er
04:47:07 <kallisti> oh
04:47:14 <kallisti> srhb: because read doesn't work on characters.
04:47:23 <kallisti> try digitToInt
04:47:25 <kallisti> @hoogle digitToInt
04:47:26 <lambdabot> Data.Char digitToInt :: Char -> Int
04:47:41 <srhb> Oh yes, of course. Doh.
04:47:51 <_Mikey> > digitToInt 'a'
04:47:52 <lambdabot>   10
04:47:55 <_Mikey> :o
04:57:48 <Sugarlake> does anyone have an idea howto get this "monadius" game to run? i installed it via "cabal install". the installation worked but the program does nothing it just returns immediately
04:58:39 <rostayob> I wrote these a while ago but I never had the time to test and document the properly: http://hackage.haskell.org/package/kyotocabinet . If someone is interested...
04:58:49 <rostayob> they cover more or less all you can do with KyotoCabinet
05:04:34 * hackagebot kyotocabinet 0.1 - Mid level bindings to Kyoto Cabinet  http://hackage.haskell.org/package/kyotocabinet-0.1 (FrancescoMazzoli)
05:04:41 <rostayob> yeah, those
05:06:26 <mekeor> ski: is that the reason for your name?: http://ro-che.info/ccc/08.html
05:07:28 <heffaklump> how do i make a list of zeroes like this: [[0,0,0],[0,0,0]]
05:07:53 <heffaklump> like : zeroMatrix :: Integer -> Integer -> [[Integer]]
05:08:09 <Tomsik> :t replicate
05:08:10 <lambdabot> forall a. Int -> a -> [a]
05:08:10 <byorgey> heffaklump: use 'replicate'
05:08:11 <lambdabot> byorgey: You have 2 new messages. '/msg lambdabot @messages' to read them.
05:08:12 <heffaklump> zeroMatrix 2 3 -> [[0,0,0],[0,0,0]]
05:08:37 <Tomsik> > let zeroMatrix n m = replicate n (replicate m 0) in zeroMatrix 2 3
05:08:38 <lambdabot>   [[0,0,0],[0,0,0]]
05:08:40 <mekeor> > replicate 3 $ replicate j 4
05:08:41 <lambdabot>   Couldn't match expected type `GHC.Types.Int'
05:08:41 <lambdabot>         against inferred type ...
05:09:00 <mekeor> > replicate 3 $ replicate 4 0
05:09:01 <lambdabot>   [[0,0,0,0],[0,0,0,0],[0,0,0,0]]
05:10:16 <Tomsik> Anyone has something to read on Data.Data? Recently I've seen something on reddit using it and it was quite fine
05:10:28 <Tomsik> But besides documentation, I'd like to read something more about it
05:11:29 <rostayob> Tomsik: there are some papers related to syb, there should be links
05:11:33 <elliott> Tomsik: "scrap your boilerplate" and "generics" are the phrases to look for
05:11:41 <elliott> (but NOT ghc generics...)
05:12:09 <rostayob> Tomsik: http://www.cs.uu.nl/wiki/GenericProgramming/SYB
05:12:20 <rostayob> the two papers are useful
05:13:00 <mekeor> Tomsik: http://www.cs.uu.nl/wiki/bin/view/GenericProgramming/Publications
05:13:38 <rostayob> mekeor: mhm... those might be related to GHC.Generics
05:13:50 <rostayob> ah no, too old
05:14:53 <Tomsik> Thanks
05:16:01 <rostayob> Tomsik: you might want to look at GHC.Generics as well since that seems to be the way forward...
05:18:41 <mekeor> @joke
05:18:41 <lambdabot> Maybe you meant: join more vote
05:18:56 <mekeor> http://www.haskell.org/haskellwiki/Humor/Haskell_saves_lives hehe
05:19:07 <alistra> > Humor
05:19:08 <lambdabot>   Not in scope: data constructor `Humor'
05:19:19 <shachaf> #not-haskell
05:19:21 <alistra> haskell never saved anybody
05:19:23 <shachaf> No humour in #haskell.
05:20:31 <alistra> because nobody will ever consider using it in a production environment
05:22:08 <chairdog> haskell-src seems to want a few build dependencies that it doesn't pull in automagically - happy and hint at least
05:22:12 <Tomsik> Nobody wil consider using #haskell in a production environment? Outrageous.
05:22:24 <chairdog> is that a cabal failing or something fixable in the .cabal file?
05:22:25 <rostayob> chairdog: install the haskell platform
05:22:39 <rostayob> #haskell is a serious channel.
05:22:52 <mekeor> alistra: why?
05:23:03 <chairdog> rostayob: yeah i could guess that would work...
05:23:06 <mekeor> shachaf: sry.
05:23:52 <alistra> mekeor: i just thought it's like a common knowledge
05:24:00 <mekeor> shachaf: #not-haskell doesnt exist. is there an offtopic-channel?
05:24:07 <alistra> -blah
05:24:13 <mekeor> ah, okay
05:24:13 <rostayob> mekeor: #haskell-blah
05:24:17 <shachaf> mekeor: Eh, I was exaggerating a little bit. :-)
05:24:37 <alistra> well surely YOU CAN FIND MORE JOBS IN #not-haskell
05:24:39 <mekeor> shachaf: :)
05:24:40 <alistra> :D
05:24:46 <mekeor> :D
05:24:50 * shachaf sighs.
05:25:09 <mekeor> alistra: no, seriously: why do you think that there won't be much "haskell-jobs" ?
05:25:31 <alistra> because i'm trying to find one ;D
05:25:33 <mekeor> i don't see any real reasons for avoiding haskell in industry.
05:25:40 <mekeor> alistra: hehe. i see.
05:26:06 <mekeor> but generally, there's no serious disadvantage of haskell in industry, is there?
05:26:45 <erus`> the level of skill required to be 'good' at c# is completely different to the level of skill required to be 'good' at haskell
05:26:56 <erus`> thats why only dons will get a job coding haskell
05:26:57 <alistra> well, the silent assumption of the world being rational and that the people who know their business doing that descisions
05:27:00 <mekeor> i mean, yes, most companies use other languages... but not because haskell is stupid... rather because most people know other langs...
05:27:07 <nand`> haskell has a few advantages in the industry that few other languages can offer
05:27:22 <nand`> these will become more obvious as time goes on and programming is forced into a functional direction in general
05:27:23 <Tomsik> Honestly, I'm paid to program in Erlang and I feel like "uhh.. no do notation.. no inference telling compiler what instances to use"
05:27:40 <Tomsik> I mean, you have to manually instantiate
05:28:11 <mekeor> @remember nand` haskell has a few advantages in the industry that few other languages can offer. these will become more obvious as time goes on and programming is forced into a functional direction in general.
05:28:11 <lambdabot> I will remember.
05:28:13 <rostayob> Tomsik: wait, what?
05:28:32 <rostayob> Tomsik: why would do notation be useful in erlang? erlang has sequencing and side effects by default
05:28:42 <rostayob> also, what instances? erlang doesn't have type classes
05:29:06 <Tomsik> Exactly, it doesn't
05:29:10 <rostayob> erlang barely has types! ehe
05:29:27 <Tomsik> You have to pick functions to run manually
05:29:31 <mekeor> erus`: you're right. i agree. yep...
05:29:39 <Tomsik> No, it has types, dynamic types, types that don't match at runtime
05:29:55 <rostayob> Tomsik: mh?
05:30:05 <mekeor> nand`: can you give arguments for your prediction?
05:30:15 <rostayob> erlang has primitive types, and it also has dyaliser
05:30:20 <Tomsik> rostayob, as of do-notation, I miss Maybe monad
05:30:21 <rostayob> (probably spelled wrong)
05:30:21 <alistra> i like dynamic types systems, it's like saying C has a dynamic null pointer dereference protection :D
05:30:34 <Tomsik> dialyzer is awful
05:30:51 <nand`> mekeor: we're rapidly gaining cores, and distributed computing is rising as well
05:30:53 <rostayob> Tomsik: it's better now. anyway, this stuff if for #erlang
05:31:11 <rostayob> but I think that erlang does what it's supposed to do fairly well
05:31:13 <nand`> mekeor: as copilers have abstracted memory management away from us for the past 50 years, compilers will abstract processor management away from us for the next 50 years
05:31:25 <Tomsik> Well yeah, it does, but it's painful to write sometimes
05:31:26 <Peaker> chairdog: about the dependencies on happy/alex -- cabal does not specify executable dependencies, only library dependencies...
05:31:30 <mekeor> nand`: hm. and you think parallel programming is easier with FP than in IP ?
05:31:33 <Peaker> chairdog: (if you depend on an executable, you cannot specify that)
05:32:20 <nand`> mekeor: well, foldMap can be parallelized automatically by the compiler, so if we process data using foldMap instead of accumulators, it can reasonably be scaled
05:32:25 <nand`> that's the direction I'm arguing from
05:32:27 <Tomsik> nand`, automatic parallelism is probably impossible
05:32:41 <nand`> (assuming a suitable data type that isn't [])
05:33:09 <chairdog> Linking dist/build/mueval-core/mueval-core ...
05:33:09 <chairdog> /usr/lib/gcc/i486-linux-gnu/4.4.5/libgcc_s.so: could not read symbols: Memory exhausted
05:33:11 <rostayob> Tomsik: why? some libraries do provide automatic parallelism (repa & co.)
05:33:17 <Tomsik> They're trying to do that
05:33:19 <nand`> In general, in pure functional programs, the compiler can make far more assumptions than in imperative programs since there are no side effects to consider
05:33:27 <rostayob> Tomsik: no, they already do that
05:33:42 <Tomsik> But there is a strong hypothesis that you cannot get a large speedup with even polynomial number of processors
05:33:45 <chairdog> why is cabal aways such an adventure for me.
05:33:45 <nand`> I think it's only a matter of time until compilers are smart enough to start beating imperative programs
05:34:10 <nand`> Tomsik: because of communication?
05:34:15 <rostayob> chairdog: you're not alone, but I doubt that's cabal's fault
05:34:27 <Tomsik> I mean as in complexity-theoretic problem
05:34:35 <rostayob> Tomsik: if you design a library to do certain operations with are easily made parallell, it works well
05:34:48 <Tomsik> nand`, it's more of computations being "inherently sequential"
05:34:51 <elliott> <rostayob> Tomsik: why would do notation be useful in erlang? erlang has sequencing and side effects by default
05:34:54 <elliott> rostayob: for monads other than IO?
05:35:17 <rostayob> elliott: no, ok.
05:35:40 <rostayob> but I doubt a do notation would be of much use without typeclasses
05:35:49 <chairdog> rostayob: oh this machine has no swap on it - thats probably why
05:36:19 <Tomsik> rostayob, even if you could make a do block and then only supply bind and return it would be much better than it is now
05:36:51 <rostayob> Tomsik: mah. I'm not sure.
05:37:14 <Tomsik> It lets you avoid many unecessary named variables
05:38:14 <Tomsik> like do x <- a; y <- b x; z <- c x y in Maybe/Either unwinds in erlang to something that has at least three nested cases
05:38:26 <rostayob> I don't know, I write erlang as well and I don't miss monads too much. Considering the plumbing that a do-notation would necessitate (passing the functions explicitly) and the untyped nature of erlang I don't know how useful it'd be
05:38:49 <elliott> rostayob: do EitherMonad { ... }
05:38:53 <elliott> you'd only need to specify them in the head
05:38:58 <elliott> (say EitherMonad is a (return,bind) tuple)
05:39:01 <rostayob> elliott: yes, I understand
05:40:04 <rostayob> but you wouldn't be able to write generic code, for example. I don't know I guess it'd save some lines of code from times to times but I don't know if you'd improve code quality and readability
05:40:27 <elliott> rostayob: well... mapM_ mon f xs = do mon { ... } :P
05:40:29 <elliott> but yeah
05:42:09 <Tomsik> having to thread variables explicitly and explicit cases are not really good for readability
05:42:40 <rostayob> Tomsik: you're threading them explicitly with do notation as well eh... it's the short-circuiting in case of Nothing that you're missing
05:42:57 <rostayob> (in the Maybe case)
05:43:39 <Tomsik> Well, yes. Perhaps I'm trying to make a different point than I want to.
05:43:46 <rostayob> Tomsik: also, erlang programmers would just do 'Just a = foo' most of the times :P
05:44:07 <Tomsik> Sometimes you just don't want to crash
05:44:20 <Tomsik> Because the place where you crash makes for a different error message
05:45:01 <Tomsik> badmatch isn't really telling much :p
05:45:04 <rostayob> yeah I know, but you'd often do that in erlang when you expect a result
05:46:18 <rostayob> Tomsik: it's a bit richer than that, it also tells you what didn't match and what lines
05:47:10 <Tomsik> It'd be painful to distinguish with that between "parse failed" and "database connection failed" and "you're a pile of poo"
05:47:57 <rostayob> Tomsik: I understand, I understand, I'm just saying that while in haskell you'd *always* handle Nothings, in a language like Erlang you often assume that things are ok
05:48:27 <Tomsik> Well, monads mostly handle it for you :p
05:48:54 <rostayob> mah not really, it's just convenient syntax. You have to handle errors at some point anyways.
05:48:56 <heffaklump> What would be a good program to write which be of a reasonable size(1k-2K lines of code) that shows the strength of Haskell as opposed to Java or C#?
05:49:17 <burbul> Newbie question: Could anyone tell me a nicer way of writing this? http://hpaste.org/57467
05:49:19 <rostayob> heffaklump: an interpreter for a small language
05:49:30 <heffaklump> rostayob: sounds quite hard
05:49:34 <rostayob> heffaklump: it isn't
05:50:03 <rostayob> an emulator for some old, small instruction set is fun as well
05:50:04 <heffaklump> + compilers is haskells strength, i think more of something that Java is good at too but haskell is better
05:50:27 <rostayob> a parser/type checker/interpreter for the lambda calculus!
05:50:33 <rostayob> heffaklump: concurrency
05:50:35 <chairdog> i oftenfind it nice for processing results from database queries
05:50:42 <chairdog> eg summarisation and stuff
05:50:59 <rostayob> heffaklump: concurrency is often heralded as a good thing in java, but it's crap
05:51:10 <rostayob> (compared to STM anyways)
05:51:50 <mjga> mekeor: don't forget that not only functional direction is more parallel, but that type classes give a nice structure to modern dynamic languages, while allowing similarly high level descriptions
05:52:58 <heffaklump> wheres a good C channel?
05:53:06 <elliott> Nowhere.
05:53:09 <elliott> A bad C channel is ##c.
05:53:19 <otters> I can testify to that
05:56:31 <mm_freak> rostayob: not really…  webwire was more like a proof of concept
05:56:47 <mm_freak> rostayob: i don't really have time to make a serious project out of it
06:00:49 <rostayob> mm_freak: ok, I have to go now but I was looking for some project to get my hands dirty with FRP
06:01:00 <rostayob> mm_freak: so if you have any suggestions... leave a message :D
06:01:07 * rostayob goes to get food
06:09:47 <mekeor> so, using haskore, you can't play sound? you just can write sounds into a file?
06:10:29 <elliott> http://www.haskell.org/haskellwiki/Haskore#Backends
06:10:39 <elliott> at least one of csound and supercollider can play in realtime, I think?
06:10:52 <elliott> "The core Haskore can run on both Linux and Windows. Only various back-ends and real-time functionality are critical. So far, real-time playback and use of SuperCollider is only usable on Linux."
06:12:45 <heffaklump> can you see this paste: http://pastebin.com/crP3R1Tz
06:12:48 <heffaklump> ?
06:12:48 <mauke> The paste crP3R1Tz has been copied to http://hpaste.org/57468
06:13:05 <heffaklump> (it is C just asking if you can see the original address)
06:13:47 <mjga> elliott: I tried to actually use both Haskore and Euterpea (not yet published, I believe) with real time playback, but it seems non trivial to configure. would appreciate if somebody told me how to make it work well with default sound daemon on ubuntu 11.10
06:13:54 <Taneb> heffaklump, yes
06:14:04 <erus`> @pf map (\x -> (length x, head x)) . group
06:14:04 <lambdabot> Maybe you meant: bf pl
06:14:12 <erus`> @pl map (\x -> (length x, head x)) . group
06:14:12 <lambdabot> map (liftM2 (,) length head) . group
06:14:58 <elliott> mjga: dunno, I just looked at the wiki page :P
06:15:08 <elliott> heffaklump: It's very red.
06:17:22 <mjga> mekeor: I also only managed to get sound file. Let me know if you manage to get more
06:18:49 <mjga> elliott: the problem may be that Haskore seems no longer developed by primary author, but its successor (Euterpea) is not yet officially released for general public. Altough many thanks to its author, for providing source and book draft
06:25:02 <tux_mark_5> hello
06:25:30 <Taneb> Hello!
06:25:32 <tux_mark_5> is there a descent way to implement the observer pattern in haskell or are there better alternatives?
06:26:31 <tux_mark_5> everyone seems to agree that FRP is the way to go, but i'm trying to decide if it fits my current situation
06:26:41 <maurer_> tux_mark_5: What are you trying to do?
06:27:24 <tux_mark_5> i'm working on a xbindkeys-like daemon, which will hook directly into /dev/input/event* and will provide system-wide actions
06:28:05 <tux_mark_5> everything already works, but i'm thinking if I should convert the core into something FRP-like
06:28:37 <tux_mark_5> also the same program is polling running processes in some time intervals
06:28:58 <tux_mark_5> and this way it can detect if some new process has started or have been destroyed
06:29:06 <maurer_> I'd say edit lenses + STM, FRP seems a little overkill
06:29:16 <heffaklump> anyone good with C?
06:29:20 <heffaklump> i cant get into #c
06:29:31 <tux_mark_5> using this information I can detect if a new X Session is running, and hook into D-Bus or something
06:29:34 <heffaklump> anyoen can invite me to #C?
06:29:55 <heffaklump> http://pastebin.com/crP3R1Tz <- some sort of aray initiation problem
06:29:55 <mauke> The paste crP3R1Tz has been copied to http://hpaste.org/57468
06:29:57 <elliott> heffaklump: You have to register with nickserv to join ##c.
06:30:04 <elliott> C problems aren't on topic here.
06:30:27 <elliott> heffaklump: /msg nickserv register <password> <email>
06:30:29 <elliott> (Without <>s.)
06:30:56 <maurer_> heffaklump: You are looking for ##c
06:30:58 <maurer_> not #c
06:31:04 <maurer_> Register, and you'll be let in.
06:31:38 <nand`> heffaklump: consider #help next time
06:31:41 <nand`> or whatever the freenode help channel is
06:31:49 <mreh> #freenode?
06:31:54 <elliott> maurer_: #c redirects to ##c.
06:31:57 <elliott> IIRC.
06:32:11 <maurer_> elliott: I tried to join #c, and it told me invite only. Joined ##c just fine.
06:32:15 <nand`> mreh: I figured that's the discussion/chat channel
06:32:17 <mreh> if you IRC correctly
06:32:33 <heffaklump> Cannot join channel (+r) - you need to be identified with services
06:32:41 <maurer_> heffaklump: 07:27 < elliott> heffaklump: /msg nickserv register <password> <email>
06:32:55 <shachaf> Invite only channels on Freenode? What's the point of that?
06:33:06 <maurer_> For further non-haskell help, go to #freenode and talk there.
06:33:09 <mreh> has anyone got a compiled and running version of the flux demo?
06:33:33 <maurer_> shachaf: Sometimes it's done as a way to bounce people out of a channel that emphatically doesn't exist for various reasons
06:33:58 <mreh> they have some interesting solutions to OpenGL warts, such as callbacks
06:34:18 <mreh> right now mine seems to be generating a torus and is taking its time about it
06:34:24 <shachaf> I guess so. As long as it's clear that anyone who makes an *actual* invite-only channel on this IRC network is the devil.
06:34:54 <maurer_> Eh, I know of at least one of those, and I'm pretty sure the people running it aren't the devil.
06:34:57 <maurer_> :P
06:35:44 <maurer_> It's also useful as a turtling mode if some jackass keeps coming back and bothering you with different IPs
06:35:57 <shachaf> So do I. I'm really just making fun of the person who made it in this channel.
06:36:07 <shachaf> He/she's already admonished me, so I guess I'll stop.
06:36:32 <mreh> it's so long since i registered i can't remember
06:37:17 <mreh> 10,000 polygons and counting...
06:37:54 <mreh> nobody got this working? http://www.youtube.com/watch?v=4vo0yK7P8-s
06:38:44 <irene-knapp> hm, cool, but no
06:38:56 <dmitrii> hi everybody
06:39:33 <dmitrii> does anybode use Darcs nowadays?
06:39:37 <irene-knapp> I do
06:40:24 <mekeor> dmitrii: afaik, lots do, yes.
06:40:37 <dmitrii> are there important differences from hg or git?
06:40:44 <mekeor> dmitrii: there's #darcs , too
06:40:47 <irene-knapp> yes
06:41:04 <irene-knapp> darcs doesn't have rebasing (yet), but it does have commutative patches, which largely obviate the need for it
06:42:12 <irene-knapp> (but not entirely)
06:42:47 <dmitrii> irene-knapp: oh, I see. I'll try to google more about it. Thank you! :-)
06:42:50 <irene-knapp> sure thing :)
06:44:32 <elliott> Er?
06:44:38 <elliott> I was under the impression that darcs does have rebase.
06:44:44 <irene-knapp> if so, it was added quite recently
06:44:46 <elliott> dmitrii: git is much more popular than darcs nowadays even in the haskell community
06:44:48 <irene-knapp> but it's possible
06:44:49 <elliott> but people still use darcs
06:45:00 <elliott> GHC and most of the popular libraries are all git, though
06:48:39 <jmcarthur> oh man the new features in ghci make me happy
06:49:23 <jmcarthur> dmitrii: i use darcs and love it
06:50:29 <_Mikey> :o I use darcs
06:50:31 <jmcarthur> "unfounded" rebasing is just about the only thing it doesn't support directly, but since that's really just blind patch application one can always simulate it with some sequence of plain unix commands. still kind of inconvenient
06:50:44 <shachaf> jmcarthur: Like the fact that it's over 10 times faster to start up?
06:51:03 <shachaf> That's the hidden feature that only affects people like me with a mid-2-digit number of imports in ~/.ghci
06:51:08 <jmcarthur> i haven't noticed a speed different yet
06:51:21 <jmcarthur> ah
06:51:25 <jmcarthur> i have much fewer
06:51:43 <jmcarthur> in fact, this being a relatively new system that i didn't copy all my old configs to, i have very few indeed
06:51:53 <dbbddbdb> Is it possible to modify sources that `cabal install` will then install?
06:51:54 <elliott> I have none.
06:52:04 <dbbddbdb> I want to fix SDL because it doesn't build on 7.4
06:52:05 <elliott> dbbddbdb: cabal unpack; modify it; cabal install inside the directory
06:52:11 <dbbddbdb> elliott: thanks!
06:52:23 <ClaudiusMaximus> don't forget to add a .1 to the version in the .cabal file or it'll get confused
06:52:37 <jmcarthur> but it's great. i can say "data Foo = Foo Int", then try "Foo 5" and see that i forgot a show instance. no problem, ":set -XStandaloneDeriving" and "deriving instance Show Foo", and it's all good
06:52:59 <shachaf> jmcarthur++ # reminding me about standalone deriving.
06:53:06 <mekeor> does anybody know a library/package/module which provides functions PLAYing sound? i do not mean writing into a sound/music-file, i rather mean directly playing.
06:53:16 <jmcarthur> yeah that extension will be useful for debugging too
06:53:24 <ClaudiusMaximus> yeah! shame about some weirdness about adding instances to datatypes defined in files with other instances
06:53:30 <jmcarthur> type in your module doesn't have Show? no problem
06:53:39 <jmcarthur> yeah
06:53:50 <jmcarthur> *almost no problem
06:53:54 <elliott> mekeor: http://hackage.haskell.org/packages/archive/pkg-list.html#cat:sound
06:54:40 <elliott> mekeor: alsa-*, esound, hmidi, jack, OpenAL, portaudio, PortMidi all look relevant
06:54:48 <elliott> pulse-simple too, I think I've used that
06:55:37 <mekeor> elliott: alright. okay. thanks so far. :)
07:01:48 <erus`> does anyone know of a matrix and vector math lib for use with opengl
07:01:59 <erus`> the hOpenGL uses IO and stuff
07:02:20 <homie> cblash,blas,lapack,atlas ?
07:02:37 <homie> gsl ?
07:04:46 <mreh> doesn't hmatrix bind to a few of those?
07:04:51 <elliott> yeah
07:05:11 <mreh> if it's really simple matrix stuff, just roll your own
07:05:24 <mreh> graphics you don't get much bigger than 4x4
07:05:26 <erus`> mreh i tried but its not working right
07:05:40 <erus`> and i cant realy debug it because i dont know the math inside out
07:06:13 <mreh> erus`: i see, i don't know of any simple matrix libs out there
07:06:24 <eikke> hmatrix is kinda nice
07:07:13 <mreh> it's another interface to learn though
07:07:51 <erus`> i just need matrix mul and build rotation matrix
07:08:03 <erus`> you know what, i might do this in javascript
07:08:10 <erus`> maybe people will get to see it then
07:08:44 <everythingWorks> erus' what are you trying to do?
07:09:30 <erus`> im gonna make a game where you can draw on the walls
07:09:57 <elliott> erus`: If it's not working right, the problem probably isn't hmatrix.
07:10:03 <erus`> i wrote some code in haskell to uvunwrap a triangle mesh
07:10:43 <erus`> then i ported my simple matrix lib from C++ to haskell but somewhere along the lines it doesnt work the same way
07:10:55 <erus`> so moving the camera doesnt work the same way
07:11:12 <mreh> are you moving the world instead of the camera?
07:11:28 <mreh> i haven't made a game where the camera moves as of yet
07:11:46 <erus`> yeah i translate the world inversely
07:12:09 <mreh> do you use your own abstraction layer for the graphics?
07:12:27 <mreh> unless you write the whole thing in IO
07:12:48 <erus`> no i just use 'matrix' to set the modelview
07:13:14 <mreh> i've got a Monoidal interface for sorting layers of the 2D sprites, but the textures don't work
07:13:25 <mreh> re-binding textures just gives me white
07:13:52 <mreh> without any binding i just get the last texture mapped to everything
07:14:02 <mreh> so i figured i wasn't binding anything correctly
07:33:58 <tromp__> how to refer to last expression that ghci evaluated?
07:34:15 <monochrom> it
07:34:29 <monochrom> last answer, actually
07:34:49 <tromp__> thx, monochrom
07:35:14 <hpc> technically, they are the same
07:35:17 <hpc> ;)
07:36:24 <eikke> hpc: hmh... > print 1 (shows '1') > it (shows '()' as expected)
07:36:26 <eikke> ;)
07:38:03 <Jafet> > print 1
07:38:04 <lambdabot>   <IO ()>
07:38:14 <tromp__> it also shows () after aborted evaluation
07:38:34 <Jafet> > it
07:38:35 <lambdabot>   <IO ()>
07:38:44 <eikke> Jafet: question was about ghci, not the type of 'print 1'
07:39:34 <monochrom> "it" is not available to lambdabot
07:39:45 <monochrom> oh, wait, it is?
07:39:52 <monochrom> @undefine
07:39:56 <Taneb> > it
07:39:56 <lambdabot>   Not in scope: `it'
07:40:07 <monochrom> > map id [5]
07:40:07 <lambdabot>   [5]
07:40:10 <monochrom> > it
07:40:11 <lambdabot>   Not in scope: `it'
07:40:19 <monochrom> well, there, is not
07:40:25 <elliott> > sum [1..]
07:40:29 <lambdabot>   mueval-core: Time limit exceeded
07:40:32 <elliott> @let it = text "mueval-core: Time limit exceeded"
07:40:39 <lambdabot>  Defined.
07:40:41 <elliott> > map id [5]
07:40:42 <lambdabot>   [5]
07:40:43 <elliott> > it
07:40:48 <lambdabot>   mueval-core: Time limit exceeded
07:40:50 <elliott> perfect
07:41:17 <rostayob> elliott: and then you complain that lambdabot hates you.
07:41:22 <otters> > 5
07:41:23 <lambdabot>   5
07:41:24 <otters> > it
07:41:27 <CodeWeaverX> @let it = text "If you've done six impossible things this  morning, why not have breakfast at Milliways!"
07:41:28 <lambdabot>  <local>:2:0:
07:41:28 <lambdabot>      Multiple declarations of `L.it'
07:41:29 <lambdabot>      Declared at: <local>:...
07:41:29 <lambdabot>   mueval: ExitFailure 1
07:41:29 <lambdabot>  mueval: Prelude.undefined
07:41:34 <elliott> I like how lambdabot is somehow responding slower to "> it"
07:41:34 <CodeWeaverX> boo
07:41:36 <elliott> making it even more realistic
07:41:43 <CodeWeaverX> @undefine it
07:41:54 <CodeWeaverX> @let it = text "If you've done six impossible things this  morning, why not have breakfast at Milliways!"
07:41:55 <lambdabot>  Defined.
07:42:02 <CodeWeaverX> > [1..5]
07:42:03 <lambdabot>   [1,2,3,4,5]
07:42:04 <CodeWeaverX> it
07:42:07 <CodeWeaverX> > it
07:42:12 <lambdabot>   mueval-core: Time limit exceeded
07:42:15 <rostayob> aha.
07:42:22 <CodeWeaverX> O.o
07:42:24 <eikke> > let it = 1
07:42:26 <lambdabot>   not an expression: `let it = 1'
07:42:39 <rostayob> eikke: it's @let
07:42:41 <elliott> CodeWeaverX: It's "If you've done six impossible things this morning, why not round it off with breakfast at Milliways, the Restaurant at the End of the Universe?"
07:42:42 <otters> @let it = 1
07:42:42 <lambdabot>  <local>:2:0:
07:42:43 <lambdabot>      Multiple declarations of `L.it'
07:42:43 <lambdabot>      Declared at: <local>:...
07:42:56 <CodeWeaverX> elliott:  Yes, yes, I realize.
07:43:12 <CodeWeaverX> *hugs his Hitchhiker's Guide*
07:46:42 <heffaklump> what a good way to replace 2 for loops?
07:47:10 <CodeWeaverX> A recursive function that calls another recursive function?
07:47:13 <CodeWeaverX> A fold within a fold?
07:47:18 <CodeWeaverX> Some combination fo the two?
07:47:24 <danr> for loops?
07:47:35 <CodeWeaverX> I presume these are nested for loops in another language's code you're talking about.
07:47:42 <hpaste> sickhuman pasted “C to haskell” at http://hpaste.org/57471
07:47:51 <danr> two or more, use a for!
07:47:55 <heffaklump> ^^ i want C->haskell
07:48:05 <danr> heffaklump: i would try to use list comprehensions
07:48:15 <heffaklump> CodeWeaver yes 2 recursive ones i can do but not very elegant i think
07:48:59 <danr> heffaklump: it seems that you set on only thecurrent index i,j som you can probably translate this to creation of a new list without destructive update
07:49:21 <mm_freak> heffaklump: a for loop is such a general control structure that your question is impossible to be answered
07:49:39 <mapreduce> heffaklump: Depends what the loops do, or if you'd rather not specify that, port 'for' to Haskell.
07:49:46 <mm_freak> please provide some context
07:49:48 <mapreduce> http://www.xoltar.org/old_site/2003//sep/09/haskellLoops.html should get you started.
07:49:49 <danr> heffaklump: what does i<items->rows+1 do? :D
07:50:28 <danr> i just assumed the paste from sickhuman was heffaklump's, is this incorrect?
07:51:02 <mm_freak> heffaklump: in general there is a very simple answer to most "how do i translate <C construct of your choice> to haskell?" questions:  "you don't"
07:51:05 <mm_freak> =)
07:51:21 <heffaklump> danr:?
07:51:33 <mapreduce> mm_freak: Although that's exactly what I've been doing recently for fun.
07:51:33 <heffaklump> i<items->rows+1????
07:51:53 <mm_freak> mapreduce: sure, but to do that you really already have to know how to do it properly =)
07:52:08 <mapreduce> I've found I can wing it. :)
07:52:08 <mm_freak> of course you can have goto and comefrom in haskell with ContT =P
07:53:18 <mapreduce> Sorry, I've just been porting code samples from C tutorials to Haskell sticking to the original as far as possible, not actually porting control constructs.
07:53:30 <mapreduce> apart from 'while', copied from the page I linked to above.
08:13:36 <heffaklump> how do i block comment?
08:13:52 <mekeor> heffaklump: {- ... -}
08:13:54 <CodeWeaverX> {- boo -}
08:14:07 <mekeor> i get an error while trying to install the xine-library with cabal (using "cabal install xine") which i don't understand:
08:14:08 <hpaste> mekeor pasted “cabal install xine -> error” at http://hpaste.org/57475
08:14:16 <mekeor> any ideas?
08:14:30 <mekeor> what does that mean?
08:15:18 <Saizan> mekeor: that you need to install the C libxine through your distro
08:15:44 <Saizan> mekeor: pkg-config is a tool used to store metadate about C libs
08:15:55 <mekeor> Saizan: ah, i see.
08:15:58 <heffaklump> damnit i forgot maybe
08:16:06 <mux> is there a cabal-install that works fine with Cabal 1.14 from GHC 7.4.1? can I just alter the .cabal file?
08:16:12 <heffaklump> is there someway to circumvent it if i know it can never happen?
08:17:03 <Saizan> case foo of Just x -> x; Nothing -> error "I thought this would never happen!"
08:19:18 <mekeor> Saizan: the *-dev package?
08:19:18 <elliott> mux: get darcs cabal
08:19:23 <heffaklump> ty
08:19:33 <Saizan> mekeor: yep
08:19:33 <elliott> mux: darcs get http://darcs.haskell.org/cabal/
08:19:41 <elliott> mux: then use bootstrap.sh in the cabal-install directory
08:19:45 <elliott> works great
08:19:59 <mux> ok, thank you - I just wish I didn't have to install darcs
08:22:41 <elliott> mux: your distro probably has a package
08:22:47 <elliott> you can uninstall it afterwards :P
08:22:54 <mux> I know, but it has other issues
08:24:10 <elliott> what does?
08:25:03 <mux> don't bother
08:26:04 <mekeor> Saizan: thank you, btw =)
08:27:00 <Saizan> mekeor: np
08:27:28 <dbbddbdb> http://hpaste.org/56725 ← this code does not compile on 7.4.1 because it complains that (unbox $ fromEnum x) has kind * while it should have kind #
08:28:09 <dbbddbdb> When I rewrite unbox as unbox (I# e) = e it still gives the error
08:28:32 <Saizan> dbbddbdb: you need to avoid ($)
08:28:40 <dbbddbdb> However, when I put the explicit case ... of I# e -> e it works
08:28:42 <dbbddbdb> Saizan: why?
08:28:53 <dbbddbdb> It worked on 7.2
08:29:13 <Saizan> i guess they are being more precise about kinds in 7.4
08:29:43 <Saizan> because ($) :: forall (a :: *) (b :: *). (a -> b) -> a -> b
08:30:00 <danr> hmm is Wadler's "Comprehending Monads" the first article published about Monads in Haskell?
08:30:42 <dbbddbdb> Saizan: thanks!  Btw how do you get the kind info in GHCi?
08:31:35 <Saizan> dbbddbdb: not sure
08:31:37 <kallisti> I'm guessing that calling freeHaskellFunPtr on a FunPtr that doesn't refer to a Haskell function will cause a segfault?
08:32:21 <kallisti> silent failure would be nice, but I'm not sure how the RTS works and so I don't know if it's even possible to do that.
08:33:48 <johnsingleton> if I am in the IO monad via a do block, but need to use the results of an IO (say, read from a file) for a subsequent computation, what is the best way to handle something like that?
08:33:49 <elliott> dbbddbdb: You don't, I think.
08:33:57 <elliott> dbbddbdb: You can get the kind of a type with :k.
08:34:13 <elliott> Although, hmm, doesn't lambdabot print kinds in its type signatures?
08:34:26 <kallisti> johnsingleton: depends, but most likely you just want to use the <- notation
08:34:29 <elliott> johnsingleton: foo <- ioAction; ...
08:34:48 <johnsingleton> leme put a paste together to make it more clear where I am tripping up
08:34:51 <elliott> e.g. main = do { foo <- readFile "foo.txt"; putStr foo }
08:36:44 <hpaste> johnsingleton pasted “?” at http://hpaste.org/57476
08:36:58 <johnsingleton> http://hpaste.org/57476
08:37:11 <johnsingleton> well there you go, hpastebot wasn't doing that for me yesterday ;)
08:37:42 <Saizan> johnsingleton: what is the type of messages?
08:37:57 <johnsingleton> its [Message]
08:38:21 <Saizan> but you're using it as a function
08:38:32 <Saizan> that's not going to work
08:38:36 <mux> darcs cabal-install does work fine (0.13.3)
08:38:38 <kallisti> johnsingleton: messages Just m   looks quite suspect to me
08:39:12 <johnsingleton> Saizan: oh, I misspoke, let me update for clarity
08:39:45 <hpaste> johnsingleton annotated “?” with “? (annotation)” at http://hpaste.org/57476#a57477
08:39:55 <johnsingleton> maybe that is more clear
08:40:18 <kallisti> johnsingleton: there's nothing named messages anywhere in that annotation
08:40:26 <kallisti> oh
08:40:27 <Saizan> kallisti: it's a field of Yammers
08:40:27 <kallisti> wait
08:40:29 <elliott> yes
08:40:29 * kallisti is blind.
08:40:30 <elliott> there is :)
08:40:36 <Saizan> messages :: Yammers -> [Message]
08:40:39 <elliott> johnsingleton: messages :: Yammers -> [Message]
08:40:40 <johnsingleton> right
08:40:44 <elliott> Just :: a -> Maybe a
08:40:47 <elliott> why're you passing Just?
08:40:56 <johnsingleton> apparently because I am retarded
08:41:02 <johnsingleton> ack
08:41:14 <elliott> it sounds like you want to extract a Yammers from m instead
08:41:15 <Saizan> to extract the [Message] out of Maybe [Message]
08:41:21 <johnsingleton> elliot, yes
08:41:23 <elliott> Saizan: where is the Maybe [Message]?
08:41:30 <elliott> johnsingleton: let Just m =  decodeYammers json
08:41:35 <elliott> johnsingleton: if you don't want to handle errors
08:41:36 <Saizan> elliott: yeah, sorry, Maybe Yammers
08:41:42 <elliott> Saizan: right
08:42:17 <johnsingleton> so why do I need to call it in the assignment?
08:42:20 <kallisti> if you do want to handle errors you can use something in Data.Maybe, do an explicit case expression, or perhaps use the Maybe monad.
08:42:39 <elliott> johnsingleton: You're not calling anything.
08:42:42 <Saizan> johnsingleton: are you familiar with Haskell pattern matching?
08:42:42 <elliott> johnsingleton: It's pattern-matching.
08:43:06 <johnsingleton> I am familiar with it, I just didn't' realize I had to use it here
08:43:16 <kallisti> johnsingleton: it's one way to do, not the only way.
08:43:24 <johnsingleton> is this the situation where it could be rewritten to a case?
08:43:26 <elliott> johnsingleton: you could also use "case" on m
08:43:28 <elliott> yes
08:43:29 <elliott> to handle the Nothing
08:43:32 <kallisti> another way, in the case where you don't want to handle errors, is to use fromJust
08:43:34 <johnsingleton> eg: Just o, Nothing o
08:43:36 <kallisti> in Data.Maybe
08:43:37 <elliott> let m = decodeYammers json; case m of Nothing -> ...; Just y -> ...
08:43:42 <elliott> johnsingleton: not Nothing o, just Nothing
08:43:46 <elliott> Nothing doesn't contain a value
08:43:50 <elliott> kallisti: no
08:43:57 <elliott> kallisti: never use fromJust over a "let" binding
08:43:58 <johnsingleton> ah, yes
08:44:03 <kallisti> elliott: because...?
08:44:05 <elliott> the latter gives a line number on failure
08:44:07 <kallisti> ah
08:44:09 <elliott> the former just dies (and should never be used, ever)
08:44:11 <johnsingleton> I've heard that
08:44:23 <elliott> fromMaybe (error "descriptive internal error message") is sometimes OK.
08:44:24 <kallisti> elliott: I've found uses for it. >_>
08:44:31 <elliott> but johnsingleton probably wants to handle the Nothing explicitly here
08:44:42 <johnsingleton> elliott: you are correct
08:44:53 <kallisti> in particular, after constructs such as:  when (blah && isJust foo) $ ...
08:45:11 <elliott> kallisti: we really need a name for that antipattern.
08:45:18 <elliott> null->(head,tail) and isJust->fromJust and ...
08:45:32 <elliott> it's what pattern-matching is for
08:45:33 <kallisti> I don't think it's an antipattern. o_o
08:45:36 <elliott> of course it is
08:45:54 <elliott> you're decoupling the checking of the safety of an operation from performing it
08:46:02 <elliott> and abandoning all static guarantees and readability in the process
08:46:51 <shachaf> elliott: And ==0 -> subtract 1 and -- wait.
08:47:18 <elliott> shachaf: Yes, we need a natural number type. :(
08:47:25 <shachaf> elliott: I think it was given a name somewhere.
08:47:30 <elliott> kallisti: case foo of Just x | blah -> ...; _ -> ...
08:47:48 <donri> "Safe-Infered" isn't this mispelled?
08:47:54 <elliott> (In this case the second ... is probably return ())
08:47:55 <elliott> donri: yes
08:48:00 <shachaf> Maybe in <http://existentialtype.wordpress.com/2011/03/15/boolean-blindness/>
08:48:18 <kallisti> elliott: there are situations (especially within the IO monad) where the use of isJust and fromJust are more concise. readability is highly dependent on several unknown factors here.
08:48:19 <mzero> are you trying to parse a single string as a sequence of JSON objects, and simply skip those that don't parse as a Yammer?
08:48:30 <shachaf> Hey, it's mzero.
08:49:01 <elliott> kallisti: No, that's never OK.
08:49:04 <shachaf> mzero: Is there anything I can do to help with BayHac?
08:49:10 <elliott> shachaf: Yes, that blog post is a good summary of the issues.
08:49:33 <otters> is the actual definition of Monad [] somewhere
08:49:49 <shachaf> In many places.
08:49:56 <mauke> instance Monad [] -- Defined in GHC.Base
08:50:15 <mzero> shachaf: give Hacker Dojo $250k -- http://www.hackerdojo.com/Assemble
08:50:18 <elliott> otters: Prelude.
08:50:49 <kallisti> elliott: perhaps if case expressions could be curried (or lambda expressions could contain multiple cases)
08:51:37 <otters> elliott: I feel dumb...I can't findi t
08:51:50 <parcs`> @src [] return
08:51:50 <lambdabot> return x    = [x]
08:51:52 <parcs`> @src [] >>=
08:51:52 <lambdabot> Source not found.
08:51:55 <elliott> otters: Where are you looking for it?
08:51:55 <parcs`> @src [] (>>=)
08:51:56 <lambdabot> xs >>= f     = concatMap f xs
08:51:56 <otters> oh, okay
08:51:59 <mzero> johnsingleton: there are several issues you may both ohave thought of
08:51:59 <elliott> Are you having problems using it?
08:52:08 <otters> no I'm just curious
08:52:14 <elliott> kallisti: Your example does not partially apply properly at all.
08:52:15 <johnsingleton> mzero: wrt?
08:52:18 <elliott> otters: Ah. Then yes, what parcs` said :)
08:52:34 <johnsingleton> oh, readign
08:52:35 <mauke> or what I said
08:52:45 <elliott> That too.
08:52:48 <elliott> kallisti: For partial application/lambdas, the correct choice is maybe.
08:52:58 <mzero> for example, is your input a single large JSON, or multiple JSONs?
08:53:07 <mzero> the later will be VERY hard to parse in light of any errors
08:53:13 <elliott> (\m -> if isJust m then f (fromJust m) else x) --> (maybe x f)
08:53:25 <elliott> mzero: It looks like johnsingleton is parsing one JSON with a list in it.
08:53:36 * elliott is confused.
08:53:49 <mzero> if it is a large JSON, you'll need to parse the whole thing into a value of type Value first, then index it, and individually parseJSON them ---
08:53:56 <johnsingleton> mzero: to start with, I am doing a series of JSONs, all with the same schema
08:54:08 <johnsingleton> I've got it working so far for that
08:54:08 <mzero> and not use the convenience function - since that will fail if one fails
08:54:36 <mzero> also - it seems very odd to have curlForMessages return String and not ByteString ---
08:54:40 * hackagebot husk-scheme 3.5.2 - R5RS Scheme interpreter, compiler, and library.  http://hackage.haskell.org/package/husk-scheme-3.5.2 (JustinEthier)
08:54:47 <johnsingleton> the deal is that the Yammer service only returns 30 messages at a time
08:54:51 <otters> why do people use bytestring instead of String?
08:54:54 <mzero> JSON is generally handed around in terms of bytes, not Char
08:54:59 <johnsingleton> otters: faster
08:55:02 <elliott> otters: For when they're using ByteStrings.
08:55:05 <otters> I'm just getting into haskell so I figure it's probably better find out now
08:55:09 <otters> oh, faster
08:55:12 <mzero> because JSON is defined, by RFC, over octets, not Unicode characters
08:55:16 <shachaf> mzero: That's a bit on the high side, unfortunately.
08:55:16 <mauke> otters: ByteString has no speed
08:55:18 <elliott> otters: ByteString is [Word8] but strict and fast and it has much less memory usage. Text is [Char] but strict and fast and it has much less memory usage.
08:55:18 <mauke> it's a type
08:55:26 <otters> I see
08:55:28 <elliott> (Fast as in many common operations on it.)
08:55:32 <elliott> otters: String is [Char] and sucks.
08:55:36 <otters> okay
08:55:39 <mzero> shachaf - otherwise, we're going to have to think about fall-back venues
08:55:45 <elliott> But you should not replace String with Char; replace String with Text, and use ByteString when you're dealing with 8-bit binary data.
08:55:51 <kallisti> elliott: how would you rewrite this then: http://hpaste.org/57478
08:55:56 <shachaf> mzero: I don't imagine they'll be done in the next few months no matter what.
08:56:02 <johnsingleton> ok, so what I was going to say was that messages returns [Message] -- all I am doing is serializing each one of them out to JSON, and writing them to a file
08:56:17 <kallisti> elliott: oops, forgot the M.size nums > 1  condition
08:56:40 <johnsingleton> and I convert my String to a ByteString when I pass it to decode
08:56:52 <mzero> not clear - the city have already granted them a reprieve and next hearing will be March 6th
08:56:53 <johnsingleton> json = decode $ C.pack json
08:57:10 <mauke> when (M.size nums > 1) $ maybe def (`addReplyHandler` M.delete cmd nums)
08:57:21 <johnsingleton> Maybe curl has a ByteString return
08:57:24 <hpaste> elliott annotated “kallisti” with “kallisti (annotation)” at http://hpaste.org/57478#a57479
08:57:39 <elliott> (using Data.Foldable.mapM_)
08:57:43 <elliott> (for the second one)
08:57:47 <elliott> Argh
08:57:51 <elliott> s/(fromJust info')/info/ in the second one
08:57:58 <hpaste> elliott annotated “kallisti” with “kallisti (annotation) (annotation)” at http://hpaste.org/57478#a57480
08:58:27 <mzero> johnsingleton: that would be better - as I'm not sure C.pack is undoing the translation that Curl did to take bytes into strings --- did it Utf8 decode or pack bytes 0x00 - 0xFF into characters U+0000 - U+00FF
08:58:30 <mzero> ?
08:59:05 <mzero> you must make sure, if you go via String, that you are undoing what Curl did (since, after all, it got bytes on the wire!)
08:59:20 <kallisti> elliott: I'm not sure I understand what static guarantee is lost by the original code. Also, it's quite a bit shorter and (I would argue) clearer.
08:59:21 <mzero> hence, why it is better to keep things in ByteString - removes possibility of confusion
08:59:37 <johnsingleton> Honestly I'm not a real UTF wizard; I don't know what it is doing under the hood. I'll see if I can get a ByteString out of CURL
08:59:40 * hackagebot mainland-pretty 0.1.1.0 - Pretty printing designed for printing source code.  http://hackage.haskell.org/package/mainland-pretty-0.1.1.0 (GeoffreyMainland)
09:00:01 <elliott> kallisti: You could argue that, but you would be completely wrong.
09:00:29 <_Mikey> does this sound like bad code to you guys?
09:00:31 <mauke> kallisti: what about my line?
09:00:38 <mzero> johnsingleton: *that* is exactly why you want to just pass the bytes along! :-)
09:00:45 <kallisti> mauke: oh I didn't see it.
09:00:51 <mauke> when (M.size nums > 1) $ maybe def (`addReplyHandler` M.delete cmd nums)
09:00:52 <_Mikey> I have a function taking 6 parameters each of them quite complex types
09:00:58 <johnsingleton> mzero: looks like curlGetString_ might be the ticket
09:01:02 <otters> hahaha snoc
09:01:03 <_Mikey> and I'm returning a 4 tuple
09:01:20 <_Mikey> each type in the tuple also quite complex.
09:01:27 <elliott> kallisti: Sorry, when I said mapM_, that shold have been forM_.
09:01:41 <elliott> mauke: That doesn't work.
09:01:43 <kallisti> ah, right.
09:01:45 <elliott> You omitted info'.
09:01:51 <mzero> johnsingleton: if your stream has a series of JSON entities - something like "{ id: ... }{ id: ... }"
09:01:57 <mauke> elliott: very true
09:02:08 <elliott> when (M.size nums > 1) $ forM_ info (`addReplyHandler` M.delete cmd nums) -- I think this is nicer, avoids the "def"
09:02:20 <kallisti> :t forM
09:02:21 <lambdabot> forall a (m :: * -> *) b. (Monad m) => [a] -> (a -> m b) -> m [b]
09:02:21 <johnsingleton> mzero: id is in there, but quoted...
09:02:38 <mzero> then you will have to use the Parser interface to parse them back -- since you'll pass that whole string, parse a *single* JSON value off it, and then know what part wasn't consumed, and then recursively use that to parse the next version
09:02:40 <kallisti> elliott: info isn't a list though.
09:02:42 <mauke> :t Data.Foldable.forM_
09:02:43 <lambdabot> forall (t :: * -> *) a (m :: * -> *) b. (Data.Foldable.Foldable t, Monad m) => t a -> (a -> m b) -> m ()
09:02:52 <mauke> it is now
09:03:04 <elliott> kallisti: Data.Foldable.forM_, as I said.
09:03:06 <mzero> notice the difference from if your stream was    "[{id:...},{id:...}]"
09:03:15 <mzero> (yes, I'm being loose with quoting) --
09:03:15 <kallisti> elliott: oh okay.
09:03:29 <mzero> that is a single JSON array, and is parsed with a single call
09:04:48 <johnsingleton> mzero: here is what the actual schema looks like: http://hpaste.org/57481
09:04:53 <mzero> both have their pros and cons --- the later can be parsed with a single line of code... but you will pull the entire structure into memory (okay if you're not anticipating megabytes) --- the former can be parsed piece meal
09:05:22 <mzero> johnsingleton: Is there a single one of those whole things in the file -- or multiple?
09:05:44 <johnsingleton> mzero: per call, exactly as pasted
09:05:57 <elliott> mzero: Google implies johnsingleton doesn't get to choose the format: https://www.yammer.com/
09:06:12 <mzero> ah - then you're fine --- as long as you don't mind parsing the whole thing in memory at once
09:06:14 <johnsingleton> I have to call it multiple times to fetch down 20 @ a time
09:06:24 <johnsingleton> mzero: I was going to write them out into file segments
09:06:39 <mzero> then you will have to do a more complicated read to read them back in
09:06:43 <mzero> which is fine, just be ware
09:06:52 <johnsingleton> mzero: ya, I was going to do some basic indexing
09:07:02 <johnsingleton> maybe group a single user's messages into each file
09:07:08 <johnsingleton> to make it easier to do my analysis
09:07:22 <johnsingleton> so I can say: getAllMessagesForUser
09:07:28 <johnsingleton> and have a really simple way to get all of them
09:07:55 <mzero> that sounds good - I'd avoid building indexing into files - painful - and the file system is good at that - just write one file per parable chunk
09:08:13 <johnsingleton> mzero: ok, coolness
09:08:23 <mzero> gotta run now - I'll be 'round laters
09:08:29 <johnsingleton> mzero: later!
09:10:34 <BlankVerse> lambdabot: > 5 + 2
09:10:39 <BlankVerse> > 5 + 3
09:10:40 <lambdabot>   8
09:10:58 <BlankVerse> @hoogle fromForeignPtr
09:11:00 <lambdabot> No results found
09:11:13 <mekeor> @hayoo fromForeighnPtr
09:11:14 <lambdabot> Unknown command, try @list
09:11:45 <mekeor> hayoo knows more functions than hoogle, i think; doesnt it?
09:12:49 <kallisti> BlankVerse: are you looking for FunPtr a -> a  ?
09:13:21 <kallisti> oh
09:13:27 <kallisti> ForeignPtr. again, I'm blind.
09:16:49 <honza> Good afternoon fine sirs, I just discovered the wonderful world of functional programming via haskell and wanted to say hello.
09:17:34 <otters> hi honza
09:21:00 <hpaste> fisher pasted “rascal 10” at http://hpaste.org/57482
09:21:45 <otters> what an intriguing paste
09:23:48 <shachaf> It's code for generating rows of the Rascal triangle.
09:24:00 <shachaf> A favorite pastime in this channel.
09:24:31 <CodeWeaverX> The… "rascal" triangle?
09:24:40 * hackagebot hlint 1.8.23 - Source code suggestions  http://hackage.haskell.org/package/hlint-1.8.23 (NeilMitchell)
09:26:56 <Taneb> After Dizzie Rascal
09:26:57 <magicman> Something unexpected happened:
09:26:58 <magicman> Info: Time limit exceeded before requested slots found (1)
09:27:29 <mike-burns> Is it non-sequitor day?
09:27:37 <CodeWeaverX> We like pizza!
09:32:52 <johnsingleton> if I have a custom data type that I'd like to be able to use maximum on when it is in a list, only say, I want an ID field to be what decides if one is greater than the other, do I implement Ord for that type to make maximum work like I want?
09:33:23 <DrSyzygy> @type maximumBy
09:33:24 <lambdabot> forall a. (a -> a -> Ordering) -> [a] -> a
09:33:35 <CodeWeaverX> I am now in love with Rascal's triangle.  What a delightful story.
09:33:49 <DrSyzygy> johnsingleton: You can hand maximumBy an arbitrary ordering function and it'll pick up the maximum wrt that.
09:34:21 <johnsingleton> DrSyzygy: Which way is the preferred way in Haskell land?
09:34:24 <DrSyzygy> johnsingleton: And if there is some function value you want to compare ordinarily on, there's the function on to do that.
09:34:33 <DrSyzygy> johnsingleton: maximumBy IMO.
09:34:42 <CodeWeaverX> Well, defining Ord means you have one ordering ever for your type.
09:34:46 <CodeWeaverX> For every operation.
09:34:48 <CodeWeaverX> Kind of heavy handed.
09:34:57 <DrSyzygy> johnsingleton: And you can do things like maximumBy (compare `on` someFunction)
09:34:58 <johnsingleton> yeah, I guess that's true
09:35:05 <DrSyzygy> if you just want, say, the ID field.
09:35:07 <DrSyzygy> so
09:35:17 <DrSyzygy> maximumBy (compare `on` idField) myData
09:35:36 <johnsingleton> DrSyzygy: that is ho
09:35:36 <johnsingleton> t
09:35:39 <johnsingleton> *hot
09:35:42 <CodeWeaverX> ooh, what's the `on` do?  *goes hunting*
09:35:48 <Tomsik> :t on
09:35:49 <lambdabot> forall b c a. (b -> b -> c) -> (a -> b) -> a -> a -> c
09:35:51 <Tomsik> not much
09:35:55 <DrSyzygy> CodeWeaverX: It does the right compositions for you.
09:36:05 <Tomsik> @src on
09:36:06 <lambdabot> (*) `on` f = \x y -> f x * f y
09:36:06 <DrSyzygy> @source on
09:36:06 <lambdabot> on not available
09:36:13 <johnsingleton> awesometown
09:36:14 <DrSyzygy> Oh, @src was how to do that.
09:36:14 <CodeWeaverX> Oh fiddle, that's word salad to me before I've had lots of coffee.
09:36:19 <Jafet> newtype CompareByID = CompareByID T; instance Ord CompareByID where compare = compare `on` getID
09:36:33 <elliott> CodeWeaverX: (foo `on` field) x y == field x `foo` field y
09:36:37 <Tomsik> Jafet, ugly :p
09:36:39 <elliott> Consider foo = compare.
09:36:53 <Tomsik> :t on compare
09:36:54 <lambdabot> forall b a. (Ord b) => (a -> b) -> a -> a -> Ordering
09:37:10 <CodeWeaverX> elliott: That's brilliant.
09:37:14 <CodeWeaverX> And much clearer.
09:37:15 <CodeWeaverX> Thanks.
09:37:38 <elliott> Note that (compare `on`) === comparing.
09:37:45 <CodeWeaverX> And now I must study the heck out of that.  Higher order functions I'm only fair to middlin' on yet.
09:38:11 <elliott> what I gave was literally the definition :P
09:38:15 <elliott> if you replace the == with a =
09:38:30 <DrSyzygy> elliott: And flip them around
09:38:35 <DrSyzygy> comparing = (compare `on`)
09:38:36 <CodeWeaverX> I know, but telling me it allows right-compositions doesn't gell in my mind.
09:38:41 <CodeWeaverX> Not yet.
09:38:42 <elliott> DrSyzygy: No, <elliott> CodeWeaverX: (foo `on` field) x y == field x `foo` field y
09:38:44 <CodeWeaverX> *finds coffee*
09:39:03 <DrSyzygy> elliott: Oh, that one.
09:39:05 <johnsingleton> DrSyzygy: what module does `on` come from?
09:39:12 <DrSyzygy> johnsingleton: Check hoogle.
09:39:18 <johnsingleton> I am ;)
09:39:21 <johnsingleton> heh
09:39:48 <johnsingleton> ah
09:39:52 <johnsingleton> ok, Data.Function
09:39:57 <johnsingleton> yes?
09:40:04 <mike-burns> base
09:40:07 <mike-burns> But yes.
09:41:08 <Phantom_Hoover> CodeWeaverX, stop being terrible.
09:41:36 <elliott> o_O
09:41:45 <johnsingleton> having a function like maximumBy makes implementing comparators look like the stone age central
09:42:44 <CodeWeaverX> "stop being terrible"?
09:42:50 <CodeWeaverX> okayyyy, will try.
09:42:51 <CodeWeaverX> O.o
09:42:52 <CodeWeaverX> :)
09:43:43 <johnsingleton> stop me if I am asking too many questions, but I am learning a lot :)
09:44:08 <johnsingleton> is there a cleaner way to write: something like: export $ mid $ maximumBy (compare `on` mid) (messages y)
09:44:25 <johnsingleton> I feel like I have too many $'s in there
09:44:31 <Tomsik> .
09:44:36 <Tomsik> That's the answer
09:44:45 <elliott> johnsingleton: export . mid . maximumBy (compare `on` mid) . messages $ y
09:44:48 <Clint> @pl export $ mid $ maximumBy (compare `on` mid) (messages y)
09:44:48 <lambdabot> export (mid (maximumBy (compare `on` mid) (messages y)))
09:44:51 <monochrom> I would just use parentheses. export (mid (etc
09:44:53 <Clint> huh
09:45:13 <monochrom> what lambdabot says :)
09:45:14 <Botje> export . maximum . map mid $ messages y
09:45:16 <glguy> johnsingleton: Either use parentheses or break it down and name some of the subcomponents so that someone else can read it
09:45:38 * shapr hugs glguy 
09:45:42 <elliott> Botje: Uh.
09:45:44 <Tomsik> :t export
09:45:45 <lambdabot> Not in scope: `export'
09:45:46 <glguy> Botje: looks a bit asymmetric :)
09:45:51 <elliott> Botje: That will not work.
09:45:59 <johnsingleton> I personally find  the composition marks hardish to read
09:46:05 <elliott> johnsingleton: oh, export . mid . maximumBy (comparing mid) . messages $ y of course
09:46:07 <ClaudiusMaximus> @check \f xs -> f (maximumBy (comparing f) xs) == maximum (map (f::Int->Int) (xs::[Int]))
09:46:08 <lambdabot>   Overlapping instances for GHC.Show.Show
09:46:09 <lambdabot>                              (GHC.T...
09:46:20 <elliott> johnsingleton: (f . g $ x) is much better than (f $ g $ x) because you can factor (f . g) out into a function
09:46:23 <elliott> simply by doing h = f . g
09:46:34 <Botje> it's a bit silly to do mid . maximumBy (compare `on` mid)
09:46:37 <johnsingleton> oh, interesting
09:46:38 <Tomsik> johnsingleton, apparently it's a matter of taste, I like the dot operator a lot, it reads just as pipelines
09:46:45 <Botje> unless i'm missing something
09:46:49 <ClaudiusMaximus> @check \(Blind f) xs -> f (maximumBy (comparing f) xs) == maximum (map (f::Int->Int) (xs::[Int]))
09:46:50 <lambdabot>   Not in scope: data constructor `Blind'
09:47:00 <elliott> Botje: oh, i see
09:47:07 <elliott> sorry, yes, Botje is totally right
09:47:11 <tazjin> What is the easiest way to get this Happstack guard to work: http://hpaste.org/57485 ? (It fails because isValidSession as an argument to unless is inside the ServerPartT Monad)
09:47:14 <elliott> (except I'd turn "map mid $ messages y" into "map mid . messages $ y")
09:47:51 <nand`> using elliott's form you can probably eta reduce the y as well
09:47:55 <glguy> I find the a . b . c . d $ x   style hard to look at
09:48:13 <glguy> if I find myself doing it I'll at least write:    let thing = a . b . c . d;  result = thing x
09:48:14 <nand`> if your function looks the way I think it does
09:48:17 <glguy> and find a name for the process
09:48:26 <mekeor> @quote nand`
09:48:26 <lambdabot> Plugin `quote' failed with: getRandItem: empty list
09:48:31 <monochrom> I would a (b (c (d x))) or (a . b . c . d) x. I have no $
09:48:34 <ClaudiusMaximus> i find it annoying when i want to use it as a subexpression - prefer (f . g . h) a == (i . j . k) b
09:48:54 <Jaxan> glguy: why not a $ b $ c $ d $ x
09:49:10 <elliott> Jaxan: ugly, hard to refactor
09:49:14 <glguy> Jaxan: I'm not against that
09:49:53 <nand`> a $ b $ c $ d $ x is very hard to read compared to a . b . c . d $ x, if you ask me
09:50:15 <monochrom> I think people avoid parentheses too much
09:50:31 <johnsingleton> let me make sure I get that composition
09:50:38 <glguy> long chains of applications are best used in IRC channels where newlines are expensive
09:52:08 <mike-burns> a $ b $ c $ d $ x    means that you need a better abstraction somewhere.
09:52:29 <ClaudiusMaximus> @quote <?
09:52:30 <lambdabot> monochrom says: math is open source. patches welcome. and oh, the author doesn't understand it either. life is a bitch, isn't it? :)
09:52:32 <johnsingleton> export . mid . maximumBy (compare `on` mid) . messages $ y === export  (mid  ( maximumBy (compare `on` mid)  messages $ y))
09:52:36 <monochrom> if a.b.c.d isn't used elsewhere, there is nothing to abstract
09:52:37 <johnsingleton> is that right?
09:53:03 <nand`> johnsingleton:  oh god
09:53:06 <nand`> use applicatives
09:53:13 <tommd> Has there been any news on the repa/GHC7.4 front?
09:53:15 <elliott> How do applicatives help there?
09:53:21 <nand`> wait
09:53:23 <nand`> let me reread
09:53:23 <elliott> johnsingleton: (f . g $ x) is the same as (f $ g $ x)
09:53:36 <elliott> johnsingleton: (Of course, (f . g) is not the same as (f $ g).)
09:53:42 <monochrom> yes johnsingleton
09:53:43 <nand`> oh, I thought you were using === as a function
09:54:04 <elliott> johnsingleton: Anyway, Botje is right: export . maximum . map mid . messages $ y is better
09:54:10 <johnsingleton> hand` -- I don't know how to type "tautology" in IRC ;)
09:54:15 <elliott> since you just apply mid at the end anyway
09:54:45 <johnsingleton> oh, that's smart
09:55:33 <johnsingleton> coolness
09:55:37 <monochrom> no, I erred, they are not equal
09:56:28 <johnsingleton> drat
09:56:33 <monochrom> replace "maximumBy (compare `on` mid)  messages $ y" by "maximumBy (compare `on` mid)  (messages y)"
09:56:54 <strager> @pl export . mid . maximumBy (compare `on` mid) . messages $ y
09:56:55 <lambdabot> export (mid (maximumBy (compare `on` mid) (messages y)))
09:57:02 <johnsingleton> monochrom: oh, right
09:57:03 <strager> lambdabot hates you all.
09:57:03 <monochrom> you are looking at "f g $ x" vs "f (g x)"
09:57:08 <johnsingleton> I get it
09:57:22 <strager> @pl export . mid . maximumBy (compare `on` mid) . messages
09:57:22 <lambdabot> export . mid . maximumBy (compare `on` mid) . messages
09:57:28 <johnsingleton> lambdabot is afraid of change ;)
09:57:51 <monochrom> @pl \y -> e . m $ y
09:57:51 <lambdabot> e . m
09:57:57 <monochrom> that's how you do it
09:59:56 <danharaj> I wonder if (.) is the most common operator in haskell source.
10:00:32 <opqdonut> probably is
10:00:35 <otters> I use $ even when I don't need to, because it looks good in Consolas
10:00:42 <otters> (not in production code)
10:00:43 <johnsingleton> does anyone here use Haskell as their primary language @ work?
10:00:51 <otters> if I worked, I would
10:00:55 <Rmx> (not in production code) -> why ?
10:01:22 <otters> because using things you don't need to unnecessarily is not production code quality practice
10:01:27 <otters> hmm
10:01:32 <otters> I appear to have a redundancy there
10:01:37 <otters> nurse!
10:01:48 <strager> johnsingleton: I do.  =]
10:01:49 <CodeWeaverX> I'd love to use it at work.  I *do* occasionally hold a lecture day or a lecture lunch and use haskell as a teaching tool.  Increasing the mental toolkit and all that.
10:02:18 <Rmx> hm, $ comes with implementation cost? o_O
10:02:20 <johnsingleton> strager: what kinda work does your shop do?
10:02:25 <strager> Though I wouldn't really say my skills are good enough for it to BE a primary language I deal with.
10:02:30 <elliott> otters: wat
10:02:30 <lambdabot> elliott: You have 1 new message. '/msg lambdabot @messages' to read it.
10:02:31 <c_wraith> Rmx: not with the most basic of optimizations
10:02:34 <elliott> ($) is just notation.
10:02:36 <johnsingleton> heh
10:02:39 <otters> right
10:02:52 <strager> johnsingleton: http://spaceport.io/  There are some back-end tools I'm working on with Haskell.
10:02:53 <Rmx> ok
10:02:57 <elliott> Sure, it's defined in the Prelude, but it's literally one inlining away from not existing, and you'd have to try really hard to have GHC not inline it.
10:02:59 <Rmx> thanks
10:03:09 <otters> oh yeah
10:03:12 <c_wraith> elliott: it's a real function. It would have overhead if ghc didn't simplify
10:03:30 <elliott> c_wraith: yeah, but it does :P
10:03:37 <johnsingleton> strager: coolness!
10:03:44 <c_wraith> It's still a legit question
10:03:48 <strager> I can't talk about them though.  Such is life.  =]
10:03:55 <elliott> c_wraith: I wasn't responding to Rmx's question.
10:03:56 <johnsingleton> certainly
10:03:58 <johnsingleton> strager: are you guys getting a lot out of using haskell?
10:04:00 <elliott> I was responding to otters.
10:04:11 <otters> seems like an awful easy function to simplify
10:04:15 <johnsingleton> you don't have to be specific, obviously
10:04:29 <otters> I mean, Consolas's dollar sign is really good
10:04:42 * hackagebot hepevt 0.3.2 - HEPEVT parser and writer  http://hackage.haskell.org/package/hepevt-0.3.2 (ScottLawrence)
10:04:47 <strager> johnsingleton: Well I'm the only one using it, and I'm on an isolated project.  But yes, we're getting a lot out of it after only a month and a half of development.  (I'd wager it'd take twice as long in C++ and 1.5 times as long in a managed language like Java.)
10:05:03 <strager> Haskell's amazing and transforming and streaming data, lemme tell you =]
10:05:57 <johnsingleton> strager: I don't doubt that… I'm just getting my feet wet with my little JSON experiment and I'm quite impressed with how you get FORCED into doing it correctly
10:06:17 <johnsingleton> heh
10:06:21 <strager> Well, sadly Haskell doesn't force you to name stuff properly.
10:06:30 <cmccann> @faq does Haskell let you write incorrect code?
10:06:30 <lambdabot> The answer is: Yes! Haskell can do that.
10:06:33 <strager> When I started I prefixed all the names of a module, C-style.  =D
10:06:39 <nyingen> johnsingleton: I would hazard that maintainability is one of haskell's great strengths
10:06:46 <cmccann> don't overestimate how much you're forced to be correct, it's still possible to write broken code :P
10:06:57 <otters> @faq
10:06:57 <lambdabot> The answer is: Yes! Haskell can do that.
10:07:01 <nyingen> I use haskell extensively for writing little tools and whatnot, and the ease of extending them and refactoring them without getting a mess is great
10:07:07 <otters> @faq will Haskell give me testicular cancer?
10:07:07 <lambdabot> The answer is: Yes! Haskell can do that.
10:07:09 <otters> Damn.
10:07:26 <johnsingleton> hehe
10:07:33 <tazjin> @faq Will Haskell cause testicular torsion?
10:07:34 <lambdabot> The answer is: Yes! Haskell can do that.
10:07:34 <cmccann> @faq can Haskell cure otters's cancer?
10:07:34 <lambdabot> The answer is: Yes! Haskell can do that.
10:07:43 <nyingen> but haskell doesn't cause ovarian cancer
10:07:50 <otters> neat
10:08:16 <otters> do { c <- metastatize $ getTesticles $ otters; demetastatize c }
10:08:21 <johnsingleton> I just mean "forced" in the smallest sense of the words: non-exhaustive pattern matching warnings for example
10:08:30 <johnsingleton> eg: there are some cases you haven't considered
10:08:34 <elliott> cmccann: btw: done
10:08:36 <strager> I really like how it's really annoying to create data structures with 300 parameters.  That kind of thing is easy in OOP languages.
10:08:56 <Rmx> I don't really agree
10:08:58 <elliott> strager: Don't worry; soon we'll fix the record system and it'll get easy.
10:09:00 <johnsingleton> strager: right, so it forces you to not do it! haha
10:09:00 <cmccann> johnsingleton, Haskell gives you many tools for forcing yourself to write correct code, which I think is a better way to look at it
10:09:00 <Rmx> I find it rather easy
10:09:05 <strager> elliott: noooo =[
10:09:08 <Rmx> why do you all say so ?
10:09:10 <otters> Keep it annoying
10:09:16 <CodeWeaverX> I can totally write a haskell program to automatically generate from a comma delimited list a massive 10,000 element data structure.  Dare me.
10:09:17 <CodeWeaverX> ;)
10:09:19 <johnsingleton> cmccann: I'd agree witht hat
10:09:22 <johnsingleton> that
10:09:23 <johnsingleton> and hat
10:09:23 <otters> no
10:09:26 <CodeWeaverX> hahahahaha
10:09:54 <Tomsik> elliott: is this true? Records will be fixed?
10:09:54 <tazjin> What's wrong with the current record system?
10:10:03 <johnsingleton> honestly, coming from javabean-landia -- I welcome the lack of lots of record members ;)
10:10:10 <Rmx> I'm interested in the answer too
10:10:24 <otters> I have a record member if anybody wants to see it
10:10:31 <johnsingleton> heh
10:10:44 <strager> Well I think it's more of a psychological thing.  I feel guilty if I add a member to a record.
10:10:48 <elliott> Tomsik: Well, you know... in theory.
10:11:07 <johnsingleton> right, like you are more careful
10:11:14 <cmccann> elliott, broke 200, eh?
10:11:17 <johnsingleton> because you are junking up the namespace
10:11:51 <Tomsik> I think there was a few proposals how to fix them and probably just any of them would be better than the status quo
10:11:58 <strager> That or you end up with MyRec String String Int String a (MyRec Int) (Map a String)
10:12:27 <Tomsik> Instead we get such lowly things like constraint kinds :P
10:12:46 * cmccann mostly cares about record accessors being first-class
10:13:02 <elliott> cmccann: maybe :P
10:13:04 <cmccann> better namespace management would be nice in general
10:13:12 <elliott> technically, record accessors are first-class.
10:13:16 <cmccann> but I don't see why records themselves are such a big deal
10:13:18 <elliott> they're values and all that
10:13:46 <cmccann> elliott, you can't take a field accessor as an argument and then set it with record syntax, stuff like that
10:14:30 <elliott> cmccann: oh, I interpreted "accessor" as "getter"
10:14:34 <strager> cmccann: I actually wanted that once and was sad I couldn't do it.  =[
10:14:37 <tazjin> That would be pretty useful
10:14:59 <cmccann> elliott, I mean the automagic stuff that you get from record syntax in general, yeah
10:15:15 <cmccann> as getters they're regular functions, that's easy
10:15:43 <cmccann> but not being able to abstract over record updates makes the whole thing nearly worthless to my mind
10:15:46 <elliott> We should just replace (->) with Lens, and define: type a -> b = exists r. Lens a (b,r)
10:15:51 <elliott> the r is the residue from the computation
10:15:57 <elliott> Like reversible languages!
10:16:07 <strager> http://www.haskell.org/haskellwiki/Record_access
10:16:07 <cmccann> elliott, just use a linear type system
10:16:18 <irene-knapp> no - they're not just regular functions, see, the thing is that some of the proposals include ways to abstract on different record types having differently-typed-but-same-named fields
10:16:28 <irene-knapp> which currently you can't do
10:16:34 <elliott> irene-knapp: we're talking about the present
10:16:37 <irene-knapp> oh, okay
10:17:09 <elliott> irene-knapp: You can't do same-type-and-same-name fields now, either.
10:17:13 <irene-knapp> right
10:17:16 <cmccann> irene-knapp, ∀x. some record syntax proposal includes x.
10:17:22 <irene-knapp> cmccann: haha
10:17:38 * elliott thinks that solving *that* problem just for records is Silly.
10:17:54 <elliott> Anyway, what we *should* do is copy the ML module system basically wholesale, and then use modules as records.
10:18:26 <irene-knapp> well, if it's a goal to do this in a way that can be done without breaking existing code, using LANGUAGE pragmas
10:18:27 <cmccann> elliott, I still like the idea of making namespace scope a general feature of "where" clauses
10:18:30 <irene-knapp> then we can't really change the module system
10:18:45 <irene-knapp> also there's zero consensus anyway
10:18:48 <irene-knapp> so nothing is going to continue to happen
10:18:50 <ion> We definitely should copy the good stuff from other languages, such as monkey patching and method_missing from Ruby.
10:19:00 <elliott> cmccann: hmm, howso?
10:19:06 <eikke> ion: +1
10:19:11 <elliott> irene-knapp: Existing code sucks.
10:19:14 <elliott> ion++
10:19:24 <irene-knapp> elliott: fair position, perhaps, but not a popular one
10:19:52 <cmccann> elliott, definitions with a where clause introduce a new namespace scope and can export identifiers from it
10:20:31 <cmccann> elliott, so GADT syntax would allow helper functions for a data type to be in a separate namespace and optionally exported, classes could have implementation functions that aren't exported, &c.
10:20:32 <elliott> irene-knapp: You think most people like the code they're currently working on?
10:20:42 <cmccann> modules would just be the degenerate case of an empty definition with a where clause
10:20:49 <elliott> cmccann: oh, that's neat... but I don't see how it solves the same-name-field-in-two-records thing
10:21:09 <irene-knapp> elliott: well, no, there's that, but.
10:21:14 <cmccann> elliott, you'd be able to use them qualified, but without having to put every type in its own module
10:21:17 <elliott> cmccann: actually I would rather replace modules with records and use plain functions as ML functors... but that needs dependent types to work properly, I think
10:21:27 <elliott> (rather than replace records with modules)
10:21:36 <elliott> cmccann: and yeah, that sounds like a decent idea
10:22:27 <dolio> You can encode ML modules and functors in System F(_omega).
10:22:37 <dolio> Although using that encoding directly wouldn't be great.
10:23:09 <elliott> dolio: things like rank-n types and such make it fairly easy
10:23:12 <elliott> but it's still ugly ugly ugly
10:23:15 <elliott> typeclasses can sort of do it
10:23:43 <elliott> (of course, typeclasses should just be replaced with an "implicit overload of a type" system, and we'd make Num into a record type... sorry, are we talking about Haskell? :P)
10:25:16 <dolio> Like Scala?
10:25:30 <dolio> Because Scala's implicits cause no end of headaches.
10:25:44 * elliott doesn't know much about Scala, but assures you that his perfect language has no problems.
10:25:49 <cmccann> elliott, if I was designing my own language I'd just allow explicit functions from types to terms and be done with it, forget this implicit nonsense
10:25:55 <elliott> dolio: Do you have any examples?
10:26:13 <elliott> cmccann: you can't pattern-match on types, that's not OK :(
10:26:21 <dolio> No. Just that we waste tons of time on them at work.
10:26:33 <elliott> dolio: heh :)
10:26:39 <cmccann> elliott, I'd be allowing that as well, and probably a bunch of other unwise things
10:26:44 <eikke> implicits rock, dont they :P
10:26:51 <elliott> I think my favourite method for typeclassy-style overloading allows orphan instances and duplicate instances and all that stuff without the breakage you get with e.g. two sets with different Ord instances
10:26:51 <cmccann> it's not like I'm in any way qualified to design a language
10:26:58 <elliott> so, my pipe-dream language continues to rule
10:27:19 <dolio> Because there are tons of ad-hoc rules about which 'instances' get chosen in which scope and so on.
10:27:41 <elliott> dolio: Right. I'd probably just embed Prolog :P
10:27:42 <Eduard_Munteanu> Or like Agda's typeclasses.
10:27:46 <cmccann> dolio, are you sure the rule isn't simply "whichever instance you least expect will be chosen"?
10:27:53 <elliott> I mean, that's what everyone wishes Haskell's typeclass resolution was.
10:27:55 <Eduard_Munteanu> Presumably you could allow recursive resolution.
10:28:13 <cmccann> elliott, I think we'd want to set our sights higher than prolog
10:28:23 <dolio> cmccann: Yes. It has to choose the one you expect a sufficient proportion of the time to lull you into a false sense of security.
10:28:29 <elliott> cmccann: OK, Mercury!
10:29:31 <cmccann> dolio, it's just optimizing for total global unexpectedness, being too predictable would get in the way
10:29:43 * hackagebot cityhash 0.2.0.0 - Bindings to CityHash  http://hackage.haskell.org/package/cityhash-0.2.0.0 (AustinSeipp)
10:29:52 <elliott> also, the mechanism should, of course, be unified with things like coq/agda's implicit parameters
10:29:57 <elliott> and thus serve to fill in foralls too
10:30:54 <cmccann> forget type inference, we need more term inference
10:31:01 <mekeor> WTF? when i start GHCI and type ":m System.Random" i get this error: "<no location info>:     Could not find module `System.Random'. It is not a module in the current program, or in any known package."
10:31:42 <byorgey> mekeor: well, what's the output of 'ghc-pkg list random'?
10:31:50 <elliott> cmccann: that's what i just said :(
10:31:55 <elliott> coq and agda can actually do that
10:32:03 <cmccann> yes, I know
10:32:11 <mekeor> byorgey: "/var/lib/ghc/package.conf.d","/home/mekeor/.ghc/x86_64-linux-7.4.1/package.conf.d"
10:32:11 <cmccann> I was agreeing
10:32:18 <elliott> ah
10:32:28 <byorgey> mekeor: well, you don't have the random package installed.
10:32:41 <byorgey> mekeor: 'cabal install random'
10:32:41 <elliott> (the way to solve the multiple-instances problem, as far as I can tell, is simply to include the instances used in the type)
10:32:47 <mekeor> byorgey: but isnt it default?
10:32:55 <elliott> (e.g.. Set :: (a :: Type) -> Ord a -> Set)
10:32:57 <elliott> erm
10:32:58 <elliott> s/Set/Type/
10:33:12 <elliott> (and then make (Ord a) an implicit parameter)
10:33:22 <byorgey> mekeor: it comes with the Haskell Platform, but not with GHC
10:33:24 <mekeor> byorgey: works. thanks.  but isn't the random-package installed by default?
10:33:28 <mekeor> byorgey: ah, okay.
10:33:36 <rwbarton> by default ghc is not installed
10:33:38 <rwbarton> so no :P
10:33:42 <byorgey> mekeor: so it depends what you mean by 'default' =)
10:33:47 <cmccann> elliott, that reminds me, I'm still amused about that type with a constraint required in covariant position
10:33:56 <mekeor> byorgey: alright, yes.
10:34:21 <elliott> shachaf: Did you ever report the bug for that?
10:34:44 * hackagebot HaskellForMaths 0.4.3 - Combinatorics, group theory, commutative algebra, non-commutative algebra  http://hackage.haskell.org/package/HaskellForMaths-0.4.3 (DavidAmos)
10:34:55 * cmccann wonders if you could use that to essentially reify dictionaries via CPS transformation
10:35:40 <cmccann> though I guess that wouldn't be terribly interesting since you can do stuff like that with GADTs anyway
10:36:43 * cmccann shrugs
10:36:46 <elliott> cmccann: yes, you can
10:36:53 <elliott> cmccann: that's how you eliminate the GADT, after all
10:37:03 <elliott> elim :: Showable a -> ((Show a) => a -> r) -> r
10:37:09 <cmccann> well yeah, like I said it's not really doing anything special
10:37:28 <Eduard_Munteanu> elliott: yeah, though not really a regular implicit, an implicit from scope.
10:37:44 <elliott> Eduard_Munteanu: ?
10:38:57 <Eduard_Munteanu> You want it to pick an instance from the (global) scope.
10:40:20 <elliott> Eduard_Munteanu: What're you replying to? It could be any number of lines I said :P
10:40:26 <johnsingleton> is threadDelay the way to pause execution?
10:40:49 <johnsingleton> or Posix sleep
10:40:49 <Eduard_Munteanu> elliott: < elliott> (and then make (Ord a) an implicit parameter)   and the few lines above it
10:41:18 <shachaf> elliott: No.
10:41:30 <shachaf> elliott: I registered the account and starting writing it down and then my computer gave up.
10:41:56 <johnsingleton> oh, nm, I didn't see *micro* seconds
10:41:58 <johnsingleton> duh
10:42:08 <johnsingleton> I was like, *it's not sleeping!*
10:42:26 <elliott> Eduard_Munteanu: Ah.
10:42:32 <elliott> Eduard_Munteanu: Well, I'm not sure that's necessarily what you'd want.
10:42:45 <elliott> For instance, if you have Eq a -> Ord (Blah b) in scope, then you'd want it to try and apply that.
10:42:48 <elliott> *Blah a
10:43:14 <mekeor> do you think debian or gentoo has a better haskell-support ?
10:43:18 <elliott> The worrying thing is that changing the instance resolution algorithm would break programs, and I'm not sure what algorithm you'd want :/
10:43:47 <elliott> mekeor: depends what you mean by haskell-support... the only thing most people bother getting from their distro is GHC, and even then a lot of people don't
10:44:23 <Eduard_Munteanu> mekeor: IME, Gentoo is reasonable, moreso if you add the haskell overlay on top
10:44:45 * hackagebot vector-algorithms 0.5.4 - Efficient algorithms for vector arrays  http://hackage.haskell.org/package/vector-algorithms-0.5.4 (DanDoel)
10:45:56 <Eduard_Munteanu> mekeor: that being said I do run xmonad, have GHC installed and stuff like that. The overlay also contains a tool which lets you generate ebuilds for cabal stuff, if you don't want to install something in ~/
10:46:43 <mekeor> hmm.... alright.
10:46:53 <Eduard_Munteanu> I don't know about Debian though, but among other distros touted to have reasonable Haskell support is Arch, AFAIH.
10:47:19 <statusfailed> If I have some stuff in a module I want to test, but not expose, how should I do that?
10:47:29 <statusfailed> make an Internal folder and chuck it in there?
10:49:04 <mekeor> my next question (which i know is posed often) is whether i generally should install haskell-stuff with cabal-install or with the package-manager of my distro.
10:49:12 <elliott> former
10:49:18 <elliott> distros inevitably lag behind
10:49:21 <Eduard_Munteanu> No.
10:49:31 <mekeor> statusfailed: maybe you could export that stuff nevertheless and then interprete it and test it in ghcI ? idk
10:49:37 <elliott> they're ok for people who want to install haskell software, but using distro packages for development will be painful
10:49:49 <elliott> especially as there's always going to be packages that simply aren't present
10:49:51 <Eduard_Munteanu> mekeor: I mean, use distro stuff for globally installed packages, then you can cabal-install in your home dir.
10:50:16 <elliott> I wouldn't bother getting GHC from your distro either, since it's just a simple binary tarball away, but that hardly matters.
10:50:33 <mekeor> can it / does it cause problems when i install a package with both cabal and package-manager ?
10:50:38 <mike-burns> Use cabal-dev.
10:50:41 <statusfailed> mekeor: I mean if I want to have some QuickCheck tests
10:50:44 <mekeor> mike-burns: huh?
10:50:46 <statusfailed> I want to do this project properly :P
10:50:59 <Eduard_Munteanu> mekeor: not really, if there's a locally-installed version it will use that.
10:51:02 <elliott> mekeor: Yes, it can.
10:51:08 <mekeor> ?!?
10:51:25 <strager> statusfailed: Would it make sense to expose a 'validate' function?
10:51:38 <elliott> monochrom: Where's that page of yours? Google can't find it.
10:51:40 <elliott> @where sicp
10:51:40 <lambdabot> The Wizard book : "Structure and Interpretation of Computer Programs" at <http://mitpress.mit.edu/sicp/> by Hal Abelson,Gerald Jay Sussman with Julie Sussman, videos at <http://swiss.csail.mit.edu/
10:51:41 <lambdabot> classes/6.001/abelson-sussman-lectures/>
10:51:44 <elliott> Oh come on.
10:51:46 <mike-burns> statusfailed: Release the internal modules as separate packages.
10:51:49 <statusfailed> strager: and do the testing in the file?
10:52:04 <statusfailed> mike-burns: packages as in cabal packages?
10:52:05 <mike-burns> http://www.vex.net/~trebla/haskell/sicp.xhtml
10:52:08 <mike-burns> statusfailed: Yeah.
10:52:10 <elliott> mekeor: ^
10:52:13 <strager> statusfailed: validate would validate an input.  (Data.Map does this IIRC.)  Just quickcheck on the validate function.
10:52:24 <strager> statusfailed: Of course, this only works with some types of structures.
10:52:39 <elliott> mekeor: specifically, the unsafeInterleaveInstall section
10:52:44 <statusfailed> strager: it's a parser, I guess so? i'm not really following what you mean though
10:53:04 <mekeor> elliott: what did you meant by "^" ?
10:53:07 <statusfailed> mike-burns: and introduce a dependency?
10:53:16 <strager> statusfailed: Okay, to change the approach: why do you not want to expose functionality?
10:53:23 <mike-burns> statusfailed: Yup.
10:53:31 <elliott> mekeor: http://www.vex.net/~trebla/haskell/sicp.xhtml
10:53:35 <elliott> pointing to mike-burns' url
10:53:49 <mekeor> elliott: are you sure you are addressing me ?  not statusfailed?
10:54:12 <statusfailed> strager: hmm, that's a good point... it just feels a little messy? :P
10:54:13 <kallisti> is there any way to get an mzero for IO?
10:54:25 <Eduard_Munteanu> mekeor: yes, he is
10:54:29 <elliott> mekeor: <mekeor> can it / does it cause problems when i install a package with both cabal and package-manager ?
10:54:31 <elliott> I am addressing you.
10:54:32 <Eduard_Munteanu> mekeor: check that link
10:54:37 <mekeor> okay.. hehe =)
10:54:45 * hackagebot numeric-quest 0.2 - Math and quantum mechanics  http://hackage.haskell.org/package/numeric-quest-0.2 (HenningThielemann)
10:54:47 <elliott> mekeor: Just the unsafeInterleaveInstall section is relevant.
10:54:56 <strager> kallisti: Throw an exception, maybe?
10:55:08 <mike-burns> kallisti: What would you use it for?
10:55:09 <strager> or exitWith
10:55:16 <statusfailed> (btw, thanks all :))
10:55:24 <elliott> kallisti: Yes, but it won't obey useful laws.
10:55:44 <elliott> kallisti: Specifically, it would violate:  v >> mzero   =  mzero
10:55:48 <elliott> which is a documented law.
10:55:55 <elliott> (consider fireZeMissiles >> mzero)
10:56:02 <kallisti> right
10:56:11 <kallisti> I'm particularly interested in mzero >> v = mzero
10:56:20 <elliott> You might be, but MonadPlus isn't.
10:56:23 <strager> statusfailed: If you still want to hide it, you can stick your "private" functions in a separate .Internal module and import that (and discourage others from using .Internal).
10:56:28 <elliott> Define your own class if you must :P
10:56:36 <kallisti> elliott: what would be the approrpaite mzero here?
10:57:00 <strager> kallisti: I think exceptions may be appropriate.
10:57:02 <kallisti> (this has nothing to do with MonadPlus anymore, apparently)
10:57:11 <strager> kallisti: Or are you thinking of something like "return" in imperative languages?
10:58:45 <elliott> kallisti: It depends what you're tryingt o do.
10:58:48 <kallisti> I just think it would be convenient to have a short-circuit of some kind in situations where the inner value isn't needed. actually "when" will suffice.
11:03:10 <Eduard_Munteanu> I wonder how much of that unsafeInterleaveInstall advice applies in the case of multiple sandboxes. I generally get the basic stuff from my distro (just enough to run say xmonad and darcs), and I don't really mind erasing ~/.cabal once in a while.
11:04:18 <Eduard_Munteanu> And I pretty much have the same expectations as if I was compiling and installing some non-Haskell apps in a prefix under ~/
11:04:36 <cmccann> kallisti, if you just want to short-circuit for control flow purposes, there are other ways to do that
11:04:37 <mekeor> elliott: so, one possible (and IMO the best way) is to only install ghc using the package-manager and using cabal-install for the rest, right?
11:05:08 <mekeor> elliott: well, and cabal-install has to be installed by the package-manager, too... or?
11:06:16 <elliott> mekeor: No.
11:06:23 <elliott> mekeor: You just download cabal-install and run bootstrap.sh.
11:06:59 <elliott> Distro GHC is fine, but it's only wget && ./configure --prefix= && make && sudo make install to use a binary tarball, which is likely to be several versions newer on many distros.
11:07:29 <ricky26> Hello, I have what appears to be a Windows problem
11:07:30 <ricky26> with haskell
11:07:38 <mekeor> elliott: how'd i update GHC then?
11:07:50 <ricky26> I'm using listenOn, and I just get connection refused from whatever I use as a client.
11:07:54 <Eduard_Munteanu> I don't really see the issue here, it's not like people aren't installing stuff user-locally. Should they install everything user-locally?
11:08:06 <elliott> mekeor: By doing the same.
11:08:08 <ricky26> I've already found that I was missing withSocketsDo, and I've added that, but something is still going awry.
11:08:12 <elliott> Eduard_Munteanu: Yes.
11:08:15 <Eduard_Munteanu> IMO it's rather the expectation that cabal-install is a pkg manager that's erroneous.
11:08:22 <kallisti> instance Show AssertionFailed where showsPrec _ (AssertionFailed err) = showString err  -- from GHC.IO.Exception
11:08:30 <Eduard_Munteanu> elliott: I was actually asking that in a non-Haskell context
11:08:33 <kallisti> why does this code use a) showString b) showsPrec
11:08:52 <mike-burns> cabal-dev is pretty nice. Worth trying.
11:08:52 <elliott> Eduard_Munteanu: Yeah, cabal isn't a package manager, it's a build tool, the package manager is cabal-install -- no wait, cabal-install isn't a package manager, it's, err, a something -- it's whatever will stop people complaining about its flaws!
11:08:53 <Eduard_Munteanu> Since distro stuff lags, we might as well install Linux from scratch :)
11:08:59 <mekeor> elliott: how can i install ghc without ghc, btw? ghc is written in haskell...
11:09:05 <elliott> Eduard_Munteanu: For users, distro lag is fine.
11:09:07 <elliott> For developers, it's not.
11:09:16 <elliott> That's why language-specific package managers start existing.
11:09:22 <elliott> mekeor: Like I said, binary tarball.
11:09:33 <Eduard_Munteanu> "package managers"
11:09:37 <elliott> mekeor: You could then download a source GHC and build it, if you really wanted to.
11:09:43 <elliott> Eduard_Munteanu: Yes, they suck, but they're better than the alternative.
11:09:48 <mekeor> elliott: no i dont
11:10:37 <Eduard_Munteanu> elliott: oh, I'm not saying they suck, rather people expect too much of them. Contrast with ./configure --prefix=~/foo, it's quite apparent how such stuff could break, yet people use it.
11:12:35 <ricky26> (In case anyone is interested, I want to know why http://pastie.org/3323323 doesn't work on Windows, but seems to work fine on Linux.)
11:13:16 <Sgeo> Is PolyKinds a step towards replacement of HList, or something a new HList library would make use of, or what?
11:13:18 <Eduard_Munteanu> e.g. I run a whole mesa and wine build under a different user here, as a developer / early adopter thingy it makes a lot of sense, and you don't need your whole machine to run bleeding edge software.
11:16:19 <elliott> Sgeo: It has absolutely nothing to do with HList. Do you mean DataKinds?
11:16:36 <cmccann> I don't think those have much to do with HList as such either
11:16:58 <cmccann> though datakinds would be useful for writing stuff like that
11:16:59 <Sgeo> elliott, yes
11:17:22 <elliott> Sgeo: It is still mostly unrelated.
11:17:30 <elliott> However!
11:17:32 <elliott> You can do
11:17:53 <elliott> data HList (xs :: [*]) where HNil :: HList '[]; HCons :: x -> HList xs -> HList (x ': xs)
11:17:55 <elliott> which is fun.
11:18:05 <elliott> And maybe a bit more readable (you can say HList '[Int, String, Char]).
11:18:33 <cmccann> what's not readable about (Int :*: String :*: Char :*: HNil) ? :D
11:18:49 <elliott> ((there's a NonEnglishKind for you))
11:18:54 <cmccann> haha
11:19:24 * cmccann suggests -XNoOlegNames
11:19:51 <cmccann> which I guess would enable data kinds and also refuse to compile any iteratee library
11:20:01 <elliott> what's'the'problem
11:21:57 * cmccann works on his own iteratee-style library because obviously there aren't enough
11:22:19 <earthy> and obviously none of them are easily learned. :P
11:23:28 <cmccann> that's okay, I'm not trying to be easier
11:23:42 <cmccann> I've decided to fill the niche of "more general and even harder to learn"
11:23:47 <cmccann> that's more my kind of thing
11:24:23 <Eduard_Munteanu> cmccann: sounds like a new iteratee-extras, by analogy :P
11:24:35 <cmccann> Eduard_Munteanu, heh
11:26:23 * cmccann is actually experimenting with a design for stream processing combinators
11:26:37 <cmccann> not really an iteratee library but does overlap somewhat
11:27:02 <Eduard_Munteanu> Throw in some arrows :P
11:27:14 <Eduard_Munteanu> And FRP.
11:27:18 <elliott> cmccann: do tell!
11:27:27 * elliott has thought about the subject quite a lot
11:27:45 <elliott> Eduard_Munteanu: funny you should mention FRP, it's actually very closely related (IMO)
11:27:46 <cmccann> Eduard_Munteanu, it actually is more inspired by arrow-based FRP than iteratees, since you mention it :P
11:27:58 <Eduard_Munteanu> Oh, heh.
11:27:59 <elliott> snap
11:28:16 <cmccann> i.e. it started as generalizing the usual automaton arrow
11:28:56 <elliott> FRP came about from a suggestion to generalise Animation = [Image] to Animation = R -> Image (by way of Animation = N -> Image)
11:28:58 <cmccann> iteratees and arrow-based FRP both being variations on "automaton arrows with ad-hoc crap bolted on"
11:29:11 <elliott> and AFRP signal transformers are basically ((R -> a) -> (R -> b))
11:29:23 <elliott> discrete stream processing is just flipping the R back to N :)
11:29:45 <elliott> and the same reasons ((R -> a) -> (R -> b)) isn't quite correct -- you can "look at the past" and so on, space leaks and all that -- are the exact same problems with [a] -> [b] lazy IO
11:29:46 <cmccann> elliott, anyway I doubt where I'm going with this is related to what you've thought about
11:30:01 <kallisti> DefaultInstances is very nice.
11:30:11 <kallisti> er
11:30:20 <kallisti> DefaultSignatures, is actually what it's called
11:30:25 <elliott> cmccann: that makes it more interesting, then :P
11:30:39 <elliott> hmm, what does Def-- oh yeah, default in classes
11:30:53 <shachaf> Def++
11:31:39 <cmccann> elliott, the main observation (partly inspired by the pipes library) is that all stream processing junk ends up being recursively nesting various composed functors
11:32:23 <elliott> I wish I had published pipes when I thought of it months ago, immediately prior to discarding it as obvious-but-insufficient because of its inability to handle leftover data and the like :P
11:32:52 <cmccann> elliott, so I have type combinators to describe the various pieces that can be combined and then generic operations
11:33:18 <elliott> phyrex1an has trouble with PARTs, I see
11:33:41 <cmccann> so given a composite functor representing the shape of each step in the stream I can mix them together in various ways to model data flow
11:33:58 <mjga> interesting, hackage contains at least 4 printf libraries, but none of them is bytestring-compatible
11:34:10 <rostayob> elliott: you're the author of this http://hackage.haskell.org/package/pipes ?
11:34:20 <rostayob> mjga: unpack?
11:34:26 <rostayob> mjga: ByteStrings are not strings.
11:34:28 <elliott> rostayob: No.
11:34:35 <Eduard_Munteanu> unpack sucks :/
11:34:36 <rostayob> there is no "right" way of converting them to string
11:34:44 <rostayob> mjga: thus it doesn't make much sense to make assumptions
11:34:48 * hackagebot shake 0.2.2 - Build system library, like Make, but properly supports generated files.  http://hackage.haskell.org/package/shake-0.2.2 (NeilMitchell)
11:35:02 <Eduard_Munteanu> You should probably use Data.Text if you're printf-ing I guess.
11:35:04 <rostayob> elliott: oh, which pipes then?
11:35:05 <elliott> rostayob: I independently reinvented it, but didn't bother doing anything with it because it (a) seemed completely obvious and trivial (b) didn't solve any of the hard problems :P
11:35:12 <rostayob> elliott: oh, ok.
11:35:19 <cmccann> elliott, then I use the free monad construction to build up with continuations, and seal off streams that either halt or repeat forever as fixed points
11:35:38 <rostayob> Eduard_Munteanu: unpack "sucks" doesn't make much sense. unpack does what it says it does.
11:35:51 <rostayob> maybe that's what he needs, I don't know
11:35:54 <elliott> cmccann: That sounds nice. Does that mean you can layer things like buffering (i.e. returning "leftover" pieces of chunks) on top independently?
11:36:22 <mjga> rostayob: the point of using printf is that they provide terse way of printing, and of bytestrings, is that hey provide a bit more efficiency. altough blaze or conduit-compatible printf would do well too
11:36:33 <elliott> mjga: No, ByteStrings are [Word8].
11:36:35 <elliott> String is [Char].
11:36:44 <elliott> Text is the one that's String but more efficient.
11:36:47 <Eduard_Munteanu> rostayob: yeah, but it's not a magic bullet either, quite the contrary. unpack and pack make it useless to use bytestrings.
11:37:08 <rostayob> mjga: again, ByteStrngs are not Strings. Writing a ByteString aware printf would have to make assumptions on the encoding
11:37:11 <mjga> elliot: utf8 bytestrings would do too
11:37:31 <rostayob> mjga: well, for some use cases. for Word8 chars it would be useless.
11:37:45 <rostayob> so that's why you don't have an "automatic" ByteString printf.
11:37:49 <rostayob> if you need fast text, use Text
11:37:51 <elliott> mjga: In the same way that [Bool] is a good way to encode a tuple of Ints, because you can represent them as one.
11:38:06 <Eduard_Munteanu> text -> Text, binary data -> Bytestrings
11:38:11 <mjga> I just tested a parser that parses 50MB in 8s, and then Shows or printfs the result well over a minute...
11:38:16 <cmccann> elliott, there's no inherent concept of chunking, but pretty much everything has to be handled explicitly so it should be possible to encode guarantees about stuff like that on top of it
11:38:38 <elliott> cmccann: Right, I was just thinking that layering independent parts on top make things like handling buffering a lot nicer, because you can isolate it.
11:39:13 <cmccann> elliott, for instance it's easy to specify that a stream produces one output per input, stuff like that
11:39:17 <elliott> One of the most persistent problems with iteratee-alikes that I haven't seen anybody address is that some streams depend on global state (like those that read from a Handle) and others don't (like reading from a list).
11:39:24 <rostayob> mjga: you're doing something wrong
11:39:32 <elliott> And it's convenient to be able to reuse streams.
11:39:39 <mjga> rostayob: I used ByteString only because it is in standard library, and it was less slow. Of course would be much better, if HS stdlib standardized on unicode bytestrings, but my domain is 7-bit clean
11:39:40 <elliott> But you can't do that for the former kind.
11:40:10 <elliott> Additionally the fact that many streams depend on global state makes the automaton-arrow style seem silly, because a mutable variable works just as well and is more consistent (like conduits) -- but of course everyone hates this because it's ugly and the idea of resumability is nice...
11:40:12 <kallisti> 22 imports, 7 language extensions. Am I writing Real Haskell(tm) yet?
11:40:13 <Eduard_Munteanu> Doesn't Data.Text come with HP as well?
11:40:19 <elliott> Eduard_Munteanu: Yes.
11:40:20 <mjga> rostayob: since when using Show on a single object is wrong? and instances of Show are derived, so I assume they should have at least _sane_ complexity.
11:40:23 <cmccann> elliott, my model should also allow for full control over branching data flow for push or pull both
11:40:23 <elliott> It does.
11:40:23 <rostayob> mjga: what are you printing back?
11:40:41 <rostayob> mjga: sometimes it can't be as fast as you want it to be (the derived instance)
11:40:49 <elliott> cmccann: sounds neat
11:40:51 <rostayob> there's probably a lot of copying going on
11:41:15 <cmccann> elliott, the automaton arrow basically simulates a thread reading and writing mutable variables in an infinite loop
11:41:16 <mjga> kallisti: I usually reduce number of used extensions after I debug, and profile the code. Surprisingly it ends with 2-3 of them most of the time (ScopedTypeVariables, and something about classes or records)
11:41:28 <mjga> rostayob: should I file a bug?
11:41:38 <rostayob> mjga: you still haven't told us what are you doing exactly
11:41:55 <rostayob> mjga: are you just using "show" over bytestrings?
11:41:56 <elliott> cmccann: right -- I'm just saying that encoding that specific thing in the arrow itself, when 90% of your effects are actually in the kleisli arrow you use it with, is odd
11:41:59 <mjga> rostayob: I would say that if an instance showing a datatype is not O(n), and not with a sane constant, then there is something wrong...
11:42:07 <elliott> because things like Handle state aren't reflected in the automaton arrow content
11:42:10 <mjga> rostayob: show is over data structure
11:42:24 <rostayob> mjga: O(n) on what?
11:42:26 <elliott> mjga: What is the buffering of stdout?
11:42:32 <elliott> Are you redirecting to /dev/null to time it?
11:42:32 <kallisti> mjga: I could get rid of NamedFieldPuns easily. I could get rid of DeriveGeneric, DefaultSignatures, and TypeSynonymInstances as well, but I'd rather not.
11:42:47 <Eduard_Munteanu> The question is whether the intermediate list fuses.
11:42:48 <mjga> elliott: nope, writing to file
11:42:51 <Eduard_Munteanu> Probably not.
11:43:10 <elliott> mjga: Write to /dev/null and measure that.
11:43:12 <mjga> rostayob: O(n) on length of data structure
11:43:18 <kallisti> I guess I could get rid of DeriveDataTypeable as well. But ForeignFunctionInterface and FlexibleInstances must stay.
11:43:30 <Eduard_Munteanu> mjga: somehow I think that's not the problem there
11:43:48 <elliott> mjga: Why not use text, by the way? It is standard, like Eduard_Munteanu says.
11:43:51 <rostayob> mjga: "length" of the data structor?
11:43:52 <Eduard_Munteanu> More like String being inefficient and generating loads of garbage.
11:43:55 <cmccann> elliott, in particular I can support forward branching with push (where one of two streams accepts the value) and backward branching with pull (where one of two streams will yield a value)
11:43:59 <rostayob> *structure
11:44:14 <rostayob> mjga: anyways I think that the best thing is do what elliott says and then post some code
11:44:27 <rostayob> also, Strings are slow
11:44:40 <rostayob> if you're serializing/deserializing, you should be using binary or cereal
11:44:51 <mjga> rostayob: I parse 50MB
11:45:08 <rostayob> mjga: yes, and?
11:45:54 <cmccann> elliott, and once I get it working I'll be able to encode zipping streams in lockstep with a guarantee that either the inputs or outputs are independent
11:47:04 <cmccann> but the semantics on that are subtle and the implementation choices are awkward at best :[
11:47:16 <rostayob> mjga: (both instances of Binary and Serialize can be derived automatically)
11:47:28 <mjga> rostayob: do s<-parse; rnf s `seq` (putStrLn $ show structure)
11:48:02 <rostayob> mjga: ok, that is probably going to be slow if the structure is slow because strings are slow. what do you need to do?
11:48:09 <elliott> cmccann: it sounds cool -- let me know when you get something working
11:48:19 <elliott> mjga: That rnf is pointless.
11:48:20 <rostayob> mjga: also, how long does it take redirecting to /dev/null?
11:48:22 <elliott> show will already force the entire thing.
11:48:25 <rostayob> yeah, that too
11:48:29 <elliott> Also, what buffering does stdout have?
11:48:54 <mjga> rostayob: rnf was to prove what takes time.
11:48:58 <cmccann> elliott, oh, and also note that I handle inputs and outputs identically--an input of type A is a "negative" element and connecting streams with matched input/output cancels them out
11:49:32 <rostayob> mjga: so why are you printing it at all? can't you just time it?
11:49:47 <elliott> cmccann: oh, that's neat
11:50:00 <elliott> cmccann: does that mean streams can have an arbitrary number of "connections"?
11:50:02 <CodeWeaverX> Hah, with some minor time-to-setup, EclipseFP seems to be working with OSX.  Go go JPMoresmau.
11:50:15 <rostayob> mjga: but the real issue here is: what is your aim? what are you trying to achieve? because you're probably doing the wrong thing
11:50:52 <CodeWeaverX> Well, for 7.2.2 anyway
11:50:53 <cmccann> elliott, which also extends to pull vs. push being inverses of each other, so pushing A or B cancels with pulling -A or -B, where one side makes the choice and the other side responds
11:51:14 <elliott> (does that mean you can have a "side-channel" with control requests (e.g. seeking)?)
11:51:39 <cmccann> elliott, there's no limitations on what shape you use for each step of a stream
11:51:50 <mjga> rostayob: no Show was just example. I parse thing quickly, but then I want to print it back after certain manipulations. Now I have a correct writing code that relies on printf and thus is damn slow because it uses Strings and then BS.packs them. I wondered whether there is a library that accepts printf format strings, but internally uses some fast string writing method. like blaze does
11:51:51 <cmccann> though pending some serious type hackery you may have to do a lot of juggling to line things up
11:52:23 <cmccann> elliott, all the ways of combining step functors should be associative and commutative but still
11:52:32 <rostayob> mjga: do you have to "print" them or writing to a file?
11:53:04 <elliott> cmccann: what was that last line in response to
11:53:04 <elliott> ?
11:53:31 <cmccann> elliott, you may begin to see why I said this is filling the "more general but harder to use" niche :P
11:53:39 <cmccann> elliott, asking about multiple connections and such
11:53:49 <elliott> ah
11:54:05 <cmccann> the answer being "yes, it's all handled generically, but you may have to manually reorder the shape of the steps to line it all up"
11:54:27 <cmccann> since connecting an input and output requires cancelling the elements when you merge the streams
11:55:09 <cmccann> elliott, it's basically the same problem as the tuple wrangling you get with arrows, except without syntax to help :T
11:55:21 <elliott> cmccann: it seems like you'd want to essentially compose everything -- yeah
11:55:30 <elliott> cmccann: well, you could abuse do-notation for the purpose
11:55:40 <elliott> (I think you could implement arrow notation with do-notation)
11:56:03 <elliott> (proc :: (Arrow a) => ArrowNotation a b c -> a b c)
11:56:12 <cmccann> I'm not sure, the way these are assembled makes many type classes awkward for the pieces
11:56:20 <elliott> (just in case anyone wants to try writing an existence proof for me :P)
11:56:30 <elliott> cmccann: right, I just meant write a separate Monad used only for notation
11:56:36 <elliott> and a function to turn that into the actual thing you want
11:56:39 <mjga> ok, I understand that Binary would help, but it is binary. or is there some trick to use Binary or Cereal conveniently and still get text output? and what about printf?
11:56:40 <elliott> EDSL-style
11:57:13 <cmccann> elliott, I'll have to think about how to do that
11:57:18 <Cale> lol, I just got an email with a comment replying to a blog post that I'd commented on why Haskell code uses lists so frequently, and the comment starts off:
11:57:21 <Cale> "What i do not realize is actually how you are now not really much more well-liked than you might be right now."
11:57:48 <rostayob> mjga: it's not clear here why would you want printf. My understanding is that you need to parse a big ass binary file, change stuff and write it back somewhere. Right?
11:57:49 <cmccann> elliott, once I get a few more things working I'm going to toss it on github, if you want to take a look I'll let you know when it's ready
11:57:51 <elliott> cmccann: basically using do-notation as a programmable semicolon in the most literal sense
11:58:00 <elliott> cmccann: sure
11:58:09 <aristid> Cale: what does that even mean? oO
11:58:24 <cmccann> well, right now I'm using do notation for stacking continuations on a free monad of these step functors
11:58:39 <elliott> Cale: :D
11:58:49 <Cale> aristid: I have a feeling that it was machine generated, judging by the rest of the message...
11:59:03 <elliott> It's true, Cale needs to be really much more well-liked than he might be right now.
11:59:06 <Cale> and the fact that it was posted by someone whose name is "seo"
11:59:08 <elliott> Everyone well-like Cale some more.
11:59:14 <Cale> http://andrewbrobinson.com/2012/01/11/why-does-haskell-use-singly-linked-lists-anyway/#comment-1600
11:59:16 <rostayob> well-hyphen-like
11:59:43 <elliott> @remember seo What i do not realize is actually how you are now not really much more well-liked than you might be right now. You are so intelligent. You realize thus significantly in terms of this subject, produced me in my view consider it from so many numerous angles. Its like men and women are not interested unless it’s one thing to do with Woman gaga! Your personal stuffs excellent. Always care for it up!
11:59:43 <lambdabot> Okay.
11:59:53 <cmccann> heh
11:59:58 <Botje> I like Cale like I like my wells!
12:00:05 <elliott> Botje++
12:00:17 <mjga> rostayob: I want printf, since I already have a rather brief code that uses printf-formatting statements. Like this "RECTYPE1  %5d %3s %7.2f %5.1f %9.3f %9.3f %9.3f %06.2f    %1s  %3s". This is precisely adhering to column-based format that I handle now.
12:00:29 <nand`> cold and deep?
12:00:37 <rostayob> mjga: and then you want to concatenate those lines I guess
12:01:02 <aristid> elliott: i imperatively increase well-like for Cale
12:01:11 <elliott> cmccann: failing that, you might be able to reuse arrow notation itself, since it offers more "introspection"
12:01:23 <elliott> although arr still gums things up
12:01:28 <rostayob> mjga: the thing is that in C, a string and "char *" are the same thing. In haskell they aren't, so nobody bothered to create a printf-link thing for ByteStrings, I guess.
12:01:30 <mjga> rostayob: yeah, but concat is done by printer, can be buffered
12:01:53 <cmccann> elliott, the problem there is that I'm both making more fine-grained distinctions than Arrow does, while ignoring a distinction that Category makes (input vs. output)
12:01:56 <rostayob> mjga: that said, you're much better off writing the deserializer with binary/cereal, even if it'll lose the conciseness of the printf.
12:02:02 <rostayob> also, printf is unsafe.
12:02:36 <mjga> rostayob: I believe that printf I use should derive types with Template Haskell, and check format strings at compile-time. Doesn't it?
12:03:03 <yitz> new seo technique - post comments on other people's web sites that move them down in search results
12:03:04 <rostayob> mjga: the standard printf doesn't work that way. If you're using a TH printf, that's another story
12:03:31 <cmccann> elliott, there are four basic ways I can compose step functors and they correspond pretty closely to (***), (&&&), (+++), and (|||)
12:03:33 <rostayob> (standard printf = Text.Printf)
12:03:42 <cmccann> but are all distinct from each other
12:03:47 <elliott> cmccann: right, I meant again to define a new type just to abuse notation
12:03:52 <cmccann> yeah
12:04:04 <Cale> yitz: that seems like it could be what's going on here?
12:04:08 <cmccann> just not sure if it'd be less of a headache than what it tries to solve is all
12:04:16 <yitz> i wonder
12:04:26 <elliott> yitz: haha, post comments full of SEO phrases so that google punishes the site
12:04:43 <rudyl313> how can I define a data type like this: data MyType = MyType a .... but constrain "a" to be a of a specific typeclass?
12:04:43 <elliott> I'm sure Google tries to rank spammed-up sites lower, after all :)
12:04:55 <mjga> rostayob: <rant> so answer is that because C-version of printf is unsafe, we abandon printf format string notation in general (even if it is briefer, and more high level than writing monadic code that handles column-based formatting?)
12:04:56 <elliott> rudyl313: data MyType = ... or data MyType a = ...?
12:05:28 <rudyl313> In the value constructor on the right... I want to specify what typeclass the variable a can be
12:05:35 <rostayob> mjga: no, a ByteString printf doesn't exist because printf is mostly used to format strings, and ByteStrings are *not* strings. the name is misleading.
12:05:42 <rudyl313> lets say I want a to be any numeric type
12:05:45 <elliott> rudyl313: yes, but which did you intend the left-hand side to be? it changes the answer
12:05:55 <rostayob> actually I would have guessed it existed, but evidently it doesn't :P
12:06:01 <elliott> ByteStrings should really be called Bytes or something
12:06:07 <rudyl313> I didn't want the left side to take an argument.. .so the former
12:06:07 <mjga> rostayob: what about cereal-printf or binary-printf?
12:06:22 <rostayob> mjga: what about them? do they exist?
12:06:28 <elliott> rudyl313: existential... but you probably don't actually want that
12:06:31 <aristid> rostayob: maybe they should be called ByteVector and ByteRope (in the case of lazy bytestrings)? :D
12:06:35 <elliott> data MyType = forall a. (Num a) => MyType a
12:06:40 <elliott> but again, this is usually not what you want
12:06:45 <rostayob> mjga: you could certainly write printf functions backed by binary/cereal. no problem
12:06:48 <elliott> aristid: lazy bytestrings aren't ropes
12:06:49 <rudyl313> elliott: why not?
12:07:02 <elliott> rudyl313: you can usually achieve the same effect in a much simpler manner
12:07:07 <elliott> it depends on what you're trying to do
12:07:22 <aristid> elliott: hmm, what differentiates them from real ropes?
12:07:35 <rostayob> mjga: it's just that most haskell programmers would just write the serializer directly.
12:07:38 <lispy> when was standalone deriving added?
12:08:08 <rudyl313> so I'm making a type that represents a filter in a query string of url... some of the filters operator on numeric values.. some on strings.. so I wanted make a type like this: data Filter = GreaterThan a | EqualsStr String | EqualsNum a .. etc.
12:08:16 <Palmik> Hi guys, I was experimenting with something like this http://hpaste.org/57491 but I get this error http://hpaste.org/57492 (it's the same without the explicit forall).
12:08:16 <rudyl313> elliott: does that make any sense?
12:08:19 <rostayob> aristid: lazy bytestrings are exactly the same as strict ones, but the reading is done in chunks in a lazy manner
12:08:25 <rostayob> under the hood
12:08:41 <elliott> rudyl313: you should probably just pick a concrete type
12:08:45 <hpaste> Doug pasted “PF Problem” at http://hpaste.org/57493
12:08:52 <elliott> rudyl313: because, in fact, an existential won't work there
12:08:54 <aristid> rostayob: well the chunks are exposed by the toChunks function
12:08:57 <yitz> lispy: a long time ago. try asking on #ghc
12:09:02 <mjga> rostayob: why? it is a text format anyway. I though that whole point of high-level programming, is to have as much as possible done by compiler?
12:09:06 <rudyl313> elliott: I'm not sure what you mean by that.. whats a concrete type?
12:09:09 <elliott> rudyl313: what you want is universal quantification of "a"... and that's going to be isomorphic to an Integer
12:09:11 <elliott> rudyl313: just pick an actual type
12:09:15 <elliott> like Int or Integer or Double or such
12:09:16 <rostayob> aristid: yeah, but iirc a rope is a more complex data structure
12:09:25 <elliott> aristid: a rope is a tree
12:09:27 <doug_> I am having trouble getting the point free version of a  very simple function to compile - any ideas? http://hpaste.org/57493
12:09:31 <elliott> of chunks
12:09:35 <elliott> lazy bytestrings are lists of chunks
12:09:36 <rudyl313> elliott: so force the client of my lib to convert to Double for all numeric types?
12:09:55 <elliott> rudyl313: well, no, you can offer: greaterThan :: (Real a) => a -> Filter
12:09:55 <rostayob> mjga: no, 'char *' is not text, at least not in haskell land. 'char *'/ByteString = binary blob
12:10:16 <aristid> elliott: oh ok :)
12:10:28 <doug_> I am having trouble getting the point free version to compile http://hpaste.org/57493.  Any ideas?
12:10:31 <rostayob> mjga: and it's not text for good reasons, since it carries no information about the character
12:10:32 <rudyl313> elliott: ok cool .. thanks for the advice
12:11:13 <mjga> rostayob: Data.ByteString.Char8 seems to work as a string with OverloadedStrings, so I am sure you are wrong...
12:11:20 <elliott> doug_: your point-free version is wrong
12:11:28 <rostayob> mjga: Char8 makes a strong assumption. that all characters fit in one byte.
12:11:32 <elliott> doug_: it's equivalent to: assertNearlyEqualPf a = (assertBool "Nearly Equal") (testNearlyEqual a)
12:11:40 <elliott> but you want: assertNearlyEqualPf a b = (assertBool "Nearly Equal") (testNearlyEqual a b)
12:11:42 <mjga> rostayob: of course having unicode strings is nicer, but not when it is as slow, as [Char]
12:11:50 <elliott> hmph
12:11:55 <elliott> mjga: Text
12:11:56 <opqdonut> mjga: use Data.Text
12:12:04 <elliott> mjga: .Char8 is a massive hack for very specific purposes only
12:12:10 <yitz> doug_: are you doing it for fun, or because you want to simplify? if the latter, you are trying to eliminate too many variables.
12:12:12 <elliott> Text is in the platform, so it's perfectly standard
12:12:14 <rostayob> mjga: yeah but the point here is that after you have your Char8 bytestring, there is nothing at the type level that tells you something about the encoding.
12:12:14 <elliott> yitz: too late
12:12:23 <ben_> but utf-16 is 50% overhead for actual text~
12:12:31 <yitz> elliott: yeah. drive-by point-free.
12:12:35 <rostayob> elliott: he's not outputting text, he's reading/writing a binary file
12:12:39 <rostayob> well...
12:12:43 <elliott> rostayob: do you know that?
12:12:46 <elliott> ben_: let me check my dictionary... actual, n. English
12:12:52 <ben_> :D
12:12:52 <elliott> :)
12:12:54 <rostayob> elliott: yes, he mentioned that
12:13:06 <elliott> rostayob: ok, fair enough. i have a better question for mjga, then
12:13:12 <elliott> mjga: why are you using a textual format for 50 megabytes of data?
12:13:17 <elliott> humans can't read 50 megabytes of data.
12:13:21 <elliott> oh, wait
12:13:26 <elliott> I mentally negated rostayob's statement :(
12:13:51 <rostayob> elliott: well binary file, it's something like WORD NUMBER NUMBER NUMBER :)
12:13:53 <lispy> yitz: I don't think #ghc is really for user questions.  Judging by the user manual, it was there in 6.8 which is plenty old for me
12:13:56 <rostayob> but not text
12:13:57 <ben_> I'd argue that there's more to it than english versus chinese or whatever, what with most plain-text formats being mostly ascii-based
12:13:59 <mjga> elliott: because I use a database that has over 20 years of age, and few gigabytes of text-formatted data. I recommend that all legacy databases were as easy to read as this one
12:14:08 <rostayob> I'd say that bytestrings are the right thing here
12:14:25 <rostayob> mjga: please try ceral. it's nice. you won't miss printf.
12:14:37 <elliott> ben_: yeah
12:14:41 <elliott> ben_: but RAM is cheap and all that
12:14:42 <rostayob> also because I'm kind of sick of this discussion :P
12:14:45 <Sgeo> ceral?
12:14:48 <ben_> but cache isn;t
12:14:54 <aristid> @hackage cereal
12:14:54 <lambdabot> http://hackage.haskell.org/package/cereal
12:14:58 <rostayob> Sgeo: cereal :P
12:14:59 <Sgeo> Oh, a typo
12:14:59 <elliott> ben_: not yet :)
12:15:04 <mjga> elliott: you are wrong, about humans not reading this data. it simply needs to be visualized in appropriate way, and believe people find mistakes in this data all the time. and correct it :-)
12:15:04 <ben_> pft :V
12:15:18 <elliott> mjga: I was working under the mistaken assumption that your format was textual.
12:15:22 <aristid> rostayob: i'm your typechecker :P
12:15:27 <elliott> Although now I'm beginning to wonder how mistaken it is.
12:15:30 <aristid> i mean typochecker.
12:15:33 <aristid> lol
12:15:35 <ben_> I should go and check out those benchmarks they did for the utf-8 data.text port
12:15:43 <rostayob> aristid: aha. thanks.
12:15:48 <rostayob> aristid: and your emacs colorer :)
12:15:50 <elliott> mjga: Anyway, of course you can display 50 megabytes of data to humans, that's irrelevant to the question of whether the intermediate format should be textual or not.
12:15:52 <mjga> elliott: it is textual, and it is 8-bit clean, because when they created database, most computers used only 8-bit strings
12:16:10 <aristid> rostayob: yeah if you should change the yellow, please give me the update too :)
12:16:15 <elliott> mjga: Anyway, you could have written your own printf in the time it took for this silliness to cycle around a few hundred times :P
12:16:31 <Palmik> Hi guys, I was experimenting with something like this http://hpaste.org/57491 where I would like to have phantom type in type class, but I get this error http://hpaste.org/57492 (it's the same without the explicit forall). Is there a way to be explicit about foo being from the instance Someclass t a?
12:16:39 <rostayob> mjga: the fact that there is textual is incidental. it's rows of data
12:16:47 <rostayob> *accidental.
12:16:49 <rostayob> I'm tired.
12:17:00 <rostayob> *there is text. lol.
12:17:09 <elliott> mjga: BTW, *any* printf is likely to be slower than it could be unless you parse the format string at compile time.
12:17:13 <elliott> i.e. Template Haskell-based solutions
12:17:30 <mjga> elliott: but then I would write printf for bytestring, and then somebody would have to rewrite it for Data.Text. Now I write it for Data.Text, and publish on hackage, in a vain hope that it gets to haskell platform, and old printf gets kicked out
12:17:31 <Saizan> Palmik: nope, you've to add an argument mentioning t to foo
12:17:45 <mjga> elliott: yes I believe I should parse fmt string at compile time
12:17:48 <Palmik> Saizan, OK, thanks. :)
12:17:52 <Saizan> Palmik: and then test too
12:18:20 <elliott> mjga: I don't understand that objection.
12:18:29 <elliott> Text.Printf is not going anywhere.
12:18:34 <kallisti> why am I not finding any information about DataKinds on google..
12:18:48 <elliott> kallisti: Because it just came out.
12:18:54 <elliott> kallisti: I bet if I ping byorgey, he'll link the paper.
12:18:54 <mjga> elliott: I know. I just think that having stdlib based on slow base data structure like [Char] is evil.
12:19:15 <yitz> lispy: ok. yeah it's been around for quite a while.
12:19:23 <elliott> mjga: As mauke pointed out some hours ago, types don't have speeds :)
12:19:42 <Palmik> Saizan, it seems to work with only foo modiefied just fine. :)
12:19:57 <Palmik> s/modiefied/modified
12:20:12 <davidL> w 11
12:20:31 <rostayob> mjga: you're problem here is not the String type... you just shouldn't be doing what you want to do how you are doing it. You should be using a serializing/deserializing library. And we do have a good one! (cereal)
12:20:35 <mjga> elliott: I am too practical for such thinking. It would take me about 10 minutes to define types in such a way, that they would describe speeds, and also would be decidable in 99% of cases
12:20:57 <dougransom> having trouble with the point free version of assertNearlyEqual called assertNearlyEqualPF in http://hpaste.org/57493. Any thoughts on my error?
12:21:05 <kallisti> http://hackage.haskell.org/packages/archive/inflist/0.0.1/doc/html/Data-InfList.html  it looks as though someone has re-invented Stream
12:21:19 <Saizan> Palmik: until you try to use test :)
12:21:27 <yitz> hi again dougransom
12:21:40 <elliott> mjga: You would be wrong.
12:21:46 <yitz> dougransom: are you doing it for fun, or because you want to simplify? if the latter, you are trying to eliminate too many variables.
12:22:14 <elliott> mjga: For instance, [a] is slow for random-access and "bulk" data processing.
12:22:31 <elliott> It is also the most fundamental control structure Haskell has, and can be the most efficient structure possible when used correctly (thanks to being eliminated at compile-time).
12:22:36 <mjga> kallisti: that's just because haskell irc channel didn't answer newbie question about how to make infinite lists ;-)
12:23:13 <zzo38> Do you agree that Peanoid/Copeanoid classes would be better for use with list operations than Num/Integral classes would do?
12:23:24 <mjga> kallisti: maybe Hackage packages should have a "like" button
12:23:25 <elliott> dougransom: You got answers after quitting.
12:23:25 <dougransom> trying to learn  both 'a' and 'b' are simpl passed on to another function, hence my thought on making assertNearlyEqual point free.
12:23:28 <rostayob> aristid: Yeah I still have to change the yellow!
12:23:32 <Palmik> Saizan, hmm, indeed, but why is not this enough? http://hpaste.org/57494
12:23:42 <elliott> dougransom: <elliott> doug_: your point-free version is wrong  <elliott> doug_: it's equivalent to: assertNearlyEqualPf a = (assertBool "Nearly Equal") (testNearlyEqual a)  <elliott> but you want: assertNearlyEqualPf a b = (assertBool "Nearly Equal") (testNearlyEqual a b)  <yitz> doug_: are you doing it for fun, or because you want to simplify? if the latter, you are trying to eliminate too many variables.
12:24:07 <zzo38> mjga: I don't like that. Probably better would be is if you just add comments if you have account, I suppose.
12:24:10 <elliott> rostayob: (what yellow?)
12:24:30 <mjga> zzo38: great idea with these comments too!
12:24:31 <Saizan> Palmik: that should typecheck if you're using ScopedTypeVariables, but then test will have the exact same problem as your old foo, becuase 't' only appears in the context
12:24:32 <Palmik> Well, without the monomorphism restriction it works.
12:24:35 <yitz> @pl assertNearlyEqual a b  = assertBool "Nearly Equal" $ testNearlyEqual a b
12:24:36 <lambdabot> assertNearlyEqual = (assertBool "Nearly Equal" .) . testNearlyEqual
12:24:45 <rostayob> elliott: I created a tango color theme for the agda emacs mode!
12:24:57 <mjga> zzo38: should we mail suggestion to hackage authors?
12:25:00 <rostayob> my life is exciting
12:25:22 <elliott> mjga: hackage 2 has been worked on for ages.
12:25:35 <elliott> it is unlikely there is any possible hackage-related suggestion that has not already been made :)
12:25:38 <rostayob> hackage 2, GNU Hurd, duke nukem forever...
12:25:47 <Palmik> Saizan, removing the monomorphism restriction seems to fix that on a first glance.
12:25:48 <mjga> elliott: why is it so slow?
12:25:59 <elliott> rostayob: That's not fair to Hackage 2.
12:26:03 <elliott> rostayob: Duke Nukem Forever shipped!
12:26:07 <elliott> ;)
12:26:12 <Saizan> Palmik: and removing the signature?
12:26:16 <kallisti> hmmm, not too promising:  the top results for a search on "polykinds" yields bug tickets. :P
12:26:16 <rostayob> elliott: yeah
12:26:29 <rostayob> actually the Hurd "shipped" as well
12:26:43 <zzo38> But what is your idea about classes for list operations?
12:26:53 <elliott> mjga: Why is what so slow?
12:27:02 <mjga> elliott: I tried to check Hackage project page, but it is broken: Internal Server Error TracError: IOError: [Errno 13] Permission denied: '/srv/trac/hackage/VERSION'
12:27:13 <newsham> rostayob: awesome.  url to non-beta release of hurd.
12:27:17 <newsham> ?
12:27:28 <rostayob> newsham: well, the beta shipped.
12:27:31 <rostayob> :)
12:27:31 <elliott> newsham: http://www.gnu.org/software/hurd/hurd.html
12:27:41 <rostayob> they're even packaging it with debian.
12:27:43 <elliott> it's not beta, it's just unstable! :)
12:27:50 <elliott> but debian gnu/hurd might be technically non-beta I think
12:27:51 <rostayob> i mean, they're packaging debian with hurd kernel.
12:28:13 <lispy> elliott: first duke nukem forever, now gnu hurd.  What's happened to the state of vapour ware?
12:28:22 <elliott> lispy: I think HURD shipped first :P
12:28:24 <rostayob> lispy: hackage 2 is keeping the flag hig
12:28:27 <rostayob> *high
12:28:30 <lispy> rostayob: haha
12:28:34 <shachaf> lispy: elliott has plenty of vapourware up his sleeve.
12:28:46 <newsham> rostayob: the debian beta release of hurd you mean
12:29:15 <rostayob> newsham: I mean this https://en.wikipedia.org/wiki/Debian_GNU/Hurd , yes
12:29:32 <elliott> that's the official way to get Hurd, IIRC
12:29:48 * hackagebot system-filepath 0.3.6 - High-level, byte-based file and directory path manipulations  http://hackage.haskell.org/package/system-filepath-0.3.6 (JohnMillikin)
12:29:50 * hackagebot system-filepath 0.4.5 - High-level, byte-based file and directory path manipulations  http://hackage.haskell.org/package/system-filepath-0.4.5 (JohnMillikin)
12:29:50 <newsham> i wouldnt exactly call it "shipped"
12:30:14 <rostayob> newsham: it's something, I guess
12:30:23 <elliott> lol @ those two uploads
12:30:26 <rostayob> there is no hackage 2 preview.
12:30:30 <elliott> rostayob: I believe there is.
12:30:31 <zzo38> I think, some people wanted to make   length :: Num i => [b] -> i; (!!) :: Integral a => [b] -> a -> b;   and so on, but I think it should be   length :: Peanoid i => [b] -> i; (!!) :: Copeanoid a => [b] -> a -> b;   and so on. Which way is better to you?
12:30:32 <elliott> Or was.
12:30:44 <rostayob> elliott: damn. there really is no hope for vaporware
12:30:48 <zzo38> If either of these is? Or something else entirely?
12:31:02 <scolobb> (Debian GNU/Hurd is the simplest way to get Hurd :-) There are others, which are harder, but not less official :-)
12:31:10 <scolobb> (Hello and sorry for nitpicking :-)
12:31:14 <elliott> scolobb: ))
12:31:14 <mjga> rostayob: there is. join dev team, and write it
12:31:20 <Palmik> Saizan, yeah, without the signature. Though it just seems that I just postponed the problem. Because it does not typecheck when I add definition like "test'' = test' (5 :: Int)". Well I guess there really is no way around it. :)
12:31:37 <elliott> scolobb: Defending HURD in public venues must be... an exhausting job :P
12:31:37 <rostayob> mjga: I meant there is no hope for vaporware :)
12:31:52 <scolobb> rostayob: Not sure about Duke Nukem, but working on Hurd was thrilling :-)
12:32:10 <rostayob> scolobb: now, when duke nukem will run on the Hurd...
12:32:18 <scolobb> elliott: Well :-) I don't do that quite often, but it's always fun :-)
12:32:21 <scolobb> rostayob: :-D
12:32:23 <donri> http://donri.zapto.org/ omg look everyone it's hackage 2
12:32:26 <hydo> I can't help but be a little disappointed that HURD didn't gain traction.  There were a few things about it that I really liked.
12:32:39 <zzo38> Num/Integral classes do not really have the correct mathematical properties for list indices in my opinion.
12:32:40 <elliott> rostayob: That's the only thing that could make HURD less appealing.
12:32:46 <hydo> of course, I haven't thought about it in a long time, so I can't defend that statement.
12:32:49 <rostayob> elliott: it's the symbolic value man.
12:33:05 <dougransom> elliott,yitz:  Thanks - trying to reason through it  now:).
12:33:05 <rostayob> combined waiting time: >> 9000
12:33:14 <scolobb> hydo: Microkernel OS haven't yet dealed with their most important problems, unfortunately
12:33:48 <lispy> New GHC releases are a lot of work for us users :(
12:34:24 <zzo38> Why does nobody know my questions?
12:34:29 <shachaf> lispy: The GHC 7.4 upgrade went pretty smoothly for me.
12:34:30 <elliott> lispy: How can anyone complain when we have declarations in GHCi?
12:34:36 <hydo> scolobb: ..... does that statement really apply that generally?  I'm trying to think of a production microkernel os.
12:34:44 <elliott> zzo38: Because they're yours.
12:34:49 <hydo> scolobb: damn... I think you might be right.
12:34:49 <elliott> hydo: OS X. Technically.
12:34:54 <rostayob> zzo38: Peanoid is an obscene name.
12:35:01 <elliott> Minix is meant to be "production" these days.
12:35:03 <scolobb> hydo: Yeah, that's why I'm trying as well :-( I though Symbian was cool, but, heh
12:35:13 <rostayob> I'm not writing "Peanoid" in my programs.
12:35:25 <zzo38> rostayob: Then change it; I don't care.
12:35:26 <newsham> hurd gets a disproportionate amount of attention compared to many other projects that are jsut as capable (or more)
12:35:31 <lispy> shachaf: I'm having FFI warnings everywhere
12:35:31 <rostayob> zzo38: but yes, indices should be naturals.
12:35:36 <rostayob> zzo38: but it's too late!
12:35:38 <hydo> elliott: oh man, huge soft spot in my heart for minix.  I learned so much with that os.
12:35:45 <elliott> hydo: So did Linus.
12:35:47 <shachaf> lispy: Oh, I haven't compiled actual code with it yet or anything.
12:35:55 <rostayob> I learned with pintos!
12:35:57 <hydo> elliott: haha... yes he did.
12:36:14 <rostayob> pintos: https://en.wikipedia.org/wiki/Pintos
12:36:42 <zzo38> I know my Peanoid class is a specific kind of pointed unary system (it follows the first six Peano axiom), but that doesn't know what name Copeanoid can be changed to!!!
12:36:56 <scolobb> rostayob: Hm, looks cool; never heard of it before
12:36:57 <hydo> pintos = plan9, nachos = inferno  pretty cool.
12:37:21 <scolobb> Plan9 was the hero of the fairy tales I was once told :-)
12:37:24 <hydo> ie hardware vs. host os.  still interesting.
12:38:21 <rostayob> zzo38: Copeanoid = codata version of Peanoid?
12:38:23 <hydo> scolobb: yea, I ran plan9 for a while... well, ok, a week, on a few machines.  That's another one that I really wanted to take off.
12:38:30 <lispy> shachaf: the problem I'm having is that now with the FFI you need access to data constructors to bind to a type.
12:38:37 <newsham> i love plan9.  but i dont use it for anything important
12:38:49 <hydo> Then again, I LOVED Apollo DomainOS and being able to 'cd //<any machine on the network>/
12:38:50 <rostayob> zzo38: if you're saying that list indices should be natural numbers, that's fair enough
12:39:00 <elliott> lispy: Really?
12:39:00 <lispy> shachaf: I have all this GLint stuff that used to work but now OpenGLRaw needs to export it's internal only module for defining these types
12:39:02 <elliott> That's weird as heck.
12:39:05 <zzo38> rostayob: I will write out my definition so that you can understand better, and then maybe you know:   class Peanoid x where { zeroP :: x; succP :: x -> x; }; class Copeanoid x where { predP :: x -> Maybe x; };
12:39:06 <scolobb> Hm, I've never expected to find so many fans of some various OSs here :-)
12:39:29 <zzo38> rostayob: So, yes it is like natural numbers but it is two classes instead
12:39:29 * elliott is an OS fan.
12:39:34 <elliott> lispy: What if only some of the constructors are available?
12:39:44 <lispy> Warning: newtype `GLint' is used in an FFI declaration, but its constructor is not in scope. This will become an error in GHC 7.6.1.
12:39:46 * hydo is an OS slut.  I'll sleep with any of them for a few days.
12:39:57 <scolobb> elliott, hydo: :-D
12:39:58 <monochrom> yikes
12:40:12 <newsham> hydo: goofed off with genode or okl4?
12:40:12 <hydo> same with languages.  I might have married haskell, but sometimes I'm a little unfaithful. :(
12:40:20 <elliott> lispy: that's utterly bizarre
12:40:20 <monochrom> Tanenbaum probably opposes you sleeping with minix!
12:40:36 <hydo> newsham: oooo... no.  never heard of them.
12:40:46 <monochrom> language polygamy ftw!
12:41:02 <scolobb> monochrom: Tannenbaum opposes hydo's sleeping with Tannenbaum's instance of Minix, I'd say ;-)
12:41:04 <zzo38> rostayob: So, if you dislike it, tell me how to adjust it please; I don't know the other name sorry
12:41:05 <monochrom> (why call yourself unfaithful when you can faithfully marry them all!)
12:41:06 <mike-burns> "Polygamy" is marriage.
12:41:21 <mike-burns> Ah.
12:41:23 <hydo> oh, as an aside, are there any new efforts with House or the like?  The idea of a haskell os is tantalizing in the best way.
12:41:28 <newsham> hydo: check out the genode live cd and the youtube demo
12:41:40 <newsham> ok-labs.com has lots of material on okl4
12:41:46 <scolobb> hydo: Was just going to ask the same question
12:41:52 <hydo> newsham: reading the site now.  I'll grab it.  Thanks!
12:41:54 <mike-burns> I'd hate deal with the package manager on an all-Haskell OS.
12:42:14 <elliott> mike-burns: Really? Purely-functional package managing has proved itself in practice.
12:42:22 <hydo> mike-burns: cabal-dev !
12:42:23 <lispy> elliott: and they're just newtypes to boot
12:42:25 <elliott> *management
12:42:27 <mike-burns> hydo: Hah, exactly.
12:42:30 <elliott> mike-burns: See Nix.
12:42:32 <lispy> cabal-dev ftw
12:42:34 <mike-burns> elliott: Yes, but cabal hasn't!
12:43:06 <elliott> mike-burns: cabal is impure! :P
12:43:19 <mike-burns> Yup.
12:43:35 <mike-burns> Haskell doesn't have a purely functional package manager, but it does have cabal-install!
12:44:02 <scolobb> We can set up an endeavour after Cabalette, the Pure Package Manager
12:44:46 <donri> isn't dcoutts doing something nixish for cabal
12:46:34 <Tomsik> Anyone used gloss on windows?
12:46:39 <Guest26618> Hm.
12:46:43 <Guest26618> :
12:46:45 <Guest26618> what
12:46:49 <Guest26618> Why.
12:47:05 <zzo38> If you make Haskell operating system, then you can have mutliple virtual consoles and/or windows with GHCi command shell, and use a completely different definition of IO, such as, a program calling another one can override systems calls in this way (similar to how ptrace can do on Linux)
12:47:12 <hydo> Ok, genode looks seriously cool.
12:47:25 <lispy> If I move a module from other-modules to exposed-modules, do I need to bump the the second number or can I just increment the last version number? (thinking about the PVP)
12:47:44 <mike-burns> What's in the module?
12:47:51 <lispy> zzo38: or make a Haskell OS with HalVM
12:48:06 <zzo38> lispy: What does HalVM mean?
12:48:08 <lispy> mike-burns: just type definitions
12:48:16 <Tomsik> I got gloss through cabal and compiled my program (copy-pasted from doc, really). Then it complained on run-time about missing GLUT so I got glut.dll and glut32.dll
12:48:17 <scolobb> zzo38: I recently thought about doing away with IO as much as possible in a Haskell shell; like, limiting it to state vars only
12:48:18 <elliott> zzo38: http://halvm.org/wiki/
12:48:18 <ion> @google "halvm"
12:48:19 <lispy> zzo38: http://halvm.org/wiki/
12:48:21 <lambdabot> http://halvm.org/
12:48:21 <lambdabot> Title: HaLVM
12:48:27 <elliott> http://halvm.org/wiki/ http://halvm.org/wiki/ http://halvm.org/wiki/
12:48:30 <elliott> not linked enough times yet
12:48:33 <albel727> HAL.
12:48:36 <Tomsik> and now it says something about hputchar and invalid code pages
12:48:39 <ion> “@lmgtfy” should be an alias to “@google”.
12:48:45 <elliott> Tomsik: You have a Unicode issue.
12:48:49 * albel727 feels something ominous for some reason.
12:48:53 <mike-burns> lispy: PVP says that you just have to bump the third value.
12:48:56 <elliott> Tomsik: Are you printing out strings in your program?
12:48:59 <lispy> Tomsik: use the GLFW-b version
12:49:06 <elliott> Oh, listen to lispy.
12:49:08 <hydo> oh DAMN... I forgot about halvm
12:49:22 <lispy> Tomsik: I think that bug was fixed in GLUT.  What version of GLUT do you have?
12:49:28 <Tomsik> lisp: how do I do that?
12:49:29 <elliott> Tomsik: cabal install --reinstall gloss --flags="GLFW -GLUT" might work if you want the GLFW version
12:49:30 <lispy> mike-burns: thanks
12:49:34 <hydo> thank you, I've been meaning to set up a machine for that.
12:49:35 <scolobb> Oh, HalVM!  That's a revelation :-)
12:49:39 <elliott> you will need to recompile your program
12:49:48 * hackagebot vcswrapper 0.0.1 - Wrapper for source code management systems  http://hackage.haskell.org/package/vcswrapper-0.0.1 (StephanFortelny)
12:49:51 <zzo38> Do you need state vars too?
12:50:10 <scolobb> I wouldn't think you could do away with IO completely
12:50:13 <eyebloom> What is the meaning of a parenthesized arrow (->) as in the message  " No instance for (Naive ((->) (S.Set G.Vertex))) arising from a use of `ext'  "?
12:50:13 <eyebloom>  
12:50:30 <scolobb> State vars seem the least evil
12:50:55 <Tomsik> That "GLFW version" worked, though I'm not quite sure what it is
12:51:22 <zzo38> I think you could do away with IO completely; only the kernel needs direct I/O and in programs the IO type can just be the action which other programs can look at and override before sending to the next in the chain (which might be the kernel)
12:51:28 <Tomsik> Thanks
12:51:50 <elliott> eyebloom: (->) a b = a -> b
12:51:53 <elliott> it's just partially applied
12:52:04 <elliott> you acn think of ((->) (S.Set G.Vertex)) as (S.Set G.Vertex ->)
12:52:27 <scolobb> zzo38: Yeah, but you would still need some storage from your OS, wouldn't you
12:52:39 <eyebloom> I see so it's partial application on a type level.
12:52:40 <lispy> Tomsik: GLFW is an alternative to GLUT. Different API and a bit better.  GLUT is way ancient.
12:52:42 <scolobb> Like, where do I keep my pictures, if there's no IO whatsoever
12:52:49 <lispy> Tomsik: GLFW-b is a haskell binding to GLFW that is smooth to install.
12:53:11 <Tomsik> Sounds good :)
12:53:32 <zzo38> scolobb: Yes; well, you tell the kernel to store the pictures. So there still is I/O but only on the kernel and not on the user programs.
12:53:32 <Tomsik> Is there a reason why it's not default for gloss?
12:53:40 <lispy> Tomsik: That I don't know.
12:54:03 <lispy> Tomsik: maybe tell the gloss author that GLFW-b works better for you than GLUT and he'll change it?
12:54:16 <elliott> lispy: it's on the homepage (that reinstall command)
12:54:24 <scolobb> zzo38: Hm, I get your point
12:54:25 <elliott> so the issues must be well-known to the author
12:55:27 <Tomsik> Hmm, it is, but it's answer to a different problem
12:57:13 <hydo> hrm, looks like you can run the hypervisor in virtualbox to test halvm.  nice.
12:57:50 <scolobb> hydo: Cool; feel compelled to test it
12:58:10 <scolobb> s/feel/I feel/
13:00:39 <ion> mm_freak: I finally got around to reading your unfinished article about arrows. It’s excellent.
13:01:16 <Rmx> wich article ?
13:01:22 <Rmx> is there any link ?
13:03:05 <ion> He asked me not to spread the link, so you’ll have to ask him about it.
13:03:32 <Rmx> it is any tutorial ?
13:03:35 <Rmx> soon to be released ?
13:03:42 <Rmx> and ok :)
13:04:00 <elliott> mm_freak: I'm interested, if you feel like spreading it further
13:04:14 <rostayob> mm_freak: me too
13:04:23 <parcs`> > sqrt 3 / 2 - pi / 9
13:04:24 <lambdabot>   0.5169595533855726
13:04:34 <tazjin> I'll wait for the finished version. #patienceasavirtue
13:04:57 <Rmx> mm_freak: me too
13:05:33 <cmccann> fortunately arrow tutorials can be duplicated
13:05:51 <mm_freak> alright, then spread it, but at least don't put the link anywhere public =)
13:05:51 <cmccann> category tutorials can only be passed along from person to person
13:06:06 <CodeWeaverX> Sort of like "The Ring".
13:06:11 <mm_freak> it's a preliminary URL and i'd like not to have it indexed
13:06:14 <Rmx> I'm not so sure it is a virtue so much :)
13:06:15 <CodeWeaverX> >.>  <.<
13:06:44 <rostayob> mm_freak: it'll be indexed anyways! i've had the most improbable urls indexed
13:06:45 <mm_freak> anyway, ion, glad you found it helpful =)
13:06:53 <mm_freak> rostayob: of course =)
13:07:00 <rostayob> :_
13:07:02 <rostayob> *:)
13:07:15 <elliott> cmccann: And tutorials on how to write monad tutorials can be turned into monad tutorials.
13:07:28 <monochrom> hahahaha
13:07:39 <scolobb> mm_freak: I'd like to be in, as well :-)
13:07:40 <mm_freak> ah, screw it
13:07:41 <Rmx> ^^
13:07:42 <mm_freak> http://ertes.de/new/tutorials/arrows.html
13:07:44 <mm_freak> there it is
13:07:44 <cmccann> elliott, and any random topic can be turned into a monad tutorial, apparently
13:07:52 <rostayob> yeeee
13:07:53 <mm_freak> no idea when i'll have time to update it anyway =)
13:07:53 <elliott> cmccann: Duh.
13:08:07 <mm_freak> lol elliott
13:08:12 <monochrom> cmccann: I think the pun is in join :: m (m a) -> m a
13:08:19 <hydo> Am I just being dense or is there no way to specify building a dependency with a flag in a cabal file?  ie. a Snap project with snap built with -fhint?
13:08:21 <cmccann> monochrom, and mine was on return
13:08:29 <monochrom> ok!
13:08:32 <elliott> mm_freak: ehm
13:08:37 <elliott> mm_freak: I hope you realise Google sees the clog logs.
13:08:45 <Saizan> hydo: nope it's deliberately like that
13:08:57 <scolobb> mm_freak: Thanks :-)
13:09:09 <Rmx> mm_freak, wait, you're the netwire guy ? :)
13:09:09 <hydo> Saizan: ok, just making sure.
13:09:15 <rostayob> Rmx: yes
13:09:49 <Rmx> ok! and Elliott the 7 pages cv guy
13:10:10 <rostayob> Rmx: if you're thinking of Conal Elliott, no. elliott is an impostor.
13:10:21 <Rmx> oki
13:10:39 <elliott> rostayob: You ruined it!!
13:10:45 <rostayob> elliott: shit. sorry
13:10:47 <elliott> I was basking in that! :'(
13:10:47 <nand`> mm_freak: block google
13:11:13 <scolobb> elliott: Thy face henceforth uncovered is
13:11:22 <McManiaC> how do you read GHC coredumps?
13:11:25 <rostayob> elliott in 1998: well, this #haskell is cool, who can I steal the nickname from?
13:11:29 <scolobb> nand`: DDoS, heh?
13:11:30 <McManiaC> gdb doesnt look useful really
13:11:37 <Rmx> Ahah :)
13:11:39 <nand`> scolobb: huh
13:11:47 <elliott> rostayob: I only acquired this name a bit over a year ago, actually :)
13:11:52 <mm_freak> elliott: i know, but google will be smart enough to remove the link, when i remove the document
13:11:58 <mm_freak> Rmx: yeah, that's me =)
13:11:59 <elliott> Someone was stupid enough to let this prime piece of nick real estate lapse :P
13:12:20 <rostayob> elliott: :)
13:12:40 <elliott> Speaking of which -- any Elliotts out there -- this nick is yours, $500. Open to bartering.
13:13:03 <rostayob> mm_freak: your document lives safely in my papers/ folder now.
13:13:08 <elliott> That's not what bartering is. I'm too tired.
13:13:09 <Rmx> Haskell community is crazy o_O
13:13:22 <Axman6> supercrazy
13:13:22 <CodeWeaverX> Yes.
13:13:22 <CodeWeaverX> Yes it is.
13:13:25 <CodeWeaverX> And wonderful.
13:13:26 <CodeWeaverX> :D
13:13:28 <scolobb> Rmx: Prove it formally ;-)
13:13:35 <scolobb> CodeWeaverX: Absolutely
13:13:38 <Axman6> we're also cocrazy
13:13:49 <Rmx> >"Haskell community is Crazy"
13:13:55 <Rmx> > "Haskell community is Crazy"
13:13:56 <scolobb> Axman6: Yeah, and that's the beauty
13:13:56 <mm_freak> rostayob: i wanted it to become part of my new hakyll-based homepage, but i've abandoned it again for yet another new approach, this time based on yesod
13:13:56 <lambdabot>   "Haskell community is Crazy"
13:13:57 <CodeWeaverX> I think functional programming does something to peoples' brains.
13:14:06 <Rmx> Lambdabot told it t_t
13:14:06 <scolobb> Rmx: Chanting around? :-)
13:14:19 <mm_freak> CodeWeaverX: definitely
13:14:20 <rostayob> mm_freak: oh, ok. I'll try to read your doc soon anyways
13:14:24 <elliott> rostayob: Did you ever define that ArrowLoop instance?
13:14:30 <JoeyA> It's not unlike drugs.
13:14:31 <Rmx> :p
13:14:35 <rostayob> elliott: nope. I mean I'm stuck with my stupid instance.
13:14:36 <JoeyA> @quote drugs
13:14:36 <lambdabot> gwern says: [of inserting BangPatterns everywhere] that's like saying if you inject drugs everywhere on your body that isn't instantly fatal, that will fix whatever disease you may have
13:14:39 <JoeyA> nvm
13:14:42 <elliott> rostayob: :(
13:14:49 * hackagebot system-fileio 0.2.4 - Consistent filesystem interaction across GHC versions  http://hackage.haskell.org/package/system-fileio-0.2.4 (JohnMillikin)
13:14:51 * hackagebot system-fileio 0.3.4 - Consistent filesystem interaction across GHC versions  http://hackage.haskell.org/package/system-fileio-0.3.4 (JohnMillikin)
13:14:51 <ion> @check \haskellCommunity -> crazy haskellCommunity
13:14:53 <lambdabot>   "OK, passed 500 tests."
13:14:55 <rostayob> elliott: I've been shell shocked since.
13:15:02 <JoeyA> heh
13:15:05 <elliott> gwern has clearly been to my parties.
13:15:15 <scolobb> ion: I think cocraziness should be checked as well
13:15:18 <ion> I misread that as “panties”.
13:15:23 <rostayob> that too.
13:15:24 <mm_freak> haskell is a drug, and i have trouble getting clean
13:15:34 <elliott> @check \crazy -> crazy haskellCommunity
13:15:34 <lambdabot>   Overlapping instances for GHC.Show.Show (() -> t)
13:15:35 <lambdabot>    arising from a use of ...
13:15:40 <elliott> Oh come on!!!
13:16:02 <mm_freak> it has totally ruined me for all dynamic languages, and even the static languages don't really satisfy me anymore
13:16:17 <scolobb> mm_freak: Same story here :-)
13:16:22 <mm_freak> luckily i went away from agda, before it could ruin me for haskell =)
13:16:27 <JoeyA> Why doesn't GHC have an event manager backend for Windows?  Is it simply because nobody's gotten around to writing one, or is there something particularly hairy about Windows that makes it hard to write one?
13:16:35 <rostayob> mm_freak: actually I'm in that position now...
13:16:43 <JoeyA> (e.g. having to distinguish between sockets and file handles)
13:16:45 <rostayob> the thing is that agda makes it fairly hard to write useful programs
13:16:50 <Rmx> I haven't used netwire so much yet, but it looks like the summum of code reusability
13:16:50 <rostayob> so it's hard to get properly hooked
13:16:57 <Rmx> why isn't it being used more ?
13:17:09 <mm_freak> JoeyA: there is nothing inherently difficult in windows (except perhaps the ugly native API), and i'm pretty surprised that it isn't implemented
13:17:09 <Rmx> I haven't see so many examples aroud
13:17:13 <rostayob> Rmx: I think it got a fair amount of interest
13:17:32 <mm_freak> i'd expect the RTS to have a decent windows implementation of concurrency
13:17:44 <Rmx> do you think it's going to become the new haskell way of coding ?
13:17:50 <JoeyA> mm_freak: It has that (I think).  I meant I/O manager, sorry.
13:17:58 <mm_freak> rostayob: my goal to combine haskell and agda failed miserably
13:18:12 <mm_freak> JoeyA: that's roughly the same
13:18:17 <rostayob> mm_freak: I'm almost done with the agda tutorial. That language is crazy.
13:18:31 <blackdog> JoeyA: presumably johtib and bos aren't terribly concerned with windows IO performance...
13:18:37 <elliott> Rmx: It doesn't make sense to consider libraries "new ways of coding" that replace other things.
13:18:39 <mm_freak> Rmx: i'd say netwire is great for FRP people and useless for everybody else =)
13:18:50 <elliott> FRP is general, sure, but it's not like we're going to throw out all our code overnight if it becomes practical...
13:18:52 <Rmx> ok
13:19:17 <ion> I’ll throw out all your code overnight.
13:19:24 <Entroacceptor>  s
13:19:26 <mm_freak> Rmx: it's an innovative FRP library, implementing some new, experimental concepts
13:19:49 <JoeyA> EPoll.hsc is only 210 lines long.  I wonder if it would be un-insane for me to try to write a backend.
13:19:53 * hackagebot Workflow 0.6.0.0 - library for transparent execution of interruptible computations  http://hackage.haskell.org/package/Workflow-0.6.0.0 (AlbertoCorona)
13:19:55 <mm_freak> basically there are two major FRP libraries:  reactive-banana, solid, stable
13:20:09 <mm_freak> and netwire:  innovative, fast, highly experimental
13:20:15 <statusfailed> can I pattern match any constructor with _?
13:20:20 <Entroacceptor> can'twe have a stable one
13:20:29 <elliott> mm_freak: I heard netwire will revolutionise the entire human species and eventually replace the entire cosmos with arrows in the "Big Crunch", after which the universe will be replaced with pure perfection and SPJ and whatever random person made that library will be crowned gods.
13:20:29 <rostayob> statusfailed: _ will pattern match everything, and bind nothing.
13:20:32 <elliott> True/false?
13:20:55 <Rmx> Maybe True
13:21:00 <statusfailed> rostayob: ah, so I can't do _ Nothing = "nothing"
13:21:00 <rostayob> 2500 history ebook: WWII -> moon -> netwire
13:21:03 <scolobb> Oh, looking forward to it :-)
13:21:04 <mm_freak> elliott: would it be fair for me to judge considering that i'm the author? =P
13:21:11 <elliott> mm_freak: That's the joke. :(
13:21:17 <mm_freak> i know =)
13:21:18 <rostayob> scolobb: I'm not sure what you mean, what are you trying to write?
13:21:48 <mm_freak> ah, and of course one major difference between reactive-banana and netwire…
13:21:54 <Peaker> I'm trying to "runhaskell Script.hs" from an empty environment (no env vars), and it's missing libraries. What env vars does "runhaskell" depend on to find its libraries?
13:21:56 <Eduard_Munteanu> statusfailed: what do you mean? No, you can't use '_' to match on the function
13:22:07 <mm_freak> you can actually learn reactive-banana before the heat death of the universe =)
13:22:12 <scolobb> rostayob: "the universe will be replaced with pure perfection" -- I'm looking forward to this part of elliott's discourse :-)
13:22:13 <Peaker> (I need to export any such env vars manually)
13:22:31 <mm_freak> i have to admit, netwire is difficult to get into
13:22:32 <elliott> scolobb: That means that all those awful imperfect humans will have to go, of course.
13:22:40 <ion> _ = "oh yeah, method_missing for Haskell!"
13:22:54 <Rmx> mm_freak, I wouldn't be here if it was my main concern ;)
13:23:00 <statusfailed> Eduard_Munteanu: all my constructors have the same type parameter
13:23:00 <scolobb> elliott: Or evolutionise into pure beings
13:23:00 <rostayob> scolobb, elliott: logan's run?
13:23:05 <rostayob> or what was the other one
13:23:11 <statusfailed> Eduard_Munteanu: but it seems a dumb question now :P
13:23:12 <rostayob> anyways. netwire.
13:23:27 <elliott> scolobb: No. That would be an impure, stateful transformation.
13:23:36 <elliott> scolobb: We'll model a perfect being on you, and then destroy you.
13:23:49 <scolobb> elliott: Damn.  Too bad.  :-D
13:23:54 <elliott> Garbage Collector would be a great terrible film.
13:24:08 <scolobb> Who's going to watch it? :-)
13:24:09 <elliott> IT CAME... FOR THE UNWANTED... BUT NOW... IT COMES... FOR YOU
13:24:22 <scolobb> Sweet pairs of kissing arrows? ;-)
13:24:41 * scolobb shivers in awe/panic
13:24:42 <rostayob> "You've been garbage collected"
13:24:52 <rostayob> dum-dum
13:25:01 <mm_freak> "Epoch over"
13:25:08 <rostayob> "BLACKHOLE"
13:25:08 <elliott> You don't want to know what the free list looks like.
13:26:03 <mm_freak> "Scope over"
13:26:07 <companion_cube> only C would still resist the tyranny of the GC!
13:26:17 <scolobb> companion_cube: :-D
13:26:27 <scolobb> I'll rewrite myself in C, then :-)
13:26:31 <companion_cube> people hide in the dangling pointers
13:26:35 <mm_freak> no, the GC has an army of libraries
13:26:39 <scolobb> C has states, and even such an impure being as me can be coded in it
13:27:07 <JoeyA> There's libgc, a garbage collection library for C.
13:27:26 <elliott> Not really C.
13:27:33 <mm_freak> also there are haskell programmers
13:27:36 <elliott> A wildly nonstandard variant of C that happens to be supported by lots of platforms :)
13:27:43 <scolobb> JoeyA: Does that mean that C will be garbage-collected eventually?..
13:27:57 <mm_freak> int withFile(const char *fn, const char *mode, int (*k)(FILE *));
13:28:08 <JoeyA> heh
13:28:10 <mm_freak> nobody stops them from doing manual garbage collection
13:28:11 <e98> doesn't happy build with ghc-7.4.1?
13:28:17 <JoeyA> Wouldn't it be great if C disappeared tomorrow?
13:28:21 <elliott> e98: IIRC, known issue.
13:28:40 <rostayob> JoeyA: if you'd like the world imploding
13:28:41 <mm_freak> JoeyA: to be replaced by what?
13:28:43 <JoeyA> Oh wait, that would make Haskell's network, I/O, and integer support go away.
13:28:45 <scolobb> JoeyA: There are more horrible beasts
13:28:45 <mm_freak> google go?  fortran?
13:28:53 <rostayob> fortran AH
13:29:01 <ivanm> JoeyA: and RTS
13:29:05 <rostayob> i'd love an os in fortran
13:29:07 <lispy> deriving (Typeable) should get added to Haskell'
13:29:11 <mm_freak> i'd rather wait for the annihilation of the cobol race
13:29:12 <scolobb> rostayob: :-D
13:29:13 <mm_freak> it's long overdue
13:29:20 <JoeyA> No, not my Starcraft!
13:29:34 <Peaker> JoeyA: It would be great if C disappeared *after* there was a good replacement for it
13:29:40 <e98> all I wanted to do is try yesod :)
13:29:54 <elliott> I bet Bit-C development would accelerate if C disappeared :)
13:30:03 <mm_freak> e98: i recommend GHC 7.0 for yesod ;)
13:30:04 <elliott> ...but then, C++ would still exist :/
13:30:06 <Peaker> maybe ATSlang is good
13:30:09 <e98> 1st hsenv failed on arch linux, but doesn't on OS X
13:30:29 <Sgeo> I still can't quite wrap my head around ATS
13:30:35 <scolobb> elliott: Unless the disappearance of C would pull the dependencies as well
13:30:42 <e98> yesod works fwith 7.4, but the demo site needs hjsmin and therefore happy
13:30:47 <scolobb> After all, C is supernatural at times
13:30:50 <Peaker> mm_freak: I think doing Haskell programming with manual memory management is somewhat similar to writing purely functional code in C
13:30:57 <elliott> scolobb: I think most computers in the world would disappear, then.
13:30:59 <mm_freak> e98: you don't need to compile happy with the same GHC version
13:31:07 <mm_freak> e98: just install happy through your distribution
13:31:09 <Peaker> (You can try to use that style, you'll reap pain but not benefits)
13:31:19 <scolobb> elliott: We return to Lisp Machines; not that bad, after all
13:31:29 <mm_freak> Peaker: i was actually talking about C
13:31:41 <Peaker> mm_freak: Ah, misunderstood :)
13:31:46 <e98> mm_freak: I know, thanks for the reminder
13:31:48 <e98> hsenv: fd:9: hGetContents: invalid argument (invalid byte sequence)
13:31:50 <e98> hsenv: thread blocked indefinitely in an MVar operation
13:32:01 <e98> anybody seen these errors with hsenv?
13:32:10 <elliott> scolobb: I'm sure Lisp Machines involved C at some point during their development... there's ZETA C and all, after all
13:32:24 <Sgeo> ZETA C?
13:32:27 <rostayob> I don't like Lisp.
13:32:32 <e98> I was also able to exceed the tickcount a lot today
13:32:49 <scolobb> elliott: Oh :-( I thought Lisp machines were Lisp-only, down to the bones
13:33:12 <JoeyA> (how (could) (you) ((not like) Lisp '?)))
13:33:21 <elliott> scolobb: They are, but if we're pulling all dependencies -- I am sure Lisp Machines were originally created on a machine running C software.
13:33:33 <elliott> (ZETA C was a Lisp Machine C compiler.)
13:33:36 <Sgeo> How does ATS compare to Haskell
13:33:40 <elliott> (It had bignum ints, and non-integral pointers.)
13:33:47 <elliott> Sgeo: It doesn't.
13:33:50 <ivanm> elliott: nah, just a magnetised needle and a steady hand :p
13:33:56 <scolobb> elliott: Ah, so we're considering historical dependencies as well; sounds horrible
13:34:05 <scolobb> I'll have trouble sleeping at night
13:34:36 <scolobb> ivanm: A very small hand at that would be just appropriate :-)
13:36:10 <teneen> Can I restrict a function to accept only a certain data constructor using DataKinds?
13:36:10 <monochrom> by the way, I just realize that in the movie Inception, in the beginning, the protagonist is doing a job for "cobol engineering"!
13:36:45 <ivanm> teneen: well, you could always have it return a Maybe value... but I'm not familiar enough with DataKinds to answer
13:36:59 <scolobb> monochrom: Terrible :-()
13:37:24 <elliott> teneen: No.
13:37:46 <elliott> teneen: You should factor out what you can accept into another type instead; that's what they're for :)
13:39:07 <teneen> eliott: thanks, but can you show me a brief example on how to do this?
13:39:29 <teneen> elliott:
13:39:49 * hackagebot OpenGLRaw 1.2.0.0 - A raw binding for the OpenGL graphics system  http://hackage.haskell.org/package/OpenGLRaw-1.2.0.0 (JasonDagit)
13:39:53 <elliott> teneen: data Foo = A | B | C; data Bar = Blah Foo | D | E
13:40:02 <elliott> Then if you only want to accept A, B and C, write foo :: Foo -> ...
13:40:11 <elliott> No fancy tricks at all, just using types and composition.
13:40:42 <Sgeo> @hoogle def
13:40:43 <lambdabot> System.Posix.DynamicLinker.Prim Default :: DL
13:40:43 <lambdabot> System.Posix.Signals Default :: Handler
13:40:43 <lambdabot> keyword default
13:40:51 <teneen> elliott: is it possible that the function can only accept A?
13:41:03 <scolobb> teneen: You might throw an exception when you get a constructor you don't want
13:41:09 <elliott> teneen: data Foo = A; data Bar = BarFoo Foo | B | C; data Quux = QuuxBar Bar | D | E
13:41:25 <elliott> scolobb: At least use a Maybe result instead of that if you're going down that route...
13:41:43 <teneen> elliott: thanks a lot :)
13:41:49 <scolobb> elliott: Yes, that's much better.  I don't like exceptions
13:42:03 <Sgeo> Prefer to use static typechecking over run-time checking. Prefer to use Maybe and Either and things of that nature over bottoms (unless in IO, depending on circumstances)
13:42:49 <scolobb> I tried Haskell exceptions a couple times, never liked it better than Either or Maybe
13:43:02 <scolobb> Are exceptions widely used somewhere, though?
13:43:09 <erus`> i dont get schrodingers cat; the cat is both dead and alive until we observe it, then it is dead OR alive
13:43:44 <elliott> scolobb: Yes: in IO. Also, for asynchronous exceptiopns.
13:43:50 <mjga> Sgeo: people omit Maybes and Eithers out of convenience, not lack of preference. It may be difficult to imagine all possible failure modes in advance. it may be unnecessarily verbose to handle all your exceptions explicitly (as Java people have long learned when they tried to put "raises" decl to every method)
13:43:52 <elliott> scolobb: Also a ton of Prelude functions will happily throw exceptions (with "error").
13:44:04 <erus`> but its not dead and alive before we observe it. Its still dead or alive.
13:44:13 <Sgeo> erus`, under the multiple worlds interpretation, the cat stays both dead and alive, and we both see the cat as alive and see the cat as dead.
13:44:13 <elliott> erus`: -blah?
13:44:16 <elliott> > (head [], tail [], init [])
13:44:17 <lambdabot>   (*Exception: Prelude.head: empty list
13:44:35 <elliott> > 1 `div` 0
13:44:36 <lambdabot>   *Exception: divide by zero
13:44:39 <scolobb> elliott: Yes, head was what I thought of; but I did see in a couple places that it's not that good
13:44:49 * hackagebot OpenGL 2.5.0.0 - A binding for the OpenGL graphics system  http://hackage.haskell.org/package/OpenGL-2.5.0.0 (JasonDagit)
13:44:51 * hackagebot GLURaw 1.2.0.0 - A raw binding for the OpenGL graphics system  http://hackage.haskell.org/package/GLURaw-1.2.0.0 (JasonDagit)
13:44:52 <elliott> Yes, but e.g. nobody really objects to div. What we really want is
13:44:53 * hackagebot GLUT 2.3.0.0 - A binding for the OpenGL Utility Toolkit  http://hackage.haskell.org/package/GLUT-2.3.0.0 (JasonDagit)
13:44:56 <Sgeo> scolobb, those Prelude functions are broken by today's standards.
13:44:59 <scolobb> I mean, it's not that good to throw exceptions
13:45:00 <elliott> div :: (Integral a) => a -> PositiveNatural -> a or so.
13:45:07 <erus`> Sgeo: is there compelling evidence for the multiple worlds ?
13:45:12 <elliott> But the numeric typeclass hierarchy is broken, so...
13:45:12 <scolobb> Sgeo: Yes, that's what I was trying to say
13:45:45 <Sgeo> As far as I'm aware, there's no real compelling evidence for any interpretation, but some people do say that multiple worlds is far simpler than other interpretations
13:45:53 <monochrom> schrödinger's box: before you look, the box contains a thunk or a value; after you look, it contains a value :)
13:46:00 <scolobb> elliott, Sgeo: thank you
13:46:01 <Sgeo> There's no notion of when a wavefunction collapses.
13:46:14 <Sgeo> monochrom, hehe
13:47:48 <Sgeo> I think I like ATS's tuples
13:47:48 <scolobb> As far as I know, nobody even says that Schroedinger's cat is even true; the point is that it the outcomes of this model fit with observable effects
13:48:02 <rostayob> why didn't 8), 3(2,4), 7(18), 5(2), 4(3)]
13:48:04 <rostayob> [rostayob(i)] why didn't
13:48:05 <Sgeo> Would ATS be suitable for general application programming?
13:48:06 <rostayob> ops.
13:48:09 <rostayob> what I wanted to say is.
13:48:10 <Sgeo> Or only for low-level system stuff?
13:48:18 * cmccann prefers many worlds because decoherence is a pure function while wave function collapse assumes the universe runs on in-place mutation
13:48:18 <rostayob> couldn't Schroedinger just use a glass box?
13:48:33 <elliott> rostayob: if you define "observing" as "seeing", sure
13:48:55 <scolobb> rostayob: The cat would feel depressed because of being constantly watched
13:48:55 <elliott> the definition of "observer" is always the tricky part of these things :)
13:48:58 <scolobb> That would be unethical
13:49:06 <rostayob> elliott: it's... it's a joke.
13:49:14 <elliott> rostayob: NO!!!! NO JOKES ALLOWED!!!!
13:49:19 <rostayob> elliott: :'(
13:49:20 <monochrom> you can use IO to run in-place mutation
13:49:21 <elliott> THIS IS VERY SERIOUS #HASKELL DISCUSSION
13:49:29 <nand`> a glass box inside a portal to an alternate dimension
13:49:42 <elliott> nand`: ooh, now it's as practical as it is ethical
13:49:44 <cmccann> that is a lot of capital letters.
13:49:50 <scolobb> Hm, I think a glass sphere would be much purer
13:49:59 <elliott> cmccann: I had a bunch free. gotta spend them on something
13:50:06 <rostayob> floating glass sphere
13:50:14 <cmccann> elliott, ok. makes sense.
13:50:15 <monochrom> use a glass Klein bottle
13:50:30 <rostayob> and the cat disappeared! thank you ladies and gents.
13:50:42 <erus`> i dont get how people made the jump to there being multiple universes until we observe them
13:50:50 <scolobb> Yes, that's what the cat would say
13:50:51 <erus`> what would lead you to think that?
13:50:59 <monochrom> Schrödinger's Klein glass bottle: before you look, the cat is inside or outside; after you look, it is inside and outside :)
13:50:59 <Sgeo> Hmm
13:51:01 <mm_freak> state DepressedCat t = Dead
13:51:02 <Sgeo> "if (x >= 0) then '0' else 1 // this expression can be given a type!"
13:51:18 <scolobb> erus`: It's just a model, whose outcomes are similar to what people observe in reality
13:51:27 <scolobb> monochrom: Awesome :-D
13:51:49 <cmccann> erus`, because there are multiple parallel possibilities at some level
13:52:06 <cmccann> erus`, many-worlds is just the naive extension of the simplest versions of what happens at small scales
13:52:19 <erus`> cmccann: where have you seen that?
13:52:31 <monochrom> you can use [] or LogicT to model many-worlds
13:52:36 <elliott> @remember monochrom Schrödinger's Klein glass bottle: before you look, the cat is inside or outside; after you look, it is inside and outside :)
13:52:37 <lambdabot> It is stored.
13:52:47 <dropdrive> What do you think "backend data transformation and loading" means here?  Sounds interesting - I want to transform, cache, and automatically invalidate "transformed" CSV files.  http://www.haskell.org/haskellwiki/Haskell_in_industry
13:52:58 <cmccann> erus`, er, physics? it's pretty standard stuff and not really on topic for #haskell :P
13:53:11 <monochrom> http://puzzle.cisra.com.au/2008/quantumwerewolf.html
13:53:14 <elliott> cmccann: But Haskell runs in universes based on physics!
13:53:45 <erus`> if you are talking about a qbit then i dont see how it relates
13:54:14 <scolobb> elliott: Anything computable can be coded and processed in Haskell, therefore anything computable is on-topic for #haskell :-)
13:54:33 <cmccann> ok, so no discussion of uncomputable things
13:54:44 <cmccann> sounds good to me
13:54:46 <monochrom> but you have to show haskell code. or at least show a type error
13:54:47 <elliott> scolobb: You can also use Haskell to explain uncomputable things too.
13:54:48 <CodeWeaverX> We need unhaskell for that.
13:54:49 * hackagebot lha 0.1 - Data structures for the Les Houches Accord  http://hackage.haskell.org/package/lha-0.1 (ScottLawrence)
13:54:51 * hackagebot MFlow 0.0.2 - (Web) application server. Stateful server processes. Simple, statically correct widget combinators.  http://hackage.haskell.org/package/MFlow-0.0.2 (AlbertoCorona)
13:54:53 <elliott> For instance, print out the Wikipedia article for Chaitin's omega.
13:55:00 <elliott> So anything describable is OK.
13:55:11 <scolobb> CodeWeaverX: Cohaskell? :-)
13:55:14 <elliott> Nobody talk about indescribable numbers, okay?
13:55:16 <scolobb> Ah, that's for cocomputable things
13:55:21 <elliott> Nobody even *mention* indescribable numbers.
13:55:23 <erus`> does the topic have to be computable in our lifetime?
13:55:36 <mm_freak> CodeWeaverX needs cohaskell
13:55:43 <mm_freak> and haskell coneeds deWeaverX
13:55:46 <tgeeky> erus`: luckily Haskell is lazy
13:55:46 <scolobb> erus`: That's a physics-related question :-)
13:56:13 <Axman6> that's a problem for engineers
13:56:17 <scolobb> Yeah, it would've been much more terrible if it had been colazy
13:57:20 <monochrom> hi, I need help writing haskell code to model quantum mechanics. here is the paste of my current code: http://hpaste.org/new
13:57:26 <monochrom> please help me write it!
13:57:28 <cmccann> scolobb, starting with evaluated results and unevaluating them on demand to compute the original expression?
13:58:16 <elliott> monochrom: You can't convert an IO Int to Int. Try using <- instead. You probably don't want to use an existential.
13:58:22 <cmccann> (of course, it will diverge if you attempt to unevaluate a result that's not computable)
13:58:25 <scolobb> cmccann: I can sense unitary (invertible) operators ;-)
13:58:25 <monochrom> hehe!
13:58:26 <elliott> monochrom: You're looking for "lenses", which are first-class record accessors.
13:58:36 <elliott> monochrom: Your indentation is wrong. You forgot a "return". You're using (/) on Integers.
13:58:37 * elliott explodes
13:58:48 <cmccann> haha
13:58:51 <rostayob> ahah
13:58:57 <monochrom> I am not using (/) on integers. the code is empty.
13:59:08 <Axman6> you will though
13:59:09 <cmccann> elliott, overdose on stackoverflow, huh
13:59:11 <monochrom> but I agree the indentation is wrong, and the rest
13:59:12 <ion> elliott: Hah
13:59:12 <CodeWeaverX> I am partially coneeded?  Neat!
13:59:26 <rostayob> cmccann: my "ahah" is the dual of your "haha".
13:59:31 <Sgeo> Can the Y-combinator be typed in ATS?
13:59:44 <teneen> elliott: but, out of curiosity, why is not possible to specify the kind of a function argument to be a promoted type?
13:59:50 <elliott> monochrom: Also: You have a lazy accumulator!
13:59:53 <cmccann> elliott, speaking of which you forgot "because type defaulting in GHCi" and "because IO buffering"
14:00:02 <elliott> teneen: Well, (->) takes types of kind * (well, not quite, it also allows unboxed types).
14:00:16 <elliott> Promoted types aren't really... types.
14:00:29 <cmccann> they're types, just a different kind of type
14:00:31 <cmccann> :D
14:00:35 <elliott> They're type-level values with a certain kind, but those type-level values aren't types, because it doesn't make sense to ask whether a value has one of them as its type.
14:00:52 <elliott> cmccann: Oh, yes, defaulting/monomorphism restriction is the other big one.
14:00:59 <ion> > co "haha"
14:01:01 <lambdabot>   "cohaha"
14:01:06 * elliott hasn't experienced IO buffering yet. I shall look forward to it.
14:01:10 <elliott> *buffering questions
14:01:13 <Axman6> > co "coconut"
14:01:14 <hpc> > co "coconut"
14:01:15 <lambdabot>   "conut"
14:01:16 <lambdabot>   "conut"
14:01:16 <Sgeo> "I use envless as a shorthand for environmentless, which is not a legal word but I guess you have no problem figuring out what it means."
14:01:17 <hpc> lol
14:01:20 <dev360> How can I take the output from a map operation and pass it in as a constructor to a data type? Its seeing the output of the map as a list - not sure what Im missing here.
14:01:24 <Axman6> =)
14:01:26 <scolobb> rostayob: If haha is computable, is ahah computable as well?
14:01:28 * scolobb hides
14:01:42 <Axman6> dev360: map only returns lists
14:01:55 <cmccann> elliott, the default buffering is different in GHCi vs. compiled programs or something, so people post questions like "why is my IO happening in the wrong order?"
14:01:56 <hpc> :t map
14:01:57 <lambdabot> forall a b. (a -> b) -> [a] -> [b]
14:02:00 <hpc> use the types, luke
14:02:10 <dev360> Axman6: is there no syntactic sugar that is available?
14:02:24 * Sgeo blinks at cloref1
14:02:24 <Axman6> dev360: to do what?
14:02:55 <hpc> dev360: what type do you want?
14:03:00 <monochrom> I think the question is scrambled
14:03:14 <Axman6> i think he wants Foo [a,b,c] -> Foo a b c
14:03:20 <elliott> monochrom: scrambled? you probably have IO buffering set wrong!
14:03:20 <dev360> Axman6: to pass the values inside of the list as if it was not a list.
14:03:28 <Axman6> but the question isn't clear
14:03:30 <cmccann> elliott, :D
14:03:32 <monochrom> yes!
14:03:43 <hpc> dev360: ah, so what Axman6 said?
14:04:01 <Axman6> dev360: what you're asking for is not type safe though
14:04:18 <dev360> Axman6: yes thats what I need to do, so I guess I can just write a function for it, but I was wondering if theres syntactic sugar in the standard library for this.
14:04:29 <Axman6> what if you wanted Foo [a,b,c] to befome Foo a b c, but you gave Foo [] or Foo [a,b]?
14:04:51 <dev360> Ok I see what you mean
14:05:09 <monochrom> what's wrong with "Foo (f a) (f b) (f c)"?
14:05:12 <parcs`> Sgeo: cloref means that the function is a closure, 1 means it may be impure
14:05:27 * elliott wishes there was a better term than "type-safety" for "impairs static guarantees".
14:05:29 <Sgeo> Ah
14:05:44 <monochrom> termination-safety
14:05:51 <elliott> "Not type safe" should mean "permits unsafeCoerce/the (co|contra)variant generics thing/etc.".
14:06:06 <hpc> elliott: "strongly normalizing"
14:06:08 <elliott> I guess the second one is still just impairing static guarantees.
14:06:10 <Sgeo> What's wrong with variant generics?
14:06:16 <elliott> But it's a more fundamental brokenness than just "can error out".
14:06:26 <elliott> Sgeo: The thing that means you can cast List<Cat> into List<Animal> and add a Dog.
14:06:35 <hpc> (strongly normalizing is about as much static safety as you can get)
14:06:56 <monochrom> program correctness
14:07:11 <Sgeo> elliott, what's wrong with doing that, unless we're talking in languages with mutability where something might still see it as a List<Cat>
14:07:14 <ehuber> what's wrong with 'type safe' ?
14:07:21 <Peaker> elliott: which languages permit that?
14:07:37 <elliott> Peaker: Java.
14:07:39 <elliott> I think C# too.
14:07:40 <monochrom> "type-safe" refers to the type system
14:07:45 <elliott> Dart.
14:07:53 <Peaker> elliott: so Java generics don't guarantee anything useful?
14:08:08 <elliott> Java doesn't really guarantee anything.
14:08:20 <hpc> Peaker: they guarantee that you never want to implement a container type ever again ;)
14:08:21 <monochrom> "let [a] = [] in ..." is an error with or without types
14:08:32 <rostayob> elliott: wait. in java you can try to cast anything
14:08:37 <e98> is Crypto actively maintained?
14:08:37 <rostayob> but generics are not covariant
14:08:44 <rostayob> so there is some sanity
14:08:45 <elliott> References and mutability are the thing to blame for that, incidentally.
14:08:55 <rostayob> it's not a generics-specific flaw
14:08:57 <Peaker> elliott: wow that is very very lame
14:09:02 <Axman6> elliott: you can check the release dates for the package on hackage to tell
14:09:04 <elliott> rostayob: Well, I forget how it goes. You can write a "safe" program (no casting warnings or anything) that produces a runtime cast error because of that.
14:09:05 <elliott> IIRC.
14:09:06 <Axman6> uh, e98
14:09:17 <ddarius> Only arrays have the wrong variance in Java and C#.
14:09:21 <rostayob> elliott: not really
14:09:27 <Peaker> so Scala has the same problem with list-adding?
14:09:28 <ddarius> And there is a dynamic check.
14:09:33 <rostayob> List<Dog> is not a subtype of List<Animal>
14:09:49 <elliott> ddarius: OK -- I'm not too familiar with the issue, just know that it sucks :)
14:09:50 * hackagebot lha 0.1.1 - Data structures for the Les Houches Accord  http://hackage.haskell.org/package/lha-0.1.1 (ScottLawrence)
14:09:52 <Peaker> ddarius: List<T> in Java/C# are lists or arrays?
14:09:56 <hpc> ddarius: can you explain that more? ive never been able to understand what makes generic arrays special
14:09:56 <Peaker> ddarius: (Python lists are arrays)
14:09:57 <e98> Axman6: sorry?
14:10:25 <rostayob> hpc: backwards compatibility makes them special iirc. "Effective Java" explains that stuff.
14:10:51 <ddarius> Peaker: Arrays are built-in in Java and C# and use the same syntax as C.
14:10:52 <rostayob> elliott: what I'm trying to say is that generics are safe, at least
14:10:59 <ddarius> List is a normal class.
14:11:12 <elliott> rostayob: well, how come? java is the standard example in discussions of it
14:11:22 <Peaker> ddarius: ah, so what elliott said above about casting List<Sub> to List<Base> and adding the wrong type and getting a runtime error is not correct? Or isn't it an example of wrong variance?
14:11:45 <elliott> @quote gosu
14:11:45 <lambdabot> gosu says: Type parameters are covariant. This is not sound, and that does not matter.
14:11:46 <elliott> and so on
14:11:55 <Axman6> e98: you can check the release dates for the package on hackage to tell
14:12:13 <rostayob> elliott: not in java
14:12:31 <e98> Axman6: was just confused if it's two different persons with the last name Hogg
14:12:40 <rostayob> in java they're *not* covariant. again, List<Dog> can't be treated as a List<Animal>.
14:12:47 <strager> @pl A . map B <$> replicateM d e
14:12:47 <lambdabot> A . map B <$> replicateM d e
14:12:51 <e98> Axman6: or if the maintainer deceased and it's a wife upload
14:13:09 <elliott> rostayob: ok, then
14:13:10 <e98> Axman6: Creighton vs Caylee
14:13:16 <Axman6> e98: i'm pretty sure i've seen quite a lot of update lately
14:13:24 <Axman6> updates*
14:13:25 <elliott> rostayob: I have to wonder why people are complaining that Dart is copying known problems, if Java/C# do not do it that way.
14:13:32 <e98> Axman6: k thanks
14:13:44 <elliott> e98: They could be siblings.
14:13:54 <rostayob> elliott: dart didn't copy that from Java for sure. also, dart is crap.
14:14:02 * elliott will now enumerate all possible ways to share last names.
14:14:04 <rostayob> java is not an insane language, just a boring one.
14:14:32 <elliott> rostayob: It is, but considering Dart's modus operandi is to copy Java wholesale, I'm having trouble believing that it made its generics deliberately less sound.
14:14:48 <cmccann> I have no trouble believing that.
14:14:50 * hackagebot OpenGL 2.2.3.1 - A binding for the OpenGL graphics system  http://hackage.haskell.org/package/OpenGL-2.2.3.1 (JasonDagit)
14:15:05 <e98> elliott: hehe
14:15:16 <ddarius> Peaker: Except for arrays, and "raw types", Java will do something safe, if not the right thing.  Even for arrays, it at least checks at run-time when you do something unsafe.
14:15:19 <rostayob> elliott: no, dart has little to do with Java afaik. Dart doesn't really have a type systems, it's just annotations iirc
14:15:25 <elliott> hackagebot: wat
14:15:31 <rostayob> elliott: I can assure you that Java generics are not covariant :P
14:15:35 <e98> elliott: I may be confused due to something like that happening with some distro packager leaving this world
14:15:37 <elliott> That's several versions behind, wonder why the upload.
14:15:49 <e98> s/happening/having happened/
14:16:07 <e98> anyway, sleep time
14:16:15 <Sgeo> I think I like Haskell's syntax better than ATS's
14:16:18 <Peaker> ddarius: so in Java, List<A> is invariant on A?
14:16:35 <rostayob> Peaker: yes.
14:16:37 <elliott> rostayob: ah, it seems it is a deliberate divergence from java, everything doing this
14:16:40 <elliott> to avoid the wildcard stuff
14:16:45 <elliott> Peaker: apologies for misleading.
14:16:58 <otters> what would you guys recommend for implementing a finite state machine?
14:17:00 <Peaker> ah, ok, that is slightly less lame :)
14:17:00 <elliott> Peaker: also, it looks like scala has proper variance stuff.
14:17:02 * cmccann notes that IEnumerable<A> in C# is covariant in A because the interface is read-only
14:17:37 <elliott> anyway, being able to access a List<Animal> as a List<Dog> by way of sneaking in another reference in before you cast it is the real problem
14:17:43 <elliott> (in a hypothetical broken language)
14:17:55 <ddarius> Peaker: If you want to get upset about a language doing this, there's Eiffel.
14:18:01 <cmccann> I've been consistently impressed by the efforts the C# team has put into not doing things more wrong than they have to given the base they're working from
14:18:03 * elliott can blame any language problem on its insufficient pure functionality.
14:18:17 <cmccann> hahaha, Eiffel bungling variance is hilarious
14:18:25 <Peaker> runtime "safety" checks that convert one kind of crash to another are overrated
14:18:26 <elliott> how did _that_ happen?
14:18:34 <elliott> Eiffel is like a case study in being boring and correct
14:18:36 <rostayob> cmccann: Eiffell!!!
14:18:49 <cmccann> elliott, it actively gets variance backwards in some places if memory serves me
14:19:22 <Peaker> "We've got safe array indexing, instead of crashing with a core dump, we'll crash with an ArrayOutOfBounds exception" (sure, sometimes it will save you from memory overruns, but those are relatively rare compared to crashes, and there is of course the big performance hit for it)
14:19:32 <elliott> we should try and mix up variance more often in haskell. for instance, we should accidentally define a Functor instance for (<-)
14:19:32 <cmccann> ddarius probably remembers the details better than I do though
14:19:34 <otters> or, even better
14:19:39 <otters> an explanation of the State monad
14:19:45 <otters> since the explanation on the wiki is absolutely useless
14:20:01 <elliott> otters: LYAH covers the state monad, I believe.
14:20:10 <hydo> and pretty well, imo
14:20:15 <irene-knapp> Peaker: but the implication is reduced in many cases from "arbitrary code execution" to "denial of service"
14:20:28 <otters> okay I'll give that a shot
14:20:31 <irene-knapp> Peaker: so imo that penalty is actually fine and worth it, although it's even niftier to obtain the benefit through stronger static checking
14:21:07 <Sgeo> Eiffel has no REPL, right?
14:21:29 <elliott> A REPL? That would encourage you to do things before you know they're correct!
14:21:42 <cmccann> elliott, well, there's the contravariant functor transformer "newtype OpT a f b = OpT (b -> f a)"
14:21:49 <otters> ghci is a REPL
14:21:50 <cmccann> elliott, which if you compose it with itself gives you ContT
14:21:50 <ion> (<-), huh?
14:21:53 <Peaker> irene-knapp: if it's merely sold as a security feature, that's fine -- but it's sold as a "safety" thing, and I think that's truly misleading people. I don't think people understand there's a deep difference between static type safety and that kind of "safety"
14:21:57 <otters> but fortunately it's almost impossible to use unless you already know you're right
14:21:58 <elliott> ion: flip (->)
14:22:05 <irene-knapp> Peaker: in that case I agree
14:22:17 <elliott> cmccann: yeah, it's cool
14:22:38 <elliott> cmccann: mostly I like Contravariant because applications of contramap look completely impossible until you make "f" concrete :P
14:22:47 <elliott> "tell me how to get back, and I'll go there"
14:22:52 <cmccann> :D yes
14:22:58 <ddarius> There's a huge difference between lack of type "safety" in that sense and lack of memory safety.
14:23:04 <ion> type (<-) b a = (->) a b?
14:23:06 <Peaker> irene-knapp: Example case: I show someone how cool it is that with Oleg's safe-array-indexing stuff, you can get static type safety on array indexes, and the response is: "But Java gets array indexing safety so much more simply, why not use an 'if' ?"
14:23:10 <elliott> ion: yes! (not valid syntax)
14:23:48 <irene-knapp> Peaker: yeah, that's awful and aggravating.  but you sort of deserve it for starting in the wrong way.  you need to first say "I can detect bugs at compile-time, which means the compiler pinpoints my mistakes for me before my code ever runs"
14:24:21 <Peaker> irene-knapp: that's what the term "type safety" is for, before it was hijacked to mean "the secure kind of runtime crash"
14:24:23 <elliott> irene-knapp: "We have that in Java too, I get type errors all the time! They're so annoying, ugh. I wish I was using Ruby."
14:24:23 <cmccann> Peaker, convincing Java programmers of the benefits of static typing is usually futile, most don't understand it :P
14:24:48 <irene-knapp> Peaker: I frequently do complain in that way at work - where I use PHP, mostly - and I get a fair amount of understanding, because I pitch it as "I'm used to having these things found for me rather than having to bisect my code repeatedly to find them".
14:24:57 <otters> Ruby is actually lovely
14:24:59 <irene-knapp> elliott: yeah, ugh, haha
14:25:04 <otters> dunno what the Haskeller view of it is
14:25:17 <ion> otters: It’s not too bad for a CLispScript.
14:25:19 <irene-knapp> I don't really have an educated take on Ruby
14:25:24 <DanBurton> Ruby has some nice FP-isms built into it
14:25:26 <irene-knapp> I was about to learn it one time and then I realized how slow it is :)
14:25:33 <otters> well hey
14:25:34 <rostayob> cmccann: I technically am a Java programmer and I understand :P
14:25:34 <elliott> otters: The (my) view is that you'll correct your views in time.
14:25:35 <otters> that's what it's for
14:25:36 <Peaker> otters: Unnecessary dynamism, as in Python. Nice use of anonymous code blocks
14:25:42 <otters> is learning
14:25:56 <cmccann> Ruby is a fine language if you're secretly a lisp programmer but want to hide behing perl and smalltalk so nobody catches you
14:26:09 <rostayob> Java gets too much underserved hate anyways. There are other fucked up languages to blame
14:26:18 <irene-knapp> rostayob: oh, I agree
14:26:18 <otters> like Perl
14:26:25 <DanBurton> @remember cmccann Ruby is a fine language if you're secretly a lisp programmer but want to hide behing perl and smalltalk so nobody catches you
14:26:25 <lambdabot> I will remember.
14:26:25 <rostayob> yes. like Perl.
14:26:32 <mauke> no, perl is fine
14:26:33 <mlh> cmccann: nice quote -- quick, someone register it for posterity
14:26:41 <mlh> \o, thanks Dan
14:26:42 <DanBurton> mlh: already done :
14:26:44 <otters> it's better because he misspelled behind
14:26:44 <elliott> @remember mlh nice quote -- quick, someone register it for posterity
14:26:44 <lambdabot> Okay.
14:26:47 <otters> so that will annoy me forever
14:26:52 <rostayob> I would say that Ruby is close to lisp. but ok.
14:26:58 <elliott> cmccann: you should say it without the typo.
14:27:00 * cmccann wishes DanBurton had fixed his type before giving it to lambdabot
14:27:02 <elliott> nobody will ever know
14:27:04 <mauke> @forget mlh nice quote -- quick, someone register it for posterity
14:27:04 <lambdabot> Done.
14:27:09 <elliott> @forget cmccann Ruby is a fine language if you're secretly a lisp programmer but want to hide behing perl and smalltalk so nobody catches you
14:27:09 <lambdabot> Done.
14:27:21 <ion> Typoing the word “typo” is so meta.
14:27:22 <elliott> it's against the rules to @remember something somebody never said, naturally.
14:27:33 <cmccann> ion, dammit
14:27:38 * cmccann can't type properly tonight
14:27:43 <DanBurton> @remember cmccann Ruby is a fine language if you're secretly a lisp programmer but want to hide behind perl and smalltalk so nobody catches you
14:27:43 <lambdabot> Good to know.
14:27:47 <DanBurton> :P
14:27:51 <elliott> ok, now cmccann has to say it
14:27:53 <elliott> to maintain integrity
14:27:56 <cmccann> no, DanBurton said it
14:28:00 <cmccann> and misattributed it to me
14:28:01 <cmccann> that's fine
14:28:08 <elliott>  @remember DanBurton @remember cmccann ...
14:28:11 <mlh> :-)
14:28:12 <DanBurton> memory is foggy
14:28:24 <rostayob> people tend to draw strange parallelism between "dynamic programming language X" and Ruby
14:28:26 <elliott> cmccann: incidentally, that's basically exactly how matz describes the language.
14:28:31 <rostayob> and Lisp, sorry
14:28:41 <cmccann> elliott, yes, it was funny because it's true
14:28:54 <rostayob> the most common being "JS is just Lisp with C syntax", which misses the point of the syntax being the center of Lisp
14:28:57 <elliott> (http://blade.nagaokaut.ac.jp/cgi-bin/scat.rb/ruby/ruby-talk/179642 -- "take lisp, then ruin it")
14:29:06 <mike-burns> I like Ruby. You have to use it carefully, but that's true of every language.
14:29:14 <cmccann> ruby is fine for what it is
14:29:26 <cmccann> I'd rather use scheme but eh
14:29:27 <DanBurton> source for elliott's statement: http://www.ruby-lang.org/en/about/
14:29:33 <rostayob> I don't like ruby that much. I don't like languages without a clear view. Python is better
14:29:41 <otters> python is gross
14:29:56 <cmccann> rostayob, yes, Python isn't afraid to unambiguously commit to doing things the wrong way
14:30:03 <cmccann> rather than leaving it up to the programmer to make their own mistakes
14:30:03 <irene-knapp> bah
14:30:05 <rostayob> cmccann: bah
14:30:09 <companion_cube> ruby is like lisp, except slow
14:30:14 <irene-knapp> I was going to take a famous quote and put it in lambdabot as my own
14:30:17 <irene-knapp> but I couldn't decide on one
14:30:19 <mike-burns> I like Rails. It's poorly designed, but it can do what you need quickly. If Rails were in something else then I'd like that something else.
14:30:20 <rostayob> ruby *is not* like lisp.
14:30:21 <codibblego> I don't use OSX, but some of my colleagues do and I use haskell a lot here at work -- they are complaining about the haskell platform and the difficulty of installing -- so what do OSX guys typically do?
14:30:23 <elliott> DanBurton: my source was http://blade.nagaokaut.ac.jp/cgi-bin/scat.rb/ruby/ruby-talk/179642
14:30:24 <irene-knapp> and now the moment has passed
14:30:24 <cmccann> see  also: almost anything guido says about functional programming
14:30:29 <DanBurton> companion_cube: and fewer parens
14:30:34 <rostayob> cmccann: ah I see, you don't like guido and his FP stance
14:30:36 <ion> @remember irene-knapp I was going to take a famous quote and put it in lambdabot as my own but I couldn't decide on one
14:30:37 <lambdabot> I will never forget.
14:30:37 <DanBurton> elliott: well yes, i meant another source
14:30:42 <irene-knapp> haha
14:30:47 <otters> codibblego: I had no trouble with it
14:30:55 <rostayob> cmccann: what are the bad things about python compared to ruby?
14:31:23 <rostayob> also, what is this "wrong way" python is committed to?
14:31:24 <companion_cube> rostayob: I'd say: anonymous functions suck
14:31:32 <companion_cube> and even closures are werid
14:31:35 <companion_cube> weird
14:31:45 <DanBurton> guido doesn't really like FP is the problem
14:31:46 <MostAwesomeDude> Oh, are we gonna do this again?
14:31:51 <mike-burns> Nah.
14:31:56 <mauke> the closures themselves are fine, scoping is broken
14:31:58 <mike-burns> Let's talk about Haskell.
14:32:03 <DanBurton> MostAwesomeDude: bash every language that isn't Haskell? well, duh.
14:32:07 <rostayob> actually, mike-burns is right
14:32:09 <mauke> and by broken I mean "broken"
14:32:17 <MostAwesomeDude> DanBurton: Python-bashing gets super-tiring.
14:32:23 * rostayob goes to watch a movie
14:32:23 <elliott> let's bash agda instead
14:32:27 <MostAwesomeDude> So! I was thinking of writing a GL stack in Haskell.
14:32:31 <rostayob> let's bash bash!
14:32:31 <mike-burns> Yeah!
14:32:33 <elliott> that would be marginally more interesting
14:32:34 <MostAwesomeDude> Has anybody done this yet?
14:32:34 * rostayob hides
14:32:38 <mauke> python-wrestling, yay
14:32:42 * DanBurton secretly likes Python almost as much as Haskell. It must be the significant whitespace connection.
14:33:17 * cmccann is actually fine with both python and ruby
14:33:38 <DanBurton> MostAwesomeDude: GL as in...OpenGL?
14:33:47 * otters can't understand why he likes whitespace sensitivity in Haskell so much because he hates it in Python
14:34:04 <MostAwesomeDude> DanBurton: Yes, but you can't call it "OpenGL" due to licensing, so we just call it "GL". MesaGL, etc.
14:34:14 <mauke> otters: I'm the same
14:34:22 * companion_cube is fine with C
14:34:24 <DanBurton> @wiki OpenGL
14:34:24 <lambdabot> http://www.haskell.org/haskellwiki/OpenGL
14:34:49 <Peaker> otters: that was one of the reasons I loved Python.  Finally a language that *forced* sensible layout :)
14:35:15 <otters> well I can do sensible layout on my own
14:35:15 <mauke> Peaker: to bad it doesn't force *sensible* layout
14:35:23 <mauke> argh, can't spell
14:35:24 <otters> I think the problem is all those underscores
14:35:26 <Peaker> mauke: why isn't it sensible?
14:35:32 * mauke walks off to #haskell-blah
14:35:59 <MostAwesomeDude> Hm. Okay, so according to the wiki, nobody's done this. Awesome. Maybe this'll be my new hotel-room project. :3
14:36:32 <Peaker> MostAwesomeDude: what's a GL stack?
14:36:59 <MostAwesomeDude> Peaker: libGL.so and everything around it.
14:37:11 <Peaker> MostAwesomeDude: hackage has a bunch of OpenGL wrappers?
14:37:21 <elliott> GL implementation
14:37:23 <elliott> I think MostAwesomeDude means
14:37:37 <Peaker> with software rendering?
14:37:38 <MostAwesomeDude> Peaker: Yes, but I'm curious as to whether a super-terse language like Haskell would yield a more readable or speedier stack than Mesa.
14:37:47 <MostAwesomeDude> 'Cause Mesa is getting super-unfun to hack on.
14:37:58 <ion> mostawesomedude: Also see: Gallium3D.
14:38:02 <Peaker> MostAwesomeDude: aren't the internals of the existing implementation mostly drivers?
14:38:17 <codibblego> otters: did you install THP? and on 64-bit?
14:38:25 <otters> yeah
14:38:38 <MostAwesomeDude> Peaker: There are two software renderers, one using LLVM and one totally-interpreted.
14:38:50 <MostAwesomeDude> There's a couple backends to other windowing systems, and then there's the hardware drivers.
14:39:00 <MostAwesomeDude> In the middle, there's a big GL state machine that handles common logic.
14:39:01 <codibblego> otters: a colleague claims it ships with incorrect architecture binaries
14:39:06 <otters> nonsense!
14:39:17 <MostAwesomeDude> ion: I wrote the first practical open-source Gallium driver, back when I didn't suck. :3
14:39:29 <ion> Cool
14:40:09 <MostAwesomeDude> But I suck pretty hard these days. Anyway, just a thought. I guess that nobody's done this yet, so it'd be a fun experiment.
14:40:21 <lispy> MostAwesomeDude: I still don't understand what you mean by GL stack.  You want to replace Mesa but write in Haskell?
14:40:32 <Peaker> MostAwesomeDude: but isn't everyone using just hardware-assisted opengl? software rendering is still in use?
14:40:32 <MostAwesomeDude> lispy: Pretty much.
14:40:49 <MostAwesomeDude> Peaker: Well, yes, some groups like VTK use it.
14:41:09 <elliott> MostAwesomeDude: You probably aren't going to end up with a speedier stack :P
14:41:30 <MostAwesomeDude> Also, even if you're hardware-accelerated, there's a *lot* of C code standing between your app and your video card. Things like the GL state machine, texture handlers, formatters, hardware state management, etc.
14:42:04 <cmccann> MostAwesomeDude, you could use a package to offload computation to the GPU, I bet a software rendering system would run pretty well there
14:42:08 <cmccann> :D
14:42:19 <MostAwesomeDude> cmccann: I see what you did there.
14:42:37 <otters> oh snap
14:43:10 <ion> hah
14:45:25 <lispy> otters: you mean, oh yesod
14:45:51 <Peaker> MostAwesomeDude: VTK?
14:46:30 <mike-burns> Hah.
14:49:04 <DanBurton> oh happstack
14:49:58 <mike-burns> Oh WASH.
14:50:05 <Axman6> Oh Warp!
14:59:22 <byorgey> kallisti: http://www.cis.upenn.edu/~byorgey/pub/promotion.pdf
14:59:47 <byorgey> elliott was right, I am just slow
15:00:02 <elliott> I knew it!
15:04:52 * hackagebot hepevt 0.4 - HEPEVT parser  http://hackage.haskell.org/package/hepevt-0.4 (ScottLawrence)
15:05:22 <MostAwesomeDude> Peaker: Dunno what it is, but some people use it.
15:10:42 <int80_h> I am making a cabal package, where two dependencies require different versions of the same package. What are my options?
15:10:50 <elliott> Depend on different packages.
15:12:17 <elliott> Though I think cabal can actually handle that.
15:12:47 <mike-burns> I assume he's asking because cabal can't.
15:12:58 <int80_h> it fails to build with the complaint "dependcy foo requires bar version x, dependency baz requires bar version y)
15:13:26 <int80_h> well I can be more specific, hold on
15:13:38 <mike-burns> Worst case: fork one of the packages and bump its dependency, submit that as a patch upstream.
15:13:58 <hpaste> int80_h pasted “what are my options?” at http://hpaste.org/57500
15:15:16 <mike-burns> I don't know.
15:18:15 <jetru_> I've made some data definitions in Haskell like this: http://pastebin.com/nCtUkP0t
15:18:17 <mauke> The paste nCtUkP0t has been copied to http://hpaste.org/57501
15:19:27 <jetru_> Why doesn't a list of the "inherited" datas form a [Card]?
15:19:52 * hackagebot bindings-gpgme 0.1.3 - Low level bindings to gpgme.  http://hackage.haskell.org/package/bindings-gpgme-0.1.3 (MauricioAntunes)
15:20:29 <Eduard_Munteanu> jetru_: because Haskell's data can only make *tagged* unions
15:20:46 <otters> "datas"
15:20:50 <otters> it's a multiplural!
15:21:28 <Eduard_Munteanu> jetru_: you need to provide constructors for each case
15:22:43 <elliott> jetru_: Be careful with words like "inherited".
15:22:43 <jetru_> Hmm, so basically, haskell needs to know the type beforehand?
15:23:01 <elliott> Reasoning about Haskell with OOP principles leads to much pain, as you're discovering.
15:23:16 <elliott> jetru_: What's happening there, is that "Treasure" is the name of one of Card's /constructors/.
15:23:19 <elliott> With no arguments.
15:23:29 <elliott> Try: data Card = Treature Treasure | Victory Victory | Action Action deriving (Eq, Show, Read, Enum)
15:23:37 <elliott> Then [Treasure Copper, Victory Estate] :: [Card].
15:23:53 <elliott> (Of course, Treaoijfiosfjsdfklsdjfklsdf Treasure would work just as well; constructor names are arbitrary.)
15:24:52 <companion_cube> @type flip id
15:24:53 <lambdabot> forall a b. a -> (a -> b) -> b
15:25:03 <companion_cube> can anyone explain me this thing?
15:25:22 <companion_cube> I can't see how the (a -> b -> c) of flip unifies with id
15:25:31 <ben_> @type flip
15:25:32 <lambdabot> forall (f :: * -> *) a b. (Functor f) => f (a -> b) -> a -> f b
15:25:35 <Peaker> companion_cube: a -> b -> c  ==  a -> (b -> c)
15:25:38 <ben_> christ
15:25:51 <Peaker> companion_cube: and (b -> c)    can be given to a type-variable
15:26:01 <companion_cube> Peaker: yes, but  a and b -> c are not eh same thing?
15:26:28 <rwbarton> so?
15:26:32 <companion_cube> wait, my flip has type flip :: (a -> b -> c) -> b -> a -> c
15:26:49 <elliott> companion_cube: Does id have the type (a -> b -> c)?
15:26:53 <companion_cube> so how can   a -> a  unify with a -> (b -> c) ?
15:26:54 <elliott> That is, can you unify (a -> b) with (c -> d -> e)?
15:27:03 <rwbarton> er
15:27:04 <mzero> yeah, lambdabot has some "special" versions of the standard functions
15:27:06 <elliott> That is, can you unify (a -> b) with (c -> (d -> e))? What would you set c to?
15:27:08 <elliott> mzero: No.
15:27:09 <rwbarton> how about (a -> (b -> c)) with (x -> x)
15:27:12 <elliott> This is perfectly standard.
15:27:14 <rwbarton> id :: x -> x
15:27:22 <companion_cube> rwbarton: for me this unification does not work
15:27:25 <rwbarton> okay
15:27:25 <elliott> companion_cube: Try and unify (a -> b) with (c -> (d -> e)).
15:27:26 <mzero> no? I don't think flip is defined in terms of Functor in the Prelude
15:27:30 <rwbarton> think about id "hello"
15:27:33 <elliott> mzero: Yes, but the question is (flip id).
15:27:37 <elliott> erm
15:27:38 <elliott> gah
15:27:41 <elliott> companion_cube: Try and unify (a -> a) with (c -> (d -> e)).
15:27:43 <mzero> right - that works with the prelude's version
15:27:45 <elliott> my apologies for being confusing :P
15:27:52 <Peaker> companion_cube: they can be unified to be the same thing
15:28:02 <Peaker> companion_cube: why can't a = (b -> c) ?
15:28:15 <elliott> (Do any of the popular Haskell tutorials teach unification?)
15:28:15 <companion_cube> oh, c is also a variable
15:28:18 <mzero> I remember working through flip id -- worth doing
15:28:19 <companion_cube> that's right
15:28:20 <elliott> (If not, why not?)
15:28:29 <rwbarton> it's not like you can't apply id to "hello" just because id :: a -> a and "hello" :: String, right
15:28:37 <rwbarton> same thing here
15:28:45 <otters> > id 1
15:28:46 <lambdabot>   1
15:28:48 <otters> handy
15:28:55 <companion_cube> so a=c=(d -> e)...
15:29:18 <ion> Let’s write a Haskell unification tutorial based on a great food-related analogy.
15:29:34 <companion_cube> the worst is that i know pretty well unification
15:29:42 <otters> The problem with all the programming tutorials is that nobody actually makes classes in the real world that represent dogs and poodles and cats and giraffes and shit
15:29:55 <elliott> unification is like unitarian universalism
15:30:03 <elliott> I don't know how, but they both have "uni" in, so they must be the same thing
15:30:10 <elliott> like monoids and monads
15:30:20 <ion> generate :: Animal a => a -> Shit
15:30:34 <jetru_> elliott: Eduard_Munteanu: It worked. But i don't get why!! Is it because when I use 'data' I'm defining the constructors on the right, and since the first word is the constructor, it gives me a NULL type?
15:30:44 <elliott> jetru_: Err...
15:30:52 <elliott> I don't know what a NULL type is. But let me try and explain.
15:31:07 <elliott> jetru_: In "data Card = Treasure | Victory | Action deriving (Eq, Show, Read, Enum)", "Treasure", "Victory" and "Action" are not referring to the types.
15:31:15 <elliott> jetru_: The syntax is: ConstructorName FieldType FieldType ...
15:31:23 <elliott> So, you have constructors Treature, Victory, and Action, all with 0 fields.
15:31:27 <elliott> They all have type Card.
15:31:33 <ion> “Card” is in a completely different namespace as “Treasure”, “Victory” and “Action” in that example.
15:31:36 <elliott> It's just that constructors can have the same name as a type.
15:31:41 <elliott> So, you've basically just said
15:31:46 <elliott> data Card = Flub | Buh | Glob
15:31:49 <elliott> but with confusing names.
15:31:55 <rwbarton> in other words, Card has (in that case) just three values, which happen to be named Treasure, Victory and Action
15:31:59 <elliott> When you say: data Card = Flub Teasure | Buh Victory | Glob Action
15:32:04 <elliott> you define constructor Flub, with one field, a Treasure
15:32:12 <elliott> constructor Buh, with one field, a Victory; and constructor Glob, with one field, an Action
15:32:24 <elliott> then we rename Flub to Treasure, Buh to Victory, and Glob to Action, because they're reasonable names in this case :)
15:32:28 <elliott> does that help?
15:32:38 <elliott> i.e., the first word in any constructor declaration is "special"
15:32:47 <elliott> because it's the constructor name... the rest of the "words" are the types of the fields
15:33:49 <Otaku_Wizard> Hello
15:34:01 <Otaku_Wizard> Is there anyone online in this room?
15:34:31 <Otaku_Wizard> Goodbye, then...
15:34:52 * hackagebot checkers 0.2.9 - Check properties on standard classes and data structures.  http://hackage.haskell.org/package/checkers-0.2.9 (ConalElliott)
15:34:59 <jetru> elliott: rwbarton: ion: Got it. I think...Thanks!
15:35:39 <elliott> Otaku_Wizard: nobody at all
15:38:17 <Eduard_Munteanu> Otaku_Wizard: please hold... *music*
15:38:40 <Eduard_Munteanu> Otaku_Wizard: no, really, don't ask to ask, just ask away if you have a question. Anybody can reply.
15:38:48 <elliott> the otaku wizard waits for no music!
15:38:58 <mrocklin> Hi, beginners question: I've made my own data type and I want to use the + operator with it. If I define (+) then I collide with Prelude.+ . What is the standard solution to this?
15:39:10 <strager> @pl \x -> map fst (zip [0..] x)
15:39:10 <lambdabot> zipWith const [0..]
15:39:26 <Jafet> Welcome to #haskell, premier call centre
15:39:43 <strager> Hmm is it me or is lambdabot pulling my leg?
15:39:45 <Jafet> mrocklin: define Prelude.+ instead
15:39:47 <elliott> strager: map f (zip xs ys) === zipWith (curry f) xs ys
15:39:52 <elliott> strager: curry fst === const
15:40:01 <elliott> thus map fst (zip [0...] xs) === zipWith const [0..] xs
15:40:11 <strager> oh I missed that \x -> is no longer there.
15:40:17 <Jafet> mrocklin: Prelude.+ is part of the class Num.
15:40:24 <strager> elliott: Yeah; thanks.
15:40:34 <elliott> strager: well, @pl removes points... that's kinda the point :P
15:40:42 <strager> Yeah, but I didn't notice ;P
15:40:50 <strager> which made me confused.
15:41:01 <johnsingleton> does exporting a type class export all of its instances as well?
15:41:34 <elliott> johnsingleton: all instances always get "re-exported", there's no control at all
15:41:35 <strager> johnsingleton: No, because all of its instances are not necessarily in the same place as the type class.
15:41:39 <elliott> well, yes
15:41:50 <elliott> but all the instances you have in scope of any module are re-exported -- even if you export nothing at all from the module
15:41:55 <elliott> thanks to the open world assumption, etc.
15:42:11 <johnsingleton> ohhhhhhh I see
15:42:24 <elliott> instances don't really get exported... they just sort of propagate through the background as a fundamental force of nature :P
15:42:35 <johnsingleton> but obviously, if you don't export the type itself, the instances are't useful
15:42:37 <johnsingleton> yes?
15:42:42 <johnsingleton> hehe
15:42:43 <Jafet> Haskell, reality warper.
15:42:43 <elliott> indeed :)
15:43:17 <johnsingleton> ok coolness
15:43:18 <strager> johnsingleton: They're useful; they're just passed around though and not really touched or "created".
15:43:19 <johnsingleton> thanks!
15:43:28 <johnsingleton> right
15:43:51 <strager> E.g. a private instance of Num still can have its defined functions called by Prelude.+.
15:44:09 <strager> Otherwise type classes would lose much of their usefulness =]
15:44:52 <ion> cmccann: I wonder if it would make sense to add asTypeIn and asAppliedTo to Overture? They’re very useful in GHCi.
15:44:55 <elliott> strager: huh?
15:45:04 <elliott> if you don't export the type, there's no way to use any instances
15:45:16 <cmccann> ion, I was already thinking about that actually
15:45:18 <elliott> because there's no way to get that particular overloading
15:45:22 <elliott> you can't reference the type in the RHS of ::
15:45:23 <cmccann> they're a nice addition to asTypeOf
15:45:29 <elliott> you can't force things with a value of the type
15:45:39 * elliott wonders what this Overture is.
15:45:50 <cmccann> elliott, my alternate Prelude :P
15:46:02 <cmccann> https://github.com/isomorphism/Overture
15:46:07 <mreh> why is this person using ~(a,b) if they don't want a and b to be evaluated?
15:46:09 <Jafet> A polyphonic Prelude
15:46:15 <mreh> shouldn't (a,b) suffice?
15:46:29 <Jafet> mreh: (a,b) causes (,) to be evaluated
15:46:31 <ion> cmccann: Btw, bool isn’t exported. :-)
15:46:39 <cmccann> ion, argh!
15:46:42 <cmccann> sorry
15:46:42 <strager> elliott: Prelude.+ can use your instance (even if it's not visible to anyone outside the module) because it operates on type classes.
15:46:44 <elliott> cmccann: ooh, that's new!
15:46:49 <elliott> :P
15:47:07 <strager> elliott: If that makes sense.  At least that's how I perceive things.
15:47:09 <elliott> mreh: (\ ~(a,b) -> c) _|_ === c (where a and b are both _|_)
15:47:14 <cmccann> elliott, it saves me the trouble of importing stuff I use a lot and defining my favorite utility functions everywhere :P
15:47:15 <elliott> mreh: i.e. it's a lazy binding
15:47:26 <elliott> it "moves" the destruction of the tuple into a and b
15:47:28 <ddarius> elliott: It doesn't matter what a or b are in that case.
15:47:40 <elliott> that is, (let ~(a,b) = c in d) === (let a = fst c; b = snd c in d)
15:47:50 <elliott> ddarius: It does if c references them.
15:47:51 <ddarius> let is already lazy.
15:48:01 <elliott> er, darn, shouldn't have used let for my example :)
15:48:31 <ddarius> elliott: It doesn't matter if c references them or not.
15:48:51 <elliott> Well, it does, because otherwise a and b would be unbound.
15:49:01 <ddarius> What?  They are bound right there.
15:49:06 <elliott> Would you be happier if I used the substitution notation?
15:49:25 <elliott> No they're not. If (\ ~(a,b) -> c) _|_ === c, then (\ ~(a,b) -> a) _|_ === a.
15:49:31 <ddarius> All I'm said was that "where a and b are both _|_" is completely unnecessary.
15:49:41 <elliott> Oh, I think you are grouping my statement wrong.
15:49:47 <elliott> (\ ~(a,b) -> c) _|_ === (c (where a and b are both _|_))
15:49:50 <elliott> was my intention.
15:49:52 * hackagebot unamb 0.2.5 - Unambiguous choice  http://hackage.haskell.org/package/unamb-0.2.5 (ConalElliott)
15:49:54 * hackagebot lub 0.1.7 - information operators: least upper bound (lub) and greatest lower bound (glb)  http://hackage.haskell.org/package/lub-0.1.7 (ConalElliott)
15:50:40 <ddarius> elliott: I guess that is clearer.
15:52:13 <mreh> oh, conal fixed unamb!
15:52:23 <ion> How was it broken?
15:52:29 <mreh> i dont know
15:52:46 <mreh> maybe it was reactive that was broken
15:52:49 <conal> i'm updating some packages for compatibility with ghc 7.4.1
15:53:00 <mreh> ok
15:54:37 <ion> I really dislike how Hackage doesn’t display a changelog for every package.
15:55:04 <ion> Adding a changelog to cabal files should be specced and encouraged.
15:55:21 <elliott> I bet Hackage 2 does that.
15:56:35 <rostayob> hackage 2: better than hackage 1.
15:56:46 <ion> Hackage 2: Almost as good as Hackage 3.
15:57:44 <kallisti> withMVar is an exception-safe wrapper for operating on the contents of an MVar. This operation is exception-safe: it will replace the original contents of the MVar if an exception is raised (see Control.Exception). However, it is only atomic if there are no other producers for this MVar.
15:57:59 <kallisti> does this mean no other producers /within/ the function argument?
15:58:05 <kallisti> or no other producers anywhere else ever? that doesn't sound very atomic.
15:58:09 <ion> “hackage 2” http://youtu.be/e4Dfo_Az6U8
15:58:42 <rostayob> hackage 2: a new vision.
15:58:49 <elliott> ion: :D
15:58:57 <Jafet> withMVar is an exception-safe wrapper that wraps takeMVar and putMVar purely to provide exception safety
15:59:01 <elliott> yes, this is exactly what i want in haskell package distribution
15:59:12 <Jafet> I suppose you could do atomically (withMVar
15:59:52 <elliott> Jafet: ?
15:59:56 <elliott> atomically is STM
16:00:34 <Eduard_Munteanu> Is that like Web 2.0? :P
16:01:05 <ddarius> kallisti: No other producers at that moment anywhere.  It is not saying it is atomic.  It is saying it is not atomic.
16:02:39 <ion> kallisti: Use STM for atomicity.
16:03:14 <kallisti> ddarius: hmmm, I don't understand what it means by atomic then. wouldn't it block other threads if the MVar were being accesssed by withMVar?
16:03:46 <kallisti> is it referring to the fact that it can create side-effects despite blocking?
16:03:57 <Jafet> The implementation of withMVar is very simple
16:04:10 <Jafet> It is pretty much defined as a non-atomic wrapper around takeMVar and putMVar
16:04:25 <Peaker> kallisti: it means that after the takeMVar, someone else may get to putMVar before you do
16:05:11 <kallisti> er, what?
16:06:11 <kallisti> I think I'm missing something here....
16:07:17 <kallisti> ah, nevermind.
16:07:49 <elliott> Thus causing the putMVar to block.
16:08:31 * kallisti is trying to think of a situation where that can occur.
16:08:41 <ddarius> kallisti: If all the other threads that hold the MVar only use readMVar or takeMVar (or even writeMVar) but never putMVar not preceded by takeMVar, then withMVar (and all those other calls) will behave atomically.
16:08:46 <kallisti> perhaps if you used readMVar, stored a value, and then later used putMVar?
16:08:54 <ddarius> This is a fairly common situation when one MVar is being used to broadcast to other threads.
16:09:15 <kallisti> okay, right.
16:09:52 * hackagebot parsimony 1.3 - Monadic parser combinators derived from Parsec  http://hackage.haskell.org/package/parsimony-1.3 (IavorDiatchki)
16:10:44 * kallisti isn't really sure why it would be useful to attempt to use MVar a different way.
16:11:18 <ddarius> kallisti: You may have an MVar that stores the results of several threads.  This is a perfectly legitimate use-case.
16:12:12 <ddarius> E.g. firstResult workers = do mvar <- newEmptyMVar; mapM_ (forkIO . ($ mvar)) workers; takeMVar mvar
16:12:22 <ddarius> Where the workers do putMVar (or tryPutMVar)
16:13:07 <kallisti> @hoogle writeMVar
16:13:08 <lambdabot> No results found
16:13:39 <kallisti> I'm guessing writeMVar would be something like withMVar var (const foo)
16:14:36 <ddarius> It's takeMVar mvar; putMVar mvar x
16:14:48 <ddarius> But yes.
16:44:53 * hackagebot wai-app-file-cgi 0.5.1 - File/CGI/Rev Proxy App of WAI  http://hackage.haskell.org/package/wai-app-file-cgi-0.5.1 (KazuYamamoto)
16:44:55 * hackagebot mighttpd2 2.5.1 - A classical web server on WAI/warp  http://hackage.haskell.org/package/mighttpd2-2.5.1 (KazuYamamoto)
16:46:58 <nyingen> @quote
16:46:58 <lambdabot> Brend says: Whoever chose the title "A Gentle Introduction to Haskell" is obviously accustomed to wrestling bears in piranha pits or something.
16:47:02 <nyingen> @quote
16:47:02 <lambdabot> cjeris says: instance (TicTacToe a) => (GlobalThermonuclearWar a) where ...
16:47:43 <companion_cube> :)
16:48:50 <CodeWeaverX> Now why didn't I think to take the handle companion_cube.  That's brilliant.
16:50:52 <Jafet>   play _ = don'tLaunchMissiles
16:51:25 <Cain_> j ##c++
16:52:33 <otters> hardly accidental
16:59:13 <nyingen> @quote C++
16:59:13 <lambdabot> medfly says: Haskell is zero maintenance because you can't get anyone to maintain it. (:
16:59:34 <otters> @quote PHP
16:59:34 <lambdabot> qwe1234 says: i'm still waiting for the list of differences between lisp and php that matter.
16:59:47 <companion_cube> CodeWeaverX: there can be only one ;)
17:00:27 <CodeWeaverX> hahahah :D
17:00:37 <CodeWeaverX> *picks up the cube and walks to the incinerator*
17:00:45 <CodeWeaverX> No, no, I just can't.
17:00:51 <CodeWeaverX> *stacks the cube next to the others*
17:00:55 <companion_cube> \o/
17:05:03 <nyingen> @quote C++
17:05:03 <lambdabot> quicksilver says: <cads> three new mersenne primes in the past couple of months <quicksilver> I blame the financial crisis [...] out of work bankers have nothing better to do that calculate primes.
17:05:32 <Jafet> @quote C\+\+
17:05:33 <lambdabot> kyevan says: I haven't tried learning C++, from what I've seen, simple c++ is readable pretty easily, complex C++ makes me want to hide in the closet.  (I'm not referring to my sexuality, either)
17:07:08 <hpaste> jmcarthur pasted “PolyKinds trouble” at http://hpaste.org/57502
17:07:10 <nyingen> @quote C\+\+
17:07:11 <lambdabot> kmc_ says: you should take a look at Boost, they implement things like Maybe and tuples in only a few thousand lines of C++
17:07:16 <otters> @quote c\+\+
17:07:17 <lambdabot> <vic_> says: everytime you unsafePerformIO, a C++ programmer spawns
17:07:21 <otters> heh
17:07:35 <jmcarthur> anybody familiar with some of the limitations of PolyKinds that can explain that error to me? ^^
17:07:41 <otters> @quote java
17:07:41 <lambdabot> medfly says: I wanted to use xmonad and yi, just to be cool like that, but to write javascript.
17:08:24 <Saizan> you can also query lambdabot
17:08:26 <jmcarthur> i note that ghci tells me that   instance Category (AnyK -> *) (NT AnyK)
17:08:49 <tromp__> it seems no new mersenne prime has been found in 3.3 years
17:10:44 <tromp__> maybe we found all f them:)
17:13:40 <Andrew___C> hi all
17:13:45 <otters> yo
17:15:49 <Andrew___C> I'm learning to use wxHaskell, and I'm trying to fire an event _after_ a user types a character in a textEntry, but the event handler runs before the text is updated, even if I propogateEvent first. Is there a way of getting around this?
17:16:18 <Saizan> jmcarthur: maybe add kind annotations to the arguments of NT?
17:16:26 <aib> tromp__: problem is, you have to disturb Mr. Norris to be sure.
17:18:16 <jmcarthur> Saizan: to make it only work on (* -> *)?
17:18:53 <Saizan> jmcarthur: yes
17:18:57 <jmcarthur> Saizan: that seems to have worked, although it's disappointing
17:20:58 <Saizan> jmcarthur: yeah
17:22:15 <Saizan> are kind-polymorphic instances allowed at all?
17:23:19 <jmcarthur> hmm... maybe not
17:23:43 <jmcarthur> i think they are
17:23:49 <jmcarthur> the docs has an example
17:24:02 <jmcarthur> Note that the datatype Proxy has kind forall k. k -> * (inferred by GHC), and the new Typeable class has kind forall k. k -> Constraint.
17:24:11 <jmcarthur> oh, that's a class
17:24:18 <jmcarthur> ignore me
17:27:10 <ben_> I'm trying to use cabal-dev to install the gtk package from their repository as a dependency to a tiny program of mine. I hoped that cabal-dev add-source would be the right approach to that, however when I try to say cabal-dev add-source path/to/gtk2hs/gio, it complains about depending on glib >=0.12.0 && <0.13, running 'configure' first, and not finding module system.GIO.Types
17:27:16 <ben_> what's the deal here
17:29:37 <lispy> ben_: can you build it with cabal-dev when you're in the path/to/gtk2hs/gio directory?
17:30:19 <lispy> ben_: if no, then does 'cabal configure && cabal build' work in that directory?
17:30:36 <ben_> well, no, because the dependency glib is installed in the cabal-dev directory over in my project directory D:
17:31:12 <ben_> I think I shoulduse cabal-dev install instead of cabal-dev add-source? welp
17:31:37 <lispy> ben_: they're very different commands
17:32:07 <lispy> ben_: add-source makes it so that your sandbox has the source for one of its dependencies
17:32:21 <lispy> ben_: install is a combination of configure/build.  It just invokes cabal-install.
17:32:49 <lispy> ben_: I have virtually no experience with successfully building gtkhs
17:32:58 <lispy> So I may not be very helpful :(
17:33:01 <ben_> It sounded like add-source would tell cabal-dev that I'd like to take my dependencies from over there
17:33:10 <lispy> yes, that's right
17:33:13 <ben_> instead of from hackage, which apparently lacks a patch or other
17:33:35 <lispy> It copies the source into your sandbox so you can build it
17:33:41 <ben_> but now it looks like it's trying to actually build the packages
17:33:57 <ben_> I'm guessing that this sdist thing isn't set up properly for cabal-dev
17:34:34 <lispy> Hmm..that could be.  cabal-dev probably assumes that sdist just makes a tarball.
17:34:51 <lispy> But this package might do something fancy in Setup.hs
17:35:19 <ben_> I suppose it's mechanically generating the bindings
17:35:36 <ben_> expecting its dependencies to be actually installed and not just known to cabal-dev
17:36:06 <lispy> Yeah, time to submit a bug report?
17:36:21 <ben_> I'm not entirely sure how it's supposed to work and whose fault it is that it doesn't :(
17:36:50 <ben_> It's about my first time using cabal-dev and I'm not that familiar with cabal either
17:49:49 * edwardk waves hello.
17:50:03 <CodeWeaverX> Greetings.
17:50:15 * ivanm waves at edwardk and CodeWeaverX 
17:50:30 <edwardk> back to armwrestling with constraints
17:51:51 <lispy> ben_: what you're doing normally works.  the gtk bindings are notorously hard to build.
17:51:52 <ivanm> edwardk: what kind of crazy stuff are you doing *now*? :o
17:52:12 <edwardk> product and sum categories using polykinds
17:52:12 <lispy> ivanm: http://blog.codersbase.com/2012/02/proposal-community-wide-build.html
17:52:28 <ivanm> lispy: yeah, I just read that
17:52:28 <edwardk> with the addition of an indexed constraint on the category
17:52:45 <lispy> ivanm: cool, we were talking about it recently, right?
17:52:46 <ivanm> I'm doing enough procrastination with enough other projects I should be hacking on though... :s
17:52:48 <ivanm> yup
17:53:41 <edwardk> @hpaste
17:53:41 <lambdabot> Haskell pastebin: http://hpaste.org/
17:54:01 <hpaste> edwardk pasted “polykinded sum categories” at http://hpaste.org/57503
17:54:30 <edwardk> i've got id to finally work, which took some doing because i had to rather obliquely approach the notion of products of two constraints
17:54:36 <lispy> them sum categories alright
17:54:38 <edwardk> I can compose constraints easily
17:54:55 <ivanm> edwardk: what does "(b => r)" mean? any constraint b allowing something of type r ?
17:55:28 <ivanm> does this relate to heffalump's suitable stuff?
17:55:55 <edwardk> but given type Foo :: x -> Constraint, and type Bar :: y -> Constraint deriving baz :: (x, y) -> Constraint is hard
17:56:02 <edwardk> yes
17:56:12 <edwardk> basically this is 'Suitable' on steroids
17:56:20 <ivanm> which question was that "yes" to? :p
17:56:32 <edwardk> yes its related to his suitable stuff
17:56:42 * ivanm was about to point out to edwardk that he should learn how to use comments, then realised he had one on line 5... :p
17:56:49 <ivanm> edwardk: what does "(b => r)" mean? any constraint b allowing something of type r ?
17:56:53 <ivanm> ^^ my other question :p
17:57:13 <edwardk> (b => r) says that given a dictionary for b, you can get an r.
17:57:33 <edwardk> Ord a => a  -- says that if you can show Ord a, I'll give you an a.
17:57:46 <ivanm> OK, don't think I've ever seen one inside a type sig like that before
17:57:47 <edwardk> maxBound :: Bounded a => a -- is probably more realistic though ;)
17:57:50 <edwardk> yeah
17:57:52 <ivanm> and with just some arbitrary constraints
17:58:00 <edwardk> i was impressed when it worked in my constraints package
17:58:06 <Saizan> ivanm: new ConstraintKinds stuff
17:58:24 <edwardk> ivanm: the use of a variable for it is allowed by constraint kinds
17:58:28 <ivanm> ahhhh
17:58:33 <edwardk> the result of that stuff comes from polymorphic kinds and data kinds
17:58:51 <ivanm> edwardk: so, how does one use all this stuff?
17:58:53 <edwardk> trying to work out the sum category composition
17:58:55 <lispy> edwardk: making sure the new code is bug free? :)
17:59:07 <edwardk> ivanm: ask me when its written ;)
17:59:11 <ivanm> heh
17:59:17 <lispy> eg., you're stress testing it
17:59:18 <edwardk> but in particular what i want it for is that constraints themselves form a category
17:59:25 <edwardk> notice the category instance for :-
17:59:34 <edwardk> so you can compose subtyping relationships
17:59:56 <edwardk> i use this to provide things using the constraints package you normally can't even say
18:00:09 <edwardk> like foo :: (forall a. Monoid (m a)) => ...
18:00:14 <edwardk> which you can't state directly
18:00:20 <edwardk> but the constraints package lets you build
18:00:54 <edwardk> lispy: hah =)
18:01:00 <edwardk> lispy: this is definitely a stress test
18:01:09 <edwardk> you can't even write this code using type families, it HAS to use MPTCs ;)
18:01:17 <cmccann> there was a discussion the other day where it was pointed out to me that having a constraint inside parentheses like that is actually meaningful even without constraint kinds being involved
18:01:28 <edwardk> because the defaulting they use for type families keeps it from working
18:01:39 <ivanm> I'm just looking at all that and have nfi what most of it even *means* let alone how (or even why :p) you'd use it...
18:01:51 <edwardk> ivanm: did you see my post on constraints?
18:02:00 <ivanm> edwardk: don't think so, where was it?
18:02:15 <edwardk> http://comonad.com/reader/2011/what-constraints-entail-part-1/
18:02:18 <edwardk> and there is a part 2
18:02:28 <edwardk> part 2 ends with a good (ab)usecase
18:02:38 <ivanm> oh, possibly
18:02:48 <ivanm> _understand_ it, however... :p
18:03:07 * cmccann thinks "we do what we must, because we can" is a sufficient use case for this stuff anyway
18:03:07 <edwardk> basically (:-) :: Constraint -> Constraint -> *
18:03:16 <edwardk> and i can compose them like a category
18:03:23 <edwardk> so i want to be able to make an instance for it
18:03:31 <edwardk> rather than reinvent all my category stuff all over again
18:03:34 <edwardk> just for a different kind
18:03:37 <edwardk> which is fine
18:03:41 <edwardk> i can do that version
18:03:49 <edwardk> but then i want category products and category coproducts
18:03:51 <ivanm> cmccann: oh, right, forgot about that rationale :p
18:04:03 <cmccann> ivanm, it is the best rationale.
18:04:33 <edwardk> right now in haskell i had to give up on categories and use semigroupoids for everything because id was unimplementable for many interesting categories
18:04:36 <edwardk> like product and sum
18:04:45 <ivanm> edwardk: so the ability to have "a => ..." requires constraint kinds?
18:04:58 <edwardk> yeah
18:05:06 <edwardk> because a :: Constraint
18:05:14 <cmccann> edwardk, think you might have time in a week or so to look at some code I'm working on when it's done-ish? I am pretty convinced at this point that some of your abstract nonsense would solve a lot of my problems but I'm still struggling to even nail the problem down well enough to begin searching
18:05:24 <edwardk> without that you have no kind to assign the variable to even have a discussion about that type ;)
18:05:34 <edwardk> cmccann: sure
18:05:59 <ivanm> looking through your blog post; why is the first UNDECIDABLE block there (for the Read and Monoid instances)? are they automagically derivable with 7.4?
18:06:51 <edwardk> because ghc isn't smart enough to see that 'a' couldn't be Monoid (Dict a)
18:07:04 <edwardk> and nah they aren't magically derivable
18:07:27 <cmccann> edwardk, basically I have some monoid operations on functors and then take the fixed point of the result and want to express some tricky constraints on the semantics of what can be done with the component functors
18:07:29 <ivanm> oh, I thought you said it was fixed in HEAD
18:07:47 <edwardk> oh perhaps that one was
18:07:55 <edwardk> there was a fix that max put in for something around that time
18:08:00 <ivanm> *nod*
18:08:01 <edwardk> but i've blotted out the issue
18:08:34 <ivanm> so can you just have "deriving instance Read (Dict a)" now? or is the "a =>" bit still needed?
18:08:42 <edwardk> haven't tried
18:08:53 <edwardk> someone else told me it'd been fixed
18:08:57 <ivanm> *nod*
18:08:58 <ivanm> also not quite sure what the Sub bit is doing
18:09:05 <edwardk> which one?
18:09:12 <ivanm> well, the point of the data type
18:09:15 <edwardk> data a :- b = Sub (a => Dict b)
18:09:16 <edwardk> ?
18:09:17 <ivanm> (in the blog post)
18:09:18 <ivanm> yeah
18:09:28 <ivanm> is that for something like Sub Ord gives you Dict Eq ?
18:09:35 <edwardk> it says that given a, i can give you a dictionary for b.
18:09:48 <edwardk> Sub is a term remember? =)
18:10:00 <edwardk> Sub :: (a => Dict b) -> a :- b
18:10:07 <edwardk> but Ord a :- Eq a
18:10:16 <ivanm> right, that's what I meant
18:10:20 <edwardk> yes
18:10:34 <edwardk> and you can compose those
18:10:40 <ivanm> so Ord is a sub-class of Eq, etc.
18:10:52 <edwardk> Ord a :- Ord [a]    but Ord [a] :- Eq [a]    so Ord a :- Eq [a]
18:11:04 <edwardk> note the first is from an instance and the latter from a class
18:11:18 <edwardk> the composition is what the category is for
18:11:22 <ivanm> *nod*
18:11:28 <lispy> cute
18:11:28 <edwardk> read :- as 'entails'
18:11:32 * lispy nods
18:11:44 <ivanm> so do you need to state all those constraints using :- explicitly, or can they be automatically inferred?
18:11:49 <ivanm> or should I shut up and keep reading? :p
18:11:51 <edwardk> well
18:11:53 <lispy> edwardk: Are you still in Boston?
18:11:56 <edwardk> kinda =)
18:11:58 <edwardk> lispy: yeah
18:12:21 <edwardk> just moved, (this weekend in fact) but only a half mile farther away from the city
18:12:37 <lispy> cool
18:12:54 <edwardk> ivanm: I make a class for Class and a class for instances to reflect that information so you can manually walk the tree
18:12:55 * lispy feels out of the loop at times :)
18:13:25 <ddarius> s/reflect/reify/
18:13:29 <edwardk> class Class b h | h -> b where cls :: h :- b
18:13:32 <ivanm> lispy: it's easier for me, I just have to know that he's overseas :p
18:13:38 <lispy> edwardk: at this rate you'll be able to write useful programs in Haskell some day ;)
18:13:47 <edwardk> lispy: haha
18:13:54 <edwardk> ddarius: fair enough
18:14:22 <edwardk> then we can reify the definition of class itself as a Class
18:14:32 <edwardk> instance Class () (Class b a) where cls = Sub Dict
18:14:34 <ddarius> Smalltalkers would be proud.
18:14:53 <ivanm> edwardk: why is there a required comment for the \\ infix statement? some weird GHC parsing bug?
18:14:55 <edwardk> instance Class (Eq a) (Ord a) -- which you can read like class Eq a => Ord a
18:15:16 <edwardk> to keep CPP from treating it like an escaped eol
18:15:42 <ivanm> ahhh
18:15:59 <edwardk> so with Class we can walk 'up' to superclasses
18:16:08 <edwardk> and we can make a class for instances as well
18:16:22 <edwardk> class b :=> h | h -> b where ins :: b :- h
18:16:52 <edwardk> instance Class () (b :=> h) where cls = Sub Dict  -- which is a class so we can make a Class instance for it
18:17:28 <edwardk> then we can allow infinite towers of these to be reflected just from the base cases: instance Class b h => () :=> Class b h
18:17:38 <ddarius> Can you give a default definition of cls?
18:17:39 <ivanm> wait, how do trans and &&& have the same source?
18:17:40 <edwardk> instance (b :=> a) => () :=> b :=> a
18:17:45 <edwardk> ddarius: sadly no
18:17:45 <ivanm> because of the (,) instance for arrows?
18:17:53 <edwardk> ivanm: nope
18:18:16 <edwardk> Dict captures the dictionary required by use its use site
18:18:21 <edwardk> Sub does the same thing
18:18:23 <ivanm> oh, right, the Dict is a different Dict
18:18:25 <edwardk> so in any ways Sub Dict
18:18:29 <edwardk> does the right thing
18:18:33 <edwardk> in almost any context
18:18:40 <edwardk> we're asking ghc to find the solution for us
18:18:54 <edwardk> occasionally you may need to use my \\ combinator to help it along with extra information
18:19:12 <ivanm> edwardk: you use more #ifdefs without saying _why_ ....
18:19:25 <edwardk> which ones?
18:19:30 <ivanm> or is that your way of commenting out chunks of code?
18:19:43 <edwardk> that was to comment out stuff that you probably don't need
18:19:44 <ivanm> "#if 0" and "#ifdef POLYMORPHIC_KINDS" ?
18:19:48 <ivanm> *nod*
18:19:54 <ivanm> yeah, made more sense on a second read-through
18:20:06 <cmccann> #ifdef CTHULHU_FHTAGN
18:20:06 <edwardk> the polymorphic kind code was because there wasn't a usable compiler with polykinds when that post was written
18:20:36 <elliott> woot \o/
18:20:41 <edwardk> and the #if 0 was commented out code because it would be what we'd like but it couldn't be implemented
18:21:16 <ivanm> so why wouldn't typefamilies work with this that you need MPTCs + FunDeps?
18:21:17 <edwardk> ivanm: you can skip the 'limited sub-superkinding' section and go to the second article
18:21:28 <edwardk> that section was mostly a rant about the way defaulting works ;)
18:21:32 <ivanm> heh
18:21:51 <edwardk> ok, for that you DO need to read that rant
18:22:02 <aalevy> i'm unable to use ghc-pkg trust to trust blaze-html package, but if I explicitly trust with ghc/ghci -trust flag it works. anybody encounter this?
18:22:09 <ivanm> so is that because of the (,) hack for constraints?
18:22:14 <edwardk> basically ghc has a little hack for (,)
18:22:15 <edwardk> yeah
18:22:26 <ivanm> OK, I'll just accept that there's a hack and ignore why :p
18:22:30 <edwardk> it _needs_ to know the kind of something in order to parse it
18:22:31 <cmccann> elliott, congrats :D
18:23:02 <edwardk> type Foo = ((),())    -- could be the unit constraint twice, in which case its just a trivial constraint, or it could be the type of a pair of units
18:23:28 <elliott> cmccann: you can trade these for real gold, right? :P
18:23:31 <edwardk> the section there talks about how you can add a little bit of structure at the superkind level to make the hack go away
18:24:03 <ivanm> edwardk: so apart from readability, is there any reason Class and :=> are separate?
18:24:03 <cmccann> elliott, no, intangible tokens of accomplishment are far more valuable than mere gold
18:24:16 <edwardk> ivanm: they are very different things and might overlap
18:24:25 <ivanm> OK
18:24:31 <elliott> @karma cmccann
18:24:32 <lambdabot> cmccann has a karma of 5
18:24:34 <elliott> @karma elliott
18:24:35 <lambdabot> You have a karma of 7
18:24:40 <elliott> cmccann: looks like i'm richer than you, then!
18:24:41 <edwardk> one comes from class definitions, the other from instances.
18:24:46 <edwardk> sometimes those look alike, some times they don't
18:25:03 <cmccann> elliott, apparently so
18:25:15 <lispy> ?karma c
18:25:15 <lambdabot> c has a karma of 0
18:25:27 <elliott> lambdabot special-cases c
18:25:29 <elliott> preflex: karma c
18:25:29 <preflex>  c: 182509
18:25:32 <lispy> Someone finally fixed that C++ karma bug?
18:25:35 <edwardk> oh
18:25:40 <edwardk> and the arrow runs the opposite direction
18:25:41 <edwardk> https://github.com/ekmett/constraints/blob/master/Data/Constraint.hs
18:25:44 <elliott> lispy: bug?!
18:25:45 <edwardk> see 114 and 118
18:25:46 <ivanm> edwardk: I see you decided to cheat and skip the (Eq a, Show a) => Num a bit :p
18:25:53 <edwardk> ivanm: i didn't cheat
18:26:03 <lispy> ?karma dogma
18:26:03 <lambdabot> dogma has a karma of 0
18:26:06 <elliott> ivanm: those superclasses are gone
18:26:07 <edwardk> there isn't a compiler that supports constraint kinds which also has the old Num superclasses ;)
18:26:11 <lispy> ?karma SOPA
18:26:11 <lambdabot> SOPA has a karma of 0
18:26:22 <edwardk> if you try to put that in it will be a type error ;)
18:26:24 <lispy> Why does SOPA have a non-negative karma here??
18:26:26 <elliott> ?karma karma
18:26:27 <lambdabot> karma has a karma of 0
18:26:30 <edwardk> SOPA--
18:26:34 <otters> :t (***)
18:26:35 <lambdabot> forall (a :: * -> * -> *) b c b' c'. (Arrow a) => a b c -> a b' c' -> a (b, b') (c, c')
18:26:37 <elliott> karma++
18:26:45 <ivanm> edwardk, elliott: they are now, but when that was posted they were still there! ;)
18:26:58 <otters> what are arrows for?
18:27:04 <otters> oh boy I bet that's a great question
18:27:06 <edwardk> ivanm: they were in the mainline compiler, but not the build i had to use to compile that code
18:27:13 <ivanm> otters: the only one most people care about is the function/pair one
18:27:18 <ivanm> @type (succ *** show)
18:27:19 <lambdabot> forall b b'. (Enum b, Show b') => (b, b') -> (b, String)
18:27:21 <edwardk> igloo had made that change like a month before that =P
18:27:31 <edwardk> i only know because i went to put them IN at first =P
18:27:35 <ivanm> heh, fair enough
18:27:37 <elliott> ivanm: yeah, but constraint kinds weren't there :P
18:27:57 <elliott> otters: giving people something to do after writing a monad tutorial
18:28:03 <otters> oh okay
18:28:22 <cmccann> also if you have a bow you can shoot people with arrows
18:28:22 <edwardk> otters: arrows exists because people didn't understand applicatives
18:28:29 <otters> good answers
18:29:01 <edwardk> ivanm: so far so good?
18:29:08 <ivanm> edwardk: yup
18:29:19 <edwardk> so then you can do evil things: https://github.com/ekmett/constraints/blob/master/Data/Constraint/Unsafe.hs
18:29:25 <edwardk> this is cheating
18:29:28 <edwardk> but fun
18:29:32 <ivanm> oh, have you managed to get TH stuff for all this yet?
18:29:44 <otters> > (succ &&& show) 3
18:29:45 <lambdabot>   (4,"3")
18:29:50 <otters> intriguing
18:29:55 <edwardk> not sure if TH has been expanded with that i'd need. doubt it
18:29:55 * hackagebot wai-middleware-catch 0.3.2 - Wai error catching middleware  http://hackage.haskell.org/package/wai-middleware-catch-0.3.2 (AlexanderDorofeev)
18:30:09 <ivanm> otters: that kind of stuff is the most I've ever seen Arrows used for
18:30:19 <otters> well, okay
18:31:09 <elliott> otters: they're also used in arrowised frp ala netwire
18:31:12 <ivanm> edwardk: :o unsafeCoerce! :o
18:31:16 <elliott> apart from that... yeah
18:31:18 <edwardk> yep
18:31:23 <edwardk> i'm casting a dictionary there
18:31:27 <ivanm> elliott: oh, yeah, but how many people use that currently?
18:31:38 <elliott> how many people use haskell? :P
18:31:43 <edwardk> 2
18:31:46 <nyingen> over 9000
18:31:49 <elliott> 3. i'm the third
18:31:52 <roconnor> 819
18:31:55 <edwardk> no i was counting you
18:31:59 <elliott> oh.
18:32:02 <elliott> you must be ivanm, then
18:32:13 <edwardk> ivanm is just an interested observer
18:32:15 <ivanm> edwardk: I see your blog software still mangles arrow brackets :s
18:32:18 <otters> to my untrained eyes, (&&&) === liftM2 (,)
18:32:22 <edwardk> ivanm: yep
18:32:31 <edwardk> it sucks, but otherwise keeps the blog going
18:32:34 <edwardk> i'll live ;)
18:32:36 <elliott> @check \f g x -> (f &&& g) x == liftM2 (,) f g x
18:32:37 <ivanm> edwardk: hey! I write Haskell! (though my supervisor has said I've got to use C for my next project :( )
18:32:37 <lambdabot>   Overlapping instances for GHC.Show.Show (b -> c)
18:32:38 <lambdabot>    arising from a use of `...
18:32:42 <elliott> aw c'mon
18:32:52 <elliott> :t (f &&& g, liftM2 (,))
18:32:52 <lambdabot> forall (a :: * -> * -> *) b c c' a1 a2 (m :: * -> *). (SimpleReflect.FromExpr (a b c), SimpleReflect.FromExpr (a b c'), Arrow a, Monad m) => (a b (c, c'), m a1 -> m a2 -> m (a1, a2))
18:32:53 <elliott> argh
18:32:55 <cmccann> ivanm, just use GHC's C backend
18:32:57 <cmccann> that counts, right
18:32:57 <elliott> :t ((&&&), liftM2 (,))
18:32:58 <lambdabot> forall (a :: * -> * -> *) b c c' a1 a2 (m :: * -> *). (Arrow a, Monad m) => (a b c -> a b c' -> a b (c, c'), m a1 -> m a2 -> m (a1, a2))
18:33:07 <ivanm> cmccann: nah, I've got to extend his C codebase
18:33:10 <elliott> otters: i conclude you're right
18:33:17 <ivanm> with his dodgy "you can do what you like except evil military stuff" license :s
18:33:23 <otters> huh
18:33:24 <ivanm> silly academics :p
18:33:26 <cmccann> haha
18:33:30 <otters> I can't believe I figured that out
18:33:32 * otters haskell level 2
18:33:49 <edwardk> anyways with a bit of meta-reasoning about instances for types that don't get exported you can also define https://github.com/ekmett/constraints/blob/master/Data/Constraint/Forall.hs
18:34:20 <edwardk> which gives you Forall :: (k -> Constraint) -> Constraint
18:34:25 <cmccann> otters, I think technically Arrow instances are supposed to have certain properties beyond Applicative, but when a type has instances for both I would expect those to coincide
18:34:27 <ivanm> edwardk: OK, so is there an actual *practical* use for this, or is it just that it's cool?
18:34:30 <edwardk> sadly i can't define it once and foral
18:34:42 <edwardk> the applicative combinator is pretty cool
18:34:45 <elliott> ivanm: Dude! You're in #haskell!
18:34:55 * hackagebot wai-middleware-route 0.3.1 - Wai routing middleware  http://hackage.haskell.org/package/wai-middleware-route-0.3.1 (AlexanderDorofeev)
18:35:02 <elliott> That's the one question you never ask.
18:35:03 <monochrom> there is an actual *cool* use for this
18:35:14 <cmccann> otters, oh and while you're at it, what is "arr" if (&&&) is liftM2 (,)?
18:35:17 <monochrom> best of both worlds :)
18:35:21 <ivanm> elliott: well, yes, but I need to know if there's any point in me actually trying to *really* understand it all because it will make *my* code better!
18:35:26 <otters> cmccann: no idea
18:35:32 <edwardk> it lets you program with functor and applicative sugar in a local block given just a monad dictionary without lifting and unlifting all over the place like you have to with WrappedMonad
18:35:47 <cmccann> otters, look at the types and think about it
18:35:55 <otters> :t arr succ
18:35:56 <lambdabot> forall b (a :: * -> * -> *). (Enum b, Arrow a) => a b b
18:36:13 <otters> ohhh wait
18:36:17 <edwardk> foo :: Monad m => ….     foo = applicative $ …. <$> <*> .. *> …<*…. <*> …<*> …
18:36:19 <otters> oh boy I don't know the terminology for this
18:36:34 <otters> :t (<$>)
18:36:34 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
18:36:44 <elliott> edwardk: you promote the actual use of that brittle thing? :P
18:36:46 <monochrom> then don't use terminology. use formulas
18:36:51 <edwardk> the other main use is for 'capturing' a dictionary when its available and using it later
18:36:54 <edwardk> elliott: no
18:36:55 <elliott> (ok, it's cool -- but eek)
18:37:00 <edwardk> but its pretty neat =)
18:37:09 <otters> so f a is like a box with a value in it with type a
18:37:13 <otters> pardon me
18:37:14 <edwardk> i used this approach in my heaps package forever ago
18:37:15 <elliott> :(
18:37:20 <ivanm> elliott: that's my impression of a lot of edwardk's stuff :p
18:37:23 <edwardk> but now you could do so in a more general fashion
18:37:25 <elliott> container analogy spotted. deploying burrito jokes
18:37:28 <otters> but I don't understand "a b b" when a is an Arrow and b is Average Joe type
18:37:36 <elliott> otters: think of a b c as (b ~> c)
18:37:37 <ivanm> @instances Arrow
18:37:38 <lambdabot> (->), Kleisli m
18:37:41 <otters> that doesn't help at all
18:37:45 <otters> I don't even know what ~> is
18:37:47 <elliott> it does
18:37:49 <elliott> (~>) is nothing
18:37:51 <elliott> just a symbol
18:37:56 <ivanm> otters: ^^ so for example, a == ->, so "a b b" is "b -> b"
18:37:57 <elliott> a is just the instance, like m for Monad
18:37:59 <otters> oh
18:38:02 <ivanm> i.e. a function that doesn't change the type
18:38:02 <otters> oh
18:38:03 <elliott> "arrow" is named after the function arrow
18:38:04 <elliott> so for example,
18:38:06 <elliott> :t (&&&)
18:38:07 <lambdabot> forall (a :: * -> * -> *) b c c'. (Arrow a) => a b c -> a b c' -> a b (c, c')
18:38:13 <otters> ...
18:38:14 <otters> hm
18:38:15 <elliott> (b ~> c) -> (b ~> c') -> (b ~> (c, c'))
18:38:19 <ion> @type (&&&) `asAppliedTo` (undefined :: a -> b)
18:38:19 <lambdabot> forall b c c'. (b -> c) -> (b -> c') -> b -> (c, c')
18:38:21 <edwardk> ivanm: *shrug* i write this stuff because it interests me. not so you can use it ;) if anything that is a fringe benefit you can derive from my occasional fits of mania ;)
18:38:22 <ddarius> Arrow isn't named after the function arrow.
18:38:25 <elliott> so any arrow (~>) can do that operation
18:38:27 <otters> okay
18:38:29 <elliott> ddarius: oh, hmm, is it not?
18:38:31 <ivanm> edwardk: oh, it's definitely cool
18:38:31 <elliott> I just assumed :)
18:38:35 <otters> I am officially lost
18:38:41 <elliott> otters: glad i could help
18:38:43 <cmccann> haha
18:38:44 * otters goes to find a soda
18:38:51 <cmccann> otters, you had the right idea to begin with though
18:38:52 <otters> a b b is b (a) b
18:38:54 <ivanm> I just always have to remember that I shouldn't spend too much time trying to understand it all completely as it just distracts me from what I *should* be doing :p
18:38:57 <otters> ?
18:39:01 <otters> am I doin it rite
18:39:04 <elliott> otters: b `a` b, rather
18:39:08 <otters> well yeah
18:39:14 <otters> same thing
18:39:20 <otters> (I know, not the same thing)
18:39:22 <ivanm> not really
18:39:23 <otters> but I think I understand it now
18:39:30 <edwardk> *shrug* you can take that approach. or you can wallow in the coolness of it all ;)
18:39:30 <cmccann> otters, in the same sense that (&&&) = liftM2 (,) then arr = (<$>)
18:39:35 <ivanm> edwardk: heh
18:39:38 <otters> ohkay
18:39:40 <elliott> in reality, an arrow is very simple, it's just: id :: a b b; (.) :: a c d -> a b c -> a b d; first :: a b c -> a (b,d) (c,d)
18:39:41 <ddarius> So x a b is a (x) b, ne?
18:39:43 <elliott> and some laws
18:39:48 <elliott> all the other operations can be derived from those three
18:39:49 <otters> x a b is a `x` b
18:39:51 <otters> get out, n00b
18:40:07 <elliott> replace (a b c) with (b -> c), and you should easily be able to implement those for functions :)
18:40:13 <edwardk> arrows are at once more than they need to be and less than they should =P
18:40:26 <otters> next question
18:40:29 <otters> :t (***)
18:40:30 <lambdabot> forall (a :: * -> * -> *) b c b' c'. (Arrow a) => a b c -> a b' c' -> a (b, b') (c, c')
18:40:33 <rwbarton> what happened to arr?
18:40:38 <ion> yarr
18:40:41 <otters> okay
18:40:47 <otters> wait
18:40:47 <edwardk> rwbarton: silently ignored, as it should be =P
18:40:53 <otters> what arrows are there besides ->?
18:40:59 <elliott> oh, crap
18:40:59 <edwardk> Kleisi
18:40:59 <rwbarton> aha
18:41:01 <elliott> I forgot about arr :(
18:41:04 <otters> oh boy
18:41:07 <aib> I'm trying to cast "return" to return a list, but I'm missing... the type name of lists? (return 3) :: Something should return [3] ?
18:41:07 <elliott> in reality, an arrow is very simple, it's just: id :: a b b; (.) :: a c d -> a b c -> a b d; first :: a b c -> a (b,d) (c,d); arr :: (b -> c) -> a b c
18:41:08 <edwardk> Kleisli is basically a -> m b   for some monad
18:41:09 <elliott> and some laws
18:41:20 <elliott> for values of "basically" equal to "literally" :)
18:41:21 <cmccann> elliott, without arr you probably want fst and snd in there btw
18:41:22 <otters> I see
18:41:23 <monochrom> return 3 :: [Int]
18:41:27 <elliott> cmccann: I added arr :P
18:41:40 <edwardk> you can also make one out of any applicative using 'static arrow composition'
18:41:44 <edwardk> f (a -> b)
18:41:45 * elliott thinks otters is probably more interested in learning Arrow than GArrow or any other such non-standard thing first :P
18:41:47 <ddarius> @arr
18:41:47 <lambdabot> Har de har har!
18:41:57 <edwardk> or even f (a b c) -- for another arrow a
18:42:03 <ion> mm_freak’s article used a State arrow.
18:42:09 * ddarius doesn't see why anyone would be interested in learning Arrow.
18:42:14 <otters> so a b c is equivalent to b -> c assuming a is (->)
18:42:26 <elliott> yes
18:42:27 <ddarius> :t id :: (->) a a
18:42:28 <lambdabot> forall a. a -> a
18:42:37 <otters> and (***) takes (b -> c) and (b' -> c') as its first two arguments
18:42:42 <aib> monochrom: can't I just infer Int? oh hold on, why is (return 3) :: Maybe not working?
18:42:47 <otters> :t (succ *** show)
18:42:48 <lambdabot> forall b b'. (Enum b, Show b') => (b, b') -> (b, String)
18:42:54 <monochrom> return 3 :: Maybe Int
18:42:58 <otters> so uh
18:43:02 <otters> :t succ
18:43:03 <lambdabot> forall a. (Enum a) => a -> a
18:43:03 <aib> monochrom: no actual type to construct a Maybe?
18:43:08 <rwbarton> aib: "Maybe" isn't the sort of thing that can be a type of a value.
18:43:19 <otters> a -> a is like...a subtype of (Arrow b) => b a a
18:43:20 <otters> ?
18:43:22 <rwbarton> The type of a value, even.
18:43:28 <edwardk> ddarius: any idea how to derive . nicely in http://hpaste.org/57503 ?
18:43:29 <otters> or there's some kind of implicit conversion
18:43:31 <ddarius> It's an instance.
18:43:38 <otters> okay
18:43:44 <monochrom> "Maybe" alone is incomplete for this
18:43:45 <aib> I see.
18:43:54 <otters> haskell is so meta
18:44:43 <ddarius> edwardk: For sum categories?
18:44:46 <edwardk> yeah
18:44:52 <monochrom> haskell type inference does not work by omitting 10% of the type expression. write it 100% or 0%.
18:45:05 <otters> and that's a good thing!
18:45:16 <edwardk> the need to use (:|) to build the constraint coproduct complicates my life a lot
18:45:30 <otters> omg can you actually define (:|)
18:45:42 <edwardk> yep
18:45:48 <otters> holy crap
18:45:54 <ion> > (:[]) ":[]"
18:45:55 <lambdabot>   [":[]"]
18:46:37 <nyingen> lol pareidolia
18:46:45 <edwardk> left/right and choose should give me the injection/projection machinery i need
18:47:59 <edwardk> product categories are similarly headache inducing
18:49:14 <ddarius> edwardk: What happens when you just start writing the obvious code for (.)?
18:50:06 <edwardk> i'll paste
18:52:12 <hpaste> edwardk annotated “polykinded sum categories” with “polykinded sum categories (annotation)” at http://hpaste.org/57503#a57506
18:53:05 <edwardk> so i clearly need to break down the (:|) dictionary to get at the one for each case
18:53:27 <edwardk> unless you meant that as 'the obvious code'
18:53:55 <edwardk> the (ob a, ob b, ob c) => constraints are what i'm trying to solve, without those this becomes trivial
18:56:01 <ddarius> edwardk: Where are the type constructors Left and Right defined?
18:56:14 <edwardk> they are caused by lifting them from Either
18:56:18 <ddarius> Ah yes.
18:56:21 <edwardk> 'DataKinds'
18:56:21 <ddarius> I forgot about that.
18:56:41 <edwardk> figured i might as well use the baked in kind definition =)
19:02:21 <ddarius> edwardk: So what I would do to get more relevant error messages is have (.) = comp :: t where comp (L f) (L g) = ... and have t be something like (ob x ~ choose ..., ob y ~ ..., ...) => (c :+ d) y z -> (c :+ d) x y -> (c :+ d) x z or whatever
19:02:29 <edwardk> hah
19:02:29 <otters> o___O
19:02:39 <edwardk> i just started building that =)
19:02:41 <otters> somebody should start an international obfuscated haskell contest
19:02:51 <ddarius> otters: There's already been three.
19:02:55 <otters> okay
19:03:32 <ddarius> Lennart, of multi IOCCC fame, won at least one of them (or at least got an judge's prize)
19:04:06 <monochrom> wait, but that's C, not Haskell
19:04:21 <ivanm> preflex: seen chrisdone
19:04:22 <preflex>  chrisdone was last seen on #haskell 7 days, 15 hours, 52 minutes and 58 seconds ago, saying: dzhus: sounds like you're trying to parse it into the wrong type?
19:04:25 <monochrom> oh, misread, I see what you mean
19:04:44 <monochrom> but I would say "Lennart of Haskell fame" instead :)
19:04:59 <edwardk> something like:
19:05:01 <edwardk> agree :: ED p q x -> ED p q y -> ED p q z -> (c :+: d) y z -> (c :+ d) x y -> ((p x', p y', p z', x ~ Left x', y ~ Left y', z ~ Left z') => c y' z' -> c x' y' -> r) -> (c :+: d) y z -> (c :+ d) x y -> ((q x', q y', q z', x ~ Right x', y ~ Right y', z ~ Right z') => d y' z' -> d x' y' -> r)
19:05:10 <Axman6> wut
19:05:10 <edwardk> er -> r
19:05:21 <Axman6> oh right, obviously
19:05:23 <Axman6> >_>
19:05:54 <edwardk> missed a couple parens
19:06:01 <edwardk> but i hope the idea made it through
19:06:52 <monochrom> ok, I confess I don't know which Lennart it is
19:07:59 <edwardk> monochrom: they are the same lennart
19:08:02 <ddarius> edwardk: That fixed up, seems sane.
19:09:22 <ion> There exists just one Lennart.
19:09:47 <Axman6> Or, put another way, all Lennart's are one
19:09:47 <ddarius> The universe wouldn't know what to do if there were two.
19:11:19 <hpaste> edwardk annotated “polykinded sum categories” with “agree?” at http://hpaste.org/57503#a57507
19:11:20 * cmccann found it incredibly, shockingly expected and unsurprising that the author of the BASIC monad had also entered the IOCCC several times
19:11:34 <ddarius> cmccann: Not just entered.
19:11:37 <edwardk> not only entered but won ;)
19:11:56 <cmccann> ha, forgot that
19:12:04 <edwardk> ddarius that type checks, now to use it
19:13:16 <ddarius> edwardk: Yeah, I suspect GHC is nowhere near smart enough to do that kind of case analysis implicitly, and that was more or less what I was expecting.
19:13:26 <aib> what was that ghc switch to fix the "Ambiguous type variable" warnings?
19:14:32 <ddarius> edwardk: This strikes me as just the kind of code the Dans would like to write.
19:14:35 <aib> e.g. echo let x = return | ghci
19:15:11 <parcs`> :set -XNoMonomorphismRestriction
19:15:26 <edwardk> yep
19:15:43 <edwardk> i was going to surprise them with it in the morning ;)
19:16:16 <parcs`> aib: put that in the ~/.ghci file to have it set automatically
19:16:27 <aib> parcs`: cheers.
19:17:19 <edwardk> was at ikea earlier today with amy. bought a couple of laptop stands so there'd be room in my office for people who come over to work, and being ikea everything has a funny name, they were both named 'Dave'. I remarked that if they'd been named 'Dan' we could just refer to them as copumpkin and dolio like we do in meetings at work ;)
19:17:47 <copumpkin> lol
19:17:48 <ivanm> what's this ambiguous type variable warning, and why does declaring an alias for return fix it? :/
19:17:58 <ivanm> edwardk: heh
19:18:43 * ddarius considers getting a mountain strop.
19:19:03 <ivanm> dammit, I have to write up these incidental math results from about 6 months ago as part of this paper, but I can't find where I did it so I have to re-calculate everything :s
19:19:39 <parcs`> ivanm: 'let x = return' triggers a type error in ghci due to 'return's polymorphicness and ghc's monomorphism restriction
19:19:58 <parcs`> well it's not actually a type error :P
19:20:11 <ivanm> oh, I missed it; I thought what aib said *was* the fix :s
19:20:12 <dolio> ddarius: I think I'd rather write code in a language that was better suited to what he's doing.
19:20:16 <ivanm> not what you said
19:20:20 <parcs`> ah
19:20:21 * ivanm needs to learn2read
19:20:38 <edwardk> dolio: think of it like building a ship in a bottle
19:21:40 <dolio> You don't build the ship in the bottle.
19:21:57 <aib> ivanm: o_O
19:22:01 <monochrom> oh noes, another monad analogy?!
19:22:08 <ivanm> monochrom: heh
19:22:32 <ivanm> copumpkin: ahhh, got what you meant on G+; got the symbols and sets the wrong way round in my head
19:22:52 <edwardk> of course not. you write it in agda first, then once you put it in the bottle you raise the masts
19:23:02 <monochrom> that is the best analogy so far, because I recognize that it is a monad analogy without being told that it is
19:23:46 <JoeyA> If I use atomicModifyIORef to change an IORef, are subsequent calls to readIORef from any thread guaranteed to have the new value?
19:23:47 <ion> Ooh, *that’s* why you can’t get the a out of IO a: it would break the bottle.
19:23:53 <ivanm> ion: heh
19:23:54 <parcs`> it beats burritos and spacesuits
19:24:14 <ion> Everything’s so clear now.
19:24:34 <monochrom> God, we have invented a monster
19:24:55 * hackagebot lha 0.1.2 - Data structures for the Les Houches Accord  http://hackage.haskell.org/package/lha-0.1.2 (ScottLawrence)
19:25:28 <ion> Functors are like Jesus’ first miracle: you don’t change the bottle.
19:25:53 <monochrom> and oh, I hope some laptops will talk to their ikea laptop stands like this: "how are you, Dave?"
19:25:56 <cmccann> monochrom, it's kind of sad that if I hear "free burritos" my first thought is that they'd be a bunch of layers of tortillas with some trivial filling in the middle
19:34:32 <edwardk> WOOHOO
19:34:45 <ddarius> Uses of it actually work?
19:34:50 <monochrom> a monster is born
19:34:53 <edwardk> no idea
19:35:01 <edwardk> they type check though =)
19:35:18 <ddarius> Products too?
19:35:37 <edwardk> i've got more code that set those up, just didn't get around to their (.)
19:36:14 <hpaste> edwardk annotated “polykinded sum categories” with “polykinded sum categories (annotation)” at http://hpaste.org/57503#a57508
19:36:35 <zzo38> I made up a preprocessor for Haskell.
19:36:44 <zzo38> Here it is:   http://sprunge.us/FfJA  It is called "Hampp" it is short for "Haskell macro preprocessor"
19:36:50 <zzo38> Tell me I'm wrong.
19:36:55 <edwardk> the intermediate types get somewhat silly ;)
19:37:31 <ddarius> zzo38: You're wrong.
19:37:44 <zzo38> ddarius: Are you sure?
19:38:22 <edwardk> nah, he's ex military. they're good at following orders
19:38:50 <zzo38> edwardk: O, OK.
19:38:55 <zzo38> Now you can please tell me in case something should be add/remove/whatever, or comment/question/complain, or something else.
19:39:12 <ddarius> Why would I use that rather than lhs2TeX?
19:39:19 <mzero> is that a macro preprocessor for preprocessing haskell source?
19:39:23 <edwardk> examples are good =)
19:39:26 <zzo38> mzero: Yes.
19:39:46 <edwardk> of course i'm ultimately fairly hypocritical in asking for them ;)
19:39:47 <zzo38> ddarius: It is not even the same purpose
19:39:54 <mzero> okay, zzo38: You're wrong (but only 'cause you asked me to tell you)
19:39:56 * hackagebot lhe 0.4 - Parser and writer for Les-Houches event files  http://hackage.haskell.org/package/lhe-0.4 (ScottLawrence)
19:39:58 * hackagebot cereal-conduit 0.0.1 - Turn Data.Serialize Gets and Puts into Sources and Sinks  http://hackage.haskell.org/package/cereal-conduit-0.0.1 (MylesMaxfield)
19:40:10 <zzo38> Here is example:   http://sprunge.us/YWAJ
19:40:14 <ddarius> zzo38: What is the purpose of your thing?
19:40:49 <zzo38> ddarius: It is used with -pgmF
19:41:22 <mzero> congratulations - you've made Haskell become C?
19:41:48 <mzero> have you ever actually needed such a facility?
19:41:53 <zzo38> mzero: No, I have not done that. Anyways you can already use C preprocessor with Haskell and I think C preprocessor is no good for Haskell anyways.
19:42:33 <zzo38> Occasionally it would be very helpful, in things I have done and think about in past. So sometimes I had to do it in the other way
19:42:41 <ddarius> edwardk: I'm technically still in the military.
19:43:55 <Axman6> technically?
19:43:57 <zzo38> I do intend to add things to my program.
19:44:01 <mzero> curious - I can't imagine what I'd need it for!
19:44:44 <edwardk> ddarius: fair nuff =)
19:45:16 <zzo38> Such as 8data for open datatypes, and 8sort for sorting. And, add more include formats (currently it only support .hs and .lhs file, but I might add support to include XML files and so on)
19:45:18 <ddarius> Axman6: I signed an eight year contract six years ago.
19:45:37 <Axman6> ddarius: they still paying you?
19:45:51 <ddarius> Axman6: The once in a blue moon when I'm obligated to do something, yes.
19:46:18 <Axman6> heh. what were/are you doing for them?
19:46:44 * cmccann imagines ddarius as a commando doing occasional infiltrations of high-security targets
19:46:46 <tgeeky> ddarius: better you schedule your work for, once in a green Sun.
19:46:52 <ddarius> Axman6: I was an enlisted airman, now I'm inactive.
19:47:14 <tgeeky> ddarius: you could still kick my ass though, right?
19:48:15 <ddarius> tgeeky: I don't believe I've met you.  So I do not know.  If the answer is "yes," then it was probably "yes" before the military.
19:48:52 <tgeeky> ddarius: good answer. It's probably yes. I'm pretty huge, though - 6'5, 275.
19:49:26 <tgeeky> ddarius: btw, my quip ^^ wasn't nonsense: http://blogs.discovermagazine.com/badastronomy/2008/07/29/why-are-there-no-green-stars/
19:49:36 <zzo38> And tell me, if there is something wrong in my program or something that you failed to understand some part of the program.
19:49:39 <edwardk> ddarius chased down a couple of muggers a while back to get something back they took from him ;)
19:49:49 <edwardk> mind you that speaks more to crazy than toughness
19:50:00 <zzo38> tgeeky: Yes that is what I thought, there is no green star
19:50:47 <ddarius> edwardk: Crazy is my secret.
19:51:58 <edwardk> its so much easier writing the second one of these
19:52:40 <lispy> ddarius: are you in academia, industry, or military these days?
19:53:38 <edwardk> technically all 3, no?
19:53:39 <edwardk> =)
19:53:53 <Axman6> i was going to say, those aren;t exactly exclusive
19:54:07 <tgeeky> damn the military-industrial-educational complex!
19:55:09 <lispy> hehe
19:55:22 <hpaste> “douban@released” pasted “24点” at http://hpaste.org/57510
19:57:25 <zzo38> It is intend my program can be combined with Template Haskell.
19:59:57 * hackagebot hepevt 0.5 - HEPEVT parser  http://hackage.haskell.org/package/hepevt-0.5 (ScottLawrence)
20:03:11 <edwardk> woot category products are in
20:03:25 <tgeeky> edwardk: in...to...what?
20:04:21 <ivanm> tgeeky: his latest make-Haskell-uber attempt :p
20:04:50 <edwardk> tgeeky: i was working out how to deal with polykinded categories with constraints
20:04:57 * ivanm points AfC towards #haskell.au
20:05:22 <tgeeky> edwardk: something I can play with in 7.4.1?
20:05:28 <edwardk> yep
20:05:33 <tgeeky> *slow clap*
20:05:42 <edwardk> not there yet?
20:05:53 * tgeeky issues a time dilation
20:05:57 <tgeeky> I can wait
20:05:58 <zzo38> A lot of my suggestions are things many people in #haskell channel hate
20:06:12 <tgeeky> zzo38: that's an excellent reason to do them
20:06:37 <edwardk> zzo38: its not so much hate as haven't felt the need for. its the kind of project only its inventor can really love
20:06:58 <AfC> ivanm: is there a particularly antipodean way of writing Haskell?
20:07:02 <edwardk> for others the names of things become a bit of an impenetrable barrier to understanding.
20:07:08 <edwardk> ;)
20:07:30 <ivanm> AfC: not particularly, it's primarily there for talking about haskell-related events down under
20:08:20 <hpaste> edwardk pasted “more polykinded categorical goodness” at http://hpaste.org/57511
20:08:42 <AfC> ivanm: fair enough. I don't generally lurk in country-centric channels, but I'll keep it in mind for when I'm in Australia. Thanks!
20:08:48 <edwardk> the types of the choicesAgree and bothAgree helper functions make me cringe a bit though
20:08:55 <edwardk> wonder if i could simplify them away
20:11:30 <danharaj> hmm
20:11:47 <danharaj> I wonder if you can hack in superclassing by abusing constraint kinds
20:12:18 <danharaj> and the other kind machinery that's been added.
20:12:35 <edwardk> not really, because they are kinda rigid
20:13:31 <ion> Is #haskell.au the channel where people talk about Haskell in Australian instead of English, mate?
20:14:00 <ivanm> ion: that's the ridgy didge!
20:14:02 <zzo38> Which of my Haskell extension proposals do you hate or like or neutral? -XNoEnglishKinds -XImportWildcards -XNaturalNumberKind -XHideNonexisting -XInstanceDisambiguation -fassume-no-error -fcrashable -fall-modules-together -XDefaultInstances -XZeroParamTypeClasses -fno-rts-options
20:14:04 <tgeeky> lolol
20:14:17 <ivanm> zzo38: where are these documented?
20:14:25 <danharaj> edwardk: Well I was thinking you could define a category for constraints where the arrows are evidence that let you turn one constraint into another.
20:14:28 <ivanm> and isn't-fno-rts-options the default now?
20:14:28 <tgeeky> NoEnglishKinds? yikes!
20:14:41 <edwardk> danharaj: i have that
20:14:46 <zzo38> ivanm: Nowhere really; I just wrote about them on this IRC channel as well as #esoteric IRC channel
20:14:55 <edwardk> http://comonad.com/reader/2011/what-constraints-entail-part-1/
20:15:00 <tgeeky> zzo38: oh, that does not constitute a proposal.
20:15:03 <edwardk> http://comonad.com/reader/2011/what-constraints-entail-part-2
20:15:05 <danharaj> edwardk: magic.
20:15:09 <zzo38> tgeeky: I know.
20:15:10 <tgeeky> zzo38: proposals are things that are documented and uploaded and etc.
20:15:14 <edwardk> danharaj: liskov substitutability forms a category
20:15:18 <ivanm> IIRC, wasn't there some project a while back that shoved all haskell modules together, which I believe -fall-modules-together is meant to be for?
20:15:18 <edwardk> i also have it in scala
20:15:28 <tgeeky> zzo38: and yet you said "Which of my Haskell extension proposals do you hate or like or neutral?"
20:15:45 <danharaj> edwardk: Can you give an idea of how much power the new extensions add to the type system?
20:15:50 <danharaj> They seem pretty big.
20:15:58 <zzo38> I can explain some of them a bit, though.
20:16:03 <tgeeky> danharaj: the kind stuff in 7.4? me too.
20:16:06 <edwardk> https://github.com/scalaz/scalaz/blob/master/core/src/main/scala/scalaz/Liskov.scala or the more robust https://github.com/ekmett/magpie/blob/master/src/main/scala/magpie/subtype.scala
20:16:17 <ivanm> zzo38: what do you mean by "NoEnglishKinds" ?
20:16:30 <edwardk> danharaj: its mostly the ability to 'talk' about constraints like any other kind
20:16:47 <zzo38> -XHideNonexisting would make it so that if you use import hiding and the hiding list includes things that the named module does not export, then it is not an error/warning, it just ignores those parts of the hiding list.
20:16:55 <edwardk> and the ability to be more precise than just allowing anything of kind * when you really only want one of a few things
20:17:00 <danharaj> edwardk: And what about kind polymorphism?
20:17:15 <edwardk> kind polymorphism is actually a big win for a few usecases
20:17:21 <edwardk> but otherwise largely invisible
20:17:23 <tgeeky> zzo38: so "hiding" is thought of just like a bitmask
20:17:46 <edwardk> it means i can make a Category instance for Constraints, product and sum categories
20:18:03 <edwardk> and it also means i can do things like make a category for natural transformations, etc.
20:18:24 <danharaj> That's pretty cool.
20:18:25 <edwardk> which is really nice, because the 'index' doesn't have to be 'anything of kind *'
20:18:28 <zzo38> ivanm: -XNoEnglishKinds means that Constraint kind is now called & and my natural number kinds (not the normal one) is now called + and the ones previously called ? and ?? are still called ? and ??
20:18:32 <edwardk> it can be a narrower kind
20:18:41 <edwardk> or in the case of constraint a largely unrelated kind
20:18:44 <zzo38> tgeeky: Yes, like that, I suppose.
20:18:48 <tgeeky> edwardk: I mentioned somewhere (maybe in #diagrams) that I thought it would really help simplify and "mofe forward" long-standing proposals like NumericPrelude and 'yap'.
20:18:58 <ivanm> zzo38: why mroe symbols?
20:19:08 <edwardk> tgeeky: yeah i've been working towards using it in a rewrite of my algebra package
20:19:11 <tgeeky> zzo38: I want the same thing. You should actually make that proposal so I can talk about it officially
20:19:25 <tgeeky> edwardk: methinks the flexibility will inspire some creative thinking there
20:19:27 <zzo38> tgeeky: OK. What is the proper way to do so?
20:19:31 <edwardk> yeah
20:19:43 <edwardk> "Ordered Monoid a" is particularly nice
20:19:58 * hackagebot dph-lifted-copy 0.6.0.1 - Data Parallel Haskell lifted array combinators. (deprecated version)  http://hackage.haskell.org/package/dph-lifted-copy-0.6.0.1 (BenLippmeier)
20:20:03 <edwardk> "Ordered Ring a :- Ordered Monoid a"
20:20:16 <danharaj> That you can have things like restricted monads sounds nice too.
20:20:26 <tgeeky> zzo38: i'm sure someone else in here has submitted a request like that
20:20:28 <danharaj> Like this change really rounds out type classes.
20:20:31 <tgeeky> zzo38: I think it's somewhere here: http://hackage.haskell.org/trac/haskell-prime/
20:20:34 <tgeeky> but I'm not sure.
20:20:35 <rwbarton> with DataKinds I can also write down "small" categories like * -> *, right?
20:20:38 <edwardk> which is one reason why i've been obsessed with packaging what i can talk about with constraints
20:20:56 <edwardk> danharaj you need to be really really careful that you don't screw up and wind up with type families that get in the way though
20:21:03 <edwardk> rwbarton: yeah
20:21:03 <zzo38> danharaj: Yes. But what I think most is Category with constraints, rather than Monad with constraints.
20:21:04 <rwbarton> (if it wasn't clear, I mean the category with two objects and one non-identity arrow between them)
20:21:13 <rwbarton> not some kind syntax
20:21:21 <danharaj> edwardk: hm?
20:22:03 <edwardk> danharaj: one of the reasons why its taking me so long to write this is that i'm trying not to wind up in 'restricted monad hell'
20:22:13 <zzo38> My own -XNaturalNumberKind is somewhat different from other one; it should be called Nat normally and + when -XNoEnglishKinds is enabled. In addition, my + is a subkind of * and there are other differences from the ordinary proposal
20:22:43 <edwardk> its hard to write a lot of combinators and constructions over restricted monads because they talk about the parameter to the monad, which gets in the way of anything that ties the knot through them, like free monads, etc.
20:22:50 <edwardk> or which threads it through a structure
20:22:51 <danharaj> ah
20:22:54 <edwardk> or is cps'd
20:22:55 <edwardk> etc
20:23:09 <edwardk> so you really want to be as parametric as possible
20:23:14 <danharaj> so the theory of restricted monads isn't very well behaved
20:23:32 <danharaj> or is it just tedium?
20:23:34 <edwardk> well, there are well behaved variants of it, i think thorsten has one
20:23:37 <zzo38> edwardk: I know those kinds of stuff too; but I would like to have constrainted Category
20:23:54 <edwardk> zzo38: yes, hence why i'm building one =P
20:24:18 <edwardk> i finally got the constraint category to be able to handle product and sum categories which was a major roadblock to me using it for anything
20:24:22 <edwardk> er constrained category
20:24:54 <edwardk> but the constraint takes something trivial and makes it rocket science =)
20:25:09 <edwardk> i still want them
20:25:12 <danharaj> so how many more extensions before type classes are first class entities :p
20:25:17 <edwardk> i just don't want to replace the nice one with it
20:25:26 <edwardk> they better never be
20:25:37 <edwardk> go work in scala for 6 months and you'll see why that is a TERRIBLE idea =P
20:25:44 <zzo38> Haskell isn't rocket science (unless you are writing a program for controlling rockets)
20:25:53 <danharaj> oh scala did that?
20:26:01 <danharaj> that sounds like a daring move.
20:26:04 <edwardk> implicits
20:26:14 <edwardk> they are more or less 'explicitly passable type classes'
20:26:21 <edwardk> without any of the confluence guarantees
20:26:31 <danharaj> doesn't that lead to incoherency problems?
20:26:40 <edwardk> so you can't really safely use them for monads, but people do, you can't use them for reliable ordering for sets, etc.
20:26:41 <edwardk> yep
20:26:44 <edwardk> all over the place
20:26:47 <edwardk> scalaz is riddled with them
20:26:59 <danharaj> Maybe not first class is what I meant :p
20:27:05 <danharaj> first and a half class.
20:27:37 <tgeeky> sure sure, and then we'll be counting some as 3/5ths class, and it's civil war all over again.
20:27:47 <edwardk> i find that the constraint kind gives you enough of a 'vocabulary' to manipulate dictionaries that we're already more or less there
20:27:49 <ddarius> danharaj: You can reify type classes for a while now.
20:28:01 <danharaj> ddarius: dictionary passing?
20:28:08 <edwardk> data Dict a where Dict :: a => Dict a
20:28:22 <edwardk> danharaj: that lets you capture the dictionary and pass it around
20:28:31 <ddarius> danharaj: No, though edwardk's approach makes that much more practical.
20:28:52 <danharaj> edwardk: I'll have to read your blog posts in detail to see what you've done then.
20:28:53 <edwardk> data Heap a = Heap (Dict (Ord a)) ….             which you can then open up in the Foldable instance for it for instance
20:30:02 <edwardk> danharaj: https://github.com/ekmett/constraints/tree/master/Data if you prefer looking at code to reading about it
20:30:07 <ddarius> edwardk: I wonder if you can make something like an Applicative to handle functions like bothAgree.
20:30:27 <edwardk> ddarius: not sure i follow
20:30:37 <danharaj> edwardk: mm. I should start with reading Data.Constraint for sure.
20:32:04 <ddarius> edwardk: It just seems like there should be a more compositional way of defining functions like bothAgree.
20:32:31 <ddarius> Though I also agree with what you said earlier, that you can probably get a lot more of it inferred.
20:32:35 <zzo38> Is there a way of making a monad from any contravariant functor? I think I might have done so
20:33:20 <danharaj> how did you manage that.
20:33:29 <edwardk> zzo38: nope
20:34:26 <edwardk> f a -> a  might work under suitable conditions on a. thats basically escardo's monad
20:34:33 <edwardk> er i mean conditions on f
20:35:07 <edwardk> zzo38: you can however make a Monad from any Comonad, though ;)
20:35:46 <edwardk> ddarius: i pulled obOf and argOf out but it blows up trying to factor out resultOf, its fairly brittle
20:38:06 <edwardk> @hpaste
20:38:06 <lambdabot> Haskell pastebin: http://hpaste.org/
20:38:18 <danharaj> I'm getting a little confused. Is => a thing now? Like => :: Constraint -> * -> *?
20:38:33 <hpaste> edwardk pasted “categories, streamlined” at http://hpaste.org/57513
20:38:43 <edwardk> danharaj: pretty much
20:39:00 <rwbarton> does that actually work? :k (=>)
20:39:23 <edwardk> rwbarton: not in ghc
20:39:39 <edwardk> thats why i hedged with 'pretty much' ;)
20:39:55 <danharaj> so the only special thing about => is that it makes the dictionary visible, right?
20:39:56 <rwbarton> what about :k (~)?
20:40:14 <edwardk> rwbarton: that works it has a polymorphic kind
20:40:19 <edwardk> x -> x -> Constraint
20:40:33 <edwardk> you have to watch out the display of polykinds leaves something to be desired
20:40:56 <edwardk> danharaj: that and there is some funny parsing on the left to make (,) mean constraint product
20:41:04 <danharaj> hm
20:41:15 * ddarius will have to install 7.4 some time.
20:41:59 <edwardk> the rant at the bottom of my blog post is on a way to fix it, but right now ghc just monomorphizes some kinds so it can check if the kind is * or Constraint
20:42:20 <danharaj> hm
20:42:46 <danharaj> so what's the difference between (r -> s) and ((a => r) -> s) as type signatures?
20:43:36 <edwardk> (a => r) -> s   -- is that you have a function that takes a computation such that if the compiler knew 'a', it could give you an r.
20:43:37 <edwardk> and uses that to give you an s
20:44:01 <edwardk> foo :: (Ord Int => r) => r   -- can be written right now
20:44:04 <edwardk> foo r = r
20:44:15 <edwardk> the compiler will figure out ()   entails Ord Int
20:44:18 <edwardk> and just do it
20:44:33 <edwardk> because of the instance Ord Int it has lying around
20:44:40 <danharaj> ok
20:44:49 <danharaj> so I guess I'm confused because there's a lot of evidence being moved around behind the scenes
20:44:54 <edwardk> Ord a => (Eq a => r) -> r     can also be written
20:44:57 <edwardk> yep
20:45:07 <ddarius> :t let foo :: (Ord Int => r) => r; foo r = r in foo 3
20:45:07 <lambdabot> malformed class assertion
20:45:08 <edwardk> matching Dict brings evidence into scope
20:45:14 <ddarius> :t let foo :: (Ord Int => r) -> r; foo r = r in foo 3
20:45:15 <lambdabot> forall t. (Num t) => t
20:45:31 <ddarius> :t let foo :: (Ord Int => r) -> r; foo r = r in foo
20:45:32 <lambdabot> forall r. ((Ord Int) => r) -> r
20:45:42 <edwardk> matching Sub incurs an obligation, which hopefully is matched by other evidence, then matching Dict inside that uses that evidence to give you other evidence
20:46:06 <danharaj> hum
20:46:16 <danharaj> so I'll never give GHC a witness to the type (a => r)
20:46:24 <rwbarton> you could already bring evidence into scope with existentials/GADTs, but with ConstraintKinds you can abstract over the type class, so you don't need a separate unrelated type for each type class you want to wrap
20:46:28 <danharaj> it'll be doing stuff in the back to put it together
20:46:39 <edwardk> yeah, note lambdabot is running an ancient ghc
20:46:48 <edwardk> this => stuff has worked correctly for a long time
20:46:55 <danharaj> man that's confusing
20:47:09 <edwardk> but without polymorphic constraints its hard to build interesting usecases
20:47:14 <edwardk> before you could make
20:47:34 <edwardk> data Order a where Order :: Ord a => Order a
20:47:39 <edwardk> and pass around Order values
20:47:52 <edwardk> but you had to make data Equal a where Equal :: Eq a => Equal a
20:47:54 <edwardk> etc
20:47:59 <edwardk> now i can make Dict once and for all
20:48:55 <edwardk> and yeah, ghc is smart enough to spot when you have an 'a' and an obligation a => r     and to use the 'a' it has to discharge that obligation
20:49:10 <ddarius> data Context t a where Context :: Ctx t a => Context a; class Ctx t a; data ORD; instance Ord a => Ctx ORD a
20:49:24 <edwardk> but it isn't smart enough to do a few other things, like pass the only possible constraint as 'a' in other contexts.
20:49:28 <zzo38> I do like many of the GHC extensions but I hate some of them too. I don't like Haskell98 n+k patterns and recursive do-notation. But my own idea for -XNaturalNumberKind includes its own n+k patterns usable in type patterns, value patterns, and even in instance headings, but only for types of kind + and values of such types
20:49:40 <edwardk> which makes making a _really_ general version of 'on' not work
20:49:47 * cmccann was surprised by how the => is handled, like in this: http://hpaste.org/57385
20:50:01 <danharaj> So Dict is just a way to coax ghc into bringing into scope a constraint
20:50:04 <edwardk> ddarius: yeah, 'Sat'
20:50:12 <edwardk> danharaj: yep
20:50:18 <danharaj> ah ok now things are falling together
20:50:39 <edwardk> and a :- b is just my way of saying 'given a dictionary for 'a', i can build a Dict for 'b'
20:50:51 <edwardk> a => Dict b
20:51:03 <zzo38> One thing I don't know about other natural number kind proposal, but which my own idea include, is it makes the type for an array of a fixed number of elements very simple. Do you know if the other ones have that?
20:51:17 <cmccann> edwardk, btw, we found some amusing behavior from GHC the other day where it would reorder constraints and then fail to unify two types that should be identical
20:51:26 <danharaj> Do type classes get desugared to actual evidence passing?
20:51:38 <rwbarton> :t id :: (Ord a => a) -> (Ord a => a)
20:51:39 <lambdabot> forall a. (Ord a) => ((Ord a) => a) -> a
20:51:50 <zzo38> cmccann: Did you report that? Please fix it
20:51:56 <rwbarton> :t (id :: (Ord a => a) -> (Ord a => a)) x
20:51:57 <ddarius> cmccann: Do those other w's not type check, or do they not type check when used in showW?
20:51:57 <lambdabot> Expr
20:51:59 <rwbarton> oops
20:52:00 <cmccann> I thought shachaf was going to
20:52:05 <rwbarton> what was the example
20:52:15 <cmccann> ddarius, in showW
20:52:24 <ddarius> cmccann: Okay, then that all makes sense to me.
20:52:42 <rwbarton> > x < y
20:52:43 <lambdabot>   True
20:52:44 <cmccann> ddarius, it does make sense, just surprised me at first
20:52:56 <ddarius> > x > y
20:53:01 <lambdabot>   mueval-core: Time limit exceeded
20:53:03 <ddarius> > x > y
20:53:04 <lambdabot>   False
20:53:50 * ddarius needs to play his violin but not right now.
20:54:13 <ddarius> danharaj: In GHC, they do eventually.
20:54:27 <otters> > x
20:54:27 <edwardk> cmccann: thats a large part of why i built the constraint package
20:54:28 <lambdabot>   x
20:54:31 <otters> > y
20:54:32 <lambdabot>   y
20:54:34 <otters> what
20:54:37 <otters> > x > y
20:54:38 <lambdabot>   False
20:54:45 <ddarius> (One of the notable things about constructor classes versus type classes is that their desugaring requires higher rank types in general.)
20:54:48 <danharaj> ddarius: cool. So edwardk's code is getting our hands on that evidence and letting us control how it's produced and discharged?
20:54:52 <edwardk> cmccann: ghc uses unification to compare constraints, but really it would ideally use bi-entailment
20:55:02 <zzo38> Do you know if other natural number kind proposal can be subkind of the * kind, or not?
20:55:03 <ddarius> danharaj: The Dict stuff does that,yes.
20:55:07 <danharaj> ah ok
20:55:12 <danharaj> It's beginning to make sense.
20:55:18 <edwardk> danharaj: yes they do get desugared into dictionaries
20:55:32 <edwardk> you can see it by looking at core
20:55:43 <danharaj> Since basically the dict code is just rules for how to use evidence in a proof :p
20:55:48 <cmccann> edwardk, would at least be nice if it didn't break the unification because it moves things around
20:56:05 <ddarius> ACI unification ho!
20:56:13 <edwardk> cmccann: yeah, constraints lets me at least manually weaken and shuffle the constraints into position to discharge obligations
20:56:27 <edwardk> (p,q) :- p    etc
20:56:42 <edwardk> then you can use \\ to apply it
20:56:43 <danharaj> wait does the unification algorithm really require things in a certain order :3
20:57:03 <cmccann> edwardk, not even talking about discharging, I mean (Ord a => a) -> (Ord a => a) failing to unify with (b -> b)
20:57:05 <edwardk> danharaj: unification doesn't really see anything special about something of kind Constraint
20:57:30 <edwardk> ah that
20:57:44 <danharaj> so it doesn't get that (a, b) => r is equivalent to (b, a) => r?
20:58:22 <edwardk> danharaj: correct
20:58:31 <danharaj> there's too many sorts of variables gah
20:58:36 <danharaj> The English alphabet is only so big.
20:58:46 <ddarius> Apparently we have the BOX sort now.
20:58:47 <cmccann> danharaj, that's why god invented unicode
20:58:48 <edwardk> you can make swap :: (p,q) :- (q,p)   swap = Sub Dict
20:58:57 <edwardk> and then use that to 'help' discharge the obligation
20:59:08 <danharaj> I propose we use English for value variables, greek for type variables, and cyrillic for kind variables
20:59:19 <chipdude> cmccann: yet another reason to believe that God exists, and he hates us
20:59:23 <danharaj> or Fraktur
20:59:27 <ddarius> Associative, commutative, idempotent unification (i.e. treating contexts as sets of constraints) is what we'd want, but that is undecidable.
20:59:36 <codibblego> is there a library out there to force the spine of a list?
20:59:43 <edwardk> danharaj: i object on the grounds that fraktur and cyrillic would drive me to drink
20:59:59 <danharaj> edwardk: I went three years thinking Fraktur A was a U :3
21:00:05 <ddarius> chipdude: That one is -explicitly- due to God (at least in the Judeo-Christian world-view.)
21:00:20 <edwardk> codibblego: can't you do that with strategies?
21:00:36 <codibblego> yeah I guess I could
21:00:41 <danharaj> ddarius: It seems surprising that it's undecidable for constraints. I didn't think it would be that complicated.
21:00:58 <edwardk> danharaj: surprise!
21:01:08 <danharaj> I don't want to live in this universe anymore.
21:01:19 <danharaj> I want to live in one where the turing problem is solvable.
21:01:26 <danharaj> and all human thought becomes trivialized.
21:01:31 <edwardk> meh, the one above is too empty, and the one below is too crowded. you're stuck here
21:01:55 * cmccann should start using fraktur for identifiers in his code
21:01:57 <danharaj> Sometimes I think it's strange that we live in the most mathematically interesting spot on the hierarchy.
21:02:12 <danharaj> (or maybe everything above looks uninteresting because it's too interesting)
21:07:31 <edwardk> universe blub paradox
21:07:44 <edwardk> http://c2.com/cgi/wiki?BlubParadox
21:08:59 <otters> :t (>>=) []
21:09:00 <lambdabot> forall a b. (a -> [b]) -> [b]
21:09:08 <otters> :t flip (concatMap) []
21:09:09 <lambdabot> forall a b. (a -> [b]) -> [b]
21:09:14 <otters> ooo
21:17:30 <edwardk> trying to figure out how to tuple up the two type arguments to Cat in my category fragment so i can have one type to pass around
21:17:51 <edwardk> i can't just use '(a,b) because i need to be able to unpack it and use it without brain surgery
21:18:24 <edwardk> otherwise the constraints here will have cut off the ability to readily define the category Cat itself.
21:20:13 <sunaku> what's the haskell equivalent of C's __FILE__ macro?  i want to programatically know the path to the current haskell file while inside it
21:20:39 <edwardk> sunaku: you can use {-# LANGUAGE CPP #-} and just use C's __FILE__ macro ;)
21:21:04 <edwardk> you can also spend a couple of hours fiddling with template haskell
21:21:32 <sunaku> thanks
21:22:32 <edwardk> gah
21:22:50 <edwardk> because of the parsing hack there isn't a way for me to make ((,)a) a functor in the category :-
21:23:00 <danharaj> man you are really mad about that hack :p
21:23:05 <danharaj> or at least vexed
21:23:09 <edwardk> well
21:23:56 <edwardk> heh, well, to be honest, in our little language at clarifi, we actually implemented it the same way ;)
21:24:13 <edwardk> so i don't have much of a leg to stand on ;)
21:24:49 <danharaj> poor (,)
21:24:51 <edwardk> but then we also have a syntax for talking about the thing thats biting me now
21:24:53 <danharaj> overloaded to work on three different sorts
21:24:58 * hackagebot pandoc-types 1.9.0.2 - Types for representing a structured document  http://hackage.haskell.org/package/pandoc-types-1.9.0.2 (JohnMacFarlane)
21:25:18 <edwardk> and our 'ultra liberal type synonyms' would let us define it even so
21:25:46 <Cale> edwardk: what parsing hack are you referring to?
21:26:25 <edwardk> (p,q)  at the type level parses as either a single type of kind * or as a list of constraints, which gets turned into a Constraint depending on context.
21:26:54 <Cale> ah
21:27:13 <edwardk> now that we have constraint kinds, this shows through a lot more
21:27:13 <Cale> Do explicit kind annotations not help?
21:27:16 <edwardk> no
21:27:27 <edwardk> i can't write explicit kind annotations for anything i want to talk about any more
21:27:37 <edwardk> since polymorphic kinds don't have a parseable representation right now
21:27:44 <Cale> hrm
21:27:52 <danharaj> when are we getting kind classes >.>
21:28:09 <edwardk> so i get to play with all sorts of early-oleg-esque asFooOf :: x y z a -> f a -> x y z a; asFooOf = const hacks rather than type/kind annotations ;)
21:28:20 <Cale> I've found that polymorphic kinds are broken in conjunction with scoped type variables, which make them unusable in most of our code
21:28:31 <edwardk> ?
21:28:36 <edwardk> how so?
21:28:42 <Cale> http://hackage.haskell.org/trac/ghc/ticket/5717
21:28:54 <Cale> (and related tickets)
21:29:05 <Cale> Basically you just get a panic :P
21:29:06 <edwardk> ah
21:29:27 <edwardk> yeah
21:29:35 <edwardk> that'll probably keep me from using them in anger as well
21:29:53 <danharaj> man how many hacker cred points is getting a compiler to panic nowadays.
21:29:59 <Cale> But not only that, kind inference is broken when PolyKinds is turned off now
21:30:08 <edwardk> for now i just use the asFooOf approach to avoid using ScopedTypeVariables
21:30:14 <Cale> So, you have to explicitly kind lots of stuff
21:30:17 <edwardk> yep
21:30:30 <Cale> Almost any of the parameters to datatypes which don't have kind *
21:30:35 <Cale> Or at least phantoms...
21:30:38 <edwardk> i was joking with byorgey that our compiler at clarifi now does better kind inference than ghc ;)
21:31:09 <edwardk> sadly, i suppose that isn't actually a joke
21:31:24 <codibblego> feel free to open-source it so that we may also indulge in the joke
21:31:38 <Cale> But constraint kinds are good to have anyway, I think.
21:31:43 <edwardk> codibblego: i'll work on it. ;) not holding my breath
21:31:52 <Cale> Well, I haven't completely got this all working yet using them :)
21:32:38 <edwardk> codibblego: that said, its funny, because we didn't actually bother implementing type classes yet.
21:33:34 <Cale> edwardk: I ran into a problem shortly before updating with 7.2 wherein GHC was inferring a bunch of types for things without generalising over all the type variables. So there were a bunch of top level things which didn't have explicit type signatures which were being ascribed types that would never unify with anything.
21:33:58 <edwardk> interesting
21:34:30 <Cale> Giving them explicit type signatures solved the problem, but it took a long time to work out that's what it was
21:34:30 <jetru> When I use shuffle from Data.Random.RVar on a list, it gives me a Data.Random.RVar.RVarT Data.Functor.Identity.Identity [Int]. Anyway I can pull out the actual shuffled list?
21:34:35 <edwardk> *nods*
21:34:41 <danharaj> shouldn't there be a suite of tests to make sure inference regressions don't happen like that?
21:35:07 <KuntSlime> I want to drink Barack Obama's diarrhea!
21:35:11 <KuntSlime> What would it taste like?
21:35:15 <danharaj> @ops
21:35:15 <lambdabot> Maybe you meant: docs oeis pl
21:35:24 <KuntSlime> My fantasy is to have a powerful man spray his liquid poo down my gullet!
21:35:38 <KuntSlime> Should I wait until he has eated corn on the cob from the night before?
21:35:39 <otters> hmm...
21:35:44 <KuntSlime> What flavor should I expect?
21:36:09 --- mode: ChanServ set +o codibblego
21:36:13 <KuntSlime> Does Barack Obama eat a lot of fried chicken?
21:36:14 --- kick: KuntSlime was kicked by codibblego (KuntSlime)
21:36:19 <KuntSlime> would that affect the flavor of the diarrhea?
21:36:20 --- mode: codibblego set +b *!*RandyJan@*.ws
21:36:23 --- kick: KuntSlime was kicked by codibblego (KuntSlime)
21:36:50 <danharaj> Every community on occassion gets a glimpse at eternal september.
21:36:57 <edwardk> hah
21:37:58 <edwardk> i explained eternal september to my wife the other day -- it started more or less the day she got on the internet. ;)
21:38:14 <dolio> Heh.
21:38:19 <edwardk> (she literally did get on the internet in september 1993)
21:38:27 <danharaj> heh
21:38:30 <dolio> So she was part of the problem.
21:38:33 <edwardk> yep
21:38:40 <danharaj> She was part of the first wave.
21:38:49 <edwardk> didn't grok usenet at the time, etc. all the stereotypes
21:38:55 <dolio> That may have been around the time I started, too.
21:39:11 <dolio> Although my early internet activities were limited to playing Diablo, I think.
21:39:11 <otters> heh, usenet
21:39:16 <edwardk> still has no idea who kibo is, etc.
21:39:16 <ddarius> danharaj: You get no credit for panicking the compiler on a feature just added.
21:39:19 <otters> eternal september started before I was born
21:39:30 <danharaj> ddarius: aww.
21:39:39 <dolio> Oh, apparently Diablo was 1996, so that's way late.
21:40:05 <danharaj> I think my first september was '98
21:42:03 <lispy> dolio: heh, we must be around the same age.
21:42:48 <lispy> I got on the internet access at home when I was 17, in 1997.
21:43:02 <edwardk> i remember trying to keep up with the deluge of usenet postings. such a badly designed protocol! we finally outsourced and then killed our usenet service entirely somewhere around 98.
21:43:02 <otters> ahh, usenet
21:43:11 <edwardk> maybe 99
21:43:12 <dolio> You're a couple years older, then.
21:43:32 <edwardk> we dropped binaries and that bought a couple of years there at the end
21:44:10 <edwardk> it was something like 4/5ths of our bandwidth right before we killed binaries
21:44:34 <lispy> dolio: Hmm...I still get carded at the store though, so I won't take that the wrong way ;)
21:44:59 <companion_cube> at my school we have internal newsgroups, and it's pretty cool compared to the usual mailing lists
21:45:21 <Cale> I wonder if anyone has an archive of every post Kibo ever made.
21:45:30 --- mode: codibblego set -o codibblego
21:45:37 <chipdude> Usenet will be the seed of the underground.  Again.
21:45:55 <Triplefox> kibo, that brings me back.
21:45:59 <lispy> It's interesting how all the collaborative forums suck until they get a certain number of users and then suck again when they exceed some other number of users.  Haskell-Cafe and subreddits all exibit this.
21:46:23 <lispy> exhibit*
21:46:48 * ddarius buys several hundred shotgun shells and sets out on a quest to get #haskell to "the way it was."
21:46:55 <edwardk> i discovered the internet somewhat obliquely, compuserve, bunch of boards with fidonet feeds that somehow tossed data over another kind of network, learned about frame relay from a friend, and then found out that merit, which ran the dialup network for the universities in the michigan area had open dialup numbers, discovered slip and ka9q, etc
21:47:02 <dolio> Your knife isn't good enough?
21:47:09 <otters> I played a lot of Neopets
21:47:15 <ddarius> dolio: Knives are tools.
21:47:46 <edwardk> cale: all you have to do is grep through old usenet feeds for kibo, but that kind of kibozing seems a bit meta
21:47:49 * ddarius was connecting to a few BBSes in the early '90s possibly the late 80's.
21:47:57 <companion_cube> ddarius: what? #haskell is stateful?
21:49:18 <ddarius> When I joined #haskell, the high-water mark was around 30.
21:50:09 <lispy> ddarius: wow, really? I think I join circa 2004 or 2005.  I was a recovering #lisp person.
21:50:22 <lispy> all I can say about #lisp is ... venomous.
21:50:28 <ivanm> lispy: like we couldn't tell *that* :p
21:50:36 * cmccann has only been in here for like two years at most... :[
21:50:46 <lispy> Well, my nick is techincally short for lispservice, which was my original nick.
21:51:06 <edwardk> i was as obsessive about BBSs and BBSing as i am about everything else
21:51:14 <companion_cube> ddarius: so, what about #agda? mustn't be that crowded...
21:51:23 <edwardk> kinda sad in retrospect
21:51:32 <lispy> edwardk: your obsession should be reveled.
21:51:49 <ddarius> companion_cube: Agda requires me to use emacs.
21:51:54 <ddarius> (Not completely true.)
21:51:55 <companion_cube> oh
21:52:09 <dolio> Nah, it pretty much does.
21:52:30 <edwardk> somewhere out there are a bunch of old BBS doors with my name on them, a whole BBS implementation named "The Keep/Psychosis", and a fossil driver i wrote that let old dos bbs's run over telnet on the internet
21:52:40 <ddarius> Wasn't Ashley Yakely or someone with a name starting with 'A' using it with vim for a long time (and still?)
21:52:43 <edwardk> oh, and a fidonet clone named fishnet
21:53:08 <dolio> There are a couple people currently using it with Vim, I think.
21:53:21 <dolio> But it's a far inferior experience.
21:53:25 <edwardk> using it with vim is why i quit using it ;)
21:54:19 <ddarius> I pre-emptively quit.  Anyway, all I'd do is write yet another CT library.
21:54:45 <edwardk> i don't have to. fortunately, copumpkin and company have started the CT library to end all CT libraries ;)
21:54:54 <edwardk> well
21:54:58 * hackagebot cookie 0.4.0 - HTTP cookie parsing and rendering  http://hackage.haskell.org/package/cookie-0.4.0 (MichaelSnoyman)
21:55:00 * hackagebot wai-test 1.1.0.1 - Unit test framework (built on HUnit) for WAI applications.  http://hackage.haskell.org/package/wai-test-1.1.0.1 (MichaelSnoyman)
21:55:04 <edwardk> at least, the one that seems to be getting somewhere
21:55:09 <lispy> glguy had some good criticisizms of agda the other day.  He was explaining that termination proof is quite draining and that the proofs of these sort of 'abstract' properties get intertwined in your algorithm and really detract from the presentation and the run-time properties.
21:55:10 <dolio> You just have to rewrite it poorly in Haskell. :)
21:55:18 <edwardk> it'd still be kinda nice to have one that built a few more powerful primitives
21:55:24 <edwardk> i'm good at rewriting things poorly
21:55:25 <ddarius> edwardk: Is it getting somewhere?
21:55:45 <edwardk> oh crap. thats going up on the whiteboard at work isn't it?
21:55:57 <dolio> It should.
21:56:02 <ddarius> lispy: Yes.  These are well known things.  This is, in part, why monochrom favors separate specification languages.
21:56:04 <dolio> I'll probably forget.
21:56:23 <lispy> ddarius: example of a separate specification language?  Isabelle?
21:56:40 <companion_cube> ATS!
21:56:57 <ddarius> PVS, Z, etc., etc.  There are tons of tools for "formal methods" besides dependently typed programming languages.
21:57:07 * lispy recalls that one of the first things I ever asked in #haskell was about writing, "Hello, World!" and dons responded with a lambdabot example
21:58:12 <lispy> ddarius: I know there are lots of crappy FM tools, but I was wondering which ones qualify as 'separate specificiton languages' to you.   I mean, would you consider coq's set/prop distinction?
21:58:29 <ivanm> codibblego: can you block that guy in -blah now please? (assuming the ops are the same...)
21:58:36 <lispy> (I should probably not call them crappy, but a good FM tool is quite hard.  Do we have any?)
21:58:36 <otters> > print "Hello, world!"
21:58:37 <lambdabot>   <IO ()>
21:58:41 <otters> :t print
21:58:42 <lambdabot> forall a. (Show a) => a -> IO ()
21:58:51 <otters> :t putStrLn
21:58:52 <lambdabot> String -> IO ()
21:58:56 <otters> hm
21:59:01 <ivanm> lispy: why do you want a radio tool? :p
21:59:22 <yitz> i'm shocked that no one has mentioned BITNET and usenet
21:59:27 <lispy> ivanm: Well, it's not like I asked about AM tools.
21:59:38 <companion_cube> lispy: don't spit on PVS, it's in lisp :]
21:59:40 <yitz> and gopher
22:00:04 <lispy> companion_cube: ACL^2 scares the hell out of me, FWIW
22:00:13 <lispy> companion_cube: and that's all in lisp
22:00:40 <companion_cube> yeah, ACL2 looks like all automated deduction technologies put together
22:01:19 <ddarius> So where (in the greater Boston area) can I get a platform to rant at impressionable mathematics, physics, and engineering students (and others interested in such subjects?)
22:01:45 --- mode: ChanServ set +o codibblego
22:01:46 <edwardk> boston haskell
22:01:50 <edwardk> functional programming works
22:01:50 --- mode: codibblego set -o codibblego
22:01:52 <dolio> I'm sure MIT has something along those lines.
22:01:54 <edwardk> oh wait
22:02:04 <codibblego> ivanm: I'm not
22:02:10 <ivanm> codibblego: damn
22:02:12 <otters> boston haskell!
22:02:17 <ivanm> looks like he's shut up anyway
22:02:27 <edwardk> you can usually run into a couple of people at boston haskell who teach physics at least
22:02:28 * otters wants to go to MIT
22:02:28 <companion_cube> why not have lambdabot being an admin?
22:02:39 <edwardk> perhaps they'd be better informed and able to answer
22:02:40 <lispy> typically ignoring a troll causes them to gtfo.
22:02:57 <ddarius> MIT lives up to its name.  It's very ... institutional...
22:02:58 <companion_cube> and have it ask a haskell question before it actually kicks/bans who we tell her to
22:03:08 <edwardk> in fact at least one of them is fond of ranting at physics and engineering students about how they should teach physics and engineering
22:03:09 <otters> ddarius: what's that?
22:03:29 <ddarius> edwardk: These rants would not be at all Haskell related.
22:03:40 <george2-> long shot… has anyone used 0mq in real world haskell apps?
22:03:48 <lispy> ddarius: if you want to give a talk, come to galois and give us some interesting talk.  We can film it and put it up on vimeo for the world to see :)
22:04:25 <companion_cube> lispy: aren't you supposed to be frozen for the winter, at Galois'?
22:04:42 <yitz> george2-: what is 0mq? (I guess you will view that question as a bad omen.)
22:04:50 <lispy> companion_cube: Sorry, I don't get the reference.  Please explain.
22:04:57 <ddarius> @hackage ZeroMQ
22:04:57 <lambdabot> http://hackage.haskell.org/package/ZeroMQ
22:04:59 <edwardk> well, come give a talk at boston haskell about something haskell related and use that to lure the physics/teaching types out of the woodwork ;)
22:05:00 <companion_cube> it's in a cold place, isn't it?
22:05:12 <lispy> companion_cube: portland?
22:05:40 <ddarius> @hackage zeromq-haskell
22:05:40 <lambdabot> http://hackage.haskell.org/package/zeromq-haskell
22:05:45 <companion_cube> yes
22:06:00 <companion_cube> http://www.zeromq.org/ yitz
22:06:02 <george2-> not a bad omen - just curious.  I'm reading about haskell tonight, and my next project involves 0mq to reach lots of systems at the same time
22:06:11 <lispy> companion_cube: today the high was like 50-60 degs F
22:06:30 <george2-> yes, I googled, but first hand experience is often better
22:06:33 <lispy> companion_cube: we had a touch of snow in Jan, but it's quite mild here other than rain.
22:06:49 <companion_cube> ok, never mind then :)
22:06:54 <dolio> That's twice as many degrees as we have here right now.
22:07:09 <ddarius> It's been pretty mild and warm here too.
22:07:15 <ddarius> Not like last year.
22:07:23 <lispy> You guys got screwed last year :(
22:07:26 <dolio> Yeah. Mid 40s or something?
22:07:34 <dolio> It's pretty nice.
22:08:03 <yitz> oh ok
22:08:03 <lispy> ddarius: I'm serious about giving a talk.  We like to have speakers and I bet you could give an interesting talk.  I'm just not sure about funding it...
22:08:16 <yitz> lower level than something like dbus?
22:08:28 <otters> is boston nice?
22:08:33 <ddarius> otters: No.
22:08:38 <otters> alright
22:08:51 <yitz> otters: a lot of people like boston.
22:08:53 <companion_cube> yitz: it's also distributed, unlike dbus
22:08:57 <ivanm> it's in the USA, how can it be nice? :p
22:09:12 <companion_cube> trollolol
22:09:19 <yitz> companion_cube: ah ok tnx
22:09:26 <otters> stfu
22:09:37 <otters> yeah no but really my final destination is norway
22:09:39 <hpaste> Cain pasted “SPOJ Fashion” at http://hpaste.org/57514
22:09:44 <Cain_> Hey, i'm trying to do a simple SPOJ problem in haskell, but i'm getting a TLE, thought you nice peolpe might be able to give me some feedback (here's the problem: http://www.spoj.pl/problems/FASHION/)
22:09:53 <ddarius> lispy: I could fund getting there and staying for a bit.  I could probably even get my employer to at least partially fund it.  If I were going to give a talk about the things I want to talk about, I'd like to have a few rounds through before presenting it at Galois.
22:10:24 <ddarius> (Actually, my employer would probably leap at the opportunity to fund that.)
22:11:03 <lispy> ddarius: Awesome. Well, I love to have you give a talk. So let me know as you refine it.
22:11:38 <yitz> ddarius: can you tell us where you work?
22:11:53 <yitz> sounds great
22:13:47 <ddarius> I work at a small and fairly young contracting/consulting firm called Now Business Intelligence.
22:14:01 <ddarius> My employer is extremely awesome.
22:14:50 * lispy wouldn't expect any less
22:15:08 <ddarius> Our last business meeting started with him showing off some 100lb thrust pulse jets he'd just bought.
22:16:35 <yitz> ddarius: hah sounds great. my employer doesn't buy any pulse jets. we have to work hard to stay profitable.
22:17:02 <yitz> ddarius: but there are great people, and it is awesome that haskell has become pretty mainstream here.
22:17:16 <lispy> if staying profitable isn't hard, your employer is lying to you, IMHO
22:17:26 <lispy> yitz: where are you?
22:19:06 <yitz> suite solutions. we do xml-based technology for enterprise documentation departments.
22:19:35 <lispy> yitz: oh! I'm trying to build a library for writing office formats (excel at the moment) any interest?
22:20:36 <yitz> lispy: yes, that's interesting. not what we usually do - but definitely related and interesting. we'd love to have a haskell library like that.
22:20:41 <ddarius> lispy: Are you doing this within a Microsoft context, or outside of one?
22:20:55 <lispy> ddarius: Pure Haskell.
22:21:19 <ddarius> lispy: Well, the good news is writing Excel (and other OpenXML formats) probably isn't too bad.
22:21:39 <lispy> ddarius: I've been doing it by hand for a subset of Excel, but I'd like to generalize and make tool that reads in the published xsd files and generates the read/show code and some basic datatypes.
22:22:30 <ddarius> I've considered making a Haskell library/EDSL for abstracting some RDL generation.
22:23:37 <ddarius> (Why didn't they just use CSS?)
22:24:30 <lispy> yitz: I have your email via the haskell-infrastructure mailing list.  Is that the best way to contact you?
22:24:54 <yitz> lispy: sure that's great
22:26:22 <lispy> yitz: okay.  I'll make sure to CC you when I announce stuff.
22:27:44 <yitz> lispy: thanks!
22:27:56 <lispy> yitz: nah, thank you!
22:39:59 * hackagebot pandoc 1.9 - Conversion between markup formats  http://hackage.haskell.org/package/pandoc-1.9 (JohnMacFarlane)
22:40:21 <lispy> JohnMacFarlane++
22:46:24 <MaskRay_> Cain_: you may use bytestring to speed the io
22:47:10 <lispy> It's down right amazing how much bytestring helps when used correctly
22:47:19 <Cain_> i'll look that up, thanks
22:47:23 <lispy> It's not surprising, but it is amazing
22:49:26 <lispy> and don't forget about data.text (which is to be used when unicode is a possibility)
22:50:00 <Jafet> Suddenly, unicode
22:50:54 <lispy> Jafet: :)
22:54:59 * hackagebot pandoc 1.9.0.2 - Conversion between markup formats  http://hackage.haskell.org/package/pandoc-1.9.0.2 (JohnMacFarlane)
23:00:20 <MaskRay_> Cain_: http://hpaste.org/57515
23:02:25 <nejucomo> What's the state of Haskell crypto?  Is crypto-api "standard"?  Are there implementations that meet the crypto-api interface for ecdsa?  Is there a good resource to answer questions like this?
23:02:49 <Cain_> MaskRay_, thanks... mind if i ask a few questions about that?
23:03:00 <Cain_> mainly, what is the ! mean in the line
23:03:03 <Cain_> !xs <- ...
23:03:05 <ivanm> nejucomo: I believe crypto-api _is_ the standard
23:03:10 <ivanm> Cain_: it's a bang pattern
23:03:17 <ivanm> an extension
23:03:21 <ivanm> it's equivalent to using seq
23:04:32 <Cain_> oh, ok
23:04:59 * hackagebot hack 2012.2.6 - a Haskell Webserver Interface  http://hackage.haskell.org/package/hack-2012.2.6 (AlbertoCorona)
23:05:07 <MaskRay_> Cain_: of course not
23:05:56 <ivanm> yay, more packages using date-based versioning :s
23:06:11 <Cain_> MaskRay_, what does state do?
23:07:32 <MaskRay_> Cain_: `state' builds a State monad from (s -> (a, s))
23:08:10 <edwardk> state actions take an initial state 's' and yield an answer 'a' and a new state
23:08:21 <nejucomo> Can I search hoogle for "packages which depend on package X"?
23:08:31 <nejucomo> (-or with cabal)
23:08:32 <edwardk> no but there is a revdeps hackage server
23:08:44 <MaskRay_> Cain_: which is by chance the return value of B.readInt if omitting the `Maybe'
23:10:18 <ivanm> nejucomo: packdeps
23:10:21 <ivanm> @google packdeps
23:10:23 <lambdabot> http://hackage.haskell.org/package/packdeps-0.1.0.1
23:10:23 <lambdabot> Title: HackageDB: packdeps-0.1.0.1
23:10:33 <ivanm> I think it's on haskellers.com
23:10:43 <ivanm> edwardk: that hasn't been up for a while IIRC
23:10:52 <edwardk> ah
23:11:08 <ivanm> revdeps.hackage.haskell.org is where it was I think
23:11:24 <ivanm> nejucomo: http://packdeps.haskellers.com/reverse
23:13:09 <Cain_> Oh, ok. So does zipWith just work on the "insides"? I'm not quite getting how we can treat xs/ys as normal, if you get what i mean
23:14:17 * Axman6 has no idea
23:14:35 <edwardk> ivanm: yeah thats the url, didn't know it was dead though
23:15:04 <ivanm> I know it was dead because I wanted to use it, and it didn't work :s
23:15:33 <MaskRay_> i forgot to sort the two lists
23:16:06 <shachaf> cmccann: OK, OK, I'll report it.
23:16:13 <Cain_> The problem itself isn't exactly clear on that requirement, so if you were going by that, i don't blame you :P
23:17:28 <MaskRay_> edwardk: i seemed to misuse the concept monad, is it more accurate to say `actions' ?
23:18:00 <edwardk> well the monad itself is the functor and the two operations you can perform.
23:18:25 <edwardk> action is also a bit of a mislabeling, but since a lot of people come at monads through IO i tend to use that term when i first introduce the concepts
23:20:37 <MaskRay_> Cain_: there's still some gotcha that spoj uses ghc 6.10 which doesn't provide the function `state'
23:21:00 <MaskRay_> Cain_: and the type of State is a bit different
23:21:41 <Cain_> do you mean different from what it is in the latest version of ghc?
23:21:52 <jetru> I have some code like this: http://pastebin.com/YiF9DnDY
23:21:55 <mauke> The paste YiF9DnDY has been copied to http://hpaste.org/57516
23:22:12 <MaskRay_> simply replacing 'state' with 'State' should compile on spoj
23:22:31 <jetru> How do I make it work right? I want to convert the IO [Int] to a regular [Int]
23:23:00 <koala_man> is there a term for what 'guard' does? could you call it a "monadic guard" or something?
23:23:20 <shachaf> jetru: You can't do that. The former doesn't contain the latter.
23:23:38 <shachaf> koala_man: I think "guard" is a term for what "guard" does.
23:23:58 <jetru> shachaf: by can't meaning, it's impossible. Or I need to do it some other way?
23:23:59 <shachaf> "monadic" is a bit misleading anyway because it's really a MonadZero (except it's really a MonadPlus).
23:24:00 <MaskRay_> edwardk: then how to speak `State s a' in the most pedantically way?
23:24:08 <shachaf> jetru: Both. :-)
23:24:45 <koala_man> shachaf: but to separate 'guard' from guards in function definitions?
23:24:59 <shachaf> koala_man: Write it in a monospace font.
23:25:24 <shachaf> jetru: You can write something like main = do { result <- (something :: IO [Int]); ... result ... }
23:25:37 <shachaf> jetru: But you should really read an introduction to how IO works in Haskell.
23:25:53 <shachaf> @google introduction to how IO works in Haskell
23:25:55 <lambdabot> http://www.haskell.org/haskellwiki/Introduction_to_IO
23:25:55 <lambdabot> Title: Introduction to IO - HaskellWiki
23:25:56 <jetru> shachaf: I'm reading them. It's slightly mindfuck. :(
23:26:17 <edwardk> probably the best way to refer to it is as a 'monadic value'
23:26:25 <shachaf> jetru: I like "getLine :: IO String contains a String in the same way that /bin/ls contains a list of files"
23:26:43 <koala_man> shachaf: then it's just referring to the function that does it, not the thing it does
23:26:57 <edwardk> shachaf++
23:27:40 <ivanm> @remember shachaf getLine :: IO String contains a String in the same way that /bin/ls contains a list of files
23:27:41 <lambdabot> Good to know.
23:29:20 <lispy> that is good
23:29:23 <jetru> shachaf: So, every IO functions needs to be connected to main somehow?
23:29:39 <lispy> jetru: we're lazy.  main demands them.
23:29:54 <ivanm> jetru: main is the actual running point of the program
23:29:58 <shachaf> jetru: Eventually, yes. In the same way that anything that happens in a C program needs to be connected to main somehow. :-)
23:30:12 <ivanm> so anything you actually want used has to get somehow hooked up to main at some point, either directly or transitively
23:30:16 <shachaf> lispy: This doesn't really have anything to do with laziness. It could work the exact same way in a pure strict language.
23:30:29 <zomg> Or you can use unsafePerformIO!
23:30:36 <zomg> And then a kitten dies
23:30:37 <zomg> er
23:30:51 <edwardk> i lose more kittens that way
23:30:52 <ivanm> zomg: how does that help you run things not found via main? :p
23:31:00 <zomg> ivanm: true, maybe it doesn't :P
23:31:02 <merijn> edwardk: You would >.>
23:31:04 <ivanm> besides, kittens are delicious!
23:31:06 <jetru> Wow. that looks awesome zomg.
23:31:19 <ivanm> jetru: you don't want to use unsafePerformIO
23:31:19 <merijn> jetru: ...
23:31:20 <lispy> shachaf: but, we work backwards from main, no?
23:31:24 <zomg> jetru: really, don't use it. It's unsafe for a reason :D
23:31:28 <edwardk> jetru: you don't want to use unsafePerformIO
23:31:32 <shachaf> jetru: You don't have to run the IO action *in* main, of course. You can construct an IO action that runs the IO action that runs the IO action or something.
23:31:42 <ivanm> if you use it, then the non-existent Haskell Cabal comes and shoots you in a dark alley some night
23:31:43 <shachaf> jetru: Yes, don't use unsafePerformIO.
23:31:57 * ivanm glares at zomg 
23:31:59 <edwardk> it sounds like a good idea, its tempting, it makes life easy, for the first 2 lines of code. then you go to write the third and everything goes to shit
23:32:12 <merijn> jetru: Much like floating points, unsafePerformIO seems a good idea. Until you spend 5 weeks debugging something only to find out that you thought you understood it, but actually didn't...
23:32:25 <ivanm> @remember edwardk [unsafePerformIO] sounds like a good idea, its tempting, it makes life easy, for the first 2 lines of code. then you go to write the third and everything goes to shit
23:32:25 <lambdabot> It is forever etched in my memory.
23:32:26 <edwardk> in general by the time you need to use unsafePerformIO you will know why you shouldn't be using it ;)
23:32:27 <shachaf> lispy: Backwards from main?
23:32:45 <agocorona> Hi, do you know if hackage, when a package is added, compiles also the dependent packages?
23:32:49 <lispy> shachaf: yeah, main demands a value and thus begins the thunk chasing
23:33:09 <ivanm> agocorona: it does to try and build it
23:33:19 <ivanm> sometimes that causes errors in inconsistencies in deps, etc.
23:33:26 <edwardk> I've been writing haskell for years. I'm even adequately good at it. I still spent 2 months writing a library that turned out to be useless because I thought I could get away with an unsafePerformIO that was in the end subtly unjustified
23:33:32 <shachaf> lispy: Even if the language was strict you could have IO work in the exact same way.
23:33:42 <lispy> agocorona: I wouldn't worry too much about whether hackage can build your package. Sadly, it is unable to build many things that build fine for people in practice.
23:34:00 <Sgeo> unamb uses unsafePerformIO, right?
23:34:20 <edwardk> sgeo: yes
23:34:34 <lispy> shachaf: perhaps I should shutup. I didn't see the origin of the discussion.
23:34:38 <shachaf> edwardk: What library was that?
23:34:42 <edwardk> sgeo: and if you've ever watched a program that abuses it spin steadily out of control you know how much of a bad idea it is ;)
23:34:56 <Sgeo> ...unamb can break stuff?
23:35:00 <edwardk> shachaf: intern. the version that is up now is at least sound
23:35:03 <agocorona> ivanm: so hackage tries to recompile all dependent packages?
23:35:07 <Sgeo> (I mean, other than using unamb wrongly)
23:35:08 <ivanm> agocorona: yes
23:35:13 <edwardk> sgeo: it starts a lot of threads
23:35:25 <agocorona> ivanm : fine
23:35:26 <ivanm> agocorona: some errors come about from that because it sometimes tries to build using newer versions of boot libs
23:35:28 <Sgeo> ...I thought threads were lightweight
23:35:32 <shachaf> lispy: All I'm saying is that IO is done the way it is in Haskell because the language is pure, not because it's non-strict.
23:35:34 <lispy> It's hard to give a semantics to amb
23:35:38 <edwardk> sgeo: and for a while it was using my tag-bits stuff in a way that didn't out so well
23:35:53 <lispy> I have a PhD disseration on my desk at work that does just that
23:36:17 <edwardk> anything that can lead to exponential explosions in possible code paths all being explored simultaneously is probably not a good idea
23:36:27 <edwardk> used in moderation unamb can be 'okay'.
23:36:28 <augur> hey edwardk
23:36:39 <edwardk> but unambing code tends to nest them
23:37:28 <edwardk> one of the guys at work went out of his way to build a nice IO monad for scala
23:40:01 <chairdog> i have some old ubuntu installs that presently have ghc 6.12 and 7.0 on them. I'd like to play with ghc 7.4 (specifically the safe haskell stuff from there). Whats the best way to go about that? compile my own ghc7.4?
23:41:11 <lispy> chairdog: yes
23:41:20 <ivanm> it's not that hard
23:41:25 <ivanm> someone even did a blog post on the topic recently
23:41:29 <lispy> chairdog: compiling ghc is easy in terms of commands typed
23:41:41 <jutaro> chairdog: why not use the linux binary, that safes you some time
23:42:00 <lispy> chairdog: something like, get the .bz2, ./configure --prefix=$HOME; make; make install
23:42:22 <chairdog> jutaro: this one? http://www.haskell.org/ghc/dist/7.4.1/ghc-7.4.1-i386-unknown-linux.tar.bz2
23:42:27 <ivanm> jutaro: issues in version of gmp could be a problem
23:42:31 <lispy> chairdog: sure
23:42:33 <ivanm> chairdog: that's the one
23:43:11 <chairdog> ok. wary of binary downloads because of library dependecy stuff that always caused me trouble before... I'll try that before compiling though
23:43:22 <lispy> chairdog: it takes a while to compile and I don't know if Safe is the default.  But the commands you need to know are dead simple.
23:43:30 <jutaro> It always worked for me to use the binary on Ubuntu
23:43:46 <jutaro> but comiling is not hard either
23:44:11 <chairdog> ok
23:44:14 <chairdog> thanks
23:44:16 <lispy> Hard to build software is my pet peeve and GHC is not a pet peeve of mine :)
23:44:24 <merijn> ivanm: "someone even did a blog post on the topic recently" <- this statement is true for all linux related tasks... >.<
23:44:32 <ivanm> merijn: heh
23:44:36 * lispy goes to bed
23:44:39 <ivanm> merijn: I meant specifically "compiling 7.4 on Ubuntu"
23:44:44 <lispy> 'night ya'll
23:44:52 <ivanm> g'night lispy
23:48:53 <merijn> If haskell is a category, then * are its objects and "* -> *" is a functor mapping one haskell object to another?
23:49:20 <edwardk> merijn: that is the common interpretation
23:50:38 <edwardk> though we usually think of functors as being of kind * -> * with the additional functor map f . map g = map (f . g) and map id = id laws
23:51:00 <Blkt> good morning everyone
23:51:24 <hpaste> “Alhberto Gómez Corona” pasted “ShoppingCart” at http://hpaste.org/57517
23:51:43 <merijn> edwardk: I don't understand the difference?
23:52:22 <edwardk> data Foo a = Foo (a -> a) -- Foo has kind * -> * but isn't a functor
23:52:35 <edwardk> at least not over Hask
23:52:46 <merijn> Ah
23:52:48 <edwardk> you can view it as a functor on the discrete category of hask
23:53:09 <edwardk> but not on the category that we commonly refer to as hask
23:53:53 <edwardk> which isn't entirely an academic distinction, because neil ghani has some neat stuff that only needs that
23:54:15 <merijn> Foo maps Hask objects to Hask morphisms, rather than Hask objects, right?
23:54:41 <edwardk> well Hask morphisms are objects in Hask, because we have very strong exponentials
23:54:59 <edwardk> being (more or less) a CCC
23:55:19 <edwardk> the problem with Foo is that the 'a' in the result appears in both positive and negative position
23:55:24 <merijn> I think I just need to continue reading up on categories :p
23:55:29 <edwardk> data Bar a = Bar (Int -> a) works fine as a Functor
23:55:45 <edwardk> data Baz a = Baz (a -> Int) works fine as a contravariant functor
23:55:49 <NothingMan65> Hey!  What's an easy way to populate a new array with the tuple  (0,0), (1,0),(1,1)... (nx,ny) ?
23:56:38 <merijn> > [(x, y) | x <- [0..10], y <- [0..10]]
23:56:39 <lambdabot>   [(0,0),(0,1),(0,2),(0,3),(0,4),(0,5),(0,6),(0,7),(0,8),(0,9),(0,10),(1,0),(...
23:56:48 <edwardk> > (,) <$> [0..10] <*> [0..10]
23:56:49 <lambdabot>   [(0,0),(0,1),(0,2),(0,3),(0,4),(0,5),(0,6),(0,7),(0,8),(0,9),(0,10),(1,0),(...
23:56:55 <edwardk> they don
23:56:56 <merijn> NothingMan65: Depends, do they need to be in that order?
23:57:01 <edwardk> t put them in that order though
23:57:02 <NothingMan65> Would be nice.
23:57:08 <NothingMan65> But maybe it's a pain?
23:57:27 <merijn> NothingMan65: Well, you can use sortBy and give your own comparison function to do it
23:57:27 <edwardk> > sortBy (uncurry (+)) $ (,) <$> [0..10] <*> [0..10]
23:57:28 <lambdabot>   Occurs check: cannot construct the infinite type:
23:57:29 <lambdabot>    a = (a, a) -> GHC.Orde...
23:57:31 <edwardk> bah
23:57:35 <edwardk> :t sortBy
23:57:36 <lambdabot> forall a. (a -> a -> Ordering) -> [a] -> [a]
23:57:51 <edwardk> > sortBy (compare `on` uncurry (+)) $ (,) <$> [0..10] <*> [0..10]
23:57:52 <lambdabot>   [(0,0),(0,1),(1,0),(0,2),(1,1),(2,0),(0,3),(1,2),(2,1),(3,0),(0,4),(1,3),(2...
23:58:13 <NothingMan65> Hehe
23:58:19 <danr> > (,) <$> [0..4] <*> [0..4]
23:58:19 <lambdabot>   [(0,0),(0,1),(0,2),(0,3),(0,4),(1,0),(1,1),(1,2),(1,3),(1,4),(2,0),(2,1),(2...
23:59:07 <merijn> > sortBy (compare `on` uncurry (+)) [(x,y) | x <- [0..4], y <- [0..4]] -- Isn't this more readable? Or does that just mean my haskell skills aren't l33t enough?
23:59:08 <lambdabot>   [(0,0),(0,1),(1,0),(0,2),(1,1),(2,0),(0,3),(1,2),(2,1),(3,0),(0,4),(1,3),(2...
23:59:27 <merijn> Also, not exactly what NothingMan65 was asking
23:59:31 <edwardk> i tend to prefer the applicative syntax, but *shrug*
23:59:32 <chairdog> both seem readable in the perl sense.
23:59:33 <merijn> Since 0,2 is in front of 1,1
