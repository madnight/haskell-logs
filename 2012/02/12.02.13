00:03:20 <Mike___> cant seem to use that
00:03:29 <Mike___> doesnt let me on my do statement
00:05:12 <donri> are you in IO?
00:15:03 <erus`> one does not simply leave the IO monad
00:15:57 <yezariaely> within the parameter --with-extra-include-dirs in cabal the paths must be separated with what symbol?
00:16:57 <Jafet> Some can return to the IO monad.
00:23:01 <mm_freak_> that's the difference between Bool and Property?
00:27:56 <ddarius> @src Property
00:27:57 <lambdabot> Source not found. You speak an infinite deal of nothing
00:41:25 <Peaker> mm_freak_: I'm guessing you mean Property in the Agda sense?
00:42:08 <Peaker> or actually, Proposition in the Agda sense :)
00:49:02 <hpaste> covi pasted “sss” at http://hpaste.org/63605
00:49:22 <covi> Hi guys, can somebody check out the error above ^?
00:51:30 <mm_freak_> Peaker: no, in the QuickCheck/SmallCheck sense
00:58:52 --- mode: kornbluth.freenode.net set +o ChanServ
00:59:08 <merijn> covi: What exactly doesn't work with that code?
01:00:16 <covi> merijn: ghci says  could not deduce (a ~ Int), in line 9
01:01:07 <merijn> covi: Oh, I think I see it
01:01:32 <covi> merijn: Mind pointing out the problem and how to fix it?
01:01:40 <merijn> covi: isPrime takes an Int
01:01:48 <merijn> By extension primeList has to be an [Int]
01:02:08 <merijn> getPrimeFactorsList returns a filtered primeList (i.e. [Int])
01:02:21 <merijn> But your function signature (Integral => a -> [a])
01:02:32 <merijn> claims that getPrimeFactorsList can return any Integral type
01:02:58 <covi> oooh..
01:03:02 <merijn> If you replace "Integral a => a -> [a]" with "Int -> [Int]" it should work (mind you, I haven't tested)
01:03:05 <covi> how do I limit it to Int?
01:03:20 <merijn> Alternatively, change isPrime to be "Integral a => a -> Bool"
01:04:07 <erus`> death to all free variables!
01:04:08 <merijn> covi: "could not deduce (a ~ Int), in line 9" basically means "you are telling me this works for any 'a' that is Integral, but the types says this can only be Int"
01:04:46 <merijn> i.e. GHC couldn't deduce that 'a == Int'
01:05:23 <covi> merijn: thanks man! the program can be run now... and is taking a long time to finish (still running) :)
01:05:48 <merijn> covi: Well yes, the code is horribly inefficient because you're constantly generating very long lists
01:06:32 <merijn> isPrime generates a list from 2 to (n-1) for each call to isPrime
01:07:05 <covi> merijn: I am very new to Haskell and I'm not sure how to implement the sieve for generating primes
01:07:07 <merijn> And isPrime is called for each number between 1 and (floor . sqrt) 600851475143
01:09:59 <merijn> covi: Some nice short examples are here: http://stackoverflow.com/questions/3596502/lazy-list-of-prime-numbers
01:10:22 <merijn> Still not that efficient, but much more so than your current code :)
01:11:08 <covi> merijn: yeah I'm also reading this http://www.haskell.org/haskellwiki/Prime_numbers, thanks :)
01:11:44 <JiXiY> hey there. is there any efficient way to apply a filter on a list and get both, the matching and not matching values back?
01:12:20 <JiXiY> i can always use 2 filters of course; but I don't think that that's very performant if you've got a large list
01:12:33 <merijn> @hoogle (a -> Bool) -> [a] -> ([a], [a])
01:12:34 <lambdabot> Prelude break :: (a -> Bool) -> [a] -> ([a], [a])
01:12:34 <lambdabot> Data.List break :: (a -> Bool) -> [a] -> ([a], [a])
01:12:34 <lambdabot> Prelude span :: (a -> Bool) -> [a] -> ([a], [a])
01:12:51 <JiXiY> thanks
01:13:00 <merijn> JiXiY: No clue if those do what you want
01:13:10 * hackagebot hmpfr 0.3.3.4 - Haskell binding to the MPFR library  http://hackage.haskell.org/package/hmpfr-0.3.3.4 (MichalKonecny)
01:13:17 <merijn> JiXiY: You could implement your own filter that does that fairly easy, though
01:13:58 <covi> Haskell, well, just blows my mind.
01:14:29 <erus`> covi: lambda calc will blow your brain
01:14:34 <merijn> covi: :)
01:14:52 <covi> erus`: I'm not officially a math major yet.
01:15:05 <covi> nor a cs
01:15:11 <merijn> Lambda calculus is more of a theoretical CS subject, isn't it?
01:15:29 <merijn> This example is always nice, though useless :p
01:15:29 <clintm> heh
01:15:30 <merijn> > let fib = 0 : 1 : zipWith (+) fib (tail fib)  in fib
01:15:31 <lambdabot>   [0,1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765,10946...
01:15:37 <erus`> you better brush up on your advanced category theory if you wanna write hello world in haskell
01:15:54 <covi> erus`: lol
01:16:14 <covi> merijn: I struggled with this this morning and still don't understand why it works.
01:16:14 <yezariaely> any developer of cabal here?
01:16:33 <merijn> covi: Any specific part that confuses you?
01:17:02 <merijn> > let ones = 1 : ones in ones
01:17:02 <lambdabot>   [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,...
01:17:05 <covi> merijn: I mean... I'm so used to sequential thinking, like 'okay after the first/second stop it becomes'
01:17:15 <covi> *step
01:17:46 <covi> merijn: this one also catches me
01:18:05 <MaskRay> > fix ((1:).id)
01:18:06 <lambdabot>   [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,...
01:18:17 <erus`> fix (1:)
01:18:19 <erus`> > fix (1:)
01:18:20 <lambdabot>   [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,...
01:18:22 <covi> merijn: so at the very beginning ones = 1, then it is instructed to be added to 1?????? ?
01:18:28 <merijn> covi: Do you know C/C++ ?
01:18:32 <covi> merijn: sure.
01:18:49 <merijn> covi: Think of "ones = 1 : ones" as a circular linked list
01:18:49 <MaskRay> > fix ((0:) . scanl (+) 1)
01:18:50 <drdo> covi: think about a circular list for the ones case
01:18:51 <lambdabot>   [0,1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765,10946...
01:18:52 <yezariaely> can anyone reproduce the following bug in cabal? Giving the parameter --extra-lib-dirs twice, the LDFLAGS output is concatenated with a space missing inbetween
01:18:57 <merijn> A list is a value + pointer to next
01:19:12 <merijn> That code just says the next pointer should point back to ones
01:19:27 <covi> drdo: it helps
01:19:31 <covi> merijn: it helps
01:19:40 <covi> is this the underlying implementation?
01:19:52 <merijn> covi: With some indirection, yes
01:20:22 <covi> but I still don't understand the fibo example.
01:20:42 <merijn> covi: The "fib" case works because of laziness. It basically says that "fib is a list of 0, followed by 1, followed by some stuff we'll calculate when we need it"
01:21:17 <yitz> @type partition -- JiXiY
01:21:18 <lambdabot> forall a. (a -> Bool) -> [a] -> ([a], [a])
01:21:22 <merijn> zipWith just combines two lists (in this case the same one with an offset of one) using the (+) function
01:21:55 <merijn> So whenever you try to use a part of fib that does not yet exist it will evaluate enough of zipWith to return the next value
01:22:04 <yitz> JiXiY: but it's not a serious performance hit to use 2 filters
01:22:29 <covi> merijn: yes I understand zipWith (+)
01:22:33 <merijn> covi: Since we never evaluate more than strictly necessary (laziness) the fact that fib is infinite is never a problem
01:22:42 <JiXiY> yitz: mmh... then the issue must lie elsewhere.
01:22:52 <Jafet> The only problem with using filter twice is space usage.
01:22:59 <covi> merijn: I gotta fetch lunch. Will think over it. thanks
01:23:08 <merijn> covi: np :)
01:23:21 <yitz> JiXiY: in an imperative language you lose your cache every time you rewind to the beginning. but in a lazy language the two passes will run together in step.
01:23:24 <dcoutts> yezariaely: what LDFLAGS?
01:23:37 <yitz> JiXiY: sometimes.
01:24:28 <yitz> Jafet: you don't always use more memory when you run two filters.
01:24:55 <yezariaely> dcoutts: Maybe I am wrong, but I thought, that LDFLAGS (gcc environment var) is set by cabal w.r.t --extra-lib-dirs? At least for the package I tried to install this seems to be the case
01:25:17 <Jafet> Well, actually, I usually do
01:25:26 <Jafet> Perhaps he doesn't
01:25:38 <yitz> dcoutts: is it really practical to conform to LGPL for GMP by provide the .o, for all of linux/windows/mac?
01:26:00 <yitz> dcoutts: i.e. is it practical for someone to re-link it with a different GMP if they want?
01:26:30 <Jafet> What on earth is a different GMP
01:26:34 <Jafet> There is one GMP
01:27:05 <asda8> Jafet: yeah, but theoretically you could modify GMP and relink with that
01:27:18 <Jafet> Oh, that. It's probably only fine if you use the .so library.
01:27:18 <asda8> Jafet: without the .o files that doesn't work
01:27:19 <yitz> Jafet: no matter. let's say they modify the source code of GMP themselves or something. the lpgl requires that they be able to re-link theirs in.
01:28:38 <yitz> my impression is that linking an app compiler with ghc is really tricky. especially on the mac. but perhaps i'm wrong.
01:28:47 <dcoutts> yezariaely: ah, no cabal itself does not set LDFLAGS env var, perhaps you're using a package with some custom Setup.hs code that does (and does so wrong)
01:28:50 <yitz> s/compiler/compiled/
01:29:17 <dcoutts> yitz: for linux and osx there's no problem since it's a shared lib
01:29:21 <Jafet> I can use my binaries on any other linux system with the appropriate libgmp.so.
01:29:43 <yitz> dcoutts: meaning we should make the .o available and we're done?
01:30:02 <dcoutts> yitz: for windows where you're statically linking your app to gmp, yes it is entirely practical to provide a .o version of your .exe which can be relinked to produce that .exe
01:30:07 <yitz> dcoutts: and for windows use sigborne's recipe?
01:30:38 <yitz> dcoutts: oh you mean on linux and osx we can do nothing?
01:30:48 <dcoutts> yitz: no idea what sigborne's recipe is, but what I did was to add some stuff to the Setup.hs so that it would always make the .o first and link that to get the final .exe, so I'd know it always works
01:31:05 <dcoutts> yitz: I can share the Setup.hs code if you're interested
01:31:12 <dcoutts> or just tell you what it does
01:31:15 <yitz> dcoutts: yes please
01:31:32 <asda8> dcoutts: could you share it please? I'm interested as well
01:31:41 <yitz> dcoutts: we have a finished app. we just want to deliver it to customers now. :)
01:31:48 <dcoutts> yitz: :-)
01:32:07 <Jafet> Or you could just build with integer-simple.
01:32:13 <dcoutts> "just"
01:32:17 <dcoutts> means rebuilding ghc
01:32:27 <Jafet> Yes build GHC
01:32:27 <yitz> right we're hoping to avoid that Jafet :)
01:32:52 <yitz> it also means that if any of our dependent libraries do anything non-trivial with Integer we are hosed
01:33:49 <Jafet> GMP is only used for, like, ten operations anyway
01:33:59 <Jafet> In fact, it's not even used for gcd
01:34:07 <hpaste> “Duncan Coutts” pasted “Setup.hs to comply with LGPL” at http://hpaste.org/63607
01:34:19 <Jafet> The whole integer-gmp binding is pretty senseless.
01:34:37 <yitz> it's been somewhere down my to-do list for a few years to write integer-karatsuba
01:34:47 <dcoutts> Jafet: the integer-gmp is much faster than integer-simple
01:34:51 <dcoutts> if you use Integer ops
01:37:59 --- mode: kornbluth.freenode.net set +o ChanServ
01:38:13 <dcoutts> yitz: yes, or adjust the above Setup to do it conditionally on arch (Distribution.Platform.hostOS)
01:38:13 <yitz> dcoutts: ugh netsplit. still there?
01:38:16 <yitz> dcoutts: ok thanks!
01:38:39 <int-e> Jafet: One funny thing about ghc is that its gmp binding is slightly faster than the plain C one, because of cheaper allocation.
01:38:40 <dcoutts> yitz: so you're sure gmp is your only LGPL lib?
01:39:01 <Jafet> Yeah, but only for the ten or so operations that use GMP
01:39:13 <yitz> dcoutts: mmm. we can check our dependencies for anything outside ghc, right?
01:39:26 <dcoutts> yitz: and for Haskell lib deps too
01:39:33 <dcoutts> yitz: e.g. gtk2hs
01:39:50 <yitz> dcoutts: we're not using that. it's a warp/wai app.
01:39:58 <dcoutts> yitz: just an example
01:40:12 <dcoutts> you need to cover all transative deps, Haskell and C
01:40:28 <alang> I'm running 7.2.1 and i'm getting different runtime behaviour if i comment/uncomment a function which is _never actually called_
01:40:36 <alang> does this bug sound familiar?
01:40:42 <dcoutts> yitz: and careful not to violate the BSD license :-)
01:40:42 <yitz> dcoutts: all the deps from the yesod suite should be fine. there's network. etc. should all be ok, we can check.
01:41:14 <yitz> dcoutts: we have no plans to hold anyone liable. actually we have no plans to be damaged either.
01:41:17 <dcoutts> yitz: we ended up with a multi-kb license file which concatenated the dozens of BSD-like licenses from all the packages
01:41:25 <int-e> alang: do you mean you're getting different results or different running times?
01:41:27 <yitz> hah
01:41:48 <alang> int-e: running times
01:42:18 <dcoutts> yitz: which according to my reading of the BSD license is required (I think as an industry we violate the BSD license left right and centre)
01:42:42 <yitz> dcoutts: ok i'll look into that too. thanks.
01:42:52 <alang> the code that gets commented calls a GSL function from hmatrix
01:43:08 <mux> it's pretty hard to violate a BSD license :)
01:43:19 <yitz> dcoutts: even though there are a lot of deps, many of them are yesod, which not only all have the same license but are developed in-house. :)
01:43:35 <yitz> mux: dcoutts says it's easier than you think
01:43:45 <dcoutts> mux: easy to do it by not including the license of some lib along with some app
01:44:05 <int-e> alang: anyway I can only speculate that the compiler is making different inlining decisions.
01:44:11 <yitz> mux: if you have thousands of deps, each with it's own file that is required to be included, it can actually be complicated to comply
01:44:26 <dcoutts> e.g. do you include the "The Glasgow Haskell Compiler License" with binaries?
01:44:40 <dcoutts> you're linking against the base package which is covered by that license
01:44:43 <mux> dcoutts: yes, that's about the only way you can violate it if it's a "modern" BSD license without the advertising clause
01:45:10 <dcoutts> mux: right, but my point is I think "we" as an industry/community do that all the time
01:45:27 * mux nods
01:45:38 <yitz> dcoutts: i think i'll invent a new bsd-style license that requires you to digitally sign the license file when you re-distribute it.
01:45:39 <dcoutts> everyone worries about violating the GPL but does it routinely for BSD, though the compliance is so much easier
01:45:52 <dcoutts> yitz: heh
01:46:23 <Jafet> yitz has found a new way to collect autographs
01:46:44 <yitz> digital postcard-ware
01:51:54 <Peaker> dcoutts: what does BSD compliance require?
01:52:13 <dcoutts> Peaker: read it, it's short :-)
01:52:29 <Jafet> Read which one?
01:52:35 <dcoutts> - Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer in the documentation and/or other materials provided with the distribution.
01:53:01 <dcoutts> Jafet: they're more or less all the same, though yes you do have to double check
01:53:33 <mux> there's another clause that is about identical but pertains to redistribution in source form
01:53:41 <b0fh_ua> Hi all! With arrows how do I take second item from a tuple, transform it and return tuple? Like in (arr id) *** (arr f)
01:54:00 <alang> int-e: yea that's what I expected, but I'm surprised since the function is not actually called anywhere
01:54:02 <mux> and older BSD licenses also have a third clause forbidding to use the name of the project for commercial purposes
01:54:17 <mux> that's it
01:54:32 <Jafet> :t second
01:54:32 <lambdabot> forall (a :: * -> * -> *) b c d. (Arrow a) => a b c -> a (d, b) (d, c)
01:54:50 <mux> why aren't first and second reexported by Data.Tuple btw?
01:55:03 <Jafet> Because they're for Arrows, silly!
01:55:08 <mux> it sucks to import Control.Arrow just to get convenient functions to map tuples
01:55:11 <mux> I, er, heh
01:55:22 <Jafet> (Arrows are... functions and tuples.)
01:55:35 <mux> obvisouly I meant to reexport them with a constrained type on tuples
01:55:53 <b0fh_ua> Jafet: not really.
01:56:07 <Jafet> Then you'd have two definitions of second
01:56:15 <mux> yes
01:56:33 <b0fh_ua> Jafet: thanks
01:56:38 <mux> a specific one and a more generic one, just like we have two versions of map, fold*, etc
02:04:47 <Mike___> Does anyone here knows anything about colloring text in Haskell?
02:07:53 <donri> Mike___: need to be more specific
02:08:02 <Mike___> I have a rubiks cube
02:08:23 <Mike___> and I would like to check what Int i have and color the text depending on it
02:08:31 <donri> on the console?
02:08:34 <donri> @hackage ansi-wl-pprint
02:08:34 <lambdabot> http://hackage.haskell.org/package/ansi-wl-pprint
02:08:36 <Mike___> text colloring in Haskell basicly
02:08:39 <Mike___> yeah
02:08:41 <Mike___> for windows
02:09:11 <donri> that one supports windows
02:09:28 <Mike___> ok, thank you
02:09:34 <Mike___> I should install it with Cabal right?
02:09:38 <donri> yep
02:12:05 <Mike___> donri: would you happen to know where I can read documentation, and see examples of this usage?
02:12:36 <Mike___> nvm
02:12:40 <Mike___> found the homepage
02:12:41 <Mike___> thanks
02:44:05 <MaskRay> [emacs,haskell-mode] my C-c C-l (inferior-haskell-load-file) seems broken. emacs gets stuck when i press C-c C-l
02:49:10 <qubodup> hi
02:49:13 <qubodup> I get this error when 'cabal list'ing: cabal: Couldn't read cabal file "pqc/0.5/pqc.cabal"
02:50:31 <dcoutts> qubodup: sorry, it doesn't handle very well .cabal files in the index that it cannot parse
02:50:45 <dcoutts> is it a problem for you or can you work around it?
02:59:33 <MaskRay> solved
03:00:12 <MaskRay> inferior-haskell-mode can only handle "^\\*?[[:upper:]][\\._[:alnum:]]*\\(?: \\*?[[:upper:]][\\._[:alnum:]]*\\)*>" prompt
03:01:34 <JiXiY> Can I somehow get ghc to give me more information about "non-exhaustive patterns in lambda" warnings/errors?
03:02:28 <rostayob> JiXiY: isn't the line number enough?
03:02:35 <rostayob> lambda only have one pattern
03:02:49 <rostayob> and if the data type you're matching has more than one... well that's a non-exhaustive pattern
03:03:13 <hpaste> drdo pasted “Overlapping Instances” at http://hpaste.org/63608
03:03:29 <JiXiY> heh... true. thanks. was looking for the error elsewhere.
03:03:34 <drdo> Why would the Num instance match?
03:03:35 * hackagebot tar 0.4.0.0 - Reading, writing and manipulating ".tar" archive files.  http://hackage.haskell.org/package/tar-0.4.0.0 (DuncanCoutts)
03:06:33 <ChristianS> is it possible to document multiple programs (each which its own main method) in a single directory generated by haddock -h ?
03:06:43 <drdo> Oh, with the OverlappingInstances extension it does work, ghc usually suggests such things :P
03:06:56 <ChristianS> it seems to me to be impossible because each main method must be in a module named Main, so haddock would treat the multiple programs (Main modules) as one? but maybe there is a workaround?
03:08:55 <Botje> you can use main-is to tell cabal which module contains your main function
03:09:18 <dcoutts> no, just which file is your Main module
03:09:42 <dcoutts> (subtle difference)
03:10:04 <quicksilver> drdo: because constraints are not part of instance selection.
03:10:16 <quicksilver> drdo: OverlappingInstances is not recommended, it can't always do the right thing.
03:10:22 <Botje> oh, right
03:10:39 <dcoutts> it's not the same as the ghc -main-is flag, which says which module to treat as the Main module
03:11:15 <drdo> quicksilver: What's the recommended approach?
03:11:37 <dcoutts> Botje: ghc -main-is lets you use a "module Foo" as the Main module, cabal's main-is lets you say that foo.hs contains the "module Main"
03:11:55 <Botje> oh
03:12:08 <quicksilver> drdo: what you're doing is not supported by the class system.
03:12:10 <Botje> i only used the ghc option, thought cabal would do the same >_<
03:12:20 <quicksilver> drdo: if you can express the underlying problem it may be more clear what the solutioni s.
03:12:29 <dcoutts> Botje: yeah, it's confusing that they ended up with the same name
03:12:37 <quicksilver> drdo: making separate instances for the 3 or 4 Num types you actually care about might be the answer.
03:13:30 <ChristianS> dcoutts: ah, so can chosse a different module name and use  ghc -main-is My.Module.Name  to let ghc know that it should compile that module into an executable file?
03:13:41 <ChristianS> that should be good enough, thanks!
03:13:45 <drdo> quicksilver: GHC doesn't complain if i don't use fromBE when defining the instance for M.Map LB.ByteString a
03:14:09 <dcoutts> ChristianS: yes, but that's not compatible with cabal's build system
03:16:30 <ChristianS> dcoutts: hmm, so far i'm not using cabal but i guess i'll have to switch to it at some point in order to be able to distribute it. so that's a pity...
03:17:05 <ChristianS> isn't there a way to get multiple tools (executables) into a single cabal package and still generate package documentation for all of them?
03:17:27 <dcoutts> ChristianS: yes, just use multiple blah.hs files
03:17:36 <dcoutts> each blah.hs is itself a Main module
03:18:27 <dcoutts> ChristianS: there's also a flag to enable generating docs for executables, since it defaults just to generating docs for libs
03:19:47 <ChristianS> dcoutts: hmm, but  haddock -h -o doc/ *.hs  complains: module `main:Main' is defined in multiple files
03:20:11 <dcoutts> ChristianS: cabal haddock does it all
03:20:51 <ChristianS> dcoutts: ok, i guess it's time to switch to cabal then, thanks
03:21:00 <dcoutts> ChristianS: it invokes haddock once for each exe
03:22:09 <ChristianS> is there a quick tutorial to get started with cabal? so far I've just used make...
03:22:51 <dcoutts> ChristianS: there's the user guide but it's not quick (and still talks about Setup.hs)
03:23:00 <dcoutts> I've got a new quick start
03:23:28 <dcoutts> http://code.haskell.org/~duncan/cabal/user-guide/developing-packages.html#quickstart
03:24:15 <dcoutts> ChristianS: and there's the http://www.haskell.org/haskellwiki/How_to_write_a_Haskell_program
03:25:15 <ChristianS> dcoutts: great, i'll take a look at both
03:33:07 <koeien3> i have a large structure of "classes", with subtyping ("inheritance"). this structure is parsed by my program and I emit haskell files corresponding to this structure.
03:33:48 <koeien3> what is the usual way to represent this in haskell? so far i have for every "class": a haskell class, a data, and an existential type.
03:34:36 <koeien3> i would also like to have "dynamic_cast", i.e. if i have a value of type T, i want to test, in runtime, if it is of type U instead (where U is a subtype of T)
03:35:00 <koeien3> i was thinking of using Typeable for this.
03:35:08 <koeien3> does this approach sound reasonable?
03:36:09 <osager> Hi
03:36:44 <mekeor> hi, osager
03:37:45 <osager> Hi just a test message on my android tablet
03:55:48 <lpjhjdh> Not 100% haskell but I was wondering if anyone could answer a simple category theory question?
03:56:11 <koeien3> lpjhjdh: just ask your question :)
03:57:07 <lpjhjdh> Given two product arrows <foh,goh> and <f,g> show <foh,goh>=<f,g>oh
03:58:44 <erus`> <foh,goh>=<f,g>oh . Qed.
03:59:04 <lpjhjdh> So I can get "prb o <foh,goh> = prb o <f,g> o h" but I don't know that prb is monic. Am I heading down the wrong route?
03:59:34 <erus`> i can has fields medal
03:59:48 <mekeor> heh
04:00:14 <mekeor> lpjhjdh: with "o" you mean function composition, don't you?
04:00:37 <lpjhjdh> Yeah, sorry I'm on my phone as I currently have no power.
04:00:39 <mekeor> what are product arrows?
04:00:46 <byorgey> lpjhjdh: show that they both make the same diagram commute.  Then since <foh, goh> is unique by definition, they must be equal.
04:00:52 <mekeor> lpjhjdh: why don't you write . then? :P
04:01:50 <lpjhjdh> mekeor: given I'm in the haskell channel I like this idea.
04:04:59 <lpjhjdh> byorgey: ah, thanks.
04:05:19 <atri> hi
04:05:25 <byorgey> hi atri
04:05:25 <atri> i needed some help
04:05:41 <rostayob> atri: ask away
04:06:57 <atri> i am a c and c++ developer
04:07:16 <atri> i wanted to learn haskell
04:07:26 <lpjhjdh> mekeor: http://en.m.wikipedia.org/wiki/Product_(category_theory)
04:07:31 <hpc> @where lyah
04:07:31 <lambdabot> http://www.learnyouahaskell.com/
04:07:33 <hpc> atri: ^
04:07:49 <mekeor> lpjhjdh: oh, i remember
04:07:49 <atri> could you please tell me the benefits of haskell
04:08:01 <atri> maybe,a quick tutorial as wel
04:08:28 <koeien3> atri: for motivation you could read the introduction of Real World Haskell
04:08:29 <koeien3> @where RWH
04:08:30 <lambdabot> http://www.realworldhaskell.org/blog/ http://book.realworldhaskell.org/read/
04:08:56 <atri> ok thanks
04:09:26 <atri> could you please tell me the way to become a haskell hacker?
04:10:12 <hpc> atri: go through a tutorial or two, then code some stuff on your own
04:10:34 <atri_> ok thanks
04:11:00 <atri_> how different is functional programming from PROCEDURAL programming?
04:11:13 <koeien3> pretty different
04:11:21 <koeien3> the whole approach differs
04:11:35 <koeien3> instead of saying *how* something should be done, you specify *what* should be done
04:11:42 <atri> ok
04:11:55 <koeien3> an example is the factorial function
04:12:03 <koeien3> (factorial(n) = n * (n-1) * ... * 1)
04:12:10 <koeien3> in C you can write this as
04:12:10 <hpc> or instead of specifying a sequence of actions, you pass values from one function to another
04:12:26 <koeien3> unsigned f = 1; for (unsigned i = 1; i <= n; i++) f *= i;
04:12:33 <atri> yup
04:12:34 <koeien3> in haskell you write
04:12:40 <koeien3> fact 0 = 1; fact n = n * fact (n-1)
04:12:41 <hpc> instead of x = f(); x = g(x); return h(x);
04:12:50 <hpc> you have h (g (f x))
04:12:52 <atri> wow
04:12:59 <atri> that's pretty compact
04:13:03 <atri> fast
04:13:21 <koeien3> it's quite dense, yes
04:14:25 <hpc> another thing haskell does that is different from almost any other language is separate IO
04:14:45 <hpc> so when you write your factorial function, the compiler can guarantee that you don't do anything silly like write to a file
04:15:18 <hpc> and the tutorials explain that way better than i can :P
04:17:17 <Peaker> hpc: x = f(g(h(x))); ?
04:17:26 <MaskRay> > map (fix(\f n->if n==0 then 1 else n*f (n-1))) [1..10]
04:17:27 <lambdabot>   [1,2,6,24,120,720,5040,40320,362880,3628800]
04:18:04 <mekeor> @src fix
04:18:04 <lambdabot> fix f = let x = f x in x
04:18:34 <int-e> > scanl (*) 1 [1..]
04:18:35 <lambdabot>   [1,1,2,6,24,120,720,5040,40320,362880,3628800,39916800,479001600,6227020800...
04:18:50 <mekeor> > scanl1 (+) [1..]
04:18:50 <lambdabot>   [1,3,6,10,15,21,28,36,45,55,66,78,91,105,120,136,153,171,190,210,231,253,27...
04:19:30 <mekeor> > fibs@(_:f) = 1 : 1 : zipWith (+) fibs f
04:19:31 <lambdabot>   <no location info>: parse error on input `='
04:19:39 <mekeor> > let fibs@(_:f) = 1 : 1 : zipWith (+) fibs f in fibs
04:19:40 <lambdabot>   [1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765,10946,1...
04:19:47 <mux> > fix ((1:) . scanl (+) 1)
04:19:49 <lambdabot>   [1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765,10946,1...
04:20:38 <int-e> (0:), please, so that fib(0) = 0, and fib(n) divides fib(m) if n divides m.
04:21:10 <mekeor> > let p l@(_:t) = [1]++zipWith (+) l t++[1] in iterate p [1]
04:21:12 <lambdabot>   [[1],[1,1],[1,2,1],[1,3,3,1],[1,4,6,4,1],[1,5,10,10,5,1],[1,6,15,20,15,6,1]...
04:21:18 <mekeor> int-e: i'm sorry.
04:21:33 <int-e> mekeor: I was complaining to mux actually ;-)
04:21:45 <mekeor> oops :D
04:21:52 <mux> > fix ((0:) . scanl (+) 1) -- fine :-P
04:21:53 <lambdabot>   [0,1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765,10946...
04:24:58 <mekeor> mux: i dont understand your code; could you briefly explain it?
04:25:59 <int-e> mekeor: fib(n) = fib(n-2) + fib(n-3) + ... + fib(1) + fib(0) + 1  is the underlying identity.
04:26:38 <atri> sorry for the delay
04:26:42 <mekeor> int-e: ah, okay
04:26:43 <atri> i now get it
04:26:46 <MaskRay> mekeor: cool stuff
04:26:56 <hpc> :t (0:) . scanl (+) 1
04:26:57 <lambdabot> forall t. (Num t) => [t] -> [t]
04:27:02 <atri> i will start learning haskell
04:27:08 <hpc> :t scanl (+) 1
04:27:09 <lambdabot> forall a. (Num a) => [a] -> [a]
04:27:14 <MaskRay> mekeor: an explicit @ to avoid `tail'
04:27:16 <atri> thank you so much
04:27:19 <mekeor> MaskRay: right
04:27:43 <mekeor> MaskRay: but idk whether that's better... idk
04:27:58 <sordina>  I'm having some issues with multiparam type classes. https://gist.github.com/821ae49582c36a836a0c - The call to comparing can't disambiguate (Windowed a t) in the `comparing` section of the `ordered` definition. Why would this be an issue?
04:28:04 <int-e> mekeor: Which is easy to prove by induction: fib(n+1) = fib(n) + fib(n-1) = fib(n-1) + fib(n-2) + ... + fib(0) + 1, with base case fib(1) = 1.
04:28:39 * hackagebot htar 0.4 - Command-line tar archive utility.  http://hackage.haskell.org/package/htar-0.4 (DuncanCoutts)
04:28:41 <mekeor> int-e: i see.
04:29:02 <mux> mekeor: rewrite it in point-full mode and unroll it in your head, it'll make sense
04:29:18 <mekeor> alright
04:30:30 <Peaker> > fix ((0:) . (1:) . scanl (+) 0)
04:30:31 <lambdabot>   [0,1,0,0,1,1,1,2,3,4,6,9,13,19,28,41,60,88,129,189,277,406,595,872,1278,187...
04:32:08 <weltensegler> I discovered some strange behaviour of ghc when it comes to ranges of Floats: [0.5 .. 0] expands to [0.5] but [0.6 .. 0] expands to the empty list. Moreover [0.18, 0.36 .. 1] expands to [0.18,0.36,0.54,0.7200000000000001,0.9000000000000001,1.08], while [0.19, 0.38 .. 1] expands to [0.19,0.38,0.5700000000000001,0.7600000000000001,0.9500000000000002]. Can anyone please explain this?
04:32:18 <int-e> Peaker: that satisfies a(n) = a(n-1) + a(n-3)
04:33:03 <merijn> weltensegler: Yes, the enum class of floats is an abomination unto the lord. Don't use it (and by extension the list comprehension syntax that it fuels)
04:33:03 <hpc> weltensegler: it's been known for pretty much forever that floats do strange things
04:34:00 <byorgey> this is not because floats are strange though.  This is because the Haskell standard is strange.
04:34:33 <weltensegler> Is there a good reason, why this does not get fixed?
04:34:36 <merijn> byorgey: The float instance of enum is weird (and really shouldn't exist >.>)
04:34:37 <hpc> byorgey: i maintain that it is floats that are strange and haskell is the only language that notices
04:34:52 <merijn> weltensegler: It won't be fixed because there's nothing wrong
04:34:53 <mux> byorgey: beg your pardon? it's ieee754's fault in my book
04:35:02 <hpc> mux: *highfive*
04:35:06 <merijn> mux++
04:35:16 <mux> yay, karma love
04:35:55 <weltensegler> merijn, how do you mean that?
04:36:06 <byorgey> hpc: fair enough.
04:36:15 <merijn> weltensegler: What do you think it should do and why should it do that?
04:36:32 <Peaker> I don't understand why [0.5..0] is different from [0.6..0]  in both cases the first element is already past the end so should be excluded?
04:36:43 <Peaker> > ([0.5..0], [0.6..])
04:36:44 <lambdabot>   ([0.5],[0.6,1.6,2.6,3.6,4.6,5.6,6.6,7.6,8.6,9.6,10.6,11.6,12.6,13.6,14.6,15...
04:36:44 <merijn> Peaker: counting down
04:36:49 <Peaker> > ([0.5..0], [0.6..0])
04:36:50 <lambdabot>   ([0.5],[])
04:36:52 <byorgey> sigh. here we go again.
04:36:57 <weltensegler> Thanks Peaker!
04:37:02 <merijn> Peaker: Floats count in half steps
04:37:06 <merijn> iirc
04:37:14 <merijn> [0.5..10]
04:37:17 <merijn> > [0.5..10]
04:37:18 <lambdabot>   [0.5,1.5,2.5,3.5,4.5,5.5,6.5,7.5,8.5,9.5,10.5]
04:37:21 <merijn> > [0.6..10]
04:37:22 <lambdabot>   [0.6,1.6,2.6,3.6,4.6,5.6,6.6,7.6,8.6,9.6]
04:37:26 <byorgey> Peaker: the Haskell standard specifies that the Enum instance for floating-point types stops only after the end of the range + 1/2 the step size.
04:37:43 <Peaker> byorgey: wow, that's silly, why?
04:38:12 <byorgey> Peaker: because otherwise rounding error would result in some even sillier things, such as [0.0, 0.1 .. 1] stopping at 0.9
04:38:28 <Peaker> well, now we get two kinds of silliness in the price of one :P
04:38:29 <byorgey> really, the point is that an Enum instance for floating-point types is silly.
04:38:33 <koeien3> nah i'd expect more that be3havior
04:38:34 <byorgey> period.
04:38:37 <Peaker> the former is at least one people already expect
04:38:39 <merijn> byorgey: Well, yes
04:38:58 <Peaker> The Ord instance is also silly, in that vein, but useful
04:39:06 <byorgey> anyway, I'm not really interested in justifying the standard.  Just explaining what it says and the reasons it gives.
04:39:15 <Peaker> ok
04:39:15 <ChristianS> i guess the reason is to say prevent the sequence [0.0, 0.1 .. 1.0] from stopping at 0.9 if the next value happens to be 1.000000001 which would be bigger than 1.0
04:39:24 <byorgey> ChristianS: right.
04:39:37 <Peaker> ChristianS: yeah, an extremely flawed workaround, IMO
04:39:43 <ChristianS> due to the rounding, 1.000000001 will still be included
04:39:58 <edsko> @help
04:39:58 <lambdabot> help <command>. Ask for help for <command>. Try 'list' for all commands
04:40:17 <mekeor> @help help
04:40:17 <lambdabot> help <command>. Ask for help for <command>. Try 'list' for all commands
04:40:35 <mekeor> thats recursion =)
04:40:35 <Axman6> @help help help! help! help!
04:40:36 <lambdabot> help <command>. Ask for help for <command>. Try 'list' for all commands
04:40:49 <aleator_> Hi all. Is there a package of typeclasses for basic geometric types such as lines, points, circles and line segments?
04:41:09 <Axman6> aleator_: why would those need to be type classes?
04:41:17 <weltensegler> Thanks for the clarification. I will have to see, what i make of it.
04:42:02 <quicksilver> byorgey: the silliness IMO is that its *called* Enum but its main purpose is ranges (the .. psuedo operator)
04:42:21 <byorgey> quicksilver: oh, yeah, Enum is silly on many different levels.
04:42:36 <koeien3> > succ maxBound :: Int
04:42:37 <lambdabot>   *Exception: Prelude.Enum.succ{Int}: tried to take `succ' of maxBound
04:42:40 <aleator_> Axman6: I've got largish bindings-dsl project that throws plenty of different c-types representing geometry at me. It would be nice to abstract them instead of converting them to haskellish types.
04:42:41 <koeien3> WTF?
04:42:49 <mekeor> byorgey: hehe
04:43:03 <merijn> koeien3: What's weird about that?
04:43:08 <quicksilver> you could distill it a little by separating the range behaviour from the "bijection with subset of the ints" behaviour
04:43:11 <mekeor> why isnt there actually a MinBounded and MaxMounded type class?
04:43:15 <koeien3> merijn: i'd expect succ to be total.
04:43:29 <koeien3> but yeah "WTF" is a bit too strong.
04:43:34 <koeien3> succ :: a -> Maybe a
04:43:37 <merijn> koeien3: What would it do on a bounded value? Loopback to the start?
04:43:43 <merijn> Yeah, that'd work
04:44:07 <flux> koeien3, but that would really succ for many uses of it
04:44:20 <koeien3> doesn't the same hold for "head"?
04:44:25 <koeien3> I don't like that function either
04:44:46 <flux> there are total languages (or at least one..), haskell isn't one of them :)
04:45:10 <mekeor> flux: whats a total language?
04:45:15 <koeien3> oh could somebody with enough power change the /topic ?
04:45:18 <koeien3> ghc 7.4.1 is out!
04:45:25 <edsko> @type 5
04:45:25 <flux> mekeor, all functions return for all values
04:45:25 <lambdabot> forall t. (Num t) => t
04:45:44 <edsko> @run 5 + 3
04:45:44 <lambdabot>   8
04:45:57 <mekeor> flux: that is no "error"s, right? okay, i see.
04:46:05 <flux> mekeor, yep, no "error", no exceptions, etc
04:46:09 <rwbarton> no nontermination
04:46:16 <koeien3> x = x is forbidden
04:48:18 <MaskRay> not forbidden
04:48:23 <MaskRay> though it is bottom
04:48:32 <koeien3> (in a total language)
04:48:40 <byorgey> MaskRay: the context was mekeor asking what a total language is.
04:49:10 <MaskRay> o
04:50:36 <Jafet> In total, there is totally more than one total language
04:54:17 <aleator_> What was the handy function for converting CDoubles to Doubles without going through rationals in the process?
04:55:02 <Peaker> aleator_: I'm not sure but maybe realToFrac?
04:55:10 <Peaker> @src realToFrac
04:55:11 <lambdabot> realToFrac = fromRational . toRational
04:55:14 <Peaker> oh, sorry :)
04:55:23 <quicksilver> don't believe the src.
04:55:26 <quicksilver> it should work.
04:55:34 <aleator_> Peaker: realToFrac seems to be surprisingly slow in random cases
04:55:35 <Peaker> rewrite rules?
04:55:37 <quicksilver> there should be optimisation rules for it
04:56:34 <aleator_> quicksilver: How to ensure that they are triggered? Sometimes realToFrac hogs half the runtime.
04:57:43 <Jafet> To begin with, they may only be triggered with -O
04:58:10 <quicksilver> I don't know, aleator_, I'd have to look into it.
04:58:21 <quicksilver> examine the code, locate the rules, speak to the library maintainers
04:58:34 <quicksilver> I have some vague memory this might have been improved not so long ago.
04:58:38 <aleator_> Ok. Thanks!
04:58:48 <aleator_> I'll try the new ghc and see what happens
04:59:05 <Jafet> Read the core, or use the appropriate GHC options
04:59:44 <quicksilver> yes, actually I meant core. s/code/core/;
05:00:43 <quicksilver> since they are actually the same type on most platforms, realToFrac *should* get compiled away entirely
05:00:58 <quicksilver> but I do have some memory of people complaining it didn't, so there are probably circumstances where it doesn't (or didn't) work
05:01:28 <aleator_> Perhaps something defaults to rational and gets converted to that in between?
05:01:47 <aleator_> Also, I just empirically found out that CInt /= Int. :)
05:05:22 <Jafet> http://www.haskell.org/ghc/docs/latest/html/users_guide/rewrite-rules.html
05:12:34 <weltensegler> >[9 % 50, 9 % 25 .. 1] :: [Rational]
05:13:17 <weltensegler> @run [9 % 50, 9 % 25 .. 1] :: [Rational]
05:13:18 <lambdabot>   [9 % 50,9 % 25,27 % 50,18 % 25,9 % 10,27 % 25]
05:13:35 <weltensegler> i am back.
05:13:52 <weltensegler> Now, shouldn't Rationals behave in this case?
05:14:01 <koeien3> they do.
05:14:13 <MaskRay> [parallel,hdbc] i have some file to parse(attoparsec) and then write parsed info to sqlite3 db(hdbc). how can i utilize multithreads to speed up?
05:14:16 <weltensegler> how so?
05:14:29 <koeien3> if you step with epsilon, the last number is the largest number x such that x + eps <= ub
05:14:49 <koeien3> err, eps/2
05:14:55 <koeien3> that made no sense.
05:15:03 <quicksilver> ub + (eps/2) I believe
05:15:13 <koeien3> yeah.
05:15:19 <koeien3> x <= ub + eps/2
05:17:52 <Axman6> MaskRay: parse in one thread, and put results in a Chan, which is read by another thread which writes to the database?
05:19:46 <weltensegler> koeien3, so x should be less than the upper bound, right?
05:20:16 <koeien3> no
05:20:27 <weltensegler> oh!!
05:21:59 <MaskRay> Axman6: nice, though a bit tricky to me... is it correct to use `parMap rdeepseq (parse myparser) files' with `+RTS -N2' ? as i can't see sensible difference..
05:22:37 <Axman6> MaskRay: threading in haskell is dead easy. give it a go. it will literally be about three lines of code to get that working
05:22:39 <MaskRay> it is even slower with -N4 -N5...
05:23:33 <Axman6> do { chan <- newChan; forkIO (writer "db.sqlite3" chan); readerFunc "input.file" chan }
05:24:26 <MaskRay> thanks. i'll try it
05:25:06 <Axman6> you're probably getting problems because you're trying to do a lot of IO at once. with this version, you do the reading of each file consequtively, and do the writing to the DB consequtively as well, but those operations can be running at the same time
05:26:17 <weltensegler> koeien3, but what about
05:26:20 <weltensegler> @run [0,4..11]
05:26:21 <lambdabot>   [0,4,8]
05:26:39 <weltensegler> should this then go up to 12?
05:27:02 <koeien3> weltensegler: it's not really consistent.
05:27:09 <koeien3> weltensegler: i don't like the instance either.
05:27:35 <Axman6> > [0,4..11.0]
05:27:36 <yezariaely> If I user-install a package using cabal, and after that I built a package, it still says the already installed packages are required, what can I do?
05:27:36 <lambdabot>   [0.0,4.0,8.0,12.0]
05:28:27 <koeien3> weltensegler: it's defined this way in the Haskell Report.
05:28:52 <weltensegler> koeien3, thanks for pointing out! But i still wonder why.
05:28:55 <tromp__> > takeWhile (<=11.0) [0.4,0.8..]
05:28:55 <lambdabot>   [0.4,0.8,1.2000000000000002,1.6000000000000003,2.0000000000000004,2.4000000...
05:29:11 <koeien3> weltensegler: otherwise [0.0,0.1..1.0] might be [0.0,...,0.9]
05:29:18 <tromp__> > takeWhile (<=11.0) [4,8..]
05:29:19 <lambdabot>   [4.0,8.0]
05:29:21 <koeien3> because of floating point inaccuracies
05:29:32 <rwbarton> anyone who writes [0,4..11] in a program needs their head examined
05:29:34 <koeien3> (i would still prefer that.)
05:29:34 <weltensegler> koeien3, but not for Rationals.
05:29:43 <tromp__> what a braindead decision
05:29:43 <rwbarton> [0,4..11] should just be an error
05:30:04 <koeien3> rwbarton: of course, one can replace 11 by a variable, and then it's less obvious what's happening
05:30:13 <yezariaely> tromp__: then, maybe you could give me a hint for my question :-p
05:30:17 <rwbarton> then it is an error if the variable equals 11
05:30:29 <koeien3> one could do that
05:30:35 <koeien3> i just avoid [..] tbh
05:30:40 <tromp__> what question, yezariaely?
05:30:46 <cmccann> I still maintain that the [ ... ] syntactic sugar is used to mean at least two or three distinct things
05:30:51 <cmccann> that shouldn't really be conflated as they are
05:30:56 <rwbarton> removing [a,b..c] entirely would be better than the common suggestions for "fixing" it that are made here
05:31:11 <yezariaely> If I user-install (i.e. as normal user, non-root) a package using cabal, and after that I built a package, it still says the already installed packages are required, what can I do?
05:31:11 <koeien3> (well, I use them only with integers and without the "step")
05:31:16 <yezariaely> tromp__: this
05:32:21 <weltensegler> koeien3, but for Rationals there should be no floating point inaccuracies.
05:32:55 <koeien3> there shouldn't, but it has been decided that it should "mimick" Double/Float
05:33:32 <weltensegler> I would like to meet those who decided this.
05:33:33 <tromp__> no idea, yezariaely
05:34:11 * mux bets that by "meet", weltensegler meant "bludgeon to death"
05:34:19 <xplat_> is there a haskell library that will just parse json, nothing fancy?
05:34:26 <koeien3> xplat_: aeson
05:34:43 <tromp__> > [10.0,8,0 .. 0.1]
05:34:43 <lambdabot>   <no location info>: parse error on input `..'
05:34:51 <tromp__> > [10.0,8.0 .. 0.1]
05:34:51 <lambdabot>   [10.0,8.0,6.0,4.0,2.0,0.0]
05:34:53 <yezariaely> tromp__: thx, anyway, and back to the wonderfull discussion :D
05:34:56 <xplat_> koeien3: no, aeson puts Objects into hashmaps, which destroys order
05:35:03 <koeien3> JSON does not define an order afaik
05:35:27 <koeien3> relying on that is extremely dangerous
05:36:06 <xplat_> it doesn't, but i'm dealing with firefox's idea of json, which is just barely compliant for read-only and i'm not confident it's compliant for read-write
05:36:07 <koeien3> from the json.org site: "An object is an unordered set of name/value pairs."
05:37:13 * weltensegler is very thankful for your help, but has to leave now.
05:37:59 <xplat_> hence why i want a library that just parses json, without depending on the semantics of anything fancier than unicode escapes
05:38:30 <koeien3> you can probably rip some code out of aeson, the tokenizer
05:39:32 <xplat_> i know i can rip code out of aeson, i asked if there was an existing library
05:39:39 <ChristianS> xplat_: where does firefox prescribe an order? maybe you should first check whether it actually cares?
05:40:17 <koeien3> i doubt it. what you're parsing is not json, it's "ordered json"
05:40:41 <MaskRay> Axman6: even slower ...
05:40:45 <xplat_> well, the existing library did it in scala, fwiw
05:41:06 <EvanR> dont rely on order of json fields
05:41:25 <EvanR> dont really know why youd want to
05:41:48 <MaskRay> Axman6: http://hpaste.org/63609
05:41:59 <xplat_> my app doesn't care what order the fields come in, it just wants to write them back out in the same order they came in to prevent other people's software from choking
05:42:30 <EvanR> liberal input and conservative output defeats the whole purpose of the convention xD
05:43:13 <xplat_> yes, but having to fix firefox bugs to get my software working defeats the whole purpose of writing this in a real language
05:43:51 <ChristianS> xplat_: there are some other json packages on hackage. maybe they return the data in a form that's more convenient to you?
05:44:45 <EvanR> firefox relies on the order? o_O
05:46:29 <xplat_> EvanR: i don't have any particular reason to think it relies on the order, but since it never expects this file to be written by anything but firefox, there is almost certainly nothing in place to make sure of this
05:47:02 <EvanR> you dont have an evidence that theres a bug in ff?
05:47:09 <yezariaely> How can I set a library search path for ghc?
05:47:11 <EvanR> or anything else?
05:47:51 <xplat_> i don't want to be the one to discover whether there's a bug in ff
05:47:55 <quicksilver> xplat_: that's a very strange thing to think.
05:48:06 <EvanR> let me introduce you to 'you aint gonna need it' ;)
05:48:18 <quicksilver> xplat_: a more natural thing to think is "firefox probably uses a JSON parser for this and will probably ignore object ordering"
05:48:27 <quicksilver> it also seems to trivial to test I'd just TIAS
05:49:02 <ChristianS> yes, everybody who uses a standard json parser won't care about ordering
05:49:11 <xplat_> firefox has historically not used a compliant json parser (or builder) for this file
05:50:01 <ChristianS> xplat_: well, just write the file in your own ordering and wait what happens :-)
05:50:03 <EvanR> ill be sure to stop asking questions about evidence since they will be categorically ignored
05:50:07 <ChristianS> if nothing, you have one problem less
05:50:26 <ChristianS> if something, you have a bugreport to file
05:52:26 <adimit> Read Int errors out when presented with non-int String inputs. Is there some function String -> Maybe Int or, more general (Read b) => String -> Maybe b or somesuch? Hoogle knows maybeRead from Network.CGI.Protocol, but I don't really think I want to add that package to my deps.
05:52:28 <xplat_> what i don't think you seem to understand is i want to write a tool useful to me, not a test suite for firefox's internals
05:52:41 <Botje> adimit: check the reads function
05:52:43 <Botje> :t reads
05:52:44 <lambdabot> forall a. (Read a) => String -> [(a, String)]
05:52:55 <merijn> > reads "a" :: String
05:52:56 <lambdabot>   Couldn't match expected type `GHC.Types.Char'
05:52:56 <lambdabot>         against inferred type...
05:53:03 <merijn> > reads "a" :: Int
05:53:04 <lambdabot>   Couldn't match expected type `GHC.Types.Int'
05:53:04 <lambdabot>         against inferred type ...
05:53:09 <merijn> hmm
05:53:12 <koeien3> > reads ("a" :: String)
05:53:13 <lambdabot>   []
05:53:19 <koeien3> merijn: ^
05:53:25 <Botje> > reads "a" :: [(Int, String)]
05:53:26 <lambdabot>   []
05:53:28 <Botje> > reads "a" :: [(String, String)]
05:53:29 <lambdabot>   []
05:53:30 <merijn> koeien3: No, that makes a String
05:53:34 <merijn> Botje++
05:53:35 <adimit> Botje, merijn, koeien3, thanks :-)
05:53:59 <Botje> (that probably should've been (Char, String))
05:54:13 <merijn> Botje: Yeah :p
05:54:34 <merijn> > reads "\"a\"" :: [(String, String)]
05:54:35 <lambdabot>   [("a","")]
05:54:37 <xplat_> i've spent too long on this already, it would have been faster to check all the relevant packages on hackage by hand
06:03:46 <xplat_> EvanR: about 'evidence' ... i find a better approach with multimillion line, multithreaded, multi-decade-old C++ codebases is to assume things are buggy until i have evidence otherwise ...
06:04:19 <merijn> I assume anything is buggy, lines of code, language and threading be damned...
06:04:43 <EvanR> xplat_: so you seek evidence of non existence of something ;)
06:04:51 <ChristianS> xplat_: if you assume everything to be
06:05:00 <ChristianS> sorry, nevermind
06:05:06 <EvanR> its like proving god doesnt exist!
06:05:15 <xplat_> EvanR: proof of nonexistence is hard, evidence of nonexistence less so
06:05:31 <koeien3> EvanR: yes, theism vs atheism debates in #haskell, that'll be productive. :)
06:05:42 <merijn> Proof of nonexistence is impossible unless you proscribe to a gnostic philosophy
06:06:06 <merijn> (Actually, so is proof of existence, so I guess I could just generalise that to "proof")
06:06:07 <EvanR> seems about as productive as intuitionistic debates
06:07:37 <merijn> koeien3: Simple, just derail into gnosticism vs agnosticism debate :p
06:08:45 * hackagebot interpol 0.2.2 - GHC preprocessor and library to enable variable interpolation in strings  http://hackage.haskell.org/package/interpol-0.2.2 (AlexandruScvortov)
06:09:11 * cmccann denies the existence of the infinite
06:09:42 <EvanR> prove it!
06:11:26 <xplat_> EvanR: before asking people to prove things, please prove you exist
06:11:46 <cmccann> wait, that's right, I decided to be a co-ultrafinitist instead. infinities do exist, and include sufficiently large numbers.
06:12:45 <EvanR> http://en.wikipedia.org/wiki/Monad_(Gnosticism)
06:13:05 <merijn> cmccann: co-ultrafinitist? That's just a normal in infinity believing person, isn't it?
06:13:12 <EvanR> i finally get monads!
06:13:23 <xplat_> merijn: apparently it
06:13:25 <koeien3> merijn: i object to your usage of "normal" here.
06:13:35 <koeien3> merijn: finitists are very normal human beings.
06:13:37 <xplat_> is someone who doesn't believe all natural numbers are finite
06:13:37 <koeien3> ;)
06:13:45 <merijn> koeien3: That's fine, because I don't care about other people :)
06:14:04 <EvanR> which natural is not finite?
06:14:05 <cmccann> xplat_, yes, sufficiently large natural numbers are infinite. that's my position.
06:14:35 <cmccann> EvanR, well I don't know off the top of my head. you'll have to pick one and check.
06:14:37 <mokus> a more interesting question would be which natural number is the smallest infinite one
06:15:33 <EvanR> does this violate the well ordering principle
06:16:17 <frerich> mokus: I don't htink that's very interesting, to the best of my knowledge infinity is not a number (let alone a member of the set of natural numbers), so there's no point in trying to compare it with natural numbers for bringing it into an order.
06:16:40 <xplat_> how do you check?  pick a delta^0_0-definable number, prove it exists, and then see if the turing machine that searches for it by counting up from 0 and checking the property halts?
06:16:41 <cmccann> frerich, this is not entirely a serious conversation ;]
06:16:43 <mokus> frerich: the question is to be posed to someone who believes there are natural numbers that are infinite
06:16:55 <merijn> frerich: Well, if you are to accept the presence of non-finite natural numbers and the fact that naturals are well-ordered, then a smallest infinite number exists
06:16:55 <roconnor> EvanR: (2^64)^(2^64) isn't finite
06:17:10 <EvanR> roconnor: how do you figure
06:17:17 <roconnor> > (2^64)^(2^64)
06:17:22 <lambdabot>   mueval: ExitFailure 1
06:17:22 <lambdabot>  mueval: Prelude.undefined
06:17:24 <frerich> cmccann, mokus: Oh drat, that's what I get for not reading the backlog.
06:17:26 <mux> as a developer, as far as I'm concerned, 2^64 is inifinity
06:17:30 <roconnor> EvanR: ta
06:17:35 <mux> similarly, 2^32 is "a lot"
06:17:39 <merijn> mux: :D
06:17:40 <cmccann> that said, I'm also half-serious
06:17:44 <frerich> cmccann, mokus: Pity, I was planning to use the metaphor "Which of these burritos is the smallest among this set of apples".
06:17:54 <frerich> Another unused chance.
06:18:05 <EvanR> by this logic, eleven is infinite because i only have ten fingers xD
06:18:09 <merijn> mux: As a developer, as far as I'm concerened, 2^32 is not nearly enough >.>
06:18:10 <roconnor> > 2^64
06:18:14 <lambdabot>   mueval-core: Time limit exceeded
06:18:25 <xplat_> merijn: you could accept that naturals are almost-well-ordered -- that is, that any descending chain is indexed by a prefix of the naturals
06:18:33 <roconnor> hmm, I didn't think 2^64 was that bad
06:19:07 <EvanR> > 2^64
06:19:08 * cmccann defines "infinite" as "at least one more than you end up needing"
06:19:09 <lambdabot>   18446744073709551616
06:19:10 <b0fh_ua> Hello! Given the tuple (Int,String) how can I compose arrows to invoke function f :: String -> MyData on second item in tuple in case if first item has some pre-defined value?
06:19:17 <EvanR> roconnor: glitch in the matrix
06:19:30 <roconnor> cmccann: I regularly use numbers larger than 2^64
06:19:40 <roconnor> oops
06:19:41 <mux> merijn: yeah, "a lot" is quite often "not enough" *grin*
06:19:43 <cmccann> well, 2^64 is clearly finite
06:19:44 <roconnor> shoudl be for mux
06:19:50 <roconnor> mux: I regularly use numbers larger than 2^64
06:19:56 <merijn> mux: As I learned when doing pointer arithmetic in the high end of my address space (I never knew pointer arithmetic was signed, but after 2 weeks of debugging I don't think I'll ever forget)
06:20:02 <osa1> I'm trying to compile and link some code from real world haskell but getting this error: http://paste.pocoo.org/show/550297/ can anyone help me?
06:20:03 <mux> roconnor: stop playing with project euler and get to real coding. :-P
06:20:16 <roconnor> mux: DSA signatures
06:20:42 <mux> DSA is old school, switch to ECDSA
06:21:00 <koeien3> osa1: use --make
06:21:25 <mux> merijn: I find ssize_t even more infuriating ;-)
06:21:32 <merijn> Why?
06:21:36 <roconnor> mux: I mean ECDSA
06:21:43 <osa1> koeien3: do you mean ghc -o simple Main.hs SimpleJSON.o --make ?
06:21:43 <roconnor> sorry
06:21:49 <mux> roconnor: well, I have no witty remark to do now :-P
06:21:58 <mux> merijn: because it shouldn't exist?
06:21:59 <koeien3> osa1: i'm not sure where the --make should go
06:22:11 <koeien3> osa1: perhaps ghc -o simple --make Main.hs SimpleJSON.o
06:22:17 <merijn> mux: What do you think should exist instead then?
06:22:30 <osa1> koeien3: nope, didn't work
06:22:38 <merijn> You need some guaranteed way of indexing arrays...
06:22:43 <osa1> koeien3: actually I've tried every place but didn't work
06:23:10 <koeien3> is there a good reason you don't just do ghc -o simple --make Main.hs ?
06:23:18 <koeien3> osa1: ghc should be able to find SimpleJSON.hs
06:23:24 <mux> merijn: all you need is size_t, nothing more; actually, the C standard doesn't even define ssize_t, it's POSIX crap
06:23:39 <merijn> mux: Oh, wait I missed the extra s
06:23:43 <merijn> What does that even mean?
06:23:48 <mux> signed size_t
06:23:50 <koeien3> signed
06:23:52 <osa1> koeien3: ok, ghc --make Main.hs worked
06:23:53 <osa1> koeien3: thanks
06:23:55 <merijn> ...
06:24:04 <koeien3> osa1: ghc --make is automatic dependency chasing
06:24:07 <xplat_> i highly support the use of DSA for anti-tampering purposes since it is so easy to screw up and leak the key :)
06:25:07 <merijn> xplat_: Time to promote NaCl for all crypto :p
06:26:00 <xplat_> (i even more highly support using nothing at all for anti-tampering purposes, but if you must use anything use an in-house implementation of DSA)
06:27:44 <mux> if all you need is anti-tampering, it doesn't even make sense to use DSA or any asymmetrical crypto algorithm
06:29:03 <deggis> problems with updating cabal-install with fresh ghc 7.4.1 http://hpaste.org/63612
06:29:56 <hpaste> killy pasted “palindrome” at http://hpaste.org/63613
06:30:12 <killy> guys, I need a newbie question
06:30:33 <koeien3> killy: you still have reverse xs there
06:30:36 <killy> why doesn't the function isPalindromeSentence that I pasted work?
06:30:43 <koeien3> killy: replace it by reverse ys
06:31:04 <koeien3> (the nicest solution is, isPalSentence = isPalindrome . filter (/= ' ')
06:31:05 <killy> argh...
06:31:11 <killy> right..
06:31:25 <killy> yeah, I know, but I was trying make this one work :)
06:32:25 <dcoutts> deggis: we'll be doing a new release that can be built with 7.4 soonish
06:32:59 <dcoutts> deggis: in the mean time, the current release built with older ghc will work with 7.4
06:33:16 <dcoutts> ie an existing cabal binary can use the latest ghc to compile other stuff
06:34:23 <deggis> dcoutts: ah, okay. good to know
06:37:53 <Peaker> b0fh_ua: onTup p f t = if (p . fst) t then second f t
06:44:45 <b0fh_ua> Peaker: with arrows )
06:45:07 <b0fh_ua> i think ( p .fst) can be replaced as well?
06:45:35 <flazz> how wrong is it to think of monoids as "things that can be appended to, with an identity append"?
06:45:47 <koeien3> flazz: that's more or less what they are.
06:45:56 <cmccann> "append" is too specific in some ways
06:45:56 <koeien3> flazz: as long as you don't think of appending as commutative
06:46:10 <flazz> why would i?
06:46:16 <koeien3> because 2 + 3 = 3 + 2
06:46:28 <cmccann> I think list appending is the canonical example here
06:46:35 <koeien3> yes, list is the free monoid
06:46:36 <cmccann> particularly since that's the free monoid
06:47:07 <cmccann> as horrible as the names mempty and mappend are, lists are at least a decent source of intuition for monoids :T
06:47:26 <Peaker> b0fh_ua: Not in a useful way.. fclabels can, perhaps
06:47:47 <Peaker> @type let     onTup p f t = if (p . fst) t then second f t     in onTup
06:47:47 <lambdabot> parse error on input `in'
06:48:00 <Peaker> @type let     onTup p f t = if (p . fst) t then second f t else id     in onTup
06:48:01 <lambdabot>     Couldn't match expected type `(a, c)'
06:48:01 <lambdabot>            against inferred type `a1 -> a1'
06:48:01 <lambdabot>     In the expression: id
06:48:21 <Peaker> @type let     onTup p f t = if (p . fst) t then second f t else t     in onTup
06:48:22 <lambdabot> forall a b. (a -> Bool) -> (b -> b) -> (a, b) -> (a, b)
06:49:09 <hpaste> killy pasted “syntax error” at http://hpaste.org/63614
06:49:23 <killy> ok, I need some help with the syntax
06:50:24 <killy> I;m trying to learn Haskell from LYAH and by solving 99 Haskell Problems, don't know if that's a good approach
06:50:55 <killy> I could use some advice on learning sources if there are any better for a beginner
06:51:19 <rwbarton> You can't put a type declaration (or anything else) in the middle of patterns defining a single function.
06:51:47 <killy> where should I put them?
06:51:56 <killy> before definitions?
06:51:58 <rwbarton> above all the patterns
06:52:05 <rwbarton> I see that's not your real problem though
06:52:08 <rwbarton> but I have to run
06:52:14 <koeien3> yeah flatten [1] is an error
06:52:22 <Botje> killy: you promise flatten :: [a] -> a
06:52:28 <Botje> killy: but then you write flatten [] = []
06:52:31 <koeien3> also that.
06:52:52 <Botje> killy: which means that a has to be a list-y thing, instead of just any type
06:52:58 <killy> so... does this mean that a function has to always accept and return the same type of input/output?
06:53:06 <koeien3> no
06:53:30 <koeien3> flatten [] = [] is correct
06:53:36 <koeien3> flatten [x] = x is correct
06:53:53 <koeien3> but, this is not all that's possible.
06:54:02 <koeien3> in general you can write flatten [] = []; and flatten (x:xs) = ...
06:54:03 <killy> then why doesn't flatten [1] work?
06:54:22 <koeien3> ah now i get your question I think
06:54:27 <Azel> Because flatten [] = [] means the return type should be a list type
06:54:31 <killy> yeah, I'll be getting to this more general case, so far i want to figure out the syntax
06:54:36 <Azel> And 1 is not a list
06:54:58 <koeien3> yes, a function has a type. if flatten [] = [] , then in flatten [x] = x, x should have the same type
06:55:18 <killy> ok, so this means that all flatten definitions I always have to return the same type from all of them
06:55:22 <koeien3> yes
06:55:27 <killy> well... thinking about it for a moment this makes sense
06:55:46 <koeien3> you cannot write, for example, f [] = 2 ; f (x:xs) = "a string"
06:57:13 <killy> mhm, thanks for explanation
06:59:15 <killy> error messages are sometimes misleading (or at least I haven't learned to understand them yet"
06:59:29 <killy> "cannot construct the infinite time"
06:59:41 <koeien3> yes they are sometimes misleading
06:59:45 <koeien3> this one isn't really
06:59:54 <koeien3> but the "num instance not found" can be
07:00:07 <cmccann> an infinite type means that it thinks a type should contain itself, like if you have two arguments of the same type and apply one to the other
07:00:21 <koeien3> :t let x = [x] in x
07:00:21 <lambdabot>     Occurs check: cannot construct the infinite type: t = [t]
07:00:22 <lambdabot>       Expected type: t
07:00:22 <lambdabot>       Inferred type: [t]
07:00:45 <cmccann> then "a" needs to be a function (a -> b) where a = a -> b
07:09:39 <Taneb> Is it possible to do something like data ArrowType a => Quiver a = blahdy blah?
07:09:48 <Taneb> If it is possible, is it recommended?
07:10:01 <koeien3> yes, and no
07:10:36 <byorgey> it probably wouldn't do what you think/want anyway.
07:10:59 <byorgey> much better is to just say  data Quiver a = blah  and then put an ArrowType constraint on all the Quiver functions that need it.
07:12:09 <byorgey> GHC trivia: the record field used to represent a context on a data declaration like that is called 'stupidTheta'
07:12:57 <byorgey> which is presumably a combination of the Greek letter used to represent that part of the syntax in some paper, and the way the GHC developers feel about it.
07:14:55 <Ken`> is there a nice LaTeX trick to print >>=?
07:15:24 <roconnor> Ken`: I'm only aware of unnice tricks
07:15:41 <ChristianS> if i remember correctly, there is talk about deprecating the 'stupidTheta' in a future version of haskell, which is further reason not to use it
07:15:50 <Ken`> roconnor: what would be your nicest unnice trick?
07:15:54 <byorgey> one nice trick is to use lhs2TeX.  But that is fairly heavyweight if all you want to do is print >>= .
07:16:02 <byorgey> ChristianS: indeed.
07:16:10 <Ken`> actually, I'm trying to typeset Coq code
07:16:32 <killy> just realized I can't do something like 'blabla (x:x:xs)' in a function definition
07:16:41 <killy> shame, works in Prolog and Erlang
07:16:51 <nus> ηλίθιοθ
07:17:31 <quicksilver> killy: this is, in a sense, because haskell patterns don't assume Eq
07:17:55 <quicksilver> although it's a bit more subtle than that. It's about different kinds of unification.
07:17:55 <koeien3> well ghc could infer that
07:17:56 <drdo> I want to provide class instances for some types but i don't depend on them, how would i do this with cabal so that i only get those instances (and consequently depend on those packages) if i actually use them?
07:18:00 <roconnor> Ken`: IIRC the unnice trick is to insert some negative space between the characters of > > and =
07:18:16 <byorgey> Ken`: lhs2TeX defines it as \newcommand{\bind}{\mathbin{>\!\!\!>\mkern-6.7mu=}}
07:18:29 <Ken`> thanks
07:18:35 <quicksilver> koeien3: it could but it would be pretty horrid if it did.
07:18:40 <dcoutts> drdo: there's no clever way to do it
07:19:01 <dcoutts> drdo: you have to decide if you depend on them or not
07:19:13 <killy> I guess this would require unification of some sort
07:19:42 <bitbucket_> killy: You could use "blabla (x:y:xs) | x == y = ..."
07:19:57 <shachaf> quicksilver: Something similar happens for Num and OverloadedStrings now.
07:20:22 <shachaf> killy: Anyway, you certainly don't want structural equality.
07:20:23 <killy> yes, that's what I did
07:20:47 <quicksilver> shachaf: they are both horrible.
07:20:48 <killy> different languages, different idioms
07:21:33 <shachaf> And Eq is "just a type class" -- it's not nice for it to exist in any sense at the language level.
07:21:54 <shachaf> quicksilver: I agree (although convenient).
07:21:59 <koeien3> well Enum is
07:22:06 <koeien3> with the [..] notation
07:22:10 <koeien3> Monad is
07:22:14 <koeien3> why not Eq?
07:23:07 <Gulshan> hi
07:23:12 <byorgey> hi Gulshan
07:23:14 <koeien3> hi Gulshan
07:23:25 <quicksilver> I think the point is more about the difference between structural pattern matching and semantic equality
07:23:26 <Gulshan> how can i learn this language?
07:23:33 <drdo> dcoutts: meh, do you know if some mechanism to enable this has been discussed already?
07:23:34 <quicksilver> pattern matching is a strongly syntactic, top-down notion
07:23:38 <cmccann> @where lyah
07:23:38 <lambdabot> http://www.learnyouahaskell.com/
07:23:51 <Gulshan> fuck you
07:24:01 <byorgey> um.
07:24:06 <quicksilver> pattern matching is always tractable and can often be partially performed at compile-time
07:24:11 <Gulshan> am i talking with computer?
07:24:17 <Gulshan> or a human
07:24:22 <byorgey> Gulshan: yes, we are all computers
07:24:23 <koeien3> i'm fairly certain i'm human.
07:24:26 <byorgey> programmed in Haskell
07:24:28 <zomg> Beep Bop.
07:24:33 <zomg> Only something a robot would say
07:24:34 <quicksilver> whereas == is "semantic equality" and might perform arbitrary computation
07:24:45 <koeien3> quicksilver: i see the point, yeah.
07:24:50 <ChristianS> what's wrong with 900 very smart computers anyway?
07:24:52 <Gulshan> so what type of language is it?
07:24:55 <PatrickRobotham> Hello <insert name here>
07:25:01 <Gulshan> gulshan
07:25:44 <Gulshan> hello?
07:26:15 <dcoutts> drdo: we don't really have a solution. You cannot (or should not) make packages with conditional dependencies because it's incompatible with traditional package management (think .deb / .rpm)
07:26:28 <PatrickRobotham> Haskell is a statically typed functional programming language.
07:26:44 <Botje> PatrickRobotham: THIS. STATEMENT. IS. FALSE.
07:26:50 <zomg> Gulshan: You were given a link to a site which tells you about haskell and also teaches you haskell. Your response was "fuck you"
07:26:51 <dcoutts> drdo: the solution is to put the class declarations and the instances in the right place (right package)
07:27:01 <dcoutts> drdo: and to avoid orphan instances
07:27:13 <PatrickRobotham> Botje: *Explodes*
07:27:22 <Gulshan> 2+2
07:27:23 <Botje> only one robot on the channel
07:27:24 <Botje> check!
07:27:27 <dcoutts> drdo: classes and instances just are not as modular as you might first think
07:27:40 <byorgey> > 2+2
07:27:40 <lambdabot>   4
07:27:54 <zomg> :t foo
07:27:54 <cmccann> Gulshan, being rude and demanding is not really the best way to get people to help you
07:27:55 <lambdabot> Not in scope: `foo'
07:28:01 <zomg> :t ((.)(.))
07:28:02 <lambdabot> forall a b (f :: * -> *) (f1 :: * -> *). (Functor f, Functor f1) => f1 (a -> b) -> f1 (f a -> f b)
07:28:34 <Gulshan> ok lets start from begning
07:28:53 <dcoutts> drdo: that means putting the instance either in the package that defines the class, or the package that defines the type that is the instance of the class
07:28:58 <drdo> dcoutts: I don't seem a problem with just mapping an optional dependency to some preprocessor name and wrapping stuff in ifdef's
07:29:12 <cmccann> dcoutts, btw, I've set up a copy of the hackage2 codebase so that people can see it
07:29:17 <cmccann> and will probably hack on the code a bit
07:29:20 <dcoutts> cmccann: great
07:29:47 <dcoutts> cmccann: we've also got access to a VM when we're ready to make it public
07:30:05 <drdo> *don't see
07:30:06 * cmccann is running it at hackage2.uptoisomorphism.net:8080
07:30:28 <cmccann> it's using a "spare cycles on a pocket calculator" size EC2 instance
07:30:29 <koeien3> nice hostname, lol
07:30:43 <dcoutts> drdo: that's not really compatible with sensible package management
07:30:45 <Gulshan> c++
07:31:02 <dcoutts> cmccann: how much memory do you have on that instance?
07:31:11 <cmccann> probably not enough :P
07:31:17 <Gulshan> don't know
07:31:27 <dcoutts> cmccann: the full package set makes the server take 8GB +
07:31:30 <drdo> dcoutts: What's the issue?
07:31:41 <Gulshan> i don't know
07:31:46 <cmccann> yeah I don't have the full package set there
07:31:48 <Gulshan> hi how are you?
07:31:49 <dcoutts> drdo: the package manager wants to know if your package depends on the thing or not
07:31:58 <Gulshan> hi how are you?
07:32:05 <cmccann> dcoutts, I'll move it to a bigger instance if I want to get a full mirror running
07:32:35 <dcoutts> drdo: also, whether you provide the instance changes the interface of your package, other packages would depend on that choice (which is not expressible in most package systems)
07:33:04 <cmccann> I've also dropped a copy of the code on github to make it easier for more people to hack on it, pushing changes back to darcs can be figured out if and when enough is done to warrant me figuring it out
07:33:10 <drdo> dcoutts: Yes, that last thing is a problem, hmm
07:33:19 <byorgey> Gulshan: If you have particular questions about Haskell we are happy to help.
07:33:51 <dcoutts> cmccann: if you'd like to test, the most useful thing would be checking the dump/restore round trip works
07:34:13 <byorgey> Gulshan: if you want to learn Haskell we recommend starting with http://www.learnyouahaskell.com/ . But we aren't going to just teach you Haskell over IRC.
07:34:27 <dcoutts> cmccann: that's one of the important parts that we need to test before/during the switchover process
07:34:29 <cmccann> dcoutts, at the moment I'm just poking around, I've never even used happstack before and I'm trying to get a feel for how it all works
07:34:35 <dcoutts> sure
07:34:38 <dcoutts> thanks
07:34:43 <byorgey> cmccann++
07:34:56 <koeien3> cmccann++
07:35:03 * cmccann is also currently unemployed so has a bit of extra free time :P
07:35:21 <byorgey> boo =(
07:35:30 <byorgey> but yay for extra free time
07:35:48 <koeien3> yay tags!
07:35:57 <koeien3> easier to filter on license and stuff
07:35:59 <koeien3> nice
07:36:21 <cmccann> koeien3, and oh yeah, glad you like my domain :P
07:36:48 <cmccann> the github repo is https://github.com/isomorphism/hackage2 btw
07:47:04 <djanatyn> Hmm. Say I had a string, "2012/1/12"
07:47:17 <djanatyn> how do I turn that into [2012,1,12]?
07:47:26 <djanatyn> I've been looking at Data.List but I don't know which function to use.
07:47:57 <quicksilver> there isn't a standard function for that kind of operation
07:48:07 <quicksilver> it's rather simple to use 'dropWhile' twice
07:48:12 <tromp__> look at Data.List.Split
07:48:15 <quicksilver> or you could get the "split" package from hackage
07:48:16 <danr> djanatyn: you can use splitOn from Data.List.Split
07:48:19 <djanatyn> I guess I need something like (words), but where I can specify the space character
07:48:28 <quicksilver> which contains the module that tromp and danr just recommended
07:48:31 <danr> djanatyn: http://hackage.haskell.org/packages/archive/split/0.1.2/doc/html/Data-List-Split.html
07:48:34 <djanatyn> I guess I'll just use dropWhile
07:48:44 <quicksilver> or you could use regexp but please don't
07:48:50 <tromp__> > map read . splitOn "/" $ "2012/1/12" :: [Int]
07:48:51 <lambdabot>   Not in scope: `splitOn'
07:48:57 <djanatyn> quicksilver: heh, not doing that :)
07:49:38 <killy> can I use 'otherwise' in a case expression?
07:49:43 <quicksilver> yes
07:49:50 <quicksilver> but not in the way you think :)
07:49:55 <quicksilver> use otherwise with guards
07:49:59 <quicksilver> just use _ for a pattern
07:50:09 <quicksilver> case foo of Bar -> 1; _ -> 2;
07:50:50 <killy> mhm
07:51:34 <killy> Haskell syntaz is a bit tough, especially when moving from Matlab :)
07:51:51 <quicksilver> otherwise is actually just a longhand for True
07:51:54 <quicksilver> to look nice in guards.
07:52:08 <djanatyn> Is there a quick way to pass each item in a list as arguments to a function? :)
07:52:10 <djanatyn> or am I doing it wrong?
07:52:40 * cmccann replaces "otherwise" with "okFineWhatever"
07:52:47 <danr> djanatyn: use map?
07:53:00 <djanatyn> I'm trying to create dates from strings in a file, using Date.Time.Calendar
07:53:01 <cmccann> djanatyn, you probably want a map or a fold
07:53:29 <kofron> @killy yeah, no joke re: matlab.  but programming in matlab is such a chore...
07:53:30 <djanatyn> oh, snap. I just need a fold.
07:53:30 <lambdabot> Unknown command, try @list
07:53:46 <djanatyn> I've been doing way too much imperative stuff - I would have gotten that immediately a while ago
07:54:04 <djanatyn> I'll just fold my function over a list of integers, with the whole currying thing
07:55:02 <killy> kofron: probably depends what you do
07:55:26 <killy> I do signal processing - Matlab is fine for that
07:58:51 <killy> man, 99 Haskell problems ARE challenging for a newbie
07:58:57 <mm_freak_> is there a difference between NF and WHNF for Integer?
07:59:25 <quicksilver> no
07:59:28 <hpaste> killy pasted “working solution” at http://hpaste.org/63616
07:59:31 <kofron> killy: i do some signal processing as well, but our data comes from disparate sources
07:59:46 <killy> anyone wiling to comment on the code? :)
07:59:56 <kofron> matlab is great for certain operations but if you want to think functionally it's a bit of a nightmare imo
08:00:25 <killy> I'm not trying to think functionaly in Matlab
08:00:36 <koeien3> @src group
08:00:36 <lambdabot> group = groupBy (==)
08:00:40 <koeien3> @src groupBy
08:00:40 <lambdabot> groupBy _  []       =  []
08:00:41 <lambdabot> groupBy eq (x:xs)   =  (x:ys) : groupBy eq zs
08:00:41 <lambdabot>     where (ys,zs) = span (eq x) xs
08:00:57 <kofron> killy: that must be my mistake
08:00:58 <killy> in Matlab I program in C-style, not even trying to do OOP
08:01:14 <killy> Haskell is a sort of new challenge for me
08:01:14 <byorgey> djanatyn: uh, no, that won't work.
08:01:25 <killy> shame I see no much applicatin for it in my work...
08:01:31 <byorgey> djanatyn: because the accumulator would have a different type at each point.
08:01:38 <byorgey> djanatyn: if I understand what you are trying to do.
08:01:55 <byorgey> djanatyn: you want to take a list like [a,b,c,d,e]  and apply a function to it, like  f a b c d e  ?
08:01:59 <kofron> it's tough because mathworks teases you with all of these functional like features
08:02:06 <kofron> have you looked at DSP library in haskell?
08:02:32 <killy> nope, I'm still on the stage of learning the syntax, not even thinking about any libraries
08:02:52 <kofron> gotcha
08:02:54 <killy> I barely reached 5th chapter of LYAH
08:03:15 <killy> how's the performance of that library?
08:03:24 <killy> cause that's my main concern
08:03:57 <kofron> you know i haven't really put it to the test in terms of performance yet.  it uses Data.Array as its backbone which i'm told is pretty quick
08:05:08 <killy> well, trying out that lib could be a nice experiment in the future
08:05:20 <byorgey> killy: writing a recursive function with an extra 'accumulator' parameter is rarely the right thing to do in Haskell
08:05:27 <killy> but I don't think that functional programming is well suited for DSP
08:05:33 <mm_freak_> a stack overflow is related to pattern-matching, isn't it?
08:05:57 <killy> byorgey: how to do tail recursion without accumulator?
08:06:08 <koeien3> haskell is lazy
08:06:16 <byorgey> killy: there's no need to do tail recursion.
08:06:16 <cmccann> you don't want tail recursion in many cases
08:06:54 <killy> well... I couldn't figure out a different way to solve that problem
08:07:10 <edwardk> tail recursion is typicaly a sign that your algorithm won't work well in haskell. you usually want productive corecursion instead
08:07:23 <killy> corecursion?
08:07:26 <edwardk> the idea being that you can get the next constructor in a small amount of work.
08:07:47 <byorgey> edwardk: don't scare the newbies with big words
08:07:53 <byorgey> ;)
08:07:54 <cmccann> you can tell its better because it's productive. clearly tail recursion is an unproductive approach.
08:07:56 <edwardk> consider the fact that map works over infinite lists
08:08:02 <killy> I'm affraid I don't follow (please keep in mind that I started oiut with Haskell 2 days ago)
08:08:03 <edwardk> recursion needs a base case
08:08:09 <mm_freak_> killy: what edwardk is saying is:  to find the 100th fibonacci number, you can either tail-recursve (bad) or create an infinite list and consume that one (good)
08:08:29 <edwardk> you define what you do for [] and what you do for cons.
08:08:43 <edwardk> when the list is finite the recursive definition and the corecursive notions coincide
08:08:45 <cmccann> killy, what languages have you used before?
08:08:50 * hackagebot libmpd 0.7.2 - An MPD client library.  http://hackage.haskell.org/package/libmpd-0.7.2 (JoachimFasting)
08:09:00 <edwardk> but if you try to map a function over an infinite list in scheme you'll never finish
08:09:19 <edwardk> whereas
08:09:22 <edwardk> > map (+1) [1..]
08:09:23 <lambdabot>   [2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,2...
08:09:26 <killy> structural and object-oriented ones (Java and Matlab mostly), but I had a small taste of Prolog and a bit of Erlang
08:10:05 <cmccann> killy, ah, don't know enough about any of those to help, sorry
08:10:07 <edwardk> the key to why it works is that haskell will only look at the next contructor in the spine of the list when forced to by case analysis
08:10:27 * cmccann is better at explaining Haskell to C# programmers
08:10:50 <kofron> killy: how much Erlang?
08:10:55 <edwardk> map f (a :: as) = f a :: map f as; map f [] = []  -- note that even if the second case weren't there. if lists were always infinitely long and never ended, map would be a good definition in haskell
08:11:32 <killy> kofron: Java is like C#
08:11:35 <edwardk> whereas in scheme, erlang you'd probably want to switch to using an accumulating parameter or some silliness
08:11:39 <koeien3> edwardk: did you use too much ML recently? :)
08:11:42 <killy> a bit of Erlang
08:11:42 <edwardk> that isn't to say you never use accumulating parameters
08:11:50 <edwardk> koeien3: hah
08:11:53 <killy> I've been reading 7 languages in 7 weeks ;)
08:11:54 <edwardk> swap :: for :
08:12:08 <edwardk> koeien3: no, our little language uses :: for cons and : for signature, and i lapsed
08:12:47 <Philonous_> I'm looking at code containing associated type instances with qualified names (type E.ErrorType ...) , according to hackage the code compiled on 7.0 but here (7.4.1) it complains about a qualified name in a binding position. Did something change in GHC or is that not supposed to work at all?
08:13:01 <killy> wow, that is a detailed explanation
08:13:13 <koeien3> killy: #haskell is quite awesome IME
08:13:20 <killy> gotta log it, not sure if I understand everything correctly
08:14:31 <killy> ok, so let me ask about simplest of all possible examples
08:14:37 <killy> i.e. factorial definition
08:14:52 <killy> why is it better not to use tail recursion in that case?
08:15:00 <killy> the accumulator has constant size
08:15:32 <killy> and using tail recursion won't overflow the stack
08:16:39 <killy> the same with fibonnaci numbers
08:16:42 <edwardk> factorial is different, there are no constructors that you _could_ yield productively
08:16:55 <edwardk> fib on the other hand you can provide a productive list of them very easily
08:17:09 <killy> um... why?
08:17:12 <edwardk> > let fibs = 1 : 1 : zipWith (+) fibs (tail fibs) in fibs
08:17:14 <lambdabot>   [1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765,10946,1...
08:17:23 <cmccann> Haskell is the odd one out with (::) vs. (:) anyway, isn't it?
08:17:27 <edwardk> you pay for the elements of that list as you go
08:17:45 <killy> but why pay for them if I only want the last one?
08:17:47 <edwardk> historical accident as i understand it - the guy who wrote miranda didn't like : for definitions or some such
08:17:59 <int-e> cmccann: I thought the same about ML :)
08:18:34 <edwardk> killy: if you only want one then you might just build the recursive version, but keep in mind, factorial has that annoying recursion pattern, so that definition did full memoization and gave a linear time result
08:19:01 <edwardk> and if you used a smarter structure than a list, you could do subsequent lookups in logarithmic time
08:19:12 <edwardk> because they could share computation with the previous one
08:19:20 <edwardk> you build the list once and query it over and over
08:19:30 <killy> you mean a Look-Up-Table, right?
08:20:02 <int-e> edwardk: I didn't get your factorial remark, what about scanl (*) 1 [1..]?
08:20:10 <Saizan> s/factorial has that annoying recursion pattern/fib has that annoying recursion pattern/
08:20:31 <Philonous_> Never mind, finally found it. There was a bug in 7.0 that accepted qualified names. (And of course someone wrote code that used it...)
08:20:51 <edwardk> lookup table is okay if its finite in size, but what i was actually thinking of was a more complicated data type which can be queried for an element in log time called a skew binary random access list
08:21:14 <edwardk> int-e: true, i suppose i had been thinking of fac somewhat disingenuously as just retrieving the single value
08:21:24 <killy> ok, too complicated for a newbie
08:21:25 <int-e> but fib can be evaluated as a power of the matrix (0,1;1,1) :)
08:22:36 <edwardk> int-e: sure, and you can use the nice power of two recurrence it inherits from lucas numbers to do it faster, etc as well
08:23:17 <edwardk> or even just evaluate that little 1 +/- sqrt 5 power trick...
08:24:17 <int-e> I much prefer sticking to integers only
08:24:47 <edwardk> agreed ;
08:25:16 <cmccann> edwardk, btw, did you see the hackage2 instance I set up? :P
08:25:26 * cmccann is going to hack on the code a bit
08:25:31 <edwardk> yeah -- nice!
08:25:36 <cmccann> at least once I figure out how happstack works
08:25:56 <edwardk> hah, fair nuff
08:26:08 <edwardk> did you have to get the code from Gracenotes or was it lying around somewhere?
08:26:18 <cmccann> there's also a github repo, because I'm too lazy to learn how to use darcs badly, when I already know how to use git badly
08:26:21 <cmccann> found the darcs repo
08:26:26 <edwardk> ah
08:26:38 * Baughn loves how common both currying and lazy evaluation are in shell programming
08:27:05 <cmccann> so I just grabbed it from darcs, converted to git using a tool that lispy mentioned
08:27:12 <cmccann> tweaked a few things to get it building on my system
08:27:38 <SubtleArray> Hello Haskell Peoples. Would anyone perhaps be able to help me with a then in an if that isn't working?
08:28:03 <cmccann> and then dropped it on an EC2 instance so people could look at it
08:29:01 <cmccann> I'm kind of hoping that tangible evidence of hackage2 being a thing that actually exists will spur action
08:29:10 <hpaste> SubtleArray pasted “The 'then' in my 'if' isn't working” at http://hpaste.org/63621
08:29:16 <cmccann> also I wanted to hack on it a bit anyway since apparently nobody else is
08:30:32 <edwardk> cmccann: knock yourself out. =)
08:30:55 <edwardk> if you find yourself wanting to be hackage maintainer for life let me know and i'll run it past the committee ;)
08:31:32 <cmccann> maybe later
08:31:38 <cmccann> let me figure out the code and then hack on it a bit
08:31:42 <edwardk> heh
08:32:02 <cmccann> I like not being officially responsible for anything because it means I can change stuff if I want to
08:32:07 <edwardk> i know this is just because you sevretly want a 'by author' search
08:32:12 <edwardk> er secretly
08:32:18 <tgeeky> just to be clear, being hackage maintainer != being responsible for hosting hackage, right?
08:32:23 <cmccann> instead of feeling obligated to be all official and serious and stonewall everything
08:32:37 <byorgey> SubtleArray: the (snd y) == x  test will filter out any x's that don't satisfy that
08:32:43 <edwardk> tgeeky: nah hosting it is done by galois at the moment
08:32:45 <byorgey> SubtleArray: in those cases it will never even reach the 'if'.
08:32:54 <tgeeky> if a group of us #haskellers come up with hackage2.4.5, we can expect someone else to host?
08:32:56 <byorgey> SubtleArray: instead, move the   snd y == x  test into the if
08:33:06 <tgeeky> ok
08:33:08 <byorgey> if (snd y == x) then "null" else ...
08:33:08 <edwardk> we may at some point move the servers to another location, but they seem content to host all the community resources for now
08:33:39 <edwardk> tgeeky: the major issue has been a lack of personages willing to maintain said shiny new hackage implementation
08:33:49 <cmccann> tgeeky, I'm actually tempted to just run an official experimental hackage off EC2 for a while
08:34:04 <cmccann> get the full package db available and get the build system working and all that
08:34:16 <edwardk> heffalump can probably get you the old wiki contents
08:34:17 <cmccann> er
08:34:19 <cmccann> unofficial I mean
08:34:20 <hpaste> killy pasted “working solution” at http://hpaste.org/63622
08:34:21 <tgeeky> cmccann: is that where this is running?
08:34:38 <tgeeky> h2.uptoismorphism?
08:34:41 <cmccann> yes
08:34:53 <cmccann> that's my domain, with the subdomain pointing to an EC2 IP
08:35:17 <edwardk> if the amazon tax gets to be too much, let me know and i can set you up an account on comonad.com, but its pretty far out of date
08:35:28 <cmccann> well, so far it's cost me $0 total
08:35:34 <edwardk> fair nuff
08:35:40 <cmccann> since I don't have the package db on there and nobody is actually trying to use it
08:35:47 <cmccann> even though I uploaded four extremely useful packages
08:35:49 <edwardk> heh
08:35:49 <SubtleArray> byorgey: That works. But there's just one problem. It returns "null" multiple times. Is there a way to only return it once?
08:36:03 <tgeeky> cmccann: I'm doing to download the hell out of acme packages. You just wait!
08:36:08 <cmccann> oh noooooo
08:36:16 <SubtleArray> byorgey: Can breaks be used in list comprehensions?
08:36:25 <tgeeky> I'm setting up a Looney Tunes version of haskell, obviously
08:36:31 <cmccann> actually I should upload some of edwardk's packages
08:36:36 <cmccann> to test out the reverse deps
08:36:51 <cmccann> seems like a good stress test for that
08:36:58 <edwardk> tgeeky: how could you? causing $2-3 dollars to flow out of michigan's economy and into amazon's coffers might just doom them all.
08:37:16 <cmccann> yeah we only have like $16.22 to spare statewide
08:37:29 <byorgey> SubtleArray: if you only want to return "null" once you should probably do that as a separate step after the list comprehension.
08:37:39 <byorgey> SubtleArray: e.g. there is the "nub" function which removes duplicates.
08:37:40 <edwardk> and probably $12 is controlled by some emergency manager somewhere
08:37:52 <tgeeky> edwardk: well, in my defense, Michican has Detroit, so 2-3$ might be all that's left!
08:37:57 <byorgey> SubtleArray: I'm not sure what you mean.
08:38:00 <tgeeky> wait, that's not in my defense at all!
08:38:47 <killy> edwardk: One more question regarding recursion. All that you said would be optimal in Haskell, I mean it would produce the fastest code?
08:38:52 <edwardk> whereas my server is hosted in michigan, and is helping to keep their ailing internet infrastructure alive ;)
08:39:33 <edwardk> killy: for fib and fac it probably won't matter. for things like map, using an accumulating parameter will take code that could terminate and turn it into code that doesn't
08:39:48 <tgeeky> edwardk: it just occured to me... the age old American phrase "No Taxation without Representation" might take on some bizarre new meaning in #haskell!
08:39:49 <edwardk> so it isn't purely an efficiency concern, its also a correctness in the presence of infinite structures concern
08:40:08 <edwardk> no taxation without representable functors?
08:40:27 <tgeeky> yes. I don't know enough if I should support this or not, so I'll flip a coin.
08:40:50 <edwardk> great. now you've fed cmccann a pun
08:40:57 <killy> hm... guess it'll take some time before I grasp everything that you've said
08:41:04 <edwardk> i look forward to class Representable f => Taxable f where tax :: ...
08:41:13 <mrcarrot> killy: there are times when haskell will be faster than C (by automatically splitting things into threads), and there will be times when it will be slower. performance is really not the main argument for haskell. the safety in the language is the main reason for picking haskell
08:41:55 <SubtleArray> byorgey: I'll try to find a way to stick nub into the function.
08:42:07 <cmccann> crap, I was afk for a few minutes and I miss a pun?
08:42:07 <killy> mrcarrot: yes, but in the end it all boils down to producing good code
08:42:08 * cmccann sighs
08:42:29 <killy> and 'good' means usually fast, safe and easy to maintain
08:42:42 <rribeiro> Hello all. Does anyone can point me any reference on how the haskell context reduction mechanism works on the presence of MPTCs ?
08:42:55 <tgeeky> are there any paranoid parrots in here who use Google+ and are happy with it's level of whateverness? Should I use it? It is teasing me with useful search results!
08:43:12 <rribeiro> I'm asking that because the unique reference that I've found is the GHC user guide
08:43:38 <cmccann> rribeiro, I'm not sure that's something that exists in a well-defined manner outside of GHC
08:44:01 <Saizan> there should be some papers
08:44:13 <cmccann> your options are probably "the GHC user guide", "the GHC source code", and "papers written by GHC authors"
08:44:49 <rribeiro> cmccann, ok... I would like to understand this process better, because I haven't find any formal descriptions of that
08:45:17 <SubtleArray> byorgey: Thank you for your time.
08:45:47 <rribeiro> cmccann: and I'm implementing a haskell front-end as a part of my research and I need some points to implement the context reduction correctly
08:45:47 <cmccann> rribeiro, looking for papers written by the GHC folks is probably your best bet
08:46:08 <rribeiro> cmccann: I'll do it. Thanks for your attention
08:46:22 <cmccann> rribeiro, if you really can't find anything I might be able to help you reconstruct it empirically :P
08:46:34 <cmccann> given how much time I've spent trying to trick GHC into doing useful and/or silly things with MPTCs
08:46:55 <edwardk> rribeiro: look up typing haskell in haskell
08:46:55 <rribeiro> cmccann: Cool!
08:47:14 <edwardk> it gives the non-MPTC version, and he has a copy which adds support for MPTCs at least of the code
08:47:33 <edwardk> but having read the paper you can follow the modified code pretty easily
08:47:39 <edwardk> iirc it doesn't cover fundeps though
08:48:33 <edwardk> otoh, if you want to do all the crazy system fc stuff that ghc is capable of you're stuck reading ghc papers and the commentary
08:48:40 <rribeiro> edwardk: I'm interested in context reduction behavior over the Undecidable instances extension
08:48:47 <edwardk> which is at last check woefully out of date in some of those areas
08:48:48 <cmccann> I'd expect fundeps to either be straightforward or completely bogus
08:49:08 <edwardk> there you're going to start depending on system fc internals at least if you want to agree with ghc
08:49:18 <edwardk> since ghc's answers on some of those have changed multiple times over recent revisions
08:49:41 <edwardk> around 6.10, 7.0 and 7.4 iirc
08:50:00 <edwardk> with maybe another break in there
08:50:00 <cmccann> rribeiro, are you dealing with overlapping instances at all? or with fundeps?
08:50:31 <edwardk> in general overlapping instances are particularly bad now that we have constraint kinds
08:50:38 <edwardk> i can make those fail really easily
08:50:50 <rribeiro> cmcann: Yes, I'm dealing with overlapping. No fundeps or type families
08:51:01 <cmccann> edwardk, they were flaky and fragile to begin with
08:51:11 <edwardk> yep
08:51:19 <quicksilver> edwardk: excellent, that's finally convinced me that ConstraintKinds are a must-have
08:51:29 <quicksilver> edwardk: anything which further breaks overlapping instances is a friend of mine.
08:51:31 <edwardk> quicksilver: =)
08:51:47 <cmccann> rribeiro, overlapping can have weird interactions with how type unification is done and all kinds of other stuff
08:52:14 <rribeiro> cmccann: Yes... I'm aware of it.
08:52:27 * cmccann really wants closed type families or some other way of expressing unambiguous overlapping for "fallthrough" cases
08:53:10 <edwardk> the problem is those will run afoul of the same constraint kind trick
08:53:18 <edwardk> i can eploit unification to give you the wrong dictionary
08:53:59 <edwardk> so basically you're screwed ;)
08:54:27 <cmccann> usually when I want to do that I don't care about dictionaries anyway
08:54:36 <cmccann> because it's purely type-level shenanigans
08:55:04 <edwardk> a closed type family actually turns out to be anything but implementation wise, because you wind up needing to make an infinite number of cases
08:55:21 <edwardk> one for every type that comes into scope at the same time as the family is in scope
08:55:30 <edwardk> otherwise you wind up with overlap
08:55:43 <cmccann> yeah it really doesn't fit well with the whole idea of how these things work, sadly
08:55:48 <atri> hi
08:55:54 <edwardk> with that implementation it could work, but its hideous, and i don't see the ghc devs buying in
08:56:15 <atri> can anybody guide me to a fast and good tutorial on h>askell
08:56:18 <cmccann> I probably just need to make my own language at some point rather than griping about GHC
08:56:23 <atri> haskell?
08:57:34 <atri> please help
08:57:50 <Saizan> atri: look at LYAH
08:57:57 <Saizan> ?where LYAH
08:57:57 <lambdabot> http://www.learnyouahaskell.com/
08:58:33 <SubtleArray> atri: Look up Yet Another Haskell Tutorial as well. It's one of my favorites. Not as deep as Learn You A Haskell, but a little quicker in pace.
08:59:30 <zzo38> Can you tell me why this failed?   http://hackage.haskell.org/packages/archive/extensible-data/0.1.0.2/logs/failure/ghc-7.4
09:00:12 <SubtleArray> atri: And book mark this. http://bit.ly/c9functional Very good video series.
09:01:18 <zzo38> O, never mind, I found it.
09:01:28 <zzo38> Bad interface file: /usr/local/tmp/archive/install/lib/template-haskell-2.6.0.0/ghc-7.4.1/Language/Haskell/TH.hi
09:01:55 <zzo38> But template-haskell-2.7.0.0 is incompatible with this program.
09:02:31 <mux> GHC.Generics is very very cool, but I'm a bit surprised by how product types are represented
09:02:33 <zzo38> And template-haskell-2.6.0.0 did build on ghc-7.4 so why doesn't it work with this one?
09:02:33 <atri> Thanks all
09:02:42 <cmccann> mux, how so?
09:02:50 <mux> I would have expected something like T1 :*: T2 :*: U
09:03:02 <mux> but there's no unit type to mark the end of it
09:03:05 <dolio> edwardk: What's the trick?
09:03:08 <mux> so I've had to write instances like this :
09:03:15 <mux> instance (GFromBencode a, GFromBencode b) => GFromBencode ((S1 i a) :*: (S1 j b)) where
09:03:18 <mux> (base case)
09:03:24 <mux> instance (GFromBencode a, GFromBencode (b :*: c)) => GFromBencode ((S1 i a) :*: (b :*: c)) where
09:03:24 <cmccann> oh, yeah
09:03:29 <mux> recursive case
09:03:34 <mux> see what I mean?
09:03:39 <mux> a bit more work than I had hopes
09:03:41 <mux> hoped*
09:04:05 * hackagebot libssh2 0.1 - FFI bindings to libssh2 SSH2 client library (http://libssh2.org/)  http://hackage.haskell.org/package/libssh2-0.1 (IlyaPortnov)
09:04:13 <cmccann> that's the form you get from the derived instance, I take it?
09:04:43 <mux> the S1 stuff and :*: ? that's the typed used for representing types
09:06:16 <cmccann> I mean, there's obviously a unit type supported
09:06:20 <zzo38> Can you please tell me why it tried to load the wrong interface file? Is it something wrong with Cabal or with Hackage?
09:06:31 <mux> cmccann: yes, but not "this" unit type ;)
09:06:43 <mux> the U1 is used for representing constructors without parameters
09:06:57 <cmccann> right
09:07:11 <cmccann> it's an empty product
09:07:33 <mux> no it's not; because if it was, a singleton product would be T :*: U1
09:07:37 <mux> that's my point :-)
09:07:42 <cmccann> and to some extent it makes sense to have it attached to any product type, where it would represent the constructor
09:07:53 <cmccann> but yeah if that's not how it works then that's awkward
09:08:02 <cmccann> I haven't looked at it much, I just know how I'd do it :P
09:08:40 <cmccann> doing type-level recursion is annoying as hell if you don't have a concrete base case
09:09:05 * hackagebot libssh2-conduit 0.1 - Conduit wrappers for libssh2 FFI bindings (see libssh2 package).  http://hackage.haskell.org/package/libssh2-conduit-0.1 (IlyaPortnov)
09:10:06 <zzo38> "Something is amiss; requested module  template-haskell-2.6.0.0:Language.Haskell.TH differs from name found in the interface file template-haskell:Language.Haskell.TH"  Why does name found in interface file without version number?
09:15:09 <zzo38> Did I do something wrong or is Hackage wrong?
09:18:39 <zzo38> Please answer my question.
09:18:52 <donri> works for me
09:18:55 <elliott> zzo38: That's hard to answer without more context.
09:19:05 * hackagebot network 2.3.0.11 - Low-level networking interface  http://hackage.haskell.org/package/network-2.3.0.11 (JohanTibell)
09:20:24 <zzo38> elliott: It is an error message in this file:   http://hackage.haskell.org/packages/archive/extensible-data/0.1.0.2/logs/failure/ghc-7.4   "Something is amiss; requested module  template-haskell-2.6.0.0:Language.Haskell.TH differs from name found in the interface file template-haskell:Language.Haskell.TH"
09:20:29 <luite> zzo38: did some package lead to the installation of an extra template-haskell package? you usually should only use the th that come with ghc
09:20:33 <zzo38> Do you need others?
09:21:07 <zzo38> luite: Version 2.7.0.0 is incompatible with my program because the ClassInstances type changed
09:21:28 <luite> zzo38: then you need to update your program
09:21:37 <luite> at least if you want to use it with GHC 7.4
09:22:16 <zzo38> But I want to use it with GHC 7.0.3 as well.
09:22:31 <luite> you can use some preprocessor directives
09:23:20 <zzo38> C preprocessor works badly with literate Haskell and even with Haskell in general
09:23:27 <luite> MIN_VERSION macro's for example
09:23:33 <luite> for the th-package
09:23:40 <zzo38> How does MIN_VERSION macros do?
09:23:58 <luite> you can stuff the things that are version dependent in a single file, then it won't interfere with your .lhs
09:24:55 <zzo38> luite: OK. As far as I know, the ClassInstance type is the only such thing that has an incompatibility.
09:25:25 <luite> something like #if MIN_VERSION_template_haskell(2,7,0)
09:26:49 <zzo38> O, OK. Thanks for information.
09:29:28 <WzC> question: what would be the nicest way to determine if a file is a text-file?
09:30:12 <WzC> someone mentioned looking into the 'magic' package. But I would hope there is a nicer way of doing this
09:30:15 <Botje> ask /usr/bin/file?
09:30:21 <Botje> magic is good too.
09:30:39 <WzC> isn't there a native way of doing this?
09:30:45 <c_wraith> WzC: why would there be a "nicer" way of doing that?
09:30:52 <c_wraith> do you understand what the problem entails?
09:31:05 <cmccann> magic, apparently
09:31:26 <cmccann> clearly you need to find a "more-magic" package
09:31:33 <c_wraith> where magic = *huge* lookup table, sure
09:32:16 <elliott> Botje: file uses magic
09:32:32 <Botje> elliott: indeed.
09:32:44 <elliott> WzC: There is no way to determine if a file is a "text file".
09:32:47 <dmwit> WzC: Define "text file".
09:32:50 <elliott> WzC: What do you actually need to know about the file?
09:32:57 <WzC> well, I mean even doing something silly like "just read from a file, do some operation that only is sensible on Text files, and if any of that failed return False"
09:33:02 <elliott> What is that operation?
09:33:31 <WzC> the question that I basically have is whether or not I can pass some file into pandoc or not
09:33:51 <WzC> i.e. if I pass a text-file then it should be fine, if it is an image I don't want to even try
09:33:51 <dmwit> WzC: You seem to be holding some weird assumption somewhere. We'll do our best to flesh it out of you, but it might be painful. Bear with us.
09:34:03 <elliott> WzC: I suspect Pandoc will accept just about anything you throw at it.
09:34:08 <elliott> WzC: Why are you trying to use a heuristic?
09:34:19 <c_wraith> ah, so what you *really* want to know is "is this a pandoc source?"
09:34:20 <elliott> Contextual information is far superior to determine how a file should be processed.
09:34:49 <WzC> contextual info like?
09:35:03 <elliott> For instance, if a file is included as an image in another document, it's not to be processed as text.
09:35:11 <elliott> If you don't have contextual information, why not, and is there an obstacle to simply demanding it? (e.g. if this is a command-line tool) -- furthermore, why would this program be applied willy-nilly to both Pandoc source and images alike?
09:35:17 <elliott> Also, is the file extension not sufficient?
09:35:21 <WzC> if at all possible I would like to avoind making some list with 'safe' file extensions or something like that
09:35:28 <elliott> Why?
09:35:47 <WzC> because there may be many file types suitable
09:35:58 <elliott> It's only a matter of time before your heuristic misfires.
09:36:08 <elliott> Pandoc supports a finite number of document types, thus a finite number of file extensions.
09:36:28 <WzC> not to mention stuff like 'markdown' does not really have an 'official' enxtention
09:36:48 <WzC> elliott: using the file extension is also just a heuristic in that matter
09:37:11 <elliott> WzC: Yes, it is, but a far more reliable one.
09:37:17 <elliott> Nobody calls a Markdown file test.png.
09:37:17 <dmwit> Is there a reason you can't just ask pandoc itself if it knows how to handle the file?
09:37:30 * elliott suspects Pandoc will happily accept PNG data and format it into nonsense.
09:37:48 <funktronic> .md
09:37:54 <WzC> elliott: that may be true, however that does not mean I want it to do so
09:38:17 <elliott> WzC: I was responding to dmwit.
09:38:42 <elliott> Anyway, you seem to want to avoid both the simple and complex solutions, and still haven't explained why you have to do this.
09:38:45 <WzC> e.g. if I pass it a (path) to a jpg file I want it to do nothing (so I can do something else) instead of doing silly things
09:39:02 <WzC> it's part of a web-application
09:39:41 <WzC> if the user requests to 'view' an object (given by a URL) and it is a text file I want to pass it to pandoc to produce suitable html output
09:39:55 <elliott> See, you didn't say you had a URL.
09:39:58 <elliott> Servers send down mime-types.
09:40:02 <elliott> That's how browsers know how to process the data.
09:40:07 <elliott> Look at the Content-Type header.
09:40:08 <WzC> if it is an image I want to just return the url/path to the image, so the browser will actually view the image
09:40:41 <elliott> (Yet another example of withholding details leading to a pointless 10-minute psychic consultation...)
09:40:46 <edwardk> dolio: back, re passing dictionaries for overlapping instances?
09:41:15 <WzC> why would the webserver allready know that the url refers to a file?
09:41:22 <elliott> WzC: What?
09:41:32 <WzC> I mean I'm defining controller operations
09:41:41 <Saizan> elliott: he's implementing the server-side here
09:41:46 <elliott> Oh.
09:41:51 <WzC> indeed
09:41:55 <elliott> WzC: Where do the files come from?
09:41:58 <edwardk> dolio: you can capture a dictionary at a more general polymorphic type using data Dict a where Dict :: a => Dict a  -- then open it in a more constraint type once you used unification to narrow that Dict type down to something else
09:42:08 <elliott> WzC: Browsers send mime-types when uploading, too.
09:43:33 <WzC> I am implementing something like , when the server gets the url "view/foo/bar/lal.jpg" and "~/foo/bar/lal.jpg" is a file then serve ~/foo/bar/lal.jpg
09:43:52 <WzC> so files themselves are simply on the system
09:44:47 <WzC> but in the mean time I heard the term "mime-type", I was allready investigating that. Would that be 'the' way to go here then?
09:47:36 <elliott> WzC: Sure, but you'll need to get the mime-type from somewhere.
09:48:42 <WzC> there seems to be some functions in missingH to do stuff with mime-types
09:49:06 <WzC> the only pain seems to be that you have to tell it where to find the mime.types file
09:51:12 <elliott> WzC: Wait 'til you hear what mime.types contains.
09:52:27 <elliott> WzC: (It's a map of file extensions to mime-types.)
09:52:48 <dmwit> elliott: Your hypothesis was incorrect.
09:52:58 <dmwit> WzC: Let me recommend again that you ask pandoc if it knows what to do with the file.
09:53:01 <dmwit> It's a very simple solution.
09:53:09 <c_wraith> it's also the only correct solution.
09:53:10 <elliott> dmwit: I know. :(
09:53:14 * elliott is shamed.
09:53:16 <c_wraith> any heuristic can be wrong.
09:53:33 <c_wraith> pandoc, on the other hand, knows whether it can handle a file or not, 100% of the time.
09:53:54 <xarch> under pressure
09:53:56 <xarch> oops
09:54:02 <xarch> not meant for this channel
09:54:09 <xarch> sorry
09:58:14 <djanatyn> ...hmm. Can I get some help folding a function over a list of arguments?
09:58:39 <srhb> djanatyn: State your problem.
09:58:50 <djanatyn> fromGregorian :: Integer -> Int -> Int -> Day
09:58:58 <djanatyn> [2012,1,1]
09:59:11 <dmwit> cabal-install++ for Just Working and installing about 20 packages in the right order when I wanted to try out pandoc
09:59:22 <djanatyn> I'm not sure how I should go about folding fromGregorian over this list to get a Day type value.
09:59:28 <DanBurton> djanatyn: that...is unfortunate. Why is the first input Integer, while the second and third are Int?
09:59:32 <srhb> djanatyn: So you have a list of those "gregorians" (you should tyep them as such, and you should probably base it on a tripple)
09:59:49 <djanatyn> DanBurton: yeah, that's how it is defined in Data.Time.Calendar
09:59:53 <DanBurton> ew
10:00:00 <srhb> Wow, really?
10:00:09 <djanatyn> Yeah, go check it out.
10:00:24 <Saizan> well, you can't fold that, you can only pattern match and apply
10:00:26 <DanBurton> > Data.Time.Calendar.fromGregorian
10:00:27 <lambdabot>   Not in scope: `Data.Time.Calendar.fromGregorian'
10:00:29 <srhb> djanatyn: They're not lists though, it's (Integer, Int, Int)
10:00:46 <srhb> Which is slightly better. :-)
10:00:50 <Saizan> fromGregorianList [y,m,d] = fromGregorian y m d
10:00:52 <srhb> Though, not much.
10:00:58 <djanatyn> Saizan: :O
10:01:06 <dmwit> :t \[x,y,z] -> fromGregorian (fromIntegral x) y z
10:01:06 <Saizan> fromGregorianTuple (y,m,d) = fromGregorian y m d
10:01:06 <lambdabot> Not in scope: `fromGregorian'
10:01:15 <Saizan> oh right
10:01:18 <dmwit> :t \fromGregorian [x,y,z] -> fromGregorian (fromIntegral x) y z
10:01:19 <lambdabot> forall t b t1. (Integral t, Num b) => (b -> t -> t -> t1) -> [t] -> t1
10:01:20 <Saizan> you need fromIntegral's
10:01:55 <djanatyn> Saizan: I didn't think to use pattern matching.
10:02:04 <djanatyn> Still, how would I do this with fold, if possible?
10:02:15 <DanBurton> djanatyn: it's not really a "fold"-y type of job
10:02:18 <djanatyn> Assuming that fromGregorian took Int -> Int -> Int
10:02:19 <Saizan> it's not
10:02:33 <djanatyn> for the sake of explaining
10:02:38 <DanBurton> djanatyn: because you are making the assumption that the list has length 3. Folds typically make no assumptions about list length.
10:02:44 <elliott> djanatyn: You can't do it with a fold.
10:02:58 <cmccann> DanBurton, unless they're foldr1 or foldl1.
10:03:01 <Saizan> i mean it's not possible to do this as a fold, becuase the type of the step function would need to change
10:03:02 <cmccann> but those are terrible functions.
10:03:03 <DanBurton> You could do it with a pipe, which is kind of like a fold
10:03:10 <srhb> I don't understand though, where do you see this List-based gregorians.
10:03:15 <djanatyn> ntoh
10:03:16 <djanatyn> so, pattern matching, or a lambda?
10:03:43 <dixie> :t goto
10:03:44 <lambdabot> Not in scope: `goto'
10:03:56 <DanBurton> djanatyn: or don't use a list to hold the info in the first place
10:04:06 <DanBurton> if possible
10:04:07 <Saizan> djanatyn: a lambda which does pattern matching too
10:04:10 <RichyB> dixie: it's called "callCC" and you need Control.Monad.Cont ;D
10:04:13 <djanatyn> srhb: I'm getting dates from a file
10:04:25 <djanatyn> I have a string, like "2012 1 1"
10:05:16 <c_wraith> hmm. is that january first, or january first?
10:05:35 <DanBurton> c_wraith: obviously its YYYY MM DD - the easy-to-sort way :)
10:05:42 <dmwit> or january 2012'th of year 1??
10:05:55 <yertalert> lol
10:06:11 <c_wraith> DanBurton: well, yes, that's the most correct date format. doesn't mean it's the one actually being used :)
10:06:31 <RichyB> "2012 01 01" would be easier to sort. Don't even need to parse the integers.
10:06:32 <dixie> RichyB: :)
10:06:56 * DanBurton just pretends like everyone uses intelligent conventions, even though they don't
10:06:59 <RichyB> (I'm half-joking. Control.Monad.Cont defines a continuation-passing monad called "Cont" and transformer called "ContT" which give you some first-class control flow.)
10:08:13 <pfn> hmm, I'm confused, so in a do block, why does the monad identity value indicate failure?  i.e. stops execution?
10:08:31 <DanBurton> djanatyn: I suppose lists are OK then, but you might want to look into using Parsec or some other legitimate parser if its "production" code or a larger parsing job
10:08:35 <pfn> at least for []
10:09:11 <DanBurton> pfn: "stop execution"? "identity value"? not sure what you mean exactly
10:09:22 <DanBurton> > mzero :: [a]
10:09:23 <lambdabot>   []
10:09:25 <yrlnry> pfn:  [] is an example of a monad with a "zero".  A "zero" value has that property that zero >>= f  =  zero   for all f.
10:09:38 <pfn> hmm
10:09:52 <pfn> so not all monads have a zero
10:09:53 <DanBurton> > mzero :: Maybe Int
10:09:54 <lambdabot>   Nothing
10:10:04 <yrlnry> pfn:  But it doesn't "stop execution".  It does often happen that the monad >>= operation is defined so that zero >>= f  can be avaluated (to zerO) without actually running f.
10:10:12 <yrlnry> No, not all monads have a zero.
10:10:17 <pfn> ok
10:10:27 <yrlnry> For example, IO x   has no zero.
10:10:30 <DanBurton> @info mzero
10:10:31 <lambdabot> mzero
10:10:34 <DanBurton> -__-
10:10:43 <DanBurton> @hoogle mzero
10:10:48 <lambdabot> Control.Monad mzero :: MonadPlus m => m a
10:10:54 <DanBurton> there we go. MonadPlus
10:10:55 <cmccann> the @info command is always helpful
10:10:57 <tkahn6_> > print mzero
10:10:58 <lambdabot>   No instance for (GHC.Show.Show (m a))
10:10:58 <lambdabot>    arising from a use of `System.IO.p...
10:11:42 <mekeor> @hoogle IO a -> a
10:11:42 <lambdabot> Foreign.Marshal unsafeLocalState :: IO a -> a
10:11:42 <lambdabot> System.IO.Unsafe unsafePerformIO :: IO a -> a
10:11:43 <lambdabot> Foreign unsafePerformIO :: IO a -> a
10:12:01 <yrlnry> pfn:  Oh, and I should add that the >>= operation for lists *is* in fact designed so that [] >>= f  can be evaluated (to []) without actually running f.
10:12:12 <pfn> yrlnry, indeed, I got that, thanks
10:12:15 <yrlnry> Sure.
10:12:16 <Mike_____> My rubik cube is now complete :D
10:12:22 <DanBurton> MonadPlus allows you to use "guard", in other words, useful monad comprehensions
10:12:28 <CodeWeaverX> Mmm rubik's cube.
10:12:48 <Mike_____> my first haskel coding project o_o
10:13:00 <DanBurton> Mike_____: a rubik cube solver in Haskell?
10:13:02 <CodeWeaverX> Bold.  I've done rubik's cube stuff in C++.
10:13:05 <Mike_____> naaa
10:13:12 <Mike_____> the one you actually play
10:13:24 <DanBurton> Mike_____: links or it didn't happen
10:13:36 <DanBurton> ;)
10:13:57 * pfn is only attempting to learn haskell to better improve his scala skills
10:14:01 <hpaste> Mike___ pasted “Rubik” at http://hpaste.org/63626
10:14:14 <c_wraith> pfn: given that haskell is a lot simpler than scala, I'm not sure that'll really work
10:14:38 <DanBurton> pfn: a noble cause. I disagree, c_wraith (though I agree Haskell is simpler than Scala)
10:15:01 <DanBurton> it is precisely the simplicity of Haskell that will help you understand Scala better
10:15:08 <pfn> well, I've been diddling with scala on and off for the last couple of years, been a java programmer for 10+ years before that, so that transition was easy enough
10:15:09 <djanatyn> DanBurton: hah, nowhere near production code :)
10:15:10 <cmccann> given the opinions I've heard expressed by a few people in here, learning haskell may improve scala skills by convincing you to ditch it and stick with haskell instead
10:15:16 <pfn> now I'm building up on the FP foundation
10:15:27 <c_wraith> Well.  The result it's had on me is making me go "Scala seems to be really complicated for no reason.  I'll just use haskell"
10:15:39 <pfn> depends on the use-case
10:15:43 <cmccann> as c_wraith demonstrates my point :P
10:15:46 <pfn> sometimes haskell isn't applicable due to platform, etc.
10:15:57 <DanBurton> djanatyn: regardless, Parsec is fun to learn. I only just started toying with it recently: https://github.com/DanBurton/hs-adventure-txt/blob/master/adventure-txt.hs
10:15:59 <pfn> there's pretty much no reason for me to use haskell right now due to my target platforms, etc.
10:16:16 <djanatyn> I'm afraid to learn Parsec because it looks hard >_<
10:16:33 <luite> does anyone know how to convert a char** into a CFArrayRef?
10:16:37 <luite> err
10:16:39 <elliott> djanatyn: parsec is really easy
10:16:41 <luite> that was the wrong channel
10:16:45 <cmccann> luite, unsafeCoerce
10:16:48 * DanBurton thinks c_wraith probably learned Haskell first, and then Scala :P
10:16:48 <cmccann> :P
10:16:58 <c_wraith> it's true
10:17:08 <Sgeo> How do parser combinator's compare with Factor's EBNF syntax thing?
10:17:15 <Sgeo> s/'s/s/
10:17:16 <dolio> edwardk: If F :: * -> Constraint is a closed, overlapping type family, how are you going to get an 'F a' dictionary?
10:17:21 <c_wraith> I heard of Scala first.  But I learned haskell first. :)
10:17:24 <DanBurton> Scala isn't so bad once you learn a little about the conventions of the collections library, and about the intricacies of subtyping and implicit values
10:17:54 <DanBurton> still, if I ever want to write something in Scala, I usually write it in Haskell first and then translate xD
10:18:10 <pfn> DanBurton, interesting idea... doubt I could do that, heh
10:18:16 * pfn is writing android apps in scala
10:18:28 <DanBurton> nice
10:18:30 <mrcarrot> before i knew almost anything about the languages, i picked haskell before scala with java as reason
10:18:30 <pfn> feels so hard to use a pure functional style there
10:18:39 <dolio> Or, and allegedly F a dictionary.
10:18:45 <edwardk> dolio: hrmm
10:18:52 <pfn> mrcarrot, java tech is so entrenched that using scala is pretty much a no-brainer
10:18:56 <pfn> imo
10:19:06 * hackagebot bitmap 0.0.2 - A library for handling and manipulating bitmaps (rectangular pixel arrays).  http://hackage.haskell.org/package/bitmap-0.0.2 (BalazsKomuves)
10:19:08 <edwardk> dolio: with it as a type family i don't think i can. with it as a class with overlapping instances i can
10:19:11 <pfn> it's applicable damn near everywhere
10:19:21 <dolio> edwardk: Right.
10:19:34 <pfn> ah, that's another point of confusion on haskell for me... so say I build something, does it require external libraries, e.g. a runtime, or is it self-contained?
10:19:34 <edwardk> i think we were talking about two different scenarios
10:19:43 <mrcarrot> pfn: i am avoiding java in every single way as i can because of "compile once, run nowhere"
10:19:46 <elliott> pfn: GHC statically-links Haskell libraries by default.
10:20:00 <djanatyn> one more question :)
10:20:01 <elliott> pfn: They depend on GMP, but you can statically link that in. If you want to avoid licensing issues, you can build GHC with integer-simple.
10:20:07 <elliott> (Integer operations will be slower, however.)
10:20:10 <pfn> elliott, yeah, that's what I thought (at least by ldd checking) but I didn't know if it dynloads anything
10:20:12 <mrcarrot> pfn: i have been seeing way too much problem with moving java apps from one platform to another one
10:20:20 <djanatyn> if I have a list of strings, how do I map read over them and make them Ints?
10:20:34 <cmccann> ... map read?
10:20:44 <cmccann> :t map read
10:20:44 <DanBurton> :)
10:20:45 <lambdabot> forall a. (Read a) => [String] -> [a]
10:20:47 <pfn> mrcarrot, I generally haven't seen those issues with properly written code
10:20:51 <djanatyn> > map (read :: Int) ["1","2","3"]
10:20:52 <lambdabot>   Couldn't match expected type `GHC.Types.Int'
10:20:53 <lambdabot>         against inferred type ...
10:21:08 <elliott> djanatyn: read is a function
10:21:09 <elliott> not an Int
10:21:12 <DanBurton> > map read ["1","2","3"] :: [Int]
10:21:13 <lambdabot>   [1,2,3]
10:21:22 <djanatyn> errm. Yes ^_^
10:21:26 <djanatyn> okay, awesome
10:21:36 <DanBurton> > map (read :: String -> Int) ["1","2","3"] -- I like the other way better
10:21:37 <lambdabot>   [1,2,3]
10:21:37 <djanatyn> do I need to tell ghc that it is an Int, or can it infer that?
10:21:47 <cmccann> it will infer it if it can
10:21:53 <DanBurton> djanatyn: usually from the way you use the list, it will be inferred
10:22:09 <cmccann> if you immediately do something with the list that can take multiple types it can become ambiguous
10:22:17 <cmccann> :t show . read
10:22:18 <lambdabot> String -> String
10:22:21 <cmccann> ...
10:22:23 <cmccann> lambdabot.
10:22:25 <cmccann> thanks.
10:22:26 <DanBurton> lol
10:22:27 <Enigmagic> heh
10:22:31 * cmccann sighs
10:22:31 <DanBurton> > show . read $ "1"
10:22:35 <lambdabot>   mueval-core: Time limit exceeded
10:22:38 <cmccann> what
10:22:38 <DanBurton> wat
10:22:44 <DanBurton> > show . read $ "1"
10:22:48 <lambdabot>   mueval-core: Time limit exceeded
10:22:50 <DanBurton> @botslap
10:22:50 <lambdabot> Unknown command, try @list
10:22:53 * cmccann blames Cale
10:22:54 <Enigmagic> > show . read $ ("1" :: String)
10:22:58 <lambdabot>   mueval-core: Time limit exceeded
10:22:59 <mekeor> i've got a question:
10:23:01 <hpaste> mekeor pasted “Question about what GHC makes out of type classes under the hood” at http://hpaste.org/63628
10:23:02 <Enigmagic> damn
10:23:35 <djanatyn> sweet, my ocode finally works :D
10:23:49 <cmccann> mekeor, you should pay attention to the stuff edwardk has been talking about in here for the last week or two :P
10:24:03 <DanBurton> mekeor: SPJ was presenting pseudocode; "Num a" is understood to be a "dictionary" with the num operations
10:24:29 <edwardk> mekeor: the Num a -> a -> a -> a isn't a legal 'surface syntax'
10:24:32 <DanBurton> mekeor: you can't actually construct or refer to these dictionaries in plain Haskell
10:24:34 <mekeor> cmccann: ...
10:24:36 <edwardk> you can't talk about Num dictionaries directly
10:24:47 <mekeor> edwardk: ah, so only Num a => is allowed for programmers?
10:25:02 <mekeor> edwardk: but under the hood it's Num -> anyway, right?
10:25:03 <DanBurton> the first rule of Typeclasses is...you can't talk about Typeclasses...directly.
10:25:05 <edwardk> its just that internally ghc works with them like they were any other kind of argument (though of a stricter kind)
10:25:11 <edwardk> mekeor: yeah
10:25:15 <mekeor> edwardk: okay. i got it. thanks =)
10:25:34 <edwardk> mekeor: there are some scary tricks on my blog for plumbing them around slightly obliquely
10:25:44 <mekeor> edwardk: link, pls
10:25:45 <edwardk> but i don't recommend them as a starting point =)
10:26:00 <edwardk> http://comonad.com/reader/2011/what-constraints-entail-part-1/ http://comonad.com/reader/2011/what-constraints-entail-part-2/
10:26:23 <eyebloom> Hi, does anyone know the purpose of thenIO ?
10:26:24 <djanatyn> okay. If I have a type defined by record syntax, and have it derive the Ord typeclass, in what order will it compare the different elements of the type?
10:26:26 <edwardk> there is also a constraints package which i think i uploaded to hackage which works on 7.4.1
10:26:33 <cmccann> don't listen to him, edwardk's blog and oleg's site taught me a great deal when I was new to Haskell
10:26:37 <mekeor> edwardk: okay. alright. thanks again.
10:26:38 <cmccann> on second thought maybe that's not a good thing
10:26:40 <DanBurton> @hoogle thenIO
10:26:40 <lambdabot> No results found
10:26:46 <DanBurton> eyebloom: of what?
10:26:49 <mekeor> cmccann: hehe
10:27:03 <edwardk> eyebloom: historical interest
10:27:14 <eyebloom> It's defined in http://hackage.haskell.org/packages/archive/base/latest/doc/html/src/GHC-Base.html#Monad
10:27:14 <geekosaur> djanatyn, in the order in which they were declared
10:27:29 <djanatyn> okay, thanks
10:27:31 <geekosaur> there's a precise definition of how Ord is derived in the online report
10:27:47 <edwardk> eyebloom: it used to be considered good form to make monomorphic versions of everything you were going to put into a typeclass
10:28:10 <eyebloom> I see.
10:28:15 <eyebloom> It's not anymore?
10:28:19 <DanBurton> mekeor: In one of my favorite answers from a while ago I wrote some musings about how you might do "typeclasses" in lambda calculus http://stackoverflow.com/questions/8925103/embedding-higher-kinded-types-monads-into-the-untyped-lambda-calculus/8936209#8936209
10:28:35 <edwardk> eyebloom: it leads to a lot of boilerplate.
10:28:49 <edwardk> eyebloom: it also uses up all the good names =P
10:29:03 <eyebloom> gotcha. :)
10:29:04 <DanBurton> it's for speed. Typeclasses make the runtime slower, iinm
10:29:15 <edwardk> DanBurton: i have a version of that in scheme
10:29:28 <ehuber> plucas: yo :)
10:29:32 <dolio> edwardk: I just thought someone said earlier that you could do the same trick with closed, overlapping families and constraint kinds.
10:29:36 <DanBurton> edwardk: Racket or gtfo ;)
10:30:02 <dolio> But I think that's guarded against by the fact that F a cannot reduce until you do case analysis on a.
10:30:10 <edwardk> DanBurton: i have a racket version as well somewhere
10:30:11 <edwardk> https://github.com/ekmett/scheme-monads
10:30:18 <plucas> ehuber: heh hi
10:30:25 <edwardk> my apologies for the names of things, i didn't get to choose them
10:30:35 <dolio> However, that means it's impossible to supply the fall-through default case.
10:30:42 <dolio> Generically.
10:30:42 <edwardk> dolio: yeah
10:31:04 <DanBurton> edwardk: you didn't get to choose the names? What was it for, then?
10:31:16 <edwardk> dan friedman wanted to write a book on monads in scheme
10:31:33 <DanBurton> ah
10:31:44 <edwardk> so he asked me to put together a library for them, that he could wrap with the kind of socratic dialogue he loves
10:32:33 <edwardk> but in the end, the limited dialect he uses in his books and page formatting considerations kinda killed it
10:32:51 <hpaste> “math science tour” pasted “Calculations” at http://hpaste.org/63630
10:32:58 <edwardk> with a currying macro you can get pretty far, and if you have a decent object system like racket you can do the rest
10:33:31 <edwardk> it did lead to me discovering a nice way to 'reader transform' monad sugar so it could plumb the dictionary behind your back though
10:33:52 <DanBurton> nice
10:33:53 <shapr> edwardk: blog posted?
10:34:05 <edwardk> shapr: on the scheme monad stuff?
10:34:11 <dolio> Doesn't work well in Haskell.
10:34:18 <edwardk> nah it didn't become clear to me it was dead in the water until a year or two after i wrote it all
10:34:25 <dolio> You need row types or lack of types.
10:34:32 <edwardk> yeah
10:34:43 <hpaste> “math science tour” pasted “blinkieleit 4” at http://hpaste.org/63631
10:34:52 <edwardk> with row types it was kinda nice. we were using it for a while in our little language before we lobotomized row types
10:35:17 <hpaste> “math science tour” pasted “Symmetries” at http://hpaste.org/63632
10:36:04 <edwardk> DanBurton: with racket most of the horrible positional subtyping nonsense in https://github.com/ekmett/scheme-monads/blob/master/base.scm just becomes a few lines of subtype definitions
10:37:13 <edwardk> oh man
10:37:15 <edwardk> that is an old version
10:37:21 <edwardk> it passes the monad dictionary first
10:39:06 <tazjin> I'm a bit confused, GHC is suddenly forcing me to use semicolons in do {} expressions. If I don't use semicolons it assumes that the second statement is an argument to the first statement, it didn't do this yesterday
10:39:29 <tazjin> Any ideas what could have happened here? I didn't even change my code and yet it refuses to compile it today when it did that just fine yesterday
10:39:29 <edwardk> tazjin: you usually don't use explicit {}'s
10:39:43 <edwardk> without them you can just use layout
10:39:52 <DanBurton> do you have to use semicolons if you use curly braces?
10:40:01 <edwardk> if you say do { … } then you have to use semicolons within the braces
10:40:07 <tazjin> I don't put the curly braces in my code.
10:40:12 * DanBurton always uses layout; never ran into this problem
10:40:29 <edwardk> then you probably have a spacing problem. check for tabs and spaces being mixed. tabs are 8 characters wide
10:40:59 <DanBurton> tazjin: basically, the rule of thumb is never use tabs. Set your editor to replace tabs with spaces.
10:41:03 <edwardk> yeah
10:41:16 <tazjin> I'm using spaces all the time, across 3 different editors
10:41:24 <tazjin> what confuses me is that I didn't even touch the code D:
10:41:38 <edwardk> hpaste?
10:41:48 <edwardk> @hpaste
10:41:48 <lambdabot> Haskell pastebin: http://hpaste.org/
10:41:49 <DanBurton> edwardk read my mind
10:41:56 <mekeor> -- strong type systems for the win!
10:43:18 <hpaste> tazjin pasted “indentation?” at http://hpaste.org/63633
10:44:38 <mekeor> tazjin: indentation is fine.
10:46:16 <erus`> @hoogle a -> (a -> a -> b)  -> b
10:46:17 <lambdabot> Prelude foldl1 :: (a -> a -> a) -> [a] -> a
10:46:17 <lambdabot> Data.List foldl1 :: (a -> a -> a) -> [a] -> a
10:46:17 <lambdabot> Prelude foldr1 :: (a -> a -> a) -> [a] -> a
10:46:55 <edwardk> tazjin: indentation looks fine. you probably have some completely unrelated error ;)
10:50:15 <hpaste> DanBurton annotated “indentation?” with “indentation? (annotation)” at http://hpaste.org/63633#a63634
10:50:43 <DanBurton> well, "without modification" was a lie, I deleted "Ip."
10:51:24 <Cale> > ()
10:51:25 <lambdabot>   ()
10:51:40 <Cale> > show . read $ "1"
10:51:42 <lambdabot>   "*Exception: Prelude.read: no parse
10:51:51 <Cale> > show . read $ "1" :: Integer
10:51:52 <lambdabot>   Couldn't match expected type `GHC.Integer.Type.Integer'
10:51:52 <lambdabot>         against inf...
10:51:59 <DanBurton> Cale :) did you change something?
10:52:04 <Cale> I didn't change anything
10:52:08 <DanBurton> o_O
10:52:19 <c_wraith> > show . (read :: String -> Integer) $ 1
10:52:20 <lambdabot>   No instance for (GHC.Num.Num GHC.Base.String)
10:52:21 <lambdabot>    arising from the literal `...
10:52:21 <Cale> Probably the machine that lambdabot was on was burdened by something which stopped
10:52:23 <c_wraith> > show . (read :: String -> Integer) $ "1"
10:52:24 <lambdabot>   "1"
10:52:26 <c_wraith> there
10:52:35 <Cale> right
10:52:37 <DanBurton> then why was lambdabot choking on show . read $ "1" earlier?
10:52:37 <Cale> there it is
10:52:49 <c_wraith> DanBurton: defaulting to () as the intermediate type
10:52:49 <Cale> DanBurton: It was giving the message that it gives when it times out
10:52:58 <c_wraith> > read "1" :: ()
10:52:59 <lambdabot>   *Exception: Prelude.read: no parse
10:53:05 <DanBurton> Cale: right. But why would it time out?
10:53:10 <Cale> DanBurton: I have no idea
10:53:17 <Cale> These things happen
10:53:24 <DanBurton> ah the mysteries of Lambdabot.
10:56:36 <Cale> DanBurton: It's usually not lambdabot, it's whatever else is going on with the machine that lambdabot is hosted on.
10:56:45 <Cale> DanBurton: It times out based on wall clock time
10:57:43 * cmccann figured that it was just lambdabot sulking because of being taken for granted all the time
11:01:09 <b0fh_ua> Hi all! How can I force computation of function passed to mapM ?
11:02:42 <c_wraith> b0fh_ua: say what?
11:02:57 <c_wraith> b0fh_ua: "force" may not be what you mean, there
11:03:33 <b0fh_ua> c_wraith: in IO monad I need to force curl download content
11:03:37 <b0fh_ua> and parse it
11:03:56 <c_wraith> "force" has a specific meaning in lazy evaluation
11:04:14 <c_wraith> So using it to mean something else leads to confusion
11:04:33 <rwbarton> or, confusion leads to using it to mean something else
11:04:47 <c_wraith> that's also possible
11:04:51 <tromp__> quiz: what types have 0,1,2,3,4 defined values?
11:04:54 <rwbarton> Can you paste your code?
11:04:55 <b0fh_ua> basically I have function f :: String -> [Item] and function g :: String -> IO String, and I have list of urls, so mapM ( liftM f . g ) urls
11:05:15 <rwbarton> okay
11:05:24 <b0fh_ua> which is supposed to have type String -> IO [Item]
11:06:09 <b0fh_ua> and basically looks like Curl connects to a server almost immediately and when parsing occurs - server closes connection somewhere in the middle of the list of urls
11:06:20 <b0fh_ua> so I need to "force" downloading content and parsing it
11:06:52 <b0fh_ua> because of lazy IO I believe
11:07:23 <c_wraith> theoretically possible.  don't use curl anyway.  the curl bindings are buggy.
11:08:10 <b0fh_ua> c_wraith: I need digest auth, looks like curl is only the choice
11:08:14 <mekeor> is Bryan O'Sullivan actually in here?
11:09:45 <c_wraith> mekeor: not all that much, anymore
11:10:12 <mekeor> c_wraith: which nickname does he use, usually?
11:10:31 <c_wraith> bos, usually
11:10:37 <mekeor> okay.
11:10:39 <afgh> less
11:10:44 <luite> he used to be in here more, but then he got hired by facebook, or something
11:10:44 <afgh> haskell
11:10:46 <afgh> :3
11:10:49 <afgh> :P
11:13:45 * DanBurton shakes his fist at facebook
11:14:33 <DanBurton> I wish I were super rich. Then I would hire everyone on #haskell and hang out with them and there would be much rejoicing.
11:16:36 <afgh> ;·3
11:16:46 <afgh> :3
11:16:48 <afgh> :
11:17:10 <alpounet> DanBurton, and the company's name would be "Monad Inc."? :P
11:18:10 <DanBurton> alpounet: nah, probably something more cool sounding like Monoid in the Category of Endofunctors
11:18:35 <DanBurton> or Fmap Fmap Fmap inc
11:19:37 <otters> Monad '; DROP TABLE companies; --
11:19:37 <Enigmagic> fap fap fap
11:19:40 <Enigmagic> :|
11:20:01 <alpounet> DanBurton, hah, yeah. Or maybe something related to fix / Mu
11:20:15 <afgh> LOL
11:20:55 <DanBurton> Enigmagic: -___-
11:22:53 <afgh> :O
11:23:01 <DanBurton> What is the backspace character? Like on the command line, if I putStr and then I want to blank out that character?
11:23:11 <DanBurton> the last character, i mean
11:25:17 <mekeor> DanBurton: i think \b -- but just google "control characters"
11:25:26 <mekeor> @wiki Control character
11:25:26 <lambdabot> http://www.haskell.org/haskellwiki/Control_character
11:25:35 <mekeor> @wikipedia Control character
11:25:35 <lambdabot> Unknown command, try @list
11:25:43 <SubtleArray> Hello everyone. Incoming question. Is it possible to define more than one variable with let in a function? Whenever I try, I get a "parse error on input `let.
11:26:30 <mekeor> SubtleArray: (AFAIK, )yes. paste your code snippet, pls( if possible).
11:26:41 <rwbarton> let x = 1
11:26:43 <rwbarton>     y = 2
11:26:45 <rwbarton> in ...
11:27:06 <tromp__> > let x=1;y=2 in x+y
11:27:07 <lambdabot>   3
11:27:15 <mekeor> exactly
11:27:23 <SubtleArray> You guys are awesome. :D Thank you. Problem solved.
11:27:45 <srhb> SubtleArray: Indentation error? You probably should not use ;
11:29:45 <SubtleArray> srhb: I was upsetting the compiler by using let too many times. I see it's only allowed once now.
11:29:55 <SubtleArray> Haskell is soooo picky. :P
11:30:00 <srhb> SubtleArray: Ah. :)
11:31:05 <deech> Hi all, hGetContents fails if it can't decode a character with the given charset. I am reading in a file that will be parsed by Parsec, but I don't really care about the bad character. Is there someway to read it in anyway and just skip over it?
11:33:28 <dmwit> deech: Use a ByteString to get the literal bytes, I guess.
11:33:44 <DanBurton> > text "a\bc"
11:33:45 <lambdabot>   ac
11:33:45 <dmwit> There's an hGetContents for ByteString.
11:34:03 <deech> dmwit : Ok I'll try that.
11:34:19 <dmwit> deech: You might want to open the file with binary mode, too, if you're not reading text (which it sounds like you aren't).
11:35:54 <elliott> SubtleArray: for for (int x; ...) /* C is soooo picky :P *?
11:36:32 <DanBurton> > text "a\x08c"
11:36:33 <lambdabot>   a
11:36:48 <dmwit> */
11:37:24 <ChristianS> > let x=1 in let y=2 in x+y
11:37:24 <lambdabot>   3
11:37:53 <dmwit> > do let {x = 1}; let {y = 2}; return (x+y) :: [Int]
11:37:54 <lambdabot>   [3]
11:38:13 <ChristianS> if works with multiple let .. ins too. but a single one is shorter :-)
11:38:35 <dmwit> It even works with multiple lets and no in! Haskell is hardly picky at all. =)
11:38:56 <ChristianS> duh (do)
11:39:53 <mekeor> dmwit: that's exactly one of those examples i don't get.  is a list a monad??!
11:40:12 <tromp__> > [x+y|let x=1,let y=2]
11:40:13 <lambdabot>   [3]
11:40:13 <dmwit> yes
11:40:34 <dmwit> mekeor: More precisely, the list type constructor forms a monad with concatMap and \x -> [x].
11:40:36 <mekeor> but more specific, it's functor, right?
11:40:43 <dmwit> Functor is less specific than monad.
11:40:47 <mekeor> ye
11:40:48 <mekeor> a
11:40:50 <tromp__> List is the 2nd most famous monad
11:40:57 <mekeor> dmwit: but a list is a functor, right?
11:41:09 <mekeor> tromp__: whats the most famous one?
11:41:09 <dmwit> The list type constructor forms a functor with map, yes.
11:41:11 <tromp__> all monads are
11:41:14 <tromp__> IO
11:41:31 <tromp__> or some would say, the most infamous
11:41:44 <SubtleArray> elliot: C isn't *that* picky. I taught myself C in a few weeks. Haskell has been kicking my arse for the last month.
11:42:02 <rwbarton> neither C nor Haskell will accept random strings of keywords
11:42:49 <dmwit> I think we need to define "picky" before we can have a meaningful discussion. Until then, let's talk about something more constructive.
11:42:50 <tromp__> you don't know C until you can solve all exercises in The C Puzzle Book
11:43:12 <stulli> Learning C isn't hard, learning best practices is hard
11:43:40 <timemage> learning all of C is hard.
11:43:42 <copumpkin> how is using let multiple times disallowed?
11:43:44 <copumpkin> SubtleArray?
11:44:01 <copumpkin> > let x = 5 in let y = 6 in let z = 7 in x + y + z
11:44:02 <lambdabot>   18
11:44:04 <SubtleArray> C isn't as elegant, but I found it easier to learn. That doesn't mean it's a better language though. If it were, I wouldn't be trying to learn Haskell right now.
11:44:35 <edwardk> SubtleArray: i think a lot of it is, that coming from java, python, etc. c largely fits your pre-existing biases
11:44:41 <copumpkin> > (do let x = 5; let y = 6; let z = 10; return (x + y + z)) :: Maybe Int
11:44:41 <lambdabot>   <no location info>: parse error on input `)'
11:44:43 <edwardk> haskell isn't harder per se, its just different
11:44:47 <ChristianS> mekeor: i found http://www.haskell.org/haskellwiki/All_About_Monads helpful (and it speaks about functors, too)
11:45:23 <SubtleArray> copumpkin: I tried to define the variables like I do in C and C++, by having a let on each line. rwbarton showed that I only needed to use let once, and I could define my other variables below that 1 let. Using multiple lets in one variable resulted in a parsing error.
11:45:39 <rwbarton> basically you tried to write
11:45:43 <rwbarton> let x = 1 let y = 2 in ...
11:45:45 <copumpkin> okay, so you're having trouble learning the syntax of haskell? :P
11:45:46 <rwbarton> which cannot make senes
11:46:05 <rwbarton> let ... in ... is a form of expression
11:46:11 <rwbarton> C doesn't have anything like it
11:46:24 <copumpkin> not knowing the syntax doesn't make the language picky
11:46:26 <otters> it sorta does
11:48:07 <dmwit> > let x = 1 (let y = 2 in "hey") in x "you were saying?" :: Integer
11:48:08 <lambdabot>   1
11:48:08 <SubtleArray> copumpkin: Right. And layout. I usually use simple editors like vim for coding, but for Haskell I've been using an IDE (Leksah) to help with layout. It's been an educational tool.
11:48:58 <copumpkin> dmwit: ಠ_ಠ
11:49:07 * hackagebot stb-image 0.2.1 - A wrapper around Sean Barrett's JPEG/PNG decoder  http://hackage.haskell.org/package/stb-image-0.2.1 (BalazsKomuves)
11:49:24 <SubtleArray> copumpkin: It depends. When I first started learning Python, for example, it didn't feel picky at all. XD
11:49:48 <mandaya> SubtleArray: depends on where you're coming from
11:49:56 <copumpkin> yeah, but that was probably more due to what your expectations were, rather than a feature of python (other than it being similar to your prior experience)
11:50:06 <mandaya> SubtleArray: After lisp, haskell's syntax and way of doing things were rather straightforward
11:50:29 <lukish> #haskell: Total of 888 nicks
11:50:31 <lukish> Nice!
11:50:37 <copumpkin> very lucky!
11:50:51 <lukish> How can I convert Maybe String -> Maybe [String] ?
11:51:02 <SubtleArray> mandaya: Haskell is fine. It's just been giving me some hell, that's all. Lol. I plan on sticking with it until I can feel more comfortable.
11:51:06 <Botje> macho answer: fmap return
11:51:20 <copumpkin> SubtleArray: I'm glad :)
11:51:48 <mandaya> SubtleArray: Yea, I'm just making the point that any language that's significantly different from what you already know will give you the same kind of hell.
11:51:58 <dmwit> > fmap return (Just "hey") :: Maybe [String]
11:51:59 <lambdabot>   Just ["hey"]
11:52:02 <copumpkin> even going from haskell to agda is pretty difficult for many people
11:52:12 <copumpkin> even though they're nominally both "pure functional"
11:52:20 <dmwit> > fmap (map return) (Just "hey") :: Maybe [String] -- the problem is underspecified
11:52:21 <lambdabot>   Just ["h","e","y"]
11:52:44 <dmwit> > fmap (transpose . return) (Just "hey") -- just for fun
11:52:46 <lambdabot>   Just ["h","e","y"]
11:53:21 <dmwit> > const Nothing (Just "hey") :: Maybe [String]
11:53:22 <lambdabot>   Nothing
11:53:25 <dmwit> ;-)
11:53:52 <SubtleArray> That lambdabot is kind of cool.
11:53:56 <SubtleArray> > [1..5]
11:53:57 <lambdabot>   [1,2,3,4,5]
11:54:18 <hpaste> plucas pasted “slow” at http://hpaste.org/63636
11:54:19 <dmwit> Yeah, he doesn't afraid of anything.
11:54:20 <hpaste> plucas pasted “fast” at http://hpaste.org/63637
11:54:27 <erus`> @hoogle a -> (a -> a -> b) -> b
11:54:27 <lambdabot> Prelude foldl1 :: (a -> a -> a) -> [a] -> a
11:54:28 <lambdabot> Data.List foldl1 :: (a -> a -> a) -> [a] -> a
11:54:28 <lambdabot> Prelude foldr1 :: (a -> a -> a) -> [a] -> a
11:54:39 <mandaya> what happens when someone accidentally types in a non-terminating expression?
11:54:40 <plucas> can anyone tell me why the python there is so much faster (~9x on a million-line input) than the haskell?
11:54:53 <cmccann> > last [1..]
11:54:56 <lambdabot>   mueval-core: Time limit exceeded
11:55:08 <mandaya> nice
11:55:10 <Botje> plucas: did you compile with -O2 ?
11:55:25 <dmwit> mandaya: There's been about a decade of attempts to break lambdabot in such a way. =)
11:55:34 <nomeata> mandaya: not sure, but you have seen what happens if somenoe types in a non-terminateing expression deliberately. not sure how lambdabot can tell the difference.
11:55:37 <plucas> Botje: no didn't use optimization. is that basically required for anytime performance matters?
11:55:46 <rwbarton> yes
11:56:00 <copumpkin> plucas: and not using lists is also a good idea, but just compile with -O2 first
11:56:16 <copumpkin> plucas: it'd be like running the python interpreter without compiling it with optimization
11:56:24 <copumpkin> plucas: you can't expect that to run as quickly
11:56:25 <mandaya> dmwit: Haha, how far have the maintainers come to solving the halting problem?
11:56:55 <rwbarton> lamdabot is very conservative
11:57:02 <rwbarton> often expressions like () are deemed nonterminating
11:57:08 <mandaya> > ()
11:57:09 <lambdabot>   ()
11:57:13 <aluink> i keep getting errors when trying to access the HackageDB2.0 pages on the hackage wiki
11:57:14 <dmwit> mandaya: Oh, it's the usual solution: just assume anything taking more than (say) 2 seconds is nonterminating.
11:57:26 <rwbarton> mandaya, it depends on lambdabot's mood
11:57:26 <statusfailed> What would be the advantage of using "id ***" vs "second" with Control.Arrow ?
11:57:40 <statusfailed> The best I can come up with is "fewer brackets"
11:57:55 <ChristianS> plucas: switching from string (list of char) to bytestring should give an additional performance boost, string is known to be slow
11:57:56 <dmwit> statusfailed: It's possible that some arrows have more efficient implementations of "first" and "second".
11:58:00 <aluink> who runs the hackage wiki?
11:58:02 <mandaya> dmwit: I thought someone mentioned that it picks up on some deliberate attempts
11:58:11 <statusfailed> dmwit: wouldn't that be an argument for using (id ***) ?
11:58:14 <dmwit> mandaya: Nothing GHC itself doesn't do.
11:58:16 <statusfailed> err, for using "second"
11:58:19 <mandaya> ahh, kk
11:58:28 <dmwit> statusfailed: Yes, isn't that what you asked for?
11:58:32 <statusfailed> dmwit: other way around
11:58:35 <statusfailed> I saw (id ***) in code
11:58:37 <statusfailed> wondering why is all
11:58:46 <dmwit> Probably a brain-fart on the author's part.
11:58:57 <plucas> Using [Char] instead and compiling with 'ghc --make -O2 test' didn't make a noticeable difference
11:58:58 <rwbarton> probably just indicates the author didn't know about or forgot the existence of "second"
11:59:04 <dmwit> Possibly for clarity or to have code that looked similar to some other part of the codebase.
11:59:16 <statusfailed> ok, so no technical reason
11:59:18 <dmwit> plucas: String is [Char], there's no difference there
11:59:23 <statusfailed> cooooolbeans
11:59:30 <ChristianS> @hoogle bytestring
11:59:30 <lambdabot> Data.ByteString data ByteString
11:59:30 <mandaya> plucas: did you remove all the compiled code? I sometimes forget.
11:59:31 <lambdabot> Data.ByteString.Char8 data ByteString
11:59:31 <lambdabot> Data.ByteString.Lazy data ByteString
11:59:31 <statusfailed> cheers
11:59:35 <dmwit> > let x = x in x -- mandaya
11:59:38 <lambdabot>   mueval-core: Time limit exceeded
11:59:39 <plucas> dmwit: oh maybe I misinterpreted ChristianS's suggestion
11:59:48 <dmwit> plucas: Yes, you did. =)
11:59:56 <plucas> mandaya: yeah I deleted test, test.hi, and test.o
12:00:21 <plucas> ah ok re-read I get it
12:00:35 <plucas> that's like… Data.Char.Somethingerother. I'll look it up
12:00:37 <mandaya> plucas: kk, I just know I've been bit by that a few times
12:01:20 <neutrino> dmwit why would you expect this to be equal to () ?
12:01:47 <dmwit> neutrino: Why would you think I expected this to be equal to ()?
12:02:00 <dmwit> neutrino: Also, what is "this"?
12:02:07 <rwbarton> @let this = ()
12:02:08 <lambdabot>  Defined.
12:02:14 <rwbarton> that should sort things out.
12:02:15 <neutrino> 22:01 < dmwit> > let x = x in x -- mandaya
12:02:53 <erus`> @pl dup a = (a, a)
12:02:54 <lambdabot> dup = join (,)
12:02:55 <dmwit> neutrino: Where do I imply that should be ()?
12:03:17 <neutrino> i thought you were following up on what rwbarton said.
12:03:22 <dmwit> ah
12:03:27 <dmwit> No, I was following up on what I said.
12:03:31 <neutrino> ok.
12:03:37 <dmwit> But apparently I was wrong, and lambdabot doesn't do black-hole detection for some reason.
12:04:00 <neutrino> what is black-hole detection?
12:04:00 <dmwit> I guess it interprets code rather than compiling it, which in retrospect makes a lot of sense anyway.
12:04:04 <neutrino> sorry i have never heard this term
12:04:13 <dmwit> neutrino: Try compiling and running the program "main = main". =)
12:04:16 <dmwit> Then you'll know. =)
12:04:24 <plucas> ChristianS: I tried dropping in ByteString there (with import etc), but get "Couldn't match expected type `ByteString' with actual type `[Char]'" inside the (read :: ByteString -> Int)
12:04:52 <neutrino> main: <<loop>>
12:04:55 <rwbarton> @hoogle readInt
12:04:56 <lambdabot> Numeric readInt :: Num a => a -> (Char -> Bool) -> (Char -> Int) -> ReadS a
12:04:56 <lambdabot> Text.Read.Lex readIntP :: Num a => a -> (Char -> Bool) -> (Char -> Int) -> ReadP a
12:04:56 <lambdabot> Data.ByteString.Char8 readInt :: ByteString -> Maybe (Int, ByteString)
12:05:04 <dmwit> neutrino: In short, it detects some infinite loops -- but actually not that many -- by replacing thunks with a thunk that immediately throws an exception during its own evaluation.
12:05:07 <neutrino> however interpreting it hangs in that loop.
12:05:07 <Palmik> Hmm, weird. I have a JSON document which has field named "replies" that can be either Object or String. I use this code: (b .:? "replies" .!= HM.empty) it works in the case "replies" is an Object, but if it's a string I get "when expecting a HashMap Text a, encountered String instead". Should not .:? take care of that?
12:05:08 <plucas> neat :)
12:05:25 <Palmik> (context: aeson).
12:05:30 <neutrino> dmwit: ok interesting, i was having an argument about something similar yesterday or two days ago
12:05:44 <ChristianS> plucas: Bytestring comes with its own api, see http://hackage.haskell.org/packages/archive/bytestring/latest/doc/html/Data-ByteString.html
12:06:19 <neutrino> dmwit: i was saying that it would be interesting for haskell to be able to tell if a list is infinite or not (without always being able to decide about it)
12:06:33 <ChristianS> plucas: replace getContents by B.getContents (if you imported Data.ByteString as B) for a start
12:06:36 <neutrino> dmwit: so for example you could always tell that "repeat 1" is infinite, and that [] is finite.
12:06:59 <neutrino> dmwit: then people started arguing that this somehow changes the program because of termination being a value and so on.
12:07:08 <hpaste> DanBurton pasted “[2/12/2012] Challenge #5 [easy] ” at http://hpaste.org/63638
12:07:37 <dmwit> neutrino: Yes, black-hole detection changes the semantics of some programs.
12:07:42 <DanBurton> What do you guys think about this implementation of password input? ^ Is there a better way?
12:07:57 <mandaya> Palmik: there's a different combinator you want, one sec
12:07:58 <dmwit> neutrino: Most people are okay with it, though, because they view it as an optimization from O(infinity) to O(1). =)
12:08:02 <neutrino> DanBurton: why is that a "challenge"
12:08:17 <DanBurton> neutrino: I wrote it for /r/dailyprogramming
12:08:24 <neutrino> dmwit: so do i, but my suggestion for detecting infinite lists has met with heated debate.
12:08:33 <neutrino> DanBurton: i'm still not sure why
12:08:39 <dmwit> DanBurton: Um, why wouldn't you just set stdin to not echo input?
12:08:43 <Palmik> mandaya, OK.
12:08:54 <DanBurton> dmwit: you can do that?
12:09:03 <dmwit> DanBurton: http://hackage.haskell.org/packages/archive/base/latest/doc/html/System-IO.html#v:hSetEcho
12:09:04 <neutrino> yes.
12:09:16 <DanBurton> TIL
12:09:17 <mandaya> Palmik: hmm, looks like Aeson doesn't expose that part of Attoparsec
12:09:47 <mandaya> Palmik: well... try (<|>)
12:09:51 <dmwit> neutrino: I would point out that detecting pointer equality (e.g. testing if lists are cyclic) is very different from detecting thunk equality.
12:09:58 <mandaya> Parsers are Applicative so it should work
12:10:15 <dmwit> neutrino: If you really, really want to do it, GHC exposes enough of its internals that you can do so.
12:10:37 <dmwit> neutrino: But this will break a lot of the properties you really expect to hold of your pure code.
12:10:51 <dmwit> neutrino: (It breaks many more things than the simple black-hole thing does.)
12:11:11 <dmwit> neutrino: Note that the black-hole detection will never turn a *productive* infinite list into an exception -- only non-productive ones.
12:11:19 <Palmik> mandaya, yes, that works. Thanks.
12:11:25 <mandaya> Palmik: great :)
12:11:26 <dmwit> You can substitute any type you like for "list" in that last sentence, too.
12:11:53 <mandaya> Palmik: you can probably change that .:? combinator to just .: now
12:12:02 <Palmik> Yep, I did that.
12:12:28 <neutrino> dmwit: i wouldn't point that out because i don't know why i would be talking about thunk equality. do you mean the whole halting problem yadda people always bring up?
12:13:27 <neutrino> dmwit: btw, i didn't expect haskell to always die when it detects an infinite list, i just expected there to be a "length2" function which can return "Infinite"
12:13:46 <neutrino> dmwit: i hope this makes more sense. i think this wouldn't break any of those properties that you mean.
12:15:38 <osa1> I can't install any of Haskell web frameworks. I'm getting same error. can anyone help me? http://paste.pocoo.org/show/550490/ I'm using ghc 7.0.4 cabal-install 0.10.2 (Cabal 1.10.2.0)
12:15:43 <dmwit> Nah, nothing I was talking about had anything to do with the halting problem.
12:15:50 <ChristianS> neutrino: haskell knows the length of a list once it has reached the end of a list. bad luck for infinite lists...
12:16:01 <dmwit> neutrino: But a length2 function which can sometimes return Infinite would, indeed, break many of the properties I mean.
12:16:34 <ChristianS> @faq can haskell solve the halting problem?
12:16:34 <lambdabot> The answer is: Yes! Haskell can do that.
12:16:40 <hpaste> plucas annotated “slow” with “slow (annotation)” at http://hpaste.org/63636#a63640
12:16:53 <dmwit> neutrino: For example, I expect that "length xs = length (map xs)", whereas if you can return infinity, then probably you will find that "length (repeat 1) = Infinity" but "length (map (const 1) (repeat 1))" will loop.
12:17:21 <dmwit> neutrino: (Speaking here specifically of GHC, not Haskell -- since Haskell doesn't have the necessary pieces to even write this code!)
12:18:11 <hpaste> plucas annotated “slow” with “slow (annotation)” at http://hpaste.org/63636#a63641
12:18:14 <otters> @src unzip
12:18:14 <lambdabot> unzip = foldr (\(a,b) ~(as,bs) -> (a:as,b:bs)) ([],[])
12:18:17 <otters> what does the ~ mean?
12:18:25 <dmwit> otters: It's an irrefutable pattern match.
12:18:49 <dmwit> otters: It means, "don't bother evaluating the argument, even to weak-head normal form; just trust me that the constructor I say here is the one that you will actually get if you try".
12:18:55 <otters> Oh, neat
12:19:04 <dmwit> otters: Later, when you use the variables from the pattern, if it turns out not to be that constructor... you get an error.
12:20:09 <dmwit> neutrino: ...and of course I meant "length xs = length (map f xs)" as my law, not the untypeable nonsense I wrote. =P
12:20:27 <jedai|2> otters: But here of course you're sure that that won't ever happen :)
12:22:07 <Jedai> otters: and the advantage is that thanks to this irrefutable pattern, unzip can bebin producing the two lists immediately instead of needing to get to the end of the list checking (successfully) that it get a pari every time
12:22:39 <Jedai> otters: And thanks to that unzip works more efficiently _and_ for infinite lists :D
12:22:41 <dmwit> Jedai++ I focused on the trees and forgot the forest.
12:23:21 <sipa> :t unzipBy
12:23:22 <lambdabot> Not in scope: `unzipBy'
12:23:34 <Jedai> dmwit: Well you explained what it does and I explained why you would want to use that in this partucalar case, I guess both answers were necessary
12:23:46 <sipa> @hoogle (a -> (b,c)) -> [a] -> ([b],[c])
12:23:46 <lambdabot> No results found
12:24:12 <sipa> :t zip . map
12:24:13 <lambdabot>     Couldn't match expected type `[a]'
12:24:13 <lambdabot>            against inferred type `[a1] -> [b]'
12:24:13 <lambdabot>     Probable cause: `map' is applied to too few arguments
12:24:36 <sipa> :t unzip . map
12:24:37 <lambdabot>     Couldn't match expected type `[(a, b)]'
12:24:37 <lambdabot>            against inferred type `[a1] -> [b1]'
12:24:38 <lambdabot>     Probable cause: `map' is applied to too few arguments
12:24:51 <dmwit> :t (unzip .) . map
12:24:52 <lambdabot> forall a b a1. (a1 -> (a, b)) -> [a1] -> ([a], [b])
12:25:54 <Jedai> > let unzipBy f = unzip . map f in unzipBy (divRem 10) [23,27..100]
12:25:54 <lambdabot>   Not in scope: `divRem'
12:26:15 <Azel> :t divQuot
12:26:16 <lambdabot> Not in scope: `divQuot'
12:26:28 <Azel> :t divMod
12:26:29 <lambdabot> forall a. (Integral a) => a -> a -> (a, a)
12:26:30 <Jedai> > let unzipBy f = unzip . map f in unzipBy (divMod 10) [23,27..100]
12:26:32 <lambdabot>   ([0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],[10,10,10,10,10,10,10,10,10,10,1...
12:27:22 <Jedai> > let unzipBy f = unzip . map f in unzipBy (`divMod` 10) [23,27..100]
12:27:24 <lambdabot>   ([2,2,3,3,3,4,4,5,5,5,6,6,7,7,7,8,8,9,9,9],[3,7,1,5,9,3,7,1,5,9,3,7,1,5,9,3...
12:27:41 <lukish> > intercalate "," ["a","b"]
12:27:42 <lambdabot>   "a,b"
12:27:44 <Jedai> Thanks Azel
12:27:52 <lukish> How can i do it for "a" and "b"
12:27:57 <Azel> You're welcome
12:27:59 <lukish> Some uncurry magic
12:28:05 <lukish> But I cannot understand
12:28:21 <dmwit> lukish: I don't understand the question.
12:28:30 <Jedai> lukish: I don't understand what you mean
12:28:39 <lukish> f "a" "b" -> "a,b"
12:28:52 <lukish> With intercalate ","
12:29:11 <dmwit> > let f s1 s2 = s1 ++ "," ++ s2 in f "a" "b" -- why intercalate?
12:29:13 <lambdabot>   "a,b"
12:29:17 <Jedai> lukish: f x y = x ++ "," ++ y
12:29:18 <alpounet> Jedai, quotRem is more efficient (iirc)
12:29:26 <dmwit> > let f s1 s2 = intercalate "," [s1, s2] in f "a" "b" -- if you insist
12:29:27 <lambdabot>   "a,b"
12:29:53 <lukish> @pl (\x y -> x ++ "," y )
12:29:53 <lambdabot> (. ",") . (++)
12:29:57 <Jedai> alpounet: Yes, something to do with how quot and rem are more often implemented in the CPU as primitive :)
12:30:05 <dmwit> lukish: needs more (++)
12:30:13 <dmwit> ?pl \x y -> x ++ "," ++ y
12:30:13 <lambdabot> (. ("," ++)) . (++)
12:30:17 <alpounet> yeah
12:30:51 <Jedai> alpounet: But I prefer divMod if I'm not searching for the best performance, it mesh with the mathematical definition of euclidian division better
12:35:23 <chairdog> in ghc 7.4 safe haskell, should I be able to specify multiple -trust parameters like this?
12:35:27 <chairdog> $ ghc -fpackage-trust -trust random-1.0.0.3 -trust base -XSafe --make auction3
12:35:54 <dylukes> "safe haskell"?
12:36:00 <chairdog> dylukes: -XSafe
12:36:15 <dylukes> Oh right.
12:36:34 * chairdog trying to make a website where people upload haskell code
12:36:59 <DanBurton> chairdog: a site that would run that Haskell code?
12:37:06 <DanBurton> that which was uploaded
12:37:29 <chairdog> DanBurton: its a donation matching site where donations can be conditional on other donations
12:37:37 <chairdog> i want to use haskell as the langauge for that
12:37:54 <chairdog> so basically bidders all upload their bids, it all goes into some optimisier like a simualted annealing program or something
12:38:29 <dylukes> Generalized Newtype Deriving is disabled by Safe Haskell?
12:38:30 <dylukes> why?
12:39:04 <dylukes> Oh, I see.
12:40:11 <lukish> How can I get Just "a,b" from (Just "a",Just "b")?
12:40:55 <Taneb> \(Just a,Just b)-> a ++ ',':b
12:41:06 <bgamari> Anyone know who I should talk to about volunteering for Hackage 2 duty?
12:41:28 <bgamari> Duncan I guess is a good start?
12:41:29 <erus`> @hoogle (m a , m b) -> m (a, b)
12:41:30 <lambdabot> No results found
12:41:42 <c_wraith> bgamari: well, cmccann is running a test site and accepting patches at the moment
12:42:01 <Enigmagic> yuck but:
12:42:04 <Enigmagic> > uncurry (liftM2 (,)) (Just "a", Just "b")
12:42:05 <lambdabot>   Just ("a","b")
12:42:20 <Enigmagic> err i guess not
12:42:21 <gwern> > let bh (index,pvalue) = pvalue < ((index * 0.05) / X) in map bh (zip [1..] [0.005276, 0.02205, 0.06163, 0.06904, 0.4015, 0.5084, 0.538, 0.7411])
12:42:21 <lambdabot>   Not in scope: data constructor `X'
12:42:23 <Enigmagic> need the ++
12:42:35 <gwern> > let bh (index,pvalue) = pvalue < ((index * 0.05) / 8) in map bh (zip [1..] [0.005276, 0.02205, 0.06163, 0.06904, 0.4015, 0.5084, 0.538, 0.7411])
12:42:36 <lambdabot>   [True,False,False,False,False,False,False,False]
12:42:39 <Enigmagic> > uncurry (liftM2 (++)) (Just "a", Just "b")
12:42:41 <lambdabot>   Just "ab"
12:43:32 <ChristianS> plucas: not sure if you're now satisfied with your example (and i don't understand what it's doing), but for me the haskell version is 3 times faster than the python version
12:43:42 <elliott> cmccann: speaking of which, would you be open to a patch that makes the main site look consistent compared to the package pages? the completely different style is weird
12:44:08 * hackagebot http-types 0.6.9 - Generic HTTP types for Haskell (for both client and server code).  http://hackage.haskell.org/package/http-types-0.6.9 (AristidBreitkreuz)
12:44:10 <dcoutts> bgamari: yes, me
12:44:26 <dcoutts> bgamari: but I need to pop out to the shops first... :-)
12:45:30 <plucas> ChristianS: I'm using as input one million lines of random numbers. With the ByteString improvement, the haskell is ~3x slower than the python: http://pastebin.com/RBThCr7W
12:45:31 <cmccann> elliott, personally I think that'd be great, but I'm not really the final authority on what hackage should look like
12:45:31 <mauke> The paste RBThCr7W has been copied to http://hpaste.org/63642
12:46:26 <kallisti> remind me never to read the comments on the online version of RWH.
12:46:44 <bgamari> dcoutts: I was about to send a message to haskell-cafe
12:46:59 <bgamari> dcoutts: but we can just talk here later if you'd rater
12:47:06 <elliott> cmccann: that's the advantage of being the official unofficial maintainer! :P
12:47:12 <ChristianS> plucas: hmm, i only used about 1000 lines of input, maybe it gets slower due to the non-strict reading of input for very large input files...
12:47:13 <bgamari> s/rater/rather
12:47:32 <cmccann> well I don't want to make it harder to integrate changes into an official official version at some unspecified point in the future
12:47:46 <plucas> ChristianS: maybe. I did notice that if I just used lists here, the haskell is faster. But I was curious about set performance.
12:48:20 <cmccann> elliott, but any reasonably self-contained changes are fine
12:48:30 <dmwit> lukish: f s1 s2 = s1 ++ "," ++ s2; then use "liftM2 f"
12:48:30 <elliott> cmccann: I'll do it in a branch
12:48:45 <dmwit> > let f s1 s2 = s1 ++ "," ++ s2 in liftM2 f (Just "a") (Just "b")
12:48:47 <lambdabot>   Just "a,b"
12:48:53 <ChristianS> plucas: hm, you first built a list and then convert it into a set, that's has to come with a performance penalty...
12:49:00 <dmwit> lukish: But, uh... String is a lousy data structure.
12:49:08 * hackagebot http-proxy 0.0.10 - A library for writing HTTP and HTTPS proxies  http://hackage.haskell.org/package/http-proxy-0.0.10 (ErikDeCastroLopo)
12:49:08 <cmccann> elliott, yeah, I was thinking of doing that myself for trying out more drastic changes
12:49:36 <cmccann> bgamari, btw the copy I'm running is currently here: http://hackage2.uptoisomorphism.net:8080/
12:50:03 <lukish> uncurry (liftM2 (curry (\(a,b) -> a ++ "," ++ b))) (Just "1234",Just "1234")
12:50:04 <bgamari> cmccann: I have a copy on my laptop at this point
12:50:08 <cmccann> ok
12:50:09 <bgamari> cmccann: Was quite painless
12:50:14 <lukish> How can I beautified it?
12:50:17 <elliott> cmccann: cabal: The install plan contains reinstalls which can break your GHC
12:50:17 <elliott> installation.
12:50:17 <elliott> :(
12:50:19 <elliott> with cabal-dev
12:50:25 * elliott tries the modular solver
12:50:34 <cmccann> elliott, yes, I discovered that myself
12:50:37 <cmccann> the harder way
12:50:38 <cmccann> sigh
12:50:38 <elliott> how did you fix it?
12:50:43 <elliott> --solver=modular --avoid-reinstalls?
12:50:57 * chairdog realises that despite -trust random, its now reported that the random module is not *safe* rather than not trusted...
12:51:00 <cmccann> manually mostly
12:51:01 <ChristianS> plucas: but you count the number of different numbers, so have to use a set to get correct results, right?
12:51:03 <elliott> that fails too
12:51:04 <elliott> sigh
12:51:12 <cmccann> I'd just
12:51:13 <cmccann> ergh
12:51:19 * elliott isn't quite sure how to solve this one...
12:51:20 <cmccann> I'd just upgraded my GHC
12:51:24 <cmccann> so I had to rebuild everything anyhow
12:51:54 <cmccann> I'm not quite sure how all the cabal voodoo works with that stuff, any idea how to avoid it in the first place?
12:51:59 <elliott> well I'm using cabal-dev
12:52:03 <elliott> so there's nothing "installed" so to speak
12:52:10 <elliott> except for the global packages that come with GHC
12:52:22 <cmccann> right
12:52:29 <plucas> ChristianS: that was a somewhat contrived reason. I guess a more realistic use case would be for membership testing later, but I pretty much just wanted to look at the set creation part
12:52:33 <elliott> bgamari: what ghc version did you use?
12:52:51 <ChristianS> plucas: yes, i understand...
12:52:57 <bgamari> elliott: 7.4
12:53:07 <bgamari> elliott: prerelease
12:53:55 <elliott> bgamari: I'm using 7.4.1, did you have to do anything special to get it installed?
12:54:20 <bgamari> elliott: had to install Cabal and alex
12:54:50 <lispy> Is the haskell-platform@projects list working?
12:55:09 <elliott> bgamari: had to install Cabal?!
12:55:11 <lispy> I'm subscribbed and I sent an email a few days ago that still hasn't appeared in the archive
12:55:17 <bgamari> elliott: Upgrade
12:55:18 <lispy> Not sure who I should talk to about this
12:55:19 <elliott> bgamari: that sounds GHC-breaking...
12:55:23 <elliott> you're not meant to upgrade boot packages
12:56:21 <cmccann> elliott, btw, I'm thinking of doing a partial mirror
12:56:26 <cmccann> enough to make my instance vaguely usable as a sort of cheap plastic imitation hackage
12:56:27 <bgamari> elliott: Nothing has exploded yet but this isn't my primary GHC tree
12:56:41 <cmccann> then point my own cabal stuff at it for a while and see if anything falls over under actual use
12:57:04 <elliott> cmccann: it's just a 230MB tarball for the whole thing
12:57:14 <elliott> but I guess it might cause more server load
12:57:14 <lispy> ?tell dcoutts I suspect the haskell-platform mailing list is not receiving (or maybe not sending) traffic.  Who should I talk to?
12:57:14 <lambdabot> Consider it noted.
12:57:30 <cmccann> elliott, you mean the "latest versions only" tarball?
12:57:38 <elliott> cmccann: right -- wouldn't that work?
12:57:57 <elliott>     Cabal      == 1.14.*,
12:57:58 <elliott> aha
12:58:07 <cmccann> I might just do that, not sure. I don't want to overload my dollar-store EC2 instance :P
12:58:09 <elliott> oh, hmm
12:58:12 <elliott> that's the version I have :/
12:58:36 <elliott> cmccann: do you remember what manual stuff you had to do to get it working?
12:58:55 <bgamari> elliott: It seems that I'm still running Cabal 1.10.1.0 so perhaps I misrecalled
12:59:16 <elliott> bgamari: Cabal 1.10 with GHC 7.4?
12:59:20 <elliott> something sounds very broken about your setup
12:59:22 <cmccann> elliott, unregister stuff shadowing boot packages, reinstall things piecemeal to figure out where the sticking points might be
12:59:24 <bgamari> Unfortunately history(3) doesn't want to jot my memory
12:59:37 <cmccann> also I bumped a few dependencies in the hackage-server cabal
12:59:38 <bgamari> elliott: Oops, yes, this is my ghc-7.0.3 prefix
12:59:54 <cmccann> time, containers, and deepseq
13:00:25 <bgamari> cmccann: I'm assuming you know about the old-deepseq-containers flag?
13:00:30 <cmccann> to get hackage-server and all the dependencies agreeing on using the same versions
13:00:52 <cmccann> bgamari, yeah, but I'd already started mucking about with broken packages before I found that
13:01:06 <bgamari> ahh
13:01:17 <bgamari> I've got to run, be back later
13:01:22 <cmccann> not sure if that was part of what caused problems to begin with or not
13:01:41 * elliott tries that flag
13:02:02 * elliott wonders what "-bytestring-in-base" means
13:02:20 <c_wraith> there was a time, the before-time, in which base contained ByteString
13:02:24 <luite> hmm, is hackage2 difficult to install? i already hav e a fully copy of the hackage archive
13:02:25 * elliott installs happstack-server separately to try and help
13:02:32 <elliott> luite: on ghc 7.4, yes
13:02:35 <elliott> probably easier on 7.0
13:02:54 <luite> actually I think it's even usable as a hackage mirror
13:03:17 <elliott> where is the "full" hackage archive?
13:03:58 <dcoutts> bgamari: hia, I'm back
13:03:58 <lambdabot> dcoutts: You have 2 new messages. '/msg lambdabot @messages' to read them.
13:04:52 <dcoutts> oh, he's gone
13:05:12 <luite> elliott: I downloaded all tar.gz files separately
13:06:05 <dcoutts> cmccann: I hope you found the hackage-mirror client
13:06:13 <elliott> luite: ouch
13:06:15 <cmccann> dcoutts, yes
13:06:20 <dcoutts> elliott: on the main hackage server :-)
13:06:26 <luite> elliott: it's 19891 tar.gz files at the moment
13:06:34 <elliott> dcoutts: ?
13:06:45 <cmccann> dcoutts, just not sure I want to subject my tiny EC2 instance to that :P
13:06:56 <dcoutts> cmccann: no probably not
13:07:08 <cmccann> also I was getting errors trying to restore from an archive tarball
13:07:09 <dcoutts> elliott: you were asking where the full archive is
13:07:16 <cmccann> which I'm trying to figure out now
13:07:23 <luite> cmccann: took a while, but I can make a large tar.gz for you if you want
13:07:36 <elliott> dcoutts: ah
13:07:45 <dcoutts> cmccann: what do you mean precisely by an archive tarball?
13:08:00 <cmccann> luite, maybe later, don't really need it right now
13:08:04 <dcoutts> elliott: it's nothing special just a big directory tree on the server, served by apache
13:08:14 <cmccann> dcoutts, errrrr I mean the backup tarball
13:08:19 <cmccann> that hackage2 produces
13:08:21 <elliott> dcoutts: right
13:08:33 <dcoutts> cmccann: ok, so you generated it with hackage-server backup
13:08:55 <elliott> cmccann: I was also thinking that it'd be nice if it used blaze-html rather than xhtml for speed... I suppose I should just shut up and code :)
13:08:56 <dcoutts> cmccann: ok, so fixing bugs in the round-trip there would be very useful
13:09:00 <cmccann> no, it was the output of convert applied to the most recent packages tarball that I downloaded from hackage a while back
13:09:22 <cmccann> elliott, I think that's in the TODO, isn't it
13:09:26 <dcoutts> elliott: yes indeed (to using blaze, not to telling you to shut up ;-)
13:09:45 <elliott> cmccann: excellent, it must be a good idea then :P
13:09:54 <cmccann> (there is in fact a TODO with some worthwhile things to work on, if you hadn't noticed)
13:10:01 <dcoutts> we have a new visual design too, if someone wants to work on that
13:10:04 <elliott> I kinda wish there was more formatting/logic separation than there seems to be, but maybe I'm just not used to the codebase yet
13:10:12 <cmccann> yes, anything written in a file named TODO is almost certainly a good idea that should be implemented immediately
13:10:19 <elliott> dcoutts: oh, you do? I was planning to make the "normal" pages look like the package pages, but if there's a plan for something else...
13:10:41 <elliott> (in my fork)
13:10:59 <cmccann> dcoutts, is there a non-kaput central location with anything like that?
13:11:12 <cmccann> would ease my efforts to get more people than just elliott hacking on it
13:11:52 <dcoutts> elliott: grr, I really need to restore the cabal trac, that's got the link to the new design
13:11:52 <elliott> pfft, anyone else will just ruin things
13:12:05 <elliott> :)
13:12:15 <elliott> dcoutts: ha, i knew it
13:12:18 * cmccann ruins things
13:12:29 <elliott> cmccann: no, no, you're great at pushing my changes
13:12:37 <cmccann> haha
13:15:37 <eyebloom> does a let expression desugar to a lambda?
13:16:12 <c_wraith> not exactly
13:16:27 <c_wraith> actually, not at all.  they have different semantics
13:16:40 <dcoutts> right, let is a primitive in core
13:16:47 <elliott> isn't `let p = x in e` === `(\ ~p -> e) x`?
13:16:58 <elliott> (I think eyebloom is talking Report-wise, not Core-wise, also)
13:17:03 <c_wraith> pattern matches in let bindings are irrefutable.  pattern matches in lambdas are refutable
13:17:18 <dcoutts> yes, it's the same if you only mean the static semantics
13:17:50 <eyebloom> c_wraith: ahh, good point.
13:18:15 <Saizan> actally, it's the same (adding the ~) if you mean runtime, but let id = \x -> x in .. and (\id -> ..) (\x -> x) are typed differently
13:18:29 <eyebloom> I think elliott is correct though aside from the patterns.
13:18:39 <c_wraith> actually, elliot included the ~
13:18:40 <Saizan> take .. to be (id True, id 'a')
13:18:42 <cmccann> dcoutts, incidentally, is there anyone really responsible for the hackage-server codebase right now?
13:18:54 <c_wraith> which makes the pattern match irrefutable
13:19:37 <elliott> oh, right, typing
13:19:43 <elliott> let gives you generalisation
13:20:08 <c_wraith> unless there MonoLocalBinds going on
13:20:15 <eyebloom> I see. What do you mean by generalization?
13:20:25 <elliott> eyebloom: given "let id = \x -> x in ...", you can use id at multiple types
13:20:32 <elliott> like, id () and id "abc" both work in ...
13:20:39 <elliott> but given (\id -> ...) (\x -> x), id is forced to be monomorphic
13:20:56 <elliott> so `let id = \x -> x in (id (), id "abc"))` types but `(\ ~id -> (id (), id "abc")) (\x -> x)` doesn't
13:20:59 <ChristianS> plucas: replacing Data.Set by Data.HashSet (from the unordered-containers package) leads to 30-35% speed-up
13:21:02 <elliott> the former doesn't type with MonoLocalBinds though
13:21:07 <elliott> which IIRC GHC turns on by default nowadays
13:21:22 <elliott> cmccann: "cabal-dev install happstack-server" seems to help get a lot of dependencies through to start with
13:21:28 <cmccann> dcoutts, I'd like to hack on it a bit and make some improvements once I get more familiar with the code but not sure who (if anyone?) would be picking what changes should go on an eventual official site
13:21:33 <ChristianS> plucas: you can also replace Data.ByteString.Char8 by Data.ByteString.Lazy.Char8 which won't help or hinder speed but which reduces memory usage somewhat
13:21:43 <cmccann> elliott, yeah, that's basically what I ended up doing
13:22:02 <elliott> cmccann: now the problem is that it thinks I don't have cryptopp installed, even though I do :(
13:22:09 <cmccann> after ripping out some broken packages, I got happstack installed successfully and things mostly fell into place
13:22:17 <cmccann> I may have needed to tweak a couple other packages though
13:22:30 <eyebloom> I see, that explains a lot. Thanks.
13:22:34 <cmccann> I kinda got used to doing that after upgrades so I don't remember if I did this time
13:22:36 <ChristianS> plucas: still only half the speed of python, though :-( i also tried replacing your Set.fromList by foldl' , but that didn't help
13:23:19 <ChristianS> plucas: guess that would require profiling so increase performance further, at least i see anything that's an obvious problem...
13:24:07 <plucas> ChristianS: yeah I was surprised at that. I didn't think python would be faster than compiled haskell in much of anything.
13:24:33 <elliott> sounds like the haskell code needs optimising
13:24:44 <elliott> /usr/lib/gcc/x86_64-unknown-linux-gnu/4.6.2/../../../../lib/libcryptopp.so: undefined reference to `pthread_key_create'
13:24:45 <elliott> ehh, wtf :(
13:25:22 <cmccann> elliott, beats me
13:26:08 <elliott> ah, --gcc-options="-pthread" solves it
13:27:40 <hpaste> ChristianS annotated “slow” with “slow (unordered-containers helps a bit)” at http://hpaste.org/63636#a63646
13:27:55 <ChristianS> elliott: feel free to take a look
13:28:10 <elliott> ChristianS: what, is that the whole thing?
13:28:28 <ChristianS> python version is at http://hpaste.org/63637 and faster, damn
13:28:31 <elliott> IIRC Python's dict/set types are really highly optimised
13:28:41 <ChristianS> elliott: yes, plucas is the author
13:28:49 <elliott> compiling with -O2?
13:28:56 <dylukes> ChristianS: Trying to optimize input?
13:28:58 <ChristianS> yes
13:29:06 <dylukes> ooh fun
13:29:08 <dylukes> I'll take a shot.
13:29:55 <elliott> cmccann: ah, it seems to turn old-deepseq-containers on by default for some reason
13:30:22 <hpaste> plucas annotated “fast” with “fast (fix typo - don't need brackets)” at http://hpaste.org/63637#a63647
13:30:25 <elliott> --flags="-old-deepseq-containers" gives a more interesting clog
13:30:31 <cmccann> yay
13:30:38 <hpaste> ChristianS annotated “slow” with “how to generate input (one method)” at http://hpaste.org/63636#a63648
13:30:44 <dcoutts> cmccann: in the absence of another maintainer, I do that, and I'm happy to grant push access to people who send good patches
13:31:01 * dcoutts is trying to restore the hackage trac...
13:31:11 <dylukes> ChristianS: What's the goal of the program?
13:31:13 <ChristianS> i used a little lua script ^^ to generate an input files (1 million numbers, one per line)
13:31:14 <dylukes> i.e., what should the input be?
13:31:22 <dylukes> Can you send me one of those files?
13:31:28 <ChristianS> dylukes: count the number of different lines
13:31:29 * elliott forces hslogger==1.1.4 and reinstalls happstack-server
13:32:38 <ChristianS> dylukes: sorry, my proxy seems unable to send files
13:32:55 <dylukes> eh, so just a column of random numbers?
13:33:00 <ChristianS> yes
13:33:04 <dylukes> How long should the numbers be?
13:33:05 <elliott> ChristianS: hpaste one of the files?
13:33:05 <dylukes> in what range.
13:33:12 <dylukes> elliott: It's a million lines he said.
13:33:16 <dylukes> That might be unwise/awkward.
13:33:28 <ChristianS> i don't know, i used range 1..100000
13:33:38 <dylukes> shouldn't be too hard
13:33:39 <cmccann> dcoutts, I'm mostly wondering whether making changes to actual functionality is worthwhile as anything other than for my own use, or if I should stick to bugfixes for stuff to push upstream
13:33:42 <ChristianS> (see the little lua script)
13:33:58 <ChristianS> no idea which range plucas used
13:34:10 * hackagebot sodium 0.1.0.0 - Sodium Reactive Programming (FRP) System  http://hackage.haskell.org/package/sodium-0.1.0.0 (StephenBlackheath)
13:34:15 <dcoutts> cmccann: stuff that's useful to you is likely useful for other people. What are you thinking of?
13:34:29 <ChristianS> dammit something's wrong...
13:35:16 <dylukes> File.open("input.txt", "w") {|f| 1000000.times {|x| f.puts "#{rand(100000)}\n"}}
13:35:19 <dylukes> this seem equivalent to your lua?
13:35:23 <dylukes> (I haven't seen your lua)
13:35:25 <plucas> ChristianS: I generated 1 mil random nums in range (0,1 mil]
13:35:33 <hpaste> plucas pasted “bunchanums” at http://hpaste.org/63649
13:35:36 <dylukes> I did 0..100000
13:35:38 <ChristianS> dylukes: yes
13:35:53 <dylukes> plucas: 10 myriad, not 100 myriad.
13:35:59 <hpaste> ChristianS annotated “slow” with “how to actually generate input (one method) (annotation)” at http://hpaste.org/63636#a63650
13:36:12 <dylukes> okay
13:36:26 <dylukes> need to do timing now...
13:36:43 <dylukes> I'm getting 2.28s
13:36:55 <dylukes> For 100 myr numbers with no optimization flags.
13:37:05 <dylukes> Is that comparable to your results?
13:37:16 <cmccann> dcoutts, nothing concrete yet, but I'm pretty sure I'll want to make some changes to the build system and add more ways to search and filter packages
13:37:29 <ChristianS> dylukes: try the python version for comparison
13:37:32 <plucas> dylukes: yeah - I get about ~3sec for haskell, ~1sec for python
13:37:40 <plucas> (python 2.7)
13:37:42 <dylukes> One moment, I have an idea :\
13:38:01 <elliott> dylukes: no optimisation flags?
13:38:02 <elliott> why?
13:38:08 <dylukes> Just to try a baseline
13:38:17 <dylukes> Why would I try opitmization flags without being able to tell if they're helping :P.
13:38:18 <dcoutts> cmccann: ok, so working on the build client would certainly be useful
13:38:21 <cmccann> dcoutts, also thinking it would be nice if browsing the tarball was nicer
13:38:30 <ChristianS> i always use -O2
13:38:43 <dcoutts> cmccann: take a look at the existing doc builder client, we'll need something similar for ordinary build results
13:38:49 <cmccann> I kind of want colorized source with cross-links to other packages and such
13:39:02 <dylukes> -O2 doesn't really help here at all.
13:39:07 <dylukes> Since you know, it's an IO thing.
13:39:19 <dcoutts> cmccann: well the haddock docs link to highlighted sources
13:39:42 <dcoutts> cmccann: the tarball browser is simply for the contents of the tarball, no interpretation or transformations
13:39:46 <elliott> dcoutts: doesn't work for viewing Internal.hs
13:39:54 <cmccann> yeah
13:39:56 <elliott> it would be nice if the tarball view showed the whole file tree on one page
13:40:03 <elliott> there's no real need for separate pages for directories
13:40:04 <cmccann> I specifically want nicer views of the raw file
13:40:07 <cmccann> and yes the tree structure
13:40:08 <dcoutts> elliott: that's true
13:40:12 <dylukes> ChristianS: I'm going to try a few things.
13:40:17 <dylukes> i'll let you know how this goes...
13:40:28 <dcoutts> cmccann: well we certainly want the raw files too
13:40:40 <cmccann> dcoutts, partly I'm not sure yet everything it already does, so I don't have specific plans
13:40:42 <cmccann> yeah of course
13:40:49 <plucas> disconnecting - I'll check the log if you all find out anything
13:40:56 <cmccann> but I'm thinking something more like hpaste where you get a nicer view with a "raw" link
13:41:23 <dcoutts> elliott: true, the haddock docs are aimed at documenting the API, not as documentation of the code itself or a general source browser
13:41:38 <dcoutts> elliott: and something targeting that more specifically would certainly be nice
13:41:40 <EvanR> but it works so well as a source browser!
13:41:48 <ChristianS> dylukes: yes, i have to disappear too, it's getting late... wish you luck!
13:41:53 <dylukes> Aw,
13:41:54 <dcoutts> EvanR: yeah, not too bad, except as elliott points out
13:41:56 <dylukes> when will you be back
13:42:11 <dylukes> I'd like to fix this up...
13:42:31 <dcoutts> cmccann: mm, though how do you know how to interpret the files? they're not all text files
13:42:42 <dcoutts> cmccann: you can try guessing based on file extension I suppose
13:42:59 <cmccann> dcoutts, yeah
13:43:09 <ChristianS> dylukes: i'll check back in 15 minutes, but after that, i'm off for the night
13:43:18 <dylukes> hm
13:43:18 <dylukes> okay
13:43:23 <dcoutts> cmccann: I'm not sure the tarball browsing needs to be fancy, it's just a bit quicker sometimes than downloading the thing
13:43:39 <dcoutts> cmccann: or as a way to give people a URL to something inside the package
13:43:44 <ChristianS> the original challenge is by plucas, can't speak for him...
13:44:01 <cmccann> dcoutts, anyway, want me to just run things past you once I have a better idea what I want to do? or does this all sound sensible enough that I should just start hacking, with the obvious caveats of not breaking functionality it already has
13:44:17 <cmccann> it doesn't need to be fancy but I've occasionally wanted a fancier view of package contents
13:44:21 <cmccann> as has elliott it sounds like
13:44:33 * elliott would suggest just going wild with improvements and reverting anything upstream doesn't like later on :P
13:44:35 <dcoutts> cmccann: sure, have a go and I'm happy to talk about it again later
13:44:43 <cmccann> strictly speaking the existing hackage does everything we NEED from it :P
13:44:44 <elliott> Control/DeepSeq.hs:56:1:
13:44:44 <elliott>     array-0.3.0.3:Data.Array can't be safely imported! The module itself isn't safe.
13:44:44 <dylukes> ChristianS: I think less of this is IO than you think...
13:44:48 <dcoutts> cmccann: I'd start with a nicer directory tree listing
13:44:49 <elliott> Does anyone know how to bypass errors like this?
13:45:03 <chairdog> elliott: i'm just encoutnering something like that
13:45:09 <cmccann> dcoutts, yeah, that's probably the first step
13:45:14 <chairdog> elliott: got halfway through understanding it then soemoen came along and interrupted me
13:45:38 <chairdog> elliott: i think maybe you could try declaring the module that does that import as -XTrustworthy
13:45:46 <chairdog> i haven't tried it yet though
13:45:53 <chairdog> i think that means it can import evil?
13:46:01 <dcoutts> cmccann: we were just following what apache does by default with directories, but yes most packages have relatively few files so we could probably list the first few levels of the tree by default, up to some maximum
13:46:08 <dcoutts> cmccann: e.g. first 100 files breadth first
13:46:12 <chairdog> elliott: let me know if it works
13:46:23 <elliott> chairdog: ok, thanks
13:46:30 <dcoutts> cmccann: perhaps use some JavaScript if you like that kind of thing
13:46:41 <elliott> dcoutts: why not just list the whole tree?
13:46:46 <elliott> even things like gtk2hs can't have /that/ many levels of nesting
13:46:47 <ChristianS> dylukes: i guess you could just cheat and remove the readInt (comparing strings instead of numbers), but since the python version parses numbers i suppose that would be unfair...
13:46:57 <elliott> chairdog: sigh - ghc: Control/DeepSeq.hs:2:14-17: Incompatible Safe Haskell flags! (Trustworthy, Safe)
13:47:02 <ChristianS> dylukes: but actually i have no idea what's the real problem...
13:47:05 <dcoutts> elliott: some tarballs have a lot of data files
13:47:26 <cmccann> anyway, I need to run and get food
13:47:50 <dcoutts> cmccann: well, you decide on the visual approach :-)
13:47:52 <dylukes> ChristianS: I do... one moment.
13:48:02 <dylukes> It might take longer than 15 minutes for me to refresh my memory though :P
13:48:41 <dylukes> "    let set = Set.fromList $ map (fst . fromJust . B.readInt) (B.lines contents)"
13:48:42 <cmccann> dcoutts, thanks for the input and support, let me know if you get the trac working, it would be useful :P
13:48:45 <dylukes> is certainly the "slow" line.
13:49:13 <dylukes> we can do better I believe.
13:51:13 <astor> is there a way to give a synonym to a constructor, in order to shorten verbose pattern matches?
13:51:18 <elliott> no
13:51:23 <elliott> she can do it
13:51:26 <elliott> https://personal.cis.strath.ac.uk/~conor/pub/she/
13:51:27 <acowley> that performance issue is surprising
13:51:28 <elliott> pattern synonyms
13:52:15 <ChristianS> dylukes: i tried doing a foldl' instead but that didn't help
13:52:27 <dylukes> mm, I have an idea...
13:52:55 <astor> thanks
13:53:09 <dylukes> ChristianS: Firstly, fromList is O(n^2)
13:53:11 <chairdog> elliott: so drop -XSafe and keep -XTrustworthy?
13:54:05 <elliott> chairdog: I can't drop it without digging into the tarball itself
13:56:28 <dylukes> ChristianS: what flags are you using?
13:56:33 <dylukes> I'm doing time cat input.txt | ./Foo btw
13:56:36 <dylukes> that similar to you?
13:56:50 <ChristianS> yes
13:56:54 <ChristianS> -O2 flag
13:57:05 <elliott> you're not using runhaskell, are you?
13:57:08 <elliott> compile it separately with ghc
13:57:14 <ChristianS> no no no
13:58:00 <dylukes> ChristianS: btw,
13:58:23 <dylukes> HashSet a is exactly equivalent to Data.HashMap.Lazy.HashMap a ()
13:58:44 <dylukes> size being exactly an alias for HashMap's size.
13:59:27 <elliott> dylukes: It's a newtype, so not really "alias"
13:59:34 <dylukes> True.
13:59:39 <dylukes> But nonetheless, it's lazy behind the scenes.
14:00:21 <ChristianS> it's faster than Data.Set, in any case (which of course is lazy too)
14:01:24 <dylukes> mm yeah
14:03:57 <chairdog> elliott: so what are you seeing? that deepseq is compiled with the -XSafe flag according to its .cabal file?
14:05:17 <dcoutts> elliott: http://althack.org/hackage/package.html
14:05:28 <dcoutts> elliott: managed to restore the hackage trac read-only for the moment
14:05:33 <dcoutts> accounts are still screwed
14:05:45 <dcoutts> but there's the design I was talking about
14:06:21 <dcoutts> (not saying it's the one true design, but a nice mockup that someone made for us)
14:06:40 <dcoutts> djahandarie's design in fact
14:07:53 <dcoutts> cmccann: trac is back up read-only
14:10:30 <djahandarie> http://althack.org/hackage/hackage4.png is the version with all the fancy stuff that I never added to the HTML mockup
14:10:53 <djahandarie> I unfortunately never figured out a reasonable way to list dependencies that works for even the ugliest packages
14:11:06 <djahandarie> (Agda has a pretty ugly dependency list but it isn't the worst)
14:11:36 <dcoutts> djahandarie: yeah, it's not so easy
14:11:50 <dcoutts> djahandarie: but I'm convinced the current way hackage does it is useless
14:11:53 <kallisti> any chance of us seeeing -XPerlQuotelikeOperators ? :P
14:12:07 <Jafet> kallisti: Q_Q
14:12:56 <Jafet> But you can already splice arbitrary expressions and quote them.
14:12:58 <elliott> kallisti: see interpolatedstring-perl6
14:13:05 <djahandarie> I think I should probably move the deps list to the bottom of the grey box, so in case it goes crazy, it won't push actual useful information off the screen
14:13:22 <elliott> dcoutts: the general layout is nice... not such a fan of the colour scheme
14:13:25 <elliott> no offence to djahandarie :P
14:13:36 <dcoutts> :-)
14:13:40 <djahandarie> The color scheme that everyone likes is blue
14:13:44 <djahandarie> But everything is blue
14:13:53 * elliott said nothing about blue!
14:13:55 <dcoutts> elliott: yeah, I was talking to someone else about using something more like the new haskell.org colour scheme
14:14:05 <dcoutts> which is same as the current haddock theme
14:14:10 <elliott> dcoutts: yeah, that's what I like about the current package page
14:14:17 <dcoutts> personally I don't really care
14:14:22 <elliott> I might have a go at implementing something
14:14:28 <djahandarie> I think I actually made that design before haskell.org got redesigned
14:14:32 <elliott> the side-by-side alternate dependency list thing is nice but I don't think it'd scale
14:14:34 <dcoutts> I'm happy for people with taste to work it out :-)
14:14:39 <djahandarie> elliott, it certainly doesn't
14:14:40 <cmccann> ah, restoring the backup dies because uu-parsinglib has no category
14:14:41 <cmccann> yay
14:14:49 <djahandarie> elliott, http://althack.org/hackage/hackage3.png
14:15:06 <djahandarie> That's a more "scalable" one, but it's still not perfectly scalable, and is miles more unreadable
14:15:07 <dcoutts> elliott: no indeed, it does not
14:15:32 <elliott> djahandarie: I would probably show alternate ones just divided with "-- or -----------------" or something in the vertical style
14:15:35 <elliott> better to be long than wide
14:15:59 <dcoutts> djahandarie: something like the way .cabal files present deps might work better
14:16:01 <djahandarie> Yes, but it means deps will have to be below everything else to avoid pushing everything else off the screen.
14:16:04 <cmccann> anyway thanks for getting the trac fixed, dcoutts
14:16:08 <dcoutts> djahandarie: that is at least already factorised
14:16:10 <elliott> djahandarie: yeah, but deps aren't that important anyway
14:16:14 <cmccann> now I'm leaving again to get dinner
14:16:15 <elliott> so that sounds OK to me
14:16:17 <chairdog> elliott: ok in my project, I'm compiling some source files with LANGUAGE Safe at the top and then my main program LANGUAGE Unsafe, and import those other modules with 'import safe' - compile fails if I try to use unsafeperformio in any of the Safe modules, as expected
14:16:24 <elliott> chairdog: ok
14:16:31 <elliott> I'll just try and get better versions of the packages rather than hack safe haskell
14:17:10 <dcoutts> djahandarie: also, we can most likely simplify so we only show "interesting" deps, and have a (more) link to full details
14:17:31 <dcoutts> djahandarie: so we don't need to try to show absolutely every precise detail in that minimal space
14:17:36 <djahandarie> dcoutts, that's definitely a good idea, but I wouldn't have the slightest idea how to do that.
14:17:36 <dylukes> hmmm
14:17:50 <djahandarie> If hackage has that sort of information it'd definitely make life easier
14:17:57 <dcoutts> djahandarie: aye, that's probably something that really requires understanding how cabal deps work
14:18:10 <dcoutts> djahandarie: we have that info, it's in the .cabal file
14:18:46 <dcoutts> djahandarie: I made a similar thing in "cabal list" to limit the number of versions we show
14:18:53 <dcoutts> but to try to show the most important ones
14:19:53 <dcoutts> djahandarie: so I think it'd be ok for the design to assume that we show the top N most important deps and make sure the design has a way to show the full detail elsewhere, e.g. with a more link
14:20:14 <dylukes> ChristianS: okay,
14:20:21 <djahandarie> Yeah, that makes sense.
14:20:21 <dcoutts> djahandarie: e.g. a full new page would give us space to do other things with deps, like integrating it with reverse deps
14:20:35 <dylukes> ChristianS: I've managed to shave off ~20% of the runtime...
14:21:03 <dcoutts> djahandarie: I don't know if you've seen the reverse deps info we have available, there's lots of info but what is less clear is how we can present it sanely
14:21:10 <dcoutts> so it's comprehensible
14:21:30 <djahandarie> I think I saw it briefly, IIRC it was just a huge list
14:21:47 <hpaste> “Dylan Lukes” pasted “Improved Version” at http://hpaste.org/63652
14:21:55 <dylukes> djahandarie: dcoutts:
14:22:05 <dylukes> do you two see any other optimization opportunities I'm missing here?...
14:22:25 <dylukes> the main timesink is building the IntMap
14:22:37 <dcoutts> dylukes: sorry, djahandarie and I were talking about something else
14:22:45 <dylukes> np
14:23:15 <djahandarie> dylukes, dump the core and take a look, you'll run in circles trying to optimize it any other way
14:23:59 <dylukes> What was the flag?
14:24:02 <dylukes> --d-dump-core?
14:24:05 <dylukes> something weird like that?
14:24:30 <djahandarie> It's -ddump-simpl, and there is also some other stuff you can use depending on what you want
14:24:33 <elliott> -ddump-simpl, but use ghc-core(1)
14:24:37 <elliott> since it omits all the rubbish
14:24:38 <elliott> cabal install ghc-core
14:24:42 <elliott> ghc-core -- -O2 foo.hs
14:25:12 <dylukes> Is building up a hashmap really the most efficient thing to do here :\...
14:25:24 <dylukes> I mean, the patricia trie means each insertion/check will be pretty good...
14:25:40 <djahandarie> I really have no idea what the hell you're doing.
14:25:41 <djahandarie> :P
14:25:49 <dylukes> I'm trying to optimize ChristianS's code.
14:26:02 <dylukes> http://hpaste.org/63636#a63650
14:26:08 <djahandarie> But if you've gone as far as adding strictness annotations you probably want to take a look at the core
14:26:13 <dylukes> My version:
14:26:13 <dylukes> http://hpaste.org/63652
14:26:34 <dylukes> The strictness annotations are just to make sure IO doesn't go fucking lazy on me.
14:26:56 <dylukes> And the stream fusion stuff is probably totally frivolous.
14:27:06 <djahandarie> You should also use the profiler to see what's going on, especially in terms of memory usage and GC time.
14:27:27 <dylukes> djahandarie: I can tell you from my... shoddy debugging...
14:27:31 <dylukes> most of the work is in readInt
14:27:32 <dylukes> and insert.
14:27:34 <chairdog> hmm I don't even need to put the Safe annotation on the modules I want to be safe - if I 'import safe' them, its inferring the safeness for me.
14:27:47 <dylukes> I can't get ghc-core anyhow...
14:27:52 <dylukes> pcre-light won't install >.>
14:28:14 <dylukes> should be able to fix that...
14:32:03 <dylukes> And now for the sledgehammer approach... >:D
14:33:12 <dylukes> @hoogle [a] -> [m a]
14:33:13 <lambdabot> Data.List inits :: [a] -> [[a]]
14:33:13 <lambdabot> Data.List permutations :: [a] -> [[a]]
14:33:13 <lambdabot> Data.List subsequences :: [a] -> [[a]]
14:34:08 <elliott> map return
14:34:50 <bgamari> dcoutts: I'm back
14:34:56 <bgamari> dcoutts: There's a new color scheme?
14:35:18 <elliott> a new mockup for a design thing that I might be interested in implementing a variant of
14:35:24 <bgamari> ahh
14:35:32 <bgamari> I'm still catching up on the discussion
14:35:43 <dcoutts> bgamari: http://hackage.haskell.org/trac/hackage/wiki/HackageDB/2.0
14:35:50 <Enigmagic> dylukes: where is the test file?
14:35:53 <bgamari> Ahh, it's up agai
14:36:00 <dylukes> Enigmagic: dunno, I generated one.
14:36:13 <dcoutts> bgamari: though I still cannot get auth working, so read only for the moment
14:36:28 <elliott> dcoutts: there is a spam link at the end of that page
14:37:05 <elliott> "Currently any registered user can upload new packages"
14:37:09 <elliott> that sounds like a supremely bad idea
14:37:29 <dcoutts> elliott: thanks, I'll have to go though all the updates in the period before we took it offline
14:37:38 <elliott> especially since there seems to be absolutely no anti-bot mechanism for registration
14:37:46 <dcoutts> elliott: yes, we agree, that's why the new design does it differently
14:37:57 <elliott> ah
14:38:05 <dcoutts> elliott: oh, no, there is an anti-bot mechanism, it's called Ross Patterson
14:38:13 <elliott> not in hackage2! it looks like anyone can register
14:38:16 <elliott> going by http://hackage2.uptoisomorphism.net:8080/
14:38:18 <dcoutts> elliott: you have to send him an email to get an account to register
14:38:25 <elliott> are we talking about the same thing?
14:38:29 <elliott> http://hackage2.uptoisomorphism.net:8080/users/register
14:38:30 <dcoutts> elliott: oh that, that's just for testing purposes
14:38:54 <elliott> i see
14:38:55 <dcoutts> elliott: the design has user groups, per-package groups etc
14:39:08 <elliott> so hackage2 is done apart from the part where it's not yet done? :P
14:39:16 <dcoutts> elliott: yes exactly :-)
14:39:31 <ChristianS> dylukes: hm, 20% up is still slower than python...
14:39:41 <dylukes> ChristianS: I'm trying something a bit more... unorthodox >.>
14:39:45 <bgamari> It would be nice if there were a way to log-out
14:39:55 <bgamari> this would make testing much easier
14:40:09 <dcoutts> bgamari: see how trac does it, can do the same I presume
14:40:26 <ChristianS> dylukes: does the fancy Stream really help a lot? my impression was that ghc does some stream fusioning behind the scenes already (if you use -O2)
14:40:31 <dylukes> No
14:40:34 <dylukes> I doubt it does anything here.
14:40:36 <dcoutts> bgamari: browsers are not very good at purging http auth info
14:40:46 <bgamari> dcoutts: I'd believe that
14:41:00 <dylukes> Okay... my trials with atomicModifyIORef and parallelization don't end well :3
14:41:03 <ChristianS> anyway, i'm off for the night (long past midnight here)
14:41:11 <ChristianS> but my nick will stay behind and listen...
14:41:15 <dylukes> I'm fork bombing myself.
14:41:16 <dylukes> awesome.
14:41:17 <elliott> dylukes: you can't speed up IO-bound tasks with parallelism...
14:41:22 <dylukes> elliott: No,
14:41:27 <dylukes> but I can speed up reading ints.
14:41:27 <dcoutts> bgamari: generally though we don't want to present different info depending on who the user is
14:41:39 <ChristianS> (it's not my code, btw, i was just the first who tried to optimize it)
14:41:39 <dylukes> the contention on the hashmap is way too high though >.>
14:41:50 * elliott finds the HTTP auth login a bit annoying, btw
14:42:44 <bgamari> Alright, I just sent a message regarding Hackage administration
14:43:09 <bgamari> Yes, the trac part no longer holds
14:44:04 <dylukes> "Link with -rtsopts to enable them."
14:44:10 <dylukes> this is infuriating.
14:44:33 <bgamari> dylukes: 7.4 enables some safe rtsopts I believe
14:44:37 <dylukes> w/e
14:44:40 <dylukes> it's not about safety
14:44:46 <dylukes> doesn't matter anyways
14:44:47 <dylukes> w/e
14:45:41 <elliott> dylukes: it is about safety
14:45:44 <elliott> that's why they were disabled
14:46:09 <otters> so join applies to ((->) r)
14:46:44 <elliott> join works with any monad
14:46:46 <otters> right
14:46:52 <otters> but I'm trying to understand how it applies to ->
14:47:13 <otters> from what I can see, if f takes two parameters, join f x is the same as f x x
14:47:42 <elliott> not "if f takes"
14:47:44 <elliott> it just is the same
14:47:58 <elliott> join m = m >>= id -- expand the definition of (>>=) for (->) and you'll see
14:48:02 <elliott> @src (->) (>>=)
14:48:03 <lambdabot> f >>= k = \ r -> k (f r) r
14:48:16 <elliott> join m = \r -> id (m r) r
14:48:18 <otters> well I've already done that and I really don't see
14:48:19 <elliott> join m = \r -> (m r) r
14:48:21 <elliott> join m = \r -> m r r
14:48:24 <otters> okay
14:48:26 <elliott> tada
14:48:30 <otters> okay
14:48:31 <qpu> how was IO done in haskell before monads were part of the language?
14:48:45 <elliott> qpu: badly (streams and continuations)
14:48:56 <otters> oh god
14:49:04 <elliott> qpu: stream-based IO was "fun"
14:49:09 <elliott> qpu: main :: [Response] -> [Request]
14:49:13 <elliott> e.g.
14:49:34 <elliott> main xs = GetLine : case xs of { GotLine s : xs' -> [PutStrLn s] }
14:49:38 <elliott> (that's the basic idea)
14:49:41 <elliott> (I don't know the concrete details)
14:49:47 <qpu> are there any documented stories about it? i imagine someone (wadler?) might have chronicled it to motivate the addition of monads?
14:49:54 <cmccann> otters, you need to trust your intuition more
14:50:05 <otters> yeah
14:50:06 <elliott> qpu: perhaps the history of haskell paper?
14:50:13 <cmccann> I think I remember at least three times where you figured something out correctly and then decided to keep looking for an answer anyway :P
14:50:45 <otters> cmccann: I don't want to be wrong :<
14:50:46 <Jafet> qpu: the hair shirt paper may have details
14:50:55 <otters> it's very hard to unlearn things when you go about them the wrong way for a long time
14:51:09 <otters> but it's very easy to correct yourself before you know anything
14:51:09 <cmccann> otters, very true
14:51:27 <qpu> Jafet, elliott thanks for the pointers!
14:51:33 <elliott> qpu: no
14:51:34 <elliott> *np
14:51:39 <elliott> nice typo...
14:51:40 <otters> does haskell have pointers?
14:51:45 <otters> hm
14:51:51 <elliott> otters: in the FFI, yes
14:51:57 <otters> 0xdeadbeef
14:51:59 <lispy> preflex: seen dcoutts
14:51:59 <preflex>  dcoutts was last seen on #ghc 1 minute and 4 seconds ago, saying: Igloo: thanks
14:52:09 <cmccann> otters, I'm just remarking that you seem to be figuring things out better than you give yourself credit for perhaps
14:52:15 <otters> cmccann: well thanks
14:52:17 <otters> sort of
14:52:22 <cmccann> heh
14:52:44 <luite> is there some accepted way to have a global  a :: Int, b :: Int, a = fn, b = fn, such that a /= b?
14:52:51 <otters> it took me awhile to understand >>= for (->)
14:53:08 <cmccann> otters, yeah, that one takes some getting used to
14:53:14 <otters> cause anything complicated written in do-notation just collapses to one enormous function call
14:53:16 <acowley> dylukes: has anyone thrown this set-building performance test onto SO?
14:53:28 <dylukes> Dunno, I'm not concerned anymore.
14:53:58 <cmccann> otters, and you know that's the Reader monad, right?
14:54:03 <otters> yes
14:54:07 <elliott> luite: huh?
14:54:20 <elliott> luite: if a = fn and b = fn, a = b
14:54:26 <acowley> dylukes: I'd just like to see if somebody can track down what the issue is, I haven't found it.
14:54:30 <luite> elliott: I mean to have global read-only unique data
14:54:31 <otters> where do { foo <- fn } in (->) is the same as do { foo <- asks fn }
14:54:35 <otters> right
14:54:39 <elliott> luite: a = 1, b = 2
14:54:44 <dylukes> acowley: It's not really an "issue"...
14:54:46 <luite> elliott: fn can obviously not be a real function
14:54:48 <dylukes> as much as readInt is somewhat slow :P.
14:54:50 <elliott> luite: failing that
14:54:52 <luite> elliott: yeah, but that's not exactly extensible
14:54:58 <dylukes> and a million insertions isn't the fastest thing in the world.
14:55:01 <elliott> {-# NOINLINE a #-}
14:55:01 <elliott> a = unsafePerformIO newUnique
14:55:07 <otters> and ask is just id
14:55:16 <cmccann> otters, indeed
14:55:18 <otters> hmm
14:55:21 <acowley> dylukes: well, I rolled my own readInt and lines, and I'm seeing time spent in lines, too
14:55:26 <otters> why do people use the Reader monad when they can just use (->)?
14:55:28 <otters> if they're identical?
14:55:34 <cmccann> otters, clarity
14:55:36 <dylukes> acowley: Lines is significantly faster, anyhow :\.
14:55:41 <otters> hmm
14:55:45 <otters> underwhelming
14:55:47 <dylukes> otters: Because Reader is clearer and lets you "hide" a parameter.
14:55:50 <elliott> otters: also Reader comes in a transformer form
14:55:53 <cmccann> so that if you mix things up you get a better error message
14:55:55 <dylukes> It also lets you do some fun stuff with local.
14:55:56 <cmccann> also, yes, ReaderT
14:55:58 <otters> oh, right, transforming
14:56:00 <otters> and local
14:56:01 <otters> okay
14:56:05 <elliott> local is definable for (->)
14:56:05 <otters> I knew there was a catch
14:56:06 <elliott> :t local
14:56:07 <lambdabot> forall r (m :: * -> *) a. (MonadReader r m) => (r -> r) -> m a -> m a
14:56:11 <luite> elliott: right, but is it possible to do reliably without NOINLINE for the actual things that need to be unique?
14:56:15 <cmccann> plain Reader probably isn't used that often anyway
14:56:15 <elliott> locale :: (r -> r) -> (r -> a) -> (r -> a)
14:56:24 <elliott> :t flip (.) :: (r -> r) -> (r -> a) -> (r -> a)
14:56:24 <lambdabot> forall r a. (r -> r) -> (r -> a) -> r -> a
14:56:52 <elliott> luite: TH
14:56:57 <elliott> a = $(fn)
14:57:00 <otters> next topic for me is going to be monad transformers :>
14:57:08 <acowley> dylukes: not by my measurements, but it can be tricky to get cost centers to show up correctly, so I may be doing something wrong there.
14:57:34 <luite> elliott: right, that was so far the only thing I could think of, but TH runs in a per-file context, doesn't it?
14:57:42 <cmccann> otters, don't get too hung up on them, they don't make as much inherent sense as most other stuff in Haskell
14:57:49 <dylukes> acowley: I think in general, even IntMap isn't set up for bulk insertions.
14:58:28 <dylukes> It's a patricia trie, so it's about as fast as it's going to get by way of pure structures...
14:58:57 <dylukes> The fastest method would be to wrap an unsafe intmap。。。
14:59:35 <elliott> luite: dunno
14:59:40 <elliott> luite: use a temporary file :P
15:00:01 <elliott> luite: is $(fn "a") OK?
15:00:07 <elliott> you could just automate the NOINLINE/newUnique
15:00:07 <otters> okay so I know that you can't use plain Reader with IO but I don't understand why
15:00:38 <elliott> @unmtl ReaderT m a
15:00:38 <lambdabot> Plugin `unmtl' failed with: `ReaderT m a' is not applied to enough arguments, giving `/\A. m -> a A'
15:00:41 <elliott> argh
15:00:42 <elliott> @unmtl ReaderT r m a
15:00:42 <lambdabot> r -> m a
15:00:54 <elliott> do you know about monad transformers yet?
15:01:01 <otters> not /exactly/
15:01:08 <elliott> ok, probably wait then
15:01:09 <otters> bet there's a wiki article
15:01:11 <elliott> but basically
15:01:16 <elliott> the monad instance for (r -> IO a) isn't what you want
15:01:20 <elliott> because it doesn't "bind" the IO part at all
15:01:30 <otters> okay
15:03:05 <luite> elliott: yeah, it should be doable at least to generate something with a very small chance of collisions
15:03:50 <elliott> luite: no, I meant
15:03:54 <elliott> $(fn "a") would literally just splice in
15:03:57 <elliott> {-# NOINLINE a #-}
15:03:58 <elliott> a = newUnique
15:04:04 <elliott> which is guaranteed to be unique no matter how many files it's in
15:04:06 <elliott> erm
15:04:07 <elliott> *unsafePerformIO
15:04:42 <luite> elliott: oh right, well in practice the types are slightly more complicated
15:07:44 <luite> the idea is to make globally unique Keys, Key m a, and have various caches that can contain a key. for example lookup :: Cache m -> Key m a -> m a, a Key m a contains an action (m a) to create some a, but if it already exists in the cache, the cached one is used
15:08:31 <luite> the cache itself has to use some ugly unsafeCoerce tricks, but the Keys are tagged, so uses can't extract the wrong types
15:10:30 <elliott> luite: take a look at the vault package, you maybe able to avoid your unsafeCoerce tricks
15:10:35 <elliott> since it implements the essence of them
15:10:51 <elliott> (and if it isn't flexible enough for your usecase I'd like to make it be)
15:11:15 <elliott> type YourCache m = Vault; type YourKey m a = Vault.Key (m a)
15:11:21 <luite> elliott: it uses unsafeCoerce trickes :)
15:11:26 <elliott> luite: yes, it does
15:11:38 <elliott> luite: but it means there's only one person using unsafeCoerce tricks rather than two
15:11:48 <elliott> luite: and you can use unsafePerformIO newKey and it'll work so long as it's NOINLINE
15:12:19 <elliott> also it would likely be faster than Unique (since it uses atomicallyModifyIORef rather than STM and an IntMap)
15:12:42 * cmccann ponders adding a visual indicator on hackage of "how much this package uses various unsafe things"
15:12:50 <cmccann> or would that annoy people :P
15:12:53 <luite> yeah I was actually already looking at vault
15:13:11 <elliott> cmccann: well vault's API is implementable with just a single, benign unsafePerformIO
15:13:14 <elliott> to stop the type of lookup ending up in IO
15:13:15 <luite> but they problem is the same anyway, generating unique keys :)
15:13:21 <elliott> cmccann: it's just done with unsafeCoerce for efficiency
15:13:25 <elliott> luite: right, well
15:13:37 <elliott> have $(fn "a") splice in {-# NOINLINE a #-} a = unsafePerformIO newKey
15:13:42 <elliott> that should be guaranteed to work
15:13:54 <elliott> (apart from that unsafePerformIO duplication bug in 7.0...)
15:14:07 <luite> ugh...
15:14:10 <cmccann> well yeah it's not like it would be a "oh god don't use this!!" thing
15:14:12 <elliott> luite: if you really want to generate your own Ints
15:14:16 <elliott> luite: then you can unsafeCoerce the Int to a Key
15:14:41 <elliott> luite: however that won't "invalidate" it i.e. it better be a big number or it'll be generated with sequential newKeys elsewhere
15:14:45 <cmccann> just that it's occasionally nice to know if something is pure well-behaved Haskell vs. using trickery such as unsafePerformIO or even the FFI really
15:15:31 <luite> elliott: meh I don't believe in birthday paradoxes anyway ;)
15:16:05 <Sgeo> I am 100% certain that there are groups of people in here who share a birthday.
15:16:23 <lispy> Sgeo: meaning they just don't want to be alone?
15:16:39 * lispy makes bad jokes about the birthday problem
15:16:40 <cmccann> I'm not using my birthday, someone else can have it
15:17:13 * cmccann donates is birthday to poor third-world children who can't afford one
15:18:18 <elliott> cmccann: So do the 1% just sit on their amassed piles of birthdays, having multiple per day?
15:18:31 <cmccann> yes
15:18:46 <cmccann> and they have a whole birthday for each one
15:18:50 <elliott> I hear Bill Gates could have one birthday per second and not run out for a thousand years.
15:19:21 <lispy> cmccann: did you see the thread just now on -Cafe about hackage2 maintainer?
15:19:25 <elliott> at which point he would be 3.1556926 * 10^10 years old
15:19:35 <lispy> cmccann: we may have one now
15:19:39 <cmccann> lispy, no, I just got back from dinner
15:19:47 <elliott> lispy: that's bgamari from above
15:19:51 <elliott> we already know about it :P
15:20:07 <lispy> Scrollback?  How does that wrok?
15:20:10 <lispy> work*
15:20:39 <cmccann> also the trac is live in read-only mode
15:20:42 <elliott> @tell bgamari btw, hackage 2 is *not* quite ready for real-world use it seems: currently any user can register an account (with no anti-bot protection) and upload a package, which is Bad; the quickest fix would be the current manual-approval system
15:20:42 <lambdabot> Consider it noted.
15:21:01 <elliott> @tell bgamari the Trac is also back (read-only) thanks to dcoutts
15:21:01 <lambdabot> Consider it noted.
15:21:46 <cmccann> yeah I'm not sure it's quite ready to go live yet honestly
15:21:58 <lispy> elliott: sounds like that should be a release critical bug in an issue tracker
15:22:11 <dcoutts> cmccann: I've got the accounts back
15:22:16 <dcoutts> well, some accounts
15:22:21 <cmccann> woot
15:22:23 <dcoutts> and you can now register
15:22:55 <elliott> lispy: issue tracker? ha ha ha
15:22:56 <cmccann> anyway, in anticipation of stuff being figured out for official stuff I'm going to hack on the code and keep my public instance running
15:22:59 <elliott> actually
15:23:06 <elliott> i'll enter it in cmccann's github
15:23:10 <elliott> since it *is* pretty serious
15:24:04 <lispy> elliott: thanks!
15:24:26 <luite> this means you're volunteering to keep it running with 99,999% uptime for the next ten years, right ;p
15:24:48 <bgamari> elliott: Fair enough
15:24:48 <lambdabot> bgamari: You have 2 new messages. '/msg lambdabot @messages' to read them.
15:24:49 <cmccann> anyhow, for what it's worth I'm not averse to having actual responsibility for any of this stuff
15:25:04 <cmccann> I'm just not necessarily seeking it out :P
15:25:24 <bgamari> elliott: Recaptcha is pretty simple to integrate I believe
15:25:31 <bgamari> would this be an acceptable solution?
15:25:35 <elliott> recaptcha is also broken by 90% of bots, I think
15:25:39 <bgamari> bah
15:25:43 <cmccann> what
15:25:43 <elliott> also, it's not enough, because human malicious users are a problem too
15:25:53 <bgamari> alright, fair enough
15:25:57 <elliott> cmccann: well not 90%, but everything I've read says that recaptcha isn't much of an obstacle these days
15:26:03 <elliott> e.g. MediaWiki recommend against using it because it's ineffective
15:26:08 <bgamari> so be it
15:26:12 <cmccann> isn't recaptcha based on figuring out stuff that research-level OCR can't decipher? :T
15:26:27 <elliott> cmccann: spam-money-level > research-level
15:26:36 <bgamari> heh, sad but true
15:26:48 <elliott> cmccann: also, paying poor people to fill out captchas > any amount of distortion
15:26:57 <cmccann> yeah I'm guessing it's the latter
15:27:12 <dcoutts> bgamari, cmccann, elliott: so the auth system in the new design copes ok with package uploaders, what it does not cover well is casual users who might want to post reviews, vote etc, but not upload packages
15:27:23 <dcoutts> since you probably want self-registration for those users
15:27:32 <dcoutts> but for uploaders it's sensible to have a human in the loop
15:27:36 <bgamari> Certainly
15:27:45 <dcoutts> like we do in the current system
15:28:01 <dcoutts> so there's an admin user group who can edit other groups
15:28:04 <dcoutts> ie grant permissions
15:28:04 <cmccann> I think self-registration is fine anyway as long as there's bot obstacles and a quarantine for stuff from unknown users
15:28:05 <bgamari> A captcha might be sufficient for the non-upload case
15:28:26 <dcoutts> e.g. the admin user can disable accounts, edit package groups etc
15:28:40 <elliott> dcoutts: right
15:28:44 <bgamari> yep
15:28:49 <dcoutts> so then there's a per-package group, that's the users who can upload new versions of that package
15:28:58 <dcoutts> there is also a user group called "trustees"
15:29:30 <dcoutts> these people can do maintenance across multiple packages
15:29:37 <elliott> cmccann: not for uploaders
15:29:46 <bgamari> dcoutts: Across all packages, yet?
15:29:48 <elliott> cmccann: I can upload a package to Hackage right now that, upon "cabal install", will delete all your ~
15:29:48 <dcoutts> trustees cannot upload themselves, but can do things like edit package meta-data
15:29:48 <bgamari> yes*
15:29:54 <bgamari> ahh
15:30:04 <elliott> cmccann: having to email someone to get an account provides social pressure against that
15:30:19 <cmccann> eh, I'd rather quarantine and then approve
15:30:36 <elliott> cmccann: oh, I see
15:30:39 <elliott> yes, that's what I meant
15:30:42 <dcoutts> elliott, cmccann: right, plus in the new system since there's a per-package uploader group then unknown users cannot subvert well known names (ie packages)
15:30:49 <elliott> but the simplest solution would be -- actually why repeat myself, I'm writing this into the bug report anyway
15:30:50 <cmccann> just so long as you can't immediately upload and then have it available via cabal install like anything else
15:30:51 <elliott> dcoutts: right
15:30:58 <dcoutts> so in the new system malicious people can still upload *new* malicious packages
15:31:02 <dcoutts> but cannot subvert e.g. base
15:31:53 <hpaste> vblm pasted “Feedback for Text Compare” at http://hpaste.org/63655
15:32:03 <elliott> dcoutts: does hackage2 have support for "per-user" versions of packages?
15:32:04 * cmccann has always been kind of quietly horrified by the "security" of hackage to be honest
15:32:07 <elliott> that's one thing I see requested a lot
15:32:37 <elliott> cmccann: it's one of those things that works as long as you don't look at it
15:32:40 <cmccann> yeah
15:32:53 <dcoutts> elliott: what does that mean exactly?
15:33:13 <dcoutts> cmccann: yes, me too, that's why we designed something more sensible
15:33:25 <bgamari> Is it possible to grant write access on the Trac for trusted users for the time being?
15:33:30 <vblm> Could someone please provide feedback / critique on http://hpaste.org/63655? It's my first substantial program I tried to write.
15:33:34 <cmccann> it's just this baffling mixture of annoying obstacles--I mean really, emailing someone to get an account? the weird thing about real names? this is why I don't have a hackage account still--yet absolutely no restriction on things like e.g. uploading new versions of major packages
15:33:59 <bgamari> it would be nice to have these things recorded somewhere
15:34:08 <elliott> ok, https://github.com/isomorphism/hackage2/issues/2
15:34:11 <elliott> dcoutts: what does what mean?
15:34:28 <dcoutts> bgamari: authenticated users can edit the wiki already
15:34:40 <elliott> cmccann: hackage is basically an insider's club
15:34:43 <bgamari> dcoutts: Ahh, so they can. Thanks
15:35:17 <elliott> cmccann: the high barrier to entry prevents abuse but it's annoying
15:35:35 <cmccann> elliott, yeah that's how it manages but that doesn't scale well
15:35:47 <dcoutts> elliott, cmccann: sure it's not a system you would design now. It was the simplest thing Ross could get working. He's not a web app designer :-)
15:35:59 <elliott> dcoutts: oh sure, I'm not blaming anyone
15:35:59 <cmccann> and is honestly just kind of embarrassing from a broader programming community perspective :T
15:36:09 <dcoutts> cmccann: we know
15:36:10 <cmccann> dcoutts, yeah
15:36:13 <elliott> cmccann: it's not embarrassing because nobody else has anything much better
15:36:16 <elliott> you know RubyGems?
15:36:18 <elliott> people install those as root
15:36:23 <elliott> forget wiping ~
15:36:25 <cmccann> heh
15:36:31 <elliott> if I could upload a new Rails package I could wipe out thousands of machines
15:36:33 <cmccann> well, I have higher standards for Haskell than other languages :P
15:37:02 <cmccann> dcoutts, and yeah I know, I don't blame anyone either
15:37:09 <dcoutts> elliott: you mentioned "per-user" versions
15:37:36 <cmccann> it's just long overdue for some changes, hence the current activity :P
15:37:42 <bgamari> Looks like I've got to run again
15:37:53 <dcoutts> elliott: and I was wondering what is meant by that
15:37:57 <elliott> dcoutts: like github
15:38:10 <bgamari> Cheerio!
15:38:39 <elliott> dcoutts: it'd probably be a major rearchitecturing yet again I guess
15:38:54 <dcoutts> elliott: well it's ok if the new package has a new name
15:39:03 <elliott> huh?
15:39:04 <dcoutts> and that can either be hosted on hackage or elsewhere
15:39:15 <dcoutts> e.g. cabal-install can install from tarballs via http
15:39:18 <elliott> I don't think you understand
15:39:30 <elliott> I meant that, it would be a lot nicer if packages were structured as user/pkg, github-style
15:39:47 <dcoutts> elliott: oh I thought you meat people want to fork a package, make some change and host their version
15:39:51 <elliott> because it would solve a lot of problems like maintainers who go AWOL
15:40:07 <dcoutts> elliott: ok, so again it's a namespace problem
15:40:10 <elliott> dcoutts: well it doesn't really need support for that, it's just that it helps keep the namespace unclogged and the like
15:40:16 <dcoutts> what does it mean when I "cabal install foo"
15:40:20 <dcoutts> what does foo resolve to
15:40:47 <elliott> well, it'd have to pick the most popular one, or such
15:40:55 <elliott> isn't that something hackage2 was meant to have anyway?
15:41:00 <elliott> I agree it's not perfect though
15:41:14 <dcoutts> elliott: no, I've never seen this mentioned before
15:41:20 <elliott> no, I meant
15:41:24 <elliott> that = pick the most popular one
15:41:30 <mike-burns> Few people install Ruby gems as root anymore, by the way. Just saw that in the backlog.
15:41:32 <elliott> although I've definitely seen other people wish for user-structured packages
15:41:38 <elliott> mike-burns: oh, did they fix that?
15:41:44 <elliott> ok they're marginally more respectable than us then :P
15:41:57 <dcoutts> elliott: 'foo' resolves to the latest version (except that maintainers can mark certain versions as broken or beta)
15:42:10 <mike-burns> elliott: Package management in Ruby is actually really nice now. Best I've had. No idea how they pulled that one off.
15:42:18 <dcoutts> elliott: plausibly one could have some kind of naming conversion for personal non-global packages
15:42:33 <dcoutts> elliott: to avoid polluting the namespace but still give handy hosting
15:42:38 <dcoutts> e.g. user:foo
15:42:49 <luite> mike-burns: hm, but I've heard horror stories about actually using and upgrading packages :)
15:42:53 <elliott> tbh I don't think it would be a major problem if you just required the username
15:42:55 <dcoutts> cabal install elliott:blah  :-)
15:43:05 <elliott> IIRC Go packages are done like that
15:43:14 <dcoutts> elliott: it's an interesting idea, not seen it suggested before
15:43:27 <dcoutts> elliott: though I think we still want a global namespace
15:43:32 <mike-burns> Oh man, Ruby packages were usernamed for a short period. It was annoying, and we stopped.
15:43:34 <elliott> yeah
15:43:35 <elliott> hmm
15:43:38 <dcoutts> e.g. I don't think distros will want user:blah
15:43:58 <cmccann> a global namespace for approved packages would be good
15:43:59 <dcoutts> elliott: or just provide install by URL
15:44:05 <elliott> that's what I was about to say
15:44:21 <dcoutts> elliott: we can already do: cabal install http://example.com/~elliott/foo-1.0.tar.gz
15:44:21 <mike-burns> Git repo URL.
15:44:22 <cmccann> that would also give another place to filter out broken stuff, nonsense, and anything suspicious
15:44:32 <waern> we already have '-' for namespace don't we? I mean it's similar to '.' in Haskell modules which is just a convention as well
15:44:37 <elliott> dcoutts: mind you, "user" could be things like "platform" (with all the "base" packages), "yesod" and the like
15:44:48 * cmccann shrugs
15:44:54 <cmccann> this seems to be a bit beyond the immediate scope though
15:44:58 <dcoutts> elliott: well, like waern says, we do use '-' that way somewhat
15:45:07 <mike-burns> cmccann: I'm with you re filtering.
15:45:15 * elliott does not really know what he wants, other than "not what we have"
15:45:48 <cmccann> mike-burns, hm? you replying to deep backscroll or did I miss some context
15:45:50 <elliott> I'm really tempted to work on a simple voting system for packages just to solve the single massive problem that is http://hackage.haskell.org/packages/archive/pkg-list.html
15:45:56 <cmccann> oh, wait
15:45:57 <elliott> btw, I don't think an account should be required for voting
15:46:04 <mike-burns> cmccann: Like, a minute ago.
15:46:08 <cmccann> yeah
15:46:10 <elliott> it'll just kill the voting system by creating a huge barrier to entry
15:46:35 <cmccann> I'd like as few barriers to entry as possible without creating major security issues to be honest
15:46:43 <bgamari_> elliott: I agree; it's easy enough to invalidate votes of users who abuse the system
15:46:57 <cmccann> particularly in contrast to the current system, with lots of barriers and no security :P
15:47:02 <elliott> oh, and the package list should just not show anything whose latest version doesn't build (hopefully with some way to maintain two "OK versions" at once)
15:47:03 <mike-burns> Hah.
15:47:09 <rostayob> I disagree. Registering is a very low barrier and it filters out a lot of bad stuff
15:47:14 <elliott> (e.g. a package doesn't show if it doesn't build on 7.0 _and_ doesn't build on 7.4)
15:47:15 <hpaste> jtlien pasted “popCount” at http://hpaste.org/63657
15:47:20 <dcoutts> elliott: we can do that once we have build info
15:47:26 <elliott> dcoutts: oh, is that not in yet?
15:47:42 <dcoutts> elliott: partly, but no builder client implementation yet
15:47:44 <elliott> clearly edwardk has some definition of "done" different to the rest of us :P
15:48:10 <elliott> we should probably just add absolutely everything hackage2 doesn't have that hackage has into github issues
15:48:11 <dcoutts> elliott: and we don't have any system to translate sets of build results into useful info like "builds on 7.0"
15:48:19 <elliott> or we'll forget it all until the next time someone wonders why hackage2 isn't live yet
15:48:41 <cmccann> feel free to spam the issues on my repo :P
15:48:42 <dcoutts> elliott: can I suggest adding it to the hackage trac as tickets or to the wiki
15:48:53 <bgamari_> I've been going through the wiki
15:48:55 <cmccann> or use the trac if it's working well enough again, yeah
15:49:02 <dcoutts> otherwise we'll just end up spreading the info in too many places
15:49:43 <elliott> dcoutts: I guess so, but I really hate Trac :(
15:49:48 <elliott> also it's read-only right now so I have an excuse :P
15:49:58 <dcoutts> elliott: I've fixed it
15:50:00 <elliott> oh, ok
15:50:13 <dcoutts> I agree it's not perfect, but it's better to use one place
15:50:21 <mike-burns> If we use the Trac we should remove the Issues. Like dcoutts just said.
15:50:29 <mike-burns> You can disable Issues in GH.
15:50:48 <dcoutts> bgamari_, cmccann: so far we've been mostly using the wiki for tracking things before the switchover, but at some point we'll want to use tickets properly
15:50:50 <elliott> I'd prefer to point the Trac issues at GitHub personally, but I'm biased :P
15:51:10 <mike-burns> If we use GH Issues then we don't have to maintain Trac.
15:51:15 <mike-burns> But maybe someone enjoys that.
15:51:39 <dcoutts> bgamari_, cmccann: since during development there were too many nebulous issues to track as tickets, but we'll get to the stage where it makes sense to start using issues for bug + feature tracking
15:51:39 <elliott> if anyone is doing development on GH then there'll be duplication in the pull requests anyway
15:51:45 <cmccann> github is all around nicer as a central point in my opinion but shrug
15:51:46 <dcoutts> and that time might be now
15:51:56 * cmccann nods
15:51:58 <elliott> (github has a wiki too :P)
15:52:11 * elliott has refined his hatred of Trac over many years
15:53:04 <Veinor> i like github because it's shiny
15:53:34 * dcoutts pushes a couple hackage-server patches
15:53:36 <mike-burns> I like GitHub because it's hosted.
15:54:00 <dcoutts> I have an irrational fear of github
15:54:21 <mike-burns> I hated it at first.
15:54:25 <dcoutts> probably because I have an irrational fear of git
15:54:30 * elliott doesn't like how centralised GitHub is
15:54:39 <elliott> but the ubiquity and convenience pretty much trumps everything for the present
15:54:57 <luite> you can install your own github box :)
15:54:58 <irene-knapp> github has been down for several minutes the past couple weeks :)
15:55:01 <irene-knapp> it was very annoying :)
15:55:04 <dcoutts> elliott: right, that's always niggled. it seems ok to centralise for distributions since you can distribute from multiple places
15:55:14 <elliott> luite: yeah, I'm sure haskell.org has that kind of money :P
15:55:18 <dcoutts> elliott: but hosting upstream sources has to be one place really
15:55:21 <elliott> dcoutts: well, the repo part is still... DVCS
15:55:29 <luite> elliott: dunno, they might want to sponsor a license, dunno
15:55:32 <elliott> dcoutts: wiki + issues are what you risk losing if you think github is going to die
15:55:42 <elliott> which is annoying, but wouldn't be fatal to lose, and are easy to back up
15:55:48 <dcoutts> elliott: sure but what everyone seems to love is the fact that it tracks who has forked and things like that, all the cross references
15:55:58 <elliott> luite: you need to specify a "team size"
15:56:03 <elliott> what's haskell.org's team size?
15:56:15 <mike-burns> Open Source gets special love from GitHub.
15:56:16 <dcoutts> elliott: which they can do easily because it's centralised, but it clearly doesn't scale to have all software in the world hosted there
15:56:34 <elliott> mike-burns: that's what literally every company says :P
15:56:45 <elliott> well, depending on your definition of "special love" I guess
15:56:48 <dcoutts> elliott: oh I don't fear it's going to die, I fear it's going to win :-)
15:56:58 <elliott> dcoutts: right
15:57:09 <luite> I heard that bitkeeper has special love for open source ;)
15:57:09 <elliott> don't get me wrong, it makes me deeply uncomfortable too that everyone just accepts github's dominance
15:57:34 <elliott> but for the sake of getting hackage2 ready for prime-time, it seems a clear convenience win, since a darcs repo on code.haskell.org is kind of a dead end as far as mass collaboration goes in 2012 I think
15:58:20 <dcoutts> elliott: mm, we can have multiple comitters and people can publish their branches
15:58:38 <dcoutts> we can list public branches on the wiki
15:59:49 <SubtleArray> Good peoples of the IRC... Small question. I have an if statement "if null return then "null" else show return" return is a variable that holds a "string". The problem, this statement only works when I add show before the variable which generates a very sloppy output "\"string\"". Is there a way to make this work without show?
16:00:50 <irene-knapp> I should point out that although "return" is not a reserved word, it has a standard meaning which this is not
16:01:10 <SubtleArray> Woot. Nevermind. I just figured it out.
16:01:12 <mike-burns> SubtleArray: Can you hpaste the whole function?
16:01:14 * cmccann mostly thinks github is nice for making it easy to just get things done rather than muck about with infrastructure
16:01:14 <mike-burns> OK.
16:01:26 <SubtleArray> I had to type it as return !! 0.
16:01:30 <SubtleArray> It was generating a list.
16:02:08 <dcoutts> cmccann: so my typical policy would be to direct grant upstream push access after a few good patches. There's currently 7 people with push access.
16:02:26 <SubtleArray> After 2 days I finally got this 1 function to work. Lol. So glad I can move on now.
16:02:46 * elliott thinks it would be reasonable for cmccann to push stuff from github upstream to darcs every now and then
16:02:57 <mike-burns> We're keeping the darcs?
16:03:02 <elliott> apparently :P
16:03:14 <dcoutts> elliott: yeah, that works too
16:03:25 <dylukes> It seems like no one really uses darcs heavily...
16:03:32 <dcoutts> I have other projects where people prefer to use git for their working branches
16:03:33 <elliott> that way people don't have to go through any red tape and can just contribute but there's still a darcs repo at the top
16:03:38 <dcoutts> but push to darcs upstream
16:03:38 <dylukes> tbh I get the feeling a lot of people use darcs if only to say "I use darcs"
16:03:44 <dylukes> not because it's any easier or more convenient :\
16:03:46 <elliott> dylukes: that's silly
16:03:52 <elliott> "darcs record" is way better than "git commit -p"
16:03:52 <elliott> by far
16:03:55 <dylukes> Just the feeling I get.
16:03:55 <rostayob> dylukes: that's not true
16:03:56 <dcoutts> dylukes: that would be silly
16:04:04 <rostayob> dylukes YOU'RE WRONG
16:04:05 <elliott> darcs' UI is miles and miles ahead of git, as is its branching support
16:04:09 <elliott> I don't use darcs though
16:04:17 <rostayob> elliott: :)
16:04:18 <elliott> because nobody else uses darcs and it doesn't really scale all that well unfortunately
16:04:21 <irene-knapp> what elliott just said, except that I /do/ use darcs
16:04:23 <elliott> but it's easy to see why someone would
16:04:49 <rostayob> there is also "camp", which is like darcs, but less used
16:04:54 <elliott> dylukes: anyway, I get the feeling a lot of people use Haskell if only to say "I use Haskell"
16:04:59 <dylukes> :P
16:05:01 <dschoepe> I find magit nicer than darcs' UI though.
16:05:04 <rostayob> dylukes: http://www.youtube.com/watch?v=iOGmwA5yBn0
16:05:05 <mike-burns> lol @ "like darcs but less used"
16:05:13 <dylukes> rostayob: I've seen it.
16:05:26 <rostayob> dylukes: ok :)
16:05:30 <rostayob> I use git as well btw.
16:05:32 <dcoutts> elliott: btw when you say "red tape" do you mean me saying "typical policy would be to grant upstream push access after a few good patches" ?
16:05:36 <rostayob> it's good enough
16:05:53 <elliott> dcoutts: well, realise that for many potential contributors, "installing darcs and figuring out how it works" is a significant amount of red tape
16:05:54 <dcoutts> elliott: prior to that sending darcs patches or pull requests is open to everyone
16:06:02 <dcoutts> elliott: ah I see
16:06:17 <elliott> and many people find github's pull requests are more convenient than submitting patches by email
16:06:29 <cmccann> my interest in dealing with darcs doesn't really extend very far
16:06:39 <luite> github makes it so easy to comment on specific lines, patches et
16:06:39 <luite> c
16:07:15 <cmccann> I'll figure out enough to generate patches for dcoutts but otherwise I don't really need to learn how another version control system works
16:07:27 <luite> "could you fix this?", and then easily add another patch to the branch, comment on that again
16:07:39 <mike-burns> I'm glad the haskell-cafe thread finally converged with IRC.
16:08:04 <cmccann> mike-burns, hm?
16:08:33 <elliott> the number one annoying thing about git pull requests is that they force a merge commit
16:08:39 <elliott> even when everything applies completely cleanly
16:08:40 <elliott> *github
16:08:56 <cmccann> which is pretty minor all things considered
16:09:01 <mike-burns> cmccann: Lots of people griping about Hackage 2 and someone stepping up, and then you just emailed to say that you have it running publicly and on GH.
16:09:10 <cmccann> yeah
16:09:41 <elliott> that comment in the reddit thread which was all "blah blah second system syndrome" was amusing
16:09:50 <cmccann> well, I did both of those to help get things moving along so yeah
16:10:07 <elliott> since their proposed development methodology was exactly what actually happened :P
16:10:08 <cmccann> I wasn't really planning to make any kind of announcement because I haven't accomplished much of anything but oh well
16:10:26 <Sgeo> Why am I looking at Factor?
16:10:31 <Sgeo> It feels so ... imperative.
16:11:02 <MostAwesomeDude> It's concatenative.
16:11:05 <fabregastic> @pl f <&&> g = (&&) <$> f <*> g
16:11:06 <lambdabot> (line 1, column 10):
16:11:06 <lambdabot> unexpected "="
16:11:06 <lambdabot> expecting variable, "(", "`", "!!", ".", operator or end of input
16:11:09 <mike-burns> Getting it on GitHub is a big thing.
16:11:26 <MostAwesomeDude> I like Factor, but it's really difficult for me to think in it.
16:11:33 <MostAwesomeDude> It's so terse, though~
16:11:51 <fabregastic> @pl \f g -> (&&) <$> f <*> g
16:11:51 <lambdabot> (((&&) <$>) .) . (<*>)
16:12:04 <fabregastic> hideous
16:12:10 <fabregastic> \quit
16:12:15 <Sgeo> Factor doesn't use .
16:12:23 <Sgeo> Well, it does, but not for composition.
16:12:34 <elliott> fabregastic: liftA2 (&&)
16:12:53 <fabregastic> elliott Ah much better
16:12:59 <fabregastic> thanks
16:13:55 <dibblego> @type \p q -> p >>= \p' -> if p' then q else return False
16:13:56 <lambdabot> forall (m :: * -> *). (Monad m) => m Bool -> m Bool -> m Bool
16:14:36 <dibblego> can I ask ghc from which installed package a module is resolved from?
16:14:54 <dibblego> :whereis Control.Monad.Identity
16:14:57 <dibblego> for example
16:16:13 <fabregastic> conal, is there good support for lifting binary operators?  e.g. some kind of syntax for gadgets like <&&> , <||>?
16:17:00 <elliott> fabregastic: in what context?
16:17:07 <Saizan> dibblego: ghc-pkg find-module
16:17:14 <elliott> for applicatives she (the preprocessor) lets you say (| f && g |)
16:17:14 <fabregastic> i mean, i can't exactly write
16:17:25 <elliott> for liftA2 (&&) f g
16:17:38 <fabregastic> isAscii `liftA2 (&&)` isNumber
16:17:40 <dibblego> Saizan: oh great thanks (I am dealing with  "No instance for (Applicative Identity)" on a different installation)
16:17:46 <fabregastic> i see
16:18:14 <fabregastic> well, i don't think i'm ready to use SHE so i'll stick with making adhoc definitions.  thanks.
16:18:27 <fabregastic> does SHE let you do [| f && g && h && k |] ?
16:18:36 <dibblego> I don't think liftA2 (||) is as useful as one with a Monad constraint
16:18:47 <cmccann> not that liftM2 is any better
16:18:53 <dibblego> no not liftM2
16:19:02 <cmccann> you have to do it explicitly
16:19:04 <dibblego> @type \p q -> p >>= \p' -> if p' then return True else q'
16:19:05 <lambdabot> Not in scope: `q''
16:19:08 <cmccann> yeah
16:19:10 <elliott> fabregastic: i don't think so, but
16:19:17 <dibblego> @type \p q -> p >>= \p' -> if p' then return True else q
16:19:18 <lambdabot> forall (m :: * -> *). (Monad m) => m Bool -> m Bool -> m Bool
16:19:19 <elliott> fabregastic: and $ sequence [f, g, h, k]
16:19:20 <elliott> is nicer anyway
16:19:20 <elliott> err
16:19:24 <elliott> fabregastic: and <$> sequence [f, g, h, k]
16:19:28 <dibblego> I think that is more useful than liftA2 (||)
16:20:08 <fabregastic> elliott: i like f <&&> g <&&> h <&&> k personally.....thanks for the suggestion though.
16:24:43 <dcoutts> elliott, cmccann: ok, so I'm starting a mirror operation now
16:24:50 <dcoutts> http://hackage.factisresearch.com/
16:25:14 <dcoutts> tested with zlib, will fire off a full hackage mirror pass
16:25:19 <dcoutts> and check in the morning
16:25:44 <byorgey> dcoutts++
16:25:46 <byorgey> elliott++
16:25:51 <byorgey> cmccann++
16:27:15 <elliott> karma! :D
16:27:43 <elliott> it would be nice to get some kind of continuous integration thing so we could have it updated to new code live... but that's probably overkill :P
16:28:09 <cmccann> elliott, I could probably rig something up like that
16:28:22 <cmccann> but likely not tonight
16:28:39 <elliott> it would also be nice if it was the same server with the mirror :P
16:28:52 <elliott> dcoutts: wow, it's so much faster
16:28:56 <elliott> than hackage, I mean
16:29:24 <elliott> I take it this is running on the darcs code? (since it doesn't have the single extra change in git :P)
16:30:10 <dcoutts> elliott: right
16:30:22 <dcoutts> elliott: yes, current upstream code
16:30:57 <dcoutts> elliott: expect it to be a bit slow while the mirroring takes place, copying 30-40k tarballs takes a while
16:31:30 <cmccann> hackage-server: Prelude.read: no parse
16:31:31 <cmccann> oh come ON
16:31:34 <cmccann> really, people
16:31:37 <cmccann> really?
16:32:50 * cmccann grits his teeth and considers just grepping the source to remove every use of read preemptively
16:35:26 <elliott> cmccann: hahahaha
16:35:31 <elliott> cmccann: it uses "readM" in some places
16:35:37 <elliott> so it might even be easy to do that
16:35:44 <elliott> (rather than fighting with reads' "interesting" interface)
16:35:48 * cmccann grumbles
16:35:49 <elliott> dcoutts: yeah
16:36:04 <edwardk> i'm really happy to see this becoming relevant again =)
16:36:10 <cmccann> or just replace read with one that returns Maybe regardless
16:36:17 <elliott> dcoutts: one stable mirror running on the latest upstream code and cmccann's server with a partial mirror running on the latest git could work well
16:37:08 <dcoutts> elliott: indeed
16:39:34 <otters> so you can kinda implement a parser with reads
16:45:06 <bgamari> cmccann: I was going to try a full mirror as well
16:45:14 <bgamari> cmccann: Looks like you beat me to it
16:45:26 <danmaftei> when folding over maps, should i use a left or right fold?
16:45:39 <bgamari> cmccann: Should I bother?
16:46:22 <elliott> dcoutts is the one doing the full mirror.
16:46:35 <Rotaerk> danmaftei, I think it'll fit in the glove compartment either way.
16:47:05 <cmccann> yes, dcoutts is doing the mirror
16:47:14 <cmccann> I was looking at the backup and restore stuff
16:47:21 <cmccann> with dubious results as you can see
16:47:39 <cmccann> and am presently somewhat annoyed about it
16:49:16 <mike-burns> danmaftei: Right. Unless you need a left, and then use a left.
16:52:32 <zzo38> It doesn't accept "#if MIN_VERSION_template_haskell(2,7,0)"; how can I fix it?
16:52:36 <danmaftei> rtfm would've been quicker but i appreciate the effort ^_^
16:54:35 <danmaftei> i read that when accumulating a list, a left fold is more efficient, but when accumulating a map, a right fold is better. i can't reason why, but is that the case?
16:55:03 <byorgey> no.
16:55:57 <dcoutts> bgamari: sent a reply to your email so other people know what's going on
16:56:18 <JoeyA> Left folds are (almost) always strict.  You can't implement a lazy variant of foldl' (+) 0, for example.
16:56:29 <byorgey> danmaftei: see http://www.haskell.org/haskellwiki/Fold  and http://www.haskell.org/haskellwiki/Foldr_Foldl_Foldl%27
16:56:33 <dibblego> danmaftei: there are all sorts of attempts to trivialise the reasoning about where fold/foldr are appropriate, but actually, the appropriate reasoning is not trivial, except I would advise just gaining a reasonable understanding of the details of both rather than try to apply some universal rule
16:56:59 <Eduard_Munteanu> Depends on the operation you're folding with.
16:57:16 <danmaftei> i've been through those too many times byorgey =/   thx dibblego
16:57:38 <Eduard_Munteanu> Usually you want foldr with non-strict stuff and foldl' with strict stuff (like (+) on numbers)
16:58:05 <dibblego> danmaftei: I teach a haskell course where I give students a detailed explanation of these two functions (they are quit different in detail), some exercises to help cement those details, and once they understand that detail, the rest falls into place
16:58:07 <byorgey> danmaftei: ok. well, just keep practicing in thinking about laziness + strictness, since that's really the key to understanding when to use what type of fold.
16:58:11 <Eduard_Munteanu> Assuming associativity doesn't get in the way, or the lack of.
16:58:22 <dibblego> that course is online, but really, instruction alongside is required
16:58:29 <dibblego> s/online/open-source
16:59:03 <zzo38> What CPP commands can I use so that it work in template-haskell-2.7.0 or older version differently? The one you told me before doesn't work
16:59:15 <dibblego> I wish I could just give all that understanding to you without manual intervention
17:00:11 <Eduard_Munteanu> Understanding how laziness is implemented helps there, I don't think it's merely about language semantics.
17:01:05 <sam0> What is the error "file name does not match module name" ?
17:01:25 <danmaftei> strictness/laziness is precisely my problem. profiling shows me my code is holding on to needless data and i'm trying to make everything as strict as possible.
17:02:05 <Eduard_Munteanu> sam0: the source file name has to mirror the module name
17:02:08 <quintessence> sam0: if your file declares the module "module Foo where ..." it has to be named Foo.hs
17:02:16 <Cale> Don't make everything as strict as possible, make just the things which need to be strict as strict as they need to be :)
17:03:00 <danmaftei> True, but in this program I gain nothing from laziness heh.
17:03:51 <Cale> Things tend to need to be strict when they're producing summaries of some sort of a large number of independently evaluatable parts, and laziness is good in almost all other cases.
17:03:52 <Eduard_Munteanu> Also, half-way strictness can make things worse.
17:03:58 <sam0> It seems that I did name it that way
17:04:04 <fabregastic> anyone game to answer an (atto)parsec question?
17:04:11 <sam0> my module name is GaussRandom and file name is GaussRandom.hs
17:04:12 <Eduard_Munteanu> Like if you foldr with an operation which you suddenly decide to strictify :)
17:04:13 <sam0> but my error is
17:04:20 <sam0> Saw: 'Main'
17:04:31 <sam0> Expected: 'GaussRandom'
17:04:49 <Cale> Answering questions before you know what the question is can be difficult ;)
17:05:31 <fabregastic> i would like to parse something to the effect of
17:05:57 <fabregastic> <letter> [<letter-or-number-or-hyphen>* <letter-or-number>]
17:06:03 <fabregastic> a real newbie here
17:06:07 <fabregastic> so "a" is ok
17:06:16 <fabregastic> "a-fsdfsdf1241" is ok
17:06:21 <Cale> okay
17:06:22 <fabregastic> "a-" is not
17:07:02 <lispy> "a-----9" is okay?
17:07:25 <danmaftei> Cale: I think that's my scenario: i'm using EM to update a 2D translation matrix given a corpus. an imperative paradigm fits the problem better but i wanted to see how well a functional paradigm deals with it. in any case, since the corpus fits in memory and i'm simply tweaking values in the matrix, laziness appears to be my bane.
17:07:55 <fabregastic> (++) <$> takeWhile isMiddleChar <*> satisfy isLetter  doesn't seem to work for me
17:08:12 <Eduard_Munteanu> Erm, corpus?
17:08:13 <Cale> do x <- letter; y <- many (letter <|> digit <|> char '-'); z <- letter <|> digit; return (x ++ y ++ z)
17:08:43 <fabregastic> forgot to mention i'm trying to use applicative style
17:08:50 <Cale> Well, we can translate...
17:09:03 <zzo38> Monadic stuff is rarely useful for Parsec.
17:09:05 <danmaftei> Eduard_Munteanu: it's just a ton of text :)
17:09:17 <Eduard_Munteanu> Ah.
17:09:41 <Cale> zzo38: It can be more straightforward in some cases in combining the results of subcomputations
17:10:17 <Cale> But most monadic uses of parsers do translate in some fashion to applicative operations
17:10:51 <fabregastic> Cale: thanks for helping out
17:11:04 <sam4> Please help me with this error
17:11:05 <sam4> http://hpaste.org/63658
17:11:33 <Jafet> danmaftei: if you are really lazy, use a profiler instead of implementing twenty fixes to see which ones correct the problem
17:11:40 <Cale> So you could liftA3 (\x y z -> x ++ y ++ z) letter (letter <|> digit <|> char '-') (letter <|> digit)
17:12:33 <fabregastic> Cale: i think you dropped a many somewhere but i get the idea
17:12:40 <zzo38> Cale: I find it never is the case that monadic parsing is useful. Although, it might be useful if parsing something like Fortran's Hollerith constants (but with much larger maximums)
17:12:41 <lispy> sam4: That's odd.
17:12:41 <danmaftei> Jafet: i have. :) i found the offending function and i'm slogging through the heap graphs to get more info
17:12:43 <fabregastic> i think my problem is maybe with attoparsec and not parsec
17:13:31 <Jafet> In that case, you could paste the offensive code (appropriately censored) and ask other people to look at it.
17:13:54 <sam4> lispy: The code itself compiles
17:13:54 <lispy> sam4: do you say "main-is: GaussRandom" in your .cabal file?
17:14:17 <sam4> I'm not sure what that is...
17:14:24 <lispy> sam4: there is a trailing "," after getNRands but I think GHC permits that normally
17:14:44 <lispy> sam4: which, the .cabal file or the "main-is:" line?
17:15:10 <sam4> .cabal file?
17:15:37 <rasfar> sam4: how do you compile it; what's the command?
17:15:39 <lispy> sam4: http://www.haskell.org/haskellwiki/How_to_write_a_Haskell_program#Build_system
17:16:02 <sam4> I just load it in ghci for now...
17:16:17 <rasfar> oh right, that
17:16:35 <fabregastic> Cale: i have written it as
17:16:55 <fabregastic> snoc <$> takeWhile isAlphaNum <*> satisfy isLetter
17:17:00 <hpaste> danmaftei pasted “stack overflow” at http://hpaste.org/63659
17:17:01 <danmaftei> Jafet: sure, if you wanna take a look, won't stop you :)
17:17:13 <fabregastic> but it appears the "takeWhile" is too greedy
17:17:29 <sam4> any ideas...?
17:17:36 <fabregastic> e.g. parseOnly myparse $ pack "hi" fails
17:17:49 <danmaftei> it's hackish to high hell, as i said, an imperative paradigm fits EM better
17:18:39 <Jafet> > (foldl1' (+) [0..999999], foldr1 (+) [0..999999])
17:18:41 <lambdabot>   (499999500000,*Exception: stack overflow
17:19:09 <Jafet> Well, do you know what "stack overflow" denotes?
17:19:13 <zzo38> Is there a command in GHC to list CPP symbols?
17:19:18 * hackagebot hexpat 0.19.10 - XML parser/formatter based on expat  http://hackage.haskell.org/package/hexpat-0.19.10 (StephenBlackheath)
17:20:35 <danmaftei> Jafet: yes, a large number of thunks are being allocated when presumably they should be reduced
17:20:39 <lispy> zzo38: I don't think so.  GHC uses gcc's CPP, IIRC
17:22:06 <Jafet> It's more specific than that. A stack overflow occurs when a value depends strictly on nested evaluation
17:22:25 <Jafet> In your case, the spine (tree shape) of M.Map is strict
17:22:46 <rasfar> sam4: GaussRandom is exporting getNRands which is not in scope.
17:23:02 <Jafet> To avoid the nested thunks, your fold should force the evaluation of the map spine
17:23:08 <Jafet> @src foldl'
17:23:09 <lambdabot> foldl' f a []     = a
17:23:09 <lambdabot> foldl' f a (x:xs) = let a' = f a x in a' `seq` foldl' f a' xs
17:24:38 <sam4> hm2026 weirdly, when I quit terminal and restarted, it compile 2026 :(
17:24:47 <sam4> I had getNRands in the bottom
17:24:53 <sam4> apparently it works now for some reason
17:25:01 <rasfar> good to hear!
17:36:30 <zzo38> How can I make it compile different for template-haskell-2.6.0.0 and template-haskell-2.7.0.0?
17:39:00 <zzo38> Does Cabal have any options which can help with this?
17:41:33 <zzo38> O, MIN_VERSION only works with Cabal, not with GHCi.
17:42:23 <dcoutts> zzo38: though with a little work it's possible to get it working with ghci too
17:42:40 <zzo38> dcoutts: How?
17:42:52 <dcoutts> need flags like -optP-include -optPdist/build/autogen/cabal_macros.h
17:43:03 <dcoutts> zzo38: see "cabal build -v" output for details
17:43:14 <dcoutts> oh and -cpp
17:47:12 <zzo38> OK, thanks that works
17:47:26 <lispy> or cabal-dev ghci
17:47:37 <lispy> (actually, untested)
17:47:40 <Zamarok> Is this accurate? http://chrisdone.com/posts/2012-01-06-monads-are-burritos.html
17:47:48 <lispy> Cabal-dev ghci will work for mos things though.  Not certain about CPP.
17:47:53 <Zamarok>  /serious question, I am a Haskell noob
17:48:13 <zzo38> I just added those things to an OPTIONS pragma. Will that cause problems?
17:48:19 <lispy> Zamarok: the "monads are foo" tutorials and posts are usually confusing, IMO
17:48:22 <MostAwesomeDude> Zamarok: Yeah, that really is how people's brains work.
17:48:27 <MostAwesomeDude> lispy: Try reading it first. :3
17:48:42 <MostAwesomeDude> Oh, nevermind, derp.
17:48:58 <MostAwesomeDude> I was thinking of another one, where he talks about the psychological way we conceptualize things.
17:48:58 <Zamarok> lispy: what is a non-confusing tutorial?
17:49:18 <MostAwesomeDude> Zamarok: How are you learning Haskell? Are you reading LYAH or RWH?
17:49:23 <lispy> Zamarok: http://www.haskell.org/haskellwiki/All_About_Monads
17:49:24 <zzo38> Monads are a kind of mathematical structore; specifically, an endofunctor which two additional operations return and join on them, which must follow certain laws. That is what it is.
17:49:35 <Zamarok> I am midway through both books
17:49:45 <Zamarok> thanks for the link
17:50:09 <zzo38> dcoutts: Is this correct?  http://sprunge.us/ZKEU
17:50:16 <elliott> Zamarok: that post is a joke
17:50:27 <MostAwesomeDude> https://byorgey.wordpress.com/2009/01/12/abstraction-intuition-and-the-monad-tutorial-fallacy/ is what I was thinking of.
17:50:37 <elliott> based on http://byorgey.wordpress.com/2009/01/12/abstraction-intuition-and-the-monad-tutorial-fallacy/ and http://blog.plover.com/prog/burritos.html
17:50:58 <Zamarok> elliott: the author was joking? Or it's so bad it's like joke?
17:51:06 <elliott> Zamarok: the author was joking
17:51:59 <Zamarok> hmm >_> I will keep reading my books
17:52:41 <Jafet> Applicative represents a hot dog bun
17:53:00 <cmccann> Functor is a slice of stale white bread
17:53:20 <dcoutts> zzo38: um I meant passing those flags on the command line, don't put it in the {-# OPTIONS
17:53:44 <dcoutts> zzo38: it's not generally a good idea to reference generated files in source files like that
17:53:57 <dcoutts> zzo38: and eventually it'll not be necessary, with cabal repl
17:54:07 <dcoutts> which will call ghci with the right flags
17:55:09 <elliott> Zamarok: the joke is that byorgey made a post some years ago making light of a number of bad analogy-based monad tutorials that were being created at the time, using burritos as a joking example
17:55:33 <elliott> Zamarok: then a joke post was written based on that attempting to show that monads "really are" like burritos, and then that cartoon is based on /that/
17:55:44 <elliott> you should probably just ignore it :P
17:56:42 <zzo38> dcoutts: O, sorry! OK.
17:56:53 <Sgeo> cabal repl?
17:57:46 <dcoutts> Sgeo: we had a GSoC project on it, it's not integrated yet
17:58:14 <Sgeo> What exactly would it do?
17:58:20 <Sgeo> Besides being a REPL
18:01:50 <lispy> or use cabal-dev ghci which calls ghci with the right flags...
18:02:01 * cmccann mutters something about dragging build infrastructure improvements into the light kicking and screaming if need be
18:02:01 <zzo38> dcoutts: Even other than the OPTIONS pragma, is the code for 2.7.0.0 correct?
18:02:05 <lispy> I haven't checked if it handles CPP, but if it doesn't submit a bug report
18:02:10 <zzo38> Does it work on your computer?
18:02:54 <lispy> I think making cabal more plugin friendly would be good here.  cabal-dev and 'repl' could both be plugins on top of cabal.
18:03:16 <lispy> As could the translators like alex, happy, hsc2hs, c2hs, etc
18:04:00 <zzo38> OK; hopefully my package is fixed now
18:04:19 * hackagebot extensible-data 0.1.0.3 - Sums/products/lists/trees which can be extended in other modules  http://hackage.haskell.org/package/extensible-data-0.1.0.3 (AaronBlack)
18:07:11 <hpaste> Deepak pasted “State Monad” at http://hpaste.org/63660
18:07:28 <elliott> cmccann: I hear putting things on GitHub helps with that.
18:07:43 <cmccann> a fascinating idea
18:07:46 <irene-knapp> cabal is actually quite plugin-friendly already
18:07:53 <hpaste> Deepak pasted “State Monad” at http://hpaste.org/63661
18:10:27 <vyom> Is there any real difference between 1 and 2 defined here: http://hpaste.org/63661
18:10:32 <lispy> irene-knapp: how so?
18:10:48 <irene-knapp> if you put an arbitrary package in the build-depends, it is available to the Setup.hs script
18:10:55 <lispy> irene-knapp: it AFAICT, cabal has to be modified to know about programs to run
18:11:06 <irene-knapp> not really
18:11:16 <irene-knapp> you can write any code you want in Setup.hs and it will work fine without patching Cabal
18:11:22 <rwbarton> vyom: in Haskell 98, yes, you can pass the first Turtle to another type constructor but not the second Turtle
18:11:22 <lispy> Setup.hs has a lot of issues though.
18:11:23 <irene-knapp> I have done this :)
18:11:32 <irene-knapp> yes, Setup.hs is not ideal, but it's pretty good for a kludge
18:11:52 <rwbarton> vyom: maybe that is even true for ghc+extensions
18:11:56 <lispy> For example, how do you control what packages are given to setup.hs? You can't, for instance, specify in your .cabal file which packages it should gets
18:12:14 <irene-knapp> as a matter of fact, anything in build-depends is given to it
18:12:17 <irene-knapp> which is? not ideal
18:12:19 <irene-knapp> but it's something
18:12:56 <rwbarton> vyom: if a program uses the second Turtle and it compiles, though, then it will also compile with the first Turtle and have the same meaning
18:13:00 <vyom> rwbarton: Yes.. that is true. I found that out when I was compiling my code. But if I omit the type parameter, it shouldnt make a difference right?
18:13:06 <lispy> Just this morning a colleage was explaining a build problem he had where his Setup.hs was getting things out of his global package db instead of a local one and he couldn't control it
18:13:08 <vyom> rwbarton: ok got it..
18:13:16 <irene-knapp> well, did he try build-depends?
18:13:47 <lispy> I can ask him when I see him again, but it certainly sounded like he tried all the reasonable things
18:13:50 <irene-knapp> okay
18:13:55 <irene-knapp> I mean, it's not documented behavior
18:13:59 <irene-knapp> it just happens to be there :)
18:14:07 <lispy> But, not everything supports build-type /= Simple
18:14:13 <irene-knapp> hmmm okay
18:14:17 <lispy> And IMO, Setup.hs is really not maintainable
18:14:20 <irene-knapp> yeah, I agree
18:14:25 <irene-knapp> my fork of Cabal (Faction)
18:14:35 <irene-knapp> drops everything but Simple, heh
18:14:45 <irene-knapp> I don't think things /= Simple are likely to even work well enough to be worth maintaining, heh
18:15:00 <irene-knapp> it also drops the other compilers.  it's worth noting that my fork is only for my personal use :)
18:15:17 <lispy> I've had to use non-simple builds because I needed to call out to build individual files with make
18:15:32 <rwbarton> vyom: basically, "type Turtle a = State TState a" means "replace every occurrence of Turtle applied to some type a with State TState a"--if you have Turtle in a position where it isn't applied to anything, that's an error
18:15:49 <irene-knapp> so I mean, ultimately I think Cabal needs changes, obviously, or I wouldn't have done that.  but my first reaction when people other than me claim they can't use Cabal, or can't use Simple, is skepticism :)
18:15:53 <lispy> Anyway, my idea for plugins was more about having a way for cabal to determine what to run and knowing where to look for it
18:16:00 <irene-knapp> ah, hm.
18:16:01 <irene-knapp> okay.
18:16:06 <rwbarton> replacing type signatures by their expansions doesn't change the meaning of your program at all
18:16:11 <lispy> LIke the way plugins work with git
18:16:14 <irene-knapp> right
18:16:18 <irene-knapp> well, that would indeed be nice
18:16:31 <irene-knapp> but the reason it doesn't exist yet is that Cabal is unmaintained only nobody has noticed :)
18:16:34 <irene-knapp> well
18:16:35 <irene-knapp> that's harsh
18:16:46 <irene-knapp> probably too harsh
18:16:51 <irene-knapp> but it has a grain of truth to it
18:16:55 <lispy> It certainly feels that way sometimes
18:17:16 <lispy> dcoutts has done a lot of hard work on cabal, and I don't intend to diminish him or his contributions
18:17:31 <irene-knapp> oh for sure
18:17:36 <irene-knapp> and I very much respect his technical acumen
18:18:07 <irene-knapp> it's clear that his real job is taking too much time for him to also maintain Cabal, at this point, though :(
18:18:16 <irene-knapp> which is fair - I mean, it's open-source and he's not being paid for Cabal
18:18:29 <vyom> rwbarton: Ok.. I am using this code from some other library which has that syntax (with explicit type param 'a'). I need to use that type inside another type constructor. So it looks like I need to go to the person who created the library I am consuming and request him to change it
18:18:33 <lispy> Instead of adding plugins, one idea I've talked over with some people here is making it so that cabal works more like one of those foo-config things.  You ask it questions from your makefile.
18:18:43 <irene-knapp> hmm
18:18:45 <irene-knapp> no, I don't like that
18:18:53 <irene-knapp> it's actually really complicated to build in the situations I've had
18:18:59 <irene-knapp> you have to do things in a very specific order, in some cases more than once
18:19:17 <irene-knapp> I am at a loss for how I would put that information in declarative format for Make, without having the same data model as Make
18:19:24 <vyom> rwbarton: unless there is another way around it
18:19:45 <mike-burns> All make replacements grow until they re-invent make.
18:19:49 <lispy> irene-knapp: Yeah, Make is not perfect but it is powerful and ubiquitous (modulo windows :)
18:19:52 <irene-knapp> yes
18:20:16 <irene-knapp> well, I also think that I would have to write a few hundred lines of dense Make code to do what I do in Faction
18:20:25 <irene-knapp> which is build hybrid Haskell-ObjC .app bundles
18:20:32 <lispy> ah
18:20:40 <irene-knapp> and that code would then be unmaintainable by me, its author
18:20:48 <lispy> Yes, that sounds quite difficult given standard cabal (and probably make)
18:20:50 <irene-knapp> yes
18:21:01 <irene-knapp> it was a few hundred lines of Haskell to add it to Cabal :)
18:21:16 <irene-knapp> but relatively simple Haskell, mostly just reorganizing facilities that were already present :)
18:21:22 <lispy> Have you ever used maven?
18:21:24 <irene-knapp> no
18:21:27 <irene-knapp> what is it like?
18:21:34 <mlh> it's a beast :-)
18:21:39 <irene-knapp> hmm
18:21:40 <lispy> It's a java build tool, but it has some interesting ideas mixed in with all the xml
18:21:58 <irene-knapp> they have two now?  I thought they liked Ant
18:21:59 <lispy> Because it's java you can easily download plugins as bytecode and run them
18:22:01 <mlh> I think you should look at https://github.com/apenwarr/redo
18:22:03 * irene-knapp nods
18:22:16 <irene-knapp> well, looking
18:22:21 <lispy> I think with Haskell we could probably do something similar actually
18:22:59 <irene-knapp> yeah
18:22:59 <elliott> I don't see how redo would reduce the pain of domain-specific logic much.
18:23:04 <lispy> I need to go home
18:23:05 <irene-knapp> elliott: I agree, yes
18:23:14 <elliott> it would make dependency specification a /little/ easier but not much
18:23:16 <irene-knapp> we need a general-purpose programming language to implement a build system
18:23:17 <lispy> ciao!
18:23:33 <rwbarton> vyom: well the thing they define is just a type synonym, so you can use its expansion (without the 'a') directly
18:23:34 <elliott> irene-knapp: well redo can theoretically be used with any language that can do exec
18:23:36 <elliott> but it's rather sh-oriented
18:23:39 <irene-knapp> hmm
18:23:56 <elliott> it's also pretty inefficient by design
18:24:04 <elliott> (albeit, in the same way as make)
18:24:10 <mlh> elliott: yep, I was twitching at the thought of someone creating yet another make (or maven or ...)
18:24:11 <elliott> (but make doesn't have to run whole shell scripts, so it can optimise it somewhat)
18:24:16 <mlh> redo looks pretty good
18:24:26 <elliott> redo is OK. I prefer tup as far as make-replacements go
18:24:36 <mlh> ah yes, I've heard of that
18:25:03 <elliott> it's not quite ready for prime-time yet IMO but once it gets variants (= multiple isolated build configurations) it'll be better than make by a long shot
18:25:09 <irene-knapp> hmm okay
18:25:23 <elliott> (and it would work well for complex haskell projects, as it supports using an external program to generate build rules natively)
18:30:45 <SmartViking> Hello
18:30:50 <hpaste> smartviking pasted “HALP” at http://hpaste.org/63662
18:30:59 <vyom> rwbarton: The problem is that the type synonym actually uses a type that is not exported http://patch-tag.com/r/byorgey/diagrams-contrib/snapshot/current/content/pretty/src/Diagrams/TwoD/Path/Turtle.hs
18:31:12 <vyom> see line 31
18:31:36 <vyom> TState is not exported
18:32:05 <cmccann> hackage-server: internal error: evacuate: strange closure type 35601
18:32:06 <cmccann> ok
18:32:14 <cmccann> think that means its time to just give up for tonight
18:32:16 <SmartViking> What I want the program to do is to create a list of numbers
18:32:27 <byorgey> vyom: patches welcome =)
18:32:56 <elliott> cmccann: wow
18:33:50 <rwbarton> hmmm... I find it vaguely unsettling that you can export a type synonym that's defined in terms of unexported types
18:33:51 <cmccann> that happened after it chewed so much memory and CPU trying to load a backup file that it brought my system to its knees for about 20 straight minutes
18:34:15 <vyom> byorgey: sure.. for now I just copied over the file and modified it myself. I intend to patch it.. just wanted to understand what is going on :)
18:34:25 <SmartViking> If someone could help me out that would be awesome, I've tried to solve this problem since yesterday and I can't figure out what it is. It's so annoying, I'm new to Haskell so I don't understand the error messages
18:34:39 <byorgey> vyom: ok =)
18:34:51 <rwbarton> can't you get at the unexported constructors anyways with a gadt or something
18:35:32 <rwbarton> or a type family
18:35:47 <elliott> SmartViking:             return (read strNum) : theRest
18:35:49 <elliott> this line contains an error
18:35:51 <rwbarton> or just a function
18:35:52 <vyom> rwbarton: now i have no idea what you are talking about :)
18:35:56 <elliott> an operator precedence-related error
18:36:14 <elliott> additionally,
18:36:15 <elliott> SmartViking:             theRest <- read number
18:36:18 <elliott> this line contains a type error
18:36:45 <SmartViking> How would I fix it?
18:36:57 <otters> look at the types
18:37:02 <rwbarton> vyom, just thinking out loud if there would be a workaround in theory if you couldn't modify the module
18:37:02 <dcoutts> cmccann: mm, how much memory were you using?
18:37:04 <elliott> well, the operator issue can be fixed by changing the line to
18:37:06 <elliott> return (read strNum : theRest)
18:37:13 <elliott> because right now, your line means (return (read strNum)) : theRest
18:37:16 <elliott> which is obviously not what you want
18:37:26 <elliott> SmartViking: other than that: what type does read have? what type does number have?
18:37:31 <SmartViking> aha
18:37:43 <Eduard_Munteanu> rwbarton: yeah, it does seem unsettling, although Haskell already breaks modularization boundaries in various ways.
18:38:08 <rwbarton> I guess the same happens with an exported function whose type is not exported
18:38:16 <cmccann> dcoutts, more than my system can handle gracefully, not sure beyond that :T
18:38:43 <SmartViking> elliott: I really don't understand types at all, that is the thing I have most problems with with Haskell. I don't know what type theRest would become, and I don't know how to figure it out :(
18:38:48 <dcoutts> cmccann: were you working with the full package set (or something approximating that) ?
18:39:08 <dcoutts> cmccann: I figure it currently takes somewhere between 4-8Gb
18:39:09 <cmccann> the tarball with the most recent version of each
18:39:19 <cmccann> and my system has 2GB of memory
18:39:28 <dcoutts> ok, which is about half the size of the full set
18:39:30 <dcoutts> or less
18:39:39 <elliott> SmartViking: You know what type read has, though, right?
18:39:47 <cmccann> it got as far as trying to compute the revdeps and then died with the strange closure thing
18:39:50 <elliott> The error is "read number", forget about theRest right now.
18:40:11 <elliott> dcoutts: methinks acid-state might not be the most appropriate storage backend for Hackage...
18:40:16 <SmartViking> elliott: I don't know, a procedure?
18:40:21 <elliott> :t read
18:40:22 <lambdabot> forall a. (Read a) => String -> a
18:40:28 <elliott> read has type (Read a) => String -> a
18:40:34 <elliott> now, even if you don't know what type number is, it's not a string, is it?
18:40:35 <dcoutts> elliott: it's not that, it's that we're keeping the full parsed PackageDescription in memory
18:40:42 * Enigmagic thinks a static page generator would be even better :P
18:40:45 <dcoutts> since it's convenient, but it's not necessary
18:40:48 <elliott> dcoutts: ah
18:40:59 <elliott> dcoutts: could do some evil unsafeInterleaveIO hacks :P
18:41:00 <dcoutts> elliott: and we need the full package graph in memory to do revdeps sensibly
18:41:02 <cmccann> yeah, whatever it's doing seems kind of ridiculous
18:41:09 <cmccann> there must be a better way
18:41:13 <elliott> meh, revdeps just needs indexes or whatever
18:41:25 <Enigmagic> or just a two pass system
18:41:41 <elliott> we know that the frist 90% has been done on hackage 2
18:41:43 <elliott> I get the feeling we've just started the last 90% :P
18:41:49 <cmccann> I guess the first thing I work on with this is going to be "make it possible to load a backup with a supercomputing cluster"
18:41:57 <cmccann> because seriously
18:42:00 <elliott> with? done!
18:42:06 <cmccann> er
18:42:07 <dcoutts> cmccann: right, there's lazy IO for the backup/restore, but there's also the steady-state memory use
18:42:33 <SmartViking> elliott: Yeah I guess
18:42:40 <elliott> SmartViking: so, what do you actually want to do there?
18:42:43 <dcoutts> cmccann: you might like to try with a cut down version of the package index (not the archive of full tarballs)
18:42:44 <cmccann> I'll see about reducing the steady-state memory use once I can actually run the thing with a bunch of packages
18:42:51 <cmccann> yeah I think I may need to
18:43:03 * elliott would rather like to be able to build it
18:43:14 <elliott> I can't figure out what order I have to do things in to end up with a non-broken installation plan
18:43:15 <dcoutts> elliott: it doesn't build for you?
18:43:20 <SmartViking> elliott: Have no idea :((
18:43:30 <elliott> SmartViking: if you don't know what you want your code to do, then I can't help you write it
18:43:36 <dcoutts> elliott: hmm, cabal install --dry just works for me
18:43:40 <elliott> dcoutts: not with ghc 7.4.1, wants to reinstall a bunch of stuff, --solver=modular --avoid-reinstalls gives up
18:43:44 <cmccann> since right now I can't even profile it since apparently GHC kicks the bucket for some reason
18:43:46 <elliott> I can show you the errors if you want
18:43:52 <dcoutts> elliott: oh, 7.4, not tried that
18:43:52 <cmccann> consistently too, three times in a row
18:43:54 <SmartViking> elliott: I want my code to create a list of Ints based on user input
18:44:11 * cmccann is using a fresh 7.4 install, upgraded this morning
18:44:15 <dcoutts> elliott: I noticed a patch in the git repo for 7.4
18:44:21 <elliott> SmartViking: ok. so you want theRest to be the result of recursing, right?
18:44:24 <elliott> dcoutts: yes, cmccann's
18:44:29 <dcoutts> ok
18:44:29 <elliott> but he ended up hacking a bunch of packages in the process
18:44:31 <elliott> so it doesn't really "work"
18:44:33 <SmartViking> elliott: Yes
18:44:40 <cmccann> not a bunch
18:44:49 <elliott> well, more than one :P
18:44:54 <dcoutts> don't people keep their old ghc when installing a new version?
18:44:54 <cmccann> a couple at most
18:44:55 <elliott> SmartViking: well, why do you need read then? "theRest <- number"
18:45:02 <elliott> dcoutts: pfft
18:45:04 <elliott> like I need old stuff
18:45:14 <dcoutts> heh
18:45:21 * cmccann has like eleven GHCs installed, it's ridiculous and not even funny
18:45:25 <dcoutts> only if you want it to work :-)
18:45:30 <dcoutts> cmccann: wow, even more than me
18:46:37 <hpaste> elliott pasted “hackage-server” at http://hpaste.org/63663
18:46:39 <elliott> dcoutts: ^
18:46:55 <elliott> with old-deepseq-containers, it's:
18:47:02 <hpaste> “C. McCann” pasted “why do I still have all these” at http://hpaste.org/63664
18:47:15 <hpaste> elliott annotated “hackage-server” with “hackage-server (annotation)” at http://hpaste.org/63663#a63665
18:47:20 <cmccann> and that's not counting a couple in other locations
18:47:35 <elliott> cmccann: good god
18:47:44 <SmartViking> elliott: I removed both reads and now it kinda works, it returns a list of strings based on user input
18:47:47 <startling> what's the best way to get different values for `a = 1` and `a := 1` from parsec? I have things kind of working, but I think I use `try` too much.
18:48:03 <cmccann> I was obviously having an argument with the build snapshots a few months ago
18:48:54 <SmartViking> elliott: I thought read was used to convert numbers to strings, am I wrong?
18:49:07 <otters> read is used to convert strings to anything
18:49:13 <dcoutts> elliott: try relaxing the hackage-server constraint on deepseq
18:49:18 <SmartViking> Oh I meant to convert to Ints
18:49:19 <elliott> SmartViking: No, you only need to remove one of the reads.
18:49:20 <otters> :t read
18:49:21 <lambdabot> forall a. (Read a) => String -> a
18:49:36 <elliott> dcoutts: ok... but isn't that one there for a reason, i.e. deepseq 1.3 broke compatibility a lot?
18:49:51 <dcoutts> elliott: no idea
18:49:59 <elliott> lots of packages depend on deepseq <1.3 I think
18:50:09 <SmartViking> elliott: This gives an error:             return (read strNum : theRest)
18:50:31 <dcoutts> elliott: the solver message is saying it cannot pick any version of deepseq
18:50:42 <hpaste> “C. McCann” pasted “hackage-server cabal changes” at http://hpaste.org/63666
18:50:52 <SmartViking> > read "3"
18:50:52 <cmccann> I made a few more adjustments to mine
18:50:52 <lambdabot>   *Exception: Prelude.read: no parse
18:51:00 <elliott> cmccann: that second deepseq line looks dodgy
18:51:01 <cmccann> while messing with the fresh 7.4
18:51:05 <qpu> SmartViking: read is polymorphic. the implementation is chosen based on return type. pretty neat
18:51:06 <JoeyA> I think the mailing facility for http://hackage.haskell.org/trac/hackage/ isn't working.  I reset my password, but didn't get an email.
18:51:07 <elliott> cmccann: shouldn't it be in the else section of the old-deepseq-containers flag
18:51:15 <elliott> SmartViking: yes, it does
18:51:22 <dcoutts> elliott: can't use 1.3+ because hackage says so, can't pick older because they will not build with 7.4 libs
18:51:25 <elliott> err, I mean
18:51:27 <elliott> it does?
18:51:31 <elliott> dcoutts: right
18:51:40 <elliott> SmartViking: please hpaste the error
18:51:57 <cmccann> it's probably dodgy, I was just adjusting the dependencies empirically
18:52:05 <cmccann> by which I mean "change some things and see if it works now"
18:52:06 <cmccann> :P
18:52:17 <dcoutts> JoeyA: what's your username on there? I'll check if we still have email addresses
18:52:24 <JoeyA> joeyadams
18:52:30 <JoeyA> It said it sent an email
18:52:40 <JoeyA> (that's the Trac that fell to spam)
18:53:03 <elliott> rejecting: deepseq-1.2.0.1, 1.2.0.0 (conflict: Cabal =>
18:53:03 <elliott> array==0.4.0.0/installed, deepseq => array>=0.1 && <0.4)
18:53:06 <elliott> this seems to be the essential problem
18:53:09 <elliott> array is a boot lib, right?
18:53:16 <hpaste> SmartViking pasted “error” at http://hpaste.org/63667
18:53:51 <elliott> SmartViking: yes, indeed
18:53:56 <elliott> SmartViking: you have to give number a type signature
18:54:00 <cmccann> elliott, I have array 0.4 as a boot lib
18:54:05 <cmccann> and deepseq 1.3
18:54:09 <elliott> cmccann: yes, but deepseq 1.2 depends on array <0.4
18:54:11 <elliott> hmm
18:54:15 <elliott> does hackage-server build with deepseq 1.3 for you?
18:54:21 <cmccann> that's the only version of deepseq I have installed
18:54:26 <cmccann> so
18:54:27 <cmccann> yes
18:54:37 <dcoutts> JoeyA: hrm, so it's got your account and email. I'll have to look into why it's not sending email.
18:54:49 <elliott> ok, the fix should be simple then
18:54:59 <Sgeo> If you didn't supply the type signature, how would it know if it meant some weird esoteric kind of number that's just an Interger + 5?
18:55:06 <JoeyA> dcoutts: Thanks
18:55:13 <elliott> \o/
18:55:37 <cmccann> at any rate
18:55:53 <cmccann> the "strange closure type" nonsense has killed my enthusiasm for dealing with this stuff tonight
18:56:04 <cmccann> dcoutts, what's the easiest way to get myself a smaller set of packages
18:56:10 <cmccann> other than mirroring some one at a time
18:56:21 <cmccann> or hacking together a script to do that I guess
18:56:22 <SmartViking> elliott: I have no idea what it should be. I also though the compiler didn't require me to?
18:56:28 <SmartViking> thought*
18:56:33 <dcoutts> JoeyA: hmm, it's got the same settings as the ghc trac, I'll have to check later what's going on
18:56:38 <qpu> SmartViking: numbers are overloaded too. 0 could be Float, Int, etc.
18:56:45 <elliott> SmartViking: it does, because you use "read", which can return any readable type, it's disambiguated by what type you use it as
18:56:49 <elliott> so GHC needs more information here
18:56:50 <dcoutts> cmccann: make a cut down 00-index.tar.gz file
18:56:52 <qpu> > read "1" :: Float
18:56:53 <elliott> SmartViking: have you read Learn You a Haskell?
18:56:53 <lambdabot>   1.0
18:57:00 <JoeyA> Thanks
18:57:00 <qpu> > read "1" :: Int
18:57:01 <lambdabot>   1
18:57:03 <elliott> SmartViking: you're not going to get anywhere without a basic understanding of what types things have, etc.
18:57:10 <dcoutts> cmccann: that's likely the crucial one, not the archive.tar
18:57:29 <cmccann> yeah
18:57:35 <elliott> cmccann: pull request'd
18:57:44 <dcoutts> cmccann: the files in archive.tar just get written out to disk, it's the index that gets parsed into memory
18:57:49 <cmccann> so just reaching in and performing a brutal packagectomy on the tarball will work?
18:57:56 <elliott> cmccann: with a dependency fix that lets cabal-dev install --solver=modular --avoid-reinstalls start compiling here
18:58:01 <elliott> cmccann: (without --avoid-reinstalls it still fails though :P)
18:58:11 <dcoutts> cmccann: yes, edit the 00-index.tar.gz with e.g. file-roller
18:58:16 <elliott> who knows whether it'll actually succeed, though
18:58:25 <SmartViking> elliott: I'm currently reading YAHT, but I haven't learned much about types. I guess I'll read LYAH
18:58:29 <cmccann> dcoutts, ok. that's easy enough, thanks.
18:58:44 <elliott> SmartViking: ahhh, yeah, skip YAHT
18:58:47 <elliott> LYAH is much much better
18:59:02 <dcoutts> cmccann: to further narrow things down it's possible to disable features/modules in the server
18:59:05 <elliott> SmartViking: but, for your immediate problem, number should have type IO [Int] or IO [Integer]
18:59:09 <elliott> because it's an IO action returning a list of integers
18:59:16 <dcoutts> cmccann: to see which ones are the real memory / IO / CPU hogs
18:59:26 <cmccann> dcoutts, well I'd like to just profile it
18:59:35 <cmccann> but I can't do that with GHC dying for some reason
18:59:38 <dcoutts> right
18:59:48 <dcoutts> if you can get the memory use down that should go away
18:59:53 <cmccann> which seemed to be tied to heavy memory use, yeah
19:00:01 <SmartViking> elliott: Awesome, thank you for your time :)
19:00:05 <cmccann> so I'd like to reduce it so the load is high but not abusrd
19:00:09 <cmccann> and then profile
19:00:14 <cmccann> but not tonight
19:00:18 <dcoutts> right, since profiling makes it slower and take more mem
19:00:28 * elliott 's immediate plans are to convert the HTML generation to blaze-html and look into making revdeps possible without keeping the whole graph in RAM
19:00:28 <elliott> FWIW
19:00:52 <elliott> then I'll probably look into getting something resembling djahandarie's design working
19:01:03 <dcoutts> elliott: we keep all the PackageDescriptions in memory for other reasons too, it'll be fairly major surgery I fear
19:01:29 <cmccann> dcoutts, yeah, adding the profiling is what pushed it over the edge from "system grinds along for 15 minutes" to "system grinds nearly to a halt for 20 minutes before GHC kicks the bucket"
19:01:33 <dcoutts> elliott: one idea was to pick out a subset of the info that we actually need, and not use Cabal's current PackageDescription type
19:01:48 <elliott> dcoutts: right, I'll have to look into it
19:01:58 <elliott> dcoutts: it's sufficiently stupid that I'm driven to :P
19:02:09 <elliott> (no offence, it's just ridiculous to need RAM linear in the number of packages)
19:02:15 <dcoutts> elliott: or the other idea was a more cunning caching system but that's painful
19:02:28 <elliott> is the storage of the graph abstracted out?
19:02:31 <dcoutts> elliott: I'm not so sure it's ridiculous
19:02:46 <dcoutts> so long as it's reasonable
19:02:55 <elliott> if it is, then making it load on demand shouldn't be too difficult; the problem is that heavy use of it like revdeps will become slow and will need optimising/caching/etc.
19:03:03 <elliott> but means it can be more incremental than major surgery
19:03:12 <dcoutts> there's some pretty big advantages to using Haskell types rather than an external DB
19:03:23 <elliott> yes, of course
19:03:36 <dcoutts> but yes it does need careful selection of what we keep in memory
19:03:37 <elliott> but as long as the external interface is that, internally whatever can be done
19:03:39 <dcoutts> and how we represent that
19:03:43 <cmccann> anyway, I'm out for the night
19:03:48 <dcoutts> me too
19:03:57 * cmccann hopes elliott magically fixes the revdeps stuff before tomorrow evening
19:04:09 <dcoutts> elliott: PackageDescription is very convenient, but a memory hog
19:04:57 <elliott> mm
19:05:08 * elliott would prefer to simply store less rather than micro-optimising individual representation
19:05:17 <elliott> but I haven't really looked at the code yet, so I'll have to see
19:05:19 <dcoutts> elliott: actually you'll notice we do have a cheapo system to avoid loading it all
19:05:25 <dcoutts> which is that we only parse it lazily
19:05:33 <elliott> right
19:05:34 <dcoutts> cheap hack
19:05:43 <dcoutts> but for import/export that does not help
19:05:48 <elliott> that helps for a finite prefix of time :P
19:05:51 <elliott> since nothing will ever be unloaded
19:05:51 <dcoutts> right
19:06:02 <elliott> (GHC should have a way to turn a value back into a thunk)
19:06:05 <cmccann> heh
19:06:12 <elliott> not even joking, it'd be useful :P
19:06:15 <dcoutts> elliott: well that's the basis of one caching approach
19:06:34 <elliott> what, messing around with internal representations to thunkify values?
19:06:41 <dcoutts> elliott: which would be to have a thread expire things replacing them with their thunk
19:07:03 <dcoutts> elliott: no, explicit insert into the Data.Map of a new thunk
19:07:08 <elliott> ah
19:07:13 <elliott> that's slightly less... terrifying
19:07:17 <cmccann> elliott, sounds like the kind of thing that can be implemented easily with unsafePerformIO and work well except for a handful of confusing corner cases that break everything
19:07:22 <elliott> tbh I'd rather abstract out the graph to avoid lazy IO entirely
19:07:34 <Enigmagic> why does it need to be in memory at all?
19:07:35 <dcoutts> it's not lazy IO we do btw
19:07:36 <elliott> but I'm a bit of a zealot when it comes to lazy IO :P
19:07:45 <elliott> dcoutts: well, hmm, right
19:07:47 <elliott> lazy parsing
19:09:45 <dcoutts> elliott: you can check but I'm pretty sure the revdep graph itself does not use much memory
19:09:55 <dcoutts> it's the packages it refers to
19:10:02 <cmccann> anyway, I'm out, got stuff to do tomorrow
19:10:14 <cmccann> I'll try to get things moving tomorrow evening :T
19:10:25 <dcoutts> elliott: though no doubt the graph could be improved too, I've not looked much at that part of the code
19:10:38 <dcoutts> cmccann: great
19:11:08 <elliott> dcoutts: right, that's not really what I meant
19:11:19 <elliott> I meant, making the revdep stuff possible efficiently without storing the entire package graph in memory
19:11:26 <elliott> but I dunno, again I haven't actually looked at the code yet because it hasn't built yet :P
19:11:53 <dcoutts> elliott: ok, have fun. Well past my bed time, g'night!
19:17:46 <elliott> oh, I'll look into replacing json with aeson too, that sounds easy
19:18:13 * elliott just uses "easy" to refer to arbitrary tasks
19:38:34 <mandaya> hmm... this is really weird
19:38:39 <mandaya> I have code that runs fine in ghci
19:38:45 <mandaya> but segfaults when compiled
19:38:56 <mandaya> and the segfault is in a C library I'm calling out to
19:39:13 <mandaya> anyone have any ideas?
19:41:39 <mandaya> I mean, I guess for what I need it for, running it through ghci isn't that big of a deal
19:41:44 <mandaya> but its just confusing
19:42:26 <elliott> cabal: The program alex version ==2.2.* || ==2.3.* is required but the version
19:42:26 <elliott> found at /home/elliott/.cabal/bin/alex is version 3.0.1
19:42:26 <elliott> oops
19:42:32 <elliott> how backwards-incompatible is alex 3?
19:42:57 <qpu> mandaya: you probably already know, but try using gdb?
19:43:43 <elliott> qpu: gdb + GHC = "fun"
19:44:20 * hackagebot ghc-mod 1.10.5 - Happy Haskell programming on Emacs  http://hackage.haskell.org/package/ghc-mod-1.10.5 (KazuYamamoto)
19:44:22 <qpu> oh, bummer. even if you just set breakpoints in your C library code?
19:44:37 <elliott> well dunno
19:44:42 <elliott> I've never actually done it, thanks to its reputation
19:45:58 <qpu> heh, can't say i've been curious
19:49:37 <elliott> hmph
19:49:42 <parcs`> elliott: alex 3 introduces and enables by default unicode support
19:49:45 <parcs`> i think
19:49:47 <elliott> parcs`: ah
19:49:58 <elliott> parcs`: how likely is that to break existing grammars?
20:03:32 <eyebloom> Did Simon Marlow's cost centre stack tracing option for GHC make it into the new Haskell platform?
20:04:08 <elliott> it's 7.4
20:04:09 <elliott> so no
20:05:10 <eyebloom> thx
20:11:41 <hpaste> SubtleArray pasted “Going to next line rather than print the next line symbol” at http://hpaste.org/63670
20:12:14 <mauke> SubtleArray: output from what?
20:12:41 <SubtleArray> That function. When I call it, it prints the line with the \n rather than go to the next line as expected.
20:12:47 <SubtleArray> I have no idea why it's doing this.
20:12:48 <reltuk> does a function like this exist in any standard libraries?: \n a -> foldr1 (>=>) (replicate n a)
20:12:56 <rwbarton> use putStrLn
20:12:57 <mauke> SubtleArray: that function doesn't produce output. it returns a string
20:13:12 <JoeyA> :t \n a -> foldr1 (>=>) (replicate n a)
20:13:13 <lambdabot> forall (m :: * -> *) b. (Monad m) => Int -> (b -> m b) -> b -> m b
20:13:30 <JoeyA> :t iterateM
20:13:30 <lambdabot> Not in scope: `iterateM'
20:13:34 <JoeyA> :t iterate
20:13:36 <lambdabot> forall a. (a -> a) -> a -> [a]
20:13:54 <JoeyA> @pl foldr1 (>=>) (replicate n a)
20:13:55 <lambdabot> foldr1 (>=>) (replicate n a)
20:13:55 <SubtleArray> mauke: Right. But do you know why the \n isn't working? Does the string have to be wrapped in something?
20:14:01 <JoeyA> @pl \n a -> foldr1 (>=>) (replicate n a)
20:14:02 <lambdabot> (foldr1 (>=>) .) . replicate
20:14:08 <mauke> SubtleArray: what do you mean by "working"?
20:14:14 <mauke> SubtleArray: a string doesn't do anything. it's just a value
20:14:32 <rwbarton> when you evaluate something in ghci, ghci prints the result
20:14:40 <SubtleArray> mauke: I want \n to move the other part of the string to another line.
20:15:09 <mauke> SubtleArray: you're not thinking clearly
20:15:11 <rwbarton> printing a String produces a format that's valid Haskell syntax for that String
20:15:21 <qpu> > "abc\nxyz" -- see
20:15:22 <lambdabot>   "abc\nxyz"
20:15:26 <mauke> SubtleArray: strings don't print themselves. there's nothing wrong with that string
20:15:36 <mauke> SubtleArray: the problem is in what you do with that string
20:15:50 <qpu> > putStrLn "abc\nxyz"
20:15:51 <lambdabot>   <IO ()>
20:15:54 <qpu> bah
20:16:00 <SubtleArray> mauke: In every language I've used, \n creates new lines. Haskell says \n creates new lines, and yet, in this case, it doesn't.
20:16:11 <mauke> SubtleArray: yes, it does
20:16:18 <rwbarton> "\n" *is* a newline
20:16:19 <SubtleArray> > "hello\nworld"
20:16:20 <lambdabot>   "hello\nworld"
20:16:31 <SubtleArray> > putStr "hello\nworld"
20:16:32 <lambdabot>   <IO ()>
20:16:57 <qpu> SubtleArray: try it in ghci
20:17:12 <rwbarton> Is it so odd that ghci shows you a String in the same format you enter it into ghci?
20:17:33 <rwbarton> putStr or putStrLn is the way to just write the string directly to the terminal.
20:17:49 <qpu> many REPLs work that way: irb/ruby, node/js, chrome/js, etc
20:18:05 <rwbarton> python also
20:18:14 <SubtleArray> qpu: This works in ghci. putStr ("hello\nworld\n") It prints the word hello on one line, and world on another.
20:18:35 <SubtleArray> This is what I'm trying to do in my function.
20:18:55 <mauke> SubtleArray: then you need to use putStr in your function
20:19:23 <rwbarton> or outside your function
20:19:54 <SubtleArray> mauke: That would cause issues with some of the other functions I have since it would change the type to IO, but if that's the only way, I guess I'll have to do that.
20:20:09 <SubtleArray> Thank you for your time.
20:20:23 <mauke> SubtleArray: I still think you're misunderstanding the problem
20:20:43 <SubtleArray> mauke: How so?
20:20:59 <qpu> SubtleArray: it's not the only way... your function can still return a string value with "\n"s and some other function can do the printing
20:21:01 <reltuk> JoeyA: I feel like I write that function a lot...maybe I'm just doing things wrong / weird though
20:21:03 <mauke> SubtleArray: what's the difference between output and return value?
20:22:10 <JoeyA> reltuk: What does it do?  Turn a monadic function (a -> m a) into one iterated a given number of times?
20:22:21 <SubtleArray> mauke: So you're saying the string is acting like a return value, which is why it's not acting like an output, as I want it to?
20:22:27 <mauke> SubtleArray: no
20:22:30 <mauke> strings don't act
20:22:34 <mauke> they're just values
20:22:35 <jmcarthur> SubtleArray: '\n' is just the literal representation for the newline. it's still a newline
20:22:57 <reltuk> JoeyA: yeah...it applies the monadic function n times
20:22:59 <rwbarton> > length "\n"
20:23:00 <lambdabot>   1
20:23:03 <jmcarthur> SubtleArray: so if you return a string containing that, it's just a string containing that. i'm not sure what other interpretation you really want
20:23:13 <jmcarthur> SubtleArray: when you putStr that string, it will do what you want
20:23:20 <jmcarthur> that doesn't mean you have to putStr it immediately
20:23:22 <SubtleArray> jmcarthur: Ah. I see.
20:23:23 <qpu> :t "abc"
20:23:24 <lambdabot> [Char]
20:23:26 <qpu> :t putStr
20:23:27 <lambdabot> String -> IO ()
20:23:56 <SubtleArray> Sorry if I seem irritated at all. Just spend the last hour trying to figure out why this \n wasn't working.
20:24:11 <jmcarthur> it happens
20:24:28 <qpu> SubtleArray: there's a good discussion about separating "pure" code from "IO" code in LYAH, i think
20:25:40 <SubtleArray> qpu: I'll check it out. Thank you.
20:25:47 <qpu> http://learnyouahaskell.com/input-and-output
20:26:02 <reltuk> JoeyA: just now it was a board game where the player re-shuffles their discard pile as late as possible...so drawCards n = iterateM_ drawOneCard n
20:27:19 <JoeyA> reltuk: Might be able to do it replicateM_ in the StateT s m monad.
20:27:23 <JoeyA> do it with*
20:28:20 <JoeyA> drawOneCard would be a StateT action.  As it stands, it looks like you're passing the state from call to call manually.
20:28:49 <wavewave> hi.
20:28:51 <SubtleArray> Problem solved. Just has to wrap the strings in putStr (). Thanks again, folk .
20:29:21 * hackagebot hxournal 0.6.5.0 - A pen notetaking program written in haskell  http://hackage.haskell.org/package/hxournal-0.6.5.0 (IanWooKim)
20:30:36 <reltuk> JoeyA: yeah...good point.  right now it's all explicitly threaded but they'll probably become statet actions eventually
20:48:06 <SubtleArray> I love this IRC... I have almost 100 lines of code done. This wouldn't have been possible without the help I've received here. Many thanks.
20:49:45 <SubtleArray> I *probably* should have picked an easier project to do for my first Haskell project though... Oh well. :D
20:51:52 <JoeyA> SubtleArray: If it's primarily number-crunching and puzzle-solving, you chose the right type of project.
20:52:55 <JoeyA> If it's a networked, concurrent program that needs to run on Windows reliably, not so sure ;-)
20:52:57 <elliott> number crunching is one of the worst newbie projects
20:53:00 <elliott> imho
20:53:07 <JoeyA> well, puzzle-solving, mainly
20:53:41 <SubtleArray> JoeyA: Yeah, there's a lot of pattern matching involved for this project. I'm basically trying to make an app that can compare data sets, and operates through natural language processing.
20:54:25 <SubtleArray> I skipped "Hello World" and went straight into this. Lol
20:54:40 <JoeyA> :-)
20:55:46 <JoeyA> Be sure to learn about the monad-burrito isomorphism restriction.
20:57:15 <JoeyA> yesodweb.com is down
21:16:06 <jtobin> i kid thee not
21:16:15 <jtobin> my girlfriend just came home from work and gave me a valentine
21:16:25 <jtobin> it is a heart-shaped piece of paper saying..
21:16:45 <companion_cube> unsafePerformLove
21:16:46 <jtobin> "mapM_ putStrLn ["Happy Valentine's Day " ++ (if x == 3 then "dear Jared" else "to You") | x <- [1..4]]
21:17:49 <companion_cube> :)
21:18:21 <ion> jtobin: You should ask her why in the world she counts from one.
21:18:42 * jtobin laughs
21:26:22 <wavewave> hi.
21:31:13 <ion> o hai
21:33:27 <wavewave> y
21:37:02 <jameysharp> If you have a GHC-compiled program that runs out of heap, what are your first couple of troubleshooting steps?
21:37:19 <wavewave> look at the code.
21:37:41 <wavewave> space problem has some pattern.
21:38:15 <wavewave> but if I cannot figure out, then profiling.
21:39:09 <jameysharp> my program often takes hours before it finally runs out of heap, so I'm a little terrified of turning on profiling. :-/
21:39:25 <elliott> you don't have to wait for it to run out of heap
21:39:28 <elliott> just profile it using ram
21:39:50 <wavewave> make heap size very small.
21:40:16 <jameysharp> oh, I forgot I can use a truncated copy of the profile. right...
21:41:13 <jameysharp> though my suspicion in this case is it's some particular combination of inputs that blows up, so I assumed I wouldn't see it early. but I do need to actually check.
21:42:12 <wavewave> often comment out some latter part of program helps
21:42:37 <wavewave> to identify whether it is retainer problem..
21:43:36 <wavewave> like lst = [1..1000000]; s = sum lst ; n = length lst
21:44:26 <jameysharp> wavewave: yes, I see where that would be helpful.
21:44:56 <wavewave> so usually two classes, one is retainer class, the other is thunk class.
21:45:07 <wavewave> thunk class means foldl kind of thing.
21:45:43 <wavewave> in that case, identify your accumulator and put some bang or seq..
21:45:47 <jameysharp> to be more specific: my program kicks off ten threads that just loop fetching web pages, and the main thread stashes results in a database. (the full program is too complicated to just post, sadly.)
21:46:35 <jameysharp> fetch results are posted on a channel for the main thread to write out, and the main thread posts new URIs to fetch on another channel for the worker threads to consume.
21:46:59 <wavewave> sounds complicated
21:47:14 <elliott> hackage2 builds! \o/
21:47:22 <wavewave> congrats!
21:48:35 <elliott> and runs! \o/
21:48:40 <wavewave> jameysharp : so your functions share some big states?
21:49:59 <jameysharp> wavewave: shouldn't usually be big, but it's proportional to the number of links on each fetched page.
21:50:35 <jameysharp> although as best I can tell, the last pages fetched before it dies aren't big pages.
21:50:43 <wavewave> identify some states which will be big, then make it as a new type with additional Chunk indirection.
21:50:54 <jameysharp> and stream it?
21:50:59 <wavewave> yes.
21:51:17 <wavewave> so that size of chunk should not be large. .
21:51:24 <jameysharp> there's a thought. I'll see if I can make that work. but I'll try profiling first. :-)
21:51:33 <wavewave> by some checking
21:52:25 <wavewave> by making accessing to chunk limited by some accessor function.
21:52:45 <wavewave> then even profiling is easier..
21:53:01 <jameysharp> oh, how does that make profiling easier?
21:53:02 <wavewave> you can put some debug log for the size of chunk.
21:53:10 <jameysharp> ahhh.
21:53:18 <wavewave> that's one. but for profiling..
21:53:40 <wavewave> you can show things in terms of constructor in profiling graph.
21:53:57 <wavewave> so.. also it identifies things quite well.
21:54:18 <wavewave> you know if all your big types are lists, then you willl see only (:)
21:54:24 <wavewave> that's not very helpful.
21:54:41 <jameysharp> I see. and newtypes don't appear in profiling output at all, right?
21:55:33 <wavewave> I am not sure about newtypes..
21:55:56 <wavewave> anyway... all this kind of things are just what iteratee does.
21:56:22 <wavewave> so.. think about using iteratee from early on..
21:56:22 <jameysharp> true. and now conduits, I guess.
21:56:50 <jameysharp> well, thanks for the suggestions!
21:56:56 <wavewave> there are several similar packages.. I haven't checked conduit yet.
21:57:22 <wavewave> you're welcome! hope that you find the leaking spot!
21:57:29 <jameysharp> me too! :-)
21:59:36 <wavewave> space leak problem needs one deeper level of indirection.
22:00:46 <wavewave> I think that that it needs one further level of indirection is language-independent.
22:01:37 <wavewave> it's like haskell's new and delete problem as an analogy of C++
22:02:14 <wavewave> or you can say 'resource boundary problem'
22:03:41 <wavewave> so iteratee or whatever equivalent is regarded as necessary from the beginning.
22:04:56 <osager> hi i'm learning monad from realworld haskell. could anyone recogmend a small package source code to learn ? as simple and short as possible? thanks
22:05:51 <wavewave> osager: did you understand state monad?
22:05:57 <osager> no
22:06:21 <osager> i want to see how monad is used in real appliactions
22:06:39 <osager> all i know is that it is some kind of abstraction
22:06:39 <wavewave> I think maybe, reader, write, state monad is a direction of understanding.
22:07:03 <ion> @where typeclassopedia
22:07:03 <lambdabot> http://www.haskell.org/haskellwiki/Typeclassopedia
22:07:14 <wavewave> that's very straightforward application, isn't it?
22:07:14 <ion> That’s a good document, too.
22:07:30 <wavewave> osager: i mean, maybe, reader, write, state..
22:07:35 <ion> And be sure to avoid everything that calls itself a “monad tutorial”. :-)
22:08:04 <osager> i only learn from realworld haskell and the standford class tutorial
22:08:16 <ion> @where lyah
22:08:17 <lambdabot> http://www.learnyouahaskell.com/
22:08:19 <osager> but it's really not easy
22:08:27 <ion> I’d suggest reading LYAH.
22:08:29 <wavewave> osager: as for application, many realworld monad applications are simply kind of extension of those..
22:09:05 <wavewave> once you understand state... then later, you can try understanding error and continuation.
22:09:12 <wavewave> then coroutine.
22:09:17 <elliott> osager: monad is just an abstract interface
22:09:18 <wavewave> then iteratee
22:09:23 <elliott> there's nothing to learn per se
22:09:27 <elliott> there's no short "monad code example"
22:09:33 <elliott> there are just examples of monads that are useful
22:09:51 <wavewave> that's right!
22:10:10 <osager> what are the equivelent of monad in other languages ? c++ for example
22:10:13 <elliott> nothing
22:10:26 <wavewave> monad has return and >>=, and it obeys some rules.. that's it in abstract way.
22:10:27 <elliott> C++ programmers don't use the "monad" interface
22:10:37 <elliott> (though they use types which happen to be monads)
22:10:44 <elliott> (and they might have cleaner code if they could exploit this)
22:10:53 <elliott> C++ is an especially bad example because the monad interface basically relies on higher-order functions.
22:11:01 <elliott> what are you trying to understand? it's not clear what you're actually having troubles with
22:11:08 <elliott> if you've set "learn monads" for yourself as a goal, don't
22:11:28 <elliott> it's pointless; there's really nothing to learn -- use the concrete examples and you'll become comfortable with the abstract interface
22:11:43 <osager> no, i'm learning the haskell language hoping to do some real world programming
22:12:44 <osager> i would especially like to use it as a handy scripting language in system manangement and scientific computing
22:12:47 <elliott> ok
22:12:49 <wavewave> osager: so i gave you quite practical advice. maybe, reader, writer, state, error, continuation, coroutine, iteratee..
22:12:53 <elliott> then don't try and learn "monads"
22:13:04 <elliott> just use haskell and be happy :P
22:13:05 <osager> ok thank you wavewave
22:13:15 <osager> really ?
22:13:25 <mikeplus64> don't forget IO
22:13:46 <wavewave> I deliberately miss IO. ;-P
22:14:01 <elliott> osager: yes
22:14:12 <elliott> it's like thinking you can't write Java because you haven't "learned visitor pattern" :)
22:14:36 <wavewave> because IO interferes with some good understanding of the above monads.
22:14:52 <osager> ok; i never know i can survive in haskell without monad
22:14:59 <mikeplus64> Monad itself is just a typeclass, right?
22:15:03 <osager> ok
22:15:14 <elliott> mikeplus64: yep
22:15:16 <mikeplus64> with some very useful instances
22:15:27 <elliott> osager: well, you'll certainly *use* monads, through their interface
22:15:29 <wavewave> in the middle, you will get to understanding of IO very naturally.
22:15:36 <mikeplus64> ok, good to know
22:15:40 <elliott> but you only need to understand it insofar as it lets you use a concrete thing like StateT
22:15:54 <elliott> when you use "do" notation to write IO programs, that's using the Monad interface -- but you don't really have to care
22:16:12 <osager> ok
22:16:15 <osager> thanks everyone
22:16:29 <osager> it's a real helpful place here
22:17:14 <wavewave> by the way, from continuation, coroutine, iteratee... it's advanced topic. so don't push too hard on that ;-)
22:17:48 <wavewave> from understanding of State monad... you had better play with some parsers..
22:17:53 <hpaste> reltuk pasted “two conditional shuffles...” at http://hpaste.org/63671
22:17:54 <johnny86> any big project made in haskell lately?
22:18:01 <wavewave> play with parsec.
22:18:25 <reltuk> anyone have style preference comments on that hpaste?
22:18:26 <mikeplus64> johnny86: yesod?
22:18:38 <elliott> johnny86: define big. but yes.
22:18:47 <wavewave> johnny86: my hxournal can be counted as big? hehe.
22:19:07 <elliott> reltuk: pretty sure you can define shuffleBeforeDrawM in terms of shuffleBeforeDraw
22:19:10 <elliott> without all that duplication
22:19:28 <mandaya> anyone know how to convert a lazy bytestring into a regular bytestring?
22:19:55 <reltuk> elliott: oh yeah, most definitely...it's more a question of whether I would rather be in StateT for this kind of computation in general
22:19:56 <johnny86> how does yesod compare with other frameworks?
22:20:17 <reltuk> elliott: there would only be one of these in the final program
22:20:25 <johnny86> i mean benchmark-wise :P
22:21:36 <wavewave> mandaya, use toChunks
22:22:07 <wavewave> mandaya, and concat.
22:22:11 <elliott> reltuk: well, it depends on the rest of your code
22:22:23 <elliott> reltuk: even if I'm using StateT everywhere I would define *M in terms of the non-M one
22:22:27 <elliott> because the M definition is ugly :P
22:23:59 <wavewave> mandaya: does it answer your question??
22:27:45 <reltuk> elliott: semi-reasonable definition of M in terms of non-M?  :  get >>= ((shuffleBeforeDraw discardL drawL) >=> put)
22:27:46 <reltuk>  
22:27:48 <mandaya> wavewave: ok, I was hoping there was a more direct approach
22:28:31 <mandaya> wavewave: Just trying to turn this bytestring into a cstring so I can pass it into some C code, *sigh*
22:28:42 <wavewave> concat . toChunks
22:28:52 <reltuk> i need to read more haskell code...i have no sense of good style =/.
22:30:56 <elliott> reltuk: well one of those ()s is redundant
22:31:10 <elliott> reltuk: but it seems ok to me
22:31:14 <elliott> I think the other () might be redundant too but I'm not sure
22:31:31 <mandaya> is there any reason the lazy bytestring api can't provide a useAsCString function? Seems like once you're in IO, it shouldn't be a problem.
22:31:34 <wavewave> http://hackage.haskell.org/trac/ghc/wiki/Commentary/CodingStyle
22:31:52 <reltuk> good call.  outmost one is necessary :-)
22:31:59 <wavewave> mandaya: it should not be..
22:32:17 <elliott> mandaya: well, it'd force the whole string
22:32:50 <mandaya> elliot: right, but isn't that reasonable once you're in IO?
22:33:03 <ddarius> mandaya: A lazy ByteString is not a contiguous block of memory.  It is a linked list of strict ByteStrings which are.
22:33:16 <ion> If the lazy bytestring consists of multiple chunks you can’t just pass it to C as a single char*.
22:33:25 <elliott> mandaya: I don't know what you mean by that.
22:33:28 <mandaya> ahh, ok, that makes more sense
22:34:14 <mandaya> thanks
22:34:20 <ion> I don’t see BS.unsafeUseAsCString ((BS.concat . BSL.toChunks) bs) as especially bad.
22:35:03 <osa1> can anyone help me? I can't install snap with cabal. here are my logs: http://paste.pocoo.org/show/550671/ ghc version 7.0.4
22:35:04 <wavewave> ion: that's actually very good. it describes what it does denotationally
22:35:28 <wavewave> ion: ahh.. your point is 'unsafe'?
22:35:50 <ddarius> His point is that it is only three tokens more.
22:36:10 <ion> No, that wasn’t my point. (Change to the safe version if the C code mutates it.)
22:36:40 <mandaya> no, the  c code treats it as data to pipe across the network
22:36:49 <mandaya> it doesn't even inspect it
22:37:08 <elliott> @hoogle (<<)
22:37:12 <lambdabot> Control.Category (<<<) :: Category cat => cat b c -> cat a b -> cat a c
22:37:12 <lambdabot> Control.Arrow (<<<) :: Category cat => cat b c -> cat a b -> cat a c
22:37:12 <lambdabot> Control.Arrow (<<^) :: Arrow a => a c d -> (b -> c) -> a b d
22:37:20 <elliott> wait, where /is/ (<<)?
22:37:27 <mandaya> I was just wondering why the lazy api doesn't even export any CString functions
22:37:34 <mandaya> unsafe or safe
22:37:54 <wavewave> mandaya: because strict version exists.
22:38:24 <ddarius> wavewave: That's not an explanation.  A strict version exists for all the functions on lazy ByteStrings.
22:38:28 <wavewave> before changing them to strict chunks, conversion doesn't make sense at all.
22:39:03 <mandaya> per the earlier explanation, aren't they already strict chunks? (the part that's been forced anyway)
22:39:23 <wavewave> so you explicitly need lazy-to-strict conversion, then use strict version after that.
22:39:25 <mandaya> though I guess that goes back to elliot's point about having to force the whole string
22:39:48 <ddarius> Lazy ByteString is essentially [Strict.ByteString]
22:40:08 <ion> mandaya: You could always use toChunks and iterate over them in IO, using (unsafe)UseAsCString with your C function for each one.
22:40:20 <ion> If it just sends it over the network.
22:40:21 <ddarius> Which would be the way to go if you wanted streaming behavior.
22:41:40 <mandaya> ion: I don't see the unsafe version
22:41:47 <mandaya> @hoogle unsafeUseAsCString
22:41:48 <lambdabot> Data.ByteString.Unsafe unsafeUseAsCString :: ByteString -> (CString -> IO a) -> IO a
22:41:48 <lambdabot> Data.ByteString.Unsafe unsafeUseAsCStringLen :: ByteString -> (CStringLen -> IO a) -> IO a
22:41:50 <wavewave> I think this choice of library design is quite deliberate.
22:42:09 <elliott> mandaya: On the individual ByteString chunks.
22:42:43 <wavewave> if you have some convenience api for lazy to cstring conversion, then you will easily encounter some space leak bug which is quite hard to find..
22:43:01 <wavewave> because lazy and strict share almost identical namespace.
22:43:43 <mandaya> elliot: I don't follow
22:43:54 <mandaya> oh, you mean don't concat the chunks?
22:44:50 <wavewave> yeah. don't concat in most cases.. if you do need it, you had better start with strict bytestring from the beginning.
22:45:01 <mandaya> problem is I need to put them together before putting it through the network
22:45:07 <elliott> mandaya: why?
22:45:09 <mandaya> yea, I would have prefered that
22:45:20 <mandaya> it's being put into a JSON object
22:45:42 <mandaya> and then stuck into a database
22:45:59 <mandaya> (eugh)
22:46:11 <ddarius> So the next question might be, why don't you have a strict bytestring to begin with?
22:46:31 <mandaya> because the function I get the bytestring back from uses the lazy bytestring api
22:47:11 <mandaya> library api, not my own code
22:47:21 <wavewave> mandaya ; then use concat ;-)
22:47:30 <mandaya> yep :(
22:47:34 <ion> …or iterate over the chunks
22:47:45 <elliott> ion: <mandaya> problem is I need to put them together before putting it through the network
22:47:49 <wavewave> i don't understand what would be mental barrier for that..
22:48:10 <mandaya> wavewave: none, people are just suggesting keeping them as chunks instead of concating
22:48:12 <ion> ah
22:48:58 <wavewave> lazy bytestring is useful simply because it is chunked.. but you know that chunk behavior is unnecessary and you have to use it because of some api, then no problem.
22:52:37 <ketil> I'm trying to use a BoundedChan to do buffered parallel processing in a pipeline.  However, I'm unable to see how to terminate - there doesn't seem to be any concept of a "closed" channel, so getChanContents just hangs indefinitely?
22:53:40 <ddarius> ketil: There isn't a concept of a closed channel.  You could build one on top of that though.
22:54:27 <ketil> I guess I should do refcounting in a separate MVar?
22:55:42 <ddarius> ketil: Why do you need to do refcounting?
22:56:16 <ddarius> You want it to "close" automatically when the write end is not live?
22:57:36 <wavewave> ketil: probably it's related laziness of result list of getChanContents?
22:58:10 <Sgeo> > let x = x in [1,x]
22:58:14 <ddarius> wavewave: No, there is simply no concept of a closed channel.  getChanContents always returns an infinite list.
22:58:15 <lambdabot>   mueval: ExitFailure 1
22:58:15 <lambdabot>  mueval: Prelude.undefined
22:58:18 <Sgeo> Hrm
22:58:23 <Sgeo> > let x = x in 1:x
22:58:25 <startling> is there an easy way to do "not a digit" in parsec?
22:58:28 <lambdabot>   mueval-core: Time limit exceeded
22:58:31 <Sgeo> Hmmmm
22:58:35 <ion> > let x = x in [0,1,x]
22:58:39 <lambdabot>   mueval-core: Time limit exceeded
22:58:47 <mandaya> if I pass a stable ptr into C code, then pass that ptr back later into haskell, will it automatically become a foreign ptr, or can I preserve the fact that its stable?
22:58:50 <Sgeo> Why is it not printing [0,1,
22:58:51 <Sgeo> ?
22:58:56 <wavewave> many (not isDigit)
22:59:07 <ddarius> mandaya: It is what it is, it's not going to change.
22:59:21 <startling> wavewave: thanks!
22:59:22 * hackagebot packdeps 0.3.0 - Check your cabal packages for lagging dependencies.  http://hackage.haskell.org/package/packdeps-0.3.0 (MichaelSnoyman)
22:59:23 <mandaya> ddarius: different issue
22:59:32 <ion> > let x = x in [0..100] ++ [x]
22:59:34 <ddarius> Sgeo: lambdabot needs to fill a buffer before it sends a response.
22:59:35 <lambdabot>   mueval-core: Time limit exceeded
22:59:46 <ion> > let x = x in [0..10000] ++ [x]
22:59:46 <mandaya> ddarius: the bytestring stuff is done, now I'm working on marshalling types
22:59:48 <wavewave> startling : use combinators creatively ;-)
22:59:50 <lambdabot>   mueval-core: Time limit exceeded
23:00:00 <ddarius> mandaya: I didn't say anything about bytestrings.
23:00:10 <mandaya> ddarius: ahh, sorry
23:00:12 <ddarius> mandaya: A StablePtr is a StablePtr it's not going to change types.
23:00:22 <mandaya> ddarius: ok, thanks
23:00:44 <startling> is there a shorter way to concatenate two parsers than do notation?
23:00:55 <mandaya> ddarius: does that mean the C-type will be different? or is it best to treat it as a void* in C?
23:01:00 <wavewave> startling : <*>
23:01:07 <ion> startling: What does your code look like in do notation?
23:01:32 <wavewave> startling : parser1 <*> parser2   if parser1's result is a function applied to parser2 .
23:01:34 <mandaya> (guess I don't fully understand the marshalling/interaction part of the ffi)
23:01:50 <wavewave> startling : parser1 *> parser2  if you need only result of parser2
23:01:51 <elliott> Man, if Hackage2 is the second system, I don't want to see how ugly Hackage1's code is.
23:01:53 <ddarius> mandaya: It's an opaque object as far a C is concerned.
23:01:58 <wavewave> <* for opposite.
23:02:13 <mandaya> ddarius: ok, thanks
23:02:14 <wavewave> startling : study Applicative
23:02:34 <ddarius> mandaya: void * would probably be the appropriate type to use but it doesn't really matter what (pointer) type you use since the only valid thing to do with it is pass it back to a Haskell function.
23:02:46 <mandaya> right
23:02:50 <wavewave> also    f <$> parser1   if you want a result of f (x)  where x is the result of parser1
23:02:59 <wavewave> and f is not a parser.
23:03:43 <wavewave> startling ; if  you don't want to mess up with Applicative, of course you can use >>=, or >> as Monad.
23:04:24 <startling> wavewave: I'd like the results of both parsers as one string, I mean.
23:04:35 <wavewave> (++) <$> parser1 <*> parser2
23:04:52 <startling> wavewave: genius, thanks. I'll look into applicative
23:05:08 <wavewave> startling : no problem ;-)
23:05:21 <ion> What wavewave said would correspond to ‘do a <- parser1; b <- parser1; return (a ++ b)’.
23:05:27 <ion> b <- parser2 that is.
23:05:47 <mandaya> gotta love applicative notation :)
23:05:50 <startling> ion: yeah, that's exactly what I have now. ;)
23:06:04 <wavewave> using Applicative is really fun..
23:06:17 <wavewave> it's quite addictive.
23:06:33 <mandaya> I'm always so happy when I can transform a bunch of do notation stuff into a point-free applicative line
23:07:00 <wavewave> you will find yourself to make applicative form even if do notation is more clear.;-P
23:09:17 <wavewave> have to sleep now.. see ya
23:09:53 <ion> “fa <*> xa” corresponds to “do f <- fa; x <- xa; return (f x)”.
23:09:55 <ion> @type (<*>)
23:10:08 <lambdabot> forall (f :: * -> *) a b. (Applicative f) => f (a -> b) -> f a -> f b
23:10:35 <ion> “return (++) <*> parser1 <*> parser2” corresponds to “do a <- return (++); b <- parser1; c <- parser2; return (a b c)”.
23:10:47 <ketil> ddarius: refcounting for multiple writers.  When no more writers exist, I can safely drain the channel and exit.
23:10:50 <ion> And “return f <*> …” is equivalent to “f <$> …”
23:11:28 <ketil> In my case, there is exactly one reader and writer per channel, so no worries - I can use an MVar Bool.
23:11:50 <ketil> Looks like it works - though I'm never quite comfortable with concurrent programs, even in Haskell.
23:15:16 <ChickenNoodle> I'm having trouble declaring a type - is someone willing to lend a hand?
23:15:44 <elliott> go ahead
23:16:35 <ChickenNoodle> I've got:
23:16:35 <ChickenNoodle>  
23:16:35 <ChickenNoodle> > data Token         = Token Int | Token Char     deriving Show
23:16:35 <ChickenNoodle> > type Expression    = [Token]
23:16:36 <lambdabot>   <no location info>: parse error on input `data'
23:16:37 <lambdabot>   can't find file: L.hs
23:17:24 <ChickenNoodle> When I attempt to write a function tokenizer ('+':ns) it blows up
23:17:27 <ddarius> ChickenNoodle: Use hpaste.org in the future.
23:17:34 <ChickenNoodle> thanks ddarius, sorry about that.
23:17:43 <ddarius> ChickenNoodle: What type would Token be if you made that declaration?
23:17:46 <elliott> data Token         = Token Int | Token Char     deriving Show
23:17:49 <elliott> you can't use the same name for two constructors
23:18:11 <mandaya> so my type creation code produces IO (Type). Will that get correctly evaluated when called by a C function?
23:18:12 <ChickenNoodle> And I pasted from the wrong file to boot - real version has token on ly on the left hand side
23:19:08 <startling> is there something nicer than `return . function`? I find myself doing it a lot.
23:19:43 <ion> <$> or fmap probably.
23:19:53 <ion> You’ll need to paste a code example.
23:20:32 <elliott> awesome, this file has something like 10,000 lines of GHC errors
23:21:10 <hpaste> ChickenNoodle pasted “Couldn't match expected type `Token' with actual type `Char' ” at http://hpaste.org/63673
23:21:31 <mandaya> elliott: o.O
23:21:54 <startling> Iion: an example: `identifier = (:) <$> starting <*> others <?> "identifier" >>= return . Tokens.Symbol`
23:21:57 <elliott> (because I yanked out a module it uses extensively)
23:22:16 <elliott> startling: (m >>= return . f) === fmap f m === f <$> m
23:22:31 <aszlig> hm, is it just a local problem, or is hackage currently down?
23:22:34 <elliott> identifier = Tokens.Symbol <$> ((:) <$> starting <*> others <?> "identifier")
23:22:39 <elliott> aszlig: wfm
23:23:14 <ion> And perhaps a bit nicer way to put the same thing: identifier = Tokens.Symbol <$> liftA2 (:) starting others <?> "identifier"
23:23:49 <ion> @src liftA2
23:23:50 <lambdabot> liftA2 f a b = f <$> a <*> b
23:23:53 <Enigmagic> hackage is down for me
23:24:01 <aszlig> elliott: thanks, so it seems to be a local problem, thanks, i'll go use a proxy
23:24:15 <elliott> oh hmm
23:24:17 <elliott> now it's down
23:24:19 <elliott> sorry
23:24:23 <aszlig> ah
23:24:23 <Enigmagic> Connecting to hackage.haskell.org|69.30.63.204|:80... failed: Operation timed out.
23:24:25 <aszlig> okay
23:25:04 <mandaya> :( that sucks... hope I have everything I need open...
23:25:32 <ChickenNoodle> I really can't figure this out
23:25:44 <elliott> ChickenNoodle: can you hpaste the broken code?
23:25:50 <ChickenNoodle> I did above
23:25:54 <aszlig> okay, time to start a mirror of hackage as soon as it's back up
23:25:55 <ChickenNoodle> through hpaste
23:25:59 <startling> elliott: thanks, I didn't think of either fmap or the <$>
23:26:15 <startling> ion: thanks, yeah, that's nicer.
23:28:01 <elliott> Wow, Hackage2 mixes logic and HTML so much :(
23:28:07 <NihilistDandy> :(
23:28:51 <elliott> Maybe we should just skip straight to Hackage3 :P
23:30:28 <ChickenNoodle> I think GHC is just being mean because it's valentine's day
23:31:03 <elliott> ChickenNoodle: sorry, I didn't see your hpaste
23:31:18 <elliott> > data Token 		= Int | Char 	deriving Show
23:31:19 <lambdabot>   <no location info>: parse error on input `data'
23:31:27 <elliott> ChickenNoodle: this declares Int :: Token, Char :: Token
23:31:33 <elliott> the names have no relation to the types of the same name
23:31:41 <elliott> you're just creating two constructors for Token called Int and Char with no parameters
23:31:54 <NihilistDandy> elliott: Hackage version approaches sqrt(5) asymptotically, obviously
23:32:32 <ChickenNoodle> What is the syntax then for saying that I want a type called Token which can take either Char or Int values?
23:33:20 <mandaya> ChickenNoodle: what are you trying to accomplish with that type?
23:33:20 <merijn> ChickenNoodle: "data Token = Foo Int | Bar Char" (this data type already exists, though. It's called Either)
23:33:57 <elliott> ChickenNoodle: You can't make any Int also a Token.
23:34:00 <elliott> Every value has one type in Haskell.
23:34:11 <elliott> You can declare a type with two constructors, one taking an Int and the other taking a Char, however.
23:34:13 <merijn> "data Either a b = Left a | Right b"
23:34:15 <elliott> ChickenNoodle: Have you read Learn You a Haskell?
23:34:28 <elliott> It explains basics like data-type declaration very well.
23:34:49 <elliott> http://learnyouahaskell.com/making-our-own-types-and-typeclasses
23:34:52 <ChickenNoodle> I've looked through it but I'm trying to just get the basics through for a programming paradigms course. I'm simultaneously in a Haskell course but they're touching on different stuff in different order and I'm geting relaly cnofused
23:34:57 <ChickenNoodle> I read that one, elliott. Several times.
23:35:13 <NihilistDandy> I love how straightforward the Data.Either source is
23:35:56 <mandaya> NihilistDandy: I feel like most of prelude and base is that way. I learned a lot just taking occasional peeks.,
23:36:03 <elliott> ChickenNoodle: Well, in this case, the applicable parts are: "data means that we're defining a new data type. The part before the = denotes the type, which is Bool. The parts after the = are value constructors. They specify the different values that this type can have. The | is read as or. So we can read this as: the Bool type can have a value of True or False. Both the type name and the value constructors have to be capital cased. [...] Now what'
23:36:03 <elliott> s this? Think of it like this. The Circle value constructor has three fields, which take floats. So when we write a value constructor, we can optionally add some types after it and those types define the values it will contain. Here, the first two fields are the coordinates of its center, the third one its radius. The Rectangle value constructor has four fields which accept floats. The first two are the coordinates to its upper left corner and the
23:36:04 <elliott>  second two are coordinates to its lower right one. Now when I say fields, I actually mean parameters. Value constructors are actually functions that ultimately return a value of a data type. Let's take a look at the type signatures for these two value constructors."
23:36:05 <merijn> ChickenNoodle: Ah, so you're learning programming in an imperative language in parallel with Haskell?
23:36:09 <elliott> Oof, that split up.
23:36:52 <mandaya> merijn: I think he means that he's getting haskell as a FP language from one class, and haskell as haskell from another
23:37:02 <NihilistDandy> mandaya: Agreed. Though some of the Prelude definitely could use some work. Though I should be careful or I'll be the nth person to make their own damn prelude
23:37:11 <ChickenNoodle> merijn, no. I've been programming in Java for several years and am actually doing quite well with the Haskell course, but the course this is for simply touches briefly on different paradigms including imperative and functional without getting into too much syntactic detail. Supposedly we're not supposed to need to know syntax but the homeworks indicate otherwise.
23:37:27 <merijn> ChickenNoodle: Ah
23:37:40 <mandaya> huh, that's interesting. The paradigms course at my school has you work on a project in each language.
23:37:48 <NihilistDandy> On a stylistic note, I'd just like to say that the use of the word Prelude in Haskell is vastly more pleasant than OCaml's use of Pervasives. It sounds friendlier :D
23:37:56 <ChickenNoodle> Elliott, the program I had with that is that each of those things is specifying the values. Either True or False, either a Circle or a Rectangle. Whereas here, I want any Char or any Int. Here is where I'm confused.
23:38:18 <elliott> ChickenNoodle: Well, that's just not possible.
23:38:19 <elliott> You can have
23:38:25 <elliott> data Token = IntToken Int | CharToken Char
23:38:30 <merijn> elliott: Depends, I think he really just wants Either :p
23:38:34 <NihilistDandy> mandaya: What languages do you use in the class?
23:38:36 <elliott> which corresponds to "So when we write a value constructor, we can optionally add some types after it and those types define the values it will contain."
23:38:46 <elliott> merijn: I doubt that. Either is usually more confusing than an algebraic data type.
23:39:00 <ChickenNoodle> Mandaya: I would've very much preferred thatl evel of focus. I can appreciate the professor's approach by having us work the same problems in multiple languages from multiple paradigms per week, but the lectures and resources from the class are not adequate for us to provide the detailed solutions he seems to be expecting.
23:39:08 <merijn> elliott: Well, your example is really just a restricted Either, isn't it?
23:39:34 <mandaya> NihilistDandy: I never had a chance to take it personally. I know they cover haskell, and a wide swath of other languages. Then they have the students go research and learn a new language for the final project and present on it.
23:39:40 <elliott> merijn: Yes.
23:39:45 <elliott> merijn: Now say you want a Double token too.
23:39:58 <elliott> Do you program all your data types up with functor combinators and Fix? :p
23:40:11 <elliott> (Not that such an approach is necessarily a bad idea, but Haskell isn't exactly tuned for it.)
23:40:28 <ChickenNoodle> How can a Shape refer to either a Circle or a Rectangle if a Token cannot refer to either a Char or an Int? This is I think the fundamental confusion
23:40:42 <NihilistDandy> mandaya: Sounds fun. It's basically all imperative at my school, but the PL class is OCaml. I kind of wish there were more advanced type theory options here
23:41:01 <ChickenNoodle> NihilistDandy: I had the same complaint about my undergrad institution
23:41:08 <mandaya> NihilistDandy: mostly the same here, except for the PL course, and this paradigms course.
23:41:11 <hpaste> merijn pasted “Either example” at http://hpaste.org/63675
23:41:30 <merijn> ChickenNoodle: Take a look at the paste, is that sort of what you're looking for?
23:41:32 <elliott> ChickenNoodle: It doesn't.
23:41:37 <elliott> ChickenNoodle: Circle and Rectangle are constructors.
23:41:39 <elliott> They're not types in themselves.
23:41:43 <elliott> When you say
23:41:48 <mandaya> NihilistDandy: I'm giving talks on XMonad and Haskell (separately) in a couple weeks so maybe I'll make a few additional converts
23:41:48 <elliott> data Foo = Circle ... | Rectangle ...
23:41:54 <elliott> you're saying "Circle, given some parameters, is a Foo"
23:41:58 <elliott> and "Rectangle, given some parameters, is a Foo"
23:42:07 <mandaya> not holding my breadth though
23:42:08 <elliott> That is, "Circle" is a function taking a bunch of parameters and returning a Foo: a constructor.
23:42:09 <NihilistDandy> mandaya: Sweet :D
23:42:12 <mandaya> *breath
23:42:29 <elliott> ChickenNoodle: So when you say "data Token = Int | Char", you're saying that Int is a Foo. That is, quite literally: the expression "Int" has the type "Foo".
23:42:32 <elliott> Which is clearly not what you want.
23:42:32 <merijn> ChickenNoodle: To translate to Java, the Circle/Rectangle constructors create values (instances) of the type (class) Foo
23:42:41 <ChickenNoodle> I need to get my head out of Java.  think what you said above is more what I was thinking, data Token = IntToken Int | CharToken Char
23:42:55 <ChickenNoodle> With a failure to communicate that to the interpreter, obviously :P
23:43:02 <merijn> ChickenNoodle: See also this more general example:  http://hpaste.org/63675
23:43:06 <ChickenNoodle> Marijn, thanks for the paste. I don't know that I entirely understand it.
23:43:19 <mrcarrot> one thing i find strange: xmobar is taking about the same much memory as the whole xmonad
23:43:22 <ChickenNoodle> merijn*. Boy am I tired
23:44:18 * elliott really doesn't think ChickenNoodle wants Either here.
23:44:19 <merijn> ChickenNoodle: The type "Either" is a general type for having two alternatives. It is essentially the same as the "data Token = IntToken Int | CharToken Char", but implemented using generics (I'm assuming you know those from Java)
23:44:30 <mandaya> mrcarrot: I dropped xmobar a while back in favor of the gtk applet. Eventually I'll get around to writing conky scripts....
23:44:34 <merijn> ChickenNoodle: But yeah, ignore that and use the Token example :p
23:44:34 <ChickenNoodle> elliott: I don't think I do either but I am interested in learning about it :P
23:45:00 <ChickenNoodle> merijn: Interface or abstract class?
23:45:02 <elliott> I bet nobody would have this constructor vs. type confusion if we used GADT syntax.
23:45:12 <elliott> (OOP metaphors never work...)
23:45:39 <mandaya> ChickenNoodle: typeclasses are closest to interfaces...sorta. Better to stop thinking in terms of the OOP terminology
23:45:44 <merijn> ChickenNoodle: There's not really a sensible comparison with either
23:45:58 <ChickenNoodle> Mandaya, I agree. Was trying to get to the heart of merijn's analogy, however. Thank you both
23:46:35 <merijn> ChickenNoodle: Basically the type Either is the type for "values that are either type A or type B", the constructors tell you which the actual value is
23:46:40 <mandaya> oh whoops, just realized merijn was *not* talking about type classes, but rather concrete types
23:46:45 <mandaya> disregard my earlier comment
23:48:17 <ChickenNoodle> elliott: Your line from above has gotten me loading properly, and I'm using the constructor in the return of my function so that '+' is treated as a token rather than a Char because it doesn't seem to be inferring, but now on my console output I am simply getting the Constructor call rather than the value. Is that expected?
23:48:19 <merijn> ChickenNoodle: The foo function uses pattern matching on the Left and Right constructor to check whether the value it gets is type A or type B. In my example both call show, but the Left and Right cases could have differing code (to deal with the fact that one works on type A and the other on type B). In this case A and B were set to Int and Char by the type signature I gave
23:48:38 <merijn> ChickenNoodle: Can you hpaste the code?
23:48:48 <merijn> (plus output!)
23:49:05 <mauke> ChickenNoodle: "the Constructor call"?
23:49:38 <mandaya> I suspect he means he's getting Foo 5 instead of 5
23:49:45 <elliott> ChickenNoodle: You will see the constructor and the value in your output, yes.
23:49:46 <mauke> but that *is* the value
23:49:50 <ChickenNoodle> mandaya, exactly
23:49:53 <elliott> ChickenNoodle: GHCi shows you values as you would enter them in a program.
23:50:09 <mandaya> mauke: exactly, now to explain that to him :)
23:50:11 <elliott> You seem to be wanting Token to be a "subtype" of Char and Int, which is completely disconnected from Haskell's data types.
23:50:17 <elliott> Everything's constructors.
23:50:24 <mauke> ChickenNoodle: '+' is a Char. nothing you do will treat is a Token
23:50:24 * ddarius wishes people wouldn't say that.
23:50:42 <mauke> ddarius: what do you mean?
23:50:49 <merijn> ChickenNoodle: Well yes. The value of a Token is "IntToken 5" or "CharToken '+'"
23:50:50 <ddarius> GHCi uses Show.  The derived Show instance uses a format similar to the format that you would use to enter the value.
23:51:03 <ChickenNoodle> Just to kind of set the record straight, I'm female. And elliott, I'm okay with the constructors thing. I'm slowly getting more comfortable with functional languages. However I have seen some objects simply output their values.
23:51:08 <ChickenNoodle> er... types?
23:51:09 <ChickenNoodle> data?
23:51:12 <mandaya> ChickenNoodle: I'm gonna assume token is declared as "data Token = Foo Int | Bar Char"
23:51:13 <ChickenNoodle> thingies.
23:51:15 <merijn> ChickenNoodle: If you want to get the 5/'+' "out" of the Token, you need use pattern matching
23:51:41 <mauke> ChickenNoodle: all values "output" their values
23:51:45 <mandaya> ChickenNoodle: So when you get out a token, you'll either have a Foo number or a Bar character
23:51:52 <ChickenNoodle> The hardest part about this is the assignment is so vague and without sample I/O
23:51:58 <elliott> ChickenNoodle: Well, you can think of 42 as a constructor of Int.
23:52:08 <elliott> ChickenNoodle: data Int = ... | -1 | 0 | 1 | 2 | ...
23:52:08 <Mike___> hello, can anyone tell me how to print a specific ascii char from the ascii table from its decimal code?
23:52:13 <elliott> ChickenNoodle: data Char = 'a' | 'b' | 'c' | ...
23:52:16 <elliott> Everything outputs its value.
23:52:21 <elliott> (When entered in GHCi.)
23:52:31 <ion> mike: chr or toEnum.
23:52:36 <Mike___> thankyou
23:52:37 <ChickenNoodle> fair enoug elliott. I suppose I'm hoping to avoid enumerating all valid tokens for this assignment, however ;)
23:52:51 <mandaya> ChickenNoodle: so if you want to get at the number or character itself, you'll have to use pattern matching
23:53:02 <ChickenNoodle> mandaya: in that case I'd simply be outputting a string again, yes?
23:53:05 <mauke> ChickenNoodle: well, Int and Char are already defined for you
23:53:18 <hpaste> merijn pasted “Token” at http://hpaste.org/63676
23:53:34 <ChickenNoodle> mauke: The beast of it is I don't want /all/ chars. Only alphanumeric and select punctuation
23:53:36 <mandaya> ChickenNoodle: not quite, it just gives you access to the Char or Int as a value in code
23:54:05 <mauke> ChickenNoodle: hmm, I wouldn't encode that in a type
23:54:12 <mauke> too complicated
23:54:28 <ChickenNoodle> which is why I'm not trying to, but instead dealing with bad characters in the functions
23:54:30 <mandaya> ChickenNoodle, can you hpaste what you have now? It's easier to explain by referring to what you already have
23:54:40 <ChickenNoodle> mandaya, trying to but getting distracted. Sorry, one moment.
23:55:08 <mandaya> No problem :)
23:55:33 <elliott> ChickenNoodle: If you don't allow the construction of invalid tokens, you don't have to handle them.
23:55:43 <elliott> mkCharToken c | isOK c = CharToken c | otherwise = error "nope"
23:56:02 <ChickenNoodle> elliott: I think that's getting into territory beyond the scope of this assignment
23:56:28 <erus`> is forall the same as just no constraints, or is there magic going on?
23:56:38 <mandaya> I agree, I doubt you need much more than an isValid predicate
23:56:47 <Mike___> I noticed something, the print of an ascii char from the extended table is diffrent in GHCi from what it is from example when compilling a program in C
23:56:53 <hpaste> ChickenNoodle pasted “[CharToken '+']” at http://hpaste.org/63677
23:57:09 <mauke> erus`: depends on how it's used
23:57:18 <ion> What’s an ASCII char from “the extended table”? Do you mean non-ASCII characters?
23:57:29 <mauke> Mike___: there is no "extended table"
23:57:34 <Mike___> extended table
23:57:37 <mauke> Mike___: you can't compile a program "in C"
23:57:40 <Mike___> extended ascii codes
23:57:44 <mauke> Mike___: there is no "extended table"
23:57:47 <mauke> Mike___: there is no "extended ascii"
23:57:55 <Mike___> http://www.asciitable.com/
23:58:01 <mauke> Mike___: that site is shit
23:58:02 <Mike___> it says extended ascii codes there
23:58:02 <Mike___> -.-
23:58:08 <merijn> Mike___: ASCII has no extended codes, there are encodings that use the upper space of ASCII, but which value you get is locale/encoding specific
23:58:09 <ion> That page is lying to you.
23:58:10 <Mike___> its the best I found
23:58:18 <mauke> Mike___: how did you determine it is the best?
23:58:28 <srhb> Simple, choose one and only one!
23:58:33 <mauke> oh, that's easy then
23:58:34 <mandaya> ChickenNoodle: I would say your solutions look good
23:58:38 <srhb> Sadly it also happens to be the worst. :(
23:58:38 <Mike___> first result, and the ascii codes i needed in c worked
23:58:42 <mandaya> At first glance those look right
23:58:48 <merijn> Mike___: You're C program will just print bytes to the terminal (and that results in whatever locale the terminal uses)
23:58:58 <mandaya> I think the issue is conceptual: you're expecting something different
23:59:02 <mandaya> right?
23:59:03 <Mike___> its just to make it prettier
23:59:05 <merijn> GHCi uses UTF-8, which may be different from your locale
23:59:10 <Mike___> oh
23:59:11 <Mike___> ok
23:59:16 <srhb> I also agree, ChickenNoodle, that's a fine solution
23:59:25 <ChickenNoodle> mandaya: I agree. And that's because I'm hoping for something different because I'm unsure of what the assignment is expecting as output/return
23:59:30 <Mike___> thanks for that ^_^
23:59:35 <merijn> Mike___: I recommend you read this article: http://www.joelonsoftware.com/articles/Unicode.html
23:59:55 <merijn> Mike___: It;s very readable and will prevent any future confusion about encodings and unicode
