00:00:16 <nus> erus`,  the 'sum' in sum types is on value level
00:03:19 <mikeplus64> could (should?) String be implemented as a typeclass instead of [Char]?
00:03:41 <tikhonjelvis> I don't know if there's a consensus on that.
00:03:50 <qpu> what's the reasoning?
00:04:03 <qpu> Text and ByteString etc?
00:04:06 <c_wraith> You're aware of OverLoadedStrings?
00:04:06 <mikeplus64> yeah
00:04:18 <c_wraith> err, OverloadedStrings
00:04:41 <tikhonjelvis> I think it sounds dandy, but I've never used OverloadedStrings and so have exactly nil experience :)
00:05:16 <c_wraith> I've used it a fair bit.  You get ambiguous type errors, and the necessary problems when the literal contains values the type in question can't represent
00:05:55 <tikhonjelvis> Eh, I don't mind the former because explict top-level types mollify it, and the latter is inevitable.
00:06:07 <c_wraith> explicit top-level types are irrelevant
00:06:12 <mikeplus64> I'm not suggesting it should be that way in Prelude, I'm just wondering how you would define it really, I thought class String_ a where map :: (a -> b) -> a (new lines...) instance String_ [Char] where map f (x:xs) = normal map definition would work but it didn't
00:06:16 <c_wraith> all you need is a polymorphic function
00:06:18 <tikhonjelvis> Also, reading that last sentence back, maybe I need to consider bed sometime soon :P
00:06:25 <c_wraith> foo "constant"
00:06:40 <c_wraith> If foo is polymorphic, that needs an annotation to compile
00:07:03 <tikhonjelvis> Erm, isn't there a mechanism for type defaulting?
00:07:38 <c_wraith> it was never extended to work with IsString
00:07:41 <tikhonjelvis> ah
00:07:54 <tikhonjelvis> Could it be? Or, I guess more pertinetly, should it be?
00:08:18 <c_wraith> It could be.  Whether it should?  I'm not going to take a side on that one
00:08:25 <qpu> Typing Haskell in Haskell discusses some of the problems with defaulting, iirc
00:08:28 <tikhonjelvis> fair enough
00:08:29 <mikeplus64> my type for map above is broken, oops
00:08:58 <tikhonjelvis> The way it is now, it feels like a bit of a hack. But maybe I'm too judgemental.
00:10:11 <JoeyA> judgmental (sorry, just being a spelling geek)
00:10:12 <qpu> > :t show $ read "0"
00:10:13 <lambdabot>   <no location info>: parse error on input `:'
00:10:20 <qpu> :t show $ read "0"
00:10:22 <lambdabot> String
00:10:40 <qpu> which type did it infer for read?
00:10:41 <tikhonjelvis> Eh, I actually appreciate it. I'd *like* my spelling to be correct, but it frequently isn't.
00:11:13 <qpu> oh, (), how useless :]
00:11:26 <tikhonjelvis> Is that because of the defaulting?
00:11:31 <qpu> yeah, i think so
00:11:36 <tikhonjelvis> hmm
00:11:58 <tikhonjelvis> Are you sure? I thought defaulting was just for numbers.
00:12:00 <DarkUnicorn> is there a function which works like show but doesn't put " around the result
00:12:04 <DarkUnicorn> ?
00:12:07 <JoeyA> Note: compiling with ghc -Wall prints warnings when defaulting occurs.
00:12:37 <tikhonjelvis> DarkUnicorn: If you just want to print a string, use putStr.
00:12:47 <tikhonjelvis> DarkUnicorn: Otherwise, I guess id fits :)
00:12:58 <tikhonjelvis> Also: putStrLn
00:13:24 <DarkUnicorn> no, i don't want to print the string, i want to use it in an sql expression
00:13:40 <tikhonjelvis> If it's just a string, why are you using show on it at all?
00:13:48 <tikhonjelvis> Or do you want to escape stuff that way?
00:13:53 <DarkUnicorn> its not always a string
00:13:58 <tikhonjelvis> ah
00:14:01 <c_wraith> tikhonjelvis: there are two versions of defaulting. lambdabot is using extended defaulting, the same as ghci uses. But even it only works as long as there's a type class it knows about involved
00:14:08 <DarkUnicorn> its just a showable thing
00:14:35 <ddarius> Yes, like a type class like Gen ...
00:14:38 <tikhonjelvis> c_wraith: Ah, that makes sense.
00:14:48 <qpu> explains why ghc won't compile my example :]
00:14:51 <tikhonjelvis> But in normal cases, defaulting only applies to numbers?
00:15:13 <c_wraith> I think it's just numbers.  the report spells out all the rules explicitly
00:15:47 * hackagebot rolling-queue 0.1 - Bounded channel for STM that discards old entries when full  http://hackage.haskell.org/package/rolling-queue-0.1 (JoeyAdams)
00:15:52 <tikhonjelvis> Eh, I'm too lazy to look it up :P
00:18:11 <tikhonjelvis> Woah, just learned how to type a smile: ⌣.
00:18:20 <tikhonjelvis> ⌢ works too
00:21:27 <ion> ⌢̈
00:21:42 <tikhonjelvis> ion: Heh, I'm trying to do that but failing.
00:22:10 <tikhonjelvis> The dots won't combine with the ⌢, for whatever reason. I get ̈⌢.
00:23:32 <ion> You’ll need to add the combining diarrhea immediately after the ⌢.
00:23:38 <tikhonjelvis> aha
00:24:04 <tikhonjelvis> I'm guessing just googling "combining diarrhea" won't get me what I want...
00:24:13 <ion> U+0308 COMBINING DIAERESIS
00:25:34 <ion> (⌢) works as an operator but adding a combining character results in a lexical error. :-(
00:25:58 <Triplefox> this character makes chatzilla use five lines worth of space
00:26:10 <ion> > let (⌣̈) = 42 in (⌣̈)
00:26:11 <lambdabot>   <no location info>: lexical error at character '\776'
00:26:15 <Guest60668> I want to create a new data type "Binary" which only has 2 constructors ( 0 and 1 ) but I also want the type to be able to inherit all the aritmetic functionality of 0 and 1.. how can I do this?
00:26:34 <tikhonjelvis> Hmm, that's exactly the character I've been using. And yet I still get ̈⌢.
00:26:35 <ion> What’s 1 + 1 :: Binary?
00:27:17 <erus`> 10
00:27:25 <erus`> :3
00:27:43 <quicksilver> Guest60668: not exactly, no, because 0 and 1 are special and you can only reuse them in specific ways
00:27:54 <quicksilver> Guest60668: however you can do things very much like that if you want to.
00:27:59 <Guest60668> ion: no, but I want to be able to multiply a binary digit (0 or 1) to an integer for example
00:28:11 <quicksilver> And you can reuse 0 and 1 as part of making your type a Num instance
00:28:17 <quicksilver> (but then 7 and 9 will work too...)
00:28:18 <ion> (1 + 1 :: Binary) is “no”? :-)
00:28:41 <ion> Mod-2 algebra would be plausible for such a type.
00:28:42 <adnauseam> is it a NAND ?
00:28:44 <Guest60668> ion: sorry ion maybe i didnt understand the question =(
00:29:22 <adnauseam> 1+1 = false is true in a NAND and XOR gate, not sure about the second
00:30:12 <qpu> Guest60668: perhaps you can start with data Binary = One | Zero; instance Num Binary where ... and fill in all the members
00:30:25 <Guest60668> I want to do all this because i wrote a binary to decimal converter and the input is a [Int] but i wanted to restrict the elements of the list to only one and zero..
00:30:47 <quicksilver> the way to do that part is data BinaryDigit = One | Zero
00:31:06 <quicksilver> if your key starting requirement is restricting to only two values, then you want a simple type like that
00:31:13 <frerich> Another idae might be to use a newtype and then have a constructor function, no?
00:31:20 <quicksilver> (you could reuse Bool, of course, but it's often cleaner to use a new type)
00:31:24 <ion> λ> data BinaryDigit = One | Zero deriving (Bounded, Show)
00:31:27 <ion> λ> minBound :: BinaryDigit
00:31:28 <ion> One
00:31:58 <Guest60668> oh.. thanks!! That will do
00:32:29 <mikeplus64> Guest60668: you could use Bool, then define an instance of Num Bool
00:33:52 <Guest60668> mikeplus64: I thought of that but the input would be [True, False, True...] dont like =(
00:34:25 <Guest60668> I think I'll stick to quicksilver's solution
00:34:34 <Guest60668> thank you all =)
00:34:37 <mikeplus64> instance Num Bool where (+) = (||); (*) = (&&); abs x = x; signum x = x; fromInteger 1 = True; fromInteger 0 = False
00:34:57 <mikeplus64> yeah, his is probably better
00:36:09 <qpu> i think you can define in your instance, fromInteger n = if n == 1 then One else Zero, then you can 1 + 0 :: Binary
00:37:45 <ion> data Bin = Zero | One deriving (Eq, Ord, Enum, Bounded, Show); instance Num Bin where { (+) = transmogrify (+); (*) = transmogrify (*); (-) = transmogrify (-); abs = id; signum = id; fromInteger = toEnum . flip mod 2 . fromInteger }; transmogrify f = (toEnum . flip mod 2) .: f `on` fromEnum
00:37:49 * ddarius would recommend fromInteger n = if even n then Zero else One
00:38:09 <mikeplus64> transmogrify?
00:38:14 <mikeplus64> oh
00:38:19 <mikeplus64> .:?
00:38:32 <qpu> .: is backwards .
00:38:37 <qpu> :t (.:)
00:38:37 <mikeplus64> ah
00:38:38 <lambdabot> forall a b (f :: * -> *) (g :: * -> *). (Functor f, Functor g) => (a -> b) -> f (g a) -> f (g b)
00:38:39 <ion> (f .: g) x y = f (g x y)
00:38:54 <mikeplus64> I was thinking Repa for a moment
00:39:35 <tikhonjelvis> .: is not . backwards. >>> is . backwards.
00:39:54 <qpu> oh, thanks
00:40:10 <QinGW> @src ($)
00:40:11 <lambdabot> f $ x = f x
00:40:25 <QinGW> @SRC (<$>)
00:40:25 <lambdabot> Unknown command, try @list
00:40:33 <QinGW> @list <$>
00:40:33 <lambdabot> No module "<$>" loaded
00:40:51 <qpu> tikhonjelvis: where are those defined?
00:40:57 <tikhonjelvis> And <<< is . forwards (with a different precedence).
00:41:03 <ion> data Tern = Zero | One | Two deriving (Eq, Ord, Enum, Bounded, Show); instance Num Tern where { (+) = transmogrify (+); (*) = transmogrify (*); (-) = transmogrify (-); abs = id; signum Zero = Zero; signum _ = One; fromInteger = toEnum . flip mod 3 . fromInteger }; transmogrify f = (toEnum . flip mod 3) .: f `on` fromEnum
00:41:10 <tikhonjelvis> Umm, I usually get them from Control.Arrow.
00:41:30 <tikhonjelvis> But I think they're actually from Control.Category.
00:41:59 <mamalujo> hi! would someone w an account on ghc wiki plz remove the spamlink added couple of minutes ago, ie revert the last revision? duped me, thought it was something relevant ...
00:42:10 <tikhonjelvis> They're both overloaded for Categories. And (.) in Control.Category is also overloaded.
00:42:22 <mamalujo> on the front page, that is , sry forgot to specify
00:44:07 <QinGW> What is the meaning of <$> operator?
00:44:14 <tikhonjelvis> It's just fmap.
00:44:21 <tikhonjelvis> Except for Applicatives
00:44:34 <ddarius> It's just fmap.
00:44:35 <quicksilver> minuse the "Except for Applicatives" part
00:44:38 <tikhonjelvis> never mind
00:44:39 <quicksilver> it is, actually, just fmap.
00:44:46 <tikhonjelvis> It's just fmap from Control.Applicative.
00:44:53 <Guest60668> exit
00:45:02 <quicksilver> (<$>) = fmap is the complete definition
00:45:04 <ion> Minus the “from Control.Applicative” part
00:45:10 <ion> It’s defined in Data.Functor.
00:45:19 <ion> (Control.Applicative does re-export it.)
00:45:43 <tikhonjelvis> Heh, learn something new every day :)
00:46:00 <QinGW> Thanks
00:46:01 <tikhonjelvis> Hmm, why is it Data.Functor but Control.{Applicative,Monad}?
00:46:43 <quicksilver> because the naming of parts is arbitrary
00:47:00 <tikhonjelvis> But is there some deep philosophical significance I'm missing?
00:47:12 <quicksilver> nothing deep, I don't think
00:47:16 <tikhonjelvis> Because I've tried to use Control.Functor in the past :P
00:47:29 <quicksilver> monads and applicatives have a notion of effect, which might be control flow
00:47:30 <mikeplus64> the planets were in alignment at Control.Applicative
00:47:48 <quicksilver> functors don't have any effectful composition operators
00:48:00 <quicksilver> so, whilst functors might be effectful, there is nothing in the functor api about that
00:48:09 <mikeplus64> @src (<$)
00:48:09 <lambdabot> (<$) = (<$>) . const
00:48:09 <quicksilver> which makes functors less to do with control flow
00:48:20 <quicksilver> but, the above is woolly handwaving, not deep.
00:48:59 <ddarius> module Control.Xml
00:49:09 <ion> <launch what="missiles"/>
00:49:22 <SmartViking> @src reverse
00:49:22 <lambdabot> reverse = foldl (flip (:)) []
00:49:45 <tikhonjelvis> Yay for folds.
00:50:15 <mikeplus64> > 3 <$ [1,2,3,4,5]
00:50:16 <lambdabot>   [3,3,3,3,3]
00:51:00 <mikeplus64> > [1,2,3,4,5] >> [3]
00:51:01 <lambdabot>   [3,3,3,3,3]
00:51:15 <tikhonjelvis> > [1,2,3,4,5] *> [3]
00:51:16 <lambdabot>   [3,3,3,3,3]
00:51:18 <mikeplus64> neat
00:51:42 <mikeplus64> except now I'm having an existential crisis over the purpose of <$ and *>
00:51:56 <quicksilver> well, <$ takes a pure value
00:51:57 <tikhonjelvis> Well, I use it for parsing: Null <$ keyword "null"
00:52:01 <quicksilver> *> takes an action
00:52:13 <mikeplus64> ah
00:52:15 <ion> > 3 <$ [0..4]
00:52:16 <lambdabot>   [3,3,3,3,3]
00:52:19 <ion> > pure 3 <* [0..4]
00:52:19 <MaskRay> convenient when using Parsec
00:52:20 <lambdabot>   [3,3,3,3,3]
00:52:22 <mikeplus64> I've never seen *> before
00:52:22 <quicksilver> x <$ a is the same as pure x <* a
00:52:22 <tikhonjelvis> Something like pure Null <* keyword "null" would be ugly.
00:52:39 <tikhonjelvis> It's like >> for Applicatives.
00:52:41 <ion> How would that be ugly?
00:52:48 <quicksilver> a *> pure x is probably the same as pure x <* a but I'm not sure if you can prove that from the axioms.
00:53:00 <tikhonjelvis> Well, maybe not absolutely ugly, but relatively ugly.
00:53:24 <tikhonjelvis> E.g. Null <$ keyword "null" is prettier.
00:53:35 <Saizan> ?type (<*)
00:53:36 <lambdabot> forall (f :: * -> *) a b. (Applicative f) => f a -> f b -> f a
00:53:50 <ion> One of the laws is: u <*> pure y = pure ($ y) <*> u
00:54:01 <tikhonjelvis> I love how Haskell has different ways of doing things. It's just like math :)
00:54:23 <mikeplus64> > putStr "come on" *> putStr " fhqwhgads"
00:54:24 <lambdabot>   <IO ()>
00:54:27 <mikeplus64> ok
00:55:51 <tikhonjelvis> Heh, I just tried to pattern match an infix constructor like this: right :@: left. Maybe it really is time for bed :P
00:56:00 <mamalujo> speaking of ugly, might I perhaps persuade someone to revert this spam from ghc page: http://hackage.haskell.org/trac/ghc/wiki/WikiStart?action=diff&version=176 I feel a bit silly registering just for that edit
00:56:04 <mamalujo> :P
00:56:49 <tikhonjelvis> Eh, you sound more responsible than I'd ever be—you may as well register.
00:57:16 <mamalujo> :)
00:57:48 <ion> tikhonjelvis: ·ǝɯ oʇ ǝuᴉɟ sʞooן
00:58:57 <mamalujo> there's unicode for inverted letters? hm, whatever for?
00:59:07 <erus`> is there a reverse bind
00:59:16 <tikhonjelvis> :t (=<<)
00:59:17 <lambdabot> forall a (m :: * -> *) b. (Monad m) => (a -> m b) -> m a -> m b
00:59:19 <erus`> so a return short circuits
00:59:43 <Botje> monad laws won't allow it
01:00:23 <ion> mamalujo: Some of them are probably used in some languages, some of them are probably for lossless translation from legacy charsets, some of them are IPA symbols.
01:01:11 <tikhonjelvis> Isn't there a character for making the rest of the string backwards?
01:01:37 <erus`> is this a good pattern:       maybe (scopeLookup p i) return (lookup i ds)
01:02:05 <mux> looks like you want whenJust
01:02:34 <ion> That has the type Monad m => … -> m ()
01:02:37 <mux> whenJust :: Monad m => Maybe a -> (a -> m b) -> m () ?
01:02:57 <mux> I've had to define a couple times and I know others did as well
01:03:29 <ion> erus: I don’t see anything wrong with it.
01:12:42 <KorriX> hello everybody
01:14:46 <KorriX> is there any builtin function for trimming list by an element: "test,test,test" and ',' should give ["test", "test", "test"]
01:14:46 <KorriX> ?
01:15:01 <Saizan> KorriX: see the split package
01:15:59 <mux> > split ',' (pack "test,test,test")
01:16:00 <lambdabot>   Couldn't match expected type `n -> t'
01:16:00 <lambdabot>         against inferred type `(GHC.T...
01:16:14 <Jafet> > break (==',') "test,es,test"
01:16:15 <lambdabot>   ("test",",es,test")
01:16:19 <mux> sigh. I meant to show tht Data.ByteString.Char8 has a builtin split function for that
01:16:41 <Jafet> Char8 can buuurn
01:16:55 <mux> String can burn even hotter imo :)
01:18:00 <Jafet> type Wick = String
01:30:31 <yitz> mux: there is a built-in function in Data.Text. You would not normally use byte-strings for text.
01:31:12 <yitz> mux: i think that is what Jafet was trying to say.
01:34:09 <koeien> am I correct in assuming that an empty class does not have a runtime representation?
01:35:51 <quicksilver> you could argue that no classes have a runtime representation.
01:36:18 <quicksilver> *instances* have a runtime representation in GHC in certain cases.
01:36:31 <koeien> right
01:36:50 <quicksilver> but the question you presumably mean to ask - will GHC optimise away an instance of empty class - I'm not sure
01:36:53 <koeien> so instances of an empty class.
01:37:06 <quicksilver> I suspect so because it is susceptible to ordinary optimisation techniques
01:37:11 <quicksilver> it's a 0-tuple which is never inspected
01:37:18 <quicksilver> so the ordinary optimiser ought to be able to remove it
01:37:41 <koeien> could i inspect core to investigate?
01:38:02 <koeien> I suspect Core does not have the concept of classes and already just passes dictionaries.
01:38:12 <luite> what's the cabal os predicate for OS X?
01:38:48 <SmartViking> Darwin?
01:43:10 <luite> ah, it was darwin (System.Info.os)
01:43:48 <luite> but Darwin also works, tnx
01:55:54 <kqr> why isn't there any operator m a -> (a -> b) -> m b?
01:56:31 <dobblego> @type flip fmap -- there is this
01:56:32 <lambdabot> forall a b (f :: * -> *). (Functor f) => f a -> (a -> b) -> f b
01:56:46 <kqr> (would be useful for chaining operations that can fail (in the Maybe monad) together with those that otherwise can't (which therefore are not in the Maybe monad))
01:57:00 <dobblego> are you asking why there isn't one with the arguments around the unusual way?
01:57:33 <kqr> yeah, i guess
01:57:34 <dobblego> you just want fmap then?
01:57:40 <dobblego> @type fmap
01:57:41 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
01:57:46 <dobblego> @type fmap (+1) (Just 7)
01:57:47 <lambdabot> forall a. (Num a) => Maybe a
01:57:50 <dobblego> > fmap (+1) (Just 7)
01:57:51 <lambdabot>   Just 8
01:58:57 <kqr> dobblego, but you can't chain those together just as well as you can with >>=
01:59:12 <dobblego> you can use <$>
01:59:29 <dobblego> but really, this would be unusual if it was burdensome
01:59:50 <dobblego> you don't exactly "chain together" calls to fmap, since they compose
01:59:55 <luite> kqr: hmm, you can just use (.) to chain these together, right?
02:00:04 <luite> a . b . c <$> someM
02:00:26 <kqr> luite, hm, maybe
02:03:24 <kqr> luite, yeah, that's what i wanted
02:03:26 <kqr> luite, thanks
02:20:38 <Ngevd> I'm probably the only person who manually @pl's for fun
02:21:02 <Ngevd> > let mean = uncurry (/) . foldr (uncurry . flip (flip . ((.) (.) . ((.) (,) . (+)))) (+1)) (0,0) in mean [1..10]
02:21:03 <Axman6> i doubt that
02:21:04 <lambdabot>   5.5
02:21:25 <Axman6> also, pointfree style for the sake of pointfree style is evil
02:21:40 <Ngevd> This is pointfree for fun and entertainment
02:21:55 <Ngevd> If I was going to actually use it, it would be a lot pointier
02:22:13 <kqr> > (\xs -> (fromIntegral . sum xs) / (fromIntegral . length xs)) [1..10]
02:22:14 <lambdabot>   Couldn't match expected type `f a'
02:22:14 <lambdabot>         against inferred type `GHC.Types...
02:22:18 <kqr> aaa
02:22:50 <kqr> oh
02:22:54 <Axman6> kqr: that's usually not a good method
02:23:01 <kqr> > (\xs -> (fromIntegral $ sum xs) / (fromIntegral $ length xs)) [1..10]
02:23:02 <lambdabot>   5.5
02:23:07 <kqr> @pl (\xs -> (fromIntegral $ sum xs) / (fromIntegral $ length xs))
02:23:08 <lambdabot> ap ((/) . fromIntegral . sum) (fromIntegral . length)
02:23:12 <kqr> Axman6, right
02:23:12 <Axman6> causes the list to be kept in memory too long
02:23:16 <Ngevd> > let mean = uncurry (/) . foldr (\x (a,b) -> (a+x,b+1)) in mean [1..10]
02:23:17 <lambdabot>   Couldn't match expected type `(a, a)'
02:23:17 <lambdabot>         against inferred type `[a1] -...
02:23:30 <Ngevd> > let mean = uncurry (/) . foldr (\x (a,b) -> (a+x,b+1)) (0,0) in mean [1..10]
02:23:31 <lambdabot>   5.5
02:23:48 <Axman6> need moar bang patterns!
02:24:01 <Axman6> also, foldr?
02:24:01 <Saizan> foldl', more importantly
02:24:07 <Axman6> yeah
02:24:18 <Axman6> i'd missed it was foldl initially
02:24:23 <Axman6> r*
02:24:34 <ion> > let avg (Sum x, Sum n) = x / fromInteger n; toAvg x = (Sum x, Sum 1); toAvgs = foldMap toAvg in avg (toAvgs [6..10] ++ toAvgs [1..5])
02:24:35 <lambdabot>   Not in scope: `foldMap'
02:24:41 <ion> > let avg (Sum x, Sum n) = x / fromInteger n; toAvg x = (Sum x, Sum 1); toAvgs = Data.Foldable.foldMap toAvg in avg (toAvgs [6..10] ++ toAvgs [1..5])
02:24:42 <lambdabot>   5.5
02:26:21 <Saizan> > foldMap (:[]) [1..]
02:26:22 <lambdabot>   Not in scope: `foldMap'
02:26:30 <Saizan> > Data.Foldable.foldMap (:[]) [1..]
02:26:31 <lambdabot>   [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28...
02:28:57 <Saizan> foldMap would be a nice function to where you could do type-directed foldl vs. foldr optimizations
02:28:58 <MaskRay> foldl' + unboxed tuple
02:29:09 <Ngevd> > let mean = uncurry (/) . foldl' (\(a,b) x -> (a+x,b+1)) (0,0) in mean [1..10]
02:29:10 <lambdabot>   5.5
02:30:41 <ion> > let avg (Sum x, Sum n) = x / fromInteger n; toAvg x = (Sum x, Sum 1); toAvgs = Data.Foldable.foldMap toAvg; as = toAvgs [6..10]; bs = toAvgs [1..5] in (as, avg as, bs, avg bs, as ++ bs, avg (as ++ bs))
02:30:43 <lambdabot>   ((Sum {getSum = 40},Sum {getSum = 5}),8.0,(Sum {getSum = 15},Sum {getSum = ...
02:30:54 <ion> > let avg (Sum x, Sum n) = x / fromInteger n; toAvg x = (Sum x, Sum 1); toAvgs = Data.Foldable.foldMap toAvg; as = toAvgs [6..10]; bs = toAvgs [1..5] in map avg [as, bs, as ++ bs]
02:30:55 <lambdabot>   [8.0,3.0,5.5]
02:31:07 <kqr> what's up with foldl vs foldr? i have vague memories of one being more efficient than the other, and it feels like it should be foldr, but could someone enligthen me?
02:31:17 <koeien> they are different kqr
02:31:20 <Axman6> depends on the situation
02:31:21 <koeien> there is an haskell wiki article
02:31:33 <kqr> right
02:31:36 <Axman6> foldr should ber used if you need early terminatination
02:31:37 <kqr> i'll read it
02:31:44 <Saizan> when you want/can have laziness you should use foldr, otherwise foldl'
02:31:50 <Axman6> foldl when you know you need to process the whole list
02:32:03 <kqr> okay, thanks
02:32:05 <Axman6> (and almost always foldl' instead of foldl)
02:32:08 <Saizan> not just early termination
02:32:14 <MaskRay> Ngevd: the version still doesn't run in constant space
02:32:39 <Saizan> you might want to process the whole list but not all up front, e.g. in the case of map
02:32:44 <ion> foldr is what you use when your function is lazy on the second parameter and you might want to use part of the result before folding over the whole list. foldl' is what you use when you want to process the whole list, potentially strictly on the accumulator parameter, and you want a single result afterwards.
02:32:44 <Ngevd> MaskRay, elaborate
02:32:56 <MaskRay> > let mean = uncurry (/) . foldl' (\(!a,!b) x -> (a+x,b+1)) (0,0) in mean [1..10]
02:32:58 <lambdabot>   5.5
02:33:41 <MaskRay> Ngevd: Section 'Bang patterns' of http://book.realworldhaskell.org/read/profiling-and-optimization.html
02:35:50 <Ngevd> Hmm
02:52:25 <luite> I have a cabal library project with C-sources: cbits/somefile.c, and after cabal install it works in ghci, but the symbols from that file are unresolved when compiling something that uses this project with ghc
02:52:33 <luite> waht am I missing?
02:55:24 <QinGW> hi evening
02:57:58 <erus`> @type iterate
02:57:59 <lambdabot> forall a. (a -> a) -> a -> [a]
02:58:17 <erus`> @hoogle (a -> a) -> Int -> a -> [a]
02:58:18 <lambdabot> Prelude maybe :: b -> (a -> b) -> Maybe a -> b
02:58:18 <lambdabot> Data.Maybe maybe :: b -> (a -> b) -> Maybe a -> b
02:58:18 <lambdabot> Data.Generics.Aliases mkQ :: (Typeable a, Typeable b) => r -> (b -> r) -> a -> r
03:02:31 <QinGW> @type fmap
03:02:32 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
03:05:18 <erus`> @hoogle (a -> (Maybe b, a)) -> a -> [b]
03:05:18 <lambdabot> No results found
03:05:45 <dobblego> erus`: unfoldr?
03:05:50 <erus`> @hoogle (a -> (Maybe b, a)) -> a -> ([b], a)
03:05:50 <lambdabot> No results found
03:06:06 <dobblego> that type is only slightly different to unfoldr
03:06:09 <erus`> dobblego: yeah but i need a also
03:06:11 <dobblego> @type unfoldr
03:06:12 <lambdabot> forall b a. (b -> Maybe (a, b)) -> b -> [a]
03:06:23 <erus`> well i need b also
03:09:58 <koeien> then replace a by (a,b)
03:10:14 <koeien> hmm, maybe not so convenient
03:10:18 <erus`> i dont want a list of a,b
03:10:30 <koeien> map fst at the end, and snd . last to find your b
03:11:51 <koeien> > unfoldr (\i -> if i == 10 then Nothing else Just ((i*2,i), i+1) 0
03:11:52 <lambdabot>   <no location info>: parse error (possibly incorrect indentation)
03:12:06 <koeien> > unfoldr (\i -> if i == 10 then Nothing else Just ((i*2,i), i+1)) 0
03:12:07 <lambdabot>   [(0,0),(2,1),(4,2),(6,3),(8,4),(10,5),(12,6),(14,7),(16,8),(18,9)]
03:12:32 <koeien> > let xs = unfoldr (\i -> if i == 10 then Nothing else Just ((i*2,i), i+1)) 0 in (map fst xs, snd (last xs))
03:12:32 <lambdabot>   ([0,2,4,6,8,10,12,14,16,18],9)
03:12:39 <koeien> erus`: ^
03:17:35 <sordina> qpu: Well, I would be happy with it just running an IO action with the built in profiler, but many times with 'arbitrary' arguments, ala quickcheck. That way the data could be graphed nicely to quickly develop intuitions.
03:17:51 <xil> hi everyone. I just ran a test that seems to suggest this but would like some confirmation. Is concat essentially "foldr (++) []"? I was wondering if stringing (++)'s together would left or right associate and did some testing
03:18:01 <koeien> xil: yup
03:18:15 <koeien> left associative would be extremely expensive
03:18:27 <koeien> well, O(n^2). and it wouldn't work for infinite lists
03:18:28 <Axman6> O(n^2) as opposed to O(n)
03:18:33 <xil> indeed. I was worried about exactly that
03:18:35 <koeien> @src concat
03:18:35 <lambdabot> concat = foldr (++) []
03:18:38 <koeien> ah!
03:18:39 <xil> because I'm using very large strings
03:18:41 <xil> haha
03:18:48 <koeien> don't use String if you care about performance
03:18:58 <koeien> use Text for texts, and ByteString for lists of bytes
03:19:12 <xil> well I don't, but I care about the difference between O(n^2) and O(n)
03:19:27 <peterjoel> hi, if I add a data directory to my cabal package, how do I access files from there?
03:19:45 <xil> this is just some parsing. I can wait a few seconds, but with left associativity I'd be waiting minutes
03:20:04 <koeien> ok, as you wish :)
03:25:22 <erus`> @pl typeCheck s t1 >>= \x -> typeCheck x t2
03:25:22 <lambdabot> flip typeCheck t2 =<< typeCheck s t1
03:26:08 <yitz> peterjoel: i'm not sure there is a platform-independent way to be able to open them as data files
03:26:57 <yitz> peterjoel: you can wrap the data as haskel source modules
03:27:24 <peterjoel> I'm using getDataFileName, but it doesn't find it
03:27:24 <yitz> peterjoel: if it's a lot of data that won't work so well though
03:27:43 <peterjoel> in fact, it doesn't find it if I just add the file, not a directory
03:27:44 <yitz> peterjoel: ghc chokes on large amounts of literal data in a module
03:28:06 <yitz> getDataFileName?
03:28:24 <Saizan> defined by Cabal to find your data-files
03:28:31 <peterjoel> yes, that one
03:28:40 <yitz> oh really? didn't know there was such a thing.
03:29:17 <yitz> @hoogle getDataFileName
03:29:17 <lambdabot> No results found
03:29:37 <peterjoel> indeed
03:30:06 <QinGW> @hoogle getDataFilePath
03:30:06 <lambdabot> No results found
03:30:09 <ClaudiusMaximus> http://www.haskell.org/cabal/users-guide/#accessing-data-files-from-package-code
03:31:44 <peterjoel> ok, so it doesn't find the file
03:33:20 <peterjoel> the directory doesn't exist actually
03:34:13 <ClaudiusMaximus> iirc you have to list each file separately in the .cabal file, with very limited wildcard support (maybe)
03:34:50 <peterjoel> yeah… that doens't work either
03:34:59 <peterjoel> the directory that it says the file is in, doesn't exist
03:38:11 <yitz> peterjoel: what is this whole data-files things supposed to do anyway? is there documentation on that?
03:43:28 <rostayob> Mhm, I sent a patch to QuickCheck adding a generic 'arbitrary'
03:43:33 <rostayob> I'm surprised it wasn't already there
03:43:36 <yitz> looks to me like data-files is only useful (if it works at all) for libraries, not for executables.
03:44:03 <yitz> rostayob: what is a generic arbitrary?
03:44:58 <rostayob> yitz: an 'arbitrary' that works with GHC.Generics
03:45:04 <yitz> ah
03:45:06 <rostayob> so you don't have to define it manually
03:45:19 <dreixel> rostayob: that's great
03:45:22 <dreixel> can I have a look at it?
03:45:55 <rostayob> dreixel: http://pastebin.com/N2kYk8tq
03:45:58 <mauke> The paste N2kYk8tq has been copied to http://hpaste.org/63806
03:46:21 <rostayob> dreixel: the relevant part is from 63 to 88
03:46:46 <rostayob> actually, I don't need dlist, I just realized...
03:47:26 <dreixel> uhm, I see
03:47:56 <dreixel> great that you've done this
03:48:12 <dreixel> but, perhaps you could reuse this implementation: http://hackage.haskell.org/packages/archive/regular-extras/0.2.2/doc/html/src/Generics-Regular-Functions-Arbitrary.html
03:48:35 <dreixel> it's written for a different GP lib, but it shouldn't be too hard to convert it to GHC.Generics
03:49:01 <dreixel> and it's more powerful because it allows you to set different frequencies to each constructor
03:49:25 <dreixel> I guess your implementation might often generate very large values, no?
03:49:25 <rostayob> dreixel: ok, I'll check that out :)
03:49:30 <rostayob> also, I'm missing CoArbitrary
03:49:32 <rostayob> yes
03:50:02 <dreixel> this one also has coarbitrary
03:50:14 <rostayob> cool
03:50:18 <rostayob> I'll add those then
03:50:25 <dreixel> it's easier, actually
03:51:03 <rostayob> dreixel: the problem is that that defines a new class
03:51:16 <rostayob> well, not too much of a "problem"
03:51:18 <dreixel> rostayob: I think that depends on the quickcheck version, no?
03:51:34 <rostayob> dreixel: ? the 'Arbitrary' class in that file is different
03:51:40 <rostayob> it includes the frequency thing that you mentioned
03:52:05 <dreixel> oh, I see what you mean.
03:52:20 <rostayob> the thing is that, walking to work
03:52:26 <rostayob> it occurred to me that you could do this
03:52:35 <rostayob> and I was sure that people had already done that
03:52:37 <rostayob> and in fact
03:52:40 <rostayob> smallcheck has it
03:52:46 <rostayob> but QuickCheck doesn't, strangely
03:53:17 <dreixel> right, so I think you should perhaps provide this function for generic instances
03:53:33 <dreixel> and come up with a suitable default to use for the standard "arbitrary" method.
03:53:34 <MaskRay> is lisp comprehension and list monad different in terms of their definition of `fail' ?
03:53:55 <yitz> MaskRay: no
03:54:08 <MaskRay> the former returns []
03:54:17 <yitz> MaskRay: they both do
03:54:25 <MaskRay> the latter gives exception
03:54:41 <mysticc> @hoogle ExitException
03:54:41 <lambdabot> Control.OldException ExitException :: ExitCode -> Exception
03:54:45 <yitz> > do fail :: [Int]
03:54:46 <lambdabot>   Couldn't match expected type `[GHC.Types.Int]'
03:54:46 <lambdabot>         against inferred typ...
03:54:51 <xil> I need some help with parsec. I'm trying to parse some tab separated text. Would "sepBy anychar tab" work or would the "anychar" part eat up the tabs as they were found?
03:54:57 <MaskRay> > [x | x@Nothing <- [Just 3]]
03:54:58 <lambdabot>   []
03:55:13 <yitz> > fail :: [Int]
03:55:13 <lambdabot>   Couldn't match expected type `[GHC.Types.Int]'
03:55:14 <lambdabot>         against inferred typ...
03:55:27 <yitz> @type fail
03:55:27 <MaskRay> > [Just 3] >>= \x@Nothing -> [x]
03:55:27 <lambdabot> forall (m :: * -> *) a. (Monad m) => String -> m a
03:55:28 <lambdabot>   *Exception: <interactive>:3:13-29: Non-exhaustive patterns in lambda
03:55:33 <ClaudiusMaximus> > faile "fail" :: [Int]
03:55:34 <lambdabot>   Not in scope: `faile'
03:55:39 <yitz> > fail "foo" :: [Int]
03:55:40 <lambdabot>   []
03:56:22 <MaskRay> yitz: what's the behind mechanism makes list comprehension behave different
03:56:27 <dreixel> rostayob: I see that my code already has a suitable generic default
03:56:48 <rostayob> dreixel: oh right, you're one of the GHC.Generics guys :)
03:56:59 <yitz> MaskRay: it doesn't behave differently. they are the same.
03:57:39 <MaskRay> yitz: then how could  [x | x@Nothing <- [Just 3]] evaluate correctly
03:57:43 <yitz> MaskRay: the exception is because you fed a Just value into a function that has no defined behavior for Nothing.
03:58:11 <dreixel> rostayob: so it should work fine. I just reused the name Arbitrary, but it's not the same class as QuickCheck's
03:58:17 <rostayob> dreixel: yep yep
03:58:29 <yitz> > do { x@Nothing <- [Just 3]; return x}
03:58:30 <lambdabot>   []
03:58:45 <rostayob> but the cool trick is using DefaultSignatures
03:58:49 <MaskRay> yitz: puzzled
03:58:56 <rostayob> dreixel: so you don't have a separate class at all
03:59:15 <yitz> MaskRay: in a do expression or list comprehension, it calls fail if your bind pattern doesn't match, giving you [].
03:59:26 <dreixel> rostayob: uhm, no, you'd still need a separate class for the representation types (sum, products, and such)
03:59:55 <dreixel> rostayob: but what I define as the "arbitrary" function would end up as the default method of Quickcheck's arbitrary
04:00:01 <rostayob> dreixel: yes but that's behind the hood
04:00:02 <MaskRay> yitz: Oh, i've confused do/list comprehension with >>=
04:00:08 <rostayob> the user doesn't need to know about that
04:00:14 <yitz> MaskRay: as opposed to in a function definition, where if the pattern doesn't match, it moves on to the next alternative definition of the function, expecting to find one, and throwing an exception if it doesn't.
04:00:18 <dreixel> rostayob: indeed.
04:00:35 <rostayob> the cool thing about DefaultSignatures is that you can write "default arbitrary :: (Generic a, GArbitrary (Rep a)) => Gen a"
04:00:49 <dreixel> yes.
04:01:00 <dreixel> I was just trying to say that it doesn't matter that this class doesn't match Quickcheck's
04:01:07 <dreixel> because this is GArbitrary, and not Arbitrary itself.
04:01:20 <yitz> MaskRay: well, list comprehension and do notation are actually both syntactic sugar for >>=. so it's not exactly confusing those. you are confusing two different kinds of pattern matching.
04:01:20 <rostayob> yes
04:01:56 <b0fh_ua> Hi, I'm trying to install email package and getting weird error: http://hpaste.org/63810
04:02:05 <yitz> MaskRay: or rather 3 different kinds of pattern matching.
04:02:09 <b0fh_ua> can somebody please advice what's wrong there? I'm on FreeBSD 9
04:02:09 <MaskRay> yitz: caught on
04:02:16 <rostayob> dreixel: I'm wondering if it's possible to define a generic 'shrink'. conceptually is definitely possible (you split :*:) but at the type level it's kind of tricky. I'll try tonight I really have to work now :P
04:02:34 <DarkUnicorn> if i want to write a negative integer in haskell, do i really have to write something like (0-5) ?
04:02:38 <dreixel> rostayob: I've never tried it, but it definitely sounds interesting
04:02:45 <dreixel> rostayob: keep me posted ;-)
04:02:45 <ion> > -5
04:02:46 <lambdabot>   -5
04:02:56 <rostayob> dreixel: it's interesting also because it's automatically well-founded
04:02:56 <yitz> MaskRay: in a pattern to the left of <- in do or a comprehension, you only get one shot, and it calles fail if it misses.
04:03:03 <rostayob> dreixel: but QuickCheck wouldn't care about that
04:03:06 <DarkUnicorn> hm, strange
04:03:25 <rostayob> I think that smallcheck already does something similar
04:03:31 <yitz> MaskRay: in a function definition, you get as many shots as you want, but if you miss on all of them, you get an exception
04:04:03 <yitz> MaskRay: and in a lambda expression, it's a function definition, but you only get one shot, so you had better hit it.
04:05:24 <yitz> MaskRay: for some monads, fail also throws an exception. you're lucky with the list monad that it does something more tame.
04:06:22 <MaskRay> yitz: many thanks
04:06:32 <yitz> MaskRay: np :)
04:07:12 * av says hello
04:07:32 <rostayob> dreixel: yes, it can be done, given that K1 has tags.
04:07:54 <dreixel> rostayob: is it as simple as returning the children?
04:08:14 <av> hi everyone, what's the easiest way of creating a closed path that consists of a cubic spline and some linear segments in Diagrams?
04:08:16 <rostayob> dreixel: yes, when K1 has got tag R
04:08:23 <rostayob> and you enforce type equality in the instance
04:08:25 <rostayob> I think it's doable
04:08:40 <dreixel> rostayob: well, if it's just the children, it is doable, yes, I've done it before
04:08:41 <rostayob> if the tag is P you trow away the data
04:08:44 <dreixel> takes a little trick with MPTCs, but it works.
04:08:56 <yitz> av: i don't know Diagrams very well, but that sounds like a fun question
04:09:01 <rostayob> dreixel: have you got any code already?
04:09:21 <dreixel> rostayob: http://hackage.haskell.org/packages/archive/generic-deriving/1.0.3/doc/html/src/Generics-Deriving-Uniplate.html
04:09:49 <dreixel> rostayob: should be something along those lines
04:10:08 <rostayob> dreixel: ok... I must resist not to try now... I should work :D
04:10:28 <dreixel> :-)
04:10:29 <fryguybo1> av: Humm, I'm not sure if that is supported.
04:11:31 <rostayob> dreixel: eh but you're using overlapping instances
04:11:35 <rostayob> can't you avoid that using R and P?
04:11:49 <rostayob> since when the type is going to be equal, there's going to be an R
04:12:05 <dreixel> rostayob: I'm afraid you can't do it without overlapping instances
04:12:30 <rostayob> dreixel: I think you can, let's see
04:12:38 <dreixel> rostayob: you need to match on "(K1 i a) a" and "(K1 i b) a"
04:12:44 <yitz> av: look at the source code of Diagrams.TwoD.Arc.bezierFromSweep
04:12:55 <rostayob> why can't you match on "(K1 R a) a" and "(K1 P b) a"?
04:13:09 <yitz> av: http://hackage.haskell.org/packages/archive/diagrams-lib/0.4.0.1/doc/html/Diagrams-TwoD-Arc.html, then click "Source".
04:13:13 <dreixel> rostayob: and what do you do with recursive occurrences of other types?
04:13:19 <fryguybob> av: I'll have to think about how to go about doing that.  You can piece together something like that from beziers.
04:13:38 <fryguybob> av: And Spiro would let you do that more directly.
04:13:49 <rostayob> dreixel: wait, aren't recursive occurences... recursive on the type itself? or do they include mutual recursion as well?
04:14:09 <dreixel> rostayob: they include pretty much anything other than parameters.
04:14:31 <rostayob> dreixel: ah, ok. I misunderstood that then
04:14:43 <rostayob> then yes, I guess you need OverlappingInstances
04:14:48 <rostayob> still, as long as you don't export the class
04:14:51 <rostayob> you should be safe
04:14:55 <dreixel> rostayob: (and even if it didn't, the types don't really tell you that you are reccurring into the same type)
04:15:09 <dreixel> rostayob: yes, it's a local thing only.
04:15:32 <yitz> av: it looks like you would do the same kind of thing, except your list would consist of a single Cubic segment and then the rest Linear.
04:16:02 <byorgey> av: the cubic spline function can be used to create a Trail, and you can also make some straight segment Trails (using e.g. ~~ or fromVertices or fromOffsets), then combine the trails with mconcat
04:16:36 <fryguybob> byorgey: I think the issue is getting smoothness between segments.
04:17:05 <yitz> fryguybob: it's going to be hard to get a closed path that way
04:17:16 <byorgey> oh, well, I guess I don't know exactly what av is trying to accomplish =)
04:17:39 <byorgey> av: note, there is also #diagrams
04:17:55 <hpaste> o1iver pasted “gen” at http://hpaste.org/63811
04:18:55 <fryguybob> yitz: I don't think it is much harder then a normal closed cubic spline.
04:19:04 <byorgey> av: can you describe in a bit more detail exactly what you want?
04:19:11 <o1iver> Hey. I am sure some people here have tried genetric programming. I am also approaching the subject. I am new to both Haskell and GenPro and was wondering if anybody could have a look at the above code and let me know if I am heading in the right direction (doesn't look to nice at the moment). Thanks!
04:19:40 <av> thanks a lot everyone
04:20:00 <o1iver> I would prefer something with more abstract types, but I am not sure if that is possible...
04:20:14 <av> byorgey: that's what I'm playing around with, just wondering whether there is a more straight-forward way
04:20:41 <byorgey> av: a more straightforward way to do what?
04:21:18 <av> byorgey: forgot about #diagrams... but it looks like I find enough answers to digest on #haskell anyway...
04:21:36 <o1iver> Ideally, functions would be simply be described by the (multiple) different types they accept and the (multiple) different types they can return, not these hardcoded function type
04:24:05 <yitz> byorgey: still no non-cairo backend?
04:24:46 <byorgey> yitz: nope, sadly
04:24:52 <byorgey> I've been focusing on other things
04:25:04 <byorgey> yitz: but once I get this 0.5 release out, a non-cairo backend will be the next priority
04:25:22 <yitz> byorgey: is it a big job?
04:25:41 <byorgey> not really
04:25:48 <byorgey> just not very exciting =)
04:26:21 <luite> non cairo backend!
04:26:37 <luite> plus -
04:26:46 <byorgey> yitz: OK, I mean, actually, there are some non-cairo backends, most notably fryguybob's postscript backend
04:27:11 <byorgey> but it's unreleased
04:27:15 <yitz> oh there's a PS backend?
04:27:28 <yitz> fryguybob: release it?
04:27:45 <byorgey> http://www.patch-tag.com/r/fryguybob/diagrams-postscript/home
04:27:47 <yitz> i'd like to see ann svg backend too
04:27:49 <av> byorgey: I'd like to create a cubic spline using cubicSpline or suchlike, and then continue it at both ends with linear segments
04:28:13 <yitz> s/ann/an/
04:28:25 <byorgey> yitz: yep, me too, that's in the works
04:28:27 <av> byorgey: oh, and it would be nice if I could then render it with a fill colour
04:28:34 <byorgey> av: OK, yes, I understand what you want now.
04:28:53 <fryguybob> av: If you want to take the direction that it "ended up at" you can convert the cubic spline to a bezier curve and continue along the end handle direction.
04:29:20 <byorgey> av: unfortunately, right now that's not easy to do.  However one of the projects I have in mind is to implement the Metapost API for path creation which would let you do this easily.
04:29:46 <fryguybob> Or you could tweak that direction toward your linear segment.  Neither of these are idea.  But I've added a ticket to look into solving these kind of things.
04:30:48 <fryguybob> yitz: The text support in the ps backend isn't great and in some cases it produces rather large unoptimized ps.  I would like to figure out how to address these things before releasing on the world.
04:31:08 * hackagebot PrimitiveArray 0.2.0.0 - Efficient multidimensional arrays  http://hackage.haskell.org/package/PrimitiveArray-0.2.0.0 (ChristianHoener)
04:31:16 <fryguybob> yitz: That said, I haven't used the Cairo backend for about a year now.
04:32:25 <av> byorgey: my thought was to break the cubicSpline up into segments using (fromSegments . trailSegments), then mappend the linear segments to it -- but I haven't had full success so far
04:33:36 <av> byorgey: it sort of works, but each trail starts at the origin, not at the end point of the previous segment, which surprises me
04:35:36 <b0fh_ua> I'm facing problems with installing "encoding" package: http://hpaste.org/63812
04:35:44 <b0fh_ua> does anybody know something about that?
04:40:12 <yitz> fryguybob: why not just release it as a preliminary version, with the comments you just wrote in the package description?
04:40:28 <yitz> fryguybob: that way people can use it already now as it is. it looks really useful.
04:40:50 <fryguybob> yitz: You can get it from darcs :D.
04:42:24 <fryguybob> yitz: But I understand that there are benefits to it being on hackage.  I think it will get there soon as we work towards the next release.
04:43:14 <yitz> fryguybob: thanks, this is nice work. the code is neat and elegant.
04:43:44 <fryguybob> yitz: byorgey is by far the most to blame :D
04:44:50 <MaskRay> [MonadNondetT] I've contemplating MonadNondetT for a while but still have no idea http://hpaste.org/63813
04:45:15 <yitz> b0fh_ua: the standard way to do that is using text-icu if you need weird encodings
04:45:51 <MaskRay> [MonadNondetT] It seems to use continuation passing style
04:46:51 <yitz> b0fh_ua: although i'm having a little trouble with that approach on mac os x, since icu is not the standard way to handle encondings on the mac
04:47:42 <MaskRay> [MonadNondetT] How is (>>=) of `instance (Monad m) => Monad (NondetT m)' implemented?
04:47:54 <byorgey> av: that means you have created a bunch of Paths instead of Trails
04:47:58 <yitz> b0fh_ua: if all you need is utf-8 (like most people), just use Data.Text.Encoding
04:50:06 <byorgey> av: see http://projects.haskell.org/diagrams/manual/diagrams-manual.html, look at the section titled "The PathLike class"
04:52:02 <yitz> byorgey: based on the simplicity of fryguybob's ps backend, a simple svg backend should be a piece of cake
04:52:46 <byorgey> yitz: indeed
04:52:48 <luite> yitz: now this is your chance to prove that you're right, I give you two hours ;p
04:53:07 <av> byorgey: I'm aware of that, so how do I make sure that I have a bunch of trails, not paths? I'm not declaring any paths explicitly here!
04:53:12 <yitz> luite: it's very tempting :) but i'
04:53:15 <byorgey> in fact, someone already wrote one, then he went off back to France and never gave me the code =(
04:53:18 <yitz> ve got to get back to work.
04:53:46 <luite> this means that we should go on an epic journey to france to retrieve the code
04:54:01 <byorgey> av: functions like fromSegments can produce any PathLike instance
04:54:02 <yitz> byorgey: the internet connection to france has been quite reliable lately.
04:54:19 <byorgey> av: so it depends on how you use it.
04:54:35 <byorgey> av: you would want something like   strokeT . mconcat $ list of trails
04:54:41 <byorgey> av: strokeT has type   Trail -> Diagram
04:54:50 <byorgey> so that fixes the type of the list to be [Trail]
04:55:18 <byorgey> av: this is explained in more detail in the user manual section that I linked.
04:55:39 <osa1> can anyone help me? I can't install libraries from cabal, I tried yesod, happstack, hakyll, snap and got almost same errors: http://paste.pocoo.org/show/552003/
04:56:14 <dcoutts> osa1: it's complaining about the version of the base package
04:56:24 <dcoutts> osa1: the base package version is tied to the ghc version
04:56:27 <byorgey> osa1: what version of ghc do you have?
04:56:30 <dcoutts> so essentially, your ghc is too old
04:56:37 <osa1> dcoutts: it's 7.0.4
04:56:48 <dcoutts> oh, hmm
04:57:38 <dcoutts> osa1: do you not have old-time installed already? ghc-pkg list old-time
04:57:51 <ion> Try cabal --solver=modular, too.
04:58:00 <osa1> dcoutts: /home/sinan/.ghc/x86_64-linux-7.0.4/package.conf.d
04:58:13 <dcoutts> osa1: ok, so it isn't listed
04:58:30 <osa1> ion: unrecognised command
04:58:42 <osa1> dcoutts: so what should I do about it?
04:58:49 <dcoutts> osa1: did you install ghc from your distro packages? perhaps you need to install the other parts
04:58:59 <av> byorgey: thanks a lot for the pointers, it was me using stroke in place of strokeT indeed.  It works now, looks like I'm going to have a lot of fun this afternoon.
04:59:13 <fryguybob> av: \o/
04:59:14 <osa1> dcoutts: I'm on opensuse 12.1. I've installed it from a third-party repository(we don't have haskell in official repos) and I have all packages related with haskell
04:59:21 <dcoutts> osa1: if your distro has a haskell-platform package then install that
04:59:39 <dcoutts> osa1: sounds like you've got *only* the ghc compiler and not the other standard libs
04:59:41 <osa1> dcoutts: unfortunately it doesn't :(
04:59:52 <osa1> dcoutts: maybe I can compile it manually?
05:00:00 <osa1> dcoutts: does it compile with ghc 7.0.4 ?
05:00:25 <dcoutts> osa1: well take a look at what other packages are available from that repository, you should find old-time and others
05:00:52 <yitz> dcoutts: the text-icu package is not finding icu on mac os x (i installed it with macports). what's the right way to fix this?
05:00:57 <dcoutts> osa1: yes it will compile with 7.0.4, but you'd need an older version of old-time. You also want cabal-install
05:00:58 <osa1> dcoutts: no it doesn't include old-time
05:01:13 <osa1> wait, it has
05:01:27 <osa1> ok, I already have ghc-old-time and now I installed ghc-old-time-devel package
05:01:34 <dcoutts> yitz: --extra-lib-dirs --extra-include-dirs, but I fear that with macports that will screw up other things like iconv
05:02:07 <nand`> apparently GHC won't accept a case/of inside a do block inside a let inside a do block inside a do block :(
05:02:19 <osa1> dcoutts: oh, looks like hakyll is compiling
05:02:20 <nand`> have been fighting with the parser for about 10 minutes trying to get it to accept my indenting
05:03:14 <yitz> dcoutts: icu isn't independent of iconv?
05:03:26 <dcoutts> yitz: yes but linker search path semantics suck
05:04:07 <dcoutts> yitz: when you use -package icu it'd link using -L/usr/local/macports (or whatever) and that means it'll resolve the -liconv using the macports one, boom!
05:04:40 <dcoutts> yitz: that problem is solvable, but only with some packaging & linking changes in ghc
05:05:03 <dcoutts> yitz: longer term mini-project for some hacker with access to OSX
05:05:30 <dcoutts> solution is not to use -L search paths but to resolve full path of the lib and keep that in the ghc-pkg db
05:06:02 <yitz> dcoutts: hmm. if that happens, think the best workaround is to install icu manually in its own dir?
05:06:11 * hackagebot BiobaseXNA 0.6.2.0 - Efficient RNA/DNA representations  http://hackage.haskell.org/package/BiobaseXNA-0.6.2.0 (ChristianHoener)
05:06:11 <dcoutts> yitz: that'd work
05:06:32 <dcoutts> yitz: or hacking the registration info after installing so that it uses the full path, and no linker search dir
05:07:15 <yitz> dcoutts: which field in the pkg db should i look for?
05:07:20 <yitz> fields
05:07:56 <dcoutts> yitz: extra-libraries and library-dirs
05:07:58 <yitz> dcoutts: i'm using cabal-dev so i'm not afraid of trying to hack the pkg db :)
05:08:20 <dcoutts> yitz: the extra-libraries turn into -l flags, the library-dirs into -L flags
05:08:26 <yitz> got it
05:08:29 <yitz> thanks!
05:08:47 <dcoutts> yitz: if it doesn't work with -l, use the ld-options to simply list the full path of the lib
05:09:49 <yitz> dcoutts: ok i'll try. part of the problem is i'm not sure i know the full list of libs that are needed, there are lots of them in icu.
05:10:29 <dcoutts> yitz: should just be the ones listed in the ghc-pkg db
05:10:38 <yitz> right
05:10:42 <yitz> ok thanks
05:13:50 <rostayob> With DefaultSignatures, there is no way to have a 'fallback' default, right?
05:13:54 <yitz> dcoutts: this is going to link statically, right? (i hope?)
05:14:07 <dcoutts> yitz: depends on the lib you're linking to
05:14:24 <dcoutts> yitz: .a or .dynlib on OSX right?
05:15:07 <dcoutts> yitz: with -l search I think if there's both then it defaults to the dynlib one, unless you link with -static
05:15:21 <dcoutts> that's the system linker behaviour I think
05:16:00 <yitz> dcoutts: that'll be bad. if i then distribute this exe to users, it's not going to work.
05:16:22 <dcoutts> yitz: you have to think about that for all the C libs you link to
05:16:31 <dcoutts> if they're not system libs guaranteed to be there
05:16:49 <yitz> dcoutts: hmm. there are a ton of deps here. who knows.
05:16:59 <dcoutts> yitz: if you've got static libs for icu then it's fine
05:17:26 <dcoutts> yitz: it is also in principle possible to distribute an executable with its libs and to have it all work
05:17:55 <dcoutts> though exactly how that works varies between platforms, and I'm least familiar with the OSX scheme for finding libs at runtime
05:17:55 <osa1> dcoutts: now I'm stuck with a different error: http://paste.pocoo.org/show/552017/
05:18:36 <yitz> dcoutts: well i think mzero set up hp on the mac to use standard system libs by default. i assume that if something unusual is needed, like for bryan's text-icu, i'll get a build failure.
05:18:42 <yitz> hope that's a good assumption.
05:19:26 <yitz> but yeah, i'm on an old version of mac os x, and it could be that my build will not be useful for people on a current platform.
05:20:02 <dcoutts> yitz: usually things work going forward, not back, so probably better to build on an older version
05:20:35 <yitz> if i can get this to build, i'll try the exe on a recent mac. if it works fine. if not we'll do the same thing again on the newer machine.
05:21:16 * hackagebot BiobaseFR3D 0.2.3.0 - Importer for FR3D resources  http://hackage.haskell.org/package/BiobaseFR3D-0.2.3.0 (ChristianHoener)
05:21:51 <yitz> dcoutts: on mac os x that's not always true. the assumption is always that you upgrade immediately. then some mechanism is provided on the new platform for developers who want to provide backwards compatibility.
05:23:15 <b0fh_ua> yitz: I don't need that - email library  wants this package
05:23:21 <osa1> strange, I already have time 1.2.0.3
05:23:32 <yitz> b0fh_ua: oh i see
05:23:37 <osa1> how can I check if I have a library installed in cabal?
05:23:43 <dcoutts> osa1: ghc-pkg list
05:23:44 <koeien> ghc-pkg list
05:23:54 <b0fh_ua> yitz: so may be I will patch it :)
05:24:05 <b0fh_ua> yitz: what is the package again?
05:24:14 <osa1> ok, I have correct version of time library but cabal install hakyll gives me error about time library
05:24:21 <b0fh_ua> yitz: iconv?
05:24:39 <osa1> "snap-core-0.7.0.1 depends on time-1.2.0.3 which failed to install." I already have time-1.2.0.3
05:25:12 <b0fh_ua> osa1: try to reinstall time, perhaps cabal has wrong indexes
05:25:37 <b0fh_ua> osa1: or it is installed globally and cabal is not able to use it for some reason
05:25:48 <osa1> b0fh_ua: it has time library in /usr/lib64/ghc-7.0.4/package.conf.d but not in /home/sinan/.ghc/x86_64-linux-7.0.4/package.conf.d
05:26:13 <b0fh_ua> so it is installed globally
05:26:30 <b0fh_ua> try to install snap with --global flag
05:26:37 <dcoutts> osa1: you can see what it's going to do using --dry-run -v
05:30:54 <QinGW> setup: The pkg-config package webkit-1.0 version >=1.1.15 is required but it could not be found. when I install manatee. How to install webkit >= 1.1.15, I can't it it in hackage, just find webkit-gtk or webkit-qt, what releation of them?
05:37:45 <osa1> so where does cabal install libraries when I run it with sudo?
05:38:11 <dcoutts> osa1: don't use sudo unless you're also using --global
05:38:18 <osa1> dcoutts: I'm using --global
05:38:20 <dcoutts> with --global it'll install to /usr/local
05:38:30 <dcoutts> osa1: generally though global installs are not recommended
05:38:34 <qnikst> what haskell - postgres sql library suck less and provide disconnect function?
05:38:46 <qnikst> :)
05:39:01 <dcoutts> osa1: it's easier to blow stuff away and clean up if it's per-user since it's all kept in ~/.cabal and ~/.ghc
05:39:03 <osa1> dcoutts: I'm trying to install hakyll, snap etc. I already have correct version of time library installed but somehow cabal doesn't use it
05:39:07 <osa1> dcoutts: so I'm using --global
05:39:12 <osa1> I know
05:39:27 <dcoutts> osa1: --global probably has nothing to do with that
05:39:30 <osa1> dcoutts: if someone can tell me how can I move this time library from system to .cabal ..
05:39:47 <dcoutts> global libs are avilable for per-user installs too
05:39:53 <dcoutts> if it's not using it, there's a reason
05:39:54 <osa1> dcoutts: no. I couldn't install hakyll without --global
05:40:00 <dcoutts> see --dry-run -v
05:40:43 <qnikst> I've found libpq, postgresql-libpq, postgresql-simple
05:41:25 <dcoutts> qnikst: and HDBC has a postgres backend
05:41:33 <osa1> dcoutts: what does --dry-run -v do?
05:41:44 <dcoutts> osa1: shows what it would do, with more detail
05:42:00 <qnikst> dcoutts, HDBC does not provide close function
05:42:11 <osa1> dcoutts: ok, how does this help me?
05:42:17 <qnikst> so I can't use it with resource-pool
05:42:32 <dcoutts> qnikst: close on what? connection or query/statement ?
05:42:40 <yitz> b0fh_ua: the problem is that the cabal file for encoding sets no upper limit on the version of HaXML that it depends on.
05:43:16 <yitz> b0fh_ua: it says >= 1.19. but recent versions of HaXML changed some of the types, so that won't work.
05:43:27 <dcoutts> osa1: it'll say why it's not using the existing time lib, most likely because it's tring to use a later version of something else. You might want to get rid of that other thing.
05:43:58 <yitz> b0fh_ua: you could edit the cabal file of encoding to say HaXML ==1.19.* and you will avoid that error.
05:44:45 <dcoutts> qnikst: as far as I can see, both connections and statements can be closed
05:44:58 <dcoutts> qnikst: disconnect and finish
05:46:00 <qnikst> dcoutts, connection. and I already found function I was looking in HDBC.PostgresSQL api not in hdbc one
05:46:36 <luite> I have a Word64 with some flags, is there some standard api for dealing with those? testing/setting etc?
05:46:39 <dcoutts> qnikst: ah, yes, HDBC is structured with backends, so you only use the initial connection function from the backend package, but use the main package for everything else
05:46:50 <dcoutts> luite: Data.Bits
05:47:28 <luite> right, that feels a bit low-level and c-ish tough, but I guess it's appropriate :)
05:47:55 <qnikst> so I missed it)
05:48:45 <qnikst> and Data.LargeWord
05:49:21 <qnikst> that uses Data.Bits in backend
05:49:47 <dcoutts> zenzike: ^^ you might like to add a note to the backend API docs pointing people to the main API in the HDBC package
05:50:15 <dcoutts> zenzike: when people are looking through hackage for postgres, or sqlite or whatever they'll find the backend package first
05:50:48 <dcoutts> zenzike: and it's not immediately obvious to them that HDBC is structured with backend packages
05:55:40 <erus`> that feel when you write screens of code and it typechecks first time :D
05:56:16 <Botje> \o/
05:57:21 <zmv> erus`: ⁵!
05:58:14 <xil> hi. Can someone help me understand the difference between Set and Map?
05:58:52 <Botje> a Set contains unique objects, a Map maps unique keys to values
05:58:57 <zenzike> dcoutts: hmm, thanks. I'll add something to that effect.
05:59:27 <xil> Botje: so the set is like the map but without values
05:59:39 <dcoutts> zenzike: perhaps package description of the drivers too, not just haddocks
05:59:54 <Botje> xil: yes.
05:59:59 <osfameron> xil: or like a map that maps an object key to its own value ;-)
06:00:04 <Botje> xil: you can even represent a set like that: type Set = Map Key ()
06:00:08 <zenzike> dcoutts: yes, I'll sprinkle some love in the README.md, the haddocks, and the cabal description
06:00:11 <Botje> or Map Key Key as osfameron says
06:00:11 <o1iver> Hey! For some reason these are always True, shouldnt there be some Falses in there?  map (\s -> fst $ random (mkStdGen s) :: Bool) [1..40]
06:00:37 <xil> okay awesome, thanks =]
06:01:17 <rwbarton> o1iver: you're not supposed to use Random like that
06:02:08 <o1iver> rwbarton: I don't use it like that, it was just a test... but isn't is strange anyhow? I mean I know it's getting the first value, but are all the first values True?
06:02:22 <rwbarton> [1..40] is not all possibilities :P
06:02:29 <Axman6> > randoms (mkStdGen 7) :: [Bool]
06:02:30 <lambdabot>   [True,False,True,False,False,True,False,True,True,True,True,True,True,True,...
06:02:50 <o1iver> > and $  map (\s -> fst $ random (mkStdGen s) :: Bool) [1..40]
06:02:51 <lambdabot>   True
06:02:55 <o1iver> > and $  map (\s -> fst $ random (mkStdGen s) :: Bool) [1..4000]
06:02:56 <lambdabot>   True
06:03:08 <rwbarton> :t mkStdGen
06:03:09 <lambdabot> Int -> StdGen
06:03:26 <rwbarton> > and $  map (\s -> fst $ random (mkStdGen s) :: Bool) [0,1287468232985371..]
06:03:27 <lambdabot>   False
06:03:41 <o1iver> Axman6: yes I know about that. I am actually using split, but I just found that strange
06:04:17 <rwbarton> it looks like the first Bool in the sequence depends only on the higher-order bits of the initial seed
06:05:25 <o1iver> > and $ map (\s -> fst $ random (mkStdGen s) :: Bool) [1..53667]
06:05:26 <lambdabot>   True
06:05:28 <o1iver> > and $ map (\s -> fst $ random (mkStdGen s) :: Bool) [1..53668]
06:05:29 <lambdabot>   False
06:05:36 <rwbarton> oh I remember now
06:05:47 <rwbarton> I think 53667 is a magic constant in the Random implementation
06:05:52 <rwbarton> something like that
06:05:56 <o1iver> So it seems that for the seeds from 1 to 53667 the first element if always True
06:06:01 <erus`> i wish undefined returned a line #
06:06:08 <o1iver> rwbarton: ok I see
06:06:17 <o1iver> rwbarton: well thanks for the explanation
06:06:39 <rwbarton> btw split has very bad randomness properties in some usage patterns
06:07:19 <rwbarton> http://hackage.haskell.org/trac/ghc/ticket/3575
06:07:39 <rwbarton> there was another cool one
06:07:55 <rwbarton> http://hackage.haskell.org/trac/ghc/ticket/3620
06:09:07 <krakrjak> erus`: use error instead of undefined and you can have what you are looking for.
06:09:29 <o1iver> rwbarton: mmmh so what would you suggest? I need to traverse an AST and modify things using a randGen and I am using split for the recursion
06:09:47 <o1iver> s/modify/modifying/
06:10:50 <hpaste> o1iver pasted “spli” at http://hpaste.org/63817
06:10:57 <rwbarton> you can either use split and cross your fingers--as far as I know pure splittable random number generators are an unsolved problem...
06:11:17 <o1iver> ok
06:11:23 <rwbarton> or use a random number generator that is impure behind the scenes, if you don't care about reproducibility
06:11:30 <o1iver> well I will try and if it causes problems I will see
06:11:49 <o1iver> cheers
06:15:28 <Na-Fiann> Hi, to learn Haskell I decided to do a simple programming exercise, as described here: http://programmingpraxis.com/2012/02/14/divisors/. I figured I'd start by simply building the list of numbers first, but I find it hard to even start with this, mostly because it seems I can't update a list by indexes, eg, given a list of lists 'xs' , a list of indexes 'is' and a number 'a', I want to append 'a' to each list indexed by 'is'
06:16:04 <RichyB> Na-Fiann, you can't modify a data structure like a list in place.
06:16:22 <Na-Fiann> hmm....
06:16:30 <RichyB> Instead you build a new list with the different elements that you want in it.
06:16:30 <Na-Fiann> yeah of course... silly
06:16:34 <rwbarton> and lists aren't designed for that kind of by-index update
06:16:53 <RichyB> If you want to do by-index updates, you should probably use Data.Map or Data.IntMap.
06:16:55 <rwbarton> (you can do it, of course, by returning a new list, but it's neither efficient nor convenient)
06:17:06 <rwbarton> or Array
06:17:21 <Na-Fiann> I think I'd probably need to rethink my method for doing this then :p
06:17:59 <merijn> Na-Fiann: For sieves you probably want to abuse laziness in someway
06:18:01 <RichyB> Yeah, but leave Array alone until after you've already decided that IntMap is too slow. Otherwise you end up with a load of ST or IO in the middle of your nice pure computation.
06:18:35 <rwbarton> there are pure Arrays too
06:18:49 <Na-Fiann> merijn, I'm not sure I follow what you mean there
06:19:00 <Axman6> i think almost all the array libraries implement pure and mutable versions
06:19:56 <RichyB> rwbarton, usually not what people want because of the O(n) cost to build a new one with one element updated.
06:20:33 <Axman6> RichyB: see DiffArray
06:20:38 <RichyB> Axman6, sucks.
06:20:45 <rwbarton> if you can only update one element at a time, that's true
06:20:49 <Axman6> probably. i've never used it =)
06:21:20 <RichyB> Axman6, DiffArray has the complexity that you want, but according to people here who've tried using it, the constants are awful. For most programs, IntMap comes out faster.
06:21:21 <erus`> i have written a staticly typed stack language :3 with polymorphism
06:21:30 <erus`> in about 80 LOC
06:21:38 <RichyB> erus`, well aren't you just goshdarned excellent.
06:21:48 <RichyB> No sarcasm, that is goshdarned excellent. :)
06:21:49 <Axman6> erus`: hpaste yo
06:22:16 <merijn> Na-Fiann: I'm working out an example for you :)
06:22:36 <Na-Fiann> merijn: awesome, thanks
06:23:22 <hpaste> erus` pasted “erus gosh darned language” at http://hpaste.org/63819
06:23:46 <osa1> I'm getting an error about hjsmin library when I run yesod devel, but I can't install it with cabal. logs: http://paste.pocoo.org/show/552059/
06:23:49 <osa1> can anyone help me?
06:24:11 <osa1> I'm trying to get yesod working for about 2 hours now ..
06:24:42 <mauke> osa1: have you tried installing alex?
06:24:59 <osa1> mauke: yes, as you can see in my logs
06:25:18 <osa1> wait, wrong logs
06:25:31 <rwbarton> is /usr/local/bin on your PATH?
06:25:40 <rwbarton> what happens when you type 'alex'
06:25:41 <rwbarton> ?
06:26:00 <osa1> rwbarton: it prints usage
06:26:18 <osa1> alex -v : Alex version 3.0.1, (c) 2003 Chris Dornan and Simon Marlow
06:26:32 <rwbarton> is /usr/local/bin on root's PATH?
06:26:50 <dcoutts> plausibly might want to try alex 2.x
06:27:17 <osa1> dcoutts: ...
06:27:25 <mauke> sudo alex -v
06:27:34 <osa1> mauke: same
06:28:03 <dcoutts> osa1: oh I see, it's asking for >= 3, ignore my comment
06:29:26 <rwbarton> how does cabal decide whether it's found the "program alex version >=3.0" anyways?
06:29:27 <merijn> @hoogle (a -> b) -> [a] -> [(a,b)]
06:29:28 <lambdabot> Control.Monad.Writer.Class listens :: MonadWriter w m => (w -> b) -> m a -> m (a, b)
06:29:28 <lambdabot> Control.Monad.Writer.Lazy listens :: MonadWriter w m => (w -> b) -> m a -> m (a, b)
06:29:28 <lambdabot> Control.Monad.Writer.Strict listens :: MonadWriter w m => (w -> b) -> m a -> m (a, b)
06:29:29 <osa1> dcoutts: http://paste.pocoo.org/show/552069/
06:29:30 <osa1> new logs
06:29:38 <osa1> wait or is it the same
06:29:43 <osa1> yeah I think it's the same
06:30:12 <osa1> ok so can you tell me how are you installing these libraries?
06:30:39 <rwbarton> well I think most people don't use --global, maybe that is related to your problem somehow
06:30:54 <osa1> last week I tried installing latest version of ghc but then I couldn't install haskell-platform because it needs an older version of ghc
06:31:09 <osa1> rwbarton: if you read my chat logs you'll see that I first tried it without --global
06:31:16 <osa1> rwbarton: and I was getting whole different errors
06:31:18 <hpaste> merijn pasted “divisors” at http://hpaste.org/63820
06:31:30 <dcoutts> osa1: for max compat it's best to use the haskell-platform, not bleeding edge ghc
06:31:31 <osa1> rwbarton: with --global I can at least install yesod library
06:31:50 <osa1> dcoutts: how can I compile haskell-platform without ghc?
06:31:58 <merijn> Na-Fiann: Probably a bit too complicated to follow without explanation, but here is an example (partial implementation) http://hpaste.org/63820
06:32:08 <merijn> Na-Fiann: Although I have to admit I didn't really test it :p
06:32:22 <dcoutts> osa1: hp includes/specifies a version of ghc
06:32:23 <osa1> dcoutts: ok, I give you a linux installed computer without any package managers etc. it just have c compilers and some other language runtimes, how do you install yesod and get it working?
06:33:05 <dcoutts> osa1: install HP, cabal install yesod, possibly with some fiddling with constraints
06:33:24 <osa1> dcoutts: "some fiddling with constraints"
06:33:31 <osa1> dcoutts: I think I already stuck at that point
06:33:56 <dcoutts> osa1: it's only needed if cabal install [--dry-run] cannot find a solution
06:34:28 <osa1> whatever
06:34:29 <hpaste> merijn annotated “divisors” with “divisors (annotation)” at http://hpaste.org/63820#a63821
06:34:34 <dcoutts> osa1: sorry, I don't have time right now to look at the details, but I suspect you've got messed up local/per-user haskell packages
06:34:48 <luite> osa1: that alex error, just install the latest alex program first, ghc or hp comes with ales 2.x
06:34:51 <luite> alex
06:34:56 <merijn> Na-Fiann: Actually, that second link is probably better. Ask away any thing you don't follow :)
06:34:58 <mauke> luite: what
06:35:00 <rwbarton> it looks like the thing you're trying to install isn't even really part of yesod proper
06:35:11 <Na-Fiann> merijn: thanks, I'll have a read
06:35:35 <osa1> rwbarton: yeah then why does yesod give an error about that package?
06:35:44 <rwbarton> as far as I can see it doesn't...?
06:35:53 <rwbarton> oh
06:36:14 <merijn> @pl (id &&&)
06:36:14 <lambdabot> (id &&&)
06:36:19 <rwbarton> well your yesod project is trying to use it
06:36:23 <luite> osa1: what is the error you're currently having?
06:36:25 <b0fh_ua> guys, again - how to convert between String and ByteString.Lazy?
06:36:32 <Botje> pack
06:36:38 <osa1> luite: it's really long story, I'm trying to solve it for about 2 hours know
06:36:45 <osa1> luite: maybe you could look to chat logs
06:36:56 <osa1> luite: which includes lots of error logs pasted by me
06:37:00 <erus`> is 'this called a quote in scheme?
06:37:04 <luite> osa1: hmm, can you join #yesod and post the relevant links?
06:37:05 <rwbarton> this isn't a very constructive attitude btw
06:37:13 <rwbarton> "please read the past 2 hours of chat logs"
06:37:18 <Botje> erus`: yes.
06:37:25 <osa1> luite: I'm not sure it's about yesod.
06:37:48 <osa1> but whatever, I'll just clean my computer from all haskell stuff and reinstall haskell-platform
06:37:49 <rwbarton> basically the problem seems to be that hjsmin wants alex >=3.0 which he seems to have installed already
06:37:50 <Botje> erus`: quoting an atom returns a symbol, quoting a tree returns the tree as it is
06:38:02 <luite> osa1: even if it's just an error you get when installing yesod, it's relevant enough. we might be able to fix it by uploading packages with adjusted constraints on the dependencies or something
06:38:25 <merijn> Na-Fiann: Actually, I just saw I made an incredibly stupid mistake in that example (in main I use the function perfect wrong)
06:38:40 <erus`> a tree is made of symbols?
06:38:51 <b0fh_ua> Botje: pack works with Word8 - but I am dealing with unicode strings
06:39:05 <mauke> b0fh_ua: so how do you want to encode them?
06:39:37 <Botje> b0fh_ua: then you should probably be using Text
06:39:56 <b0fh_ua> mauke: well, I suppose to have utf-8 as input
06:40:03 <b0fh_ua> haskell internal String is UTF8, right?
06:40:07 <mauke> b0fh_ua: no
06:40:11 <b0fh_ua> wow
06:40:13 <mauke> b0fh_ua: String is unicode
06:41:35 <ChristianS> b0fh_ua: best approach is probably to use Data.Text.Encoding (decodeUtf8, encodeUtf8) and work with the resulting Text instances, as Botje already hinted
06:41:41 <ChristianS> Text is much faster than String
06:42:18 <Na-Fiann> merijn: I think I get the general gist of it though... you create a list of all numbers, then construct a list of divisors for each of those numbers? Isn't that the opposite of what the exercise says? (building up through multiplication instead of filtering on division?)
06:42:31 <b0fh_ua> okay, thanks!
06:42:57 <erus`> @pl \t -> return (Type [] [SType t])
06:42:57 <lambdabot> return . Type [] . return . SType
06:45:07 <merijn> Na-Fiann: Oh wait, I misread some things. Lemme write something using addition (well, probably not addition as that'd be ugly and slow. But something closer to the original idea)
06:46:06 <osa1> I have to compile haskell-platform from source if my distro doesn't have it in packag emanager, right?
06:46:53 <rwbarton> installing alex 3.0.1 for language-javascript worked fine here
06:47:27 <Wooga> why i can't pattern-match with strings? like ``foo ("add":xs) = ...`` ? i can do ``foo ('a':'d':'d':xs) = ...``, but isn't "add" is just a syntactic shugar for ('a':'d':'d':[]) ?
06:47:36 <kstt> <ChristianS> Text is much faster than String   <----   I don't have the context, but I recently converted all I18N content of a website from String to Text, and lost 20% of throughput immediatly. So that does not hold for lots of small string for example.
06:47:43 <merijn> Na-Fiann: Ok, the basic problem with that exercise is this: They want you to start with empty lists and continually append at the end. Which is terribly slow in haskell (since you'd have to copy the list every append)
06:48:00 <mauke> Wooga: you can pattern match with strings
06:48:03 <Wooga> hmm
06:48:25 <kstt> Wooga: pattern-matching requires writing constructors.
06:48:41 <Wooga> isn't ``:`` a constructor ?
06:48:42 <rwbarton> Wooga: think through it again
06:48:44 <merijn> Na-Fiann: You can probably do something similar, but it'll be fairly slow (or very complicated)
06:48:48 <erus`> I can't type my call function :(
06:48:50 <rwbarton> "add" is sugar for ('a':'d':'d':[])
06:48:57 <rwbarton> so what is ("add":xs)
06:48:57 <ion> > let (``:``) = 42 in (``:``)
06:48:58 <lambdabot>   <no location info>: parse error on input ``'
06:49:10 <kstt> Wooga: expand your constructors
06:49:51 <o1iver> rwbarton: hey. You seem to know about random generators, etc. Is it possible to split a random number generator into an arbitrary number of generators? Something like g -> Int -> [g]?
06:50:00 <mauke> :t split
06:50:01 <lambdabot> forall g. (RandomGen g) => g -> (g, g)
06:50:05 <rwbarton> you can write that with split
06:50:08 <mauke> :t unfoldr
06:50:09 <lambdabot> forall b a. (b -> Maybe (a, b)) -> b -> [a]
06:50:22 <mauke> :t unfoldr (Just . split)
06:50:23 <lambdabot> forall b. (RandomGen b) => b -> [b]
06:50:36 <yitz> dcoutts: ping
06:50:39 <ChristianS> kstt: yes, Text comes with an overhead which may hurt for small strings. but it's generally faster for longer strings. when it doubt, it's always better to explicitly test what's faster for you.
06:51:30 <Wooga> ah, really. i can't use ``'d':[]:something``; because [] accepts no parameters
06:51:34 <erus`> :t ($)
06:51:35 <lambdabot> forall a b. (a -> b) -> a -> b
06:51:40 <dcoutts> yitz: can you ping me in ~3 hrs?
06:51:44 <o1iver> rwbarton, mauke : I see, thanks
06:51:49 <Wooga> thanks
06:51:51 <ChristianS> there is also the utf8-string package which works on raw utf8-encoded bytestrings, but is has a very limited api so i wouldn't generally recommended it (though it's probably the fastest option when the limited api is enough for you).
06:52:20 <rwbarton> Wooga: you *can* write foo ("add":xs) = ..., it just means the sensible thing, not what you seem to want it to mean.
06:52:21 <merijn> Na-Fiann: It is probably easier to do these sorts of exercises if you don't strictly try to follow the instructions specified, as not all imperative ideas translate well to functional style.
06:52:47 <merijn> Na-Fiann: You could force it, but then you learn to write imperative haskell, rather than learning how to write functional haskell
06:52:59 <rwbarton> > let { foo ("add":xs) = sum (map read xs) :: Integer; foo ("mul":xs) = product (map read xs) :: Integer } in foo ["add", "3", "5"]
06:52:59 <lambdabot>   8
06:53:04 <yitz> how about 2.5? have to leave in exactly 3. be back at T+4.5.
06:53:47 <Wooga> > (\("add":xs) -> xs) "add abc"
06:53:48 <lambdabot>   Couldn't match expected type `[GHC.Types.Char]'
06:53:48 <lambdabot>         against inferred ty...
06:53:52 <Na-Fiann> merijn, ok thanks =) I'll give up on it for now then
06:54:04 <Wooga> in that way - i can't
06:54:07 <rwbarton> no of course not
06:54:28 <rwbarton> y:z is a list whose first element is y and where the rest of the list is z
06:54:34 <rwbarton> so "add":xs is a list whose first element is "add"
06:54:37 <rwbarton> always!
06:54:45 <rwbarton> no random do-what-i-mean-ery
06:54:50 <merijn> Na-Fiann: My final attempt actually compiles and runs, but is a little slow since the implementation is rather naive (http://hpaste.org/63820)
06:56:27 <merijn> Na-Fiann: Probably a bit complex, but I daresay you can learn a lot from it by just looking at it and examining the type signatures of the functions in there. Exercise for the reader: figure out all the type signatures and see how they combine to see what happens :p
06:56:43 <yitz> ChristianS: kstt left. but Text should be faster than String even when there are many small strings. if you know a case where it appears not to be so, you should let bryan know.
06:56:55 <Na-Fiann> merijn: thanks for all the help and explanations =)
06:57:43 <yitz> ChristianS: i don't think i would recommend utf8-string for anything anymore. text is the way to go.
06:58:29 <merijn> Na-Fiann: :t in ghci should give all the type signatures for the functions in there. Except &&&, which is in Control.Arrow and has a very unhelpful type signature for newcomers, pretend it's type signature is this: (a -> b) -> (a -> c) -> (a -> (b, c))
07:03:10 <Na-Fiann> merijn: why is uncurry in the definition of main?
07:03:56 <merijn> Na-Fiann: What is the type of the list the gets returned by the map?
07:04:05 <merijn> s/the gets/that gets/
07:04:56 <rata_> hi
07:05:09 <Na-Fiann> merijn, haven't checked, but: [ (a, [a]) ] ?
07:05:27 <merijn> Yes (well, close enough)
07:05:36 <merijn> What's the type of perfect?
07:05:55 <Na-Fiann> a -> [a] -> bool
07:06:02 <Na-Fiann> uhm Bool, that is
07:06:51 <Na-Fiann> ohh
07:06:52 <Na-Fiann> I see
07:06:53 <merijn> The problem is that filter expects a function of type "(a, [a]) -> Bool" (since the map returns "[(a, [a])]")
07:06:58 <merijn> :)
07:07:25 <merijn> And a sudden flash of enlightenment is achieved :)
07:08:00 <Na-Fiann> yup
07:09:36 <erus`> I have to have explicit types on a call statement
07:09:39 <erus`> makes sense
07:09:57 <merijn> Although this example is a bit longer than I would normally write on a single line. Normally I'd probably place one or more of the map/filters in a where clause
07:10:17 <Na-Fiann> ahh
07:10:28 <merijn> Deciphering it is good practice to see whether you grok the type system, though
07:10:54 <Na-Fiann> you said close enough earlier, does that mean it's not entirely true?
07:11:06 <Na-Fiann> on the type of the map result
07:11:14 <rwbarton> it should be noted that the algorithm merijn is using is different from one described on the original page
07:11:16 <luite> does anyone know if there is an event based haskell file/folder watching library for windows?
07:11:41 <merijn> rwbarton: Yeah, I already said that. Because the constant appending is a pain in haskell
07:11:59 <rwbarton> well, it's not really because of the appending
07:12:08 <merijn> Na-Fiann: It's really "(Integral a) => [(a, [a])]"
07:12:20 <Na-Fiann> ahhh
07:12:32 <rwbarton> you are checking, for every 1 <= y <= x <= n, whether y divides x, that's O(n^2)
07:12:33 <hpc> luite: don't think so; there's probably some POSIX calls you can use to make the library though
07:12:37 <merijn> Na-Fiann: i.e. it works for anything that is an Integral number (because divisors uses mod and ==)
07:13:04 <rwbarton> the original only does an operation for each 1 <= y <= x <= n such that y actually divides x, that's only O(n log n)
07:13:27 <luite> hpc: there is not standard POSIX way to do this
07:13:49 <merijn> rwbarton: Yeah, I just meant that implementing the original algorithm is substantially more complex in haskell as opposed to say doing the same thing in python/java/ruby/whatever
07:14:03 <rwbarton> yes
07:14:03 <merijn> Or maybe not more complex, but at least uglier
07:14:10 <pjdelport> luite: AIO is POSIX
07:14:13 <hpc> luite: hmm, i would suggest seeing what dropbox does, but i think they use nautilus :(
07:14:19 <rwbarton> well, to match the runtime you have to use ST I would think
07:14:21 <merijn> And as such it's probably not a good start to get a feeling for functional code
07:14:24 <pjdelport> (but not Windows)
07:15:01 <luite> hpc: linux has inotify (and a few others, I'm not sure which is most suitable), bsd has kqueue but it's actually useless for this (since you need to open all files/folders you want to watch), OS X has its own FSEvents API
07:15:32 <merijn> luite: kqueue at least works on both OSX and BSD :p
07:15:50 <Na-Fiann> would you say that similar problems don't occur often when writing real-world haskell, or is it something you often have to deal with. Just asking because I thought the appeal of funcitonal languages was that it made things more succinct
07:16:01 <luite> pjdelport: hmm, can you say that you want a callback for every file change under /var (for example) with AIO? and does it work on platforms other than linux?
07:16:36 <luite> merijn: but kqueue is useless, the ulimit for file descriptors in OS X is 2048 by default, if you want you watch even a moderately large folder with kqueue, you will exceed the number of available fd's
07:16:42 <pjdelport> luite: the canonical way of doing that is with gamin or such
07:17:01 <hpc> luite: https://en.wikipedia.org/wiki/File_alteration_monitor -- this should work on all unixy OSs
07:17:24 <pjdelport> luite: if you just want to do something quickly, you can pipe the output of fileschanged to something
07:17:42 <merijn> Na-Fiann: Well, the solution is usually that you don't use the same algorithm as you would in an imperative style. It's perfectly possible to write it in an imperative style if needed (i.e. if you cannot come up with a nice algorithm)
07:17:49 <rwbarton> Na-Fiann: it's easy for an experienced Haskell programmer to translate that imperative algorithm into an imperative Haskell program, if matching the run time is important.  It's just not a great place to start learning Haskell.
07:18:25 <merijn> Na-Fiann: The problem is that its much harder to think of new algorithms while you are still learning haskell
07:19:54 <merijn> Functional algorithms I mean. As rwbarton implementing imperative haskell is pretty easy, but you don't learn much functional programming that way :)
07:20:57 <Na-Fiann> ok thanks
07:21:06 <hpc> :t text
07:21:07 <lambdabot> String -> Doc
07:21:21 <merijn> Jesus, why do I seem to be leaving out so many words?
07:21:41 <merijn> It's like gremlins sneak into my send buffer and eat the bytes to make me look stupid...
07:22:54 <merijn> luite: Can't you increase that number using setrlimit?
07:33:47 <luite> merijn: dunno, I thought processes could only decrease their own limit, but even if it's possible to increase it, it's hardly ideal to open huge numbers of file descriptors, just for watching folders for file modifications
07:34:20 <luite> pjdelport: nah I want something that can be installed easily, without extra dependencies
07:34:48 <elliott> file notification? gamin?
07:34:49 <lambdabot> elliott: You have 1 new message. '/msg lambdabot @messages' to read it.
07:35:56 <luite> elliott: that's an extra dependency, not really ideal
07:38:37 <elliott> luite: most Linux systems will have gamin, I believe
07:38:49 <elliott> xfce uses it, I believe gnome does too
07:38:51 <tafryn> How has the usage of regular expressions changed in ghc 7? The examples in RWH no longer seem to work.
07:46:28 <sordina> Hi haskellers. I'm taking a stab at profiling some memory and time usage. I see heap usage being reported at around 400K, but when I look in my activity monitor on OS X it comes in at around 400M. What might be going on here?
07:46:49 <Sgeo> :t concatMap
07:46:50 <lambdabot> forall a b. (a -> [b]) -> [a] -> [b]
07:48:08 <sordina> Valgrind confirms the low usage.
07:48:20 <mm_freak_> sordina: "reported" by what?
07:49:10 <nand`> @check (=<<) == concatMap
07:49:10 <lambdabot>   "*Exception: (==): No overloading for function
07:49:33 <nand`> @check \a b -> (a =<< b) == concatMap a b
07:49:33 <lambdabot>   Overlapping instances for GHC.Show.Show (a -> [b])
07:49:34 <lambdabot>    arising from a use of...
07:50:22 <sordina> +RTS -p -RTS
07:50:45 <Sgeo> Of course I have to figure out how to do do-notation like things in Smalltalk
07:52:25 <luite> elliott: well the problem is that windows is the only platform for which there is no lower level filesystem monitoring binding available
07:52:40 <luite> the only major platform
07:52:52 <luite> (sorry BSD guys ;p )
07:53:45 <elliott> luite: ah
07:55:19 <luite> my first question was about windows filesystem monitoring libs for haskell, but then I got all these great suggestions for using POSIX things that work everywhere except windows, or something ;p
07:55:45 <qpu> Sgeo: w flatMap: [|x| ... ] flatMap: [|x| ... ] ?
07:55:46 <qpu> Sgeo: not really do notation though
07:55:46 <qpu> Sgeo: it's pretty ugly without syntax sugar in my experience (with Ruby)
07:56:25 <Sgeo> qpu, there's a gather: but no flatMap: in what I'm using
07:56:32 <Sgeo> And that's not quite Smalltalk syntax
07:56:34 <Sgeo> Lemme pastie
07:57:12 <Sgeo> http://pastie.org/3395650
07:57:29 <qpu> Sgeo: haha, yep
07:57:59 <Ngevd> Hmm...
07:58:03 <Sgeo> It's not that bad, except for the indentation which I guess does make it more readable
07:58:17 <qpu> Sgeo: whitespace isn't significant though, you could line them up at col 0
07:58:34 <Sgeo> Right
07:58:38 <ion> Not that dissimilar from
07:58:42 <ion> foo >>= \a ->
07:58:46 <qpu> Sgeo: but like you said, that can play tricks on your eyes
07:58:46 <ion> bar >>= \b ->
07:58:49 <ion> …
07:58:51 <qpu> yeah
08:00:15 <qpu> if the Ruby parser was extensible at runtime, it would be really cool to `require "do_notation"` and implement the sugar that way. maybe that's possible in Smalltalk?
08:01:03 <qpu> neither language has macros :\
08:03:42 <Sgeo> For what it's worth, in the Workspace, the indentation does not look as daunting
08:03:50 <Sgeo> Possibly due to the font
08:05:36 <tafryn> Is the new regular expression API documented anywhere because I sure can't find it.
08:05:51 <hpaste> Peter pasted “tail recursion” at http://hpaste.org/63825
08:06:05 <ion> For what purpose do you want regexps, btw?
08:06:11 <peterjoel> is this correct optimisation?
08:06:18 <ion> http://www.haskell.org/hoogle/?hoogle=regex
08:06:43 <peterjoel> Trying to make sure it tail recurses, and is strict
08:12:16 <qpu> peterjoel: i'm not an expert, but yes it's in tail form and i assume $! is the strict version of $. one way to be sure is to look at the Core (http://stackoverflow.com/questions/6121146/reading-ghc-core)
08:12:29 <tafryn> ion: All I'm looking for is a simple usage example. Everything in RWH and elsewhere on the internet is out of date.
08:13:07 <hpaste> Abraxas pasted “Heathrow” at http://hpaste.org/63826
08:13:15 <ion> For many purposes you’ll find parser libraries such as Trifecta or Parsec more useful than regexps.
08:13:56 <tafryn> For my current purposes, regexps are the best tool.
08:14:09 <tafryn> Well, they would be if they worked :-/
08:14:17 <Abraxas> i have tried the london to heathrow example from learnyouahaskell, at first without foldl
08:14:39 <rwbarton> the first regex example in RWH worked fine for me in ghc 7.0.4
08:14:45 <Abraxas> i have it a little different, because i define minpath data types
08:15:17 <elliott> tafryn: regexp problem?
08:15:19 <tafryn> rwbarton: Are you referring to this: "my left foot" =~ "foo" :: Bool ?
08:15:21 <rwbarton> yes
08:15:22 <elliott> tafryn: RWH? the API is changed
08:15:27 <elliott> tafryn: which example is failing
08:15:28 <peterjoel> qpu: Thanks. I haven't used explicit strictness before, and I wasn't sure if it was working because I haven't managed to find any noticeable difference - maybe GHC is automatically making it strict?
08:15:46 <Abraxas> now i would like to use a +-kind operator for minpath
08:16:44 <Abraxas> instead of the "costA + a" lines, i would like to add a MinPath directly instead of the integer in the MinPath
08:17:02 <Abraxas> link to the program is up there
08:17:25 <Abraxas> it should also add the node to the path
08:17:36 <peterjoel> qpu: also I'm only making the counter strict, while the other part of the calculation is (maybe) not strict. I find it all a bit confusing :S
08:18:02 <rwbarton> peterjoel: with optimizations GHC will figure out that collatzCountTR is strict in acc so that $! won't do anything
08:18:17 <tafryn> My problem seems to stem from the difference between ':module +Text.Regex.Posix' and 'import Text.Regex.Posix'.
08:18:39 <Abraxas> so for "newCostAOverA = costA + a" i would like to have "newCostAOverA = costA + <Road>" where <Road> is specifically a type of Road
08:19:12 <tafryn> I have been under the mistaken impression that the two were equivalent.
08:19:21 <Abraxas> the + operator should then add the cost to the Cost and the road to the Path
08:19:34 <rwbarton> peterjoel: collatzCountTR is also strict in its first argument, since the first thing it does is pattern match on it
08:20:14 <rwbarton> tafryn: indeed, how odd
08:20:27 <peterjoel> ok, so the counter probably doesn't need to be strict either?
08:20:30 <KitB_> Is haskell.org doing GSoC this year?
08:20:51 <Abraxas> the problem is i need to define something like "data Road = RoadA Cost | RoadB Cost | RoadC Cost" and then adapt Section somehow...but i can't make that work
08:21:02 <rwbarton> well it is important that it be strict, but GHC with optimizations should reliably figure that out for you
08:21:24 <peterjoel> ok, so no need for bangPatterns then (which is what I was just trying)?
08:21:39 <monochrom> do not speculate or intuit. read the core code to find out.
08:22:54 <tafryn> Ok, so what do I need to do to get regexes working with 'import Text.Regex.Posix'?
08:23:37 <rwbarton> it seems like just in ghci that it doesn't work
08:23:42 <rwbarton> (tafryn:)
08:24:22 <peterjoel> ok thanks monochrom, qpu, rwbarton
08:25:13 <rwbarton> it works in ghci when I do :m +Text.Regex.Posix, and also when I load a .hs file that imports Text.Regex.Posix, and also within a .hs file that imports Text.Regex.Posix
08:25:33 <rwbarton> the only scenario that doesn't work is literally typing "import Text.Regex.Posix" into ghci
08:25:36 <rwbarton> is that what you are seeing also?
08:25:41 <hpaste> Abraxas annotated “Heathrow” with “Heathrow (changed data defs)” at http://hpaste.org/63826#a63829
08:25:43 <tafryn> Yes.
08:25:50 <rwbarton> my recommendation is "don't do that then"
08:25:53 * hackagebot happstack-state 6.1.4 - Event-based distributed state.  http://hackage.haskell.org/package/happstack-state-6.1.4 (JeremyShaw)
08:25:54 <rwbarton> but it is very curious
08:26:03 <Abraxas> i annotated the parts i was trying to change
08:27:33 <Abraxas> example in question: http://learnyouahaskell.com/functionally-solving-problems#heathrow-to-london
08:30:55 * hackagebot happstack-server 6.6.2 - Web related tools and services.  http://hackage.haskell.org/package/happstack-server-6.6.2 (JeremyShaw)
08:30:57 * hackagebot happstack-server-tls 6.0.0 - extend happstack-server with https:// support (TLS/SSL)  http://hackage.haskell.org/package/happstack-server-tls-6.0.0 (JeremyShaw)
08:30:59 * hackagebot happstack 6.1.7 - The haskell application server stack + code generation  http://hackage.haskell.org/package/happstack-6.1.7 (JeremyShaw)
08:31:02 * hackagebot happstack 6.1.8 - The haskell application server stack + code generation  http://hackage.haskell.org/package/happstack-6.1.8 (JeremyShaw)
08:31:13 <rwbarton> tafryn: looks like this was fixed in ghc 7.4: http://hackage.haskell.org/trac/ghc/ticket/4832
08:33:35 <exFalso> hey, is there a way to define a <= relation for types? something like Less :: * -> * -> 'Bool with DataKinds?
08:33:45 <elliott> whatw ould it do?
08:33:53 <exFalso> it would compare types
08:34:30 <rwbarton> type family Less a b = True
08:34:31 <exFalso> it could be done with generics i think
08:34:45 <rwbarton> don't even need the "family"!
08:35:00 <exFalso> rwbarton: haha yeah almost what i was looking for
08:35:19 <exFalso> the goal would be to define type-sets
08:35:38 <exFalso> that is some collection of types without duplicates
08:35:53 * hackagebot happstack-hsp 6.2.8 - Support for using HSP templates in Happstack  http://hackage.haskell.org/package/happstack-hsp-6.2.8 (JeremyShaw)
08:36:11 <hpaste> Abraxas annotated “Heathrow” with “Heathrow (operator was wrong)” at http://hpaste.org/63826#a63830
08:40:16 <parcs`> you can write a 'class Eq a b (c :: 'Bool) | a b -> c' that works for all types
08:40:55 * hackagebot happstack-hamlet 6.2.4 - Support for Hamlet HTML templates in Happstack  http://hackage.haskell.org/package/happstack-hamlet-6.2.4 (JeremyShaw)
08:40:57 * hackagebot nixos-types 1.5 - this package is obsolete; see cabal2nix instead  http://hackage.haskell.org/package/nixos-types-1.5 (PeterSimons)
08:40:59 * hackagebot happstack-heist 6.0.7 - Support for using Heist templates in Happstack  http://hackage.haskell.org/package/happstack-heist-6.0.7 (JeremyShaw)
08:41:00 <exFalso> with overlapping instances?
08:41:13 <parcs`> yeah and a bunch of ether extensions
08:42:08 <qpu> parcs`: so 'Bool is not a value-level boolean, but type-level?
08:42:17 <hpc> qpu: indeed
08:42:35 <qpu> how do you do that? make 'Bool a type class with two instances?
08:42:44 <hpc> type kinds
08:42:48 <exFalso> qpu: -XDataKinds
08:43:08 <exFalso> qpu: a new extension in ghc 7.4 where you can "promote" simple data types to the kind level
08:43:10 <qpu> huh, learn something every ten minutes in here
08:43:21 <hpc> er, data kinds
08:44:09 <rostayob> exFalso: to the type level
08:44:17 <qpu> is this the "Giving Haskell a Promotion" paper?
08:44:18 <exFalso> rostayob: to the kind level
08:44:18 <rostayob> well.
08:44:19 <hpc> http://www.haskell.org/ghc/docs/latest/html/users_guide/kind-polymorphism-and-promotion.html#promotion
08:44:26 <rostayob> right
08:44:37 <rostayob> exFalso: I just wanted to contradict you :(
08:45:07 <hpc> technically, values become types and types become kinds
08:45:23 <rostayob> exFalso: it lifts type constructors to the kind level
08:45:30 <rostayob> and data constructors to the type level
08:45:37 <exFalso> ye
08:45:38 <exFalso> p
08:45:52 <mux> data constructors become type constructors, types become kinds
08:45:54 * hackagebot happstack-hstringtemplate 6.0.5 - Support for using HStringTemplate in Happstack  http://hackage.haskell.org/package/happstack-hstringtemplate-6.0.5 (JeremyShaw)
08:45:56 * hackagebot cabal2nix 1.27 - Convert Cabal files into Nix build instructions  http://hackage.haskell.org/package/cabal2nix-1.27 (PeterSimons)
08:46:08 <rostayob> exFalso: so your statement was terribly ambiguous.
08:46:19 <hpc> qpu: if you haven't checked out agda, you might want to do that; would make this whole thing seem almost obvious
08:46:52 <rostayob> qpu: yeah, if haskell is too low leve for you, try agda
08:46:57 <exFalso> rostayob: i dont have a good comeback, but you're wrong
08:48:29 <rostayob> qpu: dependent types are really fun anyways. but right now there is no practical dependently typed language. but learning agda is rewarding I guess
08:48:40 <rostayob> and agda is the closest to practical (after Coq maybe?)
08:49:24 <sclv> idris!
08:49:32 <sclv> idris is a practical dependently typed language.
08:49:36 <hpc> coq is like perl without the being able to do stuff with it
08:49:48 <hpc> ;)
08:49:50 <rostayob> sclv: ok, I haven't tried idris yet.
08:50:10 <rostayob> but I doubt it has fancy greek letters like agda.
08:50:23 <rostayob> I'd program in agda just for the syntax.
08:50:58 * hackagebot happstack-jmacro 6.0.2 - Support for using JMacro with Happstack  http://hackage.haskell.org/package/happstack-jmacro-6.0.2 (JeremyShaw)
08:51:00 * hackagebot happstack-lite 6.0.5 - Happstack minus the useless stuff  http://hackage.haskell.org/package/happstack-lite-6.0.5 (JeremyShaw)
08:51:05 <hpc> rostayob: same here, except for everyone's nasty habit of naming things the same as the types only sans-spaces
08:51:13 <ion> Hah. I love the description of happstack-lite.
08:51:32 <sclv> no unicode libraries, no cred. :-)
08:51:54 <hpc> seeing z+-f5<<=>-6 :: z + (- f f) << => -6 -- no thank you
08:52:11 <rostayob> hpc: that's  perfectly readable.
08:52:51 <hpc> rostayob: i would rather have a more descriptive name for the role of the object in the proof
08:53:08 <hpc> like, "associativity : longass type"
08:53:22 <qpu> rostayob: i've heard dependent types subsume many non-dependent-type system features, but i worry i'll be pulled down a rabbit hole. why aren't dependent types practical, or is it just a matter of time/momentum?
08:53:46 <hpc> qpu: it's mostly a newness thing
08:53:52 <notsmack> the blaze-html tutorial says, "the user would probably be pulled out of a reader monad instead of given as an argument in a realistic application"...  does anybody know of any examples of this?
08:54:05 <hpc> it took a while for OO to go from "obscure smalltalk" to "everywhere java"
08:54:10 <rostayob> qpu: disclaimer: I am a total noob when talking about dependent types
08:54:12 <rostayob> but
08:54:12 <sclv> its not just newness, but usability
08:54:15 <qpu> hpc: ah, i see
08:54:16 <rostayob> it's not just novelty
08:54:19 <sclv> which is an area of active research.
08:54:24 <notsmack> i'm having trouble wrapping my head around a transformer stack that would work
08:54:44 <sclv> something like idris is like haskell + dependent types
08:54:47 <rostayob> qpu: there are situations in which dependent types are an almost painless win
08:55:05 <rostayob> but in general to express the full force of dependent types you need a lot more thinking about what you're doing
08:55:18 <hpc> sclv: i put that under newness as well; if in the future there's been lots of time to solve the usability problem but no progress has been made, ill concede that point ;)
08:55:20 <sclv> but other approaches have focused more on the dt part and less on the others, and tend to force everything into the dt mold
08:55:26 <rostayob> and the advantages are debatable
08:55:29 <sclv> instead of letting you just use them as necessary
08:55:53 <rostayob> so I'm not sure that dependent types are the way to go for practical programming, while I'm sure that the H-M type system is great
08:55:59 <hpc> haskell seems to be pulling in the most useful forms of dependent types
08:56:14 <sclv> e.g. if i want to program in agda and not feel totally worthless, i'm going to need to learn to satisfy the termination checker for everything i do.
08:56:15 <hpc> ie, one level of "type depends on a simple value"
08:56:15 <rostayob> qpu: oh and obviously you don't have decidability, but that's understood
08:56:20 <sully> well, useful for functional programming purposes
08:56:34 <hpc> yeah, not the most useful proof purposes
08:56:34 <glguy> hpc: which forms of dependent types are those?
08:56:37 <sully> full blown dependent types are super useful for theorem provin'
08:56:42 <sclv> h-m isn't a type system. its a type inference algorithm /pedant
08:56:58 <hpc> glguy: type Triple = Vector Double 3 -- stuff like that
08:57:06 <tgeeky_> sclv: that's a pretty important (and not pedantic) disctinction
08:57:17 <rostayob> sclv: right. what I mean is "System-F without higher ranked types, and with those rules for recursion"
08:57:26 <rostayob> that make Haskell and ML type systems decidable
08:57:32 <glguy> hpc: why is that a dependent type, though?
08:57:40 <hpc> glguy: because 3 is a Nat
08:57:52 <glguy> a type-level nat, rather than a value-level nat
08:57:53 <hpc> data Nat = Z | S Nat deriving (Num)
08:58:07 <hpc> ^ is the Nat it is
08:58:26 <sclv> rostayob: right, which is why its a sort of pedantic point. because people (like you) tend to use hm interchangably with typeable by hm (with a few tweaks)
08:58:29 <exFalso> hpc: well with that definition it is -not- dependent
08:58:40 <glguy> hpc: dependent types are types that are dependent upon values
08:58:44 <rostayob> sclv: I think the correct name is just "ML"
08:59:22 <qpu> rostayob: by undecidable, you mean there exist terms which we can't prove/disprove they have a given type?
08:59:28 <hpc> (in that example, Vector was the dependent type, btw)
08:59:38 <rostayob> qpu: no, I mean that the type inference is undecidable
08:59:41 <glguy> hpc: no, 3 is a "type" in that example
08:59:46 <glguy> so that is not a dependent type
08:59:50 <sclv> glguy: which is the other big issue. if you actually want to distinguish between compile-time and runtime, then there's certain dependent typed things you have to rule out.
09:00:33 <qpu> rostayob: oh, is it similar to using RankNTypes and having to annotate *only* the higher-ranked types, or do you have to annotate much more?
09:01:11 <rostayob> qpu: yeah, higher ranked types are undecidable. so Haskell just puts all the quantifications at the beginning
09:01:20 <rostayob> also, there are some restrictions on recursion
09:02:12 <rostayob> specifically, the "temporary" type for the current function is not quantified, so if we use the function recursively the function will have the less-general type
09:02:13 <qpu> rostayob: i mean, with full-blown dependent types, does the type checker require annotations on everything? will it fail to terminate when trying to infer a type?
09:02:18 <rostayob> of its arguments
09:02:30 <rostayob> even when it's not necessarly, but that's rarely a problem
09:02:38 <hpc> qpu: there's limited inference
09:02:41 <rostayob> qpu: it requires a lot of type checking
09:02:56 <rostayob> but the point about dependent types is that there is a lot of type-level computation
09:03:06 <glguy> hpc: dependent types are where you have a function:    f : (x : Bool) -> if x then String else Double; f False = 0.5; f True = "10"
09:03:23 <rostayob> and the difference between values and types is blurred (and there is no difference at all between types and kinds)
09:03:25 <glguy> where the type of the function depends on the value of the arguments
09:03:28 <qpu> hpc: ok, so perhaps if i wrote terms that could be typed by HM, the dependent type system could infer them too?
09:04:20 <sclv> qpu: depends on the implementation
09:04:22 <rostayob> qpu: I'm not sure about that, it depends on which assumption the language makes I guess
09:04:28 <exFalso> glguy: nope, thats a third order function
09:04:53 <exFalso> dependent, but the result is a kind not a type
09:05:06 <exFalso> as in its Bool -> *
09:05:27 <sp3ctum_> i'm looking for a haskell parsec equivalent to the ? in regex
09:05:35 <glguy> exFalse: in this case "f" has a dependent type
09:05:35 <hpc> optional
09:05:42 <hpc> :t optional
09:05:43 <lambdabot> forall (f :: * -> *) a. (Alternative f) => f a -> f (Maybe a)
09:06:08 <rostayob> exFalso: why wouldn't that be dependent?
09:06:08 <sp3ctum_> i'd like to get some input  like so, a <- parserOfOptionalValue
09:06:25 <rostayob> it's type depends on a value, that's like the definition of dependent function
09:06:26 <hpc> sp3ctum_: a <- optional parserOfOptionalValue
09:06:30 <sp3ctum_> but not cause the parse to fail if the value isn't returned
09:06:30 <Abraxas> when i have this: "data Road = RoadA Cost | RoadB Cost | RoadC Cost", this doesn't work: "data Section = Section (RoadA Cost) (RoadB Cost) (RoadC Cost)"...because RoadA and so on are value constructors, right?
09:06:38 <hpc> sp3ctum_: case a of Nothing -> ...; Just value -> ...
09:07:07 <qpu> Abraxas: yes
09:07:14 <rostayob> exFalso: note that the function is not "returning" a type, but a value.
09:07:29 <Abraxas> how would i make this work?
09:07:34 <rostayob> the type of the "returned" value depends on the value of 'x'
09:07:43 <Abraxas> with extensions?
09:07:45 <exFalso> ah didnt read the end
09:07:47 <glguy> ah, perhaps he didn't see that there were 3 clauses
09:07:49 <sp3ctum_> hpc, thankyou
09:07:52 <sp3ctum_> looks like what i need
09:08:03 <qpu> Abraxas: one way is data Section = Section Cost Cost Cost, with the implication that the first value is for RoadA, etc
09:08:09 <hpc> sp3ctum_: when parsing, you can go far with Applicative/Alternative functions
09:08:33 <qpu> Abraxas: alternatively, data Section = Section Road Road Road
09:08:44 <Abraxas> that's what i had before, but i was trying something more complicated
09:08:55 <rostayob> exFalso: btw, there isn't difference between types, types of types, or types of types of types in Agda
09:08:55 <sp3ctum_> i'll look into those as well, thanks!
09:09:15 <rostayob> I mean there is, but it's all Set
09:09:26 <qpu> Abraxas: if you want to ensure every road is repsented in the second case, write your own function to construct a Section, mkSection Road Road Road that errors on bad arguments
09:09:44 <Abraxas> i want to use show on the Road values, depending on whether they are A, B or C
09:09:54 <exFalso> rostayob: well not the same set are they? type : Set 1, type of type : Set 2 etc
09:10:00 <rostayob> exFalso: yes
09:10:08 <rostayob> but they're the same "kind of thing"
09:10:23 <qpu> Abraxas: showRoad :: Road -> String; showRoad (RoadA c) = "..."; showRoad (RoadB c) = "...".
09:10:35 <exFalso> rostayob: overloading much? haha
09:10:47 <Abraxas> i mean, i need the value information in a variable for some type of road later on
09:11:02 <smoge> What is the Django equivalent in Haskell??
09:11:03 <Abraxas> http://hpaste.org/63826
09:11:05 <smoge> Yesod?
09:11:11 <smoge> Would like to know more before jumping into
09:11:14 <rostayob> exFalso: ehe.
09:11:40 <Abraxas> for "newCostAOverA = costA + a" the a is the Cost inside MinPath, so it's an int
09:11:43 <mekeor> ex falso quot libet.
09:11:56 <Abraxas> now i wanted to use a + operator on a MinPath instead
09:12:06 <exFalso> mekeor: indeed
09:12:11 <rostayob> _|_ -> A
09:12:22 <Abraxas> such that the Cost and Path of the MinPath are added to the other MinPath directly
09:12:32 <qpu> Abraxas: are you asking more than one question, or am i confused?
09:12:44 <luite> smoge: yesod unfortunately doesn't yet have an automatic admin interface, and the persistent database abstraction layer is a bit more limited
09:12:45 <Abraxas> Cost and Path of the Road, i mean
09:12:48 <qpu> Abraxas: i thought we were talking about how to show a road
09:13:27 <smoge> luite: is there a strong alternative to django made with haskell?
09:13:33 <Abraxas> no, i know how to show a road, but at that point in the program, there is no information about which Road it is
09:13:54 <qpu> Abraxas: but earlier you wrote data Road = RoadA Cost | RoadB Cost ...
09:14:05 <luite> smoge: the other frameworks aren't really much better in this respect, there is nothign that is as full featured and widely used
09:14:12 <Abraxas> so i wanted to make values for RoadA and so on for Road, but then i don't know how to define Section
09:14:27 <qpu> Abraxas: alternatively just add another field to the Road in your paste. data Road = Road Cost String
09:14:41 <smoge> luite: thanks for the info
09:14:47 <Abraxas> yeah, that's the easy solution :D
09:15:06 <qpu> Abraxas: as i said, you can define data Section = Section Road Road Road
09:15:12 <Abraxas> i basically try polymorphism(?) on Road
09:15:13 <luite> smoge: but you do get a lot of advantages over django, haskell is type safe, you have much stronger static guarantees, much higher performance and concurrency
09:15:38 <Abraxas> but then Section doesn't know the first one is RoadA
09:15:43 <luite> depending on your project, haskell might already be better than python
09:15:51 <smoge> luite: yes, I was aware of those advantages, and that's why I'm considering it for a new project
09:16:18 <smoge> luite: is there a good book/guide about those frameworks?
09:16:51 <qpu> Abraxas: it does if you always construct it that way. or, like i said, write a mkSection function. mkSection a@(RoadA _) b@(RoadB _) c@(RoadC _) = Section a b c
09:17:25 <luite> smoge: hmm, dunno, I mainly use yesod myself, the references for that would be the book (yesodweb.com) and wiki there, mailing list + irc ( #yesod ) for questions
09:17:37 <qpu> Abraxas: you can also add patterns for arguments in other orders, then finally mkSection _ _ _ = error "need at least one of each: RoadA, RoadB, RoadC"
09:17:41 <smoge> thanks
09:17:54 <adimit> How can I get (Floating a, Real b) => a -> b?
09:18:08 <adimit> or is that not something that makes sense? It should…
09:18:28 <luite> smoge: snap has a quickstart and introduction on its site, dunno about happstack
09:18:35 <Abraxas> ah, mksection, ok
09:18:43 <Abraxas> i was trying something similar to operator overloading for MinPath
09:18:53 <Abraxas> but i don't know if it can be done in haskell
09:19:00 <rwbarton> adimit: Complex numbers are Floating
09:19:00 <mekeor> adimit: what do you mean by "how can i get" ?
09:19:23 <qpu> Abraxas: you'll need to read about type classes. but it's more-or-less possible
09:19:24 <adimit> mekeor: that was badly englished for "where's the function that…"
09:19:52 <Abraxas> ok thanks!
09:19:54 <mekeor> adimit: ah, okay
09:20:02 <mekeor> @hoogle (Floating a, Real b) => a -> b
09:20:03 <lambdabot> Unsafe.Coerce unsafeCoerce :: a -> b
09:20:03 <lambdabot> Prelude ($) :: (a -> b) -> a -> b
09:20:03 <lambdabot> Data.Function ($) :: (a -> b) -> a -> b
09:20:03 <adimit> rwbarton: yeah, sure, except that I have a number that's Floating, and one that's an instance of Real, and I can't use (*) on them — I want the result to be Real again.
09:20:09 <byorgey> adimit: you can't.
09:20:17 <rwbarton> well, what if the first one is a complex number
09:20:25 <adimit> byorgey: aw.
09:20:27 <rwbarton> you need to know something else about it
09:20:50 <adimit> the first one is one that I sent through (**(-1)).
09:20:58 * hackagebot happstack-server 6.6.3 - Web related tools and services.  http://hackage.haskell.org/package/happstack-server-6.6.3 (JeremyShaw)
09:21:01 <adimit> so I guess what I wanted didn't make sense after all.
09:21:16 <byorgey> adimit: it can make sense if, say, the first thing is ALSO an instance of Real
09:21:21 <Abraxas> does the LANGUAGE GADTs extension have something to do with this?
09:21:29 <rwbarton> you should think more about the types and less about the type classes
09:21:29 <adimit> byorgey: yeah, but (**) doesn't guarantee it.
09:21:42 <rwbarton> unless your input is polymorphic
09:22:05 <byorgey> adimit: but (**) DOES guarantee to give you back the same type as what you put in.
09:22:11 <byorgey> that's the most important point.
09:22:22 <adimit> rwbarton: What I'm actually trying to do is multiply a NominalDiffTime by a fraction.
09:22:24 <rwbarton> "a number that's Floating" is not complete information
09:22:31 <rwbarton> okay
09:22:33 <byorgey> just because you ran something through (**) doesn't mean you suddenly need to be able to deal with any Floating type.
09:22:45 <byorgey> you only need to be able to deal with the particular types you put in.
09:22:46 <adimit> byorgey: true…
09:23:23 <adimit> so I need the result to be (Real a, Floating a) => a
09:23:28 <adimit> *input, not result.
09:23:45 <byorgey> adimit: oh, don't use (**(-1)) to take the reciprocal of something.  use 'recip'.
09:23:50 <byorgey> @type recip
09:23:50 <lambdabot> forall a. (Fractional a) => a -> a
09:24:06 <adimit> huh. whaddayaknow. recip should do the job nicely. Thanks :-)
09:24:15 <hpc> @src recip
09:24:15 <lambdabot> Source not found. This mission is too important for me to allow you to jeopardize it.
09:24:40 <ion> > x^^(-1)
09:24:41 <lambdabot>   recip x
09:24:54 <hpc> hehe
09:24:55 <rwbarton> > x**(-1)
09:24:56 <lambdabot>   x**negate 1
09:25:04 <hpc> recip x = 1/x
09:25:04 <byorgey> adimit: next time, start by explaining what you actually want to do instead of some smaller step you think you need to do in order to accomplish it =)
09:25:18 <ion> A.k.a. the X-Y problem
09:25:23 <byorgey> indeed.
09:25:33 <adimit> byorgey: you're right. You know, I usually do that, but this time, I thought I'd figured it out, and I needed one last simple step.
09:25:42 <adimit> note to self: you've never really figured it out.
09:25:42 <byorgey> hehe
09:25:42 <eacameron> I'm trying to do something simple and Haskell seems to be making it hard. I want to POST to a webpage with some a hard-coded JSON string.
09:26:00 <rwbarton> the fact that you are asking #haskell for help with your "simple step" might indicate that it's not so simple. :)
09:26:15 <byorgey> adimit: try to get into the habit of saying things like "I want to do X. I think I can accomplish that by doing Y, does anyone know how to do that?"
09:26:22 <eacameron> The only example I have found is with Network.HTTP and it requires constructing headers and all that jazz
09:26:26 <adimit> byorgey: good habit to get into!
09:26:29 <byorgey> adimit: then others can judge at which level to answer the question.
09:26:34 <eacameron> isn't there a library that hides that from me?
09:27:22 <adimit> rwbarton: I thought my hoogle-fu was just not up to the task. I didn't know my (g/h)oogle-fu had already failed me at the (**) vs. recip stage.
09:27:45 <adimit> anyway, now I can have a pretty progress bar. ETA and all!
09:27:47 <adimit> thanks :-)
09:27:56 <byorgey> =)
09:28:09 <cmccann> and once again the day was saved thanks to #haskell
09:28:18 <byorgey> and there was much rejoicing
09:28:26 <cmccann> \o/
09:28:30 <adimit> #haskell has saved my ass so many times, I'm feeling like a leech already…
09:28:42 <ion> We do like to save donkeys.
09:28:54 <cmccann> adimit, you're not leeching, just building up a debt
09:28:56 <adimit> donkeys are pretty :-)
09:29:13 <cmccann> you'll have to repay it all eventually by helping others
09:29:23 <adimit> cmccann: I know, and when I'm doing my phd, I can probably teach folks one or two things.
09:29:25 <TomMD> A debt that can be repayed by administering the switch to Hackage2
09:29:26 <adimit> I usually try :-|
09:29:48 <cmccann> TomMD, that's a pretty steep price to ask of anyone I  think :P
09:29:50 <osa1> cabal says I have some files missing in some packages, how can I reinstall these packages?
09:29:56 <TomMD> Oh, I know.
09:30:00 <adimit> TomMD: i'd rather file for mental  bankcruptcy than do web-administration of any kind.
09:30:06 <TomMD> I didn't say it was necessary, just sufficient.
09:30:13 <nyingen> s/administering the switch to/taking the blame for/
09:30:15 <nyingen> :)
09:30:42 <cmccann> TomMD, speaking of which, I should get back to convincing hackage2 to use less than a terabyte of memory to run
09:30:58 <nyingen> cmccann: eh, just increase the swap partition
09:31:10 <TomMD> cmccann: That sounds like a worthy task.  I wish you luck.
09:31:18 <nyingen> multi-TB drives are cheap these days, right?
09:31:33 <TomMD> And a 1TB RAM system is only what?  80k?
09:32:35 <cmccann> TomMD, right now every package is kept in memory using a record type holding approximately five hundred Strings
09:32:54 <dcoutts> cmccann: it's only taking 3.2 Gb atm :-)
09:33:09 <cmccann> heh
09:33:10 <TomMD> cmccann: So you're going to farm it out to an SQL db?
09:33:15 <adimit> cmccann: smallstring and/or text have helped me keep down memory in the past.
09:33:30 <cmccann> yeah, I'm just replacing String with Text in lots of places at the moment
09:33:36 <dcoutts> adimit: that's basically our plan, more compact and selecting just the bits we need
09:33:39 <TomMD> But beyond saving a constant - I think this strategy needs changed.
09:34:00 <adimit> I'm doing a lot of corpus-linguistics which per definition needs tons of strings in memory, so I know the basic procedure there :-P
09:34:15 <dcoutts> TomMD: it's a deliberate choice, in-mem Haskell data structures, not sql db
09:34:47 <nyingen> adimit: you are also a haskell-using linguist?
09:34:59 <adimit> nyingen: one of the few, yeah :-)
09:35:05 <nyingen> actually it seems like there are a few of us on here
09:35:09 <TomMD> I have some recollection of that - and suppose if the constant savings is large enough then we won't have to worry until hackage grows a couple orders of magnitude.
09:35:28 <adimit> there are indeed. ANd there's the haskell-nlp mailing list, but 'tis very quiet.
09:36:16 <adimit> I've actually grown averse to using any kind of String data anywhere. premature optimization or not, spelling out String in Haskell hurts my fingers.
09:36:48 <hpc> that's why you type [Char] instead ;)
09:36:52 <nyingen> IMO the thing is that it's not that easy to drop Text in for String, since the former is supposed to be imported qualified
09:36:54 <cmccann> String isn't anywhere near as bad as people make it out to be for transient use
09:37:02 <eacameron> Anyone know of an HTTP library that does POSTs to a page really simply (hiding creation of headers, etc.)? For example: post "http://page" "{json data}"
09:37:11 <cmccann> you just really don't want lots of static Strings in memory
09:37:19 <CodeWeaverX> I think I shall start using strings to do matrix multiplication.
09:37:24 <CodeWeaverX> <.<  >.>
09:37:26 <nyingen> I find it very hard to avoid using String at all in "real programs" since sometimes a library you're using does not support Text
09:37:26 <CodeWeaverX> n.n
09:37:56 <adimit> oh, String is OK, as long as you don't have to actually *do* anything with it, like keep it in memory or use it as data.
09:38:20 <hpc> what's with all the string hate?
09:38:39 <cmccann> adimit, and the same is true of lists in general
09:38:42 <nyingen> hpc: it's not char*, so people think it's inefficient
09:38:46 <adimit> … nothing really, i've an irrational fear of them,
09:39:07 <CodeWeaverX> Embrace the mighty list.
09:39:09 <cmccann> you don't want to use [] for storing large chunks of data either
09:39:19 <adimit> cmccann: yeah, that's true, I can't use lists for most of the things I'm doing nowadays either.
09:39:28 <hpc> lists are very composition-friendly
09:39:35 <nyingen> There's a question on the C-FAQ about that: "hey, i wrote char[1238382838234] and it doesn't work, what gives?"
09:39:45 <hpc> nyingen: hahaha
09:39:59 <cmccann> but if you're getting some strings as input, doing simple list-y operations on them, and then discarding them after some processing, it's fine
09:40:13 <rwbarton> char x[∞]
09:40:18 <adimit> cmccann: totally agreed, that's what strings are good for.
09:40:26 <CodeWeaverX> char x[-∞]
09:40:28 <cmccann> whereas the PackageDescription stuff from Cabal and things like that are just horrific
09:40:43 <elliott> cmccann: Good example :P
09:40:49 <nyingen> rwbarton: well, in haskell you can actually have something like char x[∞], right?
09:40:52 <elliott> oh wait, that's what you were talking about
09:40:54 <cmccann> elliott, oh hi
09:40:55 <elliott> cmccann: did you see the commit I linked you?
09:40:58 <cmccann> yes
09:41:01 <hpc> nyingen: yes, it's called String ;)
09:41:01 <cmccann> I started hacking on it
09:41:03 <elliott> cool
09:41:10 <cmccann> initial space reductions are less than hoped for
09:41:21 <elliott> cmccann: I decided after giving up for the night that we need to migrate _all_ the Cabal types
09:41:23 <cmccann> currently building with an earlier GHC so I can get heap profiles :P
09:41:28 <elliott> because mixing and matching is silly
09:41:30 <cmccann> yeah I kind of discovered that as I went
09:41:31 <adimit> Text stores everything in UTF-16, btw.
09:41:53 <hpc> adimit: wtf?
09:42:07 <hpc> i find that hard to believe
09:42:26 <dcoutts> hpc: it was implemented both ways, twice, utf16 won both times
09:42:36 <adimit> haddock: "a Text value is represented as packed UTF-16 data"
09:42:39 <cmccann> elliott, I'm thinking that pretty much everything under Distribution.Package needs to be switched
09:42:46 <hpc> oh i see
09:42:49 <ion> UTF-16 is rather unnice.
09:43:01 <adimit> hpc: for extreme space-efficiency, I go with smallstring.
09:43:11 <ion> (conceptually)
09:43:21 <adimit> and there was a GSOC proposition or so to port Text to UTF-8. No idea where that went.
09:43:32 <nyingen> adimit: but how do you address the problem that library X, which you need, only allows String/ByteString/Text/whatever ?
09:43:43 <dcoutts> adimit: it was completed successfully, utf16 was still faster
09:43:47 <elliott> cmccann: oh, well I knew those had to be
09:43:51 <adimit> nyingen: yell at maintainer of library x.
09:43:54 <elliott> cmccann: I mean every type in Distribution.*
09:44:03 <cmccann> hm
09:44:06 <elliott> cmccann: did you write an equivalent of GenericPackageDescription?
09:44:09 <elliott> because those are what Hackage2 stores
09:44:13 <elliott> not PackageDescriptions directly
09:44:17 <adimit> dcoutts: yeah, but I sometimes need memory-efficiency over time-efficiency.
09:44:19 <cmccann> yes
09:44:26 <ion> UTF-16 was created as a fixed-width charset. Then they noticed “oh shit, we have more than 2¹⁶ code points” and kluged variable-width support into it.
09:44:27 <elliott> cmccann: right... what about dcoutts' alternate CondTree?
09:44:36 <ion> s/charset/encoding/
09:44:40 <cmccann> as well as implementing conversions for some of the types as I went
09:44:44 <cmccann> I left CondTree as it was
09:44:56 <dcoutts> adimit: sure, different tradeoffs in different use cases, it's tricky for a general purpose text lib
09:45:01 <elliott> I figure we should pretty much just make Distribution.Fast.* :P
09:45:26 <dcoutts> more like .Compact
09:45:33 <adimit> dcoutts: absolutely. I'm not mad at Text for being UTF-16, I'm glad that smallstring exists :-)
09:46:13 <TomMD> If you're willing to accept some semantic trade-offs, I can upload my "TinyString" package.
09:46:17 <dcoutts> adimit: right, I'd like to see "small" versions in both bytestring and text packages, ones that only support simple ops like Ord
09:46:34 <c_wraith> Ord, Eq, Hashable
09:46:37 <c_wraith> That should suffice
09:46:42 <adimit> i'm pretty happy with text's performance. When I need to do lots of transformations, I usually convert everything to Text, because it's fast and supports lots of good stuff (like caseFold, etc.)
09:46:52 <cmccann> elliott, I was thinking of just pulling it out as a separate library with the same module structure as the relevant bits of Cabal
09:47:15 <elliott> cmccann: yeah, that would probably be best, although we don't need to reimplement all of Cabal
09:47:19 <elliott> just the types we use
09:47:25 <elliott> cmccann: for example, it's fine to use Cabal's parser
09:47:29 <elliott> and convert immediately after parsing
09:47:35 <adimit> TomMD: I've no immidate need for it. But i'm curious, what are your semantic tradeoffs?
09:47:38 <elliott> that's probably easier than effectively maintaining a fork
09:47:49 <dcoutts> elliott: yep, pretty much essential for compatibility
09:47:51 <cmccann> right, just the relevant bits, then let that library re-export from Cabal as needed
09:48:04 <dcoutts> elliott: I'm rewriting the parser too, but it's a compat nightmare :-)
09:48:18 <elliott> cmccann: well re-exporting isn't enough, we'll need to compose with conversions, but yeah
09:48:39 <cmccann> well, yeah
09:48:44 <cmccann> re-export and/or wrap as needed
09:49:54 <cmccann> elliott, anyway, I currently have it building and running using the Text versions of stuff
09:50:01 <elliott> cmccann: that's good
09:50:06 <elliott> cmccann: what did you do about all the uses of "display"?
09:50:19 <elliott> cmccann: we should probably make a Text version of that class too
09:50:22 <cmccann> yes
09:50:23 <elliott> which is called Text
09:50:24 <elliott> just to be confusing
09:50:26 <cmccann> but I didn't do that yet
09:50:52 <dcoutts> elliott: yeah, sorry, it existed before the text package :-)
09:51:13 <cmccann> dcoutts, "didn't have Text back then" seems to be a running theme :P
09:51:17 <dcoutts> yep :-)
09:51:57 <dcoutts> cmccann, elliott: I'm very happy for you to try this and I'll incorporate what I can into cabal-lib-2.x along with other things I've been working on
09:52:57 <cmccann> dcoutts, I still haven't figured out how to send commits from git back to darcs unfortunately
09:53:11 <dcoutts> cmccann: there's a thing called darcs-bridge
09:53:18 <elliott> cmccann: well there's http://hackage.haskell.org/package/darcs-fastconvert
09:53:30 <cmccann> yes, darcs-fastconvert is what I'm using
09:53:31 <elliott> but I doubt darcs -> git -> darcs will be lossless enough
09:53:32 <byorgey> darcs-bridge isn't usable at the moment for sending patches from git back to darcs
09:53:33 <elliott> to push back
09:53:38 <cmccann> and I think darcs-bridge is the successor to that
09:53:40 <elliott> but you could try
09:53:42 <dcoutts> cmccann: I've not used it personally, but a colleague of mine uses it with his git branches and a darcs upstream, says it works well
09:53:46 <byorgey> there are bugs, but owst is working on it
09:53:55 <cmccann> but yeah, that's how I'm getting stuff from darcs to git right now
09:54:07 <cmccann> e.g. note that I did pull from darcs and push more stuff to my github
09:54:13 <parcs`> @quote use the right
09:54:13 <elliott> cmccann: well it can go the other way too
09:54:13 <lambdabot> No quotes for this person. I've seen penguins that can type better than that.
09:54:16 <elliott> so you could try that
09:54:20 <elliott> @quote platitude
09:54:20 <lambdabot> ddarius says: "use the right platitude for the job"
09:54:27 <dcoutts> byorgey: oh, we've found it ok so far
09:54:28 <parcs`> hehehe
09:54:31 <parcs`> love that quote
09:54:50 <byorgey> dcoutts: well, it wedged my bridge. =)
09:55:02 <cmccann> elliott, yes, the trick is that I don't know enough about darcs to figure out how to make it happen
09:55:14 <cmccann> and a crash course on darcs isn't really what I want to be spending time on right now :T
09:55:29 <eacameron> I found what I was looking for (a function to make an HTTP post with the body instead of constructing everything myself): Network.HTTP's postRequestWithBody. Not sure how I missed that before!
09:55:32 <byorgey> darcs really isn't that hard to learn.
09:55:59 <elliott> cmccann: you can pick up darcs in two minutes, really
09:56:00 <owst> dcoutts: are you using the hackage version?
09:56:19 <dcoutts> owst: of darcs-bridge? I don't think so
09:56:29 <owst> Ah good, as there isn't one :-)
09:56:30 <byorgey> there's a Hackage version?
09:56:37 <dcoutts> owst: yeah, I didn't think so :-)
09:56:38 <byorgey> ah =)
09:57:00 <owst> darcs-bridge doesn't exist anywhere except when talking about the thing that I might eventually work out how to fix
09:57:02 <dcoutts> owst: I've not used it yet, it's my colleague, I checked it out from darcs the other day, not used it yet
09:57:25 <owst> It turns out that encoding git branching/merging into darcs is easy, but decoding again is a real pain to get right.
09:59:06 <cmccann> at any rate, as long as I can get stuff from darcs into git and make sure there aren't any crazy divergences between them, I intend to put off worrying about the other direction until we have some significant improvements working :P
09:59:28 <cmccann> as well as hoping that someone else will step up and take care of it in the meantime
10:00:06 <dcoutts> cmccann: I got the feeling that bgamari might
10:00:11 <owst> Hmm, in fact dcoutts, I'd suggest you *don't* use the current version from my darcsden repo for anything serious, it *will* break in the presence of anything but the simplest merges coming from git.
10:00:29 <byorgey> you can always export a .patch file using git, apply it in the darcs repo using 'patch' and then record.
10:00:37 <dcoutts> owst: don't worry, it's an improvement on manually re-recording :-)
10:01:00 <owst> Oh, going from darcs -> git is fine, assuming no branches are involved
10:02:09 <cmccann> owst, for context, this is the hackage2 repository, specifically dcoutts' darcs repo and my GitHub
10:03:13 <elliott> cmccann: anyway, you should push your stuff to github so I can take a look :P
10:04:22 <adimit> is there a hackage 2.0 github repo?
10:04:47 <parcs`> yeah
10:05:07 <cmccann> elliott, I'll get it pushed in a bit, was seeing if I can profile things quickly and figure out why it didn't improve much
10:05:10 <parcs`> http://code.haskell.org/hackage-server
10:05:21 <owst> adimit: https://github.com/isomorphism/hackage2
10:05:38 <cmccann> and I need to clean up some of the horrific mess I made while discovering that I needed to replace more of the cabal types
10:06:16 <adimit> owst, parcs`, thanks :-)
10:06:27 <cmccann> adimit, and yeah, owst's link is my github, elliott has a fork as well
10:07:21 <elliott> cmccann: heh, I probably should have told you
10:07:41 <elliott> cmccann: btw
10:07:51 <elliott> cmccann: one thing that might hurt is that the vectors are boxed
10:08:01 <elliott> OTOH unboxing the other data types will probably be a huge pain
10:08:47 <mkscrg> I'm having a hard time grokking how finalizers work. Can someone explain to me why this code does what it does? http://hpaste.org/63832
10:09:23 <mkscrg> (This is the current iteration of the problem elliott and i were working on yesterday morning.)
10:10:23 <elliott> hmm, which problem was that?
10:10:39 <mkscrg> the problem with that ffi library throwing exceptions on 7.4.1
10:11:00 <mkscrg> finally found it was due to a finalizer running prematurely
10:11:16 <elliott> ah
10:11:29 <adimit> cmccann: how do you commit back to the darks repo though?
10:12:12 <hpc> mkscrg: yeah, that's definitely a premature finalization
10:12:14 <cmccann> good question
10:12:23 <hpc> could be some strange optimization, or just a bug
10:12:26 <ion> Premature finalization affects many men.
10:12:32 <hpc> lol
10:12:35 <mkscrg> lol
10:12:49 <mkscrg> that happens when compiled without any -O flags
10:13:09 <elliott> adimit: we'reh andling cmccann to push things upstream
10:13:13 <elliott> once he figures out how
10:13:17 <elliott> not handling... relying on
10:13:53 <adimit> yeah, I prefer github for doing coding, but I'd be afraid the changes wouldn't get back upstream…
10:14:06 <elliott> they will, don't worry
10:14:06 <adimit> is there some darcs-version of something githubby?
10:14:17 <elliott> considering some major git-based effort is in the works
10:14:20 <elliott> and there are tools to do it
10:14:28 <elliott> adimit: yes, but they're not nearly as good (IMO)
10:14:38 <adimit> ok, that's good to hear. I'll  see if I can find some time to look at the code in the near future.
10:14:44 <adimit> like, Saturday.
10:15:08 <cmccann> I'm putting off figuring out the upstream push issue until there's enough significant changes in github that I can't put it off any longer :P
10:15:20 <adimit> wise choice, tbh :-P
10:15:43 <mike-burns> Isn't the GH repo the upstream?
10:15:52 <elliott> It's the midstream.
10:16:02 <mkscrg> hpc: can you think of anything else i should to to investigate or just throw it on haskell-cafe/glasgow-haskell-users?
10:16:07 <elliott> mike-burns: Every git repo goes to cmccann goes to the darcs upstream, theoretically.
10:16:08 <mkscrg> *do to
10:16:33 <cmccann> but right now the streams are running a bit dry
10:16:34 <mike-burns> What does it mean forthe darcs to be upstream? Is Hackage2 live somewhere?
10:16:44 <elliott> mike-burns: Upstream = official repo.
10:16:48 <elliott> And yes, several places.
10:16:51 <cmccann> and there's a long stretch of dangerous rapids that noone has crossed alive between me and darcs :P
10:16:52 <hpc> mkscrg: i can't think of anything, but i also don't do much of that kind of IO code
10:16:56 <elliott> http://hackage2.uptoisomorphism.net:8080/
10:16:59 <elliott> and the full mirror whose domain name I forget
10:17:00 <hpc> wait for someone who knows more than me
10:17:08 <mike-burns> elliott: I've seen that, but the upstream for that is GH.
10:17:18 <elliott> mike-burns: yes, dcoutts has one running on the darcs
10:17:23 <elliott> that's a full hackage mirror
10:17:26 <owst> cmccann: feel free to pop into #darcs for help when you do - if I'm about I'll be hopefully able to answer questions :)
10:17:34 <elliott> theoretically the uptoisomorphism one will be more up to date but have fewer packages
10:17:41 <cmccann> owst, ok, thanks.
10:17:51 <mike-burns> This is all politically confusing.
10:18:12 <elliott> mike-burns: I don't see why.
10:18:18 <cmccann> assuming this Text stuff helps I'll mirror as much as possible to mine
10:18:23 <elliott> The darcs repo is official; cmccann is handling darcs<->git bridging.
10:18:41 <cmccann> where "handling" is defined as "procrastinating on"
10:18:43 <elliott> So anyone who wants to use git can just go via cmccann, and the git repo will probably be more up-to-date in general.
10:19:06 <mkscrg> anybody else want to dive in on a finalizers problem?
10:19:12 <elliott> cmccann: If we convert every type and it doesn't help, then maybe we should use UTF-8 ByteStrings.
10:19:12 <mike-burns> elliott: The fact that darcs is upstream but less up-to-date and ignored by mostly everyone ... is confusing.
10:19:25 <elliott> mike-burns: nobody's ignoring it
10:19:31 <mike-burns> I didn't say everyone.
10:19:37 <elliott> I said nobody
10:20:03 <mike-burns> How would one send a pull request to the actual upstream?
10:20:06 <cmccann> mike-burns, it's more that everyone who seems actively interested in doing major work on this prefers github
10:20:14 <mike-burns> That's right.
10:20:15 <elliott> mike-burns: email
10:20:22 <mike-burns> To dcoutts ?
10:20:23 <elliott> "darcs send" probably
10:20:31 <owst> mike-burns: darcs send
10:20:32 <mike-burns> How do I clone the darcs repo?
10:20:41 <owst> You go 'man darcs'
10:20:43 <elliott> if you don't know how to use darcs, maybe use the git version :P
10:21:00 <dcoutts> mike-burns: hackage.haskell.org/trac/hackage/wiki/HackageDB/2.0/
10:21:15 <elliott> that thing needs a more memorable url :P
10:21:31 <mike-burns> Aha.
10:21:44 <mike-burns> Oh this is super useful.
10:21:44 <osa1> I have hundreds of files missing in my packages(checked with ghc-pkg check) is there a command to download them?
10:21:52 <elliott> cmccann: have you tried hackage-mirror(1) btw?
10:22:03 <cmccann> tried in what sense
10:22:28 <elliott> to use it instead of the backup thing
10:22:31 <cmccann> for mirroring packages to my server?
10:22:43 <elliott> to your local machine
10:23:20 <cmccann> not really, though I might do that later
10:23:23 <parcs`> osa1: are you talking about the haddock warnings?
10:23:29 <parcs`> you can ignore those
10:23:51 <cmccann> as it stands the full index would probably make my system fall over, even skipping the convert and restore steps
10:23:57 <osa1> parcs`: no, I'm trying to install some libraries from cabal and cabal gives errors about missing files
10:24:38 <parcs`> osa1: oh, i don't know anything about that
10:24:50 <suki89> hello anybody here?
10:25:12 <suki89> can anyone please tell me whether it is ok to use cloud storage on storing sensitive data in an Android application?
10:25:34 <mike-burns> suki89: You want #android-dev .
10:30:22 <suki89> everybody is sleeping in #android-dev :(
10:30:59 * hackagebot hackport 0.2.16 - Hackage and Portage integration tool  http://hackage.haskell.org/package/hackport-0.2.16 (SergeiTrofimovich)
10:31:03 <parcs`> try ##php
10:31:25 <parcs`> or another equally irrelevant channel :P
10:31:39 <suki89> hehe
10:32:00 <suki89> do you have any idea about cloud computing?
10:32:52 <Azel> suki89: Perhaps you could go to #haskell-blah ? Your question is on a different enough from Haskell to be relevant there
10:33:46 <suki89> I just need to know whther it is safe to store sensitive data on could storage
10:33:58 <mike-burns> No.
10:34:00 <ion> Yes.
10:34:07 <cmccann> maybe.
10:34:08 <adimit> that's a philosophical question at best. so I don't think #haskell can answer it.
10:34:10 <ion> Mu.
10:34:12 <suki89> erm is it No or Yes :\
10:34:15 <Azel> Perhaps. define "sensitive"
10:34:16 <ion> Yes.
10:34:19 <plucas> Encrypted, maybe.
10:34:23 <ion> It is no or yes.
10:34:28 <suki89> like credit card details
10:34:35 <mike-burns> @faq Can Haskell safely store sensitive data on cloud storage?
10:34:35 <lambdabot> The answer is: Yes! Haskell can do that.
10:34:42 <ion> You can store credit card details on #haskell.
10:34:43 <mike-burns> OK, the answer is yes.
10:34:43 <adimit> suki89: it's best to store those on my hard drive.
10:35:00 <suki89> hehe
10:35:55 <Azel> I would rather not then...if you do heavily encrypt them, kowing you'll have to replace your encryption sooner or later
10:36:51 <nyingen> I don't think Haskell Curry would have approved of cloud storage
10:37:11 <suki89> so SQLite will be better than cloud storage
10:37:37 <elliott> suki89: please take it to some other channel
10:38:38 <suki89> ok sorry ...... and thank you everyone
10:47:21 <suki89> main = putStrLn "Goodbye, Haskell!"
10:49:22 <adimit> is there some idiom I can use to make get >>= put.(+1) look less … dunno. offensive?
10:49:23 <Sugarlake> hhaasskkeell
10:49:56 <cmccann> adimit, using (=<<) might be nicer
10:50:03 <cmccann> to make it look more like the function application it is
10:50:05 <liyang> modify (+1)
10:50:23 <adimit> liyang: modify is pretty, thanks :-)
10:50:57 <adimit> cmccann: I actually like that >>= displays it like "first get, then put"
10:51:10 <cmccann> depends on what you're doing
10:51:21 <cmccann> I usually prefer function application style for inline expressions
10:51:45 <cmccann> if I want to read it as "do this, then do that" I'm likely to use a do block
10:54:32 * cmccann is amused to note that Eric Lippert is by far the highest-scoring user on Stack Overflow for the "contravariance" tag
10:54:50 <c_wraith> cmccann: is he a scala guy?
10:54:54 <cmccann> no
10:54:55 <cmccann> C#
10:54:58 <c_wraith> interesting
10:55:18 <c_wraith> I guess you can rack up score much faster when you focus on languages with more than 20 questions per day
10:55:27 <cmccann> and when I say he's a C# guy I mean he's one of the people on the C# compiler team
10:55:57 <c_wraith> I recognized the name as being involved in some language, I just couldn't remember which
10:58:25 <elliott> cmccann: I think he used to do functional programming stuff, going by some of his answers I've seen
10:58:46 <elliott> actually I get the impression the people behind C# know a lot of FP in general
10:58:51 <cmccann> not sure about used to but he's at least somewhat comfortable with Haskell I think
10:59:07 <cmccann> pretty sure he wrote a few monad tutorials about LINQ :P
10:59:10 <elliott> yeah, Haskell = FP in general :P
11:00:07 <sclv> sigh. i tried to answer an so question on conal's vector space
11:00:08 <byorgey> also 'contravariance' comes up a lot more often in a language with subtyping.
11:00:18 <sclv> and realized that i've never actually tried to use it.
11:00:26 <sclv> someone should help this poor soul: http://stackoverflow.com/questions/9313994/derivative-towers-and-how-to-use-the-vector-space-package-haskell
11:00:43 * byorgey has used vector-space, though not the derivative towers part
11:01:12 <cmccann> byorgey, yeah, I was thinking about it because of http://stackoverflow.com/q/9302739/157360
11:01:45 <cmccann> and wondered what sort of activity the covariance and contravariance tags had in general
11:01:55 <hpc> sclv: i would, but vector-space is one of those polymorphic soup packages that i try to stay away from
11:02:19 <elliott> hpc: it is?
11:02:22 <elliott> it seems rather clear to me
11:02:31 <cmccann> sclv, the question has a pretty obvious type error but I'm not sure what the correct way is without trying it myself
11:02:40 <cmccann> and I'm somewhat occupied at the moment
11:02:45 <sclv> elliott: aha, then you should answer the question!
11:02:47 <elliott> cmccann: wow, you got 31 points on that quickly
11:02:55 <byorgey> cmccann: ah, right.  nice answer.
11:03:08 <hpc> elliott: hmm, i might be remembering something else
11:03:23 <elliott> sclv: well, I haven't actually used it all that much :P
11:03:41 <cmccann> yeah I'm never quite sure why some answers jump to 25+ and others that seem to be of similar quality and length don't
11:03:54 <sclv> probably interest level
11:03:57 <cmccann> I'm rep cap'd so hard today :P
11:04:01 <sclv> + reposts
11:04:45 <elliott> cmccann: pfft, not that bad
11:04:46 <byorgey> cmccann: is there a feedback effect?  i.e. upvoted answers tend to get read more (and hence upvoted more)?
11:04:47 * cmccann still getting occasional upvotes on http://stackoverflow.com/q/9190352/157360 as well, despite it being a week old
11:04:49 <elliott> I had over 17 votes go down the drain yesterday
11:04:53 * byorgey is not exactly sure how SO works
11:04:57 <cmccann> elliott, I've lost more than that :P
11:05:00 <elliott> byorgey: upvoted answers aren't really displayed prominently anywhere
11:05:05 <byorgey> ok
11:05:11 <elliott> byorgey: but people might be more likely to upvote if it's highly-upvoted and they thought it was good, perhaps
11:05:11 <cmccann> byorgey, there can be but not to a huge degree
11:05:23 <aadrake> Hello Haskell.  I just posted this to the mailing list, but I thought you may be interested as well.  We have a job opening for a Data Scientist at our Berlin office and we are looking for someone with a Haskell background.  If you are appropriate or know someone who is, please contact us.  http://madvertise.com/en/2012/02/14/data-scientist-fm/
11:05:26 <cmccann> yeah, if someone sees a highly-voted answer they might read it more carefully
11:05:28 <sclv> I was all about the rep till I hit whatever it was that gave me the cute mod toys
11:05:39 <cmccann> yeah, I kinda stopped caring around 10k :P
11:05:40 <sclv> then I realized that I didn't actually like modding
11:05:48 <byorgey> hehe
11:05:51 <cmccann> I enjoy it occasionally
11:05:53 <elliott> cmccann: one day I kept track of how much I lost, and IIRC I "should" have got over 600 that day... then I started worrying about my SO habit :P
11:05:59 <tromp__> import Data.Scientist
11:06:01 <cmccann> I've locked so many questions, you have no idea
11:06:26 <aadrake> tromp__: I wish it were that easy.  :)
11:06:39 <cmccann> byorgey, also note that users have a limited number of votes to cast per day, so that cuts down on the bandwagoneering a bit
11:06:41 <`Zerax`> Data Scientist is a pretty cool job title though
11:06:49 <cmccann> there's a much more limited supply of votes to go around
11:07:14 <hpaste> mmos1127 pasted “mutable arrays” at http://hpaste.org/63834
11:07:15 <elliott> cmccann: Do most people really worry about that?
11:07:17 <sclv> Imagination Scientist would be even cooler :-)
11:07:18 <elliott> I don't really vote much, maybe they do.
11:07:31 <mmos1127> see hpaste for question about mutable arrays
11:07:40 <sclv> I've never hit the upvote cap except for a few days when I deliberately used lots of votes to get one of those badges you get for using lots of votes.
11:07:51 <cmccann> elliott, I suspect it changes default behavior more than anything else
11:07:57 <mmos1127> I need some pointers to documentation that really explains it for beginners
11:08:16 <mmos1127> Hey I just remembered RWH explains some of this, I think.
11:08:33 <sclv> mmos1127: Start with plain old IO arrays
11:08:42 <mevluding> djahandarie: hey
11:08:43 <sclv> and get used to them.
11:08:56 <sclv> if you haven't already. then STArrays will be very intuitive, almost.
11:09:28 <sclv> the s is a phantom type that's closed over polymorphically, to ensure that things inside runST can't escape runST.
11:09:32 <mmos1127> sclv: what if I need to use mutable arrays in pure code? Are you saying start with them to develop my understanding?
11:09:33 <cmccann> sclv, when I'm being more active on SO I try to consistently upvote good questions
11:09:39 <sclv> mmos1127: precisely.
11:10:05 <elliott> yeah, I care more about question voting than answers
11:10:08 <sclv> STArrays are just IOArrays inside a runST block, and with that funny s in their types, basically.
11:10:18 <elliott> mostly I downvote terrible questions :P
11:10:18 <sclv> and the tricky bits in using them are just in getting the typing right.
11:10:19 <cmccann> answers seem to get more votes in the haskell tag so I think it's worth encouraging good questions
11:10:34 <mmos1127> sclv: I guess I don't have enough understanding to make any sense of your description of 's' but it sounds like you are saying I can just trust in the magic.
11:10:35 <sclv> So this line, for example, doesn't quantify over the Ss properly: arr <- newArray (1,10) 37 :: ST s (STArray s Int Int)
11:10:42 <cmccann> and downvoting bad questions is always useful
11:10:57 <sclv> instead you can annotate the arguments to newArray directly.
11:11:03 <elliott> cmccann: I'm not sure it is, really, other than a signal to other people to ignore it
11:11:14 <elliott> people who ask really bad questions don't seem to care how many downvotes they get
11:11:23 <sclv> if you find yourself needing to use the "s" inside the definition of a function.
11:11:38 <mmos1127> sclv: the example does run -- what is the consequence of not quantifying over the Ss "properly"?
11:11:47 <cmccann> elliott, there are filters
11:11:50 <sclv> oh, huh. color me surprised.
11:11:51 <elliott> sclv: it quantifies perfectly fine.
11:11:53 <elliott> that's
11:11:58 <elliott> :: forall s. ST s (STArray s Int Int)
11:12:01 <cmccann> the all-seeing eye notices every downvote
11:12:02 <elliott> which is fine
11:12:10 <elliott> cmccann: hehe
11:12:33 <mmos1127> okay thanks everyone -- looks like I have to do some good old study and maybe come back with more specific questions
11:12:34 <cmccann> users that get heavily downvoted and especially lots of closed questions will be blocked from asking more
11:12:40 <lukish> Is there a module to convert HSL to RGB colors?
11:12:54 <rwbarton> @hackage colour
11:12:54 <lambdabot> http://hackage.haskell.org/package/colour
11:13:06 <sclv> mmos1127: take a look here, maybe: https://en.wikibooks.org/wiki/Haskell/Existentially_quantified_types
11:13:28 <lukish> rwbarton: thnx
11:13:31 <elliott> ST uses universal, not existential
11:13:31 <mee> tibbe, snapframework.com seems to be down.
11:14:16 <cmccann> elliott, universal quantification in contravariant position is existential by duality
11:14:39 <osa1> wtf cabal. I can't install any libraries from cabal because cabal can't use libraries which I already installed in system(like base, oldtime, unix).
11:14:44 <elliott> cmccann: well... you could express runST as an existential, sure
11:14:55 <elliott> but I'm not sure learning about existential types will help understand runST
11:15:57 * cmccann shrugs
11:17:32 <byorgey> osa1: sounds like your installation is hosed.
11:18:18 <osa1> byorgey: what does that mean?
11:18:32 <byorgey> it means you should reinstall everything and start over, sadly.
11:18:36 <elliott> osa1: messed up. broken. unusable. screwed.
11:18:43 <mmos1127> What type does an MArray freeze into?
11:18:59 <byorgey> osa1: you may also want to read http://www.vex.net/~trebla/haskell/sicp.xhtml
11:19:03 <osa1> does anyone have any ideas about fixing this?
11:19:10 <elliott> osa1: rm -r ~/.cabal ~/.ghc
11:19:21 <elliott> Don't upgrade boot packages this time, and yes, read that link byorgey linked.
11:19:35 <byorgey> there's no need to remove ~/.cabal .
11:20:39 <mike-burns> Use cabal-dev.
11:20:40 <sclv> mmos1127: freeze :: (Ix i, MArray a e m, IArray b e) => a i e -> m (b i e)
11:22:07 <sclv> So for an MArray indexed by i, with elements e, in monad m, we get an IArray indexed by i with elements e, returned in monad m.
11:22:19 <sclv> The input marray can be IOU, STU, IO or ST
11:22:32 <sclv> the output can be UArray or Array
11:23:57 <mmos1127> sclv: okay thanks, I just got 'freeze' to work like I expected. cool.
11:25:29 <Ralith> Where can I find a formal definition of the meaning of => in the context of an instance declaration in terms of logic?
11:27:19 <Ralith> I intuit that it implies mutual implication of its left and right hand sides; is this accurate?
11:27:23 <sclv> Ralith: http://www.haskell.org/onlinereport/decls.html#sect4.1
11:27:49 <byorgey> Ralith: no.  It is an implication from left to right.
11:27:59 <byorgey> Ralith: however, that's not helpful in understanding how instance selection actually works.
11:28:12 <byorgey> instance selection works right to left.
11:28:36 <Ralith> byorgey: But the type reconstructer can infer Eq a from Eq [a].
11:28:38 <byorgey> that is, it decides on an instance based only on the part to the right of the =>, and then generates subgoals based on what's to the left of =>
11:29:17 <Ralith> if => is just left to right implication, how can that be valid?
11:29:29 <byorgey> Ralith: hmm, perhaps you're right
11:29:30 <hpaste> mmos1127 pasted “mutable arrays” at http://hpaste.org/63835
11:30:00 <mmos1127> quick question at hpaste if someone can look
11:30:10 <mdxbhmt> Anyone has recomendations for any GA library on hackage?
11:30:23 <byorgey> Ralith: it corresponds to the fact that given   Foo a => Bar a,  a dictionary for Foo will be a subfield of the dictionary for Bar.
11:30:37 <byorgey> Ralith: the Bar instance itself tells you how to build a Bar dictionary given a Foo dictionary.
11:30:39 <mmos1127> oh, to clarify, my example is not a good way to use immutable arrays but it's something I would build upon if I start using mutable arrays
11:30:51 <byorgey> but of course, given a Bar dictionary, you can project out the Foo dictionary.
11:31:13 <dolio> No you can't.
11:31:28 <Ralith> byorgey: yeah, I feel that I understand it in implementation terms; I'm trying to work out the formal meaning in set theoretic/logic terms.
11:31:32 <byorgey> dolio: ?
11:32:03 <dolio> You can only project out a Foo dictionary if you have 'class Foo a => Bar a'.
11:32:10 <Ralith> reaffirming the implementation details does indeed seem to support mutual implication implication though.
11:32:13 <dolio> Not 'instance Foo a => Bar a'.
11:32:23 <byorgey> ah, right, sorry
11:32:28 <elliott> Ralith: "instance (Eq a) => Eq [a]" reads misleadingly.
11:32:29 <byorgey> I was confusing class vs instance
11:32:38 <elliott> Ralith: The instance resolver _just_ sees "Eq [a]".
11:32:45 <elliott> Ralith: It then ensures that Eq a, and if it is not true, gives up.
11:32:51 <elliott> So there cannot be another (...) => Eq [a] instance.
11:33:25 <Ralith> byorgey: ah, so it's mutual implication but only in a *class* declaration?
11:33:34 <Ralith> elliott: er, why not?
11:33:49 <byorgey> Ralith: yes, I think so
11:34:23 <dolio> I don't think it's ever mutual implication.
11:34:52 <byorgey> Ralith: note that given a constraint of the form Eq [a] you *cannot* infer Eq a.
11:34:53 <dolio> 'class Foo a => Bar a' says that Foo is a prerequisite for Bar, so Bar implies Foo.
11:35:09 <byorgey> Prelude> let f :: Eq [a] => a -> a -> Bool; f x y = x == y
11:35:10 <dolio> 'instance Foo a => Bar a' says that you can construct a Bar instance given a Foo instance.
11:35:18 <byorgey> Could not deduce (Eq a) arising from a use of `=='
11:35:34 <mmos1127> question: http://hpaste.org/63835
11:35:56 <elliott> Ralith: Open-world assumption.
11:35:58 <byorgey> ah, dolio is right as usual
11:36:21 <Ralith> hm.
11:36:26 <elliott> Ralith: Adding an instance cannot change the meaning of an existing, valid program.
11:36:34 <elliott> consider if we allowed
11:36:41 <elliott> instance (Eq a) => Eq [a]
11:36:43 <elliott> and then someone added
11:36:48 <elliott> instance (MyRandomClass a) => Eq [a]
11:36:54 <elliott> and we have a program that uses Eq [Foo]
11:36:59 <elliott> where Foo is an instance of both Eq and MyRandomClass
11:37:24 <Ralith> elliott: oh, so it's just specified to be impossible to prevent ambiguity and permit separate compilation?
11:39:48 <sclv> mmos1127: if it works then it works :-)
11:40:05 <sclv> for something like that, obviously, you can just create an array directly.
11:40:46 <elliott> Ralith: Also to simplify implementation.
11:41:03 <elliott> Ralith: Haskell 2010 does not require implementing Prolog in the compiler.
11:41:03 <Ralith> right.
11:41:07 <Ralith> hah
11:41:33 <elliott> It's not really so much "specified as impossible" as "the rules as specified in a form that happens to forbid it".
11:41:35 <sclv> mmos1127: for example, see the listArray function.
11:41:49 <tsousa> hey, does anyone has some good exercises to do in haskell?
11:42:00 <mmos1127> sclv: it don't mean a thing if it aint got that successful compilation and execution
11:42:18 <byorgey> doo wop doo wop doo wop
11:42:23 <sclv> in general, if you're not mutating an array but just constructing it in some funny manner, you don't need mutable arrays at all.
11:42:35 <mee> tsousa, http://courses.cms.caltech.edu/cs11/material/haskell/index.html
11:42:40 <byorgey> tsousa: what sort of exercises?
11:42:51 <Ralith> tsousa: project euler!
11:42:53 <mmos1127> sclv: yeah, this snippet is just a stand-in for something that WILL need mutable arrays. Just wanted to see if I could get it to compile
11:43:09 <elliott> Are you sure it'll need mutable arrays?
11:43:23 <tsousa> byorgey, i dont care, i want to improve my haskell knewlodge and my programming experience
11:44:13 <mdxbhmt> doing project euler I saw how hard programming is...
11:44:41 <mmos1127> elliott: you might have a point: I guess I was only interested in efficiency, but the program will probably run fine with immutable arrays
11:44:42 <byorgey> tsousa: you could also take a look at the assignments from the class I'm teaching, http://www.cis.upenn.edu/~cis194/lectures.html
11:44:45 <tsousa> project euler is math
11:44:46 <elliott> Project Euler is mostly mathematics, not programming.
11:44:53 <elliott> That is also why it is bad at teaching programming.
11:44:58 <mmos1127> elliott: you might have just saved me some trouble
11:45:11 <elliott> mmos1127: There are other ways to be efficient, generally. Though sometimes you *do* need mutable arrays.
11:45:14 <elliott> But usually you can do without.
11:46:03 <tsousa> byorgey, thanks
11:46:30 <tsousa> byorgey, it is a introduction course to programming. i see universitys use haskell to introduction to programming
11:47:04 <byorgey> tsousa: no, it's not.
11:47:16 <byorgey> though UPenn does use OCaml in part of its intro programming course.
11:47:39 <akosch> Has someone used the ftphs client against filezilla? I think I may have found a bug.
11:47:40 <byorgey> it's just an elective half-credit course I'm teaching for undergrads who want to learn Haskell.
11:47:51 <elliott> akosch: ftphs is buggy in general, I think.
11:48:16 <akosch> elliott: are there any alternatives?
11:49:05 <elliott> akosch: ftp-conduit?
11:49:06 <mee> byorgey, congrats on having the prettiest homework assignments I've ever seen :)
11:49:14 <elliott> http://hackage.haskell.org/packages/archive/ftp-conduit/0.0.4/doc/html/Network-FTP-Conduit.html Bit minimal.
11:49:48 <tsousa> byorgey, so it uses a lot of functional programming. that nice :)
11:50:03 <akosch> elliott: thanks, I'll try it. I really don't want to resort to calling a command-line client through system.process :(
11:50:17 <djahandarie> I still want to teach an intro to programming course which immediately starts with GADTs in like the first 5 minutes
11:50:39 <mkscrg> byorgey: just noticed jpmayer is your TA. he applied for a job with my company before taking his current job
11:51:00 <mkscrg> i was excited to talk haskell in his interview but we didn't get that far
11:52:41 <luite> I have a feeling that byorgey is lying to me in the first exercise :(
12:02:11 <PatrickRobotham> What's the first exercise?
12:02:21 <luite> credit card validation
12:03:59 <PatrickRobotham> Does anyone know a good tutorial for Generalized Algebraic Data Types?
12:04:24 <hpc> PatrickRobotham: the wiki page is pretty good iirc
12:04:33 <hpc> i might also be remembering the wikibook so try both
12:05:04 <hpc> the basic idea is, GADTs let you constrain the result types of constructors
12:05:28 <tibbe> mee: not my project, blame greg :)
12:05:31 <hpc> so instead of Foo :: a -> Bar a, you have
12:05:36 <hpc> Foo :: a -> Bar String
12:05:39 <hpc> or something like that
12:06:50 <hpc> pretty much the rest of the wiki/wikibook pages is going to be examples of GADTs being used for different things
12:07:19 <sclv> conal: your help is required: http://stackoverflow.com/questions/9313994/derivative-towers-and-how-to-use-the-vector-space-package-haskell
12:07:20 <sclv> :-)
12:07:38 * conal looks
12:10:55 <adimit> stupid question: why does ghc not strip? (the binaries it produces.)
12:11:11 <elliott> ghc doesn't either :P
12:11:22 <elliott> erm
12:11:22 <elliott> gcc
12:11:28 <stepcut> are there any compression libraries for Haskell that would allow me to compress a bunch of individual ByteStrings using a shared dictionary? I want to use it for a compressed Data.Map type, (something like this, http://hpaste.org/63836)
12:11:59 <adimit> yeah, it doesn't but ghc produces huge binaries, that can be significantly reduced in size by strip.
12:12:34 <adimit> then again, there's no real need I guess.
12:12:50 <mee> tibbe, oops, sorry
12:12:56 <tibbe> mee: no worries
12:12:58 <Cale> Yeah, most everyone has lots of disk space and a good bit of memory these days
12:13:11 <tibbe> mee: let people at #snapframework know perhaps?
12:13:17 <mee> yeah I did
12:13:22 <adimit> Cale: I actually have to upload a binary to a server, and my home connection's speed sucks. So that's why I strip stuff.
12:13:30 <Cale> and the size of the executable doesn't really matter compared to the size of actual data being manipulated usually
12:13:33 <Cale> ah
12:14:00 <Cale> I also think I might have heard of some issues with using strip in general on GHC-produced binaries, but I don't know if those were solved or what.
12:14:33 <Cale> If the resulting binaries are working for you, I wouldn't worry too much
12:14:38 <adimit> that's what I suspected might be the case…
12:14:48 <adimit> yeah, it's working for the most part.
12:14:49 <sclv> stepcut: this may fit the bill -- http://hackage.haskell.org/package/compressed
12:14:55 <sclv> not sure how efficient it is.
12:15:17 <adimit> I mean, my program seems to have a bug I can't reproduce on my home machine, but that doesn't seem to be strips's fault :-P
12:15:38 <sclv> it has a pretty explicit representation of dictionaries at least
12:15:38 <Cale> adimit: You might also try compiling with shared libraries
12:16:44 <adimit> Cale: good idea. I'll see if I can do that.
12:23:19 <krakrjak> anyone know why Network.Socket won't build?
12:23:55 <hpaste> krakrjak pasted “Network.Socket FTBFS” at http://hpaste.org/63838
12:31:38 <lukish> How can I convert RGB :: Double to RGB :: Int ?
12:31:53 <shachaf> Neither one looks very valid.
12:32:01 <lukish> There are from Data.Colour
12:33:09 <c_wraith> lukish: which package?
12:33:24 <elliott> colour, prseumably
12:33:30 <elliott> lukish: Do you mean (RGB Double) and (RGB Int)?
12:33:30 <byorgey> that's roconnor's package
12:33:37 <byorgey> you can ask him if/when he's around
12:34:06 <c_wraith> I would bet the *very first* function in the docs is what you're looking for
12:34:09 <c_wraith> convertColor
12:34:24 <c_wraith> Oh, you said RGB, not Color
12:34:28 <zzo38> Did hpaste literate Haskell fixed now?
12:34:56 <c_wraith> Well, RGB is a functor instance
12:35:02 <c_wraith> So, worst case, you can always use that
12:35:18 <lukish> elliott: yes
12:36:14 <elliott> I suspect RGB Double is using [0,1] elements.
12:36:18 <zzo38> It looks like it doesn't
12:36:21 <elliott> Rather than 0 to 255.
12:36:35 <cmccann> I would hope it's using [0,1]
12:36:43 <c_wraith> why limit yourself to 1?
12:36:54 <lukish> λ> hsl 359 1 50
12:36:54 <lukish> RGB {channelRed = 1.0, channelGreen = 99.0, channelBlue = 97.36666666666673}
12:37:01 <elliott> Oh.
12:37:04 <elliott> Then just fmap f.
12:37:06 <c_wraith> Wasn't there research done that showed if you remove that limit, you can do all kinds of crazy stuff?
12:37:07 <lukish> I want 1 99 97
12:37:08 <elliott> For some f in truncate, round, etc.
12:37:18 <elliott> ceiling, floor, ...
12:37:25 <cmccann> c_wraith, allowing values outside the defined range is useful
12:37:35 <cmccann> defining the defined range to be [0,1] is also useful
12:37:39 <cmccann> these are separate issues
12:37:48 <c_wraith> well, how about calling that the representable range
12:37:58 <lukish> elliott: fmap truncate works fine, thanks
12:40:12 <tromp__> @pl \f x y -> (f x,f y)
12:40:12 <lambdabot> flip =<< (((.) . (,)) .)
12:40:41 <elliott> tromp__: (f *** f)
12:40:46 <elliott> I suggest defining both = join (***)
12:41:00 <elliott> oh, wait
12:41:04 <elliott> it'd be curry (both f)
12:41:19 <hpaste> abcdefg pasted “hello world” at http://hpaste.org/63839
12:41:41 <tromp__> @let hanoi n = [(i.&.pred i`mod`3,succ(i.|.pred i)`mod`3)|i<-[1..2^n-1]] in hanoi 3
12:41:41 <lambdabot>   Parse error: in
12:42:06 <tromp__> > let hanoi n = [(i.&.pred i`mod`3,succ(i.|.pred i)`mod`3)|i<-[1..2^n-1]] in hanoi 3
12:42:07 <lambdabot>   [(0,2),(0,1),(2,1),(0,2),(1,0),(1,2),(0,2)]
12:43:17 <tromp__> :t both
12:43:18 <lambdabot> Not in scope: `both'
12:48:30 <nyingen> @quote
12:48:31 <lambdabot> <monochrom> says: the selfish program's motive is to fool the programmer
12:48:53 <lukish> How can I get hex value of (RGB Int) ?
12:49:24 <c_wraith> like an html/css color code?
12:49:34 <RichyB> @hoogle RGB
12:49:35 <lambdabot> Graphics.Rendering.OpenGL.GL.PixelRectangles.Rasterization RGB :: PixelFormat
12:49:35 <lambdabot> Graphics.Rendering.OpenGL.GL.PixelRectangles.ColorTable RGB' :: PixelInternalFormat
12:49:35 <lambdabot> Graphics.Rendering.OpenGL.GL.PixelRectangles.ColorTable RGB10 :: PixelInternalFormat
12:50:01 <lukish> c_wraith: yes
12:50:11 <elliott> @forget <monochrom> the selfish program's motive is to fool the programmer
12:50:11 <lambdabot> Done.
12:50:13 <elliott> @remember monochrom the selfish program's motive is to fool the programmer
12:50:13 <lambdabot> It is stored.
12:50:29 <elliott> lukish: Format each component as hex.
12:50:33 <elliott> Concatenate the result.
12:50:40 <elliott> Or just printf "%02x%02x%02x".
12:50:40 <c_wraith> in RGB order
12:50:43 <elliott> Yes.
12:50:56 <gwern> 'What is it like to work with Dr. Friedman and Oleg Kiselyov?' 'Oleg is an emissary from some advanced alien race. Working with him is both exhausting and enlightening.'  http://clojure.com/blog/2012/02/16/take5-william-byrd.html
12:51:37 <gwern> @remember WilliamByrd Oleg is an emissary from some advanced alien race. Working with him is both exhausting and enlightening.
12:51:37 <lambdabot> I will never forget.
12:51:39 <gwern> @flush
12:51:45 <elliott> @flush
12:51:53 <gwern> elliott! that's wasteful
12:51:54 <elliott> Is it silent?
12:51:55 <elliott> Scary.
12:52:13 <elliott> gwern: I don't actually know what @flush does. Although I have a guess.
12:52:25 <gwern> it should be obvious that flushing twice is wasteful
12:52:50 <krakrjak> not as wasteful with low flow....
12:53:14 <krakrjak> sometimes when I have to get the plunger after it I have to flush 3 or 4 times.
12:53:33 <elliott> I don't want to know where lambdabot stores messages.
12:53:48 * krakrjak *grumbles* low flow means no sucking power.
12:54:06 <stepcut> krakrjak: got flush a few times during the dumping process
12:54:34 * krakrjak rofl
12:54:56 <krakrjak> stepcut: and we're back to the toilet humour.
12:55:11 <krakrjak> So did I miss any suggestions about Network.Socket not building?
12:58:00 <DanBurton> Hello everyone, I've come to shamelessly spam you in order to whore up more karma on reddit: http://www.reddit.com/r/haskell/comments/pswbp/hope_for_haskell_making_hackage_and_cabalinstall/
12:58:06 <cmccann> can't sleep strings will eat me
12:58:07 <cmccann> can't sleep strings will eat me
12:58:09 <cmccann> D:
12:58:33 * cmccann considers seppuku
12:58:39 <DanBurton> also as part of a devious plot to secure a student position in GSOC
12:58:46 <qpu> why don't compilers do high-level optimizations like solving linear recursive functions (eg, fibonacci) to produce an O(1) solution? too much effort and use case not common enough?
12:59:36 <luite> DanBurton: unix only? noooooooooooooooooooooooooooo!
12:59:52 <shachaf> cmccann: This channel is incompatible with sleep anyway.
13:00:24 <alpounet> DanBurton, have you read about Hackage2 ?
13:00:27 <DanBurton> luite: xD that's the idea...to make these things obvious and upfront
13:00:47 <luite> does unix only still include freebsd and os x?
13:00:48 <DanBurton> alpounet: I'm aware of it. Haven't read about exactly what features it has
13:00:59 <cmccann> it's very good at using memory
13:01:04 * hackagebot biopsl 0.2 - Library and executables for working with PSL files  http://hackage.haskell.org/package/biopsl-0.2 (KetilMalde)
13:01:07 <alpounet> DanBurton, well, you share some goals with it
13:01:13 <qpu> i imagine number crunching programmers perform the optimizations on paper first. but maybe there's a general approach for non-number crunching algorithms. like if fib was defined on strings "", "a", "b", "ab", ...
13:01:19 <alpounet> you really should read a bit about it
13:01:35 <cmccann> DanBurton, on a more serious note, yes, hackage stuff is already happening-ish currently
13:01:41 <cmccann> so that's possibly going to be in flux
13:01:41 <alpounet> to improve your proposal and in particular make your proposal more consistent with the current efforts spent on hackage2
13:01:53 <cmccann> also, your scope sounds a bit too wide
13:02:08 <luite> yeah a lot of these things have already been planned, but I guess the related packages could do with a summer of student love
13:02:20 <cmccann> so I'd suggest cutting out the hackage side and focus on improvements for cabal-install or something equivalent
13:02:24 <alpounet> last summer Gracenotes worked on hackage2
13:03:13 <DanBurton> alpounet: indeed, I see Hackage 2 as a definite step in the right direction
13:04:04 <alpounet> DanBurton, it is, and well, you really should talk to the right people (??? Duncan Coutts would be one of them i guess) to see who's doing what, what would be available for a GSoC student to work on, etc
13:04:12 <DanBurton> alpounet: I'm putting "Hope" forward as the possibility to build off of Hackage (or Hackage 2) without complicating the experience for people that just want to upload a little library to Hackage and have their friends cabal-install it
13:04:20 <luite> when do the final prposals have to be sumitted?
13:04:25 <DanBurton> alpounet: indeed
13:04:39 <cmccann> DanBurton, I still think you're overreaching
13:04:49 <cmccann> don't overestimate what you can accomplish in a summer
13:04:59 <luite> yeah a lot of these things are also rather vague
13:05:00 <DanBurton> cmccann: oh I'm not at all proposing to do all this myself over a single summer
13:05:09 <luite> and sometimes it's not clear if they're all that useful
13:05:18 <luite> do people really want an uninstall feature?
13:05:19 <cmccann> ok. thought this was all aimed more directly at a GSoC proposal
13:05:21 <alpounet> cmccann, well, indeed, but after talking to the hackage2 crew (which you somehow are a member of right?) the goals will be modified i guess
13:05:46 <cmccann> yes I am apparently a member of the hackage2 crew whatever that actually means
13:05:54 <DanBurton> lol
13:05:56 <cmccann> my role so far has been to complain a lot mostly
13:06:01 <luite> upgrade feature also more or less exists
13:06:20 <alpounet> cmccann, hah, not the hardest role i guess
13:06:59 <cmccann> anyway, yeah, I think elliott and myself have been doing most of the purposeful rabble-rousing
13:07:26 <cmccann> dcoutts is the official person who's stuck with hackage until further notice
13:07:39 <cmccann> several other people have been involved as well so far
13:08:32 <cmccann> DanBurton, here's my hackage2 repo btw: https://github.com/isomorphism/hackage2
13:09:19 <cmccann> there's also a darcs repo belonging to dcoutts, which is linked to from my github repo page
13:09:59 <cmccann> dcoutts is also the person to talk to about general Cabal-related stuff I think, as far as building off of cabal-install &c. goes
13:11:37 <DanBurton> cmccann: good to know
13:12:14 <elliott> DanBurton: adding lots of features will make hackage2 even more delayed than it is
13:12:33 <elliott> although many of them have already been proposed
13:13:10 <DanBurton> elliott: that's why I suggest making a separate website
13:13:20 <elliott> ah, I only skimmed
13:13:21 <DanBurton> to draw from hackage and add metadata
13:13:41 <cmccann> elliott, btw, I've got most of the alternate modules roughed out with data types defined for things that need it
13:13:48 <elliott> it would be cool, if it existed -- though I think things such as ratings belong in hackage2 itself and the codebase is expressly designed for such extensibility
13:13:51 <elliott> cmccann: woot
13:14:22 <DanBurton> I guess I underestimated the extent of the changes in hackage2
13:14:34 <cmccann> elliott, think you'll want to work on it tonight?
13:14:41 <DanBurton> maybe Hope = hackage3 then
13:15:00 <elliott> DanBurton: hackage2 is, user-facing, pretty much hackage1 with some extra features, for now
13:15:07 <elliott> but the codebase is designed to support the kinds of things you want
13:15:23 <elliott> I think we should concentrate on making hackage2 usable in production, get it on hackage.haskell.org, and then start thinking about nice user-facing features
13:15:52 <elliott> cmccann: I'm a bit busy this second, but probably soon, yes
13:16:07 * elliott doesn't know what cmccann considers "night" :)
13:16:40 <alpounet> hackage2 is happstack powered, right?
13:16:40 <cmccann> the next 5-6 hours or so I guess :P
13:16:55 <cmccann> want to know how quickly I should get it unbroke enough to push to github
13:17:19 <elliott> well, take your time, I'll probably be occupied for another hour or two
13:17:25 <elliott> alpounet: yes, although it's probably not "idiomatic"
13:17:29 <elliott> it builds a lot of its own stuff
13:17:35 <elliott> not that I know what is considered idiomatic in happstack
13:18:00 <alpounet> like what?
13:18:39 <sclv> it has a fancy system for components which can share access to the state of the packagedb
13:18:50 <elliott> alpounet: well, it basically uses happstack as a server backend, afaict :P
13:18:50 <sclv> and query one another
13:19:08 <sclv> oh right, it also has some fancy routing tree notions
13:19:26 <alpounet> uh ok, i'll take a look at this
13:19:31 <sclv> and is written restfully so resources are exposed via multiple formats (html, json, xml or whatever)
13:20:00 <sclv> they put in this work basically to make it easy to extend in a modular way
13:21:12 <alpounet> ok
13:21:54 <byorgey> mkscrg: ah, cool
13:23:04 <eyebloom> What is the difference between Int and Integer in Haskell?
13:23:25 <dmwit> > (2^65, 2^65) :: (Int, Integer)
13:23:26 <lambdabot>   (0,36893488147419103232)
13:23:51 <eyebloom> So Integers are bit strings basically.
13:23:53 <byorgey> Integer is unbounded.  Int is whatever size machine integers are on your machine.
13:24:14 <byorgey> bit strings?
13:24:19 <DanBurton> > maxBound :: Int
13:24:20 <lambdabot>   9223372036854775807
13:24:26 <DanBurton> > maxBound :: Integer
13:24:27 <lambdabot>   No instance for (GHC.Enum.Bounded GHC.Integer.Type.Integer)
13:24:27 <lambdabot>    arising from...
13:24:36 <hpc> > floor (1/0) :: Int
13:24:37 <lambdabot>   0
13:24:38 <matthiasgorgens> hello,
13:24:40 <dmwit> From the documentation: "data Int, A fixed-precision integer type with at least the range [-2^29 .. 2^29-1]. The exact range for a given implementation can be determined by using minBound and maxBound from the Bounded class. data Integer, Arbitrary-precision integers."
13:24:41 <hpc> > floor (1/0) :: Integer
13:24:42 <lambdabot>   179769313486231590772930519078902473361797697894230657273430081157732675805...
13:24:46 <matthiasgorgens> where is the monad instance for Either a defined?
13:24:51 <DanBurton> hpc: o_O nice
13:24:57 <dmwit> ?hackage base for the documentation =)
13:24:58 <lambdabot> http://hackage.haskell.org/package/base for the documentation =)
13:25:09 <eyebloom> Like a string but instead of representing characters it represents binary digits.
13:25:17 <elliott> matthiasgorgens: Control.Monad.Error
13:25:20 <dmwit> matthiasgorgens: Control.Monad.Error or Control.Monad.Either, depending on your version of base
13:25:21 <hpc> DanBurton: the rounding logic for Double doesn't seem to take into account infinities
13:25:27 <elliott> or Control.Monad.Trans.Error iirc
13:25:36 <elliott> dmwit: huh, is the latter new?
13:25:47 <byorgey> eyebloom: oh, I see. sure.  In fact, it is implemented as a linked list, but the 'element' size is much larger than bits.
13:25:51 <elliott> hpc: you have to admit, it's pretty close!
13:25:54 <dmwit> elliott: The latter is old, I think.
13:25:56 <byorgey> well, I should say in GHC it is.
13:26:03 <DanBurton> hpc: apparently you get quite a large Integer. close enough to infinity? xD
13:26:04 <byorgey> of course the Haskell standard does not specify how it should be implemented.
13:26:08 <matthiasgorgens> elliott, dmwit, thanks!
13:26:40 <hpc> DanBurton: er, the bit representation of infinity
13:26:54 <hpc> i didn't do the math, but they look exactly the same to me
13:26:56 <dmwit> elliott, matthiasgorgens: According to Hackage, I'm just wrong about the C.M.Either nonsense.
13:27:49 <fryguybob> > length . show $ (floor (1/0) :: Integer)
13:27:51 <lambdabot>   309
13:28:20 <hpc> > maxBound :: Double
13:28:21 <lambdabot>   No instance for (GHC.Enum.Bounded GHC.Types.Double)
13:28:22 <lambdabot>    arising from a use o...
13:28:23 <hpc> haha
13:28:37 <dmwit> elliott, matthiasgorgens: Aha, I was thinking of this!
13:28:39 <dmwit> ?hackage either
13:28:39 <lambdabot> http://hackage.haskell.org/package/either
13:29:06 <hpc> > logBase 2 (floor (1/0) :: Integer)
13:29:07 <lambdabot>   No instance for (GHC.Float.Floating GHC.Integer.Type.Integer)
13:29:07 <lambdabot>    arising fr...
13:29:16 <hpc> > logBase 2 $ fromInteger (floor (1/0) :: Integer)
13:29:16 <dmwit> Which was C.M.Either in category-extras...
13:29:17 <lambdabot>   Infinity
13:29:29 <hpc> > logBase 4 $ fromInteger (floor (1/0) :: Integer)
13:29:30 <lambdabot>   Infinity
13:29:42 <dmwit> hpc: logBase n Infinity = Infinity
13:29:49 <hpc> pah
13:29:56 <hpc> > logBase 2 $ fromInteger (floor (1/0) :: Integer) :: CReal
13:29:57 <lambdabot>   1024.0
13:29:58 <dmwit> :t showInt
13:29:59 <lambdabot> forall a. (Integral a) => a -> String -> String
13:30:10 <dmwit> :t showIntAtBase
13:30:11 <lambdabot> forall a. (Integral a) => a -> (Int -> Char) -> a -> String -> String
13:30:12 <hpc> the largest exponent you can get in IEEE double is 1023
13:30:33 <hpc> the next exponent is reserved for infinities and NaNs
13:30:45 <dmwit> > length (showIntAtBase 2 ("01"!!) (floor (1/0) :: Integer) "")
13:30:46 <lambdabot>   1025
13:31:38 <fryguybob> dmwit: beat me to it :D
13:33:55 <DanBurton> @hoogle logBase
13:33:55 <lambdabot> Prelude logBase :: Floating a => a -> a -> a
13:35:57 <Veinor> argh
13:36:28 <Veinor> all the functions in dropbox-sdk look like foo :: Manager -> Session -> Something -> Result
13:36:56 <Veinor> so I have to keep writing a <- foo mgr sess x; b <- foo mgr sess y;
13:37:15 <hpc> Veinor: sounds like ReaderT time
13:37:45 <roconnor> lukish: question?
13:38:14 <x_man> Hi, can one point me a paper where is study of simple lambda calculus with subtyping. to see how subject reduction theorem is proved
13:38:23 <lukish> roconnor: ?
13:38:24 <Veinor> hpc: so what would my code look like then?
13:38:43 <DanBurton> x_man: have you read Types and Programming Languages?
13:38:45 <DanBurton> @where tapl
13:38:45 <lambdabot> http://www.cis.upenn.edu/~bcpierce/tapl/
13:39:07 <dmwit> DanBurton++ that was going to be my suggestion, too
13:39:17 <edwardk> DanBurton: my desk. ;)
13:39:22 <x_man> DanBurton: I just got that book, but could not find what I want
13:39:23 <hpc> Veinor: runReaderT action (mgr, sess)
13:39:36 <DanBurton> x_man: subtyping is chapter 15
13:39:46 <x_man> yes. I found the chapter
13:39:50 <dmwit> Is subject reduction interestingly harder with subtyping?
13:39:59 <DanBurton> I know this because I literally read that chapter like 2 days ago xD
13:40:01 <hpc> then write a function to ask/curry and use that
13:40:09 <x_man> dmwit: seems
13:40:11 <dmwit> Yes, it might be, as the type might change, huh?
13:40:13 <Veinor> ah
13:40:22 <dmwit> It might get more specific.
13:40:29 <x_man> actually I do not know how to state generation lemma for abstraction case
13:40:36 <Veinor> actually since i'm already in the Snap Handler monad which has MonadState instances I can just shove stuff in there
13:40:54 <x_man> dmwit: if I have typing rule
13:41:16 <dmwit> x_man: I bet a subject reduction property like "if gamma |- x : T and x -> x', then gamma |- x' : T' for some gamma |- T < T'" or something like that.
13:41:26 <dmwit> ...is relatively easy to prove.
13:41:34 <roconnor> lukish: using saturation and lightness values greater than 1 (or less than 0) will give you bizzare and likely wrong results.
13:41:41 <elliott> lukish: roconnor is the author of the colours library
13:41:43 <elliott> *colour
13:42:02 <roconnor> I guess I should write this in the docs
13:42:20 <x_man> dmwit: if I have abstarction rule like this
13:42:29 <DanBurton> if I'm not mistaken, Pierce calls "Subject Reduction" "Preservation"
13:42:48 <x_man> G,D|-M:tau1   G,D|-N:tau2
13:42:59 <lukish> roconnor: it will be really helpful
13:43:45 <lukish> λ> let x = (34.0,0.54,0.68)
13:43:45 <lukish> x :: (Double, Double, Double)
13:43:45 <lukish> λ> fmap truncate . (\(h,s,l) -> hsl h s l) $ x
13:43:45 <lukish> RGB {channelRed = 0, channelGreen = 0, channelBlue = 0}
13:43:45 <lukish> it :: RGB Integer
13:43:48 <lukish> roconnor:
13:44:17 <dmwit> x_man: You must surely have some kind of function type for M, if you're going to apply M to N.
13:44:20 <x_man> G|-x:tau1   G|-N:tau2
13:44:20 <x_man> --------------------------
13:44:20 <x_man> lambda x.N : tau1->tau2
13:44:48 <x_man> if i have such typing rule for abstraction
13:44:50 <roconnor> lukish: you don't want to truncate, since the resulting RGB values will all be between 0 and 1
13:44:50 <DanBurton> x_man: TAPL 15.3.5 Theorem [Preservation] if gamma |- t : T and t -> t', then gamma |- t' : T
13:44:51 <dmwit> DanBurton: Yes, he does.
13:44:57 <x_man> and need to have inverse of this rule
13:45:23 <roconnor> lukish: are you trying to get a 8-bit RGB value out?
13:45:31 <x_man> DanBurton: I found that theorem. but I need strctly deferent type system
13:45:42 <lukish> roconnor: (Int.Int,Int)
13:45:53 <lukish> I should multiply it by 100?
13:45:58 <lukish> Should i*
13:46:07 <roconnor> lukish: what do you want "pure white" to be?
13:46:09 <dmwit> x_man: Your rule looks weird.
13:46:20 <x_man> why?
13:46:25 <lukish> roconnor: (255, 255, 255)
13:46:29 <dmwit> x_man: Surely the premise should be (only) G,x:tau1 |- N : tau2
13:46:35 <lukish> So I must multiply by 255, yeah?
13:47:23 <x_man> dmwit: that is true for simple typed lambda calculus
13:47:59 <roconnor> lukish: Ya.  I think fmap (truncate . (255*)) should do what you want.
13:48:31 <x_man> http://www.loria.fr/~ckirchne/=rho/papers/data/rho-wrla.pdf
13:48:44 <x_man> dmwit: could you look please page 13
13:48:55 <x_man> abs rule
13:49:07 * DanBurton isn't quite sure he understands x_man's question
13:49:14 <x_man> if I have that rule in the system together with subtyping rule
13:49:56 <roconnor> lukish: I think using round instead of truncate would be better though.
13:49:56 <x_man> I am interested how to state generation lemma for that abstraction rule
13:50:25 <dmwit> x_man: gio123, is that you?
13:50:38 <x_man> who?
13:50:48 <lukish> roconnor: works now.
13:50:49 <DanBurton> I suppose "generation lemma" is what Pierce calls "progress"?
13:50:50 <qpu> gio123: x_man, is he you?
13:50:59 <x_man> no
13:51:02 <mkscrg> Why can't I INLINE (or NOINLINE) a record selector?
13:51:11 <roconnor> lukish: what do you do with these 3 Integers once you have them?
13:51:15 <dmwit> x_man: Never mind, this style of question just reminds me of another person.
13:51:36 <x_man> ok
13:51:39 <dmwit> I apologize, but I'm not sure I have the time that would be required to understand this paper well enough to form an intelligent answer.
13:51:57 <x_man> ok
13:51:58 <DanBurton> mkscrg: huh? can you hpaste what you are doing?
13:52:00 <x_man> thx
13:52:21 <qpu> x_man: i came late to the discussion and am not ready to learn how to scroll my irc logs. what's the question?
13:52:32 <lukish> roconnor: make some PNG file
13:52:55 <DanBurton> scumbag qpu, willing to answer complicated type theory question, unwilling to learn to scroll irc logs xD
13:53:20 <roconnor> lukish: okay
13:53:57 <qpu> x_man: oh, "how do i write the 'generation lemma' for the ABS judgement" ?
13:54:11 <roconnor> lukish: thanks for the feedback.
13:54:21 <x_man> qpu: yes
13:55:08 <hpaste> mkscrg pasted “NOINLINE record selectors?” at http://hpaste.org/63841
13:55:21 <mkscrg> DanBurton: http://hpaste.org/63841
13:56:45 * dmwit won his internal bet that mkscrg was the guy asking about finalizers on the mailing list
13:57:13 <qpu> x_man: like DanBurton asked, by 'generation lemma' do you mean progress? i'm not sure i can answer without consulting TAPL, but it sounds like you'd be better off picking it up than me reading it to you: Types And Programming Languages, Benjamin C. Pierce
13:57:51 <mkscrg> dmwit: yeah. that's actually what's lead me on this NOINLINE/INLINE goose chase. it seems there are a number of things that can cause finalizers to execute early
13:57:58 <qpu> x_man: by progress, i mean proving well-typed terms don't get "stuck"
13:58:03 <mkscrg> someone needs to write a haskell wiki page on this
13:58:07 <DanBurton> qpu: yeah we've recommended TAPL, he has it already :)
13:58:25 <quintessence> mkscrg: Fully-applied record selectors aren't implemented the same as functions.  They get wrapped transparently when partially applied or passed to higher-order functions, but those are exactly the cases where you can't inline them.
13:58:37 <x_man> qpu: I just got this book and I will read it, but I think I will have to find more rellated papers also
13:58:38 <qpu> DanBurton, x_man: ah, sorry about that then!
13:58:43 <x_man> to that subject
13:59:11 <dmwit> x_man: You can read the Featherweight Java thesis, of which a small part is included in TAPL.
13:59:27 <DanBurton> mkscrg: I would guess that ghc implements selectors as a primitive lookup. What is there to inline?
13:59:36 <dmwit> mkscrg: (Are you 100% sure that running the finalizers early is a problem?)
13:59:43 <x_man> dmwit: is it freely avaiallable?
14:00:05 <mkscrg> DanBurton: i actually want to NOINLINE them
14:00:25 <mkscrg> dmwit: yah, a finalizer is closing my zeromq sockets while i'm still reading from them
14:00:32 <dmwit> x_man: Hard for me to tell. I can access it, but I've got a university proxy. Try http://scholar.google.com/scholar?q=featherweight+java and see for yourself.
14:00:44 <DanBurton> in that case...what is there to *not* inline?
14:00:45 <dmwit> mkscrg: Whoops! =P
14:02:05 <dmwit> mkscrg: You know how getContents deals with this, right?
14:02:07 <DanBurton> dmwit: acm wants to sell it to me >,<
14:02:16 <dmwit> mkscrg: It just never closes the handle. =P
14:02:39 <dmwit> *hGetContents, I mean
14:02:54 <mkscrg> DanBurton: point made. i think all of this crap will go away if i just move this code from using Ptr to ForeignPtr
14:03:17 <mkscrg> dmwit: hah. that seems like the wrong thing to do
14:04:14 <DanBurton> this is why Snoyman gave us ResourceT ;)
14:05:19 <qpu> DanBurton, x_man: http://www.cis.upenn.edu/~bcpierce/papers/fj-toplas.pdf
14:07:20 <DanBurton> qpu: cool, thanks
14:08:06 <x_man> qpu:thx
14:12:23 <newb> hello?
14:12:35 <wavewave> hi
14:12:43 <`Jake`> hi
14:12:45 <newb> where am i?
14:12:48 <c_wraith> the internet
14:12:49 <wavewave> #haskell
14:12:52 <CodeWeaverX1> Possibly Earth.
14:12:53 <newb> wow
14:13:05 <wavewave> what a wonderful place!
14:13:11 <newb> how did i get here>
14:13:25 <`Jake`>  /join #haskell
14:13:33 <newb> I was researching somthing....
14:13:35 <c_wraith> newb: probably by clicking on a link on tryhaskell.org?
14:16:26 <elliott> We will never know.
14:16:58 <wavewave> life is mystery
14:17:00 <CodeWeaverX> That's not true.  I slipped a tracking monad under his collar before he left.
14:17:09 <`Jake`> Good Job
14:17:32 <hpaste> NiceOneBrah pasted “H-99 Problems 1-10” at http://hpaste.org/63842
14:17:36 <wavewave> oops monad with no return
14:17:52 <NiceOneBrah> boom - trying to resume my quest to learn Haskell
14:18:00 <NiceOneBrah> only 89 problems left ;)
14:22:02 <tech2> CodeWeaverX: "Possibly" Earth?
14:22:40 <elliott> They might have itnernet on the ISS.
14:23:08 <`Jake`> http://www.universetoday.com/51782/iss-now-has-live-access-to-the-internet/
14:23:30 <tech2> sadly he quit, but I'm willing to bet they don't have the greatest of pings if so.
14:24:01 <`Jake`> possibly a time out
14:27:57 <`Jake`> got his IP! dunno if it's a Space IP, though...
14:29:58 <Andrew__C> hi folks
14:30:14 <hiptobecubic> I don't understand how Control.Exception.Handle works... it takes a function that takes an exception and returns an IO a, but ... well as usual it won't compile :)
14:30:50 <hiptobecubic> The line in question is right out of RWH ch08,  handle  (const (return [])) $ do ...
14:32:02 <dschoepe> hiptobecubic: that function is the exception handler. It could, for example, just print an error message and quit the program.
14:32:16 <hiptobecubic> dschoepe, I'm getting  Ambiguous type variable `e0' in the constraint:      (GHC.Exception.Exception e0) arising from a use of `handle'
14:32:24 <elliott> Well, Control.Exception.handle is a function.
14:32:30 <elliott> Does RWH define its own handle function?
14:32:31 <hiptobecubic> but shouldn't the const eat the expception, whatever it is?
14:32:43 <elliott> hiptobecubic: Can you please link to, or hpaste, the code?
14:33:02 <elliott> hiptobecubic: That RWH code can never compile.
14:33:14 <elliott> hiptobecubic: Basically the problem is that
14:33:21 <cubi> t_t
14:33:22 <elliott> handle :: (Exception e) => (e -> IO a) -> IO a -> IO a
14:33:32 <elliott> const (return []) :: (Monad m) => e -> m [a]
14:33:34 <otters> t(^_^t)
14:33:42 <elliott> hiptobecubic: the typechecker _must_ know what e is
14:33:44 <elliott> otherwise it's ambiguous
14:33:58 <elliott> hiptobecubic: In this case, I suggest (\(_::SomeException) -> return [])
14:34:03 <elliott> Which will catch every exception.
14:34:40 <hiptobecubic> elliott, ah ok. looked at :i Exception in ghci  but  I misunderstood SomeException.
14:35:13 <elliott> SomeException is the "root" of the exception hierarchy, basically.
14:35:43 <hiptobecubic> Yeah i expected something of the sort. But i didn't notice that it was SomeException and not someException
14:36:12 * hackagebot Unixutils 1.47.1 - A crude interface between Haskell and Unix-like operating systems  http://hackage.haskell.org/package/Unixutils-1.47.1 (JeremyShaw)
14:37:00 <hiptobecubic> elliott, your suggestion is apparently illegal without -XScopedTypeVariables?
14:37:47 <elliott> hiptobecubic: Yes. It's very common when using exceptions.
14:37:53 <elliott> Put {-# LANGUAGE ScopedTypeVariables #-} at the top.
14:37:55 <qpu> is there a way to recover from `undefined` or `error`? it seems Control.Exception is for something else
14:38:09 <elliott> qpu: Control.Exception lets you. Don't.
14:38:11 <monochrom> RWH uses an old version of Control.Exception. you can still obtain it as Control.OldException
14:38:17 <elliott> Instead, don't use undefined or error.
14:38:22 <elliott> hiptobecubic: ah -- following monochrom's advice will be more productive
14:38:33 <elliott> reason N I don't recommend RWH...
14:38:35 <hiptobecubic> I'd rather learn the "new" way
14:38:44 <elliott> ok, but RWH won't teach it :P
14:38:56 <monochrom> you can learn the new way by reading new haddock
14:39:20 <Veinor>   Right (_, Just (folderChildren -> meta)) <- liftIO $ getMetadataWithChildren mgr sess "/" Nothing
14:39:36 <hiptobecubic> elliott, what do you recommend? I find that RWH isn't teaching as much as demonstrating a bunch of trivial programs without any explanation about the thought process behind them
14:39:40 <Veinor> whee, pattern matching
14:40:00 <elliott> hiptobecubic: Yes, I have the same view. My favourite introduction is LYAH, but it doesn't really feature as much "practical" stuff as RWH.
14:40:19 <elliott> Reading other people's well-designed code and writing your own is the best teacher of all, but doesn't help if you don't feel confident enough with the language yet.
14:40:23 <qpu> elliott: fair enough. but say i do something dangerous, like `head xs` on user-input in a web app (eg, yesod). i don't want my server to exit. is the best answer, "don't do that and do adequate testing"?
14:40:36 <elliott> qpu: Just don't use partial functions.
14:40:40 <monochrom> that is Real World for you. everyone shows you source code, no one explains it. "use the source" they say
14:40:45 <elliott> Well, except for div/mod/quot/rem with a constant second argument. :p
14:40:56 <adnauseam> sauce caud
14:41:02 <adnauseam> now with more SAUCE
14:41:17 <hiptobecubic> that like that chapter on json parsing. what the hell was that? No explanations about anything. Just copying a bunch of totally confusing and convoluted functions until finally you discover that you were trying to match the pretty printer api, which isn't mention before or since
14:41:30 <hiptobecubic> mentioned*
14:41:35 <kniu> is there an easy way to turn a 100-element list into a 10-element list of 10-element lists?
14:41:38 <monochrom> "use the source" is also rationalization for lack of doc
14:41:45 <elliott> kniu: look at the split package
14:41:47 <qpu> elliott: ok, i mostly agree. but why does haskell have partial functions at all?
14:42:17 <kniu> elliott, okay thanks
14:42:18 <hpaste> “John Lien” pasted “leerouter second edition” at http://hpaste.org/63843
14:42:25 <dschoepe> qpu: Because they are useful, when you _know_ for some reason that the argument is in the function's domain.
14:42:31 <Veinor> qpu: IMO it's okay if it's something like a web server to wrap everything in an error catch
14:42:35 <qpu> elliott: by partial function i mean something that bottoms. i understand its much more difficult to eliminate non-terminating computations
14:42:38 <Veinor> because web server sshould not crash, ever
14:42:46 <elliott> qpu: Historical reasons.
14:43:05 <elliott> But I agree with Veinor, a top-level catch is good to save yourself.
14:43:10 <monochrom> haskell has partial functions because it is a programming language
14:43:17 <elliott> But it should be a precaution against the possibility, not a standard choice.
14:43:25 <qpu> ok, then i presume the usual web frameworks implement that
14:43:25 <Veinor> right.
14:43:27 <shachaf> qpu: A non-terminating computation *is* "something that bottoms".
14:43:31 <c_wraith> more specifically, haskell has partial functions because otherwise it'd be agda
14:43:46 <Veinor> you have a safety net beneath your trapeze so that in case you fall you don't die, not so that you have something to land on when you're done :)
14:43:52 <monochrom> SQL does not have partial functions, if that is your cup of tea
14:44:04 <c_wraith> Non-partial functions require proof of termination, in some form
14:44:10 <qpu> shachaf: is there some other terminology to distinguish non-termination from `error`?
14:44:17 <hiptobecubic> I don't understand why the default head, tail, etc are all unsafe
14:44:30 <elliott> hiptobecubic: every language before Haskell got it wrong
14:44:31 <hiptobecubic> Why would you ever want head to explode and crash the program?
14:44:39 <shachaf> qpu: The whole point of "error" is that it's indistinguishable form non-termination.
14:44:51 <elliott> shachaf: qpu obviously meant "why do standard functions error out?".
14:44:55 <shachaf> It's a more convenient way of writing _|_ that happens to be detectable at runtime.
14:44:58 <shachaf> Oh.
14:45:00 <elliott> The fact that it's indistinguishable from the POV of Haskell code does not mean it's not a reasonable question to ask.
14:45:15 <monochrom> Excel is a functional language and does not have partial functions
14:45:17 <shachaf> I thought qpu meant something about disallowing _|_ in the language, not in the standard library.
14:45:24 <shachaf> monochrom: It doesn't?
14:45:25 <elliott> Well, just don't provide undefined/error.
14:45:30 <elliott> Then you stop error _|-s.
14:45:31 <shachaf> You can have a cell refer to itself.
14:45:32 <elliott> *_|_s
14:45:36 <shachaf> And that shows up as an error.
14:45:43 <shachaf> That seems pretty similar to _|_ to me.
14:45:51 <Veinor> it looks like snap in production mode sends no response if you evaluate an undefined/error
14:46:03 <monochrom> do you also say that syntax errors are bottoms?
14:46:32 <monochrom> in Excel, syntax errors and cycle errors are just that, errors
14:46:41 <qpu> elliott: thanks. what's the right language to distinguish something like 'x = x' from 'error'? i understand they are similar theoretically
14:46:42 <shachaf> Hm.
14:46:52 <Veinor> but it doesn't kill the server
14:47:15 <Veinor> (in dev mode it sends you the error message)
14:47:16 <shachaf> qpu: "x = x" behaves a lot like "error" in practice -- GHC will detect it and print an error. :-)
14:47:33 <shachaf> (It'll print "<<loop>>". Though of course you can't rely on this behavior.)
14:47:41 <monochrom> if your spreadsheet passes all error checks, including syntax errors and cycle errors, the spreadsheet terminates
14:47:43 <c_wraith> It won't with the threaded runtime
14:47:49 <shachaf> c_wraith: It will.
14:47:58 <shachaf> Or at least it used to. Did the threaded runtime stop doing that?
14:48:03 <qpu> shachaf: ah, damnit! well, it can't detect all non-terminating computations
14:48:31 <shachaf> monochrom: I suppose that's reasonable.
14:48:39 <shachaf> qpu: Agda can detect all non-terminating computations.
14:48:39 <c_wraith> in the threaded runtime, it doesn't know if it's waiting on its own blackhole, or a different thread's blackhole
14:48:46 <c_wraith> so it just waits
14:48:47 <shachaf> Of course it also detects some terminating computations while it's at it.
14:48:59 <shachaf> c_wraith: But then when it gets to GC or something it detects it anyway.
14:49:00 <monochrom> that's total language for you
14:49:21 <monochrom> the point of total languages is to ban some terminating programs.
14:49:36 <qpu> monochrom: huh?
14:49:42 <shachaf> I would call that a side effect, not the point.
14:50:00 <qpu> monochrom: like the point of a type system is to ban some well-typed programs?
14:50:15 <monochrom> my opinion anyway. you are welcome to stick to the official party line "total languages are so great"
14:50:29 <shachaf> monochrom: I never said they were great.
14:50:43 <shachaf> I recognize that the side effect is rather unfortunate.
14:51:34 <dschoepe> Also, just for the record, Agda _needs_ to ban programs whose termination it can't prove, since otherwise it'd become useless as a theorem prover.
14:51:40 <monochrom> what is the objective criterion for classifying "this is a side effect" "this is a purpose"?
14:51:48 <dschoepe> (And you can disable the termination checker if you don't care about that)
14:52:07 <shachaf> dschoepe: Right.
14:52:24 <shachaf> monochrom: Perhaps there is none.
14:52:26 <elliott> monochrom: Does it have to be objective?
14:52:38 <shachaf> The word "because" in English might mean nothing more than "and", objectively.
14:52:46 <shachaf> Er, not "and".
14:53:00 <shachaf> Yes, "and". Something.
14:53:12 <qpu> nand!
14:53:37 <monochrom> if it is not objective, my claim is not wrong
14:54:24 <shachaf> This argument seems pretty useless (if it was ever an argument).
14:55:27 <hiptobecubic> I guess the exercises at the end of the chapters are pretty good, assuming you learned anything in the chapter.
14:55:49 <dschoepe> That no one ever used "We want to exclude some terminating programs!" as justification for making some language total, seems like a somewhat objective way of determining if it's the point, imo.
14:56:42 <dschoepe> Just like no one used that same argument for designing a type-system, at least to my knowledge.
14:56:46 <elliott> monochrom: so it's impossible to disagree about subjective things?
14:57:17 <int-e> dschoepe: actually there's work on limiting functions to those computable in polynomial time :)
14:59:13 <qpu> int-e: i've read a bit about that, the problem being its difficult to combine functions, i think. do you have any references, i'm trying to remember what i read...
14:59:25 <int-e> Which is probably not what you meant,, but it is deliberately excluding a whole bunch of terminating programs.
15:00:53 <dschoepe> int-e: Yeah, just like type systems deliberately exclude some well-behaved programs, but that's not why anyone bothers with type systems at all. I guess there's a similar reason behind the work you mentioned.
15:01:05 <hpaste> jameysharp pasted “streaming leak?” at http://hpaste.org/63844
15:01:07 <monochrom> 'That no one ever wrote "I want to increase my money and power" when applying for jobs and switching jobs, seems like a somewhat objective way of determining if it's the point', consider that
15:01:58 <Saizan> but they do write that
15:02:06 <int-e> Bellantoni, Cook, A New Recursion-Theoretic Characterization of the Polytime Functions. There's also Girard, Scedrov and Scott's bounded linear logic work, which can be used to make polynomial bounds explicit in types.
15:02:08 <qpu> does this boil down to the philosophy that meaning is not an intrinsic property? the purpose of a type system depends on what it's being used for?
15:02:28 <monochrom> yes
15:02:42 <int-e> and there must be a lot more that I'm unaware of; it's not exactly my area of interest.
15:02:54 <jameysharp> I think I've reduced my program to a small enough example to ask for help with it... I think I should be able to extract links from a page with very small peak memory consumption, but it's taking a lot more than I expected. help?
15:02:54 <qpu> int-e: ah, thanks!
15:04:05 <elliott> monochrom: I agree with dschoepe, do you consider the purpose of type-systems to reject some valid programs?
15:04:07 <shachaf> monochrom: Let's say I wanted to remove my nose, because my nose is annoying me. So I do some research into nose-removal and find out that I would die if I removed my nose, so I stop wanting to remove my nose.
15:04:10 <elliott> It's very conspiratorial thinking MIO.
15:04:23 <shachaf> Was my purpose for a short while to die?
15:04:42 * cmccann personally thinks the purpose of type systems are to annoy monochrom
15:04:45 <hpc> elliott: any valid-but-rejected program can be rewritten
15:04:56 <monochrom> it is right to say both "your purpose is to die" and "your purpose is to remove nose"
15:04:56 <hpc> er, that was at nobody in particular
15:05:14 <qpu> hpc: i was wondering if that was true in general, so thanks for the anwser :]
15:05:32 <shachaf> monochrom: As soon as the information the "if I remove my nose, I would die" was made available to me, I stopped wanting to remove my nose.
15:05:43 <elliott> qpu: trivially true by turing-completeness
15:05:53 <elliott> hpc: Same applies to lots of total languages.
15:05:56 <shachaf> This seems like an unusual meaning of "purpose" if you claim that my purpose was to die.
15:05:57 <dschoepe> I think people's intentions and what is entailed by fulfilling them are two different things, as the latter might not be known to the person in question.
15:05:58 <elliott> Just use a codata execution trace.
15:06:03 <elliott> Or whatever.
15:06:12 <shachaf> monochrom: If I used the word "intent" would you say the same thing?
15:06:57 <qpu> elliott: but in a non-turing complete language? like if agda doesn't like my expression (but it really does terminate), it can always be rephrased so agda accepts it?
15:07:01 <hpc> qpu: the trivial case would be "program that works except for poorly-typed code that never runs"
15:07:03 <monochrom> well, if you don't take the action, I grant you that we don't know your purpose.
15:07:09 <hpc> qpu: where the obvious solution is "delete the code"
15:07:27 <cmccann> qpu, any computation can be reworked via a coinductive interpreter
15:07:29 <hpc> if you run into poorly-typed code that gets run, your program wasn't valid anyway
15:07:41 <cmccann> you just may not get anything other than a stream of "no answer yet" values
15:07:59 <elliott> What cmccann said.
15:08:02 <qpu> cmccann: i start blacking out whenever i read words starting with co-... is this something informed by category theory?
15:08:07 <elliott> qpu: No.
15:08:21 <elliott> qpu: coinductive data just means you can have infinite data, but you must produce a constructor in a bounded amount of time.
15:08:22 <dschoepe> monochrom: What if he didn't find out that he would die from removing his nose and then did it? Would you then say the purpose if the removal was suicide?
15:08:26 <elliott> That is, you can have (repeat 1) but not (1 : undefined).
15:08:38 <elliott> An execution trace where each step is some primitive, constant-time "machine instruction" meets this criterion.
15:08:43 <hpc> qpu: coinductive = "productive", essentially
15:08:58 <qpu> ah, got it
15:08:58 <monochrom> yes
15:08:59 <dschoepe> *purpose of the removal
15:09:12 <hpc> if you really stretch your brain, you could say it means "countably infinite"
15:09:19 <cmccann> monochrom, that is a spectacularly useless definition of "purpose"
15:09:22 <dschoepe> Okay, then I think we just disagree about what we mean by purpose.
15:09:32 <hpc> (it's a big stretch though)
15:09:37 * cmccann concludes that monochrom's purpose here is to obfuscate communication
15:09:38 <monochrom> yes, "purpose" "intention" are all fairly useless
15:09:58 <elliott> cmccann: or to make a provocative statement without having to defend it :P
15:10:20 <cmccann> redefining words in order to be provocative is kinda silly
15:10:42 * cmccann goes back to doing something useful
15:10:56 * elliott would have agreed with monochrom's statement if it came with his definition of "purpose" on the same line
15:11:54 <shachaf> cmccann: Just so you know, elliott isn't vaguely respectable at all.
15:12:13 <elliott> Thanks, shachaf.
15:12:18 <elliott> You're a real pal.
15:12:39 <cmccann> shachaf, oh really
15:12:44 * cmccann can't recall suggesting otherwise
15:12:45 <shachaf> What I mean to say is that elliott is respectable in non-vague ways.
15:13:11 <elliott> cmccann: It's shachaf. Just accept the wisdom and move on with your life.
15:13:18 <cmccann> ok.
15:13:30 <shachaf> Apparently elliott doesn't like me much.
15:15:04 <jameysharp> ...is it safe to try asking for help again yet?
15:15:16 <elliott> It's never safe. But go on.
15:15:17 <shachaf> jameysharp: Yes, sorry.
15:15:19 <shachaf> What's your question?
15:15:23 <jameysharp> http://hpaste.org/63844
15:15:53 <jameysharp> I think I should be able to extract links from HTML with very little peak memory usage, but I don't seem to be able to achieve it.
15:16:07 <elliott> You're using foldl.
15:16:11 <elliott> You want foldl' or foldr.
15:16:18 <jameysharp> I've tried foldl' and foldr.
15:16:24 <elliott> Okay. But you still don't want foldl.
15:16:44 <elliott> replicateM_ 1 is an interesting function.
15:17:03 <c_wraith> that seems a lot like (>> return ())
15:17:08 <hpc> :t replicateM_
15:17:09 <lambdabot> forall (m :: * -> *) a. (Monad m) => Int -> m a -> m ()
15:17:17 <c_wraith> or even void
15:17:19 <c_wraith> :t void
15:17:20 <lambdabot> Not in scope: `void'
15:17:38 <c_wraith> right, why would lambdabot have that module imported
15:17:52 <alpounet> @hoogle void
15:17:52 <lambdabot> Foreign.Marshal.Error void :: IO a -> IO ()
15:17:52 <lambdabot> Control.Monad void :: Functor f => f a -> f ()
15:17:53 <lambdabot> package void
15:17:57 <elliott> c_wraith: Control.Monad.void is a lot newer than lambdabot's GHC.
15:17:59 <elliott> I think.
15:18:01 <jameysharp> For profiling purposes I was running the test multiple times so I'd get clearer heap profiles.
15:18:20 <jameysharp> I just pasted a version that only runs it once.
15:18:24 <c_wraith> elliott: you're right
15:19:13 <elliott> Although I think lambdabot uses GHC 7 these days(?)
15:20:10 <jameysharp> If I change the pasted program from (isTagOpenName "a") to (isTagOpenName "foo"), so that it doesn't match anything, it uses an order of magnitude less peak heap.
15:22:31 <jameysharp> And I can match the contents of a <title> tag with constant heap, as long as I use $! to force the text nodes to be consumed before proceeded to further tags.
15:22:52 <jameysharp> But I can't find any place I can add strictness that makes links stream like I expect.
15:23:55 <Andrew__C> Hi. How do I get haddock to produce links to source like at http://www.haskell.org/ghc/docs/7.0-latest/html/libraries/haskell98-1.1.0.1/Complex.html ?
15:24:33 <jameysharp> Heap profiling says the data that's lingering on the heap is primarily cons cells and TagSoup's "Position" nodes (which I didn't ask it to produce so it ought to be discarding them), all allocated inside TagSoup.
15:25:20 <hpaste> hiptobecubic pasted “How to sneak in Either?” at http://hpaste.org/63845
15:25:21 <jameysharp> So I believe I'm somehow retaining a reference to earlier tags in the parsed list, but I can't see how.
15:25:56 <hiptobecubic> So I am trying to remove the calls to 'error' and instead use Either String to determine if it was successful or not.
15:27:05 <hiptobecubic> But I don't see how to deal with the recursive definition of globToRegex'.   It can't return Right regex because then (++) will break. I'm sure there's a reasonable way to do what seems like a pretty common pattern.
15:29:10 <Saizan> fmap
15:29:19 <hiptobecubic> Saizan, fmap?
15:30:26 <Saizan> > fmap (+1) (Right 2)
15:30:27 <lambdabot>   Right 3
15:30:40 <hiptobecubic> hmmm
15:31:19 <hiptobecubic> Well I don't know if i have an error until i'm deep down in globToRegex'
15:31:37 <hiptobecubic> So i have to pass the Left errmsg  back up the call stack
15:31:46 <hiptobecubic> Unless i'm doing it wrong altogether
15:32:01 <Saizan> > fmap (+1) (Left "error message")
15:32:02 <lambdabot>   Left "error message"
15:32:50 <Saizan> ?src fmap Either
15:32:51 <lambdabot> Source not found. Wrong!  You cheating scum!
15:33:11 <hiptobecubic> ... wat?  That doesn't work for me. I got No Instance for Functor Either [Char]
15:34:07 <Saizan> you might need to import some module to get it
15:34:23 <hiptobecubic> i have fmap
15:35:06 <hiptobecubic> but if i run "fmap (+1) (Left "error message")" in ghci, it dies
15:35:47 <Saizan> import Control.Monad.Instances
15:36:15 <hiptobecubic> What is that even doing? Adding 1 to Char?
15:36:34 <Saizan> nope
15:37:25 <Saizan> fmap f (Left e) = Left e; fmap f (Right x) = Right (f x)
15:37:34 <Saizan> in this case
15:37:46 <hiptobecubic> oh i see
15:38:11 <hiptobecubic> ahhhh, ok
15:42:04 <cmccann> elliott, ok, I need a break from this
15:42:10 <cmccann> can't take it any more
15:43:09 <elliott> cmccann: hehe, I'll take a look at it if you push it
15:43:14 <cmccann> yeah
15:43:21 <cmccann> I'm checking to make sure nothing is obviously broken
15:43:23 <cmccann> and then I'll push
15:46:28 <Andrew__C> \part
15:46:48 <Andrew__C> \bye
15:47:45 <nyingen> ok, so I'm on ghc 6.12, but some packages won't install (via cabal) because they use -rtsopts which ghc6 apparently doesn't know about
15:48:07 <nyingen> what should I do? I can't easily upgrade ghc because this is debian squeeze and I'm not the sysadmin
15:48:39 <ivanm> nyingen: install GHC to your home directory?
15:48:55 <nyingen> sounds painful, but if there's no other way
15:49:25 <cmccann> it's not that painful
15:49:26 <Saizan> nyingen: the other way would be messing with the .cabal files of these packages
15:49:36 <cmccann> I have about a dozen GHCs
15:49:45 <cmccann> in ~/ghcs/
15:49:57 <Saizan> any limited editions?
15:50:08 <cmccann> some are nightly builds
15:50:10 <cmccann> does that count?
15:50:11 <nyingen> heh, collectible ghc
15:50:17 <cmccann> gotta catch 'em all
15:50:26 <nyingen> does it have a special black border, and misattributed artwork?
15:52:05 <cmccann> no, just a fancy serial number
15:52:14 <cmccann> kinda disappointing really
15:52:42 <nyingen> well, I have sudo privs for apt-get. Maybe i can root the box somehow
15:53:46 <nyingen> then I can become a haskell felon, like Randal Schwartz became a perl felon
15:56:55 <nyingen> so how do I tell cabal to use a local ghc instead of the the system-wide one?/
15:59:46 <cmccann> nyingen, there's a setting for that in the cabal config file I think
15:59:49 <ByronJohnson> nyingen: IN your .cabal/config file, you can change with-compiler
16:01:32 <luite> making sure that it comes before the other ghc in your $PATH should do the trick
16:01:41 <nyingen> cool
16:01:42 <nyingen> thanks
16:01:57 <napping> ls
16:02:06 <nyingen> . ..
16:02:16 <Guest32902>  nyingen: i have installed ghc in my home without root privs, it was kind of easy
16:02:26 <nyingen> Guest32902: good to know
16:02:27 <Guest32902> i gave up trying to install the haskell-platform because of dependency hell, but installed ghc and cabal, then with cabal i could install the packages my
16:02:31 <Guest32902>              programs needed
16:03:44 <Guest32902> ubuntu was my distro, so i think with debian you will not have problems too
16:07:14 <lispy> FWIW, in fedora 16 you can yum install cabal-install, ghc, haskell platform, and cabal-dev.  It's pretty amazing.
16:08:29 <Axman6> how recent are those versions?
16:35:14 <zzo38> I get an error to output Unicode text with Windows; something like (putStrLn "\x2191") results in error it is not in the codepage, even though it is in the active codepage. The same error results for all 0x00-0x1F characters in CP437.
16:36:24 <whitewizzard> hi, is there a function that gives you the factors of a number ie factor 3  returns [3,1]?
16:36:46 <zzo38> Do you know why it says is not in the code page even though it is in code page?
16:38:36 <Jesin> whitewizzard: umm, http://hackage.haskell.org/packages/archive/primes/0.2.1.0/doc/html/Data-Numbers-Primes.html
16:38:43 <Jesin> err, sorry
16:39:05 <Jesin> http://hackage.haskell.org/packages/archive/primes/latest/doc/html/Data-Numbers-Primes.html
16:39:10 <Jesin> gives you the prime factors...
16:39:11 <napping> whitewizzard: I don't know of any, but you can search hackage. (I'd guess that's what Jesin did?)
16:39:25 <Jesin> http://holumbus.fh-wedel.de/hayoo/hayoo.html
16:39:31 <Jesin> is the best search engine I've seen for it imo
16:41:12 <Jesin> btw, anyone know a good place to learn how to use template haskell?
16:47:59 <lispy> Jesin: the haskell wiki
16:48:25 <lispy> Jesin: AFAIK, this is as good as it gets: http://www.haskell.org/haskellwiki/Template_Haskell
16:50:04 <hpaste> clown pasted “Doughnut” at http://hpaste.org/63847
16:50:22 <randomclown> I've did some optimisations to improve performance
16:50:22 <lispy> Jesin: although, this looks really good: http://illustratedhaskell.org/index.php/2011/09/24/template-haskell-tutorial/
16:50:27 <lispy> Jesin: I had never seen it before
16:50:43 <Jesin> oh, hm. k
16:50:47 <randomclown> :lispy do you ahve time to have a look now?
16:51:14 <lispy> randomclown: I just glanced at it.  How does it compare now?
16:51:24 <randomclown> much faster
16:51:37 <lispy> awesome
16:51:39 <randomclown> 36.6% alloc in "toCharacters"
16:51:42 <randomclown> not sure what to think
16:51:43 <lispy> So what do you need me for? :)
16:52:41 <randomclown> Don't know why taht function is pulling that much alloc
16:52:52 <lispy> randomclown: you can insert {-# SCC "foo" #-} comments inside that function to narrow it down
16:53:05 <lispy> randomclown: Yeah, maybe the combination of fromIntegral + round?
16:53:55 <lispy> randomclown: you might get better performance wit let (w,h) = (6,13) instead of let aspect = (6,13)
16:54:12 <randomclown> hm yeah
16:54:21 <lispy> But I bet either fromIntegral or round is costly
16:55:10 <randomclown> i see
16:55:27 <Peterbing>  
16:55:33 <ivanm>  
16:58:51 <lispy> randomclown: Hmm...dunno if this would improve performance, but you might consider toCharacter :: Int -> Int -> Pair
16:59:31 <randomclown> that's probably a good idea
16:59:40 <lispy> randomclown: and you don't have any {-# UNPACK #-} on Pair
16:59:57 <randomclown> but it's going to get boxed anyway
17:01:11 <lispy> Not sure I follow
17:03:13 <randomclown> lispy adding unpack increas gc by 0.5%
17:03:53 <lispy> I see
17:04:48 <lispy> I don't see any obvious improvements
17:04:51 <covi> Hi all. How do I judge if a number is palindrome in Haskell?
17:05:21 <lispy> covi: write isPalindrome :: Integer -> Bool :)
17:05:26 <shachaf> Numbers can't be palindromes.
17:05:30 <shachaf> It doesn't make sense.
17:05:34 <latros> um
17:05:37 <covi> lispy: Sure I meant Int.
17:05:38 <shachaf> Unless you define "palindrome", I guess.
17:05:39 <latros> you know what covi means >.>
17:05:50 <randomclown> 12321 is a palindrome
17:05:50 <shachaf> latros: Yes, but covi probably doesn't.
17:05:59 <shachaf> "12321" is a palindrome.
17:06:03 <lispy> shachaf: why do you say that?
17:06:15 <latros> yeah, it may help to think of strings
17:06:27 <covi> Is there a Haskell way to convert Int to String first so that I can judge it?
17:06:28 <lispy> I mean, for all we know covi is the preminent researcher of palindromes
17:06:32 <latros> there is, covi
17:06:45 <shachaf> 12321 is a number that can also be written as 0x3012, and isn't particularly palindromic.
17:06:45 <latros> you just use show
17:07:03 <covi> latros: thx
17:07:07 <shachaf> lispy: It's true. Which is why I said "Unless you define \"palindrome\"".
17:07:09 <Ralith> it doesn't take a genius to see that covi is probably interested in the base 10 representation.
17:09:22 <liyang> Ralith: yes, but this is the internets, and people enjoy being obtuse for the sake of being obtuse.
17:10:42 <shachaf> Ralith: Right, and realizing that is the first step to solving the problem.
17:11:05 <shachaf> Please. I'm being obtuse for the sake of being helpful.
17:11:18 <MaciejP> shachaf: More formal definition: Let a_k...a_0, a_i in {0..9}, be the decimal representation of a natural number n. Then n is a palindrome if and only if forall i in {0..k}: a_i = a_(k-i)  :D
17:11:53 <shachaf> MaciejP: If you're being annoyingly formal, I'd ask you to elaborate on the "...".
17:12:58 <shachaf> Is what I said really so unreasonable?
17:13:25 <liyang> Not for this channel. ;p
17:14:02 <lispy> shachaf: it seemed a bit confrontational for such a simple question, IMO
17:14:30 <lispy> shachaf: It seems like all you wanted was for covi to think about the types and to clarify
17:14:43 <lispy> which is good
17:14:45 <shachaf> Not about types, about values! Sort of
17:14:59 <shachaf> lispy: I said that numbers can't be palindromes and asked for a clarification on the meaning of the word "palindrome".
17:15:18 <shachaf> The "covi probably doesn't know what they mean" thing was a meta-conversation, as a response to liyang.
17:15:27 <shachaf> It wasn't addressed to covi.
17:15:40 <gwern> WHY CAN'T WE All JUST GET ALONG
17:15:40 <elliott> oh boy
17:15:51 <lispy> shachaf: great, now you woke up gwern
17:15:59 <shachaf> Oops.
17:16:04 <lispy> ops?
17:16:06 <lispy> :)
17:16:16 <covi> Guys can you take a look at this snippet: http://hpaste.org/63848; ghci fails to load it
17:16:18 <lispy> gwern: shouldn't you be posting interesting articles on g+?
17:16:22 * gwern yawns, exposing long yellowed teeth, awoken from unquiet dreams of p-values and Zeo sleep data
17:16:37 <gwern> lispy: that's for when I don't have a head-cold
17:16:41 <lispy> covi: are you working on homework? (that's okay, but it does help us to know how to help you)
17:17:05 <shachaf> covi: You should post the error along with the snippet when you ask a question like that. It makes life much easier for everybody.
17:17:16 <covi> lispy: just a code-practice platform called projecteuler.net
17:17:46 <lispy> covi: pro-tip: if you have | some boolean expression = True | otherwise = False, you could just do = some boolean expression
17:17:56 <covi> shachaf: sorry, next time I will
17:18:11 <lispy> covi: this would apply in your isPalindrome function
17:18:29 <lispy> covi: you don't need the "if" in your list comp
17:18:40 <JoeyA> @pl \n -> show n == reverse (show n)
17:18:40 <lambdabot> liftM2 (==) show (reverse . show)
17:18:53 <lispy> > [ x | x <- [1..], even x] -- like this
17:18:55 <lambdabot>   [2,4,6,8,10,12,14,16,18,20,22,24,26,28,30,32,34,36,38,40,42,44,46,48,50,52,...
17:18:56 <shachaf> You also don't need the (== True).
17:19:08 <lispy> covi: notice how I just put in the "even x" and it does what you want
17:19:50 <covi> yeah :)
17:20:24 <covi> now ghci loads it, but it errors   No instance for (Show ([Int] -> [Int])) arising from a use of `print'
17:20:36 <covi> (I called 'ans')
17:20:42 <lispy> covi: That means you tried to show a function of type [Int] -> [Int]
17:21:15 <liyang> shachaf: it's srsbsnss, this. :)
17:21:23 <latros> I see the mistake
17:21:25 <lispy> covi: I would add an explicit type signature for ans, then you'll get a new error that is more informative
17:21:26 <latros> @type max
17:21:27 <lambdabot> forall a. (Ord a) => a -> a -> a
17:21:32 <latros> that may help you
17:21:42 <lispy> covi: the type of ans would be?
17:21:49 <covi> lispy: Int
17:22:01 <lispy> okay, so add that
17:22:09 <lispy> :t maximum
17:22:10 <lambdabot> forall a. (Ord a) => [a] -> a
17:23:04 <covi> gimme a sec... why can't max be applied here
17:23:29 <covi> since function is curried, why applying max to a list fails?
17:24:21 <lispy> :t max []
17:24:22 <lambdabot> forall a. (Ord a) => [a] -> [a]
17:24:40 <lispy> covi: if you apply max to a list then it returns a function that takes a list and gives a list
17:24:48 <lispy> covi: is that what you want here?
17:25:17 <covi> lispy: no, maximum is what I want
17:25:34 <covi> when do you typically use max to a list?  I can't infer from the sig
17:26:19 <lispy> > maximum [ x*y | x <- [100..999], y <- [x .. 999], show (x*y) == reverse . show $ x*y ]
17:26:20 <lambdabot>   Couldn't match expected type `GHC.Types.Char'
17:26:20 <lambdabot>         against inferred type...
17:26:34 <otters> euler
17:26:37 <lispy> > maximum [ x*y | x <- [100..999], y <- [x .. 999], show (x*y) == (reverse . show) x*y ]
17:26:37 <lambdabot>   No instance for (GHC.Num.Num [GHC.Types.Char])
17:26:38 <lambdabot>    arising from the literal ...
17:27:25 <lispy> > maximum [ x*y | x <- [100..999], y <- [x .. 999], show (x*y) == (reverse (show x*y) ]
17:27:26 <lambdabot>   <no location info>: parse error on input `]'
17:27:29 <lispy> > maximum [ x*y | x <- [100..999], y <- [x .. 999], show (x*y) == (reverse (show x*y)) ]
17:27:30 <lambdabot>   No instance for (GHC.Num.Num GHC.Base.String)
17:27:30 <lambdabot>    arising from the literal `...
17:27:39 <lispy> Hmm
17:28:05 <lispy> > maximum [ x*y | x <- [100..999], y <- [x .. 999], show (x*y) == (reverse (show (x*y))) ]
17:28:07 <lambdabot>   906609
17:28:22 <lispy> Silly precedence
17:31:41 <gwern> > (1/20) * 100
17:31:42 <lambdabot>   5.0
17:31:49 <gwern> > (1/21) * 100
17:31:50 <lambdabot>   4.761904761904762
17:31:53 <gwern> > (1/22) * 100
17:31:53 <lambdabot>   4.545454545454546
17:31:58 <gwern> > (1/25) * 100
17:31:59 <lambdabot>   4.0
17:32:04 <gwern> hm
17:32:24 <gwern> > (1/30) * 100
17:32:24 <lambdabot>   3.3333333333333335
17:34:44 <Ralith> gwern what are you doing
17:35:26 <MiggyX> Hi guys, is there a native Haskell function for converting an integer (i.e four bytes from a nework packet) to an IP address? I've found some modules that can sort of do it, and posts on using inet_ntoa, but I wanted to check there wasn't a more idiomatic way...
17:35:41 <gwern> Ralith: the new modafinil seller's FAQ quoted a loss rate to customs of 3% and said to me that she had shipped over 20 packages and also that she had read my modafinil page carefully, so I was wondering if she had taken the stats part to heart and had used laplace's law of succession to estimate the loss rate from shipping 20-30 packages without any losses
17:36:07 <gwern> Ralith: but as you can see, even assuming she had shipped 30 packages, laplace's law of succession still spits out >3% odds
17:36:47 <gwern> so now everyone knows that behind my little calculations here usually lie some pretty odd and abstruse questions :)
17:36:54 <kadoban> hmm, sorry for the lame question, but where can i find the actual definitions of [] and (:) ? or are they not implemented in haskell code exactly?
17:37:12 <lispy> MiggyX: Sorry, no idea.  If you endup needing to use inet_ntoa you could use the FFI to call it.
17:37:18 <Ralith> gwern: you know ghci is a thing right
17:37:32 <rwbarton> @src []
17:37:32 <lambdabot> data [] a = [] | a : [a]
17:37:35 <gwern> dammit Ralith I'm a gwern not a doctor not a rocket surgeon
17:37:42 <lispy> kadoban: Not literally implemented because they need syntatic sugar
17:37:59 <lispy> kadoban: but the definition that rwbarton showed you is how you can think of them
17:38:09 <elliott> Ralith: but gwern's calculations are exciting!
17:38:17 <elliott> every one hides a story that we have to figure out
17:38:44 <kadoban> lispy: ah, okay.  thanks both.  (was trying to create kind of a custom version, was wondering if i could use similar characters like : for a data constructor)
17:39:00 <parcs`> MiggyX: Network.Socket has an inet_ntoa
17:39:12 <Ralith> the story behind this one was "gwern is bad at mental arithmetic" :D
17:39:17 <parcs`> but it can easily be done in a pure fashion
17:39:39 <parcs`> > foldl ((+) . (`shiftL` 8)) 0 (reverse [127,0,0,1]) :: Int
17:39:40 <lambdabot>   16777343
17:40:14 <gwern> Ralith: I've never been too good at decimals and today is especially bad...
17:40:52 <lispy> kadoban: Yeah, you can
17:41:03 <lispy> kadoban: operators starting with : can be used infix
17:41:26 <lispy> kadoban: look at the Ratio type
17:41:46 <kadoban> thanks, ill take a look
17:42:07 <Cody_> :r
17:42:08 <lispy> http://www.haskell.org/onlinereport/ratio.html  <-- section 12.1
17:43:37 <liyang> Fun fact: ‘:’ is considered to be the sole ‘upper-case’ symbol.
17:43:53 <kadoban> oh, right...ya, that was dumb, was trying to use the operator type char as a data constructor, just need it as a function instead
17:43:58 <liyang> (Upper-case in the sense that constructor names have to begin with an upper-case letter.)
17:45:59 <edwardk> liyang: for now. =) looks like that is going to change at the type level though
17:46:26 <edwardk> can finally make some nicer looking infix operators
17:47:37 <liyang> I miss Agda's mixfix operators. ;_;
17:49:38 <MiggyX> parcs`, awesome thanks :)
17:51:21 * hackagebot http-date 0.0.2 - HTTP Date parser/formatter  http://hackage.haskell.org/package/http-date-0.0.2 (KazuYamamoto)
18:00:10 <peterjoel1> Hi, what's the standard prelude function that I'm looking for, which behaves like this:
18:00:13 <peterjoel1> accum _ [] = []
18:00:13 <peterjoel1> accum _ (x:[]) = [x]
18:00:13 <peterjoel1> accum f (x:xs) =  x : (map (f x) $ accum f xs)
18:00:36 <napping> scanl?
18:00:55 <peterjoel1> ah… yes I think so. Thanks.
18:01:14 <napping> it's not quite the same, but something like that
18:01:30 <peterjoel1> yes it's what I wanted thanks
18:01:36 <peterjoel1> scanl1 is the same
18:06:43 <MiggyX> hmm, how would one go about converting a ByteString in network byte order into an Integer? I've tried looking for ByteString -> Integer, but no go so far...
18:07:07 <wavewave> peterjoel1 : hey!
18:07:32 <covi> Hi all. Why this code  http://hpaste.org/63849   is significantly slower than its python equilvalent (also included in the code)?
18:08:23 <latros> um
18:08:29 <latros> are you just getting the head of ans?
18:08:43 <latros> what are you actually asking the compiler for
18:09:13 <shachaf> What latros said is the most obvious issue.
18:09:39 <MostAwesomeDude> covi: Those aren't the same things.
18:09:49 <MostAwesomeDude> Oh, nevermind, they are.
18:09:59 <latros> head ans == find()
18:09:59 <covi> latros: theoretically ans will only contain one element.
18:10:04 <latros> oh?
18:10:08 <covi> yes.
18:10:12 <latros> I didn't check it
18:10:19 <latros> ok, fair enough
18:10:35 <wavewave> covi: so what's your benchmark result?
18:10:41 <latros> then I'm not sure
18:10:53 <latros> try compiling it instead of interpreting
18:10:56 <shachaf> The fact that it only contains one element doesn't matter when you still ask it to look for all of them.
18:10:58 <latros> and give benchmarks for that too
18:11:03 <latros> also true
18:11:04 <latros> very true
18:11:06 <shachaf> If you're using ghci that's indeed a huge slowdown.
18:11:23 <covi> shachaf: yeah I'm using ghci.. what else can I use?
18:11:26 <latros> because it will put in the element, which it will find partway through
18:11:30 <wavewave> covi: compile.
18:11:30 <shachaf> ghc
18:11:31 <wavewave> ghc
18:11:41 <latros> and then keep going
18:11:47 <covi> wavewave: I don't know what's a benchmark result :(
18:11:48 <elliott> covi: ghc -O2
18:11:51 <latros> but yes, you can get object code with ghc, which will be much faster
18:11:53 <wavewave> ah. one step slower.  :-P
18:12:18 <covi> thanks everybody
18:12:35 <wavewave> covi: hm? just asked about time elapsed in both languages.
18:12:57 <napping> covi: looks about twice as fast here
18:13:10 <latros> actually
18:13:16 <latros> I just noticed
18:13:24 <wavewave> napping : using ghc and python ?
18:13:26 <latros> there is actually a difference there, between asking for head ans and ans
18:13:34 <latros> even though the output is essentially the same
18:13:38 <latros> head ans would terminate when it finds a result
18:13:45 <hsimon> good morning. Is there a sensible way to define a do block within a let binding within a do bock?
18:13:45 <wavewave> napping : both compiled?
18:13:45 <latros> ans would go through, find one result, and then keep trying
18:13:59 <covi> latros: ahh
18:14:04 <napping> ghc -O2 time ~4s, python (CPython) ~8s
18:14:19 <ByronJohnson> hsimon: You can do that.  You'd just need to indent it properly.
18:14:23 <wavewave> hsimon : for a monad variable. yes
18:14:33 <latros> (note "essentially" the same, x and [x] are ofc different)
18:14:48 <hsimon> i know but i don't know how to indent it
18:14:49 <wavewave> do {let action= do { xxx } ; action }
18:14:58 <covi> latros: I do head ans in ghci, still so slow
18:14:59 <wavewave> this is possible.
18:15:02 <hsimon> it works if i put it all on one line after the let with semicolons
18:15:10 <shachaf> covi: ghci is slow. We've said this before. :-)
18:15:19 <hsimon> but if i put new lines on new lines it interprets it as new let bindings i think
18:15:35 <wavewave> compilation is fun!
18:15:41 <elliott> hsimon: you need to indent it past the "let "
18:16:03 <ByronJohnson> hsimon: The inner do block should be  indented more than "let "
18:16:16 <mandaya> hsimon: if you hpaste it, it'll be easier for people to show you what they mean
18:16:53 <wavewave> who maintain hpaste by the way?
18:17:19 <elliott> wavewave: chrisdone
18:17:22 <ByronJohnson> hsimon: I'd guess that you have the inner do block indented at the same level as the let block.  You'd just need to indent it more, beyond its name
18:17:30 <wavewave> elliott: aha, thanks.
18:18:05 <Zearen> For those with experience with the Snap framework:  I'm trying to figure out what kind of key is used by initCookieSession, but I'm having trouble finding documentation.  Does anyone know If I can just use a randomly generated key of proper length?
18:18:07 <wavewave> ah.. noticed that github source code now.
18:18:16 <hpaste> hsimon pasted “indenting” at http://hpaste.org/63850
18:18:20 <hsimon> that's not it
18:18:34 <hsimon> it's a conflict of indentation between let and do
18:19:01 <elliott> Yes, that is it.
18:19:05 <elliott> Like I said, it must be indented past the "let ".
18:19:10 <ByronJohnson> hsimon: "e <- ..." needs to be indented beyond "let "
18:19:19 <Cale> Indent it a little more. You're closing the 'let' block because the continuation lines are too shallow.
18:19:20 <hpaste> elliott annotated “indenting” with “indenting (annotation)” at http://hpaste.org/63850#a63851
18:19:20 <hsimon> oh, that makes a difference?
18:19:21 <ByronJohnson> hsimon: In the code you pasted, it's not
18:19:24 <elliott> That would work.
18:19:24 <hsimon> nice, thanks
18:19:40 <hsimon> i thought you meant i hadn't indented it at all
18:19:43 <latros> that code there parses as having a let binding that isn't syntactically valid on the RHS, yes?
18:19:54 <latros> as in, you get a binding "let step w = do"
18:19:56 <latros> with no do block
18:19:57 <Cale> yeah
18:20:19 <ByronJohnson> hsimon: If you want layout, yes.  You have another option: you can use braces and semicolons.
18:21:09 <Cale> The original broken code means  let { step w = do } e <- lookup dict w; update dict w (if isJust e then fromJust e + 1 else 1)
18:21:31 <Cale> which is syntactically invalid, yeah
18:21:52 <mandaya> where's that indentation guide...
18:22:08 <mandaya> ah, found it
18:22:11 <mandaya> http://en.wikibooks.org/wiki/Haskell/Indentation
18:33:24 <luxurymode> Can i not define functions in a ghci session? keep getting "not in scope: 'function_name' "
18:33:51 <ByronJohnson> luxurymode: You can only do that if you have 7.4 or newer
18:34:05 <shachaf> luxurymode: Use "let".
18:34:11 <ByronJohnson> Erm, with functions, you can just use "let"
18:34:18 <shachaf> ghci is sort of like a do block.
18:34:21 <nyingen> I'm trying to use with-compiler in my cabal/.config, but it's not working
18:34:28 <shachaf> Except that analogy is stretching thinner with every release.
18:34:28 <luxurymode> damn, i have 7.04
18:34:35 <nyingen> I put the full path to the compiler I want it to use, but it keeps using /usr/bin/ghc apparently
18:34:46 <shachaf> nyingen: What do you want it to use?
18:34:48 <zachk> im sorry but your ghc bin can not find your libgmp.3.so even though you symlinked to the latest libgmp.10.0.0.4.so :( h-e-l-p : during ./configure
18:34:53 <nyingen> /foo/bar/ghc
18:35:01 <shachaf> You could put /foo/bar in your $PATH...
18:35:04 <luxurymode> ByronJohnson, shachaf, so let functionname x = ...?
18:35:10 <dcoutts> nyingen: did you uncomment the line?
18:35:11 <shachaf> Or there's the "right" way to do it which is always too much trouble for me.
18:35:15 <shachaf> luxurymode: Try it and see!
18:35:22 <nyingen> dcoutts: oh god, I'm an imbecile
18:35:43 <nyingen> to my credit, though, the system I'm on doesnt' have syntax highlighting on by default
18:35:55 <nyingen> blue text would have been a dead giveaway :)
18:36:08 <luxurymode> shachaf, how can i do it for something like factorial :: (Integral a) => a -> a
18:36:11 <dcoutts> nyingen: apparently it's not at all obvious, we added a comment to the top of the file but that doesn't always help :-)
18:36:15 <shachaf> luxurymode: Semicolons.
18:36:42 <nyingen> dcoutts: I think it's because I didn't realize the file would be in haskell format
18:36:53 <nyingen> I mean, I should have figured, but with no .hs extension, I guess my brain just didn't go into hs-mode
18:37:15 <luxurymode> shachaf, semicolons?
18:37:15 <dcoutts> nyingen: it's same as .cabal format really, not quite .hs
18:37:26 <nyingen> ah
18:37:40 <elliott> luxurymode: let foo :: t; foo = ...
18:38:13 <ivanm> dcoutts: where ".cabal format" == "just enough like Haskell to trip everyone up" ? :p
18:38:32 <luxurymode> elliott, uh where in my example would that ; go
18:38:39 <luxurymode> i get "lacks an accompanying binding"
18:38:57 <elliott> luxurymode: let factorial :: (Integral a) => a -> a; factorial n = ...
18:39:06 <dcoutts> ivanm: yep :-)
18:39:32 <nyingen> dcoutts: thanks for saving me from myself
18:39:38 <dcoutts> ivanm: and also just enough like YAML to trip other people up :-)
18:39:46 <nyingen> I doubt I would have processed the '--' for quite some time
18:39:54 <ivanm> heh
18:40:04 <luxurymode> elliott, got it thanks!
18:40:08 <dcoutts> nyingen: np, I wonder if we can do better, clearly people don't read the comment at the top of the file
18:40:31 <shachaf> dcoutts: I've been told that .cabal files should just have used YAML.
18:40:31 <luxurymode> how do i exit ghci?
18:40:41 <ByronJohnson> luxurymode: ^D
18:40:45 <nyingen> hard to say. I just blew by everything in the file except the 'with-compiler' field
18:41:02 <ByronJohnson> luxurymode: Also, :quit
18:41:08 <luxurymode> awesome thanks
18:41:15 <luxurymode> how can i upgrade to 7.3 ;) ?
18:41:20 <luxurymode> 7.4*
18:42:15 <wavewave> luxurymode :   :q
18:42:16 <dcoutts> shachaf: I've been told that too, but after reading the YAML spec a few times I don't think I agree
18:42:29 <dcoutts> shachaf: plausibly a small subset
18:42:52 <edwardk> i rather prefer cabal's format to yaml
18:43:17 <shachaf> dcoutts: The person who told me that wrote the YAML spec, so he may be biased.
18:43:25 <elliott> I like cabal's format. Although it's not perfect.
18:43:48 <edwardk> keen in mind given shachaf's er.. relation to the yaml spec he may get more of that kind of talk than the rest of us ;)
18:43:55 <edwardk> er keep in mind
18:44:01 <dcoutts> shachaf: heh :-)
18:44:35 <shachaf> edwardk: Hah, indeed.
18:45:37 <cmccann> awesome, it took acid-state an hour and a half to finish checkpointing after I ran hackage for about 30min and didn't actually do anything with it
18:45:47 <shachaf> I also make fun of the YAML spec more than a lot of people do, I imagine.
18:47:00 <elliott> cmccann: That seems like it could be fixed.
18:47:15 <cmccann> with a sledgehammer hopefully
18:47:48 <elliott> cmccann: I get the feeling that's how you fix everything.
18:48:12 <cmccann> except for things that move too quickly to hit with a sledgehammer
18:48:14 <cmccann> which fortunately
18:48:17 <cmccann> does not include acid-state
18:48:19 <cmccann> at all
18:48:21 <cmccann> :D
18:48:59 <shachaf> Did you know the YAML spec is longer than the XML spec?
18:49:02 <wavewave> cmccann : are you running hackage for all packages now?
18:49:12 <otters> well doesn't YAML have more datatypes?
18:49:24 <cmccann> wavewave, I had it running locally, it's still pretty brutal but much better than it was before
18:49:35 <shachaf> Oh, there are plenty of reasonable reasons for it.
18:50:14 <wavewave> cmccann: great! soon we will be able to have the better hackage!
18:50:51 <cmccann> still wish I knew why the heap profiling doesn't seem to be working right
18:51:04 <cmccann> pretty sure I'm missing something :T
18:51:07 <nyingen> grr, this still isn't working
18:51:16 <nyingen> is there a way to verify which compiler cabal is using?
18:51:31 <lispy> nyingen: hmm
18:51:33 <dcoutts> nyingen: cabal configure -v
18:51:34 <nyingen> short of making a decoy shell script?
18:51:36 <nyingen> ah
18:51:38 <cmccann> nyingen, tell it be verbose
18:51:45 <cmccann> you'll be able to see all the commands it runs
18:51:54 <cmccann> as well as lots of other stuff
18:52:11 <lispy> Other than verbose are there ways?
18:52:15 <nyingen> looks ok
18:52:43 * lispy doesn't see nay
18:52:46 <lispy> any*
18:53:05 <nyingen> hm, maybe this is a different problem now. I'm trying to install language-c, but it's not finding the 'alex' package
18:53:08 <nyingen> I did install alex though
18:53:21 <lispy> nyingen: did you put alex in your path?
18:53:58 <byorgey> it's not finding the alex *executable*
18:54:01 * cmccann wonders what made acid-state take so long at shutdown anyway
18:54:33 <nyingen> lispy: wow, I'm just full of stupid this evening
18:54:37 <lispy> heh
18:54:39 <nyingen> you were right
18:54:48 <wavewave> acid-state sometimes bite me, too
18:54:52 <nyingen> I'm not used to installing stuff 'locally', and didn't realize the binary had gone to $HOME/.cabal/bin
18:54:56 <lispy> It's easy on a new install to miss the step of adding $HOME/.cabal/bin to PATH
18:55:01 <geekosaur> nyingen, you're also being confused by the factthat cabal doesn't really handle executables sensibly
18:55:37 <cmccann> hm, hackage is also using an older verison of acid-state
18:55:38 <geekosaur> cabal knows about libraries, not so much about executables.  so if you install an executables-only package like alex, it doesn't *know* yo installed it because it doesn't install a library
18:55:42 <glguy> cabal manages executables, now
18:55:51 <glguy> sorted them by version and symlinks
18:56:02 <lispy> Poor cabal, what with its identity crisis (is it a package manager? is it a build system? is it an elephant?)
18:56:17 <wavewave> acid-state 0.4 and 0.6 are not compatible in states
18:56:26 <geekosaur> did I miss a release announcement?  only thing I've seen recently is a "oh we fixed lots of things in HEAD but no clue when it'll be released!"
18:56:37 <lispy> glguy: oh yeah? New in the latest release?
18:56:50 <cmccann> wavewave, not really a problem for me yet
18:56:52 <Runar> edwardk: How are the pipes?
18:56:54 <dcoutts> I'm not sure what glguy means :-)
18:57:07 <dcoutts> geekosaur: no, you didn't miss a release
18:57:08 <edwardk> runar: going well
18:57:20 <Runar> edwardk: I encoded some of this in Scala and it's not terrible
18:57:27 <glguy> I mean when I look in my /bin I have symlinks into different versioned directories associated with the different packages
18:57:30 <edwardk> yeah
18:57:33 <glguy> rather than .cabal/bin being a dumping ground
18:57:54 <edwardk> the little coroutine functor makes it pretty nice actually
18:58:10 <dcoutts> glguy: that's not new, just how you (or the installer) configured it
18:58:12 <edwardk> did you get the version from the front board or are you still using what you photographed from the back one?
18:58:18 <geekosaur> right, but if alex isn't found in $PATH it'll still tell you to install the package, beause it can't see you already did :)
18:58:42 <glguy> dcoutts: but I don't know how it happened. I didn't set it up that way, but I like that it is
18:58:56 <dcoutts> glguy: I think the OSX HP installer sets the default ~/.cabal/config to use that scheme
18:59:00 <geekosaur> also, that symlinks thing?  does not work on OS X; I get bins installed into their versioned dirs and *nothing* in ~/Library/Haskell/bin *sigh*
18:59:05 <glguy> ah, that makes sene
18:59:15 <glguy> geekosaur: you need to fix your .cabal/config, then
18:59:19 <geekosaur> or ~/.cabal/bin for that matter
18:59:28 <geekosaur> (this on a stock install)
18:59:30 <Runar> edwardk: a little of both I think
18:59:40 <geekosaur> (so if .cabal/config is wrong, it was installed that way)
18:59:47 <dcoutts> geekosaur: apparently the OSX Haskell devs cannot decide where the right place is, if there's any consensus we can easily change the default.
18:59:48 <edwardk> fair nuff
19:00:10 <Runar> edwardk: Did you end up using Fan?
19:00:35 <dcoutts> geekosaur: part of the reason the default config isn't to stick symlinks into ~/bin is because nobody seems to be able to agree on this stuff
19:01:12 <dcoutts> I think the symlinks in ~/bin to files installed in ~/.cabal/ is a good scheme
19:01:28 <dcoutts> I'd prefer to make it the default config
19:01:43 <dcoutts> but then apparently ~/bin isn't on the $PATH on many distros anyway
19:01:48 <nyingen> dcoutts: again, there was a message to the effect "installing executables in ~/.cabal/bin" but I didn't pay enough attention at first
19:02:01 <dcoutts> and OSX doesn't seem to have any per-user bin dir on the $PATH
19:02:14 <dcoutts> so hard to give a smooth user experience :-(
19:02:32 <nyingen> well, it's a tough problem
19:02:40 <nyingen> and now that I know how it works, it seems to make sense
19:02:48 <nyingen> i.e. I wouldn't suggest any changes to any of this
19:02:59 <geekosaur> yeh, by default there's no per-user bin directory.  ~/bin is probably reasonable (I use ~/.bin but that's just me)
19:03:32 <dcoutts> geekosaur: and I've no idea what ~/Library/Haskell/bin is, something the HP installer makes?
19:03:39 <glguy> seems so
19:03:44 <dcoutts> is it kosher to install extra stuff there?
19:04:08 <dcoutts> if it is, I expect the OSX HP installer would have configured it that way
19:04:33 <geekosaur> dcoutts, it seemed to me that about half of stuff I built with cabal that installed executables used ~/Library/Haskell/bin and half of it used versioned subdirectories
19:04:37 <edwardk> yeah
19:04:43 <lispy> Apple doesn't provide much guidance about user dirs.  So it's a free for all, right?
19:04:51 <geekosaur> with no obvious logic (first thing I checked was exec-only vs. exec-plus-lib)
19:05:12 <edwardk> data Fan :: (* -> *) -> (*,*) -> * where Read :: f (Fan f out) -> Fan f out; Write :: (s -> Free f (o, Fan f '(o,s))) -> Fan f '(o,s)
19:05:18 <dcoutts> geekosaur: sound mad
19:05:21 <dcoutts> sounds
19:05:28 <geekosaur> quite.
19:05:41 <dcoutts> certainly it's not the default cabal config
19:05:52 <lispy> Speaking of cabal and pathing, the Paths_foo mechanism drives me crazy
19:05:58 <geekosaur> thing is, if it had found a cabal config to use, that would have told it to use ~/.bin
19:06:07 <geekosaur> because that's what I put in my default cabal config on linux/fbsd
19:06:08 <lispy> The thing I don't like is that it's an absolute path at compile time
19:06:19 <edwardk> then newtype Pipe p q = Pipe { runPipe :: Fan (F p) q }
19:06:28 <lispy> Move your stuff after compile time? Better rebuild.
19:06:34 <dcoutts> lispy: you can override the paths with env vars
19:06:43 <edwardk> and Tee p q r = Tee { runTee :: Fan (These (F p) (F q)) r }
19:06:47 <lispy> dcoutts: don't make me start a rant about ENV vars :)
19:06:55 <glguy> Does cabal-install have a maintainer? Now that there is a GHC 7.4.1 is anyone in particular in charge of releasing a version of cabal-install with a cabal file that works out of the box?
19:06:57 <dcoutts> lispy: if relocatable exes worked better we might be able to use that
19:07:00 <geekosaur> I really have no idea where it came up with what it's been doing, even after I wiped my ~/.cabal and ~/Library/Haskell and started over from scratch
19:07:05 <dcoutts> glguy: yes, me
19:07:24 <lispy> dcoutts: I think I want a relative path mechanism.
19:07:51 <dcoutts> lispy: we support relocatable packages on windows, needs support for other OSs
19:07:55 <lispy> I'm not certain, but I think that is typically what I expect it to be
19:09:20 <glguy> Anyone know if it is an oversight that we have "withArgs" and "withProgName" but not "withEnv"?
19:09:45 <dcoutts> geekosaur: if you wipe your ~/.cabal then it'll be recreated with default config next time, that'll use the ~/Library/Haskell again I think. That's what the OSX HP installer changes vs a vanilla cabal installation
19:09:49 <lispy> dcoutts: I think it could probably be easily fixed by having different options for the Paths module.  Relative_Paths_foo that allows you to get paths relative to your exe, for example.
19:10:06 <shachaf> glguy: Well, getEnv :: String -> IO String
19:10:23 <shachaf> Oh, but there's a getEnvironment
19:10:31 <glguy> shachaf: the "with" family runs the continuation with an alternate value
19:10:35 <dcoutts> lispy: I don't think we can make it something you can depend on, because we cannot support it on all systems
19:10:51 <lispy> dcoutts: I don't understand
19:11:19 <geekosaur> dcoutts, did you see my previous message?
19:11:20 <shachaf> glguy: Right, I just mean that it's not quite a simple a value substitution as the other two.
19:11:22 <dcoutts> lispy: plus, the choice of absolute or relocatable is something the package builder, not author, should pick
19:11:36 <shachaf> Anyway, I don't know.
19:11:37 <geekosaur> [17 04:11] <geekosaur> I really have no idea where it came up with what it's been doing, even after I wiped my ~/.cabal and ~/Library/Haskell and started over from scratch
19:11:56 <dcoutts> geekosaur: yes, that's what I was responding to
19:11:58 <Runar> edwardk: An F is the Moore functor?
19:12:14 <lispy> dcoutts: So you could have Agnostic_Paths_foo for that choice :)
19:12:14 <geekosaur> so, wipe a second time and in theory it would behave?  why not after the first?
19:12:20 <edwardk> runar: yeah
19:12:41 <edwardk> data F :: (*,*) -> * -> * where F :: s -> (i -> a) -> F '(i,s) a
19:12:47 <dcoutts> geekosaur: no, I'm saying it's not surprising it still uses ~/Library/Haskell after you wiping
19:12:51 <lispy> dcoutts: But, I don't understand why you need platform support for this
19:13:02 <Runar> oh, the Mealy functor I mean
19:13:03 <dcoutts> geekosaur: because ~/Library/Haskell was the default config, as set by the OSX HP installer
19:13:39 <dcoutts> geekosaur: at least I think that's where it's coming from, I'm not 100% what default config the OSX HP installer uses
19:13:58 <dcoutts> but you'll get that config first time, and every time you wipe the config
19:14:16 <dcoutts> lispy: to find anything relative to the executable / library
19:14:45 <dcoutts> lispy: Windows makes it easy, linux harder for exes and impossible for libs, OSX not sure
19:15:04 <lispy> linux may be the odd man out
19:15:21 <CodeWeaverX> OSX uses an environment system similar to linux.  nothing really magic there. It's a BSD mutant if I recall.
19:15:39 <lispy> OSX has ways of finding things
19:15:49 <dcoutts> lispy: hence as package author you cannot depend on the details of whether it finds data files relative to exe or by absolute path
19:15:51 <lispy> Works especially well for app bundles
19:16:17 <lispy> dcoutts: and yet, we're forced by the current system to depend on absolute path
19:16:23 <dcoutts> lispy: but the package builder can choose an absolute or prefix-independent build
19:16:50 <geekosaur> lispy, those mechanisms are *specific* to app bundles
19:16:54 <Runar> edwardk: Was Sink cofree of F?
19:16:54 <lispy> how do you do the prefix-independent build?  Or do you mean, they pick a prefix at compile time?
19:17:04 <dcoutts> so long as the compiler+platform supports it
19:17:18 <edwardk> runar: nah it was effectively Cofree (Maybe . F in)
19:17:44 <geekosaur> in very recent (SL+) OS X there are some limited forms of the app-bundle-specific prefixes that work for some non-bundles, but it's much less flexible or useful IIRC
19:18:18 <Runar> edwardk: Yeah, that
19:18:25 <dcoutts> lispy: no, that's absolute. See http://www.haskell.org/cabal/users-guide/#prefix-independence
19:19:04 <edwardk> runar: note: you can actually tie off some inputs with a mealy machine from the signal to inputs
19:19:08 <dcoutts> lispy: though I'd like to change the UI for it slightly, and I think it is possible to support on linux
19:19:30 <Runar> edwardk: How do you mean?
19:19:54 <Runar> "tie off"?
19:19:59 <dcoutts> lispy: also needs some shared lib funkyness to get the links between .so files to work with relative paths
19:20:12 <edwardk> like how sink takes its input and gives you back a value
19:20:19 <lispy> dcoutts: so prefix-independence really means it's fixed at install time instead of compile time?
19:20:37 <dcoutts> lispy: no, means it really can be moved around the file system and still run
19:20:37 <edwardk> you can wire up a source on the other side of a pipe that uses the signal to generate its values
19:20:47 <dcoutts> lispy: even after installation
19:20:50 <lispy> dcoutts: okay. So that's the sense that I mean relative.
19:21:05 <edwardk> so if you look at the network diagram of these things using the notation i was using it would have a mealy machine feeding out to the right
19:21:13 <edwardk> but nothing coming in from the left
19:21:24 <lispy> dcoutts: if there was a general mechanism for that in cabal, it would be great.
19:21:38 <lispy> (sounds like the current one is very contingent)
19:22:04 <dcoutts> lispy: yes, it's doable, but there's not been huge demand, so not got to the top of the pile
19:22:22 <dcoutts> doable on most platforms we care about
19:22:26 <Runar> edwardk: So a machine that generates inputs in response to signals coming back from whatever is reading those inputs
19:22:36 <edwardk> yeah
19:22:38 <Runar> cute
19:22:41 * elliott wonders what the Sink Runar is referring to is
19:22:51 <edwardk> elliott: been playing with a new iteratee type
19:23:03 <elliott> ah! is this the one copumpkin was talking about? I think he mentioned you.
19:23:13 <edwardk> elliott: nah copumpkin hasn't seen this one yet =)
19:23:14 * lispy says it's time to leave
19:23:18 <dcoutts> lispy: the other thing I'd like to do is rearrange dist and add an inplace/bin with scripts that call the exes with the right env var overrides to work in the build tree
19:23:26 <edwardk> i did spend some time with copumpkin and xplat at hac boston working on a version
19:23:32 <edwardk> (and ezyang)
19:23:38 <vyom> is there something special i need to do in order to get trace outputs to show up. I have imported Debug.Trace and I using cabal build to build my project
19:23:45 <edwardk> but this is different
19:24:02 <lispy> dcoutts: yeah, that makes it easier to test without installing.
19:24:04 <edwardk> actually its rather closely related to my coroutine based io
19:24:32 <dcoutts> lispy: in the mean time, use foo_data=. dist/build/foo/foo
19:24:34 <lispy> dcoutts: but, having to call it via a script is not fully satisfying
19:24:39 <dcoutts> erm foo_datadir
19:24:43 <edwardk> taking a moore machine apart into its base functor then using that functor over and over as the inputs and outputs of sources sinks and pipes
19:24:53 <lispy> anyway, I need to go
19:24:54 <dcoutts> lispy: true
19:25:18 <edwardk> which lets you do enumerator/enumeratee-like things and maintain things as functors, do tee-joins without mucking up iteratees with monadic side-effects, etc.
19:25:19 <byorgey> vyom: and then you used the 'trace' or 'traceShow' functions somewhere?
19:26:00 <vyom> byorgey: yes ofcourse.. I can see that the expression is being evaluated.. But I am seeing no trace output.. Let me post a code snippet
19:26:15 <cmccann> edwardk, huh, I was actually hacking on something similar to that earlier
19:26:25 <cmccann> before I got side-tracked on this hackage nonsense
19:26:28 <edwardk> hah
19:26:45 <cmccann> but mine was slightly more general than that it sounds like
19:26:50 <edwardk> it'll be the first iteratee library that uses profunctors in anger ;)
19:27:11 <cmccann> mostly in that mine was treating inputs and outputs uniformly
19:27:19 <cmccann> and manipulating streams of combinations of either
19:27:24 <edwardk> yeah, sources and sinks in this actually are symmetric in a fashion
19:27:37 <cmccann> had stuff for push vs. pull in both directions
19:28:04 <edwardk> every time i send info on a 'channel' i get a signal back, so the symmetry you mention is there after a fashion
19:28:59 <cmccann> edwardk, I can show you the stuff I was working on if you're interested
19:29:07 <edwardk> sure
19:29:19 <cmccann> it wasn't really done, I got stuck trying to figure out the type to express one way of combining the streams
19:30:58 <edwardk> right now my combinations come from a fairly generic Fan functor which can be used to model pipes, pure sources and tees in the graph
19:31:20 <edwardk> and fan outs come largely from the fact that there is an applicative/monad for sinks
19:31:29 <edwardk> so you can combine sinks that way
19:31:47 <adnauseam> i must admit, after being here for about two days now, i've understood very little of what you guys have been saying :/
19:32:00 <adnauseam> we'll see if that changes after i open a book and read what haskell's about
19:32:02 <cmccann> yeah, I had T-intersections going both forward and backward, plus a few other ways of merging streams
19:32:06 <Runar> edwardk: How are you using Profunctor?
19:33:21 <edwardk> sinks are Pipe -/-> Hask profunctors, Pipes are Pipe -/-> Pipe profunctors because they form a category, etc.
19:33:45 <Runar> edwardk: Can we peek over your shoulder?
19:33:50 <edwardk> technically tees are also Pipe -/-> Pipe profunctors, but thats rather insufficient
19:34:05 <edwardk> its mostly a mishmash of type signatures right now =)
19:34:45 <glguy> adnauseam: You can be great at Haskell without knowing what edwardk is talking about :)
19:34:55 <edwardk> glguy: hahaha
19:35:00 * elliott reads what edwardk said
19:35:06 <cmccann> frankly I'm not sure anyone knows what edwardk is talking about most of the time
19:35:07 <edwardk> you can be edwardk without knowing what edwardk is talking about
19:35:11 <cmccann> haha
19:35:55 <elliott> adnauseam: "profunctor" has very little to do with haskell
19:35:58 <elliott> other than being implementable in it
19:36:09 * elliott is interested in seeing both cmccann's and edwardk's code :P
19:36:13 <adnauseam> glguy: i hope to become good at it, i've read so many things that made a good impression. =} i'm going to start reading learn you a haskell this sunday
19:36:45 <edwardk> elliott: there will definitely be a blog post before too long, the main problem is writing it in a form that can be compiled by the current ghc before they give me kind signatures for polymorphic kinds
19:36:58 <cmccann> elliott, oh yeah, I'll toss you a copy as well, you were already interested in this last time I mentioned it
19:37:22 <adnauseam> elliott: hrm, i see, i'm guessing it's a design pattern of some sort
19:37:33 <adnauseam> i won't bother you with questions to things i can google though:}
19:37:44 <cmccann> sounds like mine has much fancier types than edwardk's but less fancy other stuff involving kinds or whatnot :P
19:38:09 <edwardk> cmccann: did you throw a link up?
19:38:25 <cmccann> not yet, it's all disorganized right now
19:38:33 <adnauseam> i've noticed that many of the discussions around here revolved around implementing various mathemtiacal aspects in haskell. is it done for the mathematics, or is it part of how the language works ?
19:38:39 <cmccann> I want to clean things up a bit and put it on github
19:38:45 <elliott> adnauseam: It's a mathematical design pattern... also known as a structure :P
19:39:01 <elliott> adnauseam: A design pattern is an abstraction your language is too weak to formalise.
19:39:39 <elliott> adnauseam: Haskell was designed by people with strong mathematical knowledge, so there are several concepts in the standard libraries modelled after things from category theory. But you don't need to know category theory to use them.
19:39:41 <edwardk> cmccann: you'll be proud to note that i stole 'These'
19:39:42 <edwardk> ;)
19:39:50 <edwardk> though admittedly i lifted it a kind level
19:39:59 <shachaf> @quote kmc haskell.*math
19:40:00 <lambdabot> kmc says: it's important to show that Haskell is usable not just for useless maths, but also for real-world tasks such as rendering teapots
19:40:02 <elliott> adnauseam: They just took them directly, rather than reinventing it independently and giving it a different name.
19:40:04 <cmccann> edwardk, hahaha
19:40:05 <shachaf> @quote kmc haskell.*mathem
19:40:05 <lambdabot> kmc says: Haskell isn't really designed by mathematicians. it's designed by people who programmers would consider to be mathematicians and mathematicians would consider to be programmers
19:40:09 <adnauseam> would haskell actually be good at learning maths indirectly ? :o
19:40:10 <elliott> adnauseam: So, it's a cultural thing, mainly.
19:40:29 <elliott> adnauseam: You do not need to know mathematics to get into Haskell at all, but if you stick at it long enough you mind end up picking up some basic category theory.
19:40:32 <adnauseam> ie, would goose chases after how to implement haskell give a student mathematical insight
19:40:35 <adnauseam> ?
19:40:40 <elliott> Not mathematics in general. But certain parts of it.
19:40:42 <elliott> Not implementation.
19:40:42 <adnauseam> oh, excellent
19:40:48 <cmccann> edwardk, not sure it counts unless you also have all of elliott's instances for it though
19:40:50 <elliott> That would be an exercise in applied CS.
19:40:56 <adnauseam> that is still a very good aspect
19:41:05 <elliott> But reading edwardk's blog posts and libraries might help ;)
19:41:17 <zzo38> I am making a text adventure system in Haskell. Here is some types is this good to you?   type GameFunction = (Game, TranscriptItem) -> (String, SystemRequest); data SystemRequest = UserInput !String !Game | UserDirectInput !String !Game | RewindTo !Int (Game -> Game) | RequestRandomNumber !Int !Game | GameOver;  Please tell me if there can be change or whatever
19:41:24 <edwardk> can't. its data These f g a = This (f a) | That (g a) | These (f a) (g a)
19:41:39 <cmccann> ahh
19:41:42 <cmccann> yes that does change things
19:41:45 <adnauseam> i'm very excited to learn it myself, and someday help others learn it
19:41:53 <cmccann> but it's the names that matter I suppose
19:42:02 <edwardk> yeah
19:42:08 <cmccann> a rose by any other name would be not-a-rose and all that
19:42:31 <edwardk> i use them in non-deterministic tees, and Either when they deterministically choose their input source
19:42:59 <zzo38> edwardk: I think that type will certain be Functor if f and g is, but I don't know what else it would be?
19:43:32 <elliott> edwardk: maybe that should be added to these :P
19:43:32 <edwardk> zzo38: thats all i need it to be. you can derive foldable and traversable, and some other things using the same logic
19:43:40 <elliott> edwardk: still has Functor/Bifunctor!
19:43:55 <edwardk> elliott: just functor, the other arg has the wrong kind =)
19:44:13 <elliott> oh, right
19:44:29 <cmccann> edwardk, incidentally, that's basically the sum of the forward and backward nondeterministic tees in my stuff
19:44:31 <elliott> edwardk: make it data These f g a b = This (f a) | That (g b) | These (f a) (g b) :P
19:44:58 <edwardk> cmccann: ?
19:45:30 <edwardk> cmccann: both f and g point 'backward' in that. i use it as a functor argument to Fan
19:45:44 <cmccann> yeah
19:45:55 <cmccann> in mine it depends on what f and g are
19:46:04 <edwardk> Pipe in out = Fan (F in) out     Tee in1 in2 out = Fan (These (F in1) (F in2)) out
19:47:01 <rwbarton> is there some way to write down a kind-polymorphic Arr so that Arr * = (->) and Arr (* -> *) = Trans where newtype Trans f g = Trans (forall a. f a -> g a) etc.
19:47:04 <edwardk> each of those args is secretly a pair of args because they are being tupled up at the kind level, but the gist is there
19:47:33 <edwardk> rwbarton: yes. thats what my polykinded category code allows
19:47:34 <cmccann> e.g. if f is (In a) and g is (In b) then These would be a passive choice that accepts a push from either input, while This | That would be an active choice that pulls from either input
19:47:48 <edwardk> rwbarton: not Arr, but Category at least
19:48:01 <elliott> edwardk: I think rwbarton is defining "Arr".
19:48:02 <cmccann> it's kind of convoluted I guess but I like how it works
19:48:10 <elliott> rwbarton: I doubt it.
19:48:12 <QinGW> Where can I find some stuff about talking to java with FFI?
19:48:14 <edwardk> cmccann: yeah thats exactly what i'm doing
19:48:24 <edwardk> oh
19:48:30 <edwardk> then no =)
19:48:30 <elliott> QinGW: I gather it's unpleasant.
19:48:32 <rwbarton> I want to define this particular Arr with a finite amount of work somehow
19:48:39 <elliott> I don't think there's any "pre-packaged" stuff that works nowadays.
19:48:43 <edwardk> there isn't a way to make a kind indexed type family right now
19:49:13 <cmccann> edwardk, and if f is (Out a) and g is (Out b) then it's the other way around, either accepting a pull from either, or pushing to either
19:49:29 <cmccann> it's very tidy, albeit slightly complicated to implement
19:49:31 <edwardk> rwbarton: the best i can offer is a class Category k where id :: k a a; (.) :: k b c -> k a b -> k a c  under polykinds which lets k be anything with kind x -> x -> *
19:49:39 <edwardk> cmccann: *nods*
19:50:15 <edwardk> yeah that actually fits with the fan out code i sketched, but i've deliberately chosen not to put in fan outs for now and to use the monad for sink instead
19:50:30 <edwardk> that way you can fanout by combining sinks direclty
19:50:32 <edwardk> er directly
19:50:36 <edwardk> since the sinks don't consume
19:50:47 <QinGW> elliott: If I want to use web service which write using java, Which hackage I can use to talking with http?
19:50:48 <edwardk> so when you glue them together applicatively you are feeding both sinks
19:50:49 <rwbarton> I guess in my Arr example the kind application would actually want to be implicit?
19:50:52 <cmccann> well, I don't have special types for sinks and sources
19:50:56 <elliott> QinGW: http-conduit for a client?
19:51:14 <edwardk> rwbarton: well, byorgey's kind polymorphism proposal included kind indexed type families, but the current implementation does not
19:51:26 <QinGW> thanks elliott, I will take a look.
19:51:38 <byorgey> edwardk: not true!
19:51:45 <cmccann> edwardk, I also have two ways of combining streams that synchronize instead of interleave
19:51:48 <rwbarton> right a kind indexed type family is what I want, I think, just wondering about the syntax
19:51:51 <byorgey> the current implementation DOES have (some) support for kind indexed type families.
19:52:01 <edwardk> byorgey: well, it doesn't have any syntax to build one ;)
19:52:06 <cmccann> edwardk, but one of those two is not working well so far :T
19:52:07 <byorgey> yes it does.
19:52:10 <edwardk> ?
19:52:18 <edwardk> do tell!
19:52:32 <byorgey> I've done it.  I don't remember exactly how off the top of my head.
19:52:38 <rwbarton> ha
19:52:43 <edwardk> in all seriousness. you might save a huge project i tried and failed on
19:52:50 <Algo> I'm a math student... Haskell seems like a great language for the type of work I do. Is there a way to make the task of programming more palatable?
19:53:04 <Algo>  the actual projects I see people do require stamina and attention to details that aren't quite natural to me for some reason
19:53:09 <edwardk> algo: i find that learning haskell is the best way i know to make the task of programming more palatable
19:53:10 <byorgey> it's something like  type instance Foo (t :: * -> *) = ... t ...
19:53:24 <edwardk> byorgey: hrmm
19:53:34 <rwbarton> could you use a kind variable there?
19:53:37 <elliott> no
19:53:40 <elliott> there is no explicit syntax for them
19:53:42 <rwbarton> type instance Foo (t :: k -> k')
19:53:44 <edwardk> so the type family itself is assumed polymorphic in each argument then?
19:53:45 <elliott> at all
19:53:51 <faux-perseus> think of programming as theorem proving
19:53:57 <edwardk> rwbarton: there you're screwed. the kind variables you can't put in
19:54:02 <byorgey> edwardk: it has to be declared so, I think
19:54:09 <edwardk> you have to kind of imply them
19:54:13 <byorgey> yeah, you can't do it with polymorphic kinds yet
19:54:13 <elliott> Algo: well, there's project euler... but that's much more mathematics than programming
19:54:14 <rwbarton> so I guess I can define Arr on finitely many kinds
19:54:18 <rwbarton> but not all of them
19:54:18 <edwardk> byorgey: but how do i declare it polymorphically?
19:54:20 <glguy> faux-perseus: without all that pesky soundness, right?
19:54:24 <elliott> Algo: haskell is pretty "fun" as these things go
19:54:29 <rwbarton> or, wait
19:54:37 * elliott gives Algo the standard http://learnyouahaskell.com/ recommendation
19:54:37 <edwardk> or that the kind is the index
19:54:45 <faux-perseus> instant feedback ::-
19:54:50 <byorgey> edwardk: oh, or maybe it is inferred, not sure
19:54:56 <edwardk> i can see how i would write the type instance, just not the family
19:55:09 <rwbarton> byorgey, in your example can I add another declaration type instance Foo (t :: *) = ...
19:55:18 <byorgey> rwbarton: yes
19:55:25 <Algo> elliott I'm studying number theory :)
19:55:59 <Algo> elliott what is the best way to start learning Haskell before something like projecteuler
19:56:08 <byorgey> I am 100% sure I have gotten something like this to work, and I discussed it with SPJ and Julien who implemented it
19:56:10 <elliott> learn you a haskell is the bset way to laern haskell in general
19:56:18 <elliott> but project euler is generally a bad choice for haskell newbies
19:56:37 <tikhonjelvis> Eh, the first problems are sufficiently easy but still interesting, I think.
19:56:37 <elliott> edwardk: "type family Foo t :: *"?
19:56:54 <elliott> tikhonjelvis: well Algo is doing number theory, so ... but you run into issues like strictness quickly
19:56:54 <edwardk> elliott: the problem is you need for Arr that you have
19:57:02 <elliott> edwardk: yeah
19:57:03 <rwbarton> you want to say the kinds are the same
19:57:07 <elliott> right
19:57:13 <edwardk> a way to talk about the kinds on the right hand side
19:57:23 <edwardk> not just *
20:01:14 <hpaste> byorgey pasted “kind-indexed type family” at http://hpaste.org/63852
20:01:19 <byorgey> that works
20:01:28 <edwardk> perfect
20:01:32 <byorgey> but I realize it's not super useful without being able to write down polymorphic kinds
20:01:36 <edwardk> yeah
20:01:46 <edwardk> the Arr example is stuck being fully applied to all arguments
20:01:51 <rwbarton> what happens if you delete line 7 and then remove the kind signature on line 6
20:01:51 <edwardk> which means you can't make instances for it, etc.
20:02:06 <byorgey> edwardk: right
20:02:23 <rwbarton> or for that matter line 5 also
20:02:44 <rwbarton> can it infer the kinds and only use that definition for matching kinds?
20:02:50 <byorgey> rwbarton: oh, nice, it works!
20:03:41 <hpaste> byorgey annotated “kind-indexed type family” with “kind-indexed type family (now with 100% more inference!)” at http://hpaste.org/63852#a63853
20:03:46 <edwardk> type family Shape t :: *; type instance Shape (t :: *) = t; type instance Shape t = Shape (t ())
20:03:50 <rwbarton> that's... kind of disturbing :)
20:03:51 <Runar> edwardk: Does Sink even need the out type?
20:03:59 <byorgey> edwardk: you don't even need the :: *
20:03:59 <edwardk> oh
20:04:01 <edwardk> neat
20:04:29 <edwardk> Sink has an input and a result type, no out
20:04:35 <edwardk> even neater
20:04:55 <edwardk> so its taking the kind of t from the *
20:05:01 <edwardk> tricky
20:05:15 <byorgey> heh, Shape StateT :: * =  Shape ((* -> *) -> * -> *) (StateT ())
20:06:23 <rwbarton> wait how does that work?
20:06:37 <elliott> <edwardk> type family Shape t :: *; type instance Shape (t :: *) = t; type instance Shape t = Shape (t ())
20:06:41 <elliott> that's what I was suggesting :P
20:06:42 <rwbarton> :k StateT
20:06:43 <lambdabot> * -> (* -> *) -> * -> *
20:06:55 <rwbarton> oh it gets stuck there, right?
20:07:02 <Runar> edwardk: Sink i a = Cofree (Maybe . (i ->)) a
20:07:20 <hpaste> byorgey annotated “kind-indexed type family” with “kind-indexed type family (now with 100% more higher-order kinds!)” at http://hpaste.org/63852#a63854
20:07:23 <edwardk> not (i ->) its a F i
20:07:24 * elliott thinks: type instance Shape f = Shape (f (Shape f))
20:07:25 <byorgey> hah, check it ^^^
20:07:27 <elliott> or something.
20:07:32 <byorgey> rwbarton: yep
20:07:41 <elliott> byorgey: yikes
20:07:44 <elliott> you've created a monster
20:08:14 <Runar> edwardk: What kinds of signals does Sink write to the channel?
20:08:18 <byorgey> it's a very principled monster.
20:08:38 <edwardk> runar: could ask for it to reset, could just be the usual heartbeat signals that say 'ok'
20:08:44 <edwardk> could ask for seeks, etc.
20:08:49 <byorgey> ok, I'm off to bed, night all
20:08:53 <edwardk> its usual response noise
20:09:00 <Runar> I see
20:09:25 <edwardk> the symmetry in the protocol ensures that for everything we read we get back one of those little heartbeats
20:09:40 <hpaste> rwbarton annotated “kind-indexed type family” with “kind-indexed type family (now with 100% more higher-order kinds!) (annotation)” at http://hpaste.org/63852#a63855
20:09:44 <Runar> in practice, that's just going to be Unit
20:09:46 <rwbarton> byorgey, does this work?
20:09:52 <edwardk> possibly
20:10:13 <elliott> edwardk: oh, you even support seeks from a "consumer"? cool
20:10:31 <edwardk> rwbarton: sadly no
20:10:39 <rwbarton> oh?
20:10:42 <edwardk> there is an unfortunate restriction on foralls in the right hand side of type families
20:10:52 <edwardk> something SPJ said about not knowing when to expand them
20:10:59 <rwbarton> okay, what if I newtype it
20:11:03 <elliott> would it work with a data family?
20:11:03 <elliott> yeah
20:11:17 * rwbarton should install ghc 7.4 some day
20:12:09 <edwardk> rwbarton: that works
20:12:24 <elliott> rwbarton: join uuus!
20:12:50 <rwbarton> so that works for any (ordinary) kind, right, because the forall is quantified over whatever it needs to be
20:12:56 <edwardk> yes
20:13:06 <edwardk> and i'd already done the same trick with Arr
20:13:16 <edwardk> just winds up with 2 args when i'd rather it didn't
20:13:36 <rwbarton> but it's an open family, right, so a bad person could add an instance where the kinds are different?
20:13:55 <rwbarton> is there some horrible trick? like lifting a type-level Pair a = Pair a a
20:14:33 <edwardk> type family Arr a b :: *; type instance Arr a b = a -> b; type instance Arr f g = Trans f g; newtype Trans f g = Trans (forall a. f a -> g a)
20:14:43 <Runar> edwardk: Just trying to imagine, say, a sink that counts.
20:14:55 <elliott> do you really need the two params there?
20:15:02 <elliott> oh wait nm
20:15:17 <edwardk> elliott: i can't name the polymorphic kind to use one
20:15:23 <rwbarton> but then I want to say type family Arr :: Pair k -> * but I can't do that
20:15:25 <elliott> what would one even mean?
20:15:30 <rwbarton> so it didn't really help
20:15:32 <edwardk> ideally id just make Arr Z, Arr (S Z) , etc.
20:15:41 <elliott> what would Arr (S Z) be?
20:15:52 <edwardk> Trans for * -> *
20:16:05 <elliott> oh, ok
20:16:22 <elliott> <edwardk> type family Arr a b :: *; type instance Arr a b = a -> b; type instance Arr f g = Trans f g; newtype Trans f g = Trans (forall a. f a -> g a)
20:16:22 <edwardk> i was hoping to be able to model the kind, you'd want to swap out Z and S Z for something more descriptive so you can have different kinded args
20:16:23 <elliott> so does this not work?
20:16:30 <edwardk> elliott: that works
20:16:37 <rwbarton> why not type instance Arr f g = Trans f g; newtype Trans f g = Trans (forall a. Arr (f a) (g a))
20:16:40 <edwardk> i was saying above that it did, but that its ugly to make instances for
20:16:51 <edwardk> rwbarton: nice!
20:16:52 <zzo38> What are you making today?
20:16:56 <rwbarton> you mean like, Category?
20:16:59 <rwbarton> oh i see
20:17:06 <hpaste> NiceOneBrah pasted “Pointfree Question” at http://hpaste.org/63856
20:17:25 <NiceOneBrah> sup guys, I have a quick question about pointfree style (hpaste above)
20:17:38 <edwardk> rwbarton: that works great
20:17:51 <Runar> count = let count' n = Sink n \i -> ((), count' n + 1) in count' 0
20:17:52 <rwbarton> only problem is it is still open to bad instances
20:17:53 <edwardk> banging my head against the wall for not seeing the induction
20:17:55 <NiceOneBrah> that is my solution for #11 in h-99 and when I try to make the last equation for encodeModified pointfree ghc complains
20:18:06 <rwbarton> also I don't see any way to write instance Category Arr...
20:18:06 <NiceOneBrah> anyone know how I might make that pointfree?
20:18:10 <edwardk> runar: bit noiser bcause of the F but yeah
20:18:31 <edwardk> rwbarton: thats why i wanted a separate parameter so i could encapsulate the kind in that
20:18:34 <Runar> count = let count' n = Sink n $ F \i -> ((), count' n + 1) in count' 0
20:18:36 <elliott> btw, is (forall a. f a -> g a) in one of edwardk's libraries somewhere? :P
20:18:38 <ion> “GHC complains” is a rather inaccurate description of the issue.
20:18:49 <NiceOneBrah> apologies, let me copy / paste the error message
20:18:50 <elliott> NiceOneBrah: please show the code you used and ghc's error
20:18:51 <edwardk> elliott: old category extras as :~> or some such
20:18:52 <elliott> on hpaste
20:19:01 <NiceOneBrah> code is on hpaste, I'll hpaste the error
20:19:04 <elliott> edwardk: I think I saw it in category-extras, but I don't want to depend on it :P
20:19:10 <ddarius> Kind-level asTypeOf ho!
20:19:13 <elliott> NiceOneBrah: the point-free code, rather
20:19:14 <edwardk> elliott: not sure where it wound up
20:19:14 <ion> The code that resulted in the error message is on hpaste?
20:19:22 <edwardk> ddarius: =)
20:19:29 <elliott> NiceOneBrah: I suspect I know what the error is, though, but I'd like to see error-producing code + error first
20:19:31 <elliott> to be sure
20:19:39 <ddarius> AsTypeOf Maybe f
20:19:51 <edwardk> Yeah
20:19:57 <elliott> can you define that yet?
20:20:09 <edwardk> elliott: AsKindOf?
20:20:29 <hpaste> NiceOneBrah pasted “Pointfree Question Corresponding Error” at http://hpaste.org/63857
20:20:31 <elliott> yeah
20:20:38 * cmccann was wondering the other day about how to write an AsKindOf to trick it into giving the kind you want
20:20:40 <elliott> NiceOneBrah: right, this is disallowed by design: http://stackoverflow.com/questions/8745597/defining-a-function-by-equations-with-different-number-of-arguments
20:21:05 <edwardk> elliott: sadly no. since you can't make a type family with a polymorphic return type
20:21:06 <Runar> edwardk: So, now what about interleaving monadic actions?
20:21:14 <elliott> edwardk: right
20:21:33 <rwbarton> what if I try something like   data Pair a = Pair a a; type family Snd ('Pair x y) = y; type AsKindOf f g = Snd ('Pair f g)
20:21:45 <elliott> rwbarton: "type family Snd ... = " doesn ot type
20:21:46 <edwardk> runar: mostly i figure its the job of whoever wants to drive the contraption to wire up monadic effects to each unbound source in the graph somehow
20:21:51 <elliott> er
20:21:53 <elliott> parse, rather
20:21:59 <edwardk> rwbarton: ooh
20:22:02 <edwardk> trying it out
20:22:16 <elliott> edwardk: hmm, can your iteratees not support monadic actions in converters (conduits, enumeratees, w/e)?
20:22:33 <edwardk> elliott: they deliberately don't
20:22:40 <elliott> edwardk: that's a bit limiting :(
20:22:46 <elliott> even if it does let you do more stuff
20:22:52 <edwardk> elliott: it involves moving the actions around to a different place
20:22:59 <edwardk> i'm looking for a different discipline
20:23:09 <edwardk> i deliberately don't want that
20:23:15 <elliott> right, but they all have to end up in one place, right? I guess this sounds like arguments that FP doesn't work because all your IO ends up in one place...
20:23:38 <edwardk> i can't say type family Snd ('Pair x y) = y
20:23:39 <elliott> but the streaming data stuff was designed /because/ effects mess with just using lists, IMO (see: lazy IO)
20:23:49 <elliott> but yeah, it's interesting all the same
20:23:55 <elliott> edwardk: you can't define type families like that
20:23:58 <elliott> gotta have a separate family/instance line
20:24:01 <edwardk> elliott: thats my point
20:24:03 <elliott> right
20:24:05 <rwbarton> oh i see
20:24:16 <rwbarton> yeah, forgot the syntax
20:24:21 <Runar> edwardk: Can we not use this instead of lazy IO then?
20:24:27 <rwbarton> and it doesn't like "type family Snd; type instance Snd ('Pair x y) = y" I guess?
20:24:41 <edwardk> rwbarton: exactly
20:24:54 <edwardk> this is the problem i ran into when modeling categories this way
20:24:57 <elliott> "type family Send p" it would be
20:24:59 <elliott> *Snd
20:25:06 <Runar> I want to say "incremental IO"
20:25:14 <edwardk> type family Snd p -- would default the result to kind *
20:25:16 <NiceOneBrah> elliott, thanks! that link was helpful
20:25:16 <zzo38> What does incremental IO mean?
20:25:33 <elliott> NiceOneBrah: of course it was, I answered it :D
20:25:43 <edwardk> runar: we need a whiteboard and less background noise =)
20:25:52 <rwbarton> I guess that makes sense -- it can't infer the kind very well as the type family is open
20:25:58 <elliott> NiceOneBrah: but btw
20:26:01 <elliott> NiceOneBrah: your first clause is redundant
20:26:09 <elliott> foldr f z [] === z
20:26:15 <elliott> so just remove it and chop off xs
20:26:33 <edwardk> rwbarton: well, actually its more insidious
20:26:33 <edwardk> the culprit is that they need to know if the kind is * or Constraint for parsing (,) and ()
20:26:42 <NiceOneBrah> elliott, ah thanks for the heads up (I've been bad about that lately)
20:26:44 <rwbarton> lovely
20:26:47 <edwardk> yeah
20:27:01 <zzo38> rwbarton: I have once thought of a hypothetical extension which allows closed type classes; you could make closed type families too
20:27:04 <edwardk> i blogged a fix that adds a little bit of sub-superkinding
20:27:14 <Runar> zzo38: Doing a little I and then a little O :)
20:27:14 <otters> sub-superkinding
20:27:15 <otters> o_o
20:27:16 <elliott> NiceOneBrah: :)
20:27:16 <edwardk> but its just esoterica on my blog at this point =)
20:28:05 <edwardk> otters: if you make * and Constraint a member of the same superkind (lets call it CIRCLE) and make CIRCLE a sub-superkind of BOX, then you can give the type (,) the kind schema :: forall (k :: CIRCLE). k -> k -> k
20:28:09 <zzo38> Runar: How do you mean, exactly? Example of what you mean?
20:28:10 <rwbarton> wait isn't DataKinds supposed to promote functions also?
20:28:22 <otters> I don't even know what kinds are
20:28:23 <edwardk> and the type (), the kind schema () :: forall (k :: CIRCLE). k
20:28:51 <Runar> zzo38: Like iteratees
20:28:57 <edwardk> then you can partially apply (,)'s in types and get the right kind, and no parsing hack need prematurely monomorphize kinds
20:29:59 <elliott> rwbarton: no
20:30:14 <elliott> edwardk: superkind is an unfun name for sorts :(
20:30:28 <ddarius> "There's no typing problem that can't be solved with another level of sorts."
20:30:54 <rwbarton> wait
20:31:16 <rwbarton> how about  data Pair a = Pair a a; type Const a b = a; type AsKindOf f g = Const g ('Pair f g)
20:31:48 <rwbarton> or I guess I could church-encode the pair :P
20:32:35 <elliott> which would require a polymorphic return type, no?
20:32:38 <elliott> maybe not
20:32:43 <elliott> But that's really clever!
20:32:48 <rwbarton> return type could be specified
20:32:54 <Runar> edwardk: We could put effects in the out types.
20:32:58 <elliott> rwbarton: should I try that?
20:32:59 <rwbarton> since I am building the pair for my own use anyways
20:33:01 <rwbarton> yes please
20:33:20 <elliott> Prelude> data Pair a = Pair a a; type Const a b = a; type AsKindOf f g = Const g ('Pair f g)
20:33:22 <elliott> it goes through
20:33:25 <elliott> what should I test it with?
20:33:37 <Runar> instead of "OK", emit "putstrLn x" or "launchTheMissile"
20:33:43 <rwbarton> how about :t AsKindOf Maybe [], :t AsKindOf Maybe Int
20:33:43 <elliott> I can't just do :k AsKindOf
20:33:45 <elliott> because it's a synonym :(
20:34:01 <edwardk> runar: that was the idea
20:34:08 <elliott> Prelude> :k AsKindOf Maybe []
20:34:08 <elliott> AsKindOf Maybe [] :: * -> *
20:34:09 <elliott> Prelude> :k AsKindOf Maybe Int [...] The second argument of `AsKindOf' should have kind `* -> *',
20:34:09 <elliott>     but `Int' has kind `*'
20:34:10 <rwbarton> I wonder whether it will expand the synonyms before kind-checking Pair
20:34:15 <rwbarton> whoa
20:34:19 <Runar> edwardk: That seems very clean
20:34:26 <elliott> rwbarton: what if I try it in the other order...
20:34:40 <elliott> nope, same error
20:34:58 <edwardk> elliott: you solve it while i was gone?
20:35:48 <rwbarton> right not :t, whatever you do to expand a type
20:35:52 <rwbarton> or :k works too
20:36:50 <elliott> edwardk: <rwbarton> how about  data Pair a = Pair a a; type Const a b = a; type AsKindOf f g = Const g ('Pair f g)
20:36:57 <elliott> but it weirdly doesn't work
20:37:02 <edwardk> looks right
20:37:06 <elliott> or hmm
20:37:06 <rwbarton> ? I thought it did work
20:37:07 <edwardk> makes sense even
20:37:09 <elliott> yes, it  does
20:37:11 <elliott> the error is just misleading
20:37:14 <edwardk> and it works
20:37:15 <edwardk> sweet
20:37:19 <edwardk> AsKindOf lives!
20:37:32 * elliott needs his slice of this fame
20:37:35 <elliott> you couldn't have done it without me!
20:37:45 <edwardk> and we can abuse that same trick to force kind equality elsewhere
20:37:47 <elliott> maybe I should put it on hackage, haha
20:39:18 <zzo38> Why doesn't documentation for "extensible-data" works on Hackage?
20:39:40 <rwbarton> :k AsKindOf doesn't work?
20:39:41 <lambdabot> parse error (possibly incorrect indentation)
20:40:00 <edwardk> rwbarton: you can't :k a non-fully applied type alias
20:40:12 <rwbarton> works in ghc 7.0
20:40:25 <rwbarton> type List a = [a], :k List
20:40:47 <edwardk> try a type alias that doesn't trivially apply its excess arguments
20:40:59 <ByronJohnson> zzo38: The server seems to have not yet prrocessed it yet
20:41:02 <edwardk> if you can't eta-reduce it what do you get?
20:41:04 <rwbarton> type List a x = x a, :k List still works
20:41:09 <rwbarton> List :: * -> (* -> *) -> *
20:41:17 <edwardk> rwbarton: must have been something they had to ditch
20:41:18 <elliott> I think it's an internal GHC problem
20:41:22 <elliott> there's no kind they could print or whatever
20:41:23 <elliott> or something
20:41:27 <zzo38> ByronJohnson: How long does it take?
20:41:28 <elliott> but yeah PolyKinds is a major reworking I think
20:41:29 <rwbarton> yeah that makes sense
20:41:52 <ByronJohnson> zzo38: t'll probably be available (or not, with a log for build failures) in a few days, IIRC
20:41:59 <edwardk> makes me feel better about the fact that we do let you calculate kinds from type aliases in our little compiler though =)
20:42:04 <ByronJohnson> zzo38: Regardless, I suggest generating the documentation locally :)
20:42:37 <ByronJohnson> zzo38: You can run cabal haddock, but a better option is to enable the documentation setting in your ~/.cabal/config file
20:42:40 <rwbarton> Who's got a fancy GHC version now :P
20:43:11 <zzo38> It is my own package, in case you didn't know
20:43:59 <elliott> mwahahaha, now I have an as-kind-of.cabal that nobody will depend on because three lines is shorter than an import and a dependency line
20:44:49 <zzo38> Can you answer my original question, about your opinion of my text adventure game system in Haskell?
20:45:36 <edwardk> zzo38: seems like you'll wind up building an eval for that data type, which when you get done, you might as well just replace each of those constructors with combinators and make it a class rather than an ADT
20:45:44 <rwbarton> so now we can wrap the open type family Arr in type Arr' f g = Arr f (AsKindOf f g)
20:45:54 <edwardk> yeah
20:45:59 <edwardk> that lets us elide one arg
20:46:20 <edwardk> oh or that
20:46:29 <rwbarton> it repairs the kind
20:47:02 <elliott> edwardk: you sure do love type-classes
20:47:06 <rwbarton> are there types like '(Int -> Bool) ?
20:47:22 <rwbarton> *kinds
20:47:43 <edwardk> Bool, yes, Int not yet
20:47:49 <rwbarton> oh
20:48:02 <edwardk> elliott: well it is sort of the 'finally tagless' version of his little game DSL
20:48:04 <rwbarton> well, '(Bool -> Bool)
20:48:23 <edwardk> Bool -> *
20:48:37 <rwbarton> I mean basically is there something like '(->)
20:48:40 <rwbarton> or is that nonsense
20:50:00 <ByronJohnson> @kind Maybe
20:50:01 <lambdabot> * -> *
20:50:20 <elliott> rwbarton: '(->) = (->) :P
20:51:36 <mikeplus64> @src (->)
20:51:36 <lambdabot> Source not found. Maybe you made a typo?
20:51:41 <latros> what is '
20:51:46 <latros> in this context
20:52:13 <ByronJohnson> latros: http://research.microsoft.com/en-us/people/dimitris/fc-kind-poly.pdf
20:53:54 <edwardk> rwbarton: you have the -> from higher kinds and can of course make type families that take a  Bool to Bool
20:55:03 <rwbarton> yeah, I guess that is what it would be
20:56:52 <QinGW> @src ($$)
20:56:52 <lambdabot> Source not found. Have you considered trying to match wits with a rutabaga?
20:57:07 <QinGW> @hoogle ($$)
20:57:07 <lambdabot> Text.PrettyPrint.HughesPJ ($$) :: Doc -> Doc -> Doc
20:57:07 <lambdabot> Text.PrettyPrint ($$) :: Doc -> Doc -> Doc
20:57:07 <lambdabot> Language.Haskell.TH.PprLib ($$) :: Doc -> Doc -> Doc
20:57:20 <zzo38> edwardk: What do you mean, an eval for a data type? I do not completely understand you
20:57:41 <edwardk> zzo38: have you read the finally tagless paper?
20:57:48 <rwbarton> given the way http://hpaste.org/63852 works I almost expect it to just work if you write two "instance Category Arr where ..." in terms of (->) and Trans
20:58:10 <zzo38> edwardk: No I have not done so.
20:58:21 <edwardk> you can make a Category for (->) and one for Trans and then you can just write code with Arr
20:58:30 <edwardk> just so long as you don't under apply either
20:59:17 <edwardk> zzo38: that basically contains the definition of what i just described
20:59:29 <rwbarton> oh and that will work for every (ordinary) kind
20:59:32 <rwbarton> hmm
20:59:32 <edwardk> http://www.cs.rutgers.edu/~ccshan/tagless/jfp.pdf
20:59:53 <edwardk> yep
20:59:54 <elliott> zzo38: basically he's proposing you change data T = A ... | B ... with class T r where { a :: ... -> r; b :: ... -> r } or such
21:00:35 <zzo38> elliott: O, OK. But I do not understand how that would help in this case
21:01:06 <elliott> i'll let edwardk extol that ;)
21:01:09 <edwardk> zzo38: you can always make some eval (A …) = … function, but then you have interpretive overhead
21:02:56 <edwardk> in general one tends to start with complex ADTs, with an interpreter for the ADT that runs them, but you can flip that whole perspective and define the class instead which of course admits a trivial instance in terms of the original AST
21:03:15 <edwardk> instance Foo T where a = A; b = B; etc.
21:04:10 <edwardk> but also admits instances of Foo for IO () or if your dsl has more refined types, something that can actually type check your code
21:05:09 <edwardk> in the paper they build a little interpreter, then a compiler, cps transformation, etc. all as instances
21:05:41 <edwardk> i tend to prefer building code through those symantics classes than big DSLs full of special cases
21:05:53 <edwardk> because its easier to add cases to classes by making subclasses
21:05:57 <edwardk> than to extend an ADT
21:06:13 <zzo38> OK, I do understand now. Do you mean my GameFunction and SystemRequest types?
21:06:26 <edwardk> yeah, at least the big GameFunction one
21:06:38 <edwardk> or was it SystemRequest
21:06:45 <edwardk> whatever one had all the cases
21:07:36 <zzo38> GameFunction is a type synonym. SystemRequest is ADT. But I do need to store this in a list and in a file as well.....
21:07:39 <edwardk> the nice thing is you can make a trivial instance to test with which is completely unrelated to the final implementation, etc.
21:07:47 <edwardk> yes
21:07:49 <edwardk> to do that
21:07:54 <edwardk> you make an instance for an ADT
21:07:58 <edwardk> and serialize that
21:08:04 <edwardk> or even an instance for a serializer
21:08:22 <edwardk> avoiding the intermediate adt entirely
21:10:18 <zzo38> I also have    type Transcript = [(SystemRequest, TranscriptItem)];   and sometimes it will be retrieved from such a list for undo, to figure out which input was wanted and that kind of stuff. Still, what you said might be possible
21:10:42 <MiggyX> hmm, how would one go about converting a ByteString in network byte order into an Integer? I've tried looking for ByteString -> Integer, but no go so far...
21:10:56 <shachaf> MiggyX: Data.Binary.Get
21:11:05 <edwardk> its always possible, since you can make the instance for some ADT, if you have enough of those it may make sense not to do what i described though
21:11:25 * hackagebot xturtle 0.0.13 - turtle like LOGO  http://hackage.haskell.org/package/xturtle-0.0.13 (YoshikuniJujo)
21:11:29 <edwardk> otoh, the undo actions themselves that you perform based on what you put IN those lists, etc. can be valid instances
21:11:34 <zzo38> For example if you have a GameFunction and a Transcript and the initial Game, then you can reconstruct the game state
21:11:39 <edwardk> its just a shift in perspective
21:11:46 <edwardk> sure
21:11:56 <zzo38> Where the Transcript is what is stored in the save file
21:12:25 <edwardk> but one way to do that is to make the class for SystemRequest and make an instance of SystemRequest for Transcript
21:12:41 <zzo38> Note that the SystemRequest part is only a subset of the possible constructors of SystemRequest; RewindTo and GameOver are never going to occur in a Transcript.
21:12:51 <edwardk> just offering it up as a rather sideways way to think about the problem
21:13:19 <edwardk> sure, then with the class approach you can actually model that
21:13:46 <elliott> right, with subclasses
21:13:48 <edwardk> by splittingthe system request class up into two classes, a superclass which is what goes in anything, and the subclass that is capable of rewinding and ending
21:14:18 <edwardk> one could split the ADT, but thats more painful
21:15:04 <zzo38> edwardk: OK, that might work
21:15:05 <MiggyX> shachaf, thanks :)
21:18:49 <zzo38> If doing it with the ADT, there is no need to split it, really; because the load/save does not require to use all the constructors.
21:19:03 <edwardk> *nods*
21:19:27 <edwardk> i'm not saying it is definitely better to do it the other way, you just asked for what folks would recommend
21:19:57 <zzo38> Yes, I can understand you now.
21:20:07 <edwardk> i admit i tend to overdo the tagless thing
21:21:33 <zzo38> I can understand how that tagless way can be useful in some thing but what I am doing now, probably works without. There are some things I want extensible data types and extensible records, but I have made up a package "extensible-data" which implements extensible stuff.
21:21:55 <zzo38> You can tell me your opinion of extensible-data package too if you have anything to say
21:22:19 <edwardk> i'll take a look, but it'll probably be tomorrow. wrapping up some code and getting to bed ;)
21:23:01 <zzo38> OK. Currently Hackage has no documentation for extensible-data package; best is reading the printouts (ask if you require the birdstyle.tex macro file)
21:24:29 <elliott> <zzo38> If doing it with the ADT, there is no need to split it, really; because the load/save does not require to use all the constructors.
21:24:33 <elliott> but they could fail at runtime, no?
21:26:00 <zzo38> elliott: Of course they could, but they won't because of the way I am doing it, the Transcript value that it saves will never happen to contain such things. Actually, there is probably no need to save SystemRequest values to a file, now that I think of it; they can be regenerated while the file is loading.
21:26:44 <zzo38> Actually, Transcript does not even have to mention SystemRequest at all.
21:31:05 <zzo38> Is the stuff in my extensible-data even the kind of stuff that the Typeable class was designed for?
21:31:23 <zzo38> Probably not quite
21:48:51 <Mango_Man> what up haskell...ers
21:49:14 <Mango_Man> what's a good noun for people who use haskell?
21:49:44 <Mango_Man> python has pythonista
21:49:59 <tikhonjelvis> which makes you sound like somebody working at Starbucks
21:50:05 <nyingen> we generally say "haskellers"
21:50:26 <nyingen> but I prefer "real programmers"
21:50:46 <Mango_Man> i like "real programmers"
21:50:58 <ion> “The condescending people”
21:51:00 <copumpkin> True Scotsmen
21:51:18 <nyingen> "the literati"
21:56:18 <latros> menads?
21:56:25 * hackagebot xournal-convert 0.1.1 - convert utility for xoj files  http://hackage.haskell.org/package/xournal-convert-0.1.1 (IanWooKim)
22:01:26 * hackagebot xournal-parser 0.4.1 - Xournal file parser  http://hackage.haskell.org/package/xournal-parser-0.4.1 (IanWooKim)
22:08:51 <liyang> @hoogle (a -> f a) -> a -> f b
22:08:51 <lambdabot> Data.Data gunfold :: Data a => (forall b r. Data b => c (b -> r) -> c r) -> (forall r. r -> c r) -> Constr -> c a
22:08:52 <lambdabot> Control.Monad (<=<) :: Monad m => (b -> m c) -> (a -> m b) -> (a -> m c)
22:08:52 <lambdabot> Control.Monad (>=>) :: Monad m => (a -> m b) -> (b -> m c) -> (a -> m c)
22:09:37 <ion> Gunfold sounds violent.
22:10:31 <liyang> Does something analogous to forever with the type (a -> f a) -> a -> f b exist? Something like iterateM, but I can't find anything. :(
22:11:24 <elliott> liyang: mfix?
22:11:27 <elliott> @hoogle mfix
22:11:28 <lambdabot> Control.Monad.Fix mfix :: MonadFix m => (a -> m a) -> m a
22:11:35 <elliott> oh, not quite
22:11:49 <elliott> iterateM f x = f x >>= iterateM f, so...
22:11:56 <elliott> iterateM f = f >=> iterateM f
22:12:01 <elliott> iterateM f = fix (f >=>)
22:12:04 <elliott> iterateM = fix . (>=>)
22:12:13 <elliott> liyang: Is fix . (>=>) good enough for you?
22:12:15 <elliott> :t fix . (>=>)
22:12:16 <lambdabot> forall a (m :: * -> *) c. (Monad m) => (a -> m a) -> a -> m c
22:13:06 <liyang> Excellent!
22:13:25 <mandaya> hmm, never seen fix before
22:13:29 <mandaya> what does it do?
22:13:34 <mandaya> @hoogle fix
22:13:34 <lambdabot> Control.Monad.Fix module Control.Monad.Fix
22:13:34 <lambdabot> Data.Fixed module Data.Fixed
22:13:35 <lambdabot> Data.Function fix :: (a -> a) -> a
22:13:35 <latros> fix f = f (fix f)
22:13:38 <liyang> it fixes things.
22:13:40 <mandaya> oh
22:13:47 <mandaya> y combinator?
22:13:52 <latros> fixed point combinator
22:13:56 <mandaya> yea
22:13:56 <elliott> no, Y is a specific implementation of fix
22:14:00 <latros> pretty sure that's slightly different from a Y combinator
22:14:02 <elliott> notable for the fact that it doesn't have any explicit recursion
22:14:11 <elliott> but fix in Haskell is implemented with explicit recursion
22:14:17 <mandaya> elliott: ahh, ok fair
22:14:19 <elliott> (which also means it shares efficiently)
22:14:25 <tikhonjelvis> Isn't fix f just f (fix f) or something like that?
22:14:29 <elliott> yes, exactly
22:14:30 <latros> yes
22:14:34 <elliott> well
22:14:36 <elliott> it's actually
22:14:39 <elliott> fix f = x where x = f x
22:14:47 <tikhonjelvis> Ooh, tricky. Why?
22:15:07 <latros> that's the more conceptual definition, actually
22:15:12 <latros> in that it finds fixed points of f
22:15:18 <mandaya> elliot: "shares efficiently"... what exactly do you mean?
22:15:28 <tikhonjelvis> Oh, I guess that makes sense.
22:15:56 <latros> the second = is basically an ==
22:16:04 <latros> that syntactically makes no sense, but yeah
22:17:36 <elliott> but the difference is only efficiency
22:20:05 <mandaya> elliott: see previous question about efficiency, I think I typoed your name
22:20:45 <elliott> mandaya: ah, basically, imagine fix (1:)
22:20:49 <elliott> if you have fix f = f (fix f)
22:20:54 <elliott> then each time you look further down the list, it allocates more
22:21:00 <elliott> because it's constantly consing up more and more lists
22:21:01 <elliott> but with
22:21:05 <elliott> fix f = x where x = f x
22:21:10 <elliott> fix (1:) creates a cyclic structure
22:21:24 <elliott> like this
22:21:25 <elliott>   (:)\
22:21:25 <elliott>  /  \/
22:21:25 <elliott> 1
22:21:32 <elliott> if you imagine that right-hand side "pointing back at itself"
22:21:46 <elliott> that's sharing
22:21:51 <elliott> basically it's the same reason that
22:21:51 <liyang> It looks like a person scratching her head.
22:21:54 <elliott> (hugestructure, hugestructure)
22:21:58 <elliott> doesn't copy hugestructure, just uses pointers
22:22:02 <mandaya> haha, one sec, I'm going to rewrite your expressions in not irc chat so that I don't get smileys instead of lists
22:22:06 <elliott> naming is used to introduce sharing
22:22:14 <elliott> mandaya: http://tunes.org/~nef/logs/haskell/12.02.16
22:22:19 <elliott> just go to the end of that file to see them
22:22:29 <mandaya> ahh, thanks
22:23:10 <mandaya> ok, that makes sense
22:23:13 <mandaya> thanks!
22:23:25 <elliott> wow, it does?! :P
22:23:52 <mandaya> yep, just as soon as :) doesn't get automatically transformed into the emoticon
22:25:34 <latros> elliott,
22:25:40 <latros> wouldn't the compiler optimize fix f = f (fix f)
22:25:43 <latros> to that
22:25:44 <latros> anyway
22:25:45 <latros> ?
22:26:02 <elliott> no
22:26:10 <elliott> optimisations like that can often introduce really bad space leaks
22:26:22 <elliott> consider this
22:26:31 <elliott> (sum [1..9999], length [1..9999])
22:26:36 <elliott> this program runs in constant space
22:26:37 <elliott> but
22:26:44 <elliott> let xs = [1..9999] in (sum xs, length xs)
22:26:51 <elliott> well, this one runs in constant space too :)
22:26:54 <elliott> but it keeps the list in memory for the whole thing
22:27:00 <Axman6> bigger constant
22:27:02 <elliott> right
22:27:10 <elliott> and if you change 9999 to n it matters
22:27:15 <elliott> latros: whereas with sum/length it's consumed as it's evaluated, and garbage collected,
22:27:19 * Axman6 shoul;d have a shirt: Constants Matter!
22:27:26 <latros> right, but why can't the compiler see through that
22:27:29 <elliott> with the "let xs" version, the whole list can't be garbage collected (because it's still referenced) until the whole thing is done
22:27:31 <elliott> see through what?
22:27:34 <latros> i understand GHC is pretty freaking ridiculous at optimizing
22:27:37 <latros> *I
22:27:40 <elliott> you _don't_ want the former to translate to the latter
22:27:43 <latros> that the xs doesn't get used again and just GC
22:27:45 <latros> what?
22:27:51 <latros> no, I meant the other way
22:27:52 <elliott> you really don't
22:27:56 <latros> I meant going from the let to the other one
22:28:00 <latros> since xs doesn't get used again
22:28:01 <elliott> well, that's the opposite of the transformation you're advocating then
22:28:02 <elliott> for fix
22:28:06 <latros> wait what
22:28:10 <elliott> and has its own, opposite set of problems
22:28:21 <elliott> anyway GHC does conservative CSE (common subexpression elimination which is what the fix optimisation and the one I showed is called)
22:28:29 <elliott> conservative being the keyword
22:28:29 <mandaya> latros: if you want fix f = f (fix f) to get optimized
22:28:40 <elliott> understandign sharing is _very_ important for reasoning about performance of haskell in practice, anyway
22:28:53 <mandaya> to the where expression, you also have to worry about the same thing happening in the case elliott just showed
22:29:57 <latros> I guess I don't know enough about the compiler details to really follow the issue
22:30:13 <latros> I know most of what I've read is basically "GHC is ridiculous at optimizing things"
22:30:27 <latros> without much detail as to what optimizations it does and doesn't use
22:30:33 <mandaya> latros: look at it this way. what makes those two cases different? how would you know to do it one way once, and the other way the other time?
22:30:47 <latros> they're always equivalent, though
22:30:50 <elliott> latros: GHC is good at optimisation -- but it's not psychic.
22:31:01 <elliott> they're equivalent in denotation but not in space complexity
22:31:04 <elliott> perhaps even time too
22:31:20 <latros> but one would think it could see the equivalence in denotation, since it's such a simple one
22:31:44 <mandaya> latros: it can, but you wouldn't want to transform from a more efficient expression to a less efficient expression
22:31:52 <latros> but it wouldn't
22:32:00 <latros> unless you're saying sometimes going the other way leads to efficiency issues
22:32:05 <mandaya> exactly
22:32:09 <latros> hm
22:32:18 <mandaya> either transformation has efficiency issues in some cases
22:32:37 <latros> is there a way to determine which is which?
22:32:39 <mandaya> aggressively applying the transformation in either direction is problematic
22:32:59 <latros> presumably it depends on the structure of f
22:39:23 <elliott> latros: It can see the equivalence of denotations.
22:39:28 <elliott> It is deliberately conservative about acting on them.
22:59:11 <Algo> This is a naive question but why do people use languages like C? I'm a math guy that uses mostly Haskell but I think some CS person told me that it's to do with different tasks - like when you want to really interact with the machine
23:00:07 <companion_cube> when you want a lot of control over resources
23:00:09 <MostAwesomeDude> C is an extremely high-level and concise way to model a modern CPU.
23:00:52 <quicksilver> that's a funny way of putting it MostAwesomeDude
23:00:57 <tikhonjelvis> C really is much closer to what the machine actually does.
23:00:58 <quicksilver> it's a truly *terrible* model of a modern CPU
23:01:24 <quicksilver> C is a high level and concise way to model 1970s CPUs
23:01:40 <quicksilver> whcih are about as different from 2010s CPUs as ferraris are from donkeys
23:02:12 <MostAwesomeDude> quicksilver: And yet.
23:02:26 <tkahn6_> quicksilver: are you saying there should be language-level support for pipelines or something?
23:02:27 <quicksilver> I think people use C because kernels were written in C - and linux still is - and syscall APIs and libc are written for C.
23:02:35 <rfw_> that and the compiler munges up your code anyway
23:03:03 <quicksilver> tkahn6_: I'm not suggesting that would be generally a good programming language, no. I'm just saying that C is a long way from a modern CPU.
23:03:13 <tkahn6_> ah i see
23:03:19 <MostAwesomeDude> quicksilver: C's types are *the* linguafranca for FFI, too.
23:03:32 <ion> x86 asm is a long way from a modern x86. :-P
23:03:35 <quicksilver> C can't even model the 'carry bit' - a CPU feature which has been present in almsot all CPUs since the 80s.
23:03:55 <ion> They have some internal instruction set and x86 “machine” code is translated to that AFAIU.
23:04:01 <Algo> rfw_: What does "munges" mean?
23:04:04 <quicksilver> the essentially feature which makes it possible to implement N*2-bit addition reasonably efficiently on an N-bit cpu.
23:04:21 <rfw_> Algo: A comprehensive rewrite of a routine, data structure or the whole program.
23:04:24 <tkahn6_> inline asm?
23:04:36 <quicksilver> Algo: so, my answer to your question would be (1) historical accident (2) well understand performance characteristics (3) ubiquity of C-language libraryes and APIs
23:04:45 <quicksilver> not in any particular order.
23:04:59 <quicksilver> or particularly well spelt :)
23:06:22 <companion_cube> also, simplicity (compared to c++), which may cause some people to prefer it
23:07:17 <elliott> ion: Not quite.
23:07:30 <elliott> It's more like they implement some of the instructions in an even lower-level internal language.
23:07:36 <elliott> (microcode)
23:07:59 <Algo> quicksilver: Any reason a math student (undergraduate studying number theory) would ever want to dive into C?
23:08:23 <latros> employment?
23:08:42 <quicksilver> Algo: well you might be interested in it; you might want to write a device driver; probably not :)
23:08:45 <MostAwesomeDude> Analysis of algorithms?
23:08:55 <tikhonjelvis> It is kind of fun.
23:09:18 <MostAwesomeDude> quicksilver: Don't knock device drivers; they're more enjoyable than you know.
23:09:31 <elliott> Algo: It might help you understand the operational semantics of GHC if you can think about them in a lower-level language.
23:09:40 <tikhonjelvis> That's what my dad thinks I should write out of college...
23:09:49 <elliott> (Although an understanding of the semantics of lazy evaluation and sharing suffices just fine most of the time.)
23:09:49 <quicksilver> MostAwesomeDude: sure. But not obviously related to be an number theorist.
23:10:11 <quicksilver> being an.
23:10:18 <quicksilver> much too early, need more coffee.
23:12:46 <elliott> quicksilver: an number, too :P
23:17:26 <Mango_Man> hey guys, i need some help. here's my function expression: lastButOne xs = if length xs == 2 then head xs else tail xs
23:17:34 <Mango_Man> i'm getting a ghci error
23:17:45 <Mango_Man> i think it's because ghci doesn't know of xs is a list?
23:17:49 <Mango_Man> *if
23:17:54 <tikhonjelvis> no
23:17:57 <latros> no, it can infer that much
23:18:11 <tikhonjelvis> It's because head gives you a single item while tail gives you a list.
23:18:15 <latros> yeah
23:18:20 <Mango_Man> oh whoops
23:18:27 <latros> you want to recurse
23:18:31 <latros> on the tail case
23:18:49 <latros> (well, actually, you really want to pattern match probably, but you don't have to)
23:19:12 <latros> (in either case you have a recursive case, but you don't actually call lastButOne again in the recursive case)
23:19:30 <latros> (which...you need to do, of course, or no recursion happens :))
23:20:18 <ChristianS> ... else lastButOne $ tail xs
23:20:33 <ChristianS> Mango_Man: but you still have to take care of the case that your list has less than 2 elements
23:20:43 <latros> eh, it'll run even without that
23:20:50 <latros> you can have incomplete patterns
23:20:59 <latros> it'll just throw an exception if you pass in [] or a singleton
23:21:19 <Mango_Man> so what's wrong with head giving a single item and tail giving a list?
23:21:19 <ChristianS> latros: true enough
23:21:36 <latros> the output of a function has to always have the same type
23:21:43 <tikhonjelvis> You function has to return the same type consistently. A list of something is different from just something.
23:21:54 <Mango_Man> oh right, forgot about that
23:22:07 <latros> (ish, the return type could be polymorphic, but still)
23:22:33 <Mango_Man> wait a second, then how does the head function return a list of a when its input is a?
23:22:36 <Mango_Man> those aren't the same types
23:22:41 <latros> it doesn't
23:22:56 <latros> head returns the first item, not in a list
23:23:13 <latros> but the return type doesn't have to be the same as the input type
23:23:21 <latros> just that the return type and input type have to be consistent
23:23:26 <latros> separately
23:23:36 <notsmack> @type head
23:23:37 <lambdabot> forall a. [a] -> a
23:23:45 <notsmack> @type tail
23:23:46 <lambdabot> forall a. [a] -> [a]
23:23:54 <quicksilver> latros: (are you stuck in those parentheses?)
23:24:05 <quicksilver> latros: (happens to ex-lisp programmers sometimes)
23:24:06 <latros> didn't I close them
23:24:30 <latros> they should all match, if you parse the smiley carefully
23:24:35 <quicksilver> yes, they did
23:24:44 <quicksilver> it's just 60% of your comments were parenthetical :)
23:24:52 <latros> I do that sometimes
23:25:03 <tikhonjelvis> Now that smiley doesn't match. You've thrown everything off!
23:25:13 <latros> wut
23:25:22 <tikhonjelvis> His smiley is unbalanced.
23:25:23 <latros> no, you have to parse smileys before parens
23:26:19 <ChristianS> we need more left-handed smileys (:
23:26:41 <tikhonjelvis> Or ̈⌣? (Did that even work?)
23:27:22 <tikhonjelvis> Aha, figured it out: ⌣̈.
23:27:25 <akosch_> hi, i've tried using ftphs and ftp-conduit for uploading files to my server (filezilla). But both of them fail in strange ways. I've been told ftphs is buggy and to try ftp-conduit, but it dies with "Prelude.read: no parse". Any ideas what else I could try?
23:28:59 <elliott> akosch_: oh, I don't know that ftphs is buggy
23:29:01 <elliott> I just heard it :P
23:29:06 <ChristianS> akosch: no idea, but maybe you gave ftp-conduit the wrong input? i mean, what triggered the "no parse" error?
23:29:17 <elliott> read error makes me suspicious it's a bug in your program
23:33:03 <akosch_> elliott: I'm fairly sure about the bug in ftphs (it only allows me to upload files into a newly created directory).
23:33:16 <Sgeo> akosch, ftphs uses lazy I/O in such a way that you need to take a lot of care if you use it.
23:33:26 <Sgeo> Oh, wasn't aware of that.
23:33:33 <Sgeo> Just of the .. obnoxious laziness.
23:34:03 <akosch_> Sgeo: yeah, I noticed it sometimes tries to read the response of a different command and fails
23:34:20 <akosch_> Sgeo: I imagine it has to do with laziness
23:34:38 <Sgeo> akosch, specifically, overuse of lazy I/O
23:34:50 <Sgeo> akosch, you could force the result of the first command to be evaluated
23:35:34 <akosch_> Sgeo: I've tried playing with that, but it still fails unpredictably
23:35:43 <Sgeo> How are you forcing?
23:36:22 <akosch_> Sgeo: i've tried it with printig the results of the commands
23:36:34 <Sgeo> Hmm.
23:36:48 <Sgeo> You're doing that before issuing the next command?
23:36:58 <akosch_> Sgeo: yes
23:37:06 <Sgeo> Hmm, don't know then.
23:37:32 <Sgeo> All I know is my prior one bad experience with ftphs where a few prints solved my problems.
23:40:21 <akosch_> Sgeo: I think the problem has to do with responses like "200 Type set to A". These aren't really used by ftphs and it probably doesn't flush out of the connection because of laziness. Then when it expects a response for another command, these come up and break things.
23:41:28 <akosch_> s/out of//
23:42:25 <akosch_> Sgeo: do you think it could be possible?
23:42:49 <Sgeo> Not sure
23:42:55 <Sgeo> It was a while since I used ftphs
23:43:35 <Sgeo> Just to clarify something though: This is ftphs's fault for using lazy I/O, if it didn't make the choice to do so, Haskell's laziness would not cause these sorts of issues.
23:44:11 <akosch_> Sgeo: yeah, I'm ok with laziness. But it's not good for doing IO
23:44:20 <latros> the IO monad makes it pretty straightforward to do strict IO yes?
23:44:51 <latros> that is, forcing x to happen to allow y to happen to allow z to happen....and then z is forced to happen because you need the value in there
23:44:53 <Sgeo> latros, strict IO is the default, except for functions where it isn't.
23:44:56 <latros> ah
23:44:58 <latros> nvm
23:45:07 <latros> haven't had to do any nontrivial IO for some time
23:45:53 <Sgeo> Well, I guess it's more that IO being a monad makes strict IO easy to ... do? That's part of why it's monadic, I think.
23:45:55 <sanjoyd> @src fromDyn
23:45:55 <lambdabot> fromDyn (Dynamic t v) def
23:45:56 <lambdabot>   | typeOf def == t = unsafeCoerce v
23:45:56 <lambdabot>   | otherwise       = def
23:46:30 <akosch_> elliott: regarding ftp-conduit: it connects to my server alright, so I guess my URI is ok. I try to use it like this: runResourceT $ Data.Conduit.Binary.sourceFile sourcePath $$ Network.FTP.Conduit.createSink pkgUri
23:47:03 <elliott> akosch_: are you sure the error is there?
23:47:40 <akosch_> elliott: if I remove this line, then there is no error
23:47:46 <sanjoyd> @src typeOf
23:47:46 <lambdabot> Source not found. There are some things that I just don't know.
23:48:42 <akosch_> elliott: I've checked the source of ftp-conduit, and there is only one Prelude.read in the function "extractCode :: BS.ByteString -> Int"
23:49:34 <elliott> akosch_: well. maybe your ftp server is borked
23:49:39 <elliott> does it work with ftp(1)?
23:49:56 <akosch_> elliott: it isn't, I've tried with several other clients and it works fine
23:50:16 <akosch_> elliott: it's not like i'm trying to do anything complex anyway
23:53:48 <akosch_> I think I'll just give up and call http://wput.sourceforge.net/ with System.Process
23:54:00 <elliott> surely ftp(1) would be better?
23:54:39 <akosch_> elliott: i'm on windows at work :(
23:55:08 <elliott> windows has ftp(1) too
23:55:43 <akosch_> elliott: hm, I didn't know that. thanks
23:56:27 <elliott> hmm, perhaps it isn't default in recent versions though
23:56:31 <elliott> try and see, I guess
