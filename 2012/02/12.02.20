00:00:05 <mzero> {-# LANGUAGE UniversalBAHaskell #-}
00:00:15 <mzero> I always get confused between the two
00:00:48 <Paprikachu> leksah 10.0.4 works for me
00:00:57 <Enigmagic> yes
00:01:11 <mzero> cool, Paprikachu probably build issues on their end (which Mac, etc...)
00:01:26 <shachaf> mzero: GHC has better support for the latter.
00:01:30 <Paprikachu> where can i see the output of my program?
00:01:58 <shachaf> Seeing the output of your program is Against The Haskell Way.
00:02:05 <shachaf> (I have no idea. Maybe ask in #leksah?)
00:02:25 <shachaf> (I've never heard of anyone who actually uses it.)
00:02:25 * hackagebot xturtle 0.0.14 - turtle like LOGO  http://hackage.haskell.org/package/xturtle-0.0.14 (YoshikuniJujo)
00:03:12 <mzero> Paprikachu: I don't know - I never run it in Leksah - I just use it as a nice editor and compilation environment
00:03:17 <mzero> I always run from the command line!
00:03:24 <Paprikachu> :S
00:04:31 <Paprikachu> when i created a new file it wanted to create a new package.. i just tried to click everything until it worked. what is that?
00:06:23 <shachaf> edwardk: Is comonad.com down?
00:06:31 <Paprikachu> and how can i run my program from command line?
00:08:00 <mzero> Paprikachu: it builds a cabal package file for your project -- which is good
00:08:19 <mzero> once you built it --- from that directory you'll see a   dist dir -- that is the build dir
00:08:23 <mzero> (distribution)
00:08:38 <mzero> your executable is    dist/bin/foo/foo   (foo is the name of your thing)
00:08:50 <mzero> having a cabal set up is good
00:09:00 <mzero> you can build on the command line too, now,     cabal build
00:09:06 <Paprikachu> there is no dist dir :/
00:09:14 <mzero> is there a foo.cabal file?
00:09:31 <Paprikachu> yes
00:09:40 <mzero> did you build in Leksah?
00:09:58 <mzero> (look at the Log pane)
00:11:21 <Paprikachu> there is no log pane :|
00:11:36 <mzero> Panes menu
00:12:01 <Paprikachu> when i click "Panes" -> "Log" nothing happens
00:12:36 <mzero> perhaps it is open - it has no tab -- it is usually in the lower right
00:12:43 <mzero> it is where the compiler messages appear
00:13:07 <mzero> in any event - is your program a one file program?
00:13:24 <mzero> you can also just run it from the command line with "runhaskell foo.hs"
00:13:34 <Paprikachu> hm okay, i think i found it.
00:13:44 <mzero> good now build in Leksah
00:13:55 <mzero> package menu
00:14:28 <mzero> if your program  doesn't take interactive input, then I think if you run (also package menu) then you'll see the output in the log pane
00:14:44 <mzero> but if it is interactive, you'll need to run it on the command line
00:16:03 <Paprikachu> it's not interactive.. but doesnt print anything and i don't get any build messages
00:16:09 <SubtleArray> Hey peeps. I just had a simple, general question. Could you see Haskell being used for developing machine learning algorithms? Or would it be better to use a more "specialized" language?
00:16:31 <Paprikachu> every time i press build or run it says "============= 127 ====================="
00:16:37 <Paprikachu> or something like that
00:16:54 <mzero> Paprikachu: hmmm... is everything saved?  then normally you hit the build tool bar button and it just goes
00:17:15 <mzero> oh - that doesn't look good --- that looks like you don't have cabal or ghc installed
00:17:35 <mzero> did you install Haskell Platform?
00:17:43 <Paprikachu> yes, 7.0.3
00:17:45 <mzero> k
00:17:51 <mzero> then I don't know
00:18:03 <mzero> as I said, I'm using leksah 0.11 and it is fine
00:18:09 <mzero> sorry to have lead you down a dark alley
00:18:17 <mzero> :-[
00:18:27 <mzero> anyhow - night time for me
00:18:33 <SubtleArray> I'm using 0.10.0.4 and it runs fine. Using Ubuntu Linux .
00:22:25 * hackagebot ghc-mod 1.10.8 - Happy Haskell programming on Emacs/Vim  http://hackage.haskell.org/package/ghc-mod-1.10.8 (KazuYamamoto)
00:27:18 <adnauseam> hm, guys, how do i break a command in ghci? factorial of 99999999 is taking abit too long ;p
00:27:42 <mjrosenb> adnauseam: ^C
00:27:48 <mjrosenb> adnauseam: also known as control-c
00:28:08 <mjrosenb> hrmm, 99,999,999
00:28:19 * mjrosenb suspects you can compute that without too much pain
00:28:31 <adnauseam> arr, thanks ;p
00:28:51 <adnauseam> hm, i thin it's taking too long because it's recursive
00:29:31 * mjrosenb suspects you are computing it in the wrong order
00:30:27 <adnauseam> :o
00:30:57 <adnauseam> im working with learnyouahaskell's examples ;p i haven't thought of order just yet - but it seems i'm going to derail a bit here to fix this ;p
00:30:59 <MostAwesomeDude> > product [1..99999999]
00:31:07 <lambdabot>   mueval-core: Time limit exceeded
00:31:07 <lambdabot>  mueval: ExitSuccess
00:31:24 <MostAwesomeDude> It *is* a significant number to count up to.
00:31:40 <Paprikachu> > 999 ^ 999
00:31:45 <lambdabot>   mueval-core: Time limit exceeded
00:31:54 <Paprikachu> > 999 ^ 99
00:31:58 <lambdabot>   mueval-core: Time limit exceeded
00:32:05 <Paprikachu> > 99 ^ 99
00:32:09 <lambdabot>   mueval-core: Time limit exceeded
00:32:13 <Paprikachu> > 9 ^ 99
00:32:16 <lambdabot>   295126654306527521487534802261977363143592725170438328860638846376769434334...
00:32:21 <Paprikachu> > 9 ^ 999
00:32:24 <lambdabot>   194207916858072401073330513240517841169895831937243168645765334645631807358...
00:32:29 <Paprikachu> > 50 ^ 999
00:32:31 <lambdabot>   186652723700643775798017908944763433923418289274341604924342867959193382195...
00:32:37 <Paprikachu> > 79 ^ 999
00:32:38 <lambdabot>   536369654252874038645326866887432201240040134328909116800231300717977322689...
00:32:43 <Paprikachu> > 89 ^ 999
00:32:44 <lambdabot>   275814210583142428480486325586103014296869179137778482266502252693725704908...
00:32:50 <Paprikachu> > 94 ^ 999
00:32:52 <lambdabot>   142799190690784148980366174884361785275731696614801105492844632250654091158...
00:32:56 <Paprikachu> > 98 ^ 999
00:32:57 <lambdabot>   171731362981219962640768975613915037625543707216910609715259584070856218411...
00:33:00 <Paprikachu> > 99 ^ 999
00:33:02 <lambdabot>   436073206168265161501341703386462012231079860756206081220421527183410965695...
00:33:05 <Paprikachu> wat
00:33:11 <bill```> o_o
00:33:11 <Paprikachu> oh.
00:33:40 <Paprikachu> > 499 ^ 999
00:33:41 <lambdabot>   252606823547096535253623029205370120517476084176856538800971677143754301649...
00:33:47 <Paprikachu> > 699 ^ 999
00:33:48 <lambdabot>   429238402552755746738258792281948025606016692523310554398098252811258312983...
00:33:52 <Paprikachu> > 899 ^ 999
00:33:53 <lambdabot>   639634737454379086836738279531106532783384988834179658285601146395853249682...
00:33:55 <mjrosenb> it probably has some nonm due to whatever else is running at the same time
00:34:02 <Paprikachu> > 999 ^ 999
00:34:03 <lambdabot>   368063488259223267894700840060521865838338232037353204655959621437025609300...
00:34:05 <levi> You know, you can talk privately with lambdabot. :)
00:34:07 <Paprikachu> wtf.
00:34:07 <Ralith> Paprikachu: lambdabot responds to PMs.
00:34:21 <Paprikachu> kay
00:34:27 <Paprikachu> didn't know that
00:34:29 <cheater_> what is this tomfoolery
00:34:30 <Ralith> Paprikachu: for bonus points, you can also do experimentation on your own computer
00:34:36 <Ralith> shock gasp etc
00:34:42 <cheater_> lol
00:34:51 <Axman6> Paprikachu: /msg lambdabot > 999^999
00:34:52 <Ralith> it's not like this is C++ where setting up a repl is a huge deal
00:35:15 <Paprikachu> repl?
00:35:26 <cheater_> interpreter.
00:35:33 <cheater_> stands for read eval print loop
00:35:35 <liyang> read-evaluate-print-loop
00:35:39 <liyang> what he said.
00:37:28 <Ralith> Paprikachu: also, to answer your implied question, Haskell's default whole-number datatype is arbitrary-precision.
00:37:51 <Paprikachu> that was not my implied question.
00:38:08 <tikhonjelvis> I imagine his implied question was something like "lambdabot: wtf?" :)
00:38:12 <Ralith> perhaps you should express it in a form other than implication, then!
00:38:48 <Paprikachu> i wanted to know what the maximu number is that lambdabot can calculate without getting the time-limit-exceeded message
00:40:40 <mrcarrot> haskell is pretty amazing when it comes to handle huge numbers :)
00:41:02 <mrcarrot> 999^999999 took just about one second on my computer
00:41:40 <mrcarrot> okay, maybe it was 3 seconds
00:41:45 <mrcarrot> but still very fast
00:42:07 <mrcarrot> it takes longer time to output the number than to calculate it
00:44:34 <Axman6> mrcarrot: in ghci run :set -s, then <computation> `seq` () is usually a pretty good way to get timing for those results without printing
00:44:57 <mjrosenb> Axman6: i usually take the value mod 100 :-p
00:45:12 <mjrosenb> Axman6: and hope ghc isn't smart enough to inver the operations
00:45:12 <Axman6> 1that adds extra computation though
00:59:40 <Blkt> good morning everyone
01:02:16 <erus`> the scheme is the part before the => in a type ?
01:05:12 <Peaker> erus`: what are you talking about?
01:05:22 <Peaker> Usually the part before => is called the "context"
01:05:45 <erus`> im trying to grok thih
01:11:14 <Peaker> erus`: grok what?
01:11:29 <QinGW> @src (=>)
01:11:29 <lambdabot> Source not found. You type like i drive.
01:11:33 <erus`> 'typing haskell in haskell'
01:23:29 <nus> erus`, note he's talking about H98 when saying there're no forall's there
01:24:30 <nus> erus`, and something more introductory to Hindley-Milner might help
01:25:15 <erus`> i have implemented system F before
01:26:11 <erus`> but not hindley milner
01:26:18 <Ralith> 01:10:37 < lambdabot> Source not found. You type like i drive.
01:26:24 <Ralith> spot o' irony there
01:28:56 <MiggyX> hi guys, using pattern matching, how can you match against a specific string?  For example if an argument to a function is "hello", I want to pattern match against that string. If I put "hello" as a literal, it works, but if I put the arguments name (say field) it matches based on the type rather than the value. Any pointers?
01:29:58 <Taneb> Hmm
01:30:11 <Taneb> foo a | a == field = bar
01:31:10 <MiggyX> Taneb, cool thanks :)
01:32:07 <Taneb> What's happening is that, instead of pattern-matching, it's making a new thing called "field" and binding the input to it
01:32:23 <Taneb> :t \id -> id * 7
01:32:39 <lambdabot> thread killed
01:32:44 <Taneb> Hmm?
01:32:57 <Taneb> > let foo id = id+6 in foo 10
01:32:59 <lambdabot>   16
01:35:17 <MichaelBurge> @pl \x -> x == (f x)
01:35:17 <lambdabot> ap (==) f
01:35:28 <MichaelBurge> @type ap
01:35:29 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m (a -> b) -> m a -> m b
01:35:57 <Taneb> ap is like combinatory logic's S
01:36:20 <MichaelBurge> Why does the type signature mention a monad when x is of any arbitrary type that implements Eq?
01:36:44 <Taneb> It's the (->) r monad
01:37:29 * hackagebot msgpack-idl 0.1.0 - An IDL Compiler for MessagePack  http://hackage.haskell.org/package/msgpack-idl-0.1.0 (HideyukiTanaka)
01:37:39 <Peaker> MichaelBurge: You asked "@type ap", nothing to do with Eq
01:37:43 <Peaker> @type ap (==)
01:37:44 <lambdabot> forall a. (Eq a) => (a -> a) -> a -> Bool
01:37:51 <MichaelBurge> :o
01:38:48 <Peaker> OpenGL from github can compile against GHC-7.4, but from Hackage, it can't. Why don't they upload a new package?
01:40:43 <erus`> i want dependant types , but i want easiness. I want my cake
01:41:51 <Peaker> I want GHC 7.4 to work well with hackage --- someone should auto-mail people whose packages broke
01:43:17 <MichaelBurge> @pl \x -> f x == g x
01:43:17 <lambdabot> liftM2 (==) f g
01:43:46 <MichaelBurge> @type on
01:43:47 <lambdabot> forall b c a. (b -> b -> c) -> (a -> b) -> a -> a -> c
01:44:43 <Absbeg> :t liftM2
01:44:44 <lambdabot> forall a1 a2 r (m :: * -> *). (Monad m) => (a1 -> a2 -> r) -> m a1 -> m a2 -> m r
01:44:49 <Taneb> \a -> ((==) `on` ($ a)) f g
01:45:20 <erus`> >liftM2 (return . (+)) (Just 3) (Just 4)
01:45:24 <erus`> > liftM2 (return . (+)) (Just 3) (Just 4)
01:45:25 <lambdabot>   Overlapping instances for GHC.Show.Show (a1 -> a1)
01:45:25 <lambdabot>    arising from a use of...
01:45:28 <Absbeg> :t liftM
01:45:29 <lambdabot> forall a1 r (m :: * -> *). (Monad m) => (a1 -> r) -> m a1 -> m r
01:45:57 <Absbeg> :t (==)
01:45:58 <lambdabot> forall a. (Eq a) => a -> a -> Bool
01:46:46 <Absbeg> hmm why liftM2 (==) f g not just (==) f g?
01:47:19 <Taneb> Because some monads don't have Eq
01:47:30 <Taneb> Or a sensible Eq
01:48:18 <Peaker> liftM2 (==) and (==) have different semantics even when the monad does have sensible Eq (e.g: Maybe)
01:50:19 <osager> any all, is there any small package demonstrating directory traversal ? for learning purposes
01:50:51 <osager> i have read the chapter of realworldhaskell
01:51:04 <osager> i want to see some other code
01:51:11 <Peaker> Absbeg: oh you were asking about the above  \x -> f x == g x       you can't compare:  f == g  (which is equiv. to (==) f g)  as they are functions.  You want to compare the result of f to the result of g, so you can use the   (->) r   monad in which the result of the function is the monadic value you can manipulate
01:51:47 <erus`> this predicate stuff makes my brain warp
01:52:12 <Absbeg> Peaker: ohh thanks not it makes sense to me :)
01:52:34 <Absbeg> didn't know about an (->) monad
01:52:35 <erus`> i might implement featherweight java instead
01:53:29 <aleator_> Anyone familiar with WxHaskell? Everything else seems to work fine, but all sliders end up being immovable (one pixel wide?)
02:03:51 <hpaste> Peaker pasted “Directory traversal example” at http://hpaste.org/64024
02:04:26 <Peaker> osager: Here's an example of directory traversal
02:04:33 <Peaker> osager: just wrote it in the last 10 min :)
02:04:49 <osager> thanks peaker
02:04:54 <Peaker> traverse "/etc/X11" --> Directory "/etc/X11" [File "/etc/X11/Xsession.options",Directory "/etc/X11/Xresources" [File "/etc/X11/Xresources/x11-common"], ...
02:06:22 <erus`> is there a language that forces fixed point ?
02:06:26 <erus`> pointless *
02:06:49 <erus`> (that isnt a stack manipulation language)
02:07:38 <yitz> erus`: unlambda, lazyk
02:08:07 <Taneb> Whole bunch of esoteric ones
02:09:10 <Peaker> I think points-free is a useful way to break free from the Hask category and generalize code.. But we might want to have better notation for it
02:17:30 * hackagebot HandlerSocketClient 0.0.5 - Haskell implementation of a HandlerSocket client (API).  http://hackage.haskell.org/package/HandlerSocketClient-0.0.5 (XingboWu)
02:32:30 * hackagebot hlint 1.8.24 - Source code suggestions  http://hackage.haskell.org/package/hlint-1.8.24 (NeilMitchell)
02:39:04 <czro> Hello. I've got some problem building haskell code that depends on the preprocessor after upgrading to xcode 4.3. Seems like the installed cpp breaks a lot of packages. Anyone know about this?
02:43:15 <slehuito> Hi there!
02:43:35 <slehuito> Do you know who is in charge of configuring "Haskell Planet"?
02:44:17 <slehuito> For a few weeks/months, it takes a loooooooooong time to load.
02:44:56 <slehuito> Indeed, it seems that it's not trunkated anymore: there is a message from March 16th, 2011!
02:45:32 <slehuito> (I'm talking about planet.haskell.org)
02:47:31 * hackagebot newtype-th 0.3.2 - A template haskell deriver to create Control.Newtype instances.  http://hackage.haskell.org/package/newtype-th-0.3.2 (MichaelSloan)
02:52:25 <czro> any experts on how the preprocessor works in ghc?
02:55:21 <rostayob> czro: which preprocessor?
02:55:24 <rostayob> CPP?
02:55:53 <czro> Yes. I have some issues building sources that depend on cpp after upgrading to xcode 4.3
02:56:11 <czro> getting a lot of "warning: missing terminating ' character"
02:56:54 <rostayob> czro: how does xcode has to do with GHC? are you trying to build GHC?
02:57:09 <ChristianS> is there a way of integrating post-processing steps into the cabal build process? i usually do "strip <executable>" after compiling an executable, but i don't know how to do that with cabal.
02:57:36 <rostayob> ChristianS: maybe in Setup.lhs?
02:58:17 <czro> No just building packages, but the problem appeared after I upgraded xcode so I assumed there is some dependency on cpp (the C Preprocessor), or does ghc contain its own preprocessor?
02:59:32 <rostayob> czro: mhm. It might be that it runs 'cpp' over the source files, but I'm not sure
02:59:37 <czro> the package I'm having trouble with is network-2.3.0.8
03:00:05 <rostayob> czro: paste the error somewhere
03:00:10 <czro> That's what I thought too. Somehow it gets confused with the ' character.
03:00:13 <czro> ok
03:00:28 <rostayob> czro: actually yes, the manual seems to imply that it uses an external cpp
03:00:40 <rostayob> so the new xcode might be your problem
03:01:22 <hpaste> czro pasted “Preprocessor error ghc 7.4.1” at http://hpaste.org/64025
03:01:27 <erus`> i added the rewrite rule x = () and now nothing will build ?!?
03:01:27 <czro> http://hpaste.org/64025
03:01:43 <ChristianS> rostayob: hm, my Setup.hs just says: import Distribution.Simple; main = defaultMain
03:01:59 <czro> I like the final truncated output "The solution is to..." :)
03:02:19 <ChristianS> i don't know enough about cabal to find out how to get the names of the executables to compile and how to invoke an external process on them.
03:02:29 <ChristianS> i had hoped there would be a simpler solution...
03:02:31 * hackagebot xml-hamlet 0.2.0.1 - Hamlet-style quasiquoter for XML content  http://hackage.haskell.org/package/xml-hamlet-0.2.0.1 (MichaelSnoyman)
03:02:35 <rostayob> ChristianS: yeah, I think you can customize the process more, read up the cabal manual or wait for someone who knows more :P
03:03:08 <ChristianS> rostayob: ok, thanks so far :-)
03:03:43 <rostayob> czro: yeah that could be the problem. maybe you can install a standalone cpp?
03:05:02 <czro> I tried to install cpphs, but ghc does not seem to pick it up. Don't konow where to point ghc to the new preprocessor. I tried to place it first in the path, but that didn't work.
03:06:52 <rostayob> czro: weird. I guess you could temporarly move the old cpp executable to "force" gcc to use the new one
03:07:10 <czro> trying that just now.
03:07:27 <Taneb> What other channels is lambdabot on?
03:07:41 <rostayob> Taneb: #haskell-blah and #agda for sure
03:07:51 <rostayob> #scala as well iirc
03:07:54 <Taneb> I know it's in #esoteric
03:07:59 <ChristianS> rostayob: actually, cabal seems to automatically strip all executables it installs. that's a pleasant surprise :-)
03:08:16 <Taneb> ...What's agda?
03:08:24 <rostayob> Taneb: we don't talk about agda.
03:08:33 <czro> no luck. which cpp points to the new one now (I symlinked cpphs to cpp and put it first in path...)
03:08:36 <rostayob> Taneb: http://wiki.portal.chalmers.se/agda/pmwiki.php
03:08:41 <czro> zzz
03:08:47 <rostayob> Taneb: dependently typed programming language/theorem prover
03:09:26 <rostayob> czro: "no luck"? what error? anyways I have to go
03:09:40 <merijn> rostayob: The first rule of Agda is "don't talk about Agda"? :)
03:09:45 * rostayob goes to have breakfast
03:11:42 <czro> anyone else running xcode 4.3 and ghc 7.4.1?
03:22:12 * mrcarrot is dreaming about the day when there will be a 100% haskell toolkit similar to qt or gtk...
03:23:03 <Peaker> mrcarrot: me and a friend are working on a structural editor for Haskell, and as part of that we are working on a pure-Haskell GUI toolkit too. It's far from complete/comprehensive though
03:23:22 <mrcarrot> Peaker: that is very interesting to hear :)
03:23:26 <Peaker> We only have a simple TextEdit, Grid layout, Focus Delegator, and some nice functionality... It already looks much nicer than Qt/Gtk :-)
03:23:37 <MostAwesomeDude> Is there a Tk binding for Haskell?
03:24:33 <mrcarrot> Peaker: is it on hackage?
03:25:27 <Peaker> mrcarrot: nope, it's not quite ready for Hackage yet
03:25:28 <Peaker> mrcarrot: https://github.com/Peaker/bottle/tree/master/bottlelib/Graphics/UI/Bottle/Widgets
03:28:42 <Peaker> mrcarrot: Note how a Widget is a pure thing.. No IO or such
03:30:21 <Peaker> a Widget is basically something like:   (isFocused::Bool,  requested size [min..max sizes in each axis],  (given size -> ( what to display, how to respond to events )))
03:31:08 <Peaker> did GHC 7.4 eventually add type-level naturals?
03:31:27 <mrcarrot> Peaker: is there already something for putting a picture at a certain position inside of a window and recognice if you clicked on the picture?
03:34:26 <Peaker> mrcarrot: We're focusing on a keyboard interface at the moment
03:34:29 <Peaker> mrcarrot: no mouse inputs at all :)
03:34:57 <Peaker> mrcarrot: but that would be really easy to do with GLFW-b + graphics-drawingcombinators
03:34:59 <Peaker> mrcarrot: no need for a widget framework
03:35:18 <Peaker> You might want to rip off our event loop around GLFW
03:42:41 <Peaker> GADTs don't allow usefully matching _ instead of one other constructor, do they? They don't extract the type info if you do that, apparently
03:49:43 <erus`> someone should write sfml bindings
03:51:32 <rostayob> erus`: if you need them you can write them. writing bindings is not hard at all in Haskell
03:51:46 <erus`> but its C++
03:52:12 <rostayob> erus`: I'd bet there are C bindings
03:52:17 <wavewave> erus` : probably, my fficxx may help you.
03:52:52 <wavewave> but not yet announced.. plan to announce it soon.
03:53:11 <wavewave> at least code is http://www.github.com/wavewave/fficxx
04:00:28 <alpounet> erus`, someone started, actually :)
04:00:37 <alpounet> don't think it has ever been released though
04:00:56 <alpounet> https://github.com/Berengal/SFML---Haskell-bindings
04:01:06 <drdo> Is it possible for ghci to keep the imported modules loaded when it fails loading my file?
04:02:23 <lukish> Use :m + Module
04:03:08 <erus`> also someone should just make an ast editor for haskell as no one can agree on formatting standards
04:03:46 <drdo> lukish: Sure but i don't want to do that for all the modules i might be using on some file :S
04:04:27 <mrcarrot> drdo: copy & paste them all over to another file... then load that file first. would that not work?
04:04:53 <drdo> :)
04:05:13 <drdo> Lots of things work, but the point here was to have less work, not more
04:06:07 <alpounet> wavewave, neat! do you have some kind of tutorial or smth around?
04:06:40 <hpaste> keep_learning pasted “ghc vectorisation error” at http://hpaste.org/64028
04:06:51 <keep_learning> hello all
04:07:18 <lukish> drdo: you can keep all necesary modules in ghci and they will be imported automatically with ghci start
04:07:21 <keep_learning> I am getting this error http://hpaste.org/64028
04:07:29 <RichardO> Can anyone in here help with CIC?
04:07:30 <keep_learning> Any idea how to resolve this ?
04:07:58 <RichardO> (calculus of inductive constructions)
04:13:31 <erus`> whats the difference between an inductive datatype and an algebraic datatype
04:14:54 <frerich> erus`: The first Google hit for 'difference between an inductive datatype and an algebraic datatype' gives me the Wikipedia page on recursive data types, which says "Sometimes the term "inductive data type" is used for algebraic data types which are not necessarily recursive."
04:16:35 <erus`> where as the wikipedia page for inductive types says it may refer to recursive, algebraic or inductive types
04:16:53 <erus`> there's some recursion for you
04:17:50 <Peaker> I see some packages with type-level nats.. Are there any packages with "Fin" defined in them via GADTs?
04:17:57 <Peaker> also, anyone knows what GADT support is in various Haskell compilers?
04:18:34 <Eduard_Munteanu> I think there was a page somewhere comparing the support for various extensions in Haskell compilers.
04:18:49 <wavewave> alpounet: not yet. I need some time to do.. by the way, HROOT is written with the fficxx tool.
04:19:01 <mux> Peaker: https://bitbucket.org/mumux/stuff/src/068959a8d9d7/Vector.hs there's a Fin datatype there
04:19:11 <mux> Peaker: this code doesn't yet use the DataKinds extension though
04:19:58 <alpounet> wavewave, yeah, i figured that out :) it'll be a bit annoying that templates can't be handled properly, but still that looks a like a very useful tool to me!
04:20:11 <Peaker> mux: is it in on hackage anywhere?
04:20:18 <mux> Peaker: nope, sorry
04:20:31 <mux> but I'm sure there are similar implementations there
04:20:35 <Peaker> mux: maybe you could port it to use one of the standard packages for type-level-nats?  It would be nice if there were de-facto standards for these things
04:20:53 <wavewave> alpounet ; thanks for your good impression.. It motivates me to write at least minimal tutorial and announce it.
04:21:02 <mux> Peaker: I'm not really interested to upload this on hackage, at least for now
04:21:03 <Eduard_Munteanu> Peaker: http://hackage.haskell.org/trac/haskell-prime/wiki/HaskellExtensions
04:21:14 <mux> Peaker: but this is BSDL'ed; do what you want with it
04:21:30 <drdo> Is it possible to flip at the type level?
04:21:34 <Eduard_Munteanu> Not sure how up-to-date it is though.
04:21:47 <alpounet> wavewave, writing a tutorial that shows how to do a binding to a hm let's say one-class C++ library, from the beginning 'til the end, would be awesome
04:21:54 <wavewave> alpounet : i'm now getting on a plane.. I will let you know when I make a progress.
04:22:20 <alpounet> great! have a good flight
04:23:19 <Eduard_Munteanu> drdo: type Flip f a b = f b a   ?
04:35:21 <gandsnut1> Looking for clarification on ">"...  I'm working through a Haskell tutorial (learnyouahaskell.com)
04:36:34 <gandsnut1> This line: [ doubleSmallNumber x = if x > 100 ] claims to decide if x is greater-than OR equal
04:36:43 <gandsnut1> (other lines follow)
04:37:38 <gandsnut1> I've always approached ">" to mean JUST greater-than.  This is misleading.  In 'C', if I evaluate (x > 100) and x == 100, I get false
04:38:01 <MostAwesomeDude> > 100 > 100
04:38:02 <lambdabot>   False
04:38:14 <MostAwesomeDude> let x = 100 in x > 100
04:38:17 <MostAwesomeDude> > let x = 100 in x > 100
04:38:18 <lambdabot>   False
04:38:23 <gandsnut1> Here in Haskell, apparently if x == 100, x > 100 = True   ???
04:38:32 <MostAwesomeDude> Might be a thinko/typo in LYAH. Drop the author a line?
04:38:50 <MostAwesomeDude> (Read what I just typed into the bot.)
04:39:01 <gandsnut1> Phew, man, I thought logic had changed!
04:39:02 <yoaha> and possibly link the page?
04:39:17 <koala_man> gandsnut1: "but only if that number is smaller than or equal to 100 because numbers bigger than 100 are big enough as it is! "
04:39:19 <erus`> can a forall be polymorphic over kinds?
04:39:35 <erus`> i guess that makes it a type level function
04:40:21 <koala_man> gandsnut1: it never says greater than or equal
04:40:32 <mux> erus`: nope, but GHC 7.4.1 has an extension for kind polymorphism
04:40:52 <Taneb> http://hpaste.org/64030 <-- any ideas?
04:41:32 <gandsnut1> koala_man: you mean there is no such ">=" as in 'C'?
04:41:53 <koala_man> gandsnut1: no, I'm saying learnyouahaskell never says that > means "greater than or equal"
04:42:36 <Botje> > only means 'greater than'
04:42:37 <lambdabot>   <no location info>:
04:42:37 <lambdabot>      lexical error in string/character literal at chara...
04:42:43 <Botje> doh :/
04:42:44 <gandsnut1> koala_man:  Here's from the learnyouahaskell page:  "Now we're going to make a function that multiplies a number by 2 but  only if that number is smaller than or equal to 100 because numbers  bigger than 100 are big enough as it is! "
04:42:55 <alpounet> > 100 >= 100
04:42:56 <lambdabot>   True
04:43:27 <gandsnut1> Oh.   This lambdabot evaluates Haskell code.  Huh.
04:43:54 <yoaha> i love lines like: "This might seem like it's inefficient but laziness takes care of that problem."
04:44:07 <koala_man> gandsnut1: yes, I pasted that too. it doesn't say that it checks if the number is great or equal, you're misreading it somehow
04:44:15 <alpounet> gandsnut1, the "x > 100" condition, if true, means that your number is NOT less than or equal to 100
04:44:39 <alpounet> so you're not going to multiply it by anything in that case
04:44:40 <Taneb> http://hpaste.org/64030 <-- any help?
04:45:01 <alpounet> if not true, it means x <= 100, so you in that case, you DO multiply the number by 2
04:45:01 <mux> @check \x -> (x::Int) > 100 == not (x <= 100)
04:45:02 <lambdabot>   Precedence parsing error
04:45:02 <lambdabot>      cannot mix `GHC.Classes.>' [infix 4] and `GHC...
04:45:09 <Rc43_> Hi, guys.
04:45:13 <mux> @check \x -> ((x::Int) > 100) == not (x <= 100)
04:45:16 <lambdabot>   mueval-core: Time limit exceeded
04:45:27 <mux> oh, come on LB, cut me some slack here.
04:45:29 <mux> @check \x -> ((x::Int) > 100) == not (x <= 100)
04:45:32 <lambdabot>   "OK, passed 500 tests."
04:46:04 <ion> mueval should have a CPU time limit instead of an absolute time limit.
04:46:13 <erus`> whats a lambda abstraction called when the abstracted type is generic ?
04:46:18 <Rc43_> I am working not on my home machine now. There is strange error with do-notation (ghc 7.0.3, windows). GHCi says: `BFSRev.hs:53:5: The last statement in a 'do' construct must be an expression:     (b, source) <- readInt source (_, source)`
04:46:28 <Rc43_> Appending `;` to the line helps.
04:46:33 <Rc43_> But it is strange.
04:46:39 <Botje> Rc43_: that generally means your indentation is wrong.
04:46:40 <byorgey> Taneb: hmm, strange
04:46:42 <gandsnut1> Thanks, I'll have to ponder on this for a while.
04:46:47 <Botje> are you mixing tabs and spaces? it's quite common.
04:47:02 <byorgey> Taneb: can you paste the output of  cabal install cabal-install -v  ?
04:47:11 <mux> erus`: when it can be any type? universal quantification
04:47:25 <Rc43_> Botje, oh, really, therea are tabs mixed with spaces, editor has other settings. Thanks.
04:47:33 <byorgey> Taneb: it wants to install an old version of the unix package which isn't compatible with your version of GHC
04:47:43 <erus`> mux does it have a greek alphabet name?
04:47:48 <byorgey> but I don't know why it would want to install that old version of unix.
04:47:51 <mux> erus`: but we don't differentiate it from other lambdas in haskell, because we don't need to; the type parameter being inferred
04:47:54 <Taneb> byorgey: http://hpaste.org/64032
04:47:58 * hackagebot Holumbus-Searchengine 1.2.1 - A search and indexing engine.  http://hackage.haskell.org/package/Holumbus-Searchengine-1.2.1 (UweSchmidt)
04:48:13 <mux> erus`: only the traditional universal quantifier symbol, an inverted letter A
04:48:31 <erus`> hmm i allready have a forall at the type level :|
04:48:44 <erus`> name collision
04:48:54 <osa1_> where can I see Control.Monad.State's source?
04:49:22 <q0tw4> Taneb: what is version of ghc?
04:49:41 <Taneb> q0tw4, 7.4.1
04:50:20 <q0tw4> for 7.4.1 cabal-install.cabal must be fixed by hands :(
04:50:34 <mux> q0tw4: or you can use the darcs version, it works fine
04:51:23 <byorgey> Taneb: oh, now I see.  It seems that cabal-install really does require that version of unix, which requires an older version of base.
04:51:31 <Taneb> !?
04:51:35 <byorgey> Taneb: thus I conclude that cabal-install cannot be built under GHC 7.4.1.
04:51:59 <q0tw4> it is better to use 7.2 and http://hackage.haskell.org/package/cabal-install-ghc72 if you don't want to fix packeges
04:52:04 <byorgey> Taneb: anyway, why are you trying to install it?  What version do you already have?
04:52:40 <q0tw4> cabal-install can be built under GHC 7.4.1. Later I can share fixed sources
04:52:41 <Taneb> byorgey, I'm installing it because it asked me to
04:52:51 <byorgey> what, it did?
04:52:52 <Taneb> 1.8.0.2
04:53:00 <mux> q0tw4: uh, hello, I've been trying to say it is fixed in the darcs repo already
04:53:13 <mux> cabal-install version 0.13.3
04:53:31 <Taneb> 0.8.0
04:53:53 <Taneb> "Note: there is a new version of cabal-install available.
04:53:54 <Taneb> To upgrade, run: cabal install cabal-install"
04:53:55 <q0tw4> I think that I checked darcs version. Maybe no
04:54:08 <byorgey> Taneb: ah.  well, I think you can safely ignore that.
04:54:13 <byorgey> Taneb: 0.8.0 should work just fine.
04:54:33 <Taneb> Okay
04:54:59 <Taneb> That's easy, I suppose
05:17:28 <hpaste> erus` pasted “How can i prettify?” at http://hpaste.org/64033
05:20:46 <hpaste> Dirk pasted “lift” at http://hpaste.org/64035
05:22:13 <dhun_233> can I write l2 in a more general way http://hpaste.org/64035 I also want l3 l4 and so on
05:22:13 <lambdabot> dhun_233: You have 2 new messages. '/msg lambdabot @messages' to read them.
05:32:51 <frerich> dhun_233: My idea would be to use 'iterate'
05:32:55 <dhun_233> to put it more concise, why can't I write lz x n = (iterate lift x) !! n
05:33:09 <dhun_233> give an error about infinite type
05:33:18 <quicksilver>  you can't do that
05:33:20 <quicksilver> they're different types.
05:33:33 <quicksilver> you can't use iterate on polymorphic functions
05:33:42 <hpc> :t iterate
05:33:42 <lambdabot> forall a. (a -> a) -> a -> [a]
05:33:45 <quicksilver> (well you can't use it to use the same function N times at N different types)
05:33:58 <dhun_233> and what can I do then
05:34:13 <quicksilver> the general solution to "multiple lifts" is to have a typeclass which knows how many times to lift.
05:34:29 <quicksilver> for example "liftIO" is a composition of N lifts - always the right number to get to the IO.
05:34:43 <dylukes> @src liftIO
05:34:43 <lambdabot> Source not found. This mission is too important for me to allow you to jeopardize it.
05:34:46 <dhun_233> ok to liftIO does it
05:35:00 <dylukes> It's actually not quicksilver
05:35:12 <quicksilver> dylukes: ?
05:35:14 <dylukes> It's usually just a single lift.
05:35:30 <dylukes> But the definitions stack up.
05:35:41 <hpc> you probably don't want to do this, if you need it to do something specific, btw
05:35:58 <dhun_233> I am just playing around currently
05:36:03 <hpc> ah, k
05:36:04 <quicksilver> well, in ReaderT StateT IO, liftIO is lift.lift
05:36:08 <dylukes> true
05:36:11 <quicksilver> not really sure what you mean dylukes
05:36:17 <dylukes> sorry, w/e
05:36:24 <dylukes> In any case, dhun_233, the usual technique is to define a class
05:36:36 <dylukes> i.e., StateT has MonadState, ReaderT has MonadReader...
05:37:01 <dylukes> and put all of the fundamental ops of that transformer in there (get/put/modify, ask/asks/local)
05:37:03 <dylukes> Then
05:37:10 <dhun_233> The point is that I stack a lot of StateT on IO
05:37:20 <dylukes> instance MonadState StateT { get = get ... }
05:37:27 <dhun_233> and I often change the number of StateT I use
05:37:31 <dylukes> State*
05:37:38 <dylukes> instance MonadState StateT IO { get = ... }
05:37:45 <quicksilver> dhun_233: then liftIO is precisely your answre.
05:37:49 <dylukes> instance Monad m => ReaderT StateT m  { get = ... }
05:37:50 <dylukes> etc
05:38:13 <quicksilver> oh, you don't just want to get to the IO, but also to each state?
05:38:32 <quicksilver> yes, then probably a nice custom class like dylukes is suggesting
05:38:44 <dhun_233> yeah liftIO does this for the moment
05:38:57 <quicksilver> if all your states are different types you could actually have a magic "get" which always gets the right state
05:39:04 <dylukes> the idea, ostensibly,
05:39:08 <quicksilver> with a suitable typeclass
05:39:10 <dylukes> is that the core operations are in the typeclass
05:39:12 <dylukes> and then you do
05:39:24 <dhun_233> thats the idea have a magic get that gets me the right state
05:39:38 <dylukes> my_cool_state_action :: MonadState m => ...
05:40:11 <dylukes> so you're basically saying "I want to define a function across ANY monad which can carry state (and I know will have get/put/modify).
05:41:01 <dhun_233> perhaps I am not sure
05:41:34 <dhun_233> I basically looked what happens if I try to write in Haskell using a C like style
05:43:08 <dhun_233> and the main idea I got from you, is that I have to consider typeclasses in this problem
05:47:52 <dylukes> If you want to write C-esque code, just use IO + IORefs
05:48:34 <hpc> or use Ptr and unsafeCoerce ;)
05:49:46 <dhun_233> I think with IO Refs i can't have scope, with the current solution I do
05:53:02 * hackagebot hxt 9.2.1 - A collection of tools for processing XML with Haskell.  http://hackage.haskell.org/package/hxt-9.2.1 (UweSchmidt)
05:53:13 <Eduard_Munteanu> dhun_233: what do you mean by scope?
05:54:26 <dhun_233> visability of variables
05:57:13 <dhun_233> so I want to have a certain new integer to become usable as soon a a certain do block begins and is not accessible anymore as soon as the do block ends and I want the compiles to make sure that I don't use the integer at outside it
05:57:38 <dhun_233> compiles -> compiler
05:57:50 <jtootf> have anyone worked with the Data.Array.Accelerate?
06:13:03 * hackagebot hxt-http 9.1.4 - Interface to native Haskell HTTP package HTTP  http://hackage.haskell.org/package/hxt-http-9.1.4 (UweSchmidt)
06:14:08 <hpc> @hoogle [a] -> a -> [a]
06:14:09 <lambdabot> Data.List intersperse :: a -> [a] -> [a]
06:14:09 <lambdabot> Data.List insertBy :: (a -> a -> Ordering) -> a -> [a] -> [a]
06:14:09 <lambdabot> Data.List deleteBy :: (a -> a -> Bool) -> a -> [a] -> [a]
06:17:02 <erus`> @hoogle (,)
06:17:03 <lambdabot> Prelude undefined :: a
06:17:03 <lambdabot> Data.Function fix :: (a -> a) -> a
06:17:03 <lambdabot> Control.Monad.Fix fix :: (a -> a) -> a
06:28:39 <kaf3ii> 'newtype A a = A (Int -> IO a) deriving (Functor)' how can i get GeneralizedNewtypeDeriving to help instanciate this
06:29:31 <kaf3ii> it says "Can't make a derived instance of `Functor A`"
06:43:21 <hpc> kaf3ii: instance Functor A where fmap f (A a) = A (f .: a)
06:43:36 <hpc> kaf3ii: it chokes because of the 'Int'
06:44:04 <hpc> if you made it 'newtype A b a = A (b -> IO a)', it could probably do it
06:44:17 <rwbarton> you need DeriveFunctor, not GeneralizedNewtypeDeriving
06:44:24 <hpc> ah, also that
06:47:22 <kaf3ii> hpc: DeriveFunctor worked, but if i wanted to make it an applicative also
06:47:29 <Taneb> How do I put a flag in a .hs?
06:47:53 <hpc> kaf3ii: no clue; rwbarton seems to know more about the extensions than i do
06:47:54 <azaq23> {-# LANGUAGE FlagName #-} Taneb
06:48:01 <Taneb> Thanks
06:48:05 * hackagebot IOSpec 0.2.4 - A pure specification of the IO monad.  http://hackage.haskell.org/package/IOSpec-0.2.4 (WouterSwierstra)
06:48:14 <hpc> or {-# OPTION Whatever #-}
06:48:18 <hpc> depends on what you want to set
06:48:22 <rwbarton> kaf3ii: then you write an Applicative instance yourself
06:49:12 <rwbarton> GeneralizedNewtypeDeriving is for when you've introduced a new type constructor via newtype that is the same as some old type expression
06:49:24 <kaf3ii> ok, i have a distant memory of using 'newtype DB m a = DB (Connection -> m a) deriving (Functor, Applicative, Monad)' with that extension
06:50:10 <rwbarton> nope, imagination :)
06:50:17 <rwbarton> what you can do is things like
06:50:29 <rwbarton> newtype MyMonad a = MyMonad (Reader MyState a)
06:50:34 <rwbarton> deriving (whatever)
06:50:51 <rwbarton> because that effectively defines MyMonad as a newtype of Reader MyState
06:51:47 <rwbarton> I'm sure the GHC user manual can explain it better than I can
06:51:49 <kaf3ii> Ah so, 'newtype DM m a = DB (ReaderT m Connection a) deriving (...)' can work ?
06:51:54 <rwbarton> yes
06:52:01 <kaf3ii> nice
06:52:14 <rwbarton> or, I think so, definitely if you fix m
06:54:39 <rwbarton> the problem with your original example is that it desugars to newtype A a = A ((->) Int (IO a)), that's not the application of anything to a
06:54:53 <rwbarton> so there is no "old type" to transfer an instance from
06:59:36 <kaf3ii> rwbarton: 'newtype A m a = A (ReaderT Int m a) deriving (Functor, Applicative, Monad)'
07:00:28 <kaf3ii> rwbarton: works, so the extension lifts out the instances of the (ReaderT Int m a)
07:00:38 <rwbarton> right
07:01:39 <kaf3ii> rwbarton: but if i supplied instances for (Int -> IO a) then it would work :D
07:01:42 <rwbarton> I think what it does is look at how many arguments the type constructor in the type class takes, so here Monad applies to something of kind * -> * so there's 1 argument, then it tries to "eta-reduce" the expansion of the newtype that many times (i.e. rewrite it in the form x a_1 ... a_n for some x)
07:01:47 <rwbarton> no, you can't
07:01:58 <rwbarton> assuming you mean something like Monad
07:02:02 <rwbarton> there's nothing to write an instance for
07:02:52 <rwbarton> this should be on a FAQ somewhere
07:04:07 <kaf3ii> ReaderT is definitly what is was lookign for, so i'll be fine for now
07:15:37 <frusen> map reverse ["ok","1234","hi"] give me: Couldn't match expected type `IO a' against inferred type `[[Char]]'
07:15:49 <frusen> i d on't understand what i've done wrong
07:15:56 <rwbarton> No, it doesn't.
07:16:01 <rwbarton> > map reverse ["ok","1234","hi"]
07:16:02 <lambdabot>   ["ko","4321","ih"]
07:16:32 <byorgey> frusen: however, if you use that in a context that is expecting an IO action, you will get that error.
07:17:18 <frusen> hmm, it do work in the GHCI
07:17:27 <frusen> does*
07:17:55 <frusen> oh, i figured it out
07:18:14 <frusen> i did "let a = map reverse ["abc","cda","1234"]"
07:18:57 <byorgey> there's nothing inherently wrong with that either
07:19:20 <frusen> well, i am writing a program in a .hs file
07:19:23 <frusen> im not in the ghci
07:19:32 <frusen> if i did "let a =" it worked
07:19:39 <rwbarton> oh
07:19:58 <byorgey> if 'map reverse ...' is by itself in the middle of a do-block you would get that error
07:20:16 <byorgey> and yes, let a = ...  would work
07:20:33 <frusen> i've made a custom function to use with map
07:20:45 <frusen> that should print out every element
07:20:46 <frusen> modified
07:21:18 <frusen> but it doesn't get printed out
07:21:29 <rwbarton> uh oh
07:22:31 <frusen> let a = map check ["abc","ok"]        check s = putStrLn s
07:22:37 <byorgey> frusen: for now I advise you to forget about printing things out.
07:22:44 <rwbarton> "let a = map reverse ["abc","cda","1234"]" doesn't cause anything to be evaluated until a is used.
07:22:48 <byorgey> frusen: just write functions to compute things, and then use ghci to visualize the results.
07:23:06 <rwbarton> But more importantly, even if it did, evaluating IO actions doesn't cause their effects to occur.
07:23:10 * hackagebot HaTeX-meta 1.1.1 - HaTeX monad modules builder.  http://hackage.haskell.org/package/HaTeX-meta-1.1.1 (DanielDiaz)
07:23:12 * hackagebot HaTeX 3.2 - LaTeX code writer.  http://hackage.haskell.org/package/HaTeX-3.2 (DanielDiaz)
07:23:22 <HugoDaniel> HaTeX -> feel the hate
07:23:22 <frusen> what i am trying to do is to iterate through a list of strings and doing stuff which each element
07:23:49 <frusen> do stuff with each element*
07:26:33 <frusen> i have an idea
07:26:39 <frerich> frusen: This may be frustrating, but to me it sounds like you're approaching the problem with an inappropriate (imperative) mindset. Instead of explaining *how* you want to do something, try to think about *what* you want to do. In your case, what's that "stuff" you want to do?
07:28:10 <nand`> byorgey: “if 'map reverse ...' is by itself in the middle of a do-block you would get that error” <- depends on the monad
07:28:43 <rwbarton> obviously byorgey knows this
07:28:47 <rwbarton> (sorry)
07:28:57 <nand`> rwbarton: I'm not implying byorgey doesn't know this
07:29:04 <adimit> frusen: try main = print $ map reverse ["abc", "bca", "1234"]
07:29:07 <nand`> I'm just amending his statement
07:29:08 <rwbarton> equally obviously frusen will only be more confused by this
07:29:10 <byorgey> nand`: then why are you telling me? =)
07:29:11 <adimit> frusen: and then go read LYAH.
07:29:27 <nand`> byorgey: because you made the statement which I thought could use additional clarification :P
07:29:49 <byorgey> nand`: I specifically chose not to say it, to keep things simple.
07:30:01 <frusen> frerich: I'm trying to "convert" each string element of a list to a md5 hash
07:30:12 <nand`> byorgey: you could have used “your do block” instead of “a do block” to keep things simple
07:30:16 <nand`> and still correct
07:30:22 <frusen> frerich: but I am stuck on the iteration
07:30:26 <nand`> but I'll drop the issue
07:31:11 <frerich> frusen: Sounds like you need a function which takes a string and yields an MD5 hash - and then you map that function over your list to get a new list with all the MD5 sums, no?
07:33:12 <frusen> frerich: well, I'm doing this "(md5 (B.pack (encode "blah")))" using Pure.MD5 where "import qualified Data.ByteString.Lazy as B"
07:34:01 <frusen> frerich: what I am really trying to accomplish is to compare a hash to a list of words, where i check the md5 of each word and compare it to the hash
07:34:49 <frerich> frusen: Aha, now we're getting closer. What do you want to do if one (or multiple) of the words have the given hash?
07:36:21 <frusen> frerich: if that occurs I want to return the specific word
07:36:30 <frerich> frusen: this '(md5 (B.pack (encode "blah")))' would be your way to turn a string into an MD5 (or "String -> MD5Digest" in Haskell lingo). You could make a little function out of that, like 'md5OfString s = (md5 (B.pack (encode s)))' (at this point other people in this channel may jump in and point uot that there are different ways to express this fucntion, don't listen to them to avoid getting more confused ;-).
07:36:52 <nand`> frusen: sounds like you want filter
07:37:27 <nand`> > filter (\item -> reverse item == "olleh") ["foo", "bar", "hello", "world"]
07:37:28 <lambdabot>   ["hello"]
07:37:57 <frusen> ah, I see...
07:38:01 <frerich> frusen: Aha, sounds like a plan. So we have the 'what' sorted out: given a list of words and some hashsum, we want to filter out those words which have the same hash as the one we're given and then we just, well, give the first item in this ilst (assuming this list is always of length '1').
07:38:26 <nand`> frerich: I like the last part of your explanation :)
07:41:49 <frerich> frusen: So, if the function you want to write takes a list of words and a hash sum and it might return a word (or not, if no word matches the hashsum), then the signature of your function could be '[String] -> MD5Digest -> Maybe String'.
07:42:17 <frerich> frusen: This smells like a use case for the 'find' function in the 'Data.List' module.
07:42:40 <frusen> frerich: hmm, okay, I'll check it out
07:43:11 <Toby> !nick Tob
07:43:11 <frusen> ohh
07:43:15 <Toby> Oops
07:43:27 <Guest78216> Fine
07:43:36 <frusen> frerich: cool, I see where this is going
07:43:55 <Guest78216> Hi anyone. Should tryhaskell.org work? All I am getting is "Terminated!"
07:44:55 <hpc> Guest78216: what are you evaluating?
07:45:00 <Guest78216> 1
07:45:03 <Guest78216> 5 + 7
07:45:12 <Guest78216> true
07:45:16 <hpc> sounds like it's not working
07:45:21 <Landarzar> iam getting the same error
07:45:30 <hpc> that's the error mueval gives when a computation takes too long
07:45:40 <hpc> could be just traffic or something
07:46:06 <Guest78216> FIne. I'll just do a local install of Haskell and go from there.
07:46:13 <Guest78216> Thank you for your help
07:48:41 <rwbarton> tryhaskell.org also wasn't working when I tried it a couple months ago
07:48:50 <frusen> frerich: i think i got something
08:15:56 <erus`> my type checker is reducing type applications :|
08:21:35 <yitz> there is a comment in a current reddit thread that talks about how cool it is that you can use the diagrams package in tryhaskell to draw pictures in your browser. could be the current problems with tryhaskell are the result of it being "slashdotted" by that reddit thread.
08:23:00 <luite> I think it probably just needs to be restarted
08:28:28 <kstt> hey, I'm needing something quiet simple. I have a datatype to enumerate resources, as nullary constructors. That allows implementation to be based on pattern-matching, therefore safe with -Wall. I would need to list all constructors for some usage. How to do so ?
08:28:44 <kstt> I can certainly do something based on the automatic Enum derivation
08:29:12 <kstt> but I'd have expected the typeclass to offer a "list :: [a]" method to get the list of constructors
08:32:47 <quicksilver> kstt: [minBound..maxBound]
08:32:56 <quicksilver> kstt: given deriving (Bounded,Enum)
08:33:25 <quicksilver> I have several bits of code with allValues :: (Enum a, Bounded a) => [a]; allValues = [minBound..maxBound]
08:34:26 <kstt> great exactly what I wanted
08:34:58 <kstt> I was thinking of something along the lines of "enumFrom $ fromEnum 0"
08:35:07 <quicksilver> > length ([minBound..maxBound] :: Char)
08:35:08 <lambdabot>   Couldn't match expected type `GHC.Types.Char'
08:35:09 <lambdabot>         against inferred type...
08:35:12 <quicksilver> > length ([minBound..maxBound] :: [Char])
08:35:12 <lambdabot>   1114112
08:35:17 <quicksilver> > length ([minBound..maxBound] :: [Word16])
08:35:17 <lambdabot>   65536
08:35:20 <cmccann> https://github.com/isomorphism/Overture/blob/master/src/Overture/Data.hs#L123
08:35:23 <cmccann> :]
08:36:55 <cmccann> quicksilver, kstt, it's a handy little utility definition (cf. my link)
08:37:08 <quicksilver> agreed
08:37:58 <cmccann> seems like something that ought to be in the standard libraries
08:38:13 <kstt> > length ((enumFrom $ fromEnum 0) :: [Char])
08:38:13 <cmccann> since so many people have reinvented it
08:38:14 <lambdabot>   Couldn't match expected type `GHC.Types.Char'
08:38:14 <lambdabot>         against inferred type...
08:38:34 <quicksilver> any discussion about adding it to standard libraries would devolve into a slanging match about how rubbish Enum is, cmccann
08:38:41 <quicksilver> you'd never get consensus
08:38:44 <quicksilver> it's a haskell-Godwin
08:38:45 <cmccann> well yeah
08:38:50 <cmccann> Enum is pretty terrible
08:39:11 <kstt> > length ((enumFrom $ toEnum 0) :: [Char])
08:39:12 <lambdabot>   1114112
08:39:12 <cmccann> though this is a good example of what it's actually good for :T
08:39:12 <acvnlsjp> what's wrong with it?
08:39:20 <kstt> hey, this works :)
08:39:29 <kstt> without the bounded restriction ;p
08:39:40 <quicksilver> acvnlsjp: it conflates "class which expresses range syntax" with "class which is in bijection with subset of the Ints"
08:39:56 <kstt> indeed ! hence the toEnum trick :/
08:39:57 <scooty-puff> whatever it is that makes it so that an STRef can't leak out of ST (related to the type var s, but not sure how - wouldn't mind an good explanation), would it still work for a transformer?
08:40:00 <cmccann> > succ 1.5
08:40:01 <lambdabot>   2.5
08:40:18 <quicksilver> > [0.3,0.65 .. 2.1]
08:40:19 <lambdabot>   [0.3,0.65,1.0,1.35,1.7000000000000002,2.0500000000000003]
08:40:33 <cmccann> scooty-puff, what sort of transformer?
08:41:01 <scooty-puff> like some hypothetically STT
08:41:13 <cmccann> yes, that part would work
08:41:20 <scooty-puff> k, perfect
08:41:20 <scooty-puff> thanks
08:41:25 <cmccann> STT is problematic because of other issues
08:41:35 <cmccann> such as transforming a monad that duplicates the internal state
08:41:41 <scooty-puff> right - this isn't for STT, but will use the same trick
08:41:49 <cmccann> i.e. STT [] is not good
08:41:57 <scooty-puff> o yeah..
08:42:04 <cmccann> scooty-puff, the trick is the type of runST basically
08:42:16 <scooty-puff> is it just a general thing about rank n types?
08:42:23 <erus`> i have tagged unions :D
08:42:26 <scooty-puff> i am uncertain what skolem type variables are
08:42:28 <erus`> you jelly? u mad?
08:42:28 <cmccann> sort of
08:42:37 <quicksilver> it's a general thing about having a forall in brackets
08:42:47 <cmccann> scooty-puff, the type of runST requires that "s" be completely polymorphic
08:42:51 <quicksilver> very much related to existential types.
08:43:07 <cmccann> which means it gets to set a type for "s" inside the computation that's run
08:43:27 <cmccann> you can't know what that type is, so it's a type error (escaped scope blah blah) to do anything with it otherwise
08:44:00 <cmccann> and anything that constraints the type of "s" will prevent runST from accepting it
08:45:32 <cmccann> the end result is that using runST on a computation is entirely self-contained in a way that's enforced by the type system
08:46:49 <cmccann> scooty-puff, that make sense at all?
08:47:13 <scooty-puff> that makes sense
08:47:37 <scooty-puff> much easier to under stand on the right side of the right most ->
08:47:38 <cmccann> it's just a fancier form of parametricity
08:47:43 <scooty-puff> yeah
08:47:54 <scooty-puff> i think have use it before, but with GADTs
08:48:06 <cmccann> i.e. why (forall a. a -> a) can only be id (or something that gives _|_)
08:48:42 <mkscrg> how can I get a list of the constructors of an ADT without defining Enum and Bounded instances?
08:49:12 <donri> template haskell?
08:49:14 <Enigmagic> mkscrg: Data.Typeable
08:49:24 <quicksilver> not Data.Typeable.
08:49:36 <quicksilver> some metaprogramming
08:49:44 <quicksilver> Data.Derive is quite well liked
08:49:49 <hpc> it will break for stuff like Maybe though
08:49:53 <quicksilver> alternatives exist
08:49:53 <hpc> > [Nothing, Just]
08:49:54 <lambdabot>   Couldn't match expected type `Data.Maybe.Maybe a'
08:49:55 <lambdabot>         against inferred ...
08:50:12 <quicksilver> depends what you think a "list of constructors" is, yes :)
08:50:30 <mkscrg> what's the argument against Data.Typeable?
08:50:35 <quicksilver> it doesn't work.
08:50:55 <quicksilver> it doesn't do anything about constructors.
08:51:23 <quicksilver> there is a pattern where you pair each ADT with a second, simplified ADT, which is just an enumeration.
08:51:36 * cmccann thinks mkscrg wants Data.Data, not Data.Typeable
08:51:48 <mkscrg> quicksilver: ah, you're right. (Just looked at Data.Typeable for the first time)
08:52:01 <quicksilver> data T = A X | B Y; data TCons = TC_A | TC_B; get_cons (A _) = TC_A; get_cons (B _) = TC_B.
08:52:01 <Enigmagic> Data.Data does
08:52:02 <Enigmagic> DataType {tycon = "Prelude.Maybe", datarep = AlgRep [Nothing,Just]}
08:52:18 <quicksilver> you can metaprogram the boilerplate.
08:53:07 <Taneb> Having trouble installing glib...
08:53:12 <frusen> frerich: I figured it out :)
08:53:15 <frusen> thanks for your help
08:53:45 <Enigmagic> > dataTypeOf (Just (1 :: Int))
08:53:46 <lambdabot>   DataType {tycon = "Prelude.Maybe", datarep = AlgRep [Nothing,Just]}
08:54:30 <Taneb> http://hpaste.org/64041
09:02:48 <q0tw4> Taneb: try darcs get --lazy http://code.haskell.org/gtk2hs/
09:03:41 <q0tw4> if you use 7.4.1 many packages must be installed from darcs/git
09:04:12 <aszlig> hm, what would be the best solution for ensuring that a program is only running once, possibly cross-platform, but not necessarily?
09:04:35 <mekeor> yea, i think for "usual"/"casual"/"normal" haskellers the GHC version from the latest haskell-platform is best, isn't it?
09:04:45 <mekeor> q0tw4: ^
09:04:48 <aszlig> i'm trying setLock in System.Posix for now, but it won't bail out if the file is already locked
09:05:22 <c_wraith> aszlig: bind to a fixed tcp port to listen?
09:05:26 <aszlig> and the whole thing "for the wild" - meaning: i don't know how much the systems the program will be running on will be messed up
09:06:09 <q0tw4> it is not bad to use new compiller if you know haskell well and have a lot of free time
09:06:17 <aszlig> thought about that, but i guess that will be a too expensive operation
09:07:04 <c_wraith> How is that expensive?  It doesn't talk on the network, it just sets up some kernel data structures.
09:07:06 <aszlig> but probably the most cross-platform way of doing that
09:07:24 <c_wraith> Also, it only does it once per program run
09:07:56 <aszlig> yep, but testing if the program is running is done about > 100k per second
09:08:37 <aszlig> s/per/times &/
09:08:38 <c_wraith> THen I'd argue that something is horribly wrong with the requirement.
09:08:55 <aszlig> it is ;-)
09:10:02 <aszlig> but that will lead into an endless discussion =)
09:10:28 <mauke> aszlig: are you saying setLock will block?
09:10:29 <aszlig> anyway, so what's left besides setLock and pid files?
09:10:35 <aszlig> nope
09:11:04 <aszlig> it won't block, but it won't throw an exception if the lock was set by another instance
09:11:17 <aszlig> so i need to call getLock, which in turn is prone to race conditions
09:11:49 <mauke> that seems broken
09:11:56 <mauke> what do you mean by "instance"?
09:12:09 <aszlig> instance -> another process of the program running
09:12:21 <mauke> brb, writing test program
09:12:38 <quicksilver> I'd suggest PID file on a fast filesystem on a ramdisk.
09:12:44 <quicksilver> requires setup though
09:13:13 <aszlig> hm, it doesn't seem to be broken...
09:13:33 <aszlig> looks like the setLock isn't the problem in my case
09:13:39 <aszlig> so sorry for the noise ;-)
09:15:02 <aszlig> quicksilver: yah, i'm in a somewhat "unknown territory" - meaning, i'm already trying several methods to find a file that is writeable, if it is, try to lock, otherwise, resort to pid and if that's not working, bail out if thi tcp socket is already bound
09:15:17 <aszlig> s/pid&/files/
09:15:29 <aszlig> thanks anyway
09:19:16 <captWheeto> Can anyone explain what fforce-recomp does? I don't want to use it everytime I compile in case it's not needed
09:20:12 <quicksilver> it forces GHC to compile every file
09:20:21 <quicksilver> you shouldn't normally need it. Normally it rechecks deps fine.
09:20:30 <captWheeto> Ok (: I'll steer clear
09:20:34 <quicksilver> you need it if you want to recompile with different optimisations options
09:20:39 <captWheeto> I see
09:20:42 <captWheeto> Thanks!
09:20:48 <captWheeto> The name makes sense now
09:24:18 <kowey> I *think* I wish cabal-install refused by default to install packages that would entail packages from the global DB being reinstalled later on
09:24:37 <kowey> in my case, I'd accidentally cabal-dev install'ed old-locale
09:24:53 <kowey> and then found cabal-dev installing old-time, process, etc
09:25:20 <JoeyA> > let foo :: a -> b -> c -> (Ord d, Ord e) => d -> e -> Ordering; foo _ _ _ d e = compare d e
09:25:21 <lambdabot>   not an expression: `let foo :: a -> b -> c -> (Ord d, Ord e) => d -> e -> O...
09:25:38 <JoeyA> > let foo :: a -> b -> c -> (Ord d, Ord e) => d -> e -> Ordering; foo _ _ _ d e = compare d e in foo () () () 3 5
09:25:38 <lambdabot>   Couldn't match expected type `d' against inferred type `e'
09:25:39 <lambdabot>    `d' is a rigi...
09:26:27 <JoeyA> oh
09:26:38 <JoeyA> > let foo :: a -> b -> c -> (Ord x) => x -> x -> Ordering; foo _ _ _ d e = compare d e in foo () () () 3 5
09:26:38 <lambdabot>   LT
09:28:47 <cmccann> kowey, cabal-install is just smart enough to trick people into thinking it's a package manager
09:28:59 <cmccann> rather than a dependency-chasing build system
09:29:17 <kowey> :-)
09:29:39 <cmccann> it's an easy mistake to make, especially for a linux user
09:29:59 <cmccann> using cabal-install feels a lot like using apt or whatever
09:30:05 <cmccann> but it isn't the same
09:30:09 <cmccann> not even up to isomorphism
09:30:52 <kowey> cmccann: I'm aware that I don't understand the issue (only that the problem cabal-install has to take on is actually absurdly hard)
09:31:44 <cmccann> kowey, it's the difference between cabal-install doing its best to build a package vs. being responsible for the entire set of installed packages being consistent and working
09:32:05 <kowey> whatever the situation, this 2012 Haskell developer is using cabal-install (plus cabal-dev) to manage packages used by his software
09:32:24 <kowey> now the answer may well be “don't do that; use a proper package manager instead”
09:32:50 <cmccann> that's the answer if you can find a package manager with sufficiently up-to-date repos
09:33:06 <kowey> but I suspect it's not a gap that's going to be filled any time soon, and that we'll be seeing 2014 Haskell developers using cabal-install and cabal-dev as package managers too
09:33:13 <cmccann> or can automatically convert cabal packages to work with the package manager
09:33:24 <kowey> hmm, any recommendations for silly Mac users like me?
09:33:56 <kowey> (the other thing we have to contend with is the existence of bleeding edge packages, eg. my local test version of cabal-macosx)
09:33:59 <cmccann> I think building a proper package manager on top of cabal-install is reasonable, but nobody's done it yet that I know of
09:34:14 <quicksilver> what actual probelm do you have kowey?
09:34:36 <kowey> quicksilver: oh, it's something that I resolved by now, but I could tell the story if you want that made the thought bubble up
09:34:38 <quicksilver> is the solution "rm -r .ghc; rm -r .cabal;" then start again
09:34:39 <cmccann> yeah, one major problem is that haskell developers are used to working on the bleeding edge as standard
09:35:03 <quicksilver> I read up a bit, it was the old reinstall global package thing, right
09:35:10 <cmccann> quicksilver, I think kowey's current problem is just that having the previous problem shouldn't have occured :P
09:35:23 <kowey> quicksilver: basically the surface end of the problem is you have me in the pub, wanting to to show my program to my friend
09:35:50 <kowey> quicksilver: so I type “cabal-dev install” and then mysteriously it starts going off and fetching a bunch of things like MissingH and process, basic stuff
09:35:55 <killy_> hello everyone
09:35:59 <kowey> and basically nothing works
09:36:18 <ski> hello killy_
09:36:29 <kowey> quicksilver: it turns out that a week ago for a completely separate reason, I'd cabal-dev install'ed old-locale (which I shouldn't have)
09:37:01 <kowey> HP has old-locale-N, and now I have old-locale-M, and this lead to the mysterious "huh, wut?"
09:37:29 <kowey> so my thinking is that maybe it would be useful to by default treat packages in the global DB (ie. what comes with HP) as somehow a bit holier
09:37:58 <kowey> and to detect that installing a new version of a global package like old-locale is probably not what the user really meant to do
09:38:19 <monochrom> cabal-install is an upgrade whore
09:38:25 <killy_> > Map.insert 5 100 $ Map.singleton 5 9
09:38:26 <lambdabot>   Not in scope: `Map.insert'Not in scope: `Map.singleton'
09:38:37 <killy_> \> Map.insert 5 100 $ Map.singleton 5 9
09:38:42 <killy_>  > Map.insert 5 100 $ Map.singleton 5 9
09:38:42 <kowey> because really, the user is likely focused on stuff in their ~/.cabal or their cabal-dev, and any attempt to re-install something like old-locale or random is probably just an whoopsie
09:39:42 <ski> > M.insert 5 100 $ M.singleton 5 9  -- it's `M' in lambdabot
09:39:43 <lambdabot>   fromList [(5,100)]
09:39:44 <quicksilver> kowey: I think dcoutts__ has some general plans along those lines
09:40:12 <killy_> ski: thanks
09:40:30 <kowey> that'd be cool! not demanding greater smarts  so much as suggesting a UI tweak that would benefit users like me who are prone to putting bullets in their feet
09:40:39 <killy_> but why doesn't it return [(5.100),(5,9)]??
09:40:41 <ski> (also i'd not use `$' there .. ymmv)
09:40:44 * kowey limps off
09:41:08 <ski> killy_ : it's a map, each key maps to at most one value
09:41:15 <killy_> argh......
09:41:46 <killy_> for 10 minutes I was trying to figure out why I can't add element to a map...
09:44:27 <ski> <someone> i think the thing will haskell is to make sure you dont make mistakes as you go along
09:46:04 <mm_freak_> is there a nice tutorial on how to develop in C+haskell?
09:47:12 <cmccann> mm_freak_, as in "lots of FFI shenanigans"?
09:47:33 <mm_freak_> cmccann: ?
09:47:55 <cmccann> asking about what "C+haskell" means
09:48:04 <mm_freak_> FFI, yes
09:48:09 <mm_freak_> i'd like to write some parts of my program in C
09:48:18 <cmccann> I don't know of any tutorials
09:48:28 <cmccann> but to be honest when I've looked at it everything seemed very straightforward
09:48:40 <mm_freak_> well, it's not about the FFI itself, but mainly about how to make this work nicely with cabal
09:48:53 <cmccann> ohhhh
09:49:03 <mm_freak_> i guess i'll just read existing code
09:49:07 <cmccann> well on Windows the answer is probably "prayer"
09:49:15 <mm_freak_> hehe
09:49:18 <cmccann> and hope for divine intervention
09:49:28 * kowey has a Haskell DLL on Windows if it helps
09:49:30 <mm_freak_> honestly i don't care about windows for this particular application
09:49:37 <kowey> not that I know what I'm doing
09:49:37 <c_wraith> mm_freak_: So far as I know, the only real resource is "look at existing packages"
09:49:47 <luite> oh you can include C files: https://github.com/luite/hfsevents/blob/master/hfsevents.cabal for example
09:50:06 <mm_freak_> alright, i'll give it a shot later
09:50:08 <mm_freak_> thanks people
09:50:09 <luite> based on the Cocoa framework, and it automatically compiles the files listed under C-sources
09:50:17 <Taneb> darcs has got stuck?
09:50:28 <kowey> Taneb: anything I can help with?
09:50:41 <Taneb> It's been on "Copying pristine 3/16 : COPYING.GPLv3" for ages
09:50:44 <kowey> maybe in #darcs if it's not a quick question
09:51:00 <mm_freak_> wow, that seems incredibly straightforward
09:51:05 <mm_freak_> i love cabal =)
09:51:51 <kowey> Taneb: hmm, not sure what could be going on there, maybe try again and if it's still stuck add --debug --debug-verbose --debug-http
09:52:04 <kowey> is it over http or ssh?
09:52:13 <Taneb> Default?
09:52:32 <kowey> either way, that should cover enough debug ground
09:52:37 <kowey> Taneb: beg your pardon?
09:52:53 <Taneb> It's the default. I just went sudo apt-get install darcs
09:53:03 <Taneb> Then darcs get --lazy http://code.haskell.org/gtk2hs/
09:53:06 <freakazoid> Hmm, do I not want ghc 7.4?
09:53:15 <kowey> ah I see, so you're trying to fetch over http
09:53:28 <kowey> let me try that
09:54:05 <Taneb> It seems to have worked
09:54:14 <kowey> Taneb: it works for me, I'm afraid
09:54:26 <Taneb> I ctrl-c'd and it worked?
09:54:45 <Taneb> So now I've got gtk2hs
09:54:53 <Taneb> Where do I put it so it works?
09:55:19 <Taneb> Or what do I do with it?
09:55:55 <kowey> hmm, 37s to fetch that repo with --no-cache, and 2s to fetch it a second time with the cache
09:56:12 <dmwit> Taneb: cd gtk2hs && ./bootstrap.sh
09:56:32 <kowey> Taneb: it sounds like you may be interested in the install instructions at http://www.haskell.org/haskellwiki/Gtk2Hs
09:56:43 <kowey> Click on either Windows, Linux or Mac
09:56:54 <dmwit> Taneb: (The latter should *not* be done as root.)
09:57:07 <thalll> is it possible in a function that takes x :: m a -> l a, where m and l is an instance of Monad? ie extract the value in m and put in l
09:57:24 <dmwit> kowey: The install instructions are for stable releases. If he wants to use darcs, bootstrap.sh is what he needs.
09:57:27 <mauke> thalll: for arbitrary monads? no
09:57:33 <dmwit> Taneb: (That last sentence was also aimed at you.)
09:57:35 <Taneb> bash: ./bootstrap.sh: Permission denied
09:57:47 <dmwit> Taneb: chmod +x bootstrap.sh or source bootstrap.sh, your pick
09:57:54 <kowey> dmwit: oh right, Taneb : also do you actually want to use a bleeding edge gtk2hs?
09:58:05 <mauke> "source"? wtf
09:58:14 <kowey> or do you just want gtk2hs working on your machine?
09:58:14 <thalll> mauke: in my case its from IO a, to a my own defined monad
09:58:15 <Taneb> I don't really care. I want one that works with the tutorials I can get my hands on.
09:58:30 <mauke> thalll: IO a doesn't contain an a so you can't extract it
09:58:32 <dmwit> mauke: shell built-in, no?
09:58:35 <mauke> dmwit: yes
09:58:39 <kowey> Taneb: ok, then have a look at those instructions above, probably the simplest route
09:58:42 <dmwit> mauke: Why "wtf" then?
09:58:53 <monochrom> almost all gtk2hs tutorials are out of date. written before an API change.
09:58:56 <mauke> dmwit: why would you use it to run a shell script?
09:59:03 <kowey> Taneb: out of curiosity, what tutorials are you looking at?
09:59:07 <thalll> hmm okej thx
09:59:41 <Taneb> kowey, haven't got any yet
09:59:42 <mauke> thalll: does your monad wrap IO?
09:59:45 <mauke> if so, see liftIO
09:59:49 <dmwit> mauke: Why wouldn't you use it to run a shell script?
09:59:58 <Taneb> Just on a long quest to install it.
09:59:59 <kowey> Taneb: if those instructions don't work, or if they are confusing for any reason, don't hesitate to mail me (eric@well-typed.com)
10:00:00 <mauke> dmwit: because it runs it in the current shell
10:00:09 <Taneb> They don't work
10:00:24 <kowey> which ones? (what platform?)
10:00:31 <hpaste> Taneb pasted “elaboration” at http://hpaste.org/64043
10:00:41 <mike-burns> sourcing a shell script is just going to dump a bunch of env vars into your life.
10:00:42 <Taneb> (Ubuntu 10.04 LTS)
10:00:45 <kowey> Taneb: I meant the instructions on the wiki
10:00:58 <mauke> dmwit: I'm not sure what the exact effects are but I wouldn't be surprised if an 'exit' in the script terminated your interactive shell
10:00:59 <thalll> mauke:  but shouldn i be able to exec IO and inject the answer to my monad?
10:01:11 <dmwit> mauke: That's a pretty good reason. =)
10:01:16 <mauke> dmwit: shell variables and current directory would persist in any case
10:01:19 <kowey> hmm, so much for that
10:01:28 <mauke> dmwit: also, 'sh script.sh' is shorter :-)
10:01:39 <mauke> thalll: no, IO can't be executed
10:01:49 <mauke> from inside Haskell, that is
10:02:04 <kowey> (making gtk2hs easier to install is a sub-goal to making ThreadScope easier to get started with, http://www.haskell.org/haskellwiki/ThreadScope_Tour )
10:02:10 <dmwit> ?tell Taneb Can you double-check that darcs really got you a repository?
10:02:10 <lambdabot> Consider it noted.
10:02:11 <thalll> ok, ty =)
10:02:47 <kowey> I wonder why Taneb assumed that he needed to get it from darcs
10:03:05 * monochrom does not understand why it is not "cabal install gtk2hs-buildtools" and "cabal install gtk".
10:03:17 <kowey> as it I wonder if there are any sorts of conditions that are increasing the probability that users make such an assumption
10:03:18 <dmwit> monochrom: It should be. On Linux, it is.
10:04:02 <monochrom> there must have been a long chain of XYZX'Y'Z' problems leading to "darcs get http...gtk2hs"
10:04:11 <dmwit> monochrom: (Well, not quite. It's also often something like <your-package-manager> install libgtk2-dev or whatever.)
10:04:33 <kowey> http://www.haskell.org/haskellwiki/Gtk2Hs/Linux
10:04:47 <dmwit> Yes, I expect that he just tried a lot of things that didn't work and hoped that the darcs version would be another thing he could try that might have a chance of fixing it.
10:05:13 <kowey> seems like part of the work may be going after and rooting out old obsolete information
10:05:14 <kowey> :-/
10:05:39 * kowey admits that he still hasn't gotten cairo working on his Mac (it's perfectly simple on 32 bit Mac, though)
10:06:20 <monochrom> this is why blogs are evil
10:06:45 <luite> kowey: hm, with macports it's not that difficult right?
10:06:50 <kowey> they give longevity to the empheral
10:07:16 <luite> building a native quartz version is apparently more difficult
10:07:17 <kowey> luite: I'm using HomeBrew (used to use MacPorts, but at the time I switched, it seemed to cause me various bits of pain with iconv)
10:07:37 <luite> oh I let ghc use the macports libiconv
10:07:46 <kowey> luite: I have a ticket somewhere in my archives, basically everything builds; it's just that cairo stuff crashes
10:07:50 <luite> seems to be ok now :)
10:07:57 <kowey> that's great to hear!
10:08:35 <monochrom> then again, readers are supposed to look at the dates and say "2008? then it's of interest to historians only"
10:09:01 <luite> ./configure --prefix=/Users/luite/haskell/ghc --with-iconv-includes=/opt/local/include --with-iconv-libraries=/opt/local/lib
10:09:05 <kowey> luite: any chance you'd be willing to try this? http://hackage.haskell.org/trac/gtk2hs/ticket/1241
10:09:06 <luite> this is how i configured ghc
10:09:41 <tromp__> :t mod
10:09:42 <lambdabot> forall a. (Integral a) => a -> a -> a
10:09:56 <luite> kowey: oh don't have gtk2hs installed, and use ghc 7.4.1, let me see if i can install it
10:10:09 <tromp__> :t genericLength
10:10:10 <kowey> (this is an X11 version, fwiw)
10:10:10 <lambdabot> forall b i. (Num i) => [b] -> i
10:10:21 <luite> ok
10:10:44 <tromp__> hmm, isn't Inegral a better constraint for i in length
10:11:14 <tromp__> i mean in genericLength?
10:11:46 <luite> kowey: one moment, trying to install this, think i need the darcs version for ghc 7.4.1
10:12:07 <cmccann> monochrom, fortunately, your page on how easily confused cabal-install is seems to be timeless
10:12:07 <kowey> luite: err, actually http://hackage.haskell.org/trac/gtk2hs/ticket/1242
10:12:15 <monochrom> hehehe!
10:12:56 <cmccann> (n.b. -- this may not actually be fortunate)
10:13:16 <monochrom> well, it saves me work, I don't have to update often :)
10:17:53 <sp_> hi
10:17:56 <Rc43> Hi, guys.
10:18:22 <Rc43> Is cabal packages directory crossplatform?
10:18:38 <Rc43> I want to store my cabal-dev sandbox in a git.
10:18:40 <rostayob> type level concatenative programming: https://github.com/rostayob/agdastuff/blob/master/Stack.hs
10:19:38 <edwardk> shachaf: it resolves for me.
10:19:51 <edwardk> preflex: xseen shachaf
10:19:52 <preflex>  shachaf was last seen on freenode/#haskell 10 hours, 13 minutes and 29 seconds ago, saying: edwardk: Is comonad.com down?
10:24:35 <luite> kowey: works fine here
10:24:43 <cmccann> rostayob, haha nice
10:25:00 <luite> kowey: but they take a long time to start the first time, since they have to start X11 first
10:25:20 <luite> I haven't bothered building a quartz gtk/cairo :)
10:25:27 <czro> Is there a way to specify, in a file, extra compiler flags for ghc to pass each time it is invoked?
10:25:51 <kowey> luite: and this is on Lion, right?
10:26:29 <luite> kowey: this is btw ghc 7.4.1 64 bit, os x 10.7.3, gtk from macports, ghc configured with the line i mentioned earlier
10:26:30 <kowey> luite: do you think you might be able to add a MacPorts section to http://www.haskell.org/haskellwiki/Gtk2Hs/Mac ?
10:26:53 <luite> uh it really is trivial, just port install gtk
10:27:02 <luite> once you get ghc running
10:27:14 <kowey> ok, why don't I just add to the “known configurations” table then
10:27:34 <kowey> this gives people a chance of recognising “ah, this *should* work, because $otherGuy has a computer just like mine”
10:27:56 <rostayob> cmccann: eheh
10:28:14 <luite> kowey: note that this is with 64 bit ghc built from source, and 64 bit macports
10:28:24 <rostayob> cmccann: https://github.com/rostayob/agdastuff/blob/master/Stack.agda much simpler in agda eheh
10:28:30 <luite> 64 bit ghc used to be experimental for os x, dunno if it still is, but it seems to work here :)
10:28:31 <freakazoid> I didn't know people still used macports - I deleted it long ago for homebrew
10:28:54 <luite> dunno, what's wrong with macports?
10:29:02 <cmccann> rostayob, I would imagine it is, heh
10:29:08 <luite> at least I have a working cairo ;p
10:29:08 <rostayob> cmccann: the only wart is the the type class, which is inevitable
10:29:12 <tazjin> It always came across as kind of unreliable when compared to homebrew, at least to me
10:29:15 <osfameron> they do rather different things
10:29:38 <kowey> luite: table updated! many thanks (do please plug in gaps if you have a moment)
10:29:44 <luite> tazjin: hm, unreliable in what way? does it break pacages?
10:29:46 <rostayob> it's pretty remarcable what you can do with enough extensions turned on
10:29:47 * osfameron is unimpressed with homebrew (but hated macports.  So homebrew wins, kinda)
10:29:53 <kowey> http://www.haskell.org/haskellwiki/Gtk2Hs/Mac
10:30:04 <rostayob> *remarkable
10:30:13 <kowey> and if any of you HomeBrew users can get a working cairo on Lion, I'd love to hear from you :-)
10:30:17 <tazjin> luite: I've experienced that, and it also completely messed up my $PATH once. I have never had any problems with homebrew
10:30:29 <cmccann> rostayob, yeah, I've done my share of it, even before the recent stuff with datakinds and all
10:31:20 <cmccann> rostayob, e.g. https://github.com/isomorphism/typewriter/blob/master/Data/Typewriter/Variadic/Natural.hs
10:31:45 <cmccann> I bet I could clean that up a lot using GHC 7.4
10:31:49 <luite> tazjin: hm ok, I've never had a problem so far, but haven't used OS X for very long... at any rate, linux is much better for haskell development :)
10:31:53 <rostayob> cmccann: I'd personally be scared of doing this kind of stuff in actual programs, and there is so much overlap between language extensions sometimes
10:32:03 <rostayob> the biggest thing being fundeps and type families
10:32:29 <cmccann> if you can isolate the scary type hackery behind a simpler API it's not unreasonable to use for real programs
10:32:40 <tazjin> luite: Why? I'm pretty much OS-agnostic as long as it's some kind of *nix system, but OS X just comes across as a lot more comfortable to me. I don't really think it matters though
10:33:03 <rostayob> cmccann: I don't know.
10:33:14 <cmccann> and I mostly just ignore fundeps these days
10:33:26 <kowey> (still hoping Nix pkg manager takes off for Mac one day, but too lazy to contribute)
10:33:38 <rostayob> cmccann: yeah but still we have to deal with them all the time and it's annoying
10:33:46 * cmccann shrugs
10:34:11 <czro> Hello, is there a way to set compile flags gloabally for ghc? env variable/file?
10:34:14 <cmccann> they're only absolutely necessary if you're abusing overlaps
10:34:46 <nyingen> no new posts on planet today? get crackin, folks
10:34:48 <rostayob> cmccann: yes, which you shouldn't
10:34:50 <cmccann> though there are some cases where fundeps are much more concise than using type families
10:35:09 <freakazoid> luite: two things: MacPorts generally assumes you use MacPorts for everything, and the homebrew formulas tend to be more up-to-date.
10:35:09 <rostayob> yeah but type families make so much more sense
10:35:10 <monochrom> depends on what compile flags
10:36:19 <czro> I need to pass flags to replace the c preprocessor with cpphs. I'm having trouble running the preprocessor after upgrading to xcode 4.3 and thought cpphs is worth a try.
10:37:09 <luite> freakazoid: is there anything other than libiconv where the first one causes problems?
10:37:09 <rostayob> czro: uff, you still haven't solved that? i'd be curious to find out what is wrong with XCode
10:37:21 <monochrom> then I only know of an entry in cabal files
10:37:27 <rostayob> since it seems to cause major breakage with quotes if i remember the error well
10:37:57 <luite> tazjin: oh in general you can assume that things just work on linux, packages often haven't been tested on os x
10:38:00 <rostayob> I guess that's what you get when the only way of installing ghc is through apple...
10:38:04 <rostayob> *gcc
10:38:35 <tazjin>  luite: Well, I never ran into any problems :-)
10:38:42 <czro> I've been sitting on an airplane the whole afternoon so I haven't been working the whole time, but this annoys me, and I'm a stubborn guy :)
10:38:51 <monochrom> ghc-options
10:39:15 <luite> tazjin: for example certificate validation won't work with tls-extra and certificate, and there were issues with newer xcode not including gcc anymore
10:39:18 <rostayob> czro: I can surely believe it annoys you....
10:39:39 <tazjin> luite: Xcode not including gcc? That's news to me ;O
10:39:53 <luite> I think 4.2 or something doesn't ship gcc anymore
10:39:57 <tazjin> luite: They also recently dropped the requirement for Xcode and you can now install the command line tools seperately
10:40:41 <czro> I think a solution may be to use cpphs... I'll tell you when I solve this.
10:40:48 <luite> tazjin: yes that's really recent though
10:41:12 <luite> but do the separate command line tools include gcc?
10:41:40 <tazjin> yeah, they do. at least on Mountain Lion (I'm running the beta on the iMac I'm using right now)
10:41:48 <luite> really? not clang instead?
10:41:59 <tazjin> replace instead by aswell
10:42:03 <tazjin> afaik
10:42:22 <czro> Isnt that just a symlink to clang?
10:43:08 <tazjin> czro: O
10:43:12 <tazjin> *I'll check after this movie
10:43:25 * hackagebot yesod-core 0.10.2 - Creation of type-safe, RESTful web applications.  http://hackage.haskell.org/package/yesod-core-0.10.2 (FelipeLessa)
10:43:27 * hackagebot yesod-form 0.4.2 - Form handling support for Yesod Web Framework  http://hackage.haskell.org/package/yesod-form-0.4.2 (FelipeLessa)
10:45:01 <freakazoid> luite: I have no idea. It's been a couple years since I last used MacPorts
10:45:41 <freakazoid> Oh, I first switched because MacPorts took forever supporting Snow Leopard
10:45:48 <freakazoid> now that I think of it.
10:47:21 <geekosaur> there is a "gcc" in xcode 4.2.  the problem is it's actually llvm-gcc-4.2
10:47:45 <geekosaur> which breaks a number of things (including ghc)
10:51:48 <ozgura> ghc error message: "My brain just exploded. I can't handle pattern bindings for existential or GADT data constructors. Instead, use a case-expression, or do-notation, to unpack the constructor."
10:52:24 <ski> ozgura : yes ?
10:52:53 <ozgura> just saying.
10:53:13 <ozgura> I find this one fun, and descriptive at the same time.
10:53:20 <ski> ok
10:53:23 <ski> @ghc
10:53:23 <lambdabot> ghc says: You need -fglasgow-exts to derive an instance for this class
10:53:32 <WarzoneCommand> hmm qeustion. I want to write a `safe' version of readFile, i.e. it should return something of IO (Maybe STring) if *anything* went wrong it should just return Nothing, and otherwise 'Just content'. I now have: http://hpaste.org/64046 but that still seems to throw an exception if something went wrong
10:53:44 <WarzoneCommand> (in particular, if I feed it a binary file)
10:54:48 <ski> `readFile' uses lazy I/O
10:55:03 <c_wraith> WarzoneCommand: readFile is lazy.  That catch will rarely do anything
10:55:54 <WarzoneCommand> what would be the best way of doing something like this then?
10:56:45 <WarzoneCommand> also keeping in mind that I don't really want to load the entire file into memory first
10:56:52 <WarzoneCommand> or would that be impossible?
10:57:38 <c_wraith> If you don't load the whole file, how will you know if the whole thing decodes properly?
10:58:06 <WarzoneCommand> hmm true
10:58:16 <WarzoneCommand> would it be possible if you would only look at the first line?
10:58:32 <c_wraith> it wouldn't be foolproof
10:58:41 <c_wraith> it might work pretty well as a heuristic
11:05:02 <pcavs> Is there some example code for implementing resource pools in Haskell?
11:06:57 <preyalone> How do you compute an orthogonal basis of a matrix using hmatrix?
11:08:34 <monochrom> Gram-Schmidt?
11:13:07 <hpaste> killy_ pasted “Floating not Ordered?” at http://hpaste.org/64047
11:13:29 <killy_> why do I have to add 'Ord l' in the function type?
11:13:44 <killy_> aren't Floating variables Ordered?
11:14:29 <ski> @instances-importing Data.Complex Floating
11:14:29 <lambdabot> Complex a, Double, Float
11:14:44 <ski> `Complex Double' is in `Floating', but not in `Ord'
11:14:52 <monochrom> no, Floating does not imply Ord
11:14:57 <killy_> why so?
11:15:08 <killy_> doesn't seem logical...
11:15:09 <ski> because complex numbers don't have a natural ordering
11:15:15 <monochrom> I don't know. that's how the standard library sets it up
11:15:49 <killy_> I guess Complex numbers shouldn't classify as Floating numbers, only vice versa
11:15:49 <monochrom> FWIW, you could argue day and night on why Num implies Show
11:16:56 <ski> that doesn't make sense
11:18:24 <killy_> Complex numbers are a superset of Floating numbers, right?
11:19:03 <monochrom> http://www.haskell.org/onlinereport/haskell2010/haskellch6.html#x13-1350006.4
11:20:07 <ski> "The `Num' class no longer has `Eq' or `Show' superclasses." <http://www.haskell.org/ghc/docs/7.4.1/html/users_guide/release-7-4-1.html>
11:20:21 <mhitza> is there a better way than this to simulate futures in haskell ? http://vis.renci.org/jeff/2009/01/17/simple-futures-in-haskell/
11:20:37 <ski> killy_ : `Floating' is a type class, `Complex' is a type. they aren't directly comparable in that way
11:22:45 <monochrom> par and pseq are the future, if you aren't doing IO-specific things to begin with
11:23:25 <mhitza> monochrom, they are IO specific (web requests)
11:23:37 <ski> maybe int-e's
11:23:38 <ski> @hackage ivar-simple
11:23:38 <lambdabot> http://hackage.haskell.org/package/ivar-simple
11:23:39 <ski> ?
11:23:48 <monochrom> then MVar is already as good as it gets
11:23:56 <ski> mhitza ^
11:24:06 * ski hasn't tried it
11:24:12 <mhitza> ok, ski looking over that
11:24:49 <preyalone> monochrom: They say use Numeric.LinearAlgebra.Algorithms.qr, but I don't know how to write orth in terms of qr.
11:26:03 <monochrom> strange, you ask me about what they say. do you also ask them what I say?
11:27:04 <rribeiro> Hello all! I'm looking for some advice on a problem: I'm implementing an algorithm for a rewriting system. The rewrite will be executed until I've reached a fix point. My question is: There's a efficient way to check if I've reached a fixpoint without testing the equality?
11:27:59 <preyalone> monochrom: Gram-Schmidt isn't implemented for hmatrix data structures. qr and svd are, but I'm not sure how to use them to do MATLAB's orth().
11:28:05 <opqdonut> well if no rule was applied then you have a fixpoint
11:28:48 <mee> “fish”
11:28:50 <mee> oops
11:30:11 <srhb> preyalone: What are you trying to do?
11:30:34 <edwardk> preflex: xseen shachaf
11:30:34 <preflex>  shachaf was last seen on freenode/#haskell 11 hours, 24 minutes and 11 seconds ago, saying: edwardk: Is comonad.com down?
11:31:10 <preyalone> srhb: Do heavy duty matrix manipulations that require an orthogonal basis. I'm not sure how to get one.
11:31:21 <srhb> preyalone: Gram schmidt normalize?
11:32:15 <ski> rribeiro : probably depends on the data and the nature of the rewriting
11:32:28 <hpaste> killy_ pasted “Error message” at http://hpaste.org/64048
11:32:47 <srhb> @hoogle gramSchmidtNormalize
11:32:48 <lambdabot> No results found
11:32:51 <killy_> ok, could someone teach me how to interpret ghc error messages?
11:32:51 <srhb> Hm,
11:32:53 <edwardk> preyalone: isn't matlab's orth built using svd?
11:33:10 <rostayob> what are the rules for PolyKinds? I mean I know it works for 'data Proxy t = Proxy', but can it work for more complex data types?
11:33:12 <rribeiro> ski: The problem is that a simple equality test will be onerous
11:33:27 <rostayob> for example, I have:
11:33:29 <rostayob> data FoldN (n :: Nat) ty (tys1 :: [*]) (tys2 :: [*]) where
11:33:31 <rostayob>     FBase   :: FoldN zero ty tys tys
11:33:33 <rostayob>     FInduct :: FoldN n ty tys1 tys2 -> FoldN (Suc n) ty (ty ': tys1) tys2
11:33:35 <rostayob> can the 'ty' be made polymorphic?
11:33:49 <edwardk> or at least used to be. i'm a dinosaur in matlab
11:33:56 <rribeiro> ski: The state of the rewriting system is formed by a Data.Map plus a list
11:34:30 <edwardk> rostayob: the rules seem to be that type families monomorphize their result, and you can't currently talk about polymorphic kinds explicitly as their is no syntax for them
11:34:35 <edwardk> but you can talk about them obliquely
11:35:05 <edwardk> rostayob: and since you can't talk about them, you can't make GADTs where different branches have different kinds
11:35:30 <rostayob> edwardk: but I'm not doing that
11:35:40 <DanBurton> killy_: "could not deduce a ~ b" means just that
11:35:46 <edwardk> rostayob: i'm just mentioning the general set of limitations you have
11:36:11 <DanBurton> killy_: so you are using functions in a more specific way than the type signature was expecting
11:36:15 <rostayob> edwardk: ok, but if I'm just carrying around the kind (phantom type style), which is what I'm doing
11:36:24 <edwardk> rostayob: yes, in theory the ty there may be able to be polymorphic as long as the different constructors don't change its kind
11:36:33 <rostayob> edwardk: well that's not the case apparently :P
11:37:08 <edwardk> when one constructor uses it at a particular kind though, it gets monomorphized. i presume this is because they wanted to avoid Nothing :: Maybe Maybe type checking ;)
11:37:17 <rostayob> actually wait, in my case there are other constraits anyways
11:37:18 <killy_> DanBurton: what do you mean by 'more specific'?
11:37:28 <killy_> DanBurton: I made my type signature like this: isPrimeH :: (Integral n, Floating l, Ord l) => n -> l -> n -> Bool
11:37:36 <killy_> and this works
11:37:40 <DanBurton> killy_: right
11:37:40 <killy_> however
11:38:18 <killy_> if I make this instead: isPrimeH :: (Integral n, Floating l, Ord l, Floating c) => n -> l -> c -> Bool
11:38:24 <ski> rribeiro : each rewriting could produce a delta or a "changed" flag, which could be cheaper to check
11:38:29 <killy_> than I get the error message
11:38:35 <rostayob> edwardk: is proper kind polymorphism planned sometime?
11:38:43 <edwardk> yeah
11:38:48 <killy_> um.. replace the second 'Floating' with 'Integral'
11:39:06 <rostayob> edwardk: fun times ahead.
11:39:08 <monochrom> then the type sig says c and l could be different types, but your code requires c and l to be the same type. contradiction
11:39:10 <DanBurton> killy_: yes that's right. Because with the more general signature, the type checker cannot prove that "n" is the same as "c"
11:39:19 <edwardk> i bounced emails back and forth with byorgey/spj a while back showing them where the current lack of syntax for polymorphic kinds was crippling me
11:39:42 <edwardk> they'd already planned on it. it seems its just a small matter of implementation effort
11:39:43 <rribeiro> ski: yeah... you're right. I believe that a flag or a delta could work...
11:39:51 <DanBurton> killy_: when you use "n `div` c", "div" needs to know that n and c have the same type
11:40:08 <DanBurton> @type div
11:40:08 <lambdabot> forall a. (Integral a) => a -> a -> a
11:40:12 <edwardk> i have to admit I'm somewhat sad though, since there is a kind-index type family that I really want that I can't write perfectly
11:40:13 <rostayob> edwardk: yeah what I'd really like to write is something like [k], where k is a kind
11:40:15 <rostayob> and stuff like that
11:40:20 <edwardk> (even when they do get around to adding what they've proposed)
11:40:25 <killy_> ahh...
11:40:27 <edwardk> sure
11:40:30 <rostayob> edwardk: I still think that while this is fun and all
11:40:43 <DanBurton> killy_: if you want it to accept different types, then you'll need lots more "fromIntegral"
11:40:46 <rostayob> it's starting to get awkward
11:40:51 <killy_> so `div` needs to know that both params are Int or both Integer, but not mixed?
11:40:56 <rostayob> edwardk: and I'd rather use agda for this stuff :)
11:41:00 <ski> killy_ : yes
11:41:01 <DanBurton> killy_: correct
11:41:07 <edwardk> rostayob: i'd rather have users ;)
11:41:20 <DanBurton> this is a weird thing about Haskell that often bites newcomers
11:41:33 <rostayob> edwardk: you don't *need* those things at the type level to write software
11:41:36 <DanBurton> but it makes sense once you get a handle on Haskell's type system
11:41:37 <edwardk> and i don't want to discourage their attempts to grow in this area
11:41:38 <killy_> boy... that wasn't obvious
11:41:54 <monochrom> not weird IMO. same story with C++ to begin with.
11:42:12 <edwardk> rostayob: sure. i also spent much of my childhood banging out 6502 assembly by hand. Doesn't mean I want to do that any more.
11:42:15 <rostayob> edwardk: yeah but it really feels like I'm trying to make the hippo dance when trying to do this stuff with haskell
11:42:27 <rostayob> edwardk: I think that's an unfair analogy
11:42:36 <rostayob> the "assembly" argument is overused
11:42:47 <edwardk> I didn't say I was being fair =)
11:42:54 * DanBurton can't really argue with "I'd rather use Agda" xD
11:43:09 <monochrom> the assembly argument is overused. lately I use the connect-a-thousand-vacuum-tubes argument
11:43:35 <rostayob> I think that Haskell gives a reasonable amount of expressiveness at the type level for real world software, but types are so much fun :)
11:43:40 <edwardk> But, I do think the blub paradox is hard at work here. We're used to Haskell as it is, so its hardto see how much better it could be when Typeable doesn't suck, when we can have nicer liebnizian equality witnesses, when I can make a category for composing constraints, etc.
11:44:18 <edwardk> and that in general those constructs may be hard/awkward to write, but can be a lot nicer to use than specifying one-off versions of functor whenever i need a different kind, etc.
11:44:31 <edwardk> I wrote 8 versions of functor or so in category-extras
11:44:36 <rostayob> edwardk: I'd have thought that you need proper dependent types for liebnizian equality witnesses
11:44:39 <edwardk> I'm looking forward to going back down to 2.
11:44:44 <ski> hehe
11:45:07 <rostayob> edwardk: I mean the identity type family in type theory is dependent on values
11:45:13 <edwardk> we have the benefit that we don't need full J, since the kind level is so simple
11:45:14 <rostayob> how would you insert that feature in haskell?
11:45:37 <rostayob> wait how is it useful without elimination?
11:45:40 <rostayob> anyways I really need to go
11:46:03 <edwardk> The code I have in 'eq' cleans up a lot with polykinds
11:47:07 <mhitza> can somebody tell me how do I pattern match the wget exception? http://hackage.haskell.org/packages/archive/http-wget/0.6.2.3/doc/html/Network-HTTP-Wget.html
11:48:21 <rostayob> edwardk: wait, you mean leibnizian equality on types?
11:48:30 * hackagebot lambda-ast 0.0.1 - Untyped Lambda Calculus Abstract Syntax Tree  http://hackage.haskell.org/package/lambda-ast-0.0.1 (JonathanFischoff)
11:48:35 <rostayob> I really don't see how you can have it on values in haskell
11:48:37 <edwardk> yes
11:48:40 <rostayob> oh, ok
11:48:47 <Lemmih> mhitza: action `catch` \(WgetException str) -> ...
11:49:05 <Lemmih> mhitza: Using 'catch' from Control.Exception.
11:49:13 <rostayob> edwardk: I guess that would be kind of useful
11:49:13 <mhitza> Lemmih thanks :)
11:49:16 <rostayob> gotta go
11:49:24 <edwardk> newtype a :== b = Eq (forall p. p a -> p b)
11:49:29 <edwardk> works regardless of the kinds of a and b
11:49:42 <edwardk> later
11:49:55 <regaman> Does anyone wear diapers
11:50:00 <regaman> You stupid "Diarrhea of the mouth" nuck.  Up with shmit on black ass brown  Hackel meal McJellicker.  Harky Mc Jallillashter.  Smuggin Mah Hellihole.  Harb amin mon mif jalellamon brooms of mushkin boy a munchkin maggity von heffrin.  Shtooty mic blackened.  Shooty hick black and flubberdy bij ass rijjal.
11:50:01 <regaman> Shniggen munuh lik leggal  perritolma penis pran chella  maloney day breeze  Paahster jam ban wikkle.   Hella mah lun mick hella malole.  Hella minull mic mella manoh.  The roadline, it's illegal.  Trully mulla mih nole.  I'm a relladge-o-melladge-o-ram.  Come on you fuckin dag asses.
11:50:02 <regaman> Damned ram bastions.  McJellio oper Smelly gruthergrarin trilaxals.  withers ground ring air  Puggle dee maggle dee mack traggle  Jeremy sniggle. Jeremy spoken, in next day  I brusht boyered, I kicked a ball!  mellaminorf  troll protectors, trolls on the road!  troll protectors, their stones of power glow!
11:50:03 <regaman> Fleeberty dith bub, a hick now a hither they humpty tance Hunchell munch a reg uhl schoolio tress nael Chuck a lick a loon baby tunes Weerz mellicorp To the wack ann watching machine wells darilla raptor plexing
11:50:04 <regaman> Shligga ligga millik hole Shligga ligga millik hole regamakio mathjul hah there Just like in Bart Simpson the Magazine! Ban ricky ban glicky jallo whip! menario mibs Pahorp pahilla thin meffrin slujjal jeggy moran magomorph baleener
11:50:06 <regaman> I spell it throwt, you spell it throat, the real way to spell it is throwt throwt THROWT!  Hux a mex a lig dwarf  dudikolan mail street.  Rella manae, Rella Manae, Rye dut duh!  I'm living on budgy placky street.  Reggal dee deck shweener  Hicker trellalicker
11:50:07 <regaman> What part of that doesn't make sense to you robo  I'm rang dang smacking it up to the reck a heek a horn drom.  Rag agg big chacka lo datey fifty.  Sniggital maggal  Shelly a jelly a jew lillaputan meglamarian necks booga man  Rejja mella mic jeggal  Baika looka reg tag
11:50:08 <regaman> Throat a pelly proat raick axe.  It doesn't eat muggo whip.  It's a piece of paiper.  Scrubbity ass ragamahoun.  Raggity ass maga muffin.  Where's songy brother?  Where's spongy brother?  Jellanie mic flyer.  Paloody pluck bag ack.  Paloody pluck bag ack.
11:50:09 <regaman> Whyn you call it throat throwt.  I'm a baffy hoe.  Flivvy a niv von neffran.  Purity and prudence  I'm suing for diaper damage.  Scragg a billy blunk rake  rast eye heeker, playmus guy  I don't know what a rubbity dabby is.  Scrunny maloo lef heel hole.  Scrunny maloo lef heel hole.
11:50:10 <regaman> Arthie shlellijge.  Arthie shlellidge.  Talking about a bee turning into a guano root.  today I'm doing pasta, i crumble it and pan fry it.  Fuckin frosty.  david hippa lappa pomprin.  Is anyone here a hemp hole?  Yeah, well shnijjy mc millicker: i know billy knalavolitz.
11:50:14 <regaman> The Baby Faced Assassin pond.  yrummin!   Shmega melanie goetz  I'm smacking it up to the electrify beam, smacking it to the galactify beam!  Smackin the penis with the erectify beam!  When will another green skroan the horrified scream
11:50:14 <regaman> Rubbity dag daggy dib dib, daggy daggy dib dib, daggy daggy diggy diggy dib, throwt a welly wheel wall  Reppity shcrep bam bam rep rep paranep  Shnubbity shnib up bam bam  Givin' me twice, i a molst a meeka pleck. Givin' me twice, a molst a meeka pleck.
11:50:15 <regaman> Jeminee smucking smiggle.  Halittle halorst hamerrian sects nep tep hotep gargle dee gook mackie mchellic hole.  My niqqer dee dag sparky.  Ponto comical blessnor I'm dain dead.  Razor renzor manellik s-meg smeg you're all smegs.  We're hovvy hella pruss miss puss  Smelly mudga munaqqal  Posta wicka holma melancholy laggam
11:50:16 <regaman> Shmelly a mellac.  Cloaky active camoflauge mail bow  Warez into a whoop coup daddy deam, I filed a lawsuit with G.L.E.A.M.  Dag a ricka bleg nagg.  Richel reprezhnik rally mic hoe whip.
11:50:16 <regaman> fucking ass licking piss sucking cunt.  Threnthie oh pod throonis Tragallellah.  bweeey eeeiw!  bweeeeey ail!  shnib polmans mahhal wourney  Track a mix a meg norge
11:50:18 <regaman> Flathican fellow street.  Mc Grellae Mc Regegg.  Prag a cuckian bag of gunk.  Duh nuh nihh nuh farty milligers.  Par boockalie twistie taiter.  Tittly spoof bee  Trellie oh dabble  Antenna rethal  Fucky daddy dicky  Fucky daddy dicky
11:50:29 <regaman> Chucka lucka ling to the chucka looka lat, man can't be banned! Dee oh doing!  Chili box sand reggat. Crackity raggity ann  shaggy rab rabble  smiley oh diley oh reggal na meck transhole  In a tough manner  pung dungh chicka licka bang dad.  Guess what you smartie millickan jallefnaord.  Spend rellik maholmes.
11:50:31 <regaman> Rudda boom boom dugging.  My name is jameel my name's jamaan.  Take this you fuckin' brack stab from buck hole.  Brag a cuck of bintorns.  I had to have jalooch to have breakfast. Trug a leck leg hole.  Tellah mef raf.  Trukkle trella lickle mazzle trag.  Shab shab skrellix magellix
11:50:31 <regaman> Roonah bucky blay lee!  Roonah bucky blay lee!  An aggle dee dak beyond the premier.  switch up to a wedge pluckie  A jecka looch reft round!  poochin maleggal  Drek a lek meek foamie.  shlick a jig jeffjob  A jella jitch manifest  Horkin malurgis hoarde.  prebelally mobijowrist.
11:50:33 <regaman> Fartily gas farts on someone's jacket.  Hicka low daggal.  Manil hill the jiller.  Reet dih doo deh dih, reet deh doo duh.  dendridic millimorph cardackio cleptio maggle  Jackintoshy zillword.  Just another macgasm trexie o mario bubble.  I had to have a mummified wheat bread.
11:50:33 <regaman> Slaggy McNelly O-Loop.  Hillie Millie. Mijujik calej loft, shweener screlly mellamanorf.  The plux to the plack a leak a lithio meth  galactical terrial tuesday.  Ploody loon, back a toon!  ron ton a jelly a shawn.  Herd mah thuh fah thuh.  Jeggal mig ella cracker.  trellamanorf mick hick hole
11:50:34 --- mode: ChanServ set +o monochrom
11:50:34 <regaman> Rump tump tiddle doo, rump dump damn.  Farbooky twistie taiter. Farbooky twistie oh plox.  jickellastrip shtiffy  Trellie oh dabble  Sabba7kom allah bilkhair ya rawafeth 3ash men shafek.  3alaikom essalam mawlana.  9eqeleyya kaanat men madresat Averroes.  plan dan duckalin jee uhst waistband
11:50:35 <regaman> Sparra kitha mellon hoh snail bookanees.  Pucka hoonkin dick ass waste.  Triclapian transcripts.  Are you a jalellaputian?  Arthie midge millik.  See that is why I keep going "galactico trallie o-reggal"  Cuckin twanbastin wigwams shmagga miggal smell-it syllabalistic macro.  Oh-rellage oh ram
11:50:37 <regaman> Trellik mic jelliger.  Throwty a pellage plex.  Spigga McGregor  peggly oh dabble  Hicky trellalick.  You stupid pudgy fucker.  Sneqqal segagal.  Purital laggy oh baggal.  Bucka broon broom shella muluk mic niqqer.  Rooshta shpella.  Plocky of pleckal bag a cuck of frin torns
11:50:39 <regaman> Wa Alikum salam wa rehmatullah e wa barakat.  Tarka dellalie dool.  Mig iff raheg hord.  Raga nahoolie jeg narf.  Hellage rellage o-ram well to do it pollis  Scribble dee babble.  Mezzle ma norf.  Praggity no maddak  Duck a ween wark.  You shpuffy shpook ma leggin don't be such a terrorisdt.
11:50:39 --- mode: monochrom set +b *!*@190.99.71.254
11:50:39 --- kick: regaman was kicked by monochrom (regaman)
11:50:58 <monochrom> that killed the conversation :)
11:51:38 <mysticc> @hoogle hflush
11:51:38 <lambdabot> System.IO hFlush :: Handle -> IO ()
11:51:39 <lambdabot> GHC.IO.Handle hFlush :: Handle -> IO ()
11:51:39 <lambdabot> GHC.IO.Handle hFlushAll :: Handle -> IO ()
11:51:47 <ski> @index hFlush
11:51:48 <lambdabot> System.IO
11:51:53 <shachaf> edwardk: It works for me now.
11:52:01 <edwardk> shachaf: sweet
11:54:00 <scooty-puff> this probably isn't the right place to ask this, but since not p \/ q is the same as p -> q, why does the latter exist?
11:54:26 <ski> scooty-puff : it's not the same in intuitionistic logic
11:54:33 <monochrom> because -> is useful
11:54:50 <scooty-puff> and if i were working on a simple constraint solver, would it be safe to let p -> q imply that i can say whatever vars in p must be solved before, or at the same time, as q
11:56:23 * ski isn't sure why one would decide that
11:56:41 <hpaste> killy_ pasted “checking a prime” at http://hpaste.org/64050
11:57:02 <ski> scooty-puff : what kind of constraint solving are you doing ?
11:57:17 <Botje> scooty-puff: I've used -> twice in ten years of programming so far.
11:57:22 <killy_> so, I wrote a simple function checking if a number is a prime
11:57:35 <killy_> but somehow I feel that this could be done a bit better
11:57:40 <Botje> scooty-puff: last time I had a list of constraints to check, but a couple of constraints only needed to be checked if other constraints needed to be checked
11:57:44 <ski> killy_ : instead of `isPrime n | n == 1 = False', do `isPrime 1 = False', &c.
11:57:47 <mysticc> @hoogle flush
11:57:47 <lambdabot> Data.Text.Lazy.Builder flush :: Builder
11:57:48 <lambdabot> Graphics.Rendering.OpenGL.GL.FlushFinish flush :: IO ()
11:57:48 <lambdabot> GHC.IO.BufferedIO flushWriteBuffer :: BufferedIO dev => dev -> Buffer Word8 -> IO (Buffer Word8)
11:58:02 <killy_> ski: is that a more idiomatic approach?
11:58:06 <ski> yes
11:58:12 <mysticc> @hoogle mflush
11:58:12 <lambdabot> No results found
11:58:25 <killy_> I mean I used to do this in Prolog
11:58:27 <ski> killy_ : you'll need a guard for the `rem' anyway, of course
11:58:29 <Botje> and [ ..., inRange (bottom,top) x+1 -> x < x+1, ... ]
11:58:37 <Botje> except I called it ==>
11:59:11 <killy_> sky: but this doesn't make code any faster, right?
11:59:12 <ski> killy_ : well, in Prolog you'd probably do `is_prime(1).' as well
11:59:13 <monochrom> in fact, Hilbert did the opposite. he was like, since (x -> false) -> y is the same as x \/ y, why does the latter exist?
11:59:25 <ski> killy_ : yea, this was just a style thing
11:59:30 <killy_> mhm
11:59:38 * ski hasn't even read killy_'s question, yet
12:00:06 <killy_> question: how could this code be improved? :)
12:00:35 <killy_> I'm learning functional programming so I guess my way of thinking about the code is biased towards structural solutions
12:00:38 <ski> monochrom :)
12:01:23 <monochrom> it is also a great opportunity to invoke the assembly argument again
12:02:01 <monochrom> since connecting up several million vacuum tubes is the same as writing in haskell, why does the latter exist?
12:02:39 <mhitza> killy_, you can change n `rem` 2 == 0  = False with even n = False
12:03:50 <monochrom> also, pretty sure many girls in the 1950s would testify: in my 10-year programming career, I have written 0 lines of haskell
12:03:53 <killy_> mhitza: thanks, realized that after I pasted the code :)
12:04:06 <mhitza> killy_, and also remove the binding to reminder since you don't use it after that; just do a case (n `rem` c) of
12:04:50 <ski> killy_ : instead of  let reminder = n `rem` c in case reminder of 0 -> False; otherwise -> isPrimeH n l (c+2)  , i'd do  n `rem` c /= 0 && isPrimeH n l (c+2)
12:05:19 <ski> (also i'd s/(Integral a) => /Integral a => /. that's just me)
12:05:51 <ski> killy_ : also, i would consider making `isPrimeH' a local function to `isPrime'
12:06:03 <killy_> you mean not exporting it?
12:06:07 <monochrom> if you have used ==> only twice in your lifetime, it is because you use selection bias to ensure a self-fulfilling prophecy
12:06:17 <ski> killy_ : i mean putting it in a `where' inside `isPrime'
12:06:26 <killy_> mhm
12:06:51 <ski> killy_ : if you do that, then you can avoid carrying around `n' and `l' in arguments
12:06:56 <killy_> doesn't this make the code less readible
12:07:03 <killy_> ?
12:07:30 <ski> why ?
12:07:47 <ski> (btw, if you want to keep the intermediate name `reminder', that's fine)
12:09:33 <killy_> ski: because there's a lot of nested code
12:09:34 <ski> killy_ : imo, carrying around `n' and `l' just amounts to clutter, obscuring the meat of the code
12:09:41 <Algorith> often, reducing variables increases readability. That goes for imperative code as well, it's a common refactoring thing, though you usually have to strike a balance somewhere
12:10:13 <monochrom> there is a high dose of subjectivity in "readable"
12:10:51 <monochrom> "f (g (h x))" FPers say readable, IPers say unreadable
12:11:04 <Algorith> well, I'd say it's less subjective in imperative languages
12:11:10 <killy_> ok, I'll try to change this, not sure about the syntax though...
12:11:22 <monochrom> "x1 = h x; x2 = g x1; f x2" FPers say unreadable, IPers say readable
12:11:50 <ski> (and i don't think nested code is in itself bad -- it can become a problem if you have a hard time seeing which level binds a certain variable -- but passing around a lot of "context parameters" also makes things harder to read)
12:11:59 <Algorith> readability in haskell is more linked to familiarity with the syntax
12:12:15 <monochrom> my cut is to say, screw readability, the point of fortran is to let you write "f (g (h x))" without defining intermediate names
12:12:37 <mauke> python disagrees~
12:12:54 <ski> killy_ : you know `where' ?
12:13:11 <Rc43> When I should use `type` and `data`?
12:13:14 <monochrom> http://groups.google.com/group/comp.lang.functional/msg/17520bdd236b3351
12:13:15 <DanBurton> s/Fortran/Forth ?
12:13:21 <ski> killy_ : btw, the `otherwise' in the `case' doesn't work like `otherwise' in a guard, i hope you're aware of that
12:13:26 <mauke> Rc43: when you need them :-)
12:13:27 <ski> DanBurton : no ?
12:13:33 <killy_> yes, I know where
12:13:49 <killy_> sky: nope, I'm not...
12:13:53 <Rc43> mauke, when I need `type` and when I need `data`? :)
12:13:56 <monochrom> absolutely fortran
12:14:09 <ski> Rc43 : `data' (or `newtype') when you need a new type, `type' when you just need to give a name to an existing type
12:14:11 <mauke> Rc43: you should use 'type' when you need to declare a new name for an existing type
12:14:19 <mauke> Rc43: you should use 'data' when you need to create a new type
12:14:35 <Rc43> mauke, but all type are tuples for example
12:14:40 <mauke> huh?
12:15:04 <monochrom> all types are not just tuples
12:15:12 <ski> killy_ : `otherwise' is just a name for `False
12:15:13 <ski> '
12:15:14 <Rc43> mauke, oh, yeah, data can have multiple constructors
12:15:16 <ski> @src otherwise
12:15:16 <lambdabot> otherwise = True
12:15:26 <monochrom> that's false :)
12:15:31 <mauke> @src Bool
12:15:32 <lambdabot> data Bool = False | True deriving (Eq, Ord)
12:15:39 <mauke> can't do that with tuples
12:15:40 <ski> killy_ : saying `foo x | ... = ... | otherwise = ...' is the same as saying `foo x | ... = ... | False = ...'
12:15:44 <mhitza> how readable is this code for you guys http://hpaste.org/64051 ? And what would you improve?
12:15:59 <Rc43> mauke, yeah, I see
12:16:01 <killy_> so totaly the oposite of otherwise in a guard
12:16:16 <shachaf> ski: I think you mean True.
12:16:22 <ski> killy_ : otoh in `case ... of ...; otherwise -> ...' you are binding the result of the scrutinee to a new (local) variable `otherwise', which shadows the global `otherwise'
12:16:28 <ski> shachaf : er, yes
12:16:39 <ski> s/False/True/
12:17:15 <mauke> data Boolean = True | False | FileNotFound
12:17:18 <monochrom> data is type. False is True. Nothing is something
12:17:23 <ski> killy_ : so you might as well say `case ... of ...; myNewUnusedVariable -> ...' .. or better, `case ... of ...; _ -> ...'
12:17:38 <Botje> mhitza: is the default element on line 9 really necessary?
12:17:55 <Dodek> hey, i would like to implement something like bounded computation
12:17:56 <Botje> mhitza: otherwise you could start off with the empty map or use foldl1
12:18:15 <scooty-puff> Botje: its related to instruction selection of jump instructions for an assembler
12:18:20 <Dodek> more specifically, i want to implement a brainfuck interpreter that performs no more than n steps
12:18:25 <ski> killy_ : in case you don't know about it, `_' in a pattern means "don't care", it matches anything, and doesn't give a name for it
12:18:37 <Dodek> after n steps, it stops and returns current memory contents
12:18:46 <Rc43_> Ok, suppose I need to write server, which handles some data. Let data will be represented like a type X. I have a class, which represents interface to my server. So should I declare new type for server with `data` or just declare `type Server = X` and implement `instance` for it?
12:18:53 <Dodek> i wonder if there's an elegant abstraction for that
12:19:01 <mauke> Rc43: why do you have a class?
12:19:04 <killy_> yes, the same with Prolog and Erlang
12:19:13 <monochrom> since you are writing your own interpreter, you can count steps yourself and stop
12:19:17 <killy_> although I forgot about _
12:19:18 <mhitza> Botje, yeah I could change that to foldl1
12:19:26 <Rc43_> mauke, I am generating it with thrift, but it is detail
12:19:29 <mauke> Dodek: you could probably make a monad for that
12:19:32 <Dodek> monochrom: sure i can
12:19:49 <Dodek> monochrom: but i wanted to abstract away the counting thing
12:19:50 <monochrom> if you like, the Monad type class can help you reduce clutter
12:20:02 <Dodek> hmm
12:20:09 <Dodek> let me think about it
12:20:33 <mauke> something like state + continuation
12:21:04 <monochrom> I learned it from http://homepages.inf.ed.ac.uk/wadler/topics/monads.html#marktoberdorf
12:21:20 <ski> @unmtl StateT s (ContT o m) a  -- ?
12:21:21 <lambdabot> s -> (a -> s -> m o) -> m o
12:21:48 <Rc43> Btw, it seems that will be better to implement new type with `data`, because server can contain additional information in future, which isn't associated with handled data.
12:22:30 <ski> (killy_ : btw, if you have that comment for `l' and `c', why not rename them to `limit' and `currentDivisor' ?)
12:23:07 <hpaste> killy_ pasted “improved prime” at http://hpaste.org/64052
12:23:27 <killy_> Improved version (disregard the first line)
12:24:18 <killy_> ski: I'd do that after I figured out how to write this :)
12:25:01 <ski> killy_ : btw, next time, annotate the original paste with updates
12:25:19 <killy_> what do you mean?
12:25:36 <monochrom> click "annotate" not "new paste"
12:25:41 <mauke> killy_: http://hpaste.org/edit/64052
12:25:44 <killy_> ah, sure
12:25:52 <ski> there's an "Annotate" button at the top of e.g. your original <http://hpaste.org/64050> -- if you use it, updates will turn up on the same page
12:26:09 <ski> (and it'll be easier to compare old and new versions, and suggestions from others)
12:26:57 <benmachine> so guys
12:27:01 <benmachine> this is wrong, right:
12:27:01 <benmachine> ghci> parseExp "-x^2"
12:27:01 <benmachine> ParseOk (InfixApp (NegApp (Var (UnQual (Ident "x")))) (QVarOp (UnQual (Symbol "^"))) (Lit (Int 2)))
12:27:10 <benmachine> (Language.Haskell.Exts.parseExp)
12:27:19 <monochrom> > -5^2
12:27:20 <lambdabot>   -25
12:27:31 <monochrom> > let x=5 in -x^2
12:27:32 <lambdabot>   -25
12:28:03 <monochrom> you are right
12:28:31 <benmachine> okay
12:28:42 <ski> killy_ : ok
12:28:52 <benmachine> I wonder if it's intentional, I know people have Opinions about negative syntax
12:28:55 <benmachine> but no that would be stupid
12:28:58 <Cale> Does haskell-src-exts try to handle operator precedence correctly?
12:29:03 <ski> i'd remove the brackets in `(sqrt . fromIntegral $ n)' -- in fact i'd write it as `sqrt (fromIntegral n)'
12:29:11 <benmachine> Cale: well, it gets x*y+z and x+y*z right
12:29:31 <Cale> Probably it should try to do that right anyway
12:30:02 <Cale> negation is related to the additive structure of numbers, while exponentiation is related to multiplicative structure
12:30:12 <killy_> sky: mhm, ok, I did this to make sure I understand . and $
12:30:13 <zzo38> Is there any kind of dynamically loadable Haskell program in Haskell, such as .so and .dll files your program can load dynamically anything of the correc type?
12:30:19 <Algorith> intuitively you'd expect unary operators to bind harder than binary ones
12:30:19 <Cale> Multiplicative stuff always has higher precedence than additive stuff.
12:30:32 <alpounet> zzo38, see dyre, hs-plugins
12:30:51 <scooty-puff> Botje:
12:31:03 <ski> killy_ : next, i'd note that you're essentially checking values in the list `[3,5 .. limit]', so i'd replace your iterative loop with a call to `all' on that (lazy) list
12:31:08 <scooty-puff> sorry, mistype..
12:31:13 <benmachine> Cale: right. unfortunately I can't tell you if HSE tries to get any of the other prefix operators right :P
12:31:39 <ski> killy_ : ok -- i think `$' is over-used by many -- brackets are often easier to read, imo
12:31:51 <ski> only in some certain situations do i use `$'
12:31:57 <benmachine> agreed
12:32:33 <killy_> ski: how does using a list affect peroformacne?
12:33:02 <zzo38> What is hs-plugins? I look at dyte it doesn't seems like what I was looking for
12:33:10 <killy_> I know that it's probablyu not the most important thing whan learning a new language
12:33:18 <ski> Algorith : intuitively you'd expect unary operators to bind tighter than binary ones, *iff* the precedence of the former is higher than the one of the latter
12:33:41 <hpaste> ChrisL pasted “BinTreeFold” at http://hpaste.org/64054
12:33:53 <killy_> but what bugs me is that I totally don't know how the syntax of a language coverts to actuall operations done by the CPU
12:34:08 <ski> killy_ : well, only as much of the list as is being checked will actually be constructed, so i'd expect it to perform the same as your loop
12:34:35 <ski> (if in doubt, you could always measure)
12:34:47 <killy_> what about converting my code to tail recursion?
12:35:03 <killy_> shouldn't this be the fastest option?
12:35:15 <srhb> In a strict language, that would be absolutely necessary,
12:35:18 <killy_> I mean why waste memory on building a list when I don't need it anyway
12:35:35 <ski> `&&' is lazy, so it already does what a tail-recursive solution would
12:35:56 <ski> killy_ : the list is only built so far as it is inspected
12:36:02 <killy_> yes, I know
12:36:18 <killy_> but still, it is built but this could be avoided... I think
12:36:30 <cmccann> there's always stream fusion
12:36:33 <ski> if you fail at `3' in `[3,5 .. limit]', then the rest of the list won't be constructed (so you won't "waste memory on building a list when I don't need it anyway")
12:37:05 <srhb> killy_: You're not avoiding allocating anything in your recursive version, I believe.
12:37:12 <srhb> killy_: And the list version is way more idiomatic.
12:37:58 <ski> this is part of what people mean when they say that lazy lists are loops
12:38:07 <srhb> killy_: I think you're trying to plug the cube in the cylindrical hole. :-) Stop fighting it! Give in!
12:38:45 <killy_> srhb: I'm not fighting, I'm trying to understand what is really going on under the hood :)
12:39:11 <monochrom> noble cause, but it takes much study to find out
12:39:22 <ski> killy_ : anyway, note that "it is built but this could be avoided" isn't happening
12:39:37 <ski> the list isn't built before it is traversed
12:40:10 <monochrom> FWIW, figuring out how Java maps to hardware operations is just as non-trivial
12:40:14 <killy_> it's buile while it's beaing traversed
12:40:17 <srhb> I think killy mean "I could avoid allocating each value as I go if I did x..." where x is a lie.
12:40:58 <mauke> > cake
12:41:03 <lambdabot>   mueval: ExitFailure 1
12:41:03 <lambdabot>  mueval: Prelude.undefined
12:41:08 <mauke> :-|
12:41:17 <monochrom> > head cake
12:41:17 <srhb> The cake is undefined. :(
12:41:21 <lambdabot>   mueval-core: Time limit exceeded
12:41:22 <mauke> monochrom: why so +o?
12:41:31 <monochrom> because there was a spammer
12:41:35 <killy_> monochrom: well, maybe not hardware but I'm trying to figure out how haskell interprets different parts of code
12:41:45 <mauke> abstractly
12:42:23 <monochrom> my http://www.vex.net/~trebla/haskell/lazy.xhtml has half of it
12:42:58 <monochrom> or maybe 1/4 of it, depending on how you look
12:43:17 <killy_> thanks
12:43:49 <ski> killy_ : "it's buile while it's beaing traversed" -- yes, and only as much as is being traversed is built
12:44:47 <srhb> ski: The point is still, I think, the thought of the list being produced "up to the point" and wasting all that space.
12:44:51 <srhb> Which is still moot.
12:45:12 <ski> killy_ : .. which means that basically it will construct the same numbers `c' as your explicit looping code does
12:45:33 <srhb> If you really want to avoid it (you don't) you need some mutable type in there.
12:45:39 <ski> hm
12:45:46 <ski> or fusion of some kind
12:45:49 <srhb> Or that.
12:46:12 <srhb> Though I have no idea how that works. :/
12:46:20 <killy_> mhm
12:46:39 <killy_> ok, so now I'm trying to rewrite that using any
12:46:53 <killy_> but I can't figure out how to write a predicate for it :/
12:47:08 <srhb> I forget what the actual problem was.
12:47:17 <monochrom> "list fusion" is easier said than done. "let the compiler optimize it" but the compiler doesn't optimize it all that often
12:47:26 <ski> killy_ : you can define it in a `where' -- or you could use a function expression ("lambda expression")
12:47:53 <ski> > all (\x -> even x && x > 5) [6,4,8,10]
12:47:54 <lambdabot>   False
12:47:56 <ski> > all (\x -> even x && x > 5) [6,8,10]
12:47:56 <lambdabot>   True
12:48:14 <ski> > let isFoo x = even x && x > 5  in  all isFoo [6,8,10]
12:48:14 <lambdabot>   True
12:48:42 <monochrom> otoh, whatever thought-up alternatives to list-as-loop isn't all that faster either, given typical programmers' habit of presume-don't-verify
12:48:51 <ski> (i used `let' there instead of `where' since lambdabot accepts expressions, not definitions, and `where' attaches to definition clauses, not to expressions)
12:49:47 <ski> killy_ : btw, i suspect that you'd rather want `all' than `any' (but both could work)
12:49:59 <killy_> yes, I meant all
12:53:37 <hpaste> killy_ annotated “improved prime” with “improved prime (annotation)” at http://hpaste.org/64052#a64056
12:54:29 <killy_> a lot easier to read
12:57:01 <killy_> tommorow I'll try to figure out how to make lists acordng to some pattern (6k+/-1 in this case)
12:57:20 <benmachine> problem that I have: when hackage trac says "sure, I'll send you that e-mail verification token"
12:57:26 <benmachine> and then does not send that e-mail verification token
12:57:55 <monochrom> does your spam filter block it?
12:59:24 <killy_> ok guys, thanks for helping me with understanding haskell :)
12:59:39 <srhb> killy_: Have fun. :)
12:59:59 <killy_> I'm having fun with Haskell :)
13:00:13 <killy_> totally different from other languages that I know
13:00:22 <killy_> too bad I won't have much use of it at work :(
13:01:09 * killy_ goes to bed
13:05:21 <scooty-puff> is it fair to say that p /\ q implies that q is dependent on p, when solving for both (not sure if this even makes sense..)?
13:05:21 --- mode: monochrom set -b *!*@190.99.71.254
13:05:28 --- mode: monochrom set -o monochrom
13:05:44 <monochrom> they can depend on each other
13:06:14 <monochrom> (x+y=10) /\ (x-y=0)
13:06:35 <DanBurton> hackage/gnu-linux question. I'm trying to "cabal install readline" on GHC 7.4.1 and running into inexplicable issues
13:06:56 <monochrom> perhaps 7.4.1 is too new or readline is too old
13:07:21 <DanBurton> readline has exactly one version on hackage
13:07:26 <DanBurton> that has apparently worked since forever
13:07:48 <monochrom> there is always a first time
13:07:51 <scooty-puff> so lets say you have a given domain for x and y, that is not fully decided by the statement you mention, when beginning a search, i was thinking of first solving the vars in p (x+y=10) first (and any other strongly connected vars), before the vars in q - in this case they are they same
13:08:04 <DanBurton> but when I try to install, I get "configure: error: readline not found, so this package cannot be built"
13:08:19 <scooty-puff> *thats is not fully decided -> that is not solved by constraint propagation
13:08:32 <monochrom> you have the C-side readline header files etc?
13:09:07 <DanBurton> I believe so, given I just installed this library with apt for my ghc 7.0.4
13:09:15 <DanBurton> *0.3
13:09:24 <bill```> you probably need the -dev package from apt, too
13:09:56 <DanBurton> "this library" meaning "sudo apt-get install libghc-readline-dev"
13:10:12 <monochrom> at the stage of "configure: error:", GHC version matters very little
13:10:51 <DanBurton> but...but...how could apt install it without complaint for 7.0.3, while cabal install cannot install it for 7.4.1?
13:10:58 <DanBurton> anyways, what C libraries do I need
13:11:02 <monochrom> let me see if libghc-readline-dev even depends on C-side readline header files
13:11:02 <DanBurton> exactly
13:11:34 <cbm80> libreadline6-dev perhaps ?
13:12:20 <monochrom> libghc-readline-dev does not depend on C-side readline -dev. what cbm80 says.
13:12:44 <monochrom> the power of presume, don't verify
13:12:45 <DanBurton> mmkay that seems to be working
13:13:05 * DanBurton needs more Debian-fu
13:13:48 <hpaste> mee pasted “Data.Vector.Unboxed” at http://hpaste.org/64059
13:13:56 <mee> Can someone explain why Data.Vector{.Unboxed} behave differently in that hpaste, and if there is a way to use unboxed vectors but avoid the infinite loop?
13:14:17 <zzo38> My idea for dynamically loadable programs in Haskell, is that, it is a program having "main" of some type, and in a .so or .dll file. And then, another program which knows the type of main in the .so/.dll file can load it. So if you have     main :: x    in one program, then    dynamicLoad :: FilePath -> IO x    in the one loading it. Is there anything like that?
13:14:20 <cbm80> i build ghc 7.4.1 from the tarball and it didn't complain, i habe libreadline6-dev installed tho
13:14:28 <cbm80> *have
13:15:04 <DanBurton> mee: how odd
13:15:29 <monochrom> more pointedly you need to know that distros have very different ideas of packaging and dependency than yours
13:15:34 <DanBurton> cbm80: after installing that libreadline6-dev, cabal install readline worked like a charm, thanks :)
13:16:34 <The_Journey> can you implement map using foldl?
13:16:55 <strager> The_Journey: I don't see why not
13:17:06 <The_Journey> strager: so foldl is more general than map?
13:17:20 <benmachine> you can't exactly implement map with foldl
13:17:35 <The_Journey> benmachine: ?
13:17:37 <benmachine> well, it depends what exactly you mean by "implement foo with bar"
13:17:58 <benmachine> The_Journey: you can map a function over an infinite list, foldl doesn't tend to play nice with infinite lists
13:18:36 <benmachine> you can write something pretty map-like with foldl, I think, but it's not exactly map
13:19:04 <benmachine> > foldl f [a,b,c,d]
13:19:05 <lambdabot>   No instance for (SimpleReflect.FromExpr [SimpleReflect.Expr])
13:19:05 <lambdabot>    arising fr...
13:19:06 <The_Journey> benmachine: in what case is it not like map?
13:19:17 <strager> I think the time and space complexities would differe as well.
13:19:26 <benmachine> The_Journey: well, I'm not actually sure that you can do it at all yet :P
13:19:32 <benmachine> in a non-stupid way, at least
13:19:36 <benmachine> > foldl f [a,b,c,d] :: Expr
13:19:37 <lambdabot>   Couldn't match expected type `SimpleReflect.Expr'
13:19:37 <lambdabot>         against inferred ...
13:19:42 <benmachine> oh I silly
13:19:45 <benmachine> > foldl f z [a,b,c,d] :: Expr
13:19:46 <lambdabot>   f (f (f (f z a) b) c) d
13:19:57 * benmachine thinks for a bit
13:20:11 <strager> benmachine: http://slexy.org/view/s21iMtD7gD
13:20:32 <strager> foldr is better
13:20:39 <strager> (as it's just a list construct)
13:20:52 <DanBurton> ugh TIL the pain of removing Eq as a superclass constriant of Num
13:21:01 <benmachine> DanBurton: oh no you have to add some contexts :P
13:21:12 <benmachine> isn't it completely mechanical?
13:21:23 <benmachine> strager: well, you can implement foldl with foldr, after all :)
13:21:26 <Azel> There are numerical types without a notion of equality ?
13:21:32 <The_Journey> right, map (+2) [1,2,3,4] is the same as foldr (\x a -> ((x+2):a)) [1,2,3,4]
13:21:35 <benmachine> Azel: depends what you mean by "numerical"
13:21:38 <DanBurton> It isn't immediately obvious that certain kinds of pattern matching require Eq now
13:21:55 <benmachine> Azel: you can define + and * on functions to a numerical type, you can't in general define equality on them
13:22:14 <tromp__> you might want to make Double->Double an instance of Num
13:22:23 <The_Journey> foldr would have the same time and space as a map right?
13:22:23 <benmachine> DanBurton: no, but it's still basically just "read compile error, add context, try compile again", no?
13:22:30 <strager> Azel: Infinity and undefined/NaN, maybe?  Though those are values and not really types, I think.
13:22:32 <ski> Azel : real numbers don't have computable equality
13:22:43 <benmachine> tromp__: more generally, Num b => a -> b
13:22:50 <stulli> Is there somewhere a 'cabal test tutorial for 5 year olds'? I even cloned in a reference project mentioned on a SO thread but cabal-dev test won't work no matter how hard i try.
13:22:52 <benmachine> tromp__: you don't even need a to be a numeric type :)
13:23:00 <tromp__> true
13:23:01 <Azel> Silly me, I forgot equality is not computable on functions but addition is...
13:23:21 <tromp__> but CReal's good example too
13:24:14 <Algorith> Would learning ML be a good way to spend your time if you're already very invested in Haskell and Lisp? I heard it has a good way of dealing with modularity...don't know if there's much else to pick up.
13:24:20 <DanBurton> the pain I'm running into is the "numbers" package, btw. Apparently I have to throw the Eq constraint on every function in Data/Number/Dif.hs
13:24:26 <Jafet> > 0 == id
13:24:28 <lambdabot>   *Exception: (==): No overloading for function
13:24:56 <Jafet> > id
13:24:57 <lambdabot>   Overlapping instances for GHC.Show.Show (a -> a)
13:24:57 <lambdabot>    arising from a use of `...
13:25:47 <benmachine> Algorith: I was just wondering that exact question
13:25:49 <Azel> strager: I don't think IEEE 754 is the rationale for the removal of the Eq superclass constraint on Num: it is (as far as IEEE 754 can be...) with sense
13:25:53 <benmachine> except I don't know any lisp either :P
13:26:09 <benmachine> Azel: Ord on the other hand...
13:26:49 <ski> scooty-puff : maybe you were thinking of stuff like `x =/= 0 /\ y / x > z' ?
13:27:14 <ski> Algorith : i think it's probably worth it learning the module system in the MLs, yes
13:27:19 <Azel> Or negative zero for that matter...useful, but a pita if you don't expect it/take it into account
13:27:36 <scooty-puff> yes, sort of, but i see how i was mistaken
13:27:59 <benmachine> ski: the way you phrase that, is it possible to learn that without also learning the rest of ML?
13:28:08 <benmachine> (or at least one ML)
13:28:35 <DanBurton> sigh and now the show instances in the next file
13:28:37 <ski> benmachine : if you know basic Haskell, it should be easy to pick up the rest, i think
13:29:03 <benmachine> ski: mm. I'm kind of apprehensive that guarded recursion is hardwired into me now though :P
13:29:17 <benmachine> that was the problem I had with erlang, anyways
13:29:43 <ski> well, if you were talking about learning useful idioms, i suppose that might be another thing
13:29:53 * ski was mostly thinking about the language proper
13:30:05 <benmachine> fair enough
13:30:21 <benmachine> well, learning syntax is easy, learning ideas is more interesting, right?
13:30:42 <ski> yes -- for the most part
13:30:54 <ski> (sometimes syntax enables thinking new things)
13:30:59 <benmachine> sure
13:31:06 <benmachine> I don't mean to slight syntax, syntax is underrated
13:31:31 <benmachine> just that I felt like being able to write an ML program wouldn't be the same as being able to think in ML, and the latter would probably be more useful
13:31:50 <ski> but yes, you'll probably do cons-onto-list-and-finally-reverse more in the MLs than in Haskell
13:32:29 <srhb> constant.. reversing.. *twitch*
13:32:50 <Jafet> list!!
13:33:11 * ski would really like more TCMC in strict languages
13:33:36 <monochrom> I would skip the reversing in ML
13:33:53 <ski> (otoh, i often miss SMLs `local <decls> in <decls> end' in Haskell)
13:34:22 <benmachine> (what's TCMC? I googled a bit but found things of varying usefulness)
13:34:26 <ski> (monochrom : yeah .. depends)
13:34:36 <ski> benmachine : tail-call-modulo-cons
13:34:42 <benmachine> ski: ahh
13:34:43 <benmachine> okay
13:34:45 <benmachine> yeah
13:35:04 <benmachine> also it would be nice to have a declaration-let
13:35:06 <monochrom> oh! OCaml almost has that. it allows "letrec x = 0 :: x"
13:35:14 <benmachine> I think I put "write a proposal for that" on my todo list about six months ago
13:35:15 <benmachine> or so
13:35:47 <ski> monochrom : yeah, but i don't think it applies to the usual cases in which one wants TCMC (let alone being composable, which would be the ideal)
13:35:53 <monochrom> right
13:35:54 <benmachine> plus or minus a year or two
13:36:15 <ski> (benmachine : yeah, that's what `local' in SML does)
13:36:28 <benmachine> ski: yeah, that's why I mentioned it :P
13:36:40 * benmachine goes and has dinner instead of achieving anything
13:36:47 * ski wasn't sure, so mentioned it explicitly just in case
13:37:05 <monochrom> local open Me in now you see Me end now you don't :)
13:37:24 <ski> yeah, that too would be very useful
13:38:42 <monochrom> of course, you could write a whole module right there
13:43:34 * hackagebot vowpal-utils 0.1.1 - Vowpal Wabbit utilities  http://hackage.haskell.org/package/vowpal-utils-0.1.1 (CarterSchonwald)
13:44:05 <lispy> vowpal?
13:44:15 <lispy> Is that one of those acme packages?
13:44:27 <zomg> Sounds like a Ubuntu release name
13:44:28 <zomg> :P
13:45:38 <cmccann> zomg, not really, there's no alliteration
13:45:58 <Enigmagic> nah it's a set of online machine learning algorithms
13:46:23 <Enigmagic> originally from yahoo research, then hunch and now ebay
13:46:51 <cmccann> zomg, an Ubuntu release would obviously be called something like "wascally wabbit" instead
13:47:11 <monochrom> haha
13:47:48 <zomg> cmccann: heh, guess so =)
13:47:52 <luite> vowpal velociraptor
13:48:18 <zomg> I wonder what's "vowpal" anyway
13:48:25 <zomg> sorta like paypal, but for vows?
13:48:28 <zomg> =)
13:48:29 <zeratul> Whimsical wallaby
13:48:44 <DanBurton> but instead of paying, you..."vow"?
13:49:01 <luite> he took his vowpal swowd in hand
13:49:16 <Jafet> And it went schwickity schwack
13:49:37 * cmccann thinks the words in Jabberwocky sounded silly enough to begin with
13:49:38 <zomg> sounds like Big Bwang Theowy's Bawwy
13:50:27 <Jafet> We have degenewaited into Lepowiddy impwessions.
13:51:06 <kallisti> I can't remember where "sleep" is in Haskell...
13:51:26 <monochrom> Control.Concurrent.threadDelay
13:51:37 <kallisti> ah
13:51:38 <kallisti> thanks.
13:51:48 <monochrom> also recall that 1 does not mean 1 second
13:51:51 <plucas> can someone point me in the right direction for this?: I want to generate all permutations of some variables with certain constraints. My first attempt seems to take infinite time though: [(a, b, c) | a <- [1..], b <- [1..], c <- [1..], a < b, b < c, a + b + c < 10]
13:52:14 <Jafet> plucas: how many items are in the list [1..]?
13:52:44 <plucas> jafet: infinite - but I'm dealing in integers, and the constraint a + b + c < 10 reduces the problem space to pretty small
13:52:54 <plucas> it's very possible haskell isn't the right tool for this, but I thought I remember an example of something like this
13:53:21 <plucas> jafet: also, if I take out c, it works fine
13:53:35 <Jafet> Waving your hands in the air does not inspire compiler optimizations
13:53:36 <nlogax> still takes a long time to look at all the items and see if they are < 10
13:54:05 <hpc> i think you are supposed to use Logic
13:54:08 <monochrom> Haskell is defined to not "optimize" that one
13:54:16 <Jafet> @undo [(a,b) | a <- [1..], b <- [1..], a + b < 10]
13:54:16 <lambdabot> concatMap (\ a -> concatMap (\ b -> if a + b < 10 then [(a, b)] else []) [1 ..]) [1 ..]
13:54:24 <hpc> it's an alternate Monad instance for [] that behaves nicely when you need to do such things to infinite lists
13:54:37 <hpc> it's not an "optimization", it's just a reordering
13:54:59 <hpc> @hoogle Logic
13:55:00 <lambdabot> package logic-classes
13:55:00 <lambdabot> package logic-TPTP
13:55:00 <lambdabot> Graphics.Rendering.OpenGL.GL.PerFragment LogicOp :: BlendEquation
13:55:31 <hpc> oh, not Logic
13:55:37 <monochrom> logict
13:56:32 <monochrom> the package name is logict. the monad name is Logic alright
13:56:37 <hpc> it is?
13:56:51 <monochrom> http://hackage.haskell.org/packages/archive/logict/0.5.0/doc/html/Control-Monad-Logic.html
13:57:31 <Jafet> (Why is magic named Logic?)
13:58:06 * hpc has no clue how to use Logic
13:58:09 <monochrom> because people can name things as they like?
13:58:19 <monochrom> (cf vowpal)
14:02:18 <Jafet> Okay, it's not at all the kind of magic implied by hpc.
14:05:36 <scooty-puff> does -> have direction?
14:05:50 <scooty-puff> (do any logical connectives?)
14:06:01 <mekeor> scooty-puff: yes. that is "->" and "<-" are not the same!
14:06:02 <cmccann> scooty-puff, yes, it points over that way ->
14:06:26 <shachaf> It points toward "have direction?".
14:06:30 <scooty-puff> i guess i mean, can i say that p -> q implies q is dependent on p
14:06:43 <mekeor> scooty-puff: in types you use "->" and in a do-construct you use "<-". and in a case-expression you use "->" and in pattern guards "<-".
14:06:47 <shachaf> That depends on what "dependent" means.
14:06:57 <mekeor> they are all different arrows...
14:06:58 <scooty-puff> such that, when beginning a search, could all the vars of p be searched without accounting for q
14:07:23 <FUZxxl> Hi!
14:07:24 <scooty-puff> i guess i mean constraint satisfaction
14:07:28 <FUZxxl> Anybody from Berlin here?
14:07:30 <mekeor> Hi, FUZxxl
14:07:34 <FUZxxl> Hi mekeor!
14:07:40 <mekeor> FUZxxl: from germany, yes. #haskell.de
14:07:44 <FUZxxl> I know.
14:07:46 <scooty-puff> i don't like how p -> q, where q has not variables in p, would still contribute to the search for p
14:07:50 <FUZxxl> Silence there is.
14:07:52 <scooty-puff> *no variables
14:07:55 <scooty-puff> if that makes sense..
14:07:56 <mekeor> FUZxxl: exactly
14:07:58 <FUZxxl> :-)
14:08:13 <shachaf> Oh, you're talking about something specific.
14:08:37 <Jafet> shachaf got distracted by the arrows.
14:08:42 <FUZxxl> Well, that doesn't exactly means that there is nobody in the whole Haskell-world, since #haskell.de is just a subset of those who are able to speak German.
14:08:50 <FUZxxl> Probably not even a subset...
14:09:03 <mekeor> FUZxxl: that's correct.
14:09:06 <FUZxxl> :-)
14:09:08 <shachaf> Jafet: Who wouldn't?
14:09:10 <scooty-puff> (the actual case: branch instructions have alternate instructions for larger jumps, those different instructions having a different size themselves - so a forward branch would be dependent on itself)
14:09:10 <lispy> More of a newtype really
14:09:18 <FUZxxl> It's about my graduation from highschool.
14:09:20 <scooty-puff> (and you can imagine other branches that would not go well)
14:09:49 <scooty-puff> constraint propagation can take care of nearly all cases
14:09:58 <scooty-puff> but in the cases, however rare, that it can't
14:10:12 <FUZxxl> In Germany, one needs to write a "scientific" article about a topic one can choose for graduation.
14:10:16 <scooty-puff> i don't want instructions in one contained area to cause everything else to go slower
14:10:45 <FUZxxl> I wanted to write mine about type-systems and how good type-systems can improve the quality of software.
14:12:00 <Jafet> Tip: save the really cool topics for the Habilitation
14:12:08 <FUZxxl> :)
14:12:08 <scooty-puff> the instruction selection is expressed along the lines of: vars <- getVarsTo branchLabel; sum vars > limit -> var = 5
14:12:27 <FUZxxl> Jafet: One doesn't needs to invent anything.
14:12:37 <scooty-puff> well, :->, etc., to be valid syntax
14:13:18 <DanBurton> I can't find Cale on Google+ >,<
14:13:25 <FUZxxl> I basically want to write something like "We have these approaches to typisation, they have these advantages and these complications. The future is X."
14:13:41 <Cale> DanBurton: That's because I removed my G+ account
14:13:45 <DanBurton> cale, dmwit: https://github.com/DanBurton/lambdabot-remedies#readme
14:13:46 <Cale> Because G+ is bullshit
14:13:49 <DanBurton> Cale: D:
14:13:51 <FUZxxl> And oh yes... It has to be 20 pages or more...
14:14:18 <mhitza> plucas, wouldn't this work ? [(a, b, c) | a <- [1..], b <- [(a + 1)..], c <- [(b + 1)..], (a < b) && (b < c), a + b + c < 10]
14:14:18 <DanBurton> G+ is bullshit, but it's got lots of Haskellers on it, which is pretty much the only reason I use it xD
14:15:07 <plucas> mhitza: that emits 4 permutations and then seems to block indefinitely
14:15:32 <adrian23> hi everyone
14:16:29 <DanBurton> adrian23: hello
14:17:25 <adrian23> I have a question that is driving me crazy. I'm trying to learn some haskell for a while... but I really don't know how to call this function calcBmis xs = [bmi | (w, h) <- xs, let bmi = w / h ^ 2, bmi >= 25.0]
14:17:46 <adrian23> as you may know this is from http://learnyouahaskell.com/
14:18:43 <Landarzar> let calcBmis xs = [bmi | (w, h) <- xs, let bmi = w / h ^ 2, bmi >= 25.0]
14:18:51 <Landarzar> @let calcBmis xs = [bmi | (w, h) <- xs, let bmi = w / h ^ 2, bmi >= 25.0]
14:18:53 <lambdabot>  Defined.
14:19:04 <scooty-puff> calcBmis [(30, 140)]
14:19:08 <Landarzar> @calcBmis [(1,2),(2,3)]
14:19:08 <lambdabot> Unknown command, try @list
14:19:18 <scooty-puff> > calcBmis [(30, 140)]
14:19:23 <lambdabot>   mueval: ExitFailure 1
14:19:23 <lambdabot>  mueval: Prelude.undefined
14:19:27 <otters> hahaha
14:19:28 <mekeor> `[...|...]' is syntactic sugar for `filter', right?
14:19:35 <otters> it's a list comprehension
14:19:48 <otters> so not really it's syntactic sugar for do-notation
14:20:07 <mekeor> do-notation?
14:20:11 <Landarzar> wich is syntatic suger for monads :)
14:20:13 <otters> right
14:20:20 * otters does not like list comprehensions
14:20:37 <adrian23> yes!
14:21:07 <adrian23> thank you scooty-puff and landarzar
14:21:46 <mekeor> otters: do you mean that [...|...] is syntactic sugar for do-notation?
14:21:52 <otters> yes
14:21:59 <mekeor> oO
14:22:05 <adrian23> right now i'm trying to figure it out why :D
14:22:26 <otters> [bmi | (w, h) <- xs, let bmi = w / h ^ 2] is roughly equivalent to do {(w, h) <- xs; let bmi = w / h ^ 2; return bmi}
14:22:32 <byorgey> mekeor: it is if you enable -XMonadComprehensions.
14:23:04 <lukish> :hoogle  a b c -> a b' c' -> a (b,b') (c, c')
14:23:12 <Jafet> @undo [bmi | (w, h) <- xs, let bmi = w / h ^ 2]
14:23:12 <lambdabot> concatMap (\ (w, h) -> let { bmi = w / h ^ 2} in [bmi]) xs
14:23:22 <lukish> @hoogle  a b c -> a b' c' -> a (b,b') (c, c')
14:23:23 <lambdabot> Control.Arrow (***) :: Arrow a => a b c -> a b' c' -> a (b, b') (c, c')
14:23:27 <Jafet> @pl concatMap
14:23:27 <lambdabot> (=<<)
14:23:40 <otters> haha uh
14:23:43 <mekeor> otters, byorgey: okay, i see.
14:24:09 <carter_> lispy  Enigmagic -  I'm putting together some tools to make using vowpal wabbit a bit easier, though right now i'm only making available an implimentation of how the basic hashing is done (which is spread out quite a bit in the original c code)
14:24:10 <adrian23> thanks everyone for the wonderful responses
14:25:50 <carter> and i may or may not have a go at later porting the algorithms into a haskell implementation of the cool and call it hoppy bunny
14:26:16 <lukish> I wanna do something like ((*) ??? (+)) $ 1 2 -> (2,3). Is there some arrow for do that?
14:26:45 <lukish> Something like 2 argument (&&&)
14:26:48 <adrian23> I have to go now. It's kinda late here. Thanks everyone. Have a nice .hs hack
14:26:53 <mauke> :t curry ((*) &&& (+))
14:26:54 <lambdabot> forall a b. (Num a, Num b) => a -> b -> ((a, b) -> (a, b), (a, b) -> (a, b))
14:27:18 <mauke> oh, right
14:27:24 <everythingWorks_> what do you like kicking around? :>
14:28:13 <byorgey> @pl \f g a b -> (f a b, g a b)
14:28:13 <lambdabot> liftM2 (liftM2 (,))
14:28:25 <byorgey> ah, nice
14:28:35 <byorgey> lukish: ^^^
14:28:52 <FUZxxl> Sorry... My connection decided to die.
14:29:26 <lukish> LiftM2 is horrible
14:29:36 <Jafet> Then use liftA2
14:29:37 <lukish> 2 liftM2's is horrible twice
14:29:42 <byorgey> uh, what?
14:29:50 <byorgey> liftM2 is horrible and (***) isn't?
14:29:59 <lukish> Uguu
14:30:09 <lukish> It's not obvious to reading
14:30:11 <kallisti> hmmm, threadDelay doesn't actually seem to be delaying anything
14:30:31 <benmachine> lukish: you just need to interpret it in the right way
14:30:51 <benmachine> liftM2 op f g -- apply op to the results of f and g
14:30:52 <byorgey> lukish: there is nothing inherent in liftM2 that is either obvious or unobvious.  
14:31:03 <byorgey> it depends on who is reading it and what they are familiar with.
14:31:14 <benmachine> liftM2 (liftM2 op) f g -- apply op to the results of the results of f and g, in a manner of speaking
14:31:15 <byorgey> the same thing would go for (&&&) or any other solution to this problem you come up with.
14:31:44 <benmachine> byorgey: well, some solutions are incomprehensible even to experts
14:31:54 <lukish> :t  the expression: liftM2 (liftM2 (,)) $ (+) (*) 1 2
14:31:55 <lambdabot> Not in scope: `the'
14:31:55 <lambdabot> Not in scope: `expression'
14:32:17 <otters> :t liftM2 (liftM2 (,)) $ (+) (*) 1 2
14:32:18 <lambdabot> forall a1 a2 (m :: * -> *). (Monad m, Num (m a1)) => (m a1 -> m a2) -> m a1 -> m (a1, a2)
14:32:19 <otters> neat
14:32:44 <benmachine> that doesn't look right
14:32:50 <byorgey> benmachine: sure, I'm not arguing that everything is equally comprehensible.
14:33:08 <benmachine> byorgey: fair enough
14:33:18 <benmachine> I'd agree that liftM2 makes sense to those for whom it makes sense :)
14:33:27 <benmachine> I mean, particularly, that that's a nonempty set
14:33:35 <lukish> > curry (uncurry (+) &&& uncurry (*)) 1 2
14:33:35 <lambdabot>   (3,2)
14:33:40 <byorgey> benmachine: right
14:34:20 <byorgey> see, personally I find the liftM2 solution easier to understand than that curry/uncurry one.
14:34:24 <benmachine> :t liftM2 (liftM2 (,)) (+) (*) 1 2
14:34:25 <lambdabot> forall a2. (Num a2) => (a2, a2)
14:34:25 <kallisti> any idea why liftIO $ threadDelay 20000  isn't pausing (within ErrorT)
14:34:33 <benmachine> otters: ^ that's what you want, no $
14:34:38 <lukish> > liftM2 (liftM2 (,)) (+) (*) 1 2
14:34:39 <lambdabot>   (3,2)
14:34:48 <mauke> kallisti: is it pausing outside of ErrorT?
14:34:58 <kallisti> let me check
14:35:05 <mauke> kallisti: also, that's a really short pause
14:35:09 <geekosaur> isn't threadDelay in usec or something?
14:35:09 <mauke> kallisti: how do you know it's not pausing?
14:35:14 <byorgey> doesn't threadDelay take microseconds?
14:35:14 <benmachine> that's 20 milliseconds isn't it?
14:35:18 <mauke> yes
14:35:25 <benmachine> so a fiftieth of a second
14:35:25 <kallisti> oh
14:35:27 <kallisti> microseconds...
14:35:30 <benmachine> :)
14:35:33 <kallisti> lol
14:35:48 <kallisti> that's an unusual level of granularity there.
14:35:55 * benmachine reckons that it would have been good to call it microsleep or something
14:36:07 <mauke> biliseconds
14:36:31 <byorgey> quickThreadNap
14:36:42 <benmachine> kallisti: it's not unusually high, given that POSIX has a C function nanosleep
14:37:15 <Jafet> Because newtypes are expensive.
14:37:26 <benmachine> Jafet: wha
14:38:27 <Jafet> Especially in C-inspired libraries. They have to be fast.
14:38:30 <kallisti> see, I'm a good question asker. What if I had just said "HALP THREADDELAY NO WORK?"
14:38:47 <Jafet> But it does no work.
14:38:53 <kallisti> ..
14:38:58 <kallisti> ZING
14:39:07 <mauke> kallisti: but a bad debugger. you haven't simplified the problem to its core
14:39:18 <kallisti> mauke: yes I'm a terrible debugger.
14:39:28 <kallisti> but I'm more surprised that you actually know that based on the limited information I've given you.
14:39:56 <mauke> <kallisti> any idea why liftIO $ threadDelay 20000  isn't pausing (within ErrorT)
14:40:10 <kallisti> mauke: ah
14:40:10 <mauke> the 'liftIO $' and 'ErrorT' parts are fluff
14:40:22 <kallisti> just some context. I didn't think it mattered at all in fact.
14:40:29 <kallisti> but yes I could have checked just IO instead.
14:40:54 <shachaf> How do you know it's not pausing?
14:41:02 <benmachine> shachaf: I think we solved the actual problem
14:41:13 <shachaf> Oh.
14:41:16 <kallisti> it is now, because I gave it a human perceivable unit of time.
14:41:25 <mauke> :-)
14:41:34 <benmachine> kallisti: well, when I saw it, I thought "maybe an earlier failure has caused the ErrorT to skip that bit"
14:41:58 <benmachine> extra detail is sometimes distracting
14:42:27 <kallisti> hm, yeah
14:42:44 <shachaf> Hah, I said exactly what mauke said.
14:42:55 <shachaf> I was also vaguely thinking that it's the sort of thing mauke would say when I said it.
14:43:00 <benmachine> (but at the same time I never like it when people are too condemnatory about question-asking methods; if you fully had a grip on the situation you wouldn't be asking in the first place :P)
14:43:08 <mauke> .oO( soon. )
14:43:37 <benmachine> mauke: are you plotting to assimilate shachaf into the hivemauke
14:44:41 <SubtleArray> Good day, Haskellers. I was wondering: Could you see Haskell being used to develop machine learning algorithms? Or would it be better to use a more "specialized" language?
14:45:47 <SubtleArray> I had a hard time climbing mount Haskell, and getting my brain to think functionally. But now that I've made some progress, and feel more comfortable with the syntax, I'd like to try using it for everything.
14:46:03 <hpc> SubtleArray: you would probably write your specialized eDSL in haskell
14:46:50 <SubtleArray> hpc: :D In other words, Haskell can be used for anything?
14:47:50 <byorgey> SubtleArray: see http://www.haskell.org/haskellwiki/AI , there's a bit about machine learning there, and some interested people
14:48:12 <byorgey> SubtleArray: you should also talk to carter who has recently being doing some machine-learning sorts of things in Haskell I think
14:48:16 <zomg> SubtleArray: almost all programming languages can be used for anything ;)
14:48:20 <benmachine> almost anything can be used for almost anything else
14:48:24 <benmachine> ...yeah, that
14:48:25 <zomg> Proper ones anyway
14:48:37 <benmachine> but there are varying degrees of comfort
14:48:45 <kallisti> @faq can Haskell do anything?
14:48:46 <lambdabot> The answer is: Yes! Haskell can do that.
14:48:56 <carter> SubtleArray: yes you can use HS for anything
14:48:59 <SubtleArray> byorgey: Why can I never find those links?? >_< Probably used wrong keywords. Thanks.
14:49:00 <zomg> @faq can haskell not do anything?
14:49:00 <lambdabot> The answer is: Yes! Haskell can do that.
14:49:02 <zomg> ha haa
14:49:14 <benmachine> carter: it depends what you mean by using HS
14:49:21 <byorgey> SubtleArray: I just did a google search for "haskell machine learning" =)
14:49:26 <benmachine> you can't run it on the JVM afaik
14:49:45 <SubtleArray> zomg: True, but some languages make the work easier or more efficient. For example: Trying to do string parsing in C++ is kind of tedious. Much easier in Python and Haskell.
14:49:47 <benmachine> you can't use it *directly* for hard real-time
14:49:53 <carter> benmachine thats 'cause jvm is a terrible backend for general tail recursion
14:50:01 <kallisti> @faq can Haskell compute the graph isomorphism problem in polynomial time?
14:50:01 <lambdabot> The answer is: Yes! Haskell can do that.
14:50:02 <mhitza> plucas, how about this version :) nub . concat . map (filter (\x -> sum x < 10)) . map (filter (\x -> length x == 3) . subsequences) $ permutations [1..10]
14:50:03 <carter> benmachine .net is a saner target
14:50:06 <SubtleArray> byorgey: I've been using Bing... >_< Hahaha.
14:50:28 <byorgey> zomg: I think it interpreted "can haskell not do anything" as a rhetorical question, like "is this spaghetti not the best you've ever tasted?"
14:50:38 <byorgey> SubtleArray: well, no wonder!
14:50:43 <davv3> men har du blivit för lat o gå eller?
14:50:43 <zomg> I tried using Bing after a few microsofties I follow on twitter were talking about how they are using it and it's sooo muuuch better than google!
14:50:46 <Peterbing> I can confirm that it is possible to fail to use Haskell for anything
14:50:47 <lorraine> is there a slick way to turn catMaybes :: [Maybe a] -> [a] into something :: [(b,Maybe a)] -> [(b,a)]? I feel like there should be.
14:50:52 <zomg> Well, it ain't anything close to google
14:50:54 <zomg> :P
14:51:12 <SubtleArray> byorgey: I wanted to try something different... >_<
14:51:14 <kallisti> lorraine: you can use second and mapMaybe
14:51:39 <zomg> I suspect if Bing is actually as good as people claim, you might just need to use a different approach to querying
14:51:44 <kallisti> lorraine: (second being from Control.Arrow)
14:51:49 <carter> i think that bing has less computer scientist search history
14:51:57 <zomg> I'm so used to tailoring my questions into a format which produces good results in google it probably would not work so well with others
14:52:04 <carter> so its less adept at helping narrow things down
14:52:06 <byorgey> lorraine: catMaybes . map strength  where  strength :: Functor f => (b , f a) -> f (b, a)
14:52:44 <kallisti> also
14:52:47 <kallisti> mapMaybe
14:53:03 <lorraine> byorgey: where is strength defined?
14:53:14 <byorgey> sadly you have to imeplement strength yourself
14:53:17 <avocado> in valhalla
14:53:33 <lorraine> why "strength"?
14:53:35 <byorgey> strength (b, fa) = fmap ((,) b) fa
14:53:52 <byorgey> because it corresponds to the notion of a "strong" functor in category theory
14:53:55 <SubtleArray> zomg: Actually, Bing is fine. I don't know what the hell I was looking up before, but I just typed in Haskell machine learning and found this. http://andrewbrobinson.com/2012/01/22/machine-learning-in-haskell-linear-regression/
14:53:56 <carter> SubtleArray : what sort of machine learning are you thinking of? at some level most are just some sort of optization problem that finds the optimal model in some space subject to constraints that are your data
14:53:56 <byorgey> really you could call it anything =)
14:54:36 <SubtleArray> carter: Very true. I wanted to start with some basic path finding problems.
14:54:43 <ski> @type uncurry (fmap . (,))
14:54:44 <lambdabot> forall a (f :: * -> *) a1. (Functor f) => (a1, f a) -> f (a1, a)
14:54:51 <carter> SubtleArray: those aren't machine learning, per se
14:54:59 <carter> so you mean like A* search?
14:55:03 <byorgey> ski: nice
14:55:13 <byorgey> there's an A* search package on Hackage
14:55:32 <carter> SubtleArray: perhaps you're thinking about game playing algorithms?
14:55:33 <SubtleArray> carter: I know some languages more more tailored for ML type stuff like R and Octave, but, since I've already made some progress Haskell, I thought I could just stick with it.
14:55:45 <carter> SubtleArray: they're not tailored
14:55:52 <carter> its just that lots of people use them
14:56:03 <zomg> SubtleArray: dunno, at least I don't usually find much of what I try on bing and then typing same on google puts it like the first few results =)
14:56:08 <zomg> I suppose it's not the worst option though
14:56:13 <carter> and they wind up acruing libraries like strata of rock
14:56:28 <carter> and then it comes a question of do you know if the library exists
14:56:52 <carter> and doing archaeology to figure out which one is useable for what you want, and is performant
14:57:24 <carter> its not that those languages are "better"
14:57:42 <carter> they're just often used
14:57:45 <carter> and thus have inertia
14:57:46 <SubtleArray> carter: Sorry for the grammatical errors. And I was going to use path-finding (paticularly unsupervised path-finding) as a stepping stone for more complex, more "officially machine learning" projects. And by "tailored" I meant easier to use for machine learning tasks. I know C++, but I wouldn't want to use it for a project that involved a lot of pattern matching.
14:58:09 <carter> SubtleArray easier depends on how you think
14:58:13 <DanBurton> would anybody with ghc 7.4.1 without lambdabot installed like to try out my instructions? https://github.com/DanBurton/lambdabot-remedies#readme
14:58:51 <carter> matlab is "easier" mostly because you can just jump into writing the linear algebra for something
14:59:22 <dmwit> "unsupervised path-finding"?
14:59:24 <SubtleArray> Carter: Right.
14:59:26 <carter> r is "easier" because it has a nice built in datastructure for rows of labelled columns
14:59:28 <dmwit> What does unsupervised mean there?
14:59:44 <carter> SubtleArray : whats an example path finding thing you're thinking of?
14:59:59 <carter> like how an npc in baldurs gate walks from A to B?
15:00:23 <cmccann> dmwit, it's like Lord of the Flies, except with algorithms instead of children
15:00:54 <SubtleArray> dmwit: Yeah, a term I probably just coined. Forgive my bad English. And in that context I mean the AI has to path find through terrain that it doesn't know.
15:01:21 <carter> so as in a computer game or in real life?
15:01:27 <SubtleArray> carter: No, not game AI. I'm thinking more of the line of snails. 3 axis.
15:01:47 <carter> line of snails?
15:01:50 <SubtleArray> *more along the line of
15:02:02 <carter> so move in a line, bump into stuff?
15:02:12 <carter> randomly rotate
15:02:17 <carter> repeat?
15:02:21 <SubtleArray> No way.
15:02:24 <lukish> is there some builting function for `filter (== True)'?
15:02:38 <lukish> builtin*
15:02:43 <dmwit> lukish: filter id?
15:02:57 <byorgey> (== True) = id
15:03:07 <dmwit> I don't think it will get much shorter than that.
15:03:09 <dmwit> No built-in.
15:03:14 <lukish> Wowo
15:03:16 <dmwit> It seems like kind of a weird thing to want, really.
15:03:16 <SubtleArray> Carter: I want to make something better than that. But my question has been answered, and I've been given good links. Doing machine learning in Haskell is okay. :D
15:03:16 <lukish> Nice
15:03:34 <carter> which links?
15:03:38 * hackagebot HaTeX 3.2.0.1 - LaTeX code writer.  http://hackage.haskell.org/package/HaTeX-3.2.0.1 (DanielDiaz)
15:03:42 <carter> good luck wiht it
15:03:44 <byorgey> you just get a list of all Trues out, but the number of Trues could be interesting
15:04:00 <SubtleArray> carter: The ones byorgey gave me, and the one I found.
15:04:07 <carter> ok
15:04:11 <carter> have fun then
15:04:21 <SubtleArray> Will try.
15:04:22 <byorgey> lukish: however, if you have  filter id . map f   then you might as well just say   filter f
15:04:50 <byorgey> length . filter id . map f  ===  length . filter f
15:05:57 <carter> byorgey  also oversold how much I'm currently up to (this month, were it next month he might have been underselling)
15:06:03 <carter> haha
15:06:16 <SubtleArray> I could have phrased my question more elegantly by asking "How easy is it to do multivariate linear regression in Haskell?" Lol. Trying to expain my projects just confuses people because I always use the wrong terminology.
15:06:44 <byorgey> hehe, I wasn't really selling anything, I just though you might have some interesting things to contribute to a conversation about Haskell + machine learning =)
15:06:49 <carter> true
15:07:02 <carter> SubtleArray: pathfinding isn't multilinear regression though
15:07:22 <SubtleArray> carter: I know. But that's what I want to start with. I'm still learning Haskell.
15:07:38 <SubtleArray> But I want to work my way into some real  machine learning.
15:08:09 <SubtleArray> I just want to make sure that when I'm ready to do more complicated projects, I won't run into a dead end by using Haskell.
15:08:45 <carter> SubtleArray: it'd be pretty easy to impliment multivariate least squares regression using say Hmatrix or the like
15:09:18 <carter> (btw: is there any lgpl or bsd hmatrix like on hackage?)
15:09:20 <lukish> filter id . zipWith (==) (numberToList secret)
15:09:32 <lukish> Can it be rewritted well?
15:10:03 <SubtleArray> carter: Oh this is great... Looking at hmatrix package now.
15:10:40 <carter> lukish you mean hmatrix?
15:10:42 <Veinor> @type filter id . zipWith (==) (?numberToList ?secret)
15:10:43 <lambdabot> forall a t. (Eq a, ?numberToList::t -> [a], ?secret::t) => [a] -> [Bool]
15:11:03 <carter> I should probably email alberto and ask him, every time i've email him about a bug fix or the like, he's been incredibly nice
15:11:32 <shachaf> You can also use filter unsafeCoerce.
15:11:33 <SubtleArray> byorgey: I know. Just saying thank you. ^_^
15:13:07 <SubtleArray> Thanks guys. No more worries now. My goal really is to find 1 language that can do most of what I want to do currently, and will want to do in the future. C++ is great, but it makes me mad. >:U Python has a lot of potential, but Haskell has more.
15:13:28 <SubtleArray> That's all. Peace (%)
15:14:10 <adimit> so… the current Haskell Platform doesn't want to be compiled with 7.4.1. Should I first install 7.0.4, then haskell platform, then upgrade GHC again, or should I just try compiling it with 7.4.1
15:14:27 <adimit> ? sorry, always forget the bloody question mark.
15:14:56 <bill```> english doesn't really have a strict syntax
15:15:07 <lukish> > delete 3 [1,2,3,4,5,3,6]
15:15:07 <lambdabot>   [1,2,4,5,3,6]
15:15:10 <carter> adimit: sadly thats what I do, the main blocker seems to be getting A cabal-install installed
15:15:19 <lukish> How can I get [1,2,4,5,6]?
15:15:31 <lukish> How can I delete all occurances?
15:15:57 <adimit> bill```: I'm a linguist, I know that :-P
15:16:02 <adimit> carter: that sucks.
15:16:03 <psudo> HOW CAN I CHOOSE A FUCKEN NAME
15:16:08 <byorgey> adimit: if you want GHC 7.4.1 then bothering with the Platform is likely to be more trouble than it's worth, until a new release of the Platform is made
15:16:20 <lukish> filter (/= 3) [1,2,3,4,5,3,6]
15:16:21 <adimit> byorgey: I feared that might be the case.
15:16:26 <c_wraith> adimit: the best solution is to not use the haskell platform. Just install the version of ghc, install cabal-install (or use the one you already have) and install the packages you need with it
15:16:26 <lukish> > filter (/= 3) [1,2,3,4,5,3,6]
15:16:27 <carter> byorgey: actually, its the sanest way to get cabal cli goodness
15:16:27 <lambdabot>   [1,2,4,5,6]
15:16:36 <carter> well,
15:16:38 <byorgey> adimit: what OS are you on?
15:16:39 <carter> at least on the mac
15:16:42 <adimit> byorgey: Debian.
15:16:43 <carter> good question
15:16:45 <carter> ok
15:16:53 <carter> ignore me then (maybe)
15:17:07 <byorgey> adimit: then I don't think you'll have any trouble.  Just install GHC 7.4, install cabal-install (using the 'bootstrap.sh' script that comes with the tarball), and you're good to go
15:17:22 <adimit> byorgey, c_wraith, I guess I'll go with your suggestions and get cabal-install separately.
15:17:27 <byorgey> platform packages will be installed by cabal-install as needed.
15:17:32 <danharaj> I heard that using the list monad instance doesn't allow fusion rules to fire
15:17:35 <danharaj> is this still true?
15:17:36 <carter> i thought cabal-install currenlty doesn't build with 7.4!
15:17:44 <c_wraith> I think cabal-install has issues installing on ghc 7.4
15:17:52 <c_wraith> build it with a previous version of ghc
15:17:55 <carter> yes
15:18:00 <c_wraith> then just use it with the new one
15:18:00 <carter> thats what i was suggesting
15:18:03 <adimit> Sadly, my newest code already depends on 7.4…
15:18:06 <adimit> ugh.
15:18:08 <carter> thats ok
15:18:11 <c_wraith> I mean build cabal-install
15:18:14 <ddarius> danharaj: You can write a little program to find out.
15:18:15 <adimit> yeah, right.
15:18:15 <carter> yes
15:18:16 <c_wraith> once it's built, save the binary
15:18:23 <c_wraith> then install the new version of ghc
15:18:26 <c_wraith> it works just fine that way
15:18:26 <danharaj> ddarius: That would involve science.
15:18:30 <adimit> I just didn't want to have to install two versions of ghc, but I guess that's the way.
15:18:32 <carter> c_wraith <--- person giving the right advice
15:18:33 <adimit> thanks for your help!
15:18:48 <c_wraith> adimit: you don't need to keep the old version around, if you don't want
15:18:49 <carter> adimit you can uninstall older ghc after you build cabal-install
15:19:02 <adimit> I shall do that :-)
15:19:15 <ddarius> danharaj: You could just have faith that it works.
15:19:38 <Veinor> so here's one problem I see with acid-state migrations: if I pick a name like 'MyDatabase' for my DB type, I can't use that for the new type; I'd have to do something like 'MyDatabse2'
15:19:47 <lukish> Is there some anti (!!) operator? Like delete some i's element. [1,2,3,4,5] (!!') 2 == [1,2,4,5]
15:19:49 <SubtleArray> O_O
15:19:53 <danharaj> ddarius: Yes I think that's much easier I'll do that.
15:20:03 <ddarius> That's what I recommend as well.
15:20:13 <SubtleArray> Sorry. Wrong window. Lol
15:20:47 <SubtleArray> Shocked by some angry ranting in another IRC.
15:21:03 <shachaf> There is no right window for "O_O".
15:21:25 <doserj> lukish: no. if you have to that a lot, it is better to use some other datastructure than lists, like Map, or IntMap
15:21:45 * ddarius endeavors to say "Sorry. Wrong window" and nothing more in a channel.
15:21:59 <Veinor> > let remove n xs = let (p1, p2) = splitAt n xs in p1 ++ tail p2 in remove 2 [1,2,3,4,5]
15:22:04 <lambdabot>   mueval: ExitFailure 1
15:22:04 <lambdabot>  mueval: Prelude.undefined
15:22:16 <SubtleArray> shachaf: That's shocked face. O_O Happy face. ^_^ Etc.
15:22:25 <shachaf> ddarius: You forgot the ". Lol". That part is critical for the effect.
15:22:39 <ddarius> I don't say "lol."
15:22:44 <SubtleArray> No. Lol is so 2008.
15:22:56 <shachaf> Anyway, this is the wrong window for this discussion.
15:22:59 <shachaf> I recommend #not-haskell
15:23:21 <SubtleArray> Right. Hence the apology. But you started talking to me about it, and I explained it.
15:24:56 * DanBurton kindly gestures towards #haskell-blah
15:25:39 <DanBurton> I'm wondering what will happen if you try to use UHC to compile itself into javascript
15:25:43 <zenzike> window 1
15:26:22 <alpounet> DanBurton, hah, a Haskell compiler written in Javascript
15:26:25 <alpounet> now that's a challenge
15:26:39 <ddarius> "Sorry.  Wrong window.  I meant window 2."
15:26:41 * ddarius leaves.
15:27:15 <kallisti> What would be an alternative to using Data.List functions to search a string for a list of words. I have two in mind: 1) regex  2) Parsec
15:27:24 <kallisti> which would be best?
15:27:50 <DanBurton> it would be really cool though, because then you could send the compiler-in-javascript to people on the web, and let them compile haskell using the compiler-in-javascript
15:27:54 <kallisti> (note: question isn't exclusive to those two options)
15:28:18 <DanBurton> kallisti: "search a string for a list of words"...what's wrong with Data.List?
15:28:18 <zeratul> Is there a problem to which regex is the best solution?
15:28:28 <JoeyA> Making a JavaScript Haskell compiler efficient would be a challenge, I think.
15:28:36 <otters> and stupid
15:28:39 <alpounet> DanBurton, "Get your own compiler in your browser!"
15:28:42 <alpounet> that's catchy
15:28:43 <dmwit> zeratul: Matching a regular language.
15:29:19 <DanBurton> kallisti: if performance is a concern, then you should probably be using Data.Text
15:29:36 <DanBurton> @hackage text
15:29:36 <lambdabot> http://hackage.haskell.org/package/text
15:29:57 <adimit> I'm guessing darcs also just doesn't compile yet with 7.4.1, no?
15:30:02 <kallisti> DanBurton: I guess now that I think about it nothing is wrong with Data.List
15:31:09 <DanBurton> > T.replace (T.pack "foo") (T.pack "bar") (T.pack "foo foo foo")
15:31:10 <lambdabot>   Not in scope: `T.replace'Not in scope: `T.pack'Not in scope: `T.pack'Not in...
15:31:14 <DanBurton> aw
15:31:36 <DanBurton> adimit: haven't tried; quite possible
15:32:25 <adimit> DanBurton: it's complaining about conflicting base versions or whatnot.
15:32:42 <alpounet> kallisti, List is really not good for performance...
15:33:05 <DanBurton> adimit: if you just want a darcs exe, you can probably get it from your system's distribution, e.g. apt-get
15:33:20 <adimit> DanBurton: that's what I ended up doing :-)
15:33:59 <kallisti> alpounet: I think in this case it's going to be mostly equivalent, asymptotically speaking.
15:34:10 <alpounet> well
15:34:16 <DanBurton> mm yeah cabal is warning me that the install might break my ghc
15:34:21 <alpounet> kallisti, what is it exactly that you want to achieve ?
15:34:21 <DanBurton> (of darcs)
15:34:39 <kallisti> search for a list of words within a string.
15:34:45 <kallisti> in fact I already have it written.
15:34:47 <kallisti> because it's easy.
15:35:17 <adimit> well, 7.4.1 *was* a pretty big major release. What with the new kind-sorcery and stuff.
15:36:32 <alpounet> kallisti, well, you should write a tiny bench for this, if performance really matter
15:36:40 <alpounet> otherwise, just keep your existing code
15:37:08 <DanBurton> even though it's not commonly useful for everyday programming (yet?), the new kind-sorcery is a really Big Deal. It's surprising that such an awesome feature made its way into a mainstream Haskell compiler at all.
15:37:22 <DanBurton> <3 ghc
15:37:42 <kallisti> alpounet: it's not. just an idle premature performance consideration. :>
15:37:57 <alpounet> heh
15:38:04 <kallisti> root of all evil, etc.
15:38:35 <alpounet> however, i generally just go with text instead of String for about all my code that has to manipulate strings
15:39:42 <DanBurton> OK premature optimizations: using Text, using foldl', using strict containers appropriately
15:40:11 <DanBurton> using unboxed things
15:44:34 <mike-burns> Is there a list of OK premature optimizations, on the wiki or somewhere?
15:44:57 <dmwit> "premature" means "before it's time to optimize"
15:45:07 <mike-burns> Thank you.
15:45:14 <dmwit> Therefore, the list of premature optimizations that it is time to perform is [].
15:46:20 <dmwit> (I'm honestly not really sure what kind of answer you're looking for here. GHC flags? Refactoring techniques? What?)
15:46:38 <mike-burns> Something like what DanBurton just said 6 minutes ago, but longer.
15:46:42 <alpounet> mike-burns, well, i guess caring at least a bit about where laziness should / should not occur + using bytestring/text when you have some string manipulation code around, right from the start,  is not premature
15:46:52 <mike-burns> See, like that.
15:47:10 <mike-burns> "Using the right data structure", but more detailed.
15:47:44 <dmwit> ah, I missed that joke
15:49:26 <jfischoff> mike-burns: http://johantibell.com/files/haskell-performance-patterns.html#(1)
15:49:49 <mike-burns> Ah cool, thanks.
15:50:09 <Jafet> Usually, the premature optimization is deciding to perform them.
15:50:13 <jfischoff> the short answer "is make things strict"
15:50:51 <Jafet> Oh god, I won't ever be able to go really really fast unless I reduce the generality of this program.
15:51:23 <bill```> gotta go fast
15:51:32 <Jafet> This crucial function must necessarily embed IO.
15:52:28 <kallisti> Jafet: didn't know that IO is secretly the Fast monad?
15:52:33 <kallisti> *didn't you know
15:53:13 <kallisti> it has an associated runFast function that's useful to avoid all of that awkward monad stuff.
15:53:47 <olsner> quicklyPerformIO
15:54:40 <zeratul> Is premature optimization even such a danger in more modern languages, it seems to me much of the risk is spending large amounts of time re-factoring imperative code for near to no benefit because the real problem isn't poorly understood. But if you take a language like Haskell where compositional programs are easier to write, you end up spending less time investigating these blind alleyways and usually end up deciding not to make such a silly mistake afterwa
15:54:42 <Jafet> I knew there had to be a reason for unsafeSTToIO.
15:55:16 <jfischoff> zeratul: true that
15:55:33 <zeratul> isn't well understood even
15:55:37 <Jafet> zeratul: there is no programming language where the elegant programs are easier to write than the hackjobs
15:56:01 <mike-burns> You still need to use the right data structure for the job.
15:56:22 <Jafet> Unless you consider HQ9 a programing language.
15:56:23 <mike-burns> Someone was working on a library that automated that, but I don't remember any more details now.
15:56:35 <jfischoff> I think there is an order of priorities, logical correctness is first
15:57:15 <kallisti> a good understanding of data structures and algorithms is a different from premature optimization, however.
15:57:19 <RichyB> Jafet, it's more of a domain-specific language. :)
15:57:21 <cbm80> is there a way to find out what versin of ghc my current ghc was build with?
15:58:41 <td123> dunno if that's possible, cause there's a stage1 and a stage2 compiler :P
15:58:54 <cbm80> hmm
15:59:08 <td123> nvm
15:59:10 <td123> ghc -v
15:59:24 <td123> "Glasgow Haskell Compiler, Version 7.4.1, stage 2 booted by GHC version 7.0.3"
15:59:25 <cbm80> ah ok, thx
15:59:37 <cbm80> Glasgow Haskell Compiler, Version 7.4.1, stage 2 booted by GHC version 7.4.1
16:09:52 <dibblego> can someone please give me a hint what this message is about? http://paste.pocoo.org/show/554249/
16:11:34 <shachaf> dibblego: Have you tried using -v?
16:11:50 <dibblego> yes it lists a lot of packages and hides them for an unspecified reason
16:12:16 <dibblego> I'll just reinstall ~/.ghc and ~/.cabal I am getting used to having to do that now
16:13:11 * shachaf only recalls ever doing that once.
16:13:17 <shachaf> Maybe you should look into cabal-dev if you do that a lot?
16:13:45 <dibblego> yeah good idea
16:14:00 <cmccann> dibblego, do you have those packages installed?
16:14:18 <dibblego> cmccann: I didn't think so, nor do I see them with ghc-pkg list
16:14:21 <cmccann> I get that message if I use -hide-package with a package that ghc doesn't know about
16:14:52 <dibblego> where did the -hide-package come from I wonder?
16:15:30 <shachaf> dibblego: Maybe it's in your .ghci?
16:15:41 <dibblego> I deleted that thinking perhaps, but no change
16:16:01 <cmccann> is your ghci anything fishy, like a shell script that calls the real one with arguments?
16:16:23 <shachaf> cmccann: That's not very fishy. :-)
16:16:32 <dibblego> http://paste.pocoo.org/show/554257/
16:16:58 <cmccann> shachaf, well, it is if it uses fishy arguments
16:17:13 <shachaf> dibblego: Does ghc complain with the same error?
16:17:31 <shachaf> What happens if you rename your .ghci to something else and try to run ghci?
16:17:38 <shachaf> What happens if you use ghc --interactive?
16:18:20 <alpounet> DanBurton, regarding readline -> haskeline, maybe you should ask the maintainer(s)?
16:18:27 <alpounet> that would be great not to have to rely on a C library
16:18:27 <dibblego> er, I just copied my old ~/.ghc and ~/.cabal back to check and the error message disappeared, but then I just cabal install a local package and it came back, so I assume it's because of that package
16:18:44 <alpounet> (as far as i understand, haskeline is standalone, right?)
16:18:54 <cmccann> dibblego, something to do with that package convincing it to hide nonexistent packages I guess?
16:19:09 <dibblego> cmccann: alas, I found it in $PACKAGE/.ghci
16:19:11 <DanBurton> yes I believe so
16:19:19 <shachaf> alpounet: The issue with readline is licensing, not that it's a C library.
16:19:39 <dibblego> cmccann: if I exit out of that directory, so that ./.ghci does not exist, the message disappears
16:19:40 <DanBurton> alpounet: I'm not sure which part of lambdabot uses readline, though. It has a lot of sub-modules which seem to have a smattering of maintainers
16:19:48 <shachaf> Oh, ./.ghci
16:19:53 <shachaf> Hmm.
16:20:02 <cmccann> dibblego, what's in that .ghci? is that what you pasted?
16:20:02 <shachaf> Can you put :!system rm -rf in ./.ghci?
16:20:11 <dibblego> yes, I just happened to be using a local project that has this in its .ghci
16:20:28 <dibblego> cmccann: No, that was ~/.ghci where I am talking about LOCAL_PACKAGE/.ghci
16:20:33 <alpounet> shachaf, yeah but I think the reason why DanBurton is hoping for a replacement of readline by haskeline is more about dropping a C library dependency
16:20:36 <shachaf> Er, no "system" involved.
16:20:49 <DanBurton> yeah that's what I was thinking
16:20:50 <cmccann> dibblego, right, so I'm wondering what's in the other .ghci
16:20:52 <shachaf> haskeline is pretty terrible as far as readline compatibility goes.
16:21:06 <dibblego> cmccann: http://paste.pocoo.org/show/554259/
16:21:12 <shachaf> Who cares about depending on C libraries? It's not as if you're not going to do that anyway.
16:21:18 <cmccann> oh, haha
16:21:21 <cmccann> yeah I guess that explains it
16:21:23 <shachaf> Rewriting something because of the language it's written in is ridiculous.
16:21:27 <DanBurton> although I am also aware of the license issue. The Racket REPL doesn't have the handy readline things unless you explicitly import the bindings, in order to avoid the license issues
16:21:29 <alpounet> shachaf, it makes lambdabot's installation easier
16:21:40 <alpounet> that's the point of that change I think
16:21:47 <dibblego> cmccann: yeah, just a bit annoyed that ghci -v didn't list this
16:21:55 <shachaf> I wish haskeline wasn't so terrible a readline replacement.
16:22:10 <cmccann> dibblego, indeed
16:22:11 <shachaf> I didn't realize that ghci just read ./.ghci wherever it was.
16:22:11 <DanBurton> shachaf: well you know...it is open source ;)
16:22:17 <DanBurton> @package haskeline
16:22:17 <lambdabot> http://hackage.haskell.org/package/haskeline
16:22:22 <cmccann> I would think "what .ghci files are being loaded" would be an obvious thing to say with -v
16:22:37 <alpounet> shachaf, what's terrible in haskeline?
16:22:44 <alpounet> (never used it so i actually am wondering)
16:23:13 <hpaste> sjmurdoch pasted “Function to split every n characters” at http://hpaste.org/64071
16:23:23 <shachaf> alpounet: Subtle readline incompatibilities.
16:23:45 <shachaf> It's almost-but-not-quite readline, which is very frustrating because you can't rely on any readline behaviors.
16:24:15 <DanBurton> sjmurdoch1: you could use splitAt instead of using take and drop separately
16:24:33 <DanBurton> > splitAt 3 [0..5]
16:24:33 <lambdabot>   ([0,1,2],[3,4,5])
16:24:50 <shachaf> Or you could use the function that already exists in Data.List.Split that doest his.
16:25:02 <DanBurton> if you don't mind installing the split library
16:25:14 <Ralith> byorgey: you offered to give me advice on the OutsideIn(X) paper a while back? Well, I've hit upon my first significant failure to follow something: Just what do the authors use the # operator to mean?
16:25:16 <shachaf> Yes.
16:25:21 <DanBurton> is there anything holding back the split library from being in the haskell platform?
16:25:29 <hpc> @hackage split
16:25:30 <lambdabot> http://hackage.haskell.org/package/split
16:25:42 <sjmurdoch1> DanBurton: I tried to use splitAt, but didn't see how that would make it easier
16:26:12 <hpaste> sjmurdoch pasted “Function to split every n characters (using splitAt)” at http://hpaste.org/64072
16:26:13 <DanBurton> sjmurdoch1: (h,t) = splitAt n xs
16:27:41 <DanBurton> :t unfoldr
16:27:42 <lambdabot> forall b a. (b -> Maybe (a, b)) -> b -> [a]
16:28:04 <DanBurton> :t splitEvery
16:28:05 <lambdabot> Not in scope: `splitEvery'
16:28:40 <sjmurdoch1> DanBurton: Ah, I missed out the brackets around (h,t) so got a syntax error
16:28:57 <sjmurdoch1> (in my first attempt using splitAt)
16:29:01 <DanBurton> @let splitEvery n = unfoldr (\xs -> if null xs then Nothing else Just (splitAt n xs))
16:29:01 <lambdabot>  Defined.
16:29:10 <DanBurton> > splitEvery 2 [1..10]
16:29:12 <lambdabot>   [[1,2],[3,4],[5,6],[7,8],[9,10]]
16:29:27 <DanBurton> there's another way using an unfold ^
16:29:54 <DanBurton> > splitEvery 2 [1..3]
16:29:55 <lambdabot>   [[1,2],[3]]
16:30:09 <ion> > let f n = unfoldr (\xs -> splitAt n xs <$ guard (null xs)) in f 2 [1..10]
16:30:10 <lambdabot>   []
16:30:26 <Axman6> notNull?
16:30:30 <ion> > let f n = unfoldr (\xs -> splitAt n xs <$ (guard . not . null) xs)) in f 2 [1..10]
16:30:31 <lambdabot>   <no location info>: parse error on input `)'
16:30:36 <ion> > let f n = unfoldr (\xs -> splitAt n xs <$ (guard . not . null) xs) in f 2 [1..10]
16:30:37 <lambdabot>   [[1,2],[3,4],[5,6],[7,8],[9,10]]
16:31:00 <DanBurton> :t (<$)
16:31:01 <lambdabot> forall a (f :: * -> *) b. (Functor f) => a -> f b -> f a
16:31:08 <HugoDaniel> hi
16:31:19 <sjmurdoch1> shachaf: Thanks, I didn't know about Data.List.Split
16:31:30 <DanBurton> HugoDaniel: hi
16:32:10 <DanBurton> @pl \n -> unfoldr (\xs -> splitAt n xs <$ (guard . not . null) xs)
16:32:11 <lambdabot> unfoldr . (`ap` (guard . not . null)) . ((<$) .) . splitAt
16:32:21 <DanBurton> perfect..
16:32:42 <ion> hah
16:32:58 <DanBurton> and this, kiddies, is why we sometimes need points.
16:33:20 <ion> > let f n = unfoldr ((<$) <$> splitAt n <*> guard . not . null) in f 2 [1..10]
16:33:22 <lambdabot>   [[1,2],[3,4],[5,6],[7,8],[9,10]]
16:33:31 <DanBurton> ion: much nicer
16:33:41 <ion> No, it’s horrible. :-P
16:33:45 <shachaf> DanBurton: Or to write in a language that's designed to be point-free.
16:34:10 <shachaf> Rather than Haskell where it's a thing you use in special cases where it happens to be nice.
16:34:12 <ion> If you see “(<$) <$> …” something has gone horribly wrong.
16:34:22 <DanBurton> does banana syntax work with infix operators?
16:34:22 <otters> @src unfoldr
16:34:22 <lambdabot> unfoldr f b  = case f b of
16:34:22 <lambdabot>    Just (a,new_b) -> a : unfoldr f new_b
16:34:22 <lambdabot>    Nothing        -> []
16:34:34 <DanBurton> (| splitAt n <$ guard . not . null |)
16:35:04 <DanBurton> unfoldr is so beautiful <3
16:35:13 <otters> what is banana syntax
16:35:36 <DanBurton> I'm not entirely sure. It's magical syntax I've seen on rare occasion that seems to make applicative stuff magically work
16:35:42 <otters> sweet!
16:35:45 <otters> that's all I need to know
16:36:58 <alpounet> that'd be fun to have -XBanana
16:37:11 <sjmurdoch1> ion, DanBurton, others: Thanks for the alternative constructions. Some features there I'm not familiar with so I will need to look at them in more detail
16:37:14 <cmccann> idiom brackets?
16:37:15 <DanBurton> {-# LANGUAGE Bananas #-}
16:37:38 <cmccann> @quote idiom.brackets
16:37:38 <lambdabot> cmccann says: Idiom brackets are where you consume a mixture of alcohol and Conor McBride papers until your vision gets blurry enough that you can't actually see the Applicative operators anymore.
16:37:39 <DanBurton> cmccann: I'm not sure what the proper name is. probably that.
16:37:39 <vodik> {-# LANGUAGE Pickles #-}
16:38:05 <ion> instance Pickled Cucumber
16:38:19 <nyingen> there is a library for pickling with XML
16:38:29 <DanBurton> import Lenses, Envelopes, BarbedWire ;)
16:39:29 <ion> @quote
16:39:29 <lambdabot> mikeash says: you may have noticed that templates being turing complete theoretically allows you to add any language capability to C++.... so did the boost guys.
16:39:31 <ion> @quote
16:39:31 <lambdabot> byorgey says: a bus error? try recompiling with -fsubway, perhaps
16:43:48 <alpounet> haha
16:47:10 <Jafet> @ghc
16:47:11 <lambdabot> ghc says: Ambiguous constraint
17:08:43 * hackagebot monad-fork 0.1 - Type class for monads which support a fork operation.  http://hackage.haskell.org/package/monad-fork-0.1 (ShaneOBrien)
17:13:53 <confab> @hoogle <+>
17:13:53 <lambdabot> Control.Arrow (<+>) :: ArrowPlus a => a b c -> a b c -> a b c
17:13:53 <lambdabot> Language.Haskell.TH.PprLib (<+>) :: Doc -> Doc -> Doc
17:13:53 <lambdabot> Text.PrettyPrint.HughesPJ (<+>) :: Doc -> Doc -> Doc
17:14:02 <otters> @src <+>
17:14:02 <lambdabot> Source not found. It can only be attributed to human error.
17:14:17 <confab> :t <+>
17:14:17 <lambdabot> parse error on input `<+>'
17:14:24 <mhitza> :t (<+>)
17:14:24 <otters> :t (<+>)
17:14:25 <lambdabot>     Ambiguous occurrence `<+>'
17:14:25 <lambdabot>     It could refer to either `Control.Arrow.<+>', imported from Control.Arrow at State/L.hs:5:0-19
17:14:25 <lambdabot>                           or `Text.PrettyPrint.HughesPJ.<+>', imported from Text.PrettyPrint.HughesPJ at State/L.hs:53:0-46
17:14:25 <lambdabot>     Ambiguous occurrence `<+>'
17:14:25 <lambdabot>     It could refer to either `Control.Arrow.<+>', imported from Control.Arrow at State/L.hs:5:0-19
17:14:27 <lambdabot>                           or `Text.PrettyPrint.HughesPJ.<+>', imported from Text.PrettyPrint.HughesPJ at State/L.hs:53:0-46
17:14:29 <confab> ah
17:14:29 <mhitza> :)
17:14:30 <otters> sorry
17:14:44 <confab> :t Control.Arrow.<+>
17:14:45 <lambdabot> parse error on input `Control.Arrow.<+>'
17:14:50 <confab> oh i give up
17:15:01 <mhitza> :t Control.Arrow.(<+>)
17:15:02 <otters> :t Control.Arrow.(<+>)
17:15:02 <lambdabot> Couldn't find qualified module.
17:15:02 <lambdabot> Couldn't find qualified module.
17:15:04 <otters> hm
17:15:11 <mhitza> :|
17:16:07 <mhitza> it's (<+>) :: ArrowPlus a => a b c -> a b c -> a b c
17:16:10 <mauke> :t (Control.Arrow.<+>)
17:16:11 <lambdabot> forall (a :: * -> * -> *) b c. (ArrowPlus a) => a b c -> a b c -> a b c
17:18:41 <confab> i still have no clue what that does
17:31:17 <DanBurton> trying to install Euterpea library...second time today I've been bitten by the removed Eq => Num constraint >,<
17:33:13 <DanBurton> fortunately it only affected 2 functions in that file...
17:33:25 <DanBurton> *crosses fingers as compliation continues*
17:37:53 <mhitza> how could I convert a Text to ByteString?
17:37:54 <byorgey> preflex: seen Ralith
17:37:55 <preflex>  Ralith was last seen on #haskell 1 hour, 12 minutes and 40 seconds ago, saying: byorgey: you offered to give me advice on the OutsideIn(X) paper a while back? Well, I've hit upon my first significant failure to follow something: Just what do the authors use the # operator to mean?
17:38:56 <jfischoff> mhitza: do you mean in a optimal sense?
17:39:27 <mhitza> jfischoff, what would optimal mean here?
17:40:18 <jfischoff> mhtiza: I don't know the fastest way, but I can tell you a way
17:40:56 <mhitza> jfischoff, don't need the fastest way (not dealing with big blocks of text)
17:41:23 <jfischoff> mhitza: BSC.pack . T.unpack
17:41:33 <jfischoff> where T is Text
17:41:50 <jfischoff> and BSC is Data.ByteString.Char8
17:41:58 <mhitza> jfischoff, thank you
17:42:01 <jfischoff> np
17:42:12 <Enigmagic> and then you truncate everything to 8-bits
17:42:40 <jfischoff> oh really
17:42:41 <Enigmagic> Data.Text.Encoding.encodeUtf8
17:42:49 <Enigmagic> converts it to a bytestring with utf-8 encoding
17:42:56 <jfischoff> alright
17:43:00 <Enigmagic> there are equivalent functions for utf-16 and utf-32
17:43:04 <mhitza> Enigmagic, good to know, albeit im dealing with ascii charset
17:43:27 <jfischoff> yeah Enigmagic thanks
17:43:34 <Enigmagic> mhitza: it's still likely to be faster than using unpack/pack
17:49:22 <DanBurton> @quote
17:49:22 <lambdabot> Botty says: holy crap, knew smerdy sounded familiar - about 2 years ago he was trying to convince me to throw out my mouse
17:49:43 <DanBurton> ...wat
17:50:03 <DanBurton> @quote arrow
17:50:03 <lambdabot> Syzygy- says: Why do I get the feeling that the arrow code was written during "Speak like a pirate day"?
17:50:17 <jfischoff> @quote
17:50:17 <lambdabot> lament says: OOH SHINY ILLNESS
17:51:57 <scooty-puff> monochrom, so a while ago today i was wondering if when beginning the backtracking search for a set of variables, some constraints could be used to define dependencies, such that only each strongly connected group had to be searched together
17:52:17 <byorgey> @tell Ralith  a # X  is standard notation meaning "a is fresh for X", that is, the name a does not occur among the free variables of X
17:52:17 <lambdabot> Consider it noted.
17:52:32 <scooty-puff> p and q gave interdependencies - vars(p) `dep` vars(q), vars(q) `dep` vars(p)
17:52:39 <scooty-puff> p or q - could that be one way?
17:53:01 <scooty-puff> and is there a good way to go about thinking about this?  the only thing i have tried is to find a counter example, which does not seem optimal
17:55:25 <scooty-puff> (if anyone can cite any paper, feel free - i have doubts about doing this since i have not seen much related to it)
17:55:38 <scooty-puff> (or just common sense, etc.)
18:03:36 <gentleben> has any one here implemented Paxos?
18:03:52 <gentleben> specifically FastPaxos
18:08:12 <Veinor> hmm
18:08:21 <Veinor> how should i indicate in acid-state that an attempt to do something failed?
18:09:56 <td123> does haskell support dynamic linking of haskell libs? I'm just trying to figure out a haskell packages life
18:10:10 <td123> er first haskell -> ghc
18:10:50 <td123> I was always under the impression that they need to be statically linked
18:11:32 <Veinor> They do; there's a dynamic linking option in recent GHCs but I know nothing about it
18:12:40 <mike-burns> http://hackage.haskell.org/trac/ghc/wiki/SharedLibraries/PlatformSupport - there's this.
18:13:19 <mike-burns> http://hackage.haskell.org/trac/ghc/wiki/SharedLibraries - well, this is the starting point I suppose.
18:13:51 <td123> the first link is 3 years old :P
18:15:34 <td123> I was reading over: http://www.haskell.org/ghc/docs/7.0.3/html/users_guide/using-shared-libs.html and it just stuck out "In GHC version 6.12 building shared libraries is supported for Linux on x86 and x86-64 architectures"
18:20:11 <yescalona> http://tryhaskell.org/ is broken??? I only get Terminated! in the console. Anyone can try please if this webpage works?
18:20:44 <mike-burns> http://trylambda.com/ is up, if you want to get down to the metal.
18:21:45 <cwl> Which program will complain "<built-in>:0:4: lexical error (UTF-8 decoding error) " ? cabal or ghc
18:21:47 <yescalona> mike-burns, :)
18:22:12 <shachaf> mike-burns++
18:22:30 <shachaf> mike-burns: The cursor disappears when the window loses focus and doesn't seem to come back.
18:22:49 <mike-burns> Wild. Clicking brings it back for me.
18:23:27 <shachaf> Oh, so it does.
18:23:35 <shachaf> I guess I can click.
18:23:42 <shachaf> Are all variables one character long?
18:23:44 <nze> hi #haskell
18:24:29 <shachaf> mike-burns: I think the evaluator either has some bugs or I don't understand it.
18:24:43 <mike-burns> It's likely to be buggy.
18:24:45 <cmccann> mike-burns, what is this untyped heresy?! D:
18:24:55 <mike-burns> I knocked it out one night as a joke, and haven't looked back.
18:25:02 * cmccann files a bug report that it isn't using System F
18:25:03 <mike-burns> cmccann: Hah.
18:25:06 <mike-burns> Ahaha.
18:25:15 <nze> i'm trying to get a working haskell install at my university workspace, which means no package management but compiling everything myself
18:25:30 <shachaf> cmccann: What, you hate the function (\f x -> f (f x)) that much?
18:25:50 <cmccann> incidentally, coding in system f is a great way to discover new appreciation for type inference
18:26:04 <mike-burns> Yes, same with Java.
18:26:07 <cmccann> haha
18:26:16 <cmccann> except system f is actually decent otherwise
18:28:27 <shachaf> mike-burns: Are free symbols supposed to just evaluate to themslves? E.g. "a" => "a"
18:28:33 <mike-burns> Yeah.
18:28:46 * hackagebot hp2html 0.1 - A tool for converting GHC heap-profiles to HTML.  http://hackage.haskell.org/package/hp2html-0.1 (IavorDiatchki)
18:29:40 <mike-burns> It just does WHNF, if I have my terminology right.
18:29:58 <shachaf> Where it can't evaluate "a" further so it just leaves it as is?
18:30:34 <shachaf> I'm not sure I understand why "a" => "a" and "(\x.x x) a" => "Maximum call stack size exceeded"
18:31:06 <mike-burns> Nope, no idea either. Might be a bug.
18:31:14 <cmccann> perhaps the maximum call stack size is 1?
18:31:21 <cmccann> that would certainly simplify the interpreter
18:31:25 <mike-burns> Actually, "a a" also does that. Bizarre that I never noticed this.
18:32:06 <shachaf> Oh, so it does.
18:32:21 <shachaf> So does "a b".
18:32:38 <shachaf> In conclusion, I don't know how this works. Maybe I should read the source.
18:33:10 <mike-burns> http://goo.gl/b5mBw - this is the relevant part.
18:38:44 <shachaf> mike-burns: Well, it's line 16 when expr[1] is a VarExpr.
18:43:46 * hackagebot mathblog 0.4 - A program for creating and managing a static  weblog with LaTeX math and function graphs  http://hackage.haskell.org/package/mathblog-0.4 (JonathanDaugherty)
18:47:57 <mike-burns> Oh, I see. Yeah.
18:50:43 <cwl> I have post one question http://stackoverflow.com/questions/9371438/cabal-install-complains-built-in04-lexical-error-utf-8-decoding-error
18:53:46 * hackagebot LambdaPrettyQuote 0.0.0.1 - Parser, pretty printer, quasiquoter, and Arbitrary helpers for the untyped lambda calculus.  http://hackage.haskell.org/package/LambdaPrettyQuote-0.0.0.1 (JonathanFischoff)
18:53:48 * hackagebot vowpal-utils 0.1.2 - Vowpal Wabbit utilities  http://hackage.haskell.org/package/vowpal-utils-0.1.2 (CarterSchonwald)
18:58:26 <nze> how does bootstrapping ghc work?
18:59:19 <shachaf> By His Bootstraps
18:59:24 <nze> when i get the source package, ./confiure fails telling me that "GHC is required unless bootstrapping from .hc files"
18:59:53 <shachaf> nze: You need GHC to compile GHC.
18:59:53 <nze> which means i have to get one of the binary packages?
19:00:04 <shachaf> Pretty much.
19:00:17 <shachaf> Just like with gcc.
19:01:40 <nze> which come with binaries linked against /lib64 , which contains an outdated version of the glibc (2.5 ie 2007)
19:01:51 <nze> (the binary package)
19:04:02 <td123> nze: just install your distro's package manager and then remove it later
19:04:32 <shachaf> I wonder
19:04:34 <shachaf> Er.
19:04:35 <td123> install with** you certainly don't want to rm your distro's pm :P
19:05:56 <nze> td123: that's what i'd do if i was root :) i'm trying to do this at my uni
19:06:54 <nze> would it be possible to build an older version of ghc (2007ish) against that libc and then use it to build a newer one?
19:08:25 <td123> nze: have you considered asking them to install ghc?
19:10:21 <nze> td123: haven't really thought about that. valid suggestion though
19:10:53 <mike-burns> nze: What OS are you on?
19:11:59 <shachaf> nze: You could also install 32-bit GHC.
19:12:17 <shachaf> Though I think that'd cross-compile the 64-bit version.
19:12:34 <shachaf> Anyway, an older GHC could probably compile a newer one, yes.
19:12:49 <shachaf> Certainly in the worst case you could get an older GHC and compile up one minor release at a time.
19:14:05 <nze> it's scientific linux, 5 if i'm not mistaken. but our it department is just really crappy with keeping the system up to date (ie. less than 3-years-outdated)
19:14:44 <nze> ghc 6.10 seems done compiling, busy installing
19:14:46 <shachaf> You could compile GHC linked against the right libraries on another machine and then move it over.
19:14:57 <shachaf> Why are you installing 6.10?
19:15:29 <td123> how about, setting up ghc at home and sshing in from your uni computer?
19:16:10 <nze> shachaf: i first tried with the latest one, but it doesn't work with the ancient libc
19:16:31 <shachaf> nze: Why are you compiling GHC 6.10, though?
19:16:41 <shachaf> If you're compiling the version of libc it's linked against shouldn't matter, should it?
19:17:57 <nze> td123: amongst other things i want to get xmonad, so ssh'ing out from there kind of defies the whole idea of window management
19:18:40 <shachaf> nze: You can run a window manager over SSH!
19:18:45 <shachaf> (But you don't want to.)
19:19:20 <mike-burns> I ran GNOME2 over SSH when my university only had GNOME1.
19:19:30 <mike-burns> You definitely don't want to.
19:19:41 <shachaf> mike-burns: And now your university only has GNOME3 and you still run GNOME2 over SSH?
19:19:53 <mandaya> shachaf: I've never thought of that... for some reason I want to try it now... just how bad of an idea are we talking?
19:19:59 <mandaya> kinda sorta bad
19:20:03 * shachaf found it difficult to believe how bad they managed to make GNOME3.
19:20:08 <mike-burns> I love GNOME3.
19:20:38 <mandaya> or you should just hold the power button down at this point kinda bad
19:20:38 <shachaf> mandaya: Well, X is network-transparent, so it should "just work". The only issue is the latency.
19:20:52 <shachaf> mike-burns: :-(
19:21:05 <shachaf> Are you the user they made GNOME3 for?
19:21:24 <mike-burns> Nah; no one makes software for me. But it's pretty and stays out of my way.
19:22:23 <td123> nze: hmm, how about settling for an alternative and maximizing a single terminal window and running tmux on it :)
19:22:41 <Makoryu> Using tmux as your window manager?
19:22:53 <nze> td123: meh.. more of a screen guy :p
19:23:35 <strlen> would anyone be interested in a quick critique of some code i've written? i am just starting to get my feet wet in haskell, and have ported something I recently wrote in Java (https://github.com/afeinberg/voldemort/blob/32744e33affff6d18b1d5124a090dea7bf5befa4/src/java/voldemort/store/stats/Histogram.java) to Haskell. Anything horribly wrong that I am doing in Haskell? https://gist.github.com/1873230
19:24:18 <mike-burns> strlen: Use pattern guards.
19:24:30 <scooty-puff> btw, anyone know about ghc-mod?
19:24:43 <scooty-puff> i mention it because its kind of nice - adds flymake and other stuff to emacs
19:24:51 <scooty-puff> (just got it working and very excited)
19:24:51 <strlen> mike-burns: in place of if-else or for matching on the record?
19:25:09 <mike-burns> strlen: In compareToBucket, at least.
19:25:20 <shachaf> mike-burns: By pattern guards do you just mean guards?
19:25:25 <mike-burns> Yeah.
19:25:25 <strlen> mike-burns: would it work with the where?
19:25:40 <strlen> mike-burns: so i can use a pattern guard and a where below? going to try that
19:25:54 <scrutr> are there any good, easy to use configuration file parsers out there?
19:26:00 <mike-burns> strlen: Give some things a try. You might need to make an auxilary function, and that's very OK to do.
19:26:12 <Makoryu> strlen: Quick style tip. Function application binds higher than any operator, so you can always write "foo bar + baz" instead of "(foo bar) + baz"
19:26:16 <strlen> mike-burns: makes perfect sense, thanks
19:27:11 <mike-burns> :t (!)
19:27:12 <lambdabot> forall i e. (Ix i) => Array i e -> i -> e
19:27:26 <mike-burns> Is (!) partial?
19:27:42 <shachaf> Yes.
19:27:49 <shachaf> Well, maybe.
19:27:55 <shachaf> Depends on your index type, I guess.
19:28:06 <mike-burns> Oh interesting, yeah.
19:28:11 <strlen> thanks guys, this is highly helpful
19:28:13 <mike-burns> I wonder if strlen should watch out for that.
19:28:33 <shachaf> strlen: If you use hpaste.org instead of gist, it'll automatically run hlint on your code, which would say some of the things people in here are saying. :-)
19:28:41 <strlen> going to take another stab at this.
19:29:08 <strlen> anyone got a quick elisp macro to auto-paste to hpaste from :-)?
19:29:35 <shachaf> You can also just install hlint yourself, of course. :-)
19:30:46 <shachaf> But you'd get something like http://hpaste.org/64079
19:31:04 <strlen> yeah, just tried that
19:31:05 <strlen> this is neat
19:31:09 <strlen> and install hlint now too
19:31:22 * shachaf notes that none of the comments so far have been about the actual code itself.
19:31:24 <mike-burns> I've been replaced by script!
19:31:31 <strlen> this is really cool
19:31:38 <shachaf> Which would probably be much more helpful. :-)
19:31:58 <mike-burns> Oh I'm only into programming because code looks nice.
19:31:59 <strlen> i think the actual code could be more generic, but right now i just wanted to learn how Data.Array works
19:32:29 <strlen> the java version only uses int, since if I were to make it generic, then there'd be huge performance hit for boxing and unboxing
19:32:34 <shachaf> strlen: Things like foo | x = ... | otherwise = if y then ... else ... can be replaced with three guards.
19:33:06 <MiggyX> Hi guys, what's the idiomatic way to create an infinite loop in the main method? For example, I have a function that blocks until it receives a message, but I want to keep that loop running indefinitely...
19:33:14 <mike-burns> :t forever
19:33:15 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m a -> m b
19:33:16 <shachaf> In GHC Ints are boxed too. :-) Though you can unpack them explicitly in some cases.
19:33:47 <strlen> shachaf: does the compiler try to auto unbox in some cases?
19:33:47 * hackagebot husk-scheme 3.5.3.1 - R5RS Scheme interpreter, compiler, and library.  http://hackage.haskell.org/package/husk-scheme-3.5.3.1 (JustinEthier)
19:34:04 <MiggyX> mike-burns, awesome thanks!
19:34:09 <edwardk> hrmm. how did i manage to miss this paper? http://cseweb.ucsd.edu/~rtate/publications/proofgen/
19:34:09 <lambdabot> edwardk: You have 1 new message. '/msg lambdabot @messages' to read it.
19:34:10 <strlen> shachaf: that said, i think i'll get to boxing/unboxing later
19:34:19 <shachaf> strlen: No -- for one, it couldn't because of strictness, and also you don't always want to unbox.
19:34:29 <shachaf> (Because if something else wants a boxed Int you'll need to repack it.)
19:34:43 <shachaf> If you have a strict field, though, you can compile with -funpack-strict-fields and GHC will unbox it.
19:35:09 <shachaf> But that's indeed not such a "get my feet wet in haskell" topic. :-)
19:35:18 <strlen> shachaf: yeah, exactly :-)
19:35:29 <edwardk> strlen: boxing in java and boxing in haskell have very different impacts. in java its just an extra dereference and some annoying garbage, so its a pure win to unbox
19:36:06 <nze> oh ffs
19:36:06 <nze> checking version of ghc... 6.10.4
19:36:08 <nze> configure: error: GHC version 6.12 or later is required to compile GHC.
19:36:18 <edwardk> in haskell, however, unboxed values can be thunks, delayed computations that will yield an answer later, so if you tried to unbox thm you might turn a terminating program into one that doesn't
19:36:19 <shachaf> nze: Well, you know what to do!
19:36:42 <shachaf> edwardk: Not with a strict field, though.
19:36:46 <td123> nze: that full screen terminal + screen is looking better and better :P
19:37:41 <edwardk> shachaf: there you have the problem that unboxing cannot be done parametrically
19:37:43 <strlen> edwardk: you meant 'boxed values can be thunks', right?
19:37:50 <shachaf> edwardk: Right.
19:37:51 <edwardk> strlen yes
19:38:26 <shachaf> That's why Haskell needs to be C++, obviously.
19:38:32 <edwardk> shachaf: hah
19:38:36 <strlen> i've done caml for a while, so i am still getting used to lazyness
19:39:06 <edwardk> strlen: laziness is what makes me love haskell.
19:39:09 <strlen> but that makes perfect sense (re: unboxing and strictness)
19:39:31 <strlen> edwardk: i like caml a lot, but so far what i am really digging are type classes and "deriving Show"
19:39:35 <edwardk> knowing that i can write two algorithms and just compose them and that laziness will deal with fusing the two away in an all but optimal fashion makes me very happy
19:39:56 <edwardk> deriving cuts a lot of boilerplate, yeah
19:40:13 <strlen> there is a campl4 extension that ads deriving based on first class modules though
19:40:17 <edwardk> but there isn't anything fundamental that keeps the ml crowd from er.. rederiving it
19:40:23 <edwardk> yeah
19:40:29 <shachaf> strlen: Beginners are often known to overuse type classes, so be careful. :-)
19:40:32 <strlen> ocaml 3.12 has first class modules, which are really nice
19:40:51 <strlen> shachaf: will be careful :-)
19:41:12 <edwardk> yeah type classes in some ways make us lazy. our modules are just a namespacing scheme, whereas there are times it'd be really nice to just parameterize one and open it, fixing a whole lot of types and values all at once
19:41:40 <strlen> it's easy to overuse (what ML calls) functors and modules in ML too, though
19:41:54 <edwardk> yeah, same general guidelines apply
19:42:34 <strlen> alright, going to do what hlint suggests now.. and couple more quick fixes in that style
19:43:00 <strlen> then will try to make a mutable Histogram (just started getting into State monad)
19:43:03 <strlen> thanks again
19:43:37 <MichaelBurge> If I have "filter (predicate) (huge_list)" running on GHCi, what's the best way to get a progress indicator every 5 seconds or so?
19:43:38 <shachaf> strlen: Mutable for what purpose?
19:43:56 <strlen> shachaf: based on a Mutable array. mainly just to learn how to use Mutable arrays and State
19:44:12 <shachaf> strlen: "State" is unrelated to mutable arrays.
19:44:37 <shachaf> You might be thinking of ST (which is a restricted version of IO).
19:44:58 <shachaf> (Well, calling it a restricted version of IO is a bit misleading.)
19:45:16 <strlen> shachaf: meant both, actually. Data.Array.ST arrays in ST Monad and also a version using immutable arrays but as an instance of State (if it makes sense)
19:45:37 <shachaf> strlen: "State" is just a wrapper for functions :: s -> (a,s)
19:45:41 <shachaf> Ah.
19:45:56 <strlen> shachaf: yep, that's what i wanted to do (re: wrap a function that way)
19:47:47 <strlen> alright, back to learning. lot of really cool stuff for me to cover
19:47:49 <shachaf> I'm not sure rushing to port algorithms on mutable arrays is the best way to "get your feet wet" with Haskell, though. :-)
19:48:41 <strlen> shachaf: well i worked through "yet another haskell tutorial", and am starting on Stanford CS240h
19:49:12 * shachaf does not much recommend YAHT.
19:49:21 <shachaf> Anyway, whatever works for you works for you, I suppose. :-)
19:49:28 <strlen> and am up to chapter 14 of RWH
19:49:47 <edwardk> strlen: real world haskell/learn you a haskell make a pretty good complementary introduction
19:50:08 <edwardk> LYAH is rather slow though
19:50:16 <strlen> edwardk: i like RWH a lot, yeah
19:50:38 <edwardk> it gets jumbled up in a few places where it uses stuff ahead of where it defines it, but not too badly
19:50:53 <shachaf> My view of LYAH is probably diminished somewhat by the fact that I've only read the parts of it that people get confused by.
19:51:00 <strlen> i did lot of the exercises from there as well, perhaps after I go through chapter 14/15 I'll try the mutable version
19:51:53 <strlen> my problem with several of the books is that they try to do an intro to "basic FP" whcih i am fairly familiar with (tail recursion, CPS, high order functions) after doing scheme and ML. but of course, lazyness really changes even the basics
19:52:08 <edwardk> usually i recommend http://books.google.com/books/about/Pearls_of_Functional_Algorithm_Design.html?id=ZQJnYoAmw6gC as a followup to RWH, since its good at teaching functional thinking
19:52:19 <edwardk> and it heavily uses laziness
19:52:21 <shachaf> strlen: Tail recursion is treated pretty differently in Haskell from most other languages, by the way.
19:52:44 <strlen> edwardk: ooh, thanks
19:53:15 <edwardk> and after that, my blog. ;)
19:53:33 <strlen> edwardk: your blog?
19:53:54 <edwardk> mentioned mostly tongue in cheek, but its at http://comonad.com/
19:54:10 <strlen> can't get to it, odd
19:54:15 <edwardk> gah
19:54:16 <MichaelBurge> edwardk: It looks like an interesting book, but for $50? :o
19:54:25 <strlen> $ host comonad.com
19:54:26 <strlen> Host comonad.com not found: 3(NXDOMAIN)
19:54:26 <edwardk> i've been having problems where half the internet can't seem to reach it today
19:54:28 <shachaf> Hmm, I can get to it.
19:54:34 <MiggyX> is anyone using MongoDB with Haskell? I'm trying to figure out if I can insert a document as JSON or if I have to jump through hoops to convert JSON -> BSON first...
19:54:48 <strlen> http://afeinberg.github.com/ <-- my blog, but completely unrelated to FP
19:54:50 <ivanm> edwardk: I can reach it
19:54:56 <strlen> (and i owe a blog entry long overdue)
19:55:15 <shachaf> edwardk is intimately familiar with every aspect of Haskell, except for the {- -} -- identifiers.
19:55:21 <shachaf> I don't think he found out about those yet.
19:55:32 <ivanm> edwardk: is that the book that came out end of 2010?
19:55:36 <strlen> although i've been toing with a walk through example of paxos implement in ML as a blog entry.
19:55:36 <edwardk> shachaf: yeah, its odd, it keeps shifting which half can't reach it ;)
19:55:41 <ivanm> shachaf: nah, he's used them to comment out code before :p
19:55:41 <edwardk> ivanm: sounds about right
19:55:49 <strlen> i'll order that book, pricey, but i see lot of great recommendations for it
19:55:49 <ivanm> edwardk: I dunno if I'd use it as a tutorial
19:55:53 <strlen> too bad there's no kindle version
19:56:10 <ivanm> it's definitely interesting, but I wouldn't consider it a book for haskell beginners
19:56:24 <ivanm> strlen: IIRC you can get a PDF
19:56:29 <edwardk> ivanm: he knows ocaml/scheme and will have worked through rwh by then. what i was point it out for was its use as a good crash course in really thinking in a pure functional manner
19:56:38 <ivanm> ahhh, right
19:56:41 <ivanm> yeah, fair enough then
19:56:42 <edwardk> once you have gotten through the basics
19:57:05 <edwardk> and unlike the crap on my blog, it doesn't have any category theory pre-requisites ;)
19:57:11 <ivanm> edwardk: heh
19:57:27 <edwardk> strlen: 198.22.64.69 is what it resolves to, not sure why half the internet can't resolve it
19:57:34 <shachaf> edwardk: Is it just a DNS issue?
19:57:38 <edwardk> strlen: if you nslookup comonad.com 8.8.8.8 does it come up?
19:57:52 <strlen> it does, yeah
19:58:01 <strlen> i am using comcast's default nameservers right now
19:58:01 * shachaf wonders what shiftedlands.com is.
19:58:03 <strlen> let me try my own nameserver
19:58:23 <edwardk> shachaf: yeah, its somehow dns related, but a bunch of nameservers seem to have forgotten i exist or nslookup as if i don't any more
19:58:28 <strlen> https://gist.github.com/346a8bd07ab082dad246 <-- works fine from my nameserver too
19:58:38 <ivanm> shachaf: apparently a LARPing website IIUC
19:58:39 <edwardk> but others still find me, and my timeouts aren't that long
19:58:49 <edwardk> ivanm: the main site on that ip is
19:59:20 <ivanm> oh, so people are going there instead of comonad reader?
19:59:32 <edwardk> no, it isn't resolving at all
20:00:04 <edwardk> the machine is doing name based resolution once you get there. the fact that shiftedlands.com is on the same ip is a red herring
20:00:26 <ivanm> obviously my web-fu is smaller than I thought; I didn't realise you could have two different domains on the same IP :s
20:00:28 <edwardk> the issue is happening earlier than that, because a bunch of folks get nslookup results that make it look like i don't exist
20:00:44 <nze> compiling latest ghc, i'll get some sleep and hope noone turns of that machine in the meantime
20:01:17 <edwardk> only thing thats changed is a couple months ago i swapped over to namecheap during the godaddy fiasco
20:01:27 <shachaf> edwardk: Do you use some weird nameservers or something?
20:01:37 <edwardk> nah, just whatever namecheap has
20:02:06 <MiggyX> comonad.com works fine here
20:02:16 <edwardk> strlen: can you get to kmett.com through your main dns server or is it also wigged out?
20:02:31 <strlen> edwardk: also wigged out via comcast
20:02:43 <edwardk> strange. they might have some weird issue with namecheap
20:03:08 <shachaf> strlen: What's your main DNS server's address?
20:03:35 <lispy> edwardk: kmett.com WFM
20:03:39 <strlen> i've been looking for dns hosting myself. i run my own dns servers with a friend running secondary ns, but that can mean quite a bit of overhead
20:04:02 <strlen> 75.75.75.75
20:04:07 <strlen> and 75.75.76.76
20:04:11 <strlen> is what dhcp sets resolv.conf to
20:04:31 <shachaf> Yes, that's the address I found online.
20:04:32 <shachaf> Weird.
20:05:12 <lispy> edwardk: my copy of conceptual mathematics should be here tomorrow.  I'm strongly considering coding up some of the ideas in idris or hol light
20:05:16 <edwardk> i just get REFUSED when i try to resolve off of it, but i'm not a comcast customer, so that doesn't say anything
20:05:38 <shachaf> edwardk: But it works for me for other hosts.
20:05:42 <lispy> I can reach it and I'm a comcast customer
20:05:57 <shachaf> Wait, maybe I'm using a Comcast Internet connection. I have no idea.
20:06:13 <edwardk> then as far as i'm concerned comcast is screwed up until i can determine otherwise
20:06:49 <edwardk> http://www.downforeveryoneorjustme.com/comonad.com says i'm up, so i'm up ;)
20:07:32 <ivanm> edwardk: I remember for a while where dibblego and I couldn't access MSR, and it seemed to happen sporadically for others as well
20:07:43 <ivanm> no common denominator regarding ISP, location, etc.
20:07:51 <MostAwesomeDude> comonad.com works from OSL's viewpoint.
20:08:01 <lispy> comonad/kmett both work from here (comcast)
20:08:10 <edwardk> meh. glitch in the matrix ;)
20:08:11 <Saizan> that MSR problem had something to do with your browser
20:08:19 <ivanm> Saizan: nope
20:08:23 <ivanm> tried different browsers
20:08:27 <ivanm> we couldn't even wget IIRC
20:08:33 <lispy> Saizan: chrome doesn't let you go to MSR now? ;)
20:09:31 <lispy> BTW, I found out why hackage went down
20:09:36 <lispy> it was an HVAC malfunction
20:09:36 <shachaf> Oh, I *am* using a Comcast DNS server.
20:09:47 <edwardk> lispy: hah
20:10:01 <ivanm> lispy: as in this? http://en.wikipedia.org/wiki/Hvac
20:10:04 <lispy> So me having keys to the kingdom to reboot wouldn't have helped
20:10:17 <lispy> ivanm: correct
20:10:31 <edwardk> lispy: the whole server room?
20:10:53 <lispy> edwardk: I think only like 3-4 servers were adversly affected
20:10:59 <edwardk> *nods*
20:11:06 <lispy> edwardk: but yeah, it was the server room's hvac that was screwy
20:11:16 <lispy> I think the hardware suddenly decided to do the wrong thing
20:11:29 <lispy> It was logging the temperature but not turning on
20:11:30 <edwardk> back when i actually had a data center, we had the air condiitoning die, and had to bring in half a dozen huge portable AC units to keep everything running
20:12:15 <dolio> You should stack them up and run them in your new office.
20:12:19 <dolio> That'll work, right?
20:12:20 <edwardk> (the old pre-56k general terminal servers generated a lot of heat!)
20:12:46 <shachaf> edwardk: Pre-56k?
20:12:55 <edwardk> i think i might have an old ascend terminal server lying around. if i ever need a griddle, I can plug it in somewhere
20:13:05 <lispy> heh
20:13:05 * shachaf didn't realize it was that long ago.
20:13:39 <lispy> ah modems
20:14:17 <edwardk> right around the switch over to 56k modems, the old ascend terminal servers which were bought by lucent used to contain the digital to analog converters to shift the entire set of lines for a couple of t1s to analog, and then had basically traditional modem hardware in them for 24-48 modems
20:14:45 <edwardk> because it was cheaper for them than to derive decent purely digital modems at the time
20:15:12 <edwardk> (this is one reason why livingston, (also bought by lucent) was beating the pants off them at the time
20:15:46 <lispy> because livingston had digital modems?
20:15:50 <edwardk> yeah
20:16:50 <lispy> I come from a pretty small town; I didn't really experience geek culture until college
20:16:56 <lispy> Naturally I was instantly hooked
20:17:13 <edwardk> then there was a bake off between k56flex (lucent) and x2 (USR) before everything settled down
20:17:22 <lispy> I sometimes think I missed out on the sort of experiences you had because of that though
20:17:54 <edwardk> meh. it warped my childhood. ;)
20:18:04 <shachaf> edwardk's experiences were due to not coming from a small town?
20:18:13 <lispy> I taught my self to rasterize randomly generated triangles in HS and I was the only one in my school that seemed to know anything about programming.
20:18:39 <edwardk> shachaf: =)
20:18:47 <lispy> ("taught" myself.  I had internet access and learned C after taking one class in visual basic programming)
20:19:16 <lispy> gave me quite the edge on undegraduate though (knowing how to program in two languages)
20:19:37 <shachaf> lispy: I think most people with $ESOTERIC_INTEREST were the only one in school to be interested in $ESOTERIC_INTEREST.
20:19:47 <edwardk> my experiences mostly come from being an opportunist and trying not to let projects pass me by
20:19:50 <edwardk> shachaf: hah
20:19:54 <lispy> shachaf: programming is an esoteric interest?
20:19:59 <shachaf> Pretty much.
20:20:03 <lispy> oh
20:20:08 <shachaf> Evidence: You were the only one in school who seemed to know anything about it.
20:20:16 <lispy> But I had a very small school
20:20:30 <lispy> about 450 students split across 5 grade levels
20:20:40 <strlen> there were a lot of people into programming in my school, but then again i went to high school in cupertino, CA
20:20:43 <edwardk> lispy: take the percentage of people who graduated from there who are now programmers. figure out how many would be in your graduating class
20:20:44 <shachaf> Eh. Sufficiently esoteric.
20:20:50 * shachaf 's high school was about the same size.
20:21:00 <edwardk> and then figure how many are actually good at it, because most programmers suck
20:21:12 <strlen> that said, far too many of them ended up going into business or pre-law.. or got CS degrees and went into finance and law anyway.
20:21:51 <lispy> shachaf: hmm...I don't know if any of the students I knew in HS went on to learn programming
20:22:18 <lispy> I'm always a little surprised when people don't want to know math/programming.  I kinda worry that something is wrong with them.
20:22:23 <ivanm> when I started high school, quite a few of us "programmed" during the lunch break just to have something to do
20:22:36 <lispy> ivanm: awesome
20:22:41 <strlen> there were folks who were writing their own muds too
20:22:45 <shachaf> lispy: I'm sure most people are surprised when you're not interested in $INTEREST.
20:22:54 <ivanm> as the computers were still using DOS (in 1999), and someone had found a helicopter bombing game written in Turbo Pascal and shared it around
20:23:06 <ivanm> so we kept tweaking it and playing it
20:23:13 <lispy> our lunches were 25 minutes counting the time to go to your locker before/after the "lunch period"
20:23:15 <edwardk> strlen: i was narrowly saved from a lifetime of mud coding by the fact that the isp that was hosting my mud lied to me for years about making backups
20:23:34 <shachaf> edwardk: Hah.
20:23:38 <edwardk> strlen: so when things finally died, the backups i was counting on weren't there, and i was free to do other things ;)
20:23:54 <lispy> edwardk: haha
20:23:59 <lispy> edwardk: and category theory has never been the same?
20:24:11 <shachaf> Backups are too easy these days.
20:24:21 <edwardk> lispy: nah, from there i went on to graphics and a phone company
20:24:33 <lispy> edwardk: is all of CT based on types or do people add types in to CT because types are nice?
20:24:43 <shachaf> lispy: Get your edwardk chronology straight.
20:24:48 <shachaf> edwardkology?
20:24:54 <lispy> heh
20:25:09 <jfischoff> edwardk: ever want to get back into graphics?
20:25:35 <jfischoff> geometric algebra is wanting for some CT
20:25:42 <edwardk> lispy: types don't quite fit with category theory well, because category theory is very much 'monomorphic' in its basic presentation. you need to talk about fibrations and bundles and crazy things to make the parametricity we take for granted make sense
20:25:44 <strlen> i did lot of graphics early on with turbo pascal and embedded assembly
20:25:51 <strlen> learned all about vesa modes
20:26:07 <edwardk> jfischoff: i have a whole approach to geometric coalgebra, and i still do graphics consulting
20:26:11 <c_wraith> didn't the beach boys sing about good fibrations?
20:26:16 <jfischoff> cool
20:26:31 <edwardk> jfischoff: a sketch of geometric coalgebra is in my algebra package
20:26:45 <jfischoff> checking ....
20:26:51 <lispy> edwardk: hmm hmm. Do any of the mathematical foundations base off of types then?
20:26:51 <strlen> then got more into network programming... then when i studied vector calculus and abstract algebra i began *really* wishing i stuck with graphics
20:26:54 <edwardk> http://hackage.haskell.org/packages/archive/algebra/2.0.4/doc/html/Numeric-Coalgebra-Geometric.html
20:27:19 <edwardk> lispy: well, its more that 'the category of types' is a nice category with lots of set-like properties
20:27:26 <lispy> edwardk: russel looked at types, but it seems that mathematicians at the time don't like types
20:27:39 <edwardk> so you can use a lot of tools from category theory when manipulating that category
20:27:49 <lispy> edwardk: oh I see.
20:28:13 <lispy> edwardk: do you feel that CT is superior to ZF in any way?
20:28:17 <edwardk> in fact most category theoretic constructions that don't need any sort of classical reasoning can be readily adapted to haskell set
20:28:39 <edwardk> well, they are equivalent in one sense, but in practice i find that CT is more useful to us programmer types
20:28:42 <jfischoff> awesome
20:29:03 <edwardk> because the primitives map almost directly on to what we use every day
20:29:08 <lispy> ah
20:29:21 <edwardk> whereas with set theory they encoding is a PITA ;)
20:29:25 <lispy> and what do we use everyday? functors and monads or something else?
20:29:38 <edwardk> functions make nice arrows for a category
20:29:51 <edwardk> we have a category with exponentials because functions themselves form objects, etc.
20:29:59 <lispy> haskell functions are nice arrows for a category? Or mathematical functions make nice arrows?
20:30:02 <edwardk> every functor in haskell is strong, lots of nice properties form
20:30:15 <edwardk> both =)
20:30:37 <edwardk> jfischoff: the approach used there lets you work with infinite dimensional geometric algebra
20:30:44 <lispy> I guess I'm wondering, say I switch to C.  Does CT still help me reason about C more than ZF would?
20:30:54 * shachaf wonders what a strong functor is.
20:31:09 <ivanm> shachaf: a Functor that works out *a lot* :p
20:31:11 <lispy> shachaf: a functor that can lift 10 times its own weight
20:31:17 * shachaf sighs.
20:31:18 <edwardk> at that point it starts to get muddier
20:31:34 <shachaf> Welcome to #haskell, where your questions are answered with off-topic jokes in majestic stereo!
20:31:38 <edwardk> the main issue is that ZF is really classically motivated
20:31:46 <ivanm> shachaf: heh
20:31:47 <edwardk> the very axiom of choice is non-constructive
20:31:53 <lispy> and CT is not classically motivated?
20:32:00 <jfischoff> edwardk: very cool. Have you ever talked to the Geometrics guys?
20:32:02 <edwardk> the language of category theory is less specific about that decision
20:32:11 <shachaf> edwardk: To be fair, the axiom of choice isn't part of ZF. :-)
20:32:22 <edwardk> in fact there is this whole notion of 'the internal language' of a category
20:32:25 <lispy> I read a footnote yesterday saying that homotopy type theory might have a constructive theorem that is morally equivalent to axiom of choice but computable
20:32:41 <edwardk> where you can have a category where the internal language is a logic that is classical, or constructive, or linear, etc.
20:33:05 <lispy> IIRC, it was refer to as comutable choice
20:33:10 <lispy> computable*
20:33:39 <clsmith> hey. i have a question: can System FC do anything untyped lambda calculus can't? :p and, if not, what can it do easier thanks to the type equality stuffs?
20:33:46 <lispy> Not that I see classical logic as bad, just weaker than constructive
20:34:04 <edwardk> shachaf: my point is more that i find the presentation of logics in category theory to be better thought out and nicer to work with than their ZF analogues.
20:34:10 <clsmith> or do i just need to read about GADTs? <.<
20:34:31 <edwardk> clsmith: yeah, it can catch you when you do something stupid ;)
20:34:40 <clsmith> lol
20:34:43 <lispy> clsmith: I doubt you'll encounter much about System Fc when studying GADTs even though the GADTs compile to type coercions in some cases
20:35:11 <lispy> clsmith: For me and understanding GADTs, it's really about type refinement.  You are in a local context and suddenly you have more information.
20:35:13 <clsmith> i'm specifically reading into ghc core, so learning system fc is sort of necessary :p
20:35:15 <edwardk> clsmith: that is actually very much the reasoning. using a typed intermediate language lets you run lint passes, and check that transformations preserve the correct typing of the code.
20:35:43 <edwardk> its pretty hard to write a transformation that is wrong subtly that takes a well typed program to a well typed program (of course its easy to make ones that are off a lot)
20:36:27 <lispy> error correcting codes for program transformations without quantifying the information theoretic bounds?
20:36:31 <edwardk> but as a sanity check, the use of a strongly typed core language has been very good for ghc
20:37:05 <rasfar> Boring question:  I commencing to compile GHC.  I'm currently building haskell-platform-2011.4.0.0, but can't find ghc-7.0.4 source which it's supposed to be matched with.  Should I attempt to compile ghc-7.4.0 (stable branch) instead?
20:37:25 <clsmith> for context, i'm trying to work out whether System FC could be implemented using a specific term rewriting system, and i've worked out that it can -- including explicit 'case' etc -- so long as the fact that System FC has type equality stuff doesn't make it be able to do some crazy thing untyped lambda can't, in which case more thinking might need to be done.
20:37:35 <lispy> rasfar: it should be "okay".  BTW, what fails when building 7.0.4?
20:37:46 <rasfar> just cannot find the source tarball!
20:37:52 <lispy> rasfar: the HP is "just" a set of packages at a specific version #.
20:38:23 <edwardk> clsmith: ultimately fc just desugars into applications of lambdas, there are some pedantic issues with order of evaluation because kind # evaluates strictly, and * lazily, but thats about it
20:38:24 <lispy> rasfar: http://www.haskell.org/ghc/download_ghc_7_0_4
20:38:41 <rasfar> thanks lispy
20:39:02 <lispy> rasfar: yw
20:39:06 <rasfar> maybe I should try stable anyways!
20:39:17 <clsmith> edwardk: so system fc just provides (1) type checks, (2) nicer stuff like case and let, and (3) a couple of issues regarding strictness?
20:39:55 <lispy> clsmith: well, ghc core is what has case/let
20:40:04 <lispy> clsmith: system fc is system f + type coercions
20:40:19 <clsmith> eh, the system fc paper i'm reading has case and let, but i understand they can basically be sugar
20:40:26 <edwardk> clsmith: yeah, the foo ~ bar checks can be delayed if necessary to runtime, (often in the presence of undecidableinstances) where they may get hand-checked strictly before they get used to avoid any situation where something of the wrong 'shape' gets passed anywhere
20:40:28 <lispy> clsmith: case/let are fortunately just nice to have things that are not theoretically interesting
20:41:56 <clsmith> alright, great. thanks all. :)
20:42:16 <lispy> clsmith: an important thing to keep distinct between Haskell and core is the strictness of case
20:42:50 <lispy> clsmith: It's easy to get mixed up and think they agree there
20:43:05 <lispy> but in Haskell case is only as strict as it needs to be for the match check to work
20:43:19 <lispy> (whereas in core it's actually strict)
20:43:23 <clsmith> whereas in core you can only match a single constructor anyway?
20:43:36 <edwardk> jfischoff: not yet. i've been steadily building up a body of work around this space, which relies on the fact that i need to shuffle a few of the infinities around that usually get used by mathematicians when talking about free modules/vector spaces
20:43:43 <lispy> Oh, I can't recall if that was a constraint or not
20:43:54 <lispy> It's been ~ year since I looked at core
20:44:05 <clsmith> i believe so. i think it's in the form 'K x y z ..', where K is a constructor and everything else is just variables
20:44:15 <clsmith> alternatively just 'x' or a constant
20:44:34 <lispy> > case Just 1 of x -> x -- This is lazy in Haskell
20:44:34 <lambdabot>   Just 1
20:44:48 <lispy> but I think if you had that same case in core it would evaluate the Just 1
20:44:54 <edwardk> clsmith: that and the fact that internally core gets the evaluated value even if you don't match it directly as such
20:45:00 <c_wraith> that's correct, it would do so in core
20:45:03 <lispy> > case undefined of x -> 1
20:45:04 <lambdabot>   1
20:46:07 <lispy> core is kind of a neat language by itself
20:46:25 <lispy> But, I guess that's like saying system F is cool.
20:52:25 <ddarius> It's saying System Fc is cool.
20:53:33 <jfischoff> edwardk: They were interested in haskell last year, no idea if they still are. I contacted Chris Doran to see if he was interested in trying to design a differential geometry lib in haskell based GA. No progress was made, but that was probably my fault
21:00:44 <edwardk> jfischoff: the main trick in my code is the use of e -> r as vectors (sans the usual finite # of non-zero entries condition) and (e -> r) -> r (subject to a linearity condition) as covectors, then working with covectors for almost everything
21:01:36 <edwardk> by moving the 'finiteness' to the number of places the covector samples its input, you get a nicely constructive linear algebra
21:02:37 <edwardk> and you also get a nice monad for covectors where every operation you can build with the monad, applicative, etc. classes correspond to safe linear operators
21:04:03 <edwardk> when applied to GA, the nice thing is the CPS'd looking covectors do much the same work that using individually optimized data structures for different blades/grades/etc typically does, it enables you to avoid working with lots of zeros.
21:04:37 <edwardk> in exchange for you occasionally wanting to memoize various results
21:06:23 <jfischoff> edwardk: I think focus on try to make GA really efficient is premature any way. I would much rather have a expressive geometric language
21:07:11 <jfischoff> focusing on maps instead of indices is more the spirit of GA anyway
21:07:47 <edwardk> jfischoff: well, the presentation here makes a difference of O(2^n) on many GA operations
21:07:54 <edwardk> where n is the dimensionality of the space
21:08:01 <edwardk> since that can be infinite....
21:08:09 <edwardk> ;)
21:08:25 <jfischoff> but those small infinities :)
21:08:47 <jfischoff> plus we really arent going above 5
21:09:00 <jfischoff> and that's what AWS is for
21:09:02 <edwardk> it lets me build a version once and for all, and just pick something to treat as a pseudo-scalar
21:10:16 <edwardk> of course that ignores the choice of basis, so you still have to fiddle with that
21:10:32 * cmccann didn't quite get the hang of efficiently using the geometric coalgebra stuff
21:10:42 <cmccann> not sure what I was doing wrong but I had things occasionally get incredibly slow
21:10:43 <jfischoff> won't you wait on that?
21:10:46 <jfischoff> anyway?
21:10:58 <edwardk> cmccann: you probably needed to throw memo in there in a few places
21:11:18 <cmccann> edwardk, I tried putting memo in there in every place that seemed remotely sensible and it didn't seem to do anything
21:11:21 <edwardk> wait on that?
21:11:24 <cmccann> like I said, not sure what I was doing wrong
21:11:25 <edwardk> cmccann: interesting
21:11:40 <jfischoff> edwardk: picking a basis
21:12:22 <cmccann> edwardk, and I was only using five dimensions anyway and doing mostly simple stuff so it was kind of perplexing
21:13:00 * cmccann shrugs
21:13:09 <edwardk> jfischoff: what i do in there is just work with a user supplied eigenbasis. but the way i do it i can build for instance all homogeneous spaces as one big infinite space, or add a distinguished negative dimension and go conformal, etf.
21:13:36 <edwardk> that way the code for the most part didn't care if you were working with 3 or 30 dimensions
21:13:57 <cmccann> I also found that I missed having dimensionality encoded explicitly to be honest
21:14:11 <jfischoff> I'm not informed enough to discuss, but I will definitely check it out
21:14:33 <cmccann> something like a pure bivector has semantic value that I like being able to track in the type system
21:14:37 <jfischoff> Its exciting to know there is something to play with :)
21:14:45 <edwardk> cmccann: yeah, its a bit awkward explicitly left contracting against some pseudo-scalar all the time
21:15:01 <edwardk> cmccann: ahh that might be it, were you not contracting?
21:15:23 <cmccann> anyway, all I was doing was making some points in the weird conformal +2 approach, rotating them around, then doing a projection to 2D and plotting them (with diagrams I think)
21:15:24 <edwardk> cmccann: the stuff in that module was more of a proof of concept than a finished design of course
21:15:54 <cmccann> I don't remember exactly what I was doing
21:16:14 <cmccann> probably did leave out a contraction somewhere that I needed one I guess
21:16:46 <edwardk> cmccann: the contraction will keep you from touching all those irrelevant empty higher dimensions
21:16:53 <cmccann> right
21:17:05 <cmccann> I did realize that much
21:17:32 <cmccann> but forgetting to do that in one place would probably explain why it suddenly went from fast to horrific for some operations
21:17:39 <edwardk> *nods*
21:17:49 <cmccann> anyway, been meaning to revisit the GA stuff at some point
21:17:53 <cmccann> heh, point
21:17:56 <cmccann> anyway
21:18:06 <edwardk> if i ever get around to encoding it for real i'll probably build in a notion of dimensionality
21:18:18 <edwardk> and just pretend my coalgebra is the algebra
21:19:18 <cmccann> yeah I was toying with type-level tags for that
21:19:35 <edwardk> *nods*
21:19:59 <cmccann> and some other misc. ideas, since I wanted to encode extra information for some stuff
21:20:04 <edwardk> its all a bit of a blur. i have mostly forgotten what was in the algebra package by now ;)
21:20:15 <cmccann> might be easier to remember what isn't it
21:20:20 <edwardk> hah
21:20:43 <edwardk> was a frantic couple of months =)
21:21:01 <cmccann> anyway, if I get back to doing something with GA I'll give the coalgebra another go
21:21:03 <edwardk> i just want poly kinds to be done so i can pick it back up again
21:21:10 <edwardk> *nods*
21:21:14 <edwardk> appreciate it =)
21:21:33 <cmccann> and if I still get weird performance I'll run it past you
21:22:03 <edwardk> sure. ddarius also expressed some interest in playing with it
21:22:06 <cmccann> and maybe make suggestions about a nicer API by way of complaining a lot
21:22:11 <edwardk> hah
21:22:21 <cmccann> but right now I'm directing my ire at acid-state
21:22:29 <edwardk> well, the main reason i added it was to showcase the dualization of the usual approach
21:22:54 <Ivoz> do you guys develop lambdabot?
21:22:55 <cmccann> and yeah, ddarius introduced me to the GA stuff in the first place
21:23:16 <shachaf> Ivoz: Nobody really develops lambdabot these days.
21:23:24 <shachaf> A while ago it was a sort of #haskell group project.
21:23:30 <edwardk> ivoz: most of the authors of lambdabot lurk in here from time to time
21:24:09 <Ivoz> does anyone develop 'lambdabot 2'?
21:24:48 <edwardk> not at present. there are a couple of bots individuals have cobbled together off lambdabot's codebase, but i don't know of any formal project for a successor
21:24:49 * cmccann wonders if he's just not using acid-state correctly because it seems like a pain to work with :T
21:25:29 <cmccann> obviously lambdabot 2.0 is pending the Caleskell 2012 report being finalized
21:26:03 <cmccann> sadly everyone is bikeshedding on the optimal number of successive fmaps
21:26:03 <jfischoff> cmccann: can hear your grips about acid state, I am considering checking it out
21:26:52 <Ivoz> cmccann: I'm afraid I'm a haskell newbie, so I can't share in your humour :(
21:27:17 <cmccann> Ivoz, that's more #haskell humor than haskell, really
21:28:27 <cmccann> jfischoff, mostly that it forces everything to be very monolithic if you want to keep all of its benefits
21:28:50 <cmccann> there's no notion--as far as I can tell--of general transactionality
21:29:18 <cmccann> only in combinations of the fixed set of primitive methods you define along with the acid-state type
21:30:32 <jfischoff> cmccann: does that mean, that for each type you are forced to write a lot of boilerplate, I'm confused by what you mean by monolithic
21:30:42 <parcs`> cmccann: i think there's a fix set of primitive methods to facilitate sending updates over a network
21:30:53 <cmccann> parcs`, yes, but that doesn't really help
21:31:35 <cmccann> jfischoff, if you have two separate acid-state values, as far as I can tell there's no way to get ACID guarantees for operations on both of them
21:31:49 <cmccann> only for operations on a single type
21:32:10 <jfischoff> cmccann: got it. So you have to make a lot of types to just get the atomicity you want I guess
21:32:27 <ddarius> lambdabot is on like version 4.
21:32:35 <tomprince> lispy: Most mathematican may pretend that they use ZF, but most don't actually use it, except maybe when writting. I suspect a larger number implictly use something looking like type theory, than ZF.
21:32:43 <cmccann> so the whole thing is very non-modular; you either lump it all together into one huge beast, or you have multiple types persisted separately with no ACID guarantees when using both
21:34:00 <cmccann> simiarly, loading the state is all-or-nothing, if you want to manage your persistence separately for two types, you again have to give up ACID on operations using both
21:34:51 <jfischoff> how is the performance?
21:34:56 <ddarius> Most don't explicitly use anything and probably could hardly be considered to "implicitly" be using something (or alternatively, could be considered to be "implicitly" using anything.)
21:34:58 <lispy> cmccann: oh yeah, how is your tuning going?
21:35:00 <jfischoff> are there any positives?
21:35:11 <cmccann> jfischoff, well, for what it does do it's really quite nice
21:35:25 <cmccann> as for performance, what originally motivated this is hackage2
21:35:51 <cmccann> which loads the entire package DB up front--because it's all in acid-state--which brings my computer to its knees because that's a LOT of memory
21:35:57 * ddarius whispers, "relational database."
21:36:13 <cmccann> ddarius, sorry SQL isn't trendy anymore
21:36:33 <lispy> Hell, even just a reasonable index would be a win here
21:36:57 <cmccann> lispy, I just spent the evening trying to implement an indexed container with on-demand loading on top of acid state
21:36:59 * ddarius isn't sure there was a time when SQL was trendy.
21:37:03 <Enigmagic> or a offline rendering job
21:37:10 <tomprince> Sure, but I think most don't think \in applies between any two things, and think that things have something like types.
21:37:15 <cmccann> lispy, see above for an idea of how well it worked
21:38:21 <Enigmagic> i bet serving files off disk scales pretty well ;)
21:38:22 <parcs`> i wish there were a QQ thing that allowed for type-safe sql queries
21:38:34 <ddarius> There probably is one.
21:38:37 <ivanm> parcs`: it's make more sense than the overloaded string stuff!
21:40:11 <cmccann> anyway, acid-state does seem nice within the scope of what it handles well
21:40:45 <lispy> cmccann: I'm not sure what the conclusion was after checking my scrollback
21:40:59 <lispy> cmccann: So, acid state doesn't fit the model of lazily loading an index?
21:41:01 <cmccann> but I don't think I'd use it for anything involving large amounts of data, or data with complicated inter-dependencies
21:41:37 <cmccann> lispy, cf. the complaints about losing ACID guarantees
21:42:03 <lispy> I think I have to agree with ddarius in that case
21:42:18 <lispy> sqlite isn't that hard to use (but internally it is untyped, so watch out)
21:42:23 * Enigmagic is still wondering why a service is involved for the bulk of the site
21:42:35 <cmccann> lispy, essentially, to load things separately they need to be persisted separately
21:42:40 <cmccann> and you want your index persisted
21:42:56 <cmccann> which means now it's your responsibility to ensure that the index and the values stay in sync
21:43:04 <cmccann> because you have no ACID guarantees anymore
21:44:39 <cmccann> lispy, yeah, but the thing is it really is nice to work with Haskell types directly and not have to worry about some external untyped whatsit
21:45:06 <cmccann> I just don't think the approach used in acid-state is viable for anything approaching the scale of hackage
21:45:08 <Enigmagic> what parts of hackage benefit from near real-time updates?
21:45:16 <cmccann> or any moderately complex web application to be honest
21:46:25 <cmccann> Enigmagic, dunno, rethinking that would involve more drastic changes than I wanted to deal with though :T
21:46:44 <cmccann> I really don't want to rewrite large chunks of hackage if I can avoid it
21:46:50 <lispy> cmccann: well, you can isolate the interaction with the untyped whatsit in one module that constructs your familiar types from a database that stores the values split up into the types that sqlite understands.
21:47:37 <cmccann> lispy, yeah, which should be slightly less painful than trying to enforce higher-level transactions with acid-state
21:47:47 <Enigmagic> cmccann: hum
21:48:04 <lispy> cmccann: There is a tool that can automate the process if you have a static schema (and I think you do)
21:48:15 <lispy> Dunno if the tool is still maintained
21:48:45 <lispy> There is this: http://hackage.haskell.org/packages/archive/haskelldb/2.1.1/doc/html/Database-HaskellDB.html
21:48:51 * hackagebot network-socket-options 0.1 - Type-safe, portable alternative to getSocketOption/setSocketOption  http://hackage.haskell.org/package/network-socket-options-0.1 (JoeyAdams)
21:49:11 <Enigmagic> cmccann: just seems like serving static pages off a apache/nginx/s3/whatever would be a whole lot easier than trying jam everything into a single haskell process
21:49:17 <lispy> ah, yes
21:49:19 <lispy> cmccann: http://hackage.haskell.org/packages/archive/haskelldb/2.1.1/doc/html/Database-HaskellDB-DBDirect.html
21:49:26 <lispy> DBDirect is the thing I was thinking of
21:50:25 <cmccann> Enigmagic, that's entirely possible
21:51:01 <cmccann> but on the other hand there's an existing code base that does a lot of stuff right now
21:51:22 <cmccann> and scrapping large chunks of that doesn't set well with me
21:51:38 <Enigmagic> cmccann: i don't have problems chucking large amounts of code if it simplifies a problem
21:51:53 <Enigmagic> done it plenty of times and i'm sure i'll do it again in the future :^)
21:52:28 <Enigmagic> after i finish the dwarf symbols maybe i'll hack out a static hackage prototype
21:52:50 <cmccann> well, chucking large amounts of code that I didn't write in favor of something I will have to write also creates problems
21:53:11 <cmccann> namely the problem of needing to write more code that wasn't otherwise necessary
21:53:29 <Enigmagic> vs debugging hackage as it scales up
21:54:20 <cmccann> and virtually none of this code is mine in the first place, and I'm not officially responsible for any of this, so scrapping it would be tantamount to dropping it in favor of making my own hackage replacement
21:54:28 <cmccann> at which point I'm not sure why I'd even be bothering
21:54:52 <Enigmagic> fair enough
21:55:55 <confab> :t xmonad.actions.volume
21:55:56 <lambdabot> Not in scope: `xmonad'
21:55:56 <lambdabot> Not in scope: `actions'
21:55:56 <lambdabot> Not in scope: `volume'
21:56:19 <cmccann> at any rate, I'm not sure what to do about any of it
21:56:31 <confab> :t XMonad.Actions.Volume.lowerVolume
21:56:32 <lambdabot> Couldn't find qualified module.
21:56:35 <confab> :\
21:56:43 <cmccann> the performance is tolerable enough that it can run, but it's kind of ridiculous that hackage--which is mostly static--needs a pretty beefy server just to work decently
21:56:51 <confab> :t lowerVolume
21:56:52 <lambdabot> Not in scope: `lowerVolume'
21:56:54 <MiggyX> is anyone using MongoDB with Haskell? I'm trying to figure out if I can insert a document as JSON or if I have to jump through hoops to convert JSON -> BSON first...
21:57:08 <Enigmagic> MiggyX: the mongoDB driver needs BSON
21:57:14 <lispy> cmccann: Wait, so hackage keeps all the packages in memory while running?
21:57:26 <Enigmagic> there is a partially implemented converter from aeson's JSON to BSON on gist somewhere
21:57:28 <cmccann> lispy, the package descriptions
21:57:37 <lispy> cmccann: Do you know why it tries to do that?
21:57:47 <cmccann> because they're stored in acid-state?
21:57:53 <cmccann> again, see above
21:58:04 <Enigmagic> cmccann: are they stored compressed?
21:58:29 <lispy> cmccann: I think this discussion makes me really question the internal design of hackage then.
21:58:40 <cmccann> Enigmagic, well I replaced five million String types with Text and reduced the memory needed from ~8GB to more like 2GB, does that count as compression?
21:58:54 <lispy> cmccann: seems like Enigmagic's suggestion of a 'static' hackage is the way to go
21:58:57 <Enigmagic> cmccann: nah i meant with lzma or gzip
21:59:08 <cmccann> Enigmagic, yes, I was being snide
21:59:11 <Enigmagic> :)
21:59:35 <cmccann> lispy, well, it's not that horrible in principle--stuff that's not needed can be swapped out at no great cost
22:00:02 <cmccann> the bigger problems are that loading everything up front means it takes like half an hour to start the server
22:00:22 <cmccann> and that the GC tends to keep pulling stuff back into memory so it never really gets to idle fully
22:00:23 <MiggyX> Enigmagic, thanks, I'll take another look :)
22:00:32 <adu> BSON is a bitch
22:00:35 <cmccann> and that it's just all kind of inefficient in general
22:01:30 <lispy> I have to be honest that I just assumed hackage was more static than this
22:01:43 <lispy> Run a script on upload, update some files
22:01:44 <cmccann> and yeah, stuff that changes very infrequently could certainly be static (though I suspect there's enough churn in hackage that this would be of less benefit than you might think)
22:01:44 <Enigmagic> MiggyX: np. i'd certainly like to see native JSON support in the mongoDB package
22:01:48 <lispy> Let apache serve content
22:02:08 <cmccann> lispy, yeah no it's pretty much all dynamic using happstack
22:02:10 <cmccann> as far as I can see
22:02:43 <lispy> cmccann: the memory issues will just get worse as more web2.0 features are added
22:02:44 <Enigmagic> cmccann: for major indexes, yeah but they're going to get generated at least once most of the time anyways
22:02:49 <MiggyX> Enigmagic, maybe 10gen would be up for a little contract based customization :)
22:02:51 <lispy> cmccann: I mean, with the current schema
22:03:03 <cmccann> and while the design internally is apparently more modular than the original, it's incredibly monolithic as an application and I can't find any way to avoid that in order to run pieces of it separately
22:03:26 <cmccann> lispy, and as more packages are uploaded
22:03:43 <Enigmagic> MiggyX: i already have enough stuff to keep me busy :_)
22:03:48 <cmccann> I mean, every time edwardk uploads another five point released for Data.Void that probably adds like 50MB to hackage :P
22:03:57 <lispy> Perhaps we should have a GSoC project that looks at scalibility issues for hackage 2
22:04:10 <edwardk> =P
22:04:14 <MiggyX> Enigmagic, you wrote the driver? :)
22:04:16 <cmccann> edwardk, heheheh
22:04:24 <Enigmagic> MiggyX: nah i've done a few patches to it though
22:04:25 <lispy> edwardk: we register as mentors in march yeah?
22:04:32 <edwardk> yeah
22:04:35 * cmccann will never stop finding it hilarious that void has so many versions
22:04:36 <tomprince> Well, could you put a caching server in front of hackage?
22:04:44 <edwardk> i register us as an org tomorrow i think
22:04:46 <lispy> edwardk: make sure gwern registers so he can at least vote on things
22:04:50 <edwardk> hahahaha
22:04:52 <cmccann> tomprince, yes but I don't think that helps with the issues at hand
22:04:52 <edwardk> definitely
22:04:54 <MiggyX> Enigmagic, would it be a lot of work to add JSON -> BSON do you think?
22:04:58 <lispy> edwardk: did the spi cut-over happen soon enough?
22:05:21 <edwardk> i haven't done the registration yet, i'll let you know ;)
22:05:21 <Enigmagic> MiggyX: i don't think so but there are a little bit of a mismatch in supported types between the two... iirc there is no datetime type in bson
22:05:26 <Zar|minorchord> shit.
22:05:33 <Zar|minorchord> this simply will not do!
22:05:45 <lispy> edwardk: I'm hoping to mentor a successful project this year, but it's too soon to know if I'll even be mentoring someone
22:05:55 <edwardk> *nods*
22:06:50 <edwardk> from the spi mailing list i saw the money move over from galois, so i'd assume we're all set
22:07:03 <lispy> very cool
22:07:06 <edwardk> i just need to figure out what the new registration process involves, since we'll be using spi money
22:07:15 <lispy> I need to post the account details from 2011.  I have the data, I've just been lazy.
22:07:23 <edwardk> or rather, sending it to them
22:07:35 <cmccann> lispy, anyway I'm still not familiar enough with the whole thing to be sure but I'm increasingly suspicious that hackage2 basically is one big scalability issue :T
22:07:37 <edwardk> heading off for a bit
22:07:42 <lispy> edwardk: see ya
22:08:24 <lispy> cmccann: We need to get the yesod guys excited about building us a hackage2 to demo yesod :)
22:08:37 * cmccann shrugs
22:08:39 <ivanm> lispy: don't you mean hackage3 ?
22:08:55 <cmccann> I'm tempted to do a hackage prototype in yesod myself
22:09:14 <ivanm> though there's already yackage...
22:09:38 <cmccann> but I'd still feel awkward about... kinda walking away from the current hackage2 stuff :T
22:09:39 <lispy> cmccann: well, talk to davidL if you get the urge to rewrite hackage
22:10:05 <lispy> cmccann: the exploration you've done so far is really great
22:10:14 <lispy> You're helping the community by figuring out these issues now
22:10:23 <lispy> We'll get there
22:10:24 <cmccann> meh
22:10:56 <cmccann> I've barely done anything besides complain and bumble about with EC2
22:11:27 <davidL> cmccann: I started rewriting hackage in python over the summer. I understand your pain :)
22:11:36 <cmccann> but if nothing else at this point I don't think I can convince myself that acid-state is a good idea
22:11:45 <cmccann> did I mention that I got the acid-state remote stuff working?
22:12:01 <lispy> No, but I don't understand what that means
22:12:40 <cmccann> oh, acid-state supports loading persistent data from another process via network stuff
22:12:57 <cmccann> I wanted to try that so that I could at least restart the web UI without restarting the entire thing
22:12:59 <cmccann> but
22:13:14 <cmccann> turns out that it still needs to load absolutely everything into memory up front
22:13:24 <lispy> oh
22:13:27 <lispy> Lame
22:13:30 <cmccann> and doing that from a remote source is even slower than loading from disk
22:14:01 <cmccann> davidL, python eh? why would you do that? :P
22:14:08 <lispy> You really want a database engine to deal with how much data to load (or not)
22:14:19 <lispy> farm that problem out
22:16:02 <cmccann> I don't even have a problem with managing it semi-manually rather than relying on something else to hopefully do it right
22:16:04 <davidL> cmccann: django makes writing webapps very quick
22:16:12 <cmccann> it's just that acid-state doesn't even give me any way to control it at all
22:17:16 <cmccann> plus the problems of no higher-level transactional support
22:17:17 <mrcarrot> davidL: i do not agree
22:18:01 <mrcarrot> davidL: we have been using django at our comany, and you get a very fast start with it, but the longer you work on the project, the more the framework becomes a burden
22:18:04 <cmccann> and it annoys me because acid-state seems like it should be really nice and convenient to use but that's undermined by complete lack of compositionality and fine-grained control
22:18:08 <lispy> cmccann: hmm...I can't recall where sqlite sits on the issue of transaction support.  IIRC, it has something with a lot of caveats
22:18:17 <cmccann> what I really want
22:18:25 <cmccann> and am tempted to try implementing myself
22:18:45 <cmccann> is something like acid-state but with STM semantics and transparent load/unload
22:18:58 <cmccann> disk-backed TVars basically
22:19:09 <lispy> didn't someone write that?
22:19:11 <cmccann> that can be told to dump everything and wait until they're needed again before reloading
22:19:22 <cmccann> if they did, I'd be interested to see it
22:19:58 <davidL> mrcarrot: oh, of course. I view it as a framework for prototyping. when it starts becoming a burden, you can rewrite it quickly using something else :)
22:20:37 <lispy> cmccann: oh, DSH
22:20:39 <cmccann> davidL, anyway, I'd probably use yesod if I was going to attempt a prototype hackage
22:20:46 <lispy> http://hackage.haskell.org/package/DSH
22:21:15 <lispy> "DSH can be used to allow existing Haskell programs to operate on large scale data (e.g., larger than the available heap) or query existing database resident data with Haskell."
22:21:29 <lispy> damn, not for production use
22:21:48 <cmccann> oh boy, a huge mess of mostly undocumented TH
22:22:01 * cmccann will pass for now
22:23:37 <cmccann> anyway, that seems to be doing something more sophisticated than what I'm after anyway
22:23:58 <lispy> cmccann: what about yesod's persistence package?
22:24:45 <cmccann> haven't looked at it in enough detail
22:25:20 <cmccann> though it seemed to have a lot of SQL bias if memory serves me
22:25:24 <cmccann> and that's not terribly appealing
22:25:50 <cmccann> both because SQL itself is terrible and because trying to cram Haskell types into a relational model doesn't sound like fun
22:26:07 <lispy> I'm fairly well convinced that a traditional sort of SQL approach would work well here and persistence seems to be aimed at making that approach work well for haskell
22:26:27 <cmccann> yeah
22:26:41 <cmccann> but doing anything with SQL always feels like a horrible, painful hack to me
22:27:54 <cmccann> trying to wedge often-recursive data types into something that's like relational algebra except without the elegance makes me queasy
22:27:58 <lispy> On that note, I'm going to bed
22:28:01 <cmccann> heh
22:28:08 <cmccann> I should do the same :[
22:28:13 <cmccann> not gonna get anything done tonight
22:31:37 <tomprince> cmccann: Except relational dbs seem to have stuck with us, while everything else seems to come and go.
22:31:45 <gentleben> nah
22:31:55 <gentleben> lots of other things have stuck around
22:32:00 <cmccann> tomprince, plenty of terrible ideas have stuck with us
22:32:04 <gentleben> and relational stuff will be with us
22:32:27 <gentleben> column stores have been around in finance for 25+ years
22:33:21 <cmccann> relational dbs are a good idea that have been misused consistently enough to be optimized for that misuse
22:33:40 <cmccann> it's like doing static code analysis on C++
22:33:46 <cmccann> there are very sophisticated tools out there
22:33:52 <cmccann> but I'd rather just use something less broken to begin with
22:34:16 <gentleben> relational dbs are great
22:34:22 <gentleben> they just don't scale
22:34:32 <cmccann> they scale better than acid-state :P
22:34:41 <tomprince> Is there such as thing, though?
22:34:57 <Veinor> i swear packing and unpacking between string, bytestring, and text are going to be the death of me
22:35:42 <gentleben> well that doesn't mean much
22:35:45 <tomprince> Or do relational dbs hit the same sweet spot as do unix?
22:35:56 <gentleben> i use mongo and it has done ok
22:36:28 <gentleben> Veinor: I know. just use byte string at process boundaries and text everywhere else
22:36:49 <Veinor> gentleben: i have to interact with APIs that take strings, though
22:39:27 <gentleben> yeah. don't use those
22:39:32 <gentleben> String sucks
22:39:59 <gentleben> or don't write i high perf software
22:40:06 <gentleben> either one
22:40:53 <Veinor> gentleben: sure, let me just rewrite a dropbox api
22:41:53 <gentleben> can't be that hard
22:41:58 <gentleben> programmers use it
22:42:11 <gentleben> i hacked some shit into the AWS api
22:42:22 <gentleben> was one of my first real haskell projects
22:43:24 <gentleben> i agree oauth is a pain
22:43:49 <Veinor> there are apparently 11 instances of the word 'pack' in my 400 LOC source
22:43:57 <gentleben> it took me a while to get my twitter lib oauth right
22:44:06 <gentleben> whats the impact
22:44:10 <average_drifter> is there a benchmark between happs(or whatever de facto haskell web framework) against RoR and PHP and Python and Perl frameworks ?
22:44:12 <gentleben> i know its nasty
22:44:35 <gentleben> average_drifter: what do you want to know?
22:44:51 <carrus85> Veinor, couldn't you just make your own "lifted" Text versions of these apis (do them in a separate file; shouldn't be too much work), and just use those?  It doesn't actually get rid of all of the Strings, but at least you won't see it everywhere...
22:45:06 <average_drifter> gentleben: I want to know how it performs .. man
22:45:10 <carrus85> (esp. if you only lift the functions as you need them...)
22:45:14 <mrcarrot> average_drifter: there are benchmarks on the net for those languages. it does not matter if it is a web app or a local app, they will behave about the same
22:45:35 <gentleben> average_drifter: frameworks typically don't have a huge impact on perf. Your app does
22:45:47 <gentleben> want a fast webpage, render it staticlly
22:45:54 <Veinor> carrus85: i've considered it
22:46:02 <gentleben> database queries kill
22:46:04 <Veinor> to be honest string conversion is probably my least favorite thing about haskell, haha
22:46:08 <mrcarrot> average_drifter: and haskell is of course a winner against those scripted languages... but it does not matter much when webapps are usually about fetching data
22:46:56 <gentleben> average_drifter: if you are concerned only with perf use c++ on the intel compiler
22:47:06 <gentleben> there is nothing faster in most cases
22:47:30 <lebro> what about c
22:47:36 <mrcarrot> average_drifter: i have even made cgi in asm... haskell is for correct programs (as the biggest argument) and performance is okay
22:47:43 <gentleben> or c on the intel compiler
22:47:49 <carrus85> yeah, string conversion, in my limited experience, is a bit of a pain in haskell (XOverloadedStrings can help a bit, but so many APIs seem to want [Char]...)  I'm a bit of a n00b though :S
22:48:15 <Veinor> oh, OverloadedStrings and Data.Monoid.(<>) are a lifesaver
22:48:29 <average_drifter> alright, so I'm not going to get any references to benchmarks on this channel...
22:48:48 * average_drifter better look on my own for what I'm searching cause here I can't find anything
22:48:53 <cmccann> average_drifter, any benchmarks you'd find would probably be useless
22:49:07 <mrcarrot> average_drifter: http://shootout.alioth.debian.org/
22:49:13 <lebro> 'it doesn't matter' is a pretty useful response
22:49:17 <lebro> imo tbqh
22:49:22 <average_drifter> so all of a sudden god comes down from heaven and says "BENCHMARKS are USELESS!"
22:49:31 <mrcarrot> average_drifter: microbenchmarks like that is not a good source for information
22:49:32 <average_drifter> that's .. that's.. just awesome
22:49:43 <average_drifter> mrcarrot: who said they were micro ?
22:50:30 <mrcarrot> average_drifter: http://shootout.alioth.debian.org/u64q/which-programming-languages-are-fastest.php
22:51:05 <cmccann> average_drifter, if you want to know how haskell web frameworks perform, the answer is "pretty good"
22:51:30 <cmccann> average_drifter, if you want something more precise than that you need to be a lot more specific than just general benchmarks because there's no such thing
22:51:38 <gentleben> average_drifter: A large web company I worked at uses a popular lang with all the right design patterns and still has 4s page loads
22:51:44 <MichaelBurge> Are any FRP libraries sufficiently advanced to write a game on top of?
22:51:54 <mrcarrot> average_drifter: a compiled haskell webapplication will always be faster than the interpreted languages like python, php, ruby, perl
22:52:24 <gentleben> average_drifter: also haskell's laziness helps in page rendering
22:52:25 <mrcarrot> average_drifter: and as bonus, you can run haskell interpreted while you develop, and then compile the final product
23:02:53 <nyingen> @quote
23:02:53 <lambdabot> heatsink says: Maybe, (), and Bool go to the Lone Star Bar.  The bouncer stops Maybe and says, "we don't serve your kind here."
23:03:04 <nyingen> boo
23:03:13 <Veinor> that's a real knee-slapper
23:08:45 <Axman6> anyone used the diagrams-cairo package?
23:14:16 <Enigmagic> Axman6: i suspect byorgey has
23:17:25 <Axman6> yeah, but he wasn't about when i asked in #diagrams. turns out though that the answer to my question came from running my program with --help =)
23:31:56 <otk> failing some basic math concept here, anyone want the opportunity to feel superior?
23:32:50 <Saizan> ask :)
23:32:57 <tomprince> otk: Why don't ask, and find out.
23:33:35 <otk> i must lure you into my cave of ignorance
23:34:45 <copumpkin> otk: dammit, just ask the question :P
23:34:57 <copumpkin> we don't want to have to chase you down to find out what we're supposed to help you with
23:35:32 <Axman6> otk: first rule of IRC: don't ask to ask, just ask
23:35:53 <otk> i have a line in an image, that goes like (x,y) 1,3 1,4 1,5, 2,6, 2,7, 2,7 and so on, i always have x, but not always y, but i know that the variation is always 3, how do i work out y for any given x
23:36:23 <copumpkin> y = 3*x + 1
23:36:28 <copumpkin> oh wait
23:36:46 <copumpkin> lol
23:36:49 <copumpkin> I fail :)
23:37:14 <otk> hehe :P im failing too don't worry
23:37:25 <otk> i shoulda listened in primary school
23:37:25 <Saizan> so it's a staircase?
23:37:30 <otk> Saizan: exactly!
23:38:05 <copumpkin> > concatMap (sequence [(+2),(+3),(+4)]) [1..]
23:38:06 <lambdabot>   [3,4,5,4,5,6,5,6,7,6,7,8,7,8,9,8,9,10,9,10,11,10,11,12,11,12,13,12,13,14,13...
23:38:39 <copumpkin> hmm, I'm really failing at this
23:38:42 <otk> :P
23:38:43 <copumpkin> was that last 2,7 meant to be a 2,8?
23:38:53 <otk> sorry yes 2,8
23:38:55 * hackagebot ghc-mod 1.10.9 - Happy Haskell programming on Emacs/Vim  http://hackage.haskell.org/package/ghc-mod-1.10.9 (KazuYamamoto)
23:39:05 <copumpkin> oh
23:39:07 <Saizan> each vertical segment will start at an height of 3*x
23:39:28 <otk> i hacked around it for x as 1..19, but there are several staircases where i only know x
23:39:40 <copumpkin> > zip ([1..] >>= replicate 3) [3..]
23:39:41 <lambdabot>   [(1,3),(1,4),(1,5),(2,6),(2,7),(2,8),(3,9),(3,10),(3,11),(4,12),(4,13),(4,1...
23:39:52 <otk> oh thats nice
23:39:52 <Saizan> for forall x, you have 3*x+i where i = 0,1,2
23:40:57 <otk> hmm
23:43:06 <blbrown_win3> Has anyone seen this with EclipseFP or more importantly, how do you use it run an application https://gist.github.com/1874901
23:43:27 <c_wraith> Anyone from iPwn around?  I'm curious if Sodium is more or less what you're using internally
23:52:26 <Cale> c_wraith: it's very much unlike what we're using internally
23:52:49 <c_wraith> just checking
23:53:55 <Cale> (we're using an arrow-like library that requires a custom arrow preprocessor)
23:54:47 <c_wraith> THat does sound entirely different
23:58:42 <xrl> I'm trying to return a constructor and I'm getting the error that I'm not applying enough arguments, http://hpaste.org/64092
23:59:31 <xrl> specifically, line 45
