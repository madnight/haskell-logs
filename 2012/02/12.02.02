00:00:14 <lysgaard> SELECT id FROM nodes WHERE (tags ? 'name');
00:00:44 <lysgaard> The '?' here is a membership operator for, a hstore collum, tags.
00:06:21 <ion> Skimming through hdbc-postgresql’s parser, it might not handle that case.
00:07:00 <elliott> Does PostgreSQL have eval? You could construct the ? programmatically :)
00:16:38 <lysgaard> Hmm. That's kinda rubbish
00:18:01 <lysgaard> Well, I'll have to hack it then. What about not escaping a '?' if it's preceded by a '\'. That means the query would be written: SELECT id FROM nodes WHERE (tags \\? 'name');
00:18:55 <erus`> Im gonna write a little haskell app for defining graphs in haskell :)
00:19:25 <elliott> erus`: http://hackage.haskell.org/package/graphviz
00:21:17 <eyu100> > Nothing >> Just 1
00:21:18 <lambdabot>   Nothing
00:21:58 <Tinned_Tuna> Just 1 >> Nothing
00:22:02 <Tinned_Tuna> > Just 1 >> Nothing
00:22:03 <lambdabot>   Nothing
00:23:26 <eyu100> > data Void
00:23:27 <lambdabot>   <no location info>: parse error on input `data'
00:23:39 <oxryly> is there a function that strips leading and trailing whitespace from a string
00:23:39 <oxryly> ?
00:23:40 <eyu100> aww, no top level declarations
00:24:11 <eyu100> I suppose you could use Parsec, but that is a bit overpowered for your needs
00:24:16 <zomg> @hoogle trim
00:24:16 <lambdabot> Graphics.Rendering.OpenGL.GLU.NURBS trimmingCurve :: TrimmingPoint c => NURBSObj -> GLint -> Ptr GLfloat -> GLint -> Ptr (c GLfloat) -> GLint -> IO ()
00:24:16 <lambdabot> Graphics.Rendering.OpenGL.GLU.NURBS class TrimmingPoint p
00:24:16 <lambdabot> package trimpolya
00:24:18 <elliott> @let data Void
00:24:19 <lambdabot>   EmptyDataDecls is not enabled
00:24:20 <zomg> Guess not
00:24:25 <eyu100> @hoogle strip
00:24:25 <lambdabot> Data.List stripPrefix :: Eq a => [a] -> [a] -> Maybe [a]
00:24:26 <lambdabot> Data.Text strip :: Text -> Text
00:24:26 <lambdabot> Data.Text.Lazy strip :: Text -> Text
00:24:30 <eyu100> @hoogle regex
00:24:31 <lambdabot> Text.Regex.Posix.Wrap data Regex
00:24:31 <lambdabot> Text.Regex.Posix.String data Regex
00:24:31 <lambdabot> Text.Regex.Posix.Sequence data Regex
00:24:33 <elliott> oxryly: you can write one
00:24:50 <elliott> > let strip = reverse . dropWhile isSpace . reverse . dropWhile isSpace in strip "   abc "
00:24:51 <lambdabot>   "abc"
00:25:29 <eyu100> > isSpace '\t'
00:25:30 <lambdabot>   True
00:25:36 <eyu100> > isSpace '\n'
00:25:37 <lambdabot>   True
00:25:40 <eyu100> > isSpace 'a'
00:25:41 <lambdabot>   False
00:25:48 <eyu100> cool!
00:25:55 <eyu100> @info isSpace
00:25:55 <lambdabot> isSpace
00:26:05 <eyu100> @hoogle isSpace
00:26:05 <lambdabot> Data.Char isSpace :: Char -> Bool
00:26:24 <oxryly> Data.Text.Strip seems to be the one
00:26:50 <eyu100> > strip
00:26:51 <lambdabot>   Not in scope: `strip'
00:27:15 <elliott> oxryly: no
00:27:17 <elliott> that's for Text values
00:27:19 <eyu100> http://stackoverflow.com/questions/6270324/in-haskell-how-do-you-trim-whitespace-from-the-beginning-and-end-of-a-string
00:27:21 <elliott> not String
00:27:22 * hackagebot accelerate 0.9.0.1 - An embedded language for accelerated array processing  http://hackage.haskell.org/package/accelerate-0.9.0.1 (ManuelChakravarty)
00:27:32 <elliott> strip = reverse . dropWhile isSpace . reverse . dropWhile isSpace
00:27:34 <elliott> it's just a one-liner :P
00:28:00 <elliott> stripl = dropWhile isSpace; stripr = reverse . stripl . reverse; strp = stripr . stripl
00:28:32 <elliott> it _is_ kind of inefficient. but that's String for you
00:34:21 <eyu100> > join (*) 1
00:34:22 <lambdabot>   1
00:34:24 <eyu100> > join (*) 2
00:34:25 <lambdabot>   4
00:34:26 <eyu100> > join (*) 3
00:34:27 <lambdabot>   9
00:34:47 <elliott> join (*) x = x*x
00:35:12 <ion> > join (*) x
00:35:13 <lambdabot>   x * x
00:38:14 <eyu100> lol lambdabot can evaluate symbolic expressions?
00:38:28 <eyu100> > (x + x) + x
00:38:29 <lambdabot>   x + x + x
00:38:42 <rtharper> orly?
00:38:48 <rtharper> I didn't know that
00:38:50 <eyu100> > take 2 (x:y:z:[])
00:38:52 <lambdabot>   [x,y]
00:38:54 <eyu100> wow.
00:39:01 <eyu100> > x - x
00:39:02 <lambdabot>   x - x
00:39:06 <eyu100> it isn't that smart =P
00:39:11 <rtharper> haha
00:39:20 <flux> @src x
00:39:21 <lambdabot> Source not found. And you call yourself a Rocket Scientist!
00:39:23 <koala_man> > cow + foo
00:39:24 <eyu100> > take 2 (x:y:undefined)
00:39:24 <lambdabot>   Not in scope: `cow'Not in scope: `foo'
00:39:24 <lambdabot>   can't find file: L.hs
00:39:33 <eyu100> > take 2 (x:y:undefined)
00:39:34 <elliott> there's a thing for simplification
00:39:34 <lambdabot>   [x,y]
00:39:36 <elliott> but it's dumb
00:39:41 <eyu100> ah
00:39:42 <rtharper> single letter var names?
00:39:45 <eyu100> > take 2 (x:undefined)
00:39:46 <lambdabot>   [x*Exception: Prelude.undefined
00:40:02 <eyu100> > fix error
00:40:03 <lambdabot>   "*Exception: *Exception: *Exception: *Exception: *Exception: *Exception: *E...
00:40:12 <ion> One might not want x-x to be changed to 0.
00:40:36 <ion> It being too “smart” could hinder an important use case, such as demonstrating some folds.
00:40:50 <elliott> also it's useful for seeing how complex certain operations are
00:40:53 <elliott> > x ^ 40
00:40:54 <lambdabot>   x * x * (x * x) * (x * x * (x * x)) * (x * x * (x * x) * (x * x * (x * x)))...
00:41:00 <elliott> which simplification would hinder
00:41:04 <ion> yeah
00:41:11 <elliott> s/complex/meaningful word/
00:41:29 <flux> > x ^ 4
00:41:30 <lambdabot>   x * x * (x * x)
00:41:30 <ion> “burrito-ish”
00:41:43 <flux> shouldn't it do (x * x) * (x * x)?
00:41:54 <eyu100> > x ^ 40 ^ 40
00:41:55 <lambdabot>   x * x * (x * x) * (x * x * (x * x)) * (x * x * (x * x) * (x * x * (x * x)))...
00:42:01 <flux> well, perhaps the same at that level.
00:42:06 <eyu100> > 40 ^ x
00:42:11 <lambdabot>   mueval: ExitFailure 1
00:42:12 <lambdabot>  mueval: Prelude.undefined
00:42:16 <eyu100> lol
00:42:27 <eyu100> > 2 ^ x
00:42:32 <lambdabot>   mueval-core: Time limit exceeded
00:42:36 <eyu100> well, that derped.
00:42:38 <eyu100> > x ^ x
00:42:43 <lambdabot>   mueval-core: Time limit exceeded
00:42:46 <ion> @src (^)
00:42:46 <lambdabot> x ^ 0            =  1
00:42:46 <lambdabot> x ^ n | n > 0    =  f x (n-1) x
00:42:47 <lambdabot>   where f _ 0 y = y
00:42:47 <lambdabot>         f x n y = g x n
00:42:47 <lambdabot>           where g x n | even n  = g (x*x) (n `quot` 2)
00:42:48 <lambdabot>                       | otherwise = f x (n-1) (x*y)
00:42:50 <lambdabot> _ ^ _            = error "Prelude.^: negative exponent"
00:42:52 <eyu100> > id x
00:42:56 <lambdabot>   x
00:43:03 <unknownwarrior> hey guys, is there a nice way to check if something in a string is a number or a character?
00:43:06 <eyu100> > id id id id id id id id id id id id
00:43:07 <lambdabot>   Overlapping instances for GHC.Show.Show (a -> a)
00:43:07 <lambdabot>    arising from a use of `...
00:43:14 <eyu100> > id id id id id id id id id id id id x
00:43:15 <lambdabot>   x
00:43:22 <unknownwarrior> x
00:43:26 <unknownwarrior> id
00:43:31 <unknownwarrior> :id
00:43:37 <eyu100> > join const x
00:43:38 <lambdabot>   x
00:43:43 <ion> When n :: Expr, (n-1) never becomes 0, leading (^) to recurse infinitely.
00:43:47 <ion> (i think)
00:43:51 <eyu100> ah
00:43:55 <elliott> unknownwarrior: Number or character howso?
00:43:59 <elliott> Number or letter, do you mean?
00:44:01 <eyu100> also apparently join const == id
00:44:08 <eyu100> oh the things I learn from lambdabot
00:44:10 <eyu100> lol
00:44:12 <elliott> > join const 1 2
00:44:13 <lambdabot>   1
00:44:15 <elliott> not quite
00:44:21 <eyu100> well, nvm
00:44:27 <eyu100> > join const 1
00:44:28 <lambdabot>   1
00:44:28 <elliott> join const = const const = \_ -> const = \_ x _ -> x
00:44:40 <ion> > join const 1 2 3 4 5 6 7 8
00:44:41 <lambdabot>   1
00:44:54 <danr> @type join const
00:44:55 <eyu100> that's very interesting.
00:44:57 <lambdabot> forall a. a -> a
00:45:05 <eyu100> how can it just keep chugging along?
00:45:11 <danr> o_O
00:45:27 <unknownwarrior> elliott: what i got is for example "100" or something like this "i" or "a". i tried to solve this like this: elem (read "ab") [1..200] but it doesnt work ;)
00:45:29 <eyu100> ok it doesn't actually work for more than one argument
00:45:38 <eyu100> ghci errors out even though lambdabot doesn't
00:45:44 <eyu100> @free forall a. a -> a
00:45:45 <lambdabot> Pattern match failure in do expression at Plugin/Free/FreeTheorem.hs:54:20-34
00:45:50 <eyu100> @free a -> a
00:45:51 <lambdabot> Extra stuff at end of line
00:45:56 <eyu100> @free (a -> a)
00:45:57 <lambdabot> Pattern match failure in do expression at Plugin/Free/FreeTheorem.hs:54:20-34
00:45:58 <eyu100> @free id
00:45:59 <lambdabot> f . id = id . f
00:46:07 <ion> lambdabot has an evil Num instance leading to the “1 is a function” confusion.
00:46:34 <eyu100> @help free
00:46:34 <lambdabot> free <ident>. Generate theorems for free
00:46:42 <eyu100> @free (join const)
00:46:43 <lambdabot> Pattern match failure in do expression at Plugin/Free/FreeTheorem.hs:54:20-34
00:46:46 <eyu100> uhh
00:46:49 <eyu100> how do I use @free?
00:46:57 <ski> unknownwarrior : `case reads "ab" of [(number,"")] -> ...; _ -> ...'
00:47:09 <elliott> unknownwarrior: all isDigit?
00:47:15 <elliott> @free f :: a -> a
00:47:15 <lambdabot> g . f = f . g
00:47:17 <elliott> eyu100: like that
00:47:27 <ski> @free id
00:47:27 <lambdabot> f . id = id . f
00:47:32 <eyu100> @free
00:47:32 <lambdabot> Pattern match failure in do expression at Plugin/Free/FreeTheorem.hs:54:20-34
00:47:49 <unknownwarrior> umm give me a second ..
00:47:50 <eyu100> @free const
00:47:51 <lambdabot> f . const x = const (f x) . g
00:47:53 <danr> @free fmap
00:47:54 <lambdabot> Expected variable or '.'
00:48:05 <danr> @free (.)
00:48:06 <lambdabot> Pattern match failure in do expression at Plugin/Free/FreeTheorem.hs:54:20-34
00:48:08 <danr> hmm
00:48:25 <eyu100> @free join const
00:48:26 <lambdabot> Extra stuff at end of line
00:48:28 <ski> @free (.) :: (b -> c) -> (a -> b) -> (a -> c)
00:48:28 <eyu100> @free join
00:48:28 <lambdabot> Pattern match failure in do expression at Plugin/Free/FreeTheorem.hs:54:20-34
00:48:29 <lambdabot> Expected variable or '.'
00:48:38 <ski> @free compose :: (b -> c) -> (a -> b) -> (a -> c)
00:48:38 <lambdabot> g . k = p . f => f . q = f1 . h => g . compose k q = compose p f1 . h
00:48:42 <eyu100> @free a :: a -> a
00:48:43 <lambdabot> f . a = a . f
00:49:01 <ski> @free eq :: Eq a => a -> a -> Bool
00:49:02 <lambdabot> Extra stuff at end of line
00:49:09 <eyu100> so yeah, join const is equal to id
00:49:20 <eyu100> because of the free theorem of forall a. a -> a
00:49:44 <elliott> erm
00:49:53 <elliott> join const x = const const x = const
00:50:00 <elliott> f x = const implies f =/= id
00:50:11 <eyu100> @type join const
00:50:12 <lambdabot> forall a. a -> a
00:50:22 <eyu100> the type doesn't agree with you
00:50:27 <ski>   join const  =  \x -> const x x  =  \x -> x  =  id
00:50:54 <elliott> oh! I forgot what join did entirely :)
00:50:58 <elliott> I thought join x = x x for a second
00:51:39 <unknownwarrior> ski: what do i have to insert instead of number?
00:52:07 <ski> unknownwarrior : any variable name you like, in case you don't like that variable name
00:52:39 <ski> unknownwarrior : if you insist that th number must be in `[1 .. 200]', then you could add a guard for that
00:53:23 <unknownwarrior> ski: uff i know guards and how they work but how can i possibly add a guard in this case?
00:56:04 <ski>   case reads "ab" of
00:56:08 <ski>     [(number,"")]
00:56:15 <ski>       | number `elem` [1 .. 200] -> ..number..
00:56:17 <ski>     _                            -> ...
00:56:32 <ski> unknownwarrior : something like that
00:58:53 <unknownwarrior> okey im testing this
01:01:25 <ion> number `elem` [1 .. 200] is a bit expensive compared to 1 <= number && number <= 200.
01:03:03 <elliott> I bet GHC optimises that.
01:03:14 <Twey> (lower >< upper) x = lower < x && x < upper; (lower ><= upper) x = lower <= x && x <= upper
01:03:19 <elliott> At least GHC often gives warnings of unhandled case elements in terms of elem.
01:03:29 <elliott> Twey: Dijkstra hates you.
01:03:34 <Twey> Heh.
01:03:36 <Twey> Fine
01:04:19 <Twey> (lower >< upper) x = lower < x && x < upper; (lower =><= upper) x = lower <= x && x <= upper; (lower =>< upper) x = lower <= x && x < upper; (lower ><= upper) x = lower < x && x <= upper
01:05:43 <unknownwarrior> ski: http://hpaste.org/57315
01:07:03 <Peaker> :t liftA2 (&&) (10 <) (<= 15)
01:07:04 <lambdabot> forall t. (Num t, Ord t) => t -> Bool
01:07:31 <ski> Twey : not `(lower ><= upper) x = lower < x && x <= upper', then ?
01:07:48 <ski> ion : it's not the same, in gneral
01:07:53 <Peaker> :t let aand = liftA2 (&&) in   (10<) `aand` (<=15)
01:07:54 <lambdabot> forall t. (Num t, Ord t) => t -> Bool
01:08:32 <ski> preflex: xseen hpaste
01:08:32 <preflex>  hpaste was last seen on freenode/#haskell 3 days, 23 hours, 49 minutes and 17 seconds ago, saying: mekeor pasted “@ _mikey” at http://hpaste.org/57145
01:08:41 <Twey> ski: That's what I said, isn't it?
01:08:56 <Peaker> Nicer to compose the comparison operators directly than to make weird new operators IMO
01:09:18 <ski> Twey : no
01:09:33 <Twey> ski: (lower ><= upper) x = lower < x &&  x <= upper
01:09:50 <Twey> Looks the same to me.  What am I missing?
01:10:14 <Twey> Peaker: Mm, not sure
01:10:15 <ski> unknownwarrior : i would put `[(number,"")]' on the next line (possibly putting `| number ...' on the same line, if you prefer), making sure to align the start of `[(number,"")]' with the start of `_ ->'
01:10:29 <ski> Twey : `<' vs. `<='
01:10:52 <ski> Twey : oh, i see you changed you definition later, sorry
01:10:54 <Twey> ski: < on the first, <= on the second
01:10:54 <Peaker> operators are a very expensive namespace IMO they use needs to be heavily justified
01:10:59 <Twey> Oh, right, yeah
01:11:03 <Peaker> their*
01:11:14 <Twey> Peaker: Mm
01:11:44 <ion> @type getAll . mappend (All . (10 <)) (All . (<= 15))
01:11:45 <lambdabot> forall a. (Num a, Ord a) => a -> Bool
01:12:00 <unknownwarrior> ski: could you be so kind and annotate the code pls, i dont know what you mean
01:12:13 <ski> Twey : "Why numbering should start at zero" <http://www.cs.utexas.edu/users/EWD/transcriptions/EWD08xx/EWD831.html>
01:12:22 <ski> unknownwarrior : sure, a moment
01:12:27 <Twey> ski: Yeah, someone pointed that out already
01:12:33 <Twey> (hence the added definitions)
01:13:08 <Twey> I guess you could define a general combinator… on2 (<) (<=) (&&)
01:13:42 <Twey> on2 c1 c2 upper lower x = c1 lower x && c2 x upper
01:14:30 <elliott> eventually we'll have a name for every single kind of application pattern
01:14:38 <Peaker> on2 = liftA2 with weird arg order?
01:14:49 <Twey> :t liftA2
01:14:51 <lambdabot> forall a b c (f :: * -> *). (Applicative f) => (a -> b -> c) -> f a -> f b -> f c
01:15:05 <Twey> Hmm
01:15:07 <Peaker> :t liftA2 (&&) (<) (<=)
01:15:08 <lambdabot>     Couldn't match expected type `Bool'
01:15:09 <lambdabot>            against inferred type `a -> Bool'
01:15:09 <lambdabot>     Probable cause: `<' is applied to too few arguments
01:15:14 <Peaker> :t liftA2 (&&) (<1) (<=2)
01:15:15 <lambdabot> forall a. (Num a, Ord a) => a -> Bool
01:15:22 <Twey> Not quite the same
01:15:26 <Peaker> yeah that doesn't work there :-)
01:15:38 <Peaker> :t (liftA2 . liftA2) (&&) (<) (<=)
01:15:39 <lambdabot> forall a. (Ord a) => a -> a -> Bool
01:15:57 <Twey> Could define on2 in terms of it, though.
01:16:18 <Twey> No, don't think that's right either (where'd the other two args go?)
01:16:23 <Twey> I'm not even sure what that does.
01:17:57 <Peaker> it's wrong, yeah :-)
01:18:19 <Peaker> it will give the same two args to (<) and (<=) and then (&&) on their results
01:18:45 <elliott> also known as (<) :P
01:18:58 <unknownwarrior> ski: http://hpaste.org/57315
01:19:01 <Twey> Heheh
01:19:03 <Peaker> @let infixr 2 ~> ; (arg ~> res) f = res . f . arg
01:19:04 <lambdabot>  Defined.
01:19:20 <unknownwarrior> noooo my laptop is running out of battery!!!
01:21:41 <Peaker> @pl f x y = liftA2 (&&) (>=x) (<y)
01:21:41 <lambdabot> f = (. flip (<)) . liftA2 (&&) . flip (>=)
01:22:10 <Peaker> @let result = (.) ; argument = flip (.)
01:22:11 <lambdabot>  Defined.
01:22:50 <Peaker> @type (<=) ~> argument (>) $ liftA2 (&&)
01:22:51 <lambdabot> forall a. (Ord a) => a -> a -> a -> Bool
01:23:36 <Peaker> @type (<=) ~> (>) ~> id $ id
01:23:36 <lambdabot> forall a. (Ord a) => (a -> Bool) -> a -> Bool
01:27:35 * ski annotated "temporary" with "align correctly" at <http://hpaste.org/57315#a57316>
01:28:13 <ski> @tell unknownwarrior * ski annotated "temporary" with "align correctly" at <http://hpaste.org/57315#a57316>
01:28:14 <lambdabot> Consider it noted.
01:28:54 <elliott> Twey: Peaker: I am surprised nobody has taken the obvious leap to defining an interval type instead.
01:30:06 <ion> like Ruby!
01:30:42 <rostayob> join #haskell, Ruby is mentioned?
01:33:00 <lysgaard> @hoogle [a] -> (a -> Bool) -> ([a],[a])
01:33:01 <lambdabot> Prelude break :: (a -> Bool) -> [a] -> ([a], [a])
01:33:02 <lambdabot> Data.List break :: (a -> Bool) -> [a] -> ([a], [a])
01:33:02 <lambdabot> Prelude span :: (a -> Bool) -> [a] -> ([a], [a])
02:33:59 <Lemon> In my typechecker, I make a syntactic distinction between type variables and type constructors (which are always saturated)
02:34:15 <carrotto> where does one send a patch for the haskell gstreamer bindings ? darcs get --lazy http://code.haskell.org/gtk2hs/   comes without gstreamer
02:34:19 <Lemon> how do I incorporate type variables as constructors?
02:34:32 <Lemon> like the 'm' in
02:34:34 <Lemon> :t return
02:34:35 <lambdabot> forall a (m :: * -> *). (Monad m) => a -> m a
02:35:23 <ski> imo, `m' isn't a type constructor, there, it's a type variable
02:35:28 <Baughn> zlib failing to compile for anyone else?
02:35:43 <ski> (`Bool',`Int',`Maybe',`Either',`IO' are examples of type constructors)
02:37:34 <gienah> carrotto: its a mystery, maybe you could try emailing the maintainers
02:38:27 <carrotto> gienah: thank you
02:40:20 <elliott> Lemon: data Type = TyVar String | TyCon String | TyApp Type Type?
02:40:28 <elliott> or such.
02:41:01 <Lemon> right now I only have TyVar String | TyCon String [Type]
02:41:19 <Lemon> my question is more like
02:41:39 <Lemon> how do I handle the TyApp case in my implementation of unification?
02:43:43 <Twey> What's the :: symbol called that people use for type-of in papers sometimes?
02:44:54 <Twey> Ah, \squaredots… thanks
02:45:06 <elliott> You're welcome.
02:45:12 <elliott> But you owe me.
02:45:18 <dp_wiz> Is there a really trivial quickcheck tutorial?
02:45:25 <elliott> @check True
02:45:26 <lambdabot>   "OK, passed 500 tests."
02:45:35 <elliott> Well, it's really trivial, at least.
02:46:05 <dp_wiz> so, it's just check <code> and it goes on?
02:46:20 <Twey> elliott: I don't suppose you know the Unicode name?  :þ
02:46:31 <donri> @check (< 200)
02:46:32 <lambdabot>   "OK, passed 500 tests."
02:46:37 <elliott> Twey: I'm not sure what symbol you are referring to.
02:46:40 <MostAwesomeDude> @check \x y z -> (x > y && y > z) == (x > z)
02:46:41 <lambdabot>   "OK, passed 500 tests."
02:46:44 <elliott> Maybe I should render it.
02:46:44 <donri> @check (< 100)
02:46:45 <lambdabot>   "Falsifiable, after 237 tests:\n112\n"
02:47:24 <arcatan> basically it's import Test.QuickCheck and doing something like quickCheck $ \a -> a + 1 == 1 + a
02:47:27 * hackagebot clientsession 0.7.4 - Securely store session data in a client-side cookie.  http://hackage.haskell.org/package/clientsession-0.7.4 (MichaelSnoyman)
02:47:34 <elliott> dp_wiz: You give it a predicate of a bunch of arguments to a boolean and it throws random values at it until it breaks.
02:47:47 <elliott> You can also define instances for your own types, and do things like configure how many values it checks.
02:47:52 <Twey> elliott: The one that looks like ‘::’.
02:48:24 <elliott> Twey: Paamayim nekudotayim? :P
02:48:54 <Twey> elliott: Hahaha, yes :þ
02:49:17 <ski> Twey : people often use just a `:' for that
02:50:31 <Twey> ski: Yeah, but there's a symbol some people use
02:50:38 <Twey> It's in Unicode somewhere
02:51:12 <ski> Lemon : well, assuming every application is the application of a type constructor to zero or more type expressions (and assuming the type constructor is injective), just unify the corresponding actual type parameters
02:51:40 <ski> Twey : hm, i haven't noticed that
02:51:51 <arcatan> Twey: this one? http://shapecatcher.com/unicode_info/8759.html
02:51:55 * ski has a preferece to `:' over `::'
02:52:15 <ski> (well, i've noticed some use the "set-element-of" symbol)
02:52:28 * hackagebot authenticate-oauth 1.0.0 - Authentication methods for Haskell web applications.  http://hackage.haskell.org/package/authenticate-oauth-1.0.0 (HiromiIshii)
02:52:32 <Twey> ski: Same, but not when actually talking about Haskell.
02:52:50 <Twey> arcatan: Yes!  Thank you ☺
02:52:52 <int-e> Twey: U+2237 PROPORTION is what ghc uses.
02:53:09 <Twey> int-e: Great, thanks!
02:53:15 <kstt> hi. I'd need some advices for my first steps with GADTs, and related existentials.
02:53:15 <ski> i've not noticed anything else than `::' used when talking about actual Haskell
02:53:39 <ski> int-e : hm, uses where ?
02:53:56 <bsrk> I have a class declaration:
02:53:58 <bsrk> class (Functor m, Monad m, Functor (ApplyMonadBase m), Monad (ApplyMonadBase m), ToTree state)
02:53:58 <kstt> I've started, of course, with a SafeList implementation : https://gist.github.com/1723126
02:54:00 <bsrk>        => ApplyMonad m (state :: (* -> *) -> *) where
02:54:00 <int-e> ski: in compiler/parser/Lexer.x -- when UnicodeSyntax is enabled.
02:54:02 <bsrk>     type ApplyMonadBase m :: * -> *
02:54:04 <bsrk>    --followed by methods in the class
02:54:06 <bsrk> What is state doing? how can there be a kind declaration inside a class declaration?
02:54:23 <ski> int-e : ok (i've never tried that extension)
02:54:23 <kstt> I've successfully implemented head and tail, as shown in the gist
02:54:34 <kstt> now I'm stuck with filter.
02:54:46 <int-e> ski: same here, actually.
02:54:56 <kstt> I don't even know the type I should give to it.
02:55:48 <kstt> Of course it can't be known at compile time
02:56:01 <kstt> So IIUC, I should use existentials
02:56:29 <kstt> But I'm puzzled
02:56:46 <ski>   filter :: (a -> Bool) -> (exists t. List t a) -> (exists t. List t a)  -- basically this, i think
02:57:34 <elliott> ski: you can turn the first exists into a forall
02:57:49 <ski> i know, i wrote it that way to emphasize the symmetry
02:58:19 <elliott> (technically the second too :P)
02:58:29 <ski> and to suggest that writing this isn't much different from just writing `filter :: (a -> Bool) -> [a] -> [a]'
02:58:31 <elliott> actually you can do a bit better
02:58:42 <ski> (where `[a]' is isomorphic to `exists t. List t a')
02:58:46 <elliott> filter :: (a -> Bool) -> List t a -> (exists s. (s `SmallerThan` t) => List s a)
02:58:51 <elliott> for an appropriate SmallerThan
02:59:00 <ski> s/=>/*>/
02:59:12 <elliott> mine is closer to valid haskell :p
02:59:14 <ski> but, yes
02:59:29 <ski> it also gives the wrong associations
02:59:42 <ski> what one wants there is not `=>'
03:00:07 <kstt> thank you
03:00:30 <ski> kstt : you'll have to define a new data type to express the existential
03:00:37 <kstt> I understand the second exists, but not the first
03:02:28 * hackagebot cpsa 2.2.7 - Symbolic cryptographic protocol analyzer  http://hackage.haskell.org/package/cpsa-2.2.7 (JohnRamsdell)
03:02:45 <kstt> Oh, maybe it is here simply to allow filtering both an empty and a non-empty list, right ?
03:05:57 <ski> kstt : `(exists a. ..a..) -> ...' is the same as `forall a. (..a.. -> ...)'
03:06:12 <kstt> So if I focus on filtering non-empty lists, the haskell-valid signature would be : (a -> Bool) -> (List (T_Cons _t) a) -> (forall t2. List t2 a)
03:06:49 <ski> no, `forall' there is wrong
03:06:55 <ski>   filter :: (a -> Bool) -> (exists t. List t a) -> (exists t. List t a)
03:06:57 <ski> is the same as
03:07:14 <ski>   filter :: (a -> Bool) -> forall t. List t a -> (exists t. List t a)
03:07:17 <ski> is the same as
03:07:24 <ski>   filter :: forall t. (a -> Bool) -> List t a -> (exists t. List t a)
03:07:29 <ski> which we usually abrbeviate as
03:07:33 <ski>   filter :: (a -> Bool) -> List t a -> (exists t. List t a)
03:08:15 <kstt> but 'exists' is a notation, right ? Not valid haskell syntax.
03:08:28 <ski> however, to express the `exists t. List t a', we have to (in current Haskell extensions) to make a new named data type, say `VarList a', defined as
03:08:43 <ski>   data VarList a = forall t. MkVarList (List t a)
03:08:47 <ski> or, in GADT notation, as
03:08:59 <ski>   data VarList a
03:09:01 <ski>     where
03:09:13 <ski>     MkVarList :: forall t. List t a -> VarList a
03:09:23 <ski> (and you can omit the `forall t. ' here, if you want to)
03:09:39 <ski> note how the type signature
03:09:39 <ski>   MkVarList :: forall t. List t a -> VarList a
03:09:40 <kstt> ah, I was just typing a question on that, thx
03:09:45 <ski> here is logically equivalent to
03:09:52 <ski>   MkVarList :: (exists t. List t a) -> VarList a
03:10:05 <ski> which is what we wanted, and this explains the use of `forall' here
03:10:12 <kstt> ok
03:10:40 <ski> (however, `VarList a' is conceptually the same as `[a]')
03:10:50 <kstt> sure
03:12:02 <ski> in case you wanted to add a `SmallerThan' constraint, starting from
03:12:16 <ski>   filter :: (a -> Bool) -> List t a -> (exists s. SmallerThan s t *> List s a)
03:12:22 <ski> we can do that by saying
03:12:42 <ski>   filter :: (a -> Bool) -> List t a -> ListAtMost t a
03:12:45 <ski> defining
03:13:04 <ski>   data ListAtMost t a = forall s. SmallerThan s t => MkListAtMost (List s a)
03:13:05 <ski> or
03:13:10 <ski>   data ListAtMost t a
03:13:11 <ski>     where
03:13:27 <ski>     MkListAtMost :: forall s. SmallerThan s t => List s a -> ListAtMost t a
03:13:37 <ski> where that latter type signature is equivalent to
03:13:47 <ski>   MkListAtMost :: (exists s. SmallerThan s t *> List s a) -> ListAtMost t a
03:14:08 <ski> this assumes that we also define a class `SmallerThan', though
03:14:21 <ski> an alternative would be to make a new type, like
03:14:35 <kstt> that's certainly beautiful, although slightly ambitious given my current understanding of the type rules
03:14:55 <kstt> But I keep it in my mind, as a second exercise
03:15:31 <kstt> Now I got the type right, I'll have to implement it :)
03:15:46 <ski>   data ListAtMost :: * -> * -> *
03:15:48 <ski>     where
03:15:53 <ski>     NilAM  ::                        ListAtMost         t  a
03:15:53 <ski>     ConsAM :: a -> ListAtMost t a -> ListAtMost (T_Cons t) a
03:16:57 <ski> here i've sortof fused the original type `List s a' with the constraint `SmallerThan s t'
03:17:44 <ski> (there's actually a small difference, but i'm not sure how often it would make a difference -- i think it can disappear with datakinds)
03:21:07 <kstt> ok, I'll investigate as soon as I have filter implemented right :)
03:24:27 <kstt> ... which I'm failing to do so far ...
03:33:34 <kstt> ahah, I triggered a "My brain just exploded" type error for the first time
03:33:46 <kstt> I'm quiet proud actually :)
03:36:23 * ski grins
03:41:39 <jeltsch> I think some time ago it was argued that all infix operators should be usable as type constructors, not just the ones that begin with a colon.
03:41:49 <jeltsch> Has this change been implemented in a newer GHC?
03:44:11 <int-e> jeltsch: I don't think so; the lexer still distinguishes varsym (not starting with :) and consym (starting with :)
03:45:57 <Philippa> and then you lose ~> as in Arrow (~>), no?
03:47:14 <kstt> ski: well ... I can't produce a working safeFilter
03:47:37 <kstt> Although I got something that typechecks now :)
03:49:36 <ski> (hm .. i suppose one could decide that infix type operators are constructors, *except* those starting with some character)
03:49:42 <ski> (vaguely cf. the MLs)
03:50:50 <kstt> so if someone feels like helping me now, that'd be nice
03:51:10 * ski hasn't seen any code, yet
03:53:42 <kstt> well ... this code is broken and certainly quiet ugly, so I feel a bit ashamed to link it publicly here :)  here it is : https://gist.github.com/1723126
04:20:27 <ski> kstt : hmm, i think you have a semantic error
04:20:33 <ski> @src filter
04:20:34 <lambdabot> filter _ []     = []
04:20:34 <lambdabot> filter p (x:xs)
04:20:34 <lambdabot>     | p x       = x : filter p xs
04:20:34 <lambdabot>     | otherwise = filter p xs
04:27:46 <jaspervdj> Any Haskellers attending FOSDEM this weekend?
04:33:16 * Botje_ again :P
04:33:22 <Botje_> if i get up in time
04:52:49 <kstt> ski: certainly ... The nil case should be ok. The non-nil case is a mess in my head. With regular lists [], we can easily 'cons' the matching element to the filtered tail, because types match "(:) :: _ -> [a] -> _". With safefilter, I'm embarrased, because "Cons :: _ -> List t a -> _", but "safeFilter :: _ -> _ -> AnyList a", so the types don't match.
04:53:33 <kstt> Hence the case ... of mess.
05:03:00 <kstt> allright, I got it right ...
05:03:33 <ski> nice !
05:04:26 <ski> (sorry, i didn't notice your previous comment until now)
05:04:34 <kstt> just removing the nested nil check
05:04:47 <PatrickRobotham> Is there any way to expand out a recursive definition? e.g. factorial 3 = 3 * (factorial 2) = ...
05:05:05 <ski> kstt : yeah, because that branch was semantically incorrect (did the wrong thing)
05:05:18 <ion> @where stepeval
05:05:19 <lambdabot> http://www.srcf.ucam.org/~bm380/cgi-bin/stepeval.cgi
05:05:23 <kstt> but ... I've been confused by the ghc error : "My brain just exploded. I can't handle pattern bindings for existential or GADT data constructors. Instead, use a case-expression, or do-notation, to unpack the constructor. ..."
05:05:55 <kstt> why is "let C x = expr in x" different from "case expr of C x -> x" ?
05:06:06 <kstt> the former is rejected while the latter is accepted
05:06:08 <ski> > let factorial 0 = 1; factorial n = n * factorial (n - 1) in factorial 3 :: Expr  -- hm
05:06:09 <lambdabot>   3 * ((3 - 1) * ((3 - 1 - 1) * 1))
05:07:30 <ski> kstt : i'm not sure whether there's any fundamental reason (in this case), but currently `let' can't handle matching on existential data constructors or on GADTs
05:08:21 <ski> (in case there are more than one GADT constructor that would apply, it would be unsafe)
05:08:28 <kstt> Indeed
05:08:49 <kstt> case allows type refinment on constructors
05:09:46 <kstt> my articular "box anything" type confused me
05:09:47 <ski> hm .. though i suppose with `data Foo :: * -> * where MkFoo :: Foo Int' `let MkFoo = undefined :: Foo Bool in ..' could be unsafe as well
05:09:49 <kstt> particular
05:09:59 <ion> ski: An excellent example of why Expr computing the values “smartly” (as discussed earlier) would be very bad.
05:10:04 <ski> if one used a bang pattern, it should be ok, i think
05:10:29 <rtharper_> how would I submit an event for the haskell.og page?
05:10:32 <rtharper_> *haskell.org
05:10:37 <ski> kstt : which type was that ?
05:10:55 <kstt> AnyList
05:11:08 <kstt> data AnyList :: * -> * where MkAnyList :: List t a -> AnyList a
05:11:08 <kstt>  
05:11:56 <ski> ion : hm, i must have missed that discussion
05:12:27 <PatrickRobotham> ion: Thank you :)
05:12:45 <ski> @karma+ ion
05:12:45 <lambdabot> ion's karma raised to 4.
05:14:19 <ion> Huh, where did i get 3? :-P
05:14:40 <shachaf> preflex: karma ion
05:14:40 <preflex>  ion: 11
05:15:28 <ski> kstt : the idea is that matching `safeFilter p tl', which has type `AnyList a', on `MkAnyList l' makes `l' have type `exists t. List t a', which means that theres some unknown type `t' such that `l' has type `List t a'
05:17:05 <ski> kstt : then `Cons hd l' gets type `List (T_Cons t) a' for *that* unknown type `t' -- if we call `T_Cons t' `s' here, then `Cons hd tl' has type `List s a', which means it has type `exists s. List s a', and therefore `MkAnyList (Cons hd l)' has type `AnyList a'
05:18:31 <ski> sorry, s/Cons hd tl/Cons hd l/
05:19:07 <kstt> ok
05:19:16 <ski> (that is using the `MkAnyList :: (exists t. List t a) -> AnyList a' intuition)
05:19:54 <kstt> and there is no way to write a function "extract :: AnyList a -> List t a" ...
05:20:06 <ski> if you want you could instead say that `Cons hd l' has type `List s a' (as before), and then because `MkAnyList :: forall t. List t a -> AnyList a', we specifically have `MkAnyList :: List (T_Cons t) a -> AnyList a' and therefore `MkAnyList (Cons hd l)' has type `AnyList a'
05:22:03 <ski> (note that i'm being very explicit about polymorphism in the reasoning here -- e.g. when i say `Cons hd l :: List (T_Cons t) a' or `MkAnyList (Cons hd l) :: AnyList a' i specifically do *not* mean that as an abbreviation of `Cons hd l :: forall t a. List (T_Cons t) a' or `MkAnyList (Cons hd l) :: forall a. AnyList a')
05:24:01 <kstt> you mean your type variables scope over your whole paragraphs ?
05:24:14 <ski> yes
05:24:31 <kstt> ok, that's how I read it
05:24:45 <kstt> thank you for your precious help !
05:24:57 <ski> yeah, i just wanted to emphasize it, in case you weren't (conciously) aware of it
05:25:13 <kstt> I think it is time for me to digest all that
05:25:41 <kstt> tomorrow maybe, I'll give a try at LessThan constructors
05:26:06 <kstt> err, types
05:26:13 <kstt> not constructors ... :)
05:26:25 <ski> type constructors ? :)
05:26:58 <kstt> yeah, probably :)
05:28:36 <neutrino> hello
05:29:02 <neutrino> i am having a problem defining an optional numeric parameter with CmdLib
05:29:38 <neutrino> i defined it as type Maybe Int, and added it to the default args which i use to instantiate CmdLib.executeR
05:30:08 <erus`> whats the haskell thing which means i can define sized vectors? is it kind families or something?
05:30:13 <neutrino> in the instance of CmdLib.Attributes for my module Main, I have also defined the options as being CmdLib.Required False
05:30:25 <neutrino> yet i get this error: FATAL: Malformed flag: No default value.
05:30:41 <neutrino> erus`: tuples? ..
05:31:04 <erus`> neutrino: bad joke bro
05:31:33 <neutrino> explain what you mean by "sized vectors"
05:31:46 <erus`> found it: GADT
05:32:08 <neutrino> yeah, GADT's are used for all sorts of stuff. probably also for "sized vectors" :)
05:32:11 <erus`> neutrino: first example on the wiki
05:32:18 <neutrino> nice
05:35:32 <nicoo> erus`: Could you paste the link; I don't find "sized vectors" in http://www.haskell.org/haskellwiki/GADT
05:36:03 <neutrino> maybe there's a wiki article for "sized vectors"
05:36:57 <erus`> http://www.haskell.org/haskellwiki/GHC/Kinds
05:37:43 <erus`> I hope they add syntactic sugar for number literals to Nats
05:37:49 <erus`> and Finites
05:40:56 * ski . o O ( "finities" )
05:41:01 <nicoo> erus`: Actually, the vector example is more than a GADT (even if syntax looks the same)
05:48:19 <roconnor> is there a function to inject ReaderT Identity into StateT Identity (or ReaderT m into StateT m?)
05:50:59 <int-e> :t get >>= lift . runReaderT ?a
05:51:01 <lambdabot> forall a (m :: * -> *) b (t :: (* -> *) -> * -> *). (MonadState a (t m), MonadTrans t, Monad m, ?a::ReaderT a m b) => t m b
05:51:38 <roconnor> well I already have \mr -> state $ \s -> (runReader mr s,s)
05:51:58 <int-e> that's a no (for all I know), but it seems easy enough to write without breaking the state abstraction.
05:52:26 <roconnor> @type \mr -> StateT $ \s -> (runReaderT mr s,s)
05:52:27 <lambdabot>     Occurs check: cannot construct the infinite type: s = (a, s)
05:52:27 <lambdabot>       Expected type: (a, s)
05:52:27 <lambdabot>       Inferred type: s
05:52:59 <roconnor> @type \mr -> StateT $ \s -> \x -> (x,s) <$> runReaderT mr s
05:53:00 <lambdabot>     Couldn't match expected type `a -> b'
05:53:00 <lambdabot>            against inferred type `(t, s)'
05:53:00 <lambdabot>     In the first argument of `(<$>)', namely `(x, s)'
05:53:12 <roconnor> @type \mr -> StateT $ \s -> (\x -> (x,s)) <$> runReaderT mr s
05:53:13 <lambdabot> forall s (m :: * -> *) a. (Functor m) => ReaderT s m a -> StateT s m a
05:54:36 <int-e> what's wrong with  get >>= lift . runReaderT ?a  ?
05:56:02 <roconnor> int-e: it requires the mtl which requires fundeps which isn't haskell 2010
05:59:17 <ski> @type \(StateT smas) amb -> ReaderT (\s -> do (a,s) <- smas s; return (runReader (amb a) s))
05:59:18 <lambdabot> forall (t :: * -> *) t1 r a. (Monad t) => StateT r t t1 -> (t1 -> Reader r a) -> ReaderT r t a
06:01:27 <int-e> roconnor: ok, that makes me wonder why  transformers  doesn't define a lift function (by whatever name) in Control.Moand.Trans.State
06:02:31 <int-e> ah. because. sorry, I'm mixing up the libraries.
06:17:36 * hackagebot language-javascript 0.4.7 - Parser for JavaScript  http://hackage.haskell.org/package/language-javascript-0.4.7 (AlanZimmerman)
06:34:36 <roconnor> @seen stepcut
06:34:36 <lambdabot> Unknown command, try @list
06:34:41 <roconnor> preflex: seen stepcut
06:34:41 <preflex>  stepcut was last seen on #haskell 8 days, 17 hours, 14 minutes and 28 seconds ago, saying: yay!
06:36:12 <Sefyroth> Famous last words.
06:38:36 <SirFrancisDrake> there is g@Struct{field=f} syntax in function declaration. But can I return an ADT with only one field modified without passing all the fields manually?
06:39:35 <SirFrancisDrake> like, fn g@Struct{ field = f } = g@Struct{ field = (f + 1) }
06:39:59 <roconnor> SirFrancisDrake: g{field = f}
06:40:16 <SirFrancisDrake> roconnor: thanks
06:40:31 <roconnor> SirFrancisDrake: if you start using nested records, you will want to use some lens package ... preferably data-lens :)
06:43:01 <SirFrancisDrake> roconnor: I'll read the docs and consider that, thank you.
07:30:47 <SirFrancisDrake> if I hold a number of TVars in an IntMap, will garbage collector collect the ones that get deleted from it?
07:31:19 <ion> It sounds like a bug if it didn’t.
07:31:49 <SirFrancisDrake> just making sure I get the idea of GC. Thank you
07:31:59 <roconnor> SirFrancisDrake: remember TVar is an indirection so there are two things subject to garbage collection, the value that the TVar holds, and the TVar box itself.
07:44:02 <SirFrancisDrake> roconnor: of course. But they should be both garbage collected in that case, shouldn't they?
07:45:32 <quicksilver> SirFrancisDrake: depends if other live code or data retains references to them, of course
07:45:46 <SirFrancisDrake> quicksilver: obviously
07:46:10 <saterus> is there a cabal specific irc channel? #cabal seems unrelated to haskell
07:46:42 <roconnor> Right it's possible to delete the TVar box itself, but the data will be kept alive if someone already read that data and is holding on to it.
07:46:47 <dcoutts> saterus: this channel is ok for support Qs, there's also #hackage for more in-depth discussions
07:46:48 <c_wraith> saterus: not really. but dcoutts is cabal's maintainer, and is usually here and in #ghc
07:46:59 <c_wraith> and in #hackage, apparently
07:47:00 <c_wraith> :)
07:47:08 <dcoutts> or yes, #ghc
07:47:15 <dcoutts> c_wraith: :-)
07:47:33 <quicksilver> the preferred approach is to intone "I SUMMON THE HOLY CABAL OF CABAL" and sacrifice a beetroot over the channel.
07:47:40 <quicksilver> normally dcoutts will appear at that point.
07:47:48 <roconnor> SirFrancisDrake: but yes, if you remove the TVar from the int map, and no one else is holding the TVar then it will be GC'd and then if no one else is holding onto the value held by the TVar, then that value will be GC'd
07:48:04 <saterus> dcoutts: ok, well i'm having some crazy issues installing packages via cabal. the configure step keeps forkbombing...
07:48:05 <dcoutts> quicksilver: beetroot, I like it. How did you know I was vegetarian? :-)
07:48:19 <ion> You may have mixed up beetroot and burrito.
07:48:28 <roconnor> @quote heels
07:48:29 <lambdabot> kmc says: One thing I've learned from open-source software is that if you invent enough wheels, one of them will turn out to be round and capable of rolling.
07:48:36 <dcoutts> saterus: forkbombing? interesting
07:48:37 <roconnor> @quote click
07:48:37 <lambdabot> edwardk says: heh i should probably just type up the problem specification in haskell and click compile. funny how that seems to yield the answer ;)
07:48:39 <roconnor> :/
07:48:48 <roconnor> @quote there.is.no
07:48:48 <lambdabot> LinusTorvalds says: The slogan of Subversion for a while was 'CVS done right', or something like that, and if you start with that kind of slogan, there's nowhere you can go. There is no way to do
07:48:48 <lambdabot> CVS right.
07:48:51 <roconnor> damn it
07:49:00 <ion> I loved that talk.
07:49:23 <quicksilver> dcoutts: ;)
07:49:32 <saterus> dcoutts: yeah. when cabal goes to configure certain packages, it decides to keep forking off processes to do configuring.
07:49:48 <roconnor> oh wait, the quote I'm looking for is about gtkhs, not cabal.
07:49:51 <dcoutts> saterus: yes, it calls a number of processes, but should be sequential
07:50:07 <dcoutts> and finite :-)
07:50:27 <saterus> dcoutts: if i dont set a ulimit, it forks until i run out of memory.
07:50:54 <saterus> setting it convervatively high, i still get 300 processes like this:
07:50:59 <saterus> "sh configure --with-compiler=ghc --prefix=/home/alex/.cabal --with-gcc=/usr/bin/gcc"
07:51:35 <roconnor> wtf?
07:51:44 <dcoutts> saterus: what is this "sh configure"?
07:52:05 <saterus> i just nuked my entire haskell system on Arch. "pacman -Rcsn ghc cabal-install" and then reinstalled only ghc, happy, alex, and cabal-install from pacman
07:52:39 <dcoutts> I presume you mean "cabal configure"
07:52:51 <saterus> the next step i tried to install xmonad, and it fails in this spectacular fashion when installing "x11-xft"
07:53:19 <saterus> dcoutts: i just ran "cabal install xmonad" and what i pasted above comes directly from "ps aux"
07:53:53 <dcoutts> ah, so cabal is calling a ./configure script
07:54:07 <saterus> i was having exactly the same issues with the "network" package while trying to install yesod. which is what led me to removing all my haskell stuff from my system. which meant i had to reinstall xmonad.
07:54:13 <saterus> dcoutts: yes, exactly
07:54:14 <dcoutts> presumably "x11-xft" has a ./configure script
07:54:57 <dcoutts> saterus: now when you say forkbomb, do you really mean it never stops, or just mean it runs many processes in sequence
07:55:27 <dcoutts> ./configure itself certainly runs lots of processes, since it's all shell code and doing 100's of tests, each of which involves running gcc and / or linker
07:55:33 <saterus> it continues to fork more and more of those configure processes until my system runs out of memory and crashes or it hits my process limit i set with ulimit
07:55:36 <dcoutts> but again, it's only sequential
07:56:02 <dcoutts> saterus: so there are multiple "sh configure" processes running at the same time?
07:56:07 <saterus> hundreds
07:56:44 <dcoutts> ok, definitely something squiffy going on
07:57:10 <saterus> agreed
07:57:25 <dcoutts> saterus: I don't have time right now to look at it, though perhaps in a couple hours
07:57:37 <dcoutts> could you email me all the details you've collected, plus version info etc
07:57:55 <saterus> dcoutts: http://i.imgur.com/IMQ69.jpg  i ran "cabal install xmonad" in the bottom terminal and "ps aux" in the top before pkilling all those things
07:58:01 <dcoutts> arch/os etc, ghc version, cabal --version
07:58:19 <saterus> dcoutts: sure thing, i'd love to know what is causing this
08:07:37 * hackagebot network 2.3.0.9 - Low-level networking interface  http://hackage.haskell.org/package/network-2.3.0.9 (JohanTibell)
08:37:37 * hackagebot http-conduit 1.2.2 - HTTP client package with conduit interface and HTTPS support.  http://hackage.haskell.org/package/http-conduit-1.2.2 (MichaelSnoyman)
08:37:39 * hackagebot idris 0.9.1 - Functional Programming Language with Dependent Types  http://hackage.haskell.org/package/idris-0.9.1 (EdwinBrady)
08:42:48 <nand`> Is there a way to use cabal in compatibility mode for GHC 6.x?
08:42:50 <byorgey> watching hackagebot is like sitting next to the final conveyor belt coming out of a candy factory
08:43:11 <nand`> The latest version of xmobar fails to build on my machine, but it works with GHC 7.x
08:46:46 <alistra> nand`: is the compatibility question related to the xmonad question?
08:47:38 * hackagebot pandoc-types 1.9.0.1 - Types for representing a structured document  http://hackage.haskell.org/package/pandoc-types-1.9.0.1 (JohnMacFarlane)
08:47:40 * hackagebot Bitly 0.1.0 - A library to access bit.ly URL shortener.  http://hackage.haskell.org/package/Bitly-0.1.0 (SergeyAstanin)
08:47:58 <nand`> alistra: yes
08:48:05 <nand`> xmobar, not xmonad
08:48:38 <mr_sleepyCarrot> what other programs made with haskell do you usually use except for xmonad and xmobar
08:49:34 <mr_sleepyCarrot> darcs is one, i guess :)
08:51:22 <erus`> ghc and ghci
08:51:35 <erus`> at least twice a week
08:51:54 <mr_sleepyCarrot> ah, yeah. those are obvious
08:52:16 <mr_sleepyCarrot> i use ghci daily. it is my calculator
08:52:19 <erus`> haskell is more about making some type check than making a finished program that opthers can use
08:54:20 <rata_> hi gyus
08:54:26 <rata_> guys
08:54:55 <erus`> elo
08:55:29 <rata_> I was looking in hoogle for something like a "monadic fold", but non in the sense of foldM, rather in the sense of (a -> b -> b) -> [m a] -> m b
08:55:37 <rata_> and there seems to be nothing like that
08:55:54 <yitz> @type mapM
08:55:54 <rata_> I'd have thought it was a common operation
08:55:55 <lambdabot> forall a (m :: * -> *) b. (Monad m) => (a -> m b) -> [a] -> m [b]
08:56:03 <opqdonut> rata_: use sequence
08:56:13 <rata_> @type sequence
08:56:14 <lambdabot> forall (m :: * -> *) a. (Monad m) => [m a] -> m [a]
08:56:14 <byorgey> @type \z f -> foldr (liftM2 f) (return z)
08:56:15 <lambdabot> forall a1 r (m :: * -> *). (Monad m) => r -> (a1 -> r -> r) -> [m a1] -> m r
08:56:19 <byorgey> ^^^
08:56:25 <opqdonut> :t \f z -> mapM (foldr f z) . sequence
08:56:26 <lambdabot> forall a (m :: * -> *) b. (Monad m) => (a -> m b -> m b) -> m b -> [[a]] -> m [b]
08:56:38 <opqdonut> gah
08:56:41 <byorgey> don't use sequence.
08:56:42 <yitz> byorgey wins the prize
08:57:06 <opqdonut> :t \f z -> fmap (foldr f z) . sequence
08:57:07 <lambdabot> forall a b (f :: * -> *). (Functor f, Monad f) => (a -> b -> b) -> b -> [f a] -> f b
08:57:12 <opqdonut> but yeah, byorgey's is better
08:57:13 <byorgey> it is just a normal fold if you first lift the (a -> b -> b) function to an (m a -> m b -> m b) function.
08:57:34 <byorgey> oh, I see, yes, that works too.
08:57:49 <rata_> thanks byorgey and opqdonut
08:58:40 <yitz> hmm are the solutions of byorgey and opqdonut equivalent?
08:59:00 <byorgey> they should be.  the proof is left as an exercise for the reader.
08:59:08 <byorgey> or for #haskell. =)
09:05:11 <rata_> oh, just discovered that it can be done with applicative functors too
09:05:18 <Nibble> yeah
09:05:39 <rata_> :t foldr (\a b -> (+) <$> a <*> b)
09:05:39 <lambdabot> forall a (f :: * -> *). (Num a, Applicative f) => f a -> [f a] -> f a
09:05:47 <byorgey> yup, you can replace 'return' with 'pure' and 'liftM2' with 'liftA2' in my solution
09:06:12 <byorgey> in opqdonut's solution you have to use 'sequenceA' instead of 'sequence' though off the top of my head I forget in which module that is defined.
09:06:13 <tgeeky> yitz: it's worth noting. When byorgey means "the proof is left as an exercise to the reader" he actually means it. When Oleg says that, he means you'll just have to take his word for it.
09:06:25 <byorgey> hehe
09:06:43 <byorgey> actually what I mean is "I'm too lazy to do it myself"
09:06:46 <tgeeky> that said, Oleg's word is actually considered *more* valid than a mathematical proof
09:06:49 <rata_> I don't know how to prove such a thing
09:07:25 <byorgey> rata_: start with one of them, and work through a chain of equivalent expressions by unfolding definitions, and applying the monad laws
09:07:40 <rata_> ah ok
09:08:39 <byorgey> for example, it might start like   foldr (liftM2 f) (return z) = foldr (\mx my -> mx >>= \x -> my >>= \y -> return (f x y)) (return z) = ...
09:08:45 <byorgey> actually you will probably also need induction.
09:09:24 <byorgey> it actually sounds like a fun exercise to me.
09:09:32 <byorgey> but then, I have a rather warped notion of fun.
09:09:36 <tgeeky> byorgey: you're pretty weird that way
09:09:36 <tgeeky> yeah
09:10:55 <byorgey> OK, back to writing lecture notes
09:12:22 <rata_> it'd be fun for me if I could check if am right or not when I finally come up with the proof
09:12:25 <rata_> thanks again byorgey
09:12:33 <tgeeky> byorgey: that's what #haskell is for
09:12:43 <byorgey> tgeeky: what, writing lecture notes?
09:12:47 <tgeeky> lots of people here are teachers or whatever, and would be happy to check a proof
09:12:50 <byorgey> rata_: you're welcome
09:13:15 <byorgey> rata_: yeah, if you want to try to prove it, ping me and I'll take a look at what you come up with
09:13:17 <tgeeky> byorgey: no, writing lecture notes is what they pay you the big buck for.
09:13:30 <byorgey> I wish
09:13:38 <tgeeky> byorgey: I didn't typo. I mean one dollar.
09:13:43 <byorgey> hahahaha
09:14:01 <byorgey> they pay me a bit more than that, thankfully
09:14:16 <tgeeky> some days it probably seems like it though :O
09:14:46 <tgeeky> how am I going to responsibily apportion this (one unit of currency) for my whole family!?
09:15:50 <nand`> Everybody's salary is 1¤
09:16:15 <ski> @index sequenceA
09:16:15 <lambdabot> bzzt
09:16:19 <byorgey> let me guess, where ¤ is a special unit equal to whoever's salary we are talking about?
09:16:27 <tgeeky> dirty tricks!
09:16:34 <ski> @type Data.Traversable.sequenceA
09:16:34 <lambdabot> forall (t :: * -> *) (f :: * -> *) a. (Data.Traversable.Traversable t, Applicative f) => t (f a) -> f (t a)
09:16:38 <tgeeky> http://i.imgur.com/lWHAI.jpg
09:16:47 <nand`> byorgey: yeah, ¤ is the generic “currency” symbol
09:16:55 <byorgey> context-sensitive units are tricky, they probably require dependent types
09:17:00 <nand`> which I didn't know until I discovered it on my keyboard
09:17:36 * ski pronounces the symbol `$' as "string"
09:17:43 <ion> It’s funny, some people used to use ISO-8859-15 in which € is in the same codepoint as ¤ in the de-facto legacy IRC charset (ISO-8859-1), so their euro signs would always look like the international currency sign.
09:17:46 <nand`> I pronounce it as “on”
09:18:31 <ion> > let (¤) = "foo" in (¤)
09:18:32 <lambdabot>   "foo"
09:18:44 <ion> > let (€) = "foo" in (€)
09:18:45 <lambdabot>   "foo"
09:19:49 <erus`> > let € = "bar" in €
09:19:50 <lambdabot>   <no location info>: parse error on input `
09:20:04 <erus`> > let (€) = "bar" in €
09:20:05 <lambdabot>   <no location info>: parse error on input `
09:20:18 <nand`> > let € = "bar" in (€)
09:20:19 <lambdabot>   <no location info>: parse error on input `
09:20:27 <tgeeky> I am disturbed by our lack of parentheses.
09:20:29 <nand`> now that we've exhaustively tried all options
09:23:31 <erus`> do you know of any scripting languages that allways terminate?
09:24:15 <nand`> Agda? Not sure if that's a scripting language
09:24:15 <erus`> i guess it wouldnt be perfect anyway
09:24:24 <nand`> Define scripting language
09:24:25 <erus`> someone would make a super long computation
09:24:43 <nand`> Easier to time limit if that's a concern
09:25:43 <cmccann> erus`, why do you want guaranteed termination?
09:25:58 * cmccann suspects that other restrictions would actually be more helpful in a scripting language
09:26:06 <erus`> so you can allow users to exec stuff on your server
09:26:08 <tgeeky> you could use ruby (which is surely a scripting language) and just get rid of all non-terminating functions.
09:26:36 <erus`> tgeeky: it needs to be staticly typed .... cmon
09:26:36 <cmccann> erus`, resource use is more of a concern than termination in that case
09:26:54 <cmccann> and if you need to check for resource use anyway you don't gain much by requiring termination
09:27:21 <erus`> correct code
09:27:31 <cmccann> it would be easy to DoS lambdabot with expressions that would (eventually) evaluate to something
09:29:24 <byorgey> > let ack 0 n = n + 1; ack m 0 = ack (m-1) 1; ack m n = ack (m-1) (ack m (n-1)) in ack 200 200
09:29:27 <lambdabot>   mueval-core: Time limit exceeded
09:29:41 <cmccann> byorgey, an obvious approach
09:30:07 <byorgey> although I guess proving that terminates can be difficult in languages which require it
09:31:00 <DrSyzygy> I seem to have TeXed a set of lecture notes on category theory and Haskell...
09:31:25 <byorgey> sweet!
09:31:29 <byorgey> DrSyzygy++
09:31:36 <DrSyzygy> byorgey: Also, the AMS has been approaching me about making a book out of them.
09:31:44 * byorgey drools
09:31:45 <DrSyzygy> Hmmm... should put the notes online.
09:31:56 <DrSyzygy> byorgey: You wanna read them through and tell me what I need to do different?
09:32:01 <byorgey> DrSyzygy: sure
09:32:30 <ion> I’d like to take a look too.
09:32:54 <tromp_> > let g b 0=b;g b n=g c$s 0n-1where s _ 0=0;s e n=mod n b*c^s 0e+s(e+1)(div n b);c=b+1 in map (g 2)[0..]
09:32:58 <lambdabot>   mueval-core: Time limit exceeded
09:33:12 <DrSyzygy> byorgey: http://cs.st-andrews.ac.uk/~mik/categories.pdf
09:33:18 <tromp_> > let g b 0=b;g b n=g c$s 0n-1where s _ 0=0;s e n=mod n b*c^s 0e+s(e+1)(div n b);c=b+1 in map (g 2)[0..2]
09:33:19 <lambdabot>   [2,3,5]
09:33:25 <tromp_> > let g b 0=b;g b n=g c$s 0n-1where s _ 0=0;s e n=mod n b*c^s 0e+s(e+1)(div n b);c=b+1 in map (g 2)[0..3]
09:33:26 <lambdabot>   [2,3,5,7]
09:33:31 <byorgey> DrSyzygy: cool, I'll take a look
09:33:35 <DrSyzygy> awesome
09:33:57 <DrSyzygy> the fundamental idea is to be a good resource for people who take a haskell class, hear "there's categories underneath" and want the details.
09:34:12 <tromp_> that grows quite a bit faster than ackerman's
09:34:52 <ion> > mueval-core: time limit exceeded
09:34:56 <lambdabot>   mueval-core: Time limit exceeded
09:34:58 <byorgey> DrSyzygy: yeah, that sounds great.
09:35:06 <tromp_> termination of goodstein sequences is unprovable in peano arithmetic
09:35:36 <byorgey> tromp_: cool =)
09:36:12 <byorgey> DrSyzygy: hmm, the link is not loading for me
09:36:22 <DrSyzygy> hmmm.
09:36:23 <copumpkin> DrSyzygy: you're at st andrews now?
09:36:28 <DrSyzygy> copumpkin: yup.
09:36:31 <copumpkin> cool :)
09:36:32 <DrSyzygy> copumpkin: In the GAP group.
09:36:46 <copumpkin> unfortunately your pdf doesn't load here :(
09:36:47 <DrSyzygy> Ah.
09:36:48 <DrSyzygy> http://www.cs.st-andrews.ac.uk/~mik/categories.pdf
09:36:59 <DrSyzygy> Bloody webserver needs the www. in front. >.<
09:37:04 <byorgey> ah, one of those annoying places where... yeah, that
09:37:54 <ion> thanks
09:37:54 <copumpkin> DrSyzygy: have you seen the fairly substantial (pure) CT library in agda that I wrote with a few people?
09:38:04 <DrSyzygy> copumpkin: Nooo...
09:38:06 <copumpkin> https://github.com/copumpkin/categories/tree/master/Categories
09:38:30 <DrSyzygy> neat
09:38:40 <copumpkin> probably doesn't help you much, but figured I'd point it out :)
09:38:43 <copumpkin> </plug>
09:38:45 <DrSyzygy> awesome
09:38:52 <DrSyzygy> Also, I think, on the wrong level for what I'm doing.
09:39:06 <DrSyzygy> Though I might want to pull at some of the things you do to enlarge my own scope.
09:39:35 <copumpkin> if you do, make sure you have a beefy computer cause that library takes gigs of RAM and half an hour to typecheck completely :P
09:39:47 <copumpkin> (or comment out monoidal categories)
09:39:50 <ion> hah
09:40:03 <DrSyzygy> :-P
09:42:21 * edwinb spots a St Andrean. I'm sure the cluster can cope with it ;)
09:43:31 <DrSyzygy> edwinb: Weeeell, yeah. I'm sure we've met IRL.
09:43:45 <DrSyzygy> oh, you mean the agda stuff?
09:43:46 <DrSyzygy> :-)
09:43:55 <edwinb> indeed
10:00:54 <ski> copumpkin : btw, iirc <http://chans.lib.chalmers.se/search~S1?/aGonzal{u00ED}a%2C+Carlos%2C/agonzalia+carlos/-3%2C-1%2C0%2CB/frameset&FF=agonzalia+carlos&2%2C%2C2> implemented some basic CT in type theory
10:07:09 <CodeWeaver> cmccann, you there?  I adapted your pythagorean program to a heap, and strictified a few fields, and it's stupidly fast.  Much better than my original attempt for obvious reasons of complexity.
10:07:27 <cmccann> yes I am, and awesome
10:07:40 <cmccann> I figured it was really being killed by the implementation
10:07:44 <cmccann> using lists that way was terrible
10:08:04 <CodeWeaver> Actually in terms of understanding the code it was pretty elegant, and for small n, it was probably bloody quick.
10:08:14 <CodeWeaver> But for the large n we were doing, yeah.
10:08:20 <CodeWeaver> http://hpaste.org/57197
10:08:47 <CodeWeaver> I could paste mine if you want to see how I approached it.  Its the best I could do in the absence of understanding the algebra that leads to the ternary tree you used.
10:11:11 <CodeWeaver> Actually the one I pasted in your pastebin isn't the final one… I went further for the field strictification.
10:11:46 <CodeWeaver> Then compiled with unbox-strict-fields.
10:12:30 <lpsmith> a program to produce all the pythagorean triples within some range?
10:12:59 <lpsmith> I have one that's a little slower than I'd like,  but still pretty good
10:13:01 <CodeWeaver> All primitive triples, ordered in b in (a,b,c)
10:13:17 <CodeWeaver> pythag triples.
10:14:10 <CodeWeaver> If you're going to do it, try to ignore cmccann's solution until you come up with your own.  Oh, you already have one.
10:14:34 <CodeWeaver> Anyway, the idea was to work out the ten thousandth term (indexed from 0) in the sequence.
10:16:26 <cmccann> CodeWeaver, pretty minor modifications all things considered
10:16:56 <CodeWeaver> Oh quite.  I didn't want to modify your code overmuch.  What would be the point?
10:17:09 <lpsmith> I'm not sure how this compares,  exactly,  in functionality or speed to your attempts:  http://hpaste.org/57333
10:17:32 <CodeWeaver> In my final, with even more trivial changes, I just made all the 3-tuples into a data structure of their own so I could easily strictify everything with just !.
10:17:41 <CodeWeaver> In the structures I mean.
10:17:49 <CodeWeaver> Other htan that…. no other changes.  Stupidly fast.
10:18:00 <lpsmith> I wish it was faster because I have to generate about 2.5 triples for every triple produced,  and I use O(n) memory to do so.
10:18:04 <CodeWeaver> I'll paste my original, which is all I can really lay claim to.
10:18:20 <CodeWeaver> And I'll benchmark Ipsmith's.
10:19:09 <lpsmith> So I'd like to generate fewer triples per triple produced,  and do it in less memory.
10:19:14 <alistra> what's the best thing todo if i want to keep a master password encrypted file and read it in haskell (possibly write), are there any libs for that?
10:19:41 <alistra> i tried invoking gpg but there are some problems with pinentry and i don't like the whole thing very much
10:19:46 <lpsmith> But the idea behind my code is fairly straightforward,  it's just Euclid's formula applied to the Calkin-Wilf tree.
10:20:19 <CodeWeaver> Does it generate only primitives by any chance?  And is it easy to generate them sorted in the middle term?
10:20:29 <CodeWeaver> (and where equal, the first term)
10:20:55 <CodeWeaver> Well, I supose I could just do a post-sort so that's hardly that ugly
10:21:04 <lpsmith> CodeWeaver, yes, it generates only primitive triples.   It's sorted by the hypotenuse,  then the shorter leg, then the longer leg
10:21:35 <CodeWeaver> Yes, so I'd have to resort them, but that's not catastrophic.
10:21:35 <lpsmith> if you want to sort by the longer leg...  I dunno,  that may not be so feasible with my approach
10:21:38 <CodeWeaver> I mean to compare against my sequence.
10:22:26 <cmccann> pretty sure lpsmith's is effectively doing the same thing mine does, but without building the tree
10:22:54 <CodeWeaver> Interesting.
10:23:04 <CodeWeaver> In which case it could be reordered, since yours was.
10:23:11 <roconnor> anyone have a compelling example where one would like to have a kind depending on a term?
10:23:12 <CodeWeaver> On the fly I mean.
10:23:43 <cmccann> and since I was effectively doing a breadth-first-search as I went anyhow it I think it amounts to the same thing
10:26:52 <CodeWeaver> Oh fine, Ipsmith, make me cabal a new package why don'tcha. :D
10:27:40 * hackagebot test-framework-doctest 0.2 - Test.Framework wrapper for DocTest  http://hackage.haskell.org/package/test-framework-doctest-0.2 (SakariJokinen)
10:31:16 <lpsmith> CodeWeaver, -funbox-strict-fields isn't going to get you much in your code,  you should try  HeapTriple !Int !Int !Int,  instead of HeapTriple (Int, Int, Int)
10:31:38 <CodeWeaver> Ipsmith, yes, I didn't paste the version I unboxed the strict fields on.
10:31:41 <CodeWeaver> I can do that shortly.
10:33:05 <lpsmith> that's Lpsmith, not Ipsmith by the way =)
10:33:10 <mdmkolbe> Anyone know if what Neil Mitchell's nick is?  His "derive" program is throwing an exception on me.
10:33:34 <CodeWeaver> Sorry, looks like an i over here.  I will adapt.
10:33:42 <CodeWeaver> LLLllLllLLllLlLpsmith.
10:33:42 <lpsmith> np
10:33:52 <CodeWeaver> You can totally hear the rolling l's.
10:35:31 <CodeWeaver> Anyway, cmccann's first version came to 10s.  I adapted it to down to 0.040s by way of using a heap for a priority queue, and the strictifying.
10:35:33 <alistra> @hackage RSA
10:35:34 <lambdabot> http://hackage.haskell.org/package/RSA
10:35:47 <lpsmith> mdmkolbe, I think it might be ndmitchell, but I'm not sure.
10:36:00 <lpsmith> preflex: seen ndmitchell
10:36:00 <preflex>  ndmitchell was last seen on #haskell 1 year, 316 days, 7 hours, 43 minutes and 52 seconds ago, saying: this is not ndmitchell, just testing to see if preflex remembers this nick...
10:36:18 <lpsmith> alrighty then
10:36:38 <ski> preflex: xseen ndm
10:36:39 <preflex>  ndm was last seen on freenode/#haskell 1 year, 45 days, 16 minutes and 40 seconds ago, saying: if you don't, then there was a parse error
10:37:02 <CodeWeaver> lpsmith's came to about 0.046s, which is just noise difference.  I can only assume this somehow comes from a clever implementation of ordered lists.
10:37:12 <ski> mdmkolbe : `ndm' afaik
10:37:22 <lpsmith> CodeWeaver, not that clever
10:37:34 <CodeWeaver> Well, it's clearly better than a linear insert.
10:37:53 <cmccann> CodeWeaver, more likely it's something that GHC can optimize better
10:38:28 <CodeWeaver> It's comparable to a heap priority queue.  I'd be surprised if that's a result of a linear list insert being optimized.
10:38:40 <CodeWeaver> Let's see how it grows on much larger n.
10:38:44 <lpsmith> So, conceptually,  my code applies Euclid's formula to the calkin wilf tree,  and then I flatten the tree into a list
10:39:17 <CodeWeaver> Wait, so ipsmith, does the flattened tree *naturally* come out with sorted on the hypoteneuse?
10:39:24 <lpsmith> but as I said,  I'm generating ~2.5 triples for every triple produced,  and keeping those around means I'm consuming O(n) memory to produce the nth triple.
10:39:28 <lpsmith> I'd really like to fix that
10:40:02 <lpsmith> CodeWeaver, I know that every node below me has a bigger hypotenuse
10:40:11 <CodeWeaver> But not necessarily in-order.
10:40:22 <CodeWeaver> When flattening.
10:40:40 <cmccann> well, it's merging two sorted lists, right?
10:40:42 <lpsmith> so I check the triple in my node to make sure it's primitive,   then I recursively flatten the two trees below me and maybe add the triple on front.
10:40:46 <lpsmith> right
10:41:21 <CodeWeaver> Because both my optimized O(n log n) version of cmccann's, and lpsmith's, are on a million terms, very near in terms of time.
10:41:34 * ski wonders about the topology generated by that Calkin-Wilf tree
10:42:08 * cmccann suspects that lpsmith's turns out better than it first sounds because of GHC's optimizer
10:42:21 <cmccann> and the ordered list library it uses
10:42:56 <CodeWeaver> Mine's n log n because of the heap insert and extract.  Although, it may be better than that depending on the heap implementation because the tree cmccann produces is also close to the correct order, so it's may not be the average O(log n) insert time.
10:43:11 <CodeWeaver> Not sure.
10:43:20 <CodeWeaver> It is intriguing in any event.
10:43:43 <cmccann> I suspect the heap operations and list merge work out to be nearly the same thing in the end
10:43:52 <lpsmith> unfortunately my code is not good enough for most Project Euler problems involving pythagorean triples :-P
10:44:20 <CodeWeaver> It's possible.  The thing that concerns me is that lpsmith is not producing them in the same order as cmccann and I are, so it may be comparing apples to oranges anyway.
10:45:08 <CodeWeaver> Neat problem though.  Didn't expect to see a serious variety of solutions.
10:45:16 <cmccann> the important thing is using one triple to generate more that are guaranteed to come later than their parent
10:45:28 <cmccann> the actual order doesn't really matter beyond that
10:45:40 <CodeWeaver> Well, it did for my puzzle. :P
10:46:17 <cmccann> since however you sort, the smallest will always be smallest possible at that point and large ones get tossed to the back
10:46:20 <CodeWeaver> Fortunately we matched for the first ten thousand, so I think I can for the moment assume that my slower version that carefully increments on the middle term on purpuse and your faster tree version produce the same values.
10:47:13 <CodeWeaver> cmccann:  The only thing that bothers me about that is there's nothing obvious in the tree generation that says to me that you can't end up with a smaller value popping out of one of the first two terms than you've already processed, and thus coming in the wrong order.
10:47:48 <cmccann> right, that's the property that I couldn't prove but was pretty confident of
10:48:10 <cmccann> and lpsmith is relying on it as well
10:48:39 <CodeWeaver> Quite.  So I'm not quibbling overmuch.
10:49:03 <CodeWeaver> I'd like to rework lpsmith's to generate them in the same order, but I'll ponder that later today.
10:49:18 <lpsmith> CodeWeaver, if you are successful I'd like to hear about it
10:49:49 <CodeWeaver> I haven't the slightest understanding of this Calkin-Wilf  tree, so I expect it to be far harder than adapting cmccann's solution. :D
10:49:52 <cmccann> lpsmith, mine is using a ternary tree from fibonacci boxes algorithm that I cribbed from wikipedia, btw
10:50:05 <lpsmith> cmccann, interesting
10:50:19 <lpsmith> I'll have to take a look at that later
10:51:12 <cmccann> it uses four values [a b c d] where c = a+b and d = b+c
10:51:20 <cmccann> so any two elements determine the rest
10:51:20 <CodeWeaver> Wait.
10:51:34 <CodeWeaver> The Calkin-Wilf tree looks an awful lot like the Farey Sequence.
10:51:47 <lpsmith> yeah, they are similar
10:51:53 <cmccann> each fibonacci box corresponds uniquely to a primitive triple
10:52:10 <cmccann> and from any box you can take the first and last element and generate three new boxes
10:52:59 <CodeWeaver> There's also, on wikipedia, a matrix version of the same tree so you can treat a pyth triple as a 3-vector, and multiply it by three different matrices to get the children.  Quite elegant.
10:53:04 <lpsmith> The calkin wilf tree is closely related to the stern brocot tree,  which has a certain relationship to the farey sequence
10:53:24 <CodeWeaver> okay, fair enough, but I haven't the foggiest how to relate this to pythags. :)
10:57:19 <lpsmith> CodeWeaver, it's not particularly related,  I'm just using the calkin wilf tree to generate relatively prime inputs to Euclid's formula, that's all.
10:57:28 <Jeanne-Kamikaze> There's this course at uni that deals with reflection, aspect oriented and prototype oriented programming. Are these things useful for a haskeller ? The wikipedia has information on reflection for example but it doesn't say how it's useful.
10:57:49 <lpsmith> (or at least,  I'm not aware they are related.  They probably are though, somehow)
10:58:15 <CodeWeaver> lpsmith… wait, relatively prime?  All the fractions in the tree are in lowest terms?
10:58:29 <prem> i need some help with haskell
10:58:54 <lpsmith> CodeWeaver, yup.  Same as the farey sequence
10:59:26 <CodeWeaver> O.o holy crap, a useful purpose for those sequences!  It didn't even occur to me!
11:02:45 <Saizan> Jeanne-Kamikaze: well, hard question but i'd say they can be, e.g. the Scrap Your Boilerplate approaches are based on some form of reflection
11:05:30 <lpsmith> prem, you've come to the right place.   Just ask a question. =)
11:05:45 <CodeWeaver> Indeed!
11:06:19 <CodeWeaver> Although I'll brb… must migrate laptop to new space.
11:11:15 <startling> Do you guys use any vim scripts for haskell? There appear to be a couple (in varying states of maintainance) and I'm not sure what to try.
11:12:06 <hughfdjackson> hey startling :3
11:12:12 <hughfdjackson> i don't have anything useful to add
11:12:17 <hughfdjackson> :p just .. *wave* hiii
11:12:25 <koeien> startling: i used plain vim
11:12:41 <koeien> startling: you could try evil-mode for emacs, if you dare to dot hat
11:12:46 <startling> hi hughfdjackson!
11:13:05 <startling> koeien: yeah, so do I at the moment. It'd be nice to have a buffer with ghci, though.
11:13:37 <hughfdjackson> startling: you could run conque
11:13:42 <hughfdjackson> then fire up ghci
11:14:57 <startling> hughfdjackson: woah, neat, I didn't know that existed. Thanks!
11:15:13 <hughfdjackson> ^^ welcome
11:28:24 <erus`> is there a neat way to represent types and terms with the same structure?
11:29:28 <cmccann> erus`, define "same structure"
11:29:42 <rata_> erus`: what are terms?
11:30:04 <ceii> rata_: a term is something you give a type to
11:30:19 <rata_> ??
11:30:32 <rata_> an expression?
11:30:35 <erus`> like data Term = Lambda Type Term | Application Term Term | Index Int    data Type = Arrow Type Type | Forall Kind Type | etc etc
11:30:36 <ceii> yes
11:30:36 <Ngevd> Is a MonadPlus a Monoid Monad?
11:30:56 <koeien> Ngevd: in some sense, yes
11:31:13 <ceii> Ngevd, plus some additional laws which no-one can agree upon
11:31:57 <ceii> but at least mzero >> m = mzero
11:32:19 <Ngevd> I never really got >>
11:32:36 <mjga> hughfgjackson: thx a lot, I didn't know about Conque too. Would you consider adding it to wiki? So far I used only the haskell mode hosted on code.haskell.org, though there are many more now: http://www.google.com/cse?cx=partner-pub-3005259998294962%3Abvyni59kjr1&ie=ISO-8859-1&q=haskell&sa=Search&siteurl=www.vim.org%2F#gsc.tab=0&gsc.q=haskell&gsc.page=1
11:32:37 <koeien> Ngevd: m >> m' is just m >>= (\_ -> m')
11:32:44 <Ngevd> I think the description in Control.Monad just sounds a lot like `seq`?
11:32:55 <Ngevd> Of course, I don't really know what seq is
11:33:00 <cmccann> Ngevd, it's just >>= but ignoring the argument
11:33:12 <koeien> seq is a language primitive
11:33:18 <Sgeo|web> Will nubBy work as I expect even if my comparison function says that a == b and b == c doesn't mean that a==c?
11:33:23 <koeien> it's a function that can only be defined with compiler help
11:33:32 <ceii> if you're a do notation junkie, m >> m' = do {m ; m'}
11:33:41 <mjga> erus`: that's called dependent typing. yes
11:33:42 <koeien> Sgeo|web: probably not, what a bizarre "equality"
11:33:47 <cmccann> however, if you imagine a "strict evaluation" monad then ($!) and seq would be roughly >>= and >> respectively
11:34:01 <Sgeo|web> :/
11:34:13 <cmccann> Sgeo, it may do something useful
11:34:17 <koeien> well-behaved equalities are equivalence relations
11:34:48 <cmccann> but it won't do what you expect because your "equality" doesn't do what anyone expects equality to :P
11:34:48 <Sgeo|web> nubBy (\(a, b) (c, d) -> length (nub [a,b,c,d]) < 4) pairs
11:35:12 <Sgeo|web> I want to prevent any two pairs that share an element from going into the list
11:35:24 <mjga> erus`: see Coq. of course underlying these languages are representations that unify terms and types
11:35:39 <Sgeo|web> (And no pair has two identical elements, so that issue with my line is not a concern)
11:35:49 <koeien> Sgeo|web: f [] = []; f ((x,y):xs) = (x,y): filter (not . overlaps (x,y)) xs
11:36:03 <koeien> overlaps (x,y) (x',y') = ...
11:36:34 <cmccann> Sgeo, isn't that potentially dependent on the order you compare things in?
11:37:11 <cmccann> what if you have the pairs (x, y), (y,z), and (z, x)?
11:37:23 <Sgeo|web> First one winning is fine
11:37:37 <ceii> @src nubBy
11:37:37 <lambdabot> nubBy eq []             =  []
11:37:37 <lambdabot> nubBy eq (x:xs)         =  x : nubBy eq (filter (\ y -> not (eq x y)) xs)
11:37:55 <koeien> I'm not sure if this implementation of nubBy is specified
11:38:01 <Sgeo|web> That looks like it will do what I want, but haddock says GHC defines its own nubBy, and I'm less certain about that
11:38:05 <cmccann> Sgeo|web, but then that changes which elements end up in the list which can change which others get added
11:38:16 <Sgeo|web> http://hackage.haskell.org/packages/archive/base/latest/doc/html/src/Data-List.html#nubBy
11:38:19 <mjga> erus`: lambda-expressions terminate if recursion is not allowed, so you know where you go. just add types and values. however these are wee bit more complex than Haskell types, and more difficult to use
11:38:27 <niteria> is there a smarter indenting for haskell and vim?
11:38:29 <Sgeo|web> cmccann: I'm fine with that
11:38:33 <cmccann> ok
11:38:34 <niteria> mine sucks
11:39:32 <startling> niteria: mine too. :/
11:39:58 <ceii> Sgeo|web, the GHC implementation seems to do what you expect as well
11:40:03 <Sgeo|web> ceii: thanks
11:40:13 <ceii> at least it will return a maximal sublist with no two "equal" elements
11:40:25 <hughfdjackson> mjga: ah!
11:40:29 <hughfdjackson> i missed your post before
11:40:38 <ceii> if there are several of them, you're on your own
11:40:41 <niteria> I must hit tab dozen times after I open do block
11:40:43 <hughfdjackson> i haven't used it for ghci, so i don't want to recommend it personally
11:40:47 <Sgeo|web> ceii: several of them?
11:40:54 <hughfdjackson> if you find it useful in the long run, it'd be great if you would
11:41:09 <copumpkin> BLAST! hard cheese :(
11:41:11 <hughfdjackson> i don't want to immortalise the suggestion until i'm sure it's really useful ;)
11:41:19 <ceii> well no, actually it's simply the first element that wins
11:41:34 <cmccann> copumpkin, says the dualized squash
11:42:08 <dmwit> Blast Hardcheese, Defender of the Galaxy!
11:42:16 <Sgeo|web> As long as it does n^2 comparisons, I think it's good
11:42:22 <Sgeo|web> And doesn't try to take shortcuts
11:42:56 <ceii> Sgeo|web, it doesn't take shortcuts
11:43:09 <Sgeo|web> Ok
11:43:25 <dmwit> niteria: :set ai
11:43:32 <ceii> takes the next element, sees if it's equal to an element of the current result, if not adds it, repeats
11:43:33 <dmwit> maximum = head . sort
11:43:59 <rata_> is there anything like hoogle that when you give a function signature to it, if it doesn't find any match, tries to combine functions to get what you asked for?
11:44:23 <cmccann> rata_, hoogle with manual defaulting to djinn? :P
11:44:25 <niteria> dmwit: ai just keeps my current indent level
11:44:29 <dmwit> I think doing that kind of thing is an active research topic.
11:44:30 <dmwit> rata_: ^^
11:44:42 <dmwit> niteria: yes, it's about the nicest I've found =/
11:45:09 <rata_> cmccann: what's djinn?
11:45:24 <dmwit> ?djinn (a -> b) -> (a -> a -> a) -> (a -> a -> b)
11:45:24 <lambdabot> f a _ b _ = a b
11:45:25 <rata_> dmwit: cool then, I got to wait a bit
11:46:25 <nand`> ?djinn a -> b
11:46:25 <lambdabot> -- f cannot be realized.
11:46:26 <rata_> dmwit: well, that's not combining functions
11:46:37 <dmwit> No, I picked a bad example.
11:46:46 <cmccann> ?djinn (a -> (b -> r) -> r) -> ((a -> r) -> r) -> (b -> r) -> r
11:46:46 <lambdabot> f a b c = b (\ d -> a d c)
11:47:22 <dmwit> ?djinn (a -> a -> b) -> (i -> a) -> (o -> a) ->
11:47:22 <lambdabot> Cannot parse command
11:47:25 <parcs`> yay >>=
11:47:29 <rata_> that's not combining functions either
11:47:36 <niteria> syntax highlighting is poor too, it only highlights strings and keywords
11:47:50 <startling> niteria: there are better syntax highlighting things you can get
11:47:50 <rata_> by functions I mean Prelude + other libs functions
11:47:57 <rata_> not made-up functions
11:48:02 <cmccann> parcs`, it's a lot simpler without the ContT wrapping and unwrapping
11:48:08 <ceii> rata_, djinn works in an empty library environment
11:48:13 <dmwit> ?djinn (a -> a -> b) -> (i -> a) -> (o -> a) -> i -> o -> b
11:48:13 <lambdabot> f a b c d e = a (b d) (c e)
11:48:17 <parcs`> ?djinn ((a -> (b -> r) -> r) -> (a -> r) -> r) -> (a -> r) -> r
11:48:17 <lambdabot> f a b = a (\ c _ -> b c) b
11:48:17 <rata_> ceii: that's too bad
11:48:20 <parcs`> yay callCc
11:48:25 <ceii> it's mostly useful for munging complicated higher-order types
11:48:29 <dmwit> rata_: There, that's combining functions (taken as arguments).
11:48:29 <ceii> and for fun
11:48:33 <parcs`> cmccann: yeah
11:48:59 <cmccann> I think djinn can use other functions as well
11:49:02 <parcs`> callCC is so simple without the newtype
11:49:03 <cmccann> but you have to tell it to
11:49:03 <dmwit> niteria: I have a good highlighter, hold on.
11:49:43 <shachaf> parcs`: It is?
11:49:46 <ceii> I have a feeling running djinn using all of hackage will not be fast
11:49:49 <ceii> :)
11:49:57 <cmccann> ?djinn ((a -> (b -> r) -> r) -> (a -> r) -> r) -> (a -> r) -> r
11:49:57 <lambdabot> f a b = a (\ c _ -> b c) b
11:50:04 <parcs`> shachaf: yeah
11:50:04 <shachaf> Are you talking about ((p -> q) -> p) -> p or about the expanded newtypev ersion?
11:50:07 <niteria> I've just found nicer ones, but there are few alternatives
11:50:18 <shachaf> Oh, the expanded version.
11:50:29 <shachaf> The newtyped version's type looks simpler to me.
11:50:41 <parcs`> i mean the definition, not the type
11:50:42 <cmccann> the implementation is simpler without the wrapper
11:50:46 <cmccann> the type is atrocious
11:50:55 <shachaf> Oh, well, the definition, sure.
11:51:03 <shachaf> That's because newtypes are awkward to work with in Haskell.
11:51:03 <Ngevd> What does djunn do?
11:51:11 <parcs`> @help djinn
11:51:12 <lambdabot> djinn <type>.
11:51:12 <lambdabot> Generates Haskell code from a type.
11:51:12 <lambdabot> http://darcs.augustsson.net/Darcs/Djinn
11:51:18 <dmwit> niteria: Um... check that you have a recent vim (>=7) and that it's getting the right filetype (:set ft?).
11:51:41 <cmccann> Ngevd, it's reverse type inference, given a type it infers a term with that type :D
11:51:46 <dmwit> niteria: According to the wiki, the highlighting package I use is bundled with vim these days.
11:51:49 <parcs`> @djinn a -> a
11:51:49 <djanatyn> Is there a way to drop two elements at the *end* of the list, in Prelude?
11:51:50 <lambdabot> f a = a
11:51:56 <djanatyn> Or do I need to write my own function?
11:52:01 <cmccann> > inits [1..10]
11:52:02 <lambdabot>   [[],[1],[1,2],[1,2,3],[1,2,3,4],[1,2,3,4,5],[1,2,3,4,5,6],[1,2,3,4,5,6,7],[...
11:52:03 <djanatyn> Something like drop, but at the other end.
11:52:07 <cmccann> > init [1..6]
11:52:07 <niteria> dmwit: does it highlight types?
11:52:08 <lambdabot>   [1,2,3,4,5]
11:52:09 <parcs`> @djinn const :: a -> b -> a
11:52:09 <lambdabot> Cannot parse command
11:52:28 <Ngevd> ?djinn (a -> a) -> a -> a
11:52:28 <lambdabot> f a = a
11:52:33 <shachaf> djanatyn: It's awkward to write, and that's probably mainly because it's an awkward operation to do in general.
11:52:41 <djanatyn> Yeah, it is really awkward.
11:52:47 <shachaf> Linked lists are much more suitd to operations done on the front.
11:52:47 <DrSyzygy> ?djinn (a -> a) -> b -> c
11:52:47 <lambdabot> -- f cannot be realized.
11:53:03 <shachaf> Are you sure you actually need to do what you want to do?
11:53:04 <Peaker> djanatyn: It makes sense to write something that operates on the reversed list:  inReverse f = reverse . f . reverse
11:53:11 <parcs`> @. djinn type \a b -> a
11:53:11 <djanatyn> I'm garbbing the contents of a directory with getDirectoryContents in System.Directory, but I don't want the "." and ".." items.
11:53:12 <lambdabot> f a _ = a
11:53:14 <Peaker> djanatyn: then you can use: inReverse (drop 2)
11:53:22 <djanatyn> Ah, thanks.
11:53:39 <shachaf> djanatyn: I don't think there are guarantees on the order that the directories come in.
11:53:49 <DrSyzygy> ?djinn (a -> a) -> b -> (a -> b)
11:53:50 <lambdabot> f _ a _ = a
11:54:13 <shachaf> Have you considered dirs \\ [".", ".."]?
11:54:14 <ceii> djanatyn, wouldn't filter (not . (`elem` [".",".."])) be cleaner? It doesn't depend on the order of the results
11:54:20 <cmccann> p.s. you can install djinn from hackage
11:54:29 <parcs`> > (\n -> zipWith const <*> take n) 3 [1..10]
11:54:30 <lambdabot>   [1,2,3]
11:54:34 <parcs`> o
11:54:39 <cmccann> I think you wanted drop :P
11:54:39 <parcs`> > (\n -> zipWith const <*> drop n) 3 [1..10]
11:54:40 <lambdabot>   [1,2,3,4,5,6,7]
11:54:40 <ceii> oh, (\\)
11:54:41 <shachaf> Or what ceii said (though that's maybe a little bit less efficient?)
11:54:50 <ceii> I wish I remebrered that one
11:55:05 <monochrom> same efficiency
11:55:06 <shachaf> ceii: Also notElem. :-)
11:55:14 <dmwit> niteria: http://dmwit.com/Connexus.hs.html shows pretty much what I see here on a sample file
11:55:19 <ceii> shachaf, mea culpa
11:55:26 <shachaf> monochrom: The \\ version will stop scanning the list once it finds both "." and "..".
11:55:38 <shachaf> Whereas the other version will construct a new spine alone the entire length of the list.
11:55:42 <djanatyn> > (drop 2) . reverse [1..10]
11:55:43 <lambdabot>   No instances for (GHC.Num.Num [a], GHC.Enum.Enum [a])
11:55:43 <lambdabot>    arising from a use...
11:55:51 <djanatyn> why can't I do that?
11:56:00 <shachaf> Because of how Haskell is parsed.
11:56:09 <ion> Re: callCC, https://gist.github.com/1327699
11:56:11 <ceii> > drop 2 $ reverse [1..10]
11:56:11 <djanatyn> reverse is [a] -> [a], and drop 2 is [a] -> [a]
11:56:12 <lambdabot>   [8,7,6,5,4,3,2,1]
11:56:16 <djanatyn> ...ah.
11:56:23 <djanatyn> Sorry, brainfreeze.
11:56:23 <ceii> > drop 2 . reverse $ [1..10]
11:56:24 <lambdabot>   [8,7,6,5,4,3,2,1]
11:56:37 <djanatyn> Not sure why I was using composition there.
11:56:45 <niteria> dmwit: that's the way it works for me now, it would be nice if it highlighted types
11:56:56 <monochrom> > length ([(), undefined] \\ [()])
11:56:57 <lambdabot>   1
11:57:19 <monochrom> you are right
11:59:16 <dmwit> niteria: Well, you know the rule about open source and "it would be nice if X". ;-)
11:59:42 <ion> Evaluating a callCC call step by step for the case of using the continuation the HOF gets from it and not using it really helps to understand what’s going on.
12:01:53 <niteria> dmwit: it doesn't sound easy
12:03:16 <rata_> niteria: do you want modules and types with different colors?
12:03:42 <cmccann> dmwit, the rule is that N people each spend T minutes complaining about that, where N * T > the amount of time it would have taken any one of them to just do it
12:04:16 <monochrom> in callCC (\k -> blah >>= rest) >>= f, blah receives two continuations: rest and k. blah can choose which one to jump to. (k packages up f, so jumping to k is jumping to f)
12:05:08 <niteria> rata_: i don't care how modules are highlighted
12:05:42 <niteria> what would be nice is highlighted types and color depending if they're parametric or not
12:05:53 <niteria> depending on*
12:05:54 <monochrom> example: callCC (\k -> when b (k ()) >>= rest) >>= f  jumps to rest or jumps to f depending on b
12:07:24 <niteria> it could be easy if ghc returned all types from the module, it could also be slow
12:07:59 <niteria> well, it's not that big deal
12:08:07 <c_wraith> couldn't you use the .hi files for that info?
12:08:51 <rata_> niteria: it's not difficult at all, just create a syntax file for haskell (haskell.vim) and put there something like ":syntax match Statement /[A-Z][a-z]*/"
12:09:16 <rata_> you could do better anyway using look aheads and look behinds
12:09:29 <dcoutts__> http://www.reddit.com/r/haskell/comments/p886g/ghc_741_is_out_heres_the_release_notes/
12:09:52 <koeien> dcoutts__: awesome!
12:09:55 <monochrom> yikes
12:10:01 <dcoutts__> @arr!
12:10:01 <lambdabot> Yeh scurvy dog...
12:10:07 <dcoutts__> lambdabot: so rude!
12:10:07 <niteria> rata_: it's better, thanks
12:10:16 <parcs`> yay
12:10:23 <dcoutts__> koeien: indeed :-)
12:10:29 <dcoutts__> lots of new stuff in 7.4
12:10:34 <parcs`> unfortunately -fdefer-type-errors didn't make it :(
12:10:40 <niteria> c_wraith: how to get .hi file?
12:10:42 <dcoutts__> and will be the basis for the next haskell platform release
12:10:43 <cmccann> ooooh new ghc
12:10:46 <koeien> will there be a HP release for 7.4.x ?
12:10:47 <monochrom> horrible horrible, another new GHC version. I mean congratulations!
12:10:49 <koeien> oh answered. ty.
12:11:05 <c_wraith> niteria: well, ghc generates them automatically when it compiles a module
12:11:17 <niteria> c_wraith: nvm, found an option
12:11:33 <cmccann> monochrom, but this version has even more arcane and non-portable extensions that enable overengineered code
12:11:33 <monochrom> ok, now newbies will not be able to ask "why is 'f x = x+1' rejected?" :)
12:11:54 <rata_> niteria: was it useful then?
12:11:54 <dcoutts__> koeien: right, we the timing and stability were not right for the 7.2.x release, but we're expecting to use 7.4.x
12:12:07 <koeien> dcoutts__: yeah we just skipped the 7.2 release :)
12:12:13 <niteria> rata_: yes, definitely
12:12:16 <rata_> =)
12:12:24 <koeien> good to hear that 7.4 will be supported
12:12:31 <niteria> uh, .hi file is binary file
12:12:37 <dcoutts__> 7.2 was intended by the GHC devs as a tech preview
12:12:38 <CodeWeaver> Oh good grief.  7.4.1.
12:12:39 <monochrom> and kind constraints will blow many fuses
12:13:15 <parcs`> monochrom: that still doesn't work
12:13:54 <monochrom> oh! Num doesn't have Eq or Show. many people will be happy
12:14:06 <Sgeo|web> WTF at DataKinds
12:14:14 <Sgeo|web> Dependent typing?
12:14:25 <parcs`> no, just less boilerplate
12:14:32 <shachaf> monochrom: Many people will be unhappy.
12:14:49 <monochrom> yes, but we can just say they are old-geezers :)
12:15:18 <shachaf> We can say that they like GHC to follow the Haskell Report.
12:15:19 <koeien> ah. LLVM 3.0!
12:15:20 <monochrom> at any rate, apparently some haskell committee or haskell standard library committee ok'ed that one
12:15:23 <mdmkolbe> Why does GHC still complain about these when compiled with -XOverlappingInstances? <http://hpaste.org/57337>  Shouldn't the "Rep (Everywhere HsName) HsName" instance be more specific than the "Rep g[a6Y6] HsName" instance?
12:15:50 <monochrom> so the reports are just lagging
12:15:53 <koeien> and the +RTS flags.
12:16:12 <cmccann> shachaf, I suppose a "do things the stupid way, like the report says" flag would be nice
12:16:13 <Sgeo|web> write <em>any</em> type
12:16:51 <monochrom> "It is now possible to write compiler plugins."
12:17:09 <Sgeo|web> Would it make sense to give an Eq instance to Nums where equality is undecidable?
12:17:12 <Sgeo|web> (Say, CReal)
12:17:14 <cmccann> Sgeo|web, and no, if you're looking at what I think you are it's just lifting things. there's no "terms -> types" going on, just defining type-level data that happens to look exactly like term-level data
12:17:16 <monochrom> someone should write a plugin that strictifies everything :)
12:17:16 <rpglover64> Anyone here have experience developing multiple interdependent packages at once?
12:17:42 * hackagebot ircbot 0.3.0 - A library for writing irc bots  http://hackage.haskell.org/package/ircbot-0.3.0 (JeremyShaw)
12:18:23 <monochrom> I think providing undecidable equality is undesirable
12:19:11 <Sgeo|web> Can CReal == CReal ever terminate as True?
12:19:22 <koeien> no.
12:19:29 <Sgeo|web> :(
12:19:37 <Sgeo|web> I'm sure some implementations of the same concept could
12:19:52 <dcoutts__> rpglover64: yep, e.g. gtk2hs is actually 6 packages
12:20:23 <rpglover64> In particular, I have a problem where one of the packages gets updated and rebuilt, so is ABI incompatible with its old self, but another package that depends on it needs to be reconfigured, but I don't know that until I try to build it and it fails.
12:20:39 <parcs`> monochrom: it's been done already: https://github.com/thoughtpolice/strict-ghc-plugin
12:20:54 <rpglover64> dcoutts__: what's your build system look like?
12:21:47 <monochrom> life mimicks irc
12:22:57 <rpglover64> Although, I guess with a released project, multiple packages wouldn't change at once, or they would very rarely.
12:23:07 <k0ral> hi, what is the shorter way to find all n-grams from a given list ? I'm thinking of a sequence of zip . tail
12:24:42 <dcoutts__> rpglover64: cabal install ./gtk ./glib ./cairo ./pango ./gio
12:25:27 <rpglover64> dcoutts__: I was hoping that wasn't the answer :(
12:25:27 <djanatyn> hmm
12:26:01 <rpglover64> I'm using cabal build && cabal register --inplace
12:26:08 <Sgeo|web> ./
12:26:08 <Sgeo|web> ?
12:26:18 <dcoutts__> Sgeo: ./ current directory
12:26:25 <djanatyn> http://hpaste.org/57338 -- can anyone help me figure out what's causing the compiler errors?
12:26:42 <dcoutts__> Sgeo: the directory ./gtk/  not the gtk package from hackage
12:27:04 <dcoutts__> rpglover64: that'd also work
12:27:16 <dcoutts__> rpglover64: yes, it's not great for working with multiple packages atm
12:31:49 <cmccann> Sgeo|web, if you have "exact reals" in a lazy sequence form of some sort, what you probably want is a similarly lazy "maximum difference" operation
12:35:11 <Sgeo|web> dcoutts__: ah
12:37:42 * hackagebot ircbot 0.3.1 - A library for writing irc bots  http://hackage.haskell.org/package/ircbot-0.3.1 (JeremyShaw)
12:43:59 <lukish> Is there some (>>=) analog for not monad?
12:44:23 <aluink> data Foo = Foo {f :: String} | Bar {b :: String}
12:44:29 <cmccann> lukish, in what way?
12:44:30 <aluink> :t f
12:44:31 <lambdabot> forall a. (SimpleReflect.FromExpr a) => a
12:44:33 <parcs`> lukish: *> in analogous to >>
12:44:36 <parcs`> is
12:44:37 <lukish> @hoogle a -> a -> b -> b
12:44:37 <lambdabot> Graphics.Rendering.OpenGL.GL.VertexSpec Color3 :: a -> a -> a -> Color3 a
12:44:38 <lambdabot> Graphics.Rendering.OpenGL.GL.VertexSpec Normal3 :: a -> a -> a -> Normal3 a
12:44:38 <lambdabot> Graphics.Rendering.OpenGL.GL.VertexSpec TexCoord3 :: a -> a -> a -> TexCoord3 a
12:44:46 <lukish> @hoogle a -> (a -> b) -> b
12:44:47 <lambdabot> Prelude ($) :: (a -> b) -> a -> b
12:44:47 <lambdabot> Data.Function ($) :: (a -> b) -> a -> b
12:44:47 <lambdabot> Prelude ($!) :: (a -> b) -> a -> b
12:44:55 <cmccann> lukish, fmap, (<*>), and $ are all similar to (>>=) in certain ways
12:45:17 <lukish> I'm searching for some pipe-like syntax
12:45:23 <cmccann> oh
12:45:28 <cmccann> you just want flip ($) then
12:45:31 <aluink> how do you get past the type safety problem of b :: Foo -> String not working on anything build with Bar :: String -> Foo?
12:45:33 <cmccann> I don't think there's a standard one anywhere
12:45:49 <cmccann> I have one in a library I use for my own projects
12:45:53 <lpsmith> I've been using |>  some,  mimicking F#
12:46:03 <cmccann> yes, I call it |>
12:46:07 <cmccann> I also have a <|
12:46:32 <cmccann> both of which have very low precedence and go nicely with <<< and >>> from Category
12:47:35 <cmccann> https://github.com/isomorphism/application-operators if anyone wants to see my frivolous little package :P
12:47:42 * hackagebot couchdb-conduit 0.4.2 - Couch DB client library using http-conduit and aeson  http://hackage.haskell.org/package/couchdb-conduit-0.4.2 (AlexanderDorofeev)
12:50:16 <djanatyn> hahahaha
12:50:22 <djanatyn> I spent the past 20 minutes working on this
12:50:29 <djanatyn> I thoguht this function returned IO [Entry]
12:50:36 <djanatyn> And then I thought it returned [IO Entry]
12:50:44 <djanatyn> But it actually returned IO [IO Entry] :)
12:50:53 <cmccann> best of both worlds!
12:51:07 <djanatyn> :)
12:51:16 <djanatyn> obviously, I think I need to make this function a little less Io-y
12:51:29 <cmccann> not necessarily
12:51:36 <cmccann> keeping a list of IO actions is pretty handy
12:51:38 <djanatyn> I'll paste the code
12:52:27 <djanatyn> http://hpaste.org/57339
12:54:17 <cmccann> djanatyn, you probably want "mapM generateEntry $ drop 2 $ reverse contents" on line 31
12:57:42 * hackagebot graph-rewriting-lambdascope 0.4.11 - Implementation of Lambdascope as an interactive graph-rewriting system  http://hackage.haskell.org/package/graph-rewriting-lambdascope-0.4.11 (JanRochel)
12:58:31 <lukish> :t (|>)
12:58:32 <lambdabot> Not in scope: `|>'
12:58:52 <cmccann> lukish, it's not a standard definition anywhere
12:58:56 <cmccann> just common because of F#
12:58:59 <cmccann> and because it looks nice
12:59:21 <lukish> (|>) = flip ($)
12:59:21 <DanBurton> @let (|>) = flip ($)
12:59:22 <lukish> ?
12:59:22 <lambdabot>  Defined.
12:59:29 <DanBurton> :t (|>)
12:59:29 <lambdabot> forall a b. a -> (a -> b) -> b
12:59:36 <lukish> Best timing lol
12:59:39 <DanBurton> xD
13:00:14 <DanBurton> > 3 |> (+1)
13:00:16 <lambdabot>   4
13:00:39 <cmccann> lukish, e.g. see the github link above for my own version :P
13:01:06 <Ngevd> :t S.|>
13:01:07 <lambdabot> parse error on input `S.|>'
13:01:12 <Ngevd> :t (S.|>)
13:01:12 <lambdabot> Couldn't find qualified module.
13:01:15 <Ngevd> :t (Set.|>)
13:01:16 <lambdabot> Couldn't find qualified module.
13:01:23 <Ngevd> Wait, it's Seq isn't it
13:01:28 <Enigmagic> Seq
13:01:31 <Ngevd> Silly me
13:01:47 <Ngevd> I'm going to go to bed now before I embarrass myself further
13:03:36 <k0ral> > cycle [1, 2, 3]
13:03:37 <lambdabot>   [1,2,3,1,2,3,1,2,3,1,2,3,1,2,3,1,2,3,1,2,3,1,2,3,1,2,3,1,2,3,1,2,3,1,2,3,1,...
13:05:07 <pokoko222> hi haskell dudes
13:05:11 <pokoko222> havent been here long time
13:06:21 <DanBurton> pokoko222: hello fellow Haskeller
13:06:42 <pokoko222> hello mortal
13:07:56 <CodeWeaver> Heh. :)
13:08:53 <mkscrg> so i'm trying to figure out how QuickCheck, test-framework, and cabal test-suite all fit together. i understand QC pretty well, but i don't understand how it fits in with the latter two or how they work together
13:08:54 <mkscrg> advice?
13:10:38 <Sgeo|web> Is there a nice medium or filetype I can output to such that I can control page breaks?
13:11:23 <DanBurton> Sgeo|web: so you're outputting some sort of human-readable document?
13:11:31 <Sgeo|web> Yes
13:11:56 <Clint> the ascii page break character is ^L
13:11:58 <DanBurton> do you want to specify page breaks at certain points, and let it automatically insert page breaks as necessary otherwise?
13:12:05 <k0ral> > let n=1
13:12:06 <lambdabot>   not an expression: `let n=1'
13:12:07 <Sgeo|web> Hmm
13:12:15 <Sgeo|web> Clint, how many things respect that?
13:12:22 <DanBurton> Or do you plan on manually specifying all page breaks?
13:12:31 <Sgeo|web> Automatically insert page breaks I guess
13:12:31 <Clint> Sgeo|web: printers that take ascii
13:12:34 <guidj0s> k0ral: Look up 'let in'.
13:12:49 <k0ral> let n = 5 in [0..n]
13:12:56 <k0ral> > let n = 5 in [0..n]
13:12:57 <lambdabot>   [0,1,2,3,4,5]
13:13:04 <DanBurton> In that case, ^L or whatever equivalent should probably work.
13:13:05 <k0ral> guidj0s: thank you :)
13:13:22 <Clint> you haven't said what kind of things you're feeding the file to
13:13:27 <DanBurton> hatex was on reddit today
13:13:35 <DanBurton> @google hatex reddit haskell
13:13:37 <lambdabot> http://www.haskell.org/pipermail/haskell-cafe/2011-October/096007.html
13:13:37 <lambdabot> Title: [Haskell-cafe] Haskell Weekly News: Issue 203
13:13:47 <DanBurton> old sauce :P
13:14:01 <mkscrg> specifically, am i supposed to use test-framework with cabal test-suite? or are they mutually exclusive?
13:14:13 <DanBurton> http://www.reddit.com/r/haskell/comments/p7suu/news_about_hatex/
13:14:22 <k0ral> > let n = 5; p = 1 in [p..n]
13:14:22 <lambdabot>   [1,2,3,4,5]
13:14:49 <DanBurton> Sgeo|web: I've never used it, but Hatex might suit your needs
13:15:04 <DanBurton> or it might be overkill
13:15:17 * Sgeo|web was looking at HPDF
13:16:26 <DanBurton> I'd almost certainly recommend going through latex rather than trying to create a PDF directly. Disclaimer: I have no experience doing this stuff.
13:17:34 <monochrom> latex or not depends on how much control you want. more control = not latex
13:17:50 <k0ral> > let n = 2; text="abcdefghijklmnopqrstuvwxyz" in foldl (\text p -> tail text) (cycle text) [0..n]
13:17:51 <lambdabot>   "defghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxy...
13:21:31 <DanBurton> latex does give you tons of control, though. I'm sure page breaks are doable. And most mortals probably don't need more control than latex provides.
13:21:45 <koeien> except for figure placement
13:22:08 <k0ral> > let n = 2; text="abcdefghijklmnopqrstuvwxyz" in map (\p -> tail (cycle text)) [0..n]
13:22:09 <lambdabot>   ["bcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuv...
13:23:36 <k0ral> > let n = 2; text="abcdefghijklmnopqrstuvwxyz" in map (\p -> foldl (\t _ -> tail t) (cycle text) [1..p]) [0..n]
13:23:37 <lambdabot>   ["abcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstu...
13:24:33 <guidj0s> k0ral: Why did you type the entire alphabet?
13:24:53 <k0ral> I need a random and long enough String
13:24:58 <k0ral> I want to build ngrams
13:25:11 <Enigmagic> > ['a'..'z']
13:25:12 <lambdabot>   "abcdefghijklmnopqrstuvwxyz"
13:25:19 <k0ral> oh !
13:25:35 <k0ral> > let n = 2; text=['a'..'z'] in map (\p -> tail text) (cycle text) [0..n]
13:25:36 <lambdabot>   Couldn't match expected type `[t1] -> t'
13:25:36 <lambdabot>         against inferred type `[[G...
13:26:00 <k0ral> > let n = 2; text=['a'..'z'] in map (\p -> foldl (\t _ -> tail t) (cycle text) [1..p]) [0..n]
13:26:01 <lambdabot>   ["abcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstu...
13:27:13 <niteria> whats the parser (in Parsec) for empty string? string "" or something different?
13:27:39 <cmccann> niteria, a parser that consumes no input and always succeeds?
13:27:44 <niteria> yes
13:27:45 <koeien> return ()
13:27:46 <cmccann> that would be "return"
13:27:51 <koeien> or return ""
13:28:30 <monochrom> not sure why you want to parse the empty string
13:28:48 <niteria> I'm parsing numerical constants from lisp
13:28:59 <niteria> they can have a prefix indicating base
13:29:03 <niteria> #b010101
13:29:27 <niteria> so I have pref <- string "#b" <|> ... <|> string ""
13:29:54 <koeien> fair enough.
13:30:01 <byorgey> yay GHC 7.4.1!!
13:30:14 <monochrom> I have base <- (string "#b" >> return 2) <|> return 10
13:30:24 <cmccann> byorgey, this calls for a celebration
13:30:52 <byorgey> \o\ /o/ \o\ \o/
13:30:56 <monochrom> the point of parsing is to turn strings into real data structures, not turn strings into more strings
13:31:06 <niteria> monochrom: that's better, saves me a case statement later
13:31:21 <k0ral> > let n = 2; text=['a'..'z'] in foldl (\a b -> zipWith (++) a b) "" $ map (\p -> foldl (\t _ -> tail t) (cycle text) [1..p]) [0..n]
13:31:22 <lambdabot>   No instance for (Data.Monoid.Monoid GHC.Types.Char)
13:31:22 <lambdabot>    arising from a use o...
13:31:24 * cmccann parses strings into strings, then concatenates them to simplify things
13:31:42 <hpc> monochrom: "finite subset of strings" is enough of a data structure for me :P
13:33:00 <k0ral> > let n = 2; text=['a'..'z'] in map (\p -> take 26 $ foldl (\t _ -> tail t) (cycle text) [1..p]) [0..n]
13:33:01 <lambdabot>   ["abcdefghijklmnopqrstuvwxyz","bcdefghijklmnopqrstuvwxyza","cdefghijklmnopq...
13:33:28 <k0ral> > let n = 2; text=['a'..'z'] in map (\p -> take 26 $ foldl (\t _ -> tail t) (cycle text) [1..p]) [0..n-1]
13:33:28 <lambdabot>   ["abcdefghijklmnopqrstuvwxyz","bcdefghijklmnopqrstuvwxyza"]
13:33:49 <SOLEIL> Hi, everybody!
13:33:51 <rata_> byorgey: I just got fmap (foldr f z) . sequence = fmap (foldr f z) . foldr (liftM2 (:)) (return []) = foldr (liftM2 f) (return z)... but I should probably put something between the second and last expressions
13:34:37 <monochrom> @quote information.hiding
13:34:37 <lambdabot> No quotes match. Listen, broccoli brains, I don't have time to listen to this trash.
13:34:45 <niteria> @hoogle readOct
13:34:46 <lambdabot> Numeric readOct :: Num a => ReadS a
13:34:46 <lambdabot> Text.Read.Lex readOctP :: Num a => ReadP a
13:35:10 <monochrom> @quote hiding.information
13:35:10 <lambdabot> AlanPerlis says: The string is a stark data structure and everywhere it is passed there is much duplication of process. It is a perfect vehicle for hiding information.
13:35:52 <monochrom> is what I want to say on parsing strings to... return those same strings
13:35:52 <cmccann> string munging everywhere works for unix, who needs progress
13:36:34 <hpc> cmccann: ive often wished perl had better syntactic support for real data structures
13:36:45 <rata_> byorgey: this is why I don't like proofs, because I'm not good at them
13:36:54 <byorgey> haha
13:36:57 <hpc> but just as often wished haskell had the ability to manipulate strings like perl could
13:37:16 <byorgey> rata_: at least you are honest with yourself about the reasons =)
13:37:40 <monochrom> humans are not good at unification
13:37:43 * hackagebot xsd 0.3.6 - XML Schema data structures  http://hackage.haskell.org/package/xsd-0.3.6 (ThomasDuBuisson)
13:37:56 <monochrom> then again, computers need exponential time for unification, too
13:38:00 <rata_> byorgey: but I need to get better
13:38:20 <rata_> I'm no mathematician (nor have a good math background), but I'm doing some maths now
13:38:44 <rata_> so practice is more than welcome and that's why I took the challenge =P
13:38:46 <monochrom> the proof you're doing has little to do with conventional mathematics
13:39:18 <k0ral> > let n = 2; text=['a'..'z'] in foldl (\a b -> zipWith (++) a b) (take 26 . repeat $ "") $ map (\p -> map (\x -> [x]) . take 26 . foldl (\t _ -> tail t) (cycle text) $ [1..p]) [0..n-1]
13:39:20 <lambdabot>   ["ab","bc","cd","de","ef","fg","gh","hi","ij","jk","kl","lm","mn","no","op"...
13:39:44 <k0ral> > let n = 4; text=['a'..'z'] in foldl (\a b -> zipWith (++) a b) (take 26 . repeat $ "") $ map (\p -> map (\x -> [x]) . take 26 . foldl (\t _ -> tail t) (cycle text) $ [1..p]) [0..n-1]
13:39:46 <lambdabot>   ["abcd","bcde","cdef","defg","efgh","fghi","ghij","hijk","ijkl","jklm","klm...
13:40:11 <k0ral> anyone got a better implementation ?
13:40:41 <koeien> k0ral: what are you looking for?
13:40:43 <k0ral> > let n = 4; text=['a'..'z'] in foldl (\a b -> zipWith (++) a b) (take (length cipher) . repeat $ "") $ map (\p -> map (\x -> [x]) . take (length cipher) . foldl (\t _ -> tail t) (cycle text) $ [1..p]) [0..n-1]
13:40:44 <lambdabot>   Not in scope: `cipher'Not in scope: `cipher'
13:40:59 <k0ral> > let n = 4; text=['a'..'z'] in foldl (\a b -> zipWith (++) a b) (take (length text) . repeat $ "") $ map (\p -> map (\x -> [x]) . take (length text) . foldl (\t _ -> tail t) (cycle text) $ [1..p]) [0..n-1]
13:41:01 <lambdabot>   ["abcd","bcde","cdef","defg","efgh","fghi","ghij","hijk","ijkl","jklm","klm...
13:41:09 <k0ral> koeien: building n-grams
13:41:17 <koeien> what's an "n-gram"?
13:41:45 <k0ral> well, for n = 2:
13:42:04 <rata_> byorgey: I can easily see after getting fmap (foldr f z) . foldr (liftM2 (:)) (return []) that the part after the (.) construct the list into the monad and then we go into the monad using fmap and apply the foldr f z, but how I can express that relationship more formally?
13:42:05 <k0ral> > let n = 2; text=['a'..'z'] in foldl (\a b -> zipWith (++) a b) (take (length text) . repeat $ "") $ map (\p -> map (\x -> [x]) . take (length text) . foldl (\t _ -> tail t) (cycle text) $ [1..p]) [0..n-1]
13:42:06 <lambdabot>   ["ab","bc","cd","de","ef","fg","gh","hi","ij","jk","kl","lm","mn","no","op"...
13:42:17 <k0ral> koeien: then for n = 3 that would be:
13:42:28 <k0ral> > let n = 3; text=['a'..'z'] in foldl (\a b -> zipWith (++) a b) (take (length text) . repeat $ "") $ map (\p -> map (\x -> [x]) . take (length text) . foldl (\t _ -> tail t) (cycle text) $ [1..p]) [0..n-1]
13:42:28 <koeien> i'm not sure i understand.
13:42:29 <lambdabot>   ["abc","bcd","cde","def","efg","fgh","ghi","hij","ijk","jkl","klm","lmn","m...
13:42:34 <koeien> all substrings of a certain length?
13:42:37 <k0ral> y
13:42:41 <byorgey> rata_: as I said, it probably requires induction.  First, apply both expressions to the empty list and see that they are equal.
13:42:47 <koeien> > tails [1,2,3]
13:42:47 <lambdabot>   [[1,2,3],[2,3],[3],[]]
13:42:56 <byorgey> rata_: then, apply both to (x:xs) with the assumption that they will be equal on xs
13:43:13 <koeien> > let f n = filter ((==n).length) . map (take n) . tails in f 3 [1..10]
13:43:15 <lambdabot>   [[1,2,3],[2,3,4],[3,4,5],[4,5,6],[5,6,7],[6,7,8],[7,8,9],[8,9,10]]
13:44:21 <k0ral> nice
13:44:22 <erus`> http://webdemo.visionobjects.com/equation.html?locale=default this is amazing
13:45:24 <k0ral> koeien: thank you, as short as I would ever have dreamt of
13:47:51 <rata_> byorgey: for checking the empty list may I use specific values for f and z (say, (+) and 0) or am I losing generality then?
13:48:25 <byorgey> rata_: no, that would be losing generality
13:48:37 <byorgey> I don't think that will make it any easier anyway
13:49:16 <cmccann> byorgey, hey, weird question out of nowhere, but do you have any familiarity with linear logic as applied to programming?
13:49:23 <k0ral> koeien: a slightly better one:
13:49:25 <k0ral> > let n = 3; text=['a'..'z'] in take (length text + 1 - n) . map (take n) . tails $ text
13:49:25 <niteria> @hoogle readBin
13:49:26 <lambdabot> No results found
13:49:27 <lambdabot>   ["abc","bcd","cde","def","efg","fgh","ghi","hij","ijk","jkl","klm","lmn","m...
13:49:57 <k0ral> koeien: this way you don't have to go through each ngram to check its length
13:50:50 <maurer> 3/win 12
13:51:00 <shachaf> k0ral: You should write a version that doesn't use length, or at the very least not length on the entire list.
13:51:18 <shachaf> maurer: Alt-w, etc.
13:51:43 <Enigmagic> shachaf: function keys work sometimes too
13:51:48 <Enigmagic> f1-f12 switch for me
13:51:57 <shachaf> That's so awkward to reach.
13:52:14 <rwbarton> k0ral: better to use the sneaky trick  dropFromEnd n xs = zipWith const xs (drop n xs)
13:52:17 <Enigmagic> depends on the keyboard i suppose
13:52:39 <shachaf> rwbarton: I always forget about that sneaky trick.
13:52:44 <shachaf> @where sneaky
13:52:44 <k0ral> shachaf: agreed, but that would make the implementation much longer
13:52:44 <lambdabot> I know nothing about sneaky.
13:52:53 <k0ral> shachaf: I'm giving it a try
13:53:04 <shachaf> @where+ sneaky dropFromEnd n xs = zipWith const xs (drop n xs)
13:53:05 <lambdabot> Okay.
13:53:08 <rata_> byorgey: well, I can easily check that fmap (foldr (+) 0) $ foldr (liftM2 (:)) (return []) ([] :: [Maybe Int]) = foldr (liftM2 (+)) (return z) ([] :: [Maybe Int]) = Just 0, but I can't check that \f z -> fmap ... = \f z -> ...
13:53:14 <shachaf> I guess dropFromEnd might be a better entry name.
13:53:49 <cmccann> shachaf, how about "pord"
13:53:53 <cmccann> to go with "snoc"
13:54:07 <Eduard_Munteanu> Heh.
13:54:17 <mauke> erus`: it thinks "\~" is "x"
13:54:42 <k0ral> rwbarton: that would still be O(n)
13:55:11 <shachaf> k0ral: It would start yielding elements immediately.
13:55:26 <shachaf> You can't hope for something that isn't linear in the size of the list, given that you have to construct a new list.
13:56:00 <rata_> byorgey: moreover, if I use induction, I could have done some from the beginning right, no need to get that fmap (...) . foldr (liftM2 (:)) (return []) intermediary right?
13:56:04 <k0ral> yes but I can halve the linear factor by not going through the entire list a second time just for dropping the last elements
13:59:08 <k0ral> tails is O(n^2), isn't it ?
13:59:38 <hpc> > tails "i don't think so"
13:59:39 <lambdabot>   ["i don't think so"," don't think so","don't think so","on't think so","n't...
14:00:02 <cmccann> why would tails be O(n^2)?
14:00:15 <k0ral> a new p-list is instanciated for each p in [1..n]
14:00:17 <cmccann> insofar as that even makes sense on a lazy list function
14:00:19 <hpc> k0ral: (tails foo) !! (n+1) = tail $ (tails foo) !! n
14:00:25 <danharaj> laziness makes O notation cry.
14:00:47 <hpc> k0ral: it doesn't make new lists
14:00:50 <cmccann> k0ral, no, those lists already exist
14:00:56 <hpc> k0ral: in fact, it doesn't make any list
14:01:07 <k0ral> Oo
14:01:07 <cmccann> hpc, I'd expect it to make one :P
14:01:15 <hpc> cmccann: well yes, except that one :P
14:01:18 <k0ral> how can I assess the time complexity then ?
14:01:56 <hpc> @src tails
14:01:56 <hpc> tails [] = []
14:01:56 <lambdabot> tails []         = [[]]
14:01:57 <lambdabot> tails xxs@(_:xs) = xxs : tails xs
14:02:05 <hpc> tails l = tail l : tails (tail l)
14:02:21 <hpc> it's one pass through the list
14:02:38 <cmccann> if you ignore the cost of reading through the resulting list to find the one you want, tails is basically O(0) :P
14:03:01 <hpc> more precisely, it's a (foldr f []), for an O(1) definition of f
14:03:08 <k0ral> cmccann: I know I will need almost every element of the result
14:03:11 <shachaf> k0ral: You should assess more than time complexity.
14:03:30 <statusfailed> How do I use a literal '@' in a haddock comment?
14:03:39 <mauke> have you tried \@?
14:03:41 <magicman> With laziness, time complexity depends also on what bits of the result you want. head (using_f_with_sneaky_trick) is O(1). head (using_f_with_length) is still O(n).
14:03:42 <cmccann> k0ral, using the result is O(n) in the furthest element used
14:03:45 <statusfailed> oh
14:03:46 <statusfailed> nevermind
14:03:51 <statusfailed> mauke: damnit, I just found the page :p
14:03:56 <statusfailed> mauke: thanks :P
14:04:35 <k0ral> magicman: well, assume the worst case in which I *use* every bit of the result
14:04:59 <niteria> @hoogle [a] -> [b] -> (a -> b)
14:05:00 <lambdabot> Text.Html HtmlNode :: Html -> [HtmlTree] -> Html -> HtmlTree
14:05:00 <lambdabot> Text.XHtml.Debug HtmlNode :: Html -> [HtmlTree] -> Html -> HtmlTree
14:05:00 <lambdabot> Graphics.Rendering.OpenGL.GL.VertexSpec TexCoord3 :: a -> a -> a -> TexCoord3 a
14:05:18 <cmccann> k0ral, in that case tails still adds essentially no extra cost beyond the cost of traversing any such list
14:05:23 <niteria> @hoogle mapsTo
14:05:23 <lambdabot> No results found
14:05:42 <magicman> With optimizations, I bet there's some nice fusing stuff going on, too.
14:06:18 <k0ral> too bad I have to go, but I'll be very interested in learning more about how to design efficient algorithms in Haskell
14:06:41 <k0ral> I'll ask you tomorrow
14:06:43 <k0ral> :p
14:07:11 <rata_> byorgey: ^ (sorry for being annoying, but I'd really like to understand all of this)
14:07:25 <niteria> I need a function that takes 2 lists and makes a function that maps values to results according to position in a list
14:07:39 <danr> @hoogle insert
14:07:39 <lambdabot> Data.HashTable insert :: HashTable key val -> key -> val -> IO ()
14:07:39 <lambdabot> Data.List insert :: Ord a => a -> [a] -> [a]
14:07:40 <lambdabot> Data.List insertBy :: (a -> a -> Ordering) -> a -> [a] -> [a]
14:07:43 <niteria> [a, b, c, d, e] -> [1, 2, 3, 4, 5]
14:07:49 <niteria> a would map to 1
14:07:50 <k0ral> niteria: what if list sizes don't match ?
14:07:59 <niteria> then I crash
14:08:19 <k0ral> you can write it yourself easily
14:08:27 <cmccann> niteria, zip the lists and put them in a Data.Map.Map
14:08:30 <niteria> they match because I hardcode them
14:08:30 <k0ral> using a fold
14:08:44 <k0ral> oh yeah using zip is iven nicer
14:08:48 <k0ral> even*
14:09:10 <niteria> it seems like a common thing to do
14:09:13 <k0ral> :t (fromList . zip)
14:09:14 <lambdabot>     Couldn't match expected type `[(a, Rational)]'
14:09:15 <lambdabot>            against inferred type `[b] -> [(a1, b)]'
14:09:15 <lambdabot>     Probable cause: `zip' is applied to too few arguments
14:09:36 <cmccann> :t fromList $ zip ['a'..'z'] [1..]
14:09:37 <lambdabot> forall (m :: * -> *). (MonadRandom m) => m Char
14:09:39 <k0ral> :t \a b -> fromList $ zip a b
14:09:40 <lambdabot> forall a (m :: * -> *). (MonadRandom m) => [a] -> [Rational] -> m a
14:09:46 <cmccann> pf, what
14:09:51 <cmccann> :t M.fromList $ zip ['a'..'z'] [1..]
14:09:52 <lambdabot> forall a. (Num a, Enum a) => M.Map Char a
14:09:57 <cmccann> there
14:10:11 <k0ral> :t \a b -> M.fromList $ zip a b
14:10:12 <lambdabot> forall k a. (Ord k) => [k] -> [a] -> M.Map k a
14:10:24 <cmccann> > lookup 'x' (M.fromList $ zip ['a'..'z'] [1..])
14:10:25 <lambdabot>   Couldn't match expected type `[(GHC.Types.Char, b)]'
14:10:25 <lambdabot>         against inferr...
14:10:35 <cmccann> > M.lookup 'x' (M.fromList $ zip ['a'..'z'] [1..])
14:10:36 <lambdabot>   Just 24
14:10:46 <k0ral> niteria: look at my last example
14:10:57 <cmccann> > (M.fromList $ zip ['a'..'z'] [1..]) M.! 'w'
14:10:58 <lambdabot>   23
14:11:19 <niteria> cool
14:18:31 <beat> Can someone explain me what the following means:
14:18:32 <beat> With normal functors, when you map a function over a functor, you can't get the result out in any general way, even if the result is a partially applied function. Applicative functors, on the other hand, allow you to operate on several functors with a single function.
14:18:53 <cmccann> beat, what don't you understand?
14:19:08 <beat> is it simply that we can chain <*>?
14:19:17 <cmccann> that's what it's talking about, yes
14:19:24 <beat> ok, got it :)
14:19:52 <beat> i wasn't sure thats what the phrase meant, thank you ;)
14:22:43 * hackagebot array 0.4.0.0 - Mutable and immutable arrays  http://hackage.haskell.org/package/array-0.4.0.0 (IanLynagh)
14:22:45 * hackagebot base 4.5.0.0 - Basic libraries  http://hackage.haskell.org/package/base-4.5.0.0 (IanLynagh)
14:22:47 * hackagebot binary 0.5.1.0 - Binary serialisation for Haskell values using lazy ByteStrings  http://hackage.haskell.org/package/binary-0.5.1.0 (IanLynagh)
14:22:49 * hackagebot Cabal 1.14.0 - A framework for packaging Haskell software  http://hackage.haskell.org/package/Cabal-1.14.0 (IanLynagh)
14:22:51 * hackagebot containers 0.4.2.1 - Assorted concrete container types  http://hackage.haskell.org/package/containers-0.4.2.1 (IanLynagh)
14:23:55 <niteria> @pl \x y -> x * 10 + y
14:23:55 <lambdabot> (+) . (10 *)
14:24:35 <Peaker> @pl \x y -> y * 10 + x
14:24:35 <lambdabot> (. (10 *)) . (+)
14:25:13 <niteria> that's not more readable, is it?
14:25:37 <Peaker> not really, direct points-free with binops is usually more confusing
14:26:00 <lpsmith> I think the first is more readable,  but yeah,  I don't see that example as a good one for points-free
14:26:17 <lpsmith> I'd probably use a lambda
14:26:43 <lpsmith> also,  you could   flip((+) . (10 *))
14:27:18 <cmccann> pointless style doesn't work well either either infix operators or when binary operations are combined with manipulation of arguments
14:27:53 * hackagebot deepseq 1.3.0.0 - Deep evaluation of data structures  http://hackage.haskell.org/package/deepseq-1.3.0.0 (IanLynagh)
14:27:55 * hackagebot extensible-exceptions 0.1.1.4 - Extensible exceptions  http://hackage.haskell.org/package/extensible-exceptions-0.1.1.4 (IanLynagh)
14:27:56 <cmccann> pointless style mostly helps when you have simple pipelines of composed functions and/or treat arguments consistently
14:27:57 * hackagebot filepath 1.3.0.0 - Library for manipulating FilePaths in a cross platform way.  http://hackage.haskell.org/package/filepath-1.3.0.0 (IanLynagh)
14:27:59 * hackagebot haskell98 2.0.0.1 - Compatibility with Haskell 98  http://hackage.haskell.org/package/haskell98-2.0.0.1 (IanLynagh)
14:28:01 * hackagebot haskell2010 1.1.0.1 - Compatibility with Haskell 2010  http://hackage.haskell.org/package/haskell2010-1.1.0.1 (IanLynagh)
14:28:19 <tibbe> Do the monad laws imply that return must be lazy in its argument?
14:28:48 <DanBurton> @where monad laws
14:28:49 <lambdabot> I know nothing about monad.
14:28:53 <DanBurton> -___-
14:29:01 <DanBurton> @wiki monad
14:29:01 <lambdabot> http://www.haskell.org/haskellwiki/monad
14:29:08 * cmccann suggests lambdabot read some monad tutorials
14:29:41 <hpc> @@ google google google
14:29:42 <lambdabot>  google google google
14:29:47 <hpc> @. google google google
14:29:51 <lambdabot> http://support.google.com/webmasters/bin/answer.py?hl=en&answer=35624
14:29:52 <lambdabot> Title: Site title and description - Webmaster Tools Help
14:30:04 <hpc> hehe
14:31:14 <tibbe> DanBurton: I'm trying to be lazy and not have to think about the implications of those laws myself.
14:32:00 <hpc> tibbe: lazy how?
14:32:33 <DanBurton> tibbe: the law "return a >>= k = k a" does seem to imply that return must be lazy in its argument
14:32:36 <hpc> tibbe: the monad laws don't specify anything about strictness, and most equational reasoning craps out in the presence of seq
14:32:57 <cmccann> > return undefined >> "abc"
14:32:58 <lambdabot>   "abc"
14:33:03 * hackagebot hoopl 3.8.7.3 - A library to support dataflow analysis and optimization  http://hackage.haskell.org/package/hoopl-3.8.7.3 (IanLynagh)
14:33:05 * hackagebot hpc 0.5.1.1 - Code Coverage Library for Haskell  http://hackage.haskell.org/package/hpc-0.5.1.1 (IanLynagh)
14:33:05 <cmccann> > (return $! undefined) >> "abc"
14:33:06 <lambdabot>   "*Exception: Prelude.undefined
14:33:06 <DanBurton> tibbe: also, the type signature "a -> m a" basically says you cannot inspect the input in any meaningful way
14:33:07 * hackagebot old-locale 1.0.0.4 - locale library  http://hackage.haskell.org/package/old-locale-1.0.0.4 (IanLynagh)
14:33:09 * hackagebot old-time 1.1.0.0 - Time library  http://hackage.haskell.org/package/old-time-1.1.0.0 (IanLynagh)
14:33:11 * hackagebot process 1.1.0.1 - Process libraries  http://hackage.haskell.org/package/process-1.1.0.1 (IanLynagh)
14:33:23 <kallisti> DanBurton: nah, it implies that >>= could possibly be lazy with its left argument when its left argument is return something
14:33:34 <tibbe> hpc: put in another way, can a "monad" that defines return _|_ = _|_ fulfill the monad laws
14:34:05 <tibbe> hpc: that's was what I suspected
14:34:11 <hpc> tibbe: it... might, depending on what definition bind has
14:34:19 <kallisti> tibbe: is that even possible?
14:34:25 <hpc> as DanBurton said, that particular law is king here
14:34:28 <kallisti> the only way I can think that it would be possible is...
14:34:31 <tibbe> kallisti: to have a strict return?
14:34:32 <kallisti> return = const undefined
14:34:43 <tibbe> kallisti: with `seq` it is
14:34:50 <kallisti> ah, yes, I suppose.
14:35:04 <cmccann> > (return $! undefined) >>= const ()
14:35:04 <lambdabot>   Couldn't match expected type `m b' against inferred type `()'
14:35:14 <cmccann> > ((return $! undefined) >>= const ()) :: Maybe ()
14:35:15 <lambdabot>   Couldn't match expected type `Data.Maybe.Maybe ()'
14:35:15 <lambdabot>         against inferred...
14:35:20 <cmccann> argh
14:35:26 <cmccann> > ((return $! undefined) >>= const (Just ())) :: Maybe ()
14:35:27 <lambdabot>   *Exception: Prelude.undefined
14:35:38 <cmccann> > ((return undefined) >>= const (Just ())) :: Maybe ()
14:35:40 <lambdabot>   Just ()
14:35:43 <hpc> in any event, if you have a "return" strict enough to crap out when it gets bottom, you need a (>>=) lazy enough to not crap out when it gets bottom to the left
14:35:54 <cmccann> tibbe, pretty sure the monad laws require the above to be "Just ()"
14:35:56 <hpc> dunno if that's possible to pull off
14:36:12 <tibbe> cmccann: hmm
14:36:16 <cmccann> hpc, not for any nontrivial monad
14:36:29 <DanBurton> > Just undefined >>= const (Just ())
14:36:30 <lambdabot>   Just ()
14:36:31 <hpc> cmccann: i think i could do it for Maybe, even
14:36:37 <monochrom> I would like "return ⊥ >>= f" to be the same as "f ⊥". if you allow return ⊥ = ⊥, that may break me, depending on what >>= does of course
14:36:46 <hpc> er, no i can't
14:36:48 <tibbe> I'm trying to make a statement on the form "I you're monad has a lazy return then…."  <- only make sense if there are monads that have strict returns
14:36:49 <cmccann> hpc, (>>=) needs to distinguish Nothing from (Just _)
14:36:51 <hpc> yeah
14:37:00 <cmccann> which it can't do if you give it _|_
14:37:20 <Ptival> Prelude> :t a
14:37:20 <Ptival> a :: (((t1 -> t1) -> t1 -> t1) -> ((t2 -> t2) -> t2 -> t2) -> t) -> t
14:37:20 <Ptival> Prelude> :t a id
14:37:20 <Ptival> a id :: (t2 -> t2) -> t2 -> t2
14:37:24 <Ptival> I was expecting ((t1 -> t1) -> t1 -> t1) -> ((t2 -> t2) -> t2 -> t2), why am I wrong?
14:37:29 <monochrom> however, recently one person on haskell-cafe insist that ⊥ should be exempted from monad laws
14:37:58 <hpc> monochrom: heh, im sure that went over well
14:37:58 <cmccann> monochrom, some people like to just pretend that ⊥ doesn't exist at all
14:38:13 * hackagebot template-haskell 2.7.0.0 -   http://hackage.haskell.org/package/template-haskell-2.7.0.0 (IanLynagh)
14:38:16 <DanBurton> Ptival: where did "a" come from? o_O
14:38:24 <hpc> some of us take great pains to make sure unanticipated bottoms don't come up at all
14:38:36 <hpc> making said pretending safe
14:38:41 <hpc> ;)
14:38:44 <Ptival> DanBurton: a crazy lambda term found in a SO question
14:38:59 <cmccann> hpc, good, that's the correct approach ;]
14:39:04 <dylukes> http://cl.ly/Dsqx
14:39:06 <dylukes> This looks fun.
14:39:16 <Ptival> I don't really care about a, just want to get my mental typing algorithm fixed
14:39:30 <DanBurton> :t id `asAppliedTo` (\i -> a i)
14:39:31 <lambdabot>     Couldn't match expected type `t1 -> t' against inferred type `Expr'
14:39:31 <lambdabot>     In the expression: a i
14:39:31 <lambdabot>     In the second argument of `asAppliedTo', namely `(\ i -> a i)'
14:39:42 <DanBurton> :t asAppliedTo
14:39:43 <lambdabot> forall t b. (t -> b) -> t -> t -> b
14:40:18 <DanBurton> what's the reverse of asAppliedTo?
14:40:34 <DanBurton> if you want to know the shape of something when you apply a certain function to it
14:40:35 <monochrom> non-strictness is how you reduce unanticipated bottoms. for example, in "return ⊥ = ⊥", the right hand side is an unanticipated bottom. when it happens and I do "return ⊥ >>= f", now your >>= faces an unanticipated ⊥, you can't pretend your >>= never sees ⊥.
14:41:33 <DanBurton> :t asApplyingTo
14:41:34 <lambdabot> Not in scope: `asApplyingTo'
14:41:49 <monochrom> so, people who want to worry less about ⊥ should support more non-strictness. it is ironic.
14:41:50 <DanBurton> @let asApplyingTo :: a -> (a -> b) -> a; asApplyingTo = undefined
14:41:51 <lambdabot>  Defined.
14:41:58 <DanBurton> :t id `asApplyingTo` a
14:41:59 <lambdabot>     Couldn't match expected type `(a -> a) -> b'
14:41:59 <lambdabot>            against inferred type `Expr'
14:41:59 <lambdabot>     In the second argument of `asApplyingTo', namely `a'
14:42:03 <DanBurton> wat
14:42:16 <DanBurton> where did this magical "a" go
14:42:29 <Ptival> DanBurton: erm, I did not type it into lambdabot :D
14:42:36 <cmccann> DanBurton, in Ptival's ghci, where it always was
14:42:39 <koeien> oh that's Caleskell
14:42:39 <cmccann> :P
14:42:44 <hpc> :t id `asApplyingTo` ?a
14:42:45 <lambdabot> forall a b. (?a::(a -> a) -> b) => a -> a
14:42:49 <DanBurton> ohhh
14:43:06 <hpc> :t id `asApplyingTo` (?a :: ((a -> a) -> a -> a) -> b)
14:43:07 <lambdabot>     Could not deduce (?a::((a -> a) -> a -> a) -> b)
14:43:07 <lambdabot>       from the context ()
14:43:08 <lambdabot>       arising from a use of implicit parameter `?a'
14:44:13 <DanBurton> :t id `asApplyingTo` (?a :: (((t1 -> t1) -> t1 -> t1) -> ((t2 -> t2) -> t2 -> t2) -> t) -> t)
14:44:14 <Ptival> :t id `asApplyingTo` (?a :: (((t1 -> t1) -> t1 -> t1) -> ((t2 -> t2) -> t2 -> t2) -> t) -> t)
14:44:14 <lambdabot>     Could not deduce (?a::(((t1 -> t1) -> t1 -> t1)
14:44:14 <lambdabot>                            -> ((t2 -> t2) -> t2 -> t2)
14:44:14 <lambdabot>                            -> t)
14:44:15 <lambdabot>     Could not deduce (?a::(((t1 -> t1) -> t1 -> t1)
14:44:15 <lambdabot>                            -> ((t2 -> t2) -> t2 -> t2)
14:44:16 <lambdabot>                            -> t)
14:44:27 <DanBurton> :t id `asApplyingTo` (undefined :: (((t1 -> t1) -> t1 -> t1) -> ((t2 -> t2) -> t2 -> t2) -> t) -> t)
14:44:27 <lambdabot> forall t2. (((t2 -> t2) -> t2 -> t2) -> (t2 -> t2) -> t2 -> t2) -> ((t2 -> t2) -> t2 -> t2) -> (t2 -> t2) -> t2 -> t2
14:44:33 <DanBurton> o_O
14:45:17 <Ptival> do you want me to feed "a" to miss lambdabot?
14:45:22 <DanBurton> :t (undefined :: ((((t1 -> t1) -> t1 -> t1) -> ((t2 -> t2) -> t2 -> t2) -> t) -> t)) id
14:45:23 <lambdabot> forall t2. (t2 -> t2) -> t2 -> t2
14:45:38 <Ptival> oh that's it
14:45:50 <DanBurton> that's the type signature you expected?
14:46:44 <DanBurton> Anyways, see the one above where I did (id `asApplyingTo` undefined ...)? That is the type that "id" takes on in order to be applied to "a"
14:46:44 <Ptival> no
14:47:10 <Ptival> I was expecting ((t1 -> t1) -> t1 -> t1) -> ((t2 -> t2) -> t2 -> t2)
14:47:43 <Ptival> (which must be wrong)
14:47:58 <hpc> :t asApplyingTo
14:47:59 <lambdabot> forall a b. a -> (a -> b) -> a
14:48:01 <hpc> :t asAppliedTo
14:48:02 <lambdabot> forall t b. (t -> b) -> t -> t -> b
14:48:17 <hpc> :t a `asApplyingTo` id
14:48:17 <lambdabot> Expr
14:48:32 <hpc> :t a `asApplyingTo` (id :: (a -> a) -> a -> a))
14:48:33 <lambdabot> parse error on input `)'
14:48:36 <hpc> :t a `asApplyingTo` (id :: (a -> a) -> a -> a)
14:48:36 <lambdabot>     Couldn't match expected type `Expr' against inferred type `a -> a'
14:48:37 <lambdabot>     In the second argument of `asApplyingTo', namely
14:48:37 <lambdabot>         `(id :: (a -> a) -> a -> a)'
14:48:42 <magicman> :t asTypeIn
14:48:43 <lambdabot> forall a b. a -> (a -> b) -> a
14:49:58 <kallisti> magicman: oh cool
14:50:09 * kallisti didn't know about that.
14:50:35 <DanBurton> magicman: ah that's it. Thanks.
14:50:37 <niteria> http://hpaste.org/57347
14:51:01 <DanBurton> @undefine
14:51:15 <niteria> why doesn't it work? It parses #b10101, 423424 but fails to parse #xff
14:53:33 <magicman> Once Parsec consumes input, it can't backtrack to try another alternative of <|>
14:53:52 <niteria> ok
14:53:54 <niteria> oh
14:54:05 <magicman> So when it tries to parse #xff, it tries "#b" first, consumes the '#', then fails, but doesn't backtrack.
14:54:53 <niteria> so a way to fix that would be first consume #?
14:54:59 <mauke> yes
14:57:26 <mauke> I don't like the existence of base
14:58:16 * cmccann suggests an acid to neutralize
14:58:44 <mauke> > foldr f z (reverse [a,b,c])
14:58:45 <lambdabot>   can't find file: L.hs
14:58:48 <mauke> > foldr f z (reverse [a,b,c])
14:58:49 <lambdabot>   f c (f b (f a z))
14:59:02 <mauke> > foldl f z [a,b,c]
14:59:03 <lambdabot>   f (f (f z a) b) c
14:59:26 <mauke> > foldl (flip f) z [a,b,c]
14:59:28 <lambdabot>   f c (f b (f a z))
15:00:04 <mauke> @hoogle Char -> Int
15:00:04 <lambdabot> Data.Char digitToInt :: Char -> Int
15:00:05 <lambdabot> Data.Char ord :: Char -> Int
15:00:05 <lambdabot> Graphics.UI.GLUT.Callbacks.Window Char :: Char -> Key
15:00:12 <monochrom> id::X->X where X is an unknown to be solved for. apply f::(((t1 -> t1) -> t1 -> t1) -> ((t2 -> t2) -> t2 -> t2) -> t) -> t to id::X->X, we force X->X = ((t1 -> t1) -> t1 -> t1) -> ((t2 -> t2) -> t2 -> t2) -> t
15:00:14 <mauke> > digitToInt 'f'
15:00:15 <lambdabot>   15
15:00:38 <monochrom> parsing that type very carefully, it says X = (t1 -> t1) -> t1 -> t1 and X = ((t2 -> t2) -> t2 -> t2) -> t
15:00:43 <niteria> yay
15:01:06 <niteria> > digitToInt 'F'
15:01:07 <lambdabot>   15
15:01:38 <mauke> @hoogle readInt
15:01:39 <lambdabot> Numeric readInt :: Num a => a -> (Char -> Bool) -> (Char -> Int) -> ReadS a
15:01:39 <lambdabot> Text.Read.Lex readIntP :: Num a => a -> (Char -> Bool) -> (Char -> Int) -> ReadP a
15:01:39 <lambdabot> Data.ByteString.Char8 readInt :: ByteString -> Maybe (Int, ByteString)
15:01:43 <monochrom> jumping a few steps, t1 = t2 -> t2, t = t1->t1
15:01:59 <DanBurton> > foldl (flip f) z (reverse [a,b,c])
15:01:59 <monochrom> t = t1->t1 = (t2->t2)->(t2->t2)
15:02:00 <lambdabot>   f a (f b (f c z))
15:02:13 <DanBurton> > foldr f z [a,b,c]
15:02:14 <lambdabot>   f a (f b (f c z))
15:02:14 <monochrom> the final answer wants t, which is (t2->t2)->(t2->t2)
15:02:35 <niteria> mauke: I made parseNumber for educational purposes
15:02:55 <mauke> niteria: then definitely foldl' instead of foldr + reverse
15:03:24 <monochrom> the key is parsing the type very carefully, i.e., you're looking at X->X = Blob1 -> Blob2 -> t, not (Blob1 -> Blob2)->t
15:03:33 <niteria> @hoogle foldl'
15:03:34 <lambdabot> Data.List foldl' :: (a -> b -> a) -> a -> [b] -> a
15:03:34 <lambdabot> Data.Foldable foldl' :: Foldable t => (a -> b -> a) -> a -> t b -> a
15:03:34 <lambdabot> Data.ByteString.Char8 foldl' :: (a -> Char -> a) -> a -> ByteString -> a
15:04:01 <monochrom> so X=Blob1 and X=Blob2->t, rather than X=Blob1->Blob2 and X=t
15:05:53 <niteria> mauke: and I didn't like the type of readInt, it's 2 levels of parsers
15:06:04 <niteria> feels wrong
15:06:28 <monochrom> what is the type of readInt?
15:06:41 <mauke> Num a => a -> (Char -> Bool) -> (Char -> Int) -> ReadS a
15:07:07 <monochrom> that is not 2 levels of parsers
15:07:16 <mauke> it's one level
15:08:36 <niteria> ReadS a = String -> [(a, String)], looks like a parser
15:08:54 <monochrom> yes, that's the 1 level of parser. the end.
15:09:01 <mauke> monochrom: not the end
15:09:12 <monochrom> the foundation?
15:09:13 <mauke> why do you think it's the end?
15:09:22 <mauke> monochrom: try the other direction
15:09:38 <monochrom> because there is no other parser level.
15:09:46 <mauke> yes, there is
15:10:11 <monochrom> wait, you also agreed it's one level
15:10:25 <mauke> yes
15:10:55 <monochrom> alright, so there is some other stuff, but they don't add another parser level
15:10:57 <Jafet> monochrom fails to accept mauke's language.
15:11:08 <mauke> monochrom: why do you think they don't add another parser level?
15:11:27 <monochrom> Char->Bool and Char-Int are not parsers
15:11:32 <mauke> and?
15:11:43 <monochrom> -> are not parsers
15:11:46 <mauke> and?
15:12:08 <monochrom> a are not parsers
15:12:15 <mauke> call me when you're done
15:12:40 <monochrom> done. I've covered the whole type a -> (Char -> Bool) -> (Char -> Int) -> ReadS a
15:12:42 <niteria> I don't get this conversation
15:12:50 <mauke> monochrom: correct
15:13:00 <mauke> monochrom: how was this relevant?
15:13:02 <niteria> oh now I get what's monochrom's point
15:13:22 <cmccann> niteria, mauke is antagonizing monochrom by being obfuscatingly literal :P
15:13:24 <monochrom> I'm refuting "it's 2 levels of parsers"
15:13:31 <mauke> monochrom: no, you're not
15:13:35 <mauke> monochrom: you're misunderstanding "it"
15:13:50 <monochrom> "it" is intended to be misunderstood anyway
15:13:57 <mauke> I disagree
15:14:08 <niteria> I'm on mauke's side
15:14:21 <monochrom> ok, what is "it"?
15:14:30 <mauke> monochrom: niteria's code
15:14:32 <niteria> that it doesn't refer to readInt's type
15:15:00 <cmccann> niteria, you're using readInt inside a parsec parser or something, right?
15:15:07 <niteria> yes
15:15:18 <niteria> I considered that
15:16:00 <niteria> but it makes me do all the work anyway, so I just folded over the digits
15:19:00 <mauke> *> tparse pLN "X"
15:19:01 <mauke> Line 1, column 1, offset 0
15:19:01 <mauke> Unexpected 'X'
15:19:01 <mauke> Expecting "#b", "#d", "#o", "#x", or one of "0123456789"
15:19:03 <mauke> much better
15:19:18 <mauke> niteria++  # found a stupid bug in my parser lib
15:20:19 <niteria> I think I'm behind the schedule with this Scheme in 48h
15:20:54 <eyu100> > 1
15:20:55 <lambdabot>   1
15:21:05 <mauke> > [1, 1 ..]
15:21:06 <lambdabot>   [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,...
15:21:52 <niteria> ['a'..]
15:21:55 <niteria> > ['a'..]
15:21:56 <lambdabot>   "abcdefghijklmnopqrstuvwxyz{|}~\DEL\128\129\130\131\132\133\134\135\136\137...
15:22:54 <niteria> > putStrLn "/msg niteria test"
15:22:55 <lambdabot>   <IO ()>
15:23:04 <niteria> > "/msg niteria test"
15:23:05 <lambdabot>   "/msg niteria test"
15:23:17 <mauke> niteria: "/msg" is not an IRC command
15:23:52 <niteria> oh, it works in irssi
15:24:09 <mauke> my parser: http://hpaste.org/57349
15:24:18 <mauke> niteria: and many other irc clients
15:24:24 <mauke> but it's not part of the protocol
15:25:01 <mauke> at the protocol level you have "PRIVMSG #somechannel :your message" or "PRIVMSG somenick :your message"
15:26:58 <mm_freak> minor nitpicking:  "PRIVMSG #channel message" also works, as long as the message contains no spaces
15:27:15 <mm_freak> a standards-compliant server might choose to send messages without the colon where applicable
15:27:32 <mauke> yeah, and then there's the "\13\10" message terminator
15:27:37 <mauke> and the 512 byte limit
15:27:57 <niteria> > unsafePerformIO $ putStrLn "PRIVMSG #haskell :test"
15:27:58 <lambdabot>   Not in scope: `unsafePerformIO'
15:28:02 <niteria> oh
15:28:14 <Jafet> Not that that would work anyway.
15:28:25 <Jafet> Try opening a socket first.
15:28:32 <mauke> yeah, stdout probably isn't the socket
15:29:01 <Jafet> Fortunately, this is a fun, family-friendly pastime http://www.amazon.com/Keos-Thai-Cuisine-Keo-Sananikone/dp/1580080820
15:29:03 <niteria> ok, that was silly
15:29:17 * Jafet kicks the copy buffer
15:29:19 <Jafet> http://www.haskell.org/haskellwiki/Roll_your_own_IRC_bot
15:29:49 <mm_freak> Jafet: hi there…  would you mind P/M-ing you?  (or just rejoin the crypto-channel)
15:32:45 * hackagebot bytestring 0.9.2.1 - Fast, packed, strict and lazy byte arrays with a list interface  http://hackage.haskell.org/package/bytestring-0.9.2.1 (IanLynagh)
15:32:47 * hackagebot directory 1.1.0.2 - library for directory handling  http://hackage.haskell.org/package/directory-1.1.0.2 (IanLynagh)
15:32:49 * hackagebot unix 2.5.1.0 - POSIX functionality  http://hackage.haskell.org/package/unix-2.5.1.0 (IanLynagh)
15:32:51 * hackagebot Win32 2.2.2.0 - A binding to part of the Win32 library  http://hackage.haskell.org/package/Win32-2.2.2.0 (IanLynagh)
15:33:19 <ddarius> Jafet: That book may be handy.
15:34:30 <JoeyA> Has anyone here written programs for Windows that do network I/O ?  My question is: is it generally better to compile with -threaded or without, when reliability is the main concern?
15:34:56 <JoeyA> On Windows with -threaded, network operations are done through FFI calls, which cannot be interrupted with asynchronous exceptions.
15:35:26 <JoeyA> However, without -threaded, it does use async I/O, but I imagine there's a risk that some FFI call will come along and hang the whole program.
15:36:44 <mm_freak> JoeyA: for networking programs -threaded is usually preferable, because it changes the semantics of some IO actions
15:37:01 <mm_freak> it generally makes the program more preemptive
15:37:06 <JoeyA> mm_freak: I would agree in general, but what about Windows in particular?
15:37:51 <mm_freak> in an ideal world the OS shouldn't make a difference, but if anything i'd expect it to be better
15:38:01 <mm_freak> in any case, read the documentation of the actions you use
15:38:20 <JoeyA> The documentation doesn't warn about Windows.  I've had to learn stuff through testing :(
15:38:56 <JoeyA> Except it does say that interruptible FFI calls are only interruptible in Vista and up.
15:39:02 <niteria> ooook, parsers aren't really composable without backtracking
15:39:19 <mauke> just add 'try' everywhere
15:39:26 <BlastHardcheese> the consequences will never be the same
15:39:26 <Enigmagic> or use attoparsec?
15:39:43 <JoeyA> Attoparsec, as of version 0.10, does not require explicit try calls.
15:39:53 <niteria> I'm following Scheme in 48h tutorial and it uses parsec
15:39:57 <JoeyA> (it used to, but didn't guarantee to honor them)
15:40:07 <JoeyA> Parsec, on the other hand, certainly does.
15:40:32 <mm_freak> JoeyA: it didn't?
15:40:55 <JoeyA> See the documentation for 'try' in Attoparsec 0.9.x
15:40:56 <niteria> everywhere as in (try a) <|> (try b) or try (a <|> b) ?
15:41:17 <mm_freak> niteria: try a <|> b
15:41:25 <mm_freak> i.e. (try a) <|> b
15:41:32 <JoeyA> I was horrified when I learned about that property of Parsec, at least initially.
15:42:07 <JoeyA> However, I've come to realize that Parsec is not as declarative as you might expect.  It's easier to think about it as a hand-written recursive descent parser, with a lot of conveniences.
15:42:09 <mm_freak> niteria: basically for choice you'll want this:  try (try (try a <|> b) <|> c) <|> d
15:42:29 <mm_freak> niteria: but this is semantically equivalent to:  try a <|> try b <|> try c <|> d
15:42:41 <eyu100> @type try
15:42:42 <lambdabot> Not in scope: `try'
15:42:58 <mm_freak> (<|>) tries the left parser, and if it fails without consuming input, it tries the right parser
15:42:59 <JoeyA> And yes, I do like how it stops trying alternatives after consuming input (try rewinds a parser so it acts like it consumed no input on failure).
15:43:27 <ddarius> Parsers aren't really composable without GLR parsers.
15:43:56 <ddarius> JoeyA: Parsec parsers -are- hand-written recursive descent parsers.
15:44:26 <niteria> that's sad, I expected more
15:44:35 <mauke> what is GLR?
15:44:39 * Enigmagic wants a C-- backend for Ragel
15:44:42 <JoeyA> When I say hand-written recursive descent parser, I'm thinking along the lines of bool parse(ParseCtx *ctx, const char *s, const char *e, Foo *out)
15:44:57 <mauke> why so C-rious?
15:45:30 <Enigmagic> i think it would be easier for it to target cmm than haskell
15:45:34 <JoeyA> Better than BASIC :-)
15:45:43 <Enigmagic> though there is o'caml target for it now
15:45:56 <JoeyA> It's a pain to parse stuff when you have to think in terms of substring starts and ends.
15:46:06 <JoeyA> Of course, Attoparsec has to worry about that sort of thing.
15:46:17 <JoeyA> It's worse when you're doing one-based indexing.
15:46:40 <JoeyA> Is it substr(s, n, len - n - 1) or is it substr(s, n - 1, len - n + 1) or what?
15:46:43 <mauke> JoeyA: http://mauke.hopto.org/stuff/ploki/ploki-0.6.5.1/examples/calc.pk :-)
15:47:00 <niteria> I expected Parsec to be more declarative
15:47:15 <JoeyA> "<niteria> that's sad, I expected more" It's not too bad.  The killer feature of Parsec (and other parser combinator libraries) is that you can describe the grammar and build data structures in the same language.
15:47:40 <JoeyA> Unlike Bison, where you write the grammar, then add awkward constructor code on top.
15:48:16 <JoeyA> mauke: What language is that?
15:48:27 <JoeyA> lolcode?  Why .pk ?
15:48:34 <mauke> JoeyA: ploki
15:48:44 <ddarius> From a pure parsing perspective, the "killer feature" of parser combinator libraries is that you can abstract common patterns of parsers.  Parsec's expression parser being a good example.
15:49:05 <russellw> Yeah, the thing about declarative special-purpose languages like Bison is you always end up needing to do something that doesn't quite fit it, and then you have a big problem
15:49:07 <mauke> ddarius: I'd say that follows from parsers being first class
15:49:36 <russellw> I've come to the belief that the only domain specific languages that are worth using are the ones embedded in general purpose languages
15:50:03 <ddarius> russellw: That flies in the face of reality.
15:50:17 <JoeyA> And don't forget that C isn't really the context-free language it says it is.  C parsers have to keep track of typedefs so the parser can tell if the next identifier is a type or not.  I could be wrong.
15:50:33 <mauke> you're not wrong
15:50:42 <mauke> (and C++ makes this undecidable)
15:51:17 <russellw> ddarius, it's a belief I've acquired from hard experience - what makes you think otherwise?
15:51:36 <JoeyA> http://codegolf.stackexchange.com/questions/1956/generate-the-longest-error-message-in-c/1957#1957
15:51:37 <mauke> russellw: regex
15:52:25 <russellw> mauke, but nobody tries to write a lexical analyzer using nothing but regular expressions. Instead, we use regular expressions within a general-purpose language
15:53:05 <Phlogistique> By the way - any advice wrt Haskell PEG libs? Should one use Frisby, Trifecta, or yet another?
15:53:21 <mauke> the regexes are still a separate language and not intertwined with the host environment
15:53:36 <mauke> and regexes are used for other things than lexical analyzers
15:53:52 <cmccann> parsing html. for instance
15:54:04 <cmccann> I hear that's a popular use of regex
15:54:07 <mauke> :-(
15:54:33 <russellw> cmccann, I think we don't need to link a certain stack overflow answer :)
15:54:36 <mauke> cmccann: http://mauke.hopto.org/stuff/perl/rfc2822
15:55:02 <cmccann> mauke, haha, nice
15:56:35 <ddarius> russellw: I don't think there are any widely used embedded DSLs whereas there are several examples of widely used non-embedded DSLs.
15:56:48 <cmccann> then again, I enjoy misusing things, like drawing fractals with a Makefile :P
15:57:07 <mauke> cmccann: http://mauke.hopto.org/stuff/haskell/quine.hs
15:57:18 <Phlogistique> My goal is to write a lenient parser for a poorly defined language; is a library of PEG combinators the right tool for that? If it isn't, then what is the right tool?
15:57:23 <cmccann> mauke, hahahaha
15:58:40 <russellw> ddarius, in practice what we have ended up with is a bunch of domain specific languages like SQL, HTML, XML and makefiles, that were not designed as embedded, but have to be used as such anyway because they can't do the job otherwise, at staggering cost in the effort of maintaining the resulting pile of duct tape
16:00:05 <Eduard_Munteanu> Granted we don't really have really flexible host languages either, I'd guess.
16:00:17 <cmccann> russellw, maybe half of those have continually evolved in the direction of being (poorly-designed) general purpose languages anyhow
16:01:03 <russellw> cmccann, exactly, that's one of the huge problems
16:01:08 <cmccann> there's probably a good argument to be made that non-embedded DSLs don't stay that way over time
16:01:19 <cmccann> after enough use, they'll stop being DSLs or they'll become embedded
16:01:21 <cmccann> or both
16:01:28 <Eduard_Munteanu> EDSLs would be awkward if you couldn't get some appropriate syntax.
16:01:49 <russellw> but Eduard_Munteanu is right of course, that one of the reasons we have ended up with that situation is that languages like C are not very flexible, so it's hard to embed a DSL in one
16:01:53 <cmccann> the proliferation of HTML templating systems is kind of an effort to reverse-embed HTML to deal with it better
16:02:09 <Phlogistique> and LINQ would be an example of widely used DSL
16:02:12 <russellw> I'm given to understand that one reason Ruby on rails is so successful is that Ruby is very flexible so it was possible to embed rails in it as an embedded domain specific language
16:02:14 <owst_> I'm seeing a difference in behaviour between `cabal test` and `runghc Setup.hs test` (particularly, I override testHook in Setup.hs, and it's not overridden in the `cabal test` instance). I'm not entirely clear where Setup.hs gets pulled in by cabal, what am I doing wrong?
16:02:19 <russellw> and linq too, yes
16:02:34 <russellw> And of course apparently parsec is another example, which is how this conversation started :-)
16:02:35 <cmccann> and all the extra crap that any DB offers beyond plain SQL turns that into a pretty general language
16:02:45 * hackagebot couchdb-conduit 0.5.0 - Couch DB client library using http-conduit and aeson  http://hackage.haskell.org/package/couchdb-conduit-0.5.0 (AlexanderDorofeev)
16:02:52 <mauke> owst_: what's your Build-Type?
16:03:08 <ByronJohnson> owst_: Build-type should be custom
16:03:18 <cmccann> russellw, haskell lends itself to embedding DSLs, so that's probably not a good comparison to anything else
16:03:38 <dcoutts> owst_: does your .cabal file say build-type: Custom ?
16:03:41 <cmccann> ditto for other languages with pervasive metaprogramming support
16:03:59 <russellw> cmccann, yes, so I think we can reasonably conclude that that's a huge advantage of flexible languages like Haskell and Ruby
16:04:03 <dcoutts> oh, I see mauke and ByronJohnson said that already :-)
16:04:25 <owst_> Ah, right, it's Simple at the moment. Thanks mauke, ByronJohnson and dcoutts
16:04:26 <mauke> dcoutts: yes, but I didn't know the "custom" bit!
16:04:35 <mauke> I just know "simple" ignores Setup
16:04:37 <cmccann> russellw, most lisp dialects as well
16:04:44 <ddarius> Phlogistique: I was actually considering listing that as a counter-example.
16:04:45 <russellw> Indeed
16:05:31 <Eduard_Munteanu> How's Lisp at that?
16:06:01 <Eduard_Munteanu> Supposedly metaprogramming should be quite strong there, but do you actually get to pick the syntax, or are you stuck with parens?
16:06:19 <mauke> both
16:06:36 <mauke> in that you can hook into the lexer but no one does
16:06:46 <Phlogistique> now even C is a DSL which specific domain is to write programs, and that can be embedded into Coccinelle to more generally write *and* transform programs.
16:06:49 <russellw> Eduard_Munteanu, in principle you can redefine the entire syntax, in practice what you usually do is, you stick with the parentheses but can redefine everything else. That is the big selling point of Lisp now that most other languages have garbage collection
16:06:54 * Eduard_Munteanu kinda likes Agda's mixfix stuff and syntax declarations for instance, seems pretty reasonable.
16:06:57 <owst_> dcoutts: I think I was confused by this page: http://www.haskell.org/haskellwiki/How_to_write_a_Haskell_program - which seems to suggest that you need Simple as build-type and use a Setup.hs
16:07:04 <Eduard_Munteanu> Ah.
16:07:40 <Phlogistique> Eduard_Munteanu: I'm unsure about the drawbacks of this mixfix thing - why isn't it more popular?
16:08:01 <c_wraith> Phlogistique: it makes things whitespace sensitive, at least the way agda did it
16:08:19 <cmccann> it also has a lot of potential for abuse
16:08:30 <c_wraith> Phlogistique: some people cannot, for the life of them, figure out how to use whitespace consistently.
16:08:37 <Eduard_Munteanu> There is some awkwardness there, such as having to use (a , b) instead of (a, b) for example.
16:08:45 <dcoutts> owst_: yes, that's true but a bit misleading
16:08:46 <Phlogistique> Eduard_Munteanu: well, LISP programs are usually lists of lists; if you want an other syntax for lists, it should be trivial to convert it to LISP anyways
16:08:58 <Eduard_Munteanu> But generally it seems a reasonable compromise even as implemented.
16:09:06 <mauke> lisp programs are never lists
16:09:09 <Phlogistique> 02:04:32 < c_wraith> Phlogistique: some people cannot, for the life of them, figure out how to use whitespace consistently. <- what do you mean with "consistently"?
16:09:09 <mauke> they're trees
16:09:11 <dcoutts> owst_: distributed packages always need a Setup.hs even if it's the trivial one
16:09:44 <Phlogistique> mauke: a list of lists of lists... is a tree.
16:09:45 <c_wraith> Phlogistique: my company's CEO is no longer allowed to code for us, mostly because he cannot tell the difference between 0, 1, and 2 spaces.
16:09:48 <owst_> dcoutts: Ah, right, so it's the hook overriding that requires Custom?
16:10:06 <c_wraith> Phlogistique: and he mixes them randomly, even on the same line
16:10:20 <Phlogistique> c_wraith: well, a lot of other languages are whitespace-sensitive
16:10:25 <monochrom> you include Setup.hs because some users do not have or want cabal-install
16:10:37 <cmccann> also, note that most lisp programmers, by the time they've gotten comfortable enough with it to be writing EDSLs, are unable to comprehend why you'd want anything other than parentheses
16:10:41 <ByronJohnson> owst_: You set bulid-type to custom iff you use a non-default Setup.hs
16:10:53 <cmccann> much like haskell programmers and 3+ character infix operators
16:10:54 <Eduard_Munteanu> Heh.
16:10:58 <mauke> Phlogistique: I disagree
16:11:05 * Cale tries to figure out why the -XConstraintKinds flag is plural
16:11:21 <owst_> ByronJohnson: right, gotcha.
16:11:22 <cmccann> why is GADTs plural?
16:11:28 <Phlogistique> mauke: why
16:11:34 * monochrom sends cmccann some >=>='s
16:11:36 <c_wraith> Cale: because otherwise it would need to be -XTheConstraintKind
16:11:38 <Eduard_Munteanu> Do we have Rank2Type? :)
16:11:41 <rwbarton> Because you can define more than one GADT in a program.
16:11:44 <Eduard_Munteanu> Hah.
16:11:44 <Cale> Well, that's plural because it lets you define more than one GADT
16:11:47 <dcoutts> owst_: yeah (what ByronJohnson says). Historically Setup.hs was the primary entrypoint, so that is still required. The build-type thing is a more recent addition and lets tools infer that the package is using a simple build system (which e.g. would allow IDEs to do something cleverer than if they're faced with a black box build system)
16:11:50 <mauke> Phlogistique: because [[[a]]] isn't Tree a
16:11:54 <cmccann> hm, true, I guess there is only one kind Constraint, isn't there?
16:11:57 <Cale> yeah
16:12:04 <cmccann> ok, good point.
16:12:14 <Phlogistique> mauke: (((a))) isn't either
16:12:14 <monochrom> we have Rank2Types
16:12:24 <dcoutts> owst_: and then the cabal tool has taken advantage of the build-type to skip compiling Setup.hs if the build type is Simple
16:12:35 <mauke> Phlogistique: (((a))) is just a
16:12:36 <niteria> is "#\" space in scheme or "#\ "?
16:12:44 <Phlogistique> mauke: no it isn't
16:12:53 <Eduard_Munteanu> And, sensibly, ExistentialQuantification :)
16:12:59 <owst_> dcoutts: I see - interesting.
16:13:03 <niteria> http://www.schemers.org/Documents/Standards/R5RS/HTML/r5rs-Z-H-9.html#%_sec_6.3.4 suggests "#\"
16:13:04 <mauke> Phlogistique: ok, we're talking about completely different things
16:13:14 <Phlogistique> mauke: we're talking about lisp
16:13:21 <mauke> Phlogistique: you are
16:13:29 <niteria> but "#\ " is more reasonable
16:13:43 <mauke> niteria: no, that page suggests "#\ "
16:13:50 <Phlogistique> mauke: ok.
16:14:30 <niteria> mauke: well, try selecting it in examples
16:14:40 <mauke> niteria: irrelevant
16:14:50 <mauke> niteria: "Characters are written using the notation #\<character> or #\<character name>."
16:17:26 <niteria> ok, but still, example contradicts it
16:17:41 <tibbe> What's wrong with this type signature? (:!:) :: a -> b -> (a, b)
16:18:02 <cmccann> tibbe, is that a GADT constructor?
16:18:09 <mauke> niteria: html rendering artifact
16:18:14 <tibbe> cmccann: no, just a top-level defined operator
16:18:19 <mauke> tibbe: : is uppercase
16:18:20 <cmccann> then why's the identifier start with :?
16:18:25 <cmccann> :]
16:18:35 <tibbe> mauke: oh
16:18:37 <niteria> I can't find a parser for case insensitive strings
16:18:45 <niteria> is there one?
16:19:42 <ByronJohnson> tibbe: You need to TypeOperators extension for such types
16:19:46 <ByronJohnson> s/to/the/
16:20:13 <tibbe> ByronJohnson: right
16:20:31 <cmccann> but if it's just a regular operator, you want a valid identifier instead :P
16:22:37 <Cale> {-# LANGUAGE GADTs, TypeFamilies, FlexibleInstances, FlexibleContexts, UndecidableInstances, OverlappingInstances, RankNTypes, ScopedTypeVariables, EmptyDataDecls, MultiParamTypeClasses, TypeOperators, StandaloneDeriving, FunctionalDependencies, GeneralizedNewtypeDeriving, TemplateHaskell, BangPatterns, PolyKinds, ConstraintKinds #-}
16:22:57 <cmccann> Cale, not enough
16:22:59 <cmccann> needs more
16:23:25 <ehuber> Cale: OverloadedStrings
16:23:26 <Cale> On looking over that, I'm not sure why FunctionalDependencies
16:23:37 <ByronJohnson> tibbe: I misread that.  IIRC, that'd need to be a *type* operator.
16:23:38 <Cale> but we are using the others
16:23:58 <cmccann> Cale, no existentials? Or is that implied by GADTs or something
16:24:12 <ByronJohnson> tibbe: The problem is the colon at the beginning
16:24:33 <Cale> It's implied by GADTs
16:24:40 <Cale> and yeah, there are existentials in this
16:26:33 <niteria> @type stringCI
16:26:34 <lambdabot> Not in scope: `stringCI'
16:26:45 <Cale> ghc: panic! (the 'impossible' happened)
16:26:45 <Cale>   (GHC version 7.4.0.20111219 for i386-unknown-linux):
16:26:45 <Cale> 	tyConKind ghc-prim:GHC.Prim.BOX{(w) tc 347}
16:26:47 <Cale> .____.
16:27:17 <Cale> Okay, updating to 4.7.1 release to see if it does any better :)
16:27:28 <mauke> "up"?!
16:27:37 <Cale> 7.4.1
16:27:39 <Cale> rather
16:27:46 <Cale> I'm running the RC
16:28:14 <ByronJohnson> tibbe: It's like the difference between the data-level Just and the type-level Maybe.  Infix operators can be defined for the former, and they can also be defined for the latter if they begin with a colon.  I'm not aware of the technical details of it, though.
16:29:18 <ByronJohnson> (e.g. you could define an infix operator at the type level for Maybe)[C
16:29:37 <mauke> unary infix?
16:30:05 <ByronJohnson> s/Maybe/Either/ :)
16:31:24 <Dashkal> a ∨ b -- (Not a v)
16:31:47 <mauke> type (:<>:) = Either
16:33:27 * cmccann has used (:&:), (:+:), (:*:), and (:|:) before
16:36:21 <Cale> Er, what are people using for haddock on 7.4? Does the darcs repo work? It doesn't appear to be installable from hackage.
16:52:46 * hackagebot tagstream-conduit 0.2.2 - streamlined html tag parser  http://hackage.haskell.org/package/tagstream-conduit-0.2.2 (YiHuang)
16:53:03 <gienah> Cale: we use the haddock that is bundled with ghc 7.4
16:53:15 <Cale> gienah: orly?
16:53:27 <Cale> gienah: I'll look for it :)
16:53:38 <Cale> (It doesn't appear to have installed automatically)
16:53:38 <gienah> Cale: ok
16:54:13 <gienah> Cale: on gentoo we use an ebuild to build haddock (and ghc, etc)
16:56:53 <gienah> Cale: anyway once you find haddock in the ghc 7.4 distribution, you should be able to cabal install it from the directory it is in
16:58:05 <Cale> It doesn't appear to have a .cabal, but it is pre-built
16:58:48 <Cale> ah, perhaps I should get the source distribution
16:59:24 <gienah> Cale: on gentoo we build everything from the source :-)
16:59:56 <Cale> yeah, that sucks to have to do for ghc
17:00:05 <Cale> But I'm okay with building haddock to install it
17:01:20 <Saizan> sounds like a bug if the binary package didn't install it
17:03:14 <Cale> Saizan: ah, what you just said helped a good deal :)
17:03:28 <Cale> (it was a path problem)
17:20:27 <Veinor> The recompilation checker now takes into account what flags were used when compiling. For example, if you first run ghc -c Foo.hs, and then ghc -DBAR -c Foo.hs, then GHC will now recompile Foo.hs.
17:20:29 <Veinor> \o/
17:20:38 <mauke> YES
17:21:23 <Veinor> also the libstdc++.so bug got fixed
17:21:50 <mauke> what bug is that?
17:22:03 <Veinor> some things that needed to load libstdc++.so wouldn't work in ghci
17:24:27 <monochrom> \∩/
17:26:03 <Ralith> What is wrong with http://paste.pocoo.org/show/544942/ ?
17:27:36 <mauke> Ralith: is this a quiz?
17:27:41 <Ralith> no
17:27:46 <Ralith> this is for by benefit
17:27:48 <Ralith> my*
17:27:50 <mauke> well, why not ask ghc then?
17:28:01 <cmccann> ghc is smarter than most of us in
17:28:03 <cmccann> here
17:28:09 <Veinor> Ralith: bar is polymorphic in its return value
17:28:21 * cmccann usually learns the hard way the GHC is smarter than he is
17:28:29 <Veinor> but your instance for Foo (Baz a) has type bar :: a -> a
17:28:35 * cmccann also can't type tonight, ugh
17:28:40 <Ralith> Veinor: why is that a problem?
17:28:56 <Veinor> because a -> a and a -> b are not the same type
17:29:14 <Cale> Ralith: bar is supposed to be able to take a value of type a (the class parameter), and produce a value *of any type demanded of it*
17:29:14 <Ralith> but the problem remains if I do:
17:29:19 <parcs`> no, bar is Bar a -> a
17:29:27 <Veinor> parcs`: er, yes
17:29:31 <parcs`> ghc wants a Bar a -> b
17:29:39 <Ralith> Cale: ...huh.
17:29:56 <Ralith> okay, hm.
17:30:04 <Cale> Ralith: your implementation takes a value of type Baz a, (the instance parameter), and produces a value of type a, which is not just any type at all, but the same a as in the instance head
17:30:38 <Cale> So for example, given the type of bar in the class declaration, I should be able to apply it to a value of type  Baz Integer, and get a String
17:30:46 <Ralith> Cale: so how would I write a typeclass such that something to this effect were legal, without hardcoding assumptions about instance type kind?
17:31:03 <mauke> fundeps
17:31:05 <Cale> class Foo a where
17:31:07 <ByronJohnson> Ralith: Asstypes
17:31:10 <mauke> haha
17:31:14 <monochrom> what is your real question?
17:31:20 <Cale>   type BarResult a
17:31:24 <mauke> ByronJohnson: is that the real extension name? :-)
17:31:27 <Cale>   bar :: a -> BarResult a
17:31:37 <monochrom> err nevermind, lag
17:31:38 <Cale> Class associated types
17:31:56 <mauke> {-# LANGUAGE AssTypes #-}
17:31:57 <Cale> instance Foo (Baz a) where
17:31:59 <mauke> if that doesn't work, it should
17:32:06 <Cale>   type BarResult (Baz a) = a
17:32:11 <Ralith> ooh.
17:32:12 <Ralith> nice.
17:32:13 <Cale>   bar (Baz x) = x
17:32:33 <ByronJohnson> Ralith: On a more serious note, they're enabled with the LANGUAGE TypeFamilies pragma
17:33:05 <Cale> yeah, you'll have to put  {-# LANGUAGE TypeFamilies #-} at the very top of your source file
17:33:32 <Cale> You could also have used multiparameter typeclasses and functional dependencies, which is a somewhat older way to do it
17:33:51 <Cale> (occasionally clearer, depending on what you're doing)
17:34:00 <Cale> class Foo a b where
17:34:02 <Cale> er
17:34:06 <Cale> class Foo a b | a -> b where
17:34:12 <Cale>   bar :: a -> b
17:34:15 <Ralith> my actual use-case is such that there is only one return type for any given argument type
17:34:24 <Ralith> otherwise I'd've done that
17:34:25 <Cale> instance Foo (Baz a) a where
17:34:33 <Cale>   bar (Baz x) = x
17:35:41 <Cale> Ralith: yeah, that's what functional dependencies say, basically
17:35:54 <Ralith> oh?
17:36:04 * Ralith reads the wiki
17:36:04 <Cale> the "| a -> b"
17:36:14 <ByronJohnson> Ralith: And asstypes
17:36:35 <Cale> says that for any choice of type a, there is at most one type b for which there is an instance Foo a b
17:36:49 <Cale> Associated types are like type functions
17:37:06 <Cale> and do the same thing, but give the dependency a name
17:37:16 <ByronJohnson> < Ralith> my actual use-case is such that there is only one return type for any given argument type — Personally, I think associated types are a more elegant way to do this
17:37:18 <Cale> (which looks like a type constructor)
17:38:08 <Ralith> ByronJohnson: are associated types the thing Cale originally described?
17:38:11 <Cale> yes
17:38:14 <Ralith> kk
17:38:22 <ByronJohnson> Basically, you write class Foo a where type FooResult (Foo a) where ... instance Foo (Bar a) where type FooResult (Bar a) = a, or something
17:38:29 <Ralith> yeah
17:38:30 <Cale> There's no way to know what's clearer without looking at the real code
17:38:32 <Ralith> that does seem nicer
17:38:41 <Cale> Sometimes functional dependencies are nicer
17:38:44 <ByronJohnson> Whenever you want the Result Type of Foo, simply call FooResult a
17:38:48 <Cale> Sometimes associated types are nicer
17:39:01 * Ralith nod
17:39:30 <ByronJohnson> Cale: Out of curiousity, which would you support incorporating into a Haskell standard?
17:40:02 <Cale> I don't like standards :P
17:40:03 <ByronJohnson> (FWIW, the TypeFamily equivalent of mtl, monads-tf, doesn't require UndecidableInstances.  Oddly, this doesn't seem to be well known)
17:40:38 <Cale> If we're going to start standardising these things, they should be standardised as extensions
17:40:51 <Cale> It's nice that the language is modular with lots of separate extensions
17:41:07 <ByronJohnson> I agree with your last statement, yes
17:42:02 <Cale> But standards largely get in the way of language progress. We're just finally getting rid of the superclass constraints on Num after so many years...
17:43:07 * Ralith glances sidelong at Common Lisp
17:43:11 <Ralith> you don't know the half of it
17:43:15 <Cale> I'm okay with descriptive documents about the structure of the language, but I don't like prescriptive ones.
17:44:17 <parcs`> ByronJohnson: but it requires TypeFamilies :P
17:44:29 <Cale> I like the idea of a Report which says what the current state of affairs is with the language, but I'd rather implementors not take it too seriously.
17:44:55 <jeff_s_> If you had a base spec that had an enum, and then a 2nd spec that extended that enum with an additional value, how would you implement the two without simply copy-pasting code from the first to implement the 2nd?
17:45:48 <Cale> jeff_s_: Make the first one take a type parameter and include an Other case with that parameter?
17:46:13 <Cale> jeff_s_: It's hard to know out of context
17:46:27 <jeff_s_> Cale - I don't think you can use "deriving Enum" if you have a constructor with an argument.
17:46:33 <ByronJohnson> Cale: Interesting.  One problem is that fundeps and asstypes tend to not play well with each other.  There are several -tf and -fd clones of packages on Hackage, for example.
17:46:33 <Cale> That's true
17:47:09 <Cale> ByronJohnson: That's mainly to explore options for implementing those libraries :P
17:47:30 <Cale> ByronJohnson: In my experience you can use both at once (even in the same class!) without so many problems
17:47:45 <cmccann> yes, they work fine together
17:47:59 <cmccann> with the caveat that some interaction is one-way, or impossible
17:48:54 <cmccann> e.g. if you use fundeps to determine a type sometimes you can't use that information with the type family stuff
17:49:01 <Cale> They both translate down to the same sort of thing
17:49:35 <cmccann> and it all works much better together if you leave overlapping instances out
17:54:05 <Cale> http://hackage.haskell.org/trac/ghc/ticket/5717  .___.
17:54:50 <Cale> <-- is getting bitten by that bug
17:55:08 <cmccann> oh nooooo :[
17:55:29 <ByronJohnson> Good timing. :P
17:56:55 <Cale> maybe I can get away without polykinds here, if I just have ConstraintKinds
17:57:29 <Cale> The lack of kind inference with PolyKinds turned off sucks though
17:59:38 <jeff_s_> So I'm implementing Enum for a data type - how do I throw a bad argument exception?
17:59:51 <Cale> It especially sucks that GHC is botching the kind inference inside of TH-generated code .___.
18:00:01 <cmccann> Cale, ouch
18:00:04 <jeff_s_> I'm tryign to duplicate the functionality (or lack there-of) of "pred False"
18:00:23 <cmccann> jeff_s_, why not look at the source for the base package
18:00:26 <jeff_s_> I could just call "pred False" :)
18:01:12 <jeff_s_> Oh, just "error", I guess.
18:01:14 <cmccann> jeff_s_, http://hackage.haskell.org/packages/archive/base/4.5.0.0/doc/html/src/GHC-Enum.html#Enum
18:02:05 <djanatyn> http://hpaste.org/57353 -- my static blog compiler thingy is going well :D
18:05:00 <danharaj> dear god
18:05:05 <danharaj> I just found out about polykinds
18:05:08 <danharaj> you guys are madmen.
18:05:43 <cmccann> yes, but we're polymorphic in the kind of madness
18:05:51 <ByronJohnson> danharaj: Have you seen agda?
18:06:24 <danharaj> ByronJohnson: Yes.
18:06:38 <Veinor> gah
18:06:48 <Veinor> every time i say to myself 'you should try haskell' in response to someone's question
18:06:52 <Veinor> i hear it in ezyang's voice
18:07:27 <Cale> Veinor: heh, where have you heard his voice?
18:07:34 <cmccann> are you sure it's not actually him
18:07:39 <cmccann> maybe he's hiding somewhere
18:07:41 <cmccann> behind you
18:07:42 <cmccann> watching
18:07:44 <cmccann> always
18:07:54 <Veinor> Cale: i go to school with him
18:07:56 <Veinor> so
18:08:38 * ddarius doesn't think he's heard ezyang say "you should try Haskell."
18:09:10 <Veinor> well like
18:09:15 <Veinor> he has that one tone of voice, you know?
18:09:19 <ddarius> Yes.
18:10:14 <danharaj> So I'm pretty sure GHC is overdue for a dependent types extension by now.
18:10:27 <ddarius> danharaj: I don't think so.
18:10:58 <danharaj> ddarius: You can already fake it in an extremely painful oleg-type way.
18:11:02 <cmccann> {-# LANGUAGE Agda #-}
18:11:16 <cmccann> just skip to the end if that's what you want
18:11:16 <danharaj> :p
18:11:18 <gienah> type level records would be really cool
18:11:26 <ddarius> danharaj: No you can't.  You can fake type level programming.
18:11:44 <danharaj> ddarius: yes I'm being careless here. you're right.
18:13:16 <cmccann> faking dependent types would be more likely to involve GADTs and existentials and lots of weird type checking error messages
18:13:45 <danharaj> question is: now that you have polykinds, can you faithfully model n-categories in Haskell?
18:13:51 <ddarius> No.
18:14:06 <cmccann> can you faithfully model any math in haskell?
18:14:11 <ddarius> cmccann: Yes.
18:14:37 <cmccann> for appropriately severe definitions of "faithfully"
18:15:03 <ddarius> cmccann: As long as you have an corresponding appropriately severe definition of "any."
18:15:04 <mauke> yours faithfully: math
18:15:21 <ddarius> "yours essentially surjectively"
18:15:37 <cmccann> ddarius, a fair point, "any" is pretty inclusive :P
18:16:08 * cmccann would more likely go for "yours forgetfully"
18:16:35 <monochrom> yours forgetfully functor
18:19:10 <CodeWeaver> This begs pasting this beautiful video.
18:19:12 <CodeWeaver> http://www.youtube.com/watch?v=BipvGD-LCjU
18:23:48 <ddarius> CodeWeaver++
18:23:55 <CodeWeaver> Isn't that genius?
18:24:16 <CodeWeaver> Check out their other videos.  TBP is probably my favourite, but their others are worthy of merit.
18:24:22 <CodeWeaver> Of the few I've heard.
18:24:51 <new2net> I was interested in learning haskell, but I wanted to know from some people who have used it: what is Haskell exceptional at?  Can I manipulate images with haskell?
18:25:39 <CodeWeaver> You can do anything in haskell you can do in any other programming language, including that.
18:26:08 <CodeWeaver> Its strengths don't exactly come from what it can do, but how it does it.
18:26:36 <cmccann> new2net, Haskell's strengths are more about how it's used than the specific tasks it's used for
18:28:00 <cmccann> but yes, it's a general purpose language, you can use it for any general purposes
18:28:02 <CodeWeaver> It can be high performance compiled  or scripted… its strengths probably aren't in the rapid prototyping of GUIs like Visual Basic, although you can do it like you can in C/C++… but it has masterful strength in making your programs more bulletproof because programs often resemble (and have some of the strengths of) math proofs.
18:28:15 <new2net> oh so it has a window system
18:28:26 <CodeWeaver> With associated packages, sure, bindings to lower level APIs.
18:28:27 <cmccann> it has bindings to gtk and wx
18:28:45 <cmccann> there are bindings to lots of common C libraries, in fact
18:29:05 <new2net> curl probably :)
18:29:36 <CodeWeaver> Really, learn it because it's a robust and clean functional programming language, and learn what *that* means.
18:29:50 <CodeWeaver> Cause it can *do* most anything a modern language can do.
18:30:02 <dev360> is anybody here familiar with the Database.Redis library? Im a complete n00b and could use some help.
18:30:02 <CodeWeaver> Do I get my salesman's badge?
18:30:20 <new2net> CodeWeaver, is there any notion of OOP in a purely functional language?
18:31:04 <CodeWeaver> Yyyyyyyes, sort of.  I mean, OOP can be practiced in any kind of language if you're diligent.  What your'e asking, then, is "is OOP supported directly", and the answer is "depends what you mean".
18:31:05 <cmccann> new2net, anyway, Haskell is nearly as flexible as most "scripting" languages and nearly as fast as most compiled languages, so it can be an excellent choice if you need both
18:31:06 <new2net> maybe ... pipes or chains or code?
18:31:24 <cmccann> OOP style mostly gets in the way in haskell, and it's not really that useful anyway
18:32:26 <cmccann> most of what you'd accomplish using OOP style can be done in other ways in haskell that work at least as well
18:32:30 <mauke> new2net: hah. function composition is pipes of code
18:32:32 <CodeWeaver> new2net:  You should probably start by taking a step back from OOP to learn Haskell in its clearest form, and then bring in any OOP concepts you feel are really necessary.  Yes, you can do those sorts of things with some care.
18:32:47 <mauke> new2net: there's basically no notion of OOP in Haskell
18:32:56 <CodeWeaver> new2net: cmccann is right.  OOP is just one hammer.  Try another hammer for a while.
18:33:12 <new2net> oh yes... my most important question. Is there support for multiple threads?
18:33:15 <CodeWeaver> mauke:  Well, not *directly*.  It is certainly conceptually buildable.
18:33:22 <CodeWeaver> Yup.
18:33:23 <ByronJohnson> new2net: Of course
18:33:24 <mauke> OCaml isn't purely functional but it supports OO stuff like classes
18:33:31 <CodeWeaver> That's one of Haskell's strengths, actually, new2net.
18:33:35 <cmccann> new2net, haskell has nicer threading support than almost any other language I know of
18:33:50 <ninor> cmccann, what makes the threading support so good?
18:34:02 <CodeWeaver> Referential transparency.
18:34:03 <cmccann> ninor, purity and STM
18:34:06 <CodeWeaver> Non-mutation.
18:34:10 <mauke> ninor: want to spawn 500000 threads? sure, no problem
18:34:24 <ninor> what's this stuff mean?
18:34:25 <ninor> hehee
18:34:33 <cmccann> also, good support from the runtime, e.g. what mauke said
18:34:36 <mauke> I'm not joking, I actually did that
18:34:36 <CodeWeaver> Any newcomers:  http://learnyouahaskell.com/
18:34:39 <CodeWeaver> Good place to start.
18:34:45 <new2net> yes, I have started there :)
18:35:00 <cmccann> ninor, the short version is "99% of the headaches and weird bugs you get from concurrency in other languages don't happen in Haskell"
18:35:19 <ninor> wish i understood why :(
18:35:23 <mauke> ninor: if your data is never modified, you never have to copy it. you also don't need locks to access it from multiple threads.
18:35:39 <mauke> it's safe by default, in a way
18:35:41 <ninor> ahh
18:35:53 <cmccann> ninor, you have to go out of your way to make anything not thread-safe in haskell
18:35:54 <ninor> how is data never modified? is it copied as new values are produced?
18:36:10 <mauke> well, that's what purely functional programming is about
18:36:11 <CodeWeaver> Yes, but very efficiently, and sometimes not at all if the compiler can determine data is just being handed off.
18:36:13 <mauke> you don't mutate
18:36:24 <mauke> you construct new values
18:36:25 <CodeWeaver> As a consequence, though, you learn to program a little bit differently.
18:37:08 <CodeWeaver> Which is a great tradeoff for easy parallelism.
18:37:13 <ninor> hmm
18:37:39 <new2net> Oh right. I saw this on wikipedia; haskell can barrow functions from other languages? Is there a list of supported languages somewhere or am I not making any sense at all?
18:37:40 <CodeWeaver> under the hood it gets clever.  Above the hood, you don't worry about the details until you need to performance tune the 1% of your program running 99% of the time.
18:38:06 <ninor> ah
18:38:10 <mauke> new2net: basically, it supports C
18:38:13 <cmccann> new2net, mostly just to C, or anything with a C API
18:38:19 <ninor> i look forward to learning more about it
18:38:20 <cmccann> which turns out to be quite a lot of stuff
18:38:36 <new2net> oh... so no python + bash support or anything like that?
18:38:41 <mauke> what do you mean by "support"?
18:38:51 <startling> new2net, python has a c api
18:39:02 <CodeWeaver> new2net, well, you could tell the system to spawn a python interpreter.  No reason why not.
18:39:04 <startling> new2net, there's a python module for haskell though, give me a second to find it.
18:39:08 <CodeWeaver> Is there?
18:39:09 <CodeWeaver> Neat!
18:39:18 <mauke> I mean, you can call system "ls >output.txt" and that will spawn a shell
18:39:21 <CodeWeaver> So many packages.
18:39:28 <m3ga> calling from C into python is extraordinarily painful
18:39:46 <startling> it is.
18:39:59 <m3ga> caba install bytestring -> cabal: Couldn't read cabal file "bytestring/0.9.2.1/bytestring.cabal"
18:40:37 <m3ga> is that the new ghc release killing hackage with downloads?
18:43:32 <startling> new2net, CodeWeaver: https://john-millikin.com/articles/ride-the-snake/
18:43:51 <new2net> Is there an interactive shell type interface for 1 liners that a beginner might want to test?
18:43:55 <cmccann> yes
18:44:13 <mauke> ghci
18:44:22 <mauke> or lambdabot :-)
18:44:24 <cmccann> there's also a web-based REPL somewhere
18:44:26 <mauke> > 2 + 2
18:44:27 <lambdabot>   4
18:44:27 <preflex>  lambdabot: you have 2 new messages. '/msg preflex messages' to read them.
18:44:33 <cmccann> what
18:45:09 <mauke> @msg #haskell messages
18:45:10 <lambdabot> messages
18:45:15 <mauke> @msg #haskell preflex: messages
18:45:16 <new2net> > 2 | 1
18:45:16 <lambdabot> preflex: messages
18:45:16 <preflex>  elliott said 8 days, 4 hours, 40 minutes and 17 seconds ago: hey monochrom, you can @remember that now!
18:45:16 <lambdabot>   <no location info>: parse error on input `|'
18:45:17 <preflex>  Axman6 said 2 days, 1 hour, 14 minutes and 14 seconds ago: We love you
18:45:29 <startling> haha
18:45:34 <mauke> elliott-- Axman6--
18:45:49 <cmccann> hahaha
18:47:16 <dev360> is anybody here familiar with the Redis client library, or can help explain the type signature for me? Im new to haskell and get stuck on rudimentary stuff. Any help would be much appreciated.
18:48:01 <CodeWeaver> Well, installing ghc is pretty trivial, and it comes with its own interpreter, ghci.
18:48:10 <CodeWeaver> Damn, I"m a few pages behind.
18:48:12 <CodeWeaver> boo
18:48:15 <mauke> sorry, no clue about redis
18:48:25 <ByronJohnson> dev360: I suggest reading http://learnyouahaskell.com/ or RWH.  If you provide a more specific request, we may be able to help
18:48:35 <cmccann> dev360, which package?
18:48:41 <ByronJohnson> dev360: Which type signature are you trying to understand?
18:48:47 <dev360> Database.Redis - http://hackage.haskell.org/packages/archive/redis/0.12/doc/html/Database-Redis-Redis.html
18:49:01 <dev360> lrange
18:49:43 <Cale> dev360: okay
18:49:58 <Cale> dev360: (I have no familiarity with this library, but I can explain the type of lrange)
18:50:03 <tigger> Hi there, I'm having a surprisingly hard time installing Bytestring. I do cabal install bytestring, but get "cabal: Couldn't read cabal file "bytestring/0.9.2.1/bytestring.cabal", does anyone else have this issue?
18:50:04 <tkahn6> it takes a redis connection, a bytestring of the key, and a tuple of (lower, upper bound)
18:50:14 * cmccann rolls his eyes at the BS class
18:50:25 <Cale> Yeah, that seems awkward
18:50:26 <dev360> Im able to call llen by just doing                    x <- llen redis key >>= fromRInt, but what would the code for lrange would have to look like?
18:50:57 <mauke> wtf <- lrange redis key (from, to)
18:51:05 <tkahn6> cmccann: what's wrong with the BS class? i keep hearing conflicting views about the various string representations
18:51:50 <dev360> mauke: then it tells me Couldn't match expected type `IO t0'  with actual type `(Int, Int) -> IO (Reply s20)'
18:52:10 <mauke> dev360: what's the full error message?
18:52:12 <tkahn6> u didn't pass in the tuple it seems
18:52:12 <cmccann> tkahn6, just seems a bit frivolous for avoiding a few simple conversions
18:52:20 <tkahn6> cmccann: oh i see
18:52:30 <tkahn6> maybe it saves the library author some work
18:52:33 <tkahn6> heh
18:52:48 * hackagebot scan-vector-machine 0.2 - An implementation of the Scan Vector Machine instruction set in Haskell  http://hackage.haskell.org/package/scan-vector-machine-0.2 (AdamMegacz)
18:53:20 <mauke> wtf <- lrange redis key (from, to) >>= fromRMultiBulk
18:54:05 <dev360> tkahn6: you are right, sorry. I get: <interactive>:1:6:
18:54:05 <dev360>     Ambiguous type variable `s20' in the constraint:
18:54:05 <dev360>       (Database.Redis.ByteStringClass.BS
18:54:05 <dev360>          s20) arising from a use of `lrange'
18:54:22 <mauke> that means it doesn't know which result type you want
18:54:26 <dev360> Ill paste it in a gist instead
18:55:12 <mauke> wtf <- lrange redis key (from, to) >>= fromRMultiBulk :: IO (Maybe [Maybe S.ByteString]) should at least make it compile
18:55:22 <mauke> assuming import qualified Data.ByteString as S
18:55:35 <dev360> okay let me try that
18:56:03 <dev360> I looked at the fromRMultiBulk before but just couldnt figure it out
18:58:01 <dev360> mauke: thank you so much - that helped!!!
18:58:31 <dev360> SO how could I have arrived at this conclusion by myself? I tried to introspect but it just wouldnt give me anything back
18:59:06 <dev360> The type signature just didnt make any sense to me
18:59:39 <dev360> I sort of vaguely understand that fromRMultiBulk unwraps the value inside
19:00:55 <mauke> well, Redis -> s1 -> (Int, Int) -> ... tell me what the parameters are
19:01:18 <dev360> those I figured out, but beyond that I was not getting anywhere
19:01:32 <dev360> for instance.. why does it say :: (BS s1, BS s2)
19:01:36 <mauke> and the return value is IO (Reply s2) where s2 is a BS
19:01:39 <dev360> those are two bytestrings, no?
19:01:42 <mauke> no
19:01:51 <mauke> anything convertible from/to a bytestring
19:02:14 <mauke> that includes bytestrings but also strings and numbers for some reason
19:02:48 * hackagebot scan-vector-machine 0.2.1 - An implementation of the Scan Vector Machine instruction set in Haskell  http://hackage.haskell.org/package/scan-vector-machine-0.2.1 (AdamMegacz)
19:02:50 * hackagebot scan-vector-machine 0.2.2 - An implementation of the Scan Vector Machine instruction set in Haskell  http://hackage.haskell.org/package/scan-vector-machine-0.2.2 (AdamMegacz)
19:03:26 <luite> hmm, cabal install xhtml installs 3000.2.0.3 even though 3000.2.0.4 is available, is the older version somehow listed as preferred?
19:03:27 <dev360> mauke: Okay, well thank you so much again!
19:03:35 <mauke> so it probably uses bytestrings internally but can convert it for you
19:03:53 <mauke> but that also means you either have to use the result or specify a type signature so it knows which type you want
19:04:09 <luite> oh no it isn't, it just has incompatible base dependencies
19:04:38 <dev360> right. Its just a string right now - was trying to keep it simple.
19:09:32 <tgeeky> Data.Map.foldWithKey is no longer deprecated, although it is expected to be deprecated again in the future. <-- giggles
19:11:19 <ddarius> tgeeky: The Haskell 98 Report warns that n+k patterns may be removed in the future.  Sure enough, the next standard, Haskell 2010 removed them 12 years later.
19:11:36 <tgeeky> ddarius: hehe. yes. I actually ran into that! :O
19:12:05 <tgeeky> I thought, at the time, that the extension to turn them back on wasn't working, so I just put (n-1)'s on the RHS.
19:12:46 <tgeeky> but I was probably doing something stupid
19:14:38 <wavewave> so happy that ghc 7.4 is out!
19:15:10 <wavewave> my hxournal also has continuous page view support, too ;-)
19:18:13 <tgeeky> wavewave: if only it were continuous in the calculus sense :o
19:18:37 <tgeeky> then you could use it to simulate all of those impossible things they show on TV crime shows. ENHANCE! ZOOM IN! ENHANCE MORE!
19:19:01 <tgeeky> wavewave: maybe I'll try that out on my laptop and wacom-ish tablet
19:19:15 <wavewave> tgeeky: that's already possible... you know when using vector graphics. ;-P
19:19:17 <ddarius> tgeeky: That's not impossible at all.  You just missed all the "Degrade! Zoom out! Degrade more!" commands beforehand.
19:19:37 <tgeeky> ddarius: I won't be happy until I can't see anything!
19:19:55 <tgeeky> lol
19:20:33 <wavewave> this hxournal project was so fun to me. hehe
19:21:01 <wavewave> i've learned many things..
19:21:08 <tgeeky> wavewave: post a new screenshot with a poem written on the exterior edge of the equation e^pi*i + 1 = 0
19:21:16 <tgeeky> around the letters :o
19:22:11 <wavewave> tgeeky: :-)
19:22:43 <wavewave> I am thinking of posting some video.. :-)
19:22:58 <tgeeky> wavewave: you don't know anything about the Langlands program do you?
19:23:14 <wavewave> I don't know much about that.. that's witten's stuff.
19:23:38 <Entroacceptor> cabal: Couldn't read cabal file "bytestring/0.9.2.1/bytestring.cabal"
19:25:59 <tgeeky> Entroacceptor: works fine for me when I build it by itself in 7.2.
19:26:18 <Entroacceptor> I get that with whatever I'm trying to build
19:26:51 <tgeeky> Entroacceptor: by that you mean, if you build anything (if it uses bytestring or not?)
19:28:05 <tgeeky> wavewave: I say this because I was trying to sit through some of Benedict Gross' videos on the subject, and I... am hopelessly unprepared for something this advanced.
19:28:48 <ddarius> tgeeky: Become unprepared.
19:29:03 <tgeeky> ddarius: yes, but I would imagine that might take over a year.
19:29:19 <ddarius> tgeeky: Do you have less than a year left to live?
19:29:27 <Entroacceptor> tgeeky: no
19:29:42 <wavewave> that's very advanced stuff. it's more math than physics.
19:30:09 <ddarius> I thought it was all math.
19:30:24 <ddarius> (Admittedly, not in contradiction to what you said.)
19:30:28 <cmccann> ddarius has a very no-nonsense approach to self-improvement
19:31:02 <wavewave> it's some related to S-duality thing. but I don't know much about it.
19:31:02 <tgeeky> ddarius: well, in the last ~ 2 or 3 years, Witten et al have connected it to one of the important dualities in string theory (as far as I can tell, only in the 4D case)
19:31:22 <ddarius> tgeeky: I'm failing to see the connection to physics.
19:31:39 <tgeeky> ddarius: anti-string theory humor.
19:31:49 <parcs`> does ghc 7.4.1 require a particular verison of cabal-install?
19:32:05 <tgeeky> ddarius: I (and I think correctly) view string theory as a theory of mathematics, anyhow. It's possible that it's a theory of physics as well, but right now, it's a pretty amazing collection of mathematics.
19:32:20 <ddarius> tgeeky: That is my perspective as well.
19:32:51 <hydo> parcs`: came here to ask that as well.  Neither the hackage version, nor my git mirror are working.
19:33:09 <wavewave> well, all the physics are mathematics proven also with experiment.
19:33:24 <ddarius> wavewave: That last part is kind of important.
19:33:49 <tgeeky> I can also totally understand why string theorists think it's a theory of physics, and I understand (and empathize with) that. And perhaps it is (and perhaps they actually see enough of the detail to think so). But I don't see it, yet.
19:33:59 <parcs`> hydo: i'm getting cabal: Couldn't read cabal file "bytestring/0.9.2.1/bytestring.cabal"
19:34:20 <tgeeky> rut roh. 7.4.1 bug?
19:34:39 <ddarius> parcs`: Have you looked at the file?
19:35:33 <tgeeky> ddarius: parcs`: etc: the only thing that's changed is the Version line in the cabal file.
19:36:07 <parcs`> ddarius: it doesn't exist
19:36:22 <Entroacceptor> parcs`: I get that with ghc 7.0.3, too
19:36:26 <hydo> tgeeky: really?  Hrm.  Should I really be able to download 7.4.1 and cabal-install from hackage and it work?
19:36:30 <Entroacceptor> I think someone broke hackage
19:36:32 <tgeeky> hydo: I just did.
19:36:38 <hydo> w t f
19:36:41 <parcs`> strace time
19:36:43 <tgeeky> wait. wait. wait.
19:36:49 <ddarius> Someone suggested that you are simply being GHCed.
19:36:55 <tgeeky> hydo: I installed 0.9.2.1 onto 7.2.1
19:36:58 <tgeeky> from hackage
19:37:00 <hydo> I've had this same problem since the first 7.2 was released.
19:37:48 <hydo> tgeeky: I had that... Now i'm trying to get cabal-install to install with 7.4.1
19:38:07 <tgeeky> hydo: just try cabal unpack && cabal install
19:38:21 * cmccann is amused to see JaffaCake disconnected by a read error in the middle of a conversation about a new GHC version breaking things
19:38:37 <wavewave> I uploaded a picture of continuous page mode and split screen on the hxournal gallery page.
19:38:57 <hydo> tgeeky: I...... hrm. I always kill ~/.ghc and ~/.cabal and rebuild everything between ghc releases.
19:39:01 <wavewave> see http://ianwookim.org/hxournal/gallery.html
19:39:08 <hydo> tgeeky: you don't?
19:39:16 <tgeeky> wavewave: grammar note: "splitted" should just be "split"
19:39:21 <tgeeky> wavewave: in all cases, on that page
19:39:38 <wavewave> tgeeky : thanks!
19:39:50 <tgeeky> hydo: I haven't tried to install 7.4.1, yet. That's why I was emphasizing that I am on 7.2.1.
19:39:56 <hydo> ah, ok.
19:40:01 <tgeeky> hydo: but the package, on hackage, does not appear to be broken to me.
19:40:34 <hydo> tgeeky: probably not with 7.2.x
19:40:52 <jfischoff> is anyone familiar with GHC.Generics?
19:40:54 <tgeeky> hydo: I can try on my laptop, which is 7.4.1rc1, and report back in a few
19:41:50 <parcs`> i built 7.4 from source if that makes a difference
19:41:55 * ddarius considers trying hxournal with his Bamboo Fun.
19:41:57 <hydo> naw, I'll just wait.  I can't believe that with the release of a new version of ghc, people aren't trying to download and install cabal-install.  Either others will have the same problem, or I'm on my own.
19:43:07 <Sgeo> Should the topic be updated?
19:43:57 <CodeWeaver> Problems with 7.4.1 already?
19:44:54 <hydo> CodeWeaver: probably not - I'm going to try the darcs version of cabal-install.  Can't get the hackage version to install.
19:45:12 <parcs`> does cabal install bytestring not work for anyone else?
19:45:24 <tgeeky> uhhhh
19:45:34 <parcs`> i think this is a hackage issue
19:46:02 <tgeeky> parcs`: hydo: well that's weird. My laptop is 7.4.1-rc1 (yes, rc1) and it says bytestring-0.9.2.1 is already installed.
19:46:08 <tgeeky> But that's impossible, because it was just released today.
19:46:19 <gienah> ghc-7.4.1-src.tar.gz contains ghc-7.4.1/libraries/Cabal/cabal-install
19:46:37 <tgeeky> unless it was already bumped in rc1, I guess :/
19:47:08 <parcs`> tgeeky: try cabal update; cabal install --reinstall
19:47:14 <parcs`> bytestring
19:47:25 <tgeeky> preflex: I did, and it complained about quickcheck.
19:47:30 <hydo> hehe... need to install darcs to get the latest greatest cabal-install... so I can install darcs to...  oh boy.
19:47:47 <tgeeky> hydo: yeah, 7.4.1 comes with cabal changes and it simply refers to "cabal changelog"
19:48:06 <parcs`> that mysterious nonexistent cabal changelog :P
19:48:36 <tgeeky> parcs`: it exists in the repo, but it was last updated in Jun 2011
19:48:37 <NihilistDandy> tgeeky: I also have 0.9.2.1
19:48:55 <NihilistDandy> hydo: Use the hackage version of cabal-install
19:48:59 <NihilistDandy> I just got through it
19:49:25 <NihilistDandy> *darcs
19:49:27 <NihilistDandy> Derp
19:49:35 <NihilistDandy> The hackage version is all wrong
19:49:36 <hydo> NihilistDandy: that would be awesome if I didn't get errors much like with 7.2
19:49:47 <hydo> ag
19:49:50 <hydo> err ah
19:50:03 <NihilistDandy> The darcs version should be okay. Easier than 7.2, even
19:50:05 <NihilistDandy> No patching needed
19:50:11 <tgeeky> NihilistDandy: so they didn't actually bump the version?
19:50:35 <hydo> Would someone kindly ball up the darcs version by chance?  I can't get it without that whole chicken/egg problem I aluded to a bit ago.
19:50:37 <NihilistDandy> tgeeky: cabal-install version 0.13.3
19:50:38 <NihilistDandy> using version 1.14.0 of the Cabal library
19:50:54 <NihilistDandy> hydo: What system?
19:51:09 <NihilistDandy> Aren't there binary distros for most systems?
19:51:24 <tgeeky> NihilistDandy: we're probably just talking about problems with 7.4.1
19:51:25 <hydo> At what point does cabal-install become part of ghc?  Never?
19:51:32 <hydo> NihilistDandy: naw, just the source.
19:51:49 <NihilistDandy> hydo: What OS?
19:51:49 <hydo> there probably are, but I don't use them.
19:52:01 <NihilistDandy> You only need to use the binary until you get the source
19:52:09 <NihilistDandy> Then you'll just build the new one
19:52:11 <hydo> oh, I see what you're saying.
19:52:21 <hydo> Clearly I am undercaffinated..
19:52:24 <NihilistDandy> lol
19:52:31 <hydo> osx
19:52:40 <NihilistDandy> http://darcs.net/binaries/macosx/darcs-2.5-OSX-10.6-i386.tar.gz
19:53:00 <NihilistDandy> If you need to build happy, let me know. You need to patch the lexer to get it to build with 7.4.1
19:53:04 <parcs`> hydo: there's a bootstrap.sh script inside the cabal repo
19:53:25 <hydo> parcs`: yep... that's what I always use... and that's what always doesn't work. :)
19:53:29 <ddarius> It makes no sense to have cabal-install become part of GHC.
19:53:34 <NihilistDandy> hydo: It works this time
19:53:36 <hydo> ddarius: clearly
19:53:38 <CodeWeaver> Nihilist, I might just need that.
19:53:39 <NihilistDandy> I promise
19:54:05 <NihilistDandy> CodeWeaver: Sure thing. I submitted the patch to Simon, but that was 10 minutes ago :D
19:54:07 <hydo> NihilistDandy: no, I believe you.
19:54:22 <NihilistDandy> hydo: I'm also on OS X :D
19:54:24 <NihilistDandy> Lion, even
19:54:40 <CodeWeaver> Nihilist:  So am I.  Maybe I can bounce ARRRGH IT WON'T BUILD off of you once in a while. :/
19:54:43 <hydo> sorry for being a ding-dong everyone.  I should have looked for darcs bins - could have solved my own problem.
19:54:51 <NihilistDandy> lol
19:55:08 <NihilistDandy> CodeWeaver: Please do. I'm getting pretty good at that :D
19:55:13 <CodeWeaver> I'm becoming way too familiar with hacking around cabal files. :)
19:55:22 <avartanian> Quick question for all you beautiful Haskellers. I find myself fold (>>=) all the time. Is there a more idiomatic way of writing something like: foldl (>>=) (return 1) (replicate 10 (\_ -> [1,2])) ?
19:55:22 <NihilistDandy> Same
19:55:45 <CodeWeaver> Okay, well, may take you up on that.  Trying to help JP get EclipseFP working smoothly on OSX, but my own ghc/xcode/llvm/segfault woes are *not* helping.
19:55:58 <PatrickRobotham> avartanian: Sequence?
19:56:08 <NihilistDandy> Well, the patch for happy is pretty simple, so if you need it, just query me
19:56:16 <NihilistDandy> Alex builds just fine, thankfully
19:56:41 <CodeWeaver> I'll try, Nihilist… I think I'll need happy to get scion-browser to build.
19:57:11 <NihilistDandy> I always get happy and alex out of the way early
19:57:15 <NihilistDandy> I loves my Agda
19:57:18 <parcs`> wait so what exactly is the cabal issue
19:57:19 <magicman> The current DJ is Jick, and they're on until 2012-02-02 23:59:59 EST.
19:57:48 <NihilistDandy> parcs`: Can't get darcs repo without darcs
19:57:53 <NihilistDandy> Just a brain malfunction
19:58:09 <parcs`> why is the darcs version of cabal required?
19:58:27 <NihilistDandy> Because the hackage one doesn't build under 7.4.1
19:58:42 <parcs`> oh
19:58:46 <NihilistDandy> Well, cabal-install, to be precise
19:58:47 <CodeWeaver> Moreover, *which* version of cabal does it actually end up being?  My cabal seems to be okay.
19:58:55 <NihilistDandy> CodeWeaver: What's your version
19:58:58 <NihilistDandy> ?
19:59:07 <NihilistDandy> I'm cabal-install version 0.13.3
19:59:07 <NihilistDandy> using version 1.14.0 of the Cabal library
19:59:07 <CodeWeaver> 0.10.4 of cabal-install, 1.12.0 of Cabal
19:59:16 <CodeWeaver> Mmmm..
19:59:25 <CodeWeaver> Mayhaps I'll try to grab the repo version.
19:59:28 <avartanian> PatrickRobotham: I thought sequence just computed each monad left to right rather than chaining them.
19:59:42 <mauke> "each monad" :-(
19:59:45 <NihilistDandy> Which GHC are you using, CodeWeaver ?
19:59:49 <gienah> Cabal-1.14.0 is the version included in ghc-7.4.1-src.tar.bz2
19:59:52 <CodeWeaver> Trying to get 7.4.1 to go.
20:00:00 <CodeWeaver> OSX.
20:00:15 <NihilistDandy> Let me go for a quick cigarette, and I'll tell you how to make it go :D
20:00:22 <CodeWeaver> Hooray!
20:00:25 <CodeWeaver> *snoopy dances*
20:00:27 <NihilistDandy> :D
20:00:31 <NihilistDandy> Back shortly
20:00:34 <avartanian> mauke: Okay, I suck.
20:01:41 <mauke> > foldl (>>=) (return 1) (replicate 3 (const [1,2]))
20:01:42 <lambdabot>   [1,2,1,2,1,2,1,2]
20:02:52 <mauke> > foldl (>=>) return (replicate 3 (const [1,2])) 1
20:02:52 <lambdabot>   [1,2,1,2,1,2,1,2]
20:04:05 <hydo> NihilistDandy: GASP!  you PROMISED!  https://img.skitch.com/20120203-j7q6kggw3ks9tfc42w9ricnk5u.jpg
20:05:08 <mauke> base >=4 && <3?
20:05:29 <A1kmm> Anyone having problems getting cabal to work with the current Hackage index?
20:05:44 <CodeWeaver> It is a matter of much amusement.
20:05:49 <CodeWeaver> For various definitions of amusement.
20:06:02 <A1kmm> I get this after a cabal update: cabal: Couldn't read cabal file "bytestring/0.9.2.1/bytestring.cabal"
20:06:21 <parcs`> yep, same
20:06:27 <A1kmm> and I see someone asked a question about the exact same error on Stackoverflow (unanswered) less than an hour ago.
20:06:38 <Sgeo> Will the next Haskell Platform in May use 7.4?
20:06:51 <parcs`> yeah the next hp will use 7.4
20:06:55 <A1kmm> The file is there if I manually extract packages/hackage.haskell.org/00-index.tar with tar
20:07:00 <Sgeo> Yay
20:07:06 <Sgeo> I can be lazy and just wait for the HP
20:07:08 <Sgeo> >.>
20:07:18 <Sgeo> Although I guess I do want it sooner than that
20:07:48 <parcs`> i'm still bummed that -fdefer-type-errors didn't make it to 7.4
20:08:48 <NihilistDandy> CodeWeaver: Back
20:09:02 <CodeWeaver> Hurray!
20:09:02 <NihilistDandy> hydo: You grabbed the wrong cabl
20:09:05 <NihilistDandy> *cabal
20:09:22 <NihilistDandy> Okay, so first and foremost, I assume you have libgmp through homebrew or equivalent
20:09:25 <CodeWeaver> I'd like to be a good advcoate for GHC on OSX, but its a little tough some days. ;)
20:09:36 <NihilistDandy> :D
20:09:37 <CodeWeaver> libgmp, probably, through macports.
20:09:39 <NihilistDandy> I'm all about it
20:09:52 <tikhonjelvis> Hmm, anybody here use GHC on Fedora?
20:10:09 <NihilistDandy> Blah, macports. But it'll be fine, probably
20:10:19 <CodeWeaver> As far as I know. :)
20:10:40 <CodeWeaver> Hold the phone, I lied.  But it's building now.
20:10:50 <NihilistDandy> So you wanna incant `curl -O http://www.haskell.org/ghc/dist/7.4.1/ghc-7.4.1-x86_64-apple-darwin.tar.bz2` and then tar xjvf that
20:10:53 <NihilistDandy> Oh, okay
20:11:14 <CodeWeaver> I've got the installer package for that.
20:11:19 <luite> ghc 7.4.1 seems to work fine here on os x with macports (ghc built from source)
20:11:26 <CodeWeaver> Will I need the tarball iinstead?
20:11:29 <NihilistDandy> CodeWeaver: I highly recommend from source
20:11:32 <CodeWeaver> Okay.
20:11:40 <CodeWeaver> I'll uninstall the existing one.
20:12:09 <CodeWeaver> Wait, won't I need an existing ghc install to build the new one if I do it that way?
20:12:20 <NihilistDandy> Nope
20:12:26 <NihilistDandy> Bootstrap FTW
20:12:29 <CodeWeaver> k
20:13:22 <CodeWeaver> Crap, I've forgotten how to curl.  Got a screenfull of gibberish.
20:13:34 <CodeWeaver> Ah, forgot the -O
20:13:37 <NihilistDandy> yup
20:13:47 <hydo> ugh... comcast sucks and all that.
20:14:24 <blackdog> hydo: hello mate. what're you doing with 0mq & haskell? i am all agog.
20:14:26 <NihilistDandy> CodeWeaver: Let me know when you've got it untar'd
20:14:43 <CodeWeaver> Downloading as we speak.
20:14:51 <CodeWeaver> Uninstalled prepackaged 7.4.1
20:14:55 <blackdog> (i am currently struggling with the Network lib - can't work out how to get it to pretend ipv6 doesn't exist.)
20:15:07 <NihilistDandy> hydo: You don't need to reinstall Cabal, you just need to install the cabal-install from the darcs head repo
20:15:14 <CodeWeaver> Apparently 6 minutes to go.
20:15:17 <CodeWeaver> And counting
20:15:17 <NihilistDandy> CodeWeaver: Awesome
20:15:47 <hydo> NihilistDandy: yea, that's what I was trying to do.  ./bootstrap must have downloaded cabal.  looking.
20:15:59 <hydo> yea, it did.
20:16:09 <parcs`> yay i fixed the hackage problem
20:16:24 <parcs`> tar --delete -f ~/.cabal/packages/00-index.tar bytestring/0.9.2.1
20:16:41 <NihilistDandy> hydo: Hmm… it oughtn't to have done that. 7.4.1 comes with the newest Cabal. Then the darcs head repo has the newest cabal-install
20:16:44 <hydo> blackdog: I just got a simple abstraction that let you write to a TVar adn read from another and have it send/receive over zmq
20:16:51 <parcs`> err, tar --delete -f ~/.cabal/packages/hackage.haskell.org/00-index.tar bytestring/0.9.2.1
20:17:20 <hydo> NihilistDandy: weird... this is from darcs.  let me make sure I didn't do something dumb.
20:17:22 <blackdog> hydo: right. got an application behind that, or it's just a cool abstraction-mapping? :)
20:17:43 <NihilistDandy> hydo: As long you darcs get http://darcs.haskell.org/cabal/ you should have the right one
20:18:14 <hydo> blackdog: I will, once I test it more to make sure that it works.  I'll put it up somewhere here soon.  you saw my thing about it on twitter?
20:18:19 <CodeWeaver> *twiddles fingers*
20:18:24 <NihilistDandy> :D
20:18:30 <blackdog> hydo: yep.
20:18:48 <hydo> NihilistDandy: yea, I just went to the cabal-install page and copy/pasted the "darcs get" into a terminal.
20:19:00 <NihilistDandy> From here: http://www.haskell.org/cabal/code.html
20:19:01 <NihilistDandy> ?
20:19:09 <CodeWeaver> I've been installing, uninstalling, and debugging tring to get OSX/GHC nice and stable most of the week.  It's possible I"ll start hallucinating in lambda-expressions shortly. ;)
20:19:21 <NihilistDandy> Sounds good :D
20:19:38 <NihilistDandy> Luckily, everything seems hunky-dory on mine, so things should go well :D
20:19:41 <CodeWeaver> I'm too much of a noob to be obsessed this much with getting the $*&*&#^$ thing to wokr. ;)
20:19:43 <hydo> NihilistDandy: darcs get http://darcs.haskell.org/cabal-install/
20:19:49 <CodeWeaver> typo only slightly unintentional.
20:19:50 <luite> hmm, it just works fine here
20:19:52 <luite> with xcode 4.1
20:19:52 <NihilistDandy> Ah, there's the problem
20:19:59 <hydo> ahoy
20:20:06 <CodeWeaver> 4 minutes
20:20:14 <NihilistDandy> hydo: darcs get http://darcs.haskell.org/cabal/
20:20:28 <NihilistDandy> cabal-install is now a part of the Cabal repo
20:21:11 <hydo> NihilistDandy: woo haa!  ok, trying that.
20:22:36 <CodeWeaver> xcode 4.2 alright, ND?
20:23:07 <NihilistDandy> Yup
20:23:10 <NihilistDandy> That's what I'm on
20:23:10 <CodeWeaver> *nods*
20:23:27 <CodeWeaver> I had trouble with 4.2 on building some things,  Strange hangs and segfaults.  Went back to 4.1 for a while.
20:23:41 <CodeWeaver> But 4.2's already ready
20:23:54 <CodeWeaver> Expanding.
20:23:58 <NihilistDandy> Coolo
20:24:24 <CodeWeaver> Appreciate the help.  I'm hoping a clean install of xcode4.2, plus ghc7.4 plus clang/llvm will work happily.
20:24:42 <CodeWeaver> Okay, expanded.
20:24:59 <nyingen> @quote
20:24:59 <lambdabot> RasmusLerdorf says: "I don't know how to stop it [PHP], there was never any intend to write a programming language [...] I have absolutely no idea how to write a programming language, I just kept
20:24:59 <lambdabot> adding the next logical step on the way."
20:25:02 <hydo> I may have to clean install 4.2 as well.  Got the lovely "inconsistent state - press this to crash now" message when starting xcode.
20:25:04 <NihilistDandy> cd into the directory and `./configure --prefix={whatever or skip it for /usr/local} --use-gmp-includes=/opt/local/include --use-gmp-libraries=/opt/local/lib`
20:25:34 <NihilistDandy> hydo: Yeesh. That doesn't sound good :/
20:26:04 <hydo> NihilistDandy: aw well, I'll just uninstall or rm -rf /Developer and install again.
20:26:25 <hydo> or I'll try once again to get freebsd on this macbook.  haven't tried 9 yet.
20:26:46 <hydo> done enough yak shaving at work for the day.
20:26:49 <CodeWeaver> Why the gmp settings?  What happens if they're left out?
20:27:10 <hydo> sup, shapr
20:27:11 <CodeWeaver> Wait… configure iddn't like those.
20:27:21 <hydo> by god, NihilistDandy, you're the bomb.com
20:27:25 <NihilistDandy> :)
20:27:28 <NihilistDandy> Thanks :D
20:27:30 <hydo> success!
20:27:33 <NihilistDandy> CodeWeaver: What does it say?
20:27:34 <CodeWeaver> ND, configure didn't like the gmp flags.
20:27:44 <CodeWeaver> unrecognized option
20:27:58 <NihilistDandy> ./configure --help
20:27:59 <hydo> I'm gonna tattoo that darcs url on my eyelids or something.
20:28:08 <NihilistDandy> I'm pretty sure that's what the flags are called
20:28:09 <CodeWeaver> Yup, I got the help.
20:28:16 <NihilistDandy> They're at the bottom
20:28:16 <CodeWeaver> with, not use
20:28:19 <NihilistDandy> Ah
20:28:20 <NihilistDandy> Derp
20:28:22 <NihilistDandy> My bad
20:28:34 <CodeWeaver> So what happens if they're left out?
20:28:41 <NihilistDandy> It uses the shitty native gmp
20:28:42 <CodeWeaver> Trying to learn the nuances here.
20:28:45 <CodeWeaver> Okay.
20:28:53 <NihilistDandy> The new version of gmp is much faster
20:29:00 <hydo> blackdog: who are you on twit?  I'll put it up tonight if you want to mess with it.  It's kinda ugly atm, but whatever.
20:29:04 <CodeWeaver> configuring.  Done.
20:29:11 <NihilistDandy> Now just make install
20:29:24 <CodeWeaver> I'll need a sudo. :D
20:29:35 <CodeWeaver> sudo make me a sandwich
20:29:40 <NihilistDandy> blah, sudo is evil :D
20:29:45 <hydo> first things first on a new install.  "cabal install cabal-dev"
20:29:47 <NihilistDandy> I always install GHC to ~
20:29:47 <CodeWeaver> It complained otherwise.
20:29:50 <CodeWeaver> Ah.
20:29:51 <CodeWeaver> Well.
20:29:52 <pikhq> ln -s `which sudo` ./%s
20:30:04 <NihilistDandy> --prefix=/Users/{name}/GHC
20:30:08 <CodeWeaver> wait, waht?  It's done?
20:30:10 <randi> hey guys would any of you know why "abs minBound" returns a negative number? seems like a ghci bug
20:30:12 <CodeWeaver> *blink*
20:30:26 <CodeWeaver> Great googly moogly
20:30:28 <CodeWeaver> That was fast.
20:30:36 <NihilistDandy> Yup
20:30:48 <CodeWeaver> Okay, cabal didn't get upgraded.
20:30:53 <CodeWeaver> I presume that's the next step?
20:30:53 <tikhonjelvis> randi: It probably uses twos-complement
20:31:06 <parcs`> > [minBound, maxBound] :: [Int]
20:31:07 <lambdabot>   [-9223372036854775808,9223372036854775807]
20:31:12 <NihilistDandy> CodeWeaver: What do you get when you type ghc --version?
20:31:30 <parcs`> > [minBound, maxBound, maxBound + 1] :: [Int]
20:31:31 <lambdabot>   [-9223372036854775808,9223372036854775807,-9223372036854775808]
20:31:40 <randi> 7.0.3
20:31:42 <CodeWeaver> 7.4.1, ND
20:31:46 <parcs`> randi: due to the way ints are encoded
20:31:53 <CodeWeaver> Cabal reports the same as before though
20:32:02 <NihilistDandy> That'll be fixed in just a moment
20:32:06 <CodeWeaver> woot
20:32:14 <NihilistDandy> If you ghc-pkg list, you'll see the new Cabal lib
20:32:14 <tikhonjelvis> To negate a number you flip all the bits and add one.
20:33:03 <tikhonjelvis> The smallest negative number is a 1 followed by a bunch of 0s.
20:33:08 <NihilistDandy> Next you want to `darcs get http://darcs.haskell.org/cabal/`
20:33:24 <tikhonjelvis> So to negate it, you first get 0 followed by a bunch of ones and then add one.
20:33:28 <hydo> yea, and *not* the one listed on the cabal-install hackage page.
20:33:29 <tikhonjelvis> Then you get the same number back.
20:33:33 <randi> thats the thing... the function should report the correct thing for abs
20:33:35 <NihilistDandy> That'll get you the latest version of cabal-install, but you'll want to patch the bootstrap.sh in a few places
20:33:39 <hydo> important point, that.
20:33:50 <tikhonjelvis> It is "correct" in the sense that that's how bounded integers behave.
20:34:09 <CodeWeaver> Moment.
20:34:21 <tikhonjelvis> You can't represent the positive version of minBound as a bounded integer of the same size.
20:34:37 <tikhonjelvis> If you want mathematical correctness, use Integer.
20:34:49 <randi> tikhonjelvis: ok cool...
20:34:52 <CodeWeaver> Copying.
20:35:20 <tikhonjelvis> Two's complement sounds weird, but it actually makes sense.
20:35:32 <CodeWeaver> I really appreciate this ND.  I'll likely have other questions, if and when I can track you down. ;)
20:35:57 <CodeWeaver> Terribly cool language.  Terribly frustrating invisible brick walls.
20:36:19 <NihilistDandy> :D
20:36:21 <NihilistDandy> True
20:36:30 <NihilistDandy> The new version's surprisingly helpful, though
20:36:41 <NihilistDandy> Great new error messages :D
20:37:08 <CodeWeaver> And I'm… not practiced at the art of makefile level project management.  My decades in the industry have been sadly padded.  Despite my delight in majikal hacquery.
20:37:30 <CodeWeaver> So this is good.
20:37:35 <CodeWeaver> Yay!  Gotten
20:37:48 * hackagebot exact-combinatorics 0.2.0 - Efficient exact computation of combinatoric functions.  http://hackage.haskell.org/package/exact-combinatorics-0.2.0 (WrenThornton)
20:37:48 <olivers> hello all
20:38:00 <NihilistDandy> Awesome. Now cd to cabal/cabal-install
20:38:14 <NihilistDandy> And open up bootstrap.sh in your editor of choice
20:38:41 <CodeWeaver> If it's a few small changes, I can pop it open in vi.
20:38:54 <NihilistDandy> It's just a few lines
20:38:55 <CodeWeaver> Open.
20:39:25 <NihilistDandy> Okay, near the top, there's a section full of environment variables
20:39:30 <CodeWeaver> Yup
20:39:47 <NihilistDandy> There's one called EXTRA_CONFIGURE_OPTS
20:39:52 <CodeWeaver> yup
20:39:55 <NihilistDandy> Uncomment the line and make it say `EXTRA_CONFIGURE_OPTS="-p"`
20:40:03 <NihilistDandy> That'll build profiling libs
20:40:07 <CodeWeaver> ah HAH.
20:40:10 <CodeWeaver> Good.
20:40:20 <CodeWeaver> Wait, isn't that normally in the ~/.cabal/config file?
20:40:36 <NihilistDandy> Yeah, but bootstrap doesn't consult with that
20:40:38 <NihilistDandy> Sadly
20:40:38 <CodeWeaver> done.
20:40:40 <NihilistDandy> I wish it did
20:40:58 <NihilistDandy> Then, if you're a doc fiend like I am, you'll want to generate haddock docs for the packages the bootstrapper will install
20:41:00 <CodeWeaver> Out of curiousity, will we be using the llvm for this?
20:41:07 <CodeWeaver> Okay, I'm happy to try it.
20:41:26 <NihilistDandy> By default, I think it'll be using llvm, yes
20:41:41 <CodeWeaver> I recall in 7.2.2 fighting to get it to use the llvm.
20:41:44 <CodeWeaver> Anyway.
20:41:56 <NihilistDandy> In vi, just /Setup build and add the following lines after that
20:42:09 <CodeWeaver> Found it
20:42:18 <NihilistDandy> ./Setup haddock ${VERBOSE} \
20:42:18 <NihilistDandy>     || die "Haddocking the ${PKG} package failed"
20:42:56 <CodeWeaver> okay so far
20:43:29 <NihilistDandy> And that's it
20:43:41 <NihilistDandy> Then you just sh bootstrap.sh and you should be all good
20:43:53 <CodeWeaver> okay, building
20:44:09 <olivers> I am a bit rusty with programming. (4 years ago i used to program in c). I don't program for a living anymore. My interests like more in finance which is also my career now. I am looking to develop an opensource technical anaysis software for the stocks. I am also starting with haskell. Is haskell a good "fit" for this ? I know that haskell is great for the real time calculations and quick
20:44:10 <olivers> coding of analysis tools. However I also need a strong gui platform. Something which will allow drawing of trendlines and adjusting trendlines etc. The gui part will be the initial focus and then I will move onto the stratergies part after there is a decent chart to work with. I have looked at wxhaskell. I will appreciate any pointers. Thanks.
20:44:14 <CodeWeaver> *twiddles fingers*
20:44:39 <NihilistDandy> All should go well
20:44:52 <CodeWeaver> I've heard that before. ;)
20:45:02 <CodeWeaver> Sometimes even from me.
20:45:04 <tikhonjelvis> olivers: You have two broad GUI options in Haskell: traditional, imperative bindings and FRP.
20:45:37 <NihilistDandy> CodeWeaver: Well, unless the impossible happens~
20:45:38 <tikhonjelvis> olivers: You can also mix and match the two approaches.
20:45:50 <NihilistDandy> I really wanna get into FRP
20:45:52 <CodeWeaver> I did six impossible things this morning.  So.
20:45:53 <NihilistDandy> Looks so coo
20:45:55 <NihilistDandy> *cool
20:46:04 <NihilistDandy> CodeWeaver: Proud of you~
20:46:07 <tikhonjelvis> NihilistDandy: Me too, but wxcore won't build :(
20:46:26 <NihilistDandy> Aww
20:46:31 <olivers> tikhonjelvis which of the two is more flexible. I don't mind putting in extra effort.
20:46:53 <CodeWeaver> I had trouble getting wxWidgets working on OSX lately… I think they're making a mad dash to do some major upgrades, lately, so I'm waiting, but…  very annoying.
20:47:03 <CodeWeaver> I quite liked my minor experiments with it about a year ago.
20:47:11 <CodeWeaver> Oh well, one crisis at a time.
20:47:15 <tikhonjelvis> olivers: Well, you can actually mix and match them. From what I've heard, FRP leads to more elegant and easier to read code but is a little bit more difficult to wrap your head around.
20:47:20 <NihilistDandy> I'm thinking about taking a crack at some Cocoa bindings
20:47:26 <NihilistDandy> That's what I really want
20:47:30 <CodeWeaver> Interesting
20:47:41 <tikhonjelvis> I'd look at what the code looks like in the two cases and see what you like more.
20:47:49 <CodeWeaver> I should get my friend who's into GUI stuff to dig into haskell/GUI buidings.
20:48:00 <NihilistDandy> Definitely
20:48:02 <CodeWeaver> Except he's a hardcore OOP guy.  Doesn't stray far from the path.
20:48:13 <CodeWeaver> I'm slowly melting his noggin.
20:48:22 <NihilistDandy> Show him Agda :D
20:48:25 <CodeWeaver> Right.  Seems to have finished.
20:48:30 <NihilistDandy> Awesome
20:48:40 <NihilistDandy> Now cabal --version and let me know what it says :D
20:48:48 <olivers> thanks tikhonjelvis I will look around. Is wxhaskell better or the gtk bindings ?
20:48:55 <CodeWeaver> 0.10.4, but I think the old one's in my path somewhere.
20:49:25 <NihilistDandy> How about ~/.cabal/bin/cabal --version?
20:49:25 <tikhonjelvis> olivers: I think wxhaskell is a better option, but I haven't used either one.
20:49:41 <tikhonjelvis> olivers: On Linux, wxhaskell uses GTk as the backend anyhow.
20:49:41 <CodeWeaver> Ah hah, 0.13.3
20:49:45 <NihilistDandy> :D
20:49:49 <NihilistDandy> Success!
20:49:49 <CodeWeaver> Gotta find the old one and crush it or I'm in trouble.
20:49:59 <olivers> ah k. thanks tikhonjelvis
20:50:04 <NihilistDandy> CodeWeaver: Just which cabal and see what it says
20:50:13 <NihilistDandy> That'll tell you quick
20:50:36 <CodeWeaver> Actually, it says the one in .cabal, but it's clearly not running that one.
20:50:43 <CodeWeaver> I think its running one in /usr/local/bin
20:50:46 <tikhonjelvis> olivers: If you don't have much existing GUI development experience, learning FRP off the bat might be a pretty good option, come to think of it.
20:51:08 <NihilistDandy> CodeWeaver: Are you using homebrew?
20:51:12 <NihilistDandy> Oh, wait, no
20:51:12 <CodeWeaver> interesting, I had to close my terminal window and reopen it.
20:51:14 <NihilistDandy> ports
20:51:25 <NihilistDandy> Oh, good
20:51:25 <CodeWeaver> Now it's there, and reporting properly.
20:51:29 <NihilistDandy> Sweet!
20:51:41 <CodeWeaver> At this point, any recommendations for not shooting myself in the foot?
20:52:12 <NihilistDandy> Hmm. Well, install alex right now. That'll work no problem
20:52:16 <NihilistDandy> Oh, wait
20:52:22 <CodeWeaver> happy
20:52:22 <NihilistDandy> What's your cabal config like?
20:52:45 <CodeWeaver> the two profiling lines are True, but everything else is default.
20:52:56 <CodeWeaver> Its the cabal file I had from 0.10
20:53:12 <CodeWeaver> Probably should do a cabal update, what?
20:53:38 <CodeWeaver> Oh, and I guess documentation: True in there?
20:54:10 <NihilistDandy> Yup
20:54:27 <CodeWeaver> Updating
20:54:27 <NihilistDandy> I'd also recommend against executable-profiling, but that's just because I occasionally hit issues with it
20:54:38 <NihilistDandy> Oh, and probably put a True on executable-stripping
20:54:40 <CodeWeaver> issues?
20:54:44 <NihilistDandy> That'll save a little space
20:54:49 <CodeWeaver> Its by default on isn't it?
20:54:54 <NihilistDandy> Things just wouldn't build. But that was back on 7.0.4.
20:54:54 <CodeWeaver> It was in my old file anyway
20:55:13 <NihilistDandy> I dunno. I think it had nothing my default, but whatever :D
20:55:36 <CodeWeaver> Set up.  I'll try a test build.
20:55:48 <olivers> tikhonjelvis http://www.haskell.org/haskellwiki/Functional_Reactive_Programming#Libraries
20:55:53 <olivers> I was looking into this.
20:56:01 <tikhonjelvis> I think reactive-banana is the best option.
20:56:01 <olivers> It looks good.
20:56:21 <NihilistDandy> CodeWeaver: I'd recommend alex and happy upfront, but cabal alex and then grab the source for happy off hackage
20:56:26 <NihilistDandy> And I'll tell you how to patch it
20:56:32 <NihilistDandy> It's just one line
20:56:32 <CodeWeaver> Right, good call.
20:57:38 <CodeWeaver> Hopefully this really is using the llvm.  on 7.2.2 I got a test program to build under the default compiler, and then later under LLVM, and the speedup was enormous.
20:57:57 <CodeWeaver> Alex seems happy so far.  Building
20:58:49 <CodeWeaver> Right, okay… alex done.  I'll grab happy
20:59:17 <NihilistDandy> Awesome
20:59:25 <CodeWeaver> wait, where is it?  hackage seems to have 1.18.8… is there a darcs repo for it?
20:59:42 <CodeWeaver> Oh I have to cabal unpack it
20:59:43 <CodeWeaver> Hang on
21:00:04 <CodeWeaver> I'm in.
21:00:09 <CodeWeaver> What's the change?
21:00:48 <NihilistDandy> Ah, okay
21:01:18 <NihilistDandy> So, open up src/Lexer.lhs
21:01:27 <CodeWeaver> Done
21:01:56 <NihilistDandy> Then /lexReadCode twice to get to its declaration
21:02:05 <Sgeo> Will she be rewritten to use compiler plugins?
21:02:07 <CodeWeaver> Yup
21:02:16 <NihilistDandy> Then change the type constraint to (Num a, Eq a)
21:02:22 <NihilistDandy> Instead of just Num a
21:02:27 <CodeWeaver> Ahhh, the change in the Num class
21:02:30 <CodeWeaver> interesting
21:02:31 <NihilistDandy> Yup
21:02:42 <CodeWeaver> I'll have to watch out for that in other packages.   How would the error manifest itself?
21:02:56 <NihilistDandy> You'll get a big helpful error :D
21:03:05 <CodeWeaver> I'm sure I will :D
21:03:06 <olivers> tikhonjelvis I was thinking of a second approach as well. A something like a webservice with a haskell backend. http://bigcharts.marketwatch.com/interchart/interchart.asp?symb=djia&insttype=&time=8&freq=1 (An example chart). Is that a good idea or a desktop application is better ?
21:03:09 <CodeWeaver> That it?
21:03:53 <NihilistDandy> Yup
21:03:57 <CodeWeaver> installing
21:03:59 <tikhonjelvis> olivers: I think the webservice is actually better. I had thought about suggesting it, but assumed you wanted a native program.
21:04:25 <CodeWeaver> I do keep getting this warning about documentation:  "Warning: No documentation was generated as this package does not contain a
21:04:26 <CodeWeaver> library. Perhaps you want to use the --executables flag."
21:04:26 <tikhonjelvis> Of course, I'm naturally biased because I have done more web development than native GUI development :)
21:05:05 <CodeWeaver> Alright, anything else I should know about?  I'm going to keep this chatlog around in case I can help out other people.  hopefully I don't hit unexpected snags.
21:05:36 <CodeWeaver> I'm going to *try* to get the various EclipseFP support tools built via cabal tonight.  This should be all kinds of merry fun.
21:05:41 <NihilistDandy> Nothing comes to mind, unless you want to use Agda
21:05:50 <NihilistDandy> Then you just need to grab the darcs repo
21:05:51 <CodeWeaver> I don't know about Agda.  What is?
21:05:56 <NihilistDandy> Oh, that's the other thing
21:06:07 <NihilistDandy> Use darcs to get the darcs darcs repo :D
21:06:13 <tikhonjelvis> It's dependently typed. That's all you need to know :)
21:06:21 <NihilistDandy> Agda's a theorem prover and dependently typed language
21:06:24 <NihilistDandy> It's awesome :D
21:06:40 <CodeWeaver> oh darn, that sounds… like it could melt my brain.  Excellent.  I'll look into it.
21:06:49 <CodeWeaver> Should I be darcsing darc immediately?
21:06:51 <tikhonjelvis> Would a (simpler) dependently typed language be reasonable to implement?
21:06:57 <CodeWeaver> darc seems to be working alright. :D
21:07:41 <NihilistDandy> Just if you want all the new toys :D
21:07:53 <NihilistDandy> tikhonjelvis: I dunno. Agda's not too bad
21:07:58 <CodeWeaver> I'm not sure what that even means, but I'll see if I can darc the darc.  Hang on.
21:08:06 <olivers> tikhonjelvis thanks. I will look into the web app idea as well.
21:08:17 <CodeWeaver> holy crap, 7.4.4 got all the way through building cmdargs without whining.
21:08:21 <CodeWeaver> errr, 7.4.1
21:08:28 <CodeWeaver> O.o
21:08:31 <NihilistDandy> Whoop
21:08:40 <NihilistDandy> Wish I could get it to build pandoc, though :/
21:08:44 <CodeWeaver> :/
21:08:51 <CodeWeaver> If I get good enough at this I'll come help ya out.
21:09:05 <tikhonjelvis> The final project for my programming language class is to build a language, and I want to do something exciting for it.
21:09:07 <NihilistDandy> Ambiguous occurence of <>. I've been trying to figure it out, but nothing's working :/
21:09:27 <NihilistDandy> tikhonjelvis: Hardware description language on the type level!
21:09:29 <NihilistDandy> :D
21:09:45 <Sgeo> :t (<>)
21:09:45 <lambdabot> Doc -> Doc -> Doc
21:09:48 <Sgeo> !
21:09:54 <tikhonjelvis> Doesn't a haskell-like hardware description language already exist?
21:10:07 * Sgeo slaps lambdabot for not magically knowing the new stuff in GHC 7.4
21:10:14 <CodeWeaver> Right, then.  Do you drop by here often ND?  I don't recall talking to you before.  Mind you I'm new.
21:10:23 <NihilistDandy> I drift in and out
21:10:28 <NihilistDandy> I'm pretty new, really
21:10:34 <NihilistDandy> Though I've been around here for about a year
21:10:37 <CodeWeaver> Okay, well, hopefully I'll spot you if I get stuck.
21:10:46 <NihilistDandy> You can email me, if you like
21:10:59 <CodeWeaver> That would be great.  I promise not to abuse the priviledge.
21:11:06 <NihilistDandy> Either NihilistDandy@gmail.com or I can query you my university email
21:11:11 <NihilistDandy> Whatever's good
21:11:19 <CodeWeaver> Fabulous.  I'll send an introductory email shortly.
21:11:41 <CodeWeaver> out of curiousity, what do *you* use as your source editor?
21:11:53 <NihilistDandy> Emacs, of course :D
21:11:54 <CodeWeaver> or project environment if you have one?
21:11:55 <tikhonjelvis> yay
21:11:56 <CodeWeaver> Ah!
21:11:57 <CodeWeaver> heehee
21:12:00 <tikhonjelvis> I approve. A lot.
21:12:01 <kfish> for some reason i thought EitherNihilistDandy was a new ghc extension
21:12:02 <CodeWeaver> I'm… not emacs familiar.
21:12:10 <NihilistDandy> Cocoa emacs is awesome
21:12:18 <CodeWeaver> I may give it a shot.
21:12:19 <NihilistDandy> Especially with the emacs prelude
21:12:38 <tikhonjelvis> Do you use scion (or whatever it's called)?
21:13:55 <CodeWeaver> But I still want to get this Eclipse plugin to work.  I've started down that road, and I think its a noble attempt at an interactive IDE for haskell.
21:14:02 <NihilistDandy> I just installed ghc-mod. I haven't actually tried scion, yet
21:14:09 <tikhonjelvis> CodeWeaver: Have you tried Leksah?
21:14:28 <CodeWeaver> Yes, tik, but I can't get it to build, well as of 7.2.2 anyway, and the binary just crashes on me with any real use.
21:14:32 <CodeWeaver> Don't know why.
21:14:40 <NihilistDandy> brb
21:14:42 <tikhonjelvis> Ooh, can't help you. I'm too coddled by my package manager :)
21:14:45 <CodeWeaver> I did use it about a year ago and it was great.
21:14:55 <CodeWeaver> Love that it was written in haskell.  I may fix that next. :D
21:15:06 <tikhonjelvis> Heh, ironically, I didn't like it very much. So I'm the one who has no problems with it :)
21:15:24 <CodeWeaver> Go fig.  I *also* should point out that I didn't play with it *much*.
21:15:37 <Sgeo> Does EclipseFP just fail if ~/.cabal/bin isn't in the PATH?
21:15:57 <Sgeo> If that's why EclipseFP has been failing on me, I'll be ticked at myself.
21:16:48 <CodeWeaver> That may be one reason, Sgeo.  What platform?  I'm helping ferret out bugs on OSX, but I don't know if there's hiccups on other platforms.
21:17:08 <Sgeo> CodeWeaver, Lubuntu something
21:17:11 <CodeWeaver> Mm.
21:17:12 <Sgeo> I have not tried 7.4
21:17:30 <CodeWeaver> I don't know if that will help with EclipseFP failing exactly.
21:17:54 <CodeWeaver> Huh, the new cabal seems to be handling itself more gracefully than the last one.
21:17:57 <CodeWeaver> That's a good sign.
21:18:07 * Sgeo tries Eclipse with the stuff on the path
21:18:15 <tikhonjelvis> What used to be the issue with Cabal?
21:19:46 <CodeWeaver> hey ND… I'm looking at a verbose version of cabal's output during building a package, and it appears the -fllvm flag for compiling using the llvm is *not* being issued.  So by default… I wonder if the llvm is actually being used, or if the -fllvm flag is necessary on OSX....
21:19:58 <CodeWeaver> …on 7.4.1… it was on 7.2.2
21:26:41 <Sgeo> Error loading local database
21:26:41 <Sgeo> incorrect header check
21:26:50 <Sgeo> Even with ~/.cabal/bin in the PATH
21:28:01 <ninor> anyone here do apple ios dev?
21:28:58 <tikhonjelvis> Are you thinking of using Haskell on iOS?
21:31:43 <CodeWeaver> Yes, I ahd a problem with that too, Sgeo, not sure what's going on.
21:33:34 <NihilistDandy> Back
21:33:52 <CodeWeaver> ND, asked a question back there somwhere.
21:33:56 <NihilistDandy> Noticed
21:34:18 <NihilistDandy> CodeWeaver: I think I was digging through something and it mentioned that LLVM produced slower code with 7.4.1
21:34:25 <CodeWeaver> Also… trying to build buildwrapper, but a TypeRep doesn't support Pred… this is new.  Something changed in base regarding that?
21:34:30 <NihilistDandy> So they use gcc-4.2 where available
21:34:40 <CodeWeaver> Hmmm.
21:34:41 <NihilistDandy> But I'm not sure that Xcode 4.2 has that, so it may just default to LLVM
21:34:50 <NihilistDandy> So the flag would be unnecessary
21:34:52 <CodeWeaver> Well, it doesn't come in the command line, so… who knows.
21:34:53 <CodeWeaver> Right.
21:34:54 <CodeWeaver> Okay.
21:34:59 <CodeWeaver> Comment on the TypeRep thing?
21:35:11 <CodeWeaver> I know its not strictly OSX. ;)
21:35:18 <NihilistDandy> TypeRep?
21:35:21 <NihilistDandy> I missed that one
21:35:33 <CodeWeaver> Also… trying to build buildwrapper, but a TypeRep doesn't support Pred… this is new.  Something changed in base regarding that?
21:36:13 <NihilistDandy> Building now. I'll let you know if I see anything helpful
21:36:49 <CodeWeaver> Oh, didn't expect you to do that.  I had to grab the repostory versions as its definitely bleeding edge right now.
21:37:48 <CodeWeaver> Doesn't export, not doesn't support.
21:37:49 * hackagebot socks 0.4.1 - Socks proxy (version 5) implementation.  http://hackage.haskell.org/package/socks-0.4.1 (VincentHanquez)
21:38:14 <NihilistDandy> hmm
21:38:58 <gienah> buildwrapper is likely to be difficult to build with ghc 7.4.1 as it uses ghc api
21:39:15 <CodeWeaver> Possibly true.
21:39:23 <CodeWeaver> I may be unable to pull this off.
21:39:36 <CodeWeaver> Which means backgrading to help out with the project.  But we'll see.
21:40:22 <gienah> CodeWeaver: I think you could fix buildwrapper if are keen, just needs concentration and coffee :-)
21:40:58 <gienah> CodeWeaver: one window open with the old ghc api docs, another with the ghc 7.4.1 ghc api docs
21:41:05 <CodeWeaver> I may try.  I'm getting frustrated with my previous attempts getting weird segfaults, I think because my 7.2.2 builds got mangled somehow.
21:41:17 <CodeWeaver> gienah, noted.
21:42:09 <CodeWeaver> Okay, where would the docs for that be?  *digs into hackage*
21:42:31 <NihilistDandy> pandoc is proving annoying
21:42:43 <NihilistDandy> Ambiguous import that shouldn't be ambiguous :/
21:42:50 <CodeWeaver> ah hah.
21:43:25 <gienah> CodeWeaver: I guess you found them included with ghc
21:44:22 <CodeWeaver> Er, well, I found reference to them in the haskellwiki.
21:44:30 <CodeWeaver> And now I know a second place to go looking. ;)
21:45:27 <gienah> CodeWeaver: here are the old ones: http://www.haskell.org/ghc/docs/7.2.2/html/
21:45:39 <CodeWeaver> Oh, great, many thanks!
21:45:46 <CodeWeaver> *grins*
21:45:55 <CodeWeaver> I shall crush zis bug!
21:46:06 <CodeWeaver> Also, its sleepytime cause I'm getting a bit silly.
21:46:17 <gienah> CodeWeaver: awesome, here are the latest of course: http://www.haskell.org/ghc/docs/latest/html/
21:46:42 <CodeWeaver> Okay, excellent.  I'll try to get a handle on it.
21:46:48 <CodeWeaver> If nothing else, I'll learn loads.
21:47:03 <NihilistDandy> Yay!
21:47:06 <NihilistDandy> I fixed pandoc
21:47:33 <CodeWeaver> woohoo!
21:47:44 <NihilistDandy> Found the ambiguity and crushed it
21:47:45 <CodeWeaver> Okay.  my Tomorrow's task is fixing buildwrapper.
21:47:51 <CodeWeaver> crushed it like bug?
21:47:55 <NihilistDandy> Hell yeah
21:48:00 <CodeWeaver> win!
21:48:02 <NihilistDandy> I'll have to submit a pull request
21:48:06 <NihilistDandy> It's just a very small thing
21:48:26 <CodeWeaver> Thanks again, ND.  We'll no doubt talk soon.  Alright.  *fades*
21:48:37 <CodeWeaver> Also thanks again gienah
21:48:45 <NihilistDandy> Adios
21:49:40 <gienah> NihilistDandy: a trivial pandoc patch fyi: https://github.com/gentoo-haskell/gentoo-haskell/blob/master/app-text/pandoc/files/pandoc-1.8.2.1-ghc-7.4.patch
21:50:02 <NihilistDandy> gienah: I'm building 1.9
21:50:13 <NihilistDandy> But yes, that does do the trick :D
21:50:22 <gienah> NihilistDandy: ok, neat
21:50:22 <NihilistDandy> I just couldn't find the ambiguit immediately
21:50:29 <NihilistDandy> *ambiguity
21:50:41 <NihilistDandy> I just ended up adding a `hiding ((<>))` and it went perfectly
21:50:50 <NihilistDandy> Well, pandoc-types, anyway
21:51:11 <NihilistDandy> Ah, same problem in pandoc proper. Good. Patch time :D
21:51:15 <NihilistDandy> Thanks for the link, gienah
21:51:38 <gienah> NihilistDandy: no worries, thanks for helping out everyone that uses macos
21:52:24 <NihilistDandy> Haha, I try. It's just a bunch of trial and error on my end :D
21:53:20 <NihilistDandy> 7.4.1 is amazingly worry-free in most respects on OS X
21:53:31 <NihilistDandy> Much improved over the nightmare that was 7.0.4 at first
21:53:52 <NihilistDandy> Even 7.2 require an unpleasant amount of cabal hackery
21:54:31 <gienah> NihilistDandy: I notice OS X seems very popular, so makes sense that ghc 7.4.1 works better with people working on macos
21:55:20 <NihilistDandy> I just got a quad-core MacBook. GHC's been a dream :D
21:55:32 <gienah> NihilistDandy: cabal configure with the --verbose=3 option can sometimes give some hints on stuff
21:56:00 <NihilistDandy> Yeah. Usually it was pretty obvious stuff even without the verbosity. Just version numbers needing to be bumped for the most part
21:56:11 <NihilistDandy> The occasional patch, though
21:56:19 <NihilistDandy> I like it, though
21:56:24 <NihilistDandy> Feels like I'm contributing :D
21:57:30 <NihilistDandy> brb
21:58:21 <gienah> NihilistDandy: just a little story in case it helps: on gentoo there was a problem recently where happstack-server said it could not find the cryptocpp (crypto++) library, that was due to the NEEDED libraries section being incomplete
21:59:50 <gienah> NihilistDandy: on gentoo this command checks the library, maybe there is something similar on macos: ldd -r /usr/lib64/libcrypto++.so
22:00:49 <gienah> NihilistDandy: what that does is it prints out unresolved symbol errors if the NEEDED library list is incomplete - mentioning this in case it helps with your macosx stuff
22:11:52 <rudyl313> has anybody has experience using hoauth for oauth?
22:14:54 <WendyMackaye> !dict carbamate
22:22:36 <NihilistDandy> gienah: Good to know. I think they're all dylibs on OS X, but as far as I remember the principle is the same
22:38:28 <Guest63786> @pl (\x -> (++) (x ++ "+"))
22:38:28 <lambdabot> (++) . (++ "+")
22:39:50 <sipa> :t (+(3+4))
22:39:51 <lambdabot> forall a. (Num a) => a -> a
22:40:05 <sipa> :t (+3+4)
22:40:05 <lambdabot>     The operator `+' [infixl 6] of a section
22:40:06 <lambdabot>         must have lower precedence than that of the operand,
22:40:06 <lambdabot>           namely `+' [infixl 6]
22:56:37 <StepanKuzmin> Hi all!
22:57:11 <StepanKuzmin> How can I know what version of ghc is included in Haskell platform?
22:57:51 * hackagebot hastache 0.3.2 - Haskell implementation of Mustache templates  http://hackage.haskell.org/package/hastache-0.3.2 (SergeyLymar)
22:59:02 <strager> StepanKuzmin: ghc -V ?
22:59:06 <bbear> hey ya.
22:59:13 <bbear> That doesn't work
22:59:15 <bbear> removeNonUppercase st = [ c | c <- st, c `elem` ['A'..'Z']]
22:59:48 <bbear> It's in the Learnyouahaskell tutorial
23:00:12 <strager> What doesn't work about it?
23:01:13 <bbear> <interactive>:1:23: parse error on input `='
23:01:27 <mauke> bbear: so you didn't put it in a file
23:01:36 <Guest63786> @pl (\n a b -> n ++ "x" ++ b ++ "y" ++ a ++ "z")
23:01:36 <lambdabot> (. ((('x' :) .) . flip (++) . ('y' :) . (++ "z"))) . (.) . (++)
23:02:20 <StepanKuzmin> strager, can I know it without installing platform?
23:02:46 <bbear> mauke, what 's the distinction ?
23:02:50 <bbear> zip [1..] ["apple", "orange", "cherry", "mango"]
23:03:01 <bbear> works in the interactive mode but not in text file.
23:03:45 <mauke> bbear: http://learnyouahaskell.com/starting-out#an-intro-to-lists
23:04:07 <bbear> that strange that one  cannot do a=1 ; a=2
23:04:24 <bbear> So when a variable is assignated , one cannot change it's value :o
23:04:34 <bbear> I suppose that enforces the use of the functionnal paradigm.
23:05:05 <mm_freak> StepanKuzmin: http://hackage.haskell.org/platform/contents.html
23:05:10 <bbear> mauke, yeah I saw that in the tutorial when interactive mode is used it's underlined out in the example.
23:05:12 <bbear> Thanks.
23:05:40 <StepanKuzmin> mm_freak: thanks!
23:07:22 <Guest63786> @pl (\n a b -> n ++ "x" ++ a ++ "y" ++ b ++ "z")
23:07:22 <lambdabot> (. ((('x' :) .) . (. (('y' :) . (++ "z"))) . (++))) . (.) . (++)
23:07:51 <bbear> Is it type inference in Haskell ?
23:08:09 <bbear> Actually I wonder why one needs to write this : lucky :: (Integral a) => a -> String
23:08:14 <bbear> any idea ?
23:08:41 <mauke> why do you think you need to write that?
23:08:48 <mm_freak> bbear: that version of "lucky" works for Int, Integer, Word, Word32, …
23:09:19 <strager> 02:57 < bbear> <interactive>:1:23: parse error on input `='
23:09:28 <strager> When binding a name in GHCi you should use let.
23:09:35 <strager> Prelude> let removeNonUppercase st = [ c | c <- st, c `elem` ['A'..'Z']]
23:09:35 <strager> Prelude> removeNonUppercase "aASDfdfdfkdjfifDF2443"
23:09:35 <strager> "ASDDF"
23:09:46 <mm_freak> bbear: but you are free to give a more specific type like Integer -> String
23:09:50 <strager> 03:04 < bbear> Actually I wonder why one needs to write this : lucky :: (Integral a) => a -> String
23:10:10 <strager> Documentation, and sometimes it lets the function be polymorphic.
23:10:23 <mauke> strager: yes, that's what the page I linked to says
23:10:56 <erg> is dons still around much?
23:10:58 <bbear> strager, if one would write a polymorphic function, shouldn't it be
23:11:25 <bbear> What does the Integral keyword stands for ?
23:12:58 <mauke> bbear: do you actually read the words in the tutorial?
23:13:11 <mauke> 'lucky' is from chapter 4
23:13:18 <mauke> typeclasses are explained in chapter 3
23:14:03 <mauke> as are type signatures
23:14:45 <bbear> mauke, I type code examples and ask questions or IRC :p
23:15:01 <mauke> this is not a productive use of my time
23:16:04 <mm_freak> bbear: you won't learn haskell that way
23:16:18 <mm_freak> unlike most other languages, haskell /requires/ some understanding of what you are doing
23:16:33 <strager> bbear: Integral is a typeclass.  It's pretty basic Haskell; go read a Haskell tutorial or book as mauke is saying.
23:17:24 <mauke> strager: I'm not saying "read a tutorial"
23:17:49 <mauke> strager: bbear is complaining about example code in Learn You A Haskell not working
23:18:08 <mauke> I'm saying "read the words in Learn You A Haskell"
23:18:25 <strager> "read the tutorial" then ;P
23:18:41 <mauke> and now I'm adding: don't skip from chapter 1 (which you didn't read) to example code in chapter 4 (which you didn't read) that uses features explained in chapter 3 (which you didn't read)
23:18:48 <bbear> actually I would like another tutorial because this is a bit too "baby step tutorial styleb"
23:18:55 <bbear> I read chapter 1,2, etc.
23:18:59 <mauke> no, you didn't
23:19:04 <bbear> I just skiped the last 2 chapters 3 and 4
23:19:11 <bbear> I know about tuple , lists.
23:19:11 <mauke> no, you didn't
23:19:24 <mauke> you didn't know about 'let'
23:19:34 <mm_freak> bbear: don't skip anything
23:19:37 <bbear> Why ? I was stuck with the "let" keyword two days ago, I found the answer by myself.
23:19:44 <mauke> and you didn't skip chapter 4 because that's where 'lucky' is from
23:19:47 <bbear> I am just no well awakened this morning.
23:19:47 <mm_freak> even if you are fluent in other languages
23:19:58 <zomg> bbear: just read it entirely, even if you have used other languages before I promise you will totally get lost if you start skipping that stuff :P
23:20:16 <zomg> Haskell is insane like that so you need to know what all the pills it takes do
23:20:18 <zomg> =)
23:20:31 <bbear> Learn you is not very concise. zomg yeah I know what you mean not being able to read one liner programs.
23:20:41 <arcatan> bbear: Real World Haskell is more fast-paced and practical introduction to Haskell, if that suits you better that LYAH.
23:20:51 <antonh> There are no shortcuts to the perfect sound.
23:20:58 <zomg> antonh: except monster cables
23:21:07 <bbear> antonh, yeah. arcatan thank you
23:21:39 <CodeWeaver> ls
23:21:53 <mauke> bbear: while reading chapters 1 and 2 you apparently also missed the parts where it repeatedly tells you to put some definitions in a file and load them with :l
23:22:52 * hackagebot dph-base 0.6.0.1 - Data Parallel Haskell common config and debugging functions.  http://hackage.haskell.org/package/dph-base-0.6.0.1 (BenLippmeier)
23:22:54 * hackagebot dph-prim-interface 0.6.0.1 - Data Parallel Haskell segmented arrays. (abstract interface)  http://hackage.haskell.org/package/dph-prim-interface-0.6.0.1 (BenLippmeier)
23:23:27 <bbear> mauke, I did.
23:23:38 <bbear> Want to see my baby.hs ?
23:23:57 <mauke> no, thanks
23:24:54 <bbear> but thank you for your attention.
23:26:45 <bbear> See you later.
23:26:54 <QinGW> when I use cabal install hare, it report  "cannot configure HaRe-0.6.0.1. It requires base >4 && <=4.2.0.2", I have intalled haskell platform 2011.2 with ghc 7.0.4.
23:27:29 <gienah> QinGW: you could try hacking the cabal file
23:27:56 * hackagebot dph-prim-seq 0.6.0.1 - Data Parallel Haskell segmented arrays. (sequential implementation)  http://hackage.haskell.org/package/dph-prim-seq-0.6.0.1 (BenLippmeier)
23:27:58 * hackagebot dph-prim-par 0.6.0.1 - Data Parallel Haskell segmented arrays. (production version)  http://hackage.haskell.org/package/dph-prim-par-0.6.0.1 (BenLippmeier)
23:28:00 * hackagebot dph-lifted-base 0.6.0.1 - Data Parallel Haskell common definitions used by other dph-lifted packages.  http://hackage.haskell.org/package/dph-lifted-base-0.6.0.1 (BenLippmeier)
23:28:02 * hackagebot dph-lifted-vseg 0.6.0.1 - Data Parallel Haskell lifted array combinators.  http://hackage.haskell.org/package/dph-lifted-vseg-0.6.0.1 (BenLippmeier)
23:29:30 <QinGW> gienah: Thanks, I will try.
23:30:01 <QinGW> get source first.
23:32:52 * hackagebot dph-lifted-vseg 0.6.0.2 - Data Parallel Haskell lifted array combinators.  http://hackage.haskell.org/package/dph-lifted-vseg-0.6.0.2 (BenLippmeier)
23:36:34 <sm> 7.4.1 doesn't seem to like apple's libiconv on os x snow leopard.. the extra-lib-path is specified but Unable to link against the iconv library.
23:37:54 * hackagebot dph-examples 0.6.0.1 - Data Parallel Haskell example programs.  http://hackage.haskell.org/package/dph-examples-0.6.0.1 (BenLippmeier)
23:37:59 <sm> I can't install haskeline (unless I put macports libiconv first in the path, but then linking fails as expected)
23:39:06 <gienah> sm: you might be able to obtain more information by trying: runghc ./Setup.hs configure --verbose=3
23:39:37 <gienah> sm: or maybe cabal-install has a --verbose=3 option (not sure)
23:42:35 <sm> it does, here's the failure: https://gist.github.com/1729092
23:46:02 <Blkt> good morning everyone
23:47:52 * hackagebot dph-examples 0.6.0.2 - Data Parallel Haskell example programs.  http://hackage.haskell.org/package/dph-examples-0.6.0.2 (BenLippmeier)
23:49:45 <dca`> what is the contradiction symbol in math logic?
23:50:06 <opqdonut> there are various
23:50:23 <opqdonut> _|_ is one
23:50:41 <opqdonut> but it actually means falsity
23:50:45 <dca`> yeah
23:51:55 <opqdonut> in more informal contexts I've seen a lightning symbol and > and < overlayed in a #-like pattern
23:55:42 <sm> hmm, my gcc is 4.2.1 but xcode looks like 3.2.6, not 4.1 as ghc recommends
23:56:37 <sm> and of course this is snow leopard, not lion which ghc download page talks about
23:56:51 <dca`> i've recalled: ↯ can be used for contradiction
23:59:34 <danr> What is this about? "There is a new extension TraditionalRecordSyntax which is on by default. When turned off, the standard Haskell record syntax cannot be used. "
