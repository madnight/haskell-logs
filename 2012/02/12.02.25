00:00:49 <ddarius> Really augur is using an undefined notion of "case" and a non-standard notion of "constructor."
00:00:57 <augur> er, no
00:01:04 <augur> thats not what is at issue here at all
00:01:16 <augur> what's at issue is whether or not Maybe (NotInfinite a) counts as "recursing on NotInfinite a"
00:01:19 <augur> which it doesn't
00:01:26 <nanothief> I think we have different definitions on what makes up a resursive constructor
00:01:34 <augur> the argument to the constructor is not of type NotInfinite a
00:01:44 <augur> it's of a type /build from/ that, but that's not the same thing
00:01:56 <efie> i want to map a function :: String -> String -> String -> Data over a list :: [[String]] (whereas each [String] - list consists of exactly 3 Strings) how can i do this with higher ordered functions?
00:02:14 <augur> er
00:02:15 <ddarius> augur: That's an arbitrarily restricted and non-standard definition.
00:02:50 <augur> ddarius: no im pretty sure that's not really arbitrarily restricted or non-standard
00:02:58 <tikhonjelvis> You should probably make it a list of tuples of strings: [(String, String, String)]
00:03:04 <augur> its exactly as restricted as i intended when i said what i said initially
00:03:21 <efie> tikhonjelvis: oh yes, sounds good
00:03:36 <bd_> efie: map (\[a,b,c] -> f a b c) xs
00:03:48 <bd_> I don't think there's a builtin function to uncurry a list (not pair) of 3 items
00:04:06 <tikhonjelvis> You wouldn't have a pair of three items anyhow :P
00:04:37 <tikhonjelvis> With a tuple, map (\(a,b,c) -> f a b c) xs would work *and* be type safe.
00:05:27 <ddarius> augur: I'm not aware of anyone who would call nanothief's type "not recursive" nor would make a distinction about recursing "on a type" and recursing on "a type built from a type."
00:05:48 * augur shrugs
00:05:58 <augur> oh well.
00:06:06 <ddarius> augur: Can you provide a reference that uses this distinction?
00:06:31 <augur> i cant be bothered, because it doesnt matter either way
00:07:08 <augur> we've settled the confusion of what i initially meant, either way.
00:08:08 <ddarius> That wasn't really relevant, especially because you basically just said "it means what I want it to mean so that I'm right."
00:08:11 * cmccann complains that nanothief's "NotInfinity" type still contains infinite values and is thus misleadingly named
00:08:58 <ddarius> cmccann: My next exercise, also easy, is to make a type with no non-recursive constructor that only admits finite (potentially undefined) values.
00:09:47 <cmccann> "potentially undefined" makes the whole thing rather trivial, doesn't it?
00:09:54 <augur> the only thing thats relevant, ddarius, is the original point i was trying to make. if i worded it in a way that you didn't like, then we have corrected that problem, and we can move on.
00:15:23 <Rc43> Hi, guys.
00:16:06 <Rc43> How can I look `Data.Array.Unboxed` source? There is no link for that on hackage.
00:16:33 <Cale> http://www.haskell.org/ghc/docs/latest/html/libraries/array-0.4.0.0/Data-Array-Unboxed.html
00:16:57 <Cale> There's a source link from there which takes you to Data.Array.Base's source
00:20:30 <Rc43> Cale, yeah, Data.Array.Base is nice, thanks
00:21:41 <czro> Hello. How do I file a bug for GHC?
00:21:41 <lambdabot> czro: You have 1 new message. '/msg lambdabot @messages' to read it.
00:25:17 <Rc43> I can't implement my own unboxed arrays?
00:25:28 <Rc43> Constructor UArray is hidden.
00:25:42 <tikhonjelvis> I suspect it would need some deep GHC magic.
00:26:04 <tikhonjelvis> Well, maybe not that deep, but at least some :) Of course, I don't really know.
00:26:37 <Rc43> And there is no other way to implement unboxed 2d array?
00:27:45 <Cale> Rc43: You could do it in terms of the FFI perhaps.
00:28:00 <Cale> But... well, what are you trying to do?
00:28:30 <Rc43> Writing a contest problem with graph.
00:28:42 <Rc43> I need fast array.
00:29:22 <ddarius> Why do you think you can make a faster array than one of the standard types?
00:29:29 <Cale> Well, the existing instances should be enough for a decent graph representation...
00:29:40 <Cale> Depending on what sort of graph it is
00:29:56 <paolino> hello, is it right that getStdGen which is in IO always return the same generator ?
00:30:38 <Cale> paolino: It should return different values each time, and the first generator should be initialised differently each time you run your program
00:30:45 <Cale> er
00:31:06 <Rc43> ddarius, I just want to use unboxed array, the are faster. But there is no unboxed arrays for array value (2d).
00:31:14 <ChristianS> Rc43: did you look at the vector package? i heard it's preferably over array.
00:31:20 <paolino> Cale, maybe I got it wrong
00:31:23 <Cale> paolino: oh, no I'm wrong
00:31:23 <ChristianS> there's a Data.Vector.Unboxed module
00:31:26 <Rc43> ChristiansS, did it 5 sec ago.
00:31:39 <Cale> paolino: It'll give the same value each time, but should be different each time you run your program
00:31:40 <Rc43> ChristianS, which difference in two words?
00:31:58 <paolino> Cale so what is the point of IO ?
00:31:58 <Cale> paolino: if you want a new random generator each time, use newStdGen
00:32:23 <ChristianS> Rc43: more efficient and nicer api. but that's just hearsay, i tried neither of them myself.
00:32:28 <Cale> paolino: getStdGen/setStdGen get/set the generator used for the IO versions of the System.Random operations
00:32:39 <ddarius> Rc43: You can flatten a 2D array to a 1D array.
00:32:57 <Rc43> ddarius, yes, I forgot about it
00:33:03 <Rc43> ddarius, may be it will be better
00:33:06 <Cale> paolino: newStdGen splits the current state of that generator, updating it with one of the results and returning the other
00:33:21 <paolino> Cale, right, thanks
00:33:23 <Cale> (which is usually what you actually want)
00:33:28 <ddarius> @hoogle UArray
00:33:28 <lambdabot> Data.Array.Unboxed data UArray i e
00:33:28 <lambdabot> Data.Array.IO castIOUArray :: IOUArray ix a -> IO (IOUArray ix b)
00:33:29 <lambdabot> Data.Array.ST castSTUArray :: STUArray s ix a -> ST s (STUArray s ix b)
00:34:05 <Cale> http://escism.net/omfgdogs/ -- where is BONUS? He needs to see this.
00:34:16 <paolino> Cale, right, thanks
00:34:27 <paolino> ops
00:34:53 * ski wants to s/third/2nd/,&c. over the whole world
00:35:07 <paolino> xchat and netbook pointers are bad
00:35:13 * ski wonders why there's no `instance IArray UArray (Int,Int)',&c.
00:35:55 <ski> preflex: xseen BONUS
00:35:55 <preflex>  BONUS was last seen on freenode/#haskell 300 days, 13 hours, 7 minutes and 56 seconds ago, saying: yeah i think that's better as well
00:36:24 <Cale> Rc43: Note that the Ix instance you use with UArray is unconstrained, so you can use 2D indexes
00:36:40 <Cale> Rc43: Just by using pairs for your bounds and indexes into the array
00:37:00 <Cale> It's only the type of elements stored in the array which are restricted
00:37:09 <ddarius> ski: You want everything in the world to be zero indexed?
00:37:22 <Rc43> Cale, tried it for previous problems, don't remember what was with it
00:37:41 <Rc43> Cale, will do such now
00:38:03 <ChristianS> Rc43: there also is A Vector Tutorial: http://www.haskell.org/haskellwiki/Numeric_Haskell:_A_Vector_Tutorial
00:38:06 <ski> ddarius : maybe not *quite* everything, but much more than now
00:38:34 <ski> (imo, it should be the default)
00:38:41 <Rc43> ChristianS, thanks
00:39:31 <Rc43> ChristianS, vector isn't included in standard distribution?
00:41:22 <Rc43> btw,can tuple idices cause overhead?
00:42:33 <ChristianS> Rc43: no, vector doesn't come with ghc
00:43:02 <Rc43> Sadly, I have to use only standard libs
00:44:15 <ski> > fix ((1 +) . recip) :: CReal
00:44:19 <lambdabot>   mueval-core: Time limit exceeded
00:44:23 <ski> ):
00:47:13 <ski> hm, i suppose it couldn't possibly choose which of the two solutions it should yield
00:48:37 <ski> it would be nice if there was a way to make `fix (max 1 . (1 +) . recip)' work, though
01:01:41 <ddarius> > iterate ((1+) . recip) 1.0
01:01:42 <lambdabot>   [1.0,2.0,1.5,1.6666666666666665,1.6,1.625,1.6153846153846154,1.619047619047...
01:02:06 <ddarius> > drop 10 $  iterate ((1+) . recip) 1.0
01:02:08 <lambdabot>   [1.6179775280898876,1.6180555555555556,1.6180257510729614,1.618037135278514...
01:02:29 <ddarius> > (1 + sqrt(5)) / 2
01:02:30 <lambdabot>   1.618033988749895
01:20:09 <oskimura> :it
01:30:45 <alistra> :t it
01:30:46 <lambdabot> Not in scope: `it'
01:30:51 <alistra> >it
01:30:53 <alistra> > it
01:30:54 <lambdabot>   Not in scope: `it'
01:31:19 <Rmx_> mm_freak_ : did you code an example using gloss and netwire ?
01:35:55 * hackagebot egison 1.0.6 - An Interpreter for the Programming Language Egison  http://hackage.haskell.org/package/egison-1.0.6 (SatoshiEgi)
01:36:35 <dreixel> mux: now I am
01:41:47 <MagneticDuck> Hello, newbie here...
01:42:02 <MagneticDuck> I'm fairly new to monads, but I just wanted to ask a little question about them.
01:42:23 <alistra> they're not like a burrito
01:43:08 <MagneticDuck> Do any of you like using monads outside of the IO? I mean, where the actual calculation happen, in the "pure code"?
01:43:20 <alistra> outside of io?
01:43:38 <MagneticDuck> Well, that is, when you're not using them only because you have to do some interface.
01:43:45 <lispy> yes
01:43:49 <alistra> well yeah
01:43:58 <lispy> Many very elegant abstractions are made out of monads in haskell
01:44:00 <alistra> you use monads not to use monads
01:44:05 <Enigmagic> sure, who doesn't?
01:44:06 <MagneticDuck> Yeah, that's what I have been seeing.
01:44:07 <alistra> you use them because it's shorter and cleaner
01:44:15 <alistra> for example
01:44:16 <alistra> maybe
01:44:22 <alistra> is a nice monad :P
01:44:39 <alistra> if anything on the way returns Nothing the whole comp returns nothing
01:44:50 <alistra> it's better than chaining cases like a c programmer
01:44:50 <MagneticDuck> Yeah... until very recently, I didn't know Maybe was a monad. It's not a very confusing one at that.
01:44:58 <lispy> MagneticDuck: also, these days applicative functors are catching on as an alternative to monads
01:45:05 <Nereid> Cale ☃ since you're talking about making a game with haskell, I'm going to bother you with some questions.
01:45:11 <MagneticDuck> And we don't want to be C programmers!
01:45:11 <Cale> okay
01:45:12 <nanothief> list is also very nice
01:45:33 <nand`> the best applicative is ((->) r)
01:45:46 <MagneticDuck> Still learning about those...
01:45:47 <alistra> list is useful if you do np-hard problems :P
01:45:53 <alistra> bruteforce that is
01:45:55 <Nereid> well ok.
01:45:55 <MagneticDuck> What is list?
01:46:01 <Cale> Hi MagneticDuck!
01:46:05 <MagneticDuck> Hey Cale!
01:46:10 <nand`> oh no oh no
01:46:12 <nand`> here comes Cale
01:46:27 <Cale> (I was responsible for getting MagneticDuck addicted :)
01:46:33 <nand`> ah, I see
01:46:34 <MagneticDuck> Yeah, well he introduced me to Haskell, actually on the #magnets irc
01:46:41 <alistra> > do { x <- [1,2,3]; y <- [4,5,6]; return (x,y) }
01:46:42 <lambdabot>   [(1,4),(1,5),(1,6),(2,4),(2,5),(2,6),(3,4),(3,5),(3,6)]
01:46:44 <nand`> I thought you were getting ready to drop unbounded amounts of helpful information on him
01:46:47 <Nereid> Cale ☃ I tried something a while back, using yampa. unfortunately, the game necessarily needs to have upwards of a thousand objects at a time, and still run smoothly, at say 60fps.
01:47:08 <Nereid> needless to say, even with dead simple object behaviours, it struggled.
01:47:12 <Cale> Nereid: yeah, yampa has some limitations
01:47:41 <Nereid> what can I look into that can handle such things?
01:47:53 <Nereid> maybe I'd have to roll my own thing. I don't remember seeing many suitable ptions.
01:47:56 <Nereid> options.
01:48:25 <Cale> Nereid: We've struggled quite a lot to get a good FRP implementation in-house (in fact, it's probably been *most* of the time that we put into the game -- a sort of long-term investment :)
01:48:32 <Nereid> heh.
01:48:50 <Cale> Nereid: One of us, Stephen Blackheath, has done another implementation which he's used in other projects
01:49:07 <Cale> You might want to try it out, it's called Sodium
01:49:22 <Cale> I can't really say from personal experience how well it works, but supposedly it's cool :)
01:49:46 <Nereid> cool, I'll have a look.
01:50:05 <Nereid> I figured you'd be more on top of these things, so.
01:50:43 <Nereid> although
01:51:25 <Cale> I only really have a fair amount of experience with Yampa (which we were using quite a while ago), and our in-house system
01:51:52 <Nereid> Cale ☃ how deterministic are these systems?
01:52:03 <Cale> Our in-house system we might contribute back to the community, at least in part, someday. It's entirely deterministic.
01:52:03 <nand`> What is this about a game? Entirely written in Haskell, I assume?
01:52:13 <lispy> Cale: https://twitter.com/#!/PLT_Borat/statuses/172637850284724224
01:52:32 <Cale> ahaha
01:52:44 <Nereid> like say, my game would have everything running synchronously at 60fps, or whatever, and one of the requirements/hopes is that the game would evolve deterministically, given the same inputs and random seed and whatever.
01:53:29 <Nereid> hmm.
01:55:08 <Cale> Nereid: Our FRP system requires a special preprocessor for Arrow syntax, because it uses a completely revised Arrow library, which is split up into smaller parts and extended in various ways.
01:55:38 <Nereid> mm
01:55:40 <Cale> Probably it'd also be a good idea to turn that preprocessing step into a GHC feature.
01:55:47 <Cale> (and a new Control.Arrow)
01:55:53 <Nereid> I hate ctrl-W
01:56:11 <Cale> (and a new Control.Arrow)
01:56:17 <Nereid> mhm
01:56:44 <Cale> The new Arrow library looks a lot more like "symmetric monoidal categories", if that means anything to you :)
01:57:51 <Cale> It's important to be able to abstract over fst, snd, swap, and left/right reassociation of pairs
01:58:35 <Nereid> mhm
01:58:40 <Cale> We also require that  (f >>> g) *** (h >>> k) = (f *** h) >>> (g *** k)
01:58:50 <Cale> which means that our Arrows are not a generalisation of Monad
01:58:58 <Cale> but that, I think, is actually a good thing
01:59:16 <MagneticDuck> BTW I'm back. Just gobbled down breakfast.
01:59:25 <Nereid> it's been a while. remind me what it would look like if it were a generalization of Monad?
01:59:58 <Cale> Well, if, say, you could have Kleisli IO a b ~= a -> IO b
02:00:02 <Cale> as an Arrow instance
02:00:07 <Nereid> sure
02:00:12 <Nereid> ahh I see.
02:00:16 <Cale> then the g and h in that identity would happen in a swapped order
02:00:29 <Cale> (at least presumably...)
02:01:20 <Cale> That law lets you look at those wiring diagrams that people draw for Arrows a little more seriously though
02:01:47 <Cale> Without it, the wiring diagram doesn't tell you the whole story (and you have to draw awkward boxes around things to say exactly how they're composed in terms of the operations
02:01:55 <Nereid> yeah
02:02:58 <Cale> and it seems like all the libraries which use Arrow and which also really need to be using Arrow, at least so far as I have seen, also satisfy that naturality law
02:03:51 <covi> Hi all. Why does this pattern match fail?  'filter (\(a, b, c) -> a+b+c == 1000 && a^2+b^2 == c^2) $ [(a, b, c) | a <- [1..1000], b <- [a + 1..1000], c <- [b + 1..1000]]'
02:04:11 <Cale> > filter (\(a, b, c) -> a+b+c == 1000 && a^2+b^2 == c^2) $ [(a, b, c) | a <- [1..1000], b <- [a + 1..1000], c <- [b + 1..1000]]
02:04:15 <lambdabot>   mueval-core: Time limit exceeded
02:04:44 <Cale> covi: it shouldn't
02:04:55 <Cale> covi: what are you running it in?
02:05:10 <covi> Cale: actually this is one piece of the code. I run it with ghc
02:05:29 <Cale> okay, I don't see how that can pattern match fail
02:05:48 <Cale> You're only matching on irrefutable patterns and (a,b,c), which is unfailable
02:06:13 <Cale> I'm running that in ghci, and it has found (200,375,425) so far
02:06:19 <covi> wait a sec, let me paste the complete line for you..
02:06:50 <covi> http://hpaste.org/64311
02:07:34 <Cale> um, is that not a type error?
02:07:55 <Cale> covi: that's a type error
02:08:02 <Cale> product . head
02:08:16 <Cale> The head of the list will be a triple
02:08:21 <Cale> but product will want a list
02:08:31 <covi> Cale: I see..
02:08:36 <efie> is there a function like isNotPrefixOf ?
02:08:54 <Cale> efie: You could compose with 'not'
02:08:59 <covi> is there a handy function for product of a triple
02:09:11 <covi> efie: not . isPrefixOf
02:09:22 <Nereid> covi ☃ you probably want to write one yourself.
02:09:34 <Cale> covi: not in the standard library, but you could write one, or just use lists
02:09:51 <Nereid> using lists sounds like the wrong way to do this
02:09:59 <Cale> well, it's a little wrong ;)
02:10:23 <covi>  okay I'll wrote one
02:10:25 <MagneticDuck> To find the product of a triple, can
02:10:33 <MagneticDuck> 't you just nest uncurry twice?
02:10:40 <covi> how do I let my program pause before exiting?
02:10:46 <Cale> nope, because triples are a separate type from pairs
02:10:59 <Nereid> MagneticDuck ☃ a triple is not a pair containing a pair.
02:11:02 <MagneticDuck> Oh, spoiled by lists. That's right.
02:11:05 <Cale> (it's actually really uncommon to use the tuples larger than pairs very much)
02:11:17 <MagneticDuck> Smack on the head.
02:11:29 <Cale> You could use pairs with other pairs instead of triples
02:11:54 <covi> is there sth like sys.pause()?
02:12:19 <Nereid> covi ☃ what do you expect that to do?
02:12:22 <Cale> Control.Concurrent has threadDelay
02:12:33 <MagneticDuck> Yeah, I wanted to know a function like that too.
02:12:34 <Cale> which delays for a given number of picoseconds
02:12:45 <covi> Nereid: pretty simple. My program is printing a calculation result, but before I can see it, the program ends.
02:13:05 <Cale> covi: why is the terminal closing?
02:13:15 <covi> Cale: it seems... a little bit heavy for my purpose
02:13:19 <covi> Cale: I don't know...
02:13:20 <MagneticDuck> covi, if you're running it on the terminal, you can just use getLine
02:13:29 <covi> MagneticDuck: like?
02:13:35 <Nereid> like
02:13:36 <Nereid> getLine
02:13:38 <Cale> main = do ... ; getLine
02:13:41 <efie> how can i make the lamdabot tell me of which type (not . isPrefixOf) would be?
02:13:48 <Nereid> @type not . isPrefixOf
02:13:49 <lambdabot>     Couldn't match expected type `Bool'
02:13:49 <lambdabot>            against inferred type `[a] -> Bool'
02:13:49 <lambdabot>     Probable cause: `isPrefixOf' is applied to too few arguments
02:13:52 <Nereid> of course that doesn't work.
02:13:57 <Cale> :t not . isPrefixOf "foo"
02:13:58 <lambdabot> [Char] -> Bool
02:13:58 <Nereid> @type not . isPrefixOf "asdf"
02:13:59 <lambdabot> [Char] -> Bool
02:14:03 <covi> I see. thanks guys!
02:14:04 <Cale> :t (not .) . isPrefixOf
02:14:05 <lambdabot> forall a. (Eq a) => [a] -> [a] -> Bool
02:14:16 <efie> ok, thanks
02:14:17 <nand`> @type not .: isPrefixOf
02:14:18 <lambdabot> forall a. (Eq a) => [a] -> [a] -> Bool
02:14:55 <efie> (not .) . isPrefixOf is ugly, is it not?
02:15:01 <nand`> .: is a very helpful operator :)
02:15:04 <nand`> :t (.:)
02:15:05 <lambdabot> forall a b (f :: * -> *) (g :: * -> *). (Functor f, Functor g) => (a -> b) -> f (g a) -> f (g b)
02:15:06 <Cale> efie: a little
02:15:13 <nand`> oh god, that type
02:15:13 <Cale> efie: You might just want a lambda
02:15:22 <nand`> :t (.).(.)
02:15:23 <lambdabot> forall (f :: * -> *) a b (f1 :: * -> *). (Functor f, Functor f1) => (a -> b) -> f (f1 a) -> f (f1 b)
02:15:25 <Nereid> (\(a,b,c) -> a*b*c)
02:15:42 <mux> dreixel: hi! do you see any usefulness in Andres' example? I fail to see the point
02:15:42 <Nereid> oh wait
02:15:43 <Cale> nand`: It's mostly scary because of all the explicit quantification and kinding
02:15:52 <Cale> nand`: if you ignore that, it's pretty easy :)
02:16:15 <Nereid> Cale ☃ also because lambdabot has a more general (.)
02:16:15 <Cale> lambdabot has a cute generalisation of (.) :)
02:16:24 <nand`> Cale: yeah and because of the functorized version of (.) instead of (b -> c) -> (a -> b) -> (a -> c) :P
02:16:24 <Nereid> :t (.)
02:16:25 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
02:16:29 <Nereid> oh yeah it's just fmap.
02:16:34 <nand`> lol caleskell
02:16:40 <Cale> yeah, in this case, I think the generalisation actually helps understand how (.).(.) works
02:17:01 <Cale> Because it's easier to see what fmap . fmap would be in general
02:17:02 <Rc43> Suppose I have `x = 100 :: Word8`. The only way to get `x^2 :: Word16` is using `fromIntegral`?
02:17:09 <nand`> I think the old type is easier to understand: (.).(.) :: (c -> d) -> (a -> b -> c) -> (a -> b -> d)
02:17:10 <Cale> and then re-specialise it :)
02:17:24 <nand`> but yeah, not as easy to understand *how* it works
02:17:27 <Cale> nand`: But could you derive that type in your head so easily? :)
02:17:28 <Cale> yeah
02:17:28 <nand`> just what it does
02:17:30 <Rc43> it seems, fromIntegral a little slows programm
02:17:59 <adnauseam> hrm - getting a not in scope error on scanll, should i be loading any modules ?
02:17:59 <OODavo> The expression 'const "" (return True)' produces an ambiguous type variable error, since the monad being used for the return is unknown. Shouldn't the monad type not actually matter, however, since the expression shall /always/ resolve to ""?
02:18:09 <nand`> @pl \a b x y -> a (b x y)
02:18:10 <lambdabot> (.) . (.)
02:18:19 <nand`> Cale: there you go :)
02:18:27 <nand`> no functor required ;)
02:18:31 <Cale> OODavo: Well, the typechecker doesn't know that :)
02:19:05 <Cale> OODavo: (though, I guess in this case, it could almost know that because of parametricity...)
02:19:13 <OODavo> It can't just leave that argument with type Monad m => m Bool?
02:19:50 <adnauseam> would anyone have an idea as to why i'm getting "not in scope" on "scanll"  ?
02:20:01 <Cale> adnauseam: because that second l should be a 1
02:20:04 <ChristianS> OODavo: in general, you cannot get things out of monads
02:20:05 <mekeor> > const "" (return 'a')
02:20:06 <lambdabot>   Ambiguous type variable `m' in the constraint:
02:20:06 <lambdabot>    `GHC.Base.Monad m'
02:20:06 <lambdabot>      a...
02:20:15 <Nereid> @djinn (c -> d) -> (a -> b -> c) -> (a -> b -> d)
02:20:15 <lambdabot> f a b c d = a (b c d)
02:20:30 <ChristianS> OODavo: oops, i misread, ignore me
02:20:32 <adnauseam> oh
02:20:37 <adnauseam> ;p
02:20:50 <Cale> OODavo: I think it's because the typechecker never substitutes a polymorphic type for a type variable on its own.
02:21:12 <Cale> OODavo: So when it takes the type of const :: a -> b -> a
02:21:18 <covi> Hi guys. why this fails... 'ans = abs . (-) $ (sum . map (^2) $ [1..100]) (sum [1..100])^2'
02:21:18 <Cale> and substitutes something in for b
02:21:29 <Cale> oh
02:21:43 <Nereid> covi ☃ abs . (-) is not what you think it is.
02:21:45 <Cale> Well, it substitutes in m0 Char
02:21:54 <Cale> with a constraint (Monad m0)
02:22:06 <Nereid> neither is the thing after the $
02:22:07 <MagneticDuck> Yeah, (-) is a function of type...
02:22:12 <MagneticDuck> >:t (-)
02:22:19 <covi> Nereid: so I should do subtract?
02:22:21 <nand`> Num a => a -> a -> a
02:22:26 <Cale> but then there's this extra constraint hanging around which it doesn't know how to resolve
02:22:27 <MagneticDuck> Yeah, that's it
02:22:31 <Nereid> covi ☃ that's not it.
02:22:46 <mekeor> Nereid: what the hell is ☃ ?
02:22:50 <Nereid> it's a snowman.
02:22:54 <MagneticDuck> I have the same question.
02:22:55 <mekeor> ?
02:23:07 <nand`> bleh, can't see it at that font size
02:23:12 <Nereid> me either
02:23:17 <mekeor> i can zoom :P
02:23:24 <OODavo> Ah, so the typechecker doesn't elevate that typeclass constraint into const's signature?
02:23:28 <Nereid> covi ☃ look at the types of things. think carefully.
02:23:33 <covi> man, changing (-) to subtract does not work
02:23:33 <Nereid> you probably want
02:23:37 <MagneticDuck> Yeah, so if you want to negate something, use (0-)
02:23:46 <Nereid> ans = (abs .: (-)) (sum . map (^2) $ [1..100]) (sum [1..100])^2
02:23:50 <Nereid> except
02:23:55 <Nereid> with more parentheses around the last argument
02:23:59 <nand`> MagneticDuck: abs . negate would make no sense
02:24:06 <mekeor> @hoogle (.:)
02:24:07 <lambdabot> No results found
02:24:16 <MagneticDuck> Yeah, that's the other problem.
02:24:17 <Nereid> covi ☃ first a couple things.
02:24:21 <nand`> .: needs to be Prelude
02:24:28 <Cale> OODavo: yeah, it doesn't make it b = (forall m. Monad m => m Char)
02:24:31 <mekeor> what is .: ?
02:24:38 <nand`> (.:) = (.).(.)
02:24:39 <Nereid> mekeor ☃ (f .: g) a b = f (g a b)
02:24:45 <Cale> OODavo: but it introduces some specific as-yet-unknown type m0
02:24:53 <nand`> NSFW operator
02:25:01 <covi> I'm completely thrown off.
02:25:06 <Cale> OODavo: and it is able to tell that it has a Monad m0 constraint that needs satisfying
02:25:07 <Nereid> covi ☃ well let's look first.
02:25:14 <Nereid> covi ☃ what do you think
02:25:15 <covi> Nereid: sure plz
02:25:22 <Nereid> >(abs . (+)) 1 2
02:25:24 <Nereid> > (abs . (+)) 1 2
02:25:26 <lambdabot>   3
02:25:30 <Nereid> ???
02:25:37 <Nereid> gdi lambdabot.
02:25:38 <Nereid> stop it.
02:25:39 <paolino> :t (sum . map (^2) $ [1..100]) (sum [1..100])^2
02:25:40 <lambdabot> forall a t. (Num a, Enum (t -> a), Num t, Enum t) => a
02:25:53 <Nereid> covi ☃ ok let's say n is our number type.
02:25:56 <Cale> OODavo: but then when you get to the type of the result, it never figured out which monad m0 was and still has this Monad m0 constraint hanging around which it can't work out how to satisfy
02:25:56 <MagneticDuck> Okay, what's forall?
02:26:05 <Nereid> we have (-) : n -> (n -> n)
02:26:09 <mekeor> Nereid: and where is .: defined?
02:26:09 <Nereid> while abs :: n -> n
02:26:24 <Nereid> covi ☃ you can't compose those.
02:26:35 <OODavo> And the typechecker isn't as lazy as the evaluation semantics, so it has a problem with not finding that type, even though it's never required, I take it?
02:26:39 <covi> Nereid: what is the ':'...
02:26:42 <Nereid> I meant ::
02:26:45 <Cale> OODavo: yeah
02:27:15 <covi> Nereid: I changed (-) to 'subtract'
02:27:21 <Nereid> covi ☃ yes, that's not the issue.
02:27:26 <Nereid> subtract and (-) are the same thing.
02:27:30 <Cale> OODavo: In any case, this isn't a very common problem to have :)
02:27:40 <nand`> having _ be valid on the right hand side of :: might be useful for this, where the type checker would ignore anything that gets matched against a _
02:27:50 <nand`> but I can't think of much use for it other than const
02:28:00 <Nereid> covi ☃ the issue is that
02:28:16 <Nereid> subtract doesn't return a number.
02:28:42 <Nereid> it's a curried function, remember.
02:28:44 <Rmx> does anyone have any example of netwire 3 ?
02:28:49 <mekeor> :t subtract 10
02:28:50 <lambdabot> forall t. (Num t) => t -> t
02:28:50 <OODavo> Since the second argument of const is perhaps the most unnecessary argument of all time, yes, it's not exactly a big issue. :P
02:28:50 <covi> Nereid: I understand. I now fix it by putting '$' before (-) or subtract
02:28:57 <Rmx> I'm really experiencing problems with it
02:29:03 <Nereid> covi ☃ and taking out the other $, I hope.
02:29:06 <Rmx> I would like to look at some working code
02:29:08 <covi> Nereid: thank you so much... besides my fix, any other possible fix?
02:29:11 <Rmx> other than wiki page
02:29:13 <covi> Nereid: sure.
02:29:17 <Nereid> that's probably the most reasonable thing to do.
02:29:19 <nand`> > abs $ 5 - 8
02:29:20 <lambdabot>   3
02:29:34 <Nereid> yeah, just go
02:29:36 <Cale> It could presumably use parametricity to prove just from the type of const that the type of the second argument of const can't actually affect anything about the result.
02:29:44 <Cale> and resolve ambiguities by ignoring them
02:29:50 <Nereid> ans = abs $ (sum . map (^2) $ [1..100]) - (sum [1..100])^2
02:30:06 <Cale> But that'd be a bunch of special casing for a case that doesn't often happen
02:30:17 <Nereid> (I personally find the $ operator ugly, but w/e)
02:30:34 <nand`> > const "" (return True :: ())
02:30:34 <lambdabot>   Couldn't match expected type `()'
02:30:35 <lambdabot>         against inferred type `m GHC.Bool...
02:30:42 <Cale> > const "" (return True :: IO ())
02:30:42 <lambdabot>   Couldn't match expected type `()'
02:30:43 <lambdabot>         against inferred type `GHC.Bool.B...
02:30:49 <Cale> > const "" (return True :: IO Bool)
02:30:50 <lambdabot>   ""
02:31:07 <Cale> > const "" (return True :: [Bool])
02:31:08 <lambdabot>   ""
02:31:12 <nand`> oh, wait, () isn't :: * -> *
02:31:22 <Nereid> :)
02:31:24 <nand`> otherwise I was thinking it might be a monad with the only valid result being () in any case
02:31:30 <hpaste> Athas pasted “How can I use multiple prefix operators in Parsec?” at http://hpaste.org/64312
02:32:17 <adnauseam> in [(4+), (10*), (^2), sqrt] where does sqrt fit ?
02:32:39 <Athas> I assume the reason my parser doesn't work is by design, but surely this must have come up before?
02:32:41 <adnauseam> i don't understand why it\s there
02:32:48 <nand`> :t sqrt
02:32:49 <lambdabot> forall a. (Floating a) => a -> a
02:33:15 <adnauseam> i know what it does, but why is it in a list /
02:33:15 <adnauseam> ?
02:33:19 <Cale> adnauseam: Is that list from some actual code, or just an example?
02:33:20 <nand`> adnauseam: short answer: it's there because somebody put it there
02:33:34 <paolino> :t (4+)
02:33:35 <lambdabot> forall t. (Num t) => t -> t
02:33:36 <Cale> That's a list of functions which take numbers and produce numbers
02:33:36 <adnauseam> map ($ 3) [(4+), (10*), (^2), sqrt]
02:33:43 <adnauseam> this is the code it appeared in
02:33:45 <Cale> > map ($ 3) [(4+), (10*), (^2), sqrt]
02:33:45 <lambdabot>   [7.0,30.0,9.0,1.7320508075688772]
02:34:02 <Cale> > [4+3, 10*3, 3^2, sqrt 3]
02:34:02 <Nereid> :t [(4+), (10*), (^2), sqrt]
02:34:02 <lambdabot>   [7.0,30.0,9.0,1.7320508075688772]
02:34:03 <lambdabot> forall t. (Floating t) => [t -> t]
02:34:14 <nand`> adnauseam: each element of that list is a function, and you're passing the parameter 3 to each of them
02:34:26 <Nereid> :t ($ 3)
02:34:27 <lambdabot> forall a b. (Num a) => (a -> b) -> b
02:34:47 <adnauseam> oh god damnit - i missed that the resulting list had 4 elements and kept thinking it's three
02:34:49 <nand`> No real reason why it's there, just that somebody thought it might make a good example
02:34:51 <Nereid> ($ x) f = f x
02:35:06 <Nereid> huh
02:35:32 <adnauseam> yeah i was reading about function application with #
02:35:34 <adnauseam> $
02:35:54 <adnauseam> it got a bit dizzying with all the parenthese at somepoint ;p
02:36:19 <nand`> ($ x) = (\f -> f x)
02:36:29 <Cale> Who is PLT Borat?
02:36:59 <dreixel> mux: yes. I'll reply to that email.
02:37:49 <adnauseam> nand`: how'd you read that? $ applied on the parameter x and the fuction f produce f x ?
02:38:14 <Nereid> ($ x) f = f $ x = f x
02:38:19 <nand`> ($ x) is just partial application of ($) on the right hand side, so ($ x) f is f $ x
02:38:32 <nand`> as for how I'd read it
02:39:19 <nand`> “Opening parenthesis dollar sign x closing parenthesis equals opening parenthesis backslash f minus greater than f x closing parenthesis”, I guess
02:39:50 <adnauseam> i must say that this demands a bit of mental juggling to get at first - as simple as it may seem after one actually gets it; which i do now ;p
02:40:21 <nand`> (^2) 4 = 4^2 = 16
02:40:38 <Nereid> (+ 5) 3 = 3 + 5
02:40:53 <Nereid> ($ 5) f = f $ 5
02:41:04 <Nereid> ...= f 5, by definition  of $
02:41:12 <mux> dreixel: thank you
02:41:20 <dreixel> mux: you agree?
02:41:22 <adnauseam> i've a bit of confusion before since i've actually tried to push similar commands into ghci's prelude but got errors
02:41:25 <nand`> (.: f) g = \a b -> g (f a b)
02:41:31 <adnauseam> i suppose they only work in defined functions
02:42:18 <nand`> > let f = (^2); x = 4 in ($ x) f
02:42:18 <adnauseam> the (+5) 3 examples
02:42:18 <lambdabot>   16
02:42:26 <adnauseam> yeah, must define it with a let first
02:42:32 <mux> dreixel: I definitely agree that if there's a V1 instance, it should evaluate to undefined; I wasn't sure about the usefulness of it, Bas had convinced me otherwise. but if you see the point of Anderes, well that's fine, I'll re-add it and will release 2.0.1.0 now
02:42:38 <adnauseam> > (+4) 4
02:42:39 <lambdabot>   8
02:42:41 <adnauseam> oh
02:42:43 <adnauseam> o_0
02:43:16 <covi> man... it turns out that 'ans = abs $ (-) (sum . map (^2) $ [1..100]) (sum [1..100])^2'
02:43:17 <adnauseam> damn what the hell was i doing.
02:43:22 <covi> gives the wrong answer, whereas
02:43:29 <covi> ans = abs . (-) (sum . map (^2) $ [1..100]) $ (sum [1..100])^2
02:43:32 <covi> is the right one..
02:43:38 <dreixel> mux: I think Bas didn't consider the case of empty datatype appearing in the middle of other datatypes (as I didn't, at first)
02:43:49 <dreixel> mux: he complains about the V1 case returning ()
02:43:57 <mux> dreixel: well I did, and it didn't seem useful to be able to deepseq such types
02:44:01 <dreixel> mux: I think we all agreed that that is not what one would expect
02:44:03 <mux> it still doesn't actually
02:44:12 <dreixel> mux: well, take the Example datatype Andres gavve
02:44:13 <dreixel> *gave
02:44:18 <mux> well tht yeah, but he also said he thought the V1 instance should be removed
02:44:27 <dreixel> it's all fine if you only use the C1 constructor
02:44:28 <mux> dreixel: I did, I don't see the point of being able to deepseq such a type
02:44:38 <mux> that is, a X Z
02:44:45 <mux> you don't need a V1 instance for X itself
02:44:53 <mux> as long as the a parameter is in the DeepSeq as well
02:45:05 <paolino> >  abs $ (-) (sum . map (^2) $ [1..100]) (sum [1..100])^2
02:45:07 <dreixel> right, but you might want to deepseq Example values that are made up of C1 only
02:45:07 <lambdabot>   111088890000
02:45:10 <dreixel> for instance
02:45:37 <nand`> > negate 4^2
02:45:37 <dreixel> so just because there is an empty type somewhere in the datatype definition, it doesn't mean you will actually deepseq those at runtime
02:45:38 <lambdabot>   16
02:45:50 <nand`> application binds stronger than operators
02:45:54 <paolino> >  abs . (-) (sum . map (^2) $ [1..100])  $ (sum [1..100])^2
02:45:55 <nand`> > negate (4^2)
02:45:56 <lambdabot>   can't find file: L.hs
02:45:57 <lambdabot>   25164150
02:45:59 <mux> dreixel: hmm, that makes sense; I get it now. thank you
02:46:02 <dreixel> removing the V1 instance would prevent using generic deepseq on those types altogether, which seems a bit too restrictive
02:46:12 <nand`> > ans = abs $ (-) (sum . map (^2) $ [1..100]) ((sum [1..100])^2)
02:46:14 <dreixel> yw :)
02:46:15 <lambdabot>   <no location info>: parse error on input `='
02:46:18 <nand`> > abs $ (-) (sum . map (^2) $ [1..100]) ((sum [1..100])^2)
02:46:20 <lambdabot>   25164150
02:46:22 <mux> dreixel: so I'll be adding back a "instance GDeepSeq V1 where grnf _ = undefined" -- how does that look?
02:46:27 <nand`> covi: &
02:46:29 <dreixel> mux: that looks good.
02:46:29 <nand`> ^*
02:46:53 <dreixel> mux: you might want to use error instead of just undefined
02:47:05 <nand`> for what it's worth you don't need to use (-) in that syntax
02:47:06 <covi> nand`: yes I've tested myself too, the results are different. But why so?
02:47:13 <paolino> :t  abs . (-) (sum . map (^2) $ [1..100])  $ (sum [1..100])^2
02:47:14 <lambdabot> forall a. (Num a, Enum a) => a
02:47:24 <nand`> covi: did you see my last evaluation? That should be the right result
02:47:28 <paolino> :t  abs $ (-) (sum . map (^2) $ [1..100]) (sum [1..100])^2
02:47:29 <lambdabot> forall a. (Num a, Enum a) => a
02:47:34 <dreixel> I think that's what I use in the representation of empty datatypes (from/to functions)
02:47:44 <mux> dreixel: I've been wondering about that; at some point I even thought that using "seq undefined <whatever>" would be best, to make sure I throw just the same thing as seq
02:47:49 <dreixel> with some message like "no representation for empty datatype X"
02:47:56 <nand`> > abs $ (sum . map (^2) $ [1..100]) - (sum [1..100])^2
02:47:57 <lambdabot>   25164150
02:48:01 <covi> nand`: yeah but why the first is different (and wrong)?
02:48:06 <mux> like grnf _ = seq undefined ()
02:48:10 <paolino> :t (^)
02:48:11 <nand`> covi: I showed you a bit earlier
02:48:11 <lambdabot> forall a b. (Num a, Integral b) => a -> b -> a
02:48:13 <nand`> > negate 4^2
02:48:14 <lambdabot>   16
02:48:15 <nand`> is the same as
02:48:20 <nand`> > (negate 4)^2
02:48:20 <lambdabot>   16
02:48:30 <dreixel> mux: well, `seq undefined _` must be the same as `undefined`
02:48:31 <nand`> you need an extra pair of parenthesis around your last (sum [1..100])^2
02:48:56 <nand`> or you just use - infix instead of (-) so it binds less strongly, that's what I did about 10 lines ago
02:49:09 <dreixel> mux: undefined is indeed observed differently from error, but semantically they are equivalent
02:49:18 <nand`> I'd write that as:
02:49:37 <mux> dreixel: yeah, but then, in the context of stuff like ChasingBottoms, or the spoon package (maybe a bad example), it seems safer to me to just use undefined
02:49:42 <dreixel> mux: I'm just imagining a situation where you have lots of undefined's around, then you get one and you don't know where it came from. But this is not important
02:49:50 <nand`> > abs $ (sum $ map (^2) [1..100]) - (sum [1..100])^2
02:49:51 <lambdabot>   25164150
02:50:16 <dreixel> mux: I'm guessing ChasingBottoms will still find a bottom at an error
02:50:17 <covi> nand`: I understand that (-) A B returns a function that takes B. But why adding an extra pair of parenthesis around the last term solves the problem?
02:50:33 <dreixel> mux: but yes, it might find a "different" bottom
02:50:47 <nand`> covi: you had (-) A B^2 while you really meant (-) A (B^2)
02:50:48 <mux> dreixel: I suppose so. it just seems to make sense to me that deepseq would behave just like seq for those cases, even if it means we have less useful error messages
02:51:01 <nand`> it was evaluating to ((-) A B)^2
02:51:02 <dreixel> mux: go ahead and just use `undefined` :)
02:51:10 <mux> dreixel: thanks again for all the help :)
02:51:15 <dreixel> mux: no problem
02:51:31 <dreixel> mux: let me know if you think the performance is worse than type-specific
02:51:39 <covi> nand`: so my wrong version does (A-B)^2?
02:51:45 <nand`> covi: yes
02:52:01 <nand`> instead of (A-B^2)
02:52:03 <covi> nand`: oh my god...
02:52:12 <covi> haskell is...
02:52:17 <covi> I don't know what to say.
02:52:20 <covi> thanks nand`
02:52:34 <mux> dreixel: performance seems surprisingly good to me; have you seen those reports when I benchmark deepseq and generic-deepseq separately? it turns out generic-deepseq is significantly faster in that case :)
02:52:39 <nand`> np; always remember that function application binds very strongly
02:52:44 <nand`> you get used to it
02:53:01 <paolino> covi: when you use (-) it looses its fixity as operator
02:53:30 <dreixel> mux: well it's also surprising that it's faster :P
02:53:51 <covi> paolino: where can I read more about the fixity you're talking about and the function application binding stuff?
02:54:12 <paolino> using :i at ghci
02:54:27 <dreixel> mux: but I will not worry if it's faster :-)
02:54:34 <mux> dreixel: I think it's just because I build with -O2 and deepseq doesn't; switching from -O to -O2 improved performance significantly for me
02:54:46 <paolino> covi: :i (-)
02:54:49 <dreixel> mux: ah, sure, you should compare with the same flags.
02:54:56 <mux> wait, deepseq doesn't even builds with -O? (looking at the cabal file)
02:55:08 <mux> well, good for me I guess :-P
02:55:26 <dreixel> mux: doesn't cabal-install add -O by default, these days?
02:55:34 <mux> dreixel: ah, maybe it does, I don't knowq
02:55:46 <dreixel> mux: have you seen my email http://www.haskell.org/pipermail/generics/2012-February/000513.html ?
02:56:08 <covi> paolino: thanks
02:56:21 <mux> dreixel: I haven't seen that, but if it's about INLINEs, I should read it, but in my case adding INLINE pragmas didn't make a difference
02:56:36 <dreixel> mux: I sent it to ghc-users too, but it got moderated because it's too long :-/
02:56:58 <mux> it looks very interesting anyways
02:57:13 <dreixel> mux: yes, it might be relevant to you. I also try to explain what's going on, and what we need to optimise generic functions
02:57:42 * mux nods
02:57:53 <mux> I'll release 2.0.1.0 now, I have to go after that
02:58:03 <dreixel> ok
02:59:13 <paolino> > abs . (-) (sum . map (^2) $ [1..100]) $ (^) (sum [1..100]) 2
02:59:15 <lambdabot>   25164150
03:11:00 * hackagebot generic-deepseq 2.0.1.0 - Generic deep evaluation of data structures  http://hackage.haskell.org/package/generic-deepseq-2.0.1.0 (MaximeHenrion)
03:16:29 <covi> is there a function that does sth like [1,2,3] -> 123?
03:17:35 <naig> should be quite easy to write
03:17:40 <ChristianS> > let concatShow = (concat . map show) in concatShow [1,2,3]
03:17:42 <lambdabot>   "123"
03:17:56 <naig> or is it integer 123?
03:18:03 <Cale> > foldl (\n d -> 10*n + d) 0 [1,2,3]
03:18:04 <lambdabot>   123
03:18:13 <ddarius> +'
03:18:15 <covi> naig: if I have "123" I can do digitToInt
03:18:28 <covi> Cale: not necessarily three digits :)
03:18:33 <Cale> > foldl (\n d -> 10*n + d) 0 [1,2,3,4]
03:18:34 <lambdabot>   1234
03:18:39 <covi> Cale: but good for small numbers
03:19:00 <ddarius> > foldl' (\n d -> 10*n + d) 0 $ replicate 100 1
03:19:01 <lambdabot>   111111111111111111111111111111111111111111111111111111111111111111111111111...
03:19:17 <Cale> beat me to it :)
03:20:19 <ddarius> > read "1234" + 0 -- how to make Haskell like Javascript
03:20:20 <lambdabot>   1234
03:20:46 <shachaf> SyntaxError: Unexpected string
03:21:28 * ddarius wonders if anyone has ever added a + 0 to a Haskell program to "fix" a type error.
03:22:12 <ChristianS> > read "1234" :: Int
03:22:13 <lambdabot>   1234
03:22:14 <Nereid> surely it's better to just add a type declaration
03:22:21 <Nereid> > read "1234" :: Num a => a
03:22:21 <lambdabot>   Could not deduce (GHC.Read.Read a) from the context (GHC.Num.Num a)
03:22:22 <lambdabot>    aris...
03:22:26 <Nereid> oops right.
03:22:33 <ddarius> > read "1234"
03:22:34 <lambdabot>   *Exception: Prelude.read: no parse
03:22:45 <Nereid> :t read "1234"
03:22:46 <lambdabot> forall a. (Read a) => a
03:22:54 <ddarius> Nereid: The kind of person who would do such thing would not be someone particularly knowledgeable in Haskell.
03:23:05 <Nereid> well yes
03:23:44 <Peaker> ddarius: I always use -Wall -Werror, so (+0) would leave a defaulting warning anyway
03:23:46 <ddarius> But I've been around for a long time, and I don't think I've ever seen anyone successfully do that, nor can I recall a particular instance when someone tried to do that.
03:23:54 <Taneb> I think I've done a bad thing
03:24:20 <ddarius> Taneb: Did you use + 0 to add a Num constraint so defaulting would default to Integer where otherwise it would be ambiguous?
03:24:29 <Taneb> No
03:24:35 <Nereid> lol
03:24:49 <paolino> I'm looking for a rectangular tessellation so that tiles never share full sides, can't find a definition for it. I know it's not haskell
03:24:51 <Taneb> I changed the requirements of a Cabal package from Base 4.5.* to Base 4.3.* so it would install
03:25:09 <Taneb> I don't know if it will work or not
03:25:45 <paolino> base 4.5 is ghc 7.4 ?
03:25:47 <ddarius> Presumably you will find out.
03:26:11 <Taneb> Working so far
03:26:19 <Taneb> The package should work in GHC 7.2
03:26:40 <Nereid> I'm on 6.10 D:
03:26:42 <Taneb> I've got 7.0.4
03:26:45 <srhb> Has anyone had any luck with installing wxcore on a Mac with wxMac 2.9?
03:27:02 <Nereid> oh wait, I got 7.0.4 at some point.
03:32:09 <srhb> How do I go about fixing this? * Missing C library: wx_macu_media-2.8 - when installing wxcore. I do have wx 2.8 installed, but there's no such file. Is it a bug in the wxcore on hackage?
03:34:39 <mekeor> srhb: you have to install the *-dev package of wx_macu_media or so, idk… which distro?
03:34:49 <mekeor> oh, mac, okay…
03:35:03 <srhb> mekeor: Yeah. It worked in earlier versions, and now I reinstalled, using Homebrew to install wxMac
03:35:19 <srhb> I'm not sure if the problem is with wxWidgets or with wxHaskell (wxcore)
03:39:29 <shergill> so when is haskell getting extensible records?
03:40:33 <mekeor> shergill: what's that at all?
03:40:58 <shergill> http://www.haskell.org/haskellwiki/Extensible%5Frecord
03:41:04 <shergill> mekeor: ^
03:41:25 <adnauseam> hmm
03:41:34 <adnauseam> > (negate (-4))
03:41:35 <mekeor> yea, but that page doesn't really say what it IS…
03:41:35 <lambdabot>   4
03:41:54 <adnauseam> > (negate (4))
03:41:55 <lambdabot>   -4
03:42:23 <mekeor> adnauseam: let me guess: are you looking for 'subtract' or so?
03:42:29 <mekeor> > subtract 4 2
03:42:29 <lambdabot>   -2
03:43:10 <adnauseam> ghci gave a weird result and i wanted to test it
03:43:13 <adnauseam> *Main> (negate (-4))
03:43:14 <adnauseam> 4
03:43:14 <adnauseam> *Main> (negate (4))
03:43:14 <adnauseam> 4
03:43:21 <adnauseam> on asecond go it gave the right result again
03:43:35 <mekeor> lol :)
03:43:37 <adnauseam> strange :|
03:43:59 <mekeor> it's 2012…
03:44:00 <adnauseam> at least i didn't ask weird questions came out looking clean :P
03:44:44 <adnauseam> one can with some mathematical skill turn that year into 666
03:44:54 <adnauseam> which would explain why ghci is behaving as it does
03:46:09 <mekeor> exactly :D
03:46:12 <osa1> what's wrong with getRandoms in this code? http://paste.pocoo.org/show/556451/ take 5 getRandoms stucks in an infinite loop. isn't getRandoms lazily creating a list of random numbers?
03:46:58 <shergill> mekeor: treating records as first class objects, allowing for subtyping. https://research.microsoft.com/en-us/um/people/simonpj/Haskell/records.html
03:47:00 <mekeor> @hoogle rand
03:47:00 <lambdabot> package randfile
03:47:01 <lambdabot> System.Random class Random a
03:47:01 <lambdabot> System.Random random :: (Random a, RandomGen g) => g -> (a, g)
03:47:04 <mekeor> :t rand
03:47:05 <lambdabot> Not in scope: `rand'
03:47:12 <mekeor> oh, oops
03:48:00 <mekeor> :t getStdRandom
03:48:01 <lambdabot> forall a. (StdGen -> (a, StdGen)) -> IO a
03:48:46 <mekeor> :t randomR
03:48:47 <lambdabot> forall a g. (Random a, RandomGen g) => (a, a) -> g -> (a, g)
03:49:39 <mekeor> osa1: does 'randNum <- rand' work?
03:49:53 <mekeor> is it the last line which causes the error?
03:50:13 <osa1> mekeor: there isn't an error, but it's not working as expected
03:50:42 <osa1> I was hoping it to create list of random numbers lazyli so take I can take as many random numbers as I want with take n getRandoms
03:51:07 <mekeor> ah
03:53:03 <mekeor> osa1: it seems that you append randNum in front of the list, so you do 'randNum:aList' but you should somehow do 'aList++[randNum]', i think.
03:53:43 <mekeor> osa1: can you try replacing 'fmap (randNum:) getRandoms' with 'fmap (++[randNum]) getRandoms' ?
03:54:02 <paolino> osa1, there are lazy list creators in that lib
03:54:21 <mekeor> osa1: you said that it doesn't work as expected. what does it instead?
03:54:42 <mekeor> osa1: you can't 'take someIntegerHere getRandoms', right?
03:54:48 <osa1> mekeor: it stucks in an infinite loop when I run take n getRands
03:54:53 <mekeor> yea
03:54:55 <mekeor> do what i said
03:55:09 <paolino> randoms :: (RandomGen g, Random a) => g -> [a]
03:55:14 <osa1> paolino: isn't haskell a lazy language? why do I have to use some libs to create lazy collections
03:55:26 <srhb> Problem (possibly) solved. For some reason the homebrew recipe does not build wxmac with --enable-mediactrl and wxcore doesn't seem to have required this before.
03:55:30 <mekeor> osa1: getRandoms = someRandNum:getRandoms = someRandNum:someRandNum:getRandoms = …, got it?
03:56:05 <mekeor> you have to add the 'randNum' in your code AT THE END of the list!
03:56:05 <Cale> osa1: Executing IO actions isn't lazy
03:56:18 <Cale> osa1: It's lazy evaluation, not lazy execution :)
03:56:23 <mekeor> osa1: NOT in_front/at_the_beginnng as you do it atm
03:56:44 <osa1> Cale: oh wait, so stuff I'm doing in IO monad is cannot be lazy, right?
03:57:00 <osa1> mekeor: this makes your solution wrong then
03:57:04 <Cale> osa1: Apart from some magical primitives
03:57:08 <osa1> mekeor: since I'll be still in an IO monad
03:57:25 <mekeor> IO is lazy, too(, AFAIK)!
03:57:44 <Cale> Well, there are some magical things like getContents
03:57:52 <Cale> (but they're magic :)
03:57:59 <osa1> Cale: is there a way to get out of an IO monad? I'm wondering how can I build a lazy list of stuff I got in an IO monad
03:58:10 <Cale> Don't think of it as "getting out of an IO monad"
03:58:21 <Cale> The monad isn't a cage
03:58:45 <Cale> IO actions are values which represent some stuff to be done in order to construct a value
03:59:10 <Cale> To get the result of an IO action, you run it (as part of another IO action)
03:59:24 <Cale> The result of an action of type IO a has type a
03:59:56 <Cale> and inside a do-block, you write v <- x to mean "run the IO action x, and call the result v"
04:00:28 <Cale> and the do block as a whole will then be an IO action as well, glued together from its constituents
04:00:34 <Cale> Does that make sense?
04:01:06 <Cale> You can't run infinitely many IO actions without putting yourself into an infinite loop of some sort.
04:01:37 <Cale> However, generating pseudorandom numbers is conceptually pure
04:01:52 <Cale> You just need the PRNG state to be explicit
04:02:07 <Cale> (and pass it around a bit)
04:02:23 <osa1> Cale: it's strange that rand function return an IO, how is generating pseudorandoms related with IO?
04:02:45 <Cale> Well, the only way in which it's related to IO is getting some entropy from your system
04:03:12 <Cale> or, if the library turns out to be lazy, doing something with the system clock
04:03:23 <Cale> *cough* not lazy in a technical sense ;)
04:03:33 <Cale> lazy in the sense of being poorly written
04:04:05 * ski . o O ( "Haskell : a lazy language with class" )
04:04:09 <Cale> But the System.Random library provides pure functions for generating random numbers.
04:04:13 <Cale> pseudorandom*
04:04:20 <Cale> :t random
04:04:20 <lambdabot> forall g a. (Random a, RandomGen g) => g -> (a, g)
04:04:24 <Cale> :t randoms
04:04:25 <lambdabot> forall g a. (Random a, RandomGen g) => g -> [a]
04:04:32 <Cale> :t mkStdGen
04:04:32 <lambdabot> Int -> StdGen
04:04:48 <Cale> > randoms (mkStdGen 42) :: [Int]
04:04:49 <lambdabot>   [-3907187990116499535,-2519438828217931933,-8264534369199619667,86887135830...
04:04:53 <Cale> > randoms (mkStdGen 42) :: [Int]
04:04:54 <lambdabot>   [-3907187990116499535,-2519438828217931933,-8264534369199619667,86887135830...
04:05:03 <Cale> ^^ a completely random sequence of Ints ;)
04:05:17 <Cale> randoms gives an infinite list
04:05:35 <mekeor> osa1: i think you're looking for randomRs, or?
04:05:39 <mekeor> :t randomRs
04:05:39 <Cale> But if you want a different infinite list each time your program runs, you'll need to get a StdGen from somewhere else
04:05:40 <lambdabot> forall a g. (Random a, RandomGen g) => (a, a) -> g -> [a]
04:05:52 <Cale> yeah, randomRs is nicer, it lets you set the bounds
04:06:06 <Cale> > randomRs (1,6) (mkStdGen 42) :: [Int]
04:06:07 <lambdabot>   [6,4,2,5,3,2,1,6,1,4,4,4,1,3,3,2,6,2,4,1,3,1,1,5,5,5,1,3,6,1,5,6,1,3,5,4,1,...
04:06:22 <Cale> :t newStdGen
04:06:23 <lambdabot> IO StdGen
04:06:57 <Cale> ^^ you could run this action just once near the top of your program, and use the resulting StdGen instead, and it would make your program less predictable
04:07:26 <Cale> osa1: Make sense?
04:07:56 <ski> > let ns :: [Int]; n:ns = randoms (mkStdGen 42) in fmap (1 +) (elemIndex n ns)
04:08:00 <lambdabot>   mueval-core: Time limit exceeded
04:08:54 <Cale> ski: interesting :)
04:09:00 <osa1> yeah, thanks
04:09:28 <ski> apparently there's no `Random Int8' in scope
04:09:29 <srhb> Oh dear, now I understand, it would appear cabal is trying to install a wxcore that doesn't even compile on anything earlier than GHC 7.2
04:10:02 <srhb> Does cabal always pick the newest version from hackage?
04:10:07 <osa1> ok, another unrelated question: what are some useful monads to save some states? like game states for games, positions of some entites, status of map etc.
04:10:15 <srhb> cabal install, I should say
04:10:23 <ski> > let s :: String; c:s = randoms (mkStdGen 42) in fmap (1 +) (elemIndex c s)
04:10:24 <lambdabot>   Just 859094
04:11:06 <Cale> osa1: One that I rather like is StateT GameState [] which has backtracking nondeterminism, plus get and put operations to read the current state of play :)
04:11:23 <Cale> osa1: which is nice for solving puzzles like Sudoku and such :)
04:12:00 <osa1> Cale: thanks. I already knew StateT, are there any other useful monads like that?
04:13:07 <dcoutts> srhb: it tends to pick the newest one yes, you can explicitly ask for older ones (the next release will be cleverer and picking older ones if newest will not work)
04:13:13 <osa1> Cale: what do you mean by backtracking nondeterminism?
04:13:38 <Cale> osa1: Well, if you're just interested in storing state, you can practically always build a custom wrapper around a State monad which has a special interface for accessing each of the bits of state that you're interested in.
04:13:47 <Cale> osa1: I'm not really quite sure what you're looking for :)
04:15:15 <Cale> osa1: by that, I mean that you can "try all possibilities" from some list, and it will try each in turn, and backtrack when there are no answers
04:15:43 <Cale> http://www.haskell.org/haskellwiki/Sudoku -- the first solver on this page is an example I wrote
04:17:08 <Cale> I guess it's a little out of date. If I wrote it today, I might have just used the Logic monad from the logict package on Hackage rather than a custom monad for nondeterminism.
04:17:24 <Cale> You can also, as the comment says, just use the list monad, and it's really not so bad :)
04:17:39 <Cale> At least at the time though, GHC compiled better code this way
04:20:51 * ddarius likes using ST with a non-determinism monad to produce logic variables.
04:24:15 <adnauseam> :t takeWhile (<10000) (scanl1 (+) (map sqrt [1..]))
04:24:16 <lambdabot> forall a. (Floating a, Ord a, Enum a) => [a]
04:24:22 <adnauseam> o
04:24:49 <Cale> > takeWhile (<10000) (scanl1 (+) (map sqrt [1..]))
04:24:49 <lambdabot>   [1.0,2.414213562373095,4.146264369941973,6.146264369941973,8.38233234744176...
04:26:14 <adnauseam> :t is an excellent feature
04:26:15 <lambdabot> Not in scope: `is'
04:26:15 <lambdabot> Not in scope: `an'
04:26:15 <lambdabot> Not in scope: `excellent'
04:26:19 <adnauseam> hah !
04:26:20 * ski does too
04:26:23 <mekeor> @src abs
04:26:24 <lambdabot> Source not found. :(
04:26:35 <mekeor> :t abs
04:26:36 <lambdabot> forall a. (Num a) => a -> a
04:26:54 <mekeor> how is 'abs' implemented? Num is not a subset of Ord !
04:27:02 <mekeor> :info Num
04:27:34 <ski> > abs (sqrt (-1)) :: Complex CReal
04:27:35 <lambdabot>   1.0 :+ 0.0
04:28:40 <mekeor> http://hackage.haskell.org/packages/archive/base/latest/doc/html/src/GHC-Num.html#abs shows that, for example, Int is instanciated to Num by defining abs with 'geInt'. but where/howis geInt defined?
04:28:43 <ski> @type map `asTypeIn` \map -> takeWhile (<10000) (scanl1 (+) (map sqrt [1..]))
04:28:44 <lambdabot> forall a. (Floating a, Ord a, Enum a) => (a -> a) -> [a] -> [a]
04:29:01 <mekeor> ski: help!
04:29:13 <mekeor> ski: how is abs defined? for example, for Integers?
04:29:15 * ski looks around wildly
04:29:53 <ski>   abs n = max n (- n)  -- might be one way for `Integer'
04:29:53 <mekeor> http://hackage.haskell.org/packages/archive/base/latest/doc/html/src/GHC-Num.html#abs says: 'abs = absInteger' for Integers… but where's absInteger defined then?
04:30:03 <mekeor> ski: ah, okay
04:30:07 <mekeor> :t max
04:30:08 <lambdabot> forall a. (Ord a) => a -> a -> a
04:30:12 <ski> (:
04:30:14 <mekeor> max uses Ord :P
04:30:21 <ski> so what ? :)
04:30:28 <mekeor> Num is not a subset of Ord
04:30:29 <hpc> @hoogle absInteger
04:30:29 <lambdabot> No results found
04:30:29 <ski> `Integer' is in `Ord', so that's fine
04:30:39 <mekeor> ski: no!
04:30:41 <mekeor> it's not.
04:30:45 <mekeor> oh, okay
04:30:48 <mekeor> oh, right
04:30:51 <mekeor> ah, yes.
04:30:53 * Varifold facepalms.
04:30:57 <ski> it would be a problem if you tried to define a default implementation for `abs' using `max'
04:31:32 * ski faces a palm
04:31:44 <mekeor> right, i got it.
04:31:51 <mekeor> > abs (1:+2)
04:31:52 <lambdabot>   2.23606797749979 :+ 0.0
04:32:11 <Varifold> ski, be careful. Palms can be overwhelming.
04:32:21 <ski> (mekeor : also, to be pedantic, you should probably say "subclass" (or maybe "subrelation"))
04:32:42 <mekeor> okay.
04:33:00 <mekeor> so, abs could be defined for complex numbers as follows: abs (a:+b) = (magnitude (a:+b):+0)
04:33:19 <ddarius> ski: "Subset" seems completely fine to me.
04:33:22 <ski> yeah, i think so
04:33:34 <mekeor> @src abs :: Num a => Complex a -> Complex a
04:33:34 <lambdabot> Source not found. You type like i drive.
04:33:48 <mekeor> :t magnitude
04:33:49 <lambdabot>     Ambiguous occurrence `magnitude'
04:33:49 <lambdabot>     It could refer to either `Data.Complex.magnitude', imported from Data.Complex
04:33:49 <lambdabot>                           or `Data.VectorSpace.magnitude', imported from Data.VectorSpace
04:33:57 <mekeor> :t Data.Complex.magnitude
04:33:58 <lambdabot> forall a. (RealFloat a) => Complex a -> a
04:34:13 <mekeor> shit. magnitude requires RealFloat…
04:34:19 * ski tends to think of type classes as predicates rather than sets, but to each their own
04:34:49 <mekeor> (because of sqrt)
04:34:52 <mekeor> :t sqrt
04:34:53 <lambdabot> forall a. (Floating a) => a -> a
04:35:03 <ski>   instance RealFloat a => Num (Complex a)
04:35:04 <mekeor> does lambdabot have :info or so?
04:35:14 <ski> not really
04:35:18 <mekeor> ok
04:35:23 <ski> it has `src' and `index'
04:35:29 <ddarius> ski: I agree but then I don't know why you find "subrelation" okay.
04:35:32 <ski> (and `source', but i think that's broken)
04:35:51 <rostayob> Some guy posted a blog post about doing completion with tries, I posted this: http://www.reddit.com/r/programming/comments/q5dz2/roll_your_own_fast_completion_and_correction/
04:35:57 <ddarius> Hoogle usually works as a better, albeit noisier, @index.
04:36:22 <ski> hoogle doesn't list instances, iirc
04:36:31 <ski> @instances Ord
04:36:32 <lambdabot> (), (a, b), (a, b, c), (a, b, c, d), (a, b, c, d, e), All, Any, Bool, Char, Double, Dual a, Either a b, First a, Float, Int, Integer, Last a, Maybe a, Ordering, Product a, Sum a, [a]
04:36:38 <ski> @instances-importing Data.Complex Ord
04:36:39 <lambdabot> (), (a, b), (a, b, c), (a, b, c, d), (a, b, c, d, e), All, Any, Bool, Char, Double, Dual a, Either a b, First a, Float, Int, Integer, Last a, Maybe a, Ordering, Product a, Sum a, [a]
04:36:48 <ski> that doesn't show the context, though
04:37:06 <ski> @instances-importing Data.Complex Num
04:37:06 <lambdabot> Complex a, Double, Float, Int, Integer
04:37:11 <ski> (i rather meant)
04:38:22 <ddarius> @src Complex abs
04:38:22 <lambdabot> Source not found. :(
04:38:25 <ddarius> @src abs Complex
04:38:25 <lambdabot> Source not found. There are some things that I just don't know.
04:38:35 <ddarius> @src abs
04:38:35 <lambdabot> Source not found. Just what do you think you're doing Dave?
04:38:38 <ski> ddarius : i suppose it depends on how you interpret relation (e.g. as a subset of a cartesian) -- i was thinking of it in the sense of `R(x,y,z)' rather than `(x,y,z) \in R' above
04:39:23 <hpc> @src Integer abs
04:39:24 <lambdabot> Source not found. It can only be attributed to human error.
04:41:33 <mekeor> Why is 'abs' in Num ?
04:41:52 <ddarius> Cuz.
04:41:57 <mekeor> ah, okay.
04:42:01 <mekeor> got it, thanks.
04:42:13 <mekeor> ddarius: seriously, why?
04:42:55 <ddarius> There is no reason.  The original Haskell numerical hierarchy was inspired by Scheme/Lisp's but if you want to know why you'd have to ask someone twenty years ago.
04:43:40 <ski> mayhaps augustss would remember
04:43:48 <ski> preflex: xseen augustss
04:43:48 <preflex>  augustss was last seen on freenode/#haskell 108 days, 12 hours, 11 minutes and 40 seconds ago, saying: > div (-1) 2
04:43:57 <mekeor> ddarius: so, 'abs' doesn't neccessarily be defined in the Num class, right?
04:44:20 <ddarius> Having abs (and signum and other methods) in Num actually causes problems.
04:44:20 <mekeor> who's that, ski?
04:44:35 * mekeor agrees with ddarius 
04:44:51 <mekeor> > div (-1) 2
04:44:52 <lambdabot>   -1
04:44:59 <ddarius> > quot (-1) 2
04:45:00 <lambdabot>   0
04:45:07 <ChristianS> hm, some types of numbers (e.g. complex numbers) don't have a total ordering, but still a well-defined abs. so i suppose that's the reason that abs is in Num?
04:45:31 <ChristianS> "if you don't know how to calculate abs, don't make it a number" -- or something like that...
04:45:40 <ddarius> abs for Complex numbers should go C -> R
04:45:41 <ski> mekeor : Lennart Augustsson. one of the designers. implementor of the Haskell B compiler (first implementation). has blog at <http://augustss.blogspot.com/>
04:46:24 <mekeor> ski: was there a Haskell A compiler, too? =)
04:46:24 * ski str some paper named "History of Haskell" or somesuch, as well. you might try checking it
04:46:33 <ddarius> mekeor: No.
04:46:37 <mekeor> :)
04:47:14 * ski wonders about `abs' for `p'-adic number
04:47:46 * ddarius will leave it as an exercise for mekeor to find out why hbc is named the way it is.
04:48:07 <ddarius> ski: id
04:48:43 * mekeor doesn't know p-adic numbers (although he's in #math, too)
04:49:38 * ski considers spoiling the exercise
04:49:42 <ddarius> Freenode #math is homework help for basic calculus and linear algebra.
04:50:10 <ski> some probability theory, today
04:50:12 <ChristianS> while Freenode #haskell is homework help for haskell newbies, right?
04:50:23 <ddarius> ChristianS: Occasionally.
04:50:28 <chu> sometimes they talk about, for instance, zfc in #math
04:50:43 <Nereid> ddarius: nah, freenode #math (now ##math) is anything math.
04:50:46 <Nereid> at any level really
04:51:09 <mekeor> is there a better, non-freenode, math-channel?
04:51:10 <ddarius> Nereid: I've been in #math (and #not-math).  Admittedly, this was a long while ago.
04:51:22 <ddarius> I hear the EFNet #math is good, but I've never been there.
04:51:36 <mekeor> ddarius: now, you, Derek Elkins, are in ##categorytheory, right?
04:51:56 <ski> ChristianS : that, and discussing category theory, type theory, Bird-Meertens formalism and possibly some more things
04:53:11 <Nereid> abs for p-adic numbers should obviously return their p-adic absolute value. too bad that's not a p-adic number.
04:53:15 <Nereid> well
04:53:25 <Nereid> oops, it's not a p-adic integer.
04:53:26 <ski> well, what is it, then ?
04:53:41 <Nereid> but in any case it's not good to think of it as a p-adic number.
04:53:43 <ddarius> abs should not be a -> a anyway.
04:53:46 <Nereid> ^
04:53:54 <mekeor> ddarius: instead?
04:54:10 * ski wasn't assuming it was endo
04:54:31 <mekeor> Did you mean: Kendo?
04:54:37 <ski> no
04:54:52 <ddarius> mekeor: abs should be moved out of Num into a (subclass of a) vector space (or module) class.
04:55:09 <ddarius> At which point it should go from v -> s where s is the type of scalars for the vector space.
04:55:18 <ddarius> I understand why they did what they did though.
04:55:51 <Nereid> why who did what?
04:56:08 <mekeor> Nereid: made 'abs' in Num class.
04:56:12 <ddarius> Why abs has the type it has.
04:56:55 <mekeor> ddarius: is there a class for vector space in haskell?
04:57:10 <Nereid> mekeor ☃ there's a library with a bunch of these things in them
04:57:11 <KitB_> Is there a library that will allow me to output coloured text to a standard terminal?
04:57:16 <ddarius> Not in standard Haskell, because the way to do it correctly requires features that haven't been standardized.
04:57:38 <Nereid> vector-space package
04:57:39 <ddarius> There are a bunch of libraries that provide modules and/or vector spaces via classess or other means all over the place.
04:57:43 <Nereid> for instance
04:57:51 <mekeor> KitB: NCurses?
04:58:06 <ddarius> KitB: grep hackage.  There are a few options.
04:58:19 <KitB> ddarius: I have been, I'm not actually sure what to look for :/
04:59:03 <mgsloan> http://hackage.haskell.org/package/vector-space-0.8.0 seems to be the most used
04:59:15 <KitB> I just realised I'm searching for "colour" only
04:59:56 <mgsloan> oh, nvm
05:00:15 * ski recalls in old Hugs there was an `AnsiScreen' and `AnsiInteract' module -- no color there, though
05:02:39 <ddarius> @hackage wl-pprint-terminfo
05:02:39 <lambdabot> http://hackage.haskell.org/package/wl-pprint-terminfo
05:02:41 <ddarius> @hackage vty
05:02:41 <lambdabot> http://hackage.haskell.org/package/vty
05:02:43 <mekeor> why are there so much type classes for floating stuff? RealFrac, Fractional, Floating, Rational… does that have a sense?
05:03:27 <ski> @hackage ansi-terminal
05:03:27 <lambdabot> http://hackage.haskell.org/package/ansi-terminal
05:03:27 <ddarius> Yes, Rational numbers and IEEE754 floating point numbers are very different.
05:03:32 <ski> @hackage hscolour
05:03:32 <lambdabot> http://hackage.haskell.org/package/hscolour
05:04:30 <ski> @hackage AC-Terminal
05:04:30 <lambdabot> http://hackage.haskell.org/package/AC-Terminal
05:04:39 * ski has used none of these
05:05:05 <tomodo> I can't compile Coq!
05:05:14 <ddarius> @hackage ansi-wl-pprint
05:05:14 <lambdabot> http://hackage.haskell.org/package/ansi-wl-pprint
05:05:20 <ddarius> tomodo: Doesn't sound like a Haskell problem.
05:05:31 * ski wonders whether tomodo maybe wants #coq or #ocaml
05:05:47 <mekeor> ddarius: so, Floating is IEE754?
05:06:28 <KitB> ddarius: Sorry, yes. Once I started searching for "color" rather than "colour" I found most of those
05:06:32 <KitB> Thanks
05:06:50 <mekeor> ddarius: [ ] Yes     [ ] No
05:07:10 <ski> [*] No
05:07:23 <tomodo> help
05:07:35 <mekeor> does haskell have an IEE754-type?
05:07:49 <ddarius> mekeor: In theory, no.  In practice, yes.
05:08:00 <ddarius> @src Floating
05:08:00 <lambdabot> class  (Fractional a) => Floating a  where
05:08:00 <lambdabot>     pi                                                      :: a
05:08:00 <lambdabot>     exp, log, sqrt, sin, cos, tan                           :: a -> a
05:08:00 <lambdabot>     asin, acos, atan, sinh, cosh, tanh, asinh, acosh, atanh :: a -> a
05:08:00 <lambdabot>     (**), logBase                                           :: a -> a -> a
05:08:23 <mekeor> ddarius: isn't it usually inverse? in theory yes, in practice not? :)
05:08:28 <ddarius> @src RealFloat
05:08:28 <lambdabot> Source not found. Sorry about this, I know it's a bit silly.
05:08:38 <mekeor> ddarius: seriously, how do you mean exactly?
05:09:04 <mekeor> :t NaN
05:09:04 <lambdabot> Not in scope: data constructor `NaN'
05:09:25 <mekeor> > 0/0
05:09:26 <lambdabot>   NaN
05:09:31 <mekeor> :t 0/0
05:09:32 <lambdabot> forall t. (Fractional t) => t
05:09:56 <mekeor> is lambdabot kidding me?  why does ':t NaN' not work?
05:10:10 <MagneticDuck> > @src Fractional
05:10:11 <lambdabot>   <no location info>: parse error on input `@'
05:10:22 <MagneticDuck> @src Fractional
05:10:22 <lambdabot> class  (Num a) => Fractional a  where
05:10:22 <lambdabot>     (/)             :: a -> a -> a
05:10:22 <lambdabot>     recip           :: a -> a
05:10:22 <lambdabot>     fromRational    :: Rational -> a
05:10:22 <ddarius> mekeor: NaN would be a constructor if it was a value, which it is not.
05:10:34 <ddarius> :t isIEEE
05:10:35 <lambdabot> forall a. (RealFloat a) => a -> Bool
05:11:09 <MagneticDuck> Then what the heck is NaN? Is it some built in thing?
05:11:12 <mekeor> ddarius: ah, so isIEEE refers to IEE754, okay…
05:11:33 * mekeor repeats MagneticDuck's question.
05:11:36 <ddarius> MagneticDuck: It is how the show instance for Double/Float shows the NaN value(s) defined in IEEE754
05:11:45 <ski> > read "NaN :: Float
05:11:46 <lambdabot>   <no location info>:
05:11:46 <lambdabot>      lexical error in string/character literal at end o...
05:11:48 <ski> > readFloat "NaN"
05:11:49 <lambdabot>   [(NaN,"")]
05:11:57 <ski> > read "NaN" :: Float  -- er
05:11:58 <lambdabot>   NaN
05:12:07 <ski> interesting
05:12:12 <ddarius> All those people who want tell you that show outputs "valid Haskell" or is supposed to are lying/wrong.
05:12:28 <MagneticDuck> Okay, what's IEEE754? I've never heard of anything like this.
05:12:53 <MagneticDuck> BTW, I'm a bit late to the conversation. Sorry!
05:12:53 * ski is lying/wrong
05:13:02 <mekeor> @wiki IEEE_754
05:13:02 <lambdabot> http://www.haskell.org/haskellwiki/IEEE_754
05:13:09 <mekeor> no, i meant wikipedia…
05:13:09 <MagneticDuck> Thanks!
05:13:18 <mekeor> MagneticDuck: http://en.wikipedia.org/wiki/IEEE_754
05:13:22 <ski> @where floating-point
05:13:22 <lambdabot> "What Every Programmer Should Know About Floating-Point Arithmetic" at <http://floating-point-gui.de/> and "What Every Computer Scientist Should Know About Floating-Point Arithmetic" by David
05:13:22 <lambdabot> Goldberg in 1991 at <http://docs.sun.com/source/806-3568/ncg_goldberg.html> and <citeseer.ist.psu.edu/viewdoc/summary?doi=10.1.1.102.244>
05:13:26 <MagneticDuck> Oh. Thanks again.
05:14:38 <mekeor> ski: that's somehow a big bunch what a haskeller has to know…
05:15:55 <MagneticDuck> Oh, so IEEE compliant numbers can be passed around between languages, and everyone treats them the same. Cool.
05:16:39 <MagneticDuck> Am I correct? I didn't read the whole article.
05:17:04 <ddarius> I don't believe IEEE754 defines a external format, so you can't pass them between languages naively.
05:17:26 <MagneticDuck> Oh, but on the wikipedia page it states: "interchange formats: encodings (bit strings) that may be used to exchange floating-point data in an efficient and compact form"
05:17:38 <MagneticDuck> As one of the standards defined by IEEE
05:17:43 <ddarius> The important things is that there are a -lot- of arbitrary decisions that need to be made to represent floating point numbers on a computer and IEEE754 defines one virtually universal way.
05:18:11 <MagneticDuck> Yeah
05:20:26 <ChristianS> > show (0.0/0.0)
05:20:27 <lambdabot>   "NaN"
05:20:36 <MagneticDuck> Okay, got that. When would you use an infinity?
05:20:36 <ChristianS> > read "NaN" :: Double
05:20:37 <lambdabot>   NaN
05:20:54 <MagneticDuck> > NaN
05:20:55 <lambdabot>   Not in scope: data constructor `NaN'
05:20:59 <MagneticDuck> Okay, so...
05:21:03 <MagneticDuck> > NaN :: Double
05:21:04 <lambdabot>   Not in scope: data constructor `NaN'
05:21:09 <ChristianS> show is supposed to produce output that read can read (if not valid haskell), so that works at least
05:21:18 <ChristianS> > (1/0.0)
05:21:19 <lambdabot>   Infinity
05:21:36 <MagneticDuck> *ahem*
05:22:12 <ski> > log (-1) :: Complex CReal
05:22:13 <lambdabot>   0.0 :+ 3.1415926535897932384626433832795028841972
05:22:37 <MagneticDuck> Anyway, can you assign NaN and Infinity inside Haskell code? Like myDivide a b = (if b == 0 then Nan else a / b)
05:22:43 <mekeor> MagneticDuck: NaN is not a data constructor.
05:22:57 <ski> no, you have to write something like `0 / 0', &c.
05:23:05 <MagneticDuck> Hmm.
05:23:09 <mekeor> or 'read "NaN"'
05:23:20 <ski> *nod*
05:23:48 <ddarius> Floating point numbers may not have NaN or Infinity.
05:24:47 <MagneticDuck> So it's not custom to trigger NaN, if, say, I have a numerical function that wouldn't crash, but I want to convey that the function didn't work?
05:25:02 <MagneticDuck> For instance, one of the parameters isn't inside a certain bounds?
05:25:11 <mekeor> is there a standard function like that 'nearlyEqual' on http://floating-point-gui.de/errors/comparison/ in haskell?
05:25:17 <MagneticDuck> Although I know that's a pretty horrible thing to do in Haskell. :)
05:26:00 <ddarius> MagneticDuck: You can, you are just assuming (or you can check with isIEEE) that the numbers are IEEE754 numbers.  Haskell can't make that assumption so it can provide nan or infinity because they may not exist.
05:26:30 <ddarius> @google haskell interval arithmetic
05:26:32 <lambdabot> http://www.haskell.org/haskellwiki/Libraries_and_tools/Mathematics
05:26:32 <lambdabot> Title: Applications and libraries/Mathematics - HaskellWiki
05:26:49 <mekeor> ddarius: that's for me?
05:27:24 <MagneticDuck> Alright. So, bringing us back to the discussion earlier on that I missed about checking for IEEE compliance.
05:29:48 <MagneticDuck> Well... if nobody else is talking, it's time for my silly question about Monads. Note that I'm just learning them.
05:30:55 <osa1> where can I see State monad's source?
05:31:12 <MagneticDuck> So, for instance I want to make a little console program that will remember a number, and display it whenever you enter "display," and also bump it up one when you enter "up". I can do that fairly simply with a recursive IO "loop", but could somebody explain to me how to do that with Monads?
05:32:12 <ddarius> MagneticDuck: You are assuming this is something that can or should be "solved" with monads.
05:32:23 <MagneticDuck> Well, I just kind of think so.
05:32:42 <MagneticDuck> I suppose the monad would be a package containing the last integer value.
05:33:01 <ChristianS> MagneticDuck: in haskell, you usually "convey that the function didn't work" by returning  Maybe a  instead of  a , and Nothing if it fails
05:33:07 <ski> MagneticDuck : `StateT Integer IO', use `put' and `get' for the state and `liftIO' for I/O will do
05:33:31 <ChristianS> or m a instead of Maybe a, calling fail ... when the function fails. than it can be called in the context of any monad.
05:34:05 <ddarius> :t maybe mzero return
05:34:06 <lambdabot> forall (m :: * -> *) a. (MonadPlus m) => Maybe a -> m a
05:34:12 * ski doesn't like `fail'
05:34:15 <ddarius> :t maybe zero pure
05:34:15 <lambdabot> Not in scope: `zero'
05:34:20 <ddarius> @src Alternative
05:34:20 <lambdabot> class Applicative f => Alternative f where
05:34:20 <lambdabot>     empty :: f a
05:34:20 <lambdabot>     (<|>) :: f a -> f a -> f a
05:34:27 <ddarius> :t maybe empty pure
05:34:27 <lambdabot>     Ambiguous occurrence `empty'
05:34:28 <lambdabot>     It could refer to either `Control.Applicative.empty', imported from Control.Applicative
05:34:28 <lambdabot>                           or `Text.Regex.Posix.empty', imported from Text.Regex.Posix at State/L.hs:55:0-22
05:34:40 <ddarius> Touche
05:35:04 <ski> @type maybe Control.Applicative.empty pure
05:35:05 <lambdabot> forall (f :: * -> *) a. (Alternative f) => Maybe a -> f a
05:36:29 <ski> MagneticDuck : well, i suppose `modify' is nicer than `put' here ..
05:37:13 <ski> @type modify (1 +) :: StateT Integer IO ()
05:37:14 <lambdabot> StateT Integer IO ()
05:38:24 <MagneticDuck> Okay. This state monad is storing the value... and also IO.
05:38:38 <MagneticDuck> modify is a function that applies a function to the State monad.
05:38:52 <Botje> w 23
05:38:53 <Botje> argh
05:39:02 <MagneticDuck> That is, the state. The integer only.
05:39:26 <ski> yep
05:39:51 <MagneticDuck> Okay... (I'm a real newbie when it comes to Monads. Hoping to change that...)
05:39:53 <ski> @type modify `asTypeIn` \modify -> modify (1 +) :: StateT Integer IO ()
05:39:53 <lambdabot> (Integer -> Integer) -> StateT Integer IO ()
05:40:03 <MagneticDuck> So, how would main look?
05:40:13 <ski> @type (1 +) `asTypeIn` \up -> modify up :: StateT Integer IO ()
05:40:14 <lambdabot> Integer -> Integer
05:40:26 <MagneticDuck> ...and what's asTypeIn?
05:40:39 <ddarius> ski: What's nicer than modify is doing the way MagneticDuck already did it.
05:40:42 <opqdonut> :t asTypeIn
05:40:43 <lambdabot> forall a b. a -> (a -> b) -> a
05:41:02 <ski>   main = (`runStateT` initialState) $ do
05:41:04 <ski>     ...
05:41:13 <ski> ddarius : i agree
05:41:28 <MagneticDuck> Yeah, in this case recursion in as "IO loop" is simpler to understand. I think.
05:41:48 <MagneticDuck> But I'm trying to learn Monads to apply them to more complex problems.
05:41:55 <ddarius> It's simpler/"better" in pretty much every way.
05:41:56 <ski> MagneticDuck : `asTypeIn' is just a trick to ask lambdabot what the type of `modify' or `(1 +)' in the above example had in that particular expression
05:42:51 <MagneticDuck> So, it will find the type of part of an expression, without modifying it too much? (And the return of the function will now be the  type.)
05:43:06 <ski> @type map `asTypeIn` \map -> map ord "False"
05:43:07 <lambdabot> (Char -> Int) -> [Char] -> [Int]
05:43:19 <MagneticDuck> @type asTypeIn
05:43:20 <lambdabot> forall a b. a -> (a -> b) -> a
05:43:33 <albel727> :src asTypeIn
05:43:40 <designmac> does anyone here use leksah IDE on debian (i know there is a separate channel for leksah but there was no activity there)
05:43:49 <ski> @src asTypeIn
05:43:49 <lambdabot> a `asTypeIn` f = a where _ = f a
05:43:49 <albel727> @src asTypeIn
05:43:49 <lambdabot> infixl 0 `asTypeIn`
05:43:49 <lambdabot> a `asTypeIn` f = a where _ = f a
05:43:49 <lambdabot> infixl 0 `asTypeIn`
05:43:53 <ski> @src asAppliedTo
05:43:53 <lambdabot> Source not found. Wrong!  You cheating scum!
05:43:58 <ski> bah
05:44:01 <ski> @type asAppliedTo
05:44:01 <lambdabot> forall t b. (t -> b) -> t -> t -> b
05:44:07 <MagneticDuck> Alright. More coordination here, guys!
05:44:12 <covi> Hi all! I have a string like "ABCDEFGHI", and I want to process "ABC", "BCD", "CDE", and so on. What's the method to go?
05:44:20 <ski>   f `asAppliedTo` a = f `asTypeIn` ($ x)
05:44:27 <ski> (s/x/a/)
05:44:35 <niteria> :t zip3
05:44:35 <lambdabot> forall a b c. [a] -> [b] -> [c] -> [(a, b, c)]
05:44:39 <MagneticDuck> covi: I needed to do that just yesterday
05:44:59 <ski> MagneticDuck : "it will find .." -- something like that, yes
05:45:18 <covi> MagneticDuck: how did you approach it?
05:46:00 <MagneticDuck> Well, I used a recursive function that took a certain amount of elements from the string, if the string had more than n elements, and otherwise, just returned the string.
05:46:01 <ski> covi : `Data.List.Split.chunk'
05:46:04 <ski> @hackage split
05:46:04 <lambdabot> http://hackage.haskell.org/package/split
05:46:08 <ddarius> > map (take 3) . tails $ "ABCDEFGHI"
05:46:09 <lambdabot>   ["ABC","BCD","CDE","DEF","EFG","FGH","GHI","HI","I",""]
05:46:12 <MagneticDuck> ...or that, ski
05:46:43 <covi> ddarius: nice! I'll do this
05:46:46 <covi> thank you all
05:46:55 <MagneticDuck> However, if you're a beginner, I'd recommend doing it on your own. :)
05:47:14 <ski> covi : note the end
05:47:22 <niteria> > let a = "ABCDEFGHI" in map (\(a, b, c) -> a:b:[c]) $ zip3 a (tail a) (tail $ tail a)
05:47:23 <lambdabot>   ["ABC","BCD","CDE","DEF","EFG","FGH","GHI"]
05:47:27 <ski> .. oh
05:47:32 <MagneticDuck> Yeah. Remember the edge condition.
05:47:45 <MagneticDuck> Oh, wow. Let me try to think about that...
05:48:02 <ski> covi : oh, sorry, `chunk' doesn't do exactly that
05:48:02 <MagneticDuck> Cool!
05:48:12 <covi> ski: okay
05:48:42 <covi> I guess I'll do ddarius's method. Because the seperated elements in my case should have a length of 5
05:48:53 <MagneticDuck> BTW, I needed that code the other day because I was making a program that read a number out, that is, 1234 becomes "one thousand and two hundred fourty four"
05:48:59 <ski> (`chunk "ABCDEFGHIJ"' would be `["ABC","DEF","GHI","J"]')
05:49:21 <MagneticDuck> I'll post the code if anyone's interested.
05:49:47 <niteria> @hoogle (a, a, a) -> [a]
05:49:47 <lambdabot> Data.Typeable typeOf3 :: Typeable3 t => t a b c -> TypeRep
05:49:47 <lambdabot> Data.Typeable typeOf2Default :: (Typeable3 t, Typeable a) => t a b c -> TypeRep
05:50:04 <ddarius> It shouldn't be "one thousand and two hundred ..."
05:50:32 <MagneticDuck> Yeah, it was actually "one thousand two hundred..."
05:50:35 <MagneticDuck> Typo
05:50:56 <albel727> @type chunk
05:50:57 <lambdabot> Not in scope: `chunk'
05:51:19 <MagneticDuck> You need to load Data.List.Split.chunk
05:51:20 <ski>   Data.List.Split.chunk :: Int -> [e] -> [[e]]
05:52:28 <MagneticDuck> Yeah, in my program, I would need the reverse of chunk. (Just apply reverse once inside the parameters and once on the result)
05:53:04 * albel727 wanted to think up a solution roughly based on concat (chunk x) (chunk (take 1 x)) (chunk (take 2 x))
05:53:49 <albel727> @src Typeable
05:53:50 <lambdabot> Source not found. My pet ferret can type better than you!
05:53:59 <albel727> -_-
05:54:02 <MagneticDuck> lambdabot has an attitude
05:54:12 <albel727> issues
05:54:14 <MagneticDuck> ...and a pet ferret?
05:54:30 <albel727> that's just imaginary friend, I bet.
05:55:03 <MagneticDuck> @src Typeable
05:55:04 <lambdabot> Source not found. stty: unknown mode: doofus
05:55:17 <MagneticDuck> Wow! Does he know insults!
05:55:33 <MagneticDuck> And that's one heck of an error.
05:56:19 <MagneticDuck> BTW, does anyone know if you can get lambdabot onto your computer, or does he live in the server?
05:56:32 <MagneticDuck> And where is his code?
05:56:34 <ddarius> @version
05:56:34 <lambdabot> lambdabot 4.2.2.1
05:56:35 <lambdabot> darcs get http://code.haskell.org/lambdabot
05:56:47 <albel727> wow
05:56:47 <MagneticDuck> Thanks! This will be fun.
05:56:51 <albel727> indeed.
05:57:04 <MagneticDuck> Just wondering.
05:58:53 <MagneticDuck> BTW, I always loved the fact that even the biggest Haskell programs have the tiniest main declaration. Makes it so easy to read.
05:59:05 <MagneticDuck> ...unless they're making a GUI.
05:59:26 <MagneticDuck> BTW, did I just scare everybody away?
05:59:33 <albel727> hehe
05:59:45 <albel727> oh no, what have I done...
05:59:51 * albel727 runs in terror.
06:00:13 <MagneticDuck> Everybody's leaving! Quick! Make useful conversation on Monads!
06:00:41 <MagneticDuck> Anyway...
06:01:24 <otters> I once cured leukemia using nothing but a single monad
06:01:34 * albel727 hears THE WORD WHICH MUST NOT BE SAID, and starts to run even faster.
06:01:43 <albel727> s/SAID/UTTERED/
06:01:57 <MagneticDuck> Hehe, otters!
06:02:06 <otters> I mean the file didn't even do anything
06:02:12 <otters> I just defined the datatype and the Monad instance
06:02:12 <otters> and bam
06:02:19 <covi> Can you please check out this code: http://hpaste.org/64315? The error occurs in line 7.
06:02:28 <MagneticDuck> Sure! On it.
06:02:32 <ski> @type ($ []) .:: (.: (:)) .: (.: (:)) . (:)
06:02:32 <lambdabot> forall a. a -> a -> a -> [a]
06:02:34 <ski> @type ($ []) .:: (.: (:)) .: (.: (:)) . (.: (:)) id
06:02:35 <lambdabot> forall a. a -> a -> a -> [a]
06:02:35 <covi> Seems something's wrong with the where
06:03:05 <mekeor> is .: a lambdabot-feature?
06:03:11 <MagneticDuck> Ow, my eyes... please use indents! No offense, lots of people do it.
06:03:12 <ski> @src (.:)
06:03:12 <lambdabot> Source not found. My pet ferret can type better than you!
06:03:13 <ski> yep
06:03:20 <ski> bah
06:03:21 <mekeor> ah, now. i got it.
06:03:26 <ski>   (.:) = (.) . (.)
06:03:30 <ski>   (.::) = (.) . (.) . (.)
06:03:31 <mekeor> yep
06:03:35 <mekeor> ah, okay
06:03:36 <ski> (all `infixr 9')
06:03:51 <covi> MagneticDuck: I also want to make my code readable... but I'm not sure how to indent in this case :(
06:03:55 <mekeor> :t (.) . (.) . (.)
06:03:56 <lambdabot> forall (f :: * -> *) (f1 :: * -> *) a b (f2 :: * -> *). (Functor f, Functor f1, Functor f2) => (a -> b) -> f (f1 (f2 a)) -> f (f1 (f2 b))
06:04:01 <mekeor> :t (.) . (.)
06:04:02 <lambdabot> forall (f :: * -> *) a b (f1 :: * -> *). (Functor f, Functor f1) => (a -> b) -> f (f1 a) -> f (f1 b)
06:04:09 <ski> @type let (.) = (Prelude..) in (.) . (.)
06:04:10 <lambdabot> forall a b c a1. (b -> c) -> (a -> a1 -> b) -> a -> a1 -> c
06:04:11 <ski> @type let (.) = (Prelude..) in (.) . (.) . (.)
06:04:12 <lambdabot> forall a a1 b c a2. (b -> c) -> (a -> a1 -> a2 -> b) -> a -> a1 -> a2 -> c
06:05:09 <ski>   (f . g) a = f (g a)
06:05:15 <ski>   (f .: g) a b = f (g a b)
06:05:20 <ski>   (f .:: g) a b c = f (g a b c)
06:05:41 <covi> MagneticDuck: the num is a very long string. But splitting it on multiple lines with '\' or '\\' seems not to work
06:05:52 <albel727> oh my god, it's full of dots.
06:06:29 <ski> > (^ 2) .:: [[Just 0,Nothing],[Nothing,Just 2,Just 3],[Just 4,Nothing]]  -- works because Cale did `(.) = fmap' in lambdabot
06:06:31 <lambdabot>   [[Just 0,Nothing],[Nothing,Just 4,Just 9],[Just 16,Nothing]]
06:07:15 <MagneticDuck> Yeah, I usually use something like
06:07:20 <MagneticDuck> str = "hello world"
06:07:25 <MagneticDuck>    + "more string..."
06:07:32 <MagneticDuck> sorry, typo, I meant ++
06:07:54 <ski>   str = "hello world\
06:07:55 <ski>         \more string..."
06:08:03 <covi> MagneticDuck: okay. The function the foldl uses is also a bit long...
06:08:08 <covi> ski: ahh, thx!
06:08:08 <ddarius> > "foo\                                                                \bar"
06:08:10 <lambdabot>   "foobar"
06:08:15 <ski> > "hi\     \ over there"
06:08:16 <lambdabot>   "hi over there"
06:08:26 <MagneticDuck> Yeah, I didn't know about that either!
06:08:44 <ddarius> I don't think anyone uses that feature.
06:08:53 * ski uses it, sometimes
06:09:09 <MagneticDuck> No?
06:09:13 <MagneticDuck> It seems pretty cool.
06:10:00 <Ngevd> Well, I fixed the problem I was having yesterday
06:10:07 <ddarius> > "\9595"
06:10:07 <lambdabot>   "\9595"
06:10:17 <albel727> it does. especially the part, where you are not required to start the string immediately after newline.
06:10:22 <albel727> *does look cool
06:10:58 <albel727> (which obviously has roots in indentation-for-semantics)
06:11:22 <ddarius> > "foo\ {- bar -} \baz"
06:11:23 <lambdabot>   <no location info>:
06:11:23 <lambdabot>      lexical error in string/character literal at chara...
06:11:41 <ski> > (all (("" ==) . read . ("\"\\" ++) . (: "\\\"")) . filter isSpace) [minBound .. maxBound]
06:11:42 <lambdabot>   True
06:12:24 <covi> MagneticDuck: can you tell me what's wrong with my code?
06:12:52 <MagneticDuck> I'm working on it... almost done!
06:12:58 <covi> ski: vim does not color the "str\  \str" style correctly...
06:13:02 <covi> MagneticDuck: thank you so much
06:13:21 * ski doesn't know about vim ...
06:14:10 <covi> what editor do you use to code
06:14:54 <MagneticDuck> Me? I use... um... well anything, really.
06:15:00 <mekeor> covi: emacs with haskell-mode, that's fine.
06:15:00 <MagneticDuck> I'm almost done...
06:15:23 * covi don't know nothing about emacs.
06:15:27 * covi uses vim.
06:16:21 <MagneticDuck> Alright, so, the main problem with your code is that when you're going folding through a string, the function is only going to be passed char - by - char. You can't use multiple ones.
06:16:32 <MagneticDuck> You have to break it up first.
06:16:44 <MagneticDuck> Or, no, you can't do that...
06:16:52 <ski> > (all isSpace . filter (maybe False (uncurry (&&) . join (***) ("" ==)) . listToMaybe . reads . ("\"\\" ++) . (: "\\\""))) [minBound .. maxBound]
06:16:56 <lambdabot>   mueval-core: Time limit exceeded
06:17:04 <ski> hmpf
06:17:14 <covi> MagneticDuck: so you're saying (a:b:c:d:e:st) fails?
06:17:19 <MagneticDuck> you have to make a list of all the possible chunks of string that you could process.
06:17:23 <MagneticDuck> yes, that's right.
06:17:41 <MagneticDuck> remember, foldl is of type:
06:17:46 <MagneticDuck> @type foldl
06:17:46 <lambdabot> forall a b. (a -> b -> a) -> a -> [b] -> a
06:18:10 <MagneticDuck> Yeah. You function have to take the type of element in the list.
06:18:33 <MagneticDuck> So, your list must have type [[String]] in order to work for this problem.
06:18:48 <MagneticDuck> No, [String]
06:18:50 <MagneticDuck> Sorry
06:19:12 <MagneticDuck> Hope that helps!
06:19:39 <covi> MagneticDuck: ty so much!
06:19:52 <covi> @type groupBy
06:19:52 <MagneticDuck> Glad to be of help!
06:19:52 <lambdabot> forall a. (a -> a -> Bool) -> [a] -> [[a]]
06:20:09 <MagneticDuck> Nope, that doesn't work for this case.
06:20:29 <covi> yeah, I'll just use map (take 5) . tails $ num and handle the edge conditions
06:21:45 <MagneticDuck> That is, tail. No s. Typo, I know.
06:22:09 <covi> MagneticDuck: tails. tail only return 1 list.
06:22:27 <MagneticDuck> Ah, yeah. And I'm trying to be the teacher here!
06:22:53 <MagneticDuck> Well, I'm a newbie too.
06:23:07 <covi> MagneticDuck: :) thank you so much. Learning haskell has quite a curve for me
06:23:26 <ski> > (init . tails) "abcd"
06:23:28 <lambdabot>   ["abcd","bcd","cd","d"]
06:23:41 <MagneticDuck> Yeah, you have to handle the end.
06:24:18 <MagneticDuck> At the end, you have to make sure to break off before your string gets smaller and the pattern match crashes.
06:24:22 <covi> MagneticDuck: the ghci reports error on the "where" too.....
06:24:46 <MagneticDuck> Hm, yeah. I'm almost done neatifying it. I'll post it when I'm done.
06:24:58 <covi> MagneticDuck: okay
06:26:21 <ski> > (reverse . drop 3 . reverse . map (take 3) . tails) "abcde"
06:26:22 <ski> > (drop 3 . map (reverse . take 3 . reverse) . inits) "abcde"
06:26:23 <lambdabot>   ["abc","bcd","cde"]
06:26:23 <lambdabot>   ["abc","bcd","cde"]
06:26:29 <ski> `reverse' isn't nice
06:27:15 <covi> ski: yes I exactly do  num' = drop 5 . reverse . map (take 5) . tails $ num
06:27:20 <MagneticDuck> Where do I post it to that online clipboard?
06:27:28 <MagneticDuck> ...that's awesome?
06:27:30 <covi> MagneticDuck: hpaste.org
06:27:35 <MagneticDuck> Thanks
06:28:08 <hpaste> MagneticDuck pasted “Huge Number” at http://hpaste.org/64316
06:28:15 <MagneticDuck> http://hpaste.org/64316
06:28:26 <MagneticDuck> Hope that works!
06:28:33 <MagneticDuck> Well, I tested it.
06:29:10 * ski would break the line before `where'
06:30:02 <ski> also, `(D a)' can be written as `D a', also `D' can't start with an uppercase letter
06:30:12 <MagneticDuck> it can?
06:30:27 <MagneticDuck> Oh, yeah.
06:30:34 <MagneticDuck> No, I corrected all of that in the new code.
06:30:36 <MagneticDuck> :)
06:30:51 <covi> ski: why no uppercase
06:30:52 <ski> why not remove the `D's, and replace `num' by `(map digitToInt num)' instead ?
06:31:10 <MagneticDuck> because it's cleaner, at least I think
06:31:12 <ski> (also you can change `st' into `_', if you like)
06:31:25 <MagneticDuck> Where?
06:31:34 <ski> > let D = digitToInt in D '3'  -- covi
06:31:35 <lambdabot>   Not in scope: data constructor `D'Not in scope: data constructor `D'
06:31:44 <ski> MagneticDuck : in the lambda expression
06:31:55 <MagneticDuck> But I use it!
06:32:16 * ski can't see the paste using `st'
06:32:48 <MagneticDuck> Look in the condition in the if statement. :D
06:33:00 <ski>   if product' > acc then ... else ...
06:33:06 <ski> no `st' in there
06:33:14 <covi> head gonna break
06:33:17 <MagneticDuck> Yeah. No, I wrote the *new* code.
06:33:22 <MagneticDuck> It's called "huge number"
06:33:27 <covi> haskell can drive me crazy sometimes...
06:33:34 * ski can see no annotation to this paste
06:33:35 <MagneticDuck> Yeah. Sorry. :)
06:33:45 <ski> .. oh
06:33:49 <MagneticDuck> Hey, ski?
06:33:55 <MagneticDuck> hpaste.org/64316
06:34:01 <covi> Is Haskell the craziest functional programming language?
06:34:10 <MagneticDuck> Maybe. But also the most awesome!
06:34:29 <ski> MagneticDuck : yeah, apparently i got a mispaste -- i thought i had copied that url and were looking at it
06:34:32 <hpc> covi: i would say the craziest functional programming languages is make
06:34:37 <covi> This thing has the most serious learning curve
06:34:39 <hpc> but haskell is certainly up there :P
06:34:47 <Philippa> not C++ templates?
06:34:56 <MagneticDuck> max . (map awesomeLevel) $ programmingLanguages == "haskell"
06:35:02 <hpc> Philippa: it took oleg to prove that make was turing-complete
06:35:10 <ski> (MagneticDuck : anyway, try to remember next time to *annotate* the original paste, by pressing the "Annotate" button)
06:35:23 <covi> MagneticDuck: shouldn't that be 'maximum'?
06:35:31 <MagneticDuck> Oh, sorry! This is my first time with hpaste
06:35:37 <ski> no worry
06:35:51 <MagneticDuck> And yes, I'm used to 'max' from Mathematica. I'm guilty on all charges!
06:35:59 <Philippa> covi: how many other FPLs do you know?
06:36:13 <covi> Philippa: 0. In total 0 too, for I don't know Haskell.
06:36:35 <Philippa> *nod*. Haskell makes you face the fact you're learning something new, but otherwise the curve's the good kind of sharp
06:36:45 <MagneticDuck> Well, keep on trying! Haskell is awesome once you learn it!
06:36:49 <Philippa> it's just painful until you've got over the sub-linear chunk of it
06:37:09 <covi> But I somehow *feel* this is the thing to learn and play with.
06:37:24 <Philippa> afterwards? You find the rate you can do new stuff at is much faster than expected
06:37:28 <covi> Do you guys all know some mathematics?
06:37:31 <Philippa> yeah, it's certainly well worth knowing
06:37:33 <ben> If I have something like 'do ch <- newChan; replicateM_ n (forkIO $ produceInto ch); replicateM_ m (forkIO $ consumeFrom ch)', what's a robust way to let the consumer threads know when all the producer threads have exited and to not expect input anymore?
06:37:35 <Philippa> sure. 1+1=2
06:38:13 <Philippa> (I first met Haskell on the first year of a compsci degree, I did two A levels in maths here which is similar to having taken some US college courses but difficult to map exactly)
06:38:14 <covi> Philippa: the type signitures in haskell are so math
06:38:18 <MagneticDuck> @covi Well, I'm in 8th grade, but I'm way above the level of school here!
06:38:18 <lambdabot> Unknown command, try @list
06:38:23 <Philippa> actually they're so logic
06:38:26 <Philippa> as in, isomorphic to one
06:38:28 <hpc> covi: i learned the math concepts from haskell, actually :P
06:38:33 <Philippa> but maths is next in line :p
06:38:46 <covi> MagneticDuck: what the hell
06:39:05 <Philippa> Haskell's got a much closer relationship to foundational mathematics than mainstream langs though, certainly
06:39:06 <covi> MagneticDuck: well I'm a high school senior. To be frank. I'm old.
06:39:11 <MagneticDuck> What the h*** what?
06:39:22 <hpc> MagneticDuck: you are really young to know haskell
06:39:47 <Philippa> MagneticDuck: your age. Also, I'm don't think most people find the *s help, but hey :-) Congrats, I was stuck with BASICs at that age
06:39:53 <MagneticDuck> Thank you. :) I try to concentrate on life too, though! Unlike some people I know.
06:39:58 <Philippa> (I knew VB1 once upon a time!)
06:40:20 <MagneticDuck> VB? I knew Pascal before that.
06:40:22 <Philippa> eh. You're concentrating on some parts of it, others on others. You'll learn in time that it's trickier to judge exactly where people're concentrating
06:40:33 <Philippa> yeah, I got taught a little bit of Pascal when I was 7
06:40:48 <MagneticDuck> Yeah. Pascal is pretty readable and easy to learn.
06:40:49 <hpc> i actually learned transistors first
06:40:54 <Philippa> (VB=Visual Basic. If you've managed to avoid it, be happy!)
06:40:58 <MagneticDuck> array of Integer is [Int]
06:40:58 <hpc> then TI BASIC
06:41:09 <ski> covi : Scheme macros is a strange call-by-name functional programming language -- see e.g. the articles around <http://okmij.org/ftp/Scheme/macros.html#Macro-CPS-programming>
06:41:20 <Philippa> hpc: heh. Yeah, I've forgotten what age my first kids' electrical-to-simple-electronics kit was
06:41:30 <MagneticDuck> @hpc: yeah, I've done some of that, too! It's quite fun.
06:41:30 <lambdabot> Unknown command, try @list
06:41:37 <covi> ski: scheme has like infinite amount of parenthesis
06:41:49 <hpc> Philippa: i was 7, and learned it from a full-adder in one of those "how things work" books
06:41:57 <ddarius_> VB.NET is much better than VB6.
06:42:06 <Philippa> hpc: mammoths?
06:42:21 <Philippa> yeah, but so are most sex acts involving cheese graters
06:42:22 <hpc> Philippa: ...it definitely had mammoths
06:42:29 <mm_freak_> Rmx__: no, but it should be straightforward…  there is a gloss peculiarity though…  you can only use pure monads like Kleisli (State s) or Kleisli (Reader e)
06:42:33 <hpc> i forget the title of the book, just that it was awesome
06:42:40 <Philippa> "The Way Things Work", IIRC
06:42:51 <MagneticDuck> Lots of things happen when you're seven, don't they?
06:42:58 <mm_freak_> Rmx__: for example if you use a state monad, then you have to wrap the update function of gloss in a runStateT, because it's a pure function
06:43:02 <hpc> Philippa: hotdamn, that's it
06:43:12 <ddarius_> That said, it's basically VB syntax for C# and C# is already much nicer so there isn't much point to it.
06:43:18 <Philippa> MagneticDuck: sure feels that way at that age, yeah
06:43:22 <ski> covi : which parens ?
06:43:36 <Philippa> ddarius_: helping VB-only coders keep their underwear a little cleaner, mostly
06:43:47 <srhb> Hm, how do I check if my ghc is 64 bit or not?
06:43:54 <mm_freak_> Rmx__: and of course with gloss you will want to use at least simulateInWindow (though it may be named differently now…  the author changed some function names)
06:43:57 <hpc> > maxBound :: Int
06:43:58 <lambdabot>   9223372036854775807
06:44:12 <hpc> srhb: evaluate that -- lambdabot is 64-bit
06:44:15 <mm_freak_> Rmx__: i.e. either simulate or game, but not animate/display
06:44:36 <Saizan> ghc --info
06:44:37 <srhb> hpc: Thanks
06:44:43 <hpc> or what Saizan said lol
06:44:50 <srhb> Both works ;)
06:44:50 <MagneticDuck> Wow. Not this is a whirlpool of messages! Hard to keep track!
06:45:41 <MagneticDuck> Also: I'd like to do some graphics and GUIs... what are the problems with Gloss?
06:45:53 <MagneticDuck> I've heard people say that there are a lot of limitations...
06:46:25 <MagneticDuck> But if I just want to write a little pong game, I can do that, right?
06:46:35 <Philippa> MagneticDuck: it's not the easiest of chans to multitask with, yeah
06:46:53 <ddarius> Gloss is intended for fairly simple graphical applications where you don't need/want to worry about the details.
06:47:05 <MagneticDuck> 'K.
06:47:09 <Philippa> are the SDL bindings bitrotten?
06:47:20 <MagneticDuck> Now, for instance, how easy it is to make a menu with buttons... or something like that?
06:47:21 <ddarius> SDL doesn't change that often.
06:47:25 <Philippa> (I remember them being "fun" to get working well under windows five years or so back)
06:47:53 <ddarius> I don't recall any real trouble using them on Windows or Linux, but it's been a while.
06:47:57 <Philippa> most graphics libs suitable for games don't help you out much with UI elements
06:48:05 <Philippa> you're expected to build your own
06:48:47 <Philippa> I never did see anyone write a nice generalised lib for doing it, it's a minor rite of passage for junior gamedevs I guess
06:48:59 <MagneticDuck> Anyway, bye everyone! Have to go!
06:49:32 <ddarius> My impression is that most games want a fairly unique look and feel to their UI elements (for good and bad reasons.)
06:50:20 <Philippa> the behaviour's fairly generalisable though, and mouse->UI element collision detection can be generalised too
06:51:08 <mm_freak_> magicman: the problem with gloss for larger applications is mainly that it forces you into a pure framework, so you can't even load a game state from disk in the middle of the application
06:51:12 <Philippa> but when your community's traditional langs include C++ and (not /so/ long ago) BASIC, it's not so surprising either
06:51:13 <mm_freak_> oh
06:51:22 <mm_freak_> that was for MagneticDuck
06:51:44 <magicman> It was worse when there was a guy called magicman3 in here a couple of days ago :P
06:52:06 <Philippa> wow, Capcom've really run out of robot names
06:52:45 <hpc> Philippa: RE: megaman? i think they ran out of names before they even started :P
06:52:46 * ski recalls writing games in BASIC
06:53:46 * albel727 too. so nostalgic.
06:54:04 * mekeor not
06:54:13 <Philippa> hpc: c'mon, he was Rockman when they started
06:54:15 <albel727> c-c-combo breaker!
07:01:48 <ski> <http://enfranchisedmind.com/blog/posts/what-programming-language-should-i-use/>
07:02:20 <albel727> is that even a question? haskell, ofc.
07:03:13 <Philippa> I'm not sure I can use Haskell to get ghci running on ARM
07:03:31 <Philippa> I mean, short of having it spit out C or another similar language
07:04:06 <albel727> authored BRIAN HURT. lol
07:07:38 <ben> Someone link me a bunch of cool example code that uses Control.Concurrent.Chan
07:08:35 <Philippa> I would, but I lost it in a particularly stupid incident 6 or so years back
07:08:40 <Philippa> (it was an IRC client)
07:08:54 <sam5> I go ghc.7.4.1 and I am not sure how to import Control.Monad.State
07:09:22 <sam5> it seems that it cannot find module Control.Monad.State
07:09:37 <Philippa> you probably don't have the mtl package?
07:09:46 <Philippa> try cabal update; cabal install mtl
07:10:13 <sam5> oh I see2026 I am trying it now
07:11:29 <sam5> oh it work2026 thanks
07:11:48 <sam5> wait...
07:12:28 <sam5> can I not use State when I import Control.Monad.State?
07:15:32 * edwardk waves hello
07:17:43 <sam6> I wanted to try using state monads so I imported Control.Monad.State but when I use State, I get "data constructor State not in scope"
07:17:56 <sam6> do I have to import something else?
07:18:14 <Saizan> there isn't a State constructor anymore, only StateT
07:18:21 <Saizan> there's a state function though
07:19:10 <sam6> what is the difference of StateT?
07:19:37 <sam6> does it work like State?
07:20:25 <sipa> StateT is a monad trnasformer
07:20:38 <sipa> StateT Id is equal to State
07:22:19 <skchrko> sam6, you can use state instead of State in your code
07:24:05 <sam6> how does state function work?
07:24:21 <skchrko> state f = StateT (Identity . f)
07:24:39 <t7> whats the standard approuch to optimizing lambda calc free variable access? using a stack and an index?
07:25:00 <t7> approach *
07:26:34 <mekeor> so, the basic difference between OOP and types is that in OOP a "class"/"object" contains itself the function (called "method"), right?  whereas in haskell, e.g. the function "defines" which kind of type it gets (and returns).
07:27:11 <ddarius> There isn't a dichotomy between OOP and types.
07:28:00 <nomeata> Hi. Can anyone here tell why my message 1330120967.2800.12.camel@kirk did not make it to the haskell-platform mailing list?
07:28:14 <mekeor> ddarius: you mean no difference?
07:28:51 <dougransom> @pl domain_index d@(low,high) n =  (low +) . ((domain_width d n)  *) . fromIntegral
07:28:52 <lambdabot> (line 1, column 29):
07:28:52 <lambdabot> unexpected "="
07:28:52 <lambdabot> expecting variable, "(", "`", "!!", ".", operator or end of input
07:29:07 <mekeor> nomeata: which mailing list?
07:29:10 <ddarius> I meant what I said.
07:29:30 <nomeata> mekeor:  haskell-platform@projects.haskell.org
07:29:45 <dougransom>   (low +) . ((domain_width d n)  *) . fromIntegral
07:29:54 <mekeor> ddarius: and i don't know what dichotomy is…
07:30:00 <dougransom> @pl        (low +) . ((domain_width d n)  *) . fromIntegral
07:30:00 <lambdabot> (low +) . (domain_width d n *) . fromIntegral
07:30:41 <mekeor> nomeata: no idea. just resend it maybe?
07:31:08 <nomeata> resent
07:32:03 <t7> whats a Ⲡ type and how does it work?
07:32:25 <sipa> a boxed type?
07:32:25 <ddarius> What Pi are you using?
07:32:55 <mekeor> t7: http://en.wikipedia.org/wiki/Product_%28category_theory%29 ?
07:35:29 * ddarius has Android javadoc with source links now.
07:37:03 <mekeor> is pattern matching more than an if-expression?
07:37:42 <ddarius> mekeor: Yes.
07:40:07 <mekeor> ddarius: namely what?
07:41:35 <ddarius> I assume you are asking in what ways pattern matching is more than an if-expression.  The most notable aspect is that it is a binding form.
07:43:07 <mekeor> ddarius: what do you mean by "binding form"?
07:45:07 <dougransom> @pl add_tuple (a1,a2) (b1,b2) = (a1+b1,a2+b2)
07:45:07 <lambdabot> add_tuple = uncurry (flip flip snd . (ap .) . flip flip fst . ((.) .) . (. (+)) . flip . (((.) . (,)) .) . (+))
07:45:37 <mekeor> ah, right. got it.
07:46:30 <ion> > (a,b) + (c,d)
07:46:31 <lambdabot>   (a + c,b + d)
07:47:54 <otters> > (1,2) + (3,4)
07:47:55 <lambdabot>   (4,6)
07:48:00 <otters> @type () +
07:48:01 <lambdabot> parse error (possibly incorrect indentation)
07:48:03 <otters> oh
07:48:13 <mekeor> that's a lambdabot-feature, isn't it, ion?
07:48:52 <otters> @src () +
07:48:52 <lambdabot> Source not found. This mission is too important for me to allow you to jeopardize it.
07:48:54 <otters> ok
07:50:05 <ion> http://hackage.haskell.org/package/NumInstances
07:50:36 <mekeor> neat.
07:51:32 <ion> @where hackage2
07:51:32 <lambdabot> http://code.haskell.org/hackage-server/
07:51:50 <ion> Where was the running instance again?
07:51:56 <hiptobecubic> is there a way to do list comprehensions like [(a1, b1), (a2, b2)...] instead of [(a1,b1), (a1, b2),...(a2,b1)...]
07:52:11 <srhb`> hiptobecubic: How about zipping two list comprehensions
07:52:12 <ion> hiptobecubic: Use zip.
07:52:12 <hiptobecubic> i guess zip the lists and do a single comprehension over that?
07:52:23 <hiptobecubic> srhb`, ion thanks. I guess writing it out made it obvious
07:52:47 <srhb`> hiptobecubic: Well the single comprehension didn't occur to me until I wrote it. :-)
07:53:39 <dougransom> @pl (x* f x, fx)
07:53:39 <lambdabot> (x * f x, fx)
07:53:55 <dougransom> @pl nd x = (x* f x, fx)
07:53:55 <lambdabot> nd = flip (,) fx . ap (*) f
07:54:07 <hiptobecubic> Although, before i retreat, i'll pose the real problem in case i'm doing it stupidly. I need to get all of the combinations of elements in a list. Data.List only seems to have permutations and I'm worried that filtering it will be too slow for enormous lists, is that unreasonable?
07:54:11 <mekeor> > id == concat
07:54:12 <dougransom> @pl nd x = (x* f x, f x)
07:54:12 <lambdabot> nd = ap ((,) . ap (*) f) f
07:54:12 <lambdabot>   Occurs check: cannot construct the infinite type: a = [a]
07:54:21 <mekeor> > id == concat
07:54:22 <lambdabot>   Occurs check: cannot construct the infinite type: a = [a]
07:54:39 <hiptobecubic> I haven't mastered my mental model of haskell's laziness yet
07:55:27 <dougransom> @pl nd x = (x* fx, fx)
07:55:28 <lambdabot> nd = flip (,) fx . (fx *)
07:55:30 <reltuk> anybody here particularly failure with oleg's iteratee and region stuff?  i'm trying to figure out if there's a way to do something like openReq from IterAdv.hs with Regions / SafeHandles
07:55:43 <dougransom> @pl nd x = (fx, x*fx)
07:55:44 <lambdabot> nd = (,) fx . (fx *)
07:56:40 <mekeor> ion: when lambdabot uses numinstances then 'id == concat' should result in an error like "(==): No overloading for function" (see https://github.com/conal/NumInstances/blob/master/src/Data/NumInstances.hs line 20)
07:56:42 <reltuk> but I think the whole point of safe handles is that the types stop you from  getting that handle to the iteratee
07:56:51 <ddarius> @hoogle combinations
07:56:51 <lambdabot> No results found
07:56:53 <ill_logic> Hi all. I was just looking at http://www.haskell.org/haskellwiki/Typeclassopedia#Instances I don't think I have edit permissions myself, but if someone here does, I think it would improve it if ((,) e)  and ((->) e) had links with code examples on how to use them. They're a bit strange to me at this point.
07:57:41 <reltuk> so then i was trying to determine if it was possible to write an enumeratee that would thread an shandle through, but I don't think that works either for the same reason.
07:57:43 <mekeor> ill_logic: what about registering on haskellwiki and just editing it yourself? you'll have permissions to do so.
07:59:20 <osa1> can anyone explain me what's wrong with this code? I'm getitng a type error in line 3 http://paste.pocoo.org/show/556539/
07:59:51 <ion> mekeor: id and concat don’t have the same type.
07:59:58 <mekeor> > head == last
07:59:59 <lambdabot>   *Exception: (==): No overloading for function
08:00:06 <mekeor> ion: perfect, nice =)
08:00:20 <ill_logic> mekeor: oh drat, I'm dumb, I didn't see the signup/login. sure I'd gladly do it, but I'm not sure what to link to
08:00:38 <savask> osa1: Maybe because in the type Maybe is outside, but you use Just inside?
08:00:41 <ill_logic> if you tell me what terms to look up I can find it.
08:00:52 <mm_freak_> is there a stream library with fusion?
08:01:04 <mekeor> ill_logic: idk either.
08:05:09 <dougransom> @pl standard_line slope intercept  = \x -> slope*x+intercept
08:05:09 <lambdabot> standard_line = flip . ((+) .) . (*)
08:05:37 <osa1> anyone? what's the problem with line 3 here: http://paste.pocoo.org/show/556539/
08:05:39 <CodeWeaverX> Point free form is so freaking twisted.
08:07:44 <dougransom> CodeWeaver:  frequently it is.  Kind of reminds me of programming my HP28C in RPN with all the stack fun.  I think it is something-amorphic.
08:07:52 <dougransom> to pointfree.
08:07:52 <savask> osa1: You can't make such a function, it's type must be IO (Maybe String)
08:09:12 <Varifold> Just a quick question: What is the best GNU/Linux distribution for Haskell programming? For instance, Ubuntu's repo support for Haskell is quite sucky.
08:09:36 <luite> ubuntu is ok if you just download ghc form haskell.org
08:10:54 <hiptobecubic> this "blow your mind" page on the haskell wiki is the most appropriately named page on the internet.
08:11:00 <solarus> savask: actually it might work if hIsEOF is of type Handle -> Maybe Bool
08:11:06 <dougransom> CodeWeaver:  A slightly less pointless version:  standard_line slope intercept = (intercept +) . (slope *)
08:11:13 <Varifold> luite, this is what I did so far. Ubuntu isn't exactly lightweight, though, and I have a weaker laptop in mind.
08:11:14 <ion> varifold: Any distro is fine, i just add ~/.ghc/bin:~/.cabal/bin to PATH, download the GHC binary and install it to ~/.ghc and bootstrap cabal-install to ~/.cabal. (For GHC 4.7.1, the compatible cabal-install is in the main cabal darcs repo.)
08:11:32 <ion> 7.4.1
08:11:42 <savask> solarus: That would be a magic version of hlsEOF :-P
08:11:52 <solarus> indeed
08:12:08 <Varifold> ion, I see. Well, that approach is also good if you want several GHC versions simultaneously. You just have to change PATH...
08:12:09 <luite> Varifold: GHC isn't exactly lightweight either, depending on what you're going to compile you might want at least 4 GB
08:12:14 <luite> RAM that is
08:13:39 <Varifold> Hmhm.
08:14:46 <hiptobecubic> >  liftM2 (>>) putStrLn return "hello"
08:14:47 <lambdabot>   <IO [Char]>
08:15:26 <hiptobecubic> That example fails in ghci, is that because ghci is already permanently in IO?
08:16:43 <Varifold> ion, luite, thanks. I'll stick to Ubuntu. I was considering ArchLinux but if nobody has a logical reason to switch to that, I won't.
08:17:02 <luite> hehe lots of haskellers do use arch, I just don't have much experience with it
08:17:47 <Varifold> Is there any advantage in using Xmonad as the window manager?
08:17:47 <hiptobecubic> luite, Varifold my experience is that they push enormous updates that break everything too frequently.
08:18:06 <mm_freak_> Varifold: arch is good for haskell development, because you get fairly recent packages easily
08:18:19 <mm_freak_> through the distribution's package manager that is
08:18:34 <mm_freak_> and there is the AUR for all other packages, although i don't use it for haskell…  i just use cabal-install
08:19:21 <Varifold> mm_freak_, what about compatibility issues with Arch? Ubuntu appears to be well-established these days. Is Arch similarly developed?
08:19:52 <td123> generally if you use stuff from the stable repos, you will be fine and wont have problems
08:20:31 <hiptobecubic> but you often have to reach out into AUR, ubuntu can lean on debian's *enormous* collection of (mostly) vetted packages
08:22:01 <copumpkin> rwbarton: what happened to your python quiz?
08:22:08 <td123> the aur has pretty much everything and more :)
08:23:04 <td123> hiptobecubic: the reason debian can do that is because it has a huge official developer base
08:23:38 <td123> hiptobecubic: I think they have like ~1000 devs working on that distro
08:25:24 <rwbarton> copumpkin: oh no, my MIT account went away
08:25:54 <copumpkin> oh no!
08:27:25 <t7> i dont need term substitution if i keep track of context ? (untyped lambda calc)
08:29:14 <k0ral> hi, anyone knows why does cabal rebuild every single imported library each time I build my project ?
08:36:08 <mjga> any hint, as of which of numerous lenses/accessors libraries to use?
08:39:24 <tgeeky> mjga: there's a stackoverflow article about it
08:40:01 <tgeeky> mjga: http://stackoverflow.com/questions/5767129/lenses-fclabels-data-accessor-which-library-for-structure-access-and-mutatio
08:40:06 <tgeeky> you probably want fc-labels, I think
08:40:36 <tgeeky> but probably best to read the note by edwardk and decide thusly
08:41:37 <tgeeky> is it acceptable to say "you're welcome in advance"?
08:41:39 <mjga> @which lenses
08:41:40 <lambdabot> Unknown command, try @list
08:41:42 <mjga> @which lens
08:41:42 <lambdabot> Unknown command, try @list
08:41:59 <mjga> thx
08:42:35 <mjga> @where lens
08:42:35 <lambdabot> I know nothing about lens.
08:42:36 <mjga> @where lenses
08:42:36 <lambdabot> <http://twanvl.nl/blog/haskell/overloading-functional-references>,<http://cdsmith.wordpress.com/2011/04/26/composing-state-with-functions-and-lenses/>,<http://patternsinfp.wordpress.com/2011/01/31/
08:42:36 <lambdabot> lenses-are-the-coalgebras-for-the-costate-comonad/>,<http://stackoverflow.com/questions/5767129/lenses-fclabels-data-accessor-which-library-for-structure-access-and-mutation>
08:42:54 <tgeeky> hey, that's the one I mentioned
08:43:17 <tgeeky> mjga: there's some more advanced stuff going on as well... there's multiplate, there's edit-lenses
08:43:20 <mjga> so that is a very lame question from me, thx a lot anyway
08:45:52 <tgeeky> mjga: no, it's perfectly reasonable. And it's a common situation in haskell -- many packages that apparently do the same thing
08:46:19 <tgeeky> mjga: one way you can decide is to look at hackage reverse dependencies -- often you'll want the most used (and hence most depended on) package
08:46:51 <mjga> tgeeky: I suppose that means a lush, bustling innovation is coming. I wonder whether people feel like standardizing on something anytime?
08:48:38 <tgeeky> mjga: perhaps. It's double edged sword. It's a sign of a healthy code ecosystem, but it's also a sign that the design space isn't well understood.
08:49:02 <tgeeky> if you really just want to get to work, use fclabels.
08:50:08 <mjga> tgeeky: I understand this respect for difficulty of design space, but I am still afraid that it may end like "extensible records", since their design space has been left pretty much fallow for decades yet... scary.
08:51:33 <tgeeky> mjga: yeah. I have the same feeling about some of these things. But then team GHC releases two new versions a year, each with major improvements and new extensions. My eyes glaze over, and I feel like it's Christmas again.
08:51:43 <tgeeky> and I forget about those problems.
08:52:03 <aavogt> tgeeky: do you know of a count of which library is more popular?
08:52:34 <mjga> aavogt: yeah, kind of: http://packdeps.haskellers.com/
08:52:38 <aavogt> this used to be up, but I think it has moved somewhere http://www.mail-archive.com/haskell@haskell.org/msg22407.html
08:53:02 <mm_freak_> mjga: i think the most common and most convenient library nowadays is data-lens
08:53:19 <mm_freak_> mostly together with data-lens-template and often with data-lens-fd
08:53:44 <aavogt> mjga: that doesn't seem to do what I want. If I search data-accessor, it should list all the packages that use it
08:53:45 <tgeeky> mm_freak_: now there you go contridicting my totally unfounded opinion!
08:53:52 <mm_freak_> i use it and it's mostly straightforward with very little code clutter
08:53:58 <mm_freak_> tgeeky: sorry =)
08:54:15 <tgeeky> mm_freak_: no, no. I'm a scientist. I'll take it like one. Time to destroy my laboratory and start over
08:54:18 <aavogt> which is say Chart among others
08:55:27 <mm_freak_> hehe
08:55:52 <tgeeky> mm_freak_: that's edwardk's lens package, right?
08:56:55 <mm_freak_> yeah
08:57:24 <mjga> well, counting revdeps: data-lens 14, fclabels 36, data-accessor 46, lenses 0, pointless-lenses 3
08:57:57 <mjga> mm_freak_: I suppose the order of popularity is: data-accessor, fclabels, data-lens. wonder why?
08:59:53 <aavogt> age is probably the reason
09:00:45 <singpolyma> I'm writing an FFI binding.  I have some complex (structs) global constants in the C code that I just want to get pointers to in haskell (so that I can pass said pointers to FFI functions) -- is there a way to do that ?
09:08:31 <MagneticDuck> Nap time on #haskell, eh?
09:08:42 <MagneticDuck> Anyway, I have a question about the usage of Monads...
09:08:52 <MagneticDuck> I'm still learning them...
09:09:38 <MagneticDuck> So, here's my question: if I were to make a little program, say, that remembered a number and displayed the number every time you write "display" and adds one to the number every time you write "up"...
09:09:54 <MagneticDuck> Would you use monads, or the simpler recursive method?
09:10:35 <MagneticDuck> That is, have a function, (an IO Int actually), that acts as a cycle of the program.
09:10:46 <MagneticDuck> What's your opinion?
09:10:50 <MagneticDuck> Anyone?
09:11:00 <CodeWeaverX> I'm sort of just getting a handle on them myself...
09:11:13 <MagneticDuck> They're hard, aren't they?
09:11:34 <CodeWeaverX> Welllllll… sort of.  They're basically computations-in-a-context where the context may be state.
09:11:41 <MagneticDuck> Good thing there's SO MANY TUTORIALS OUT THERE.
09:11:45 <MagneticDuck> Hehe.
09:12:06 <MagneticDuck> Of course, they're not entirely alien to me.
09:12:06 <CodeWeaverX> …but it seems to me that you don't really avoid recursion no matter how you implement it.  You might (and often do) hide it because a function you're using is recursing for you.
09:12:09 <reltuk> i would use a recursive method
09:12:20 <reltuk> but the IO is  going to be in the IO monad
09:12:21 <MagneticDuck> Well, yes. With monads, you're still going to use a form of recursion.
09:12:58 <CodeWeaverX> For something that simple, feeding your existing numeric state forward with manual recursion is pretty easy to do, and pretty readable in code.
09:13:06 <hpaste> reltuk pasted “display and up prog” at http://hpaste.org/64320
09:13:20 <MagneticDuck> Yeah. That's what I thought.
09:13:45 <MagneticDuck> Well that was some fast coding there!
09:13:57 <MagneticDuck> And yes, that's what I would do too.
09:14:12 <CodeWeaverX> When you start needing a lot of state, you might need a data structure… and if you want to start threading both state and error management, monads become a lot more directly useful.
09:14:32 <MagneticDuck> Okay. So that's when Monads really become helpful.
09:14:48 <zerax> You might want to try and get away form the concept of solving the problem "with monads". Monads themselves aren't the solution in themselves, they just mean you can take advantage of code that's already been written and reduce duplication.
09:15:05 <MagneticDuck> True
09:15:49 <CodeWeaverX> Sure.. reducing the boilerplate of doing a computation when there's state, error handling, and various rules, that have to be managed as you do any operation.
09:16:15 <MagneticDuck> And anyway, as a tutorial I'm reading points out, most people faced with the situation usually just make their own type of simple monad without even knowing it... of course, usually very different but with the same concepts.
09:16:28 <CodeWeaverX> Right.
09:16:48 <CodeWeaverX> That's sort of the thing I think people miss.  It's a… functional programming pattern that people sort of stumble into.
09:16:55 <CodeWeaverX> Monads just formalize it.  Really well.
09:17:27 <MagneticDuck> And scare people, if it's their first time... :D
09:17:52 <MagneticDuck> Monads kinds of have an aurora around them, that make people think they're real hard, though.
09:18:01 <MagneticDuck> And where did all these tutorials come from?
09:18:24 <MagneticDuck> Oh well, I don't really have much of a problem with them. Just pick the best.
09:18:50 <Philippa> once upon a time, the practical application of monads wasn't as well understood and that understanding was mostly passed by oral tradition or its IRC equivalent
09:19:35 <mrcarrot> i think the biggest mistake with all monad tutorials is that they are too long when they overtry to make it easy than the other.
09:19:40 <MagneticDuck> There's quite a culture here on IRC, isn't there? Oral traditions and everything...
09:19:45 <mrcarrot> easier*
09:19:50 <Philippa> whenever you think "I wish I was programming in a language with $feature", monads are a potential solution - they're a pattern for building embedded (domain-specific?) languages around
09:20:04 <MagneticDuck> What's $feature?
09:20:09 <Philippa> well, there used to be a greater proportion of haskell coders who were still in academia, too
09:20:37 <Philippa> it's a metavariable (indicated by the $, as in dereferencing a variable in *nix shell or even old BASICs), in this case referring to an arbitrary programming language feature
09:20:41 <CodeWeaverX> Philippa just means pick a language feature you might want.
09:21:26 <MagneticDuck> Okay. Although I hate C, so...
09:21:42 <mm_freak_> incidentally MagneticDuck has a great use case for data-lens =)
09:21:42 <Philippa> C doesn't use that syntax
09:21:59 <MagneticDuck> Oh. Well incidentally, I don't know C.
09:22:09 <MagneticDuck> Or as they say, I don't "speak" C.
09:22:12 <mm_freak_> case command of "display" -> access counter >>= liftIO . print; "up" -> counter += 1
09:22:21 <Philippa> learn it briefly one of these days, it's worth having done that much
09:22:36 <MagneticDuck> Yeah. Sadly.
09:22:42 <Philippa> (and it's small enough that a day's enough to learn the language itself enough to... well, mostly shoot yourself in the foot)
09:22:46 <hpaste> reltuk pasted “display and up prog with monad” at http://hpaste.org/64321
09:22:53 <MagneticDuck> By the way, what's data-lens?
09:22:54 <reltuk> monads do not make that better :-P
09:22:57 <ion> @hackage data-lens
09:22:58 <lambdabot> http://hackage.haskell.org/package/data-lens
09:23:35 <dougransom> @pl above_inflection xx = 1-2*square((xx-gamma)/d1)
09:23:35 <lambdabot> above_inflection = (-) 1 . (2 *) . square . (/ d1) . subtract gamma
09:23:37 <mm_freak_> of course that's overkill for just one variable, but if you had three of them, it's great
09:23:52 <MagneticDuck> Philippa: Hahaha.
09:24:17 <mm_freak_> and yes, i'd use a state monad there…  simple recursion gives you some code clutter there
09:25:04 <MagneticDuck> Arrgh! The only thing worse that one thing I can't follow is two things I can't follow! Wait for me!
09:25:43 <MagneticDuck> Hey, what's @pl?
09:25:59 <Philippa> it converts code to "pointless" (point-free) style
09:26:06 <Philippa> @pl \x -> x+1
09:26:06 <lambdabot> (1 +)
09:26:15 <MagneticDuck> Alright.
09:26:23 <Philippa> notice the lack of variables being bound in (1 +)?
09:26:28 <Philippa> that's what makes it point-free
09:26:29 <MagneticDuck> Or, if I was more sarcastic, that's just pointless.
09:26:39 <ion> It generally makes the code more horrible (see e.g. dougransom’s code above), but sometimes it can actually help to make it more readable. :-P
09:26:40 <MagneticDuck> Alright, got it.
09:26:49 <reltuk> mm_freak_: in this case, assumulators are such a common idiom i can't them being distracting...the first one much more clearly expresses the intention imo
09:27:00 <MagneticDuck> Yeah. :D
09:27:45 <MagneticDuck> The one thing that makes my head spin is this: (.).(.)
09:27:51 <MagneticDuck> Trying to figure it out...
09:28:00 <MagneticDuck> Let's see. I can rewrite that as this:
09:28:32 <MagneticDuck> f (.) g = f g
09:28:47 <mekeor> is it intended that there's a closing paranthese missing in the second listing at http://www.haskell.org/haskellwiki/GADT#Motivating_example ?
09:28:47 <ion> Uh. That looks wrong.
09:28:56 <mekeor> f . g = f g
09:28:57 <MagneticDuck> (.) . (.) = . .
09:29:03 <ion> mekeor: That’s wrong, too.
09:29:09 <MagneticDuck> Okay okay.
09:29:10 <mekeor> okay.
09:29:12 <mekeor> wait
09:29:22 <MagneticDuck> I know it's weird...
09:29:23 <ion> f . g = \x -> f (g x)
09:29:25 <mekeor> f . g (x) = f (g x)
09:29:28 <mekeor> ah, yea
09:29:28 <Philippa> MagneticDuck: you're being pretty sloppy with your syntax there
09:29:30 <reltuk> \h g a b -> h (g a b)
09:29:34 <MagneticDuck> Sorry!
09:29:47 <Philippa> (and you'll find it makes your life easier in the long run if you're not)
09:29:57 <MagneticDuck> Yeah, I know. I repent.
09:30:41 <MagneticDuck> Hummm...
09:31:08 <MagneticDuck> so f .: g = ?
09:31:24 <ion> f .: g = \a b -> f (g a b)
09:31:41 <MagneticDuck> Ah ha!
09:31:43 <ion> Or to put it another way,
09:31:49 <ion> (f .: g) a b = f (g a b)
09:32:02 <MagneticDuck> Thanks!
09:32:09 <ion> > ((f :: Expr -> Expr) .: (g :: Expr -> Expr -> Expr)) a b
09:32:11 <lambdabot>   f (g a b)
09:32:21 <hpc> or to put it another way, (.:) = (.) . (.)
09:32:31 <hpc> or better, (.:) = fmap . fmap
09:32:41 <MagneticDuck> True.
09:32:43 <ion> > ((.).(.)) f (g :: Expr -> Expr -> Expr)) a b
09:32:43 <lambdabot>   <no location info>: parse error on input `)'
09:32:46 <ion> > ((.).(.)) f (g :: Expr -> Expr -> Expr) a b
09:32:47 <lambdabot>   Ambiguous type variable `b' in the constraints:
09:32:47 <lambdabot>    `GHC.Show.Show b'
09:32:47 <lambdabot>      a...
09:32:50 <ion> meh
09:32:50 <hpc> > (+ 5) .: [[1,2],[3,4]]
09:32:52 <lambdabot>   [[6,7],[8,9]]
09:32:56 <ion> > ((.).(.)) (f :: Expr -> Expr) (g :: Expr -> Expr -> Expr) a b
09:32:58 <lambdabot>   f (g a b)
09:33:58 <MagneticDuck> Okay. But how does hpc's list example work?
09:34:09 <MagneticDuck> [[Int]] takes two parameters?
09:34:10 <ion> Ignore it, he’s just confusing you. :-P
09:34:27 <MagneticDuck> Okay. I imagine that .: is actually defined with fmap...?
09:34:33 <ion> lambdabot replaces (.) with fmap, yeah.
09:34:40 <MagneticDuck> Ah ha.
09:34:44 <ion> Which leads to plenty of confusion. :-)
09:35:04 <hpaste> “Doug Ransom” pasted “Partial Application Eval Query” at http://hpaste.org/64322
09:35:38 <MagneticDuck> But how the ... does that work? Are you saying that abs . sqrt == fmap abs sqrt?
09:35:41 * mekeor just wrote a data type 'NumList' which is a list of values of types of the Num class using existential types!
09:36:03 <ion> @type fmap
09:36:03 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
09:36:35 <ion> In “instance Functor (r ->)”, both of those “f”s are “r ->”. So, (a -> b) -> (r -> a) -> (r -> b).
09:36:51 <MagneticDuck> A function is a functor?
09:36:52 <ion> Which happens to be the same type as
09:36:56 <ion> @type (Prelude..)
09:36:57 <lambdabot> forall b c a. (b -> c) -> (a -> b) -> a -> c
09:37:04 <MagneticDuck> ...
09:37:14 <ion> Thus the only sensible implementation for fmap in the (r ->) instance is (.).
09:38:21 <ion> http://heh.fi/haskell/functors/#function-instance
09:38:29 <MagneticDuck> Hmmmm... (r ->) is a partially applied function that takes r and gives whatever. And so you can fmap to the result of function?
09:40:01 <ion> The “f” in the type is applied to another type in the type signature, e.g. (a -> b) -> f a -> f b in the case of fmap.
09:40:01 <dougransom> My question on http://hpaste.org/64322 is if I use f= trapezoidCurve 1 2 3 4 wich yields a function Double->Double,  and then f is called a lot of times with a lot of different values,   are say, the line function for the x < leftFull case recomputed over and over before application, or is the evaluation of " (leftZero,0) (leftFull,1) " to a function "tf" remembered by the compiler?
09:40:31 <ion> “f” corresponds to “(r ->)”, so “f a” becomes “r -> a”.
09:41:07 <MagneticDuck> Yeah. f is a box. I can see that now.
09:41:43 <MagneticDuck> It's just like anything else... IO, Maybe... WAIT, A FUNCTION IS A BIT LIKE A MONAD?
09:41:57 <MagneticDuck> I'm having one of those realization moments...
09:43:21 <MagneticDuck> Am I the tinyest bit right? Because I would be soo happy. :D
09:43:32 <ion> There’s a (r ->) instance for Applicative and Monad as well. See the link above.
09:43:33 <mekeor> hehe
09:43:45 <MagneticDuck> Yessss! Yesss yesss!
09:43:58 <MagneticDuck> And yeah, I'm on the page right now.
09:44:36 <ion> (It’s actually called the “(->) r” instance since the section syntactic sugar isn’t available for types. “(->) r a” is the same as “r -> a”.)
09:44:59 <MagneticDuck> Okay
09:47:08 <MagneticDuck> Every step closer I get to fully understanding Haskell in its entirety is pretty fun.
09:47:34 <MagneticDuck> It's like a video game, except you actually gain something.
09:47:51 <CodeWeaverX> Wait, in its *entirety* ?
09:47:54 <CodeWeaverX> Bold goal. :D
09:48:01 <MagneticDuck> Yeah, I know. :D
09:48:30 <MagneticDuck> But you can't deny that I *am* getting *closer*...
09:49:23 <MagneticDuck> Gosh darnit! All these people coming in and going out make it hard to concentrate! I wonder if there's some way to disable all these notices!
09:50:20 <ChristianS> MagneticDuck: there usually is, depends on your irc client
09:50:29 <MagneticDuck> Looking for it right now.
09:50:29 <mm_freak_> reltuk: what'
09:50:30 <ion> Probably. WeeChat has a “smart filter” which hides joins/parts/quits from users who haven’t been speaking for a certain number of minutes (and you can still see them if you want to with a keyboard shortcut).
09:50:35 <mm_freak_> reltuk: what's an assumulator?
09:50:51 <reltuk> accum :-P
09:51:00 <mm_freak_> does it assumulate people? =P
09:51:17 <MagneticDuck> BTW, I'm using linux... anyone know any really good IRC clients. And any in Haskell? :)
09:52:01 <mm_freak_> i think manatee has an IRC client
09:52:09 <mm_freak_> also there is this simpleirc-based thing on hackage
09:52:27 <t7> chatzilla is nice
09:52:30 <mm_freak_> if you like terminals and don't insist on haskell, there are irssi and weechat
09:52:33 <t7> can change theme with css
09:52:51 <mm_freak_> weechat is easier and has some stuff like nicklists builtin, while irssi is more flexible
09:53:04 <MagneticDuck> Thanks! Lots of choices here, I see.
09:53:11 <ChristianS> MagneticDuck: i use xchat, which is pretty fine and lets you hide join/part message (not written in haskell though, i'm afraid)
09:53:41 <MagneticDuck> Hey, that's what I'm using! Do you know how to disable notices for people coming and going from the chan?
09:54:24 <ChristianS> right-click on channel tab + select Settings / Hide join/part message
09:54:32 <MagneticDuck> Thanks!
09:54:54 * mekeor is using ERC from Emacs such that he can change his input-method to LaTeX-like such that he can type \lambda or something which results in λ then :P
09:55:34 <MagneticDuck> Emacs! Yay! Don't know how to use it... but I know it's awesome!
09:55:49 <mekeor> heh
09:55:57 <mm_freak_> if you don't know how to use it, you don't know it's awesome ;)
09:56:16 <mm_freak_> i mean it is, but you don't know it, otherwise you would be using it =P
09:56:29 <MagneticDuck> Well, all I know is that you can write old snakey in it!
09:56:38 <mekeor> M-x snake
09:56:45 <MagneticDuck> Yeah yeah.
09:57:28 <MagneticDuck> But that makes it awesome, right?
09:57:46 <mm_freak_> by that definition almost every modern editor is awesome
09:57:59 <MagneticDuck> Well, true.
09:58:23 <t7> "Perhaps a bit irritating, type variables are monotypes, either."
09:58:26 <t7> wtf am i reading
09:58:50 <MagneticDuck> Dont know.
09:59:55 <MagneticDuck> BTW, use WTHBOG instead of wtf.
10:00:05 <MagneticDuck> What The Holy Bowls Of Gravy
10:00:50 <ion> mm_freak: In what way is Irssi more flexible? I switched from Irssi to WeeChat a while ago and haven’t noticed a lack of flexibility so far.
10:01:52 <Philippa> MagneticDuck: Why not just WTD (What The Diddly)?
10:01:56 <mm_freak_> ion: the way you can manage windows, the stuff you can configure, etc.
10:02:21 <MagneticDuck> Philippa: WTHBOG does Diddly mean?
10:02:31 <Philippa> never seen an ep of The Simpsons?
10:02:41 <mrcarrot> ion: weechat is less flexible because of it being a single thread. any addonscript that uses sleep to wait for something will block the whole client. it is simply badly designed
10:02:54 <MagneticDuck> Philippa: Well... actually I never watched a full one.
10:04:10 <Rc43> Hi, guys.
10:04:14 <MagneticDuck> Hey there
10:04:15 <ion> mrcarrot: Irssi behaves exactly like that.
10:04:28 <jhance> anyone know if llvm-base is supposed to build on LLVM 3.0 or not? Github and the hackage description yield different answers and I'm not sure if I need to fix up llvm-base or not
10:04:36 <Philippa> MagneticDuck: Flanders started off inserting "diddly" or "diddily" into words as emphasis - "scrum-diddily-umptious!". And of course, he doesn't swear. Eventually that morphed into "What the diddly?" and the like
10:05:00 <MagneticDuck> Oh
10:05:14 <MagneticDuck> BTW, WTHBOG ever happened to DougRansom? I think he had a question about his code...
10:05:41 <CodeWeaverX> Project:  Write an auto-flandersing program in haskell for lazily processing text files.
10:05:49 <Rc43> Is there a thing like setters? E.g. I have `data X = X a b c d`, and I want to change `b`. I can do it with `f (X a b c d) = X a newB c d`. Can I just use something like `f X = setB X newB` ?
10:06:29 <MagneticDuck> I'd personally just pattern match.
10:06:55 <jhance> Rc43: Record syntax
10:06:59 <CodeWeaverX> Rc43: Look up haskell's "field labels" when it comes to data structures.  Using them, you also get syntax for constructing new data structures with singular fields changed…. or multiple at once.
10:07:32 <Rc43> jhance, CodeWeaverX, thanks
10:07:44 <MagneticDuck> Well, I learned something!
10:07:45 <Rc43> also, is it something basic?
10:08:08 <ion> rc43: See data-lens.
10:08:11 <ion> @hackage data-lens
10:08:11 <lambdabot> http://hackage.haskell.org/package/data-lens
10:08:59 <ion> There’s also something for generating lenses for data types using Template Haskell.
10:09:36 <ion> @hackage data-lens-template
10:09:36 <lambdabot> http://hackage.haskell.org/package/data-lens-template
10:11:08 <ion> {-# LANGUAGE TemplateHaskell #-} data Foo = Bar { _baz :: Quux }; makeLenses [''Bar]
10:11:20 <ion> Eh, i mean makeLenses [''Foo]
10:12:56 <ion> f = setL baz newBaz
10:13:33 <t7> > let f = f f in f
10:13:33 <lambdabot>   Occurs check: cannot construct the infinite type: t = t -> t
10:13:52 <mm_freak_> data-lens-fd lets you write pretty imperative code
10:13:58 <mm_freak_> baz += 1
10:14:40 <t7> nasty?
10:14:45 <reltuk> yeah...i've got a board game simulator / ai that i'm working on, and all the state management looks really imperative :-P
10:16:07 <mm_freak_> you can have declarative stateful computations using AFRP, but it's not always applicable
10:16:31 <mm_freak_> sometimes you really just want mutable variables, and StateT with data-lens is much nicer than IORef/STRef
10:16:39 <ninestraycats> Hi, I'm new to monads and was wondering if they'd be useful for the EM algorithm. Given some input, you build a data structure, then iteratively update it using the same input until convergence. I previously wrote this purely functionally, and it isn't clear to me if doing the computations in any monad would help clarity and/or speed. (The functional implementation is straightforward: "uniform" takes input and
10:16:39 <ninestraycats> builds the data structure; "step" runs one iteration; and "em" recursively calls "step" until convergence)
10:17:10 <ninestraycats> the state monad doesn't seem appropriate since i'm not interested in any results during this training process
10:19:02 <mm_freak_> ninestraycats: the algorithm's structure sounds like it could be done by simply using laziness
10:19:21 <byorgey> ninestraycats: using a mond will not help with efficiency
10:19:21 <mm_freak_> boxed vectors are great for that
10:19:39 <byorgey> not that it would hurt, either, it's just kind of an orthogonal concern.
10:20:03 <byorgey> ninestraycats: if the functional implementation is straightforward, then I don't see what you would gain by using, e.g. a state monad.
10:20:07 <mm_freak_> ninestraycats: are you doing backpropagation?
10:20:32 <cmccann> sounds like something that would make sense for using iterate and then an adjacent-element version of dropWhile
10:20:59 <ninestraycats> byorgey: having read about monads a lot these past days, i thought so too. my (space) efficiency is awful but i can now chalk that up to my "step" implementation, not the lack of monads.
10:21:09 <byorgey> ninestraycats: right.
10:21:12 <ninestraycats> mm_freak_: no. isn't back-propogation for neural nets with hidden layers?
10:21:20 <ion> > let em step a = until (\(prev, next) -> prev == Just next) (\(_, prev) -> (Just prev, step prev)) (Nothing, a) in em (\x -> min (x+1) 100) 42
10:21:21 <lambdabot>   (Just 100,100)
10:22:06 <mm_freak_> ninestraycats: yes…  it sounded like you're doing that…  i have a library on hackage that iterates a neural network until coming to rest simply by using laziness
10:22:17 <mm_freak_> http://hackage.haskell.org/package/instinct
10:22:32 <mm_freak_> it does something similar for backpropagation
10:22:37 <ninestraycats> ooooh, yes, in that sense i suppose yor'e right. there are many machine learning algorithms which update state until convergence
10:22:43 <mm_freak_> i.e. declarative stateful computations
10:22:44 <ninestraycats> well
10:22:47 <byorgey> > let em step = fst . head . dropWhile (uncurry (/=)) . zip `ap` tail . iterate step in em (\x -> min (x+1) 100) 42
10:22:48 <lambdabot>   Precedence parsing error
10:22:48 <lambdabot>      cannot mix `L..' [infixr 9] and `Control.Mona...
10:23:08 <ion> mm_freak: I’ll have to take a look at instinct, i might find it useful some day.
10:23:10 <byorgey> > let em step = fst . head . dropWhile (uncurry (/=)) . (zip `ap` tail) . iterate step in em (\x -> min (x+1) 100) 42
10:23:11 <lambdabot>   100
10:23:27 <mm_freak_> ion: it really just has fast neural networks with backpropagation, nothing fancy
10:24:09 <mm_freak_> they are layered by default but the library really lets you build any structure you want, as long as the neural network converges
10:25:19 <mm_freak_> it's an excellent demonstration of how evaluation convergence and algorithm convergence can be tied together =)
10:26:21 <ion> mm_freak: Yes, i might find neural networks with backpropagation useful some day. :-) (I’ve done some ML-class homework with them in Octave before, but if i ever have a project of my own that requires them, i’ll almost certainly use Haskell.)
10:26:44 <o1iver> Hey. Is there a haskell tutorial somewhere that goes step by step through writing a rather large program? Something much larger than the examples in Real World Haskell? I think I saw somewhere that there is an XMonad code walkthrough, but are there any other large projects like that?
10:27:16 <byorgey> o1iver: maybe "Write yourself a scheme in 48 hours"?
10:27:32 <byorgey> not sure if that's the kind of thing you're looking for
10:28:30 <o1iver> byorgey: yes... that looks pretty perfect. I was actually hoping for a parser/compiler topic. Great! Thanks a lot!
10:28:58 <monochrom> I want a C tutorial through writing a rather large program, too
10:29:53 <mm_freak_> monochrom: would a series of three books suffice?  or do you need portability, too?
10:29:57 <o1iver> monochrom: :-)
10:31:26 <monochrom> what are those three books?
10:31:54 <jhance> Writing a parser isn't necessarily the best example of a large program since its so monad-based, etc.
10:32:06 <jhance> It gives good practice with monads but then it seems empty otherwise
10:32:48 <reltuk> anyone here seen oleg's IterReg post?
10:32:56 <ggherdov> Hi all. Any clue on ICFP contest 2012? organizing university, aproximative dates and the like?
10:33:14 <mm_freak_> monochrom: i haven't written them yet =)
10:33:31 <ggherdov> reltuk: link? just joined.
10:33:52 <monochrom> I was thinking the TCP/IP series of three
10:33:54 <mm_freak_> monochrom: but i'd estimate the minimum needed to cover writing large applications in C to three books without covering portability
10:34:23 <singpolyma> is there a way to export everythin in a module *except* a list of items, instead of having to explicitly list every item?
10:34:28 <Philippa> jhance: a parser's too small. Nothing wrong with eg an interpreter for a small language though
10:34:41 <Philippa> (except where you can do it in a few hundred lines)
10:34:53 <reltuk> http://www.haskell.org/pipermail/haskell-cafe/2012-January/098704.html
10:35:07 <ggherdov> reltuk: thx
10:35:10 <monochrom> no way. explicit list exports only
10:35:13 <mm_freak_> singpolyma: make a proxy module that imports hiding and reexports the module
10:35:13 <reltuk> and http://www.haskell.org/pipermail/haskell-cafe/2012-February/099689.html
10:35:29 <reltuk> ggherdov: i'm trying to figure out a way to combine the safehandles with something IterAdv's reqOpen
10:35:35 <mm_freak_> singpolyma: module X.Proxy (module X) where import X hiding (a, b, c)
10:35:43 <singpolyma> mm_freak_: hmm. I'll try that
10:35:51 <monochrom> look at the bright side. the export list is also where you can organize order and sections in haddock
10:36:04 <singpolyma> thanks :)
10:36:17 <reltuk> basically, I want an iteratee to be able to request that an enumerator open a new safe region for it...something like that.  i don't even know if what i want to do makes sense here
10:36:35 <cmccann> mm_freak_, it feels like a horrible hack whenever I do it that way
10:36:39 <ggherdov> reltuk: cannot help sorry, new to haskell. But enjoy reading.
10:36:53 <mm_freak_> reltuk: Iteratee a (StateT Bool m)
10:36:58 <mm_freak_> reltuk: ugly, but works
10:37:20 <mm_freak_> cmccann: it is a horrible hack
10:37:35 <mekeor> is there a way to print out the current line in haskell? i mean, like the __LINE__ macro in C…
10:37:41 <cmccann> mm_freak_, well that explains why it feels that way, now doesn't it
10:37:57 <cmccann> mekeor, with TH if nothing else
10:38:27 <mekeor> and in plain haskell?
10:38:40 <monochrom> Control.Exception.assert can
10:39:16 <cmccann> mekeor, why do you need the current line?
10:39:18 <mekeor> i know. i know but printing it yourself is nice, too…
10:39:26 <mekeor> cmccann: for debugging, e.g.
10:39:46 <monochrom> although, assert also aborts
10:39:51 <mekeor> anyway, not so important…
10:39:54 <mekeor> exactly
10:40:06 <cmccann> ok. if it's debugging during development, I'd say use TH or whatever horrible hack you feel like
10:40:14 <monochrom> although, if you're debugging, you want to abort anyway
10:40:14 <cmccann> @hackage placeholders
10:40:14 <lambdabot> http://hackage.haskell.org/package/placeholders
10:40:19 <cmccann> you might find that library useful
10:40:27 <cmccann> if only as an example
10:40:35 <mekeor> okay…
10:40:49 <monochrom> informativehead xs = assert (not (null xs)) (head xs)
10:41:12 <mm_freak_> monochrom: not always
10:41:19 * hackagebot nme 0.1 - Bindings to the Nyctergatis Markup Engine  http://hackage.haskell.org/package/nme-0.1 (StephenWeber)
10:41:25 <mm_freak_> i occasionally find traceShow from Debug.Trace very useful
10:41:30 <mekeor> cmccann: that's TH, too :P, but anyways that satisfying
10:41:35 <mm_freak_> it would be more useful, if it could print line numbers along the way
10:41:38 <mekeor> so i don't have to use TH myself…
10:41:43 <cmccann> mekeor, yeah, sorry, wasn't clear
10:41:48 <cmccann> it shows how to do it with TH in a tidy way
10:41:54 <mekeor> :)
10:41:57 <cmccann> so that you don't have to figure it out yourself :P
10:42:03 <mm_freak_> mekeor: /using/ TH is pretty straightforward…  it's /writing/ TH that is horrible
10:42:06 <mm_freak_> so go ahead and use it =)
10:42:32 <cmccann> and while having a TH dependency annoys some people, if you're only using it for debugging you can remove it for release
10:43:04 <mekeor> mm_freak_: :D lol
10:43:33 <mekeor> why does having TH dependency annoy people at all??
10:44:08 <cmccann> more dependencies, longer compile times, &c.
10:44:17 <hpc> mekeor: superfluous dependencies are annoying, especialy when they point to strange packages
10:44:33 <ion> Abusing implicit parameters seems like a better alternative than Development.Placeholders: the error messages will contain the supposed types of the “holes”.
10:44:35 <hpc> (TH is strange because it isn't just functions and data structures)
10:45:11 <cmccann> ion, that's not entirely the same thing though
10:45:41 <mekeor> hpc: yea it's 'meta'…
10:45:59 <mekeor> with bash-like $s bah
10:46:00 <cmccann> the point of placeholders is to be a better version of (error "TODO") for unimplemented stuff so that the rest of the code compiles while you're working on it
10:46:40 <ion> aye
10:47:29 * cmccann ponders whether a horrible hack involving implicit params, haskell-src-exts, and running another GHC process would let him get a "typeInContext" TH function working
10:48:29 <cmccann> eh, probably more hassle than doing something less deranged
10:50:50 <ion> :-)
10:51:09 <DanBurton> scala screwing up my terminal, no response on #scala >,<
10:51:14 * cmccann should hack on ghc-goals a bit
10:51:51 <mekeor> is it possible to make my data type 'SList' in the following source code an instance of 'Functor' *at all* ?:
10:51:53 <hpaste> mekeor pasted “instanciating type to Functor” at http://hpaste.org/64327
10:51:53 <cmccann> <DanBurton> how do I fix my scala problem? <#haskell> stop using scala
10:52:09 <DanBurton> interestingly I can open up ghci, blindly type :m +System.IO and then hSetEcho stdin True, and it starts working. Thenk I quit ghci and it stops echoing again
10:52:26 <cmccann> mekeor, isn't that a kind error?
10:52:29 <mauke> DanBurton: try 'reset'
10:52:42 <mekeor> cmccann: atm?
10:52:50 <mekeor> cmccann: you mean the code as it is atm?
10:52:52 <cmccann> mekeor, there's no type parameter, what would a Functor instance even mean?
10:52:59 <mekeor> cmccann: the code compiles fine.
10:53:04 <cmccann> yes
10:53:10 <mekeor> cmccann: yea, that's my problem..
10:53:14 <DanBurton> mauke: nice, that does the trick.
10:53:32 <DanBurton> still rather strange that the scala interpreter screws up the echo state like that
10:53:47 <cmccann> mekeor, also, how does that type differ from just [String]?
10:53:49 <mekeor> cmccann: actually SList is a list… so…
10:53:59 <DanBurton> sudo apt-get uninstall scala
10:54:04 <DanBurton> whoops wrong window >.>
10:54:10 <cmccann> heh
10:54:22 <DanBurton> doh what's the uninstall command
10:54:36 * DanBurton figured it out...never mind...
10:54:46 <mekeor> cmccann: i can make (123 :|: (123.123 :: Double) :|: "foo" :|: 'c') with it. it's a list of different types which are instances of Show.
10:55:02 <cmccann> mekeor, and what can you do with those values?
10:55:06 <cmccann> you can apply "show" to them
10:55:07 <rwbarton> cmccann: that's easy, you can show the elements at different precedence levels.
10:55:08 <cmccann> that's all
10:55:21 <mekeor> cmccann: that's correct.
10:55:31 <cmccann> rwbarton, hm, true
10:55:47 <mekeor> rwbarton: how do you mean?
10:55:48 <rwbarton> somehow I doubt this is relevant :)
10:56:03 <rwbarton> mekeor: if you want to know, look up the definition of the Show class
10:56:06 <rwbarton> but it's irrelevant
10:56:20 <cmccann> mekeor, the point is that if all you do is use "show" on the elements, you can just do that ahead of time and get a list of String with no loss of generality
10:56:28 <mekeor> rwbarton: ah, got it.
10:56:57 <mekeor> cmccann: yea that's right actually… you're right, yes... but it'd be meaningful with Num instead of Show, right?
10:57:12 <mekeor> because Num defines more ((+),(*),(-),abs,…)
10:57:23 <cmccann> mekeor, how would you use the operations, though?
10:57:38 <cmccann> each element would be a potentially distinct Num instance
10:57:46 <cmccann> you wouldn't be able to add them together or anything
10:57:56 <cmccann> you could... negate everything in the list I guess
10:58:18 <mekeor> cmccann: i could be able to add everything together! why not??
10:58:39 <cmccann> mekeor, because they're not necessarily the same type
10:58:46 <mekeor> oh!
10:58:49 <mekeor> :t (+)
10:58:50 <lambdabot> forall a. (Num a) => a -> a -> a
10:58:54 <cmccann> > (1 :: Int) + (1 :: Float)
10:58:55 <lambdabot>   Couldn't match expected type `GHC.Types.Int'
10:58:55 <lambdabot>         against inferred type ...
10:58:55 <mekeor> ah
10:59:23 <cmccann> with a list of existentials you discard any useful knowledge of the original types
10:59:24 <mekeor> cmccann: you're right. that was a bad idea…
10:59:29 <cmccann> so they might as well all be different
10:59:43 <mekeor> right…
11:00:08 <cmccann> @quote cmccann existential
11:00:09 <lambdabot> cmccann says: some programmers have a problem to solve and think "I know, I need an existential type." now they have another problem, but can't solve it because all they know about it is that the
11:00:09 <lambdabot> problem exists.
11:00:17 <cmccann> :P
11:00:33 <ion> heh
11:00:38 <mekeor> lol :D
11:00:54 <cmccann> a good rule of thumb is that if you think you want to use an existential type, you're wrong, and actually don't want to do that
11:01:02 <DanBurton> something fishy is going on with Hackage documentation generation. e.g. the latest conduit package was uploaded on Tuesday, and it still has no docs.
11:01:25 <t7> lol
11:06:06 <k0ral> hi, I have f :: a -> IO (Either a a) and g :: Either a a; how do I "pipe" g into f ?
11:06:36 <k0ral> as IO is the top level monad, >>= will be understood as the IO pipe
11:06:48 <ion> f (either id id g)
11:07:33 <k0ral> ion: now try with Either a b instead of Either a a
11:07:58 <mauke> k0ral: impossible
11:08:03 <adimit> k0ral: you'd need a function b -> a for that.
11:08:32 <k0ral> hmmm, maybe I meant Either b a
11:08:41 <adimit> k0ral: same thing applis.
11:08:43 <adimit> *applies.
11:09:02 <adimit> given h :: b -> a, you'd say f (either h id g)
11:09:13 <adimit> :t either
11:09:13 <lambdabot> forall a c b. (a -> c) -> (b -> c) -> Either a b -> c
11:09:35 <k0ral> something is bugging me here
11:10:25 <k0ral> I need to read >>='s implementation for either
11:10:33 <k0ral> I might have assumed something wrong about it
11:11:27 <mm_freak_> k0ral: your functions don't seem particularly useful
11:11:55 <k0ral> mm_freak_: how would you know ?
11:12:02 <t7> the type sigs
11:12:12 <k0ral> so what ?
11:12:17 <mm_freak_> "f :: a -> IO (Either a a) and g :: Either a a"
11:12:19 <mm_freak_> write f
11:12:20 <monochrom> case g of Left x -> return (Left x); Right y -> f y
11:12:22 <t7> and a mispent youth on a computer
11:12:37 <monochrom> IOW, don't use f in the Left case
11:12:38 <mm_freak_> return . Left?  return . Right?
11:13:14 <hpc> :t \f -> either (return . Left) f
11:13:15 <k0ral> f performs an IO action and then returns a value corresponding to the success of failure
11:13:15 <lambdabot> forall (m :: * -> *) a b b1. (Monad m) => (b1 -> m (Either a b)) -> Either a b1 -> m (Either a b)
11:13:22 <k0ral> s/of/or
11:13:39 <mm_freak_> k0ral: ah, that makes sense…  didn't think about side effects =)
11:13:49 <monochrom> consider "newtype EIO a = IO (Either Blah a)". then "case g of Left x -> return (Left x); Right y -> f y" is what you do for >>= for EIO
11:13:53 <mm_freak_> but what action does it perform that might depend on 'a'?
11:14:06 <k0ral> mm_freak_: HTTP request, a is the URI
11:14:57 <mm_freak_> k0ral: in that case you shouldn't give a polymorphic type
11:15:00 <k0ral> monochrom: I thought about it, but then I have a bunch of a -> Either b a functions and I cannot chain them with EIO functions
11:15:03 <monochrom> err, "newtype EIO a = EIO (IO (Either Blah a))".
11:15:15 <k0ral> monochrom: unless you tell me there's a way to do so ?
11:15:51 <k0ral> mm_freak_: it's not polymorphic
11:16:04 <monochrom> without IO it's even easier. chaining a -> Either Blah a is the Either Blah arrow
11:16:08 <k0ral> mm_freak_: I should have written "A" and "B"
11:16:17 <mm_freak_> k0ral: yeah, that's my point
11:16:27 <k0ral> mm_freak_: oh, fair enough :)
11:16:46 <rwbarton> people do not normally assume that free type variables must be universally quantified
11:16:46 <monochrom> or the Either Blah monad
11:16:56 <rwbarton> particularly when the context suggests otherwise
11:17:11 <monochrom> well then I am not people.
11:17:27 <rwbarton> monochrom, I seriously doubt you thought k0ral meant "g :: forall a. Either a a"
11:17:47 <monochrom> oh, in that sense, sure
11:18:00 <k0ral> rwbarton: I shall be more careful next times :)
11:18:04 <mm_freak_> there you go
11:18:05 <monochrom> but I assume that a type variable is a type variable
11:18:22 <mm_freak_> two people confused by the type variable =)
11:19:19 <k0ral> monochrom: do you mean the arrow would make it possible to chain EIO functions with a -> Either blah a functions ?
11:19:19 <monochrom> more precisely, it means there is universal quantification at a suitable outer level
11:20:18 <k0ral> s/a/A
11:21:14 <adimit> is there a bounded Chan implementation on Hackage?
11:21:21 * hackagebot mathblog 0.5 - A program for creating and managing a static  weblog with LaTeX math and function graphs  http://hackage.haskell.org/package/mathblog-0.5 (JonathanDaugherty)
11:21:29 <adimit> i.e. one that I can tell how many items the Chan should maximally hold.
11:21:51 <cmccann> yes
11:21:54 <cmccann> two, actually
11:21:58 <cmccann> one for TChan
11:22:14 <mm_freak_> wow, mathblog sounds interesting!
11:22:24 <cmccann> adimit, and I think both are called something pretty obvious like "bounded-chan" :P
11:22:38 <adimit> cmccann: thanks a lot :-)
11:22:42 <monochrom> I didn't know you're mixing A -> Either Blah A with A -> IO (Either Blah A). but you can convert the former to the latter first
11:23:55 <adimit> cmccann: bounded-tchan actually recommends using stm-chans instead.
11:24:14 <b0fh_ua> Hi all! is there any quick fix to overcome: thread blocked indefinitely in an MVar operation or at least identify which mvar is affected?
11:24:16 <ReinH> Hi folks. What's your preferred haskell dev environment? Emacs with haskell mode? Vim?
11:24:27 <cmccann> adimit, ah, haven't actually used either myself
11:25:51 <adimit> cmccann: I think I'll go for stm-chans, seeing as their implementation seems more efficient (and I unfortunately need memory-efficiency right now.)
11:26:13 <mekeor> ReinH: emacs with haskell-mode.
11:26:41 <cmccann> adimit, sounds like a good plan
11:26:53 <adimit> ReinH: go with whatever editor is more comfy for you. You can make either work with Haskell. If you use vim, I recommend using syntastic and ghc-mod
11:27:02 <DanBurton> despite the polls, emacs seems to be slightly preferred over vim in the haskell community
11:27:06 <cmccann> adimit, funny thing is, now that I actually look at the packages, stm-chans is the one I was actually thinking of anyway :P
11:27:22 * cmccann is a rebel, using neither vim nor emacs
11:27:29 <adimit> cmccann: well, see, I wanted to ask the knowledgable folks of #haskell first.
11:27:32 <mekeor> ReinH: i just found leksah… hehe cool
11:27:35 <adimit> and that's why :-D
11:27:41 <ReinH> adimit: I'm definitely more familiar with vim but in the past I enjoyed emacs with haskell mode
11:27:44 <DanBurton> cmccann: what do you use then?
11:27:59 <ReinH> didn't find integration as nice with vim tbh, but I haven't looked at everything that's available
11:28:05 <ReinH> I will take a look at syntastic and ghc-mod
11:28:06 <adimit> I was considering using sublimetext, but it doesn't have syntastic, and it's "Vintage" mode is woefully incomplete.
11:28:33 <ReinH> adimit: I played around with sublime but as a long-time vim user I thought it was rather a toy editor
11:28:34 <cmccann> DanBurton, SciTE with GHCi in a console window
11:28:38 <cmccann> pretty low-tech :P
11:28:42 * DanBurton needs to revisit leksah, now that he is actually cabalizing stuff
11:28:56 <ReinH> cmccann: how is leksah on Lion these days, I wonder
11:28:58 <k0ral> monochrom: I don't like the idea of liftin every pure function into IO just because only one of the chaining functions is in IO
11:29:08 <adimit> ReinH: Syntastic & ghc-mod will give you hlint warnings and compile failures in a location list on :w
11:29:24 <ReinH> adimit: or :make, I assume?
11:29:29 <adimit> ReinH: probably.
11:29:40 <ReinH> using vim's built in compiler functionality, I would hope
11:29:42 <ReinH> will check it out
11:29:59 <ReinH> compiler in vim is really a makeprogram plus an errorformat
11:30:01 <ReinH> weirdly named
11:30:02 <ReinH> w/e
11:30:25 <ReinH> anyone use haskellmode-vim? http://projects.haskell.org/haskellmode-vim/
11:30:39 <mm_freak_> k0ral: then lift compositions or make a combinator for the patterns you see
11:30:56 <ReinH> anything that is still packaged as a vimball is automatically dubious...
11:30:58 <adimit> ReinH: used to use it, but it had problems I didn't like. Don't remember what it was.
11:31:08 <mm_freak_> there are nice ways to interleave pure computations with IO effects
11:31:23 <adimit> yeah. I was working on making an improved indentation mode for haskell+vim, but vimL kinda ruined the fun.
11:31:51 <ReinH> adimit: vimL?
11:32:16 <adimit> ReinH: also known as VimScript.
11:32:26 <adimit> or: the language that manage to suck even more than Perl.
11:32:28 <k0ral> mm_freak_: via Kleisli arrows for example ?
11:32:46 <ReinH> adimit: oh, yes, I hadn't heard it called vimL
11:32:52 <ReinH> not my favorite thing
11:32:59 <ReinH> but indentation files are relatively easy to write
11:33:06 <ReinH> compared to, say, things that require turing completeness
11:33:16 <td123> adimit: doesn't vim have ruby/python/etc bindings where you can write a script with?
11:33:21 <ReinH> td123: kind of
11:33:23 <ReinH> no one does it
11:33:30 <mike-burns> It's incomplete.
11:33:37 <mike-burns> People do it, but you also need vimL plumbing.
11:33:42 <ReinH> right
11:33:47 <td123> ah ok
11:33:47 <mm_freak_> k0ral: huh?  no, just combinators
11:33:49 <adimit> td123: it even has lua bindings, but for stuff like indentation, you sacrifice efficiency, and you still don't get around having to use vimL for some things.
11:33:49 <ReinH> it's a lot like FFI
11:33:56 <ReinH> you need to wrap everything in vimL
11:33:58 <adimit> plus the API sucks quite a bit. It's very idiosyncratic.
11:34:06 <td123> gotcha
11:34:24 <mike-burns> vimL isn't bad sometimes, though. It's just worse than Haskell.
11:34:25 <adimit> honestly, at some point I'm gonna ditch vim because of that. But I haven't found any other modal editor (that would live up to my standards.)
11:34:39 <adimit> vimL is worse than perl, and that's quite a feat.
11:34:42 <mm_freak_> k0ral: in many cases you have some data structure built by a pure computation and consumed by an IO action
11:34:49 <DanBurton> just write a Haskell DSL that compiles to vimL. problem solved!
11:34:52 <mike-burns> http://goo.gl/I5bSr - in which I try to convince you that vimL isn't bad.
11:35:04 <td123> adimit: heh, agreed, the most requested new feature for vim is to replace vimL :P
11:35:17 <mm_freak_> k0ral: in fact i try to write my algorithms that way…  pure producer, pure/impure consumer
11:35:25 <adimit> DanBurton: wrapping Vim's api in another language won't really do it.
11:35:37 <mm_freak_> if the producer is impure, i use conduits
11:35:46 <ReinH> is there a concise guide on creating a Haskell package with cabal?
11:35:55 <mike-burns> cabal init
11:35:56 <DanBurton> adimit: you write the api that you want, and then some really nasty code to transform it into the Vim api
11:36:00 <ReinH> I'd like to know about things like conventional directory structure, etc
11:36:01 <ReinH> ok
11:36:02 <td123> adimit: http://www.vim.org/sponsor/vote_results.php
11:36:26 <k0ral> mm_freak_: never heard of conduits
11:36:42 <adimit> td123: why python? Why not lua? *mumble* *mumble*… but OK, I'll settle for Python.
11:36:43 <DanBurton> ReinH: yes, there's one on the wiki. let me see if i can find it
11:36:47 <mm_freak_> k0ral: an alternative to enumerators/iteratees
11:37:07 <td123> adimit: dunno, that's what the community wants :P
11:37:35 <mike-burns> More people know Python than Lua.
11:37:43 <k0ral> mm_freak_: by combinators you meant conduits' ones, right ?
11:38:06 <dolio> adimit: Python is more pythonic, and thus better, obviously.
11:39:06 <ion> It even has monad comprehensions (with the restriction that it only works for lists).
11:39:09 <Peaker> I saw people use "Pythonic" in the context of C++.. it's somewhat funny
11:39:32 <Peaker> Pythonic basically means "just the level of abstraction I'm comfortable with"
11:39:35 <monochrom> the other night we had a pythoner here, and we had a debate on what "pythonic" meant. we were arguing whether "pythonic" is for describing python code or C code
11:39:37 <DanBurton> ReinH: found it: http://www.haskell.org/haskellwiki/How_to_write_a_Haskell_program
11:40:20 <mm_freak_> k0ral: no, just generic combinators
11:40:26 <mm_freak_> k0ral: foldM, mapM, etc.
11:40:36 <Peaker> Haskell is not Pythonic because it is not intentionally limiting new abstractions you can make -- so people write code in abstractions you're not comfortable with
11:41:01 <DanBurton> ReinH: you can also google for the Cabal User's Guide for more details about cabal
11:41:05 <mm_freak_> Peaker: intentionally?
11:41:26 <monochrom> oh, and another day we debated what is intention! :)
11:41:45 <Peaker> mm_freak_: Python restricts various features (such as anonymous code blocks) because they would allow users to make new abstractions. And some of those would be horrible!
11:42:04 <mm_freak_> i'd say the language just isn't designed to be flexible, but there doesn't seem to be anything intentional about it
11:42:12 <Peaker> mm_freak_: instead, we rely on the good old BDFL to slowly add abstractions (such as the bracket function known as "with contexts" in Python)
11:42:32 <monochrom> the point of total languages is to ban some terminating programs! <duck>
11:42:34 <mm_freak_> Peaker: i see
11:42:34 <Peaker> mm_freak_: I'm pretty sure it's intentional, the idea is to get everyone to agree on a small set of abstractions to use
11:42:53 <srhb> I like how Haskell PLatform asks me to contact the software vendor when installation fails.
11:43:01 <Peaker> The approach actually does have nice advantages
11:43:14 <dolio> The point of total languages is to ban non-terminating programs.
11:43:20 <dolio> Some terminating ones get caught in the cross fire.
11:43:21 <cmccann> Peaker, I'd say "get most people to agree, and get the rest to switch to Ruby"
11:43:24 <Peaker> Guido explicitly said he doesn't want tail-call optimization because it would enable the functional style
11:43:26 <monochrom> oh, thanks Peaker, now I have a reason to back up my claim :)
11:43:42 <dolio> Yeah, TCO is the biggest example, I think.
11:43:56 <mm_freak_> Peaker: true, i heard that one
11:44:10 <ReinH> DanBurton: thanks
11:44:13 <mm_freak_> he also wanted to ban reduce and map IIRC
11:44:26 <Peaker> It does mean you don't have to learn new abstractions when you read Python code, mostly
11:44:35 <Peaker> but you do have to read more error-prone code with conceptual repetition
11:45:00 <Peaker> cmccann: Ruby is a huge turn-off for many, even those who would want anonymous blocks and other Ruby features
11:45:02 <mm_freak_> well, python is for people who just want to get the work done with as little thinking as possible
11:45:07 <mm_freak_> haskell is from smart people for smart people
11:45:19 <cmccann> Peaker, as opposed to error-prone code filled with leaky abstractions, right? :P
11:45:44 <mike-burns> Can people use Haskell to get work done with as little thinking as possible?
11:45:51 <Peaker> cmccann: well, if it turns out badly :)
11:46:02 <mm_freak_> (in fact haskell is pretty idiot-intolerant)
11:46:07 <Peaker> mm_freak_: Why?
11:46:15 <Enigmagic> mike-burns: the minimum needed to write haskell, sure
11:46:18 <mm_freak_> Peaker: because there is no function of type a -> b
11:46:34 <Peaker> mm_freak_: the compiler helps the idiot understand it sooner, instead of hitting runtime errors :)
11:46:43 <Peaker> When I'm being an idiot, I'm glad I have GHC to tell me :)
11:46:49 <mm_freak_> Peaker: a real idiot won't like haskell
11:46:51 * cmccann doesn't see why Ruby would be a huge turn-off, it's not really appreciably different from Python except on points that are mostly about culture and idiom
11:47:02 <mm_freak_> note that idiot ≠ unexperienced programmer
11:47:21 <mm_freak_> haskell is pretty unexperienced programmer-tolerant =)
11:47:29 <Peaker> cmccann: I was really turned off by the Perlisms, back when I was a Pythoneer.. Baked-in syntax for regexes, support for Perl sigils, various syntactic quirks regarding method calls
11:47:31 <monochrom> I find myself thinking more when writing javascript. also checking the reference manual more. javascript semantics is more evil than haskell. I think less in haskell.
11:47:50 <mike-burns> Culture and idiom is everything.
11:47:53 <cmccann> Peaker, yes, but that's all pretty superficial except insofar as it highlights the cultural divide there
11:48:06 <mm_freak_> monochrom: ditto…  javascript is not a quick-n-reasonably sane language
11:48:17 <mm_freak_> python is quick-n-reasonably sane
11:48:25 <mm_freak_> haskell is -n-sane =)
11:48:26 <Peaker> cmccann: The superficial is pretty important.. How the text you stare at a lot of your day looks like is important :) Also it's a big first impression
11:48:33 <mike-burns> Programming is hard; separating it into "idiots" and "non-idiots" does everyone a disservice.
11:48:39 <cmccann> whether you use Python vs. Ruby has much more to do with culture and idiom than the languages themselves
11:48:51 <mm_freak_> mike-burns: an idiot refuses to learn
11:49:03 <cmccann> and yes, as mike-burns says, culture and idiom are probably more important anyway :P
11:49:03 <mm_freak_> that's the notion of "idiot" i have
11:49:05 <mike-burns> mm_freak_: programmers are not idiots.
11:49:14 <mike-burns> I don't care what language they use.
11:49:15 <mm_freak_> mike-burns: never said that
11:49:17 <mike-burns> OK.
11:49:27 <mike-burns> Yes, Haskell is hard for idiots. Python is too. Even PHP.
11:49:30 <mm_freak_> i said, haskell is idiot-intolerant
11:49:38 <monochrom> if python were statically typed, I would think the same amount when writing python and when writing haskell. non-static typing always makes me think more—more errors to mentally check
11:50:03 <mm_freak_> mike-burns: an idiot can make some quantity of money in reasonable time with PHP
11:50:05 <mike-burns> Haskell isn't as hard to learn as we'd like to think. The property that makes it hard to learn is that it's different.
11:50:20 <cmccann> mike-burns, it's harder than many languages but not by a huge margin
11:50:25 * albel727 doesn't know, why non-static typing even exists, besides the fact, that it's easier to implement.
11:50:45 <cmccann> on the other hand, having spent time helping people learn both, I'd say that Haskell is a good bit easier than  C++
11:51:13 <mike-burns> I don't want to think more than I have to, and Haskell is just fine for that.
11:51:13 <mm_freak_> PHP is very idiot-tolerant…  you can build entire company websites using only copy/paste code…  and the sad truth is this is done in practice
11:51:19 <cmccann> where "easier" here means "easier for someone who's never programmed before"
11:51:26 <DanBurton> the thing about Haskell is that once you've learned "the language" there's still much more to learn. Contrast to say, Java, where once you learn a few patterns you've pretty much hit the glass ceiling
11:51:48 <mike-burns> DanBurton: What more is there to learn in Haskell that isn't true of Java?
11:51:49 <monochrom> I know why dynamic typing exists. it is dependent typing checked at run time
11:51:51 <mike-burns> Libraries?
11:51:55 <cmccann> DanBurton, I think you underestimate the significance of other tools in the Java ecosystem
11:52:18 <DanBurton> cmccann: such as?
11:53:06 <cmccann> such as everything, basically? it's not really that different from Haskell in that regard.
11:53:10 <mm_freak_> monochrom: dynamic typing is the pragmatist's bad excuse for not having any type "system" at all
11:53:24 <cmccann> it's just that the higher abstraction levels in Haskell make more of it feel like complexity in the language vs. the individual libraries
11:53:59 <mm_freak_> monochrom: in agda you can express that one function takes values from the image of another function…  do you know a dynamically typed language that can do that on type level?
11:54:03 <mike-burns> (I'd also argue that being able to learn everything off a few patterns is actually better than needed to learn something new at every step.)
11:54:41 <mm_freak_> i also like the 'so' type from idris =)
11:54:59 <mm_freak_> sad that you can't express it in haskell
11:55:27 <cmccann> the sort of abstract computation-building we take for granted using Monad would end up being a whole bunch of slightly-different APIs in a language like Java, specific to each sort of computation
11:55:35 <cmccann> or they'd offload it to external configuration files or something else
11:56:46 <dolio> so is a McBride-ism.
11:56:50 <dolio> I believe.
11:58:17 <cmccann> looking at the idris documentation, the definition of "so" certainly reads like a McBride-ism
11:58:28 <dolio> Yes.
11:58:31 <cmccann> "oh : so True"
11:59:14 <danr> so is called T in the agda stdlib, but it's defined as a function instead of a data type
11:59:22 <monochrom> in dynamic typing, I express "this function takes values from the image of g" in a comment. why, it's dynamic typing, the type language is at the comment level
11:59:32 <dolio> It's also called _==_ True.
11:59:49 <danr> dolio: oh, so true :p
12:01:03 <mekeor> (why) is monomorphism restriction really such a big problem? just add the type signature and that's it…
12:01:12 <mm_freak_> in agda a good name would be ah! : uhm_?
12:01:18 <monochrom> so next you object that "but then the function body may also accept values outside the image of g". well, in practice, the same holds for the agda case.
12:01:50 <dolio> Dynamically typed languages aren't doing dependent type checking at runtime.
12:02:38 <mm_freak_> monochrom: i see, hence all the "You haven't read the comments!" exceptions in dynamic languages
12:04:29 <monochrom> or you can write guards in the function body
12:04:47 <cmccann> dolio, obviously it's lazy type checking, you get compiler errors at runtime only at whatever point you inspect the type of something and find that it doesn't type-check :P
12:05:25 <mm_freak_> it's also fuzzy checking…  the type system can be disabled by either not doing run-time checks or not writing comments
12:05:58 <monochrom> well, fine, next time I'll say dynamic typing is dependent typing without checks
12:06:02 <mm_freak_> though there are some strong dynamic languages, where this feature isn't as flexible
12:06:44 <dolio> What does that mean?
12:06:54 <dolio> It just not checking types.
12:07:02 <Rc43_> Can't find monad example for parsers.
12:07:27 <dolio> It's pretty widely known that type checking rules out terms that are allowed when you don't check.
12:07:30 <mm_freak_> seriously…  strong dynamic typing…  does that make sense to anyone?  you could just as well have static typing
12:07:41 <dolio> And various type systems rule out more terms than others.
12:07:52 <Rc43_> Interesting because I noticed that functions like `x -> (a, x)` can be chained with monads (not sure).
12:08:05 <mm_freak_> Rc43_: that's state monads
12:08:25 <Rc43_> mm_freak, may be
12:08:41 <Rc43_> mm_freak, parsing monads aren't same?
12:08:44 <mm_freak_> parsers can be written in terms of state monads, but usually they de-MTL to something slightly more complicated
12:09:01 <mm_freak_> String -> (a, String) basically
12:09:09 <mm_freak_> slightly more complicated though
12:09:18 <mm_freak_> to allow failure
12:09:34 <Rc43_> mm_freak, want to apply it for case x -> (a,x), where x isn't list-like
12:10:20 <mm_freak_> Rc43_: what data structure do you want to parse?
12:11:09 <monochrom> in dynamic typing, you can do this: take two parameters b, o. if b, you use o.m; if not b, you use o.n. that is the dependent type (b :: Bool) -> (if b then {m, ... } else {n, ...}) -> ...
12:11:39 <dolio> Otherwise we might as well start saying that '\[x,y,z] -> ...' is doing dependent typing like stuff, because dynamically it accepts things from Vec 3 instead of List.
12:11:54 <Rc43_> mm_freak, not parse in common meaning. I have complex structure of some related maps, like DB. Want to query some info. So not parsing, but querying.
12:12:09 <Rc43_> mm_freak, and transformations with querying too.
12:12:25 <Rc43_> mm_freak, example: insert new value and return id it places
12:12:30 <mm_freak_> Rc43_: that's two unrelated concepts then…  make your querying primitives first
12:13:04 <mm_freak_> monochrom: i'm not sure if that's really meaningful
12:13:11 <Rc43_> now I just want to implement chaining in a pretty way
12:13:33 <mekeor> Assuming i'm defining a data type 'AType' using GADTs, all constructors of that type must either be of type AType itself or they have to be a function of type "... -> AType", right?
12:14:10 <mm_freak_> Rc43_: chaining of what?
12:14:27 <Rc43_> mm_freak, of functions `x -> (a,x)`
12:14:49 <Rc43_> mm_freak, and accumulating results
12:15:45 <mm_freak_> Rc43_: end results or intermediary results?
12:17:31 <Rc43_> mm_freak: pseudo-syntax: `f1 >>> f2 >>> f3 ||| arg = [a1,a2,a3]` (there are can be different types of results, so may be I need heterogenous lists or chainging will be only with same-results-functions).
12:19:15 <Rc43_> Or not heterogenous but common type for result (`data Result = Id a | Search xs | etc.`)
12:19:17 <mm_freak_> Rc43_: from which category is (>>>) there?
12:19:47 <mm_freak_> stay on the ground…  i'm pretty sure you don't need anything fancy…  i rather have the impression that you're making problems
12:20:06 <Rc43_> mm_freak =/ Tried to use not-used symbol, didn't know that `>>>` is already taken
12:20:21 <Rc43_> mm_freak, it is just chaining operator
12:20:25 <mm_freak_> all symbols you used are already taken =)
12:20:32 <mm_freak_> Rc43_: give me a concrete example
12:20:33 <monochrom> if you don't import Control.Arrow or Control.Category, >>> is not taken
12:21:01 <Rc43_> monochrom, taken is more common meaning
12:21:37 <mm_freak_> Rc43_: often thinking concretely makes you realize that you've been too creative about problems
12:22:48 <mm_freak_> of course s -> (a, s) is modelled by the state monad 'State s', so for composition you would use (<=<) from Control.Monad
12:23:00 <mm_freak_> but i'm not convinced you need it
12:23:13 <Rc43_> mm_freak, example: `insertValue >>> searchMatchedNodes >>> insertNode >>> querySize == [Id val1, SearchingResult [n1,n2,n3], Id n4, Int 157]`
12:23:22 <Rc43_> mm_freak, I will look at it
12:23:33 <mm_freak_> is it an impure/mutable database?
12:23:52 <Rc43_> mm_freak, immutable
12:24:01 <Rc43_> impure > immutable?
12:24:21 <Rc43_> (yes, but which examples?)
12:24:24 <mm_freak_> multable implies impure
12:24:40 <tomodo> hello
12:24:41 <Rc43_> When immutable is impure?
12:24:59 <tomodo> for which dimensions is connect 3 and 4 a win,lose or draw?
12:25:00 <mm_freak_> in any case, it really sounds like your operations would be State Database operations
12:25:20 <mm_freak_> Rc43_: when you want it to be
12:26:15 <mm_freak_> and immutable data structure can have impure operations, but a mutable data structure cannot have pure operations
12:26:35 <albel727> speaking of lambdabot. is there a way to make it change its irc mode? (I'm running it on my channel)
12:27:15 <Rc43_> mm_freak, ok, `immutable` can be applied only to structures, so now it is clear
12:27:22 <dmwit> tomodo: I'm curious: what makes you think we would know?
12:27:27 <Rc43_> mm_freak: `newtype State s a = State { runState :: (s -> (a, s)) }` It is only for one result type?
12:27:42 <mm_freak_> Rc43_: no, check the type of (>>=)
12:27:53 <tomodo> #haskell would know about perfect play
12:28:03 <mm_freak_> Rc43_: or fmap for that matter
12:28:12 <mm_freak_> :t fmap State
12:28:13 <lambdabot> Not in scope: data constructor `State'
12:28:20 <flixil> Hello, i'm following lisperati.com haskel tutorial after reading "Learn yourself haskel for a greater good" and there is a sentence I'm quite unable to understand in http://lisperati.com/haskell/ht4.html  Thats:    readPoint s | Just [x,y] <- matchRegex (mkRegex "([0-9.]+),([0-9.]+)") s = (read x,read y)
12:28:21 <mm_freak_> :t State fmap
12:28:22 <lambdabot> Not in scope: data constructor `State'
12:28:38 <mm_freak_> oh, stupid me
12:28:39 <dmwit> Why would #haskell know the perfect play for connect four? How is connect four related to Haskell at all?
12:29:20 <mm_freak_> flixil: what part of that is unclear?
12:29:27 <flixil> I think readPoint is a pure function even if it´s using <- and I think this <- has nothing to do with list comprehensions. What else could it be then or what is it?
12:29:39 <dmwit> Never mind, it's not important. Anyway, we probably don't know any more than what Google does on this topic.
12:29:42 <mm_freak_> flixil: it's a pattern guard
12:29:57 <mm_freak_> flixil: f x | Just y <- g x = z
12:30:11 <mm_freak_> the pattern matches when the result of 'g x' is 'Just y' for any y
12:30:34 <nand`> @type flip (flip fmap `asAppliedTo` (undefined :: State s a))
12:30:35 <lambdabot> forall a b s. (a -> b) -> StateT s Identity a -> StateT s Identity b
12:30:38 <nand`> prolly a nicer way to get it
12:31:16 <Rc43_> mm_freak, can't find API for Control.Monad.State
12:31:24 <mm_freak_> dmwit: by extension we know nothing more than everything =)
12:31:47 <mm_freak_> Rc43_: http://hackage.haskell.org/packages/archive/mtl/2.0.1.0/doc/html/Control-Monad-State-Lazy.html
12:32:04 <Rc43_> mm_freak, oh, lazy
12:32:06 <monochrom> maybe you want Strict not Lazy
12:32:36 <mm_freak_> if you don't know which one you want, you want Lazy =)
12:32:44 <monochrom> ok!
12:33:12 <flixil> mm_freak, still not quite sure i understand the point as a pattern guard can just be:    f x |  checkingFunction x = output
12:33:26 <mm_freak_> flixil: no, that's just a guard =)
12:33:26 <flixil> what about the  <-
12:33:31 <nand`> Are there any “asX” functions beside asTypeOf and asAppliedTo?
12:33:34 <mm_freak_> flixil: a "pattern guard" is something specific
12:33:39 <monochrom> no, it's f x | pattern <- expression = output
12:33:50 <nand`> (for lambdabot)
12:33:58 <monochrom> and it means: evaluate expression, match against pattern
12:34:06 <mm_freak_> flixil: it basically saves you from cascading 'case' expressions
12:34:30 <mm_freak_> flixil: f x = case g x of Just y -> z1; Nothing -> z2
12:34:32 <monochrom> right, it is the same as: f x = case expression of pattern -> output
12:34:45 <Rc43_> btw, which hugest pluses have lazy evaluation on practice?
12:34:56 <mm_freak_> with pattern guards:  f x | Just y <- g x = z1; f x = z2
12:35:35 <dzhus> I need something like memoization for my functions, but with possibility to forget all memoized results on request (so it can work like cache), what approach do I take?
12:35:52 <monochrom> it is rather new, and so LYAH probably doesn't have it
12:36:04 <mm_freak_> Rc43_: lazy evaluation lets you separate concerns…  with lazy evaluation you can write stuff ad hoc, for which other languages need to provide specific language support
12:36:29 <Rc43_> mm_freak, second isn't clear
12:36:35 <mm_freak_> Rc43_: for example the equivalent to a tight search loop in other languages is:  write a list and consume it
12:36:35 <flixil> mm_freak_ Thanks a lot :) is there any tutorial i can read about it?
12:37:28 <Rc43_> mm_freak< what is `tight search loop` ?
12:37:59 <ovechkin> how do you extract every other element from a list?
12:38:24 <mm_freak_> flixil: well, the size of the topic really doesn't justify a tutorial, but there is this:  http://www.haskell.org/haskellwiki/Pattern_guard
12:38:37 <rwbarton> ovechkin, explicit recursion is probably easiest and clearest
12:38:52 <mm_freak_> > map head . takeWhile (not . null) . iterate (drop 2) $ [1..10]
12:38:54 <lambdabot>   [1,3,5,7,9]
12:38:57 <mm_freak_> @ ovechkin
12:39:15 <ovechkin> rwbarton: mm_freak_ thanks
12:39:44 <mm_freak_> Rc43_: for example you search for the smallest square number that is > 100 and just assume there is no simple formula
12:40:20 <mm_freak_> generate the list of squares:
12:40:30 <mm_freak_> > iterate (\(r, x) -> (r + 1, x + 2*r + 1)) (0, 0)
12:40:31 <lambdabot>   [(0,0),(1,1),(2,4),(3,9),(4,16),(5,25),(6,36),(7,49),(8,64),(9,81),(10,100)...
12:40:37 <mm_freak_> then consume it
12:41:01 <mm_freak_> > head . dropWhile ((< 100) . snd) $ iterate (\(r, x) -> (r + 1, x + 2*r + 1)) (0, 0)
12:41:03 <lambdabot>   (10,100)
12:41:11 <mm_freak_> > head . dropWhile ((<= 100) . snd) $ iterate (\(r, x) -> (r + 1, x + 2*r + 1)) (0, 0)
12:41:13 <lambdabot>   (11,121)
12:41:24 * hackagebot sbv 1.2 - Symbolic bit vectors: Bit-precise verification and automatic C-code generation.  http://hackage.haskell.org/package/sbv-1.2 (LeventErkok)
12:41:25 <Rc43_> ok, understood
12:41:26 <MostAwesomeDude> I like how "no simple formula" turns into an iterative approach.
12:41:59 <MostAwesomeDude> \(r, x) -> (r + 1, (r + 1) * (r + 1)) -- Really.
12:41:59 <monochrom> most of programming are iterative approaches
12:42:13 <Rc43_> what about separating concerns?
12:42:29 <DanBurton> most good programming practices contradict each other
12:42:34 <monochrom> you have separated generator and checker
12:42:49 <rwbarton> Rc43_: there's a classic paper on the topic, "Why Functional Programming Matters"
12:42:52 <mm_freak_> Rc43_: here i have separated the generation from the search
12:43:10 <mekeor> so, in *type signature*, '[a]' is syntactic sugar for '[] a', right?
12:43:20 <DanBurton> mekeor: correct
12:43:21 <monochrom> I think so
12:43:23 <mm_freak_> and i can do it because of laziness…  note that the code compiles to a simple constant space loop
12:43:26 <rwbarton> sections 4-5 are particularly about lazy evaluation
12:43:29 <monochrom> > [1,2] :: [] Int
12:43:30 <lambdabot>   [1,2]
12:43:33 <mekeor> :k []
12:43:34 <lambdabot> * -> *
12:43:36 <mekeor> nice
12:43:47 <Rc43_> mm_freak, but there separated concerns are tool, but not an aim
12:44:01 <paolino> @src []
12:44:01 <lambdabot> data [] a = [] | a : [a]
12:44:02 <Rc43_> mm_freak, hm, forgot
12:44:19 <cmccann> mekeor, the same applies to ((->) a b) and ((,) a b)
12:44:21 <DanBurton> you might even say [a] is syntactic sugar for ([] a)
12:44:39 <DanBurton> @type undefined :: IO [] a
12:44:40 <lambdabot>     `IO' is applied to too many type arguments
12:44:40 <lambdabot>     In an expression type signature: IO [] a
12:44:40 <lambdabot>     In the expression: undefined :: IO [] a
12:44:46 <mm_freak_> Rc43_: more generally in haskell you can write things like 'if' as functions and 'for' as combinators
12:44:49 <DanBurton> @type undefined :: IO ([] a)
12:44:50 <lambdabot> forall a. IO [a]
12:44:51 <monochrom> IO ([] a)
12:45:15 <Rc43_> mm_freak, yeah, understood. Orthogonal primitives and combinators for them.
12:45:17 <mm_freak_> Rc43_: solving problems in haskell often involves first inventing a language to express the problem in
12:45:25 <mm_freak_> laziness plays an important role there
12:45:34 <albel727> @echo test
12:45:34 <lambdabot> echo; msg:IrcMessage {msgServer = "freenode", msgLBName = "lambdabot", msgPrefix = "albel727!~albel727@unaffiliated/albel727", msgCommand = "PRIVMSG", msgParams = ["#haskell",":@echo test"]} rest:"
12:45:35 <lambdabot> test"
12:45:43 <albel727> @echo テスト
12:45:43 <lambdabot> echo; msg:IrcMessage {msgServer = "freenode", msgLBName = "lambdabot", msgPrefix = "albel727!~albel727@unaffiliated/albel727", msgCommand = "PRIVMSG", msgParams = ["#haskell",":@echo \227\131\134\
12:45:43 <lambdabot> 227\130\185\227\131\136"]} rest:"\227\131\134\227\130\185\227\131\136"
12:46:04 <albel727> meh. so it actually doesn't support unicode.
12:46:08 <Rc43_> mm_freak, but why laziness by default but not on demand?
12:46:22 <monochrom> it partly does and partly doesn't
12:46:24 * hackagebot sbv 1.3 - Symbolic bit vectors: Bit-precise verification and automatic C-code generation.  http://hackage.haskell.org/package/sbv-1.3 (LeventErkok)
12:46:27 <MostAwesomeDude> mm_freak_: Why not solve the problem in Haskell instead of inventing a language?
12:46:42 <monochrom> > let x ⊕ y = x+y in 1⊕2
12:46:43 <lambdabot>   3
12:46:49 <monochrom> to that extent it works
12:46:50 <albel727> hmm. and @reconnect is not working either. =(
12:47:16 <MostAwesomeDude> Rc43_: Lazy by default reduces the amount of computation that must be done.
12:47:35 <DanBurton> MostAwesomeDude: what he means is that you do solve the problem in Haskell, with custom functions that make the solution natural
12:47:55 <MostAwesomeDude> DanBurton: What does "natural" mean here? "Elegant?"
12:48:13 <DanBurton> Not necessarily "elegant" per se...just the "normal" way you would want to solve the problem
12:48:42 <MostAwesomeDude> What if the "normal" way is ass-backwards?
12:48:44 <monochrom> people are lazy about laziness. that is, if laziness is not the default, people write excellent library support for eagerness and non-existent library support for laziness. for example, empirically, all eager-by-default languages enjoy almost no lazy-list lib
12:49:06 <DanBurton> MostAwesomeDude: then you can probably find a more elegant way to do it in Haskell anyways
12:49:15 <MostAwesomeDude> This seems specious.
12:49:35 <Saizan> don't most languages have iterators now?
12:49:45 <albel727> define "most"
12:49:52 <DanBurton> define "iterators"
12:49:55 <MostAwesomeDude> Define "iterator" too, while you're at it. :3
12:49:59 <albel727> define "define"
12:50:07 <DanBurton> define "language" ;)
12:50:12 <Saizan> nevermind.
12:50:21 <mekeor> lol :D
12:50:26 <albel727> define "have"
12:50:27 <Rotaerk> define the undefinable
12:50:31 <albel727> define "nevermind"
12:50:36 <MostAwesomeDude> I like Python's approach: Both lazy and eager iterables are iterable, but have different types and cause TypeErrors when used wrong.
12:50:39 <dgpratt> so I'm reading this http://en.wikibooks.org/wiki/Haskell/Zippers (again)...
12:50:46 <MostAwesomeDude> So you don't have to care, except when you're Doin' It Wrong.
12:50:52 <mm_freak_> MostAwesomeDude: with "language" i mean an embedded domain-specific language
12:51:04 <MostAwesomeDude> mm_freak_: Oh. Well, why doesn't Haskell come with DSL tools?
12:51:06 <_vic> I'm reading this again http://www.haskell.org/arrows/syntax.html but... I'm light-years away
12:51:11 <mm_freak_> MostAwesomeDude: it does
12:51:17 <DanBurton> MostAwesomeDude: cause TypeErrors *at runtime
12:51:24 <dgpratt> ...and it's mostly making sense, until I get to the section "Zippers via Differentiation"...
12:51:32 <mm_freak_> MostAwesomeDude: it has ADTs, pattern matching, etc.
12:51:34 <MostAwesomeDude> DanBurton: You can write everything in RPython if you really want.
12:51:34 <Rotaerk> is there a difference between a EDSL and like... a library/API
12:51:35 <_vic> dgpratt: try lyah
12:51:38 <Ralith> see the invisible
12:51:51 <mm_freak_> Rotaerk: in haskell usually no
12:51:53 <MostAwesomeDude> mm_freak_: Can I write line noise, like in CL?
12:51:57 <mm_freak_> parsec is an EDSL for parsing
12:52:17 <mm_freak_> MostAwesomeDude: if you want a non-embedded DSL you can use quasiquotes
12:52:18 <dgpratt> ...and now I can't make heads nor tails of this definition "μF := μX.F X"
12:52:27 <Rotaerk> so EDSL is basically an ancient concept that's been rebranded
12:52:34 * _vic shrugs 
12:52:49 <dgpratt> (where F is a polynomial functor)
12:52:59 <mm_freak_> Rotaerk: EDSL is an old concept…  common lisp may have introduced it in a practical language, though you might find even older languages using it
12:53:13 <Rotaerk> C has it
12:53:38 <Rotaerk> you can make a library in C, i.e. a collection of functions and data structures to solve a particular kind of problem with
12:53:42 <dgpratt> pretty sure I know what a polynomial functor is, but I can't make heads nor tails of that definition; can it be translated into Haskell (or something close to it)?
12:54:00 <b0fh_ua> Hi all! is there any quick fix to overcome: 'thread blocked indefinitely in an MVar operation' or at least identify which mvar is affected?
12:54:04 <companion_cube> Rotaerk: library and EDSL are not the same thing
12:54:12 <MostAwesomeDude> mm_freak_: If there's a library that lets me do [ly|c4 c g g a a g2 f4 f e e d d c2|] then I'll be convinced.
12:54:18 <mm_freak_> Rotaerk: by that broad definition yes, C has it, but it provides very poor tools for EDSLs
12:54:38 <companion_cube> because a library is just a collection of functions
12:54:46 <MostAwesomeDude> Although I suppose the better example would be [|####@#@#@!^&^@####@#@&@^#@#%@#|]
12:54:47 <Rotaerk> right
12:54:52 <companion_cube> and does not provide any syntactic convenience
12:55:05 <mm_freak_> MostAwesomeDude: what's that?
12:55:15 <Rotaerk> so the ability to create new infix operators makes it a EDSL?
12:55:31 <mm_freak_> Rotaerk: no, the ability to make control structures
12:55:39 <MostAwesomeDude> mm_freak_: First one is Ly, no bars (since that would be cheating.) Second one is similar to a CL parser library I saw once that defined a bunch of macros and then switched to a wall of line noise.
12:55:48 <dmwit> b0fh_ua: There are no quick fixes for multi-threaded errors.
12:55:52 <Rotaerk> you mean domain specific abstractions
12:55:58 <mm_freak_> Rotaerk: in haskell data structures aren't bound to concrete memory representations
12:56:03 <mm_freak_> there might be none at all
12:56:10 <MostAwesomeDude> mm_freak_: Ly requires | occasionally; can QQs handle [ly|c d e f | g f e d | c1|] ?
12:56:10 <mm_freak_> and control structures are just functions
12:56:27 <mm_freak_> MostAwesomeDude: i think so, but i'm not sure…  why is that so important?
12:56:48 <DanBurton> I think it highly likely
12:56:52 <MostAwesomeDude> mm_freak_: Because Ly is already an existing language and uses those bars. They are *essential* for bigger pieces.
12:57:05 <MostAwesomeDude> And it's hard to find any docs on QQs. I had to learn them from context when doing Yesod.
12:57:38 <mm_freak_> MostAwesomeDude: i have no experience with writing quasiquoters…  the biggest i have done is a quasiquoter for here-documents
12:57:58 <MostAwesomeDude> 'k.
12:58:13 <cmccann> yes, documentation and especially worked examples are sadly lacking for lots of TH stuff
12:59:01 <b0fh_ua> dmwit: but at least I'd like to get some indea of which mvar is affected
12:59:02 <cmccann> playing with yesod might actually be one of the best places to start right now, because it's pretty well-documented and uses lots of TH
12:59:26 <dmwit> b0fh_ua: Yes, that would be nice. What would you expect the report to say, though?
12:59:33 <dmwit> How do you identify an MVar?
12:59:42 <dmwit> or: what does "which mvar" mean?
12:59:46 <MostAwesomeDude> My POV is that we are at an era when DWIM is actually almost practical, and we should be able to use DSLs at any point to express what we want done.
12:59:58 <DanBurton> challenge: fill in the blank: _____ is an even better demonstration of Template Haskell than Yesod
13:00:36 <MostAwesomeDude> "The Mythical Long-Lost Template Haskell Tutorial of Captain Cooke"
13:00:50 <clemux> hi; I don't understand why "putStr ">>> "; cmd <- getLine" prints ">>>" after the user hits <return>... sorry if that's a dumb question, I was not sure how to search that on google...
13:01:09 <mauke> clemux: putStr ">>> "; hFlush stdout
13:01:21 <DanBurton> clemux: by default Haskell uses line buffering
13:01:42 <mm_freak_> for me EDSLs suffice
13:01:46 <DanBurton> clemux: you need to either hFlush as mauke suggests, or change the buffering with hSetBuffering from System.IO
13:01:51 <mm_freak_> haskell's syntax is lightweight enough to make them feasible
13:01:52 <b0fh_ua> dmwit: name of variable would be helpful :)
13:01:59 <mauke> changing the buffering mode is not recommended
13:02:27 <_vic> tried to install Euterpea and it broke some packages.
13:02:28 <cmccann> b0fh_ua, an MVar may be associated with any number of variable names, including zero
13:02:28 <clemux> oh, ok thanks, I'll look into that :)
13:02:33 <_vic> Yesod too...
13:02:42 <DanBurton> right, for a simple thing like printing out a prompt, changing the buffering mode is a little over the top
13:03:09 <DanBurton> _vic: I had that happen to me a while ago.
13:03:28 <_vic> How did you fix them?
13:03:41 <DanBurton> I reinstalled ghc >.>
13:03:46 <DanBurton> not the recommended approach
13:03:52 <_vic> Yep
13:03:55 <_vic> But the easy one
13:03:56 <tomodo> Hello
13:04:00 <tomodo> I have my AI results now
13:04:05 <mekeor> yippie!!
13:04:07 <dmwit> b0fh_ua: What should it report for newEmptyMVar >>= takeMVar?
13:04:08 <tomodo> claim: 5x4 connect 4 is a draw with perfect play
13:04:12 <mekeor> tomodo: result?
13:04:16 <_vic> There are problems in package X dependency Y  doesn't exist is madness.
13:04:19 <tomodo> my program computer in 252.155s CPU time, 1.712s GC time
13:04:39 <srhb> Does anyone know where the macosx-app script comes from? Can I search hackage for file names?
13:04:42 <dmwit> b0fh_ua: (I'm trying to get you to admit that "name of variable" doesn't really make sense.)
13:04:51 <tomodo> is anyone able to verify?
13:05:14 <DanBurton> _vic: I have since learned to use --dry-run before doing a cabal install
13:05:25 <_vic> Ah, yes
13:05:34 <_vic> Found out later about that option
13:06:13 <_vic> Have you managed to make Euterpea run?
13:06:17 <DanBurton> fortunately the new version of cabal will prevent you from installing if doing so would break things
13:06:43 <DanBurton> _vic: I actually installed it just a few days ago.
13:07:08 <_vic> What version of ghc?
13:07:11 <DanBurton> _vic: I never got the "play" functionality working, but it can write a midi file
13:07:14 <DanBurton> 7.4.1
13:07:19 <_vic> Excellent
13:07:29 <DanBurton> There was some pain involved
13:07:33 <DanBurton> I forget what it was though
13:07:34 <_vic> I know
13:07:42 <mekeor> hmm... #haskell always said that the type class 'Monad' is a subclass of 'Applicative' (which is a subclass of 'Functor') but technially that doesn't seem to be correct. so, is it right or wrong??
13:07:42 <mekeor> @src Monad
13:07:43 <lambdabot> class  Monad m  where
13:07:43 <lambdabot>     (>>=)       :: forall a b. m a -> (a -> m b) -> m b
13:07:43 <lambdabot>     (>>)        :: forall a b. m a -> m b -> m b
13:07:43 <lambdabot>     return      :: a -> m a
13:07:43 <lambdabot>     fail        :: String -> m a
13:07:44 <_vic> But it's a very interesting package
13:07:59 <lispy> ?quote
13:07:59 <lambdabot> sethk says: it's certainly true that you can clobber the stack in C without even getting out of bed in the morning
13:08:07 <_vic> And Haskell School of Music is awesome
13:08:59 <PatrickRobotham> mekeor: Well, it's not true in the source, but it's true mathematically.
13:09:00 <DanBurton> mekeor: it's theoretically correct, but the standard libraries do not enforce it
13:09:15 <mekeor> DanBurton: why not?
13:09:20 <PatrickRobotham> mekeor: Any monad can be made an instance of Applicative. Any applicative functor can be made an instance of Functor.
13:09:28 <DanBurton> convenience, supposedly
13:09:32 <cmccann> mekeor, because the standard libraries are wrong
13:09:37 <cmccann> and Applicative is newer than Monad
13:09:54 <cmccann> (there's no good reason for Monad not to imply Functor though)
13:10:07 <mekeor> PatrickRobotham: any applicative functor MUST be an instance of Functor!
13:10:19 <PatrickRobotham> mekeor: Really?
13:10:21 <mekeor> cmccann: ah
13:10:25 <PatrickRobotham> @src Applicative
13:10:25 <lambdabot> class Functor f => Applicative f where
13:10:26 <lambdabot>     pure  :: a -> f a
13:10:26 <lambdabot>     (<*>) :: f (a -> b) -> f a -> f b
13:10:26 <mekeor> @src Applicative
13:10:26 <lambdabot> class Functor f => Applicative f where
13:10:26 <lambdabot>     pure  :: a -> f a
13:10:27 <mekeor> ah
13:10:28 <lambdabot>     (<*>) :: f (a -> b) -> f a -> f b
13:10:46 <DanBurton> I've been working on my own version of Prelude to fix such things. https://github.com/DanBurton/sexy
13:11:00 <DanBurton> (pet Preludes are the new monad tutorials)
13:11:33 <cmccann> Monad could instead be defined as something like "class (Applicative m) => Monad m where join :: m (m a) -> m a"
13:12:03 <DanBurton> https://github.com/DanBurton/sexy/blob/master/src/Sexy/Classes/Monad.hs
13:12:37 <PatrickRobotham> DanBurton: I think we know everything about Monads now. They're burritos!
13:13:09 <companion_cube> burritos in space suits
13:13:33 <Enigmagic> i prefer enchiladas
13:13:39 <DanBurton> my only objection to the burrito analogy is that I dislike mexican food
13:14:08 <Enigmagic> burritos aren't really proper mexican food
13:14:11 <DanBurton> it's a pity we didn't latch onto something like "cream puff" instead
13:14:28 * PatrickRobotham wonders what a burrito of burritos would be like
13:14:31 <DanBurton> which would go along nicely with the "warm fuzzy thing"
13:14:54 <Enigmagic> PatrickRobotham: in the turducken style?
13:19:32 <phpDude> why haskell?
13:19:39 * Clint nods.
13:21:39 <mekeor> phpDude: because it sucks less. especially less then PHP.
13:21:45 <skchrko> phpDude, because his parents wanted such a name
13:22:20 <mekeor> phpDude: Because God wants us to use it.
13:22:26 * raichoo fetches popcorn
13:22:40 <Enigmagic> i use haskell because it has a funny sounding name, and it takes a while to link apps just like c++
13:23:02 <companion_cube> good reasons!
13:23:07 <ion> I use Haskell because of bad burrito jokes.
13:23:11 <dmwit> phpDude: Haskell has the finest lightweight static analysis tools available.
13:23:26 <rostayob> I vaguely remember a library the let you define a serializer and gave you a deserializer for free
13:23:28 <dmwit> 75% of bugs just don't make it past the compiler.
13:23:30 <rostayob> of course with some limitations
13:23:32 <mekeor> phpDude: And Haskell makes fun. The community is cool, the principles it is based upon are different from any other… :)
13:23:51 <dmwit> welp
13:23:53 <byorgey> rostayob: http://hackage.haskell.org/package/invertible%2Dsyntax ?
13:24:10 <dmwit> He was gone by the time anybody even bothered to answer.
13:24:11 <rostayob> byorgey: that sounds good, thanks
13:24:50 <companion_cube> his IRC client was probably written in php
13:26:26 <raichoo> companion_cube: :3
13:27:00 <ion> byorgey: Interesting. But why use names that conflict with standard classes, such as Alternative, (<*>), pure?
13:27:20 <byorgey> ion: don't ask me, I didn't write it
13:27:40 <ion> Should have added “i wonder”. I didn’t think you did.
13:28:10 <byorgey> ion: there's a very nice paper about that library in the 2010 Haskell Symposium which I think goes into some of the design decisions
13:28:36 <byorgey> http://www.mathematik.uni-marburg.de/~rendel/rendel10invertible.pdf
13:28:42 * mekeor doesn't understand anything of that paper…
13:29:34 <byorgey> mekeor: so pick the first thing you don't understand, and go learn about that
13:29:40 <rata_> hi guys
13:29:40 <byorgey> (recursively)
13:29:47 <ion> byorgey: Thanks
13:31:42 <ciaranm> any reason liftA2 (,) and liftA3 (,,) and so on don't have names?
13:33:00 <ion> They do. They’re called “liftA2 (,)” and “liftA3 (,,)”.
13:33:13 <byorgey> ciaranm: because names would not be much shorter than those expressions already are.
13:33:27 <byorgey> it would just be one more thing to remember with not much benefit.
13:33:32 <ciaranm> but <* and *> and so on have names
13:33:53 <mm_freak_> ciaranm: there is historical reason for that
13:33:59 <mm_freak_> for (*>) at least
13:34:07 <byorgey> ciaranm: well, there's a fine line between what's worth giving a name and what isn't.
13:34:08 <DanBurton> how good is compiler support for TypeOperators? (uhc, hugs, etc?)
13:34:11 <mm_freak_> (<*) isn't as simple to define
13:34:17 <Enigmagic> :t (*>)
13:34:18 <lambdabot> forall (f :: * -> *) a b. (Applicative f) => f a -> f b -> f b
13:34:23 <mm_freak_> :t liftA2 const
13:34:24 <lambdabot> forall a b (f :: * -> *). (Applicative f) => f a -> f b -> f a
13:34:24 <byorgey> of course I'm not claiming the standard libraries always get it right.
13:34:27 <Sgeo> <* could be called prog1
13:34:29 * Sgeo ducks
13:34:39 <mm_freak_> :t liftA2 (flip const)
13:34:40 <lambdabot> forall b a (f :: * -> *). (Applicative f) => f a -> f b -> f b
13:35:00 <ciaranm> liftA2 (,) and so on are really handy when doing things with parsec
13:35:37 <Enigmagic> ciaranm: i see a lot more code written using the operators than liftA2 (,)... like "(,) <$> x <*> y"
13:35:52 <mm_freak_> Enigmagic: though i find that really ugly
13:35:57 <mm_freak_> i prefer liftA2 (,)
13:36:08 <Enigmagic> mm_freak_: i don't disagree, i just see more of it written that way
13:36:32 <ciaranm> let's take parsec as an example... if you have an x then a y, and you want the x, you use <*. if you have an x then a y, and you want the y, you use *>. if you want them both, you use do notation...
13:36:51 <mm_freak_> ciaranm: or you use liftA2 X
13:37:11 <mm_freak_> and commonly X ≠ (,)
13:37:19 <hpaste> erkin pasted “Supposed palindrome finder of product of two three digit numbers.” at http://hpaste.org/64334
13:37:35 <tomodo> sounds liek PROJECT EULER
13:37:35 <tomodo> To me
13:37:40 <erkin> Exactly.
13:37:49 <ciaranm> mm_freak_: it's silly that some of these have nice notation and that some of them don't
13:38:21 <mm_freak_> ciaranm: "nice" is subjective…  perhaps you want more than another combinator
13:38:23 <erkin> What exactly am I doing wrong?
13:38:27 <mm_freak_> you might find idiom brackets useful
13:39:17 <mm_freak_> ciaranm: there is simply no justification to add the one operator you miss over any of the other thousands of combinators some people feel MUST go into the base library
13:39:49 <mm_freak_> for example i really miss a combinator for head . filter p
13:39:58 <mm_freak_> or equivalently fromJust . find p
13:40:12 <ciaranm> mm_freak_: yes there is. i care about it. i don't care about the rest. that's all the justification i need!
13:40:59 <byorgey> erkin: [x| y <- [100..999], z <- [100..999], (y * z) == x]  is wrong
13:41:07 <erkin> Oh?
13:41:21 <byorgey> erkin: (y * z) == x  tests whether x is equal to y*z but there is nothing called x in scope
13:41:31 <erkin> Ahh.
13:41:38 <erkin> I must use <- then?
13:41:43 <luite> let
13:41:45 <byorgey> erkin: if you want to *define* x to be equal to y*z  then you should write   [x| y <- [100..999], z <- [100..999], let x = y*z]
13:42:03 <byorgey> erkin: but in fact you should then just write  [ y*z  | y <- [100..999], z <- [100..999]]  instead
13:42:15 <erkin> ...why haven't I thought of that? >_<
13:42:15 <aavogt>   [ x | y <- [100..999], z <- [100..999], x <- [y*z] ] works too
13:42:52 <tgeeky_> because our brains are horrendous creatures which betray us at every opportunity
13:43:14 <byorgey> tgeeky_++
13:43:31 <erkin> [y*z| y <- [100..999], z <- [100..999]]  returns tons of compilation errors.
13:44:11 <ion> tgeeky_-- tgeeky++
13:44:56 <tgeeky_> ion: I'm both of them
13:45:04 <byorgey> erkin: paste the errors or it didn't happen.
13:45:12 <ion> Yeah, might as well ++ the primary one. :-P
13:45:16 <tgeeky_> ion: true
13:45:23 <tgeeky_> truecrypt is awesome
13:45:28 <tgeeky_> by the way.
13:45:33 <hpaste> erkin pasted “error” at http://hpaste.org/64335
13:47:20 <ion> erkin: You’re probably trying to use x1 as [[Int]] somewhere. Try adding a type signature for x1.
13:48:44 <abdelhalim> Can I get the module name from a loaded file using GHC APIs?
13:48:51 <DanBurton> Is there a cabal option that allows you to insert "import Foo" in every file before compiling?
13:49:19 <abdelhalim> The examples I found has the module name hardcoded in the function
13:50:42 <erkin> Also
13:50:52 <DanBurton> sort of the opposite of NoImplicitPrelude
13:50:55 <erkin> How do I tell if the program is hanging or actually running?
13:51:11 <ion> Simply by solving the halting problem.
13:51:13 <byorgey> erkin: what's the difference?
13:51:25 <erkin> The hanging program never returns anything.
13:51:36 <erkin> The working program just returns late.
13:51:49 <byorgey> erkin: it is impossible to tell, as proved by Alan Turing.
13:51:54 <erkin> Aww.
13:52:27 <DanBurton> You can tell *what* your program is doing with Debug.trace
13:52:41 <erkin> Well, can you at least tell me if it's valid code?
13:52:43 <hpaste> erkin pasted “palindrome test” at http://hpaste.org/64337
13:53:40 <DanBurton> reverse x1 is probably going to take a lot of time and memory
13:53:55 <erkin> So, it's valid?
13:53:58 <DanBurton> but it looks like a valid program
13:54:07 <erkin> \o/
13:54:23 <byorgey> erkin: x <- x1, y <- reverse x1, x == y   is going to test whether any of the numbers in x1 are equal to any of the numbers in the reverse of x1
13:54:29 <byorgey> which is probably not what you mean.
13:54:40 <erkin> Oh.
13:54:44 <erkin> I forgot to add digits.
13:55:04 <byorgey> erkin: I suggest writing a function   isPalindrome :: Int -> Bool
13:55:19 <erkin> Might be helpful.
13:55:27 <byorgey> you can easily test whether it is working by trying it on examples.
13:55:33 <DanBurton> erkin: if you reduce the numbers to 1..10 you can see that it terminates rather quickly
13:55:37 <byorgey> then you can insert it into a list comprehension as appropriate.
13:56:07 <ion> x <- x1, y <- reverse x1 is O(length x1^2) in time complexity.
13:56:26 <ion> (Well, ignoring the reverse.)
13:57:22 <ion> And x1 already has a length of 810000 (i think).
13:57:41 <ion> > 900^2^2
13:57:42 <lambdabot>   656100000000
13:58:20 <erkin> Hmm...
14:00:21 <DanBurton> also, I don't think it is doing what you think it is doing
14:00:28 <DanBurton> It seems you are using <- as if it were let
14:01:10 <erkin> I'm trying to use it as "for every element of this list".
14:01:37 <DanBurton> well that makes sense then
14:02:03 <DanBurton> except y <- reverse x1 doesn't seem right
14:02:17 <erkin> Yeah, I'm writing an isPalindrome function.
14:02:26 <DanBurton> that will probably help :)
14:03:35 <DanBurton> hrm. trying to think of how to redesign ListLike for my pet Prelude. You can do so much with list-y things..
14:05:20 <mm_freak_> > (900^2)^2
14:05:20 <lambdabot>   656100000000
14:05:20 <Veinor> DanBurton: what's ListLike?
14:05:45 <MaybeJust> @sm you got mail
14:05:45 * lambdabot clobbers you got mail with an untyped language
14:05:47 <mekeor> Veinor: he's talking about his prelude, called sexy (https://github.com/DanBurton/sexy)
14:06:01 <Veinor> ew
14:06:06 <DanBurton> Veinor: ListLike is a class that someone wrote: http://hackage.haskell.org/packages/archive/ListLike/3.1.4/doc/html/Data-ListLike-Base.html
14:06:21 <Veinor> ah ok
14:06:22 <mm_freak_> > 2^2^3
14:06:22 <mekeor> Veinor: i was wrong, sorry.
14:06:23 <lambdabot>   256
14:06:39 <DanBurton> mekeor: no you're right. I'm basically porting ListLike to my Prelude
14:06:44 <DanBurton> to my Sexy
14:06:51 <mekeor> ah okay
14:06:51 <mm_freak_> i wonder why (^) is always right-associative…  the most common usage seems to be left
14:07:52 <Veinor> because in math it's right-associative
14:08:11 <mm_freak_> Veinor: in math you can't even write it that way
14:08:12 <Veinor> and you can rewrite (x^y)^z as x^(y*z)
14:08:38 <mekeor> what does a "|" mean between "instance" and "where" ?
14:08:45 <mm_freak_> you can rewrite x^(y^z) as ((((((((((((((…
14:08:46 <mm_freak_> =P
14:09:02 <Veinor> mekeor: what do you mean?
14:09:10 <mm_freak_> mekeor: where did you see that?
14:09:12 <parcs`> mekeor: it marks the beginning of a list of functional dependencies
14:09:24 <mm_freak_> parcs`: fundeps belong to a class
14:09:27 <mekeor> Veinor: e.g.: "class (FoldableLL full item, Monoid full) => ListLike full item | full -> item where"
14:09:35 <parcs`> mm_freak_: oh right
14:09:40 <mekeor> parcs`: what?
14:09:46 <mm_freak_> mekeor: that's a functional dependency, and it's class-bound, not instance-bound
14:10:07 <mm_freak_> in an instance, 'item' follows from 'full'
14:10:28 <mm_freak_> class VectorSpace base v | v -> base
14:10:39 <mm_freak_> instance VectorSpace Double (Double -> Double)
14:10:56 <mm_freak_> Double follows from Double -> Double, i.e. you can't have a second instance:  instance VectorSpace Float (Double -> Double)
14:11:37 <mekeor> i don't get it. i'm probably not ready for that yet. i'll just read on LYAH…
14:11:41 <parcs`> the fundep a -> b asserts that if the typechecker knows what the parameter a is, then it can determine the parameter b
14:11:49 <parcs`> this comes with restrictions as mm_freak_ showed
14:12:08 <mm_freak_> the restriction is the rationale for fundeps
14:12:19 <mm_freak_> it basically improves type inference
14:12:27 <mekeor> fundeps? fundamentall dependecy?
14:12:36 <mm_freak_> functional
14:12:48 <mekeor> oh okay…
14:13:00 <mm_freak_> mekeor: fundeps are closely related to associated types (see type families)
14:14:03 <mekeor> http://www.haskell.org/haskellwiki/GHC/Type_families ?
14:14:16 <Enigmagic> yes
14:14:41 <mm_freak_> mekeor: http://www.haskell.org/haskellwiki/GHC/Type_families#An_associated_data_type_example
14:15:08 <mm_freak_> though fundeps are associated type synonyms
14:15:15 <bgamari> Could someone explain to me why "1" =~ "(\\d)" :: String == ""?
14:15:19 <bgamari> Using Text.Regex.Posix
14:15:19 <mm_freak_> http://www.haskell.org/haskellwiki/GHC/Type_families#An_associated_data_type_example
14:15:23 <mm_freak_> this is probably better @ mekeor
14:15:27 <mekeor> man, i though that i more or less got the gist of haskell's type system… but it seems endless complex… when you understand something there appears another topic which you don't understand…
14:15:57 <mekeor> s/though/thought/
14:15:59 <MaybeJust> can anyone give me a simple Monad to implement?
14:16:12 <zerax> maybe?
14:16:18 <tempire> what do the pipe symbols indicate? [| getConf |]
14:16:18 <ion> Identity
14:16:33 <mm_freak_> mekeor: if you are new to this, first understand the h2010 type system
14:16:33 <aavogt> tempire: template haskell
14:16:39 <mm_freak_> fundeps and type families are extensions
14:16:48 <mekeor> mm_freak_: h2010 tt?
14:16:56 <mekeor> haskell 2010 ?
14:16:58 <mm_freak_> mekeor: haskell 2010
14:17:12 <ion> “tt”?
14:17:12 <mekeor> mm_freak_: does h2010TT differ from h98TT ?
14:17:23 <parcs`> what do you think?
14:17:31 <mm_freak_> yes, h2010 is the current standard with some extensions turned into builtin features
14:17:35 <mm_freak_> like pattern guards =)
14:17:38 <Enigmagic> they released a new version that was the same as the old one :P
14:17:41 <mm_freak_> they used to be an extension
14:17:57 <mekeor> mm_freak_: oO pattern guards are part of h2010?? cool.
14:18:06 <mekeor> Enigmagic: hehe :)
14:18:11 <mm_freak_> mekeor: whenever you get along without the LANGUAGE pragma or -X flags, you're dealing with h2010
14:18:15 <mm_freak_> at least starting with GHC 7
14:18:29 <mm_freak_> i wish view patterns were part of h2010 =)
14:18:32 <mekeor> mm_freak_: yea i often used LANGUAGE pragmas…
14:18:34 <Philippa> mm_freak_: now I'll have to read the report, or a report diff, just to check what else that's cool made the cut
14:18:41 <mm_freak_> and also ScopedTypeVariables
14:19:01 <mekeor> mm_freak_: all language pragmas are H2010 ?
14:19:10 <mm_freak_> Philippa: there is a summary somewhere on the haskellwiki
14:19:13 <mekeor> i mean, part of…
14:19:41 <mm_freak_> mekeor: with the LANGUAGE pragma you enable extensions, so obviously when you use it you don't use haskell anymore =)
14:19:44 <mm_freak_> but haskell with some extension
14:19:52 <darkangel> Hi. Can I some how emulate C++ overloading to call generic foo on any Show type but for String and Text call different implementation?
14:19:55 <mekeor> Philippa: http://www.haskell.org/haskellwiki/Haskell_2010#Changes_since_Haskell_.2798 ?
14:20:32 <mm_freak_> darkangel: there is no ad hoc way, but you can write a wrapper newtype and use GeneralizedNewtypeDeriving for most instances and write some instances the way you want
14:20:41 <mauke> darkangel: no
14:20:50 <mekeor> mm_freak_: yea, okay, that's what i thought.  and haskell 2010 is by default "turned on" as of ghc 7.*, or what?
14:21:01 <mm_freak_> darkangel: although it really sounds like you're doing something you probably don't want to do anyway
14:21:07 <MaybeJust> can anyone give me a simple Monad to implement?
14:21:10 <mm_freak_> mekeor: yeah
14:21:15 <mekeor> mm_freak_: okay, thanks.
14:21:15 <mm_freak_> MaybeJust: State
14:21:38 <ion> maybejust: IO
14:21:43 <mm_freak_> MaybeJust: functions of type s -> (a, s) form a monad, so write a newtype for it and implement the Monad instance
14:21:44 <mekeor> simple?!?!
14:21:48 <mekeor> ion: ^
14:21:48 <mauke> MaybeJust: Maybe
14:22:28 <parcs`> the Cont monad is pretty simple
14:22:29 <mekeor> MaybeJust: maybe just nothing? :)
14:22:39 <parcs`> if you follow the types
14:22:45 <parcs`> you can't mess up!
14:23:03 <darkangel> I need to serialize data into xml. If I do show x, where x is String it apears in output as "foo" - in quotes, but for show y, where y is Int there is no quotes. How I should implement that&
14:23:04 <mm_freak_> there is also RState, which is pretty straightforward to write once you know State but extraordinarily difficult to understand =P
14:23:33 <ion> What relevance does show have with XML?
14:23:39 <mm_freak_> darkangel: Show is not meant to be used for serialization
14:24:23 <darkangel> Why I can't stick to default Show for simple Scalar types?
14:24:35 <mm_freak_> you can, as long as it works =)
14:24:36 <mauke> darkangel: there are no scalar types
14:24:43 <mauke> show is never appropriate for XML
14:24:47 <erkin> Yay, it's done.
14:24:56 <darkangel> mauke: I mean simle, as Int or String
14:25:04 <mauke> String is a list
14:25:08 <mauke> that's the opposite of a scalar
14:25:35 <mm_freak_> darkangel: you probably mean predefined
14:25:41 <mauke> list has two constructors, one without parameters, the other with two parameters, and it's recursive
14:25:44 <mauke> this is not simple
14:25:45 <Philippa> darkangel: 1 -- which type does this belong to?
14:26:03 <mm_freak_> darkangel: in haskell there is no such thing as a scalar or even "simple" type
14:26:26 <ion> data Simple = Simple
14:26:26 <Philippa> mm_freak_: eh, I wouldn't go that far. There's no special native concept for it, though
14:26:29 <monochrom> "simple" is subjective and ambiguous. sometimes people confuse "simple" with "familiar" or "I know"
14:26:30 <mm_freak_> in fact i'd say that Int is quite a complicated type compared to String
14:26:52 <darkangel> mm_freak_: Ok. I mean types that has simplest, direct mapping to string
14:27:01 <darkangel> As Int, Doublt, String, Text
14:27:02 <Philippa> mm_freak_: butbutbut it's finite, that makes it infinitely simpler!
14:27:13 <Philippa> darkangel: again, what is the type of 1?
14:27:17 <mm_freak_> darkangel: i know what you mean =)
14:27:30 <mm_freak_> darkangel: in any case, you probably want to use a real serialization library
14:27:43 <darkangel> Can be anything. Int, Integer ...
14:27:52 <wavewave> hi.
14:27:56 <Enigmagic> darkangel: it is possible with unsavory extensions like UndecidableInstances https://gist.github.com/8f5d94ab14b0674f2e71
14:27:57 <mekeor> hi, wavewave
14:28:03 <mm_freak_> for XML you'll want text serialization, and i'm sure there is some package on hackage to do it
14:28:07 <Philippa> darkangel: right. That's one reason you really, really don't want to use Show for serialisation
14:28:15 * wavewave waves mekeor
14:28:19 <mm_freak_> darkangel: one simple way is to use Aeson to serialize to JSON, then stuff that into the XML
14:28:20 <darkangel> Enigmagic: Already tryed ^)
14:28:26 <Philippa> (another is that it's not obliged to be at all fast)
14:28:44 <Enigmagic> darkangel: the example in there works
14:29:10 <wavewave> mm_freak_ : does your netwire support gtk2hs backend? if not, any plan?
14:29:28 <mm_freak_> wavewave: no and no, nothing immediate
14:29:49 <mm_freak_> wavewave: netwire is a pure FRP library…  it is mainly meant for library or large application programmers
14:30:00 <mm_freak_> for quick GUI creation have a look into reactive-banana
14:30:13 <MaybeJust> ion: how?
14:30:34 <MaybeJust> like what i implement it for, print?
14:30:35 <wavewave> mm_freak_ : is it difficult to implement a certain backend?
14:31:04 <mekeor> so, when i do "data Foo" (with -XEmptyDataDecls), which value can a "variable" of type "Foo" have?
14:31:24 <wavewave> mm_freak_ : i mean, as a user, can one implement backend without changing netwire source?
14:31:41 <mm_freak_> wavewave: once you understood how AFRP works it's reduced to a lot of handwork…  it's not difficult intellectually, but there is overhead involved
14:31:55 <mm_freak_> wavewave: yes, netwire is intended to be general-purpose
14:32:06 <mm_freak_> if you need to change the library, you're probably doing something wrong
14:32:11 <darkangel> In C++ I wrote one generic implementation and than some specialization if generic impl not satisfy me. But in haskell I need to define type class and than make dozen instances for types to serialize. I just don't want write all those instances :(
14:32:21 <wavewave> mm_freak_ : I see. sounds very good.
14:32:37 <mm_freak_> darkangel: i just gave you a solution
14:32:38 <wavewave> mm_freak_ : I am thinking of making a script language using FRP.
14:33:24 <mm_freak_> wavewave: netwire is great as an EDSL, if you don't mind building the bridge between netwire and the GUI framework =)
14:33:42 <mm_freak_> wavewave: choose a GUI library that exposes an event polling interface though
14:33:52 <darkangel> mm_freak_: I don't think that Types -> JSON -> XML is a good solution for Types -> XML problem
14:33:52 <mm_freak_> like SDL's pollEvent/waitEvent
14:33:57 <monochrom> type class allows default implementations. that's generic implementation for you.
14:34:23 <wavewave> mm_freak_ : yeah. gtk2hs also has something similar.
14:35:11 <wavewave> mm_freak_ : in fact, in my case, even don't need it. because the script program will run on the full program which does the event processing.
14:36:11 <mm_freak_> darkangel: note that instances can have contexts:  instance (A x) => B x
14:36:17 <mm_freak_> let A be Serializable
14:36:34 <mm_freak_> uhm
14:36:43 <mm_freak_> instance (A x) => B (F x)
14:36:51 <mm_freak_> makes more sense
14:37:47 <MaybeJust> anyone can post a link to where the IO and Maybe monads are implemented?
14:38:39 <Enigmagic> MaybeJust: http://hackage.haskell.org/packages/archive/base/4.3.1.0/doc/html/src/Data-Maybe.html#Maybe
14:38:41 <wavewave> mm_freak_ : thanks for explanation. ;-)
14:38:55 <darkangel> thanx to All.
14:39:44 <MaybeJust> be defining a monad  do i autoget fmap then?
14:40:11 <Peaker> MaybeJust: sort of.. you get "liftM" which should be equivalent
14:40:24 <Peaker> Unfortunately Monad and Applicative/Functor are not related as they should be
14:40:37 <Peaker> I wish they bit the bullet and broke everyone and related them
14:40:41 <Enigmagic> MaybeJust: Monad IO is defined here https://github.com/ghc/packages-base/blob/master/GHC/Base.lhs#L617
14:43:46 <Peaker> MaybeJust: IO's monad instance is an internal compiler implementation detail
14:43:51 <heoa> which haskel compiler would you use in W -box? Ghc?
14:44:30 <Peaker> mm_freak_: writing a wrapper around a callback-library like GLFW-b to convert it to polling is easy enough
14:45:47 <Kuba> I'd like to use the same benchamarking data ghci provides with :set +s in my Haskell code, can I do it?
14:46:10 <Enigmagic> Kuba: compile with -rtsopts and run with +RTS -sstderr -RTS
14:46:34 <Kuba> and how would I get stats in my code?
14:47:11 <shergill> hmm this isn't exactly related, but i was wondering if someone here can help me understand the difference between 'narrowing' and 'sld resolution'
14:47:51 <Enigmagic> Kuba: this will get you part of it http://blog.ezyang.com/2011/07/in-program-gc-stats-for-ghc/
14:48:02 <ClaudiusMaximus> http://holumbus.fh-wedel.de/hayoo/hayoo.html?query=gc%20module%3AGHC
14:48:16 <Kuba> I'd like a function f1 that takes another function f2, runs it, returns output of f2, and seconds it took it to run, and bytes of memory used
14:48:27 <maurer> Anyone know how to import agda from haskell?
14:48:46 <Kuba> Enigmagic, ClaudiusMaximus: thx guys, will check it
14:49:33 <Enigmagic> Kuba: it won't be terrible accurate though aside from simple examples
14:51:40 <Kuba> I need it only for my report, to show that my prediction about asymptotic growth of given function implementations is correct ;)
14:52:16 <Enigmagic> Kuba: ok, good luck :)
14:53:16 <mm_freak_> Peaker: easy, but arduous
14:54:34 <mm_freak_> repetetive handwork can be difficult for some people
14:54:48 <mekeor> where can i find the naming conventions for constructors?  there're not on http://www.haskell.org/haskellwiki/Constructor …
14:59:28 <Kuba> ClaudiusMaximus: erm, should this GHC.Stats be bundled with my ghci?
14:59:38 <Kuba> ghc*
15:00:14 <ClaudiusMaximus> you have to unhide the package i think, and it might be (relatively) new
15:00:59 <Enigmagic> Kuba: it's in 7.4
15:01:13 <Peaker> mm_freak_: there aren't that many event types to convert... about an hour or two of work
15:01:14 <Enigmagic> no unhiding required
15:01:24 <Kuba> Enigmagic: fedora has 7.0.4 ;d
15:01:25 <Peaker> mm_freak_: at least with the low-level frameworks
15:01:36 <Kuba> okay, time to compile...
15:06:32 <jeff_s_> I'm looking at Control.Monad, and I almost see the function I want. I think I want mfilterM MonadPlus m => (a -> m Bool) -> m a -> m a. Is that somewhere, or do I need to write it?
15:07:24 <Kuba> o, there are some prebuilt packages, how nice :)
15:07:27 <jeff_s_> Maybe it won't be too hard.
15:08:11 <MaybeJust> can i write: add3 = do
15:08:11 <MaybeJust>   a <- Only 5
15:08:11 <MaybeJust>   return $ a + 3
15:08:11 <MaybeJust> on a sinlgr row?
15:08:27 <aavogt> jeff_s_: for your  (m Bool) is there a difference between  (return False) and  mzero?
15:08:35 <srhb> do { something; something else; the last thing }
15:09:04 <MaybeJust> > let add3 = liftM (+3) in add3 (Just 5)
15:09:05 <lambdabot>   Just 8
15:09:06 <srhb> or add3 = Only 5 >>= \a -> return (a + 3)
15:09:23 <jeff_s_> aavogt - yes, I think so. My test function does something that depends on IO.
15:09:44 <srhb> or even add3 = Only 5 >>= return . (+3)
15:10:18 <aavogt> jeff_s_: what I mean is for an arbitrary MonadPlus, those two things are different but I'm not really seeing why there's a need to distinguish them for a filter kind of thing
15:11:13 <jeff_s_> Hm, it turns out the type I'm looking for is a bit more complicated than I realized.
15:11:14 <aavogt> in which case you can just have              mfilterM :: MonadPlus m => (a -> m ()) -> m a -> m a; mfilterM f x = (f =<< x) >> x
15:11:50 <zzo38> I was thinking of a new idea, new kind of programming language (called Ibtlfmm) some things like Haskell and other programming languages, I will write some ideas here. One is the classes are now different; a class can be: a tag, a class method, a mathematical law, a type family, or a collection of classes. And you can add defaulting superclasses afterward, private instances, etc
15:11:58 <zzo38> What is your opinions/ideas?
15:12:47 <srhb> No idea. If it was more concrete, perhaps.
15:14:35 <Cale> The name needs work :P
15:15:05 <Cale> Also, how do you intend to statically verify the mathematical laws?
15:15:08 <Enigmagic> needs more consonants
15:15:25 <zzo38> A program shall be arranged in a similar way to a WEB program; there can be many levels of meta-programming usable; and it also includes some ideas from Prolog, C, INTERCAL, and Magic: the Gathering.
15:15:37 <Cale> lol
15:15:44 <srhb> It sounds scary.
15:15:58 <Enigmagic> zzo38: please make it look like apl
15:15:58 <Cale> troll confirmed
15:16:19 <copumpkin> Cale: he actually isn't
15:16:22 <zzo38> Cale: OK, what name do you suggest? In some cases you might be unable to verify mathematical laws statically but they can still be used for optimization even if you cannot verify them always
15:16:29 <srhb> "some cases" ?
15:16:39 <srhb> You're heading straight for a nobel prize.
15:16:46 <zzo38> Probably most cases, actually.
15:16:57 <Enigmagic> srhb: it's the first compiler of its kind
15:16:57 <copumpkin> zzo38: under what cases _could_ they be verified statically?
15:17:06 <copumpkin> zzo38: have you looked at proof systems and dependent types?
15:17:07 <byorgey> copumpkin: troll is not a binary attribute. =)
15:17:12 <zzo38> copumpkin: Perhaps if a proof is supplied
15:17:14 <srhb> Enigmagic: Maybe we will call it Amazing
15:17:24 <copumpkin> zzo38: what would constitute a proof?
15:17:28 <jeff_s_> The function I'm looking for has a type like :: (Foldable f, Monoid m) => (a -> IO Bool) -> f a -> IO (m a)
15:17:46 <MaybeJust> ++..----..-.
15:17:51 <Enigmagic> copumpkin: types that implement the MathematicallyProven tag
15:17:57 <jeff_s_> er, not IO (m a), just m
15:18:00 <jeff_s_> IO m
15:18:16 <copumpkin> where's the m come from?
15:18:17 <zzo38> copumpkin: I don't know yet. But it was not my intention that you could always verify the laws; but even then they could be used for optimization and disambiguation even if not verified by computer.
15:18:43 <jeff_s_> So basically I'm looking for filterM that is generalized over the type of collection.
15:18:45 <srhb> zzo38: So more like when you make a type you promise the compiler that certain identities hold
15:18:52 <rwbarton> it's hard to tell whether zzo38 is a troll or just an alien
15:18:56 <zzo38> srhb: Yes, like that.
15:19:06 <aavogt> ghc has rewrite rules: these are the same thing as laws used for optimization purposes?
15:19:22 <copumpkin> the thing about laws is that they're typically not directional
15:19:39 <copumpkin> so you'd need to have a stronger language for talking about what's more efficient and what isn't
15:19:56 <zzo38> aavogt: Sort of. Similar to my idea, but mine is a bit more general and some things; for example, GHC seems to have no way to express reflexive laws
15:19:56 <srhb> copumpkin: Enter Magic
15:20:28 <MaybeJust> what is the (<-) operator? it lifts a value out of a monad right
15:20:29 <monochrom> well, I am glad the focus has moved from "make haskell do this" to "make a new language do this"
15:20:37 <zzo38> And there could still be rules for optimization to specify if things are equivalent, certain things preferred from others
15:20:49 <srhb> zzo38: How about writing a type with some of these identities for optimization and we'll sort out how awesome it is then.
15:20:57 <mauke> MaybeJust: do { v <- X; ... } is syntactic sugar for X >>= \v -> do { ... }
15:21:31 <monochrom> and so, I am not glad with all these other people's attempt at "but GHC can do some of these"
15:22:13 <byorgey> @type \p -> fmap (map snd . filter fst . Data.Foldable.toList) . Data.Traversable.traverse (p &&& id)
15:22:14 <lambdabot> forall b (t :: * -> *) c. (Data.Traversable.Traversable t, Monoid c) => ((Bool, b) -> c) -> t (Bool, b) -> (c, [b])
15:22:37 <byorgey> oh, not quite
15:22:40 <BMeph> jeff_s_: You have no way to correlate any ties between the Bool and the 'm', otherwise, it looks like something that should involve Any/All, traverse and foldMap.
15:23:16 <jeff_s_> BMeph - good point
15:23:36 <Peaker> zzo38: what interesting ideas are you taking from INTERCAL?
15:24:08 <byorgey> @type \p -> fmap (map fst . filter snd . Data.Foldable.toList) . Data.Traversable.traverse (\a -> fmap ((,) a) (p a))
15:24:09 <lambdabot> forall (t :: * -> *) (f :: * -> *) a. (Data.Traversable.Traversable t, Applicative f) => (a -> f Bool) -> t a -> f [a]
15:24:12 <zzo38> My idea for the kinds are currently: the kind * for ordinary inhabited types, the kind # for raw low-level types (can be defined using LLVM or whatever), the kind + for natural numbers, the kind & for constraints, the kind @ for program modules, the kind ? which is not known * or # yet, and -> as functions between kinds.
15:24:23 <zzo38> User-defined kinds are also possible and are given alphanumeric names.
15:24:24 <byorgey> jeff_s_: ^^^ that's a start, at least
15:24:24 <MaybeJust> how can i apply several functions to a monadic value and then return it?
15:24:38 <MaybeJust> like (+5) then (*7) but not at the same time
15:25:04 <mauke> liftM twice
15:25:08 <jeff_s_> byorgey - thanks I'll see what I can do with it. Applicative isnt' somethign I've gotten to spend much time on.
15:25:45 <byorgey> jeff_s_: oh, don't worry about the Applicative part for now.  The Applicative constraint there is on f, which in your case is IO
15:25:52 <reltuk> anyone familiar with oleg's IterReg.hs?
15:25:55 <jeff_s_> I'm just trying to do something like filterM, but abstracted over the collection type. So rather than a list, I could supply and IntMap, or whatever.
15:26:21 <jeff_s_> and also the test returns IO Bool rather than just Bool.
15:26:25 <zzo38> Peaker: Some of the ideas relating to backtracking, multithreading, and object oriented stuff, but they would not be exactly like INTERCAL only with more like INTERCAL than other programming languages. Also, something like the optimizer language in C-INTERCAL
15:26:39 <Peaker> zzo38: you do realize INTERCAL was a parody?
15:26:43 <zzo38> Peaker: Yes.
15:27:24 <Enigmagic> zzo38 is also a parody
15:27:31 <zzo38> But I have occasionally wanted to sometimes used various features of INTERCAL when programming in other programming languages (including but not limited to the interleave and select operators)
15:28:05 <Peaker> MaybeJust: liftM yourFunction monadicValue       will apply yourFunction to the monadicValue.   yourFunction can of course be a composition of multiple functions:
15:28:12 <Peaker> i.e: yourFunction = (*7) . (+5)
15:28:22 <abdelhalim> I'm using GHC APIs to compile/load some haskell files in my application, and I have an issue with the API "findModule". It expects a module name as input, but what if I don't know the module name beforehand ? Is there a way to get the module name from the Target that I just loaded ?
15:29:01 <MaybeJust> whats an efficient rep of a graph? adj matrix is good i guess but spacewise terribleunless it is edfined as a map?
15:30:10 <byorgey> abdelhalim: you might also try asking in #ghc
15:30:29 <zzo38> I intend some features of Haskell are omitted, such as: if/else expressions, layout, do-notation, case-of blocks (you can use \{ ... } instead), unicode names (if someone wants it, it could be implemented as internally converting to something like Punycode)
15:30:36 <byorgey> MaybeJust: it depends what sort of graph it is, and what you want to do with it.
15:30:53 <abdelhalim> byorgey: I'll try there, thanks
15:31:22 <zzo38> Although possibly the macro system can be extensive enough that you could even implement do-notation and if/else and case-of and whatever, by using macros.
15:32:05 <MaybeJust> byorgey: 1.represent some sort of information about people and their relations 2. nodes in a network, network flow optimization
15:32:34 <Peaker> zzo38: It sounds like this would be more interesting if you had a concrete implementation or at least concrete examples to look at, showing any sort of improvement
15:33:10 <zzo38> Peaker: Yes, you are probably correct. I could try to write specification document including examples
15:33:52 <Peaker> zzo38: I suspect people in #haskell do not generally find lack of do notation appealing :)
15:35:24 <mekeor> Why is (+) not of type "(Num a, Num b, Num c) => a -> b -> c" ?
15:35:37 <MaybeJust> cant you chain something together like main = Only 12 >>= (+5) >>= (*7) >>= return
15:36:01 <mekeor> Only ?
15:36:05 <zzo38> Peaker: I agree you are correct about that; however, I do not like do-notation; and I intend various kinds of macros able to be used, so possibly do-notation can be implemented inside of Ibtlfmm (or whatever it is called) if some people want to, instead of being build-in
15:36:20 <Enigmagic> mekeor: what would the type of "1 + 2 + (3 ::Int)" be?
15:36:23 <zzo38> MaybeJust: For one thing, >>= is not like that; >>= is esentially a combination of fmap and join
15:36:46 <mekeor> Enigmagic: idk, Int ?
15:36:56 <cmccann> zzo38, I still don't see why you're forbidding unicode. everything else seems designed to make the code completely unreadable, so why not make it hard to write as well by using weird code points? :P
15:37:04 <Enigmagic> mekeor: it wouldn't compile
15:37:09 <MaybeJust> can i compile and run a haskell file at runtime
15:37:14 <byorgey> MaybeJust: well, I suggest using the 'fgl' library instead of writing your own graph implementation from scratch.
15:37:15 <mekeor> Enigmagic: (1 :: Integer) + (1.2 :: Float) == (2.2 :: Float)
15:37:26 <srhb> Enigmagic: Huh? Why not?
15:37:34 <tomodo> mekeor: you can't do that
15:37:35 <mekeor> thanks , srhb :)
15:37:44 <Peaker> MaybeJust: you can, but it is not as easy as with dynamic languages
15:37:52 <monochrom> I wouldn't know how to do ((1 :: Int) + (1.6 :: Double)) :: Int
15:37:59 <zzo38> cmccann: I am not trying to make it hard to anything... it is a side-effect... I intend it to be ASCII and if you want unicode you can convert them into something like Punycode by a compiler possibly
15:38:00 <mekeor> tomodo: yea i can't do because of the prelude. why can't the prelude do that?
15:38:12 <tomodo> mekeor: haskell can't do it
15:38:15 <Peaker> zzo38: why would you call a language Ibtlfmm?
15:38:17 <Enigmagic> srhb: there are not enough types to do inference
15:38:19 <mekeor> tomodo: WHY?
15:38:30 <tomodo> no need to shout
15:38:33 <srhb> Enigmagic: Sorry, I thought you were saying 1 + 2 + (3 :: Int) would not compile.
15:38:36 <zzo38> Peaker: Because I don't know the other name. I just put each letter of "Haskell" one ahead
15:38:47 <MaybeJust> Peaker: how?
15:38:59 <danr> it gets even messier if you have function space Num instances...
15:39:01 <Enigmagic> srhb: only if (+) was defined as "(+) :: a -> b -> c"
15:39:08 <byorgey> mekeor: note, (Num a, Num b, Num c) => a -> b -> c  means it must be able to work with *any* types the *caller* chooses.
15:39:17 <srhb> Enigmagic: Right. This is why I should read context. :-)
15:39:25 <byorgey> mekeor: for example I would be able to add a Float and a Complex and demand to get an Int as a result
15:39:26 <Peaker> MaybeJust: http://hackage.haskell.org/packages/archive/hint/0.3.3.4/doc/html/Language-Haskell-Interpreter.html http://www.haskell.org/haskellwiki/GHC/As_a_library
15:39:34 <byorgey> mekeor: how would that work?
15:39:40 <monochrom> anyway, I support (Num a) => a->a->a because I prefer everyone to make conversions explicit if they want to do (x::Int)+(y::Complex CReal)
15:40:08 <Peaker> lack of required explicit conversions is one of the more annoying sources of bugs we have in our C code
15:40:09 <Enigmagic> i would sorta prefer "a -> b -> c | a b -> c"
15:40:19 <rwbarton> or worse (x::CReal)+(y::Complex Int)
15:40:48 <mekeor> byorgey: oh, right…
15:41:13 <OscarZ> zzo38: is there going to be Ibtlfmm on sbjmt for web development?
15:41:34 <mekeor> byorgey: thanks for that good example, thanks (although the addition of real numbers and complex numbers is of course defined, i mean, in theory, but of course not in haskell…)
15:41:59 <byorgey> mekeor: no it isn't.
15:42:06 <mekeor> byorgey: really?
15:42:07 <zzo38> And my other idea, some way you can even write programs in other categories?
15:42:08 <byorgey> mekeor: there is just a standard injection from the reals into the complex
15:42:21 <zzo38> OscarZ: Not as far as I intend; someone else can make up such things if they want to.
15:42:29 <mekeor> byorgey: (real:+imag) + real' = (real+real':+imag)
15:43:00 <byorgey> mekeor: no one actually does that.
15:43:13 <mekeor> byorgey: because ℝ = { a+b*i | a, b ∈ ℝ;  i²=-1 }
15:43:21 <monochrom> you are really asking for implicit conversions. sure, a few implicit conversions seem standard and benign. you haven't seen enough evil cases.
15:43:24 <mekeor> oops
15:43:31 <mekeor> that's C, sorry
15:43:48 <mekeor> i meant  ℝ = { a+0*i | a ∈ ℝ;  i²=-1 }
15:44:06 <mekeor> so ℝ ⊂ C
15:44:14 <zzo38> The use of no-unicode also means you don't need to have the entire unicode tables to parse the program, since only ASCII will be used and everything else don't unless you have specified the ways of parsing and converting them to ASCII codes
15:44:15 <monochrom> at the end of the day, it comes down to impossibility to write a type that allows the standard and benign cases, and disallows the evil cases.
15:44:21 <srhb> > map (chr . subtract 1 . ord) "sbjmt"
15:44:23 <lambdabot>   "rails"
15:44:24 <byorgey> mekeor: right, that's the standard injection from R into C.
15:44:26 <mekeor> or, ℝ = { c ∈ C | imag(c) = 0 }
15:44:28 <srhb> Ah.. lol
15:45:04 <rwbarton> @zzo38
15:45:04 <lambdabot> Unknown command, try @list
15:45:11 <rwbarton> :(
15:45:15 <mekeor> byorgey: so realNumber + imagNumber *is* defined imo… why not?
15:45:43 <mekeor> byorgey: but anyway, you're right… my original idea was bad, yes.
15:46:02 <byorgey> mekeor: it depends what you mean by "defined".  My point is that how it is usually defined is "first implicitly convert the real number to a complex number, then add".
15:46:10 <zzo38> Also I intend, possibly the Maybe monad can be called successor monad instead, and the numeric type Word called Nat instead, and then Natural which is any natural number any large while Integer is any integer any large. And such thing as Nat8, Int8, Nat16, Int16, Nat32, Nat64, Nat128, and so on.
15:46:34 <srhb> x_x
15:47:11 <mekeor> byorgey: okay. that's right…
15:47:24 <byorgey> zzo38: less talking, more code please =)
15:47:31 <zzo38> I don't know, if you like this rename, or not
15:47:39 <monochrom> the fire of enthusiasm in haskell as a CAS must be watered
15:48:02 <zzo38> OK I can try to write an example code but it might not work in the final version due to changes it is currently pre-draft
15:48:38 <srhb> That is acceptable, zzo38. Go fort!
15:48:38 <byorgey> zzo38: I don't mean examples, I mean an implementation.
15:48:39 <srhb> h
15:48:52 <monochrom> Mathematica and Perl are where you can expect to do "4"+5+6i
15:48:53 <srhb> Heck I'd settle for examples.
15:49:33 <zzo38> byorgey: How can I write an implementation if I have no specification document yet and even if it was, if it would be draft and not yet fixed enough?
15:50:04 <byorgey> zzo38: people write prototype implementations without a specification document all the time.
15:50:18 <byorgey> in fact it's a great way to figure out what you really want to put in the specification document.
15:50:35 <monochrom> be careful what you ask for
15:51:31 <mekeor> Is there a good summary of encoding stuff around?  i mean about the relationship of String and Unicode (and Text (and Bytestring)) etc...
15:51:39 <MaybeJust> what do i call to compile with ghc in emacs and then to run it?
15:52:05 <mekeor> MaybeJust: i just know C-c C-l to interpret…
15:54:12 <MaybeJust> ok i managed to compile with M-x
15:54:20 <MaybeJust> but how do tun a program in emacs?
15:54:48 <monochrom> Char is Unicode scalar. Text and [Char] achieve the same thing (sequence of Unicode scalars), Text uses less memory. ByteString is a sequence of bytes, store whatever you want in the bytes.
15:57:03 <hash`> Hi. Is there any way to mark a non-exhaustive pattern match such that it doesn't throw a warning?
15:57:30 <monochrom> add one last pattern to make it exhaustive
15:57:46 <hash`> Heh
15:58:02 <monochrom> turn off warnings altogether
15:58:18 <hash`> In general I like warnings.
15:58:21 <Sgeo> You could have the last pattern result in error "Whatever"
15:58:26 <monochrom> there is no fine-grained way
15:58:31 <Sgeo> (The last pattern to make it exhaustive)
15:58:39 <hpaste> Kuba pasted “Microbenchmarking” at http://hpaste.org/64345
15:58:56 <Kuba> Enigmagic: this is what I came with ^
15:59:24 <hash`> Thanks. I'll mull over my options and pick the one that least makes me feel like I'm writing imperative code.
15:59:24 <Kuba> I have no experience with IO/Monads so excuse me code
16:00:03 <srhb> Does >> ever make sense outside of the IO Monad? I may just be lacking imagination here.
16:01:10 <monochrom> >> makes sense whenever m () makes sense
16:01:19 <Enigmagic> Kuba: that will only work for certain types (see the caveat on Control.Exception.evaluate)
16:01:27 <tromp__> > "foo" >> " yo!"
16:01:28 <lambdabot>   " yo! yo! yo!"
16:01:28 <monochrom> so, for example, put :: State s ()
16:01:40 <Enigmagic> Kuba: and the regular clock isn't very granular, so it will only be accurate on long running functions
16:01:42 <hpc> @src (>>)
16:01:42 <lambdabot> m >> k      = m >>= \_ -> k
16:02:01 <monochrom> err, put :: s -> State s ()
16:02:17 <Enigmagic> Kuba: you might take a look at criterion if you're interested in microbenchmarking
16:02:22 <Enigmagic> @hackage criterion
16:02:22 <lambdabot> http://hackage.haskell.org/package/criterion
16:02:30 <monochrom> @type guard
16:02:31 <lambdabot> forall (m :: * -> *). (MonadPlus m) => Bool -> m ()
16:02:36 <monochrom> also that one
16:02:38 <Kuba> Enigmagic: i need this function only for functions of the same type
16:02:46 <Kuba> Enigmagic: so it should be okay
16:03:03 <MaybeJust> i want to extract a graph from a file, so i guess i need a parser
16:03:11 <MaybeJust> or i dont i could just decode t simply?
16:03:32 <Enigmagic> Kuba: i mean that it only evaluates the top level thunk, so if you have more thunks stored within an ADT it will not evaluate them
16:03:33 <monochrom> decode = parse = decode
16:03:51 <Kuba> Enigmagic: hm...
16:04:01 <monochrom> of course you're welcome to say "this parser is trivial"
16:04:38 <akosch> does anyone have example code using Network.HTTP.Conduit.Browser? I'm a bit confused...
16:09:57 <MaybeJust> I never download any software, it takes too long to read all those license agreements.
16:12:56 <Cale> MaybeJust: Most people just don't read them
16:13:36 <Cale> MaybeJust: and there are really only a few license agreements anyway
16:14:33 <Peaker> MaybeJust: that's quite ridiculous ;-)
16:15:23 <Peaker> MaybeJust: When you download software, you don't really have to worry about any licenses (only EULAs, in some jurisdictions). When you *redistribute* works/derivative works, that's when licenses matter..
16:15:51 <saml> can I instruct cabal to use all my cpu cores?
16:15:55 <saml> or ghc
16:16:02 <saml> compiling is too long
16:16:46 <dgpratt> hi Cale
16:17:02 <MaybeJust> i was joking ;)
16:17:33 <Cale> dgpratt: hello
16:17:42 <mekeor> hello
16:17:49 <mekeor> =)
16:18:08 <Peaker> saml: http://hackage.haskell.org/trac/ghc/ticket/910
16:18:23 <dgpratt> Cale: so...what do you know about zippers and differentiation? :)
16:19:13 <Cale> dgpratt: Some...
16:19:57 <Peaker> saml: maybe you could specify the build rules with http://gittup.org/tup/ and then use tup -j
16:20:39 <dgpratt> Cale: I was reading this: http://en.wikibooks.org/wiki/Haskell/Zippers#Zippers_via_Differentiation
16:20:54 <Cale> yeah, I was thinking of linking to that
16:20:58 <dgpratt> and not getting it
16:21:04 <Cale> Also... some papers by Conor McBride
16:21:25 <Cale> http://strictlypositive.org/diff.pdf
16:21:57 <Cale> I doubt that's actually any easier to understand...
16:22:09 <Cale> but it contains a picture which may help
16:23:13 <dgpratt> the definition at the beginning of that section I linked, "μF..."; I don't really understand what is being expressed there; is there a simplified explanation?
16:23:14 <Cale> dgpratt: When you differentiate a functor, you get a functor for structures which have a single "hole" somewhere in them where they would have had a value of the type parameter in the original sort of structure.
16:23:36 <Cale> Oh, μ is the fixed point for types
16:23:42 <tomodo> dgpratt: it's like fix f but for data ionstead of function
16:23:54 <dgpratt> Cale: I *think* I sort of understand that, it's the math that's the problem
16:24:12 <Cale> So, they're talking about how to differentiate recursive types
16:24:23 <Cale> You can do it pretty much by "implicit differentiation"
16:24:31 <dgpratt> tomodo: I shall ponder that
16:24:58 <Cale> So for example, suppose you know that List x = 1 + x * List x
16:25:21 <dgpratt> Cale: ok
16:25:31 <Cale> Then List' x = 0 + 1 * List x + x * List' x
16:25:51 <Cale> and we can cancel that 0 :)
16:26:00 <dgpratt> Cale: right
16:26:40 <Cale> and this says that a list of xs with a hole in it is either the hole together with a plain list, or it's an element together with a list with a hole in it :)
16:27:19 <dgpratt> Cale: ok, that's making some sense
16:29:07 <saml> Peaker, thanks.. so it's not mainstream yet.
16:29:26 <dgpratt> is there a term for the representation of a type in that form, e.g. "List x = 1 + x * List x"?
16:29:31 <Peaker> saml: nope, to be honest ghc compilation times only slightly bother me when I'm "cabal install"ing afresh
16:30:01 <saml> ah, the bottleneck is cabal itself? I was just wondering
16:30:09 <dgpratt> the scheme makes sense to me based on other stuff I've seen, but I have no formal knowledge of that
16:30:36 <byorgey> dgpratt: often referred to as an "algebraic" representation
16:31:02 <dgpratt> byorgey: I see, thanks
16:31:19 <monochrom> writing like "1 + x*y" is why algebraic data types are called algebraic
16:31:51 <dgpratt> monochrom: ah
16:35:45 <mekeor> > π -- nice, huh?
16:35:46 <lambdabot>   3.141592653589793
16:36:06 <sipa> Seems inaccurate.
16:36:07 <dgpratt> so does the definition of "μF" (in what I linked) represent something like "newtype Fix f=Fix (f (Fix f))" (I found elsewhere)?
16:36:14 <Cale> yeah
16:36:29 <Cale> That's pretty much exactly what it means
16:36:36 <dgpratt> Cale: oh, cool, thanks
16:37:12 <dgpratt> if I can translate math to Haskell, I have a chance of understanding it, otherwise not so much :)
16:40:46 <hpaste> Kuba pasted “Installing criterion” at http://hpaste.org/64347
16:40:49 <Axman6> > π:: CReal
16:40:51 <lambdabot>   3.1415926535897932384626433832795028841972
16:41:01 <Kuba> I'm very unlucky
16:41:15 <Kuba> Those I my first steps with cabal and I fail miserably
16:41:38 <Peaker> Kuba: hah, everybody's first steps with cabal fail miserably :)
16:42:38 <nand`> http://omploader.org/vY3Zucw/1330215485703.png hehe
16:42:53 <Kuba> Peaker: any advice on that specific problem I pasted?
16:42:55 <Kuba> ;d
16:43:09 <Kuba> nand`: :D
16:43:11 <MaybeJust> if you decide how a system is invariant by one change couldnt the dssme change applied again make it invariant?
16:43:19 <MaybeJust> i guess not
16:43:31 <adnauseam> musical interval for you guys https://www.youtube.com/watch?v=4jheVlgWrwI
16:43:47 <adnauseam> gets really awesome 1:00 in
16:43:51 <nand`> :t π
16:43:52 <lambdabot> <no location info>: not an expression: `'
16:44:10 <nand`> @type π
16:44:11 <lambdabot> <no location info>: not an expression: `'
16:44:15 <nand`> :(
16:44:37 <adnauseam> :t pi
16:44:38 <lambdabot> forall a. (Floating a) => a
16:45:40 <adnauseam> :t (π) :: (Floating a) => a ; π x = 3.1415926535897932384626433832795028841972
16:45:41 <lambdabot> parse error (possibly incorrect indentation)
16:45:56 <adnauseam> would that even work ? :o
16:46:03 <nand`> adnauseam: no
16:46:12 <adnauseam> :{
16:46:23 <nand`> would be π = ...
16:46:27 <adnauseam> o
16:46:28 <nand`> not π x = ...
16:46:34 <adnauseam> :t (π) :: (Floating a) => a ; π = 3.1415926535897932384626433832795028841972
16:46:35 <lambdabot> parse error (possibly incorrect indentation)
16:46:54 <adnauseam> > /q lambdabot
16:46:55 <lambdabot>   <no location info>: parse error on input `/'
16:46:57 <adnauseam> er sorry
16:47:00 <nand`> :t let  (π) :: (Floating a) => a ; π = 3.1415926535897932384626433832795028841972 in π
16:47:01 <lambdabot> parse error (possibly incorrect indentation)
16:47:10 <adnauseam> might need >
16:47:16 <adnauseam> > (π) :: (Floating a) => a ; π = 3.1415926535897932384626433832795028841972
16:47:16 <lambdabot>   <no location info>: parse error on input `;'
16:47:28 <adnauseam> ormaybe the ; is just wrong - a let would be better ?
16:47:43 <adnauseam> > let π = 3.1415926535897932384626433832795028841972let
16:47:43 <lambdabot>   <no location info>: parse error on input `let'
16:47:54 <otters> back
16:48:52 <nand`> adnauseam: It's more likely he doesn't like the π
16:49:05 <adnauseam> ha!
16:49:07 <nand`> @type let pi :: (Floating a) => a; pi = 3.14159 in pi
16:49:08 <lambdabot> forall a. (Floating a) => a
16:49:09 <adnauseam> let π = 3.1415926535897932384626433832795028841972
16:49:13 <adnauseam> > π
16:49:15 <lambdabot>   3.141592653589793
16:49:21 <adnauseam> =}
16:49:37 <adnauseam> haskell <3
16:49:58 <nand`> I'm not sure why > π works when something like “let π = 3.14 in π” doesn't; or even @type π
16:50:07 <nand`> Maybe it's a hard coded alias to pi or something
16:50:17 <nand`> then again, that would work for let as well
16:50:20 <nand`> strange
16:50:53 <adnauseam> @type let π :: (RealFloating a) => a; π = 3.1415926535897932384626433832795028841972 in π
16:50:54 <lambdabot> <no location info>: not an expression: `let'
16:51:16 <adnauseam> interesting
16:51:36 <nand`> adnauseam: you're probably thinking of RealFloat not RealFloating
16:51:42 <nand`> unless I'm mistaken
16:51:44 <adnauseam> oh yeah - ;p
16:51:58 <adnauseam> it refused to parse let though - hrm
16:52:07 <adnauseam> didn't even get to bitch about the type
16:52:33 <adnauseam> @type π
16:52:34 <lambdabot> <no location info>: not an expression: `'
16:52:41 <adnauseam> :t π
16:52:42 <lambdabot> <no location info>: not an expression: `'
16:52:53 <adnauseam> let π = 3.1415926535897932384626433832795028841972
16:52:56 <adnauseam> :t π
16:52:57 <lambdabot> <no location info>: not an expression: `'
16:53:19 <adnauseam> alright - enough buggary from me about this ; onto doing more reading
16:53:27 <cbp`> what's going on o.o
16:53:49 <adnauseam> we were trying to define π and ran into a few peculiarities
16:54:00 <Peaker> Kuba: hmm.. what ghc are you using?
16:54:07 <adnauseam> let a = 5
16:54:11 <adnauseam> > a
16:54:12 <lambdabot>   a
16:54:14 <joyfulgirl> adnauseam: That's easy. Pi = 3, for large values of 3 or small values of pi.
16:54:30 <adnauseam> we were trying to use the symbol - but haskell didn't like it
16:54:41 <adnauseam> π
16:54:57 <adnauseam> let π = 4
16:55:00 <adnauseam> > π
16:55:02 <lambdabot>   3.141592653589793
16:55:21 <joyfulgirl> works I can define pi here
16:55:30 <joyfulgirl> π, rather
16:55:47 <adnauseam> @type let π = 3.141592653589793
16:55:48 <lambdabot> <no location info>: not an expression: `let'
16:56:19 <adnauseam> then it must an encoding issue
16:56:23 <Kuba> Peaker: $ ghc --version \ The Glorious Glasgow Haskell Compilation System, version 7.0.4
16:56:41 <Kuba> Peaker: fedora package
16:57:29 <ClaudiusMaximus> > "ππ"
16:57:30 <lambdabot>   "\960\960"
16:57:45 <Peaker> Kuba: ghc-pkg list template-haskell
16:58:23 <Peaker> Kuba: You're supposed to only have template-haskell 2.5.0.0.  In your "cabal install" command, try to add:   --constraint "template-haskell == 2.5.0.0"
16:58:54 <hpaste> Kuba pasted “ghc-pkg list template-haskell” at http://hpaste.org/64348
16:59:33 <Kuba> Peaker: does it make sense ^? ;p
16:59:58 <Peaker> Kuba: yes. Also do "ghc-pkg check", and then, for each listed package, do "ghc-pkg unregister"
17:00:11 <Peaker> Kuba: and try your install command with the --constraint on TH
17:02:21 <hpaste> Kuba pasted “ghc-pkg check/unregister” at http://hpaste.org/64349
17:02:33 <Kuba> more fails...
17:03:42 <Kuba> Peaker: I'd rather not mangle with OS/distribution files
17:04:20 <Kuba> Peaker: cabal can run from user's home directory, right?
17:05:32 <MaybeJust> glib-0.12.2 failed during the configure step. The exception was:
17:05:33 <MaybeJust> ExitFailure 1
17:05:45 <Peaker> Kuba: that's the default
17:06:23 <Peaker> Kuba: hmm.. somehow your "containers-0.4.." disappeared
17:06:36 <Peaker> Kuba: you might want to reinstall your distro packages, or just install GHC/et-al manually
17:06:50 <Peaker> Kuba: ghc-pkg list containers
17:07:16 <Kuba> /usr/lib/ghc-7.0.4/package.conf.d
17:07:16 <Kuba> /home/jakub/.ghc/i386-linux-7.0.4/package.conf.d
17:07:16 <Kuba>    containers-0.4.2.1
17:09:49 <Peaker> Kuba: somehow, your global containers-0.4.0.0 disappeared, and instead you have your home-dir install of containers-0.4.2.1. Any idea how it happened?
17:11:08 <Peaker> Kuba: try to reinstall ghc/etc, to reach a valid state where "ghc-pkg check" is clean.  Then when you install from hackage, you have to make sure it doesn't reinstall packages that are already installed globally. For example, you have to manually tell it that you don't want template-haskell>2.5.0.0, for some reason it does not know that template-haskell>2.5.0.0 is not suitable for ghc-7.0.*
17:12:23 <MaybeJust> how do install gtk? it doewsnt work
17:12:28 <Peaker> Kuba: sometimes, you see cabal-install installing a package you have globally, with the same version, for no apparent reason! (For example, reinstalling template-haskell-2.5.0.0). The reason for this is that some package is probably demanding an older/newer version of a dependency of the package being reinstalled. It's being reinstalled to be relinked with the other version of the depenedency. In that case, a "-v" flag will show you wh
17:12:28 <Peaker> at dependency it is, and a "--constraint" on the dependency will expose the culprit which is forcing the different version in
17:15:37 <Kuba> Peaker: thanks for the help
17:15:55 <Kuba> Peaker: I'm pretty sleepy now, so I'll finish it tomorrow morning
17:16:14 <Peaker> The newest cabal-install from darcs HEAD avoids the reinstall issue more nicely
17:16:15 <Kuba> Peaker: but indeed, my containers are missing
17:17:38 <Kuba> i.e. I have /usr/lib/ghc-7.0.4/containers-0.4.0.0/ but its missing in package.conf.d
17:17:40 <MaybeJust> is gtk not updated anymore?
17:18:44 <Peaker> Kuba: you seem to have run "ghc-pkg unregister" on it?
17:18:57 <Kuba> no
17:19:09 <Kuba> I've run it only on template-...
17:22:05 <Kuba> Peaker: + how would on earth ghc-pkg touch my system files if I run all my commands as user?! ;d
17:22:54 <Kuba> Peaker: maybe it's Fedora's bug
17:23:09 <Kuba> Peaker: anyways, thx, see you tomorrow
17:33:46 <cbm80> can i just compile & install the latest cabal-install from darcs, or will my current installation be hosed?
17:37:32 <cbm80> scratch that, i alread have the latest version
17:38:17 <covi> Hi guys. Why I can't 'sudo apt-get install haskell-platform' on my Ubuntu? The system is 10.04LTS.
17:38:20 <MaybeJust> what GUI do you recommend?
17:40:24 <HugoDaniel> covi: try to install it from source
17:40:46 <covi> HugoDaniel: You mean download the source and build it myself?
17:41:13 <HugoDaniel> yes
17:41:21 <HugoDaniel> you will need ghc in the system though
17:41:25 <sipa> covi: WHat error do you get?
17:41:36 <sipa> Or why does installing haskell-platofrm fail?
17:42:04 <geekosaur> I don't think it was packaged for lucid.  there should be a ppa somewhere though
17:42:05 <covi> sipa: It says 'Couldn't find package haskell-platform'
17:42:40 <sipa> covi: So it just doesn't exist for your distribution...
17:42:48 <covi> geekosaur: what is a ppa? HugoDaniel recommends me to install from source
17:42:55 <sipa> s/exists form/including in/
17:44:26 <geekosaur> covi: https://launchpad.net/ubuntu/+ppas
17:45:09 <geekosaur> it would be possible to install from source, but if someone's already done it for you and published a ppa, why bother?
17:45:34 <geekosaur> https://launchpad.net/~justinbogner/+archive/haskell-platform
17:47:16 <covi> geekosaur: ah I got in that page. What should I do next?
17:47:54 <geekosaur> um, read it?  "Adding this PPA to your system" is right there...
17:52:34 <lispy> cmccann: how goes the adventures in hackage?
17:54:11 <zzo38> OK, here is example you asked for (I am sorry I am late):  http://zzo38computer.cjb.net/Ibtlfmm/example1.ibtl
17:54:39 <cmccann> lispy, haven't had much time recently
17:55:06 <cmccann> also things are still kind of up in the air about how to proceed I guess
17:56:08 <cmccann> particularly since I'm apparently the only one who's really dissatisfied with the data persistence stuff
17:56:14 * hackagebot json-builder 0.2.4 - Data structure agnostic JSON serialization  http://hackage.haskell.org/package/json-builder-0.2.4 (LeonSmith)
17:56:29 <zzo38> cmccann: With what data persistence stuff?
17:57:14 <cmccann> zzo38, hackage2 stuff, don't really feel like going over it all again right now
18:01:37 <ion> zzo38: You seem to be making the same mistake Haskell did with including Int in Prelude.
18:01:55 <lispy> cmccann: brb
18:01:57 <zzo38> ion: OK, thanks for telling me that.
18:02:34 <zzo38> Can you please tell me, which different ways have been done to do extensible records in Haskell where fields can be added, and extensible datatypes to add new options, etc? Which ways works best to you, what kind of feature, etc?
18:03:46 <ion> Why regress to more syntactic noise? I mean the ; after every statement.
18:04:05 <zzo38> ion: So that you know where it ends.
18:04:31 <zzo38> (I don't like using line breaks and so on to determine where it ends)
18:05:45 <covi> Hi all... I added this ppa https://launchpad.net/~justinbogner/+archive/haskell-platform in my /etc/apt/sources.list, but after that, 'sudo apt-get install haskell-platform' failed either.
18:06:49 <Cale> covi: did you apt-get update?
18:08:44 <DrKP_> Hello. Is this the right place to ask for basic help with Haskell? I'm having trouble getting 'ghci' to start up on OS X Snow Leopard, because, it appears, "libiconv.dylib" cannot be loaded.
18:09:10 <bill```> do you have macports installed?
18:09:14 <covi> Cale: ahh.. but turns out the command returns a GPG error for the ppa.
18:09:19 <covi> What does that mean?
18:09:30 <ion> Did add-apt-repository fail to add the key?
18:09:30 <DrKP_> Me? Yes, I do.
18:09:45 <bill```> DrKP_: uninstall it and use homebrew instead and all those problems go away
18:09:53 <bill```> brew install ghc; brew install haskell-platform
18:10:07 <bill```> macports ships with broken libraries, notably openssl
18:10:10 <DrKP_> I'll give that a try.
18:10:35 <covi> ion: It said 'The following signatures couldn't be verified because the public key is not available'
18:12:04 <ion> Huh. Perhaps try running the add-apt-repository command again (but then check that there aren’t duplicate entries in the sources.list.d file).
18:12:46 <ion> I for one install GHC and cabal-install under my home directory and don’t bother with system packages for them.
18:12:48 <mikeplus64> http://quasimal.com/posts/2012-02-25-level-0.html <- a game I made
18:13:29 <mikeplus64> maybe someone can sift through it and tell me how horrible my coding style is :)
18:13:50 <aavogt> you don't need to exitWith ExitSuccess normally
18:14:11 <covi> ion: I didn't run add-apt-repository. I just manually added two lines in my /etc/apt/sources.list file.
18:14:30 <ion> Oh, that won’t work indeed.
18:14:31 <aavogt> so that'll cut out 2 loc, which is pretty good percentage-wise
18:14:46 <covi> ion: why?
18:14:58 <ion> You didn’t add the PGP key to the trusted key database.
18:15:03 <mikeplus64> aavogt: OK
18:15:33 <covi> ion: and 'add-apt-repository' will?
18:15:36 <ion> yes
18:17:11 <aavogt> mikeplus64: did {-# INLINE direction #-} buy you anything?
18:17:12 <ion> covi: Err. That PPA seems to have an ancient version of the platform.
18:17:20 <mikeplus64> aavogt: no idea!
18:17:28 <mikeplus64> it was probably inlined automatically
18:17:47 <mikeplus64> I'm not good at reading ghc core output so I wouldn't know if it did or didn't
18:18:29 <aavogt> if you define data Snake in the same way as data World you'll get a function like direction defined
18:18:32 <covi> ion: ...I'm trying to do add-apt-repository
18:18:55 <ion> covi: I’m not sure an unmaintained PPA is the best way to go.
18:19:15 <geekosaur> ion, is there a newer one for lucid?  launchpad seems to think tjats the recommended one
18:19:35 <aavogt> or maybe this is "better"   data Snake =Snake { alive :: Bool, direction :: Direction, __points :: Point }
18:19:48 <geekosaur> (and as far as out of date is concerned, I'm on debian, that ppa is the same version as what I can install...)
18:19:50 <aavogt> or make it  snakePoints :: Point
18:19:56 <covi> ion: any other options besides building it from source?
18:20:05 <ion> I’d just add ~/.ghc/bin:~/.cabal/bin to PATH and install the GHC binary and cabal-install to ~/.ghc and ~/.cabal respectively.
18:20:48 <mikeplus64> aavogt: hm, ok
18:21:11 <covi> well, i'm installing from the ppa right now
18:21:21 <covi> geekosaur: haha, since you're on debian :)
18:22:43 <ion> haskell-platform | 2011.4.0.0 | http://ftp.fi.debian.org/debian/ sid/main Sources
18:23:34 <geekosaur> sid
18:23:51 <geekosaur> oddly enough, not everyone runs unstable, or wants to
18:24:34 <ion> I’m not sure one has the privilege to say “that’s not old” if Debian stable has the same version. :-P
18:44:11 <NOTtheMessiah> probably an easy question, but is there an easy way to effectively do list indices in haskell without awkwardly combining takes? (like a[n]=-a[n]) I want to change the nth value in a list.
18:44:57 <ion> If you do such operations lists might not be the most appropriate data structure.
18:49:33 <geekosaur> lists are not arrays, they are singly linked lists.  if you want to do a lot of that kind of manipulation, you don't want lists
18:50:41 <davean> NOTtheMessiah: you might want something like Data.Sequence
18:51:01 <davean> or a vector or something, depending on what you are doing
18:52:28 <geekosaur> (indexing lists is annoying not because we like to be obtuse but because it's an expensive thing to do with a linked list, so we make it difficult, specifically as a warning that you should probably consider a different data type if you want to do it)
18:53:13 <hatds> I'm telling ghc to use a custom preproccesor, but I don't need it to run on every *.hs that is compiled and linked.  What's the best way to limit the invocations?
18:54:11 <NOTtheMessiah> davean, geekosaur, ion: ya, just toying around with the idea, porting some numpy (numerical python) code to haskell to get my feet wet. Seems like a lot of things work well enough with lists for it to be worth the cost when I access the element by index.
18:54:23 <DrKP_> Hello again. I've just removed MacPorts and installed haskell-platform from homebrew, but 'ghci' still yields this error: Loading package base ... <command line>: can't load .so/.DLL for: iconv (dlopen(libiconv.dylib, 9): image not found). Is it perhaps an issue with Xcode..?
18:54:59 <jeff_s_> byorgey - still here?
18:55:15 <byorgey> jeff_s_: hi
18:55:28 <jeff_s_> I made the function I was trying to make! Want to see it?
18:55:39 <byorgey> jeff_s_: sure!
18:56:12 <hpaste> “Jeff Shaw” pasted “mfilerM” at http://hpaste.org/64353
18:56:28 <jeff_s_> that should be: "mfilterM"
18:56:59 <byorgey> heh, I figured =)
18:57:19 <jeff_s_> The type signature is kind of messy.
18:59:43 <byorgey> jeff_s_: aha, I see
18:59:44 <NOTtheMessiah> found what I needed: (!!) :: [a] -> Int -> a
19:00:04 <geekosaur> oh sorrym I thought you had found that and were upset at the verbose usage
19:00:22 <geekosaur> (which follows from both lists being expensive for indexing and from immutability)
19:00:32 <ion> (!!) is evil for non-infinite lists.
19:01:02 <byorgey> jeff_s_: that's sort of an abuse of Alternative
19:01:18 <NOTtheMessiah> ya, I'm aware of the potential horrible things that could happen
19:01:43 <jeff_s_> byorgey - I don't understand why, but I'm not surprised, either. I don't have much experience with Alternative and Traversable and Applicative.
19:01:44 <byorgey> jeff_s_: there's not necessarily any relationship between the 'empty' for Alternative and the Monoid instance
19:02:03 <byorgey> jeff_s_: why not just replace 'empty' with 'mempty' (since you already have a Monoid constraint on (f a))
19:02:13 <byorgey> and then change 'Alternative' to 'Applicative'
19:02:53 <jeff_s_> byorgey - I think mempty confuses me, because then I expect to have to use something like pure to get a value into the monoid
19:03:06 <jeff_s_> or maybe pure is going to work...
19:03:31 <byorgey> you don't have to change the call to pure
19:03:52 <byorgey> "get a value into the monoid" -- not sure what you mean
19:04:25 <jeff_s_> Never mind - for some reason I thought mempty and pure x wouldn't work together.
19:05:47 <hpaste> “Jeff Shaw and byorgey” annotated “mfilerM” with “mfilerM (annotation)” at http://hpaste.org/64353#a64354
19:06:48 <byorgey> this is one of the very few times it seems it would be useful to have a class Pointed f where  pure :: a -> f a
19:06:58 <jeff_s_> I put your name in there since you suggested the changes; I hope that isn't bad etiquette.
19:07:07 <byorgey> because you're only using 'pure' and not the rest of the Applicative interface
19:07:16 <byorgey> jeff_s_: that's fine, I don't think it matters too much =)
19:09:41 <jeff_s_> So this is pretty cool - what I can have is a collection of values that self destruct after a given time period, and then I have a garbageCollect function that will go through a collection and remove all the self-destructed values (i.e. the MVar is empty).
19:18:10 <DanBurton> > splitAt 1000 []
19:18:10 <lambdabot>   ([],[])
19:18:24 <jeff_s_> > take 1000 []
19:18:25 <lambdabot>   []
19:20:10 <ion> @type Data.Traversable.forM
19:20:11 <lambdabot> forall (t :: * -> *) a (m :: * -> *) b. (Data.Traversable.Traversable t, Monad m) => t a -> (a -> m b) -> m (t b)
19:20:18 <ion> You can put the “c” before the lambda with forM.
19:22:28 <NOTtheMessiah> splitAt + (!!) is just what I needed
19:23:31 <BMeph> NOTtheMessiah: splitAt + pattern matching will likely do just as well, at least for your mentioned use case.
19:24:44 <KitB> How can I find out whether or not stdout is a pipe?
19:25:58 <BMeph> > let f n xs c = let (as,_:bs) = splitAt n xs in as++(c:bs) in f 4 "racepar" 'c'
19:26:00 <lambdabot>   "racecar"
19:32:40 <NOTtheMessiah> BMeph: pretty much what I came up with, although yours works, thanks
19:38:03 <Jafet> KitB: ask René Magritte?
19:38:41 <BMeph> > let f n xs c = let (as,_:bs) = splitAt n xs in as++(c:bs) in f 2 "rapecar" 'c' -- 'cause it's racier? ;)
19:38:43 <lambdabot>   "racecar"
19:39:11 <Cale> Ceci n'est pas un FIFO.
19:39:21 <BMeph> NOTtheMessiah: Thank you for letting us here work on our "Imperative Translation" skills. ;)
19:40:38 <drbean> BMeph: Oh, racier, in 2 ways.
19:40:53 <nyingen> un FIFO? une FIFO?
19:42:14 <Jafet> KitB: qu'est ce qu'un pipe?
19:46:44 <nyingen> @quote
19:46:44 <lambdabot> mattmight says: Coq is a tool for turning ordinary programs into POPL papers.
19:47:00 <MostAwesomeDude> Heh.
19:56:03 <shergill> heh
20:02:27 <adnauseam> > 26/3
20:02:27 <lambdabot>   8.666666666666666
20:02:53 <adnauseam> > /join #math
20:02:54 <lambdabot>   <no location info>: parse error on input `/'
20:02:56 <adnauseam> err
20:03:56 <nyingen> @quote
20:03:56 <lambdabot> wagle says: <wagle> in the end all entities die. don't bother living. <lambdabot> thread killed
20:04:02 <nyingen> @quote
20:04:03 <lambdabot> mental says: "real programming" as in web 2.0 applications?
20:04:16 <nyingen> no, "real programming" as in Ruby on Rails
20:04:48 <nyingen> maybe some JSP for the hardcore
20:06:03 <Jafet> No python or asp?
20:28:46 <drbean> Is there any short, easily-rememberable URL for Hayoo?
20:29:59 <donri> duckduckgo and use the !hayoo bang :)
20:40:48 <drbean> hayoo.com is a parking site.
20:42:08 <nyingen> @quote
20:42:09 <lambdabot> Vellos says: I combed my chinbeard back.
20:42:15 * geekosaur had thought haskell.org/hayoo worked, guess not
20:42:32 <geekosaur> oh, I'm thinking ghoogle.  hayoo is holumbus, right
20:42:35 <geekosaur> s/gh/h/
20:56:24 * hackagebot expiring-mvar 0.1 - Create values which expire after a period of time.  http://hackage.haskell.org/package/expiring-mvar-0.1 (JeffShaw)
21:02:11 <drbean> Hey, surfraw has a duckduckgo elvi.
21:02:56 <drbean> Someone should write hoogle and hayoo elvis for surfraw.
21:09:01 <ddarius> drbean has lost it and is just spouting word salad.
21:12:42 <drbean> http://en.wikipedia.org/wiki/Surfraw
21:18:02 <parcs`> authored by Julian Assange :P
21:30:10 <hash`> I have a function that takes a list of 5 items and produces a tuple of 5 items. It will always have 5 items in the input, guaranteed. I can't get rid of the silly non-exhaustive pattern match warning though.
21:30:44 <hash`> toTuple [_0, _1, _2, _3, _4] = (_0, _1, _2, _3, _4)
21:31:26 * hackagebot mysql-simple 0.2.2.4 - A mid-level MySQL client library.  http://hackage.haskell.org/package/mysql-simple-0.2.2.4 (BryanOSullivan)
21:32:32 <Sgeo> toTuple badList = error "Wrong number of items in list: " ++ show badList
21:32:44 <dainanaki> @pf deleteElems k sks = (run . hdel) (mkKey k) $ map mkKey sks
21:32:44 <lambdabot> Maybe you meant: bf pl
21:32:49 <Sgeo> But why do you have a list of 5 items guaranteed?
21:32:52 <dainanaki> @pointfree deleteElems k sks = (run . hdel) (mkKey k) $ map mkKey sks
21:32:52 <lambdabot> Unknown command, try @list
21:32:56 <dainanaki> @list
21:32:56 <lambdabot> http://code.haskell.org/lambdabot/COMMANDS
21:33:00 <cmccann> you want "pl"
21:33:04 <Sgeo> hash`, ?
21:33:10 <dainanaki> @pl deleteElems k sks = (run . hdel) (mkKey k) $ map mkKey sks
21:33:10 <hash`> Ha. Error.
21:33:10 <lambdabot> deleteElems = (. map mkKey) . run . hdel . mkKey
21:33:14 <cmccann> it stands for "pointless" btw
21:33:14 <hash`> That does it, thanks.
21:33:32 <dainanaki> cmcann, thanks, I had it in my head as pointfree.
21:33:36 <Sgeo> You're... welcome, but again I must question why you have lists of 5 items guaranteed floating around in your code.
21:33:37 <hash`> The guarantee is because I use a fromTuple function first that has 5 items :)
21:33:46 <Sgeo> Why do you have a fromTuple?
21:33:46 <cmccann> dainanaki, that's the name of the program you get if you install it from hackage
21:33:51 <Sgeo> Why not keep it as a tuple?
21:34:02 <hash`> So I can map and zip over it.
21:34:34 <Sgeo> > (+1) <$> (1,2,3,4,5)
21:34:35 <lambdabot>   No instance for (GHC.Base.Functor ((,,,,) t t1 t2 t3))
21:34:35 <lambdabot>    arising from a us...
21:34:37 <Sgeo> Darn
21:34:51 <cmccann> hash`, how about "newtype Five a = Five (a, a, a, a, a)"
21:35:01 <cmccann> and then give it a Functor and Applicative instance that does what you want
21:35:26 <cmccann> or grab a fixed-length list library off of hackage, there are piles of them I think
21:35:39 <Sgeo> hash`, you generally want to avoid runtime errors, and non-exhaustive pattern matches and error function are runtime error makers.
21:35:43 <hash`> That does look nice, Sgeo
21:36:00 <hash`> And yes, it was a newtype.
21:37:20 <hash`> I get the same error as lambdabot
21:46:45 <hash`> Anyway, thanks!
21:47:08 <mikeplus64> trying to get lambdabot installed, I run into this: Loading package readline-1.0.1.0 ... <command line>: can't load .so/.DLL for: ncurses (/usr/lib/libncurses.so: file too short)
21:47:17 <mikeplus64> anyone know of a remedy?
21:49:45 <mikeplus64> this is on arch linux with ghc 7.0.3
22:02:47 <tsanhwa> hi, I am cabal-installing webkit hackage on windows, and get a error: pkg-config pckage webkit-1.0 version > 1.1.15 is required but could be not found
22:03:26 <tsanhwa> does it mean I have to install webkit by myself?
22:31:28 * hackagebot stm-chans 1.3.0 - Additional types of channels for STM.  http://hackage.haskell.org/package/stm-chans-1.3.0 (WrenThornton)
22:36:51 <nyingen> @quote
22:36:51 <lambdabot> Martty says: im actually surprised i got it to work even though it was O(e^(n!^n!))
22:38:39 <albel727> oh dear.
22:38:49 <albel727> must be a very small constant.
22:39:09 <johnbender> could someone who's familiar with basica category take a look at this gist: https://gist.github.com/c5d8bb7e973e4bffa9de
22:39:17 <johnbender> I'm curious whether I'm missing anything fundamental
22:39:24 <johnbender> ah,
22:40:08 <johnbender> aside from showing closure under composition for both categories
22:40:58 <johnbender> s/basica category/basic category theory/
22:48:42 <Lajla> lambdabot, say Mr. Bot, don't you enjoy it when people go 'f in O(\x.x^2)' or something like that where O(f) = { g : exist x, M (forall y ( y > x -> |g ( y ) | < M * | f (y)))}
22:49:06 <itwenty> I run cabal install happy as normal user and the binary goes in ~/.cabal/bin dir. Which is not in my $PATH. Should I add this dir to my $PATH or run cabal as root user?
22:49:09 <Lajla> Instead of that sloppy f(x) = O (x^2) bullshit
22:51:27 <nyingen> that's "miss bot" to you
22:52:10 <geekosaur> itwenty, you are expected to add it to $PATH, that should be mentioned in documentation somewhere
22:52:53 <Lajla> nyingen, a woman doing complicated mathematics, that's richer than a man understanding the emotions of a child, pfah.
22:55:30 <geekosaur> ...
22:58:25 <itwenty> geekosaur: ok..A quick glance through cabal user guide didn''t reveal anything
23:04:56 * geekosaur got knocked off net before he could add "...but possibly isn't, or at least not in a useful place"
23:05:21 <geekosaur> (which I am kinda aware of, since I recently have been poking at documentation for various other things)
23:56:40 <lispy> Just read a very compelling review on amazon and then realized the review was written by shapr
