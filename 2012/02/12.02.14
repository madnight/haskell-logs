00:00:01 <mandaya> ChickenNoodle: I think you're unsure cause the terminology is still unfamiliar. Given those statements, I'd write the same or very similar code
00:00:11 <Mike___> ok, thanks alot. I will certainly read it
00:00:24 <srhb> ChickenNoodle: Well you have to make a decision how you want it to fail.
00:01:09 <mandaya> srhb is right, that is the one thing left over
00:01:50 <ChickenNoodle> srhb: wasp lanning to simply ignore characters not within the syntax
00:02:07 <ChickenNoodle> return empty
00:02:11 <mandaya> ChickenNoodle: what do you think happens if you feed your tokenize function "abc", as its written right now?
00:02:16 <NihilistDandy> I'm always thrilled when I encounter a character not in my Unicode coverage. Then I get to go searching for obscure fonts to round out my map :D
00:02:20 <ChickenNoodle> it's ill defined for abc
00:02:21 <srhb> ChickenNoodle: I'd probably let the program die horribly when given unsanctioned input.
00:02:34 <ChickenNoodle> i was more worried about getting the one statement working first :)
00:02:43 <srhb> OK. :) I'll butt out then.
00:03:02 <mandaya> ChickenNoodle: alright, sounds good.
00:03:07 <ChickenNoodle> Love all of you for the input <3 I've been working 30 hour weeks on top of 3 classes in my master's programming the last month and I'm absolutely burnt out
00:03:25 <ChickenNoodle> I feel like I would have to whip out my fingers to add single digits these days
00:03:49 <mauke> have a chicken: üêî
00:03:58 <ChickenNoodle> ha :D
00:04:44 <NihilistDandy> ChickenNoodle: Use a bunch of opaque Parsec combinators. Obfuscation is the key to academic success, after all :D
00:05:15 <ChickenNoodle> haha. My prof's English is limited so I get verbose when I panic just so he gets too bored to dock points on something silly and small. Maybe dishonest, but so are his grading practices. tit for tat!
00:05:39 <mandaya> haha, sounds normal
00:06:00 <NihilistDandy> If you're not cheating, you're not trying, as no less than three of my professors have told me over the years.
00:06:32 <ChickenNoodle> Oh my :P
00:06:36 <merijn> NihilistDandy: Ha! I recently saw a homework assignment that just took someone else's assignment from last year and used ghostview to split of the first PDF page with the name
00:06:51 <merijn> Idiot turned it in for grading to the same people that saw the old one >.>
00:07:05 <ChickenNoodle> question: How obnoxiously long can guards be without offending someone (compiler included)?
00:07:37 <ion> Exactly 84 characters.
00:07:38 <ion> (Kidding.)
00:07:41 <ChickenNoodle> :P
00:08:09 <ChickenNoodle> I want the same outcome if my head character is between a and z, A and Z or 0 and 9 (and don't want to import the char module thingermadoo to just do checks on these things)
00:08:12 <NihilistDandy> merijn: If one must cheat, one should cheat well, and quietly. :D
00:08:19 <ChickenNoodle> will the combinational logic work or sould i not bother typing that ugliness?
00:08:30 <mauke> Char won't help you with that
00:08:37 <mandaya> ChickenNoodle: there's a between function
00:08:43 <mauke> :t inRange
00:08:44 <lambdabot> forall a. (Ix a) => (a, a) -> a -> Bool
00:08:53 <mauke> :t all
00:08:54 <lambdabot> forall a. (a -> Bool) -> [a] -> Bool
00:09:04 <NihilistDandy> @src between
00:09:04 <lambdabot> Source not found. This mission is too important for me to allow you to jeopardize it.
00:09:08 <ion> ‚Ä¶ | isAlphaNumeric c = ‚Ä¶
00:09:09 <NihilistDandy> @hoogle between
00:09:10 <lambdabot> Text.ParserCombinators.ReadP between :: ReadP open -> ReadP close -> ReadP a -> ReadP a
00:09:10 <lambdabot> Text.Parsec.Combinator between :: Stream s m t => ParsecT s u m open -> ParsecT s u m close -> ParsecT s u m a -> ParsecT s u m a
00:09:10 <lambdabot> Text.ParserCombinators.Parsec.Combinator between :: Stream s m t => ParsecT s u m open -> ParsecT s u m close -> ParsecT s u m a -> ParsecT s u m a
00:09:18 <ChickenNoodle> so many IRC gizmos... mind = blown.
00:09:24 <mandaya> huh, guess I was thinking of inRange
00:09:26 <NihilistDandy> Haha
00:09:26 <merijn> lambdabot rocks :)
00:09:34 <ion> isAlphaNumeric c = ‚Ä¶  -- No need to put this inside the guard, you can separate it to a function of its own.
00:09:38 <mandaya> I love the @hoogle searches personally
00:09:40 <merijn> @hoogle Char -> Bool
00:09:42 <lambdabot> Data.Char isAlpha :: Char -> Bool
00:09:42 <lambdabot> Data.Char isAlphaNum :: Char -> Bool
00:09:42 <lambdabot> Data.Char isAscii :: Char -> Bool
00:09:50 <ChickenNoodle> ion: I don't think I understand your suggestion
00:09:51 <merijn> > isAlphaNum 'c'
00:09:52 <lambdabot>   True
00:09:55 <merijn> > isAlphaNum '+'
00:09:57 <lambdabot>   False
00:10:05 <ion> > isAlphaNum '√•'
00:10:06 <lambdabot>   True
00:10:08 <mauke> > isAlphaNum '√©'
00:10:09 <lambdabot>   True
00:10:17 <elliott> ChickenNoodle: Importing the char module tingermadoo is all of one line ("import Data.Char")
00:10:21 <NihilistDandy> I keep wanting to hack on lambdabot, but the source just feels so dense, comparatively
00:10:24 <mauke> > isAlphaNum '‡•™'
00:10:25 <lambdabot>   True
00:10:36 <elliott> NihilistDandy: Believe me, you don't.
00:10:44 <mauke> :t any
00:10:45 <lambdabot> forall a. (a -> Bool) -> [a] -> Bool
00:11:05 <mauke> :t \c -> any (`inRange` c) [('a', 'z'), ('A', 'Z'), ('0', '9')]
00:11:06 <lambdabot> Char -> Bool
00:11:26 <ChickenNoodle> elliott: I suppose I"ll cave. I worry about doing things like that because I'm not sure what we're 'allowed' to use if that makes sense
00:11:30 <ion> chickennoodle: You asked about how long guards should be. I was just saying you might (or might not) want to make a separate function called isAlphaNumeric and refer to that from the guard.
00:11:36 <merijn> ChickenNoodle: If you get confused by his mention of a guard, just ignore it for now and use an if/else/then. (Then go back to reading Learn You a Haskell until it explains guards :p)
00:11:50 <ChickenNoodle> ion: I understand. thanks!
00:11:58 <ChickenNoodle> merijn: I love me some guards :) No worries there.
00:12:08 <mandaya> ChickenNoodle: Data.Char is pretty standard
00:12:10 <mauke> > (\c -> any (`inRange` c) [('a', 'z'), ('A', 'Z'), ('0', '9')]) 'a'
00:12:11 <lambdabot>   True
00:12:31 <merijn> mauke: Make it a little less readable with @pl ;)
00:12:59 <elliott> ChickenNoodle: Well, Data.Char is part of the base library.
00:13:14 <elliott> ChickenNoodle: It would be painful to get by on only the Prelude functions; Haskell's libraries are modular by design.
00:13:24 <mauke> > ((`any` [('a', 'z'), ('A', 'Z'), ('0', '9')]) . flip inRange) 'a'
00:13:24 <ion> The @pl version would be even more pretty if you used a version that referred to ‚Äòc‚Äô multiple times.
00:13:29 <lambdabot>   mueval: ExitFailure 1
00:13:29 <lambdabot>  mueval: Prelude.undefined
00:13:33 <mauke> > ((`any` [('a', 'z'), ('A', 'Z'), ('0', '9')]) . flip inRange) 'a'
00:13:37 <lambdabot>   mueval-core: Time limit exceeded
00:13:39 <mauke> what
00:13:41 <ChickenNoodle> elliott: This isn't really a "getting acquainted with using Haskell practically" sort of class, so prof has very weird.... expectations...
00:13:44 <NihilistDandy> merijn: You should see the mess of if_then_else_ in my more imperatively minded classmates' OCaml...
00:13:59 <ion> @pl \c -> ('a' <= c && c <= 'z') || ('A' <= c && c <= 'Z') || ('0' <= c && c <= '9')
00:13:59 <lambdabot> ap ((||) . liftM2 (&&) ('a' <=) (<= 'z')) (ap ((||) . liftM2 (&&) ('A' <=) (<= 'Z')) (liftM2 (&&) ('0' <=) (<= '9')))
00:13:59 <startling> what's the best way to handle spaces in parsec? I have three parsers; I want to match "(matches parser1) (matches parser2) (matches parser3)".
00:14:04 <merijn> NihilistDandy: I TA'ed intro FP in Ocaml >.>
00:14:04 <mauke> > ((`any` [('a', 'z'), ('A', 'Z'), ('0', '9')]) . flip inRange) 'a'
00:14:06 <NihilistDandy> Painful circumlocution if ever I saw it
00:14:10 <lambdabot>   mueval: ExitFailure 1
00:14:10 <lambdabot>  mueval: Prelude.undefined
00:14:24 <merijn> Don't get me started :p
00:14:35 <ChickenNoodle> merijn: I'm so sorry
00:14:36 <ChickenNoodle> ha
00:14:49 <mandaya> startling: there's either a spaces combinator, or a really simple way to construct one
00:14:50 <NihilistDandy> While I'm in minor rant mode‚Ä¶ seriously, separate float and int operators?
00:14:53 <NihilistDandy> The fuck?
00:15:07 <mandaya> startling: I remember seeing one in the scheme in 48 hours book
00:15:21 <merijn> NihilistDandy: inorite?
00:15:24 <mauke> > ((`any` [('a', 'z'), ('A', 'Z'), ('0', '9')]) . flip inRange) 'a'
00:15:26 <lambdabot>   True
00:15:31 <startling> mandaya: I'm aware of `spaces`, but I'm not sure of the best way to do three things with spaces in between.
00:15:45 <elliott> oh good, the hackage2 mirror has the package I want
00:15:47 <mauke> startling: do { p1; spaces; p2; spaces; p3 }
00:15:53 <elliott> ...but no haddocks, sigh
00:16:07 <NihilistDandy> merijn: My professor's a hardcore OCaml evangelist and he gets so defensive when people ask about the oddities that he takes as normal
00:16:13 <mandaya> startling: what mauke said, or p1 <*> spaces <*> p2 <*> spaces...etc.
00:16:32 <ion> mandaya: That doesn‚Äôt have the same meaning.
00:16:51 <mandaya> ion: one sec, checking in ghci
00:16:53 <QinGW> What's wrong with hackage.haskell.org?
00:16:56 <startling> mandaya: I'll take a look at the scheme book, thanks
00:16:58 <QinGW> I can't reach there.
00:17:53 <adimit> I'm curious: ever since ghc 7.0 or so, I've been getting a lot of SpecConstr warnings when compiling with -Wall ‚Äî can I just ignore them, and if not, how should I treat them?
00:18:22 <mauke> adimit: ignore them
00:18:33 <elliott> adimit: you can turn them off
00:18:42 <ChickenNoodle> I forget, can haskell take two functions with the same name and different types? overloading or what have you
00:18:48 <adimit> mauke: ok. Is there any material on *why* exactly they show up?
00:18:58 <elliott> adimit: -dno-debug-output
00:19:04 <mauke> adimit: I don't know
00:19:05 <adimit> elliott: thanks!
00:19:06 <elliott> adimit: they're internal debug messages
00:19:09 <ion> chickennoodle: Type classes, too.
00:19:10 <elliott> they basically mean "couldn't optimise"
00:19:11 <NihilistDandy> I cannot believe it took me this long to find pandoc. I might just be in love
00:19:13 <mauke> ChickenNoodle: not directly
00:19:14 <elliott> 7.2 gets rid of them
00:19:27 <adimit> ‚Ä¶ ok, if they're internal debug messages, then I don't need to know about them.
00:19:40 <adimit> No need to concern myself with the interna of GHC.
00:21:53 <ChickenNoodle> What is t0?  Couldn't match expected type `Char' with actual type `[t0]'
00:22:14 <mauke> ChickenNoodle: a type variable
00:22:22 <mauke> ChickenNoodle: [t0] is "a list of something"
00:22:40 <startling> anyway, I can't think of a better way to do this: http://bpaste.net/show/23548/ . Not least, it consumes input before the `=`; I can use `try` but I feel like there's a better way.
00:22:40 <ChickenNoodle> So I'm confusing the type inferer somewhere?
00:22:48 <elliott> no, you've mismatched your types
00:22:51 <elliott> it's not confused, you are ;)
00:22:58 <mauke> ChickenNoodle: your code returns a list where a Char is needed
00:23:00 <elliott> (and it's the type checker here, not the inferer, although the line is blurry)
00:23:11 <merijn> ChickenNoodle: Well, the inferrer detects that you are trying to use a Char as a list ([t0])
00:23:26 <ChickenNoodle> oi. screw it. he's not asking for that part.
00:23:28 <merijn> Oh wait, I reveresed it
00:23:51 <mauke> > digitToInt []
00:23:53 <lambdabot>   Couldn't match expected type `GHC.Types.Char'
00:23:53 <lambdabot>         against inferred type...
00:24:10 <mauke> > digitToInt 'a'
00:24:12 <lambdabot>   10
00:28:32 <NihilistDandy> startling: try `try` again *rimshot
00:28:50 <mandaya> there's no chance in hell the ffi will automatically convert a C array into a list is there... or a magic function maybe?
00:29:02 <mauke> there was one
00:29:11 <NihilistDandy> Yeah, it's in Control.Magic~
00:29:25 <mauke> peekArray
00:29:37 <mandaya> @hoogle peekArray
00:29:38 <lambdabot> Foreign.Marshal.Array peekArray :: Storable a => Int -> Ptr a -> IO [a]
00:29:38 <lambdabot> Foreign.Marshal.Array peekArray0 :: (Storable a, Eq a) => a -> Ptr a -> IO [a]
00:29:44 <mandaya> o.O
00:29:47 <mandaya> awesome!
00:29:58 <NihilistDandy> @hoogle digitToInt
00:29:59 <lambdabot> Data.Char digitToInt :: Char -> Int
00:30:24 <hpaste> ChickenNoodle pasted ‚Äú[CharToken '+']‚Äù at http://hpaste.org/63678
00:31:00 <ChickenNoodle> Getting an exception on the exclamation poitns of input "22-!!", even though I have a line to handle non alphanumeric input
00:31:25 <elliott> ChickenNoodle: btw, (x == True) is the same as just "x"
00:31:28 <mauke> ChickenNoodle: get rid of == True
00:31:33 <elliott> and rather than checking it for False, just use "otherwise"
00:31:34 <elliott> | otherwise = ...
00:31:35 <ChickenNoodle> I had that originally and it yelled
00:31:40 <mauke> ChickenNoodle: no, it didn't
00:32:06 <elliott> (also, "Code a type Token suitable to represent a string of tokens of the simple language of expressions." -- your Token type only represents one string ... but I suppose the requirement is ambiguous)
00:32:06 <mauke> ChickenNoodle: your last line has no >
00:32:08 <elliott> ChickenNoodle: what exception?
00:32:10 <ChickenNoodle> mauke: Will try again then. Wouldn't be the first time I did something stupid this ltae at night
00:32:23 <ChickenNoodle> Non-exhaustive patterns in function Main.tokenize
00:32:38 <mandaya> ChickenNoodle: yea, the ==false is causing a problem
00:32:50 <mauke> mandaya: what?
00:32:53 <mandaya> ChickenNoodle: use otherwise
00:32:56 <mauke> mandaya: what??
00:33:00 <elliott> mandaya: what
00:33:06 <mandaya> mauke: look at her guard
00:33:13 <mauke> mandaya: and now?
00:33:23 <elliott> ChickenNoodle: <mauke> ChickenNoodle: your last line has no >
00:33:25 <elliott> ChickenNoodle: did you fix that?
00:33:31 <elliott> the last line isn't being considered as code
00:33:38 <ChickenNoodle> fix which?
00:33:43 <ChickenNoodle> There's so much fixing to be done
00:33:44 <ChickenNoodle> :P
00:33:44 <elliott> <mauke> ChickenNoodle: your last line has no >
00:33:46 <mauke> ChickenNoodle: <elliott> ChickenNoodle: <mauke> ChickenNoodle: your last line has no >
00:33:48 <merijn> ChickenNoodle: Also, the parentheses around "(CharToken '*' : tokenize ns)" are redundant. You can just write "CharToken '*' : tokenize ns" as a result
00:33:51 <elliott> <mauke> ChickenNoodle: <elliott> ChickenNoodle: <mauke> ChickenNoodle: your last line has no >
00:33:55 <elliott> whee
00:34:07 * merijn has a parentheses allergy
00:34:09 <mandaya> Nevermind, just tried it and I'm an idiot
00:34:17 <mandaya> carry on :)
00:34:29 <ChickenNoodle> '>'? Where on earth would that go...
00:34:43 <mauke> ChickenNoodle: where did it go on the other lines?
00:34:51 <NihilistDandy> ChickenNoodle: I think it's just hpaste wrapping the line
00:34:56 <ion> @tell lambdabot <elliott> <mauke> ChickenNoodle: <elliott> ChickenNoodle: <mauke> ChickenNoodle: your last line has no >
00:34:57 <lambdabot> Nice try ;)
00:34:58 <ChickenNoodle> oh XD
00:35:01 <ChickenNoodle> lhs....
00:35:04 <ChickenNoodle> bane of my existence
00:36:02 <ChickenNoodle> \o/
00:36:08 * ChickenNoodle runs around high-fiving everyone
00:36:21 <mauke> ‚Åµ‚Åµ‚Åµ‚Åµ‚Åµ‚Åµ‚Åµ
00:36:23 <NihilistDandy> I usually go the \begin{code} route just because it's easier to see :D
00:36:37 <NihilistDandy> ChickenNoodle: The crowd goes wild~
00:36:37 <ChickenNoodle> what, we're in latex now?
00:36:52 <NihilistDandy> I'm always in LaTeX, yo
00:37:03 <NihilistDandy> Write it in LaTeX, pandoc it to everything else :D
00:37:08 <ChickenNoodle> I was too until profs started requesting lhs. I feel bad for my graders/TAs
00:37:25 <ChickenNoodle> My tex docs were always gorgeous
00:37:29 <elliott> ChickenNoodle: lhs supports \begin{code}...\end{code}
00:37:29 <NihilistDandy> What about lhs stops you from using LaTeX?
00:37:35 <elliott> by design!
00:37:38 <NihilistDandy> What he said
00:37:39 <ChickenNoodle> whaaaaaa :O
00:37:51 <ChickenNoodle> you mean I have to start caring again...? I
00:37:52 <NihilistDandy> Welcome back to the LiGhT
00:37:56 <ChickenNoodle> I'll never get to sleep tonight
00:38:06 <mandaya> hahahaha
00:38:12 <mandaya> <3 LaTeX
00:38:28 <ChickenNoodle> I do too when I don't have to be up for work in 4 hours and am only halfway through an assignment.
00:38:31 * ChickenNoodle sighs
00:39:27 <mauke> L·¥ÄT·¥áX
00:39:39 <NihilistDandy> Well, next time you'll just have to devise a semantic markup system and make the machine write the equivalent TeX for you
00:40:03 <NihilistDandy> It never ceases to amaze me how many hours I'll spend working on something ridiculous to save 10 minutes of work
00:40:11 <NihilistDandy> I should have been a perl programmer~
00:40:27 <mauke> it's not too late!
00:40:34 <koala_man> be careful what you wish for
00:40:46 <mandaya> Oh god... the amount of time I spend automating a trivial task I do maybe 3 times ever...
00:41:19 <NihilistDandy> mandaya: Hence my rule of thumb: If you have to do it more thatn three times, it's time to automate it
00:41:20 <NihilistDandy> :D
00:41:57 <mandaya> NihilistDandy: I like it. I'll have to shamelessly steal that
00:42:24 <NihilistDandy> koala_man: Why would I want opaque, unmaintainable, slow code in perl when I can stick with Haskell and get all that *plus* an ornery typechecker :P
00:42:55 <ion> nihilistdandy: I‚Äôd *love* to automate cooking.
00:42:59 <mauke> NihilistDandy: no one forces you to write opaque, unmaintainable, slow code
00:43:02 <NihilistDandy> mandaya: Though lately that's just been a bunch of boring text processing, so I've been making pandoc do all the hard work
00:43:05 <ChickenNoodle> is there built-in trace functionality?
00:43:07 <mandaya> NihilistDandy: Don't forget the awesome feeling of "doing it right"
00:43:11 <mauke> but the real advantage of perl is cpan
00:43:13 <elliott> mauke: NihilistDandy's brain might
00:43:27 <mauke> ChickenNoodle: not really
00:43:34 <NihilistDandy> mauke: I jest, clearly :P
00:43:36 <mauke> :t trace
00:43:36 <lambdabot> Not in scope: `trace'
00:43:43 <mandaya> @hoogle trace
00:43:44 <lambdabot> Debug.Trace module Debug.Trace
00:43:44 <lambdabot> Debug.Trace trace :: String -> a -> a
00:43:44 <lambdabot> Debug.Trace traceShow :: Show a => a -> b -> b
00:43:47 <NihilistDandy> elliott: Ouch. Soooo cruel
00:43:49 <ChickenNoodle> The foo is this then: "Turn in a trace of execution of your program on the sample strings t1,... t5 shown above."
00:43:52 <ion> <ChickenNoodle> what, we're in latex now?
00:43:53 <ion> Yes. http://i.imgur.com/cjd02.jpg
00:44:05 <elliott> ChickenNoodle: you might have to write your own trace or something
00:44:06 <ChickenNoodle> ion, THAT woke me up lol
00:44:15 <NihilistDandy> ion: Shit, I'm probably on a watchlist now :/
00:44:26 <ChickenNoodle> hahahha
00:44:37 <mandaya> now I know it's late... I stared at that image for a good 10 seconds before I got the joke...
00:44:39 <ChickenNoodle> elliott: Way to be the bringer of bad news :P Maybe I can just type it
00:44:44 <ChickenNoodle> aw mandaya
00:44:45 <Samuel> Hello, I am new here and I am a newbie in computing. I know a little bit of Python and some theory in programming.
00:44:59 <ChickenNoodle> Samuel, may you be more productive in your newbiness than me :P
00:45:05 <elliott> ChickenNoodle: I suggest just responding to every request this guy makes with "INSUFFICIENT DATA FOR MEANINGFUL ANSWER".
00:45:33 <Samuel> I am planning to learn Haskell for Natural Language Processing. Do you think it is a good idea?
00:45:36 <ChickenNoodle> haha elliott... if that was a viable response I wouldn't have gotten a 75 on my midterm. Well that and forgetting to fill out an entire page >:/
00:45:39 <zasimov> Hello =)
00:45:42 <elliott> learning haskell is a good idea
00:45:44 <srhb> Samuel: Sure, why not.
00:45:47 <elliott> whether it's suitable for your domain, who knows, but probably
00:45:53 <Samuel> or should I prefer OCaml?
00:45:59 <elliott> Samuel: I highly recommend http://learnyouahaskell.com/
00:46:03 <elliott> oh, if it's Haskell vs. OCaml, go with Haskell
00:46:04 <zasimov> -1 `div` 3 == 0
00:46:07 <NihilistDandy> "I AM MONAD. YOUR SIDE EFFECTS MUST BE STERILIZED."
00:46:10 <Samuel> or any Lisp?
00:46:11 <elliott> unless there's some existing OCaml lib you need to use or such
00:46:14 <zasimov> but in python -1 / 3 == -1
00:46:18 <elliott> zasimov: (-1) `div` 3
00:46:24 <elliott> > (-1) `div` 3
00:46:25 <lambdabot>   -1
00:46:35 <elliott> -1 `div` 3 === -(1 `div` 3). yes, this is stupid
00:46:37 <NihilistDandy> > - 3 + 1
00:46:38 <lambdabot>   -2
00:46:43 <Samuel> I do not think that there are any lib in OCaml for that, but as I said, I am a noob.
00:46:53 <ddarius> elliott: What if it was Haskell v. C++?
00:46:58 <elliott> Samuel: well, #haskell is always going to recommend Haskell :)
00:47:16 <elliott> ddarius: Well, also Haskell. :p
00:47:29 <Samuel> Are there any lib in Haskell for NLP
00:47:30 <Samuel> ?
00:48:08 <ion> elliott: Huh. Are you insinuating #haskell is‚Ä¶ biased?
00:48:19 <elliott> http://www.haskell.org/haskellwiki/Applications_and_libraries/Linguistics
00:48:28 <elliott> dunno how much of that is actually maintained or whatever
00:48:48 <elliott> Samuel: but based on the nothing I know about NLP, I'd say that Haskell is probably well-suited
00:49:13 <elliott> assuming it involves input, parsing, aggregating and combining data, and output :P
00:49:23 <Samuel> Elliott, What are you personnally doing using Haskell?
00:49:34 <Samuel> and why do you like it?
00:50:02 <elliott> All sorts of things. Haskell is my go-to language.
00:50:05 <ion> I‚Äôm mainly using Haskell to launch the missiles.
00:50:40 <elliott> Samuel: I like it because it's good. More seriously, I deeply appreciate the pure style and static guarantees, as well as the compositional approach to program creation and advanced type system.
00:50:50 <elliott> It also excels at EDSLs, which comes in very handy.
00:50:57 <Samuel> Elliott, do you also make web development in Haskell?
00:51:30 <Samuel> Elliott, what is difficult to do in Haskell than in other languages?
00:52:04 <elliott> I haven't done much web development. Though I'm hacking on a web codebase in Haskell right now.
00:52:44 <NihilistDandy> Yesod finally builds cleanly. I've been waiting for that since 7.0.4
00:52:45 <elliott> Samuel: I don't really feel Haskell has any major problems in terms of difficulty. The library support for some things may be thin on the ground (although I would say there are more active libraries than OCaml, I don't have much to back this up though), but the major bases are covered and very well.
00:53:27 <elliott> You should probably just give it a try. Be warned that it's pretty much nothing like Python; it's probably best to try and put your Python knowledge completely out of your head to learn Haskell.
00:54:05 <ion> University of Brunei Darussalam, huh? I hadn‚Äôt even heard of Brunei before. :-)
00:54:14 <hpaste> Mandaya pasted ‚ÄúImage Conversion‚Äù at http://hpaste.org/63679
00:56:06 <NihilistDandy> hlint is the only thing in the world that I know of that complains about redundant $s
00:56:08 <mandaya> can anyone think of a better way to write that? feels a little unclear to me
00:56:08 <Samuel> It is in South East Asia. Yes, I have already started the book you recommended further above. I enjoy it so far.
00:56:09 <ion> mandaya: do notation?
00:56:10 <Samuel> OK. I have to go home now. Thank you for your advice all of you. I liked our discussion. See you soon.
00:56:10 <mandaya> ion: I was having trouble wrapping my head around the forM inside of the do
00:56:10 <mandaya> it's very late here
00:56:45 <ion> nihilistdandy: It‚Äôs good that it does.
00:57:10 <aleator_> mandaya: What is ImgG?
00:57:11 <elliott> mandaya: flip forM = mapM
00:57:25 <elliott> mkImgL is n = peekArray (fromIntegral n) is >>= mapM (creatingImage . return) >>= newStablePtr
00:57:30 <NihilistDandy> ion: My attempt at a pun was a flop. I am shamed
00:57:34 <elliott> mandaya: Why does creatingImage take a monadic value as a parameter?
00:57:38 <elliott> (What type does it have?)
00:57:46 <mandaya> aleator: a newtype around Image GrayScale D32
00:57:57 <ion> do someGoodName <- peekArray (fromIntegral n) is; someOtherName <- forM someGoodName $ \img -> creatingImage (return img); newStablePtr someOtherName
00:57:57 <aleator_> Ah. What are you doing exactly?
00:58:00 <mandaya> aleator: I just didn't feeling like typing that over and over again
00:58:30 <aleator_> mandaya: Yeah. I get tired of it as well? Do you want an official type alias for it? :)
00:58:36 <mandaya> aleator: working on integrating some vision code I've already written in C with a database
00:59:08 <mandaya> aleator: now that I found CV I'll probably port it to haskell at some point
00:59:15 <roelvandijk> http://www.downforeveryoneorjustme.com/hackage.haskell.org: It's not just you! http://hackage.haskell.org looks down from here.
00:59:17 <roelvandijk> :-(
00:59:21 <mjga> elliott: I would say that for a pythoner it may be better to start with magic RTS options: -xc and -prof -auto-all. and profile everything after it is correct for space leaks
00:59:22 <mandaya> elliott: creatingImage is IO BareImage -> IO Image a b
00:59:48 <mandaya> elliott: thanks for the mapM reference
00:59:51 <aleator_> mandaya: So you have a array of image ptrs and you want a list of images?
00:59:51 <elliott> mandaya: Why not BareImage -> IO (Image a b)?
01:00:00 <elliott> mjga: What?
01:00:01 <mandaya> aleator: yep
01:00:28 <mandaya> elliott: I'm not sure, ask aleator. it's his library
01:00:47 <elliott> ah
01:00:51 <mandaya> elliott: I haven't familiarized myself with the source thoroughly enough
01:00:58 <elliott> I thought it was something in your source.
01:01:02 <zasimov> elliott: Thanks for help =)
01:01:08 <mm_freak_> apparently i don't have to turn on PatternGuards anymore‚Ä¶  is it part of the standard now?
01:01:24 <mandaya> aleator_: I think I may make an Image Pyramid type at some point
01:01:45 <mjga> elliott: I noticed you advised pythoner. I would say: use classes all the time, and add -xc, then profile. it will feel better than python xcept for exceptions
01:01:48 <mandaya> aleator_: the list of images thing feels...unsatisfying?
01:01:51 <ddarius> http://www.haskell.org/onlinereport/haskell2010/haskellli2.html#x3-5000
01:02:17 <elliott> mjga: That sounds like terrible advice for a Python programmer looking to learn Haskell.
01:02:37 <elliott> Pretending Haskell is Python doesn't exactly help one understand Haskell.
01:02:46 <elliott> mm_freak_: yes, since 2010
01:02:54 <MostAwesomeDude> It also doesn't really help one understand how Python and Haskell relate to each other.
01:02:57 <aleator_> \iptr -> S . BareImage <$> newForeignPtr iptr (freeBareImage iptr) gets you an image from a ptr
01:03:18 <aleator_> Providing that you don't touch the pointer afterwards
01:03:19 <ion> Use classes all the time? ‡≤†_‡≤†
01:03:39 * ChickenNoodle rages out silently
01:03:41 <mandaya> aleator_: problem is, I need to read the values back
01:03:48 <mandaya> aleator_: that'll free the pointer won't it?
01:03:55 <mjga> elliott:why? python is where everyhing is high level and you just care to make it work fast. then you may speed it up.and in python you just see result, you on't care what is exact type. I am python programmer (besdie fortran and C, and... haskell)
01:04:24 <elliott> mjga: You gotta be joking if you think not caring about types is the best way to learn Haskell.
01:04:35 <elliott> ChickenNoodle: Very silent.
01:04:49 <mjga> MostAwesomeDude: they both strive to be very expressive high-level languages. duck typing ~= classes - strong typing
01:05:13 <ChickenNoodle> Very. Believe it or not I'm typing all the traces out by hand and the number of lines is... infuriating
01:05:37 <NihilistDandy> ...
01:05:48 <ion> I think we got trolled. :-D
01:05:52 <NihilistDandy> lol
01:05:58 <mjga> MostAwesomeDude: Python is very effective at using libraries to get things done in a clear way. Haskell is very clear, very high-level,libraries are getting there definitely
01:05:59 <elliott> ion: Unfortunately I suspect not.
01:06:02 <mm_freak_> elliott: thanks
01:06:08 <elliott> At least not intentionally.
01:06:11 <aleator_> mandaya: Well, maybe. I need to go to class now, but pop me a mail or put up a github issue and I'll work something out for you in the afternoon
01:06:37 <mandaya> aleator_: will do. Thanks for your help
01:07:23 <mjga> elliott: not caring about types is Python way. Haskell way is care about classes: http://www.haskell.org/haskellwiki/Typeclassopedia. I do not declare types, just write and correct until it works.
01:07:37 <kstt> hey guys. I feel embarrased to come for a basic cabal problem, but I've tried all I could think of, and failed to solve it. It is related to cabal and cabal-dev, with an error popping often, complaining that "cannot satisfy -package Cabal-1.10.2.0". Details are here : http://hpaste.org/63680
01:07:59 <elliott> mjga: Meh, okay, you are just trolling then.
01:08:08 <kstt> any help would help me have a more-or-less productive day :)
01:08:09 <elliott> Haskell's typeclasses aren't even remotely comparable to Python's dynamic typing.
01:08:15 <MostAwesomeDude> mjga: Python is Twisted, PIL, Flask, Django... It's so incredibly not in the Haskell mindset and trying to pretend that they are is not gonna work.
01:08:26 <mjga> elliott: no, I just say that type inference gives you safety and classes _FOR_FREE_
01:08:42 <elliott> mjga: That does not make any sense.
01:08:50 <MostAwesomeDude> mjga: You understand that Python classes and Haskell typeclasses are *totally not the same thing*, right?
01:08:51 <merijn> MostAwesomeDude: I think his point is "Yay!, I don't have to write useless verbose crap like Java forces me to!"
01:08:56 <elliott> kstt: ghc-pkg check?
01:09:10 <elliott> merijn: "use classes all the time"?
01:09:11 <kstt> elliott: that's clean
01:09:26 <elliott> merijn: That's "make a lot of work for myself to be unidiomatic", not "yay, it's concise".
01:09:35 <mjga> MostAwesomeDude: yes, I do :-) btw be nice with a "troll", and call it "different point of view"
01:09:40 <kstt> elliott: GHC + Platform install is 1 day old ...
01:09:52 <elliott> kstt: Dunno then. Sorry.
01:10:01 <kstt> thanks anyway :)
01:10:18 <mauke> mjga: do you understand that type inference is orthogonal to classes?
01:10:44 <ion> There‚Äôs nothing with me hammering the screw in and telling others it‚Äôs a good idea. Call it a different point of view.
01:11:06 <mauke> you accidentally a word
01:11:58 <elliott> ion: after all, what is IRC but a platform for legitimising being flat-out wrong?
01:11:58 <ion> Yes, i totally the accidentally.
01:12:00 <mjga> mauke: I do think Type Classes are just way of generalizing type inference, thus not really orthogonal.
01:12:06 <elliott> what
01:12:13 <elliott> that's a completely incoherent statement
01:12:16 <mauke> yeah, you've lost me there
01:12:24 <elliott> do you know what type inference is?
01:12:24 <MostAwesomeDude> Haha, what.
01:12:28 <mandaya> oh dammit, the C backend is gone...
01:12:47 <mandaya> can I still use foreign export without having to go through llvm?
01:12:48 <user56555> is hackage kaputt?
01:12:55 <elliott> mandaya: yes...
01:12:59 <elliott> -fvia-c is orthogonal to the ffi
01:13:00 <elliott> user56555: yes
01:13:05 <user56555> uh ok
01:13:17 <mjga> mauke: type classes let you infer types like (Num a) => a -> a -> a. without TC all Num codes becomes monomorphic, and thus inference looses its tooth
01:13:23 <mandaya> elliott: I'm getting errors telling me to use -fvia-C
01:13:30 <elliott> mandaya: hpaste?
01:13:38 <mauke> mjga: why do you think so?
01:13:49 <mauke> mjga: most code isn't polymorphic in Num
01:13:52 <elliott> mjga: data Num a = NumD { add :: a -> a -> a; fromInteger :: Integer -> a }
01:13:56 <elliott> mjga: blah :: Num a -> a -> a -> a
01:14:00 <elliott> no type-classes
01:14:03 <elliott> same thing
01:14:11 <elliott> completely unrelated to inference
01:14:21 <mjga> mauke: yeah, I used SML modules and it was a pain for things like numbers. too many modules I used.
01:14:54 <mjga> elliott: no type classes, inconvenience at every step :->
01:15:06 <xil> hi everyone. Is hackage down?
01:15:09 <hpaste> Mandaya annotated ‚ÄúImage Conversion‚Äù with ‚ÄúImage Conversion (annotation)‚Äù at http://hpaste.org/63679#a63681
01:15:09 <elliott> xil: Yes.
01:15:14 <elliott> mjga: This still has absolutely nothing to do with type inference.
01:15:17 <elliott> You can have typeclasses without type inference.
01:15:23 <xil> elliott: thanks =]
01:15:28 <mjga> elliott: there is synergy
01:15:41 <elliott> mandaya: huh
01:15:56 <elliott> mjga: That they go well together does not mean that one is a "generalisation" of the other.
01:16:01 <qnikst> hello, what had happened to hackage?
01:16:15 <elliott> Anyway, using Haskell classes as if they were Python classes doesn't work (because they're not the same thing) and will cause hellish ambiguities.
01:16:22 <elliott> qnikst: It went down.
01:16:26 <mandaya> oh, duh, I'm dumb
01:16:30 <mandaya> of course it doesn't work in ghci
01:17:26 <qnikst> and is there some official mirrors?
01:17:30 --- mode: ChanServ set +o mauke
01:17:30 --- topic: set to '["hackage is down","Haskell Platform 2011.4: http://bit.ly/Clv5r","GHC 7.2 and cabal-install: http://is.gd/LXRBhh (all archs not just mac)","Paste code/errors: http://hpaste.org/new/haskell","GHC 7.2.1: http://is.gd/IU2lRI","Haskell News: http://reddit.com/r/haskell","The Haskell programming language http://haskell.org","Logs: http://bit.ly/5mwtRQ","admin/spam issues: #haskell-ops"]' by mauke
01:17:38 <mjga> elliott: I don't know why you compare TC and OO classes, but I would never go into that. I say that inference+TC pretty much eliminate 90% of advantage in duck typing, if you have good classes.
01:19:30 --- mode: mauke set -o mauke
01:20:00 <xil> is there another way than hackage for me to view the docs for System.Random?
01:20:09 <mjga> I program in both Python and Haskell, so I just told what are killer features for me: DT and exceptions in Python, TC+TI, strong typing+compile-time optimization in Hs. It just so happens, that they compete as high-level tool for the things I do
01:20:43 <elliott> How long has the topic been a list of strings?
01:20:51 <elliott> It plays havoc with my IRC client's link detection. :(
01:21:09 <wavewave> mjga: you are using term 'inference' in quite different meaning than conventional way.. anyway I do not think both of you are disagreeing much.
01:21:56 <mauke> elliott: does xchat let you customize link detection?
01:22:09 <elliott> I don't believe so.
01:22:23 <mauke> haha
01:22:27 <elliott> Seems not.
01:23:27 <wavewave> mjga: internally, type classes are implemented as elliott said btw.
01:24:36 <mauke> https://bugs.launchpad.net/ubuntu/+source/xchat/+bug/276115 open since 2008
01:26:07 <xil> well maybe someone here just might know what I need. Hoogle isn't finding the function and I forgot what it's called, but it's in System.Random and has a type of, I think, (StdGen -> (a, StdGen)) -> IO a. It give the standard generator to the function, updates it with the snd of the result and outputs the fst of the result
01:26:24 <wavewave> mjga: see this talk by SPJ. it explains about internal rep of typeclasses a little bit.  http://yow.eventer.com/events/1004/talks/1054
01:27:10 <xil> oh hmm....I got hoogle to work now. It's "getStdRandom" that I was looking for
01:27:28 <roelvandijk> xil: Also take a look in your .cabal directory
01:27:42 <roelvandijk> xil: Specifically .cabal/share/doc/index.html
01:27:59 <roelvandijk> xil: If you are on linux it is in your home directory
01:28:07 <kstt> oh no .... hackage is down again :(
01:28:38 <xil> roelvandijk: I am on linux and am familiar with the folder, but there's no index.html
01:29:25 <roelvandijk> xil: Do you have "documentation: True" in your ~/.cabal/config ?
01:29:40 <mm_freak_> is there an O(log n) lookup data structure that can be created very efficiently, i.e. faster than Data.Map?  the keys are effectively random and unsorted
01:29:53 <xil> roelvandijk: doubtful, though there is a folder for each package in the doc/ directory
01:29:53 <kstt> Seriously, package management in Haskell is painful :/ If Haskell itself wasn't THAT great, I would have given up just because of package management !
01:30:31 <mm_freak_> kstt: seriously?  have you compared cabal to autoconf/automake? ;)
01:30:34 <wavewave> mjga: see it from about 40min..
01:30:42 <xil> roelvandijk: now I have "documentation: True"
01:30:58 <kstt> I really think hackage is down more often than most hobby websites I visit :)
01:31:16 <roelvandijk> xil: I'm not really sure if that documentation option will build the global index
01:31:26 <roelvandijk> xil: It could also depend on your cabal version, but I am not sure
01:31:50 <kstt> mm_freak_: I'm speaking of cabal/hackage, and can compare it to ruby gem which is a breeze.
01:32:00 <nus> kstt, a local mirror and an update schedule might help
01:32:01 <NihilistDandy> xil: If you grab docidx from github (or hackage when it comes back up) you can generate a convenient centralized index file
01:32:05 <xil> roelvandijk: I'll look into it more another day. It's too late for that now =/
01:32:18 <xil> NihilistDandy: ah okay, thanks =]
01:32:21 <NihilistDandy> Though you can also tell cabal to make one fromt he config file
01:32:25 <NihilistDandy> *from
01:32:48 <dcoutts> kstt: ahh, that's why my mirroring stopped
01:32:57 <xil> NihilistDandy: oh yeah I see that config option
01:33:07 <nus> dcoutts, #haskell HA at your service (-;
01:33:15 <dcoutts> heh
01:33:27 <dcoutts> well we have a partial mirror :-)
01:33:38 <mm_freak_> kstt: ok, i can't comment on that one
01:33:56 <dcoutts> but only a mirror for packages starting with A-Z and a-d :-)
01:34:12 <NihilistDandy> But docidx gives a nice hackage style layout as a list of packages. The developer made the unfortunate decision to make it use a remote stylesheet, though, so you might want to tweak it if you get as bothered as I do by unstyled indices :D
01:34:42 <NihilistDandy> https://github.com/andyprice/docidx.hs
01:34:55 <xil> I'll have to take a look tomorrow. But now I think it's bed time. Thanks for the link, I'll bookmark it =]
01:35:11 <kstt> dcoutts: were you in the process of importing packages to hackage 2 ?
01:35:17 <dcoutts> kstt: right
01:35:40 <dcoutts> mm_freak_, kstt: well at least hackage.h.o is looked after by a paid admin, unlike the rest of our infrastructure
01:35:47 <dcoutts> downside is he's on the US west coast
01:35:52 <kstt> dcoutts: I think that's what causes hackage 1 to go down. Grany often don't want to retire.
01:36:10 <dcoutts> so it may not be back up 'til they're awake
01:36:13 <dcoutts> kstt: hah
01:37:22 <mjga> wavewave: implementation is good thing, but what I care most is convenience: TC are much different than implementing them by hand - aren't they?
01:37:24 <elliott> dcoutts: I remembered the mirror and was happy for about 5 seconds until I realised it didn't have haddocks :P
01:37:34 <dcoutts> heh
01:37:49 <dcoutts> elliott: though we do have a doc builder client
01:37:53 <elliott> the package was in the alphabet range, too!
01:37:58 <dcoutts> heh
01:38:01 <dcoutts> so close!
01:38:03 <elliott> irony of ironies:
01:38:11 <elliott> I was looking up blaze-html documentation ... while hacking on Hackage 2
01:38:18 <elliott> I think Hackage1 is going down to protect itself.
01:38:32 * elliott dons tinfoil hat.
01:38:41 <ion> dons‚Äô tinfoil hat
01:38:45 <mjga> elliott: why not to mirror Hackage on Hackage2 test site?
01:39:10 <elliott> <kstt> dcoutts: were you in the process of importing packages to hackage 2 ?  <dcoutts> kstt: right
01:39:18 <elliott> Also, Hackage 2 doesn't build documentation yet.
01:39:46 <mjga> elliott: thx, I wait for that for ages ;-)
01:39:47 <wavewave> mjga: that implementation is not just an implementation. that's the definition of type class in a sense. that's why type classes are different from classes in oop.
01:40:15 <wavewave> hm.
01:40:32 <Philippa> the main thing a type class gets you that can't be done without is the 1:1 type -> instance mapping
01:40:40 <dcoutts> elliott: are you volunteering your box to run the doc builder client?
01:40:54 <dcoutts> elliott: I can allocate a username and passwd for your bot :-)
01:41:08 <Philippa> (and thus, inferring which instance to use 'for free', even when it involves building one out of lots of others)
01:41:11 <elliott> dcoutts: ha! my VPS' ssh key is on another machine!
01:41:14 <elliott> you can't trap me!
01:41:25 <ion> For one thing, we have polymorphism on the return value, too, since the vtables aren‚Äôt attached to objects.
01:41:35 <elliott> I somewhat doubt it has adequate enough specs for the job
01:41:42 <dcoutts> :-)
01:42:24 <elliott> btw, what is going on with Distribution/Server/Features/Html.hs :(
01:42:31 <dcoutts> elliott: for the build clients, we can have as many as we like, for the doc builders it's probably more sensible to have a smaller number of somewhat controlled ones
01:42:41 <dcoutts> elliott: "going on?"
01:43:15 <mjga> wavewave: not really: exists a -> (tc dictionary, a) is Luca Cardelli's definition of an object, I recall
01:43:21 <dcoutts> elliott: you mean, why is it such a big module, so unmodular?
01:43:24 <elliott> dcoutts: well, I can't figure out what it's actually meant to contain :) I guess that's why there's a comment at the top about needing tob e split up
01:44:24 <dcoutts> elliott: it's most of the chrome all in one module, because unlike the other features, it depends on more or less everything and html is not compositional (not without looking awful)
01:44:32 <mjga> oh, what is when I suddenly "am not on that channel"?
01:44:44 <elliott> mjga: you keep leaving
01:44:50 <elliott> dcoutts: right
01:45:03 <mjga> elliott: nope, it happened wo leaving
01:45:06 <dcoutts> elliott: trace it by starting from the resource list
01:45:17 <elliott> some more logic/html separation would be nice
01:45:30 <elliott> but right, I mostly get what it's doign
01:45:33 <elliott> *doing
01:45:41 <elliott> time to get acquainted with code folding, I suppose
01:45:49 <rostayob> where's the code for hackage2?
01:46:08 <rostayob> (if that's what you're talking about)
01:46:23 <dcoutts> elliott: the idea is that most of the logic should be in other features
01:46:31 <elliott> rostayob: http://github.com/isomorphism/hackage2 or a darcs repo on code.haskell.org
01:46:32 <dcoutts> elliott: and the html one just plugs everything together
01:46:36 <elliott> dcoutts: right
01:46:47 <elliott> it's kind of trying to be like a component-based webframework, I think
01:46:51 <dcoutts> rostayob: see http://hackage.haskell.org/trac/hackage/wiki/HackageDB/2.0
01:47:17 <rostayob> oh, happstack. I can help I guess
01:47:21 <dcoutts> elliott: yes, but with the acceptance that html just isn't compositional
01:47:38 <elliott> dcoutts: you realise you just linked to a page on the Hackage website?
01:47:40 <elliott> which is currently down? :P
01:47:45 <dcoutts> doh!
01:47:47 <dcoutts> :-)
01:48:06 <dcoutts> rostayob: when it comes back, that page has all the instructions :-)
01:48:12 <alang> haha I thought that was intentionally ironic
01:48:19 <rostayob> dcoutts: ok
01:49:26 * elliott was thinking that download count + reverse dependencies would be a better popularity metric than manual voting
01:50:45 <dcoutts> elliott: yes, that's always been my opinion too
01:50:55 <nus> weighted manual voting + both others?
01:51:12 <dcoutts> elliott: but people want to vote apparently, or at least leave comments
01:51:37 <elliott> dcoutts: comments could be reasonable or such
01:51:43 <elliott> dcoutts: I was thinking in terms of ordering the package list
01:51:46 <dcoutts> elliott: we could let them vote and leave comments but ignore them and only rank by objective metrics ;-)
01:52:05 <elliott> dcoutts: well there could be a reviews section where you can leave a review with a star rating or whatever
01:52:14 <elliott> display it on the package page and don't rank by it :P
01:52:18 <dcoutts> elliott: aye
01:53:23 <elliott> (is the infrastructure in place for collecting download statistics "liev"?)
01:53:24 <elliott> *live
01:53:29 <dcoutts> elliott: yes
01:53:31 <elliott> well, s/live/updated at some regular interval/
01:53:32 <elliott> great
01:53:38 <dcoutts> it's completely live
01:53:56 <dcoutts> and it's displayed on each package page atm
01:53:59 <dcoutts> iirc
01:54:01 <roelvandijk> Or offer multiple package rankings. But we would still have to decide on the default one.
01:54:09 <elliott> how detailed? e.g. can you account for a single IP redownloading repeatedly?
01:54:20 <dcoutts> elliott: no, it's just a counter per version
01:54:33 <elliott> right
01:54:49 <mandaya> hmm... I'm getting undefined linkage against my c functions that I have to have compiled by ghc
01:54:51 <elliott> roelvandijk: choice is overrated :P
01:55:17 <dcoutts> elliott, roelvandijk: either way, the trick is not to display any reason or rating for the ordering you give
01:55:17 <mandaya> when I try to link against the object file with gcc
01:55:33 <mandaya> do I have to have ghc do the final linkage or something?
01:56:30 <mandaya> I really hope not...
01:57:00 <dcoutts> mandaya: easier but not essential, ghc calls gcc for the final link with a ton of extra flags, you can copy those
01:57:47 <nus> dcoutts, what constitutes a download? a single GET?
01:57:53 <elliott> dcoutts: hehe, i can't tell how serious you're being but i agree :P
01:57:58 <elliott> oh wait
01:58:03 <elliott> i completely misparsed that
01:58:19 <elliott> actually now I have no idea how it's meant to be parsed
01:58:20 <mandaya> dcoutts: how can I get ahold of those flags?
01:58:23 <dcoutts> nus: yes
01:58:24 * elliott is tired :(
01:58:34 <dcoutts> mandaya: ghc -v
01:58:39 <mandaya> thanks
02:00:05 <NihilistDandy> elliott: dcoutts: Better obfuscate the package names, too, no?
02:00:28 <ddarius> ion: I don't recommend emphasizing polymorphism "on the return value."
02:00:53 <elliott> dcoutts: could the counter structure be improved to accommodate a log with IP information and such, or are there space/scaling issues with that?
02:00:53 <mandaya> oh my god, you weren't kidding about the number of those flags...
02:01:31 <NihilistDandy> mandaya: The next GHC extension will almost certainly be called semaphore
02:01:49 <mandaya> >.<
02:02:03 <RichyB> But me already *have* QSem in Control.Concurrent... ;)
02:02:05 * mandaya cries
02:02:06 <NihilistDandy> Although‚Ä¶ (http://en.wikipedia.org/wiki/Semaphore_(programming))
02:02:15 <NihilistDandy> RichyB beat me to it :D
02:03:56 <rostayob> ddarius: so is the trac website going to be up anytime soon :)?
02:04:33 <elliott> rostayob: the trac is up, hackage itself is down
02:04:45 <elliott> it'll be up whenever hackage stops being down :P
02:05:29 <mandaya> ... one of those billions of flags is a file in /tmp/
02:05:32 <ChickenNoodle> Thank you to everyone who helped tonight :] I need to go collect my 3 hours of sleep now. Have a good night!
02:05:45 <mandaya> ChickenNoodle: lucky you :)
02:05:51 <ChickenNoodle> Indeed ;D
02:07:06 <mandaya> *sigh* still didn't get all of them
02:07:35 <dcoutts> elliott: sorry, back later
02:08:38 <elliott> dcoutts: no problem
02:09:40 <nus> elliott, re IPs, there are many ISPs operating their user mass from behind a couple addresses
02:13:08 <elliott> nus: yeah, I know
02:13:25 <elliott> nus: statistics like these are fundamentally exercises in imprecision
02:13:40 <elliott> nus: but to be useful for Hackage, they basically only have to be correct to an order of magnitude
02:14:11 <elliott> things like the big web frameworks at the top of the web development category, aeson and blaze-builder at the top of the text category, and so on
02:14:37 <elliott> nus: and showing things as less popular due to ISPs is better than making it trivial for anyone to shoot a package up to the top of the list
02:16:44 <nus> elliott,  It's rather easy to organize a distributed attack nowadays
02:17:11 <elliott> nus: yes -- but a lot harder than while true; do wget mwahaha.tar.gz; done
02:17:32 <elliott> being at the top of the hackage lists is not going to win anyone fame and glory. but a one-liner shell script should not be able to ruin them
02:19:32 <ddarius> elliott: It's not like such behavior would not go undetected or would be uncorrectable.
02:20:38 <elliott> ddarius: True, but if a log is used instead of a simple counter (which would, of course, be produced by a regular static webserver anyway), it's a couple of lines of codes to stop it.
02:30:33 --- mode: kornbluth.freenode.net set +o ChanServ
02:31:27 <NihilistDandy> netsplit?
02:31:35 <elliott> a mighty impressive one
02:32:31 <NihilistDandy> Quite a wall of joins :D
02:35:35 <mandaya> *facepalm*
02:35:48 <mandaya> even after I managed to get ghc to compile and link the whole program for me
02:36:23 <mandaya> it still can't link against the file originally compiled by ghc
02:38:18 <kstt> elliott: dcoutts: I'm afraid that the download count metric leads to stable equilibrium, where people alway download the most popular product, making it even more popular.
02:38:37 <kstt> the revdeps looks better, OTOH
02:39:27 <kstt> maybe google can also help rank them, based on how much content (blog posts, docs, tutorials ...) point to a package
02:41:08 <elliott> kstt: sure, but -- is that equilibrium necessarily a bad thing?
02:41:10 <elliott> it applies to revdeps too
02:41:16 <elliott> people look for a library to use in their own package
02:41:19 <elliott> pick the most popular, etc.
02:41:33 <elliott> if the idea is to represent popularity, that it is self-sustaining is unavoidable
02:43:46 <rostayob> dcoutts: since you're already using github, why don't you use its issue tracker? it's not bad
02:44:06 <dcoutts> rostayob: I'm not already using github
02:44:24 <dcoutts> rostayob: upstream is http://code.haskell.org/hackage-server/
02:44:44 <rostayob> dcoutts: well since you already have a github account set up
02:44:48 <dcoutts> rostayob: but people are free to make git mirrors if that's what works for them
02:45:02 <dcoutts> rostayob: oh that was under duress for another project at work :-)
02:45:08 <rostayob> dcoutts: I was talking of just using the issue tracker
02:45:24 <dcoutts> rostayob: we already use trac for all the cabal/hacakge bugs/issues
02:45:28 <rostayob> i've seen many people do that with google code, using it only for the issue tracker
02:45:34 <rostayob> dcoutts: yeah, but trac is down :P
02:45:48 <dcoutts> rostayob: no I fixed it (but the server is temporarily down)
02:45:54 <rostayob> with github, it'd (almost) never be down
02:46:04 <dcoutts> hackage.h.o is rarely down
02:46:23 <dcoutts> it's a Galois machine, maintained by their sysadmin
02:46:30 <rostayob> well, I remember it being down more than once
02:46:44 <elliott> it's been down like three times in the past few weeks
02:46:47 <rostayob> for long periods of time, something that would never happen on github
02:46:54 <mandaya> ok, I'm very confused
02:47:25 <dcoutts> rostayob: it makes sense for mirrors of hackage packages itself, less so for the dev infrastrucutre, we have all the ghc development on the hackage.h.o machine too
02:47:26 <mandaya> I have C functions being compiled by gcc (using ghc flags)
02:47:47 <mandaya> but just that file won't link correctly
02:47:49 <rostayob> dcoutts: mh, ok. It'd just save a lot of pain bot for the sysadmins and the users
02:47:56 <elliott> rostayob: to be fair
02:47:58 <mandaya> does anyone have any ideas? I'm at my wits end
02:48:00 <elliott> hackage being down disturbs every single haskell user
02:48:07 <elliott> it significantly impairs work whether you can access an issue tracker or not
02:48:17 <elliott> the solution is to stop hackage.haskell.org going down :P
02:49:00 <dcoutts> yes, I'm much more worried about affecting all users when the package collection is unavailable than people being unable to report bugs for a few hours
02:49:19 <elliott> that said, i still hate trac ;)
02:49:28 * elliott is really good at complaining!
02:49:34 <dcoutts> btw, I'm not here :-)
02:49:38 <elliott> of course not
02:49:59 <rostayob> elliott, dcoutts: true true, but still deferring stuff like issue tracking to github is easy, while putting hackage on github is impossible :)
02:50:06 <rostayob> anyways, going to have lunch
02:50:23 * nus wonders if there's a PMS using a DHT as a backend yet
02:50:55 <NihilistDandy> rostayob should have consulted the @faq before he made such a rash statement as that
02:52:30 <kstt> NihilistDandy: where is this @faq ?
02:53:00 <NihilistDandy> @faq Can I use Haskell to find the FAQ?
02:53:00 <lambdabot> The answer is: Yes! Haskell can do that.
02:53:40 <eddayyy> Is there some way for me to do a cabal update & cabal install X that doesn't timeout (i.e is there a mirror I can use)?
02:54:20 <kstt> Because I also happen to think that the hackage trac being down due to spam is an indication that its job should be handled by a solid third party service, such as Github or Google projets ...
02:54:23 <elliott> I only know of partial ones
02:54:31 <elliott> but there is probably a complete one nobody knows the URL to
02:54:37 <elliott> kstt: the hackage trac is not down
02:54:42 <elliott> the hackage trac is up as of yesterday
02:54:46 <elliott> hackage *itself* is down
02:54:48 <elliott> taking the trac with it
02:54:59 <kstt> elliott: yeah, I know.
02:55:11 <kstt> I meant it has been down for months.
02:55:16 <elliott> erm.
02:55:20 <elliott> hackage has not been down for months.
02:55:24 <elliott> haskell would be dead if that was the case
02:55:37 <kstt> hackage trac has been down for months :)
02:55:53 <NihilistDandy> As usual, the completeness of a hackage mirror is inversely proportional to its availability to the wider world
02:56:24 <NihilistDandy> If only hackage.haskell were less complete, it might not have gone down T_T
02:56:44 <elliott> :D
02:58:54 <NihilistDandy> Fie, fie, Haskell Foundation and your accursed hubris!~
03:00:39 <b0fh_ua> Hi all! I have function f :: String -> IO (Maybe String) and g :: Maybe String -> Maybe [Item]. Function f takes URL as input and returns content of resource, and function g parses the content and transform it into custom data type. Now I have function a :: [Item] -> Data.Map String LocalTime, which aimed to take Item and extract modification time from it. For single url it works well: (a . g) <$> (f "url"), but I wanted to run this xf = ((a . g ) <$> f)
03:00:50 <b0fh_ua> how to do that correctly?
03:00:57 <drdo> Is there something i can read about cabal-install upgrade (why it was removed) ?
03:01:36 <elliott> drdo: it liked to upgrade boot packages iirc
03:01:47 <elliott> so it had to be exterminated ;)
03:01:57 <drdo> elliott: So why is the solution not to just not do that? :P
03:04:37 <drdo> Or just recompile ghc when such packages are upgraded
03:07:31 <NihilistDandy> Was that another netsplit, or are my fears confirmed? IRC HATES ME~
03:08:01 <drdo> Definitely another net split
03:08:05 <mauke> NihilistDandy: that was a netsplit plus irccloud timing out
03:08:12 <mauke> MULTIKILL
03:08:51 <elliott> [predictable jab at the cloud]
03:09:08 <drdo> I chose a good time to delete my .ghc too
03:09:17 <drdo> oh hackage is back!
03:10:50 <abdulsattar> Can I delay a thread for an exact time?
03:11:32 <abdulsattar> threadDelay delays the current thread but it doesn't gurantee the delay to be equal to the time specified
03:11:35 <elliott> no, OSes do not support such things
03:11:41 <elliott> you need hard real-time systems for guarantees like that
03:12:01 <elliott> abdulsattar: the OS is free to schedule your thread whenever it wants
03:12:17 <abdulsattar> What is the best way to implement a Timer in Haskell then?
03:12:40 <abdulsattar> I was forking a new thread and delaying it the specified time.
03:12:42 <elliott> threadDelay
03:12:47 <drdo> abdulsattar: You can't do that at all with any common OS
03:13:17 <ion> You want exact timing? Get rid of the multi-tasking kernel and use timer interrupts.
03:13:33 <abdulsattar> I implemented the Timer using threadDelay but it wont stop sometimes for a minute when the time given is actually 10 secs or something
03:13:47 <elliott> It might very well.
03:13:52 <elliott> It's not likely to if not under high load, though.
03:14:00 <abdulsattar> ion: I don't want the exact thing, I just want a close enough value.
03:14:01 <elliott> You cannot guarantee anything, but you can hope.
03:14:11 <abdulsattar> 1 min for 10 secs is just highly inaccurate
03:14:13 <elliott> Use threadDelay and the OS will try its best (given its policies).
03:14:19 <elliott> Who said you'll get 1 min?
03:14:28 <abdulsattar> It did for me
03:14:30 <abdulsattar> I tested it
03:14:35 <elliott> wat
03:14:37 <elliott> show test program
03:15:02 <mandaya> @hoogle fromJust
03:15:03 <lambdabot> Data.Maybe fromJust :: Maybe a -> a
03:15:16 <elliott> noooo don't do it
03:15:23 <mandaya> haha
03:15:32 <mandaya> I'm just trying to get something working
03:15:44 <mandaya> I'll fix it later
03:16:00 <elliott> that's what everyone says
03:16:00 <hpaste> Abdulsattar pasted ‚ÄúIRC‚Äù at http://hpaste.org/63684
03:16:46 <elliott> abdulsattar: try and reduce it into as small an example as possible
03:16:51 <elliott> it's 99.9% a bug in something else in your code
03:17:03 <elliott> reducing it will help you find out what it is, or else help you prepare a program to more easily test the weird scheduler behaviour
03:18:11 <abdulsattar> The time function returns the number of microseconds and the line here http://hpaste.org/63684#line63 calls the threadDelay
03:24:58 <hpaste> aleator pasted ‚Äúcopying cv images from bare pointers‚Äù at http://hpaste.org/63685
03:26:11 <drdo> GHC is saying bytestring doesn't have an IsString instance...
03:26:22 <elliott> import .Char8 and feel bad that you're misusing bytestrings :P
03:27:07 <drdo> Not misusing them :P
03:27:33 <aleator_> mandaya: Here's a patch that might help.
03:27:40 <drdo> Weird, i thought utf8-string would provide one
03:28:41 <ben> I'm tempted to suggest some implicit variables shenanigans or specifying the encoding, but I suspect it won't actually work with IsString
03:28:53 <elliott> drdo: If you're using bytestring literals, you're probably misusing them as strings. :(
03:28:59 <elliott> And yeah, it won't work with utf8-string.
03:29:07 <elliott> (Why aren't you using Text?)
03:29:14 <ben> filenames?
03:29:46 <elliott> Then utf8-string wouldn't apply.
03:30:45 <drdo> elliott: bencode strings
03:30:57 <elliott> Aren't those binary?
03:31:02 <drdo> Exactly
03:31:05 <drdo> :P
03:31:11 <elliott> So why are you using utf8-string?
03:31:53 <drdo> to provide a conversion to String
03:32:23 <drdo> They are binary but most things will actually be text (torrents)
03:32:40 <drdo> Well not most things, but some things
03:32:47 <drdo> Probably most things
03:33:01 <elliott> Consider me reassured
03:33:20 <elliott> drdo: I would suggest providing conversion to Text instead, it has efficient UTF-8 decoding built-in.
03:33:26 <drdo> elliott: I provide that as well
03:33:30 <elliott> fair enough
03:34:01 <jedai|2> drdo: You could probably use Text rather than String though, it's more specialised than String (which is just [Char] when all is said and done)
03:34:13 <jedai|2> Ok, 4I'm late :)
03:36:36 <drdo> I'm not actually using String, i just have a String instance for my FromBE and ToBE classes
03:43:53 <drdo> How does one refer to class instances in the module system?
03:44:06 <Axman6> you don't
03:44:21 <drdo> So what happens if you import 2 modules that provide the same instance?
03:44:31 <drdo> How do you choose?
03:45:03 <Jedai> You don't ... :-/
03:45:05 <Axman6> you shouldn't have two module that have the same instance definition
03:45:31 <Axman6> instances are part of the type's definition, and should ideally be in the same module the type is defined in
03:45:53 <drdo> Axman6: Makes perfect sense in this case (providing IsString for ByteString with different encodings)
03:46:32 <Axman6> it really doesn't
03:46:43 <Axman6> that is not how you're supposed to do things
03:47:02 <Axman6> IsString is supposed to be an extremely basic conversion from String to your type, nothing more
03:47:17 <Axman6> if you need anything more complex, you should be using functions
03:47:19 <elliott> drdo: see this:
03:47:32 <elliott> http://stackoverflow.com/questions/8728596/explicitly-import-instances/8731340#8731340
03:47:40 <elliott> use plain old definitions instead, don't abuse the typeclass system
03:47:42 <Axman6> scumbag elliot, directs attention to nothing for a long time
03:47:58 <elliott> Axman6: i should really have that answer on hotkey, it comes up every few days :P
03:47:59 <erus`> building llvm; see you tomorrow
03:48:17 <Axman6> erus`: bahm it doesn't take that long :P
03:48:27 <elliott> yeah, see erus` in 23 hours
03:48:28 <Axman6> erus`: yeah? i haven't seen it that often
03:48:29 <erus`> and clang*
03:48:38 <Axman6> <3 clang
03:49:00 <Axman6> i'm considering trying to teach my self C++ again, just so i can play with Clang some more
03:49:32 <erus`> its not hard just mutate state and carry lots of redundant data around in classes
03:49:37 <elliott> "I'm considering cutting off my arm, I hear they have really nice prosthetics these days"
03:49:46 <erus`> rinse and repeat until you have a huge spaghetti mess
03:50:20 <erus`> then ship it!
03:50:35 <Axman6> but C++11 has lambdas!
03:50:43 <Axman6> it's like totz functional now
03:50:54 <erus`> clang doesnt implement much C++11 i dont think
03:51:28 <Axman6> it implements almost all of it. it doesn't implement about the same amount GCC doesn't
03:51:52 <Axman6> they have different missing features, but they're about equal in terms of how much of C++11 it implements
03:52:21 <Axman6> http://channel9.msdn.com/Events/GoingNative/GoingNative-2012/Clang-Defending-C-from-Murphy-s-Million-Monkeys for more info
03:52:41 <erus`> yeah i watched that yesterday :)
03:53:06 <Axman6> =)
03:53:39 <Axman6> as someone who has a pretty strong dislike for C++, i found most of the videos very interesting (and horrifying, C++ is so amazingly broken)
03:54:28 <erus`> i need to find a vim plugin that implements all the awesome stuff now
03:55:22 <merijn> Axman6: Does gcc implement C++ lambda's?
03:55:42 <Axman6> not sure
03:55:45 <merijn> Hmm
03:55:48 <Axman6> probably
03:55:56 <luite> is clang better than gcc now?
03:56:02 <merijn> luite: Define better?
03:56:22 <mandaya> gcc does have c++ lambdas
03:56:27 <NihilistDandy> merijn: As of 4.5, at least
03:56:29 * merijn is considering moving the C code base to C++ (in the C + name spaces + templates + first class functions sense, not in the OO sense)
03:56:31 <ion> clang at least outputs considerably better error messages.
03:56:32 <mandaya> but only if you compile with --std=c++0x
03:56:42 <Axman6> luite: in some ways yes, in others no
03:56:59 <merijn> Right now I've jerry-rigged our codebase with CPP templates :>
03:57:36 <Axman6> luite: i'd highly recommend clang while doing development, just for the much faster compile times, and infinitely better error messages
03:57:49 <erus`> merijn: i code like that mostly
03:58:22 <merijn> erus`: I know, but namespaces and templates would make things so much more readable :<
03:58:24 <erus`> but its nice to not have to write libraryname_function()
03:58:47 <erus`> also constructors and destructors are nice
03:58:54 <erus`> for structs
03:58:56 <merijn> Right now I have function names taking up two-thirds of a 80 char line
03:59:01 <luite> Axman6: does it have debugging stuff like bounds checking and use after free checking?
03:59:26 <erus`> merijn: and lists and vectors yaddy yadda ya
04:00:02 <Axman6> not sure, but i think it's definitely being worked on. watch that video to find out more, it's very entertaining =)
04:00:27 <elliott> <merijn> Axman6: Does gcc implement C++ lambda's?
04:00:28 <elliott> yes
04:00:51 <paul424> What is the name of such higher order function similar to map : map f list IS ( ( f elem1) ( f elem2 ) .... (f elemn)) and foobar would be : (f elem1)@( f elem2)@.....(f elemn). Where @ is concatenection of 2 lists ?
04:01:14 <elliott> paul424: Your question doesn't make much sense. Is the context Haskell?
04:01:21 <elliott> If so, the operator to concatenate lists is ++, not @.
04:01:59 <Axman6> paul424: concatMap? your question in very unclear and doesn't use haskell syntax
04:01:59 <drdo> I think he wants concatMap
04:02:04 <paul424> ahh so substitute ++ in above quest
04:02:07 <Axman6> :t concatMap
04:02:08 <lambdabot> forall a b. (a -> [b]) -> [a] -> [b]
04:02:53 <Axman6> paul424: concatMap also happens to be the definition og >>= for lists. meaning you can use the list monad if you need to chain many of those computations together
04:03:27 <paul424> ok / its not haskell oriented question anyway :)
04:03:46 <erus`> what is >> in the list monad?
04:03:56 <erus`> > [1,2] >> [3.4]
04:03:57 <lambdabot>   [3.4,3.4]
04:04:44 <ion> > [1,2] >>= \_ -> [3,4]
04:04:45 <lambdabot>   [3,4,3,4]
04:04:52 <ion> > concatMap (\_ -> [3,4]) [1,2]
04:04:53 <lambdabot>   [3,4,3,4]
04:05:08 <Axman6> it's just xs >> ys = concatMap (\_ -> ys) xs
04:05:27 <erus`> > [1,2] >> [3,4]/join #vim
04:05:28 <lambdabot>   Not in scope: `vim'Not in scope: `#'
04:05:35 <erus`> whoops
04:05:50 <elliott> paul424: strange to ask non-haskell-oriented questions in #haskell
04:05:57 <ion> Subliminal messages in Haskell code!
04:07:17 <ion> > [1,2] *> [3{- Drink Coca-Cola‚Ñ¢ #-},4]
04:07:18 <lambdabot>   [3,4,3,4]
04:19:06 * hackagebot Holumbus-Searchengine 1.2.0 - A search and indexing engine.  http://hackage.haskell.org/package/Holumbus-Searchengine-1.2.0 (UweSchmidt)
04:26:13 <mjga> since most packages seem to work for GHC 7.4 oh-kay, why can't we have a topic GHC 7.4?
04:27:09 <mjga> BTW anybody knows why holumbus seems to have better coverage among libraries than hoogle?
04:29:06 * hackagebot cabal-src 0.2.0.1 - Alternative install procedure to avoid the diamond dependency issue.  http://hackage.haskell.org/package/cabal-src-0.2.0.1 (MichaelSnoyman)
04:31:20 <Axman6> is there any good reason Set shouldn't be a monad?
04:32:14 <rostayob> Axman6: the Ord constraint
04:32:32 <rostayob> also
04:32:38 <rostayob> I'm not sure how you'd define that instance
04:33:03 <hpaste> SmartViking pasted ‚Äúzip'‚Äù at http://hpaste.org/63687
04:33:09 <Axman6> well, there's a pretty obvious toList/fromList version, but i see why Ord would break things
04:33:28 <SmartViking> Can someone tell be what I'm doing wrong?
04:33:36 <rostayob> Axman6: not break, it makes impossible to write that instance with the current type class.
04:33:47 <rostayob> with ConstraintKinds you can hack your way around those things
04:33:47 <Axman6> yeah, that's what i meant
04:33:50 <mux> SmartViking: you don't handle the base case of your recursion
04:34:02 <rostayob> Axman6: http://hackage.haskell.org/packages/archive/rmonad/0.6/doc/html/Control-RMonad.html
04:34:08 * hackagebot shakespeare-i18n 0.0.2 - A type-based approach to internationalization.  http://hackage.haskell.org/package/shakespeare-i18n-0.0.2 (MichaelSnoyman)
04:34:18 <rostayob> oh. that's not even with ConstraintKinds.
04:34:31 <statusfailed> Do I need an instance of Category for my type if I want it to be Arrow?
04:34:45 <SmartViking> mux: What does that mean?
04:34:53 <rostayob> Axman6: well but a set is different from a list, unless you do toList/fromList on bind, which would be stupid.
04:35:00 <ion> statusfailed: See :i Arrow in ghci.
04:35:22 <mux> SmartViking: you need to handle any of the two lists to be null in zip', because you recursive call will end up passing an empty list at some point
04:36:04 <ion> statusfailed: The constraint in the class definition means you do.
04:36:04 <mux> SmartViking: your tests for null xs and null ys are bogus and useless, too
04:36:06 <rostayob> Axman6: I'm not sure the monad laws would be respected with "union" instead of "++"
04:36:30 <statusfailed> ion: whoops, missed that. cheers
04:36:39 <mux> SmartViking: why would you stop zipping elements when you have an x and a y but nothing further in the list? you still want to zip x and y
04:36:40 <SmartViking> mux: Ah, I thought the then [] would take care of that. Why does it not?
04:37:17 <mux> SmartViking: you _return_ [] but you never check for the lists being empty or not, you always expect them to have a at least an element
04:37:24 <mux> SmartViking: due to the (x:xs) and (y:ys) pattern
04:37:36 <rostayob> Axman6: from a semantics perspective, it probably would mhm
04:37:37 <yitz> @src zip
04:37:37 <lambdabot> zip (a:as) (b:bs) = (a,b) : zip as bs
04:37:38 <lambdabot> zip _      _      = []
04:37:51 <ion> http://hpaste.org/50278 Functor, Applicative and Monad instances for Data.Set
04:38:31 <SmartViking> mux: Thanks for the help!
04:38:34 <rostayob> ion: yes, but that's doing toList/fromList on bind as I said
04:41:12 <rostayob> ion: also, that Eq and Ord instance is hacky :P
04:42:29 <ion> rostayob: The entire paste is a joke. The instances will result in utterly broken Sets. :-P
04:42:45 <ion> Which is naturally documented as ‚Äúthe precondition is not checked‚Äù.
04:43:05 <rostayob> ion: ehe
04:45:09 <ion> Inspired by the documentation of functions like http://hackage.haskell.org/packages/archive/containers/latest/doc/html/Data-Set.html#v:mapMonotonic
04:46:31 <quicksilver> mapMonotonic could actually check that precondition without changing its asymptotics, I believe
04:46:42 <quicksilver> assuming < is O(1)
04:46:57 <mauke> which it ain't for [a]
04:47:10 <quicksilver> mauke: not quite that simple
04:47:31 <quicksilver> mauke: < for [a] is stil O(1) relative to the size of the set, if the lists you're taking Sets of have bounded size
04:47:39 <quicksilver> (or satisfy some other natural condition)
04:47:43 <NihilistDandy> Broken Set Theory sounds like PhD level recreational mathematics :D
04:49:07 * hackagebot Hayoo 1.2.0 - The Hayoo! search engine for Haskell API search on hackage  http://hackage.haskell.org/package/Hayoo-1.2.0 (UweSchmidt)
04:55:45 <kstt> hackage is back ! topic can be updated :)
04:56:15 --- mode: ChanServ set +o mauke
04:56:15 --- topic: set to '["Haskell Platform 2011.4: http://bit.ly/Clv5r","GHC 7.2 and cabal-install: http://is.gd/LXRBhh (all archs not just mac)","Paste code/errors: http://hpaste.org/new/haskell","GHC 7.2.1: http://is.gd/IU2lRI","Haskell News: http://reddit.com/r/haskell","The Haskell programming language http://haskell.org","Logs: http://bit.ly/5mwtRQ","admin/spam issues: #haskell-ops"]' by mauke
04:56:49 --- topic: set to '["Haskell Platform 2011.4: http://bit.ly/Clv5r ","GHC 7.2 and cabal-install: http://is.gd/LXRBhh (all archs not just mac)","Paste code/errors: http://hpaste.org/new/haskell ","GHC 7.2.1: http://is.gd/IU2lRI ","Haskell News: http://reddit.com/r/haskell ","The Haskell programming language http://haskell.org ","Logs: http://bit.ly/5mwtRQ ","admin/spam issues: #haskell-ops"]' by mauke
04:58:50 --- mode: mauke set -o mauke
04:59:08 * hackagebot hstzaar 0.9 - A two player abstract strategy game.  http://hackage.haskell.org/package/hstzaar-0.9 (PedroVasconcelos)
04:59:25 <mux> Lemmih: ping
05:04:07 * hackagebot hashmap 1.3.0.1 - Persistent containers Map and Set based on hashing.  http://hackage.haskell.org/package/hashmap-1.3.0.1 (MilanStraka)
05:19:06 <erus`> is there a staticly typed stack language like forth, factor, joy etc?
05:19:45 <eddayyy> erus`: lookup cat
05:20:51 <erus`> this is exactly the idea i had in my head :|
05:21:00 <erus`> does it support type classes et all?
05:25:25 <hmax> hi
05:26:08 <hmax> guys, what's the best library for generating yaml?
05:32:10 <portnov> data-object-yaml ?
05:34:05 <hmax> This package is officially deprecated, says hackage
05:36:08 <portnov> then yaml.
05:40:26 <nibalizer> arsitenaoierstnc
05:40:28 <jeff_s_> I wrote what I think would be a good little function to have in Data.Maybe. Is this something I should use the Haskell Prime trac system to suggest?
05:40:36 <nibalizer> sorry
05:41:16 <elliott> jeff_s_: what function?
05:41:16 <jeff_s_> It's not really a language extension... so I'm not sure.
05:41:21 <elliott> it would go to libraries@
05:41:27 <hpaste> ‚ÄúJeff Shaw‚Äù pasted ‚ÄúmaybeTo‚Äù at http://hpaste.org/63688
05:41:42 <mdxbhmt> hey is there any easy to use haskell library to manipulate images? (opening gifs, croping, saving raw data, etc)
05:41:44 <jeff_s_> I find myself wanting to use this a lot.
05:42:18 <mm_freak_> makes more sense than maybeToList
05:42:29 <jeff_s_> mm_freak - that's exactly what I thought! :D
05:42:43 <mm_freak_> i'd probably write that in terms of Alternative, though
05:42:58 <quicksilver> maybe mzero return is certainly something you see from time to time
05:43:07 <quicksilver> it is an idiom of sorts.
05:43:10 <mm_freak_> MonadPlus is ugly for the same reason as liftM
05:43:49 <quicksilver> well, one problem with MonadPlus is that we don't know what axioms it should have
05:43:55 <quicksilver> there are at least two possibilities.
05:44:20 <quicksilver> however, this little trick is independent of the definition of 'mplus' anyway.
05:44:26 <jeff_s_> Does Alternative have Monad as a special case?
05:44:38 <jeff_s_> I'm wondering if it would end up workign the same. I don't have experience using Alternative.
05:45:19 <jeff_s_> quicksilver - oh ok, never mind then
05:45:53 <Axman6> mdxbhmt: yes, take a look at the devil package i think
05:46:26 <mdxbhmt> Axman6: thank you
05:47:35 <ion> @check \xs -> Data.Foldable.asum xs == Data.Foldable.msum xs `const` (xs :: [[Integer]])
05:47:37 <lambdabot>   "OK, passed 500 tests."
05:47:43 <ion> @check \xs -> Data.Foldable.asum xs == Data.Foldable.msum xs `const` (xs :: [Maybe Integer])
05:47:44 <lambdabot>   "OK, passed 500 tests."
05:53:32 <mm_freak_> jeff_s_: technically they are unrelated, mathematically MonadPlus is the ugly brother of Alternative
05:54:09 * hackagebot hackage-db 1.3 - provide access to the Hackage database via Data.Map  http://hackage.haskell.org/package/hackage-db-1.3 (PeterSimons)
05:54:28 <ion> Alternative is hot.
05:54:48 <timemage> heh
05:55:18 <jeff_s_> I already posted my MonadPlus version to the libraries mailing list. I'd like to see the Alternative (pun intended) implemention.
05:58:38 <mm_freak_> jeff_s_: same with (<|>) and empty instead of mplus and mzero, respectively
05:59:11 <mm_freak_> technically Alternative is equivalent to MonadPlus expect that it is a subclass of Applicative instead of Monad
05:59:49 <yitz> anyone know how to build text-icu on mac os x?
06:00:01 <jeff_s_> So maybe there needs to be two functions? maybeToMonadPlus and maybeToAlternative, or something like that. The names are a bit ugly.
06:00:21 <yitz> it says it can't find icui18n, icudata, or icuuc
06:02:05 <yitz> the cabal file has slightly different external C library deps for windows, but no special instructions for mac os x.
06:02:57 <erus`> that feel when someone stole your idea in the past :(
06:03:44 <erus`> maybe i can write a cat implementation
06:03:59 <yitz> erus`: think of it as having emulated giants
06:05:03 <uniquenick> what is the "haskelly" way to do this?  I want a way to sort of, tag some functions, so that later I can do something with them, like list all the functions tagged with "foo"
06:06:02 <byorgey> uniquenick: do they all have the same type?
06:06:15 <uniquenick> should I be using something like template haskell to turn pseudo-tags into calls to register the functions in a list?
06:06:22 <uniquenick> unfortunately, no they won't
06:07:25 <byorgey> uniquenick: what exactly are you trying to accomplish?
06:07:42 <byorgey> you can't put things of different types in a list.
06:07:49 <byorgey> do you mean you just want their *names* in a list?
06:07:53 <uniquenick> yeah
06:07:56 <byorgey> ah, ok
06:08:58 <luite> is it possible to force that some top-level expression has a monomorphic type, with plain haskell or th?
06:10:02 <byorgey> uniquenick: honestly I think you'd be best off writing some sort of external program to look at your source code, notice which functions have been tagged (e.g. with some kind of special comment?) and dump the list into a file which you can later inspect
06:10:11 <byorgey> assuming I have understood what you want to do.
06:10:38 <ChristianS> luite: add a type signature?
06:10:44 <byorgey> luite: not generically
06:11:43 <luite> ChristianS: yes, that solves it for a single expr, but I want compilation to fail if the inferred type is polymorphic
06:14:33 <luite> ChristianS: more specifically, I have some template haskell thing that gets an action (Monad m => m a), but it's only valid if it's monomorphic
06:15:54 <koeien3> I'd guess TH gets run before the typechecking phase
06:16:01 <koeien3> you could use the GHC API perhaps
06:22:29 <George> hello
06:23:11 <George> what is Haskell
06:23:17 <George> what is Haskell's native sorting algorithm*
06:23:25 <portnov> :D
06:23:27 <sclv> sort is a mergesort
06:23:35 <sclv> but its not "native" just in a core library
06:23:55 <George> is it an in-place mergesort?
06:23:59 <koeien3> no
06:24:15 <int-e> no, there's no in-place modification with immutable data
06:24:23 <George> ahh right....
06:24:36 <George> referential transparency and all that
06:24:54 <sclv> http://www.haskell.org/ghc/docs/latest/html/libraries/base-4.5.0.0/src/Data-List.html#sort
06:25:16 <sclv> you can always find the source by going to the online libraries, finding the function you want, and clicking the "Source" link
06:25:24 <portnov> one could of course write
06:25:25 <portnov> sort :: Ptr Int -> IO ()
06:25:25 <portnov> sort ptr = ... peek ptr ... poke ptr ...
06:25:34 <portnov> but it would be a bit...
06:25:36 <portnov> C'ish :)
06:25:58 <mux> also lacks a size parameter, otherwise it's pretty much useless
06:26:00 <koeien3> oh sure, you can use STArray and stuff
06:26:13 <koeien3> if you really need it
06:26:16 <mux> and it would be better to use mutable arrays in that case
06:26:25 <mux> STArray or IOArray or MVector...
06:26:36 <sclv> I forgot the special tweaks in sort that let it handle runs much more cleverly.
06:27:10 <George> I thought Haskell would use one of those faster parallel sorting algorithms
06:27:20 <sclv> the core libs aren't parallel
06:27:25 <George> right
06:27:26 <sclv> though they provide parallelism
06:27:46 <sclv> also parallel sorting isn't necessarily faster -- especially on plain old lists
06:29:11 * hackagebot ChasingBottoms 1.3.0.3 - For testing partial and infinite values.  http://hackage.haskell.org/package/ChasingBottoms-1.3.0.3 (NilsAndersDanielsson)
06:30:06 <sclv> at least for now, I also tend to prefer that my core functions are single-threaded unless I otherwise specify.
06:30:44 <sclv> otherwise it makes it hard to reason about performance when you start composing them into blocks which you run parallel at some higher level.
06:31:22 <sclv> i.e. if i use a super-awesome parallel sort that pegs all my processors at 100%, then that's maybe not such a good idea if i actually have other threads handling other requests as well :-)
06:32:32 <hpc> sclv: heh, i had a discussion about that with my boss yesterday
06:33:02 <hpc> etsy published their results of resizing a hundred-odd million images at once with some whizbang multithreaded graphicsmagick code
06:33:10 <hpc> my boss says "why didn't they just fork it?"
06:34:54 <sclv> @hpc: links plz?
06:34:54 <lambdabot> Unknown command, try @list
06:35:19 <sclv> hah, getting my s/ospeak and my irspeak mixed up
06:35:54 <hpc> uh
06:36:48 <sclv> ah, found it.
06:36:48 <hpc> sclv: http://codeascraft.etsy.com/2010/07/09/batch-processing-millions-of-images/
06:36:51 <hpc> ah
06:42:13 <Matobet> @pl \url -> (url ++) <$> getRandomString
06:42:13 <lambdabot> (<$> getRandomString) . (++)
06:49:09 <George> A language like C is great for embedded and systems programming (I've heard), and a language like Java or Javascript is great for web programming. What's Haskell's killer app or niche?
06:49:25 <koeien3> no, JavaScript and Java are not great for web programming
06:49:36 <hpc> George: refactoring facebook's crappy PHP code ;)
06:49:46 <qpu> hpc: looks like they compared threads to child processes and found highest throughput with 2 threads and 15 child processes
06:50:03 <koeien3> http://cdsmith.wordpress.com/2011/03/13/haskells-niche-hard-problems/
06:50:14 <hpc> George: more seriously, it's a general-purpose language that is very good at hard problems
06:50:17 <hpc> and i got ninja'd :P
06:50:29 <George> nice
06:50:36 <erus`> javascript is webscale
06:50:42 <ion> george: http://yow.eventer.com/events/1004/talks/1055
06:51:03 <erus`> haskell requires a phd in thermonuclear category physics
06:52:36 <George> I probably would never deal with a language like Haskell as a computer engineering student, or even in a typical work environment. Why am I interested in it?
06:52:51 <ion> Because of subliminal advertising.
06:54:44 <ion> Learning Haskell will certainly make you a better programmer in whichever languages you‚Äôll end up actually using. Just like learning any new language, especially one that‚Äôs very different from what you already know.
06:54:45 <George> I like how it supports (perhaps enforces) a declarative style of programming
06:56:24 <erus`> I wish the types were a little stronger
06:58:39 <qpu> which way does the motto read: (avoid) (success at all costs) or (avoid success) (at all costs)?
06:58:55 <uniquenick> both?
06:59:13 <koeien3> the latter
06:59:34 <hpc> qpu: they wanted haskell to be unsuccessful because "success" (read, popularity) creates a lot of inertia
07:00:05 <hpc> eventually you start picking up enough code that depends on bugs that you are stuck in perlville
07:01:06 <qpu> java is pretty bad that way too
07:01:40 <ion> I for one didn‚Äôt have a good grasp on how to separate IO stuff from pure stuff before i learned Haskell even though i knew that would be a very good thing to do. That‚Äôs probably the most significant way learning Haskell made me a better programmer in any language.
07:02:29 <hpc> ion: it gives that separation a name
07:02:58 <hpc> once IO clicked in my mind, i was stunned by how obvious the concept was
07:03:04 <ion> yeah
07:03:27 * roconnor__ finds nothing obvious about bind
07:03:54 <koeien3> yes. and immutability
07:04:03 <hpc> roconnor: i don't see the problem, it's just mappend in the category of endofunctors!
07:04:09 <koeien3> of course I still use mutable data structures sometimes in C
07:04:13 <roconnor> hpc: *lol*
07:04:16 <koeien3> but the advantages are obvious
07:04:48 <George> so Haskell is a great language to write compilers in?
07:04:56 <koeien3> among others
07:05:01 <roconnor> In haskell I make my code thread-safe, even thought I don't use threads.
07:05:08 <mekeor> George: what is haskell not great for? =)
07:05:15 <hpc> the first perl6 interpreter was written in haskell
07:05:27 <hpc> that's right folks, perl is so complicated not even PERL can run it anymore
07:05:48 <mdxbhmt_> but haskell can run haskell?
07:05:55 <koeien3> GHC is written in Haskell
07:06:13 <mekeor> gcc is written in c
07:06:14 <George> I don't know what Haskell isn't good for :( Perhaps for programming real-time systems, embedded applications, operating systems, etc?
07:06:15 <roconnor> koeien3: how does GHC implement putChar?
07:06:24 <koeien3> roconnor: it's turtles all the way down!
07:06:34 <hpc> koeien3: i think that reasoning in terms of the immutable algorithm helps you notice when to use mutation in other languages
07:06:37 <hpc> and when to use copying
07:06:42 <koeien3> hpc: yes
07:06:58 <koeien3> hpc: advantages of immutability are clearer now
07:06:59 <hpc> instead of "crap, i need a copy", it's "hey, this change doesn't break things"
07:07:06 <koeien3> also strong typing
07:07:17 <roconnor> George: possibly any place where a garbage collector isn't good.
07:07:19 <mdxbhmt_> strong typing is wonderfull
07:07:50 <roconnor> Though now-a-days it feels like embedded systems are not all that constrained anymore.
07:08:12 <hpc> roconnor: no, it still is
07:08:13 <roconnor> they *only* have 4GB of memory
07:08:15 <qpu> George: yep, real-time doesn't work well with garbage collection. but there are haskell libraries that generate code (VHDL, C, etc) for you for that purpose
07:08:17 <mdxbhmt_> C would be wonderfull if he had how to chose between safe/unsafe type conversions
07:08:18 <hpc> roconnor: phones just left the "embedded" category
07:08:25 <roconnor> hpc: oh, okay
07:08:30 <ion> roconnor: GHC implements putChar by taking a universe and returning a version of the universe where the side effect has happened.
07:08:39 <hpc> George: haskell is used at high frequency trading firms
07:08:46 <hpc> so it has at least some use in real-time processing
07:08:48 <roconnor> ion: how does GHC implement forever?
07:08:56 <Axman6> soft real-time anyway
07:09:05 <hpc> indeed
07:09:15 <roconnor> hpc: perhaps in that case correctness trumps speed
07:09:23 <Axman6> for hard real-time, you want Ada
07:09:24 <hpc> you won't see haskell powering $100,000 cisco routers anytime soon, of course :P
07:09:58 <roconnor> hpc: making incorrect HFTs is possibly much worse than not trading at all.
07:10:11 <roconnor> I'm just speculating here
07:10:21 <hpc> roconnor: indeed, though speed can have an effect on how correct your information is
07:10:28 <uniquenick> cisco demands the non-blocking, event driven, async, webscale, distributed, nosql, web 3.0 features of javascript
07:10:45 <mdxbhmt_> The network latency>> haskell latency ?
07:10:46 <ChristianS> hpc: i think you have confused haskell with ocaml: http://www.janestreet.com/technology/ocaml.php
07:10:57 <Axman6> roconnor: i don't know much abouty how things worked in the trader at tsuru, but i know that the loop that cancels bad orders runs about 10 times more often than the one making orders, for that reason :P
07:11:00 <portnov> Are there any chances to get some version of cabal-install working with GHC 7.4.1 ?
07:11:21 <hpc> ChristianS: i know about jane street, but haskell does see use too
07:11:22 <roconnor> Axman6: hah
07:11:31 <hpc> ...i think
07:11:31 <luite> hpc: why not?
07:11:34 <Lemmih> mux: pong.
07:11:50 <hpc> yeah, allston trading
07:11:52 <hpc> http://www.haskell.org/haskellwiki/Haskell_in_industry
07:11:53 <roconnor> hpc: yep, see tsuru's use of starling's trading software.
07:11:53 <Axman6> ChristianS: see Tsuru capital. I was an intern there last summer\
07:12:11 <Axman6> afaict, starling basically became tsuru
07:12:12 <hpc> also that
07:12:12 <ChristianS> hpc, Axman6: ah, ok
07:12:18 <ChristianS> good to know
07:12:27 <Axman6> there are also other HFT companies using haskell
07:12:42 <roconnor> Axman6: how was it there?  I was vaguely trying to give me a job working from Canada, but it never panned out.
07:12:43 <Axman6> Tsuru might be unique in that it used haskell almost exclusively
07:12:51 <hpc> in other news, there's something undeniably hilarious about "ocaml.php"
07:12:54 <luite> hpc: perhaps not cisco, but many routers run something else, bsd kernel or something
07:12:56 <mux> Lemmih: I was interested in GHC.Generics after having written a small Bencode parser, so I wrote a generic interface for it; then I saw you have a bencode package up on haskell, so I thought this might interest you: http://code.mumux.org/bencode
07:13:04 <ion> hpc: :-D
07:13:16 <Axman6> roconnor: it was good fun, the guys who work there are awesome.
07:13:28 <roconnor> nice
07:14:19 <Axman6> learnt a lot of cool stuff (mainly iteratees and monad transformers, both of which i'd been scared of before finding out how nice they were there)
07:14:34 <hpc> transformers aren't exactly nice
07:14:38 <luite> hpc: (Junos runs on FreeBSD)
07:14:39 <hpc> but they aren't scary either ;)
07:14:46 <roconnor> ah; I haven't figured out iteratees yet.
07:14:59 <hpc> the iteratee library bamboozles me
07:15:06 <hpc> i don't even know where in the docs to start
07:15:13 <roconnor> Sometimes I think that Oleg makes unnecessary use of continuations in Haskell when laziness would suffice.
07:15:19 <koeien3> and now there are "conduits" and other things
07:15:24 <koeien3> i don't even know what to use anymore
07:15:35 <hpc> koeien3: i just use IO ;)
07:15:39 <luite> conduits are a bit simpler
07:15:39 <Axman6> roconnor: i think i'd recommend conduits over any of the 'iteratee' libraries. it's much simpler, and has much clearer names
07:15:40 <roconnor> koeien3: screw it, use MArray.
07:15:50 <Axman6> (sources, sinks and sonduits to pipe them together)
07:15:53 <Axman6> c*
07:15:54 <luite> Sink/Source/Conduit are at least sensible names :)
07:15:57 <ion> Screw it, use C via the FFI.
07:16:04 * roconnor <3 sonduits
07:16:05 <erus`> someone should make a tutorial implementing all corners of the lambda cube
07:16:15 <mux> the newest Pipe API is even cuter, name-wise
07:16:20 <ion> erus: And the time cube.
07:16:31 <ion> The newest Pipe API?
07:16:38 <George> Was Try Haskell written in Haskell?
07:16:42 <erus`> isnt the time cube that crazy website?
07:16:42 <luite> haven't looked at pipe yet, only enumerator and conduit, mostly for yesod development
07:16:51 <luite> George: yes, the source code is available
07:16:55 <Axman6> George: yes
07:16:57 <ion> @hackage pipe
07:16:58 <lambdabot> http://hackage.haskell.org/package/pipe
07:17:10 <Axman6> one of the nicest things to come out of Conduits is ResourceT, which takes a huge burden off the programmer in applications where you need to manage scarce resources
07:17:23 <luite> George: https://github.com/chrisdone/tryhaskell
07:17:26 <mux> ion: not this one, this one: http://hackage.haskell.org/package/pipes
07:17:36 <mekeor> lambdabot: that's a dead link.
07:17:52 <Axman6> @hackage idon'texist
07:17:52 <lambdabot> http://hackage.haskell.org/package/idon'texist
07:17:54 <bgamari> Is there any reason not to disentangle the Cabal and Hackage trac instances?
07:17:54 <ion> mux: Thanks
07:18:02 <mekeor> Axman6: ah, okay
07:18:10 <mux> mekeor: looks like lambdabot lowercased the url, it works if you have a capital P
07:18:15 <mux> oh
07:18:22 <mux> nevermind :)
07:18:32 <Axman6>  @hackage is literally just ("http://hackage.haskell.org/package/"++) i think
07:18:47 <Axman6> @hackage a package with spaces
07:18:47 <lambdabot> http://hackage.haskell.org/package/a package with spaces
07:18:50 <hpc> @hackage is literally just ("http://hackage.haskell.org/package/"++) i think
07:18:50 <lambdabot> http://hackage.haskell.org/package/is literally just ("http://hackage.haskell.org/package/"++) i think
07:18:55 <hpc> yep :P
07:19:04 <roconnor> erus`: Jacobs trashes the lambdacube in "On Cubism". J. Funct. Program. 6(3): 379-391 (1996)
07:19:04 <luite> George: oh it looks like that repository doesn't actually contain the code that runs haskell, but t must be in one of the other repositories
07:19:04 <mux> it doesn't even urlencode stuff :-P
07:19:19 <George> :(
07:19:38 <dcoutts> bgamari: yes, there are quite a few cross-cutting issues
07:19:44 <Axman6> luite: doesn't it just use mueval?
07:19:46 <George> George:
07:19:48 <roconnor> luite: is this a new form of super simon bros.
07:19:54 <dcoutts> bgamari: it's mainly for that reason I think it makes sense to keep them together
07:20:07 <dcoutts> bgamari: similarly, sharing the cabal-devel mailing list
07:20:21 <roconnor> *your princess is in another castle*
07:20:33 <luite> Axman6: no it uses a patched version that keeps running. starting a new mueval process for every request is rather expensive
07:20:52 <Axman6> ah, well, same thing
07:21:27 <bgamari> dcoutts: Alright, fair enough.
07:21:56 <dcoutts> bgamari: the biggest area of overlap is between hackage-server and cabal-install client
07:21:56 <bgamari> dcoutts: Perhaps there should be a hackage-server 2 component in the Trac's issue tracker?
07:22:09 <dcoutts> bgamari: yes, now would be a fine time to start that
07:22:15 <bgamari> dcoutts: Make a clean break with the hackageDB-website component
07:22:49 <bgamari> Unless we think there's a better place to track issues
07:23:07 <bgamari> I'm open to anything; although I think a dedicated issue tracker is better than the wiki
07:23:10 <dcoutts> bgamari: right. As I mentioned, previously the development was not in the phase where an bug tracker is best used, but we're probably past that stage now.
07:23:11 <drdo> What's the difference between MonadPlus and Alternative?
07:23:38 <dcoutts> bgamari: I'll make a hackage-2 component
07:23:40 <ion> Much like the difference between return and pure, i understand.
07:23:52 <bgamari> dcoutts: Thanks
07:24:04 <dcoutts> bgamari: ah, the server is back up, that's good
07:24:08 <drdo> ion: Meaning an accident of history?
07:24:50 <roconnor> drdo: MonadPlus implies a Monad constraint while Alternative does not.
07:25:08 <dcoutts> bgamari: btw, you know about the #hackage channel?
07:25:11 <mux> Alternative implies a Functor constraint though, I suppose
07:25:14 <bgamari> dcoutts: Ahh, nope
07:25:15 <drdo> roconnor: I'm obviously not asking about it in such a literal manner
07:25:18 <bgamari> Now I do
07:25:48 <drdo> Since Monad should have an Applicative constraint
07:26:12 <roconnor> drdo: well, it isn't so much an accident of history.  MonadPlus can be seen as the union of Alternative and Monad over Applicative.
07:28:27 <drdo> roconnor: Is there any situation where mzero and mplus wouldn't reasonably be exactly the same as empty and (<|>) respectively?
07:28:41 <zachk> alright, I have haskell-mode for emacs working, but the handy keybindings like c-c c-= don't work, any ideas?
07:29:05 <roconnor> drdo: If bind doesn't exist, then neither will mzero and mplus exist.
07:29:43 <roconnor> drdo: if mzero and mplus exist then they ought to be equivalent to empty and <|>
07:29:54 <Taneb> Hello!
07:29:59 <koeien3> hi Taneb
07:31:15 <roconnor> drdo: ah but yes, it is an accedient of history that MonadPlus isn't simply defined as class (Monad m, Alternative m) => MonadPlus m where {- no methods -}
07:31:24 <roconnor> drdo: I see what you are getting at now.
07:31:45 <drdo> roconnor: Ah, so that's what i thought
07:31:58 <roconnor> drdo: sorry I didn't catch on earlier
07:32:27 <hpc> roconnor: or with constraint kinds, MonadPlus would be more straightforwardly defined and not require empty instances
07:32:40 <roconnor> such a class would have been a less trivial than it appears since it implies some (undocumented) laws.
07:33:09 <roconnor> I do something similar with KleeneAlgebra in http://r6.ca/blog/20110808T035622Z.html
07:33:24 <roconnor> KleeneAlgebra adds no methods to StarSemiring, but it does add 3 laws.
07:33:26 <hpc> roconnor: does it imply new laws, or does it just give a name to the relationship between Alternative and Monad?
07:33:48 <roconnor> hpc: there should be some bind - <|> laws
07:34:06 <drdo> From what i'm reading there are two implicit laws relating mzero and mplus to bind
07:34:07 <roconnor> hpc: I don't know if they would be implied by the other laws. I doubt it.
07:34:14 <hpc> so it would be like the old pure/fmap law, kinda
07:34:21 <hpc> before it was proved to be a free theorem
07:34:28 <roconnor> ya
07:34:31 <hpc> groovy
07:34:35 <roconnor> but I don't think we can prove it is a theorem in this case.
07:34:45 <roconnor> fmap is very special
07:34:46 <hpc> (er, Pointed pure)
07:34:58 <hpc> indeed
07:35:51 <hpc> roconnor: sounds like proving those laws would be a good puzzle to pass along to #agda
07:38:22 <hpc> it looks like the MonadPlus laws aren't 100% decided on
07:38:50 <quicksilver> well there are at least two "natural" possibilities
07:38:57 <quicksilver> the "or-else" type and the "additive" type
07:39:19 <koeien3> "or-else" is "absorbing"?
07:39:28 <quicksilver> IO's exception-hiding mplus is an example of the first and []'s non-deterministic is an example of the latter
07:39:44 <quicksilver> there used to be a wiki page speculating on equational theories for these
07:40:33 <quicksilver> here's a thread about it but I can't find the wiki page http://www.haskell.org/pipermail/haskell-cafe/2008-May/042644.html
07:41:45 <quicksilver> oh here we are http://www.haskell.org/haskellwiki/MonadPlus
07:42:11 <koeien3> then we might need two separate classes
07:42:45 <hpc> it looks like the alternative laws can be expressed in terms of bind/return
07:42:57 <quicksilver> yes indeed, see http://www.haskell.org/haskellwiki/MonadPlus_reform_proposal
07:42:58 * hpc brb
07:44:14 * hackagebot nixos-types 1.4 - this package is obsolete; see cabal2nix instead  http://hackage.haskell.org/package/nixos-types-1.4 (PeterSimons)
07:51:17 <drdo> Is there a name for this sort of composition? \f g h x ‚Üí g x `f` h x
07:51:55 <Palmik> Hmm, I found this old paste and worder how the issue got resolved (as I am facing the similar problem) http://hpaste.org/8841
07:52:01 <c_wraith> drdo: liftA2?
07:52:13 <koeien3> drdo: on, I think.
07:52:16 <koeien3> :t on
07:52:17 <lambdabot> forall b c a. (b -> b -> c) -> (a -> b) -> a -> a -> c
07:52:20 <koeien3> @src on
07:52:20 <lambdabot> (*) `on` f = \x y -> f x * f y
07:52:31 <c_wraith> on takes different args for the same function
07:52:40 <koeien3> ah, right.
07:52:42 <c_wraith> liftA2 takes different functions for the same arg
07:52:43 <koeien3> i just saw the pattern
07:53:11 <c_wraith> > liftA2 (*) (+1) (+2) 1
07:53:12 <lambdabot>   6
07:53:45 <hpc> :t uncurry .: (***)
07:53:46 <lambdabot>     Couldn't match expected type `b -> c'
07:53:46 <lambdabot>            against inferred type `(c1, c')'
07:53:46 <lambdabot>     Probable cause: `***' is applied to too many arguments
07:54:14 * hackagebot cabal2nix 1.26 - Convert Cabal files into Nix build instructions  http://hackage.haskell.org/package/cabal2nix-1.26 (PeterSimons)
07:56:42 <drdo> thanks
08:03:25 <Cale> http://hackage.haskell.org/package/sodium <-- Stephen Blackheath (who is working with us at iPwn) has released his own FRP system. It's different from the one we've been using internally at iPwn, but I thought I'd advertise it here anyhow :)
08:04:07 <quicksilver> Cale: why are there *so* many different approaches to FRP? :)
08:05:48 <Cale> quicksilver: The same could be asked about most general approaches to program design.
08:06:06 <hpc> @src (*>)
08:06:06 <lambdabot> (*>) = liftA2 (const id)
08:06:16 <hpc> :t (*>)
08:06:17 <lambdabot> forall (f :: * -> *) a b. (Applicative f) => f a -> f b -> f b
08:06:38 <Taneb> > [1,2,3] *> "abc"
08:06:39 <lambdabot>   "abcabcabc"
08:06:55 <Lp_Macau> what does the !! do? i can't remember
08:07:01 <Cale> Lp_Macau: list indexing
08:07:02 <koeien3> Lp_Macau: takes the n-th element of the list
08:07:09 <koeien3> > [1..10] !! 4
08:07:10 <lambdabot>   5
08:07:21 <Lp_Macau> oh, thanks!
08:07:21 <quicksilver> Cale: well, yes and no.
08:07:25 <yitz> dcoutts: any idea why text-icu can't find the icu libraries on mac os x? or might know?
08:07:29 <koeien3> using (!!) is often a mistake though
08:07:34 <Cale> quicksilver: Why are there so many approaches to OO?
08:07:56 <quicksilver> Cale: it really seems like FRP is like a bag of cats, which really wants to go somewhere but can't work out where.
08:08:02 <Cale> hehe
08:08:03 <dcoutts> yitz: sorry
08:08:06 <rostayob> Cale: there is a dominant approach to OO
08:08:22 <quicksilver> Cale: because OO is broken by design, so people are continually inspired to try to unbreak it.
08:08:22 <Cale> rostayob: The dominant approach to OO isn't even the best one, imo.
08:08:30 <rostayob> Cale: still, there is a dominant one
08:08:37 <rostayob> the same can't be said about FRP
08:08:41 <Cale> Right, but OO has been around a long time
08:08:46 <rostayob> that's true
08:09:04 <rostayob> I mean OO in its infancy was pretty different
08:09:09 <rostayob> so we'll see what happens with FRP
08:09:18 <rostayob> FRP is already.. what 15 years old?
08:09:24 <rostayob> it's like 1990 for OO lets say
08:09:40 <Cale> We're starting to get FRP figured out
08:10:00 <Cale> There's a bunch of stuff we know internally at iPwn which we need to write a paper about
08:10:14 <Cale> (or possibly more than one paper)
08:10:38 <quicksilver> I'm pleased to see that Stephen's model closely follows some of Conal's
08:10:53 <quicksilver> I'm convinced that Conal has a nice model, even if it seems slippery to implement
08:11:09 <rostayob> I found the arrowised one much more intuitive, but that's me
08:11:37 <Cale> The arrowised approach gets better once you generalise and patch up the concept of arrows a bit
08:11:50 <quicksilver> which means "don't use arrows" :0
08:11:53 <Cale> heh
08:11:56 <quicksilver> but use something else, which is more useful for FRP.
08:12:02 <Cale> But use something very close to arrows.
08:12:08 <quicksilver> which is fine but let's call a spade a trowel
08:12:11 <Cale> hehe
08:12:28 <quicksilver> I wonder why stephen has all those Typeable constraints around
08:12:30 <Cale> Use monoidal 2-categories?
08:12:34 <quicksilver> they smell bad at first sniff
08:13:17 <hpc> in a proof, is the following transformation valid?
08:13:18 <hpc> 1 - mzero >>= f  =  mzero
08:13:24 <hpc> 2 - mzero >> m = mzero
08:13:32 <nsxt> Conal Elliott == irc elliott?
08:13:52 <rostayob> nsxt: no
08:13:56 <rostayob> nsxt: irc conal
08:14:30 <Cale> mzero >> m = mzero >>= const m -- by definition of (>>)
08:14:44 <Cale> mzero >>= const m = mzero -- by 1
08:15:23 <hpc> Cale: yeah, i mean, can i say that both of those would be the same law
08:15:32 <Cale> They're not quite the same law...
08:15:37 <Cale> But the first implies the second
08:16:05 <Cale> The second may actually imply the first, for a more subtle reason.
08:16:15 <hpc> that's what i was wondering
08:16:34 <Cale> (the fact that you can't computably tell that a function is a constant function)
08:16:35 <hpc> i feel like that subtle reason is parametricity or something along those lines
08:16:37 <Cale> yeah
08:16:40 <hpc> but i don't know enough to be sure
08:17:15 <Cale> It doesn't follow just from a straight "(>>=) and (>>) are mathematical functions" approach to things
08:17:27 <hpc> Cale: ill note that step to look at later, then
08:17:52 <hpc> im trying to find equivalences between MonadPlus and Alternative laws
08:18:19 <hpc> so far i have m *> empty = empty *> m = empty
08:18:56 <hpc> from the zero and absorbtion laws
08:19:02 <hpc> (however "absorbtion" is spelled)
08:19:29 <copumpkin> it has a P in it
08:19:37 <hpc> ty
08:19:44 <hpc> and the left catch is pure a <|> b = pure a
08:19:44 <copumpkin> apsorbtion, obviously
08:19:48 <quicksilver> absPorbtion
08:20:13 <Palmik> Hmm, I found this old paste and worder how the issue got resolved (as I am facing the similar problem) http://hpaste.org/8841 <-- does anyone have any ideas? :)
08:27:07 <zzo38> I have a preprocessor which expects include files in HAMPPPATH environment variable; how can I make a different package install stuff there.
08:28:05 <zzo38> ?
08:31:15 <CondT> anyone can explain functors better than wikipedia?
08:31:25 <CondT> is a functiona  mapping betweens sets?
08:31:35 <hpc> :t empty
08:31:36 <lambdabot>     Ambiguous occurrence `empty'
08:31:36 <lambdabot>     It could refer to either `Control.Applicative.empty', imported from Control.Applicative
08:31:37 <lambdabot>                           or `Text.Regex.Posix.empty', imported from Text.Regex.Posix at State/L.hs:55:0-22
08:31:41 <CondT> thus function specialcase of functor?
08:31:46 <hpc> :t Control.Applicative.empty
08:31:47 <lambdabot> forall (f :: * -> *) a. (Alternative f) => f a
08:31:57 <zzo38> CondT: A functor is a mapping between two categories. In Haskell, the Functor class is always an endofunctor, meaning from a category to itself, specifically the (->) category.
08:31:58 <portnov> :i Functor
08:32:05 <portnov> :/
08:32:15 <koeien3> CondT: a "functor" in Haskell is a "container" to which functions can be applied
08:32:16 <rwbarton> in math, you can think of a function as a special case of a functor, yes
08:32:25 <rwbarton> in Haskell, not so much
08:32:46 <ion> condt: I take it you‚Äôre familiar with ‚Äúmap‚Äù for lists?
08:33:05 <koeien3> CondT: or do you want to know the more general concept of a functor in category theory?
08:33:09 <zzo38> A functor is not always a container, although it might be. It allows a function to be applied such that the same composition laws apply.
08:33:11 <portnov> haskell functor is ¬´simply endofunctor in Hask category, what's the problem?¬ª ;)
08:33:22 <koeien3> portnov: :)
08:34:16 <zzo38> Best way to understand, is by the laws, and the example, and then how it applies in that way
08:34:43 <zzo38> All monads are endofunctors, too (although Haskell currently does not have Functor as a superclass of Monad)
08:34:45 <CondT> ion: yes and you can fmap Maybe
08:35:05 <CondT> and fmap all monads?
08:35:38 <koeien3> yes
08:35:42 <koeien3> also called liftM
08:36:13 <portnov> :t fmap
08:36:14 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
08:36:19 <portnov> :t liftM
08:36:20 <lambdabot> forall a1 r (m :: * -> *). (Monad m) => (a1 -> r) -> m a1 -> m r
08:36:45 <ion> condt: You might want to read the Typeclassopedia.
08:36:48 <ion> @where typeclassopedia
08:36:48 <lambdabot> http://www.haskell.org/haskellwiki/Typeclassopedia
08:37:13 <CondT> ty
08:37:37 <hpc> :t (const id <$>)
08:37:38 <lambdabot> forall a a1 (f :: * -> *). (Functor f) => f a1 -> f (a -> a)
08:38:01 <hpc> aha!
08:38:16 <zzo38> CondT: A monad is just an endofunctor with extra operations defined on them satisfying certain laws, so the Haskell "Functor" is an endofunctor it is just not as much as a monad
08:38:35 <ion> zzo38: You‚Äôre very helpful, thanks.
08:40:23 <zzo38> I have a preprocessor which expects include files in HAMPPPATH environment variable; how can I make a different package install stuff there?
08:41:33 <asante> whats wrong in the following line?
08:41:36 <asante> handle (const (return [])) $ do {return ["foo"]}
08:41:48 <asante> ghci tells me "Ambiguous type variable `e' in the constraint:"
08:42:16 <CondT> :t CondT
08:42:17 <lambdabot> Not in scope: data constructor `CondT'
08:42:18 <ion> It can‚Äôt infer which exception type you want to handle.
08:42:45 <ion> Add a type annotation to the first parameter to handle.
08:44:32 <asante> ion: smth like " (const (return [])) :: [String] "
08:44:52 <ion> @type Control.Exception.handle
08:44:53 <lambdabot> forall e a. (GHC.Exception.Exception e) => (e -> IO a) -> IO a -> IO a
08:44:57 <asante> thats from "real world haskell" ch08
08:45:34 <ion> The parameter‚Äôs supposed to be of type Exception e => e -> IO a. It can‚Äôt infer what e‚Äôs supposed to be based on your code. You‚Äôll need to provide that information.
08:45:45 <postfuturist> My first Haskell program has really poor performance, not sure why: https://github.com/deliciousrobots/sml_life/blob/master/haskell/life.hs
08:45:51 <drdo> How can i do a ByteString to Word16 conversion?
08:46:24 <ion> What do you want to do with a ByteString with a length of 3 bytes?
08:46:33 <drdo> memory corruption
08:46:34 <rwbarton> or 2 bytes for that matter
08:46:43 <drdo> It's supposed to be unsafe of course
08:46:44 <asante> ion: but ghc should care about, or? since const didn't care about what its parameter is..
08:47:40 <drdo> I'm just reading a 2 byte port number from the network and need to make a SockAddr out of it
08:47:58 <ion> drdo: Sounds like you want to use cereal or something like that.
08:47:59 <rwbarton> have you looked at the binary package?
08:48:01 <ion> @hackage cereal
08:48:01 <lambdabot> http://hackage.haskell.org/package/cereal
08:48:12 <ion> The binary package is nasty. :-\
08:48:25 <hpc> it occurs to me that the debate over what the MonadPlus laws should be...
08:48:32 <hpc> is really the debate over what the Alternative laws should be
08:48:36 <ion> Its decode function handles errors by returning bottom.
08:48:47 <rwbarton> for good reason
08:49:05 <hpc> every proposed MonadPlus law can be expressed in terms of Applicative and Alternative
08:49:26 <postfuturist> I think the lazy evaluation is killing performance for the Haskell version of this little Conway's Game of Life implementation, any ideas on how to mitigate? https://github.com/deliciousrobots/sml_life
08:49:44 <zzo38> hpc: I think it should be just the monoid laws. If you need things such as left catch and so on, make them into separate classes having those as superclass
08:50:13 <zzo38> The left zero law is automatically implied by the monad laws
08:51:03 <NothingMan65> Noob question incoming...
08:51:04 <mjga> postfuturist: either use BangPatterns or profile to find the culprit: ghc --make prog -prof -auto-all -auto-caf -xc, and then ./prog +RTS -hpc?
08:51:24 <hpc> zzo38: no it isn't
08:51:26 <NothingMan65> First of all, Happy Valentine's Day
08:51:35 <rwbarton> postfuturist: it would probably help a lot to use an (unboxed) array rather than a list
08:51:35 <hpc> not unless you take another law as a relationship between mplus and bind
08:51:52 <NothingMan65> So I'm all up in the ST Monad, and I'm like, well how do I assign a variable?  LIke if I want a variable with the value 1 which does not come from my array
08:51:55 <zzo38> hpc: The other law is parametricity
08:51:58 <ion> postfuturist: You‚Äôll probably need to make things stricter. ‚Äúd‚Äù probably builds a huge thunk which is evaluated at the very end.
08:53:09 <zzo38> I prefer join to be basic intstead of bind anyways; they should make it into a class method, it make more sense join anyways
08:53:09 <postfuturist> ion: I figured something like that was happening, is there a standard way to force evaluation earlier?
08:53:44 <hpc> zzo38: ah, and then the law would be "join mzero = mzero"
08:54:01 <rostayob> I'm studying L-system and I get a comonad feeling
08:54:04 <mjga> @info seq
08:54:04 <lambdabot> seq
08:54:06 <rostayob> am I correct?
08:54:11 <mjga> @src deepseq
08:54:11 <lambdabot> Source not found. Sorry.
08:54:16 --- mode: kornbluth.freenode.net set +o ChanServ
08:55:02 <mjga> postfuturist: early `seq` value or `deepseq`
08:55:09 <zzo38> hpc: Yes, it can prove by "fmap id = id" and parametricity and "join . return = join . fmap return = id"
08:55:43 <ion> postfuturist: http://www.haskell.org/haskellwiki/Performance/Strictness
08:56:05 <postfuturist> ion, mjga: just what I was looking for, thanks!
08:56:13 <zzo38> hpc: Now do you think it is?
08:57:22 <Cale> Couldn't match expected type `t0 -> t1 -> t2' with actual type `forall (n :: (* -> *) -> *). (Node (GM x2) n) => Ref (GM x2) n -> n (GM x2) -> RAM bi0 ei0 bo0 eo0 (GM x0) ()'
08:57:25 <Cale> .___.
08:57:30 <Cale> Oh well.
08:57:39 <hpc> zzo38: almost
08:57:42 <hpc> working it out myself
08:58:30 <hpc> zzo38: convinced
08:58:45 <zzo38> hpc: OK.
08:58:56 <hpc> very cool
08:59:11 <rwbarton> postfuturist: btw (map (\(x,i) -> getNext (i, x)) (zip v [0..])) can be written zipWith getNext [0..] v
08:59:38 <rwbarton> er
08:59:47 <rwbarton> @type zipWith
08:59:48 <lambdabot> forall a b c. (a -> b -> c) -> [a] -> [b] -> [c]
09:00:01 <rwbarton> it could if you curried getNext
09:00:28 <hpc> left distribution becomes fmap f (m `mplus` n) = (fmap f m) `mplus` (fmap f n)
09:01:31 <rwbarton> postfuturist: also just to make sure, are you compiling with -O2? it can make a huge difference even over compiled without optimizations
09:02:03 <postfuturist> rwbarton: I'll try that.
09:02:19 <zzo38> There is a common MonadPlus instance for IO which does not follow the monoid laws. Here is my Alternative instance for IO which does follow laws:  instance Alternative IO where { empty = fail []; x <|> y = catch x $ \e -> modifyIOError (\z -> if z == userError [] then e else z) y; };
09:02:33 <dekuked`> hey, what's the best way to learn haskell?
09:02:44 <zzo38> dekuked`: Practice.
09:03:53 <postfuturist> rwbarton: heh, that cut runtime down to 23 seconds from 104.
09:04:17 * hackagebot language-javascript 0.4.8 - Parser for JavaScript  http://hackage.haskell.org/package/language-javascript-0.4.8 (AlanZimmerman)
09:04:57 <zzo38> hideError = modifyIOError (const $ userError []);
09:06:27 <zzo38> How can you write in the .cabal file to tell to install certain extra files into certain places?
09:07:07 <mjga> dekuked: I recommend "Real World Haskell" on WWW, or as ebook :-)
09:07:55 <rostayob> dekuked`: RWH is not a good book to start.
09:08:02 <rostayob> LYAH or Programming in Haskell are excellent
09:08:23 <uniquenick> what's wrong with RWH?
09:08:33 <koeien3> it's a bit dense for beginners
09:08:37 <asante> i can't figure out, whats wrong with that piece of code (from real world haskell): http://pastebin.com/vNXXVC5e
09:08:39 <mauke> The paste vNXXVC5e has been copied to http://hpaste.org/63692
09:08:41 <rostayob> uniquenick: it doesn't teach you functional programming
09:08:44 <zzo38> No; the best way is to learn to be mathematically inclined
09:08:46 <rostayob> it's a cookbook kind of book
09:08:54 <rostayob> zzo38: that doesn't mean anything.
09:09:05 <rostayob> I wouldn't say I'm mathematically inclided and I love haskell
09:09:22 <zzo38> I didn't mean that is the only way!
09:09:32 <rostayob> zzo38: you said that's the best way
09:09:43 <rostayob> while maths has little to do with practical haskell programming
09:09:45 <zzo38> Just because is best way doesn't make it the only way
09:09:54 <rostayob> it's very interesting to study the foundation of haskell
09:09:58 <rostayob> but it's not a requirement
09:10:06 <rostayob> zzo38: I'm arguing on it being the best way
09:11:43 <rostayob> You might be a better haskell programmer after you read about lambda-calculus and type theory, but again I really don't think it's a requirement, and it's definitely not the best way to start programming in haskell
09:11:55 <Jedai> I think that Mathematics is a charged term, there is so many branch of Maths that have really little to do with Haskell and much of what you do until college is in those branches...
09:11:58 <zzo38> Well, to me, at least, understanding a lot of things in Haskell including how many of the typeclasses work can be I understand by mathematics, such as functors and monads in category theory, and so on. Defining the monad with fmap and join makes more sense to me than using >>= as definition; to me, >>= is a convenient shortcut to combine fmap with join
09:12:49 <zzo38> (And this combination is often useful with list monad)
09:12:56 <rostayob> zzo38: cathegory theory is even less relevant to haskell
09:12:57 <rostayob> the bulk of the theory is regarding types
09:13:16 <rostayob> and really, I think no one here would argue that the best way to teach haskell is through category theory
09:13:21 <zzo38> Yes, I know, they are not all category theory.
09:13:29 <Jedai> So many people have bad associations with "Maths" without realizing that a lot of what attract them to Haskell (and "clean" programming) is in fact what some others recognize as linked to some deep theory in Mathematics
09:14:15 <rwbarton> asante: ion already explained earlier.
09:14:54 <rwbarton> if you didn't understand the explanation, you shouldn't ask the same question, or you will likely get the same explanation again.
09:16:33 <zzo38> Jedai: Possibly; that can certainly work. However, I find it difficult to understand typeclass laws without mathematics. And then I will figure out implied laws, proofs, and more. They can come from other areas of mathematics too. And even things without typeclasses can have mathematical ideas.
09:18:30 <zzo38> Does anyone know answer to my other question about cabal packages installing stuff in other directories?
09:18:45 <Jedai> zzo38: I didn't say they didn't, I said that maths is a pretty vague term and some people have an adverse reaction to it for legitimate but mistaken reasons (because they're thinking of some branch that disagreed with them, or they were lost by the pretty informal presentation of Maths they had in High school and so on...)
09:20:13 <nyingen> I looked up "alonzo church" on google image search, and the first result on the second row of images is hardcore pornography
09:21:49 <Jafet> <TRWBW> don't google for "group action"
09:22:24 <tgeeky> lol
09:22:24 <yless> Ok, I'm not sure if my message got through before disconnecting, appologies if it did.
09:22:27 <yless> Does anyone know what the best way of converting a "Vector (Vector Float)" to a ForeignPtr is (using Storable Vectors). For a single vector there is "unsafeToForeignPtr", and the stated way of doing 2D Vectors is vectors of vectors but this doesn't seem to handle the underlying memory model very well. Failing that (or otherwise), is there a better 2d data structure with easy marshalling? For
09:22:28 <yless> reference I currently concatenate all the inner vectors to a single vector and convert that.
09:23:36 <Jedai> yless: I don't think Vector (Vector Float) produce adjacent Vectors (not in all situation at least), so I don't think you can do better than what you currently do
09:24:32 <Jedai> yless: Which means you should be using another data structure probably (or add an abstraction over a Vector Float to give an illusion of 2D)
09:24:41 <zzo38> I want to make a package which installs some files in the HAMPPPATH (an environment variable listing directories to search) how can I do that?
09:24:47 <yless> OK, thanks
09:25:07 <Jedai> yless: Maybe if you told us how you use your data, we could orient you towards suitable libraries ?
09:25:08 <rostayob> I feel that while this focus of the haskell community on the theoretical stuff is great
09:25:11 <rostayob> it also create a divide between the haskell community and the larger programming community
09:25:11 <rostayob> and saying to a newcomer "learn category theory first" is simply wrong
09:25:17 <rwbarton> repa is one package that provides rectangular arrays
09:25:45 <Jedai> Damn, this is seriously unstable...
09:25:47 <zzo38> rostayob: I agree; I found category theory difficult to understand too at first. I say learn it at the same time
09:25:58 <Jedai> zzo38: rostayod si splitted...
09:26:02 <Jedai> *is
09:26:19 <asante> rwbarton: sry, you're right. but.. mh i just don't get it
09:26:20 <zzo38> Oops
09:26:49 <asante> if i want some code handle any kind of exception, i should use handle, right?
09:27:20 <Jafet> @hoogle handle
09:27:20 <lambdabot> System.IO data Handle
09:27:21 <lambdabot> GHC.IO.Handle data Handle
09:27:21 <lambdabot> Control.OldException handle :: (Exception -> IO a) -> IO a -> IO a
09:27:26 <asante> which takes a function, that will be used for the exception handling
09:27:38 <Jafet> @hoogle catch
09:27:38 <lambdabot> Prelude catch :: IO a -> (IOError -> IO a) -> IO a
09:27:38 <lambdabot> System.IO.Error catch :: IO a -> (IOError -> IO a) -> IO a
09:27:38 <lambdabot> Control.OldException catch :: IO a -> (Exception -> IO a) -> IO a
09:27:51 <Jedai> asante: catch is normally more appropriate
09:28:06 <yless> rwbarton: cheers
09:28:09 <Jafet> Wait, catch is a flip handle?
09:28:26 <asante> seems so..
09:28:30 <Jedai> asante: from Control.Exception (not the old stuff hoogle just showed us)
09:29:00 <asante> i'll used handle, cause thats just an example from RWH
09:29:47 <Jedai> asante: Note that if you don't want to really "handle" the exception but make code that is robust in the face of an exception, there are other functions like finally, or bracket
09:29:56 <Jedai> @hoogle bracket
09:29:56 <lambdabot> Control.Exception.Base bracket :: IO a -> (a -> IO b) -> (a -> IO c) -> IO c
09:29:56 <lambdabot> Control.Exception bracket :: IO a -> (a -> IO b) -> (a -> IO c) -> IO c
09:29:56 <lambdabot> Control.OldException bracket :: IO a -> (a -> IO b) -> (a -> IO c) -> IO c
09:33:53 <asante> ok.. so the problem with the book code is, that it depends on the old version of handle, which lives in Control.OldException
09:34:18 * hackagebot aws 0.3 - Amazon Web Services (AWS) for Haskell  http://hackage.haskell.org/package/aws-0.3 (AristidBreitkreuz)
09:39:24 <Jedai> asante: really, I thought RWH was written after the overhaul of exceptions. What do you want to do ?
09:40:03 <asante> thats an example code from ch08/Glob.hs about regular expressions
09:40:29 <Jedai> asante: basically if you want to catch everything you should use    action `catch` (\SomeException e -> whatever)
09:41:07 <Jedai> asante: If you just want to test the code, the easy fix is to import Control.OldException, I guess
09:41:29 <asante> that works, yes
09:41:38 <asante> i'll try the catch-version
09:42:59 <Jedai> asante: note that handle and catch seems to works exactly the same (but with arguments swapped around)
09:43:44 <Jedai> asante: catch is usually used infix like in my example to put the exception handling code after the code it handle :)
09:44:05 <asante> ok, thanks
09:44:42 <asante> SomeException is in Control.Exception, isn't it? how can i import data contructors like SomeException?
09:44:53 <Jafet> SomeException is not a constructor
09:44:56 <asante> import Control.Exception (SomeException) doesn't seems to work
09:45:08 <Jafet> There is no need to use it, either
09:45:17 <c_wraith> asante: that's the type you're importing, not a constructor
09:45:21 <Jafet> Catch the type of the exception you want to catch
09:45:43 <Jedai> Jafet: He wants to catch them all (or so he thinks)
09:45:53 <Jafet> Good job encouraging him!
09:45:59 <asante> :D
09:46:16 <c_wraith> I nearly always want to catch them all.  (Then throw them later. I actually use bracket much more than catch)
09:46:37 <Jedai> Jafet: I don't think it's really important for testing code from a book :) (and I already recommanded bracket)
09:46:45 <mike-burns> I'd rather they be Either.
09:47:00 <Jafet> @hackage spoon
09:47:00 <lambdabot> http://hackage.haskell.org/package/spoon
09:47:01 <asante> mh, i'm completly onfused
09:47:03 <asante> *confused
09:47:12 <mike-burns> Yeah! I love spoon.
09:47:18 <mike-burns> The Tick and I have that in common.
09:47:30 <donri> 200 OK THERE IS A SPOON
09:47:58 <asante> catch is just flipped handle, ya?
09:48:18 <Jafet> If it is, the documentation for Control.Exception should say so.
09:48:25 <asante> so, why can i use (`catch` (const (return []))) $ do .. instead of my previous version?
09:48:27 <Jedai> Jafet: it does
09:48:59 <asante> @hoogle handle
09:48:59 <lambdabot> System.IO data Handle
09:49:00 <lambdabot> GHC.IO.Handle data Handle
09:49:00 <lambdabot> Control.OldException handle :: (Exception -> IO a) -> IO a -> IO a
09:49:00 <Jedai> asante: probably because if you does that there's an ambiguity on the type of the exceptions you want to catch
09:49:35 <Jedai> asante: Which is why in my example I used \(SomeException e) -> ...
09:50:01 <asante> shouldn't it be the same thing with "handle (const (return [])) $ do ..
09:50:29 <Jedai> asante: this ensure that GHC see that I want to catch every exception that is under "SomeException" in the Exception hierarchy (that is every single one of them)
09:51:01 <Jafet> asante: what is the type of const (return [])?
09:51:01 <Jedai> asante: No, because in the new Control.Exceotion, Exception is a type class, not a type
09:52:07 <Jedai> asante: so in the OldException, (const(return [])) could only be of the type (Exception -> IO [..]) but in the new one there's an ambiguity on the type of the parameter
09:52:20 <asante> ya ok. i understand that
09:52:32 <Jedai> asante: handle :: Exception e => (e -> IO a) -> IO a -> IO a
09:53:03 <dcoutts> zzo38: would have to write some custom code in Setup.hs copy hook
09:53:17 <asante> when i want to catch exceptions in the new version, is SomeException the most general exception?
09:53:34 <Jedai> asante: so either you annotate your function with an explicit type, or you use a pattern match that makes it explicit what type of exception you want
09:53:37 <dcoutts> asante: yes, but you almost never want to catch all exceptions
09:53:58 <Jedai> asante: Yes, there's now a whole hierarchy (there's a good paper on that somewhere)
09:54:04 <Jedai> @where exception
09:54:04 <lambdabot> I know nothing about exception.
09:54:14 <asante> ok cool.
09:54:15 <asante> thanks!
09:55:45 <Jedai> http://community.haskell.org/~simonmar/papers/ext-exceptions.pdf
09:56:02 <asante> btw: later on in RWH they say, that it is printed with the old exception system
09:56:24 <asante> ah, nice. thanks
09:57:11 <Jedai> @where+ exceptions http://community.haskell.org/~simonmar/papers/ext-exceptions.pdf
09:57:11 <lambdabot> Done.
09:57:34 <Jedai> @where+ exception http://community.haskell.org/~simonmar/papers/ext-exceptions.pdf
09:57:34 <lambdabot> It is stored.
10:02:34 <hpaste> SubtleArray pasted ‚ÄúPrompt Function‚Äù at http://hpaste.org/63694
10:06:20 <SubtleArray> Hi folks. I'm trying to get a prompt function to work. I'm not sure if I'm writing it properly. Chances are I'm not. >_< But it's close. Lol. http://hpaste.org/63694
10:09:28 <asante> bye
10:09:30 <ksion> SubtleArray: You don't need getUserInput and return at the end, just the case.
10:09:56 <rwbarton> SubtleArray: i'm not sure what the question is...
10:10:20 <rwbarton> this program looks like it would compile, and then do something sort of odd...
10:11:19 <rwbarton> it doesn't do what you expect, or what?
10:11:34 <ksion> If it was ran without arguments, it will just endlessly output > and wait for input.
10:11:57 <ksion> I think he wanted to parse string returned by getLine in command-like manner.
10:13:01 <SubtleArray> ksion: When I remove the return, GHC complains says "last statement in a 'do' construct must be an expression.
10:13:18 <rwbarton> "x <- y; return x" can be simplified to "y"
10:13:32 <SubtleArray> rwbarton: How do I correct this function so that it'll return the getUserInput variable so it can be used by whatever calls it?
10:14:00 <rwbarton> what is getUserInput supposed to *be*?
10:14:26 <rwbarton> an action describing how to get input from the user in the future?
10:15:25 <rwbarton> or some actual input from the user? if so that's a strange name for the variable
10:15:52 <rwbarton> anyways there is nothing *wrong* per se about the way you do "x <- y; return x"
10:16:11 <SubtleArray> rwbarton: getUserInput is a string variable of the user's input.
10:16:14 <rwbarton> okay
10:16:56 <donri> case args of [] -> getLine; fileName:_ -> readFile fileName
10:17:02 <rwbarton> I'm still not sure whether the program is doing something you don't expect, or whether you understand why it does what it does but you want to make it do something else but you don't know how.
10:17:19 <mekeor`> so, ML doesn't have type classes, does it?
10:18:49 <mjga> mekeor`: ML has modules that hope to substitute but work different way
10:19:07 <SubtleArray> rwbarton: Right now I have an error. "last statement in a 'do' construct must be an expression. I'd like to first get rid of this error.
10:19:14 <rwbarton> ugh
10:19:15 <mekeor`> mjga: ah, okay
10:19:30 <rwbarton> the code you pasted doesn't have that error.
10:20:10 <donri> SubtleArray: what ksion meant was to just end with the case, without the getUserInput <-
10:21:15 <rwbarton> does anyone understand the difference between the unboxed singleton "(# a #)" and a simple "a"?
10:21:39 <SubtleArray> One moment. Trying to catch up. Had to put on glasses so I can read better. Ha.
10:22:07 <mjga> rwbarton:1) unboxed cannot throw exception, nor loop forever if used 2) only boxed can be given to polymorphic function
10:22:45 <SubtleArray> ksion: I'm trying to make a prompt function that I can reuse that can get user input from the command line or from a text file, and then return that input in a string called getUserInput.
10:22:48 <rwbarton> But inside the unboxed singleton, there is a box
10:23:07 <hpaste> donri annotated ‚ÄúPrompt Function‚Äù with ‚Äúmaybe like this?‚Äù at http://hpaste.org/63694#a63695
10:23:10 <rwbarton> e.g. indexArray# :: Array# a -> Int# -> (#a#)
10:23:20 <SubtleArray> rwbarton: But it has the error when I remove the return. Someone said I didn't need to have the return.
10:23:24 <cmccann> I would expect that an unboxed singleton tuple is equivalent to what it contains
10:23:27 <cmccann> as a newtype is
10:23:41 <cmccann> based on how the GHC user guide describes unboxed tuples in general
10:23:55 <SubtleArray> donri: Ohhh! I see now.
10:23:58 <SubtleArray> I'll try that.
10:24:00 <cmccann> are there other interpretations of it that would make sense?
10:24:07 <rwbarton> not that I can think of
10:24:13 <ksion> SubtleArray: donri's annotation seems to match your desired behavior at first glance.
10:24:56 <cmccann> rwbarton, I'd recommend either empirical investigation or asking some GHC hackers to be sure
10:24:59 <cmccann> why do you want to know?
10:25:04 <rwbarton> oh, just curious
10:26:10 <cmccann> my understanding is that unboxed tuples exist essentially to represent multiple return values
10:26:36 <cmccann> and indicate that the values are passed directly without having an explicit structure to store them
10:26:47 <cmccann> i.e. a compile-time fiction of sorts
10:27:00 <rwbarton> So do you think there would be an implementation difference between (# a #) and a? in the calling conventions involved, perhaps
10:27:16 <mux> Lemmih_: did you get my message?
10:27:37 <cmccann> personally I'd expect the end result to be the same all else equal
10:28:00 <mjga> rwbarton: inside unboxed type one can only have a C primitive: int32, float32, char, so unboxed = strict - polymorphic
10:28:03 <cmccann> I'd expect them to differ no more than a (Id a) and a do
10:28:15 <rwbarton> I'm not talking about Int# etc.
10:28:17 <cmccann> except that the unboxed singleton tuple might have a funny kind
10:28:47 <rwbarton> I'm talking about the (# #) constructor
10:28:53 <cmccann> are unboxed singleton tuples even valid syntax, anyway?
10:28:56 <cmccann> seems superfluous
10:29:06 <rwbarton> cmccann, I came across one in GHC.Prim
10:29:10 <cmccann> ah
10:29:13 <rwbarton> indexArray# :: Array# a -> Int# -> (#a#)
10:29:18 <rwbarton> Read from specified index of immutable array. Result is packaged into an unboxed singleton; the result itself is not yet evaluated.
10:29:27 <cmccann> that's odd
10:29:33 <mjga> rwbarton: Int# :: #, whereas Int :: *, * is polymorphic kind, # is not afair
10:29:58 <rwbarton> Also, I remember a mailing list thread where I think one of the Simons made it sound like it made sense to him that unboxed singletons were a sensible thing to have.
10:30:04 <cmccann> rwbarton, I can't imagine what purpose that serves unless I'm wrong and there's more to them
10:30:34 <cmccann> I'd still be surprised if it changed anything in the final binary, but maybe the optimizer and such cares
10:30:43 <SubtleArray> donri: I just spotted this. http://hpaste.org/63694#a63695 Checking it out now.
10:31:21 <rwbarton> yeah, it was this -- http://haskell.1045720.n5.nabble.com/Unit-unboxed-tuples-td5097119.html
10:31:52 <cmccann> just found that myself :]
10:32:33 <rwbarton> at least dolio is as confused as I am
10:33:40 <SubtleArray> donri: I think that did the trick! Now I just need to figure out how to pull input from it and put it into a variable. But I think I can figure that out. But I think I'm on the right track now. Thank you.
10:33:57 <donri> do input <- prompt
10:34:57 <CondT> anyone here good with control theory?
10:35:26 <asdf1234> ....
10:35:34 <mekeor> CondT: whats that?
10:36:02 <mekeor> ah, yea, we did that in school a lil bit
10:36:05 <mekeor> hehe
10:36:11 <cmccann> rwbarton, ok. my conclusion from that thread is that unboxed singleton tuples do mean something different from the obvious
10:36:17 <cmccann> and that I don't quite understand what
10:36:20 <cmccann> sorry
10:36:30 <JoeyA> Where is GHC.Prim these days?
10:36:40 <rwbarton> it seems to have something to do with 'case' in ghc core
10:36:56 <mux> JoeyA: maybe it is all contained in the primitive package now? just a wild guess
10:37:26 <cmccann> rwbarton, which is different from how case works in Haskell I believe
10:37:32 <rwbarton> yes
10:37:36 <cmccann> but I don't recall the details :T
10:37:43 <SubtleArray> donri: :D Thanks.
10:37:48 <JoeyA> I'm trying to find GHC's documentation for unsafeCoerce.
10:37:56 <rwbarton> in core "case x of _ -> y" is Haskell's "x `seq` y"
10:38:00 <rwbarton> is the main difference I know about
10:38:15 <dolio> rwbarton: Yes, it's very confusing.
10:38:22 <cmccann> JoeyA, just pick a random piece of documentation, rename the file to "unsafeCoerceDocs" and assume that's what it is
10:38:23 <cmccann> it should work
10:38:44 <JoeyA> har har
10:38:52 * cmccann is helpful
10:40:11 <JoeyA> In particular, I want to know if I can use unsafeCoerce to manipulate data with hidden definitions, by repeating the definition.  I know that's... unsafe.
10:40:24 <mkscrg> Struggling with some FFI code in 7.4.1: Did 7.4.1 change the behavior of -threaded or multithreading in general?
10:40:39 <JoeyA> I imagine there's a risk the compiler might automatically unpack fields or something.
10:40:42 <c_wraith> That should work
10:40:56 <dolio> rwbarton: Near as I can tell, returning an unboxed singleton lets you do stack allocation while still not evaluating, which is missing in core otherwise.
10:40:59 <c_wraith> but yes, unsafe as heck, and even if it works, brittle
10:41:23 <Saizan> JoeyA: http://www.haskell.org/ghc/docs/latest/html/libraries/ghc-prim-0.2.0.0/GHC-Prim.html#v:unsafeCoerce-35-
10:42:45 <JoeyA> Thanks.  The link I followed on Hackage took me to a Haddock v1 page, so I assumed it was old:  http://hackage.haskell.org/packages/archive/ghc-prim/0.2.0.0/doc/html/GHC-Prim.html#v:unsafeCoerce-35-
10:45:11 <rwbarton> dolio: so is the idea if I have something like "f (x ! k)" I would want to do the lookup "x ! k" before invoking f, to avoid allocating a thunk for "x ! k"?
10:45:44 <rwbarton> but that's not really legitimate because k could be out of bounds
10:46:11 <dolio> You don't want to allocate a thunk, but you don't want to evaluate the result of x!k.
10:46:19 <rwbarton> right
10:46:31 <rwbarton> i just want to pass f the thunk or whatever value is in the array x
10:46:46 <dolio> Yeah. Something like that.
10:47:39 <nus-> co-boxing?-)
10:48:29 <dylukes> Is there any way to take an existing type class instance...
10:48:37 <dylukes> and only override one of its functions?
10:48:49 <dylukes> sort of subtype implementation inheritance.
10:49:00 <dylukes> I just don't want to re-implement all of the rest.
10:51:47 <thiagoharry> @version
10:51:47 <lambdabot> lambdabot 4.2.2.1
10:51:47 <lambdabot> darcs get http://code.haskell.org/lambdabot
10:52:03 <thiagoharry> @type map
10:52:04 <lambdabot> forall a b. (a -> b) -> [a] -> [b]
10:52:49 <rwbarton> :t (# 3 #)
10:52:50 <lambdabot> forall t. (Num t) => (# t #)
10:53:02 <rwbarton> :k (# Int #)
10:53:02 <lambdabot> (#)
10:54:21 <thiagoharry> @run [1,2,3]
10:54:22 <lambdabot>   [1,2,3]
10:54:27 <thiagoharry> @run [1..]
10:54:28 <lambdabot>   [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28...
10:54:32 <Eduard_Munteanu> What's that, a boxed 1-tuple?
10:54:50 <rwbarton> it is the mysterious unboxed 1-tuple
10:54:51 <Eduard_Munteanu> :k (# Int, Int #)
10:54:52 <lambdabot> (#)
10:54:55 <Eduard_Munteanu> Erm, unboxed.
10:55:20 <rwbarton> :t let f (# n #) = (# n+1 #) in f
10:55:21 <lambdabot>     Couldn't match kind `(#)' against `??'
10:55:21 <lambdabot>     When matching the kinds of `(# a #) :: (#)' and `t :: ??'
10:55:22 <lambdabot>     When generalising the type(s) for `f'
10:55:54 <Eduard_Munteanu> :k (->)
10:55:55 <lambdabot> ?? -> ? -> *
10:56:11 <rwbarton> so I can only unpack unboxed tuples with let, not pass them to functions?
10:56:32 <rwbarton> :k Int#
10:56:33 <lambdabot> Not in scope: type constructor or class `Int#'
10:56:56 <Eduard_Munteanu> :k 3#
10:56:57 <lambdabot> parse error on input `3#'
10:56:58 <dolio> Can you unpack them with let?
10:56:59 <Eduard_Munteanu> :k #3
10:57:00 <lambdabot> parse error (possibly incorrect indentation)
10:57:15 <rwbarton> oh I should have said case?
10:57:22 <Eduard_Munteanu> Erm.
10:57:23 <rwbarton> > let (# x #) = (# 3 #) in x
10:57:23 <lambdabot>   3
10:57:24 <Eduard_Munteanu> :t #3
10:57:25 <lambdabot> <no location info>: not an expression: `#3'
10:57:26 <rwbarton> apparently
10:57:29 <Eduard_Munteanu> :t 3#
10:57:30 <lambdabot> GHC.Prim.Int#
10:57:32 <dolio> Dunno. Even if you use let, it probably turns into case in the core.
10:57:56 <rwbarton> > let (# x #) = undefined in "test"
10:57:57 <lambdabot>   Couldn't match kind `*' against `(#)'
10:57:58 <dolio> I wasn't sure if it would complain if you used let, though.
10:58:03 <rwbarton> hmm
10:58:05 <rwbarton> > let (# x #) = (# x #) in "test"
10:58:06 <lambdabot>   "test"
10:58:26 <rwbarton> okay this isn't helping.
10:58:35 <dolio> I have no idea how that works.
10:59:18 <Eduard_Munteanu> > let n# = n# in "test"
10:59:19 <lambdabot>   "test"
10:59:38 <magicman> > let n# = 3 in "test"
10:59:39 <lambdabot>   "test"
10:59:45 <rwbarton> n# is just another identifier, no different from n
11:00:15 <rwbarton> > case undefined of (# x #) -> "test"
11:00:16 <lambdabot>   Couldn't match kind `(#)' against `*'
11:00:17 <Eduard_Munteanu> Ah so you don't need to mark unboxed stuff somehow?
11:00:28 <rwbarton> the type/kind system tracks that
11:00:36 <Eduard_Munteanu> :t let f x = (# x #) in f
11:00:37 <lambdabot> forall t. t -> (# t #)
11:00:49 <rwbarton> but there are a lot of named unboxed things, and their names tend to end with # by convention
11:00:56 <rwbarton> or functions that operate on unboxed things
11:01:19 <Eduard_Munteanu> :t let f x = (# x #); f :: GHC.Prim.Int# -> (# Int #) in f
11:01:20 <lambdabot>     Couldn't match expected type `Int'
11:01:20 <lambdabot>            against inferred type `GHC.Prim.Int#'
11:01:20 <lambdabot>     In the expression: x
11:01:33 <Eduard_Munteanu> :t let f x = (# x #); f :: GHC.Prim.Int# -> (# GHC.Prim.Int# #) in f
11:01:34 <lambdabot> GHC.Prim.Int# -> (# GHC.Prim.Int# #)
11:01:54 <Eduard_Munteanu> Right, so ? = ?? + (#)  I guess
11:02:30 <Eduard_Munteanu> I'm not exactly sure why though, I heard an argument about regparms.
11:04:54 <dolio> Unboxed tuples are used for passing multiple things in registers.
11:05:23 <int-e> I would think that the argument is that you don't need such functions -- you can always unpack the unboxed tuple into a list of separate arguments.
11:05:24 <dolio> But, you can already pass multiple registers into a function, because GHC is smart about things of the form T -> U -> V -> ...
11:05:44 <dolio> However, you can't pass multiple things out without allocating, unless you have unboxed tuples.
11:06:00 <dolio> So they don't bother allowing you to pass unboxed tuples into a function.
11:06:04 <Eduard_Munteanu> I thought you could do that, at least on x86-64.
11:06:09 <Eduard_Munteanu> rax and rdx, no?
11:06:25 <dolio> I mean the GHC core execution model.
11:06:37 <int-e> But we're firmly on the Haskell side of things. (Ok, Core)
11:06:44 <Eduard_Munteanu> Ah.
11:06:47 <dolio> The only way to pass multiple results out of a function is to use a tuple, and you have to allocate the tuple.
11:07:49 <Eduard_Munteanu> But doesn't that hinder taking advantage of particular ABIs which allow it?
11:08:08 <dolio> Allow what?
11:08:12 <int-e> ghc pretty much ignores the ABI anyway, except when calling C functions.
11:08:21 <Eduard_Munteanu> dolio: returning multiple things via registers
11:08:45 <Eduard_Munteanu> E.g. IIRC, C will return struct foo { int a; int b } in rax and rdx.
11:08:46 <int-e> that's what the unboxed tuples are designed for
11:08:58 <dolio> Returning an unboxed tuple is returning multiple things in registers.
11:09:15 <int-e> note that haskell's tuples are data objects on a heap. in particular, a value of type (a,b) may be undefined.
11:09:16 <Eduard_Munteanu> Ah, I see your point now.
11:09:22 * hackagebot hashable 1.1.2.3 - A class for types that can be converted to a hash value  http://hackage.haskell.org/package/hashable-1.1.2.3 (JohanTibell)
11:10:17 <Eduard_Munteanu> Also, ?? = ? + (#) above, my mistake.
11:10:38 <dolio> :k (->)
11:10:38 <Eduard_Munteanu> Wait no, it was alright.
11:10:39 <lambdabot> ?? -> ? -> *
11:10:40 <int-e> nope, you had it right.
11:11:31 <Eduard_Munteanu> I guess passing unboxed tuples into functions would complicate argument passing?
11:14:47 <theorinf> I would like to demonstrate that the following language is not context free: (ww)  and w is a string made with "a" and "b"
11:15:50 <adimit> ok, this is a long shot, but maybe somebody here has a better intuition about these things than I: I have a data structure of 18 integers in columns c_1‚Ä¶c_18, that I have about 14-20 million rows of. I need to be able to search for a subset of these integers (say, 6 of them that match at arbitrary positions i_1‚Ä¶i_6 where 1 ‚â§ i_1 < i_6 ‚â§ 18). What's the most efficient way to go about such an
11:15:52 <adimit> endeavour?
11:16:09 <adimit> ‚Ä¶ I can't hash them, because I need to be able to look for just parts of them.
11:16:42 <cmccann> adimit, would a k-d tree work?
11:16:54 <adimit> cmccann: depends, I have no idea what a k-d tree is.
11:16:54 <cmccann> with appropriate tweaks for dealing with the volume of data you need
11:17:09 <cmccann> a k-dimensional search tree
11:17:47 <tty7> theorinf: the language {ww | w \in {a, b}*} is context free in fact.
11:17:49 <adimit> cmccann: i'll have to investigate, but I think a search tree might be bad performance-wise.
11:18:00 <cmccann> i.e. an arbitrary-dimension generalization of the kind of search trees used for nearest-neighbor searches and spatial information
11:18:19 <adimit> yeah‚Ä¶ well, it's a lead, someting I hadn't thought of before.
11:18:21 <adimit> thanks :-)
11:18:23 <cmccann> they're used specifically for performance when you need to search by multi-dimensional proximity
11:18:31 <cmccann> e.g. octrees are common in 3D graphics
11:18:50 <c_wraith> there are 3-dimensional space-filling curves, right?
11:19:01 <cmccann> yes
11:19:02 <adimit> yeah, true, I could just view the rows as 18-dimensional vectors.
11:19:41 <cmccann> yeah, what I'm not sure is if you'd get good enough results if you don't care about overall distance but only on certain elements
11:19:42 <adimit> damn, I should've done more CS in undergrad.
11:19:57 <cmccann> but maybe you can project to a lower dimensional space on the fly or something
11:20:10 <rwbarton> i_1 ... i_6 are part of the search data?
11:20:25 <Saizan> tty7: using which grammar?
11:20:34 <cmccann> you'll probably have to tweak things a bit, but there's a k-d tree package on hackage if memory serves me
11:20:40 <rwbarton> as in, the input to your search consists of i_1 ... i_6, x_1 ... x_6
11:20:58 <tty7> ah, wait. sorry. :/
11:21:14 <tty7> i read it like "w_1 w_2" instead of "ww"
11:21:29 <akosch> what's the mainstream opinion on implicit parameters? are people using them?
11:21:38 <cmccann> adimit, also, keep in mind that search trees are used in databases and such, they're fine for performance if you're using them appropriately
11:21:59 <adimit> rwbarton: no, I get a 6-tuple as input, with positions. So basically, I get another 18 d vector, but with certain positions of the vector zero'd out.
11:22:05 <rwbarton> so, yes
11:22:10 <byorgey> akosch: I have never once seen them actually used
11:22:24 <cmccann> I use them the way edwardk does
11:22:25 <rwbarton> if you can afford to build and store (18 choose 6) indexes, that will give you the best performance
11:22:28 <adimit> rwbarton: then I didn't understand you correctly :-)
11:22:29 <drdo> Are there any tools that can look at a file and write the import's ? (Based on your locally available packages presumably)
11:22:30 <cmccann> which is to generate useful type errors
11:22:40 <byorgey> as poor-man's holes?
11:22:46 <cmccann> byorgey, right
11:22:48 <mjga> what do you think about putting a row indices into a multimap (int -> [row])
11:22:51 <cmccann> they work surprisingly well for that
11:23:15 <edwardk> cmccann: implicit parameters?
11:23:15 <lambdabot> edwardk: You have 2 new messages. '/msg lambdabot @messages' to read them.
11:23:20 <cmccann> edwardk, yes
11:23:27 <akosch> byorgey: I guess if you already make them explicit in type signatures, they don't help much with brevity
11:23:29 <rwbarton> 18 choose 6 is probably too big for that to be practical unless you have a lot of disk lying around
11:23:31 <cmccann> edwardk, responding to the question "does anyone use them"
11:23:39 <adimit> rwbarton: I need it to fit in memory.
11:24:02 <rwbarton> 14-20 million * 18 * sizeof(int) is already playing with fire (unless you have a lot of memory lying around)
11:24:09 <adimit> disk access is too slow ‚Äî it's what I'm doing right now: putting the whole thing in an SQL data base.
11:24:16 <rwbarton> like, basically you have no room for data structures on top of that
11:24:32 <adimit> 24G is what I currently have
11:24:33 <edwardk> ah
11:24:39 <rwbarton> oh
11:24:54 <adimit> at my disposal. probably more like 20G if I count in some overhead.
11:25:14 <theorinf> tty7: I tried to apply the pumping lemma but without success
11:25:28 <adimit> so I believe I *can* fit a 2.4G db into memory for more efficient querying. I was wondering how :-)
11:25:53 <cmccann> adimit, do you have all the data up front and then only query it?
11:25:56 <cmccann> or do you need updates also
11:26:27 <tty7> theorinf: which words did you try?
11:26:55 <tty7> which word for a given n, i mean
11:27:22 <OceanSpray> the recent introduction of data kinds gave me a crazy idea
11:27:29 <adimit> cmccann: well, I can do it either way, but in the end, insert operations with SQL are tolerable on disk, I need half a day to assemble the entire DB, which is doable. So yeah, for all intents and purposes, I do have all the data upfront.
11:27:52 <OceanSpray> what if we do "garbage collection" in the type system?
11:28:04 <mjga> adimit: you may want to use on-disk index db (like sqlite, or hashable) though
11:28:08 <theorinf> tty7: I tried  aabbaabb
11:28:39 <adimit> mjga: yeah, that's what I'm currently doing, though it's slow to hit the disk so often. I need super-fast lookup since I'm doing lots of it.
11:29:04 <theorinf> tty7: but I can repeat the second b and the third b making it possible: aabbbbbbaabbbbbb
11:29:05 <tty7> so a^n b^n a^n b^n for arbitrary n?
11:29:15 <OceanSpray> we associate with every newly created resource a unique type-level token that we insert into a type-level datastructure, and when the second argument of (>>=) returns, we "search" its type for the presence of that token
11:29:19 <theorinf> tty7: yes like you said
11:29:28 <tty7> what about a^n b a^n b?
11:29:33 <cmccann> adimit, I'd suggest a bit of reading up on how DBs store things. you have similar needs, even if specialized
11:29:50 <rwbarton> adimit, I assume your SQL database does not have all (18 choose 6) indexes built, though
11:30:03 <theorinf> tty7: in that case I could repeat the last a in the first group and the last a in the second group
11:30:48 <haskell_noob> There seems to be an error in try Haskell at step 9. If you type in the first example it results in an error (<hint>:1:21: parse error on input `|'). If you click on it and then run it, it works. Just an FYI.
11:31:27 <adimit> rwbarton: no it does not. the integer values represent words in text.
11:31:52 <rwbarton> okay, that's helpful
11:32:01 <tty7> theorinf: wait a moment, let me think about that
11:32:24 <theorinf> tty7: thank you very much
11:32:43 <adimit> cmccann: that sounds good, yeah. also, vector space models and k-d trees :-)
11:33:30 <cmccann> adimit, k-d trees and related structures are the only tractable approach I know of for high-dimensional data but I'm not sure if your problem fits that closely enough
11:33:37 <rwbarton> i'm not sure how well k-d trees will work here, since you have no information at all about 12 of the directions, you'll always need to search both sides of the tree
11:34:04 <rwbarton> hmm
11:34:09 <cmccann> rwbarton, yes, it doesn't work directly
11:34:11 <adimit> rwbarton: yeah :-\
11:34:25 <cmccann> I'm more thinking it'd be a potential starting point
11:35:14 <rwbarton> you might also look into how full-text search tools like lucene work
11:35:57 <adimit> rwbarton: lots of bit-twiddling, afaicr‚Ä¶
11:36:33 <adimit> my course in IR is so long ago‚Ä¶ but I'll look into ti.
11:36:36 <adimit> *it.
11:37:45 <adimit> rwbarton, mjga, cmccann, thanks a lot for your input!
11:38:37 <tty7> theorinf: you can't do a^n b^(mn) a^n b^(mn) when pumping a^n b^n a^n b^n
11:39:06 <cmccann> adimit, no prob'
11:40:14 <tty7> for w = pqrst, |qrs| <= n says that you cannot have q = a^k, r = b^n, s = a^j or something
11:40:20 <mjga> cya ;-)
11:42:49 <lukish> How can group [1,2,3,4,5,6] to [[1,2],[3,4],[5,6]]? Is there some function [a] -> Int -> [[a]]?
11:43:05 <mauke> probably in Data.List.Split
11:43:11 <adimit> lukish: zip`ap`tail might serve you, too.
11:43:25 <mauke> adimit: how?
11:43:36 <kallisti> assuming he only wants two elements.
11:43:41 <kallisti> per inner list
11:43:50 <kallisti> then that can be represented with a 2-tuple.
11:43:57 <adimit> yeah, that's what I assumed.
11:44:00 <kallisti> but
11:44:03 <kallisti> these are not consecutive.
11:44:04 <mauke> still: how?
11:44:06 <lukish> :t zip `ap` tail
11:44:07 <lambdabot> forall b. [b] -> [(b, b)]
11:44:20 <adimit> oh, I misread.
11:44:21 <hpc> @quote aztec
11:44:22 <lambdabot> quicksilver says: zip`ap`tail - the Aztec god of consecutive numbers
11:44:27 <theorinf> tty7: and what about if I choose q='the last b in the first group' and s='the first b in the second group' ?
11:44:33 <hpc> > zip`ap`tail $ [1..]
11:44:34 <lambdabot>   [(1,2),(2,3),(3,4),(4,5),(5,6),(6,7),(7,8),(8,9),(9,10),(10,11),(11,12),(12...
11:44:39 <adimit> these really aren't consecutive.
11:44:44 <tty7> theorinf: don't worry. in detail, you'd have to look at several cases i guess, but the general idea is that with a^n b^n a^n b^n due to |qrs| <= n you will always produce something not in the language when pumping
11:44:46 <adimit> pardon.
11:45:01 <kallisti> lukish: for what purpose do you need a list of lists?
11:45:25 <kallisti> lukish: you may be able to simply use pattern matching within a recursive function to get n-elements at a time.
11:45:33 <tty7> theorinf: that won't work either, because a 'b' in both q and s will force r to have a minimum of n letters
11:45:33 <kallisti> f (x:y:xs) = ...
11:45:34 <kallisti> for example.
11:45:50 <tty7> and qrs will be longer than n letters then, as |qs| > 0
11:45:58 <theorinf> tty7: ah ok so here the 'n' is what decides about possible and unpossible things
11:46:05 <kallisti> :t splitEvery
11:46:06 <lambdabot> Not in scope: `splitEvery'
11:46:11 <kallisti> @hoogle splitEvery
11:46:11 <lambdabot> No results found
11:46:15 <tty7> yeah, somehow.
11:47:43 <tty7> the point is, that you have to pump different letters in q and s (e.g. q = a^k and s = b^j) or you have qrs = a^k or qrs = b^k, so you pump inside one 'half' of the word
11:48:53 <adimit> http://hackage.haskell.org/packages/archive/split/0.1.4.2/doc/html/Data-List-Split.html#v:splitEvery
11:49:13 <adimit> lukish: ^ that's probably more like what you want.
11:49:56 <lukish> Ok
11:51:03 <theorinf> tty7: ok, I finally got this...  :D thanks
11:51:13 <adimit> curious that hoogle doesn't have split indexed‚Ä¶
11:51:25 <tty7> :) no problem
11:52:50 <byorgey> adimit: you can always add "+pkg" to a Hoogle query to get it to look in pkg
11:52:56 <byorgey> so e.g. "+split"
11:53:08 <byorgey> but that doesn't help if you don't already know you want the split package.
11:53:48 <byorgey> hoogle doesn't search in all of Hackage by default.  I don't know how the "default" set of packages for Hoogle search gets chosen.
11:53:59 <adimit> byorgey: that was gonna be my question :-P
11:54:11 <luite> is there no public instance that does search everything by default?
11:54:17 <byorgey> hayoo does
11:54:23 <adimit> why doesn't it search in all of hackage by default? doesn't seem to be too difficult.
11:54:33 <adimit> hayoo++
11:54:37 <byorgey> too slow? too much information? I'm not sure
11:54:40 <koeien3> yes i prefer hayoo for that reason
11:57:25 <Palmik> koeien3, what about going back (in the browser) with Hayoo? Does not that bother you?
11:58:13 <koeien3> no, but i can see why it does
11:59:20 <eyebloom> Hi, is anyone currently maintaining the qtHaskell bindings?
12:04:27 * hackagebot xattr 0.6.0 - Haskell extended file attributes interface  http://hackage.haskell.org/package/xattr-0.6.0 (DeianStefan)
12:24:28 * hackagebot haskell-src-meta 0.5.1 - Parse source to template-haskell abstract syntax.  http://hackage.haskell.org/package/haskell-src-meta-0.5.1 (BenMillwood)
12:42:10 <Rc43> Hi, guys.
12:42:23 <Rc43> Is there a type like tuple, but unordered?
12:42:41 <ksion> Set?
12:42:42 <c_wraith> Seems really hard to get to work with the type system
12:42:47 <davean> Rc43: How would that work and what would it be like?
12:42:48 <Rc43> ksion, too big
12:43:02 <c_wraith> "each of these elements is going to be one of these types, maybe?"
12:43:17 <otters> why would you want an unordered tuple?
12:43:20 <Rc43> (a,b) == (c,d) = a == c && b ==d || a == d && b == c
12:43:39 <Rc43> otters, unoriented edge in a graoh, just wnat to get light code
12:43:44 <Rc43> *graph
12:43:52 <byorgey> Rc43: makes sense, but there isn't one
12:43:59 <byorgey> in fact, such a type would be impossible to implement in Haskell.
12:44:10 <ksion> Rc43: For edge, define a newtype of (a,b) and appropriate instance of Eq.
12:44:11 <Rc43> byorgey, ?
12:44:26 <Rc43> ksion, yeah, but it is 2 lines of code :)
12:44:45 <ksion> Ekhm ;)
12:45:10 <byorgey> Rc43: if you just want an instance of Eq that compares them both ways, then sure.  But there's no way for Haskell to prevent you from observing which element is actually stored first.
12:45:50 <Rc43> byorgey, what is meaning of "be stored first" ?
12:46:28 <byorgey> well, that's a bad way to put it.
12:47:11 <byorgey> Rc43: well, if (as you said) all you mean is that you want equality testing to not care about the order, then sure, it's easy to implement yourself, and it doesn't already exist
12:47:26 <Rc43> byorgey, ok
12:47:32 <byorgey> there are other possible things one might mean by "unordered tuples"
12:47:35 <byorgey> which is what I was talking about
12:47:54 <Rc43> `(Edge a1 b1) == (Edge a2 b2) = a1 == a2 && b1 == b2 || a1 == b2 && a2 == b1` os ugly :P
12:48:07 <otters> then define an eq instance
12:48:18 <byorgey> that is an Eq instance
12:48:24 <otters> oh
12:48:42 <byorgey> Rc43: sure, but the ugliness is confined to that one line, and then you don't have to worry about it for the rest of your program =)
12:48:49 <davean> you can also just compair the min and maxes of the pair
12:49:06 <rmaurer> I have a process which continually sends things over a channel, and will eventually terminate. I have another process which has the same channel, and also holds the mvar the first one will signal on when it is done. How do I get the other process to continually consume until the mvar is placed without deadlock or polling the channel?
12:49:16 <byorgey> or make a smart constructor that always puts the two elements in a canonical order
12:49:45 <Rc43> davean, yeah, it is prettier
12:50:51 <rmaurer> Essentially, a process produces data on a channel, I want the other process to do stuff to the data that comes out until the first process decides that it is done, and dies
12:51:14 <rmaurer> But at the same time, I'd prefer to not have the second process spin on the channel waiting for input, and would like it to do the smart thing and sleep when there is no input
13:24:11 <nwf> Silly question: with the new ConstraintKinds stuff, is it possible to be polymorphic over constraints that imply another?
13:25:59 <hpc> nwf: like... variadic constraints?
13:26:12 <nwf> That might be one word for it, yes.
13:26:42 <hpc> ie, stuff of kind x -> x -> ... (n times) -> Constraint
13:26:56 <hpc> im gonna go out on a limb and answer instead with "oh god, why" :P
13:27:02 <nwf> Oh, no, more like (Constraint, Constraint)
13:27:04 <hpc> oh
13:27:11 <nwf> Here, lemme hpaste what I'm trying to do.
13:27:15 <cmccann> hpc, for science!
13:27:17 <cmccann> that's why.
13:29:44 <otters> can I match against maxBound in a type-agnostic way?
13:29:48 <otters> in a case statement
13:29:57 <hpc> @src Enum
13:29:57 <lambdabot> class  Enum a   where
13:29:57 <lambdabot>     succ                     :: a -> a
13:29:58 <lambdabot>     pred                     :: a -> a
13:29:58 <lambdabot>     toEnum                   :: Int -> a
13:29:58 <lambdabot>     fromEnum                 :: a -> Int
13:29:59 <lambdabot> [3 @more lines]
13:30:13 <hpc> otters: kinda
13:30:23 <otters> kinda
13:30:25 <otters> elaborate
13:30:29 <hpc> case foo of
13:30:49 <hpc>   x | fromEnum x == fromEnum maxBound
13:30:56 <hpc> er, wait
13:31:00 <hpc> @src Bounded
13:31:00 <lambdabot> class  Bounded a  where
13:31:00 <lambdabot>     minBound, maxBound :: a
13:31:05 <hpc> yeah, that's right
13:31:06 <hpaste> nwf pasted ‚ÄúRestricted polymorphism over constraint implication?‚Äù at http://hpaste.org/63697
13:31:14 <mauke> case foo of x | x == maxBound -> ...
13:31:14 <hpc> compare it to maxBound in a guard
13:31:20 <otters> oh, okay
13:31:24 <nwf> hpc: ^
13:31:27 <hpc> mauke: that needs Eq too :P
13:31:30 <MostAwesomeDude> Does Boundeed require Eq?
13:31:35 <elliott> @src Bounded
13:31:35 <lambdabot> class  Bounded a  where
13:31:35 <lambdabot>     minBound, maxBound :: a
13:31:37 <elliott> no
13:31:37 <lambdabot> elliott: You have 1 new message. '/msg lambdabot @messages' to read it.
13:33:11 <mee> why isn't that Ord a => Bounded a ?
13:33:21 <hpc> because it doesn't need an ordering
13:33:23 <hpc> just bounds
13:33:33 <nwf> hpc: I want some ability to say something like "instance (l -> SymLam) => SymLam (VQ v l) where ..." but I don't have the type-level magic to write a membership function.
13:33:37 <hpc> > minBound :: Float
13:33:37 <lambdabot>   No instance for (GHC.Enum.Bounded GHC.Types.Float)
13:33:38 <lambdabot>    arising from a use of...
13:34:01 <edwardk> nwf: hrmm
13:34:10 <elliott> nwf: What is that constraint supposed to mean?
13:34:31 <mee> what's an example of a bounded, unordered type?
13:34:50 <nwf> It's an attempt to specify "which aspects of the semantics are in use by this VQ" -- i.e. which fragment of the (open) finally-tagless language it needs.
13:34:51 <elliott> floats :P
13:34:51 <mee> @src Ord
13:34:51 <lambdabot> class  (Eq a) => Ord a  where
13:34:52 <lambdabot>     compare      :: a -> a -> Ordering
13:34:52 <lambdabot>     (<), (<=), (>), (>=) :: a -> a -> Bool
13:34:52 <lambdabot>     max, min         :: a -> a -> a
13:34:53 <qpu> enums
13:35:23 <otters> guys, help: https://gist.github.com/1831152
13:35:24 <nwf> Before I was having to have different types for each subset of language features.
13:35:27 <otters> everything is explained in the gist
13:35:29 <edwardk> nwf: i have a similar dsl lying around, one sec
13:36:30 <cmccann> otters, you need to constrain maxBound to have the same type as y
13:36:33 <cmccann> :t asTypeOf
13:36:34 <lambdabot> forall a. a -> a -> a
13:36:34 <edwardk> hrmm the version on github is old. bah
13:36:37 <otters> hmm
13:36:41 <cmccann> @src asTypeOf
13:36:41 <lambdabot> asTypeOf = const
13:36:47 <edwardk> https://github.com/ekmett/grid/blob/master/Data/Distributed/Symantics.hs has the old one, let me dig up something more current and push it
13:36:51 <otters> but type constrained
13:36:52 <otters> okay
13:38:25 <nwf> edwardk: Yeah, like that, but with multiple Symantics classes.  If I'm not crazy, the set of classes needed needs to be a type parameter (and thus the reliance on ConstraintKinds).
13:38:45 <otters> yay, new error
13:38:46 <otters> https://gist.github.com/1831220
13:38:51 <edwardk> yes
13:38:54 <edwardk> thats what i'm uploading =)
13:39:00 <nwf> Whoo! :)
13:39:11 <otters> oh, wait
13:39:13 <otters> hahaha
13:39:16 <otters> never mind
13:39:19 * otters stupid
13:39:20 <mee> I had a feeling you were going to say that... ;) but what part of Ord doesn't make sense for floats? also there appears to be an instance in GHC.Float
13:39:33 <nwf> mee: NaN does not compare to NaN.
13:39:53 <nwf> There is an instance but it's not really a full ordering; the instance is a lie of convenience.
13:39:53 <mee> ah, ok
13:40:40 <edwardk> https://github.com/ekmett/grid/blob/master/Grid/Symantics.hs starts to break down the symantics further
13:40:56 <edwardk> and this is where i introduce function symantics https://github.com/ekmett/grid/blob/master/Grid/Exp.hs
13:41:01 <otters> well that was easy
13:41:51 <nwf> edwardk: Do you define instances on Closed anywhere?
13:41:52 <edwardk> but i have a more limited notion of function application because i don't expose values of type Exp (a -> b) to the user, only Exp a -> Exp b 's which may have been built by fun, that way i can always expand any applications fully if i'm forced to for compiling to say, openCL where i lack recursion
13:42:01 <mee> How does NaN make sense with Bounded? seems to have the same problem
13:42:05 <edwardk> not at present
13:42:15 <nwf> edwardk: Ah; that is the bit that is giving me trouble.
13:42:28 <edwardk> this was more of a sketch of how thin i could make a finally tagless dsl
13:42:53 * nwf nod
13:43:14 <qpu> also, why isn't maxBound::Float = 1.0/0.0 (Infinity)?
13:43:28 <eyebloom> Am I right in thinking that the qtHaskell binding project has been abandoned?
13:43:45 <elliott> i think so
13:43:47 <dmwit> There's a maxBound::Float?
13:43:51 <dmwit> > maxBound :: Float
13:43:52 <lambdabot>   No instance for (GHC.Enum.Bounded GHC.Types.Float)
13:43:52 <lambdabot>    arising from a use of...
13:44:00 <dmwit> qpu: because
13:44:02 <qpu> no, but i don't know why not
13:44:09 <dmwit> qpu: because NaN
13:44:13 <elliott> edwardk: nice tower of extensions
13:44:23 <edwardk> elliott: =)
13:44:25 <dmwit> > 0/0 :: Float
13:44:26 <lambdabot>   NaN
13:44:36 <eyebloom> It also doesn't appear to be hosted on github or sourceforge.
13:44:37 <edwardk> now that polymorphic kinds work i can extend it further ;)
13:44:44 <dmwit> > (0/0 > 1/0, 1/0 > 0/0)
13:44:45 <lambdabot>   (False,False)
13:44:50 <edwardk> > maxBound :: Float
13:44:51 <lambdabot>   No instance for (GHC.Enum.Bounded GHC.Types.Float)
13:44:52 <lambdabot>    arising from a use of...
13:45:22 <nand`> > (0/0 == 0/0)
13:45:22 <lambdabot>   False
13:45:26 <dmwit> It is not true that 1/0 > x for all x :: Float. =)
13:45:38 <edwardk> > (0/0) < (1/0)
13:45:39 <lambdabot>   False
13:45:53 <Azel> NaN doen's compare lower than infinity and neither does it compare greater than -infinity (IEEE semantics)
13:46:03 <edwardk> Float instances are generally all screwed up because they try to comply with ieee 754
13:46:33 <edwardk> also a more useful general 'upper bound' is often the max representable positive but non infinite value
13:46:42 <qpu> dmwit: fair enough. but why not make Ord a superclass of Bounded?
13:46:44 <edwardk> since you can't derive that constant easily by other means
13:47:12 <edwardk> qpu: because you may have a partial order which still has upper and lower bounds
13:47:41 <edwardk> and we simply don't have a class for talking about partial orders
13:47:50 <cmccann> sure we do, Ord
13:47:53 <cmccann> just look at Float
13:47:54 <cmccann> :P
13:47:58 <dmwit> heh
13:48:04 <cmccann> can't argue with that, can you
13:48:06 <qpu> oh, forgot Ord is total order... kinda :]
13:48:26 <ddarius> Float's instance isn't a partial order or even a preorder.
13:48:38 <mee> ah ok, so the problem is that Ord suggests a total ordering
13:48:39 <dmwit> Solution: take away the Ord instance for Float/Double.
13:48:56 * cmccann shouldn't get into this discussion yet again
13:49:04 <Azel> At the very least, take away the Enum one
13:49:08 <copumpkin> I think Eq on Float is a PER isn't it?
13:49:12 <elliott> just fix Float's Ord instance
13:49:17 <elliott> who cares about IEEE
13:49:18 <dmwit> Real solution: make all operations on Float/Double have IO return-types.
13:49:25 <elliott> dmwit: Float :: IO *
13:49:27 <qpu> hooray!
13:49:29 <ddarius> copumpkin: No.  Eq is total on (defined) Floats.
13:49:38 <elliott> main ::<- { flt <- Float; return (IO flt) }
13:49:38 <ddarius> You could induced a PER that would make it sane probably.
13:49:39 <copumpkin> ddarius: yeah, but it isn't reflexive on NaN
13:49:54 <ddarius> copumpkin: It isn't reflexive, but it is defined.
13:50:03 <copumpkin> I thought PER was symmetric, transitive, but not reflexive
13:50:08 <copumpkin> and didn't mention anything about totality
13:50:35 <edwardk> its total, but not reflexive
13:50:36 <edwardk> yeah
13:50:54 <tgeeky> dmwit: wouldn't that mean we'd immediately want a Float monad (or transformer?)
13:50:56 <Azel> copumpkin: Which is totally normal: two NaN might arise for wildly different reasons
13:51:03 <ddarius> copumpkin: I guess.
13:51:07 <copumpkin> Azel: yeah, I wasn't commenting on that bit :)
13:51:11 <dmwit> tgeeky: Maybe, but the IO monad seems monad-y enough for me.
13:51:36 <dmwit> (+.) :: Float -> Float -> IO Float
13:51:38 * copumpkin just had a chunk of flesh cut out
13:51:40 <tgeeky> dmwit: well, it feels like sort of giving up the baby with the bathwater.
13:51:55 <dmwit> tgeeky: But, I mean, you can't really get around it.
13:52:01 <edwardk> there was some discussion that blew up for technical reasons about just using signally nan's everywhere, which would let double's actually have real equivalence
13:52:02 <Azel> copumpkin: Sorry about that then...my collegues must have worn me out...
13:52:08 <copumpkin> :)
13:52:15 <dmwit> tgeeky: A call to a C function might change the semantics of (+)! That screams IO to me.
13:52:16 <edwardk> (well, not structural because there is still the -0 vs +0 distinguishability issue)
13:52:17 <tgeeky> dmwit: what is the starting point for this line of argument, I didn't see it?
13:52:24 <ddarius> copumpkin: Hopefully not a chunk of flesh you were using.
13:52:44 <edwardk> dmwit: well, a call to a c function can also totally break sin, cos, etc. as well =)
13:52:48 <copumpkin> ddarius: I don't think I was using it, but I'm not supposed to do anything particularly active for a little while
13:52:50 <dmwit> tgeeky: IEEE has all kinds of wacky exception-handling state.
13:52:58 <dmwit> edwardk: Yes, sin :: Float -> IO Float, too, please.
13:53:08 <dmwit> sinf, if you want
13:53:09 <ddarius> copumpkin: I guess I shouldn't bring my kettlebell over then.
13:53:14 <edwardk> *twitch*
13:53:29 <copumpkin> ddarius: not just yet
13:53:30 <ddarius> dmwit: That would let us handle setting rounding modes "easier."
13:53:42 <cmccann> > 1/0 == 1/(-0)
13:53:43 <lambdabot>   False
13:53:44 <edwardk> copumpkin: where'd the zombie get you? and did they remove the flesh in time?
13:53:47 <cmccann> yay, floats
13:53:56 <edwardk> or will you come into the office tomorrow moaning brraaaaaains?
13:54:05 <cmccann> he doesn't do that anyway?
13:54:14 <Azel> cmccann: Isn't that Infinity /= -Infinity ?
13:54:15 <copumpkin> edwardk: on the shoulder, just a mole :) but I might consume braaaaaiiiins anyway
13:54:21 <edwardk> ah
13:54:24 <cmccann> Azel, yes
13:55:05 <cmccann> Azel, but it means that you have (x/y) /= (x/z) where y == z
13:55:14 <cmccann> > 0 == (-0)
13:55:14 <dmwit> > 0 == -0
13:55:15 <lambdabot>   True
13:55:15 <lambdabot>   True
13:55:16 <mee> seems better to me to have the base Float type be arbitrary-precision decimal like (Integer,Integer) and have the IEEE-like type be special. But I realize the  impracticality of that
13:55:26 <Azel> Oh, was forgetting...IEEE floats have negative zero...useful in some fields but a pain in almost any other setting...
13:55:27 <otters> > -0
13:55:28 <lambdabot>   0
13:55:50 <dmwit> mee: Yeah, deciding (==) is tricky for the most efficient arbitrary-precision decimals.
13:55:55 <edwardk> mee: there is an ieee standard for decimal floats as well
13:56:19 <edwardk> azel: you really can't omit them though, without destroying the usefulness of infinity
13:56:22 <dmwit> > 50.0000000000000000000000000000000000000001 == (50 :: CReal)
13:56:22 <lambdabot>   False
13:56:28 <dmwit> whoop
13:56:42 <c_wraith> more zeroes!
13:56:58 <dmwit> > 50.000000000000000000000000000000000000000000000000001 == (50 :: CReal)
13:56:59 <lambdabot>   True
13:57:23 <edwardk> azel: they aren't as obscure as you might think when things gradually underflow
13:58:00 <cmccann> floats are designed for useful calculations on approximate values, which turns out to not coincide well with basically any sensible property one would expect of numbers
13:58:09 <tgeeky> mee: a small addition to your numeric utopia: why decimal?
13:58:18 <dmwit> Yeah, IEEE has a lot of traps to be wary of. But it was also designed carefully enough that they're still the standard decades later.
13:58:20 <ddarius> intervals
13:58:37 <brad_larsen> Hi!  I have a Haskell program that uses the FFI.  I have two C types, call them A and B, both that need finalizers.  However, the finalizers for B must be run *after* the finalizers for A.  The documentation for Foreign.ForeignPtr says scary things about ordering finalizers; I'm wondering what my options are.
13:58:43 <cmccann> which is both why we want relevant instances for floats (because they're useful) and why the instances are always bogus (because they're not really numbers)
13:58:45 <mee> decimal doesn't matter, misspoke
13:58:45 <Azel> edwardk: True...and if I remember correctly, the standard for decimal floating-points number is the 2008 revision of IEEE 754
13:58:48 <elliott> x not being equal to x is inexcusable, however useful the rest of IEEE is.
13:59:09 <elliott> Yeah, yeah, it's "not a number", but it's still a member of the type, you can't just exempt yourself from the rules like that.
13:59:21 <edwardk> yep
13:59:24 <cmccann> > let x = 0/0 in compare x x
13:59:25 <lambdabot>   GT
13:59:28 <cmccann> yay
13:59:31 <dmwit> brad_larsen: What does it mean to have a finalizer for a type?
13:59:39 <elliott> data MyMonad = NotAMonad | ...
13:59:44 <elliott> it obeys the monad laws so long as you don't use NotAMonad
13:59:47 <otters> x is greater than itself? :O
13:59:53 <elliott> also, standard operations on MyMonad return NotAMonad in lots of situations
13:59:54 <elliott> have fun!
14:00:02 <edwardk> elliott: well, in their defense the majority of platforms don't have the notion of an applicative/maybe/etc to encapsulate that behavior behind
14:00:13 <Azel> > (1/0) > (1/0) :: Float
14:00:14 <lambdabot>   Couldn't match expected type `GHC.Types.Float'
14:00:14 <lambdabot>         against inferred typ...
14:00:19 <elliott> edwardk: yeah
14:00:24 <Azel> > (1/0) > ((1/0) :: Float)
14:00:25 <lambdabot>   False
14:00:26 <elliott> edwardk: I can't think it'd hurt to just allow identical NaNs to compare equal, though
14:00:28 <gwern> so what dep do I need installed for regex-pcre-builtin-0.94.2.1.7.7 ? I even did 'apt-get install libghc-pcre-light-dev  libghc-regex-base-dev libghc-regex-pcre-dev libpcre++-dev libpcre3-dev' but it still fails with 'running dist/build/Text/Regex/PCRE/Wrap_hsc_make failed (exit code 127) command was: dist/build/Text/Regex/PCRE/Wrap_hsc_make  >dist/build/Text/Regex/PCRE/Wrap.hs /usr/bin/hsc2hs returned ExitFailure 1 '
14:00:50 <elliott> (x86 needs applicatives!)
14:01:04 <dmwit> What is an "identical NaN"?
14:01:15 <ddarius> dmwit: There is more than one NaN.
14:01:19 <brad_larsen> dmwit: A and B are C types; in Haskell land, they are represented by ForeignPtr
14:01:20 <edwardk> elliott: the issue is that the anything compared with nan (in either direction) determining false hack allows careful c/fortran code writers to plumb the nan case through their code without any additional computational overhead
14:01:25 <elliott> dmwit: A NaN with the same value stuffed inside it (I forget what it's called).
14:01:32 <edwardk> elliott: allowing them to compare as equal actually forces more code paths
14:01:33 <tgeeky> dmwit: what kind of mathematical structure would dictate that you should expect 50.0(some number of times)1 versus 50.0(some number of times + n)1 have sensible equality -- if you *aren't* talking about approximation?
14:01:44 <elliott> edwardk: yeah
14:01:44 <tgeeky> dmwit: would it be groups or division algebras?
14:01:54 <brad_larsen> dmwit: I register a finalizer to be called when they are garbage collected using addForeignPtrFinalizer
14:01:56 <elliott> edwardk: i'm OK if C does it, not OK if Haskell reuses it for its instance
14:01:59 <edwardk> you can easily cram extra values in NaNs
14:02:04 <elliott> I mean, C is all about operation sthat make no sense :P
14:02:10 <dmwit> tgeeky: The sensible equality just isn't decidable, that's all.
14:02:25 <dmwit> brad_larsen: You can't pass a type to addForeignPtrFinalizer.
14:02:34 <dmwit> (You can't pass a type to anything in Haskell.)
14:02:41 <brad_larsen> dmwit: I'm aware
14:03:01 <dmwit> Yes, so what do you mean when you say you have finalizers for a *type*?
14:03:20 <brad_larsen> dmwit: fine, I add a finalizer to all *values* of two types A & B
14:03:43 <brad_larsen> dmwit: the crux of the matter is about ordering finalizers
14:03:43 <dmwit> And you want all the finalizers for all the values of type A to run before any finalizer for any value of type B?
14:03:51 <brad_larsen> yes
14:03:54 <brad_larsen> well
14:04:01 <brad_larsen> yes
14:04:27 <dmwit> ...
14:04:37 <dmwit> Never run the B finalizers, then.
14:04:38 <ddarius> You can probably find a way to do this, in fact it is not hard, but this is really not something you should be using finalizers for.
14:04:41 <brad_larsen> but what's important is that I want to ensure that a particular finalizer is run before another particular finalizer
14:04:59 <dmwit> That problem sounds much more feasible.
14:05:40 <dmwit> Have the two finalizers involved close over an IORef or some such nonsense.
14:05:40 <brad_larsen> the documentation for Foreign.ForeignPtr makes it sound tough to do correctly
14:05:47 <ddarius> Job Ad: "Ever wanted to command an AI-powered industrial robot with Clojure?"  Me: "No!"  That was quick.
14:06:16 <brad_larsen> "In general, it is not recommended to use finalizers on separate objects with ordering constraints between them. To express the ordering robustly requires explicit synchronisation using MVars between the finalizers, but even then the runtime sometimes runs multiple finalizers sequentially in a single thread (for performance reasons), so synchronisation between finalizers could result in artificial deadlock. Another a
14:06:16 <brad_larsen> explicit reference counting."
14:06:39 <brad_larsen> I'm hoping to avoid using explicit reference counting.
14:06:45 <ddarius> Why?
14:07:04 <brad_larsen> laziness?
14:07:29 <mee> is there a language that tries to have a Real type (‚Ñù). I'd imagine you'd have to have some involved strategies for dealing with nonterminating, nonrepeating numbers like pi like storing them as a generating function or something
14:07:53 <tgeeky> mee: not that I'm aware of, I'd be interested to know the answer
14:07:54 <Sgeo> mee, (sin + cos) ^ 2 $ 5
14:07:58 <rwbarton> > pi :: CReal
14:07:59 <lambdabot>   3.1415926535897932384626433832795028841972
14:08:00 <Sgeo> > (sin + cos) ^ 2 $ 5
14:08:01 <lambdabot>   0.4559788891106301
14:08:05 <Sgeo> > (sin + cos) ^ 2 $ 5 :: CReal
14:08:06 <lambdabot>   0.4559788891106301865952523381486227183164
14:08:11 <Sgeo> oops
14:08:14 <janne_h> Hi, a silly monad question.  I'd like to do Either monad style short-circuiting, but instead of running through all the Right computations, the computation would short-circuit on the first Right and return the value.  Or similarly, the same for Maybe but with exit on first Just instead of Nothing
14:08:23 <Sgeo> > (sin ^ 2 + cos ^ 2) $ 5
14:08:24 <lambdabot>   0.9999999999999999
14:08:28 <Sgeo> > (sin ^ 2 + cos ^ 2) $ 5 :: CReal
14:08:29 <lambdabot>   1.0
14:08:35 <Sgeo> > (sin ^ 2 + cos ^ 2) $ 5 :: CReal == 1
14:08:36 <lambdabot>   Could not deduce (GHC.Float.Floating
14:08:36 <lambdabot>                      ((==) Data.Number...
14:08:38 <otters> that's a very accurate pi
14:08:40 <Sgeo> > (sin ^ 2 + cos ^ 2) $ 5 :: CReal == 1.0
14:08:40 <lambdabot>   <no location info>: parse error on input `1.0'
14:08:52 <Sgeo> > (sin ^ 2 + cos ^ 2) $ 5 == (1 :: CReal)
14:08:53 <lambdabot>   No instance for (GHC.Float.Floating GHC.Bool.Bool)
14:08:54 <lambdabot>    arising from a use of...
14:09:03 <Sgeo> > (sin ^ 2 + cos ^ 2) 5 == (1 :: CReal)
14:09:04 <lambdabot>   True
14:09:10 <Sgeo> That was lulzy
14:09:17 <gwern> hm, and downloading the tarball directly from hackage and I ca compile regex! dammit cabal
14:09:28 <tgeeky> I think there is a misunderstanding of mee's intent
14:09:37 <elliott> janne_h: that's impossible
14:09:39 <Sgeo> mee, CReal does what you want, probably.
14:09:41 <elliott> janne_h: such an implementation wouldn't type
14:09:51 <elliott> janne_h: (>>=) :: Maybe a -> (a -> Maybe b) -> Maybe b
14:09:52 <dmwit> brad_larsen: Have your finalizers write to a Chan. Have a separate thread wait for two writes, then run both finalizers.
14:09:59 <elliott> janne_h: so you can't have (>>=) return its left argument, ever
14:10:20 <c_wraith> dmwit: isn't that a better use for QSemN than a Chan?
14:10:21 <mee> Sgeo: for all /practical/ purposes, probably. I'm intentionally in the weeds here
14:10:29 <dmwit> c_wraith: Probably.
14:10:29 <Sgeo> But you can do things similar to what janne_h wants, just not monadically
14:10:36 <Sgeo> Actually, for Either, why not defined a FlippedEither?
14:10:48 <dmwit> c_wraith: Except I've never heard of QSemN.
14:10:51 <Sgeo> mee, hmm?
14:10:57 <c_wraith> dmwit: it's in the same library...
14:11:07 <janne_h> Sgeo, elliott: kind of what I was wondering about.  Certainly Either or Maybe directly won't work (I tried and failed :))
14:11:20 <Jedai> Wasn't what janne_h described exactly what already happen in Either monad but with Left instead of Right ?
14:11:25 <elliott> janne_h: Well, it doesn't matter what m you pick. It doesn't fit a monadic interface.
14:11:33 <c_wraith> dmwit: http://hackage.haskell.org/packages/archive/base/4.5.0.0/doc/html/Control-Concurrent-QSemN.html
14:11:37 <brad_larsen> dmwit: that's one idea.  I'll think on it.
14:11:42 <elliott> Jedai: Yes, indeed, since the Left argument type is in the non-parametric part.
14:11:45 <elliott> So it works there.
14:11:52 <Sgeo> elliott, Left and Right deserve to be symmetrical, just define a newtype wrapper around it.
14:11:57 <elliott> janne_h: You can get what you want if you're OK with the type arguments being flipped.
14:12:05 <c_wraith> err, QSem would suffice
14:12:36 <Sgeo> mee, CReal is supposed to be an exact real ... thingy
14:12:37 <c_wraith> Oh, no, that needs QSemN
14:12:47 <mee> Sgeo: oh I misunderstood. nm
14:12:50 <Sgeo> (Although I noticed it uses Ints for something internally, which kind of creeps me out)
14:13:00 <Sgeo> I'm not entirely sure what the Int is for
14:13:12 <elliott> Which CReal?
14:13:12 <cmccann> elliott, this acid-state stuff is killing me :[
14:13:14 <janne_h> elliott: if flipping the type args works then what do you mean that "it doesn't fit a monadic interface"?
14:13:16 <dmwit> brad_larsen: Alternately, have your chan receive (Either AFinalizer BFinalizer) and run AFinalizers early when possible.
14:13:18 <elliott> lambdabot's CReal is from numbers.
14:13:19 <Jedai> Sgeo: Well even Integer use Int
14:13:22 <cmccann> where by me I mean my system's memory
14:13:23 <elliott> Not Few Digits.
14:13:33 <elliott> cmccann: you think you have it hard?
14:13:38 <elliott> cmccann: I'm rewriting a 1,000 line file to use blaze-html
14:13:42 <dolio> The Int is for the exponent of the precision you want.
14:13:44 <cmccann> haha
14:13:45 <sipa> > sin
14:13:46 <elliott> with intermixed logic and HTML generation
14:13:46 <lambdabot>   Overlapping instances for GHC.Show.Show (a -> a)
14:13:47 <lambdabot>    arising from a use of `...
14:13:49 <sipa> > sin 5
14:13:50 <lambdabot>   -0.9589242746631385
14:13:53 <sipa> > sin 5 :: CReal
14:13:54 <lambdabot>   -0.9589242746631384688931544061559939733525
14:14:15 <cmccann> elliott, did you give up on the revdeps stuff or did you not even look at it yet?
14:14:15 <Sgeo> dolio, why not an Integer?
14:14:29 <Sgeo> Although iirc even Integers have a fixed range.
14:14:40 <dolio> Because Int is probably faster, and not a practical limitation.
14:14:46 <dmwit> Integers have a range fixed to -2^memsize to +2^memsize, roughly.
14:14:50 <Jedai> sipa: You can ask for more or less decimals, this is just the default for the Show instance
14:16:04 <Sgeo> dmwit, I think, with sufficient memory, the bounds might actually fit in memory?
14:16:18 <dmwit> Sgeo: The bounds of Integer?
14:16:40 <dmwit> Where are you getting this information?
14:16:53 <ddarius> But what if I need to work with numbers that take 2^40 GB to represent?
14:17:28 <dmwit> 2^40 is a lot of gigabytes.
14:17:40 <dmwit> That number may not be representable in our current universe.
14:17:46 <elliott> cmccann: I haven't looked at it yet since you said you were going to :P
14:17:56 <Sgeo> dmwit, I looked at the definition of Integer a while ago
14:18:03 <cmccann> elliott, ok, just wanted to make sure I don't duplicate effort.
14:18:06 <Sgeo> Can't seem to find it now
14:18:10 <rwbarton> @src Integer
14:18:10 <lambdabot> data Integer = S# Int#
14:18:10 <lambdabot>              | J# Int# ByteArray#
14:18:24 <elliott> cmccann: I was planning on just finishing this blaze-html conversion and such to familiarise myself with the codebase
14:18:41 <Sgeo> I forget what the J# represents exactly, but it was that Int# that was bothering me
14:18:42 <cmccann> 'k
14:18:49 <sipa> "Jumbo"
14:18:58 <Sgeo> sipa, what does the Int# hold?
14:19:08 <sipa> no idea
14:19:36 <tromp__> > let g 0=succ;g m=iterate(g(pred m))>>=(!!) in map g [0..]
14:19:37 <lambdabot>   Overlapping instances for GHC.Show.Show
14:19:37 <lambdabot>                              (GHC.T...
14:19:46 <c_wraith> Int# is the primitive unboxed type...  that is, it's the machine word itself
14:19:54 <Sgeo> c_wraith, I know that
14:20:09 <Sgeo> I'm asking about representing large numbers with an Int# and a ByteArray#
14:20:14 <Sgeo> What does the Int# hold.
14:20:19 <Jedai> So there's a practical limit but from what I can see, it's probably the same as the size of the memory that can be adressed by the OS anyway... (kidding, I'm pretty sure that Linux can adress a lot more than that now)
14:20:20 <qpu> size of the byte array?
14:20:30 <tromp__> > let g 0=succ;g m=iterate(g(pred m))>>=(!!) in [g i i|i<-[0..]]
14:20:30 <rwbarton> either the size in bytes or the size in words, I forget
14:20:31 <lambdabot>   [1,2,8,*Exception: stack overflow
14:20:40 <c_wraith> Sgeo: oh, you mean in the J# constructor
14:20:44 <Sgeo> c_wraith, yes
14:20:47 <elliott> Sgeo: the number of things
14:20:50 <elliott> i forget their name
14:20:54 <elliott> splines or something, gmp term
14:20:55 <c_wraith> Sgeo: I believe it's the size of the ByteArray#
14:20:56 <dolio> Limbs?
14:20:58 <elliott> yes
14:21:04 <elliott> which corresponds to the number of "digits" in some huge base, I believe
14:21:09 <elliott> (not quite INT_MAX but close)
14:21:18 <Sgeo> If there's a finite number of splines, then the number of numbers an Integer can hold is finite.
14:21:18 <c_wraith> Sgeo: because before some recent ghc version, there wasn't a primitive to get the size of a ByteArray#
14:21:23 <Jedai> Sgeo: Still, if you need more than (2^64)^(2^64), you're probably in bad shape anyway
14:21:28 <elliott> right, yes, that's what a limb is
14:21:34 <elliott> Sgeo: You don't need an Int# for that.
14:21:36 <elliott> Sgeo: ByteArray# is a pointer.
14:21:42 <tromp__> g 4 4 takes much more than 2^40GB to write down
14:21:43 <elliott> Pointers are exactly as finite as integers are.
14:22:20 <elliott> Sgeo: I could also point you to approximately 1,000,000,000,000,000 other places in the GMP/RTS code that assume your platform is finite...
14:22:39 <dmwit> tromp__: g 4 4 is bigger than 2^(2^70)?
14:22:44 <tromp__> g 3 3 fits in 48MB though...
14:22:54 <Sgeo> So, Haskell is not suitable for the computer in the Sam Hughes story that can do infinite number of computations in finite time?
14:22:55 <tromp__> yes
14:23:01 <dmwit> wow
14:23:20 <elliott> *GHC/RTS
14:23:21 <ddarius> Sgeo: No, a single Integer is not suitable.
14:23:21 <elliott> Sgeo: Yes, because GHC is Haskell.
14:23:28 <rwbarton> what makes you think that computer has 64-bit Int#s
14:23:58 <elliott> Sgeo: That Integer definition appears nowhere in the Report.
14:24:00 <dmwit> elliott: "Pointers are exactly as finite as integers are" is misleading.
14:24:17 <dmwit> elliott: I can store much more data behind a pointer than I can store inside an integer of equal bitsize.
14:24:23 <elliott> dmwit: Finiteness is a boolean!
14:24:25 <Sgeo> Hmm, does GHC violate the report?
14:24:34 <Sgeo> Even with LANGUAGE Haskell98 or Haskell2010
14:24:37 <Jedai> Wait, that's a ByteArray, so assuming you can only use 7 bits on each Byte, the maximum representable should be on the order of 2^(7*2^64)
14:24:37 * hackagebot weighted-regexp 0.3.1.2 - Weighted Regular Expression Matcher  http://hackage.haskell.org/package/weighted-regexp-0.3.1.2 (SebastianFischer)
14:24:38 <ddarius> elliott: What if you don't have enough space to fit a bit?
14:24:38 <c_wraith> Sgeo: not on existing hardware.
14:24:45 <c_wraith> Sgeo: at least, not in that way.
14:24:46 <elliott> Sgeo: Yes, Eq and Show are not superclasses of Num.
14:24:50 <elliott> Even with Haskell2010.
14:24:52 * ddarius uses F_1 for all calculation.
14:24:53 <tromp__> @pl \x -> g x x
14:24:54 <lambdabot> join g
14:24:58 <elliott> ddarius: That's just a really True-y boolean of finiteness.
14:24:59 <dmwit> elliott: I can define type Integer = [Bit] and have a (very inefficient) representation of unbounded integers that depends on memory size and not word size.
14:25:08 <dmwit> um
14:25:21 <dmwit> Yes, okay, I see what your point is. =)
14:26:11 <elliott> I mean that you don't need to appeal to Int# to prove that GHC isn't infinity sacle.
14:26:12 <elliott> *scale
14:26:17 <dmwit> right
14:26:34 <dmwit> I'm with you now. It just took me a bit longer to get there than it took you. =)
14:26:43 <elliott> That's because you're not infinity scale.
14:26:55 <dmwit> Is /dev/null infinity scale?
14:26:56 <dolio> If the integer is for counting the number of things you're storing, then pointers aren't that much bigger.
14:27:03 <dolio> Which is what the Int# is doing there.
14:27:03 <elliott> dmwit: No, but /dev/zero is.
14:27:21 <dolio> Except the sign bit is wasting space.
14:27:30 <elliott> dolio: No.
14:27:32 <c_wraith> Still, I don't don't that Int# is necessary in newer GHC versions
14:27:33 <elliott> dolio: GMP uses it for the sign.
14:27:37 <elliott> Yes, seriously.
14:27:42 <dolio> Oh, right, forgot.
14:27:53 <elliott> c_wraith: see ^
14:27:57 <c_wraith> whoa
14:28:00 <c_wraith> ok, that's bizarre
14:28:00 <elliott> I guess you could replace it with a boolean.
14:28:04 <elliott> But it'd take the same amount of space.
14:28:07 <c_wraith> yeah
14:28:10 <wavewave> hi.
14:28:13 <elliott> Unless you packed it.
14:28:15 <elliott> Which would be ridiculous.
14:28:31 <dolio> I don't think GHC has any way of packing it.
14:28:31 <rwbarton> could split the J# constructor according to sign
14:28:39 <dolio> Not into a single bit, anyway.
14:28:51 <c_wraith> J+# and J-#
14:28:53 <wavewave> I almost determined new name of hxournal
14:28:54 <c_wraith> terrific names
14:29:11 <wavewave> creampad
14:29:22 <dolio> Yeah, I guess they've already spent several bits on the constructor.
14:29:37 * hackagebot redis 0.12.1 - A driver for Redis key-value database  http://hackage.haskell.org/package/redis-0.12.1 (AlexanderBogdanov)
14:30:17 <NihilistDandy> wavewave: I'm surprised GHC would build that (http://www.creampad.com/). Are you using the HEAD build?
14:30:20 <elliott> rwbarton: oh, that would actually be a good idea
14:30:34 <elliott> I guess it'd be like a five thousand line patch to GHC to change Integer, though
14:30:44 <NihilistDandy> They've really gotten easygoing about their definitions of side effects~
14:30:51 <wavewave> NihilistDandy:  I haven't installed ghc 7.4 yet..
14:31:03 <NihilistDandy> joke...
14:31:11 <elliott> http://www.creampad.nl/images/referentie1.jpg
14:31:13 <tgeeky> wavewave: I would advise against that :)
14:31:16 <c_wraith> elliott: would it?  There are already two different implementations.  That means everything outside of them is abstracted.
14:31:29 <elliott> c_wraith: Oh, hmm, you're right.
14:31:38 <wavewave> tgeeky: yeah. I am waiting for haskell platform.
14:31:38 <elliott> c_wraith: OK, my new excuse is that I'd have to benchmark it and stuff.
14:31:48 <c_wraith> elliott: well that convinces me
14:32:32 <wavewave> I am now designing gadget system...
14:33:18 <wavewave> ruler, pallette which always shows on the canvas when turned on.
14:34:57 <wavewave> NihilistDandy: I am a little worrying about trademark issue about creampad.. probably it's okay if it is so different.
14:35:33 <NihilistDandy> mmhmm
14:36:14 <wavewave> anyway~~
14:36:16 <tgeeky> wavewave: I meant, against the name 'creampad'
14:36:46 <wavewave> tgeeky: what's the reason?
14:37:07 <wavewave> tgeeky: ah.. that legal issue?
14:37:11 <tgeeky> wavewave: that juvinile people exist
14:37:34 <tgeeky> though probably that too, knowing the bark and bite of Apple's dogs
14:39:46 <wavewave> tgeeky: hmmm... i see.. i have to think about it.. KreamPad is another idea but it looks like KDE project. Thanks.
14:53:58 <whitewizzard> hi I am having an issue getting some code to work
14:54:29 <whitewizzard> insertInAll a xs = map (a:) xs insertInAll a xs = map (a:) xs insertInAll a xs = map (a:) xs insertInAll a xs = map (a:) xs
14:54:37 <whitewizzard> sorry about that
14:54:41 <whitewizzard> insertInAll a xs = map (a:) xs
14:55:10 <elliott> That code types. What is the problem?
14:55:27 <whitewizzard> I think this should work to insert the element a before every list element in xs
14:56:02 <RichyB> With what you have written there, xs is a list of lists.
14:56:08 <RichyB> Each list has the same type as a.
14:56:22 <RichyB> And your function adds the element a to the start of each of those lists.
14:56:37 <whitewizzard> I am using http://codepad.org and I keep getting ERROR line 3 - Syntax error in declaration (unexpected `}', possibly due to bad layout)
14:56:45 <whitewizzard> http://codepad.org/iuapiJU4
14:56:56 <RichyB> > let insertInAll a xs = map (a:) xs in insertInAll 5 [ [1,2], [3,4] ]
14:56:57 <lambdabot>   [[5,1,2],[5,3,4]]
14:56:58 <elliott> whitewizzard: You put an expression at top-level.
14:57:00 <elliott> You can't do that.
14:57:03 <elliott> Define a "main" function instead.
14:57:04 <elliott> For example:
14:57:09 <elliott> main = print (insertInAll 3 [['a'],[],[4]])
14:57:13 <elliott> *"main" definition
14:57:17 <elliott> (main isn't a function.)
14:57:44 <elliott> whitewizzard: I would recommend downloading the Haskell Platform so you can experiment with GHCi; it'll be a lot more pleasant than codepad.
14:59:54 <whitewizzard> okay, is there any way to not worry about the types in haskell?  or do the list always have to be the same type
15:00:26 <whitewizzard> aka is [ 1,"Asdf", 4, [4]] legal code?
15:00:52 <int-e> no there isn't
15:01:13 <elliott> whitewizzard: no, Haskell is all about thinking about the types :P
15:01:25 <elliott> whitewizzard: the fact that that is not legal code is a good thing, however
15:01:42 <elliott> it ensures that your code makes sense, and the compiler tells you if it doesn't, without having to wait until runtime to find out it's broken
15:02:04 <sipa> whitewizzard: which doesn't mean it is impossible to things of different types in one list
15:02:09 <sipa> but it becomes a bit more complex
15:02:17 <elliott> not much more complex
15:02:25 <elliott> data Elem = IntElem Int | StringElem String | ListElem [Elem]
15:02:36 <tromp__> why is the #php channel invitation only?
15:02:47 <sipa> but you should first know why you'd want different types in one list
15:03:02 <int-e> tromp__: ##php
15:04:12 <tromp__> thanks, int-e
15:04:59 <whitewizzard> thanks, that helps a bit
15:04:59 <tromp__> cannot join that either (need to be identified with services)
15:05:20 <tromp__> anyway, i was shocked by http://codepad.org/l2jJiLIx
15:05:33 <tromp__> and more shocked when changing 9 to 10
15:05:46 <mux> so happy: it was easy as pie to add an optional member function to my FromBencode type class so that I can remap accessor names, so that I can use the generic interface with dictionary keys such as "created by" that I can't use directly as haskell identifiers
15:05:58 <elliott> tromp__: identify with services, then
15:06:19 <sipa>  tromp__ what happens then?
15:06:25 <elliott> that one doesn't surprise me
15:06:26 <int-e> hehe. bash: php: command not found
15:06:39 <elliott> declarations "spread" like that in many dynamic languages
15:06:58 <tromp__> http://codepad.org/SHzR4nkR
15:07:02 <elliott> in Ruby for instance whether an identifier is a function is similarly contagious, but not the function's definition itself...
15:07:12 <elliott> tromp__: wat
15:07:27 <mux> I'm actually surprised aeson doesn't offer such a functionality
15:07:34 <elliott> http://codepad.org/P2sl9v6x
15:08:22 * DanBurton glares at the PHP posts
15:08:52 <tromp__> wonder what property of numbers is being tested there
15:09:44 <int-e> tromp__: odd, my cli php prints 9one for the version with 9.
15:11:12 <int-e> 5.3.10 though, while codepad uses 5.2.5. oh well. it's php.
15:11:35 <mux> bos: ping
15:12:12 <CondT> Kenny fucking Powers!
15:19:41 * hackagebot leveldb-haskell 0.0.2 - Haskell bindings to LevelDB  http://hackage.haskell.org/package/leveldb-haskell-0.0.2 (KimAltintop)
15:19:43 * hackagebot copilot-sbv 0.5 - A compiler for CoPilot targeting SBV.  http://hackage.haskell.org/package/copilot-sbv-0.5 (LeePike)
15:24:26 <rwbarton> looks like it prints one or two depending on how many characters of source code precede the first function definition
15:25:03 <rwbarton> maybe there's a hash table from source position to function involved?
15:28:06 <rwbarton> pretty amazing bug in any case
15:31:13 <whitewizzard> can someone explain what happens that makes this work?
15:31:13 <whitewizzard> duplicate xs = foldr mydouble [] xs            where mydouble x y = x : x : y
15:31:59 <whitewizzard> i think it is  passing in the empty list as y, but am not sure
15:32:21 <elliott> whitewizzard:
15:32:24 <elliott> > foldr f [] [a,b,c,d]
15:32:25 <lambdabot>   No instance for (SimpleReflect.FromExpr [a])
15:32:26 <lambdabot>    arising from a use of `e_1'...
15:32:27 <elliott> argh
15:32:29 <elliott> > foldr f z [a,b,c,d]
15:32:30 <lambdabot>   f a (f b (f c (f d z)))
15:32:38 <elliott> in this case, z = [] and f = mydouble
15:32:39 <elliott> so it's
15:32:49 <CondT> diff ebtween foldl and foldr?7
15:32:51 <elliott> mydouble a (mydouble b (mydouble c (mydouble d []))))
15:32:54 <elliott> (for a four-element list)
15:32:54 <CondT> :t foldl
15:32:55 <lambdabot> forall a b. (a -> b -> a) -> a -> [b] -> a
15:32:59 <CondT> :t foldr
15:33:00 <lambdabot> forall a b. (a -> b -> b) -> b -> [a] -> b
15:33:04 <rwbarton> oh wow, I misread "work" as "doesn't work" and proceeded to get really confused
15:33:05 <elliott> whitewizzard: which is a : a : (b : b : (c : c : (d : d : [])))
15:33:09 <kallisti> elliott: http://donsbot.wordpress.com/2008/06/04/haskell-as-fast-as-c-working-at-a-high-altitude-for-low-level-performance/   have you read this?
15:33:26 <DanBurton> CondT: foldr simply replaces "cons" and "nil" with the things you specify
15:33:42 <elliott> whitewizzard: so yes, mydouble is called with y = [] at the end of the list
15:33:50 <DanBurton> CondT: foldl is more like a for loop, that gathers an accumulated value by traversing the list from left to right
15:33:53 <elliott> kallisti: I think so.
15:34:01 <elliott> CondT:
15:34:04 <elliott> > foldr f z [a,b,c,d]
15:34:05 <lambdabot>   f a (f b (f c (f d z)))
15:34:06 <elliott> > foldl f z [a,b,c,d]
15:34:07 <lambdabot>   f (f (f (f z a) b) c) d
15:34:15 <elliott> "any questions?" :p
15:34:22 <DanBurton> yes, that's the difference ^
15:34:33 <elliott> kallisti: Yes.
15:34:57 <ddarius> > let mydouble = fun "mydouble"; nil = var "[]" in foldr mydouble nil [a,b,c,d] :: Expr
15:34:57 <lambdabot>   Couldn't match expected type `SimpleReflect.Expr'
15:34:58 <lambdabot>         against inferred ...
15:35:46 <ddarius> > let mydouble = fun "mydouble"; nil = var "[]" in mydouble nil :: Expr
15:35:47 <hpc> :t fun
15:35:47 <lambdabot>   mydouble []
15:35:48 <lambdabot> forall a. (SimpleReflect.FromExpr a) => String -> a
15:36:20 <elliott> ddarius: Monomorphism is catching you there, I think
15:36:40 <ddarius> I only need them at monomorphic types.
15:36:45 <elliott> Hmm, right.
15:38:10 <ddarius> > f [] :: Expr
15:38:11 <lambdabot>   f []
15:38:15 <ddarius> I thought so.
15:40:20 <magicman> :t foldr (fun "mydouble") []
15:40:21 <lambdabot> forall a a1. (Show a, Show a1, SimpleReflect.FromExpr [a1]) => [a] -> [a1]
15:40:27 <magicman> :t foldr (fun "mydouble") [a]
15:40:28 <lambdabot>     No instance for (SimpleReflect.FromExpr [Expr])
15:40:28 <lambdabot>       arising from a use of `fun' at <interactive>:1:7-20
15:40:28 <lambdabot>     Possible fix:
15:40:36 <magicman> Err.
15:40:43 <magicman> :t foldr (fun "mydouble") [] []
15:40:44 <lambdabot> forall a. (Show a, SimpleReflect.FromExpr [a]) => [a]
15:40:49 <magicman> :t foldr (fun "mydouble") [] [a]
15:40:50 <lambdabot> forall a. (Show a, SimpleReflect.FromExpr [a]) => [a]
15:41:04 <magicman> > foldr (fun "mydouble") [] [a]
15:41:04 <lambdabot>   No instance for (SimpleReflect.FromExpr [a])
15:41:05 <lambdabot>    arising from a use of `e_1'...
15:41:22 <kallisti> hmm, so if foldl were written in terms of foldr then foldl could take advantage of list fusion right?
15:41:32 <magicman> Riiight.
15:41:45 <kallisti> ???
15:41:49 <magicman> (@lambdabot, not @kallisti, I wouldn't know about that)
15:43:00 <ddarius> kallisti: Not in a meaningful way.
15:43:21 <ddarius> In the best case it would fuse back into what you'd have had you written foldl in the first place.
15:43:42 <parcs`> :t foldr (fun "mydouble") (var "[]")
15:43:43 <lambdabot> forall a a1. (Show a, Show a1, SimpleReflect.FromExpr (Sym a1)) => [a] -> Sym a1
15:43:56 <osager> hi i have a question on the "group" implementation as follows:
15:43:58 <osager> pack (x:xs) = let (first,rest) = span (==x) xs
15:43:58 <osager>                in (x:first) : pack rest
15:43:58 <osager> pack [] = []
15:44:07 <osager> in x:first
15:44:11 <parcs`> :t foldr (fun "mydouble") (var "[]") [a,b,c,d]
15:44:12 <lambdabot> forall a. (Show a, SimpleReflect.FromExpr (Sym a)) => Sym a
15:44:22 <ddarius> Maybe var was wrong.
15:44:26 <osager> isn't there an extra x ?
15:44:39 <kallisti> :t var
15:44:40 <lambdabot> forall a. String -> Sym a
15:44:42 <kallisti> you're using the wrong var
15:44:45 <kallisti> unless you want Sym.
15:44:55 <ddarius> osager: Try it both ways and see what the difference is.
15:45:08 <parcs`> :t foldr (fun "mydouble") (Debug.SimpleReflect.Expr.var "[]") [a,b,c,d]
15:45:09 <lambdabot> Couldn't find qualified module.
15:45:27 <ddarius> :t expr
15:45:28 <lambdabot> Expr -> Expr
15:45:40 <parcs`> :t foldr (fun "mydouble") (Expr.var "[]") [a,b,c,d]
15:45:41 <lambdabot> Couldn't find qualified module.
15:46:09 <osager> ddarius:hi ican see the difference
15:46:17 <osager> ddarus: but i dont get it
15:46:35 <osager> in the code first include the first element
15:47:27 <magicman> > let f (x:xs) = span (==x) xs in f [1,1,1,2,3]
15:47:28 <lambdabot>   ([1,1],[2,3])
15:47:34 <parcs`> foldr (fun "mydouble") (fun "id" []) [a,b,c,d]
15:47:39 <parcs`> > foldr (fun "mydouble") (fun "id" []) [a,b,c,d]
15:47:40 <lambdabot>   Ambiguous type variable `b' in the constraints:
15:47:40 <lambdabot>    `SimpleReflect.FromExpr ...
15:47:59 <parcs`> that's enough spam for today!
15:48:07 <kallisti> :t fun
15:48:08 <lambdabot> forall a. (SimpleReflect.FromExpr a) => String -> a
15:49:05 <osager> let (first,rest) = span(==x) [1,1,2,3]
15:49:19 <CondT> lambdabot is modified ghci?
15:49:21 <osager> first equals [1,1]
15:49:23 <kallisti> > foldr (fun "mydouble") (SimpleReflect.var "[]") [a,b,c,d] :: [Expr]
15:49:23 <lambdabot>   Not in scope: `SimpleReflect.var'
15:49:51 <magicman> osager: Assuming x = 1, yes.
15:49:56 <CondT> anyone here used linear algebra in their jobs?
15:50:03 <magicman> (which is the case with the [1,1,1,2,3] stuff from before)
15:50:31 <ulidtko1> CondT: i'm using linear algebra (besides other cool maths) everyday in my job
15:50:41 <osager> so why is there not an extra element ?
15:50:42 <osager> pack (x:xs) = let (first,rest) = span (==x) xs
15:50:42 <osager>                in (x:first) : pack rest
15:50:42 <osager> pack [] = []
15:50:54 <CondT> ulidko1: and your job is?
15:51:12 <magicman> the (x:xs) part breaks down the list into its first element (now called 'x'), and the rest of the list (now called 'xs').
15:51:21 <ulidtko1> CondT: research software engineer
15:51:24 <osager> yes ?
15:51:26 <osager> and ?
15:51:31 <magicman> So xs is [1,1,2,3]
15:51:38 <osager> ok i get it
15:51:48 <osager> ....
15:52:01 <osager> man it's hard !
15:52:28 <osager> i'm torturing myself by learning haskell
15:52:30 <CondT> ulid: ok, in haskell?
15:52:36 <CondT> guess not
15:52:43 <ulidtko1> unfortunately not :\
15:52:46 <CondT> what do you do?
15:52:59 <ulidtko1> would like to, but not yet
15:53:28 <ulidtko1> CondT, i'm doing R&D in the research department of Viewdle
15:53:33 <ulidtko1> you can google their site
15:53:50 <kallisti> I'm not sure why SimpleReflect isn't visible
15:53:52 <ulidtko1> they're (we're) doing commercial face recognition and other stuff.
15:53:54 <kallisti> :t SimpleReflect.var
15:53:54 <lambdabot> String -> Expr
15:53:57 <CondT> wow computer vision?
15:54:02 <ulidtko1> yeah
15:54:28 <CondT> might have some of that later in my education, image analysis and computer vision
15:55:07 <ulidtko1> CondT, don't miss your signal processing course, if you're into this
15:55:19 <ulidtko1> it's really very fundamental
15:55:34 <ulidtko1> Hey haskellers, what's the fastest "set" datastructure out there? i need the fastest membership testing, a hashmap implementation presumably
15:56:15 <elliott> HashSet from unordered-containers
15:56:27 <CondT> ulid: had a absic signalsd and systems course(which was terrible though), know my transforms really well
15:58:41 <CondT> I dont go to the best uni and the CV and IA vcourse we have have not statistics based stuff in them(like markov fields) isthat a big loss?
16:01:54 <ulidtko> CondT: the most important skill which you really MUST acquire is how to learn things by yourself
16:02:10 <ulidtko> how to search, what keywords to use, how to read what you've found
16:02:54 <ulidtko> how to separate useful and needed right-now  information from other stuff
16:03:28 <ulidtko> this way you won't ever have to worry about missing a lecture or two, or even an entire course: because you can learn it yourself
16:04:44 * hackagebot dimensional-tf 0.1.0.1 - Statically checked physical dimensions, implemented  using type families.  http://hackage.haskell.org/package/dimensional-tf-0.1.0.1 (BjornBuckwalter)
16:08:21 <CondT> yes ty
16:08:56 <quintessence> @src cycle
16:08:57 <lambdabot> cycle [] = undefined
16:08:57 <lambdabot> cycle xs = xs' where xs' = xs ++ xs'
16:10:53 <otters> @src (->) return
16:10:53 <lambdabot> return = const
16:11:53 <osager> hhi CondT, do you find enough math tools in haskell to do computer vision ?
16:15:14 <hpaste> Clint pasted ‚Äúparse error on input `Word16'‚Äù at http://hpaste.org/63700
16:15:30 <Clint> anyone know what that's about?
16:18:07 <mux> oh yeah, it feels soooo good to use the GHC 7.4 (<>) operator for mappend
16:18:19 <mux> no more stinky `B.append` !
16:18:49 * cmccann has been redefining (++) as mappend for a while anyway
16:19:11 <mux> but you have to hide it or you get a warning, uncool
16:19:35 <cmccann> meh, I usually hide and import a bunch of stuff anyway
16:19:48 <cmccann> a lot of the Prelude is dumb and a lot of useful stuff has to be imported
16:20:07 <DanBurton> suppose I want to calculate the sum of an infinite series, accurate to a given number of decimal places. What data type should I use?
16:20:09 <sohum> what's the point of "Equations for ____ have different numbers of arguments"? why can't haskell just pattern-match down the pointed versions and then apply the pointfree version after?
16:21:34 <elliott> sohum:
16:21:48 <elliott> http://stackoverflow.com/questions/8745597/defining-a-function-by-equations-with-different-number-of-arguments
16:21:57 <sohum> elliott: thanks :D
16:22:16 <Rc43> Hi, guys.
16:22:32 <Rc43> I am trying to profile my haskell code.
16:22:46 <Rc43> I see that `read` take >80% time and alloc.
16:22:52 <Rc43> How can I optimize it?
16:22:59 <Rc43> I am parsing ints from file.
16:23:43 <elliott> Rc43: perhaps use ByteString and readInt or such
16:24:01 <Rc43> elliott, thanks, i will try
16:25:58 <rekado> Hi, I've got a question regarding the function listenOn in the Network library.
16:26:47 <rekado> I want to bind the port only to localhost, so that it is not available  from the outside.
16:27:33 <rekado> This seems to be possible with bindSocket in Network.Socket, but I can't seem to construct a valid IP with SockAddrInet
16:29:06 <rekado> What would be the correct invocation of SockAddrInet to construct an address for localhost:3000
16:29:36 <parcs`> rekado: SockAddrInet 3000 16777343
16:29:38 <rekado> I'm currently using (SockAddrInet 3000 0000).
16:30:08 <rekado> parcs`: is there a function to convert a readable tupel to this number?
16:31:36 <BMeph> (\(x,y) -> SockAddrInet 3000 16777343)
16:33:16 <parcs`> rekado: there's inet_addr from Network.Socket
16:33:50 <aBound> Hello all, is there any good books on learning Haskell for a beginner like me?
16:34:17 <c_wraith> depends on the kind of beginner you are.
16:34:26 <c_wraith> @where lyah
16:34:26 <lambdabot> http://www.learnyouahaskell.com/
16:34:34 <c_wraith> That's a good place to start for many people
16:36:31 <aBound> A beginner who has never learned programming. :P
16:37:39 <sm> heh: http://machinegestalt.posterous.com/if-programming-languages-were-cars
16:37:47 <elliott> aBound: learn you a haskell is still a good start
16:38:03 <elliott> aBound: it's appropriately gentle -- and it stops talking about anything to do with other languages quickly
16:38:22 <elliott> aBound: someone who doesn't know any programming is likely to have an easier time at learning Haskell than someone who already knows an imperative language
16:38:54 <parcs`> > 1 `shiftL` 24 + 127
16:38:55 <lambdabot>   Ambiguous type variable `a' in the constraint:
16:38:55 <lambdabot>    `Data.Bits.Bits a'
16:38:55 <lambdabot>      a...
16:39:16 <aBound> I tried grasping a bit of Perl and a few others but some of them can be daunting or cryptic indeed.
16:39:34 <c_wraith> perl has a reputation for cryptic beyond most languages, though.  and often deservedly so.
16:39:40 <c_wraith> Don't hold that against programming in general :)
16:39:43 <aBound> I'll check that book out no doubt.
16:40:29 <aBound> HA! I used to do a bit of html/css I know it isn't programming but heck always nice to know something.
16:40:38 <elliott> I think there's a dead-tree-only book suitable for first-time programmers that people like but I forget what it's called... LYAH should be pretty well-suited, though
16:41:01 <c_wraith> is it Graham Hutton's "Programming Haskell"?
16:41:08 <elliott> yes, I think so
16:41:12 <hpc> LYAH is in dead tree form
16:41:22 <elliott> "-only"
16:41:26 <c_wraith> yeah, looks like Programming Haskell by Graham Hutton is also a good book.
16:41:27 <hpc> oh
16:41:28 <elliott> i.e. counting against it, since it's not available online
16:41:29 <scripts> hi there, i'm a python programmer is there any book or tutorial  like "haskell for programmers" ?
16:41:42 <elliott> scripts: http://www.learnyouahaskell.com/ is aimed primarily at imperative programmers
16:41:46 <c_wraith> (just snagged it off my co-worker's desk, it looks like it's designed for beginners, and I've heard lots good about it)
16:42:06 <elliott> scripts: there's not really much in the way of analogies to Python, so pretty much any learning process is going to involve a mindset shift more than making connections
16:42:10 <hpc> scripts: honestly, "haskell for programmers" would probably read "1. forget everything 2. learn haskell"
16:42:23 <hpc> haskell is way different
16:42:45 <elliott> this channel has a cottage industry of telling people to forget everything then linking them lyah :)
16:42:57 <hpc> it's a good industry
16:43:19 <scripts> way different  you mean the sintax or the "way" of making software ?
16:43:22 <`Jake`> pretty much was I was told a few days ago :-)
16:43:30 <parcs`> > foldl ((+) . (`shiftL` 8)) 0 (reverse [127,0,0,1]) :: Int
16:43:31 <elliott> scripts: the whole structure, semantics and paradigm of the language
16:43:31 <shachaf> c_wraith: Graham Hutton's book is good.
16:43:32 <lambdabot>   16777343
16:43:33 <hpc> scripts: both
16:43:40 <hpc> scripts: you've learned recursion, yes?
16:43:41 <elliott> scripts: not that the syntax is that close too, although haskell is also whitespace-sensitive
16:43:50 <hpc> they give you a cliche "here's recursive factorial"
16:43:51 <parcs`> anyone know if this function exists somewhere?
16:43:55 <elliott> hpc: pfft, recursion is *so* low-level
16:43:56 <shachaf> I recommend Hutton's book if you have access to it (but it's not available for free online, unfortunately).
16:43:56 <scripts> yes i've used recursion
16:43:59 <hpc> "it's just a mental exercise, everyone does it in loops"
16:44:02 <aBound> Good thing for IRC eh. :P
16:44:08 <hpc> in haskell, recursion is EVERYTHING
16:44:09 * elliott disagrees with where this is going
16:44:15 <elliott> Explicit recursion is unidiomatic.
16:44:19 <elliott> (When avoidable.)
16:44:22 <hpc> except what elliott said
16:44:29 <elliott> That would apply better to Scheme or such.
16:44:34 <c_wraith> shachaf: yeah, I just read the first few pages.  Looks like it's very well-designed for teaching the basics of programming
16:44:50 <hpc> we build the basic functions we want up from recursion
16:44:52 <shachaf> c_wraith: Also for teaching Haskell.
16:44:54 <hpc> and then use those to make programs
16:44:55 <shachaf> It's a bit short, though.
16:44:56 <mandaya> Haskell is declarative, you program by saying what something is instead of how to compute something
16:44:59 <hpc> for instance,
16:45:02 <elliott> scripts: Haskell programming is based heavily on composition: building up small higher-order building blocks and composing them together.
16:45:07 <hpc> > map (* 10) [1..10]
16:45:08 <lambdabot>   [10,20,30,40,50,60,70,80,90,100]
16:45:10 <mandaya> that's the best way I've found to explain the difference
16:45:11 <elliott> scripts: But really, the best way to get a grasp of how Haskell programming works is to read LYAH.
16:45:27 <elliott> It's very rewarding but difficult to explain in a soundbite.
16:45:35 <scripts> i will read thanks alot for the info
16:45:45 <scripts> haskell seems pretty interesting
16:45:55 <hpc> it is
16:46:09 <hpc> even if you never use it for any large projects, it will make you a better programmer
16:47:13 <scripts> python is my bread maker so unfortunately i can't use it all the time but i will definitely take a look
16:48:06 <scripts> i kind of used because we have a project that use rabbitmq  and if i'm not mistaken it uses haskell for parallelism
16:48:22 <scripts> that actually is what got my attention to haskell
16:48:57 <hpc> fun
16:49:00 <DanBurton> > sqrt 12
16:49:01 <lambdabot>   3.4641016151377544
16:49:14 <elliott> scripts: RabbitMQ uses Erlang actually.
16:49:19 <elliott> scripts: Oh, your project. OK.
16:49:33 <elliott> Yes, GHC Haskell has excellent support for parallelism and concurrency (two very different things).
16:49:33 <hpc> erlang is cool too, if you need something to learn after haskell
16:50:21 <danmaftei> i'm installing cabal-install manually. i have ghc 7.4.1. dependencies include versions of Cabal, base, and unix that are older than those that come with ghc 7.4.1. is it harmless to install old versions alongside my current ones?
16:50:23 <c_wraith> I'd just love a different syntax for erlang, after learning haskell.
16:50:29 <c_wraith> Prolog syntax is not my ideal
16:50:49 <scripts> sorry i didn't express my self correctly, what i meant is that i used python and rabbitmq for the parallelism but the other programmer in my team write a part of the project in haskell for the asynchronous part
16:50:52 <c_wraith> But the erlang runtime and libraries are both excellent
16:51:27 <elliott> scripts: Right.
16:52:22 <elliott> scripts: You know the async IO stuff that's popular right now? node.js, etc. GHC lets you write normal-looking sequential IO code with threads and translates it into efficient asynchronous IO under the hood, without having to write everything in a deeply-nested chain of callbacks.
16:52:47 <elliott> GHC is really great at concurrency and network programming.
16:53:13 <cmccann> it's also one of I think two languages that have a worthwhile STM implementation
16:53:14 <scripts> woow that is awesome
16:53:45 <scripts> i can write asynchronous apps in python but i will have to use callbacks
16:54:04 <scripts> eventlet make thinks a little easy but either way
16:54:32 <`Jake`> Just to be sure, do you know what GHC is, scripts?
16:55:12 <c_wraith> Yeah, I've used greenlets to write async code in python synchronously...  But it required a lot of work, and being careful to translate everything into greenlets
16:55:16 <elliott> (If not, it's the Glasgow Haskell Compiler, the main implementation of Haskell.)
16:59:58 <cmccann> ugh, I still can't get this thing to run with profiling built in with any amount of data because of whatever is causing GHC to fall over when acid-state starts using all the memory it can find
17:00:13 <danmaftei> since i can't install cabal-install i'm installing packages manually (e.g. unordered-containers). however i can't compile for profiling. i grep'ed the source folder of unordered-containers for 'prof' and didn't find anything. i searched online and found only a few debian/ubuntu packages for an older version. i'm not sure how to proceed
17:00:30 <cmccann> I am getting seriously tempted to switch to an older GHC and try to build it that way
17:01:01 <cmccann> or just start ripping out some of the utterly pointless use of acid-state for piles of basically write-once static data
17:01:20 <cmccann> this is just ridiculous
17:01:56 <elliott> cmccann: I think acid-state has fairly low overhead if you do snapshots, so I'm not sure that would help.
17:02:17 <cmccann> I dunno what the problem is, then
17:02:27 <cmccann> and for some reason the heap profiling doesn't seem to be working
17:02:32 <cmccann> I get blank profiles
17:02:41 <cmccann> and it says it ran for 0 seconds or something
17:02:48 <Gracenotes> if this is Hackage-related, GenericPackageDescription is reeaaly bloated.
17:03:00 <ddarius> cmccann: Be sure to flame Himmelstrup for his incompetence.
17:03:17 * ddarius remembers the days when acid-state was simply defined to be a memory leak.
17:03:18 <cmccann> and half the time if I tweak the runtime options GHC pukes with this strange closure type thing
17:03:26 <Gracenotes> also, GHC doesn't like giving up memory :|
17:03:38 <ddarius> Gracenotes: It's better now.
17:03:44 <cmccann> ddarius, ugh, I'm sure acid-state is fine for what it is, maybe it's not even the problem here anyway
17:03:52 <elliott> Gracenotes: Ah, the scapegoat! Hi!
17:03:55 <elliott> (Just kidding. Mostly.)
17:04:13 <cmccann> I'm mostly getting irritated by GHC exploding on me and not being able to profile anything properly
17:04:14 * cmccann sighs
17:04:21 <Gracenotes> all of the heap. ALL of it.
17:04:24 <elliott> cmccann: Maybe you should report a bug for that evacuate thing.
17:04:31 <cmccann> and sorry, Gracenotes, don't take this personally :T
17:04:48 <ddarius> cmccann: I recommend switching to C++.
17:04:48 <elliott> In GHC, I mean.
17:04:49 <hpc> im glad im sticking to 7.0.4
17:05:08 <cmccann> yeah I probably should, it's happened frequently but not quite consistently enough for me to pin down an easy repro
17:05:24 <cmccann> ddarius, good point, I could get much more consistent crashes that way
17:05:55 <cmccann> and I'd really, really like to know what's up with the profiling
17:06:00 <Gracenotes> I'm not entirely sure what everyone is exactly referring to, but that's okay
17:06:22 <rekado> (poor connection)
17:06:25 <ddarius> Gracenotes: Using C++ for fun and profit.
17:06:29 <elliott> Gracenotes: it gobbles up lots of memory and then dies with a GHC error if you feed it lots of data
17:07:20 <hpc> elliott: sounds like you need to make a smallest example program
17:07:31 <Gracenotes> acid-state isn't so great with bloated data structures. .. and then there's sharding... that might happen someday
17:07:45 <cmccann> Gracenotes, yeah, I can't even load half the package index on my desktop
17:07:51 <ddarius> The one with minimum Kolmogorov complexity?
17:07:55 <elliott> hpc: cmccann is the one experiencing it.
17:08:03 <elliott> hpc: And harrowing down ~a billion lines of code is not exactly easy.
17:08:04 <elliott> *narrowing
17:08:09 <Gracenotes> ddarius: I have used C++ for fun. and once for profit. I mostly use C for profit.
17:08:11 <cmccann> on the full index it seizes up the machine for about 20min until GHC implodes
17:08:31 <hpc> what i meant was, simplest example program that uses acid-state
17:08:36 <Gracenotes> cmccann: how much memory do you have?
17:08:56 <cmccann> 2GB
17:09:50 <Gracenotes> hm. that might be on the lower end. As a workaround, you can mirror things, restart the server, and mirror more things. repeat indefinitely.
17:09:54 * ddarius has used C++ for a lot of fun and also once for profit accidentally.
17:09:56 <elliott> hpc: The Hackage2 codebase is the one with ~a billion.
17:10:13 <cmccann> what I really don't see is why it needs that much memory
17:10:58 <hpc> ddarius: i used perl for work and accidentally started having fun
17:10:59 <cmccann> I mean, the index tarball is what, a few megabytes?
17:11:09 <cmccann> how on earth does that balloon to multiple GIGABYTES?
17:11:33 <cmccann> I mean, sure, it's going to run on something beefier than my machine
17:11:35 <ddarius> Oh ye of little faythe.
17:12:05 <cmccann> but Hackage isn't exactly getting smaller and with that kind of inefficiency I don't know how well it's going to work
17:12:08 <elliott> cmccann: I bet it's just missing a few UNPACK annotations or something.
17:12:18 <cmccann> oh, ok. good idea.
17:12:27 <cmccann> let me put exclamation points everywhere first.
17:12:27 <Gracenotes> look at all of these fields: http://www.haskell.org/ghc/docs/6.12.2/html/libraries/Cabal-1.8.0.4/Distribution-PackageDescription.html
17:12:31 <elliott> To be fair, it's cheap as far as hardware upgrades go just to stick a huge amount of RAM on the Hackage machine.
17:12:31 <cmccann> that fixes most stuff, I hear.
17:12:34 <elliott> But for developer's it's kind of unideal.
17:12:35 <Gracenotes> it's not 7.x, but, whatever.
17:12:38 <elliott> *s
17:12:46 <elliott> Gracenotes: yeah and they're all lazy
17:12:50 <Gracenotes> yep.
17:12:51 <Gracenotes> and Strings.
17:13:03 <Gracenotes> and lots and lots of pointers to [].
17:13:04 <elliott> Gracenotes: yeah I really want to replace all the Strings in this thing
17:13:10 <cmccann> ugh
17:13:13 <elliott> isn't PackageDescription used directly absolutely everywhere though
17:13:19 <elliott> making it incredibly painful to replace
17:13:34 <elliott> (by converting to/from at the Cabal library boundaries)
17:13:41 <Gracenotes> maybe it doesn't need to be loaded all the time.
17:13:50 <cmccann> doesn't seem like most of that even needs to be in memory all the time, really
17:13:51 <cmccann> I mean
17:13:59 <cmccann> a lot of stuff doesn't really change
17:14:04 <cmccann> except when a package is uploaded
17:14:07 <elliott> Gracenotes: that's what I said :P
17:14:14 <elliott> but apparently revdeps absolutely needs the graph in memory at all times or something?
17:14:16 <ddarius> elliott: Yeah, but cmccann's time for free is even cheaper.
17:14:24 <Gracenotes> the stuff that doesn't change can be quite complex, of course
17:14:29 <elliott> ddarius: what? no, we're not working on this
17:14:31 <elliott> we're just complaining about it!
17:14:41 <Gracenotes> elliott: if you want to do it incrementally, as it's currently implemented, yeah.
17:14:49 <ddarius> elliott: Then it's someone else's free time.
17:16:02 <cmccann> my patience and free time are both dwindling and approaching the point of refactoring of the bloody dismemberment variety
17:16:17 <cmccann> because right now I can't even run this well enough with actual data to work on it meaningfully
17:16:30 <ddarius> cmccann: The proof of preservation of semantics of that one is probably interesting.
17:16:55 <Gracenotes> Well, I should note that importing packages introduces space leaks, and restarting the whole damn server brings back the usual startup costs.
17:17:13 <cmccann> yeah I'm also not sure why the whole thing is so monolithic either
17:17:17 <Gracenotes> which should be, in total, within 1.5 GB.
17:17:24 <Rc43> elliott, i am still trying to optimize my program; your advice was nice, it helped, but now I am looking at pure input/output code (commented out logic) and it spends 90mb of memory! It reads lines from one file and writes to another. Input file contains about 300^2 lines of two numbers.
17:17:24 <Gracenotes> ...roughly.
17:17:43 <elliott> Rc43: Make sure you are counting how much it's using at one time not the total allocation figure
17:17:47 <cmccann> it seems kind of weird that the whole thing is tied completely to the main web UI as far as I can tell
17:17:49 <elliott> (which can grow without bound safely)
17:17:54 <cmccann> a lot of it seems like it can and should run independently
17:18:08 <elliott> cmccann: I have entertained at least two (2) thoughts that sound like "let's throw this out and write Hackage3" already (both dismissed in <1s) so far, which is worrying.
17:18:12 <ddarius> It's actually pretty amazing how fast GHC programs can allocate memory.
17:18:12 <cmccann> so that I can, say, work on the web UI and restart that without having to drop everything and reload all the package info
17:18:15 <Rc43> elliott, 55% of whole
17:18:21 <Rc43> (memory)
17:18:39 <elliott> Rc43: Well, hard to say more without seeing the code/profile.
17:18:49 <cmccann> elliott, I don't think any of it needs to be thrown out per se
17:19:06 <hpaste> Rc43 pasted ‚ÄúProfiling‚Äù at http://hpaste.org/63704
17:19:11 <cmccann> but I wasn't entirely joking about the bloody dismemberment refactoring
17:19:35 <cmccann> it's already fairly modular in a "well, but most of the modules depend on each other actually" way
17:19:37 <Rc43> elliott, `generateTest` creates a file that will be read under profiling
17:19:50 <elliott> cmccann: I sort of wish it used an actual MVCy template system.
17:19:51 * hackagebot highlighting-kate 0.5.0.5 - Syntax highlighting  http://hackage.haskell.org/package/highlighting-kate-0.5.0.5 (JohnMacFarlane)
17:19:53 * hackagebot github 0.2.0 - Access to the Github API, v3.  http://hackage.haskell.org/package/github-0.2.0 (MikeBurns)
17:19:54 <cmccann> splitting it up into actually-separate chunks might be a good start
17:20:11 <Gracenotes> cmccann: one of the observations was that HTML is fundamentally not-modular
17:20:15 <elliott> It might be ugly but it'd be a lot easier to delve into.
17:20:24 <Gracenotes> I don't think a templating system would be so bad
17:20:25 <cmccann> eh, MVC-ish template systems have their own headaches as well
17:20:36 <hpaste> Rc43 pasted ‚ÄúProfiling‚Äù at http://hpaste.org/63705
17:20:39 <elliott> Gracenotes: Isn't it better to accept that fundamentally rather than writing page combinators that try to pretend it is?
17:20:46 * elliott doesn't claim to know what went into the design decisions, mind you.
17:20:56 <elliott> It just seems odd to me to make that observation and go down that path anyway.
17:20:56 <cmccann> I mostly would like to not have any UI tied directly to the important part, which is the package repository and managing that
17:21:14 <cmccann> and yes
17:21:21 <cmccann> HTML is inherently anti-modular in multiple ways
17:21:37 <cmccann> anyone who used ASP.NET webforms learned that the hard way
17:22:02 <Gracenotes> features are basically no-UI, except for a basic barebones server in case you want minimalism.
17:22:14 <cmccann> Gracenotes, right
17:22:16 <Gracenotes> which still does require the PackageDescription index
17:22:19 <whitewizzard> how do you use list nub ?
17:22:42 <mike-burns> > nub [1,2,1,1,2,3]
17:22:43 <lambdabot>   [1,2,3]
17:22:45 <mike-burns> Like that.
17:23:02 <cmccann> yes, but having it in smaller pieces would make it easier to tackle the memory-devouring problem
17:23:08 <otters> nub is O(n^2) performance
17:23:10 <otters> IIRC
17:23:19 <cmccann> so yeah
17:23:20 <Gracenotes> the whole server was 700MB in memory at the time, which wasn't so bad, but acid-state interfacing is going to have to get better at strictness or use another database. essentially.
17:23:27 <elliott> FWIW my mental "things to look into" list is: finish conversion to blaze-html, expurgate as many uses of String as possible, switch to something better than Cabal's bloated data types, and separate logic/UI a bit more.
17:23:57 <Gracenotes> yeah
17:23:58 <elliott> For the last one an actual type-safe routes package might be nice, although there seems to be something trying to approximate it in the codebase already.
17:24:07 <whitewizzard> union2::[Int]->[Int]->[Int] union2 [] [] = [] union2 xs [] = xs union2 [] ys = ys union2 xs ys = nub (concat[xs , ys])
17:24:26 <whitewizzard> i keep getting an error , it says nub is an undefined variable
17:24:33 <elliott> whitewizzard: import Data.List to get nub
17:24:36 <mike-burns> whitewizzard: import Data.List (nub)
17:24:38 <cmccann> elliott, that's pretty much my list as well, with the priorities going from last to first in your list :P
17:24:57 <elliott> cmccann: Mine is ordered in order of required familiarity with the codebase for a reason :)
17:25:34 <cmccann> mine is ordered in order of how much I'm pissed off at it
17:25:37 <elliott> Actually I was going to look into switching json to aeson too while I was at the "converting between equivalent libraries" thing, but I doubt there'd be much concrete improvement.
17:26:11 <elliott> cmccann: Shouldn't the Cabal data types one be last, or are you going to try and refactor the whole codebase without being able to usefully run it? :P
17:26:29 <cmccann> well
17:26:50 <cmccann> like I said I want some of these pieces to run independently in general
17:27:07 <cmccann> I don't see why restarting the web UI should restart the whole package system &c.
17:27:29 <Gracenotes> because Haskell can't do dynamic reloading?
17:27:33 <Gracenotes> easily?
17:27:35 <elliott> cmccann: I agree.
17:27:36 <cmccann> so I was planning to start ripping chunks off and getting them running independently, and trying to prune down the bloat a bit as I go
17:27:44 <elliott> Gracenotes: How's that relevant?
17:27:48 <elliott> Just run them as separate servers or such.
17:27:50 <cmccann> yes
17:27:51 <Gracenotes> if it's all in one process.
17:27:54 <cmccann> separate processes
17:27:56 <cmccann> separate applications
17:27:59 <elliott> Separate processes also lets you run them on separate servers.
17:28:06 <cmccann> hell, on separate servers if I feel like it
17:28:11 <cmccann> this has no reason to be monolithic
17:28:12 <elliott> Maybe it should just use an RDBMS :P
17:28:28 <Gracenotes> that makes plenty of sense. acid-state... not so evolved beyond that though.
17:28:33 <elliott> acid-state does network
17:28:39 <Gracenotes> whaa?
17:28:42 <cmccann> honestly I think the vast majority of the data should be stored as... files
17:28:44 <cmccann> on a file system
17:28:45 <elliott> but there's no reason the protocol has to be acid-state
17:28:45 <Gracenotes> :| well that is a good thing.
17:28:46 <cmccann> seriously
17:28:51 <cmccann> this is mostly static data
17:29:09 <Gracenotes> complex heterogenous (some recursive) static data, but, yeah
17:29:11 <elliott> cmccann: I don't see how that is better, in that I don't know that acid-state has any special overhead for mostly-static data.
17:29:24 <elliott> And it handles serialisation and format changes with much less work.
17:29:29 <elliott> acid-state *is* backed by a file and all.
17:29:33 <cmccann> I guess so
17:29:46 <cmccann> and I wasn't going to worry about that immediately anyhow
17:30:52 <cmccann> the main thing is not having a single monolithic process that wants to have everything in memory forever
17:31:16 <elliott> Is the package graph abstracted?
17:31:33 <elliott> cmccann: BTW, "in memory" might be misleading.
17:31:55 <elliott> cmccann: If the OS uses swap appropriately, it's likely going to be less efficient to explicitly flush out files, close them, reopen them, etc.
17:32:18 <cmccann> true
17:33:01 <elliott> cmccann: If you're having troubles and have a large heap allocated to GHC and a decent amount of swap space, the problem is going to be in the usage patterns of that memory.
17:33:07 <cmccann> yeah
17:33:11 <elliott> Maybe acid-state is touching it when it shouldn't, or something.
17:34:15 <elliott> cmccann: What boundaries were you wanting to split things up into servers on?
17:34:55 <cmccann> not entirely sure, but the existing divisions in the Feature stuff are the obvious starting point
17:35:21 <Sgeo> Is it just me, or are design decisions easier in the presence of immutability?
17:35:25 <cmccann> the main thing is not reloading the package information unless necessary
17:35:39 <Sgeo> I kind of like being forced into a way of thinking.
17:35:48 <Gracenotes> in the world of post-acid-state-modularization, Feature objects are a primary interfaces to feature-specific data
17:36:12 <Gracenotes> *in the apocalyptic world of. has a better ring to it.
17:36:56 * elliott is honestly a little sceptical of the features thing.
17:37:02 <elliott> But I tend to be sceptical of anything that sounds like it was intended for "extensibility", probably it would be uglier without...
17:37:04 <cmccann> elliott, I'm going to need a decent stretch of time to sit down and look through the code when I'm not in a foul mood about GHC crashes and non-working profiling
17:37:42 <cmccann> which may not happen for a few days, going to be kinda busy here
17:41:11 * cmccann sighs
17:41:29 <elliott> this Hackage2 thing is going well so far :P
17:41:31 <cmccann> anyway, I don't think I'm up for much else tonight
17:41:50 <cmccann> elliott, do you think you could try to get some heap profiling for it?
17:42:01 <cmccann> with an actual package index present
17:42:19 <cmccann> I'm still not convinced that isn't just something funny going on with my system
17:42:41 <elliott> cmccann: ok, do you have an index I could try to import?
17:42:44 <cmccann> and I'm still not sure how to get a minimal repro on the strange closure type thing
17:42:47 <elliott> I have 4 gigs of ram (but only a 1.3 ghz cpu)
17:43:03 <cmccann> grab the one from hackage, then delete stuff out of the tarball
17:43:20 <elliott> just the package description tarball?
17:43:38 <cmccann> yes, and you'll need the upload log too
17:43:42 <Saizan> isn't GHC's GC touching everything once in a while?
17:43:52 <elliott> oh, good point
17:43:53 <cmccann> they don't need to match, it'll yell at you but still work
17:44:00 <elliott> is there a way to put stuff outside of the GC's reach?
17:44:11 <elliott> some runtimes let you have "immortal" objects that it never copies or touches
17:44:33 <elliott> cmccann: should I try without heap profiling first, or does the problem not appear there?
17:44:41 <elliott> also i suddenly realise i've never actually used the heap profiling stuff
17:44:46 <cmccann> so just delete stuff from the tarball, run convert on that, run restore on the result, then run the server
17:44:56 <cmccann> well, it's the heap profiling I want
17:45:05 <cmccann> I'm getting empty profile data
17:45:09 <cmccann> and I have no idea why
17:45:35 <cmccann> just look at RWH and see what it does
17:45:46 <cmccann> and glance at the GHC user guide too, there are some minor changes
17:46:05 <elliott> gah, why does --enable-library-profiling not turn on -auto-all with cabal
17:46:30 <elliott> cmccann: ok, it'll take like ten minutes to compile though
17:46:39 <elliott> because --make is from the stone age and can't do parallel builds etc. etc. etc.
17:47:10 <cmccann> yeah
17:47:11 <cmccann> I know
17:47:13 <cmccann> trust me
17:47:14 <cmccann> I know
17:47:31 <elliott> ok, now I'm having really awful ideas for keeping the GC off the package database
17:47:34 <elliott> for example
17:47:49 <elliott> what if we stuffed it into a stableptr, stored it in a C global variable and dropped the reference from the haskell side?
17:47:55 <elliott> would the GC see it? I guess so
17:48:04 <elliott> we'd need to store it C-side in the first place to avoid that... maybe with Storable
17:48:07 <elliott> this is stupid
17:48:55 * cmccann still isn't convinced that half of the issues he's having aren't his system being flaky... somehow
17:49:22 <cmccann> and yeah let's not do anything incredibly stupid until we have to
17:49:43 <cmccann> if we can prune down the data bloat enough maybe it won't matter
17:49:52 <elliott> well
17:49:58 <elliott> i'm getting kind of sick of mechanically converting code to blaze-html
17:50:08 <elliott> so i'm really tempted to write my own version of the cabal data types for something to do
17:50:17 <elliott> which should help tons
17:50:29 <elliott> just s/String/Text/ s/[]/Vector/ s/::/:: !/ :P
17:51:43 <cmccann> sounds like a start at least
17:52:13 <elliott> I would be surprised if it doesn't fix the problem entirely
17:52:16 <elliott> String is huge
17:52:22 <ninestraycats> hey all, i been racking my brain for an hour re a potential space problem, can i ask about that here? here's a heap profile (http://i.imgur.com/xhEDU.png) and the offending code.
17:52:24 <hpaste> ninestraycats pasted ‚Äúlist leak?‚Äù at http://hpaste.org/63707
17:52:24 <hpaste> ninestraycats pasted ‚Äúlist leak?‚Äù at http://hpaste.org/63708
17:52:36 <ninestraycats> that was odd, not sure why it went twice
17:52:37 <elliott> ninestraycats: which paste?
17:52:41 <elliott> ok
17:53:02 <elliott> cmccann: would it be unwise to try and use the full tarball?
17:53:04 <elliott> I'm lazy :p
17:53:10 <cmccann> go ahead and try
17:53:23 <cmccann> worst case scenario you get to feel my pain for a while
17:53:24 <elliott> ninestraycats: your foldr looks suspicious
17:53:25 <cmccann> :D
17:53:26 <elliott> ninestraycats: try a foldl'
17:53:33 <ninestraycats> i did, no change
17:54:09 <ninestraycats> that corpus there is read from disk, only 300KB, so looking at the heap profile, a 2MB map structure seems alright, but where's all that space from (:) coming from?
17:54:17 <elliott> well
17:54:21 <elliott> lists have a lot of memory overhead
17:54:25 <elliott> since they're boxed in both head and tail
17:54:30 <elliott> maybe you can use a vector instead or such
17:54:53 <elliott> cmccann: is restore 00-index.tar.gz the thing to do?
17:54:55 <cmccann> this seems like a remarkably appropriate conversation
17:54:56 <elliott> without existing state
17:54:58 <cmccann> yes
17:55:05 <cmccann> also give it the log file
17:55:11 <elliott> ok
17:55:39 <elliott> which kind of heap profile do you want?
17:55:44 <ninestraycats> hm, so 8MB of heap space isn't unthinkable given i'm reading only 500KB worth of text?
17:56:06 <cmccann> any kind
17:56:13 <cmccann> whatever kind you want
17:56:17 <cmccann> just something
17:56:18 <elliott> ninestraycats: http://blog.johantibell.com/2011/06/memory-footprints-of-some-common-data.html
17:56:23 <geekosaur> a character is stored as a 32-bit value; a string is a boxed linked list of those (assuming you didnt use Text or ByteString)
17:56:28 <geekosaur> yes, it can take a lot of memort
17:56:30 <geekosaur> memory
17:56:44 <elliott> ninestraycats: I suggest using Text or ByteString
17:56:49 <elliott> Text if you're processing Unicode
17:56:50 <ninestraycats> ooh, what a handy link!
17:56:53 <elliott> ByteString if you're processing raw bytes
17:57:01 <elliott> they will be 230923742389472394x faster than a list structure
17:57:13 <whitewizzard> hi again, I am trying to write a function that finds all perfect square right triangles  up to a certian number where n is the max
17:57:17 <elliott> [elliott@dinky instance]$ ../cabal-dev/bin/hackage-server restore 00-index.tar.gz log +RTS -hc
17:57:17 <elliott> hackage-server: There should be exactly one argument: the backup tarball.
17:57:19 <ninestraycats> wow that's much faster
17:57:22 <elliott> cmccann: I thought I should give it the log
17:57:31 <elliott> does it just have to be in the same directory?
17:57:40 <whitewizzard> i was going to try and use all, but I don't know if I can use more than one variable with it
17:57:48 <mike-burns> :t all
17:57:49 <lambdabot> forall a. (a -> Bool) -> [a] -> Bool
17:59:12 <cmccann> elliott, oh, do the convert first
17:59:27 <elliott> cmccann: ah
17:59:29 <cmccann> that spits out a tarball that you can restore from
17:59:34 <elliott> does that take up RAM or is it the restore?
17:59:43 <cmccann> the convert didn't seem too bad
17:59:54 <cmccann> the restore was more painful
18:00:02 <cmccann> as was just starting the server
18:00:13 <cmccann> with the full index I can't even run the restore
18:00:30 <cmccann> with the half index I can start the server as long as I compile without profiling
18:00:44 <elliott> $ time ../cabal-dev/bin/hackage-server convert 00-index.tar.gz log
18:00:44 <elliott> hackage-server: 'convert' does not take any extra arguments: 00-index.tar.gz
18:00:44 <elliott> $ time ../cabal-dev/bin/hackage-server convert
18:00:45 <elliott> hackage-server: A package index and log file must be supplied together.
18:00:49 <elliott> thanks a bunch!
18:00:52 <cmccann> haha
18:00:55 <cmccann> use flags
18:01:00 <cmccann> ask it for --help :P
18:01:06 <elliott> ah, i see
18:01:11 <elliott> you see, the restore command's help was useless
18:01:16 <cmccann> yes
18:01:17 <elliott> so I assumed the convert command's would be too
18:01:17 <cmccann> and misleading
18:01:23 <elliott> yes, it says it takes 0 arguments :)
18:02:02 <cmccann> right, but restore needs the tarball, e.g. "hackage-server restore export.tar" or whatnot
18:02:06 <elliott> yeah
18:02:36 <cmccann> it's all so simple. I can't imagine how anyone could be confused. :P
18:04:30 <elliott> The conversion step is harmless, he says!
18:04:34 <elliott> It's the restore one that'll get you!
18:04:40 <elliott> cmccann: X just crashed.
18:04:45 <elliott> Because of Hackage2.
18:05:01 <elliott> I think this program might hate me.
18:05:04 <cmccann> haha
18:05:05 <cmccann> wow
18:05:12 <elliott> So, uh, I guess I'll rip packages out of the index.
18:05:28 <cmccann> well congratulations you managed to outdo me then
18:05:45 <elliott> How do you manage to use GHC with 2 gigs anyway?
18:05:51 <cmccann> I successfully converted the full index before trying the restore
18:06:14 <elliott> ok, what's the best letters
18:06:23 <elliott> correct! a-g are the best letters
18:06:58 <zachk> anyone using ghc 7.4? it looks tasty
18:07:13 <elliott> it's tasty and sourly bitter when you try and use hackage packages
18:07:18 <elliott> for the refined haskeller
18:07:23 <cmccann> other than mystery bugs that may or may not be an artifact of my system
18:07:38 <cmccann> and the usual fun with compiling everything and tweaking dependencies
18:07:39 <elliott> cmccann: those are just the special ingredient
18:08:10 <elliott> ok, let's try this again
18:08:31 <cmccann> in other news, I recompiled hackage-server while it was running
18:08:42 <elliott> oh that was much faster
18:08:42 <cmccann> on the assumption that ghc is even more memory-hungry than hackage
18:08:58 <cmccann> and it grudgingly gave up a bit of resident memory which was swapped out
18:09:02 <cmccann> and now it's slowly creeping back in
18:09:10 <cmccann> despite me not touching it
18:09:11 <elliott> hahahaha
18:09:14 <cmccann> or even loading it in the browser
18:09:16 <elliott> cmccann: I think that's the GC
18:09:19 <elliott> like Saizan said
18:09:20 <cmccann> right
18:09:29 <elliott> if we could just move it out of the heap it'd be fine
18:09:32 <cmccann> that was what I was hoping to test
18:09:35 <elliott> right
18:09:36 <cmccann> very informally
18:09:43 <elliott> [elliott@dinky instance]$ time ../cabal-dev/bin/hackage-server restore export.tar +RTS -hc
18:09:43 <elliott> it was nice knowing y'all
18:09:49 <cmccann> :D
18:09:50 <elliott> see you on the other side
18:09:54 <elliott> what
18:09:58 <elliott> ok it completed in 3 seconds
18:10:01 <elliott> I think I cut out too much
18:10:11 <cmccann> maybe
18:10:14 <elliott> 2.5, in fact
18:10:26 <elliott> cmccann: what did you rip out?
18:11:00 <cmccann> the first hold-shift-mash-page-down packages
18:11:05 <cmccann> :P
18:11:06 <elliott> haha
18:11:17 <elliott> I'll rip out abcd
18:11:25 <cmccann> I lopped off about 45% of the archive size the first time
18:11:35 <cmccann> then another ~25% after that
18:11:58 <ninestraycats> wow, Data.Text GREATLY reduced my space usage! however, it barely skimmed .5 seconds off speed. =/  thanks all.
18:12:08 <ninestraycats> uhh, carry on.
18:12:22 <elliott> ninestraycats: there's probably other things you can do :P
18:12:30 <elliott> but getting rid of String is the first thing you do, basically
18:12:50 <cmccann> ninestraycats, don't mind us, we're just talking about how to tame insane memory use probably caused by too many Strings among other causes :P
18:12:57 <ninestraycats> hah
18:13:15 <zachk> so String is a horrible mem hog?
18:13:28 <elliott> wtf
18:13:30 <cmccann> lots of strings sitting fully-evaluated in memory is horrific
18:13:34 <elliott> cmccann: this time it completed in 0.6
18:13:46 <elliott> cmccann: prediction: there is one bad package messing things up
18:13:51 <cmccann> hm
18:13:53 <cmccann> interesting
18:13:57 <elliott> i'm going to try with the full dataset again
18:14:03 * cmccann tentatively blames edwardk
18:14:12 <edwardk> ?
18:14:23 <elliott> yeah edwardk can fix it
18:14:30 <edwardk> what'd i break?
18:14:36 <elliott> http://hpaste.org/63709 aren't heap profiles meant to be more informative than this?
18:14:39 <cmccann> edwardk, well if I throw a dart at the package index I figure I've got a 60% chance of hitting one of yours
18:14:40 <whitewizzard> can I create a filter such that x will fullfill x^2 = a^2 + b^2 for some a and b ?  then return (a,b,x) ?
18:14:48 <elliott> did I do something wrong? :(
18:14:56 <edwardk> cmccann: only on your minimalist hackage ;)
18:14:58 <elliott> whitewizzard: sure, if you have a list of as and bs to test
18:15:04 <cmccann> edwardk, so if there's a problem with a specific package I'm blaming you until further notice ;P
18:15:11 <whitewizzard> I can create them
18:15:13 <edwardk> outside of that i'm pretty sure the odds drop below 50% because snoyman is still alive
18:15:23 <whitewizzard> with a list generator
18:15:26 <cmccann> haha yeah true
18:15:30 <cmccann> also
18:15:39 <cmccann> hooray GHC 7.4 broke heap profiles
18:15:41 <cmccann> or something
18:15:53 <cmccann> because elliott got the same useless empty profile I did
18:15:57 <ninestraycats> elliott: occasionally i find empty heap profiles when my program runs seemingly instantly. never understood why, as e.g. upping my input keeping all else same gives me a nice profile
18:16:02 <elliott> http://stackoverflow.com/questions/9286799/haskell-libraries-overview-and-their-quality I think this question is trying to ask every question anyone could possibly ask about haskell
18:16:09 <elliott> cmccann: well
18:16:15 <elliott> cmccann: remember that some of this is a library and some of it is an executable
18:16:21 <elliott> so maybe that's messing things up or something
18:16:38 <elliott> ninestraycats: ah, maybe it just ran too quickly
18:16:49 <cmccann> I would still expect it to actually show memory use or something
18:16:53 <ninestraycats> same
18:17:03 <elliott> ok, let's try doing the whole thing again
18:17:18 <cmccann> but yeah maybe there's a flag we're missing or something
18:17:29 <elliott> hmmmm
18:17:36 <elliott> again it's a lot slower to convert
18:17:40 <elliott> gulp, I bet X dies again
18:17:45 <cmccann> oh noooooo
18:17:54 <elliott> 99% cpu
18:18:01 <elliott> rapidly growing memory usage
18:18:10 <elliott> well
18:18:11 <elliott> not that rapid
18:18:12 <cmccann> what, that's all? I had like 140% :P
18:18:18 <elliott> it's going in increments
18:18:23 <elliott> probably ghc's pooling or something
18:18:45 <dolio> If it's not forcing a hard reset, it's not rapid.
18:18:48 <elliott> 46% :(
18:18:59 <elliott> 50%... I should kill this soon
18:19:02 <cmccann> dolio, words to live by
18:19:10 <elliott> btw, I don't have swap
18:19:13 <elliott> which is presumably why X dies
18:19:16 <elliott> rather than becoming useless
18:19:18 <cmccann> hahahaha
18:19:23 <elliott> I think I prefer it like that
18:19:31 <dolio> I've written plenty of Haskell programs that forced me to manually power off.
18:19:38 <Gracenotes> yep.
18:19:45 <elliott> 72%
18:19:46 <cmccann> yeah my system just grinds to a halt if I don't kill it in time
18:19:47 <elliott> :'(
18:19:50 <Gracenotes> trivial ones, sometimes.
18:19:53 <elliott> yay
18:19:54 <elliott> it died
18:19:59 <elliott> hackage-server: out of memory (requested 1048576 bytes)
18:20:02 <cmccann> haha
18:20:12 <elliott> cmccann: how big is the export.tar?
18:20:21 <elliott> maybe you could transfer it to me somehow
18:20:40 <elliott> the one that you're using that's eating up your RAM on import
18:21:01 <cmccann> it's not much bigger than the index tarball I think
18:21:13 <cmccann> not sure if I still have the full index version though
18:21:14 <ninestraycats> speaking of profiles, mine continues to show a sharp peak (lots of thunks allocated?) followed by a decline (GC?) (http://i.imgur.com/WjP10.png)  since i'm just reading from disk, building a data structure, forcing evaluation, and quitting, this profile oughta be flat, no?
18:21:26 <cmccann> I nuked most of the temp files after the first few failures
18:21:32 <elliott> cmccann: well, the partial one is fine, anything that causes the weirdness on your machine
18:21:49 <ninestraycats> e.g. cf. Text usage vs Map
18:21:50 <elliott> ninestraycats: remember that almost anything you do will involve lots of intermediate structures being allocated very quickly and then GC'd
18:21:58 <elliott> ninestraycats: GHC programs regularly allocate terabytes
18:22:08 <elliott> sometimes in the space of seconds, I think
18:22:22 <ninestraycats> oh my
18:22:31 <elliott> but it's OK, because GHC's allocator is really fast
18:22:37 <elliott> comparable to stack allocation in C
18:23:47 <cmccann> and GHC programs sometimes allocate gigabytes and kill elliott's X server
18:23:47 <ninestraycats> ok, so space itself isn't the issue. what you described, though, would be consistent with a heap profile with some random spikes here and there. this one huge spike at start, followed by decline: shouldn't i be worried?
18:25:29 <cmccann> elliott, http://dl.dropbox.com/u/15282699/export_ORIG.tar
18:25:38 <elliott> ninestraycats: not sure -- possibly
18:25:57 <elliott> cmccann: thanks
18:26:14 <elliott> cmccann: have you tried compiling hackage-server with -O2 btw?
18:26:15 <elliott> maybe it'd help
18:26:19 <cmccann> thank me after your computer miraculously doesn't explode trying to use it
18:26:34 <cmccann> pretty sure I did :P
18:26:40 * elliott just used the default
18:27:02 * elliott starts a few Flash players to make GHC feel intimidated in the memory-use department
18:27:07 <cmccann> :D
18:27:26 <hpaste> elliott pasted ‚Äúwhat‚Äù at http://hpaste.org/63712
18:27:43 <cmccann> oh yeah
18:27:51 <cmccann> forgot about that
18:28:19 <cmccann> um
18:28:28 <cmccann> just go fix the csv file, probably easiest
18:28:33 <cmccann> it's uu-parsinglib
18:28:36 <elliott> oh
18:28:41 <elliott> god DAMMIT Utrecht
18:28:46 <elliott> first our eyeballs, now this?!
18:28:53 <cmccann> it doesn't have a category apparently
18:28:57 <cmccann> http://hackage.haskell.org/packages/archive/pkg-list.html
18:29:01 <elliott> tar: export-2012-02-13/core/package/shakespeare-css-0.10.5/shakespeare-css.cabal: implausibly old time stamp 1970-01-01 01:00:00
18:29:02 <cmccann> note where it shows up
18:29:07 <elliott> it's complaining about every single file, hahaha
18:29:10 <cmccann> heh
18:29:22 <elliott> cmccann: I think they used that no-category to make it appear at the top :D
18:29:31 <cmccann> clever bastards
18:29:35 * cmccann shakes his fist
18:29:56 <elliott> hmm, just remove the '"",'?
18:30:03 <cmccann> or put something in there
18:30:18 <cmccann> it just doesn't like empty tags
18:30:21 <elliott> ah
18:30:57 <elliott> hackage-server: Codec.Compression.Zlib: incorrect header check
18:30:59 <elliott> what
18:31:04 <cmccann> ...
18:31:15 <elliott> $ tar cf export_ORIG_fixed.tar export-2012-02-13
18:31:21 <elliott> maybe my tar is too new???
18:31:22 <nand`> Preferred way to get the clean directory/filename of a path? I can obviously use reverse . takeWhile (/= '/') . reverse but I wonder if there's a nicer way
18:31:26 <elliott> and creating incompatible tarballs? I don't even know
18:31:31 <elliott> nand`: see System.FilePath?
18:31:41 <elliott> http://hackage.haskell.org/packages/archive/filepath/1.1.0.2/doc/html/System-FilePath-Posix.html
18:32:34 <cmccann> elliott, I guess you could just modify Distribution/Server/Packages/Backup/Tags.hs to filter out empty tags
18:32:37 <nand`> elliott: thanks
18:33:28 <elliott> cmccann: ugh
18:33:37 <cmccann> ok
18:33:37 <elliott> cmccann: does the reduced tarball still give you problems? I could try that instead
18:34:04 <cmccann> everything that makes it use memory gives me problems
18:34:38 <cmccann> and the other tarballs might not help if they still have uu-parsinglib in them
18:35:13 <cmccann> which they do
18:35:36 <elliott> right
18:35:47 <elliott> have you tried importing the same stuff on that EC2?
18:35:51 <elliott> or is that what gives the problems
18:35:56 <cmccann> haha, no
18:36:02 <cmccann> that would not end well
18:37:06 <elliott> tempted to say something's up with your system as far as the weirdness goes, but... it does use a *lot* of memory
18:37:11 <elliott> I presume it's loading all the PackageDescription things into memory?
18:38:00 <ulidtko> > Couldn't match expected type `GHC.Word.Word8'  with actual type `Char'  In the first argument of `split', namely '\n'
18:38:01 <lambdabot>   <no location info>: parse error on input `type'
18:38:13 <ulidtko> whoops
18:38:29 <ulidtko> how do I write Word8 literals?
18:38:31 <elliott> ulidtko: '\n' is a Char, not a Word8.
18:38:34 <elliott> As digits.
18:38:41 <ulidtko> ookay
18:38:44 <rwbarton> 10
18:38:44 <elliott> In this case, 10.
18:38:58 <elliott> You can also import Data.ByteString.Char8 to use ByteStrings as if they were sequences of Chars, but I'll be really disappointed in you.
18:39:11 <ulidtko> no-no-no
18:39:18 <ulidtko> no that way
18:39:21 <cmccann> elliott: http://dl.dropbox.com/u/15282699/restore.prof
18:39:28 <cmccann> also http://dl.dropbox.com/u/15282699/run.prof
18:39:36 <ulidtko> encodings an unicode will be angry at me if i'd do that
18:39:39 <ulidtko> *and
18:39:52 * hackagebot sbv 1.1 - Symbolic bit vectors: Bit-precise verification and automatic C-code generation.  http://hackage.haskell.org/package/sbv-1.1 (LeventErkok)
18:40:04 <scooty-puff> is it possible to use a where cluase the uses variables in the preceding set of do statements?  or perhaps something that makes that work better - mostly just don't like the aesthetic of let's in do's
18:40:39 <elliott> Encodings and Unicode will be angry at you if you're using ByteString to process text in the first place :P
18:40:52 <elliott> scooty-puff: No. You can pass parameters to functions declared in where clauses.
18:41:04 <ulidtko> sh-h-h, the text is ascii-only
18:41:14 <whitewizzard> hi all I am having an issue with this filter
18:41:15 <whitewizzard> filter(\x -> (( x!!1)*( x!! 1)+(x !! 2)+(x !! 2))== ((x!!3) * (x!!3)))[ (a,b,c) | a <- [1..10], b <- [1..10], c <- [1..10] ]
18:41:20 <elliott> cmccann: ha, this file is one column wider than my terminal
18:41:41 <cmccann> nice
18:41:42 <elliott> whitewizzard: (!!) is for accessing elements of lists, not tuples.
18:42:20 <whitewizzard> if I use [a,b,c] I get  (!!) index too large
18:42:48 <elliott> List indexing starts at 0. But you shouldn't use a list there anyway.
18:42:48 <zachk> change /(a,b,c)/[a,b,c] and it should work as you want
18:42:56 <elliott> No, it shouldn't.
18:43:19 <elliott> cmccann: this is the hugest profile I've ever seen
18:43:28 <elliott> cmccann: did you -auto-all in every library or something?
18:43:39 <Sgeo> Is there a clear explanation somewhere of principal typings?
18:43:48 <cmccann> elliott, just on hackage-server itself
18:43:49 * zachk goes derrr and admits elliott is 110% correct 
18:44:02 <cmccann> what GHC did with that is its own business
18:44:29 <whitewizzard> I can get it to work If I start counting at 0, but the output is not what I expect
18:44:36 <whitewizzard> [[1,4,3],[2,6,4],[3,8,5],[4,10,6]]
18:44:39 <cmccann> in other news that running hackage-server is still seeping back into residence
18:44:40 <elliott> cmccann: it's unreadable as far as figuring out what's taking up space :(
18:44:46 <elliott> cmccann: these columns need sort buttons
18:44:49 <whitewizzard> I was expecting something starting with [3,4,5]
18:45:03 <rwbarton> whitewizzard: you have a typo.
18:45:19 <rwbarton> also, you should really move that filter into the list comprehension so it could be readable.
18:45:25 <rwbarton> then the typo would be obvious.
18:45:50 <whitewizzard> how would I go about doing that?
18:45:52 <cmccann> elliott, well, it says at the top that partialToFullPkg is the biggest offender
18:46:03 <rwbarton> [ (a,b,c) | a <- [1..10], b <- [1..10], c <- [1..10], a * a + ... ]
18:46:04 <cmccann> in the restore, that is
18:46:12 <elliott> oh right, I forgot there's a summary
18:46:33 <cmccann> in the run it's cereal that's eating my memory for breakfast
18:46:38 <elliott> cmccann: interesting that demandInput is 50% alloc
18:46:45 <ulidtko> > [ (a,b,c) | a <- [1..10], b <- [1..10], c <- [1..10], a*a + b*b == c*c]
18:46:46 <lambdabot>   [(3,4,5),(4,3,5),(6,8,10),(8,6,10)]
18:46:46 <cmccann> yes
18:46:48 <elliott> cmccann: maybe that's misleading and it actually just means the package data itself
18:46:52 <elliott> is the 50% alloc
18:47:00 <cmccann> that's an mappend call btw
18:47:07 <cmccann> or something like that
18:47:12 <cmccann> combining results, at any rate
18:47:15 <elliott> uuuurgh
18:47:27 <elliott> how about I just rip up the cabal type and see if that helps :P
18:47:31 <Sgeo> "Or an inferred structural type that leaks implementation data?"
18:47:40 <cmccann> (the s1 is the name in the where clause the result is assigned to)
18:47:46 <Sgeo> Uh, inferred structural types don't necessarily leak implementation data.
18:47:53 <whitewizzard> thanks that got it working!
18:47:54 <cmccann> (which is a neat feature that got added to the profiling at some point)
18:47:54 <Sgeo> As far as I can think, anyway
18:48:34 <zachk> > let list = [1..5] in [(a,b,c) | a <- list , b <- list, c <- list , a^2+b^2==c^2]
18:48:35 <lambdabot>   [(3,4,5),(4,3,5)]
18:48:42 <elliott> Sgeo: what if you have a private field in your structure
18:49:23 <Sgeo> Wouldn't that not match an inferred type trying to use that structure that expects that field to be public?
18:49:25 <elliott> Gracenotes: PackageDescription is the only big type from Cabal used, right? well, that and everything it contains
18:49:27 <cmccann> elliott, btw, note the "total time" in those profiling results
18:49:38 <Sgeo> Or maybe I'm misunderstanding your hypothetical?
18:49:39 <elliott> Sgeo: Who said there's any concept of private/public?
18:49:52 <elliott> cmccann: wat
18:49:54 <cmccann> elliott, how about we just scrap Cabal
18:49:57 <cmccann> that's a good idea right
18:50:06 <elliott> cmccann: yes, please
18:50:08 <cmccann> suffice it to say it ran for a lot longer than that
18:50:09 <nand`> I don't want to interrupt my coding by reading through pages and pages of cabal documentation, how do I specify that I want dependency at version >= 0.7.2 but < 0.8.*? In other words, 0.7.x; x >= 2
18:50:20 <elliott> >= 0.7.2 && < 0.8
18:50:34 <nand`> oh, I tried < 0.8.*
18:50:39 <nand`> no wonder it didn't work
18:50:41 <elliott> that's only used for == wildcards
18:50:46 <nand`> I see
18:51:27 <hpaste> elliott pasted ‚Äúaaaargh‚Äù at http://hpaste.org/63713
18:51:30 <elliott> cmccann: wish me luck
18:51:44 <cmccann> haha
18:51:49 <Gracenotes> elliott: yes. Chances are there's lots of PackageNames scattered all over the application, though, which is a wrapper around String
18:51:56 <elliott> Gracenotes: right
18:51:56 <cmccann> 100 PLEASE DON'T GIVE UP
18:52:13 <elliott> Gracenotes: I figure if I use Text in the PackageDescription-equivalent's field, it'll show me all those places with type errors
18:52:34 <elliott> dear GHC devs: please give me a way to figure out which record fields a codebase doesn't use
18:52:38 <elliott> so I can omit them when replacing structures :P
18:52:48 <cmccann> anyway
18:53:10 <cmccann> I had a long day and am kinda sick of this stuff right now
18:53:17 <cmccann> so I'm heading to bed
18:53:25 <elliott> are you implying memory leaks aren't the funnest thing?!
18:53:30 <cmccann> well
18:53:35 <cmccann> your X server crashing was pretty funny I admit
18:53:38 <cmccann> otherwise nah
18:53:47 <Gracenotes> GenericPackageDescription is mainly used for.. what is essentially an encoding of a package's dependencies, a CondTree
18:53:54 <elliott> oh god
18:53:55 <elliott> there's GenericPackageDescription too
18:53:59 <elliott> Gracenotes: snap
18:54:08 <Gracenotes> hell yes. I mean
18:54:13 <Gracenotes> >:|
18:54:33 <elliott> just so you know, I blame you, personally, for all this
18:54:36 <elliott> gotta blame someone
18:54:41 <elliott> :'(
18:55:01 <elliott> (I'm lying, I actually blame lambdabot.)
18:55:33 <Gracenotes> dcoutts and I were coconspirators in, well, reasonable design decisions that didn't end up performing well, which certainly by now we would've hoped
18:56:00 <cmccann> the problem here seems to be a very small number of poor design decisions
18:56:07 <cmccann> which have metastasized
18:56:08 <Gracenotes> I mean, they perform quite well if you have 8GB of memory and a current-generation CPU.
18:56:13 <cmccann> and spread to the entire application
18:56:23 <elliott> Gracenotes: we would have hoped what?
18:56:36 <elliott> ok, I'll start at ./Distribution/Server/Packages/PackageIndex.hs and ./Distribution/Server/Packages/State.hs
18:56:56 <cmccann> anyway
18:56:57 <elliott> those seem to be the root of the PackageDescription terror
18:57:17 <cmccann> elliott, Gracenotes, feel free to harass me via email and/or lambdabot if you find anything interesting
18:57:33 <elliott> maybe a grue
18:57:39 <Gracenotes> also, coconspirators = nspirators?
18:57:41 <cmccann> could be
18:57:51 <cmccann> > co "conspirators"
18:57:52 <lambdabot>   Not in scope: `co'
18:58:00 <cmccann> oh ,was that a command
18:58:01 <elliott> cmccann: enjoy your dreams filled with hackage2 memory leaks
18:58:05 <cmccann> can't even remember
18:58:14 <cmccann> my memory is filled with hackage bloat
18:58:24 <elliott> IN A WORLD... WHERE THE UNIVERSE RUNS ON HASKELL... ONE MEMORY LEAK... IS ALL IT TAKES
18:58:28 <cmccann> everything useful has been swapped out
18:58:30 <elliott> ~ HACKAGE ~
18:58:34 <cmccann> :D
18:58:37 <cmccann> ... :[
18:59:03 <elliott> "I told you Haskell's performance was too unpredictable for serious use, god dammit!" "BLASPHEMY!"
18:59:16 <elliott> "There's no other hope. We're going to have to bring out... C++."
18:59:31 <elliott> "C++?! Are you crazy? We're civilised!"
18:59:42 <cmccann> this is incredibly silly
18:59:48 <Gracenotes> maybe if Cabal-the-library didn't use linked-list strings and everything lazy, these problems wouldn't exist. maybe they would to a lesser extent.
18:59:48 <cmccann> ok, I'm out
18:59:51 <elliott> Hey, I'd watch it.
19:00:10 <elliott> Gracenotes: I'm mostly surprised Cabal actually works as a build tool with structures like that
19:00:25 <cmccann> let me know what you accomplish here so I know whether it's worth hacking on stuff tomorrow or if I should wait for you to finish your PackageDescription genocide
19:01:01 <elliott> huh
19:01:06 <elliott> what's with this Package typeclass
19:01:20 <elliott> cmccann: (btw, the mappend is just merging Maps I think)
19:01:21 <Gracenotes> I mean, reverse dependencies needs [Generic]PackageDescription. If you want to anything useful with formatting dependencies nicely, you need it as well
19:01:39 <Sgeo> http://gbracha.blogspot.com/2011/06/types-are-anti-modular.html
19:01:44 <Sgeo> Is that actually Philip Wadler?
19:01:57 <Gracenotes> Package is things having a PackageId
19:02:26 <elliott> Sgeo: No, it's the other Philip Wadler who uses Haskell and stuff.
19:02:34 <elliott> There's seven.
19:02:38 <cmccann> does he have a beard and bowtie?
19:02:41 <cmccann> if so, it's wadler
19:02:46 <cmccann> that's the key thing really
19:02:54 <Sgeo> I mean, how do I know it's not someone pretending to be Wadler?
19:03:17 <elliott> Because it's linked to his blog?
19:03:30 * elliott pretends to be SPJ in blog comments, waits for the money to roll in.
19:03:42 <cmccann> anyway, heading out for real now
19:03:49 <elliott> I mean, maybe it's someone who hacked into Wadler's Blogger account!
19:03:57 <cmccann> elliott, good luck :P
19:04:53 <elliott> cmccann: If only luck was enough.
19:09:02 <elliott> Gracenotes: wow, CondTree is trying really hard to use as much space as it possibly can
19:09:10 <elliott> (in GenericPackageDescription)
19:09:53 * hackagebot xturtle 0.0.12 - turtle like LOGO  http://hackage.haskell.org/package/xturtle-0.0.12 (YoshikuniJujo)
19:17:49 <Gracenotes> elliott: there are lots of flag combinations and stuff. One of the ideas I had is that each package page could have a form with dropdowns/checkboxes/etc, and you could see the exact dependencies for a given set of flags.
19:18:04 <Gracenotes> which includes compiler version, OS, etc.
19:18:47 <Gracenotes> displaying a package's dependencies requires a flattened CondTree, and so does revdep.
19:19:05 <Gracenotes> doing the fancy thing I mentioned would require the CondTree itself, all of the data in it
19:19:13 <elliott> right
19:19:23 <elliott> i meant more the gratuitous boxes :P
19:20:36 <Gracenotes> yes. you probably do not need two dozen pointers to empty lists ._.
19:21:55 <koninkje> Does anyone know of a good LaTeX symbol for (<$>)?
19:22:21 <koninkje> I can use \circledast for (<*>), but I can't think of anything decent for (<$>)
19:31:15 <elliott> koninkje: can you construct a circled $?
19:31:36 <koninkje> perhaps, though I don't know how good it would look...
19:32:03 <koninkje> Just didn't know if we'd figured out a common way of rendering ($) or (<$>) which looks decent in print
19:33:54 <edwardk> koninkje: hrmm, what did the old squiggol stuff use for map?
19:35:45 <Sgeo> o.O I'm thinking over how to implement Applicatives in Smalltalk
19:35:51 <Sgeo> I seem to want to turn Smalltalk into Haskell.
19:36:03 <edwardk> koninkje: one sec. lemme check
19:37:19 <edwardk> bird used to use * for map
19:37:28 <koninkje> well, it looks like Squiggol used f.x for application
19:37:48 <koninkje> it's the applicative idiom-brackets sense of (<$>) I mean to invoke here...
19:38:21 <koninkje> yeah, and * as fmap
19:38:26 <edwardk> Found my old copy of "Research Topics in Functional Programming" which had Bird's "A Calculus of Functions for Program Derivation" in it
19:38:36 <Gracenotes> elliott, cmccann: incidentally, if you need the rationale behind any of the aspects of the codebase, you can ask me or dcoutts. The ones which are design decisions and not.. uh.. partial implementations.
19:38:53 <Gracenotes> for historical reasons
19:39:11 <Sgeo> Is it ok to say that Smalltalk's >>collect: is a flipped fmap?
19:39:17 <Sgeo> Or is the name too misleading for that?
19:39:25 <edwardk> * is probably not the best typographical representation though =)
19:39:43 <Eduard_Munteanu> koninkje: mm, don't bother if there's no recognized symbol for it. I guess it just makes it harder to relate. Why not try a reasonable proportional font instead?
19:39:48 <koninkje> yeah, everyone uses asterix to mean different things
19:39:59 <elliott> koninkje: why not just use idiom brackets? :P
19:40:05 <edwardk> yeah smashing the <$> together a bit might help, but otherwise you'll just make it harder to read
19:40:16 <edwardk> for anyone who already knows what you're talking about
19:40:42 <koninkje> elliott: Well, they make it more confusing when you're mixing applicative with pure
19:40:47 <edwardk> failing that just avoid it, and use liftAn
19:40:52 <elliott> right
19:41:14 <koninkje> ug, but liftA is so ugly!
19:41:35 * koninkje wonders what APL used for map
19:44:49 <nand`> Is it possible to create a friendly name for data constructors? Eg. for something like: type BatBaz = Either Int String; and then Bat = Left and Baz = Right
19:45:16 <elliott> she lets you
19:45:22 <elliott> otherwise no
19:45:23 <edwardk> nand`: not directly. you can make smart constructors, by making functions, but pattern matching will use the old names
19:45:33 <nand`> Alright
19:45:50 <edwardk> view patterns can kinda fake it, but its a bad idea ;)
19:46:12 <edwardk> as can unsafeCoerce ;)
19:46:15 <elliott> the strathclyde haskell enhancement preprocessor, that is
19:46:30 <nand`> it's not that big of a deal
19:46:35 <elliott> with pattern signatures
19:46:42 <elliott> erm
19:46:42 <nand`> just wanted to see if I could prettify all of the MPD.LsDirectory, MPD.LsFile and so on matches
19:46:47 <edwardk> everytime i see SHE i think of the enzyte commercials
19:46:47 <elliott> synonyms
19:47:00 <edwardk> All Natural Haskell Enhancement
19:47:08 <elliott> nand`: perhaps with view patterns
19:48:58 <whitewizzard> union2 xs ys = [ concat[xs, [y]] |  y <- ys , not (member2 y xs)]
19:49:13 <whitewizzard> I am trying to write a new union for sets
19:49:51 <whitewizzard> I can get it to add the correct ys but it does it as a bunch of lists
19:51:59 <edwardk> for an assignment or for practical use?
19:52:04 <whitewizzard> assingment
19:52:23 <rwbarton> > let union2 xs ys = [ concat[xs, [y]] |  y <- ys , not (member2 y xs)] in union2 "abc" "ebf"
19:52:24 <lambdabot>   Not in scope: `member2'
19:52:26 <whitewizzard> otherwise I would use the stuff in  Data.list
19:52:29 <edwardk> first an observation concat [xs, [y]] can become xs ++ [y]
19:52:30 <rwbarton> > let union2 xs ys = [ concat[xs, [y]] |  y <- ys , not (member y xs)] in union2 "abc" "ebf"
19:52:31 <lambdabot>   Not in scope: `member'
19:52:35 <rwbarton> > let union2 xs ys = [ concat[xs, [y]] |  y <- ys , not (elem y xs)] in union2 "abc" "ebf"
19:52:36 <lambdabot>   ["abce","abcf"]
19:52:58 <whitewizzard> im looking to get ["abcef"]
19:53:47 <edwardk> what about moving the concat[xs, ‚Ä¶ ] outside of the comprehension?
19:54:11 <whitewizzard> good idea brb
19:54:43 <edwardk> and replace concat [xs, ys] with xs ++ ys while you're at it =)
19:55:20 <edwardk> finally you can releplace the list comprehension with a single call to filter
19:55:29 <edwardk> er replace
19:56:03 <whitewizzard> i fot it working!
19:56:05 <edwardk> so unioning would be taking all the elements in one set, and concatenating that to the result of returning all the elements in the other that aren't in the first
19:56:05 <whitewizzard> thanks
19:56:48 <whitewizzard> yes, usually it has been coded as concat both sets then remove duplicates
19:56:53 <edwardk> > let union2 xs ys = xs ++ filter (not . elem xs) ys in union2 "abc" "ebf"
19:56:54 <newsham> ?unpl \xs ys -> nub (xs ++ ys)
19:56:54 <lambdabot>   Occurs check: cannot construct the infinite type: m = [[m]]
19:56:54 <lambdabot> \ xs ys -> nub (xs ++ ys)
19:57:01 <newsham> ?pl \xs ys -> nub (xs ++ ys)
19:57:01 <lambdabot> (nub .) . (++)
19:57:04 <edwardk> bah
19:57:09 <edwardk> i need to flip that
19:57:10 <edwardk> :t notElem
19:57:11 <lambdabot> forall a. (Eq a) => a -> [a] -> Bool
19:57:23 <edwardk> > let union2 xs ys = xs ++ filter (`notElem` xs) ys in union2 "abc" "ebf"
19:57:25 <lambdabot>   "abcef"
19:57:42 <newsham> > numb ("abc" ++ "ebf")
19:57:43 <lambdabot>   Not in scope: `numb'
19:57:47 <newsham> > nub ("abc" ++ "ebf")
19:57:48 <lambdabot>   "abcef"
19:57:54 <edwardk> there is that =)
19:59:15 <parcs`> > (S.toList .: S.union `on` S.fromList) "abs" "ebf"
19:59:17 <lambdabot>   "abefs"
20:00:00 <zzo38> OK. I am glad that hashable-1.1.2.3 added a hash for TypeRep; in next version of my extensible-data package I cam use that instance instead of using my own newtype wrapper for it. Can you tell me what gave you idea to add the hash for TypeRep? It seem good idea to me.
20:00:03 <parcs`> oh damn, ordering
20:02:16 <zzo38> Is Johan Tibell on?
20:02:20 <edwardk> zzo38: the md5 is already there inside it
20:02:52 <zzo38> edwardk: Yes, I did look. That is good.
20:03:12 <edwardk> so extracting from that to hashable is pretty easy
20:03:20 <edwardk> er s/is/was
20:05:34 <zzo38> But not all versions of GHC do it the same way; I simply hashed the "show" string in my own newtype wrapper in Data.Extensible.Product, which is what I used the TypeRep hashes for. How I have it, the field labels are types. So in next version, I will use their TypeRep hash instead of my own.
20:05:56 <edwardk> yeah mkTyCon3 changed the hash codes that are generated by Typeable
20:07:13 <zzo38> But I did use a newtype wrapper; so there will be no instance conflict even if you upgrade the hashable package. But when I update extensible-data package I will remove the newtype wrapper to use their instance instead, which works with many version of GHC it has a code to check which one it is
20:08:00 <hpaste> clown pasted ‚Äúdrawbox‚Äù at http://hpaste.org/63716
20:09:55 <zzo38> The type (ExtProd p) is represented internally by something like (p, HashMap TypeRep Any), where the value that Any is coerced to is fixed by an associated type family with the ExtProdC class, and p is a type of a value used to initialize default values for each field of the record.
20:10:28 <zzo38> So now I can simplify my program and improve it by using their TypeRep hash directly
20:10:44 <zzo38> Thank you for making this improvement to hashable-1.1.2.3 package!
20:11:15 <whitewizzard> what is the difference between foldl and foldr?
20:11:35 <randomclown> what's hpaste's code analyser called?
20:11:45 <tgeeky> hint
20:11:52 <tgeeky> or hlint
20:12:01 <elliott> whitewizzard
20:12:04 <tgeeky> http://hackage.haskell.org/package/hlint
20:12:08 <elliott> > foldr f z [a,b,c,d]
20:12:09 <lambdabot>   f a (f b (f c (f d z)))
20:12:12 <elliott> > foldl f z [a,b,c,d]
20:12:13 <lambdabot>   f (f (f (f z a) b) c) d
20:12:34 <whitewizzard> thanks!
20:12:37 <randomclown> tyo tgeeky
20:12:42 <randomclown> ty*
20:13:33 <zzo38> Can you fix hpaste's "Literate Haskell" mode? It highlights the code as a Visual Basic code instead by mistake.
20:13:53 <elliott> zzo38: @tell chrisdone
20:14:17 <zzo38> chrisdone is not on today
20:14:35 <elliott> yes, so @tell with lambdabot
20:14:45 <elliott>  @tell chrisdone ...message...
20:14:54 <zzo38> O, like that.
20:15:10 <zzo38> OK. I have done so.
20:16:55 <zzo38> When will they fix it?
20:17:05 <tgeeky> zzo38: probably tomorrow
20:17:15 <tgeeky> zzo38: they is just one person, Chris Done
20:17:29 <zzo38> tgeeky: OK. But do you know why it does that?
20:17:57 <elliott> i assume zzo38 was using singular they
20:18:14 <zzo38> elliott: Yes I mean singular they, I even put it on my Wikipedia
20:18:32 <tgeeky> zzo38: assuming it's not user error, then probably just overlooked.
20:19:49 <zzo38> But notice, there is one syntax highlighting program that does something wrong with literate Haskell. It uses LaTeX mode if the first character of the file is \ or % and uses Bird mode otherwise. But they are allowed to be mixed together in one file; it should always use both modes at the same time.
20:20:20 <zzo38> (Specifically, my literate Haskell programs usually start with % but use bird-style; Haskell does allow this)
20:21:31 <parcs`> oo, i didn't know 'data Foo = Foo { a, b :: Int }' was valid
20:21:45 <Veinor> does a :: Foo -> Int?
20:21:52 <zzo38> I think the program that does this is Pygments; I have posted a bug report but they didn't fix it
20:21:54 <edwardk> parcs`: yeah its a lifesaver when you have a lot of fields =)
20:21:56 <parcs`> Veinor: yeah
20:22:15 <parcs`> edwardk:  i can imagine :)
20:22:50 <edwardk> Veinor: yes
20:23:21 <reltuk> will -Wall tell you about unused imports?
20:23:30 <elliott> yes
20:24:13 <randomclown> anyone know how to fix this code?
20:24:13 <randomclown> http://hpaste.org/63720
20:24:21 <randomclown> error is included in the paste
20:24:41 <randomclown> Its supposed to draw a box with the size written in the middle
20:24:53 <zzo38> What is the syntax highlighter used in hpaste?
20:25:34 <randomclown> oh wiat I figured it out
20:32:49 <randomclown> Is there a way to generalise a insertCentre function that allows both [a] -> [a] -> [a] type inserts
20:32:58 <randomclown> as well as a -> [a] -> type inserts
20:33:06 <reltuk> @pl \ fs -> appEndo (mconcat $ map Endo fs)
20:33:06 <lambdabot> appEndo . mconcat . map Endo
20:33:31 <randomclown> i.e. insertCentre 'a' "bbbb" -> "bbabb"
20:33:44 <elliott> reltuk: ala Endo foldMap
20:33:48 <randomclown> and insertCentre "a" "bbbb" -> "bbabb"
20:33:52 <elliott> with the newtype package
20:34:04 <elliott> randomclown: technically yes but it'd be very unidiomatic
20:34:28 <randomclown> I'd hate to have to write my insertCentre function twice
20:34:43 <randomclown> with [] around different things though
20:34:45 <randomclown> elliott:
20:34:46 <elliott> just define the list one
20:35:02 <elliott> write the elem one in terms of it
20:35:12 <elliott> (oneliner)
20:36:32 <reltuk> does ala stand for anything?
20:36:52 <elliott> a la
20:37:01 <elliott> :t aa
20:37:02 <lambdabot> Not in scope: `aa'
20:37:03 <elliott> :t ala
20:37:04 <lambdabot> forall o n b n' o'. (Newtype n o, Newtype n' o') => (o -> n) -> ((o -> n) -> b -> n') -> b -> o'
20:37:27 <zzo38> O, the hpaste uses highlight.js, which doesn't support literate Haskell. That may be the problem.
20:37:45 <zzo38> But why did it highlight as Visual Basic instead of nothing at all?
20:56:10 <Subhash123> I was wondering if anyone can point me to the right direction on this.
20:56:16 <Subhash123> What i have is this: data Shapes = Rectangle Int Int  | Ellipse Int Int | Location Int Int Shapes | Group [Shapes] deriving (Show)
20:56:37 <Subhash123> sizeShape :: Shapes -> Int  sizeShape  (Rectangle _ _) = 1 sizeShape (Ellipse _ _) = 1 sizeShape (Location _ _ s) = sizeShape s --sizeShape (Group [s]) = Data.Map.map ( sizeShape) [s]     sizeShape (Group [s]) = groupSize (map sizeShape [s])                   groupSize :: [Int] -> Int groupSize p = sum p
20:57:10 <Subhash123> now if i get a size function for a single type, i get the right answer.
20:57:26 <Subhash123> sizeShape (Group [(Location 1 1 (Rectangle 1 1))])
20:57:39 <Subhash123> but if i do this, i get non-exhausive functions.
20:57:40 <Subhash123> sizeShape (Group [(Location 1 1 (Rectangle 1 1)), (Ellipse 1 1)])
20:59:09 <elliott> Subhash123: (Group [s])
20:59:14 <elliott> [s] matches a list with the single element s
21:00:53 <Subhash123> @elliott - what is it exactly that i have to do to make it work with multiple elements?
21:00:53 <lambdabot> Unknown command, try @list
21:01:05 <Subhash123> elliott, thanks - what is it exactly that i have to do to make it work with multiple elements?
21:06:31 <zzo38> Is there a package for posixly-correct command-line option parsing with short options and no long options?
21:07:37 <ion> Isn‚Äôt that pretty much a subset of both short and long options? You could just use a library that supports both, just ignoring part of the functionality.
21:09:26 <zzo38> Yes, that will work, if long options can be turned off. And if it can have posixly-correct mode; some programs don't use it but I prefer it
21:09:57 * hackagebot couchdb-conduit 0.5.2 - Couch DB client library using http-conduit and aeson  http://hackage.haskell.org/package/couchdb-conduit-0.5.2 (AlexanderDorofeev)
21:12:08 <zzo38> How can I do save/restore cursor in a terminal window, and check size of terminal window, using Haskell, in way which work in both UNIX and in Windows (and in case of UNIX, in both console and in X)?
21:12:18 <loneWandererRed> hello interweb
21:12:45 <loneWandererRed> tonght i am going to attack a victim
21:12:59 <loneWandererRed> with brute force the victim will stand no chance
21:13:00 <loneWandererRed> be aware
21:13:06 <loneWandererRed> and remember my name
21:13:09 <adu> I'm writing an article on divmod/quorem
21:13:30 <ion> zzo38: Use termcap. Make Windows‚Ñ¢ more bearable with MinTTY http://code.google.com/p/mintty/ and msys. :-P
21:15:42 <zzo38> No, I mean, like ansi-terminal package it work Windows and UNIX, but has some things missing
21:16:29 <elliott> @where ops
21:16:29 <lambdabot> shapr Cale glguy dons sjanssen dcoutts Saizan dibblego conal Philippa bos arjanb xerox Heffalump kosmikus wli Pseudonym Igloo quicksilver monochrom Lemmih jmcarthur copumpkin
21:22:23 <SubtleArray> Hello #Haskell. Simple question. Is there a way to do recursion with functions? For example: Have the program continuely call a function until a variable reaches a certain value?
21:23:06 <NihilistDandy> ...
21:23:14 <elliott> SubtleArray: What do you mean by "variable", exactly?
21:23:18 <elliott> Do you mean an argument to that function?
21:23:25 <elliott> Haskell does not have mutable variables.
21:23:58 <bd_> elliott: unless he's looking for something that works in IO or St
21:24:12 <SubtleArray> *thinking*
21:24:42 <bd_> SubtleArray: if you're doing recursion though, usually you'll use a pattern guard
21:24:52 <SubtleArray> I basically need a loop. I need for a function to call over and over until a condition is met.
21:25:01 <elliott> you need to forget everything you know, that's what ;)
21:25:19 <hpaste> DanBurton pasted ‚ÄúNetSpec tentative design‚Äù at http://hpaste.org/63721
21:25:19 <elliott> sounds like you're entrenched in an imperative mindset.
21:25:33 <SubtleArray> Arghhh. >_<
21:25:51 <mandaya> SubtleArray: So check for the condition in the guard, and recurse otherwise. That said, there's probably a better way to do what you're trying to do
21:26:00 <DanBurton> What do you guys think about the direction I'm going with this little Networking library?  ^
21:26:27 <bd_> SubtleArray: One of the key things about Haskell is you need to be very explicit about what state you're keeping around. So you need to know if this is an IO function (which behaves much like the more common imperative languages) or a pure function, or a function in some other kind of monad
21:26:37 <elliott> SubtleArray: you should really try and start with a clean slate, without any preconceptions about programming... it'll never stop being frustrating if you keep thinking about Haskell like other languages
21:26:44 <bd_> SubtleArray: so, what are you _really_ trying to do?
21:26:44 <wavewave> hi.
21:26:56 <bd_> SubtleArray: because a loop is just a mechanism to do something, and not always the best one to choose :)
21:27:07 <randomclown> maybe map over it or something
21:27:13 <randomclown> loop -> map or fold or recursion
21:27:24 <DanBurton> or unfold, or until
21:27:35 <randomclown> or takewhile takeuntil etc
21:27:49 <elliott> Or construct an infinite tree inductively and walk some computed path in it, and so on.
21:27:51 <zzo38> DanBurton: Should SpecState be Functor? It seems like it to me
21:28:02 <wavewave> tgeeky: if I say 'hoodle,'  does it mean any funny thing?
21:28:09 <DanBurton> SubtleArray: what you want to do sounds like "until" to me
21:28:16 <wavewave> hoodle doodle
21:28:36 <zzo38> DanBurton: In addition, explain your program more? What exactly is the program going to do?
21:28:56 <elliott> "hoodle" is a remarkably difficult word to pronounce
21:28:58 <SubtleArray> bd_: I love loops. They make my life easy. Lol. But seriously. I can't do what I'm trying to do without some kind of a loop. If I were to take any other approach, it would overcomplicate an already complicated project.
21:29:02 <DanBurton> zzo38: I'm trying to write a little library to simplify certain kinds of Networking tasks
21:29:07 <bd_> SubtleArray: but what are you trying to do :)
21:29:12 <bd_> haskell has lots of kinds of loops
21:29:15 <SubtleArray> DanBurton: Until? That sounds promising. I'll look it up.
21:29:21 <bd_> and while you can open code a loop, there's often a better way to do it
21:29:24 <elliott> SubtleArray: There are no "for loops" in conventional, pure Haskell as you might be thinking of them.
21:29:36 <elliott> So there's no possible way they could be less complicated than an idiomatic solution.
21:29:51 <DanBurton> zzo38: the main idea I have for it is serving a "game" a la Google Ants Challenge
21:29:53 <ion> elliott: Difficult how?
21:30:03 <elliott> ion: it's mostly the "dle"
21:30:04 <SubtleArray> bd_: Natural language processing. I already have some nice, neat functions typed up, and they work well. I used pattern matching to get them to understand certain phrases. But... The program only runs once because I can't get any of those functions to load twice. Hahaha
21:30:07 <DanBurton> AI contest, or whatever
21:30:13 <ion> Is poodle equally difficult?
21:30:15 <elliott> SubtleArray: bd_ is asking what computational task you are trying to accomplish with the loop.
21:30:16 <bd_> elliott: eh, I don't know, occasionally you have some kind of process you want to loop until it hits a steady state
21:30:28 <zachk> how do i embed XNoMonomorphismRestriction in a src file?
21:30:31 <bd_> SubtleArray: do they keep some kind of state that needs to converge over multiple runs, then?
21:30:32 <cvprog> can a compositing manager be written in haskell, are the necessary bindings there or would i have to interface with c
21:30:32 <elliott> ion: no, the "h" seems to adjust things into a ocnfiguration that makes the later "dle" more difficult
21:30:40 <elliott> zachk: {-# LANGUAGE NoMonomorphismRestriction #-}
21:30:45 <zachk> ty elliott
21:30:45 <bd_> SubtleArray: and is the number of runs fixed?
21:30:47 <zzo38> DanBurton: I don't even know what that is. Can you show a simple example of a gopher service or something?
21:30:53 <bd_> SubtleArray: or do you have some kind of convergence condition?
21:31:00 * elliott thinks it would be best to get SubtleArray to actually answer the question instead of guessing answers to it...
21:31:03 <zzo38> If it can do that?
21:31:14 <zzo38> Is it for servers?
21:31:21 <bd_> elliott: pretty much yeah
21:31:23 <zzo38> I still don't know what it is supposed to do?
21:31:41 <DanBurton> zzo38: it is for servers.
21:31:53 <SubtleArray> elliot: Regarding the clean slate, I've been trying, and I've made progress. I just need a way to call a function more than once. Ha.
21:31:54 <wavewave> hoodle doodle poodle
21:32:09 <bd_> when people act like this it's like going to a mechanic and saying, "How do I change the third gear in my transmission?" First off, why are you changing the gear in your transmission? "Well, I think I might need some kind of screwdriver, but what size?"
21:32:21 <randomclown> why isnt tuples mappable
21:32:39 <randomclown> arent*
21:32:40 <Axman6> how could it be?
21:32:47 <SubtleArray> bd_: Yes.
21:33:00 <NihilistDandy> @faq Can Haskell make SubtleArray's program sexy?
21:33:00 <lambdabot> The answer is: Yes! Haskell can do that.
21:33:01 <bd_> Now, there may be a perfectly good reason to change the third gear in your transmission, but there might well be a better way to fix that clunking you've been hearing, and if you don't tell me that, well.
21:33:01 <Axman6> randomclown: give the type of the function that maps tuples
21:33:01 <wavewave> randomclown : tuple has two type parameters while Functor has one.
21:33:11 <DanBurton> zzo38: the idea is, you construct a "NetSpec s", where "s" is your "state". You specify what ports you want to accept connections on, and then you get a list of handles which represent a single connection on each of the indicated ports
21:33:18 <randomclown> oh yeah that's right
21:33:20 <zzo38> DanBurton: Internet servers? Can you show a simple example such as a gopher service? And/or a program copying data received from one client to all clients?
21:33:24 <randomclown> tuples aren't homogenous
21:33:26 <SubtleArray> bd_: "Is the number of runs fixed?" No. That's part of the problem. I need for some questions to repeat until all conditions are met.
21:33:31 <randomclown> I see now
21:33:34 <wavewave> randomclown: if you want, make (a,a) type as Functor instance
21:33:44 <elliott> SubtleArray: Can you please tell us what task you are trying to accomplish?
21:33:46 <elliott> Not your whole program.
21:33:47 <bd_> SubtleArray: okay, so this means there's some kind of state that keeps it from just getting the same answer each time?
21:33:50 <elliott> What are you trying to do with *this* loop?
21:33:53 <DanBurton> zzo38: sure. But it's not for arbitrary servers, it's for servers that expect a specific number of connections.
21:34:10 <SubtleArray> bd_: Coverage condition? As in how far along the user is through the Q&A? Yes.
21:34:12 <wavewave> make (a,a) type as Functor instance and hoodle it down.
21:34:15 <bd_> ... user?
21:34:19 <DanBurton> zzo38: I'll try coding up a simple echo server or something
21:34:31 <bd_> SubtleArray: see, you never said anything about a UI. This is actually quite important.
21:34:38 <bd_> Are you using a GUI?
21:34:42 <bd_> Or is this command line?
21:35:03 <DanBurton> zzo38: good questions, though. If nothing else, I'm grateful you're asking questions and making me think about what it is for :)
21:36:11 <elliott> SubtleArray: It's almost impossible to help you 20 questions-style.
21:36:41 <SubtleArray> elliott: A lot of this program is already done. The only ingredient missing is some kind of a loop, or recurision, some kind of a way to call a function more than once.
21:37:02 <bd_> SubtleArray: you're not answering the question. If this is a GUI application, the answer will be _completely different_ from if it's a command-line app
21:37:11 <bd_> which in turn will be _completely different_ for if it's a pure function
21:37:22 <bd_> It is _not possible_ to answer the question with the incomplete information you've given
21:37:23 <SubtleArray> Sorry for the slow replies. I'm old. Pushing 31 now. Ha.
21:37:45 <elliott> SubtleArray: I understand.
21:37:54 <elliott> SubtleArray: But please tell us what you are actually trying to do: what that missing piece is, in concrete terms.
21:37:57 <SubtleArray> bd_: No GUI... No way. This is all command line.
21:38:12 <elliott> Otherwise it is impossible to answer adequately; the *only* detail we have is that it'd be a loop in an imperative languages.
21:38:14 <elliott> *language
21:38:20 <bd_> SubtleArray: Okay. So this is a command-line driven UI program that needs to loop back to an earlier stage of the questioning
21:38:26 <zzo38> DanBurton: If you intend to export the SpecState type, I suggest to make it instance of Functor.
21:39:01 <bd_> SubtleArray: `typically what you'd do here is make whatever the unit of looping is a function, then at the end of the function you decide to either return something, or recurse back
21:39:40 <bd_> SubtleArray: eg: http://codepad.org/WfjCTrRI
21:40:02 * elliott notes that askQuestion isn't a function, but an IO action
21:40:22 <bd_> technically yes
21:40:34 * elliott also doesn't think it's a technical point :P
21:41:02 <SubtleArray> elliot: I don't know how to be any clearer. I'm doing natural language processing. When the user types in an input, pattern matching is used to give an output until a certain match is made which then executes a task.
21:41:17 <SubtleArray> It's complicated...
21:41:19 <bd_> elliott: okay fine
21:41:22 <bd_> but technically speaking IO actions are newtypes over a function from (State# RealWorld) to (# State# RealWorld, a #) ;)
21:41:26 <bd_> (in GHC)
21:41:29 <bd_> but I digress
21:41:39 <elliott> SubtleArray: We're not asking for a description of your program: we're asking for a description of what you're trying to accomplish with the loop.
21:41:41 <zzo38> Specifically I wanted to know number of rows/columns in terminal, and these other things, I want to make a library for text adventure game in Haskell. If it could be compiled into Glulx or something then they can do that things themself instead
21:41:50 <SubtleArray> But the only thing that's keeping me from finishing this is some kind of a bloody loop. I need a way to run the program more than once.
21:41:54 <bd_> SubtleArray: so basically the user has to keep reentering invalid inputs like this? http://codepad.org/WfjCTrRI
21:42:08 <elliott> For instance, if you wanted to print 99 bottles of beer on the wall, it would be: "I want to print 'X bottles of beer on the wall / ...' for X from 0 to 99".
21:42:23 <SubtleArray> bd_: Looking at the codepad link now. Scrolling up to earlier replies.
21:42:32 <elliott> Or "I want to do the equivalent of while (x != 0) x = sqrt(x)"), etc.
21:42:36 <mandaya> SubtleArray: Can you describe what the loop condition would be? What are you looping over?
21:42:47 <elliott> The answer depends on the question; without a question, there can't be any helpful answer.
21:42:54 <bd_> SubtleArray: part of the problem here, by the way, is that Haskell has a lot of kinds of loops, which in imperative languages tend to get summarized into three or four. So if you just say a loop, it's hard to pick which kind to use :)
21:43:41 <bd_> > concatMap (\n -> print ((show n) ++ " bottles of beer on the wall...\n")) [99..0]
21:43:41 <lambdabot>   Couldn't match expected type `[b]'
21:43:42 <lambdabot>         against inferred type `GHC.Types...
21:43:52 <bd_> > concatMap (\n -> ((show n) ++ " bottles of beer on the wall...\n")) [99..0]
21:43:54 <lambdabot>   ""
21:44:06 <bd_> gah, forgot enums don't count backwards :)
21:44:09 <bd_> > concatMap (\n -> ((show n) ++ " bottles of beer on the wall...\n")) $ reverse [99..0]
21:44:11 <lambdabot>   ""
21:44:11 <SubtleArray> bd_: "to either return something, or recurse back" Recurse back! That's what I need. Is there a higher order function that does this?
21:44:27 <bd_> SubtleArray: you want a HOF to recurse until a condition becomes true?
21:44:35 <companion_cube> > [99,98..0]
21:44:35 <lambdabot>   [99,98,97,96,95,94,93,92,91,90,89,88,87,86,85,84,83,82,81,80,79,78,77,76,75...
21:44:53 <bd_> SubtleArray: it's often easier to just recurse at the end, since you have allthe variables you'll need in scope
21:45:22 <SubtleArray> bd_: Just looked at the codepad link. And YES!
21:45:26 <mandaya> I mean, a simple recursive function is easy, right?
21:45:41 <bd_> :t until
21:45:41 <mandaya> func x | meetsCondition x = base case
21:45:42 <lambdabot> forall a. (a -> Bool) -> (a -> a) -> a -> a
21:45:52 <bd_> there's until for pure code
21:45:57 <bd_> but with IO code I don't think there's a combinator
21:46:03 <mandaya> func x | otherwise = piece + func rest
21:46:06 <mandaya> *shrug*
21:46:07 <bd_> mostly because it'd often get in the way
21:46:16 <bd_> you can write one if you like
21:46:17 <SubtleArray> elliot: I've gotten pretty good at writing recursive list comprehensions, but that knowledge hasn't been helpful in recursively calling functions.
21:46:23 <bd_> SubtleArray: http://codepad.org/spJyjnG5
21:46:29 <bd_> SubtleArray: doesn't really improve readability imo
21:47:15 <zzo38> bd_: Just put it into the Kleisli category......
21:47:17 <elliott> SubtleArray: That's unsurprising, since they're unrelated concepts.
21:47:44 * elliott :( @ using an IORef here.
21:48:07 <wavewave> SubtleArray: what's difficulty in just calling a function inside itself?
21:48:08 <bd_> elliott: I wrote this when he was still being super vague about what he was doing :)
21:48:11 <zzo38> You can make a Kleisli version......
21:48:14 <SubtleArray> mandaya: I'm looping over a prompt function that prints a prompt in the command line and gets the user input, a function that parses the input, and some pattern matching functions that generate a reply.
21:48:25 <elliott> bd_: fair enough :P
21:48:37 <bd_> elliott: and figured he was doing some kind of computation that takes a number of rounds to converge :)
21:48:42 <elliott> SubtleArray: ok, that's the kind of concrete description we needed all along
21:48:45 <bd_> maybe in StateT or something ;)
21:49:00 <elliott> SubtleArray: you want an IO action that uses itself
21:49:01 <SubtleArray> bd_: "ou want a HOF to recurse until a condition becomes  true?
21:49:08 <SubtleArray> Yes.
21:49:11 <elliott> loop = do { blah <- getUserInput; print (generateOutput blah); loop }
21:49:24 <elliott> loop = do { blah <- getUserInput; if we'reQuittingNow then return () else do { print (generateOutput blah); loop } }
21:49:26 <elliott> and so on
21:49:38 <bd_> SubtleArray: I linked one in the second paste, I don't really think it helps. But you might be able to make one better tailored to your usecase (promptCheck validator message?)
21:49:39 <mandaya> SubtleArray: A bit of refactoring to separate out the IO and the actual work (the pure functions) may make it a lot oeasier
21:50:03 <elliott> SubtleArray: is there something wrong with ^?
21:50:09 <elliott> it seems to fit your description exactly
21:50:50 <SubtleArray> wavewave: I can do that? One second. I'll try that. Before I tried using other functions to "handle" the looping/recursion I wanted to do.
21:51:03 <bd_> SubtleArray: http://codepad.org/yj3fhVI8 ?
21:51:17 <mandaya> SubtleArray: why wouldn't you be able to recursively call a function...?
21:51:33 <wavewave> SubtleArray: What I said is just what elliot showed.
21:52:01 <elliott> You two should start spelling my name properly :P
21:52:20 <SubtleArray> elliot: I see. :D
21:52:31 <wavewave> oh sorry.. I will hoodle it down
21:53:30 <elliott> SubtleArray: :(
21:53:54 <mandaya> two 't's guys :)
21:54:11 * elliott gives mandaya a medal.
21:54:11 <SubtleArray> bd_: Psshtt. I wasn't that vague. :P I thought it was a simple request / simple question. "How do you loop through functions?"
21:54:16 <elliott> for Services to the Spelling
21:54:33 <bd_> SubtleArray: Okay, so if I answer "use mapM_" that would satisfy you? :)
21:54:54 <elliott> i recommend you use until + unsafePerformIO!
21:55:00 <elliott> (Please don't do this.)
21:55:03 <bd_> or "use iterate", or "fmap usually works" or "foldl?" or etc :)
21:55:12 <bd_> none of those would work for your use case
21:55:15 <bd_> but they're all loops
21:55:18 <SubtleArray> elliot: Do I want an IO action that uses itself? Yes.
21:55:34 <NihilistDandy> Are there really IRC clients that don't have tab completion?
21:55:36 <elliott> Okay, SutleAray!
21:55:42 <bd_> NihilistDandy: netcat?
21:56:46 <SubtleArray> Crap... I'm lost. Trying to catch up. Don't understand why I'm having such a hard time keeping up. I used to be awesome at IRCing.
21:57:03 <Sgeo> I want a language like Haskell with an environment like Smalltalk's
21:57:41 <SubtleArray> elliot: I don't think so. That looks very close to what the program needs.
21:58:04 <bd_> SubtleArray: ..... there is a reason that unsafePerformIO is considered unsafe
21:58:22 <bd_> in that you absolutely must understand the internals of GHC inside out to understand its semantics
21:58:22 <elliott> bd_: i think SubtleArray is replying to my line from about 23498234324 lines up
21:58:25 <bd_> oh :)
21:58:35 <elliott> time dilation!
21:58:54 <elliott> hmm, does this mean I understand the internals of GHC inside out?
21:58:58 <elliott> I never noticed
21:59:48 <bd_> elliott: either that or you don't fully understand all of the subtle edge cases that it can bring on, I guess :)
22:00:11 <bd_> I'm probably exaggerating though. But only a little.
22:00:57 <elliott> Well, GHC offers fairly good guarantees about unsafePerformIO, even if they're not written down somewhere.
22:01:05 <elliott> Although unsafeCoerce has stronger guarantees. Some of them are even written down.
22:01:10 <bd_> The "even if they're not written down somewhere" would be the key here :)
22:01:32 <SubtleArray> bd_: "Okay, so if I answer "use mapM_" that would satisfy you? :)" Actually, yeah. Lol. I feel guilty when I use up too much of people's time. That's why I like to keep things quick and simple, and then I can go off and do the research. But I do appreciate the code snipplets. They've been very helpful. I'm reading over them now.
22:02:09 <bd_> SubtleArray: mapM_ totally wouldn't work for your use-case fyi :)
22:02:29 <bd_> although it's very handy in other cases
22:03:07 <bd_> :t s
22:03:08 <lambdabot> Expr
22:03:18 <elliott> bd_: Well, if you used an infinite list and exitSuccess to break out...
22:03:27 <elliott> JUST SAYIN
22:03:29 <bd_> elliott: or IO throw?
22:03:47 <elliott> exactly!
22:04:01 <elliott> loop f = mapM_ f [0..] `catch` \Break -> return ()
22:04:05 <elliott> break = throwIO Break
22:04:17 <wavewave> SubtleArray: (loop without control) and (loop with some control) are different when you just say 'loop'
22:04:22 <elliott> loop $ \i -> if xs!!i == 0 then break else print (xs!!i)
22:05:46 <wavewave> SubtleArray: if you are just really looping from start to end, then mapM_ is adequate, but if you will finish early with some condition, you need to use different function
22:05:54 <bd_> > fix $ ([0,1]++) . join (zipWith (+) . tail)
22:05:56 <lambdabot>   [0,1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765,10946...
22:05:59 <bd_> ^^^ Find the loop! \o/
22:06:23 <wavewave> SubtleArray: that's why your question was not specifying your problem enough
22:06:48 <hpaste> SubtleArray pasted ‚ÄúAn example of the loop I'm trying to do as it would be written in C++‚Äù at http://hpaste.org/63722
22:07:01 <elliott> wavewave: ...additionally, of course, a monadic loop is a completely different beast from implementing something that would be a loop in C++ or similar
22:07:10 <elliott> like "sum" or whatever
22:07:31 <SubtleArray> I was just hoping for a simple solution to what seemed like a simple problem... >_<
22:07:33 <elliott> SubtleArray: loop = do { a <- blah1; b <- blah2 a; if blah3 b then return () else loop }
22:07:39 <elliott> it is a simple problem
22:07:50 <elliott> it's just that it could have been one of a trillion simple problems
22:07:57 <SubtleArray> I know it's a different paradigm, but I know Haskell must have a way to call functions multiple times until a condition is met.
22:07:58 <bd_> SubtleArray: there was a simple solution. The problem is we couldn't determine which simple problem it was, and therefore which simple solution was just right :)
22:08:09 <zzo38> In my (not yet posted) module Control.Category.Arrow, you can make any category with *+* and fanout loop:   loopOut x = x . (id &|& loopOut x); let loopIn x = (id |&| loopIn x) . x;
22:08:21 <elliott> well, it's not "calling functions"
22:08:24 <elliott> it's sequencing monadic actions
22:08:25 <alang> SubtleArray: the problem is that it has many many ways
22:08:26 <elliott> functions are pure
22:08:31 <elliott> so calling a function multiple times just wastes time
22:08:33 <zzo38> You could do this with Control.Arrow too, probably; it is similar (although mine is more generalized)
22:08:34 <bd_> SubtleArray: Sure. I codepad'd you a fairly general method. But there are dozens of others that might be a bit clearer or shorter depending on the context.
22:08:37 <elliott> unless you do something with the result, or whatever
22:08:43 <elliott> SubtleArray: sorry, my example was a bit wrong
22:08:45 <bd_> zzo38: ... I don't think that'll help him much, really :)
22:08:50 <wavewave> SubtleArray : you want multiple side effects
22:08:52 <elliott> SubtleArray: loop = do { a <- blah1; b <- blah2 a; c <- blah3 b; when c loop }
22:08:57 <elliott> SubtleArray: ^ is probably what you want
22:09:04 <elliott> if all the blahs return IO actions
22:09:07 <zzo38> bd_: You are right but maybe it will help you
22:09:12 <letrec> Is there a way to simplify this: func iol w = do { l <- iol; return (w:l) } ?
22:09:37 <SubtleArray> *taking notes*
22:09:47 <wavewave> (:) w <$> iol
22:09:51 <bd_> zzo38: to be honest when I see arrows my eyes usually start to glaze over :) at that point the returns from mental effort just stop being worth it
22:09:58 <bd_> @pl  func iol w = do { l <- iol; return (w:l) }
22:09:58 <lambdabot> (line 1, column 17):
22:09:58 * hackagebot couchdb-conduit 0.5.3 - Couch DB client library using http-conduit and aeson  http://hackage.haskell.org/package/couchdb-conduit-0.5.3 (AlexanderDorofeev)
22:09:58 <lambdabot> unexpected "{"
22:09:58 <lambdabot> expecting variable, "(", operator or end of input
22:10:13 <bd_> @. pl undo func iol w = do { l <- iol; return (w:l) }
22:10:14 <lambdabot> func = flip (fmap . (:))
22:10:18 <bd_> there you go
22:10:27 <elliott> letrec: func iol w = (w:) <$> iol
22:10:34 <elliott> letrec: I suggest swapping the parameters
22:10:36 <elliott> letrec: then it's just
22:10:39 <elliott> func = fmap . (:)
22:10:44 <elliott> or func w = fmap (w:)
22:11:12 <bd_> or func iol w = fmap (w:) iol  if you insist on that parameter order
22:11:17 <zzo38> bd_: I don't like the standard Control.Arrow it isn't very generalized. Such as, I don't like arr together with the others, I also don't like the order of the default definitions; I prefer *+* and fanout (or, *** and (id &&& id)) as basic; no need for ArrowChoice since that is just the dual category, and using Either instead of (,) as the pairs type
22:11:57 <zzo38> It is not very good unless you can understand category theory first. That work with Kleisli categories, and so on, too.
22:14:14 <zzo38> (loopOut and loopIn are dual to each other.)
22:17:03 <SubtleArray> Thank you all for your time and help. I'm going to organize the info. I should be able to work out a solution now.
22:50:17 <letrec> I'm looking for a loop operator working on monadic values and with accumulation. That would be something like: m (Maybe a) -> (b -> a -> b) -> b -> m b
22:50:20 <letrec> Any idea?
22:50:33 <NihilistDandy> @hoogle m (Maybe a) -> (b -> a -> b) -> b -> m b
22:50:34 <lambdabot> Data.Foldable foldl :: Foldable t => (a -> b -> a) -> a -> t b -> a
22:50:34 <lambdabot> Data.Foldable foldl' :: Foldable t => (a -> b -> a) -> a -> t b -> a
22:50:34 <lambdabot> Control.Monad liftM2 :: Monad m => (a1 -> a2 -> r) -> m a1 -> m a2 -> m r
22:52:00 <letrec> @hoogle m (Maybe a) -> (a -> b -> b) -> b -> m b
22:52:01 <lambdabot> Data.Foldable foldr :: Foldable t => (a -> b -> b) -> b -> t a -> b
22:52:01 <lambdabot> Data.Foldable foldr' :: Foldable t => (a -> b -> b) -> b -> t a -> b
22:52:01 <lambdabot> Control.Applicative liftA2 :: Applicative f => (a -> b -> c) -> f a -> f b -> f c
22:57:41 <elliott> letrec: so foo next f z = next >>= maybe (return z) (foo next f . f z)?
22:57:49 <ion> @type \f z -> (Data.Foldable.foldlM f z =<<)
22:57:50 <lambdabot> forall b b1 (m :: * -> *) (t :: * -> *). (Data.Foldable.Foldable t, Monad m) => (b -> b1 -> m b) -> b -> m (t b1) -> m b
22:58:21 <hpaste> DanBurton pasted ‚ÄúNetSpec echo‚Äù at http://hpaste.org/63723
22:58:52 <ion> @type \f z -> (Data.Foldable.foldlM (return .: f) z =<<)
22:58:53 <lambdabot> forall a (m :: * -> *) b (t :: * -> *). (Monad m, Data.Foldable.Foldable t) => (a -> b -> a) -> a -> m (t b) -> m a
22:58:58 <DanBurton> it's been a while :) but I finally finished tinkering for now. What do you guys think? ^
22:59:30 <letrec> elliott: Thanks, will look at it :)
23:04:50 <ion> letrec: ‚Üë
23:06:48 * elliott likes that
23:06:54 <elliott> though er
23:06:56 <elliott> ion: no, that's wrong
23:07:09 <elliott> if I am correctly interpreting the intent, as a *loop* combinator it should run the m (Maybe a) multiple times
23:07:11 <elliott> stopping on a Nothing
23:07:15 <elliott> -- but this is another guessing game...
23:07:33 <letrec> elliott: Right, that's what I wanted
23:08:33 <ion> ah
23:20:00 * hackagebot lio 0.1.2 - Labeled IO Information Flow Control Library  http://hackage.haskell.org/package/lio-0.1.2 (DeianStefan)
23:25:02 * hackagebot dclabel 0.0.5 - The Disjunction Category Label Format  http://hackage.haskell.org/package/dclabel-0.0.5 (DeianStefan)
23:35:39 <DanBurton> is there a Networking library with the same interface as "import Network" but that works with ByteString or Text instead of String?
23:36:15 <elliott> DanBurton: yes, Network
23:36:23 <elliott> .Socket.ByteString
23:36:28 <ben> There's a package called network-bytestring, so I remain hopeful
23:36:31 <elliott> if you want the low-level interface
23:36:33 <elliott> network-bytestring is deprecated
23:36:38 <elliott> DanBurton: Network just works with Handles; what do you want?
23:36:45 <elliott> ByteString and Text have functions to work on Handles.
23:36:54 <elliott> Network.Socket works on String; there's Network.Socket.ByteString for that
23:38:58 <DanBurton> right, what I wanted was working with Handles
23:39:40 <DanBurton> so the module I really want comparable functions for is System.IO
23:40:25 <elliott> DanBurton: Data.ByteString and Data.Text.IO contain Handle-based functions
23:40:30 <ben> http://hackage.haskell.org/packages/archive/bytestring/latest/doc/html/Data-ByteString.html#g:26
23:40:49 <ben> sorry, http://hackage.haskell.org/packages/archive/bytestring/latest/doc/html/Data-ByteString.html#g:29
23:41:25 <DanBurton> looks perfect, thanks elliott. /hits "that was easy!" button
23:45:02 <letrec> Any simpler way to write:  func next f v0 = next >>= maybe (return v0) (\x ->  f v0 x >>= func next f )
23:45:27 <elliott> func next f v0 = next >>= maybe (return v0) (f v0 >=> func next f)
23:45:49 <elliott> func m f z=m>>=maybe(return z)$f z>=>func m f :P
23:46:02 <elliott> @pl let func m f z -> m >>= maybe (return z) (f z >=> func m f) in func
23:46:02 <lambdabot> (line 1, column 16):
23:46:02 <lambdabot> unexpected "-"
23:46:03 <lambdabot> expecting pattern or "="
23:46:11 <elliott> @pl fix (\me m f z -> m >>= maybe (return z) (f z >=> me m f))
23:46:12 <lambdabot> fix (ap ((.) . (.) . (>>=)) . (((liftM2 maybe return .) . liftM2 flip ((>=>) .)) .))
23:46:16 <elliott> try that :P
23:46:23 <letrec> :P
23:46:26 <DanBurton> so much simpler!
23:47:28 <DanBurton> I wish there were syntax for "do x <- foo; case x of ..." that didn't require naming x
23:47:55 <MaskRay> I wish there were  if' :: Bool -> a -> a -> a
23:50:28 <merijn> DanBurton: I think there was an extension in the works that did that
23:50:49 <merijn> (or maybe I'm confused from reading the Habit language report and it hasn't been ported to haskell)
23:50:49 <elliott> MaskRay: wrong argument order
23:50:59 <NihilistDandy> I definitely remember seeing a similar desire expressed on one of the lists
23:51:25 <merijn> Habit supports the syntax "case<- foo of ..." (or something similar)
23:51:55 <MaskRay> elliott: ?
23:52:20 <elliott> MaskRay: should be bool :: a -> a -> Bool -> a
23:52:26 <elliott> for partial application (compare maybe, foldr)
23:52:38 <NihilistDandy> merijn: I hadn't heard of Habit. I'm impressed by the level of effort, though. Systems programming could be more joyful :D
23:52:51 <NihilistDandy> Or perhaps just habit-forming
23:54:35 <MaskRay> elliott: i grasp. it will make currying easy to perform
23:55:33 <merijn> The typeclass stuff in there is also nice, just not sure if/when that Habit will be open sourced/released
23:55:57 <erus`> will pl code compile down to the same code as non-pl ?
23:56:19 <NihilistDandy> I wonder how much C is underneath it all
23:57:45 <DanBurton> suppose I want to re-export the IsString instance for ByteString in my module, can I do that?
23:58:21 <elliott> yes: just import it
23:58:28 <elliott> instances don't follow normal import/export rules
23:58:36 <elliott> if they can get somewhere, they will
23:59:21 <NihilistDandy> I can't wait for the first "instances are bedbugs" tutorial
