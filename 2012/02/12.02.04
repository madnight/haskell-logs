00:03:38 <btvl> is there a more elegant notation for : do { m <- computeFileMD5 fullname ; return $ Right (filename, m) } ?
00:05:04 <edwardk> fmap (Right . (,) fileName) $ computeFileMD5 fullname
00:05:26 <edwardk> which can probably be turned into Right . (,) fileName <$> computeFileMD5 fullname or some such
00:05:41 <btvl> i'm not sure I'd say it is more readable
00:06:26 <edwardk> with a monad comprehension you get [ Right (filename, m) | m <- computeFileMD5 fullname ]
00:06:56 <btvl> Actually I just realized (,) is a function
00:07:33 <wavewave> tkahn6 : simpler.. just import Text.Regex.Posix.String  http://hpaste.org/57393
00:07:56 <edwardk> :t (,)
00:07:57 <lambdabot> forall a b. a -> b -> (a, b)
00:08:13 <penelope> Where can one get monad comprehensions?
00:08:22 <Jafet> A time machine
00:08:23 <wavewave> ?
00:08:44 <Jafet> (It works whichever way you go!)
00:08:55 <penelope> :-)
00:08:59 * zygoloid goes sideways
00:09:21 <edwardk> jafet: they were added back
00:09:24 <wavewave> btvl ; once you are used to the point-free style, actually it's quite readable.
00:09:44 <btvl> I'll try to get used to this then
00:09:58 <wavewave> point free style and applicative style.
00:10:28 <wavewave> btvl : there is also a GHC extension called TupleSections
00:10:45 <wavewave> which allows  (filename, )
00:11:10 <wavewave> as a function \x -> (filename,x)
00:11:16 <edwardk> wavewave yeah: i just never like the way it looks ;)
00:11:40 <btvl> sounds like the kind of thing you can write but can't read 2 month later
00:11:43 <penelope> (:[])
00:12:10 <wavewave> edwardk : I use it when I boast off the succintness of  my code to my friends  ;-)
00:12:43 <edwardk> :t \whatever doyou mean -> (whatever,,,doyou,,mean,,)
00:12:44 <lambdabot> Illegal tuple section: use -XTupleSections
00:12:47 <edwardk> bah
00:13:13 <btvl> I have an architectural question : I just write this function that runs in its thread and listens on a channel for requests, then answers on the same channel
00:13:14 <wavewave> btvl : in fact, longer code is more difficult to reconstruct after 2 months.
00:13:17 <edwardk> ok, going to sleep i have to get up in ~3 hours and move boxes all day
00:13:35 <btvl> right now the "clients" duplicate the channel and write/read to it
00:13:37 <wavewave> I find one-liner is always good. (rather bold claim I know.. )
00:13:56 <penelope> You should offer coffee and dougnuts for help.
00:14:03 <btvl> I just have a single client, but I can already read everything i wrote
00:14:15 <btvl> I suppose with 100 clients, everybody will see each others chatter ?N
00:14:22 <wavewave> edwardk: good nite.
00:14:23 <edwardk> clearly
00:14:24 <edwardk> > let w(p,q)i=(p*i+1,q*i);d%(p,q)=p*d`div`q;(x:y:s)^d|d%y>d%x=s^d|0<1=mod(d%x)10:s^(10*d)in 2:scanl w(1,1)[1..]^10>>=show
00:14:26 <lambdabot>   "27182818284590452353602874713526624977572470936999595749669676277240766303...
00:14:31 <edwardk> is the most obvious way to do that ;)
00:14:49 <edwardk> > let(q,r,t,k,n)%l|4*q+r-t<n*t=n:(10*q,10*(r-n*t),t,k,div(10*(3*q+r))t-10*n)%l|z<-t*l=(q*k,(2*q+r)*l,z,k+1,div(q*(7*k+2)+r*l)z)%(l+2)in(1,0,1,1,3)%3>>=show
00:14:50 <lambdabot>   "31415926535897932384626433832795028841971693993751058209749445923078164062...
00:15:03 <edwardk> ;)
00:15:11 <penelope> go away, APL.
00:15:57 <Jafet> > let w(p,q)i=(p*i+1,q*i);d%(p,q)=p*d`div`q;(x:y:s)^d|d%y>d%x=s^d|0<1=mod(d%x)10:s^(10*d)in 2:scanl w(1,1)[1..]^10>>=show -- more readable version
00:15:58 <lambdabot>   "27182818284590452353602874713526624977572470936999595749669676277240766303...
00:16:08 <Jafet> Oh wait, that's the same one
00:16:14 <Jafet> It's still more readable though
00:16:19 <edwardk> if i can eke out a couple fewer characters the latter becomes tweetable
00:16:37 <penelope> I like the "more readable". That's a nice touch.
00:16:38 <tkahn6> wavewave: thanks
00:16:48 <Jafet> > '3':fix(\s n m->let a%i=10^(3*n)`div`(a^i*i)in(take n.drop n.show$sum[4*(-1)^div i 2*(2%i+3%i)|i<-[1,3..m]])++s(2*n)(2*m))1 9 -- more readable
00:16:50 <lambdabot>   "31415926535897932384626433832795028841971693993751058209749445923078164062...
00:16:59 <edwardk> penelope: of course its more readable. the comment constitutes something like 20% of the code ;)
00:17:22 <edwardk> ooooh
00:17:58 <Taneb> Could Text.PrettyPrint.ANSI.Leijen.Doc be a Monoid with mempty being empty and mappend = (<>)?
00:18:02 <Jafet> I bet edwardk is trying very hard to decipher that one.
00:18:05 <edwardk> that meets my tweetable requirement
00:18:35 <wavewave> btvl : I do not understand your architecture question yet.
00:18:38 <arcatan> hmm, how does that work?
00:18:40 <edwardk> Taneb: yes
00:18:54 <btvl> might be easier if I explain what I want to achieve
00:19:05 <edwardk> taneb: wl-pprint-extras is basically that, with exactly that monoid
00:19:11 <Taneb> Okay
00:19:12 <edwardk> just with an extra argument for annotations
00:19:12 <Taneb> :)
00:19:18 <btvl> In a thread I keep a Map.Map filename attributes
00:19:33 <btvl> random threads can ask for the attributes, or to expire the cache
00:19:37 <edwardk> ok. sleeping
00:19:57 <wavewave> btvl : in fact, you are interested in a similar problem of my concern
00:20:13 <btvl> rewriting puppet so that it runs in finite time ?
00:21:01 <wavewave> ?
00:21:13 <wavewave> so what's your question
00:21:14 <wavewave> ?
00:21:27 <btvl> how do i setup the message passing system ?
00:21:38 <btvl> a single channel shared by all ?
00:21:47 <btvl> or is there something clever that i am missing
00:21:53 <btvl> because i'm not sure how to multiplex in all cases
00:22:30 <wavewave> btvl : this is not a problem with one answer that solves all cases.
00:22:50 <wavewave> depending on the complexity and bottleneck of your problem domain.
00:23:22 <btvl> the "master" threads does disk I/O, and it is ok if it blocks and clients have to wait for their answers
00:23:42 <btvl> clients either ask for a file attributes, or to expire these attributes from the master's cache
00:24:03 <wavewave> btvl : it's like a question of CAP theorem of Database.
00:24:31 <btvl> well I suppose it is a pretty common pattern
00:24:31 <wavewave> if you need consistency most, then you need to have master-slave
00:24:37 <btvl> when you want to share a cache
00:25:09 <wavewave> if you are okay with eventual consistency only, then you can make the system more partition tolerant.. and distributive...
00:25:18 <wavewave> more democratic.
00:25:29 <btvl> consistency is very important
00:25:47 <wavewave> but for simplicity, I recommend you to start master-slave first
00:25:55 <penelope> consistency, or eventual consistency?
00:25:56 <btvl> but my concern is that I have no clue on how to do a select on channels, and answer only to a client
00:26:31 <btvl> the cache must be consistent at all times
00:26:45 <btvl> it is ok if some clients requests are handled before an expiration order
00:26:51 <wavewave> penelope : eventual consistency allows temporal inconsistency in state
00:27:36 <Flonk> So, I decided to check out haskell today
00:27:48 <Flonk> Messed around with the web-tutorial etc
00:27:55 <btvl> but the data structure consistency should be of no concern because it is owned by a single thread
00:28:01 <penelope> Control.Concurrent.threadWaitRead?
00:28:11 <Flonk> And I just downloaded GHC, but when I try to compile an empty script, I get an error
00:28:14 <Flonk> The function `main' is not defined in module `Main'
00:28:16 <Flonk> Wat do?
00:28:23 <Taneb> main = return ()
00:28:24 <Jafet> Use PHP instead
00:28:41 <btvl> run with ghci then try typing the thing you wanted evaluated
00:29:03 <wavewave> follow "getting started" section of tutorial.
00:29:43 <penelope> Flonk: What os?
00:30:03 <btvl> threadWaitRead seems to work with standard file descriptors
00:30:20 <Flonk> penelope: win7
00:30:32 <Flonk> wavewave: all those tutorials start off with chapters all done in ghci
00:30:36 <btvl> I know how to do it with unix sockets, but I guess the haskell "chan"s are much more effective
00:30:39 <Flonk> So I thought I might aswell ask
00:30:44 <wavewave> Flonk : did you download haskell platform?
00:31:20 <penelope> Flonk: if you installed the haskell platform, there should be a ghci or windows equiv.
00:31:33 <Flonk> wavewave: yep
00:31:44 <Taneb> ghci comes with GHC, I think
00:31:56 <Flonk> penelope: There is, I just don't want to type everything into ghci, but have my stuff in a file
00:32:09 <wavewave> Flonk : use :l
00:32:14 <wavewave> :l filename.hs
00:32:22 <Taneb> ..Why did you try to compile an empty file?
00:32:27 <wavewave> then you can learn multiple line script in ghci
00:32:43 <wavewave> learn -> run
00:32:46 <wavewave> :-P
00:32:47 <strager> I was poking around and I came across build :: (forall b. (a -> b -> b) -> b -> b) -> [a]
00:33:13 <strager> However, build (\x y -> y) :: [a] -- why is that?  I would expect build (\x y -> y) :: b -> b -> [a]
00:33:31 <strager> Wait, I think I figured it out.
00:33:39 <strager> x :: (a -> b -> b)
00:33:43 <wavewave> btvl : there are several network process communication concept library in haskell
00:33:52 <wavewave> one is CHP : communicating haskell processes
00:34:16 <wavewave> there is also some cloud haskell thing
00:34:49 <wavewave> https://github.com/jepst/CloudHaskell
00:35:20 * BMeph gives strager a golf clap
00:35:41 <penelope> Hmm. But there's nothing quite like C-c C-l to run haskell.
00:36:44 <penelope> Flonk? Maybe try to get http://leksah.org/ running?
00:36:50 <btvl> ah yes I have seen this cloudhaskell thingie
00:37:14 <btvl> is that the thing where they implemented function serialization ?
00:38:02 <penelope> function serialization ?
00:38:05 <wavewave> btvl : i don't know.. but I think you had better not rely on function serialization even if it is realized.
00:38:16 <btvl> heh
00:38:29 <wavewave> penelope : some idea was sketched in a paper.
00:38:30 <btvl> this was a big part of their paper if this is the same thing ;)
00:38:31 <Taneb> Is there a better way to write \xs ys -> map (\x -> ($ x) (map (,) xs )) ys
00:38:33 <Taneb> ?
00:38:54 <wavewave> http://research.microsoft.com/~simonpj/papers/parallel/remote.pdf
00:39:12 <dobblego> Taneb: yes, first recognise that map f (map g x) is better written map (f . g) x
00:40:00 <wavewave> section 5 of the paper.
00:40:17 <Flonk> penelope: I think the main problem is that I have no idea what a basic program looks like, and where the code goes
00:40:31 <penelope> Flonk:
00:40:32 <penelope> so
00:40:38 <Flonk> Like when you first start coding C++ you have no idea what 'include "stdafx.h"' means, you just roll with it
00:40:39 <penelope> start with
00:40:51 <wavewave> Flonk: so.. I just recommend you to read some "getting started"
00:40:58 <penelope> module Main where
00:41:07 <penelope> main :: IO ()
00:41:33 <penelope> main = print "Hello World"
00:41:44 <wavewave> multiline script can be written in some file and loaded using :l in ghci prompt
00:42:33 <penelope> I think a good start is the seminal paper, "Why functional programming matters"
00:42:49 <Flonk> wavewave: same problem though, source file is not valid
00:42:52 <Flonk> I'll do some reading though
00:43:32 <wavewave> btvl : anyway.. if you are not sure about the design, I recommend you to start with a single almighty server / very minimal client first.
00:44:02 <wavewave> btvl : then when some bottleneck arises, move things to client one by one.
00:44:28 <btvl> but I already have a problem
00:44:33 <penelope> Flonk: try to get Leksah installed--it's probably more familiar to you than emacs+unix+bash...
00:44:43 <btvl> duplicating channels creates a broadcast channel
00:44:48 <btvl> I have to filter out messages I don't want
00:44:54 <wavewave> designing a distributive system from the scratch without previous experience or prebuilt library is daunting.
00:45:08 <btvl> I have a bit of experience with C
00:45:12 <penelope> (it's like the eclipse of haskell)
00:45:24 <shachaf> Flonk: I would recommend focusing less on "completed programs" that do things  and more on experimenting with smaller parts of the language interactively (in ghci).
00:45:48 <Ke> I'd rather love some emacs for haskell
00:45:54 <wavewave> btvl : I don't understand ?
00:46:08 <Ke> ie. yi, but more lively community
00:46:19 <btvl> i create a chan that i pass to the master thread
00:46:23 <Ke> and ncurses
00:46:26 <btvl> then duplicate it for all childs
00:46:30 <btvl> well, all clients
00:46:39 <wavewave> okay.
00:46:41 <btvl> if a client writes in the chan, all others can see it
00:46:41 <penelope> If i could only figure out how to do C-c C-l in Yi....
00:46:48 <btvl> if the master answers, all clients see the answer
00:46:53 <btvl> at least that is my understanding
00:47:14 <btvl> this means i have to add a clunky "request id" and make sure it is not shared by 2 clients
00:47:14 <Ke> penelope: you can extend it at will
00:47:52 <Jafet> But penelope still has to figure out how to do that
00:47:53 <btvl> this also means as i scale clients will spend more time filtering unwanted messages than what they need, but this is a theoritical concern for now
00:47:55 <Flonk> penelope: Usually not the IDE guy (except for C++ development where you need it to get anything done), but I'll download it
00:48:25 <wavewave> btvl : I think you are interested in CHP most..
00:48:31 <Ke> the ncurses and lack of syntax highlight are real issues
00:48:32 <btvl> I'll take a look at this then
00:48:45 <tikhonjelvis> Flonk: What do you normally use?
00:49:06 <btvl> wow the api is certainly much more complex than chan !
00:49:16 <penelope> oh, but the super indentation!
00:49:17 <wavewave> btvl : it's more featureful than chan..
00:49:32 <wavewave> btvl : definitely most are what you want I guess.
00:49:48 <Flonk> tikhonjelvis: Sublime Text - you can check across files for functions, it has a nice plugin system..
00:50:11 <btvl> thanks for the pointer
00:50:15 <penelope> No, what Yi is really missing is the self-documentation that lisp has.
00:50:16 <tikhonjelvis> Ah, I don't know much about it. But if it does indentation correctly and lets you easily load/compile files, it should be more than good enough.
00:50:49 <Jafet> Does yi use Haskell?
00:50:58 <Ke> yes
00:51:06 <Jafet> Through, what, hint?
00:51:06 <penelope> Yi only does haskell.
00:51:13 <Ke> it's a haskell library like xmonad afaik
00:51:21 <wavewave> Yi is written in haskell.. scripted in haskell
00:51:41 <wavewave> yi has dynamic reloading feature.
00:51:48 <Ke> like xmonad
00:51:55 <penelope> If Xmonad was an editor, it would be called Yi.
00:51:56 <wavewave> yeah.
00:52:12 <wavewave> using the same infrastructure : dyre
00:52:41 <Jafet> I suppose it then stems from the Haskell journeyman's lazy habit of not writing documentation
00:52:44 <penelope> Fast though: emacs takes like 5 minutes to start up.
00:52:54 <penelope> Yi: instant.
00:53:03 <tikhonjelvis> emacsclient :)
00:53:10 <penelope> Yes
00:53:12 <Jafet> That's but a sign that you need to rewrite your .emacs
00:53:12 <penelope> But
00:54:11 <penelope> I have my "desktop" saved. It's the massive amounts of files that I have what with all the syntax coloring.
00:54:36 * ski . o O ( <http://www.ymeme.com/zmacs-vs-emacs-manual.html> )
00:54:44 <Jafet> I thought emacs was lazy about syntax colouring
00:54:49 <wavewave> penelope: so you use yi for your production setting?
00:54:55 <penelope> There is that option
00:54:55 <Jafet> Maybe it's different for coloring
00:55:15 <Ke> so that ncurses ui anyone?
00:55:26 <penelope> wavewave: no, in fact, I haven't even gotten it to run ghci in a sub-session.
00:55:34 <wavewave> penelope : I am thinking of switching from emacs to yi... but I want to hear some user's opinion
00:56:05 <wavewave> penelope : that's not a big deal to me... My concern is whether it has some quirks in editing.
00:56:08 <Ke> so is there some collection of yi syntax hilighting?
00:56:12 <tikhonjelvis> Does Yi have anything like TRAMP?
00:56:29 <penelope> Oh, it edits nicely.
00:56:58 <penelope> You can hit M-x and write a haskell snippet to mutate your code
00:57:00 <wavewave> I saw some negative comments on yi when editing some large file.
00:57:02 <penelope> That is cool.
00:57:19 <penelope> How large could a haskell file be?
00:57:39 <penelope> All I've ever seen is lightening response.
00:57:50 <wavewave> okay great.
00:57:52 <penelope> I mean, compared to emacs?
00:57:55 <Ke> penelope: if you really spend time tuning some editor, you may want it to be useful for something more than haskell
00:58:03 <penelope> It's a velociraptor.
00:58:12 <penelope> Oh
00:58:30 <companion_cube> download a snapshot of wikipedia and edit it :]
00:58:35 <penelope> Well, sometimes it's good to be a brotosaurous.
00:58:56 <tikhonjelvis> I once converted a 70,000 line CSV file to JSON using an Emacs keyboard macro. But it took forever.
00:59:00 <wavewave> I want to have emacs server/client feature in yi..
00:59:38 <penelope> I think, if we all clap our hands hard enough....
00:59:51 <wavewave> penelope : by the way.. saving your previous open document status and coming back to it later is easy?
00:59:53 <tikhonjelvis> Aww, Yi isn't very buildy today.
01:00:05 <penelope> It just build for me....
01:00:23 <penelope> You might have the usuall cabal gunk....
01:00:29 <penelope> oh
01:00:30 <tikhonjelvis> maybe
01:00:32 <penelope> my
01:00:34 <penelope> god
01:00:40 <tikhonjelvis> I'll try the git repo. One can hope...
01:00:46 <btvl> wavewave: actually I just realized I can send a Chan in a Chan, so it solves my problem : all clients have the same control chan, where they write their requests and the chan they are listening on
01:00:56 <btvl> and I get to use the easy API
01:01:06 <penelope> http://www.gnu.org/software/emacs/manual/html_node/elisp/Desktop-Save-Mode.html
01:01:27 <wavewave> btvl : good.. I would doubt if base library only supports broadcasting
01:02:24 <wavewave> penelope: so that is possible in yi editor too?
01:03:00 <penelope> More than possible. But you'll have to write the extension yourself...
01:03:08 <penelope> (don't be stingy)
01:04:02 <wavewave> penelope : I know that it's possible to extend yi editor, but I just want to know whether somebody already made some script for it.
01:04:15 <penelope> Ah.
01:04:31 <penelope> I think, the short answer is: No!
01:04:36 <wavewave> penelope : anyway.. actually I am thinking something big with yi.
01:05:14 <wavewave> I am now making pen notetaking  program in haskell.
01:05:29 <penelope> Hey, I'd use it for haskell if I could just figure out an easy way for it to reload/recompile/run a ghci.
01:05:54 <wavewave> I am thinking incorporating it with text editor.. (pen annotating on top of text editor. )
01:06:49 <wavewave> anyway.
01:07:52 <xarch____> hi
01:08:12 <wavewave> yi is a pretty big project.. I feel a little sad that it seemed to lose its momentum somehow.
01:08:18 <wavewave> hi
01:09:48 <tikhonjelvis> Well, no reason for it not to randomly pick up a bit of momentum all of a sudden.
01:10:49 <wavewave> hope that starts again.
01:11:27 <tikhonjelvis> It does sound like a very promising option.
01:11:50 <xarch> I'd like to embed Scheme/Lisp in Haskell, but I want it to be sandboxed as possibly untrusted might want to use it, what library should I use?
01:12:09 <xarch> I've looked for tinyscheme/guile bindings but I couldn't find one
01:12:30 <xarch> there's HuskScheme but I'm not sure it's safe to use it as users might be able to mess with I/O for example
01:13:35 <wavewave> www.haskell.org/haskellwiki/Applications_and_libraries/Compilers_and_interpreters#Scheme
01:14:08 <xarch> yeah well I've seen that but there's only tutorials on implementing a smal subset of scheme
01:14:15 <xarch> that's not what I want
01:14:42 <wavewave> xarch : that should not do any unsafe things at all, though ;-)
01:15:40 <xarch> yes
01:16:00 <wavewave> scheme is a very minimal language so I think even those tutorials are okay for decent purpose.
01:16:17 <wavewave> Just expose some haskell function as scheme function.
01:16:18 <tikhonjelvis> They probably miss the fun bits like macros and call/cc.
01:17:19 <penelope> do not embed scheme in haskall when one could evalute haskell in haskell...
01:18:12 <penelope> no reason to go back 20 years....
01:19:37 <wavewave> penelope : well, you can think scheme direction as another viable direction of untyped lambda calculus
01:20:27 <penelope> As if the untyped lambda calculus were a direction
01:20:44 <penelope> Rather than just a throwing up of hands.
01:21:19 <wavewave> it has its own advantage though.. like self-evaluation kind of thing.
01:22:12 <penelope> True. But we could do some sort of eval in haskell...
01:22:24 <penelope> Granted, not as trivial.
01:22:46 <wavewave> For some DSL, dynamic untyped language may still be good
01:23:37 <wavewave> yeah.. not trivial..
01:24:00 <wavewave> partial evaluation in typed lambda calculus is rather complex
01:24:28 <penelope> GHCi does it.
01:24:55 <wavewave> no.. that's just interpretation.
01:25:23 <penelope> As opposed to the scheme repl?
01:26:26 <penelope> You want a just in time for a string for haskell?
01:26:45 <penelope> (So don't we all!)
01:26:54 <wavewave> if you want to your interpreted language as fast as your host language, you need to have a sort of dynamic untyped language in the middle.
01:27:35 <wavewave> ghc runtime also does it. as system FC.
01:28:32 <wavewave> so still scheme-like language has its use... even with prolific haskell
01:28:48 <penelope> I'm curious, why should we need a dynamic, untyped language in the middle?
01:29:25 <penelope> What's the diffence between my typing and a file?
01:30:09 <wavewave> I am not an expert on that at all, but there are big chunk of references on this stuff.
01:30:22 <penelope> GHC is a beast, granted
01:30:42 <wavewave> search for partial evaluation or something like that.
01:30:58 <penelope> But I don't see how it's fundamentally different than scheme...
01:31:03 <ski> there are partial evaluators for typed systems as well
01:31:30 <ski> (though maybe you're talking about second and third futamura projection)
01:31:37 <wavewave> ski: yeah.. it's rather complicated.
01:32:33 <ski> the deal with futamura is that it's hard to apply a partial evaluator to itself, in a typed language
01:32:45 <ski> (it might be possible, though)
01:32:46 <mekeor> why is "<-" syntax and not a function?
01:32:56 <ski> mekeor : can't be a function
01:33:25 <ski> mekeor : why is `=' in `let x = 2 in x*x' syntax and not a function ?
01:33:28 <tkahn6> mekeor, what do you mean?
01:33:34 <companion_cube> why did I read 'futurama'?
01:33:41 <tkahn6> lol
01:33:51 <Jafet> It's not futurama, it's simpson
01:33:58 <ski> wavewave : but i'm not sure why you claim "you need to have a sort of dynamic untyped language in the middle"
01:34:24 <companion_cube> greenspun's law
01:34:32 <penelope> I thought the deal with futurama was that leela was an unrealistic character?
01:34:53 <companion_cube> yes, she knows how to drive a spaceship
01:34:56 <mekeor> ski: why it cant be a function?
01:35:19 <Jafet> Oh, I thought the cube read "function" for "futurama"
01:35:21 <ski> mekeor : the thing to the left of `<-' isn't an expression
01:35:27 <Jafet> Meta-misreading
01:35:33 <ski> functions takes expressions as arguments
01:35:44 <wavewave>   ski: I am not sure, either. ;-/
01:35:45 <mekeor> ski: oh, right...
01:36:07 <companion_cube> I read "futamura" as "futurama", same multiset of letters :)
01:36:08 <wavewave> seems like that's easiest solution.
01:38:08 <wavewave> mufurata maratafu
01:38:13 <wavewave> nono
01:38:16 <wavewave> maratufu
01:38:41 <wavewave> very mathematical name.
01:38:42 * hackagebot TCache 0.9.0.2 - A Transactional cache with user-defined persistence  http://hackage.haskell.org/package/TCache-0.9.0.2 (AlbertoCorona)
01:39:01 <wavewave> m  a  -> r -> a -> t u -> f -> u
01:39:55 <Jafet> @quote Eval
01:39:55 <lambdabot> JonHarrop says: I lurk on the Haskell Cafe mailing list and eager evaluation is often the solution to reliability or performance problems: laziness is unpredictable.
01:40:04 <Jafet> @quote Eval.x
01:40:04 <lambdabot> autrijus says: * autrijus stares at type Eval x = forall r. ContT r (ReaderT x IO) (ReaderT x IO x) and feels very lost <shapr> Didn't you write that code? <autrijus> yeah. and it works <autrijus> I
01:40:04 <lambdabot> just don't know what it means.
01:41:40 <wavewave> whatever it is said, i love laziness, and that's why i started to learn haskell.
01:44:40 <tkahn6> @where RTS-xc
01:44:40 <lambdabot> ghc --make -fforce-recomp -prof -auto-all -rtsopts foo.hs && ./foo +RTS -xc
01:55:12 <mjga> how to tell lambdabot to change its answer? ghc --make -prof -auto-all -rtsopts -osuf .p_o foo.hs && ./foo +RTS -xc  # works better if you use Template Haskell, which needs unprofiled object files when compiling
01:55:53 <jamy23> someone tell me what ever audiobook in Haskell?
01:56:17 <jamy23> sorry aboute haskell
01:57:13 <ski> @help where+
01:57:13 <lambdabot> where+ <key> <elem>. Define an association
01:57:26 <mjga> ski: thx
01:57:50 <ski> @list where
01:57:51 <lambdabot> where provides: where url what where+
01:58:48 <mjga> @where+ RTS-xc  ghc --make -prof -auto-all -rtsopts -osuf .p_o foo.hs && ./foo +RTS -xc
01:58:48 <lambdabot> I will remember.
01:59:00 <mjga> @where RTS-xc
01:59:00 <lambdabot> ghc --make -prof -auto-all -rtsopts -osuf .p_o foo.hs && ./foo +RTS -xc
02:00:37 <ski> "Continuation-Based Partial Evaluation" by Julia L. Lawall,Olivier Danvy in 1995-02 at <ftp://ftp.daimi.au.dk/pub/empl/danvy/Papers/lawall-danvy-lfp94-extended.ps.gz>
02:00:57 <ski> wavewave : might be interesting re partial evaluation, types, futamura
02:04:05 <Taneb> My Langton's Ant program is going well
02:07:58 <khanzor> anyone had any luck with lambdabot / hoogle on osx? it looks like someone's home path env variable has somehow been captured
02:08:47 <khanzor> http://hpaste.org/57395
02:13:43 * hackagebot Octree 0.2.0.1 - Simple unbalanced Octree for storing data about 3D points  http://hackage.haskell.org/package/Octree-0.2.0.1 (MichalGajda)
02:14:34 <m3ga> hmm, maybe i tried to upgrade to 7.4.1 a little early.
02:14:44 <mekeor> m3ga: me, too
02:14:46 <NapHtaKeRoSene> hello
02:14:50 <mekeor> hello, NapHtaKeRoSene
02:14:58 <NapHtaKeRoSene> i'm deleting haskell right now
02:15:11 <nicoo> NapHtaKeRoSene: Why ?
02:15:29 <NapHtaKeRoSene> because i haven't found any actual use in 2 month
02:15:37 <NapHtaKeRoSene> also, it's slow, and huge
02:15:42 <khanzor> loltroll
02:15:52 <m3ga> so why are you coming here to tell us?
02:16:01 <NapHtaKeRoSene> ghc]# du -sh
02:16:01 <NapHtaKeRoSene> 1.7G	.
02:16:04 <mjga> m3ga: what did you have a problem with?
02:16:20 <NapHtaKeRoSene> # ./hello
02:16:21 <NapHtaKeRoSene> Hello World
02:16:27 <NapHtaKeRoSene> -rwxr-xr-x. 1 root root 970985 Feb  4 12:03 ./hello
02:16:45 <m3ga> deepseq won't cabal-install because some Safehaskell thing
02:17:02 <m3ga> NapHtaKeRoSene: go away. we don't care.
02:17:35 <mjga> NapHtaKeRoSene: -O2 -fllvm?
02:17:52 <m3ga> Control/DeepSeq.hs:56:1: array-0.3.0.3:Data.Array can't be safely imported! The module itself isn't safe.
02:17:58 <mjga> NapHtaKeRoSene: -rtsopts=none && strip <executable>?
02:18:29 <NapHtaKeRoSene> mjard<< i don't know what are those
02:19:07 <jamy23> NapHtaKeRoSene: you need to go deeper
02:19:19 <mjga> m3ga: strange, i have a working deepseq, because my pkgs depend on it. I had to fix some version deps though, and have just sent patches to maintainers. which version of deepseq?
02:19:57 <m3ga> 1.3.0.0
02:20:03 <NapHtaKeRoSene> jamy23<< i have gone as deep as i can go, in C
02:20:56 <m3ga> C is a very fine language for a bunch of programming problems. its also completely horrible for others.
02:20:59 <NapHtaKeRoSene> in 60kB i get a graphic animation with 12 effects, mouse handling, fps meter, timing statistics
02:22:03 <m3ga> NapHtaKeRoSene: how big are the libraries you are linking your 60k program to?
02:22:16 <NapHtaKeRoSene> SDL, math.h
02:22:23 <ChristianS> NapHtaKeRoSene: ghc statically links most libraries, hence binaries are big (though they can be shrunk somewhat, as mjga pointed out)
02:22:32 <m3ga> SDL is rather large
02:22:42 <NapHtaKeRoSene> oh i also use #include <stdio.h>
02:22:43 <ChristianS> haskell is also extremely fast, if you do it right, but it can be hard to get there
02:22:49 <drdo> What's the incantation to get ghc to show me the expanded code? (Template Haskell)
02:23:45 <NapHtaKeRoSene> m3ga<< actually i only use SDL's virtual framebuffer and mode setting and rasterize manually
02:24:12 <NapHtaKeRoSene> fps is >60.
02:24:29 <m3ga> NapHtaKeRoSene: so how big would your program be if you had to include the SDL stuff in your program?
02:24:52 <NapHtaKeRoSene> assuming less than 800MB
02:25:06 <NapHtaKeRoSene> (that is GHC's installed size)
02:25:41 <ChristianS> ? you don't need ghc to run programs, just to compile them
02:25:49 <m3ga> NapHtaKeRoSene: you're talking about the compiler now?
02:26:06 <khanzor> that seems a rather strange observation, do you include your c compiler in your size estimation?
02:26:16 <NapHtaKeRoSene> no, i just saw my hello world code compile to 1MB
02:26:21 <NapHtaKeRoSene> and the huge libraries
02:26:34 <m3ga> NapHtaKeRoSene: why don't you write code that runs directly on the hardware?
02:26:43 <jamy23> NapHtaKeRoSene: C moving to functional programming on each years more and more. So you whatever need study functional way
02:26:46 <NapHtaKeRoSene> m3ga<< i'd like to
02:27:03 <m3ga> NapHtaKeRoSene: then you're in the wrong channel :-)
02:27:57 <mjga> it seems that it should come with the compiler: ghc-pkg-7.4.1 list -> /home/m/apps/ghc-7.4.1/lib/ghc-7.4.1/package.conf.d:  deepseq-1.3.0.0; with which package you had the problem again?
02:28:05 <NapHtaKeRoSene> my expectations from ghc would be to compile optimized code to logic gates. and program an fpga with it
02:28:12 <drdo> What's this? Trolling Saturday?
02:28:23 <NapHtaKeRoSene> drdo<< yeah
02:28:33 <m3ga> NapHtaKeRoSene: youre a troll.  i'm done with you.
02:28:52 <NapHtaKeRoSene> m3ga<< i'm lagughing on this, but no i'm not
02:28:53 <NapHtaKeRoSene> ;>>
02:30:16 <NapHtaKeRoSene> i do functional math in C manually
02:30:30 <NapHtaKeRoSene> ;< so you trying to stop me deleting my ghc?
02:30:49 <NapHtaKeRoSene> i really don't see any real-world use of it.
02:30:55 <jamy23> yes! Delete gcc!
02:31:04 <drdo> NapHtaKeRoSene: Please pick some other place for your trolling endeavours
02:32:22 <NapHtaKeRoSene> jamy23<< but gcc is the standard linux compiler, and i compile 99% of the softwares using it, including my own codes
02:32:28 <mjga> NapHtaKeRoSene: I would greatly recommend you to build GCC and Glibc from the scratch, and come back when you finish
02:33:19 <NapHtaKeRoSene> mjard<< i wrote >10000 lines of long C code last 2 month, no joke ;/
02:33:46 <NapHtaKeRoSene> mjga
02:33:52 <NapHtaKeRoSene> ah this name confusion
02:34:42 <mjard> :|
02:34:47 <NapHtaKeRoSene> i like logics anyway.
02:35:24 <NapHtaKeRoSene> #define __valueisinrange__( v, r1, r2 ) ( \
02:35:24 <NapHtaKeRoSene>       ( ( (r1) <=  (r2) ) && ( (r1) <= (v) ) && ( (v) <= (r2) ) ) || \
02:35:24 <NapHtaKeRoSene>       ( ( (r2) <=  (r1) ) && ( (r2) <= (v) ) && ( (v) <= (r1) ) ) \
02:35:24 <NapHtaKeRoSene> )
02:35:29 <NapHtaKeRoSene> i do this because .
02:35:40 <mjard> if you delete ghc, would you leave?
02:36:00 <NapHtaKeRoSene> mjard<< no, but i don't join
02:36:24 <khanzor> what's the function in glibc to delete the user?
02:36:30 <mjard> you've been inhaling too many fumes
02:36:56 <jamy23> NapHtaKeRoSene: its been joke! :) If you want to do it - do it! And does not distract from the work of others yours whining
02:37:38 <Taneb> http://hpaste.org/57396
02:37:58 <khanzor> NapHtaKeRoSene, also, your macro has a bug, it will bail if your ranges are out
02:38:13 <Taneb> ^^^langton's ant
02:38:20 <Taneb> With an ANSI display
02:38:44 * hackagebot OpenAFP-Utils 1.3.1.1 - Assorted utilities to work with AFP data streams  http://hackage.haskell.org/package/OpenAFP-Utils-1.3.1.1 (AudreyTang)
02:38:46 * hackagebot mix-arrows 1.1 - Mixing effects of one arrow into another one  http://hackage.haskell.org/package/mix-arrows-1.1 (MiguelMitrofanov)
02:39:35 <NapHtaKeRoSene> khanzor<< it only returns a boolean value is in range or not.
02:40:11 <NapHtaKeRoSene> #define __clampvaluerange__( x, r1, r2 ) ( \
02:40:11 <NapHtaKeRoSene>         valueisinrange( (x), (r1), (r2) ) ? (x) : ( \
02:40:11 <NapHtaKeRoSene>             ( ( (r1) < (r2) ) && ( (x) < (r1) ) ) ? (r1) : (r2) \
02:40:11 <NapHtaKeRoSene>         ) \
02:40:11 <NapHtaKeRoSene> )
02:40:15 <NapHtaKeRoSene> you probably meant this
02:41:06 <Phlogistique> NapHtaKeRoSene: would you happen to know about inline functions?
02:41:13 <Phlogistique> they are a very nice feature of C!
02:41:39 <Taneb> :t \v r1 r2 -> (v <= max r1 r2) && (v >= min r1 r2)
02:41:39 <NapHtaKeRoSene> Phlogistique<< this is more inline than an inline function. and these are typeless
02:41:40 <lambdabot> forall a. (Ord a) => a -> a -> a -> Bool
02:42:35 <Phlogistique> @pl \v r1 r2 -> (v <= max r1 r2) && (v >= min r1 r2)
02:42:35 <lambdabot> ap (ap . (liftM2 (&&) .) . (. max) . (.) . (<=)) ((. min) . (.) . (>=))
02:42:37 <khanzor> why would you want typeless
02:42:55 <Phlogistique> khanzor: to apply his macro to different types of arguments
02:43:10 <Phlogistique> well he wants "duck typing" in this case
02:43:12 <khanzor> isn't that what taneb's does as well
02:43:17 <NapHtaKeRoSene> here is how you fix a macro input:
02:43:18 <NapHtaKeRoSene> /  eval any std type using input size
02:43:18 <NapHtaKeRoSene> #define eval_( anyuinttype ) ( { __typeof__ (x)   y = (x); y; } )
02:43:50 <Taneb> khanzor, I have no idea, I don't speak C
02:44:08 <Phlogistique> NapHtaKeRoSene: or you use inline functions!
02:44:13 <NapHtaKeRoSene> i mean
02:44:14 <NapHtaKeRoSene> #define eval_( anyuinttype ) ( { __typeof__ (anyuinttype)   y = (anyuinttype); y; } )
02:44:29 <khanzor> well
02:44:57 <NapHtaKeRoSene> no i won't make a logic function for every combination of input variable types thanks
02:44:59 <khanzor> sorry, by the use of the existential quantification on a in forall a. (Ord a) => a -> a -> a -> Bool, you can apply that anywhere
02:45:25 <aristid> khanzor: i don't see any existential quantification there
02:45:30 <JoshTriplett> With the new Constraint support in GHC 7.4.1, does any mechanism exist to write implementations conditional on constraints?  For example, "if I have this constraint, use this implementation, otherwise use that implementation"?
02:45:41 <khanzor> aristid, isn't that the forall part?
02:46:04 <aristid> khanzor: that would be the opposite of existential quantification:) i forgot the name :/
02:46:21 <JoshTriplett> And closely related to that: can I write a typeclass which provides a default implementation of some of its methods but only for instances of some other typeclass?
02:46:48 <NapHtaKeRoSene> Phlogistique<< i am concerned about the "smart" uninlining feature, that adds additional unnecessary memory moves
02:46:49 <Phlogistique> NapHtaKeRoSene: Oh! sounds like you need a dynamically typed language then.
02:46:50 <aristid> JoshTriplett: no
02:47:00 <JoshTriplett> aristid: No to which?
02:47:20 <aristid> JoshTriplett: the second question. at least... i don't know about GHC 7.4
02:47:28 <Phlogistique> aristid: wait
02:47:28 <JoshTriplett> NapHtaKeRoSene: What problem did you want to solve?
02:47:34 <Phlogistique> maybe I misunderstood
02:47:34 <aristid> JoshTriplett: but i don't think they added that :)
02:47:42 <JoshTriplett> aristid: OK.  Thanks.
02:48:02 <Phlogistique> but I think instance (Typeclass2 a) => Typeclass a where
02:48:08 <Phlogistique> is what JoshTriplett was asking for
02:48:13 <NapHtaKeRoSene> JoshTriplett<< rasterizing vectorgraphic primitives, determine if rectangle is in rectangle using logics....
02:48:14 <Phlogistique> or I misunderstood the question
02:49:04 <JoshTriplett> Phlogistique: Nope.  I don't want to require the typeclass; for the first question I just want to provide a different implementation *if* you have a typeclass, and for the second I want a typeclass that provides default implementations *if* you have another typeclass but doesn't require that typeclass if you implement the methods yourself.
02:51:14 <Taneb> Did anyone look at my Langton's Ant program?
02:52:00 <jamy23> Taneb: What do you say?
02:52:07 <Taneb> http://hpaste.org/57396
02:52:46 <aristid> Phlogistique: that is then the only instance
02:53:06 <aristid> Phlogistique: because constraints are checked after instance selection
02:53:20 <Phlogistique> OK
02:53:21 <jamy23> Taneb: and what we need to do?
02:53:32 <Taneb> Look at it
02:53:34 <Taneb> Admire it
02:53:41 <Taneb> Criticize it
02:53:52 <Taneb> Acknowledge it
02:54:18 <jamy23> Taneb: what of usable it?
02:54:54 <Taneb> It displays successive iterations of Langton's Ant in an ANSI text format when the return button is pressed
02:55:42 <jamy23> it use GUI? :O
02:56:00 <Taneb> Just ANSI
02:56:09 <Taneb> Coloury text
02:56:36 <jamy23> sorry! return button on keyboard :) course!
02:59:21 <jamy23> Taneb: 57:9: Error: Eta reduce <- WHAT THIS???
02:59:49 <Taneb> f x = blah x rather than f = blah
02:59:59 <Taneb> Still works fine
03:04:21 <khanzor> is there a way to have ghci reload packages while it's running?
03:05:49 <jamy23> Taneb: Works fine, but algorithm doesn't thoroughly. You know what haskell can be solved in different ways?
03:10:48 <Taneb> jamy23, I'm afraid I can't work out what you're saying
03:11:44 <Taneb> Could you rephrase it?
03:12:45 <jamy23> just stick to his advice
03:17:11 <khanzor> Taneb: it might just be nitpicking, but toThing' could benefit from a call to maybe
03:17:28 <khanzor> Taneb: maybe (char ' ') (red . char . dir2char) md
03:17:32 <Taneb> Yeah
03:17:44 <Taneb> Also, my function-naming skills are lacking
03:17:45 <khanzor> it's probably an issue of style though
03:17:54 <jamy23> Taneb: http://stackoverflow.com/questions/5793843/what-does-eta-reduce-mean-in-the-context-of-hlint
03:24:45 <khanzor> Taneb: it might just be me (I just installed that pprint library), but on osx i don't get a clean screen each tick
03:25:09 <ChristianS> silly question: i can do this: do
03:25:09 <ChristianS>     isFile <- doesFileExist x
03:25:09 <ChristianS>     if isFile then ... else ...
03:25:10 <khanzor> Taneb: is this the way it's supposed to work, or am i just a second class citizen?
03:25:33 <ChristianS> but how to express the same thing without the bool helper variable? if ??? then ... else ... ?
03:26:10 <khanzor> :t when
03:26:10 <Eduard_Munteanu> ChristianS: you can always desugar do notation
03:26:11 <lambdabot> forall (m :: * -> *). (Monad m) => Bool -> m () -> m ()
03:26:30 <khanzor> ChristianS: that should work, right?
03:26:48 <Eduard_Munteanu> Or yeah, that's better advice if you can use it.
03:26:49 <khanzor> ChristianS: ahh, sorry, no, it won't
03:27:12 <Taneb> khanzor, it's how it works for me as well, because I'm not very good
03:29:07 <jamy23> Taneb: you are almost very good!
03:30:54 <ChristianS> Eduard_Munteanu: but when i desugar i never still need a lambda variable instead of the isFile, right? that wouldn't help much
03:31:17 <ChristianS> guess i'll just leave the code as is...
03:35:23 <Eduard_Munteanu> ChristianS: yeah. You could write a helper a-la Maybe to dispatch based on the Bool value, I don't think there's a standard one. But if you have a choice perhaps you should write that in the Maybe or Either monad so you can just fallthrough errors (e.g. when the file you're opening doesn't exist).
03:35:36 <Eduard_Munteanu> s/a-la Maybe/a-la maybe/
03:35:37 <Eduard_Munteanu> :t maybe
03:35:38 <lambdabot> forall b a. b -> (a -> b) -> Maybe a -> b
03:36:35 <jamy23> Еhere was an interesting question. To which the answer was no. Let him answer! Why Haskell is not performed directly on the hardware?
03:37:47 <Eduard_Munteanu> jamy23: what do you mean directly on the hardware exactly?
03:38:03 <jamy23> yes
03:39:03 <Eduard_Munteanu> Yes what?
03:39:47 <jamy23> Why Haskell is not working directly on the hardware?
03:40:21 <Flonk> Is there a function that splits a string into chunks?
03:42:09 <khanzor> Flonk: there are several :), what are your requirements?
03:43:04 <Flonk> khanzor: Simply taking a [Char] and splitting it into [Chars] of length 10 (or any variable length really)
03:43:13 <Flonk> *[Char]'s
03:46:03 <jamy23> Ok! Next question someone know how evaluate lambda expression directly on hardware?
03:47:08 <jamy23> or this room is not for such issues?
03:48:12 <Taneb> I heard of something like that once
03:48:21 <Taneb> I can't remember where, though
03:48:21 <khanzor> Flonk: I think you need to implement that using Data.List.splitAt (from memory)
03:48:54 <Flonk> khanzor: oh, okay, I'll check that then
03:48:56 <Flonk> Thanks a bunch!
03:52:34 <Flonk> oor I could implement it myself
03:52:40 <Flonk> sounds like a good practice
03:53:01 <Flonk> Weird though that Haskell has all these awesome functions in the standard library but nothing for splitting strings :D
03:53:23 <khanzor> Flonk: well, it has plenty for splitting strings
03:53:38 <khanzor> just nothing for breaking lists into sublists based on number
03:53:41 <dobblego> it's not weird, it's well documented as difficult
03:53:55 <dobblego> see Data.List.Split as documentation of that difficulty
03:56:54 <byorgey> jamy23: http://www.cs.york.ac.uk/fp/reduceron/
03:57:51 <byorgey> Data.List.Split also has a function for splitting a list into chunks of a given length.
03:57:53 <jamy23> byorgey: Thanks! Not heard :)
03:58:19 <Philippa> I think reduceron originally worked on SKI + some of the other regular combinators?
03:58:38 <byorgey> maybe, I'm not exactly sure
03:59:22 * Philippa wonders if you can build interesting hardware GC based around spatial partition strees
04:00:34 <Philippa> it's rare to see hardware that actually beta reduces, anyway
04:01:49 <opqdonut> I'd rather see combinator calculus in hw and abstraction elimination in microcode :)
04:01:49 <Philippa> (re the GC thing, I guess that means NUMA GC)
04:09:35 <jamy23> in couple words < why need Reduceron? What he can?
04:12:40 <rostayob> wow this reduceron stuff is cool
04:12:53 <rostayob> I thought they gave up in making functional hardware
04:19:58 <jamy23> One people of this room, in private chat, tell me about Haskell environment running on XEN. Read more this http://halvm.org/wiki/
04:22:37 <mreh> i get a syntax error trying to install the last two releases of the zlib package
04:23:00 <mreh> i've worked around it though
04:23:44 <hpc> jamy23: why in private chat?
04:25:13 <jamy23> hpc: i dont know
04:26:37 <mreh> where does cabal-dev put my executables>
04:26:52 <donri> $PWD/cabal-dev/bin
04:27:19 <jamy23> maybe he hidden what he know many in order to avoid being harassed
04:27:32 <mreh> donri: that's what I was hoping, must not have installed any
04:28:41 <mreh> yeah, my mistake
04:53:37 <argiopeweb> Has anyone had any experience with HDBC's withRTSSignalsBlocked doing screwy things with the RTS (e.g. causing it to miss sigPIPEs and crash)?
04:59:27 <auastro> hi all
04:59:48 <auastro> quick question, how does one "groupBy" globally in a list
05:00:05 <Clint> globally?
05:00:25 <auastro> as in groupAll = map (\x -> (sort x, x)) >>> sortWith fst >>> groupWith fst >>> (map . map) snd
05:01:05 <auastro> sorry* groupAll op = map (\x -> (op x, x)) >>> sortWith fst >>> groupWith fst >>> (map . map) snd
05:01:44 <auastro> like a multiway partition
05:05:26 <auastro> @Clint any ideas? it seems like something that would be int he standard library
05:05:26 <lambdabot> No module "any ideas? it seems like something that would be int he standard library" loaded
05:30:51 <bytbox> I'm having a terrible time setting up tests with cabal 1.10.1.0 - I'm using exitcode-stdio-1.0, following the documentation example exactly. The test always fails (I don't think it's even compiling) and I can't get any meaningful debug output: http://hastebin.com/vedudidudo.rb
05:32:10 <bytbox> ideas?
05:33:43 <Saizan> the log doesn't say anything?
05:34:54 <bytbox> Saizan: that's correct
05:35:07 <donri> did you look in dist/test/contextual-0.1-test-qc.log
05:35:33 <bytbox> http://hastebin.com/necahixuge.rb
05:35:39 <bytbox> yes, I looked at both logs
05:35:42 <bytbox> haste'd above
05:35:46 <bytbox> neither has any useful information
05:35:55 <donri> that's not the file i mentioned
05:36:04 <bytbox> donri: read the paste - there are two files printed
05:37:09 <donri> i can't see that because hastebin sucks
05:37:13 <donri> @hpaste
05:37:14 <lambdabot> Haskell pastebin: http://hpaste.org/
05:38:25 <bytbox> eh, ok, won't argue this now: http://hpaste.org/57399
05:38:51 <bytbox> the strange thing (I now discover) is that if I remove file reference by main-is, I get exactly the same sort of output
05:39:17 <_Mikey> can I write if then else in my do blocks?
05:39:27 <donri> _Mikey: yes
05:39:32 <donri> bytbox: it does seem weird
05:39:42 <_Mikey> cool! donri
05:39:54 <donri> bytbox: some log should contain "This test always fails!"
05:40:02 <donri> if you used the examples from the user guide
05:40:19 <bytbox> donri: I modified it to be exitSuccess, actually
05:40:31 <donri> bytbox: might need to cabal build?
05:40:33 <donri> duno
05:40:34 <bytbox> donri: also, things are running too fast for there to be compilation
05:40:46 <bytbox> so I'm pretty sure it's not even looking at the file
05:41:00 <bytbox> my .cabal file: http://hpaste.org/57400
05:41:12 <bytbox> am I doing anything gratuitously dumb?
05:42:14 <Flonk> What do I need to do to get a line feed in Haskell (when using print)? '\n' is not it
05:42:29 <opqdonut> you can't get one when using print
05:42:37 <opqdonut> but it is \n when you use putString
05:42:44 <opqdonut> @src print
05:42:44 <lambdabot> print x = putStrLn (show x)
05:42:54 <bytbox> oh...
05:43:01 <Flonk> Oh, I see!
05:43:01 <bytbox> donri: yup. Needed 'cabal build'
05:43:06 <bytbox> thanks
05:43:10 * bytbox feels stupid
05:43:13 <donri> :)
05:43:41 <bytbox> (honestly, I think cabal could give a slightly better error message - or build automatically)
05:49:02 <rwbarton> @src putStrLn
05:49:03 <lambdabot> putStrLn s =  do putStr s; putChar '\n'
05:54:38 <prof7bit> @src putChar
05:54:38 <lambdabot> putChar c = hPutChar stdout c
05:54:54 <prof7bit> @src hPutChar
05:54:54 <lambdabot> Source not found. I've seen penguins that can type better than that.
06:02:32 <kbrad> Enter text here...
06:02:45 <kbrad> can anyone help me with programming in Basal?
06:03:09 <irene-knapp1> Probably, but not here.  Is there a channel relating to Basal?  This channel is for Haskell.
06:03:47 <ion> The word Haskell looks very similar to Basal, one can understand the confusion.
06:03:53 <irene-knapp> indeed
06:05:26 <rata_> hahahaha
06:07:21 <Flonk> Does Haskell automatically typecast from Int to Float when needed?
06:07:26 <opqdonut> no
06:07:33 <opqdonut> :t fromIntegral
06:07:34 <ion> No, but number literals are polymorphic.
06:07:34 <lambdabot> forall a b. (Integral a, Num b) => a -> b
06:07:41 <opqdonut> :t 3
06:07:42 <lambdabot> forall t. (Num t) => t
06:08:32 <Flonk> That explains a few things
06:09:21 <kbrad> idk anything about computers or programming, and Basal does not come up in google as a computer program. i thought hakell was just a name...lol
06:09:58 <kbrad> C++ comes up, but basal guves me reading stuff, and insulin result??
06:10:19 <ion> Good try, very amusing.
06:11:09 <Saizan> http://android-dev.org/cross-platform-development-in-basal-android-development/ <- ?
06:16:21 <Blkt> good day everyone
06:17:34 <otters> you too
06:17:58 <rpglover64> How might one prove that one can't have a function of a particular type? e.g. (Monad m) => m a -> a
06:18:56 * hackagebot bindings-gpgme 0.1.2 - Low level bindings to gpgme.  http://hackage.haskell.org/package/bindings-gpgme-0.1.2 (MauricioAntunes)
06:19:16 <rpglover64> The paticular function I'm looking for is (Monad m) -> ((a -> a -> Ordering) -> [a] -> [a]) -> (a -> a -> m Ordering) -> [a] -> m [a]
06:19:19 <ion> rpglover64: You could look at the Monad typeclass and see that the interface doesn’t provide a way to do that.
06:19:37 <rpglover64> ion: That's not a proof, though.
06:20:01 <ion> Sorry. Let me fix that.
06:20:05 <ion> rpglover64: You could look at the Monad typeclass and see that the interface doesn’t provide a way to do that. QED.
06:20:26 <rpglover64> *facepalm*
06:21:21 <rpglover64> Just because the monad typeclass doesn't provide an extract operation doesn't mean that between bind and return, you can't create one.
06:21:31 <ion> (I was joking.)
06:21:37 <rpglover64> You'd probably have to resort to category theory.
06:21:42 <rpglover64> (I realized.)
06:22:44 <rpglover64> So, really my question is: how can I convert a sortBy function to a sortByM function or demostrate it impossible?
06:23:32 <dschoepe> rpglover64: What should be monadic? The comparison function?
06:23:43 <rpglover64> and the output, necessarily
06:24:06 <rpglover64> sortByM :: (Monad m) => (a -> a -> m Ordering) -> [a] -> m [a]
06:25:44 <gwern> > (10 / 4.22)
06:25:45 <lambdabot>   2.3696682464454977
06:25:53 <otters> > return 1
06:25:54 <lambdabot>   No instance for (GHC.Show.Show (m t))
06:25:54 <lambdabot>    arising from a use of `M6531462750...
06:25:59 <gwern> > (10 / (4.22 * 5.92))
06:26:00 <lambdabot>   0.4002817983860638
06:26:06 <irene-knapp> rpglover64, you can't do it in a generic way, because doing it monadically implies there is some sequence to the invocations of the comparator
06:26:08 <otters> :t return 1
06:26:09 <lambdabot> forall t (m :: * -> *). (Num t, Monad m) => m t
06:26:15 <irene-knapp> rpglover64, you can do it easily for the specific case of sortByM though
06:26:55 <rpglover64> irene-knapp: you mean rewrite sortBy with monads in mind?
06:26:55 <irene-knapp> no, I take that back, you have to implement quicksort or another algorithm yourself
06:27:00 <irene-knapp> yes, indeed
06:27:07 <rpglover64> That's what I feared.
06:27:08 <irene-knapp> fortunately, quicksort is easy to express in Haskell!
06:27:13 <irene-knapp> @src sortBy
06:27:13 <lambdabot> sortBy cmp = foldr (insertBy cmp) []
06:27:19 <irene-knapp> @src insertBy
06:27:19 <lambdabot> insertBy _   x [] = [x]
06:27:20 <lambdabot> insertBy cmp x ys@(y:ys') = case cmp x y of
06:27:20 <lambdabot>                                  GT -> y : insertBy cmp x ys'
06:27:20 <lambdabot>                                  _  -> x : ys
06:27:24 <irene-knapp> there's the meat of it
06:27:33 <magicman> That's... insertion sort?
06:27:36 <irene-knapp> the definition there is actually an insertion sort, yes
06:27:58 <dschoepe> Yeah, the usual quicksort definition is not very efficient, iirc.
06:28:02 <irene-knapp> it's non-obvious what algorithm performs best with immutable values though
06:28:05 <irene-knapp> @hoogle sort haskell
06:28:06 <lambdabot> No results found
06:28:10 <irene-knapp> @google sort algorithm haskell
06:28:12 <lambdabot> http://en.wikibooks.org/wiki/Haskell/Algorithm_complexity
06:28:17 <irene-knapp> @google sort haskell
06:28:19 <lambdabot> http://www.haskell.org/hoogle/?hoogle=sort
06:28:19 <lambdabot> Title: sort - Hoogle
06:28:23 <irene-knapp> @google sort algorithm immutable
06:28:24 <lambdabot> http://lindstroem.wordpress.com/2009/02/19/using-mutable-arrays-for-faster-sorting/
06:28:24 <lambdabot> Title: Using Mutable Arrays for Faster Sorting « Haskellville
06:28:28 <irene-knapp> there we go
06:29:04 <rpglover64> Fortunately, this package exists: http://hackage.haskell.org/packages/archive/monadlist/0.0.2/doc/html/Control-Monad-ListM.html
06:29:04 <rpglover64> so I don't have to do it myself
06:29:08 <irene-knapp> well, actually, you don't want mutable arrays
06:29:09 <irene-knapp> ah, excellent
06:29:14 <irene-knapp> I thought you wanted to do it as an exercise
06:29:28 <irene-knapp> it doesn't strike me as difficult or tedious and I think it would be a good learning experience, so perhaps you should
06:29:31 <btvl> is there a way to have cabal working with ghc-4.2.1 ? Been at it for an hour now
06:29:37 * dschoepe wonders how an impossibility proof of constructing sortByM from sortBy would look like -- maybe assuming f ∘ sortBy (g ∘ cmp ∘ h) ∘ k = sortByM cmp and then deriving a contradiction
06:29:38 <rpglover64> well, I wanted to do it as an exercise if it didn't involve rewriting the sort function
06:29:38 <btvl> erm
06:29:39 <btvl> 7.2.1
06:29:49 <btvl> 7.4.1
06:30:00 <irene-knapp> btvl: nobody has done that work yet.
06:30:04 <btvl> AH
06:30:07 <rpglover64> dschoepe: interesting
06:30:08 <irene-knapp> btvl: it's not really difficult if you know what you're doing, but.
06:30:20 * Flonk finished his first program http://hpaste.org/57402
06:30:24 <Flonk> I feel accomplished.
06:30:32 <irene-knapp> Flonk: Cool, Mandelbrot! :D
06:30:34 <btvl> well I installed all prerequisites, will try to comment all those version requirements and hope for the best
06:30:45 <irene-knapp> sounds good!  let people know if you get it working
06:31:05 <ion> btvl: Yeah, it took a bit of poking it with a stick to get it installed. I found the version of cabal-install under the Cabal darcs repository easier to get installed than the one in the cabal-install repository.
06:31:10 <Flonk> irene-knapp: took me hours >_>
06:31:13 <irene-knapp> aw ><
06:31:32 <btvl> ion, that's what I figured. I'm not sure how to get it, I did wget -np -r ...
06:31:38 <irene-knapp> yes, um, the Cabal darcs repo is the primary (latest)
06:31:40 <opqdonut> Flonk: implode is also known as intercalate
06:31:43 <irene-knapp> the cabal-install repo is legacy
06:31:44 <opqdonut> :t interacalate
06:31:45 <lambdabot> Not in scope: `interacalate'
06:31:50 <opqdonut> :t intercalate
06:31:50 <irene-knapp> they were merged back together after a couple years forked
06:31:51 <lambdabot> forall a. [a] -> [[a]] -> [a]
06:32:12 <opqdonut> > intercalate 1 ["Hello","World","!",""]
06:32:13 <dschoepe> rpglover64: I think can't work though, since you could take probably alter the argument function to sortBy in a way to put the comparison function in the result and take f to be sortByM that extracts cmp from the result of sortBy.
06:32:13 <lambdabot>   No instance for (GHC.Num.Num [GHC.Types.Char])
06:32:14 <lambdabot>    arising from the literal ...
06:32:21 <opqdonut> > intercalate "1" ["Hello","World","!",""]
06:32:21 <lambdabot>   "Hello1World1!1"
06:32:31 <Flonk> :D Well that would have been good to know
06:33:00 <Flonk> But that was the 'easy' part anyway so it's not too bad
06:33:04 <btvl> is it possible to get a tarball of what's in the darcs repo ?
06:33:25 <jamy23> https://plus.google.com/105523658172538902193/posts
06:33:42 <ion> btvl: http://hpaste.org/57403
06:33:56 * hackagebot HiggsSet 0.1.1 - A multi-index set with advanced query capabilites  http://hackage.haskell.org/package/HiggsSet-0.1.1 (LarsPetersen)
06:34:13 <btvl> I already installed Cabal with my bare hands
06:34:20 <btvl> I'm not sure I will want to run this script now
06:34:30 <ion> btvl: And i needed to run EXTRA_CONFIGURE_OPTS="--flags=-bytestring-in-base --flags=-old-base" sh bootstrap.sh for some reason.
06:34:39 <btvl> yes
06:34:47 <btvl> I noticed those
06:35:00 <btvl> my main problem is getting the source now ;)
06:35:04 <btvl> well, for now
06:35:16 <opqdonut> Flonk: I made this at some point: http://hpaste.org/57405
06:36:06 <Flonk> opqdonut: neat!
06:36:28 <ion> btvl:
06:36:31 <ion> whoops
06:36:34 <ion> darcs get --lazy http://darcs.haskell.org/cabal-branches/cabal-1.14/
06:38:04 <btvl> i don't have darcs
06:38:51 <btvl> oh perhaps i do
06:38:59 <dschoepe> btvl: It's packaged for most distros.
06:39:10 <dschoepe> And if not, you can install it via cabal.
06:39:29 * btvl facepalms
06:39:37 <btvl> I thought it would pull the distro's ghc
06:39:39 <dschoepe> Oh, maybe I should have read the context.
06:39:43 <btvl> and I'm trying to install cabal ;)
06:39:51 <mysticc> I have a::Integer and b::Int .. How can I do a*b ?
06:40:20 <opqdonut> use fromIntegral
06:41:06 <mysticc> opqdonut: Should I convert Int to Integer using toInteger ?
06:41:25 <Taneb>  a * (fromIntegral b)
06:41:33 <mauke> a * fromIntegral b
06:41:41 <opqdonut> or: fromIntegral a * b
06:41:42 <parcs`> @src fromIntegral
06:41:42 <lambdabot> fromIntegral = fromInteger . toInteger
06:42:01 <dschoepe> btvl: Another idea would be to download all the files in the repo recursively with curl, using the web-interface at the same address.
06:42:09 <dschoepe> (or wget)
06:42:10 <mysticc> thanks . a*(toInteger b) also works ..
06:42:24 <btvl> dschoepe, started this, but it was taking forever
06:42:46 <dschoepe> Did you try excluding the _darcs directory?
06:43:19 <cgroza> What do I need to do to set up an IconView in gtk2hs? I have been googling for an hour now and I can't get anything precise.
06:44:30 <mysticc> Anybody has used mmap here ?? I have to read and write fixed size blocks on a file .. where file size is very large .. will it be useful to use mmap or should I use System.IO and Bytestring??
06:44:33 <btvl> dschoepe, I saw that and just stopped, fearing there would be more of these things I didn't know about
06:44:57 <doug_> Hi, I am having difficult getting this to compile in Leksah though it works in the command line:
06:44:58 <doug_> module Main (
06:44:58 <doug_>     main
06:44:58 <doug_> ) where
06:44:58 <doug_> import Data.List
06:44:58 <doug_> import Numeric
06:45:00 <doug_> import Test.HUnit
06:45:11 <jedai> doug_: use hpaste.org
06:45:40 <doug_> src/Main.hs:22:8:
06:45:41 <doug_>     Could not find module `Test.HUnit':
06:45:41 <doug_>       It is a member of the hidden package `HUnit-1.2.4.2'.
06:45:41 <doug_>       Perhaps you need to add `HUnit' to the build-depends in your .cabal file.
06:45:41 <doug_>       Use -v to see a list of the files searched for.
06:45:46 <dschoepe> btvl: I think that's the only problematic directory and only necessary for using the repo with darcs (obviously).
06:45:52 <jedai> doug_: don't paste it all here (you'll risk auto-kicking)
06:45:56 <btvl> heh
06:46:03 <doug_> k
06:46:39 <jedai> doug_: I don't know why HUnit is hidden... what's your compiler command line ?
06:47:08 <btvl> Setup configure passed, will see what happens now ..
06:47:52 <doug_> for reference here is the past http://hpaste.org/57406.
06:48:16 <mauke> doug_: do you have a .cabal file?
06:48:36 <doug_> it works on the command line with "ghc Main.hs", but not from Leksah.
06:48:38 * dschoepe suspects Leksah creates one automatically as part of a project
06:48:39 <btvl> ion, this hpaste is a huge help, as I'm now facing the compile problems
06:49:02 <jedai> Yes, leksah only works with "project" I think
06:49:28 <doug_> yes, i see a cabal in my project directory.
06:49:45 <dschoepe> doug_: That should have a build-depends line, where you need to add HUnit
06:50:02 <dschoepe> `HUnit == 1.2.*' to be precise
06:50:04 <jedai> You must add HUnit in the dependency of your project (leksah has graphical tool to handle that, don't change the .cabal directly)
06:50:30 <btvl> it works !
06:51:10 <btvl> looks like I will finally be able to get some work done (or face some more problems)
06:51:12 <jedai> doug_: I've not used Leksah for quite a time but it was relatively easy to make change to a project setting with it (I would avoid doing it manually for fear that it would interfere)
06:51:15 <doug_> HUnit is now showing up in the tree of available packages
06:51:26 <doug_> HUnit is NOT showing up in the tree of available packages
06:53:26 <btvl> should I be really afraid of that : text-0.11.1.13 (reinstall) changes: array-0.4.0.0 -> 0.3.0.3
06:53:46 <btvl> it looks pretty dangerous to me ... but I can't see how to get away with it
06:53:52 <Flonk> opqdonut: I kinda see the program flow, but what do those dots do?
06:54:55 <ion> cmccann: Overture doesn’t seem to export bool.
06:54:57 <mysticc> @hoogle String -> ByteString
06:54:57 <doug_> after a cabal install, how do I let leksah know where the package is for HUnit?
06:54:57 <lambdabot> Data.ByteString.Char8 pack :: String -> ByteString
06:54:58 <lambdabot> Data.ByteString.Lazy.Char8 pack :: [Char] -> ByteString
06:54:58 <lambdabot> Data.String fromString :: IsString a => String -> a
06:55:46 <ion> @src (.)  -- these?
06:55:47 <lambdabot> Source not found. BOB says:  You seem to have forgotten your passwd, enter another!
06:55:50 <ion> @src (.)
06:55:50 <lambdabot> (f . g) x = f (g x)
06:55:51 <lambdabot> NB: In lambdabot,  (.) = fmap
06:56:53 <otters> ?
06:57:56 <Flonk> ion: Oh, okay
06:58:07 <Flonk> So composing 2 funtions basically
06:58:12 <ion> Indeed
06:58:21 <alistra> if i want to use a String as an AES key in the crypt library, what's the function to do a transformation String -> Word256 or something :D
06:58:25 <ion> > (f . g . h) x
06:58:26 <lambdabot>   Ambiguous type variable `a' in the constraints:
06:58:27 <lambdabot>    `GHC.Show.Show a'
06:58:27 <lambdabot>      a...
06:58:29 <ion> > (f . g . h) x :: Expr
06:58:30 <lambdabot>   Ambiguous type variable `a' in the constraints:
06:58:30 <lambdabot>    `SimpleReflect.FromExpr ...
06:58:39 <ion> le sigh :-P
06:58:50 <ion> > ((f :: Expr -> Expr) . g . h) x
06:58:51 <lambdabot>   Ambiguous type variable `a' in the constraints:
06:58:51 <lambdabot>    `SimpleReflect.FromExpr ...
06:58:56 <ion> I give up.
06:58:59 <Flonk> :D
06:59:29 <ion> (f . g . h) x = f (g (h x))
07:01:13 <mauke> > let f' = f in (f' . f' . f') x
07:01:14 <lambdabot>   Ambiguous type variable `a' in the constraints:
07:01:14 <lambdabot>    `GHC.Show.Show a'
07:01:15 <lambdabot>      a...
07:01:17 <mauke> aww
07:01:38 <Flonk> Can anyone talk to lambdabot?
07:01:40 <Flonk> @scr (.)
07:01:40 <lambdabot> Maybe you meant: arr rc src
07:01:52 <Flonk> derp
07:01:58 <parcs`> > (f . (g :: Expr -> Expr) . h) (x :: Expr)
07:01:59 <lambdabot>   Ambiguous type variable `b' in the constraints:
07:01:59 <lambdabot>    `GHC.Show.Show b'
07:01:59 <lambdabot>      a...
07:02:19 <mauke> > let f' = f :: Expr->Expr in (f' . f' . f') x
07:02:21 <lambdabot>   f (f (f x))
07:02:30 <mauke> you need to fix all intermediates
07:03:40 <Flonk> @src ($)
07:03:41 <lambdabot> f $ x = f x
07:03:46 <Flonk> lolwut
07:03:53 <parcs`> > iterate (f .) ($ x)
07:03:54 <lambdabot>   Overlapping instances for GHC.Show.Show
07:03:54 <lambdabot>                              ((Simp...
07:04:17 <mauke> yeah, that's a list of functions
07:04:25 <mauke> > iterate f x
07:04:26 <lambdabot>   [x,f x,f (f x),f (f (f x)),f (f (f (f x))),f (f (f (f (f x)))),f (f (f (f (...
07:04:38 <parcs`> > map ($x) (iterate (f .) f)
07:04:39 <lambdabot>   Ambiguous type variable `b' in the constraints:
07:04:39 <lambdabot>    `SimpleReflect.FromExpr ...
07:04:47 <parcs`> i suck
07:05:03 <Flonk> :D
07:05:11 <harlekin> Flonk: f . g $ x == (f . g) x, but f . g x == f . (g x). It just changes the implicit brackets.
07:05:27 <mauke> :t let f' = f in f'
07:05:28 <lambdabot> forall a. (SimpleReflect.FromExpr a) => a
07:05:38 <mauke> :t let f' = f `asTypeOf` id in f'
07:05:39 <lambdabot> forall a. (SimpleReflect.FromExpr a, Show a) => a -> a
07:06:00 <mauke> :t let f' x = head [f x, x] in f'
07:06:01 <lambdabot> forall a. (SimpleReflect.FromExpr a, Show a) => a -> a
07:06:06 <Flonk> harlekin: I see.. Does that have any uses aside from saving a byte?
07:06:21 <parcs`> > map ($x) (iterate (f .) id)
07:06:22 <lambdabot>   [x,f x,f (f x),f (f (f x)),f (f (f (f x))),f (f (f (f (f x)))),f (f (f (f (...
07:06:28 <mauke> Flonk: some people are allergic to parens
07:06:35 <harlekin> Flonk: well, it doesn't save you anything since $ + space is the same as (). ;-) It just looks better sometimes.
07:06:46 <aristid> > id x
07:06:47 <lambdabot>   x
07:07:01 <harlekin> And it's sometimes nice to have function application for things like foldl ($) or something.
07:07:16 <paul___> :)
07:07:52 <jedai> Flonk: Note that $ has the lowest precedence, so you can also use it like "f . g $ a + b" instead of "(f . g) (a + b)"
07:08:14 <parcs`> $ is good for delimiting let, case and do expressions
07:08:22 <mauke> and lambadas
07:08:27 <parcs`> and lambadas
07:08:28 <Flonk> Okay, thats kinda nice
07:08:59 <mauke> shizzle $ \x -> f x <<|> g (h x)
07:09:11 <jedai> Flonk: And then you get into cases where you would have tons of nested parens and with $ you avoid some of them, and it's much cleaner... In other words it avoids the parenthesis overload you get from List or Scheme
07:09:44 <mauke> more specifically, $ simplifies tail nesting
07:10:20 <jedai> Flonk: thing is the fp style tends to make it easier and more reasonable to have deeply nested expression, so anything that makes them clearer is good for your sanity
07:10:23 <mauke> by "tail nesting" I mean when something is nested within another thing. at the end.
07:10:53 <mauke> ((a b) (c d)) <- here (c d) is in the tail position of the outer ( )
07:10:55 <Flonk> mauke: I figured
07:11:09 <mauke> lisp generally doesn't have special support for this, so you end up with )))))))
07:11:23 <mauke> delicious )))))))))))
07:12:03 <int-e> some say the name stands for "Lots of Irritating Superfluous Parentheses"
07:12:17 <mauke> haskell constructs such as lambda or case .. of (with layout) don't have an explicit end marker
07:12:40 <mauke> $ gives you sort of the same thing for nested expressions
07:12:57 <ion> mauke: You do a good impersonation of a Russian person))))))))))))))))))
07:13:08 <mauke> kekekek
07:13:12 <ion> This style of smiley is rampant in there)))))))))))
07:13:33 <mauke> scalable multichin processing
07:15:19 <Flonk> I think I deciphered his code completely now :D
07:21:27 <mysticc> How to find the size of a bytestring ? Give size say 1KB I want to split it into 2 chunks 1st of 1KB second of rest
07:22:14 <mauke> length
07:23:20 <ion> splitAt
07:23:43 <ion> Good that you gave the X in addition to the Y.
07:24:16 <mauke> oh, that was related?
07:24:38 <mauke> I thought the second sentence was a non sequitur
07:26:17 <mysticc> mauke: length of Bytestring is size in Bytes ?
07:26:37 <c_wraith> What else could it be?
07:26:39 <mauke> what else could it be?
07:26:43 <c_wraith> hah
07:27:33 <elliott> in bits!
07:27:37 <elliott> BitString
07:28:54 <c_wraith> > length . LB.toChunks
07:28:55 <lambdabot>   Not in scope: `LB.toChunks'
07:28:56 * hackagebot libnotify 0.0.1.2 - Haskell binding for Libnotify  http://hackage.haskell.org/package/libnotify-0.0.1.2 (MatveyAksenov)
07:29:07 <c_wraith> hmm.  what are the names those are imported under?
07:29:24 <c_wraith> or does \bot just not have bytestrings?
07:29:26 <mauke> :t BS.length
07:29:27 <lambdabot> BSC.ByteString -> Int
07:29:32 <c_wraith> ah
07:29:43 <c_wraith> :t BSL.toChunks
07:29:43 <lambdabot> BSLC.ByteString -> [BSC.ByteString]
07:29:46 <mauke> :t BS.pack
07:29:46 <lambdabot> [Word8] -> BSC.ByteString
07:29:58 <mauke> where's my Char8?
07:30:08 <c_wraith> :t BSC.pack
07:30:08 <Saizan> :t BSC.pack
07:30:09 <lambdabot> String -> BSC.ByteString
07:30:09 <lambdabot> String -> BSC.ByteString
07:30:42 <c_wraith> :t BSCL.pack
07:30:43 <lambdabot> Couldn't find qualified module.
07:30:50 <c_wraith> guess that one's not around
07:30:54 <c_wraith> or, wait
07:30:58 <c_wraith> :t BSLC.pack
07:30:59 <lambdabot> [Char] -> BSLC.ByteString
07:31:02 <c_wraith> ok then
07:33:56 * hackagebot DeepArrow 0.3.4 - Arrows for "deep application"  http://hackage.haskell.org/package/DeepArrow-0.3.4 (ConalElliott)
07:38:57 * hackagebot DeepArrow 0.3.5 - Arrows for "deep application"  http://hackage.haskell.org/package/DeepArrow-0.3.5 (ConalElliott)
07:47:36 <gwern> > length "11001100110011001100"
07:47:36 <lambdabot>   20
07:47:58 <gwern> > 2^20
07:47:59 <lambdabot>   1048576
07:48:46 <idest0> hi everyone, is there a difference between (putStrLn . show) and putStrLn in terms of lazyness ? Thanks in advance
07:49:13 <mauke> > showIntAtBase 36 ((['0'..'9']++['a'..'z']) !!) 1048576 ""
07:49:14 <lambdabot>   "mh34"
07:49:15 <c_wraith> that's really hard to say, since there's a different in types..
07:49:44 <c_wraith> > take 1 $ show (undefined :: String)
07:49:45 <lambdabot>   "\""
07:49:47 <idest0> oh i'm sorry, say the first was called on a string
07:49:50 <mauke> idest0: for strings, I don't think so
07:49:52 <c_wraith> > take 1 $ (undefined :: String)
07:49:53 <lambdabot>   "*Exception: Prelude.undefined
07:50:11 <Taneb> > show "hello"
07:50:12 <lambdabot>   "\"hello\""
07:50:18 <c_wraith> looks different to me
07:50:26 <mauke> > fix show
07:50:27 <lambdabot>   "\"\\\"\\\\\\\"\\\\\\\\\\\\\\\"\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"\\\\\\\\\\\\...
07:50:38 <otters> heh
07:50:44 <otters> > fix (+1)
07:50:48 <lambdabot>   mueval-core: Time limit exceeded
07:51:32 <idest0> ok
07:52:12 <elliott> > fix (In . Identity)
07:52:13 <lambdabot>   No instance for (GHC.Show.Show
07:52:13 <lambdabot>                     (Data.Functor.Identity.I...
07:52:16 <elliott> :(
07:52:17 <elliott> > fix (In . Just)
07:52:19 <lambdabot>   In (Just (In (Just (In (Just (In (Just (In (Just (In (Just (In (Just (In (J...
07:54:09 <otters> > fix (Just)
07:54:09 <mauke> this just in: just in just in just in
07:54:10 <lambdabot>   Occurs check: cannot construct the infinite type:
07:54:10 <lambdabot>    a = Data.Maybe.Maybe a
07:54:16 <otters> this is fun
07:54:36 <mauke> fun?! this. is. LAMBDA!
07:55:01 <ion> > cycle "this just in: "
07:55:02 <lambdabot>   "this just in: this just in: this just in: this just in: this just in: this...
07:55:08 <otters> > fix (-1)
07:55:09 <lambdabot>   -1
07:55:12 <otters> oh
07:55:13 <mauke> hahaha
07:55:16 <int-e> Error: Can't fix Just: Not broken.
07:55:20 <mauke> > fix 2
07:55:20 <otters> dat unary minus
07:55:21 <lambdabot>   2
07:55:45 <int-e> Oh Caleskell strikes agaian.
07:55:47 <ion> > 42 1337 (sqrt (-1))
07:55:48 <lambdabot>   42
07:55:49 <otters> > fix (\e -> e - 1)
07:55:53 <lambdabot>   mueval-core: Time limit exceeded
07:55:59 <mauke> > fix (subtract 1)
07:56:03 <lambdabot>   mueval-core: Time limit exceeded
07:56:05 <otters> @src fix
07:56:05 <lambdabot> fix f = let x = f x in x
07:56:19 <int-e> > ((*2) + 4) 2
07:56:19 <lambdabot>   8
07:56:42 <mauke> > 2 `inRange` (2, 3)
07:56:43 <lambdabot>   False
07:56:58 <ion> > 2.5 `inRange` (2,3) -- :-(
07:56:59 <lambdabot>   Ambiguous type variable `t' in the constraints:
07:57:00 <lambdabot>    `GHC.Arr.Ix t'
07:57:00 <lambdabot>      aris...
07:57:21 <int-e> > (*(*2)) 3 5 -- hmm.
07:57:22 <lambdabot>   30
07:57:41 <mauke> > (*) (*) 2 3 5
07:57:42 <lambdabot>   30
07:57:51 <elliott> > ((*) * (*)) 4
07:57:52 <lambdabot>   Overlapping instances for GHC.Show.Show (a -> a)
07:57:53 <lambdabot>    arising from a use of `...
07:57:55 <elliott> :(
07:57:58 <elliott> > ((*) * (*)) 4 5
07:57:59 <lambdabot>   400
07:58:02 <mauke> > 2 3 5 (*) (*)
07:58:03 <lambdabot>   2
07:58:11 <elliott> > (*) 2 (*) 3 4
07:58:12 <lambdabot>   24
07:58:46 <mauke> preflex: calc * 2 * 3 4
07:58:46 <preflex>  24
07:58:47 <nand`> How is the Num instance for a -> a defined?
07:58:50 <mauke> it's true
07:59:00 <int-e> > map (2 + id + id^2) [0..3]
07:59:01 <lambdabot>   [2,4,8,14]
07:59:01 <elliott> nand`: applicative lifting
07:59:05 <elliott> (*) = liftA2 (*) etc.
07:59:10 <elliott> i.e. f*g = \x -> f x * g x
07:59:18 <elliott> fromInteger = const . fromInteger
07:59:18 <nand`> ah
07:59:20 <int-e> nice way to write polynomial functions.
07:59:26 <mauke> nand`: a bit like http://mauke.hopto.org/stuff/haskell/fun.hs except less crazy
07:59:32 <elliott> I actually like that instance.
07:59:35 <elliott> The (,) instance, less so.
08:00:16 <elliott> mauke: haha, that Num (f a) instance... playing with fire
08:00:21 <int-e> > (1,1) + 4
08:00:22 <lambdabot>   (5,5)
08:00:41 <elliott> > (1,2) * (3,4)
08:00:42 <lambdabot>   (3,8)
08:00:58 <otters> > (1,2) * (3,4,5)
08:00:58 <lambdabot>   Couldn't match expected type `(t, t1)'
08:00:59 <lambdabot>         against inferred type `(t2, ...
08:01:05 <int-e> the (,) instance has the same semantics though, pretty much -- pointwise evaluation.
08:01:24 <mauke> my code lets you do [1,2] * [3,4,5]
08:01:30 <elliott> int-e: yeah, but that makes _sense_ for an applicative functor
08:01:31 <mauke> and also [1,2] * "xyz"
08:01:32 <otters> > 3 + ()
08:01:33 <lambdabot>   No instance for (GHC.Num.Num ())
08:01:33 <int-e> so  Bool -> a  and  (a,a)  have isomorphic Num instances.
08:01:33 <lambdabot>    arising from the literal `3' at <intera...
08:01:52 <elliott> int-e: I would be fine if it mirrored the (,) applicative (aka Writer)
08:01:59 <elliott> i.e. (a,b) + (c,d) --> (a <> c, b+d)
08:02:34 <ion> @type (id, id) + (id, id)
08:02:35 <lambdabot> forall a a1. (Num a, Num a1) => (a -> a, a1 -> a1)
08:02:43 <elliott> :(
08:02:44 <int-e> elliott: I disagree. There's a choice here, many sensible instances. Which arguably means that there should be none at all but Haskell has set bad precedents in that area.
08:03:03 <mauke> :t 0 `asTypeOf` (undefined, undefined)
08:03:04 <lambdabot> forall a a1. (Num a, Num a1) => (a, a1)
08:03:14 <elliott> int-e: I don't think the (*) is sensible, since the obvious use of the instance is to treat it as a vector.
08:03:43 <elliott> int-e: A two-element ZipList would be the correct way to achieve such semantics.
08:03:56 <int-e> is it? it's a direct product of rings.
08:04:01 <idest0> what is the difference between if I do (contents <- getContents) and then either I follow with putStrLn . show or just putStrLn (contents) ? I can see a difference at runtime but i don't get what is going on underneath
08:04:11 <int-e> you may perceive vectors as more useful ...
08:04:12 <elliott> idest0: show puts quotes around strings
08:04:23 <mauke> idest0: the second one prints contents, the first one prints (show contents)
08:04:28 <elliott> > "abcdef"
08:04:28 <lambdabot>   "abcdef"
08:04:29 <elliott> > show "abcdef"
08:04:31 <lambdabot>   "\"abcdef\""
08:04:35 <elliott> (and escapes what's inside, etc.)
08:04:36 <idest0> ok so it needs to get the whole string before being able to print it ?
08:04:40 <mauke> idest0: no
08:04:41 <elliott> No.
08:04:46 <elliott> They are identical as far as strictness goes.
08:04:49 <elliott> But they don't do the same thing.
08:04:57 <int-e> ... but vector spaces are not rings anyway, so Num is the wrong class for them.
08:05:09 <elliott> int-e: Num is the wrong class full stop. :p
08:05:19 <int-e> it's a nice class for rings.
08:05:41 <mauke> instance Ring (Ring (Ring (Ring Bananaphone)))
08:05:41 <int-e> (except that abs and signum don't belong there)
08:06:04 <elliott> it's nice for rings except for the fact that it's not Ring!
08:06:09 <idest0> ok but then why the second one prints immediately after each "return" entry by the user, and the other waits EOF ?
08:06:47 <elliott> idest0: Because you have line-buffering on.
08:06:56 <elliott> idest0: And show turns newlines into backslash-n.
08:06:59 <int-e> elliott: and why is that?
08:07:02 <elliott> So stdout is never flushed.
08:07:09 <elliott> hSetBuffering stdout NoBuffering if you want.
08:07:15 <elliott> int-e: <int-e> (except that abs and signum don't belong there)
08:07:18 <mauke> ^ not recommended
08:07:27 <idest0> ah ok i got it, thank you very much
08:07:27 <int-e> elliott: ok. I got confused about "it" :)
08:07:40 <mauke> NoBuffering makes all output much slower
08:17:37 <cmccann> elliott: I always feel guilty writing a Num instance for something isomorphic to a fixed-length list and using "(*) = liftA2 (*)" but usually there's no other choice :[
08:19:03 <alistra>     Couldn't match expected type `Data.ByteString.Internal.ByteString'
08:19:04 <alistra>                 with actual type `ByteString'
08:19:10 <alistra> what can be the problem here? ^
08:19:22 <elliott> cmccann: Well, it's OK if those are the semantics you want.
08:19:32 <elliott> cmccann: I would not expect those semantics for (,) (or rather I would not expect a Num instance at all).
08:19:43 <elliott> alistra: lazy/strict bytestring mixup
08:19:51 <cmccann> elliott, they're not, but the semantics I want usually don't work with Num
08:19:52 <elliott> it wants a strict bytestring, you're giving it a lazy one
08:20:04 <alistra> elliott: how to fix it, because i tried with all the kinds
08:20:14 <elliott> alistra: Pass the right type of ByteString.
08:20:14 <alistra> and it looks that it always wants the other one :D
08:20:19 <elliott> Hmm.
08:20:20 <cmccann> elliott: and (,) is wrong because it's heterogeneous, this is for fixed length lists
08:20:22 <elliott> Can you hpaste what you've tried?
08:20:27 <elliott> cmccann: (*) = error "blame the committee"
08:21:12 <cmccann> elliott, at least with the pointwise multiplication I get easy fake scalar multiplication, with "fromIntegral = pure . fromIntegral" :P
08:21:56 <alistra> http://hpaste.org/57407
08:21:58 <alistra> no paste bot?
08:22:56 <alistra>     Couldn't match expected type `Data.ByteString.Lazy.Internal.ByteString'
08:22:57 <alistra>                 with actual type `ByteString'
08:23:06 <alistra> now this when i change lazy to regular
08:23:33 <ByronJohnson> alistra: I haven't looked at the code, but that looks like you're using a strict bytestring where a lazy one was expected
08:24:08 * cmccann is sometimes tempted to use a geometric algebra-based representation for vectors in Haskell just because it permits a nearly sensible Num instance
08:24:09 <alistra> ByronJohnson: it appears that depends on what i'm using the other one is needed
08:25:10 <ByronJohnson> alistra: You can convert between the bytestring types with the *chunks functions
08:26:20 <zhasha> Hey, I apparently don't understand IO monads as I wrote this code to time a sorting algorithm, but it seems no matter what I do it always outputs 0 ns passed: http://hpaste.org/57408
08:27:38 <irene-knapp> zhasha: line 21
08:27:46 <irene-knapp> the sort is not happening yet, because of lazy evaluation
08:28:07 <zhasha> How do I go about emulating strict behavior?
08:28:19 <alistra> :t bracket
08:28:20 <lambdabot> Not in scope: `bracket'
08:28:42 <alistra> zhasha: deepSeq i guess :D?
08:29:06 <ByronJohnson> zhasha: Deppends on what you mean by "emulating strict behaviour", but seq a b causes a to be strictly evaluated to at least WHNF before b is
08:29:14 <otters> :t seq
08:29:15 <lambdabot> forall a t. a -> t -> t
08:29:18 <elliott> zhasha: You probably want evaluate (rnf xs).
08:29:27 <zhasha> but I need the return value
08:29:32 <elliott> Oh, wait, no.
08:29:36 <elliott> zhasha: You probably want evaluate (force xs).
08:29:40 <irene-knapp> well, bear in mind that you can never just drop a function call into place in a lazy language, and expect it to take as much time as it will in a strict language
08:29:43 <elliott> evaluate from Control.Exception, force from Control.DeepSeq.
08:29:51 <ByronJohnson> zhasha: deepSeq seems to be intended to fully strictly evaluate something
08:29:55 <elliott> zhasha: But you should consider using the criterion library.
08:30:04 <irene-knapp> that is, the measurement you will obtain is worst-case only
08:30:12 <elliott> zhasha: It greatly simplifies the benchmarking of code like this, with accurate timing, and the interface is a lot simpler too.
08:30:29 <zhasha> elliott: is it included in the haskell platform?
08:30:36 <irene-knapp> how long it actually takes depends on how it's used and  whether all of the result is /ever/ used
08:30:47 <elliott> zhasha: I don't know, but it's a common library; you can just "cabal install criterion".
08:31:10 <irene-knapp> and it never happens all at once normally, it's split up to happen as the sorted items are demanded
08:31:14 <zhasha> Not for me, but for my teacher who was dubious about receiving haskell code in the first place
08:33:10 <otters> yeah, how do you evaluate an IO action?
08:33:11 <otters> just one
08:33:20 <elliott> otters: Evaluate howso?
08:33:26 <zhasha> irene-knapp: I'm only interested in the worst case by the way
08:33:36 <otters> elliott: like if I say let foo = putStrLn "Hello world!"
08:33:56 <elliott> otters: Why are you saying that? You can just do: do { putStrLn "Hello world!"; ... }
08:34:01 <otters> yeah...
08:34:05 <elliott> But if foo = putStrLn "Hello world!" then do { foo; ... } will work too.
08:34:11 <otters> Oh, okay.
08:34:14 <elliott> Of course, just "foo" itself works fine, it's an IO action.
08:34:20 <otters> right
08:34:51 <irene-knapp> zhasha: welllll, but it's actually worse than the worst case because it also counts the cost of forcing it
08:35:03 <irene-knapp> zhasha: but good, that should help
08:35:20 <irene-knapp> zhasha: I just wanted to explain what was happening
08:35:32 <zhasha> irene-knapp: Ideally I'd like to just do it with things in the haskell platform. The numbers themselves aren't really that important
08:35:44 * irene-knapp nods
08:35:55 <zhasha> It's an introduction to algorithms class I took just to get 5 easy points
08:36:39 <irene-knapp> the numbers you get by this method don't reflect average performance, is all
08:36:44 <irene-knapp> anyway, yeah
08:37:51 <zhasha> irene-knapp: but they'll resemble, in relation to one another, the kind of numbers you'd get in C by doing a quick sort
08:37:58 <irene-knapp> certainly
08:38:23 <irene-knapp> but I'd hate to have Haskell compared to C on such a basis
08:45:40 <zhasha> irene-knapp: deepseq is doing the trick for me this time I think, but I'll definitely use criterion if I ever need to do this for real
08:48:37 <irene-knapp> good, cool
08:49:04 <irene-knapp> I wasn't the one who suggested criterion, but I hear good things about it :)
09:02:11 <zhasha> irene-knapp: I don't know what's better: that my completed haskell code is smaller than the _extremely_ condensed Java code, or that mine is finished and the Java code is lacking the actual sorting algorithm :)
09:07:47 <lukish> @pl (\[a,b] -> b ++ " - " ++ a ))
09:07:48 <lambdabot> (line 1, column 3):
09:07:48 <lambdabot> unexpected "["
09:07:48 <lambdabot> expecting pattern
09:08:08 <lukish> How can I make it pointfree?
09:09:12 <cmccann> > intercalate " - " ["foo", "bar"]
09:09:13 <lambdabot>   "foo - bar"
09:09:19 <cmccann> lukish, ^^
09:09:28 <Ptival> @pl (\l -> let [a, b] = l in b ++ " - " ++ a)
09:09:28 <lambdabot> (line 1, column 12):
09:09:29 <lambdabot> unexpected "["
09:09:29 <lambdabot> expecting "()", natural, identifier or "in"
09:09:35 <cmccann> which also works on any number of arguments :P
09:09:35 <Ptival> meh
09:09:55 <tkahn6> anyone know of a function like 'sequenceWhile' :: sequenceWhile (m a -> Bool) -> [m a] -> m [a]
09:09:56 <johnsingleton> Does anyone have any experience with the Aeson JSON library?
09:10:01 <Nibble> johnsingleton: no
09:10:03 <tkahn6> johnsingleton; a litle
09:10:11 <shachaf> cmccann: What if OverloadedStrings and Monoid (++)?!
09:10:18 <Nibble> johnsingleton: if you have a specific question, please ask it instead of asking if anyone knows anything about it
09:10:22 <shachaf> Now your function is less general.
09:10:29 <johnsingleton> Nibble, ok
09:10:32 <Nibble> johnsingleton: even if no-one knows about it, they may be able to help you instead
09:10:35 <Nibble> win-win :)
09:10:43 <Nibble> there's a lot of great people in here
09:10:47 <johnsingleton> Basically, I am trying to access a nested structure within my JSON response
09:10:56 <cmccann> shachaf, good point, I should generalize intercalate. I'm thinking any foldable and monoid, perhaps?
09:11:14 <shachaf> Why Foldable?
09:11:15 <johnsingleton> I perfectly get how to parse things of the form {"k":"v","k2":"v2"}
09:11:19 <shachaf> Oh, Foldable = ToListable.
09:11:26 <shachaf> Seems silly.
09:11:28 <johnsingleton> but I am interested in something like this:
09:12:09 <cmccann> shachaf, well I can't just leave it with only lists, that's much too monomorphic
09:12:26 <cmccann> I need to be able to use it when I get -XPolymorphismRestriction added to GHC
09:12:31 <johnsingleton> { "interesting stuff" : {"k":"v", "k2":"v2", "moarkeys": {….}, "don't care about this stuff" : {"k":"v", "k2":"v2", "moarkeys": {….},  }
09:13:05 <elliottcable> elliottt: hi! Ignore elliott, he's the devil.
09:13:07 <johnsingleton> I've been working on it for several days, and I just don't see how to do it :(
09:13:15 <elliottcable> elliottt: (the other one, I'm cool.)
09:13:44 <monochrom> hi! devil on cable :)
09:13:46 <elliott> No elliott can be cool without a nick matching /elliott+/.
09:14:25 <jedai> @type intercalate
09:14:26 <lambdabot> forall a. [a] -> [[a]] -> [a]
09:14:50 <ikitat> ts = 0:1:(zipWith (\a b -> 34*a-b+2) (drop 1 ts) ts)
09:14:51 <johnsingleton> It doesn't *need* to be in haskell -- I just think knowing how to do it would help strengthen my understanding of it
09:14:53 <cmccann> tkahn6, might be one here: http://hackage.haskell.org/package/monad-loops
09:14:58 <tkahn6> johnsingleton: yeah it's pretty annoying the docs only have a very basic example
09:15:12 <tkahn6> cmccann:: i've looked, i don't think it exists there
09:15:28 <ikitat> I can't quite parse the above, it finds the intersection between squares and triangular numbers
09:15:50 <ikitat> I get the 0:1:... is concatenation to a list
09:15:55 <cmccann> tkahn6, if it's not there it probably doesn't exist. sounds like some sort of fold, so should be easy to write using other combinators...
09:15:57 <johnsingleton> tkahn6: ya, I've pretty much hit a dead end with it...
09:16:07 <ikitat> but I don't understand where ts comes frm
09:16:32 <tkahn6> cmccann: it's like a fold that short circuits though, i'd like to be able to do it on an infinite list
09:16:38 <johnsingleton> ideally I'd just have some sort of nested data type, but how to tell Aeson how to parse that, no idea.
09:17:12 <cmccann> tkahn6, you'll have to get a finite list out of it even if the input is infinite
09:17:39 <monochrom> ikitat: the author wants a recursive definition. the author chooses to give a name so that the name can be used for recursion
09:17:55 <tkahn6> right, but doesn't fold consume the whole list?
09:18:13 <tkahn6> i mean i don't think what i want is too hard, just curious if something like it already existed
09:18:15 <elliott> I wish bracket had the type { bracket :: IO (a, IO ()) -> (a -> IO b) -> IO b }
09:18:21 <elliott> or something
09:18:26 <tkahn6> johnsingleton: http://stackoverflow.com/questions/6826678/how-to-parse-nested-json-with-aeson ?
09:18:32 <tkahn6> does that help?
09:18:34 <ikitat> so does haskell determine the sequence based on 0:1: and continue to imcrement by 1?
09:19:16 <cmccann> tkahn6, foldr works on infinite lists...
09:19:18 <monochrom> the recurrence being implemented is: ts!!0 = 0, ts!!1 = 1, ts!!(n+2) = 34 * (ts!!(n+1)) - (ts!!n) + 2
09:19:24 <johnsingleton> tkahn6: reading...
09:19:45 <tkahn6> > take 10 $ [0,1..]
09:19:45 <lambdabot>   [0,1,2,3,4,5,6,7,8,9]
09:19:51 <tkahn6> ikitat: ^
09:20:02 <tkahn6> cmccann: k
09:20:11 <zhasha> ikitat: I believe it defaults to 1
09:20:18 <zhasha> > take 10 $ [0..]
09:20:19 <lambdabot>   [0,1,2,3,4,5,6,7,8,9]
09:20:26 <ikitat> ah
09:20:40 <ddarius> Neither of those is what is happening.
09:21:07 <ddarius> (0:) just adds 0 to the beginning of the list.  Similarly for (1:).
09:21:32 <ikitat> cons
09:21:46 <ddarius> Yes, (:) is cons.
09:21:47 * zhasha needs to learn to scroll up
09:21:48 <jedai> @src intercalate
09:21:48 <lambdabot> intercalate xs xss = concat (intersperse xs xss)
09:21:53 <nand`> > let ts = 1:2:ts in ts
09:21:54 <lambdabot>   [1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,...
09:22:01 <jedai> @src intersperse
09:22:01 <lambdabot> intersperse _   []     = []
09:22:01 <lambdabot> intersperse _   [x]    = [x]
09:22:02 <lambdabot> intersperse sep (x:xs) = x : sep : intersperse sep xs
09:23:23 <johnsingleton> tkahn6: I don't think I understand what happens starting at the "case" statement...
09:23:41 <johnsingleton> is it just pattern matching?
09:24:00 <elliott> case is pattern-matching, yes
09:24:38 <tkahn6> elliot: you don't even know what we're talking about..
09:25:05 <elliott> tkahn6: I was inferring from context.
09:25:08 <johnsingleton> elliott: I've never seen this syntax: [("field", Object o')], specifically the second part of the tuple.
09:25:26 <elliott> johnsingleton: o' is just a variable name, Object's just a constructor.
09:25:28 <elliott> Like (Just a).
09:25:46 <tkahn6> johnsingleton: M.toList will convert the JSON object into a list of [(key, value)] pairs
09:25:47 <elliott> Except Object is presumably a field of some other data type (a JSON object type).
09:26:03 <tkahn6> so then you can pattern match on the key
09:26:15 <johnsingleton> tkahn6: Now we are getting somewhere!
09:26:45 <tkahn6> and o' is bound to the value part
09:26:57 <tkahn6> so then you can extract information from that
09:27:07 <johnsingleton> tkahn6: So I can probably just keep nesting from there to access deeper parts of the structure?
09:27:14 <tkahn6> johnsingleton: that should work
09:27:33 <johnsingleton> I'd need to convert o' to a list, if I need to go deeper though, yes?
09:28:02 <tkahn6> yeah you'd probably want to have helper functions for each 'breakdown'
09:28:18 <johnsingleton> tkahn6: okay, great. That gives me something more to go with
09:28:26 <tkahn6> johnsingleton: yeah good luck :p
09:28:34 <johnsingleton> tkahn6: I'll keep hacking and report back… thanks!
09:28:41 <tkahn6> johnsingleton: np
09:29:49 <jedai> johnsingleton: note that if you want to do deep-nested modification or inquiry, you probably want lenses (see fclabel for example)
09:30:00 <jedai> @where lenses
09:30:00 <lambdabot> <http://twanvl.nl/blog/haskell/overloading-functional-references>,<http://cdsmith.wordpress.com/2011/04/26/composing-state-with-functions-and-lenses/>,<http://patternsinfp.wordpress.com/2011/01/31/
09:30:00 <lambdabot> lenses-are-the-coalgebras-for-the-costate-comonad/>,<http://stackoverflow.com/questions/5767129/lenses-fclabels-data-accessor-which-library-for-structure-access-and-mutation>
09:30:22 <elliott> that patternsinfp link sure is helpful :P
09:30:51 <jedai> elliott: and broken up :(
09:31:24 <elliott> jedai: good -- it'll stop newbies clicking it
09:31:44 <jedai> elliott: Or did you mean that for a beginner it wasn't the best presentation of leses ever ?
09:31:52 <jedai> *lenses
09:31:53 <elliott> indeed :P
09:32:08 <elliott> a lens is just a coalgebra for the costate comonad, what's the problem?
09:32:18 <monochrom> as it happens, the split url still works
09:32:34 <jedai> monochrom: oh good..or bad...
09:33:07 <elliott> quick, someone expand it so it breaks at a less opportune place
09:33:25 <jedai> elliott: I'm sure we can find some link on lenses that are even better for beginners (some papers maybe ?)
09:33:38 <monochrom> no, you have to move the split point to the left, e.g., http://patternsinfp.wordpress.com/20
09:34:03 <johnsingleton> lenses!
09:34:08 <johnsingleton> this is exciting
09:34:36 <elliott> johnsingleton: the http://stackoverflow.com/questions/5767129/lenses-fclabels-data-accessor-which-library-for-structure-access-and-mutation link is the best introduction in that entry
09:34:51 <johnsingleton> elliott: checking it out...
09:35:00 <elliott> jedai: surely lenses must have some deep category-theoretic interpretation someone's written up somewhere :)
09:35:14 <elliott> johnsingleton: (personally I would recommend the data-lens library discussed there, but fclabels is popular too)
09:35:55 <johnsingleton> haskell continually blows me away…
09:37:38 <mysticc> aby body used memory mapped files in haskell ?
09:38:29 <elliott> mysticc: no, but I think http://hackage.haskell.org/package/mmap is meant to be good
09:39:13 <eyebloom> what do mean by blows me away.
09:39:15 <mysticc> elliott: Yeah .. but I dont know how to flush the data in memory to force it to be written ..?
09:40:47 <johnsingleton> eyebloom: like, there seems to be no bottom to what you can do/learn wrt haskell
09:41:41 <elliott> mysticc: "If mode is ReadWrite, ReadWriteEx or WriteCopy the returned memory region may be written to with poke and friends."
09:41:53 <jedai> mysticc: What do you mean ? that's the kernel job no ? If you're finished with it you could use munmap ?
09:41:54 <elliott> so you have to use the Ptr interface, I think
09:42:01 <johnsingleton> like, I'm really just starting out w/Haskell, but I feel like the more I learn, the more I have to learn ;)
09:42:14 <elliott> johnsingleton: weird unicode in your line there
09:42:27 <elliott> (U+001C INFORMATION SEPARATOR FOUR)
09:42:30 <eyebloom> I see. It's a big relief coming from a language like C++ or Python.
09:42:46 <jedai> johnsingleton: Yes, there's plenty of depth to Haskell (doesn't mean you have to know everything to write some nice programs with it though)
09:42:56 <johnsingleton> eyebloom: it makes them look very boring...
09:42:57 <ddarius> eyebloom: How is that a relief?
09:42:59 <mysticc> jedai: I wanted to provide some gurantees that the data is written after certain point even system crashes ..
09:43:40 <elliott> mysticc: You'll need fsync and stuff for that.
09:43:41 <johnsingleton> jedai: heh, indeed. ;)
09:44:12 <jedai> mysticc: They don't seem to provide facility for this particular case "Q: What happens if I map ReadWrite and change memory? A: After some time in will be written to disk. It is unspecified when this happens. "
09:44:22 <eyebloom> Haskell immediately removes a lot of the problems and bugs in those languages, moving them from run time to compile time and that's a relief.
09:44:37 <jedai> mysticc: I guess it was too hard to provide independently of the os ?
09:47:01 <jedai> mysticc: Are you concerned about staying multiplatform ?
09:47:18 <mysticc> jedai: No just linux
09:47:19 <CodeWeaverX> I'm alive!  ALIVE!  Right, back to coding.
09:47:40 <jedai> mysticc: Then you should use msync, that may not be too hard with the FFI
09:47:50 <elliott> I'm not alive!
09:48:23 <CodeWeaverX> I am NaN!  I am a free(void*)!
09:48:38 <jedai> mysticc: Pretty easy in fact if you're not too nitpicky :)
09:48:58 <monochrom> hi CodeWeaverX, are you ok? :)
09:49:09 <CodeWeaverX> Rarely. ;)
09:49:21 <monochrom> "I am live! I am not garbage collected!"
09:49:26 <CodeWeaverX> hahahahahaha
09:49:52 <monochrom> "I am a leaked file handle"
09:50:00 <mysticc> jedai: Dont know .. Can you tell some refernces to read for that ..
09:50:13 <jedai> @where ffi
09:50:13 <lambdabot> http://www.cse.unsw.edu.au/~chak/haskell/ffi/
09:50:47 <jedai> mysticc: The FFI in Haskell is really nice, there's not much to it
09:51:26 <jedai> You may also look at the source of System.IO.MMap to see how they did it :)
09:56:17 <johnsingleton> I'm getting a ambiguous reference error because I have both aeson and aeson-native installed -- any way to deal with that without passing in flags to ghc, ghci?
09:58:35 <luite> johnsingleton: the best way is probably to upgrade all packages that depend on aeson-native
09:59:07 <luite> but as a workaround for things without a cabal file, like ghci sessions, just ghc-pkg hide aeson-native
09:59:18 <lukish> There is rights :: [Either a b] -> [b]. But how can I apply it to Either a b value?
09:59:18 <elliott> ghc-pkg hide aeson would be better, surely?
09:59:23 <elliott> oh, wait, -native is the slow one
09:59:28 <luite> no, aeson-native is deprecated
09:59:36 <elliott> oh, so it is
09:59:50 <tkahn6> apparently zipWithM isn't lazy?
09:59:50 <johnsingleton> luite: ok, cool -- that works
09:59:53 <luite> newer aeson don't cause problems with TH and ghci anymore
10:00:32 <luite> yesod now depends on the regular aeson, I'm not sure if anything else used to depend on -native
10:01:03 <c_wraith> tkahn6: it applies all the effects immediately.  It's not lazy if the effects aren't lazy.
10:01:36 <tkahn6> c_wraith: thanks, i'll do an hpaste, maybe you can help me come up with an alternative
10:04:08 <otters> what does yesod mean?
10:04:14 <tkahn6> c_wraith: http://hpaste.org/57410
10:04:16 <elliott> http://yesodweb.com/
10:04:20 <luite> the yesod web framework, http://yesodweb.com/
10:04:25 <elliott> ("foundation", I think :P)
10:04:26 <otters> no, what does the name mean
10:04:28 <otters> oh
10:04:29 <luite> oh right
10:04:34 <luite> yes foundation in hebrew
10:04:43 <otters> I see
10:05:20 <otters> looks good so far
10:05:26 <dgpratt> thus making it the only Hebrew word I know
10:05:49 <c_wraith> tkahn6: yeah, zipWithM is never going to return produce a value in IO when working over two infinite lists
10:06:15 <tkahn6> c_wrait: thanks
10:06:27 <tkahn6> c_wraith: i guess my solution will be a tad uglier then
10:06:37 <c_wraith> tkahn6: Your options are doing your control flow more explicitly, or, in a case like this, using unsafeInterleaveIO
10:06:52 <tkahn6> c_wraith: ah i see. i've never used that
10:06:59 <elliott> Don't start now.
10:07:03 <tkahn6> lol
10:07:08 <tkahn6> why not?
10:07:13 <viller> [newb] how can I define a name in interactive Hugs? let foo = "bar" gives an error
10:07:15 <otters> "unsafe"
10:07:15 <elliott> That way lies madness. It's unsafe for a reason :)
10:07:28 <otters> :t unsafePerformIO
10:07:29 <lambdabot> Not in scope: `unsafePerformIO'
10:07:32 <otters> oh
10:07:49 <byorgey> viller: IIRC, in Hugs you can just write  foo = "bar"
10:07:50 <tkahn6> why doesn't zipWithM only do the IO action when it's required?
10:08:03 <c_wraith> because it's not allowed to, by the definition
10:08:07 <tkahn6> oh i see
10:08:20 <byorgey> viller: do you have a particular reason for using Hugs?
10:08:22 <tkahn6> oh
10:08:25 <c_wraith> it's defined in terms of (>>=), and that is explicit about when to do IO
10:08:36 <tkahn6> c_wraith: i just had that epiphany
10:08:39 <tkahn6> thank you
10:08:48 <viller> byorgey: it gives me "ERROR - Syntax error in input (unexpected `=')"
10:08:55 <elliott> No, you can't.
10:08:56 <viller> byorgey we have to use it in school
10:09:00 <c_wraith> excellent
10:09:00 <elliott> You have to do: let foo = "bar" in ...
10:09:05 <byorgey> viller: hmm, I don't know then
10:09:06 <elliott> Hugs doesn't have definitions like that at all in the REPL.
10:09:12 <elliott> BTW, what is it with all these schools using Hugs lately?!
10:09:13 <monochrom> unsafeInterleaveIO delays error detection to a point you don't expect and so you can't handle them properly. it also delays actual I/O so you don't know when to close files.
10:09:20 <elliott> Someone needs slapping for that.
10:09:24 <byorgey> viller: in that case I guess you have to put  foo = "bar" in a .hs file and then load it into Hugs
10:09:30 <byorgey> elliott: seriously.
10:09:36 <viller> ok no problem. I was just wondering.
10:10:20 <viller> where I live school hasn't actually started yet but in the previous years they used Hugs (I checked the course materials) so I guessed they will continue with that (I hope not)
10:11:34 <byorgey> viller: even if the course materials use Hugs I don't see any particular reason why you couldn't use ghci.
10:11:55 <elliott> byorgey: Well, GHC's libraries are quite divergent from Hugs' at this point, I think...
10:12:03 <elliott> I don't think Hugs even has Control.Applicative.
10:12:10 <luite> viller: you might contact them about it, maybe it's still early enough to change it
10:12:14 <tkahn6> this is actually an interesting problem..
10:12:16 <byorgey> elliott: "quite" is probably an overstatement.
10:12:35 <byorgey> elliott: they are divergent in ways that are not likely to be important in a beginning Haskell course.
10:12:53 <monochrom> the common solution to both of those problems is to hack evaluation order to indirectly hasten the I/O and error detection back to the points under your control. in other words, introduce unsafeInterleaveIO to postpone I/O, just so that you can write more code to cancel the postponement.
10:13:34 <tkahn6> monochrom: thanks
10:15:04 <johnsingleton> tkahn6: so I'm playing around with that example… I'm getting a type mismatch error on the M.toList(o :: Object) part… M.Map k0 a0 doesn't match against unordered-containers-0.1.4.3:Data.HashMap.Common.HashMap.Data.Text.Internal.Text Value
10:15:44 <tkahn6> johnsingleton: can you do an hpaste of what you have so far?
10:16:45 <monochrom> it is like saying you have a school homework of outputting 0, but you think that's too easy, so you choose two distinct primes p, q randomly, loop over 1..p*q to count the divisors of p*q, then subtract (p-1)*(q-1), and output that.
10:17:11 <johnsingleton> tkahn6: heh, sure, I'm just actually using that sample verbatim to play with it in GHCI, but here: http://hpaste.org/57411
10:17:32 <elliott> byorgey: fair enough
10:17:35 <elliott> byorgey: Hugs has better error messages :P
10:17:49 <byorgey> elliott: does it?
10:18:03 <elliott> Well, it seems to have better typeclass-related error messages, going by what I've seen in SO questions.
10:18:05 <int-e> monochrom: that even works if p = 2 and q = 5 or vice versa ;)
10:18:08 <elliott> More concise, at least.
10:18:18 <byorgey> ok, that could be.
10:18:43 * elliott doesn't think that's a good reason to use Hugs, but it might be a good reason not to bother using GHCi when Hugs is expected.
10:18:49 <shachaf> Helium has better typeclass-related error messages.
10:18:50 <byorgey> GHC's error message have improved a lot in the past few years though.
10:18:58 <nand`> What language is hugs written in?
10:19:00 <elliott> shachaf: It also has the worst.
10:19:02 <elliott> nand`: C
10:19:05 <nand`> oh
10:19:11 <nand`> I like how GHC is written in haskell itself
10:19:24 <elliott> byorgey: One step forward, two steps back, IMO... especially with type families, (a ~ b) started popping up in even the simplest of type mismatch errors.
10:19:32 <elliott> "I wanted a, you gave me b" --> "Can't deduce a ~ b"
10:19:42 <elliott> nand`: Hugs is an interpreter.
10:19:45 <byorgey> hmm
10:19:54 <byorgey> maybe so
10:19:56 <nand`> elliott: so it doesn't compile down to assembly, but executes on the fly?
10:20:08 <elliott> nand`: Yes.
10:20:16 <elliott> I don't know if Hugs compiles down to a bytecode or does AST-walking, actually.
10:20:25 <tkahn6> johnsingleton: i'm looking
10:20:33 <johnsingleton> tkahn6: cool
10:20:42 <nand`> the wiki article mentions bytecode
10:20:45 <elliott> nand`: It has to do *some* "preprocessing", of course, since Haskell has e.g. forward references.
10:20:55 <elliott> And type-checking is quite thoroughly global :P
10:24:04 * hackagebot scan-vector-machine 0.2.7 - An implementation of the Scan Vector Machine instruction set in Haskell  http://hackage.haskell.org/package/scan-vector-machine-0.2.7 (AdamMegacz)
10:26:12 <edwardk> preflex: xseen dolio
10:26:12 <preflex>  dolio was last seen on freenode/#haskell 11 hours, 9 minutes and 50 seconds ago, saying: Not all. Just some more choice ones.
10:26:18 <dolio> Eh?
10:26:52 <edwardk> at the new place unpacking a bunch of books. if you want any of those old 2nd edition d&d books, feel free to swing by ;)
10:26:55 <cmccann> elliott: those aren't precisely the same thing, "can't deduce a ~ b" means it expected them to be the same, not that it wanted one and got the other
10:27:03 <dolio> Hah.
10:27:17 <dolio> I'll pass for now.
10:27:23 <edwardk> fair nuff ;)
10:28:16 <edwardk> bunch of random .net stack stuff, and pretty much every cisco book that was in print a few years ago that i'm also clearing out
10:28:33 <edwardk> wish i'd decided to do so before moving them, but hey
10:28:46 <shachaf> What's with all the Cisco books?
10:28:47 <byorgey> cmccann: however, one could imagine implementing type inference by generating a constraint a ~ b every time you need to do unification, and then trying to solve all the constraints at the end.
10:28:56 <byorgey> cmccann: although I don't think that's how it's actually done.
10:28:56 <elliott> cmccann: yeah, yeah :)
10:29:05 <edwardk> shachaf: at one point in time i challenged all my employees that i'd get any certification they did
10:29:09 <elliott> cmccann: but expecting them to be the same can arise from passing one where it wanted the other
10:30:17 <edwardk> shachaf: they started going pretty obscure after a while. i just moved the box full of pretty-much-all-lapsed-by-now certifications
10:30:17 <edwardk> the only cisco book i'm keeping is the worst technical book i've ever read
10:30:26 <edwardk> and i'm keeping it because it is SO incredibly bad
10:30:48 <edwardk> well, its not technically by cisco
10:31:08 <edwardk> but irony of ironies it was printed by mcgraw hill
10:32:09 <int-e> nand`: there is some bytecode. if you look at the sources, the instructions are in src/machine.c
10:34:07 <monochrom> TaPL's explanation of type inference is indeed to generate and accumulate a ton of a~b constraints, use unification to solve them at the last minute
10:34:52 <nus> edwardk, so did you get the most revered one?-)
10:35:14 <mreh> CCNA?
10:35:54 <nand`> How easy is it to find a job involving Haskell programming?
10:36:15 <mreh> nand`: don't bother
10:36:15 <elliott> Find? Pretty easy, I should think. Get? Harder :)
10:36:35 <elliott> There's Galois, that Tsuru Capital company...
10:36:36 <nus> nand`, just become a TA (-:
10:36:48 <mreh> a few companies are using FP as a shill to get smart programmers in the door
10:36:53 <erus`> when is the new platform out ? :) i wanna try these cool new kinds and stuff
10:36:58 <mreh> an even smaller few are using it
10:37:01 <monochrom> #haskell-certified haskell tutor
10:37:11 <cmccann> elliott, given how dumb GHC's suggestions often are, I'm happy to not have it guess which type is "correct"
10:37:14 <tkahn6> johnsingleton: cabal install unordered-containers
10:37:21 <nand`> I personally believe the future will inevitably shift more and more towards functional programming
10:37:28 <Dalamar> nus:  TA?
10:37:34 <nand`> as compilers start inferring algorithms for us
10:37:38 <mreh> drupal or XSLT are about a close to mainstream FP that you might find
10:37:39 <tkahn6> johnsingleton: replace Data.Map with Data.HashMap.Strict
10:37:43 <elliott> cmccann: Well, yes. But I do distinctly recall previously-reasonable error messages about mismatched types becoming ~-deduction silliness.
10:37:44 <mreh> that's my opinion
10:37:45 <nus> Dalamar, teaching assistant
10:37:48 <mreh> depends what circle you move in
10:37:49 <elliott> After all, ~ wasn't around a few versions ago.
10:37:52 <johnsingleton> tkahn6: already installed uc
10:37:57 <elliott> mreh: OCaml is pretty popular.
10:38:00 <elliott> F# too, I think.
10:38:06 <tkahn6> johnsingleton: yeah that was just in case
10:38:07 <nand`> ugh, F#
10:38:08 <elliott> Also, surely SQL and LINQ are more mainstream than XSLT?
10:38:12 <mreh> true, Citrix use OCaml
10:38:17 <mreh> they wouldn't give me a job though :(
10:38:21 <johnsingleton> tkahn6: why the type change?
10:38:29 <nand`> elliott: well yeah, LinQ is basically part of standard C# now, so it's popular by virtue of C# being popular
10:38:36 <tkahn6> johnsingleton: no idea :p ask the aeson authors
10:38:43 <russellw> nand`, you dislike F#? why?
10:39:01 <nand`> russellw: I haven't tried it personally, but heard it's hard to integrate C# and F# together
10:39:13 <nand`> and if I'm restricting myself to F# why not just use a more sensible alternative
10:39:26 <russellw> oh, I didn't find it all that hard
10:39:32 <johnsingleton> tkahn6: still the same error :(
10:39:45 <tkahn6> johnsingleton: can paste the code again?
10:39:52 <johnsingleton> tkahn6: sure
10:40:43 <johnsingleton> tkahn6: http://hpaste.org/57412
10:43:33 <tkahn6> johnsingleton: hmm either 1) remove the lines import Log and module or 2) check to make sure you're actually loading the new file or 3) we have some version differences
10:43:45 <tkahn6> johnsingleton: i only say that cuz it's working on my system
10:44:30 <mreh> oh... must i free Ptrs myself?
10:44:56 <johnsingleton> tkahn6: ok, let me try that.
10:44:57 <elliott> Yes.
10:45:07 <elliott> Except, freeing an mmapped Ptr is probably not what you want.
10:45:09 <elliott> Use munmap or wahtever.
10:45:12 <elliott> *whatever
10:45:17 <elliott> (You were the person asking about mmap, right?)
10:46:25 <zhasha> would it make sense to have a pure functional drawing API in haskell?
10:46:48 <cmccann> pure functional APIs make sense by default :P
10:47:04 <johnsingleton> tkahn6: sigh. no dice. I think 3) we must have different packages installed or something.
10:47:25 <zhasha> cmccann: so does procedural APIs, but none-the-less object orientation makes for great GUI APIs
10:47:56 <tkahn6> johnsingleton: :(
10:48:22 <cmccann> I think OO is somewhat overrated for general GUIs actually
10:48:24 <elliott> zhasha: Good GUI APIs, maybe. Great, no
10:48:28 <elliott> *no.
10:48:45 <tkahn6> johnsingleton: what is your version of Aeson?
10:48:46 <lpsmith> I rather liked Erlang's TK-based gui library
10:48:57 <mreh> withArray frees ptrs for me anyway
10:49:02 <elliott> FP GUI hasn't been perfected yet, but I can't see anyone seriously arguing that a declarative UI description + FRP would seriously be inferior to mutable OOP spaghetti.
10:49:11 <elliott> (Except out of ignorance, but people will argue anything out of ignorance.)
10:49:21 <elliott> OOP is certainly the most practical way to design GUI libraries in 2012, though, unfortunately...
10:49:48 <johnsingleton> tkahn6: Default available version: 0.5.0.0
10:50:00 <tkahn6> johnsingleton: oh i have 0.6.0.0
10:50:09 <zhasha> elliott: I've been toying with making a pure functi
10:50:16 <johnsingleton> tkahn6, leme see if that fixes anything
10:50:22 <zhasha> -onal API on top of Gallium3D and imbuing GHC with some power
10:50:24 <tkahn6> johnsingleton: k
10:51:45 * cmccann thinks most OO-based GUI libraries are 95% baroque obfuscation of a combinator library and 5% stuff that actually needs OO
10:51:52 <johnsingleton> tkahn6: OH MY GOD
10:51:58 <tkahn6> johnsingleton: !!
10:52:04 <johnsingleton> how can a minor version number make such a difference
10:52:19 <Eduard_Munteanu> Well, GTK feels quite a bit functional when used in conjunction with Haskell. :)
10:52:29 <tkahn6> johnsingleton: library authors like to change the underlying types they use
10:52:38 <johnsingleton> tkahn6: no kidding
10:52:39 <tkahn6> johnsingleton: had the same problem with the regex library last night
10:52:51 * cmccann recalls the package versioning policy allowing all kinds of breakage with only a minor version bump
10:53:06 <elliott> The Package Versioning Policy really confuses me.
10:53:14 <cmccann> major version bump means more "guaranteed breakage" than "possible breakage" :P
10:53:19 <elliott> Especially the part where it has one more component than any reasonable person could possibly want to use.
10:53:23 <johnsingleton> for real
10:53:32 <Eduard_Munteanu> cmccann: perhaps the leading 0 in the version number has something to say about that ;)
10:54:32 * cmccann dislikes the way version numbers are handled because they won't let him use complex numbers
10:55:07 <Eduard_Munteanu> :)
10:55:10 <tkahn6> cmccann: there's no ordering of complex numbers tho right
10:55:48 <johnsingleton> not that it matters
10:55:53 <Eduard_Munteanu> "Isn't there a new release available?"   "No, I think you just imagined it."  :P
10:55:55 <johnsingleton> heh
10:55:55 <arcatan> it doesn't even let me use real numbers :(
10:56:02 <tkahn6> can u imagine figuring that out… 'you need to upgrade from 0.6+30i to 30+0.6i'
10:56:25 <nus> just go counterclockwise
10:56:30 <tkahn6> lol
10:56:47 <Eduard_Munteanu> You'd also get to say leftgrade/rightgrade.
10:57:13 <jedai> zhasha: Did you see diagrams ?
10:57:24 <zhasha> jedai: no?
10:57:27 <tkahn6> counterclockwise for minor changes, radial change for majo changes
10:57:28 <jedai> zhasha: as a functional drawing api ?
10:57:30 <cmccann> tkahn6, magnitude for feature set, angle for implementation, it's simple
10:57:43 <Eduard_Munteanu> oO... polar versions.
10:57:54 <jedai> zhasha: it's pretty awesome, don't know if that's what you were speaking about though
10:57:54 <cmccann> the closer you get to the real axis the closer that version is to being complete and bug-free
10:58:09 <arcatan> makes perfect sense
10:58:11 <mauke> I just use the source code itself as the version number
10:58:12 <cmccann> indeed
10:58:13 <tkahn6> cmccann: brilliant
10:58:14 <johnsingleton> tkahn6: so in that example we've been looking at, it assumes every top level element is something we care about -- how do I handle the return values in a way that tells it to drop stuff from the parser… i.e., is there a "skip" for a result of parseJSON?
10:58:17 <mauke> it's all just bits anyway
10:58:25 <mauke> and it only requires integers
10:58:46 <tkahn6> johnsingleton: i'll annotate an example of something that may work
10:58:50 <Eduard_Munteanu> HTTP 4e^(2000i) ftw
10:59:01 <johnsingleton> tkahn6: it seems that fail, mzero, etc would stop parsing...
10:59:06 <johnsingleton> tkahn6: ok, cool.
10:59:17 <jedai> zhasha: There's also gloss but that's really more basic as for drawing, though it support animation, simulation and "games" so it's pretty useful for some applications
10:59:38 <zhasha> jedai: looks really good, and it's apparently implemented on Cairo
11:00:08 <jedai> zhasha: Yes, diagrams allows you to do some nice stuff in very few lines :)
11:00:50 <cmccann> basically my complex versioning scheme defines the positive real axis as being "complete and bug-free software" and the imaginary axis as being "vaporware"
11:00:50 <Eduard_Munteanu> The fun thing is cleanup changes / releases could be equal modulo 2π.
11:00:59 <cmccann> because let's face it, most real software is indeed a mixture of the two
11:01:01 <tkahn6> yeah basically i would try doing _ -> mzero for fields you don't care about
11:01:07 <tkahn6> johnsingleton: ^
11:01:35 <mekeor> @faq Does haskell know that '0*(a very complex function)' always equals 0 and thus doesn't eval the complex function?
11:01:35 <lambdabot> The answer is: Yes! Haskell can do that.
11:01:38 <jedai> zhasha: http://hpaste.org/57415
11:01:44 <cmccann> conflating bug fixes with implementing missing features seems dubious though, and I haven't figured out how to handle deprecations
11:01:52 <cmccann> I might need to switch to quaternions
11:01:52 <mekeor> lambdabot: rly?
11:01:53 <cmccann> :D
11:02:14 <tkahn6> mekeor: that's actually an interesting question
11:02:19 <zhasha> jedai: I was thinking a combined 3D and 2D API that would emit a machine-code-like bytestream asynchronously speaking a language very close to an actual GPU language. It would require GHC changes, but at the same time it would allow you to do things like write shaders directly in haskell and have it run GPU accelerated when compiled by GHC
11:02:20 <cmccann> mekeor, given a type with a suitable Num instance, yes
11:02:35 <johnsingleton> tkahn6: oh, sweet!
11:02:45 <tkahn6> johnsingleton: i don't know if that works :p but that would make sense
11:02:50 <cmccann> aren't there already a couple packages for writing shader code?
11:03:01 <jedai> zhasha: Sounds interesting, I don't know enough to comment though ;)
11:03:03 <johnsingleton> tkahn6: I'll play and report...
11:03:40 <zhasha> jedai: I don't know enough about haskell to undertake something like that. I do however have experience with g3d
11:04:00 <elliott> another day, another SO question to which the answer is "lenses"
11:04:06 <mekeor> cmccann: okay. does it also lazily eval '(a very complex func)*(another very complex func)*somenumber*5*10*(-1)*0' ?
11:04:21 <johnsingleton> does Haskell provide a way to write strings without escaping?
11:04:42 <cmccann> mekeor, it lazily evaluates everything unless you tell it not to. The details depend on the Num instance, again.
11:04:44 <tkahn6> johnsingleton: you mean like for debugging or something?
11:05:02 <cmccann> mekeor, if you're asking whether it will do that for standard types like Integer, then no not in general :P
11:05:03 <johnsingleton> tkahn6: to make it easier to write out JSON, for example
11:05:06 <tkahn6> or you mean without escape characters
11:05:28 <cmccann> mekeor, but consider that you can write a type representing abstract algebraic expressions and give that a Num instance
11:05:29 <mekeor> cmccann: oO okay...
11:05:46 <cmccann> mekeor, which you can then perform any optimizations on you like before "evaluating"
11:05:48 <tkahn6> johnsingleton: hmm maybe show an example of what you want, not exactly sure
11:05:58 <mekeor> cmccann: oO
11:05:59 <johnsingleton> tkahn6: sorta like a multiline mode, like groovy has: http://groovy.codehaus.org/Strings+and+GString
11:06:23 <jedai> johnsingleton: You have quasiquoting that allows for things like that
11:06:40 <johnsingleton> in groovy I could write: def foo = """\ (this region doesn't need escapes or anything) """
11:06:53 <johnsingleton> jedai: ok, I'll check into that
11:07:12 <tkahn6> johnsingleton: http://groups.google.com/group/fa.haskell/msg/6a63dc4540f0486d?pli=1
11:07:13 <tkahn6> may help
11:07:16 <jedai> johnsingleton: I think there's a package that does exactly that on hackage (with quasiquoting, qq...)
11:07:24 <cmccann> johnsingleton, quasiquoting is TH which is vastly more general than what you want, but yes a quasiquoter could let you do things like that
11:07:46 * elliott has been tempted to switch to the revolutionary versioning system "an incrementing natural starting from 0"
11:07:56 <elliott> the constraint crap never works anyway
11:08:00 <johnsingleton> tkahn6/jedai: that's perfect
11:08:02 <cmccann> mekeor, anyway, did that make sense to you? :T I could show an example if you like.
11:08:24 <cmccann> elliott, what we really need is better automation, manually tracking versions for compatibility constraints is madness
11:08:35 <jedai> johnsingleton: http://hackage.haskell.org/package/aeson-qq-0.4.1
11:08:50 <jedai> johnsingleton: if you directly want the json value in Haskell...
11:09:12 * cmccann has some half-baked ideas for how to automate such things but they need the GHC API and that's too much hassle
11:09:32 <johnsingleton> jedai: that is awesome!
11:09:40 <jedai> johnsingleton: http://hackage.haskell.org/packages/archive/string-qq/0.0.2/doc/html/Data-String-QQ.html if you just want multiline strings without escape (there's a version that does interpolation too)
11:10:38 <johnsingleton> jedai: for my tests, I need to write it in JSON, but it's cool to know that exists… I'll check into String-QQ
11:10:44 <johnsingleton> very cool!
11:11:31 <johnsingleton> that's honestly so much better than I expected
11:11:33 <jedai> johnsingleton: apparently there are quasiquoters for text-json and aeson depending on which you use :)
11:12:17 <erus`> Interger -> Integer -> Integer
11:12:25 <erus`> @hoogle Integer -> Integer -> Integer
11:12:25 <lambdabot> Data.Bits (.&.) :: Bits a => a -> a -> a
11:12:25 <lambdabot> Data.Bits (.|.) :: Bits a => a -> a -> a
11:12:26 <lambdabot> Data.Bits xor :: Bits a => a -> a -> a
11:13:05 <cmccann> zhasha, what all did you have in mind for your GPU stuff, anyway?
11:13:25 <zhasha> cmccann: which side of things?
11:13:37 <elliott> cmccann: yes, it is
11:13:48 <elliott> cmccann: but doing it based on type signatures and the like doesn't really work
11:14:03 <elliott> cmccann: what we need are machine-readable comments like haddocks specifying API breakages/additions
11:14:31 <cmccann> zhasha, all of it in general, just curious about the details
11:14:49 <elliott> cmccann: so that we can annotate our packages with, e.g. "built with <pkg> version <ver>" (where the version number is arbitrary), and the package manager can check all changes to the API since then to determine whether a newer version is compatible with the parts of the API used
11:14:56 <elliott> but it would be a big undertaking :/
11:15:10 <Taneb> What would be the best thing to implement queues with in Haskell
11:15:14 <erus`> @Hoogle Floating -> Integral
11:15:14 <lambdabot> Maybe you meant: google hoogle
11:15:15 <cmccann> elliott, yes, types are insufficient in general, I was thinking of deeper source analysis and automated regression testing for common cases
11:15:20 <erus`> @hoogle Floating -> Integral
11:15:20 <Taneb> Is there a Data.Queue or something
11:15:21 <lambdabot> Warning: Unknown type Floating
11:15:21 <lambdabot> Unsafe.Coerce unsafeCoerce :: a -> b
11:15:21 <lambdabot> Prelude ($) :: (a -> b) -> a -> b
11:15:31 <cmccann> Taneb, I'm sure there are at least two on hackage
11:15:34 <erus`> oh i need round
11:16:32 <xKjabibi> elliott, my psychic powers tell me you're British
11:16:50 <xKjabibi> Also, did your great grandfather have an e or an a or an o in his name?
11:16:56 <xKjabibi> I can talk to him beyond the grave
11:17:35 <Taneb> xKjabibi, "British" is a pretty wide field. Most people in Britain are British
11:17:40 <zhasha> cmccann: I really don't know enough about functional languages to boot. What I was thinking was creating a GHC extension of sorts, with an accompanying library that would allow you to use a pure functional drawing API, rendering on the CPU when compiled by (not GHC), and be converted into an efficient bytecode when compiled with GHC
11:17:58 <xKjabibi> True, but the name Elliott is seldom found outside that place.
11:17:58 <shachaf> Your MBR is written in Haskell?
11:18:08 <cmccann> elliott, it should be possible to identify many obvious incompatibilities, some trivial cases where versions are equivalent, and then generate quickcheck-like regression tests for pure functions that are non-obvious
11:18:13 <Taneb> xKjabibi, can you get it any narrower?
11:18:26 <shachaf> What about Conal Elliott? ...I guess "Conal" is a pretty uncommon name too.
11:18:36 <jedai> zhasha: I don't really see why you would need en extension to ghc
11:18:42 <xKjabibi> Sounds ike an adjective for something cone-shaped.
11:18:53 <cmccann> zhasha, yes, modifying GHC is probably overkill
11:19:10 <jedai> zhasha: there's plenty of EDSL that generate code in another language (see copilot, lava, ...)
11:19:26 <cmccann> zhasha, sounds like something that could be implemented as an embedded domain-specific language to produce the code you want
11:19:32 <cmccann> er, as jedai just said
11:20:17 <elliott> xKjabibi: wat
11:20:18 <jedai> zhasha: You even have harpy that basically allows you to put assembler in your code
11:20:46 <cmccann> zhasha, and it'd be easy to have an "interpreted" mode that runs the program on the CPU instead of compiling for the GPU
11:21:13 <jedai> Right, even starting from the same code
11:21:27 <_Mikey> can one nest "if" "then" and "else" inside do blocks?
11:21:45 <ByronJohnson> _Mikey: Yes
11:21:55 <jedai> _Mikey: Yes but the indentation is tricky
11:22:01 <_Mikey> ByronJohnson, cool!
11:22:10 <_Mikey> jedai, ohh ...
11:22:18 <jedai> _Mikey: or rather there's an easy mistake to make (if you line up the if then and else)
11:22:35 <_Mikey> ahh ok..
11:22:43 <jedai> _Mikey: since the compiler then see them as three different monadic action, or try to...
11:22:59 <rwbarton> also what follows "then" and "else" are just expressions, so if you want to use do syntax there you need new do blocks
11:23:53 <jedai> though you don't need them if you have a single action (as you don't need a do-block for a single action)
11:25:24 <zhasha> cmccann, jedai: the reason I was thinking it needed to be embedded in the compiler is really just that in GPU it's all a matter of changing state efficiently. I believe there's a lot to be gained from the compiler having a very low level entry point and knowledge (at compile-time) about the things to be done. I think some llvm optimization passes would give a sizable boost
11:26:20 <zhasha> when I first started playing around with g3d I was amazed at the amount of code a single OpenGL call would end up executing
11:26:33 <cmccann> zhasha, what we're suggesting is that instead of embedding it in the compiler, you create a mini-compiler for the GPU as a library
11:26:46 <_Mikey> thanks for the heads up rwbarton
11:27:16 <cmccann> zhasha, Haskell makes it very easy to have embedded languages like that while still constructing programs in them using mostly normal Haskell-ish code
11:27:25 <erus`> guys, is there a quick way to mask a Word*
11:27:38 <erus`> like i wanna set every bit except bit 6 and 7 to false
11:27:47 <jedai> erus`: mask ? with the operators from Bits no ?
11:28:06 <Eduard_Munteanu> zhasha: admittedly stuff like DX10/11 involves way less state tracking
11:28:08 <jedai> .&. 0b0010010
11:28:09 <erus`> there is no mask function
11:28:14 <erus`> oh and
11:28:17 <Eduard_Munteanu> Or so I hear.
11:28:18 <erus`> ofcourse ;)
11:29:05 * hackagebot HaskellForMaths 0.4.2 - Combinatorics, group theory, commutative algebra, non-commutative algebra  http://hackage.haskell.org/package/HaskellForMaths-0.4.2 (DavidAmos)
11:29:15 <elliott> zhasha: take a look at the GPipe, accelerate libraries
11:29:24 <elliott> zhasha: haskell excels at edsls
11:29:29 <elliott> so you don't have to run a haskell runtime on the gpu at all
11:29:43 <elliott> and can write code that looks like higher-order functional transformations that compiles down to efficient gpu code
11:29:57 <jedai> zhasha: especially the accelerate package has a gpu backend I believe (a CUDA backend)
11:30:24 <zhasha> with 512 instruction slots on the r500 chip, it wouldn't really be possible to put in a full haskell runtime
11:30:25 <elliott> GPipe is GLSL-backed
11:30:27 <erus`> >0b11100000
11:30:30 <erus`> > 0b11100000
11:30:30 <lambdabot>   Not in scope: `b11100000'
11:30:44 <elliott> zhasha: yes, which is why we're telling you that's not what we're proposing...
11:30:56 <jedai> erus`: Sorry, I'm not sure at all that this syntax works in Haskell
11:31:07 <zhasha> elliott: sorry, just stating the obvious
11:31:22 <elliott> also, I would qusetion the idea that  GPUs are "all about state"; they're rather /bad/ at shared state, after all, given their heavily-parallel nature and weird memory structure
11:31:25 <elliott> *question
11:31:39 <elliott> indeed, they're mostly good at operations that can be expressed most directly in a functional style
11:31:44 <elliott> maps, zips, associative folds, etc.
11:31:47 <erus`> > foldl (.|.) 0 (map bit [5..7])
11:31:48 <lambdabot>   Ambiguous type variable `a' in the constraint:
11:31:49 <lambdabot>    `Data.Bits.Bits a'
11:31:49 <lambdabot>      a...
11:32:06 <Taneb> > foldl (.|.) (0 :: Int) (map bit [5..7])
11:32:07 <lambdabot>   224
11:32:15 <mauke> > 3 `shiftL` 6 :: Word
11:32:16 <lambdabot>   192
11:33:14 <zhasha> elliott: yes, the individual processor lends itself to a functional style. However it's been my experience that at the driver level the interface is quite slow, and this has led to various ways of reducing state changes significantly
11:33:14 <johnsingleton> tkahn6: OK, moving on: http://hpaste.org/57418
11:33:50 <johnsingleton> tkahn6: can you guess what getParsed returns?
11:33:54 <elliott> zhasha: certainly -- but that's mostly to do with how you acecss the API, not the code that goes on the GPU per se
11:34:08 <tkahn6> johnsingleton: Nothing?
11:34:18 <johnsingleton> tkahn6: how'd you guess ;)
11:34:19 <elliott> zhasha: I mean, it's something an EDSL can excel at -- since it can analyse the high-level functional structure of the code and optimise the code it creates for that
11:34:22 <tkahn6> johnsingleton: haha
11:34:26 <elliott> and ensure efficient memory patterns, etc.
11:35:00 <johnsingleton> tkahn6: I can't explain why, but yes.
11:36:15 <zhasha> elliott: right, but my concern is really more in the area of "what if I have 4 function calls, that relate to 2 different framebuffers. The compiler COULD group these to minimize framebuffer state changes". Of course taking more than just fb state into account, this could probably lead to some pretty sizable gains. Not for games of course, but for general GUIs it could be massive.
11:37:11 <zhasha> it would effectively be like what they want to do with clutter, which is manually flattening the entire object tree and avoid/group as many API calls as possible
11:37:39 <johnsingleton> tkahn6: any ideas about where I might be going wrong?
11:37:45 <tkahn6> johnsingleton: looking at it now
11:37:53 <johnsingleton> tkahn6: oh ok
11:38:30 <elliott> zhasha: Yes, that's why an EDSL is exactly what you want.
11:38:44 <elliott> zhasha: You'd basically get a high-level syntax tree at runtime that you could transform and optimise as much as you want.
11:38:55 <elliott> Transforming it into a heavily-stateful program to send off to the GPU.
11:39:06 <zhasha> awesome
11:39:44 <elliott> zhasha: GPipe is a working OpenGL solution that does basically that (although it's kinda bitrotten) and accelerate is a more data-processing-oriented variant on the same ideas with CUDA and soon OpenCL backends, so you should probably take a look at those
11:46:07 <erus`> has anyone has any experience with GAs? I need to represent a List of List of things as a genome
11:46:26 <erus`> but it has to be mutatable
11:48:12 <CodeWeaverX> I've dohne some simple GA's in C++ and Java.
11:48:18 <zhasha> elliott: I definitely will
11:50:09 <CodeWeaverX> But your question isn't so much about GA's.. more about applying small data mutations… rebuilding the list(s) with mutations applied isn't an option?
11:50:32 <gwern> > 42 * 15
11:50:32 <lambdabot>   630
11:50:57 <erus`> yeah but the boundaries between lists get skewed
11:51:01 <erus`> i guess thats the idea
11:51:21 <CodeWeaverX> explain 'skewed'
11:52:06 <erus`> i have like <8 bits defining list len><list data>
11:52:41 <erus`> lost of those in the genome
11:52:43 <erus`> lots*
11:53:46 <CodeWeaverX> i need more coffee apparently.  not sure what you mean there.
11:55:49 <CodeWeaverX> Oh I see.  You have a length of list and a list.  Okay, but why does that preclude rebuilding the list when you mutate?
11:55:55 <jedai> johnsingleton: testJson = C.pack [s|
11:55:55 <jedai> [{"field":{"name":"john"}}, {"tag":{"name":"some tag"}}, {"line":{"number":69}}]
11:55:55 <jedai> |]
11:56:56 <jedai> johnsingleton: Your problem is you ask it for [Rule] but you don't give it a list of Rule, you give it a hash with several entries, which each could be a Rule
11:56:57 <erus`> CodeWeaverX: i just worry that the list mutation will write over the list length
11:57:23 <CodeWeaverX> erus', are you storing the length and list in a tuple or record in haskell then?
11:57:43 <erus`> yes
11:58:02 <erus`> but i have to convert to bit array to mutate it right?
11:58:24 <erus`> in order to apply GA
11:58:56 <tkahn6> johnsingleton: :)
11:59:00 <CodeWeaverX> Well, doesn't that depend on what the rules for GA mutation are?  If what you have is a list of 0's and 1's, or a list of floats, or whatever, you could do the appropriate genetic mutation operation yourself.
11:59:12 <johnsingleton> jedai: hurmmmmm
11:59:22 <CodeWeaverX> You have a [[Int]] (list of list of ints) or something?
11:59:31 <erus`> yeah kinda
11:59:40 <tkahn6> johnsingleton: http://hpaste.org/57420
11:59:40 <jedai> johnsingleton: Is the JSON already there or are you creating it ?
12:00:03 <CodeWeaverX> erus': What does the mutation operation do?  Select random genetic bits to flip?
12:00:13 <johnsingleton> jedai: I'm putting it together based on the example… In reality, I want to consume a JSON feed from Yammer
12:00:15 <tkahn6> the guy's usecase in that stackoverflow answer is probably different than yours
12:00:20 <johnsingleton> jedai: babysteps
12:00:31 <monochrom> there is also some dependence on whether you have to keep the old gene for a while
12:00:41 <johnsingleton> tkahn6: reading....
12:00:42 <erus`> CodeWeaverX: a real mutation algorithm is also supposed to swap whole sections
12:00:44 <tkahn6> k
12:01:10 <CodeWeaverX> erus' I see, so your outer list is a list of sections, and your inner list is a list of individual bits?
12:02:16 <erus`> i have a list of polygons, a polygon is a list of vertexes
12:02:29 <ddarius> erus`: That would be the crossover step.
12:02:42 <jedai> tkahn6: johnsingleton: Well I guess there's several ways of parsing it successfully but if you don't know what you want to get at the end... ;)
12:02:58 <tkahn6> jedai: yeah exactly that may be the problem :p
12:03:25 <tkahn6> jedai: I don't think johnsingleton wanted Rule to be an ADT
12:03:29 <k0ral> hi, how can I limit the number of figures used to print a Double ?
12:04:05 <mauke> :t showFFloat
12:04:06 <lambdabot> forall a. (RealFloat a) => Maybe Int -> a -> String -> String
12:04:20 <mauke> > showFFloat Nothing pi ""
12:04:21 <lambdabot>   "3.141592653589793"
12:04:23 <monochrom> showEFloat lets you control that. there is also printf
12:04:26 <CodeWeaverX> erus': Well, there's no reason to need to convert this to another data type as such.  You just need a rule for rebuilding the list and choosing when to perform a mutation action.  For a vertex, the mutation might be 'move in a random direction by some amount'.
12:04:26 <mauke> > showFFloat (Just 2) pi ""
12:04:27 <lambdabot>   "3.14"
12:04:29 <johnsingleton> tkahn6: did the code you pasted return an array of Rule?
12:04:41 <tantalum> k0ral: google haskell printf
12:05:00 <k0ral> tantalum: I googled "Haskell print Double precision"
12:05:04 <tkahn6> johnsingleton: yes
12:05:19 <johnsingleton> tkahn6: getParsed?
12:05:23 <tkahn6> ah no
12:05:29 <k0ral> mauke, monochrom: thank you :
12:05:40 <tkahn6> getParsed is supposed to return a singular value
12:05:44 <jedai> tkahn6: doesn't it return only one Rule
12:05:46 <mauke> > printf "%.2f" pi :: String
12:05:47 <lambdabot>   "3.14"
12:05:50 <tkahn6> jedai: yes
12:05:57 <tkahn6> testJson returns a list
12:06:28 <tantalum> tantalum: There is a printf like function in haskell that you can use %.2d with
12:06:41 <tantalum> *k0ral
12:06:46 <monochrom> hehehe
12:06:52 <mauke> tantalum: did you mean: %.2f
12:07:12 <tantalum> mauke: maybe
12:07:15 <tkahn6> oh wait
12:07:18 <tkahn6> getParsed returns a list
12:07:22 <tkahn6> haha
12:07:23 <mauke> also, by "printf like" do you mean printf?
12:07:30 <tkahn6> johnsingleton jedai: yes getParsed returns a list
12:08:07 <johnsingleton> tkahn6: running it as pasted still returns nothing for me
12:08:39 <tkahn6> johnsingleton: hmm works on my machine
12:08:41 <jedai> tkahn6: No, you need to have a list in the json to get a list aith decode
12:09:02 <jedai> tkahn6: Really, what version of aeson ?
12:09:10 <tkahn6> 0.6.0.0
12:09:37 <johnsingleton> how does it work in general? is parseJSON supposed to decode a single element? it's confusing what is going on there.
12:09:43 <tkahn6> johnsingleton: yes
12:09:49 <jedai> tkahn6: Strange, I have the same, are you sure you didn't add [ and ] in testJSON after you pasted ?
12:10:36 <jedai> johnsingleton: basically you have a (FromJSON a) => FromJSON [a] instance
12:10:38 <johnsingleton> tkahn6: so for each element it encounters, as separated by a "," -- it calls parseJSON, I assume?
12:11:21 <jedai> johnsingleton: that takes of elements you know how to parse i the json (so something between []) and return a list of Haskell values
12:11:28 <k0ral> tantalum: yes mauke already mentioned it
12:11:42 <jedai> *that takes a list of
12:12:19 <tkahn6> johnsingleton jedai: proof i'm not messing with y'all http://i.imgur.com/sQb4Y.png
12:12:20 <tkahn6> :p
12:12:40 <tkahn6> i think that's what i hpasted
12:13:26 <johnsingleton> jedai: so if I give it any old string, how does it decide how to call parseJSON? Eg, does it call it for each element it encounters? at which level? I am thinking of parseJSON as a callback for when it encounters a new element in a json array… would that be accurate?
12:13:41 <jedai> tkahn6: You're not showing getPasted in this...
12:13:55 <tkahn6> jedai: that's cuz i'm retarded
12:13:59 <tkahn6> ://////
12:14:00 <tkahn6> lol
12:14:08 <johnsingleton> tkahn6: call getParsed ;)
12:14:08 <jedai> johnsingleton: Well it calls the parseJSON your Haskell code calls for
12:14:10 <johnsingleton> see what you get
12:14:32 <tkahn6> oops
12:14:50 <johnsingleton> brb
12:15:08 <jedai> johnsingleton: that is if you call decode json :: Maybe Rule, it will call your parseJSON
12:15:53 <jedai> tkahn6: No, truly, the [a] instance of FromJSON needs a json list (so [] in the JSON)
12:16:04 <lukish> How can I rewrite that zip (allInnerTagsContent "title" a) (allInnerTagsContent "url" a) ?
12:16:34 <lukish> Without duplication allinnerTagsContent and a
12:16:57 <tkahn6> *sigh
12:17:14 <jedai> tkahn6: http://hpaste.org/57418
12:17:32 <tkahn6> jedai: nice
12:18:02 <jedai> tkahn6: but as I said, I'm not sure what we're trying to achieve here... Your interpretation may have been closer to what he need
12:18:16 <tkahn6> jedai: yeah that json looks pretty weird
12:18:28 <tkahn6> johnsingleton: you should find a sample of what you're trying to parse
12:18:36 <shortino> ciao
12:18:38 <tkahn6> johnsingleton: then we can get something accomplished for real
12:18:42 <jedai> tkahn6: He should probably work on his real target (though that may be bigger...)
12:18:42 <shortino> !list
12:19:02 <tkahn6> jedai: yeah
12:19:15 <k0ral> > 1:[]:[]
12:19:16 <lambdabot>   No instance for (GHC.Num.Num [a])
12:19:17 <lambdabot>    arising from a use of `e_11' at <inter...
12:19:24 <k0ral> > 'a':[]:[]
12:19:24 <lambdabot>   Couldn't match expected type `GHC.Types.Char'
12:19:25 <lambdabot>         against inferred type...
12:19:31 <k0ral> > 'a':[]
12:19:32 <lambdabot>   "a"
12:19:35 <k0ral> > 'a':[]:[]
12:19:36 <lambdabot>   Couldn't match expected type `GHC.Types.Char'
12:19:36 <lambdabot>         against inferred type...
12:21:14 <mekeor> > 'a':[]:[[]]
12:21:15 <lambdabot>   Couldn't match expected type `GHC.Types.Char'
12:21:16 <lambdabot>         against inferred type...
12:21:40 <mekeor> > "a":[]
12:21:41 <lambdabot>   ["a"]
12:21:54 <mekeor> > ('a':[]):[[]]
12:21:55 <lambdabot>   ["a",""]
12:22:03 <mekeor> > ('a':[]):[]
12:22:04 <BMeph> Is there a name for the property: "fmap f (a b g) == a b (fmap f g)"?
12:22:04 <lambdabot>   ["a"]
12:23:04 <k0ral> > []:[]
12:23:05 <lambdabot>   [[]]
12:23:09 <k0ral> > []:[]:[]
12:23:10 <lambdabot>   [[],[]]
12:23:28 <ddarius> BMeph: You are saying fmap f . h = h . fmap f
12:23:39 <ddarius> If that is true for all f then h is a natural transformation.
12:24:23 <elliott> I wonder what the most elegant way to generate all balanced strings of parentheses is.
12:24:52 <elliott> > let foo = [""] `interleave` map (\x -> "(" ++ x ++ ")") foo `interleave` liftA2 (++) foo foo
12:24:53 <lambdabot>   not an expression: `let foo = [""] `interleave` map (\x -> "(" ++ x ++ ")")...
12:24:54 <elliott> > let foo = [""] `interleave` map (\x -> "(" ++ x ++ ")") foo `interleave` liftA2 (++) foo foo in foo
12:24:56 <lambdabot>   ["","","()","","()","()","(())","","()","()","(())","()","(())","(())","(((...
12:25:02 <elliott> Hmph.
12:26:17 <BMeph> ddarius: So it just means that "a b" is an NT, then?
12:26:32 <ddarius> If that statement is true for all f, yes.
12:26:40 <salisbury> So, I started reading 'Land of Lisp', and I keep thinking: "I prefer Haskell". I'm never going to use Lisp, I was just learning it for the supposed insights it gives you.
12:27:01 <salisbury> Are these insights still apparent for someone knowing haskell?
12:27:51 <ddarius> (and for all g)
12:28:03 <BMeph> > let dycks = "" : concatMap (\xs -> ["()"++xs,'(':xs++")"]) in take 30 dycks
12:28:04 <lambdabot>   Couldn't match expected type `[[GHC.Types.Char]]'
12:28:05 <lambdabot>         against inferred ...
12:28:09 <jedai> salisbury: Well you can envy the simplicity of macros I guess, that gives you some insight into Template Haskell, probably
12:28:14 <BMeph> > let dycks = "" : concatMap (\xs -> ["()"++xs,'(':xs++")"]) dycks in take 30 dycks
12:28:15 <lambdabot>   ["","()","()","()()","(())","()()","(())","()()()","(()())","()(())","((())...
12:29:03 <BMeph> ddarius: Well, its the definition of "a", so...yeah. Okay, thanks. :)
12:29:13 <BMeph> s/its/it's/
12:29:25 <salisbury> jedai: Hmm I didn't think of that.
12:29:59 <ddarius> BMeph: Note that that statement will hold (well enough) immediately due to parametricity.
12:30:01 <salisbury> I went in with the preconceived idea that Lispers frequently wrote programs that output other programs. I don't seem to see this actually happening in practice though..
12:30:12 <jedai> salisbury: On the other hand you may do a lot of that with normal functions in Haskell so
12:31:08 <russellw> salisbury, lispers don't often write programs that output whole programs, but they do often write subroutines (macros) that output code fragments
12:31:18 <ddarius> salisbury: Read "On Lisp" instead.
12:31:39 <russellw> Yeah, on Lisp contains a lot of good discussion about that
12:32:43 <elliott> salisbury: Lisp has valuable ideas not present in Haskell.
12:33:14 <elliott> salisbury: But I don't think it is possible to pick up deep, valuable ideas if you're going at it from the mindset of language tourism.
12:33:29 <elliott> (i.e. "I'm not going to use this, but I'll read this look to get all the good ideas anyway")
12:33:34 <salisbury> Hmm, you may be right.
12:33:39 <elliott> BMeph: hmm, nice enough
12:34:00 <salisbury> Perhaps (for not at least) I should focus on reading more about Haskell itself, rather than looking for insights elsewhere
12:34:20 <salisbury> now*
12:34:38 <elliott> salisbury: Compare, e.g. things like monads just "clicking" after being exposed to them and using them for a while -- you can't just read about something and leave it to simmer; the learning comes from applying them sufficiently that you come to a deeper understanding.
12:34:48 <johnsingleton> tkahn6: let me slap something together
12:34:52 <elliott> Learning Lisp is a good idea, but I agree that it's probably not best to try and learn Haskell and Lisp simultaneously.
12:34:53 <tkahn6> johnsingleton: k
12:34:54 <johnsingleton> tkahn6: thanks a ton for helping
12:35:03 <tkahn6> johnsingleton: no problem, i'm learning as well
12:35:40 <jedai> johnsingleton: Did you see my version ?
12:36:16 <salisbury> elliott: would you recommend any specific books for upper-end intermediate / advanced Haskell? I'm slowing working through TaPL, but a lot of that does not relate directly to Haskell
12:36:31 <jedai> johnsingleton: http://hpaste.org/57418 (Use the "it really works" version...)
12:37:06 <johnsingleton> jedai: checking
12:38:05 <johnsingleton> jedai: Ah, I see… So it's only for that single record
12:38:25 <johnsingleton> I'm going to knock together a data structure I am trying to populate to see if I can get some real understanding of what I am doing here ;)
12:38:29 <johnsingleton> almost there
12:38:56 <elliott> salisbury: It depends what "upper-end intermediate / advanced" is :) I don't know of any Haskell books that cover topics I would consider advanced.
12:39:22 <jedai> johnsingleton: Well your parsing function is adapted to parse a single Rule, which must be an object in json land {"field":{"name":"stuff"}}
12:39:36 <monochrom> there is no book covering type classes specifically, for example
12:39:47 <elliott> Typeclasses are upper-end intermediate/advanced now?!
12:39:55 <monochrom> no, I don't mean that
12:40:04 <elliott> salisbury: The problem is that it'd essentially be a big heap of "and here's another concept".
12:40:12 <jedai> johnsingleton: if you ask for a list of Rule, you'll use the default FromJson instance for list that only works for JSON lists
12:40:25 <monochrom> I mean that there is no book explaining all aspects of haskell type system
12:40:32 <elliott> Beginning to learn Haskell has a basically well-defined, progressive trajectory; after that, there's a sea of interconnected concepts, but no real ordering.
12:40:57 <salisbury> yes, that is exactly where I find myself. I'm not really sure how to proceed.
12:41:08 <elliott> salisbury: Have you read the Typeclassopedia? That's good to read once at an intermediate level to flesh out your understanding of the "control" typeclass hierarchy and as a pointer to more advanced material.
12:41:40 <monochrom> although type class falls under bounded polymorphism, all books go OOP when they bring up bounded polymorphism and leave haskell type class untouched
12:41:43 <elliott> Beyond that, what to learn is basically a function of your interest, or what you run into.
12:41:59 <illissius> m3ga: did you manage to solve your cabal-install/deepseq problem?
12:42:00 <salisbury> Hmm I'll have a look at that one
12:42:19 <elliott> salisbury: http://www.haskell.org/haskellwiki/Typeclassopedia
12:42:55 <monochrom> TaPL also goes with equirecursive types and does very little to isorecursive types, while haskell uses isorecursive types
12:43:29 <salisbury> Oh, yes, I have read portions of that. Though not everything
12:44:26 <monochrom> TaPL certainly has its own value for its own sake. but if your goal is to focus on haskell, TaPL is a long way to learn half of haskell
12:45:00 <salisbury> monochrom: that is what I was thinking as well. There is a whole section on OOP, for example
12:47:39 <Sgeo> TaPL?
12:47:50 <salisbury> Types and Programming Languages
12:51:21 <tommd> @where tapl
12:51:22 <lambdabot> http://www.cis.upenn.edu/~bcpierce/tapl/
12:52:01 <Cain_> Am i viewing this function correctly?
12:52:05 <Cain_> uh what
12:52:12 <Cain_> ignorem e..
12:54:06 <johnsingleton> if you have two data types (using record syntax) in the same module, if you'd like them both to share similar methods, e.g.: A.foo, and B.foo, how can you write that?
12:54:23 <johnsingleton> so they don't conflict
12:56:48 <glguy> a_foo, b_foo
12:57:09 <monochrom> they have different field names. then I write a type class to unify them
12:58:35 <johnsingleton> glguy: the underscore thing is just convention, right?
12:59:06 <ddarius> You could just put them in separate modules.
12:59:18 <glguy> The important part is that the names are different. I'm not advocating for a particular convention :)
13:00:15 <jedai> johnsingleton: Yes, the underscore is convention, though fclabels template Hskell utilities want you to put them there (so that the generated lenses don't have them)
13:00:23 <lpsmith> does anybody know why cabal install takes so long to determine dependencies?   Is it reading in the entire package index?
13:01:14 * glguy wants a cabal install that either uses the latest versions of packages or asks me to manually specify
13:01:24 <johnsingleton> jedai: http://hpaste.org/57424
13:01:28 <johnsingleton> tkahan6: http://hpaste.org/57424
13:01:55 <johnsingleton> jedai: I really have to learn these lenses ;)
13:02:02 <elliott> johnsingleton: You can't.
13:02:04 <johnsingleton> glguy: ok, just checking.
13:02:04 <elliott> Put them in different modules.
13:02:20 <elliott> jedai: "a_foo" won't work with fclabels.
13:02:24 <elliott> It'd be _a_foo.
13:02:33 <elliott> Which is a different underscore entirely.
13:02:47 <johnsingleton> elliot: and when you import them, haskell is smart enough to know what type I am operating on -- e.g., it's polymorphic?
13:02:54 <jedai> elliott: I thought john was speaking about the second
13:03:08 <elliott> johnsingleton: No.
13:03:19 <elliott> johnsingleton: Don't expect the record system to be reasonable, well-designed or useful.
13:03:25 <elliott> You'll be sorely disappointed.
13:03:30 <johnsingleton> ha
13:03:39 <elliott> Just prefix every field name with the record name, or put them in their own modules and import qualified.
13:03:51 <m3ga> illissius: no. dropping back to 7.2.2
13:03:59 <johnsingleton> so I need to still do like import qualified A as Foo, and then Foo.foo, etc?
13:04:08 <johnsingleton> that's a bummer
13:04:28 <elliott> m3ga: What problem?
13:04:54 <jedai> Yep, the record system is _the_ sore point in Haskell design right now (which is why you have so many attempts to make it right in libraries of course !)
13:05:02 <elliott> johnsingleton: Yes, it is. Nobody likes it, and everybody knows the *perfect* solution to the records problem: it's exactly like the solution everybody else wants, but slightly different, and they'll defend it to the death.
13:05:15 <elliott> Let me tell you about *my* solution!
13:05:20 <ByronJohnson> johnsingleton: While you're experimenting with record syntax, I suggest looking at fclabels
13:05:36 <elliott> johnsingleton: I feel obligated to state that I prefer data-lens over fclabels since everyone is mentioning the latter :P
13:05:51 <johnsingleton> heh
13:05:58 <johnsingleton> ok, I'll put both on a sticky to check out
13:06:03 <Sgeo> Isn't there a thing where fclabels allows for setters to be partial?
13:06:04 <johnsingleton> thanks for all the input!
13:06:26 <elliott> Sgeo: That is not really useful as a record system aid. But http://hackage.haskell.org/package/partial-lens.
13:06:37 <m3ga> elliott: Data.Array wouldn't compile due to some deepseq problem.
13:07:17 <Sgeo> trySetPL :: PartialLens a b -> a -> Maybe (b -> a)
13:07:21 <elliott> m3ga: Hmm, okay. Isn't the problem with deepseq usually that the version "cabal install" installs is the version that doesn't work with anything?
13:07:25 <Sgeo> Not ... quite what I meant, I think
13:07:42 <elliott> Sgeo: Why not?
13:07:43 <Sgeo> I think maybe trySetPL :: PartialLens a b -> a -> b -> (Maybe a)
13:07:49 <johnsingleton> tkahn6: did you see my paste, above?
13:07:55 <johnsingleton> that's basically what I am trying to do.
13:08:03 <Sgeo> elliott, I think I'm looking for something similar to the OO concept of only allowing validated values to be set
13:08:06 <johnsingleton> complete with a *real* JSON input
13:08:33 <jedai> johnsingleton: Well that seems pretty straightforward :)
13:08:47 <elliott> Sgeo: That should be encoded in the type of the field (smart constructor if the property is not statically decidable).
13:08:52 <johnsingleton> jedai: I sense sarcasm in your voice hehe
13:09:12 <elliott> setL blahField <$> makeBlah 42
13:09:26 <johnsingleton> I've been trying to decompose the problem into just, "how can I read stuff out of nested JSON structures" but maybe an exact example is more helpful
13:09:43 <jedai> johnsingleton: apparently you have an Object, that contains messages in the "messages" field, (which is a list) and users among other things in the referneces field (which is also a list)
13:10:28 <Sgeo> elliott, and how would the smart constructor be integrated with lenses? A lens needs a non-partial setter, right?
13:10:32 <jedai> johnsingleton: decode doesn't seem appropriate here
13:10:41 <johnsingleton> jedai: oh really?
13:11:04 <Sgeo> Or would you use error?
13:11:15 <jedai> johnsingleton: well your json is _not_ a list of messages, it's a complicated object that among other things contains messages
13:12:01 <johnsingleton> so am I better off just dropping down into Parsec?
13:12:07 <elliott> Sgeo: setL blahField <$> makeBlah 42
13:12:14 <elliott> data Foo = Foo { _blahField :: Blah }
13:12:15 <jedai> johnsingleton: or maybe you should have an data YammerStruct = Yammer Messages Users
13:12:18 <elliott> makeBlah :: Int -> Maybe Blah
13:12:23 <johnsingleton> I mean, that makes more sense to me, but I figured, hey, there is a JSON library….
13:12:30 <elliott> blahField can be set to any Blah; of course, Blahs can only hold valid values.
13:12:35 <elliott> Validation belongs in types.
13:12:49 <Sgeo> Hmm, ok
13:13:03 <elliott> setL blahField <$> makeBlah 42 :: Maybe (Foo -> Foo), e.g. setL blahField <$> makeBlah 42 <*> pure myFoo :: Maybe Foo
13:13:24 <jedai> johnsingleton: oh no, not at all what I mean, keep aeson, it's just a bit trickier than a complete 1 for 1 correspondence between your JSon and your data in Haskell (at least as you have created them for now)
13:13:24 <Sgeo> Ok, I get this
13:13:33 <johnsingleton> jedai: part of the reason I have it as two separate types like that is that 1) I won't have the entire feed at once, I have to stream it in little by little, and 2) it's is VERY large
13:13:42 <Sgeo> Not everything of type Set a b is a valid Set
13:14:02 <Sgeo> (Actually, hmm, it is except for the unsafe construction function I guess)
13:14:27 <jedai> johnsingleton: Well what you posted don't seem to be very large, did you trim it beforehand ?
13:14:35 <elliott> Sgeo: What is Set a b?
13:14:43 <johnsingleton> jedai: that's just the sample from the yammer docs
13:14:54 <johnsingleton> jedai: I have to still pull down the whole shebang
13:15:30 <mekeor> which are the conditions for a operator? i mean, which characters may it include? with which characters does it have to begin?
13:15:31 <Sgeo> (Ord a) => Set a b
13:15:36 <johnsingleton> guessing the traffic at my company, I am going to assume it's pretty darn big
13:15:39 <elliott> Sgeo: What is b?
13:15:43 <johnsingleton> on any given day there are thousands of messages
13:15:55 <Sgeo> elliott, me derping and confusing Set with Map
13:15:56 <jedai> johnsingleton: Well aeson seems to boast of some pretty fast parsing :)
13:15:56 <Sgeo> >..
13:15:57 <Sgeo> >.>
13:16:08 <elliott> mekeor: http://www.haskell.org/onlinereport/haskell2010/haskellch2.html#x7-180002.4
13:16:13 <johnsingleton> jedai: my thinking process isn't entirely opaque ;)
13:16:18 <mekeor> elliott: ty
13:16:45 <elliott> mekeor: See http://www.haskell.org/onlinereport/haskell2010/haskellch2.html#x7-160002.2 for the definition of "symbol".
13:16:59 <Sgeo> johnsingleton, yammer? As in the ... messaging thing that begins with G?
13:17:07 <elliott> "any Unicode symbol or punctuation" -- how vague.
13:17:32 <johnsingleton> Sgeo: yammer.com -- Gabble is the mac client
13:17:55 <Sgeo> Ah
13:18:00 <Sgeo> I wasn't thinking of that
13:18:16 <jedai> johnsingleton: Well from what you have right now, a lot of the yammer json won't have to be parsed at all (if you use decode) so you should be ok
13:18:19 <Sgeo> Y---something was a web interface to a G-something
13:19:03 <cgroza> I am having a hard time creating a regexp that will match a "Option=value" pattern.
13:19:06 <Sgeo> Had a CLI client too
13:19:33 <cgroza> I have : "^option=val$" and using the POSIX.
13:19:49 <jedai> johnsingleton: I would really suggest a Yammer type, you'll have to define three instances, one for User, one for Message and one for Yammer
13:19:59 <johnsingleton> my general approach was to 1) extract all the messages using roughly this logic: get a block of json (it's well-formed and closed, but you can only get it in chunks of 20), 2) for each message, parse out the details. 3) move to the end section, if it includes any user details I haven't stored yet, parse those out, 4) append new messages and users to a  (different) file, using a easier JSON structure.
13:21:02 <johnsingleton> jedai: I think I see what you are saying, that is, the ENTIRE block of JSON can be described via the Yammer type, rather than trying to almost imperatively solve it
13:21:09 <johnsingleton> is that accurate?
13:21:15 <jedai> johnsingleton: seems right
13:23:11 <jedai> johnsingleton: for this kind of data, I kind of doubt you'll get to performance problems (if you're only looking at the output of your company, aeson has been used to look at large portion of twitter traffic so it should be alraight)
13:23:39 <tjgillies> why doesn't :t Infinity work?
13:23:54 <cgroza> let r = mkRegex "a" ; matchRegex r "alfa" return Just []. Why?
13:24:03 <jedai> tjgillies: because Infinity is not a real Haskell literal
13:24:14 <jedai> > Infinity
13:24:14 <lambdabot>   Not in scope: data constructor `Infinity'
13:24:25 <jedai> > read "Infinity" :: Double
13:24:26 <lambdabot>   Infinity
13:24:45 <jedai> tjgillies: it's just what show use for 1/0
13:24:49 <jedai> > 1/0
13:24:50 <lambdabot>   Infinity
13:25:26 <tjgillies> i did Just 3 >>= \x -> return (x /0) and expected Nothing but got Just Infinity
13:25:42 <elliott> You expected wrong :)
13:25:45 <johnsingleton> jedai: so one more thing… If I go with the Yammer type approach
13:25:48 <tjgillies> apparently ;)
13:25:53 <elliott> tjgillies: return (x/0) in the Maybe monad === Just (x/0)
13:25:55 <elliott> === Just Infinity
13:26:21 <tjgillies> elliott: aah, that makes sense
13:26:26 <Sgeo> tjgillies, note that even div, which will error on divide by 0, will not give Nothing
13:26:28 <johnsingleton> jedai: the instances I define -- do they take into account the "position" of the parser or anything like that? or do I approach it: "given this huge block of JSON, here is how you make this type?"
13:26:32 <elliott> tjgillies: The Maybe monad doesn't magically catch exceptions in the values you return (indeed, it does not even force values when you return them, so it could not possibly do so)... but even then, dividing by zero does *not* produce an exception with floating-point numbers.
13:26:46 <jedai> johnsingleton: the second one
13:26:48 <elliott> tjgillies: You can write safeDivide _ 0 = Nothing; safeDivide n d = Just (n/d)
13:26:52 <elliott> And then use that inside the Maybe monad.
13:26:56 <Sgeo> > Just 3 >>= return (x `div` 0)
13:26:57 <lambdabot>   Couldn't match expected type `Data.Maybe.Maybe b'
13:26:58 <lambdabot>         against inferred ...
13:27:15 <Sgeo> > Just 3 >>= \x -> return (x `div` 0)
13:27:15 <lambdabot>   Just *Exception: divide by zero
13:27:38 <cgroza> >:t mkRegex
13:27:39 <johnsingleton> jedai: and so since there are MULTIPLE messages, I should be defining returning [Message] or Message from my fromJSON method?
13:27:50 <cgroza> :t mkRegex
13:27:51 <lambdabot> Not in scope: `mkRegex'
13:27:53 <jedai> Just Message
13:28:01 <jedai> mmm just Massage
13:28:06 <Sgeo> > let safeDiv _ 0 = Nothing; safeDiv a b = a `div` b in Just 3 >>= \x -> return (x `safeDiv` 0)
13:28:07 <lambdabot>   No instance for (GHC.Real.Integral (Data.Maybe.Maybe a))
13:28:07 <lambdabot>    arising from a ...
13:28:07 <jedai> Message
13:28:11 <hey_lu> jedai: is that aeson+Twitter stuff somewhere on the web? i'd really like to see aeson in action...
13:28:20 <cgroza> :m Text.Regex
13:28:21 <johnsingleton> jedai: ah, so in decode I tell it, decode blah :: Maybe [Message]
13:28:27 <johnsingleton> and it knows how to deal with it?
13:28:32 <Sgeo> > let safeDiv _ 0 = Nothing; safeDiv a b = Just (a `div` b) in Just 3 >>= \x -> return (x `safeDiv` 0)
13:28:33 <lambdabot>   Just Nothing
13:28:41 <Sgeo> Uh
13:28:45 <jedai> johnsingleton: No, you use decode json :: Maybe Yammer
13:28:50 <Sgeo> Oh
13:28:54 <johnsingleton> ah
13:29:02 <Sgeo> > let safeDiv _ 0 = Nothing; safeDiv a b = Just (a `div` b) in Just 3 >>= \x -> x `safeDiv` 0
13:29:03 <lambdabot>   Nothing
13:29:27 <johnsingleton> but yammer is defined like data Yammer { messages :: [Message] .. } ?
13:29:32 <Sgeo> "What's wrong?" "Just Nothing"
13:29:34 <illissius> m3ga: what were you trying to install? the problem is packages which depend on array < 0.4, which results in cabal wanting to reinstall deepseq to depend on 0.3.0.3 (instead of 0.4.0.0 which GHC ships with)
13:30:15 <jedai> johnsingleton: wait a sec, I'll make you a schema
13:30:27 <johnsingleton> jedai: very much appreciated ;)
13:30:55 <johnsingleton> jedai: sorry to be so dense on this, but this is my first adventure into this sorta thing with Haskell
13:30:58 <donri> are equality constriants a feature of type families specifically?
13:31:57 <m3ga> illissius: wanted wai warp yesod etc
13:32:09 <parcs`> donri: of?
13:32:20 <parcs`> they are enabled when type families are
13:32:31 <elliott> donri: They come with type families.
13:32:36 <Sgeo> wai do you want wai?
13:32:49 <ByronJohnson> As do asstypes
13:32:50 <Saizan> donri: they got intruduced with them
13:33:20 <Saizan> but are used e.g. for gadts in general
13:34:05 <jedai> johnsingleton: http://hpaste.org/57426 <- something like that, though I probably forgot to peel away some things
13:34:07 <Saizan> though probably not at the source level
13:34:33 <donri> ok thanks
13:35:47 <jedai> johnsingleton: You're not dense at all, I myself am often confused by this (because you have a mixture of Haskell types for JSON, real JSON and your own type) mostly you have to be real careful to understand what the type of everything you manipulate is
13:37:00 <hey_lu> jedai: regarding aeson+twitter, do you mean bos' blog post last february?
13:37:43 <jedai> hey_lu: maybe, it seems some of this was used to benchmark aeson after that
13:38:56 <johnsingleton> jedai: oh wow
13:39:16 <johnsingleton> jedai: that looks almost like magic -- the reason that all works is just type inference, right?
13:39:53 <johnsingleton> i.e., in the last step you pass messages as a constructor to Yammer, so it infers it can construct message with the Message instance of FromJSON etc
13:39:53 <johnsingleton> ?
13:40:05 <jedai> johnsingleton: it's probably because it don't work (I forgot to lift my filter to operate inside the Value on the Array but hte rest of it should be good)
13:40:16 <jedai> johnsingleton: Right
13:40:42 <tomprince> Is there a nicer way to write 'do portrait <- portrait; return $ if portrait then ["normal"] else ["left"]' ?
13:41:05 <jedai> johnsingleton: messages type is inferred from it being passed to Yammer and so GHC know to use the Message instance to parse it (or rather the [Message] but that use Message so...)
13:41:14 <shapr> Oh hey, where do I sign up for the haskell.org summer of code?
13:41:16 <johnsingleton> jedai: awesomeness. well, I'll pour over that -- do you think you could add the lift you were talking about so I have it all together for the first type?
13:41:25 <shapr> I want to be a student for the 2012 Haskell.org Google Summer of Code!
13:42:12 <shapr> conal: oh hi! Do you know who's running Summer of Code for haskell.org this year?
13:42:30 <conal> shapr: hey there. i haven't heard anything this year.
13:42:57 <shapr> Ah, too bad. I'm going to apply as a student!
13:43:09 <shapr> With a rather weird and odd proposal... PROPAGANDA!
13:43:36 <Saizan> :O
13:44:26 <shapr> Seriously, I will propose writing tutorials and further documentation for the most popular libraries on hackage. Though perhaps the ranking should include those least documented?
13:44:35 <shapr> Saizan: What do you think?
13:45:28 <johnsingleton> when/if I get this working, I'll be sure to blog about it so there is an example of it SOMEWHERE out on the web
13:46:01 <shapr> Saizan: This is in direct reaction to gwern's GSoC feedback: http://www.gwern.net/Haskell%20Summer%20of%20Code#lessons-learned
13:46:22 <shapr> I'm picking on point three: "Lack of propaganda" as a point I can effectively address.
13:46:41 <shapr> I may not be great at producing new libraries, but I srsly rock as a cheerleader and tutorial writer.
13:47:07 <mekeor> apropos "gwern"... is he in here sometimes? which nickname does he use?
13:47:13 * shapr looks at gwern 
13:47:16 <shapr> gwern: OH HAI
13:47:23 <shapr> mekeor: Hm, no clue.
13:47:24 <chipdude> Buenos dias.  Having freshly upgraded to ghc 7.4.1, I find cabal isn't letting me install yesod due to a problem with array and deepseq:
13:47:27 <chipdude> array-0.3.0.3 (new version)
13:47:30 <chipdude> deepseq-1.3.0.0 (reinstall) changes: array-0.4.0.0 -> 0.3.0.3
13:47:30 <chipdude> ... help?
13:47:33 <mekeor> gwern: hi! =)
13:47:34 <gwern> WHO SUMMONS ME
13:47:41 * shapr cowers before the power of gwern 
13:47:44 <mekeor> shapr: hehe
13:47:56 <Saizan> shapr: iirc gsoc has a rule against documentation-only projects
13:48:02 <Saizan> shapr: but icbw
13:48:04 <shapr> :-(
13:48:24 <shapr> Saizan: I would like to know more about that...
13:48:25 * shapr asks google
13:49:00 <jedai> johnsingleton: http://hpaste.org/57426
13:50:09 <nus> shapr, whouldn't that first require establishing some popularity metrics?
13:50:28 <shapr> nus: afaik, they're already available by hackage download at least.
13:51:16 <Saizan> but if a library is already popular does it really need propaganda?
13:51:18 <shapr> Saizan: http://www.google-melange.com/document/show/gsoc_program/google/gsoc2012/faqs#documentation
13:51:19 <chipdude> any hint on how to persuade cabal to simply -use- the globally installed deepseq, rather than unsuccessfully recompiling it?
13:51:34 <chipdude> I have rtfm, and found it unforthcoming
13:52:03 <shapr> chipdude: Are you installing some parts as user?
13:52:11 <johnsingleton> jedai: thanks! I'll jack and report back with a final solution (hopefully)
13:52:18 <johnsingleton> *hack
13:52:21 <johnsingleton> same thing ;)
13:52:21 <chipdude> shapr: all as user.  no attempt to install system libs
13:52:51 <chipdude> to be specific, I have a Debian [unstable] install which just upgraded ghc, I removed my old .cabal dir and started fresh
13:53:10 <chipdude> I did find http://hackage.haskell.org/trac/ghc/ticket/5701 which describes the dependency issue, but no applicable resolution appears
13:53:48 <Saizan> chipdude: you should figure out why it doesn't like that version
13:53:54 <Saizan> chipdude: --dry-run -v can help
13:53:57 <chipdude> but you see, it -does- like that version.
13:54:26 <Saizan> sorry, i meant more than just "version"
13:54:27 <chipdude> it just wants to (re)install it because, I believe, cabal's database claims that the deepseq and array versions cannot coexist, when in fact they do
13:55:03 <Saizan> i meant that exact installation of the version, it most probably wants to compile it against different dependencies
13:55:44 <chipdude> ah, yes.  see the link.  the hackage database claims, I believe incorrectly, that deepseq and array-0.4.0.0 are not compatible when they actually are
13:56:06 <chipdude> they are system installed, and fine, but cabal wants to install array-0.3.0.0 which then borks the build
13:56:33 <jedai> johnsingleton: I posted a slightly more beautiful version on http://hpaste.org/57426
13:56:40 <jedai> johnsingleton: I think...
13:56:52 <elliott> chipdude: known problem it seems
13:56:56 <elliott> ask m3ga :P
13:57:16 <m3ga> chipdude: i was running into that. i've backed out to 7.2.2 because i've got work to do.
13:57:19 <chipdude> I welcome a mere workaround.  Force cabal to believe that array-0.4.0.0 is compatible with deepseq, in the short term
13:57:20 <Saizan> chipdude: ok, so the problem is that they changed the .cabal file of deepseq without bumping the version
13:57:21 <elliott> the ticket isn't related afaict
13:57:31 <elliott> chipdude: cabal unpack array, edit .cabal file to fix it?
13:57:34 <elliott> then cabal install
13:57:58 <Saizan> chipdude: i guess you could just do the right thing wrt deepseq, i.e. edit the .cabal file but also bump the version
13:58:01 <m3ga> maybe i should try that
13:58:02 <chipdude> elliott: array is not the one with the error, but deepseq; but yes, I suppose that'd work
13:58:10 <chipdude> make a ...1 locally
13:58:11 <Saizan> chipdude: or, you could remove that version from your hackage index
13:58:21 <m3ga> i actually thing deepseq is right and array is wrong
13:59:25 <chipdude> ok, it's a path forward, thanks
14:00:03 * chipdude does look forward to it getting sorted out so I'm not followed by a steady stream of petitioners
14:01:48 <mekeor> i can't find the definition of a list anywhere… i mean like ‘data List a = …‘.  actually, my original goal was/is to find the non-sugar version of ‘[a]’. ideas?
14:02:14 <Saizan> there no non-sugar version of [a]
14:02:30 <mekeor> why not, Saizan?
14:02:48 <mekeor> @faq
14:02:49 <lambdabot> The answer is: Yes! Haskell can do that.
14:02:53 <elliott> data [a] = [] | a : [a]
14:02:58 <Saizan> because they designed it like that :)
14:03:00 <Saizan> @src []
14:03:01 <lambdabot> data [] a = [] | a : [a]
14:03:10 <illissius> Saizan: oh? I thought the problem was some package depending on array < 0.4...
14:03:14 <elliott> The fact that that is not valid syntax is entirely a property of the fact that syntax is specially reserved for lists.
14:03:27 <elliott> I think GHC actually defines it like that, because ghc-prim is allowed to use reserved syntax like that.
14:03:37 <Saizan> ^^^ except the above is not valid haskell code
14:03:43 <Saizan> illissius: yes, deepseq, afaiu
14:04:06 <mekeor> alright. there's no non-sugar version of [a]. okay... okay, okay, okay! okay.
14:04:36 <illissius> Saizan: it's alright according to Hackage: http://hackage.haskell.org/package/deepseq
14:04:37 <Saizan> illissius: but the problem actually is that there are two different "versions" of deepseq with the same version number
14:05:04 <illissius> or is it wrong in the version shipped with GHC? but if cabal is wanting to reinstall it it's going to look at the Hackage version I think... ?
14:05:04 <chipdude> the Rule of Pretense applies
14:05:19 <chipdude> different things that pretend to be the same thing will, eventually, have to be distinguished.  <- pain
14:05:54 <Saizan> chipdude: what version of deepseq is shipped with your ghc?
14:06:23 <chipdude> deepseq-1.3.0.0 in system
14:06:33 <chipdude> ghc-7.4.1-1 debian package
14:06:39 <illissius> yeah, 7.4.1 comes with 1.3.0.0
14:06:56 <chipdude> then 7.4.1's 1.3.0.0 isn't the same as hackage's 1.3.0.0, quite?
14:07:05 <chipdude> at least in metadata
14:07:25 <illissius> the problem *I* had was that I tried to install category-extras which depended on packages which depended on array < 0.4, and then cabal tried to reinstall deepseq to depend on 0.3.0.3 which resulted in the error
14:07:31 <Saizan> chipdude: the bug you linked is about deepseq-1.2.0.1
14:07:43 <chipdude> Saizan: ah.  thanks, won't repeat that
14:07:44 <illissius> but I don't know if that's the same problem people who are trying to install yesod are having
14:08:15 <Saizan> chipdude: the thing about two different deepseqs with the same number might not be true then
14:08:25 <chipdude> cabal, after a fresh "update", is quite sure that deepseq-1.3.0.0 simply cannot use array-0.4.0.0, even though both are installed in system
14:08:55 <chipdude> so it installs array-0.3, then tries to recompile deepseq-1.3.0.0 for no helpful reason, and that fails
14:09:42 <Saizan> chipdude: doesn't make sense though
14:09:50 <illissius> chipdude: check that neither the package you're trying to install nor any of its transitive dependencies has a constraint on array which rules out 0.4.0.0
14:10:08 <nand`> presenting, the horrible fizzbuzz type constructor: http://hpaste.org/57433
14:10:17 <chipdude> illissius: ooh, that's a clue
14:10:19 <elliott> Hey mekeor, did you know there's no non-sugar version of [a]?
14:10:52 <illissius> chipdude: (again, that seems like it was the problem in my case)
14:11:07 <Saizan> chipdude: as i said above --dry-run -v should help in figuring out that
14:11:39 <chipdude> Saizan: you'd think so, but --dry-run -v doesn't tell me which of the many dependencies is forcing the array downgrade
14:11:47 <jedai> johnsingleton: Ok, (.:) didn't have the type I thought, so here is a better version (should maybe probably works) http://hpaste.org/57434
14:11:57 <illissius> chipdude: it does
14:12:02 <chipdude> ?
14:12:18 <illissius> it says at some point discarding array [and then which versions]
14:12:28 <Saizan> chipdude: it should tell which is the first package that excludes array-4.0.0.0
14:12:35 <Saizan> chipdude: can you paste it?
14:13:22 <illissius> oh, hm, I'm not sure if you can tell which package. in my case I just took the list of packages it said it wanted to install at the end, and then tried cabal install --dry-run --verbose on each of them in order... :)
14:13:26 <chipdude> https://gist.github.com/1741002
14:13:34 <chipdude> ^ if the output is telling me, I can't see where
14:13:55 <chipdude> but one at a time, yes, that might be instructive.  will try tht
14:13:55 <illissius> (maybe that was unnecessary, but in any case it worked)
14:14:10 <chipdude> deepse is a red herring, in any case.  thanks for the leads
14:14:14 <chipdude> *deepseq
14:14:41 <illissius> chipdude: are you sure you're using --verbose?
14:14:54 <illissius> it's supposed to dump a bunch of information after "Resolving dependencies..."
14:15:06 <chipdude> I used -v.  not a synonym?
14:15:09 <illissius> dunno :)
14:15:27 <Saizan> it used to print more
14:15:32 <chipdude> verbosity is variable.  let's try -v3
14:16:02 <chipdude> hehe, that's more like it.  I'll troll through this textwall, and see what I can find
14:16:14 <illissius> Saizan: oh, might my cabal-install being rather old be causing the difference?
14:16:58 <chipdude> this is curious.
14:17:06 <chipdude> "selecting Cabal-1.12.0 (hackage) and discarding Cabal-1.8.0.2, 1.8.0.4, 1.8.0.6, 1.10.0.0, 1.10.1.0, 1.10.2.0 and array-0.4.0.0"
14:18:35 <chipdude> yup.  Cabal-1.12.0   Dependencies: ... array >=0.1 && <0.4
14:18:56 <elliott> chipdude: Are you using darcs cabal?
14:18:58 <illissius> wait, what? not according to hackage: http://hackage.haskell.org/package/Cabal-1.12.0
14:18:59 <elliott> It works great with 7.4.
14:19:15 <elliott> I don't know why people are rushing to patch the .cabal file of an old version.
14:19:24 <elliott> Oh, wait.
14:19:29 <elliott> Sorry, ignore me -- that's cabal-install, not Cabal.
14:19:47 <elliott> (Can we please try and be *more* confusing about those names?)
14:19:50 <jedai> johnsingleton: Does it work for you now ? I now have a working version (though I didn't handle the field likedBy, byUserId and inReplyTo, but that shouldn't be too hard to add)
14:20:23 <chipdude> elliott: I'm using the Debian cabal-install.
14:20:23 <chipdude> ii  cabal-install               0.10.2-3                    command-line interface for Cabal and Hackage
14:20:29 <elliott> chipdude: With GHC 7.4?
14:20:31 <elliott> That sounds unwise.
14:20:50 <chipdude> I'm starting to agree.
14:20:50 <elliott> If you darcs get the repo, it's just a ./bootstrap.sh away from a latest cabal-install that works with 7.4.
14:20:54 <jedai> johnsingleton: If you come back around here, my working version is at http://hpaste.org/57437
14:20:57 <elliott> I would suggest purging all your distro stuff.
14:21:37 <Saizan> illissius: it's behind a flag, maybe that's why hackage doesn't print it?
14:21:55 <chipdude> There will be joy in Mudville.  For mature language ecosystems distro packaging is sometimes more trouble than it's worth; I see this is an example.
14:21:56 <illissius> oh, possible
14:22:18 <Saizan> chipdude: anyhow, now you should figure out why it's picking Cabal-1.12 rather than 1.14 :)
14:22:29 <illissius> because yesod's depending on it
14:22:59 <illissius> (does Hackage list dependencies shallowly or transitively?)
14:23:18 <Saizan> (the former)
14:23:31 <chipdude> Cabal-1.14 simply doesn't appear as a possibility in the --verbose=3 output.
14:23:46 <chipdude> so it never 'excludes' it
14:23:56 <Saizan> i assume that's the version you have installed though
14:24:08 * hackagebot scotty 0.2.0 - Haskell web framework inspired by Ruby's Sinatra, using WAI and Warp  http://hackage.haskell.org/package/scotty-0.2.0 (AndrewFarmer)
14:24:08 <illissius> http://hackage.haskell.org/package/yesod Cabal (≥1.8 & <1.13), says right there
14:24:09 <Saizan> but yeah, yesod is depending on < 1.13
14:24:17 <elliott> chipdude: It's funny how terribly traditional package managers serve developers.
14:24:47 <chipdude> Debian has a motivated packager for Haskell, I have no complaints per se, but the impedance mismatch is awful.
14:24:47 <illissius> is it wrong to use an old cabal-install with a new GHC? i seem to recall hearing that it's not
14:25:00 <elliott> It's more of a fundamental mismatch than bad packagers IMO.
14:25:07 <chipdude> yes
14:25:12 <elliott> Something like Nix gets a lot closer.
14:26:24 <chipdude> Ah, now this is interesting.  cabal info Cabal shows that 1.14.0 is actually installed.
14:26:38 <illissius> presumably it came with ghc
14:26:41 <chipdude> yes
14:27:12 <illissius> but if yesod says it can't use that then it doesn't really matter
14:27:38 <chipdude> feh
14:27:45 <darrint> Is is possible to construct a NominalDiffTime that represents 4 hours in the past?
14:27:56 <chipdude> so it's yesod that needs surgery.
14:27:56 <illissius> so what needs to happen is someone needs to ask yesod's maintainer to bump the dependenc(y|ies)
14:28:34 <Clint> they're probably bumped in git already
14:28:35 <Clint> but not released
14:29:31 <chipdude> Seems so.  "cabal-version:   >= 1.6" https://github.com/yesodweb/yesod/blob/master/yesod/yesod.cabal
14:30:36 <illissius> I think that's different. it's the version of cabal required for installing the package (every package has this)
14:30:37 <elliott> Hm?
14:30:41 <elliott> Nothing's wrong with that.
14:31:09 <elliott> illissius: I believe a NominalDiffTime represents a time delta, whereas "4 hours in the past" is an absolute time.
14:31:10 <illissius> whereas yesod explicitly has Cabal as a dependency because it's using it for something or other
14:31:36 <illissius> chipdude: you want the build-depends: field
14:31:41 <chipdude> then
14:31:44 <chipdude> how about this: https://github.com/yesodweb/yesod/commit/95200463c6ea353c78355ddbe16ecbb69628597b#yesod/yesod.cabal
14:31:57 <illissius> elliott: not sure who you meant, but I don't think it was me
14:32:08 <chipdude> this removed Cabal version from build-depends
14:32:16 <nand`> will we ever get an OS written in haskell?
14:32:33 <nand`> probably with a bootstrapper + small kernel in assembly
14:32:51 <illissius> chipdude: that looks relevant. :)
14:32:51 <mekeor> nand`: afaik, there's a OS written in haskell...
14:32:54 <chipdude> k
14:32:56 <mekeor> just google it...
14:32:58 <CodeWeaverX> heh  wierd, i was thinking of that earlier today, nand
14:33:09 <mekeor> nand`: yep
14:33:28 <mekeor> @quote CodeWeaverX
14:33:28 <lambdabot> No quotes match. Listen, broccoli brains, I don't have time to listen to this trash.
14:33:30 <mekeor> @quote CodeWeaver
14:33:30 <lambdabot> CodeWeaver says: keep in mind encryption's only as good as how much you trust that the implementors got it right.
14:33:34 <mekeor> hehe
14:33:57 <nand`> that's a good one
14:34:01 <CodeWeaverX> heehee
14:34:12 <Eduard_Munteanu> nand`: see House
14:34:14 <chipdude> rot13 is good, but I do it twice to be sure
14:34:15 <Eduard_Munteanu> @where house
14:34:15 <lambdabot> http://programatica.cs.pdx.edu/House/
14:34:48 <mekeor> i've got an other question.... WHY THE HELL does cabal depend on unix<2.5 ??
14:35:38 <chipdude> mekeor: <2.6 presently, but ... yeah, why
14:36:12 <mekeor> chipdude: is there a work-around?
14:36:42 <mekeor> chipdude: 2.6? really?
14:36:46 <jedai> johnsingleton: If you come back around here, my working version is at http://hpaste.org/57437
14:37:20 <HWJohn> Can someone tell me how to run a Haskell file on Linux?
14:37:26 <HWJohn> I have the .hs file ready, but it won't run
14:37:50 <jedai> HWJohn: We'll need more details, what do you mean "it won't run" ?
14:37:50 <mekeor> chipdude: you said "presently"... but i just did "cabal update" and "cabal info cabal-install" still shows "unix<2.5" as a dependency...
14:37:54 <donri> HWJohn: runhaskell File
14:38:15 <HWJohn> do I do it in ghci or straight from Terminal?
14:38:16 <Eduard_Munteanu> HWJohn: or you could compile it to an executable
14:38:34 <mekeor> donri: please let noobs (like me) answer nooby questions such that they have a chance to help others, too ;)
14:38:46 <mekeor> HWJohn: from terminal
14:39:19 <donri> I will allow it.
14:39:19 <mekeor> HWJohn: there's also runghc, btw... (idk the difference)
14:39:24 <mekeor> donri: hehe
14:39:41 <HWJohn> It says "Not in scope: Main"
14:39:53 <jedai> @tell johnsingleton If you come back around here, my working version is at http://hpaste.org/57437
14:39:53 <lambdabot> Consider it noted.
14:39:53 <mekeor> HWJohn: you need a main-function
14:40:05 <monochrom> I agree with needing more details. tell what you tried, verbatim. post the file, verbatim
14:40:19 <mekeor> HWJohn: you can also start an interpreter. like "ghci myhaskellfile.hs" and then call your functions from the terminal.
14:40:22 <monochrom> and all output, verbatim
14:40:27 <mekeor> HWJohn: that's probably what you are looking for
14:40:29 <jedai> mekeor: it run ghc, whereas runhaskell could run hugs (or jhc or uhc)
14:40:48 <mekeor> jedai: that's what i assumed.. yep. alright :)
14:41:06 <elliott> illissius: sorry
14:41:09 <elliott> darrint: <elliott> illissius: I believe a NominalDiffTime represents a time delta, whereas "4 hours in the past" is an absolute time.
14:41:38 <HWJohn> I typed ghci syntax.hs
14:41:44 <elliott> nand`: Not only is there a Haskell OS, there's, like, four.
14:41:45 <HWJohn> now it says
14:41:47 <jedai> HWJohn: if you need to paste you code, use hpaste.org
14:41:59 <HWJohn> it's three lines only
14:42:10 <HWJohn> I actually just started learning today
14:42:14 <jedai> HWJohn: error message are fine (
14:42:47 <HWJohn> "Ok, modules loaded: Main
14:43:02 <HWJohn> now I'm prompted with *Main>
14:43:17 <mekeor> HWJohn: cool! just call your function than
14:43:22 <jedai> HWJohn: congratulation, you can now use anything you defined in your file
14:43:26 <hey_lu> jedai: That's pretty awesome (parse tweets efficiently in about 5 lines... :)
14:43:45 <mekeor> HWJohn: we've got an interpreter-bot in here, too, btw:
14:43:49 <mekeor> > 2+12*123
14:43:50 <lambdabot>   1478
14:44:07 <mekeor> > scanl1 (+) [1..]
14:44:09 <lambdabot>   [1,3,6,10,15,21,28,36,45,55,66,78,91,105,120,136,153,171,190,210,231,253,27...
14:44:15 <HWJohn> I got it working now
14:44:19 <HWJohn> Thank you
14:44:28 * mekeor is lucky.
14:44:35 <CodeWeaverX> > let fib@(_:fibt) = 0:1:zipWith (+) fib fibt in take 20 fib
14:44:36 <lambdabot>   [0,1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181]
14:44:40 <CodeWeaverX> teehee
14:44:53 <CodeWeaverX> Simple things amuse me
14:47:13 <ddarius> > deriv (\x -> x^2 + 1) 0
14:47:14 <lambdabot>   0
14:47:17 <ddarius> > deriv (\x -> x^2 + 1) 2
14:47:19 <lambdabot>   4
14:47:57 <jedai> hey_lu: Well once you understand what you're doing, you can parse JSON pretty concisely with aeson
14:47:58 <mekeor> @src deriv
14:47:58 <lambdabot> Source not found. Take a stress pill and think things over.
14:48:45 <mekeor> ddarius: deriv?
14:48:48 <mekeor> @hoogle deriv
14:48:49 <jedai> hey_lu: And it's a library that got a lot of attention on its performance (use the most recent techniques like builders, attoparsec and so on
14:48:49 <lambdabot> package derivation-trees
14:48:49 <lambdabot> package derive
14:48:49 <lambdabot> package derive-gadt
14:49:33 <hey_lu> jedai: well, i actually wrote a function for '(.: "here") =<< o .: "text"' and I still need to unserstand it
14:49:54 <darrint> Basically I'm trying to express that time t must be newer than at least 4 hours ago. I can't figure out how to do that with Data.Time.
14:50:05 <hey_lu> jedai: by the way, is there something like aeson for xml? :)
14:50:48 <elliott> mekeor: see numbers package
14:52:24 <hey_lu> understand
14:52:38 <acts_as_david> i've struggled for about an hour to install hmatrix on OS X lion. anyone have experience with this?
14:52:43 <smop> the joy of haskell on windows
14:52:51 <mekeor> elliott: ah, okay
14:53:38 <acts_as_david> the C compiler isn't properly linking to GSL dylibs
14:53:42 <jedai> hey_lu: I don't think so (well there are facilities to parse XML but not to your own data type (though you could probably put together something)
14:54:08 * hackagebot corebot-bliki 0.1 - A bliki written using yesod. Uses pandoc to process files stored in git.  http://hackage.haskell.org/package/corebot-bliki-0.1 (CoreyOConnor)
14:54:10 * hackagebot numeric-quest 0.1.1.3 - Math and quantum mechanics  http://hackage.haskell.org/package/numeric-quest-0.1.1.3 (HenningThielemann)
14:55:26 <jedai> smop: it's better than it was in the past though (or maybe I just have more experience with it)
14:56:22 <smop> i could only imagine
14:56:33 <acts_as_david> in general, should hackage packages be installed as 32-bit on lion?
14:57:29 <CodeWeaverX> These days the 64 bit version of haskell on lion seems to be doing pretty well.   But in any event, the compiler and packages have to match.  Which they should if you build them.
14:57:35 <jedai> smop: what's your current problem ?
14:57:46 <CodeWeaverX> 64 bit of ghc I mean.
14:58:06 <smop> nothing in general
14:58:07 <acts_as_david> hm okay
14:58:26 <jedai> hey_lu: You can look http://www.yesodweb.com/book/xml-enumerator for one approach to xml in Haskell (there are many others)
14:58:33 <acts_as_david> ghc --arch
14:58:37 <acts_as_david> oops wrong window. how to i figure out ghc's arch
14:58:40 <CodeWeaverX> The 32 bit works as well.  Choose your poison.  You *might* run into things that only work in 32 bit, but they're slowly getting rarer.'
14:59:24 <CodeWeaverX> acts:  Didn't you install the ghc yourself?
14:59:30 <acts_as_david> this was via homebrew
14:59:36 <CodeWeaverX> Ah
14:59:39 <acts_as_david> brew install haskell-platform
14:59:56 <acts_as_david> with GSL/liblas/etc. also installed using homebrew
14:59:57 <hey_lu> jedai: thanks! (i was going to ask you...)
15:00:16 <CodeWeaverX> ghc - - info (put the two dashes together)
15:00:42 <CodeWeaverX> The target platform should say x86_64
15:01:06 <acts_as_david> ah okay. i get this: ,("C compiler flags","[\"-march=i686\",\"-m32\",\"-fno-stack-protector\"]") ,("Gcc Linker flags","[\"-march=i686\",\"-m32\"]") ,("Ld Linker flags","[\"-arch\",\"i386\"]")
15:01:19 <acts_as_david> looks like the linker and compiler flags aren't matching?
15:01:49 <CodeWeaverX> That's a bit weird.
15:02:01 <acts_as_david> agreed
15:02:15 <CodeWeaverX> I'm not sure how that happened.  Hopefully someone here has some insight.
15:02:36 <CodeWeaverX> Mine has 64 bit in the various linker and compiler fields where it matters.
15:02:45 <acts_as_david> how did you install?
15:03:14 <CodeWeaverX> I've installed both via the 64 bit pkg installer, and most recently by the bindist (by doing a ./configure with appropriate parameters and a make install)
15:03:22 <CodeWeaverX> I reinstalled at one point
15:03:53 <acts_as_david> ah okay
15:04:07 <acts_as_david> thanks, i'll try that
15:04:29 <CodeWeaverX> :)  I got help getting 7.4.1 installed, so if you run into trouble, come find me, maybe I can pass on advice.
15:04:51 <CodeWeaverX> But I have to move locations, offline for a short bit.
15:04:53 <CodeWeaverX> brb
15:09:08 * hackagebot file-location 0.4.3 - common functions that show file location information  http://hackage.haskell.org/package/file-location-0.4.3 (GregWeber)
15:11:28 <acts_as_david> CodeWeaverX: okay, thanks
15:19:03 <CodeWeaverX> Mmm beer.
15:19:06 <CodeWeaverX> And haskell.
15:22:36 <nand`> @pl \i -> (f i 3, f i 5)
15:22:36 <lambdabot> ap ((,) . flip f 3) (flip f 5)
15:23:07 <nand`> :t (&&&)
15:23:08 <lambdabot> forall (a :: * -> * -> *) b c c'. (Arrow a) => a b c -> a b c' -> a b (c, c')
15:24:08 <nand`> :t ($3) &&& ($5)
15:24:09 <lambdabot> forall a b. (Num a) => (a -> b) -> (b, b)
15:25:28 <eyu100_> > 1
15:25:28 <lambdabot>   1
15:37:53 <tgeeky> > (maxBound :: Int) - (minBound :: Int)
15:37:54 <lambdabot>   -1
15:38:14 <CodeWeaverX> heh.
15:38:16 <CodeWeaverX> Integer rollover?
15:38:26 <CodeWeaverX> Two's complement overflow.
15:39:07 <ddarius> > 2 * (maxBound :: Int) + 1
15:39:08 <lambdabot>   -1
15:39:36 <CodeWeaverX> > (maxBound::Int) - (minBound::Int) + 1
15:39:37 <lambdabot>   0
15:39:44 <CodeWeaverX> surprise == False
15:41:38 <mekeor> > (fromIntegral (maxBound :: Int)) * 2 + 1 :: Integer
15:41:39 <lambdabot>   18446744073709551615
15:42:26 <CodeWeaverX> "Space is big.  Really BIG.  You might think it's a long walk down to the chemist's, but that's just *peanuts* to Space!" — Douglas Adams
15:45:21 <mekeor> @src print
15:45:22 <lambdabot> print x = putStrLn (show x)
15:46:05 <Jafet> "The above quote is from the guy who invented the infinite improbability drive." — Jafet
15:46:17 <ddarius> Space isn't that big.
15:46:31 <elliott> "Space isn't that big." — ddarius
15:48:33 <mekeor> @remember ddarius Space isn't that big.
15:48:34 <lambdabot> Good to know.
15:49:09 * hackagebot corebot-bliki 0.2 - A bliki written using yesod. Uses pandoc to process files stored in git.  http://hackage.haskell.org/package/corebot-bliki-0.2 (CoreyOConnor)
15:51:06 <eyebloom> Is there any way to allow a type to remain ambiguous?
15:51:56 <monochrom> what does that mean? what is the X problem?
15:51:59 <sipa> eyebloom: how do you mean?
15:52:04 <sipa> :t length
15:52:05 <lambdabot> forall a. [a] -> Int
15:52:11 <sipa> length never knows what a is
15:53:25 <eyebloom> I'm writing a type checker that generates a type for higher order syntax
15:53:36 <eyebloom> err infers a type.
15:53:54 <ddarius> @google beluga weirich
15:53:57 <lambdabot> http://www.cis.upenn.edu/~byorgey/papers/binders-unbound.pdf
15:53:57 <monochrom> design a representation for type variables
15:53:57 <lambdabot> Title: Binders Unbound
15:54:25 <nand`> FizzMaster 3000, C++ edition: http://hpaste.org/57442
15:55:21 <eyebloom> I've done that. But the problem is my original syntax is still type safe in Haskell.
15:55:51 <eyebloom> But in order to use containers for example, I have give them an arbitrary type.
15:56:53 <Jafet> (forall a. [a]) is the valid type of a container of arbitrary type in Haskell
15:58:25 <eyebloom> I'll try universal quantification. That seems right.
15:58:33 <CodeWeaverX> I really have to get a handle on using the forall keyword.
15:59:09 * hackagebot exists 0.1 - Existential datatypes holding evidence of constraints  http://hackage.haskell.org/package/exists-0.1 (GaborLehel)
16:00:54 <elliott> hehe, here comes the flood of constraint kinds packagse
16:00:55 <elliott> packages
16:01:03 <eyebloom> CodeWeaverX: me too.
16:01:36 <tkahn6> isn't universal quantification assumed?
16:01:44 <tkahn6> what is gained by adding that?
16:02:01 <CodeWeaverX> There are situations where you can use it to control existential qualification, for one.
16:02:14 <tkahn6> what does that gain you?
16:03:20 <CodeWeaverX> The ability to design an interface which will accept objects conforming to a specific class without knowing the real class.  ie ad-hoc polymorphism like you might find in OOP.  Just for one example.
16:03:26 <CodeWeaverX> Honestly I"m not sure of all of the consequences.
16:03:34 <Eduard_Munteanu> Isn't the extension that provides forall merely aesthetic, for proofs or such? :/
16:03:53 <CodeWeaverX> no, it *can* serve a useful purpose.
16:04:06 <Eduard_Munteanu> I mean, you still need to turn something else on for existentials, or scoped type variables or rank-2/n types.
16:04:24 <tkahn6> CodeWeaverX can you give a concrete example? i'm trying to understand how that get's you ad-hoc polymorphism
16:04:39 <CodeWeaverX> Trying to find a web link.  Moment.
16:04:43 <tkahn6> thanks
16:04:46 <elliott> CodeWeaverX: Sounds like the existential typeclass antipattern to me.
16:04:55 <illissius> Eduard_Munteanu: afaik yes. ExplicitForall iirc.
16:04:59 <tkahn6> elliott: why because OOP is an antipattern?
16:05:02 <tkahn6> :p
16:05:04 <Eduard_Munteanu> tkahn6: http://www.haskell.org/haskellwiki/Existential_type#Dynamic_dispatch_mechanism_of_OOP
16:05:11 <tkahn6> Eduard_Munteanu thanks
16:05:18 <CodeWeaverX> Also:  http://en.wikibooks.org/wiki/Haskell/Existentially_quantified_types
16:05:25 <CodeWeaverX> Check out the 'heterogenous lists' area.
16:05:29 <tkahn6> CodeWeaverX thanks
16:05:39 <elliott> Eduard_Munteanu: a prime demonstration of the antipattern.
16:05:41 <Veinor> if i upgrade from 7.2 to 7.4.1, what do i need to blow away in terms of cabal?
16:05:42 <elliott> unfortunately without any disclaimer.
16:05:47 <Eduard_Munteanu> :)
16:05:49 <elliott> Veinor: everything, I think
16:05:53 <Veinor> aw
16:05:58 <CodeWeaverX> Not that I recommend using existentials all the time, but sometimes they're a good solution.
16:07:50 <tkahn6> @where RTS-xc
16:07:50 <lambdabot> ghc --make -prof -auto-all -rtsopts -osuf .p_o foo.hs && ./foo +RTS -xc
16:15:22 <Veinor> what's the -osuf for?
16:16:09 <monochrom> "*.o's suffix"
16:16:21 <Veinor> i guess the question is, why does it need to be specified?
16:16:42 <otters> is #yesod active at all?
16:16:48 <monochrom> so that foo.o is not overwritten, and foo.p_o is used instead
16:17:45 <monochrom> however, I wonder what happens to foo.hi
16:18:01 <erus`> has anyone got a shell with the new ghc on it? :3 i wanna try it out
16:18:24 <ddarius> There are p_hi files.
16:19:10 * hackagebot inflist 0.0.1 - An infinite list type and operations thereon.  http://hackage.haskell.org/package/inflist-0.0.1 (JamesFisher)
16:20:07 <monochrom> then it should add -hisuf .p_hi too
16:21:06 <CodeWeaverX> I have electrical power!  w00t!
16:22:58 <monochrom> "By the power of Grayskull... I have electrical power"?
16:23:39 <Veinor> infinite list type? but... we already have that
16:23:41 <CodeWeaverX> *snort* *cough* *hack* MY BEER
16:23:41 <Veinor> it's called []
16:24:04 <blackdog> Veinor: it looks like a reimplementation of streams
16:24:09 <Veinor> oh it's a type that only contains infinite lists
16:24:15 <blackdog> ie, this list is definitely infinite
16:24:30 <Jafet> It doesn't have to be infinite
16:24:35 <Jafet> It could be bottom
16:24:40 <Veinor> :|
16:24:56 <monochrom> use exception-catching to detect end of list :)
16:25:18 <Jafet> While singing "a spoonful of sugar"
16:25:55 <CodeWeaverX> "A spoon full of sugar helps the bottom-evaluation go dowwwwwwn"
16:27:32 <erus`> has anyone experimented with forcing provably terminating functions in haskell?
16:27:49 <erus`> like agda
16:29:08 <ddarius> erus`: You can always provide bottom for any value.
16:29:55 <ddarius> You could make a value that, if defined, is a total function.
16:49:10 * hackagebot hdaemonize 0.4.4.1 - Library to handle the details of writing daemons for UNIX  http://hackage.haskell.org/package/hdaemonize-0.4.4.1 (FrederickRoss)
17:12:51 <nyingen> @quote
17:12:52 <lambdabot> blip says: im just kidnapping
17:12:55 <nyingen> @quote
17:12:56 <lambdabot> Pseudonym says: If Hofstadter had said this, it would have been much funnier.
17:14:51 <nyingen> @quote
17:14:51 <lambdabot> douglas-adams says: I love deadlines, I especially like the swooshing sound they make as they fly past
17:15:15 <CodeWeaverX> Nice.
17:38:04 <nyingen> @quote
17:38:04 <lambdabot> paczesiowa says: my friends (evil, imperative and objectionable) from university laugh at me that I love haskell and I wont find any job as haskell programmer. I get sad when I start to believe them.
17:38:05 <lambdabot>  but then I look at some java code and I'm all happy again
17:39:17 <nyingen> my sentiments exactly
17:39:30 <nyingen> java is a horrible, horrible language
17:39:39 <CodeWeaverX> *cough* heh
17:41:08 <otters> it's nice to know that no matter what language you use, java is always worse
17:41:43 <CodeWeaverX> You do realize of course, that java programmers are just saying the same thing about… well, probably not Haskell because they probably don't know about it… but you get the point.
17:41:56 <otters> yeah but we're right
17:41:57 <otters> and they're wrong
17:42:06 <CodeWeaverX> *cough* Once again, you do realize of course...
17:42:16 <otters> I was being facetious
17:42:18 <CodeWeaverX> :d
17:42:18 <otters> :3
17:42:19 <CodeWeaverX> :D
17:42:21 <CodeWeaverX> heehee
17:43:37 <cmccann> otters, no, php is even worse
17:43:43 <otters> yeah, that's the outlier
17:43:44 <nyingen> @quote java
17:43:45 <lambdabot> Jafet says: Javascript is pretty much a DSL for making your web browser take up more CPU
17:43:47 <nyingen> @quote java
17:43:47 <lambdabot> lennart says: I would rather lose my left arm than write it in Java
17:43:51 <nyingen> @quote java
17:43:51 <lambdabot> mwc says: I can only believe that Java is a conspiracy perpetrated by keyboard manufacturers
17:44:43 <nyingen> steve yegge: Java is like a variant of the game of Tetris in which none of the pieces can fill gaps created by the other pieces, so all you can do is pile them up endlessly.
17:44:58 <nyingen> I would add that but I don't remember how
17:45:20 <otters> well it's in my memory forever
17:45:22 <otters> so maybe it doesn't matter
17:46:02 <nyingen> also: if you begin with the assumption that you need to shrink your code base, you will eventually be forced to conclude that you cannot continue to use Java.
17:46:21 <nyingen> do people actually try to shrink their code bases though?
17:46:41 <nyingen> "Hey, this project has 250,000 LOC. These can't all be necessary!"
17:47:05 <nyingen> (disclaimer: I sporadically work on a 250,000 LOC java project, and it appears to be a total mess)
17:47:13 <CodeWeaverX> *snort*
17:47:24 <nyingen> 250,000 LOC sounds like a lot, except when you realize it's Java
17:48:18 <otters> private abstract class AuthenticationProviderManagerFactoryFactory extends GenericProviderManagerFactoryFactory
17:48:20 <otters> {
17:48:51 <Saizan> let's get back to Haskell :)
17:49:55 <nyingen> Maybe we can compromise on Jaskell
17:50:09 <derpladee> isn't it called Hava?
17:50:09 <otters> how would that work
17:50:25 <ion> Suckskell
17:50:34 <otters> no we're being subtle
17:51:12 <Veinor> o'haskell
17:52:22 <Veinor> 'man my /new on reddit is full of haskell!'
17:52:26 <Veinor> 'oh. i went to /r/haskell'
17:54:44 <Eduard_Munteanu> nyingen: I don't think it's shrinking per se, perhaps removing deprecated / unmaintained features.
17:55:14 <nyingen> our 'code base' is full of shit like '/* this is probably dead code, but i'm afraid to remove it */'
17:55:46 <Eduard_Munteanu> nyingen: heh, does "I'm afraid to remove it" mean "I don't use source code management"? :)
17:56:13 <nyingen> if(blah == null) { /* this case is supposed to be impossible, but I had to add this because it somehow keeps happening */
17:56:17 <Eduard_Munteanu> Ah.
17:56:20 <Veinor> ... oh nice
17:56:38 <Veinor> TIL that if you export EXTRA_CONFIGURE_OPTS="-p" when you bootstrap cabal, it installs the profiling
17:56:40 <Eduard_Munteanu> I'd rather assert it then, in some cases.
17:57:16 <jedai> nyingen: I like that code !!
17:57:30 <jedai> *comment
17:59:14 <nyingen> yeah, I find it kind of funny myself, as long as Eclipse is not open
18:02:13 <edwardk> nyingen: thats the opposite of ours. is this in use? i dunno. lets remove it and find out. ;)
18:03:17 <mike-burns> I delete code so long as I can get away with it.
18:03:21 <edwardk> helps to have a decent test suite though so you know that its still doing what it should
18:03:30 <erus`> ghc takes forever to build
18:03:42 <mike-burns> forever $ build_ghc
18:03:42 <otters> yessirree
18:03:43 <edwardk> strong enough types can serve as a decent proxy for that in a pinch though
18:04:06 <mike-burns> Erm, useless ($) in there. Bah.
18:11:46 <Eduard_Munteanu> erus`: I used to think that too, but then I tried building the atlas BLAS :P
18:20:10 <nyingen> @quote
18:20:10 <lambdabot> NathanielSBorenstein says:  It should be noted that no ethically-trained software engineer would ever consent to write a DestroyBaghdad procedure. Basic professional ethics would instead require him
18:20:10 <lambdabot> to write a DestroyCity procedure, to which Baghdad could be given as a parameter.
18:23:52 <CodeWeaverX> Darn it, I keep closing #haskell when I'm not paying attention.
18:23:58 <CodeWeaverX> Quick, someone say something interesting.
18:23:59 <CodeWeaverX> :D
18:25:30 <hiptobecubic> CodeWeaverX, duck typing is the future of computer science.
18:25:44 <CodeWeaverX> Er… quack.
18:26:24 <CodeWeaverX> :D
18:27:03 <CodeWeaverX> Also I looked up duck typing, and …. oy.
18:28:55 <hiptobecubic> CodeWeaverX, :D haha. You wanted something interesting.
18:29:09 <CodeWeaverX> Remind me never to ask that of the chatroom again. :D
18:29:30 <hiptobecubic> CodeWeaverX, it's the ultimate type safety! There IS no wrong type!
18:29:59 <erus`> 63 mins to build ghc
18:30:07 <hiptobecubic> erus`, new record
18:30:19 <erus`> i think it crashed out too
18:30:35 <hiptobecubic> Well that's not new.
18:31:11 <hiptobecubic> Alright, I've made enough constructive contributions here. I'm off to bed.
18:34:29 <parcs`> erus`: by default ghc gets built with optimization, profiling, dynamic libraries, etc..
18:34:53 <parcs`> erus`: if you want a fast build you can change the settings with mk/build.mk
18:35:02 <parcs`> in*
18:35:10 <erus`> i only have 2 gig ram and virtual cpu
18:35:46 <parcs`> vm?
18:35:55 <erus`> yeah
18:36:18 <erus`> can i get the binaries for arch anywhere?
18:36:28 <erus`> pacman is out of date now
18:37:24 <parcs`> i actually have made a binary for arch myself
18:37:34 <parcs`> there is no official one thought
18:38:02 <parcs`> are you on x86_64?
18:38:04 <erus`> theres one on the ghc site
18:38:24 <erus`> wow windows too
18:38:38 <erus`> will the platform libraries still work?
18:38:40 <parcs`> the generic binary on haskell.org doesn't work on arch because of gmp version mismatch
18:38:51 <parcs`> no
18:38:52 <erus`> ah bummer
18:39:03 <erus`> parcs`: yeah _64
18:39:13 <erus`> have you hosted yours online anywhere?
18:39:24 <parcs`> no, want me to?
18:42:51 <erus`> oh yes please
18:49:04 <parcs`> http://www.mediafire.com/?4a5ae50omjq0j6c
18:52:21 <tryhaskeller> "Hi"
18:52:41 <erus`> parcs`: thanks
18:55:27 <Veinor> edwardk: thanks for patching semigroupoids :)
18:57:35 <dstcruz> I'm trying to follow along on the "write yourself a scheme" tutorial, and I am trying to parse numbers with a radix.
18:58:15 <dstcruz> I have https://gist.github.com/1742525 so far, but my parser does not seem to like "#b1101", and complains that I need to have a 'd' after the '#'
18:58:31 <dstcruz> line 52 is where my woes begin
18:58:45 <dstcruz> can someone help me unstuck?
18:59:44 <Veinor> sure, give me a bit
19:01:02 <Veinor> ah
19:01:18 <Veinor> you need the <|> parseBinary to be on the same line as parseDecimal
19:02:17 <Veinor> because right now it's parsing it as do {char '#'; parseDecimal} <|> parseBinary
19:02:19 <dstcruz> darn it, that worked. I'm a bit confused.
19:02:36 <dstcruz> oh, IC
19:02:53 <strager> Down with 'do'!  =]
19:03:02 <Veinor> the hell, hint isn't building
19:03:17 <dstcruz> the other parsers that make use of the <|> are not in a do block :( that's why is differen!
19:03:49 <dstcruz> thanks Veinor
19:04:10 <Veinor> no problem :)
19:04:14 * hackagebot corebot-bliki 0.2.2.0 - A bliki written using yesod. Uses pandoc to process files stored in git.  http://hackage.haskell.org/package/corebot-bliki-0.2.2.0 (CoreyOConnor)
19:06:50 <dstcruz> hmmm…. is there a way to put those in different lines?
19:07:26 <Veinor> i think if you indent the <|> more
19:10:07 <dstcruz> that works. weird. maybe I need to stick with the do {;;;} notation
19:10:31 <Veinor> i'd advise against it
19:10:49 <Veinor> the do {;;} notation is mostly intended for machine-generation, iirc
19:11:05 <Veinor> (and using in places like ghci and \bot ;) )
19:11:21 <parcs`> dstcruz: instead of do { foo; bar } you can use foo *> bar
19:11:43 <parcs`> so parseRadixNumber can become char '#' *> (parseDecimal <|> parseBinary)
19:12:03 <Veinor> @undo do {foo; bar}
19:12:03 <lambdabot> foo >> bar
19:12:11 <Veinor> why not >>?
19:15:15 <parcs`> no real reason
19:15:23 <parcs`> well, actually
19:15:37 <parcs`> *> is "symmetric" to <*
19:15:55 <parcs`> and there is no monad analogue to <*
19:16:47 <Veinor> ah, interesting
19:16:55 <parcs`> well, no predefined one anyway. so a *> b <* c looks better than a >> b <* c
19:16:59 <ion> There shouldn’t be a separate >> in the first place.
19:17:34 <Veinor> parcs`: that looks like 'hey, b is really awesome!'
19:17:48 <Veinor> which, i guess it is, since it's the only one whose value we care about
19:18:03 <parcs`> and i imagine the precedence of *> is usually better when using other applicative combinators
19:18:56 <Clint> ion: separate from what?
19:19:28 * mgsloan recently write a case statement like this: (s :< r') -> (l |>) *** (<| r) 
19:21:28 <ion> clint: The Applicative equivalent.
19:21:42 <Clint> ah
19:24:56 <nyingen> I've never understood <* and *>
19:25:05 <nyingen> that part of RWH confused me
19:26:17 <otters> looks like it's just >> for functors
19:26:25 <otters> and then what would be <<
19:26:33 <ion> > pure (\a b -> (a,b)) <*> [0..2] <*> [10..12]
19:26:34 <lambdabot>   [(0,10),(0,11),(0,12),(1,10),(1,11),(1,12),(2,10),(2,11),(2,12)]
19:26:39 <ion> > pure (\a b -> a) <*> [0..2] <*> [10..12]
19:26:40 <lambdabot>   [0,0,0,1,1,1,2,2,2]
19:26:43 <ion> > pure (\a b -> b) <*> [0..2] <*> [10..12]
19:26:44 <lambdabot>   [10,11,12,10,11,12,10,11,12]
19:26:45 <nyingen> and what's the difference between <*> and <$>
19:26:47 <otters> > pure 2
19:26:48 <nyingen> in practical terms?
19:26:48 <lambdabot>   No instance for (GHC.Show.Show (f t))
19:26:48 <lambdabot>    arising from a use of `M5393380331...
19:26:51 <ion> > [0..2] <* [10..12]
19:26:52 <lambdabot>   [0,0,0,1,1,1,2,2,2]
19:26:56 <ion> > [0..2] *>* [10..12]
19:26:57 <lambdabot>   Not in scope: `*>*'
19:26:59 <ion> > [0..2] *> [10..12]
19:27:00 <lambdabot>   [10,11,12,10,11,12,10,11,12]
19:27:06 <nyingen> interesting
19:27:12 <otters> nyingen: <$> takes (a -> b), <*> takes f (a -> b)
19:27:32 <nyingen> @type (<$>)
19:27:33 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
19:27:37 <nyingen> ah, so it does
19:27:41 <otters> tbh I don't know why you'd ever need to use <*>
19:28:13 <parcs`> (+) <$> Just 5 <*> Just 10
19:28:17 <parcs`> > (+) <$> Just 5 <*> Just 10
19:28:18 <lambdabot>   Just 15
19:28:21 <parcs`> > (+) <$> Just 5 <*> Nothing
19:28:22 <lambdabot>   Nothing
19:28:24 <nyingen> hmm
19:28:25 <otters> oh
19:28:26 <edwardk>  nyingen: <*, unlike << has the 'effects' from left to right
19:28:38 <edwardk> >> and *> should do the same thing
19:28:39 <otters> okay so it's for partial application purposes
19:28:40 <otters> makes sense
19:28:51 <edwardk> except that *> has the same fixity as <*>
19:28:57 <ion> otters: Well, for instance.
19:29:04 <parcs`> not ethat f <$> x === pure f <*> x
19:29:08 <parcs`> note that*
19:29:20 <otters> :t pure
19:29:21 <lambdabot> forall a (f :: * -> *). (Applicative f) => a -> f a
19:29:27 <otters> so pure is return for functors
19:29:32 <edwardk> which permits nice little tricks like exprL0 = leftParen *> expr <* rightParen | ..
19:29:48 <parcs`> otters: return is like pure for monads :P
19:29:53 <edwardk> which lets you ignore the answers from parsers, etc which are obviously irrelevant
19:29:59 <edwardk> and which you are running for just their effects
19:30:42 <edwardk> pure is return for a slightly weaker thing. Monads are effectively slightly more powerful Applicatives
19:30:56 <edwardk> note the types for <*>
19:31:23 <edwardk> f (a -> b) -> f a -> f b -- you can more or less manipulate the values carried by the computation, but you can't choose a completely different computation based on that value
19:31:40 <edwardk> whereas with >>=     f a -> (a -> f b) -> f b --- you can PICK what to do next
19:32:13 <edwardk> Applicatives are 'about' carrying around those annotations, but not necessarily about being able to change the 'shape' of the computation you are doing based on previous answers
19:33:35 * ddarius thinks the lax monoidal functor perspective makes it much clearer what the extent of Applicative's power is.
19:33:47 <edwardk> in grammar terms applicatives, if you ignore the infinities which make lie of the statement, intuitively applicatives let you play with 'context-free' computation, while monads allow you context sensitivity
19:33:51 <otters> I know what all of those words are individually
19:33:52 <ion> the laxative monoidal functor
19:34:14 * hackagebot vector-fftw 0.1.2 - A binding to the fftw library for one-dimensional vectors.  http://hackage.haskell.org/package/vector-fftw-0.1.2 (JudahJacobson)
19:34:32 <otters> man
19:34:37 <otters> how often do people really need to work with vectors
19:34:51 <otters> a lot
19:34:52 <monochrom> depends on which people
19:34:58 <edwardk> depends
19:35:00 <otters> the average person
19:35:16 <ddarius> otters: The average person is not a programmer, so probably never.
19:35:18 <monochrom> sure, the average person doesn't need it
19:35:20 <edwardk> i despise the average person ;)
19:35:23 <otters> right
19:35:28 <ion> I’ve never met the average person.
19:36:15 <edwardk> just keep in mind how dumb the average person is, and then remember that half of them are not even that intelligent
19:36:17 <otters> damn you, yesod
19:36:56 <ddarius> I think 100% of average people are just as intelligent as the average person.
19:37:00 <drdo> Is it possible to get GHC to tell me from where an exception is being thrown?
19:37:11 <ByronJohnson> drdo: Yes
19:37:19 <ByronJohnson> drdo: Typically, you :set -fbreak-on-exception
19:37:36 <ByronJohnson> drdo: Then you :trace main, or whatever else you want to examine the history of
19:37:43 <ByronJohnson> drdo: And then :hist
19:38:02 <monochrom> the problem with the average person is that, because advanced society is so keen on specialization and division of labour, every expertise is only used by like 0.1% of the population, so you can make the case that the average person doesn't need that expertise
19:38:08 <ByronJohnson> drdo: GHCI's debugging functionality is more completely documneted at http://www.haskell.org/ghc/docs/latest/html/users_guide/ghci-debugger.html
19:38:15 <drdo> Thank you
19:38:42 <monochrom> yet you would be wrong to deduce that the average person needs no expertise at all
19:39:56 * ddarius deduces that the average person needs 100.5% of an ovary, and 98% of a testicle.
19:40:23 <otters> same thing
19:40:25 <ion> or that divided by two
19:40:29 <ByronJohnson> u'i
19:40:45 <ion> oh, i misread
19:41:10 <edwardk> monochrom++
19:41:40 <edwardk> ion: he only said ~one each
19:41:57 <ion> Yes, that was what i misread.
19:42:45 <dev360> Hey, Im new to haskell, I just split up my single file program into a directory/package structure. How do I compile everything to a binary and tell the program where the main entry is?
19:42:50 <otters> and a ~2.4 inch penis
19:43:20 <edwardk> dev360: cabal
19:43:24 <ion> otters: You don’t need to tell the program where that is.
19:43:27 <ByronJohnson> dev360: You'd use cabal
19:43:35 <ByronJohnson> dev360: http://www.haskell.org/cabal/users-guide/
19:43:49 <dev360> edwardk: I created a cabal file too. What command do I run?
19:43:56 <edwardk> dev360: i use cabal for pretty much everything i write in haskell that exceeds one file, and many of the things that still fit in one
19:43:59 <edwardk> cabal install
19:44:10 <ByronJohnson> dev360: cabal configure, cabal build, and then cabal install
19:44:19 <ByronJohnson> dev360: Although you really should read up on the documentation
19:44:26 <ByronJohnson> dev360: (cabal help is useful too)
19:44:28 <edwardk> for most practical projects, cabal install will do everything you need
19:44:56 <edwardk> by the time you need any of the others you'll probably also know why ;)
19:46:37 <dev360> edwark & ByronJohnson - thanks that helped - looked like I had everything setup correctly
19:47:31 <edwardk> dev360: impressive =)
19:49:33 <dev360> edwardk: How can I see the exact version of a cabal installed dependency?
19:49:54 <ByronJohnson> dev360: ghc-pkg list should show which packages are registered
19:50:12 <ByronJohnson> dev360: ghc-pkg list | grep -i bytestring, for example
19:51:46 <dev360> ByronJohnson - awesome thank you
19:55:59 <nyingen> @quote
19:56:00 <lambdabot> bremner says: the "web scale" language's web site doesn't load in my web browser. I think that pretty much sums up how I knew I wasn't going to like it.
19:56:22 <otters> my cat is such a slut
19:57:54 <nyingen> @quote
19:57:54 <lambdabot> Plugin `quote' failed with: getRandItem: empty list
19:57:56 <nyingen> @quote
19:57:56 <lambdabot> Plugin `quote' failed with: getRandItem: empty list
19:57:58 <nyingen> @quote
19:57:58 <lambdabot> djanatyn says: I started out trying to figure out how to mess with xmonad, and fell in love with Haskell's syntax.
19:58:21 <ddarius> otters: Most cats are.
20:02:10 <Bacta> Does learning about Monads make me a homosexual?
20:03:23 <nyingen> @quote
20:03:24 <lambdabot> Plugin `quote' failed with: getRandItem: empty list
20:03:26 <nyingen> @quote
20:03:26 <lambdabot> mmorrow says: [regarding excessive use of categorical recursion schemes] a morphasm?
20:03:38 <nyingen> @quote c++
20:03:38 <lambdabot> Enigmagic says: we use the 'rsync' deploy model
20:03:48 <otters> @quote php
20:03:48 <lambdabot> fr30n says: <fr30n> php? eso es para vrutos
20:03:51 <strager> Bacta: Does learning affect your sexual orientation?
20:04:00 <nyingen> @quote perl
20:04:01 <lambdabot> qwe1234 says: it's 2006 already, and the world doesn't need 'dynamic languages'. otherwise, we'd be all programming in perl.
20:04:19 <otters> @quote php
20:04:19 <lambdabot> qwe1234 says: i'm still waiting for the list of differences between lisp and php that matter.
20:04:54 <nyingen> ouch
20:05:07 <nyingen> @protontorpedo
20:05:07 <lambdabot> what does haskell do better than java perl or ruby?
20:05:21 <smop> lol
20:05:41 <Bacta> Nothing
20:06:08 <strager> It's better at being terse =]
20:06:32 <nyingen> @protontorpedo
20:06:32 <lambdabot> does haskel work one windows?
20:06:40 <otters> @protontorpedo
20:06:41 <lambdabot> cmon Im asking cool questions
20:06:44 <otters> what's the point of this
20:07:04 <Bacta> Does learning about Monads make me a homosexual?
20:07:06 <ivanm> otters: IIRC, it's a collection of sayings of some interesting people
20:07:09 <otters> oh, I see
20:07:10 <ivanm> @help protontorpedo
20:07:10 <lambdabot> protontorpedo is silly
20:07:39 <ivanm> Bacta: why would it?
20:07:49 <ivanm> Bacta: because you are *definitely* not a troll...
20:08:08 <nyingen> I originally thought '@protontorpedo' was a metaphor for trolling the haskell channel
20:08:16 <ivanm> heh
20:08:17 <nyingen> turns out it was an actual user who actually posted these questions
20:08:32 <otters> that's one user?
20:08:37 <nyingen> so I heard
20:08:46 <otters> sweet jeezus
20:09:32 <Bacta> Where can I download Microsoft Silverlight?
20:09:38 <ClaudiusMaximus> http://hackage.haskell.org/packages/archive/Cabal/1.14.0/doc/html/Distribution-TestSuite.html mentions "The packages cabal-test-hunit, cabal-test-quickcheck1, and cabal-test-quickcheck2 provide simple interfaces to these popular test frameworks."    But where can I get them?
20:09:54 <monochrom> ivanm, how do you know?
20:10:02 <ivanm> @nixon
20:10:02 <lambdabot> You know, it's a funny thing, every one of the bastards that are out for legalizing marijuana is Jewish. What the Christ is the matter with the Jews, Bob? What is the matter with them? I suppose it
20:10:03 <lambdabot> is because most of them are psychiatrists.
20:10:12 <otters> what
20:10:25 <nyingen> ah, old tricky dick
20:10:36 <nyingen> @nixon
20:10:36 <lambdabot> People react to fear, not love; they don't teach that in Sunday School, but it's true.
20:10:57 <ByronJohnson> ClaudiusMaximus: Usually, haskell packages are downloaded from Hackage via cabal-install.  cabal install package-name  should instaltl it.
20:11:03 <ivanm> monochrom: know what?
20:11:08 <Bacta> Where can I download Microsoft Silverlight?
20:11:18 <monochrom> that who is or is not a troll
20:11:39 <otters> I used to feel guilty about possibly banning people that weren't actually trolls
20:11:44 <ivanm> Bacta: www.apple.com
20:11:45 <otters> then I lost my sense of empathy
20:11:51 <Veinor> haha
20:12:07 <ClaudiusMaximus> ByronJohnson: i know; but they appear not to be on hackage unless i'm looking wrong
20:13:36 <ivanm> ClaudiusMaximus: just hunit, quickcheck (versions 1 and 2), etc.
20:13:47 <ivanm> I think the "Cabal-test-" bit refers to the new test integration in Cabal
20:14:50 <Bacta> Where can I download Low Orbit Ion Cannon?
20:15:16 <ClaudiusMaximus> ivanm: right; that's what i want - i want to try out the shiny (relatively) new test-suite stuff in cabal, and don't feel like writing boilerplate to hook it up to quickcheck or whatever
20:16:07 <Bacta> Where can I download Microsoft Silverlight?
20:18:26 <ivanm> monochrom: how would you classify him as then?
20:18:33 <edwardk> bacta: i almost suggested you go hunting for an abandonware site ;)
20:18:48 <monochrom> ban candidate
20:18:52 * ivanm grumbles about his internet connection suddenly going dodgy as he fires up IRC
20:18:53 <edwardk> yep
20:19:35 <startling> are there any command-line interface libraries for haskell in the vein of but ideally more advanced than ncurses?
20:20:35 <ivanm> startling: as in console-based UI? just ncurses bindings I think
20:20:43 <startling> that's it? darn.
20:21:15 <ivanm> ansi-terminal ?
20:21:16 <ClaudiusMaximus> @hackage vty-ui
20:21:16 <lambdabot> http://hackage.haskell.org/package/vty-ui
20:21:24 <ivanm> ClaudiusMaximus: oh, forgot about vty
20:21:32 <ivanm> that still uses C bindings though, right?
20:21:41 <ByronJohnson> startling: I see a few packages listed in http://www.google.co.uk/search?hl=en&as_sitesearch=hackage.haskell.org/package&as_q=curses
20:21:49 <ByronJohnson> hscurses, nanocurses, etc.
20:22:00 <ByronJohnson> I've never used any of them, though.
20:22:06 <ivanm> ByronJohnson: I don't think he wants curses stuff though
20:22:08 <ClaudiusMaximus> ivanm: no clue
20:22:11 <nus> startling, Manatee (suggested only if you grok Chinglish)
20:22:17 <ivanm> nus: that's GUI
20:22:23 <ivanm> as in GTK based
20:23:04 <nus> ivanm, I supposed it covers all bases by now given his productivity, untrue (-:
20:23:12 <ivanm> heh
20:23:41 <startling> vty looks good. thanks!
20:34:09 <nyingen> @quote
20:34:10 <lambdabot> Catfish_Man says: Well, at a first approximation Haskell is an overpowered DSL for generating Fibonacci numbers.
20:40:19 <lispy> hello
20:42:34 <ivanm> hey lispy
20:42:45 <lispy> As a community, I think we need a public build bot service for checking support with dependencies (GHC version compatibility, hackage package compat, etc)
20:43:00 <ivanm> it's been mooted before
20:43:05 <ivanm> just need someone to write it :p
20:43:12 <lispy> I'm quite happy to donate to such a service, but I don't know how to build it safely.
20:43:18 <ivanm> wasn't someone using some kind of CI on their stuff? tibbe maybe?
20:43:50 <lispy> ivanm: at galois we use hudson/jenkins internally, and I know bos uses the same thing. tibbe may as well
20:44:04 <ivanm> oh, might have been bos rather than tibbe
20:44:39 <lispy> ivanm: I think the trick is to do it in a trusted way.  It would be terrible to have the machine compromised.  What does hackage do before buliding things?
20:44:49 <lispy> s/trusted/trustable/
20:44:51 <ivanm> nfi
20:45:07 <ivanm> not sure if it sandboxes them or anything
20:46:02 <lispy> Unlike hackage you'd want to allow people to test things *before* they are released
20:46:33 <lispy> So it's hard to delegate to hackage for the trust bit
20:47:09 <lispy> And using a separate VM for every package seems a bit ham fisted
20:48:42 <ivanm> lispy: I was thinking more creating one on the fly every time it needed to test something
20:48:50 <ivanm> or else run it within a sandboxing application
20:48:52 <ivanm> e.g. sydbox
20:49:09 <ivanm> just in case someone tries to have a virus or something that runs at build time... >_>
20:53:34 <lispy> hudson + sydbox...
20:53:46 <lispy> That would actually go a fair ways towards being safe
21:15:47 <jmillikin> quick bug report: the <title> for http://www.haskell.org/ghc/download_ghc_7_4_1 is "DOwnload version 7.2.2"
21:15:53 <jmillikin> *Download
21:18:37 <ivanm> jmillikin: saying that in #ghc would probably be better
21:18:58 <jmillikin> ivanm: ah, sorry, I didn't realize ghc had it's own channel. thanks
21:19:04 <ivanm> np
21:24:45 <argiopeweb> I'm compiling with -threaded -prof -auto-all -caf-all and running with +RTS -p -hc -N2. After completion of ~2 minutes of running, the resulting heap trace from both hp2ps and hp2pretty are less than 3 seconds long. Is it possible that my main which does nothing but spawn 3 threads is the reason for this?
21:25:24 <ivanm> argiopeweb: dunno, but it sure sounds weird
21:25:45 <ivanm> how long does it run for with no profiling (not even profiling support when compiling) ?
21:25:50 <ivanm> and are you profiling with optimisations?
21:25:54 <argiopeweb> ivanm: Indeed. The fact that the profiles are correct is even more odd.
21:27:06 <argiopeweb> -02, and it's a server type of deal so I forked my main thread of control instead of letting it take over main and put a threadDelay to exit the program after 2 minutes.
21:56:51 <nus> "Note that multi-processor execution (e.g. +RTS -N2) is not supported while profiling."
21:58:07 <ivanm> nus: that could explain it...
21:58:22 <nus> argiopeweb, which ghc version is that?
21:59:43 <ClaudiusMaximus> ghc 7.4 say It is now possible to use profiling when running on multiple capabilities (i.e. when running with +RTS -N). There is a new built-in cost centre called IDLE, which records the ticks of idle capabilities.
22:13:29 <void> Hi guys
22:15:22 <void> I have trouble connecting to #agda channel. It tells something like "cannot send to channel" for unknown reason. It looks like some kind of intellect test I don't pass at all :)
22:16:09 <Axman6> are you registered?
22:16:20 <disgrntld> Does anyone know where I can find the factory metaphor for monads that is referenced from this (http://en.wikibooks.org/wiki/Haskell/Understanding_arrows) page? "...we shall present arrows from the perspective of stream processors, using the factory metaphor from the monads module as a support."
22:16:41 <void> Yep, that's what google told me, but I have no idea of how to register in freenode
22:16:52 <johnsingleton> how might I rewrite the following do-notation based block to applicative? I can't quite seem to figure it out: http://hpaste.org/57454
22:16:52 <lambdabot> johnsingleton: You have 1 new message. '/msg lambdabot @messages' to read it.
22:16:53 <Axman6> /msg nickserv help
22:17:04 <void> Oh, thanks a lot
22:17:29 <disgrntld> ..the page linked didn't have a factory diagram or seem to convey the metaphor at all.
22:26:24 <johnsingleton> jedai: You still around? I think I got this badboy working ;)
22:33:28 <mzero> johnsingleton:  I think if you change line 17 to    ((o .: "linked_by") >>= (.: "count")) <*>     it will work  -- Note the extra parens
22:34:20 * hackagebot oi 0.0.4 - Purely Functional Lazy Interaction with the outer world  http://hackage.haskell.org/package/oi-0.0.4 (NobuoYamashita)
22:38:36 * Sgeo blinks at OI
22:39:50 <nus> disgrntld, check the previous versions of the monads page
22:40:40 <mjrosenb> :t .:
22:40:41 <lambdabot> parse error on input `.:'
22:40:41 <disgrntld> awesome, thanks nus
22:40:46 <mjrosenb> :t (.:)
22:40:47 <lambdabot> forall a b (f :: * -> *) (g :: * -> *). (Functor f, Functor g) => (a -> b) -> f (g a) -> f (g b)
22:41:28 <mjrosenb> so it is (fmap . fmap)
22:43:29 <Sgeo> o.O at conal
22:43:54 <conal> Sgeo: hi
22:46:30 <disgrntld> bah, didn't find it
22:49:20 * hackagebot wai 1.1.0 - Web Application Interface.  http://hackage.haskell.org/package/wai-1.1.0 (MichaelSnoyman)
22:49:23 * hackagebot wai-app-static 1.1.0 - WAI application for static serving  http://hackage.haskell.org/package/wai-app-static-1.1.0 (MichaelSnoyman)
22:49:24 * hackagebot wai-eventsource 1.1.0 - WAI support for server-sent events  http://hackage.haskell.org/package/wai-eventsource-1.1.0 (MichaelSnoyman)
22:49:34 <johnsingleton> mzero: Yes, that worked!
22:49:38 <johnsingleton> mzero: Thanks!
22:51:10 <nus> disgrntld, http://users.info.unicaen.fr/~karczma/matrs/Fuprog/Haskell/CoursTutoriels/Print_version.htm
22:54:26 * hackagebot wai-extra 1.1.0 - Provides some basic WAI handlers and middleware.  http://hackage.haskell.org/package/wai-extra-1.1.0 (MichaelSnoyman)
22:54:28 * hackagebot wai-frontend-monadcgi 1.1.0 - Run CGI apps on WAI.  http://hackage.haskell.org/package/wai-frontend-monadcgi-1.1.0 (MichaelSnoyman)
22:54:30 * hackagebot wai-handler-devel 1.1.0 - WAI server that automatically reloads code after modification.  http://hackage.haskell.org/package/wai-handler-devel-1.1.0 (MichaelSnoyman)
22:54:32 * hackagebot wai-handler-fastcgi 1.1.0 - Wai handler to fastcgi  http://hackage.haskell.org/package/wai-handler-fastcgi-1.1.0 (MichaelSnoyman)
22:54:35 * hackagebot wai-handler-launch 1.1.0 - Launch a web app in the default browser.  http://hackage.haskell.org/package/wai-handler-launch-1.1.0 (MichaelSnoyman)
22:54:55 <ivanm> why isn't Snoyman here?
22:55:06 <MostAwesomeDude> Welp, looks like I'd better go figure out how to use the new Yesod stuff.
22:59:36 * hackagebot wai-handler-scgi 1.1.0 - Wai handler to SCGI  http://hackage.haskell.org/package/wai-handler-scgi-1.1.0 (MichaelSnoyman)
22:59:38 * hackagebot wai-test 1.1.0 - Unit test framework (built on HUnit) for WAI applications.  http://hackage.haskell.org/package/wai-test-1.1.0 (MichaelSnoyman)
22:59:40 * hackagebot wai-websockets 1.1.0 - Provide a bridge betweeen WAI and the websockets package.  http://hackage.haskell.org/package/wai-websockets-1.1.0 (MichaelSnoyman)
22:59:42 * hackagebot warp 1.1.0 - A fast, light-weight web server for WAI applications.  http://hackage.haskell.org/package/warp-1.1.0 (MichaelSnoyman)
22:59:44 * hackagebot warp-static 1.1.0 - Static file server based on Warp and wai-app-static  http://hackage.haskell.org/package/warp-static-1.1.0 (MichaelSnoyman)
23:04:46 * hackagebot warp-tls 1.1.0 - SSL support for Warp via the TLS package  http://hackage.haskell.org/package/warp-tls-1.1.0 (MichaelSnoyman)
23:31:47 <lukish_> How can I convert Int to Float?
23:31:55 <lukish_> @hoogle Int -> Float
23:31:56 <lambdabot> Prelude (!!) :: [a] -> Int -> a
23:31:56 <lambdabot> Data.List (!!) :: [a] -> Int -> a
23:31:56 <lambdabot> Data.Sequence index :: Seq a -> Int -> a
23:32:55 <companion_cube> > (fromIntegral (42 :: Int)) :: Float
23:32:56 <lambdabot>   42.0
23:36:05 <mjrosenb> wow, that sure looks like @hoogle not being useful.
23:37:09 <ddarius> mjrosenb: At least it hadn't gotten to unsafeCoerce yet.
23:37:26 <arcatan> if you look at the web results, it's the fifth answer
23:38:33 <MichaelBurge> How safe is the Haskell SDL package for writing games? It was last updated May 2010
23:38:55 <MichaelBurge> I haven't had any problems using it, and it seems to work fine; but I don't know if that's just because SDL isn't updated often, and the package works
23:39:00 <MichaelBurge> or if I just got lucky
23:39:01 <btvl> how am I supposed to handle this : http://hpaste.org/57458
23:39:12 <btvl> I tried specifying the type then compiler whines about needing some pragma
23:39:18 <btvl> adding the pragma produces another error
23:39:36 <btvl> does the error come from the fact that the functions in the list could be of distinct types ?
23:42:08 <btvl> if that is the case the only solution that I can see is manually unrolling the list and performing tons of tests
23:42:30 <arcatan> MichaelBurge: there was a new SDL release less than month ago, but the one before that occured in 2009, I think
23:43:48 <mjrosenb> btvl: what are teh types of withStat and vIsBlockDevice et al?
23:44:00 <btvl> it all comes from http://hackage.haskell.org/packages/archive/MissingH/1.0.0/doc/html/System-IO-HVFS.html
23:45:59 <yitz> btvl: what pragma and what is the new error?
23:46:15 <btvl> let me check
23:46:59 <Blkt> good morning everyone
23:47:29 <btvl> ah it seems that my pragma statement isn't used by the compiler
23:47:33 <btvl> my bad
23:47:41 <btvl> it would be nice to understand the problem though
23:47:59 <btvl> ok new error
23:48:25 <btvl> http://hpaste.org/57459
23:49:07 <btvl> I start believing I am doing it wrong when it asks me to add flag after flag
23:49:18 <ddarius> withStat s (\s' -> map s' funcs) may work.
23:49:37 <btvl> ah
23:50:45 <disgrntld> was afk, thanks nus!
23:51:09 <btvl> http://hpaste.org/57460
23:51:20 <btvl> no luck either
23:51:37 <ddarius> Yeah, lambda bound variables need to be monomorphic.
23:56:01 <btvl> so, does the original error comes from the fact that the functions in the list are polymorphic and not declared as being of the same type ?
23:56:23 <ddarius> No.
23:58:07 <btvl> ok .. then I have no clue on what to do about it
23:58:13 <btvl> I will just unroll it by hand
23:59:01 <ClaudiusMaximus> i'm having trouble adding {-# SPECIALIZE instance ... #-} pragmas using {-# LANGUAGE CPP #-}  -- i get a syntax error at the second inserted pragma
23:59:04 <ClaudiusMaximus> any ideas?
23:59:08 <ddarius> res = case s of HVFSStatEncap x -> map ($ x) funcs
23:59:38 <ClaudiusMaximus> is it even possible to have more than one specialized instance?
23:59:46 <ddarius> Sure it is.
