00:00:06 <shachaf> "Foldable" just means "has a toList function".
00:00:17 <shachaf> What does that have to do with it?
00:01:07 <Cale> dmwit: We both dug up the same old mailing list post for examples of programs which are incorrect but typecheck if you allow infinite types :)
00:01:45 <Cale> (namely this: http://www.haskell.org/pipermail/haskell-cafe/2006-December/020074.html)
00:02:52 <cbm80_> shachaf: i guess i have to figure out the exact differences between lists and sequences in greater detail
00:03:41 <ChristianS> cbm80_: as long as you're fine with lists, just stick with them
00:04:23 <shachaf> Or: Figure out what you're doing and then figure out what data structure matches it.
00:04:49 <cbm80_> will do, thanks for your thoughts
00:05:08 <Saizan> cbm80_: one big difference even with finite elements is that a list can be produced lazily as it is consumed, while a Sequence can't
00:05:39 <shachaf> Right -- I gave an extreme case of infinite lists, but any sort of laziness is going to behave differently.
00:05:45 <shachaf> Sequences are more or less spine-strict.
00:13:58 <osa1> where can I see source of monad functions(>>= and return) for lists?
00:14:19 <osa1> I couldn't find the module including monad instance of lists
00:14:51 <shachaf> @src [] (>>=)
00:14:52 <lambdabot> xs >>= f     = concatMap f xs
00:14:55 <shachaf> @src [] return
00:14:56 <lambdabot> return x    = [x]
00:16:37 <osa1> thanks
00:25:46 <Guest26576> @src reverse
00:25:47 <lambdabot> reverse = foldl (flip (:)) []
00:25:51 <Guest26576> @src do
00:25:51 <lambdabot> Source not found. :(
00:26:05 <DanBurton> do is not a function
00:26:38 <DanBurton> it is syntactic sugar for stringing chains of >>= together
00:27:03 <ion> > do do do do do do do do do do do do do do do do batman
00:27:04 <lambdabot>   BATMAN
00:27:08 <DanBurton> @undo do x <- foo; y <- bar; baz; return (quux foo bar)
00:27:09 <lambdabot> foo >>= \ x -> bar >>= \ y -> baz >> return (quux foo bar)
00:27:18 <Guest26576> oh
00:27:39 <DanBurton> @slap ion
00:27:39 * lambdabot places her fist firmly on ion's jaw
00:28:46 <shergill> > do superman
00:28:47 <lambdabot>   Not in scope: `superman'
00:34:04 <osa1> when working on ghci, I'm working on an IO monad, right?
00:36:00 <ion> If you type an IO expression, ghci will execute it. If you type a non-IO expression that is showable, ghci will evaluate and show it.
00:37:09 <ion> In case you didn‚Äôt receive this: If you type an IO expression, ghci will execute it. If you type a non-IO expression that is showable, ghci will evaluate and show it.
00:47:02 <eyu100> > fix error
00:47:03 <lambdabot>   "*Exception: *Exception: *Exception: *Exception: *Exception: *Exception: *E...
00:47:23 <Ptival> that didn't fix it :d
01:07:42 <shergill> clearly you wanted > do fix error. :P
01:08:03 <ion> sudo fix error
01:12:34 <shergill> heh
01:29:30 <sohum> @pl \x -> foo x bar
01:29:30 <lambdabot> flip foo bar
01:29:35 <sohum> oh, duh
01:39:06 <t7> @seen rostayob
01:39:06 <lambdabot> Unknown command, try @list
01:39:20 <t7> !seen rostayob
01:39:32 <t7> seen rostayob
01:40:38 <Ptival> preflex: seen rostayob
01:40:39 <preflex>  rostayob was last seen on #haskell 8 hours, 31 minutes and 37 seconds ago, saying: * rostayob goes to bed
01:53:17 <Younder> You know random acess to strings is really  important. I measured it. No wonder your monad approach works better. Apparently the same was discovered in Lisp 20 years ago ;)
01:53:26 <Younder> access
01:54:41 <Ptival> what are you talking about?
01:55:00 <Phlogistique> Younder: you should make a twitter account for that
01:55:08 <Younder> Ptival, strings arrays as opposed to lists
01:55:36 <mux> o_O
01:56:13 <Younder> Sorry, I came about this all wrong.
01:56:35 <Phlogistique> Younder: you want Text, not String
01:56:45 <Younder> But truth remains treating a string as a list is inefficient.
01:58:04 <ChristianS> Younder: you need to modify random chars in a string? that's pretty rare requirement in my experience...
01:58:04 <Ptival> "in most cases"?
01:58:20 <Younder> Phlogistique, I went through a entire book on search algorithms last night.
01:59:16 <Younder> Backtracking is key
02:00:00 <t7> how do i purely functional brainfuck?
02:00:41 <mrcarrot> ChristianS: i have noticed that often you can make many algorithms faster by swapping elemt in their position rather than doing it with normal lists... so it is not that rare. also, unless there is a replace function, replacing means to first search for a value, then again change it by using !!
02:01:22 <mrcarrot> (this from somebody that is still developing his FP skills and have been infected way too much with imperative programming)
02:01:37 <Younder> t7: simple try Purely functional infrastructures. Actually they work fine for things like databases .
02:02:22 <ChristianS> mrcarrot: that's not what i meant. i was talking specifically about strings. there, just modifying some chars in the middle while leaving the rest of the string alone is rarely needed, in my experience.
02:02:33 <Younder> t7: data-structures, sorry for myioverzellous  editor
02:03:55 <t7> someone was talking about typing the Y combinator (i forget where). Is there a type system that allows this?
02:05:03 <Younder> t7: lambda calculus
02:05:39 <t7> thats untyped my friend
02:05:43 <Ptival> :)
02:06:39 <Younder> t7: Simon P. Jones wrote a book on writing functional compilers which you might want read
02:06:40 <Phlogistique> t7: typed lambda calculus, then?
02:06:51 <ChristianS> Younder: if you really need random access to specific chars in a long string, you could try Data.Sequence.Seq Char instead of Text
02:07:11 <Ptival> Phlogistique: you can't express its type
02:07:30 <t7> Phlogistique: .... you cant type the Y combinator in typed lambda calculus
02:07:58 <Younder> t7: you can but it's more tricky
02:08:09 <mux> not in simply typed lambda calculus
02:08:36 <Saizan> you can in haskell, through recursive types
02:08:56 <Younder> t7: http://en.wikipedia.org/wiki/Fixed-point_combinator
02:08:58 <Saizan> or you can if you allow infinite types in something like System F
02:09:17 <Ptival> http://r6.ca/blog/20060919T084800Z.html
02:09:20 <Saizan> Younder: the Y combinator is a specific fixed point combinator
02:09:37 <t7> Younder: different things :|
02:09:42 <Saizan> of course you can just add a fix :: (a -> a) -> a constant to most lambda calculi
02:10:02 <mux> or equivalently to fix, you cna provide a letrec primitive
02:10:08 <Younder> Saizan, the one that allows recursion
02:10:30 <Younder> Saizan, thus essential
02:10:38 <zerax> @where fix
02:10:39 <lambdabot> I know nothing about fix.
02:10:40 <mux> all fixed-point combinators allow recursion
02:10:58 <Younder> mux no
02:11:03 <Saizan> yes.
02:11:33 <Younder> I really should check this
02:11:47 <Saizan> you just need fix f == f (fix f) for general recursion to happen, you don't care how it's implemented
02:13:06 * hackagebot gnuplot 0.5 - 2D and 3D plots using gnuplot  http://hackage.haskell.org/package/gnuplot-0.5 (HenningThielemann)
02:13:07 <Younder> Going with Barendregth, lambda calculus.
02:13:08 * hackagebot utility-ht 0.0.8 - Various small helper functions for Lists, Maybes, Tuples, Functions  http://hackage.haskell.org/package/utility-ht-0.0.8 (HenningThielemann)
02:13:17 <Ptival> Younder: you might be mixing up combinators in general with fixed-point combinators :\
02:13:28 <Younder> Ptival, yes, I have
02:17:58 <Younder> One of the key points of Banderechts book was that Y point combinator
02:18:40 <Younder> Through recursion comes loops, and all the rest...
02:19:15 <rostayob> haskell packages are pretty good at breaking clang builds: http://clang.debian.net/status.php?version=3.0&key=UNDEF_REF
02:21:53 <Younder> rostayob, checked it for Ubuntu?
02:22:03 <rostayob> Younder: mh?
02:22:37 <Younder> rostayob, suppose it will be the same
02:22:53 <rostayob> Younder: there isn't such a thing for ubuntu (clang builds)
02:23:01 <rostayob> debian is trying clang instead of gcc for the first time
02:23:07 <sohum> @pl \x -> x * (min 10 (fromIntegral (length foo)))
02:23:08 <lambdabot> (min 10 (fromIntegral (length foo)) *)
02:23:27 <Younder> rostayob, ubuntu is just a special build of debian
02:24:33 <Younder> rostayob, with a few extras trown in like aptitude and unity
02:24:37 <rostayob> Younder: I know but they haven't tried to build packages with clang yet.
02:38:11 <rostayob> hpc: dmwit points out that the treeToLists functions doesn't work
02:45:45 <jacobian> wow, it's really hard to search for hscolour on google
02:45:53 <jacobian> You get 50 million pages made by hscolour
02:47:05 <imc> :p
02:50:13 <rostayob> jacobian: the first result is the right one, at least for me
02:50:56 <jacobian> Yeah, I was looking for info about utf-8, so it wasn't the vanilla query for hscolour
02:51:03 <jacobian> It's like searching for a needle in a haystack
02:51:46 <hpaste> ‚ÄúTom Bowden‚Äù pasted ‚ÄúrunDFA and NFA‚Äù at http://hpaste.org/64532
02:52:28 <rostayob> that is some creative whitespacing.
02:56:32 <shergill> what the
02:57:51 <srhb> Someone really should fix hpaste so that it either does something about the tabs or tells people to replace them with spaces in a giant, red, menacing font.
02:58:29 <shergill> heh
02:58:44 <mrcarrot> i have vim to mark all bad whitespace as red
02:58:57 <srhb> Well, your Vim won't communicate that to the users of hpaste.
02:59:07 <mrcarrot> nope
03:00:00 <shergill> mrcarrot: now if you had emacs ...
03:00:21 <Guest70890> ∏,¯§∞`∞§¯,∏∏,¯§∞`∞§¯,∏∏HELLO  HELLO  HELLO HELLO∏,¯§∞`∞§¯,∏∏,¯§∞`∞§¯,∏∏
03:01:01 <mrcarrot> shergill: what does your emacs do?
03:06:34 <ion> mrcarrot: Gives you a repetitive stress injury.
03:09:16 <jacobian> ha!
03:11:13 <shergill> mrcarrot: more like what it *can* do. in this specific instance, spam people on irc :P
03:13:02 <srhb> I'm making a small database REPL with HDBC, but I'm in doubt how to handle errors when the connection fails. Should I maybe wrap it in an error and catch it, returning Nothing?
03:13:23 <srhb> wrap it in a Maybe*
03:15:11 <Daneo> Wow .. this looks weird, al this tut-stuff
03:17:30 <rostayob> Daneo: tut-stuff?
03:18:22 <Daneo> tutorial stuff
03:18:26 <rostayob> ah.
03:18:34 <Daneo> First time looking at Haskell
03:18:45 <Daneo> Feels awkward
03:19:07 <srhb> Daneo: You'll be bitten soon enough. :)
03:19:31 <Saizan> it's supposed to be painful, even
03:20:18 <Daneo> It is, what a syntax ..
03:20:47 <srhb> Daneo: Or lack thereof. :-)
03:21:11 <ChristianS> haskell syntax is indeed beautiful in its minimalism, but it need some getting used to
03:25:07 <Daneo> 'some', might be. Feels like it is going to be a bit more than some though
03:25:48 <Daneo> I'm used to the C#, java way .. So :-)
03:26:03 <srhb> Daneo: Then you do get to shave off quite a lot of keypresses. :-)
03:26:10 <srhb> But yes, quite a bit.
03:26:16 <Eduard_Munteanu> Daneo: I don't think syntax is going to be the problem.
03:26:40 <Daneo> It is going to be the reasoning probably
03:26:54 <Eduard_Munteanu> Yeah. Getting used to laziness, purity etc.
03:28:09 <Daneo> As far as I  get it , is that a pure (function?) is supposed to handle input the same way, over and over again, no matter what is provided ?
03:30:14 <srhb> Daneo: That is correct. A pure function will always return the same value given the same parameters
03:30:41 <srhb> conn <- catch (Just `liftM` (connectSqlite3 db)) (\_ -> return Nothing) <-- This is awkward! Can I do better?
03:30:41 <srhb>  
03:31:07 <Daneo> (brb)
03:31:14 <Daneo> Change of classes :-)
03:31:53 <Saizan> srhb: there's try, but that gives you and Either
03:32:28 <srhb> That would work too I guess. I couldn't figure out how to use it. I'll give it another go
03:33:10 <Saizan> econn <- try (connectSqlite3 db)
03:33:38 <srhb> Yeah but I get ambiguous type variables.. Let me mess around a bit.
03:33:42 <Saizan> though you'd probably get an ambiguous type variable error if the context doesn't specify which type of exceptions you want to catch
03:33:48 <srhb> Ah
03:33:59 <Saizan> but you'd have the same problem with your catch code
03:34:11 <srhb> I didn't have a problem with catch, no.
03:34:14 <srhb> It was just ugly. :-)
03:34:28 <Saizan> was it Prelude.catch then?
03:34:32 <srhb> Yes
03:34:36 <Saizan> ah, ok
03:35:01 <Saizan> ?type Control.Exception.try
03:35:02 <lambdabot> forall a e. (GHC.Exception.Exception e) => IO a -> IO (Either e a)
03:35:49 <Saizan> you've to pick something for that 'e' variable and give some annotation or use the value so that type inference understands what you want
03:36:05 <srhb> Yeah. Annoying. I just want to catch everything. I guess the first solution is better after all, even if ugly.
03:36:26 <Saizan> Prelude.catch won't catch everything iirc
03:36:40 <Saizan> anyhow the way to catch everything is to use SomeException as the type for e
03:36:55 <srhb> But type annotations are disgusting. :/
03:37:17 <rostayob> ChristianS: I really wouldn't call Haskell minimalist
03:37:38 <rostayob> expecially GHC Haskell :P
03:37:49 <srhb> The syntax feels very minimalist.
03:37:58 <rostayob> it isn't
03:38:01 <srhb> Compared to all the scaffolding with other languages.
03:38:03 <rostayob> there's a lot of redundancy
03:38:18 <rostayob> e.g. let/where
03:38:27 <rostayob> case and pattern matching
03:38:33 <rostayob> it's a very rich syntax
03:39:01 <Saizan> you could define tryAll :: IO a -> IO (Either SomeException a); tryAll = try to not have to annotate inline
03:39:15 <srhb> Indeed, I was thinking about that.
03:43:07 <srhb> I went with :: IO (Either SqlError Connection). It's the right way I guess. It just feels like I kill a magic pony every time I type annotate. :(
03:43:45 <srhb> A style question: should I name Eithers eSomeVar?
03:43:54 <srhb> And Maybes mSomeVar?
03:44:09 <zhulikas> what does s stand for here?
03:44:14 <zhulikas> I mean, there is read / reads
03:44:19 <zhulikas> I saw some other combinations as well
03:46:32 <srhb> I could venture a guess. It's a plural form because it reads some characters up to what parses as the type
03:46:50 <srhb> > 1 + (fst . head) (reads "41abc")
03:46:52 <lambdabot>   42
03:48:13 <zhulikas> aaa
03:48:15 <zhulikas> I see
03:51:40 <t7> haskell has spoilt me :( i feel lost without repl
03:52:45 <zhulikas> what do you guys think, how many haskellers there might be across the world?
03:53:02 <t7> 30
03:53:06 <mugenken> 42 i guess..
03:53:28 <t7> i forget the number in that "someone gives a shit about haskell" news article
03:53:39 <zhulikas> hehe
03:53:43 <zhulikas> about that java programmer maybe?
03:54:06 <zhulikas> I see IRC as probably the only normal support on Haskell
03:54:15 <zhulikas> and internet is kind of empty
03:54:22 <zhulikas> so my guess would be - 2-3k
03:55:23 <hpaste> srhb pasted ‚ÄúDB REPL‚Äù at http://hpaste.org/64534
03:55:50 <t7> zhulikas: stackoverflow has plenty of haskell folk
03:55:51 <srhb> I was hoping I could get a quick code review on ^ before I continue. Does my main function look sane?
03:57:47 <Daneo> See you later on everyone
03:57:54 <Daneo> I'm sure coming back ;-) :-)
03:58:24 <srhb> Daneo: Bye :)
03:59:24 <Saizan> srhb: looks sane, though dbREPL will probably have to deal with q and "" similarly, no? also you'd probably get a more pleasant repl by using haskeline
03:59:52 <srhb> Saizan: Yes, it would need to, but that would signify disconnecting from the database. but yes, there is code duplication there. Hm.
04:00:41 <srhb> That was my concern too, really, that each of these "states" the repl is in, like dbREPL, requires duplicating "" and "q"
04:01:00 <srhb> Not sure how to get around it.
04:02:04 <Saizan> maybe it'd be clearer once you've the code in front of you
04:02:11 <Saizan> *it'll
04:02:34 <srhb> Maybe. :) For now I only need main and dbREPL, so it's acceptable to duplicate those two lines of code, I guess.
04:03:06 <ChristianS> rostayob: i meant "minimalist" in the sense of "not much to type", not in the sense of few syntactic constructs.
04:03:39 <ChristianS> ocaml has a fewer syntactic constructs (only let, no where) but it's more verbose
04:04:06 <srhb> So Haskell is "terse" :-)
04:04:20 <liyang> Like Perl!
04:04:25 <rostayob> yes, just like perl.
04:04:48 <zomg> I propose adding goatse operator from Perl to Haskell
04:06:28 <Saizan> srhb: a simple way would be reploop k = do cmd <- getLine; case cmd of "q" -> putStrln "Bye!"; "" -> reploop k; _ -> k cmd >> reploop k
04:06:44 <Saizan> srhb: or some variation on that theme
04:07:43 <ChristianS> haskell can indeed look ugly like perl, if you use too many custom-defined infix operators in your programs. don't really like that, i have to say. strings make better function names than combinations of <$%&> etc. in my mind...
04:08:30 <quicksilver> ChristianS: On the other hand, there is a reason we write "x+y*z" and not (add x (multiply y z))
04:08:33 <quicksilver> it's a trade-off.
04:08:35 <zomg> I'll give a cookie to anyone who can come up with a practical usage for ((.)(.))
04:08:47 <Axman6> just stick to the widely understood and used ones, like <*>, <?>, +, -, *
04:09:08 <ChristianS> quicksilver: indeed, i prefer using only those infix ops in the prelude and not much of those defined elsewhere
04:09:16 <Axman6> :t (Prelude.(.) Prelude.(.))
04:09:17 <lambdabot> Not in scope: data constructor `Prelude'
04:09:17 <lambdabot> Not in scope: data constructor `Prelude'
04:09:36 <Axman6> :t ((Prelude..) (Prelude..))
04:09:37 <lambdabot> forall b c a a1. (a1 -> b -> c) -> a1 -> (a -> b) -> a -> c
04:09:37 <quicksilver> once you know what it means "Expr <$> parseExpr" is easier to read than "fmap Expr parseExpr"
04:09:43 <ChristianS> Prelude got the trade-off pretty right, i think
04:11:12 <sohum> hm, though I wouldn't mind "+ x (* y z)"
04:12:05 <liyang> sohum: why not "y z * x +"?
04:12:19 <sohum> concatenative!
04:12:21 <sohum> :P
04:12:22 <ChristianS> quicksilver: maybe, but i think there is too much hidden knowledge in that expression. the name "fmap" gives a better idea about what might be going than the char sequence <$>
04:12:40 <quicksilver> ChristianS: you don't accept that there is a tradeoff?
04:13:10 <quicksilver> of course terser syntax contains fewer clues than more verbose syntax
04:13:31 <quicksilver> however, terseness allows you to express more complex ideas with less cognitive load
04:13:39 <quicksilver> once you are familiar with the notation.
04:13:59 <quicksilver> there is a reason that most developed areas of mathematics have their own notation - it's more efficient to think in a carefully chosen notation.
04:14:25 <quicksilver> some elusive facts/theorems become completely *obvious* with a well-chosen notation.
04:14:28 <quicksilver> it's a complicated trade-off.
04:17:41 <randomclown> (.)(.) = bags of sand
04:18:10 <ChristianS> quicksilver: i accept there is a trade-off but i would use stuff as e.g. defined in Control.Arrow very sparingly, since it leads to unreadable programs
04:18:43 <quicksilver> ChristianS: "unreadable" is subjective and almost meaningless.
04:18:50 <quicksilver> In that example it speaks to the education of the reader.
04:19:01 <quicksilver> Norwegian is unreadable to me, for I do not know norwegian.
04:19:14 <quicksilver> Arrow combinators are unreadable to people who have not taken the time to learn arrow notation.
04:19:48 <quicksilver> "what level of education do I assume about the reader of this piece" is, in general, a tough question
04:19:58 <quicksilver> which people who write textbooks, novels, and computer programs all have to face
04:20:29 <quicksilver> x+y*z is unreadable to people who have not learn arithmetic and our notation for it.
04:21:58 <Saizan> of course there's also notation that's just a bad fit for what one wants to express, but that's another topic
04:23:18 <ChristianS> quicksilver: i said "sparingly", i didn't say i wouldn't use them at all. i'll stick to that.
04:24:37 <jacobian> We should use '+' and '*' sparingly, they're too terse.  we could understand it more easily if it was 'plus' and 'times'
04:25:28 <quicksilver> ChristianS: sure. I don't disagree with your conclusions, I'm just picking holes in the expression of the reasoning you give.
04:25:40 <quicksilver> New notation is like a new language and that has lots of advantages as well as disadvantages
04:25:56 <quicksilver> there is no simple global call on whether it's good or bad.
04:34:24 <t7> let x = 123 in (x :: Int, x :: Double)
04:34:26 <t7> > let x = 123 in (x :: Int, x :: Double)
04:34:27 <lambdabot>   (123,123.0)
04:35:47 <t7> let creates a new instance for x every time time it is referenced
04:43:04 <ChristianS> quicksilver: btw, as far as i know, mathematics never uses sequences of multiple punctuation chars for functions. it either uses a single punctuation char, for the most important functions (+ - * / etc.) or else alphabetic names (sin cos log etc.)
04:43:19 <quicksilver> t7: with the monomorphism off, yes.
04:43:49 <quicksilver> ChristianS: mathematics uses composed and invented symbols. These are the moral equivalent of multiple punctuation chars.
04:44:14 <quicksilver> ChristianS: "circle with a cross in it" "diamond with a wiggly line under it" "blackboard bold inverted greek delta".
04:48:01 <Ptival> Unicode!
04:50:50 <Ptival> ‚ö†coerce
04:52:17 <Younder> actaually to use math in unicode you need special fonts like the ones from zwig
04:53:07 <Younder> I just installed them in order to use MathML
04:53:36 <sopvop> Anyone has a link explaining lenses without too much math?
04:54:18 <Younder> sopvop, simple .. vel = v first / vel sec
04:54:46 <Younder> c is difraction index
04:55:08 <Younder> then c * v first
04:55:35 <Saizan> i think sopvop meant the "functional reference" kind of lenses
04:56:07 <sopvop> Sure I did
04:56:44 <Ptival> http://bugsquash.blogspot.com/2011/11/lenses-in-f.html
04:56:48 <sopvop> Thanks
04:58:30 <Younder> ahh projections
04:58:46 <Ptival> "Lenses are exactly the coalgebras for the costate comonad"
04:59:02 <Saizan> store comonad, please :)
04:59:03 <sopvop> Oh, now I get it.
04:59:08 <sopvop> :)
04:59:21 <Ptival> it's all so simple when you add co-words :D
04:59:43 <Younder> coalgebra for costated comonad then...'
05:00:00 <Younder> co something anyhow
05:00:35 <Younder> Me has just studied Algebra by Lang
05:01:56 <Saizan> that means Lens a b = a -> (b, b -> a), btw
05:02:04 <Saizan> + laws
05:02:47 <Younder> A function that return a projection in function laymans term
05:02:54 <Younder> ?
05:03:22 <Ptival> not only a projection
05:03:32 <quicksilver> not just a projection but also the bit which can reassemble the value
05:03:39 <quicksilver> with the focussed part replaced
05:03:39 <Saizan> it projects out the field and a function that given another value for the field reconstructs the updated original structure
05:03:52 <Ptival> this ^
05:04:18 <Younder> decomposition
05:33:26 * hackagebot agum 2.4 - Unification and Matching in an Abelian Group  http://hackage.haskell.org/package/agum-2.4 (JohnRamsdell)
05:38:26 * hackagebot cmu 1.4 - Unification in a Commutative Monoid  http://hackage.haskell.org/package/cmu-1.4 (JohnRamsdell)
05:44:21 <osager> Hi how can i tell if a string contains a sub string: for example if "hello" contains "ll"
05:44:46 <MagneticDuck> You'd break the string up into chunks...
05:44:57 <osager> thanks but how
05:45:05 <osager> to break a string
05:45:10 <MagneticDuck> Like "hello" -> ["he", "el", "ll", "lo"]
05:45:13 <osager> i mean is there any library function for this
05:45:20 <MagneticDuck> I'm not sure.
05:45:31 <MagneticDuck> It's real easy to make your own, though!
05:45:43 <MagneticDuck> Which is the best thing to do if you're new to Haskell.
05:45:50 <osager> ok
05:45:54 <Phlogistique> osager: isInfix [] [] = false
05:46:03 <Phlogistique> oops
05:46:08 <Phlogistique> isInfix [] [] = true
05:46:12 <MagneticDuck> Ah, forgot about about that one.
05:46:13 <Phlogistique> isInfix s [] = false
05:46:17 <danr> > "ll" `isInfixOf` "hello"
05:46:18 <lambdabot>   True
05:46:31 <Phlogistique> wait, it is already defined
05:46:32 <Phlogistique> K
05:47:25 <MagneticDuck>  BTW, Hoogle is a great place to find functions like this.
05:47:34 <osager> i'm actually doing a programming problem which test if a string is composed of only 3 sub strings
05:47:38 <mjo> osager: The missingH library has `contains` in Data.List.Utils.
05:47:51 <osager> wow thanks mjo
05:48:18 <mjo> Sure thing.
05:48:26 <otters> @src (->) join
05:48:27 <lambdabot> Source not found. The more you drive -- the dumber you get.
05:48:33 <otters> @src (->) >>=
05:48:33 <lambdabot> Source not found. It can only be attributed to human error.
05:48:38 <otters> okay
05:48:46 <hpc> join f x = f x x
05:53:16 <duairc> Is it possible to make Haddock document orphan instances?
06:03:28 * hackagebot cmu 1.5 - Unification in a Commutative Monoid  http://hackage.haskell.org/package/cmu-1.5 (JohnRamsdell)
06:18:54 <hpaste> incoganon pasted ‚ÄúSTM/forkIO confusion‚Äù at http://hpaste.org/64535
06:19:26 <incoganon> Could someone help me understand what I'm misunderstanding here? http://hpaste.org/64535
06:19:32 <incoganon> What I want to do is this:
06:20:33 <incoganon> What I want to do is this: I'd like  main'  to keep forking threads until each worker (as defined by  workers) is up to capacity.
06:20:57 <incoganon> What happens is: main' seemingly fires off a single worker, waits for it to finish, and then launches the next
06:21:09 <incoganon> so clearly I've misunderstood something with regards to STM or forking
06:21:28 <incoganon> sorry about the relatively large size of the code, I think I've reduced it as far as I can
06:21:50 <incoganon> (run.sh is simply a shell script that prints its two first arguments and then sleeps a few seconds)
06:22:54 <incoganon> So the idea is that  the channel at first has one entry for worker, counting with multiplicity given in the workers list. When a task begins, it is taken out of the chan. Whenever a worker finishes its task, it places itself back into the channel.
06:24:02 <fryguybob> incoganon: You compiled with -threaded -rtsopts and ran with +RTS -N... right?
06:24:29 <incoganon> fryguybob: Nope... should I? :P
06:25:04 <fryguybob> incoganon: Yes
06:25:24 <incoganon> oops
06:26:06 <t7> is there a platform function to remove item at index n from list?
06:26:09 <incoganon> damn, taht fixed everything :)
06:26:12 <incoganon> *that
06:26:15 <incoganon> thank you, fryguybob
06:26:26 <incoganon> turns out my understanding was correct afterall then
06:28:02 <fryguybob> @hoogle delete
06:28:04 <lambdabot> Data.HashTable delete :: HashTable key val -> key -> IO ()
06:28:05 <lambdabot> Data.List delete :: Eq a => a -> [a] -> [a]
06:28:05 <lambdabot> Data.List deleteBy :: (a -> a -> Bool) -> a -> [a] -> [a]
06:28:08 <int-e> funny. regardless of the -N option, it seems to spawn 7 clients and no more.
06:28:13 <osager> hi i want to see if word contains of one or more "pi" or "ka" or "chu" with word =~ "(pi|ka|chu)*"
06:28:25 <osager> but it doesnt work
06:28:34 <int-e> ("it" being incoganon's program compiled with -threaded)
06:28:37 <Tom___> hi, anyone here doing visual programming with haskell?
06:28:42 <osager> any hint ?
06:28:51 <magicman> osager: * is zero or more
06:29:14 <osager> thanks magicman
06:29:23 <osager> what is one or more then ?
06:29:25 <fryguybob> int-e: workers = [("A", 2), ("B", 3), ("C", 2)] -- adds to 7
06:29:40 <hpc> :t (=~)
06:29:40 <lambdabot> forall source1 source target. (RegexMaker Regex CompOption ExecOption source, RegexContext Regex source1 target) => source1 -> source -> target
06:29:59 <hpc> > let word = "pikachu" in word =~ "(pi|ka|chu)*"
06:30:00 <lambdabot>   No instance for (Text.Regex.Base.RegexLike.RegexContext
06:30:00 <lambdabot>                    ...
06:30:07 <int-e> fryguybob: right. thanks
06:30:38 <hpc> oh, or what magicman said
06:30:46 <hpc> osager: one or more is +
06:30:52 <osager> ok thanks hpc
06:31:07 <hpc> http://perldoc.perl.org/perlre.html -- far more than you ever wanted to know about regexes
06:31:19 <hpc> albeit in a perly context
06:32:00 <osager> still doesnt work
06:32:21 <hpc> osager: what error do you get?
06:32:22 <osager> "kakaj" =~ .. gives true
06:32:38 <osager> but "kakaj" should give false
06:32:54 <hpc> "KAkaj"
06:32:56 <osager> "(PI)|(KA)|(CHU)+"
06:33:08 <hpc> =~ (pi|KA|chu)
06:33:18 <osager> "kakaj" =~ "(PI)|(KA)|(CHU)+"
06:33:24 <hpc> ah
06:33:26 <osager> should give false
06:34:12 <MagneticDuck> Is there any standard function that returns the element in a list with the highest return value for a function? Searched on Hoogle, but nothing useful popped up!
06:34:46 <MagneticDuck> > (1, "hello") `compare` (2, "apple!")
06:34:46 <lambdabot>   LT
06:34:50 <MagneticDuck> Oh, never mind!
06:35:07 <mux> maximumBy ?
06:35:31 <int-e> > maximumBy (comparing snd) [(1,2),(2,1),(0,3),(4,2)]
06:35:32 <lambdabot>   (0,3)
06:38:14 <hpc> :t maximumBy
06:38:15 <lambdabot> forall a. (a -> a -> Ordering) -> [a] -> a
06:38:19 <osager> does anyone know if "kakaj" =~ "(PI)|(KA)|(CHU)+" is correct ?
06:39:55 <MagneticDuck> @type comparing snd
06:39:56 <lambdabot> forall a b. (Ord b) => (a, b) -> (a, b) -> Ordering
06:41:34 <magicman> osager: That means "match pi, ka, or (chu one or more times)"
06:42:26 <magicman> "kakaj" has "ka", so it's True.
06:42:33 <magicman> I'm not sure what you want here.
06:43:55 <hpaste> i_am_neuron pasted ‚Äúnetwork‚Äù at http://hpaste.org/64537
06:49:42 <i_am_neuron> Hi guys, trying to build a simple echo server in Haskell, got it running (http://hpaste.org/64537), but there's one thing missing. At the moment it reads only one character and then reaches return at line 31. The obvious solution for that would be to add 'forever' on line 23, but this means we're not leaving the loop when we reach EOF (it first reads EOF and then iterates again only to fail with error -- I want to avoid this)
06:49:52 <i_am_neuron> Alternatively, I can replace return on line 31 with a copy of lines 29-31. But how to refer a function to itself here? I checked the Y Combinator implementation for Haskell (it seems to be suitable here) but this seem to be an overkill. Is there any alternative way to implement looping there?
06:51:32 <ski> just make `echo' call itself ?
06:52:38 <Botje> i_am_neuron: you can also check hIsEOF h before you call echoLoop
06:52:44 <i_am_neuron> ski: I want only a part of it to be called. Duplicate lines 29-30 instead of line 31 infinitely
06:53:04 <i_am_neuron> ski: I mean, like duplicating lines infinitely
06:53:58 <i_am_neuron> Botje: Yeah, this could be the solution, I was more wondering if this is possible to do at all
06:54:09 <hpaste> MagneticDuck pasted ‚ÄúMultiline strings‚Äù at http://hpaste.org/64539
06:54:24 <rwbarton> just replace "return" there with an appropriate call to echo
06:54:29 <MagneticDuck> Some help with multiline strings?
06:54:34 <rwbarton> what's the problem?
06:54:34 <ski> (it's probably better to use `handleJust' or `catchJust' or something like that instead of using `try')
06:54:41 <MagneticDuck> > "Multiline\
06:54:41 <lambdabot>   <no location info>:
06:54:41 <lambdabot>      unexpected end-of-file in string/character literal...
06:54:45 <hpc> :t whileM
06:54:45 <lambdabot> Not in scope: `whileM'
06:55:00 <hpc> @hoogle m Bool -> m () -> m ()
06:55:00 <lambdabot> Data.Generics.Aliases ext0 :: (Typeable a, Typeable b) => c a -> c b -> c a
06:55:00 <lambdabot> Control.Monad unless :: Monad m => Bool -> m () -> m ()
06:55:00 <lambdabot> Control.Monad when :: Monad m => Bool -> m () -> m ()
06:56:11 <MagneticDuck> GHC gives me the error "parse error on input : '='"
06:56:26 <ski> strange
06:56:34 <ski> if that the only contents of your file ?
06:56:50 <rwbarton> MagneticDuck: no, it doesn't
06:57:01 <MagneticDuck> Everything else is commented out.
06:57:01 <MagneticDuck> Hm, I'll try it again...
06:57:15 <hpc> runs here
06:57:32 <MagneticDuck> Whoops. How the *bleep* did that equals sign get in after my last comment?!?
06:57:50 <MagneticDuck> He he.
06:57:50 <hpc> perhaps the error is earlier
06:57:50 <hpc> like that lol
06:57:50 <MagneticDuck> Yeah, I fixed it. :P
06:57:58 <MagneticDuck> By the way, has anybody else here tried Sublime Text 2?
06:58:32 <MagneticDuck> http://www.sublimetext.com/
06:58:37 * hackagebot mtl-evil-instances 0.1 - Instances for the mtl classes for all monad transformers.  http://hackage.haskell.org/package/mtl-evil-instances-0.1 (ShaneOBrien)
06:58:39 * hackagebot pugs-compat 0.0.6.20120229 - Portable Haskell/POSIX layer for Pugs  http://hackage.haskell.org/package/pugs-compat-0.0.6.20120229 (AudreyTang)
06:58:40 <hpc> never heard of it
06:59:05 <hpc> ...oh, that's cool
06:59:09 <MagneticDuck> Well, it's not the most powerful thing in the world, but it has some GHC support, Haskell highlighting, widgets, macros...
06:59:09 <hpc> http://www.sublimetext.com/screenshots/pythonHeroFull.png
06:59:22 <MagneticDuck> and a black background!
06:59:27 <MagneticDuck> Makes me feel like a hacker.
06:59:45 <hpc> i love that preview on the left
06:59:55 <MagneticDuck> If you want to impress people, run it in fullscreen mode, and it looks like you're a hacker straight from the movies!
07:00:00 <MagneticDuck> Yeah, I do too.
07:00:16 <MagneticDuck> Runnin' it on Linux, and it workes fine!
07:00:26 <hpc> MagneticDuck: it's apparently nagware?
07:00:36 <MagneticDuck> I'm of course running the trial version. *trollface*
07:00:41 <MagneticDuck> hpc: What's that?
07:00:41 <hpc> lol
07:00:57 <MagneticDuck> It's really sleek.
07:01:10 <hpc> you got all my hopes up about it being a vim replacement
07:01:18 <hpc> but it does the "trial expired, buy winrar" thing
07:01:36 <MagneticDuck> No, actually!
07:01:51 <MagneticDuck> It just brings up a dialog every 20 minutes or so, and you just have to shut it!
07:02:01 * ski grins
07:02:11 <Ptival> that's the winrar thing...
07:02:15 <Ptival> even more frequently
07:02:36 <MagneticDuck> It works fine for me, and who knows, I might bug my parents into buying it someday!
07:02:53 <MagneticDuck> You can write scripts for it and everything, in Python though.
07:02:54 <hpc> what Ptival said
07:05:33 <MagneticDuck> Yes?
07:05:55 <MagneticDuck> Is everybody downloading it right now?
07:07:10 <MagneticDuck> Nap time! Yay!
07:07:31 <applicative> i couldn't figure out how to configure it, even though it has a big community, they are all too stupid to write plugins and bundles
07:07:49 <MagneticDuck> What OS are you running?
07:07:56 <applicative> os x
07:08:14 <MagneticDuck> Can't help you there... MAC USER! Just kidding. I know nothing about os x.
07:08:38 * hackagebot pugs-compat 0.0.6.20120229.160500 - Portable Haskell/POSIX layer for Pugs  http://hackage.haskell.org/package/pugs-compat-0.0.6.20120229.160500 (AudreyTang)
07:10:27 <applicative> no, i just meant i couldn't make internal modifications that are easy with e.g. textmate, e.g. to display the type of a haskell expression, or reformat lhs as hs or whatever you please
07:11:22 <temp1> Is it ok if I ask a basic Happy question here?
07:11:47 <MagneticDuck> You're unhappy with happy? :) Yeah, go ahead.
07:12:17 <applicative> there isn't a #happy so yes.
07:12:55 <MagneticDuck> If there was, it would probably be something other than Haskell, come to think of it.
07:13:21 <temp1> When parsing the $n in the code annotations, 1) does it ignore string contents? and 2) is there a way to escape $ characters outside of strings?
07:14:32 <shampoo> hey guys i need some help with the output of a code. variable :: Integer -> [String]     variable x     | x == 0 = ["abc"]        | x > 0 = map (++ "A") (variable (x-1)) ++ map (++ "B") (reverse (variable (x-1))
07:15:02 <MagneticDuck> shampoo: Ow, my eyes! Post your code on hpaste.org
07:15:09 <shampoo> what would be the output if x = 2
07:15:43 <Ptival> > let variable x     | x == 0 = ["abc"]       | x > 0 = map (++ "A") (variable (x-1)) ++ map (++ "B") (reverse (variable (x-1))
07:15:44 <lambdabot>   <no location info>: parse error (possibly incorrect indentation)
07:15:55 <Ptival> > let variable x     | x == 0 = ["abc"]       | x > 0 = map (++ "A") (variable (x-1)) ++ map (++ "B") (reverse (variable (x-1)) in variable 2
07:15:56 <lambdabot>   <no location info>: parse error on input `in'
07:16:01 <Ptival> meh
07:16:12 <Ptival> I'll have to read
07:16:36 * Ptival embodies laziness
07:17:53 <shampoo> variable :: Integer -> [String] variable x | x == 0 = ["abc"] | x > 0 = map (++ "A") (variable (x-1)) ++ map (++ "B") (reverse (variable (x-1))
07:18:25 <MagneticDuck> Ow, my eyes hurt! Please stop! :|
07:18:30 <MagneticDuck> Use hpaste.org!
07:19:22 <DoctorSmaug> output from "variable 2" is ["abcAA", "abcBA", "abcBB", "abcAB"]
07:19:35 <DoctorSmaug> you missed a closing bracket at the end btw
07:19:39 <t7> i duno how people can code in asm, how do they keep all that state in their head?
07:20:03 <hpc> t7: one function at a time
07:20:04 <Ptival> > let variable x | x == 0 = ["abc"] | x > 0 = map (++ "A") (variable (x-1)) ++ map (++ "B") (reverse (variable (x-1))) in variable 2
07:20:05 <lambdabot>   ["abcAA","abcBA","abcBB","abcAB"]
07:20:12 <shampoo> awesome
07:20:13 <shampoo> thanks
07:20:32 <ion> t7: Why would one keep all the state in one‚Äôs head?
07:20:35 <hpc> t7: the same way C programmers code, more or less; they think only in terms of the structs they are using at the time
07:20:40 <shampoo> why does it start with abc?, shouldnt that be the last thing?
07:21:14 <Ptival> no
07:21:21 <Ptival> you map (++ "something")
07:21:29 <DoctorSmaug> recursion
07:21:31 <Ptival> so you append at the end of the base case
07:22:03 <dowski> hi all; quickcheck question here
07:22:06 <hpaste> shampoo pasted ‚Äúvariable function‚Äù at http://hpaste.org/64541
07:22:13 <shampoo> oh ok
07:22:15 <MagneticDuck> I posted it for him, actually.
07:22:20 <dowski> i need to pass -XScopedTypeVariables to ghci when poking at my code
07:22:23 <shampoo> thank you very much... youve been a huge help
07:22:26 <dowski> how to i pass that through to quickCheck?
07:22:33 <dowski> (quickCheck the script)
07:22:37 <robertberry> hello chaps. if I have a pattern with guards, must one of the guards match?
07:22:51 <Ptival> shampoo: wait, there's this reverse still :\
07:23:04 <robertberry> I'm getting "Exception: /home/robert/haskell/99-questions/q18.hs:(11,1)-(16,33): Non-exhaustive patterns in function slice"
07:23:05 <applicative> > let variable 0 = ["abc"] ; variable x = map (++ "A") (variable (x-1)) ++ map (++ "B") (reverse (variable (x-1))) in variable 2
07:23:06 <lambdabot>   ["abcAA","abcBA","abcBB","abcAB"]
07:23:29 <applicative> ^^^ pattern matching is typically better than an equality test
07:23:30 <robertberry> But one of my other later patterns matches I think ...
07:23:33 <DoctorSmaug> robert: yes.  Otherwise you'll get an "inexhaustive pattern" error.  Use "otherwise" to match all other cases
07:23:43 <shampoo> let variable 0 = ["abc"] ; variable x = map (++ "A") (variable (x-1)) ++ map (++ "B") (reverse (variable (x-1))) in variable 3
07:23:44 <robertberry> so it can't fall through into another pattern?
07:23:54 <temp1> robertberry: it can fall through
07:23:58 <Ptival> > let variable x | x == 0 = ["abc"] | x > 0 = map (++ "A") (variable (x-1)) ++ map (++ "B") (reverse (variable (x-1))) in map variable [1..3]
07:24:00 <lambdabot>   [["abcA","abcB"],["abcAA","abcBA","abcBB","abcAB"],["abcAAA","abcBAA","abcB...
07:24:09 <robertberry> i'll stick it on a gist so you can see what I mean
07:24:10 <robertberry> one sec
07:24:26 <temp1> robertberry: add a function _ = error "fell through" to your code
07:24:40 <robertberry> https://gist.github.com/1941563
07:25:10 <robertberry> I'm basically using the first pattern just to check for errors, as I'm not using (x:xs) in that so I thought it'd look cleaner
07:25:14 <Ptival> shampoo: basically, the code is marking in the result by which branch it recursed
07:25:17 <robertberry> but if you can't do that I can just merge them
07:25:17 <MagneticDuck> Nope, that doesn't work.
07:25:24 <temp1> robert: you need a pattern for the empty list
07:25:34 <robertberry> oh yeah!
07:25:41 <robertberry> didn't notice that
07:25:43 <MagneticDuck> Because all patterns will fall through to the first definition.
07:25:46 <robertberry> cheers
07:25:57 <robertberry> right - so once they're in guards, that's it
07:25:58 <MagneticDuck> Whoops, I'm late to this! Sorry. :P
07:26:10 <robertberry> that patterns matched and it stops looking?
07:26:15 <robertberry> *pattern's
07:26:19 <temp1> robertberry: no
07:26:40 <temp1> robertberry: if the pattern matches but the guards don't, that's the same as the pattern not matching
07:26:43 <robertberry> oh
07:26:44 <MagneticDuck> As I was saying, your first definition of slice will catch everything!
07:26:46 <temp1> it just falls through
07:27:01 <MagneticDuck> Oh, never mind.
07:27:04 <robertberry> yeah it does - but the guards don't match
07:27:42 <robertberry> it seems to just have been the lack of an empty list pattern
07:27:44 <robertberry> thanks guys :)
07:27:51 <robertberry> haskell's awesome
07:28:07 <temp1> Anybody know (or know where to find in the docs) Happy's rules on what is and isn't valid $n?
07:28:54 <srhb> @src putStrLn
07:28:59 <lambdabot> putStrLn s =  do putStr s; putChar '\n'
07:29:07 <srhb> So that doesn't flush the output buffer either?
07:30:10 <applicative> temp1, it looks like you'll have to try when Happy-knowledgeable people are around, unfortunately.
07:30:38 <hpc> srhb: it does if stdout is line buffered :P
07:30:46 <ski> srhb : if you have line buffering, outputting a newline flushes
07:31:07 <temp1> srhb: use hSetBuffering to change buffering options
07:31:23 <hpc> stdout defaults to line buffered, iirc
07:31:32 <ski> srhb : if you want to flush explicitly, `hFlush'
07:34:15 <MagneticDuck> I usually use hFlush
07:35:50 <hpc> it's generally pretty rare when line buffering or block buffering won't cut it for you, though
07:36:29 <dowski> i solved my quickCheck issue
07:36:45 <dowski> i added a LANGUAGE pragma to my source file
07:37:00 <dowski> {-# LANGUAGE ScopedTypeVariables #-}
07:37:15 <MagneticDuck> hpc: When you're making an interactive console app, or something along those lines it's better to use NoBuffering.
07:37:15 <hpaste> erkin pasted ‚ÄúFind the largest factor of x1‚Äù at http://hpaste.org/64542
07:37:30 <Peaker> A beginner I've shown Haskell to was very very surprised "ScopedTypeVariables" was not the default behavior
07:37:33 <erkin> Is it normal for it to hang?
07:37:37 <Peaker> maybe it should be on by default
07:37:42 <erkin> Or does it take way too long to calculate it?
07:38:01 <ChristianS> i usually collect all my output in a lazy bytestring and use LB.putStr to lazily print it as it is assembled. keeps things out of the IO monad.
07:38:41 <reltuk> when using pipes, is there any way to lift the monad transformer a pipe is in?
07:39:10 <MagneticDuck> erkin: Your prime function is wrong!
07:39:12 <reltuk> or is there a better way to write the pipes so that they're more agnostic as to where the WriterT or ResourceT or whatever is in the tranformer stack?
07:39:13 <erkin> D:
07:39:22 <erkin> Damnit, I knew something was wrong!
07:39:33 <temp1> erkin: find a good prime library, rolling your own is usually horrible
07:39:48 <temp1> erkin: It makes most of the Euler problems much easier and faster too.
07:39:56 <erkin> But I want to write my own.
07:40:01 <erkin> Because I want to learn.
07:40:10 <ski> Peaker : had that beginner used an ML before ?
07:40:17 <Peaker> ski: nope
07:40:28 <temp1> erkin: fair enough, expect slow perfomance though
07:40:38 <Peaker> ski: he just tried adding type annotations when encountering ambiguous types and was baffled by the type errors
07:40:38 <erkin> So, the code actually works?
07:40:42 <rostayob> ski: ScopedTypeVariables makes perfect sense
07:40:45 <reltuk> Basically I have: writerPipe = forever $ ( await >>= \x -> (lift $ tell x) >> yield x )
07:41:10 <ski> rostayob : except that having to add an explicit `forall' is contraintuitive
07:41:22 <temp1> I want to be able to match the regex "$[0-9]+" in a string, replace all those instances with a function of the number and then record which numbers were matched. What's the easiest way to do this?
07:41:26 <Peaker> ski: maybe it should be implied -- or added as a potential fix in the type errors
07:41:36 <hpaste> srhb annotated ‚ÄúDB REPL‚Äù with ‚ÄúDB REPL (annotation)‚Äù at http://hpaste.org/64534#a64543
07:41:39 * ski understands the reasoning for that, but still doesn't like it
07:42:01 <reltuk> and I have a Pipe like: Consumer a (ResourceT m) ()
07:42:02 <srhb> I factored out the repl-functionality, but the calls to repl don't seem very intuitive now. Is record syntax a better idea, perhaps?
07:42:04 <reltuk> and I want to combine them
07:42:06 <ski> (imo, it should be the other way around)
07:42:59 * ski usually prefers `PatternSignatures'
07:43:00 <reltuk> it seems like the transformation I want to make is some function that goes from Pipe a b (t m) c -> Pipe a b (t' (t m)) c
07:43:05 <temp1> if you use records, NamedFieldPuns is almost mandatory
07:43:10 <MagneticDuck> erkin: I do all the Euler problems with my own code, and it doesn't take that long. I use fairly simple algorithms.
07:43:23 <reltuk> by lifting every lift call within the Pipe once more
07:43:32 <erkin> The code is running for almost half an hour. :/
07:43:42 * hackagebot pugs-compat 0.0.6.20120229.163800 - Portable Haskell/POSIX layer for Pugs  http://hackage.haskell.org/package/pugs-compat-0.0.6.20120229.163800 (AudreyTang)
07:44:12 <Eduard_Munteanu> temp1: is that a literal '$'?
07:44:24 <srhb> ski: Was the PatternSignatures re: my repl?
07:44:32 <temp1> Eduard_Munteanu: yes
07:44:32 <Eduard_Munteanu> End of line wouldn't make much sense.
07:45:01 <temp1> Eduard_Munteanu: think what happy does with the code segments
07:45:18 <temp1> Eduard_Munteanu: I'm doing something like that
07:45:46 <Eduard_Munteanu> temp1: I guess you could split the string by '$' then read numbers
07:46:49 <temp1> Eduard_Munteanu: that's exactly what I wanted thanks, and I guess it wouldn't be too hard to extend it to ignore '$' in quotes for example
07:48:53 <ski> srhb : hm, no. it was re `ScopedTypeVariables'
07:53:02 <Eduard_Munteanu> > fst . head . reads . drop 1 $ "$123abc" :: Integer
07:53:03 <lambdabot>   123
07:53:34 <Eduard_Munteanu> temp1: ^^, also you'd get no parse if you have something like "$'"
07:54:26 <Eduard_Munteanu> Although that might accept stuff like "$-123"
07:54:45 <ski> > (reads :: ReadS Integer) (drop 1 "$123abc")
07:54:46 <lambdabot>   [(123,"abc")]
07:55:35 <ski> > (reads :: ReadS Integer) (drop 1 "$-123abc")
07:55:35 <lambdabot>   [(-123,"abc")]
07:55:37 <ski> > (readDec :: ReadS Integer) (drop 1 "$123abc")
07:55:38 <lambdabot>   [(123,"abc")]
07:55:40 <ski> > (readDec :: ReadS Integer) (drop 1 "$-123abc")
07:55:41 <lambdabot>   []
07:55:42 <temp1> that's pretty much what I'm doing, just defining a function using pattern matching and passing a Bool around if I'm in a quoted string
07:56:00 <beyeran> hi, what would be the appropriate way to get a sha1 sum of a file in haskell?
07:56:04 <temp1> abd using split isDigit
07:56:13 <temp1> though readDec seems to also be what I want
07:57:41 <ski> > do '$':s <- ["$123abc"]; (readDec :: ReadS Integer) s
07:57:42 <ski> > do '$':s <- ["#123abc"]; (readDec :: ReadS Integer) s
07:57:42 <lambdabot>   [(123,"abc")]
07:57:43 <lambdabot>   []
07:57:51 <ski> (could also be done with list comprehensions)
07:59:02 <temp1> ski: thanks
08:00:17 <temp1> ski: how do you implement choice with ReadS?
08:00:42 <ski> (btw, the type ascription ` :: ReadS Integer' could be unnecessary, depening on context)
08:00:45 <temp1> ski: for example, do {('$' or '¬£'); readDec}
08:00:50 <ski> temp1 : with `(++)'
08:01:49 <t7> @hoogle [a] -> a -> [a]
08:01:49 <lambdabot> Data.List intersperse :: a -> [a] -> [a]
08:01:50 <lambdabot> Data.List insertBy :: (a -> a -> Ordering) -> a -> [a] -> [a]
08:01:50 <lambdabot> Data.List deleteBy :: (a -> a -> Bool) -> a -> [a] -> [a]
08:02:25 <temp1> ski: thanks for all your help
08:03:02 <ski> temp1 : hm, in this specific case, you could write a quich-and-dirty function which checks for  '$'  alt.  '¬£'
08:04:04 <ski> you could also read a character, and use `guard' (or a list comprehension guard) to check (e.g. using `elem') that it's one of those two characters
08:04:33 <ski> more generally, you could use `(++)', but it might be awkward, due to that you're in a list monad, not in a proper parser monad
08:05:20 <ski> temp1 : you might want to look up `ReadP' (which is a thin wrapper around `ReadS'), or possibly look into a proper parser combinator library, like Parsec, Parsek or trifecta
08:05:42 <ski> (in those there's a general choice combinator)
08:07:58 <temp1> the funny thing is I'm actually implementing a parser combinator library currently. Perhaps I should put my money where my mouth is and actually use it for this?
08:08:17 <ski> hehe
08:12:04 <dowski> so i'm new to Haskell, and i keep wanting to convert things to other types
08:12:12 <dowski> Seq to [], etc
08:12:31 <dowski> should i instead be wanting to lift functions into those ... things?
08:12:54 <mux> as far as Seq and [] are concerned, you could use the Foldable type-class
08:13:02 <mux> that'll cover those types and much more
08:13:30 <mux> for Foldable-like operations, of course
08:14:00 <dowski> mux: cool, thanks
08:22:22 <beyeran> hi, what would be the appropriate way to get a sha1 sum of a file in haskell?
08:23:57 <Botje> there's a Data.Digest.SHA1
08:25:14 <beyeran> yes, but it's annoying me because I don't exacly geht the meaning of Word8... or to be more specific the usage of the "hash" function in Data.Digest.SHA1
08:25:37 <rostayob> beyeran: Word8 = a byte
08:26:29 <rostayob> beyeran: you can read the file into a ByteString and then convert it to [Word8]
08:26:31 <rostayob> :t unpack
08:26:32 <lambdabot> forall n o. (Newtype n o) => n -> o
08:26:34 * ski would have said "octet"
08:26:42 <rostayob> @hoogle unpack
08:26:42 <lambdabot> Graphics.Rendering.OpenGL.GL.PixelRectangles.PixelStorage Unpack :: PixelStoreDirection
08:26:42 <lambdabot> Data.ByteString.Char8 unpack :: ByteString -> [Char]
08:26:42 <lambdabot> Data.ByteString.Lazy.Char8 unpack :: ByteString -> [Char]
08:26:55 <rostayob> beyeran: you should use the Data.ByteString readFile/unpack
08:27:27 <beyeran> rostayob: thank you, with unpack it makes sense!
08:28:35 <ski> @type Data.ByteString.unpack
08:28:36 <lambdabot> BSC.ByteString -> [Word8]
08:39:04 <beyeran> rostayob: yes it works like I wanted it to, thanks
08:40:06 <rostayob> beyeran: yw
08:43:09 * ski realizes <http://www.sublimetext.com/> is neither <http://subtextual.org/> nor <http://www.codingmonkeys.de/subethaedit/>
08:44:19 <MagneticDuck> Yeah. LOL
08:44:25 <MagneticDuck> But do you like it?
08:45:24 <MagneticDuck> Personally, I like its interface, although it's not the most powerful thing in the world, but it has code snippets, building support for haskell, and of course macros... good enough for me!
08:47:34 <MagneticDuck> Actually, it's because I'm too lazy to learn the full power of emacs... but really, I'm coding in Haskell. Do I need that kind of stuff?
08:47:37 <ski> the overview to the left looks nifty, but i wonder how useful it is in practice
08:47:45 <MagneticDuck> It's actually quite cool.
08:48:23 <MagneticDuck> In Linux it's on the right though... :D
08:48:43 * hackagebot HaskellLM 0.1.2 - Pure Haskell implementation of the Levenberg-Marquardt algorithm  http://hackage.haskell.org/package/HaskellLM-0.1.2 (KietLam)
08:48:51 <MagneticDuck> WHO IS THAT HACKAGEBOT?
08:49:14 <MagneticDuck> Just an advertising system for hackage? :P
08:49:23 <ski> more or less, yes
08:49:29 <MagneticDuck> Huh.
08:49:51 <ski> well, not quite advertisment, it does the above when someone *updates* a package
08:50:05 <MagneticDuck> Okay.
08:50:09 <rostayob> ski: emacs is better :)
08:50:13 <quicksilver> I can't bring myself to learn an editor which is not open source and not designed to be fully scriptable.
08:50:15 <sm> / whois hackagebot
08:50:27 <quicksilver> all editors suck
08:50:39 <MagneticDuck> quicksilver: What the heck do you use, then?
08:50:41 <quicksilver> but among that class, (if you're a programmer), you might as well use one you can extend and adapt.
08:50:47 <ski> rostayob : yeah, so far i'm not seeing much that emacs doesn't offer, and i worry that i'll miss "essential" things from emacs if i attempt switching
08:50:58 <quicksilver> MagneticDuck: emacs.
08:50:59 <rostayob> http://www.reddit.com/r/haskell/comments/qadwm/improbable_uses_of_unsafecoerce/c3w5qwo
08:51:03 <rostayob> I don't understand ekmett comment
08:51:19 <rostayob> edwardk: speak of the devil
08:51:23 <quicksilver> your misunderstanding appears to have summoned him
08:51:26 <rostayob> I don't understand your reddit comment
08:51:27 <quicksilver> he did this yesterday to me
08:51:34 <edwardk> rostayob: ?
08:51:35 <quicksilver> edwardk-- # sinister
08:51:36 <MagneticDuck> Yeah, I should really get around to learning emacs one of these days. I've started... but I haven't gotten far.
08:51:46 <rostayob> edwardk: http://www.reddit.com/r/haskell/comments/qadwm/improbable_uses_of_unsafecoerce/c3w5qwo , I think we're talking about different Trees.
08:52:11 <edwardk> i'm taking about Data.Tree, from containers
08:52:27 <rostayob> edwardk: ok, we're talking about different trees.
08:52:27 <edwardk> which is data Tree a = Node { rootLabel :: a, subForest :: Forest a }
08:52:40 <edwardk> where Forest a = [Tree a]
08:52:44 <rostayob> yep
08:53:23 <ChristianS> MagneticDuck: better learn vim instead! (but don't ask me why -- there must be a specific channel for emacs vs. vim flamewars somewhere)
08:53:48 <MagneticDuck> Yeah, I've seen that too... I really don't understand either of them yet though.
08:54:12 * ski recently tried <http://en.wikipedia.org/wiki/CygnusEd> a bit
08:54:55 <rostayob> edwardk: data Tree a = Leaf | Branch a (Tree a) (Tree a) might be equivalent to 'Cofree Prod a' where 'newtype Prod a = Prod (a, a)'
08:55:13 <edwardk> nope, that Tree isn't Cofree, Leaf has no 'a' in it
08:55:30 <rostayob> edwardk: yeah
08:55:35 <rostayob> adding the a in the Leaf
08:55:37 <edwardk> a * f (a * f (a * ‚Ä¶))
08:55:58 * ski would have called it `Tip' or `Empty' or `Nil' instead
08:56:12 <edwardk> then its Cofree of Maybe2 where Maybe2 a = Nothing2 | Just2 a a
08:56:17 <ski> (a leaf with no element is no leaf !)
08:56:35 <edwardk> but you can't unsafe coerce because the constructors don't line up
08:56:42 <rostayob> edwardk: and lists with at least one element are Cofree Maybe a, I guess? I had never met this Cofree before
08:58:09 <rostayob> edwardk: well but they do line up with my Tree
08:58:26 <rostayob> the [] in the list and the Leaf in the Tree
08:58:46 <MagneticDuck> By the way, I finally found the comic I was looking for on emacs vs vim... http://tnerual.eriogerg.free.fr/0xBABAF000L/10_en.html
09:00:34 <edwardk> blah what was the last thing i said?
09:00:38 <gentleben> i find that debate to be funny
09:00:49 <MagneticDuck> Yeah, me too. :P
09:01:04 <MagneticDuck> Sorry to interrupt everyone...
09:01:07 <edwardk> blah what was the last thing i said?
09:01:12 <ski> <edwardk> but you can't unsafe coerce because the constructors don't line up
09:01:21 <edwardk> ski: ack
09:01:28 <gentleben> i had someone trying to convince me to use emacs because "its backed by the power of lambda calculus"
09:01:31 <edwardk> @hpaste
09:01:31 <lambdabot> Haskell pastebin: http://hpaste.org/
09:01:54 <hpaste> edwardk pasted ‚Äúfree/cofree‚Äù at http://hpaste.org/64546
09:01:59 <ski> edwardk : <http://tunes.org/~nef/logs/haskell/12.02.29>
09:02:03 <edwardk> i hpasted what i was saying =)
09:02:25 <guest19287> Hi, everyone. I have few quick questions. What does the . do in haskell? and What is point free?
09:02:34 <MagneticDuck> What does :< mean?
09:02:34 <hpc> guest19287: (.) is function composition
09:02:39 <sipa> guest19287: (f . g) x == f (f x)
09:02:39 <hpc> (f . g) x = f (g x)
09:02:39 <edwardk> rostayob: sure. they do line up in your case, it was just a miscommunication
09:02:46 <sipa> eh, what hpc said
09:02:50 <edwardk> MagneticDuck: its just an infix constructor
09:03:06 <MagneticDuck> Meaning...
09:03:10 <ski> @type (Seq.:<)
09:03:11 <lambdabot> forall a. a -> Seq.Seq a -> Seq.ViewL a
09:03:16 <hpc> guest19287: pointfree is a style of writing functions without mentioning the arguments
09:03:25 <edwardk> in this case it is evocative of the fan out as you add more elements on the right.
09:03:33 <edwardk> since cofree comonads look vaguely treelike
09:03:34 <hpc> guest19287: so if you wanted to find the sum of the first 5 elements of a list...
09:03:48 * hackagebot hedis 0.4 - Client library for the Redis datastore: supports full command set,  pipelining.  http://hackage.haskell.org/package/hedis-0.4 (FalkoPeters)
09:03:48 <hpc> > let sum5 = sum . take 5 in sum [1..]
09:03:52 <edwardk> 1 :< [2 :< [], 3 :< [4 :< []]]
09:03:52 <lambdabot>   mueval-core: Time limit exceeded
09:03:57 <hpc> > let sum5 = sum . take 5 in sum5 [1..] -- derp
09:03:58 <rostayob> edwardk: it still doesn't work eheh
09:04:02 <lambdabot>   mueval-core: Time limit exceeded
09:04:07 <edwardk> rostayob: ?
09:04:11 <hpc> @slap lambdabot
09:04:11 * lambdabot activates her slap-o-matic...
09:04:18 <MagneticDuck> > let sum5 = sum . take 5 in sum5 [1..]
09:04:23 <rostayob> edwardk: the unsafeCoerce with Fix [] and Tree
09:04:23 <lambdabot>   mueval: ExitFailure 1
09:04:24 <lambdabot>  mueval: Prelude.undefined
09:04:33 <hpc> guest19287: anyhoo, "sum5 = sum . take 5" is in pointfree style
09:04:40 <MagneticDuck> Yeah
09:04:44 <edwardk> i don't understand the coerce you are seeking there
09:05:19 <edwardk> you're discarding the argument for the leafs by going to Nil
09:05:41 <guest19287> what would that be if it wasn't point free?
09:05:51 <edwardk> which should be fine
09:05:56 <hpc> guest19287: sum5 list = sum . take 5 $ list
09:05:56 <edwardk> oh i see the problem
09:05:59 <rostayob> edwardk: yes, and you get the spline
09:06:01 <edwardk> data FixTree = FixTree [FixTree]
09:06:03 <edwardk> not newtype
09:06:05 <hpc> guest19287: or: sum5 list = sum (take 5 list)
09:06:58 <edwardk> if he swaps that it should be fine
09:07:00 <guest19287> ohh so explicitily put what you want and that is point free
09:07:02 <guest19287> ?
09:07:14 <hpc> guest19287: pointfree is when you don't mention "list"
09:07:41 <guest19287> okay
09:08:05 <hpc> it's kind of like you write what f is, rather than what (f x) is
09:08:11 <guest19287> and . means do everything infront of me and then pass the value to one before me
09:08:16 <guest19287> ?
09:08:19 <MagneticDuck> ...kind of.
09:08:30 <byorgey> guest19287: (f . g) x = f (g x)
09:08:35 <hpc> guest19287: essentially, if you ignore operator precedence
09:08:36 <MagneticDuck> You can use (.) abstractly.
09:08:45 <hpc> also what MagneticDuck said
09:08:48 <Eduard_Munteanu> :t (Prelude..)
09:08:48 <byorgey> to start with, don't worry about what it "means", just know the definition.
09:08:50 <lambdabot> forall b c a. (b -> c) -> (a -> b) -> a -> c
09:08:56 <rostayob> edwardk: why would FixTree being data/newtype affect things?
09:09:00 <MagneticDuck> So here's a good example:
09:09:11 <MagneticDuck> > unwords . reverse . words $ "hello world this is a test"
09:09:13 <lambdabot>   "test a is this world hello"
09:09:24 <edwardk> FixTree as data makes it a single constructor, fixtree as a newtype makes it invisible like you'd expect
09:09:27 <matthiasgorgens> byorgey: actually, you don't even need to know the definition.  the type is all you need.
09:09:29 <edwardk> data /= newtype
09:09:36 <rostayob> edwardk: FixTree is not used in the coercion
09:09:41 <rostayob> it's just a convenient type to show the result
09:10:12 <edwardk> ah
09:10:16 <byorgey> matthiasgorgens: heh, good point, that's a bit more abstract though =)
09:11:11 <guest19287> (f . g) x = f (g x)  so the brackets dont matter in this case when you have the .
09:11:12 <guest19287> ?
09:11:50 <guest19287> sorry for stupid question
09:11:58 <byorgey> guest19287: which brackets?
09:12:03 <byorgey> I don't understand your question
09:12:10 <guest19287> i mean parenthesis ()
09:12:15 <monochrom> the brackets matter
09:12:18 <guest19287> (f.g)
09:12:26 <MagneticDuck> You can just write f . g
09:12:30 <byorgey> guest19287: f . g x   and  (f . g) x  are very different
09:12:36 <MagneticDuck> Yes.
09:12:51 <MagneticDuck> (f . g) x is taking the composition of f and g and calling it with x
09:12:55 <byorgey> guest19287: because function application has the highest parsing precedence.  so  f . g x   means   f . (g x)
09:13:16 <MagneticDuck> f . g x is currying g with x and composing it with f.
09:13:30 <MagneticDuck> Assuming that g is of kind * -> * -> *
09:13:45 <hpc> MagneticDuck: g is a value, it can't have a kind :P
09:14:01 <MagneticDuck> Alright. So I'd say a -> b -> c
09:14:11 <MagneticDuck> That's right. I keep on mixing them up!
09:14:41 <MagneticDuck> guest19287: Hope we're not confusing you...
09:16:39 <edwardk> well, if you put result = treeToLists (Branch (Leaf 3) (Leaf 4)) in the module, and add -fobject-code then ghci gives the right answer
09:17:05 <guest19287> thinking lol
09:17:09 <edwardk> so i think you're seeing some interaction between the bytecode interpreter and the tagbits
09:17:31 <MagneticDuck> guest19287: Just wait till you get to stuff like (.) . (.)
09:17:32 <edwardk> and you can use
09:17:33 <edwardk> deriving instance (Show (Fix f), Show (f (Fix f))) => Show (Fix f)
09:17:38 <edwardk> to avoid the need for FixTree entirely
09:17:53 <MagneticDuck> guest19287: It's still hard for me! :P
09:18:16 <guest19287> haha
09:18:30 <MagneticDuck> Well, technically, I'm still a newbie actually.
09:18:55 * hackagebot monad-atom 0.4.0 - Monadically convert object to unique integers and back.  http://hackage.haskell.org/package/monad-atom-0.4.0 (GrzegorzChrupala)
09:18:59 <rostayob> edwardk: interesting, thanks
09:21:15 <rostayob> edwardk: yeah, but it needs undecidable instances
09:21:39 <edwardk> rostayob: sure
09:21:58 <edwardk> but its sound for this case
09:22:10 <edwardk> almost any instances on Mu need that
09:23:45 <edwardk> (technically Show can be handled through some funny tricks and the Functor without extensions, but Eq, Ord, etc need it)
09:23:47 <guest198732> got disconnected
09:23:48 <rostayob> eacameron: yay, you're right with -fobject-code it works. thanks!
09:24:04 <guest198732> sum5 list = sum . take 5 $ list  what does the dollar sign mean?
09:24:21 <MagneticDuck> That's just function application.
09:24:24 <rostayob> is it possible to pass options to ghci in a pragma?
09:24:28 <MagneticDuck> f $ x = f x
09:24:35 <edwardk> you can :set
09:24:50 <MagneticDuck> The difference, though, is that is have a precedence of 0. So, f ( g x) = f $ g x
09:24:51 <rostayob> no but I need -fobject-code, and OPTIONS_GHC doesn't seem to have any effect
09:24:52 <edwardk> and i suppose {-# OPTIONS_GHC -fobject-code #-} might work
09:24:56 <edwardk> hrmm
09:25:11 <edwardk> don't know of any way
09:25:13 <byorgey> no, pragmas in a .hs file do not affect the pragmas in effect within ghci itself
09:25:28 <rostayob> ok, too bad
09:25:34 <ski> guest198732 : it's the same as writing `sum5 list = (sum . take 5) list' (which i think looks prettier)
09:25:51 <sipa> guest198732: but a $ b $ c $ d is the same as a (b (c d))
09:26:05 <sipa> it's function application, but with different precedence
09:26:08 <monochrom> "sum . take 5 $ list" is "(sum . take) list"
09:26:10 <ski> is the same as `(a . b . c) d'
09:26:13 <MagneticDuck> ...what I said.
09:26:20 <MagneticDuck> *which is
09:26:38 <sipa> MagneticDuck: oops, missed that
09:26:38 <MagneticDuck> ...is the same as a . b . c $ d
09:26:53 <MagneticDuck> IRC can be pretty uncoordinated! :P
09:27:05 <sipa> it's just multiplayer notepad, really
09:27:20 <MagneticDuck> Yeah. :D
09:28:05 <MagneticDuck> Q: What is notepad? A: An IRC client for hermits.
09:28:42 <guest198732> lol thanks magnetcDuck
09:28:55 <MagneticDuck> De nada!
09:28:58 <Martty> zoopp2: irc = multiplayer notepad
09:28:59 * hackagebot delta-h 0.0.3 - Online entropy-based model of lexical category acquisition.  http://hackage.haskell.org/package/delta-h-0.0.3 (GrzegorzChrupala)
09:29:22 <timemage> MagneticDuck, that explains why i can't find the command to kick people from my channel.
09:29:39 <MagneticDuck> LOL
09:30:52 <MagneticDuck> By the way, what's the prettiest way to find the tuple with the highest fst component, in a list of, say, (Int, String), and return the string?
09:30:55 <albel727> .
09:30:56 <MagneticDuck> Trivial, I know...
09:31:08 <MagneticDuck> but I'm wondering if there's a pretty way to do it...
09:31:42 <guest198732> one theory question, what are the 3 fundamental differences between von neuman and functional programming?
09:32:12 <MagneticDuck> for now, I'm using:
09:32:12 <MagneticDuck> > head . max $ [(1, "hello"), (2, "world")]
09:32:13 <lambdabot>   Couldn't match expected type `[a]' against inferred type `a1 -> a1'
09:32:44 <MagneticDuck> Or wait, that doesn't work...
09:33:27 <MagneticDuck> > head . maximum $ [(1, "hello"), (2, "world")]
09:33:28 <lambdabot>   Couldn't match expected type `[a]'
09:33:28 <lambdabot>         against inferred type `(t, [GHC....
09:33:41 <MagneticDuck> :|
09:33:50 <MagneticDuck> This is laughable...
09:34:27 <rostayob> MagneticDuck: you're trying to get head (2, "world")
09:34:32 <rostayob> :t maximum
09:34:33 <lambdabot> forall a. (Ord a) => [a] -> a
09:34:38 <MagneticDuck> Yeah. :P
09:34:49 <MagneticDuck> Fail
09:37:01 <Zedrikov> > sort
09:37:02 <lambdabot>   Overlapping instances for GHC.Show.Show ([a] -> [a])
09:37:02 <lambdabot>    arising from a use ...
09:37:55 <MagneticDuck> @type sort
09:37:55 <lambdabot> forall a. (Ord a) => [a] -> [a]
09:38:13 <Enigmagic> > maximumBy (comparing fst) [(1, "foo"), (2, "bar")]
09:38:13 <temp1> > :k [] (Integral a => a)
09:38:14 <lambdabot>   (2,"bar")
09:38:14 <lambdabot>   <no location info>: parse error on input `:'
09:38:23 <guest198732> difference between constoructor for return values and inpattern matching?
09:38:34 <MagneticDuck> @kind [] (Integral a => a)
09:38:35 <lambdabot> *
09:38:44 <temp1> magneticduck: thanks
09:39:03 <MagneticDuck> guest198732: What do you mean?
09:39:14 <tazjin> > head $ reverse $ sort [(13,"Hello"),(53,"World"),(185,"Something"),(72, "No")]
09:39:15 <lambdabot>   (185,"Something")
09:39:27 <MagneticDuck> Like an if statement, or do you mean guards?
09:39:28 <temp1> @type undefined :: ([] (Integral a => a)
09:39:28 <lambdabot> parse error (possibly incorrect indentation)
09:39:30 <guest198732> our prof said there are 2 types of constructors
09:39:31 <temp1> @type undefined :: ([] (Integral a => a))
09:39:32 <lambdabot>     Illegal polymorphic or qualified type: (Integral a) => a
09:39:32 <lambdabot>     Perhaps you intended to use -XImpredicativeTypes
09:39:33 <lambdabot>     In an expression type signature: [] ((Integral a) => a)
09:39:53 <MagneticDuck> guest198732: Yeah, there's type constructors, like Maybe Int, and value Constructors, like Just 5
09:40:00 <temp1> get in ghc docs it says that ImpredicativeTypes is depreciated, how do I make that work?
09:40:01 <MagneticDuck> Maybe that's what he means...
09:40:40 <guest198732> i thinks so
09:40:50 <Enigmagic> temp1: data IntegerBox = forall a . Integral a => IntegerBox{unBox :: a}
09:40:57 <MagneticDuck> Yeah. Examples:
09:41:00 <MagneticDuck> @kind Maybe
09:41:01 <lambdabot> * -> *
09:41:04 <MagneticDuck> @type Just
09:41:04 <lambdabot> forall a. a -> Maybe a
09:41:05 <guest198732> is there a guide on trees somewhrer for haskell?
09:41:08 <Enigmagic> temp1: then use [IntegerBox]
09:41:16 <MagneticDuck> You mean, binary trees?
09:41:35 <guest198732> yes
09:41:45 <monochrom> almost every haskell tutorial has trees
09:41:49 <Zedrikov> What do you mean by guide?
09:41:59 <guest198732> tutorial with ecamples
09:42:41 <MagneticDuck> ecamples?
09:42:52 <temp1> enigmagic: Is there not a prefix way to do it? In short, if I have "Integral a => a", I'd like to transform that into "Integral a => [a]". If prefixes don't work, then I'd need a type parser I think
09:43:09 <MagneticDuck> I'd recommend anything from LYAHFGG.
09:43:13 <MagneticDuck> This chapter: http://learnyouahaskell.com/making-our-own-types-and-typeclasses
09:43:25 <sm> what's the package that does cabal build whenever your source files change ?
09:43:28 <temp1> to clarify: I mean the strings
09:43:29 <Enigmagic> temp1: well you can make a list of Integral a => [a] but if you wanted impredicative types it would be [forall a . Integral a => a]
09:43:31 <MagneticDuck> Check recursive data structures.
09:45:07 <Enigmagic> temp1: if you need the impredicative form (a list holding any Integral instance) you'll need to use a type to wrap it like i showed earlier
09:45:13 <Enigmagic> constructor
09:46:00 <sm> I'm fairly certain this tool appears on http://hackage.haskell.org/packages/archive/pkg-list.html but I can't find it :/
09:46:55 <tgeeky_> sm: something using inotify?
09:46:57 <sm> where's the new hackage with reverse deps ? that might help track it down
09:47:02 <guest198732> one last question. could someone explain map in simple words lol
09:47:10 <sm> tgeeky_: +1
09:47:25 <tgeeky_> sm: http://packdeps.haskellers.com/reverse/hinotify
09:47:29 <tgeeky_> sm: that's part 1 and 2
09:47:31 <tgeeky_> :)
09:48:02 <tgeeky_> guest198732: you put the things on the left. then, you also put the things on the right. then you draw left to right arrows.
09:48:21 <sm> which finds http://hackage.haskell.org/package/plugins-auto , nice. Strange though, I thought there was one with a different name
09:48:44 <sm> oh yeah, this is for dynamic plugins I think
09:48:55 <MagneticDuck> Sorry, disconnected, but back now!
09:49:28 <Zedrikov> guest198732: in case where map is applied to lists?
09:49:44 <MagneticDuck> I'm sure all of you missed me incredibly. *trollface*
09:50:16 <Enigmagic> temp1: if you need a generic way of doing it and are using ghc 7.4.1... look at the "Reified dictionaries" section here http://blog.omega-prime.co.uk/?p=127
09:50:40 <Enigmagic> train time for me, i bbl
09:51:06 <guest198732> lets say like map :: (a-->b) --> [a] --> [b]
09:51:18 <guest198732> map f [] = []
09:51:35 <MagneticDuck> Yeah.
09:51:44 <guest198732> map f (x:xs) = f x : map f xs
09:51:53 <MagneticDuck> Yep!
09:52:07 <guest198732> so what does this little code mean in words?
09:52:17 <monochrom> map f [a, b, c] is [f a, f b, f c]
09:52:17 <MagneticDuck> Okay, it's recursive.
09:52:47 <MagneticDuck> It's saying that if you map a function named f to an empty list ([]), it just returns the empty list.
09:53:14 <MagneticDuck> Then, if you give it any list with a head x and tail xs, assign f to the head and cons that to the mapping of the tail.
09:53:19 <MagneticDuck> Got it?
09:53:23 <monochrom> map f [a, b, c, d, e, f] is a type error
09:53:33 <MagneticDuck> Yeah, so don't run it.
09:53:41 <MagneticDuck> > map (*2) [1..10]
09:53:42 <lambdabot>   [2,4,6,8,10,12,14,16,18,20]
09:53:45 <MagneticDuck> Is a better example.
09:54:09 <sm> gaaah
09:54:13 <MagneticDuck> Although you'll see the former when people are talking about theory a lot.
09:54:42 <MagneticDuck> Also, there's a function called fmap that maps to any functor... (to give you a taste of higher haskell)
09:54:52 <MagneticDuck> > fmap (*2) $ Just 1
09:54:53 <lambdabot>   Just 2
09:55:03 <MagneticDuck> > fmap (*2) Nothing
09:55:04 <lambdabot>   Nothing
09:55:43 <mauke> :t let a@b@c@d@e@f = id in map f [a, b, c, d, e, f]
09:55:44 <lambdabot>     Occurs check: cannot construct the infinite type: a = a -> a
09:55:44 <lambdabot>     Probable cause: `a' is applied to too few arguments
09:55:44 <lambdabot>     In the expression: a
09:56:42 <MagneticDuck> That's pretty silly...
09:57:36 <MagneticDuck> @ is an as pattern. He's saying that a variable a, which he will also call b, which he will also call c... is equal to id in...
09:57:42 <ski> > let f :: a -> a; a@b@c@d@e@f = id in map f [a, b, c, d, e, f]
09:57:43 <lambdabot>   Cannot match a monotype with `forall a. a -> a'
09:58:23 <monochrom> you don't say what mauke does is silly
09:58:35 <MagneticDuck> Sorry there, big guy.
09:59:05 <monochrom> no, not big guy. mauke knows haskell. he knows what the notation means
09:59:24 <monochrom> if you try to explain "@" to mauke, you are being the big guy.
09:59:35 <MagneticDuck> No, I'm explaining it to guest.
09:59:57 <ski> > let f@_ = id in f ()
09:59:58 <ski> > let f :: a -> a; f@_ = id in f ()
09:59:58 <lambdabot>   ()
09:59:59 <lambdabot>   Inferred type is less polymorphic than expected
09:59:59 <lambdabot>    Quantified type variable...
10:00:02 <guest198732> thank for the xplanation.
10:01:20 <mauke> :t let f :: a -> a; a@f = \x-> x in ()
10:01:21 <lambdabot>     Cannot match a monotype with `forall a. a -> a'
10:01:22 <lambdabot>       Expected type: t
10:01:22 <lambdabot>       Inferred type: forall a. a -> a
10:01:38 * mauke stares at @
10:02:32 <MagneticDuck> :t let a@f = id :: a -> a in ()
10:02:32 <lambdabot> ()
10:02:44 <MagneticDuck> ?
10:03:05 <mauke> :t let a@f = id :: a -> a in f f ()
10:03:06 <lambdabot>     Occurs check: cannot construct the infinite type: a = a -> a
10:03:06 <lambdabot>     Probable cause: `f' is applied to too few arguments
10:03:06 <lambdabot>     In the first argument of `f', namely `f'
10:03:11 <mauke> :t let a@f = id :: a -> a in id id ()
10:03:12 <lambdabot> ()
10:03:22 <MagneticDuck> ????
10:03:41 <MagneticDuck> This is weird... we'll laugh at this moment in a few minutes though...
10:04:09 * hackagebot lda 0.0.1 - Online Latent Dirichlet Allocation  http://hackage.haskell.org/package/lda-0.0.1 (GrzegorzChrupala)
10:04:25 <MagneticDuck> :t id
10:04:26 <lambdabot> forall a. a -> a
10:04:50 <MagneticDuck> :t let a@f = id :: forall a. a -> a in f f ()
10:04:51 <lambdabot>     Occurs check: cannot construct the infinite type: a = a -> a
10:04:51 <lambdabot>     Probable cause: `f' is applied to too few arguments
10:04:51 <lambdabot>     In the first argument of `f', namely `f'
10:04:54 <mauke> > let a=f;b=f;c=f;d=f;e=f;f=id in map f [a, b, c, d, e, f]
10:04:55 <lambdabot>   Overlapping instances for GHC.Show.Show (a -> a)
10:04:55 <lambdabot>    arising from a use of `...
10:04:59 <mauke> :t let a=f;b=f;c=f;d=f;e=f;f=id in map f [a, b, c, d, e, f]
10:04:59 <lambdabot> forall a. [a -> a]
10:05:01 <mauke> there we go
10:05:13 <mauke> @ monomorphs it
10:05:45 <MagneticDuck> *phew*
10:06:31 <MagneticDuck> But alas, the Haskell hackers monomorphed the expression, saving the day and the lives of 100 orphan children!
10:08:24 <MagneticDuck> I think I just scared everyone.
10:08:38 <Daneo> So say we all.
10:08:50 <MagneticDuck> That I scared everyone?
10:08:55 <quicksilver> mauke: that's interesting.
10:09:07 <quicksilver> mauke: is it documented that @ monomorphs things?
10:09:10 <mauke> no idea
10:09:45 <quicksilver> it's certainly not something I was previously aware of
10:09:50 <Daneo> Can't tell that, I saw your 'monomorphed' sentence as first :-)
10:10:06 <quicksilver> there were some changes in generalisation though
10:10:52 <MagneticDuck> Daneo: Yeah, we were on to a great discovery in unexplored land of Haskell... oh no, here I go again.
10:11:06 <Daneo> Really? Take me with you :-)
10:11:21 <MagneticDuck> Scroll back a few lines...
10:11:31 <Daneo> [19:06] == Daneo [6d84fbf7@gateway/web/freenode/ip.109.132.251.247] has joined #haskell [19:06] <MagneticDuck> But alas, the Haskell hackers monomorphed the expression, saving the day and the lives of 100 orphan children!
10:11:32 <ski> mauke,quicksilver : presumably because it makes it into a pattern-binding
10:12:28 <MagneticDuck> Okay, Daneo. Well... I can't scroll back... hopefully somebody documented this!
10:12:49 <ski> Daneo : <http://tunes.org/~nef/logs/haskell/12.02.29>
10:13:27 <Daneo> ski : Don't you hate that? The page you wanted could not be found! Try one of these locations
10:13:46 <mauke> works here
10:14:12 * hackagebot lda 0.0.2 - Online Latent Dirichlet Allocation  http://hackage.haskell.org/package/lda-0.0.2 (GrzegorzChrupala)
10:14:13 <Daneo> Sigh
10:14:18 <Daneo> It was the > sign
10:14:19 <Daneo> :)
10:15:16 <quicksilver> <> is the correct way to quote URLs
10:16:11 <Daneo> Could be, just saying that the > was assumed part of the URL, and as it wasn't my first reaction to check that, I gave that as a reason.
10:16:28 * quicksilver nods
10:16:35 <Daneo> So, sorry ;-)
10:17:15 <MagneticDuck> By the way, has anyone here heard of Zen Magnets?
10:17:41 <MagneticDuck> I was introduced to Haskell on the Zen Magnets IRC, so I guess it's fitting I tell about Zen Magnets on #haskell... :)
10:18:06 <ski> Daneo : see "APPENDIX: Recommendations for URLs in Context" in "RFC 1738 - Uniform Resource Locators (URL)" at <http://www.faqs.org/rfcs/rfc1738.html>
10:18:31 <MagneticDuck> Getting all formal here, are we?
10:18:33 * quicksilver has two sets of zen magnets. Or zen magnet clones. Or whatevr it was zen magnets were clones of.
10:18:41 <ski> MagneticDuck : ask Cale ?
10:18:47 <MagneticDuck> Well, that's disputable.
10:18:51 <MagneticDuck> ski: Yeah.
10:22:20 <MagneticDuck> www.zenmagnets.com
10:22:22 <MagneticDuck> *ahem*
10:22:28 <MagneticDuck> <www.zenmagnets.com>
10:24:08 <mmcdermo> ?
10:24:13 * hackagebot gitit 0.9 - Wiki using happstack, git or darcs, and pandoc.  http://hackage.haskell.org/package/gitit-0.9 (JohnMacFarlane)
10:24:54 <MagneticDuck> mmcdermo: They're a bunch of magnetic balls that go well with office jobs, school, math, and other things.
10:26:45 <MagneticDuck> Since nobody's asking questions anyway... here's my flickr photostream. I only post photos of designs I make:  <http://www.flickr.com/photos/chris_magneticduck/>
10:28:30 <MagneticDuck> Here's the gallery, with photos from people better than me: <http://www.flickr.com/groups/zengallery/pool/with/6742688975/>
10:28:51 <hpaste> scooty-puff pasted ‚ÄúUnexpected Type Failure‚Äù at http://hpaste.org/64550
10:29:21 <scooty-puff> http://hpaste.org/64550 - its a little long, but if anyone could help, it would be greatly appreciated
10:29:41 <scooty-puff> trying to have a type-indexed writer monad, where Category is required instead of Monoid
10:29:49 <MagneticDuck> What goes wrong?
10:30:42 <MagneticDuck> Oh, never mind.
10:30:43 <scooty-puff> not sure - its in the definition of the >>= method
10:31:12 <guest198732> hi, i am back lol
10:31:17 <MagneticDuck> Hey there
10:31:34 <guest198732> i need one more explanation in words
10:31:58 <guest198732> legnth :: [a] --> Int
10:32:09 <guest198732> legnth [] = 0
10:32:19 <hpaste> scooty-puff annotated ‚ÄúUnexpected Type Failure‚Äù with ‚ÄúUnexpected Type Failure (annotation)‚Äù at http://hpaste.org/64550#a64552
10:32:34 <guest198732> legnth (x:xs) = 1 + length xs
10:32:52 <mauke> 3
10:32:53 <MagneticDuck> length takes a list of elements with any type. length of an empty list is 0. length of any list with head x and tail xs is 1 + the length of the tail.
10:33:10 <mauke> MagneticDuck: you've missed three details
10:33:23 <MagneticDuck> mauke: What?
10:33:39 <mauke> MagneticDuck: 1) --> is an undefined type constructor
10:33:56 <MagneticDuck> Yeah, I think he meant ->
10:33:56 <mauke> MagneticDuck: 2) the thing being defined is "legnth", not "length"
10:34:06 <MagneticDuck> LOL
10:34:08 <mauke> MagneticDuck: 3) the call on the RHS is to "length", not "legnth"
10:34:33 <MagneticDuck> legnth, length... arrgh!
10:34:48 <backpackjoe> hey guys i have a question. suppose you have a function 'flat' which computes the list of labels when a tree is traversed in inorder, where data Tree a = Empty | Tree a (Tree a) (Tree a). what would be the code for that
10:35:05 <mauke> backpackjoe: homework?
10:35:12 <backpackjoe> yes
10:35:17 <mauke> that's not how you do it
10:35:36 <mauke> "suppose you have a function, what would be the code for it?" is just a fancy way of saying "write this function for me"
10:35:46 <guest198732> magnetic is that recursion?
10:35:57 <backpackjoe> are you going to help? or just be a dick
10:36:11 <MagneticDuck> guest198737: yes
10:36:13 <mauke> backpackjoe: are you going to put in some effort? or just be a dick
10:36:22 <edwardk> backpackjoe: well, up until you said that, you probably would have gotten some help
10:36:25 <mauke> MagneticDuck: technically no :-)
10:36:37 <MagneticDuck> Am I the only one learning Haskell in their free time, in 8th grade?
10:36:53 <mauke> wasn't sorear like that?
10:36:53 <Daneo> What is 8th grade in Europe MagneticDuck ?
10:36:55 <Daneo> :-)
10:37:02 <mauke> preflex: xseen sorear
10:37:03 <preflex>  sorear was last seen on freenode/#perl6 9 hours, 22 minutes and 33 seconds ago, saying: o/ sisar
10:37:09 <backpackjoe> i dont understand why retards come here if they're just going to be useless
10:37:18 <backpackjoe> you dont HAVE to comment on everything
10:37:29 <backpackjoe> if you cant help then do everyone a favor and shut up
10:37:34 --- mode: ChanServ set +o mauke
10:37:34 --- mode: mauke set +q *!*@gateway/web/freenode/ip.132.205.249.251
10:37:34 <ski> backpackjoe : `foldTree [] (\a as0 as1 -> as0 ++ a : as1)'
10:37:35 <scooty-puff> :t listify
10:37:36 <MagneticDuck> backpackjoe: #haskell is for people who like haskell.
10:37:37 <lambdabot> forall r a. (Data a, Typeable r) => (r -> Bool) -> a -> [r]
10:38:02 <scooty-puff> :t listify (const True)
10:38:03 <lambdabot> forall r a. (Data a, Typeable r) => a -> [r]
10:38:05 <MagneticDuck> backpackjoe: I don't exactly feel like helping you after that introduction.
10:38:12 <ski> backpackjoe : you'll need to implement `foldTree', though
10:38:22 <Daneo> backpackjoe, often you learn a lot by saying 'retarded' things, because they get corrected :-)
10:38:50 <MagneticDuck> Yeah, as long as you aren't calling people sexual organs.
10:38:54 <scooty-puff> :t listify (constTrue) (Just True)
10:38:54 <lambdabot> Not in scope: `constTrue'
10:38:58 <mauke> backpackjoe: your idea of "help" is misguided
10:39:05 <scooty-puff> :t listify (const True) (Just True)
10:39:06 <lambdabot> forall r. (Typeable r) => [r]
10:39:10 <MagneticDuck> agreed
10:39:10 <scooty-puff> backpackjoe: that enough?
10:39:34 --- mode: mauke set -o mauke
10:39:40 <quicksilver> vanj
10:40:16 <Daneo> MagneticDuck, may I ask your age ? Then I can picture what 8th grade is :-) Cuz I'm nearing 20s, and indeed learning in free time :-) First looks, still though.
10:41:04 <MagneticDuck> Daneo: 14
10:42:02 <guest198732> magneticduck i need one more code in words and that will be all. Please, i need it to prepare for exam
10:42:08 <Daneo> Alright, we use different terms for that stuff :-)
10:42:31 <MagneticDuck> guest198732: Sure, ask away
10:42:58 <guest198732> filter :: (a ->Bool) -> [a] -> [a]
10:43:33 <guest198732> filter p xs = [k | k <- xs, p k]
10:43:41 <guest198732> there
10:43:44 <MagneticDuck> filter is a function that takes a function that takes any type a and gives a bool, and also takes a list of type a, and in turn gives a list of type a.
10:44:20 <Botje> guest198732: you should really be able to read those functions yourself ..
10:44:33 <MagneticDuck> filter of predicate p and list xs will return the list composition that will return k, where p k is true, and k comes from xs
10:44:42 <MagneticDuck> *list comprehension
10:45:23 * hackagebot filestore 0.4.1 - Interface for versioning file stores.  http://hackage.haskell.org/package/filestore-0.4.1 (JohnMacFarlane)
10:45:32 <MagneticDuck> By the way, a predicate over a is a function that takes type a and returns a bool. Used often in filtering function and the likes.
10:47:06 <MagneticDuck> Hope that helps.
10:47:23 <MagneticDuck> You know, I'll write a program that reads out the type of functions!
10:47:27 <MagneticDuck> Better get started!
10:47:50 <guest198732> haha u should
10:47:52 <guest198732> lol
10:48:03 <MagneticDuck> No, it's entirely possible!
10:48:16 <guest198732> what does the -> and <- mean?
10:48:37 <MagneticDuck> They're rather different.
10:48:39 <Martty> right and left
10:48:45 <guest198732> like k<- xs
10:48:47 <MagneticDuck> -> is a type constructor.
10:49:01 <MagneticDuck> A function that takes the thing on the right and returns the thing on the left.
10:49:07 <MagneticDuck> <- is from monads...
10:49:29 <MagneticDuck> It basically unpackages a value from a container.
10:49:39 <MagneticDuck> usrInput <- getLine
10:49:42 <MagneticDuck> because...
10:49:45 <MagneticDuck> @type getLine
10:49:46 <lambdabot> IO String
10:49:56 <MagneticDuck> To unpack it from IO, you have to use <-
10:50:15 <hpaste> scooty-puff annotated ‚ÄúUnexpected Type Failure‚Äù with ‚ÄúUnexpected Type Failure (annotation) (annotation) For some reason, this works..‚Äù at http://hpaste.org/64550#a64554
10:52:19 <guest198732> thank you very much
10:52:30 <guest198732> have a great day
10:52:45 <MagneticDuck> Well, night here, actually! :P
10:53:13 <yitz> guest198732: -> is also part of the way you write a "lambda", an anonymous function
10:53:23 <yitz> oops, he left
10:53:28 <MagneticDuck> Yeah. Don't confuse them
10:53:30 <yitz> or she
10:53:42 <Daneo> ah right, that clears it up for me :-)
10:54:05 <MagneticDuck> ...or maybe it's a sinister robot from an alien race, out to steal all mankind has developed about programming! Play it safe!
10:54:18 <yitz> what is the difference between : and :: ?
10:54:31 <MagneticDuck> : is cons, :: is "is type of"
10:56:10 <yitz> right, the question isn't really what's the difference. the question is what are those two things that happen to be slightly similar visually.
10:56:43 <MagneticDuck> Coincidence.
11:04:25 <scooty-puff> GAH
11:04:45 <scooty-puff> ok, so may or may not have found a bug in ghc 7.0.3, its unexpected at least, but probably related to my understanding of rebindable syntax
11:05:24 * hackagebot yesod 0.10.1.1 - Creation of type-safe, RESTful web applications.  http://hackage.haskell.org/package/yesod-0.10.1.1 (GregWeber)
11:05:39 <monochrom> "->" means several unrelated things, too
11:06:12 <hpaste> scooty-puff pasted ‚ÄúWorks‚Äù at http://hpaste.org/64556
11:06:32 <monochrom> "f :: a->a" and "case x of (a,b) -> c"
11:08:51 <hpaste> scooty-puff pasted ‚ÄúDoesn't Work‚Äù at http://hpaste.org/64557
11:08:51 <MagneticDuck> Yeah. And infix functions, too.
11:09:16 <monochrom> "<-" means several unrelated things too
11:09:37 <dzhus> is there any standard extension of  `or` which treats empty lists as false and non-empties as true? (and the same for maps)
11:09:43 <scooty-puff> with rebindable syntax on, if you locally shadow >>=, will it be used in the related "do"?
11:09:56 <monochrom> "do { x<-getChar; ... }" and "f x | (a,b) <- g x = ..."
11:10:01 <scooty-puff> line 56 of http://hpaste.org/64557
11:10:05 <MagneticDuck> dzhus: You mean like in java etc?
11:10:26 <MagneticDuck> Yeah, you can make your own typeclass and make them instances of it to get that same java-y feeling.
11:11:20 <MagneticDuck> Personally I don't like that approach though-- use 'null' to make your code cleaner.
11:11:33 <MagneticDuck> > map null [[], [1, 2]]
11:11:34 <lambdabot>   [True,False]
11:11:50 <mike-burns> dzhus: What are you doing that got you there?
11:12:14 <dzhus> mike-burns: pick non-empty container out of two
11:12:28 <dzhus> mike-burns: containers are maps, lists or maybes
11:12:40 <MagneticDuck> head $ filter (not . null)
11:12:45 <monochrom> -> and <- are reserved words. you can't define a function with either name.
11:13:01 <MagneticDuck> Yep.
11:13:22 <dzhus> I need something like fold for functors.
11:13:52 <MagneticDuck> Give an example of an instance of that...?
11:15:24 * hackagebot colada 0.0.1 - Colada implements incremental word class class induction using online LDA  http://hackage.haskell.org/package/colada-0.0.1 (GrzegorzChrupala)
11:16:05 <yitz> MyMonad = Foldl StateT () [State1, State2 .. StateN] Id
11:16:05 <dzhus> oh, i need Data.Foldable
11:16:13 <dzhus> yitz: monad is too much here
11:16:40 <yitz> or something
11:19:06 <scooty-puff> meh, maybe overkill, but: http://hackage.haskell.org/trac/ghc/ticket/5908
11:21:31 <Veinor> how do I get from a UTCTime to an Integer?
11:22:08 <monochrom> what should that Integer represent?
11:22:21 <Veinor> seconds since the epoch
11:23:13 <c_wraith> fromIntegral?
11:23:27 <Veinor> no Integral instance
11:24:54 <c_wraith> ugh.  I forgot how awful time-keeping is.
11:24:59 <c_wraith> leap garbage
11:25:08 <monochrom> Data.Time.Clock.POSIX has utcTimeToPOSIXSeconds. "POSIX time is the nominal time since 1970-01-01 00:00 UTC" in seconds
11:25:23 <gentleben> plus the UTCTime library is not great for complex time manipulations
11:26:06 <Veinor> gentleben: i just have a Day value and I want to get the time at midnight in seconds since the epoch
11:27:12 <monochrom> POSIXTime is a RealFrac instance. use one of the rounding functions to get an integer.
11:28:32 <int-e> funny. I didn't know that the 17th of November, 1858, had any significance.
11:28:38 <gentleben> Veinor: can't help much. We built our own time library modeled after joda time.
11:28:47 <hpaste> dzhus pasted ‚ÄúDid it with typeclass, but is there any standard solution?‚Äù at http://hpaste.org/64558
11:28:54 <gentleben> open sourcing it is in our backlog
11:29:30 <gentleben> just haven't had the time to break the dependencies it has on our common library
11:29:49 <int-e> (it's the base for the modified julian day that can be found in the UTCTime record)
11:37:34 --- mode: ChanServ set +o mauke
11:37:34 --- mode: mauke set -q *!*@gateway/web/freenode/ip.132.205.249.251
11:39:34 --- mode: mauke set -o mauke
11:44:58 <Mathnerd314> dzhus: Data.Monoid?
11:46:17 <Mathnerd314> @hoogle a -> a -> a
11:46:18 <lambdabot> Prelude asTypeOf :: a -> a -> a
11:46:18 <lambdabot> Network.BufferType buf_append :: BufferOp a -> a -> a -> a
11:46:18 <lambdabot> Prelude atan2 :: RealFloat a => a -> a -> a
11:47:06 <dzhus> Mathnerd314: seems like yes!
11:47:19 <byorgey> no, Data.Monoid is not the same.
11:47:39 <Mathnerd314> @slap hoogle
11:47:39 * lambdabot smacks hoogle about with a large trout
11:47:40 <byorgey> pickNonNull [1] [2] == [1], but [1] `mappend` [2] == [1,2]
11:48:29 <byorgey> although for any type you wanted to make PossiblyNull you *could* make a Monoid instance with the same semantics.  But the existing instances are not necessarily what you want.
11:49:14 <dzhus> I should really dive into typeclassopedia
11:49:42 <Mathnerd314> no, you should figure out why there are so many typeclasses :p
11:51:01 <gentleben> not as many as scala
11:51:10 <otters> ho hoo
11:59:37 <MagneticDuck> What's scala?
11:59:50 <Clint> a language
11:59:58 <MagneticDuck> Guessed...
12:00:16 <pdxleif> ML-ish, written on top of Java
12:00:27 <byorgey> It's an opera house
12:00:28 <pdxleif> So you can kinda use it as both
12:01:34 <MagneticDuck> Hm.
12:01:58 <dzhus> scale is hype
12:02:02 <dzhus> *scala
12:02:13 <MagneticDuck> hyped-over?
12:02:29 <pow4h>  I have int fd=rb->open("/myfile",O_RDONLY);   char array[10];   rb->read(fd,array,1);   rb->splashf(100,"%d",fd);   rb->splashf(100,"%d",array[0]);.   Is char array[10]; the only line of code responsible for displaying the data file's bits as characters?
12:06:01 <MagneticDuck> I believe you have a few typos there...??
12:06:19 <pdxleif> Is that C?
12:06:27 <MagneticDuck> Looks like it...????
12:06:32 <byorgey> MagneticDuck: pow4h already got kicked.  Apparently freenode realizes that C counts as spam ;)
12:06:41 <MagneticDuck> LOL!!
12:06:51 <pdxleif> C++, I think
12:07:18 <byorgey> looks like valid C to me.
12:07:25 <byorgey> of course that also makes it valid C++.
12:07:46 <byorgey> oh, wait, there's a declaration in the middle
12:07:54 <pdxleif> I didn't know if the -> pointer deref stuff was in C...
12:07:58 <MagneticDuck> Ow! My eyes! C... ow, ow... cannot understand logic... why can't you just test if two strings are equal to each other without using a specialized function...
12:08:04 <byorgey> pdxleif: yes, it is
12:08:09 <byorgey> but! who cares! ;)
12:08:35 <dmwit> byorgey: http://www2.research.att.com/~bs/bs_faq.html#C-is-subset ;-)
12:09:05 <dmwit> MagneticDuck: ...what do you think you do in other languages? (Hint: you use a specialized function.)
12:09:23 <byorgey> dmwit: ah, I stand corrected
12:09:35 <byorgey> should have known there would be strange corner cases =)
12:09:38 <MagneticDuck> dmwit: Not in Pascal or Mathematica, that's all I know.
12:10:07 <nulloid> Hi all. I have a question with Data.Lens and Template Haskell
12:10:27 <monochrom> this case probably counts as C (and same behaviour) if you move the declaration
12:11:23 <MagneticDuck> bye everyone
12:11:26 <nulloid> I have a data type, for which I made lenses with $(makelLenses [''MyDataStructure]). Is there any way to export the generated functions? I've searched the web, but only found a ghc ticket for export list modifyin, which was 2 yrs ago :)
12:12:51 <nulloid> (the ticket in ghc was for template haskell)
12:15:48 <edwardk> nulloid: if you don't put an export list on the module, are they being exported then?
12:16:10 <nulloid> they are, but that's kinda unelegant for me :)
12:16:22 <edwardk> nulloid: yeah its rather unfortunate =/
12:16:30 <nulloid> so I have to livbe with that.
12:16:33 <nulloid> -b
12:16:44 <nulloid> well, thanks then :)
12:17:02 <edwardk> nulloid: you can always put the data type and lens definitions in an 'Internal' module, then re-export them from the module that you want people to use
12:17:08 <edwardk> that way you can hide the _'d ones etc.
12:17:16 <nulloid> hmmm
12:17:23 <edwardk> that gives you enough of a phase separation that the TH issue goes away
12:17:40 <nulloid> that's a good idea. I'll give it a try :)
12:21:04 <mkscrg> what other languages make use of referential transparency besides Haskell?
12:21:51 <ion> You can use referential transparency to your advantage in all languages.
12:26:31 <mkscrg> ion: sure, but you can't rely on it the way you can in haskell
12:27:03 <rostayob> woah ddc surely has a lot of tests.
12:27:05 <rostayob> a lot.
12:28:49 <ski> mkscrg : Clean,Mercury
12:29:08 <mercury^> ski: you called?
12:29:08 <ski> also proofy stuff like Agda,Coq,Twelf
12:29:35 <ski> mercury^ : no, the programming *language* Mercury :)
12:29:43 <mercury^> :)
12:29:45 <ski> (unless you are a programming language ?)
12:29:56 <mercury^> The funny thing is that I was not alerted. I just randomly looked at this channel when you wrote that.
12:30:07 <ski> hehe
12:30:17 <mercury^> I had not done so in at least 30 minutes.
12:30:40 <mkscrg> are those also languages that enfore purity?
12:30:44 <mkscrg> *enforce
12:30:58 <monochrom> I think so
12:31:31 <mkscrg> the usefulness of referential transparency in Haskell seems to stem from enforcing purity
12:31:37 <mkscrg> but i haven't put a lot of thought into that idea
12:32:38 <zerax> Does the former not require the latter?
12:33:08 <ski> @where purely-functional
12:33:08 <lambdabot> "What is a Purely Functional Language?" by Amr Sabry in 1993-01 at <https://www.cs.indiana.edu/~sabry/papers/purelyFunctional.ps>
12:33:42 <Cale> "purity" generally refers to referential transparency
12:35:16 <mkscrg> Cale: aha, provide the right definitions and the question becomes trivial :)
12:38:47 <nulloid> edwardk, if I use your internal-module trick, I have to write the accessor functions in the export list explicitly, right?
12:38:51 <rostayob> cods: what was that
12:38:54 <rostayob> oops, copton
12:38:58 <rostayob> fuck, copumpkin
12:39:00 <nulloid> :D
12:43:55 <nulloid> because I gues I can write those functions right away in the export list, and then no internal module would be needed...
12:44:10 <nulloid> I'll try it.
12:45:08 <nulloid> yup, it works that way
12:46:17 <nulloid> I tried to have GHC automatically generate functions end export them by using the record syntax, but namespace collision is the point where I think my elegancy have to stop. :)
12:46:43 <nulloid> Thanks for the trick, though :)
12:46:43 <bxc> someone recommended a faster replacement for ld here i think once
12:46:48 <bxc> or rather a less memory intensive one
12:47:13 <bxc> anyone know what that was?
12:47:22 <copumpkin> rostayob: huh?
12:48:38 <mike-burns> gold
12:48:44 <mike-burns> bxc: ^
12:49:29 <bxc> though looks like http://hackage.haskell.org/trac/ghc/ticket/5240 suggests a recent GHC will use less
12:50:03 <Veinor> blah, like nothing that parses haskell works with quasiquoters
12:50:04 <Veinor> bxc: gold?
12:50:15 <bxc> Veinor: you lose by 3 lines.
12:50:24 * mike-burns wins!
12:50:52 <bxc> this thing has taken almost half a nhour to compile on my VPS that takes 20s on my laptop
12:50:55 <bxc> its just living in swap
12:54:55 * bogwonch
13:00:31 * hackagebot DysFRP 0.1 - dysFunctional Reactive Programming  http://hackage.haskell.org/package/DysFRP-0.1 (MarekMaterzok)
13:00:33 * hackagebot DysFRP-Cairo 0.1 - dysFunctional Reactive Programming on Cairo  http://hackage.haskell.org/package/DysFRP-Cairo-0.1 (MarekMaterzok)
13:02:26 <geekosaur> o.O
13:03:26 <monochrom> haha, "Simple imperative implementation of FRP"
13:05:42 <dzhus> Racket has nice FRP language
13:05:56 <dzhus> with animations and hookers
13:08:24 <yin> hey, I'm wondering what really is the empty list's type... Is it forall a.[a] or [forall a.a]? They almost behave the same except when I take the head, one diverges, one throws exception...
13:09:15 <ski> > let a :: [forall a. a]; a = [] in a :: String
13:09:16 <lambdabot>   Couldn't match expected type `GHC.Types.Char'
13:09:16 <lambdabot>         against inferred type...
13:09:28 <ski> yin : it's `forall a. [a]'
13:09:56 <yin> ois... I forgot to put the type annotation, so [bot] gets inferred as something else ...
13:10:09 <ski> > let foo :: (forall a. [a]) -> (); foo _ = () in foo ""
13:10:10 <lambdabot>   Couldn't match expected type `a'
13:10:10 <lambdabot>         against inferred type `GHC.Types.C...
13:10:12 <ski> > let foo :: (forall a. [a]) -> (); foo _ = () in foo []
13:10:13 <lambdabot>   ()
13:10:32 <ski> yin : `[bot]' ?
13:10:54 <yin> ski: bot=bot... that's forall a.a right?
13:11:24 <yin> then I put bot in [bot]... I expect to have a [forall a.a]
13:11:40 <yin> but it turns out that it's not
13:12:01 <dzhus> what are get‚Ä¶ functions for in various Data.Monoid wrappers?
13:12:10 <dzhus> like getAll, getSum, getDual
13:12:15 <yin> [bot] gets the same type as the empty list
13:12:40 <ski> > let a :: [forall a. a]; a = [fix id] in head a
13:12:41 <yin> I can even use (1:[bot], True:[bot])
13:12:44 <lambdabot>   mueval-core: Time limit exceeded
13:13:11 <yin> > let a = [fix id] in head a
13:13:12 <ski> yin : because each use of `bot' gets the type `a', for a *fresh* type-variable `a'
13:13:15 <lambdabot>   mueval-core: Time limit exceeded
13:13:33 <yin> ski: actually I used the same bot
13:13:33 <ski> then in `[bot]' the generalizing (if any) happens outside of this, getting the type `forall a. [a]'
13:13:53 <ski> yin : i didn't imply anything else
13:13:54 <yin> > let x = [bot] in (1:x, True:x)
13:13:55 <lambdabot>   Not in scope: `bot'
13:14:07 <yin> > let x = [fix id] in (1:x, True:x)
13:14:10 <lambdabot>   mueval-core: Time limit exceeded
13:14:12 <monochrom> [forall a. a] is a rank-2 type. normally haskell doesn't do it.
13:14:12 <ski> > let bot = bot; x = [bot] in (1:x, True:x)
13:14:16 <lambdabot>   mueval-core: Time limit exceeded
13:14:43 <ski> (in fact a type requiring `ImpredicativeTypes')
13:15:51 <monochrom> oops, impredicative type. still, normally haskell doesn't do it.
13:16:35 <yin> interesting, when I type let x = [bot] in 'a' : x in ghci I get "a ... without the right quote mark and diverges
13:17:13 <monochrom> sure, the type of 'a':x is [Char]
13:17:30 <yin> monochrom: I turned the -XImpredicativeTypes switch on. Will that work?
13:17:50 <monochrom> no, it is largely unimplemented
13:18:10 <monochrom> unfinished
13:18:17 <yin> got it
13:18:59 <ski> yin : now try `fix error' and `interact error'
13:20:40 <yin> monochrom: so that means although [bot] should have type [forall a.a] it is inferred as forall a.[a]?
13:21:11 <monochrom> I disagree with "should"
13:21:19 <rwbarton> it should not have type [forall a. a] (except to the extent that [forall a. a] is basically the same as forall a. [a])
13:21:42 <rwbarton> think of it like this
13:21:45 <rwbarton> let a be any type
13:21:49 <rwbarton> then we have bot :: a
13:21:52 <rwbarton> so [bot] :: [a]
13:21:58 <rwbarton> therefore, [bot] :: forall a. [a]
13:22:21 <yin> but [bot] behaves differently from [], how do you explain this if they have the same type?
13:22:38 <rwbarton> different values of the same type can be different. no surprises there
13:22:44 <ski> `[bot]' is a singleton list, `[]' is an empty list
13:23:01 <rwbarton> > (null [], null [undefined])
13:23:02 <lambdabot>   (True,False)
13:23:06 <monochrom> 'a':[] has type [Char]. 'a':[bot] has type [Char]. I don't see a difference
13:23:23 <rwbarton> what specific different behavior are you thinking of?
13:23:31 <ski> (.. you can go from `forall a. [a]' to `[forall a. a]', if you allow impredicative instantiation)
13:24:41 <monochrom> [[], [], []] has type forall a. [[a]], i.e., same a over all three []'s. [[bot], [bot], [bot]] has type forall a. [[a]], i.e., same a over all three [bot]'s. I still don't see a difference.
13:25:55 <quicksilver> because of the way HM inference works, though.
13:26:09 <quicksilver> [[],[],[]] is a valid term of type [[forall a . a]]
13:26:15 <quicksilver> but that isn't its principal type.
13:26:17 <yin> I'm trying to see if this can cause problems..
13:26:29 <quicksilver> and that latter type would never be inferred in an HM-system
13:27:24 <yin> quicksilver: do you mean [forall a.[a]]?
13:28:14 <c_wraith> that's a third option
13:29:37 <quicksilver> yin: no, I didn't.
13:30:53 <mkscrg> for a Vector Int, am I better off using Data.Vector.Storable or Data.Vector.Unboxed?
13:31:18 <c_wraith> Unboxed
13:31:28 <c_wraith> Unless you're going to be passing to to FFI code
13:32:27 <osager> hi all
13:32:35 <mkscrg> c_wraith: thanks
13:32:38 <osager> what's wrong with this function definition
13:32:38 <osager>  6 checkPiKaChu :: Maybe String->Bool
13:32:38 <osager>  7 checkPiKaChu Nothing = False
13:33:01 <c_wraith> it capitalizes pikachu strangely.  Also, please use hpaste or the like
13:33:19 <osager> i get an error for this function saying that checkPiKaChu have different numbers of arguments
13:33:21 <ski> you seem to be missing the other case ..
13:33:29 <ski> oh, you want brackets
13:33:33 <c_wraith> osager: you probably forgot parens
13:33:47 <ski> `checkPiKaChu (Just x) = ..x..' instead of `checkPiKaChu Just x = ..x..'
13:33:59 <osager> ok i'll try ski
13:34:02 <osager> thnkx
13:34:08 <metazilla> hey all, I'm having some trouble using BitGet to read data - http://hpaste.org/64564
13:34:17 <metazilla> it looks like its reading the bits in the wrong order
13:34:38 <yin> quicksilver: But if it is forall a.[[a]], then the three []'s inside [[],[],[]] should have the same a?
13:34:46 <ski> (since `checkPiKaChu Just x = ..x..' is parsed as `(checkPiKaChu Just) x = ..x..', which isn't what you want -- this is just normal function application precedence here, btw)
13:35:31 <monochrom> osager: clearly, the problem is in line 8. you should learn to not omit information
13:35:31 <hpaste> osager pasted ‚Äúwhat's wrong with this function‚Äù at http://hpaste.org/64567
13:35:39 <ski> yin : yes, but that `a' could possibly be `forall b. b' (with impredicative instantiation), which would make it into `[[forall b. b]]'
13:36:05 <osager> hi ski
13:36:09 <osager> i tried but still same problem
13:36:09 <osager> pls check my hpaste code
13:36:32 <osager> error message is: (2 of 3) error:  Equations for `checkPiKaChu' have different numbers of arguments tc.hs:7:1-28 tc.hs:(11,1)-(15,20)
13:36:32 <dzhus> osager: put (Just []) pattern in parens
13:36:48 <yin> ski: but that will not be empty, it contains something that diverges
13:36:50 <osager> i did
13:37:09 <ski> osager : you still didn't put in brackets around the argument
13:37:20 <osager> ok
13:37:27 <osager> i get it now
13:37:28 <osager> Thanks !
13:37:51 <ski> yin : no, it just says that every element has to have that type, it doesn't say that there has to be an element
13:38:22 <yin> ski: then they can only contain bot?
13:38:46 <ski> > case [] :: [forall a. a] of [] -> ()  -- see, a list of type `[forall a. a]' can be empty
13:38:46 <lambdabot>   ()
13:38:52 <ski> yeah
13:39:26 <yin> but the fact is that I can use something like let x = [[],[]] in (1:(head x), True:(head (tail x)))
13:39:46 <yin> this means the []'s inside [[],[]] has type forall a.[a] and not [forall a.a]
13:39:54 <ski> yes, because `x' is polymorphic, getting type `forall a. [[a]]'
13:39:55 <ski> yes
13:40:15 <ski> i was merely saying that `[forall a. a]' is a *possible* type of `[]'
13:40:25 <yin> but then [[],[] should have type [forall a.[a]]
13:40:28 <ski> (assuming `ImpredicativeTypes')
13:40:54 <ski> yin : no, since generalization doesn't happen at every expression level
13:41:11 <ski> it only happens at the level of (`let'-)bindings
13:41:48 <yin> ski: If [[],[]] has type forall a.[[a]] and gets instantiated into [[forall a.a]], then the two []'s can only contain bot. If it gets instantiated into [[Int]], then the two []'s can only contain Int, in any case, the two []'s will contain the same type.
13:41:49 <ski> (including `where', but not lambda-bound stuff .. also not pattern-bindings in `let'/`where')
13:42:14 <quintessence> > let x = [[], []] in case x of [a, b] -> (1:a, True:b)
13:42:14 <lambdabot>   No instance for (GHC.Num.Num GHC.Bool.Bool)
13:42:15 <lambdabot>    arising from the literal `1'...
13:42:21 <yin> then it contradicts the fact I can use let x = [[],[]] in (1:(head x), True:(head (tail x)))
13:42:50 <ski> yin : `[[],[]]' has type `[[a]]' for any type `a'. when you bind `x' to that, then *`x'* get the generalized type `forall a. [[a]]'
13:42:59 <quintessence> yin: no, using x instantiates its polymorphic type in a different way each time
13:43:32 <ski> in addition, what quintessence said
13:44:23 <quintessence> (this is why it works with head and head.tail, but fails with pattern matching)
13:44:33 <shergill> let generalizations are bad
13:44:44 <shergill> *i thought let generalizations were bad
13:45:21 <yin> shergill: I think they are wrong, but they seem to have some interesting behaviors which seemingly correct
13:45:31 <ski> yin : only at each *use* of `x' does the universal get instantiated. also, essentially it makes a *copy* with a specific instantiation -- i.e. how one occurance of `x' is used *doesn't* affect what types the other occurance of `x' can be used at
13:46:11 <yin> ski: now this makes sense
13:46:28 <ski> do the first occurance of `x' gets the type `[[Int]', while the second occurance gets the type `[[Bool]]'
13:46:31 <ski> this is how
13:46:46 <ski> > (length [0,1,2],length [False,True,False])
13:46:47 <lambdabot>   (3,3)
13:46:48 <ski> works, btw
13:47:38 <dzhus> does newtype support existential?
13:47:43 <ski> each use of `length' starts with the general type `forall a. [a] -> Int', and each of them gets instantiated : to `[a0] -> Int' resp. `[a1] -> Int'
13:47:47 <stulli> ski: Hi, just wanted to thank you for reviewing my hpaste a while ago, much appreciated!
13:48:03 <shergill> yin: could you give a concrete example?
13:48:05 <ski> then it discovers that `a0' must be `Integer' (say), and that `a1' must be `Bool'
13:48:19 <ski> note that `a0' and `a1' here are meta-variables, which will be instantiated to specific types
13:48:41 * ski tries to recall which hpaste that was
13:48:50 <ski> dzhus : unfortunately not
13:49:46 <ski> (it could, in the case you don't pack a constraint on the existentially quantified tyvars -- but that's currently not allowed)
13:50:52 <yin> shergill: [bot], because bot has type forall a.a, [bot] should have type [forall a.a], but let generalize it into forall a.[a], the same type of empty list. But because you can't do anything with bot, you seem to get the same behavior
13:51:29 <stulli> ski: http://hpaste.org/64405 "I see a pattern..."
13:52:36 <stulli> It'll probably take me a while to understand your suggestions
13:52:37 <ski> right
13:53:03 <identity_> Hmm.
13:53:13 <identity_> Wait, I can write stuff without registering?
13:53:15 <ski> the `undefined's look a bit unfortunate
13:53:21 <ski> identity_ : why not ?
13:53:41 <identity_> ski: I just thought I remembered registration being mandatory
13:53:42 <identity_> my bad.
13:53:49 <ski> it depends on channel
13:53:54 <identity_> No, I mean here.
13:54:12 <identity_> I was probably confusing you guys with #c++ ;)
13:54:13 * identity_ hides
13:54:21 * ski can't recall that flag being turned on in here
13:54:22 <hpaste> metazilla pasted ‚Äútrouble with BitGet‚Äù at http://hpaste.org/64568
13:54:33 <ski> (but then, i'm usually identified, so i probably wouldn't notice)
13:54:38 <metazilla> could someone please take a look at this ^
13:54:40 <c_wraith> sometimes that flag gets enabled for short terms here, when someone is spamming
13:54:51 <quicksilver> ski: we have turned it on once or twice for a period of some hours
13:54:55 <identity_> c_wraith: I see.
13:55:04 <ski> c_wraith,quicksilver : ok
13:55:05 <quicksilver> if there is a persistent spam issue that freenode staff couldn't quickly fix.
13:55:17 <quicksilver> only a handful of occasions I think.
13:55:19 * ski can't even recall which flag it is ..
13:55:32 <dzhus> Maybe is a Monad, and Monad is a Maybe.
13:55:39 * hackagebot type-unary 0.2.1 - Type-level and typed unary natural numbers, inequality proofs, vectors  http://hackage.haskell.org/package/type-unary-0.2.1 (ConalElliott)
13:55:41 * hackagebot DysFRP-Craftwerk 0.1 - dysFunctional Reactive Programming on Craftwerk  http://hackage.haskell.org/package/DysFRP-Craftwerk-0.1 (MarekMaterzok)
13:55:43 * hackagebot BiobaseTurner 0.2.2.0 - Import Turner RNA parameters  http://hackage.haskell.org/package/BiobaseTurner-0.2.2.0 (ChristianHoener)
13:56:36 <nand`> Is http://www.haskell.org/haskellwiki/Gentoo/HaskellPlatform still relevant to installing haskell-platform under gentoo?
13:56:45 <ski> stulli : would it be sensible to make a version of `findK' which only gave the first resp. the second part of the pair ?
13:57:38 <ski> stulli : or do you compute the results in an intertwined way (alternatively it's an expensive computation) so that it'd be bad to compute them separatedly
13:58:17 <ski> stulli : i'm asking, since if you did that, you could skip the `undefined', which would probably simplify stuff
13:58:49 <ski> stulli : one could possibly define something mealy/moore-like alternatively
13:59:09 <osager> hi how do i use pattern matching to see if a string begins with a certain prefix
13:59:34 <osager> for example i can us "ka" isPrefixOf "kaa"
13:59:44 <nejucomo> Is it possible to define arbitrary pure functions which evaluate to types in standard haskell?
13:59:47 <ski> > let unfoo ('f':'o':'o':s) = Just s; unfoo _ = Nothing in unfoo "foobar"
13:59:48 <lambdabot>   Just "bar"
13:59:56 <osager> but can i use: | "k":"a":word
13:59:56 <osager> ?
14:00:04 <nejucomo> If not, is this possible with template haskell or some other variation?
14:00:09 <osager> ok
14:00:16 <ski> > let unfoo (stripPrefix "foo" -> Just s) = Just s; unfoo _ = Nothing in unfoo "foobar"
14:00:17 <lambdabot>   Just "bar"
14:00:18 <osager> i should have use single quote
14:00:41 <stulli> ski: I need the resulting strings too, since other computations need the results. I tried using the original strings but that was too slow.
14:00:59 <dmwit> > let unfoo = stripPrefix "foo" in unfoo "foobar"
14:01:00 <lambdabot>   Just "bar"
14:01:09 <stulli> It's part of a project euler problem btw
14:02:14 <yin> I think 1 : [bot] works as follows... At first [bot] has type [forall a.a], which mean a  list containing universal elements, you can do whatever to them, certainly, because they diverge, so that's vacuously true. But then you put an Int into the list, so now you do an intersection of the things you can do to 1 and bot, the result is the things you can do to Int. So the list's type gets lowered to [Int].
14:02:17 <dmwit> nejucomo: No, it is not possible in Haskell. You might like Agda, though.
14:02:19 <ski> stulli : yeah, what i'm asking is whether it would be sensible to define two functions `findKA',`findKB' having the semantics `findKA n strings = fst (findK n strings)',`findKB n strings = snd (findK n strings)' (but implemented more directly/efficiently)
14:02:37 <dmwit> nejucomo: Also, there are various extensions for writing functions that *take* types and compute types.
14:03:03 <ski> osager : did my two examples answer your question ?
14:03:03 <dmwit> nejucomo: (But nothing for writing functions that take values and compute types, because types are erased at runtime and values aren't.)
14:03:08 <nejucomo> Is there a wiki page or other list of such variations?
14:03:17 <hpaste> dzhus pasted ‚ÄúReiterate on PossiblyNull containers‚Äù at http://hpaste.org/64570
14:03:22 <scooty-puff> nejucomo: you might want to take a look at DataKinds
14:03:35 <nejucomo> dmwit: Right.  I am interested in compile-time type-domained functions.
14:03:39 <nejucomo> Ok.
14:03:49 <xivix> @pl \x -> '[' ++ x ++ ']'
14:03:49 <lambdabot> ('[' ++) . (++ ']')
14:03:59 <xivix> heh
14:03:59 <dmwit> nejucomo: There are many tricks you can play with GADTs to connect the term and type level, if you like, to make tight connections between values and types. But in the end, all of the type-level functions take types, not values.
14:04:21 <xivix> oops, those ain't strings
14:04:22 <ski> nejucomo : you probably want either Template Haskell or `TypeRep' (maybe both)
14:04:31 <xivix> @pl \x s -> s ++ x ++ s
14:04:31 <lambdabot> ap (++) . (++)
14:04:33 <nejucomo> Thanks for the feedback.
14:04:35 <xivix> neat
14:04:47 <hpaste> identity_ pasted ‚Äúsome helpful title‚Äù at http://hpaste.org/64571
14:04:59 <identity_> I would appreciate it if one of you gurus could take a look
14:05:18 <ski> (nejucomo : but there may be alternate ways of achieving your main goal, so you should look at GADTs and type families as well, to understand what it's about, and what one can do with them)
14:05:21 <identity_> I *think* I remember seeing something like this once, but It's been a while since I've had time or will to write any real code, so I'm rusty as all hell.
14:05:23 <temp1> damn, can't hpaste wordwrap?
14:05:25 <stulli> ski: Well, those are infinite strings and the number denotes the nth string. I'll need to think a bit about it, the infinite strings are part of another infinite list...
14:05:28 <identity_> uh
14:05:39 <identity_> Obviously, it doesn't break lines automatically, so I'll repaste it
14:06:17 <ski> yin : not quite
14:06:23 <dzhus> M-q plox
14:07:02 <hpaste> identity_ pasted ‚Äúsome helpful title(fixed)‚Äù at http://hpaste.org/64572
14:07:30 <yin> ski: I just think that may be the actually thing happening, but the type forall a.[a] given to [bot] seems to make this lowering process automatic
14:07:36 <nejucomo> ski: Well, to be concrete, I had imagined a function which takes a parsec parser and resulting types as input and produces a new parser and new types as output, where the relationship between input types and output types has an anlogous "structure".
14:07:37 <ski> yin : what happens is that `bot' in `[bot]' get type `_a', where `_a' is a yet-to-be-determined type. then when you do `False:[bot]' the type `Bool' and `_a' are *constrained* to be the *same* type, which means that now the system knows that `_a' is the same as `Bool', so the type of that whole expression is now `[Bool]'
14:08:04 <stulli> ski: If you are interested, that's the problem http://projecteuler.net/problem=238 I'll probably only work on this on the weekend again
14:09:05 <stulli> (disclaimer: I didn't solve all preceding problems...)
14:09:07 <yin> ski: you are talking about another interpretation. I think both way of thinking will work
14:09:37 <identity_> Anyone interested? :)
14:09:54 <dmwit> identity_: The problem is insufficiently explained for meaningful answer.
14:10:07 <identity_> I see, not surprising.
14:10:22 <identity_> Having a hard time explaining what I want to do, and it may be because it's not possible at all
14:10:41 * hackagebot scion-browser 0.2.7 - Command-line interface for browsing and searching packages documentation  http://hackage.haskell.org/package/scion-browser-0.2.7 (AlejandroSerrano)
14:10:41 <identity_> In fact, it may just not be possible due to the fact that functions aren't Show-able
14:10:48 <byorgey> identity_: it may be possible but it is probably not worth the extreme type system contortions involved.
14:10:58 <identity_> byorgey: I see
14:11:11 <byorgey> identity_: the bigger problem is that functions aren't parse-able if you don't know what type you expect to get in the firts place.
14:11:17 <byorgey> *first
14:11:22 <yin> ski: my way is to say "finding common denominator when consing happens", your way is to say "set it to a non-deterministic type" and let it bind to whatever it is used for
14:11:29 <identity_> Yeah, I guess
14:11:55 <byorgey> identity_: however, one alternate approach is to have your configuration file *be* Haskell code
14:12:06 <byorgey> identity_: take a look at xmonad for an example of doing things this way.
14:12:11 <identity_> Anyway, thanks for the help! "Release is a feature" so I'll go and try to write some code instead of trying to contort the universe to make my code be as elegant as possible
14:12:51 <byorgey> identity_: the idea is that instead of making up a configuration file format, you make a little configuration DSL, embedded in Haskell
14:13:01 <yin> ski: because forall a.a is universal, so the common denominator with any other type T, is T. So that happens to match your explanation
14:13:14 <identity_> byorgey: Yeah, I had wondered about that. Are they just using the internal ghc api?
14:13:22 <byorgey> identity_: no!
14:13:24 <dmwit> No internal APIs involved.
14:13:39 <dmwit> xmonad is a library; configuration involves writing a window manager that calls those library functions.
14:13:40 <osager_> hi my pattern matching is not exhaustive, how do i express "otherwise" in pattern matching ?
14:13:48 <identity_> Ooh! Do elaborate on this wondrous magic
14:13:49 <osager_> i know there is "otherwise" in guards
14:13:57 <c_wraith> use a _ for the pattern that you don't care about
14:14:00 <quintessence> osager_: _ is a pattern that matches anything and binds no variables
14:14:12 <yin> ski: this is like finding the gcd of 0 and any other number x
14:14:14 <quintessence> (incidentally, "otherwise" just means "True")
14:14:23 <byorgey> identity_: to use xmonad you have to make a .hs file that has something like   main = xmonad $ configuration
14:14:23 <osager_> ok
14:14:25 <osager_> thanks
14:14:27 <ski> yin : well, in a sense you're right with "do an intersection of the things you can do to 1 and bot" and "finding common denominator when consing happens" -- but it's not really an intersection (it could be, if we had supertypes)
14:14:35 <identity_> byorgey: Aye, I am slightly familiar with it
14:14:37 <byorgey> identity_: and xmonad provides lots of tools for building such configurations
14:14:49 <byorgey> identity_: and a special function 'xmonad' which takes a configuration and runs a window manager.
14:15:19 <ski> yin : also, my explanation wasn't "set it to a non-deterministic type" :) it was more like when you're solving an equation, you first don't know what value the variable you're solving for has to be to satisfy the equation
14:15:35 <byorgey> identity_: the only slightly tricky magic in xmonad is how it can restart itself on the fly.  but that's not essential to the idea (and if you cant to do that you can look at how xmonad does it)
14:15:52 <yin> ski: that's what I meant... maybe the word nondeterministic is not the right one
14:15:53 <dmwit> ?hackage dyre
14:15:54 <lambdabot> http://hackage.haskell.org/package/dyre
14:16:04 <dmwit> identity_: ^^
14:16:14 <identity_> Well, that is not a necessity for my program, so I guess I'll let that lie. Thanks though.
14:16:15 <byorgey> oh, right, I forgot about dyre!
14:16:39 <identity_> But for once, I'm trying hard not to be led astray out on some magical, wondrous tangent of elegance and actually, like.. release a working app.
14:16:52 <yin> ski: It's a little like quantum mechanics. When you look at it, it collapses to whatever makes sense
14:17:09 <identity_> See http://xkcd.com/974/
14:17:11 <ski> (incidentally, `gcd 0 0' should be `0')
14:17:50 <byorgey> identity_: hehe, indeed.  but seriously, dyre may be exactly what you want
14:18:30 <Clint> i wonder how well that works for preserving tcp connections
14:18:31 <yin> ski: that makes sense :-)
14:19:05 <yin> ski: or should it exist?
14:19:40 <dmwit> Clint: There are probably situations where dyre is inappropriate. That said, doesn't exec preserve fds and stuff?
14:19:43 <identity_> I'll check it out. Thanks for your replies, dmwit & byorgey
14:19:50 <yin> ski: it can be whatever number
14:20:17 <Clint> dmwit: yep
14:20:41 * hackagebot BiobaseVienna 0.2.2.0 - Import Vienna energy parameters  http://hackage.haskell.org/package/BiobaseVienna-0.2.2.0 (ChristianHoener)
14:20:52 <ski> yin : yes, it should exist, "greatest" is to be taken wrt the (multiplicative) divisibility order, not wrt the usual additive order
14:21:33 <yin> ski: but why 0?
14:21:51 <ski> yin : because `0' is the greatest element in the divisibility order
14:21:56 <ski> everything divides zero
14:22:46 <yin> ski: but 5 is greater than 0 and it divided both 0 and 0
14:22:48 <ski> the point re `gcd' is that `forall a b d.  d | gcd a b  <=>  d | a /\ d | b' should hold
14:23:07 <ski> yin : no, `0' is greater than `0', in the *divisibility* ordering : `5 | 0'
14:23:15 <ski> er `0' is greater than `5'
14:23:41 <ski> the usual additive ordering `0 =< 5' is irrelevant here
14:26:30 <yin> ski: not sure what divisibility means here
14:28:12 <yin> ski: ah got it from "Order Theory"
14:28:35 <ski> `a' divides `b', traditionally written `a | b', means that `exists k. k * a = b'
14:29:15 <ski> from the characterizing property `forall a b d.  d | gcd a b  <=>  d | a /\ d | b', we can derive `forall a b. gcd a b | a /\ gcd a b | b', &c.
14:30:14 <ddarius> Implying half of the universal property from the characterization via representability.
14:30:14 <lambdabot> ddarius: You have 1 new message. '/msg lambdabot @messages' to read it.
14:45:01 <Nisstyre> is the function globDir in System.FilePath.Glob lazy?
14:45:46 <c_wraith> probably not.  It'd be kind of hard to do lazily.
14:45:50 <c_wraith> as well as ill-defined
14:45:55 <Nisstyre> c_wraith: I want a lazy glob function
14:46:17 <Nisstyre> c_wraith: I suppose I could try and write one myself
14:46:22 <c_wraith> what would the semantics be?
14:46:48 <Nisstyre> c_wraith: if new files get added to the directory after returning the first file it will return those new files later
14:47:46 <c_wraith> What if a file is renamed? What if a file's content is changed?  What if a file is removed?  What if a file is removed, then a new file with the same name is written?
14:48:01 <c_wraith> This seems nearly impossible to have sane semantics for.
14:48:21 <c_wraith> "the current snapshot" seems like the only sane thing to do.
14:48:34 <Nisstyre> c_wraith: if a file is renamed but not yet evaluated then it won't be returned by the function (assuming it doesn't match the pattern)
14:49:10 <ehy_> > fix error
14:49:11 <lambdabot>   "*Exception: *Exception: *Exception: *Exception: *Exception: *Exception: *E...
14:49:54 <Nisstyre> c_wraith: I wrote a version of this in Python (sort of) using a stack
14:50:07 <c_wraith> It seems very bug-prone.
14:50:12 <Nisstyre> I would push new files onto the stack after each file was looked at (if new files were there)
14:50:15 <c_wraith> Any assumptions you make about its behavior will be wrong.
14:50:19 <Nisstyre> I kept track of the files already seen with a set
14:53:25 <morice> ciao
14:53:31 <morice> !list
14:54:12 <c_wraith> seems like the strongest assumption you can make is "this will return *some* files that match the pattern"
14:54:29 <Nisstyre> c_wraith: yes
14:54:54 <Nisstyre> c_wraith: not necessarily all of the files currently in the directory that match the pattern
14:55:16 <tgeeky_> ls -l \.\*?
14:57:06 <zhulikas> @hoogle a -> m a
14:57:06 <lambdabot> Data.Generics.Aliases unGM :: GenericM' m -> forall a. Data a => a -> m a
14:57:07 <lambdabot> Prelude return :: Monad m => a -> m a
14:57:07 <lambdabot> Control.Monad return :: Monad m => a -> m a
15:03:55 <Veinor> ... apparently T.stripPrefix causes my system to hang
15:04:14 <Veinor> (where T is Data.Text)
15:06:51 <jfischoff> is there a more Either version of partial-lens?
15:07:08 <jfischoff> ignore the "more"
15:11:47 <Veinor> fixed in 0.11.1.13, whatever it is
15:13:20 <slack_> err ^^
15:13:52 <byorgey> hi slack_
15:14:41 <Jafet> So, how 'bout them monads
15:15:18 <c_wraith> I heard they gave up too many touchdowns in the third inning yesterday.
15:15:32 <c_wraith> Need to protect the goal better.
15:16:25 <Jafet> Ouch. But that's what the protector pads are for, right?
15:26:21 <dibblego> \p -> filter (not . p) -- is this in the base library somewhere?
15:26:53 <byorgey> no
15:31:36 <c_wraith> you mean the thing that seems like it would naturally be named filter?
15:31:53 <c_wraith> what's currently named filter seems more like it would be naturally named keep
15:33:55 <byorgey> it doesn't seem to me like "filter" has a particular connotation either way.
15:34:45 <byorgey> because filters are used both for both purposes: keeping or throwing away whatever gets caught by the filter.
15:35:00 <c_wraith> not when used as a verb
15:35:02 <ski> called include/3 and exclude/3 in SWI-Prolog ..
15:35:29 <c_wraith> If I were to filter the multiples of three, my reading is that I'm removing the multiples of three.
15:36:31 <byorgey> hmm, maybe you're right
15:37:41 <zhulikas> @hoogle Int -> Html -> Html
15:37:41 <lambdabot> Prelude scaleFloat :: RealFloat a => Int -> a -> a
15:37:41 <lambdabot> Text.Regex.Base.RegexLike after :: Extract source => Int -> source -> source
15:37:42 <lambdabot> Text.Regex.Base.RegexLike before :: Extract source => Int -> source -> source
15:38:22 <byorgey> I guess even noun-filters are more often used for taking stuff out.  coffee filters, water filters, air filters, oil filters, lens filters ... all are for removing something you don't want
15:38:55 <quintessence> byorgey: on the other hand, they're named after the kind of thing you want to keep
15:39:04 <byorgey> quintessence: hehe, that's true =)
15:39:05 <quintessence> (minus lens filters that is)
15:39:34 <byorgey> quintessence: well, I don't even know if that's a proper term.  Maybe "light filter" is better anyway.
15:40:58 <Nisstyre> c_wraith: strain
15:41:43 <c_wraith> Nisstyre: sounds like I'm pulling a muscle :)
15:41:47 * ski notes there's two different nouns in swedish, "sil","sÂll"
15:42:10 <zhulikas> @hoogle lengthP
15:42:10 <lambdabot> No results found
15:42:15 <zhulikas> is this ok to use?
15:42:25 <zhulikas> it's inside GHC.PArr
15:42:48 <Nisstyre> c_wraith: as in a strainer
15:43:04 <Nisstyre> when you strain out something that implies you want to keep the things that are not matched
15:43:18 <c_wraith> Nisstyre: my point was more that lacking context, I'm going to infer the wrong "strain"
15:43:20 <Nisstyre> er, matched
15:43:23 <Nisstyre> not not matched
15:43:47 <Nisstyre> c_wraith: yeah, I agree
16:03:38 <beyeran> how do I produce the following string: "\0"
16:04:10 <beyeran> if I just type it "\NUL" is returned, and if I type "\\0", then "\\0" is returned...
16:04:27 <sipa> using show?
16:04:40 <c_wraith> beyeran: you aren't distinguishing between the contents of a string, and its printable representation
16:04:44 <sipa> > putStr "\\0"
16:04:45 <lambdabot>   <IO ()>
16:05:02 <c_wraith> you want "\\0", but using show will cause it to be escaped.
16:07:00 <beyeran> when using show I get the following output: "\"\\\\0\"", I just want a string that looks like this: "\0"
16:07:20 <rostayob> beyeran: you're showing the string.
16:07:22 <rostayob> try putStrLn
16:07:29 <rostayob> > show "\\0"
16:07:30 <lambdabot>   "\"\\\\0\""
16:07:34 <rostayob> > "\\0"
16:07:34 <lambdabot>   "\\0"
16:08:49 <beyeran> with putStrLn I don't get the string, I get a message to the console, as far as I know?
16:09:23 <c_wraith> beyeran: why do you think "\\0" is not what you want?
16:09:37 <c_wraith> beyeran: what IO are you doing that outputs it improperly?
16:09:41 <quintessence> beyeran: ghci prints things with "print" (which is putStrLn . show)
16:10:10 <beyeran> quintessence: ok, good to know!
16:10:48 * hackagebot timeout-control 0.1 - Updatable timeouts as a Monad transformer  http://hackage.haskell.org/package/timeout-control-0.1 (NathanHowell)
16:11:06 <beyeran> c_wraith: "\0" should be a part of a concatenated string in whichs other concatenations are already in IO... the result is encrypted via sha1
16:11:07 <c_wraith> beyeran: this is basically the same as every REPL for popular languages.
16:11:58 <c_wraith> beyeran: That's not any explanation of something going wrong.
16:13:50 <beyeran> c_wraith: ok, you're right. The problem is when I use shell's sha1sum for a string which should look the same way (with this \0 in it) the encryption is different than that one I get from ghci
16:14:49 <quintessence> beyeran: yeah, when you're testing things that return strings that would need escaping in haskell source code, you probably want to skip show and putStrLn the result directly
16:15:15 <quintessence> otherwise you have to unescape in your head to see what the real value is
16:15:27 <c_wraith> beyeran: ok, excellent starting point.  Sadly, the tools you're working with here are fiddly.  Both whatever tool you're using in the shell and whatever you're doing in ghci, I suspect they're doing escaping incompatibly, in some way you don't realize.
16:16:08 <chas> cabal question
16:16:13 <c_wraith> with sha1 (and any cryptographic hashing algorithm) it's important to have access to the underlying bytes
16:16:31 <chas> $ ./Setup configure Configuring Cabal-1.10.2.0... Setup: At least the following dependencies are missing: base >=4 && <3 && >=2 && <5, filepath >=1 && <1.3, unix >=2.0 && <2.5
16:16:54 <chas> how can base possibly be satisfied? >=4 && < 3
16:16:56 <rostayob> base >=4 && <3 && >=2 && <5
16:16:58 <rostayob> nice.
16:17:07 <rostayob> chas: don't install cabal like that.
16:17:07 <beyeran> c_wraith: might be possible
16:17:10 <rostayob> install the haskell platform
16:17:18 <chas> i want 7.4.1
16:17:27 <chas> platform is behind
16:17:53 <rostayob> chas: the HP is not "behind"
16:18:15 <rostayob> anyways, cabal should come with GHC
16:18:32 <chas> are you suggesting i install platform and then install 7.4.1 on top of it?
16:18:38 <rostayob> actually
16:18:49 <rostayob> chas: that's what I do
16:19:01 <rostayob> ghc binaries are versioned
16:19:02 <beyeran> quintessence: ok, I'm not really sure if what I do is right, but I think really escaping isn't needed, just the raw string
16:19:09 <rostayob> you can install them one after the other and you'll have both version
16:19:15 <rostayob> then you can use cabal with what compiler you want
16:20:29 <chas> rostayob: ty will try
17:00:49 * hackagebot arx 0.1.1 - Archive execution tool.  http://hackage.haskell.org/package/arx-0.1.1 (JasonDusek)
17:13:51 <startling> are there xmpp libraries with actual docs?
17:15:57 <whatsphere> anyone knows: http://whatsphere.com/whatsphere4/ ?
17:17:41 <Axman6> whatsphere: what is that link? We're not going to click it without knowing what it is first
17:18:05 <whatsphere> lol
17:18:06 <whatsphere> i wonder
17:19:02 <Axman6> seems a hell of a lot like you're spamming to me
17:19:04 <Axman6> @where ops
17:19:04 <lambdabot> shapr Cale glguy dons sjanssen dcoutts Saizan dibblego conal Philippa bos arjanb xerox Heffalump kosmikus wli Pseudonym Igloo quicksilver monochrom Lemmih jmcarthur copumpkin
17:19:56 --- mode: ChanServ set +o shapr
17:20:00 --- kick: whatsphere was kicked by shapr (Kicked by shapr)
17:20:01 <dibblego> whatsphere: please do not spam the channel
17:20:01 <Jafet> A link has been posted, you must click it!
17:21:15 --- mode: shapr set -o shapr
17:46:44 <Kuba> zenzike: hey, it's Jakub :)
17:52:35 <maloi> http://ontwik.com/haskell/simon-peyton-jones-a-taste-of-haskell/ at around 32:20 spj mentioned something like cowie ... isomorphism...i don't understand that right, can someone hear in and give me the right name of it?
17:52:42 <maloi> in part 2
17:56:29 <doserj> maloi: http://en.wikipedia.org/wiki/Curry%E2%80%93Howard_correspondence ?
17:57:44 <Jafet> Cowie-Howahd isomowfism
17:58:11 <shachaf> kowey has an isomorphism?
17:58:16 <rostayob> maloi: it's a lie anyways. A LIE
17:58:27 <shachaf> rostayob: Huh?
17:59:45 <maloi> doserj: Jafet thank you very much, so i misunderstood the names completly :(
18:00:50 <maloi> or misheard is the better word i think
18:03:59 <niteria> a lie?
18:12:13 <tazjin> If I have a string like "169 - libpuzzle1" what's the easiest way to parse it into a tuple of (Int, String) ?
18:12:24 <tazjin> I can't think atm :P
18:12:48 <Jafet> tazjin: import Text.Parsec;
18:12:51 <hpc> @hoogle String -> String -> (String, String)
18:12:52 <lambdabot> Data.List genericSplitAt :: Integral i => i -> [b] -> ([b], [b])
18:13:05 <hpc> yes, parsec
18:13:17 <tazjin> Haven't played around with Parsec yet, lets see. Thanks
18:13:31 <hpc> be aware of ambiguities, like "abc - efg - hij"
18:13:36 <startling> how should i write an xmpp server in haskell? I can only find xmpp client libraries
18:15:20 <Cale> The Network library, or possibly Network.Socket, and perhaps some attoparsec or something along those lines for parsing?
18:15:44 <Cale> If you can't find a pre-existing XMPP server library, you'll basically have to implement the protocol from the ground up.
18:15:59 <startling> yeah, I was hoping I wouldn't have to. oh well
18:16:06 <startling> what's the best xml parsing thing?
18:16:21 <Cale> oh, xml...
18:16:32 <startling> hehe
18:17:40 <startling> well, xmpp message are xml. so.
18:17:46 <Cale> It's been a while since I've done anything with XML, so this might be out of date, but HXT was reasonably decent when I last looked. You may be able to get away with something like hexpat-pickle
18:18:28 <Cale> HXT is kinda more aimed at fancy transformations of XML documents
18:19:13 <Cale> but if you can write some pickler/unpickler pairs for whatever set of possible XMPP messages there are, that should work out pretty nicely
18:19:27 <Cale> http://hackage.haskell.org/packages/archive/hexpat-pickle/0.5/doc/html/Text-XML-Expat-Pickle.html
18:21:25 <startling> Cale: that seems perfect, thanks
18:29:10 <hpc> @tell mauke your domain expired; i was trying to use http://mauke.dyndns.org/stuff/javascript/unicode.html and it wasn't there
18:29:11 <lambdabot> Consider it noted.
18:29:36 <mauke> try mauke.hopto.org
18:30:00 <hpc> oh, nifty
18:35:05 <dstcruz> is it possible to run ghci with a different package database?
18:35:54 * hackagebot hedis-tags 0.1.1 - Tags for hedis  http://hackage.haskell.org/package/hedis-tags-0.1.1 (AlexanderDorofeev)
18:35:56 * hackagebot hedis-pile 0.4.2 - Caching mandatory data with Redis  http://hackage.haskell.org/package/hedis-pile-0.4.2 (AlexanderDorofeev)
18:40:54 * hackagebot wai-middleware-cache-redis 0.2.1 - Redis backend for wai-middleware-cache  http://hackage.haskell.org/package/wai-middleware-cache-redis-0.2.1 (AlexanderDorofeev)
18:42:31 <dstcruz> ah! -package-conf
18:47:08 <Cale> Does anyone happen to know what these  foo.\  cost centres are in profiling output?
18:48:19 <Cale> There seem to be various cost centres appended with varying numbers of occurrences of .\
18:52:56 <vyom> does Control.Monad.State need me to include some dependency apart from base?
18:53:10 <vyom> i am using GHC 7.4
18:53:17 <c_wraith> you need mtl
18:59:36 <vyom> c_wraith: thanks
19:16:38 <cmrn> boo, Axman6
19:17:08 <edwardk> preflex: xseen koninkje
19:17:08 <preflex>  koninkje was last seen on freenode/#haskell 14 days, 22 hours, 32 minutes and 39 seconds ago, saying: * koninkje wonders what APL used for map
19:17:54 <edwardk> hah, i finally got my little bayesian inferene engine to compute random samples from a distribution‚Ä¶ a uniform distribution, but its still a distribution ;)
19:19:21 <roconnor> edwardk: http://search.dilbert.com/comic/Random%20Nine
19:19:41 <edwardk> roconnor: =P
19:21:01 <monochrom> that's very uniform :)
19:21:25 <edwardk> heh
19:21:44 <Jafet1> @google feynman point
19:21:46 <lambdabot> http://en.wikipedia.org/wiki/Feynman_point
19:21:46 <lambdabot> Title: Feynman point - Wikipedia, the free encyclopedia
19:21:59 <edwardk> now i just need to set up the autocorrelation based thinning. that way i can skip 40 of those 9's and report fewer of them ;)
19:22:10 <roconnor> using inference to compute random samples feels like an oxymoron
19:23:05 <Proge> probability is a strange beast
19:23:26 <roconnor> well, I guess it is better than using random samples to do inference.
19:23:42 * roconnor ponders that
19:28:19 <Proge> its funny how most people seem to be able to understand the law of probability, just not believe it
19:29:53 <Proge> coding a roulette wheel at the minute, the game seems so utterly pointless when you understand it
19:30:26 <roconnor> I play roulette
19:30:36 <roconnor> I bet on black and red
19:30:39 <roconnor> never lost yet
19:31:18 <Proge> but play 1000 times and you will lose to the zero
19:31:32 <Proge> the longer you play the more you'll lose
19:31:58 <roconnor> I only play until I get 1 comp point.
19:32:27 <edwardk> roconnor: playing for comps i can understand
19:32:52 <roconnor> edwardk: in the long run parking is cheaper this way :D
19:33:33 <edwardk> roconnor: yeah, and if you go far enough off strip and know where the locals hang out it can be a pretty cheap way to stay in vegas
19:33:52 <roconnor> oh, interesting.
19:34:04 <roconnor> I've only done this at Niagra Falls.
19:34:09 <roconnor> Canadian side.
19:34:34 <edwardk> at least you get the nice (wet) view ;)
19:35:11 <edwardk> wound up heading down to niagara like 3 times when i went up to mcmaster
19:35:38 <roconnor> the somewhat recent hotels has increased the spray
19:35:53 <edwardk> (we had a heck of a time getting koninkje_away across the border)
19:36:30 <roconnor> he made it to Japan last year.
19:37:21 <edwardk> well in this case they thought he was going to take some job away from some fine upstanding canadian citizen or something
19:37:25 <edwardk> since he was staying so long
19:37:58 <roconnor> canadian boarder guards are possibly more retarded than american guards from my experience.
19:38:25 <edwardk> so chris anand had to come down in an unassuming sweater and make nice noises until they let him through
19:40:57 * hackagebot stm-chans 1.3.1 - Additional types of channels for STM.  http://hackage.haskell.org/package/stm-chans-1.3.1 (WrenThornton)
19:47:56 <danharaj_> what's the cleanest way to check an IO (Either a b) in a do block and fail gracefully?
19:48:17 <Axman6> cmrn: D:
19:48:26 <cmrn> :D
19:51:25 <Sgeo> I still need to start my April Fools project
19:51:32 <Sgeo> Only have about a month, crud.
19:53:39 <mike-burns> danharaj: Probably the `either' function.
19:54:04 <aavogt> @unmtl ErrorT IO a
19:54:04 <lambdabot> Plugin `unmtl' failed with: `ErrorT IO a' is not applied to enough arguments, giving `/\A. a (Either IO A)'
19:54:15 <aavogt> @unmtl ErrorT a IO b
19:54:15 <lambdabot> IO (Either a b)
19:55:58 * hackagebot stm-conduit 0.2.4 - Introduces conduits to channels, and promotes using  conduits concurrently.  http://hackage.haskell.org/package/stm-conduit-0.2.4 (ClarkGaebel)
19:56:32 <monochrom> I just x <- your IO (Either a b) here; case x of ...
19:58:59 <Mathnerd314> hmm... I wonder if there will ever be a paper like "Do notation considered harmful"
19:59:12 <Sgeo> Mathnerd314, there's an article on the wiki named similar
19:59:40 * Mathnerd314 looks
20:00:14 <Mathnerd314> http://www.haskell.org/haskellwiki/Do_notation_considered_harmful
20:00:55 <aavogt> I'm not sure you can get location info like here http://hpaste.org/64581 without using do
20:02:10 <Zamarok> Interesting article I thought people here would enjoy: http://johnbender.us/2012/02/29/faster-javascript-through-category-theory/
20:03:01 <Zamarok> Probably been posted already huh? :P
20:03:12 <mike-burns> It was on Haskell Reddit.
20:03:24 <mike-burns> But wasn't posted in here.
20:03:48 <aavogt> monochrom: then your code just ends up at the right side of the page, and you have to think about ways to split it up
20:03:54 <Mathnerd314> aavogt: IIRC failed pattern matches always have error messages.
20:04:07 <aavogt> but you can recover from this one
20:04:09 <Zamarok> well, I learned from theory from it anyway
20:05:07 <rwbarton> I don't think nesting all your code inside an argument to 'either' is better
20:05:39 <mike-burns> You can define a function and pass that.
20:05:49 <mike-burns> In case you didn't know.
20:06:03 <rwbarton> seriously?
20:06:48 <mike-burns> Yeah! Some people call this a closure!
20:07:13 <mike-burns> Oh I should sleep instead of trolling.
20:07:50 <monochrom> no, you should not sleep. you are funny! :)
20:08:27 <monochrom> with explicit {;}, you can avoid indenting
20:08:47 <rwbarton> (in case you were serious, the decision to factor out the rest of your code into a function is independent of the choice of whether to use either or case)
20:10:37 <mikeplus64> is there a "fmapM" or equivalent?
20:11:54 <BMeph> Yes. Next question? ;)
20:11:56 <dibblego> mikeplus64: mapM\
20:11:58 <dibblego> mikeplus64: mapM
20:12:27 <rwbarton> maybe you want something from Data.Traversable
20:12:37 <dibblego> @type Data.Traversable.mapM
20:12:38 <lambdabot> forall a (m :: * -> *) b (t :: * -> *). (Data.Traversable.Traversable t, Monad m) => (a -> m b) -> t a -> m (t b)
20:12:42 <monochrom> http://www.vex.net/~trebla/tmp/f.hs
20:14:09 <mikeplus64> alright, Data.Traversable looks good
20:14:16 <mikeplus64> thanks
20:14:32 <dibblego> @google The Essence of the Iterator Pattern
20:14:34 <lambdabot> http://www.cs.ox.ac.uk/jeremy.gibbons/publications/iterator.pdf
20:14:34 <lambdabot> Title: The Essence of the Iterator Pattern
20:14:42 <dibblego> ^ that paper talks all about that function
20:15:01 <mikeplus64> ok
20:18:36 <Nisstyre> I'm trying to duplicate this python code in Haskell: http://ideone.com/Ew8L7 What it does is it takes all of the avi files in a directory, and starts playing them, and after finishing playing each file looks for any new files that have been put into the directory, and adds them to the playlist
20:18:50 <Nisstyre> here is my terrible attempt: http://ideone.com/ZXBwQ
20:19:11 <Nisstyre> (sorry for the messiness)
20:20:26 <dibblego> Nisstyre: run hlint on it (I can see some improvements it would suggest)
20:20:32 <dibblego> e.g. [x] ++ y is better written x:y
20:20:40 <dibblego> hlint will point this out to you
20:20:45 <Nisstyre> dibblego: yeah it's not well written really
20:20:55 <Nisstyre> but I'm trying to figure out why it doesn't add new files
20:21:00 <Nisstyre> it uses the initial list of files
20:21:05 <dibblego> well you can get it up to hlint standards pretty easily -- it makes the suggested improvement
20:21:07 <Nisstyre> but no new ones get added
20:21:10 <dibblego> oh ok
20:21:26 <Nisstyre> dibblego: there's probably a much more elegant way of doing this
20:21:30 <Nisstyre> but I haven't found it
20:22:58 <Nisstyre> dibblego: I can replace fappend with liftM2
20:23:03 <Nisstyre> just realized that
20:23:31 <dibblego> liftM2 (++) by the look of it
20:23:36 <Nisstyre> yes
20:23:38 <Nisstyre> anyway
20:23:40 <applicative> liftM2 (++) I was about to say
20:23:41 <dibblego> although I prefer liftA2 to liftM2
20:23:46 <Nisstyre> the overall program doesn't seem to work properly
20:23:53 <Nisstyre> well, it doesn't
20:24:17 <Nisstyre> dibblego: what's the difference between the two?
20:24:37 <dibblego> liftA2 just has Applicative instead of Monad, which gels in my head better
20:24:43 <Nisstyre> okay cool
20:24:54 <dibblego> Monad is overly restrictive
20:24:55 <Jafet> Why is your program full of >>= \
20:25:09 <Nisstyre> Jafet: because I am too lazy to use do notation?
20:25:15 <Jafet> What
20:25:59 <Nisstyre> Jafet: sorry, I'm not very experienced with Haskell
20:26:11 <Nisstyre> you'll have to forgive me if I write really unidiomatic code
20:26:43 <notrusty2> anybody using haskelldb with mysql?
20:26:46 <applicative> dont worry Nisstyre
20:26:50 <monochrom> I do not see anything in your haskell code that says "repeatedly: re-read directory, find files to play"
20:27:18 <Jafet> It's just pretty strange to see people that find desugared bind easier to understand
20:27:19 <Nisstyre> monochrom: "(return fns) `fappend` newfiles"
20:27:46 <Nisstyre> monochrom: it should be getting a list of files that are new and haven't been added yet
20:27:59 <Nisstyre> and adding it to the list each time it recurses
20:28:04 <Nisstyre> like the python code I posted
20:28:09 <Nisstyre> http://ideone.com/Ew8L7
20:28:11 <Jafet> Filenames, to be exact
20:28:15 <Nisstyre> yes, filenames
20:28:23 <monochrom> fns are newfiles are merely parameters to your streamfiles. so it comes down to how you call streamfiles
20:28:57 <monochrom> your call "streamfiles files files" is rather unproductive
20:29:42 <Nisstyre> monochrom: well, one is merely meant to keep track of what has been played
20:30:06 <Nisstyre> at the beginning they are both the same
20:30:06 <Nisstyre> because I assume that was is in the playlist will be played
20:30:13 <Nisstyre> *that what is in
20:31:19 <monochrom> let me put it this way. how many times is "play" called?
20:32:02 <Nisstyre> monochrom: once for every file
20:32:05 <monochrom> I see nothing that will cause "play" to be called more than once.
20:32:06 <Nisstyre> *filename
20:32:46 <Nisstyre> monochrom: oh, I'm an idiot
20:35:53 <edwardk> muaahahaha i just found a whole line of research into using automatic differentiation to improve mcmc. ;)
20:36:31 <nejucomo> I get confused about MonadTrans‚Ä¶  I have defined: type T t = ReaderT R (ErrorT E IO) t
20:36:51 <Jafet> Nisstyre: write out all the type signatures for your helper functions
20:36:54 * companion_cube feeds more fuel to edwardk's scrambler
20:36:58 <Jafet> Then remove "IO" from all of them
20:37:08 <nejucomo> Within a do block of type T, how do I raise an error of type E?
20:37:19 <Jafet> Or "m"
20:37:42 <edwardk> nejucomo: the mtl automatically makes ReaderT r m    where m is an instance of MonadError into an instance of MonadError in its own right
20:37:57 * nejucomo tries: lift (throwError myError)
20:38:16 <edwardk> just 'throwError myError'
20:38:19 <edwardk> no need to lift at all
20:38:22 <Jafet> Oh, I see, you're passing around globs as file lists.
20:38:30 <Nisstyre> Jafet: yes
20:38:41 <nejucomo> edwardk: Oh‚Ä¶  Where do I see that in the docs?
20:39:15 <Jafet> Don't; use liftM as late as possible
20:39:20 <nejucomo> When I look at the docs for C.M.T.Reader it doesn't show ReaderT instances related to Error.
20:39:41 * nejucomo looks at ErrorT instances again...
20:40:06 <edwardk> nejucomo: look at the instances in http://www.haskell.org/ghc/docs/6.8.3/html/libraries/mtl/Control-Monad-Error-Class.html#t%3AMonadError
20:40:18 <edwardk> not the instances that are applied to ErrorT
20:40:24 <edwardk> you want the instances of MonadError
20:40:25 <nejucomo> Ok.
20:40:26 <Nisstyre> Jafet: what I am doing right now, will it result in each call to files having the same result?
20:40:32 <edwardk> MonadError gives you throwError and catchError
20:40:36 <Nisstyre> because that's what I suspected was happening
20:40:37 <edwardk> which are the operations you want
20:41:03 <edwardk> the mtl is pretty good about automagically doing lift for you for the other classes provided by the mtl
20:41:27 <edwardk> instance MonadError e m => MonadError e (ReaderT r m)      -- is what you are looking for
20:41:28 <Jafet> Nisstyre: how would you find out?
20:41:39 <Nisstyre> Jafet: the debugger I suppose
20:41:53 <Jafet> No, you don't need the debugger.
20:42:03 <Nisstyre> Jafet: well, I tested it in ghci
20:42:15 <Nisstyre> and it did return a new list after having added a new file to the directory
20:42:24 <Jafet> >>= \x -> print x >> return x
20:42:39 <Nisstyre> Jafet: ah, ok
20:42:40 * nejucomo puzzles over the relationship between C.M.$thing.Class and C.M.Trans.$thing
20:43:29 <edwardk> nejucomo: C.M.Trans.$thing is written to be Haskell 98/Haskell 2010 compatible.
20:43:43 <edwardk> the 'transformers' package is legal Haskell across lots of compilers.
20:43:46 <nejucomo> Oh, good to know.
20:44:18 <edwardk> the mtl uses multiparameter type classes, and augments the types from transformers with classes that can magically do the lifting i just described for you
20:44:41 <nejucomo> Where can I find a reference or tutorial about the | and -> syntax in class definitions?  Example: class Monad m => MonadReader r m | m -> r where ...
20:44:56 <dibblego> nejucomo: "functional dependencies" is the keyword
20:45:00 <nejucomo> Thanks.
20:45:12 <edwardk> monads-tf is (well, mostly was) an attempt to provide the same mtl'ish api with type families instead of MPTCs that way the mtl could live on if multiparameter type classes were removed from the language
20:45:19 <edwardk> those are functional dependencies
20:45:35 <edwardk> a -> b c    -- says that you can 'infer the types of b and c from a'
20:47:10 <edwardk> which means that if you had class Foo a b c | a -> b c   -- then instance Foo Bar Baz Quux      would be fine, and instance Foo Quaffle X Y would be fine together, but attempting to also add Foo Quaffle W Z would crap out because a=Quaffle implies the second parameter is X but also that it is Y
20:47:22 <edwardk> er but also that is W i mean
20:47:32 <edwardk> in the case of the MTL the idea is that
20:47:37 <nejucomo> Wait, so does ``class C x y | x -> y where ‚Ä¶'' mean "where it is possible to infer y from x" or "hey type system: please infer y from x" ?
20:47:50 <edwardk> class MonadReader r m | m -> r -- says you can 'figure out the type of the environment from the type of the monad'
20:48:41 <edwardk> it says that you y is a function of x, and can be treated as such, and any attempt to violate that fact is a type error
20:50:27 <edwardk> instance Monad m => MonadReader e (ReaderT e m)  -- says that you can infer the type 'e' from the fact that the monad's type is ReaderT e m. When you make members of a class, you have to reference enough of the parameters of the typeclass that all of the arguments to the typeclass can be inferred. if fundeps didn't exist, then every type argument to the typeclass would have to be used by
20:50:27 <edwardk>  every method you put in it
20:50:48 <edwardk> not only that there would be many places where you would need type annotations in code in practice
20:52:09 <edwardk> the fundep machinery was added shortly after multiparameter typeclasses were added, because it drastically cut down on type annotations -- can you imagine having to say (ask :: ReaderT Env IO Env) every time you went to use 'ask'?
20:52:27 <edwardk> without the fundep you could have multiple valid environment types for the same monad
20:53:05 <edwardk> at least this way you have one and if you are transforming a monad that has an environment of its own, you can lift ask enough times to get that one instead
20:53:42 <cmrn> im on a tablet
20:53:51 <cmrn> and lazt
20:53:54 <cmrn> lazy
20:54:08 <cmrn> err, wrong channel
20:54:30 <Jafet> Nisstyre: http://hpaste.org/64583
20:55:43 <Cale> edwardk: Would you happen to know what these foo.\ cost centres are in profiles in 7.4.1?
20:55:55 <edwardk> cale: nope
20:56:44 <nejucomo> Why does the documentation for C.M.Reader and C.M.Reader.Class look identical on my system?  Does the former export the latter?
20:57:09 <nejucomo> Also, why do hoogle's links have handy source links on the right side, but my cabal installed documentation does not?
20:57:31 <Nisstyre> Jafet: trying it out now
20:57:42 <Jafet> I doubt that code even compiles.
20:57:59 <Jafet> But it illustrates some... things.
20:58:13 <Jafet> nejucomo: rebuild your documentation with --hyperlink-source
20:58:48 <Nisstyre> Jafet: it compiles with a typo fix and import Control.Applicative
20:58:54 <Nisstyre> Jafet: but it still doesn't pick up new files
20:58:58 <nejucomo> Jafet: Excellent, thanks.  Is there a way to tell cabal to always do that?
20:59:00 <Jafet> Okay, then I doubt it works!
20:59:04 <Jafet> nejucomo: nope
20:59:10 <nejucomo> ok.
20:59:10 <Nisstyre> Jafet: yeah, there must be another way of doing it though
20:59:26 <Jafet> Unless you invoke cabal manually for every package.
21:00:01 <Jafet> Why doesn't hpaste have a search feature
21:00:08 <Jafet> I can't find my old paste
21:00:51 <Jafet> http://hpaste.org/47364/kludge_what_kludge
21:02:27 <nejucomo> Does cabal conveniently support installing multiple versions of a package (for instance, if I request two other packages that depend on disjoint versions of a common package)?
21:03:44 <edwardk> nejucomo: yes. you can install multiple versions, though some packages you may not want to do that with
21:03:45 <DanBurton> Jafet: just do a google search with site:hpaste.org
21:04:31 <Jafet> Googlebot indexes every paste?
21:04:44 <DanBurton> I believe so
21:04:55 <Jafet> That is depressing
21:04:57 <DanBurton> @google site:hpaste.org ioMemo
21:04:59 <lambdabot> http://hpaste.org/64488
21:04:59 <lambdabot> Title: Did I just reinvent spawn? :: hpaste ‚Äî Haskell Pastebin
21:05:32 <DanBurton> doubtful that it's super duper real time indexing, but if it's been on the net for like a day, Google probably has it indexed
21:06:03 <DanBurton> also hpaste apparently keeps irc logs
21:11:18 <nejucomo> I'm still grappling with fundeps.  Given ``class Monad m => MonadReader r m | m -> r'' and ``(Error e, MonadReader r m) => MonadReader r (ErrorT e m)'' does this mean for a given ``ErrorT e m'' there may be only one ``r'' type?
21:11:39 <nejucomo> (Sorry, I dropped an ``instance'' from the second quote.)
21:16:40 <Axman6> nejucomo: m -> r means that for each m, the r value is fixed (this is clearer when you use less abstract classes, like um... let me think of something)
21:18:28 <Axman6> say, class Abs a b | a -> b where abs a -> b. then we can have instance Abs Double Double, because the absolute value of a Double is also a double, but we can also have instance Abs (Complex a) a, which says that when we take the absolute value of a say a Complex Double, the result should be a Double
21:18:47 <nejucomo> So r is fixed for a given m, but how do I know what r is?  It seems like "given IO, there is a MonadReader r IO" but I don't know what r is.
21:19:08 <Axman6> also, instance Num a => Abs (Vector a) a
21:19:56 <Axman6> nejucomo: well, usually you'd see something like: instance MonadReader r (Reader r), so you know the r is the r type for the given Reader use (that was a horrible explanation)
21:20:40 <Axman6> i'm not sure how MonadReader works with IO though in that case. is there an instance MonadReader r IO?
21:21:12 <nejucomo> Ah, do fundeps require a type expression left of ``=>'' which specifies the dependency?
21:21:40 <Axman6> i don't think so... are you referring to the Abs on Vector example?
21:21:46 <nejucomo> There's this instance: ``Monad m => MonadReader r (ReaderT r m)''
21:22:15 <nejucomo> -actually, now that I look at all of the instance declarations on classes with fundeps, it's rather obvious.
21:22:19 <Axman6> ah, that's more from the fact that ReaderT doesn't force m to be in Monad
21:23:40 <nejucomo> Right, so ``instance C x (T x)'' satisfies the fundep: ``class C a b | b -> a''  Is this correct?
21:24:07 <nejucomo> It seems as if the instance type expression must satisfy the fundep requirement.  Is this true?
21:26:18 <Axman6> i'm no expert, but it sounds like you might have something backward here. all class C a b | a -> b says is that when you pick a certain a type, then the b type is fixed for that a. so you can't have instance C Int Bool and instance C Int Char. but you can however have instance C Int Bool and instance C Double Bool
21:27:06 <Axman6> if you had class D a b | a -> b, b -> a, then that lies the two tyoes together, you can have instance C Int Bool, but now you cannot create another instance where a is an Int OR b is a Bool
21:27:42 <Axman6> uh, lies -> links, types*
21:28:32 * shergill had been kinda confused about this too. thanks Axman6
21:30:04 <Axman6> don't take my word as gospel, i'm by no means an expert, and would really appreciate it if someone who knows more (*poke* quicksilver, edwardk, copumpkin) would make sure i'm not talking complete nonsense =)
21:30:34 <copumpkin> that's pretty much it, I think
21:30:42 <Axman6> \o/
21:30:49 * Axman6 wins at understanding
21:30:59 <edwardk> nejucomo: C.M.Reader re-exports C.M.Class and C.M.Trans.Reader
21:31:05 <shergill> heh
21:32:09 <nejucomo> Axman6: Ah, ok.
21:34:14 <edwardk> AD + MCMC is making me very happy. wow its faster. how did i never find this before?
21:35:35 <alang_> edwardk: how are you combining AD and MCMC?
21:37:17 <edwardk> found references on langevin and hamiltonian mcmc. basically langevin uses the gradient of the pdf to push the candidate in the direction it is more likely to be accepted in
21:37:41 <mauke> acronym overload
21:37:56 <edwardk> where as the hamiltonian (hybrid) mcmc approach mixes that with a notion of momentum that i'm still getting my head around
21:38:31 <edwardk> as for ad, i found http://www.mit.edu/~wingated/papers/opover.pdf
21:38:42 <edwardk> when i was going through wingate's other stuff
21:39:23 <shergill> edwardk: doesn't the hybrid approach basically formulate potential equations, which it then solves. and kinda alternates between taking random samples and taking paths along 'moment' trajectories?
21:39:39 <edwardk> shergill: thats my understanding so far
21:39:47 <edwardk> i just haven't put it into practice
21:40:18 <edwardk> i'm really familiar with ad, but most of my use of this other stuff has been rather formulaic application inside MLT
21:41:02 <edwardk> now i'm just trying to see how i can use my ad library to augment what i'm working on =)
21:42:42 <edwardk> i already have all the higher derivatives and mixed ad modes available to me, so its just a matter of figuring out how to use them.
21:43:22 <shergill> heh. i usually go the other way around
21:43:57 <edwardk> well i wrote http://hackage.haskell.org/package/ad-1.3.0.1 a while ago
21:45:21 <edwardk> i'm also trying to get my head around how to convert wingate's 'bher' into a monad in haskell.
21:46:33 <edwardk> that would take my little deep research dive out of hierarchical bayesian modeling and move it into a more probabilistic programming approach
21:46:50 * ddarius decides to start calling MCMC "McMc."
21:47:05 <edwardk> ddarius: =)
21:48:45 <alang_> edwardk: hmm i'm unable to look at that paper right now, but essentially the AD is for computing the gradient?
21:49:36 * ddarius makes sure all his derivatives are in an infinite dimensional configuration space.
21:49:40 <edwardk> alang: yeah, in bher, he is doing probabalistic programming, tracking dependencies on random variables and doing the walk in 'program trace' space
21:50:18 * Jafet looks forward to future programmers being made to learn analysis
21:50:43 <edwardk> jafet: it'd give them a use for all the math we make them take ;)
21:50:47 <ddarius> Just like all electrical engineers learn analysis ...
21:50:48 <alang_> sounds interesting, definitely have to look at that later =D
21:50:58 <ddarius> edwardk: All none of it?
21:51:21 <sanjoyd> Is there some deriving(read) like deriving(show)?
21:51:28 <edwardk> sanjoyd: yes
21:51:36 <ddarius> Yes, there's deriving (Read)
21:51:42 <Jafet> The derived Read is the inverse of the derived Show.
21:51:43 <sanjoyd> ddarius: edwardk thanks!
21:51:48 <sanjoyd> Perfect.
21:52:06 <edwardk> > read (show "hello") :: String
21:52:07 <lambdabot>   "hello"
21:52:09 <sanjoyd> Saves me from writing a parser. :)
21:52:16 <ddarius> Jafet: Only if all the components satisfy that property.
21:52:33 <Jafet> True. But they should.
21:52:48 <Jafet> reads is already a parser.
21:53:07 <ddarius> It's nice if they do, but it's hardly a requirement.
21:58:04 <ddarius> It's not even the case that read . show is (approximates) id even with the standard instances.
21:58:58 <danharaj> which instances break that equation?
21:59:34 <ddarius> danharaj: The usual suspects.  The floating point instances.
21:59:45 <ddarius> I would be unsurprised if others do as well.
22:00:01 <danharaj> ah of course
22:00:22 <danharaj> hmm, actually it seems a little strange that the float instance is broken in this case.
22:01:06 <danharaj> I guess it has to do with floats that don't have finite decimal expansinos.
22:01:10 <danharaj> expansions*
22:01:25 <ddarius> No, though I can see that being a problem as well.
22:02:05 <ddarius> It takes care to write read/show instances that produce nice-ish output and round-trip as far as floating point round-off is concerned.  I believe it can be done and may be done for GHC.
22:03:17 <ddarius> > (isNegativeZero (read (show (-0.0 :: Double)), isNegativeZero (-0.0 :: Double))
22:03:18 <lambdabot>   <no location info>: parse error (possibly incorrect indentation)
22:03:24 <ddarius> > (isNegativeZero (read (show (-0.0 :: Double))), isNegativeZero (-0.0 :: Double))
22:03:25 <lambdabot>   (True,True)
22:03:44 <ddarius> Oh, I mistested that one.
22:04:57 <shergill> relevant: http://florian.loitsch.com/publications/dtoa-pldi2010.pdf
22:06:20 <ddarius> Certainly NaN will fail as there are multiple bit patterns that are NaN and, presumably, they all show as "NaN."
22:07:04 <danharaj> oh I did not know that.
22:07:17 <danharaj> are they semantically equivalent?
22:08:41 <ddarius> Well there are signed NaNs and there's a bunch of bits available that can be used for arbitrary things.  There are also signalling NaNs which are definitely not semantically equivalent.
22:08:54 <ddarius> Of course, these are all observationally different to the extent that you can get at the bit representation.
22:09:17 <danharaj> mm
22:28:43 <qnikst> hello, can one help me with using monad transformer in conduits? I've got following code: https://gist.github.com/1941151
22:29:24 <qnikst> there're commented blocks that I want to run (with runWriterT) first 2 blocks works
22:29:38 <qnikst> but block with register action doesn't want to
22:29:40 <c_wraith> why are you using packageimports?
22:30:03 <qnikst> I have many Control.Monad.Reader/Writer packages
22:30:21 <qnikst> so I had to add "mtl" to specify package
22:30:24 <c_wraith> then use cabal to build so that only mtl is in scope.
22:30:31 <c_wraith> it's cleaner than packageimports
22:30:35 <c_wraith> but that's not your problem
22:31:09 <qnikst> yes, but its onefile toy example that I want to add to gist or other paste services, so anybody can test it
22:42:11 <quicksilver> Axman6 is talking complete nonsense.
22:42:20 <quicksilver> ;)
22:43:21 <Jafet> So can he obtain a PhD?
22:43:34 <quicksilver> possibly
22:43:34 <companion_cube> is it a sufficient condition?
22:43:44 <quicksilver> it has worked for many people in this channel
22:43:56 <companion_cube> interesting, i should try
22:48:26 <Nisstyre> Jafet: I'm writing the thing in Scheme now instead http://ideone.com/YLOBg
22:48:36 <Nisstyre> :P
22:49:56 <tempire> If I'm using the cabal tool to install packages, should the corresponding haddock docs also be in ~/.cabal?
22:50:36 <Jafet> If the cabal tool builds documentation, yes
22:51:57 <Jafet> Nisstyre: be careful, you may cause scheme programmers not partial to haskell to flip out.
22:52:08 <Nisstyre> lol
22:52:18 <Sgeo> Nisstyre, what if you want to do (partial + 1 2)?
22:52:22 <Sgeo> For example?
22:52:25 <Sgeo> Provide several arguments
22:52:32 <Sgeo> And then several more when it's used.
22:53:16 <Nisstyre> Sgeo: (partial (partial + 1) 2)
22:53:25 <Nisstyre> :P
22:53:32 <Nisstyre> of course  there's probably a better way
22:54:10 <Jafet> Sgeo: it doesn't even work in Haskell!
22:55:22 <Sgeo> Common Lisp's apply also doesn't work in Haskell.
22:55:41 <Jafet> How do you know when to apply?
22:56:47 <Sgeo> Could use it when making a compose function that can sanely handle multiple arguments in the first function.
22:58:32 <Jafet> (define (partial f . xs) (lambda ys (apply f (append xs ys)..)
22:59:11 <Jafet> I suppose that works
23:07:01 <augur> what are good representations of partially ordered sets?
23:09:19 <yitz> (define (curry n f) (if (< n 2) f (lambda (x) (curry (- n 1) (partial f x)))))
23:10:30 <yitz> hmm not quite. that works in python though.
23:10:41 <shergill> data Curry = Vindaloo | Chicken ...
23:10:51 <augur> shergill: :)
23:12:16 <yitz> oh maybe it does work
23:12:59 <yitz> can we define curry without the n parameter?
23:13:26 <Sgeo> alexandria, a library for Common Lisp, has a curry without an n parameter
23:14:20 <companion_cube> augur: a DAG?
23:14:34 <augur> companion_cube: i suppose
23:14:40 <yitz> augur: how about Data.Map a (Data.Set a)
23:15:03 <yitz> Sgeo: is it defined using a macro?
23:15:14 <Sgeo> I don't think so, I'll check
23:16:07 <yitz> augur: or Data.Set (a,a)
23:16:09 <companion_cube> yitz: doesn't Data.Set already need some ordering? :D
23:16:51 <companion_cube> so the alternative is probably something like a HashMap a [a]
23:16:52 <Sgeo> Let's see. It uses a macro as a safety check, and a declaration I don't understand
23:16:56 <yitz> companion_cube: yes, those would be for defining a different partial ordering on a type that already has a total ordering. you can usually impose one arbitrarily for that purpose though.
23:17:14 <companion_cube> yitz: if it makes sense
23:17:35 <Jafet> class POS a where compost :: a -> a -> Maybe Ordering
23:17:41 <companion_cube> and I'm not convinced that an adjacency set is better than an adjacency list
23:18:13 <Sgeo> I think it's an optimization
23:18:24 <companion_cube> I'm not even sure
23:18:24 <yitz> companion_cube: sometimes if you need to store a type in containers, you add an extra Int field which you fill with unique values for each object. sometimes that's not so convenient to do though.
23:18:50 <Sgeo> Oh, no, it's the thing I thought was a macro is a function
23:18:51 <yitz> companion_cube: depends on what you expect the shape of the p.o. to be
23:18:57 <companion_cube> yitz: but then you have to remember which int goes which which object
23:19:10 <companion_cube> if you don't have all the objects at the same time
23:19:15 <yitz> companion_cube: no you ignore them
23:19:16 <companion_cube> (otherwise it's called a hash :D))
23:19:17 <Sgeo> http://common-lisp.net/gitweb?p=projects/alexandria/alexandria.git;a=blob;f=functions.lisp;h=f703a99b447668749ac803472506e3e13054fedf;hb=HEAD;js=1
23:19:20 <Sgeo> Search for curry
23:19:24 <yitz> companion_cube: true
23:19:32 <Sgeo> You could easily translate that into scheme
23:19:42 <Sgeo> Or, the core concept behind it anyway
23:19:56 <Sgeo> I'm going to assume that Scheme has an append, I'm not checking if it's true
23:20:05 <yitz> Sgeo: it's true
23:20:08 <companion_cube> that's why I would go for some HashTrie or Map, with an adjacency list (whcih should be short)
23:20:28 <yitz> companion_cube: it all depends on the use case
23:20:44 <Sgeo> (define (curry f . args1) (lambda (. args2) (apply f (append args1 args2))))
23:20:45 <companion_cube> yes, but for an ordering...
23:20:58 <Sgeo> I don't know if that lambda is syntactically correct
23:21:02 <Sgeo> But I think the core idea should work
23:21:04 <companion_cube> but I agree, there are too many parameters
23:21:30 <Sgeo> Kind of obvious in hindsight
23:21:35 <yitz> Sgeo: what does (. mean?
23:21:54 <Sgeo> yitz, that the lambda should collect all of its arguments into a list
23:22:08 <Sgeo> I don't know the actual Scheme syntax
23:22:24 <yitz> Sgeo: Jafet just wrote (lambda ys ...)
23:22:42 <dibblego> @type MaybeT . return
23:22:43 <lambdabot> Not in scope: data constructor `MaybeT'
23:22:49 <Sgeo> ....oh
23:23:08 <Sgeo> That makes sense, use that then
23:23:18 <Sgeo> Same thing, just I was a derp
23:23:34 <Sgeo> Jafet's code does the right thing
23:23:53 <Sgeo> Unless keyword arguments get involved. Does Scheme even have keyword arguments? I know Racket does.
23:24:11 <Sgeo> This is one of the things I like about CL: How it treats keyword arguments.
23:24:13 <yitz> no i don't think so
23:24:20 <yitz> at least it didn't used to
23:25:02 <yitz> Sgeo: something like python's keyword arguments? (if so, python stole it from CL)
23:26:07 <Sgeo> Actually, not like Python. In Python, doing def foo(*args): won't put the keyword argument into args. In CL, the equivalent will
23:26:24 <Sgeo> (WIth the keyword and argument next to each other)
23:26:35 * Sgeo double-checks what he just said
23:26:37 <companion_cube> there is **args in python,ut that's different
23:31:04 * hackagebot CoreFoundation 0.1 - Bindings to Mac OSX's CoreFoundation framework  http://hackage.haskell.org/package/CoreFoundation-0.1 (ReinerPope)
23:51:58 <osager> can i use list concat in pattern matching ? example, foo ("ok"++xs) , to match all list that begins with "ok"
23:52:12 <osager> or do i have to use 'o':'k':xs
23:54:19 <Saizan> the latter
23:54:55 <Saizan> ?hoogle stripPrefix
23:54:55 <lambdabot> Data.List stripPrefix :: Eq a => [a] -> [a] -> Maybe [a]
23:54:55 <lambdabot> Data.Text stripPrefix :: Text -> Text -> Maybe Text
23:54:55 <lambdabot> Data.Text.Lazy stripPrefix :: Text -> Text -> Maybe Text
23:55:19 <ion> Incidentally, Erlang does have that syntactic sugar.
23:55:24 <Saizan> "foo xs | Just ys <- stripPrefix "ok" xs = .." also works with PatternGuards
23:55:53 <Saizan> foo (strpPrefix "ok" -> Just xs) = .. with ViewPatterns
