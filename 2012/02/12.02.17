00:23:06 <srhb> Does anyone develop Haskell on a *nix platform for deployment on both Linux, OS X and Windows - particularly with wxHaskell? Will I be running into a lot of trouble if I try?
00:29:44 <ivanm> srhb: if you limit how many libraries you need that bind to C, etc. then I *think* you'll be fine
00:29:53 <ivanm> also be careful about handling FilePaths
00:30:04 <ivanm> I believe it's also possible to run windows GHC in wine to test it
00:32:23 <srhb> ivanm: With wine, oh really? That would simplify things greatly.
00:32:28 <wavewave> hi.
00:33:08 <wavewave> is there any library for constructing multipart/form-data ?
00:33:16 <wavewave> in web app.
00:34:31 <mm_freak_> srhb: whether you'll run into trouble under windows depends on your package's dependencies…  with no C dependencies outside of the haskell platform you'll be fine…  testing with wine is a good way make sure it works and also to cross-compile
00:34:50 <srhb> mm_freak_: Yeah, I guess using WX totally destroys that safety.
00:35:05 <mm_freak_> srhb: test it, there are precompiled windows packages for it
00:35:21 <tikhonjelvis> I thought wx was fairly portable?
00:35:42 <mm_freak_> srhb: the trouble starts when you have to compile C stuff yourself
00:35:46 <srhb> mm_freak_: So I have to distribute my program with wx as well?
00:35:48 <srhb> mm_freak_: Aha, okay.
00:36:17 <mm_freak_> srhb: also sometimes passing the right options to the linker can be tricky
00:36:26 <mm_freak_> but that's usually solvable
00:39:08 <erus`> all the constraints have to be at the start of a type, right?
00:40:18 <erus`> ie i cant have a => (b => b -> b) -> a
00:40:35 <tikhonjelvis> Not as far as I know
00:40:44 <latros> that's correct
00:40:50 <tikhonjelvis> Why would the order matter?
00:40:58 <tikhonjelvis> That is, why would you want your version?
00:41:05 <erus`> im redesigning my type system
00:41:09 <latros> it doesn't even really make syntactical sense
00:41:09 <tikhonjelvis> ah
00:41:10 <mauke> erus`: not with rank-n types
00:41:21 <latros> ah true
00:41:33 <latros> if you've got values of polymorphic type
00:41:35 <latros> then yeah
00:41:39 <latros> there's some meaning to that
00:41:39 <erus`> if i apply a poly type to another it will look like the above
00:43:05 <erus`> :t id (+)
00:43:06 <lambdabot> forall a. (Num a) => a -> a -> a
00:43:13 <erus`> :t const (+)
00:43:14 <lambdabot> forall a b. (Num a) => b -> a -> a -> a
00:44:00 <jkomi> :t compare
00:44:00 <lambdabot> forall a. (Ord a) => a -> a -> Ordering
00:44:06 <jkomi> :t sort
00:44:07 <lambdabot> forall a. (Ord a) => [a] -> [a]
00:48:15 <sanjoyd> @src const
00:48:15 <lambdabot> const x _ = x
00:52:27 <jkomi> @src sort
00:52:27 <lambdabot> sort = sortBy compare
00:52:35 <jkomi> @src sortBy
00:52:35 <lambdabot> sortBy cmp = foldr (insertBy cmp) []
00:52:50 <jkomi> @src foldr
00:52:50 <lambdabot> foldr f z []     = z
00:52:50 <lambdabot> foldr f z (x:xs) = f x (foldr f z xs)
00:52:54 <sanjoyd> Layers of an onion.
00:53:03 <mauke> the onion is a lie
00:53:19 <sanjoyd> The lye is an onion.
00:54:50 <latros> how efficient is that sort algorithm....
00:55:42 <latros> seems like it could be O(n^2)
00:55:43 <latros> >.>
00:55:51 <latros> unless I'm looking at it wrong
00:56:01 <jkomi> hm
00:56:02 <tikhonjelvis> Look at the actual source: http://hackage.haskell.org/packages/archive/base/latest/doc/html/src/Data-List.html#sortBy
00:56:09 <mauke> latros: it is
00:56:19 <jkomi> messy
00:56:46 <tikhonjelvis> It seems the nice pretty but inefficient source is part of the standard, but GHC usually uses a scary but probably faster one.
00:56:49 <latros> surprising that the "herp derp naive derp" solution isn't a qsort
00:57:01 <latros> at least they're nlogn
00:57:06 <tikhonjelvis> sort of
00:57:48 <latros> though I'm not sure how I'd write qsort without explicit recursion, I will admit
00:57:48 <tikhonjelvis> I'll give you a metaphorical cookie if you can prove that it's nlogn on average without looking it up :)
00:57:54 <latros> qsort?
00:57:57 <tikhonjelvis> yeah
00:58:00 <latros> uh
00:58:03 <erus`> forall a. does a have to be of kind (*) ?
00:58:04 <tikhonjelvis> well, assuming you mean QuickSort
00:58:07 <latros> yeah
00:58:11 <latros> it's just a chopping
00:58:26 <tikhonjelvis> It's O(n²) in the worst case.
00:58:36 <latros> wait....ah
00:58:37 <latros> yes
00:59:13 <tikhonjelvis> I had to prove that it was O(nlogn) on average for homework last semester. Fun times.
00:59:18 <latros> but statistically the probability is high that it is nearish the middle, intuitively
00:59:32 <latros> which means you get 2 n/2 subproblems
00:59:47 <tikhonjelvis> That's very hand-wavey :P
00:59:50 <latros> sure
00:59:58 <latros> takes effort to actually do the proof correctly
01:00:11 <latros> and it's 5 am and I'm in bed
01:00:16 <latros> >.>
01:00:18 <tikhonjelvis> I don't remember how I ended up doing it, but it was really annoying.
01:00:23 <x_man> dmwit: there?
01:00:36 <Gothmog_> actually, the correct proof isn't that hard, either. ;)
01:00:42 <latros> not THAT hard
01:00:46 <latros> but still, effort
01:01:07 <tikhonjelvis> There's a difference between hard and annoying.
01:01:18 <latros> yeah
01:01:27 <Gothmog_> that's quite true.
01:01:56 <latros> calculus II is annoying, even after it becomes easy to you
01:01:56 <latros> :p
01:03:25 <x_man> If state lemma of inversion of subtyping relation like this:
01:03:26 <x_man> If S1->S2=<T  then T has form T1->T2, with T1=<T and S2=<T2
01:03:26 <x_man> is there any conceptual deferent between original lemma? can I refer original lemma as proof of this lemma?
01:13:23 <erus`> > (id id) 123
01:13:24 <lambdabot>   123
01:14:39 <koeien> id id = id
01:15:10 <erus`> do functions have kinds?
01:15:16 <koeien> no, types have kinds
01:15:21 <koeien> and type constructors
01:15:26 <erus`> -> is a type
01:15:33 <koeien> no, -> is a type constructor
01:16:42 <tikhonjelvis> Coincidentally, you don't even need the parentheses:
01:16:47 <tikhonjelvis> > id id id id id id 42
01:16:48 <lambdabot>   42
01:17:02 <koeien> (->) has kind ** -> * -> *
01:17:18 <tikhonjelvis> **?
01:17:41 <ziman> :sort *
01:17:47 <ziman> :\
01:18:25 <koeien> ?? -> ? -> *
01:18:25 <lambdabot> Plugin `compose' failed with: Unknown command: ""
01:18:28 <koeien> you can ask ghc with :k
01:18:43 <tikhonjelvis> The ?? and ? are just GHC additions though.
01:19:03 <koeien> yeah there are some new things in ghc 7.4 re the kind system iirc
01:19:04 <tikhonjelvis> When you're just learning about kinds, it's just going to confuse you.
01:19:23 <mauke> @kind (->)
01:19:23 <lambdabot> ?? -> ? -> *
01:19:25 <tikhonjelvis> Heh, you guys are making me feel guilty about not having upgraded yet...
01:21:50 <erus`> so id doesnt have a kind
01:21:53 <erus`> because its a value
01:21:58 <erus`> it has a type
01:21:58 <koeien> correct
01:21:59 <koeien> id has a type
01:22:08 <erus`> but the type of id
01:22:10 <erus`> has a kind?
01:22:14 <koeien> yes
01:22:20 <erus`> :t id
01:22:21 <lambdabot> forall a. a -> a
01:22:29 <erus`> :k forall a. a -> a
01:22:31 <lambdabot> *
01:22:35 <koeien> all types have kind *
01:22:42 <mauke> erus`: for any value x, the kind of the type of x is *
01:22:43 <koeien> type constructors have a different kind
01:22:53 <erus`> what kind is forall a?
01:22:53 <koeien> for example, Maybe has kind * -> *
01:23:00 <erus`> polymorphic?
01:23:02 <mauke> erus`: forall a is not a type
01:23:25 <koeien> that means that Maybe expects a type, and given a type, returns a type
01:23:39 <koeien> this implies that "Maybe Integer" is a type, for example.
01:23:47 <erus`> forall a. a  can be a type of any kind?
01:23:48 <koeien> but Maybe Maybe does not kind-check
01:23:59 <koeien> no, it also has kind *
01:24:37 <adimit> Maybe (Maybe Int) does typecheck though, because (Maybe Int) has kind *
01:24:52 <erus`> yeah i know this but ...
01:25:55 <erus`> :t id :: Maybe -> Maybe
01:25:56 <adimit> btw, does anybody have any experience with using redis haskell bindings? i'm wondering whether to use the hedis or the redis package… :-\
01:25:56 <lambdabot>     `Maybe' is not applied to enough type arguments
01:25:56 <lambdabot>     Expected kind `??', but `Maybe' has kind `* -> *'
01:25:57 <lambdabot>     In an expression type signature: Maybe -> Maybe
01:26:15 <koeien> erus`: yes, Maybe is not a type.
01:26:18 <erus`> a forall type has to have the kind  *
01:26:29 <erus`> yeah?
01:26:37 <koeien> Maybe is a type *constructor*
01:26:41 <tikhonjelvis> I think it might be easier just to forget about the forall bit for now. If you type :t into GHCi you won't get a forall.
01:26:44 <koeien> given a type, it returns a type.
01:26:58 <erus`> tikhonjelvis: i cant forget about forall because im trying to model it
01:28:28 <tikhonjelvis> It just means that the type signature holds when a is any type.
01:28:45 <tikhonjelvis> :t fmap
01:28:46 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
01:29:35 <tikhonjelvis> You can read the => as implication.
01:29:59 <erus`> aha so forall does take a kind
01:30:35 <tikhonjelvis> Yes. In this case, it's saying for all concrete types a and b and for all type constructors with one argument f, ...
01:30:53 <erus`> cool
01:30:56 <erus`> s ]
01:31:11 <erus`> data Type = Forall Kind Type | ....
01:31:44 <tikhonjelvis> In this case the a, b and f aren't so much types as type variables.
01:32:01 <erus`> yeah like type lambdas ?
01:32:04 <tikhonjelvis> a forall only makes sense with a variable
01:32:52 <erus`> \a :: *-> \b :: * -> \f :: (* -> *) -> ....
01:34:53 <tikhonjelvis> Umm, it's probably better to think of the variables as introduced by a forall.
01:35:18 <tikhonjelvis> So the type is really a universally qualified predicate.
01:35:51 <latros> proposition, actually
01:35:57 <latros> not the same thing
01:36:22 <tikhonjelvis> umm, right
01:36:52 <tikhonjelvis> Type classes are predicates.
01:37:07 <latros> correct
01:37:25 <tikhonjelvis> And =>, as I said earlier, is implication.
01:40:02 <tikhonjelvis> I hope this made types clearer.
01:47:58 <erus`> :t forall (f :: * -> *) . f
01:47:59 <lambdabot> parse error on input `*'
01:48:03 <erus`> :k forall (f :: * -> *) . f
01:48:04 <lambdabot>     `f' is not applied to enough type arguments
01:48:04 <lambdabot>     Expected kind `*', but `f' has kind `* -> *'
01:48:04 <lambdabot>     In the type `forall f :: (* -> *). f'
01:48:24 <dobblego> erus`: ?
01:51:54 <erus`> every value has to have a type with a kind of (*)
01:51:57 <erus`> im such a wally
01:52:26 <koeien> yes, types have kind *
01:52:51 <erus`> a type constructor is a type too?
01:53:03 <koeien> no
01:53:06 <koeien> Maybe is not a type
01:53:19 <koeien> it's a type constructor
01:53:48 <erus`> aha
01:58:29 <quicksilver> well it's a slightly fiddly piece of terminology.
01:58:41 <quicksilver> if Maybe is not a type, then what is it that kinds classify?
01:58:54 <koeien> yeah i don't like the terminology either
01:59:01 <koeien> "types and type constructors"
01:59:14 <quicksilver> type constructors is no longer good terminology
01:59:22 <quicksilver> because we talk about other kinds of type function now
01:59:37 <quicksilver> it might have been OK when the only types of non *-kind we could have were constructors.
01:59:44 <koeien> what is the preferred nomenclature in dependently typed PLs?
02:00:01 <tikhonjelvis> I don't think dependently typed languages have kinds at all.
02:00:55 <koeien> oh. i'm a complete idiot in this regard. i noticed before that i disliked the terminology as well
02:07:30 <mandaya> Quickcheck's instance of Arbitrary for numbers... why am I getting all zeroes out of it?
02:07:40 <mandaya> (floats in particular)
02:07:59 <ivanm> > check (all (0.0==))
02:08:00 <lambdabot>   Not in scope: `check'
02:08:02 <ivanm> @check (all (0.0==))
02:08:03 <lambdabot>   "Falsifiable, after 0 tests:\n[-2.3333333333333335]\n"
02:08:08 <ivanm> mandaya: ^^ you shouldn't
02:08:13 <ivanm> maybe you did something wrong?
02:08:13 <mandaya> huh
02:08:26 <mandaya> maybe there's something wrong with my function that writes the floats...
02:10:43 <koeien> well ivanm used Doubles
02:10:46 <koeien> but Floats should also work
02:11:04 <mandaya> yea, I tested it in ghci myself
02:11:55 <mandaya> its annoying to figure out what's going on cause I'm stuck working with one of those "should be pure but isn't" foreign functions
02:12:11 <koeien> did you mark it as "safe" at least?
02:12:25 <mandaya> not using my own library
02:12:38 <mandaya> so I'm pushing data through unsafePerformIO right now
02:12:53 <mandaya> but that makes it really tough to figure out where thingsa ren'
02:12:58 <mandaya> * aren't working
02:23:51 <mandaya> oh, just realized what's wrong
02:23:56 <mandaya> I'm sitting inside the list monad
02:24:17 <mandaya> just cause I return the last bit doesn't mean the forced IO actions ever get performed
02:24:23 <mandaya> hmm
02:24:41 <koeien> unsafePerformIO strikes again
02:27:14 <mandaya> yep
02:27:22 <dreixel> I'm looking for a tool to test command-line programs. It should take an input program invocation, and compare its output to a reference. Something like http://hackage.haskell.org/package/shelltestrunner, but with better support for large outputs, for instance. Something like the GHC testsuite driver, but preferably in Haskell...
02:27:31 <dreixel> maybe someone here has some suggestions?
02:27:40 <mandaya> does quickcheck not work for you?
02:27:52 <dreixel> no, it's for command line programs.
02:28:00 <dreixel> I'm not looking for property testing.
02:28:05 <mandaya> ok
02:28:14 <dreixel> HUnit is also not what I want.
02:36:42 <mandaya> is there a way to force a function to be strict in it's argument, even though there's no way to actually make use of the value?
02:36:50 <mandaya> (the IO action returns ())
02:36:50 <koeien> yes
02:36:53 <koeien> seq
02:37:05 <mandaya> thanks
02:37:16 <koeien> seq x y checks if x is _|_ and has value y
02:37:32 <koeien> operationally it forces x
02:37:32 <dobblego> you can use ! on a function argument with a GHC extension to denote strict
02:37:41 <koeien> yes that desugars into seq
02:37:48 <mandaya> seq does exactly what I want, and it's a little easier to work in
02:37:59 <mauke> if you're in IO, you can use evaluate
02:38:04 <mandaya> I'm not :(
02:38:10 <dobblego> @type evaluate
02:38:11 <lambdabot> Not in scope: `evaluate'
02:38:11 * mandaya feels dirty
02:38:12 <koeien> so (unsafePerformIO launchMissiles) `seq` 37  has value 37 but launches missiles
02:38:31 <koeien> it might, of course, launch missiles zero or more times since you've used unsafePerformIO
02:38:52 <mandaya> in this case the function is genuinely pure
02:39:06 <mandaya> so having it executed multiple times isn't an issue
02:39:23 <mandaya> it's an IO action because it's a foreign function that writes into a struct
02:39:30 <koeien> yes you promised that to the compiler when you used unsafePerformIO :)
02:40:06 <dcoutts> mandaya: what's the argument that it's pure?
02:40:38 * dcoutts has been bitten by variants of unsafePerformIO even when it's "genuinely pure"
02:40:47 <koeien> dcoutts: how? thread safety?
02:40:59 <mandaya> dcoutts: I'm worried about the same, but what I'm thinking is this
02:41:14 <mandaya> the function writes a provided value into a memory buffer at the specified location
02:41:22 <mandaya> so provided it actually does what it says
02:41:27 <mandaya> if it gets called multiple times
02:41:36 <mandaya> it just writes the same value into the same location multiple times
02:41:39 <mandaya> which is no issue at all
02:42:09 <mandaya> the values being written and the locations they get written into are generated by pure code
02:42:18 <dcoutts> koeien: that (prior to the noDuplicate feature), plus moving resources uses outside the scope of with* style resource management utils, worse things with inlinePerformIO
02:42:38 <dcoutts> koeien: several really nasty ones in ByteString over the years
02:43:04 <koeien> yup i can see that, I avoid it. I only used it to read a constant file to have a string at toplevel
02:43:26 <dcoutts> koeien: ah see I actually think that's more evil
02:43:40 <dcoutts> that's using unsafePerformIO to structure your app
02:43:47 <koeien> it's somewhat evil, but it was not extremely critical code
02:44:06 <dcoutts> rather than to present a pure abstraction with a low level implementation
02:44:07 <koeien> yeah but i didn't want to pass it everywhere or run all my code in a custom monad
02:44:28 <koeien> the code does not run anymore, it was only necessary for like a week :)
02:44:41 <koeien> of course it was a hack
02:44:42 <dcoutts> mandaya: and the structure is allocated and deallocated within the same unsafePerformIO block?
02:44:51 <dcoutts> koeien: ok :-)
02:45:13 <mandaya> no, the structure is passed into the unsafePerformIO block and pulled out
02:45:30 <mandaya> a nasty issue with working with C libraries
02:45:42 <mandaya> I just got bit by that
02:45:58 <mandaya> (the call to unsafePerformIO never happened because it basically wasn't needed)
02:46:36 <koeien> yes unsafePerformIO launchMissiles `seq` () does not *guarantee* that missiles get launched, I assume
02:47:13 <mandaya> also, I'm trying to test my fixes, but quickcheck apparently can't generate arbitrary sized lists... the length of the list is just as random as the values
02:47:19 <dcoutts> koeien: there are not many guarantees about unsafePerformIO, but I think it would
02:47:28 <dcoutts> it's hard to formalise something that can segfault
02:47:35 <mandaya> is there a way to ask it to generate lists of a particular size?
02:47:36 <dcoutts> and break the type system
02:47:50 <mandaya> or do I need to write my own instance of arbitrary
02:47:57 <dcoutts> mandaya: yes, see the Gen combinators
02:48:04 <dcoutts> in one of the QC modules
02:48:08 <mandaya> thanks
02:48:14 <dobblego> there is an Arbitrary for tuples and Gen is a Functor
02:48:31 <dcoutts> vector is the function you're looking for iirc, generates a list of a given length
02:48:47 <mandaya> ok, thanks
02:48:50 <dobblego> arbitrary3List = (\(a, b, c) -> [a, b, c]) `fmap` arbitrary -- for example
02:48:58 <dcoutts> yeah, or tuples, if you mean a really short list
02:49:01 <dobblego> ah yes they are probably built in
02:50:07 <mandaya> nah, it's long
02:50:23 <mandaya> and I'm shortening it for testing purposes
02:50:37 <mandaya> (I'm trying to generate random images basically)
02:50:44 <mandaya> (so 640x480)
02:52:38 <x_man> If I change lemma of inversion of subtyping relation like this:
02:52:38 <x_man> If S1->S2=<T  then T has form T1->T2, with T1=<T and S2=<T2
02:52:38 <x_man> can I refer proof of original lemma for this lemma?
02:52:38 <x_man> original lemma is stated here
02:52:39 <x_man> http://www.inf.ed.ac.uk/teaching/courses/tpl/lectures/1101.pdf
02:53:38 <mandaya> hahaha, of course it works that way... it performs *exactly* the one action that gets requested even though it should technically depend on all the previous actions...
02:54:20 <x_man> mandaya: ?
02:54:30 <x_man> was it addressed to me?
02:54:35 <mandaya> x_man: no
02:54:48 <x_man> ok :)
02:55:10 <mandaya> x_man: lamenting the difficulty in correctly using unsafePerformIO
02:56:45 * hackagebot Catana 0.2 - A monad for complex manipulation of a stream.  http://hackage.haskell.org/package/Catana-0.2 (DustinDeWeese)
02:57:35 <Rc43> Hi, guys.
02:57:42 <dobblego> hi Rc43!
02:57:46 <koeien> hi Rc43
02:58:02 <Rc43> Is there function for filtering uniqie elements of list?
02:58:08 <luite> nub
02:58:09 <koeien> nub
02:58:15 <koeien> > nub  [1,2,3,4,4,3]
02:58:16 <lambdabot>   [1,2,3,4]
02:58:18 <Rc43> oh, yes, I forgot
02:58:26 <Rc43> searched for `unique`
02:58:39 <dobblego> I used to ride a RC51 but I threw it down the road last week
02:58:41 <koeien> or Data.Set.toList . Data.Set.fromList if you don't care about ordering
02:58:55 <luite> and if you don't have infinite lists...
02:59:04 <koeien> hmm
02:59:17 <Rc43> heh
03:01:57 <Rc43> btw, is `length . nub . elems` a single way to count unique values in map?
03:02:17 <koeien> M.size iirc
03:02:28 <koeien> map already enforces uniqueness
03:02:39 <Botje> S.size . S.fromList . M.elems
03:02:51 <Botje> (where S = Data.Set, M = Data.Map)
03:03:00 <hpaste> mandaya pasted “setData” at http://hpaste.org/63861
03:03:06 <merijn> koeien: Map enforces unique keys, if he wants unique values...
03:03:10 <Botje> what you proposed also works, but is O(N^2)
03:03:10 <dobblego> @type Data.Map.size -- I really think you want this instead
03:03:11 <lambdabot> forall k a. M.Map k a -> Int
03:03:14 <koeien> woops, values!
03:03:15 <mandaya> ok, pasted the function I'm working on
03:03:20 <mandaya> any one have any ideas?
03:03:28 <koeien> of course, what botje suggested (if you have an Ord)
03:03:31 <merijn> koeien: Not sure whether he wants that, but that seems the most logical implementation to me
03:03:42 <merijn> s/implementation/interpretation
03:03:46 <merijn> My mind is broken again
03:03:52 <ion> Yeah. If you want to calculate the number of some unique elements and you’re okay with a strict result in a potentially different order, S.size . S.fromList can be much better than nub.
03:03:55 <mandaya> I assumed asking for the last element of the list would force the generation of the entire list
03:04:06 <mandaya> but only the very last element gets set
03:04:34 <merijn> mandaya: Generation of the entire list yes, but not of the values in that list
03:04:49 <merijn> mandaya: You could just end with a list of thunks, I think
03:05:08 <merijn> (Some confirm if I'm right :p)
03:05:15 <mandaya> merijn: yea, makes sense based on what I'm observing
03:05:19 <Rc43> Botje, `length . nub . elems` is O(N^2)? Why?
03:05:28 <koeien> Rc43: because nub is
03:05:33 <mandaya> I tried mapping seq over the list, but that didn't change anything
03:05:40 <mandaya> not surprising
03:05:53 <merijn> mandaya: I think you need deepSeq or something like that?
03:05:57 <merijn> :t deepSeq
03:05:58 <lambdabot> Not in scope: `deepSeq'
03:06:01 <merijn> hmm
03:06:02 <koeien> mandaya: seqList [] = []; seqList (x:xs) = seq x (seqList xs)
03:06:02 <Rc43> koeien, nub uses double loop for searching unique? Why not storage unique values?
03:06:03 <quicksilver> mandaya: why are you fighting unsafePeformIO in this complicated way
03:06:04 <mandaya> @hoogle deepSeq
03:06:04 <lambdabot> Control.DeepSeq module Control.DeepSeq
03:06:04 <lambdabot> Control.DeepSeq deepseq :: NFData a => a -> b -> b
03:06:05 <lambdabot> package deepseq
03:06:06 <hpaste> “doug ransom” pasted “eclipseFP Woes” at http://hpaste.org/63862
03:06:13 <quicksilver> mandaya: why do you just do the work in IO so it's clear what gets done when
03:06:16 <koeien> mandaya: or rnf / NFData
03:06:24 <quicksilver> (you could then use *one* unsafePerformIO at the top level if you want)
03:06:36 <koeien> Rc43: nub does not have an Ord constraint, so it can't use a Set
03:06:47 <mandaya> quicksilver: I was having trouble doing that way because of the interplay between the list and IO monads
03:06:55 <mandaya> this way made more sense to me
03:07:04 <quicksilver> I believe you made the wrong choice.
03:07:14 <quicksilver> there is no interplay between the list and IO monads
03:07:17 <mandaya> quicksilver: entirely possible
03:07:20 <quicksilver> they're entirely separate, you just made a mistake :)
03:07:24 <mandaya> hmm
03:07:27 <mandaya> ok
03:07:29 <mandaya> I'll give it another go
03:07:33 <quicksilver> and getting that code clear is probably a good thing
03:07:37 <mandaya> agreed
03:07:37 <quicksilver> and more productive that your current fight
03:07:57 <Rc43> koeien, ok, I looked now at the source of nub, it uses common nubBy with predicate, so it is clear
03:07:58 <ChristianS> Rc43: if your values have an Ord constraint, you should use Set.fromList to convert your values to a set and then get the size of the set
03:08:05 <dougransom> These errors occurred in eclipsefp.  It was compiling ok for a few days, then suddenly it could not find the hunt package.  build wrapper and scion-browser never build when eclipsefp starts up (os x).  I'd be happy if the only feature I get working is the  compile.
03:08:12 <dougransom> http://hpaste.org/63862
03:08:13 <Rc43> ChristianS, is it fast?
03:08:22 <koeien> Rc43: yes! it's O(n log n)
03:08:40 <ChristianS> Rc43: much faster than nub, in any case. HashSet or IntSet might be even faster than normal Set, depending on your datatype.
03:08:55 <Rc43> koeien, but it can be O(n)
03:09:02 <koeien> no
03:09:05 <Rc43> ChristianS, its true
03:09:09 <merijn> dougransom: Why not just compile using GHC if that's the only thing you care about?
03:09:28 <Rc43> koeien< `elems` is O(n)
03:09:43 <Rc43> koeien, I can go through a list and remember visited
03:10:03 <koeien> yes, but testing for membership is O(n) in that way
03:10:10 <koeien> or O(log n), if you use a Set
03:10:19 <Rc43> koeien, yea, frgot this
03:10:19 <koeien> so you spend O(n^2) or O(n log n)
03:10:20 <ChristianS> Rc43: O(n) is only possible with impure data structures. if you're desperate, you could try the Hashtable package or something.
03:10:29 <koeien> yes perfect hashing or something
03:10:34 <koeien> but it's probably unnecessary
03:11:06 <Rc43> koeien, ChristianS, everything is clear now, thanks
03:16:00 <mandaya> @hoogle newIORef
03:16:00 <lambdabot> Data.IORef newIORef :: a -> IO (IORef a)
03:16:54 <quicksilver> in fact, "uniq" or "nub" or whatever you call it can't be faster than O(n log n)
03:17:07 <quicksilver> even perfect hashes take time to compute.
03:17:17 <Rc43> There is no way to create set from list excepting fromList? I need to store IORefs, it isn't Ord.
03:17:31 <koeien> no
03:18:13 <merijn> quicksilver: Well, then it becomes O(nk), k being the time to compute a single hash
03:18:24 <merijn> Assuming you have no collisions, otherwise it becomes worse
03:18:42 <merijn> So if k is rather small (less then log n) it could be worth it
03:19:02 <erus`> :t \f g a b -> (fa, g b)
03:19:03 <lambdabot> Not in scope: `fa'
03:19:07 <erus`> :t \f g a b -> (f a, g b)
03:19:08 <lambdabot> forall t t1 t2 t3. (t -> t2) -> (t1 -> t3) -> t -> t1 -> (t2, t3)
03:19:21 <koeien>  erus`: *** iirc
03:19:28 <MostAwesomeDude> :t ***
03:19:29 <lambdabot> parse error on input `***'
03:19:31 <koeien> :t (\f g -> f *** g)
03:19:32 <MostAwesomeDude> :t (***)
03:19:32 <lambdabot> forall (a :: * -> * -> *) b c b' c'. (Arrow a) => a b c -> a b' c' -> a (b, b') (c, c')
03:19:33 <lambdabot> forall (a :: * -> * -> *) b c b' c'. (Arrow a) => a b c -> a b' c' -> a (b, b') (c, c')
03:19:44 <quicksilver> merijn: k can't be less than log n for unknown data
03:19:47 <koeien> yes it's Arrow, but you can think of Arrow as (->)
03:20:09 <quicksilver> merijn: if your hash has no collisions you must inspect every bit of the inbound keys. So you must be log n.
03:20:27 <merijn> quicksilver: I'll take your word for it :)
03:21:04 <koeien> quicksilver: that makes sense
03:21:40 <erus`> is it bad practise to pass around a data type with some values set to undefined?
03:22:00 <koeien> unless it's very local, yes
03:22:13 <erus`> i will define a new one
03:22:41 <koeien> setTitle "37" (Author { title = undefined }) is fine
03:24:04 <quicksilver> on the other hand you can inspect only some bits, but then obviously you might have collisions
03:24:06 <koeien> but passing around stuff with undefined in them is asking for trouble
03:24:14 <quicksilver> and if you have collisions then you're definitely not O(1) any more.
03:24:42 <koeien> consider using Maybe if it makes more sense
03:25:44 <quicksilver> there is a cute trick where you do data Author f = { title :: f String, age :: f Int }
03:25:57 <quicksilver> and then "Author Maybe" is the type with possibly-not-filled fields
03:26:06 <quicksilver> and "Author Identity" is the type with all fields filled.
03:26:09 <mandaya> quicksilver: thanks for the tip, that was way easier and it works now
03:26:14 <quicksilver> it's only worth it if you need that though.
03:26:18 <quicksilver> mandaya: yay \o/
03:26:33 <mandaya> :)
03:26:49 * mandaya still feels dirty writing imperative code in haskell
03:26:51 <koeien> quicksilver: that's a very nice trick!
03:27:03 <dobblego> I wonder if there is a type-class for Author that gives rise to some generally useful operations (Lens-y like thing)
03:27:16 <Rc43> eeeehm, how to use Data.Unique? I can invent only using with Map.
03:29:03 <Rc43> Ahh, understood.
03:29:15 <dobblego> class Tuple2y k where tuple2y :: k f -> f (a, b) -- or something
03:29:24 <Rc43> Like (<unique>,<non-unique>).
03:29:32 <dobblego> class Tuple2y k where tuple2y :: k f -> (f a, f b) -- more like
03:34:26 <osa1> what's wrong with this code: http://paste.pocoo.org/show/552487/ ? I'm getting "The last statement in a 'do' construct must be an expression" error
03:35:36 <Axman6> osa1: can i suggest a slightly different coding style, that makes it harder to muck things up?
03:36:00 <osa1> Axman6: of course. I'm just learning haskell. btw this code is from real world haskell
03:36:37 <cwl> <built-in>:0:4: lexical error (UTF-8 decoding error)
03:36:55 <cwl> compiling ghc-syb-utils on WIN7
03:37:11 <cwl> how to walk around that?
03:38:16 <Axman6> osa1: this is how i'd write it: http://paste.pocoo.org/show/552489/
03:38:45 <Axman6> osa1: not sure where the error was coming from though
03:39:44 <Axman6> osa1: basically, if you've got a do block, put the do on the line before the first line of the block, and indent the block one more 'tab' from the previous line (usually, something you need more, depending on the situation)
03:39:58 <cwl> anyone met the same problem?
03:40:10 <cwl> lexcial error
03:40:45 <Axman6> cwl: i don;t know the answer, but i think we'd need more context than you
03:40:50 <Axman6> you've given*
03:40:59 <Botje> osa1: probably because lines 3--7 should be indented beyond the do
03:41:05 <nand`> Axman6: instead of when (not ineof) consider: unless ineof
03:41:44 <cwl> Axman6: I just type cabal install ghc-mod
03:41:51 <Axman6> i think it readsa better this way, "When not EOF, do this stuff"
03:42:03 <Axman6> cwl: do you have a log of all the output from running that?
03:42:16 <cwl> error occurs while compiling ghc-syb-utils
03:42:18 <Axman6> if so, paste ot on hpaste
03:42:25 <Axman6> it*
03:43:28 <nand`> readFile "input.txt" >>= writeFile "output.txt" . map toUpper
03:43:34 <hpaste> cwl pasted “lexical error” at http://hpaste.org/63863
03:43:38 <erus`> @hoogle (a, b) -> f -> f a b
03:43:39 <lambdabot> Data.Graph.Inductive.Graph delNode :: Graph gr => Node -> gr a b -> gr a b
03:43:39 <lambdabot> Data.Graph.Inductive.Graph delNodes :: Graph gr => [Node] -> gr a b -> gr a b
03:43:39 <lambdabot> Data.Graph.Inductive.Monad delNodeM :: GraphM m gr => Node -> m (gr a b) -> m (gr a b)
03:43:47 <erus`> @hoogle f -> (a, b) -> f a b
03:43:48 <lambdabot> Data.Graph.Inductive.Graph delNode :: Graph gr => Node -> gr a b -> gr a b
03:43:48 <lambdabot> Data.Graph.Inductive.Graph delNodes :: Graph gr => [Node] -> gr a b -> gr a b
03:43:48 <lambdabot> Data.Graph.Inductive.Monad delNodeM :: GraphM m gr => Node -> m (gr a b) -> m (gr a b)
03:43:49 <cwl> Axman6: posted
03:44:25 <aadrake> Hello all.  Is there a way to modify the verbosity of the decode function in Aeson so I can figure out why my parse attempts are always returning Nothing?
03:45:26 <dougransom> @pl         (max  (antecedentCurve inputVal)) . consequenceCurve
03:45:27 <lambdabot> max (antecedentCurve inputVal) . consequenceCurve
03:45:52 <cwl> Axman6: http://aur.archlinux.org/packages.php?ID=17845
03:46:10 <cwl> Axman6: someone met that problem but seems no solution
03:46:39 <Botje> dougransom: you need to specify the parameters you want to eliminate
03:46:49 <Botje> @pl \inputval -> max (antecedentCurve inputVal) . consequenceCurve
03:46:49 <lambdabot> const (max (antecedentCurve inputVal) . consequenceCurve)
03:46:55 <Botje> for example.
03:47:35 <cwl> Axman6: http://hackage.haskell.org/trac/ghc/ticket/3585 another, but 2 years ago
03:52:09 <erus`> @hoogle (a -> b) -> (a, c) -> (b, c)
03:52:09 <lambdabot> Data.Graph.Inductive.Query.Monad mapFst :: (a -> b) -> (a, c) -> (b, c)
03:52:10 <lambdabot> Data.Graph.Inductive.Query.Monad (><) :: (a -> b) -> (c -> d) -> (a, c) -> (b, d)
03:52:10 <lambdabot> Data.Graph.Inductive.Graph nmap :: DynGraph gr => (a -> c) -> gr a b -> gr c b
03:53:28 <erus`> mapFst should be a Prelude thing :3
03:54:10 <byorgey> it's written   f *** id
03:54:20 <ion> @type (*** id)
03:54:21 <lambdabot> forall b c b'. (b -> c) -> (b, b') -> (c, b')
03:55:01 <ion> @type first
03:55:01 <lambdabot> forall (a :: * -> * -> *) b c d. (Arrow a) => a b c -> a (b, d) (c, d)
03:55:28 <ion> @type first `asAppliedTo` (undefined :: a -> b)
03:55:29 <lambdabot> forall b c d. (b -> c) -> (b, d) -> (c, d)
03:58:29 <Rc43> Can I test two IORefs on referencing to one object?
03:59:00 <Rc43> Without comparing objects, I mean.
04:00:17 <Rc43> But such possibility seems to be equal to `insatance Eq IORef`.
04:00:37 <Botje> Rc43: at least the GHC version of IORefs compares the pointers
04:01:26 <Rc43> Botje, I don't see sych function on hackage.
04:01:29 <Rc43> *u
04:01:43 <Botje> Rc43: it's the Eq instance, right
04:02:03 <Botje> so you can use the == and /= operators
04:02:04 <Rc43> Oh, yes, now I see it, thanks
04:03:52 <aadrake> Hello all.  Is there a way to modify the verbosity of the decode function in Aeson so I can figure out why my parse attempts are always returning Nothing?
04:04:18 <aadrake> Oops.  Up-arrow got me.
04:04:50 <byorgey> aadrake: since its type is FromJSON a => ByteString -> Maybe a, there cannot possibly be
04:05:59 <byorgey> it can't do anything except return a Maybe a; it can't produce any other information, verbose or otherwise
04:06:58 * hackagebot shake 0.2.6 - Build system library, like Make, but more accurate dependencies.  http://hackage.haskell.org/package/shake-0.2.6 (NeilMitchell)
04:07:01 <byorgey> aadrake: try using the 'json' function instead, which gives you a Parser Value
04:07:33 <byorgey> aadrake: see http://hackage.haskell.org/packages/archive/attoparsec/0.10.1.0/doc/html/Data-Attoparsec-ByteString.html#t:Parser
04:07:38 <aadrake> byorgey: I was afraid of that.  It is possible to only parse certain keys/values out of a JSON record, right?  I don't have to specify all possible keys in my data type, or do I?
04:07:56 <byorgey> looks like there are ways to run an attoparsec parser which will give you more information about why it failed
04:08:03 <byorgey> aadrake: I have no idea.
04:09:51 <Rc43> Why `seq (print 1) (print 2)` doesn't print "1" but only "2" ?
04:10:00 <koeien> print 1 is an IO action
04:10:09 <koeien> you *evaluated* the IO action, you did not *execute* it
04:10:31 <koeien> that is a profound difference in Haskell
04:10:32 <ion> > print 1  -- evaluated (and incidentally shown), not executed
04:10:33 <lambdabot>   <IO ()>
04:10:39 <aadrake> byorgey: Thanks for the help.
04:11:17 <ion> > print 1 `seq` print 2  -- Both are evaluated now. The latter is incidentally shown. Neither is executed here, but as lambdabot shows the latter value, e.g. GHCi would execute it.
04:11:18 <lambdabot>   <IO ()>
04:11:23 <Rc43> koeien, understood
04:11:57 <mauke> Rc43: seq (print 1) (print 2) doesn't print enything
04:11:59 <mauke> not even 2
04:12:16 <Rc43> mauke, ghci prints 2 for me
04:12:19 <mauke> > length [seq (print 1) (print 2), seq (print 1) (print 2), seq (print 1) (print 2)]
04:12:20 <lambdabot>   3
04:12:40 <mauke> Rc43: because you told it to execute the result of 'print 2'
04:12:45 <ion> > let print x = "please print " ++ show x ++ " upon execution, thanks" in print 1 `seq` print 2
04:12:46 <lambdabot>   "please print 2 upon execution, thanks"
04:12:48 <mauke> print 2 itself does nothing
04:12:55 <Rc43> mauke, yes, forgot again about it
04:13:03 <Rc43> thanks
04:19:42 <Tinned_Tuna> :t seq
04:19:43 <lambdabot> forall a t. a -> t -> t
04:20:46 <Tinned_Tuna> :t \a b -> seq (print a) (print b)
04:20:47 <lambdabot> forall a a1. (Show a, Show a1) => a -> a1 -> IO ()
04:21:01 <Tinned_Tuna> :t \a b c -> seq (print a) (print b) (print c)
04:21:01 <lambdabot>     Couldn't match expected type `IO () -> t'
04:21:02 <lambdabot>            against inferred type `IO ()'
04:21:02 <lambdabot>     In the expression: seq (print a) (print b) (print c)
04:21:57 <slack1256> when learning to use monad "Maybe" was the easiest one.
04:22:03 <slack1256> which is the easiest arrow?
04:22:10 <koeien> ->
04:22:18 <Botje> function arrow
04:22:33 <koeien> it's also the only Arrow i understand.
04:22:43 <Botje> Arrow a => a b c  is actually b -> c
04:22:52 <hpc> Kleisli is the one to learn next
04:23:09 <mekeor> what's kleisli?
04:23:13 <hpc> koeien: http://hpc.dyndns-web.com:8000/blog/view.cgi?id=8 -- might help you to understand Kleisli
04:23:16 <koeien> it's a mathematician
04:23:17 <slack1256> with kleisli is when you start doing interesting thing?
04:23:26 <hpc> mekeor: it's basically the category of functions (a -> m b)
04:23:38 <hpc> @src Kleisli
04:23:39 <lambdabot> Source not found. Are you on drugs?
04:23:53 <mekeor> lol
04:23:58 <hpc> newtype Kleisli m a b = Kleisli {runKleisli :: a -> m b}
04:23:58 <slack1256> hpc: ohh, that why people say monads can be generalized to arrow?
04:24:05 <hpc> yes
04:24:50 <mekeor> hpc: that http://en.wikipedia.org/wiki/Kleisli_category ?
04:25:04 <hpc> mekeor: yes
04:27:36 <mekeor> Does something like GitHub exist for darcs? Hackage itself doesn't contain repositories, right?
04:28:00 <koeien> darcsden, patch-tag
04:28:06 <koeien> but not as mature as github, by far
04:28:24 <erus`> that feel when a line is exactly 80 chars :)
04:28:36 <hpc> erus`: lol
04:28:57 <hpc> erus`: i like it better when a function is point-free and nothing but compositions
04:30:07 <mekeor> koeien: okay, i see. thanks
04:30:27 <mekeor> what's code.haskell.org ?
04:30:38 <mekeor> is it like github, too?
04:30:39 <alpounet> mekeor, there's also http://community.haskell.org/
04:30:52 <alpounet> which offers a darcs repo, a trac instance, a mailing list
04:31:42 <mekeor> alpounet: nice, wow.
04:33:09 <quicksilver> koeien: not as mature in the sense of "older, but worse" :-(
04:33:26 <koeien> yes, for various reasons
04:33:29 <quicksilver> nod
04:33:54 <koeien> i stopped using darcs a long time ago :( the model was nice, but it was slow
04:34:02 <quicksilver> github really hit on something with the idea of making it trivial for *any* user, affiliated or not, to branch a project and make that branch instantly public
04:34:07 <quicksilver> such an obvious idea
04:34:14 <quicksilver> but someone had to make it really, really, easy.
04:34:21 <mekeor> quicksilver: yea, that's grat
04:34:25 <mekeor> great
04:34:29 * byorgey doesn't find darcs to be slow any more.
04:34:31 <koeien> i don't like git as much, hg > git
04:34:45 <koeien> byorgey: yeah i read that they improved a lot in 2.x. unfortunately i had already switched then :(
04:34:48 <adimit> as long as nobody forces svn on me, i'm fine :-P
04:35:09 <merijn> koeien: Fortunately hggit works pretty well for interacting with github :)
04:37:23 <mekeor> adimit: hehe
04:39:15 <osa1> anyone has any ideas about this problem: http://paste.pocoo.org/show/552512/
04:40:08 <donri> osa1: i think that's the ghc library, not the executable
04:40:48 <osa1> donri: no package named "ghc"
04:40:54 <osa1> donri: I tried cabal install ghc
04:41:02 <donri> may have to get it from where you got ghc
04:41:38 <osa1> donri: right. thanks.
04:43:46 <byorgey> osa1: what is the output of 'ghc-pkg list ghc' ?
04:44:15 <slack1256> osa1: also what distro are you using?
04:44:43 <osa1> I'm downloading ghc-ghc from my distro's package manager, I think this will solve the problem
04:44:46 <osa1> slack1256: opensuse 12.1
04:45:11 <osa1> yeah, leksah is installing now
04:45:29 <osa1> omg
04:45:30 <duairc> Can Unsafe.Coerce be safely used to coerce between a type and a newtype wrapper around that type?
04:46:06 <donri> why would you do that?
04:46:12 <mkramer> Hi guys. More piddling haskell questions for you all today.  I have a pastie http://pastie.org/3401428
04:46:26 <byorgey> duairc: yes, but I have the same question as donri
04:46:26 <osa1> http://paste.pocoo.org/show/552512/ http://paste.pocoo.org/show/552514/
04:46:50 <osa1> leksah needs ghc and haddoc, and haddoc needs ghc. but leksah's and haddoc's version requirement are incompatible
04:46:57 <mkramer> Essentially this is the first time I've tried to use an IO action from within another IO action, and I think the problem is in the type of getRestaurant, but I'm not sure
04:47:19 <koeien> mkramer: return (pickResturant … )
04:47:30 <mkramer> That's it?
04:47:34 <koeien> GHC is telling you that pickRestaurant idx restaurants 0 is not an IO action
04:47:39 <duairc> byorgey, donri: It's kind of a hack, I need the "real" type underneath a newtype that I'm using from another package, and the unwrapper function isn't exported from it.
04:47:43 <koeien> that's right, because it's a Restaurant
04:47:56 <koeien> you can make any Restaurant into an IO Restaurant by using "return"
04:47:58 <donri> duairc: pattern match?
04:48:07 <duairc> The constructor isn't exported either.
04:48:42 <nand`> A GHC compiled binary will work without any haskell dependencies right?
04:48:43 <byorgey> mkramer: also, I would strongly urge you to put type signatures on all your top-level things.  It will (a) help you think more clearly about what you intend and (b) result in better (more localized) error messages
04:48:56 <mkramer> so return creates an IO action out of my pure functional code?
04:49:02 <koeien> yes
04:49:02 <nand`> other than POSIX and other obvious APIs/libs
04:49:11 <donri> osa1: cabal install 'haddock < 2.9.4'
04:49:21 <byorgey> mkramer: yes, return x  is the IO action which doesn't do any IO and just results in x
04:49:22 <donri> or get haddock from suse
04:49:24 <koeien> return x turns a pure value x into an action that, when executed, returns x
04:49:37 <nand`> koeien: only in the context of IO
04:49:39 <mkramer> the annoying thing is that I thought that was the case based on the type error, but I didn't have parens on the return statement when I tried it :)
04:49:46 <byorgey> hehe
04:49:53 <koeien> nand`: no, any monad. but it works for IO.
04:50:02 <koeien> you don't need to understand monads to do IO
04:50:34 <byorgey> mkramer: return pickRestaurant idx foo  parses as   ((return pickRestaurant) idx) foo
04:51:06 <byorgey> which (as I hope you can see) does not make sense
04:52:04 <mekeor> so, QuickCheck is used to test a pure (or rather non-monadic) function by trying random inputs and testing an invariant condition on the output of the function, right?
04:52:16 <koeien> yes
04:52:23 <mekeor> nice, thanks
04:52:39 <byorgey> mekeor: actually, the latest versions of QuickCheck can be used to tast monadic functions too
04:52:44 <byorgey> *test
04:53:32 <mekeor> cool
04:54:45 <nand`> koeien: So [1] is an action that when executed, returns 1?
04:54:49 <nand`> because that's what you just said
04:55:11 <hpc> nand`: he was explaining in terms of IO only
04:55:17 <Axman6> mekeor: if something is a monad, it doesn't mean it's not pure. most monads are completely pure
04:55:22 <nand`> hpc: that's why I said nand` │ koeien: only in the context of IO
04:55:41 <mekeor> Axman6: oh, right. i'm sorry. of course, yes.
05:00:04 <mux> can someone explain me when it makes sense to have generic instances for functor compositions? the :.: type operator
05:01:11 <mkramer> byorgey: I'll try putting type sigs on there. It does help to think in types
05:01:21 <mkramer> someone else told me not to do it
05:01:27 <mkramer> it sounded fishy at the time
05:06:52 <mandaya> mkramer: whoever told you not to is sadistic...
05:07:02 <mkramer> one more simple question.  Now that getEntry :: IO () works correctly, I want to do it 80 times in main
05:07:14 <hpc> :t repeat
05:07:15 <lambdabot> forall a. a -> [a]
05:07:16 <koeien> replicateM 80
05:07:25 <hpc> :t replicateM
05:07:26 <lambdabot> forall (m :: * -> *) a. (Monad m) => Int -> m a -> m [a]
05:07:36 <koeien> more likely replicateM_
05:07:49 <hpc> that will give you a list of [(), (), ... 80 times]
05:07:55 <hpc> what koeien said
05:08:03 <mkramer> thanks, I can take it from there
05:15:26 <rostayob> dreixel: mhm... yours does something much more complicated
05:16:23 <mkramer> is there a way to get :t like information from inside of haskell code?
05:16:52 <koeien> what would you like to accomplish?
05:17:26 <mkramer> let entries = replicateM 80 getEntry
05:17:47 <mkramer> now, based on the type sig of replicateM which I have checked in GHCi, I know that entries :: m [a]
05:17:55 <mekeor> > replicateM_ 5 (print "hello")
05:17:56 <lambdabot>   <IO ()>
05:17:58 <koeien> that's correct
05:18:07 <koeien> in fact it's IO [()]
05:18:16 <koeien> since getEntry :: IO ()
05:18:19 <mkramer> but really I'd just like to do something like print $ typeof(entries)
05:18:33 <mkramer> sorry... print $ typeof entries
05:18:48 <koeien> i don't have your paste handy anymore, what was the URL?
05:18:59 <mkramer> The program has changed a lot
05:19:03 <rwbarton> that's easy, print "IO [()]" :P
05:19:23 <koeien> rwbarton: yeah i assume s/he has an ADT of some kind
05:19:25 <koeien> ;)
05:19:48 <rwbarton> > typeOf $ replicateM 5 (print "hello")
05:19:48 <lambdabot>   IO [()]
05:19:59 <rwbarton> > show $ typeOf $ replicateM 5 (print "hello")
05:20:00 <lambdabot>   "IO [()]"
05:20:20 <rostayob> mkramer: that rwbarton did requires Data.Typeable
05:20:26 <rwbarton> @hoogle typeOf
05:20:26 <lambdabot> Data.Typeable typeOf :: Typeable a => a -> TypeRep
05:20:26 <lambdabot> Data.Typeable typeOf1 :: Typeable1 t => t a -> TypeRep
05:20:26 <mkramer> Ok, good, I was hoping that was possible
05:20:26 <lambdabot> Data.Typeable typeOf1Default :: (Typeable2 t, Typeable a) => t a b -> TypeRep
05:20:27 <rostayob> which is kind of ugly, but works
05:20:28 <rwbarton> yeah
05:20:39 <koeien> this might not be what you want, I'm not sure.
05:20:39 <mkramer> thanks
05:20:39 <rwbarton> it's a strange thing to do, but it is there
05:20:42 <rostayob> mkramer: only for monomorphic types
05:20:56 <dreixel> rostayob: it does more :)
05:21:22 <dreixel> rostayob: but in general I think you have to try to be careful not to keep generate huge values
05:21:55 <hpaste> rostayob pasted “dreixel” at http://hpaste.org/63865
05:22:01 <mkramer> Next question. I have entries :: m [Float], and I want to print the sum of that
05:22:11 <rostayob> dreixel: ^^^ that's what I do, check genericArbitraryFreq
05:22:20 <rostayob> for a description
05:22:22 <koeien> (liftM sum) ..
05:22:23 <rostayob> I didn't think much about it
05:23:27 <rostayob> but the code is much much simpler
05:23:41 <mkramer> ok ... reading up on liftM now...
05:23:47 <mkramer> the rabbit hole just keeps getting deeper
05:23:59 <osa1> how many parameters does this function take? bind :: (Float -> (Float,String)) -> ((Float,String) -> (Float,String))
05:24:12 <rostayob> mkramer: you probably don't want to use Typeable
05:24:12 <dreixel> rostayob: wow, this is big
05:24:15 <dreixel> but it looks good
05:24:20 <dreixel> have you tested it? :)
05:24:27 <rostayob> dreixel: yes
05:24:27 <mkramer> osa1: one?
05:24:35 <rostayob> dreixel: well it's the whole source for Arbitrary
05:24:38 <mkramer> sorry, 2
05:24:47 <rostayob> dreixel: the interesting part is at the end really
05:25:05 <dreixel> oh, I see, this is not all generic code
05:25:14 <dreixel> but I see you also implemented shrink
05:25:17 <rostayob> yes
05:25:21 <osa1> mkramer: how do you understand it's 2? I'm still thinking it should be one
05:25:24 <dreixel> so it all works nicely?
05:25:45 <rostayob> dreixel: nicely apart from the fact that I'd like to be able to define a better default arbitrary
05:25:57 <rostayob> that chooses each constructor with the same probablity
05:25:59 <rostayob> apart from that yes
05:26:16 <dreixel> rostayob: but 1) why can't you do that, and 2) why would you want that?
05:27:04 <rostayob> dreixel: I can't do that for N-constructor datatypes because you can't pattern match :+: generically
05:27:06 <dreixel> rostayob: I think by default they shouldn't have the same probablilty, else constructors that branch a lot will happen as often as constructors that stop, meaning on average you will get very large values
05:27:20 <rostayob> dreixel: well what's the "sane" default then?
05:27:36 <HugoDaniel> here is my favourite haskell one-liner:
05:27:41 <HugoDaniel> main = interact reverse
05:27:49 <dreixel> rostayob: oh, I don't know.
05:28:08 <dreixel> rostayob: I'm afraid it's not easy. it would involve looking at the number of recursive occurrences per constructor, and choosing based on that
05:28:24 <rostayob> dreixel: yeah... anyways I think it's fine
05:28:35 <rostayob> another nice thing would have to have 'shrink' to shrink the K1 values
05:28:45 <dreixel> rostayob: it's certainly a good first implementation
05:28:52 <rostayob> so 'Leaf 4' would return [Leaf (shrink 4)]
05:28:58 <rostayob> instead of []
05:29:08 <dreixel> ah. is that hard?
05:29:59 <rostayob> yes, because when you're defining the K1 instance you don't know what the "upper" type is
05:30:01 <rostayob> I mean you could
05:30:28 <ChristianS> mkramer, osa1 : i would think 1, too? (it takes a function and returns a function)
05:30:34 <rostayob> match the inner K1 when defining the instance for M1
05:30:36 <dreixel> rostayob: you can have something like "(Arbitrary a) => GArbitrary (K1 i a)"
05:30:41 <dreixel> no?
05:30:52 <dreixel> then you can use "shrink" on that "a"
05:30:54 <osa1> ChristianS: well, it's not. here's the definition: bind f' (gx,gs) = let (fx,fs) = f' gx in (fx,gs++fs)
05:31:16 <osa1> ChristianS: I'm trying to understand how this works
05:31:29 <rostayob> dreixel: wait
05:31:33 <rostayob> we're talking about shrink
05:31:39 <rostayob> in Arbitrary that's what I do
05:31:56 <dreixel> rostayob: yes, but can't you do the same in shrink?
05:32:19 <rostayob> dreixel: no, because the type of the list has to be the same all the way doen
05:32:21 <HugoDaniel> what are you favorite oneliners ?
05:32:21 <rostayob> *down
05:32:56 <rostayob> dreixel: for example doing that you'd have some [a] on the left and some [b] on the right of a :*:
05:33:22 <rostayob> I think you can do it by matching the K1 on the M1, or something like that
05:34:00 <dreixel> rostayob: ah, I see.
05:34:36 <rostayob> dreixel: but matching on the K1 would require UndecidableInstances, I think.
05:34:45 <rostayob> or maybe not... I'll try later
05:35:14 <ChristianS> osa1: i just let ghc figure our the type of the bind function you defined above and actually its  bind :: (t -> (t1, [a])) -> (t, [a]) -> (t1, [a])
05:36:15 <ChristianS> osa1: ah, your type works as well: bind :: (Float -> (Float,String)) -> (Float,String) -> (Float,String)
05:36:34 <ChristianS> one of the parenthesis was unnecessary and did confuse me
05:37:08 <osa1> ChristianS: yeah, same here
05:37:12 <osa1> ChristianS: thanks
05:37:29 <osa1> ChristianS: I'm still having trouble seeing which paenthesis are optional
05:38:02 <ChristianS> osa1: use hlint on your code, it suggested removing the paren
05:44:39 <osa1> ChristianS: how are you running hlint? I installed it from cabal but can't run with just hlint
05:51:43 <ChristianS> osa1: just hlint <sourcefile>, hlint is in my path. but i remember that cabal installs executables in a very strange location. it should have told where when you installed hlint. add that directory to your PATH.
05:53:31 <osa1> ChristianS: thanks. I added ~/.cabal/bin to PATH and know it works
05:55:21 <ChristianS> osa1: in addition to using hlint I also like running ghc with -Wall . together, they give a lot of useful suggestions.
06:35:34 <rostayob> dreixel: Ok, I sent the patch. Let's see what they think :)
06:44:37 <Boxo> http://hpaste.org/63866 <- how can I split ifs to multiple lines in a do block?
06:45:19 <epsil> hi, I'm reading Learn You a Haskell, and have reached the chapter on recursion
06:45:30 <epsil> and I notice that none of the examples are tail-recursive
06:45:33 <dreixel> rostayob: great
06:45:43 <dreixel> rostayob: I'm not subscribed to that list, but I hope they like it
06:46:05 <donri> epsil: indent "else" more than "if"
06:46:13 <donri> uh, Boxo*
06:46:15 <donri> sorry
06:46:29 <epsil> np ;)
06:46:51 <donri> Boxo: a common way to format it is to put "then" on its own line too, and line up "else" with that
06:46:54 <Boxo> :r
06:46:56 <Boxo> whoops
06:46:59 <dmwit> epsil: Tail recursion isn't that useful in a lazy language.
06:47:07 <dmwit> Productive recursion is better.
06:47:14 <epsil> dmwit: aha
06:47:26 <epsil> and what is productive recursion?
06:47:38 <dmwit> It's where the recursive call is under a constructor.
06:47:43 <Boxo> nope dmwit, http://hpaste.org/63867 doesn't work
06:47:43 <dmwit> ?src map
06:47:44 <lambdabot> map _ []     = []
06:47:44 <lambdabot> map f (x:xs) = f x : map f xs
06:48:19 <merijn> epsil: The problem with (for example) "map f (x:xs) = f x : map f xs" in strict languages is that it traverses the entire list xs before returning (horribly inefficient if you later traverse it again)
06:48:25 <Boxo> (even if I indent that last else one more to the right)
06:48:26 <dmwit> epsil: Notice that the recursive calll to "map" is protected by a (:) constructor.
06:48:42 <hpaste> donri annotated “a” with “a (annotation)” at http://hpaste.org/63866#a63868
06:48:46 <rostayob> dreixel: wait, is there a list?
06:48:49 <Boxo> meh, lets in do blocks have never worked properly, guess I'll just use braces and semicolons
06:48:54 <merijn> epsil: Since haskell is lazy "f x : map f xs" will just return "f x : <thunk of computation to do later>"
06:49:13 <dmwit> Boxo: You also must indent the value of a thing more than the name of the thing.
06:49:25 <dmwit> Boxo: So indent lines 3-8 more than the "z" in line 2.
06:49:39 <epsil> okay, so it postpones the recursion?
06:49:44 <merijn> epsil: Eh, wait. I'm an idiot. The problem is that map can't return until all the other maps have run
06:49:53 <dmwit> epsil: More correctly, it will return <thunk for f x> : <thunk for map f xs>
06:49:53 <merijn> epsil: Thus eating up stack space
06:50:00 <donri> Boxo: may need to indent after "let" more too btw
06:50:39 <epsil> but lazy or not, would it not consume the same stack space when I actually execute it?
06:50:42 <abcdef> what is currying useful for, besides saving some typing?
06:50:53 <Boxo> dmwit: oh that works
06:51:09 <merijn> epsil: No, because it does "map -> return thunk -> inspect tail (this calls map, which again returns a thunk)"
06:51:12 <rostayob> dreixel: oh yes there is.
06:51:32 <merijn> epsil: The fist map has already returned before the second map runs, thus the stack doesn't grow
06:51:50 <dmwit> abcdef: By currying, do you mean partial application or the conversion of a (a,b) -> c function into an a -> b -> c function?
06:52:20 <koeien> abcdef: essentially nothing except for making the code nicer
06:52:28 <koeien> abcdef: it makes partial application very neat
06:52:43 <abcdef> i mean the transformation
06:52:49 <koeien> e.g. map (f 3) xs  vs map (\y -> f (3, y)) xs
06:52:49 <erus`> if there a nice way to define [n,n-1..] where n is a huge expression ?
06:53:08 <Botje> erus`: enumDownFrom or somesuch. check the Enum typeclass
06:53:19 <epsil> merijn, dmwit: I see, thanks for the help
06:53:21 <merijn> > let n = 10 in [n,n-1..]
06:53:22 <lambdabot>   [10,9,8,7,6,5,4,3,2,1,0,-1,-2,-3,-4,-5,-6,-7,-8,-9,-10,-11,-12,-13,-14,-15,...
06:53:34 <merijn> erus`: Just use let/where for n?
06:53:48 <erus`> but points :(
06:54:02 <koeien> iterate pred hugeExpression
06:54:15 <chridi> erus`: let e = ... in [e, e - 1 ..]
06:54:16 <chridi> ?
06:54:36 <dreixel> rostayob: I think the patches get sent to a list
06:54:57 <parcs`> :t (enumFromThen <*> pred)
06:54:58 <lambdabot> forall a. (Enum a) => a -> [a]
06:55:05 <parcs`> > (enumFromThen <*> pred) 5
06:55:06 <lambdabot>   [5,4,3,2,1,0,-1,-2,-3,-4,-5,-6,-7,-8,-9,-10,-11,-12,-13,-14,-15,-16,-17,-18...
06:55:51 <erus`> iterate . pred wins i think
06:56:14 <rostayob> dreixel: yep... but I can't subscribe to that list and my message doesn't show up in the archives
06:56:19 <rostayob> so I emailed Koen
07:12:04 <roconnor> @quote stack-calculator
07:12:04 <lambdabot> stack-calculator says: let start f = f (); push s a f = f (a,s); add (a,(b,s)) f = f (a+b,s); end (a,_) = a in start push 2 push 3 add end
07:13:34 <roconnor> >  let start f = f (); push s a f = f (a,s); add (a,(b,s)) f = f (a+b,s); end (a,_) = a in start push 2 push 3 add end
07:13:35 <lambdabot>   5
07:29:41 <erus`> @hoogle a -> [a] -> [Int]
07:29:42 <lambdabot> Data.List elemIndices :: Eq a => a -> [a] -> [Int]
07:29:42 <lambdabot> Data.List intersperse :: a -> [a] -> [a]
07:29:42 <lambdabot> Data.List insertBy :: (a -> a -> Ordering) -> a -> [a] -> [a]
07:30:41 <mkramer> WOW
07:30:43 <mkramer> AWESOME!
07:30:48 <mkramer> You can search for type signatures like that
07:31:19 <mkramer> @hoogle (a -> b) -> m [a] -> b
07:31:19 <lambdabot> Prelude map :: (a -> b) -> [a] -> [b]
07:31:20 <lambdabot> Data.List map :: (a -> b) -> [a] -> [b]
07:31:20 <lambdabot> Prelude all :: (a -> Bool) -> [a] -> Bool
07:31:38 <mkramer> no no, that's no what I need...
07:31:44 <merijn> mkramer: Yes, there's also a webinterface that links to the docs
07:31:55 <merijn> mkramer: http://www.haskell.org/hoogle/
07:32:26 <erus`> @hoogle (a -> Maybe b) -> [a] -> [b]
07:32:26 <lambdabot> Data.Maybe mapMaybe :: (a -> Maybe b) -> [a] -> [b]
07:32:27 <lambdabot> Prelude mapM :: Monad m => (a -> m b) -> [a] -> m [b]
07:32:27 <lambdabot> Control.Monad mapM :: Monad m => (a -> m b) -> [a] -> m [b]
07:32:27 <mkramer> but it didn't find what I'm looking for - map doesn't remove monad aids
07:32:44 <merijn> mkramer: I assume you have an IO [a], then?
07:32:51 <mkramer> yes
07:33:01 <merijn> The answer is: That function does not and cannot exist
07:33:36 <mkramer> :t liftM
07:33:37 <lambdabot> forall a1 r (m :: * -> *). (Monad m) => (a1 -> r) -> m a1 -> m r
07:33:56 <rostayob> mkramer: you can't "get out" of IO. Otherwise haskell wouldn't be pure.
07:34:02 <merijn> You probably want either "fmap map" or something like "do {x <- myList; map f x}"
07:34:24 <rostayob> mkramer: if you had a function 'danger :: IO a -> a', you could easily create non referential transparent functions
07:34:37 <rostayob> mkramer: (actually you do have such a function but you should almost never use it!)
07:34:46 <merijn> s/almost never/never
07:35:04 <Boxo> is there a version of writeFile that would write "he" instead of nothing if I did: writeFile "out.txt" ('h':'e':undefined) ?
07:35:09 <mkramer> I do get the purity/non purity distinction (at some level)
07:35:41 <merijn> mkramer: Do you have a concrete example of what you want to do?
07:35:45 <mkramer> It's the syntax & constructs that allow me to work with monadic actions which I'm having trouble grokking
07:35:59 <mkramer> Well, this is related to something I was asking earlier
07:36:11 <mkramer> in main, I have entries :: m [ Float ]
07:36:32 <mkramer> I want to enter in an action that takes me from m [ Float ] to Float
07:36:45 <mkramer> someone suggested this and it worked: (liftM sum) entries
07:37:01 <mkramer> but I don't understand the type of it
07:37:10 <merijn> mkramer: Why do you want to go from "IO [Float] -> Float"?
07:37:17 <merijn> Why do you think that is necessary?
07:37:39 <Boxo> liftM sum will take you to (m Float), not Float
07:37:51 <rwbarton> @type liftM
07:37:52 <lambdabot> forall a1 r (m :: * -> *). (Monad m) => (a1 -> r) -> m a1 -> m r
07:37:53 <mkramer> Oh.  Gotcha
07:38:22 <merijn> mkramer: You can just write "[Float] -> Float" and then put that inside of IO with fmap/liftM, rather than trying to get IO [Float] out of IO
07:39:00 <merijn> Putting things into IO is easy. Most times the solution to "I want to get something out" is really "write what you want without IO, then put it inside"
07:39:24 <Boxo> going to Float is impossible for a general monad, you can't take anything out of a monad
07:39:38 <rostayob> merijn: that's not true
07:39:50 <rostayob> merijn: you use libraries that use unsafePerformIO all the time.
07:40:08 <rostayob> (regarding the "you should never use unsafePerformIO")
07:40:31 <merijn> rostayob: People that *need* it know enough to understand when you break the rules
07:40:32 <byorgey> Boxo: no, I think you'd have to make your own which writes each Char individually while catching exceptions
07:40:37 <Boxo> also, how are you supposed to manipulate the results of IO actions in ghci without doing unsafePerformIO first?
07:40:42 <mkramer> why is the type using type variables "a1" and "r" instead of "a" and "b"?
07:40:55 <Boxo> byorgey: ok :/
07:41:10 <rostayob> mkramer: yes, but saying that you never need it is false.
07:41:15 <rostayob> sorry, merijn
07:41:20 <merijn> rostayob: The same thing goes for (in imperative languages, obviously) "don't use threads" rather than "use threads sparingly in a subtle set of conditions"
07:41:36 <mkramer> I have no desire to breka referential transparency
07:41:43 <mkramer> I can do that enough in the half dozen languages I already know
07:41:47 <byorgey> Boxo: you can write   x <- someIOAction  at the ghci prompt, which binds x to the result
07:41:50 <merijn> rostayob: In my experience telling newcomers "you sometimes need something" results in them saying "well, this must be one of those times"
07:42:05 <byorgey> Boxo: think of the ghci prompt as existing within a do-block for the IO monad
07:42:13 <merijn> rostayob: By the time they know enough to break rules, they should know that the rule might be an exaggeration
07:42:15 <rostayob> merijn: well explaining why it's bad is much better than saying "pretend that doesn't exist"
07:42:47 <rostayob> expecially in this case, since it's really easy to understand why it's terribly bad if you know what purity is
07:42:51 <mkramer> But really guys, why are the type variables named strangely sometimes? What information can I infer from a type variable named t0 as opposed to one named a1 as opposed to one named r?
07:43:03 <merijn> mkramer: Internal details of the type checker
07:43:21 <byorgey> mkramer: (re: a1 and r) who knows.  The actual letters used don't matter.  GHC tries to keep names the same when it can, but sometimes it has to make up new names
07:43:22 <parcs`> Boxo: first turn ('h':'e':undefined) into ('h':'e':[]) by using something like the 'spoon' library: http://hackage.haskell.org/packages/archive/spoon/0.3/doc/html/Control-Spoon.html
07:43:24 <rostayob> mkramer: those names are automatically generated as you can imagine.
07:43:31 <merijn> mkramer: There's probably some info you can infer from it, but in my experience it's not that important
07:43:41 <byorgey> parcs`: ah, good idea
07:43:43 <rostayob> mkramer: so they deal with generating fresh names in various ways
07:43:54 <tromp__> @pl \i -> (i.&.pred i`mod`3,succ(i.|.pred i)`mod`3)
07:43:54 <lambdabot> ap ((,) . (`mod` 3) . ap (.&.) pred) ((`mod` 3) . succ . ap (.|.) pred)
07:45:11 <merijn> On slightly related note, the more I understand the IO monad, the more it inspires awe with its brilliant elegance...
07:46:17 <mkramer> thanks guys, good to know
07:51:50 <mkramer> does it make any sense to think of the IO monad like a thunk? (In that it is a deferred action which may be performed a later time?)
07:52:37 <tromp__> byorgey, this hanoi works for all n:
07:52:41 <tromp__> > [(i.&.pred i`mod`3,succ(i.|.pred i)`mod`3)|i<-[1..]]
07:52:42 <lambdabot>   [(0,2),(0,1),(2,1),(0,2),(1,0),(1,2),(0,2),(0,1),(2,1),(2,0),(1,0),(2,1),(0...
07:53:01 <tromp__> the first 2^n-1 moves solved hanoi for n disks
07:56:52 <Cale> mkramer: Well, a thunk isn't an *action*, in that it's just a runtime representation of an expression which is going to evaluate to a value with no other effect
07:56:56 <Cale> But other than that, sure
07:57:24 <Cale> An IO action is value representing something to be done later.
07:57:28 <Cale> (potentially)
07:57:50 <rwbarton> unlike a thunk, it may be performed more than once
07:57:56 <dzhus> upgradin ur haskell @ rebuildin all ur packageez
07:58:02 <mkramer> If I think of Haskell code as essentially building up a list of thunks (that are impure) and then executing them in sequence, that's a way in for me
08:04:18 <erkin> How can I filter a list? Like removing floats but keeping integers?
08:05:41 <parcs`> how can you have a list of Floats and Integers
08:06:10 <erkin> I have no idea.
08:06:21 <mkramer> :t filter
08:06:22 <lambdabot> forall a. (a -> Bool) -> [a] -> [a]
08:06:39 <mkramer> your example of a filtering function was unfortunate but that's how you do it
08:06:52 <erkin> Hmm..
08:06:55 <erkin> Well, thanks anyway.
08:07:08 <mkramer> what do you mean, "anyway"? :)
08:07:28 <parcs`> erkin: one way is to give the list a type [Either Float Integer]. then you can extract all the Floats or Integer by using the lefts and rights functions
08:07:30 <parcs`> :t lefts
08:07:31 <lambdabot> forall a b. [Either a b] -> [a]
08:07:34 <parcs`> :t rights
08:07:35 <lambdabot> forall a b. [Either a b] -> [b]
08:07:44 <erkin> Oooh.
08:07:50 <erkin> That looks interesting.
08:07:52 <Cale> mkramer: You should think of it as two processes: execution (carrying out the steps described by IO action values), and evaluation (turning expressions into values)
08:08:36 <Cale> mkramer: These are interleaved with each other... main is evaluated in order to determine (the first part of) which action it is, and then that is executed
08:09:21 <Cale> because the right hand side of a >>= is a function which is applied to the result of the action on the left, the resulting function application then needs to be evaluated before more execution can happen.
08:11:40 <mkramer> Cale: that actually helps! thanks
08:13:11 <Cale> mkramer: I actually don't like using the word 'thunk' because it's a bit low-level-implementation-detail-y. You can just think of expressions as existing in some form at runtime.
08:13:15 <quicksilver> fuyrther more, things which are *never* needed, will never get evaluated
08:13:47 <Cale> (same goes for "closure" -- you should only ever talk about closures if you're discussing the particular implementation of a language, and not its features)
08:13:53 <quicksilver> (or they might be needed in some runs of the program, but not this one, as the program is conditional on external factors)
08:14:55 <mkramer> thunks don't necessarily get evaulated either...which is often the point of them
08:15:37 <mkramer> But ok, I will just make some more conceptual space for actions here
08:15:46 <mkramer> just another abstract data type
08:17:00 <mkramer> and I can think of actions as pure, but their execution is not
08:17:10 <mkramer> right?
08:17:28 <mkramer> Wait - no
08:18:43 <rwbarton> I don't really want to try to assign a meaning to "pure" in that sentence
08:18:58 <rwbarton> but an action is just a particular kind of value. Evaluating that value never has side-effects
08:19:13 <rwbarton> Executing the action causes effects to occur
08:19:56 <quicksilver> all evaluation is pure, meaning that is never has side-effects, which means it never matters if you do it twice.
08:20:15 <quicksilver> (that's not the only thing it means but it's a handy thing to remember)
08:20:15 <rwbarton> I also like to say that execution doesn't have side effects, either. It just has *effects*.
08:20:22 <quicksilver> agreed
08:20:35 <mkramer> ok. So I can conceive of functions like m a -> m b -> c  -> d which are pure
08:20:39 <quicksilver> the important thing about avaluation is that you can defer it - do it later
08:20:44 <quicksilver> you can do it earlier
08:20:45 <mkramer> but they'd never be able to do anything useful with m a or m b
08:20:55 <quicksilver> you can do it once, discard the result (replace it with the thunk) and do it again
08:21:00 <quicksilver> and none of these change the meaning of your program
08:21:09 <quicksilver> (although they might make it faster or slower)
08:21:19 <quicksilver> this gives the compiler lots of freedom
08:21:27 <mkramer> the only sensible return type of a pure function that takes an action is another action
08:21:46 <rwbarton> Do you mean IO a -> IO b -> c -> d?
08:21:47 <quicksilver> or a complex data type which embeds an action inside it somewhere, mkramer
08:22:07 <quicksilver> or of course it might ignore/throw away its argument, but presumably that's what you meant by "sensible"
08:22:22 <mkramer> ah, right
08:22:43 <mkramer> a complex data type can be holding an action without advertising that fact in the type signature?
08:23:00 <quicksilver> yes
08:23:13 <mkramer> m a -> b -> Complex
08:23:14 <mkramer> got it
08:23:18 <quicksilver> data Printer = { value :: Integer, printFunction :: IO () }
08:24:20 <CodeWeaverX> Interesting.  I have to learn various advantages in treating actions as values like that.
08:24:57 <mkramer> and it's normal to do this? Hide actions inside of more complex data types?
08:25:14 <koeien> quite normal, why not?
08:25:20 <koeien> darcs does it, for example
08:32:15 <mux> https://bitbucket.org/mumux/generic-deepseq -- thoughts welcome
08:32:37 * hackagebot unification-fd 0.6.0 - Simple generic unification algorithms.  http://hackage.haskell.org/package/unification-fd-0.6.0 (WrenThornton)
08:32:39 <mux> I still need to tidy a few things up, such as adding a proper description to the cabal file, but I intend to upload it to hackage soon afterwards
08:36:49 <hpaste> anonymous pasted “test” at http://hpaste.org/63870
08:38:21 <erkin> I pasted that. Uhh...
08:38:52 <erkin> I can't seem to find the problem. I want to find the numbers between 1 and 1000 that are divided by 3 or 5.
08:39:39 <monochrom> but what does + and - mean?
08:39:57 <erkin> Add and subtract.
08:40:25 <erkin> You think it interprets it as a negative number?
08:40:36 <monochrom> no, I misread
08:40:41 <erkin> Ah, okay.
08:40:51 <mauke> what's the problem?
08:40:55 <monochrom> and what does sum mean?
08:41:17 <erkin> Σ
08:41:39 <monochrom> yes, and does it fit "find the numbers between 1 and 1000 that are divided by 3 or 5"?
08:41:51 <erkin> Find the sum of numbers.
08:41:53 <erkin> Sorry.
08:42:18 <mauke> what's the problem?
08:42:24 <Peterbing> Ooh, some FizzBuzz action...
08:42:34 <erkin> The output seems to be incorrect.
08:42:39 <mauke> incorrect how?
08:42:49 <erkin> The problem giver does not accept it as correct.
08:42:57 <mauke> what's a problem giver?
08:43:16 <erkin> The problem is: "If we list all the natural numbers below 10 that are multiples of 3 or 5, we get 3, 5, 6 and 9. The sum of these multiples is 23. Find the sum of all the multiples of 3 or 5 below 1000."
08:43:21 <monochrom> I am unconvienced that it is wrong, too
08:43:32 <mauke> erkin: where is this problem from?
08:43:33 <erkin> Maybe I misunderstood the problem.
08:43:39 <erkin> Project Euler.
08:43:39 <ion> “below 1000” might be significant.
08:43:45 <mauke> erkin: which one?
08:43:54 <erkin> Very first one. ._.
08:44:01 * erkin failed at the very first problem
08:44:09 <mauke> ion is right
08:44:22 <erkin> Hmm, so I should leave out 1000?
08:44:29 <ion> > 1000 < 1000
08:44:30 <lambdabot>   False
08:44:33 <monochrom> yeah, "below 10" is 3, 5, 6, 9, but no 10
08:44:34 <mux>  /query lambdabot
08:44:36 <mux> woops :)
08:44:47 <ion> Are you talking to her behind our backs?
08:44:56 <monochrom> but generally, "below x" is ambiguous. always ask for clarification.
08:45:01 <erkin> ion: Yes, that seems to be correct.
08:45:07 <erkin> Thank you.
08:45:13 <mauke> > sum $ filter (\n -> n `mod` 3 == 0 || n `mod` 5 == 0) [1 .. 999]
08:45:14 <lambdabot>   233168
08:45:58 <rwbarton> You might take a moment to reflect on how answerable your original question "I can't seem to find the problem with http://hpaste.org/63870" was.
08:46:59 <erkin> rwbarton: But I included the details in the very same sentence.
08:47:13 <mkramer> so that's the point of lambas
08:47:16 <mauke> erkin: no, you didn't
08:47:25 <erkin> <erkin> I can't seem to find the problem. I want to find the numbers between 1 and 1000 that are divided by 3 or 5.
08:47:37 <erkin> The second sentence was explaining the problem.
08:47:40 <mauke> erkin: no, it wasn't
08:47:43 <mauke> erkin: I had to ask you twice
08:47:47 <erkin> (even if I forgot to include the word "sum")
08:47:54 <mauke> erkin: three times, actually
08:47:58 <rwbarton> erkin: There was no problem.
08:48:29 <ion> “between 1 and 1000” is much more ambiguous than “below 1000”
08:48:30 <erkin> Sigh. Okay, I will not use vaguely defined words anymore and even if I do I will define them before someone sees me.
08:48:48 <rwbarton> In general explaining up front why you think there is a problem will make it a lot easier for people to try to help fix the problem
08:48:58 <rwbarton> rather than a vague "there is a problem".
08:48:58 <mkramer> I think mauke is trying to say that you posted a question you wanted answered (what you're calling the 'problem') and a solution that didn't work for some reason. (And that reason is what he's calling the 'problem')
08:49:04 <erkin> I understand what exactly you are talking about.
08:49:14 <mauke> erkin: start with "I'm trying to solve http://projecteuler.net/problem=1 and my code is http://hpaste.org/63870"
08:49:31 <mauke> "but my solution is rejected by the site"
08:49:35 <erkin> I mentioned a problem but forgot to define what the problem exactly is and instead explained what I wanted to do straight up.
08:51:29 <monochrom> "between 1 and 1000" is ambiguous. however, if the code says x<-[1..1000], it is taken as disambiguation rather than source of errors
08:51:51 <monochrom> after all, how do we know that the author is not to be trusted?
08:52:32 <mauke> "I can't seem to find the problem with X" includes at least the following possibilities:
08:52:48 <mauke> 1) it doesnt compile because the compiler crashes
08:52:57 <mauke> 1) it doesnt compile because the compiler gives an error
08:53:00 <mauke> er. 2)
08:53:11 <mauke> 3) it crashes at runtime
08:53:16 <o1iver> Hey. What would be a good data structure to store elements that will be some default value 80% of the time and must be index by three Ints? Something like a 3D sparse matrix
08:53:20 <mauke> 4) it hangs at runtime
08:53:22 <tgeeky> mauke: no, no, keep using 1) ... markdown syntax will fix it later
08:53:33 <mauke> 5) it computes a result but I think it's wrong because X
08:53:34 <monochrom> hahaha
08:53:43 <erkin> If my problems included these, I would include the error.
08:53:59 <qpu> damn, being humbled sucks. that leonidas post on concatenative programming in haskell subsumes months of my own studying and hacking :[
08:54:03 <nand`> case event of 1 -> bug report; 2 -> documentation; 3 -> ghci; 4 -> ghci; 5 -> unit testing
08:54:05 <erkin> And I'd assume the problem is caused by something else, seeing that the user has provided no errors.
08:54:09 <mauke> as it turns out, the actual meaning was 6) it computes a result and I think it's correct but some other party says it's wrong
08:54:44 <Cale> qpu: also, it's a standard trick which has been around for a long time. I would be somewhat surprised if he actually invented it entirely independently.
08:54:44 <erkin> Your point is "It was not a problem."?
08:55:24 <mauke> no, my point is your problem description sucked because it was extremely vague
08:55:35 <Cale> (I'm assuming you're referring to https://github.com/leonidas/codeblog/blob/master/2012/2012-02-17-concatenative-haskell.md)
08:55:50 <monochrom> if I write in markdown syntax "3) ... 1) ... 4) ... 1) ... 5) ... 9) ...", will markdown fix it too? :)
08:55:55 <mauke> erkin: this isn't a personal attack on you, btw
08:56:16 <quintessence> o1iver: I'd use Map (Int, Int, Int) a and findWithDefault
08:56:21 <erkin> Honestly, it was written in a hurry because I was not aware that the bot posted my paste here and I was just getting ready to paste here.
08:56:36 <mauke> I'm trying to dump what my brain goes through when I see a problem description on IRC
08:56:44 <erkin> I do realise you are not assaulting me. :)
08:56:54 <erkin> I think you just dislike vagueness a lot.
08:57:21 <o1iver> quintessence: that is also what I am currently thinking about. How is the performance of Map? These _structures_ may contain > 100k values...
08:57:25 <monochrom> well, turns out it's crucial, isn't it?
08:57:42 <monochrom> clean-break difference between "accept" and "reject"
08:57:42 <mauke> erkin: yes
08:57:51 <erkin> Heh. You'd love Lojban.
08:58:06 <Adrian1> hello i would like to code this in haskell only with predefined functions that can be found in the library, can any1 suggest an approach to this problem please :) ? Count all syllables in each word. To make this simple, use the following rules:   Each group of adjacent vowels (a, e, i, o, u, y) counts as one syllable (for exam-  ple, the “ea” in “real” contributes one syllable, but the “e . . . a” in “regal”   count a
08:58:17 <qpu> Cale: yeah. you're probably right... i haven't spent enough time with haskell. it's mostly obvious after reading it, but now i feel dumb
08:58:19 <monochrom> I'm really fine with ambiguity and missing information when they don't matter.
08:58:32 <hpaste> mkramer pasted “confused by an inferred type again” at http://hpaste.org/63871
08:58:47 <tgeeky> Adrian1: if by 'the library', you mean "base" or standard GHC, you *can* do it.
08:58:53 <rwbarton> it's just that knowing which of 1) through 6) is the problem is really valuable information to people trying to help.
08:58:54 <Cale> qpu: I don't think it's obvious, but it's been around for a long time.
08:59:06 <rwbarton> You already knew it was 6). Why not include that information?
08:59:32 <monochrom> my experience with #haskell is that 99% of the time ambiguity and missing information really matter.
08:59:32 <Cale> qpu: you can do it in CPS, and make it look even more forthy
08:59:45 <erkin> rwbarton: I was not aware that there was a certain standard on problem reporting descriptions.
08:59:47 <mauke> Adrian1: homework?
08:59:59 <monochrom> and this example has just bumped it from 99% to 99.1%.
09:00:03 <Cale> qpu: (but it's more awkward to work with, and the type errors become absurd)
09:00:03 <erkin> So, I didn't know I was supposed to say  "Hi guys, I've got a 6!"
09:00:18 <qpu> Cale: embedding a concatenative language in Haskell also takes care of a *lot* of legwork (eg, type checking) that i had been toiling on
09:00:34 <mauke> mkramer: String = [Char]
09:00:43 <mauke> mkramer: that's where the [ ] comes from
09:00:58 <mekeor> mkramer: string was defined as follows: "type String = [Char]".
09:01:01 <Cale> qpu: Yeah, it shows pretty easily how Hindley-Milner-like type systems can be leveraged for concatenative languages.
09:01:28 <Adrian1> mauke yes its homework and i do not know where to start.. i was thinking about foldl SumSylFunct 0 words(x) but i would like a little bit of guidance
09:01:34 <rwbarton> erkin: Well, now you're just being deliberately obtuse
09:01:44 <rwbarton> I'm just trying to help for future questions.
09:01:52 <mkramer> but why is the type of idx inferred to be String?
09:02:07 <mauke> Adrian1: I'd probably start with groupBy or partition
09:02:11 <mauke> mkramer: it isn't
09:02:14 <Adrian1> hmmm
09:02:36 <mkramer> what is inferred to be a String here?
09:02:40 <mauke> mkramer: nothing
09:02:40 <erkin> rwbarton: Pardon my arrogant passive aggression. :(
09:02:53 <mauke> mkramer: String isn't inferred. String is from the explicit type signature you gave
09:02:57 <qpu> Cale: one problem i've not solved is how a term like "dup compose" can be typed. for instance "[+] dup compose" should have s.:int.:int.:int -> s.:int, but "[id] dup compose" is s -> s. what's the type of "dup compose"?
09:03:09 <mauke> mkramer: getMeal :: Restaurant -> String; getMeal r = do { ... }
09:03:15 * tgeeky suddenly wonders if (passive, aggressive) are commutative. Is 'aggressive passiveness' the same as 'passive aggression'?
09:03:18 <mkramer> oh...right
09:03:21 <mauke> mkramer: from that the compiler infers that this 'do' block is in the list monad
09:03:32 <mauke> mkramer: so all '<-' statements must be using [ ] somehow
09:04:22 <Adrian1> could someone give me a groupby example
09:04:47 <qpu> Cale: s.:(a -> a) -> s.:(a -> a) is not general enough, because you can't apply it to "+"
09:05:15 <Cale> qpu: um, what's the type of compose?
09:05:20 <ion> > groupBy (==) "foo bar"
09:05:21 <lambdabot>   ["f","oo"," ","b","a","r"]
09:05:38 <Adrian1> oh i c
09:05:49 <Cale> qpu: Is it meant to pop two functions off the stack and compose them?
09:05:54 <qpu> Cale: yeah
09:05:58 <Cale> qpu: (+) . (+) doesn't make sense
09:06:13 <Cale> well, but add . add might ;)
09:06:16 <Adrian1> groupBy (==) "foo bor"
09:06:17 <mux> :t (.!)
09:06:18 <lambdabot> Not in scope: `.!'
09:06:19 <qpu> Cale: no, but "3 >>> 4 >>> 5 >>> (+) >>> (+)" does
09:06:26 <Cale> right
09:06:32 <Adrian1> ohh the bot is no working for everyone :) sry
09:06:36 <ion> > ((+) . (+)) 5 id 6
09:06:36 <mauke> Adrian1: yes, it is
09:06:37 <lambdabot>   17
09:06:39 <Cale> Well, not (+), but add, the stack operation
09:06:46 <qpu> Cale: yeah
09:06:55 <Adrian1> groupBy (==) "foo bar"
09:07:37 <qpu> Cale: sorry for the mixed terminology, the blog post does a qualified prelude import and defines its own (+) as "add"
09:07:45 <fryguybob> Adrian1: start with >
09:07:47 <Cale> oh
09:07:49 <Cale> So compose :: (s :. (b -> c) :. (a -> b)) -> (s :. (a -> c)), yeah?
09:08:25 <Adrian1> >groupBy (==) "foo bor"
09:08:47 * fryguybob sighs
09:08:52 <Cale> compose = liftS2 (.)
09:09:03 <nand`> > groupBy (/=) "foo bar"
09:09:04 <lambdabot>   ["foo bar"]
09:09:22 <Adrian1> thank you
09:09:41 <nand`> Adrian1: that wasn't an example directed at you, that was me wondering what would happen
09:09:45 <qpu> Cale: swap the arg order.... i think compose = (>>>). but the problem isn't typing compose, it's typing the term "dup compose".
09:09:50 <Adrian1> > groupBy (==) "aa bc ad")
09:09:51 <lambdabot>   <no location info>: parse error on input `)'
09:09:53 <nand`> @src groupBy
09:09:53 <lambdabot> groupBy _  []       =  []
09:09:54 <lambdabot> groupBy eq (x:xs)   =  (x:ys) : groupBy eq zs
09:09:54 <lambdabot>     where (ys,zs) = span (eq x) xs
09:09:54 <Adrian1> > groupBy (==) "aa bc ad"
09:09:55 <lambdabot>   ["aa"," ","b","c"," ","a","d"]
09:09:59 <qpu> Cale: i suppose i should check what type is inferred with this guy's definitions
09:10:55 <Cale> ghci> :t push add >>> push add >>> compose
09:10:55 <Cale> push add >>> push add >>> compose
09:10:55 <Cale>   :: P.Num n => a -> a :. ((((s :. n) :. n) :. n) -> s :. n)
09:11:08 <Cale> hmm
09:11:26 <rostayob> It would be nice to have a facility that tells you the type of the things in scope in a certain expressions, a-la Agda
09:11:32 <rostayob> does something like that exist?
09:11:38 <Cale> errr
09:11:58 <qpu> Cale: this is the problem: twice = dup >>> (liftS2 (.)). the inferred type is (s :. (c -> c)) -> s :. (c -> c)
09:12:10 <Cale> oh, liftS2 is different from what I wanted it to be
09:12:31 <qpu> Cale: liftS2 works, just args are reversed (not significant here)
09:12:34 <hpc> :t map ?f -- rostayob
09:12:35 <lambdabot> forall a b. (?f::a -> b) => [a] -> [b]
09:12:39 <dschoepe> rostayob: If the value's type is Typeable, you can get a TypeRep with this: http://www.haskell.org/ghc/docs/latest/html/libraries/base-4.5.0.0/Data-Typeable.html
09:13:05 <Palmik> Hmm, does anyone know if GHC 7.4.1 works with libc version 2.12?
09:13:14 <qpu> Cale: so the problem is q ((+)) >>> twice won't type check, because the add/+ term isn't c -> c
09:13:15 <dschoepe> rostayob: Or did you mean for writing a program interactively?
09:13:15 <hpc> i assume you meant "infer the type of a hole"
09:13:38 <Cale> qpu: Well, the raw (+) is a function which takes a number and produces another function
09:13:43 <Cale> (the Prelude one)
09:13:53 <rostayob> dschoepe: writing programs interactively
09:13:54 <Adrian1> countSyl x = groupBy (==) x -----> Not in scope: `groupBy' ??
09:14:07 <rostayob> hpc: no i want to display the types of the variables in scope
09:14:11 <rostayob> the types inferred by GHC
09:14:19 <Cale> qpu: there's a polymorphism issue there, yes
09:14:21 <nand`> Adrian1: import Data.List (groupBy)
09:14:44 <Adrian1> thanks it works :D
09:14:54 <qpu> Cale: yeah, with the concatenative version of + it won't type check. any ideas on how to express that type?
09:15:17 <qpu> Cale: i've looked at MLF ... it might work but i don't grok it well enough
09:15:23 <qpu> Cale: same with intersection types
09:16:00 <Cale> That seems too fancy... I think there's a way to do this with good ol' higher rank types :)
09:16:52 <qpu> Cale: my thoughts at the time documented here, https://github.com/kputnam/bee/issues/3 -- this might be misinformed
09:18:11 <Cale> oh, no wait
09:18:25 <Cale> there's no problem, I was just reading this type incorrectly because of fixity :P
09:18:38 <Cale> q add >>> q add >>> liftS2 (.) :: P.Num n => a -> (a :. ((((s :. n) :. n) :. n) -> s :. n))
09:18:47 <Cale> the a is a stack type
09:19:13 <qpu> Cale: that's cheating. define a higher-order combinator "twice" and try q add >>> twice
09:19:57 <qpu> Cale: it infers c -> c, which is wrong... isn't it?
09:20:04 <Cale> what's the type of twice?
09:20:15 <Cale> (what should it be?)
09:20:38 <qpu> Cale: i'm not sure how to express it. the definition is twice = dup >>> (liftS2 (.))
09:20:50 <hpaste> mkramer pasted “One more type error before i get on the plane” at http://hpaste.org/63872
09:21:03 <Cale> qpu: Well, in order to compose a function with itself, it had better have type (c -> c)
09:21:06 <Cale> for some type c
09:21:19 <qpu> Cale: not true in a concatenative language
09:21:30 <qpu> Cale: consider this...
09:22:22 <RainbowFactory> Guys do you think it's true that if you can't explain something concisely you don't understand it enough?
09:23:11 <Cale> RainbowFactory: Information theory shows that to be incorrect.
09:23:14 <Adrian1> how would I group a string that has "ae" in it or any other vowel ..basically i want to group the vowels that are adjacent in a string
09:23:33 <Cale> RainbowFactory: But it's somewhat true :)
09:23:49 <Cale> RainbowFactory: In mathematics, if you can't prove something, you don't really understand it.
09:24:59 <qpu> Cale: push 3 >>> push 4 >>> push 5 >>> add >>> add should be equivalent to push 3 >>> push 4 >>> push 5 >>> q add >>> twice >>> apply
09:25:08 <rata_> Adrian1: filter (\x -> length x > 1) . groups I think
09:25:18 <rata_> Adrian1: no
09:25:25 <rata_> Adrian1: groupBy
09:25:40 <rata_> and define a function isVowel
09:26:00 <mkramer> Sorry - was dced
09:26:01 <o1iver> how can I make any instance of a class an instance of another class (ie. make a class an instance of a class)?
09:26:09 <mkramer> did anyone have anything to say about that paste?
09:26:36 <rata_> mkramer: afaik no
09:26:50 <rata_> *afais
09:26:55 <Cale> qpu: Okay, I think twice just needs to be a little less polymorphic (and a little more polymorphic in a different direction :)
09:27:11 <qpu> Cale: i don't wanna!
09:27:12 <tomodo> I found on reddit
09:27:13 <tomodo> "So I've been hearing more and more about hascol, would learning it be a good idea?"
09:27:26 <qpu> Cale: but yes, for Haskell to type it correctly you're right
09:27:40 <Cale> qpu: we need to make sure that the function it's eating operates on a stack
09:27:49 <Cale> qpu: so that we can forall the stack type
09:27:58 <mauke> mkramer: so it can apply snd to it
09:28:08 <mauke> mkramer: you can't snd a list
09:28:40 <Cale> qpu: and insist that the function be polymorphic on the stack
09:28:54 <mkramer> I'm trying to send snd into the list with fmap, though
09:29:01 <edwardk> rwbarton: got more funny polykinded stuff working
09:29:17 <rwbarton> neat
09:29:19 <rwbarton> like what?
09:29:21 <edwardk> rwbarton: type AsArgKind a f = Const a (Proxy (f a))
09:29:37 <edwardk> type AsResultKind a f = Const a (forall r. Proxy ('Pair (f r) a))
09:29:37 <rwbarton> mhm
09:29:38 <qpu> Cale: i'm not sure i understand, but i think you're describing rank-1 polymorphism
09:29:46 <Cale> yes
09:29:54 <edwardk> still can't make the category for all Arr though
09:30:11 <ion> Yarr
09:30:11 <rata_> tomodo: of course it's a good idea
09:30:15 <edwardk> mainly because there isn't a good way to tell Trans that it can induct on the kind to find simpler categories =/
09:30:26 <edwardk> if you use f a -> g a inside Trans it of course works, but blech
09:30:26 <mauke> mkramer: entries isn't a list
09:30:34 <tomodo> hascol
09:30:41 <qpu> Cale: then we agree, twice can't be given a most general type. but i think there *is* a most general type in MLF
09:30:42 <ion> habol
09:30:48 <mkramer> fmap snd [(1,2), (3,4)] works
09:30:55 <tomodo> should I learn see slup slup first?
09:30:57 <fryguybob> > let isVowel = (`elem` "aeiou") in groupBy (curry ((uncurry (&&) . (isVowel *** isVowel)))) "haello woorld"
09:30:58 <lambdabot>   ["h","ae","l","l","o"," ","w","oo","r","l","d"]
09:31:02 <mkramer> this problem must be that entries is not only a list, but also an IO
09:31:04 <edwardk> i'm hoping to carry the AsArgKind etc trick farther to get a form of Arr which takes a parameter which is the list of argument kinds
09:31:08 <mauke> mkramer: it can't be both
09:31:12 <qpu> Cale: i mean, it can't be given a most general type using rank-1 polymorphism
09:31:20 <mkramer> so what is entries then?
09:31:22 <edwardk> now that i have a limited form of kind agreement
09:31:35 <mauke> mkramer: "Actual type: IO [(Restaurant, Float)]"
09:31:52 <mauke> that's IO foo, not [foo]
09:32:01 <mkramer> do you understand what I'm trying to do? I'm trying to get IO [Float] out of IO [(Restaurant, Float)]
09:32:11 <mauke> mkramer: yes
09:32:13 <mkramer> that's IO [foo], right? no IO foo
09:32:25 <mauke> mkramer: it's IO foo with foo = [...]
09:32:27 <Cale> mkramer: fmap snd
09:32:31 <mauke> mkramer: but that's irrelevant
09:32:40 <mauke> Cale: wrong
09:32:45 <rwbarton> edwardk: I think I see, for Trans defined in terms of Arr there's no way to write the context for the instance...?
09:32:46 <qpu> Cale: unfortunately that's a bit over my head. the other possibility is intersection types, twice :: s:.(a -> a' and a' -> b) -> s:.(a -> b) or something, but the relationship between a and b isn't being expressed. i think MLF deals with that
09:32:56 <mkramer> Cale: that's what I'm trying in this paste
09:33:02 <Cale> mauke: I said that only in response to "I'm trying to get IO [Float] out of IO [(Restaurant, Float)]"
09:33:12 <mauke> Cale: yes, and that's wrong
09:33:15 <Cale> I've ignored all the other context
09:33:20 <mauke> Cale: still wrong
09:33:20 <hpc> Cale: (.:) snd
09:33:23 <Cale> ?
09:33:27 <hpc> you have to fmap two deep
09:33:31 <mauke> Cale: fmap (map snd)
09:33:31 <hpc> into the IO, then into the list
09:33:32 <Cale> oh, derp
09:33:55 <mauke> however, there's no reason for entries to be an IO something
09:33:55 <Cale> fmap (map snd)
09:34:42 <edwardk> rwbarton: yeah. i tried making some horrible contexts for the inside of Trans which said something like there exists  k such that k (f a) (g a) ~ Arr (f a) (g a), and that there is a Category for k
09:34:47 <mkramer> oh, because it's in a do block you mean?
09:34:49 <edwardk> but it wasn't having it ;)
09:34:54 <mkramer> I could have just extracted it?
09:34:57 <rwbarton> oh god
09:35:07 <mkramer> thanks by the way for fmap (map snd)
09:35:17 <edwardk> i'll get there eventually ;)
09:35:20 <mkramer> I was vaguely coming to the realization that I had to map two deep
09:35:42 <qpu> edwardk: what does ~ mean?
09:35:54 <edwardk> qpu: thats a type equality constraint
09:35:56 <rwbarton> exciting stuff, anyways, I still can't really believe it's in a real released version of GHC
09:36:11 <mauke> mkramer: yes
09:36:23 <maurer> @hoogle [a] -> [b] -> [c] -> [(a, b, c)]
09:36:24 <lambdabot> Prelude zip3 :: [a] -> [b] -> [c] -> [(a, b, c)]
09:36:24 <lambdabot> Data.List zip3 :: [a] -> [b] -> [c] -> [(a, b, c)]
09:36:28 <edwardk> (Int ~ Int) => Double -- is trivially satisfiable for instance. since Int = Int
09:36:48 <edwardk> you wind up with them when working with type families some times
09:36:48 <qpu> edwardk: ah, so there are functions on types which it's not trivial?
09:37:31 <stephenjudkins> edwardk: are you the "Edward K" who gave the "Lenses: A Function Imperative" talk?
09:37:41 <edwardk> do x <- ask; put x   -- would give you something like (MonadState m, MonadReader m, St m ~ Env m) => m ()
09:37:43 <edwardk> yep
09:37:44 <edwardk> thats me
09:37:55 <stephenjudkins> i have passed around a PDF of the slides I have to a couple friends
09:38:04 <edwardk> =)
09:38:13 <stephenjudkins> but can no longer find them anywhere online.
09:38:22 <edwardk> ah, let me check my google docs
09:38:27 <edwardk> i think i put a copy up there for folks
09:38:29 <stephenjudkins> yeah, the google doc is gone now
09:39:17 <edwardk> try https://docs.google.com/open?id=0ByK3AAy5ubqaMTQ3M2FiZTktODQyNi00OTc2LTkwNTgtNzQ2MWE0OWVlZWJk
09:39:18 <mkramer> grr...
09:39:50 <edwardk> there is video on youtube as well
09:40:13 <edwardk> http://www.youtube.com/watch?v=efv0SQNde5Q
09:41:27 <stephenjudkins> edwardk: thanks. it's a fantastic talk
09:41:29 <edwardk> qpu: the signature i gave there assumed something like monad-tf, with the mtl you of course just get type variables
09:41:49 <edwardk> i'm glad. it turned out better than expected, because i was exhausted by the time i finally got around to giving it
09:42:01 <edwardk> (just a really long day that day)
09:42:41 <qpu> edwardk: the example is beyond my understanding, but i'm reading the wiki page on type families. getting the main idea at least
09:43:12 <edwardk> qpu: basically you'd normally write (MonadState s m, MonaReader s m) => m () using mtl
09:43:36 <edwardk> but if you use type families rather than extra arguments to the type class, sometimes you need to assert that two such type functions yield the same answer
09:44:10 <edwardk> another example is of course that you can type check id as id :: (a ~ b) => a -> b
09:44:18 <tgeeky> edwardk: did you read and understand the paper on monad zippers and views?
09:44:24 <Adrian1> hello again, i would like to prepend an 'N' to the vowels that i found in an word but not the adjacent ones, as per example I would like to have the output of "MaMaMiaSenior" as "aNaNiaNeNioN" and i have this function isVowel x = filter (`elem` a) $ x where a = "aeiouy" that returns the voewls in string ..how would i be able to do this?
09:44:32 <edwardk> i don't recall reading it off hand
09:44:34 <edwardk> which one?
09:44:38 <tgeeky> lemme find the link
09:45:13 <edwardk> we're in homework season again, aren't we?
09:45:30 <mkramer> Thanks for the help, mauke & all
09:45:58 <Adrian1> yes :)
09:46:37 <Adrian1> do u guys kno if any european university teaches haskell ?
09:47:50 <edwardk> Adrian1: there are several. utrecht is probably the most visible, but also chalmers, and i'm sure it comes up at oxford with gibbons there, and strathclyde, and a few others
09:49:00 <Adrian1> thank you
09:51:52 <Adrian1> what library do i need to use for genericLength
09:52:02 <fryguybob> @hoogle genericLength
09:52:02 <lambdabot> Data.List genericLength :: Num i => [b] -> i
09:52:35 <Adrian1> thank you
09:53:05 <hpaste> deech pasted “Hlint Parse Error” at http://hpaste.org/63873
09:54:11 <deech> Hi all, I just a piece of code that causes hlint to emit a parse error. It compiles fine with GHC. Is this a hlint bug?
09:54:26 <mauke> deech: no, a ghc extension
09:54:47 <fryguybob> http://hackage.haskell.org/trac/haskell-prime/wiki/DoAndIfThenElse perhaps?
09:55:35 <deech> mauke: GHC compiles this without any flags.
09:55:46 <mauke> deech: yes
09:56:38 <deech> mauke : So is this an extension that is enabled by default?
09:56:59 <Saizan> deech: yep
09:57:36 <lispy> I think that was accepted for Haskell 2010
09:57:38 <rwbarton> it's part of haskell 2010
09:57:49 <lispy> If so, it could be that hlint was not updated to parse Haskell 2010
09:58:00 <mkramer> I wish I could have named my type constructors '$', '$$', and '$$$', is there any way to do that? It'd be really cute for the RestaurantPriciness type
09:58:12 <mauke> mkramer: no, the only uppercase symbol is :
09:58:15 <lispy> :$
09:58:24 <lispy> But not $
09:58:27 <rwbarton> and that's infix
09:59:24 <rwbarton> > let ᙚ = 1 in "test"
09:59:25 <lambdabot>   "test"
09:59:59 <rwbarton> > let Ṩ = 1 in "test"
10:00:00 <lambdabot>   Not in scope: data constructor `
10:00:27 <o1iver> Is it bad practice to have a type class that implements the same functions as some other interface in order to be able to say simply :: Something => ... and :: MutableSomething => ... instead of always having to do both?
10:00:28 <mkramer> oh well
10:01:15 <o1iver> and with both I mean (Something m1, MutableSomething m2) => ...
10:01:18 <Wooga> hello, always can't remember this thing: how function acting like read, but returning [(String,String)] or [] instead of failing named?
10:01:56 <Saizan> Wooga: reads
10:02:02 <Wooga> Saizan: thanks
10:02:30 <Saizan> o1iver: you mean having a typeclass that has both Something and MutableSomething methods?
10:02:36 <monochrom> you can create "class (Something m, MutableSomething m) => Both m"
10:03:37 <o1iver> Something and MutableSomething are the classes, but from an OOP point of view one would say that MutableSomething is a subclass of Something
10:03:52 <Wooga> Saizan: hmm, which module contains it?
10:03:59 <o1iver> monochrom: yes, sorry thats what I meant above, is that how it's usually done
10:04:13 <Saizan> @hoogle reads
10:04:13 <lambdabot> Prelude type ReadS a = String -> [(a, String)]
10:04:13 <lambdabot> Text.ParserCombinators.ReadP type ReadS a = String -> [(a, String)]
10:04:13 <lambdabot> Text.Read type ReadS a = String -> [(a, String)]
10:04:34 <o1iver> I guess the thing is that I then have to always specify both
10:04:38 <Saizan> Wooga: Prelude does
10:04:57 <Wooga> ah, ReadS is defined so
10:05:33 <Saizan> o1iver: you could make one a subclass of the other
10:07:10 <o1iver> Saizan: ah yes... that's right! Didn't think of that for some reason
10:07:13 <o1iver> thanks!
10:09:19 <zzo38> How can I tell cabal to rebuild a package that is already installed?
10:09:31 <monochrom> --reinstall
10:09:31 <ByronJohnson> zzo38: --reinstall
10:10:25 <zzo38> I don't need to redownload it; I only need to rebuild it.
10:11:01 <monochrom> sure. --reinstall
10:13:20 <alpounet> zzo38, i don't think cabal keeps a source archive of packages it installs once they are installed, so it'll readownload it
10:13:48 <monochrom> it keeps. it doesn't re-download. unless you erase it.
10:14:23 <monochrom> ls ~/.cabal/packages/hackage.haskell.org for some surprises
10:15:54 <zzo38> What surprises do you mean?
10:16:56 <zzo38> This computer is not UNIX, so I used:   dir "%appdata%\cabal\packages\hackage.haskell.org"   is that any surprises? I have seen that directory before but am unsure what (if anything) to do with it
10:17:39 <monochrom> if you already know its existence, the surprise is not for you
10:20:54 <LostPW> hello, can anybody tell where i can find an friendly instruction in monads.
10:21:18 <mauke> LostPW: do you already know Functor?
10:21:24 <monochrom> learnyouahaskell.com is the friendliest
10:21:40 <zachk> http://learnyouahaskell.com
10:22:11 <daimrod> LostPW: http://web.cecs.pdx.edu/~antoy/Courses/TPFLP/lectures/MONADS/Noel/research/monads.html is nice too
10:22:34 <LostPW> mauke no ... i only have our lecture and we started with functional parsers and after this started with monads  and both have f*** my brain
10:22:43 * hackagebot extensible-data 0.1.0.4 - Sums/products/lists/trees which can be extended in other modules  http://hackage.haskell.org/package/extensible-data-0.1.0.4 (AaronBlack)
10:22:50 <mauke> LostPW: oh, that makes sense
10:23:47 <LostPW> i can hope that parsers and monads where not asked in the exam :-)
10:23:51 <monochrom> it takes more examples
10:23:51 <zzo38> Hopefully my package is correct this time!!!!!!
10:24:34 <mauke> http://bulbapedia.bulbagarden.net/wiki/Bind_%28move%29  http://bulbapedia.bulbagarden.net/wiki/Return_%28move%29
10:24:37 <mauke> pokemonad
10:24:54 <monochrom> hahaha
10:25:25 <LostPW> lol
10:25:32 <zachk> monadnock
10:26:46 <zzo38> And then, join and fmap as well...........?
10:28:06 <zzo38> Is there a way to tell cabal to tell Hackage to make documentation immediately (possibly according to files I generate locally, if necessary)?
10:29:18 <Saizan> nope
10:31:31 <zzo38> Can you make -XDefaultInstances extension in Haskell? I think it will be important, it can be used to make up a new Monad class and so on without causing incompatibilities with existing programs:   class Functor m => Monad m where { ... }; default instance Prelude.Monad m => Functor m where { ... }; default instance Prelude.Monad m => Monad m where { ... }; default instance Monad m => Prelude.Monad m where { ... };
10:33:42 <dmwit> zzo38: There are several proposals floating around on the Haskell Prime wiki.
10:34:02 <zzo38> dmwit: OK. Anything similar to what I have specified?
10:34:03 <dmwit> Why not take a look at them, decide which one you think makes the best tradeoff, and take a whack at implementing it in GHC?
10:34:34 <zzo38> My computer is too slow and lacks sufficient memory to compile GHC.
10:35:16 <dmwit> Perhaps you should buy a new toaster. ;-)
10:36:34 <zzo38> How do I properly make a proposal? I have many ideas.
10:37:35 <zzo38> How do I find Haskell Prime?
10:37:52 <dmwit> zzo38: http://hackage.haskell.org/trac/haskell-prime/wiki/Process for information on the proposal process
10:38:10 <dmwit> http://hackage.haskell.org/trac/haskell-prime/ is the launching point for any Haskell' question
10:41:00 <zzo38> Where do I find the proposals related to -XDefaultInstances idea?
10:42:04 <dmwit> zzo38: Click "all proposals, grouped by topic" or something like that.
10:42:16 <dmwit> There's only about a hundred proposals, so just read their titles and browse any that sound likely.
10:50:02 <zzo38> I found a list of some things they want to remove. I disagree; most of those things should be kept. Typeclasses are useful I like to keep it. But there are many things I would be OK to remove (although it should be an extension which removes them): layout, do, if/then/else, list comprehensions, unicode, etc.
10:51:13 <zzo38> Although you might disagree with me.
10:51:46 <hpaste> “Joey Adams” pasted “How can I assert patterns more concisely?” at http://hpaste.org/63874
10:51:56 <LostPW> never remove list comprehension o.0 its so awesome and powerful
10:52:27 <JoeyA> How can I assert that a value matches a pattern more concisely than in the code above?  I don't mind changing the monad and definition of expectMessage.
10:52:29 <Cale> zzo38: who is "they"?
10:52:43 <Cale> LostPW: It's sort of subsumed by do-notation
10:52:55 <Cale> LostPW: but it's prettier for some uses
10:52:55 <zzo38> LostPW: Well, I don't like list comprehension, or do-notation.
10:52:57 * koeien wants monad comprehensions
10:53:05 <JoeyA> I could use a pattern guard in do notation: Version v <- expectMessage conn
10:53:10 <gwern> you can remove unicode, if you want to piss off the entire world
10:53:12 <LostPW> o.0
10:53:13 * ben also wants to comprehend monads
10:53:26 <JoeyA> But then I lose the message value, whose type I want to log.
10:55:01 <JoeyA> I suppose I could have expectMessage run in a state monad that carries the last message to use in an error message...
10:55:51 <JoeyA> Another alternative would be to have a non-exhaustive lambda: version <- expectMessage conn $ \(Version v) -> v
10:56:15 <mandaya> zzo38: I've found do notation isn't the most elegant thing ever, but it sure as hell helps readability
10:56:33 <JoeyA> I like this, but I have to set up an exception handler and evaluate a pure value.
10:56:34 <mandaya> zzo38: I'm with you on list comprehensions though
10:56:52 <zzo38> An idea, if you remove "if/then/else", then make up a new "else" which can be used in a lambda expressions used in case of pattern match failure (which is not specific to monads)
10:56:55 <quintessence> JoeyA: possibly partial lenses for each of your constructors could help
10:57:09 <JoeyA> What do you mean?
10:57:29 <JoeyA> These? http://hackage.haskell.org/packages/archive/partial-lens/0.0.1/doc/html/Data-Lens-Partial-Common.html
10:57:49 <quintessence> I'm not actually up to date on the state of various lens packages
10:58:17 <quintessence> but I'm pretty sure some of them have TH to derive partial inverses for constructors
10:58:41 <zzo38> quintessence: I like "data-lens"
10:58:52 <quintessence> (basically just \x -> case x of {Con y -> Just y; _ -> Nothing}, but automatic)
10:59:10 <zzo38> mandaya: I have used do-notation a little bit in the first Haskell program I wrote, but now I know better Haskell and I find do-notation to be useless
10:59:43 <Cale> I have programmed in Haskell for 10 years, and I use do-notation all the time
10:59:49 <parcs`> the guys who wrote haskell find do notation useful
11:00:13 <Cale> It's a lot clearer and prettier than
11:00:17 <Cale>  foo >>= \x ->
11:00:25 <Cale>    bar >>= \y ->
11:00:34 <JoeyA> My favorite trick is abusing layout to un-nest stuff.  One example I saw in GHC:
11:00:38 <Cale>    baz >>= \z -> ...
11:00:38 <JoeyA> exists <- ...
11:00:40 <Cale> etc.
11:00:41 <JoeyA> if exists
11:00:42 <JoeyA>     then ...
11:00:45 <JoeyA>    else do
11:00:47 <JoeyA> ...
11:00:53 <JoeyA> (err, indent that else one more space)
11:01:04 <JoeyA> Unfortunately, this doesn't work with case.
11:01:39 <Cale> um, I'm not sure what you're getting at there... that looks like the standard indentation of if/then/else (once you add the space)
11:01:52 <JoeyA> As opposed to:
11:01:53 <JoeyA>     else do
11:02:00 <JoeyA>         wayOverHere
11:02:18 <rwbarton> you don't have to indent if-then-else in any particular way at all actually
11:02:22 <JoeyA> right
11:02:36 <rwbarton> except as constrained by the surrounding layout block
11:02:38 <zzo38> Cale: I don't like  foo >>= \x -> bar >>= \y -> ...  either. I did invent a <>>= operator which I use in some programs, and then there are Applicative operators, I use all of those
11:04:29 <Cale> zzo38: What's the type of <>>=?
11:04:57 <zzo38> Cale:  (<>>=) :: (Functor m, Monad m) => m a -> (a -> m b) -> m a;
11:04:58 <Cale> zzo38: The applicative operators on their own are not general enough to express all the programs in IO
11:05:23 <zzo38> Cale: I know applicative operators on their own are not general enough. I do use >>= and join for IO as well
11:05:27 <Cale> zzo38: That also isn't quite general enough.
11:05:31 <Cale> okay
11:05:40 <mib_c98c4> !help
11:06:34 <rwbarton> sure it is, you can recover (>>=) using that and IORefs :P
11:07:52 <zzo38> I do use >>= with IO and other monads, especially the list monad
11:08:16 <zzo38> You can see how I write a program, like this   http://sprunge.us/Fejg
11:09:02 <rwbarton> I wish I hadn't.
11:09:56 <chridi> zzo38: u do literate programming?
11:10:10 <zzo38> chridi: Yes. Do you have any question?
11:10:15 <Cale> zzo38: I think many of those things would be clearer and shorter if you just used do-notation :P
11:10:19 <chridi> zzo38: what do u use?
11:10:33 <chridi> zzo38: or do u use some sed magic to get the .hs file?
11:10:48 <zzo38> chridi: For C programs I use Enhanced CWEB (a variation of CWEB I made myself); for Haskell I just use Plain TeX.
11:10:58 <chridi> okay...
11:11:07 <zzo38> chridi: I could use sed or AWK to get the .hs file but Haskell can do that itself so I don't need to
11:11:17 <chridi> oh
11:11:19 <chridi> okay
11:11:20 <Cale> chridi: That file he linked is a valid .lhs source file
11:11:24 <chridi> how do you compile it?
11:11:32 <Cale> chridi: You can just pass it to the compiler
11:11:40 <zzo38> chridi: If the file extension is .lhs then you just compile it like any other Haskell program.
11:11:44 <chridi> cool
11:11:59 <chridi> have to try it :)
11:12:18 <zzo38> I did write birdstyle.tex myself it is a macro package to allow Plain TeX to parse bird style programs
11:13:53 <nand`> @hoogle (Eq b) => (a -> b) -> a -> a -> Bool
11:13:53 <lambdabot> Data.Function on :: (b -> b -> c) -> (a -> b) -> a -> a -> c
11:13:53 <lambdabot> Prelude maybe :: b -> (a -> b) -> Maybe a -> b
11:13:54 <lambdabot> Data.Maybe maybe :: b -> (a -> b) -> Maybe a -> b
11:14:06 <zzo38> chridi: There are two styles supported in .lhs files: Bird-style (the one I use) and LaTeX-style. You are allowed to mix both in the same file.
11:14:18 <chridi> okay
11:14:27 <chridi> thats realy great
11:14:42 <Adrian1> hy i dontunderstand what 	(a -> b) -> [a] -> [b] means im trying to make a function that works with map such as i have Funct x = map anotherFunt x; and my anotherFunct :: String -> String just does x = x  and it does not work what does the (a -> b) means could u give me an example of map with a custom function please
11:15:19 <chridi> think i will do more literate programming now :)
11:15:24 <zzo38> Bird-style means all lines with > at first is program codes, and there must be a blank line before and after a block of > lines. LaTeX-style means \begin{code} on a line by itself starts a code block and \end{code} on a line by itself ends a code block.
11:16:33 <chridi> okay...
11:16:36 <mandaya> Adrian1: (a->b) is the type of a function
11:16:40 <mandaya> from some type to some other type
11:16:46 <chridi> hmh.. have to try it to find out which style is better
11:16:56 <mandaya> so the whole function has type (a->b) -> [a] -> [b]
11:17:03 <chridi> but.. vim does the right syntax highlighting...
11:17:11 <chridi> in the code blocks
11:17:24 <mandaya> which means that it takes a function from a to b, and applies it to each element of the list (which has type [a])
11:17:32 <hpaste> nyingen pasted “build failure on c2hs” at http://hpaste.org/63877
11:17:40 <mandaya> the result of that is a list of type [b]
11:17:55 <zzo38> chridi: It is a matter of preference. I prefer bird-style but you can use whichever one you prefer.
11:17:56 <mandaya> Read the section on learn you a haskell about functors
11:18:01 <nyingen> so I'm trying to build c2hs "locally" (not system-wide)
11:18:17 <nyingen> c2hs dies with an error about illegal datatype context
11:18:27 <Adrian1> http://hpaste.org/63878
11:18:28 <chridi> zzo38: if you write latex its better to use tex style, or?
11:18:28 <nyingen> presumably I can fix that by editng the .cabal file, but where does it live?
11:18:28 <Adrian1> i have this
11:18:33 <Jafet> cabal install c2hs --user
11:18:53 <Adrian1> what do i need to change so i make it work
11:18:59 <mandaya> Adrian1: String is an alias for [Char]
11:19:00 <Adrian1> maybe ill understand by an example
11:19:12 <mandaya> so if you want to map over a list of Char
11:19:13 <Adrian1> ok
11:19:16 <nyingen> Jafet: what about the 'use -XDatatypeContexts' error?
11:19:24 <mandaya> you need a function from a character to something else
11:19:32 <mandaya> Since you want the result to still be a string
11:19:39 <zzo38> chridi: I don't know LaTeX much; I use Plain TeX.
11:19:40 <mandaya> the function needs to be from Char -> Char
11:19:59 <mandaya> make sense?
11:20:11 <Jafet> I don't know. If you want to monkey patch it in, unpack the tarball yourself, add {-# LANGUAGE DatatypeContexts #-} and rebuild.
11:20:27 <Jafet> Naturally, that masks the real problem.
11:20:30 <Adrian1> i did that
11:20:31 <Adrian1> i changed
11:20:34 <Adrian1> everything
11:20:36 <Adrian1> in both functions
11:20:38 <Adrian1> to char
11:20:41 <mandaya> hmm?
11:20:45 <nyingen> I was hoping I could somehow find where cabal downloaded the package, fix teh cabal file, and then proceed as normal
11:20:48 <nyingen> perhaps that's not possible
11:20:53 <mandaya> no, just ab needs to have type Char -> Char
11:20:59 <chridi> hmh
11:21:04 <mandaya> hang on, I'll add some annotations
11:21:06 <Jafet> cabal downloads packages to the directory named "packages"
11:21:16 <Adrian1> ok
11:21:20 <Jafet> ls -R ~/.cabal
11:21:20 <Adrian1> it works
11:21:29 <chridi> i just wonder if pdflatex will build a .lhs file
11:21:31 <mandaya> good
11:21:38 <mandaya> does it make sense now?
11:21:46 <nyingen> Jafet: I see
11:22:01 <Adrian1> yes
11:22:02 <Adrian1> but still
11:22:04 <Adrian1> that
11:22:09 <mandaya> (see if you can write a pair of functions that adds 2 to each number in a list)
11:22:17 <zachk> > let squareAString x = ((read x)::Int) ^ 2 in map squareAString ["5","10","25"]
11:22:18 <lambdabot>   [25,100,625]
11:22:26 <Adrian1> ok
11:22:33 <zachk> for whoever wanted map on custom functions
11:22:36 <Adrian1> we can do that
11:22:37 <Adrian1> with
11:22:38 <Adrian1> simply
11:22:45 <rwbarton> your spacebar seems to be broken
11:22:53 <Adrian1> im sorry i will stop doing that
11:23:01 <mandaya> just add it to the hpaste
11:23:03 <mandaya> I can see it there
11:23:12 <rwbarton> thanks :)
11:23:42 <erus`> :t fmap
11:23:42 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
11:23:58 <erus`> what are some other functions that take type constructors?
11:24:07 <mandaya> :t (>>=)
11:24:08 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m a -> (a -> m b) -> m b
11:24:15 <mandaya> :t sort
11:24:16 <Adrian1> i finally understood what (a - > b) -> [a] -> [b] means thank you soo much
11:24:16 <lambdabot> forall a. (Ord a) => [a] -> [a]
11:24:23 <mandaya> eh, guess not that one
11:24:25 <nyingen> finally: hsndfile is installed.
11:24:34 <nyingen> that took a lot of shell commands.
11:24:44 <mandaya> most of the operators in Control.Monad/Applicative do
11:25:04 <mandaya> Adrian1: no problem
11:25:06 <Adrian1> xSyl [3,4,5] [5,6,7]
11:25:07 <Adrian1> :D
11:25:18 <erus`> i probably shouldnt try to implement a type system i dont know inside out :|
11:25:37 <erus`> but fuck the man
11:25:53 <mandaya> Adrian1: you're just starting to touch on a very interesting and broad issue
11:26:05 <mandaya> Adrian1: I highly reccommend checking out the chapter on Functors in Learn you a haskell
11:26:15 <Jafet> @hackage thih erus`
11:26:15 <lambdabot> http://hackage.haskell.org/package/thih erus`
11:26:46 <mandaya> (the function you just learned is a special case of something slightly more general)
11:28:16 <erus`> does thih treat (->) as a type constructor?
11:28:25 <Jafet> Do dyslexic programmers wonder if functors are an instance of Monad?
11:28:39 <Jafet> erus`: sorry, I don't know thih inside out.
11:29:02 <mandaya> :k (->)
11:29:03 <lambdabot> ?? -> ? -> *
11:29:29 <erus`> a `fn` b    = TAp (TAp tArrow a) b
11:29:34 <erus`> no then :|
11:31:51 <quintessence> tArrow   = TCon (Tycon "(->)" (Kfun Star (Kfun Star Star))), so it looks like yes
11:32:30 <zzo38> chridi: pdflatex should compile a .lhs file as long as it is a valid LaTeX document.
11:32:43 <zzo38> (The extension doesn't matter.)
11:32:54 <erus`> i mean yes :)
11:32:55 <chridi> zzo38: i already found out..
11:33:09 <chridi> zzo38: thats realy great
11:33:32 <chridi> just another reason to love haskell ;)
11:37:54 <DxBlueIce> hey, can anyone help me with leksah - please pm!
11:38:48 <hpc> DxBlueIce: any particular reason the problem can't be solved in-channel? :P
11:38:49 <erus`> i think someone should design a haskell with simpler syntax, eg. get rid of multiple type declarations (user case), dont allow pattern in type decl (use case) etc etc
11:39:00 <hpc> erus`: they can call it "scheme"
11:39:10 <erus`> yeah bu typed :|
11:39:24 <hpc> typed scheme would actually be pretty cool
11:39:35 <mandaya> hpc: a few exist
11:39:56 <mandaya> I'm taking the programming languages course at school next quarter, where we have to write a scheme
11:40:01 <DxBlueIce> ok, how do i setup leksah correctly? i installed the haskell platform before; but leksah can't find the packages?
11:40:23 <mandaya> I'm really tempted to put in the work to write a typed scheme with strong type inference
11:40:45 <mandaya> but at the same time, it's the term before I graduate...
11:40:49 <hpc> haha
11:41:12 <stulli> What's the difference between type inference and duck typing?
11:41:37 <mandaya> type inference determines what type some polymorphic variable must have
11:41:54 <hpc> stulli: duck typing is a membership test
11:41:56 <quintessence> stulli: duck typing crashes at runtime if you do something impossible, type inference tells you at compile time
11:41:59 <mandaya> duck typing simply assigns a type based on how something is used (and determines at run time whether or not it was correct)
11:42:06 <td123> duck typing means if it looks,sounds,tastes, like a duck, it is a duck :)
11:42:13 <hpc> stulli: it doesn't check the type so much as it checks "does this name exist inside the class definition"
11:42:33 <Sgeo> There is something similar to duck typing for statically-typed languages
11:42:42 <Sgeo> Structural typing I think?
11:42:47 <mandaya> hpc: it's a run time test, not a compile time test
11:43:07 <mandaya> hpc: may as well think of it as no test at all, it just tries it and if it works, great
11:43:12 <hpc> Sgeo: yeah
11:43:42 * mandaya wonders why anyone thinks that's a good idea...
11:43:51 <nyingen> td123: tastes? I'm pretty sure you have to kill the duck in order to taste it
11:44:09 <zzo38> nyingen: What if you only taste part of a duck?
11:44:15 <mandaya> nyingen: so? :P
11:44:20 <hpc> in haskell, you can /kinda/ get something that looks like duck typing
11:44:27 <hpc> if you take type classes, and really squint at them
11:44:39 <mandaya> that's some squinting
11:44:56 <mandaya> I mean, I guess it solves a similar problem
11:45:04 <nyingen> "oh wait, this wasn't a duck after all, it was an albatross! I wasn't supposed to kill/taste that one"
11:45:08 <mandaya> but it's a totally different approach
11:45:11 <hpc> indeed
11:45:15 <nyingen> unfortunately, the process is already dead of runtime errors at that point
11:45:28 <mandaya> nyingen: your point?
11:45:39 <mandaya> nyingen: that's how those languages work
11:45:39 <nyingen> I just find this a strange metaphor. :)
11:45:50 <hpc> nyingen: who cares about ducks? bird's the word
11:45:50 <mandaya> it's actually quite apt :P
11:46:01 <nyingen> the idea of tasting animals to see what species they are
11:46:20 <nyingen> "hm, this tastes like staphyloccocus aureus"
11:46:25 <mandaya> haha
11:46:25 <nyingen> sorry, I'll shut up now.
11:46:36 <Jafet> @quote python.way
11:46:36 <lambdabot> Jafet says: it's more fashionable nowadays to do it [write code] the python way, pretend your code works when you write it and hope it works when you run it
11:46:43 <zzo38> Which of your own arm do you prefer to taste, your left or right arm?
11:46:53 <stulli> Thanks for all the answers. Some it still seems to me like a dynamic vs static typing thing, but i'll wrap my head around it some more
11:47:22 <mandaya> stulli: yea, very much so. you are in #haskell after all
11:47:40 <koeien> in data X m = ..., can m be of kind other than * ?
11:47:51 <hpc> koeien: depends how you use m
11:47:55 <hpc> :k Mu
11:47:56 <lambdabot> (* -> *) -> *
11:47:59 <mandaya> also, to anyone who might know... if I did want to go about writing a type inferencer
11:48:03 <mandaya> what are the key papers to read?
11:48:05 <hpc> @src Mu
11:48:05 <lambdabot> newtype Mu f = In { out :: f (Mu f) }
11:48:06 <stulli> Heh, perhaps i should have ask what the difference is between type inference and structural typing
11:48:59 <zero_> I want to read numbers from user input (in one line) and add them together, however sum . map read. words line doesnt work... Am I using read in a wrong way?
11:49:06 <hpc> stulli: type inference is kind of a tangental concept
11:49:20 <hpc> stulli: you can have type inference and duck typing, in theory
11:49:36 <Jafet> zero: words line isn't a function, you cannot apply (.) to it
11:49:45 <koeien> i tried data X m = C (m (Y m)), this was rejected
11:50:16 <hpc> koeien: what's Y?
11:50:59 <koeien> hpc: i'll fiddle some more, if I don't manage to, i'll paste it :)
11:51:01 <zero_> Jafet: words is not a function?
11:51:01 <hpc> stulli: you might have better luck looking up "parametric polymorphism"
11:51:12 <Jafet> zero: of course it is.
11:51:20 <hpc> :t sum . map read . words
11:51:21 <lambdabot> forall a. (Num a, Read a) => String -> a
11:51:22 <nand`> polymorphism with class restraints is what I'd call duck typing in haskell
11:51:25 <Jafet> words line is not.
11:51:29 <mandaya> zero_: it isn't once you've applied it to line
11:51:33 <hpc> > sum . map read . words "bacon bacon"
11:51:34 <lambdabot>   Couldn't match expected type `[GHC.Types.Char]'
11:51:34 <nand`> Num a => a
11:51:35 <lambdabot>         against inferred ty...
11:51:42 <hpc> > (sum . map read . words) "bacon bacon"
11:51:43 <mandaya> (function application binds very tight)
11:51:44 <lambdabot>   *Exception: Prelude.read: no parse
11:51:46 <nand`> if it (a) walks like a number and acts like a number, it is a number
11:51:49 <quintessence> stulli: structural typing is a statement about when two types are compatible (when they have the same field and corresponding fields have compatible types)
11:51:51 <hpc> > sum . map read . words $ "bacon bacon"
11:51:53 <lambdabot>   *Exception: Prelude.read: no parse
11:52:15 <mandaya> > read "bacon bacon"
11:52:16 <lambdabot>   *Exception: Prelude.read: no parse
11:52:28 <hpc> zero_: (f . g . h x) parses as (f . (g . (h x)))
11:52:39 <hpc> zero_: (f . g . h) x parses right
11:52:39 <mandaya> does read work on lambdabot?
11:52:42 <mandaya> :t read
11:52:43 <lambdabot> forall a. (Read a) => String -> a
11:52:46 <hpc> as does (f . g . h $ x)
11:52:50 <hpc> > read "100"
11:52:51 <lambdabot>   *Exception: Prelude.read: no parse
11:52:52 <mandaya> hmm, it should
11:53:02 <hpc> > read "()" -- oh god, monomorphism
11:53:03 <quintessence> stulli: a language with structural typing could still force you to write out types (e.g. Go's interface types)
11:53:03 <lambdabot>   ()
11:53:05 <mandaya> > read "100" :: Int
11:53:06 <lambdabot>   100
11:53:12 <mandaya> ah, that's what it is
11:53:29 <koeien> hpc: oh the error was somewhere else, in an associated type something was rejected. never mind.
11:53:40 <mandaya> > sum . map read . words $ "5 10 15"
11:53:42 <lambdabot>   30
11:53:45 <stulli> hpc, quintessence: Interesting, i'm not sure if i could explain it to a coworker but slowly i seem to understand :)
11:54:36 <quintessence> stulli: whereas with type inference you don't have to write out types, but two types might not be compatible even if they have the same structure (e.g. newtype Row = Row Int; newtype Col = Col Int in Haskell)
11:54:51 <mandaya> anyway, I'm off to catch some sleep (finally, only 16ish hours late!). "Night" all.
11:55:25 <hpc> quintessence: actually, that's a good explanation of duck typing
11:55:33 <zero_> i must be doing something else wrong then, because haskell is complaining.. No instance for (Num String)
11:55:35 <koeien> oh no it isnt. wut?
11:55:46 <koeien> zero_: you're trying to add a string to another string
11:55:51 <koeien> but strings are not numeric.
11:56:02 <zero_> koeien: no, im trying to add the numbers of the string
11:56:09 <nand`> > "hello" + "world"
11:56:10 <lambdabot>   No instance for (GHC.Num.Num [GHC.Types.Char])
11:56:10 <lambdabot>    arising from a use of `GH...
11:56:29 <hpc> > sum . map read . words $ "100 200 5 10" -- this should work
11:56:29 <zero_> koeien: the string is supossed to be something like "1 3 5 3"
11:56:30 <lambdabot>   315
11:56:34 <stulli> quintessence: Thanks, that helped a lot!
11:57:17 <hpaste> koeien pasted “kind error?” at http://hpaste.org/63881
11:57:24 <koeien> why do i get this error?
11:58:07 <nand`> > map (read :: String -> Int) . words $ "1 3 5 3"
11:58:09 <lambdabot>   [1,3,5,3]
12:01:04 <zero_> thank you guys!!!
12:03:41 <jfischoff> koeien: are you still getting that error?
12:04:00 <koeien> jfischoff: yes
12:04:23 <koeien> i can't see what's wrong. r has kind * -> *, it should work
12:04:45 <jfischoff> koeien: I think it is confused by the second of us of r
12:05:10 <jfischoff> koeien: it can't tell if r has kind * or * -> *
12:05:25 <koeien> can I annotate that somehow?
12:05:56 <koeien> ah!
12:06:01 <koeien> it's confused by Z r
12:06:05 <jfischoff> koeien: I don't it
12:06:19 <koeien> it thinks the r in Z r has kind *, but it does not
12:06:38 <quintessence> you should be able to write data Z (r :: * -> *) = Z
12:06:47 <jfischoff> koeien: yeah, I think you can write code like that because you can never apply a type to the second use of r
12:06:49 <koeien> quintessence: yeah i figured that out by trial & error. It works now.
12:07:11 <koeien> it did work without the sig with 7.0.3.
12:07:15 <jfischoff> koeien: or maybe you can ..
12:07:23 <jfischoff> cool
12:07:23 <koeien> maybe related with the new kind stuff in 7.4
12:07:36 <quintessence> I think kinds are no longer simple enough to make kind inference always work
12:07:56 <koeien> should i file a bug or is this expected behavior?
12:07:59 <cfricke_> Hey peeps, is it true that `man` is currently broken due to missing symlink of less?
12:08:07 <quintessence> but I would actually have expected Z to be kind-polymorphic in r, so I'm not sure
12:08:14 <cfricke_> I guess rtfm is not an option. Hah
12:08:34 <koeien> cfricke_: this is #haskell, are you sure you're in the correct channel?
12:08:36 <cfricke_> Ups, excuse me, wrong channel.
12:09:14 <cfricke_> Seems my irssi config is broken as well... embarressing.
12:10:53 <koeien> the user's guide mentions "For the release on GHC 7.4 we focused on getting the new kind-polymorphic core to work with all existing programs (which do not make use of kind polymorphism)." so I suppose this is not expected behavior
12:11:11 <t7> is there a flipped fmap in the Prelude?
12:11:23 <t7> @hoogle f a -> (a -> b) -> f b
12:11:23 <lambdabot> Prelude fmap :: Functor f => (a -> b) -> f a -> f b
12:11:23 <lambdabot> Data.Functor fmap :: Functor f => (a -> b) -> f a -> f b
12:11:24 <lambdabot> Control.Monad fmap :: Functor f => (a -> b) -> f a -> f b
12:11:29 <koeien> t7: no, not that i know of
12:11:55 <t7> binds are left to right but you fmap right to left :|
12:12:12 <MostAwesomeDude> :t (>=>)
12:12:13 <lambdabot> forall a (m :: * -> *) b c. (Monad m) => (a -> m b) -> (b -> m c) -> a -> m c
12:12:36 <otters> > return >=> return 3
12:12:37 <lambdabot>   Overlapping instances for GHC.Show.Show (a -> m c)
12:12:38 <lambdabot>    arising from a use of...
12:15:32 <pouye> i haskell a good language for me to step forward in real programming for now i just did silly exercises
12:16:06 <notsmack> @faq
12:16:07 <lambdabot> The answer is: Yes! Haskell can do that.
12:17:11 <monochrom> define "real"
12:18:51 <pouye> monochrom, like i only did some exercises on lists and stuff like that. i want to start doing some chat clients, some web apps, some medium apps/games
12:19:43 <monochrom> there are like 3 frameworks for web apps
12:21:24 <nand`> and some dozen bindings for the various rendering libs (OpenGL, D3D, SDL)
12:21:30 <nand`> both high and low level
12:21:44 <t7> monochrom: a point in one dimension :3
12:21:55 <nand`> and bindings (high and low level) for most GUI frameworks out there
12:22:10 <monochrom> haha t7
12:22:10 <nand`> including but not limited to medium-level access to Gtk, Qt and so on but also low-level access to X11
12:22:16 <pouye> monochrom, what about the other stuff. i dont want to just do web dev
12:22:49 <pouye> is there a good binding for gtk?
12:23:12 <zachk> gtk2hs?
12:23:31 <koeien> Gtk2Hs is quite nice
12:23:51 <koeien> but it's imperative.
12:24:14 <pouye> koeien, there is no one gui directioned to functional languages?
12:25:15 <nyingen> why would there be? functional languages are a pretty diverse group
12:25:46 <zachk> gloss, fran, fruit, gtk2hs, opengl, glut, wxhaskell(out of date and imperative), hgl (hugs graphics library, flickers): all for haskell
12:25:58 <koeien> pouye: there are various Functional Reactive Programming initiatives. I'm not qualified to comment.
12:26:20 <Adrian1> hello im wondering how would i write my where clause so it would work
12:26:22 <Adrian1> http://hpaste.org/63882
12:26:27 <Adrian1> thanks
12:27:14 <koeien> Adrian1: i'm not sure what you want to accomplish.
12:27:19 <nand`> :t (||)
12:27:20 <lambdabot> Bool -> Bool -> Bool
12:27:27 <nand`> pretty sure [Char] ≠ Bool
12:28:04 <otters> @src (||)
12:28:04 <lambdabot> True  || _ =  True
12:28:04 <lambdabot> False || x =  x
12:28:37 <nand`> Adrian1: also even if "a" || "e" worked that would be no different from writing bb _ _ since the local where would shadow
12:28:41 <Adrian1> i want to group all the vowls that are adjacent in a string
12:29:30 <Adrian1> thats what i am trying to acomplish
12:29:41 <nand`> groupBy (\x y -> isVowel x && isVowel y)
12:29:42 <Adrian1> moaamaa = [ m , oaa  , m, aa]
12:29:43 <nand`> that?
12:30:19 <parcs`> > let isVowel = (`elem` "aeiou") . toLower in groupBy ((&&) `on` isVowel) "moaamaa"
12:30:20 <lambdabot>   ["m","oaa","m","aa"]
12:30:33 <otters> @pl \x y -> isVowel x && isVowel y
12:30:34 <lambdabot> (. isVowel) . (&&) . isVowel
12:30:54 <Adrian1> how do i make my isVowel function?
12:31:06 <nand`> (&&) `on` isVowel looks better
12:31:09 <koeien> isVowel 'a' = True; isVowel 'o' = True; ..; isVowel _ = False
12:31:21 <koeien> or, isVowel x = x == 'a' || x == 'o' || x == 'u' ..
12:31:23 <nand`> @pl (&&) `on` (`elem` "aeiou")
12:31:23 <lambdabot> (&&) `on` (`elem` "aeiou")
12:31:23 <otters> isVowel x = x `elem` "aeiou"
12:31:31 <nand`> ..
12:31:34 * nand` feels dumb now
12:31:49 <nand`> that's already point-free
12:32:12 <otters> @unpl (&&) `on` (`elem` "aeiou")
12:32:13 <lambdabot> (on (&&) (\ a -> elem a "aeiou"))
12:33:01 <nand`> @unpl (on (&&) (\ a -> elem a "aeiou"))
12:33:01 <lambdabot> (on (&&) (\ a -> elem a "aeiou"))
12:33:03 <pouye> is snap a good framework?
12:33:04 <nand`> hmm
12:33:15 <nand`> oh right, pl/unpl doesn't know of “on” etc.
12:33:29 <nand`> pouye: I don't know but I hear a lot about yesod
12:33:35 <stulli> > 'a' `elem` "aoeiAOEI"
12:33:36 <lambdabot>   True
12:33:36 <nand`> if you've had a look at that
12:34:46 <otters> :t on
12:34:47 <lambdabot> forall b c a. (b -> b -> c) -> (a -> b) -> a -> a -> c
12:35:38 <pouye> is Haskell a good language for me to write a chess program with the capabilitie to play online?
12:36:00 <koeien> an engine? or a grpahical client?
12:37:12 <nand`> engine definitely, one of the best tools for the job
12:37:20 <nand`> ie. if you want to write a chess AI
12:37:29 <koeien> nand`: depends. if you want a really strong one, then no
12:37:33 <nyingen> I wrote half of a graphical chess client in haskell
12:37:47 <pouye> nand`, yes, it has to have some AI
12:37:52 <nand`> frontend/client/server? eh, sure, why not, but nothing special about haskell for this
12:37:55 <otters> which half
12:38:03 <tromp__> from my experience, it's hard to write a fast engine
12:38:04 <pouye> the player will have the option to play with the computer has play online
12:38:08 <nand`> I'd only recommend writing your GUI programs in haskell if you like using haskell for unrelated reasons
12:38:14 <nyingen> I wrote most of the board display, and part of the FICS interface
12:38:28 <koeien> ah, interesting nyingen.
12:38:40 <nyingen> I find GUI programmingn extremely annoying in every language, so I eventually got frustrated and gave up for awhile
12:38:43 <pouye> nyingen, and what did you think?
12:38:47 <nyingen> it was fine
12:38:58 <alpounet> pouye, there are a few chess programs hanging around, if you want to look how "fine" they look like according to you
12:38:58 <nyingen> I was using SDL, not GTK
12:39:25 <koeien> the stockfish engine is excellent. it's C++.
12:39:36 <pouye> C could also be an option
12:40:38 <nyingen> these days I only use C when there's a really good reason to do so
12:41:15 <nyingen> haskell has such extensive libraries and a good FFI that I don't need C much anymore
12:42:20 <nand`> These days I only use C when.. oh who am I kidding, these days I don't use C
12:43:08 <pouye> well i have to improve my C skills as my Haskell skill. my goal in programming is to go deep on OS's
12:43:32 <monochrom> http://hackage.haskell.org/package/manatee may blow you away
12:43:39 <nand`> doesn't sound like you'll get much out of haskell then personally.. unless you're writing an OS for the reduceron :)
12:44:24 <nyingen> monochrom: that was interesting
12:45:36 <monochrom> look for "Then choose extension package list in below to install:" and be very intimidated!
12:46:28 <pouye> nand`, but first i need to get better in programming
12:46:54 <nand`> monochrom: sometimes I hate my country. Blocking a Haskell video due to GEMA-licensed music? Seriously? Good thing I have a proxy
12:47:25 <mauke> http://www.youtubeunblocker.org/
12:47:34 <nand`> I use proxtube
12:47:35 <morel> cool
12:47:38 <morel> me, too
12:47:57 <morel> btw, do you know youtuberepeat.com ? heheh
12:48:12 <morel> (but that's rather off-topic...)
12:49:28 <pouye> nand`, where are you from?
12:49:55 <`Zerax`> GEMA sounds like Germany :)
12:49:58 <nand`> ^
12:50:58 <pouye> oh ok
12:53:28 <nand`> Is there a shell written in/integrated with Haskell flexible/powerful enough to rival, say, bash?
12:53:48 <dmwit> nand`: ghci
12:53:50 <nand`> something like a mix between ghci and a shell would be nice
12:53:59 <nand`> well, ghci isn't usable as a general purpose shell
12:54:46 <nand`> and having to switch between ghci and bash constantly is annoying
12:55:27 <`Zerax`> What is it that you need from bash?
12:55:41 <MostAwesomeDude> I think he wants a system shell that speaks Haskell instead of bash.
12:55:48 <nand`> even if it doesn't have the haskell language integrated, something like xmonad but for shells would be great
12:56:22 <nand`> ie. something that I can quickly and painlessly recompile to match my needs
12:56:53 <nand`> MostAwesomeDude: not necessarily “speak” Haskell. It would just be nice to have haskell features integrated, ie. something like :t being accessible from the command line directly
12:57:22 <nand`> hmm
12:57:24 <nand`> that gives me an idea
12:57:46 <`Zerax`> Use a multi-tab terminal? ;p
12:57:51 <nand`> A shell that works like bash but has “> ” and “:” at the beginning of a line work like lambdabot
12:58:09 <nand`> and maybe some sort of built-in feature to evaluate haskell code on the spot
12:58:20 <nand`> like, inline
12:58:23 <shachaf> That's already written, if you're OK with typing "ghc -e" instead of ">".
12:58:43 <shachaf> I'm sure you can make an alias if that's too long.
12:59:03 <nand`> shachaf: the point is being able to define stuff using ghci-like “let” syntax
12:59:36 <shachaf> That can probably be done too, with a little more work.
12:59:46 <nand`> ie I would write > let f = someFunction and then later something like “cat foo | sed /bar/${f 5}/”
12:59:48 <nand`> y'know?
13:00:02 <nand`> and the contents of ${ f 5 } would be evaluated as if I had typed “f 5” into ghci
13:00:11 <nand`> I can see this working by just tying ghci together with an existing shell
13:00:17 <shachaf> You should make it and then show us.
13:00:18 <nand`> since ghci already does everything I want
13:00:31 <nand`> my shell just doesn't integrate with it :)
13:01:37 <nand`> shachaf: seems like my best bet would be to take an existing shell like bash or zsh and modify it to suit my needs
13:02:00 <nand`> hmm.. maybe using a ghcid to provide a persistent ghci session to everything that requests it
13:02:02 <nand`> that would be interesting
13:02:04 <zzo38> http://zzo38computer.cjb.net/textfile/miscellaneous/haskell.proposals
13:02:15 <alpounet> or have some kind of bash templating engine
13:02:46 <zzo38> (Also available on gopher)
13:03:11 <nyingen> good old gopher
13:03:21 <dmwit> zzo38: Most of these are not language proposals.
13:03:38 <dmwit> (The language does not mention implementation-specific details like optimizations.)
13:03:52 <nand`> s/Haskell/GHC/
13:04:13 <dmwit> zzo38: The ones that *are* language proposals are so short on details it is impossible to judge them.
13:04:30 <zachk> -f-combine-modules already exists somewhere iirc
13:04:58 <zachk> -f-assume-no-error would just break horribly
13:07:08 <Veinor> @pl \(a, b) -> (a, f a b)
13:07:09 <lambdabot> uncurry (liftM2 (.) (,) f)
13:07:23 <zzo38> I am sorry; my computer broke.
13:07:32 <dmwit> Veinor: That is strangely beautiful.
13:07:45 <nand`> petition to rename -fcrashable to -fsudo-rm-rf-/
13:07:49 <nand`> because that's about as bad as it is
13:08:45 <zzo38> nand`: No it isn't; it is about as bad as a C program that fails to check that everything is correct
13:09:09 <nand`> and gets compiled with zero debugging information
13:09:28 <nand`> with no source code available and the last known maintainer not having worked on the project for 5 years
13:09:30 <nand`> the nyes
13:09:33 <nand`> then yes*
13:09:57 <zzo38> dmwit: Correct; the ones with -f are not language proposals they are compiler proposals. The one with -X are language proposals.
13:10:02 <Veinor> 2. Do-notation is no longer supported (freeing the keyword "do").
13:10:03 <Saizan> -XRemoveSomeSyntax could be -XIWantTheSchemeCompilerThx
13:10:05 <Veinor> who would ever use this?
13:10:25 <zzo38> Veinor: Anyone who wants to call a function "do".
13:10:29 <Veinor> i don't understand why you would want to do that
13:13:01 <zzo38> (HTTP server is temporarily down. Please use gopher in the mean time or wait for HTTP service to be restored.)
13:13:11 <quintessence> I've seen LambdaCase before and I approve
13:13:44 <Veinor> quintessence: using lambdacase, how do you get at the variable inside the case statements?
13:13:44 <quintessence> your DefaultInstances breaks the type system though if it works on classes with associated types
13:14:15 <quintessence> generally you don't want to, but if you must you can do case of { list@(x:xs) -> ... }
13:14:25 <quintessence> mostly I would want to use lambdacase in do notation
13:14:34 <quintessence> something >>= case of \n ...
13:15:25 * quintessence needs to separate syntax and metasyntax more clearly
13:16:21 <zzo38> OK I can see how the DefaultInstance breaks type system with classes with associated types. Perhaps there is a way to fix it? Such as, not allowing associated types to be used when there is no explicit instance.
13:16:36 <zzo38> (HTTP server has been restarted.)
13:17:21 <zzo38> How would you expect -fassume-no-error to break, exactly? Can you be specific?
13:17:39 <nand`> zzo38: what exactly is the purpose of !optional_extension?
13:17:44 <quintessence> well, the associated types problem is only a symptom; it also makes other class methods incoherent
13:17:57 <nand`> when would you ever want to include an extension if there is the possibility of it not being met?
13:19:00 <quintessence> for instance, if some modules use the default instance for Ord and some use a non-default one, you could have two (Map k a)'s built with different comparison functions
13:19:50 <zzo38> nand`: The ! means it really has no name; but it must be given one so that you can refer to the proposal. The reason for it, is such as, if you have an extension which is backward compatibility, such as {-# LANGUAGE NPlusKPatterns? #-} and some compiler turns them on all the time and does not recoginze that name, then it would still work. (I hate n+k patterns too; this is simply an example)
13:20:14 <zzo38> quintessence: Yes I know that. But there is already -XIncoherentInstances. You would just have to assume they are equivalent.
13:21:04 <nand`> Oh, I see now. Yes, default behavior that got degraded into an optional language extension
13:22:36 <quintessence> There's some work on putting type-level naturals into ghc: http://hackage.haskell.org/trac/ghc/wiki/TypeNats
13:25:08 <zzo38> quintessence: That is different from my proposal... it seems to be less useful than my proposal...
13:26:32 <quintessence> you can make a type Fin :: Nat -> * of bounded integers as long as you have a Nat kind
13:26:43 <quintessence> I don't think you gain anything by rolling both into one proposal and complicating the subkinding
13:27:08 <zzo38> In my proposal, the type of arrays of a fixed number of elements is very simple. It is:   (->)
13:27:47 <zzo38> I have now added -XHideNonexisting to my proposals file.
13:28:56 <Enigmagic> sounds like your going to be pretty busy for a while hacking on all these new features
13:29:36 <zzo38> I told you I cant my computer has not enough memory or speed
13:30:04 <Enigmagic> memory is pretty cheap nowadays
13:30:37 <monochrom> God, the world does not need more "you should buy a bigger computer" arguments
13:30:59 <ivanm> monochrom: faster /= bigger :p
13:32:24 <monochrom> just saying "memory is cheap" is very cheap
13:32:30 <Enigmagic> perhaps we should only allow GHC to use 1 gig for compiling
13:32:41 <Enigmagic> developers are very expensive
13:32:59 <`Zerax`> It boggles the mind that some consumers are building machines with 64gb of ram
13:33:41 <DxBlueIce> can anyone help me with this error: Loading package GLUT-2.3.0.0 ... can't load .so/.DLL for: glut32 (addDLL: could not load DLL)
13:34:10 <ivanm> DxBlueIce: get a copy of the glut32.dll (google will help) and shove it in the same directory as your code
13:34:20 <ivanm> or maybe C:\windows\system32
13:34:38 <DxBlueIce> i put it in C:\windows\system32 but that doenst help
13:36:18 <DxBlueIce> ivanm: ah fixed copying it in the same dic as code... ty!
13:37:34 <`Zerax`> Try to avoid putting things in windows\system32 having permission to do so is a security risk, and the windows loader will check the current directory and PATH anyway.
13:38:09 <ivanm> `Zerax`: more for "why do I have to copy this dll into every project I want to use it in" solutions ;)
13:38:24 <zzo38> Then just put it in the PATH
13:38:45 <ivanm> eh, my windows-fu isn't as great as it once was
13:38:54 <ivanm> and I never did any serious development on windows
13:39:10 <DxBlueIce> so what should i do to avoid putting it in my code dic?
13:39:36 <gentleben> put it somewhere in the path
13:40:05 <gentleben> if you want it to be truly shared
13:40:29 <gentleben> it was common practice pre .net to put all the libs you needed with your app
13:40:46 <DxBlueIce> how do i do this?
13:40:57 <gentleben> put it in your path?
13:41:20 <ivanm> gentleben: yes, because every individual app having its own copy of various libraries is a *great* idea and doesn't have any security problems at all! :p
13:41:34 <gentleben> well there is another issue
13:41:39 <DxBlueIce> yes
13:41:39 <gentleben> library versioning
13:42:10 <gentleben> just make some directory like c:\shared
13:42:19 <`Zerax`> Kind of depends on the implementation of the dll loading in what I assume is cabal, if it clears the search path and loads from the current directory, it may not help you.
13:42:26 <DxBlueIce> gentleben: ah i see
13:42:29 <gentleben> then edit the path variable to include it
13:45:15 <DxBlueIce> I am not satisfied with the haskell ide's (i tried leksah and eclipsefp) - can somebody tell me an easy to use ide?
13:45:47 <shachaf> Most people don't use IDEs for Haskell.
13:46:46 <koeien> DxBlueIce: most people use emacs or vim, I think.
13:47:06 <DxBlueIce> i would never think of using a text editor + cmd when coding java
13:47:20 <DxBlueIce> why would i when coding haskell
13:47:54 <CodeWeaverX> 'cause you've rejected two IDEs already?
13:48:10 <DxBlueIce> true :)
13:48:33 <CodeWeaverX> Also, given Haskell's GHCI interpreter (interactive mode), a lot of the reason for an IDE becomes less useful.  Prettier, yes.
13:48:35 <quintessence> IDEs mostly insert boilerplate for you; I think fewer people use them for terse languages like haskell (or python, or ruby, or ...)
13:49:09 <CodeWeaverX> Project management is nearly as basic as just using cabal to install packages, and organizing your files in a folder hierarchy for modules.
13:49:34 <CodeWeaverX> Many editors exist out there that have syntax highlighting.  Some have started to include Haskell.
13:49:44 <DxBlueIce> i see
13:50:18 <`Zerax`> The point is that Haskell is meant to provide you the utility to write small programs and libraries such that you don't need an IDE to manage it.
13:50:23 <CodeWeaverX> It *is* nice to have project management a bit more automated.  That's the one thing I'd miss without EclipseFP.  But it's not a huge argument.
13:50:40 <CodeWeaverX> Given the other tools available for the 'prettifying' of the process.
13:51:22 <CodeWeaverX> Step-debugging isn't nearly as useful in haskell as it is in other languages because things tend to get evaluated out of order anyway.  EclipseFP and Leksah do allow it, but its often just as convenient to use GHCI's built in debugger.
13:51:40 <CodeWeaverX> I suppose these things all sound like excuses until you get used to it.
13:52:00 <CodeWeaverX> Hell, I'm just getting started with Haskell, and I'm starting to get used to it.
13:52:17 <mgsloan> I think the problem of Haskell IDEs just hasn't been tackled well enough yet, because the task of creating a text editor people actually want to use is too large compared to the potential benefits of typical IDE stuff
13:52:55 <CodeWeaverX> especially since the text editor part is already available in other tools.
13:53:08 <`Zerax`> I would imagine that many of the people who know enough about the requirements don't think it is a problem that there isn't a good one available. ;)
13:54:10 <mgsloan> I am working on something that takes a slightly other perspective on things - that Haskell and friends have some properties that haven't yet been leveraged by IDEs.  Namely, there's a lot more to know about your code, that your compiler can tell you
13:54:58 <gentleben> completely disagree about debugging
13:55:07 <gentleben> complex apps need real debuggers
13:55:17 <mgsloan> though I am not shooting at creating an actual IDE, more of a coding assistant / type error killer
13:55:21 <gentleben> the current gdb support doesn't cut it
13:56:14 <gentleben> once apps grow in complexity you need real tools
13:56:24 <gentleben> also for hunting down corner cases
13:56:32 <gentleben> like BLACK_HOLE
13:56:37 <mgsloan> I agree.  I look forward to seeing these real tools develop ontop of this more rational foundation :)
13:56:39 <gentleben> and seg faults
13:56:51 <gentleben> slowly but surely
13:57:05 <CodeWeaverX> I suppose that'd be nice. :)
13:57:13 <gentleben> we are working on getting peter's symbols into 7.4.1
13:57:37 <gentleben> once that is done it will be possible to do much more debugging
13:57:42 <gentleben> with call stacks and stuff
13:58:42 <CodeWeaverX> i wonder why that wasn't done a long time ago.
14:00:32 <Enigmagic> because it's hard to do
14:00:33 <Enigmagic> :)
14:00:42 <CodeWeaverX> Ah, well, that's a good reason. :D
14:02:41 <Enigmagic> i don't think it's a real good reason but it's certainly a reason
14:03:52 <ddarius> Extrapolating, in 100 years people will still use vim.
14:04:10 <zachk> they sure will :)
14:04:24 <`Zerax`> vimim?
14:09:04 <DanBurton> if by "vim" you mean "the emacs operating system" then yes ;)
14:09:52 <quintessence> I recently got a second monitor and now I sometimes try to "C-x o" to firefox on the other screen
14:09:59 <DanBurton> because noone will bother to implement Agda for Vim, and Agda is obviously the language of the future >.>
14:12:50 <blbrown_win3> general question, what is that mathematical equivalent of pattern matching in something like haskell.  Or maybe there is no link?
14:13:49 <mgsloan> blbrown_win3: I'm no mathematician, but http://en.wikipedia.org/wiki/Structural_induction ?
14:14:26 <mgsloan> whoever wrote that article seems to know haskell :D
14:14:58 <blbrown_win3> mgsloan, that would be kind of cool.  Match some haskell code and map it to the math theory
14:17:04 <mgsloan> yup, or just turn Haskell into maths or vice versa
14:18:22 <ciaranm> which is all nice and fun until you try to do it carefully
14:18:38 <ciaranm> at which point _|_ comes along and makes your life a misery
14:18:48 <ciaranm> and then seq jumps out and stabs you in the groin
14:20:28 <ivanm> heh
14:21:17 <monochrom> I think mathematicians have always done pattern-matching without ever rigorizing it
14:22:10 <ciaranm> the formalism is there for inductively defined sets. but it's not very interesting so once you've seen that you can do it you don't really need to look at why.
14:25:46 <monochrom> they have also always done view patterns without rigorizing it
14:26:03 <ninestraycats> hey, i'm new to monads and wrapping my head around (>>=) and (>>). consider "do f1 <- readFile "f1"; f2 <- readFile "f2"; putStr $ f1 ++ f2". now, is there a neat way to desugar this? i've got something that looks rather ugly: "readFile "f1" >>= (\f1 -> readFIle "f2" >>= ('f2 -> putStrLn $ f1 ++ f2))"
14:26:30 <otters> that's how youd do it yes
14:26:30 <otters> you'd
14:26:54 <ninestraycats> suddenly i see the need for do-sugar :)
14:27:19 <mauke>  readFile "f1" >>= \f1 ->
14:27:20 <rwbarton> @undo do f1 <- readFile "f1"; f2 <- readFile "f2"; putStr $ f1 ++ f2
14:27:20 <lambdabot> readFile "f1" >>= \ f1 -> readFile "f2" >>= \ f2 -> putStr $ f1 ++ f2
14:27:40 <byorgey> yeah, the parentheses are unnecessary
14:28:06 <ninestraycats> wow, lambdabot is pretty bad ass
14:28:14 <byorgey> you have no idea
14:28:16 <mauke> ninestraycats: http://hpaste.org/63884
14:28:23 <CodeWeaverX> lambdabot frightens me.
14:28:24 <CodeWeaverX> :(
14:28:32 <mauke> @vixen hi
14:28:33 <lambdabot> I can take it. The tougher it gets, the cooler I get.
14:28:35 <monochrom> now, if you say, you don't care what mathematicians do, if they have never made it rigorous, you want to do it now, so how to proceed. in that case you can look at how theorem provers do it.
14:28:38 <ciaranm> lambdabot knows when you are sleeping
14:29:05 <ninestraycats> mauke: ah, that looks neater.
14:29:19 <ninestraycats> until i feel perfect with monads i'm trying to write everything with (>>=) and (>>)
14:29:44 <monochrom> so, for example, PVS and HOL do this: when you create an algebraic data type, the prover automatically adds this theorem: every value falls in one of those cases you create.
14:29:58 <ciaranm> ninestraycats: start by using join instead of bind
14:30:10 <byorgey> ninestraycats: that's a great idea
14:30:13 <byorgey> ciaranm: why?
14:30:31 <ciaranm> byorgey: because join, bind and fmap are the "right" way to do monads. bind is a convenience.
14:30:34 <ciaranm> er
14:30:37 <ciaranm> join, return and fmap
14:30:49 <byorgey> um, I don't agree.  join, bind and fmap are ONE way to do monads.
14:30:53 <byorgey> return + bind is another way.
14:31:03 <monochrom> so, to a large extent, it is just asserted. to a small extent, there is a set-theoretic model behind algebraic data types, and that theorem can be proved.
14:31:49 <byorgey> they are equivalent.  both have been used in the mathematics community before monads made their way into FP.
14:31:53 <ninestraycats> (i know i should just google but while i'm here...) where is join and bind defined? i did :i Monad and don't see them
14:32:05 <ciaranm> bind relies rather heavily upon certain properties of the alleged category
14:32:06 <byorgey> ninestraycats: "bind" is just the name for >>=
14:32:34 <ciaranm> join's in Control.Monad iirc
14:32:36 <byorgey> ninestraycats: join is defined in Control.Monad, but it's not a member of the Monad type class
14:32:48 <byorgey> it's defined in terms of the other Monad operations
14:32:50 <monochrom> so, if you create "data X = Y Int | Z Bool", the prover asserts: for all x::X, (exists n::Int. x = Y n) or (exists b::Bool. x = Z b). that's the basis for pattern-matching.
14:32:57 <ciaranm> you should try implementing join yourself. it's a good exercise.
14:33:05 <byorgey> though as ciaranm points out, one could also take join as primitive and define >>= in terms of it
14:33:11 <monochrom> (the prover also asserts mutual exclusion, but that is not needed for now)
14:33:12 <ciaranm> then you should try implementing bind, using join etc
14:33:31 <byorgey> ciaranm: "bind relies rather heavily upon certain properties of the alleged category" -- can you elaborate on that?
14:34:39 <ciaranm> byorgey: that it's CC, for starters
14:35:41 <byorgey> hmm, interesting
14:36:27 <ciaranm> doesn't really matter for hask, since whatever you pretend hask is is going to be cc, but if you assume it in general then the scary category theorists will get confused and upset
14:37:20 <byorgey> ciaranm: fair enough.  that's a good point, I hadn't considered it before
14:38:59 <ciaranm> another one to watch for: supposedly you can't derive <*> from a monad in an arbitrary ccc
14:40:56 <ddarius> flip (>>=) makes more sense categorically as then you can view it as a function (natural transformation) between hom-sets (hom-functors.)
14:41:39 <CodeWeaverX> brain… melty....
14:42:11 <Saizan> (=<<) aka kleisli star, no?
14:43:19 <ddarius> Saizan: Yep.
14:44:04 <mauke> >>= killed the kleisli star
14:44:53 <AfC> heh
15:08:18 <johnsingleton> is there an even remotely automated way to have the cabal dependancies for a given program I've written (modules, and version numbers) generated so that I can put them in my .cabal file?
15:13:23 <zachk> johnsingleton: leksah maybe?
15:13:29 <CodeWeaverX> Or EclipseFP.
15:13:44 <CodeWeaverX> Of course, installing an IDE to work this out is a little hardcore.
15:13:58 <johnsingleton> Exactly my thought....
15:14:06 <zachk> unless he has hardcore dependencies
15:14:13 <johnsingleton> I don't ;)
15:15:07 <johnsingleton> I'm just using like list utils, aeson and a few sundry things… But I'm like caught in this little dependency loop
15:15:42 <zzo38> Is it permitted to make a package with no library/executable?
15:16:12 <johnsingleton> well, I'm just making an executable for now
15:19:51 <zzo38> Can I use the install-includes: command in Cabal to tell it to install files in a subdirectory of $libdir/includes directory? And what happen in case there are multiple versions?
15:21:31 <eyebloom> Anyone ever had the experience where a program just outputs Main: <<loop>> (it's an OpenGL program)
15:21:49 <mauke> looks like an infinite loop
15:22:18 <eyebloom> Being detected by the runtime?
15:22:24 <luite> yeah
15:22:37 <luite> but it doesn't quite solve the halting problem ;p
15:22:37 <eyebloom> Can I get more information about it somehow?
15:23:13 <SubtleArray> Hello Haskell IRC. Quick question: How do you make a then in an if do more than one action? For example: I need for the then in my if statement to print a string and call a function.
15:23:21 <luite> eyebloom: hmm, dunno
15:23:40 <mauke> SubtleArray: the same way you'd do it without if/then
15:23:56 <jfischoff> SubtleArray: you probably have a indentation issue
15:24:12 <mauke> jfischoff: that assumes they're using layout
15:24:17 <SubtleArray> So just putting the next thing I want to do under the then should suffice if the indentation is correct?
15:24:30 <mauke> SubtleArray: do you have a 'do' in there?
15:24:46 <jfischoff> SubtleArray: probably
15:25:06 <jfischoff> mauke: yeah
15:25:35 <SubtleArray> mauke: No dos in the if.
15:25:59 <SubtleArray> I'll hpaste what I have.
15:26:13 <mauke> that is why you fail
15:27:30 <hpaste> SubtleArray pasted “If, then, and else” at http://hpaste.org/63886
15:28:18 <SubtleArray> mauke: Well damn... Adding a do did the trick. Lol
15:28:20 <ivanm> SubtleArray: you need a do in the then part
15:28:35 <SubtleArray> *smacks self on head*
15:28:47 <SubtleArray> Problem fixed. Thank yous.
15:29:13 <ivanm> or else a >>
15:31:54 <darkFLAME> a
15:45:58 <CodeWeaverX> do-block, or do-not-block.  There is no try-catch-block.
15:46:08 <byorgey> haha
15:46:21 <byorgey> @remember CodeWeaverX do-block, or do-not-block.  There is no try-catch-block.
15:46:21 <lambdabot> Nice!
15:46:37 <CodeWeaverX> :P :D
15:46:54 <byorgey> there IS in fact a do-not block
15:46:57 <byorgey> @package acme-dont
15:46:57 <lambdabot> http://hackage.haskell.org/package/acme-dont
15:47:19 <CodeWeaverX> That…. is brilliant.
15:54:55 <Aradian> if i have a ["m" , "oo" , "n" , "a" ]  (i used groupBy to do this) to group the adjacent vowels and I would like to count the first occurence of a vowel in a string such that i would get a sum of 2 in this case.
15:55:07 <zzo38> I suppose acme-dont might be useful if you need to use void in the definition of lift for a monad transformer, you can use don't instead (like how you can use liftM instead of fmap in the definition of lift for a monad transformer), but I cannot think of why you would need that
15:55:09 <Aradian> because oo - check first o and its a vowel - so add 1
15:55:41 <Aradian> and "a" - first head[x] is a vowl too so add 1
15:55:49 <Aradian> so total = 2
15:56:09 <Aradian> right now im writing so many functions that its hard to plug them to do what i want
15:57:03 <Aradian> right now i have this so far
15:57:04 <Aradian> http://hpaste.org/63887
15:59:18 <byorgey> Aradian: just use 'filter' to keep only the vowel groups and then use 'length' to count them
16:00:45 <byorgey> Aradian: don't repeat yourself in 'checkSyl', you already wrote 'isVowel', so reuse it
16:01:11 <parcs`> has anyone seen the error "Bad interface file: /home/patrick/snap/cabal-dev//lib/template-haskell-2.6.0.0/ghc-7.4.1/Language/Haskell/TH.hi" when compiling eg quickcheck?
16:01:50 <Aradian> ok
16:01:54 <Aradian> so i will try to use filter now
16:02:20 <shachaf> parcs`: Few people in this channel are named "patrick".
16:02:39 <blark> Apologies for the simple question, but I couldn't find what I'm looking for on Hoogle. Where can I find a function that takes two functions and a value, applies both to the value and puts their results in a tuple? (a -> b) -> (a -> c) -> a -> (b, c)
16:02:56 <mauke> :t (&&&)
16:02:57 <lambdabot> forall (a :: * -> * -> *) b c c'. (Arrow a) => a b c -> a b c' -> a b (c, c')
16:05:27 <blark> @mauke woohoo! thanks!
16:05:28 <lambdabot> Unknown command, try @list
16:05:43 <mauke> :t liftA2 (,)
16:05:44 <lambdabot> forall a b (f :: * -> *). (Applicative f) => f a -> f b -> f (a, b)
16:07:14 <Aradian> im trying to write this x = filter(\x -> isVowel x) groupBy (\x y -> isVowel x && isVowel y) x
16:07:21 <Aradian> but i know it does not make sense
16:07:45 <Aradian> or im not sure
16:07:46 <Aradian> hmm
16:09:00 <Aradian> ok nvm filter(\x -> isVowel x) (groupBy (\x y -> isVowel x && isVowel y) x)
16:09:02 <Aradian> it is good
16:09:08 <Botje> you're defining x in terms of itself, that's dangerous
16:09:18 <Botje> ah
16:09:23 <byorgey> no
16:09:23 <Botje> nevermind :)
16:09:37 <Botje> i focused on the x = ... part
16:09:38 <byorgey> but it is awkward using the same variable name multiple times
16:09:58 <Aradian> ok
16:10:01 <Aradian> so i should put z
16:10:02 <Aradian> there
16:10:09 <byorgey> Aradian: are you sure that works? I thought isVowel takes a Char?
16:10:14 <Aradian> yes
16:10:20 <Aradian> so it does not work
16:10:22 <byorgey> the output of groupBy is a list of lists
16:10:29 <Aradian> yes
16:10:50 <byorgey> so instead of  (\x -> isVowel x) you need a function which takes a *list* of Chars and tests whether the first one is a vowel
16:11:10 <Aradian> ok
16:11:12 <Aradian> thank you
16:11:23 <byorgey> (by the way,  (\x -> isVowel x)  is equivalent to plain old   isVowel )
16:13:15 <Aradian> cant i overload a function
16:13:23 <Aradian> so it works
16:13:27 <Aradian> for both string and char
16:13:28 <Aradian> somehow
16:13:39 <mauke> only by using typeclasses
16:13:39 <shachaf> Aradian: You sound very confused.
16:14:08 <shachaf> You might be best off reading some more of a Haskell introduction before writing this.
16:14:24 <Aradian> well im learning this stuff im a bit confused i read the introduction
16:14:40 <shachaf> "the introduction"?
16:15:43 <wagle> anyone lready know how to build a gitit on a fresh system?  which ghc?  pandoc?  which cabal commands?
16:16:58 <byorgey> wagle: are you having trouble?
16:17:43 <wagle> yeah, i'm trying different versions and finding different problems each time
16:18:11 <byorgey> looks like your best bet might be to try building it under GHC 7.0.4 (?)
16:18:28 <byorgey> but you can also try posting the error messages on hpaste and seeing if anyone has any ideas
16:18:55 <byorgey> problems with outdated dependencies are sometimes easy to solve
16:19:33 <wagle> oki..  currently wiped system clean and started over with 7.0.4 and pandoc 1.8.2.1
16:20:41 <MaskRay> a question about CPS MonadNonDet(m >>= k  = NondetT (\cons nil -> foldNondetT m (\x -> foldNondetT (k x) cons) nil)
16:20:53 <MaskRay>  sorry, the url is http://hpaste.org/63813
16:21:36 <MaskRay> How is the bind(>>=) of Monad (NondetT m) implemented?
16:23:07 <wagle> for example:     Not in scope: data constructor `OptNumberLines'
16:24:02 <MaskRay> I can imagine the definition of `newtype NondetT' ((forall b. (a -> m b -> m b) -> m b -> m b)) as taking a `fold' function and a initial generized `list' and return a new `list'
16:24:23 <derpladee> n
16:43:06 <wagle> if i have multiple versions of ghc installed, how to select which one is the default?
16:45:44 <wagle> ffrom the haskell platform, that is
16:50:15 <alpounet> wagle, well, i believe it's handled by the symlink "ghc" is pointing to
16:50:22 <zachk> ghc --version will tell you the default, i dont know of a cross platform way of swapping ghc's
16:51:08 <rudyl313> whats the performance of an index lookup in a list (i.e. the !! function)
16:51:21 <wagle> thanks
16:51:32 <zachk> O(n)
16:52:07 <hallettj1> I'm looking for an HTTP client library that  1) supports HTTPS and that will  2) let me post JSON request bodies.  Network.HTTP seems to support 2, but not 1.  And I'm having trouble working out how to do 2 with Network.Curl.  Any suggestions?
16:52:09 <rudyl313> zachk: thanks
17:02:55 <zzo38> Finally, the Hackage has the documentation generated for extensible-data package.
17:03:16 <zzo38> edwardk: Did you view it?
17:03:32 <edwardk> not yet
17:03:34 <edwardk> just got home
17:05:02 <zzo38> I do like the stuff you write about Haskell and so on. It is interest to me.
17:08:34 <zzo38> I think there might be some mistake with lambdabot
17:08:36 <zzo38> ?thank you
17:08:36 <lambdabot> Maybe you meant: thank you thanks
17:26:14 <shachaf> Can you build cabal-install with GHC 7.4 yet?
17:27:51 <zachk> dunno, but cabal works with 7.4.1
17:29:28 <shachaf> Yes, and cabal-install compiled with a previous version also works with 7.4.1.
17:40:17 <eyebloom> Why is this program allowed? main = let x = 1 + x in putStrLn (show x)
17:42:06 <latros> what do you mean allowed? why does it compile?
17:42:15 <eyebloom> I just ran it.
17:42:20 <latros> wait, it *runs*?
17:42:21 <zachk> infinite loop
17:42:26 <zachk> yes it does
17:42:27 <latros> oh, "runs"
17:42:29 <eyebloom> Loops infinitely
17:42:31 <latros> right
17:42:36 <latros> of course, it should
17:42:51 <latros> plenty of ways to make infinite loops, and because of the halting problem there's no way to get around them
17:42:52 <eyebloom> Isn't x out of scope in 1+x
17:43:06 <zachk> its allowed because you can't make a program to check if a function is infinite or not (in general)
17:43:07 <latros> because of laziness that's not actually a problem
17:43:17 <latros> for example
17:43:21 <latros> fix f = x where x = f x
17:43:45 <latros> this compiles and runs for any f, and terminates if f has non-strict semantics
17:43:56 <latros> er sorry, any f :: a->a
17:44:07 <latros> has to return the same type as its input
17:44:18 <eyebloom> I see fixed points.
17:44:24 <latros> that would be the idea, yes
17:44:34 <latros> simplest example that terminates
17:44:50 <latros> fix (const 0) = x where x = const 0 x
17:44:50 <zachk> eyebloom: main = let x = x in putStrLn (show x) seems to do the same thing
17:44:52 <latros> == 0
17:45:17 <eyebloom> zachk: I imagine it would.
17:45:22 <latros> nontrivial examples provide a model of recursion
17:45:43 <zzo38> This module says Safe-Infered but how does it infer it to be safe? It imports an unsafe module.
17:46:18 <zzo38> Oops I forgot the module:    http://hackage.haskell.org/packages/archive/extensible-data/0.1.0.4/doc/html/Data-Extensible-Product.html
17:48:31 <latros> basically comes down to whether this is safe
17:48:38 <latros> > constructorToKV :: ProdConstructor p -> (TypeRep, Any);
17:48:38 <latros> > constructorToKV (k :*= v) = (typeOf k, unsafeCoerce v);
17:48:39 <lambdabot>   <no location info>: parse error on input `;'
17:48:39 <lambdabot>   can't find file: L.hs
17:48:40 <zzo38> Do you know reason why it says it is infer to be safe even though it imports an unsafe module? I do believe the module to be trustworthy but why does it infer that?
17:49:08 <latros> I'm not sure how the compiler knows that something is safe, but it's a little bit more clever than just checking what it imports
17:49:22 <latros> that's the only place where it uses Unsafe.Coerce
17:49:55 <latros> wait nvm
17:49:59 <latros> there's at least one more
17:50:12 <latros> but, um, unsafe functions can be used safely
17:50:30 <latros> when you do IO using the IO monad, unsafePerformIO gets called, but it gets called safely
17:50:59 <latros> iirc Data.Dynamic calls unsafeCoerce but it does it safely
17:50:59 <zachk> then there is Safe Haskell which is a whole different kind of safe
17:51:00 <latros> etc.
17:51:02 <c_wraith> that's.. a misleading way to put it
17:51:08 <latros> eh yeah it is a bit misleading
17:51:17 <zzo38> I know they can be used safely. And I think I did use them safely. What I am wondering, is how it infers that. The documentation for GHC just says it infers it safe if it is allowed to compile with -XSafe.
17:51:18 <latros> but it's not really unsafe in the same way that unsafePerformIO is unsafe
17:52:09 <zzo38> This one too:  http://hackage.haskell.org/packages/archive/extensible-data/0.1.0.4/doc/html/Data-Extensible-Sum.html
17:54:18 <zachk> 800+ people wow
17:54:38 <zzo38> The other two modules in the package say "None" for the safety, probably because of Template Haskell. But, those are also safe (you should be allowed to safely import them in a -XSafe module as long as you do not use the Template Haskell stuff). Those modules do not even contain any TH splices and they are usable without Template Haskell
17:55:23 <parcs`> zachk: peaks at around 870 nowadays
17:56:01 <zzo38> If the compiler is a little bit more clever than just checking what it imports, then how does it work?
17:58:49 <rudyl313> is there a list/seq/array type in haskell that can do constant time lookups for some abitrary index?
17:59:07 <Enigmagic> :t Vector
17:59:08 <lambdabot> Not in scope: data constructor `Vector'
17:59:14 <Enigmagic> @hackage vector
17:59:14 <lambdabot> http://hackage.haskell.org/package/vector
17:59:23 <rudyl313> got it .. thanks
17:59:49 <copumpkin> there's also just the standard arrays
17:59:55 <Enigmagic> there are built-in array types but most people use vector nowadays
18:01:34 <latros> this seems to talk a bit about details of Safe
18:01:38 <latros> http://hackage.haskell.org/trac/ghc/wiki/SafeHaskell#SafetyInference
18:01:41 <latros> err
18:01:56 <latros> in particular there's a bit further down about implementation details
18:04:19 <rudyl313> Enigmagic: why not use a built in Array type? .. Why do ppl use Vector instead?
18:17:59 <iamafilthynigge> hii
18:18:52 <johnny86> hello
18:24:04 <zzo38> Are there any vectors with strict indexing?
18:32:05 <copumpkin> strict indexing?
18:32:37 <wavewave> hi
18:47:21 <wagle> building darcs under macports is dependent on ghc 6.8.x..  </whinge>
18:47:44 <latros> macports/fink/etc. are awful
18:47:49 <latros> :(
18:52:46 <mandaya> so Agda... is it's type checker powerful enough to always preclude the partial use of head? I don't know enough about the language to say for sure but I think that's undecidable in general
18:52:50 <applicative> how do I get the kind Constraint in scope? I cant remember
18:52:57 <mandaya> I have someone arguing with me about it in /r/programming
18:53:26 <irene-knapp> mandaya: the typechecker precludes it by requiring the programmer to prove that it's valid
18:53:32 <irene-knapp> the typechecker simply validates the proof
18:53:39 <irene-knapp> it does not create proofs by itself
18:53:57 <Enigmagic> applicative: import GHC.Exts
18:54:08 <shachaf> mandaya: Agda isn't Turing-complete.
18:54:08 <mandaya> irene-knapp: right, but there's always the case that a list generated at run time will have length 0 though, right?
18:54:16 <edwardk> mandaya: you can always replace it, just by making a monad for partiality
18:54:31 <mandaya> shachaf: That I didn't know
18:54:32 <edwardk> mandaya: you can make vectors with known length, etc
18:54:40 <applicative> Enigmagic: perfect, thanks
18:54:47 <wavewave> mandaya:  you should treat length 0 and length nonzero differently.
18:54:48 <irene-knapp> mandaya: if you are accepting a list generated at runtime, you cannot call head on it, because you cannot prove it to be nonzero in length, because no such proof is possible even in principle
18:55:08 <mandaya> irene-knapp: ahh, ok that makes sense
18:55:10 <irene-knapp> yes
18:55:20 <shachaf> This is similar to Haskell.
18:55:45 <wavewave> total programming is difficult, but seems rewardign.
18:55:46 <shachaf> E.g. you could say NonEmpty a = (a,[a]) and then case input of [] -> print "error!"; (x:xs) -> doSomething (x,xs)
18:55:46 <mandaya> edwardk: I understand your second point, but not your first. What do you mean by a monad for partiality?
18:56:05 <mandaya> wavewave: right, but I'm talkinga bout the general case
18:56:19 <shachaf> mandaya: In a similar way to the way that IO is done in Haskell even though it's a "pure" language, you can "do partiality" in Agda even though it's a "total" language.
18:56:31 <mandaya> ahh
18:56:43 <mandaya> it's just discouraged?
18:56:46 <edwardk> mandaya: you can work in the Maybe monad or build a little dsl for working with it
18:56:55 <wavewave> mandaya: i think we need some more experiment with total language with user experience yet.
18:57:05 <edwardk> if you need to work with something that isn't guaranteed or provably going to terminate you can make a monad like
18:57:08 <parcs`> mandaya: why are you arguing in /r/programming? :P
18:57:18 <edwardk> data Partial a = Done a | Step (Partial a)
18:57:33 <edwardk> (in agda there are little things you need to make that coinductive)
18:57:37 <mandaya> parcs`: accidentally, someone asked a legitimate question about the use of haskell
18:57:54 <edwardk> but in haskell each constructor is a time step, so you can run those computations as long as you want, and see if they've finished yet
18:57:58 <wavewave> mandaya: total programming is so difficult.. but it's so powerful, so even your compile suggest you a right completion of algorithm.
18:58:07 <edwardk> that makes your code 'productive' in terms of step constructors
18:58:32 <mandaya> wavewave: right. but how much more difficult are we talking? I've never tried to write entirely total programs
18:59:00 <mandaya> edwardk: thanks, that makes sense
18:59:01 <edwardk> mandaya: its not that bad in practice. most of the algorithms you write are within the subset of things that are easy to write in agda
18:59:39 <wavewave> mandaya: I do not know much about it, either. I sneaked some discussion about epigram development before.
19:00:00 <edwardk> you can't write code that depends on the collatz conjecture or the riemann hypothesis or the most things in math labeled conjectures, without actually just postulating them or doing hinky things like that
19:00:23 <edwardk> but how often do you do that?
19:00:33 <mandaya> edwardk: project euler :P
19:00:43 <edwardk> and if you need to you can reason about that through the partiality monad
19:00:53 <edwardk> and say things like 'if this terminates, then this other property holds'
19:01:05 <mandaya> right, so it's similar to the use of IO in haskell then
19:01:08 <edwardk> and that turns out to be a fairly powerful tool
19:01:14 <wavewave> more powerful type system means more rejection on your program. that's first more frustration. so good design for queuing developer by compiler message is very important.. and this is not yet well-studied topic.
19:01:19 <shachaf> edwardk: You write code that depends on other properties tht may not be unproved but still annoying to prove.
19:01:29 <edwardk> shachaf: sure
19:01:42 <shachaf> Though I suppose it's slightly less hinky to postulate them in that case.
19:02:05 <wavewave> even we are baffled easily with error message from template haskell.
19:02:08 <edwardk> there is still a large chunk of category theory that copumpkin's agda CT library can't prove
19:02:12 <mandaya> all very interesting, though I don't think I'm gonna make the dive into Agda quite yet :)
19:02:16 <edwardk> just because it can't finish compiling it
19:02:17 <copumpkin> edwardk :(
19:02:31 <edwardk> mandaya: there is always #agda if you decide to take it up in the future
19:02:38 <mandaya> right
19:03:56 * wagle is in cabal dependency hell..  dont follow him
19:08:14 <JoeyA> Is there a fairly standard type class for getting the "inner" value of something?  i.e. class HasInner a where inner :: a i -> i
19:08:47 <wavewave> copointer?
19:08:52 <wavewave> copointed?
19:09:43 <JoeyA> Interesting, thanks
19:10:15 <latros> if you have more going on you may in fact have a comonad
19:11:57 <Aradian> hi i would like to make this work but im unsure how: isFirstVowel :: String -> Bool
19:11:57 <Aradian> isFirstVowel x | head(x) == a where a = "aeiouyAEIOUY"  = True
19:11:57 <Aradian> 			   | otherwise = False
19:12:24 <JoeyA> Pattern matching to the rescue!
19:12:37 <latros> the head is definitely not going to be a list...
19:13:06 <latros> did you mean elem?
19:13:20 <JoeyA> isFirstVowel (x:xs) | x `elem` "AEIOUYaeiouy" = True; isFirstVowel _ = False
19:13:21 <otters> > let isFirstVowel x = elem (head x) "aeiouyAEIOUY" in isFirstVowel "eagle"
19:13:22 <lambdabot>   True
19:13:34 <JoeyA> Be sure to document that you consider Y a vowel.
19:13:52 <otters> or even better
19:13:56 <Aradian> hmm
19:13:57 <latros> that said, | x = True | otherwise = False
19:13:58 <latros> can just be
19:13:59 <latros> x
19:14:12 <otters> > let isFirstVowel = flip elem "aeiouyAEIOUY" . head in isFirstVowel "ostrich"
19:14:13 <lambdabot>   True
19:14:32 <JoeyA> latros: In the code I wrote, there's a pattern match and a |.
19:14:42 <JoeyA> > let isFirstVowel = flip elem "aeiouyAEIOUY" . head in isFirstVowel ""
19:14:44 <lambdabot>   *Exception: Prelude.head: empty list
19:14:45 <applicative> > let isFirstVowel = flip elem "aeiouyAEIOUY" . head in isFirstVowel ""
19:14:47 <lambdabot>   *Exception: Prelude.head: empty list
19:14:57 <JoeyA> Great minds think alike.
19:15:00 <applicative> JoeyA: beat me
19:15:01 <wavewave> let's do TOTAL programming
19:15:05 <latros> um
19:15:08 <latros> you still don't need the |
19:15:10 <copumpkin> wavewave: TOTALLY
19:15:29 <JoeyA> Meh, you're right.
19:15:29 <latros> isFirstVowel (x:xs) = x `elem` vowels
19:15:34 <latros> isFirstVowel [] = False
19:15:46 <copumpkin> > 5 `elem` []
19:15:47 <lambdabot>   False
19:16:25 <Aradian> so
19:16:39 <Aradian> i need to check if the first element of a certain string is a vowel :)
19:16:56 <wavewave> yes. latros' solution does that.
19:17:01 <latros> yup
19:17:11 <latros> I was too lazy to write out vowels, but you know how to do that
19:17:11 <wavewave> vowels = "aeiouyAEIOUY"
19:17:53 <Aradian> im not allowed to write a recursion function but im allowed to use any functions that i want from ghci library
19:18:04 <otters> his isn't recursive
19:18:08 <latros> it's not recursive, yeah
19:18:11 <JoeyA> Aradian: You're not allowed to use pattern-matching, you mean?
19:18:12 <Aradian> x:xs
19:18:18 <latros> that's not recursive
19:18:19 <Aradian> yea
19:18:21 <Aradian> its not
19:18:22 <Aradian> im dumb
19:18:46 <wavewave> hmmm. why not allowed..
19:18:49 <JoeyA> (`elem` vowels) . head works for non-empty strings.
19:19:23 <JoeyA> If only there was a way to test if a string is empty without using pattern matching.
19:19:52 <jaredj> null?
19:20:03 <otters> > null []
19:20:03 <lambdabot>   True
19:20:09 <jaredj> > null ""
19:20:09 <lambdabot>   True
19:20:28 <latros> if you can't pattern match you can use null, though in effect you're using pattern matching anyway
19:20:30 <latros> and it's more verbose
19:20:34 <Aradian> that was easy so this function isFirstVowel(x:xs) = x `elem` "aeiouyAEIOUY" will return fals
19:20:50 <otters> you don't need the () when calling functions
19:20:54 <latros> you need the space, too
19:21:39 <latros> the () is not there because of the function call, it's there because of the pattern match on :
19:22:14 <latros> eh, rather because of the pattern match in general
19:22:33 <latros> anyway, yes
19:23:48 <Aradian> thanks d
19:23:49 <Aradian> :d
19:26:16 <wagle> hi.. never used darcs before (git expert though).. if a repo has version 6.6.3 of happstack-server current, how do I extract version 6.5.*?  (#darcs is dead)
19:26:39 <wavewave> darcs get --tag=6.5 ?
19:27:09 <Enigmagic> darcs-fastexport and convert to git? :P
19:27:22 <applicative> >  let f = (||) <$> null <*> (`elem` "aeiouAEIOU") . head in f ""> let f = (||) <$> null <*> (`elem` "aeiouAEIOU") . head in
19:27:23 <lambdabot>   <no location info>: parse error (possibly incorrect indentation)
19:27:34 <applicative> >  let f = (||) <$> null <*> (`elem` "aeiouAEIOU") . head in f ""
19:27:36 <lambdabot>   True
19:27:41 <wagle> its got several things in it, each with different versions
19:27:54 <wagle> Enigmagic: good point..  8)
19:28:23 <Enigmagic> wagle: http://hackage.haskell.org/package/darcs-fastconvert
19:29:30 <wagle> currently trying to unscramble cabal...
19:29:34 <sm> hi dreixel.. how is shelltestrunner failing you for large output ?
19:33:01 <wavewave> wagle : didn't my answer satisfy your situation?
19:33:04 * hackagebot husk-scheme 3.5.3 - R5RS Scheme interpreter, compiler, and library.  http://hackage.haskell.org/package/husk-scheme-3.5.3 (JustinEthier)
19:34:04 <wagle> wavewave: i think i'm looking for 20120216173513-8e95d-64e232197e8404601a9b8e6857e1da47fde5a418
19:35:10 <wavewave> wagle : use --to-match
19:35:34 <wagle> wavewave: ok
19:36:04 <jaredj> i'm trying to arrange some balls on a plane where the balls are quantized to integer coordinates but i want them to be as equally spaced as possible
19:36:22 <jaredj> my first intuition is to start with a random arrangement and iteratively improve it
19:36:31 <jaredj> am i failing to think functionally?
19:36:45 <sm> jaredj: fly first class ?
19:37:03 <jaredj> *golf clap*
19:37:15 <sm> 8%]
19:37:26 <sm> strange humour over here at this hour... carry on
19:37:31 <jaredj> what is on your head?!
19:37:34 <colah> I need to reference a type variable used in the type expression describing the instance I'm declaring in an express in its declaration (to specify the type of something) but GHC doens't seem to realize I'm refering to the same type.
19:37:37 <dmwit_> zzo38: By the way, I favor letting \ introduce a block rather than this bulky "case of" syntax.
19:37:39 <colah> instance (OpenscadTypeMirror a) => OpenscadTypeMirror [a] where
19:37:41 <colah> 	forceObj (OList list) =
19:37:44 <colah> 		let
19:37:46 <colah> 			maybeAList = map (\obj -> forceObj obj :: Maybe a) list
19:38:32 <dmwit> zzo38: The only thing that you would need to be wary of is that it would break the "many lines of >>= \x ->" pattern.
19:38:34 <Enigmagic> colah: {-# LANGUAGE ScopedTypeVariables #-} and add a 'forall a.' to the instance line
19:41:04 <colah> Enigmagic: Thanks! I'm really accumulating a list of type extentions :P
19:41:24 * colah now has {-# LANGUAGE MultiParamTypeClasses, FunctionalDependencies, FlexibleInstances, FlexibleContexts, TypeSynonymInstances, UndecidableInstances, ScopedTypeVariables  #-} at the top of this file.
19:41:25 <Enigmagic> colah: that means you're writing real haskell ;)
19:41:33 <colah> Oh, very good :)
19:41:54 <shachaf> The farther from Haskell 98 your language is, the realer a Haskell it is.
19:41:54 <latros> oh jeez UndecidableInstances
19:42:21 <latros> that make the type system turing complete doesn't it >.>
19:42:42 <colah> Yeah, I really wante to do without that one, but some functional dep stuff wouldn't work without it.
19:42:58 <latros> incidentally, iirc everything fundeps can do type families can do
19:43:07 <latros> in a way that doesn't use relational semantics
19:43:45 <colah> I beleive that the line that pushed it over was instance (Additive a b c) => Additive (d -> a) (d -> b) (d -> c) where
19:43:48 <dmwit> colah: Of those, only UndecidableInstances is really controversial in any way.
19:44:22 <dmwit> colah: That should be decidable.
19:44:42 <colah> Hm... I've been interested in compiling to JS lately. Will these extensions make that impossible?
19:44:43 <dmwit> The instance context is definitely smaller than the instance head.
19:45:10 <Saizan> dmwit: UndecidableInstances also lifts fundep coverage checking
19:45:14 <dmwit> ah
19:45:32 <jaredj> (sm, that's all i really had)
19:45:32 <colah> Yeah, I spent several hours trying to make it work and someone told me that the funcdep stuff still has issues in some edge cases.
19:45:44 <Saizan> which means you have to check that those fundeps hold yourself
19:45:47 <latros> what are you doing anyway
19:45:49 <latros> just out of curiosity
19:46:02 <colah> ImplicitCAD: https://github.com/colah/ImplicitCAD
19:46:18 <colah> That was more convenience.
19:46:37 <colah> It's in Graphics.Implicit.SaneOperators
19:47:04 <zzo38> dmwit: It is why, \ should not introduce a block. Maybe "\ of" could be used instead of "case of" though.
19:47:53 <colah> schachaf: Can I tweet you about being farther from Haskell 98 being real haskell? :)
19:50:02 <latros> lol
19:50:10 <latros> -- | Make ALL the functions Showable!
19:50:10 <latros> -- This is very handy when testing functions in interactive mode...
19:50:10 <latros> instance Show (a -> b) where
19:50:10 <latros> show f = "<function>"
19:50:17 <latros> that's one way to do it
19:51:51 <colah> I was sick and tired of making complicated objects that contained a function and then not being able to inspect the rest of it easily :)
19:55:40 <latros> well here's one place you might've needed UndecidableInstances at one point
19:55:48 <latros> when you wanted to do instance Num a => Foo a
19:55:58 <latros> for your various classes
19:57:30 <latros> if you'd kept UndecidableInstances around that should've worked, however
19:57:31 <latros> for example
19:57:47 <sm> jaredj: sorry, you lost me. But how's things, did you ever hack more on your ofx lib ?
19:58:05 <hpaste> latros pasted “classtest” at http://hpaste.org/63891
19:58:06 <jaredj> dangit i knew you were going to ask that
19:58:11 <jaredj> it's next on the list
19:58:18 <latros> @ colah
19:58:22 <colah> latros: Ah, forgot about those. I guess I could add them back in :)
19:58:37 <jaredj> this balls-on-a-plane thing was supposed to be a half-hour project
19:59:00 <jaredj> i still need the ofx lib
19:59:09 <jaredj> and no one else has constructed it, that i know of
20:00:09 <jaredj> i think the last place i got was that it could be fun to try to construct a haskell record from the dtd
20:00:16 <jaredj> but that would require parsing an sgml dtd
20:06:43 <geekosaur> ok, someone over in #xmonad just broke my brain.  "newtype Invisible m a = I (m a)" --- meaning a parameter to the newtype is of kind (* -> *).  this is legal?
20:06:54 <sm> jaredj: heh
20:06:54 <dmwit> yes
20:07:04 <geekosaur> I kinda had the feeling type parameters had to be fully saturated (ie, kind *)
20:07:17 <latros> why would that be
20:07:18 <dmwit> No.
20:07:23 <dmwit> Only type synonyms must be fully saturated.
20:07:29 <sm> jaredj: I wonder if wonderful new xml libs have appeared to make it more pleasant
20:07:38 <latros> also this is necessary to do monad transformers
20:08:13 <dmwit> latros: Well, "data" would suffice if newtype had such a restriction.
20:08:40 <latros> I thought he wasn't being specific to newtype
20:08:47 <latros> that was an assumption, though, could've been wrong
20:09:09 <colah> So, I'm implementing an interpreter for Openscad. Openscad objects have a type OpenscadObj. I can try to convert them into Haskell objects of a type a with fromOObj :: OpenscadObj -> Maybe a. I need to implement "modules" which behave differently depending on the input type, so I have to test if it is a bunch of openscad object types. Any thoughts on a way to do this?
20:09:47 <geekosaur> I was being specific to newtype there, in fact.  and I do see the point about monad transformers, so now I'm trying to figure out why it feels wrong
20:10:01 <latros> um, are you sure that OpenescadObj isn't really more a typeclass then?
20:10:11 <latros> er
20:10:13 <latros> type constructor
20:10:14 <latros> rather
20:10:20 <colah> I want to do something like case fromOObj foo of (Just 1) -> .. (Just "abc"), and so on.
20:10:28 <latros> "if it is a bunch of openescad types"
20:10:34 <latros> means that there are more than one of those
20:10:50 <colah> Well, I could do it by the type constructors, and that's what I'm doing right now, but I want to make it more elegant.
20:11:08 <latros> what's inelegant about what you're doing now?
20:11:28 <colah> See: https://github.com/colah/ImplicitCAD/blob/master/Graphics/Implicit/ExtOpenScad/Primitives.hs
20:11:42 <sm> night all
20:11:52 <latros> uh
20:11:56 <colah> I was able to use my ArgParser monad to keep a lot of situtations clean, but I need to do a lot of things like polygon, and they're ugly.
20:12:04 <latros> you never use liftM
20:12:08 <latros> just saying
20:12:13 <colah> Why?
20:12:20 <latros> s/use/used
20:12:59 <colah> Oh. Oops.
20:13:05 * colah is deleting.
20:13:15 <latros> that said fmap should be in the prelude anyway
20:13:29 <latros> but class hierarchies *shrug*
20:14:05 <latros> anyway, is the structure of OpenescadObj fixed?
20:14:12 <latros> like, in some external lib
20:14:27 <colah> Nope.
20:14:38 <colah> https://github.com/colah/ImplicitCAD/blob/master/Graphics/Implicit/ExtOpenScad/Definitions.hs
20:14:49 <hpaste> SubtleArray pasted “Is there a way to break from a function that is calling itself?” at http://hpaste.org/63892
20:15:14 <latros> well, you could do it at the level of type constructors instead of data constructors
20:15:28 <cmccann> geekosaur, note that stuff like "newtype Action m = Action (m ())" is also legal
20:15:29 <latros> I'm not sure what exactly is inelegant about what you're doing now, though
20:15:42 <colah> You mean like data OpenscadObj a = ...?
20:15:47 <latros> yeah
20:16:15 <cmccann> stuff like "newtype Foo = Foo Int" is also legal
20:16:18 <latros> there's good reason not to do that, though, I think
20:16:23 <jaredj> sm, ofx 1.x is sgml not xml, that's what the whole fiasco is about
20:16:31 <SubtleArray> Hi everyone. Was just wondering. Can a break be used to break from a function that's calling itself?
20:16:40 <colah> Yeah. I'm mimicking a language without any sane idea of types.
20:16:46 <colah> :(
20:16:49 <cmccann> geekosaur, newtype only requires a single value; the quantity and kind of type parameters are completely separate
20:17:02 <latros> I more meant that things like your Show instance would break horribly
20:17:09 <colah> Oh, that to.
20:17:25 <latros> what specifically would you like to be different?
20:17:34 <latros> because I'm still not really seeing problems
20:17:48 <colah> I may be obssesing over making it elegant.
20:18:02 <latros> but do you have a specific example that you think is ugly?
20:18:15 <colah> cube, polygon.
20:18:30 <colah> Anywhere I have to explicitly deal with Openscad nonsense.
20:18:37 <SubtleArray> colah: I fall into the same kind of traps when programming. Lol. Obsessing over elegance. We have to fight that. Focus on making it work first, then make it look pretty later. :D
20:19:00 <colah> Stuff like this: OList ((ONum x):(ONum y):(ONum z):[]) ->
20:19:21 <latros> the Onum one can be shortened
20:19:22 <latros> a lot
20:19:24 <latros> *ONum
20:19:40 <latros> well, rather it could if you were doing this with a helper function
20:20:12 <colah> Go on?
20:20:19 <latros> I'm writing a little
20:20:34 <colah> I'm presently implementing my fromOObj thing.
20:20:52 <colah> Which I'm hoping I can use to solve this.
20:21:35 <Aradian> how do u deny a boolean in haskell
20:21:42 <Aradian> !function_bool ?
20:22:02 <colah> SubtleArray: Good to know other people have the same problem. :) It mostly works... But now I need to add user defined modules and I decided to refactor.
20:22:12 <latros> not True = False
20:22:16 <latros> not False = True
20:22:37 <colah> Also, there is a practical reason. I need the code base, especially this section, to be accessible other people (read: non-Haskellers).
20:26:17 <Aradian> ok i successfully checked now syllables from words with vowels, but I have to check for words without vowels in them and count them as well, I am trying to get the countSyl_wordsContainNoVowels to work just wondering if you guys could suggest a simple algorithm that will do the trick http://hpaste.org/63893
20:27:18 <hpaste> latros pasted “cubehandler” at http://hpaste.org/63894
20:27:26 <latros> @ colah
20:27:27 <latros> ^
20:28:41 <applicative> Aradian: what is the definition of countSyl
20:29:12 <colah> latros: That's a bit nicer... But I'd really like to avoid dealing with OpenscadObj's all together.
20:29:29 <latros> by doing what
20:29:49 <colah> First can I confirm that one can't do something like : case foo :: (forall a. a) of 1 -> ... "ac" -> ... ?
20:30:24 <latros> there's only one (forall a. a) >.>
20:30:35 <colah> :P
20:31:04 <Aradian> groups adjacents vowels together and splits everyhing else, then im checking the list if the first element of the every string in that list is a vowel if yes i filter them out, and i get the length of the list
20:31:15 <colah> Wait, I need to figure out what the right way of phraising my type is :)
20:31:29 <latros> yeah, I don't know what exactly you want it to do differently
20:31:44 <colah> So, I have class OTypeMirror a where fromOObj :: OpenscadObj -> Maybe a
20:32:12 <colah> If it can't become the type I want, I get a nothing.
20:32:28 <colah> I feel like there should be an elegant way to use that to make my codes pretty.
20:32:37 <latros> I'm not sure if you're mixing up types and data constructors or not
20:32:39 <applicative> Aradian: I see
20:32:43 <colah> But so far the best I can come up with would be something like:
20:32:53 <Aradian> i need to do now when i have a list with "moom adrian padre bb cc adrian" so that it counts the bb and cc as 1  + 1 syllables too
20:33:18 <Aradian> so "cxdfdfdsgbfsdfs" = 1
20:33:23 <Aradian> one syllable
20:33:33 <Aradian> and i was wondering how to approach that
20:33:42 <colah> if fromOObj foo :: Float /= Nothing then (\(Just a) -> ...) (fromOObj foo :: Float) else ...
20:33:48 <colah> Which I don't consider to be elegant.
20:33:55 <latros> you won't be able to do that anyway
20:34:03 <colah> But if I could do something patter matchy.
20:34:05 <colah> ?
20:34:21 <latros> you've got a type equation in there
20:34:21 <colah> Oh, oops.
20:34:40 <colah> if (fromOObj foo :: Maybe Float) /= Nothing then (\(Just a) -> ...) (fromOObj foo :: Float) else ...
20:34:47 <kniu> I cobbled together a type checker and I have no idea whether it's correct.
20:35:13 <latros> hm
20:35:33 <colah> I just need a better way to put it syntactically.
20:35:46 <kniu> every typechecking tutorial I came across treats functions as things that only take a single argument
20:35:55 <colah> Preferably one were I don't have to use (fromOObj foo :: Maybe Float) twice.
20:35:57 <kniu> is there any material that explains how to typecheck patterns?
20:36:11 <latros> you'd do that in a helper, colah?
20:36:13 <latros> *.
20:36:18 <latros> (seriously, helpers are great)
20:36:27 <colah> helpers?
20:36:42 <latros> local functions
20:36:51 <colah> Oh, yeah.
20:37:26 <latros> seems like what you really want is a type function
20:37:41 <latros> potentially
20:37:52 <colah> type function?
20:38:11 <latros> eh no, nvm, that's not appropriate here
20:38:12 <latros> hm
20:38:40 * colah may be looking for an elegant solution that doesn't exist.
20:39:24 <latros> in short your situation is
20:39:24 <kniu> colah, what is it exactly that you're trying to do?
20:39:31 <latros> "if I get a Float, do ...; if I don't, do ..."
20:39:33 <latros> yes?
20:39:59 <latros> and this situation is not because of what you have implemented, but central to the application?
20:40:15 <colah> Well, "if I can turn it into a float, do... else, if I can turn it into..."
20:40:25 <colah> Yes.
20:41:08 <colah> The absolute ideal would be something like a case.
20:41:09 <latros> I think the most natural way to handle that is to carry things around in data constructors
20:41:34 <latros> that's somewhat ugly but it works
20:42:18 <Aradian> i have genericLength $ filter isVowel x a isVowel is isVowel :: Char -> Bool and I would just like to say genericLength $ filter not IsVowel.... im trying it and it does not work
20:42:26 <rwbarton> use pattern matching (case) rather than "if (fromOObj foo :: Maybe Float) /= Nothing then (\(Just a) -> ...) (fromOObj foo :: Float) else ..."
20:42:37 <latros> you need filter (not . isVowel)
20:43:11 <Aradian> thank you
20:43:12 <colah> A case is excatly what I want to use -- it would be perfect -- but I don't think it will work with my case weirdness.
20:43:26 <colah> I guess I should actually test that, shouldn't I? :)
20:43:30 <latros> I think it does but unfortunately forces you to have a LOT of data constructors
20:43:43 <rwbarton> case fromOObj foo :: Maybe Float of Just a -> ...; Nothing -> ...
20:44:07 <latros> you can also use maybe
20:44:09 <latros> (lowercase)
20:44:26 <latros> @src maybe
20:44:26 <lambdabot> maybe n _ Nothing  = n
20:44:27 <lambdabot> maybe _ f (Just x) = f x
20:44:39 <latros> does the same thing but looks prettier
20:45:35 <colah> Ideal is case fromOObj foo of Just a :: Maybe Float -> ...; Just b :: [(Float,Float)] -> ...
20:46:00 <latros> uh
20:46:06 <latros> that doesn't actually make sense
20:46:09 <latros> without a lot of polymorphism
20:46:15 <latros> not even sure it makes sense then
20:46:37 <latros> fromOObj doesn't have a gajillion return types
20:46:57 <colah> fromOObj does though :)
20:47:02 <latros> what
20:47:28 <colah> Thanks to  {{ instance forall a. (Eq a, OTypeMirror a) => OTypeMirror [a] }} it has infinitly many :)
20:47:59 <colah> Countably ifinitly many. I think I get to uncountables with my tuple dec via isomorphism with binary reals :)
20:48:36 <latros> wait a minute, where's the class declaration of OTypeMirror again?
20:49:15 <latros> I'm trying to give a type signature to things
20:49:21 <latros> specifically to things like this:
20:49:25 <latros> case fromOObj foo of Just a :: Maybe Float -> ...; Just b :: [(Float,Float)] -> ...
20:49:34 <rwbarton> class OTypeMirror a where fromOObj :: OpenscadObj -> Maybe a
20:49:37 <rwbarton> from above
20:50:19 <cmccann> woo, full hackage index runs on my EC2 micro instance
20:50:27 <cmccann> tomorrow I should get mirroring going
20:50:28 <hpaste> “Chris Olah” pasted “OTypeMirror” at http://hpaste.org/63895
20:50:31 <latros> yeah, that means that you don't have a gajillion return types once the instance declaration that you are working with is determined
20:50:35 <cmccann> and maybe some actual tarballs
20:51:14 <latros> actually...can it be determined?
20:51:21 <colah> Not sure I follow. In my test, ghc seems to just choose one type and run with it?
20:51:34 <colah> Which isn't the behaviour I want :(
20:51:59 <latros> I'm confused as to how the system will figure out what type fromOObj someobj has
20:52:30 <latros> because notice that it can't infer which instance declaration of OTypeMirror you are talking about
20:52:32 <rwbarton> btw your construction in lines 39-41 is just called "sequence"
20:52:33 <latros> from the input
20:52:38 <colah> Well, normally one would force it with (:: FooType)
20:53:03 <colah> But I'd like to have it get forced into types every entry in the case statement if that was possible.
20:53:05 <latros> right but that's not safe, and you can't do it like pattern matching
20:53:27 <colah> :(
20:53:45 <rwbarton> I mean, you are setting yourself up for this pain by not simply pattern matching on the constructor
20:53:48 <latros> yeah
20:54:02 <latros> having a function that maps from concrete types to polymorphic types, as a rule
20:54:07 <latros> is a Very Bad Thing
20:54:16 <latros> well
20:54:18 <latros> sorry
20:54:22 <latros> it's not actually polymorphic
20:54:28 <colah> How is it not safe? Can't the type checker just make sure every line has an appropriate type instance?
20:54:31 <latros> but...you can't infer which Maybe a you're talking about
20:54:38 <latros> without a type signature
20:54:51 <latros> because the instance declaration that you need for that given OpenescadObj
20:54:51 <colah> Right, but I'm giving a type signature on each pattern.
20:55:01 <latros> yeah, and that's ITSELF really really bad
20:55:23 <rwbarton> your fictional "case fromOObj foo of Just a :: Maybe Float -> ...; Just b :: [(Float,Float)] -> ..." is nonsense because you are really examining a DIFFERENT fromOObj foo in each branch
20:55:25 <latros> you would prefer to do things at data constructor level
20:55:31 <rwbarton> case is for pattern matching on a single value
20:55:48 <latros> right
20:56:05 <latros> the output from fromOObj has one type, in each case
20:56:14 <latros> you can't pattern match against it having different typse
20:56:15 <latros> *types
20:56:43 <latros> so...yeah, keep everything at constructor level and it should be pretty painless?
20:56:56 <colah> I was really hoping there would be a way to make that work :( It would've made this super pretty.
20:57:07 <rwbarton> you can always cook up some combinators for your specific use case
20:57:13 <latros> type signatures in patterns are not pretty :/
20:57:24 * colah pouts in a corner.
20:57:56 <colah> OK.
20:58:21 <rwbarton> get over it and just write or :: OTypeMirror a => (a -> b) -> (OpenscadObj -> Maybe b) -> (OpenscadObj -> Maybe b)
20:58:41 <rwbarton> you can do that once
20:58:54 <latros> isn't that a functor instance >.>
20:59:02 <rwbarton> and then your case expression is (\a -> ...) `or` (\b -> ...) `or` (const Nothing)
20:59:07 <rwbarton> except don't call it "or"
20:59:20 <latros> that is definitely a functor instance, and probably satisfies the functor laws
20:59:33 <latros> so call it fmap, why not
20:59:36 <colah> Ooh... shiney.
20:59:37 <rwbarton> it's basically just mplus but massaged to fit this use case better
20:59:58 <dmwit> :t fmap . fmap :: (a -> b) -> (e -> Maybe a) -> (e -> Maybe b)
20:59:59 <lambdabot> forall a b e. (a -> b) -> (e -> Maybe a) -> e -> Maybe b
21:00:08 <rwbarton> that's not what I wrote
21:00:17 <dmwit> Oh, so it's not.
21:00:40 <rwbarton> I meant    or f g x = fmap f (fromOObj x) `mplus` g x
21:01:04 <dmwit> I guess I'm missing some context about OTypeMirror.
21:01:13 <rwbarton> basically Dynamic
21:01:14 <dmwit> Perhaps I shouldn't try to say something intelligent without reading my scrollback. =P
21:01:22 <latros> wait nvm
21:01:27 <latros> they're both b
21:01:30 <latros> after the a->b
21:01:35 <latros> not a standard functor then
21:01:50 <latros> OTypeMirror a => (a -> b) -> (OpenscadObj -> Maybe a) -> (OpenscadObj -> Maybe b)
21:01:58 <latros> would be an fmap signature
21:02:08 <rwbarton> or I guess OTypeMirror is like Typeable and OpenscadObj is like Dynamic
21:02:33 <latros> actually
21:02:36 <latros> how would you declare that
21:02:44 <latros> instance Functor ??? where fmap = ...
21:02:46 <latros> what's the ???
21:02:50 <latros> eh
21:02:51 <latros> sorry
21:02:59 <latros> instance OTypeMirror a => Functor ??? where fmap = ...
21:03:19 <latros> I'm trying to say (\b -> (OpenescadObj -> Maybe b))
21:03:21 <latros> is a functor
21:03:27 <latros> how do you do that syntactically
21:03:36 <rwbarton> you can't because it's not a type constructor, also the constraint would get in the way, also it's irrelevant :P
21:03:49 <latros> sure it's a type constructor
21:03:52 <rwbarton> nope
21:03:55 <latros> it's an anonymous type constructor
21:03:58 <rwbarton> nope
21:04:00 <latros> what
21:04:07 <rwbarton> it's maybe like a "type function" or something
21:04:15 <latros> (\b -> (OpenescadObj -> Maybe b)) is definitely a type constructor, even if the haskell syntax doesn't like it
21:04:16 <rwbarton> but it is definitely not a Type Constructor
21:04:20 <latros> ah
21:04:23 <latros> not like that, no
21:04:37 <dmwit> latros: You would have to create a newtype Foo b = Foo (OpenescadObj -> Maybe b)
21:04:39 <latros> yeah
21:04:42 <latros> I was about to say that
21:04:50 <dmwit> (Because type-level lambdas mess type inference up pretty hard.)
21:05:02 <latros> ah
21:05:03 <latros> gotcha
21:05:09 <cmccann> dmwit, it'd be like type-level n+k patterns
21:05:13 <cmccann> imagine what kind of fun that would be
21:05:15 <rwbarton> they would make instance selection impossible, which would pretty much defeat the purpose :)
21:05:16 <dmwit> (...and possibly also type-checking?)
21:05:34 <latros> still irrelevant, as you said
21:05:42 <latros> a vs. b makes a big difference :p
21:07:15 <Qiqi> hey guys, first-timer here (never used IRC before too). not sure if I can interrupt, but i have a question that's confusing me
21:07:43 <Qiqi> why does fmap (*0) (+1) 0 gives 0 instead of 1?
21:07:49 <rwbarton> maybe this is clearer/more direct:
21:08:12 <rwbarton> or :: OTypeMirror a => (a -> c) -> (OpenscadObj -> c) -> (OpenscadObj -> c)
21:08:16 <latros> um
21:08:20 <latros> *0 gets applied second
21:08:24 <Qiqi> I think of +1 as the container that wraps around 0, and *0 is a function that applies within the box.
21:08:27 <rwbarton> or f g x = case fromOObj x of Just a -> f a; Nothing -> g x
21:08:36 <Qiqi> so it should be 0*0+1=1
21:08:41 <latros> you have it reversed
21:08:52 <cmccann> Qiqi, the "container" analogy is somewhat misleading anyway
21:08:59 <edwardk> fmap (*0) (+1) 0     = (*0) . (+1) $ 0 =   (*0) $ (+1) $ 0 = (*0) $ 0 + 1  = (*0) $ 1 = 1 * 0 = 0
21:09:02 <dmwit> Qiqi: Your first sentence was correct, but your conclusion wasn't.
21:09:02 <latros> (+1) is *already* a container, but the value is the return value
21:09:16 <dmwit> Qiqi: If *0 is the function that applies within the box, the result is (*0) (0+1)
21:09:22 <latros> so when you "extract the value", you get (+1 0) = 1
21:09:33 <dmwit> Qiqi: = (0+1) * 0 = 0 ;-)
21:09:36 <latros> then you "apply the pure function to the value" and get (*0) 1 = 0
21:09:45 <latros> err
21:09:50 <latros> s/(+1 0)/(+1) 0
21:10:07 <rwbarton> > (+1 0)
21:10:08 <lambdabot>   Overlapping instances for GHC.Show.Show (a -> a)
21:10:08 <lambdabot>    arising from a use of `...
21:10:19 <latros> don't be a smartass >.>
21:10:22 <Qiqi> thanks, but let me think for a while...
21:10:23 <rwbarton> quick lambdabot quiz, what is this
21:10:44 <dmwit> rwbarton: It's a function that adds 1 applied to 0.
21:10:50 <dmwit> Functions can't be shown, done.
21:10:53 <dmwit> What do I win?
21:11:07 <dmwit> > (+1 0) 3 == 4
21:11:08 <lambdabot>   True
21:11:11 <cmccann> edwardk, btw, I got the full hackage index loaded on my EC2 instance :P kinda hilarious actually.
21:11:30 <latros> wait a minute what
21:11:34 <latros> oh nvm
21:11:38 <latros> wait...not nvm
21:11:44 <edwardk> fmap :: (a -> b) -> f a -> f b    -- here f = "Int ->"   so you get (a -> b) -> (e -> a) -> (e -> b)  -- which is to say that the second function happens first
21:11:58 <edwardk> cmccann: how big is it?
21:12:08 <cmccann> the instance? or hackage?
21:12:14 <edwardk> yes
21:12:19 <cmccann> :D
21:12:22 <cmccann> it's a micro instance
21:12:22 <latros> how does (+1 0) group, with explicit parens
21:12:36 <latros> in such a way that you end up with a function instead of a number
21:12:39 <ion> > (+1 0) :: Expr
21:12:40 <lambdabot>   The section `GHC.Num.+ 1 0' takes one argument,
21:12:41 <lambdabot>  but its type `SimpleReflec...
21:12:51 <ion> > (+f y) :: Expr
21:12:52 <lambdabot>   The section `GHC.Num.+
21:12:53 <lambdabot>               SimpleReflect.f SimpleReflect.y' takes...
21:12:53 <cmccann> currently it's cost me $0.10, for disk IO because of hackage swapping like mad
21:13:01 <latros> oh
21:13:05 <latros> that's not standard GHC
21:13:09 <latros> that's some madness in lambdabot
21:13:10 <latros> ok
21:13:12 <latros> fair enough
21:13:33 <ion> > (+f a) b :: Expr
21:13:34 <lambdabot>   b + f a
21:13:38 <cmccann> edwardk, hackage itself is currently eating about 1.5GB of ram, most of which is swapped out
21:14:03 <dmwit> latros: It groups as (+ (1 0)), that is, a section of the (+) function with (1 0) as its right-hand argument.
21:14:06 <cmccann> given that the VM only has like 600MB of RAM and all
21:14:13 <edwardk> *nods*
21:14:20 <cmccann> cf. http://hackage2.uptoisomorphism.net/packages/
21:14:22 <colah> OK. Thanks to everyone who gave feedback :) I will be using "or" as <||> in honor of Parsec :)
21:14:23 <dmwit> latros: The fact that 1 0 typechecks is because of a cute instance of Num for functions.
21:14:27 <latros> yea
21:14:28 <latros> h
21:14:32 <latros> that's what I meant
21:14:42 <cmccann> it's a little slow at times but surprisingly not horrific
21:15:11 <dmwit> This looks just like Hackage!
21:15:14 <cmccann> tomorrow I'm gonna try and get it stocked with actual tarballs and maybe figure out how to run the build stuff as well
21:15:27 <cmccann> dmwit, it's just a cheap plastic imitation hackage
21:15:34 <dmwit> Oh, what, tags!
21:15:48 <Qiqi> an even more fundamental question that I have is: why is (*1) a functor? it's a function to me. but it doesn't seem to convert a concrete type into another concrete type
21:15:53 <cmccann> dmwit, well yes, it's the hackage2 code base :P
21:16:14 <cmccann> dmwit, got revdeps and whatnot too
21:16:17 <dmwit> This idempotent "on hackage" link looks a bit odd.
21:16:23 <dmwit> How to revdeps??
21:16:33 <cmccann> look at an individual package's page
21:16:43 <ion> http://hackage2.uptoisomorphism.net/package/semigroupoids/reverse
21:16:43 <copumpkin> Qiqi: it isn't a functor
21:16:56 <dmwit> Oh, I was just looking at one that didn't have any revdeps, I guess.
21:16:59 <copumpkin> Qiqi: the functor is something like (Int -> _)
21:17:06 <copumpkin> also known as (->) Int
21:17:20 <cmccann> also, the "on hackage" link isn't idempotent I think
21:17:32 <cmccann> it should send you to the "same" page on the real hackage
21:17:49 <cmccann> but check out something like http://hackage2.uptoisomorphism.net/package/mtl
21:17:57 <cmccann> plenty of revdeps there
21:18:00 <edwardk> qiqi: instance Functor ((->) e) where fmap = (.)
21:18:15 <dmwit> cmccann: Oh, so the "on hackage" link isn't going to be on the official Hackage, then?
21:18:24 <cmccann> I would assume not
21:18:30 <dmwit> That makes more sense, then.
21:18:48 <Qiqi> so (+1) is an instance of the functor Int->_  ?
21:18:53 <cmccann> the introduction page probably won't say "This isn't the official HackageDB." either
21:18:54 <cmccann> :P
21:19:06 <copumpkin> Qiqi: yeah, it instantiated the _ to (for example) Int
21:19:15 <edwardk> fmap :: Functor f => (a -> b) -> f a -> f b  -- when f == (->) e  that becomes fmap :: Functor f => (a -> b) -> (->) e a -> (->) e b  -- which is fmap :: Functor f => (a -> b) -> (e -> a) -> e -> b  -- when you read it more normally
21:19:27 <edwardk> :t (+1)
21:19:28 <lambdabot> forall a. (Num a) => a -> a
21:19:41 <edwardk> if we ignore the Num noise thats basically Int -> Int
21:19:49 <ion> @type fmap `asTypeIn` \fmap -> fmap undefined (undefined :: a -> b)
21:19:49 <lambdabot> forall a b a1. (a -> b) -> (a1 -> a) -> a1 -> b
21:20:39 <DanBurton> :t fmap `asAppliedTo` (undefined :: a -> b)
21:20:40 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
21:20:54 <edwardk> :t fmap Just Just
21:20:55 <lambdabot> forall a. a -> Maybe (Maybe a)
21:21:25 <Qiqi> so ghci is very helpful in telling us about types and kinds. I wonder if there is any tool that can give a more detailed picture, which reveals the underlying type inference procedure for example?
21:21:27 <DanBurton> fmap (+1) (+1)
21:21:33 <DanBurton> :t fmap (+1) (+1)
21:21:34 <lambdabot> forall a. (Num a) => a -> a
21:22:07 <cmccann> dmwit, anyway, once I get tarballs added tomorrow you'll be able to use it as a substitute hackage if you want
21:22:19 <edwardk> Qiqi: not really. you'll gradually get better at seeing how these things line up in your head
21:22:25 <cmccann> albeit a slightly out of date one until I set the mirroring up as well
21:22:41 <edwardk> Qiqi: i guess agda is pretty good at showing off that sort of thing through the holes and editor support
21:23:37 <ion> Couldn’t holes be added to Haskell?
21:23:44 <Qiqi> thanks, i'll look into it.
21:23:53 <cmccann> ion, see the "ghc-goals" project
21:23:57 <cmccann> lying around on github somewhere
21:24:01 <ion> cmccann: Thanks
21:24:09 <cmccann> not really complete though
21:24:23 * cmccann got it running at one point and it had some problems
21:28:35 <glguy> You can simulate holes a bit with implicit parameters
21:28:56 <cmccann> glguy, I was surprised how well that actually works
21:29:33 * cmccann has developed the habit of sticking an implicit parameter applied to everything relevant in as a "hole"
21:29:52 <cmccann> then I get a nice error message telling me what type I need and the types of all the pieces I might expect to use
21:30:58 <cmccann> makes it convenient to sorta run djinn in my head to put it together
21:34:26 <ion> Oh, i hadn’t thought of using implicit parameters like that. That’s a good idea.
21:34:36 * cmccann stole the idea from edwardk
21:34:42 <hpaste> DanBurton pasted “Fortran as transformations...help with call and q?” at http://hpaste.org/63896
21:34:58 <edwardk> and i stole it from copumpkin
21:35:29 <copumpkin> oh man, who did I steal it from?
21:35:38 <latros> sorry, can you give an example of that?
21:35:40 <latros> this implicit parameter idea
21:35:42 <latros> that is
21:35:44 <DanBurton> copumpkin: steve jobs?
21:35:48 <copumpkin> probably
21:35:50 <cmccann> copumpkin, you could retroactively steal it from ion
21:35:53 <glguy> :t ?x ?y
21:35:54 <lambdabot> forall t t1. (?y::t, ?x::t -> t1) => t1
21:35:57 <cmccann> tie the knot and all
21:36:10 <DanBurton> timey wimey
21:36:20 <glguy> :t map ?f [0..9]
21:36:21 <lambdabot> forall a b. (?f::a -> b, Num a, Enum a) => [b]
21:36:43 <cmccann> DanBurton, oh, you might be interested that I slimmed hackage2 down enough to make it (barely) run on an EC2 micro instance
21:36:59 <DanBurton> cmccann: nice
21:37:10 <cmccann> the main value of that being cheap experimental public hackage clones
21:37:30 <cmccann> startup and shutdown times are horrific though
21:37:43 <DanBurton> define "horrific"
21:37:46 <DanBurton> hours?
21:37:48 <cmccann> yes
21:37:55 <DanBurton> o_O
21:38:03 <cmccann> I think it took ~90min to start
21:38:11 <cmccann> I expect shutting down to take much longer
21:38:16 <ion> > putStrLn ?hole
21:38:17 <lambdabot>   mueval-core: internal error: PAP object entered!
21:38:17 <lambdabot>      (GHC version 6.12.3 f...
21:38:22 <cmccann> wow
21:38:30 <ion> λ> putStrLn ?hole
21:38:32 <ion>     Unbound implicit parameter (?hole::String)
21:38:32 <colah> If I want to get a string for a haskell type, like (:t in ghci), is there an easy way to do that?
21:38:32 <cmccann> I don't think that's supposed to happen
21:38:55 <DanBurton> lambdabot is on ghc 6.12?
21:39:15 <DanBurton> that's so...old
21:40:02 <DanBurton> colah: a string for a haskell type...why exactly would you want that?
21:40:22 <DanBurton> > typeOf (undefined :: Int)
21:40:22 <lambdabot>   Int
21:40:32 <DanBurton> :t typeOf
21:40:33 <lambdabot> forall a. (Typeable a) => a -> TypeRep
21:40:43 <DanBurton> :t show (undefined :: TypeRep)
21:40:44 <lambdabot> String
21:41:17 <colah> Because I'm going to hijack it for creating documentation for modules in an embedded language I need to interpret for backwards compatibility with OpenSCAD.
21:41:21 <colah> :P
21:41:27 <colah> Thanks! :)
21:41:28 <zzo38> edwardk: O, you are on now? Did you look at my file now?
21:41:29 <DanBurton> colah: anyways, using typeOf will get you a TypeRep, and you can show from there
21:41:45 <glguy> for things that are Typeable*
21:41:58 <edwardk> zzo38: been describing geometric coalgebra in -blah =/
21:42:08 <DanBurton> right. and you can derive Typeable automatically for your own data types
21:42:08 <colah> That suffices. I only need to do it for some very boring types :)
21:42:11 <zzo38> edwardk: What does that mean?
21:42:24 <DanBurton> using DeriveDataTypeable iinm
21:42:30 <edwardk> lots of stuff i've been working on in my algebra package basically
21:43:00 <cmccann> it's like geometric algebra, only more confusing
21:43:30 <cmccann> (actually the coalgebra stuff is really neat even if took me forever to begin to understand how it worked)
21:43:38 <edwardk> or less, depending on if you have my warped perspective
21:43:43 <edwardk> its also faster
21:43:58 <edwardk> I like saving O(2^n) when n can be infinity
21:44:04 <cmccann> yes
21:44:27 <Qiqi> thanks guys. i think I understand the fmap (*0) (+1) 0 question now. a curious question is, can we think of (+1) as an instantiation of (<-) r (instead of ->) which seems to be a functor too, so that fmap (*0) (+1) 0 = 1
21:44:53 <cmccann> Qiqi, think about the type signatures there
21:45:01 <cmccann> and whether that would work as a Functor instance
21:45:58 <Qiqi> anything that turns a concrete type into a concrete type can be a functor right?
21:46:05 <zzo38> Do you know for what purpose Data.Typeable and that stuff was designed for? Not necessarily for what I have used it for
21:46:10 <ion> What’s (<-) r?
21:47:10 <Qiqi> i made this up. maybe it's wrong syntax.  let x be an input type, then output type is x->r. this is what i meant by (<-) r
21:48:12 <latros> you mean this
21:48:54 <latros> newtype Right r x = Right (x->r)
21:48:55 <Qiqi> if lambda works for type variables, then \x -> (x->r)
21:48:59 <latros> it doesn't
21:49:19 <latros> regardless, the arguments to + have the same type
21:49:39 <latros> so...yeah
21:49:46 <latros> @type (+)
21:49:46 <lambdabot> forall a. (Num a) => a -> a -> a
21:50:00 <latros> once you've specified the type of 1, (+1) has a concrete type
21:50:00 <DanBurton> or if you don't mind turning on -XTypeOperators, newtype r :<- x = Fun (x -> r)
21:50:44 <rwbarton> even if \x -> (x->r) was the sort of thing that could be an instance of a class (it isn't), it wouldn't be an instance of Functor
21:50:47 <mzero> BayHac '12 plans are up!  Join us: http://www.haskell.org/haskellwiki/BayHac2012
21:51:28 <Qiqi> latros: is Right something special?
21:51:32 <latros> nope
21:51:36 <latros> just a name
21:51:39 <latros> and a wrapper
21:51:46 <latros> you can't do it with lambdas for technical reasons
21:52:17 <zzo38> It is a functor from (->) to the dual category of (->) or in other words it is a contravarant functor.
21:52:29 <latros> anyway, instance Functor (Right r) where fmap (Right f) (Right g) = Right $ g . f
21:52:31 <latros> I suspect
21:52:55 <DanBurton> ((:<-) a) can't be a functor, because there is no way to combine (x -> r) and (x -> y) to get (y -> r)
21:53:09 <latros> err...what
21:53:17 <DanBurton> "a functor" meaning the Haskell Functor typeclass
21:53:27 <rwbarton> right
21:53:29 <DanBurton> fmap :: (x -> y) -> f x -> f y
21:53:34 <latros> oh, sorry
21:53:39 <Qiqi> oh, newtype is basically data here. (i'm such a beginner)
21:53:46 <zzo38> DanBurton: It is for endofunctors on (->)
21:54:03 <latros> ah, yes, right
21:54:05 <latros> valid point
21:54:19 <zzo38> What you called Right or (:<-) is the dual category of (->)
21:54:32 <latros> but a contravariant functor is not a haskell functor
21:54:33 <zzo38> So, it can be an instance of Category.
21:54:38 <latros> haskell functors are assumed covariant
21:54:43 <latros> yes?
21:54:48 <zzo38> latros: OK. Yes.
21:54:54 <latros> I should say Functors
21:55:27 <zzo38> Yes; the Functor class is only for endofunctors on (->) like I mentioned
21:55:27 <latros> class Contr f where cfmap :: (a->b)->f b->f a
21:55:42 <latros> that works, I take it
21:55:45 <zzo38> Yes that is the contravariant functors on (->)
21:55:48 <latros> gotcha
21:56:23 <latros> though
21:56:26 <Qiqi> for someone like me who just got a feeling on functor, reading what you guys just wrote makes about to cry... i guess i'll save the conservation for future read...
21:56:32 <latros> the category you're talking about is all of Hask
21:56:49 <latros> since the arrows of Hask are (->)
21:57:14 <zzo38> Yes.
21:57:38 <latros> basically, qiqi, haskell functors "preserve direction", that is they turn (a->b)'s into (f a->f b)'s
21:57:42 <latros> this is called being covariant
21:58:00 <latros> there are things mathematically called functors that "reverse direction", that is they turn (a->b)'s into (f b->f a)'s
21:58:09 <latros> this is called being contravariant
21:58:38 <latros> our little back and forth was because I and at least one other didn't catch that haskell functors are assumed covariant
21:58:56 <wavewave> cmccann : hi, did you get back well?
21:59:18 <Qiqi> thanks for trying to explain. i'm gonna learn category theory eventually and get back to this..
22:01:08 <zzo38> No, the reason is that the Haskell Functor class is only endofunctors (on (->)). Endofunctors is functors from a category to itself. Contravariant can go to dual categories like:   (a -> b) -> (f a :<- f b)   it is still a functor, but to a different category.
22:01:50 <latros> gah
22:01:51 <latros> I meant
22:01:53 <latros> haskell Functors
22:02:43 <latros> incidentally, the contravariant functors on Hask are still endofunctors
22:02:58 <latros> wait
22:03:00 <latros> no
22:03:01 <latros> sorry
22:03:16 <latros> not all functions are invertible
22:03:18 <latros> etc.
22:03:20 <latros> sorry
22:03:21 <latros> carry on
22:05:11 <hpaste> DanBurton pasted “Category instance of :<-” at http://hpaste.org/63897
22:05:51 <latros> uh
22:05:53 <latros> F $ g . f
22:05:54 <latros> is clearer
22:05:55 <latros> :p
22:05:56 <tomodo> what's the point of that??
22:06:22 <latros> not much; it's basically just showing that contravariant functors are functors
22:06:23 <DanBurton> fun
22:06:29 <latros> also that
22:09:03 <Qiqi> is there any good video on category theory + haskell online?
22:09:09 <haskellnoob> Hi. I have the Haskell Platform installed, and I am able to import and use the Parsec library (Text.ParserCombinators.Parsec) in my programs. But I the documentation for this library  is not present in the local html files which hold the documentation for other Haskell libraries which are present on my system.  How do I install the documentation for the Parsec library so that I can access it locally?
22:09:17 <Qiqi> or I better learn from books
22:09:33 <DanBurton> edwardk: have you considered adding the Category instance to the "Op" type in the "contravariant" package?
22:09:40 <mzero> haskellnoob: which OS are you on?
22:09:50 <haskellnoob> mzero: Mac OS
22:10:11 <nlogax> Qiqi: i don't know about video but was recommended this http://www.cs.nott.ac.uk/~gmh/cat.html
22:10:13 <mzero> if you installed Haskell Platform, then docs should be there
22:10:28 <edwardk> DanBurton: its missing?
22:10:36 <edwardk> i'll add it
22:10:41 <haskellnoob> I can see some related docs, for packages named Text.ParserCombinators.Poly.*
22:10:45 <mzero> haskellnoob:   file://localhost/Library/Haskell/doc/packages/parsec-3.1.1/doc/html/Text-Parsec.html
22:11:04 <mzero> (assuming latest Haskell Platform)
22:11:05 <haskellnoob> mzero: Let me try that, thanks
22:11:18 <DanBurton> edwardk: it doesn't show up on hackage as having that instance
22:11:32 <mzero> or better: file://localhost/Library/Haskell/doc/packages/parsec-3.1.1/doc/html/frames.html
22:12:01 <Qiqi> thanks nlogax. even though it's handwritten, it looks really nice
22:12:04 <ion> What protocol does file://something-else/… use in OSX?
22:12:16 <haskellnoob> the …./parsec-3.1.1/doc directory is present, but its *only* contents are a LICENSE file
22:12:48 <mzero> ion: beats me
22:12:58 <haskellnoob> ion: I just type it into the browser url window and it works (if this is what you asked)
22:12:58 <edwardk> DanBurton: i must have forgotten
22:13:35 <haskellnoob> is it possible to install just the documentation for Parsec using cabal or something similar?
22:13:41 <mzero> not really
22:14:01 <mzero> but I'm a little surprised that it isn't all there - was this a recent Haskell Platform install?
22:14:01 <zzo38> DanBurton: Yes I agree with you they should add that.
22:14:08 <zzo38> edwardk: Yes you should
22:14:16 <haskellnoob> mzero: After November 1, 2011
22:14:32 <mzero> haskellnoob: you should be able to go to file://localhost/Library/Haskell/doc/frames.html and get all the lib doc that came with the system
22:14:51 <haskellnoob> let me try that
22:15:01 <ion> I have “documentation: True” in ~/.cabal/config, but if you don’t have documentation, you’d probably need to reinstall everything with cabal (in the dependency order) to get working interpackage links etc.
22:15:02 <mzero> and the Text.Parsec link should work
22:15:40 <mzero> ion - HP ships with pre-built haddocks w/inter-links (mostly) - and Parsec should be there
22:15:59 <edwardk> DanBurton: added
22:16:00 <mzero> I'm the maintainer of the Mac HP installer, so if is broken .... it's my bad!  :-(
22:16:26 <ion> ok
22:17:16 <haskellnoob> mzero: I thank you for the installer. In the last place you mentioned, the only related things present are : Text.ParserCombinators.ReadP, and Text.ParserCombinators.ReadPrec
22:17:17 <mzero> on mac, at least, if you started with HP, then once you cabal install something else, you get a local doc tree as well - including everything on your system --- that is at     file:///Users/<your acct here>/Library/Haskell/doc/frames.html
22:18:21 <mzero> haskellnoob: those are from the base package, not the parsec package
22:18:36 <mzero> did you manually install anything after installing HP?
22:18:42 <mzero> or use ghc-pkg in someway?
22:19:16 <haskellnoob> mzero: I did manually install a few things after installing HP. that ~/Library/.. is the place where I usually look for documentation, and Parsec is not there either
22:19:50 <mzero> well, wait - are you poking around the file system directly, or looking via the URLs in a browser?
22:19:57 <haskellnoob> but Data.Attoparsec.* is there in the ~/Library/.. place, and so also TextJSON.Parsec
22:20:00 <haskellnoob> browser
22:22:00 <mzero> okay... you should first of all, bookmark  file:///Users/xxxx/Library/Haskell/doc/frames.html   -- replacing xxxx with your login account short name
22:22:14 <mzero> that will be the start of a doc tree that is rebuilt every time you cabal install a package
22:22:29 <mzero> (assuming you are using the default cabal config file that HP for Mac installs for you)
22:23:02 <haskellnoob> mzero: I had bookmarked file …./index.html , but now I will change it to .../frames.html
22:23:04 * hackagebot contravariant 0.2 - Haskell 98 contravariant functors  http://hackage.haskell.org/package/contravariant-0.2 (EdwardKmett)
22:23:30 <mzero> but even that tree, will have links to the Parsec docs which reside up and over in :    /Library/Haskell/ghc-7.0.4/lib/parsec-3.1.1/doc/html    (that is a file path to look via Finder or shell, not in the browser)
22:23:42 <edwardk> DanBurton: i haven't chased down all the dependent packages though, there are lots of them that use contravariant, which i didn't bump to use that major version =/
22:23:55 <mzero> haskellnoob: index.html or frames.html --- it's just a matter of personal preference
22:24:19 <haskellnoob> mzero: ok, then i will keep the index.html. let me look at the file path you mentioned
22:25:02 <mzero> the HP installer puts the docs for Parsec there --- and looking at my installer master disk image - they're there
22:25:24 <mzero> (which isn't to say that it didn't malfunction on your set up... it very well might have)
22:25:34 <haskellnoob> hmm.. i have ghc-7.0.3 instead
22:25:57 <mzero> then you do not have HP 2011.4.0.0 installed methinks
22:26:34 <mzero> do you have /Library/Haskell/bin/uninstall-hs   ?
22:26:54 <mzero> (it is safe to run - it won't uninstall anything unless you add very explicit switches)
22:28:08 <haskellnoob> no. and the downloaded installer for HP which I have on disk is ..2011-2.01
22:28:28 <haskellnoob> 2.0.1
22:28:29 <mzero> ah...
22:28:37 <haskellnoob> that explains it?
22:28:42 <mzero> I don't remember what the state of Parsec was in that version --- or it's doc
22:29:19 <haskellnoob> ok. let me remember/check why i installed this version instead of the more current one, even though i did the install in November
22:29:34 <mzero> assuming you have documentation: True in your .cabal/config file --- perhaps the easiest thing to do is
22:29:50 <mzero> just reinstall Parsec via    cabal install parsec-3.1.1 --reinstall
22:30:40 <mzero> or parsec-3.1.2 I guess
22:30:42 <mzero> or just
22:30:47 <haskellnoob> mzero: it is also cheaper wrt the bandwidth. thank you!
22:30:50 <mzero> cabal update
22:30:59 <mzero> then cabal install parsec --reinstall
22:31:07 <haskellnoob> thanks, let me try that
22:31:09 <mzero> you may then end up with two versions of parsec installed
22:31:33 <mzero> and you may have to / want to   hide the older one via ghc-pkg hide
22:31:47 <haskellnoob> that is very helpful.
22:32:04 <mzero> N.P.
22:32:48 <haskellnoob> i will probably want to install the more recent HP once I am back at work and the bandwidth is not a problem. i do not have the uninstall-hs file. what would be a good way of upgrading?
22:33:46 <Sgeo> "There is no way to do this in a non Lisp language."
22:33:58 <Sgeo> (Referring to making a with-file macro in Common Lisp)
22:33:59 <Sgeo> Herp derp
22:34:06 <Sgeo> http://pschombe.wordpress.com/2006/04/07/convincing-programmers-they-want-to-use-lisp/
22:36:28 <haskellnoob> mzero: good news! I just did cabal install parsec (without —reinstall) and it installed the 3.1.2 and the documentation. thanks a lot!
22:37:32 <mzero> haskellnoob: you can just go ahead and install HP 2011.4.0.0  --- then if you need to clean up disk space (~1Gig!) you can run the uninstaller-hs  -- it will list what it finds on your system, and give you instructions for how to selectively uninstall versions
22:38:24 <haskellnoob> mzero: thank you, this was very helpful. back to writing myself a scheme in a couple of weeks, now
22:38:27 <mzero> note: if you have not hand modified your .cabal/config file --- I suggest deleting it just before installing HP 2011.4.0.0 --
22:38:37 <mzero> it will install a better one the first time you run cabal
22:38:52 <haskellnoob> ok. i will move it somewhere else first and then install the latest HP
22:38:59 <mzero> welcome, haskellnoob, enjoy!
22:44:35 <Mango_Man> hey guys, any recommendations for a haskell-aware text editor?
22:44:46 <Mango_Man> i still use nano
22:45:10 <mzero> OS platform?
22:45:13 <Mango_Man> ubuntu
22:45:22 <SubtleArray> Mango_Man: A lot of people recommend emacs or vim with plugin. I'm a big fan of Leksah personally.
22:45:23 <mzero> have you tried Leksah?
22:45:41 <Mango_Man> not sure what that is, googling
22:45:46 <mzero> full Haskell IDE - but mostly a very Haskell aware editor w/auto complete
22:46:01 <Mango_Man> oooh this is nice
22:46:07 <mzero> and built in support for building via cabal and
22:46:12 <mzero> get 0.11 version
22:46:17 <mzero> not the 0.10 on the download page
22:46:44 <Mango_Man> any recs for non-haskell programming?
22:46:53 <Mango_Man> like, should i learn vim or emacs?
22:47:01 <SubtleArray> I think it's available in the repos.
22:47:06 <SubtleArray> sudo apt-get install leksah
22:47:18 <mzero> vim or emacs? you tryin' to start a war here?
22:47:28 <zzo38> Mango_Man: I happen to like vi when working on UNIX, but different people like different thing just please use what *you* prefer.
22:47:31 <Mango_Man> lol
22:48:46 <SubtleArray> *cough* vim *cough*
22:49:03 <zzo38> I would like to know how they got the idea to add the instance for TypeRep to the hashable package? I noticed they added it *after* I used TypeRep as a key in a HashMap (it was initially a private instance using newtype; but I fixed and reuploaded my package). So I do like they added that but am curious what gave them that idea. Has anyone else used TypeRep as a key in anything?
22:50:00 <shachaf> mzero: Hooray!
22:50:08 <mzero> dates!
22:50:09 <mzero> woot!
22:50:44 <shachaf> mike-burns: BayHac will be Apr 20-22, if you're still thinking of going.
22:51:03 <shachaf> Oh, that's old news in the channel, it looks like.
22:51:31 <mzero> I pasted it earlier, but no one commented
22:52:19 <SubtleArray> Peoples of the IRC. I have a question. >_< I'm trying to create a list variable that collects input. In Python I did this by appending to a list, and in C++ I inserted into vector. Is there a way to do something similar in Haskell?
22:52:42 <SubtleArray> append xs ys = foldr (:) ys xs
22:52:45 <DanBurton> SubtleArray: sounds like a fold
22:53:08 * hackagebot ghc-pkg-autofix 0.2.0.1 - Simple utility to fix BROKEN package dependencies for cabal-install.  http://hackage.haskell.org/package/ghc-pkg-autofix-0.2.0.1 (HiromiIshii)
22:53:16 <SubtleArray> I found that on Wikipedia, but I'm not sure how to apply that to 1 list variable.
22:53:19 <DanBurton> SubtleArray: what do you mean "a list variable that collects input" exactly?
22:53:20 <SubtleArray> If that makes any sense...
22:54:18 <SubtleArray> I have a variable called 'combined' that I'd like to use to store all the keywords used during a session. This is needed for my natural language processing program.
22:54:29 <mzero> SubtleArray: what is producing the input that is to be collected? Human typing? a file? a computation?
22:54:39 <SubtleArray> mzero: Human typing.
22:54:48 <DanBurton> "during a session" hrm...
22:55:02 <SubtleArray> DanBurton: Chat session.
22:55:31 <SubtleArray> Basically, I want this thing to answer follow up questions. Lol. But that can't happen if it doesn't know the keywords from the last interaction.
22:55:43 <mzero> how are you representing the state of the session? in a state monad of some sort, or are you expressly passing around a data record of the state as you iterate?
22:55:45 <DanBurton> in what form is this data presented to your Haskell program? Is the Haskell program in charge of actually serving the chat session, or are you reading log files?
22:57:14 <SubtleArray> mzero: I'm passing around the record in variables. The user's input first goes into a variable called input1, it's parsed, a reply is given. And the next user input is put into a variable called input2, parsed, etc.
22:57:44 <SubtleArray> DanBurton: Everything is done internally. No logs.
22:58:20 <ChristianS> SubtleArray: why not insert each new keyword into a Set (and passing that Set around)?
22:58:20 <SubtleArray> I hope I'm explaining this right... My English sucks.
22:58:31 <DanBurton> right, so like mzero hinted at, you'll want to keep state throughout the session somehow
22:58:45 <mzero> so in that record, you have another field, combined --- the question is what data structure do you want? a list of a keywords... use [String], do you need a map from keywords to use?   try Map String String    or perhaps Map String Int
22:58:45 <DanBurton> SubtleArray: your English is very clear so far :)
22:58:49 <SubtleArray> ChristianS: A set? -looks that up-
22:59:11 <ChristianS> SubtleArray: HashSet (from unordered-containers package) may be best
22:59:14 <juhp> is there a library better than "cautious-file"?
22:59:29 <juhp> it doesn't seem so popular
22:59:38 <DanBurton> @hackage unordered-containers
22:59:38 <lambdabot> http://hackage.haskell.org/package/unordered-containers
22:59:58 <mzero> each of these data structures has a different method of adding --- BUT, they all share the same pattern: You don't really add it to the data structure, you "insert" it which really gives you a NEW data structure, like the original, with the datum added
23:00:23 <mzero> then you create a new state record, using that new structure --- and pass that along to the next part of your program
23:00:26 <juhp> yi uses cautious file for a single function in one place...
23:00:28 <SubtleArray> mzero: Do I need a map of keywords to use? Not currently. The keywords and pattern matching are mostly done. I just need to get this thing to remember context.
23:00:32 <juhp> cautious-file
23:00:45 <mzero> so, just a set of keywords that have been seen
23:00:47 <mzero> ?
23:01:03 <SubtleArray> mzero: And a way to do this, I think, would be to append the input to a list so when the program checks to see what has been said, the keywords would be there.
23:01:20 <mzero> Data.Set is what you want
23:01:35 <mzero> or perhaps Data.HashSet if you anticipate 1000s of keywords
23:02:07 <SubtleArray> DanBurton: Looking at unordered-containers now.
23:02:19 <mzero> you could use a list, but that will get very slow very quickly
23:02:54 <SubtleArray> mzero: Are state records related to unordered containers?
23:03:01 <mzero> now
23:03:02 <mzero> no
23:03:19 <dreixel> sm: hi! it isn't "failing", it just doesn't quite work the way I expected it, because it shows everything, and not just what's different
23:03:36 <SubtleArray> Looking up Data.HaskSet
23:03:41 <SubtleArray> *Hash
23:03:44 <mzero> you will presumably have something like     data ChatState = ChatState { lastInput :: String, keywordsSeen :: Set String }
23:03:51 <mzero> perhaps other fields in there
23:04:21 <ChristianS> SubtleArray: unordered-containers are pure (immutable), not stateful. every insert will actually create a new data structure, as mzero already explained.
23:04:29 <mzero> then ChatState values are what you pass around:      doSomeChatting :: ChatState -> IO ChatState
23:04:42 <mzero> but don't get hung up about that
23:04:52 <mzero> get used to doing that - that is the Haskell way
23:05:00 <SubtleArray> B-)
23:05:19 <SubtleArray> Awesome. Thanks a lot guys. Looking through the info now.
23:05:29 <mzero> don't jump to something that lets you do mutable data via IO --- unless performance testing really shows you need it
23:06:09 <ChristianS> SubtleArray: though Set/HashSet are pure, inserting into them is pretty fast and lookup is very fast (much faster than in lists where haskell has to traverse the entire list)
23:06:33 <DanBurton> guys don't flood him with too much info :)
23:06:45 <SubtleArray> *gets flooded* :D
23:06:53 <mzero> that way you can keep the bulk of your program out of the IO monad.... you should functions like:    extractAndAddKeywords :: String -> ChatState -> ChatState
23:08:05 <SubtleArray> Wait, so...
23:08:45 <SubtleArray> Hasksets are immutable, yes?
23:08:50 <SubtleArray> Hash
23:08:58 <aadrake> Good morning all.  I have a bit of a problem.  I wrote the simplest of JSON parsers in Haskell and Ruby as a comparison, and the Ruby version is far faster.  Can you reccommend some improvements to the Haskell version? https://gist.github.com/1858163
23:09:09 <mzero> yes
23:09:48 <aadrake> The Haskell version parses about 3000 records per second, and the Ruby version parses approximately 4600 records per second.
23:10:17 <SubtleArray> mzero: I remember reading somewhere (probably here) that it wasn't a good idea to put too much in IO, so I try to put any kind of "reusable" task into a separate function.
23:10:29 <mzero> good
23:10:40 <MostAwesomeDude> aadrake: Why not use the pre-existing JSON parsing libraries available in both languages?
23:10:52 <SubtleArray> I use a similar approach with C++. My main functions are usually very small.
23:10:54 <mzero> aadrake: how are you running that Haskell code? in ghci? via runHaskell?
23:10:55 <juhp> MostAwesomeDude, actually he is...
23:11:06 <aadrake> MostAwesomeDude: I did.  I used Aeson in Haskell and the JSON gem in Ruby.
23:11:14 <aadrake> mzero: I compiled it with -O2
23:11:43 <MostAwesomeDude> Ah, that's what I get for not clicking the link.
23:11:49 <DanBurton> aadrake: hrm, I'm not much of an expert, but I don't think C8 is the best ByteString type to use
23:12:13 <mzero> one change, aadrake:   make line 8      mapM_ (print . parse json) (C.lines allRecords)
23:12:20 <juhp> aadrake, so "I wrote the simplest of JSON parsers" is a little misleading :)
23:12:37 <aadrake> Yes, I misspoke.  I didn't write the actual parsers, I used the standard parser libraries in each language
23:12:49 <mzero> you were parsing all the JSON, assembling it into one giant list, and converting that list to a string at the end
23:12:58 <mzero> the Ruby version you wrote printed and parsed one by one
23:13:08 <aadrake> mzero: Good call
23:13:43 <DanBurton> aside - why is it that you have one JSON value per line? seems kinda odd to have JSON delimited by \n
23:14:00 <mzero> looks like test data to me! ;_0
23:14:37 <aadrake> DanBurton: very large files with one record per line :)
23:15:22 <aadrake> mzero: That provided about a 25% speedup, and it's now faster than the Ruby version by about 170 records per second.
23:15:32 <mzero> there ya go
23:15:37 <mzero> apples to apples to
23:15:39 <mzero> though I wonder
23:15:47 <mzero> is the Haskell version pretty printed, while the ruby not?
23:15:48 <juhp> aadrake, any better? :)
23:16:16 <aadrake> juhp: Yes, much better.
23:17:09 <aadrake> mzero: Neither is pretty printed.
23:17:19 <juhp> :)  I would expect aeson to be considerably faster than ruby
23:17:31 <aadrake> juhp: I did too, which is why I'm surprised that they are comparable
23:17:35 <mzero> I see that now -
23:18:12 <DanBurton> I wonder if using ByteString.Lazy would be better
23:18:28 <DanBurton> and ByteString.Lazy.Split '\n'
23:18:45 <mzero> how big is this data file?
23:18:52 <ChristianS> well, the json parser used by ruby is probably written in c, so i'm not surprised its pretty fast
23:19:34 <mzero> and hence we are delighted that the pure Haskell one is faster!
23:19:35 <mzero> :-)
23:19:37 <mzero> night all
23:19:37 <DanBurton> *lowercase split
23:19:48 <DanBurton> mzero: night
23:19:51 <ChristianS> DanBurton: ByteString.Lazy.split '\n -> that's what Char8.lines is doing anyway, so it wouldn't make a difference
23:20:13 <ChristianS> but it's certainly worth trying whether the .Lazy variant of both ByteString imports is faster.
23:20:46 <DanBurton> ChristianS: I was under the impression that Char8 was undesirable for some reason
23:21:14 <DanBurton> not really sure why
23:21:26 <ChristianS> DanBurton: it is in general since it's not utf8-aware
23:21:47 <ChristianS> but that doesn't matter for things such as line splitting since newlines are the same in ASCII and UTF-8
23:21:54 <aadrake> Sorry everyone, my machine died
23:22:09 <aadrake> The last thing I saw was someone mentioning using ByteString.Lazy and splitting on \n
23:23:02 <DanBurton> aadrake: RIP your machine
23:23:16 <ChristianS> aadrake: try appending .Lazy to both ByteString imports and check whether that makes a difference
23:23:18 <aadrake> DanBurton: Indeed.
23:23:33 <DanBurton> aadrake: what ChristianS said ^
23:24:40 <DanBurton> if nothing else, the lazy file read should be able to reduce the memory used by your program
23:27:11 <aadrake> ChristianS: I get a type error when trying to compile. Couldn't match 'Data.ByteString.Internal.ByteString' with actual type 'C.ByteString'
23:27:30 <aadrake> Coming from C.lines
23:28:45 <DanBurton> If C.lines gives you trouble, you can just use " split '\n' " (split from Data.ByteString.Lazy, or wherever)
23:29:34 <DanBurton> you changed both imports to use .Lazy right?
23:30:02 <aadrake> DanBurton: Correct.  Data.ByteString.Lazy as BS and Data.ByteString.Lazy.Char8 as C
23:30:21 <DanBurton> yeah that being a type error doesn't make much sense =/
23:30:22 <ChristianS> aadrake: hm, that's strange, they should play together
23:31:10 <ChristianS> but it don't know whether aeson can handle lazy bytestrings, maybe that's the problem?
23:31:13 <aadrake> DanBurton: using BS.split causes the same type error
23:31:25 <aadrake> ChristianS: Perhaps
23:32:43 <DanBurton> in any event I should get to bed. If any of yall need to kill some time, kindly code review my pet library https://github.com/DanBurton/netspec and/or answer this question http://stackoverflow.com/q/9339585/208257
23:33:56 <aadrake> DanBurton: Thanks for the help
23:34:00 <ChristianS> aadrake: does the parse function come from Attoparsec? try replacing Data.Attoparsec by Data.Attoparsec.Lazy.
23:34:46 <aadrake> ChristianS: Correct assesment, it was the parse function from Attopasec.
23:35:01 <Enigmagic> aadrake: curious of an enumerator based solution is faster or not.. https://gist.github.com/1858260
23:37:41 <aadrake> Enigmagic: No, it's a fair bit slower.  The Lazy version runs in about 8.45 seconds and the version from your gist is about 9.9 seconds.
23:38:12 <aadrake> I think you helped me with a csv-enumerator problem or a mongodb problem at one time though, so thanks again for that :)
23:38:36 <ChristianS> aadrake: the Lazy version is slower than the strict one?
23:38:58 <Enigmagic> aadrake: np :^)
23:39:04 <aadrake> ChristianS: No, the Enumerator version is slower than the Lazy version
23:39:19 <aadrake> The Lazy version is slightly faster than the non-lazy one
23:39:38 <ChristianS> ah, cool -- especially since it should also save a lot of memory
23:40:11 <aadrake> That's good, because the actual file I want to use this on is 160GB :)
23:41:00 <Enigmagic> you'll probably want to use (parse json') instead of (parse json) then
23:41:06 <ChristianS> uh, trying to read that one into memory strictly (all at once) wouldn't be a good idea!
23:41:29 <aadrake> ChristianS: Indeed
23:42:42 <aadrake> I also have a C parser I'm benchmarking these against and it is processing around 13,500 records per second
23:42:57 <aadrake> It's has many more lines of code though :)
23:44:18 <Enigmagic> i suspect it'll be difficult to beat that in haskell
23:44:45 <aadrake> Enigmagic: If I can get close then that's good enough
23:45:01 <aadrake> Enigmagic: Actually, something significantly better than the speed of Ruby would be good
23:45:05 <Enigmagic> is it a generic json parser or one very specific to your file?
23:45:24 <Enigmagic> (the C version)
23:46:01 <aadrake> Enigmagic: The C version is actuall a tool that dumps JSON to CSV.  You specify the keys and it strips the values from the JSON.
23:46:14 <aadrake> Enigmagic: So it's very general
23:46:37 <ChristianS> aadrake: i sometimes use the following function to read a whole file lazily but convert each line into a strict bytestring before processing it further:
23:46:41 <aadrake> Enigmagic: I found some problems with the way it handles certain characters and escapes strings, so it's not working as intended, but it's not my tool so I'd have to discuss with the author.
23:46:42 <ChristianS> strictLines = map (B.concat . LazyB.toChunks) . LazyB.lines -- B is Data.ByteString, LazyB is Data.ByteString.Lazy.Char8
23:47:15 <ChristianS> aadrake: you could try that (instead of B.lines) with the strict version from Attoparsec, possible it would help further
23:48:32 <aadrake> ChristianS: But then I would have to use the strict versions of ByteString and ByteString.Char8, right?
23:48:52 <aadrake> ChristianS: Because of the strict/lazy conflict with Attoparsec?
23:49:56 <ChristianS> aadrake: import qualified Data.ByteString as B; import qualified Data.ByteString.Lazy.Char8 as LazyB
23:50:26 <aadrake> Ah
23:51:12 <cadabra> I'm using a library that implements Show to pretty print all its types. Is there any way I can print them the way a deriving Show would?
23:51:17 <ChristianS> no, because small strict bytestrings are often faster (especially if use them as keys in Sets of something), while reading a whole file strictly is ugly and sometimes (as in your case) impossible
23:52:17 <tempodox> bye
23:52:21 <tempodox> end
23:52:27 <tempodox> quit
23:52:30 <tempodox> exit
23:52:30 <Enigmagic> try kicking it
23:52:39 <tempodox> kick
23:52:49 <Enigmagic> perhaps the X in the corner would do the trick
23:52:56 <tempodox> :-)
23:52:56 <aadrake> ChristianS: The laziness is a huge advantage over the Ruby version since it will die if used on the real file.
23:53:22 <quintess`> aadrake: if you have to tell the C program which keys you want up-front, it probably doesn't build any hashtables (unlike the Haskell and Ruby versions)
23:54:05 <aadrake> quintess`: Good point.
23:55:18 <aadrake> ChristianS: With this performance level it will take about 12 hours to process the file with Haskell, it's impossible in Ruby (as far as I know, unless I break the file into small pieces), and the C version that dumps to CSV took 2.5 hours
23:55:42 <Raphael> hi
23:55:51 <aadrake> ChristianS: I'm guessing the performance will change if I set up a data type for the records and start trying to parse into that
23:57:16 <ChristianS> aadrake: no idea, i never tried processing json with haskell. but it will be hard/impossible to beat a hand-written c parser.
