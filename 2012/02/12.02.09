00:00:05 <elliott> Peaker: uses or implementations?
00:00:09 <elliott> oh, instances
00:00:37 <Peaker> elliott: implementations
00:01:05 <elliott> well, discard = join, discard xs = [ x | Just x <- xs ]... but I guess those aren't very interesting
00:01:19 <Peaker> trying out ghci7.4 for the first time, yay REPL classes! :)
00:01:29 <Peaker> man this is going to make presenting Haskell more awesome :)
00:01:37 <elliott> Peaker: oh, (Map k)
00:01:47 <elliott> which _isn't_ an Applicative (but only on what some people would consider a technicality)
00:02:05 <Peaker> Well, Map kind of sucks :-) There's conal's total map (TMap)
00:02:06 <elliott> too lazy to actually write out the implementation, but you just discard keys with Nothing values
00:02:19 <Peaker> there's Data.Map.mapMaybe id
00:02:28 <elliott> right
00:02:29 <Peaker> @type Data.Map.mapMaybe id
00:02:29 <lambdabot> forall b k. (Ord k) => M.Map k (Maybe b) -> M.Map k b
00:03:00 <elliott> anyway, I'm interested in it because it can turn aligns into zips, sort of
00:03:04 <Peaker> so basically you want a generalized catMaybes
00:03:12 <elliott> you turn (These a a) into (Maybe a) by taking only the These constructors
00:03:14 <elliott> and then discard the result
00:03:29 <elliott> Peaker: yes
00:04:18 <Peaker> well, if you can "discard" Maybes, doesn't it imply some sort of traversal of non-discarded things is possible?
00:04:32 <Peaker> (i.e: maybe a Traverseable constraint?)
00:04:43 <Peaker> (though that throws Applicative in too)
00:04:54 <elliott> Traversable does not throw in Applicative.
00:05:26 <elliott> That's in the f.
00:05:40 <elliott> But yeah, Traversable feels like a bit too much as well.
00:05:48 <elliott> Since it brings in Foldable.
00:05:50 <drdo> Does anyone use haskell-emacs ?
00:06:10 <elliott> Peaker: I have a completely unsubstantiated hunch that there are structures you can discard Nothings from that don't support enumerating their contents, so Traversable is too much.
00:06:36 <zzo38> I prefer catMaybes generalization using MonadPlus (which does not always mean it is Traversable, such as IO)
00:06:53 <Peaker> elliott: heh, Maybe is an instance of CatMaybe though in that case it just yields Monad's join :)
00:07:26 <Peaker> drdo: I do, but I'm not very satisfied with it :)
00:07:50 <elliott> Peaker: i said that twice :P
00:07:54 <drdo> Peaker: I just started trying it now
00:08:01 <elliott> CatMaybe is not as nice a name as Discard :(
00:08:12 <elliott> (is Peaker and/or drdo confusing haskell-emacs and haskell-mode?)
00:08:13 <drdo> It's switching my cursor to black
00:08:36 <drdo> elliott: I'm well aware that they are different things
00:08:45 <unknownwarrior> hey guys, i want to find out whether something in a String is a number or a string. ex "1" -> number, "a" -> string. this is my try: pastie.org/3346919. the problem is that i still get a parse error even i try to avoid this with "case"
00:08:45 <lambdabot> unknownwarrior: You have 1 new message. '/msg lambdabot @messages' to read it.
00:08:47 <elliott> oh, hey... it's the mapMaybe rwbarton mentioned
00:08:51 <Peaker> elliott: Hmm.. just skimmed the above and didn't notice
00:08:51 <elliott> discard, that is
00:08:55 <elliott> *maybeFmap
00:08:58 <drdo> I usually use haskell-mode and noticed haskell-emacs and decided to try it
00:09:51 <tikhonjelvis> drdo: What's the difference between haskell-mode and haskell-emacs?
00:09:55 <tikhonjelvis> I've only ever used the former.
00:10:00 <Peaker> unknownwarrior: "case" is for patterns
00:10:12 <Peaker> unknownwarrior: maybe you want guards, but that won't work either because "read" will just crash & burn if it fails to parse
00:10:24 <unknownwarrior> Peaker: aww
00:10:32 <unknownwarrior> Peaker: so what can i doß
00:10:40 <MaskRay> http://chrisdone.com/posts/2011-08-21-haskell-emacs.html
00:10:43 <Peaker> unknownwarrior: what does the range 1..100 have to do with anything? :)
00:10:44 <MaskRay> seems great
00:10:58 <drdo> tikhonjelvis: haskell-emacs has a lot more functionality apparently
00:11:11 <unknownwarrior> Peaker: its about an assembler interpreter and i just expect the number to be between 1 and 100 ;)
00:11:12 <drdo> I'm finding hard to start using it though
00:11:22 <drdo> *finding it
00:11:59 <tikhonjelvis> Have you tried scion?
00:12:08 <drdo> Never even heard about it
00:12:12 <Peaker> unknownwarrior: but you wanted to see if it is parse-able as an int, or as a string, right?
00:12:18 <matthiasgorgens> @pl  \fail succeed -> a fail $ \result -> (getParser . f) result fail succeed
00:12:18 <lambdabot> liftM2 (.) a (flip . flip (getParser . f))
00:12:27 <tikhonjelvis> It's an external program that can interface with Emacs
00:12:36 <unknownwarrior> Peaker: y, its not necessary to know if its between 1 and 100
00:12:38 <burbul> I have a sequence of operations which are performed on a tree datatype  --- i.e. a_1 . a_2 . a_3 . ... . a_n $ T.  I'd like to force full evaluation of each (a_i X) before the next evaluation is started (to see if it speeds things up). Can someone point me at a tutorial on this? (Just checked http://users.aber.ac.uk/afc/stricthaskell.html#seq , which suggests 'seq' isn't enough... .) [Thanks!]
00:12:40 <tikhonjelvis> https://github.com/nominolo/scion
00:12:42 <elliott> matthiasgorgens: stick with the original... please :P
00:12:45 <matthiasgorgens> @pl \ succeed -> a fail $ \result -> (getParser . f) result fail succeed
00:12:45 <lambdabot> a fail . flip (flip getParser fail . f)
00:12:46 <Peaker> unknownwarrior: you can use the total parsing function (reads) or a simple readM defined around it
00:12:56 <tikhonjelvis> I haven't used it myself, but I keep on meaning to try it :p
00:12:56 <matthiasgorgens> elliott, I will.  I'm just exploring the structure. :o)
00:13:14 <elliott> matthiasgorgens: you may want to rearrange the continuations to make things work out nicer
00:13:21 <Peaker> unknownwarrior: the algorithm I think you're after is something like:  parse-as-int --> fail? then parse-as-string, fail? then parse-as ...
00:13:21 <elliott> or maybe that's the best order, dunno
00:13:33 <matthiasgorgens> elliott, I think that's the best order.
00:13:39 <tikhonjelvis> Hmm, haskell-emacs seems neat. It also sounds more approachable as far as customization than the haskell-mode.
00:13:41 <matthiasgorgens> elliott, thinks work out pretty nicely already.
00:13:44 <Peaker> does Parsec's "choice . map try" have a name?
00:14:15 <unknownwarrior> Peaker: in what manner should i use "reads"? can you maybe give an example?
00:14:21 <drdo> tikhonjelvis: I'm trying to figure out why it's changing my cursor to black when i use the interactive thing
00:14:22 <elliott> ok, Discard = Control.Categorical.Functor.Functor f (Kleisli Maybe) (->)
00:14:23 <tikhonjelvis> drdo: What are you finding difficult with it?
00:14:28 <tikhonjelvis> ah
00:14:42 <elliott> which is uh... convenient
00:14:42 <drdo> Also requiring me to create projects is annoying
00:15:14 <tikhonjelvis> Hmm, reading further, it actually mentions scion. It seems it isn't integrated yet though.
00:15:19 <elliott> drdo: the interactive thing runs without your configuration to avoid conflicts, iirc
00:15:42 <Peaker> @type reads
00:15:43 <lambdabot> forall a. (Read a) => String -> [(a, String)]
00:15:59 <drdo> elliott: everything stays the same, it's just the cursor
00:16:23 <Peaker> @type (\s -> case reads s of ((x, "") : _) -> Just x ; _ -> Nothing)
00:16:24 <lambdabot> forall a. (Read a) => String -> Maybe a
00:16:39 <Peaker> @let readM s = case reads s of ((x, "") : _) -> Just x ; _ -> Nothing
00:16:40 <lambdabot>  Defined.
00:16:47 <yitz> Peaker: probably it doesn't have a name because we try to avoid it. but in reality it does come up all too often.
00:16:48 <Peaker> unknownwarrior: you can use readM as defined above
00:17:55 * elliott would call it readMaybe, since readM tends to refer to the Monad/MonadPlus one in my experience
00:17:59 <Jafet> :t fmap fst . listToMaybe . reads
00:17:59 <lambdabot> forall a. (Read a) => String -> Maybe a
00:18:01 <Peaker> yitz: avoiding it is awful for the modularity of the parser -- might as well make an applicative parser rather than monadic if we want modularity & performance
00:18:22 <drdo> oh, it only changes the color upon entering something in the repl
00:18:38 <yitz> Peaker: yeah, but all that backtracking... ew.
00:18:50 <Peaker> @check (liftA2 (==) readM (fmap fst . listToMaybe . reads))
00:18:51 <lambdabot>   "OK, passed 500 tests."
00:19:08 <Peaker> @check (liftA2 (==) (readM :: String -> Maybe Int) (fmap fst . listToMaybe . reads))
00:19:09 <lambdabot>   "OK, passed 500 tests."
00:19:12 <Peaker> yay :-)
00:19:45 <Peaker> yitz: I really miss a tokenizing pass in parsec -- if you tokenize naively and do a second pass, you lose all the pos info on errors/etc :(
00:20:21 <tikhonjelvis> Ooh, automatically generating a TAGS file sounds useful.
00:20:50 <Peaker> I installed cabal-install from darcs head (for ghc 7.4) and now I get a funny error like:
00:21:08 <drdo> elliott: Care to point out what actually does that if you already know? :)
00:21:14 <Peaker> "cabal: dependencies conflict: derive-2.5.5.1 requires an installed instance of template-haskell ==2.7.0.0 however:" (followed by nothing)
00:21:27 <Peaker> (I have template-haskell 2.7.0.0 installed)
00:21:37 <yitz> Peaker: well, the whole advantage of Parsec over, say, attoparsec, is that you can have a tokenize pass at all
00:21:46 <unknownwarrior> Peaker: okey thanks, i took this one: (\s -> case reads s of ((x, "") : _) -> Just x ; _ -> Nothing), even i am not sure what it does .. why is there a touple?
00:21:49 <tikhonjelvis> drdo: How is the indentation?
00:22:01 <drdo> tikhonjelvis: Haven't tried it yet
00:22:16 <drdo> I was quite unhappy with haskell-mode's indentation though
00:22:27 <drdo> Had to manually indent quite a bit
00:22:28 <tikhonjelvis> Really? It almost always works exactly the way I want.
00:22:33 <yitz> Peaker: i use attoparsec in practice. almost exclusively applicatively. i chop up the input and never let the parsers read too much.
00:22:49 <drdo> And sometimes resorted to writing my code differently just to please haskell-mode
00:23:01 <Peaker> yitz: I wouldn't say I can have it at all, if having it means losing meaningful error messages
00:23:04 <drdo> (so i didn't have to manually indent)
00:23:19 <yitz> Peaker: true you don't want to get lost
00:23:34 <tikhonjelvis> The one annoying thing is when do gets moved. But I think a little bit of elisp magic could fix that.
00:23:48 <yitz> Peaker: so i guess you need to pass through some location information manually
00:23:49 <drdo> tikhonjelvis: for example, arguments in different lines don't align
00:24:05 <drdo> foo x
00:24:06 <drdo> y
00:24:12 <drdo> haskell-mode wants this
00:24:14 <drdo> i want
00:24:15 <drdo> foo x
00:24:20 <drdo>      y
00:24:23 <drdo> one less space :P
00:24:27 <yitz> @type ReadS
00:24:27 <lambdabot> Not in scope: data constructor `ReadS'
00:24:36 <yitz> @type reads
00:24:37 <lambdabot> forall a. (Read a) => String -> [(a, String)]
00:24:43 <tikhonjelvis> Ah. I just don't ever indent my code that way.
00:24:44 <t3eblinder1> Is there a similar function for read, but instead of throwing an error at (read "5a") it returns Nothing?
00:25:22 <yitz> unknownwarrior: reads returns a list of tuples, representing possible parses together with the leftover text after each
00:25:44 <Peaker> yitz: I think it would be nice if you could define a restricted parser that explicitly yields tokens and they get auto-located to whatever range you read to generate them (since last yield)
00:26:09 <yitz> unknownwarrior: but in practice, most Read instances just use that list as a "Maybe" - either there's one parse or none.
00:26:12 <Peaker> maybe it's not even monadic, so you really know what was yielded relates to those positions only
00:26:45 <unknownwarrior> yitz: hmkey..
00:28:35 <yitz> unknownwarrior: anyway, the point is that reads is usually better than just read, which either gives you a parse or blows up your program.
00:29:24 <unknownwarrior> yitz, okey thanks
00:29:50 <yitz> unknownwarrior: so you do what Peaker says, which turns reads into something almost like read, except it returns Nothing when there's no parse instead of throwing an exception
00:31:05 <mm_freak_> last time i tried GHC 7.4, there have been lots of dependency problems…  is it still that bad?
00:31:51 <Peaker> what's the canonical way to make code dependent on ghc ver?
00:32:02 <yitz> Peaker: i suppose it would be some kind of transformer, so you could use varying numbers of lifts to get the position in any of the various tokenization layers.
00:32:30 <yitz> Peaker: specify a constraint on the version of base
00:33:07 <Peaker> I want to compile on all ghc versions
00:33:13 <Peaker> I just want some code to be #ifdef'd out on newer ghc
00:33:17 <Peaker> (workaround for missing instances)
00:37:48 <yitz> Peaker: there is some way to do it with ifdefs, yeah. but that's not what people usually do.
00:38:23 <Peaker> how do people do it? Just new version that only works with the new? That's recipe for failures (of which we have many whenever new version of ghc is released)
00:38:26 <yitz> Peaker: they use cabal conditions that specify different sets of other dependencies for different ranges of versions of base
00:39:27 <yitz> Peaker: look around on hackage there are a lot of examples
00:40:00 <Peaker> I just want Word8 instances of random -- and <7.4 didn't have them
00:40:14 <yitz> Peaker: someone ought to write up a wiki page for this.
00:40:30 <yitz> Peaker: i always forget the details and have to go searching around for examples
00:41:41 <yitz> Peaker: for that you can just do randomR (0,255). but what a pain.
00:41:54 <Peaker> by the time my project becomes viable, ghc 7.4 will be norm. I'll just rely on it :)
00:42:06 <yitz> heh ok. :)
00:43:54 <unknownwarrior> yitz: okey i have a question, i receive the string "@256" that i receive from lines . readfile "filepath" and i pass the tail to the function that does something special with it if its a number, but its always a string oO
00:46:26 <elliott> Peaker: lots of people use ifs for it
00:46:34 <elliott> cabal defines min_version macro things
00:46:56 <elliott> just condition on the base version
00:48:56 <yitz> Peaker: have a look at this: http://hackage.haskell.org/trac/ghc/ticket/3457
00:50:23 <yitz> unknownwarrior: use readM that Peaker gave you. then do something like: maybe somethingOrdinary somethingSpecial $ readM yourInput
00:50:31 <yitz> @type maybe
00:50:32 <lambdabot> forall b a. b -> (a -> b) -> Maybe a -> b
00:50:59 <unknownwarrior> yitz, okey ty
01:06:49 <matthiasgorgens> I re-implemented a toy version of monadic parsing.  I want to make it as simple as possible for an introduction to newbies.  Is it necessary to use continuation-passing-style / cont-monad?  Or, rather, is that style the simplest possible implementation?
01:09:44 <matthiasgorgens> elliott, don't worry, I won't throw the pointfree version at the newbies.
01:14:42 <drdo> Does indentation work for anyone in haskell-emacs? (I just get spaces inserted)
01:16:25 <matthiasgorgens> drdo, you also need meta-x haskell-indent-mode
01:17:37 <drdo> from haskell-mode?
01:18:29 <drdo> I don't have that function with just haskell-emacs
01:22:31 <drdo> matthiasgorgens: Oh i guess you mean hs-indent-kb-mode or hs-indent-glfsf-mode
01:22:52 <Philippa_> matthiasgorgens: I like the version where you build the core combinators as a GADT+Interpreter pair
01:23:22 <Philippa_> there's ground for debate about whether that's simplest or not, but I figure CPS definitely isn't for most newbies - it tends to involve thinking inside out
01:23:52 <Philippa_> the interpreter's transformable into other flavours pretty mechanically too, if you want to remove the tags afterwards
01:24:12 <Philippa_> (oh for a tool to do that automatically if you feed it the relevant types and functions!)
01:30:49 <matthiasgorgens> Philippa_: I don't see how I'd need GADT and interpreter here.
01:31:07 <matthiasgorgens> see http://hpaste.org/57668 for the (near) current state of affairs.
01:31:24 <matthiasgorgens> Philippa_: could you please elaborate somewhat?
01:31:46 <matthiasgorgens> drdo: sorry, I don't remember what package I used to install.
01:33:19 <otk> hm neat http://nkwiatek.com/#
01:39:39 <rata_> hi
01:42:34 <Taneb> Hello!
01:43:32 <burbul> Could someone tell me why in (Either String String), 'fail' and 'Left' produce different behaviour?
01:44:16 <Taneb> :t fail
01:44:17 <lambdabot> forall (m :: * -> *) a. (Monad m) => String -> m a
01:44:24 <Taneb> :t Left
01:44:25 <lambdabot> forall a b. a -> Either a b
01:45:55 <burbul> Sorry, I don't follow... I'm fairly new to Haskell.  I looked for the 'instance Monad (Either a)', but I don't know where to find it
01:45:58 <Taneb> Because the people writing Control.Monad.Instances made it so?
01:46:04 <Taneb> Control.Monad.Instances
01:46:23 <Taneb> instance Functor (Either a) where
01:46:23 <Taneb>         fmap _ (Left x) = Left x
01:46:23 <Taneb>         fmap f (Right y) = Right (f y)
01:46:23 <Taneb> instance Monad (Either e) where
01:46:23 <Taneb>         return = Right
01:46:24 <Taneb>         Left  l >>= _ = Left l
01:46:26 <Taneb>         Right r >>= k = k r
01:46:27 <burbul> ah... founded, but it doesn't have any code for fail
01:46:34 <burbul> *found it
01:46:39 <Taneb> So it would go for the default
01:46:45 <Taneb> @src fail
01:46:45 <lambdabot> fail s      = error s
01:46:51 <burbul> @src error
01:46:51 <lambdabot> error s = throw (ErrorCall s)
01:46:56 <burbul> @src throw
01:46:57 <lambdabot> throw exception = raise# exception
01:47:03 <burbul> @src raise#
01:47:04 <lambdabot> Source not found. Take a stress pill and think things over.
01:47:07 <burbul> @src raise
01:47:07 <lambdabot> Source not found. Sorry.
01:47:41 <burbul> Ew, so I've really written a partial function without realising...
01:48:44 <Taneb> I'm not good at vocab, what's a partial function?
01:48:46 <burbul> Is there no difference in type between something that is allowed to raise an exception and something that is not allowed to raise an exception?
01:49:07 <burbul> sorry, I meant that the function doesn't have to return a thing of its output type
01:49:21 <Taneb> :t error
01:49:21 <lambdabot> forall a. [Char] -> a
01:49:33 <Taneb> Typewise, there is no difference
01:49:38 <burbul> So I had 'apply_to_node :: Node a -> Either String String'
01:49:54 <burbul> I thought it had to return something of type 'Either String String'
01:50:20 <burbul> OK, thanks!
01:51:13 <Palmik> Hmm, what are some instances of functions that compile without signature (thus their type is inferable), but do not typecheck if you given the previously inferred type?
01:52:20 <Palmik> And also, why does not it typecheck? Can not the typechecker try to inferr the type and compare it with the given signature and see if the signature is equally or less general?
01:53:35 <Palmik> This happened to me in the context of type families and GADTs
01:57:22 <quintessence> Palmik: if it's not top-level, you may need ScopedTypeVariables
01:59:26 <burbul> @pl (\s -> (hPutStr stderr s >> putStr "\n"))
01:59:26 <lambdabot> (>> putStr "\n") . hPutStr stderr
01:59:36 <Palmik> quintessence, here is my example without much context http://hpaste.org/57670 (I can give pasthe the whole code if needed), I would like to understand the reason why it does not typecheck. I could understand if the "return" type was of some value, but is it in this case?
02:00:15 <Palmik> Also the whole error message http://hpaste.org/57671
02:01:22 <MichaelBurge> How do you write the type of, "A list of things that are instances of a given type class"?
02:02:44 <Palmik> MichaelBurge, you make a GADT that wraps it. Actually that's what I'm doing basically here: http://hpaste.org/57673
02:02:49 <Jafet> data Showable where Showable :: Show a => a; type ListShowable = [Showable]
02:02:52 <Palmik> I can show you a simpler example if you wish.
02:03:00 <Jafet> Or something
02:03:08 <Palmik> Yep. Like that.
02:03:18 <Jafet> Show a => a -> Showable
02:03:37 <Palmik> Or you can use the soon to be deprecated existentials.
02:03:39 <quintessence> Palmik: Hmm, that's not what I thought it was; I think I may have to read the OutsideIn paper to figure it out
02:03:56 <quintessence> (it's in my queue anyway, so now's as good a time as any)
02:03:57 <Jafet> forall, the best existential quantifier
02:04:08 <Palmik> Jafet, indeed. :P
02:05:44 <Tinned_Tuna> There exists a best existential quantifier :-)
02:06:45 <Palmik> quintessence, hmm, seems like an interesting read indeed.
02:08:39 <Algorith> é&
02:08:42 <Jafet> burbul: the whole point of exceptions is to bypass the bureaucracy of threading errors through other code
02:09:45 <Jafet> In a value context, error is (a very strange) bottom
02:22:57 <yoaha> can anyone help me with: 1
02:22:57 <yoaha> 2
02:22:57 <yoaha> 10
02:22:57 <yoaha> 42
02:22:59 <yoaha> bah
02:23:05 <yoaha> copy/paste fail
02:23:08 <yoaha> http://ideone.com/sZGKi
02:24:17 <luite> use `mod` instead of mod
02:24:44 <luite> since it's a regular function name, you need to use backquotes if you want infix
02:25:31 <yoaha> aha
02:25:38 <luite> and the type sig is wrong, the context comes before the actual parameters: Num a => a -> Bool
02:26:01 <rostayob> yoaha: you should read an introduction to haskell, e.g. LYAH
02:26:16 <yoaha> yeah, i am still reading it
02:26:30 <yoaha> on higher-order-functions
02:26:44 <yoaha> i just wanted to run through project euler to try and get to grips with what i have learnt so far
02:26:45 <rostayob> yoaha: you're reading LYAH?
02:26:51 <rostayob> ok
02:26:52 <yoaha> yup
02:27:09 <luite> yoaha: I think those mods should make at least the isMultiple funciton work, so you should be able to isMultiple 15 at the ghci prompt
02:27:12 <yoaha> i'll probably re read it when i have done for clarity
02:27:43 <yoaha> yeah i'm thinking the "result: Not running     " on ideone is more to do with it not being a real program yet
02:27:52 <yoaha> i'll work in ghci instead
02:28:25 <Taneb> Also, you're brute-forcing it. There's a much easier way to do it (read up on summation series)
02:28:35 <Taneb> By easier I mean quicker
02:28:48 * hackagebot shake 0.2.3 - Build system library, like Make, but properly supports generated files.  http://hackage.haskell.org/package/shake-0.2.3 (NeilMitchell)
02:28:57 <Taneb> Assuming you're doing the Project Euler number... 1?
02:29:53 <luite> yoaha: fixed it :) http://ideone.com/2pskc
02:30:16 <luite> you need Integral instead of Num because of the mod function you're using
02:30:37 <yoaha> Taneb: i just want to get my head around syntax and what not first
02:30:48 <yoaha> thankyou luite
02:31:14 <Entroacceptor> yoaha: so, explain the differences ;)
02:31:18 <Taneb> yoaha, fair 'nuff
02:32:21 <yoaha> the difference is he has defined a main which i'm assuming ideone is looking for
02:32:35 <Entroacceptor> ah, ignoring ideone
02:33:55 <yoaha> well the type signature was wrong for starters, also the type of input (Num vs Integral)
02:34:02 <yoaha> plus infix'ing mod
02:34:12 <yoaha> not sure why he imported where though
02:34:44 <Entroacceptor> the "module Main where" is not an import
02:34:56 <Entroacceptor> it just defines "the stuff in this file is the module Main"
02:35:02 <MichaelBurge> Jafet: Does it then make sense to say "instance Show ListShowable where [...]"? I'm getting a confusing error message when I try that
02:35:03 <yoaha> ah
02:35:17 <Entroacceptor> you can define what to export there, too
02:35:28 <Entroacceptor> but ignore that for now ;
02:35:37 <Jafet> MichaelBurge: there is already a Show instance for lists.
02:35:45 <Jafet> Perhaps you meant: instance Show Shoable
02:35:48 <Jafet> Shooable
02:35:59 <quintessence> Palmik: does it work if you also give a type signature for m?
02:36:00 <MichaelBurge> I have a separate type, and was building off of your example
02:36:38 <Jafet> There is already a Show instance for lists, so it isn't a good idea to try to define another one.
02:36:40 <Entroacceptor> yoaha: and do you see why he can just do  print (isMultiple 15) ?
02:36:42 <yoaha> Taneb: i'm looking at summation series now, thanks for the info
02:36:53 <Jafet> type ListShowable = [] Showable
02:37:01 <yoaha> Bool is part of Show?
02:37:25 <Jafet> Bool is an instance of Show.
02:38:02 <Jafet> Unless Bool is a circus performer
02:38:40 <yoaha> hrhr
02:38:40 <Palmik> quintessence, yes, with ScopedTyeVariables like this: http://hpaste.org/57675
02:38:55 <Palmik> *Type
02:40:25 <Palmik> I think the reason that it does not work without is that even if the inferred type matches the type signature, it can not confirm the type of m (which was solved solved by the scoped type var.).
02:41:14 <quintessence> Palmik: yeah, that's my guess.  On this box I have ghc 6.12, and it complains about a non-rigid GADT pattern match unless I add a type signature for m (with or without one on printFields)
02:41:47 <quintessence> The new inference algorithm tries a bit harder and says something stranger when it can't figure things out later on
03:24:19 <MaskRay> [data-lens] why is it said that iso :: (a -> b) -> (b -> a) -> Lens a b is isomorphic to ((a->b), (b->a))
03:41:45 <qubodup> hi
03:42:00 <qubodup> (asked this on #ghc) we're trying to build ghc on windows in msys but it won't accept the --with-gcc=PATHTOGCC parameter and just uses it's own. are we doing something wrong?
03:49:37 <mekeor> qubodup: why not haskell-platform? >.>
03:51:55 <qubodup> mekeor: we need to use one gcc version for all compilation and haskell-platform brings its own, including all of its dependancies and itself being compiled with it
03:52:38 <mekeor> qubodup: okay.
03:53:02 <Taneb> > let factors n = uncurry (++) $ unzip [(x,round y)|x<-[2..round $ sqrt $ fromInteger n],y<-[fromInteger n/fromInteger x],floor y == ceiling y] in factors 1000000
03:53:04 <lambdabot>   [2,4,5,8,10,16,20,25,32,40,50,64,80,100,125,160,200,250,320,400,500,625,800...
03:53:11 <Taneb> Surprisingly efficient
03:53:27 <Taneb> > let factors n = uncurry (++) $ unzip [(x,round y)|x<-[2..round $ sqrt $ fromInteger n],y<-[fromInteger n/fromInteger x],floor y == ceiling y] in length $ factors 1000000
03:53:28 <lambdabot>   48
03:53:33 <Taneb> Could do with a nub
03:54:08 <Taneb> > let factors n = nub $ uncurry (++) $ unzip [(x,round y)|x<-[2..round $ sqrt $ fromInteger n],y<-[fromInteger n/fromInteger x],floor y == ceiling y] in length $ factors 1000000
03:54:10 <lambdabot>   47
03:56:13 <Taneb> Also could do with a (1:)
03:56:24 <Taneb> > let factors n = 1 : nub $ uncurry (++) $ unzip [(x,round y)|x<-[2..round $ sqrt $ fromInteger n],y<-[fromInteger n/fromInteger x],floor y == ceiling y] in length $ factors 1000000
03:56:25 <lambdabot>   Couldn't match expected type `[t]'
03:56:25 <lambdabot>         against inferred type `[a] -> [a]'
03:56:38 <Taneb> > let factors n = 1 : (nub $ uncurry (++) $ unzip [(x,round y)|x<-[2..round $ sqrt $ fromInteger n],y<-[fromInteger n/fromInteger x],floor y == ceiling y]) in length $ factors 1000000
03:56:40 <lambdabot>   48
03:59:59 <noteventime> Lol, funky colour theme
04:00:09 <noteventime> Opps, Wrong channel :)
04:01:03 <MaskRay> takeWhile ((<= n) . join (*))
04:02:34 <Taneb> Instead of round $ sqrt $ fromInteger n?
04:03:00 <tigger> I think this shouldn't be to hard, but with the ffi, how would I convert [CInt] -> Ptr CInt, would it be right to do (malloc >>= return . poke a), where a :: [CInt], but this creates something of type Ptr [CInt] not Ptr CInt, could someone help me out? thanks
04:03:04 <MaskRay> looks conveniently though less efficient
04:03:27 <Axman6> @hoogle Storable a => [a] -> Ptr a
04:03:28 <lambdabot> Foreign.Marshal.Array newArray :: Storable a => [a] -> IO (Ptr a)
04:03:28 <lambdabot> Foreign.Marshal.Array newArray0 :: Storable a => a -> [a] -> IO (Ptr a)
04:03:28 <lambdabot> Foreign.Marshal.Pool pooledNewArray :: Storable a => Pool -> [a] -> IO (Ptr a)
04:03:37 <Taneb> And why not takeWhile ((<= n) . (^2))?
04:03:40 <tigger> Axman: thanks!
04:04:40 <MaskRay> [data-lens], why is it said that `Lens a b' and the pair `(a->b), (b->a)` are isomorphic ?
04:05:57 <MaskRay> iso f g = Lens (store g . f)
04:06:00 <Axman6> MaskRay: probably because a lens is just a tuple of functions of (almost?) those types
04:06:02 <MaskRay> iso :: (a -> b) -> (b -> a) -> Lens a b
04:06:15 <Axman6>  @src Lens?
04:06:59 <MaskRay> Axman6: i can only understand this construc function: (a -> b) -> (b -> a -> a) -> Lens a b
04:07:27 <MaskRay> Axman6: `a' resembles a record while `b' the field
04:08:25 <Axman6> so, the a -> b is the function that extracts the b value from the a, and the b -> a function is what sets the b inside the a to the new b? (not quite right...)
04:08:40 <Axman6> edwardk would be the best person to talk to about this though
04:11:41 <MaskRay> how does the b -> a function know which record it is operating
04:13:13 <Axman6> yeah, that's where the 'not quite right...' part came in, i realised that as i said it
04:13:54 <Palmik> MaskRay, what makes you think that they are isomorphic?
04:13:54 <MaskRay> iso f g = Lens (store g . f)
04:14:14 <MaskRay> Palmik: from the doc: -- | build a lens out of an isomorphism
04:14:18 <Axman6>  :t store?
04:14:34 <ddarius> If you have an isomorphism you can a build a lens.  That doesn't make a lens isomorphic to an isomorphism.
04:14:39 <Palmik> Yeah, that does not mean that Lens a b is isomorphic to (a -> b) (b -> a) touple .)
04:14:39 <kallisti> "Thrown when the runtime system detects that the computation is guaranteed not to terminate." -- Huh, I didn't know the runtime did this.
04:14:58 <ddarius> @hoogle isBottom
04:14:58 <lambdabot> No results found
04:15:02 <Axman6> hooray, people who actually know something about lenses!
04:15:27 <nand`> that paper has been sitting on my hard drive for a while now
04:15:41 <kallisti> it seems that it would be difficult to distinguish useful non-termination from non-useful non-termination.
04:15:54 <kallisti> so I would imagine in practice the NonTermination error is not very common?
04:16:23 <ddarius> kallisti: It occurs when you write stuff like let x = x in x
04:16:32 <MaskRay> oh, i misunderstood the doc
04:17:14 <nand`> what about: length [1..]
04:17:14 <kallisti> ddarius: hm, actually I guess any strict non-terminating non-IO computation could be considered non-useful?
04:18:12 <ddarius> kallisti: Yes, but the run-time system can't detect that an arbitrary non-IO computation is non-terminating.
04:18:21 <kallisti> well, yes.
04:18:44 <MaskRay> Palmik: ddarius: then how to understand the iso function
04:20:52 <kallisti> hm, Control.Exception has 23 exception types. that's more than I expected.
04:21:23 <kallisti> or rather, 23 Exception instances.
04:21:26 <kallisti> are listed in the docs.
04:21:56 <kallisti> huh, what. Dynamic is apparently an instance of Exception.
04:22:37 <hpc> kallisti: Dynamic can be anything
04:22:58 <hpc> if it's not an exception, i imagine most of the Exception methods will.... throw an exception :D
04:23:51 * hackagebot hfoil 0.1.1 - Hess-Smith panel code for inviscid 2-d airfoil analysis  http://hackage.haskell.org/package/hfoil-0.1.1 (GregHorn)
04:24:28 <ddarius> MaskRay: A lens lets you extract part of something.  In the case of an isomorphism, that "part" of something is equivalent to the whole thing.
04:24:43 <MaskRay> Palmik: ddarius: is `iso' a simple form of `lens' and does not have  all the functionality ?
04:24:43 <ddarius> E.g. a record with one field.
04:25:09 <Palmik> It has all it's functionality. It's just a lense over a special kind of type (or part of type)
04:25:10 <ddarius> MaskRay: No.  Once you have a Lens you can do everything you can do with a Lens.
04:25:18 <Palmik> s/lense/lens
04:25:40 <MaskRay> ddarius: seems so from the type
04:25:52 <kallisti> "data RecConError. An uninitialised record field was used"   for some reason I thought this was impossible.
04:26:03 <ddarius> Basically iso f g = lens f (\b a -> g b)
04:26:29 <MaskRay> the second argument of `iso' is b -> a for there is only one field?
04:27:01 <kallisti> oh wait I guess when you try to access a field on the wrong constructor.
04:27:17 <ddarius> kallisti: You can just not initialize a field.
04:27:30 <kallisti> ddarius: that seems very semantically strange to me.
04:27:33 <ddarius> No, it's as if b is a record with only one field.  So if you are setting that one field you don't need the original record to "update" that field; you'd just be overwriting everything anyway.
04:27:39 <ddarius> > Just {}
04:27:40 <lambdabot>   Just *Exception: <interactive>:3:0-6: Missing field in record construction
04:27:52 <kallisti> ddarius: see I would think this is a compile-time error....
04:28:15 <ddarius> It is if the fields are strict.
04:28:30 <MaskRay> setter (b->a) has no more knowledge other than the only argument (field) passed to it
04:28:49 <kallisti> if the record syntax were transformed into the equivalent non-record-syntax form then it would simply be a type error of some form.
04:28:55 <MaskRay> it behaves like it has to construct the full record with the only field
04:28:57 <ddarius> kallisti: Note that this is pretty much the dual of allowing non-exhaustive patterns.
04:29:27 <MaskRay> so it resembles a record with only one field
04:29:34 <ddarius> MaskRay: Yes.
04:29:59 <ddarius> That's what the (a -> b) (b -> a) pair being an isomorphism says; that b has all the information needed to build a.
04:30:04 <ddarius> (and vice versa)
04:30:40 <MaskRay> the term `isomorphism' applys to `a' and `b' ...
04:31:07 <ddarius> MaskRay: No.  a and b are isomorphic if the pair of functions form an isomorphism.
04:31:38 <ddarius> Note that not all pairs of functions of those types form isomorphisms.
04:31:49 <MaskRay> silly me... suddenly enlightened, it was so apparent that i should understand from the first glance
04:32:15 <Taneb> Does anything like data Reversible a b = Reversible (a -> b) (b -> a) exist?
04:33:39 <donri> Taneb: Enum?
04:33:52 * hackagebot persistent-postgresql 0.8.1 - Backend for the persistent library using postgresql.  http://hackage.haskell.org/package/persistent-postgresql-0.8.1 (MichaelSnoyman)
04:33:54 * hackagebot persistent-template 0.8.1 - Type-safe, non-relational, multi-backend persistence.  http://hackage.haskell.org/package/persistent-template-0.8.1 (MichaelSnoyman)
04:34:13 <MaskRay> i can see it exists as long as there's a bijection from a to b
04:36:22 <kallisti> ddarius: I don't understand why record syntax is treated different from the (otherwise) equivalent positional constructor form.
04:37:58 <quicksilver> kallisti: that different treatment is considered to be the *purpose* of record syntax
04:38:01 <ddarius> kallisti: The whole point of record syntax in general is that you don't have to always write out all the fields.  This "difference" seems completely in line with that.
04:38:01 <quicksilver> more or less.
04:38:55 * hackagebot wai-app-static 1.1.1 - WAI application for static serving  http://hackage.haskell.org/package/wai-app-static-1.1.1 (MichaelSnoyman)
04:38:57 * hackagebot wai-test 1.1.1 - Unit test framework (built on HUnit) for WAI applications.  http://hackage.haskell.org/package/wai-test-1.1.1 (MichaelSnoyman)
04:38:59 * hackagebot yesod 0.10.1 - Creation of type-safe, RESTful web applications.  http://hackage.haskell.org/package/yesod-0.10.1 (MichaelSnoyman)
04:39:00 <kallisti> sure, it's supposed to be a syntactic convenience. It seems odd that it would have this strange semantic difference as well. What is an "empty field". Everything just has a default value of bottom when you use record syntax?
04:39:01 * hackagebot yesod-auth 0.8.1 - Authentication for Yesod.  http://hackage.haskell.org/package/yesod-auth-0.8.1 (MichaelSnoyman)
04:39:03 * hackagebot yesod-core 0.10.1 - Creation of type-safe, RESTful web applications.  http://hackage.haskell.org/package/yesod-core-0.10.1 (MichaelSnoyman)
04:39:20 <luite> wooh yesod 0.10! :p
04:39:45 <quicksilver> kallisti: it's not a semantic difference, it's another syntactic convenience.
04:39:48 <luite> merge window for yesod 1.0 now open :p
04:39:56 <kallisti> > Just {}
04:39:57 <lambdabot>   Just *Exception: <interactive>:3:0-6: Missing field in record construction
04:39:58 <kallisti> > Just
04:39:59 <lambdabot>   Overlapping instances for GHC.Show.Show (a -> Data.Maybe.Maybe a)
04:40:00 <lambdabot>    arisin...
04:40:10 <quicksilver> Foo {x = blah} is sugar for Foo blah (error "y missing") (error "z missing")
04:40:21 <kallisti> so, yes.
04:40:31 <Taneb> kallisti, it means if you have a datatype like Person s = Person String Data Data Person Person [Person] you don't need to define a tonne of functions for getting the list
04:40:41 <Taneb> s/Data/Date/
04:41:05 <kallisti> making Constructor {blah = x} require /all/ fields does not impede any of that functionality and actually just serves to reduce possible runtime errors.
04:41:18 <quicksilver> sure.
04:41:19 <Taneb> Or am I mixed up
04:41:20 <kallisti> note that not_a_constructor {blah = x}  would not have the same restriction.
04:41:21 <ddarius> kallisti: So would making all pattern matches be required to be exhaustive.
04:41:22 <Taneb> I'm mixed up
04:41:22 <donri> i think -Wall warns on that?
04:41:27 <quicksilver> in many ways I agree with you kallisti
04:41:31 <Taneb> Ignore me
04:41:44 <quicksilver> but, I seldom use haskell record syntax because it sucks in multiple different ways
04:41:49 <quicksilver> however, this *is* its purpose.
04:42:02 <quicksilver> Foo {} is convenient though
04:42:09 <kallisti> I don't think I've ever seen a usage for this bottom-defaulting behavior.
04:42:27 <kallisti> I always fill in every field when I'm using the actual constructor.
04:42:34 <kallisti> because I believe in Truth and Justice etc
04:42:41 <donri> i've seen it used to create QuasiQuoters
04:42:43 <ddarius> kallisti: You may (and fairly often do) make a record for which you want to update some fields later.
04:42:54 <ddarius> E.g. a default.
04:43:29 <kallisti> ddarius: sure, and I usually fill in some other default value before that point.
04:43:30 <donri> ddarius: even so, isn't it better to put a more descriptive error in the missing fields?
04:43:47 <MaskRay> i only hates field name pollusion
04:44:01 <MaskRay> s/s/t/
04:44:05 * hackagebot yesod-default 0.6.1 - Default config and main functions for your yesod application  http://hackage.haskell.org/package/yesod-default-0.6.1 (MichaelSnoyman)
04:44:07 * hackagebot yesod-form 0.4.1 - Form handling support for Yesod Web Framework  http://hackage.haskell.org/package/yesod-form-0.4.1 (MichaelSnoyman)
04:44:09 <ddarius> donri: Do you handle all cases of a pattern match and for the unused cases always put in a more descriptive error?
04:44:10 * hackagebot yesod-json 0.3.1 - Generate content for Yesod using the aeson package.  http://hackage.haskell.org/package/yesod-json-0.3.1 (MichaelSnoyman)
04:44:11 * hackagebot yesod-newsfeed 0.4.1 - Helper functions and data types for producing News feeds.  http://hackage.haskell.org/package/yesod-newsfeed-0.4.1 (MichaelSnoyman)
04:44:13 * hackagebot yesod-persistent 0.3.1 - Some helpers for using Persistent from Yesod.  http://hackage.haskell.org/package/yesod-persistent-0.3.1 (MichaelSnoyman)
04:44:27 <donri> ddarius: usually, yes
04:44:40 <ddarius> donri: Then for you, the answer is "yes."
04:44:43 <donri> :)
04:45:07 <ddarius> Or I should say "usually, yes"
04:46:28 <kallisti> in most circumstances I've found that I can use Maybe and have a default value of Nothing if no other default value makes sense. I could see how this would have disadvantages over bottom perhaps.
04:46:42 <kallisti> in some programs.
04:46:51 <donri> "Nothing" doesn't make more sense though if no default value makes sense
04:47:08 <donri> because what you really have then is a required value
04:47:49 <kallisti> yes
04:48:25 <kallisti> and bottom is usually a bad choice for required values. :P
04:48:53 <kallisti> unless you have a complex structure that has to be built up over several different stages or something...
04:49:11 <donri> in deed, better have a descriptive error or a factory function taking the required values as arguments
04:49:15 * hackagebot yesod-routes 0.0.1 - Efficient routing for Yesod.  http://hackage.haskell.org/package/yesod-routes-0.0.1 (MichaelSnoyman)
04:49:18 * hackagebot yesod-static 0.10.1 - Static file serving subsite for Yesod Web Framework.  http://hackage.haskell.org/package/yesod-static-0.10.1 (MichaelSnoyman)
04:50:00 <ddarius> kallisti: Let's say I have a structure that stores some connection information.  The port may have a nice default value, but the URL doesn't.  It doesn't make sense to not have a URL, so there's little reason to have Maybe Uri.  It would just be a program error to fail to initialize the URL.
04:50:25 <ddarius> donri: Indeed, that factory function may still want to use a default record that it updates though.
04:50:37 <kallisti> I typically use empty string for situations where an empty string would be otherwise meaningless.
04:50:57 <ddarius> kallisti: That's disgusting.  Do you use -1 for situations where -1 is otherwise meaningless?
04:51:20 <kallisti> not generally, no.
04:51:38 <donri> yea that doesn't sound very type safe
04:51:51 <donri> easy to forget to check for the empty string case
04:53:03 <kallisti> in situatons where you're building the structure though you have no reason to make that check. It's not like a steadfast rule I follow or anything.
04:53:22 <kallisti> perhaps a runtime error would be better in that case though
04:53:49 <ddarius> Seems like it would be to me.  Forgetting to update that "" to the actual value is a program error that should "never happen."
04:54:36 <ddarius> It's likely that the "" would just lead to a program error anyway down the line, though it could just lead to unexpected behavior.  Maybe your driver interprets "" as something meaningful.
04:55:29 <kallisti> well in some situations Maybe String seems unecessary when "" is almost the same as Nothing, and Just "" would never ever happen.
04:55:42 <kallisti> but of course it's not as type safe.
04:56:31 <ddarius> I agree that Maybe String seems unnecessary, but I don't see the value in using "" for unset out of a misguided desire to only write "total" values.
04:56:41 <kallisti> I may not be entirely consistent in my application of type safety over convenience and vice versa. :P
04:57:08 <ddarius> kallisti: You are suggesting something that is less convenient -and- less safe though.
04:58:41 <kallisti> the particular situation in which I'm thinking about involves a structure that contains WHOIS response data from an IRC server.
04:59:24 <kallisti> not every server implements the same responses or even have responses that mean the same things in a completely standard way. The responses are split up over many lines and have to be handled asynchronously.
04:59:50 <kallisti> so, at the moment, I'm not clear what should be a String and what should be a Maybe String, because I am not an expert of IRC servers.
05:00:24 <kallisti> so I just use String for now.
05:00:33 <donri> that sounds like a case for Maybe
05:00:49 <kallisti> yes most likely. I think some fields will be universal however.
05:00:58 <kallisti> at the end of the responses you will always have them.
05:02:18 <kallisti> the end result, regardless, is rather nice. you can completely ignore the asynchronicity in the calling code, and the whois request just becomes a kind of control flow construct.
05:02:55 <kallisti> whois irc nick $ \data -> ...
05:04:16 <kallisti> if everything were within Haskell and not involving the FFI with C, then I could probably use Cont or something to do it. but, unfortunately, instead I have to use top-level mutable variables. :P
05:04:39 <kallisti> such is life.
05:05:02 <donri> @hackage ircbot
05:05:02 <lambdabot> http://hackage.haskell.org/package/ircbot
05:13:02 <tigger> could someone help me understand how to free an object which is a pointer to pointers, If for instance I just had a :: (Ptr Int), I just use (free a), but If I have b :: Ptr (Ptr Int), and I know the length, I would traditionally iterate and free successively, then free b, but I'm not sure how to do it in haskell
05:13:23 <tigger> I couldn't find much googling "free pointer to pointer haskell"
05:14:57 <ddarius> tigger: You do exactly what you do in C.
05:16:13 <tigger> ddarius:: oh ok, so I can do pointer arithmetic like peek (b + 3) >> free, I wasn't sure if pointer arithmetic worked
05:23:45 <osa1> I'm getting Could not find module `Data.Map': error when I "import qualified Data.Map as Map", can anyone help me?
05:24:29 <mekeor> osa1: did you install the package which includes data.map ?
05:24:53 <osa1> mekeor: I'm not sure but I dont remember installing any packages
05:24:56 <ddarius> mekeor: That would be base.
05:25:01 <mekeor> oh =)
05:25:12 <ddarius> Well it might be containers now.
05:25:21 <osa1> Containers.Map ?
05:25:25 <mekeor> nono
05:27:02 <MaskRay> osa1: ghc-pkg list containers
05:27:24 <osa1> MaskRay: /usr/lib64/ghc-7.0.4/package.conf.d
05:30:38 <mekeor> osa1: ddarius meant that it could be possible that you have to install the containers-package (by "cabal install containers" or so). try that, if you want.
05:30:38 <osfameron> ooo, this looks fun: http://blog.ponoko.com/2012/02/09/solid-modeling-with-the-new-implicitcad/
05:30:38 <osfameron> especially the “Clobbering programming problems with gigantic mathematical hammers” tagline
05:30:38 <ddarius> osa1: How did you install GHC and what version are you using?
05:30:38 <osa1> ddarius: I think I installed it from my distro's package manager(I'm using openSUSE 11.4)
05:30:39 <osa1> ddarius: can installing newer version of haskell platform solve this?
05:31:18 <mekeor> the haskell-platform should include the package which contains Data.Map, i think. (but i'm nooby.)
05:31:35 <MaskRay> osa1: strange. it should also print something like `containers-0.4.2.1'
05:31:55 <ddarius> osa1: If you have the platform installed at all, then you should have containers.  In fact, I think it takes some doing to get a GHC without containers.
05:32:07 <osa1> whatever, I'm compiling latest version of haskell platform from source ..
05:32:33 <MaskRay> why not use binaries
05:32:37 <mekeor> that's exactly what i wanted to ask:
05:32:43 <mekeor> i installed Debian GNU/Linux testing now. i want to do everything right considering haskell, that is i dont want to get conflicts between cabal(-install) and apt. so, what's the best way to get haskell stuff? first of all, should/can i install GHC with APT, or should i download the binary?
05:32:43 <osa1> MaskRay: do we have binaries?
05:32:51 <mekeor> osa1: of course, yes.
05:33:23 <MaskRay> http://www.haskell.org/ghc/download_ghc_7_4_1#binaries
05:33:27 <dcoutts> mekeor: install core stuff (ghc / haskell-platform) with apt, install extra things not provided by debian using cabal
05:33:32 <osa1> MaskRay: thanks, downloading
05:35:14 <ClaudiusMaximus> get ghc with apt, use it to compile - afaik generic 7.4.1 binary doesn't work on debian testing (at least, i had problems..)
05:35:14 <ddarius> osfameron: My employer may find that interesting.
05:35:14 <osfameron> ddarius: who do you work for
05:35:14 <mekeor> ClaudiusMaximus: to compile what?
05:35:14 <osfameron> ?
05:35:14 <mekeor> osfameron: hehe, are you looking for a haskell-job?
05:35:14 <ClaudiusMaximus> mekeor: i used it to compile latest ghc
05:35:21 <mekeor> ClaudiusMaximus: but i could also use the binary...
05:35:39 <mekeor> ClaudiusMaximus: why not directly download the binary of GHC?
05:35:41 <MaskRay> i fought against dev-lang/ghc all day, exert all my efforts, did much dirty hacks and finally made it built
05:35:44 <ddarius> osfameron: I mean my employer as a person, not my employer as a company.
05:35:54 <ClaudiusMaximus> mekeor: i had some problems with wrong gmp version or something along those lines
05:36:00 <mekeor> MaskRay: gentoo?
05:36:12 <osfameron> mekeor: hehe, I'm nowhere near good enough, but it's always good to know who's interested in haskell (and in digital prototyping)
05:36:33 <mekeor> osfameron: i see.
05:36:55 <MaskRay> osa1: it used more than 3.5G space when it was finally built
05:37:01 <mekeor> dcoutts: so, should it work to install GHC and cabal with APT and the remaining stuff with cabal itself?
05:37:40 <dcoutts> mekeor: yes, look for the debian package for the Haskell Platform (includes GHC + core libs and tools)
05:38:02 <MaskRay> mekeor: yes
05:38:26 <osa1> MaskRay: and binary distribution is more than 100mb, I wonder why it's that big. I have lots of interpreters/compilers/language platforms installed my sytem and I think haskell is the biggest one
05:39:19 <mekeor> dcoutts: i'm going to "apt-get install haskell-platform", okay? i'm nervous/afraid/excited....
05:39:34 <osa1> MaskRay: oh, btw, the link you sent me was binary dist of haskell compiler, right? so after this I should install haskell platform
05:39:37 * dcoutts hopes it's actually called that in debian...
05:39:43 <MaskRay> osa1: its overall size is 792 MB, even larger than libreoffice
05:39:50 <MaskRay> osa1: its overall size is 792 MB on my box, even larger than libreoffice
05:39:52 <mekeor> dcoutts: yes. i looked it up.
05:41:40 <rostayob> mekeor: imho the GHC binaries are much better than the various distributions' binaries, any particular reason why you would want the debian ones?
05:42:03 <dcoutts> rostayob: "much better"? in what sense?
05:42:06 <mekeor> rostayob: no.
05:43:01 <MaskRay> osa1: larger than the total size of all the other interpreters/compilers installed on my system...
05:43:12 <osa1> MaskRay: are you sure this link is including compiled ghc?
05:44:09 <mekeor> osa1: i think, it ONLY include compiled ghc, doesn't it?  read the link ;)
05:44:19 <mekeor> s/include/includes/
07:54:22 --- topic: '["Haskell Platform 2011.4: http://bit.ly/Clv5r", "GHC 7.2 and cabal-install: http://is.gd/LXRBhh (all archs not just mac)", "Paste code/errors:  http://hpaste.org/new/haskell", "GHC 7.2.1: http://is.gd/IU2lRI", "Haskell News:  http://reddit.com/r/haskell", "The Haskell programming language http://haskell.org", "Logs: http://bit.ly/5mwtRQ",  "admin/spam issues: #haskell-ops"]'
07:54:22 --- topic: set by copumpkin!~pumpkin@unaffiliated/pumpkingod on [Sat Dec 17 14:06:48 2011]
07:54:22 --- names: list (clog eno lorandi ulfdoz Azel Itkovian CodeWeaverX MaciejP aartamonau teurastaja jem777 strangemonad wyfrn anRch corruptmemory synonymous e50138 smarter dzhus89 Shammah stephenjudkins warrenharris ablokzijl kallisti DanBurton RayNbow mreh_ Cromulent perspectival shintah odi snits shurikas jrslepak donri tncardoso dolio lpeterse danharaj posteverything pmaes tty7 pmade fryguybob PatrickRobotham jutaro ceii_ exlevan take_cheeze hughfdjackson mekeor whotemp)
07:54:22 --- names: list (Icewing RobertLJ ArchGT_ ceii bru` lambdanaut nighty_- RoXtein realitygrill PhilRod_ EvanR amathew ksf_ inr The_third_man ps-auxw anders^^ jakky mxweas pkrupp qubodup strmpnk hajimehoshi dom96 fcr ISF edon Twey smop }ElectrowolF{ moonlite pfn Gothmog_ johs Masxmasx{AFK} funktronic luite chr1s burp snetz_ totte_ obcode_ pr_ saati_ tobym timemage copumpkin guampa chra plutoniix milessabin petermw homie erkin danols dnjaramba buddyholly dschoepe MoALTz)
07:54:22 --- names: list (EarlGray^ roconnor nexx estebistec dimmy dsouza mschneider kmels flori jamii erochester johnsingleton KaneTW bytbox rtharper_ dwhj knoc kanak ptrf tigger akosch MrFahrenheit DasIch ace2001ac ville coeus soiamso Jonno_FTW adlan pen pgavin jklvxnasd vortexion` ftrvxmtrx tavelram kaf3ii hadriano dcoutts owst rostayob Lycurgus erus` asdfhjkl MichaelBurge ksion lorian noam_ Algorith rtharper ejackson rata_ overrosy jonke_ mceier rmunoz_ othiym23` fatih mnestic1)
07:54:22 --- names: list (monochrom nniro Rmx_ Yarou_ orbital_fox hey_lu Jeanne-Kamikaze jaspervdj gwicke Dashkal danvet shergill1 Sugarlake ccc jdnavarro isaacbw Blkt insomniaSalt Khisanth elnn bddn emmanuelux ivan\ gehmehgeh antilect stekro ngochai_ Palmik hirsch_ Redshift64 naneau tsuraan kshannon hvr pranq cynick mortberg elliottcable m3ga mmaruseacph2 scm vili darrint yitz kadoban dmwit pantski charro CrazyThinker mlh td123 wespee_ otto_s_ cdidd Philonous_ augur pikhq)
07:54:22 --- names: list (endojelly koala_man pommes_ mroman hash` jtannenbaum Flushot tgeeky aliak quintessence Ralith tomku cheater_ LordTrev vblm Kandu imphasin1 Cale master_of_master JaffaCake abbe jedai burbul theorbtwo jsk average_drifter Draconx|Laptop cubi yogurt_truck proq vvz_ gienah noddy2OOO [[zz]] magicman AfterDeath glguy shurane scooty-puff Cerise Martty hundskatt welterde iulian a11235 Philippa_ perlite Sgeo Jafet earthy Baughn Starfire amiri smorg BlankVerse)
07:54:22 --- names: list (EyesIsServer albel727 liyang rsimoes SamB_XP john7771 gbeshers Nanakhiel sunfun Zamarok cwb zax AtnNn willb Guest28547 overflow_0f8b i1126 eejaydubya xinming mjard deggis amiller emias ftrvxmtrx_ rglenn gwillen Ornedan Boxo lomeo mornfall `10 dflemstr gehho2 NiceOneBrah kleini__ Bwild mndrix floomp yeltzooo ice799_ blast_hardcheese SeanTAllen hpaste poucet_ mulletro1 MrNibbles djahandarie adnap_ davidL_ wingless_ electrog1ek nominolo_ tsuraan__ plat0 noj)
07:54:22 --- names: list (zeratul pyryp_ ben Number6 jlaire peterhil wunki petanqk Will| alistra tazjin|away mm_freak_ dMazzz m_stone_ ray avocado solarus saruman_ janne TacticalGrace solrize_ jrslepak_ ehamberg jeff_s_ cygnus__ shlevy s4msung_ Dave2 gemelen TML Vq r126f yoaha mwc Varakh nowhereman Nimatek byorgey confab ajhager newsham strlen CosmicRay macUzer Gunni Internet13 joeytwiddle snarkyboojum integral sm profmakx Raynes ibid stchang dumael sohum boyscared tlockney)
07:54:22 --- names: list (mrdomino hammi jabirali gabber bogner ddarius mercury^ chairdog gereedy thetallguy1 kvey ft ricky gwern ivan` end3r- mimi_vx jimleroyer helgikrs1 mapreduce ion Astro dju alexsdutton mrcarrot brandonw dabradley tomprince Muad_Dibber_ BlastHardcheese BRMatt Lemmih Ke reacocard quaestor CindyLinz mrd confound jayne Clint dilinger devn impl kloeri vmeson dogmaT kissyboy Tene cncl eyck mokus_ xnyhps Damn3d harlekin pettter prof7bit guerrilla chipdude shepheb)
07:54:22 --- names: list (daimrod vav Veinor exobit tempire Luke j2jxx Eliel dominikh joshc alpounet wilfredh_ alip MK_FG mee ricky26 torkjak chops parcs` dkannan liesen Entroacceptor bobry arnihermann minsa dmarkey akahn Apocalisp vithos mimico kakos rm34D Yahovah_ sagelywizard zorzar wavewave zenzike And[y] Laney Saizan aszlig saiam mjhan jonafan bartavelle gredman dino- repnop c2thunes ixzkn Razz levi etpace dropdrive Belgarion0 Ptival nkpart RogueShadow waern birkenfeld)
07:54:22 --- names: list (Derander_ tridactyla copton loccipocci brisbin nmodprime fei seats bford bradwright wagle stepnem DustyDingo hackagebot Nereid tessier FireFly Corey lpsmith mrshoe Nshag krakrjak andrewsw jd10 klugez zw01 ahf PreciousMetals saurik tamiko pcapriotti BMeph EgeBamyasi jix kalven nand` Gilly erg ski jlewis Intensity araujo lukish adimit almostsix SonicvanaJr Yacoby mauke mike-burns xsysstar ernst gdsx statusfailed ramier hiredman wires ClaudiusMaximus)
07:54:22 --- names: list (Gracenotes dax aninhumer Pseudonym speerfissure kosmikus McManiaC dev360 SimonRC saml demolithion Deewiant preflex niko yrlnry gltest_ joe9 noddy lokydor rby ousado skiold mysticc levitation_ Sunhay FalkoPeters lopex xrl si14 blooberr puzza007 Jaxan shutdown_-h_now robbert dmitrii lefant srcerer irene-knapp otterdam dp_wiz Boney chee1 zeiris flux felipe_ samek aib dqd brainproxy A1kmm tg bbee2 beat ubiquill idnar cjay opqdonut Younos antonh sp3ctum)
07:54:22 --- names: list (wayne[mobile] thorkilnaur znutar jml alang_ davv3 Enoria otters jbauman MostAwesomeDude xplat thetallguy brodo tromp__ schroedinbug1 dcoutts__ limetree drbean em ahihi2 sipa enobscuratus eZet [mth] tafryn dougransom kawantum olsner cmccann nicoo ybit vibowit dcolish otk davean matthiasgorgens sordina __class__ pdxleif_ Botje mateu suiside_ majoh scgilardi- ido_ neptunepink Solver Zarathu maurer Guest93070 cjackson ahkurtz_ frerich Amadiro Carmivore)
07:54:23 --- names: list (perimosocordiae _root_ wto waterlaz nighty- setmeaway brixen gerard0 gentz mbernstein frigga1 edwtjo elliottt tuv Shou- folone`` Maxdamantus donderom vold Innominate nyingen kolmodin SHODAN Valodim k0ral Blazeix milkpost DrSyzygy lnostdal dcguru sahazel_ bd_ PHO_ Jaak anachron Dybber elgot Vulpyne Mathieu mejalx dlmalloc hyko skaar jmcarthur jakeskik mikeplus64 koninkje_away biio jamiely_desktop Aikawa `0660 jbalint_ kate_r clsmith Mitar ocharles mjrosenb)
07:54:23 --- names: list (norm2782 pou szbalint mattp_ edwinb aleator jrib noplamodo freiksenet drdo atomicity sjl CoverSlide danr eviltwin_b robinbb froztbyte KitB Phlogistique yezariaely def-lkb nlogax ttvd mendez nihtml danm_ inimino ormaaj kyagrd zomg djanatyn flamingspinach _habnabit jrockway LeNsTR IvdSangen yottis arkx ve caligula_ warpy mantovan1 HalfWayMan cschneid Taggnostr2 Liskni_si tommd cods Nanar aristid milli fall_ @ChanServ BrianHV doubledensity hugin dannynn kaol)
07:54:23 --- names: list (smly- srh bezik idoru genivf dubellz twn jrk_ thirsteh acfoltzer ByronJohnson quicksilver pi8027 proqesi`` audunska nimred mietek lebastr fwg lispy sully sunnavy mike1703 jlouis sahn osfameron rwbarton ChristianS Counter-Strike brett marienz deavid tomaw wjlroe Axman6 adnam dixie_ guibou_ bcoppens taruti shachaf ciaranm ian_mi Obfuscate Draggor Enigmagic R496 rhodesd lusory lambdabot hpc nibalizer dreixel tomh maloi angstrom poindontcare strager iFire)
07:54:23 --- names: list (zygoloid int-e ziman zaero peddie Nibble jyyou Tinned_Tuna herself __main__ Igloo meanburrito920 ChongLi linduxed amagnus)
07:55:00 <djanatyn> I want to define some data types in Foo, and then use them in Foo.Bar
07:55:09 <djanatyn> but then import Foo.Bar whenever something imports Foo
07:55:15 <djanatyn> Is that possible, or am I thinking about things the wrong way?
07:56:07 <ski> hm, clog apparently lost 1 hour and 17 minutes there
07:56:16 <djanatyn> I'm defining an Entry data type for a little blog system.
07:56:23 <djanatyn> And then I want to define an Entry.Render
07:56:41 <djanatyn> so you would import Entry and then maybe import Entry.Render? I'm not sure how to go about this
07:56:48 <eviltwin_b> Foo can import Foo.Bar and then have "module Foo.Bar" in its export list
07:58:58 <quintessence> you can define the types in another module (Foo.Types) and then import that into both Foo and Foo.Bar to avoid the import cycle
08:02:20 <tromp__> you can look at my connect4 in haskell to see bitboards in action, kmels
08:03:09 <kmels> tromp__, is there an URL?
08:03:16 <jonkri> would it be nice to have something like Data.Email which provides a String -> Maybe Email function for e-mail validation?
08:03:34 <tromp__> google for tromp connect4
08:04:22 <tromp__> or for Fhourstones
08:05:09 <elliott> Why did we drop the Eq and Ord constraints from Num, but not the Num constraint from Bits?!
08:05:09 <kmels> tromp__, I found it, Connect4.java, right?
08:05:31 <tromp__> the tar file has versions in C,java, and haskell
08:07:23 <kmels> tromp__, sorry but I can't find it, would you mind pasting the link?
08:08:03 <tromp__> http://www.cwi.nl/~tromp/c4/fhour.html
08:08:24 <tromp__> tar files are near bottom
08:10:57 <tromp__> can anyone run haskell fhourstones on the latest ghc with fully optimized 64 bit code?
08:11:43 <tromp__> last time i tried it was over 10 times slower than java:(
08:12:12 <kmels> tromp__, oh that was not the first result google came up with, thanks.
08:12:23 <elliott> tromp__: yell "haskell sucks because this benchmark is 10 times slower than java" somewhere dons can hear it
08:12:27 <elliott> it'll be faster than C within a week
08:13:21 <cmccann> dons is too busy for that these days I think
08:13:44 <tromp__> i'll bet Don $100 he can't make it faster than C in a month...
08:14:00 <cmccann> unlike back when "getting your program added to the language shootout" was the best way to optimize Haskell code
08:14:25 <cmccann> or when people proposed -fvia-stackoverflow as a backend
08:14:30 <elliott> tromp__: that's a dangerous bet. is the C program parallel?
08:14:38 <tromp__> no
08:15:00 <tromp__> it's a sequential integer benchmark
08:15:52 <CodeWeaverX> I hope someone keeps an eye on haskell performance.  It'd be nice to at least claim some semblance of acceptable tradeoff between robustness, time to functional prototype, and performance.  Haskell's a positive influence on the adoption of functional programming into the mainstream programming world if nothing else.
08:17:10 <cmccann> I expect Haskell's performance is "good enough" anyway
08:17:39 <tromp__> this benchmark used to be slow because of using library calls for 64bit int ops
08:18:31 <elliott> cmccann: (btw, is your recent SO answer on types /intended/ to reveal the secret truth that Andreas Blass is Conor McBride?)
08:19:04 <cmccann> haha
08:19:13 <cmccann> no :P
08:19:30 <cmccann> though I suppose he could be, you never know with McBride
08:19:34 <cmccann> he's a bit eccentric
08:19:52 <elliott> the knights of the lambda calculus won't be pleased with you at all
08:20:08 <elliott> I'd get out of the country if I were you :)
08:22:16 * cmccann is pretty sure McBride was excommunicated from the Church of the Fixed Point for heresies involving total functions
08:22:25 <elliott> actually you didn't link to more than two papers so I have no idea where "same author" came from in the first place...
08:22:43 <elliott> cmccann: haha
08:22:47 <cmccann> in reference to a paper other people mentioned
08:22:56 <elliott> ohh
08:23:03 <elliott> my english parser is broken
08:23:22 <cmccann> i.e. McBride's original "derivative of a type" paper
08:23:34 <elliott> right
08:23:39 <cmccann> so yeah I guess that was less clear than it could have been
08:23:59 * hackagebot postgresql-simple 0.0.4 - Mid-Level PostgreSQL client library  http://hackage.haskell.org/package/postgresql-simple-0.0.4 (LeonSmith)
08:24:13 <cmccann> that "same author" was attached only to the immediately preceding bit, not the stuff about 7-tuples of trees
08:24:52 <cmccann> I probably should have cited byorgey in there as well just to confuse absolutely everything but sigfpe took care of that
08:25:55 <cmccann> (also, note that the second edit was added largely in response to acfoltzer's comment, which is another bit of unclear context, oh well)
08:26:24 <elliott> hmm, all the instances of Align I can think of either allow maybeMap or behave like a zip :(
08:26:32 <matthiasgorgens> Does somebody have an opinion on datalog?
08:26:38 <elliott> matthiasgorgens: it's cool
08:26:47 <cmccann> what's maybeMap again?
08:28:41 <elliott> (a -> Maybe b) -> f a -> f b
08:28:49 <elliott> i.e. the Kleisli Maybe to Hask map
08:28:53 <cmccann> ohhyeah
08:28:55 <cmccann> hm
08:28:59 * hackagebot nlp-scores 0.2.0 - Scoring functions commonly used for evaluation in NLP and IR  http://hackage.haskell.org/package/nlp-scores-0.2.0 (GrzegorzChrupala)
08:29:01 <elliott> or equivalently, a functor with f (Maybe a) -> f a
08:29:12 <elliott> "discarding" the parts of the structure with Nothing
08:29:26 <cmccann> well
08:30:23 <cmccann> what would it mean for an instance of Align to not allow maybeMap?
08:30:31 <ski> cmccann : seven-trees-in-one ?
08:30:47 <elliott> cmccann: instances that behave as regular zipping?
08:30:56 * ski wondered what the Blass relation was
08:30:59 <elliott> e.g. those with a fixed structure (although you need empty so it's a little tricky)
08:31:28 <cmccann> ski, are you asking what that's about, or asking if that's what I was talking about?
08:31:53 <cmccann> and yeah, aside from fixed structures, since those aren't likely to be interesting instances here
08:31:59 <ski> cmccann : the latter
08:32:07 <cmccann> ski, then yes
08:32:10 <elliott> cmccann: but it's interesting in that you can give unalign a stronger law with discard :: f (Maybe a) -> f a
08:32:51 <cmccann> ski, http://stackoverflow.com/q/9190352/157360 for the full context if you're wondering
08:33:05 <ski> cmccann : was just about to ask for that :)
08:33:09 <elliott> cmccann: fmap (bimap discard discard) (unalign (align f g)) = pure (f,g) -- there must be some way to express this without pure
08:33:27 <elliott> hmm
08:33:32 <cmccann> oh, by the way
08:33:39 <cmccann> empty causes name clashes
08:33:58 <cmccann> with Alternative
08:35:23 <elliott> yeah, I realised that but couldn't think of a better name :/
08:35:38 <cmccann> the worst part is that I suspect they could easily be the same thing
08:36:50 <cmccann> but obviously changing Alternative isn't possible and Align clearly can't have it as a constraint
08:36:53 <elliott> I suspect they coincide for any reasonable instance of both.
08:36:56 <cmccann> yeah
08:37:20 <elliott> oh well, lots of things clash with other things (<-- rationalisation because I can't think of anything better)
08:37:22 <elliott> ooh, ooh, wait!
08:37:25 <elliott> how about "null" :)
08:37:29 <cmccann> :t null
08:37:30 <lambdabot> forall a. [a] -> Bool
08:37:31 <elliott> ...wait, that clashes with Prelude. my joke is ruined
08:37:37 <cmccann> yeah
08:37:42 <elliott> "nil" could work, I guess
08:37:50 <hpc> :t nil
08:37:51 <lambdabot> Not in scope: `nil'
08:38:03 <cmccann> I mean I could replace it in Overture, which uses these, but I'd like these to stand on its own
08:38:09 <hpc> it has the added bonus of confusing the lispers
08:38:18 <cmccann> nil is good actually
08:38:30 <yitz> nada
08:38:33 <cmccann> I occasionally use nil as a name for things that behave like []
08:38:35 <elliott> tbh people seem a lot less worried about clashing with things nowadays because qualified/explicit imports are becoming so common
08:38:41 <elliott> but I guess clashing with Control.Applicative is pretty bad
08:38:47 <cmccann> well, personally
08:38:52 <elliott> nil is nice, I agree
08:38:54 <cmccann> I'd like to not clash with things I import everywhere
08:38:57 <elliott> yeah :P
08:39:23 <elliott> oh, another thought about discard: if you have discard, then all you need is any arbitrary value in f whatsoever to get nil
08:39:24 <cmccann> which basically means the non-awful parts of Prelude, Applicative, Monad, and Category
08:39:26 <elliott> nil = discard (Nothing <$ arb)
08:40:25 <elliott> what did we even /do/ before Control.Applicative?
08:40:37 <hpc> elliott: we apped
08:41:11 <elliott> btw, if anyone can think of an instance of Bialign let me know :P
08:41:15 <cmccann> haha
08:41:23 <elliott> I think \a b -> (Maybe a, Maybe b) is an instance
08:41:27 <elliott> but that's not even a standard named type
08:41:52 <cmccann> it is if you have functor products I guess
08:42:04 <cmccann> in case we want even more dependencies on abstract nonsense packages
08:42:47 <elliott> Don't tempt me.
08:43:58 <elliott> wait, no
08:43:59 * hackagebot monad-atom 0.3.0 - Monadically convert objects to unique atoms and back.  http://hackage.haskell.org/package/monad-atom-0.3.0 (GrzegorzChrupala)
08:44:01 <elliott> even that isn't an instance
08:44:02 * hackagebot nlp-scores 0.2.1 - Scoring functions commonly used for evaluation in NLP and IR  http://hackage.haskell.org/package/nlp-scores-0.2.1 (GrzegorzChrupala)
08:44:18 <elliott> oh hm
08:44:18 <elliott> yes it is
08:45:40 <cmccann> oh, speaking of abstract nonsense, were you the one mentioning that GArrow stuff earlier?
08:46:33 <elliott> yes
08:46:43 <elliott> well, I mentioned them to you when you complained about Arrow
08:46:46 <cmccann> yes
08:47:58 <cmccann> and after mulling it over I think that really is a sweet spot between the standard libraries vs. scaling the cliffs of edwardk's five hundred type classes
08:48:17 <cmccann> and might be useful for some stuff I'm working on
08:48:18 <elliott> hahaha
08:48:28 <cmccann> is there an implementation of that on hackage anywhere, do you know?
08:48:36 <ski> cmccann : hm, "Categories and Computer Science" by R. F. C. Walters mention the "crazy calculations" for `I + X + X^2 + X^3 + ...' for lists of `X', `I + X + ... + (1 / (n + 1)) * over (2 * n) n * X^n + ...' for binary trees, and `Sum_{n = 1}^inf (n * X^n)' for lists with a selected element
08:48:37 <elliott> well it's part of a GHC extension, so I doubt it
08:48:39 <cmccann> obviously without special support, but the classes and such.
08:48:59 <elliott> cmccann: but -- Bifunctor/Biapply from bifunctors can basically replace Arrow for many uses
08:49:11 <elliott> cmccann: I would probably recommend them over GArrows in the absence of compiler support
08:49:23 <ski> (using derivatives in the last case to derive `L = S * X * S' where `L' is this type of lists-with-selected-element and `S' is the type of lists (stacks) of `X')
08:49:27 <elliott> because (a) getting the instance resolver happy about things not being ambiguous is *really* painful in my experiments
08:49:53 <tty7> is there something like an "empty character", or do i have to use "" or []?
08:49:55 <elliott> and (b) avoiding the equivalent of arr tends to make code extremely confusing in hand-written form, since it's basically "product machine dataflow assembly language"
08:50:06 <ski> tty7 : there is no empty character, no
08:50:13 <tty7> i.e. i have to use String instead of Char if i want an empty value
08:50:18 <hpc> tty7: you would
08:50:19 <tty7> okay, thanks, ski
08:50:21 <hpc> or Maybe Char
08:50:22 <ski> tty7 : or `Maybe Char'
08:50:22 <elliott> cmccann: but yes, it would be nice if just the classes were on hackage
08:50:23 <tty7> thanks hpc
08:50:26 <cmccann> elliott, I have a lot of practice coaxing GHC into figuring out instances :P
08:50:29 <elliott> but I don't think they are
08:50:33 <tty7> okay
08:50:35 <rwbarton> > "Hel\&lo"
08:50:36 <lambdabot>   "Hello"
08:50:43 <hpc> you can also cheat a bit:
08:50:48 <hpc> '\0'
08:50:49 <ski> tty7 : or, if you *know* some specific `Char' won't appear, you can use that ..
08:50:50 <hpc> > '\0'
08:50:51 <lambdabot>   '\NUL'
08:50:54 <elliott> cmccann: you have no idea
08:51:01 <ski> but it might be clearer to use `Maybe Char', regardless
08:51:07 <tty7> ski: no, i want to return it as a result
08:51:12 <cmccann> ski, and yeah, that's a well-known trick from the combinatorics side, isn't it?
08:51:17 <elliott> cmccann: this is a three-parameter, completely fundepless typeclass, where you usually have to use multiple selections of the latter two parameters for the first, in the same definition
08:51:19 <tty7> sure. filtering would be even better in my case, i think
08:51:31 <elliott> also, local function annotation often simply doesn't work for reasons I was too confused to understand
08:51:51 <ski> tty7 : so, if you e.g. know you won't ever give  '\0'  as a normal result, you *could* use that
08:51:53 <tty7> i want to take a String as the input and return only the letters in it, uppercased
08:52:07 <ski> ok
08:52:23 <cmccann> elliott, the category and bifunctor should determine the identity
08:52:24 <tty7> the best would probably be to filter for letters first
08:52:26 <cmccann> at least I would hope so
08:52:28 <elliott> yeah, (Maybe x Maybe) is a Bialign
08:52:36 <hpc> > filter isLetter . map toUpper $ "i think this works"
08:52:38 <lambdabot>   "ITHINKTHISWORKS"
08:52:41 <elliott> cmccann: they don't (also, the product is not necessarily a Haskell bifunctor)
08:52:44 <ski> cmccann : which of them ?
08:52:51 <hpc> :t filter isLetter . map toUpper
08:52:52 <lambdabot> [Char] -> [Char]
08:52:59 <tty7> well, i just started writing my own isLetter and toUpper ;)
08:53:10 <ski> > filter (isLetter . toUpper) "i think this works"
08:53:12 <lambdabot>   "ithinkthisworks"
08:53:28 <elliott> cmccann: a type family based thing to determine the product, identity, and exponential are provided to "simplify" things, but it's so "simple" that it means you couldn't, e.g. use the equivalent of Arrow and ArrowChoice on the same arrow
08:53:36 <hpc> ski: filter p x returns a subset of x :P
08:53:38 <tty7> > toUpper $ filter isLetter "this should work as well"
08:53:39 <lambdabot>   Couldn't match expected type `GHC.Types.Char'
08:53:39 <lambdabot>         against inferred type...
08:53:49 <tty7> > map toUpper $ filter isLetter "this should work as well"
08:53:50 <lambdabot>   "THISSHOULDWORKASWELL"
08:53:57 <cmccann> elliott, well, I guess I'd have to try it and see, but it doesn't look any worse than stuff I've written before
08:54:05 <ski> cmccann : i've heard that this is related to the theory of species by Andr Joyal, but last i tried i didn't manage to find any of his papers
08:54:12 <cmccann> elliott, I mean, you realize how much dumb type hackery I've played with, right? :P
08:54:28 <hpc> > toUpper .: filter isLetter "if you are a snob and/or lambdabot"
08:54:29 <lambdabot>   Couldn't match expected type `g GHC.Types.Char'
08:54:29 <lambdabot>         against inferred ty...
08:54:32 <ski> hpc : yes ?
08:54:33 <elliott> cmccann: yeah, I was only recommending it if you were trying to do something that you actually wanted to work :P
08:54:36 <cmccann> ski, I don't know the specifics, sorry. ask byorgey about it sometime.
08:54:37 <hpc> :(
08:54:48 <elliott> cmccann: oh, duh, the product of every align is a bialign
08:54:55 <hpc> oh well
08:55:02 <elliott> cmccann: ...what's your favourite functor combinators package? :D
08:55:11 <cmccann> how about functor composition of Align instances?
08:55:22 <cmccann> uh, well
08:55:24 <cmccann> thing is
08:55:26 <hpc> > toUpper .: filter isLetter $ "i need to learn order of operations"
08:55:28 <lambdabot>   "INEEDTOLEARNORDEROFOPERATIONS"
08:55:40 <cmccann> functor combinators are usually faster to reimplement than search for on hackage :[
08:55:43 <cmccann> so I have no idea
08:56:09 <elliott> haha
08:56:16 <cmccann> I guess see if edwardk has some since that's more likely to come with lots of instances
08:56:17 <elliott> I usually use Conal's functor-combo
08:56:20 <elliott> but maybe edwar- yeah :D
08:56:21 <tty7> :t map toUpper . filter isLetter
08:56:22 <lambdabot> [Char] -> [Char]
08:56:34 <elliott> @ask edwardk do you have a package with functor combinators?
08:56:34 <lambdabot> Consider it noted.
08:56:43 <elliott> also functor-combo depends on lub
08:56:44 <hpc> there's no empty characters there, just strings that get shorter
08:56:52 <elliott> which is just a bit too scary for a library based on a simple algebraic type i think
08:56:58 <tty7> yep. that's okay :)
08:56:59 <hpc> *a string
08:57:01 <hpc> :P
08:57:05 <cmccann> haha
08:57:22 <keep_learning> Hello all
08:57:33 <ski> i'd also like to read "Combinatorial Species and Tree-like Structures" by Franois Bergeron,Gilbert Labelle,Pierre Leroux in 1997 at <http://bergeron.math.uqam.ca/Species/especes.html>
08:57:47 <tty7> which module exports toUpper and isLetter?
08:57:48 <cmccann> elliott, wait
08:57:56 <cmccann> transformers has some
08:57:56 <hpc> tty7: Data.Char iirc
08:58:00 <hpc> @hoogle isLetter
08:58:01 <lambdabot> Data.Char isLetter :: Char -> Bool
08:58:06 <elliott> cmccann: ha, I just switched to this workspace to say that
08:58:11 <elliott> instance time!
08:58:13 <cmccann> :D
08:58:19 <tty7> thanks :)
08:58:25 <tty7> @hoogle toUpper
08:58:25 <lambdabot> Data.Char toUpper :: Char -> Char
08:58:25 <lambdabot> Data.Text toUpper :: Text -> Text
08:58:26 <lambdabot> Data.Text.Lazy toUpper :: Text -> Text
08:58:27 <keep_learning>  I am trying to install latest version of doh-examples but i am getting this error "you need clang installed to use the LLVM backend". I am using Mac 10.7.3 and Xcode 4.2.1
08:58:37 <elliott> cmccann: also http://hackage.haskell.org/packages/archive/comonad-transformers/2.0.3/doc/html/Data-Functor-Coproduct.html
08:58:49 <keep_learning> Could some one please tell me how to install clang on mac.
08:58:50 <tty7> :k Text
08:58:51 <lambdabot> Not in scope: type constructor or class `Text'
08:58:58 <tty7> :t Data.Text.toUpper
08:58:59 <tromp__> > 103919148791293834318983090438798793469  `mod` (2^64)
08:58:59 <lambdabot> Data.Text.Internal.Text -> Data.Text.Internal.Text
08:58:59 <lambdabot>   14114520109454678781
08:59:24 <hpc> keep_learning: http://clang.llvm.org/get_started.html
08:59:37 <hpc> mac is unix-like, in theory
08:59:41 <hpc> so follow the top instructions
09:00:01 <elliott> but xcode also ships with clang
09:00:10 <elliott> cmccann: I really wish GHC's redundant import stuff would tell you where the other import is from >_<
09:00:18 <elliott> of stuff that the module exports but is imported from elsewhere too
09:00:39 <tty7> :t elemIndex
09:00:40 <lambdabot> forall a. (Eq a) => a -> [a] -> Maybe Int
09:00:53 <cmccann> elliott, yeah no kidding
09:00:55 <hpc> keep_learning: oh wait, derp
09:00:55 <hpc> keep_learning: http://llvm.org/releases/download.html#svn -- release versions
09:00:59 <jedai> keep_learning: Did you install XCode ? It's a pretty good idea, whatever development you'll do later
09:00:59 <hpc> (clang.llvm.org is a poorly organized website...)
09:01:06 <elliott> oh, wait
09:01:14 <elliott> they were unused because i didn't add the instance declarations yet
09:01:16 <elliott> hahaha
09:01:21 <keep_learning> jedai, yes I am using Xcode 4.2
09:02:22 <elliott> cmccann: oh, no, (Product f g) isn't a Bialign instance; wrong kind
09:02:25 <elliott> but it's probably an Align instance
09:02:28 <jedai> keep_learning: Are you sure you did install it (the market only download the installer), I would think that Clang would be included
09:02:29 <tty7> @hoogle elemIndex
09:02:29 <lambdabot> Data.List elemIndex :: Eq a => a -> [a] -> Maybe Int
09:02:29 <lambdabot> Data.ByteString.Char8 elemIndex :: Char -> ByteString -> Maybe Int
09:02:29 <lambdabot> Data.ByteString.Lazy.Char8 elemIndex :: Char -> ByteString -> Maybe Int64
09:03:01 <jedai> keep_learning: In fact I'm sure it is included
09:03:05 <cmccann> elliott, oh yeah, true
09:03:59 <elliott> f (g a) -> f (g b) -> f (g (These a b))... hmm
09:04:05 <keep_learning> jedai, I think I downloaded and double clicked to install it.
09:06:12 <rostayob> http://skitch.com/sogrady/g97x7/dataists-020711 , well, this is not bad at all!
09:06:14 <keep_learning> jedai, I can see this /Developer/Platforms/MacOSX.platform/Developer/Library/Xcode
09:07:28 <byorgey> rostayob: I'd actually like to see a log-log graph of that using actual numbers of projects and SO questions, instead of just using the rankings
09:07:56 <byorgey> ranking seems a funny thing to put on an axis.
09:09:25 <ski> "Species: a modern approach to combinatorics." (slides) by Franois Bergeron in 2005-04 at <http://bergeron.math.uqam.ca/Species/especes.html>
09:09:31 <rostayob> byorgey: I guess. still, it's something :)
09:09:51 <jedai> keep_learning: Well clang is included, so either it's installed but ghc doesn't find it (not on the path ?) or you just have an installer still not installed (did you use XCode yourself ?)
09:09:52 <rostayob> I really wouldn't have expected Haskell to be that high
09:10:21 * ski wonders whether any of Joyal's papers are in english, and online
09:10:48 <keep_learning> jedai, No I don't use Xcode. In fact I  just started using Mac couple of moths ago.
09:11:03 <elliott> keep_learning: you need to install Xcode to get compilers and such
09:11:14 <elliott> ok, I'm offering a prize to anyone who can think of a concrete Bialign instance that doesn't depend on another one
09:11:22 <elliott> the prize is it being included in Data.Align
09:17:50 <elliott> byorgey: SO questions is an odd metric, I think
09:17:58 <elliott> considering how many of them are homework :P
09:18:15 <elliott> but I guess that is "popularity" in a sense
09:18:58 <jedai> elliott: That would still be an indicator of how many people are learning Haskell now which would implicate a lot about the future :)
09:19:05 <jedai> O could...
09:19:11 <jedai> *or
09:19:44 <elliott> jedai: you think most people who have to learn haskell for school keep using it later on?
09:19:50 <cmccann> Haskell isn't the most active functional programming language tag on SO, I don't think
09:19:55 <cmccann> for what that's worth
09:20:07 <elliott> if that was the case, Scheme would have been pretty damn popular a while back
09:20:15 <jedai> elliott: I think if more people do learn it now, more people will know it later and may be tempted to use it
09:20:31 <elliott> [scala] has more questions, at least
09:20:35 <byorgey> elliott: it is a somewhat odd metric, but I guess the idea is that it gives you some sort of indication of "interest" in a programming language (as distinct from "use")
09:20:45 <byorgey> I don't know any better ways of measuring that.
09:20:57 <elliott> jedai: To be perfectly honest, I think a good number of schools that teach Haskell probably put the students off it for life.
09:20:59 <ski> "Why is Algebraic Combinatorics so Hot?"/"Pourqui la combinatoire algbraique est-elle si cool?" by Franois Bergeron at <http://bergeron.math.uqam.ca/petit_Web.pdf>
09:21:06 <keep_learning> jedai, I have reinstalled the Xcode but still same error.  After installing Xcode 4.2 I got error no llvm found then I installed llvm using brew install llvm and problem solved for ghc-7.2.1
09:21:24 <elliott> How many people come out of Scheme classes thinking it's all about recursion and you can't write actual programs with it because it's just functions and the like?
09:21:30 <elliott> Also, they use Hugs, man. Hugs!
09:21:35 <elliott> byorgey: yeah
09:21:36 <keep_learning> and now with ghc-7.4.1 again I back to error in installation.
09:21:39 <byorgey> ski: nice
09:21:45 <byorgey> ski: every slide seems to be in a different language though
09:21:57 <tty7> @hoogle random
09:21:57 <lambdabot> System.Random class Random a
09:21:58 <lambdabot> System.Random random :: (Random a, RandomGen g) => g -> (a, g)
09:21:58 <lambdabot> package random
09:22:05 <tty7> @hoogle mix
09:22:06 <lambdabot> package alsa-mixer
09:22:06 <lambdabot> package JackMiniMix
09:22:06 <lambdabot> package jackminimix
09:22:10 <tty7> @hoogle shuffle
09:22:10 <lambdabot> package random-shuffle
09:22:14 <ski> byorgey : i only noticed english and french
09:22:20 <byorgey> ski: there's also German
09:22:28 <ski> oh, you're right
09:23:01 <byorgey> the backgrounds are also really distracting =P
09:23:26 * ski just got a plain background
09:25:16 * cmccann thinks that plot rostayob linked to mostly shows the ratio of "SO users who need to use language X" to "new and active open source hacking in language X"
09:26:33 <elliott> oh, that graph actually shows SO already
09:26:37 <elliott> I thought byorgey was just suggesting it
09:26:44 <quintessence> Turns out it's a pretty close correlation
09:28:14 * cmccann figures you can read above the diagonal as "practical but no fun" and below the diagonal as "fun but useless", for the sake of trolling at least
09:29:44 <elliott> the Io and Rust points are interesting
09:30:04 <cmccann> yeah
09:30:09 <quintessence> Rust is a file extension collision with something else that uses .rc I think
09:30:10 <jedai> cmccann: Wouldn't that be the inverse, people posting question on fun languages and using more of the practical but not fun ?
09:30:11 <elliott> I guess most people using Rust already know what they're doing in general, and there's not really much Q&A to be had since it's so new
09:30:18 <elliott> quintessence: oh, Windows resources I think
09:30:37 <cmccann> jedai, no, github is going to be skewed toward hobbyists and random tinkering
09:30:46 <elliott> cmccann: I think the Io data point is a mistake too
09:30:53 <elliott> http://stackoverflow.com/questions/tagged/iolanguage 21 questions
09:30:57 <elliott> http://stackoverflow.com/questions/tagged/io >2k questions
09:31:02 <cmccann> yeah sounds like it
09:31:04 <elliott> I bet they measured the latter :)
09:31:07 <jedai> cmccann: And SO is only for practical, no fun questions ?
09:31:24 <elliott> SO doesn't like questions that are *too* fun ;)
09:31:28 <cmccann> jedai, it leans that way slightly
09:31:31 <cmccann> and yes, no fun allowed
09:31:34 <jedai> True :)
09:31:49 <cmccann> fun = "closed as not constructive"
09:32:00 <elliott> or too localised
09:32:05 <Jafet> Stack Overflow is dominated by questions from people who need to do something and have no idea how to do it
09:32:13 <hpaste> keep_learning pasted “error in dph-examples installation library on mac os x version 10.7.2” at http://hpaste.org/57687
09:32:14 <cmccann> Jafet, yeah, that's what I was getting at
09:32:14 <elliott> (actually people seem to close as too localised far less than they should)
09:32:22 <elliott> (imo)
09:32:36 <cmccann> elliott, yeah
09:32:47 <cmccann> though the most egregious cases tend to be bad questions anyway
09:32:52 <cmccann> and get a mixture of close votes
09:32:54 <eviltwin_b> keep_learning, XCode does not include the full LLVM suite
09:32:56 <quintessence> http://stackoverflow.com/questions/tagged/fun: one third as popular as FORTRAN
09:32:56 <elliott> well... I guess a lot of such questions will help those with the same homework in the future :D
09:33:09 <cmccann> I think I once saw a question that was closed without any two reasons being the same
09:33:10 <eviltwin_b> you need to get and install that from somewhere else
09:33:25 <elliott> quintessence: heh, it's one of those tags that's a list of questions to be closed
09:33:33 <keep_learning> eviltwin_b, I tried it using brew install llvm
09:33:51 <cmccann> or a tag that just needs to be burninated
09:33:54 <elliott> "The only criteria for questions to be under this tag is that it should bring "smiles"" -- awesome, I'm going to tag everything [fun] from now on
09:34:00 <cmccann> (that's a technical term fyi)
09:34:11 <keep_learning> Should I download it and install it manually ?
09:34:33 <eviltwin_b> I can't help with homebrew, but you may need to force $PATH or something to make sure whatever you're building finds the correct clang etc.
09:36:24 <elliott> oh dear, reducers has a lot of dependencies
09:36:50 <deech> Hi all, I have a style question. I have a list of triples [(x,y,z)] and I want to sort them by 'z' which is already an instance of Ord. Is there a better way of doing this than making (x,y,z) a datatype and an instance of Ord?
09:37:15 <Jafet> :t sortBy
09:37:16 <lambdabot> forall a. (a -> a -> Ordering) -> [a] -> [a]
09:37:17 * cmccann considers creating an edwardk-extras package that simply depends on everything of his, might save some time in the end
09:37:35 <cmccann> category-extras doesn't have everything after all
09:37:38 <Jafet> :t comparing (\(_,_,z)->z)
09:37:39 <lambdabot> forall t t1 t2. (Ord t2) => (t, t1, t2) -> (t, t1, t2) -> Ordering
09:37:54 <deech> Jafet: thanks!
09:37:58 <elliott> cmccann: just make a unified haddock for all of edwardk's stuff like the haskell platform library docs :P
09:37:58 <edwardk> cmccann: yeah. dmwit wanted to limit it to mostly what was in category-extras
09:37:58 <lambdabot> edwardk: You have 1 new message. '/msg lambdabot @messages' to read it.
09:38:21 <CodeWeaverX> *wafts the scent of fresh coffee over the chatroom*
09:38:28 <edwardk> elliott: the various functor combinators from category-extras have not found a new way to live
09:38:31 <edwardk> they were really hard to use
09:38:41 <edwardk> and let roconnor to make a lambdabot plugin iirc ;)
09:38:44 <edwardk> er led
09:38:59 <edwardk> to try to desugar combinations of them
09:39:06 <cmccann> haha
09:39:17 * cmccann never did figure out how to read all that Biff whatever nonsense
09:39:22 <edwardk> hah
09:39:23 <rwbarton> they led me to write something that used reify from TH to expand all the newtypes in a type
09:39:34 <edwardk> yeah
09:39:37 <rwbarton> when I was trying to use the free monad or something like that
09:39:43 <elliott> edwardk: thankfully I just needed simple enough stuff that transformers already has it
09:39:45 <cmccann> rwbarton, that actually sounds useful, did you upload that anywhere?
09:39:49 <edwardk> oh yeah coz free was built on PFree or something
09:39:50 <elliott> although I think there might be a Coproduct instance too
09:40:00 <rwbarton> cmccann: I think so, though it only sort of worked
09:40:08 <edwardk> some of the others are in comonad-transformers
09:40:13 <elliott> only one, no?
09:40:16 <edwardk> coproduct,e tc.
09:40:24 <elliott> plus http://hackage.haskell.org/packages/archive/comonad-transformers/2.0.3/doc/html/Data-Functor-Composition.html
09:40:25 <rwbarton> cmccann: https://github.com/rwbarton/oldtype/blob/master/Language/Haskell/Oldtype/Oldtype.hs
09:40:28 <elliott> which isn't really a combinator :P
09:40:43 <edwardk> and coproduct
09:40:51 <edwardk> no biffs, jokers or clowns ;)
09:41:14 <edwardk> one of the reasons i took over mtl was to move some of that out of comonad-transformers and into transformers where it belongs
09:41:18 <rwbarton> cmccann: it got tricky when I tried to handle recursive newtypes nicely
09:41:25 <edwardk> but then ross held on to transformers, so i really haven't been able to do anything
09:41:29 <cmccann> rwbarton, yeah, makes sense
09:41:31 <edwardk> since any change needs to start from him
09:41:45 <elliott> edwardk: I support your hostile takeover of the entire ecosystem
09:42:01 <elliott> edwardk: start your own hackage, and make all your packages use custom build scripts that set cabal-install to use it :D
09:42:05 <tty7> if i run through a list using a recursive function like myFct part1 part2 = myFct (part1 ++ head part2) (tail part2), would it be better to do myFct (head part2 : part1) (tail part2) instead, and reverse the part1 list at the end?
09:42:10 <edwardk> hah
09:42:19 <edwardk> nah, just going to slowly continue writing my haskell compiler ;)
09:42:40 <edwardk> then i can have an answer for the haskell' stuff that requires an idea to already be implemented =P
09:43:05 <cmccann> how much of that compiler exists so far?
09:43:14 <edwardk> now that work is winding down on our in house language i can devote more time to it
09:43:33 <edwardk> well, i built a type error slicer for ghc-style polymorphic kinds, but then i wanted to generalize it to use my revision control monad
09:43:45 <tty7> in other words: for a list of length n, is it better to concat n times (i.e. a ++ b with length of a from 1 to n) or to do h : b n times and reverse once?
09:43:49 <edwardk> and i haven't figured out a good way to get 'record' into that
09:43:55 <edwardk> so it stalled out on getting that fixed up
09:43:59 <tty7> i feel the reverse-thing would be more efficient, but i am not sure
09:44:01 * hackagebot pandoc 1.9.1 - Conversion between markup formats  http://hackage.haskell.org/package/pandoc-1.9.1 (JohnMacFarlane)
09:44:16 <edwardk> with a recordable rev monad, i could do slicing REALLY fast
09:44:28 <rwbarton> tty7: appending a single element with (++) n times is O(n^2) so don't do that
09:44:46 <edwardk> because i could recycle most of the previous attempt at type checking as i pull away constraints one at a time
09:44:49 <tty7> rwbarton: thanks for confirming :) that's what i thought
09:45:07 <edwardk> but for that i really want a nicer locally nameless representation
09:45:23 <edwardk> so i basically stripped it down to a handful of types and compiler plumbing
09:45:33 <edwardk> ok, more than a handful
09:45:50 <edwardk> once i get back to the revision monad i'll take another whack at it
09:46:46 <jfischoff> hey edwardk, what are some of your design goals for compiler?
09:47:04 <jfischoff> would it doing any ghc can't do?
09:47:05 <elliott> tty7: you probably want a differnce list
09:47:07 <elliott> *difference
09:47:18 <elliott> represent [a] as ([a] -> [a]), "foo" becomes ("foo"++)
09:47:20 <elliott> concatenation is (.)
09:47:22 <edwardk> jfischoff: i have a number of compiler technologies i keep playing with in isolation that i want to put together
09:47:25 <elliott> turn into a list by applying to ""
09:47:38 <jfischoff> cool
09:48:10 <edwardk> jfischoff: i have a tracing jit that has been screaming for me to apply it to a spineless tagless g-machine. i keep playing with the approach from rob ennal's thesis for optimistic evaluation, which was based on changes to the ghc runtime system that were too invasive
09:48:29 <edwardk> and the tracing jit can replace the strictness analysis and unboxing pass at compile time, moving them to runtime profiling
09:48:49 <jfischoff> ah
09:49:00 <edwardk> i've also been focused on prettier parse errors with trifecta, and on type error slicing in the type checker, which would make it so that i never show you a type i make up
09:49:02 * hackagebot rad 0.1.6.2 - Reverse Automatic Differentiation.  http://hackage.haskell.org/package/rad-0.1.6.2 (EdwardKmett)
09:49:03 <jfischoff> thanks hadn't heard of a tracing jit before
09:49:04 * hackagebot monadic-arrays 0.2.0.2 - Boxed and unboxed arrays for monad transformers  http://hackage.haskell.org/package/monadic-arrays-0.2.0.2 (EdwardKmett)
09:49:06 * hackagebot th-lift 0.5.5 - Derive Template Haskell's Lift class for datatypes.  http://hackage.haskell.org/package/th-lift-0.5.5 (MathieuBoespflug)
09:49:35 <elliott> edwardk: oh, that strictness jit sounds really cool
09:49:40 <elliott> edwardk: when do i get to play with it?!
09:49:42 <edwardk> which means i can greatly streamline the compiler internals and simultaneously give you errors that highlight every fragment of code that could possibly be contributing to the error
09:49:55 <elliott> I like that edwardk is uploading packages to Hackage even while chatting on IRC :D
09:50:21 <edwardk> i also have a slightly smarter polymorphic kind/constraint kind variant that i want to show off in a full compiler
09:50:59 <quintessence> hmm, a tracing jit would also probably with specializing away dictionaries
09:51:11 <edwardk> quintessence: exactly
09:51:29 <quintessence> (I also probably the word "help")
09:51:46 <edwardk> it works out remarkably well. i was working on one for ghc when matt morrow left and i lost my oracle into the internals of ghc bytecode
09:52:12 <edwardk> i however have passed the torch and a pile of info onto ed yang, so hopefully we'll see something ;)
09:52:29 <Nibble> dom96: hey! Nirmod made it to redmonk language rankings!
09:52:40 <edwardk> the main thing is a tracing jit can turn indirect jumps into direct jumps and the STG does two indirect jumps for _every_ thunk evaluation
09:53:02 <dom96> Nibble: Yes, I know.
09:53:05 <edwardk> so it provides a nice model for getting efficient straightline code out of stg indirect jump messiness
09:53:35 <edwardk> which is a big deal since indirect jumps stall pipelines really badly
09:54:02 * hackagebot stable-maps 0.0.3 - Heterogeneous maps keyed by StableNames  http://hackage.haskell.org/package/stable-maps-0.0.3 (EdwardKmett)
09:56:49 <dom96> Nibble: And learn to spell Nimrod.
09:57:46 <elliott> Isn't Nimrod that language where foo_bar = foO-BAR?
09:59:04 * hackagebot charset 0.2.3 - Fast unicode character sets based on complemented PATRICIA tries  http://hackage.haskell.org/package/charset-0.2.3 (EdwardKmett)
09:59:06 * hackagebot monoids 0.3.2 - Deprecated: Use 'reducers'  http://hackage.haskell.org/package/monoids-0.3.2 (EdwardKmett)
09:59:07 <dom96> elliott: no. It's underscore insensitive not dash and underscore insensitive.
10:00:42 <elliott> dom96: that's slightly better I suppose :P
10:01:19 <dom96> I don't see a problem with it being that way.
10:02:12 <elliott> perhaps not :)
10:03:43 * cmccann makes a language that's insensitive to similar-looking glyphs
10:03:52 <cmccann> so that l and I and 1 are all the same
10:03:57 <cmccann> but L and i are different
10:04:02 <cmccann> that'd be reasonable, right?
10:04:30 <zzo38> cmccann: Go on #esoteric and discuss that if you want to do things like that
10:05:04 <byorgey> cmccann: the problem is that "looks similar to" is not transitive
10:05:30 <zzo38> I could probably add dependent defaults in my extensible products implementation by having   defaultValue :: p -> a -> ExtProdF a;   but still seem it probably will be inefficient; how inefficient is my implementation anyways? I could also make up a extensible sums implementation too I suppose
10:05:37 <zzo38> byorgey: Yes I think you are correct
10:05:45 <byorgey> shades of the sorites paradox.
10:06:08 <zzo38> O yes it is like a sorites paradox
10:06:14 <cmccann> byorgey, it also depends on the font
10:06:26 <byorgey> cmccann: also true
10:06:28 <zzo38> Yes and that too
10:06:37 <byorgey> cmccann: so I guess your language would have to detect what font you are using
10:06:45 <cmccann> nah, it'd be a compiler flag
10:06:49 <cmccann> keep things simple
10:07:03 <byorgey> oh, I see   --font='Comic Sans'
10:07:07 <cmccann> yep
10:07:10 <byorgey> cool
10:07:16 <byorgey> sounds reasonable
10:07:23 <cmccann> yeah
10:07:37 <zzo38> 'cmr10.600gf'
10:07:39 <cmccann> would probably use EWD.ttf for all the standard libraries, I think
10:07:45 <cmccann> that'd look nice
10:07:52 <magicman> And then to write a program that needs every module compiled with a different --font flag.
10:08:14 <zzo38> I prefer METAFONT fonts but you can use TrueType or whatever else you prefer
10:08:32 <quintessence> why not have source files be html, then you can use stylesheet rules to change your font by lexeme type
10:08:34 <elliott> cmccann: you could embed the fonts in the program source
10:08:43 <elliott> and have emacs automatically load them
10:08:46 <elliott> so that other people can read and write code without downloading fonts
10:08:55 <cmccann> elliott, yeah but I'd rather not require that
10:09:53 <KorriX> Does anybody know how to staticaly build happstack application (i mean compile to binary that will run on server without ghc) ?
10:11:00 <c_wraith> KorriX: compiling it should do that, unless it's linking in the ghc api for doing dynamic loading
10:11:42 <KorriX> dynamic linking is problem
10:12:35 <zzo38> Will changing strictness or pragmas or stuff change the efficiency of my implementation of extensible product types?
10:13:25 <c_wraith> I don't know happstack in particular, but it's the case with Snap that it's just a build flag (to cabal) to disable (well, enable in the first place) dynamic loading.
10:14:08 <c_wraith> Hmm.  That assumes you used the project skeleton snap provides, though.  I'm not sure if happstack does something like that.
10:14:30 <elliott> KorriX: -optl-static -optl-lpthread
10:14:41 <elliott> KorriX: But it only links to GMP.
10:14:51 <elliott> So dynamic linking shouldn't be a problem on all but the most bare-bones of servers.
10:15:48 <c_wraith> dynamic linking *shouldn't* be a problem.
10:16:07 <c_wraith> statically linking the ghc api in, on the other hand, is guaranteed to be a problem, if you want to run without ghc
10:16:32 <zzo38> I uploaded a package is there supposed to be a message here about it?
10:16:46 <c_wraith> because the ghc api will depend on package being installed and registered properly
10:18:41 <zzo38> How can I tell cabal that a package is a preprocessor used with -pgmF options, so that it can install to be used like that?
10:19:03 * hackagebot hampp 0.2 - Haskell macro preprocessor  http://hackage.haskell.org/package/hampp-0.2 (AaronBlack)
10:19:13 <zzo38> O there, now it came on.
10:19:49 <byorgey> zzo38: there's nothing special about installing things so they can be used with -pgmF, any executable can be so used.
10:20:11 <tux_mark_5> hello
10:20:19 <byorgey> hi tux_mark_5
10:20:31 <tux_mark_5> is anyone here familiar with XHB?
10:21:04 <zzo38> byorgey: But doesn't it have to be in PATH or something like this?
10:21:32 <byorgey> zzo38: well, of course, but that's again true of any executable you want to use.  And it's also not cabal's problem.
10:22:02 <byorgey> cabal will install executables wherever it has been configured to install executables.
10:22:31 <byorgey> each person should set up their own cabal config to install executables somewhere on their $PATH.
10:22:52 <byorgey> so it's not something you, the package author, need to worry about
10:29:54 <tty7> elliott: what's that stuff with the difference list?
10:30:09 <tty7> sorry, i was just afk
10:31:05 <elliott> tty7: I was suggesting it if you need to do a lot of appending.
10:31:34 <elliott> tty7: http://www.haskell.org/haskellwiki/Difference_list
10:31:40 <zzo38> When I use :set +r in GHCi, the memory amount varies why is that?
10:31:49 <elliott> tty7: http://hackage.haskell.org/package/dlist
10:31:56 <tty7> thanks, i will check that
10:32:49 <quintessence> tty7: the key trick is often used without giving it a name (or importing the package), for instance ShowS
10:32:54 <jgreene> does anyone have a guide to updating to ghc 7.4.1?  I'm running ubuntu 64bit
10:33:00 <hpaste> djanatyn pasted “static blog maker” at http://hpaste.org/63353
10:33:58 <zzo38> Does GHC (or, any Haskell compiler at all) include optimisations for functions which are used as lookup tables and can be modified?
10:34:27 <zzo38> Mathematically is similar kind of things
10:34:35 <tty7> what's O(spine) in the runtime for concat on DLists?
10:34:47 <tty7> http://hackage.haskell.org/packages/archive/dlist/0.5/doc/html/Data-DList.html
10:35:07 <matthiasgorgens> zzo38: there's support for mutable arrays in ghc.
10:35:13 <rata_> is there a nice way to compose a monad MaybeT IO a with IO (Maybe a, b)?
10:35:24 <elliott> tty7: well concat is basically fine on lists too
10:35:26 <elliott> but e.g.
10:35:32 <elliott> ((a ++ [b]) ++ [c]) ++ [d]
10:35:42 <matthiasgorgens> rata_: what do you want the type of the result to be?
10:35:48 <elliott> vs. (((a . (b:)) . (c:)) . (d:)) []
10:35:58 <elliott> oh, wait
10:35:58 <shachaf> a ++ [b,c,d]
10:36:01 * shachaf saves the day.
10:36:01 <elliott> what does O(spine) mean, you mean
10:36:06 <tty7> yep
10:36:07 <rata_> matthiasgorgens: IO (Maybe a, b)
10:36:08 <elliott> tty7: O(spine) means it's linear in the spine :P
10:36:15 <hpaste> prophet pasted “TMixedValueIssues” at http://hpaste.org/63354
10:36:17 <tty7> so what's spine then? ;)
10:36:35 <prophet> can anyone help me on that error?
10:36:35 <zzo38> matthiasgorgens: I know that. But that isn't exactly what I meant; the input could be any type in my case including real numbers or even a polymorphic type, and there might be an infinite number of possible inputs; but you might update the value for one input, and then do the same later will it be inefficient? Will changing strictness affect this?
10:36:36 <elliott> You know. The spine! Okay, somebody else handle this one.
10:36:50 <tty7> the spine of a list?
10:36:55 <shachaf> Of the DList.
10:37:08 <shachaf> It's a composition of functions in this case.
10:37:35 <elliott> tty7: basically, it's linear in the size of the tree of compositions you have
10:37:36 <prophet> i don't know why i can't define toTValue b = TValue b, because b is a instance of TMixedValue
10:37:41 <elliott> or, hmm
10:37:45 <elliott> does it mean O(spine) of the list you givei t...
10:37:48 <elliott> oh, I give up :)
10:38:16 <quintessence> I think it means O(length of the list of DLists), since append is O(1)
10:38:18 <c_wraith> > take 1 $ ((1:) . undefined) []
10:38:19 <lambdabot>   [1]
10:38:34 <elliott> right
10:38:38 <tty7> quintessence: that's what i thought. but why do they write "spine" for that? Oo
10:38:44 <tty7> okay, cool. thanks
10:38:49 <c_wraith> concat is O(1). It just adds a new parent to the tree of composes
10:39:11 <nand`> c_wraith: totally did not expect that result
10:39:14 <nand`> that is some magic
10:39:20 <prophet> the error relates to line 36 in the post
10:39:35 <nand`> makes sense though
10:40:13 <c_wraith> basically, it's *really* hard to talk about the timing taken for any particular DList operation in isolation
10:40:34 <elliott> tty7: because O(n) could mean n in the number of elements in all the dlists
10:40:46 <elliott> but yeah, DList's complexity is screwy to talk about
10:40:57 <elliott> it's useful for doing a bunch of concatenations and only observing it once
10:41:01 <elliott> observing = looking at the elements
10:41:07 <elliott> (because you pay all your costs off then)
10:42:14 <c_wraith> :t concat
10:42:16 <lambdabot> forall a. [[a]] -> [a]
10:43:27 <c_wraith> Yeah, ok.  concat for DList is going to be O(number of DLists being concatenated).  Sort of.  if you pretend it's strict.  DList analysis is complicated
10:45:02 <dylukes> https://gist.github.com/1782357
10:45:08 <dylukes> This seems a bit odd.
10:45:23 <dylukes> It seems it's not able to resolve the polymorphism correctly?..
10:46:36 * shachaf wonders why dylukes is using a type class.
10:47:06 <elliott> dylukes: What type does LitAtom have?
10:47:36 <quintessence> you need to put your LitAtom / VarAtom constructors back on to get an Atom again
10:47:51 <eviltwin_b> looks to me like, since resolveArity has to return the same type it was given, you're feeding it a Lit and expecting it to produce an Atom
10:47:55 <elliott> Oh, yes, of course.
10:48:07 <eviltwin_b> ...yes, that
10:49:22 <dylukes> XD
10:49:23 <dylukes> that'd be it.
10:49:28 <dylukes> So really the signature needs to be like
10:49:37 <dylukes> a -> (forall ArityAnalysis a. a)
10:49:47 <dylukes> Which would be a bit weird.
10:49:57 <dylukes> Really it should be...
10:50:21 <dylukes> resolveArity lit *> id
10:50:26 <dylukes> >_>
10:50:47 <dylukes> But... it's not an applcative ;__;
10:50:57 <dylukes> So I guess I'd just use seq.
10:50:59 <dylukes> right?
10:51:25 <elliott> What?
10:51:33 <dylukes> resolveArity atom@(LitAtom lit) = resolveArity lit `seq` atom
10:51:37 <elliott> You sound incredibly confused about your design
10:51:48 <elliott> dylukes: That's resolveArity (LitAtom lit) = LitAtom lit.
10:51:51 <elliott> Assuming resolveArity lit always terminates.
10:51:57 <elliott> Which it presumably should.
10:52:02 <dylukes> I seem confused?...
10:52:10 <dylukes> It does, it's a traversal of the AST.
10:52:10 <rwbarton> maybe data Atom = LitAtom Atom | VarAtom Atom -- :P
10:52:20 <dylukes> No.
10:52:21 <dylukes> :P
10:52:27 <rwbarton> well what on earth are you trying to do then
10:52:32 <dylukes> This is a downward traversal of the AST.
10:52:39 <elliott> dylukes: Yes, you do seem confused, because I have no idea why you're using a typeclass, and no idea why you think seq is a replacement for (*>)...
10:52:42 <dylukes> I'm going to change a -> a to a -> Reader ... a
10:52:54 <dylukes> elliott: Because they're both sequence points.
10:52:56 <dylukes> elliott: Oh, I'll show you...
10:53:09 <dylukes> It's because I have a collection of AST types.
10:53:09 <elliott> dylukes: You said resolveArity terminates for all inputs.
10:53:10 <elliott> Yes?
10:53:13 <dylukes> Yep.
10:53:16 <elliott> Then
10:53:16 <elliott> <dylukes> resolveArity atom@(LitAtom lit) = resolveArity lit `seq` atom
10:53:17 <elliott> is identical to
10:53:22 <elliott> resolveArity (LitAtom lit) = LitAtom lit
10:53:26 <elliott> aka id
10:53:32 <elliott> If you do the same for the other clause, then resolveArity = id.
10:53:33 <dylukes> Right, but I need to force the resolving of lit.
10:53:38 <elliott> What is the resolving?
10:53:46 <elliott> If you want side-effects, you need some monad to encapsulate them.
10:53:55 <dylukes> The idea is this pass goes over the tree,
10:53:56 <rwbarton> also, you need some effects
10:54:06 <dylukes> building up a hash table as it goes...
10:54:07 * hackagebot hs-json-rpc 0.0.0.1 - JSON-RPC client library  http://hackage.haskell.org/package/hs-json-rpc-0.0.0.1 (LoicArjanen)
10:54:17 <elliott> You're not accumulating a hash table.
10:54:20 <dylukes> Well yes.
10:54:20 <elliott> You're just returning the argument, slowly.
10:54:22 <dylukes> I reduced the example.
10:54:34 <dylukes> This is one very small piece >.<
10:54:41 <dylukes> Okay so, basically,
10:54:47 <dylukes> I have a collection of AST types.
10:55:07 <dylukes> So I'm using the type class as static overloading so I can apply my function recursively.
10:55:12 <dylukes> It will not be a -> a later
10:55:24 <rwbarton> perhaps we should proceed to "later" now
10:55:25 <dylukes> a -> RWS/Writer Prog a or somethin.
10:55:32 <dylukes> RWS more likely.
10:55:45 <elliott> Yes, go to later now, because that type is completely different.
10:55:50 <elliott> And won't involve seq at all.
10:55:59 <dylukes> True enough.
10:57:32 <dylukes> hm, debating what to do monadwise though
10:57:44 <dylukes> I basically need Reader to push the symtab of arity info down the tree,
10:57:54 <dylukes> and I need a mechanism for collecting diagnostics (Writer)
10:57:57 <prophet> http://hpaste.org/63354 < Can anyone help me with that error? it refers to line 36 in the post
10:57:58 <dylukes> so, RWS seems appropriate.
10:59:18 <rwbarton> prophet: I don't think that line 4 means what you think it means.
11:00:11 <rwbarton> prophet: You probably wanted data TValue = forall a. TMixedValue a => TValue a
11:00:48 <rwbarton> Although what you actually really probably want is just data TValue = TBool Bool | TInt Integer | TString String | TList [TValue] | TComposite {-...-} ... why make it so complicated?
11:00:50 <dylukes> edwardk: Can I use trifecta's Diagnostics outside of parsing?
11:00:58 <dylukes> i.e., in the rest of my project.
11:01:06 <edwardk> yes and no
11:01:14 <edwardk> i have been simplifying them so the answer can be yes
11:01:21 <dylukes> Excellent.
11:01:28 <dylukes> Any thoughts on when that'll be the case?
11:01:28 <edwardk> but im not sure the version i have release does this well yet
11:01:36 <dylukes> When's 0.50 :0?
11:01:50 <edwardk> somewhere in the thorsten future ;)
11:02:27 <edwardk> well, i'm pushing a small patch to make it 7.4.1 compatible, but the current code is in another repo
11:02:32 <edwardk> i need to spend a few days on it
11:02:39 <prophet> rwbarton: I'll try the first two advises. The third one using the different cases has the provblem that i can no generically add new algebraic datatypes to be a TValue
11:03:21 <rwbarton> sure you can... just add them to the data declaration.
11:03:21 <prophet> rwbarton: espescially for composite i want to be able to add new ones.
11:03:53 <prophet> rwbarton: but then i always have to change everthing that uses a TValue
11:03:57 <rwbarton> What you have looks like taking the original declaration data TValue = TBool Bool | TInt Integer | TString String | TList [TValue] | TComposite ..., translating it into Java, and translating back
11:04:16 <rwbarton> You only have to change the things that pattern match on TValue.
11:04:24 <rwbarton> Which you have to do anyways, no?>
11:04:43 <rwbarton> since you'd have to change TMixedValue and thus TValue anyways
11:06:22 <Grace12> Hello everyone
11:06:36 <prophet> well the idea was in case i have some new composite i can just implement TMixedValue and then access its values by getAttr and everthings works on
11:07:05 <rwbarton> you can also just write a regular function of type NewComposite -> TValue.
11:07:06 <prophet> but using your suggestion i would have to implement everthing again when adding a new composite
11:07:10 <rwbarton> write a type class for such functions if you like.
11:07:27 <rwbarton> perhaps I don't understand what you are trying to do
11:07:49 <rwbarton> TComposite can just be TComposite (String -> Maybe TValue)
11:08:10 <ski> @where Io
11:08:10 <lambdabot> Raphael L. Levien's language with continuations as fundamental structure, described in his paper "Io: a new programming notation" (1989-09-10) at <http://dl.acm.org/citation.cfm?id=70931.70934> and
11:08:10 <lambdabot> in chapter 2 of Raphael A. Finkel's book `APLD', implementations `Amalthea',`Ganymede'
11:08:16 <ski> BMeph ^
11:08:37 <prophet> that sounds quite clever and would be as flexible as what i wanted to i think
11:08:44 <prophet> thanks i'll try that
11:10:24 * ski thinks <http://stackoverflow.com/questions/tagged/iolanguage> is about something else
11:11:25 <elliott> ski: Yes, it is.
11:11:36 <elliott> What did BMeph say?
11:12:49 <prophet> rwbarton: i'm quite fascinated how simple that alternativ was and yet it is as expressive as what i thought of... your right a i think i had a kind of java approch to what i wanted to do
11:12:55 <ski> BMeph : nothing, so far
11:12:57 <ski> er
11:13:02 <prophet> thanks a lot!
11:13:04 <ski> elliott : nothing, so far
11:13:10 <ski> @where Ganymede
11:13:11 <lambdabot> Implementation by BMeph of the (continuation-based) `Io' language at <http://hackage.haskell.org/package/Ganymede>
11:14:16 <elliott> ah
11:15:12 * ski just fixed up the `@where' thing -- previously it (incorrectly) said that Raphael A. Finkel was the one who had created the Io language
11:16:36 <rwbarton> prophet: no problem, it's a pretty common thing to see this kind of existential/type class pattern here but usually it can be translated to a simpler "plain old data" structure.
11:16:57 <rwbarton> http://lukepalmer.wordpress.com/2010/01/24/haskell-antipattern-existential-typeclass/
11:17:31 <prophet> rwbarton: i see i'm not the only a little bit stuck in old patterns
11:23:01 <prophet> very nice
11:23:36 <Grace12> I'm writing a function which has a list of function to apply to a list, the result will be a list.
11:24:11 <shachaf> Grace12: sequence will do that, but that probably doesn't help you.
11:24:39 <Grace12> For example func [(+1), (*2), (+1)] [1,2,3] = [5, 7, 9]
11:25:07 <Grace12> the function list will be applied from right to left
11:25:38 <rwbarton> well there are two problems
11:25:42 <rwbarton> (1) compose a bunch of functions
11:25:48 <Grace12> I thought of using map, foldr, and may be '.' or the function id to do it.
11:25:49 <rwbarton> (2) apply the composition to every element of the list
11:25:57 <rwbarton> yep, you should use all of those things.
11:26:16 <Grace12> but what is the sequence to apply these things?
11:26:35 <shachaf> Oh, this is for composition?
11:26:49 <shachaf> Oh, I see.
11:27:03 <Botje> Grace12: use foldr to construct a big function first, and map that over your list
11:27:17 <shachaf> This looks best expressed as two separate functions.
11:27:18 <zzo38> I entered    let z = iterate (putExtProd Field3 "Who?") x !! 1000000   and then   getExtProd z Field3   was slightly slow the first time and then faster, but then I typed    getExtProd z Field1   and it just seem to run forever and never stop.
11:29:32 <zzo38> Do you how how to make it stop doing that?
11:29:36 <rwbarton> control-C
11:34:05 <statusfailed> Is there a script for generating haddock docs into the standard package format?
11:34:11 <statusfailed> where standard = cabal
11:34:40 <Grace12> Hi Botje, can you tell me again about the function that I told here before? Thanks.
11:35:21 <keep_learning> Hello all
11:36:14 <keep_learning> I am working with dph and looking for function groupByP ( similar to groupBy in Data.List )
11:36:52 <keep_learning> Any idea how to implement this. I am can write sorting code but not able to figure out this one.
11:37:30 <keep_learning> :t  Data.Array.Parallel.mapP
11:37:31 <lambdabot> Couldn't find qualified module.
11:37:44 <keep_learning> :>  Data.Array.Parallel.mapP
11:37:49 <keep_learning> >  Data.Array.Parallel.mapP
11:37:50 <lambdabot>   Not in scope: `Data.Array.Parallel.mapP'
11:38:39 <Ptival> wtf
11:38:39 <ski> @type Data.List.groupBy
11:38:40 <lambdabot> forall a. (a -> a -> Bool) -> [a] -> [[a]]
11:39:05 <Botje> Grace12: use foldr to construct a big function first, and map that over your list
11:39:11 <Ptival> darcs install says it needs cabal to be installed, but cabal needs darcs to be installed @__@
11:39:23 <incluye> that's what yesod is like
11:39:52 <Grace12> Botje: what do you mean by a big function? Thanks.
11:41:47 <Azel> Grace12: I would say a fold applied to (.), id and your list of functions
11:44:09 * hackagebot stm-conduit 0.2.2 - Introduces conduits to channels, and promotes using  conduits concurrently.  http://hackage.haskell.org/package/stm-conduit-0.2.2 (ClarkGaebel)
11:45:30 * ski wonders which package has `Data.Array.Parallel.mapP'
11:45:31 <Botje> Grace12: chain your functions together using some combination of foldr, (.) and id.
11:45:49 <Grace12> func [xs] [ys] = map (foldr (.) id [xs]) [ys]?
11:46:08 <Grace12> @Azel: is it something like this?
11:46:08 <lambdabot> Unknown command, try @list
11:47:29 <ski> Grace12 : probably you want `xs',`ys' instead of `[xs]',`[ys]' ?
11:47:59 <ski> s/@Azel:/Azel:/
11:50:28 <Grace12> I got it. Thanks everyone.
11:50:31 <scolobb> @tell edwardk Hello, I've seen that last year you've been a GSoC admin.  Are you going to adopt this function this year as well?  I'd be interested to apply :-) I'll extend my online times to catch you in person, if you won't mind.
11:50:32 <lambdabot> Consider it noted.
11:50:47 <scolobb> Thank you, lambdabot, :-*
11:53:55 <lpsmith> Ok,  I want to use threadWaitRead with a Handle...  however threadWaitRead takes an Fd,  and handleToFd depends on the unix package.   Is it possible to use threadWaitRead on Handles on Windows?
11:53:57 <Grace12> func xs ys = map (foldr (.) id xs) ys.... That what I wrote, and it worked per Azel's help. Can anyone explain me what is the order of execution of this?
11:54:09 * hackagebot yesod-sitemap 0.3.0 - Generate XML sitemaps.  http://hackage.haskell.org/package/yesod-sitemap-0.3.0 (MichaelSnoyman)
11:55:38 <statusfailed> is it bad to use `infix` as a shortcut to writing out binary lambda functions?
11:55:44 <JoeyA> lpsmith: you can hack into the underlying Handle__ object.  I'll post what I did on hpaste though it's not perfect.
11:55:45 <Axman6> Grace12: the order is not important
11:55:53 <Ptival> #haskell, ideas for a blogging engine please?
11:56:04 <Botje> Grace12: what do you mean by 'order of execution' ?
11:56:26 <Botje> Grace12: if you feed it an empty list of values, the foldr will not be computed at all.
11:57:09 <lpsmith> JoeyA, that sounds interesting
11:57:15 <Grace12> func [(+1), (*2), (-1)] [1,2,3,4]. It does not work for this case when I have the right most function is -1.
11:57:25 <Botje> :t (-1)
11:57:26 <lambdabot> forall a. (Num a) => a
11:57:41 <scooty-puff> :t negate
11:57:42 <lambdabot> forall a. (Num a) => a -> a
11:57:52 <otters> :t (>>>)
11:57:53 <lambdabot> forall (cat :: * -> * -> *) a b c. (Control.Category.Category cat) => cat a b -> cat b c -> cat a c
11:57:58 <Botje> Haskell's parser is weird. either put (an explicit lambda or (subtract 1)
11:58:05 <prophet> how can i solve the problem that a typeclass instance fpr generic lists and one for Strings overlaps
11:58:12 <scooty-puff> meh don't know why i thought negate..
11:58:16 <scooty-puff> :t subtract
11:58:17 <lambdabot> forall a. (Num a) => a -> a -> a
11:58:39 <hpaste> “Joey Adams” pasted “getHandleSocket” at http://hpaste.org/63365
11:58:47 <prophet> ?
11:58:50 <otters> huh
11:58:51 <JoeyA> lpsmith: Oh wait, you want to use threadWaitRead...
11:58:59 <Ptival> prophet: newtype?
11:59:00 <otters> either xchat is freaking out, or lambdabot ignores :t queries in private messages
11:59:07 <JoeyA> threadWaitRead doesn't work on Windows.
11:59:09 * hackagebot text-register-machine 0.4.0 - A Haskell implementation of the 1# Text Register Machine  http://hackage.haskell.org/package/text-register-machine-0.4.0 (AdamFoltzer)
11:59:17 <otters> astonishing
11:59:25 <JoeyA> See e.g. http://hackage.haskell.org/trac/ghc/ticket/5797
11:59:39 <JoeyA> "The real problem is that there is no IO manager on Windows."
11:59:58 <Ptival> otters: use @type in private
12:00:01 <otters> oh
12:00:06 <Ptival> don't ask me why :)
12:00:09 <otters> what's with t
12:00:10 <otters> okay
12:00:39 <Grace12> s/Botje: does not work for -1
12:00:57 <JoeyA> lpsmith: However, in GHC.IO.FD, there is a function called ready that tests if a socket is ready to read.
12:00:59 <prophet> Ptival: yeah sure but that would destroy the nice syntax by requiring to wrap everthing in a pseudo type
12:01:04 <JoeyA> It is used internally by hWaitForInput
12:01:10 <JoeyA> However, see http://hackage.haskell.org/trac/ghc/ticket/5843#comment:1
12:01:25 <Azel> Grace12: Normal, like its type indicates, (-1) is parsed as a number, not as a section
12:01:27 <Grace12> (-1) :: Num a => a
12:01:54 <Grace12> <Azel>: I check the type and it said as showed
12:02:02 <JoeyA> lpsmith: So backing up, what are you trying to do?
12:02:04 <Grace12> how can I fix it? Thanks.
12:02:31 <Botje> 21:57 < Botje> Haskell's parser is weird. either put (an explicit lambda or  (subtract 1)
12:02:58 <Grace12> Thanks Botje, I see the problem.
12:03:14 <Grace12> Even map (-1) [list] does not work either.
12:03:20 <elliott> because (-1) is a number.
12:03:25 <elliott> use an explicit lambda or (subtract 1).
12:03:49 <shachaf> (-1+)
12:04:01 <Botje> shachaf: bwhaaha :)
12:04:03 <otters> :t (-1+)
12:04:04 <lambdabot> forall a. (Num a) => a -> a
12:04:10 <Botje> :t (+1-)
12:04:11 <lambdabot> parse error on input `)'
12:04:16 <otters> nonsense
12:04:17 <qpu> :t (+ (-1))
12:04:17 <Botje> aww
12:04:17 <lambdabot> forall a. (Num a) => a -> a
12:04:25 <otters> :t (+-1)
12:04:26 <lambdabot> Not in scope: `+-'
12:05:51 <cmccann> :t 1--
12:05:52 <lambdabot> forall t. (Num t) => t
12:06:08 <rwbarton> nice one
12:06:16 <cmccann> rwbarton, heheh
12:06:20 <sp3ctum> i'm trying to learn parsec, and have a question: how can i make a parser case insensitive for strings?
12:07:21 <cmccann> rwbarton, it even works the way it looks, assuming you don't have anything else on that line
12:07:30 <statusfailed> sp3ctum: this isn't helpful, but attoparsec has "stringCI"
12:07:49 <cmccann> you get the current value, and then afterwords it ignores the decremented value because everything is immutable
12:07:56 <cmccann> :V
12:08:08 <elliott> sp3ctum: afaik there's no built-in way to do it
12:08:12 <otters> > 1--
12:08:13 <elliott> and unicode case logic is pretty painful
12:08:13 <lambdabot>   1
12:08:19 <otters> oh, wait
12:08:20 <otters> that's a comment
12:08:24 <cmccann> :D
12:08:26 <statusfailed> hahah
12:08:33 * otters o_o
12:08:38 <elliott> sp3ctum: so you'll probably have to roll your own, unless a simple ascii-only hack will work or whatever
12:08:44 <elliott> (which is still rolling your own, just simpler)
12:09:05 <qpu> sp3ctum: also not helpful, but lowercase the input first :]
12:09:26 <sp3ctum> so how should it be done? what is common?
12:09:29 <elliott> sp3ctum: maybe trifecta can do it :P
12:09:31 <statusfailed> sp3ctum: http://stackoverflow.com/questions/8716553/how-to-do-proper-case-folding-with-parsec
12:09:34 <statusfailed> that might help
12:09:39 <elliott> statusfailed: it won't
12:09:43 <elliott> I answered that question :P
12:09:47 <statusfailed> :D
12:09:52 <statusfailed> also, :\
12:09:53 <elliott> ok, the comment section might help
12:09:53 <statusfailed> but mainly :D
12:09:57 <elliott> but the answer won't really
12:10:09 <elliott> sp3ctum: are you dealing with unicode?
12:10:12 <KorriX> hello 2nd time
12:10:13 <otters> haskell doesn't have multiline comments right
12:10:13 <elliott> if not you could just use a hack.
12:10:18 <elliott> otters: {- ... -}
12:10:21 <statusfailed> I vote attoparsec.
12:10:22 <otters> oh yeah
12:10:30 <otters> haha I thought that was a preprocessor directive
12:10:42 <KorriX> if i have data sth = Option1 | Option2 | Option3
12:10:43 <sp3ctum> elliott, atm i don't have a real use case even, so i don't care if it's unicode
12:10:44 <statusfailed> otters: are you thinking {-# #-} ?
12:10:48 <otters> yes
12:10:49 <otters> yes I am
12:10:54 <elliott> sp3ctum: Well, it's hard to give advice without a use case.
12:11:02 <KorriX> how to add deriving to type defined like that ?
12:11:10 <statusfailed> On the contrary, without a use case it doesn't matter what advice you give
12:11:10 <elliott> KorriX: | Option3 deriving (...)
12:11:24 <monochrom> it's easy to give advice without a use case. advice: find a use case. :)
12:11:36 <statusfailed> lol
12:12:06 <statusfailed> hmmmmm. how can I be sure my haskell package isn't going to be completely wrong when I upload to hackage?
12:12:10 <statusfailed> cabal package*
12:12:17 <sp3ctum> let the use case be an oversimplified test: some text comes in and some value should come out. i don't care beyond that atm :)
12:13:22 <sp3ctum> i'm just exploring the limits and abilities of parsec. i've done a bit of perl and am surprised this is not trivial in parsec
12:13:25 <statusfailed> sp3ctum: let yourParser = return () :: Parser ()
12:13:46 <statusfailed> jokes
12:13:52 <sp3ctum> :3
12:13:55 <statusfailed> Find an example file format to parse?
12:14:06 <statusfailed> I did ARFF and now i'm trying to package it D:
12:14:09 * hackagebot yackage 0.4.0 - Personal Hackage replacement for testing new packages.  http://hackage.haskell.org/package/yackage-0.4.0 (MichaelSnoyman)
12:14:28 <sp3ctum> let the input be "text" or "TeXT" or so on
12:14:41 <statusfailed> ... thanks hackagebot!
12:15:06 <sp3ctum> my question: how can a case insensitive parser for that input be generated?
12:15:30 <statusfailed> sp3ctum: I don't see why you couldn't do what is suggested on the SO link
12:16:20 <statusfailed> i.e. let stringCI s = foldl (\c -> char (toLower c) <|> char (toUpper c)) s
12:16:24 <statusfailed> or something like that
12:16:40 <otters> :t (<|>)
12:16:41 <lambdabot> forall (f :: * -> *) a. (Alternative f) => f a -> f a -> f a
12:17:04 <sp3ctum> thanks, i will try that and explore a bit.
12:17:40 <lpsmith> JoeyA, I'm trying to remove the unix dependency in postgresql-libpq
12:17:58 <JoeyA> Ah
12:19:09 <lpsmith> it's a pretty small dependency,  I'm not sure exactly the issues involved though,  as the code with the dependencies I didn't write
12:19:29 <lpsmith> but the only dependency on Unix is the handleToFd function
12:24:09 * hackagebot elerea-examples 2.2.2 - Example applications for Elerea  http://hackage.haskell.org/package/elerea-examples-2.2.2 (GergelyPatai)
12:26:03 <JoeyA> lpsmith: It looks to me like print :: Handle -> Result -> PrintOpt -> IO () leaks a FILE* every time it is called.
12:26:26 <JoeyA> the fdopen call creates a FILE.  I don't think fclose-ing it is the right thing to do, though.
12:28:38 <lpsmith> JoeyA, yeah, I don't know that what's there is correct
12:30:12 <Taneb> http://sprunge.us/WMEO
12:30:19 <Taneb> Woops, wrong channel
12:30:23 <Taneb> Ignore that
12:30:32 <lpsmith> Honestly I'm just considering cutting print and trace out.
12:31:29 <JoeyA> Sounds like a good idea.  If anyone complains, it can be added back later.
12:34:50 <JoeyA> It'd be fun to write a useAsFile function that provides a FILE* such that writes to it will be piped to a Handle.
12:42:42 <DanBurton> @where+ waldo http://planet.haskell.org
12:42:43 <lambdabot> I will never forget.
12:44:06 <monochrom> sp3ctum: "read some input, compute something" is trivial or non-trival in perl, and trivial or non-trivial in haskell, depending on the input syntax. if the input syntax is line-based and furthermore each line fits a regex, perl certainly has an advantage there, considering its origin (sysadmin wants to scan line-based log files for "FATAL ERROR"). but as soon as the input sytanx grows out of that model, non-line-based or non
12:44:07 <monochrom> -regular, perl suffers and haskell prevails, parsec makes that easy, and there are even easier ways. and then there is also what to compute/output. if you say, parse a string into... many little string! then perl certain has an advantage again. but if you get real and parse a string into a real data structure... well perl doesn't even have real data structure, any language except snobol is going to do better
12:44:10 * hackagebot postgresql-libpq 0.7 - low-level binding to libpq  http://hackage.haskell.org/package/postgresql-libpq-0.7 (LeonSmith)
12:44:31 <monochrom> @quote hiding.information
12:44:32 <lambdabot> AlanPerlis says: The string is a stark data structure and everywhere it is passed there is much duplication of process. It is a perfect vehicle for hiding information.
12:44:45 <monochrom> sp3ctum: that quote is food for thought for you
12:45:20 <aristid> monochrom: haskell isn't that bad for line-based formats, though, i think :)
12:45:45 <DanBurton> the one good thing about strings is they are the universal language, and bash pipes can work well with them
12:46:13 <DanBurton> according to legend, Haskell programs were once String -> String
12:46:32 <monochrom> well if you take the totality of both the language itself and common library support, perl still has that advantage, haskell could have the advantage if someone wrote a library for that mode of operation
12:46:58 <statusfailed> Errm, how do I find out which version of "base" i'm using?
12:47:02 <monochrom> thankfully, no one in the haskell community cares about that stupid mode of operation, and so we don't have such a library
12:47:14 <statusfailed> cabal info base
12:47:15 <statusfailed> woo
12:47:16 <DanBurton> statusfailed: ghc-pkg list base
12:47:22 <statusfailed> oh
12:47:39 <statusfailed> man. I'm two versions behind, that's lame.
12:48:09 <monochrom> "cabal list" and "cabal info" sometimes lies. use ghc-list
12:48:35 <DanBurton> statusfailed: I recommend http://blog.jasonknight.us/2012/02/how-to-install-ghc-741-in-ubuntu-from.html
12:48:37 <Saizan> also, each ghc is tied to a base version
12:48:58 <statusfailed> oh noo, broken packages again :(
12:49:11 <DanBurton> yargh i hate it when that happens
12:49:32 <statusfailed> cabal fix-packages? :(
12:50:07 <DanBurton> I started vigorously cloning my virtual boxes so that if I messed up the packages, I could just throw away the image and re-clone from a common parent
12:50:23 <statusfailed> damn. I need to start snapshotting
12:50:40 <statusfailed> also I need my config files under version control
12:50:48 <Saizan> maybe you could just backup ~/.cabal and ~/.ghc instead
12:51:22 <statusfailed> trueeeee
12:51:38 <statusfailed> pandoc and citeproc-hs are being mean
12:51:51 <kniu> :t (<$>)
12:51:52 <DanBurton> Saizan: that would be the easy way, though
12:51:52 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
13:04:10 * hackagebot attoparsec-arff 0.0 - An ARFF file parser using Attoparsec  http://hackage.haskell.org/package/attoparsec-arff-0.0 (PaulWilson)
13:04:12 * hackagebot persistent-postgresql 0.8.1.1 - Backend for the persistent library using postgresql.  http://hackage.haskell.org/package/persistent-postgresql-0.8.1.1 (MichaelSnoyman)
13:09:10 * hackagebot snaplet-mongodb-minimalistic 0.0.6.1 - Minimalistic MongoDB Snaplet.  http://hackage.haskell.org/package/snaplet-mongodb-minimalistic-0.0.6.1 (PetrPilar)
13:10:12 <pfn> are the 99 questions for haskell available in a ruby-koans-like form?
13:10:58 <shachaf> I doubt it.
13:14:24 <rostayob> what are these 99 questions?
13:14:40 <rostayob> oh. googled.
13:15:10 <pfn> is there any way to run ghci in such a way that it behaves as if I were typing in from a file?
13:16:15 <shachaf> pfn: Your question is pretty vague, but the answer is probably no.
13:16:28 <shachaf> GHC 7.4 improves things a little bit, though (you can define data types and so on in ghci)
13:16:43 <pfn> yeah, not gonna be able to use that any time soon in my setup
13:32:29 <Pseudonym> pfn: runghc?
13:33:09 <Pseudonym> It's not exactly GHCi, admittedly,.
13:33:17 <Pseudonym> You could always write your own...
13:35:33 <Pseudonym> @quote runghc
13:35:33 <lambdabot> monochrom says: just add #! /usr/bin/runghc to your haskell file. then type errors occur at runtime only.
13:35:44 <tazjin> Can I use the GHC 7.2 install guide from the topic if I've already got the Haskell Platform with GHC 7.0.* installed?
13:39:03 <pfn> Pseudonym, yeah, that might be my only thing, would be nice to be interactive and a little "faster"
13:40:53 <Pseudonym> You might like to take a look at the source code for GHCi. It's a readline layer on top of a fairly well-written API.
13:54:28 <heiz> Hello! I'm a student and now I'm looking for a theme for my course work. I want something connected with type theory. Any ideas are welcome.
13:55:41 <Axman6> heiz: you'll have to be much more specific about what you want from us...
13:56:04 <Axman6> o/ kfish
13:56:20 <kfish> hi Axman6
13:56:29 <Axman6> how goes it?
14:02:48 <zzo38> Is there a package with a more portable unsafeCoerce and Any, by itself?
14:04:40 <rudyl313> I'm thinking of submitting my library to hackage and I was wondering if I just go "cabal sdist" to create the tarball or do I have to build the project and/or generate the haddock docs myself (or does hackage generate haddock docs themselves?)
14:04:51 <elliott> rudyl313: try "cabal upload"
14:05:01 <elliott> but it's just a cabal sdist, yes, hackage generates docs itself
14:05:26 <rudyl313> elliott: so no building before I run "cabal sdist"?
14:05:43 <rudyl313> do I have to run cabal sdist before cabal upload?
14:05:55 <elliott> rudyl313: No, you can just run it directly, I think.
14:06:01 <elliott> But yes, Hackage builds everything itself.
14:06:11 <rudyl313> elliott: great thanks
14:07:41 <zzo38> I want to be able to make a program with   unsafeCoerce :: x -> Any   and   unsafeCoerce :: Any -> x   but I am unsure what I should do in case of making such things how to do so?
14:13:19 <dylukes> edwardk: :0
14:13:21 <dylukes> sorry
14:13:29 <dylukes> I ran out right after asking you about the Diagnostics stuff.
14:13:33 <dylukes> ;__;
14:22:30 <jfischoff> How should I meet other haskellers to start a business with?
14:22:56 <zzo38> jfischoff: It depend what business you want
14:23:36 <jfischoff> zzo38: Probably something web/mobile like, in the social discovery or exercise space
14:23:50 <jfischoff> zzo38: but I'm open to ideas
14:23:57 <mm_freak_> jfischoff: if you mean it physically it also depends on where you live
14:24:12 <jfischoff> i'm in the bay area
14:24:16 <qpu> perhaps somewhere in the space space?
14:26:11 <DanBurton> jfischoff: #haskell irc, perhaps? :)
14:26:18 <jfischoff> hehe
14:26:26 <jfischoff> I hope so
14:26:34 <DanBurton> jfischoff: have you seen http://haskellers.com ?
14:27:04 <jfischoff> DanBurton: yeah, I guess I could just contact people in my area
14:27:25 <jfischoff> Dan Burton: see if they are looking to start a company
14:27:58 <DanBurton> screw your area, I want to join >,< area issues aside, school keeps me rather busy, though :(
14:28:36 <jfischoff> DanBurton: I won't rule it out, but I think being physically in the same location is important
14:29:08 <DanBurton> jfischoff: you may also want to look into the Bay Area Haskell Users Group https://groups.google.com/forum/?fromgroups#!forum/bahaskell
14:29:37 <DanBurton> apparently they are meeting up on Feb 15
14:29:51 <jfischoff> DanBurton: I'm going. They have a meetup group too
14:30:10 <jfischoff> DanBurton: its a little weird format wise, more of a lecture
14:30:20 <jfischoff> DanBurton: bad for socializing
14:30:37 <tty7> @hoogle Data.List.Split
14:30:38 <lambdabot> Prelude splitAt :: Int -> [a] -> ([a], [a])
14:30:38 <lambdabot> Data.List splitAt :: Int -> [a] -> ([a], [a])
14:30:38 <lambdabot> package split
14:30:42 <DanBurton> bring snacks and sit around them afterwards? ;)
14:30:47 <tty7> @hoogle splitOn
14:30:47 <lambdabot> Data.Text splitOn :: Text -> Text -> [Text]
14:30:47 <lambdabot> Data.Text.Lazy splitOn :: Text -> Text -> [Text]
14:31:17 <tty7> do i have to install the Data.List.Split module seperately? http://hackage.haskell.org/packages/archive/split/0.1.1/doc/html/Data-List-Split.html
14:31:24 <DanBurton> tty7: I don't think hoogle has an index of the split package
14:31:27 <DanBurton> @hackage split
14:31:27 <lambdabot> http://hackage.haskell.org/package/split
14:31:28 <elliott> tty7: "cabal install split"
14:31:40 <tty7> hm. too bad :/
14:31:54 <DanBurton> or you can just steal the code you like.
14:32:09 <DanBurton> its got some funky internals, though
14:32:10 <tty7> and i'd guess there's nothing like splitOn or splitOneOf in the standard installation?
14:32:38 <tty7> @hoogle oneOf
14:32:38 <lambdabot> Text.Parsec.Char oneOf :: Stream s m Char => [Char] -> ParsecT s u m Char
14:32:38 <lambdabot> Text.ParserCombinators.Parsec.Char oneOf :: Stream s m Char => [Char] -> ParsecT s u m Char
14:32:39 <lambdabot> Test.QuickCheck.Gen oneof :: [Gen a] -> Gen a
14:34:36 <tty7> well, writing an own version of splitOn doesn't seems too difficult. but i don't know if it would be as efficient as the module's version ;)
14:35:06 <tty7> i mean without the Splitter type and such, just by running through the list and splitting at the right point(s)
14:36:02 <atlasair> can anyone see what I'm doing wrong here: trip = take 1 [(a,b,c) | a <- [1.9], b <- [1..9], c <- [1..9] ,a^2 + b^2 == c^2 ,a+b+c == 12 ]?
14:36:24 <tty7> shouldn't it be 1..9, atlasair?
14:36:28 <paf31> [1..9]?
14:36:35 <Ptival> huhu
14:37:04 <tty7> > take 1 [(a,b,c) | a <- [1..9], b <- [1..9], c <- [1..9], a^2 + b^2 == c^2, a+b+c == 12]
14:37:05 <lambdabot>   [(3,4,5)]
14:37:11 <tty7> > take 10 [(a,b,c) | a <- [1..9], b <- [1..9], c <- [1..9], a^2 + b^2 == c^2, a+b+c == 12]
14:37:12 <lambdabot>   [(3,4,5),(4,3,5)]
14:37:20 <tty7> > [(a,b,c) | a <- [1..9], b <- [1..9], c <- [1..9], a^2 + b^2 == c^2, a+b+c == 12]
14:37:21 <lambdabot>   [(3,4,5),(4,3,5)]
14:37:22 <atlasair> oh thanks, haha
14:39:11 <Ptival> > take 1 [(a,b,c) | a <- [1..9], b <- [1..a], let c = 12 - b - a, a^2 + b^2 == c^2]
14:39:12 <lambdabot>   [(4,3,5)]
14:39:16 * hackagebot LambdaHack 0.2.0 - A roguelike game engine in early and very active development  http://hackage.haskell.org/package/LambdaHack-0.2.0 (MikolajKonarski)
14:39:55 <elliott> i see, lambdahack has been in early development since 2008 :)
14:40:31 <tty7> > take 1 [(a,b,c) | b <- [1..9], a <- [1..b], let c = 12 - b - a, a^2 + b^2 == c^2]
14:40:32 <lambdabot>   [(3,4,5)]
14:40:36 <tty7> :)
14:41:56 <tty7> > take 1 [sort [a,b,c] | a <- [1..9], b <- [1..a], let c = 12 - b - a, a^2 + b^2 == c^2]
14:41:57 <lambdabot>   [[3,4,5]]
14:42:24 <Axman6> > [sort [a,b,c] | a <- [1..9], b <- [1..a], let c = 12 - b - a, a^2 + b^2 == c^2]
14:42:25 <lambdabot>   [[3,4,5]]
14:43:30 <tty7> > [(3,4,5)] -- come on, you can see the solution yourself, don't let haskell do the work! ;)
14:43:31 <lambdabot>   [(3,4,5)]
14:43:32 <Ptival> sorted lists are too mainstream
14:44:48 <Jake__> wow, didn't expect so many people to be here
14:45:18 <nyingen> welcome to the secret order of programming
14:45:32 <atlasair> i
14:45:44 <Jake__> Thanks
14:45:52 <CodeWeaverX> Please, plug your brain into the wall socket.  That's right.  It'll only hurt for a moment.
14:47:21 <atlasair> what kind of stuff do you use FP for?
14:47:39 <atlasair> I dont mean generally, I mean you personally :)
14:47:56 <c_wraith> atlasair: writing software. (writing web services, in my case)
14:48:02 <CodeWeaverX> Mostly goofing off and solving various kinds of logic, search, and math puzzles.
14:48:06 <CodeWeaverX> So far.
14:48:12 <Ralith> Analyzing large volumes of sales data.
14:48:28 <atlasair> CodeWeaverX, thats what i do aswell
14:48:31 <CodeWeaverX> I plan on trying to play with openGL with it eventually.
14:48:31 <Axman6> atlasair: the last thing i wrote was a tool to read data from a power meter over a serial connection
14:48:31 <tty7> c_wraith: what kind of web services do you write?
14:49:06 <tty7> CodeWeaverX: i still think openGL with a language like haskell would be a pain
14:49:08 <CodeWeaverX> atlasair:  You have to understand, though, I did that a lot with every language I ever encountered.  So that says nothing special about Haskell, except that I intend to bend it to my will.
14:49:18 <c_wraith> I'm at janrain.  Plenty of docs out there on what we do with haskell. (check galois's site for a tech talk one of our engineers did)
14:49:34 <atlasair> Axman6, cool, I wonder if you can program an arduino with haskell
14:49:44 <Axman6> possibly
14:49:51 <elliott> Maybe with that Copilot DSL stuff?
14:49:57 <Axman6> you can certainly use haskell to produce code that can run on an arduino though
14:50:00 <elliott> Not really "in Haskell", though.
14:50:07 <CodeWeaverX> tty7:  Probably.  OpenGL is pretty stateful, which is a minor problem.  That being said, though, you can hide most of that from the code that's actually interesting.
14:50:12 <atlasair> c_wraith, I'll have a look
14:50:27 <Axman6> copilot produces C which can be run on the arduino
14:51:04 <Jake__> Really, today's the first time I've heard of Haskell and it's so awesome to see such an active community!
14:51:15 <nyingen> Jake__: have you seen hackage yet?
14:51:24 <Jake__> nope
14:51:46 <nyingen> Jake__: http://hackage.haskell.org/packages/archive/pkg-list.html
14:51:48 <Axman6> Jake__: be prepared for brain hurt as your brain grows
14:52:03 <Jake__> ok, i'll try
14:52:13 <tty7> CodeWeaverX: i guess i don't like stuff like OGL in general, just using a bunch of library functions without thinking about it (but only carefully reading the docs) doesn't feel like programming for me
14:52:14 <CodeWeaverX> Jake:  Yes, I just sort of got here myself, and it's a pretty neat bunch.
14:52:31 <Axman6> haskell is not a particularly easy language to learn, especially if you know another language. but it is amazingly worth it
14:52:45 <Jake__> So... these are functions for Haskell, or something_
14:52:47 <Jake__> ?
14:52:58 <td123> libraries
14:53:02 <Jake__> ah, ok
14:53:15 <Axman6> Jake__: do you know any other languages?
14:53:20 <CodeWeaverX> tty7: Not entirely sure what you think the alternative would be if you want a back end to do 3d rendering of something you're doing a lot of work on in haskell.
14:53:51 <Jake__> yeah, I know a little bit of pascal and visual basic and I programmed quite a few programs with Java and C++
14:54:09 <Axman6> ah, so your brain is already broken. we'll have to fix that ;)
14:54:19 <tty7> CodeWeaverX: not to use 3D rendering (and maybe even gui) at all ;)
14:54:25 <Jake__> Yeah, I guess^^
14:54:54 <Jake__> I'll try to forget everything I know while I'm learning this
14:55:08 <Axman6> good =)
14:55:19 <CodeWeaverX> tty7:  Well, it must be said most of my interesting self-directed programs have been (and probably will continue to be) console driven.  However, there's not much I can do about your perception of what constitutes "real programming". :P heh heh
14:55:24 <elliott> Jake__: are you reading a tutorial yet?
14:55:27 <elliott> Learn You a Haskell is really good
14:55:29 <elliott> @where lyah
14:55:29 <lambdabot> http://www.learnyouahaskell.com/
14:55:30 <Axman6> heaving learnt C++ is usually a big problem, because you keep trying to think about how things 'actually work'
14:55:34 <Jake__> no, the introduction
14:55:42 <elliott> Jake__: um... the Gentle Introduction?
14:55:46 <Axman6> LYAH is highly recommended
14:55:52 <Jake__> http://www.haskell.org/haskellwiki/Introduction
14:56:01 <elliott> ah
14:56:08 <elliott> that doesn't actually teach any haskell though :)
14:56:11 <elliott> just provides an introduction
14:56:41 <Jake__> I know, just thought it would be good to know what I'm learning before I try to understand it
14:57:04 <elliott> yeah :P
14:57:16 <tty7> CodeWeaverX: it's the (obvious?) difference between "real cool programming" and "real-world programming" :)
14:58:14 <Jake__> So I suppose I can just skip that and read the introduction from learnyouahaskell.com?
14:58:25 <tty7> or self purpose programming versus writing real-world software, if you want
14:58:54 <monochrom> the obvious comonality between "real cool" and "real world" is that both are entirely subjective
14:59:17 * hackagebot hmatrix-syntax 0.1 - MATLAB-like syntax for hmatrix vectors and matrices  http://hackage.haskell.org/package/hmatrix-syntax-0.1 (ReinerPope)
14:59:42 <tty7> well, i didn't managed to say what i wanted to i think
15:00:17 <monochrom> fill in the blanks: ask different people what programs they write for _____ (hobby, job), and you will get different answers. that is what I mean by subjective.
15:00:26 <tty7> but thinking about algorithms and finding elegant solutions to a problem is an entirely different thing than building UIs, for example
15:00:37 <tty7> sure
15:09:17 * hackagebot yesod-markdown 0.3.1 - Tools for using markdown in a yesod application  http://hackage.haskell.org/package/yesod-markdown-0.3.1 (PatrickBrisbin)
15:09:17 <ulidtko> hey fellows
15:09:28 <ulidtko> consider this code
15:09:30 <hpaste> ulidtko pasted “having troubles with parametrized instances” at http://hpaste.org/63374
15:10:47 <ulidtko> somehow typecheckers fails to understand that a1 and a are the same types
15:10:57 <ulidtko> or, I fail to explain that.
15:12:25 <parcs`> ulidtko: the a in 'instance State (AssocListStorage a)' is different from the a in 'class NodeStorage m where ... getNode :: NodeID -> m (NodeData a)'
15:12:41 <ulidtko> how do i make them the same?
15:13:03 <ulidtko> you see, i thought they'll be same when wrote this
15:13:34 <ulidtko> i tried adding 'a' into the class parameters
15:13:52 <parcs`> are you familiar with type families?
15:13:55 <ulidtko> but that leads to MultiParamTypeClasses, which feels kinda wrong way
15:14:00 <parcs`> and associated types/
15:14:15 <ulidtko> uhm... seems not
15:14:18 * hackagebot Allure 0.4.3 - Near-future roguelike game in very early and active development  http://hackage.haskell.org/package/Allure-0.4.3 (MikolajKonarski)
15:16:24 <hpaste> parcs annotated “having troubles with parametrized instances” with “having troubles with parametrized instances (annotation)” at http://hpaste.org/63374#a63375
15:17:32 <ulidtko> seems pretty simple
15:18:04 <ulidtko> resembling typedef's in C++ classes :)
15:20:36 <parcs`> btw, you need FlexibleInstances because class instances must have the form 'T a b c ...' where T is a type constructor and a b c.. type variables. 'State (AssocListStorage a)' does not fit this description because AssocListStorage is not a type variable
15:20:49 <parcs`> flexibleinstances relaxes this restriction
15:21:10 <ulidtko> well, i have read that kind of explanation from the error message
15:21:17 <ulidtko> but still don't understand why
15:21:40 <parcs`> because the haskell standard says so :P
15:22:01 <ulidtko> oh that is unsatisfying for me %)
15:22:01 <parcs`> because it's simpler for implementors
15:22:14 <ulidtko> and btw, are language extensions standardized?
15:22:27 <parcs`> nope
15:22:27 <ulidtko> i thought that only core langues is
15:22:38 <ulidtko> *language
15:22:58 <parcs`> by default ghc only accepts standarized haskell
15:23:04 <tty7> @hoogle flatten
15:23:05 <lambdabot> Data.Tree flatten :: Tree a -> [a]
15:23:05 <lambdabot> Data.Graph flattenSCC :: SCC vertex -> [vertex]
15:23:05 <lambdabot> Data.Graph flattenSCCs :: [SCC a] -> [a]
15:23:12 <tty7> @hoogle concat
15:23:13 <lambdabot> Prelude concat :: [[a]] -> [a]
15:23:13 <lambdabot> Data.List concat :: [[a]] -> [a]
15:23:13 <lambdabot> Prelude concatMap :: (a -> [b]) -> [a] -> [b]
15:23:22 <Saizan> some extensions have their spec on the haskell' wiki
15:23:51 <tty7> concat [a, b, c] basically just does a ++ b ++ c, doesnt it?
15:24:00 <Axman6> yes
15:24:08 <tty7> okay, thanks
15:24:23 <Jake__> Just because I hate it when I pronounce something wrong: Is it HASkell or hasKELL?
15:24:29 <zzo38> Probably some do but not my proposal of extension, because those people hate it.
15:24:37 <parcs`> HASKELL
15:24:40 <tty7> :D
15:24:46 <CodeWeaverX> hahahaa.
15:24:47 <zzo38> Jake__: Does Wikipedia tells you anything like that?
15:24:53 <DanBurton> Jake__: the former
15:24:54 <Eduard_Munteanu> Jake__: first one
15:24:54 <hpc> Jake__: has-kul (with a short 'u')
15:25:00 <CodeWeaverX> I pronounce it with the emphasis on the first syllable.  For whatever that's worth.
15:25:10 <DanBurton> @google haskell pronunciation
15:25:12 <lambdabot> http://www.haskell.org/haskellwiki/Pronunciation
15:25:12 <lambdabot> Title: Pronunciation - HaskellWiki
15:25:16 <hpc> wiktionary probably has a recording
15:25:21 <zzo38> O, there it is
15:25:28 <tty7> u can haz kell xD
15:25:30 <Jake__> Ok, thanks that is what wikipedia says: /ˈhæskəl/
15:25:34 <DanBurton> well, that page is good too.
15:25:44 <Jake__> so, it's on the first syllable
15:25:54 <DanBurton> yes
15:26:34 <paf31> > let next (x,y) = (x^2-y^2,2*x*y)
15:26:35 <lambdabot>   not an expression: `let next (x,y) = (x^2-y^2,2*x*y)'
15:26:38 <DanBurton> Jake__: look for videos with Simon Peyton-Jones talking about Haskell
15:26:39 <paf31> > next (0,0)
15:26:40 <lambdabot>   No instance for (System.Random.RandomGen (t, t1))
15:26:40 <lambdabot>    arising from a use of ...
15:26:44 <Eduard_Munteanu> Hm, must be that æ is pronounced differently to the Latin ae :/
15:26:48 <Jake__> I will, thanks
15:26:55 <DanBurton> or there was that presentation mzero gave a while ago
15:27:32 <tty7> > let next x y = (x^2 - y^2, 2*x*y) in next 0 0
15:27:33 <lambdabot>   (0,0)
15:27:56 <DanBurton> Jake__: also, incidentally, a great intro to Haskell by mzero http://www.youtube.com/watch?v=b9FagOVqxmI
15:28:04 <DanBurton> rather long, though
15:28:23 <Jake__> thank you!
15:29:06 <DanBurton> oh I can spam you with plenty more links if you like :) just ask
15:29:40 <xil> hi. ghci is failing on a strictness bang pattern for me. I tried the -fglasgow-exts flag with ghci but that didn't fix it. Is there a different flag I should be using?
15:29:54 <Jake__> ok, I will watch these two first :-)
15:30:06 <Saizan> xil: -XBangPatterns maybe
15:30:27 <DanBurton> -fglasgow-exts is deprecated, iinm
15:30:41 <Eduard_Munteanu> Yeah, aren't they planning on removing it sometime?
15:30:50 <glguy> Why does   Test.QuickCheck> sample arbitrary       default to the () instance of Arbitrary?
15:30:57 <Eduard_Munteanu> Might not enable that particular extension anyway.
15:31:04 <DanBurton> usually GHC would tell you which flag to use though, in the error message. Isn't that the case this time, xil?
15:31:07 <Saizan> glguy: ghci's extended defaulting
15:31:25 <Eduard_Munteanu> glguy: pretty much everything defaults to () stuff, AFAIK
15:31:37 <DanBurton> which is rather annoying sometimes
15:31:56 <Eduard_Munteanu> > minBound
15:31:57 <lambdabot>   ()
15:31:59 <xil> DanBurton: it's ghci, so it's failing on parse and giving a parse error
15:32:07 <DanBurton> I usually write my quickCheck props with a type signature of [Int] -> Bool or equivalent
15:32:17 <xil> Saizan: -XBangPatterns worked, thanks =]
15:32:48 <DanBurton> > mempty
15:32:48 <lambdabot>   ()
15:33:21 <DanBurton> > mempty `mappend` mempty
15:33:22 <lambdabot>   ()
15:33:38 <DanBurton> () is so...depressing
15:33:47 <glguy> Saizan: thanks. That's just the search term I needed :)
15:33:51 <Redshift64> > (())
15:33:52 <lambdabot>   ()
15:33:54 <Redshift64> oh.
15:33:55 <DanBurton> its like it represents the monotony of life
15:34:05 * Eduard_Munteanu wants a topless ghci :P
15:34:06 <Redshift64> > ((((((()))))))
15:34:07 <lambdabot>   ()
15:34:07 <tty7> > init []
15:34:08 <lambdabot>   *Exception: Prelude.init: empty list
15:34:15 <tty7> > last []
15:34:16 <lambdabot>   *Exception: Prelude.last: empty list
15:34:18 <tty7> > last [1]
15:34:19 <lambdabot>   1
15:34:23 <otters> yeah () actually looks sad
15:34:23 <tty7> > init [1]
15:34:24 <lambdabot>   []
15:34:55 <paf31> > let plot f w h = map (\x -> map (\y -> if f x y then '*' else ' ') [1..h]) [1..w] in plot (\x y -> (x + y)>1) 3 3
15:34:56 <lambdabot>   ["***","***","***"]
15:35:04 <ulidtko> i'd say that () looks unique, or even... alone
15:35:26 <paf31> > let plot f w h = intercalate "\n" (map (\x -> map (\y -> if f x y then '*' else ' ') [1..h]) [1..w]) in plot (\x y -> (x + y)>1) 3 3
15:35:26 <lambdabot>   "***\n***\n***"
15:35:34 <paf31> bah
15:35:53 <wlangstroth> only on #haskell could () become a Rorschach test
15:36:02 <DanBurton> I don't think there's a way to get lambdabot to actually print strings as nature intended.
15:36:12 <paf31> yeah i expected as much :)
15:36:19 <paf31> > let plot f w h = intercalate "\n" (map (\x -> map (\y -> if f x y then '*' else ' ') [1..h]) [1..w]) in plot (\x y -> (x + y)>2) 3 3
15:36:20 <lambdabot>   " **\n***\n***"
15:36:42 <Saizan> > text "***\n***\n***"
15:36:43 <lambdabot>   ***
15:36:44 <lambdabot>  ***
15:36:44 <lambdabot>  ***
15:36:49 <paf31> aha
15:36:49 <DanBurton> wat
15:36:53 <DanBurton> nice
15:37:05 <paf31> > let plot f w h = intercalate "\n" (map (\x -> map (\y -> if f x y then '*' else ' ') [1..h]) [1..w]) in text (plot (\x y -> (x + y)>2) 3 3)
15:37:06 <lambdabot>    **
15:37:06 <lambdabot>  ***
15:37:07 <lambdabot>  ***
15:37:07 <parcs`> Eduard_Munteanu: what about a bottomless ghci :P
15:37:14 <DanBurton> except it has an extra space for the first one o_O
15:37:20 <tty7> let [a, b] = splitAt 3 [1..9] in init b ++ a ++ last b
15:37:24 <tty7> > let [a, b] = splitAt 3 [1..9] in init b ++ a ++ last b
15:37:25 <lambdabot>   Couldn't match expected type `[t]'
15:37:25 <lambdabot>         against inferred type `([t1], [t...
15:37:32 <Eduard_Munteanu> parcs`: totally :P
15:38:05 <Axman6> [last b]
15:38:10 <DanBurton> noooooo not my precious `undefined` -- protest against bottomless ghci
15:38:12 <tty7> > let xs = splitAt 3 [1..9] in init (last xs) ++ head xs ++ last (last xs)
15:38:13 <lambdabot>   Couldn't match expected type `[a]'
15:38:13 <lambdabot>         against inferred type `([t], [t])'
15:38:24 <tty7> huh?
15:38:25 <paf31> > let plot f w h = text ("\n"++ (intercalate "\n" (map (\x -> map (\y -> if f x y then '*' else ' ') [1..h]) [1..w]))) in plot (\x y -> (x + y)>2) 3 3)
15:38:26 <lambdabot>   <no location info>: parse error on input `)'
15:38:57 <Saizan> tty7: you're mixing tuples and lists and elements
15:39:17 <tty7> :t [a] -> a
15:39:18 <lambdabot> parse error on input `->'
15:39:20 <tty7> arg
15:39:25 <tty7> @hoogle [a] -> a
15:39:25 <lambdabot> Prelude head :: [a] -> a
15:39:25 <lambdabot> Data.List head :: [a] -> a
15:39:26 <lambdabot> Prelude last :: [a] -> a
15:39:36 <tty7> :t init
15:39:37 <lambdabot> forall a. [a] -> [a]
15:39:42 <Axman6> those are functions you should try to avoid
15:39:44 <tty7> :t last
15:39:45 <lambdabot> forall a. [a] -> a
15:39:47 <paf31> > let plot f w h = text ('\n':intercalate "\n" (map (\x -> map (\y -> if f x y then '*' else ' ') [1..h]) [1..w])) in plot (\x y -> (x + y)>2) 3 3
15:39:48 <lambdabot>    **
15:39:48 <lambdabot>  ***
15:39:48 <lambdabot>  ***
15:40:02 <Saizan> paf31: btw, plotting on the channel should be avoided
15:40:20 <otters> yeah
15:40:21 <tty7> i didn't intend to use tuples, Saizan. where do i?
15:40:23 <paf31> ah ok
15:40:27 <Saizan> as running too many commands through lb which are unrelated to any discussion
15:40:29 <DanBurton> ghci exists for a reason :)
15:40:35 <paf31> sorry
15:40:35 <Saizan> tty7: splitAt returns a tuple
15:40:39 <Axman6> :t splitAt
15:40:40 <lambdabot> forall a. Int -> [a] -> ([a], [a])
15:40:47 <tty7> oops
15:40:49 <tty7> :/
15:40:50 <tty7> thanks
15:40:50 <Saizan> btw, lambdabot responds to queries too
15:41:02 <DanBurton> @botsnack
15:41:02 <lambdabot> :)
15:41:06 <otters> there are all kinds of possibilities
15:41:15 <tty7> let (a, b) = splitAt 3 [1..9] in init b ++ a ++ last b
15:41:18 <tty7> > let (a, b) = splitAt 3 [1..9] in init b ++ a ++ last b
15:41:20 <lambdabot>   Occurs check: cannot construct the infinite type: t = [t]
15:41:28 <Saizan> last b is not a list
15:41:37 <tty7> > let (a, b) = splitAt 3 [1..9] in init b ++ a ++ [last b]
15:41:38 <lambdabot>   [4,5,6,7,8,1,2,3,9]
15:41:41 <tty7> oh yes, thank you!
15:41:47 <JoeyA> Is there something like hGetSome for regular Strings?
15:42:03 <JoeyA> (just curious)
15:42:17 <Saizan> nope, there's hGetBuf but it's ugly
15:43:11 <JoeyA> Thanks
15:43:30 <mkorpar> Hi guys, is there a way to timeout the Network.Socket.recvFrom function?
15:44:19 * hackagebot factual-api 0.1.0 - A driver for the Factual API  http://hackage.haskell.org/package/factual-api-0.1.0 (RudigerLippert)
15:44:56 <DanBurton> mkorpar: good question. If no one here knows, then you'll likely get a good answer on StackOverflow
15:46:16 <mkorpar> are there any alternatives for datagram communication to UDP?
15:47:30 <ulidtko> why UDP doesn't fit for your purposes?
15:48:54 <nyingen> mkorpar: you mean in haskell specifically, or in general?
15:48:55 <mkorpar> i'm in a bit of an overkill to write the whole checking and resending packets
15:49:00 <mkorpar> haskell
15:49:20 <Ralith> mkorpar: SCTP is awesome.
15:49:32 <Ralith> I dunno if there's haskell bindings for it, though.
15:49:51 <quintessence> mkorpar: (re: first question): you could spawn another thread and have it throw you an asynchronous exception after sleeping, but I have no idea if this is a good way to do it
15:50:05 <Axman6> mkorpar: sounds like you're reinventing TCP?
15:50:11 <Ralith> mkorpar: SCTP implements reliable datagrams with optional ordering and a variety of other useful features.
15:50:18 <Enigmagic> @hoogle timeout
15:50:18 <lambdabot> System.Timeout module System.Timeout
15:50:18 <lambdabot> System.Timeout timeout :: Int -> IO a -> IO (Maybe a)
15:50:18 <lambdabot> System.Event type TimeoutCallback = IO ()
15:50:19 <Ralith> Axman6: TCP is a stream protocol.
15:50:31 <DanBurton> @google sctp
15:50:33 <lambdabot> http://en.wikipedia.org/wiki/Stream_Control_Transmission_Protocol
15:50:33 <lambdabot> Title: Stream Control Transmission Protocol - Wikipedia, the free encyclopedia
15:50:57 <mkorpar> SCTP sounds great
15:51:22 <Ralith> it really is!
15:51:29 <ulidtko> DCCP sounds even better!
15:51:36 <DanBurton> and it can be yours for the low low price of $9.95!
15:51:37 <Ralith> ?
15:52:28 <Ralith> ulidtko: DCCP doesn't serve the same usecases.
15:52:37 <ulidtko> sure it doesn't
15:52:46 <ulidtko> that's the reason it's a different protocol :)
15:52:54 <mkorpar> any od those in haskell :)?
15:53:01 <Ralith> I mean, you can't compare them linearly.
15:53:12 <Ralith> DCCP is not "better"
15:53:13 <DanBurton> @google haskell sctp
15:53:16 <lambdabot> https://github.com/d-snp/SCTP-in-Haskell
15:53:58 <ulidtko> i said it *sounds* better :)
15:54:08 <Ralith> mkorpar: you should be aware that SCTP is often unsupported by consumer NATs, and may require library and/or driver installation depending on your OS.
15:54:17 <Ralith> 'unsupported' as in 'cannot be port-forwarded'
15:54:43 <mkorpar> thanks guys that would be it :)
15:54:47 <Ralith> if your applications are not behind NAT's that's a non-issue, though.
15:55:19 * ulidtko unfortunately has no experience with dccp, neither with sctp.
15:55:44 <Ralith> I'd love to have some experience with SCTP, but all of my use-cases so far have been behind consumer NATs :/
15:56:00 <Ralith> next time I implement a client/server system, perhaps.
15:56:43 <ulidtko> yeah, nats suck so much, from a network system designer's viewpoint
15:56:57 <ulidtko> probably that's why IPv6 has no nat
15:57:14 <Ralith> IPv6 does support NATs, they're just considered horrendously bad practice.
15:57:21 <Ralith> here's to hoping it becomes standard soonish.
15:57:21 <ion> ulidtko: As if.
15:57:26 <ulidtko> well, was intended to have no nat %)
15:57:27 <irene-knapp> well, really, IPv6 can do nothing to prevent NATs
15:57:28 <irene-knapp> is more like
15:57:41 <Ralith> irene-knapp: sure, but "thou shalt not NAT" used to be in the standard.
15:57:47 <ion> There will surely be a bunch of ISPs who happily screw their customers with IPv6 NAT.
15:57:50 <irene-knapp> haha okay
15:57:59 <Ralith> it got taken out because :politics:
15:59:19 * hackagebot yesod-paginator 0.1.1 - A pagination approach for yesod  http://hackage.haskell.org/package/yesod-paginator-0.1.1 (PatrickBrisbin)
16:02:16 <Ralith> ulidtko: though I understand that SCTP can be layered atop UDP. Do you know anything about that?
16:02:48 <ulidtko> nope :\
16:03:05 <ulidtko> my knowledge in this area is almost entirely based on wikipedia articles
16:03:24 <ulidtko> i.e. i know it exists, but have never used them in practice
16:04:05 <ulidtko> yet
16:04:20 * hackagebot factual-api 0.1.1 - A driver for the Factual API  http://hackage.haskell.org/package/factual-api-0.1.1 (RudigerLippert)
16:04:26 <nyingen> lol, ipv6
16:08:30 <gwern> > 341 + 4202
16:08:31 <lambdabot>   4543
16:14:02 <j0br> I am on a small VPS, when i i run   cabal install 'randompackage'  it fails with the meesage   ghc: out of memory (requested 1048576 bytes), any ideas to solve this problem?
16:14:18 <ion> Add swap.
16:14:20 <dcoutts> j0br: 512Mb or less?
16:15:01 <j0br> ion: That is a very simple solution, i fell stupid, that i havn't tried that..
16:15:36 <j0br> dcoutts: 393216k
16:16:29 <dcoutts> j0br: I think you'll have serious problems linking with that little
16:16:52 <dcoutts> j0br: if you notice ld terminating with signal 9 then do not be surprised
16:17:06 <dcoutts> if you can, build on a different box and deploy to the server
16:18:34 <j0br> dcoutts: i have tried without success... my knowledge about the cabal build system is miminal
16:19:02 <j0br> dcoutts:  i did cabel install gitit and used scp to transfor to host server
16:19:58 <j0br> i transfered .cabal the whole .cabal dir and fixed path in .cabal/config
16:20:06 <j0br> but without a good result..
16:20:25 <ulidtko> j0br: if your VPS uses the same arch and system as yours, then you really should build on your system
16:20:34 <dcoutts> j0br: when I say deploy, I mean copy the final binary/program that you wan to run
16:20:40 <dcoutts> wan/want
16:20:55 <dcoutts> so you can avoid compiling or linking anything on the server itself
16:20:57 <dcoutts> j0br: people often report problems during linking when they have 512Mb, an you've got a lot less
16:21:16 <ion> (or MB)
16:21:28 <ulidtko> (or MiB)
16:21:51 <ion> Mi et al. are mostly useless for humans. We think in base-ten. :-P
16:21:55 <j0br> dcoutts: is that possible.. just the copy the file .cabal/bin/git?
16:22:17 <ulidtko> ion: and exactly for that reason they are useful
16:22:36 <j0br> is it a binary with all depends inculuded? as said i am new to haskell and the cabal build system..
16:22:37 <ulidtko> to remind that we're thinking in base 10 and warn about that
16:23:30 <dcoutts> j0br: currently GHC/Haskell apps are all statically linked, so it's just data files and C libs you need to worry about
16:24:26 <dcoutts> j0br: using cabal configure; cabal build; cabal copy --destdir=image/  you can make an image directory containing everything that needs to be installed (including any data files)
16:25:15 <dcoutts> for simple apps with no data files you can get away with copying the binary installed on your own system in ~/.cabal/bin
16:25:25 <dcoutts> but in the general case you need to prepare the install image
16:26:08 <j0br> dcoutts:  It sounds amazing.. I will google,read and learn.. had no idea cabal could do that..
16:26:45 <j0br> dcoutts: ,ion: thanks for your time and yout helpsome answers. :)
16:27:02 <j0br> yout = your
16:27:47 <irene-knapp> "What is a yout?"
16:27:57 <irene-knapp> "Oh, excuse me, your honor.  The two /youths/."
16:35:55 <ion> your ≠ your
16:35:58 <ion> uh
16:36:01 <ion> s/your/yout/ :-D
16:36:10 <ion> I untypo’d the typo.
16:37:37 <j0br> wow, nice untypo'd ion..
16:44:20 * hackagebot hedis-tags 0.1.0 - Tags for hedis  http://hackage.haskell.org/package/hedis-tags-0.1.0 (AlexanderDorofeev)
16:54:20 * hackagebot yesod-markdown 0.3.2 - Tools for using markdown in a yesod application  http://hackage.haskell.org/package/yesod-markdown-0.3.2 (PatrickBrisbin)
17:02:01 <nyingen> @quote
17:02:01 <lambdabot> FogCreek says: Since throwing away a large code base and starting from scratch is typically a bad idea, the final decision was to have an intern write a compiler to translate a subset of ASP into
17:02:02 <lambdabot> PHP.
17:03:03 <ulidtko> horrible world
17:11:54 <ion> haha
17:12:03 <otters> @quote Scala
17:12:04 <lambdabot> jlouis says: the Scala people got a bite of the forbidden fruit. The Haskell people swallowed it whole
17:14:45 <shapr> Does the kfish patch for cabal-sort output make -j capable Makefiles?
17:15:22 <kfish> shapr, yes
17:15:32 * ivanm waves at kfish 
17:15:35 <kfish> just at the package level
17:15:38 <kfish> hi ivan`
17:15:40 <kfish> ivanm even
17:15:53 <kfish> shapr: ie. it'll compile packages in parallel, in dependency order
17:16:21 <ivanm> shapr: i.e. kfish's patch helps if you suddenly want to install yesod on a blank Platform install, but not if you're installing a single package
17:16:29 <kfish> right
17:16:36 <shapr> kfish: Ok, how do I make it work?
17:16:47 <kfish> pull the darcs version of cabal-sort
17:16:57 <shapr> ok, got it.
17:17:05 <kfish> run "cabal-sort --makefile *.cabal"
17:17:14 <kfish> and it will generate something makefiley on stdout
17:17:17 <shapr> spiffy!
17:17:32 <kfish> you'll want to use the --install-cmd option to run a script or something
17:17:54 <ivanm> kfish: oh, so you need all the cabal files relevant to the package you want to install?
17:18:17 <ivanm> (i.e. you can't just do "cabal-sort --makefile yesod" or something?)
17:18:22 <kfish> you'll need all the cabal files for stuff which is not in your package conf
17:18:34 <shapr> Actually, I want another utility that rips all the relevant .cabal files off of hackage, throws them in a subdir that has their sources as well, and does the rest for me.
17:18:49 <shapr> Then cabal install will effectively build in parallel.
17:19:11 <kfish> ah, a dependency-chasing cabal unpack?
17:19:57 <shapr> "cabal install snap" -> get snap.cabal from hackage, download all deps' .cabal, throw in dir...
17:20:42 <dcoutts> mm, if we added an -o flag to cabal fetch then that'd work
17:20:49 <shapr> kfish: Wouldn't that effectively allow "cabal install" to build in parallel?
17:20:54 <kfish> hi dcoutts :)
17:20:59 <shapr> I don't care if it's usin make -j under the hood... I just want it to work :-)
17:21:16 * dcoutts is also expecting a new parallel build patch from the GSoC student
17:21:34 <ivanm> dcoutts: would this be duplicating what kfish has just done via make?
17:21:52 <dcoutts> ivanm: it'd be doing it inside cabal-install
17:22:01 <kfish> dcoutts, https://plus.google.com/101555949501667191720/posts/ZJfR7sKj9jg
17:22:16 <kfish> mikhail reckons he'll have it ready by the end of february ...
17:22:18 <dcoutts> kfish: hia :-)
17:22:47 <dcoutts> kfish: oh great
17:23:15 <kfish> also https://plus.google.com/101555949501667191720/posts/ZJfR7sKj9jg
17:23:38 <kfish> note i haven't actually tested "cabal-sort --makefile" with cabal-install directly, just with our build system at tsuru
17:23:39 <Axman6> isn;t that the same link?
17:23:51 <kfish> so it is
17:24:09 <dcoutts> kfish: btw, I loved the xmas card from you and colleagues, very nice :-)
17:24:16 <kfish> https://plus.google.com/101555949501667191720/posts/T3ZGHWHEQxq
17:24:22 <kfish> dcoutts, cheers :)
17:25:58 <otters> :t (<+>)
17:25:59 <lambdabot>     Ambiguous occurrence `<+>'
17:25:59 <lambdabot>     It could refer to either `Control.Arrow.<+>', imported from Control.Arrow at State/L.hs:5:0-19
17:26:00 <lambdabot>                           or `Text.PrettyPrint.HughesPJ.<+>', imported from Text.PrettyPrint.HughesPJ at State/L.hs:53:0-46
17:26:09 <otters> how do you resolve those? I forge
17:26:11 <otters> t
17:26:24 <Veinor> otters: which <+> do you want?
17:26:29 <otters> the arrow
17:26:38 <dcoutts> kfish: have I missed the point of cabal-sort? (though I can see the point of the parallel bit) it seems to be for the purpose of installing a bunch of related local packages in the right order
17:26:43 <Veinor> so import Text.PrettyPrint.HughesPJ hiding ((<+>))
17:26:48 <dcoutts> but cabal-install can already do that
17:27:07 * Sgeo wants to communicate with Smalltalk from Haskell and visa versa >.>
17:27:07 <otters> Veinor: no, I mean in the type query
17:27:13 <otters> :t Control.Arrow.<+>
17:27:14 <lambdabot> parse error on input `Control.Arrow.<+>'
17:27:15 <otters> see
17:27:21 <Veinor> :t Text.PrettyPrint.HughesPJ.(<+>)
17:27:22 <lambdabot>     Not in scope: data constructor `Text.PrettyPrint.HughesPJ'
17:27:23 <lambdabot>     Ambiguous occurrence `<+>'
17:27:23 <lambdabot>     It could refer to either `Control.Arrow.<+>', imported from Control.Arrow at State/L.hs:5:0-19
17:27:31 <otters> :t Control.Arrow.(<+>)
17:27:32 <lambdabot> Couldn't find qualified module.
17:27:32 <Veinor> :t (Text.PrettyPrint.HughesPJ.<+>)
17:27:33 <lambdabot> Doc -> Doc -> Doc
17:27:36 <otters> Huh.
17:27:44 <otters> :t (Control.Arrow.<+>)
17:27:45 <lambdabot> forall (a :: * -> * -> *) b c. (ArrowPlus a) => a b c -> a b c -> a b c
17:28:41 <dcoutts> kfish: cabal install ./a ./b ./c   --they can be listed in any order
17:29:30 <shapr> dcoutts: Could I use that to fix any output from ghc-pkg check?
17:29:32 <Enigmagic> dcoutts: make -j
17:29:32 <Enigmagic> ?
17:29:51 <ivanm> dcoutts: I think it predates cabal-install, or maybe when it wasn't working as well
17:30:02 <dcoutts> ivanm: I don't think it does
17:30:02 <shapr> dcoutts: wait, nm
17:30:03 <ivanm> or possibly for when someone isn't using cabal-install
17:30:13 * shapr retracts suggestion
17:30:23 <ivanm> maybe ask Henning why he developed it though?
17:31:53 <dcoutts> shapr: yes but that's kind of orthogonal to the feature of building multiple local packages
17:32:10 <Enigmagic> dcoutts: this is what i do for multiple local packages: http://breaks.for.alienz.org/blog/2011/10/28/building-large-haskell-projects-with-waf/
17:32:12 <dcoutts> Enigmagic: no, no parallel builds yet, patches in the works, we had a GSoC project on it
17:32:26 <Enigmagic> mad parallel yo
17:33:52 <dcoutts> Enigmagic: nice, but you've also got some recompilation checking there
17:33:55 <kfish> dcoutts, yes you're right, we'd like to move to just use cabal-dev or cabal-install directly ...
17:34:15 <kfish> dcoutts, we need sandboxing also ...
17:34:27 <Enigmagic> dcoutts: yeah and i have a few other projects (C++) things that need to get built in the middle
17:34:45 <dcoutts> kfish: I should email about the IHG again, we're just proposing these things to the current IHG members atm
17:35:03 <kfish> ok :)
17:35:25 <dcoutts> Enigmagic: yeah, I'd love to do proper cross-package file-level recompliation checking. Doing it right is hard.
17:35:34 <Axman6> " Being #haskell this took around 17 characters of actual code and 400 lines of option handling, plus a drive-by patch to fgl." =) love it
17:35:54 <Enigmagic> dcoutts: one of these days i'll actually finish my .cabal parser and skip cabal-install entirely... i do have a haskell source scanner that builds up the dependency graph between files already
17:36:03 <kfish> Axman6, :)
17:36:09 <Enigmagic> but it's in python and thus not cool :P
17:36:20 <Axman6> glad to see more fun stuff coming out of Tsuru
17:36:23 <dcoutts> Enigmagic: ah, I was going to say, if your tool is written in haskell then it's easy
17:36:44 <Enigmagic> dcoutts: i have a little tool in haskell that dumps it out as JSON
17:36:51 <Enigmagic> that runs as part of the build
17:37:56 <Enigmagic> i'd rather use some other tool but i hate writing custom build steps for cabal
17:38:28 <dcoutts> the current hooks interface is useless
17:38:49 <Enigmagic> yeah :\
17:39:12 <Enigmagic> the only thing i use it for still is calling hprotoc
17:48:55 <Axman6> kfish: have you guys been looking at conduit for any of the tools at Tsuru??
17:49:23 <Axman6> uh, only one ? >_>
17:49:31 <kfish> Axman6, nope
17:49:56 <Enigmagic> Axman6: we're looking at it since we use yesod a bunch... but not till we upgrade to 7.4.1
17:50:14 <Axman6> Enigmagic: you're at Tsuru too?
17:50:24 <Enigmagic> no but we also trade stuff
17:50:24 <Enigmagic> :)
17:51:34 <Axman6> kfish: i was wondering because it seems that it's less likely to cause the sort of issues Maciej ran into while I was there
17:51:48 <Axman6> Enigmagic: can you share which company you're with?
17:52:00 <Enigmagic> alpha heavy
17:52:23 <Enigmagic> we have some simple stuff up on github https://github.com/alphaHeavy otherwise there's not much info on da web
17:52:46 <Axman6> "Alpha Heavy Industries is an alternative asset manager dedicated to producing superior returns through quantitative methods." that's a great nondescript description :P
17:53:16 <ivanm> Axman6: has more info than some package descriptions on hackage :s
17:53:28 <Enigmagic> i spent like half an hour on that page :P
17:53:46 <Axman6> and all you ended up with was that? :P
17:53:56 <ivanm> e.g. second last one that hackagebot reported "hedis-tags: Tags for hedis" :/
17:54:11 <Enigmagic> that included learning enough css to make it render
17:54:19 <Axman6> "ghc-lldb" :o
17:54:34 <Axman6> Enigmagic: ha, nice
17:55:15 <Enigmagic> Axman6: i'll be pushing a bigger update to ghc-lldb in the next couple weeks
17:55:54 <Axman6> what's the purpose of the project? i can see several things that could meet that description...
17:56:14 <Enigmagic> Axman6: decoding values, dumping out threads, etc
17:56:48 <Enigmagic> lldb allows you to write debugger hooks that generate children to display in the debugger
17:57:14 <Axman6> is this for debugging haskell, or extending lldb?
17:57:43 <Enigmagic> yes
17:57:55 <Axman6> >__<
17:57:56 <Enigmagic> this is what it did as of that commit: https://gist.github.com/a32709e307af99379e68
17:59:30 <Enigmagic> they fixed a few more bugs in lldb since then so now it actually looks ok
17:59:32 <Axman6> cool. what is that actually printing?
18:00:40 <Enigmagic> Axman6: whatever was in some register when i hit my main function :-)
18:00:58 <Axman6> heh
18:01:01 <Enigmagic> it's an array of some sort
18:02:06 <Enigmagic> eventually i'd like local symbols so you could print values by name instead of address
18:41:58 <MaskRay> please recommend some tutorials on template haskell
18:42:40 <pacak> MaskRay: http://docs.google.com/uc?id=0B4BgTwf_ng_TM2MxZjJjZjctMTQ0OS00YzcwLWE5N2QtMDI0YzE4NGUwZDM3
18:42:45 <pacak> MaskRay: http://docs.google.com/uc?id=0B4BgTwf_ng_TOGJkZjM4ZTUtNGY5My00ZThhLTllNDQtYzJjMWJiMzJhZjNj
18:43:46 <MaskRay> Bulat's tutorials? I could not fetch..
18:44:31 <pacak> Yes, them. Worked nicely for me.
18:46:04 <MaskRay> fetched with a proxy
18:57:17 <eyebloom> Is there a way to discover the kind of a type in Ghci?
18:57:29 <ski> use `:k'
18:57:30 <Enigmagic> :k
18:57:36 <eyebloom> Ahh
18:57:40 <ski> @kind Either Int  -- in lambdabot
18:57:41 <lambdabot> * -> *
18:58:49 <eyebloom> Is there a kind equivalent to TypeRep?
18:59:11 <Axman6> eh?
18:59:28 <eyebloom> Data.Typeable.TypeRep?
19:00:03 <Axman6> oh, you want something like TypeRep for kinds . that wasn't clear to me'
19:00:16 <eyebloom> Yes
19:00:20 <eyebloom> Just curious
19:00:29 <Axman6> i don't believe so
19:00:33 <eyebloom> Only just started playing with typeable.
19:01:22 <eyebloom> the function would be call kindOf :)
19:02:02 <eyebloom> kindOf:: TypeRep -> KindRep
19:07:00 <otters> so the largest tuple is a 62-tupel
19:07:02 <otters> *tuple
19:08:53 <otters> or the largest documented
19:09:06 <eyebloom> Most useful kind.
19:09:25 <eyebloom> Because it holds the most stuff of course.
19:09:28 <Enigmagic> it doesn't have a Show instance though
19:09:31 <Enigmagic> makes me sad :(
19:09:39 <otters> From talking to lambdabot, I can get up in the 500-tuples
19:09:43 * ski . o O ( `type family KindOf (a :: k) :: *' )
19:09:43 <otters> what's the actual upper limit?
19:10:21 <ski> (i suppose one could s/*/KindRep/, lifting it to a kind)
19:16:51 <cmccann> :t (>>>) <<< (>>>)
19:16:52 <lambdabot> forall c (cat :: * -> * -> *) a b c1. (Control.Category.Category cat) => cat a b -> (cat a c1 -> c) -> cat b c1 -> c
19:17:55 <cmccann> :t (>>>) <<< (>>>) <<< (>>>)
19:17:56 <lambdabot> forall c c1 (cat :: * -> * -> *) a b c2. (Control.Category.Category cat) => cat a b -> ((cat b c2 -> c1) -> c) -> (cat a c2 -> c1) -> c
19:18:01 <cmccann> :t (>>>) <<< (>>>) <<< (>>>) <<< (>>>)
19:18:02 <lambdabot> forall c c1 c2 (cat :: * -> * -> *) a b c3. (Control.Category.Category cat) => cat a b -> (((cat a c3 -> c2) -> c1) -> c) -> ((cat b c3 -> c2) -> c1) -> c
19:18:07 <cmccann> yes, this looks useful
19:24:22 * hackagebot Monadius 0.97 - 2-D arcade scroller  http://hackage.haskell.org/package/Monadius-0.97 (HideyukiTanaka)
19:24:24 * hackagebot hedis-pile 0.1.0 - Caching mandatory data with Redis  http://hackage.haskell.org/package/hedis-pile-0.1.0 (AlexanderDorofeev)
19:26:32 <Axman6> :t let (~) x y = x - y in (~)
19:26:33 <lambdabot> parse error on input `)'
19:26:36 <Axman6> :(
19:27:12 <cmccann> :t (~)
19:27:13 <lambdabot> parse error on input `)'
19:27:14 <cmccann> :t (~~)
19:27:16 <lambdabot> Not in scope: `~~'
19:27:28 <cmccann> when in doubt, add more symbols
19:27:29 <Axman6> :t let (~~) x y = x - y in (~~)
19:27:29 <lambdabot> forall a. (Num a) => a -> a -> a
19:27:30 <eviltwin_b> single ~ wont work there because a pattern is valid syntax
19:27:35 <Axman6> hmm, that works
19:27:53 <Axman6> eviltwin_b: yeah, i figured as much. it;s nice you can use ~~ though
19:29:02 <DanBurton> is there a standard library function for "prompt :: String -> IO String"?
19:29:23 <DanBurton> prompt str = prompt str = putStr str >> putChar ' ' >> hFlush stdout >> getLine
19:29:30 <cmccann> Axman6, ~~ isn't reserved, so you can use it
19:29:33 <DanBurton> whoops doublepaste
19:29:44 <cmccann> just like you can use "iff" even though "if" is syntax
19:30:37 <cmccann> also valid are operators containing <-, @, --, =>, and so on as substrings
19:30:51 <cmccann> :t (->)
19:30:52 <lambdabot> parse error on input `->'
19:30:53 <cmccann> :t (-->)
19:30:54 <lambdabot> parse error (possibly incorrect indentation)
19:31:02 <cmccann> hm
19:31:09 <cmccann> that doesn't seem right
19:31:12 <tikhonjelvis> :t (->-)
19:31:13 <lambdabot> Not in scope: `->-'
19:31:15 <cmccann> --> should be valid
19:31:38 <wavewave> hi
19:32:26 <parcs`> cmccann: it is
19:32:30 <parcs`> :t f --> x
19:32:31 <lambdabot> forall a. (SimpleReflect.FromExpr a) => a
19:32:36 <cmccann> hm
19:32:49 <cmccann> lambdabot is just weird I guess
19:33:40 <monochrom> :t (-->)
19:33:41 <lambdabot> parse error (possibly incorrect indentation)
19:33:57 <monochrom> :t 0-->1
19:33:58 <lambdabot> forall t. (Num t) => t
19:34:00 <dmwit> Works in ghci.
19:34:11 <dmwit>  :t (-->) gives a "Not in scope" error
19:34:13 <dmwit> (of course)
19:34:22 * hackagebot acme-inator 0.1.0.0 - Evil inventions in the Tri-State area  http://hackage.haskell.org/package/acme-inator-0.1.0.0 (MarkLentczner)
19:34:23 <dmwit> > let a --> b = 3 in 5 --> "hey"
19:34:24 <lambdabot>   3
19:34:33 <dmwit> > let a --> b = 3 in (-->) 5 "hey"
19:34:33 <lambdabot>   3
19:34:43 <mzero> (+1) . inator
19:34:46 <mzero> :-)
19:39:18 <lispy> hi
19:39:46 <lispy> Not yet ready for hackage, but I put some code on my github for generating .xls files from Haskell
19:40:05 <lispy> It's working well so far.  I haven't noticed any bugs other than it's short on features
19:41:27 <cmccann> -- Stability:   unstable, may self-destruct
19:41:50 <Jafet> Bah, why isn't there a SetBy
19:42:16 <mzero> :-)
19:43:45 <mzero> Jafet:  ? SetBy?
19:43:55 <DanBurton> what is the safe version of "read"?
19:44:10 <Sgeo> :t reads
19:44:11 <lambdabot> forall a. (Read a) => String -> [(a, String)]
19:44:29 <Jafet> empty :: (a -> a -> Ordering) -> SetBy a
19:44:31 <Sgeo> read "Oops" :: [(Int, String)]
19:44:36 <Sgeo> > reads "Oops" :: [(Int, String)]
19:44:36 <DanBurton> > reads "3" :: [(Int, String)]
19:44:37 <lambdabot>   []
19:44:37 <lambdabot>   can't find file: L.hs
19:44:46 <cmccann> yay
19:44:50 <Sgeo> > reads "3" :: [(Int, String)]
19:44:51 <lambdabot>   [(3,"")]
19:45:00 <Sgeo> > reads "34oops" :: [(Int, String)]
19:45:01 <lambdabot>   [(34,"oops")]
19:45:04 <DanBurton> > reads "foo" :: [(Int, String)]
19:45:05 <lambdabot>   []
19:45:11 <DanBurton> coolio
19:46:03 <mzero> > let readMaybe = listToMaybe . map fst . filter (null . and) . reads in (map readMaybe ["3", "bob", 47"] )::[Int]
19:46:04 <lambdabot>   <no location info>:
19:46:04 <wavewave> line of code comparison : hxournal = 10452, xournal = 17257
19:46:04 <lambdabot>      lexical error in string/character literal at end o...
19:46:14 <wavewave> ?
19:46:50 <mzero> > let readMaybe = listToMaybe . map fst . filter (null . snd) . reads in (map readMaybe ["3", "bob", "47"] )::[Maybe Int]
19:46:52 <lambdabot>   [Just 3,Nothing,Just 47]
19:47:26 <mzero> I always define readMaybe in my Utils module
19:47:33 <ski> > (reads :: ReadS Int) "34oops"  -- DanBurton
19:47:34 <lambdabot>   [(34,"oops")]
19:47:35 <DanBurton> I am stealing that :)
19:47:35 <otters> :t fromMaybe
19:47:36 <lispy> I really wish readMaybe was somewhere in base.  I tend to have it around
19:47:36 <lambdabot> forall a. a -> Maybe a -> a
19:47:51 <lispy> "base" is a bit overloaded though.
19:48:20 <mzero> well, I could do without read --- that'd make room for readMaybe
19:48:27 <mzero> :-)
19:48:45 * cmccann has replaced "read" with "readMaybe" in his alternate Prelude, predictably
19:48:50 <cmccann> I also have readEither
19:49:19 <cmccann> which returns the error message it would have given using the standard read
19:49:19 <lispy> This is where I usually point out that Read isn't really meant for proper parsing...but yeah, readMaybe would be nice :)
19:49:40 <tikhonjelvis> Are alternate Preludes common in practice?
19:49:56 <cmccann> I don't really think so
19:50:12 <cmccann> most people seem to have a utility library of some sort
19:50:18 <lispy> I had to convert a bunch of data inside html tags into either Double or String depending on if I thought it was supposed to be a number.  readMaybe would have been nice.
19:50:23 <cmccann> and my alternate Prelude is more an overgrown utility library than anything else
19:50:28 <tikhonjelvis> ah
19:50:35 <Jafet> > let readMaybe (reads -> [(a, "")]) = Just a; readMaybe _ = Nothing in map readMaybe ["3", "bob", "47", "1337sp34k"] :: [Maybe Int]
19:50:36 <lambdabot>   [Just 3,Nothing,Just 47,Nothing]
19:50:55 <cmccann> tikhonjelvis, mine just imports some stuff by default and hides other things but mostly shuffles around standard libraries
19:51:15 <cmccann> there are serious, full Prelude replacements out there as well but that's a much bigger project
19:51:17 <ski> @type let readM :: (MonadPlus m,Read a) => String -> m a; readM = foldr (mplus . \(a,s) -> guard (null s) >> return a) mzero . reads in readM
19:51:18 <lambdabot> forall (m :: * -> *) a. (Read a, MonadPlus m) => String -> m a
19:51:40 <Jafet> @quote generalisation
19:51:41 <lambdabot> ksf says: ...premature generalisation is the root of all procrastination.
19:51:42 <tikhonjelvis> A full Prelude replacement would proabably confuse anybody who read your code.
19:51:59 <cmccann> I'll probably confuse people anyway
19:52:05 <tikhonjelvis> Well, I guess it would depend on how different the modified Prelude is.
19:52:11 <cmccann> since I'm happy to steal Prelude names and use them for something better
19:52:17 <tikhonjelvis> heh
19:52:36 <tikhonjelvis> Turning all the partial functions into maybes would be nice though.
19:52:56 <cmccann> yeah that's one of my main goals
19:53:01 <lispy> tikhonjelvis: Yeah, I think that would be a good Haskell' proposal (maybe there already is?)
19:53:19 <lispy> head for example...
19:53:19 <Jafet> Ugh
19:53:24 <lispy> > head [] -- arg!!!
19:53:25 <tikhonjelvis> It is a fairly obvious idea
19:53:25 <lambdabot>   *Exception: Prelude.head: empty list
19:53:27 <Jafet> I sense Haskell' will be terrible for golfing
19:53:32 * Eduard_Munteanu imagines foldl™
19:53:32 <cmccann> I've replaced partial functions, generalized some needlessly monomorphic functions, and added some utility functions I like
19:53:42 <tikhonjelvis> Haskell is already not super golfable.
19:53:57 <lispy> Jafet: we could just move all of them to Prelude.Partial in the module heirarchy?
19:54:14 <ski> tikhonjelvis : <http://pleac.sourceforge.net/pleac_haskell-on-steroids/strings.html>
19:54:19 <cmccann> if you're choosing languages based on golfing potential I think APL is worth considering
19:54:21 <lispy> cmccann: fixed Enum?
19:54:21 <Jafet> tikhonjelvis: what
19:54:22 * hackagebot iterio-server 0.2 - Library for building servers with IterIO  http://hackage.haskell.org/package/iterio-server-0.2 (AmitLevy)
19:54:31 <cmccann> lispy, sadly no
19:54:38 <ion> % ghci
19:54:39 <cmccann> I can't think of any way to fix it without replacing it wholesale
19:54:40 <ion> λ> :t head
19:54:43 <ion> head :: [a] -> Maybe a
19:54:46 <lispy> cmccann: the forced "Int" in that type class bugs me to no end :)
19:54:51 <lispy> cmccann: right
19:55:11 <cmccann> I'm drawing the line at anything that needs rebindable syntax and replacing Enum would, for range notation
19:55:21 <cmccann> but yeah it irritates me
19:55:22 <eyu100> @hoogle finally
19:55:22 <lambdabot> Control.Exception.Base finally :: IO a -> IO b -> IO a
19:55:23 <lambdabot> Control.Exception finally :: IO a -> IO b -> IO a
19:55:23 <lambdabot> Control.OldException finally :: IO a -> IO b -> IO a
19:55:30 <eyu100> @info finally
19:55:30 <lambdabot> finally
19:55:55 <ski> @index finally
19:55:56 <lambdabot> Control.Exception, Distribution.Compat.Exception
19:55:56 <cmccann> I think a non-partial succ can be defined but I can't figure out any way to get pred  :[
19:55:58 <Eduard_Munteanu> cmccann: fix it how, or why?
19:56:06 <Eduard_Munteanu> Ah.
19:56:14 <cmccann> > succ () -- Eduard_Munteanu
19:56:15 <lambdabot>   *Exception: Prelude.Enum.().succ: bad argument
19:56:17 <cmccann> I mean
19:56:19 <cmccann> really
19:56:21 <cmccann> REALLY.
19:56:25 <ion> :-D
19:56:38 <ski> > succ GT
19:56:39 <lambdabot>   *Exception: Prelude.Enum.Ordering.succ: bad argument
19:56:46 <Eduard_Munteanu> Spooning it might be a quick fix :)
19:56:54 <lispy> cmccann: also, having an infinite precision Word type would be nice in the prelude.  Like, Nat (==Word32) and Natural (like Integer)
19:56:56 <bogner> Hmm, the haskell platform includes graphical libraries. I don't suppose there's a subset of the haskell platform that's more suitable for a headless box?
19:56:57 <cmccann> Eduard_Munteanu, yeah I've been considering that
19:57:12 <cmccann> lispy, yes, the problem with that is Num, as always
19:57:26 <Jafet> lispy: (-) :: Natural -> Natural -> Maybe Natural?
19:57:35 <lispy> > succ 0
19:57:35 <lambdabot>   1
19:57:41 <lispy> > pred 0
19:57:42 <lambdabot>   -1
19:57:45 <Jafet> Either Unnatural Natural
19:57:52 <lispy> Oh, I expected pred 0 = 0
19:57:56 <Eduard_Munteanu> bogner: why install HP on a headless box at all?
19:58:09 <ion> bogner: Just get GHC and cabal-install and then install the rest of what you need with cabal.
19:58:13 <cmccann> giving up numeric literals would make a Natural type much less useful
19:58:47 <bogner> Well, I suppose I could install all the bits I want manually
19:58:55 <bogner> It's just that the platform is so convenient!
19:59:13 <lispy> cmccann: We could move things around tho so that Natural doesn't have to be part of Num
19:59:18 <Eduard_Munteanu> Yeah, but it might be worth considering doing development on another machine anyway, if you're just deploying the app on the headless box.
19:59:19 <lispy> cmccann: or that Num isn't so ring like
19:59:33 <cmccann> lispy, that requires hacking GHC to do properly
19:59:33 <crutex> race roll call on behalf of cthulhon
19:59:35 * ski . o O ( `m : |N , n : |N |- m - n : |N | m < n' )
19:59:44 <tikhonjelvis> If only there was some way to overload unary -. But it's unholy syntactic magic as far as I know.
19:59:48 <lispy> cmccann: Revising the language isn't out of scope in my head right now :)
19:59:49 <cmccann> or accepting really terrible names
19:59:49 <crutex> say "+race" where race is your nationality / race
19:59:52 <bogner> Eduard_Munteanu, well, I use that box for ghci every once in a while when I'm somewhere without haskell
19:59:52 <crutex> +caucasian
19:59:59 <cmccann> tikhonjelvis, it desugars to negate
20:00:03 <tikhonjelvis> Erm, not overload as much as shadow or replace.
20:00:03 <Eduard_Munteanu> Ah.
20:00:12 <tikhonjelvis> Can you change it to desugar to a different function?
20:00:21 <tikhonjelvis> Without modifying GHC, that is.
20:00:23 <cmccann> with rebindable syntax
20:00:26 <bogner> I just noticed it got X11 on it by accident recently (I installed haskell platform from the debian package a while ago)
20:00:27 <tikhonjelvis> aha
20:00:29 <lispy> +haskellian
20:00:30 <cmccann> it desugars to whatever negate is in scope
20:00:42 <cmccann> also, and this is my favorite part
20:00:44 <cmccann> "fromInteger"
20:00:46 <Jafet> Why would you ever want it to desugar to something else
20:01:01 <cmccann> is only ever applied to natural numbers when converting literals
20:01:02 <tikhonjelvis> So you could theoretically rebuild the entire Num heirarchy to make -42 a type error if it's a Natural number?
20:01:05 <bogner> I suppose it doesn't really hurt to have X on it, it's just strange.
20:01:09 <cmccann> and yet it's called "fromInteger"
20:01:20 <ion> +terran
20:01:47 <cmccann> tikhonjelvis, what you can do is define "class FromNatural n where fromInteger :: Integer -> n"
20:01:52 <lispy> tikhonjelvis: That's the goal, although depending on how unary minus is done it could be a problem.
20:01:56 <cmccann> and then make sure to never use fromInteger yourself
20:02:09 <tikhonjelvis> lispy: unary - is just negate apparently
20:02:20 <mzero> +(Monad m) => m
20:02:26 <lispy> tikhonjelvis: but you first convert the numeric literal
20:02:29 <cmccann> yes, unary minus (which includes negative literals) desugars as negate
20:02:35 <ion> @type mzero
20:02:36 <lambdabot> forall (m :: * -> *) a. (MonadPlus m) => m a
20:02:43 <cmccann> so (-42) becomes (negate (fromInteger 42))
20:02:45 <mzero> d'oh!
20:02:45 <lispy> tikhonjelvis: negate (fromInteger 1) -- IIRC
20:02:53 <tikhonjelvis> right
20:03:04 <lispy> So what type should fromInteger have?
20:03:15 <lispy> It should return an instance of a type class
20:03:36 <lispy> If natural is in that type class (which it probably should be) then you'd be able to call negate and then it would be a run-time error
20:03:51 <cmccann> fromInteger and negate need not be in the same class
20:03:57 <cmccann> you can, and I have, separate them
20:04:10 <tikhonjelvis> Are there any operations that work over all types of numbers we might want to represent?
20:04:17 <ion> “42.0» currently becomes “fromRational 42.0” and “42” becomes “fromIntegral 42”. How about “42” becoming “fromNatural 42” and “-42” (assuming we want to keep that) becoming “fromIntegral (-42)”?
20:04:36 <cmccann> and then negative literals indeed give a compile error for types that allow fromInteger but not negate
20:04:40 <lispy> ion: Yeah, that would be do-able I gues
20:04:43 <tikhonjelvis> Also, would it make sense to incorporate stuff like matices into the hypothetical Num equivalent?
20:04:47 <cmccann> the problem is using fromInteger directly
20:04:56 <lispy> or maybe negate :: Natural -> Integer
20:05:09 <lispy> (as one non-polymorphic example)
20:05:25 <parcs`> :t sin
20:05:25 <lambdabot> forall a. (Floating a) => a -> a
20:05:34 <parcs`> :t asin
20:05:35 <lambdabot> forall a. (Floating a) => a -> a
20:05:46 <Eduard_Munteanu> tikhonjelvis: I guess it can already handle some matrices
20:05:46 <ion> :t asinine
20:05:47 <lambdabot> Not in scope: `asinine'
20:05:52 <lispy> tikhonjelvis: Well, the cool thing about type classes is that they make it so fewer of the 'language intrinsics' must be intrinsic
20:06:01 <Eduard_Munteanu> Like identity multiplied by a scalar.
20:06:38 <lispy> tikhonjelvis: It would be nice as a math geek, if we followed more of the standard math terminology with rings, fields, modules, etc.
20:06:46 <parcs`> @check (==) =<< (asin . sin)
20:06:48 <lambdabot>   "Falsifiable, after 1 tests:\n-1.5\n"
20:06:52 <lispy> Then matricies would have a more obvious place to live
20:07:01 <hpaste> “C. McCann” pasted “numeric literal handling” at http://hpaste.org/63381
20:07:07 <tikhonjelvis> lispy: As somebody who isn't really a math geek, it'd be nice to learn that terminology :)
20:07:12 <DanBurton> does hpaste ever delete old pastings?
20:07:13 <cmccann> that's a module from a proper prelude replacement I was working on
20:07:13 <lispy> Someday when associated types are of the haskell standard this stuff will be easier
20:07:15 <cmccann> but never finished
20:07:33 <lispy> tikhonjelvis: So that's a problem for people. Programmers don't necessarily know a ring from a group from a field.
20:07:54 <tikhonjelvis> lispy: Programmers also don't know about Functors and the like...
20:08:14 <ion> tikhonjelvis: There’s a nice table in Wikipedia. I don’t remember them myself, i always have to consult the table. :-P
20:08:17 <wavewave> lol..
20:08:23 <Eduard_Munteanu> Correction, they don't know about functors :P
20:08:45 <tikhonjelvis> In practice, there is very little *all* programmers know anyhow.
20:09:04 <mbernstein> lispy: I never understood the reason behind half of the stl containers - they never made sense when compared to the actual mathematical meaning of the words.
20:09:20 <wavewave> i just compiled c++ xournalpp now... and at first run.. it crashes.
20:09:23 <lispy> I really hope that programming becomes more mathematical as times goes by, but I fear it will not.  That mainstream programming will actually move further from mathematics.
20:09:28 <mbernstein> lispy: stuff like that has always bothered me about programming names
20:09:52 <lispy> mbernstein: hmm. Other than map what are you thinking of?
20:09:58 <lispy> oh and vector
20:10:00 <mbernstein> vector
20:10:01 <DanBurton> cmccann: I think a lot of us have tried our hand at making a pet Prelude replacement at one time or another
20:10:02 <otters> They should make a version of Wikipedia that isn't useless for math
20:10:15 <mbernstein> lispy: as silly as it sounds, that actually bothers me a lot :)
20:10:18 <lispy> otters: proofwiki.org?
20:10:20 <cmccann> DanBurton, yes, I have two plus a third that I'm actually using
20:10:25 <cmccann> and that ion is also using apparently
20:10:33 <cmccann> speaking of which I need to fix some stuff in that this weekend
20:10:33 <tikhonjelvis> There's that encyclopedia thing by Wolfram
20:10:43 <Eduard_Munteanu> otters: mm, it isn't useless for math. It's worse for some other fields.
20:10:55 <otters> But now on the Ring article it seems almost deceptively simple
20:10:56 <otters> :|
20:11:01 <DanBurton> we should all get together and revamp TheOtherPrelude or something
20:11:01 <lispy> mbernstein: C++'s use of vector is more of what you seen in dependent typed examples.  It's a list of a fixed known length.
20:11:04 <Eduard_Munteanu> Well, they could include basic theorems and proofs though.
20:11:28 <wavewave> eventually everything will move to mathematics.
20:11:39 <lispy> If you want proofs on a wiki, proofwiki.org is seriously what you want
20:11:51 <cmccann> anyway, I am actually kind of curious what people think of the stripped down approach in that hpaste of mine :P
20:11:54 * lispy is hoping that proofwiki takes off.  It's so awesome.
20:12:34 <tikhonjelvis> I should probably take some advanced math classes. But I'm too easily distracted by CS classes...
20:12:37 <wavewave> proofwiki will be programwiki ;-)
20:13:24 <lispy> tikhonjelvis: When I started college I made a pact with myself.  1 math class every term until either a) I simply couldn't grok it any more, b) I had a math degree.
20:13:41 <lispy> tikhonjelvis: I graduated undergrad with degrees in CS and math :)
20:13:42 <ski> lispy : statically checked proofs ?
20:13:50 <tikhonjelvis> lispy: My goal is to take two CS classes a semester :)
20:14:08 <lispy> ski: hehe. Yeah, uploading machine checkable proofs to proofwiki was something we talked about at work recently :)
20:14:16 <tikhonjelvis> And the other problem is that while I *should* take some advanced math classes, I should also do some physics and EE.
20:14:36 <mbernstein> tikhonjelvis: I have an EE degree, don't waste time on any of the courses that aren't information theory.
20:15:00 <lispy> tikhonjelvis: if you're going into software EE is probably a waste.  Physics I can't say because I'm now starting to study it a bit in my spare time :)
20:15:01 <mbernstein> tikhonjelvis: EE is something where it's all or nothing, and I chose the nothing route post university :)
20:15:18 <monochrom> mathematicians do not want machine checkable proofs
20:15:20 <wavewave> hmm.. proofwiki has newton's second law.. sounds awkward.
20:15:26 <tikhonjelvis> mbernstein: Well, I have to do at least a little bit of EE for my degree.
20:15:43 <mbernstein> tikhonjelvis: That's fine, it's mostly discrete math disguised as EE at least
20:15:59 <lispy> monochrom: I don't think proofwiki has to be about mathematicians' preferences per se.
20:16:18 <mbernstein> tikhonjelvis: You'll probably learn s-domain and neat laplace transforms and that stuff which is cool, but a lot of it won't matter.  I suppose signals and systems is fine since you get into Fourier
20:16:34 <wavewave> I do think every proof must be coded.
20:16:45 <monochrom> right, but if proofwiki doesn't please mathematicians, it pleases even fewer people
20:16:48 <mbernstein> tikhonjelvis: But overall, the EE part of my Comp Eng degree is mostly useless - I'd have been better off dual majoring in Math/CS
20:16:50 <wavewave> so sometime it should be uploaded to a big brother machine.
20:17:20 <wavewave> 'the' wise mahchine.
20:17:21 <lispy> monochrom: is there not room to have both human proofs and machine proofs on the articles?  My intuition is that you could have both.
20:18:22 <monochrom> the market is too small, is what I'm saying. if you want it to "take off", it needs a not-too-small market
20:18:52 <lispy> monochrom: Haven't I widened the market?
20:19:12 <monochrom> also, the few people who are interested will first spend 5 years arguing over the proof language
20:19:48 <monochrom> you have widened the market by about 5 persons
20:19:50 <lispy> It will be their own personal TDNR hell? :)
20:20:07 * lispy has haskell-cafe pet peeve threads...
20:20:18 <lispy> I should go read before sleep
20:20:21 <lispy> Peace.
20:22:27 <cvprog> what is to haskell as coffescript is javascript, or does such a thing exist
20:22:39 <tikhonjelvis> Template Haskell :)
20:23:04 <monochrom> haskell-cafe
20:23:05 <Axman6> haskell is the coffeescript equiv :P
20:23:10 <wavewave> i don't think template haskell is coresspondent
20:23:12 <tikhonjelvis> Actually, just having an alternate prelude would have the same effect as CoffeeScript.
20:23:24 <monochrom> oh, I know!
20:23:29 <tikhonjelvis> Can't you use TH to change the syntax more or less however you want?
20:23:38 <monochrom> calekell : haskell :: coffeescript : javascript :)
20:23:52 <Axman6> Haskell + CPP
20:23:54 <Axman6> >_>
20:24:13 <wavewave> hmm.. maybe i misunderstand coffeescript.
20:24:26 <tikhonjelvis> Besides, for stuff like significant whitespace, Haskell already supports two styles as is.
20:24:40 <Axman6> it's an alternative syntax for javascript that's cleaner (and i think less ambiguous)
20:24:47 <tikhonjelvis> So writing your do statements without braces is like using CoffeeScript.
20:24:53 <wavewave> yeah.. that's what I understood.
20:25:40 <wavewave> template haskell is like coffeescript maker.. not coffeescript it self.
20:25:49 <tikhonjelvis> yeah
20:25:59 <wavewave> baristascript
20:26:07 <tikhonjelvis> But most of CoffeeScript is just a fairly straightforward lexical transformation to JavaScript, isn't it?
20:26:20 <tikhonjelvis> So it doesn't make sense to have something like that in a language that supports macros.
20:26:23 <cvprog> i hear template haskell is only available in ghci
20:26:34 <tikhonjelvis> GHC, you mean?
20:26:35 <wavewave> no.
20:27:02 <cvprog> oops :3
20:27:04 <wavewave> ghci : interpreter, ghc : compiler. .template haskell available for both.
20:27:27 <wavewave> template haskell is only available for ghc
20:27:31 <tikhonjelvis> In practice, very few people seem to care about writing portable Haskell anyhow
20:27:35 <wavewave> ghc/ghci.
20:27:43 * cmccann suspects that "RebindableSyntax + do notation" is already more sophisticated than a lot of stuff other languages allow :P
20:27:45 <wavewave> de facto standard.
20:28:21 <wavewave> I want agda-like language as coffeescript of haskell
20:28:33 <tikhonjelvis> cmccann: Certainly infintiely more sophisticated than anything you can do in JavaScript.
20:28:34 <wavewave> maybe type level language..
20:28:58 <wavewave> so type language in agda... .and generate value level haskell.
20:29:02 * cmccann wonders if she would suit wavewave
20:29:17 <cmccann> she's an interesting bit of... something :P
20:29:29 <wavewave> yeah.. that's closest
20:29:30 <tikhonjelvis> Why do people insist on ungooglable names?
20:29:40 <cmccann> because many people are insnae
20:29:42 <cmccann> insane even
20:29:46 <cmccann> also I can't type
20:29:50 <wavewave> that's why hxournal is hxournal kiki
20:30:08 <wavewave> you cannot miss it.
20:30:12 <tikhonjelvis> Happy? Alex? Hugs?
20:30:16 <cmccann> tikhonjelvis, I have a package named "these"
20:30:44 <ski> @fresh
20:30:45 <lambdabot> Hafo
20:30:45 <cmccann> that's got to be one of the best so far :P
20:31:38 <tikhonjelvis> Oh yes, lets have a competition and see who can come up with the hardest to find package names :) It's progress!
20:31:51 <wavewave> I
20:31:58 * shergill proposes 'santorum'
20:32:05 <ivanm> a
20:32:15 <tikhonjelvis> Hmm. Haskell supports unicode. So maybe ☃?
20:32:15 <cmccann> no, no, wavewave is on to something
20:32:18 <ivanm> shergill: how would that be hard?
20:32:26 <cmccann> and it should be a package defining a whole bunch of identities
20:32:31 <cmccann> like the I combinator
20:32:37 <cmccann> and the identity functor
20:32:41 <shergill> ivanm it'd be flooded by the results from savage's campaign against him
20:33:12 <ivanm> who?
20:33:15 <wavewave> in fact, i don't like id in haskell
20:33:19 <ivanm> http://www.urbandictionary.com/define.php?term=santorum
20:33:24 <ivanm> wavewave: why not?
20:33:40 <wavewave> id is so good name for being used for I.D.
20:33:51 <ion> A frothy mix of fecal matter and code that is sometimes the byproduct of programming
20:33:58 <shergill> heh
20:34:03 * ski idly wonders what "I.D." stands for
20:34:22 <tikhonjelvis> ski: I dunno
20:34:32 <wavewave> I usually use idee
20:34:36 <cmccann> ski, It Doesn't
20:34:39 <cmccann> :V
20:35:14 * ski would have expected some latin
20:35:42 <monochrom> I.D. stands for identification, for example in schools or draconian countries, everyone is given a unique number, and the school or country knows the member by that number only
20:36:05 <monochrom> schools or prisons or draconian countries
20:36:05 <ion> I. Dentification
20:36:09 <ski> then why is there a "." after the "I" ?
20:36:41 <tikhonjelvis> That who's geting dentified :)
20:36:47 <monochrom> because "I." is ambiguous and "ident" is too long
20:37:36 <tgeeky> monochrom: i isn't ambiguous
20:37:59 <monochrom> or, why don't I use reduction to answer your question? :)
20:38:43 <monochrom> identification is shortened to I.D. for the same reason the identity function is shortened to id. I don't know what reason that is, but it ought to be the same reason.
20:39:16 <tgeeky> monochrom: I'm not defending any one else's arguments, but if we mentally think of "f" for function, or "g" for group, or whatever, then "i" can be for identity
20:39:17 <ion> “id.” doesn’t imply the “i” is a separate word. “i.d.” does.
20:39:17 <ski> why not "ID." (or maybe "Id.") ?
20:40:01 <monochrom> some places say ID. too
20:40:08 <ski> i see
20:40:49 <monochrom> it was old convention to put dots between all letters in an acronym
20:42:34 <monochrom> "i" can be for the stereotypical integer variable
20:45:14 <SubtleArray> Is this the place where n00bs like myself can inquire about Haskell?
20:45:28 <mzero> indeed, ask away
20:45:29 <tikhonjelvis> Sure.
20:45:40 <tikhonjelvis> It's also the place random people
20:45:55 <tikhonjelvis> ...chat about surprisingly random things
20:46:06 <SubtleArray> Awesome. Just had a simple question. In C++, you can look through functions by listing them in a while. Does Haskell have something similar?
20:46:14 <SubtleArray> look = loop
20:46:42 <mzero> yes, we have map
20:46:44 <SubtleArray> I meant loop. Not look. >_<
20:46:49 <monochrom> listing functions?
20:46:58 <ion> (look ≠ loop.) Please give an example of what you mean in C++.
20:47:01 <mauke> "loop through functions" is not a sensible thing to do
20:47:10 <tgeeky> SubtleArray: if your definition of 'a while' is 'forever', then haskell has a forever function
20:47:10 <ski> SubtleArray : Haskell has recursion. there's also some libary routines like `until',`mapM_',`map',`foldr',&c. -- also list comprehensions
20:47:22 <SubtleArray> Like, if I wanted to loop through 3 function calls. Apologies for the bad grammar.
20:47:24 <mzero> I'm guessing you mean loop through a sequence of calls to functions? (but I'm only guessing)
20:47:38 <mauke> SubtleArray: why would you ever want to do that?
20:47:47 <tgeeky> SubtleArray: that solves the time part. As for the function part, these other people will help you :o
20:47:57 <monochrom> perhaps show 3 examples?
20:48:00 <SubtleArray> Yes, mzero.
20:48:48 <SubtleArray> while (status == true) { function1(); function2(); and so on. } And one of the functions could return status false to stop the program.
20:49:10 <mzero> In Haskell, SubtleArray , we use functions on lists where in other languages you'd use loops
20:49:23 * hackagebot JSONb 1.0.8 - JSON parser that uses byte strings.  http://hackage.haskell.org/package/JSONb-1.0.8 (JasonDusek)
20:49:32 <SubtleArray> So I'd have to put the functions in a list comprehension?
20:49:44 <ski> SubtleArray : you can do that kind of thing if you really want to, yes
20:49:45 <mzero> well, as you wrote there
20:49:59 <monochrom> that requires a global variable, which is not nice
20:50:13 <mzero> those functions are "side effecting" - that is, as they took no arguments, and produced no results -- they only had effect --- like by printing, say
20:50:18 <ski> (it need not be global)
20:50:19 <CodeWeaverX> More to the point, SubtleArray, you're making a classic, but perhaps somewhat subtle mistake -- functional programming doesn't state the order in which to do things.  At least, you have to jump through a few extra hoops to enforce that, and most of the time you don't want to.
20:50:21 <mzero> usually we don't do this  Haskell
20:50:37 <CodeWeaverX> Or rather don't care to.
20:50:57 <mzero> so, let's look at a concrete example --- I want to start with 1, then triple and add 2 until my result is greater than 100
20:50:59 <CodeWeaverX> If you need to, you can, of course.
20:51:07 <mzero> does that seem to fit your idea, SubtleArray
20:51:08 <mzero> ?
20:51:48 <SubtleArray> Sorry. Using irssi for the first time in a long time and I'm trying to remember how to scroll in this damn thing. Haha.
20:51:57 <mauke> PgUp, PgDown
20:52:06 <wavewave> function composition.
20:52:13 <SubtleArray> Sweet! Thanks.
20:52:14 <mauke> Alt+p, Alt+n
20:52:31 <SubtleArray> And mzero, that's about it. I'm working on a natural language app.
20:52:38 <ski> > until (> 100) (\x -> 3*x + 2) 1
20:52:39 <lambdabot>   161
20:52:50 <mzero> > take 1 $ dropWhile (< 100) $ iterate ((+1).(*3)) 1
20:52:52 <lambdabot>   [121]
20:52:55 <SubtleArray> And I'd like for it to loop through a set of functions until the user tells it to stop.
20:53:07 <ski> > take 1 $ dropWhile (< 100) $ iterate ((+2).(*3)) 1
20:53:09 <lambdabot>   [161]
20:53:33 <wavewave> SubtleArray; you are interested in sequence
20:53:45 <ski> > takeWhile (<= 100) (iterate (\x -> 3*x + 2) 1)
20:53:46 <lambdabot>   [1,5,17,53]
20:53:57 <ski> > iterate (\x -> 3*x + 2) 1
20:53:58 <lambdabot>   [1,5,17,53,161,485,1457,4373,13121,39365,118097,354293,1062881,3188645,9565...
20:54:03 <mauke> :t forever
20:54:04 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m a -> m b
20:54:08 <CodeWeaverX> SubtleArray:  For that small part of it, then, you'd be after using Haskell's 'sublanguage' that allows for sequencing of actions.  In its simplest form, the 'do notation', it resembles an imperative language like C.  A little.
20:54:12 <wavewave> or sequence_
20:54:21 <CodeWeaverX> Indeed.
20:54:25 <mzero> so what we do, SubtleArray, is use a nice library of various high-order functions to do what is done with loops in C++
20:54:36 <wavewave> SubtleArray: there are so many ways to do that in haskell..
20:54:43 <CodeWeaverX> Quite a few.
20:54:47 <SubtleArray> *taking notes*
20:55:18 <wavewave> SubtleArray :  all methods have their own reason..  so you had better ask with some example.
20:55:24 <CodeWeaverX> Some more hardcore than others.  If you're just getting started, stick with do notation using the "IO Monad".  You can learn how to do sequences of IO (user interaction) actions pretty quickly.
20:55:25 <mzero> by high-order functions, in this case, you can think of the body of the loop --- in Haskell, that is just a value passed (passing a function) to the control function -- iterate, until, map, foldr, etc....
20:55:52 <CodeWeaverX> But if your'e doing everything in strict sequence, you've kind of missed the point of functional programming.
20:55:57 <ski> SubtleArray : do you know what a higher-order function is ?
20:55:59 <SubtleArray> I'll try to give a clearer example.
20:56:28 <SubtleArray> ski: I think I do. Like maps and do notation?
20:56:47 <SubtleArray> I read somewhere that do notation could be problematic because variables can't be passed from it.
20:56:51 <wavewave> do notation is not a higher order function.
20:57:22 <wavewave> it's a notataion ..
20:57:37 <mzero> well, do notation is short of sequences of monadic bind (the famous >>= operator, SubtleArray ) and, yes that is a higher-order function
20:57:44 <mzero> short for...
20:57:45 <wavewave> do is not a function at all. you may be easily confused.
20:58:09 <mzero> and there's nothing problematic about it.... :-)
20:58:14 <wavewave> mzero : ;-)
20:58:58 <wavewave> think do as a function is a common misunderstanding at the very begining.
20:59:17 <mzero> but - let's be clear, SubtleArray, in imperative languages, you'd use a while or for loop for both processing through some data structure (an array or list, say), as well as doing a sequence of imperative operations (print, input, decide, loop)
20:59:21 <ski> SubtleArray : if by "map" you mean a function that is passed a list and a callback function, calls the callback on every element of the list, getting back a new element, collecting all the output elements into an output list, then yes
20:59:23 <mzero> in Haskell, we do those two things differently
20:59:30 <mzero> (to a degree)
20:59:39 <JoeyA> What's a good way to do relative timing?  Something like:  newTimer :: IO Timer; readTimer :: Timer -> IO Interval
20:59:55 <JoeyA> Where readTimer determines the amount of time that has elapsed since the call to newTimer.
20:59:59 <SubtleArray> CodeWeaverX: I'm trying to avoid strict sequences, but I don't know of any other way to do what I'm trying to do without some kind of a sequence. The program is all about sequencing, really, asking one question after the next until a pattern match is found, and then it performs a final action.
21:00:21 <wavewave> probably it's fold pattern
21:00:44 <mzero> SubtleArray: a common pattern for that is either a monadic fold (as you are taking user input) ---- or really, simpler - just a recursive function:
21:00:46 <CodeWeaverX> Yes, SubtleArray, and that's why the IO Monad (and other monads) exist. :)  Because without sequencing, user interaction devolves into heating your computer up.
21:01:18 <monochrom> how much haskell have you learned?
21:01:26 <augur> omg i just remembered i had a haskell video queued up
21:01:30 <augur> a new haskell video i havent seen!
21:01:30 <augur> :D
21:01:44 <ski> SubtleArray : there is no problem with using explicit sequencing when you really need to. but very commonly one don't need any explicit sequencing for large parts of the code (depending on the type of thing one does)
21:01:46 <mzero> something like      process soFar = do { a <- getLine; if patMatch a soFar then finalComp a soFar else process (combine soFar a) }
21:01:46 <CodeWeaverX> So yeah… turn any sequence loop into a simple recursive function, inside of which is a "do notation" list of operations to perform.  You can get clever with folds and maps and the like on the sequence later.
21:02:16 <CodeWeaverX> Basically:  Isolate those strict sequenced things into one part of your program, and everything else in elegant functional purity.
21:02:17 <monochrom> if you haven't learned much, I say at this point the only meaningful answer is "the observable behaviour can be implemented, the implementation will not look like C++, totally different control flow and idioms etc"
21:02:22 <SubtleArray> Apologies if I've missed any comments or questions. I haven't used IRC in years and I'm extremely rusty. >_<
21:02:44 <CodeWeaverX> Relax.  :)  You've got every level of experience here.
21:03:01 <monochrom> if you have learned much, then it's meaningful to go into actual code
21:04:03 <SubtleArray> monochrom: I know a fair amount of syntax, mostly list comprehensions, and some recursion and pattern matching. I don't now much about structuring programs though. Most of my experience is in C, C++, and Python. My brain is still wired in a very procedural way.
21:04:22 <SubtleArray> I'm still trying to wrap my head about the functional programming paradigm.
21:04:36 <mbernstein> SubtleArray: There's a really good beginning book that just came out that helps go through the design/thought process for haskell/functional apps, one sec
21:04:54 <tkahn6_> SubtleArray: these are fun and will expose you to a more functional style http://www.haskell.org/haskellwiki/99_questions
21:04:57 <mbernstein> Well, a new edition came out
21:05:02 <CodeWeaverX> If nothing else, the online book Learn You A Haskell regularly comes recommended on this chatroom.
21:05:08 <CodeWeaverX> Its a delightful and educational read.
21:05:09 <ski> @where LYAH
21:05:10 <lambdabot> http://www.learnyouahaskell.com/
21:05:18 <CodeWeaverX> Yes.
21:05:20 <SubtleArray> mzero: Monadic fold or recursive function? Got it.
21:05:31 <CodeWeaverX> *points at LYAH book*
21:05:35 <ski> SubtleArray : you should probably start with recursive functions
21:05:42 <CodeWeaverX> Get the hence, and read a mighty tutorial. :D
21:05:48 <mzero> SubtleArray: do you have ghc and/or Haskell Platform installed?
21:05:51 <wavewave> SubtleArray: take a long breath.. your brain is not easily unwired from procedual way of thinking
21:05:51 <CodeWeaverX> Sigh… "Get thee hence".  Can't type tonight.
21:06:17 <CodeWeaverX> It's definitely a nifty way of thinking, this FP stuff. ;)
21:06:19 <mbernstein> SubtleArray: LYAH is a great book but Haskell The Craft of Functional Programming is probably the most accessible Haskell book I've seen
21:06:35 * ski learned from that book
21:06:49 <CodeWeaverX> http://www.haskellcraft.com/craft3e/Home.html
21:06:50 <ski> (and from comp.lang.functional and this channel)
21:06:51 <CodeWeaverX> Interesting.
21:06:55 <mbernstein> SubtleArray: If you're having issues with getting into writing code or thinking in a functional way, it starts out at a relatively slow pace and builds up - it's really solid for introductory work
21:07:39 <wavewave> start from fac n = n * fac (n-1)
21:07:51 <SubtleArray> "Isolate those strict sequenced things into one part of your program, and everything else in elegant functional purity.
21:08:05 * ski thought it started from "picture combinators"
21:08:27 <CodeWeaverX> SubtleArray:  Sequencing is unavoidable.  But you don't have to dally with that devil for the entire program. ;)
21:08:28 <wavewave> realizethis is fold (*) 1 [1..n]
21:08:37 <Eduard_Munteanu> FWIW, I remember going through the Gentle Introduction a bit at some point. But I think this channel helped more than anything in particular:)
21:08:46 <ski> SubtleArray : yes, that's a stronger version of "separate UI from internal machinery", in some sense
21:08:47 <Eduard_Munteanu> Not that I recommend GI.
21:08:50 <SubtleArray> Just bookmarked 99_questions link.
21:09:20 <wavewave> SubtleArray: realizing fold pattern is most important first step.
21:09:41 <SubtleArray> Learn You A Haskell is a great book. It's VERY heavy on syntax though. But I guess it has to be.
21:09:51 <wavewave> provided you understand map now..
21:10:13 <ski> > map (* 2) [0,1,2,3,4,5,6,7,8,9]
21:10:14 <lambdabot>   [0,2,4,6,8,10,12,14,16,18]
21:10:20 <SubtleArray> mzero: I have the Haskell platform and ghci installed.
21:10:27 <mbernstein> SubtleArray: I can't recommend Thompson's book enough :).  Well worth the money.
21:10:39 <ski> > map (map (^ 2)) [[],[0],[1,2],[3,4,5],[6,7,8,9]]
21:10:40 <mzero> SubtleArray: if you want a different starting approach --- try barley --- run cabal install barley
21:10:40 <lambdabot>   [[],[0],[1,4],[9,16,25],[36,49,64,81]]
21:10:51 <mzero> then run   barley
21:11:04 <SubtleArray> wavewave: "your brain is not easily unwired from procedural way of thinking" Ain't that the truth... >_<
21:11:05 <mzero> it installs a web based IDE for Haskell with a tutorial in it
21:11:16 <mzero> you can twiddle code, and watch it run, producing web pages
21:11:28 <monochrom> user interaction in haskell is procedural, too. but it still discourages the use of mutable variables (completely orthogonal to user interaction anyway). you will not be using the "status" variable. fortunately, you will not need it either. you will write a tail recursion. making a recursive call is "looping back". not making a recursive call is "exiting". therefore, you don't need a "status" variable to remind the while-loop
21:11:28 <monochrom>  to exit. just don't do a recursive call, then you're exiting.
21:12:49 <mzero> er, then run   "barley start playground" in your homedir
21:12:50 <SubtleArray> I found this video series based on a book by Graham Hutton http://bit.ly/c9functional I was thinking about getting that book.
21:13:11 <mzero> @where amuse
21:13:11 <lambdabot> I know nothing about amuse.
21:13:13 <CodeWeaverX> The c9 lectures aren't half bad.  I quite liked them.
21:13:29 <SubtleArray> mbernstein/all: Could you see Haskell being used for general purpose programming?
21:13:34 <mbernstein> SubtleArray: http://www.youtube.com/watch?v=b9FagOVqxmI
21:13:52 <mbernstein> SubtleArray: Good talk by mzero.
21:13:55 <wavewave> then.. you can realize fold has accmulator argument. which passes from previous step to next step..
21:14:10 <mzero> er, yeah, that one!  Haskell Amuse-Bouche -- an hour of interesting basics aimed a the C/C++/Java/Python programmer
21:14:13 <ski> SubtleArray : btw, in case it's not obvious, you're quite welcome to stay here, asking questions about things you struggle with, learning from what other people do/say, &c.
21:14:16 <CodeWeaverX> a video by the mzero that pops by here?
21:14:21 <CodeWeaverX> Like this mzero?
21:14:24 <mzero> (note: slides and code are available -- see the YouTube page)
21:14:32 <CodeWeaverX> That's epic. :D
21:14:34 <wavewave> SubtleArray: haskell is very general purpose..
21:14:44 <mbernstein> SubtleArray: I'm not even that great with Haskell but there's a reason I spend a lot of time learning/writing it - I find all other langauges to be inferior in the long term.
21:14:45 <mzero> er, well, yes, that's my talk I gave at Google last Fall
21:14:47 <wavewave> It cannot do nothing
21:14:49 <CodeWeaverX> Sweet!
21:15:01 <CodeWeaverX> *watches right the heck now*
21:15:20 <CodeWeaverX> *needs more beer though*
21:15:22 <monochrom> yikes, mzero looks old!
21:15:24 <mzero> click on the "show more" on that page, and you can get links to the slide deck --- and the source code (on github)
21:15:34 <mzero> so you can "play along" in ghci as you watch
21:15:42 <mzero> yikes - mzero IS old!
21:15:52 <CodeWeaverX> I do love that GHC provides both the interpreter and a high performance compiler.
21:16:02 <CodeWeaverX> Screw around for the while, and then compile your code and get *industrious*
21:16:09 <SubtleArray> *looking up barley now*
21:16:13 <mzero> I've been programming more than half the time the profession has even existed!
21:16:27 <Eduard_Munteanu> Heh.
21:16:31 <CodeWeaverX> *refuses to feel old*
21:16:32 <monochrom> the interpreter also mixes compiled code and interpreted code just fine
21:16:33 <CodeWeaverX> *stomps foot*
21:16:39 <wavewave> wow.
21:17:35 <SubtleArray> mbernstein: *saved YouTube link*
21:17:41 <tkahn6_> mzero: you are an enthusiastic speaker
21:17:52 <mzero> yeah- I know of no other system where I can load up some random inner module of my giant multi-module compiled program, and quickly fiddle with it in an interpreter --- ghci rocks
21:17:54 <wavewave> SubtleArray: anyway.. my suggestion to you to unwire your brain is to understand fold completely as early as possible..
21:18:19 <mzero> tkahn6_: it was a tough audience - 140+ Google engineers -- -had to be upbeat!
21:18:21 <mzero> thanks
21:18:23 <sp3ctum> monochrom, you're right about what you said (re: perl)
21:18:29 <wavewave> SubtleArray: when you use fold more easily than using loops, you become a beginner functional programmer.
21:18:34 <tikhonjelvis> Oh, I think I saw that talk too. It was very good.
21:18:56 <ski> SubtleArray : also, you should remember to have *fun* !
21:18:58 <wavewave> mzero: I saw it. I admire it.
21:18:59 <CodeWeaverX> I have beer!
21:19:13 <SubtleArray> mbernstein: That's part of the reason why I really want to learn Haskell. It's been difficult, but I see a LOT of potential in its use.
21:19:14 <CodeWeaverX> I know you wanted to know that.
21:19:14 <mzero> heh
21:19:27 <mbernstein> mzero: How's the silk screening going?  I saw your monad shirt on g+ - the offer stands, I'd pay $ for one :P
21:19:48 <CodeWeaverX> SubtleArray:  That kind of enthusiasm will carry you through the hair-pulling bits.  But I tells ya, its a deep dark rabbit hole, with lots of shiny gems.
21:19:58 <wavewave> SubtleArray: absolutely.. it's very rewarding experience .
21:20:04 <sp3ctum> monochrom, the quote is good as well. i think it's true
21:20:14 <mzero> aw, thanks! Well, I'm thinking for BayHac (when we get a venue and weekend down), I'll make a batch up
21:20:26 <CodeWeaverX> "A crazy taste of haskell"
21:20:28 <SubtleArray> CodeWeaverX: That's another plus I've noticed. There aren't many language that can be interpreted and compiled. This is an advantage Haskell has over Python.
21:20:29 <wavewave> SubtleArray; it's very amazing to see how some complicated code can be finally condensed down to one line.
21:20:30 <CodeWeaverX> Love the opening line. :D
21:20:56 <tikhonjelvis> mzero: Are you going to announce BayHac on the mailing list? Because I'd like to go, but I tend to forget anything no in the immediate future.
21:20:57 <mbernstein> I hadn't seen a remotely acceptable haskell shirt, so I'd definitely like one.  Probably won't be at BayHac though as I'm in Austin >.<
21:21:08 <mzero> oh yeah, I will -
21:21:11 <CodeWeaverX> Ah, Austin… visited once.
21:21:15 <mzero> don't worry - lots of advance notice
21:21:19 <CodeWeaverX> Delightful time.
21:21:28 <wavewave> SubtleArray: and you will just get AHA moment.. then... everything you do is just same pattern (mostly)
21:21:38 <tikhonjelvis> mzero: I think you're underestimating how forgetful I can be :)
21:21:53 <SubtleArray> wavewave "understand fold completely as early as possible" That sounds like a plan. From what I've gathered (in my poor attempt to keep up) is that I should try to use recursive list comprehensions in the place of while loops or monadic folds.
21:22:25 <wavewave> SubtleArray: actually I don't recommend list comprehension in the beginning at all.
21:23:06 <ski> > foldr (+) 100 [7,1,4,2,8,5]
21:23:07 <SubtleArray> ski: Fun? I try. :D I was mad as hell last night though. Haha. Today has been better.
21:23:08 <lambdabot>   127
21:23:09 <wavewave> SubtleArray: rather.... you had better try to write your own recursive function as many times as possible.
21:23:09 <ski> > foldr (+) 100 [7,1,4,2,8,5] :: Expr
21:23:10 <lambdabot>   7 + (1 + (4 + (2 + (8 + (5 + 100)))))
21:23:16 <mzero> or non-monadic folds!
21:23:17 <mbernstein> Then again, I'd just have to buy a plane ticket and crash on a friends couch, so maybe I'll go - looks interesting.
21:23:21 <ski> > foldr f z [a,b,c,d,e,f] :: Expr
21:23:22 <lambdabot>   f a (f b (f c (f d (f e (f f z)))))
21:23:27 <mzero> you only need the monadic ones if you're doing IO in there
21:23:32 <mzero> (like asking for user input)
21:23:36 <wavewave> SubtleArray: get the pattern... in your definition.
21:23:51 <wavewave> write down something works... and rewrite it.. and rewrite it..
21:23:58 <CodeWeaverX> It's definitely worth being able to implement your own recursive functions for anything you want to do, first, before realizing you can avoid them.  Because under the hood they're still conceptually there.
21:24:00 * ski probably shouldn't have used `f' in the list, there
21:24:19 <CodeWeaverX> Every child should find their inner recursive child.
21:24:24 <tkahn6_> mbernstein: how about a 100% cotton grey shirt with a white bind operator on the top of the back
21:24:27 <CodeWeaverX> <.<  >.>
21:24:33 <SubtleArray> wavewave: I can kind of do them already, but fold would be a better starting/focal point for now?
21:24:48 <wavewave> SubtleArray: fold is always focal point.
21:24:55 * ski grins
21:25:03 <ski> @where evolution
21:25:03 <lambdabot> http://www.willamette.edu/~fruehr/haskell/evolution.html
21:25:06 <wavewave> fold is quite central in FP concept.
21:26:01 <tikhonjelvis> I've always thought "accumulate" was a more intuitive name for fold.
21:26:16 <tkahn6_> tikhonjelvis: it's not really accumulate though
21:26:17 <ski> SubtleArray : for some fun, you can look at that ^ page and see how many of the definitions you understand :)
21:26:20 <wavewave> even you think you understand it, you willl probably reencounter its different viewpoint later.
21:26:32 <tkahn6_> tikhonjelvis: because you an write map with fold
21:26:41 <wavewave> catamorphism.
21:26:43 <ski> `foldl' might have been called `accumulate'
21:27:02 <ski> `foldr' generalizes to catamorphisms for other datatypes than lists
21:27:04 <tikhonjelvis> tkahn6_: You're just accumulating a new list with cons.
21:27:24 <sopvop> Is it ok to build build list with cons and then reversing it, or it's better to use difference lists?
21:27:39 <mzero> tkahn6_: mbernstein was referring to these images: https://lh3.googleusercontent.com/-Nu4Y6Lnm3rI/TyxYHtUfRmI/AAAAAAAAASU/o_xQo8v-P6w/s640/12+-+1    --    and   --   https://lh6.googleusercontent.com/-DgtR7BcDeYE/TyxYHqSixQI/AAAAAAAAASE/7KCTDDh3Lqg/s640/12+-+2
21:27:39 <tikhonjelvis> I'm mostly thinking about the very first time you run into the concept though.
21:28:06 <tkahn6_> mzero: lol what is that owl doing there
21:28:22 <sopvop> it's an lolwut owl
21:28:22 <ski> sopvop : probably ok, if it's not too long. if you can avoid the reversing without too much adverse effects to readability, that could be good
21:28:24 <mzero> it flew in the window as I was printing
21:28:27 <tikhonjelvis> Why wouldn't you want an owl?
21:28:40 <CodeWeaverX> owls are cool.
21:29:10 <ski> (s/it's not too long/the list is not too long/)
21:29:58 <wavewave> SubtleArray : once you understand fold, then... you start to notice relation between constructing data type and getting a result out of the datatype.
21:30:12 <mbernstein> mzero: and all this time i thought the owl was for ((.)$(.))
21:30:19 <wavewave> in fact, usual fold is that from list data structure.
21:30:25 <wavewave> create list -> consume list
21:30:34 <tkahn6_> :t ((.)$(.))
21:30:36 <lambdabot> forall (f :: * -> *) a b (f1 :: * -> *). (Functor f, Functor f1) => f (a -> b) -> f (f1 a -> f1 b)
21:30:36 <sopvop> ski: can 200 items list be considired  long? :)
21:30:36 <wavewave> that's build / fold pattern
21:30:37 <mbernstein> and by all this time, i mean not that long.
21:30:48 <wavewave> so-called hylomorphism .
21:30:48 <CodeWeaverX> It may cause severe brain-damage to overload SubtleArray. :)
21:31:08 <CodeWeaverX> Specifically a buffer overflow.  How appropriate.
21:31:21 <ski> sopvop : i don't think so (well, unless each element takes up very much memory, say)
21:31:32 <SubtleArray> wavewave: I'm all over fold right now. Lol
21:31:42 <SubtleArray> Thanks a lot everyone for your help. ^_^
21:31:55 <ski> yw
21:31:56 <wavewave> SubtleArray: you will see that most of problem you have will be essentially such pattern.
21:32:32 <sopvop> ski: I thought it's juts pointers
21:32:33 <sopvop> just
21:32:33 <JoeyA> To answer my own question, it seems the clock module provides what I want (a monotonic (safe against clock changes) clock).
21:32:33 <JoeyA> Still gotta test it.
21:32:33 <wavewave> that's how you unlearn loop in your brain. ;-D
21:32:46 <ski> sopvop : yes -- i was thinking about cases when the whole list (including elements) can't fit into your RAM, though
21:33:14 <wavewave> if you start to think data structure first before changing state for doing a certain job.. you are rather functional programmer.
21:33:55 <wavewave> then start to think the meaning of definition... not operation..
21:33:58 <sopvop> ski: Otherwise there is no speed gain with difflist vs reverse?
21:34:21 <ski> sopvop : possibly some. measure ?
21:36:46 <CodeWeaverX> Hahaha "Okay, so what bus did we just get hit by?"  (higher order functions)
21:38:09 <mzero> I'm plain' here all week, folks
21:38:21 <sopvop> Didn't measure it, in my case it's just a tiny portion of cpu time. And I have small enough lists and don't have any space issues either. Maybe difflists are more space efficient, idk.
21:38:51 <CodeWeaverX> Very friendly video.  Has that LYAH feel.  Cheery, educational, but not droning.  Fun.
21:38:57 <ski> sopvop : so go with the one you prefer
21:39:31 <sopvop> So I do, just wanted to know for possible future uses.
21:39:44 <Jafet> sopvop: Data.Sequence.|>
21:40:12 <CodeWeaverX> Also now I have a hankering for infinite pineapples.
21:40:14 <CodeWeaverX> mmmmm
21:40:23 <sopvop> I'll check it, thanks
21:40:25 <SubtleArray> wavewave: I look forward to feeling comfortable with this new paradigm. I feel most comfortable with procedural, but it has limitations. And object-oriented can get really abstract which makes execution flow hard to track. Functional has a lot of potential.
21:40:35 <SubtleArray> new paradigm = new for me
21:40:40 <SubtleArray> I know it's been around for awhile. :D
21:40:45 <CodeWeaverX> :)
21:40:53 * ski grins
21:41:12 <mzero> mmmmmm infinite pineapple upside-down cake.......
21:41:15 <DanBurton> Data.Sequence is a magical data structure
21:41:18 <CodeWeaverX> SubtleArray:  Don't make the mistake of assuming there's something one can do that the others can't.  They are computationally equivalent.  It's just the representation that changes.
21:41:28 <CodeWeaverX> Darnit mzero!
21:41:35 <CodeWeaverX> Now I want cake!
21:41:37 <CodeWeaverX> :P
21:41:55 <monochrom> you can have a pineapple cake
21:42:07 <wavewave> SubtleArray: ;-)
21:42:09 <mzero> me too, it would go well with the 2007 Cabernet Sauvignon I'm drinking
21:42:16 <monochrom> the only problem is you don't know whether it's PineappleT Cake or CakeT Pineapple
21:42:23 * ski has an old forgotten pineapple in fridge
21:42:34 <CodeWeaverX> Is it an infinite pineapple, ski?
21:42:35 <tikhonjelvis> ski: close enough
21:42:44 <mzero> I'd rather be in the Pinapple monad, 'cause the cake is a lie
21:42:47 * DanBurton yearns for Psych, with all this talk of pineapples
21:42:56 <CodeWeaverX> *nearly chokes on beer*
21:42:57 <SubtleArray> CodeWeaverX: True. I know from experience that procedural programming can do anything, and OOP doesn't have to be abstract. But functional, from what I gather, seems to natural lend itself to "syntatic transparency"? That might be the right term.
21:43:00 <ski> CodeWeaverX : it might have infinite longevity
21:43:00 <CodeWeaverX> Dammit, a portal haskell crossover.
21:43:25 <wavewave> SubtleArray: definitely you will be also better imperative programmer after learning haskell
21:43:42 <CodeWeaverX> SubtleArray:  I look forward to hearing what insights you have as you learn.  I'm sort of getting started myself.
21:44:06 <CodeWeaverX> Oh, what wavewave says is true:  Learning Haskell will improve your skills in other languages, even imperative ones.
21:44:33 <mzero> functional programming has a property that is often lacking in other languages... at dinner last night we were discussing it, and I dubbed it: "The Princess Bride" property --- which is, that a piece of code means what you think it means
21:44:49 <CodeWeaverX> Bwahahahahahaha
21:44:55 <CodeWeaverX> I love this channel.
21:45:00 <SubtleArray> :D
21:45:04 <mzero> JavaScript, for example, doesn't have this property -- if your code runs after some other code -- then you really have no idea what your code means
21:45:32 <mzero> this is because the prior code could have "monkey patched" everything in crazy ways, and you have no control over what anything means anymore
21:45:50 <tikhonjelvis> That's true to a lesser or greater extent in any language with mutation.
21:46:00 <DanBurton> @remember mzero functional programming has a property that is often lacking in other languages... at dinner last night we were discussing it, and I dubbed it: "The Princess Bride" property --- which is, that a piece of code means what you think it means
21:46:00 <lambdabot> Done.
21:46:03 <CodeWeaverX> Which is also why you want to keep most of your code pure.  To take advantage of the Princess Bride property.  To avoid monkey patching.
21:46:04 <DanBurton> priceless :)
21:46:15 <CodeWeaverX> Thanks, Dan.
21:46:19 <CodeWeaverX> I should have thought to do that.
21:46:21 <CodeWeaverX> Genius.
21:46:34 <CodeWeaverX> Well, at the very least hilarious.
21:46:35 <CodeWeaverX> :D
21:46:52 <mzero> imperative code often fails to have this property because of globals --- I called that function a thousand times and it was fine.... now it is returning NULL -- what's up with that?!?!?!?!
21:47:40 <CodeWeaverX> Global variables must die.
21:47:51 <SubtleArray> >_<
21:47:54 <CodeWeaverX> Of course, I've been practicing that in my C++ for … oh, an embarrassingly long time now.
21:47:56 <DanBurton> @google haskell global variables
21:47:58 <lambdabot> http://www.haskell.org/haskellwiki/Global_variables
21:47:59 <lambdabot> Title: Global variables - HaskellWiki
21:48:47 <sopvop> Monkey patching... I don't know why so many python programmer think it's a good idea. Had to stop using several nice libraries because they thought what they have right to monkey patch closed source binding to certain c api. hate em.
21:49:31 <mzero> of course we all do (reduce globals) --- but then that pesky class static shows up --- and then initialization order issues creep in --- and, well, we're all right back at Wesley telling us "...I don't think it means what you think it means"
21:49:39 <SubtleArray> I remember the stuggles I had switching from BASIC to OOP. >_< Local variables felt so limiting. Now I can't stand variables that aren't local.
21:50:27 <wavewave> now you don't have 'variable' in pure world.
21:50:37 <wavewave> welcome to purity
21:51:06 <SubtleArray> (^_^)
21:51:58 * ski . o O ( <http://ffd2.com/fridge/index.html> )
21:51:58 <monochrom> "What one man can invent, another can discover." great quote to be used next time "is math invented or discovered?" :)
21:51:58 <tkahn6_> netsplit
21:52:11 <DanBurton> I feel like we're at Bad Programmers anonymous or something :) I've been clean from effects for 1.3 years!
21:52:49 <CodeWeaverX> Soon, you won't be able to stand code that does a lot of mutations. :D
21:54:04 <wavewave> of course, sometimes mutation is necessary... important thing is 'control'
21:54:13 <CodeWeaverX> Sure.  Isolated exceptions to the paranoia.
21:54:26 <SubtleArray> CodeWeaverX: I can't stand that now. Lol
21:54:27 <tikhonjelvis> In most cases it seems to be an optimization.
21:54:35 <DanBurton> STM ftw
21:55:08 <SubtleArray> It's 1am here in Chicago. Time for me to get going. Good day, Haskellers.
21:55:17 * mzero is currently trying to design / code ugly mutating code (via MVars)
21:55:20 <wavewave> this control of mutation actually makes most well-defined layer structures.
21:55:25 <DanBurton> SubtleArray: may the Monoids be with you
21:55:44 <CodeWeaverX> SubtleArray: ...always
21:55:50 <nyingen> @quote
21:55:50 <lambdabot> Taral says: But I can do DP in C, which has no RT
21:55:55 <sopvop> My work is mostly in imperative languages, but now I try to write it purely... like first gather data, then compute new data, and only then update the world in one go.
21:56:02 <SubtleArray> Ha... Trying to figure out how to exit without hitting crtl-c. >_<
21:56:11 <CodeWeaverX> hahahaha
21:56:20 <DanBurton> slash quit?
21:56:21 <wavewave> I just rearranged my codes with pure/monad1/monad2../ IO
21:56:36 <nyingen> what is all this pwnage
21:56:42 <wavewave> then.. that just defines necessary layer structure
21:57:35 <mzero> well - night all
21:57:44 <CodeWeaverX> night
21:57:47 <tikhonjelvis> night
21:57:50 <wavewave> night
21:58:08 <DanBurton> mzero: sweet lambda-filled dreams
21:58:21 <DanBurton> -_- right after he leaves
21:58:55 <DanBurton> so much netsplit. I might as well go too.
21:59:34 <nyingen> @quote
21:59:35 <lambdabot> Dianora says: I need to learn haskell
21:59:37 <nyingen> @quote
21:59:38 <lambdabot> Knuth says: I envy astronomers: People expect them to study stars because stars are beautiful and interesting?
21:59:57 * ski glances around furtively
22:00:05 <nyingen> @quote
22:00:06 <lambdabot> Baughn says: I think I'm beginning to understand this language. I just defined 1+1=3.
22:01:14 * sopvop is going to by Nikki and the robots, even though disliking that kind of games
22:01:24 <sopvop> buy
22:01:49 <ski> I want EARS!  I want two ROUND BLACK EARS to make me feel warm 'n secure!!
22:03:51 <sopvop> ski: like that? http://upload.wikimedia.org/wikipedia/ru/thumb/f/f9/Film_2567_03.jpg/250px-Film_2567_03.jpg
22:05:04 * ski suggests "Hammerfist" <http://www.lemonamiga.com/games/details.php?id=482> to sopvop
22:05:46 <ski> (or maybe that's not cute enough ?)
22:11:51 <zzo38> The Template Haskell stuff for list of class instances is different in old and new version; will the compatibility version continue to working? What else is necessary to know about this?
22:12:18 <austin> hello
22:12:34 <ski> ehlo
22:13:04 <Guest82699> hi
22:13:11 <ski> lo
22:13:30 <Guest82699> what's the square root of 4
22:13:36 <ski> > sqrt 4
22:13:39 <lambdabot>   2.0
22:13:58 <zzo38> In my computer it is   ClassI Dec [ClassInstance]   but documentation says   ClassI Dec [InstanceDec]   what do I do?
22:14:27 <Guest82699> fuck
22:14:35 <zzo38> Does everyone hate my questions?
22:14:42 <ski> Guest82699 : do you need help ?
22:14:57 <ski> zzo38 : i suppose noone is around who knows the answer
22:14:57 <CodeWeaverX> No, zzo, but we probably don't know the answer and don't know how to respond.  Others may be along eventually who do. :)
22:15:07 <CodeWeaverX> Man, I'm wordy
22:15:32 <lpsmith> gwern, ping
22:15:52 <Guest82699> 你好
22:16:18 <ski> zzo38 : but i suppose if the map doesn't agree with the territory -- which do you follow ?
22:16:38 <ski> Guest82699 : sorry ?
22:16:44 <zzo38> ski: It is different in different versions. Does it cause incompatibilities?
22:17:09 * ski doesn't know
22:19:25 * hackagebot bytestring-delta 0.1 - Simple, fast binary diff/patch  http://hackage.haskell.org/package/bytestring-delta-0.1 (JoeyAdams)
22:19:27 * hackagebot bdelta 0.1.1 - Simple, fast binary diff/patch  http://hackage.haskell.org/package/bdelta-0.1.1 (JoeyAdams)
22:21:49 <zzo38> Using the "cabal info" command, I noticed the "base" package to have compatibility versions, although "template-haskell" package does not appear to have such a things.
22:43:15 <MichaelBurge> The FFI lets you interface with C code from Haskell; is there a way to interface with scripting languages like Ruby or Perl?
22:44:04 <ion> If by no other means, via C. :-)
22:44:58 <MostAwesomeDude> MichaelBurge: Well, do you want to host their VM in your address space, or do you want them to call into Haskell?
22:45:28 <MichaelBurge> They would call into Haskell
22:46:54 <MostAwesomeDude> Hm.
22:47:12 <MichaelBurge> ion: You're probably right - calling into Haskell is at some level equivalent to calling into C
22:47:21 <MichaelBurge> The other way around gives a little more room for creativity though
22:48:46 <MichaelBurge> IRC's being flooded with people :o
22:49:35 <ion> WeeChat’s smart filter hides the flood, leaving the actual discussion unhindered. ♥
22:49:55 <ski> MichaelBurge : netsplit (caused by DOS)
22:51:37 <pikhq> Jeeze, is there a natural disaster happening or something?
22:51:55 <ion> What ski said.
22:53:28 <sopvop> It's a nazi from dark side of the moon attack
22:54:49 <chu> There's a DOS attack or something.
22:55:03 <MichaelBurge> What's an elegant way to design a program which interfaces with multiple distinct IO subsystems(graphics, reading files, sound, input, etc.)?
22:55:10 <chu> https://twitter.com/#!/freenodestaff/status/167875722755575808
22:55:58 <MichaelBurge> In an OOP language, I'd define a global set of events, an abstract base class, and various inherited classes that each can respond to events
22:57:56 <MichaelBurge> I tried using typeclasses for a similar effect in Haskell, but I ended up having the equivalent of a list of arbitrary elements which I can't figure out the type of
22:58:17 <MichaelBurge> and was thinking there would be a more functional way to do this
22:59:59 <mm_freak> MichaelBurge: as you introduce static, strong algebraic typing you discover that many supposedly similar concepts aren't as related as OOP tries to sell them
23:00:03 <ski> MichaelBurge : you could use an existential for that
23:00:10 <ski> see <http://lukepalmer.wordpress.com/2010/01/24/haskell-antipattern-existential-typeclass/> though
23:00:59 <mm_freak> MichaelBurge: of course you can use an existential type to force everything under a common, broken interface, but is that really what you want?  do you really want to output graphics with the same interface you use to read user input?
23:01:16 <mm_freak> then you could just as well go back to OOP with subtyping
23:01:43 <ski> @wiki Existential type
23:01:44 <lambdabot> http://www.haskell.org/haskellwiki/Existential_type
23:02:43 <Rmx_> mm_freak, do you have any estimation of the time you need to complete you tutorial ?
23:02:49 <ski> record-of-functions is appropriate, sometimes
23:02:58 <MichaelBurge> mm_freak: You're probably right - but I'm not sure how else to think about it
23:03:33 <MostAwesomeDude> MichaelBurge: Well, are you hung up on the multiplexing of IO?
23:03:49 <mm_freak> Rmx_: no, sorry
23:04:19 <mm_freak> MichaelBurge: there is nothing wrong to approach them as entirely separate problems for now…  as you do, common patterns will emerge, for which you can actually express types
23:04:41 <Rmx_> arf :)
23:04:51 <mm_freak> Rmx_: was it helpful so far?
23:04:59 <Rmx_> yes, clearly!
23:05:04 <mm_freak> great =)
23:05:07 <Rmx_> it was smooth
23:05:18 <MichaelBurge> That makes sense - why try to design a big abstract system ahead of time when you don't have the information to really know what you're abstracting?
23:06:37 <Rmx_> strangely, I would have write "StateA True $ \(a, _) -> ((), a)" instead of "StateA True $ \(s, _) -> ((), s)" (it would have be more logical to me)
23:07:01 <Rmx_> and also use different notation for type of state and actual state variable
23:07:40 <Rmx_> I guess some people can find it confusing (but maybe those won't read this tutorial, so it's fine ;)
23:07:51 <MichaelBurge> How ugly would it be to have each subsystem store its state in global variables with the "a = unsafePerformIO $ newIORef" trick?
23:08:08 <Rmx_> but Thanks, really!
23:08:23 <Rmx_> I'm waiting toward reading the final version.
23:10:41 <Rmx_> "StateA True $ \(a, _) -> ((), a)" instead of "StateA True $ \(s, _) -> ((), s)" (it would have be more logical to me) ** fot putA function, my bad, I forgot to mention name of the function. **
23:10:57 <MostAwesomeDude> MichaelBurge: Learn to not think about global state.
23:11:59 <osa1> I just started to learn haskell and have some basic questions in my mind, why we need "map" function for lists when we have "fmap"?
23:12:18 <Philippa> Global state is for the IO monad. And even then you can't get at most of it
23:12:28 <Philippa> we don't
23:13:01 <Philippa> Hysterical raisins and simpler type errors, nothing more
23:13:02 <CodeWeaverX> We only need it to ease people into the idea of maps.
23:13:41 <osa1> CodeWeaverX: is there a way to see definition of map function?
23:13:46 <ski> @src map
23:13:46 <lambdabot> map _ []     = []
23:13:47 <lambdabot> map f (x:xs) = f x : map f xs
23:14:31 <Philippa> I like the foldr version, myself
23:15:06 <ion> I like the outsource-to-cheap-labor version, myself.
23:15:06 <CodeWeaverX> ok ok so there's more than one way to define it.
23:15:06 <osa1> ski: thanks, can I see the source in ghci?
23:15:11 <DarkUnicorn> Philippa: aren't map und foldr two different things?
23:15:26 <ion> codeweaverx: Wasn’t Haskell’s motto TMTOWTDI?
23:15:40 <MichaelBurge> Should the (,) operator be listed on Hoogle?
23:15:55 <CodeWeaverX> seriously tim-tow-tdee
23:16:05 <Philippa> DarkUnicorn: foldr subsumes map
23:16:49 <Philippa> map f = foldr ((:) . f) [] or so
23:17:01 <DarkUnicorn> Philippa: oh, right
23:17:08 <DarkUnicorn> nice :)
23:17:14 <ski> osa1 : lambdabot has some of the `Prelude' definitions in the `src' command. i'm not sure whether it's available in GHCi
23:17:32 <osa1> @str fmap
23:17:32 <lambdabot> Maybe you meant: arr ft src
23:17:36 <osa1> @src fmap
23:17:36 <lambdabot> Source not found. My pet ferret can type better than you!
23:17:41 <ion> @src [] fmap
23:17:42 <lambdabot> fmap = map
23:17:50 <ion> @src Maybe fmap
23:17:52 <lambdabot> fmap _ Nothing       = Nothing
23:17:52 <lambdabot> fmap f (Just a)      = Just (f a)
23:17:59 <Philippa> The platform lib docs have a lot of source links
23:18:21 <MichaelBurge> @src unsafePerformIO
23:18:21 <lambdabot> Source not found. I am sorry.
23:18:37 <CodeWeaverX> best place to go.  online source docs
23:19:24 <ion> philippa: In this case, the list of instances having source links would be useful. Perhaps we’ll get that one day. :-)
23:19:51 <ski> MichaelBurge : presumably since `(,)' is a bit special (syntactically), they possibly don't get listed in export lists, and hoogle hasn't them addedd manually
23:20:08 <NothingMan65> Good morning!
23:20:38 <ski> good morning
23:21:16 <osa1> why does haskell this big? ghc is bigger than all compilers/interpreters installed on my system..
23:21:35 <mm_freak> Rmx_: well, i view the state as the state at all times
23:21:48 <mm_freak> hence i use 's', when i'm dealing with it
23:22:00 <mm_freak> other people might use a different intuition there
23:22:06 <Rmx_> yes
23:22:18 <andkal_> s/why does/why is/
23:22:25 <Rmx_> sounds like a stupid remark
23:22:36 <mm_freak> MichaelBurge: haskell gives you a powerful type system precisely for the reason that you can express directly what you want
23:22:40 <Rmx_> and anyway so tiny detail :)
23:22:43 <Rmx_> thanks
23:23:05 <byorgey> osa1: it is a very sophisticated compiler, with lots and lots of features.
23:23:08 <mm_freak> MichaelBurge: you'll find that you really should forget most of the so-called "best practices" OOP has infected your brain with =)
23:23:38 <mm_freak> Rmx_: it's not so tiny actually, because the name of the variable tells you a lot about how people think =)
23:23:46 <Philippa> Also the linking is often inefficient
23:24:03 <Philippa> Especially on windows, AFAICT
23:24:52 <mm_freak> in a different world you might have written StateA (\(a, _) -> let s = a in ((), s))
23:24:55 <mm_freak> =)
23:24:55 <Jafet> Global variables is an OOP best practice?
23:25:04 <Rmx_> yeah!!
23:25:08 <Rmx_> totally
23:25:08 <ShinyDarkness> Hello. What is a Haskell list? An iterator?
23:25:26 <Jafet> A Haskell list is a list in Haskell
23:25:29 <Rmx_> I admit I find more logical to show that the state we put to the right is the argument we pass, regarding to the state of the left part
23:25:37 <mm_freak> Jafet: they give nice names to the same broken concepts…  for example in OOP you call global variables "class variables"
23:25:41 <ski> ShinyDarkness : it's a (lazy) linked list, but often can be used a bit like an iterator
23:25:44 <CodeWeaverX> Singly linked list.
23:25:57 <mm_freak> or "class properties" (as opposed to "object properties")
23:26:16 <Jafet> mm_freak: but that's theoretically justified, because classes are objects!
23:26:23 <mm_freak> ;)
23:26:30 <Jafet> (But programs aren't objects, something something)
23:26:40 <ski> Rmx_ : yes, i think `s -> (s,a)' would have been preferable
23:27:47 <mm_freak> Rmx_: people also commonly call term variables x, y, z while calling type variables a, b, c
23:27:56 <mm_freak> so in my world i'd replace 'a' by 'x'
23:28:02 <Rmx_> yes
23:28:14 <Rmx_> I admit that whe you speak about putA
23:28:34 * ski often^Wusually call term variables, having type `a', `a'
23:28:41 <Rmx_> it would be good to paste a commented declaration of  Data Arrow just above
23:28:49 <Rmx_> otherwise, we don't remind the type
23:29:08 <Rmx_> because, unlike you, we read this tutorial because we're not familiar with arrows
23:29:14 <mm_freak> good point
23:29:21 <Rmx_> so if you use the same letter for type and argument
23:29:29 <ion> By the time you reach “c” or “z” you might want to consider whether you’re using too many single-letter names. :-)
23:29:33 <Rmx_> and swap them..
23:30:00 <Jafet> ion: why limit yourself to latin?
23:30:19 <MichaelBurge> osa1: I think I remember reading somewhere that GHC includes multiple copies of some libraries
23:30:21 <mm_freak> x0, x1, x2, x3, x4, x5, …, x511
23:30:38 <Jafet> (Why limit yourself to variables?)
23:31:09 <osa1> MichaelBurge: do you remember reading why is that?
23:31:11 <ion> Let’s get rid of all variables. We should have a @pl for types as well.
23:31:23 <CodeWeaverX> (go lambdas or go C++!)
23:31:30 <Philippa> I use t, i, v, b a lot
23:31:32 <MichaelBurge> http://stackoverflow.com/questions/4858585/why-is-ghc-so-large-big
23:31:44 <osa1> thanks
23:32:04 <ski> Philippa : `k' ?
23:33:17 <Philippa> Don't handle constants so much. But c is probably con instead
23:33:45 * ski thought Philippa was talking about type variables
23:34:08 <Philippa> Nope, t is 'term'
23:34:34 <Philippa> I write too damn much lambda calculus munging code
23:34:57 * ski . o O ( "transformer","idiom","value" .. dunno "b" )
23:35:41 <Philippa> Body
23:37:06 <MichaelBurge> Haskell's usually contrasted with impure imperative languages like C; how does it compare with an HDL like Verilog?
23:37:35 <Jafet> You'll have to find someone who started using Haskell because he despised Verilog
23:39:28 * hackagebot hedis-pile 0.2.0 - Caching mandatory data with Redis  http://hackage.haskell.org/package/hedis-pile-0.2.0 (AlexanderDorofeev)
23:46:41 <mm_freak_> MichaelBurge: much closer to haskell actually because of the declarative nature
