00:00:20 <DanBurton> elliott: in my module, I have in my export list "module BS", and in my imports for that same module, I have "import qualified Data.ByteString as BS (ByteString)"
00:00:35 <DanBurton> elliott: so then I have a file that imports my module
00:00:49 <DanBurton> and it's giving me the "not an instance" error
00:02:34 <c_wraith> DanBurton: wrong module
00:02:48 <c_wraith> the IsString instance for ByteString is in Data.ByteString.Char8
00:03:33 <DanBurton> ah
00:07:47 <tigger> Hi all. I am working on some bindings, and am getting a "pointer being freed was not allocated" problem. It says set a breakpoint in malloc_error_break to debug, but I can't seem to find many tutorials for beginners on how I go about this exactly.
00:09:24 <merijn> tigger: OSX? :)
00:09:37 <tigger> merijn: yes
00:10:36 <merijn> If you link with debug binaries on OSX it will also use a malloc with debug support (triggering this message), you usually set a breakpoint in gdb when trying to debug that stuff. BUt I'm unsure how helpful GDB is when it comes to debugging haskell
00:10:41 <merijn> I suspect not so helpful
00:11:24 <NihilistDandy> That's a nice way to put it, if what little I've heard is so
00:11:31 <tigger> merijn: crap. that sounds painful. Could I possibly use the haskell trace module, so print statement like debugging?
00:11:45 <hpaste> DanBurton pasted “import/export type ByteString” at http://hpaste.org/63724
00:12:16 <DanBurton> any idea why the ByteString type isn't exported? ^
00:13:07 <merijn> tigger: Sure. The problem boils down to this: Somewhere in your code free is being called on a pointer that was not allocated using malloc
00:13:28 <merijn> tigger: Solution: Check where your haskell code might be calling free and where those pointers might come from
00:13:33 <erus`> what can i call a function that has no generic arguements
00:13:42 <erus`> or any type without generic args
00:13:49 <erus`> static? fixed?
00:13:59 <c_wraith> you mean not polymorphic?
00:14:06 <erus`> yes
00:14:08 <c_wraith> monomorphic is usually used
00:14:28 <DanBurton> strangely, I can get the error with the simple code, but in my larger code, the error doesn't exist o_O
00:15:04 <c_wraith> DanBurton: ghc has some bugs in instance scoping that are really hard to produce good test cases for.
00:15:25 <tigger> merijn: yeah. thankfully grepping shows theres only three places with 'free'
00:16:29 <DanBurton> c_wraith: should I submit a bug report with that little test case?
00:16:43 <c_wraith> I didn't read it.  maybe I should :)
00:17:00 <DanBurton> feel free :)
00:17:14 <NihilistDandy> DanBurton: Don't you need to import its constructors?
00:17:33 <c_wraith> where's the source for imports.hs ?
00:17:36 <NihilistDandy> Or at least some
00:17:38 <c_wraith> oh.
00:17:39 <c_wraith> nevermind
00:17:45 <c_wraith> file was so short, I missed it
00:18:26 <c_wraith> that's not an instance resolution bug, anyway
00:18:41 <c_wraith> It might be a rewrite rule bug.
00:19:35 <c_wraith> But it's messing with that intersection of reexporting a qualified import that I'm not familiar with
00:20:07 <c_wraith> what happens if you take the "qualified" out of the import?
00:20:12 <DanBurton> NihilistDandy: nah, just the type
00:20:46 <elliott> DanBurton: give imports.hs a module signatuer
00:20:49 <elliott> *signature
00:21:03 <DanBurton> c_wraith: it works just fine if I take out "qualified"
00:21:19 <c_wraith> yeah, I think your issue is with the intersection of module exports and qualified imports
00:21:22 <elliott> hmm, it does?
00:21:23 <elliott> oh, duh
00:21:34 <elliott> DanBurton: what happens if you say BS.ByteString
00:21:39 <elliott> from imports.hs
00:21:49 <elliott> IIRC you can't re-export qualified stuff like that
00:22:04 <elliott> "(module Foo)" actually means "all the identifiers in scope from module Foo"
00:22:11 <elliott> which in this case is none of 'em
00:22:45 <c_wraith> I really don't know how module exports work with qualified imports
00:23:05 <mux> :t (<>)
00:23:06 <lambdabot> Doc -> Doc -> Doc
00:23:29 <c_wraith> It'd actually be kind of handy if you could export the qualified name for the module into the importer's namespace - but also really odd
00:23:39 <DanBurton> elliott: 1) giving imports.hs a modular signature doesn't fix it. 2) BS.ByteString also doesn't work 3) exporting a qualified import does actually work in the larger code I am working with
00:23:48 <c_wraith> mux: GHC 7.4 added <> as a synonym for mappend in Data.Monoid
00:24:00 <mux> I know
00:24:13 <c_wraith> were you just checking if \bot had it?
00:24:15 <DanBurton> I'll send a link once I push to github in a couple mins
00:24:27 <mux> yeah, I was wondring if LB had been updated to 7.4.1
00:24:29 <c_wraith> :t (++)
00:24:30 <lambdabot> forall m. (Monoid m) => m -> m -> m
00:24:40 <c_wraith> it has that, though!
00:24:56 <mux> yeah, LB deviates too much from the Haskell Prelude if you ask me :-/
00:29:09 * mux wishes ByteString was integrated in the Prelude and used in many places where it doesn't make sense to use String (including I/O)
00:29:20 <merijn> mux++
00:29:44 <merijn> getLine :: IO String is a gross lie :\
00:29:49 * mux nods
00:29:53 <mux> type FilePath = String is a lie too
00:30:05 <ion> @hackage system-filepath
00:30:06 <lambdabot> http://hackage.haskell.org/package/system-filepath
00:30:56 <mux> ion: nice
00:31:32 <mux> lazy bytestrings to represent a list of path components and an abstract data type to get more type-safety
00:31:35 <mux> very nice
00:31:43 <DanBurton> c_wraith, elliott: this is the "larger code" I was talking about http://github.com/DanBurton/netspec
00:32:09 <mux> ah, no lazy bytestrings, just a list of Chunks thing
00:32:13 <mux> and it has type Chunk = String
00:32:51 <mux> but it deals with encodings for different platforms, that's cool
00:33:23 <mux> uuuh, it assumes all file paths are encoded in utf8 o_O
00:33:24 <mux> not cool.
00:33:46 <elliott> only on unix i think
00:33:49 <elliott> which is all you can do
00:33:57 <elliott> since they are bytestrings with no encoding metadata
00:33:59 <mux> unix has no specified encoding for filenames, it's only conventions
00:34:02 <elliott> yes
00:34:08 <mux> windows uses utf16-le
00:34:08 <elliott> which is why things dealing with unicode assume utf-8
00:34:12 <mux> this code assumes everything is utf8
00:34:21 <tigger> merijn: got it! thanks
00:34:32 <mux> that's just going to fail under windows
00:35:00 * mux isn't sure we need a polymorphic representation too, bytestrings are enough
00:35:01 * hackagebot ghc-mod 1.10.6 - Happy Haskell programming on Emacs  http://hackage.haskell.org/package/ghc-mod-1.10.6 (KazuYamamoto)
00:35:32 <erus`> is there  a name for something that isnt a value
00:35:43 <erus`> lol i mean function
00:36:08 <elliott> mux: I don't see any evidence that it assumes Windows uses UTF-8 encodings from the source.
00:36:18 <erus`> x is an Int. f is an Int -> Int . How can i describe x
00:36:26 <elliott> Also, ByteStrings aren't enough because many ByteStrings map to one file path and some ByteStrings are not valid file paths
00:36:33 <elliott> additionally which ByteString represents a filepath is dependent on the OS
00:36:41 <mux> elliott: comment from the fromText function
00:36:50 <elliott> a bytestring is about as suitable for representing a filepath as it is for representing a tree of floating point numbers
00:36:52 <mux> elliott: yes, but that doesn't contradict what I just said one bit
00:37:05 <mux> I don't think you understood me
00:37:10 <elliott> mux: that's only if you go from Text
00:37:16 <elliott> getting things from the OS will still work
00:37:17 <mux> well d'oh..
00:37:18 <elliott> but I agree that's imperfect
00:37:24 * mux nods
00:38:17 <mux> anyways, this code still uses Strings under the hood to represent file paths
00:38:56 <elliott> it should use an abstract representation
00:38:58 <elliott> imo
00:39:01 <mux> it does
00:39:19 <mux> but yes it should, that gives us more type-safety
00:40:06 <elliott> oh right, it does
00:40:18 <elliott> the representation worries me a bit thoguh
00:40:21 <elliott> *though
00:40:24 <elliott> lots of fields, lots of boxing
00:40:27 * mux nods again
00:40:28 <mux> and Strings :)
00:41:11 <elliott> bte
00:41:12 <elliott> *btw
00:41:12 <elliott> http://hackage.haskell.org/packages/archive/system-filepath/0.4.6/doc/html/src/Filesystem-Path-CurrentOS.html
00:41:26 <elliott> it /does/ handle windows vs. unix unicode vs. bytestring in this module
00:41:31 <elliott> which is apparently what you're intended to import
00:43:10 <mux> elliott: ah, cool
00:44:46 <mux> erus`: I didn't get that question
00:47:16 <erus`> how can i describe a non function
00:47:24 <erus`> at the moment i use 'non function'
00:47:31 <elliott> you don't
00:47:33 <mux> but everything is a function :)
00:47:38 <elliott> how do you describe a non-banana?
00:47:38 <mux> even functions with arity 0 :D
00:47:41 <elliott> mux: no
00:47:48 <elliott> http://conal.net/blog/posts/everything-is-a-function-in-haskell
00:47:49 <erus`> oh boy, here we go
00:48:08 <elliott> erus`: anyway "non-function" is fine, "not X" is the best you'll get for a negative concept like that
00:50:42 <mux> elliott: well that's a subjective point of view, one way or the other
00:50:57 <elliott> mux: no, it is not
00:51:07 <elliott> the definition of "function" in the context of Haskell is objective and unambiguous
00:51:13 <mux> sigh
00:51:19 <SmartViking> Hi, if I want to see what types are in a typeclass, or the source code of a prelude function, can I do the in ghci?
00:51:26 <elliott> you can, however, subjectively choose to misuse the word, and certainly that's a viewpoint, but it is not in any way justified
00:51:28 <mux> SmartViking: :i TypeClass should do it
00:51:31 <erus`> ooh poo i have a recursive dependency
00:51:37 <randomclown> @pl \x -> (func1 x, func2 x)
00:51:37 <lambdabot> liftM2 (,) func1 func2
00:51:57 <erus`> a Type can point to a binding and a binding can point to a type
00:52:00 <mux> elliott: there is nothing in that blog post that formally proves that it doesn't make sense to say that 0-ary functiosn are still functions, so I stand by what I said.
00:52:04 <elliott> mux: to use an example from the blog post, i am sure you would not consider it a reasonable subjective POV to consider everything a list?
00:52:15 <mux> elliott: and I believe stating that this is objectively wrong is dishonest
00:52:18 <donri> mux: only 1-arity functions exist in haskell
00:52:24 <elliott> 2-nesty list: [[a]]
00:52:26 <elliott> 1-nesty list: [a]
00:52:29 <elliott> Integer must be a 0-nesty list.
00:52:30 <mux> elliott: so is the comparion with 3 being "just" [3] because it is syntactically different
00:52:31 <donri> 0-arity functions can certainly be said to be functions, but haskell doesn't have th em
00:52:41 <elliott> mux: ok:
00:52:44 <elliott> type (:->) = Map
00:52:49 <elliott> 2-nesty map: a :-> b :-> c
00:52:53 <elliott> 1-nesty map: a :-> b
00:52:57 <elliott> Integer must be a 0-nesty map.
00:53:04 <elliott> (is it the colon that invalidates this?)
00:53:14 <mux> that is still a dishonest comparison to me :)
00:53:34 <SmartViking> mux: Thanks!
00:53:41 <elliott> yes, as would any example be; such is the nature of misconceptions
00:53:43 <ion> What’s the difference between a comparison to a function?
00:53:53 <ion> +that and
00:54:03 <elliott> after all, there is always some fundamental difference; namely, that you don't believe one, and believe the other
00:55:49 <quicksilver> mux: there is no formal reason not to call apples bananas.
00:55:55 <randomclown> what's the record syntax for declaring a tuple with 3 doubles
00:56:00 <quicksilver> mux: not is there any formal reason not to call the sky, a lobster.
00:56:10 <randomclown> not sure if (Double, Double, Double) will work
00:56:16 <elliott> saying that Integer has "arity 0" can have meaning, for instance in lifting patterns (liftM and such)
00:56:17 <quicksilver> mux: however, by using function to mean something other than function, you are just speaking a different language.
00:56:18 <mux> quicksilver: there is nothing formal about fruits to begin with, you're taking things out of a scientific context
00:56:21 <elliott> however, "arity 0 function" it is not
00:56:29 <randomclown> is it Double a => (a, a, a)?
00:56:32 <quicksilver> mux: no, I was building up a simile.
00:56:42 <elliott> quicksilver: pseudoscientist! :P
00:56:43 <quicksilver> mux: function has an accepted mathematical meaning.
00:56:57 <quicksilver> mux: whilst the natural *generalisation* of functions to arity 0 is quite obvious and logical
00:56:58 <elliott> mux: anyway I am sure you can ask the Report or spj or someone if you want to be put out of your misconception
00:56:59 <mux> quicksilver: not in the context of haskell, or does the prelude gives a formal definition of what's a function?
00:57:01 <quicksilver> that is not what functions mean.
00:57:11 <elliott> I think you will find that the Report defines functions.
00:57:11 <quicksilver> that is a generalisation.
00:57:20 <elliott> (indeed, the property that distinguishes things that can be called "arity 0" is exactly their not being functions)
00:57:24 <quicksilver> functions are functions. And non-functions are not functions.
00:57:35 <mux> elliott: if you can point out a part of the haskell report that contradicts what I said, then yes, I'll keep shut because I'll consider this is a formal proof that what I said is wrong
00:58:16 <donri> more interestingly, everything *including functions* is a "value" in haskell
00:58:28 <mux> well that one is obviously true
00:58:32 <donri> that is, functions are just one type of a value rather than the other way around
00:58:54 <elliott> mux: can you point me to the place in the report where it says that not all values are Maps?
00:58:56 <elliott> thanks!
00:59:17 * mux shrugs
00:59:37 <quicksilver> or the point in the report where is says that patterns are not data declarations
00:59:48 <tihach> hi folks
00:59:51 <quicksilver> it would be a long report if it specified all possible pairs of "A is not B"
01:00:20 * elliott notes that the Prelude does refer to undefined as a function, but (undefined :: a -> b) types, so it's not a "formal" proof
01:00:24 <elliott> as if anything in the report is formal
01:00:34 <elliott> (it also says typeclasses let you defined overloaded functions, but that is again true)
01:00:49 <elliott> (still of course it is unfortunate it uses the terminology in a way that has such potential to mislead)
01:01:54 <donri> in deed, took me a while to get over monadic computations like Reader "ask" not being functions
01:02:14 <ben> :t ask
01:02:15 <lambdabot> forall (m :: * -> *) r. (MonadReader r m) => m r
01:02:17 <elliott> donri: well, Reader is a newtype over a function, so it's a little closer than most ;)
01:02:23 <elliott> and I think (->) is even a MonadReader instance!
01:05:01 * hackagebot IntervalMap 0.2.3.1 - Maps from Intervals to values, with efficient search.  http://hackage.haskell.org/package/IntervalMap-0.2.3.1 (ChristophBreitkopf)
01:05:17 <SmartViking> @src max
01:05:17 <lambdabot> max x y = if x <= y then y else x
01:05:29 <SmartViking> Can you do ^ that in ghci?
01:05:39 <mux> the @src command?
01:05:42 <SmartViking> Yes
01:05:47 <mux> no you can't
01:05:47 <NihilistDandy> If you install GOA, yeah
01:05:53 <mux> it's a separate t hing
01:05:55 <ion> GOA?
01:05:58 <elliott> ghc on avid
01:05:59 <elliott> acid
01:06:02 <elliott> integrates lambdabot in ghci
01:06:06 <ion> ah
01:06:10 <mux> fun name :)
01:06:22 <quicksilver> you wouldn't really want to, since @src is limited and sometimes a bit broken
01:06:33 <quicksilver> I meant, GOA is great, but @src is the worst motivation for it.
01:06:59 <quicksilver> learn to use the library docs (online or offline) which have full actual source of libraries, much more useful.
01:07:27 <SmartViking> Or I could make my own plugin specifically for viewing prelude source
01:08:49 <elliott> ghci doesn't have plugins
01:09:17 <SmartViking> Then I'll make a program and call it with :!  :)
01:09:54 <mux> so, GHC.Generics is very very cool; I layered a generic interface on top of some Bencode parsing code, and added a way to optionally apply a translation function on accessor names, so you can use the interface even if you have dictionary keys containing spaces, or that are haskell reserved keywords, etc
01:10:11 <mux> https://bitbucket.org/mumux/bencode/src/tip/Example.hs
01:10:58 <mux> I need to get a hold on bos to know if he plans to do something like that in the generic interface for aeson
01:11:26 <mux> it's so cool to parse and essentially validate some kind of a schema in one stop, the schema being inferred from your type's structure
01:11:34 <mux> s/stop/step/
01:11:57 <donri> SmartViking: http://hackage.haskell.org/package/haskdogs
01:12:31 <dreixel> mux: glad you like it!
01:12:45 <mux> dreixel: more than that, I'm in love with it :-)
01:12:57 <mux> dreixel: looks like it could use PolyKinds though
01:13:06 <dreixel> mux: it definitely can
01:13:07 <mux> and DataKinds too
01:13:11 <mux> for extra cuteness
01:13:13 <dreixel> oh, well
01:13:18 * mux grins
01:13:19 <dreixel> actually, it can and should use DataKinds
01:13:33 <dreixel> PolyKinds is a bit trickier (if you're thinking of supporting multiple datatype parameters)
01:13:59 <mux> dreixel: I was essentially thinking it would remove the need for the Foo0 / Foo1 stuff, not sure if that's right
01:14:25 <dreixel> mux: no, unfortunately it's not that simple :(
01:14:30 <mux> ah :(
01:14:53 <dreixel> mux: I wrote something about that here: http://hackage.haskell.org/trac/ghc/wiki/Commentary/Compiler/GenericDeriving#Kindpolymorphicoverhaul
01:14:57 <elliott> (Could it use DataKinds to provide e.g. record field names as type-level Strings?)
01:15:26 <db81> Can cabal unregister packages or, more generally, what is the proper way to delete a package?
01:15:39 <mux> dreixel: thanks, will read!
01:15:40 <elliott> db81: ghc-pkg unregister blah, find its files if you care
01:15:49 <elliott> db81: but I just rm -r ~/.cabal ~/.ghc and start over if I get myself into trouble
01:15:55 <elliott> db81: http://hackage.haskell.org/package/cabal-dev may interest you
01:16:02 <db81> elliott: thanks
01:16:05 <dreixel> elliott: haven't thought about that before...
01:16:37 <NihilistDandy> It's the only efficient way I've found to clean up after trouble, too
01:16:39 <dreixel> elliottt: you have a particular use-case in mind?
01:16:53 <mux> I'm curious too, given that you'll need the value-level strings anyways
01:17:02 <elliott> dreixel: not at all, it just sounds interesting :P
01:17:35 <elliott> dreixel: I suppose the approach I'd go with as far as generics goes would be to essentially define the AST for data declarations and let it be lifted with DataKinds
01:17:57 <elliott> which would do that naturally
01:18:27 <elliott> but then you need an additional layer before you can actually write the generic code since the cost of the flexibility is that it's less "structural"
01:18:41 <mux> dreixel: btw, is it normal that with GHC 7.4, _all_ my K1 types are tagged with R rathern than P even though there is no recursion involved?
01:18:48 <mux> dreixel: it seems to contradict the documentation
01:19:02 <dreixel> mux: I would expect that behavior
01:19:17 <dreixel> mux: which documentation?
01:19:35 <mux> dreixel: the GHC one, with the example UserTree datatype
01:19:40 <dreixel> mux: basically, you should think of P for parameters, and R for everything else.
01:19:48 <dreixel> mux: the user's guide?
01:19:58 <mux> dreixel: it shows K1 R for the subtrees, which makes sense, and K1 P for the node's value, as I would expect
01:20:14 <mux> yeah, the user's guide
01:20:23 <dreixel> yes, that is correct
01:20:57 <mux> ok, then maybe my expectation is wrong: I would expect a type "data Foo = Foo Int" to be represented as M1 S NoSelector (K1 P ...)
01:21:08 <elliott> but Int isn't a parameter
01:21:10 <dreixel> no, P is for type arguments
01:21:21 <mux> aaaaaaaaaah, _type_ arguments
01:21:28 <dreixel> Foo has no type arguments, so it won't have any P's
01:21:36 <mux> which explains why it's K1 P for the UserTree datatype
01:21:41 <mux> ok, I get it now
01:21:43 <mux> thanks!
01:21:46 <dreixel> yw
01:30:02 * hackagebot imagesize-conduit 0.2.0 - Determine the size of some common image formats.  http://hackage.haskell.org/package/imagesize-conduit-0.2.0 (MichaelSnoyman)
01:36:29 <KorriX> hello everybody
01:37:24 <KorriX> how to embed html code as strings in blaze-html ?
01:37:34 <KorriX> i mean to render H.div "<b>Sth</b>"
01:37:43 <KorriX> as H.div $ H.b "sth"
01:40:11 <donri> KorriX: preEscapedText
01:42:25 <donri> well, preEscapedString if you really mean String
01:47:17 <parcs`> what `x >>= \a -> a `seq` return a` equivalent to `evaluate x' ?
01:47:28 <parcs`> s/what/is
01:48:18 <parcs`> err 'x >>= evaluate'
01:48:35 <elliott> evaluate x === (return $! x) >>= return
01:48:45 <elliott> (which is /not/ the same as (return $! x); the monad laws weep)
01:49:18 <elliott> parcs`: and since (return $! x) === (x `seq` return x), the answer to your question is no
01:49:20 <elliott> but it's close.
01:49:27 <elliott> here's the difference:
01:49:40 <elliott> > (return $! undefined :: IO ()) `seq` ()
01:49:41 <lambdabot>   *Exception: Prelude.undefined
01:49:44 <elliott> > ((return $! undefined) >>= return :: IO ()) `seq` ()
01:49:45 <lambdabot>   ()
01:49:55 <quicksilver> in fact you can't define evaluate by seq
01:49:56 <quicksilver> IMO.
01:50:27 <elliott> I just did
01:50:27 <KorriX> thx
01:50:31 <elliott> and that definition is in the documentation
01:50:36 <quicksilver> my contention is that your definition is wrong
01:50:42 <quicksilver> yes, my further contention is that the documentation is wrong :)
01:50:52 <elliott> how is my definition wrong?
01:51:03 <quicksilver> because of the monad law, basically
01:51:13 <elliott> quicksilver: ah, you're definitely wrong then
01:51:18 <elliott> consider, Reader violates the monad laws in the exact same way
01:51:20 <quicksilver> the semantics of >>= and return permit that transformation
01:51:28 <elliott> quicksilver: but we ignore _|_ for the sake of laws
01:51:30 <elliott> which is what's relevant here
01:51:35 <quicksilver> so a compiler could choose to make them equal
01:51:41 <elliott> if you don't want to do that, you have to remove most of transformers
01:51:48 <quicksilver> it's true that we ignore _|_ for laws
01:51:49 <quicksilver> I agree
01:51:53 <elliott> yes
01:51:56 <quicksilver> but I don't think that makes this problem go away
01:51:59 <elliott> and the compiler cannot make transformations which change semantics
01:52:06 <elliott> so, since it can only assume weaker forms of the laws...
01:52:49 <ChristianS> evaluate a = IO $ \s -> seq# a s -- http://hackage.haskell.org/packages/archive/base/latest/doc/html/src/GHC-IO.html#evaluate
01:52:52 <quicksilver> whether - and when - "(x `seq` return x) >>= return" forces x depends in some detail on the precise implementation of >>=
01:52:57 <quicksilver> ChristianS: that's not helpful.
01:53:08 <quicksilver> ChristianS: that's the GHC implementation, which is dependent on the GHC implementation of IO.
01:53:28 <quicksilver> it doesn't give us a semantically precise defitnition.
01:54:17 <elliott> quicksilver: btw, the fundamental issue here is that (const _|_) =/= _|_
01:54:20 <elliott> which is caused by
01:54:21 <elliott> you guessed it!
01:54:22 <elliott> seq
01:54:28 <elliott> now if we had the haskell 1.4 situation where functions aren't seqable
01:54:35 <elliott> then there would be no problem
01:54:36 <emph> Hey! Got a question. I'm doing a school assignment atm. The assignment is to construct a Replay-monad. I'm doing a transformer-stack with a statet,  writert, eithert and last IO. However I have got some problems.  Lets say my replay fails in which I invoke EitherT.left (lifted), how can I extract the output of the writer? Is it possible?
01:54:39 <quicksilver> I'm not sure that's fundamental here.
01:54:40 <elliott> we would just not make IO seqable
01:54:42 <elliott> and everyone would be happy
01:54:42 <quicksilver> It's related, I agree
01:54:45 <elliott> and the two definitions would be equivalent
01:54:49 <quicksilver> btu I'm not sure it's fundamental.
01:55:00 <elliott> quicksilver: well, a (->) is the only way I know the standard monads to violate the laws
01:55:15 <elliott> quicksilver: by the way, I do not think we can have a semantically precise definition at all
01:55:19 <quicksilver> I think the intuitive statement of the fundamental problem is that "seq" forces a value in the *evaluation* sequence.
01:55:20 <elliott> since it is IO we are talking about
01:55:32 <quicksilver> whilst evaluate is intended to force a vale in the *execution* sequence
01:55:45 <kstt> 'seq' and 'par' are operational semantic operator
01:55:46 <quicksilver> so it's not that surprising that it's hard to give a clear definition of evaluate in terms of seq
01:56:03 <rostayob> elliott: you mean ((->) a)? Also, violates the monad laws why? because you can introduce strictness?
01:56:07 <kstt> in my opinion they don't play very nicely with the rest of haskell
01:56:15 <quicksilver> since the precise interplay of execution with evaluation is to some limited sense up to compiler.
01:56:35 <elliott> rostayob: no, I mean "a (->)"
01:56:42 <elliott> violates the monad laws because >>= return is not id
01:56:51 <elliott> because _|_ is not const _|_
01:56:57 <kstt> some days I love non-strict, and some other I don't like it ...
01:57:06 <elliott> kstt: actually seq is denotationally defined
01:57:22 <rostayob> "a (->)" is not part of the base monads
01:57:26 <elliott> rostayob: a function arrow
01:57:33 <elliott> kstt: seq _|_ b = _|_; seq a b = b
01:57:39 <elliott> kstt: in particular, evaluation order is *not* specified
01:57:50 <elliott> indeed a Sufficiently Smart compiler can not bother with it at all if it knows the first argument isn't _|_
01:58:07 <rostayob> I didn't even know "-> a" was a monad at all
01:58:36 <kstt> elliott: but that can't be known in the general case, right ?
01:58:51 <elliott> kstt: no, but that's not really relevant
01:58:59 <elliott> it was just an example to show that it's not really operational at all
01:59:12 <elliott> rostayob: I can't tell whether you're making a pedantic point about my syntax or are just trying to understand what I'm saying without context
01:59:31 <rostayob> elliott: I definitely don't have context (I just joined)
01:59:42 <rostayob> but I don't understand your context about this "(->) a" mona
01:59:45 <rostayob> d
01:59:46 <elliott> rostayob: right, that's presumably the problem then
01:59:47 <aadrake> Does anyone know if it's appropriate to post Haskell-related job openings to the Haskell-Cafe mailing list?
01:59:47 <rostayob> *you comments
01:59:50 <elliott> I never said (->) a monad
01:59:54 <elliott> I said
01:59:59 <elliott> a <function arrow> is the only way I know the standard monads to violate the laws
02:00:04 * hackagebot AppleScript 0.2 - Call AppleScript from Haskell, and then call back into Haskell.  http://hackage.haskell.org/package/AppleScript-0.2 (ReinerPope)
02:00:58 <rostayob> elliott: I still don't understand :P. Are you talking about the "a ->" monad?
02:01:07 <rostayob> or "(->) a", or whatever
02:01:28 <alang> rostayob: no the "a" part is english, not haskell
02:01:42 <rostayob> oh god. ok.
02:02:40 <ion> :-)
02:08:12 <frerich> rostayob: It's fun to read the backlog with your idea of 'a ->' monad in mind. :-)
02:08:27 <rostayob> frerich: I guess lol
02:08:36 <rostayob> well, 'a ->' is a monad :P
02:08:40 <rostayob> '-> a' isn't
02:08:42 <rostayob> that confused me eheh
02:09:53 <frerich> It's usually called the "reader" monad, isn't it? I always wondered why that is, and what it's often 'r ->' (or '(->) r'). Because the lhs is being 'read'?
02:10:16 <rostayob> frerich: yes it's the reader monad without a wrapper
02:10:54 <frerich> rostayob: Would 'function monad' or something like that be more appropriate?
02:11:59 <rostayob> frerich: I guess reader monad conveys the idea better...
02:12:18 <rostayob> 'function monad' might be mistaken for the identity monad
02:14:02 <Rc43> Hi, guys.
02:14:30 <Rc43> Suppose I have a file with lines of pairs of integral numbers.
02:14:31 <rostayob> elliott: anyways, I get what you're saying now
02:14:49 <Rc43> What is convinient way to parse them into adjacency matrix?
02:15:11 <elliott> rostayob: yay :P
02:15:36 <elliott> frerich: it's the reader monad because it's sort of dual to writer
02:15:38 <ion> Parse them into a list of pairs first, then convert that to an adjacency matrix.
02:15:41 <Rc43> I tried to parse them as pairs or custom edge type (for speed) and them iterating the list such elements set IOArray (a,b) to True or False
02:15:48 <Rc43> but it takes a lot of memory
02:16:14 <Rc43> ion, my code was ok, but it can't pass memory limit on the contest
02:16:20 <Rc43> (training contest)
02:16:22 <rostayob> Rc43: you might want something sparse - e.g. IntMap
02:16:46 <rostayob> arrays as I'm sure you know allocate the whole block of memory for constant access
02:17:05 <Rc43> also I have tried to use ByteString by elliott's advice, and it helped some (from 170mb to 100mb on a custom example)
02:17:09 <rostayob> well IntMap wouldn't work, maybe an HashMap
02:17:49 <Rc43> rostayob, isn't array better for adjacency checking? Instant access?
02:17:59 <rostayob> Rc43: the access time if faster
02:18:07 <rostayob> but as you noticed it takes up a lot of memory
02:18:17 <rostayob> and with a sparse array it might not be convenient
02:18:18 <Rc43> Oh
02:18:19 <Rc43> really
02:18:26 <Rc43> I forgot about it.
02:18:30 <rostayob> the proverbial space/time tradeoff
02:18:44 <Rc43> Good advice, but I forgot to say that bottlenck is file parsing.
02:18:55 <rostayob> Rc43: attoparsec?
02:19:05 <Rc43> Is it standard?
02:19:09 <rostayob> Rc43: define standard
02:19:18 <rostayob> the answer is probably "no"
02:19:30 <rostayob> but it's a stable and widely used package
02:19:56 <Rc43> Included the "base" package (don't sure about haskell platform). I need to launch my code in test cyctem, can't to install packages.
02:20:04 <Rc43> *system
02:20:06 * hackagebot AppleScript 0.2.0.1 - Call AppleScript from Haskell, and then call back into Haskell.  http://hackage.haskell.org/package/AppleScript-0.2.0.1 (ReinerPope)
02:20:07 <rostayob> Rc43: no, it isn't.
02:20:12 <rostayob> Rc43: If you need a package in base
02:20:15 <rostayob> the only way is Binary
02:20:17 <rostayob> well
02:20:22 <rostayob> not in base, but that comes with GHC
02:20:37 <rostayob> I suppose you'd have the haskell platform with GHC anyways
02:20:45 <rostayob> but Binary is probably better than parsec for your task
02:21:29 <Rc43> rostayob, will look at it
02:21:44 <rostayob> Rc43: what are you using now?
02:22:06 <rostayob> if you're using parsec, Binary will definitely be faster
02:22:21 <rostayob> expecially if it's a binary file (duh...)
02:22:27 <Rc43> (map ((map readI).words)).lines
02:22:33 <Rc43> fst . fromJust . readInt
02:22:40 <Rc43> readI = fst . fromJust . readInt
02:22:57 <rostayob> Rc43: so it's strings all the way? yeah that's going to be slow
02:22:59 <elliott> Rc43: bytestring isn't in base either
02:23:13 <Scott_> hello
02:23:22 <Rc43> elliott, oh, but it was passed, so there is platform or something.
02:23:57 <emph> Hi, got a problem. Have a transformer-stack looking something like: StateT InputState (WriterT Output (EitherT q IO)) a. The problem I have is that when the computation works I get a result Right (a,Output) without problems. But when it fails I can just retrive q, not the Output. Is this even possible or am I walking in circles?
02:24:24 <Rc43> Also, it seems i need to do something imperative or like iteratee for not-storaging list of pairs but get the array/map at once.
02:24:51 <rostayob> Rc43: I doubt that's the problem there
02:25:00 <rostayob> your problem is that strings are slow
02:26:21 <elliott> emph: EitherT needs to go outside the WriterT
02:26:46 <Rc43> rostayob, what about ByteString?
02:27:19 <emph> elliott: Okok, I'm rather new to transform-stacks. Will try that! Thanks
02:27:45 <rostayob> Rc43: ByteStrings are faster but if your file is a text file writing a parser like that without attoparsec or similar will be kind of annoying
02:28:50 <rostayob> Rc43: you can just include attoparsec code with your code!
02:29:04 <Rc43> rostayob, :D
02:29:12 <rostayob> it doesn't depend on anything non-haskell platform
02:29:39 <rostayob> otherwise you can use binary but you'd have to write your "read"-like functions manually
02:30:06 <Rc43> rostayob, yeah, and I see that code isn't huge
02:30:41 <Philippa> emph: as a rule of thumb, things on the bottom of the stack 'override' things on the top - so if they undo things, they'll undo state above them
02:30:47 <Rc43> rostayob, also, I have tried to use lazy byte strings, and (not sure) have seen that they were slower
02:30:57 <Rc43> rostayob, can it be so?
02:31:08 <rostayob> Rc43: yes
02:31:33 <emph> Philippa: Thanks, will keep that in mind.
02:31:35 <rostayob> lazy bytestrings are basically a list of strict bytestrings
02:31:43 <rostayob> Rc43: they're called "lazy" because they're lazily loaded
02:31:56 <rostayob> so as you consume the bytestring it loads chunks
02:32:20 <Rc43> and why they are slower?
02:32:21 <rostayob> the chunks are reasonably sized and it shouldn't be much slower really...
02:32:36 <Rc43> not much
02:32:43 <rostayob> Rc43: because of the loading overhead
02:32:53 <Rc43> ok, understood
02:33:41 <rostayob> Rc43: lazy bytestrings are actually more efficient when appending bytestrings
02:34:38 <Rc43> rostayob, because it can store them like <readed_chinks> : <unreaded_chunks (mock)> : <appended_chunks> ?
02:34:40 <parcs`> @unmtl StateT InputState (WriterT Output (EitherT q IO)) a
02:34:40 <lambdabot> InputState -> EitherT q IO (a, InputState, Output)
02:34:53 <parcs`> @unmtl StateT InputState (WriterT Output (ErrorT q IO)) a
02:34:53 <lambdabot> InputState -> IO (Either q (a, InputState, Output))
02:35:11 <parcs`> emph: that command may be of use for you
02:35:40 <parcs`> @unmtl ErrorT q (StateT InputState (WriterT Output IO)) a
02:35:41 <lambdabot> InputState -> IO (Either q a, InputState, Output)
02:35:42 <dsx7> Hi, there's something I don't understand about (<*): if I run     writeFile "/tmp/a1" "run" <* writeFile "/tmp/a2" "run"    , it creates both a1 and a2, whereas if I run      return "string" >>= writeFile "/tmp/xxx1" <* writeFile "/tmp/xxx2"    , the xxx1 is there but xxx2 not. I kind of understand the second case more (because of liftA2 const) but I'm not sure why in the first case both files get created
02:35:45 <rostayob> Rc43: because it doesn't have to copy the entire bytestring, but at most the size of a chunk
02:38:30 <emph> parcs`: Which one? ErrorT?
02:38:59 <erus`> pure languages are so much easier to implement that stateful
02:39:07 <rostayob> erus`: are they?
02:39:41 <erus`> yes
02:40:09 <rostayob> erus`: I'm not sure I see why, it's not like destructive updates are hard to implement
02:40:32 <erus`> rostayob: i could have a global list of bindings before
02:40:32 <rostayob> on the other hand, implementing sharing a good GC (which are both requirements for pure language) it's tricky
02:40:40 <parcs`> emph: no, i mean @unmtl. it unwraps the newtypes of a monad transformer stack and gives you its raw type
02:41:02 <rostayob> erus`: mh?
02:41:04 <erus`> now i have to manage all my mutable states
02:41:35 <neutrino> hi guys
02:41:46 <neutrino> i have two questions
02:41:50 <erus`> how do i index variable i have just created?
02:41:51 <emph> Ah! Sweet, didn't know that :) Rather new to both Haskell and this channel. Been here a couple of times and always get great help.
02:41:59 <erus`> im gonna go for some kinda stack index
02:41:59 <rostayob> erus`: I'm not sure I see what you mean, but I have to work now, so I better not get myself in this discussion
02:42:08 <neutrino> 1. i'm thinking of writing bindings for a C lib, is there a good tutorial for the FFI? i'm fairly weak with my C but i somehow managed in the past
02:42:20 <rostayob> neutrino: RWH
02:42:37 <neutrino> 2. i am looking to build something that works on ASTs, is there a general approach to doing that (like eg parsec for parsing) or do i need to roll my own?
02:42:52 <rostayob> neutrino: AST are just data types
02:43:06 <Guest32470> hello
02:43:10 <rostayob> unless you're doing something very specific, it's just manipulating ADTs
02:43:16 <elliott> neutrino: Haskell is pretty much designed around that in a way
02:43:31 <Guest32470> how do i change my name from Guest32470 to something else?
02:43:38 <elliott> neutrino: remember, Haskell is in the ML family of language -- ML stands for MetaLanguage because it was invented as a way to give concise, precise semantics to other languages
02:43:43 <elliott> Guest32470: /nick foo
02:43:44 <rostayob> Guest32470: /nick yournick
02:44:02 <elliott> neutrino: so, with algebraic data types, pattern matching, and so on, it's already very well-equipped to the task
02:44:13 <elliott> neutrino: you might be interested in syb-style generics for simplifying tree operations
02:44:16 <neutrino> i realize ASTs are just data types but for example i might want to easily be able to replace all nodes that match something
02:44:25 <elliott> (lets you omit a lot of tedious recursion-scheme stuff)
02:44:29 <elliott> right, syb lets you do that
02:44:30 <rostayob> neutrino: syb
02:44:34 <neutrino> ok i heard of that
02:44:38 <elliott> everywhere replace where replace x | matches x = replaced | otherwise = x
02:44:42 <elliott> etc.
02:47:07 <neutrino> thanks i will look at SYB
02:47:24 <rostayob> neutrino: the best introduction when I wanted to learn it was the SYB paper
02:47:42 <rostayob> but for basic operations it's pretty simple
02:47:54 <neutrino> ok
02:48:04 <elliott> there's also uniplate/multiplate
02:48:10 <elliott> which some people like more
02:48:38 <Philippa> elliott: that's... something of a point of contention, actually. Haskell's not "an ML" the same way that ocaml or sml are, for example.
02:48:53 <elliott> Philippa: oh, certainly
02:48:59 <elliott> Philippa: let's say "related to" rather than "a member of"
02:49:33 <elliott> Philippa: but the similarities for things such as handling structures that fit algebraic data types very well are numerous
02:49:47 <rostayob> well haskell is very much like SML, - the module system, + typeclasses, - strictness, + purity, + more powerful type system :P
02:50:18 <elliott> right, type system power, module system, typeclasses and purity aren't directly relevant to AST-walking
02:50:22 <Philippa> elliott: well yes. They have common ancestors
02:50:23 <elliott> and laziness is a win
02:50:36 <aninhumer> it would perhaps be a bit like saying Java is "a C" :P
02:50:39 <rostayob> elliott: no, in fact I agree with your comment
02:50:56 <rostayob> (regarding the fact that Haskell borrows that kind of power from ML)
02:50:57 <Philippa> the main thing that's descended from ML is using a Hindley-Milner-derived type system
02:50:59 <elliott> rostayob: I wasn't saying you disagreed
02:51:02 <elliott> I was agreeing further
02:51:10 <elliott> saying that the primary differences of Haskell are ones not all that relevant to AST-walking
02:51:10 <rostayob> actually ML borrowed the pattern matching power from that other thing
02:51:25 <elliott> actually in a way Haskell is more MLy than its ancestors
02:51:54 <elliott> like, Miranda + steal some more stuff from ML (like type system) = pretty close to (Report) Haskell
02:51:58 <rostayob> aninhumer: I think Java and C are much further away than Haskell and SML.
02:52:07 <Philippa> er, Miranda was already H-M?
02:52:12 <Philippa> with ugly syntax, but still
02:52:16 <elliott> oh, I'm mixing up Miranda and another language
02:52:27 <elliott> Philippa: I don't agree that that's the main thing descended from ML
02:52:34 <elliott> "ML family" =/= descended from ML, btw
02:52:45 <elliott> in that ML didn't necessarily originate all the characteristics of the MLf amily
02:52:50 <elliott> *ML family
02:52:52 <rostayob> ok I *have* to work. Goodbye :P
02:52:56 <neutrino> what have i done
02:53:05 <neutrino> please don't fight over me
02:53:08 <Philippa> most people use "$foo family" for languages descended from $foo, IME
02:53:11 <elliott> neutrino: no fighting :)
02:53:18 <Philippa> $foo doesn't have to have originated all the concepts, no
02:53:30 <elliott> Philippa: well, you seem to be arguing that you can't say haskell is derived from ML because ML didn't originate the many similar things like hindley-milner, algebraic data types, pattern-matching :)
02:53:36 <neutrino> ok different question
02:54:00 <neutrino> if i have a yacc def for my syntax, can i easily use that in haskell?
02:54:05 <elliott> but ML is definitely a close ancestor of Haskell (at the most one step removed), Haskell has many of its most distinctive features, and I very much doubt the committee weren't influenced by it
02:54:08 <Philippa> no, I'm saying it /isn't/ derived (primarily) from ML and that those things aren't evidence it is
02:54:15 <elliott> neutrino: maybe, if you convert it to happy or so
02:54:25 <elliott> Philippa: well, something does not have to be directly related for it to be in the same family
02:54:29 <neutrino> i heard of happy but i am not sure what it does
02:54:30 <Philippa> with HM as the main exception
02:54:31 <elliott> it's in the same family tree
02:54:34 <elliott> neutrino: it's like yacc for haskell
02:54:34 <neutrino> does happy create a module for me or something?
02:54:45 <Philippa> elliott: yes, but we might call that the "CPL family"
02:54:52 <Philippa> or the "ISWIM family", or...
02:55:06 <neutrino> the syntax is awesomely complex
02:55:07 <elliott> Philippa: yeah, and the C family is the BCPL family...
02:55:12 <Philippa> well, y'know, the "lambda calculus family" except that one's a bad idea because "family" has a more specific context
02:55:14 <neutrino> so i wouldn't want to have to convert it by hand
02:55:20 <elliott> ML was the first prominent language with those characteristics
02:55:26 <neutrino> is there some good way to do that?
02:55:29 <elliott> and by far the most influential, IMO
02:55:40 <elliott> neutrino: well the basic grammar syntax is the same, but it'd still be a lot of work
02:55:41 <Philippa> elliott: I don't consider the C family to be the same thing as the BCPL or the CPL family
02:55:56 <elliott> neutrino: I'd recommend writing a Parsec parser for the grammar or such
02:56:01 <elliott> Philippa: your families are way too rigidly-defined :P
02:56:16 <Philippa> also, I disagree re prominence
02:56:19 <Philippa> it looks that way /now/
02:56:32 <Philippa> but CPL was a big thing for example
02:56:51 <neutrino> i'm totally not writing parsec for mysql syntax
02:56:57 <neutrino> that would drive me mad
02:57:01 <Philippa> not the way that COBOL or FORTRAN were, but a significant step in programming languages
02:57:30 <elliott> well, history is unfair :)
02:57:42 <Philippa> elliott: FWIW, I'd accept "Haskell and ML are related", or even qualifiers such as "wider ML family". But Haskell isn't an ML
02:57:54 <Philippa> *rolls eyes*
02:57:59 <Philippa> you're being actively ignorant here
02:58:29 <Philippa> ask someone who's into HoPL how significant CPL and the work around it was
02:58:43 <Philippa> don't assume that "mainstream programmer" prominence is the only kind that matters
02:58:55 <aninhumer> Oh huh, looking at this CPL thing, it looks quite FP, but C is derived from it?
02:58:58 <Philippa> especially, don't assume that it's the only kind that matters to language designers or computer scientists
02:59:02 <Philippa> aninhumer: yep
02:59:30 <Philippa> three steps down the line - BCPL was the implemented version, B was hacked up from it for low-level programming and C derives directly from B
02:59:45 <aninhumer> brb need to blow all my imperative friends' minds :P
03:00:03 <DarkUnicorn> can someone explain me the "do ..." in the raw sql interface example at http://www.yesodweb.com/blog/2012/02/persistent-0-8 i don't understand how to get the list of entities
03:01:41 <Philippa> elliott: Haskell's syntax deviates from ML's substantially because it's a union of two major non-ML syntactic styles btw. That union happens to more closely resemble what's now common ML style
03:01:49 <elliott> Philippa: I didn't intend that at all
03:02:10 <Philippa> I imagine you didn't, no
03:02:16 <elliott> Philippa: I just meant that the name "ML family" may be unfair
03:02:22 <elliott> but that doesn't mean it's not the most useful name for that family
03:02:54 <quicksilver> I think haskell is a member of the "miranda family"
03:02:55 <Philippa> no. The fact it commonly means languages directly derived from ML strongly suggests it might not be, though
03:02:58 <elliott> but I definitely didn't mean to imply CPL was insignificant, or that mainstream-programmer prominence is relevant at all
03:03:04 <quicksilver> which is quite distinct from the ML family
03:03:18 <Philippa> quicksilver: quite, I namedropped ISWIM for a reason
03:03:22 <elliott> quicksilver: Can we agree that the Miranda family is closely related to the ML family, then?
03:03:28 <quicksilver> elliott: no.
03:03:37 <quicksilver> miranda and its antecendents were quite unlike ML
03:03:53 <quicksilver> although Turner took a few bits of influence from ML when he put miranda together
03:03:55 <Philippa> I can, but for values of 'closely related' that are more mathematical than historical
03:04:04 * elliott identifies languages much more broadly than everyone else, apparently :)
03:04:14 <quicksilver> and haskell sprung, roughly speaking, from miranda's unfortunate license
03:04:14 <Philippa> elliott: yes, I was trying to tell you that!
03:04:27 <quicksilver> if miranda had been freely licensed, haskell might never have happened
03:04:28 <elliott> anyway, my original statement was unfortunate
03:04:35 <elliott> but I think in context what I meant by it was perfectly reasonable
03:04:58 <elliott> i.e. as far as processing ASTs go, Haskell has the same basic strengths as ML, which was designed for the purpose
03:05:40 <Philippa> Sure
03:05:51 <mkscrg> So the RTS option -V0 turns off the RTS clock and changes scheduling. Is there a reason not to run with this in "production" multithreaded apps?
03:06:32 * mkscrg is ignorant of the runtime system
03:09:18 <quicksilver> mkscrg: well I would think it makes things slower (context switching very frequently is not free)
03:09:23 <quicksilver> mkscrg: why would want to ?
03:10:15 <mkscrg> i have some code that makes long FFI calls (a binding to the ZeroMQ lib) that doesn't work with -threaded unless run with -V0
03:10:44 <quicksilver> I would investigate why that is the case
03:10:51 <quicksilver> it sounds strange.
03:10:54 <jonte> Can I inspect what a Writer has written so far?
03:11:18 <emph> @unmtl EitherT q (StateT (Trace r) (WriterT (Trace r)  IO)) a
03:11:18 <lambdabot> EitherT q (StateT (Trace r) (WriterT (Trace r) IO)) a
03:11:35 <mkscrg> quicksilver: yeah i'm working on it. looks like 7.4.1 changed a couple things about annotations and the FFI, so i'm looking into that
03:12:19 <elliott> mkscrg: Are they imported unsafe?
03:13:29 <mkscrg> elliott: not sure what that means. can you elaborate? (this is someone else's FFI binding and I'm an FFI noob)
03:14:13 <elliott> mkscrg: Do the functions have "unsafe" in their "foreign import" lines?
03:14:37 <elliott> If so, whoever wrote the binding is a bad person, and you should remove them from any functions that might be long-running.
03:18:29 <mkscrg> elliott: yes, they're all imported unsafe. they also check for EINTR and retry. is that an acceptable compromise or is "unsafe" still bad?
03:19:05 <elliott> mkscrg: "unsafe" means that if they block, the runtime blocks
03:19:08 <mkscrg> that is, the haskell functions that make the c calls check for EINTR and retry
03:19:08 <elliott> or is it just the OS thread
03:19:12 <elliott> whatever, don't use unsafe on blocking calls
03:19:13 <elliott> you're not meant to
03:19:27 <mkscrg> interesting
03:19:27 <quicksilver> unsafe makes it block a whole "capability"
03:19:39 <mkscrg> quicksilver: i.e. a cpu core, right?
03:19:43 <quicksilver> that is, not only one OS thread, but also haskell won't schedule any more OS threads for execution to replace it
03:19:52 <quicksilver> mkscrg: it's up to you how many capabilities there are
03:19:56 <quicksilver> but normally it's 1 per core, yues.
03:20:10 <quicksilver> it's designed for really quick calls which never block
03:20:25 <quicksilver> for example, if you were importing "sin" from math.h, then unsafe would be fine.
03:20:40 <quicksilver> generally if your call takes more than a microsecond, unsafe is a mistake.
03:21:06 <quicksilver> you can "work around" a library with inappropriate unsafes by upping the number of capabilities, possibly
03:21:12 <quicksilver> depends how your app scales.
03:22:19 <mkscrg> quicksilver: i don't know whether unsafe is causing it, but this library is broken on 7.4.1 when run w/ -threaded (fine w/o -threaded)
03:22:31 <mkscrg> regardless of the # of capabilities set
03:23:03 <elliott> just remove all uses of unsafe
03:23:10 <elliott> if it works, yell at the original author
03:23:47 <quicksilver> :)
03:24:06 <quicksilver> 7.4.1 is an important clue though
03:24:23 <quicksilver> I don't know how this stuff changed in 7.4 but I'm not aware of any basic changes to the scheduling or what unsafe means
03:24:35 <quicksilver> so if its' a really inappropriate use of unsafe, it should have been broken in 7.2 as well.
03:24:42 <quicksilver> JaffaCake1 will know for sure.
03:26:55 <JaffaCake1> mkscrg: what goes wrong?
03:28:18 <elliott> JaffaCake: (to provide additional info out of backlog, mkscrg says it works with -V0)
03:29:09 * elliott 's wild guess is that 7.4 compiles the program slightly differently in a way that makes the misuse of unsafe clog things up
03:30:16 <mkscrg> JaffaCake: the error from the C lib suggests that the "socket" is being accessed concurrently, which is a no-no
03:30:30 <mkscrg> with zeromq, you have contexts (which are thread safe) and sockets (which are not)
03:30:46 <mkscrg> but that error could easily be a red herring
03:31:21 <JaffaCake> if you had an unsafe where there shouldn't be one, the worst that could happen is that you block other threads for too long, i.e. too little concurrency, not too much
03:31:38 <elliott> mkscrg: haskell threads can map to arbitrary OS threads
03:31:39 <JaffaCake> (unless you call back into Haskell, in which case you'll get an error)
03:31:46 <elliott> so perhaps the library is just not ensuring non-concurrent access?
03:31:49 <elliott> say with a bound thread or global lock
03:32:46 <RichyB> If you link in a C library that isn't threadsafe with pthreads then it's going to be unsafe with Haskell's threads too.
03:33:20 <mkscrg> elliott: locks (via MVars or the like) are often used to make sockets threadsafe in practice, but my test code is single-threaded
03:33:34 <RichyB> Compiling with the non-threaded runtime sort of sidesteps the problem by switching from preemptive multitasking with OS threads to cooperative multitasking.
03:33:51 <elliott> mkscrg: well you have no guarantee that a library is not using forkIO under the hood
03:34:04 <elliott> so I am not sure I believe that your test code is single-threaded :)
03:35:01 <neutrino> hello
03:35:15 <mkscrg> i think it is, unless mapM_ is secretly running on multiple threads. it's very simple test code: https://gist.github.com/1829190
03:35:16 <neutrino> is the happy syntax very different from yacc or is it a mostly mechanical conversion?
03:35:38 <elliott> neutrino: well the basic structure is similar but you'll have to translate all the C code inside...
03:35:41 <JaffaCake> mkscrg: the FFI calls might run in different threads, even if they don't run concurrently
03:35:45 <neutrino> 14661 sql/sql_yacc.yy
03:35:49 <neutrino> this is in lines
03:35:55 <JaffaCake> perhaps the C lib relies on being called from the same OS thread?
03:36:15 <mkscrg> JaffaCake: quite possible. is that something that might have changed w/ 7.4.1?
03:36:30 <elliott> (does that happen even if -N isn't specified?)
03:36:34 <elliott> (if -threaded is on)
03:36:44 <elliott> neutrino: there's not going to be an easy fix :P
03:37:02 <JaffaCake> not deliberately, but scheduling is non-deterministic
03:37:41 <JaffaCake> try running all your code inside runInBoundThread
03:37:49 <JaffaCake> or in the main thread
03:38:03 <elliott> JaffaCake: right, but if only one OS thread is used then how could the FFI calls run in different threads?
03:38:19 <JaffaCake> the RTS uses multiple OS threads
03:38:49 <elliott> ah, ok, so -N doesn't directly map to the count of OS threads
03:38:54 <JaffaCake> right
03:39:06 <JaffaCake> "it's more complicated than that" :)
03:40:17 <quicksilver> JaffaCake: his test code is superficially all in the main thread ( https://gist.github.com/1829190 ) but I don't know what System.ZMQ3 might be doing behind his back
03:41:52 <mkscrg> runInBoundThread didn't make any difference, nor did -N1
03:42:55 <JaffaCake> it's probably something else then
03:45:13 <mkscrg> i looked a little more into the "unsafe" thing, and it actually looks ok. most of the C calls are fast, and the slow ones (socket reads/writes) are done with a "DONTWAIT" flag
03:45:29 <mkscrg> also removing "unsafe" from all the FFI imports made no difference
03:47:49 <JaffaCake> perhaps something is closing your socket too early?
03:49:27 <mkscrg> yeah that's what that error suggests. i think i need to get in deeper and play with these C calls to see where it's actually croaking
03:50:01 <mkscrg> also it's time for real work :P thanks for all the help everyone. if anyone thinks of anything there's a thread on cafe about this
04:06:36 <savask> Hello. I'm writing a program which does brute-force algorithm. To collect all variants I use sequence function like this: "vars n = sequence . replicate n $ listofvalues" But it seems that lazy foldr in it makes my prog. use more and more memory. Is there a strict version of sequence? Or maybe I can somehow write my own strict version?
04:10:13 * hackagebot ddc-base 0.2.0.1 - Disciple Core language common utilities.  http://hackage.haskell.org/package/ddc-base-0.2.0.1 (BenLippmeier)
04:10:15 * hackagebot ddc-core 0.2.0.1 - Disciple Core language and type checker.  http://hackage.haskell.org/package/ddc-core-0.2.0.1 (BenLippmeier)
04:10:16 * hackagebot ddc-core-eval 0.2.0.1 - Disciple Core language semantic evaluator.  http://hackage.haskell.org/package/ddc-core-eval-0.2.0.1 (BenLippmeier)
04:10:19 * hackagebot ddc-core-simpl 0.2.0.1 - Disciple Core language simplifying code transformations.  http://hackage.haskell.org/package/ddc-core-simpl-0.2.0.1 (BenLippmeier)
04:10:29 <neutrino> savask, maybe you can use "seq".
04:11:35 <savask> neutrino: Where? I suppose that memory is being wasted inside sequence.
04:12:23 <int-e> savask: is changing the order ok? foldl (liftM2 (flip (:))) [[]] . replicate n $ list  should not suffer from this problem.
04:13:39 <int-e> savask: the problem is that all the tails are shared, so when picking lists of length 10 over "ab", you generate all lists of length 9, then prepend 'a' to all of them, and then later prepend 'b' to all of them; in the meantime, all the generated lists of length 9 are kept in memory.
04:15:15 <savask> int-e: Ah. And I thought that it's because of foldl.
04:15:20 * hackagebot ddci-core 0.2.0.1 - Disciple Core language interactive interpreter.  http://hackage.haskell.org/package/ddci-core-0.2.0.1 (BenLippmeier)
04:15:22 * hackagebot ddci-core 0.2.0.2 - Disciple Core language interactive interpreter.  http://hackage.haskell.org/package/ddci-core-0.2.0.2 (BenLippmeier)
04:15:24 * hackagebot ddc-core 0.2.0.2 - Disciple Core language and type checker.  http://hackage.haskell.org/package/ddc-core-0.2.0.2 (BenLippmeier)
04:15:26 <savask> *foldr
04:15:39 <randomclown> is there an efficent way to have a mutable 2d array in haskell
04:15:40 <int-e> (which is a pity --  replicateM n "sequence"  would be adorable otherwise)
04:15:57 <randomclown> I'm plotting points on a graph
04:17:59 <savask> int-e: It seems that your function doesn't waste memory - thanks!
04:20:05 <RichyB> randomclown, sure. You just need an Ix index for (Int, Int).
04:20:47 <randomclown> I'd hate for the whole thing to be copied everytime I change something
04:20:59 <RichyB> Oh right.
04:21:34 <RichyB> randomclown, mutable arrays are implemented in the IO monad by Data.Array.IO
04:21:57 <randomclown> Ah right ty
04:22:17 <RichyB> randomclown, if you're doing a pure computation but you happen to want a mutable array just for efficiency's sake then you should use the ST monad (in Control.Monad.ST) and Data.Array.ST
04:23:33 <RichyB> randomclown, BTW, about the 2d thing, you can expect an array indexed by (Int,Int) pairs to have pretty much identical performance to an array indexed by a single Int where you multiply the x and y coordinates yourself.
04:23:46 <RichyB> and AIUI there's an Ix instance for (Int, Int) already defined.
04:23:59 <quicksilver> there is.
04:24:58 <randomclown> Thanks richyb
04:25:21 <elliott> randomclown: Consider a functional tree structure.
04:25:31 <elliott> Mutable arrays should only be used in very specialised scenarios.
04:25:42 <randomclown> I have a set of vertices
04:25:43 <elliott> With tree structures, you don't have to copy on every update, thanks to sharing.
04:25:49 <randomclown> each have a light value setting
04:26:00 <elliott> Use a HashMap (Int,Int) or such.
04:26:12 <elliott> (Actually, IntMap (IntMap a) would be much better.)
04:26:18 <randomclown> and I'm plotting a ascii art ish string out of them
04:26:52 <elliott> randomclown: Your needs don't sound special enough to warrant the inconvenience of a mutable array.
04:27:06 <elliott> Unless you need *very* high performance (don't underestimate GHC + CPUs).
04:27:11 <randomclown> I'll just use the normal array if it's too shit I'll come back
04:31:28 <RichyB> elliott, I have that vague guilty feeling that normally comes after having given someone what they wanted instead of what they needed.
04:31:40 <RichyB> Oh well, life goes on.
04:32:20 <elliott> RichyB: Meh, don't worry about it.
04:32:28 <elliott> RichyB: I think by "normal array" randomclown meant "immutable array".
04:32:41 <elliott> In which case, they'll discover that the standard array interface is awful in about 5 minutes and switch to IntMap ;)
04:32:45 <RichyB> Oh yeah.
04:32:54 <RichyB> We'll see them again in, what, five hours time?
04:33:43 <RichyB> Three hours to write their program followed by two hours of sitting around waiting for it to run before they decide that their data flow makes copying immutable arrays too expensive. ;)
04:34:19 <elliott> then #haskell will rewrite their program in 5 minutes
04:35:00 <int-e> using plain lists ;)
04:35:37 <int-e> (it happens often enough that the required access is actually nicely sequential)
04:36:09 <Jedai> The array aren't that bad... and once you've introduced Foldable and Traversable the interface isn't completely terrible, still there are gloaring deficiencies from time to time...
04:36:25 <Jedai> *glaring
04:36:38 <RichyB> int-e, then we trick Don Stewart into thinking that it's a shootout problem and he rewrites it using unboxed vectors to take advantage of the linear access order. :)
04:38:47 <zachk> RichyB, elliott. int-e, isn't that the entire beauty of referential transparency and functional programming?
04:39:30 <elliott> What is?
04:39:38 <elliott> IRC channels that optimise your programs for you?
04:42:15 * zachk frowns 
04:42:31 <elliott> Sincere question.
04:42:33 <elliott> Well, the first one was.
04:44:03 <zachk> well it wasn't 100% sincere, more of a parable, but try rewriting someone's program in 5 minutes from another language, and have it run faster
04:49:40 <erus`> when are uninitialized variables useful?
04:51:03 <copumpkin> erus`: never?
04:51:24 <copumpkin> erus`: since variables for us are just names, and being "uninitialized" probably means its value is bottom? :)
04:51:28 <copumpkin> you can't set them
04:51:37 <erus`> i mean in java/C++
04:51:55 <ski> uninstantiated variables can be useful for modularity
04:53:11 * ski would like to see a static initialization system for an imperative language, comparable to the mode/instantiation system of Mercury
04:54:28 <elliott> @hoogle x f g -> g a -> x f g
04:54:29 <lambdabot> Network.Browser withBrowserState :: BrowserState t -> BrowserAction t a -> BrowserAction t a
04:54:29 <lambdabot> Data.Graph.Inductive.Graph delNodes :: Graph gr => [Node] -> gr a b -> gr a b
04:54:29 <lambdabot> Data.Graph.Inductive.Graph delNode :: Graph gr => Node -> gr a b -> gr a b
04:54:40 <osfameron> ski: would that be a bit like IoC dependency management?
04:54:53 <ski> osfameron : no idea what that is
04:56:12 <osfameron> ski: it's roughly speaking, lazy instantiation of fields with multiple dependencies.
04:57:11 <ski> what does the "with multiple dependencies" part mean ?
04:58:28 <osfameron> ski: sorry, I'm not explaining very well.  The code examples/docs at https://metacpan.org/module/Bread::Board might make more sense than me?  (Though they're in Perl, it's fairly white-noise-less Perl)
04:59:23 <osfameron> I suspect I'm entirely wrong though, and that isn't what you mean about the Mercury mode/instantiation at all
05:02:03 <ski> well, i was looking a little bit in a C# book
05:02:40 <ski> and they explained at one point how one could pass an uninitialized struct by reference to a function, and have it initialize it
05:04:23 <ski> an static initialization system would allow this and more : it would allow one to express that one initialization function initialized some parts of the struct and another initialized other parts, and the system would keep a fine-grained track of exactly which parts of structures was initialized at each point in the program
05:05:21 <ski> in Mercury you can express e.g. that a predicate constructs a binary tree of a certain shape where all the elements are uninstantiated
05:05:42 <ski> then another predicate could fill in elements (i.e. instantiate the elements) of the tree
05:06:07 <ski> in that way you could decouple the code that decides how the tree will look like from the code that fills in elements
05:06:30 <ski> this is just a silly example, but i hope it hints at the decoupling possibilities
05:06:46 <osfameron> ah
05:07:13 <ski> the nice thing in Mercury is that all this has a clear declarative semantics :)
05:07:25 <zachk> :-D
05:07:45 <quintessence> it seems like row polymorphism gets you something like that for structs
05:08:08 <quintessence> initializing a part adds some fields, and if you don't initialize them all your record isn't the right type
05:08:11 <ski> however, i think it could be valuable in more vanilla imperative programming to have the system keep track of the exact instantiation state of the mutable data one manipulates
05:08:38 <ski> quintessence : that's not the same thing, though
05:08:59 <elliott> ski: it's because logical variables can basically model write-once mutable references, right?
05:09:02 <elliott> which also let you do cycles, etc.
05:09:03 <ski> the "inst" of a variable (or more generally, term/expression) in Mercury is different from its type
05:09:16 <ski> elliott : yes
05:09:42 <ski> (though you can only get cycles if you skip the occurs-check that is supposed to be present for inductive types)
05:11:08 <ski> (well, iirc Mercury disallows such cycle-creation (for non-mutable stuff), because it's convervate about aliasing, and doesn't allow non-trivial such)
05:12:02 <ski> one can also use an "inst" to describe effectively a subtype of a type, so that you can declare that a function always returns a non-empty list, or a list with an even number of elements, &c.
05:14:42 <nand`> What's the difference between mapM_ and forM_? Just reversed parameters?
05:14:52 <Botje> yup
05:16:46 <ski> @src forM_
05:16:47 <lambdabot> forM_ = flip mapM_
05:17:46 <ion> and mapM_ = flip forM_
05:18:12 <ski> osfameron : hm, i can't say i grok the idea of `Bread::Board' exactly yet, but it appears similar to wiring components together in a relational way
05:18:20 <ski> @pl flip . flip
05:18:20 <lambdabot> id
05:19:27 <elliott> <ski> (though you can only get cycles if you skip the occurs-check that is supposed to be present for inductive types)
05:19:31 <elliott> ski: yeah, I was thinking from a prolog POV
05:19:36 <elliott> (so, an unsound POV :P)
05:21:05 <ski> elliott : well, co-LP allows constructing cyclic data
05:21:39 <osfameron> ski: yeah, with relationships, but also with laziness.  e.g. you don't have to worry about needing to create the Database and Logfile *first* before creating an Application.  Much like haskell variable declarations in that sense.
05:21:56 <ski> "In programming, the co-logic paradigm (Co-LP for brevity) "is a natural generalization of logic programming and coinductive logic programming, which in turn generalizes other extensions of logic programming, such as infinite trees, lazy predicates, and concurrent communicating predicates. Co-LP has applications to rational trees, verifying infinitary properties, lazy evaluation, concurrent LP, model checking, bisimilarity proofs, etc."
05:21:57 <drdo> Is there some library with concurrency utilities? Particularly spawning a thread and having all exceptions in that thread be thrown in the current thread instead
05:22:32 <ski> osfameron : i was thinking of module loading
05:23:01 <erus`> @hoogle [(a, b)] -> [b] -> [b]
05:23:01 <lambdabot> Data.Graph.Inductive.Query.BFS bfsn :: Graph gr => [Node] -> gr a b -> [Node]
05:23:01 <lambdabot> Data.Graph.Inductive.Query.DFS dfs :: Graph gr => [Node] -> gr a b -> [Node]
05:23:01 <lambdabot> Data.Graph.Inductive.Query.DFS rdfs :: Graph gr => [Node] -> gr a b -> [Node]
05:23:18 <ski> i.e. not having to manually load modules in some topological sorting of the dependency partial order, instead relying on the system to work out the correct order
05:23:33 <erus`> whats the function to replace elements in a list?
05:23:45 <ski> replace how ?
05:23:48 <quicksilver> there isn't one erus`
05:24:34 <quicksilver> although I proposed a generalised replace operation a few years ago - http://www.haskell.org/pipermail/haskell-cafe/2007-July/028032.html
05:24:35 <erus`> @hoogle splitAt
05:24:35 <lambdabot> Prelude splitAt :: Int -> [a] -> ([a], [a])
05:24:35 <lambdabot> Data.List splitAt :: Int -> [a] -> ([a], [a])
05:24:35 <lambdabot> Data.ByteString splitAt :: Int -> ByteString -> (ByteString, ByteString)
05:24:53 <ski> replace at an index ?
05:24:58 <erus`> yep
05:25:26 <rwbarton> > let f x = case undefined of Nothing -> (# x+1 #) in case f 3 of (# _ #) -> "test"
05:25:27 <lambdabot>   "*Exception: Prelude.undefined
05:25:29 <osfameron> is the lack deliberate, to make you consider arrays/finger-trees etc. instead?
05:25:39 <ski>   (!!<-) :: Integral i => [a] -> i -> (a -> a) -> [a]  -- have used this a couple of times
05:26:04 <erus`> is that a prelude func?
05:26:09 <ski> no
05:26:27 <erus`> i guess i should be using an array or vector or something
05:26:42 <ion> > id "foo"
05:26:43 <lambdabot>   "foo"
05:26:45 <ski> maybe see if you can rethink your algorithm
05:26:53 <ion> Interesting, Haskell (or at least GHC) understand nbsp as a space.
05:27:14 <ski> > id "id"
05:27:15 <lambdabot>   "id\65533"
05:27:22 <RichyB> ion, GHC parses your source code as unicode and then uses the standard unicode character predicates.
05:27:47 <ion> > id　"foo"
05:27:48 <lambdabot>   "foo"
05:27:51 <quicksilver> osfameron: the lack of "string update at a particular index" - yes, probably.
05:28:05 <quicksilver> osfameron: the lack of som ekind of generalised replacement operator - no, it's just missing, IMO.
05:28:34 <quicksilver> "replace foo with bar" can work naturally (lazily) down the list and is fine
05:29:04 <elliott> Is it really true that you can have e.g.
05:29:06 <osfameron> ah, as a map over all elements you mean?
05:29:20 <elliott> class Foo (~>) one | (~>) -> one where test :: one ~> one
05:29:25 <elliott> with (~>) inferred as k -> k -> *
05:29:26 <elliott> but not
05:29:35 <quicksilver> so that replace "foo" "bar" "I like to drink foo in the foo bar" becomes "I like to drink bar in the bar bar".
05:29:36 <elliott> class Foo (~>) where type One (~>); test :: One (~>) ~> One (~>)
05:29:42 <elliott> because the kind gets forced to *?
05:29:46 <elliott> with PolyKinds
05:29:50 <elliott> if so, that sucks :(
05:29:55 <elliott> means you have to use huge ugly fundep bundles everywhere
05:30:33 <quicksilver> well, polykinds has only just been implemented it's not that surprising if it's a bit lacking in places?
05:30:47 <quintessence> Can you not write the kind signatures yet?
05:30:48 <elliott> still :(
05:30:51 <elliott> quintessence: yeah
05:31:11 <quintessence> awkward.
05:31:29 <osfameron> quicksilver: OIC.  Like regexps (but over any type of list)?
05:34:22 <quicksilver> osfameron: well the email I linked allowed you to use arbitrary functions for the recognition and replacement.
05:34:43 <quicksilver> osfameron: but, yes, that's a reasonable intuition. Perl regexps can include arbitrary functions after all.
05:34:49 <quicksilver> (but only insane people use that feature)
05:35:18 * hackagebot crypto-pubkey-types 0.1.1 - Generic cryptography Public keys algorithm types  http://hackage.haskell.org/package/crypto-pubkey-types-0.1.1 (VincentHanquez)
05:35:25 <osfameron> quicksilver: heh
05:35:39 * ski . o O ( irregexen )
05:36:28 <quicksilver> quite
05:38:16 <ski> "IrRegular Expressions" by foof (Alex Shinn) at <http://synthcode.com/scheme/irregex/>
05:39:48 <mauke> why do they even bother with posix syntax
05:42:40 <elliott> ski: that link doesn't load
05:42:42 <mauke> yay, it's breaking sanity rule #1
05:42:48 <mauke> I already hate irregex
05:44:45 <chrisdone> http://hpaste.org/63730 — who can reproduce?
05:44:46 <preflex>  chrisdone: you have 1 new message. '/msg preflex messages' to read it.
05:44:46 <lambdabot> chrisdone: You have 1 new message. '/msg lambdabot @messages' to read it.
05:44:53 <chrisdone> @_@
05:45:17 <RichyB> You'd better pick up your messages, dude.
05:45:24 <chrisdone> dcoutts__: you about?
05:45:25 <ski> elliott : loads for me
05:45:53 <mauke> preflex: version
05:45:57 <mauke> oh, great
05:46:02 <ski> (for some reason it took maybe 10 seconds or something, though)
05:46:15 <chrisdone> preflex: did preflex just break?
05:46:22 <ski> mauke : "sanity rule #1" ?
05:46:39 <mauke> chrisdone: disconnected, currently waiting to reconnect
05:46:47 <chrisdone> ah ok
05:47:29 <mauke> ski: the problem is this: which characters have special meaning in a regex and which characters match themselves? and how do you get special characters to match themselves?
05:47:55 <RichyB> If you do know the regex flavour, backticks.
05:48:00 <RichyB> If you don't, single-element character classes.
05:48:01 <chrisdone> can anyone reproduce the uconv bug? it's very surprising to me. the code looks sound, but something's broken
05:48:05 <ski> mauke : you are not talking about SRE here, yes ?
05:48:13 <mauke> ski: right
05:48:57 * ski wouldn't consider to use anything else than the SRE syntax
05:49:29 <RichyB> BREs are make of fail and hate.
05:49:30 <mux> RichyB: so if I want to match ^ and I don't know the RE flavour, I should use [^] you say? ;-)
05:49:57 <RichyB> mux, you can't deny that it would work.
05:50:06 <mux> [^] wouldn't work
05:50:14 <mauke> preflex: version
05:50:15 <preflex>  7.996
05:50:40 <quicksilver> [^] is an unmatched ]
05:50:58 * mux nods
05:51:23 <erus`> has anyone written a C interpreter in haskell?
05:51:48 <quicksilver> mauke: isn't it only perl REs that pass that test?
05:51:54 <quicksilver> I agree with you though.
05:51:56 <RichyB> mux, oops, you're right. There are a couple of RE parsers that allow it but they're insane.
05:51:58 <elliott> http://hpaste.org/63731 I really hope "hs2bf" means "Haskell to brainfuck".
05:52:11 <mauke> perl's solution to the problem above: every alphanumeric character matches itself. every non-alphanumeric character may have a special meaning. putting a backslash before a non-alphanumeric character makes it match literally.
05:52:11 <chrisdone> isn't geordie a c++ interpreter in haskell?
05:52:22 <mux> RichyB: yeah, you cannot really support [^] if you want to support [^]] to mean anything but a ] character
05:52:33 <mauke> (and backslashing an alphanumeric character may give it a special meaning, but that's not important here)
05:52:34 <luite> chrisdone: no, it doesn't interpret c++
05:52:53 <mauke> \< and \> violate this principle
05:53:00 <quicksilver> it runs c++ by compiling it with G++
05:53:02 <luite> chrisdone: it runs the compiler and the program with ptrace to make some kind of jail
05:53:03 <chrisdone> luite: just analysis?
05:53:04 <RichyB> mux, yes.
05:53:09 <chrisdone> luite: oh, hah
05:53:15 <quicksilver> which is only an interpreter on a loose observational sense
05:53:39 <quicksilver> however, up to an appropriate observational equivalence, yes, geordie is a c++ interpreter :)
05:53:49 <ski> (if backslashing some alphanumeric characters have special meaning, then backslashing the others shouldn't be allowed)
05:53:58 <elliott> mauke: /me would prefer to quote self-matching things
05:54:27 <elliott> /^{three digits follow: }d3{ and here's an arbitrary amount of whitespace:}s+$/
05:54:45 <mauke> ski: I agree. perl currently only warns for those
05:56:52 <mauke> why doesn't SRE have '+?' and '>=?'?
05:58:01 <luite> chrisdone: I have read somewhere that someone wanted to use a C++ parser with haskell, or write one, so maybe someone is actually building an interpreter :)
05:58:14 <elliott> http://hackage.haskell.org/package/hs2bf oh my god, it is
05:58:24 <mauke> you can't parse C++ without implementing half of it anyway
05:58:41 <hpaste> nand` pasted “Type restraints on multiple fields” at http://hpaste.org/63733
05:58:52 <nand`> Can somebody take a look at my paste and tell me how to do what it is I want to do?
05:59:10 <nand`> Basically, I want the “a” type variable to scope over to all fields, but it should have a Widget a constraint
05:59:12 <ski> nand` : do you want to do an existential type ?
05:59:13 <chrisdone> amg
05:59:13 <koeien2> nand`: your a does not occur on the lhs
05:59:33 <ski> nand` : .. or a parameterized one ?
05:59:39 <chrisdone> so uconv is returning different things each time i call it with the same arguments
05:59:45 <chrisdone> i hate it. hate it. hate it.
05:59:47 <koeien2> ski: an existential type is kind-of useless with a -> [Command]
06:00:12 <koeien2> so the question becomes: what would you like to accomplish? :)
06:00:20 <ski> koeien2 : i don't see what you mean
06:00:36 <koeien2> isn't data X = forall a. X (a -> [Command])
06:00:40 <koeien2> just [Command]
06:00:45 <ski> koeien2 : depending on `Widget', making an existential out of `Tab' might be pretty useless, though
06:00:48 <koeien2> (almost)
06:01:09 <ski> koeien2 : yes, but `Widget a' might contain `a' in covariant position
06:01:15 <koeien2> yeah it could be useful.
06:01:18 <osa1> can I create data constructor for a type synonym?
06:01:23 <nand`> What I want to accomplish: Package a widget of type a together with a set of functions that can operate on it
06:01:28 <koeien2> osa1: no. do you mean "newtype" ?
06:01:32 <ski> osa1 : no, then it wouldn't be a type *synonym*
06:01:44 <osa1> koeien2: no, "type"
06:01:49 <elliott> nand`: beeeeep
06:01:55 <elliott> nand`: existential typeclass antipattern detected!
06:01:59 <Axman6> that's not a type synonym then
06:02:04 <koeien2> osa1: no, that's not possible. type introduces a synonym
06:02:09 * elliott raises the alarm
06:02:09 <osa1> ok, thanks
06:02:12 <Axman6> uh, yes it is >_<
06:02:13 <koeien2> if you want a constructor, you'll need data or newtype
06:02:13 * elliott delivers nand` an emergency http://lukepalmer.wordpress.com/2010/01/24/haskell-antipattern-existential-typeclass/
06:02:15 * Axman6 should sleep
06:02:17 <ski> nand` : you can make an existential for that, yes -- but we'd like to see how `Widget' is defined
06:02:22 <ski> also, what elliott linked to
06:03:46 <ski> (osa1 : also, `Widget a => a' really would be `Widget a *> a' then -- but you have to write it with different syntax)
06:04:03 <silver> I have rather vague question: is there any ideas in the field of functional approach to GUI programming? may be some kind of combinator libraries sketches or papers on the possible ways to do that cool way?
06:04:35 <koeien2> you mean FRP?
06:04:55 <koeien2> i don't know how it works, or really anything about it, just that some people think it's cool :)
06:04:57 <nand`> ah, it type checks the way I want it to if I just add forall a. before the Tab {. I just forgot the syntax for it
06:05:00 <koeien2> FRP = functional reactive programming
06:05:27 <ski> er, s/osa1/nand`/
06:05:36 <silver> oh nice thanks, I'll read about it
06:05:58 <ski> silver : there's also the (old) Fudgets, which is interesting
06:05:59 <nand`> ski: Why is this? What's *>?
06:06:06 <ski> i don't think it's maintained atm, though
06:06:23 <nand`> Oh, and for the definition of Widget, see https://github.com/sol/vimus/blob/master/src/Widget.hs
06:06:48 <silver> ski, thanks
06:06:56 <ski> nand` : saying `widget :: Widget a => a' means that `widget' is supposed to contain a value of type `a', provided the *user* supplies the `Widget a' instance
06:07:18 <elliott> nand`: data Widget = Widget { render :: Window -> IO () }
06:07:22 <ski> nand` : `widget :: Widget a *> a' would mean that `widget' contains two things : a value of type `a', and an instance for `Widget a'
06:07:23 <nand`> ski: That's correct. Tab should only be usable on types which have a Widget instance
06:07:27 <elliott> nand`: then just include Widget in your record
06:07:28 <elliott> this is equivalent
06:07:36 <elliott> (no, not just close; equivalent)
06:07:39 <ski> nand` : it's conceptually two different things (which was the point i wanted to emphasize)
06:07:52 <elliott> this is the textbook existential typeclass antipattern
06:08:25 <nand`> elliott: I'll do that then
06:08:50 <elliott> basically, the only thing you can do with an a that has (Widget a)
06:08:53 <elliott> if you don't know what a is
06:08:54 <elliott> is to render it
06:09:08 <elliott> so, if you don't know what the type is, a Widget instance is equivalent to its render function
06:09:17 <frerich> elliott: Coolness, I had the "Most of the time you think a type class is a good solution - it's not." mantra in my mind for a few months. Now I learn that it's actually an antipattern with a much nicer name :)
06:09:19 <ski>   data Widget = Widget { render :: forall m. MonadIO m => Window -> m () }  -- rather
06:09:22 <elliott> if you /do/ know what the type is, then it's better to have a concrete structure with all the functions specific to that structure on it, and a function from that structure to Widget
06:09:35 <elliott> ski: no, that's also equivalent
06:09:47 <elliott> ski: per monad laws
06:09:51 * ski forgets exactly what's in `MonadIO'
06:09:56 <elliott> just liftIO
06:10:01 <elliott> so you can just liftIO the result of render
06:10:08 <ski> ah, ok. i agree
06:10:52 <elliott> well, hmm, liftIO has no laws
06:10:56 <elliott> so for pathological m it could differ
06:11:16 <koeien2> afaik darcs has the correct approach here
06:11:33 <koeien2> with DarcsCommand
06:11:42 <ski> well, `liftIO . return = return' and `liftIO . join = join . liftM liftIO . liftIO' seems like obvious law candidates
06:11:52 <elliott> koeien2: darcs doing something idiomatically? first time for everything
06:11:58 <ski> (i.e. : expressing that `liftIO' is a monad morphism)
06:12:07 <koeien2> haha
06:12:20 <koeien2> it's probably not the prettiest codebase, but i haven't looked in a long time
06:12:21 <elliott> ski: right
06:12:40 <elliott> ski: a pathological instance I've seen lifts IO exceptions into the native exception handling of m
06:13:30 <ski> would that fail any of those two laws ?
06:13:51 <hpaste> ninestraycats pasted “thunks” at http://hpaste.org/63734
06:13:52 <ninestraycats> hey all i asked this question last night but would like some fresh eyes on it if possible. i got a heap profile suggestive of needless thunk allocation (http://i.imgur.com/O0mYc.png)  i'm reading from disk, making  a map, then forcing its full eval. i should be seeing a flat heap. i've hacked at the code for very long, and am not sure what is causing this. (cf. hpaste log)
06:13:59 <elliott> ski: not the first one... maybe the latter
06:14:22 <koeien2> ninestraycats: i don't see a big problem tbh.
06:15:10 <ninestraycats> as ppl here last night might remember, i may be too paranoid re this heap shape
06:15:42 <elliott> don't worry, be happy :)
06:16:29 <erus`> whats the opverloaded strings pragma plox?
06:16:56 * ski . o O ( Happy Happy Joy Joy )
06:17:00 <ninestraycats> hah ok. the map size is even consistent with the link you posted last night, given its size. thanks.
06:17:05 <koeien2> erus`: it converts Strings to something polymorphic
06:17:08 <koeien2> erus`: like numbers
06:17:17 <koeien2> erus`: it uses the IsString type class
06:17:28 <erus`> no i mean whats the comment i put at the top of my file?
06:17:29 <koeien2> erus`: it's convenient if you use Data.Text
06:17:37 <koeien2> oh {-# LANGUAGE OverloadedStrings #-}
06:17:39 <elliott> erus`: {-# LANGUAGE Guess #-}
06:18:23 <erus`> "Guess language extension is not available"
06:18:37 * ski grins
06:18:42 <erus`> ;)
06:19:30 <mux> {-# LANGUAGE DWIM #-}
06:21:31 <erus`> whats the Lanuage.C.Position.Position for first character?
06:21:34 <erus`> this is confuse
06:22:17 <Nibble> ^&p
06:22:24 <Nibble> sry
06:32:59 <ninestraycats> hm, what does a backslash represent in a time profile? (i am using -auto-all for my cost centres). e.g, e_step.\  and e_step.\.\ where e_step is a function
06:34:09 <ninestraycats> (no doc on this on real world haskell or haskell.org)
06:34:26 <cmccann> it represents subexpressions in some fashion
06:34:38 <cmccann> you'll occasionally see names after the backslash for e.g. stuff in the where clause
06:35:05 <cmccann> but I'm not sure exactly what it means otherwise
06:35:59 <ninestraycats> i figured it's a subexpr, but which? i've got 6 subexprs in a let in e_step, yet my .prof explicitly names only three, the rest are slashes
06:36:10 <ninestraycats> i'll try manually adding cost centres, maybe that'll solve this
06:36:31 <cmccann> all I know is that you used to get less information so I haven't worried about it too much
06:37:13 <cmccann> but yeah can't seem to find anything in the GHC user guide about what that means, sorry
06:37:16 <ninestraycats> well, i'm entering e_step.\.\ 1 million times so i'd like to pinpoint what exactly my program thinks it should compute 1 million times ;)
06:38:03 <ninestraycats> ok, thanks for the help. i'll let you know if manual cost centres makes them go away
06:38:10 <elliott> hi cmccann
06:38:21 <cmccann> sup
06:38:31 <elliott> I've looked into the PackageDescription stuff some more
06:38:37 <cmccann> did you fix hackage [y/n]
06:38:49 <elliott> I conclude that replacing it will be possible, just require a bunch of manual fixups
06:39:03 <cmccann> ok
06:39:04 <nand`> Interesting GHC error message: “My brain just exploded”
06:39:23 <elliott> cmccann: but I really don't want to add another module containing them to this maze of twisty passages, so I'd rather some package separation happened before going into that nonsense
06:39:29 <cmccann> nand`, yes, that's always a popular one
06:39:58 <elliott> nand`: This is what happens when you use existentials!
06:40:43 <elliott> cmccann: on the other hand, I think it could be a /big/ space win
06:40:59 <elliott> like, PackageDescription has something like 25 fields
06:41:17 <elliott> even just unboxing all the fields would save like 256 bytes per package
06:41:37 <cmccann> well
06:41:50 <cmccann> how much of that is actually needed often, anyway?
06:41:53 <nand`> hmm
06:42:12 <elliott> cmccann: does it matter? if keeping the entirety of hackage in RAM requires 2 gigs of ram rather than 10, that sounds OK to me
06:42:27 <elliott> oh, and the whole GenericPackageDescription/CondTree mess would benefit massively too
06:42:32 <cmccann> well, I'm wondering if it would make sense to separate the parts that really do care about building packages and whatnot
06:42:47 <cmccann> and then excise the dependency on Cabal from the rest entirely
06:42:47 <elliott> add in String -> Text, and I think you could easily shave off the vast majority of those gigabytes
06:42:57 <elliott> cmccann: huh? build things are already separate with this hackage
06:42:57 <cmccann> and only use what's needed in a more compact form
06:43:02 <elliott> that's what dcoutts said, at least
06:43:10 <elliott> this thing doesn't do any building or doc generation or whatever
06:43:13 <cmccann> right
06:43:29 <elliott> cmccann: having the web frontend parse cabal files seems fine to me though
06:43:36 <elliott> since it has to handle uploads
06:43:54 <ski> nand` : using `let' to unpack the existential ?
06:44:08 <ski> (or `where')
06:44:24 <hpaste> nand` annotated “Type restraints on multiple fields” with “Type restraints on multiple fields (annotation)” at http://hpaste.org/63733#a63736
06:44:28 <cmccann> elliott, I was actually considering separating the whole upload/download of actual package files from the web front end
06:44:28 <nand`> ski: I tried, I'm using case now
06:44:35 <nand`> It doesn't work as expected ,see my paste
06:44:42 <elliott> cmccann: PackageDescription also has 13 straight string fields, let alone the lists of strings it has... optimising these few types would I think literally turn "words" into "bytes"
06:45:25 <elliott> cmccann: that could work, but you realise that there's a web frontend to uploading, right?
06:45:29 <elliott> it has to submit somewhere
06:45:33 <elliott> no point running a separate webserver
06:45:55 <elliott> it could just shove it into a queue that gets processed by some server to insert into the database, but that seems like unnecessary indirection for a simple task
06:45:57 <cmccann> yeah, I'm just mulling things over really
06:46:17 <cmccann> I just really don't like having the package db itself tied to the web UI
06:46:25 <ski> nand` : as i was trying to communicate, i don't think you want `widget   :: Widget a => a', but `widget   :: Widget a *> a' -- in actuality, you should do s/Widget a => // and s/forall a. /forall a. Widget a => /
06:46:33 <elliott> cmccann: well the way I see it is
06:46:38 <elliott> the acid-state stuff is just the web UI's cache
06:46:50 <koeien2> will hackage2 use acid-state?
06:46:51 <elliott> the .tar.gzes are still stored
06:46:54 <elliott> koeien2: it does
06:46:58 <elliott> koeien2: and it's causing problems :P
06:47:14 <elliott> cmccann: and that cache is perfectly reasonable, IMO, there's no real point separating it out *if* the memory usage can go low enough
06:47:22 <koeien2> it's little tested i suppose
06:47:24 <elliott> having the web UI be the authoritative source for anything but web accounts is a bad idea, I agree
06:47:29 <ski> nand` : your actual `widget   :: Widget a => a' is requiring the *context* of `case tab of Tab { widget = w } -> action w' to provide the `Widget a' constraint
06:47:30 <elliott> koeien2: it's more the RAM usage that's causing problems
06:47:30 <nand`> ski: the latter is exactly what I want, thanks
06:47:35 <elliott> (but the blame is the structures, not acid-state)
06:47:46 <ski> nand` : while in fact i think you want `tab' to provide that constraint
06:47:52 <koeien2> ah, ok. well it would be interesting to see it used in a "real" environment
06:48:02 <nand`> ski: yeah
06:48:07 * elliott mutters something about not having this constraint problem if you don't use an antipattern ;)
06:48:12 <elliott> koeien2: it will be
06:48:15 <nand`> I see what you mean now, this is what I didn't understand earlier
06:48:19 <elliott> koeien2: hackage2 is present, not future tense
06:48:23 <elliott> there's already thousands of lines of code
06:48:26 <koeien2> yup
06:48:28 <elliott> they're just not good enough yet :P
06:48:33 <nand`> so I'd have to put the instance declaration of Widget inside the body of the match
06:48:39 <ski> nand` : but still, an existential isn't really warrented in your code
06:48:52 <elliott> class Inty a where int :: a -> Int
06:48:57 <elliott> data Foo = forall int. (Inty int) => ...
06:49:05 <elliott> now it's extensible! :)
06:49:13 <nand`> ski: I'm not sure how to make it any better
06:49:20 <nand`> The old method was even uglier
06:49:29 <elliott> nand`: ? we told you how
06:49:39 <elliott> drop your typeclass
06:49:41 <elliott> data Widget = Widget { render :: Window -> IO () }
06:49:48 <elliott> your existential is equivalent to having one of those as a field
06:50:09 <elliott> using typeclasses as OOPy interfaces is almost always wrong, data-types are the tool
06:50:17 <nand`> elliott: I considered doing that, and got halfway through implementing it, but then I realized that would move a lot of code into regions where it makes little sense and adds further boilerplate as well; the Widget class is supposed to be completely separate from the Tab class
06:50:24 <nand`> it also adds problems because I have some other widgets in use that are *not* within tabs
06:50:38 <nand`> so I'd need extra render functions for each of those
06:50:44 <elliott> nand`: did you read the blog post I linked?
06:50:54 <koeien2> i have a related question. i am parsing a large file that specifies the format of other files, it is OO-like
06:50:56 <elliott> if you go through with this model you will honestly find it's a lot more inconvenient than the one me and ski are proposing
06:50:57 <nand`> elliott: only took a glance
06:50:58 <ski> nand` : you could replace `data Tab = forall a. Widget a => Tab { widget :: a , commands :: a -> [Command] , macros :: a -> Macros }' with `data Tab = Tab { widget :: Window -> IO () , commands :: [Command] , macros :: Macros }' as elliott (more or less) suggested before
06:51:01 <elliott> there's a reason it's considered an antipattern
06:51:05 <koeien2> now i have a typeclass, a data, and an existential.
06:51:06 <elliott> nand`: read it fully, it covers exactly your case
06:51:09 <elliott> down to the name Widget
06:51:09 <erus`> my C parser parses 1 + 2 :D
06:51:15 <erus`> and interprets *
06:51:35 <cmccann> oh, are we citing luqui's blog?
06:51:39 <elliott> it takes a very exceptional case to invalidate the common wisdom of many years of typeclass usage that accumulated in the community's recognition of the typeclass antipattern and I don't see it here ;)
06:51:49 <elliott> *existential typeclass antipattern
06:51:58 <hpaste> koeien pasted “design?” at http://hpaste.org/63737
06:52:07 <koeien2> is this the correct way to do this?
06:52:12 <ski> nand` : if you want you can define `Widget' as `Window -> IO ()' (or `forall m. MonadIO m => Window -> m ()' if you insist, perhaps for ease of use), and then use `widget :: Widget' in the other type
06:52:18 <elliott> koeien2: that layout :(
06:52:24 <koeien2> elliott: it's autogenerated.
06:52:36 <elliott> koeien2: what do you mean by correct?
06:52:46 <elliott> I see another existential waiting to be eliminated :D
06:52:54 <koeien2> right, i would like to eliminate that one
06:53:04 <koeien2> but there is "subtyping"
06:53:15 <ski> elliott : i'm not sure i would agree with "is almost always wrong" -- but i agree that one should always consider whether the complication of an existential is really warranted
06:53:29 <koeien2> so an IfcOpenShell is-a IfcConnectedFaceSet
06:54:34 <elliott> ski: probably I have been biased by my previous being bitten by the antipattern, my tendency to designs that wouldn't make anyone think of a typeclass in the first place, and seeing countless upon countless people fall prey to it in #haskell :p
06:54:51 <koeien2> but i'm not sure how to eliminate the existential here
06:54:52 <elliott> existentials are not always useless, but... I do think they receive about 70% more use than they should
06:56:11 <ski> agreed
06:56:20 <koeien2> i guess i could do  data X = ...; data Y = ...; class Upcast a b where upcast :: a -> b; instance Upcast Y X where ...
06:57:03 <elliott> koeien2: if you have subtyping it's reasonable
06:57:03 <erus`> @hoogle (m a) -> (m b) -> (a -> b -> m c) -> m c
06:57:03 <lambdabot> Control.Monad zipWithM :: Monad m => (a -> b -> m c) -> [a] -> [b] -> m [c]
06:57:04 <lambdabot> Control.Monad zipWithM_ :: Monad m => (a -> b -> m c) -> [a] -> [b] -> m ()
06:57:04 <lambdabot> Control.Monad foldM :: Monad m => (a -> b -> m a) -> a -> [b] -> m a
06:57:15 <erus`> @hoogle liftM2
06:57:16 <lambdabot> Control.Monad liftM2 :: Monad m => (a1 -> a2 -> r) -> m a1 -> m a2 -> m r
06:57:20 <koeien2> elliott: yeah and it can get quite deep
06:57:22 <elliott> erus`: liftM2 + join
06:57:40 <elliott> koeien2: telling that existentials pop up when modelling ugly OOP hierarchies :P
06:57:55 <ski> koeien2 : how is `IfcOpenShell.C' defined ?
06:58:09 <koeien2> ski: it's on line 8.
06:58:16 <koeien2> ski: this is not the best example, admittedly.
06:58:22 <koeien2> (note the name of the module)
06:58:49 <hpaste> koeien annotated “design?” with “design? (annotation)” at http://hpaste.org/63737#a63738
06:58:51 <elliott> koeien2: oh, ew, is that Henning class naming?
06:58:59 <ski> hm, that seems to define `IfcConnectedFaceSet.C'
06:59:12 <koeien2> ski: no that's the superclass
06:59:17 <ski> er, no, i'm reading this wrong
06:59:26 <ski> yeah
06:59:39 <koeien2> i've annotated with a clearer example
06:59:47 <ski> well, presumably you have some real methods in `C a' that actually *use* `a'
06:59:56 <ski> we'd need to know how `a' is used
06:59:57 <koeien2> ski: yes, in general.
07:00:06 <JustMaybe> since i cant get into C, is it a bad idea if you have a project with a lot of different modules to name things with file name like matrix_insert, list_insert?
07:00:09 <ski> (and also for the superclass)
07:00:30 <elliott> JustMaybe: this is not ##c.
07:00:31 <koeien2> ski: they are "fields", so for example  name :: a -> String
07:00:32 <elliott> whether you can get into ##c or not.
07:00:40 <elliott> register your nick and you will be able to join ##c
07:00:44 <erus`> Can i write my own IO type, like for C external function calls
07:00:46 <erus`> ?
07:00:57 <elliott> erus`: what would you want it to do?
07:01:09 <erus`> well it means i dont hyave to use a monad transformer
07:01:18 <erus`> my interpreter returns an either error value
07:01:20 <ski> koeien2 : so the types of the methods are all of the form `a -> ...' where `...' doesn't mention `a' ?
07:01:25 <koeien2> ski: yes
07:01:27 <elliott> erus`: You can wrap a monad transformer stack in a newtype.
07:01:35 <ski> koeien2 : then this can be eliminated, yes
07:01:42 <elliott> oh, indeed
07:01:44 <elliott> koeien2: just use simple composition
07:01:45 <koeien2> ski: maybe i should do that, then.
07:01:47 <JustMaybe> no you need invite, how do you get that+
07:01:52 <elliott> JustMaybe: ##c, not #c
07:01:56 <elliott> koeien2: use a data type to represent each "class"
07:02:01 <elliott> koeien2: include the superclass as a field
07:02:03 <elliott> remove "a"
07:02:13 <koeien2> elliott: like data X a = { f1 :: String, super :: a }
07:02:17 <elliott> koeien2: no
07:02:26 <elliott> koeien2: let's say you have
07:02:27 <koeien2> ah
07:02:31 <elliott> class A a where { foo :: a -> IO () }
07:02:36 <koeien2> but won't it uses tons of indirection then?
07:02:38 <elliott> class (A a) => B b where { bar :: b -> String -> IO () }
07:02:40 <elliott> this can be turned into
07:02:42 <koeien2> have*
07:02:44 <elliott> data A = A { foo :: a -> IO () }
07:02:55 <elliott> data B = B { bIsA :: A; bar :: String -> IO () }
07:02:56 <cmccann> isn't tons of indirection what OOP is all about? :P
07:02:58 <elliott> koeien2: exactly as much as the existential
07:03:02 <elliott> existentials are just bundled dictionaries
07:03:26 <elliott> erm
07:03:27 <elliott> sorry
07:03:31 <elliott> data A = A { foo :: IO () }
07:03:31 <elliott> of course
07:03:33 <JustMaybe> hwo do you login once you regged?
07:03:38 <erus`> @pl \s -> execParser_ expressionP s (initPos "input")
07:03:38 <lambdabot> flip (execParser_ expressionP) (initPos "input")
07:03:51 <ski> JustMaybe : /msg NickServ identify <password>
07:04:04 <koeien2> ah if i have  class C a => D a, then D has a field C
07:04:11 <elliott> koeien2: yep
07:04:13 <koeien2> instead of "concatenation"
07:04:19 <elliott> koeien2: what OOP people would call composition over inheritance
07:04:21 <koeien2> right, then that's the easier solution.
07:04:43 <erus`> @hoohle String -> ByteString
07:04:43 <lambdabot> Data.ByteString.Char8 pack :: String -> ByteString
07:04:43 <lambdabot> Data.ByteString.Lazy.Char8 pack :: [Char] -> ByteString
07:04:44 <lambdabot> Data.String fromString :: IsString a => String -> a
07:05:13 <elliott> erus`: Are you sure you don't want Text?
07:05:13 <koeien2> i'm not sure how it compares for the users of the code. but i'll investigate. thanks for the pointers
07:05:23 <elliott> koeien2: well, the great thing is
07:05:38 <elliott> koeien2: for direct methods (i.e. not in a superclass), these have identical signatures to the typeclass versions
07:05:40 <erus`> i need to pass ByteString to C parser
07:05:41 <elliott> the record accessors, that is
07:05:59 <elliott> erus`: ok, what encoding does it expect data in?
07:06:13 <koeien2> maybe i'll need an overloaded "upcast"
07:06:14 <elliott> koeien2: it's true that getting at a superclass requires a bit of digging though
07:06:15 <erus`> no idea :3
07:06:25 <elliott> koeien2: yes, you could define an upcasting class
07:06:35 <koeien2> i would also like to be able to downcast
07:06:40 * cmccann still likes his subtypes library
07:06:41 <ski> elliott : hm, the existential type class version has the advantage of only allowing one implementation per type
07:06:47 <erus`> "The String interface only supports Latin-1 since alex-3, as alex now requires byte based access"
07:06:48 <elliott> koeien2: that doesn't really make sense in your context.
07:06:48 <koeien2> that's probably more tricky, but it might not be strictly necessary
07:06:54 <ski> cmccann : ?
07:07:03 <elliott> erus`: what has Alex got to do with talking to C?
07:07:15 <cmccann> ski: https://github.com/isomorphism/subtypes
07:07:23 <erus`> Language.C.Parser
07:07:26 <elliott> oh
07:07:31 <cmccann> ski, ;]
07:07:47 <elliott> erus`: right, well, don't get your input as a String
07:07:49 <elliott> get it as a ByteString
07:07:49 <ski> elliott : or hm, no that doesn't matter much -- except that you can only define a bounded number of instances
07:08:07 <elliott> ski: "one implementation per type" is meaningless
07:08:15 <elliott> since types are used as identifiers for implementations
07:08:22 <elliott> the types don't exist with the data version
07:08:39 <elliott> ski: but yes, you can't map over instances, or generate instances at runtime, etc.
07:08:51 <ski> yes, so you can define values depending on run-time input with the `data' version
07:08:52 <elliott> ski: which is why data is superior to instances
07:08:56 <elliott> because functions can transform them
07:09:07 <cmccann> it's also better OOP style
07:09:08 <neutrino> guys
07:09:16 <ski> elliott : yes, only saying that sometimes that restriction might be preferable
07:09:22 <elliott> ski: right
07:09:22 <cmccann> rather than being crippled by the assumptions of nominative subtyping created by crappy OO languages
07:09:24 <neutrino> would it make sense to have syntax for do blocks where you can define what monad a <- comes from?
07:09:26 <elliott> can't think of an example but maybe it exists :P
07:09:35 <koeien2> neutrino: no. you can already do that.
07:09:45 <elliott> neutrino: that doesn't really make sense, or is trivial, so no and yes
07:09:47 <elliott> but no
07:09:50 <ski> (.. so it's not completely equivalent)
07:09:51 * elliott helpful
07:09:54 <neutrino> let's say something like          x <- stuff <List>; y <- moreStuff <Maybe>
07:09:56 <koeien2> > (do { return 3; }) :: [Integer]
07:09:56 <lambdabot>   [3]
07:10:03 <elliott> ski: well it is in a way
07:10:04 <koeien2> neutrino: ah but that doesn't typecheck
07:10:07 <leoncamel> Did anyone get this "recursive dependencies" problem with ghc-7.4.1 : http://pastebin.com/90q66LmN ?
07:10:08 <mauke> The paste 90q66LmN has been copied to http://hpaste.org/63739
07:10:09 <cmccann> neutrino, that doesn't really make sense
07:10:09 <elliott> ski: because you can define an instance for the record
07:10:12 <elliott> ski: version
07:10:14 <neutrino> why does it not
07:10:16 <hpc> neutrino: think of what that means in terms of (>>=)
07:10:17 <neutrino> it makes perfect sense
07:10:19 <elliott> ski: which lets you conjure up instancse at runtime
07:10:25 <elliott> neutrino: no, it doesn't, a "do" block takes place in _one_ monad
07:10:28 <ski> neutrino : i suppose you could consider a system with subtyping for monads
07:10:30 <koeien2> neutrino: think how it desugars into >>=
07:10:32 <elliott> it's not magic, just syntactical sugar
07:10:35 <neutrino> you iterate over the list, and then only continue if y is Just baz
07:10:45 <elliott> ski: (by defining the class members as the accessors, obviously)
07:10:50 <hpc> neutrino: what happens if moreStuff is Nothing?
07:10:53 <hpc> neutrino: what if i did
07:10:55 <cmccann> neutrino, there is more than one possible interpretation of that and you don't want GHC magically picking one
07:10:55 <koeien2> neutrino: you can use guard for that
07:10:59 <elliott> ski: you can then define a mapInstance based on that
07:10:59 <ski> @type maybeToList
07:11:00 <lambdabot> forall a. Maybe a -> [a]
07:11:03 <koeien2> neutrino: or just write Just baz <- return y
07:11:06 <erus`> @hoogle [(a, b)] -> a -> m b
07:11:06 <lambdabot> Prelude lookup :: Eq a => a -> [(a, b)] -> Maybe b
07:11:07 <lambdabot> Data.List lookup :: Eq a => a -> [(a, b)] -> Maybe b
07:11:07 <lambdabot> Language.Haskell.TH.Syntax RecConE :: Name -> [FieldExp] -> Exp
07:11:10 <neutrino> then you do not continue, and you iterate over the next element of stuff
07:11:11 <hpc> do {x <- getLine; [x]} :: [String] -- neutrino
07:11:13 <elliott> ski: reify instance to existential, to record version, pass to function, use record result as instance
07:11:15 <koeien2> however, this requires a sensible fail
07:11:22 <elliott> ski: so, the typeclass buys you nothing
07:11:25 <hpc> neutrino: ^ is scaaaaary, and totally possible if what you want is also possible
07:11:40 <erus`> @hoogle maybe
07:11:40 <lambdabot> Prelude data Maybe a
07:11:41 <lambdabot> Data.Maybe data Maybe a
07:11:41 <lambdabot> Prelude maybe :: b -> (a -> b) -> Maybe a -> b
07:11:53 <neutrino> neutrino: why is that scary
07:12:04 <elliott> hpc: I assume that would become IO [String] or something else according to context-dependent rules that make no sense but happen to perfectly answer any example you can come up with :P
07:12:15 <hpc> elliott: oh, of course
07:12:26 <cmccann> oh, is this assuming {-# LANGUAGE DWIM #-}?
07:12:29 <cmccann> I guess that makes sense then :P
07:12:46 <neutrino> er
07:12:50 <neutrino> hpc: why is that scary
07:12:56 <elliott> neutrino: it's unsafePerformIO
07:12:56 <ski> elliott : i don't follow the "you can define an instance for the record version"
07:13:01 <cmccann> I think that's still waiting for someone to implement a sophisticated AI for GHC that guesses what people really want
07:13:03 <hpc> what elliott said
07:13:04 * elliott thinks that asking people "what about [proposal-breaking example]?" might be counterproductive
07:13:19 <hpc> neutrino: any do-block can do any IO, and you can't tell by the type signature
07:13:21 <elliott> we need a way to say "define a formal rule for every example I can come up with and commit to giving up if you have to change it" ;)
07:13:31 <hpc> and you can't tell by looking for unsafePerformIO either
07:13:33 <neutrino> hpc: when is that
07:13:34 <elliott> ski: do you know what I mean by "record version"?
07:13:47 <elliott> ski: I mean the non-existential Plain Old Datatype
07:13:50 <ski> elliott : the de-existentialized version, i believe
07:13:53 <elliott> right
07:13:53 <elliott> so
07:13:57 <neutrino> hpc: i don't see how this relates to the examples i gave
07:14:03 <elliott> ski: instance ClassVersion RecordVersion where { classMethod1 = recordAccessor1; ... and so on ... }
07:14:12 <elliott> ski: which we know works by koeien2's stated structure of all members
07:14:16 <hpc> neutrino: because it's starting in the IO monad and ending in the list monad
07:14:18 <cmccann> neutrino, your examples only make sense because you know what they're supposed to mean
07:14:27 <cmccann> and because you've picked a very trivial combination of monads
07:14:34 <elliott> ski: so, we actually *can* conjure up instances at runtime (under the assumption that everything uses the existential, which koeien2 tacitly confirmed)
07:14:49 <neutrino> cmccann: i have explained what they are supposed to mean. have you missed the explanation? sorry
07:14:49 <cmccann> try actually formalizing how this would work in general and how to decide what any particular combination means
07:15:00 <elliott> ski: (and so does not care what particular "a" we pick, so we are free to pick RecordVersion whenever we want to generate an instance at runtime)
07:15:08 <hpc> neutrino: it's the same reason there isn't implicit conversion between floats and ints, etc
07:15:15 <neutrino> cmccann: yeah, that would be one step towards fleshing out the idea
07:15:20 <cmccann> neutrino, no, you haven't explained anything
07:15:22 <cmccann> you have an idea
07:15:23 <hpc> neutrino: because "what happens when i want a number to be true/false, or a list, or ..."
07:15:27 <neutrino> hpc: i think you're lost on this
07:15:43 <hpc> you have an idea that doesn't generalize in a sane way
07:15:43 <cmccann> that isn't even clearly specified enough to examine properly
07:15:45 <neutrino> cmccann: yes i have an idea
07:15:46 <elliott> i don't think hpc is the one that is lost
07:16:04 <elliott> but right now everyone is losing until we get a more concrete description of this proposal
07:16:16 <elliott> ski: does it make sense now?
07:16:19 <neutrino> hpc: that's a strong statement, i'll expect a proof of non-existence on my desk by 6 pm
07:16:23 <erus`> you guys know how C cats numbers? long + int becomes a long?
07:16:36 <erus`> cast*
07:16:47 <koeien2> yes a bit
07:16:47 <elliott> (if hpc does not prove neutrino's feature impossible, are the GHC devs legally obligated to implement it?)
07:16:50 * ski would call that "coercion", not "casting"
07:17:08 <neutrino> elliott: only as long as it's not dependent typing.
07:17:20 <cmccann> neutrino, nobody is going to take your idea seriously if you don't actually explain what it's supposed to do
07:17:31 <hpc> erus`: fun exercise: come up with rules for when an expression in C evaluates to true
07:17:34 <cmccann> and no, giving a few examples of what you want it to do doesn't count
07:17:37 <hpc> hint: think of floats first ;)
07:17:53 <neutrino> cmccann: calm down, you'll get a heart attack!
07:18:04 <elliott> you're just trolling now
07:18:07 <cmccann> yeah
07:18:11 <cmccann> the idea is nonsense anyway
07:18:15 * cmccann gives up
07:18:16 * ski thinks neutrino wants subtyping for monads
07:18:19 <hpc> wait nvm, float was designed so 0.0 == 0x000000...
07:18:25 <cmccann> I don't think neutrino knows what neutrino wants
07:18:26 <elliott> ski: ok, I guess I just lost you :P
07:18:27 <erus`> hpc non zero?
07:18:28 <neutrino> i come here to discuss something in a light manner and everyone gets heated up
07:18:39 <neutrino> you can't expect me to take this seriously
07:18:40 <elliott> neutrino: nobody's heated up, you're just being defensive without actually explaining your idea
07:18:43 <hpc> erus`: yeah, derp
07:18:56 <hpc> forgot the bit layout of floats for a second there
07:18:56 <RichyB> hpc, but -0 is 0x80000000 (or 0x00000080 depending on endianness) =)
07:19:05 <elliott> neutrino: demanding you clarify or else we'll give up talking to you =/= getting heated up
07:19:15 <elliott> in fact, it's precisely that which lets us not get heated up trying to figure out wtf you mean :P
07:19:28 <ski> elliott : my brain is a little bit overloaded at the moment, i need to consider this calmly
07:19:28 <neutrino> how can you not be defensive with comments like "nobody is going to take your idea seriously" or "you have an idea that doesn't generalize in a sane way"
07:19:29 <RichyB> I think so anyway. Are there architectures where float endianness differs from integer endianness?
07:19:41 <elliott> ski: ok
07:19:42 <neutrino> have you guys actually read what you typed there over the last 10 minutes
07:19:57 <elliott> neutrino: sorry, it's true ... you have discovered the conspiracy of haskell
07:20:06 <elliott> we've been working to conceal this feature from the programming world for the past ten years
07:20:12 <elliott> through intimidation and anger
07:20:14 <mux> neutrino: I feel you. some people don't realize how abrasive/rude/condescending they are.
07:20:17 <koeien2> neutrino: ok let's try again. what would you want do { x <- [1,2,3]; Just 1 }  to do?
07:20:20 <erus`> maybe i will require cast :)
07:20:23 <nand`> What's the appropriate way to handle cyclic imports with GHC?
07:20:25 <erus`> 'C done right'
07:20:32 <koeien2> nand`: look up boot-files
07:20:43 <hpc> nand`: ideally, refactoring; also see hs-boot files
07:20:45 <byorgey> nand`: refactor so they aren't cyclic
07:20:47 <neutrino> koeien2: interesting. i guess that depends on the type you assign to this block
07:20:58 <koeien2> neutrino: but i'd like to have it inferred for me.
07:20:58 <ski> koeien2 : `do { x <- [1,2,3]; maybeToList (Just 1) }' iiuc
07:21:00 <nand`> byorgey: that would require putting everything into one big source file
07:21:01 <hpc> hs-boot files are a bit of a pain in the ass to maintain
07:21:11 <koeien2> ski: no i'm deliberately taking a non-typechecking example
07:21:18 <elliott> neutrino: seriously though: with the information we have, your idea looks like nonsense. there's no point pretending otherwise, if anything it should just encourage you to explain more concretely
07:21:23 <ski> koeien2 : huh ?
07:21:26 <nand`> everything depends on everything
07:21:39 <koeien2> ski: i'm trying to understand neutrino's proposal
07:21:56 <byorgey> nand`: heh, fair enough.
07:21:59 <neutrino> koeien2: i see you could say "ok, the last line is of type Num a => Just a so let me make the whole thing be Just a", but then you are looping over something. i guess the middle ground would be some sort of fusion of the two monads ("fusion" used in a non-technical manner)
07:22:00 <ski> neutrino : i don't think your idea sounds like nonsense, but i think you'll have to be more specific with what you want
07:22:11 <neutrino> ski: of course
07:22:17 <nand`> Is it possible to just split a single big module into separate files without cabal whining at me because the file names don't match?
07:22:32 <elliott> neutrino: you can't compose two arbitrary monads to get a monad
07:22:35 <hpc> nand`: you could be silly and use CPP includes
07:22:38 <elliott> only if they commute
07:22:39 <koeien2> neutrino: right, but two monads cannot always be composed.
07:22:40 <nand`> either that or I dump all of my types and type classes into a single big Types
07:22:44 <nand`> then include that in every module
07:22:46 <koeien2> neutrino: what elliott said :)
07:22:46 <nand`> I think I'll do that
07:22:48 <hpc> so you have foo.hs, bar.hs, etc
07:22:55 <hpc> then #include all of them into a single file and compile
07:22:58 <elliott> neutrino: (& what you get as a result is probably not what you want in a lot of cases anyway)
07:22:59 <ski> elliott : well, one monad could be included into another, as well
07:23:04 <neutrino> koeien2: that's an interesting point
07:23:05 <elliott> neutrino: also it's undecidable whether two monads commute
07:23:10 <neutrino> elliott: why do the two monads need to commute?
07:23:13 <nand`> hpc: That actually does sound like what I want. It's a program, not a library, so I don't need modules in the first place
07:23:15 <koeien2> neutrino: also. do { () <- launchMissiles; Just 1 }
07:23:20 <elliott> neutrino: it's formally proven
07:23:31 <elliott> the only implementation you can give requires commute :: m (n a) -> n (m a)
07:23:39 <elliott> (that is generic in m and n)
07:23:40 <rwbarton> it's not really "commuting"
07:23:49 <elliott> yeah, I don't know why I said commute
07:24:03 <hpc> it's more like sequence
07:24:05 <hpc> :t sequence
07:24:05 <neutrino> wait so if i have a composition of monads, such as Maybe [a], then the list and maybe monad need to commute in some way?
07:24:06 <lambdabot> forall (m :: * -> *) a. (Monad m) => [m a] -> m [a]
07:24:06 <elliott> pretend i said foo instead :p
07:24:13 <rwbarton> anyways combining monads is an important issue that a lot of people have thought a lot about.
07:24:17 <hpc> replace [] with 'n'
07:24:20 <neutrino> elliott: sorry the only implementation of what?
07:24:20 <elliott> neutrino: no, you can maybe give that an instance independent of the generic thing
07:24:29 <elliott> neutrino: but the point is that you cannot compose *any* two monads and get a monad
07:24:40 <elliott> urgh, I'm not explaining this well
07:24:40 <hpc> neutrino: see: monad transformers
07:24:49 <elliott> but yes, monad transformers are the way to do this and they are essentially ad-hoc
07:24:56 <neutrino> what is an example of two monads which you cannot compose?
07:25:03 <elliott> IO and []
07:25:05 <koeien2> neutrino: yes. but there are monads that don't play so nice
07:25:07 <koeien2> neutrino: see: IO
07:25:15 <neutrino> can you give me an example of how they don't compose?
07:25:27 <koeien2> commute :: IO [a] -> [IO a]
07:25:30 <koeien2> you can't write this
07:25:36 <koeien2> (in a sane way)
07:25:39 <elliott> you can but it won't follow the laws you need (that I forget)
07:25:44 <cmccann> in a useful way, rather
07:25:44 <neutrino> why do i need commute?
07:25:45 <elliott> basically each IO in that list duplicates the effects
07:25:50 <elliott> neutrino: because you do
07:25:54 <neutrino> what for?
07:25:58 <elliott> try and define the Monad instance for the composition of two monads
07:25:59 <rwbarton> writing join
07:26:04 <elliott> hint: write join, not (>>=)
07:26:11 <elliott> you will find you need "commute"
07:26:22 <neutrino> :t join
07:26:23 <lambdabot> forall (m :: * -> *) a. (Monad m) => m (m a) -> m a
07:26:32 <neutrino> ok i see that
07:26:32 <Azel> neutrino: Because otherwise, which composition should the compiler choose: m (n a) or n (m a) [with m and n monads] ?
07:26:33 <hpc> you need magicjoin :: m (n a) -> n a
07:26:33 <mux> neutrino: if it was possible to compose two monads in the general case, there would be no reason for monad transformers to exist
07:26:34 <elliott> (Monad can be defined as return+fmap+join)
07:26:38 <elliott> (it's equivalent to return+(>>=))
07:26:42 <rwbarton> it's usually called a distributive law for one of the monads over the other
07:26:47 <neutrino> that's very basic abstract algebra there
07:26:49 <elliott> yes, I was looking for "distribute"
07:26:58 <elliott> but my brain gave me "commute"
07:27:03 <cmccann> rwbarton, around here it's usually called sequenceA
07:27:11 <hpc> :t sequenceA
07:27:12 <lambdabot> Not in scope: `sequenceA'
07:27:17 <hpc> @hoogle sequenceA
07:27:17 <lambdabot> Data.Traversable sequenceA :: (Traversable t, Applicative f) => t (f a) -> f (t a)
07:27:17 <lambdabot> Data.Foldable sequenceA_ :: (Foldable t, Applicative f) => t (f a) -> f ()
07:27:25 <elliott> cmccann: sequenceA should be called distribute :P
07:27:43 <magicman> Eh. (m `O` n) a -> (n `O` m) a looks like commutativity of `O` for m and n. I can see why your brain would say that :p
07:27:47 <neutrino> what if you could define m n (m n a) -> m k n a, where k is some other interesting object?
07:28:10 <hpc> neutrino: that's a kind error
07:28:12 <neutrino> maybe m n != n m, but still they can be used in ways that abstract interestingly
07:28:20 <elliott> they can?
07:28:33 <neutrino> as in "maybe can"
07:28:39 <neutrino> i guess i didn't say that clearly
07:28:52 <neutrino> hpc: why is it a kind error?
07:28:53 * ski has considered the type `m a -> (a -> n b) -> n b'
07:29:06 <hpc> neutrino: first you apply two types to m
07:29:11 <Philippa> ski: "rebind"?
07:29:11 <hpc> neutrino: then you apply 3
07:29:18 <hpc> "m n a" vs "m k n a"
07:29:42 <dcoutts> nand`: you can always split a module into multiple mutually recursive modules
07:29:53 <neutrino> hpc: have i been missing parentheses there?
07:29:59 <dcoutts> nand`: and cabal and ghc can cope with that
07:30:17 <neutrino> i meant m( n( m( n( a )))) -> m( k( n( a )))
07:30:27 <neutrino> hpc: does that make more sense?
07:30:34 <dcoutts> elliott, cmccann: re package description. I agree with elliott that making a local type that is a lot more compact is a pretty reasonable solution in the short term
07:30:46 <ski>   class (Monad m,Monad n) => Thin m n where thin :: m a -> n a; joinThin :: m (n a) -> n a; (>>=|) :: m a -> (a -> n b) -> n b; joinThin mna = mna >>=| id; ma >>=| anb = joinThin (anb `liftM` ma)
07:30:50 <ski>   class Thin m n => Thick m n where thick :: n a -> m a; joinThick :: n (m a) -> m a; (|>>=) :: n a -> (a -> m b) -> m b; joinThick nma = nma |>>= id; na |>>= amb = joinThick (amb `liftM` na)
07:30:55 <dcoutts> elliott: as you say, both more compact and pruning only the stuff we need
07:31:03 <elliott> dcoutts: right
07:31:09 <elliott> dcoutts: although I am not convinced there is all that much that isn't needd
07:31:11 <elliott> *needed
07:31:19 <elliott> the custom fields, for one, though
07:31:20 <dcoutts> elliott: in the longer term I'd like to change the types in the Cabal lib too, but that can catch up later
07:31:32 <hpc> ski: im not too thrilled about the use of amb in those classes...
07:31:33 <cmccann> I suspect there's a lot that isn't needed 99% of the time
07:31:43 <ski> hpc : hm ?
07:31:48 <dcoutts> cmccann: but there's very little that's needed never
07:31:49 <elliott> dcoutts: yes, I was going to write it in mind of going upstream later
07:31:49 <cmccann> but that separating out what needs what might be too much work right now
07:31:58 <cmccann> yeah
07:31:59 <hpc> ski: oh, misread
07:32:02 <elliott> cmccann: with in-memory state that'll just duplicate
07:32:05 <hpc> amb :: (a -> m b)
07:32:09 <elliott> since everything that is ever needed is in virtual memory at all times
07:32:11 <hpc> i see what you did there
07:32:13 <dcoutts> elliott: e.g. Text did not exist when we started Cabal
07:32:21 <elliott> dcoutts: yeah, I understand it as a historical thing
07:32:43 <elliott> dcoutts: I bet the GHC fast packed string thing existed ;)
07:32:45 <dcoutts> elliott: and you're also right that the CondTree is a mess, I've got a rewrite in the works
07:32:51 <elliott> but there were non-GHC compilers back then, or so I hear
07:32:57 <dcoutts> indeed
07:33:12 <dcoutts> Cabal lib I think still builds with hugs and nhc
07:33:13 <ski>   instance MonadPlus n => Thin [] m; instance MonadPlus n => Thick [] m
07:33:15 <elliott> dcoutts: UHC?
07:33:17 <ski>   instance Thin (State sr) (Reader sr); instance Thick (State sr) (Reader sr)
07:33:18 <ski>   instance Num n => Thin [] (Const n)
07:33:32 <koeien2> how is UHC these days?
07:33:37 <dcoutts> elliott: it can build other packages using UHC, not sure if UHC has enough of base to build Cabal
07:33:50 <elliott> koeien2: people are interested in its JS compilation support
07:33:57 <ski> Philippa : see above
07:34:08 <elliott> dcoutts: I would be interested in your CondTree reworking, since I'll have to make a copy of it anyway
07:34:13 <koeien2> elliott: yeah, there are some initiatives with ghc as well. I would also be extremely interested
07:34:19 <elliott> would it be easy to convert Cabal's CondTree to and from it?
07:34:26 <dcoutts> elliott, cmccann: btw, if we find our conversation takes over the channel, there's #hackage
07:34:32 <elliott> since obviously we're still tied to the Cabal library as it exists today
07:34:43 <ski> (er, s/[] m/[] n/)
07:34:56 <dcoutts> elliott: good point, I could try using my new data structure in hackage-server first
07:34:59 * cmccann is currently idling in hackage
07:35:06 <cmccann> er, #hackage
07:35:10 <dcoutts> elliott: make sure it works there before moving it into Cabal lib
07:35:12 <neutrino> ski: interesting
07:35:32 <neutrino> ski: so is Thin/Thick like an alternative to using Monad?
07:35:52 <elliott> dcoutts: well, I was planning to rework the types as my first thing; it'd probably be best to integrate it as part of that -- since every piece of code that touches one of Cabal's types is going to have to be adjusted
07:35:56 <ski> neutrino : also laws like e.g. `thin (thick na) = na' (but not `thick (thin ma) = ma')
07:36:02 <elliott> best to do it all at once than once (for compactness) and again (for experimental CondTree)
07:37:06 <neutrino> ski: so it encodes the non-commutativity of monads in the type system?
07:37:11 <ski> neutrino : it was an exploration of some commonality between three different examples of "mixing" monadic actions, in a way which seemed possibly related to what you wanted to do
07:37:15 <neutrino> basically
07:37:26 <ski> neutrino : if you have any other example, i'd be interested to hear it
07:38:03 <neutrino> ok what about using the same monad twice
07:38:07 <neutrino> just in different contexts
07:38:20 <alistra> > let qs (x:xs) = filter (<x) xs ++ [x] ++ filter (>=x) xs in qs [1,87,4,3,93,2]
07:38:21 <lambdabot>   [1,87,4,3,93,2]
07:38:26 <ski> neutrino : example or explanation of what you mean ?
07:38:31 <neutrino> typing
07:38:32 <koeien2> alistra: apply qs recursively.
07:38:37 <neutrino> let's say foo :: [[a]]
07:38:55 <neutrino> then doing x <- foo <List/1> could give you an [a]
07:39:06 <alistra> > let qs (x:xs) = qs (filter (<x)  xs) ++ [x] ++ qs (filter (>=x) xs)  in qs [1,87,4,3,93,2]
07:39:07 <neutrino> whereas doing x <- foo <List/2> could give you an a
07:39:08 <lambdabot>   *Exception: <interactive>:3:4-66: Non-exhaustive patterns in function qs
07:39:19 <koeien2> neutrino: you mean, join
07:39:19 <ski> (also note that `Thin' and `Thick' was just working names)
07:39:20 <neutrino> or, instead of that do <List> and <List/List>
07:39:24 <alistra> well i don
07:39:29 <alistra> 't know how to do it in one line
07:39:47 <qpu> alistra: you could test before calling qs
07:39:47 <dzhus> does OverloadedStrings allow using ++ (as in concatenation) with string-like datatypes?
07:39:50 <neutrino> koeien2: can you explain please?
07:39:58 <neutrino> i'm still a newbie to haskell :)
07:40:01 <alistra> > let qs xss@(x:xs) = if xss == [] then [] else  qs (filter (<x)  xs) ++ [x] ++ qs (filter (>=x) xs)  in qs [1,87,4,3,93,2]
07:40:03 <lambdabot>   *Exception: <interactive>:3:4-97: Non-exhaustive patterns in function qs
07:40:04 <koeien2> > let qs [] = []; qs (x:xs) = qs (filter (<=x) xs) ++ [x] ++ qs (filter (>x) xs) in qs (reverse [1..10])
07:40:06 <lambdabot>   [1,2,3,4,5,6,7,8,9,10]
07:40:06 <tromp__> @hoogle launchMissiles
07:40:07 <lambdabot> No results found
07:40:19 <koeien2> neutrino: sure. join "collapses" a monad one level.
07:40:25 <neutrino> ski: basically what's in the <>'s could perhaps specify explicitly which monad you're refering to
07:40:27 <koeien2> join :: [[a]] -> [a]
07:40:28 <alistra> > let qs xss = if xss == [] then [] else let (x:xs) = xss in  qs (filter (<x)  xs) ++ [x] ++ qs (filter (>=x) xs)  in qs [1,87,4,3,93,2]
07:40:30 <lambdabot>   [1,2,3,4,87,93]
07:40:30 <neutrino> koeien2: ah, yes
07:40:32 <koeien2> join :: IO (IO a) -> IO a
07:40:42 <neutrino> koeien2: exactly
07:40:46 <dolio> OverloadedStrings makes string literals have type IsString t => t
07:40:54 <koeien2> alistra: don't use "== []"
07:41:05 <Azel> join doesn't permit exiting monads, though
07:41:07 <alistra> koeien2: i don't know how to pattern match in one line
07:41:07 <ski> neutrino : yes, but what i'm wondering is what would be the typing restrictions on its use ?
07:41:15 <koeien2> alistra: case
07:41:16 <alistra> koeien2: i don't write normally like this
07:41:29 <neutrino> ski: on the use of <Foo/Bar> ?
07:41:38 <koeien2> let qs ys = case ys of { [] -> []; (x:xs) -> ...
07:41:43 <ski> alistra : `let qs [] = ...; qs (x:xs) = ..x..xs.. in ..qs..'
07:41:45 <kofron> i have a quick cabal question.  i just switched from 32 bit to 64 bit haskell-platform and now whenever i try to install a new package i get the following (or similar) error:
07:41:55 <alistra> > let qs xss = case xss of [] -> [] |  (x:xs) ->  qs (filter (<x)  xs) ++ [x] ++ qs (filter (>=x) xs)  in qs [1,87,4,3,93,2]
07:41:56 <lambdabot>   <no location info>: parse error on input `|'
07:41:57 <kofron> Building monte-carlo-0.4.1...
07:41:59 <kofron> <command line>: cannot satisfy -package-id mtl-2.0.1.0-5b7a9cce5565d8cc8721ba4f95becf1b
07:42:04 <elliott> alistra: ski's suggestion is better
07:42:09 <koeien2> alistra: | is a guard.
07:42:14 <ski> neutrino : yes, and on how to combine commands in a `do' which uses different monads
07:42:18 <koeien2> that's somehting else
07:42:22 <dcoutts> kofron: most likely you have two instances of the same version of the mtl package installed
07:42:27 <alistra> > let qs xss = case xss of {[] -> [] ;  (x:xs) ->  qs (filter (<x)  xs) ++ [x] ++ qs (filter (>=x) xs)}  in qs [1,87,4,3,93,2]
07:42:29 <lambdabot>   [1,2,3,4,87,93]
07:42:44 <neutrino> ski: well how about this: instead of using the righ-hand side let's use the left-hand side to specify
07:42:50 <neutrino> so for example if foo :: [[a]]
07:42:59 <neutrino> then let's write something like this:
07:43:00 <dcoutts> kofron: so blow away the duplicates
07:43:15 <neutrino> x = [y] <- foo
07:43:24 <neutrino> x will be of type [[a]]
07:43:24 <kofron> dcoutts: is there a way to get cabal to tell me where it's finding the libraries it is complaining about?
07:43:34 <dcoutts> kofron: ghc-pkg list
07:43:41 <ski> neutrino : why ?
07:44:05 <neutrino> or if you write x = [[z]] <- foo then x will also be of type [[a]] but will only contain the first element
07:44:22 <neutrino> in here [[z]] acts like <List/List> whereas [y] acts like <List>
07:44:27 <ski> neutrino : (re before) still doesn't answer my question :) : in `do x <- foo <A>; y <- bar x <B>; ..x..y..', exactly when is this well-typed ?
07:44:39 <neutrino> ski: i was going to answer this next
07:44:44 <ski> ok
07:44:48 <kofron> thx
07:44:51 <jeff_s_> Anyone know how I can get the configure part of gtksourceview to see my installation of the c libraries and headers in /usr/local?
07:45:18 <ski> neutrino : what is the role of `z' in `x = [[z]] <- foo' ?
07:45:31 <rwbarton> dolio: I gained a better understanding of the difference between a and (# a #) with this example:
07:45:37 <dino-> Ugh! cabal: Couldn't read cabal file "pqc/0.5/pqc.cabal"
07:46:01 <rwbarton> > let f x = case undefined of Nothing -> x+1 in case f 3 of _ -> "test"
07:46:02 <lambdabot>   "test"
07:46:10 <rwbarton> > let f x = case undefined of Nothing -> (# x+1 #) in case f 3 of (# _ #) -> "test"
07:46:11 <lambdabot>   "*Exception: Prelude.undefined
07:46:13 <dcoutts> dino-: when doing what?
07:46:21 <neutrino> ski: two roles. let foo = ["abc", "def", "ghi"]. Then z will be sequentially 'a', then 'b', then 'c' (obviously i'm using "then" in a non-exact manner)
07:46:24 <dino-> dcoutts: cabal list
07:46:34 <neutrino> ski: whereas y would be "abc", "def", "ghi"
07:46:51 <dino-> What's in that package's cabal file that's derailing cabal I wonder?
07:46:54 <neutrino> ski: the second role is: something to apply all the constructors to
07:47:15 <neutrino> ski: meaning, that we can't just have x = [[]] <- foo because that would look stupid ;)
07:47:20 <dcoutts> dino-: a bug in older Cabal lib versions that means it trips up on certain test-sute sections
07:47:41 <neutrino> ski: in your example, what is "..x..y.." ?
07:47:41 <ski> neutrino : hm, so your `x = [[z]] <- foo' would be equivalent to `x <- foo; z <- x' ?
07:48:09 <dcoutts> dino-: combined with not very good handling of files in the index that cabal-install cannot parse, it should ignore them or something instead
07:48:19 <neutrino> ski: no, it would be equivalent to u <- foo; z <- u; x = [[z]]
07:48:20 <ski> neutrino : `..x..y..' is any expression which (possibly) mentions `x' and `y'
07:48:28 <neutrino> ski: ok
07:48:43 <ski> neutrino : s/x = [[z]]/let x = [[z]]/ ?
07:48:58 <dino-> dcoutts: I'm not averse to upgrading my cabal-install or Cabal lib stuff, even outside of my distro's packaging if necessary.
07:49:16 <neutrino> ski: maybe, but in my mind the "x = [[z]]" is the left side of the <-.
07:49:44 <neutrino> maybe i should have just said [[z]], and skipped the x altogether. it was really just about accessing different levels of a monad.
07:49:54 <dino-> I've got cabal-install 0.10.2 and Cabal 1.10.1.0
07:50:01 <ski> neutrino : you didn't write it in that way in `u <- foo; z <- u; x = [[z]]' -- in current Haskell, that's not a valid command sequence to be put inside `do'
07:50:01 <neutrino> different levels of monads.
07:50:13 <neutrino> ski: oh, you mean there
07:50:17 <neutrino> yes, of course "let"
07:50:31 <neutrino> ski: i'd probably get a syntax error and would fix that right away :)
07:50:37 <ski> hm, so `x' will always be a singleton of a singleton, then ?
07:50:38 <dino-> Ah I see that's 3 vers back for Cabal.
07:50:55 <neutrino> in the [[z]] example yes
07:50:58 <Philippa> could you get what you want with wrappers around lift, eg lift $ lift (do ...) ?
07:51:06 <neutrino> basically you're controlling how finely-grained your iteration is
07:51:24 <koeien2> i think judicious use of join is enough
07:51:33 <ski> neutrino : why would that be useful ? -- or maybe you can write `x = [[z0,z1]] <- foo' (e.g.) as well ? (what would it mean ?)
07:51:37 <Philippa> it probably is here, yes
07:51:55 <nand`> elliott: if it makes you any happier, I've decided to git revert my work and will be taking your suggestions on a better way to design it into account the next time I try
07:51:55 <Philippa> join is runMonadM :-)
07:52:04 <hpc> Philippa: lol
07:52:07 <neutrino> ski: i think you should basically only be able to write things similar to those you would write in type declarations
07:52:18 <ski> Philippa : you saw the `Thin',`Thick' thing above ?
07:53:31 <neutrino> so if you do "[Just q] <- baz; return q" (or some code similar to it) then this might be a definition for [Maybe a] -> [a]
07:53:34 <ski> neutrino : yes, i was sortof assuming that the `[...]'s in `x = [[z]] <- foo' was meant to be interpreted as the type constructor `[]' (as opposed to interpreted as singleton lists)
07:53:52 <sir_blunderbrain> [A[A[A[A[AWelcome!
07:54:16 <neutrino> i guess it's like a type constructor, but how far you define it tells the language how finely-grained you want the interaction to be
07:54:41 <ski> neutrino : i have to say i don't completely understand yet what you want
07:55:04 <neutrino> think of it in terms of holes
07:55:13 <Philippa> ski: I technically saw it, but didn't read thoroughly - I'm just dropping in and out at the moment. Feel free to explain though? (just assume I'm having one of those days where my effective IQ's halved)
07:55:23 <ski> you seem to have two proposals, (a) allow commands like `pat <- expr <type>'; (b) allow commands like `pat = ??? <- expr'
07:55:45 <elliott> nand`: Me, happy?!
07:55:46 <dino-> dcoutts: Will build new cabal-install with new Cabal. Thank you
07:55:55 <neutrino> ski: i think those two are basically identical, and the second one is nicer syntax. it hadn't occured to me at first you could define it on the left side like that.
07:55:58 <elliott> nand`: but seriously, I wouldn't give the advice I do if I didn't want to help people avoid the same pitfalls I fell into ;)
07:56:15 <elliott> I'm happy with any code that works well for you
07:56:16 <ski> Philippa : the basic idea was : what's common between `MonadPlus m => [a] -> (a -> m b) -> m b',`State sr a -> (a -> Reader sr b) -> Reader sr b',`Num n => [a] -> (a -> Const n b) -> Const n b' ?
07:56:36 <dylukes> Greetings.
07:56:37 <ski> (Philippa : re IQ, i could say ditto)
07:56:38 <nand`> elliott: Fair enough. That being said, if I fall into these pitfalls it will be a learning experience
07:56:41 <koeien2> hi dylukes
07:56:43 <ski> ehlo dylukes
07:56:43 <dylukes> I have been delving into the source of an edwardk project.
07:56:48 <dylukes> I am slowly losing my mind.
07:56:51 <dylukes> This is my last cry for help.
07:56:53 <edwardk> trifecta?
07:56:56 <dylukes> Before the semigroupoids get me.
07:56:58 <elliott> nand`: GHC's brain exploded and you're still not satisfied with the learning experience? :D
07:56:59 <edwardk> hah
07:57:00 <dylukes> They're coming for me.
07:57:02 * Philippa hands dylukes a couple of spare SAN points
07:57:06 <nand`> The reason I reverted my edits was actually because I was going crazy with cyclic dependency issues and every attempt at solving them made things worse
07:57:09 <edwardk> by the time you see them, its too late
07:57:12 <dylukes> edwardk: Yeah, going through the Diagnostics module.
07:57:15 <elliott> nand`: try a separate module with all your types in it
07:57:16 <edwardk> hah
07:57:19 <dylukes> You have no idea,
07:57:20 <nand`> that's what I tried
07:57:24 <dylukes> how long I spent on that "e" parameter.
07:57:24 <dino-> Oh, hm, in cabal-install.cabal: Cabal    >= 1.10.1   && < 1.11
07:57:26 <neutrino> Philippa: my original question was: let's say i am inside a composition of monads, in a do block. i want to use <- from one monad, then <- from another monad. I would add annotations that specify what monad i am specifically referring to. how could that work?
07:57:27 <edwardk> heh
07:57:28 <dylukes> And now I want to beat my face in.
07:57:31 <ski> Philippa : or we might replace the first one with `[a] -> (a -> Maybe b) -> Maybe b'
07:57:35 <dylukes> Also Comonads.
07:57:35 <nand`> then I got into a bunch of ambiguity issues because of record selectors conflicting with local names and so on
07:57:38 <elliott> nand`: if that doesn't work, you're the proud owner of a big ball of mud :P
07:57:39 <elliott> oh
07:57:40 <nand`> most of the modules are imported qualified
07:57:43 <elliott> ugh
07:57:51 <Philippa> neutrino: yeah. I mostly saw a pile of "composed how?"-derived mess after that
07:57:54 <edwardk> the comonad is largely irrelevant
07:57:59 <dylukes> Yeah.
07:58:06 <dylukes> In any case, could you briefly explain "It" to me?
07:58:15 <ski> Philippa : so i'm assuming `thin :: m a -> n a' and `thick :: n a -> m a' such that `thin . thick = id'
07:58:16 <dylukes> It seems It-eratee-like.
07:58:26 <edwardk> It is a lobotomized It-eratee
07:58:35 <nand`> It was also ugly because I think data declarations + instance declarations for it should go into the same module as the functions that operate on them
07:58:38 <neutrino> Philippa: yeah. there's the problem with commutability. but i don't think i want to be able to compose the two monads i am referring to in the do block - i want them to stay separate. i just want the do block to be able to refer to more than one monad at a time, that's all.
07:58:45 <nand`> which is the way it works now
07:58:46 <ski> Philippa : specifically we can go from `Maybe' to `[]' to `Maybe' again, and from `Reader sr' to `State sr' to `Reader sr' again
07:58:59 <edwardk> It is a monad for querying some kind of input that keeps growing.
07:59:14 <edwardk> data It r a = Pure a | It a (r -> It r a)
07:59:27 <nand`> elliott: I can at least point the finger of blame elsewhere, since it's not my project originally. I've just been doing minor refactoring / feature adding :P
07:59:27 <edwardk> Pure says you don't care what input you get, your answer will be 'a'
07:59:36 <ski> Philippa : for the last example, we can go from `[a]' to `Const n a' (assuming `Num n'), but not back again
07:59:47 <dylukes> IT'S COFREE.
07:59:47 <dylukes> D:
07:59:51 <dylukes> Agh. That shit again.
07:59:54 <elliott> edwardk: It should be coded with what she offers.
07:59:57 <edwardk> It says 'if no input was supplied, my answer would be 'a', but if you enlarged the input, you could feed it to the function and get a new result
08:00:01 <edwardk> elliott: =)
08:00:09 <edwardk> thats what he said
08:00:27 <edwardk> ahahaha
08:00:29 <edwardk> yeah
08:00:32 <dylukes> I kind of see.
08:00:34 <edwardk> if you factor out the 'a' part you get
08:00:34 <Philippa> neutrino: tbh, I recommend just using multiple do blocks there
08:00:37 <dylukes> So Pure is like a Yield, almost.
08:00:43 <neutrino> ski: regarding well-typedness, if you did "do { a <- foo <A>; b <- bar <B> }"; then foo and bar would need to be of type A and B
08:00:52 <neutrino> ski: does that answer your question a bit more?
08:01:07 <neutrino> Philippa: yeah but that's non-ideal :)
08:01:08 <ski> neutrino : not `A t' and `B u', for some types `t' and `u' ?
08:01:13 <edwardk> It r = Cofree (Maybe `O` (->) r)
08:01:29 * ski was assuming `A' and `B' were meant to be monads here, so kind being `* -> *'
08:01:41 <elliott> O is so much uglier than (:.)
08:01:45 <Philippa> neutrino: eh, it's not an awful lot of overhead, especially when you can use pattern type annotations to almost simulate what you wanted
08:01:50 <edwardk> pure is an answer. that computation is done, won't change as you add more input. It tells you what the answer would be if there was no input, and provides a continuation that you can feed more input to.
08:01:59 <ski> neutrino : but still, the more interesting question is how `A' and `B' must be related
08:02:01 <edwardk> unlike an iteratee though, you need to keep feeding It all of the previous input as well
08:02:03 <dylukes> Where's the continuation...?
08:02:16 <edwardk> because there is no concept of how much input you have consumed so far tracked by It
08:02:16 <dylukes> data It r a = Pure a | It a (r -> It r a)
08:02:19 <dylukes> Pure a is just "Pure a"
08:02:21 <edwardk> r -> It r a
08:02:24 <ski> neutrino : maybe you have some actual code you're pondering ?
08:02:29 <dylukes> That's in "It", not Pure.
08:02:42 <dylukes> Okay, so an iteratee is
08:02:48 <dylukes> "this is what I have ,and give me more input"
08:03:00 <dylukes> It says "this is what I have, and give me the *updated* complete input"
08:03:05 <dino-> Well, maybe I had better leave this alone for now. Not sure what trouble it will get into building cabal-install against Cabal outside its deps range.
08:03:05 <elliott> dylukes: You are misparsing edwardk's "It" as the word "it".
08:03:09 <elliott> It is instead "[constructor] It".
08:03:15 <elliott> edwardk is trying to confuse It.
08:03:27 <dylukes> let's do
08:03:28 <edwardk> "It tells you" -- meaning It the constructor, not it the pronoun referring to Pure as an antecedent =P
08:03:33 <elliott> dino-: what was your problem?
08:03:36 <dylukes> data Daft r a = Pure a | Daft a (r -> Daft r a)
08:03:36 <dino-> It's not actually preventing me from cabal install what I want.
08:03:42 <dylukes> To avoid confusion, for the moment.
08:03:53 <dylukes> edwardk: XD
08:03:53 <ski> Philippa : the idea with `Const n' would be that it is probably more efficient to just generate a count, instead of actually generating a list of elements, and then count the length
08:04:25 <elliott> dino-: Is your problem GHC 7.4.1?
08:04:27 <dino-> elliott: cabal-install can't read the .cabal file of package pqc, because of problem with the Cabal lib it's built against.
08:04:30 <elliott> oh, ok
08:04:38 <edwardk> Ok, then Pure is just a result, and Daft is going to give you a result that you could use if you didn't have any 'larger' input available and the a continuation that accepts more input, and will either tell you its satisfied (Pure) or could keep eating input (Daft)
08:04:44 <dino-> So cabal list fails somewhere int he P's
08:05:10 <dino-> Anyway, cabal install works fine if you know the package name. Can use search of hackage website as workaround.
08:05:37 <neutrino> ski: well for example, i'll have a function keepGuessing: [Int] -> [IO Int] -> Bool. You enter your guesses for 4 numbers, and then random numbers are created, and if you guess them all then you have won (== True). It could look like: keepGuessing numbers guesses = all $ do { random <- numbers; x <- guesses; guess <- x; random == guess }
08:05:57 <dylukes> edwardk: got it.
08:06:21 <edwardk> So, It relies on the fact that the Parser from Prim tracks its notion of a position internally
08:06:38 <edwardk> so It doesn't need to hold onto position information
08:06:40 <neutrino> ski: i bet there's this great idiomatic way of doing this in Haskell but i think this illustrates my point well none the less
08:06:43 <dylukes> right.
08:06:58 <edwardk> and since you have to hold onto the entire input, this allows the parser to seek around in the input stream arbitrarily
08:07:05 <dylukes> It is sort of just "driving" the parsing.
08:07:09 <edwardk> i'm not entirely convinced this is a pure win
08:07:10 <dylukes> It doesn't actually keep any of the state
08:07:12 <dylukes> or anything.
08:07:16 <ski> neutrino : that type signature looks very strange -- are you sure you don't want `IO Bool' instead of `Bool' ?
08:07:18 <edwardk> but it seemed like a nice way to get started
08:07:19 <edwardk> yeah
08:07:38 <dylukes> Yeah, the first thing that comes to mind in that respect is,
08:07:43 <dylukes> chunking the input stream,
08:07:49 <dylukes> and sort of like, "garbage collecting"
08:07:52 <dylukes> bits you aren't using.
08:07:56 <dylukes> i.e., "revert to thunk"
08:08:09 <dylukes> Can you have a reversible thunk...?
08:08:12 <edwardk> yep. for that you'd need to add to It a notion of how much of the input has been consumed irreversibly
08:08:29 <edwardk> so that It can know to throw it away
08:08:33 <ski> neutrino : it wouldn't be safe to allow your program to have that type signature in Haskell
08:08:50 <dylukes> mm...
08:08:56 <jtootf> hi everyone! http://hpaste.org/63728 - this is a tiny spellchecker, which inspects words in a file to be in a dictionary, and prints them if they aren't. I'm wondering if it can be effectively parallized: spell function sparks do not depend on each other, and the order is irrelevant. however, since it works in IO, it's seems to be impossible to use Parallel.Strategies map function. Can anyone give any suggestions on how to parallize (or may
08:08:57 <jtootf> be optimize sequential part) this code?
08:08:59 <ski> neutrino : if a computation does I/O, it needs to have `IO' somewhere in its "return type"
08:09:04 <dylukes> btw, what's the difference between logDiagnostic and throwDiagnostic?
08:09:19 <dylukes> the throw can't really be caught :\... (by design?)
08:10:05 <dylukes> jtootf: a function from Word -> Maybe (Correction) is not in IO...
08:10:12 <dylukes> jtootf: Neither is a function Text -> Word
08:10:20 <dylukes> only reading the file input in is.
08:10:39 <jtootf> dylukes: HashTables are in IO
08:11:06 <jtootf> dylukes: and I'm using them to lookout dictionary words
08:11:07 <dylukes> Well, consider an alternative maybe?...
08:11:11 <hpc> jtootf: why not use a tree?
08:11:31 <jtootf> dylukes: I've tried a lot. this implementation is the fastest
08:11:39 <dylukes> jtootf: You can run HashTables in ST maybe.
08:11:52 <jtootf> hpc: Data.Set (finger tree) is 2.5 - 3 times slower on a lookup
08:11:57 <ski> neutrino : generally, it's not common that one wants `[IO Int]' at all -- i suspect that in your case you don't really want that
08:12:06 <edwardk> the throw can be caught theoretically by <|> and catchError, but you catch it in a slightly different form
08:12:10 <neutrino> ski: right true, that's just a draft :)
08:12:17 <edwardk> if you throw a fatal though, it doesn't get caught at present
08:12:27 <neutrino> true about IO in the return type
08:12:27 <edwardk> that is to keep you from having fatal errors caught by normal control flow
08:12:48 <ski> neutrino : but i'm still not sure on how you want the list monad and the `IO' monad to *interact* in your case
08:12:59 <dylukes> edwardk: heh...?
08:13:06 <dylukes> are Diagnostics Errors?
08:13:11 <jtootf> dylukes: maybe. actually, yes, I can, but that still leaves a question on how to parallize the code in the ST rather that in IO
08:13:13 <hpc> jtootf: https://en.wikipedia.org/wiki/Ternary_search_tree
08:13:16 <dylukes> I don't believe so.
08:13:25 <edwardk> they don't have to be, this isn't Either
08:13:25 <neutrino> ski: i want them to interact as if they were zipped
08:13:32 <neutrino> ski: or maybe i don't?
08:13:36 <ski> neutrino : one way of explaining that would be to explain how one could expand the code you want to write into currently allowed Haskell code -- but maybe that's hard if you're (relatively ?) new to Haskell
08:13:38 <neutrino> ski: hmm.
08:13:39 <dylukes> jtootf: btw, there are a bunch of parallel io packages.
08:14:00 <Philippa> neutrino: take a look at applicative functors, if you want zip-like compositional behaviour?
08:14:21 <neutrino> Philippa: i take that back. i want it to be nested iteration.
08:14:31 <jtootf> dylukes: monad-parallel consumes all the free memory easily. I didn't tried Par monad yet, but it's interface doesn't seem to fit nicely here
08:14:33 <dylukes> edwardk: So... maybe I should make my own error type with Maybe (Diagnostic) ?
08:14:35 <Philippa> that differs how?
08:14:37 <edwardk> in the current trifecta Prim is an instnance of MonadError for 'ErrState' rather than Diagnostic
08:14:52 <neutrino> Philippa: for each outer step you do all inner steps over and over.
08:15:02 <edwardk> in the version i keep meaning to finish, i swap out ErrState for just Diagnostic
08:15:08 <neutrino> as opposed to zipper style where for each outer step you do one inner step.
08:15:20 * cmccann suggests http://youtu.be/YtdWHFwmd2o for further documentation on "It"
08:15:26 <edwardk> which makes it easier to see
08:15:28 <jtootf> hpc: I'm trying to stick with the data structures that are already available on hackage. anyway, I don's see why ternary tree should be faster on lookup than a hashtable
08:15:39 <dylukes> edwardk: hm, so maybe it wouldn't be worth my time to try to work something out with trifecta's diagnostics as they are.
08:15:48 <edwardk> cmccann: =)
08:15:54 <edwardk> dylukes: it doesn't change things much
08:16:04 <Philippa> neutrino: ah, so concat-like
08:16:10 <edwardk> dylukes: just make your error type Diagnotic TermDoc or whatever
08:16:12 <elliott> cmccann++
08:16:17 <cmccann> heheh
08:16:27 <dylukes> edwardk: Sounds good.
08:16:35 <dylukes> edwardk: btw, all of the combinators require MonadParser...
08:16:38 <edwardk> yes
08:16:42 <neutrino> Philippa: kinda maybe probably
08:16:51 <ski> neutrino : anyway, i'm not clear on what the list `guesses :: [IO Int]' actually contains
08:16:53 <RichyB> Philippa, (>>=) is a useful shorthand for (concatMap) in golf competitions. :)
08:16:55 <edwardk> you can't use the combinators from there, but you can build and toss around diagnostics still
08:17:18 <edwardk> any combinators used in a more general setting won't have access to a notion of a current location
08:17:27 <neutrino> ski: inputs from the user
08:17:33 <edwardk> since they aren't parsing, they are typechecking or whatnot
08:17:34 <ski> neutrino : if i understood you correctly, the user makes all their four guesses before this code executes, right ?
08:17:38 <edwardk> so they'd be different combinators anyways
08:17:51 <neutrino> before, during, after, there's no difference in a lazy language
08:18:02 <ski> i know, but conceptually
08:18:29 <ski> the point : this code isn't (supposed to be) responsible for asking the user to make a guess ?
08:18:46 <dylukes> edwardk: Right.
08:19:10 <zachk> how would I be able to dual install ghc 7.2.2 and 7.4.* ?
08:19:12 <dylukes> btw, the use of "m" and "e" in Diagnostic threw me off for a while haha
08:19:15 <dylukes> I read the last bit as
08:19:21 <dylukes> (m [Diagnostic m])
08:19:22 <dylukes> >_>
08:19:25 <edwardk> heh
08:19:25 <neutrino> ski: well given the input is IO already, i'd say that conceptually the action of requesting input has been defined already
08:19:29 <ski> neutrino : judging from "inputs from the user", i suspect that you actually want `[Int]' instead of `[IO Int]'
08:19:34 <neutrino> so in your words, it's "already happened"
08:19:39 <edwardk> i'm planning on removing both of those parameters eventually
08:19:49 <edwardk> the user doc type just confuses people
08:19:50 <neutrino> yeah but [Int] would be easier
08:19:57 <neutrino> and would make the explanation more difficult
08:20:03 <neutrino> because the case would be too trivial
08:20:10 <edwardk> and i need to eliminate the 'r' type to get better error reporting from things like the preprocessor
08:20:11 <ski> hehe
08:20:49 <ski> neutrino : well, my current problem with your statement of the example is that it already seems non-realistic
08:21:01 <vivekyadav> I want to find the largest integer smaller than the sqare-root of an integer. But I'm completely confused with haskell number types
08:21:07 <ski> (i.e. why pass `IO'-actions to the function, instead of passing the guessed numbers themselves ?)
08:21:36 <dylukes> edwardk: So, when are all these changes hitting?
08:21:39 <vivekyadav> "floor sqrt fromIntegral "  didn't work
08:21:44 <dylukes> I'm debating switching to Diagnostics JUST yet, if it's soon.
08:21:54 <Palmik> Hi guys, have anyone here ever encountered this TH error "Type constructor `Foo' used where a value identifer was expected" Here is how to reproduce: http://hpaste.org/63742
08:22:21 <rwbarton> I think you want 'Foo, not ''Foo
08:22:23 <edwardk> eventually ;)
08:22:56 <Palmik> rwbarton, indeed. Why?
08:23:02 <vivekyadav> any help people
08:23:23 <ski> @type floor . sqrt . fromIntegral
08:23:24 <hpc> > floor . sqrt . fromIntegral $ (100 :: Int) -- vivekyadav
08:23:24 <lambdabot> forall b a. (Integral b, Integral a) => a -> b
08:23:25 <lambdabot>   10
08:23:26 <rwbarton> well 'Foo is the TH syntax for "the data constructor Foo", while ''Foo is the TH syntax for "the type constructor Foo"
08:23:27 <srhb> vivekyadav: You probably want floor . sqrt . fromIntegral
08:23:48 <ski> > (floor . sqrt . fromIntegral) 99
08:23:49 <lambdabot>   9
08:23:52 <Palmik> rwbarton, OK.
08:23:57 <srhb> vivekyadav: You're composing the functions, not giving two function arguments to floor, after all
08:24:03 <Palmik> rwbarton, thanks. :)
08:24:30 <rwbarton> normally in Haskell data and type constructors appear in different syntactic contexts, so there is no need for disambiguation
08:24:36 <vivekyadav> Thank you
08:24:54 <vivekyadav> but why do we need the '.' operator
08:25:39 <bhaskar> floor $ sqrt $ fromIntegral 101 , if you prefer brackets
08:25:42 <srhb> vivekyadav: Because you want floor(sqrt(fromIntegral(x))) not floor(sqtr,fromIntegral,x= so to speak
08:26:08 <zachk> > let intSqrt x = floor (sqrt (fromIntegral x)) in intSqrt 5
08:26:09 <lambdabot>   2
08:26:38 <srhb> vivekyadav: . is the function composition operator, go look it up. :)
08:26:58 <geekosaur> vivekyadav, because a function can be passed as a value, so you need some way to distinguish function calls from function-as-value.  and haskell doesn't use brackets for parameters because of currying
08:27:07 <geekosaur> (think map)
08:27:11 <bhaskar> hey guys, is there a arbitrary precision float I can use easily
08:27:11 <zachk> the (.) glues function output to function input
08:27:31 <bhaskar> I want 1/278 to go upto 100 decimal places or more
08:27:34 <geekosaur> bhaskar, I believe there's one or two on hackage
08:27:44 <vivekyadav> ok
08:27:51 <geekosaur> but if they're all things like 1/278, maybe you want Rational
08:28:02 <ski> vivekyadav : if you write `a b c', it means the same as `(a b) c', not `a (b c)', so `floor sqrt fromIntegral 99' doesn't meant `floor (sqrt (fromIntegral 99))' (which was what you wanted), it means `((floor sqrt) fromIntegral) 99' (which is nonsense in this case)
08:28:19 <bhaskar> I actually need the decimal points to solve euler problem 26
08:28:28 <bhaskar> http://projecteuler.net/problem=26
08:28:30 <vivekyadav> thank you, now I get the use of '.'
08:29:06 <bhaskar> but float or double seems to stop at 10-12 decimal points
08:29:26 <edwardk> bhaskar: there is a 'creal' package somewhere
08:29:30 <edwardk> for computable reals
08:29:34 <bhaskar> @geekosaur, I looked at some, whats a easy one to use
08:29:35 <lambdabot> Unknown command, try @list
08:29:37 <yitz> > let stable (x:xs@(y:_)) | x==y = x | otherwise = stable xs; isqrt x = stable $ iterate (\y ->(y*y+y+x)`div`(2*y)) x; isqrtLT x = let s = isqrt x in if s * s < x then s else s-1 in map isqrtLT [1..30]
08:29:38 <geekosaur> right, they're machine floating point values which tend to be something like 80 bits on intel
08:29:38 <lambdabot>   [0,1,1,1,2,2,2,2,2,3,3,3,3,3,3,3,4,4,4,4,4,4,4,4,4,5,5,5,5,5]
08:29:46 <yitz> vivekyadav: how about this ^^ ?
08:29:53 <edwardk> http://hackage.haskell.org/package/numbers-2009.8.9
08:29:54 <vivekyadav> I remember now, functions have the highest Precedence
08:30:04 <ski> s/functions/function application/
08:30:23 <ski> (and it's not completely true, `@',`~' and record construction has higher precedence)
08:30:28 <geekosaur> (well, 64 bits, or 128 for long double which I don;t think is exposed in haskell; 80 bits is internal precision)
08:30:31 <vivekyadav> yitz , yes I knew that one, but wanted to use multiple functions
08:30:33 <bhaskar> ahh! so good edwardk, thanks :)
08:30:43 <yitz> vivekyadav: ok :)
08:30:54 <bhaskar> BigFloat might be it
08:30:59 <edwardk> CReal
08:31:16 <edwardk> gives you infinite precision and you can showCReal with the number of decimals you want at the end
08:31:30 <edwardk> that way you have no intermediate rounding error
08:31:41 <bhaskar> sweet! thank thank you
08:32:00 <edwardk> the digits are computed lazily as needed
08:32:20 <hpaste> kaf3ii pasted “what is wrong with my show instance” at http://hpaste.org/63743
08:32:33 <bhaskar> that was exactly what I was looking, i knew it had to be there, but just could not find it
08:32:52 <hpc> edwardk: they aren't; try evaluating pi to 10000 places
08:33:04 <hpc> but it's true that it will only evaluate as many digits as you ask for
08:33:12 <hpc> and precisely
08:33:27 <edwardk> well, showing it demands them
08:33:36 <kaf3ii> adding a Show constraint on the Gt constructer should not be needed i hope
08:34:07 <hpc> edwardk: it demands all of them at once though; you can't get the first few digits without all the rest too
08:34:40 <edwardk> yes
08:35:09 <edwardk> oh yeah
08:35:12 <edwardk> its Int -> Integer
08:35:20 * hackagebot shake 0.2.5 - Build system library, like Make, but more accurate dependencies.  http://hackage.haskell.org/package/shake-0.2.5 (NeilMitchell)
08:35:58 <rwbarton> kaf3ii: well a Show a constraint needs to come from somewhere; and in the (Gt x y) case, all you get from the instance context is Show Bool
08:36:02 <koeien2> kaf3ii: well why does x implement Show ?
08:36:12 <ski> neutrino : anyway, if you could find a more convincing example (with explanation of what it's supposed to do), i'd be interested
08:36:22 <koeien2> (why is x of a type that instantiates Show)
08:36:24 <rwbarton> but x could have any type that's an instance of Ord
08:36:33 <edwardk> hrmm i wonder what happened to the lazy computable real implementation i'm remembering
08:37:00 <hpc> edwardk: it probably exists in a different package
08:37:07 <edwardk> yeah
08:37:14 <hpc> ive heard of it too
08:37:15 <edwardk> just not sure where it went =)
08:37:20 <bhaskar> what would that package be :)
08:37:34 <kaf3ii> rwbarton: i thought if i added the 'instance (Show a) =>' constaint that it would be granted that x and y should be Show instances in (Gt x y)
08:37:42 <rwbarton> no.
08:37:46 <statusfailed> What's the time complexity of Data.List.groupBy ?
08:37:51 <yitz> there
08:37:54 <koeien2> kaf3ii: no, it enfources that Show Bool in the second case
08:38:19 <hpc> edwardk: im actually not sure why CReal needs to consume the whole number before showing
08:38:48 <rwbarton> kaf3ii: the "a" in "instance (Show a) => ..." is the same "a" as in "Term a" later on that line.
08:38:53 <yitz> the wiki page about numerical computing in haskell lists various kinds of reals, including that one. i think that page hasn't been updated in years though.
08:39:04 <rwbarton> But the "a" that's the type of x and y in the Gt constructor has nothing to do with that.
08:39:15 <rwbarton> Because the Gt constructor has type Ord a => Term a -> Term a -> Term Bool
08:39:27 <rwbarton> It might as well be Ord b => Term b -> Term b -> Term Bool
08:39:39 <elliott> edwardk: Few Digits?
08:39:44 <elliott> The one lambdabot uses is from numbers.
08:39:50 <elliott> Its CReal is not Few Digits' CReal.
08:40:22 * hackagebot uniplate 1.6.6 - Help writing simple, concise and fast generic operations.  http://hackage.haskell.org/package/uniplate-1.6.6 (NeilMitchell)
08:40:29 <yitz> here: http://www.haskell.org/haskellwiki/Libraries_and_tools/Mathematics
08:40:46 <kaf3ii> rwbarton: ah, i think i understand now
08:40:47 <yitz> the information on that page seems to pre-date cabal
08:42:13 <kaf3ii> rwbarton: so then i would need to add a Show constraint at the Gt constructor :s
08:43:19 <rwbarton> Yes. Or somehow redesign the Term GADT so that the Gt constructor doesn't "forget" the type of its arguments, which I imagine you don't want to do.
08:45:20 * hackagebot aws 0.3.1 - Amazon Web Services (AWS) for Haskell  http://hackage.haskell.org/package/aws-0.3.1 (AristidBreitkreuz)
08:45:32 <kaf3ii> yup, Gt turns two (Term anything) to a (Term Bool), so then i would need to constraint that anything type or save it somehow..
08:46:11 <elliott> Term anything? Are you sure?
08:46:11 <yitz> the numeric prelude has a type Number.Positional that computes digits lazily.
08:46:17 <elliott> I suspect it's Term <anything from a specific list>.
08:46:28 <elliott> In which case you can make the list a class constraint, and add Show as a superclass to that class.
08:46:40 <yitz> it's based on Jerzy's classic paper on computing the digits of pi
08:47:52 <kaf3ii> elliott: i would think it sensible to just have the Ord constraint on the Gt constructor, so therefore i am i little reluctant to introduce other constraints
08:48:31 <elliott> Oh, any Ord.
08:50:56 <kaf3ii> more constraints at the constructors is probably the best solution
09:01:12 <qpu> how does `shrink` work from QuickCheck? it looks like it builds a tree where each node has some part of the parent value replaced by another.
09:02:10 <qpu> but how does QuickCheck determine which one is "simplest"?
09:02:47 <mux> there is another type-class for shrinking
09:03:09 <mux> and you provide a method that shrinks a data structure, more or less
09:03:17 <mux> I don't remember the specifics
09:03:40 <qpu> i've been poking around at the source but still trying to make sense of it
09:03:55 <cmccann> qpu, I think it just relies on you to give it a bunch of "simpler" values
09:04:02 <cmccann> and the simplest is whichever it simplifies the most
09:05:13 <qpu> most meaning the "deepest" value in the tree that still fails the property test?
09:05:55 <mux> most meaning the value it will have successfully shrinked most while still having it fail the test
09:10:29 <qpu> specifically, what is "shrinked most"? i imagine shrink(shrink(x)) is more shrunken than shrink(x), but how does it compare to shrink(shrink(x'))? my guess is somehow it doesn't matter
09:11:22 <qpu> if "abc" was a failing input, is "ab" smaller than "bc"? is the order of values `shrink` returns significant?
09:13:46 <erus`> round 0.55
09:13:48 <edwardk> shrink just requires that all the results be 'smaller' than the input, not that they be relatively ordered in a nice way
09:13:49 <erus`> > round 0.55
09:13:50 <lambdabot>   1
09:14:18 <rostayob> qpu: from the sources you can get a feel on how "shrink" works: http://hackage.haskell.org/packages/archive/QuickCheck/2.4.2/doc/html/src/Test-QuickCheck-Arbitrary.html#Arbitrary
09:14:35 <rostayob> for example:
09:14:37 <rostayob>   shrink []     = []
09:14:39 <rostayob>   shrink (x:xs) = [ xs ]
09:14:41 <rostayob>                ++ [ x:xs' | xs' <- shrink xs ]
09:14:43 <rostayob>                ++ [ x':xs | x'  <- shrink x ]
09:14:49 <rwbarton> I imagine quickcheck finds a value x which fails but for which none of the values returned by shrink x fail
09:14:53 <edwardk> it just hill climbs towards a better solution, it doesn't try to dodge local optima
09:14:56 <rostayob> rwbarton: yes
09:15:14 <qpu> edwardk: ah, that's what i meant to ask
09:15:36 <edwardk> that makes shrinking tractable
09:15:41 <qpu> edwardk: that also answers how it terminates
09:15:45 <edwardk> in practice this hill climbing is good enough for most uses
09:15:56 <edwardk> yeah
09:16:03 <rostayob> yeah finding the optimal solution in general is not an option
09:16:11 <edwardk> shrink should remove a constructor or count down using something well founded
09:16:26 <rostayob> it actually would be with well founded data structures
09:16:36 <erus`> yey i have casting :)
09:17:37 <rostayob> I guess shrink could be improved by giving it some "momentum" with the current types?
09:17:53 <rostayob> but maybe it's not really a problem anyways
09:20:18 <gwern> could always do exhaustive search down to the depth at which the counterexample was found
09:20:25 <edwardk> momentum is always tricky to deal with in a discrete scenario
09:22:46 <edwardk> gwern: that requires some kind of uniform 'cost' or 'distance' metric that you can use across widely different types though
09:22:57 <rostayob> edwardk: yeah I guess... I was thinking about gradient descent
09:22:58 <edwardk> when i shrink a list of ints i can shrink the ints, i can also shrink the list
09:22:59 <chridi> hi
09:23:52 <gwern> edwardk: treat the datatype as a breadth-first lazy list and test values until a smaller counterexmaple is found or you run into the original counterexample? if it's an ADT or something which is an implementer of Arbitrary, seems doable
09:23:56 <rwbarton> what, like the derivative of how false the property is? :P
09:23:57 <erus`> is there any code to parse C floats before i write this?
09:24:06 <erus`> C.Parser just reads them into strings
09:24:21 <edwardk> this is something near and dear to me right now because calculating type error slices is more or less the same issue, i can hill climb towards a smaller slice but finding the optimal one is out in NP or PSPACE land
09:24:44 <edwardk> rwbarton: =)
09:24:55 * gwern notes that exhaustive search seems like it would be in a high complexity class
09:25:05 <edwardk> yeah
09:25:14 <edwardk> quickcheck has the benefit that its fairly tractable
09:25:20 <rostayob> rwbarton: no I meant that I was borrowing the momentum idea from gradient descent :P
09:25:22 <edwardk> if you want an exhaustive search there is always smallcheck
09:25:36 <gwern> but if you combine quickcheck with breadth-first you get a worst-case guarantee
09:25:43 <edwardk> *nods*
09:25:53 <CodeWeaverX> Mornin'
09:25:58 <koeien2> good evening CodeWeaverX
09:26:10 <edwardk> otoh, what we have works well in the absence of a total ordering. you only need the partial order
09:26:39 <edwardk> and can deal with generators that can't generate the entire space
09:27:33 <vblm> Could someone please critique http://hpaste.org/63655? I'm still not too familiar with the standard library, so I would appreciate any improvements (especially with simplifying any of the functions).
09:28:22 <gwern> vblm: use hlint and turn on -Wall
09:29:33 <vblm> gwern: Thanks, never heard of it before. I'll look into it.
09:29:36 <rwbarton> vblm: also everywhere you use fst/snd, it would likely be clearer to unpack the tuple with pattern matching
09:30:07 <rwbarton> vblm: hpaste runs hlint for you, that's what all the "Warning"s below your paste are.,
09:30:26 <elliott> vblm: use type signatures on all top-level declarations
09:30:32 <elliott> vblm: they will help the compiler help you + serve as documentation
09:31:05 <vblm> rwbarton, elliott: Thanks for the suggestions.
09:31:34 <dzhus> why there's no fromLeft/fromRight in base library?
09:31:53 <elliott> dzhus: because that would be terrible
09:31:56 <elliott> the better question is why fromJust is there
09:32:01 <rwbarton> it's pretty rare that you would want them
09:32:31 <rwbarton> @type intersect
09:32:31 <lambdabot> forall a. (Eq a) => [a] -> [a] -> [a]
09:32:40 <rwbarton> > intersect "aaabb" "aabbbc"
09:32:41 <lambdabot>   "aaabb"
09:32:44 <rwbarton> :/
09:32:45 <amindfv> Is there a built-in function to show an Int with a specified number of leading zeros?
09:32:57 <elliott> amindfv: printf can do it at least
09:33:02 <elliott> but defining a pad function is easy
09:33:06 <rwbarton> > printf "%06d" 1024 :: String
09:33:07 <lambdabot>   "001024"
09:33:49 <amindfv> elliott: Thanks!
09:34:31 <rwbarton> vblm: combine xs ys is supposed to count how many items xs and ys have in common? (with repitition so that if z appears a times in xs and b times in ys, it contributes min(a,b))
09:35:03 <Rc43> Hi again.
09:35:11 <rwbarton> it seems like there must be a better way to do that
09:35:34 <Rc43> Are there mutable intset/intmap ?
09:35:37 <rwbarton> > let f xs ys = xs \\ (xs \\ ys) in f "aaabb" "aabbbc"
09:35:38 <lambdabot>   "aabb"
09:35:49 <koeien2> Rc43: a good question is: why do you want to do that? :)
09:35:49 <rwbarton> (that isn't a very good way)
09:35:51 <elliott> Rc43: there is the hashtables library. why do you want mutable?
09:35:59 <elliott> put it in an IORef or MVar if you really want something mutable
09:35:59 <koeien2> Rc43: but yeah, it's possible.
09:36:23 <Rc43> I have refactored my slow io with edge parsing, but it is still takes a lot of memory. I think it is because of using recursion with IntMap accumulator.
09:36:43 <koeien2> Rc43: let's see your code
09:36:50 <elliott> Rc43: you need a bang pattern somewhere probably
09:36:54 <elliott> not mutability
09:38:13 <vblm> rwbarton: Right, your description of combine xs ys is accurate.
09:39:09 <hpaste> Rc43 pasted “Slow IO, graph parsing” at http://hpaste.org/63744
09:39:39 <Rc43> koeien2, elliott, pasted
09:39:54 <Rc43> elliott, what is `bang pattern` ?
09:40:15 <elliott> Rc43: import System.IO.Unsafe
09:40:17 <elliott> what are you doing?!
09:40:30 <elliott> no no no ... readFileLazy is not OK, you need to remove that unsafePerformIO
09:40:36 <Rc43> elliott, dirty hack for converting Maybe to IO
09:40:39 <elliott> it breaks referential transparency
09:40:51 <Rc43> elliott, what do you mean?
09:41:02 <elliott> readFileLazy p can be not equal to readFileLazy p
09:41:12 <elliott> you should remove that
09:41:16 <Rc43> elliott, yes, but it is just test
09:41:32 <koeien2> it's very likely that you should replace insertWith with insertWith' and so on
09:41:35 <koeien2> some extra strictness
09:41:37 * glguy wonders why it is OK to use Flexible Contexts in programs without specifying the extension, but it is not OK to write a Flexible Context type without specifying the extension...
09:41:46 <Veinor> what's the difference between $(deriveSafeCopy 0 'base ''Foo) and deriveSafeCopy 0 'base ''Foo ?
09:41:49 <rwbarton> there's nothing wrong with unsafePerformIO'ing readFile, I do it all the time.
09:41:51 <elliott> Veinor: nothing
09:41:56 <elliott> Veinor: former was required syntax in olden days
09:41:59 <Veinor> ah okay
09:42:01 <Veinor> what's 'preferred'?
09:42:04 <elliott> latter imo
09:42:07 <elliott> cleaner
09:42:15 <elliott> but maybe if you care about ghc <7 (iirc)
09:42:22 <Veinor> well, i don't :)
09:42:35 <mjga>  glguy: because FlexibleContexts is deeply within type inference engine?
09:43:00 <elliott> Rc43: I find your code very difficult to read because of the double spacing, but readEdge/readEdges' are to blame
09:43:05 <elliott> you need to make acc strict
09:43:16 <elliott> probably by changing acc to !acc with the BangPatterns extension
09:43:22 <elliott> but please, fix that unsafePerformIO :(
09:43:54 <Rc43> koeien2, you mean put insertWith into separate function?
09:44:18 <Rc43> elliott, ye, don't know why it is pastes so
09:44:32 <Rc43> elliott, i'll look at it
09:45:10 <elliott> Rc43: basically you are building up a huge thunk in the acc argument I think
09:45:19 <elliott> because you transform the set a lot without ever forcing it
09:45:22 <elliott> thus resulting in growing memory use
09:45:44 <Rc43> elliott, what `forcing` means ?
09:46:16 <Rc43> also, bang patterns appeared a lot version ago? Can ghc 6.~ not contain them?
09:46:24 <rwbarton> Rc43: how much memory is "a lot", and how much input are you reading?
09:46:48 <elliott> Rc43: bang patterns are ancient
09:46:54 <Rc43> rwbarton, test input is generated by http://pastebin.com/pCUHaMeQ with n = 300
09:46:55 <elliott> Rc43: Forcing means... well, forcing the value of a thunk.
09:46:56 <mauke> The paste pCUHaMeQ has been copied to http://hpaste.org/63745
09:47:05 <elliott> Do you have a basic understanding of the semantics of lazy evaluation?
09:47:17 <Rc43> rwbarton, so there are about 90000 edges, memory is about 100mb
09:47:31 <elliott> Basically, when you recurse with acc being (f previousAcc), that doesn't cause any actual evaluation.
09:47:40 <elliott> It just builds up another reminder to do that later on when its value is actually demanded.
09:47:52 <elliott> Since you never demand it during the accumulation, it just builds up more and more layers for each recursion.
09:48:04 <elliott> Adding a bang pattern forces acc as soon as the function is entered, keeping memory use reasonable.
09:48:05 <Rc43> elliott, yes, but what is bad in it?
09:48:12 <elliott> Rc43: You complained about memory use.
09:48:13 <elliott> That's the cause.
09:49:14 <rwbarton> I'm not convinced the evaluated map-of-sets will be much smaller than the pile of thunks, but it's certainly worth a try
09:49:35 <Rc43> elliott, ! means `arg will calculated before use` ?
09:50:58 <rwbarton> let !x = ... in ... means that x will be evaluated before the body of the let expression
09:51:01 <elliott> Rc43: No.
09:51:09 <rwbarton> for some value of "before"
09:51:16 <Rc43> elliott, I have thought that while `empty` accumulator is growing no memory used, but then it is filled
09:51:58 <elliott> Rc43: You should probably read an introduction to the semantics of lazy evaluation. But I don't know one to point you at.
09:52:05 <elliott> Didn't monochrom have one?
09:52:08 <Rc43> elliott, ok
09:52:38 <rwbarton> Rc43: btw, trimNewLine doesn't need to do all this Maybe monad stuff
09:52:40 <elliott> Here we go. http://www.vex.net/~trebla/haskell/lazy.xhtml
09:52:45 <elliott> I don't know if it'll help you or not.
09:53:03 <rwbarton> you have it returning a value of type Maybe ByteString but in fact it always returns Just something
09:53:11 <Rc43> elliott, thanks
09:53:45 <rwbarton> you could simplify it to   trimNewLine source = case B.uncons source of { Just ('\n', trimmed) -> trimmed; _ -> source }
09:54:07 <rwbarton> similarly readEdges can never return Nothing
09:54:13 <Rc43> rwbarton, yeah, it firstly returned not only just
09:54:20 <rwbarton> yeah, ok
09:54:32 <rwbarton> I realize this isn't related your question; it would just make the code easier to read
09:54:56 <Rc43> rwbarton, readEdges can return Nothing
09:55:06 <rwbarton> it can?
09:55:10 <Rc43> look at `(acc,source) <- result` in the else branch
09:55:18 <rwbarton> but...
09:55:22 <rwbarton> you just checked result is not Nothing
09:55:29 <Rc43> Oh, yeah, sorry
10:04:27 <Rc43> rwbarton, elliott, btw bang pattern haven't improve memory usage, but reduces time from 0.35-0.45 to 0.25 sec
10:05:10 <Veinor> i read that as 'big bang pattern'
10:06:11 <elliott> Rc43: I'd second rwbarton's suggestion of insertWith' or such then
10:07:21 <luxurymode> I'm new to haskell and this confuses me a bit: let xxs = [[1,3,5,2,3,1,2,4,5],[1,2,3,4,5,6,7,8,9],[1,2,4,2,1,6,3,1,3,2,3,6]] and then...[ [ x | x <- xs, even x ] | xs <- xxs]
10:07:39 <luxurymode> where is "xs" coming from if the arg name is xxs
10:07:40 <luxurymode> ?
10:07:49 <koeien2> xs <- xss
10:07:52 <koeien2> xs runs through xss
10:07:55 <luxurymode> oh i see its getting pulled from xss
10:08:01 <luxurymode> haha i realized it as i asked it
10:08:03 <Rc43> elliott, insertWith' is a separate function? You mean to calculate it one time and then to use?
10:08:17 <Rc43> btw, it was koeien2's suggestion
10:08:17 <luxurymode> so the xs <- xss is evaluated first…?
10:08:24 <luxurymode> or only after the first part "asks for it"?
10:08:35 <mekeor> #haskell, like a drug, it makes addicted.
10:09:02 <letrec> Any better way to write:  (\k a ds -> return $ insert k a ds )
10:09:37 <luxurymode> koeien2, so xs <- xss binds the variable xs to each element in the list and then the other part uses the predicate to get only the evens?
10:09:49 <mekeor> by the way, i suggest using (h:t) (as in "head" and "tail") instead of (x:xs). i find it better... or what does the "s" stand for in "xs" ?
10:09:51 <elliott> Rc43: uh, no
10:09:56 <elliott> I mean the strict functions in Data.Set
10:09:59 <koeien2> mekeor: plural
10:10:05 <koeien2> pronounce x-ess
10:10:09 <mekeor> koeien2: ah, okay.
10:10:12 <elliott> luxurymode: yes
10:10:20 <elliott> luxurymode: don't think of it in terms of evaluation order
10:10:26 <mekeor> koeien2: but anyway, (h:t) is good, too, isnt it?
10:10:29 <luxurymode> yeah i realize thats the wrong way
10:10:31 <koeien2> mekeor: not idiomatic imo
10:10:52 <luxurymode> makes more sense to think of it as set comprehension
10:10:56 <elliott> luxurymode: basically, it maps over every element of xxs, producing [ x | x <- xs, even x ] for each one of them called "xs". that inner expression filters xs to only the even elements
10:10:59 <Rc43> elliott, ok, seen it
10:11:00 <luxurymode> cuz thats exactly what it is ;)
10:11:04 <elliott> exactly
10:11:12 <elliott> the list comprehensions desugar to a bunch of filters and maps
10:11:12 <luxurymode> elliott awesome thanks
10:11:19 <elliott> well, concatMaps technically, but it's easier to think of it as map and filter
10:11:22 <luxurymode> i thought ruby was awesome with collections
10:11:27 <luxurymode> haskell is ridiculous
10:11:30 <luxurymode> :)
10:11:31 <cmccann> it's a set comprehension except with a spurious order on the elements that you can usually ignore :P
10:11:54 <koeien2> mekeor: in the haskell world most people use (x:xs)
10:12:01 <koeien2> mekeor: it's a convention. you can ignore it of course.
10:12:08 <koeien2> i like it personally
10:12:38 * cmccann occasionally uses (xs:xss) for a list of lists
10:12:48 <mekeor> koeien2: hm. okay.
10:12:55 <nexion> http://hpaste.org/63747 <- how should that 'where' be indented?
10:13:35 <Rc43> eeeeeehm, I see insertWith' on hackage, but ghci cannot find it ...
10:13:45 <elliott> it's fairly recent I think
10:13:46 <koeien2> nexion: not on the same line as siteData probably
10:13:56 <elliott> but maybe you don't need it
10:14:02 <nexion> yeah.. I tried with 0 spaces too
10:14:11 <Rc43> for Data.Map everything is ok
10:14:14 <nexion> I'd like the code above to be able to use that function
10:14:39 <rwbarton> nexion: is there anything wrong with the way your paste is currently indented?
10:15:07 <nexion> it gives an indentation error
10:15:24 <rwbarton> I think you have some other error
10:15:48 <hpaste> rwbarton annotated “-” with “this works fine” at http://hpaste.org/63747#a63749
10:15:50 <koeien2> make sure your parens are nested
10:15:51 <elliott> Rc43: Really? Map k () works OK but not Set k?
10:15:53 <koeien2> correctly
10:16:21 <nexion> you're right :)
10:16:27 <Rc43> elliott, I mean Map has insertWith' but IntMap - not
10:16:34 <nexion> what's the general rule for indenting the 'where'?
10:17:12 <rwbarton> it needs to be more indented than the declaration it is attached to
10:17:34 <rwbarton> you can even indent it further than the body of the do block with no problem (other than that it looks ugly)
10:17:47 <mekeor> why did haskell developers chose "::" instead of ":" ?
10:18:05 <nexion> ah okay
10:18:29 <nexion> thanks :)
10:18:34 <nexion> got it working
10:18:34 <elliott> Rc43: ah, I see
10:18:50 <Rc43> (on hackage bot has)
10:18:52 <daimrod> mekeor: maybe because it has some roots in the ML family
10:18:53 <Rc43> *have
10:18:59 <rwbarton> I think what's happening here is there is a rule that a block is closed when including the next line in it would be a syntax error, like "where" would in this case
10:19:25 <mekeor> daimrod: hmmm
10:20:12 <applicative> mekeor, they fought about it, ml goes the other way :: for cons, : for types
10:20:44 * mjrosenb learned sml first
10:21:08 <mjrosenb> and later switched to haskell
10:21:11 <mekeor> applicative: types is more important then ML(, im(h)o)…!  -.-
10:21:22 <elliott> mekeor: cons is more common
10:21:26 <applicative> agda follows ML, so maybe the consensus is against Haskell
10:21:27 <elliott> mekeor: also :: is the lowest precedence operator
10:21:31 <mjrosenb> so my pronunciation of "::" has switched from "cons" to "hastype"
10:21:34 <elliott> so it should be big :)
10:21:36 <cmccann> agda needs more type signatures than Haskell
10:21:46 <edwardk> mjrosenb: =)
10:21:48 <elliott> (f $ x :: t) === ((f $ x) :: t)
10:21:52 <mekeor> applicative, elliott: what's "cons" ?
10:21:56 <applicative> that must be the reason in agda's case, you'd go crazy
10:21:59 <mjrosenb> and coworkers give you many fewer strange looks when you pronounce "::" in c++ "cons" than when you pronounce it "hastype"
10:22:00 <cmccann> type inference + lists as control structure means that cons is more common than type annotations
10:22:02 <elliott> mekeor: cons is a -> [a] -> [a]
10:22:13 <mekeor> huh?
10:22:16 <elliott> :t (:)
10:22:17 <lambdabot> forall a. a -> [a] -> [a]
10:22:17 <koeien2> it's (:)
10:22:17 <elliott> that's cons
10:22:20 <elliott> terminology is from lisp
10:22:27 <applicative> a lisp word
10:22:28 <elliott> (lisp terminology is from CONStruct)
10:22:29 <mekeor> ah, okay, okay, okay
10:23:11 <applicative> very frequently in Haskell contexts they'll haul out 'nil' and 'cons' for [] and :
10:23:52 <applicative> is there a more common way of pronouncing [] in haskell?
10:23:59 <rwbarton> monkey mouth
10:24:09 <rwbarton> er, robot monkey mouth
10:24:31 <elliott> nil and cons are good names for them
10:24:31 * applicative thinks inwardly "the empty list" which would be inefficient if it weren't his imagination only
10:24:34 <mjrosenb> rwbarton: no, that is (:[])
10:24:43 <rwbarton> hence the "mouth" part
10:24:56 <elliott> over half a century of precedent, not misleading, short, easy to pronounce
10:25:43 <applicative> yes, and familial  piety toward lisp is sound policy
10:26:20 <frusen> what is the best way to hash a string, md5
10:26:32 <frusen> ?
10:26:37 <Veinor> frusen: depends on why you're hashing it
10:26:54 <elliott> String or Text or ByteString
10:26:58 <elliott> if former two, in what encoding
10:27:00 <elliott> MD5 hashes bytes
10:27:05 <Veinor> if you're hashing it for purposes of password storage, you want bcrypt.
10:27:12 <koeien2> don't use md5. ever.
10:27:37 <frusen> i am just making a basic md5 hasher. you enter a string and i want the program to spit out the md5 hash
10:27:38 <elliott> also that
10:27:49 <elliott> frusen: ok, so you want to read in raw bytes from the user
10:28:12 <elliott> http://hackage.haskell.org/packages/archive/pureMD5/2.1.0.3/doc/html/Data-Digest-Pure-MD5.html
10:28:16 <koeien2> for educational purposes, it's fine.
10:28:20 <elliott> the pureMD5 package is probably sufficient for your needs
10:28:35 <elliott> or even http://hackage.haskell.org/packages/archive/Crypto/4.2.4/doc/html/Data-Digest-MD5.html (read in ByteString then unpack it to pass to that)
10:29:05 <clintm> I wasn't. :/
10:29:19 <clintm> ack... wrong window.  still getting used to irssi
10:30:02 <frusen> elliott: thanks, i got an idea now
10:39:51 <elliott> @tell monochrom Just read your whole page on lazy evaluation -- really excellent work! I love the presentation of the reductions.
10:39:51 <lambdabot> Consider it noted.
10:42:38 <Rc43> cannot reinstall world with cabal on windows =/
10:43:11 <JoeyA> Will GHC automatically unpack fields with strictness annotations?  Or are there cases where it can't?
10:43:50 <shachaf> JoeyA: I think you have to give it -funpack-strict-fields
10:44:05 <JoeyA> Is that implicit in -O2 ?
10:44:15 <shachaf> I don't think so, but not sure.
10:44:22 <shachaf> Unpacking isn't always what you want.
10:44:53 <JoeyA> Thanks
10:45:23 <glguy> Are there any good libraries for solving systems of linear equations on Hackage?
10:45:41 <koeien2> glguy: hmatrix
10:45:42 <sclv_> hmatrix?
10:46:06 <sclv_> there's also the direct blas bindings, but they're a bit more complicated to use in return for the lower-level power
10:46:14 <elliott> it's -funbox-strict-fields
10:46:15 <sclv_> hmatrix otoh is a snap
10:46:15 <elliott> confusingly
10:46:28 <shachaf> elliott: I meant unbox.
10:46:38 <elliott> JoeyA: But yes, it's not in -O2.
10:47:14 <JoeyA> I saw the warning about it re-boxing things.  Thanks for the info.
10:53:29 <luite> is it safe to call back haskell functions from C in a new pthread?
10:53:48 <Rc43> Is it possible that there are no profiling lib for fresh containers package?
10:54:26 <koeien2> no.
10:54:34 <koeien2> you have to compile those yourself
10:54:45 <koeien2> set library-profiling to True in ~/.cabal/config
10:54:49 <RichyB> luite, that's an involved enough question that you might want to ask in #ghc.
10:55:19 <shachaf> luite: If it's safe to call Haskell functions from C in a C program (from a pthread that didn't call hs_init), then I'd assume so.
10:55:21 <geekosaur> installing a new containers package can break stuff
10:55:35 <wavewave> hi
10:55:48 <Rc43> koeien, i have done it, but nothing
10:55:59 <Rc43> geekosaur, why?
10:56:37 <RichyB> Isn't containers one of the packages that's distributed with your GHC itself? You don't want to update those, AIUI.
10:56:43 <luite> shachaf: well, the idea is that I call a C function from haskell, with a callback that's something like (CInt -> IO ()), but that callback will be from another thread
10:56:47 <dcoutts> luite: yes it is safe, if the original C function that was called was marked 'safe' in it's FFI decl
10:56:48 <luite> C doesn't call hs_init
10:57:04 <wavewave> Rc43: because many pkgs depend on containers
10:57:08 <shachaf> luite: Right, but presumably the Haskell RTS does whatever preparations are necessary.
10:57:18 <shachaf> (If you call the C function with "safe", of course, as dcoutts mentions.)
10:57:33 <shachaf> This is all "presumably", of course. :-) You may not want to listen to me.
10:57:37 <luite> yeah, that's what I'm doing :)
10:57:42 <luite> dcoutts: thanks
10:58:10 <Rc43> wavewave, they are installed ok, but profiling isn't possible
10:58:14 <luite> I'm trying to creat bindings for fsevents :)
10:59:53 <wavewave> Rc43; containers usualy come with profiling, don't they?
11:00:55 <Rc43> wavewave, i dunno, my executable talks `couldn't find .. Data.IntMap .. perhaps you haven't install profiling libs for package containers 0.4.2.1`
11:01:28 <wavewave> Rc43; check /usr/lib/ghc-xxx/containers-xxx/ and whether you have libHScontainers-xxx_p.a
11:01:36 <wavewave> where xxx means version number.
11:02:23 <wavewave> the suffix _p.a indicates its profiling lib.
11:02:49 <devinus> what does xs stand for usually?
11:02:56 <wavewave> x's
11:03:00 <wavewave> many x
11:03:05 <geekosaur> Rc43, currently cabal-install doesn't handle updating core packages (that come with the compiler) very well, you ofte end up with version skew when something decides to use both versions f the package because different packages it wants were compiled against different versions of e.g. continers.  and cabal-install doesn't provide a "rebuild everything aginst the new library"
11:03:15 <elliott> Rc43: Do not install containers.
11:03:18 <elliott> It is a boot package.
11:03:36 <Rc43> boot package?
11:03:47 <elliott> boot package = package GHC needs to bootstrap
11:03:51 <geekosaur> comes with the compiler
11:03:56 <wavewave> very tightly interconnected with ghc
11:03:57 <Rc43> Also, SUDDENLY I haven't containtes-0.4.2.1
11:04:01 <elliott> Installing another containers will void your warranty and cause ghosts to haunt your typechecker forevermore.
11:04:05 <Enigmagic> luite: it is safe, yes
11:04:19 <wavewave> hmmmm. probably your haskell setup got messed-up.
11:04:23 <Enigmagic> luite: you need to use the -threaded rts though
11:04:40 <luite> Enigmagic: oh, why?
11:04:55 <Enigmagic> because you're executing haskell on multiple threads
11:05:25 <Rc43> elliott, what is bad in updating standard package?
11:05:45 <luite> Enigmagic: hm, right
11:05:58 <Enigmagic> luite: iirc the process will terminate if you attempt this without -threaded
11:06:18 <Rc43> geekosaur, if any package depends on version_1 and i am trying to install version_2 then it fails?
11:06:30 <luite> meh I don't really want to force that...
11:06:32 <wavewave> Rc43: basically you wills still have two versions of standard packages
11:06:39 <elliott> Rc43: It will mess up GHC.
11:06:56 <wavewave> Rc43: and everytime you compile something, it inconsistently links things.
11:07:29 <luite> without -threaded, will a blocking ffi function block all haskell executiong?
11:07:45 <wavewave> Rc43: so it will break almost everything. believe me. I am experienced :-P
11:08:06 <Rc43> So I can't It seems single possibility to use new features - copy them into sources.
11:08:24 <Rc43> * - `I can't`
11:08:54 <wavewave> Rc43: use new feature?
11:08:56 <geekosaur> it is possible to do it, just highly painful and best left to experts; avoid new boot ackages until the next compiler comes out that includes them
11:09:04 <Rc43> wavewave, insertWith'
11:09:04 <geekosaur> unless you like pain
11:09:17 <Rc43> wavewave, I had bigger problem with installing haskell gtk :P
11:09:32 <wavewave> Rc43: if you simply need one function, just see the source code and copy and paste.
11:09:39 <geekosaur> well, you might be able to do it if you use cabal-dev starting from a pristine environment
11:09:45 <Rc43> wavewave, it import s a lot :D
11:10:14 <Rc43> wavewave, btw it is normal; just wanted to use convinient way firstly
11:10:41 <wavewave> Rc43: do not hesitate to see inside the source code. actually it is quite helpful.
11:11:08 <wavewave> Rc43: most haskell functions are not so long, so you do not need much effort to rewrite it in your source code.
11:11:19 <Rc43> geekosaur, may be it is a nice way
11:11:28 <Enigmagic> luite: yes
11:11:37 <elliott> wavewave: iirc insertWith' etc. rely on internal Set representation
11:11:40 <elliott> so they can't be copied out
11:12:01 <wavewave> elliott: ah.. okay.. let me see the source code ;-P
11:12:16 <Enigmagic> luite: it will also block with -threaded unless you use forkIO/forkOS
11:13:43 <xivix> yay haskell
11:13:56 <xivix> that is all
11:14:47 <Rc43> eeehm
11:14:57 <Rc43> how can I return to containers 4.0.0.0?
11:14:59 <Rc43> :)
11:14:59 <wavewave> Rc43: I am confused.. are you using ghc-7.4 ?
11:15:15 <Rc43> wavewave, 7.0.4
11:15:37 <wavewave> looks like the new containers-4.2.1 cannot be compiled with old version of ghc..
11:16:14 <stepkut> Is there someplace that documents the fields that can appear in the module description in haddock (e.g. Module, Copyright, etc, as found here: http://www.haskell.org/ghc/docs/latest/html/libraries/base-4.5.0.0/src/Control-Applicative.html)
11:16:28 <Rc43> how to reset containers to 4.0.0.0?
11:17:02 <wavewave> use time machine.
11:17:07 <elliott> Rc43: rm -r ~/.cabal ~/.ghc
11:18:12 <Rc43> elliott,  sadly
11:18:37 <wavewave> Rc43: did you compile many packages already?
11:19:26 <elliott> today we learned: don't upgrade boot packages :)
11:20:19 <wavewave> elliott: i learned it many times already.. tears...
11:20:44 <Enigmagic> i wish cabal required a --force before hosing the system
11:20:58 <Enigmagic> now i just have to use --dry-run everywhere first to make sure it's not going to mangle everything
11:21:40 <elliott> new cabal does i think
11:21:57 <wavewave> whenever I start cabal install..., I am ready to hit Ctrl+C with my fastest biological response function
11:22:21 <wavewave> elliott: that sounds great.
11:22:59 * cmccann sometimes wishes cabal was harder to use, so as to discourage people from thinking of it as a proper package manager like apt or such
11:23:26 <cmccann> in the end it's a build system, albeit a clever one
11:23:58 <wavewave> cmccann: yes.. it should be compared with "configure; make ; make install" not with apt
11:24:05 <RichyB> luite, yes. Without -threaded, you get cooperative scheduling instead of preemptive.
11:24:27 <Rc43> wavewave, no
11:24:41 <Rc43> wavewave, it is relatively fresh system
11:24:46 <luite> RichyB: yeah I'm already rewriting stuff so that everything can run from the same haskell thread
11:25:01 <wavewave> Rc43: then, just remove .ghc, .cabal and reconstruct from cabal update
11:25:41 <wavewave> Rc43: anyway, some times you had better know how to do some emergency thing. so this is good to experience.
11:26:24 <wavewave> I experienced it in the last moment of some project. at that time, it was really painful.
11:26:36 <`Jake`> Just noticed how easy it is to view the source code of the ghc implementation... That's awesome.
11:26:47 <Rc43> wavewave, I can use cabal-dev too as said geekosaur
11:27:06 <wavewave> Rc43: yes... that's a very good idea.
11:27:49 <wavewave> `Jake` : yes. haskell people are awesome. every achievement is completely transparent and condensed to gems of algorithms.
11:28:02 <geekosaur> thing to keep in mind about cabal-dev is you need to use it consistently and pervasively (that is, for everything); don't install any packages globally, always install into a cabal-dev environment
11:28:08 * otters heart FP
11:28:11 <`Jake`> <3 Free Software & Open SOurce
11:28:38 <elliott> `Jake`: brought to you by microsoft ;)
11:28:40 <geekosaur> that insures that any library collisions that ever do happen can't spread to infect the entire package tree
11:28:40 <wavewave> it can never be more fun to look at guru's code.
11:28:56 <Rc43> geekosaur, but it has some bugs, so it is impossible sometimes use it
11:29:01 <`Jake`> sure, that's why I usually use linux
11:29:04 <cmccann> GHC's source is a little... interesting in some spots though
11:29:26 <cmccann> I particularly liked one comment saying something to the effect of "if you can explain what all this really means there's probably a PhD thesis in it for you"
11:29:36 <Enigmagic> RichyB: unless i'm wrong, i though all haskell code was scheduled cooperatively
11:29:40 <Rc43> geekosaur, I mean not bugs, but unfinished things
11:29:45 <geekosaur> elliott, that's slightly unfair, MSR is not corporate
11:30:15 <geekosaur> Rc43, you might also look at virthualenv, it's a bit more involved (can involve installing a new ghc into the virtualized dev environment) but may be more complete
11:30:20 <wavewave> so curious. what's relation between haskell and MS?
11:30:29 <cmccann> wavewave, MS Research
11:30:37 <cmccann> they fund a lot of work on GHC
11:30:38 <geekosaur> ghc development is funded by Microsoft Research in Glasgow
11:30:48 <wavewave> cmccann: i know.. so what does microsoft think about haskell?
11:30:49 <RichyB> Enigmagic, multiple threads but context switches happen on allocations, yes.
11:30:57 <cmccann> I know the C# language team likes it
11:31:20 <geekosaur> I believe haskell is part of the secure languages and operating systems research effort in MSR
11:31:22 <Wooga> hello, why Functor typeclass means thing that can be mapped over while usualy Functor means that this thing (described as Functor) could be used as function?
11:31:26 <cmccann> there's some obvious influence from Haskell in both C# and F#
11:31:41 <elliott> geekosaur: i was kidding
11:32:06 <erus`> is there a ones complement function?
11:32:07 <wavewave> Wooga: I cannot parse your question.
11:32:13 <elliott> Wooga: the haskell term comes from category theory
11:32:24 <elliott> dunno where the c++ meaning comes from
11:32:30 <RichyB> luite, wait I think I was wrong about that. If you block in an "unsafe" foreign function with the non-threaded RTS then you block the entire process, but I'm not so sure about "safe" functions. Lemme try a quick test program.
11:32:30 * cmccann isn't even sure what definition Wooga is thinking of
11:32:34 <cmccann> oh, is that from C++?
11:33:05 <shachaf> cmccann: Yes. In C++ "functor" means "something that defines operator()".
11:33:10 <cmccann> ah
11:33:17 <wavewave> Wooga: would you name 'thing' with some concrete thing?
11:33:23 <cmccann> sounds like a good way to overcomplicate things
11:33:51 * shachaf senses some anti-C++ bias.
11:34:09 <int-e> @quote assembler
11:34:09 <lambdabot> dons says: that's 3 things i've never seen in the one sentence before: my assembler .. a bunch of type classes .. a natural syntax
11:34:19 <Rc43> Wooga, may be you can think about Functor like about just function of functions? So fmap is applying/
11:34:47 <elliott> its just an etymlogy question.
11:34:48 <Rc43> Wooga, id est fmap functor functin = functor (function)
11:34:55 <cmccann> shachaf, I tutored people in C++ when I was in college and that soured me on it a bit
11:35:04 <int-e> @quote int-e assembler
11:35:04 <lambdabot> int-e says: C++ does make a reasonably usable high-level assembler
11:35:11 <cmccann> and every time I look at C++ again it just seems too difficult and complicated to do anything with
11:35:12 <shachaf> Rc43: That would be a pretty wrong way to think about it, unless I misunderstand what you mean.
11:35:13 <int-e> ok, it remembers :)
11:35:57 <Rc43> Rc43, just function `(A -> B) -> X`
11:36:10 <Wooga> welterde: well, yeah, almost anything in Haskell is function, so involving such term as "Functor" in meaning "could act as a function" doesn't makes much sense
11:36:27 <wavewave> I always think making some language hybrid will finally lead to inconsistency.
11:36:40 <Rc43> shachaf, like (fmap functor) x = functor ( x )
11:37:55 <elliott> Wooga: not almost everything
11:38:03 <Enigmagic> functions are functions
11:38:03 <elliott> only (a -> b) is a function
11:38:04 <wavewave> Wooga: you can think functor is a relation between function defined for this type to function defined for another type associated with the original type.
11:38:23 <elliott> Wooga seems to understamd functors
11:38:33 <wavewave> if a function defined for a, then some related function can be defined for [a]
11:38:37 <elliott> the question was about the name functor...
11:38:56 <elliott> as it's used with different meanings in other languages
11:39:01 <koeien2> the name comes from category theory
11:39:10 <wavewave> Wooga: mathematically that concept is functor.. nothing special at all.
11:39:30 <elliott> koeien2: yes, i said that 5min ago :P
11:39:41 * cmccann would expect ML to have first claim on the term in programming if anything
11:39:51 <cmccann> but category theory probably predates it all
11:39:54 <koeien2> oh i missed a lot of the conversation, excusez-moi :)
11:39:55 <wavewave> Category has object and arrows and functor is map between categories preserving category laws of arrows
11:41:36 <wavewave> It happened that haskell desingers are quite knowledgable about math.. so all names are quite mathy.
11:42:05 <Wooga> so, category theory terms. thank you guys.
11:42:29 <wavewave> I think that this is good for me because at least I know where to find exact definition.
11:43:11 <wavewave> if monad is named as workflow or some warm fuzzy thing, that i cannot imagine where the real concept come from.
11:43:27 <wavewave> s/that/then/
11:50:16 <Guest45444> what the hell man, my name isn't Guest45444
11:50:31 * hackagebot haskell-mpi 1.2.1 - Distributed parallel programming in Haskell using MPI.  http://hackage.haskell.org/package/haskell-mpi-1.2.1 (DmitryAstapov)
11:59:33 <`Jake`> Guest45444: how about /nick?
12:00:39 <erus`> > complement 123456789
12:00:40 <lambdabot>   Ambiguous type variable `a' in the constraint:
12:00:40 <lambdabot>    `Data.Bits.Bits a'
12:00:40 <lambdabot>      a...
12:00:50 <erus`> > complement (123456789 :: Int64)
12:00:51 <lambdabot>   -123456790
12:01:22 <Guest45444> lesson 4 on tryhaskell, w00t!
12:02:42 <Guest45444> what do you guys recommend I do after finishing the tryhaskell tutorials?
12:03:08 <Guest45444> i suppose i'll try some project euler problems...
12:04:06 <cmccann> project euler isn't really the best way to learn Haskell if you ask me
12:04:13 <cmccann> and also if you ask a few other people in here I think
12:04:35 <Guest45444> any recommendations?
12:04:50 <hpc> PE is where you go to learn number theory
12:04:54 <hpc> @where lyah
12:04:54 <lambdabot> http://www.learnyouahaskell.com/
12:04:59 <hpc> ^ the best tutorial around
12:05:09 <mike-burns> I recommend writing a Haskell library.
12:05:09 <hpc> and im not just saying that because i got the book for free ;)
12:05:12 <mike-burns> That's the best way to learn.
12:05:13 <cmccann> no recommendations, sorry :[ one of these days I'm going to write some better exercises
12:05:17 <dylukes> If you want something more meaty, I'm with mike-burns
12:05:26 <dylukes> Pick a simple task, and write a library to do it.
12:05:33 <hpc> i personally started out with an IRC bot
12:05:34 <mike-burns> It doesn't have to be big.
12:05:43 <dylukes> hpc: Yeah but that's not fun enough.
12:05:43 * cmccann is thinking problem statements for very simple libraries would be a good way to do exercises
12:05:47 <mike-burns> I started out with some convenience wrappers around time and date functions.
12:05:55 <cmccann> with some pre-written quickcheck stuff to run against them
12:06:16 <dylukes> mike-burns: IRC bot is just StateT s IO routines :\.
12:06:27 <hpc> dylukes: it can be fun; my bot calculated the d/dx of an arbitrary expression
12:06:29 <mike-burns> Sounds useful.
12:06:41 <dylukes> I guess.
12:06:43 <hpc> naturally it had an Optimus Prime easter egg
12:06:48 <dylukes> hah
12:06:49 <dylukes> of course.
12:06:59 <dylukes> Maybe I should write a new IRC bot one of these days >.>
12:07:17 <dylukes> brb food/sleep
12:07:34 <hpc> nowadays that bot is written in self-modifying perl
12:07:47 <hpc> so i can update it without restarting
12:08:00 <cmccann> self-modifying perl sounds like the best idea ever
12:08:22 <mike-burns> Hahah.
12:09:17 <hpc> cmccann: it's surprisingly not so bad
12:09:46 <hpc> i have to use eval in one place, but the rest of it is pretty much just "code in a functional style and you are fine"
12:10:22 <hpc> instead of "sub foo {...}", "$foo = sub {...}", etc
12:15:32 * hackagebot language-javascript 0.4.9 - Parser for JavaScript  http://hackage.haskell.org/package/language-javascript-0.4.9 (AlanZimmerman)
12:15:42 <osager> Hello why i always get an parse error in this code ?
12:15:44 <osager> data Bin = Bin {
12:15:44 <osager>         clearBottle  :: Int,
12:15:45 <osager> 		greenBottle :: Int,
12:15:45 <osager> 		brownBottle :: Int
12:15:45 <osager> }	deriving (Show)
12:15:45 <osager> findBest = clearBottle bin1 + clearBottle bin2 + clearBottle bin3
12:15:47 <osager>  where bin1 = Bin { clearBottle = 10, greenBottle = 15, brownBottle = 20}
12:15:49 <osager>            bin2 = Bin { clearBottle = 30, greenBottle = 12, brownBottle = 8}
12:15:51 <osager> 		   bin3 = Bin { clearBottle = 15, greenBottle = 8, brownBottle = 31}
12:15:58 <osager> at bin2
12:16:00 <Botje> osager: please don't paste in the channel.
12:16:05 <osager> ok
12:16:05 <Botje> osager: put it in hpaste.org
12:16:16 <Botje> osager: but I can tell you now: you're mixing tabs and spaces
12:16:20 <magicman> That, and that looks like layout trouble.
12:16:31 <magicman> Grah, ninjas :p
12:16:47 <osager> no the layout is ok in my editor
12:16:57 <osager> and i didnt mix tab with spaces
12:16:58 <b_jonas> lol
12:17:02 <Botje> osager: no, you're mixing tabs with spaces.
12:17:11 <Botje> they show up as inverted-space I's on my screen.
12:17:22 <Botje> tell your editor to convert everything to spaces
12:17:27 * mike-burns watches
12:17:30 * Clint chortles.
12:17:33 <Botje> that's the way of the least resistance
12:18:16 <osager> ok i'll try
12:21:32 <mondeun> I'm doing the tryhaskell tutorial and I wonder wich sorting algorithm sort uses
12:21:44 <Guest45444> spaghetti sort obv
12:22:38 <mondeun> thanks
12:22:38 <Veinor> I think I just broke a new personal record for number of language extensions used in one file
12:23:13 <Guest45444> over 9000?
12:23:20 <Veinor> mondeun: it looks to be some kind of mergesort
12:23:57 <Guest45444> also which part of tryhaskell are you on?
12:24:03 <Guest45444> i'm on lesson 5
12:24:09 <Guest45444> pretty cool language
12:25:02 <mondeun> just started on lesson 2. Are considering learning Python but got quite curious about haskell
12:25:34 <Guest45444> you made a good decision
12:27:14 <osager> can an expression be on the same line with where ?
12:27:21 <mauke> yes
12:27:26 <osager> ghci complains when my programs is like:
12:27:32 <osager> where expr1
12:27:35 <osager> expr2
12:27:41 <mauke> yes
12:27:49 <Botje> you have to indent expr2 as much as expr1
12:27:54 <osager> but it doesnt complain if expr1 is not ont he same line
12:27:57 <osager> with where
12:28:02 <osager> i did
12:28:07 <mauke> no, you didn't
12:28:08 <osager> but doesn't work
12:28:18 <Botje> osager: please show code (hpaste.org)
12:28:23 <mauke> "doesn't work" is meaningless. what's the code? what's the error message?
12:29:05 <osager> the indentation has to be exact the same for expr1 and expr2 ?
12:29:24 <osager> i'll paste the code
12:29:37 <`Zerax`> Save yourself the trouble and indent it consistently
12:30:55 <byorgey> osager: yes, the indentation of the entire where-block is determined by the starting column of the first thing after the where
12:31:03 <osager> the code i paste in hpaste changes automatically
12:31:10 <osager> from what i have in the editor
12:31:24 <Botje> doublecheck to make sure you don't have tabs, then :)
12:31:28 <byorgey> osager: are you using tabs?
12:31:29 <Botje> which editor are you using?
12:31:31 <geekosaur> osager, the indentation should be the same for both, yes.  there is a little room for variance but not much, and the rules are slightly different when expr1 isn't on the same line as where.  and yes, haskell uses layout / significant whitespace, and you want to make sure you don't mix tabs and spaces because they behave differently
12:31:38 <osager> i use notepad++
12:31:58 <osager> and i already use Space to TAB function
12:32:13 <Botje> convert tabs to spaces, not the other way round
12:32:26 <osager> i mean tab to space
12:32:28 <osager> sorry
12:32:37 <osager> but i did tried both ways
12:32:55 <`Zerax`> If it's not on already, enable showing of whitespace and check that it's not being mixed everywhere
12:33:36 <osager> anyway the expressions in where block has to be intended exactly the same ?
12:34:07 <magicman> Yes.
12:34:07 <RichyB> luite, d'oh. GHC's manual has a simple answer as to exactly when slow foreign calls will block the RTS: http://www.haskell.org/ghc/docs/7.0.4/html/users_guide/ffi-ghc.html#ffi-threads
12:34:26 <osager> ... can't believe this is really true
12:34:35 <RichyB> luite, instead of writing a program to test it (I did, and I can confirm everything the manual says ^_^) I could have just read that.
12:35:20 <RichyB> osager, if you absolutely, positively cannot stand syntactic whitespace then you can use { ; } in Haskell and it'll work.
12:36:05 <RichyB> It's less pretty, which illustrates the whole reason why Haskell has syntactic whitespace in the first place.
12:36:19 <osager> wow it helps
12:36:26 <osager> thanks for the hint richyB
12:37:49 <cmccann> ugh, braces and semicolons are horrible :[
12:38:11 <hpc> cmccann: hardly; semicolons make nice separators for related thoughts
12:38:20 <cmccann> I do occasionally miss more pleasantly minimal syntax though
12:38:21 <cmccann> like scheme
12:39:03 <`Jake`> Still, you don't really need braces to group your thoughts.
12:39:31 <hpc> `Jake`: don't you go ruining my linguistics puns :P
12:40:11 <`Jake`> Well, I'll agree; semicolons are useful ;-)
12:40:17 <c_wraith> the thing that seems silly to me is that good style usually means using whitespace anyway..  At which point the {;} mess is just potentially-lying noise.
12:40:29 <osager> is it possible to create an editor that indents automatically ?
12:40:35 <hpc> osager: yes
12:40:40 <Botje> osager: mine does.
12:40:56 <`Zerax`> You can configure Notepad++ to automatically insert spaces, the option is just hard to find.
12:41:02 <cmccann> doesn't every code editor preserve indentation automatically?
12:41:10 <cmccann> so all you have to do is add extra indents
12:41:26 <osager> i mean indent a code that's been badly indented
12:41:32 <osager> as a whole
12:41:32 <hpc> for all its incredible bloat, eclipse's autoformat tool is great
12:41:36 <mauke> not ina whitespace sensitive language
12:41:43 <osager> yes something like that
12:41:46 <osager> autoformat
12:41:46 <Guest45444> i just finished tryhaskell, should i read "Real World Haskell" or "Learn You a Haskell for Great Good" next?
12:41:48 <c_wraith> as I recall, haskell only has {;} because it was expected to aid in creating generated code
12:41:56 <Guest45444> *which one should i read
12:42:00 <cmccann> Guest45444, LYAH is better for newcomers I think
12:42:07 <hpc> c_wraith: indeed
12:42:14 <Guest45444> cool thanks
12:42:21 <Saizan> c_wraith: and write one-lines for lambdabot!
12:42:35 <c_wraith> Saizan: of course.  That's the only real reason for it. :)
12:42:37 <cmccann> c_wraith, isn't layout defined in terms of translation to ugly mode?
12:42:48 <c_wraith> cmccann: yes, but it needn't be
12:42:56 <Saizan> though i sometimes use ; to avoid some newlines in normal code too
12:42:58 <cmccann> right, just saying
12:43:13 <osager> can haskell guru use haskel as a mathematica replacement ?
12:43:41 <osager> the famous Mr. Don works in financial world with haskell
12:43:45 <c_wraith> it's not a particularly good mathematica replacement. Though..
12:43:50 <osager> how does he have enough math tools ?
12:43:55 <hpc> osager: i think you would find replacing mathematica's libraries to be difficult
12:44:01 <c_wraith> > deriv (x ^ 2) x
12:44:02 <lambdabot>   Couldn't match expected type `Data.Number.Dif.Dif a
12:44:02 <lambdabot>                        ...
12:44:17 <Saizan> building them is his job, i guess
12:44:21 <raichoo> hmmm PolyKinds don't seem to work here with ghc 7.4.1 :(
12:44:21 <c_wraith> hmm, I've totally forgotten the signature for that
12:44:33 <hpc> > deriv (x ** 2) x :: Expr
12:44:34 <lambdabot>   Couldn't match expected type `Data.Number.Dif.Dif a
12:44:34 <lambdabot>                        ...
12:44:46 <hpc> @hoogle diff
12:44:47 <lambdabot> package Diff
12:44:47 <lambdabot> Data.Time.Clock.TAI diffAbsoluteTime :: AbsoluteTime -> AbsoluteTime -> DiffTime
12:44:47 <lambdabot> package diffarray
12:44:50 <hpc> hmm
12:44:55 <hpc> :t deriv
12:44:56 <lambdabot> forall a b. (Num a, Num b) => (Dif a -> Dif b) -> a -> b
12:45:12 <hpc> > deriv (** 2) x :: Expr
12:45:12 <lambdabot>   1 * recip x * 2 * exp (log x * 2)
12:45:20 <c_wraith> oh
12:45:35 <osager> can haskell guru read haskell code as they read english ?
12:45:37 <c_wraith> also, don't use **
12:45:47 <c_wraith> because it results in exp log expressions :)
12:45:58 <c_wraith> > derive (^2) x :: Expr
12:45:59 <lambdabot>   Not in scope: `derive'
12:46:01 <raichoo> Ah. it needs datakinds :D
12:46:03 <hpc> > deriv (^ 2) x :: Expr
12:46:04 <lambdabot>   1 * x + x * 1
12:46:11 <c_wraith> I can't spell :(
12:46:30 <hpc> the hard part is simplifying the expression down to "2 * x"
12:50:26 <olsner> oh, it ends up doing the chain rule on x*x?
12:51:48 <hpc> i think it's using the more general rule for f(x)**g(x)
12:54:32 <pkeene> can any of the more experienced Haskellers here talk a little bit about things that substantially increased your proficiency in Haskell? I've spent a decent amount of time reading Learn you a Haskell and Real World Haskell, but I've found that a lot of it hasn't really stuck with me (especially after taking a break from Haskell for a while)
12:54:58 <burp_> write code yourself
12:55:05 <burp_> just reading won't help
12:55:16 <burp_> (as always ;)
12:55:45 <pkeene> haha very true. I started working through some PE problems, but stopped for some reason. Might be time to resume or find a new project
12:55:56 <mike-burns> Oh I was just about to say what burp_ did.
12:55:56 <hpc> pkeene: new project, definitely
12:56:02 <burp_> PE?
12:56:06 <pkeene> Project Euler
12:56:09 <burp_> that is not good
12:56:11 <hpc> PE gets you started, but beyond problem 10 or so it's just number theory
12:56:21 <burp_> it does not make your learn real world haskell
12:56:32 <burp_> you want some larger real world project
12:56:37 <mike-burns> Yeah, go write code. Get dirty. Make mistakes.
12:56:40 <cmccann> pkeene, I found that answering questions on Stack Overflow helped cement my understanding of many things
12:56:59 <RichyB> cmccann, I'm in about three times as many freenode channels as I should be for exactly that reason.
12:57:04 <hpc> pkeene: find something you do frequently and automate it in haskell
12:57:26 <cmccann> do I'd add "teaching others" to "doing stuff" as a good approach
12:57:27 <pkeene> hpc: that's a good idea
12:57:35 <burp_> I have written an irc bot in haskell to learn it ;) think of something that interests you
12:58:08 <hpc> i did too
12:58:17 <Clint> i did too
12:58:19 <hpc> if you can think of the right combination of commands to implement you will learn way fast
12:58:22 <pkeene> burp_, initially I was considering writing a web app with Snap or Yesod, but I think that might have been a tad overambitious considering my relative inexperience with web apps
12:58:48 <hpc> pkeene: you can do web stuff easily with CGI
12:59:14 <hpc> it's a bit more extraneous setting-up steps, but conceptually it's all just env, stdin, and stdou
12:59:17 <hpc> t
13:00:20 <osager> i think topcoder problems are better than PE
13:00:21 <pkeene> hpc, yea
13:00:23 <osager> problems
13:00:34 <osager> plus there are answers
13:00:51 <cmccann> topcoder stuff tends to be pretty artificial as well
13:01:00 <cmccann> in different ways than project euler, but still
13:01:19 <osager> but it touchs way more domains
13:01:26 <cmccann> not really that much
13:01:42 <cmccann> doing something vaguely practical is better
13:01:52 <cmccann> something like an IRC bot at least interacts with the outside world
13:02:07 <osager> at least haskell can be used to solve purely algorithmic problems such as topcoder
13:02:48 <Guest45444> woah woah what i'd miss, i'm reading real world haskell right now
13:03:06 * cmccann thinks Haskell is better suited to practical stuff than to artificially-constructed algorithmic stuff
13:03:24 <cmccann> leave the silly benchmarks and algorithmic wanking to C :P
13:03:46 <osager> the irony is that there are not a lot of real practial stuff for a language that's been existing for over a decade
13:03:58 <Guest45444> can you make games in haskell?
13:04:02 <otters> certainly
13:04:08 <otters> you can make anything in haskell
13:04:23 <RichyB> otters, counterexample: love.
13:04:28 <cmccann> Guest45444, yes, but it can be awkward because you have to work with bindings to various libraries with non-Haskell-ish APIs
13:04:32 <RichyB> (but you CAN make war in Haskell)
13:04:34 <c_wraith> Several people in here work for a company that's making an iPhone game in haskell.
13:04:37 <otters> love doesn't exist
13:04:53 <c_wraith> @faq Can I make a unicorn with haskell?
13:04:53 <lambdabot> The answer is: Yes! Haskell can do that.
13:04:57 <Guest45444> love at first sight doesn't exist
13:04:58 <RichyB> otters, you sound like make.
13:05:04 <otters> indeed
13:05:20 <cmccann> osager, it's a niche language, that's not really surprising
13:05:33 * hackagebot ety 0.1 - Random etymology online entry.  http://hackage.haskell.org/package/ety-0.1 (ChrisDone)
13:05:54 <RichyB> Love at weak head normal form might exist, but the program failed to terminate when we tried to evaluate it.
13:05:56 <cmccann> just because Haskell is more practical for many tasks than something like C++ or Java doesn't mean everyone is going to drop everything and switch to the better tool overnight
13:06:03 <cmccann> RichyB, hahaha
13:06:58 <Guest45444> :( is that some haskell insider joke?
13:07:06 <pkeene> question on side projects: what do you guys think about cloning existing stuff vs trying to think up something cool and original?
13:07:06 <otters> yes
13:08:07 <hpc> pkeene: they build different skillsets
13:09:10 <mike-burns> Yeah I love those ideas. Do they both.
13:09:12 <mike-burns> them
13:09:34 <Guest45444> pkeene: I'm a blacksmith, and I like two things. Making skillsets, and filling them with liquid Pong clones
13:10:33 <hpc> a nice middle ground might be to clone part of something, then try and add new stuff you wish it did
13:10:58 <rostayob> I end up inventing something of my own every time I "clone" something
13:11:14 <pkeene> that's a cool idea. a customized clone
13:11:52 <hpc> rostayob: i tried to do something new when i wrote my website, and ended up cloning blaze-html with fewer inline functions
13:12:07 <osager> if one puts some let expressions outside any functions, are they global ? meaning all functions can access them ?
13:12:20 <rostayob> hpc: difference lists++
13:12:28 <mike-burns> osager: Try it.
13:12:35 <rostayob> my and my friends routinely re-discover them and we're so excited for half an hour
13:13:09 <osager> good advice :p
13:13:38 <hpc> rostayob: it's really "difference monoids"
13:14:07 <hpc> @src Endo
13:14:07 <lambdabot> Source not found. Sorry.
13:14:46 <hpc> which is really just Endo -- http://hackage.haskell.org/packages/archive/base/latest/doc/html/Data-Monoid.html#v:Endo
13:14:52 <osager> how do you do permutations of three : a b c, a c b, b a c ...
13:15:08 <rostayob> hpc: well, ok :)
13:15:12 <hpc> :P
13:15:12 <c_wraith> with permutations, of course.
13:15:19 <c_wraith> > permutations [1,2,3]
13:15:20 <lambdabot>   [[1,2,3],[2,1,3],[3,2,1],[2,3,1],[3,1,2],[1,3,2]]
13:15:21 <osager> is there any one lnes ?
13:15:24 <hpc> @src permutations
13:15:25 <lambdabot> Source not found. Sorry.
13:15:31 <osager> wow there's such a function
13:15:36 <c_wraith> the source for permutations is frightening.
13:15:40 <rostayob> osager: yes. it's amazing.
13:15:47 <c_wraith> (it's designed to work on infinite lists)
13:15:52 <hpc> > filterM [True, False] [1,2,3]
13:15:53 <lambdabot>   Couldn't match expected type `a -> m GHC.Bool.Bool'
13:15:53 <lambdabot>         against inferre...
13:16:04 <hpc> > filterM (const [True, False]) [1,2,3]
13:16:05 <lambdabot>   [[1,2,3],[1,2],[1,3],[1],[2,3],[2],[3],[]]
13:16:07 <c_wraith> hpc: that's subsets
13:16:10 <hpc> oh
13:16:13 <hpc> derp
13:17:26 <aristid> > nub . concatMap permutations . filterM (const [True,False]) $ [1,2,3]
13:17:27 <lambdabot>   [[1,2,3],[2,1,3],[3,2,1],[2,3,1],[3,1,2],[1,3,2],[1,2],[2,1],[1,3],[3,1],[1...
13:17:40 <aristid> > length . nub . concatMap permutations . filterM (const [True,False]) $ [1,2,3]
13:17:42 <lambdabot>   16
13:18:14 <magicman> > map (take 10) $ permutations [1..]
13:18:15 <shachaf> Hmm, working on infinite lists is an interesting constraint for permutations.
13:18:15 <lambdabot>   [[1,2,3,4,5,6,7,8,9,10],[2,1,3,4,5,6,7,8,9,10],[3,2,1,4,5,6,7,8,9,10],[2,3,...
13:18:34 <magicman> This is me not believing it, and me being amazed that it actually works :p
13:19:36 <krakrjak> > length $ permutations [1..]
13:19:39 <lambdabot>   mueval-core: Time limit exceeded
13:19:49 <krakrjak> just checking....
13:20:16 <hpc> > map (take 2) $ permutations [1..]
13:20:17 <lambdabot>   [[1,2],[2,1],[3,2],[2,3],[3,1],[1,3],[4,3],[3,4],[3,2],[4,2],[2,4],[2,3],[4...
13:21:02 <mauke> > 0x0 +2
13:21:03 <lambdabot>   2
13:21:06 <mauke> just making sure
13:21:15 <hpc> > 0x
13:21:16 <lambdabot>   0
13:21:22 <hpc> > 0x+2
13:21:23 <lambdabot>   2
13:21:29 <mauke> double devious!
13:21:34 <mauke> lambdabot++  # truly evil
13:21:44 <Veinor> 0x0 is a bunny
13:22:08 <hpc> > 0xsqrt(5)
13:22:08 <mauke> > 0x (+) 2
13:22:09 <lambdabot>   Not in scope: `xsqrt'
13:22:09 <lambdabot>   0
13:22:11 <hpc> pah
13:22:31 <hpc> mauke: wait, that might not work...
13:22:32 <hpc> > 0 x
13:22:33 <lambdabot>   0
13:22:42 <hpc> num instances :P
13:22:43 <krakrjak> > 0x `+` 2
13:22:44 <lambdabot>   <no location info>: parse error on input `+'
13:23:09 <hpc> > 0 x 0
13:23:10 <lambdabot>   0
13:23:14 <otters> > 0 x 1
13:23:15 <lambdabot>   0
13:23:16 <otters> :t x
13:23:17 <lambdabot> Expr
13:23:22 <krakrjak> > (+) 0x 2
13:23:22 <otters> @src x
13:23:22 <lambdabot> Source not found. Take a stress pill and think things over.
13:23:23 <lambdabot>   Couldn't match expected type `t1 -> t'
13:23:23 <lambdabot>         against inferred type `Simpl...
13:23:31 <hpc> x = var "x"
13:23:32 <hpc> :t var
13:23:33 <lambdabot> forall a. String -> Sym a
13:23:39 <hpc> er, something like that
13:23:51 <magicman> :t SimpleReflect.Expr.var
13:23:52 <lambdabot> Couldn't find qualified module.
13:23:57 <magicman> :t SimpleReflect.var
13:23:58 <lambdabot> String -> Expr
13:24:07 <hpc> :t fun
13:24:08 <lambdabot> forall a. (SimpleReflect.FromExpr a) => String -> a
13:24:32 <hpc> polymorphic for varargs
13:24:34 <otters> so haskell is fun
13:24:35 <hpc> > f x 0
13:24:36 <lambdabot>   Ambiguous type variable `a' in the constraints:
13:24:36 <lambdabot>    `SimpleReflect.FromExpr ...
13:25:06 <hpc> otters: type error; haskell is isomorphic to fun
13:25:11 <hpc> :P
13:25:19 <otters> ho ho
13:27:14 <kqr> so i'm looking at the documentation for GLUT, and i'm really curious about what a "Position" is, but it seems to link to a local path on some OS X
13:27:17 <kqr> http://lambda.haskell.org/platform/doc/2011.4.0.0/packages/GLUT-2.1.2.1/doc/html/Graphics-UI-GLUT-Callbacks-Window.html#g:5
13:27:23 <kqr> for example down at "KeyboardMouseCallback"
13:27:39 <kqr> does anyone know how i can figure out what a Position is?
13:27:50 <hpc> @hoogle Position
13:27:50 <lambdabot> Graphics.Rendering.OpenGL.GL.CoordTrans Position :: GLint -> GLint -> Position
13:27:51 <lambdabot> Graphics.Rendering.OpenGL.GL.CoordTrans data Position
13:27:51 <lambdabot> Graphics.Rendering.OpenGL.GL.Colors position :: Light -> StateVar (Vertex4 GLfloat)
13:28:10 <hpc> data Position = Position GLint GLint -- my guess
13:28:19 <hpc> click the source button in docs
13:28:38 <kqr> oh
13:28:39 <kqr> wow
13:28:40 <kqr> thanks
13:29:09 <hpc> pretty much everything has links, so if a type confuses you you can just click on it
13:29:12 <hpc> :P
13:29:23 <mauke> <kqr> so i'm looking at the documentation for GLUT, and i'm really curious about what a "Position" is, but it seems to link to a local path on some OS X
13:29:23 <kqr> yeah, but this link is wrong
13:29:27 <hpc> ah
13:29:55 <hpc> oh, that last part didn't parse right in my head and was silently dropped
13:30:10 <hpc> ive reported the bug, but evolution hasn't marked it assigned yet
13:33:03 <geekosaur> that appears to want Graphics.Rendering.OpenGL.GL.CoordTrans module from the OpenGL-2.2.3.0 package, might be able to find it on hackage
13:38:19 <nyingen> 1
13:38:42 <kqr> 2
13:39:11 <elliott> 3
13:39:11 <lambdabot> elliott: You have 2 new messages. '/msg lambdabot @messages' to read them.
13:39:14 <elliott> *sigh*
13:39:17 <elliott> lambdabot ruins everything.
13:39:33 <shachaf> elliott: If only someone had sent you two more messages!
13:41:28 <kqr> 1
13:41:57 <elliott> 0
13:42:41 <nyingen> heh
13:43:00 <erus`> are there any famous programmers who are quite good looking?
13:43:01 <nyingen> I was trying to switch virtual screens in 'screen', but missed the ctrl-a
13:44:30 <erus`> programming fame is the opposite of hollywood fame
13:45:08 <Urchin> Grace Hopper used to be good looking
13:45:36 <Urchin> (that was over half of century ago, so...)
13:45:52 <kqr> how about leah culver?
13:46:29 <erus`> ada was quite hot
13:46:38 <erus`> but she never compiled her code
13:46:43 <cmccann> heh
13:46:48 <nyingen> why are we only discussing female programmers?
13:47:01 <erus`> because the guys have beards
13:47:06 <nyingen> since most programmers are men, I assumed you wanted to know about sharp-looking guys
13:47:18 <erus`> or look like bjarne stroustrup
13:47:41 <otters> dennis ritchie was hot stuff
13:48:00 <cmccann> http://en.wikipedia.org/wiki/File:Simon_Peyton_Jones_01.jpg
13:48:03 <cmccann> heheheh
13:48:09 <nyingen> Maybe you should set up an "am i hot or not"-type site, populate it with pictures of famous programmers, and see what happens
13:48:14 <kqr> nyingen, i very rarely get the feeling that "oh man, that guy was good looking"
13:48:16 <mandaya> hahaha
13:48:19 <RichyB> What do you mean "was"
13:48:23 <kqr> nyingen, none of the times has been about a male programmer ;)
13:48:24 <mandaya> cmccann: nice
13:48:29 <RichyB> WAIT pretend I didn't type that.
13:48:37 <erus`>  ibet there are some good looking ruby programmers
13:48:39 * RichyB was thinking of someone else.
13:48:43 <erus`> they are god damn rock stars
13:48:53 <elliott> cmccann: I like to think that was just meant to be a photo of the wall, but after they took it the ghostly, blurry apparition of SPJ appeared in the file
13:49:01 <cmccann> heh
13:49:08 <elliott> it's only logical
13:49:18 <Urchin> there was a bit of research about famous programmers, among hundreds of men, there are 5 or 7 women (depending on how you count them)
13:49:57 <kqr> Urchin, surprisingly many females, unless they were considered famous to a large extent because of their sex
13:50:43 <Urchin> that 5 or 7 comes from transsexuals
13:50:46 <nyingen> How about the inventor of ruby on rails? He looks pretty sharp, generally
13:50:55 <nyingen> Maybe he would win the contest
13:50:56 <mandaya> kqr: not really, female programmers aren't *that* rare
13:51:07 <elliott> this belongs in -blah
13:51:11 <cmccann> nyingen, this guy? http://blog.wekeroad.com/wp-content/uploads/2007/10/dhh-fu-thumb.jpg
13:51:35 * otters has never personally met a Ruby programmer that called himself a "rockstar"
13:51:42 <nyingen> cmccan: yeah, I hear he's kind of a jerk
13:52:00 <`Jake`> http://en.wikipedia.org/wiki/Women_in_computing
13:52:09 <tgeeky_> I have a friend who put "rockstar programmer" in his resume.
13:52:09 <erus`> stupid ruby has everything
13:52:11 <Urchin> that ruby guy looks like an asshole
13:52:41 <Urchin> I hear that there's a ruby developers speed dating convention
13:52:42 <kqr> mandaya, perhaps not, but i've never heard about a famous female programmer
13:52:46 <erus`> most of you guys have long hair, at least the ones who goto haskell meets
13:52:55 <tgeeky_> Ada Lovelace?
13:53:12 <kqr> mandaya, and that's no sexist bullshit about them not being able to become good at it, it's just a casual observation
13:53:15 <startling> kqr: grace hopper?
13:53:20 <kqr> startling, never heard of
13:53:25 <startling> kqr: first compiler
13:53:34 <kqr> oh
13:53:38 <nyingen> How about Catherine de Medici? She did a lot of "programming" in the political sense
13:53:41 <kqr> i've missed something
13:53:45 <c_wraith> kqr: Ada Lovelace?
13:53:48 <mandaya> kqr: check the wikipedia link, there's a list of award winners who were female
13:54:05 <tgeeky_> nyingen: that's... a stretch
13:54:11 <tgeeky_> c_wraith: repost
13:54:11 <startling> kqr: also came up with the usage of "bug"
13:54:38 <kqr> c_wraith, i've heard of her, but i didn't think she did as much as something that could be called programming
13:54:43 <kqr> c_wraith, i guess i stand corrected
13:54:47 <kqr> startling, yeah, i read that
13:54:59 <tgeeky_> kqr: yeah, when I mentioned Ada, I had the same reservartion
13:55:30 <c_wraith> grace hopper is by far the most famous, though.  mostly because she had such a *huge* impact on the whole system.  She didn't just create the first compiler, she's responsible for the entire concept of a high-level language
13:56:10 <mandaya> c_wraith: I'm not sure I'd go quite that far, the lambda calculus and LISP had a bit to do with that too
13:56:44 <kqr> mandaya, depends on where you draw the line for what to call high-level
13:56:46 <`Jake`> http://www.quora.com/Why-are-there-not-more-female-programmers
13:56:47 <c_wraith> lambda calculus is no more high-level than assembly.
13:56:54 <Urchin> RDML Grace Hopper designed COBOL
13:57:04 <c_wraith> LISP is way more than just lambda calculus, of course
13:57:39 <nyingen> like Haskell is more than TLC
13:57:52 <erus`> yeah its polymorphic typed
13:58:22 <mjrosenb> with datatypes, and pattern mathcing
13:58:23 <mandaya> c_wraith: agreed, but I'd argue without those two things, we wouldn't be very far from machine code still
13:58:26 <tgeeky_> I think we should give credit to all the family members (female or not) of all these programmers and engineers who made this stuff possible
13:58:30 <mjrosenb> and typeclasses
13:58:31 <tgeeky_> certainly they should count quite a bit
13:58:35 <startling> kqr: but anyway, ada lovelace struck on the idea of recursion before there were programming languages
13:58:49 <otters> but then again it's not a programming concept
13:58:55 <mandaya> kqr: I meant as a catalyst for the development of high level languages
13:59:00 <kqr> otters, yeah exactly
13:59:07 <kqr> mandaya, sure
14:04:45 <dzhus> Should I specify -O2 in ghc-options: of .cabal file?
14:05:26 <hpc> dzhus: it shouldn't break anything
14:07:01 <dcoutts> dzhus: usually not needed, -O is the default
14:07:46 <dcoutts> do it if you've measured that it makes an important performance difference for that package
14:25:26 <tgeeky_> even though I'm an amateur Haskeller, I would put -O2 in there unless you feel it takes too long to compile
14:25:33 * hackagebot charset 0.3 - Fast unicode character sets based on complemented PATRICIA tries  http://hackage.haskell.org/package/charset-0.3 (EdwardKmett)
14:25:35 * hackagebot snaplet-redis 0.1 - Redis support for Snap Framework  http://hackage.haskell.org/package/snaplet-redis-0.1 (DmitryDzhus)
14:25:48 <randomclown> is there a way to run a list comprehension backwards?
14:25:57 <randomclown> I want to prepend a lot of stuff to a list
14:26:08 <tgeeky_> randomclown: monad comprehensions on something that has a snoc
14:26:12 <tgeeky_> like a DList
14:26:22 <randomclown> something pure perhaps?
14:26:39 <tgeeky_> well, I should have said 'generalized list comprehensions'
14:26:44 <tgeeky_> I think you can still do it purely
14:27:06 <ozgura> randomclown: sorry, what did you think wasn't pure?
14:27:22 <randomclown> monad comprehensions didnt sound pure
14:27:39 <randomclown> I think I'll just foldr
14:27:48 <ozgura> they are as pure as list comprehensions
14:28:03 <randomclown> I'll look them up
14:28:15 <ozgura> "monad" doesn't necessarily mean impure
14:28:18 <tgeeky_> randomclown: you'll need the MonadComprehensions extension, I think
14:28:54 <tgeeky_> randomclown: certainly you do not need IO
14:30:52 <tgeeky_> randomclown: http://www.haskell.org/ghc/docs/7.2.1/html/users_guide/syntax-extns.html monad comprehensions (and their desugaring) is specified there
14:34:06 <augur> conal: have you seen http://vimeo.com/36579366
14:34:06 <augur> ?
14:34:20 * mgsloan loved that video
14:34:34 <augur> it reminded me immediately of conals TVs
14:35:27 <mgsloan> it's very similar to stuff I'm currently trying to do with Haskell.  I hadn't thought of the time slider, though, that's nifty
14:35:51 <augur> i saw a lot of it coming, like the time-as-space visualization
14:36:24 <mgsloan> yup, the slider-for-literal thing was the first thing I was going to do live manipulation wise
14:36:32 <augur> but i think thats just because i have a lot of the same motivations as this guy
14:36:40 <mgsloan> sofar I've been focusing on giving type information
14:36:56 <mgsloan> as that's the more uniquely Haskell problem - everything else is engineering
14:37:20 <mgsloan> "merely a matter of engineering", hah
14:37:25 <augur> well conal's got some sliders for your values :)
14:37:55 <mgsloan> so do I! :D https://github.com/mgsloan/gtk-toy-diagrams/blob/master/src/Graphics/UI/Gtk/Toy/Slider.hs
14:38:00 <mgsloan> but mine aren't as pretty
14:40:02 <elliott> mgsloan: I like how two of the fields are _-prefixed but one is suffixed :P
14:40:07 <mgsloan> my overall scheme is no where near as elegant as TVs.  Instead, portions of the code that the user wants to edit live will be replaced with "(unsafePerformIO $ readIORef someGlobal)"
14:40:39 <mgsloan> elliott - yeah, not the cleanest of code :P The reason for that is that I define the lens for sliderHandle elsewhere
14:42:00 <mgsloan> anyway, as long as I'm already talking about it, I might as well link to a more recent screenshot.. www.mgsloan.com/panopti2.png
14:42:13 <RichyB> elliott, makes perfect sense. _prefix is for things that aren't meant to be in the public API, postfix_ is for things that just happen to conflict with language keywords.
14:42:19 <mgsloan> The type diagrams are awfully arranged right now
14:42:27 <mgsloan> look at the bottom of the vertical stacks for the result types
14:42:29 <RichyB> elliott, that's the convention in use in the Python community.
14:42:45 <elliott> RichyB: that's not how they are being used there.
14:42:47 <mgsloan> and the constraint context isn't properly related to the diagram
14:42:51 <elliott> _prefix is for lenses
14:43:01 <RichyB> I would not recommend it in Haskell - in Haskell, there aren't so many keywords and I'd just keep things out of the exports list. :)
14:43:15 <shachaf> It makes some sense for lenses.
14:43:30 <shachaf> Does Python have significantly more keywords than Haskell?
14:43:32 <shachaf> @where keywords
14:43:32 <lambdabot> case class data default deriving do else foreign if import in infix infixl infixr instance let module newtype of then type where _
14:44:01 <MostAwesomeDude> There are 29 keywords in Python: http://docs.python.org/release/2.3.5/ref/keywords.html
14:44:16 <MostAwesomeDude> Actually, that's old. There's also "with", for a total of 30.
14:44:30 <mgsloan> anyway, that's a live evaluation context - it updates the results and type information as you type
14:44:37 <MostAwesomeDude> Compared to 23 in Haskell, there's more, but not that many more.
14:44:54 <mgsloan> when you break parseability, the type annotations stick around, as what they were most recently
14:45:01 <hpc> haskell also has a few non-keyword magic symbols, like (->), (::)
14:45:17 <MostAwesomeDude> And \ as well, right?
14:45:21 <mgsloan> (@), (#), (\)
14:45:27 <hpc> and [], (:)
14:45:29 <RichyB> MostAwesomeDude, there are relatively quite a lot of collisions in Python code.
14:45:29 <hpc> (~)
14:45:33 <hpc> (!)
14:45:34 <shachaf> Yes, there's an @where entry for them.
14:45:41 <hpc> @where symbols
14:45:41 <lambdabot> I know nothing about symbols.
14:45:49 <shachaf> Using parentheses around them is completely inappropriate, though.
14:45:50 <hpc> @where reserved
14:45:50 <lambdabot> I know nothing about reserved.
14:45:52 <hpc> hmm
14:46:04 <RichyB> Python code tends to do things like pass around first-class classes, which leads to people defining parameter names like "klass" and "class_".
14:46:13 <RichyB> Other things like that.
14:46:33 <RichyB> and some builtins (like "type") that you wouldn't want to override anyway in any context ever.
14:47:54 <b_jonas> uh, shouldn't that list contain "family"?
14:48:00 <b_jonas> the list for haskell I mean
14:48:14 <MostAwesomeDude> RichyB: What would you use as the keyword for defining a class? What would you call the object which is the type of types?
14:48:38 <b_jonas> MostAwesomeDude: it's called Class
14:48:39 <RichyB> MostAwesomeDude, "class" and "type", respectively.
14:48:48 <b_jonas> the latter that is
14:49:02 <RichyB> "type(type) == type" is a Python expression that evaluates to True. :)
14:49:02 <MostAwesomeDude> RichyB: Okay. So what's the problem with doing that in Python? :3
14:49:32 <RichyB> I didn't say there was a problem. Just that collisions occur just long enough that the Python community specifically thought to come up with a convention for it.
14:49:34 <acowley> have we turned to python to answer our type theory questions?
14:50:04 <RichyB> Yes, all types are now to be replaced with Dynamic.
14:50:12 <b_jonas> what's the class of all classes called in smalltalk?
14:50:14 <geekosaur> practical parsing questions, maybe.  they have at least as much experience with significant whitespace, too :)
14:50:14 <RichyB> All functions now have the type (Dynamic -> Dynamic)
14:50:30 <RichyB> which itself is referred to as (Dynamic)
14:51:09 <RichyB> acowley, solves most problems. You get the odd annoyance at runtime but what's a crash bug between friends, eh? ;)
14:52:44 <acowley> I suppose the axiom "type : Python" would simplify some things.
14:54:34 <mkscrg> Can someone explain to me what `mask` in Control.Exception.Base is doing?
14:54:53 <c_wraith> preventing asynchronous exceptions
14:55:06 <mkscrg> http://www.haskell.org/ghc/docs/7.4.1/html/libraries/base-4.5.0.0/src/Control-Exception-Base.html#mask
14:55:26 <mkscrg> c_wraith: can you elaborate on how it's doing that?
14:55:47 <c_wraith> mkscrg: how? how is a matter of runtime internals.  Or do you mean how the signature works?
14:57:18 <c_wraith> The signature is complicated. How to use it really isn't.
14:57:29 <randomclown> do you extract value from a map
14:57:46 <mkscrg> i think i get the signature, and i see how it's used. i guess if the relevant runtime internals aren't incredibly complex i'd like to hear it
14:57:59 <dmwit> randomclown: Yes, maps are rank high in my utility function.
14:58:04 <dmwit> s/are//
14:58:21 <dmwit> Less snarky response: I didn't understand your question, could you try again but with more words?
14:58:34 <c_wraith> mkscrg: Well, async exceptions are exceptions that come from other threads, and as such, are relatively uncommon.
14:58:49 <mkscrg> c_wraith: i have some FFI code that runs fine under `bracket` (i.e. no exceptions) but raises an exception without it
14:59:19 <randomclown> I have a fromList [(1,2)]
14:59:21 <dmwit> bracket catches exceptions...
14:59:24 <randomclown> how do I get the 2 out
14:59:29 <c_wraith> mkscrg: I don't know a whole lot about this. I've looked at the relevant RTS code a couple times.
14:59:37 <dmwit> randomclown: Data.Map.lookup
14:59:51 <randomclown> it returns another map...
14:59:59 <dmwit> lookup returns a Maybe, not a Map.
15:00:04 <dmwit> :t M.lookup
15:00:05 <lambdabot> forall k a. (Ord k) => k -> M.Map k a -> Maybe a
15:00:21 <c_wraith> mkscrg: in general, there's a queue(? maybe just a single-element queue) that stores outstanding async exceptions for each thread
15:00:27 <dmwit> Use pattern matching or other functions from Data.Maybe to inspect the result.
15:00:45 <mkscrg> c_wraith: fair enough. what happens if an exception is raised by another thread (say via FFI) within mask?
15:00:50 <c_wraith> mkscrg: usually, that queue is checked on allocations.  IIRC.  (this is all sort of hand-wavey)
15:00:59 <randomclown> hmm I was confused for a bit
15:01:25 <c_wraith> mkscrg: inside of mask, it just skips that check.  the exceptions stay in the queue, and can be raised at some future time
15:02:11 <c_wraith> mkscrg: that's my rough understanding based on a short time spent looking at that code in the RTS several months ago. :)
15:02:34 <mkscrg> c_wraith: gotcha. thanks! debugging other people's FFI code can be a real treat… :P
15:15:34 * hackagebot sock2stream 0.3 - Tunnel a socket over a single datastream (stdin/stdout)  http://hackage.haskell.org/package/sock2stream-0.3 (StephenWeber)
15:32:36 <hpaste> “Deepak Jois” pasted “Arrows” at http://hpaste.org/63770
15:34:09 <vyom> Is there a cleaner way to write this: http://hpaste.org/63770 Basically I have a record that contains a map of local and global vars and I am trying to lookup a value in either of them
15:34:55 <c_wraith> vyom: you could use <|>
15:35:13 <c_wraith> > Just 5 <|> Just 3
15:35:14 <lambdabot>   Just 5
15:35:19 <c_wraith> > Nothing <|> Just 3
15:35:20 <lambdabot>   Just 3
15:37:20 <eyebloom> Hi, is there anyone on interested in talking about HOpenGL?
15:37:56 <vyom> > Nothing <|> Nothing <|> error "cannot find"
15:37:57 <lambdabot>   *Exception: cannot find
15:38:58 <vyom> > Nothing <|> Just 5 <|> error "cannot find"
15:38:59 <lambdabot>   Just 5
15:40:06 <lispy> eyebloom: probably more people in #haskell-game, but what's up?
15:40:15 <lispy> eyebloom: I'm the current maintainer
15:40:26 <eyebloom> Ah thanks.
15:41:08 <eyebloom> I'm just finding that it's very difficult to include text in 2D drawings and I'm curious what the options are.
15:41:10 <cmccann> lispy, HOpenGL seems like an awfully elaborate library for something that draws black rectangles, why is that? :P
15:41:28 <lispy> ?slap cmccann
15:41:29 <lambdabot> *SMACK*, *SLAM*, take that cmccann!
15:41:33 <lispy> :)
15:41:39 <cmccann> eyebloom, there's a package with FFI bindings to a library for that
15:41:50 <cmccann> it has five different ways or so
15:42:09 <lispy> eyebloom: Well, the main way I know of is to draw the glyphs into a buffer and then use that buffer on quads as a texture
15:42:09 <eyebloom> What's it called?
15:42:19 <cmccann> eyebloom, I forget, sorry
15:42:30 <cmccann> I'll look in a minute if you want
15:42:33 <lispy> I have a binding on hackage to freetype2, but that really just parses the font files
15:42:48 <lispy> To use it with opengl you need some other code I haven't written yet
15:43:12 <eyebloom> I see.
15:43:14 <cmccann> but it lets you either draw directly post-rasterization, render the font to a texture, generate a flat shape, create extruded polygon text, or a few other things
15:43:41 <lispy> cmccann: oh, I think I know what you're talking about... what is that called
15:43:46 <RichyB> lispy, {-# LANGUAGE ClosedTimelikeCurveImport #-}
15:43:51 <cmccann> FTGL
15:44:12 <alpounet> eyebloom, i have some code for 3D text rendering, so maybe you can adapt it? it uses fgl
15:44:15 <cmccann> that's the name of both the package and the foreign lib I think
15:44:36 <alpounet> oh yeah ftgl sorry
15:44:38 <cmccann> http://hackage.haskell.org/package/FTGL
15:44:54 <alpounet> i have written a simple program rotating some text
15:45:02 <cmccann> I've used that library before, it works well in my experience
15:45:11 <cmccann> you have to do all the positioning yourself though
15:45:16 <cmccann> through the usual gl nonsense
15:45:19 * lispy hopes to get his freetype2 binding to a point where it provides glPrintf
15:45:31 <eyebloom> cmccann: Ok thanks, I've been googling and hadn't found this.
15:46:00 <cmccann> eyebloom, no prob
15:46:01 <eyebloom> I'll hack away at that and see if I can make it work.
15:46:08 <cmccann> I wish there was something more Haskell-y
15:46:21 <cmccann> but for an FFI binding with IO everywhere that one isn't bad
15:46:27 <cmccann> unlike openGL which is horrific as always
15:46:30 <cmccann> ;]
15:47:15 <Veinor> what's the difference between mvar and tvar?
15:47:28 <monochrom> the difference between IO and STM
15:47:28 <lambdabot> monochrom: You have 1 new message. '/msg lambdabot @messages' to read it.
15:47:28 <mauke> Veinor: what do they have in common?
15:47:36 <Veinor> in particular
15:47:43 <Veinor> i need to store some global state across threads
15:47:44 <mauke> "well, they're both mutable variables, except MVar"
15:48:12 <Veinor> it looks like i want tvar, since mvar empties on read
15:48:16 <monochrom> I agree, they actually have little in common to begin with
15:48:37 <cmccann> MVar and TMVar are more comparable
15:48:42 <cmccann> TVar is more like an IORef
15:48:57 <cmccann> if you squint a little
15:49:09 <eyebloom> The main thing I've found difficult so far is there are a few function in HOpenGL that require you do IO to get a query that could otherwise be pure. Like the width of text in stringWidth ::  a -> String -> IO GLint.
15:49:51 <cmccann> yes
15:49:59 <eyebloom> I understand why, but it makes you wish for a graphics library written from scratch in Haskell.
15:50:02 <cmccann> SDL has some crap like that as well
15:50:05 <cmccann> and it does
15:50:07 <cmccann> :T
15:51:03 <monochrom> MVar is a 1-place message queue. I think M stands for message, in fact.
15:51:49 <monochrom> you can always invoke unsafePerformIO
15:52:17 <cmccann> monochrom, what, for these should-be-pure foreign functions?
15:52:28 <shachaf> "a -> String -> IO GLint"?
15:52:32 <shachaf> That's a weird type.
15:52:54 <monochrom> yes
15:52:54 <c_wraith> Seems like that first arg is useless
15:53:04 <cmccann> frankly I don't trust many of these foreign functions to actually be pure
15:53:13 <cmccann> and not come back to bite me somehow
15:53:46 <shachaf> By the way, did you know you can unsafePerformIO by e.g. foreign export foo :: Int -> IO Int; foreign import foo :: Int -> Int?
15:53:57 <shachaf> (With the syntax corrected, of course.)
15:54:50 <magicman> c_wraith: stringWidth is a method of the Font class, so its type is actually Font a => a -> String -> IO GLint.
15:54:50 <ddarius> shachaf: That's a non-sequitur.
15:55:01 <shachaf> ddarius: Indeed.
15:55:02 <cmccann> if they're very simple I'd rather just reimplement them, and if they're nontrivial enough that I can't do that I don't trust them to be well-behaved either
15:55:02 <c_wraith> magicman: ok, that makes *far* more sense. :)
15:55:11 <ddarius> foreign import is already defined to use unsafePerformIO when you omit the IO in the return type.
15:55:19 <RichyB> shachaf, please remind me to some day work out what the difference between unsafePerformIO and inlinePerformIO is.
15:55:25 <shachaf> Oh. Is that the definition?
15:55:26 <kqr> why can't i do a 'let dices = getStdGen >>= randomRs (1, 6)'? what am i misunderstanding about the io monad?
15:55:38 <shachaf> RichyB: Inlining, presumably.
15:55:45 <shachaf> RichyB: Don't forget about unsafeDupablePerformIO.
15:55:54 <eyebloom> shachaf: a is an instance of the font typeclass
15:56:03 * cmccann ponders "unsaferPerformIO"
15:56:05 <monochrom> @hoogle inlinePerformIO
15:56:05 <c_wraith> kqr: You can do that, but the type you end up with is IO [Int] (or Integer, whatever)
15:56:06 <lambdabot> No results found
15:56:15 <rwbarton> @type randomRs
15:56:15 <c_wraith> monochrom: it's part of the Bytestring internals
15:56:15 <shachaf> Isn't inlinePerformIO just from ByteString?
15:56:16 <lambdabot> forall a g. (Random a, RandomGen g) => (a, a) -> g -> [a]
15:56:20 <RichyB> The Data.ByteString.Internal documentation makes it sound like inlinePerformIO is even less safe than unsafePerformIO.
15:56:35 <rwbarton> you want something like fmap (randomRs (1, 6)) getStdGen
15:56:45 <ddarius> RichyB: It is, albeit, you'd already have to be abusing unsafePerformIO for that to be true.
15:56:51 <rwbarton> also, you probably want newStdGen rather than getStdGen
15:56:52 <c_wraith> oh, right.  it would have to be fmap
15:56:59 <monochrom> I'm really curious as to why people ask all kind of "difference between apple and orange" questions
15:57:14 <ddarius> monochrom: What -is- the difference between apples and oranges?
15:57:16 <c_wraith> monochrom: well, both have type IO a -> a
15:57:22 <Veinor> cmccann: unsaferPerformIO: it only lets you do IO operations that are guaranteed to be side-effect-ful
15:57:44 <shachaf> unsafeDupablePerformIO (IO m) = lazy (case m realWorld# of (# _, r #) -> r)
15:57:54 <shachaf> inlinePerformIO (IO m) = case m realWorld# of (# _, r #) -> r
15:58:10 <shachaf> And the former has a NOINLINE annotation and the latter has an INLINE annotation.
15:58:11 <c_wraith> monochrom: further, both execute IO actions unsafely.  I mean.  The differences are more subtle than that.
15:59:12 <cmccann> ddarius, ah, but does a dog have the Buddha nature?
15:59:46 <mauke> what's the difference between a buddha dog and nature?
16:00:10 <c_wraith> What's the difference between IO?
16:00:39 <cmccann> mauke, 20 ounces of flax
16:00:39 <mauke> how do I extract IO from IO Int?
16:00:41 <magicman> > "a buddha dog" \\ "nature"
16:00:42 <lambdabot>   " bddha dog"
16:00:49 <monochrom> does unsafeDupableInlinePerformInterleaveIOCoerce have Budhha nature?
16:00:52 <c_wraith> mauke: typeOf1
16:01:06 <RichyB> ddarius, please elaborate? Say if I write: getDoubleBits dbl = unsafePerformIO (allocaBytes 8 (\ptr -> poke (12.0 :: Double) ptr >> peek (castPtr :: Ptr Double -> Ptr Word64)))
16:01:09 <c_wraith> > typeOf1 (undefined :: IO Int)
16:01:10 <lambdabot>   IO
16:01:17 <monochrom> haha
16:01:25 <cmccann> c_wraith, nice
16:01:38 <mauke> c_wraith: http://youtu.be/LrDY6Hyam54
16:01:38 <kqr> what's the opinion on '(f . g . h) x' as opposed to 'f $ g $ h x'?
16:01:44 <mauke> kqr: yes
16:01:46 <cmccann> kqr, yes
16:01:50 <kqr> why so?
16:01:57 <cmccann> expresses intent better
16:02:01 <RichyB> ddarius, that's a pure (slightly naughty but oh well) function that allocates memory internally. Does that suddenly break if I use inlinePerformIO?
16:02:01 <cmccann> easier to refactor
16:02:02 <mauke> maximizes extractable subexpressions
16:02:15 <kqr> sounds like good arguments
16:02:20 <rwbarton> whichever one expresses your intent better expresses your intent better
16:02:28 <monochrom> $ is too tall
16:02:34 <cmccann> kqr, note that "f . g . h $ x" is also fine
16:02:38 <mauke> $ is too expensive
16:03:03 <RichyB> ddarius, or is the "don't allocate memory inside a function wrapped in inlinePerformIO" warning actually trying to ward people off from doing insane things like malloc() inside?
16:03:09 <magicman> "f . g $ h x" is cool, too.
16:03:10 <cmccann> but as rwbarton says, expressing intent is the main thing, so if you're not really composing functions conceptually then maybe the second form is clearer
16:03:32 <magicman> (I usually do that when 'h' is something like fromList, toList, show, or whatever)
16:04:13 <ServerSaler> I am selling dedicated servers (VPS) in different countries Windows XP, 2003,2008, Seven, Cent OS, Fedora, Debian, Gentoo, Slackware, Ubuntu, Linux Mint, OpenSuse, FreeBSD, Arch Linux. Write only PM who need them.
16:04:18 <kqr> cmccann, what i'm doing is generating a stuff of data, applying a filter to it and then passing it on to the function meant to process it
16:04:20 <shachaf> @where ops
16:04:20 <lambdabot> shapr Cale glguy dons sjanssen dcoutts Saizan dibblego conal Philippa bos arjanb xerox Heffalump kosmikus wli Pseudonym Igloo quicksilver monochrom Lemmih jmcarthur copumpkin
16:04:30 <kqr> cmccann, it doesn't feel like composing functions to me
16:04:50 <kqr> cmccann, or the first part does, but there's no clever way to dot compose them that i can think of
16:05:00 <ddarius> RichyB: allocaBytes calls malloc.
16:05:09 <kqr> s/stuff/load/
16:05:42 <cmccann> kqr, yeah, I'd definitely compose filters if you have multiple
16:05:45 <cmccann> but otherwise shrug
16:05:59 <cmccann> also don't hesitate to use parentheses, $ isn't required either
16:06:10 <DanBurton> Hey guys. Suppose I have a ByteString which I know to be 64 bits (8 Word8s); is there a way to turn it into an Int64? And vice versa?
16:06:18 <cmccann> unsafeCoerce
16:06:20 <cmccann> :D
16:06:27 <DanBurton> they have the same representation?
16:06:32 <cmccann> beats me
16:06:35 <DanBurton> -_-
16:06:37 <cmccann> but you'll get something of the right type
16:06:39 <shachaf> cmccann: Might as well say "undefined"
16:06:46 <cmccann> shachaf, that's not as funny though
16:06:51 <shachaf> (It certainly won't work if you just unsafeCoerce the ByteString.)
16:06:53 <cmccann> also that won't cause segfaults
16:07:00 <DanBurton> lol
16:07:15 <cmccann> if I'm giving bad advice I want it to be thoroughly horrific
16:07:19 <shachaf> DanBurton: Data.Binary or Data.Get or whatever it's called.
16:07:43 <shachaf> Maybe it's Data.Binary.Get.
16:07:44 <RichyB> Ugh, that function should be getDoubleBits dbl = unsafePerformIO (allocaBytes 8 (\ptr -> poke ptr (dbl::Double) >> peek (castPtr ptr))) :: Word64
16:07:48 <shachaf> One of those things.
16:08:02 <RichyB> DanBurton, no very no they do not have the same representation.
16:09:02 <cmccann> using unsafeCoerce and relying on matching representation is not really a good idea anyway
16:09:03 <RichyB> DanBurton, runGet getWord64le bytestring
16:09:30 <RichyB> DanBurton, runGet and getWord64le are both defined in Data.Binary.Get, manual page is here: http://www.haskell.org/ghc/docs/latest/html/libraries/binary-0.5.1.0/Data-Binary-Get.html
16:09:45 <ddarius> cmccann: Psh.  And you call yourself a C programmer?
16:09:52 <cmccann> ddarius, no
16:10:24 <hpc> cmccann: good :P
16:10:51 <DanBurton> > runGet getWord64le $ pack "a"
16:10:52 <lambdabot>   Not in scope: `runGet'Not in scope: `getWord64le'
16:10:52 <RichyB> cmccann, I seem to remember reading that someone had implemented a dependently-typed language which compiled to Haskell, where the output code contained loads and loads of unsafeCoerce calls in places where the source language contained a proof of type equality but the target Haskell didn't. :)
16:11:07 <hpc> RichyB: agda
16:11:08 <RichyB> Might have been Cayenne or Adga or something.
16:11:12 * cmccann knows C well enough to accomplish many tasks but is not in any way a "C programmer" by any reasonable definition
16:11:12 <RichyB> hpc, ta. :)
16:11:27 <shachaf> RichyB: Hey, you're MyCatVerbs.
16:11:29 <ddarius> preflex: seen ezyang
16:11:30 <preflex>  ezyang was last seen on #ghc 17 days, 8 hours, 25 minutes and 52 seconds ago, saying: they should be pretty similar though
16:11:36 <RichyB> shachaf, yes.
16:12:02 <RichyB> shachaf, what gave me away? ;)
16:12:18 <shachaf> The name.
16:12:24 <hpc> preflex: seen MyCatVerbs
16:12:24 <preflex>  MyCatVerbs was last seen on #haskell-blah 225 days, 48 minutes and 42 seconds ago, saying: preflex: Debian maintainers are actually really nice people.
16:12:26 <RichyB> Good memory.
16:12:46 <RichyB> ...I can't remember why I would have said something like that.
16:12:55 <RichyB> I must have been less hateful back then than I am now.
16:13:30 <hpc> RichyB: now you know better ;)
16:13:47 <RichyB> Mostly I just have more hate.
16:13:53 * shachaf wonders why RichyB was talking to preflex.
16:13:55 <RichyB> I'm not sure if that counts as knowing better? Eh.
16:14:14 <RichyB> Mistook it for a person.
16:14:17 <mauke> preflex: quote-count * debian
16:14:25 <preflex>  * has 0 quotes containing "debian"
16:14:30 <mauke> preflex: quote-count * Debian
16:14:32 <preflex>  * has 1 quote containing "Debian"
16:14:32 <RichyB> It's case sensitive?
16:14:38 <mauke> preflex: quote * Debian
16:14:41 <preflex>  <jawnsy> fuck you Debian :(
16:14:41 <RichyB> preflex: quote-count * hate
16:14:43 <preflex>  * has 4 quotes containing "hate"
16:14:54 <shachaf> preflex: quote-count * preflex
16:14:56 <RichyB> Let us all bow down to the wisdom of jawnsy.
16:14:56 <preflex>  * has 1 quote containing "preflex"
16:15:15 <RichyB> shachaf, are you google-bombing the chatbot? :)
16:15:49 <mauke> preflex: quote-count * askell
16:15:51 <preflex>  * has 27 quotes containing "askell"
16:22:07 <zzo38> Is there a way to define a global variable which is only written once during the program and cannot be used before a value is written?
16:22:39 <hpc> zzo38: a constant?
16:23:11 <zzo38> hpc: Like that, but that will be set at runtime
16:23:55 <hpc> ReaderT, perhaps
16:24:20 <randomclown> how do you plot points wiht wolfram alpha...
16:24:42 <hpc> randomclown: see how mathematica does it and try that
16:24:43 <zzo38> hpc: O, yes, that will work
16:24:58 <hpc> WA is pretty much just mathematica plus a search engine
16:25:00 <byorgey> randomclown: the answer to "how do you X with wolfram alpha" is always "try random things until it works" =P
16:25:11 * byorgey hates the WA interface
16:25:12 <randomclown> the NLP really complicates things
16:25:24 <hpc> byorgey: you think the UI is bad, wait until you see the API
16:25:33 <byorgey> heh, I bet
16:26:07 <hpc> i honestly have no clue how duckduckgo manages to reduce that much information to a little red box
16:26:44 <zzo38> I don't like it much either; we should design something in Haskell which does many of these things, and usable locally, and it connect to internet when needed too.
16:27:49 <cmccann> zzo38, sounds good, are you volunteering to write it? :D
16:27:53 <RichyB> zzo38, there IS a package on Hackage which defines a function with type ([Integer] -> String) that looks up a sequence of integers that you provide to it on the Online Encyclopedia of Integer Sequences.
16:27:57 <rwbarton> for a good laugh ask wolframalpha about "klein bottle", then read the entire page
16:28:06 <zzo38> cmccann: I am volunteer to help with it
16:28:24 <RichyB> zzo38, technically it *should* be [Integer] -> IO String, but it has unsafePerformIO pre-applied on the rationale that the properties of integer sequences don't change very often. ;)
16:29:02 <zzo38> RichyB: Too bad!
16:29:37 <zzo38> Can you tell it not to pre-apply unsafePerformIO?
16:29:56 <RichyB> Apply "return"? ;)
16:30:54 <RichyB> zzo38, there are a bunch of IO actions for the same, too. :)
16:30:57 <RichyB> zzo38, http://hackage.haskell.org/packages/archive/oeis/0.3.1/doc/html/Math-OEIS.html
16:31:51 <RichyB> zzo38, the most violently magical thing in that is extendSequence :: [Integer] -> [Integer]. :)
16:32:51 <pkeene> OOC, how many of you frequently or semi-frequently implement state machines in your projects? Also, are you more, equally, or less likely to implement a state machine in your Haskell projects?
16:33:44 <irene-knapp> equally
16:34:47 <o1iver> Hey. What would be the best way of representing variable type function arguments in a container? In python I would simply use a list, but this obviously doesn't work here because of the different types. Tuples are not so nice because getting the 6th argument would be kinda ugly... any thoughts?
16:35:25 <cmccann> o1iver, first step is to think about what you really want to accomplish
16:35:27 <RichyB> pkeene, little bit more. I'm more likely to write an application to lean on threads a lot in Haskell than I am in any other language, and then I end up writing the individual thread subroutines as state machines.
16:35:36 <cmccann> a list of things of completely arbitrary type is probably not useful
16:35:52 <irene-knapp> o1iver, look into records, but yes, think about it carefully
16:36:22 <irene-knapp> o1iver, what does the function do?
16:37:13 <cmccann> chances are you either want a proper data type, or you want to just apply functions ahead of time instead of passing a collection of arguments around
16:37:15 <o1iver> cmccann, irene-knapp: the thing is that I need to be able to define different functions with the same type, meaning that all functions must be of some type (a -> b -> c)
16:37:51 <ByronJohnson> olsner: Normally, you would implement it without using such a list (in this case it sounds like you want to create a new datatype), but you could use heterogenuous lists, which are much more elegant with the extensions that GHC 7.4 provides.
16:38:05 <rwbarton> "define different functions with the same type" isn't a problem.
16:38:13 <irene-knapp> well
16:38:29 <rwbarton> I think you need to back up a little more
16:38:34 <ddarius> #haskellers, always tempting beginners with the latest GHC
16:38:35 <shachaf> rwbarton: It is when you do an extreme form of type-directed name resolution!
16:38:40 <irene-knapp> I mean, for example, if the shape of the function parameters stays the same but the type of some of them changes
16:38:45 <shachaf> I.e., when you only write types, never names.
16:38:46 <irene-knapp> you could define a parametrized synonym type
16:39:12 <irene-knapp> type MimsyFunction mimsyParameter = Int -> String -> mimsyParameter
16:39:23 <pkeene> RichyB, interesting. Personally, I have never written a state machine outside of college assignments. Where do you draw the line between managing state in an adhoc way vs. implementing a more formal state machine?
16:39:31 <irene-knapp> then the type "MimsyFunction Word32" is a function from an int and a string to a word32, and so on
16:39:46 <irene-knapp> pkeene: at around 100 lines of code, I draw the line :)
16:40:12 <pkeene> irene-knapp, haha awesome :)
16:40:25 <irene-knapp> haha yeah :)
16:40:38 <o1iver> actually I am not sure if I am on the right course here... I am going to think about this again. FYI: I am trying to implement a genetic programming funcion/parameter tree with variable type and variable number of arguments functions.
16:41:01 <RichyB> pkeene, if I decided that it was worth drawing out the state transition digraph on paper in order to prove to myself that it's correct, then I refer to the thing as a state machine afterwards. :)
16:41:21 <cmccann> o1iver, so the function and arguments here are the stuff being evolved?
16:41:26 <irene-knapp> o1iver, ohhhhhh, genetic programming!  interesting
16:41:28 <pkeene> RichyB, that sounds like a reasonable heuristic to use
16:41:39 <irene-knapp> o1iver, I was imagining something much more mundane :)
16:41:49 <ddarius> RichyB: Ever look at Promela and SPIN?
16:41:54 <o1iver> irene-knapp: I realized :-)
16:42:12 <irene-knapp> o1iver, doing a genetic programming thing is probably kind of similar to writing an interpreter for a hosted language, so you might want to look into how Haskell does that
16:42:18 <RichyB> pkeene, that doesn't rule out that I write state machines *all the time* but yeah.
16:42:19 <o1iver> irene-knapp: but I am just playing with this stuff for the fist time...
16:42:24 <irene-knapp> Generalized Algebraic Datatypes (GADTs) are typically relevant to it
16:42:27 <RichyB> ddarius, never heard of either.
16:42:36 <o1iver> irene-knapp: ok thanks, will look into that
16:42:45 <irene-knapp> sure thing
16:43:14 <RichyB> ddarius, SPIN is like tactics (in the theorem prover sense of the word) for CSP calculus?
16:43:24 <o1iver> irene-knapp: that definitely looks good, cheers!
16:43:26 <RichyB> or is it just a verifier?
16:43:30 <irene-knapp> excellent, np :)
16:44:30 <ddarius> RichyB: The input to SPIN is a concurrent program written in Promela.
16:45:36 * hackagebot simple-sendfile 0.2.1 - Cross platform library for the sendfile system call  http://hackage.haskell.org/package/simple-sendfile-0.2.1 (KazuYamamoto)
16:46:20 <o1iver> cmccann: yes exactly...
16:46:22 <hpaste> DanBurton pasted “Sanity check: dealing with ByteStrings” at http://hpaste.org/63776
16:46:29 <hpaste> “John Lien” pasted “lee maze router using cantor pairs and unfold” at http://hpaste.org/63777
16:46:46 <o1iver> cmccann: well actually the nodes evolve, but those can be either parameter nodes or function nodes
16:47:26 <RichyB> ddarius, so I'd model the *protocol* that I want to use in Promela, use SPIN to verify its correctness
16:47:43 <DanBurton> Before I start trying to actually use this, can I get a sanity check that the code actually makes sense? ^
16:48:04 <ddarius> RichyB: Correct.  Hence being a model checker.  You can abuse it to do other things though.
16:48:14 <RichyB> and then write the actual program in Haskell or C or whatever, but at this point proving its correctness is trivial because the only work that I have to do is to demonstrate that it implements the same model that I wrote in the Promela file, rather than having to demonstrate that the model is correct too?
16:48:43 <ddarius> RichyB: Well it won't be trivial, which is usually why you'd operate at a "protocol" level.
16:49:06 <ddarius> I.e. you'd prove that the protocol is correct (e.g. is responsive, doesn't deadlock, etc.)
16:49:14 <glguy> shachaf: did you get what you needed from an op?
16:49:36 <RichyB> er I misphrased that
16:49:37 <shachaf> glguy: Yep.
16:49:40 <shachaf> Well, from an oper.
16:49:47 <shachaf> If that's the term?
16:50:00 <RichyB> ddarius, so I'd write the actual program in Haskell or C or whatever, and only have to prove that the program corresponds to the protocol.
16:50:22 <RichyB> ddarius, instead of having to prove that the protocol is correct at the same time as proving that my program implements it correctly.
16:51:17 <ddarius> RichyB: Yes, though in many cases proving the program correctly implements the protocol is much harder than proving that the protocol is correct.
16:51:55 <ddarius> But it is much more likely that you will correctly (enough...) implement the protocol than correctly build a concurrent protocol.
16:52:03 <parcs`> how can a protocol be correct?
16:52:24 <RichyB> parcs`, be free of both deadlocks and livelocks.
16:52:36 <ddarius> parcs`: You define what "correct" means.
16:52:47 <ddarius> But lack of deadlocks and productivity are typically desirable features.
16:53:17 <RichyB> Or provide strictly bounded response time, or fairness, or amortised bounded response time or whatever.
16:54:23 <RichyB> ddarius, what order would you recommend learning about verification tools?
16:54:29 <ddarius> The properties that you want to hold are typically (in SPIN) expressed as linear temporal logic formulas.
16:54:56 <RichyB> I remember trying to read CPDT in order to learn Coq a few years back, but it didn't quite stick and I rediscovered videogaming shortly afterwards.
16:55:13 <ddarius> RichyB: In the order in which you have a use and/or the order the interests you.
16:55:29 <byorgey> learning Coq using CPDT is like learning about water using a fire hose.
16:55:36 <ddarius> SPIN is a fairly practical tool.
16:55:38 <RichyB> byorgey, yes, I ran into that.
16:55:43 <ddarius> byorgey: Better than learning about using fire.
16:55:50 <byorgey> true.
16:56:14 <byorgey> I guess it's like learning about fire using a flamethrower.
16:56:22 <RichyB> byorgey, about one and a half chapters in I was making "fack fack oh my what the fack" noises and resorting to reading the Coq reference manual because it was *easier* than the supposed "tutorial" I was reading.
16:56:38 <RichyB> Flamethrower? Plasma cannon.
16:56:57 <ddarius> How many states of matter are we up to now?
16:57:10 <byorgey> RichyB: yep.  you may be interested in "Software Foundations", http://www.cis.upenn.edu/~bcpierce/sf/
16:57:26 <acowley> My issue with CPDT is that it too often seems to present code with not much more prose then, "Here's something neat…"
16:58:11 <RichyB> ddarius, five. Solid, liquid, gas, custard, not-custard.
16:58:24 <RichyB> byorgey, thank you!
16:58:25 <ddarius> Is water not a not-custard?
16:58:28 <acowley> The proof style doesn't lend itself to annotating the steps of a proof, but I think more verbiage could be spent describing what the automation is doing.
16:59:10 <byorgey> ddarius: duh, water is a gas.
16:59:29 <RichyB> ddarius, several of water's possible states are not-custards.
17:00:42 * ddarius thinks his DNS settings got screwed up when he DHCPed into some wireless network.
17:01:12 * ddarius doesn't like "DHCPed into" but can't think of a better concise way to indicate the desired idea.
17:01:20 * RichyB is a big fan of 8.8.8.8 and 8.8.4.4 as nameservers.
17:01:49 <RichyB> ddarius, "grabbed a DHCP lease on some wireless network"
17:02:42 <RichyB> Those two IP addresses are for the public DNS servers that Google runs. I use them in situations where the nominally available nameservers are woefully insufficient for purpose - for example, with residential internet connections.
17:03:08 <RichyB> (in case anyone was wondering at the 8.8.8.8 / 8.8.4.4 comment)
17:03:28 <qpu> byorgey: would you suggest "Software Foundations" for beginners?
17:03:41 <byorgey> qpu: define "beginners"
17:04:29 <byorgey> qpu: however, the answer is probably "yes".
17:04:53 <qpu> byorgey: no experience with automated proof systems, but still capable of writing basic proofs
17:05:38 <byorgey> qpu: it is used as the text in an introductory graduate course where many of the students are masters-degree students without a particularly strong background
17:05:55 <byorgey> qpu: it definitely does NOT assume any experience with automated proof systems.
17:05:58 <qpu> byorgey: masters degree in CS or math?
17:06:03 <byorgey> CS
17:06:14 <qpu> ah, i'm hopeful then :]
17:06:25 <byorgey> qpu: yeah, I think you should be fine.
17:07:28 <dmwit> Wait, there are insufficient name servers?
17:07:31 <qpu> i started reading Pierce's category theory for computer scientists book, but stalled early in the definitions due to not enough motivating examples
17:07:35 <dmwit> Don't they all do basically the same thing?
17:08:34 <byorgey> qpu: "These notes are intended to be accessible to a broad range of readers, from advanced undergraduates to PhD students and researchers. They assume little specific background in programming languages or logic. However, a degree of mathematical maturity will be helpful."
17:09:44 <qpu> byorgey: sounds promising!
17:11:46 <qpu> dmwit: well, dns servers provided by isps for residential connections (eg, roadrunner) sometimes behave badly, like direct queries to a "search engine" instead of answering "name not found"
17:15:37 * hackagebot github 0.2.1 - Access to the Github API, v3.  http://hackage.haskell.org/package/github-0.2.1 (MikeBurns)
17:18:36 <wavewave> hi.
17:18:56 <hpaste> m3ga pasted “Filtering on constructor” at http://hpaste.org/63779
17:19:01 <wavewave> it's possible to do haskell scripting in hxournal now.
17:19:13 <wavewave> dyre is sweet.
17:19:42 <m3ga> is there a neater way of filtering a list based on the constructor?
17:19:49 <m3ga> http://hpaste.org/63779
17:21:13 <rwbarton> you can write Element {} in place of Element _ _ _ -- even if the constructor Element wasn't declared with record syntax
17:21:14 <cmccann> wavewave, still going with "hoodle"?
17:21:18 <irene-knapp> well, there's syb-style generic stuff
17:21:27 <acowley> m3ga: I'd name the lambda in a where and use pattern matching rather than case, but I'd generally use the same approach as you.
17:21:35 <rwbarton> also, you could use a list comprehension like this: [ x | x@(Element {}) <- xmllist ]
17:21:41 <cmccann> yeah
17:21:42 <wavewave> cmccann; I didn't decide anything yet. hoodle is number one candidate.
17:21:44 <Axman6> m3ga: use a list comprehension
17:22:13 <Axman6> filterAllElements xs = [x | x@(Element{}) <- xs]
17:22:21 <Axman6> bleh, beaten
17:22:22 <m3ga> Axman6: ah, yeah, that rings a bell.
17:22:29 <cmccann> wavewave, I think it's the best so far by a good margin
17:22:52 <m3ga> thanks all. brain fart. i'm pretty sure i've done that before myself.
17:24:30 <wavewave> cmccann : yes. ;-)  anyway any better idea is always welcome!
17:26:10 <wavewave> currently very basic scripting stuff started. it reads .hxournal.d/start.hs and compile it using dyre.. you can relaunch hxournal after you modify start.hs.. this is xmonad style.
17:26:41 <student> hi everyone
17:26:42 <wavewave> I just implemented Save As hook which will be called whenever save as called
17:26:48 <wavewave> hi.
17:26:50 <cmccann> wavewave, oh btw I'm going to be on the other side of the state this Friday for a job interview, going right past Ann Arbor probably
17:27:15 <wavewave> cmccann: great. you're welcome to visit!
17:27:48 <cmccann> not sure how much time I'll have, given the long drive home, but if you wanted to meet up briefly for coffee or something that'd be fun
17:28:12 <wavewave> cmccann: email me if you want. I will let you know my contact.
17:28:51 <wavewave> Friday. we have seminar at 3 pm ... that is one time constraint.
17:29:24 <adnauseam> at least you're not thinkign about which seat you should be taking
17:29:24 <wavewave> I am tutoring a grad student, but I can easily give him some break at any time.
17:29:26 <cmccann> well, it'd probably be closer to 4-6pm
17:30:12 <wavewave> cmccann : email me ;-D look forward to seeing you.
17:30:12 <cmccann> but I'll be on pretty tight time constraints myself, to get home at a sensible hour
17:30:22 <cmccann> ok :D
17:31:07 <CodeWeaverX> Wait, waht, party at wavewave's house?
17:31:11 <CodeWeaverX> woot!
17:31:12 <cmccann> haha
17:31:38 <RichyB> dmwit, lots of ISPs just don't spend enough money on their DNS servers.
17:31:39 <wavewave> ek. then i need to clean my mess from now on.
17:32:21 <RichyB> dmwit, so you end up with really slow and unreliable web access because the DNS requests for fifty thousand customers all go through one coal-fired little pentium-1 box in the corner of an office somewhere.
17:33:00 <student> hey everyone. I have an assignment to work on and i kind of need a push start. I am not sure how to start. Could anyone help me out please.
17:33:18 * mike-burns pushes student
17:33:19 <cmccann> wavewave, anyway I need to run at the moment but I'll email you tomorrow with approximate times and stuff
17:33:27 * RichyB shoves student.
17:33:29 * cmccann pushes student down the stairs, oops
17:33:42 <CodeWeaverX> So. student has learned that this is a bit of a room of smartasses.
17:33:43 <wavewave> cmcann: yeah~~!
17:33:43 <CodeWeaverX> :D
17:33:48 <mike-burns> student: Start with the data types.
17:34:41 <wavewave> push start button
17:34:51 <irene-knapp> game over - continue?
17:35:13 <student> I am given a haskell program but it has mistakes and is missing things and i have to fix it.
17:35:33 <mike-burns> Look at the error messages from the compiler, and try to fix those.
17:35:48 <mike-burns> This is a good exercise.
17:35:50 <irene-knapp> have you tried compiling the program to see whether it compiles at all, and what it does if so?
17:35:57 <irene-knapp> yes, it's an excellent exercise, they should do more of it
17:36:01 <mike-burns> Agreed.
17:36:02 <student> I learned java so not really familiar with haskell
17:36:13 <student> how to test?
17:36:19 <mike-burns> It's OK, many people have succeeded at learning both Java and Haskell.
17:36:28 <qpu> also, a quick way to learn compiler error messages are actually encrypted
17:36:30 * cmccann failed at learning Java
17:36:33 <student> i have the program running
17:37:01 <student> could i post it and someone look at it please?
17:37:06 <mike-burns> Oh, so there's no error? That's not as good of an exercise as I hoped.
17:37:08 <student> just give me a few hints
17:37:18 <mike-burns> We won't do your homework, but we love looking at code!
17:37:20 <mike-burns> @paste
17:37:21 <lambdabot> Haskell pastebin: http://hpaste.org/
17:39:37 <hpaste> student pasted “assignment” at http://hpaste.org/63780
17:41:00 <irene-knapp> this is a highly amusing problem description, but I would say that the practical joke is entirely the wrong approach to the problem.
17:41:00 <student> [Assert r 4 False | r <- recipes]    this line was fixed in the code to make it run (removed the  parentheses)
17:41:21 <irene-knapp> "I'm sorry, but I can't get time off of work.  Maybe you can stay with our parents instead."
17:41:46 <ceasarbautista> Any chance I can get some help with an assignment I'm working on?
17:42:01 <mike-burns> ceasarbautista: Bonus points if it's the same thing student is working on.
17:42:14 <mike-burns> student: Looks like you need to fill in lines 45 to 69. Yeah?
17:42:16 <qpu> reassignment is not allowed in #haskell
17:42:22 <mike-burns> Hah!
17:42:24 <ceasarbautista> mike-burns: haha. I wouldn't be surprrised
17:42:24 <irene-knapp> qpu: cute :D
17:43:16 <randomclown> is haskell sine in radians -> radians?
17:43:40 <student> hmm let me see the lines 45 to 69
17:43:42 <irene-knapp> yeah, that "recipe analysis" stuff is just a stub (see how the functions rule1, rule2, rule3, rule4 are simply defined as "True"), you need to write it
17:43:50 <irene-knapp> other functions may also be just stubs
17:43:52 <RichyB> randomclown, yes.
17:44:02 <randomclown> ok
17:44:18 <RichyB> randomclown, the trigonometric functions in Haskell work the same way as the trigonometric functions in C, i.e. in they're all in radians.
17:44:56 <irene-knapp> although it is incorrect to say that it's radians -> radians.  technically it's simply radians -> numbers.
17:45:05 <RichyB> randomclown, I would blame the fact that programming languages are all designed by either mathematicians or engineers.
17:45:12 <qpu> student: looks like you're ready to implement rule1..4 using bacon, ham, etc
17:45:12 <JustMaybe> is Cale a bot?
17:45:13 <irene-knapp> inasmuch as the input of the function is an angular measure but the output is not
17:45:16 <randomclown> hmm
17:45:19 <randomclown> radians are fine though
17:45:21 <Cale> JustMaybe: no
17:45:25 <randomclown> I quite like then
17:45:29 <irene-knapp> @quote Cale bot
17:45:30 <lambdabot> Cale says: I've written an entire IRC bot as what was essentially a single extremely long shell pipeline.
17:45:33 <Cale> JustMaybe: well, maybe
17:45:38 <JustMaybe> how can you be here anytime of the day ?
17:45:44 <RichyB> Engineers use radians because it makes the equations simpler.
17:45:50 <Cale> JustMaybe: By not keeping regular hours
17:45:57 <rwbarton> > tau
17:45:57 <lambdabot>   Not in scope: `tau'
17:45:58 <RichyB> Mathematicians use radians for reasons of personal taste. ;)
17:46:20 <qpu> JustMaybe: tmux on a remote host could keep your IRC client running too
17:47:00 <qpu> on a local host too, actually
17:47:02 <student> How would I check my output?
17:47:24 <qpu> student: ghci assignment.hs will given you an interactive console where you can call those functions
17:48:43 <student> I am doing that
17:48:57 <student> so i get the error because i have to make changes?
17:49:07 <mike-burns> What error.
17:49:38 <student> if i type rule1 i get : <interactive>:1:1:     No instance for (Show (Recipe -> Bool))       arising from a use of `print'     Possible fix:       add an instance declaration for (Show (Recipe -> Bool))     In a stmt of an interactive GHCi command: print it
17:49:56 <mike-burns> OK, great! This is the assignment I wanted.
17:50:11 <mike-burns> You can use    :t rule1    to see more details.
17:50:13 <mike-burns> It's awesome.
17:50:25 * cmccann considers assigning all of his compiler errors to mike-burns as homework
17:50:36 <mike-burns> I'm good; I got my own.
17:50:43 <cmccann> drat.
17:50:46 <mike-burns> Anyone want my cabal errors?
17:50:53 <cmccann> no I'm good
17:50:56 <clsmith> hey all. this isn't haskell.. but uh, i'm trying to solve a problem. i need an efficient algorithm which, given a weighted graph, will yield a subgraph such that each vertex has a single edge (they are 'paired up'), with the minimum total weight. does anyone happen to know an algorithm for that? >.>
17:51:09 <clsmith> alternatively, a channel suggestion?
17:51:36 <rwbarton> clsmith, search for something like "minimum weight matching in a general graph"
17:51:37 <qpu> minimum spanning tree?
17:51:42 <irene-knapp> not a spanning tree
17:51:44 <irene-knapp> it's less than one
17:52:19 <qpu> oh, each vertex has an edge but we don't care to which other vertex?
17:52:22 <kfish> doesn't need to be connected?
17:52:26 <student> let me take some time thinking about this lol. i am really lost.
17:52:41 <nus> student, it's telling you it doesn't know how to show the thing you ended up with (a function)
17:52:42 <clsmith> no, it can't be connected, because each vertex has exactly one edge
17:53:30 <irene-knapp> in fact, as clsmith said, the only possible configuration satisfying the constraints is that the graph effectively defines a set of disjoint pairs of vertices
17:53:40 <clsmith> more wikipedia tells me i want to find the minimum '1-regular graph'
17:53:53 <rwbarton> it's normally just called a (perfect) matching
17:54:06 <irene-knapp> hm
17:54:07 <rwbarton> "perfect" meaning it uses every vertex
17:54:25 <qpu> oh, so it's only defined for even number of vertices (checking my understanding)?
17:54:43 <clsmith> ah yes, a 'perfect matching' is a better way of putting what i want
17:54:55 <clsmith> yeah, it's necessarily even
17:54:57 <rwbarton> for example, here is a paper which apparently contains an algorithm for what you want to do: http://www.cs.ucl.ac.uk/staff/V.Kolmogorov/papers/BLOSSOM5.html
17:54:58 <magicman> And not even for every graph with an even number of vertices.
17:55:05 <JustMaybe> clsmith: can you explain clearer?
17:55:15 <clsmith> rwbarton: thanks!
17:55:34 <clsmith> now that i know the type of graph's name it's going to be a lot easier to google :p
17:56:13 <rwbarton> if your graph is bipartite then it's a more classical (and easier) problem
17:56:32 <clsmith> JustMaybe: i want to pair up nodes by their edges, with the minimum total weight.
17:56:53 <clsmith> googling 'perfect match graph' would be more helpful i guess
17:57:34 <clsmith> rwbarton: i think it may be bipartite (i'm not so well versed in this stuff).
17:57:47 <clsmith> yeah, it is.
17:59:06 <clsmith> "hall's marriage theorem"?
17:59:29 <rwbarton> then you can use the so-called Hungarian algorithm and there's even a package on Hackage that purports to implement it (http://hackage.haskell.org/package/Munkres)
17:59:50 * ddarius hopes someone named "Kolmogorov" produces good work.
18:01:19 <clsmith> rwbarton: does that yield the minimum weighted perfect match?
18:01:25 <clsmith> ah yes
18:01:32 <clsmith> should read descriptions ;p thanks a lot!
18:16:49 <student> rule 1 i put the following :rule1 r = bacon r || ham r || sausage r
18:17:14 <student> but still the same error
18:17:36 <JoeyA> Is there an "assert" for STM?  Or should I roll my own?
18:18:16 <JoeyA> It is desirable to be able to disable assertions at compile-time.
18:18:16 <qpu> student: i'm guessing you are typing the name of a function at the GHCI prompt, but not providing arguments. so it's trying to print a function (ie, no instance for Show ...)
18:18:34 <qpu> student: be sure to pass all the parameters to your function at the prompt
18:19:48 <student> can you help me change the layout of how it prints assertions
18:19:49 <JoeyA> (note: If I understand correctly, regular assert is unsafe to use in STM, because the transaction might be looking at an inconsistent picture of the memory)
18:20:17 <alang> edwardk: hello
18:20:18 <student> its all cluttered up and i can't seem to see anything right :(
18:20:39 * hackagebot test-framework-th-prime 0.0.3 - Template Haskell for test framework  http://hackage.haskell.org/package/test-framework-th-prime-0.0.3 (KazuYamamoto)
18:21:19 <edwardk> heya alang
18:22:30 <alang> edwardk: can i use ad to differentiate erf?
18:23:11 <alang> edwardk: rather, I know what the derivative of erf should be, so using that, how can I differentiate an expression that involves erf
18:23:48 <edwardk> well, the problem is 'erf' isn't in Floating, etc.
18:24:06 <edwardk> i packaged it in http://hackage.haskell.org/packages/archive/numeric-extras/0.0.2.2/doc/html/Numeric-Extras.html
18:24:32 <edwardk> but i don't thing that i made instances for RealExtras for AD s a
18:24:47 <alang> ah I see
18:24:55 <edwardk> ah, nope i didn't. =/
18:27:45 <student> in the "if" i have to put an "else"?
18:28:09 <student> for example i have the following : rule3 :: Recipe -> Bool -- Rule 3: If bacon, then peppers. rule3 r = if bacon r then peppers r
18:28:20 <student> is it fine?
18:28:20 <rwbarton> yes, you need an else
18:28:36 <student> what should i put in else
18:28:48 <rwbarton> whatever you want the value to be if bacon r is false
18:29:07 <jtobin> edwardk: while i can see you here - do you have any idea offhand how much work would be involved in implementing AD for something like matrix trace?  or d/dSigma (mu-mo)^T Sigma^-1 (mu-mo)
18:29:11 <edwardk> alang: having random routing problems sorry if i drop in and out
18:29:16 <student> so it should be false i guess
18:29:24 <jtobin> edwardk: not in the sense of 'can you do it', but moreso, 'if i do it, what am i looking at'
18:29:47 <edwardk> jtobin: well you can calculate the trace of course and just compute an AD'd answer
18:29:50 <byorgey> student: suppose a recipe does not have any bacon.  Is rule 3 satisfied?
18:30:05 <tgeeky_> byorgey: who cares about rule 3. I'm not satisfied!
18:30:17 <jtobin> edwardk: yes, more along the lines of general AD'd matrix functions i suppose
18:30:21 <byorgey> well, then tgeeky_ is False.
18:30:35 <edwardk> jtobin: the sigma bit just for mahalanobis distance?
18:30:36 * tgeeky_ vanishes out of existence
18:30:54 <jtobin> edwardk: i have only a cursory knowledge of AD - trying to get a better handle on it
18:30:59 <edwardk> i've been playing with ad in terms of matrix ops, there is actually a good solid theory for it
18:31:14 <edwardk> but for that i need the hmatrix guy to split it into the gpl and bsd parts
18:31:23 <jtobin> hmm
18:31:32 <student> hmm
18:32:13 <edwardk> alberto said he would, but i'm still waiting =/
18:33:06 <student> byorgey have you looked at my assignment?  i think it should be false but i am not sure
18:33:56 <hpaste> student pasted “assignment with changes” at http://hpaste.org/63782
18:34:01 <monochrom> if tgeeky_ is False, I don't know who is True
18:34:16 <student> there it is with the changes Imade
18:34:46 <Sgeo> I want a language with semantics similar to Haskell in a Smalltalk-like environment.
18:35:09 <Sgeo> Smalltalk itself bothers me. Between the lack of namespacing, the single-dispatch, and the dynamic typing...
18:35:30 <byorgey> student: I have looked at your assignment.
18:35:47 <student> you think i am right?
18:36:04 <byorgey> student: let me ask the question in a different way.  Suppose a recipe uses onions and mushrooms.  Does that recipe satisfy Rule 3?
18:36:11 <qpu> Sgeo: which parts of the environment do you like? the UI looks like 1980s to me
18:36:19 <student> no
18:36:19 <alang> edwardk: no prob, I'm gonna go to lunch actually, but be back later
18:36:25 <byorgey> student: it doesn't?
18:36:33 <Sgeo> qpu, I think the way I can change programs while they run easily, debugging, etc.
18:36:35 <student> yes it does
18:36:44 <byorgey> student: Rule 3 says, IF there is bacon, then there must also be peppers.
18:36:46 <student> sorry it has to have one
18:37:03 <byorgey> but my recipe does not have bacon.
18:37:15 <student> then no
18:37:26 <student> so else false
18:37:53 <student> correct?
18:37:57 <byorgey> student: no.
18:38:02 <student> why
18:38:14 <byorgey> student: I grant, it is a bit tricky understanding when an implication is true or false.
18:38:17 <rwbarton> ask ##english :P
18:38:32 <byorgey> student: my brother says that if a recipe contains bacon, then it must also contain peppers.
18:38:36 <byorgey> suppose that is the only rule.
18:38:47 <byorgey> would he be unhappy with a recipe that contains only mushrooms and onions?
18:38:48 <student> okay
18:39:34 <student> but i am thinking like in java
18:39:45 <byorgey> well, there's your problem.
18:39:48 <monochrom> the law says, "if you drink, don't drive". I don't drink. this law allows me to drive. this law also allows me to not drive
18:40:01 <cmccann> thinking like java is usually a bad idea
18:40:05 <cmccann> including in java
18:40:33 <student> lol
18:40:46 <monochrom> thinking like in java is fine, as long as you know that "if (b) { x=0; }" means "if (b) { x=0; } else { don't change x; }". put back the else. then it is clearer.
18:40:49 <rwbarton> anyways this isn't a programming question at all
18:41:30 <monochrom> if bacon is there, then peppers must be there, else no constraint on peppers.
18:42:28 <student> okay but then the rule is not satisfied there is no bacon
18:42:36 <student> and should say false
18:42:39 <student> ?
18:43:08 <monochrom> "if (b) ..." does not require b
18:43:31 <monochrom> this is not a cabal file
18:44:31 <student> okay
18:44:51 <qpu> student: sometimes it helps to build a 4x4 table. Bacon, NoBacon x Peppers, NoPeppers. then in each box write true/false depending on if the brother would eat the omlette
18:45:41 <qpu> if there is no bacon, does the brother care if there are peppers?
18:45:50 <student> nope
18:46:01 <qpu> if the rule is false, he won't eat the omlette
18:46:12 <student> ahhh
18:46:29 <student> thats clear
18:47:01 <jtobin> edwardk: this came up as i was looking at getting gradients for a distribution over matrices (inverse wishart)
18:47:14 <edwardk> *nods*
18:47:41 <edwardk> you can of course compute answers using derivatives and matrix
18:47:41 <student> okay so what else am i missing in the code that will make it work?  Is there a way to change how assertions print?
18:47:43 <edwardk> er matrices
18:47:44 <byorgey> student: the rule *is* satisfied if there is no bacon.  The only time the rule is violated is if there IS bacon but there are NO peppers.
18:47:52 <edwardk> and it'll even yield the right answer
18:48:05 <student> yep got that one
18:48:07 <edwardk> what i was talking about is i may be able to speed it up ~ an order of magnitude
18:48:12 <byorgey> ok
18:48:19 <student> thanks
18:48:48 <jtobin> sorry, dc'd there for a sec
18:48:52 <student> how would i put the results in 3 columns?
18:49:41 <jtobin> sure, the speed is the goal
18:50:25 <student> anyone please
18:50:26 <edwardk> have you tried it with the current implementation?
18:50:53 <student> me?
18:51:07 <jtobin> no, actually - i was looking at it this morning and put it on a to-do list to try
18:51:12 <edwardk> fair nuff
18:51:13 <jtobin> then i saw someone quizzing you about erf, haha
18:51:25 <jtobin> so i figured it was a good opportunity to check
18:51:42 <edwardk> =)
18:52:18 <jtobin> continuing with the 'things to check' theme, actually
18:52:57 <student> i have only one hour to complete this and submit it please help :(    i want to change the layout of the results printed using assertions
18:53:20 <jtobin> what do you know about parallel ad?  when i look at a simple forward-mode derivative tree, it looks like it should be reasonably parallelizable
18:53:32 <jtobin> but i'm not sure it would be worth doing for most functions
18:57:46 <student> anyone
18:57:56 <edwardk> you can actually evaluate any function in 'ad' in parallel using seq, par, etc.
18:58:01 <student> am i muted or something
18:58:04 <edwardk> the reverse mode doesn't benefit from it so much of course
18:58:11 <jtobin> great, that's what i was hoping to hear
18:58:28 <Sgeo> student, I can hear you
18:58:31 <Sgeo> See your text
18:58:34 <edwardk> but the construction of the primal can be done quite quickly even in reverse mode
18:58:53 <student> could you help me please
18:59:22 <edwardk> folks have used it for about 50-100k variables
18:59:31 <jtobin> yes, my intuition is that it would not really add anything for any reasonably `normal' function
18:59:43 <student> just got 55 minutes to submit this assignment and had 2 midterms today so i am really stressed out. please help
19:00:09 <student> i want to change the layout of the results printed using assertions
19:00:30 <hpaste> o1iver pasted “eval” at http://hpaste.org/63783
19:01:11 <o1iver> Does this type class with functional dependency define that the type of function f defines the function input and output argument types?
19:03:22 <edwardk> o1iver: yes, 'f' determines is and os
19:04:02 <edwardk> instance Eval (i -> o) i o where eval = id
19:05:06 <edwardk> keep in mind that keeps any type information from flowing from the result or the input into 'f', so you may wind up with annoying type annotations
19:05:20 <student> please someone
19:05:38 <student> point me to a guide or something atleast
19:05:59 <student> i am trying to learn, i am not asking anyone to do it for me
19:07:32 <companion_cube> do you know "learn you a haskell for great good"? if you're looking for a guide...
19:07:54 <o1iver> edwardk: ok thanks. I am not sure what you mean with the type info not flowing but thats ok for now (struggling as it is :)
19:08:44 <jtobin> edwardk: cheers, thanks.  off to code it up
19:08:53 <rwbarton> o1iver: well normally if I have "let y = f x in ..." and I know x :: a and y :: b then I know that f :: a -> b
19:08:58 <o1iver> edwardk: actually, could you show me another instance of that class (I keep getting functional dependency conflicts)
19:09:15 <o1iver> rwbarton: ok, but ...?
19:09:16 <rwbarton> but if I have "let y = eval f x in ..." then even if I know the types of x and y I can't conclude anything about the type of f
19:09:35 <o1iver> rwbarton: ah because it depends on the instance of Eval
19:09:42 <o1iver> rwbarton: is that right?
19:09:43 <rwbarton> yes
19:09:51 <o1iver> rwbarton: I see
19:10:07 <student> I am on that guide
19:10:13 <edwardk> data Exp = Add Exp Exp | Int Int   instance Eval Exp () Int where eval (Add x y) () = eval x + eval y; eval (Int x) () = x
19:10:22 <edwardk> er
19:10:25 <student> but how to change the layout of the printing of assertions
19:10:29 <edwardk> eval (Add x y) () = eval x () + eval y ()
19:10:47 <rwbarton> so if f has some kind of polymorphic type, you might need to add a type signature to that use of f to fix some type variables
19:14:57 <o1iver> rwbarton: ok I see what you mean... thanks!
19:15:17 <o1iver> edwardk: I don't think that works because Eval Int () is *->* and not *
19:16:07 <edwardk> Eval Exp () Int
19:16:09 <o1iver> edwardk: shouldnt it be instance Eval Exp () Int
19:16:13 <byorgey> ceasarbautista: still need some help?
19:16:13 <student> okay any help here with deficit
19:16:14 <o1iver> ok
19:16:34 <student> deficit' :: Recipe -> Integer deficit' r = 4
19:16:36 <edwardk> which is what i wrote up above, no?
19:16:41 <ceasarbautista> byorgey: Yeah. Got distracted by dinner.
19:16:52 <edwardk> [23:13] edwardk: data Exp = Add Exp Exp | Int Int   instance Eval Exp () Int where eval (Add x y) () = eval x + eval y; eval (Int x) () = x
19:16:53 <byorgey> dinner has a way of doing that
19:17:09 <ceasarbautista> byorgey: I'm working on #6. I'm having trouble figuring out how to implement HasVars.
19:17:24 <edwardk> but i'd typod the eval function case for Add
19:17:42 <student> byorgey: please help me out i have only 40 minutes to submission of the assignment
19:18:20 <ceasarbautista> byorgey: So it looks like I just need to let Map.lookup be assigned a name.
19:18:22 <byorgey> student: I'm very sorry to hear that.
19:18:51 <ceasarbautista> What's confusing though is that the instantce, unlike the other things I had to do is, a function this time.
19:18:51 <student> i had exam today and now tired and have to submit this.
19:18:55 <student> exams
19:19:01 <ceasarbautista> And I have no idea how to limit it to only take Strings and Ints.
19:19:18 <student> so i want to change the layout of the assertions
19:19:34 <byorgey> ceasarbautista: what do you mean, limit it?
19:19:43 <student> byorgey: could you guide me in the direction for that
19:19:50 <byorgey> student: no, sorry, I don't have time
19:19:53 <ceasarbautista> Naively, I want to do: "var s = M.lookup"
19:20:19 <ceasarbautista> But clearly that won't work because M.lookup takes generic parameters.
19:20:38 <byorgey> ceasarbautista: that's not why it won't work.
19:20:50 <byorgey> you can always specialize a polymorphic function to something more specific.
19:20:50 <o1iver> edwardk: ok thanks. It works now with Eval Exp () Int ... eval x () + ...
19:20:53 <o1iver> cheers
19:21:06 <byorgey> remember, the caller of a polymorphic function (i.e. you) gets to choose the types
19:21:12 <companion_cube> student: what do you mean, "change the layout of the assertions"?
19:21:20 <companion_cube> which assertions?
19:21:21 <edwardk> yeah
19:21:43 <ceasarbautista> byorgey: Right that makes sense. But I'm not calling it here.
19:21:53 <student> in my assignment when i type assertions it give me the results but they are in one line and too confusing to read
19:22:03 <student> i want it in 3 columns
19:22:11 <byorgey> ceasarbautista: what type does M.lookup have?
19:22:24 <student> http://hpaste.org/63782
19:22:45 <ceasarbautista> byorgey: Data.Map.lookup :: Ord k => k -> Map k a -> Maybe a
19:22:49 <byorgey> right
19:22:52 <byorgey> ceasarbautista: and what type should go on the right hand side of  var s = ...  ?
19:23:05 <ceasarbautista> (M.Map String Integer -> Maybe Integer)
19:23:08 <byorgey> right.
19:23:11 <byorgey> do those match?
19:23:20 <ceasarbautista> Close, but no.
19:23:29 <byorgey> right, why not?
19:24:01 <companion_cube> student: so if you run this code, the layout is not satisfying, that's it?
19:24:09 <ceasarbautista> lookup will work for any k and a. the RHS of var s will work only for Strings and Ints.
19:24:15 <student> yes
19:24:18 <byorgey> ceasarbautista: no, that's not why =)
19:24:39 <byorgey> ceasarbautista: suppose you can replace k and a with any types you like.  Can you make them match?
19:25:00 <ceasarbautista> byorgey: So Ord is the trick?
19:25:03 <student> companion_cube: how/where would i change the printing layout?
19:25:15 <byorgey> ceasarbautista: no, the Ord is just there to ensure that k has an instance of Ord
19:25:33 <byorgey> ceasarbautista: so if you replace k by some type that has an Ord instance you can throw away the Ord part
19:25:48 <byorgey> (String does indeed have an Ord instance)
19:25:49 <student> companion_cube: this is how it prints right now [Assert {recipe = "00000", deficit = 4, legal = False},Assert {recipe = "10000", deficit = 4, legal = False},
19:25:53 <ceasarbautista> byorgey: Oh- Of course. So I miss that key.
19:25:57 <companion_cube> you define your own printing layout, there are already some functions to print on several lines
19:25:59 <ceasarbautista> missed*
19:26:03 <byorgey> ceasarbautista: right.
19:26:27 <companion_cube> try printAAs instead of printAs ?
19:27:34 <ceasarbautista> byorgey: Not sure how I missed that. Thanks though!
19:28:00 <byorgey> ceasarbautista: no worries! you're welcome
19:28:54 <byorgey> ceasarbautista: anyway, it's understandable how you could miss it since it was obscured by both polymorphism and a type class constraint
19:29:14 <byorgey> ceasarbautista: but with practice you get used to reading those things
19:29:14 <lispy> hello
19:29:16 <student> companion_cube: no difference
19:31:12 <student> companion_cube: ohh wait changes weren't saved
19:31:20 <student> companion_cube: trying it
19:31:23 <companion_cube> well, it doesn't even compile on my computer
19:32:14 <companion_cube> ah, there were a few typos
19:33:08 <o1iver> what is the simples data structure that supports an ordered list of values with different types?
19:33:13 <o1iver> *simplest
19:33:35 <companion_cube> I'd say Hlist?
19:33:46 <startling> o1iver: tuple?
19:33:51 <student> companion_cube: yes i see fixing them
19:34:11 <student> companion_cube: the deficit needs to be fixed right?
19:34:19 <o1iver> startling: oops... must be of variable length with easy take
19:34:35 <o1iver> companion_cube: cheers looking at them now
19:34:46 <companion_cube> student: it was something like s/pepper/peppers/
19:34:56 <companion_cube> student: but to me it already prints stuff with a nice layout
19:35:05 <student> hmm
19:35:10 <student> it must be the mac then
19:35:16 <student> dammit
19:35:20 <dobblego> does anyone know of a zipper for Language.Haskell.Syntax.HsModule?
19:35:45 <student> how can i run this on a windows pc?
19:36:16 <student> or forget that. I want to know how to fix the deficit
19:36:48 <companion_cube> I mean, at the beginning I have lots of lines like 'Assert {recipe = "00000", deficit = 4, legal = False}'
19:37:09 <student> okay
19:37:18 <student> thats what i meant to change
19:37:41 <companion_cube> what would you like instead?
19:37:41 <student> arrange them nicely so i can see the different recipes
19:38:00 <student> the deficit part needs to be change i belice
19:38:09 <companion_cube> how, you mean, just print the recipe?
19:38:17 <latros> hi
19:38:53 <latros> I have an idea for a proposal of a language extension; however the idea I have in my head is a little bit vague
19:39:08 <latros> and I don't know much about the details of the implementation of the type system, which is where the proposal lives
19:39:14 <latros> anyone know anything about how this works?
19:39:20 <student> like once row shows 00000 another deficit value and another legal or not. I don't know the tutor had it so need i am not sure if they changed the code or were using some different command
19:39:29 <MostAwesomeDude> latros: Perhaps describing it would help?
19:39:45 <latros> I called the idea "block closures of typeclass definitions"
19:40:13 <latros> it's essentially an extension of the idea that's already in the compiler that allows you to have what look like mutually recursive default definitions of functions
19:40:14 <companion_cube> student: then you have to add a "Show" instance to Assertion
19:40:23 <latros> for example (-) and negate
19:40:24 <companion_cube> I mean, to write one by hand
19:40:47 <latros> the extension is to families of typeclasses, with the motivation being hierarchies of typeclasses
19:40:54 <latros> for example Monad-Applicative-Functor
19:40:55 <quintessence> student: or write some other function of type Assertion -> String and use that instead of show
19:41:00 <qpu> student: start by creating a function that takes an Assert and returns a String
19:41:37 <qpu> student: you can convert most values to strings using `show`
19:41:43 <qpu> > show 100
19:41:44 <lambdabot>   "100"
19:41:47 <latros> the idea is that you tell the compiler minimal definitions that are sufficient to define an instance of *multiple* typeclasses, such as Monad-Applicative-Functor, and then force the user to instantiate their type using only one of these blocks
19:42:06 <latros> for example, for Monad you have the {return,>>=} block, the {return,join,fmap} block, and I think a couple others
19:42:18 <student> okay
19:42:23 <latros> from which you get all the functions in Monad-Applicative-Functor
19:42:24 <student> how about the deficit
19:42:38 <latros> this works around the issue of needing UndecidableInstances to implement mutually recursive typeclass hierarchies
19:42:39 <student> i have to change it right?
19:42:54 <latros> for example, this breaks:
19:42:57 <latros> class Monad m where
19:42:58 <latros> ...
19:43:02 <hpaste> companion_cube annotated “assignment with changes” with “assignment with changes (annotation)” at http://hpaste.org/63782#a63786
19:43:09 <latros> (>>=) :: m a -> (a -> m b) -> m b
19:43:14 <latros> m >>= f = join $ fmap f m
19:43:21 <latros> instance Monad m => Functor m where
19:43:28 <companion_cube> if you just want to modify how a recipe is printed, you can try this way
19:43:29 <latros> fmap f m = m >>= (return . f)
19:43:40 <latros> you are not allowed to do what I just did
19:43:50 <latros> without UndecidableInstances
19:43:53 <companion_cube> (I did not try it)
19:43:57 <latros> and UndecidableInstances breaks things
19:44:09 <latros> does that help, MostAwesomeDude ?
19:45:12 <latros> in effect you would have default implementations of one or more functions, and then (MAYBE automatically, but I somewhat doubt it) would have minimal definitions of combinations of typeclasses
19:45:17 <latros> then you supply one and the compiler infers the rest
19:45:36 <MostAwesomeDude> latros: Well, I still don't get it, especially since I normally see the hierarchy going the other way, but okay.
19:45:50 <dobblego> latros: FYI, as an aside, Monad<-Applicative<-Functor is not desirable
19:45:58 <latros> what
19:46:01 <Jesin> ...why not
19:46:42 <latros> people write boilerplate that basically does what I'm describing all the time...
19:46:49 <latros> instance Functor SomeMonad where fmap = liftM
19:46:56 <latros> this happens way too many times
19:47:07 <dobblego> in short, because not all semigroups are monoids (I can write up a more appropriate type-class hierarchy, though I believe edwardk and byorgey are working on one)
19:47:28 <latros> um
19:47:34 <latros> which aspect of the hierarchy are you saying breaks?
19:47:49 <edwardk> dobblego: i think there might be one linked from the new category-extras
19:47:49 <latros> (I do know what you mean when you say semigroups are not monoids, I don't see why it's pertinent)
19:47:57 <edwardk> oh, its just the packages
19:47:59 <latros> (since I'm not talking about MonadZero or MonadPlus anywhere)
19:48:07 <dobblego> edwardk: oh great, care to help me out here :)
19:48:20 <dobblego> edwardk: do you mean the semigroupoids package specifically?
19:48:24 <edwardk> yes
19:48:49 <student> companion_cube: do you know how should i write the deficit?
19:48:50 <dobblego> oh wait, you updated category-extras! *smooch*
19:48:53 <edwardk> latros: it is more useful to talk about applicatives without pure and monads without return than to talk about pointed for the most part
19:48:59 <edwardk> dobblego: dmwit did
19:49:06 <dobblego> smooch him too
19:49:14 <latros> ok, fair enough
19:49:16 <latros> the point stands
19:49:29 <dobblego> there is a nice ASCII diagram here http://hackage.haskell.org/package/semigroupoids-1.2.6.1
19:49:34 <quintessence> latros: what happens to programs that currently define an explicit Monad and Functor instance for the same type?
19:49:42 <dobblego> latros: yes it was an aside to your main point, carry on
19:49:57 <edwardk> anyways with that, you wind up with classes like Apply and Bind from semigroupoids, which correlate are to Applicative and Monad what semigroup is to monoid
19:50:14 <cmccann> fun fact, desugaring do blocks doesn't actually need return
19:50:30 <latros> quintessence, you wouldn't use this extension for those, I'm fairly sure
19:50:33 <edwardk> latros: so you want to derive a functor for everything that is a monad? i just jumped in
19:50:38 <dobblego> cmccann: this is related to edwardk's point
19:50:40 <companion_cube> student: is it the number of broken rules?
19:50:55 <latros> that's part of it, edwardk, but that's just one example
19:51:07 <latros> this is really an implementation of a mild form of typeclass hierarchies
19:51:12 <dobblego> note that Scala's monad comprehension syntax does not use pure/point (this is a coincidence rather than being thought through)
19:51:15 <edwardk> the problem with that is that what happens when that data type is also a comonad? there is a perfectly good canonical definition for fmap in terms of extract and extend
19:51:19 <edwardk> which wins?
19:51:27 <edwardk> instances can also come into scope from anywhere
19:51:31 <latros> you'd have another block
19:51:36 <student> companion_cube: i swear i dont understand the assignment that clearly, he gave a us a code with all broken things and we have to fix it
19:51:37 <latros> for that purpose
19:51:37 <edwardk> so what happens when the instance for monad is defined in another module entirely
19:51:49 <hpaste> clown pasted “clown” at http://hpaste.org/63788
19:51:56 <latros> there is a subtlety, though, you're right
19:52:00 <companion_cube> student: yeah, ok, but this is your homework
19:52:10 <student> companion_cube: due in 5 minutes and i will loose marks, yes
19:52:20 <randomclown> can you gents help me improve the performance of my code?
19:52:21 <randomclown> http://hpaste.org/63788
19:52:27 <latros> you might have a block for {Monad,Functor} and {Comonad,Functor}
19:52:30 <randomclown> it draws an ascii doughnut
19:52:32 <companion_cube> well, you're not the only one who is tired here
19:52:39 <edwardk> the main reason why none of the superclass proposals has been implemented is this kind of subtlety though
19:52:41 <latros> but if you ever had {Monad,Comonad,Functor} you would need to have a block for it
19:52:43 <latros> I know
19:52:47 <companion_cube> but good luck
19:53:12 <latros> you see, though, that for a lot of the natural situations this works pretty nicely
19:53:13 <latros> hell
19:53:21 <latros> you see "minimal complete definition: blah" in documentation
19:53:22 <latros> a lot
19:53:34 <latros> it'd be nice to be able to tell the compiler that sort of information
19:54:01 <companion_cube> student: if you have precise technical questions, i think people on this chan will help you; but not if you just ask "do it for me"...
19:54:03 <edwardk> i actually don't see that for the natural situations that it works out well, though. since when you start getting far enough out there the confluence of these definitions isn't necessarily guaranteed
19:54:21 <latros> oh?
19:54:28 <latros> I don't see it, frankly
19:54:36 <latros> the only problem is that you'd wind up with a lot of blocks
19:54:47 <latros> and inferring the blocks via a relational structure would probably be nontrivial
19:55:08 <edwardk> and when you construct those instances they have to come into scope and be re-exported, so you can break instances that other people might have explicitly exported from other modules
19:55:14 <Jesin> hmm
19:55:19 <edwardk> so there is no good time to make the call that you have a Functor a Monad and a Comonad in scope
19:55:32 <edwardk> since you may have only had the Functor and the Monad when you wanted to form your first judgment on the matter
19:55:35 <latros> module sequencing is an issue here, definitely
19:55:41 <Jesin> [23:54:17]	edwardk	the problem with that is that what happens when that data type is also a comonad? there is a perfectly good canonical definition for fmap in terms of extract and extend
19:55:43 <Jesin> [23:54:20]	edwardk	which wins?
19:55:57 <latros> but this isn't actually a problem here, because you basically do *everything* in block closures
19:56:03 <Jesin> those don't generally end up equivalent?
19:56:17 <edwardk> jesin: they theoretically have to for any legal functor. ;)
19:56:21 <latros> if you don't do something in a block closure you can't use this language extension
19:56:39 <Jesin> yay
19:56:47 <edwardk> jesin: but there are various cheating functors out there ;)
19:56:51 <Jesin> :(
19:56:56 <Jesin> how do you cheat with FUNCTOR
19:56:58 <edwardk> uu-parsinglib has several
19:56:58 <Jesin> lol
19:57:03 <hpaste> student pasted “assignment with error” at http://hpaste.org/63789
19:57:13 <latros> but...growing blocks
19:57:15 <latros> is a problem
19:57:28 <latros> passing from {Monad,Applicative,Functor} to {Monad,Comonad,Applicative,Functor}
19:57:32 <latros> is...troubling
19:57:55 <latros> on the other hand it can be done
19:57:57 <student> companion_cube: i get a compile error now after changing the deficit : [1 of 1] Compiling Main             ( A2.hs, interpreted )  A2.hs:65:22: Not in scope: `true'  A2.hs:70:22: Not in scope: `true' Failed, modules loaded: none.
19:58:12 <companion_cube> it's "True"
19:58:12 <ion> edwardk: What kind of evilness does uu-parsinglib do wrt. functors?
19:58:29 <latros> you can write down the relations between functions in the different typeclasses
19:58:34 <edwardk> ion: they have a few that have negative occurrences which they avoid through particular nastiness
19:58:37 <strager> student: You want True, not true.  True is a data constructor.
19:58:42 <latros> and then figure out what the blocks that work
19:58:44 <latros> er
19:58:47 <dobblego> student: type this at ghci :info Bool
19:58:50 <latros> what function blocks work
19:58:53 <cmccann> edwardk, how does THAT work
19:59:25 <latros> edwardk, does my description actually make sense, btw?
19:59:28 <edwardk> i also have some where i effectively coyoneda transform my functor so i can keep it functorial, or where i actually change constructors to be able to put in the fmap explicitly
19:59:30 <randomclown> @:t Bool
19:59:30 <latros> also does the name make sense?
19:59:31 <lambdabot> Done.
19:59:43 <randomclown> @:info Bool
19:59:43 <lambdabot> Unknown command, try @list
19:59:43 <student> companion_cube: what is that?
19:59:44 <latros> (the name is essentially borrowed from topology)
19:59:55 <edwardk> latros: i haven't gone that far into it, i just offered you the standard rebuttals ;)
20:00:01 <latros> right
20:00:03 <latros> but
20:00:05 <latros> with this in particular
20:00:09 <randomclown> @type Bool
20:00:10 <lambdabot> Not in scope: data constructor `Bool'
20:00:10 <latros> I came up with it with some of these issues in mind
20:00:25 <Jesin> @info Bool
20:00:25 <lambdabot> Bool
20:00:31 <qpu> :]
20:00:33 <Jesin> well that's helpful
20:00:40 <randomclown> @type True
20:00:41 <lambdabot> Bool
20:00:51 <qpu> @info Monad
20:00:52 <lambdabot> Monad
20:00:55 <latros> lol
20:01:18 <ion> lambdabot’s @info is one of the most useful commands ever.
20:01:22 <edwardk> latros: well, given the limited description i see above, there isn't much else i can poke holes in =/
20:01:26 <Jesin> @help info
20:01:26 <lambdabot> help <command>. Ask for help for <command>. Try 'list' for all commands
20:01:35 <Jesin> well that's helpful
20:01:36 <Jesin> lol
20:01:38 <randomclown> @list
20:01:38 <lambdabot> http://code.haskell.org/lambdabot/COMMANDS
20:01:41 <ion> @info (+)
20:01:41 <lambdabot> (+)
20:01:44 <ion> @info foo
20:01:45 <lambdabot> foo
20:01:49 <latros> my idea is pretty detailed, edwardk
20:01:54 <latros> but I may have described it overly vaguely
20:01:58 <edwardk> latros: did you paste a link?
20:01:58 <cmccann> @info info
20:01:59 <lambdabot> info
20:02:00 <randomclown> @slap ion
20:02:00 * lambdabot decomposes ion into several parts using the Banach-Tarski theorem and reassembles them to get two copies of ion!
20:02:03 <latros> a link to what
20:02:07 <Jesin> @echo lol
20:02:08 <lambdabot> echo; msg:IrcMessage {msgServer = "freenode", msgLBName = "lambdabot", msgPrefix = "Jesin!~Jesin@Dyn146012.cc.lehigh.edu", msgCommand = "PRIVMSG", msgParams = ["#haskell",":@echo lol"]} rest:"lol"
20:02:14 <Jesin> what was that
20:02:27 <edwardk> the idea/a sketch of what code would look like
20:02:29 <latros> I didn't paste a link to anything, but I'm wondering what I would've pasted a link to if I ad
20:02:29 <ion> @@ @echo @echo @echo foo
20:02:30 <lambdabot>  echo; msg:IrcMessage {msgServer = "freenode", msgLBName = "lambdabot", msgPrefix = "ion!ion@heh.fi", msgCommand = "PRIVMSG", msgParams = ["#haskell",":@@ @echo @echo @echo foo"]} rest:"echo; msg:
20:02:30 <lambdabot> IrcMessage {msgServer = \"freenode\", msgLBName = \"lambdabot\", msgPrefix = \"ion!ion@heh.fi\", msgCommand = \"PRIVMSG\", msgParams = [\"#haskell\",\":@@ @echo @echo @echo foo\"]} rest:\"echo; msg:
20:02:30 <lambdabot> IrcMessage {msgServer = \\\"freenode\\\", msgLBName = \\\"lambdabot\\\", msgPrefix = \\\"ion!ion@heh.fi\\\", msgCommand = \\\"PRIVMSG\\\", msgParams = [\\\"#haskell\\\",\\\":@@ @echo @echo @echo foo\
20:02:30 <lambdabot> \\"]} rest:\\\"foo\\\"\""
20:02:30 <latros> *had
20:02:31 <latros> ah
20:02:31 <latros> no
20:02:38 <latros> I probably should, but I don't have a syntax in mind yet
20:02:50 <randomclown> I think you killed you
20:02:52 <randomclown> it*
20:03:19 <edwardk> annoyingly all we have right now is the default method machinery which actually makes modularization of code impossible =(
20:03:20 <monochrom> "I think it killed you"? "I think you killed it"? "it think you killed you"?
20:03:36 <randomclown> pronouns are my weakness
20:03:46 <edwardk> because you can't make Applicative get default methods from Monad without the code for Applicative being defined in the same module or circularly with the code for Monad =/
20:04:01 <randomclown> does anyone want to help me imporve my slow ass code?
20:04:03 <ion> > [ a ++ " killed " ++ b | a <- ["it", "you"], b <- ["it", "you"] ]
20:04:05 <lambdabot>   ["it killed it","it killed you","you killed it","you killed you"]
20:04:09 <Jesin> I have problems under prepositions sometimes.
20:04:27 <randomclown> @eval perm ["it", "killed", "you"]
20:05:11 <rwbarton> wow -- user1151874: i already declare hp as int with value 3 now my problem is when i put "hp--", it shows error [...] but if i put "--hp", the result print is 3 not 2. -- is this a real quote?
20:05:12 <randomclown> @eval permutation ["it", "killed", "you"]
20:05:46 <cmccann> rwbarton, yes
20:05:46 <CodeWeaverX> Is there any particular reason a text file read in with hGetContents should actually throw an exception when the lazy read gets to the end of the file?
20:05:47 <monochrom> rwbarton: you have overloaded --
20:05:52 <Jesin> .........lol
20:05:53 <CodeWeaverX> I"m baffled.
20:06:24 <cmccann> rwbarton, http://stackoverflow.com/questions/9241687/haskell-subtract-error
20:06:35 <wavewave> .
20:06:50 <ion> hah
20:07:10 <Jesin> > permutations ["it","killed","you"]
20:07:11 <lambdabot>   [["it","killed","you"],["killed","it","you"],["you","killed","it"],["killed...
20:07:33 <CodeWeaverX> :sighs
20:07:37 <randomclown> cmccann the troll is trong with this one
20:07:39 <student> companion_cube: ohh lol got it
20:07:45 <nus> CodeWeaverX, windows?
20:07:53 <ion> “things like i++ can be modelled in Haskell by using State monad. You can look examples on haskellwiki” How useful answer.
20:08:01 <CodeWeaverX> nus: osx.
20:08:10 <CodeWeaverX> Just a straightforward text file.
20:08:21 <rwbarton> let (++) = modifyIORef (+1)
20:08:34 <monochrom> more useful than no answer
20:08:43 <dobblego> s/(+1)/succ {- FTW -}
20:09:11 <ion> I’m stuck waiting for the end of the substitution expression.
20:09:42 <mgsloan> latros - I'm not sure if I understand the idea.  Is the idea that you introduce a named "union instance", which gives new default implementations to the typeclasses involved?  Then, instances are created in terms of this union instance?
20:10:12 <mgsloan> err that last question --> Then, an instance of this union can be created for a particular ADT / type
20:10:53 <latros> not exactly, mgsloan, though it's somewhat similar
20:11:27 <mgsloan> it'd be cool to also use this as a constraint, as we've named a new context
20:11:50 <latros> you'd have a "block of typeclasses", and would then make types instances of all types in the block by defining one of the minimal blocks
20:11:51 <ceasarbautista> Can somebody tell me how I could go about adding the result of two lookups (of type (M.Map String Integer -> Maybe Integer))? I can't seem to come up with a decent solution given that the results could be Nothing.
20:12:07 <latros> then the functions required by the different typeclasses would get defined from the block closure of the minimal block you chose
20:12:13 <latros> (I'm writing something up atm)
20:12:14 <rwbarton> latros: edwardk: maybe we can sidestep this monad/comonad issue by declaring at the instance site which other instances we want, so e.g. instance (Functor [], Applicative [], Monad []) where return = (:[]); (>>=) = flip concatMap
20:12:29 <rwbarton> (totally not thought-out proposal)
20:12:40 <quintessence> :t liftA2 (+)
20:12:41 <lambdabot> forall a (f :: * -> *). (Num a, Applicative f) => f a -> f a -> f a
20:12:54 <edwardk> rwbarton: that is far more plausible to me
20:13:01 <Jesin> wow
20:13:08 <Jesin> I like that last one
20:13:09 <Jesin> lol
20:13:15 <randomclown> http://hpaste.org/63788
20:13:24 <randomclown> someone help me with this code?
20:13:43 <Jesin> rwburton's idea ftw
20:13:45 <ion> Try profiling it and adding strictness annotations.
20:14:10 <randomclown> where would strictness help in this?
20:14:45 <latros> rwbarton, that's basically what this does
20:14:59 <latros> except it does it at the typeclass level instead of the instance level
20:15:07 <ion> Dunno, i’m just pulling thoughts out of my ass based on a bunch of code and a vague explanation of the problem. Perhaps you’re building huge thunks somewhere.
20:15:09 <dobblego> @type \p q -> p >>= \p' -> if p' == 0 then q else q >>= \q' -> return (p' + q')
20:15:10 <lambdabot> forall (m :: * -> *) b. (Num b, Monad m) => m b -> m b -> m b
20:15:12 <hpaste> student pasted “assignment finished I think” at http://hpaste.org/63790
20:15:46 <nus> CodeWeaverX, http://www.mail-archive.com/glasgow-haskell-users@haskell.org/msg17542.html
20:16:24 <mgsloan> latros - gotcha.  What about a selection of two classes being a minimal block?  It is definitely good to be able to reflect the fact that one of a pair of the mutually invoking functions absolutely _must_ be implemented.
20:16:32 <CodeWeaverX> nus:  Whoa!
20:16:53 <CodeWeaverX> nus: Nice catch!  Not sure what to do here.
20:17:37 <CodeWeaverX> nus:  No, wait.  There's no actual error except for end-of-file.  I wonder if that's still an error.  At least, I'm not sure how to ferret out if there is another error.
20:17:39 <randomclown> How do I force a function to be evaluated?
20:17:49 <CodeWeaverX> nus: All the data comes in.  It's just that it fails after reading all the data.
20:17:51 <randomclown> when it is in a monad
20:18:10 <latros> mgsloan -- for example, in the Monad-Functor block, one minimal function block has >>= in it, the other has fmap in it
20:18:22 <CodeWeaverX> nus: And it actually throws an exception… with no other information.  The error doesn't look like the one in the message.
20:18:27 <latros> you are forbidden to define neither when instantiating a type as being in the Monad-Functor block
20:18:28 <randomclown> basically something like let preload = slow function; printStrLn result
20:18:28 <nus> CodeWeaverX, how are you closing the file handle?
20:19:02 <mgsloan> latros - ahh, I see.  And I take it you'll also handle overriding the defaults that result from this?
20:19:10 <latros> probably
20:19:19 <randomclown> @info $!
20:19:19 <lambdabot> ($!)
20:19:25 <randomclown> @type $!
20:19:25 <lambdabot> parse error on input `$!'
20:19:30 <student> companion_cube: is this good enough
20:19:41 <CodeWeaverX> nus:  At present, I'm not.  It appears to die during a 'show' of the list that contains the data.  Closing the file *after* that didn't seem to make any difference.
20:19:45 <mgsloan> cool idea, I like that it also solves the issue of checking if there's enough of an implementation
20:20:04 <student> companion_cube: should i change something else? or is there a better way to write the deficit part
20:20:14 <student> companion_cube: http://hpaste.org/63790
20:20:39 <CodeWeaverX> I wonder if it's because I have 'break on exceptions' on, and its treating the end-of-file as an exception for some weird reason.
20:21:02 <companion_cube> student: yeah, there's a better way
20:21:05 <companion_cube> just hang on a sec
20:21:13 <rwbarton> it would be nice for sure to declare in the type class definition what the minimal definitions are
20:21:19 <student> okay
20:21:52 <rwbarton> I think everyone gets caught out by the "instance Eq X where {}" and now your program enters an infinite loop problem once
20:22:26 <ddarius> Why would you write such an instance and then use (==) or (/=)?
20:22:51 <dmwit> As we all know, ddarius never makes mistakes
20:23:01 <ion> module CPUBurnTest where { data CPUBurn = CPUBurn; instance Eq CPUBurn where {}; main = return (CPUBurn == CPUBurn) }  -- use case!
20:23:06 <latros> rwbarton, it wouldn't actually happen at the class declaration, it'd happen in a separate but related declaration
20:23:18 <companion_cube> student: deficit r = fromIntegral . length . filter id $ [rule r | rule <- ruleset]
20:23:19 <rwbarton> Because you wanted your program to type check while you were working on some other thing, so you wrote an empty instance and then forgot to fill it in by the time you actually ran the program, maybe? I dunno. I remember it happening to me once.
20:23:22 <companion_cube> something like this
20:24:04 <cmccann> it's also not always obvious what definitions are required
20:24:11 <companion_cube> hmm, wait, more like deficit' r = fromIntegral . length . filter not $ [rule r | rule <- ruleset]
20:24:13 <mzero> filter id?
20:24:18 <mzero> after a list comprehension?
20:24:26 <cmccann> Eq is about the only class where it is pretty obvious, really
20:24:33 <mzero> and then ignoring the values?
20:24:35 <companion_cube> yeah, ok, you can put the test in the list comprehension
20:24:38 <rwbarton> but uh
20:24:38 <ChickenNoodle> Is there any quick and easy way to convert from a String to an Int?
20:24:42 <ion> rwbarton: In that case it might be better to add something like (==) = error "TODO"
20:24:53 <rwbarton> I hope abs and signum are not considered part of the minimal definition of Num :P
20:25:01 <rwbarton> ion: In retrospect, yes.
20:25:04 <companion_cube> fromIntegral . length . filter not . map ($ r) ruleset
20:25:15 <mzero> deficit r = from integral $ length [ () | rule <- ruleset, rule r ]
20:25:34 <rwbarton> But if it weren't for the weird mutually recursive definitions of (==) and (/=), that's equivalent to what you'd get with no definition.
20:25:40 <mzero> or    deficit r = sum [ 1 | rule <- ruleset, rule r ]
20:25:55 <rwbarton> (also seriously who defines an Eq instance in terms of (/=))
20:25:59 <cmccann> rwbarton, the minimal definition of Num is at least 60% of the functions, a shot of hard liquor, and forgetting everything you know about abstract algebra
20:26:01 <companion_cube> oh yeah, sum
20:26:30 <randomclown> how come I can't have an empty char?
20:26:32 <randomclown> ''
20:26:37 <companion_cube> anyway, that's better than the current answer
20:26:43 <companion_cube> randomclown: empty char does not exist
20:26:44 <student> companion_cube: what difference does the code you gave me make? gives me the same output if i replace deficit' r with yours
20:26:46 <mzero> well, sum here, only because I saw the fromIntegral -- and seemed you wanted something polymorphic in numeric type
20:26:50 <ion> randomclown: What’s the Unicode code point of the empty character?
20:26:59 <companion_cube> student: well, it's just simpler and shorter
20:27:01 <ion> randomclown: How come I can’t have an empty Integer?
20:27:18 <randomclown> is there a work around for (if true then 'a' else ''):list ?
20:27:25 <companion_cube> and mzero gave even better definitions
20:27:35 <student> companion_cube: okay perfect.
20:27:43 <mzero> randomclown: (if true then ('a':) else id) list
20:27:51 <mgsloan> latros: just a thought - you might consider suggesting that defaulting actually be moved out of type classes, in favor of using these blocks.  Also, it seems like this could definitely be mocked up in template haskell.
20:28:06 <companion_cube> randomclown: if (True then "a" else "" ) + list, also
20:28:10 <companion_cube> ++, sorry
20:28:26 <companion_cube> I'm no match for mzero :D
20:28:55 <randomclown> (++) is O(left side length) right?
20:28:55 <mzero> randomclown: I don't know where the source of that True was from (some Bool expression, I'm guessing)
20:29:08 <randomclown> mzero yeah
20:29:18 <mzero> but if it was from checking a Maybe x    ---
20:29:23 <ddarius> let true = False
20:29:26 <mzero> then using the function    maybe   would be more idomatic
20:29:28 <mzero> c
20:29:36 <randomclown> I'd pattern match maybe
20:29:50 <randomclown> (++) is O(left side length) right?
20:30:04 <CodeWeaverX> nus:  Okay, that's a bit retarded -- it's breaking as if the end-of-file is an exception.  If I turn off that debugging feature from GHCI, it goes as normal.  (guess I should have mentioned I'm doing this in GHCI).
20:30:21 <mzero> but, without knowing....   in any event, review my version and become comfortable with the notion that if is going to return a function to apply  ---- and with the    ('a':) syntax --- which is a partially applied operator
20:30:35 <student> companion_cube: wait
20:30:45 <mzero> and the pattern of using    id     in such a case to mean "I don't want to modify the list..." or some such
20:30:45 <edwardk> ddarius: you can further confuse them with
20:30:53 <edwardk> > let True = False in True
20:30:54 <lambdabot>   True
20:31:04 <latros> http://pastebin.com/vsW5JfqM
20:31:06 <mauke> The paste vsW5JfqM has been copied to http://hpaste.org/63791
20:31:24 <ddarius> If you try to do that more emphatically it gets unhappy.
20:31:25 <latros> ack
20:31:27 <latros> missed a paren
20:31:30 <ddarius> > let !True = False in True
20:31:31 <lambdabot>   *Exception: <interactive>:3:4-16: Non-exhaustive patterns in pattern binding
20:31:45 <student> companion_cube: i can remove all the deficitRule1 :: Recipe ->Integer  till deficiteRule3 and just ur line of code?
20:31:51 <nus> CodeWeaverX, itype IOError = IOException
20:31:51 <latros> http://pastebin.com/gpuXeGNS
20:31:53 <latros> there we go
20:31:53 <mauke> The paste gpuXeGNS has been copied to http://hpaste.org/63792
20:31:58 <companion_cube> student: that's the idea, yeah
20:31:59 <latros> it's a nasty syntax
20:32:00 <latros> but
20:32:05 <latros> you can kinda see how it would work?
20:32:09 <companion_cube> but take mzero's one, with the "sum"
20:32:24 <ddarius> Not True = False but Haskell doesn't listen.
20:32:29 <student> companion_cube: ohh cool.
20:32:30 <companion_cube> fromIntegral $ sum [1 | rule <- ruleset, rule r]
20:32:40 <companion_cube> then try to understand how it works
20:32:50 <randomclown> how do I get a list like [100, 99, 98 .. 0]?
20:32:52 <mzero> umm, no need for fromIntegral there I think
20:32:53 <randomclown> using the ranges
20:32:57 <mzero> :t sum
20:32:59 <lambdabot> forall a. (Num a) => [a] -> a
20:33:13 <edwardk> > [2,1..-10]
20:33:14 <lambdabot>   Not in scope: `..-'
20:33:15 <CodeWeaverX> nus:  Okay, I can see that,but if hGetContents is allowed to read lazily, of what use is it if it reaches the end of file and throws an exception just for that?  Shouldn't it just end the lazy list, and close up shop?
20:33:18 <edwardk> > [2,1.. -10]
20:33:19 <lambdabot>   [2,1,0,-1,-2,-3,-4,-5,-6,-7,-8,-9,-10]
20:33:47 * mzero is guessing some university problem set is due tomorrow... :-)  
20:34:09 <latros> mgsloan--that's an interesting diea
20:34:09 <latros> *idea
20:34:10 <lispy> yeah, edwardk stop doing your homework in here ;)
20:34:12 <latros> also, check my paste
20:34:23 <edwardk> you're on to me
20:34:44 <lispy> my homework was to finally get idris installed. I did it!
20:34:50 <lispy> better late than never
20:35:07 <edwardk> latros: the main thing lacking is implementation effort more than points in the design space
20:35:10 <cmccann> my homework is to make hackage need less than a terabyte of RAM
20:35:16 <cmccann> :T
20:35:23 <int_> Hello, Does any know of a hosting company that supports GHC and SSL? apparently nearlyfreespeech.net does not. Any help would be greatly appreciated. thanks.
20:35:25 <edwardk> lispy: nice. i installed it during hac boston when edwin brady was out here
20:35:27 <latros> ofc, edwardk
20:35:28 <student> companion_cube: am i correct here : notDeficitOne a = if (deficit a==1)                          then False                          else True
20:35:42 <latros> I'm more curious if the idea holds water
20:35:46 <latros> than if it could actually be done
20:35:48 <edwardk> latros: *nods*
20:35:50 <mzero> my homework is to secretly replace a common programmer tool with one written in Haskell....
20:35:50 <companion_cube> notDeficitOne a = a /= 1
20:36:13 <companion_cube> err
20:36:42 <companion_cube> student: notDeficitOne = (/= 1) . deficit
20:36:54 <edwardk> the general model is sound. you could even just require that all instances for superclasses have to be in scope before you make an instance for a subclass and if not then the default definitions from the subclass are used, the problem there of course is that class constraints involving MPTCs, etc. get ugly
20:37:11 <quintessence> student: or if you want to be literal, notDeficitOne a = not (deficit a == 1)
20:37:25 <mgsloan> latros - cool!   I really think that this could be done in < 100 lines of template haskell
20:37:31 <edwardk> for instance your proposed block { Monad, Applicative, Functor } doesn't work when there are multiple arguments or worse when the same class is used multiple times
20:37:44 <mgsloan> ahhhh
20:38:01 <student> companion_cube: both of you guys code does the same as mine?
20:38:15 <companion_cube> student: just test it, but yeah, it should
20:38:27 <mzero>  no - they are not,
20:38:28 <latros> I didn't think of doing it in template haskell
20:38:29 <latros> that's a neat idea
20:38:43 <edwardk> class (Category (Dom f), Category (Cod f)) => Functor f where type Dom f :: * -> * -> * ; type Cod f :: * -> * -> *; map :: Dom f a b -> Cod f (f a) f b)
20:38:58 <mzero> insofar as   notDeficitOne = (/= 1) . deficit    will run afoul of the dreaded monomorphism restriction
20:39:10 <edwardk> now Category comes up twice, which one would i be referring to?
20:39:11 <mzero> (assuming deficit is polymorphic)
20:39:55 <student> companion_cube: i like quintessence way since its easy to understand for an amateur like me. good for studying for exam
20:40:01 <edwardk> latros: you can use reifyInstances to figure out which instances are in scope and make any others you need
20:40:04 <mzero> so, just write it naturally, not cleverly for now:    notDeficitOne a = deficit a /= 1      or   notDeficitOne a = not (deficit a == 1)
20:40:37 <companion_cube> student: you can play with subparts of the definitions in ghci, to see whcih type they have and how they work
20:40:40 * hackagebot io-choice 0.0.0 - Choice for IO and lifted IO  http://hackage.haskell.org/package/io-choice-0.0.0 (KazuYamamoto)
20:40:42 <edwardk> you can also use a [d| … |] quasiquoter to grab all your definitions as well
20:40:45 <latros> I haven't heard of reifyInstances
20:41:16 <nus> CodeWeaverX, it does normally, read GHC-IO-Handle-Text to understand better what's happening
20:41:32 <latros> (I'm new at TH in general)
20:42:12 <CodeWeaverX> nus: okay…. this bewilders me some…
20:42:17 <CodeWeaverX> nus:  Searching...
20:42:24 <student> companion_cube: hmm i have to get used to ghci a little more. Took me a while to figure out why my .hs was not loading on my mac
20:42:49 <lispy> int_: you may need to go with an EC2 (or linode etc)
20:43:22 <companion_cube> student: you can ask for the type of expressions, like  :type sum
20:43:24 <nus> CodeWeaverX, particularly read lazyReadBuffered's implementation
20:44:17 <student> companion_cube: I think i should be changing the longest_run, but again not sure, i have the following :longest_run = head $ reverse $ sortBy (compare `on` length) d1runs
20:44:37 <CodeWeaverX> nus:  Okay, I will probably be convinced that that is what it *is* doing.  I'm confused as to why it should.  How can I treat it as a list that happens to come from a file if it could throw an exception just because it reaches the end of file?  I would have expected it to just end the list.  *other* file errors make sense to throw.  But EOF?
20:44:39 <mzero> student:   it is so common to type  :type  into ghci, you can abbreviate it   :t
20:44:46 <rwbarton> why do you think you should be "changing" it
20:45:06 <mzero> since when does hGetContents through EOF?
20:45:27 <companion_cube> I love this  compare `on` length  stuff
20:45:29 <CodeWeaverX> mzero:  This is what I am seeing when I turn on 'break on exception' when reading lazily.
20:45:52 <CodeWeaverX> It doesn't throw an exception that kills my program unless I turn that feature on in GHCI
20:45:54 <companion_cube> student: it looks fine, did you test it?
20:45:58 <mzero> oh - but isn't that exception caught and handled within hGetContents -- your code will never see that
20:46:02 <lispy> edwardk: does system f support dependent types?
20:46:10 <lispy> edwardk: or do you need a different formalism?
20:46:12 <CodeWeaverX> mzero:  Perhaps, but then why should ghci even report it?
20:46:30 <CodeWeaverX> mzero:  Specifically when the break-on-exceptions feature is used I mean.
20:46:34 <mzero> ghci can't tell the difference between your program and the library!
20:46:38 <rwbarton> well, it is still an exception, right
20:46:53 <rwbarton> it's not called break-on-unhandled-toplevel-exceptions
20:46:54 <mzero> to be honest, in years of using Haskell --- I've never turned that feature on - not even once!
20:47:02 <CodeWeaverX> Okay okay, I started to see that answer coming as I posed the question.  But then… I suppose we can continue past that.
20:47:03 <rwbarton> yeah I have never heard of it before
20:47:13 <edwardk> lispy: thats kind of the definition of when you need another formalism, no?
20:47:20 <CodeWeaverX> I wonder if I can instruct GHCI to just continue past that exception since I know it'll be handled...
20:47:34 <CodeWeaverX> Oh bite me, there it goes.
20:47:38 <CodeWeaverX> *facepalm*
20:47:43 <student> companion_cube: hmm won't work until i import
20:47:49 * mzero never uses the "debugger" features in ghci... never ever
20:48:02 <companion_cube> import Data.Function (on), I'd say
20:48:07 <ChickenNoodle> There are debugger features?
20:48:13 <CodeWeaverX> Sue me, I rather like debuggers.
20:48:21 <edwardk> lispy: how well do you know the lambda cube?
20:48:21 <eyebloom> mzero: what do you use?
20:48:22 <ChickenNoodle> ....Do they do traces?
20:48:29 <lispy> edwardk: Not well, actually.
20:48:29 <student> companion_cube: yea but is it needed for my assignment? as i don't remember learning this in class
20:48:39 <CodeWeaverX> They do if you launch a function with tracing on, or enable a bunch of breakpoints.
20:48:44 <mgsloan> latros: So, here's how I'm thinking about things.  Typeclasses allow you to write constraints that guarantee existence of a particular set of functions.  Default implementations of these functions is an entirely separate, convenience-oriented concern, and is a tiny bit of a language smell.  Solving this problem better would essentially be a template system for class instances.
20:48:46 <rwbarton> student: where did you learn of it then
20:48:46 <edwardk> going to dig up a paper for you
20:48:50 <companion_cube> student: it's not necessary, but your current answer looks nice
20:49:08 <edwardk> http://www.staff.science.uu.nl/~jeuri101/MSc/jwroorda/ the ps file linked there
20:49:19 <student> companion_cube: look at these slides i just got
20:49:22 <lispy> edwardk: looking at the wikipedia page I see that it pretty much says System F doesn't do dependent types
20:49:30 <edwardk> lispy: they describe the connection between pure type systems and system f.
20:49:31 <student> companion_cube: looking*
20:49:35 <companion_cube> uh, ok
20:49:44 <edwardk> and in particular they sketch the lambda cube right after showing how awful system f is
20:49:48 <mzero> eyebloom: I don't find I need a "debugger" for Haskell - when I'm working, if I need to explore how some code works -- I :load it into ghci (remember to set -isrc if you put source in a subdir named src) and away I go plugging away at running internal functions by hand
20:49:54 <latros> I see, mgsloan
20:50:01 <lispy> edwardk: thesis.ps?
20:50:07 <student> companion_cube: if you know of a noobish way please share lol
20:50:12 <edwardk> yeah
20:50:17 <mzero> I don't find "single stepping" or such to be helpful --- or needed --- as most Haskell functions are short enough to just worry about a function at a time
20:50:26 <edwardk> its a fun read and a nice gentle introduction to pure type systems
20:50:27 <lispy> edwardk: thanks, I'll add that to my reading list
20:50:30 <byorgey> system F is lovely if you want the simplest possible setting in which to study parametricity.
20:50:33 <byorgey> but not for much else.
20:50:37 <mgsloan> latros - So, when you instantiate an implementation template, by name, it would provide some set of functions
20:50:38 <lispy> edwardk: I don't know why I missed out on all this stuff in my education
20:50:44 <byorgey> er, I meant "polymorphism"
20:50:46 <edwardk> byorgey: yep
20:50:47 <byorgey> but parametricity too.
20:50:51 <lispy> edwardk: I took all the grad level language classes I could at my univ
20:51:05 <lispy> edwardk: the one on OOP made me want my money back :(
20:51:06 <eyebloom> mzero: I think sometimes it would just be very helpful to find out quickly what parameters a function is getting.
20:51:17 <edwardk> lispy: sok. my college basically taught java, bioinformatics and database architecture ;)
20:51:32 <eyebloom> I'm still finding that very difficult and time consuming in haskell
20:51:33 <companion_cube> student: try to write it yourself, say, using recursion
20:51:55 <student> companion_cube: the "--" in the start of a line means comment out like in java "//"
20:51:56 * byorgey didn't learn any of this in undergrad either
20:52:08 <companion_cube> student: yes
20:52:11 <lispy> byorgey: I meant grad school though :)
20:52:26 <tgeeky_> undergrad = learning how to learn, unless you're special or driven or both
20:52:26 <byorgey> oh. =)
20:52:31 <edwardk> likewise
20:52:53 <pikhq> undergrad for me = "sleeping until they hand me a certificate of basic competence"
20:52:56 <pikhq> :)
20:53:06 <edwardk> undergrad was a nice break from having to work ;)
20:53:11 <byorgey> well, given that I am doing a PhD in PL stuff my grad school experience is probably not representative =)
20:53:12 <lispy> I sometimes feel like a total hack as I don't know things like the lambda cube, PTS, category theory, etc
20:53:20 <mgsloan> latros: I, of course, am just speculating, and no expert.  Like any good template system, this would also support parameters.  The template instantiation would be provided arguments that are substituted into the appropriate portions of the definitions
20:53:20 <edwardk> byorgey: =P
20:53:29 <student> companion_cube: i am really bad at recursion in haskell specially
20:53:36 <latros> random question: can template haskell use the full power of GHC while doing its thing?
20:53:39 <edwardk> lispy: have you read TaPL?
20:53:41 <latros> similar to lisp macros?
20:53:55 <companion_cube> student: well that's annoying, because recursion is fundamental in haskell
20:53:57 <lispy> edwardk: I have a copy, but no I've only skimmed a few chapters so far
20:54:04 <companion_cube> if you're going to have an exam on it, you should train
20:54:10 <mgsloan> latros - yup!  Which is why template haskell is a good fit for this
20:54:11 <startling> edwardk: what is TaPL?
20:54:19 <latros> cool
20:54:20 <lispy> Types and Programming Languages
20:54:21 <edwardk> startling: types and programming languages
20:54:23 <CodeWeaverX> Thanks for your help, all.  I'm going to go drown my facepalm in beer.  And more haskell.
20:54:30 <mzero> student: I'm sorry, are we talking about your use of `on` and if that is Kosher 'cause it is in Data.Function ? and if it isn't how you need to write it yourself?
20:54:43 <mzero> it isn't, ya know recursive...
20:55:04 <startling> edwardk, lispy: thanks!
20:55:10 <lispy> hmm...evernote is not letting me make a webclip of that PTS page...
20:55:13 <edwardk> startling: a really good text that takes you from very simple type checking algorithms to some very complicated type inference algorithms through showing you how certain forms of type inference are impossible, etc.
20:55:33 <edwardk> written by the same guy that proved that said inference algorithms couldn't exist ;)
20:55:42 <student> companion_cube: yea i mean the data.function was not taught to us in class
20:55:47 <startling> that's really neat. I've been meaning to get into category theory etc
20:56:07 <byorgey> (TaPL doesn't have any category theory)
20:56:13 <edwardk> startling: well, it doesn't ever mention category theory, but its all about type theory
20:56:16 <startling> type theory?
20:56:24 <startling> that one. heh.
20:56:25 <edwardk> that said, the author _also_ has a category theory book ;)
20:56:39 <companion_cube> student: I don't know which rules you have for your homeworks; if you're not going to use this solution, however, at your place I'd write my own function using recursion
20:56:41 <edwardk> though admittedly its not one i usually recommend
20:56:50 * mzero thinks it is a sad sad instructor who would be upset that you managed to learn something additional on your own and use it in a solution.....
20:56:56 <byorgey> edwardk: it's funny, if you try to talk to him about category theory now, he claims he doesn't remember any of it =)
20:57:02 <mzero> student    :longest_run = head $ reverse $ sortBy (compare `on` length) d1runs       --- this isn't quite right
20:57:02 <edwardk> hah
20:57:34 <lispy> edwardk: which one do you usually recommend?
20:57:36 <edwardk> so its a sort of 'this is what i learned as i learned it' book
20:57:53 <byorgey> edwardk: yeah, I think so
20:57:57 <mzero> think about it - the problem here is essentially linear: find the biggest x    --- but you're using an operation, sort, which is n log n ---- this should be ringing bells in your ears --- I'm doing a lot more work than I need to be, which
20:58:05 <student> mzero: why?
20:58:12 <mzero> apart from being inefficient, is perhaps signaling that you're going about it wrong
20:58:13 <edwardk> awodey is the usual place to send people who are learning category theory
20:58:25 <edwardk> i rather like categories for the working mathematician myself
20:58:31 <byorgey> hah, you would
20:58:33 <mgsloan> instantiation of class templates is something I've always wanted.  It'd allow you to do cool stuff like "instance Num a => TNum []", where all of the numeric ops are done in terms of traversable
20:58:39 <mzero> student --- I give you a line of 30 people --- find me the tallest ..... do you need to put them in size order first?
20:58:49 <edwardk> byorgey: of course. the last chapter is all about kan extensions =)
20:58:50 <byorgey> lispy: stay as far away from Categories for the Working Mathematician as possible
20:58:53 <companion_cube> mzero: I'm curious, do you have a point free linear solution to this one?
20:59:07 <student> mzero: not necessarily
20:59:11 <edwardk> awodey is probably the best place to go
20:59:11 <lispy> edwardk: So if someone wanted to add "-XDependentTypes" to GHC, core wouldn't be able to handle it?
20:59:18 <byorgey> lispy: unless you are resigned to the fact that it will take you a week just to get through the first 10 pages
20:59:24 <mzero> companion_cube: is point free a requirement?
20:59:33 <companion_cube> no, I'm just curious
20:59:40 <edwardk> if you want a really gentle slope in, http://www.amazon.com/Conceptual-Mathematics-First-Introduction-Categories/dp/052171916X/ref=sr_1_1?s=books&ie=UTF8&qid=1329372142&sr=1-1 gets you some topics drilled in very well
20:59:41 <lispy> byorgey: I'm not a working mathematician so, I'd probably not pick it up :)
20:59:45 <edwardk> but it takes a LONG time drilling them
20:59:51 <companion_cube> let say, just a one liner, not necessarily point free
20:59:52 <mzero> but, sure I can write that point free
20:59:57 <mzero> without a sort
21:00:03 <companion_cube> something elegant :p
21:00:06 <edwardk> categories for the working mathematician is amazing, but its really scarily dense.
21:00:12 <byorgey> lispy: fair enough =)
21:00:38 <mzero> more elegant than    head . reverse . sort    - yes, though admittedly elegance is in the eye of the coder
21:00:44 <byorgey> joking aside, I do actually use CftWM as a reference now and then, and am able to glean bits of information out of it
21:01:06 <byorgey> but yeah, it's probably the densest thing I've ever tried to read
21:01:12 <byorgey> that and the quotient containers paper
21:01:18 <edwardk> personally i think the lawvere book isn't a bad way to get started if you are looking for a way to start to _think_ categorically, it gives you enough vocabulary and some of the patterns to kind of see what category theory is all about
21:01:28 <student> mzero: could you possible show it in point free please
21:02:19 <edwardk> that and serge lang's algebra are closely tied for me
21:02:25 <edwardk> in terms of density
21:02:43 <edwardk> the difference being that algebra is 900 pages at that density
21:03:08 <mzero> > let ml = snd . maximum . map (\a -> (length a,a)) in ml $ words "now is the time for all good zorks to come to the aid of their planet"
21:03:09 <lambdabot>   "planet"
21:03:20 <companion_cube> :t maximumBy (compare `on` length)
21:03:21 <lambdabot> forall a. [[a]] -> [a]
21:03:33 <edwardk> maybe half to 2/3rds that density to be fair
21:03:35 <mzero> not that this solution points out a potential flaw in the problem definition
21:04:00 <student> mzero: is that for my solution?
21:04:01 <latros> how does it do that maximum....
21:04:02 <companion_cube> > maximumBy (compare `on` length) $ words "now is the time for all good zorks to come to the aid  of their planet"
21:04:03 <lambdabot>   "planet"
21:04:14 <mzero> what should the answer be if two of the runs have the same maximum length?
21:04:20 <mzero> which one "wins"?
21:04:28 <companion_cube> I was trying with a foldl1, but this is much better
21:04:30 <latros> maximum shouldn't work on a [(Int,String)] should it?
21:04:40 <student> mzero: hmm
21:04:44 <edwardk> latros: why not?
21:04:53 <companion_cube> latros: yes it does, by lexicographic order
21:04:53 <latros> wait WHAT
21:04:56 <lispy> > maximum [(1,"hi"), (2, "bye")]
21:04:56 <lambdabot>   (2,"bye")
21:04:58 <latros> wow.
21:04:59 <latros> that's
21:05:00 <latros> ridiculous
21:05:05 <edwardk> latros: you can order ints and strings separately, you can order pairs of them, and you can order lists of things you can order
21:05:07 <latros> tuples have a comparison instance
21:05:10 <latros> wow
21:05:10 <lispy> > maximum [(1,"hi"), (2, "bye"), (2, "a")]
21:05:10 <mzero> no - if a and b are both Ord, then (a,b) is Ord
21:05:11 <lambdabot>   (2,"bye")
21:05:15 <latros> er, Ord instance
21:05:15 <mzero> this is VERY useful
21:05:21 <companion_cube> latros: that's convenient, no ridiculous :D
21:05:33 <edwardk> latros: its just lexicographical
21:05:33 <cmccann> it's ridiculously convenient is what it is
21:05:34 <lispy> > maximum [(1,"hi"), (2, "bye"), (2, "a"), (2, "z")]
21:05:35 <lambdabot>   (2,"z")
21:05:44 <latros> it's not that there's an ordering that makes sense
21:05:47 <latros> it's that the ordering is built in
21:05:48 <mzero> it is ridiculously convenient!
21:05:59 <edwardk> there is even a monoid on Ordering that is convenient for making these for your own types
21:06:24 <Jesin> > GT `mappend` EQ
21:06:25 <lambdabot>   GT
21:06:28 <hpaste> clown pasted “clown” at http://hpaste.org/63793
21:06:30 <Jesin> > LT `mappend` EQ
21:06:31 <lambdabot>   LT
21:06:32 <mzero> :t snd . maximum . map (\a -> (length a,a))
21:06:33 <lambdabot> forall a. (Ord a) => [[a]] -> [a]
21:06:34 <randomclown> http://hpaste.org/63793
21:06:36 <edwardk> (a,b) `compare` (c,d) = compare a c `mappend` compare b d
21:06:54 <Jesin> > GT `mappend` LT
21:06:54 <randomclown> how can I force "backbuffer" to get filled before system "
21:06:55 <lambdabot>   GT
21:06:57 <student> mzero: so what is the correct alternative to my solutions?
21:06:57 <mzero> Notice that the derived type of my solution points out that it is only well formed, if the elements in the list are Ord
21:07:04 <edwardk> where the monoid is the monoid for lexicographical composition
21:07:05 <Jesin> > LT `mappend` GT
21:07:06 <lambdabot>   LT
21:07:12 <companion_cube> wow, Ordering is a monoid
21:07:18 <randomclown> how can I force "backbuffer" to get filled before system "clear" is called? http://hpaste.org/63793
21:07:30 <Jesin> > mempty :: Ordering
21:07:31 <lambdabot>   EQ
21:07:39 <mzero> student: "correct"? I don't know your problem --- what I do know is that     head . reverse . sortBy    is almost certainly wrong
21:07:40 <edwardk> with the new monoid sugar, that becomes compare a c <> compare b d -- and its even less obtrusive
21:07:49 <companion_cube> student: we wrote several
21:07:58 * cmccann grumbles about (<>)
21:08:00 <lispy> randomclown: it's really hard to say without knowing more.
21:08:13 <randomclown> getData gets a String
21:08:14 <companion_cube> I like maximumBy (compare `on` length), though :)
21:08:14 <Jesin> what's the problem with (<>)
21:08:17 <edwardk> cmccann: meh. you an import Data.Semigroup and get the right one or Data.Monoid and get the crappy one
21:08:20 <randomclown> then I clear the screen
21:08:22 <edwardk> it gives people an upgrade path
21:08:23 <randomclown> then print the string
21:08:35 <student> companion_cube: ohh those were for my question lol
21:08:36 <rwbarton> from the looks of that code getData *is* a String
21:08:44 <cmccann> the problem with (<>) is that it should have been (++)
21:08:46 <lispy> randomclown: basically, you need a seq somewhere, I think
21:08:49 <rwbarton> seeing as you pass it to putStrLn
21:08:52 <edwardk> cmccann: i still disagree there
21:08:57 <Jesin> oh
21:09:02 <mzero> student - the questions Haskell should be leading you to ask is "hey, wait a minute... what DOES that mean when there are two with the same length...."   --
21:09:03 <Jesin> lol
21:09:11 <Veinor> edwardk: more things have Monoid instances then Semigroup instances though
21:09:20 <randomclown> ah ok
21:09:22 <randomclown> thank lispy
21:09:26 <edwardk> cmccann: that could break code that needs (++) to be parametric in the final argument
21:09:32 <Jesin> ?
21:09:41 <Jesin> parametric in the final argument what
21:09:46 <Veinor> edwardk: ?
21:09:50 <edwardk> Veinor: thats because Data.Semigroup isn't standard, fully instantiated there are of course more semigroups than monoids ;)
21:09:51 * Jesin is not familiar with this use of "parametric"
21:10:01 <cmccann> edwardk, I suppose
21:10:01 <lispy> randomclown: but, if getData is in your monad, just changing it to say, backBuffer <- getData, may fix it
21:10:07 <Jesin> actually
21:10:08 <Jesin> [01:12:14]	Veinor	edwardk: more things have Monoid instances then Semigroup instances though
21:10:12 <Jesin> this is false
21:10:15 <randomclown> lispy get data is pure
21:10:29 <randomclown> I'm just a bit confused about how to used seq with a let
21:10:33 <edwardk> jesin: i mean that (++) :: [a] -> [a] -> [a]    -- is parametric in the argument to list
21:10:44 <quintessence> randomclown: you probably want deepSeq
21:10:48 <lispy> randomclown: the easiest thing is to use seq via bang pattern
21:10:54 <Veinor> edwardk: i guess, can you give an example of something that works with (++) but fails with (<>)?
21:10:57 <lispy> randomclown: let !backBuffer = getData
21:11:18 <edwardk> but if you switch to (++) as an alias for mappend then you the individual instances for [a] are chosen per 'a'
21:11:20 <rwbarton> randomclown: you want to make sure backBuffer is totally evaluated so it will be ready to be printed as soon as you've cleared the screen?
21:11:31 <quintessence> lispy: that only forces the first cons
21:11:34 <randomclown> rwbarton: yes
21:11:42 <edwardk> veinor: sure. but almost every such example involves a rank 2 type
21:11:46 <Jesin> instance Monoid a => Semigroup (WrappedMonoid a)
21:11:47 <dobblego> data NonEmptyList a = NEL a [a] -- for the purpose of discussion, has Semigroup but not Monoid
21:11:48 <Jesin> :p
21:11:58 <Veinor> Jesin: that exists for Identity :D
21:11:59 <tgeeky_> edwardk: you missed a verb in that sentence "but if you switch to ..."
21:12:17 <Jesin> ?
21:12:19 <student> companion_cube: so you are saying change it to "longest_run = maximumBy (compare `on` length)"?
21:12:20 <Jesin> oh
21:12:23 <Jesin> wait, what?
21:12:27 <lispy> quintessence: That's true. WHNF.
21:12:27 <Veinor> instance Monoid a => Semigroup (Identity a)
21:12:31 <Jesin> :D
21:12:36 <edwardk> : but if you switch to (++) as an alias for mappend then the individual instances for [a] are chosen per 'a'
21:12:36 <Jesin> that's awesome
21:12:38 <companion_cube> student: well, try it!
21:12:58 <edwardk> jesin: ?
21:13:01 <companion_cube> choose by yourself
21:13:21 <Jesin> edwardk: ??
21:13:25 <edwardk> jesin: ???
21:13:48 <companion_cube> everyone: ???
21:13:53 <Jesin> I was saying "instance Monoid a => Semigroup (Identity a)" was nice
21:13:55 <mzero> student: I don't' know your problem domain --- but    what would longest_run [ [1,2,3], [4,5,6] ]    yield?   what about   longest_run [ ]
21:14:04 <Jesin> if that's what you're asking
21:14:04 <edwardk> did i put that in?
21:14:14 <dmwit> mzero: ??/?/1!?
21:14:15 <Jesin> though... it might have issues
21:14:21 <student> companion_cube: gives an error
21:14:34 <Veinor> i always wondered: why can't you express that every type that implements the Monoid typeclass also implements the Semigroup one?
21:14:35 <Jesin> did you put what in
21:14:38 <Jesin> I don't know
21:14:55 <randomclown> lispy bang pattern didnt work
21:14:58 <edwardk> veinor: you can't write such a constraint without precluding any other semigroups from existing
21:15:00 <mzero> :t maximumBy (compare `on` length)
21:15:00 <dmwit> Veinor: You can. Write class Semigroup a => Monoid a
21:15:01 <lambdabot> forall a. [[a]] -> [a]
21:15:11 <Veinor> edwardk: ah
21:15:13 <lispy> randomclown: how can you tell, BTW?
21:15:13 <hpaste> student pasted “assignment current” at http://hpaste.org/63794
21:15:14 <Jesin> it does seem that you might have issues with Identity-wrapping something that's already a Semigroup, though
21:15:20 <mzero> notice how the type for that one doesn't require  (Ord a) =>
21:15:26 <Jesin> with not inheriting the correct (<>)
21:15:29 <student> mzero: that is what i am currently working with
21:15:31 <edwardk> veinor: you could fix Monoid by adding the superclass constraint
21:15:48 <edwardk> but that was shot down by at least one person who claimed not to know what a semigroup was
21:15:48 <companion_cube> student: what's the type you need, already?
21:15:53 <Veinor> edwardk: haha
21:15:57 <randomclown> because of the sequence. screen should be cleared and data instantly appear, instead of screen cleared and wait 5 seconds then data appears
21:15:58 <Jesin> ........whaaaaaaat
21:15:58 <Veinor> damn non-mathematicians trying to program!
21:16:05 <Jesin> [01:18:51]	edwardk	but that was shot down by at least one person who claimed not to know what a semigroup was
21:16:13 <Jesin> :(
21:16:20 <randomclown> lispy:
21:16:28 <companion_cube> student: yes, you have too give it d1runs, of course
21:16:34 <Jesin> who the hell knows what a Monoid is but doesn't care enough about math to learn what a semigroup is
21:16:58 <latros> I learned about semigroups after I knew about both monoids and groups
21:16:59 <latros> fwiw
21:17:07 <latros> like, quite a while after
21:17:10 <Jesin> so did I, but
21:17:12 <companion_cube> me too
21:17:20 <Veinor> if you know what a monoid is it's not that hard to understand what a semigroup is
21:17:24 <latros> true
21:17:29 <Veinor> 'a semigroup is a monoid that doesn't have an identity element'
21:17:33 <companion_cube> but it's easy to forget the definition
21:17:38 <edwardk> http://www.haskell.org/pipermail/libraries/2011-August/016607.html
21:17:38 <student> companion_cube: ahh see i make stupid mistakes and then can't see them
21:17:38 <Jesin> yeah... shooting down a proposal to fix the language
21:17:46 <Jesin> on that basis, though
21:17:57 <Jesin> seems bleh.
21:18:01 <student> companion_cube: ahh i always do this and then stare at it for hours lol
21:18:05 <edwardk> it rather fundamentally bothered me that his question was answerable by googling 'semigroup
21:18:07 <Veinor> edwardk: what's replicate1p?
21:18:11 <companion_cube> so it's  semigroup > monoid > group ?
21:18:12 <edwardk> and reading the first sentence on the first page
21:18:49 <randomclown> hmm
21:19:03 <randomclown> bang is working
21:19:06 <mzero> ew - did the assigment use that encoding of ingredients as fixed positions in the string?   peppers r = r!!3 == '1'
21:19:08 <randomclown> but not with runhaskell
21:19:10 <mzero> that is gnarly
21:19:10 <edwardk> veinor: http://hackage.haskell.org/packages/archive/semigroups/0.8/doc/html/Data-Semigroup.html
21:19:16 <edwardk> i renamed it to times1p
21:19:19 <Veinor> oh
21:19:55 <lispy> randomclown: I'm slightly concerned you're doing something weird.  You seem to be able to observe evaluation order.
21:19:56 <companion_cube> mzero: they should have done it on the type level? ;)
21:20:01 <edwardk> it uses log n <>'s to build up a <> … <> a out of n + 1 'a's
21:20:10 <mzero> uhm, companion_cube, no
21:20:15 <edwardk> has to be +1 because it doesn't know how to deal with 0
21:20:20 <edwardk> hence the 1p
21:20:22 <mzero> on the type level would imply that values were distinct types
21:20:30 <randomclown> lisp: want to have a look at the code I'm working on?
21:20:38 <randomclown> it's pretty short
21:20:40 <lispy> randomclown: sure
21:20:47 <mzero> just    what would have been wrong with     data Recipe { bacon, ham, sausage, peppers, onions :: Bool }
21:20:52 <hpaste> student pasted “assignment done?” at http://hpaste.org/63795
21:20:54 <mzero> er
21:21:08 <edwardk> named to mirror log1p and their ilk
21:21:09 <mzero>      data Recipe = Recipie { bacon, ham, sausage, peppers, onions :: Bool }
21:21:20 <mzero> bah - modulo spelling errors and such
21:21:39 <student> companion_cube: according to me it is done. could you please verify for me if i have everything.
21:21:39 <companion_cube> right
21:21:56 <companion_cube> student: if it typechecks and gives you the correct answer...
21:22:14 <companion_cube> I did not even read the spec
21:22:33 <mzero> I'm curious where the provided code ended....
21:22:46 <student> companion_cube: hmm not sure about correct answer lol thats why asking any of you guys to check please.
21:22:58 <Jesin> hmm
21:23:03 <companion_cube> come on, it's your homework!
21:23:08 <Jesin> does this channel have an off-topic channel associated with it
21:23:14 <edwardk> #haskell-blah
21:24:49 <student> companion_cube: I think it is good but you guys are the pros so before submitting i would like to confirm. always good for someone to have a quick glance and check if i missed something.
21:24:54 <student> please
21:25:11 <student> just a quick check
21:25:18 <mzero> student - does it work?
21:25:20 <qpu> student: the compiler checks your work for free
21:25:32 <student> it compiles
21:25:40 <mzero> does it give the right answer?
21:25:51 <companion_cube> well, it looks ok
21:25:52 <qpu> student: write some tests if you aren't confident in your solution
21:25:59 <mzero> also - which lines were the provided code to start with?
21:26:13 <student> i am not sure what should be the right answers
21:26:33 <student> its so cluttered and hard to read the output lol
21:26:34 <qpu> student: test smaller subproblems
21:26:40 <companion_cube> yay, the gray code function
21:27:23 <student> you give me something and i will test it
21:28:03 <qpu> student: i assume it prints out a solution. there are requirements enumerated at the top of the file, check that the solution it produced meets those requirements
21:28:42 <ChickenNoodle> Is there a good way to show the steps through a function call without needing to call :step over and over if you don't careabout the variable values until output?
21:30:19 <mzero> student: I don't see, in the generated results, clear answers to the two questions asked
21:31:48 <student> mzero: lol what did i do until now.
21:32:02 <qpu> student: good practice, extra effort for your own benefit, would be to write functions that take a possible solution as a parameter and test that it answers the question, satisfies the criteria, etc programatically and returns True or False
21:32:25 <mzero> no, really, it asks "how many days can I do this?" I don't see a number printed- or clear indication of which sequence is that seuqnece
21:32:46 <mzero> ditto for ii
21:34:48 <mzero> still deeply curious where the original assignment ended....
21:35:10 <mzero> line 34? line 45?
21:35:55 <Zenith77> #php
21:35:58 <Zenith77> err, oops
21:36:33 <companion_cube> not quite the same chan :D
21:36:47 <hpaste> student pasted “assignment original” at http://hpaste.org/63797
21:36:55 <student> mzero: lol there u go
21:37:12 <Zenith77> companion_cube: yeah, I was spamming /join commands and I accidentally the window XD
21:37:49 <student> if i put the following 3 lines at the end : print2	  "Longest legal run of recipes is 3 days"  print2	  "Longest practical joke run of recipes is 7 days"  print2	  "therefore it would be funnier to go with 7 days"
21:37:54 <companion_cube> Zenith77: you accidentally forgot a
21:38:02 <student> mzero: will that do the job?
21:38:03 <mzero> student: really? Ouch!
21:38:23 <mzero> I mean - that was the original assignment? cripes that is non-idomatic Haskell code
21:39:07 <student> mzero: it looks hard you mean?
21:39:23 <mzero> no, I mean the supplied code is just really bad form -
21:39:31 <qpu> non-idiomatic, meaning it doesn't look like Haskell should
21:39:55 <student> mzero: lol k
21:40:20 <mzero> gosh - I wish university prof.s would come here and ask us to vet their problem sets before the unleash them
21:40:23 <qpu> student: why not replace the entire program with those three lines?
21:40:25 <student> mzero: so will adding the 3 lines solve the 2 question:   print2	  "Longest legal run of recipes is 3 days"  print2	  "Longest practical joke run of recipes is 7 days"  print2	  "therefore it would be funnier to go with 7 days"
21:40:27 <mzero> we'd be more than happy to help for nothing!
21:40:44 <mzero> student: you mean printing those fixed strings
21:40:45 <mzero> no
21:41:05 <mzero> does your code compute those?
21:41:15 <ChickenNoodle> Am I invisible or something?
21:41:26 <companion_cube> mzero: that would be great, a veto right for #haskell :D
21:41:27 <student> mzero: uhhm no
21:41:35 <companion_cube> ChickenNoodle: i can see you
21:41:52 <ChickenNoodle> Thanks companion_cube. I've posted a couple questions now and nobody said diddly, so I wasn't sure :)
21:42:02 <mzero> then how od you know the longest legal run is 7 days? I see your code prints a longer one
21:42:29 <companion_cube> ChickenNoodle: oh, it looks like no one masters the debugging functions :)
21:42:32 <companion_cube> (not me, at least)
21:42:57 <mzero> oh - my bad - it is 7 days
21:42:58 <mzero> heh
21:43:08 <ChickenNoodle> companion_cube: So I've been hearing, but I saw my prof do something in class and since he's request traces of the functions we wrote for our homework I'm assuming there's gotta be somethin! Or maybe he's a wizard...
21:43:34 <student> mzero: yes logest run is there, which we wrier doing
21:43:46 <mzero> traces? of Haskell code? what is he thinking    (facepalms)
21:44:16 <ChickenNoodle> mzero: considering how he graded our midterms? Probably thinking of how much he hates us all and wants to afflict his pent up rage with his undergrads upon us. That's my theory anyway.
21:44:21 <companion_cube> ChickenNoodle: have you tried  import Debug.Trace ?
21:44:22 <Veinor> hmm. why doesn't modifyTVar :: (a -> a) -> TVar a -> STM () exist
21:44:35 <companion_cube> there's a trace function in it ;)
21:44:54 <mgsloan>  in my (clearly limited) experience, when taught by professors who aren't passionate about modern Haskell, it's is still taught as "look at this! infinite lists!! Isn't that weird?  Imagine how convoluted programming like this would be!".  Their viewpoint was more accurate when they first learned it, and they didn't bother updating it
21:44:57 <ChickenNoodle> companion_cube: That I have, but it doesn't seem to be doing what I need it to do. Maybe I'm having trouble setting up the breakpoints the way I need, but the intermediate variable values are extraneous to what I really want.
21:44:58 <mzero> trace?!?!  he wants you to put trace in your code?  WHAT?    That isn't how do Haskell!
21:45:29 <ChickenNoodle> mzero: It's not in the code, but rather in accompaniment to it as part of a write up (I hope, at least): "Turn in a trace of execution of your program on the sample strings t1,... t5 shown above."
21:45:35 <companion_cube> mzero: i don't know what he asked, that's just the closest thing to "traces of thefunctions" i know
21:46:29 <mzero> Unless he's asking you to hand write the expansion sequence for a function (which is a useful exercise, for say, foldr ) I can't imagine what he wants, or why
21:46:41 <mzero> I'm tending to give this prof. a C-
21:46:52 <mzero> (can #haskell grad Haskell profs?)
21:47:21 <ChickenNoodle> mzero: which is why that's exactly what I did on monday night/tuesday morning after the kind folks in here talked me through the equally ambiguous programming portion of the assignment. Interestingly, the homework did end up being due Tuesday morning anyway so I stayed up for nothing, but at least I had time to make some improvements and invalidate my laboriously constructed hand expansions.
21:47:25 <ChickenNoodle> Lovely ain't it?
21:47:31 <Veinor> oh it exists in Control.Concurrent.STM.MonadIO
21:47:33 <Veinor> nice
21:47:45 <ChickenNoodle> didn't*** end up due.
21:48:45 <companion_cube> looks like it's Haskell homework's night
21:49:03 <ChickenNoodle> companion_cube: and not even the fun kind ;)
21:56:25 <Adrian> hello everyone
21:56:49 <mzero> okay - so, graycoders -- you want the sad sad truth about that problem set
21:57:18 <mzero> it is clear the prof. doesn't understand how to solve the problem ---
21:57:33 <mzero> cause the order of the bits in the grey code makes a difference
21:57:46 <companion_cube> maybe he just wants something simple for the students to understand
21:57:57 <mzero> so the correct solution to the questions posed aren't even findable with the data structures he set up
21:58:50 <mzero> well, then he should have changed the question he was asking in the problem set so that it was even correct
21:59:25 <Guest93488> ok so i have a question i would like to trace this algorithm
21:59:37 <Guest93488> countSentences x = fromIntegral . length . filter (`elem` a) $ x where a = ",.;!?"
21:59:42 <student> Thank you very much everyone for your help
21:59:44 <companion_cube> homework collision now!
22:00:10 <student> I really appreciate it. Someday I will be here helping people ;)
22:00:19 <CodeWeaverX> Must have been a mighty homework problem
22:00:37 <Guest93488> and I understand this as:
22:00:50 <student> Good night for now.
22:00:56 <Guest93488> i have a list of characters ",.;!?"
22:01:13 <mzero> night 'student
22:01:48 <mzero> why is the prof. so dang fond of integer --- what's his beef with int???
22:01:49 <Guest93488> and i say get element a for every x where a = ....
22:01:57 <latros> or just Integral a
22:01:58 <latros> >.>
22:02:14 <qpu> countSentences x = fromIntegral (length (filter (`elem` ",.;!?")))
22:02:23 <qpu> oops, damn
22:02:26 <Guest93488> ywait
22:03:12 <Guest93488> fromInteger(length(filter('elem' a where a =",...")
22:03:50 <latros> ew
22:03:51 <Guest93488> the part that confused me is the $x as that is the input string on my function
22:03:51 <latros> also
22:03:52 <latros> ``
22:03:54 <latros> not ''
22:03:56 <byorgey> mzero: Int is yucky
22:03:58 <qpu> Guest93488: be careful not to confuse parenthesis with function application
22:04:00 <mzero> that's what the prof. want's a trace of?
22:04:03 <mzero> really?
22:04:27 <qpu> fromIntegral $ length $ filter (`elem` ",.;!?") xs
22:04:28 <Guest93488> $ --this stands for () or for every
22:04:33 <mzero> byorgey: littering your code with fromIntegral all over the place is too
22:04:40 <byorgey> mzero: oh, agreed.
22:04:54 <mzero> trace? trace? what does this guy want?
22:05:00 <Guest93488> to understand
22:05:02 <Guest93488> more about haskell
22:05:05 <Guest93488> i dont quite understand
22:05:13 <Guest93488> the line of code that i just pasted here
22:05:15 * glguy suspects that the prof must have given some "trace" examples in lecture
22:05:16 <qpu> :t ($)
22:05:17 <lambdabot> forall a b. (a -> b) -> a -> b
22:05:18 <Guest93488> and i would like to understand it :)
22:05:41 * hackagebot yjftp 0.3.6.5 - CUI FTP client like 'ftp', 'ncftp'  http://hackage.haskell.org/package/yjftp-0.3.6.5 (YoshikuniJujo)
22:05:54 <byorgey> perhaps be 'trace' they mean show the steps of evaluation?
22:06:00 <byorgey> s/be/by/
22:06:17 <qpu> Guest93488: try defining and using my$ and my. as replacements for $ and .
22:06:57 <Guest93488> i know that a . b = a(b)
22:07:07 <ion> It isn’t.
22:07:09 <quintessence> not quite
22:07:12 <Guest93488> and i know that i cannot write a . b . c i have to write a . b $ c
22:07:15 <Guest93488> i dont understand why
22:07:24 <qpu> :t (.)
22:07:25 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
22:07:28 <latros> (g . f) x = g (f x)
22:07:34 <Guest93488> oh ok
22:07:35 <ion> latros: no
22:07:50 <Guest93488> no ??
22:07:53 <ion> Oh, sorry. I misread the latter part as being “f (g x)”.
22:07:58 <Guest93488> ok
22:08:00 <latros> I was gonna say, what.
22:08:01 <latros> lol
22:08:22 <latros> you may have seen an open circle for function composition in mathematics
22:08:26 <latros> . is exactly that symbol
22:08:27 <ion> My morning caffeine hasn’t quite kicked in yet. :-P
22:08:36 <Guest93488> oke
22:08:38 <latros> (if you haven't, ignore what I just said)
22:08:40 <Guest93488> i got now that
22:08:49 <Guest93488> (g . f ) x = g(f(x))
22:09:01 <Guest93488> so
22:09:06 <Guest93488> i could do smt like
22:09:11 <Guest93488> g . f x
22:09:12 <qpu> Guest93488: btw, you don't need parens to apply a function
22:09:27 <Guest93488> yes i kno i was writing it for my understanding :)
22:09:30 <byorgey> note, g . f x  is not the same as  (g . f) x
22:09:30 <Guest93488> and $
22:09:34 <Guest93488> hmmmmmmmm
22:09:35 <byorgey> they are quite different
22:09:39 <Guest93488> oh
22:09:44 <byorgey> the first is  g . (f x)
22:09:46 <latros> function application has the highest priority of any operation
22:09:52 <latros> so you get what byorgey said
22:09:54 <ion> g . f x = g . (f x) = \y -> g (f x y)
22:10:11 <latros> . has a lower precedence than function application, so f x gets done before .
22:10:18 <Guest93488> ok
22:10:21 <latros> which gives you that somewhat strange object that ion just described
22:10:30 <Guest93488> but if i do  g(f(x))
22:10:34 <Guest93488> i still do the f x first
22:10:41 * hackagebot hake 1.3.7 - make tool. ruby : rake = haskell : hake  http://hackage.haskell.org/package/hake-1.3.7 (YoshikuniJujo)
22:10:41 <ion> Nothing strange about it. You do something like “g . f x” all the time.
22:11:06 <latros> well, yes, Guest93488, but notice that it also wants to give another argument to f first
22:11:22 <latros> that's because you're composing g with a partially applied function (f x)
22:11:56 <latros> so it gives input to the function (f x) and then passes that result on to g
22:12:26 <Guest93488> yes
22:12:52 <Guest93488> g . f x does not equal (g . f) x
22:12:53 <Guest93488> hmm
22:13:19 <mgsloan> g . f $ x = (g . f) x
22:13:27 <quintessence> function application binds tighter than everything else
22:13:28 <mgsloan> ==
22:13:43 <Guest93488> what is a function application
22:14:04 <qpu> in C you would say "calling a function"
22:14:05 <Guest93488> i thought that g . f $ x = g . f (x)
22:14:27 <CodeWeaverX> . binds more tightly than $
22:14:42 <latros> so you get (g . f) x
22:14:51 <latros> $ binds very weakly
22:14:54 <glguy> g . f $ x ===> (g . f) x ==> g (f x)
22:14:55 <latros> which is the entire point of it
22:15:07 <mgsloan> ==> g $ f x
22:15:18 <Guest93488> ok
22:15:31 <CodeWeaverX> f x == ($) f x == f $ x… $ is sort of a 'low priority' version of function application.
22:15:47 <byorgey> s/sort of//
22:15:51 <Guest93488> hmm
22:16:09 <Jesin> I still wish it had a different type signature
22:16:12 <mgsloan> it's a parenthesis replacement
22:16:17 <Guest93488> why is haskell soo hard to understand :)
22:16:24 <Jesin> they should've just defined ($) = id
22:16:26 <Jesin> :p
22:16:49 <latros> my perspective is that haskell makes a lot of the difficulty get handled up front
22:16:52 <CodeWeaverX> Guest… its just that there are a lot of little shortcuts that make it way less clear until you know what the shortcuts mean.
22:16:57 <glguy> Jesin: that would just make it generate less useful type errors
22:17:04 <latros> then once you get it a lot of things are really easy
22:17:06 <Guest93488> ok
22:17:10 <qpu> imagine you had two multiplication operators. * and #, where # is lower precedence than +. if you wanted to write 3 * (4 + 1) you could just write 3 # 4 + 1
22:17:14 <int_> Thanks lispy, That is exactly what I was looking for! explained in detail here http://hackage.haskell.org/trac/ghc/wiki/AmazonEC2
22:17:21 <Jesin> how so
22:17:39 <Guest93488> so # = $ in our case
22:17:42 <latros> also, yes, the piles upon piles of shortcuts and syntactical sugar in haskell are overwhelming
22:17:46 <latros> at first
22:18:20 <CodeWeaverX> Guest:  Indeed… the thing is, with normal function application, it's really just the 'spaces' in an expression.  f x y is a function application of f on parameters x and y, even though there's no 'operator' visible like $
22:18:40 <Guest93488> ok
22:18:44 <Guest93488> so
22:18:47 <Guest93488> i coudl write smt like
22:18:58 <CodeWeaverX> f x y is a high precedence function application.  f$x$y is a low precedence.  You just group them by precedence.
22:19:13 <CodeWeaverX> That includes every operator which fits into a precedence level
22:19:30 <Guest93488> wha does a high precendece function mean
22:19:32 <Guest93488> and low one
22:19:41 <latros> (high precedence) (function application)
22:19:43 <CodeWeaverX> High precedence operators happen before low precedence.
22:19:44 <ion> codeweaverx: Sadly, the associativity of ($) is such that f $ x $ y means f (x y), not f x y. It would be nice to have that changed.
22:19:47 <latros> is how you want to parse that
22:19:57 <CodeWeaverX> Sorry, ion, that's true.  My apologies.
22:19:59 <CodeWeaverX> I forgot.
22:20:03 <CodeWeaverX> But the idea is correct.
22:20:21 <Guest93488> but as stated before
22:20:24 <Jesin> "It would be nice to have that changed."
22:20:26 <Jesin> why
22:20:34 <latros> uh...I can see huge reasons why NOT to make that change
22:20:35 <CodeWeaverX> Anyway, precedence…  its the same reason multiplication happens before addition in a math expression.
22:20:38 <Guest93488> f x y = f (x y)
22:20:40 <CodeWeaverX> * has higher precedence than +
22:20:46 <Guest93488> okey
22:20:50 <qpu> Guest93488: no
22:20:59 <latros> foo $ complicated madness $ even more complicated madness
22:21:02 <latros> should be
22:21:03 <qpu> f x y = (f x) y
22:21:10 <latros> foo (complicated madness (even more complicated madness))
22:21:16 <latros> which it is
22:21:26 <latros> the other way is less useful
22:21:52 <qpu> Guest93488: f $ x y == f (x y)
22:21:54 <latros> in particular it doesn't save you from ))))))))
22:21:57 <ion> “a $ b $ c” can always be written like “a . b $ c” – and the latter form is easier to make less pointful, too. On the other hand, if ($) associated to the left, you could do things like
22:22:07 <ion> foo = some function blahblah
22:22:10 <companion_cube> > iterate ("(complicated madness " ++) ""
22:22:11 <lambdabot>   ["","(complicated madness ","(complicated madness (complicated madness ","(...
22:22:14 <ion>     $ the first parameters blahblahblah
22:22:20 <ion>     $ the second parameter etc
22:22:39 <latros> I think the mnemonic of $ = put a ( where $ is and a ) at the end of the expression
22:22:45 <CodeWeaverX> Adrian1:  Now the conversation has devolved into discussing the benefits of various kinds of associativity, so don't get too lost… :D
22:22:50 <latros> is helpful
22:22:58 <Adrian1> im a bit lost
22:23:00 <Adrian1> but trying
22:23:10 <latros> this is really a theoretical discussion, basically
22:23:16 <Adrian1> so $ and .
22:23:21 <Adrian1> just decide which will go first
22:23:24 <glguy> If you screw up the fixity of $ you break things like this:   forM_ [1..2] $ \ x -> forM [3..4] $ \ y -> print (x,y)
22:23:24 <Adrian1> into my function
22:23:33 <latros> regular function application goes first
22:23:36 <latros> then .
22:23:37 <latros> then $
22:23:37 <byorgey> latros: I don't think it's helpful.  It just replaces real understanding by an incorrect approximation.
22:23:37 <companion_cube> > fix ("(complicated madness " ++) -- yay
22:23:39 <lambdabot>   "(complicated madness (complicated madness (complicated madness (complicate...
22:23:41 <latros> (assuming nothing else is around)
22:23:45 <Adrian1> ok ok i think im gettign it
22:23:55 <CodeWeaverX> latros has a good simple rule of thumb there.
22:24:02 <glguy> whoops, nvm
22:24:02 <CodeWeaverX> Its not bulletproof, but it's good.
22:24:07 <glguy>  :)
22:24:24 * Jesin wonders what the bullet looks like
22:24:26 <nyingen> I also used that rule of thumb when learning haskell
22:24:27 <Adrian1> so f x $ c . b = f(x(b(c)))
22:24:31 <nyingen> now i know better, but it's good for starting out
22:24:37 <ion> λ> let (#) = ($); infixl 0 # in forM_ [1,2] # \x -> forM_ [3,4] # \y -> print (x,y)
22:24:41 <ion> Works just fine.
22:24:42 <latros> careful, adrian
22:24:45 <latros> that's this:
22:24:55 <latros> f x (c . b)
22:25:00 <CodeWeaverX> Remember latros's rule of thumb, plus the idea that higher precedence operators take place before lower precedence operators in the absence of parentheses to override.
22:25:27 <Adrian1> soo c did not get the lowest priority and b got the highest
22:25:39 <qpu> Adrian1: i think you could replace ' ' with ^, '.' with *, and $ with + to understand the implied parenthesization
22:25:40 <latros> umm...not sure what you mean
22:25:41 <CodeWeaverX> Its the operators that have precedence, not the terms.
22:25:45 <latros> yeah
22:26:04 <ion> > let (#) = ($); infixl 0 # in div # 10 + 10 # 2 + 2
22:26:05 <lambdabot>   <no location info>: parse error on input `)'
22:26:18 <Adrian1> im sorry i dont know what # is
22:26:23 <Adrian1> ok so the
22:26:24 <ion> > Just div <*> Just (10 + 10) <*> Just (2 + 2)
22:26:25 <Adrian1> operators
22:26:25 <lambdabot>   Just 5
22:26:40 <ion> The behavior of an infixl ($) would match that, too.
22:27:29 <Jesin> > let {thisWorks = True} in thisWorks
22:27:30 <lambdabot>   True
22:27:33 <Jesin> yay
22:27:36 <Jesin> it parses that
22:27:44 <Jesin> ....I guess it was @pl that couldn't read {}
22:27:47 <ion> > let ($) = (Prelude.$); infixl 0 $ in div $ 10 + 10 $ 2 + 2
22:27:48 <lambdabot>   5
22:27:55 <Adrian1> f b . c $ d . e  = ?
22:28:08 <ion> adrian1: = (f b . c) (d . e)
22:28:31 <Adrian1> ohh
22:28:37 <Adrian1> and thats equal to
22:28:50 <ion> Just expand the definition of (.).
22:28:52 <ion> @src (.)
22:28:53 <lambdabot> (f . g) x = f (g x)
22:28:53 <lambdabot> NB: In lambdabot,  (.) = fmap
22:29:05 <latros> ((f b) . c) (d . e)
22:29:08 <ion> (f b . c) something = f b (c something)
22:29:13 <latros> no
22:29:13 <shachaf> fmap (f b) c (fmap d e) -- Thanks, lambdabot!
22:29:14 <latros> er
22:29:17 <latros> sorry
22:29:19 <latros> yes
22:29:34 <Adrian1> im trying to expand (f b . c) (d . e)
22:29:48 <latros> (f b . c) x = f b (c x)
22:29:50 <latros> so
22:29:51 <Jesin> @unpl (f b . c) (d . e)
22:29:51 <lambdabot> (f b (c (\ k -> d (e k))))
22:29:52 <shachaf> Adrian1: It might help to eta-expand it first.
22:30:00 <Jesin> there you go
22:30:01 <Adrian1> eta - expand ? :))))
22:30:09 <shachaf> I.e., turn it into (\z -> (f b . c) (d . e) z)
22:30:14 <shachaf> Then expand that.
22:30:20 <Jesin> @unpl f b . c $ d . e
22:30:20 <lambdabot> (f b (c (\ m -> d (e m))))
22:30:36 <Adrian1> i just know at this point that \  defines a function
22:30:53 <shachaf> Jesin: I don't imagine Adrian1 is very interested in the specific solution to this problem.
22:30:55 <CodeWeaverX> Yes, a nameless function, called a lambda expression
22:31:00 <qpu> > (\x -> x + 1) 10
22:31:00 <lambdabot>   11
22:31:08 <Adrian1> so if (\x -> x + 1) 10
22:31:09 <Adrian1> yes
22:31:14 * shachaf has the feeling that Adrian1 is jumping ahead a little bit.
22:31:15 <Adrian1> thats what i was typing :))
22:31:23 <CodeWeaverX> :D
22:31:25 <Adrian1> i get this
22:31:29 <Adrian1> with lambada
22:31:38 * shachaf also has the feeling that #haskell isn't helping.
22:31:44 <shachaf> Maybe it's just me.
22:31:45 <Adrian1> it is
22:31:48 <Adrian1> i learned all i know
22:31:50 <Adrian1> from here
22:31:56 <Adrian1> and im progressing :)
22:31:59 <CodeWeaverX> Then you have immense patience. :D
22:32:07 <CodeWeaverX> And a good TMI filter.
22:32:10 <ion> Learning all you know from here might not be the best way. Have you read LYAH?
22:32:12 <ion> @where lyah
22:32:13 <lambdabot> http://www.learnyouahaskell.com/
22:32:20 <CodeWeaverX> Good online book.
22:32:28 <shachaf> Please learn from places that aren't here.
22:32:32 <Jesin> awesome title as well
22:32:38 <CodeWeaverX> Hilarious content too.
22:32:39 <shachaf> This channel is for answering questions that aren't already answered elsewhere.
22:32:43 <Adrian1> yes i read that but haskell is soo diffrent for me than java and c
22:32:47 <Adrian1> that i have trouble understanding it
22:32:55 <Adrian1> ok :(
22:33:06 <lukish> What is ""::String analog for ByteString?
22:33:15 <qpu> Adrian1: another good reference is Real World Haskell
22:33:20 <shachaf> Adrian1: You can still ask questions in here, of course.
22:33:30 <ion> > Data.ByteString.empty
22:33:31 <lambdabot>   Not in scope: `Data.ByteString.empty'
22:33:41 <ion> > BS.empty
22:33:42 <lambdabot>   ""
22:33:49 <shachaf> But ignoring all other content just to have people type answers to you in real-time is kind of pointless.
22:33:51 <Adrian1> u guys play with haskell as a hobby?
22:34:09 <shachaf> Maybe we need a #haskell-beginners channel.
22:34:11 <CodeWeaverX> I wish I could do it as a job. :)  I understand some people do.
22:34:28 <CodeWeaverX> Problem with that kind of channel is populating it not just with beginners.
22:34:50 <tikhonjelvis> It's a hobby for me, but I'm probably going to have a job with it over the summer.
22:35:08 <tikhonjelvis> Of course, that's also true of programming in general :)
22:35:15 <CodeWeaverX> :D
22:36:02 <CodeWeaverX> Learning from people in realtime on a chat channel may not be practical… but it definitely helps breed enthusiasm.
22:36:13 <CodeWeaverX> If you've got friendly enthusiasts.
22:36:33 <tikhonjelvis> Hmm, anybody know if I can easily make | an electric character in haskell-mode?
22:36:48 <tikhonjelvis> Without writing a function for it myself, I mean.
22:37:03 <CodeWeaverX> I think my brain froze.  "electric character"?
22:37:13 <ion> codeweaver: “haskell-mode” is probably a hint.
22:37:15 <ion> x
22:37:17 <tikhonjelvis> It just means it auto-indents.
22:37:20 <companion_cube> CodeWeaverX: you know, your keyboard electrocutes you when you type it?
22:37:23 <tikhonjelvis> Emacs has it's own terminology.
22:37:28 <CodeWeaverX> Heehee
22:37:33 <CodeWeaverX> Fair enough
22:37:35 <tikhonjelvis> We're too cool for your standard, mortal lexicon.
22:37:56 <tikhonjelvis> That's why we call windows frames, cutting killing and pasting yanking.
22:38:11 <Adrian1> countSentences x = fromIntegral . length . filter (`elem` a) $ x where a = ",.;!?" = fromIntegral $ length $ filter (`elem` ",.;!?") xs
22:38:14 <Enigmagic> they learned from the best
22:38:15 <CodeWeaverX> decades in the industry, and I'm still stumbling around in lexicon hell.  I blame all of you. ;)
22:38:20 <ion> In Vimland we call copying yanking. :-)
22:38:38 <tikhonjelvis> Oh yeah, CS people are horrible with words.
22:38:48 <tikhonjelvis> Some words have too many meanings--functor, for example.
22:38:56 <qpu> math people are worse
22:39:07 <tikhonjelvis> It's one thing in Java, something similar in C++, something *different* in ML and something differenter-yet in Haskell.
22:39:10 <ion> adrian1: If you have more than zero or one $ on a line you might be using them too much.
22:39:11 <companion_cube> titles of math papers make me dream
22:39:26 <companion_cube> tikhonjelvis: wait, what are functors in java?
22:39:31 <ion> adrian1: Btw, “fromIntegral . length” → genericLength
22:39:42 <Adrian1> thank you
22:39:44 <tikhonjelvis> ghetto functions
22:40:05 <companion_cube> ion: where does genericLength come from?
22:40:07 <tikhonjelvis> Classes that implement an interface with a single method called run or something like that.
22:40:09 <ion> @hoogle genericLength
22:40:10 <lambdabot> Data.List genericLength :: Num i => [b] -> i
22:40:13 <qpu> companion_cube: i beleive that referes to anonymous inner classes that instantiate an interface with one method
22:40:14 <companion_cube> tikhonjelvis: oh, this
22:40:20 <companion_cube> I did not know it had a name
22:40:25 <tikhonjelvis> In C++ it's like that, except you get to overload operator().
22:40:38 <tikhonjelvis> It's literally the stupidest thing I ever learned in any of my CS classes.
22:40:55 <qpu> java was for me too!
22:41:01 <companion_cube> C++ has proper functions
22:41:02 <tikhonjelvis> Because you know what's just as good as a lambda? An anonymous inner class implementing a silly interface with a single method.
22:41:16 <companion_cube> and now it has lambdas, yay
22:41:27 <tikhonjelvis> companion_cube: I think any object overloading operator() is called a functor by C++ people.
22:41:31 <tikhonjelvis> But I'm not a C++ person.
22:41:34 <tikhonjelvis> I just saw it on SO :)
22:41:36 <companion_cube> lulz
22:41:37 <CodeWeaverX> tik: tis true.
22:41:47 <companion_cube> everybody know the true functors are the ocaml ones ;)
22:41:49 <CodeWeaverX> tik:  Poor man's lambdas.  They work okay though
22:42:01 <tikhonjelvis> CodeWeaverX: For very relative values of "okay".
22:42:13 <CodeWeaverX> tik: Naturally.  You work with what you got to get the job done. :)
22:42:40 <tikhonjelvis> Over the summer I worked at a company that disagreed and wrote their own language that was sort of like Java with lambdas and some other stuff.
22:42:40 <nyingen> even Java?
22:42:45 <tikhonjelvis> It was much nicer than using Java.
22:42:55 <nyingen> er, that was to CodeWeaverX
22:43:25 <qpu> nyingen: when all you have is a hammer..
22:43:27 <CodeWeaverX> nyingen: Even Java.  I'm a proponent of problem solving over language loyalty.
22:43:34 <nyingen> lol
22:43:42 <nyingen> name a feature you like from language X. Java doesn't have it
22:43:48 <MaskRay> ion: do you mean  f $ g $ h a  --> f . g . h $ a  .  the transform leads to more operators
22:43:59 <nyingen> brings new meaning to the common jab "lowest common denominator"
22:44:12 <companion_cube> nyingen: java has a GC!
22:44:15 <qpu> nyingen: ... you implement a NailFactoryFactory so you can use the hammer
22:44:15 <nyingen> pfft
22:44:20 <nyingen> qpu: right.
22:44:47 <ion> maskray: or (f . g . h) a perhaps. Avoiding all brackets might not always be the best thing to do.
22:45:23 <nyingen> I remember this guy once kept trying to tell me Java was great because it had generics. I told him that concept was irrelevant in practically every other language. "But Java has generics!"
22:45:36 <nyingen> "You don't understand -- this amplifier goes up to 11!"
22:45:36 <tikhonjelvis> annoying generics
22:45:39 <Jesin> lol
22:45:41 <sordina> Is there anything similar to quickcheck for profiling?
22:46:00 <CodeWeaverX> I actually never liked GCs until I got to haskell.  I still have some problems with not being able to control that cpu spike, but none of my haskell projects have gotten realtime enough to matter yet.
22:46:07 <nyingen> And I say this as someone who does a lot of Java programming, unwillingly. I'll stop ranting now, this is #haskll not #java-blows
22:46:07 <qpu> sordina: not sure but hpc (haskell program coverage) might do it
22:46:29 <tikhonjelvis> nyingen: Heh, I know exactly how you feel. I have to use an annoying language against my will too.
22:46:33 <sordina> qpu: I'll check it out.
22:46:41 <companion_cube> nyingen: sorry, in which language are generics irrelevant?
22:46:58 <companion_cube> let say, "parametric polymorphism"
22:47:08 <ion> codeweaverx: Erlang has an independent GC for every process, which is kind of nice. Perhaps one could create guaranteed share-nothing threads with message passing in Haskell and have independent GC for them, too.
22:47:09 <sordina> qpu: Wouldn't it be neat thought to have an argument provide various profiling test cases?
22:47:10 <Jesin> Python's one example
22:47:14 <MaskRay> ion: may i ask why the usage of $ chain is not considered good practice?
22:47:34 <nyingen> companion_cube: Oh, I just meant that Java's belated implementation of generics doesn't make a good impression against other programming languages in general. It's not like it was a revolutionary feature
22:47:38 <companion_cube> Jesin: oh yeah, that's right, dynamically typed don't care
22:47:39 <tikhonjelvis> MaskRay: You can extract f . g but not f $ g.
22:47:52 <companion_cube> nyingen: it's still better than no generics at all
22:47:58 <companion_cube> trust me, I write C currently
22:47:58 <nyingen> companion_cube: that is true.
22:48:05 <tikhonjelvis> MaskRay: So you can refactor a composition into a function much more easily than an application.
22:48:13 <qpu> sordina: i wonder how well it will work. laziness might make things weird?
22:48:23 <tikhonjelvis> MaskRay: Also, it just looks better.
22:48:24 <CodeWeaverX> ion:  I'm not sure what the right answer is.  In java I nicely got around it by managing my own object pools.  In haskell I don't have that choice.  I'm not sure how multiple threads would help, precisely.
22:48:42 <qpu> sordina: eg, who gets billed for runtime for evaluating a thunk
22:49:24 <Adrian1> im trying to work on this : http://pastebin.com/i3caXi9u , and i think i should use a foldr function on the words(a long string) somehow so i get smt like: /*\ foldr myFunction 0 myfirstword /*\ and ill my function so it will return how many syllables i find in that word and just keep going, do u guys think that I am approaching this correctly?
22:49:25 <companion_cube> CodeWeaverX: if I may ask, why do you need such tight control?
22:49:26 <mauke> The paste i3caXi9u has been copied to http://hpaste.org/63798
22:49:47 <qpu> companion_cube: i'm sometimes stuck in Java 1.4 code (no generics), and i agree -- they are appreciated
22:49:54 <companion_cube> awwwwww
22:50:00 <CodeWeaverX> cube:  If I were doing something realtime, even soft realtime, not being able to control a cpu spike from GC is at best a nuisance.
22:50:01 <companion_cube> it must hurt so badly
22:50:31 <qpu> companion_cube: i have a good sense of humor about it
22:50:36 <ChickenNoodle> night, everybody. Thanks companion_cube for helping me out earlier.
22:50:43 <companion_cube> you're welcome
22:50:45 <companion_cube> good night
22:51:13 <MaskRay> tikhonjelvis: i preferred . chains before but could not tell why. thank you for giving the reason
22:53:00 <tansell-laptop> Tonight's Functional Programming Sydney Group is being (experimentally) live streamed at http://view.streamti.me/sypy
22:53:15 <Adrian1> lol
22:55:37 <Adrian1> the stream isnt working for me
22:55:42 <tansell-laptop> (sorry about the URL - didn't have time to fix it)
22:55:43 <covi> Hi folks. Why typying   fibs = 0 : 1 : zipWith (+) fibs (tail fibs)   in ghci results in errors?
22:56:02 <tikhonjelvis> You should probably add a type signature.
22:56:10 <ion> GHCi isn’t like a Haskell source file. It’s more like lines within a do block.
22:56:19 <ion> Try this: let fibs = … in fibs
22:56:42 <tikhonjelvis> Happily the new version is going to accept all sorts of declarations soon :)
22:57:09 <covi> ion: thanks!
22:57:11 <covi> tikhonjelvis: ty
22:57:24 <MaskRay> the fibs may not be shared between (fibs) and (tail fibs)
22:57:52 <qpu> covi: you can read more about "let polymorphism"
22:58:25 <tikhonjelvis> MaskRay: It works fine for me in GHCi.
22:59:13 <Adrian1> ill try my luck another time, i wont resend this again if no1 will answer, sorry for persistence : im trying to work on this : http://pastebin.com/i3caXi9u , and i think i should use a foldr function on the words(a long string) somehow so i get smt like: /*\ foldr myFunction 0 myfirstword /*\ and ill write myFunction so it will return how many syllables I find in that word and just keep going,
22:59:14 <Adrian1> do u guys think that I am approaching this correctly?
22:59:14 <mauke> The paste i3caXi9u has been copied to http://hpaste.org/63798
23:00:30 <nyingen> Adrian1: sure, that sounds plausible
23:01:05 <nyingen> except that you'd fold on allTheWords, not myFirstWord
23:01:18 <MaskRay> tikhonjelvis: whether it is more appropriate to use a `let fib' clause since the behavior of compiler cannot be predicated
23:01:41 <nyingen> Adrian1: also, in general foldr should not be used; use foldl or foldl' unless you know the list might be infinite
23:01:43 <Adrian1> ok :) thats good
23:01:55 <tikhonjelvis> MaskRay: It's a let for GHCi rather than in actual code.
23:02:06 <nyingen> for your problem it's no big deal, but foldl' is far more efficient
23:02:08 <Adrian1> but if u see in the requirements it wants me to check if the last letter of a word is e
23:02:35 <Adrian1> if it is i should return a sum of syl + 1, if it is not i should return a sum of syl
23:03:08 <nyingen> well, instead of counting the syllables, you could generate the list of syllables
23:03:40 <nyingen> if you add a 'end-of-word' token, some symbol like '$', then you can later filter out those syllables which end with 'e$'
23:03:53 <nyingen> er, that ARE 'e$'
23:04:59 <tikhonjelvis> Hmm, how does Haskell deal with parsing arbitrary operators efficiently?
23:05:06 <Adrian1> ok i get it i have no ideea how to add a token in a huge list could u tell me some functions that would be useful please
23:07:20 <Adrian1> hmm
23:07:23 <Adrian1> ok im dumb
23:08:03 <nyingen> > map (\x -> x ++ "$") (words "i ate soylent green")
23:08:04 <nus> @src foldr
23:08:04 <lambdabot> foldr f z []     = z
23:08:05 <lambdabot> foldr f z (x:xs) = f x (foldr f z xs)
23:08:05 <lambdabot>   ["i$","ate$","soylent$","green$"]
23:08:16 <nyingen> Adrian1: you see what I mean?
23:08:18 <Adrian1> i could just get the first word and just simply say smt like  x |
23:08:19 <Adrian1> yes
23:09:05 <Adrian1> but how do i check if my last char is an e
23:09:08 <Adrian1> i would do smt like
23:09:12 <nyingen> Adrian1: I'm just demonstrating how you would append a token to each word, though. that's not quite how you would do it for your problem
23:09:21 <Adrian1> yes
23:09:36 <qpu> @src last
23:09:36 <lambdabot> last [x]    = x
23:09:36 <lambdabot> last (_:xs) = last xs
23:09:37 <lambdabot> last []     = undefined
23:09:45 <nyingen> with this approach, you don't even need to check whether the last character is 'e', because any syllable involving 'e$' doesn't count
23:09:47 <Adrian1> ok
23:10:15 <nyingen> I'm sure there are at least a couple ways to solve the problem though, so by all means try something else
23:10:33 <Adrian1> im working on it :)
23:12:40 <Adrian1> can i use @src as well?
23:12:50 <Adrian1> or only some people are priviliged?
23:13:32 <MaskRay> what if concerns with the memory usage of `let fibs = 0 : scanl(+) 1 fibs' or making it a top-level CAF
23:14:49 <Sgeo> Adrian1, @src somewhat sucks, but you can use it./
23:14:53 <nyingen> Adrian1: @src is just a command to the bot in this channel which shows the source code of certain library functions. You can look at the source of any library function by using the documentation for GHC
23:16:35 <Adrian1> okay thank you
23:16:43 <tikhonjelvis> There are a bunch of source links in the documentation that do exactly what you expect. I won't tell you how embarassingly long it took me to notice them :)
23:17:29 <lukish> color2Triple color = (red color, green color, blue color)
23:17:31 <Adrian1> can i paste 2/3 lines of code here or should i use hpaste instead?
23:17:37 <lukish> Is it rewritable?
23:17:54 <lukish> @pl color2Triple color = (red color, green color, blue color)
23:17:54 <lambdabot> color2Triple = ap (liftM2 (,,) red green) blue
23:18:04 <nyingen> Adrian1: if it's more than 1 line, I'd use hpaste
23:18:40 <tikhonjelvis> Wait, why wouldn't liftM3 (,,) work?
23:18:47 <tikhonjelvis> Let me think about this for a second...
23:18:57 <tikhonjelvis> And by "think" I mean fire up GHCi.
23:20:20 <Adrian1> can i define
23:20:28 <Adrian1> extra variables in a function
23:20:36 <Adrian1> apart from the input variables and the return variables?
23:20:39 <nyingen> sure
23:20:48 <nyingen> you use 'let'
23:20:49 <qpu> yes, with "let" or "where"
23:21:06 <nyingen> If you haven't already, maybe take a look at "Learn You A Haskell" or even the Haskell wikibook
23:21:18 <MaskRay> tikhonjelvis: what if concerns with the memory usage of `let fibs = 0 : scanl(+) 1 fibs' or making it a top-level CAF
23:21:26 <nyingen> Adrian1: those resources will tell you all about 'let'
23:22:10 <tikhonjelvis> MaskRay: I was disconnected for a bit, so I probably missed a couple of the things you said a couple minutes back.
23:22:32 <Adrian1> so far i find this website http://zvon.org/other/haskell
23:22:36 <Adrian1> to be the most clear one
23:23:31 <tikhonjelvis> lukish: Yeah, liftM3 (,,) red green blue would work. I actually think that's pretty readable :)
23:24:24 <Adrian1> right now im here am i on tthe right track :) http://hpaste.org/63799 ?
23:24:50 <tikhonjelvis> Ooh, time to abuse unicode and have a variable called λ!
23:24:57 <Adrian1> oh i should to a fromIntegral
23:25:09 <MaskRay> tikhonjelvis: noticed, i said nothing before that
23:25:36 <tikhonjelvis> ah, okay
23:26:07 <tikhonjelvis> But yes, your concerns about using a let here are valid. You wouldn't want to use on in an actual source file.
23:26:35 <MaskRay> @src scanl
23:26:36 <lambdabot> scanl f q ls = q : case ls of
23:26:36 <lambdabot>     []   -> []
23:26:36 <lambdabot>     x:xs -> scanl f (f q x) xs
23:26:46 <tikhonjelvis> Of course, I'm not an expert on these matters—I'm just repeating stuff I've heard elsewhere :P
23:27:36 <MaskRay> @src scanl'
23:27:36 <lambdabot> Source not found. Where did you learn to type?
23:27:42 <qpu> BURN
23:27:52 <MaskRay> sigh, no strict one
23:28:34 <Enigmagic> why would you want a strict scanl?
23:29:32 <MaskRay> to obtain a constant-memory `take 1000000 fibs', fibs = 0 : scanl (+) 1 fibs
23:29:46 <MaskRay> sorry, it's to obtain a constant-memory ` fibs!!100000', fibs = 0 : scanl (+) 1 fibs
23:31:37 <MaskRay> i've read some wiki about lazy evaluation and want to gain profound understanding
23:37:55 <Adrian1> what does this represent (a -> b -> a) -> a -> [b] -> a //\\ does it mean that i takes smt of type a and a list and it returns smt of type a eg a = int but i dont understand that tuliple at the beggining why is it there
23:38:41 <dobblego> Adrian1: it is a type signature, probably of foldr; what exactly are you misunderstanding?
23:38:48 <dobblego> what do you mean by smt?
23:38:55 <tikhonjelvis> It means you can take a two argument function (a -> b -> a) that returns the same type as its first argument, then a value of that type, then a list of the other type and get a value of the first type back.
23:38:59 <ion> Aren’t higher-order functions discussed in LYAH?
23:39:11 <erus`> How do I describe one part of a Sum type?
23:39:24 <ion> One part?
23:39:41 <dobblego> the operand to summation?
23:39:57 <erus`> i have the type A + B
23:40:12 <erus`> how do i describe an instance of A which is an A + B
23:40:47 <erus`> do i just keep an index to which part of the sum it is?
23:41:09 <erus`> (because A and B could both be the same type)
23:42:36 <erus`> im not sure that make any sense...
23:44:30 <qpu> does haskell have sum types? i found "Sum" in prelude, but it's just the monoid
23:44:45 <qpu> or did you mean generally, not in haskell?
23:44:46 <erus`> qpu data SumType = A | B
23:45:00 <erus`> yeah i meant in general
23:45:05 <ion> Those A and B aren’t types.
23:45:08 <tikhonjelvis> erus`: That declares two nullary constructors A and B.
23:45:18 <qpu> oh, i don't know off the type of my head but TAPL covers the topic fairly well
23:45:25 <tikhonjelvis> erus`: So SumType is just an enum of A and B, really.
23:45:29 <qpu> i'm not sure what it says about A | A
23:45:33 <tikhonjelvis> If you define it that way, I mean.
23:45:41 <erus`> qpu data SumType = A Int | B Int
23:46:23 <tikhonjelvis> Now each version is "tagged" with A or B, so you can tell them apart that way. Or am I misunderstanding something?
23:46:35 <qpu> do you mean untagged unions?
23:46:51 <tikhonjelvis> case x of { A n -> 1; B n -> 2 } or something
23:46:52 <xz> hi, I'm trying to come up with a good design for the following kind of program: I have a typeclass "Loggable a" describing things that can be serialised as instructions to build them by a virtual machine (log :: a -> IO ()) and can be stored in a map (key :: a -> KeyType). Now I want to write code that threads around a Map and every time one of these loggable things is built or referred to...
23:46:54 <xz> ...either logs the instructions to build it and stores it in the map, or finds it in the map and logs instructions to look it up instead (the virtual machine also has a map).
23:48:26 <xz> basically, I want to write my program so that as it's running in haskell it also outputs instructions to rerun it on the vm, and does automatic hash-consing
23:49:27 <qpu> erus`: i haven't seen untagged unions in haskell, but someone pulled it off in scala (kind of). it looked something like foo(x: Int | String | Float): Int = match x { case x: Int => ...; case x: String => ...; etc }
23:49:57 <qpu> erus`: there were limitations though. it probably won't translate to haskell easily
23:50:35 <qpu> erus`: i think it was unsound, actually
23:50:53 <erus`> so i need a tag field if i want haskell style data structures
23:51:17 <qpu> http://www.chuusai.com/2011/06/09/scala-union-types-curry-howard/
23:51:25 <qpu> erus`: as far as i know, yeah
23:51:38 <erus`> makes sense really :)
23:51:54 <qpu> erus`: maybe you can do some magic with Data.Dynamic or Typeable or something, i'm not familiar with those libraries
23:52:26 <qpu> erus`: otherwise you might as well just use a tuple
23:52:44 <qpu> erus`: err, sorry... ignore that
23:53:09 <tikhonjelvis> This is interesting--Emacs seems to crash when I try to type σ <- in my source file...
23:54:27 <tikhonjelvis> You'd think I'd learn after the first two times, but no.
23:55:46 * hackagebot ghc-mod 1.10.7 - Happy Haskell programming on Emacs/Vim  http://hackage.haskell.org/package/ghc-mod-1.10.7 (KazuYamamoto)
23:55:56 <qpu> erus`: i meant to say Either. that is nested Eithers or build your own with higher arity... Left | Right | ... Middle :]
23:57:11 <tikhonjelvis> Okay, turning off font-lock-symbols fixed the problem, but it isn't a very satisfying fix.
