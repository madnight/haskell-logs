00:00:26 <adnauseam> aye aye - hope i dont tire you lot with my questioning =}
00:00:40 <srhb> Not at all, I was there just a few weeks ago
00:02:21 <tikhonjelvis> Indoctrination newcomers is always fun.
00:03:51 <tikhonjelvis> Oops, meant indoctrinating.
00:04:09 <kir> tikhonjelvis, what is indoctrinating? =)
00:04:14 <tikhonjelvis> I still haven't got a hang of Emacs's magical spellcheck autocomplete.
00:04:22 <srhb> I don't think I ever will.
00:04:39 <tikhonjelvis> kir: It's like teaching
00:04:48 <tikhonjelvis> except more cultish
00:04:49 <kir> tikhonjelvis, ah
00:05:07 <tikhonjelvis> so more like propoganda than teaching per se
00:06:14 <adnauseam> it's the imprinting of values onto naive subjects
00:06:46 <tikhonjelvis> Abusing TeX mode some more: naïve.
00:08:40 <tikhonjelvis> Without the ̈, there is no good way to know how "naïve" is pronounced.
00:09:19 <tikhonjelvis> Which gets me about a lot of English words: I comically mispronounce words I've just learned constantly.
00:10:04 <aib> only to be expected. English is not phonetic - what's the actual term?
00:10:55 <aib> (it's "phonetic")
00:15:37 <Jafet> COMMA WITH DIAERESIS
00:15:59 <tikhonjelvis> ,̈
00:16:15 <tikhonjelvis> ...
00:16:31 <Eduard_Munteanu> Sounds like a painful affliction :P
00:16:48 <tikhonjelvis> ⌢̈
00:17:49 <Jafet> Not to be confused with colon cancer
00:17:57 <tikhonjelvis> ⋯̈
00:18:13 <Eduard_Munteanu> Semicolon is what you get after surgery? :P
00:19:31 <tikhonjelvis> Hmm, does Haskell accept variable names combined with accents like that?
00:19:43 <tikhonjelvis> > let ä = 10 in ä
00:19:44 <lambdabot>   <no location info>: lexical error at character '\776'
00:19:47 <tikhonjelvis> aww
00:19:56 <tikhonjelvis> > let ä = 10 in ä
00:19:57 <lambdabot>   10
00:20:14 <tikhonjelvis> ä̈
00:20:18 <mekeor> what was the difference?
00:20:30 <tikhonjelvis> ä is one character, ä is two.
00:20:37 <mekeor> ah, okay
00:20:40 <tikhonjelvis> You can also get ä̈.
00:20:40 <mekeor> äöü
00:20:48 <mekeor> nice
00:20:56 <Eduard_Munteanu> What's wrong with two characters?
00:21:02 <tikhonjelvis> Haskell doesn't accept it.
00:21:10 <tikhonjelvis> > let ä = 10 in ä
00:21:11 <lambdabot>   <no location info>: lexical error at character '\776'
00:21:12 <mekeor> tikhonjelvis: this is two chars: ạ
00:21:13 <tikhonjelvis> vs
00:21:19 <tikhonjelvis> > let ä = 10 in ä
00:21:19 <lambdabot>   10
00:21:41 <Eduard_Munteanu> No visual difference here :/
00:21:44 <tikhonjelvis> yeah
00:21:50 <Jafet> > "ä"
00:21:51 <lambdabot>   "a\776"
00:21:51 <mekeor> well, the two dots seem to be not a literal, for haskell, or?
00:21:57 <Jafet> > "ä"
00:21:57 <lambdabot>   "\228"
00:22:21 <mekeor> just like that's invalid:
00:22:30 <mekeor> > let a§ = 5 in a§
00:22:31 <lambdabot>   <no location info>: parse error on input `='
00:22:44 <Eduard_Munteanu> How do you "separate" them? Isn't it supposed to encode the same way in UTF8? I mean, a followed by the "
00:22:52 <Jafet> > "СССР"
00:22:53 <lambdabot>   "\1057\1057\1057\1056"
00:23:08 <mekeor> wow
00:23:10 <tikhonjelvis> > let С
00:23:10 <lambdabot>   <no location info>: parse error (possibly incorrect indentation)
00:23:21 <tikhonjelvis> > let С = 10 in С
00:23:21 <lambdabot>   Not in scope: data constructor `
00:23:28 <mekeor> lol
00:23:30 <tikhonjelvis> > let с = 10 in с
00:23:31 <lambdabot>   10
00:23:35 <tikhonjelvis> > let с = 10 in c
00:23:36 <lambdabot>   c
00:23:39 <Jafet> Eduard_Munteanu: characters are made out of one or more code points
00:23:44 <mekeor> what?
00:23:51 <tikhonjelvis> Different "c"s
00:23:56 <mekeor> okay..
00:24:04 <mekeor> > "c"
00:24:05 <lambdabot>   "c"
00:24:07 <tikhonjelvis> One's Cyrillic
00:24:09 <mekeor> a
00:24:11 <mekeor> h
00:24:13 <tikhonjelvis> > "с"
00:24:13 <lambdabot>   "\1089"
00:24:20 <mekeor> i see, okay :)
00:24:23 <tikhonjelvis> > "c"
00:24:24 <lambdabot>   "c"
00:24:47 <Jafet> (Does this mean I can't name a constructor after my favourite rock band?)
00:25:04 <tikhonjelvis> afraid not :(
00:25:15 <aib> > let (Α,Ω)=(1,5) in [Α..Ω]
00:25:17 <lambdabot>   Not in scope: data constructor `
00:25:48 <srhb> > isSymbol ̈
00:25:49 <lambdabot>   <no location info>: lexical error at character '\776'
00:25:54 <srhb> Oops
00:25:59 <srhb> > isSymbol ' '̈
00:26:00 <lambdabot>   <no location info>: lexical error at character '\776'
00:26:03 <tikhonjelvis> heh
00:26:13 <tikhonjelvis> It's too clever for your quotes :)
00:26:18 <srhb> Apparently.
00:26:29 <tikhonjelvis> Maybe try escaping it?
00:26:35 <tikhonjelvis> \̈
00:27:23 <srhb> > isSymbol '\ '̈
00:27:24 <lambdabot>   <no location info>:
00:27:24 <lambdabot>      lexical error in string/character literal at chara...
00:28:19 <Jafet> @let ɑ = minBound; ω = maxBound
00:28:20 <lambdabot>  Defined.
00:28:34 <srhb> I think it just does not like diacritics in general
00:29:20 <Eduard_Munteanu> > [ɑ..ω]
00:29:22 <lambdabot>   [()]
00:30:34 <tikhonjelvis> > isSymbol '\776'
00:30:35 <lambdabot>   False
00:32:52 * hackagebot GLFW-b 0.1.0.2 - GLFW bindings  http://hackage.haskell.org/package/GLFW-b-0.1.0.2 (BrianLewis)
00:33:24 <Jafet> > generalCategory '\776'
00:33:25 <lambdabot>   NonSpacingMark
00:40:30 <adnauseam> listElements [] = Nothing
00:40:39 <adnauseam> makes ghci angry
00:40:41 <adnauseam> :|
00:40:49 <tikhonjelvis> Did you change the type appropriately
00:40:54 <adnauseam> hrm
00:41:09 <adnauseam> i don't think so
00:41:25 <adnauseam> oh one moment
00:42:19 <adnauseam> just changed it into a string and all is good - now i got a barrage of new errors ;p
00:42:52 <adnauseam> ghci does not agree with listElements (a:xs) = show a ++ listElements [x | x <- tail xs]
00:43:00 <tikhonjelvis> The return type has to include a Maybe
00:43:14 <adnauseam> i really need to look this Maybe up.
00:43:30 <tikhonjelvis> Yeah. It's like a type-safe version of null.
00:43:55 <adnauseam> i thought my listElements [] = "End of list"
00:44:00 <adnauseam> comes instead of null
00:46:18 <adnauseam>  listElements :: Maybe [a] -> a
00:46:19 <adnauseam> '
00:46:20 <adnauseam> ?
00:46:58 <adnauseam> negatory
00:47:01 <tikhonjelvis> No, it's the other way around: listElements :: [a] -> Maybe a
00:47:57 <tikhonjelvis> It makes sense—you're maybe returning an a, maybe not :)
00:48:30 <mekeor> adnauseam: maybe is easy. for example, a value of type `Maybe Bool' is either `Just True' or `Just False' or `Nothing'.  so, with `Just' you can put a value into that "container".  use the case-expression to get a value out of the container.
00:49:27 <mekeor> well, case-expr or the `maybe'-function…:
00:49:30 <mekeor> @hoogle maybe
00:49:31 <lambdabot> Prelude data Maybe a
00:49:31 <lambdabot> Data.Maybe data Maybe a
00:49:31 <lambdabot> Prelude maybe :: b -> (a -> b) -> Maybe a -> b
00:51:34 * adnauseam scratches his head
00:52:38 <ChristianS> adnauseam: what exactly is your listElements function meant to do?
00:52:59 <adnauseam> list the members of a list
00:53:13 <adnauseam> listElements :: [a] -> Maybe String
00:53:13 <adnauseam> listElements [] = Nothing
00:53:13 <adnauseam> listElements (a:[]) = show a
00:53:14 <adnauseam> listElements (a:xs) = show a ++ listElements [x | x <- tail xs]
00:53:33 <tikhonjelvis> Why do you do [x | x <- tail xs] ?
00:53:43 <adnauseam> trying :p
00:53:44 <mekeor> adnauseam: Just (show a)
00:53:47 <adnauseam> works in ghci :p
00:53:56 <tikhonjelvis> Yes, but it's the same as just tail xs
00:54:04 <adnauseam> im just training :p
00:54:10 <tikhonjelvis> You're saying something like for each x in the tail of xs, return x.
00:54:21 <adnauseam> ill probably recreate many other commands that already exist in haskell
00:54:24 <ChristianS> adnauseam: yes, Just is needed for the not-Nothing cases
00:54:36 <adnauseam> yeah
00:54:51 <frerich2> adnauseam: Doesn't that function print just every 1st, 3rd, 5th ... element?
00:54:52 <ChristianS> but why don't you just convert [] into "" (the empty string)? than you wouldn't need the Maybe
00:55:00 <adnauseam> yeah it should
00:55:14 <mekeor> adnauseam: (x:[]) is [x], btw:
00:55:17 <adnauseam> im trying to learn about Maybe while doing this too :p
00:55:17 <mekeor> > 5:[]
00:55:18 <lambdabot>   [5]
00:55:20 <tikhonjelvis> The Maybe suggestion was for your neck function.
00:55:34 <adnauseam> yeah but [x] would error out on the compile
00:55:43 <adnauseam> tried it before with another function just a moment ago
00:55:50 <adnauseam> oh
00:56:00 <adnauseam> let me see
00:56:22 <ChristianS> listElements (a:[])  is exactly the same as  listElements [a]
00:56:54 <adnauseam> x
00:56:54 <adnauseam> neck :: [a] -> Maybe a
00:56:54 <adnauseam> neck (x:[]) = x
00:56:54 <adnauseam> neck (x:y:_) = y
00:56:56 <adnauseam> ?
00:57:01 <adnauseam> is that what you meant ?
00:57:11 <ChristianS> and you can do  listElements (tail xs)  instead of  listElements [x | x <- tail xs]
00:57:31 <adnauseam> ChristianS: even in the code to be compiled ?
00:57:39 <adnauseam> code and console seem to bahve differently
00:57:46 <ChristianS> they shouldn't
00:58:02 <adnauseam> let me see
00:58:39 <adnauseam> so listElements (a:[]) = show a
00:58:40 <adnauseam> to
00:58:51 <adnauseam> listElements [a] = show a
00:58:52 <adnauseam> ?
00:59:05 <ChristianS> yes
00:59:06 <tikhonjelvis> yeah, those are the same
00:59:28 <ChristianS> but that will only compile if your type is ... -> String  (without the Maybe)
00:59:55 <srhb> Which it is, by definition of show.
01:03:24 <adnauseam> listElements :: [a] -> Maybe String
01:03:24 <adnauseam> listElements [] = Nothing
01:03:24 <adnauseam> listElements [a] = show a
01:03:25 <adnauseam> listElements (a:xs) = show a ++ listElements (tail xs)
01:03:29 <adnauseam> ghci angry.
01:03:46 <tikhonjelvis> You have to wrap normal values in Just. So Just (show a).
01:04:09 <adnauseam> "Just (show a)" ?
01:04:15 <adnauseam> &
01:04:23 <adnauseam> "Just (show a ++ listElements (tail xs)
01:04:27 <adnauseam> "Just (show a ++ listElements (tail xs))
01:04:41 <tikhonjelvis> You can also write it as Just $ show a ++ listElements (tail xs)
01:04:49 <adnauseam> o
01:04:51 <tikhonjelvis> The $ acts like parentheses until the end of the line.
01:04:55 <adnauseam> nice :o
01:04:57 <ChristianS> that won't work, since you cannot concatenate a string a Nothing
01:05:06 <tikhonjelvis> there is that
01:05:08 <ChristianS> just get rid of the Maybe
01:05:18 <adnauseam> how would i then handle the end of the loist ?
01:05:19 <tikhonjelvis> You should have used the Maybe with your neck function, not this one.
01:05:37 <ChristianS> listElements :: [a] -> String
01:05:43 <ChristianS> listElements [] = ""
01:05:49 <adnauseam> oh
01:05:53 <ChristianS> then it should work fine
01:06:05 <adnauseam> yeah ... i was thinking null
01:06:21 <ChristianS> (except that you won't have any separators between your 1st, 3rd, 5th etc. element -- not sure if that's how you want it)
01:06:51 <adnauseam> this is what i've got now :
01:06:52 <adnauseam> listElements :: [a] -> String
01:06:52 <adnauseam> listElements [] = ""
01:06:52 <adnauseam> listElements [a] = Just $ show a
01:06:53 <adnauseam> listElements (a:xs) = Just $ show a ++ listElements $ tail xs
01:07:06 <ChristianS> no no no, now the Just to too much
01:07:07 <adnauseam> hopefully it compiles
01:07:13 <adnauseam> oh
01:07:18 <ChristianS> try understand this, not just blindly doing what we tell you
01:07:32 <adnauseam> i got confused with the Maybe part =[
01:08:18 <mekeor> is the following source really correct? i'm not sure…:
01:08:21 <mekeor> @src transpose
01:08:21 <lambdabot> transpose []             = []
01:08:21 <lambdabot> transpose ([]   : xss)   = transpose xss
01:08:21 <lambdabot> transpose ((x:xs) : xss) = (x : [h | (h:t) <- xss]) : transpose (xs : [ t | (h:t) <- xss])
01:09:10 <DarkUnicorn> :249
01:09:15 <DarkUnicorn> ups, sorry
01:09:18 <mekeor> i mean, what if one of the lists in the list which transpose gets is [] ??    then transpose mustn't call head or tail on it…
01:09:43 <srhb> mekeor: Nowhere is head or tail called, is it
01:10:25 <mekeor> srhb: `[h | (h:t) <- xss]' that's actually `map head xss', isnt it?
01:11:03 <srhb> > [ h | (h:t) <- [] ]
01:11:04 <lambdabot>   []
01:11:09 <srhb> > head []
01:11:10 <lambdabot>   *Exception: Prelude.head: empty list
01:11:10 <mekeor> > [h|(h:t)<-[[1],[1,2],[3,4],[5,6,7]]]
01:11:11 <lambdabot>   [1,1,3,5]
01:11:34 <mekeor> > [h|(h:t)<-[[1],[1,2],[3,4],[5,6,7],[]]]
01:11:34 <lambdabot>   [1,1,3,5]
01:11:40 <mekeor> what?? O_O
01:11:54 <srhb> Monads. Magic.
01:12:08 <mekeor> ?
01:12:33 <srhb> Perhaps you should try to desugar that list comprehension if it confuses you
01:12:45 <srhb> I think what's really bugging you is what that <- is doing
01:13:14 <mekeor> (h:t) is element of that list which follows the arrow.. i know that
01:13:44 <mekeor> but (h:t) can't be instanciated (i'm not sure whether that's the correct word/term) to [] !
01:14:23 <MostAwesomeDude> The term is "matched".
01:14:34 <MostAwesomeDude> [] doesn't match (h:t).
01:14:39 <mekeor> actually, transpose first has to `filter (not . null) xss' or so…
01:14:50 <mekeor> MostAwesomeDude: yes, exactly.
01:14:57 <MostAwesomeDude> Although...
01:15:02 <mekeor> so how does that work then? is the source wrong or what?
01:15:09 <MostAwesomeDude> > let f (h:t) = h in f []
01:15:10 <lambdabot>   *Exception: <interactive>:3:4-14: Non-exhaustive patterns in function f
01:15:23 <mekeor> i'm mean, of course it's not the original source in the prelude, but the source saved in lambdabot's brain…
01:15:35 <MostAwesomeDude> No, lambdabot is correct.
01:15:40 <mekeor> oh, okay…
01:15:42 <ChristianS> if there is no match, list comprehension just returns the empty list (or so me thinks)
01:16:07 <ChristianS> it never throws an error, as a pattern match would
01:16:13 <mekeor> ah!
01:16:27 <MostAwesomeDude> > transpose [[1],[1,2],[3,4],[5,6,7],[]]]
01:16:28 <lambdabot>   <no location info>: parse error on input `]'
01:16:33 <MostAwesomeDude> > transpose [[1],[1,2],[3,4],[5,6,7],[]]
01:16:33 <lambdabot>   [[1,1,3,5],[2,4,6],[7]]
01:16:54 <srhb> > do { (h:t) <- [[1],[1,2],[]]; return h }
01:16:55 <lambdabot>   [1,1]
01:16:58 <mekeor> so, under the hood that is somehow a filter like i said before, right?
01:17:28 <mekeor> so, in some way transpose filters empty lists… because they don't match (h:t)… alright. got it =)
01:17:36 <MostAwesomeDude> I'm honestly not sure how LCs are desugared.
01:17:49 <MostAwesomeDude> But this would appear to be a property of the LC, not of transpose.
01:18:02 <mekeor> yes.
01:18:03 <tikhonjelvis> They could be turned into do notation, but I am fairly certain they're actually not.
01:18:05 <srhb> MostAwesomeDude: As the do-statement I wrote
01:18:09 <srhb> > do { (h:t) <- [[1],[1,2],[]]; return h }
01:18:10 <lambdabot>   [1,1]
01:18:23 <danr> @src transpose
01:18:23 <lambdabot> transpose []             = []
01:18:23 <lambdabot> transpose ([]   : xss)   = transpose xss
01:18:23 <lambdabot> transpose ((x:xs) : xss) = (x : [h | (h:t) <- xss]) : transpose (xs : [ t | (h:t) <- xss])
01:18:37 <danr> yes, so there's some felting going on
01:18:41 <danr> filtering*
01:18:41 <srhb> is equal to [ h | (h:t) <- [[1],[1,2],[]] ]
01:18:56 * mekeor was just translating felting… hehe
01:20:39 <srhb> So the trick is the fail definition of the List monad
01:21:36 <mekeor> explain further, pls
01:24:21 <ddarius> @undo [ h | (h:t) <- [] ]
01:24:21 <lambdabot> concatMap (\ a -> case a of { (h : t) -> [h]; _ -> []}) []
01:24:44 <tikhonjelvis> I think in actual practice list comprehensions get desugared differently.
01:25:09 <tikhonjelvis> Then again, maybe no.
01:25:29 <tikhonjelvis> @undo do {(h:t) <- []; return h}
01:25:29 <lambdabot> [] >>= \ a -> case a of { (h : t) -> return h; _ -> fail ""}
01:25:36 <mekeor> @undo [ h | (h:t) <- l ]
01:25:36 <lambdabot> concatMap (\ a -> case a of { (h : t) -> [h]; _ -> []}) l
01:25:37 <tikhonjelvis> hmm
01:25:48 <srhb> Ah yes, there we go
01:25:49 <mekeor> ddarius: cool!
01:26:01 <srhb> Was desugaring that by hand and the case was throwing me off
01:27:11 <srhb> so the trick is that fail for the list monad is simply [], I think
01:27:24 <tikhonjelvis> Or maybe the trick is with MonadPlus?
01:27:41 <tikhonjelvis> :t fail
01:27:42 <lambdabot> forall (m :: * -> *) a. (Monad m) => String -> m a
01:27:51 <tikhonjelvis> fail "blarg" :: [Int]
01:27:57 <tikhonjelvis> > fail "blarg" :: [Int]
01:27:58 <lambdabot>   []
01:28:02 <srhb> :)
01:28:06 <tikhonjelvis> > mzero :: [Int]
01:28:07 <lambdabot>   []
01:28:53 <mekeor> @hoogle mzero
01:28:53 <lambdabot> Control.Monad mzero :: MonadPlus m => m a
01:29:12 <tikhonjelvis> mzero :: Just Int
01:29:14 <tikhonjelvis> > mzero :: Just Int
01:29:15 <lambdabot>   Not in scope: type constructor or class `Just'
01:29:16 <srhb> instance  Monad []  where
01:29:16 <srhb>     m >>= k          = concat (map k m)
01:29:16 <srhb>     return x         = [x]
01:29:16 <srhb>     fail s           = []
01:29:22 <tikhonjelvis> It's nothing
01:29:45 <mekeor> no, it's Nothing.
01:29:48 <mekeor> :P
01:30:00 <tikhonjelvis> > mzero :: Maybe Int
01:30:01 <lambdabot>   Nothing
01:30:06 <tikhonjelvis> and I need sleep ⌣̈
01:30:28 <mekeor> tikhonjelvis: good night :)
01:31:10 <tikhonjelvis> night
01:32:35 <srhb> > 1:2:fail ""
01:32:36 <lambdabot>   [1,2]
01:33:01 * hackagebot ebeats 0.1.0 - Time in ebeats  http://hackage.haskell.org/package/ebeats-0.1.0 (BrianLewis)
01:33:08 <srhb> I don't know how I feel about fail. Somehow it's really nice, and somehow it's really not logical.
01:33:22 <srhb> But life without it would be annoying.
01:33:44 <mandaya> :t fail
01:33:44 <lambdabot> forall (m :: * -> *) a. (Monad m) => String -> m a
01:33:57 <srhb> (and yes, I obviously mean life in its broadest sense. <_<)
01:41:46 <randomclown> how do I round a number to n decimal places?
01:41:58 <randomclown> I'm probably missing something obvious
01:42:24 <Botje> multiply by 10^n, round, divide?
01:42:57 <randomclown> is there no built in function>
01:43:01 <randomclown> library*
01:43:50 <MostAwesomeDude> It's not a very common task.
01:43:53 <flux> randomclown, note that in the process you should make the number a rational number
01:44:05 <flux> because floating points numbers don't really hold that kind of information well
01:44:13 <Jafet> > 0.1 + 0.2 == 0.3
01:44:14 <lambdabot>   False
01:45:30 <mekeor> randomclown: http://www.haskell.org/pipermail/haskell-cafe/2006-February/014447.html i googled and found this… it's not a already existing function, i mean it's not in a library, but it's there
01:45:45 <mekeor> > 0.1 + 0.2
01:45:46 <lambdabot>   0.30000000000000004
01:45:52 <randomclown> yeah I found that too just wanted to make sure
01:46:05 <mekeor> okay
01:47:12 <c_wraith> I really feel like ieee754 numbers shouldn't be in the Prelude.
01:47:40 <mekeor> c_wraith: what's that?
01:47:58 <c_wraith> or, in any programming language, they should have some sort of hurdle to using them.  Something that indicates you know what their limitations are
01:48:10 <srhb> c_wraith: Yeah, it's one of those few areas where you suddenly have to be very, very careful. It's annoying.
01:48:21 <ChristianS> what's that? Double, Float
01:48:24 <c_wraith> yes
01:48:45 <c_wraith> They aren't needed very often in most code
01:48:51 <Jafet> I really feel like dumb people shouldn't write computer programs.
01:48:55 <Jafet> That is all.
01:49:17 <mwc> Jafet: they write them with lots of {
01:49:23 <c_wraith> Saying ".1 + .2 == .3 should be true!" isn't dumb
01:49:40 <c_wraith> it's just unaware of the representation used by ieee754
01:49:44 <QinGW> @hoogle Either
01:49:45 <lambdabot> Prelude data Either a b
01:49:45 <lambdabot> Data.Either data Either a b
01:49:45 <lambdabot> Prelude either :: (a -> c) -> (b -> c) -> Either a b -> c
01:49:58 <Jafet> So what you're saying is, the default RealFrac instance should be Rational.
01:50:00 <mwc> well, yeah, but you should be aware of the representation of "real" numbers on your computer
01:50:02 <Jafet> Or something.
01:50:06 <c_wraith> Yes
01:50:10 <mwc> Hmmm
01:50:20 <Jafet> That is reasonable, but unlikely to happen in successful languages like ours.
01:50:24 <c_wraith> and if you want the performance optimized version, you should have to indicate that you understand the tradeoffs, somehow
01:50:35 <c_wraith> You get tons better performance, but there is a cost
01:50:54 <mwc> Well, constants and the like would be easily coerced at compile time by the type system
01:51:04 <c_wraith> constants already are
01:51:08 <c_wraith> > 0.5 :: Rational
01:51:09 <lambdabot>   1 % 2
01:51:13 <mwc> so you'd specialize a lot of code that way as soon as you start using Double in your types
01:51:33 <mux> > pi :: Rational
01:51:34 <lambdabot>   No instance for (GHC.Float.Floating GHC.Real.Rational)
01:51:34 <lambdabot>    arising from a us...
01:51:38 <c_wraith> Well, and I don't think Double or Float belong in the prelude
01:51:49 <mwc> Well, a lot of stuff arguably doesn't
01:51:58 <c_wraith> You should really need to make an effort to use limited-purpose numbers
01:51:58 <mwc> Integer, Bool...
01:52:06 <Jafet> :t 1.0
01:52:07 <lambdabot> forall t. (Fractional t) => t
01:52:09 <c_wraith> Integer and Bool are much more general
01:52:15 <mwc> Integer, Bool are examples of what I think should be in the prelude
01:52:18 <Jafet> :t fromRational
01:52:19 <lambdabot> forall a. (Fractional a) => Rational -> a
01:52:20 <c_wraith> ah
01:52:23 <mwc> machine types in platform
01:52:25 <mwc> but yeah
01:52:51 <ChristianS> > (0.1 :: Rational) + (0.2 :: Rational) == (0.3 :: Rational)
01:52:51 <lambdabot>   True
01:52:54 <ChristianS> neat
01:52:55 <c_wraith> Float and Double are.. strange types optimized very well for one particular use case, but not suited to storing and calculating with arbitrary non-integer numbers.
01:53:11 <mux> > realToFrac pi :: Rational
01:53:12 <lambdabot>   884279719003555 % 281474976710656
01:53:26 <mwc> what I really want is class Eq e b | e -> b where { (==) :: e -> e -> b; {- ... -} }
01:54:15 <ChristianS> mux: hey, you just converted pi into a rational number. the ancient greeks would have been SO proud of you!
01:54:29 <adnauseam> success:}
01:54:39 <adnauseam> listElements :: (Show a) => [a] ->  String
01:54:39 <adnauseam> listElements [] = ""
01:54:40 <adnauseam> listElements (a:xs) = show a ++" "++ listElements xs
01:54:51 <adnauseam> i don't understand one thing though
01:54:59 <mwc> together with a similar parameterization over Bool in the rebindable syntax for if.. then... else... would make writing embedded EDSL expressions much more natural
01:55:31 <adnauseam> how come it's enough that i recursively pass listElements the list itself - the head doesn't get removed - so shouldn't it lock into an infinite loop printing the head ?
01:56:01 <adnauseam> or does (a:xs) seperate the head from the tail per definition ?
01:56:08 <c_wraith> data Equalish = DefinitelyNotEqual | ProbablyNotEqual | Can'tSay | ProbablyEqual | DefinitelyEqual
01:56:15 <mux> ChristianS: hahaha
01:56:20 <ChristianS> a is the head, xs is the rest (the tail)
01:56:31 <ChristianS> that's pattern matching
01:56:37 <adnauseam> woot
01:56:39 <adnauseam> =D
01:56:45 <adnauseam> nice
01:57:15 <nlogax> just like you construct a list using x : xs, you pull it apart in the same way in a pattern
01:57:50 <adnauseam> this is pretty awesome
01:58:04 <nlogax> same for other constructors :)
01:59:10 <mwc> c_wraith: yeah, less crazy use is instance Eq e b => Eq (K e) (K b) ... which captures == operations on DSEL expressions (K :: * -> *) and injects the result back into the DSEL.
01:59:15 <Jafet> :t (=<<) $ (++" ") . show
01:59:16 <lambdabot> forall a. (Show a) => [a] -> [Char]
02:08:51 <ChristianS> adnauseam: btw, you could also define your function like this, using some standard functions: listElements xs = concat (intersperse " " (map show xs))
02:09:05 <ChristianS> (and i feel there must be a simpler way, but i currently don't get it)
02:09:42 <adnauseam> thing is i haven't read about concat and map yet :p
02:09:52 <adnauseam> i'm just glad i got it working for now ;p
02:10:21 <ChristianS> @hoogle concat
02:10:21 <lambdabot> Prelude concat :: [[a]] -> [a]
02:10:21 <lambdabot> Data.List concat :: [[a]] -> [a]
02:10:21 <lambdabot> Prelude concatMap :: (a -> [b]) -> [a] -> [b]
02:10:25 <ChristianS> @hoogle map
02:10:25 <lambdabot> Prelude map :: (a -> b) -> [a] -> [b]
02:10:25 <lambdabot> Data.List map :: (a -> b) -> [a] -> [b]
02:10:25 <lambdabot> Prelude mapM :: Monad m => (a -> m b) -> [a] -> m [b]
02:10:44 <ChristianS> look them up, they are worthwhile knowing
02:11:14 <ChristianS> but you don't have to do so now, just play around with what you already know :-)
02:12:06 <adnauseam>  i'll look themup once i finish this chapter =}
02:18:28 <Tinned_Tuna> > map (+2) [1..10]
02:18:29 <lambdabot>   [3,4,5,6,7,8,9,10,11,12]
02:18:40 <Tinned_Tuna> > mapM print [1..10]
02:18:41 <lambdabot>   <IO [()]>
02:19:01 <Tinned_Tuna> > words "Hello world"
02:19:02 <lambdabot>   ["Hello","world"]
02:23:52 <mekeor> Tinned_Tuna: i think you actually usually use "mapM_ print [1..10]"…
02:25:15 <ChristianS> yes
02:31:45 <Webfp> I have a question about using custom scripts with xmobar in xmonad
02:32:48 <Webfp> in my .xmobarrc I have "Run Com "home/frank/scripts/volume.sh" [] "volume" 10
02:33:21 <Webfp> I can execute the script from a terminal, but all xmobar gives is "Could not execute command /home/frank/scripts/volume.sh
02:33:58 <Eduard_Munteanu> Webfp: is that home/frank/scripts/volume.sh? Doesn't sound right.
02:34:08 <xil> hi everyone. When I run "cabal list regex" I get, like, 30 regex packages. Anyone know which one I should install?
02:34:13 <Eduard_Munteanu> Missing '/' at the beginning.
02:34:45 <Webfp> oh sorry, Eduard, I forgot to type the / before home
02:34:58 <Webfp> it is /home/frank/scripts/volume.sh
02:35:39 <Webfp> In .xmobarrc the command does have the /
02:37:41 <Eduard_Munteanu> Webfp: does it have execute rights?
02:41:36 <Webfp> Eduard: I haven't checked for that, will do that right now
02:42:40 <Webfp> Thanks Eduard, that was the trick to get it working
02:48:22 <savask> Hello. If I make an emulator in Haskell, is there a better way of making it than keeping a state of a machine and using monad transformers, or dealing with IOish vars and arrays?
02:49:50 <Eduard_Munteanu> savask: not really
02:50:19 <Eduard_Munteanu> Depends what you're emulating though.
02:50:50 <savask> It's a small toy assembler-like language.
02:52:29 <savask> I thought that if there is FRP for "reactive" progs, then there should be something for stateful ones.
02:53:51 <Eduard_Munteanu> If your "machine" is best described by a stateful approach, I don't see a way around it.
02:54:59 <savask> Okay :C
03:02:04 <Rc43> Hi, guys.
03:03:05 * hackagebot alsa-seq 0.5.1.1 - Binding to the ALSA Library API (MIDI sequencer).  http://hackage.haskell.org/package/alsa-seq-0.5.1.1 (HenningThielemann)
03:03:54 <Rc43> Can I for type (X a) declare instance of some class C with constraints for a and without them? For example I want to declare Show for X, if a is Show then it will be done one way, if a isn't Show then it will be done other way. Now it is impossible without any extensions, as I know.
03:24:57 <mekeor> haskell doesn't have nested guards, right?
03:27:14 <Guest88038> :|
03:28:11 * hackagebot midi 0.1.7.1 - Handling of MIDI messages and files  http://hackage.haskell.org/package/midi-0.1.7.1 (HenningThielemann)
03:31:12 <osa1_> is there a commoand in ghci to browse exported names fo a package?
03:31:23 <osa1_> s/package/module
03:39:37 <Peaker> can TH/haskell-src-exts generate FFI bindings too?
03:44:54 <alpounet> osa1_, :browse
03:48:30 <tomodo> I have a function f x y z w u = True or False which is the same no matter what permutation you have the arguments?
03:49:14 <tomodo> how do you write the fastest code for it if you have input/output pairs defined for all inputs?
03:52:58 <Botje> lookup table and/or decision tree.
03:53:31 <Botje> what does 'the same no matter what permutation' mean?
03:53:38 <Botje> are you simply counting the number of trues and falses?
03:53:46 <Botje> .. or whatever your input type is
03:54:11 <Peaker> tomodo: you could write that function as a pattern-match on 0..5 values
03:54:27 <Peaker> oops, unless they're non-boolean :)
03:54:58 <benmachine> tomodo: if the type is ordered then a simple, if somewhat crude, way, would be to put them in a list and sort the list and then apply the function to that
03:55:00 <tomodo> they're Maybe Boolean
03:55:01 <Peaker> heh, that's funny
03:55:26 <Peaker> tomodo: what is the function?
03:55:56 <tomodo> I don't know how to give you the function since it's got 3^5 cases
03:55:58 <tomodo> well
03:56:06 <tomodo> more like 3^5/5! I guess
03:56:12 <tomodo> since it's up to permutation
03:56:22 <benmachine> tomodo: it doesn't have a simpler meaning?
03:56:26 <benmachine> what is it trying to do?
03:56:58 * benmachine has to run off somewhere
03:58:20 <tomodo> its almost symmetric with respect to not :"
04:03:30 <magicman3> Any nice one liner to transform a list of two lists like [[1,2],[3,4]] to two parameters (or a 2-tuple) so I can use it with zip (optionally uncurried)?
04:04:01 <Peaker> What is the CT name of the non-recursive folder (as opposed to "catamorphism" which is the recursive one)?
04:04:19 <shachaf> > transpose [[1,2],[3,4]]
04:04:20 <lambdabot>   [[1,3],[2,4]]
04:04:48 <shachaf> Peaker: As in foo f z [] = z; foo f z (x:xs) = f x xs?
04:05:01 <hpc> > map f . transpose $ [[1,2],[3,4]] :: [[Expr]]
04:05:02 <lambdabot>   No instance for (SimpleReflect.FromExpr [SimpleReflect.Expr])
04:05:02 <lambdabot>    arising fr...
04:05:22 <magicman3> Fair enough.. that was silly. Let me try this out.
04:05:23 <hpc> > map f . transpose $ [[1,2],[3,4]] :: [Expr]
04:05:25 <lambdabot>   [f [1,3],f [2,4]]
04:05:32 <Peaker> shachaf: yeah
04:06:04 <Peaker> magicman3: why do you have a list of 2 lists, and not a tuple of 2 lists?
04:06:20 <Peaker> magicman3: i.e: Why are your types not reflecting the invariant you have, that the list is of length 2?
04:07:15 <Jafet> Because tuples suck
04:07:28 * shachaf agrees with Peaker and Jafet simultaneously.
04:08:38 <Peaker> I am going to use a LenList for a length-indexed list, with GADTs
04:08:41 <magicman3> Peaker: Well, I couldn't figure out how to do it that way either :) I'm trying to write a single line function f :: [a] -> [a] that takes a list and applies a binary function to every consecutive pair of elements. So f (+) [1 2 3 4] == [3, 7]
04:08:47 <magicman3> But it's proving to be somewhat harder than I expected.
04:08:57 <Peaker> magicman3: what happens if the list has an odd number of elements?
04:09:49 <magicman3> Peaker: I'm assuming the input is of even length.
04:10:00 <magicman3> (At least in the application it always will be)
04:10:46 <Peaker> > map head . takeWhile (not . null) . iterate (drop 2) . (zip<*>tail) $ [1,2,3,4,5]
04:10:47 <lambdabot>   [(1,2),(3,4)]
04:11:22 <shachaf> > let odds [] = []; odds [x] = [x]; odds (x:x':xs) = x:odds xs in (\f xs -> odds (zipWith f xs (tail xs))) (+) [1,2,3,4]
04:11:23 <lambdabot>   [3,7]
04:13:14 <miggyx_> I don't suppose anyone would be interested in writing a converter for Aeson JSON <---> BSON at all?
04:15:11 <Jafet> > map (join(***)snd) . uncurry zip . partition fst . zip (cycle [True,False]) $ [1..5]
04:15:12 <lambdabot>   [(1,2),(3,4)]
04:16:30 <Peaker> Jafet: that's a nutty one :)
04:16:44 <magicman3> The zip<*> one has exponential complexity, right?
04:16:55 <Peaker> magicman3: nope
04:17:09 <Peaker> > map head . takeWhile (not . null) . iterate (drop 2) . (zip<*>tail) $ [1..100000000]
04:17:11 <lambdabot>   [(1,2),(3,4),(5,6),(7,8),(9,10),(11,12),(13,14),(15,16),(17,18),(19,20),(21...
04:17:15 <Jafet> > last $ map head . takeWhile (not . null) . iterate (drop 2) . (zip<*>tail) $ [0..99999]
04:17:16 <lambdabot>   (99998,99999)
04:17:33 <Peaker> > last . map head . takeWhile (not . null) . iterate (drop 2) . (zip<*>tail) $ [1..10000000]
04:17:36 <lambdabot>   (9999999,10000000)
04:18:03 <Peaker> magicman3: (zip<*>tail) xs = zip xs (tail xs)
04:18:19 <Peaker> magicman3: and that's linear
04:18:29 <Jafet> > length <$> ["ap zip tail", "(zip<*>tail)"]
04:18:30 <lambdabot>   [11,12]
04:18:58 <Jafet> Admittedly, it's because (L..) is the wrong fixity.
04:19:19 <Peaker> I think it would work without ()
04:19:31 <Peaker> oh, oops
04:19:38 <Peaker> (.) is the most powerful operator on earth
04:21:14 <Jafet> Can't abuse lambdabot evaluation
04:23:49 <magicman3> OK, you've lost me now. Thanks for the directions though.
04:24:10 <mekeor> @hoogle (<*>)
04:24:11 <lambdabot> Control.Applicative (<*>) :: Applicative f => f (a -> b) -> f a -> f b
04:25:51 <Peaker> magicman3: zip xs (tail xs)  makes a new list of length (N-1) from a list of length N. "tail" doesn't copy anything, so there's nothing that's not O(N) here
04:26:54 <Peaker> @src zip
04:26:54 <lambdabot> zip (a:as) (b:bs) = (a,b) : zip as bs
04:26:55 <lambdabot> zip _      _      = []
04:26:57 <mekeor> @hoogle (,)
04:26:57 <lambdabot> Prelude undefined :: a
04:26:57 <lambdabot> Data.Function fix :: (a -> a) -> a
04:26:57 <lambdabot> Control.Monad.Fix fix :: (a -> a) -> a
04:27:19 <Peaker> Prelude (,) :: a -> b -> (a, b)
04:27:26 <mekeor> ah, okay
04:27:37 <mekeor> > (,) 1 2
04:27:38 <lambdabot>   (1,2)
04:27:40 <mekeor> cool
04:27:52 <mekeor> > (,,) 1 2 3
04:27:52 <lambdabot>   (1,2,3)
04:28:03 <mekeor> that's GHC ext, right?
04:28:12 <Peaker> Don't think so...
04:28:24 <mekeor> but i :P
04:28:50 <magicman3> Yes I think I see now, the so-called "laziness" is preventing what would be quadratic complexity occurring from repeatedly computing cross products?
04:28:54 <Peaker> I'm nearing stopping to pay lip service to "Haskell" and just surrendering to write GHC Haskell exclusively
04:29:08 <matthiasgorgens> magicman3, nope.
04:29:13 <Peaker> magicman3: not here, eagerly evaluating it is also O(N)
04:29:24 <mekeor> http://www.haskell.org/ghc/docs/7.2.1/html/users_guide/syntax-extns.html "7.3.13. Tuple sections"
04:29:43 <matthiasgorgens> magicman3, if lazy evaluation evaluated everything, it has the same O() complexity as strict evaluation.
04:29:47 <mekeor> Peaker: ^
04:29:55 <shachaf> Peaker: What, your ap zip tail thing?
04:29:57 <matthiasgorgens> magicman3, but in practice it will be slower, because of the lazyness overhead.
04:29:58 <Peaker> magicman3: is it   the  "zip xs (tail xs)"  part that you expect to be non-linear?
04:30:12 <matthiasgorgens> magicman3: only if you actually evaluate less than the full structure, do you save with lazyness.
04:30:14 <Peaker> shachaf: yeah
04:30:14 <shachaf> Peaker: I think it would be worse if it evaluated the entire result of "tails".
04:30:17 <mekeor> > (,True) 1
04:30:18 <lambdabot>   Illegal tuple section: use -XTupleSections
04:30:21 <magicman3> It's the iterate (drop 2) . (zip <*> tail) $ [1...n], which generates a bunch of cross-products?
04:30:25 <matthiasgorgens> shachaf: no.
04:30:34 <Peaker> shachaf: it would still be linear to the input size
04:30:59 <Peaker> magicman3: <*> of the function monad, not of the list monae
04:30:59 <matthiasgorgens> shachaf: tails in Ocaml, a strict language, has the exact same definition as in haskell, and also asymptotic runtime, if you evaluate the whole thing.
04:31:00 <shachaf> Hmm, you didn't actually use tails.
04:31:24 <Peaker> magicman3: there's no cross produce here (if you mean cartesian here)
04:31:29 <matthiasgorgens> shachaf: yes.  But even tails is linear.
04:31:57 <matthiasgorgens> (zip <*> tails) also gives an interesting function, that's still linear in the input length.
04:32:30 <matthiasgorgens> exercises: what's the runtime complexitiy of (zip <$> inits <*> tails)?
04:33:05 <magicman3> > takeWhile (not . null) . iterate (drop 2) . (zip<*>tail) $ [1,2,3,4,5]
04:33:07 <lambdabot>   [[(1,2),(2,3),(3,4),(4,5)],[(3,4),(4,5)]]
04:33:11 <magicman3> This is quadratic, no?
04:33:13 <hpc> :t zip <$> inits <*> tails
04:33:14 <lambdabot> forall a. [a] -> [([a], [a])]
04:33:38 <Peaker> magicman3: no, because of sharing
04:33:50 <adnauseam> looks linear
04:33:58 <Peaker> magicman3: Showing it is O(N^2), because it re-duplicates what's shared
04:34:08 <adnauseam> o
04:34:18 <matthiasgorgens> inits can't use sharing on the spine of the lists.
04:34:50 <matthiasgorgens> but tails can.
04:35:17 <Peaker> magicman3: tail   is O(1), it doesn't duplicate the entire list
04:36:06 <matthiasgorgens> (zip <$> (reverse . tails . reverse) is linear (and a zipper of a list) but not lazy enough, unless the compiler is really good.
04:36:53 <Peaker> some would argue a compiler that optimizes that kind of thing is not a good thing
04:37:49 <Peaker> taking reliability seriously needs to focus on reasonable performance too... A program that crashes or takes too long is also unreliable
04:37:50 <matthiasgorgens> or let's say `knowledgeable' not `good'.
04:38:10 <Peaker> and a compiler that smart is going to make innocent changes introduce cryptic performance bugs
04:38:21 <Peaker> GHC already does...
04:38:25 <matthiasgorgens> oh, yes.  it will be hard to predict.
04:38:51 <matthiasgorgens> yes, in GHC whether various strictness analyses kick in makes a huge difference.
04:38:58 <matthiasgorgens> and other things, too.
04:38:59 <Peaker> It would work well and be great if the optimization was more transparent in the toolchain.. i.e: Good UI integration for Core -- seeing it right next to the function, and seeing it change incrementally as you change your code
04:39:46 <ion> That would be cool.
04:41:07 <magicman3> Peaker: Isn't that consistent with what I was saying? Semantically there are quadratically many elements in that "list" so at least quadratic complexity (if it were fully evaluated).
04:42:57 <matthiasgorgens> magicman3: nope.
04:43:11 <matthiasgorgens> magicman3: sharing saves you, and it's part of the semantics.
04:43:35 <matthiasgorgens> magicman3: it's at the same level as tail call optimization.
04:43:56 <Peaker> magicman3: evaluating both  xs  and  tail xs    evaluates each element of xs AND the spine of the list of xs exactly once
04:44:40 <Peaker> magicman3: in an eager language, xs would be an already-evaluated list, and "tail" would just a ptr to it's already evaluated tail, not recompute the entire tail
04:47:30 <magicman3> So hold on. printing the so-called "list" forces some kind of de-duplication, but typically we can operate on that list (of quadratic size) in linear time?
04:48:13 <Peaker> printing it forces re-duplication, not de-duplication :)
04:48:22 <beginner> is there any compiler introduction book with Haskell as the implementation language?
04:48:28 <Peaker> magicman3: don't think of it as a "quadratically sized" list
04:48:37 <Peaker> magicman3: again, the sharing is part of the semantics
04:49:03 <Peaker> > show $ tails [1,2,3,4]
04:49:04 <lambdabot>   "[[1,2,3,4],[2,3,4],[3,4],[4],[]]"
04:49:11 <beginner> I mean introduction to compiler, like the modern compiler implementation in ML
04:49:19 <Peaker> the "show" is duplicating the elements here, "unsharing"
04:50:35 <Peaker> magicman3: do you have experience with some other languages, e.g: C?
04:52:19 <magicman3> Yes, I see what it's doing but then, any modification of one of the duplicated "tails" of the original list is going to cause re-duplication, to some extent?
04:54:56 <shachaf> > replicateM 4 [0,1]
04:54:57 <lambdabot>   [[0,0,0,0],[0,0,0,1],[0,0,1,0],[0,0,1,1],[0,1,0,0],[0,1,0,1],[0,1,1,0],[0,1...
04:54:59 <shachaf> Er.
04:56:16 <KorriX> hello
04:56:23 <KorriX> how to change colorset in hscolour to emacs ?
05:03:08 <niteria> @src replicateM
05:03:08 <lambdabot> replicateM n x = sequence (replicate n x)
05:04:11 <niteria> @src sequence
05:04:11 <lambdabot> sequence []     = return []
05:04:11 <lambdabot> sequence (x:xs) = do v <- x; vs <- sequence xs; return (v:vs)
05:04:11 <lambdabot> -- OR: sequence = foldr (liftM2 (:)) (return [])
05:04:52 <mysticc> Can this be performed in a functional way .. I have a tree with nodes something like data Tree a = Empty | Node (Tree a) a (Tree a) ..There can be a number of such trees ... With this tree I want to also simultaneously want to maintain a map from a key (a) to its node .. So I can get given a key its corresponding node in O(1) or maybe O(log n) time ...
05:05:42 <Peaker> mysticc: You can maintain a   Map a (Tree a) along-side the tree
05:05:50 <Peaker> or any other form of mapping
05:06:11 <Peaker> mysticc: if you use a zipper-tree or such maybe you can traverse upwards from that point too
05:06:14 <niteria> oh, I see
05:06:37 <Peaker> For that @src sequence, I'd add:
05:06:44 <Peaker> -- OR: sequence = ... foldA2 ...
05:06:52 <Peaker> (and ... pure ...)
05:07:25 <niteria> how does one know how to write that if it takes me a while to understand?
05:09:19 <Peaker> niteria: you grow an intuition for the concepts with time
05:09:31 <Peaker> niteria: how long have you been working with Applicatives, Monads, etc?
05:09:54 <niteria> I almost haven't
05:10:24 <beginner> @src heap
05:10:25 <lambdabot> Source not found. :(
05:10:30 <alpounet> the it's normal niteria
05:10:57 <alpounet> you'll get a feel of what Applicatives, Monads, etc are by reading about them, using them a bit
05:11:08 <matthiasgorgens> Are there some more suitable combinators than foldr to write http://hpaste.org/64218 ?
05:11:19 <mysticc> Peaker: The problem is suppose I do that .. Now if I insert a element in the tree I get a new tree .. Now I will have to update maps of all the nodes of the tree as map will be storing a copy of tree ..
05:12:35 <Peaker> mysticc: well, normally insertion to a persistent tree is done in O(logN) time to duplicate the branch you're modifying. Each of these logN changes would incur another logN cost to update the map too. So it may convert O(logN) to O(log^2 N)
05:13:37 <niteria> when I write something in haskell I can't stop thinking recursively
05:14:37 <mysticc> Peaker: I am using a zipper tree suppose .. The problem is you will not only have to update maps of elements on the path but all the elements in the tree ...
05:15:07 <mux> mmm, I should try having a generic zipper implementation with GHC.Generics
05:15:43 <mysticc> mux: Isn't there already a generic zipper implementation ??
05:15:51 <imma> ciao
05:15:57 <imma> !list
05:16:00 <mysticc> oh that was for traversable class ..
05:16:10 <Peaker> mysticc: yeah, in the zipper tree case, that's true
05:16:37 <mysticc> Peaker: So in the end , any operation I do it will end up being O(n) ..
05:16:48 <Peaker> mysticc: but your tree was not a zipper
05:17:08 <Peaker> mysticc: if it isn't a zipper, then it would still be O(log^2 n)
05:19:58 <mysticc> Peaker: How ? .. I want to support two things .. a operation on tree which given 2 trees merges them (in a special way).. (which I am able to do in O(log n)) and given a key I want to get the root of the tree to which it belongs to ..In order for the first operation to persist I will end up updating every element of the new tree in the map ..
05:20:16 <matthiasgorgens> niteria: just get used to combinators, instead of recursion.
05:20:41 <matthiasgorgens> niteria: recursion is too powerful (i.e. easy to screw up, and makes you think too hard when reading) for most cases.
05:21:07 * mysticc thinks sometimes immutability make your life hell .. 
05:26:43 <Peaker> mysticc: When you change a tree node, you only change its branch, and so only keys in that branch need to be updated in your map to the new root
05:28:37 <Peaker> mysticc: oh, I see, you're right -- the root of all nodes changes with each modification
05:29:15 <Peaker> mysticc: Haskell has mutability if that's what you want :-)  With ST, the mutability gives nicer guarantees than in imperative languages
05:29:41 <ben> But less nice syntax <:)
05:30:20 <zomg> state syntax is not nice?
05:30:24 <Peaker> well, with the augustusson hack for lvalue/rvalues, Haskell *can* give nice mutability syntax
05:30:25 <matthiasgorgens> mysticc: you can always escape to IORefs or the state monad.
05:30:33 <mysticc> Peaker: Yeah .. I was trying to design a functional algorithm to union find algorithm .. nvm .. I think I will have to try some other way round ..
05:30:34 <Peaker> but the libs don't do it, there's less emphasis on it in Haskell
05:30:48 <Peaker> matthiasgorgens: State monad won't help here, his problem is operational semantics
05:30:53 <matthiasgorgens> Peaker: ok.
05:31:04 <mysticc> Peaker: It was never about the implementation .. it was about the algorithm being functional .. :P
05:31:09 <matthiasgorgens> mysticc: isn't union find notoriously hard to do fast purely functional?
05:31:19 <Peaker> mysticc: union find? Interesting -- I was toying with implementing a nice new way to do UFD a friend of mine wrote a paper about
05:31:22 <matthiasgorgens> mysticc: I remember there being papers about it.
05:32:11 <Peaker> Union Find is just not a persistent data structure, it's meant to be ephemeral
05:32:21 <mysticc> matthiasgorgens: Yup .. I thought of a mutable implementation .. then was thinking of a immutable data structure of the same ..
05:32:35 <Peaker> Union Find Delete, even more so
05:34:05 <mysticc> Peaker: Yeah .. until somebody finds a functional implementation .. :P .. I thought the same way about pointers in the imperative implementation of trees until I found zippers :P
05:34:38 <matthiasgorgens> mysticc: zippers even make sense in an imperative setting.
05:34:53 <matthiasgorgens> mysticc: you can imagine instead of having a double linked list,
05:35:08 <matthiasgorgens> mysticc: flipping the pointers from a->b to b->a as you traverse the list.
05:35:34 <matthiasgorgens> of course you need an extra pointer at the current node.
05:35:47 <mysticc> Peaker: What paper on UFD you were referring ..
05:36:01 <Peaker> mysticc: Well, persistent data structures are more restricted than ephemeral ones..
05:36:30 <matthiasgorgens> almost by definition.
05:36:55 <matthiasgorgens> though it's interesting to see how much you can get away with.
05:37:21 <matthiasgorgens> and if you don't care about a logarithmic factor, you can always convert to persistent.
05:38:00 <matthiasgorgens> (though caching and locality of access effects might make that even worse than logarithmic in practice.)
05:38:25 <kerneis> hi
05:38:46 <t7> there should be a case statement that works like this: f x = case x of 123 -> 345      becomes:    f = case'  123 -> 345
05:38:58 <kerneis> I stumbled upon this bug and think the fix is not enough: http://hackage.haskell.org/trac/ghc/ticket/5701
05:39:04 <t7> so case becomes an a -> b
05:39:26 <kerneis> I needed to force the installation of a more recent version of array (> 0.4)
05:39:50 <kerneis> where shall I report that? (seems I can't reopen the report)
05:39:52 <mysticc> t7: what happens when  case' does not match ?
05:39:54 <matthiasgorgens> t7, it's been discussed for some time.  an alternative name is something like lambda-with-cases or so.
05:40:18 <t7> mysticc: same as before
05:40:19 <matthiasgorgens> mysticc: you can have multiple lines.
05:40:33 <mysticc> Oh .. just the name .. OK ..
05:40:55 <matthiasgorgens> the proposed syntax was closer to "case of 123 -> 345"
05:41:10 <matthiasgorgens> just removing the expression in-between.
05:42:02 <t7> it wasnt implemented then?
05:42:26 <matthiasgorgens> I don't know whether somebody made an extension to ghc, yet.
05:42:47 <Peaker> matthiasgorgens: caching/etc don't affect asymptotic time, though.. they just make it a much much much worse constant in practice
05:42:58 <matthiasgorgens> t7, http://hackage.haskell.org/trac/ghc/ticket/4359
05:43:06 <matthiasgorgens> Peaker: yes.
05:43:35 <matthiasgorgens> Peaker: and in practice you have typical sizes, and caching makes speed a very step-wise function of sizes.
05:43:36 <weasels> :t mcase
05:43:36 <lambdabot> Not in scope: `mcase'
05:43:54 <mekeor> does such a type have a special name?: "data Foo = Bar Foo" ?
05:44:09 <Botje> i'd call that a wrapper
05:44:15 <Botje> and you might as well use a newtype :)
05:44:20 <mekeor> oh, yes
05:44:24 <matthiasgorgens> t7, what I also found useful to have is whenM, unlessM, and ifM.  to be used like:
05:44:49 <mekeor> Botje: okay, so no technial term…
05:44:53 <matthiasgorgens> ifM monadicConditionThingy monadicThenBranch monadicElseBranch
05:45:13 <matthiasgorgens> or, without the requirement for monads in the if' definition, just swap arguments around for:
05:45:26 <matthiasgorgens> monadicCondition >>= if' thenBrach elseBranch
05:45:34 <matthiasgorgens> if' :: a -> a -> Bool
05:46:17 <t7> simonpj came up with the nice solution:    \case { blah }  ==>   \x -> case x of { blah }
05:46:25 <weasels> > if False then undefined else 3
05:46:26 <lambdabot>   3
05:47:45 <matthiasgorgens> t7, but that still requires introducing a variable name.
05:48:16 <t7> no... ?
05:48:23 <matthiasgorgens> oops, I forgot that the ==> wasn't syntax.
05:48:34 <matthiasgorgens> I thought that one line was the proposal, not the translation rule.
05:49:22 <matthiasgorgens> another omission from haskell are or-patterns.
05:51:56 <t7> matthiasgorgens: wus da?
05:54:43 <hpc> t7: say you wanted to write (join either)
05:54:45 <hpc> :t join either
05:54:46 <lambdabot> forall a c. (a -> c) -> Either a a -> c
05:55:03 <hpc> je f (Right a) = f a
05:55:08 <hpc> je f (Left a) = f a
05:55:15 <hpc> an or-pattern would put that on one line
05:56:55 <cpa> hey there, I don't manage to install repa on OSX with the latest haskell-platform
05:57:15 <cpa> cabal: cannot configure repa-2.2.0.1. It requires base ==4.4.*
05:57:16 <cpa> For the dependency on base ==4.4.* there are these packages: base-4.4.0.0 and
05:57:16 <cpa> base-4.4.1.0. However none of them are available.
05:58:56 <dcoutts> cpa: do you understand what the message means?
05:59:49 <dcoutts> once you do, a potential solution is then relatively clear
06:00:09 <cpa> I tried cabal install base-4.4.1.0
06:00:20 <dcoutts> ok, so base is special, it cannot be upgraded
06:00:28 <dcoutts> the base version is fixed with your ghc version
06:00:40 <dcoutts> you've probably got base 4.3
06:01:03 <hpc> dcoutts: with the latest haskell platform?
06:01:05 <cpa> ghc -V is 7.0.4
06:01:20 <t7> @hoogle a -> a -> a
06:01:20 <lambdabot> Prelude asTypeOf :: a -> a -> a
06:01:21 <lambdabot> Network.BufferType buf_append :: BufferOp a -> a -> a -> a
06:01:21 <lambdabot> Prelude atan2 :: RealFloat a => a -> a -> a
06:01:22 <dcoutts> hpc, cpa: right
06:01:33 <t7> > asTypeOf 1 True
06:01:34 <lambdabot>   No instance for (GHC.Num.Num GHC.Bool.Bool)
06:01:34 <lambdabot>    arising from the literal `1'...
06:01:36 <hpc> oh, i see
06:01:43 <t7> > asTypeOf (1 :: Int) True
06:01:43 <lambdabot>   Couldn't match expected type `GHC.Types.Int'
06:01:44 <lambdabot>         against inferred type ...
06:01:45 <dcoutts> cpa: so there's then two solutions: 1: use a later ghc, 2: use an older repa
06:02:11 <cpa> later ghc means checking out from the repo and compiling it myself, right?
06:02:12 <hpc> will cabal automatically try older versions?
06:02:21 <hpc> cpa: or downloading a binary
06:02:41 <dcoutts> cpa: unless you know you need the latest repa, it'd be easier to get an older repa
06:02:48 <hpc> there's stable versions of ghc between yours and HEAD
06:02:53 <dcoutts> e.g. cabal install repa-2.1.1.5
06:03:07 <cpa> dcoutts: defintely, I'll do that
06:03:11 <cpa> thanks!
06:03:30 <dcoutts> cpa: if you know you need the latest repa, then yes you'd need to install ghc-7.2, there's binaries, but no HP
06:04:22 <dcoutts> hpc: the answer to that is a bit tricky
06:05:02 <dcoutts> hpc: the latest version of the old solver will do that with no warning. The new solver, I'm not so sure. But either way you'd want a warning if it picks an older version for some reason.
06:05:41 <dcoutts> hpc: apparently the answer is yes
06:05:45 <dcoutts> for the new solver
06:05:55 <dcoutts> and with no warnings
06:08:23 <hpc> dcoutts: interesting
06:08:48 <dcoutts> hpc: the new solver does limited backtracking
06:21:28 * mekeor is writing awesome code.
06:21:38 <hpaste> sdas pasted “dsa” at http://hpaste.org/64225
06:23:34 * hackagebot bio 0.5.2 - A bioinformatics library  http://hackage.haskell.org/package/bio-0.5.2 (KetilMalde)
06:26:10 <beginner> is there any compiler writing  introductory book with Haskell as the implementation language?
06:27:16 <hpc> beginner: dunno about compilers, but there's a haskell tutorial where you make a scheme interpreter
06:27:18 * mekeor would have interest for that too
06:27:27 <hpc> would be a neat book
06:27:56 * mekeor is writing a RPN calculator with high-order functions =)
06:28:40 <hpc> mekeor: you mean the left fold from lyah?
06:28:45 <mekeor> yep
06:29:36 <hpc> love that one; used it on my IRC bot when i was learning
06:29:48 <hpc> now my bot's in perl and i haven't bothered to reimplement it
06:29:52 <mekeor> yea, it's very simple
06:30:24 <beginner> hpc which tutorial is that?
06:30:32 <hpc> actually, i should try and write the RPN calculator as a regex loop
06:31:28 <hpc> beginner: http://en.wikibooks.org/wiki/Write_Yourself_a_Scheme_in_48_Hours
06:31:38 <beginner> ok
06:31:40 <beginner> thanks!
06:32:46 <osa1> I have just installed emcas 24 but text rendering is really slow, in emacs 23 it was way more faster, does anyone have any ideas?
06:33:37 <mekeor> #emacs ?
06:34:26 <osa1> whoa, sorry
06:38:34 * hackagebot monad-atom-simple 0.0.2 - Monadically map objects to unique ints.  http://hackage.haskell.org/package/monad-atom-simple-0.0.2 (GrzegorzChrupala)
06:38:53 <mysticc> Peaker: there ?
06:41:42 <Peaker> mysticc: sort of
06:45:38 <t7> @hoogle (a -> b -> m c)  -> m a -> m b -> m c
06:45:39 <lambdabot> Control.Monad zipWithM :: Monad m => (a -> b -> m c) -> [a] -> [b] -> m [c]
06:45:39 <lambdabot> Control.Monad zipWithM_ :: Monad m => (a -> b -> m c) -> [a] -> [b] -> m ()
06:45:39 <lambdabot> Control.Monad foldM :: Monad m => (a -> b -> m a) -> a -> [b] -> m a
06:45:50 <mysticc> Can there be a zipper of such mutually recursive data type .http://paste.pocoo.org/show/555561/ ..
06:46:48 <matthiasgorgens> mysticc: yes, but I don't know how you'd do it automatically.
06:47:18 <wern> Are type classes a good solution for generic code that handles different GUI widgets with common functionality? (e.g. Focusable, Clickable, …)?
06:47:34 <mysticc> matthiasgorgens: Not automatically .. The idea is .. my general structure is a binary tree on nodes .. but each node is also a part of a rose tree of height 1 ..
06:47:47 <matthiasgorgens> wern, have you looked at how other libraries handle that already?
06:49:03 <matthiasgorgens> mysticc: with height 1, you mean that only the top level is a rose tree, and the rest is binary?
06:49:14 <mysticc> matthiasgorgens: So to travel nodes .. there are 2  ways either travel from the binary tree .. or get to the root of a rose tree and travel its children ..
06:49:32 <matthiasgorgens> is there sharing that you'd like to preserve?
06:49:45 <mysticc> matthiasgorgens: Nope .. You can think every node is a part of 2 trees  .. yes two trees share the same node ...
06:49:53 <matthiasgorgens> i.e. can you reach a node from two different routes?
06:50:02 <mysticc> matthiasgorgens: yes ..
06:50:04 <matthiasgorgens> ok.
06:50:20 <matthiasgorgens> should your zipper be just traversable, or also be editable?
06:50:24 <matthiasgorgens> mutable.
06:50:42 <matthiasgorgens> or rather: we can mutate the elements easily, but should the structure also be changeable?
06:51:00 <matthiasgorgens> if your structure can be fixed, than you can use something like tying the knot.
06:51:28 <mysticc> mutable too ..  The binary tree will persist .. but I can change the root of rose trees ... like assign same root to more than one node ..
06:52:27 <mysticc> Peaker: ^^ you can also enter the discussion
06:52:38 <matthiasgorgens> if you can reach a node via multiple routes, it's actually not a tree any longer, but a general graph.  writing zippers for mutable graphs with cycles seems to be hard.
06:52:49 <matthiasgorgens> If you find a solution for that, let me know.
06:53:29 <mysticc> matthiasgorgens: If I can find a solution to that .. I think I can also solve UF .. :P
06:53:30 <hpaste> rribeiro pasted “Doubt about context reduction” at http://hpaste.org/64234
06:53:35 <matthiasgorgens> (I mean a solution that has an average constant runtime for navigating the tree, and mutating single elements.
06:53:57 <matthiasgorgens> mysticc: oh, I have something like a solution for the single-threaded case.
06:53:59 <rribeiro> Hello all, I'm with a doubt about context reduction in the presence of some haskell extensions
06:54:04 <matthiasgorgens> or at least an idea.
06:54:06 <wern> matthiasgorgens: I've mostly found GUI wrappers for native code (gtk, wx, etc). I'm looking for more Haskellish solutions to render many different widgets in opengl, and wonder if there are any best practices.
06:54:11 <rribeiro> Could someone help me with this?
06:54:28 <mysticc> matthiasgorgens: But my graph is not totally mutable .. only certain nodes are mutable .. which constitutes the root of the rose tree ..
06:54:58 <matthiasgorgens> wern, there was an example using the prompt monad to do UI.
06:55:07 <matthiasgorgens> mysticc: hmm, that might help.
06:56:28 <wern> matthiasgorgens: thanks, will look into it
06:56:44 <matthiasgorgens> wern, perhaps it was http://www.haskell.org/pipermail/haskell-cafe/2008-January/038047.html
06:56:48 <mysticc> matthiasgorgens: Problem is very restricted .. So what I will be going to do is to travel to a node from a binary tree .. and then move to the rose tree's root to which it belong and change it ..
06:57:02 <matthiasgorgens> wern, not exactly what you want, but an interesting approach for the problem of GUI and haskell.
06:57:23 <mysticc> matthiasgorgens: What idea you had .. and how single threaded affects it ..
06:57:43 <matthiasgorgens> mysticc: if you only have one future, you can replace every node with a list of all it's future states.
06:58:12 <matthiasgorgens> the list would have to be constructed lazily of course, but could also include replacement by a sub-tree.
06:59:17 <QinGW`> hello everyone
06:59:20 <matthiasgorgens> You just pretend all operations (in a single threaded manner) on your structure where known in advance (as a lazy list),
06:59:33 <matthiasgorgens> and use tying the knot to construct the whole shebang.
06:59:46 <QinGW`> Is there a one zip package to this url:http://hackage.haskell.org/packages/archive/
07:00:05 <matthiasgorgens> though I'd probably need to write a prototype to see, if that idea makes enough sense.
07:00:24 <luite> do you really want everything? it's around 1.5GB
07:00:39 <matthiasgorgens> it's a bit like the fib = 0: 1 : zipWith (+) fib (tail fib) example, but for graphs.
07:01:43 <mysticc> matthiasgorgens: looks interesting idea ..
07:01:59 <matthiasgorgens> you can pretent fib is a graph with one node and a future.
07:02:06 <mysticc> but in my case future is not fixed .. as far as I know ..
07:02:06 <matthiasgorgens> but it stays at one node.
07:02:17 <matthiasgorgens> mysticc: if you only have one future, you can pretend it's fixed.
07:02:57 <matthiasgorgens> fib future_operations = 0 : 1 : zipWith ($) future_operations (zipWith (+) fib (tail fib))
07:03:25 <matthiasgorgens> just be careful about not looking into the future for each level of `time', so that lazyness gets preserved.
07:03:53 <matthiasgorgens> There was also something about co-monads and cellular automata, that works similar,
07:03:58 <matthiasgorgens> but without changing the structure.
07:04:15 <matthiasgorgens> a blog post called "cellular automata are co-monadic" or so.
07:07:00 <matthiasgorgens> hmm, but each node would have to at least check for each operation in the list, whether it's affected by it.  that would probably at least logarithmic in the number of nodes.
07:07:10 <matthiasgorgens> and would destroy performance, I fear.
07:07:30 <matthiasgorgens> mysticc: Are you familiar with how to use two linked lists to build a queue?
07:08:21 <matthiasgorgens> mysticc: you can easily extend that to form a zipper over a very simple ring-like graph, i.e. a graph that only consists of one single cycle.  You can add and remove nodes, and mutate them, too.
07:08:54 <matthiasgorgens> but I don't know how you can extend that to even the case of the simplest graph with two cycles, like an 8 or so.
07:09:03 <matthiasgorgens> ('8' shaped graph.)
07:11:14 <mysticc> matthiasgorgens: hmm .. I should think a little more about that .. If that can be done .. a lot of problems will be solved ..
07:12:08 <matthiasgorgens> good luck.
07:12:36 <mysticc> matthiasgorgens: I still can not see how you were telling you can create a zipper over simple ring like graphs ...
07:14:02 <mysticc> matthiasgorgens: brb ... Thanks for all the help .. If you find something let me know ..
07:16:05 <matthiasgorgens> mysticc: look at the zipper for a list, and just join the ends.
07:25:05 <t7> @hoogle (a -> b) -> (c -> d) -> (a, c) -> (b, d)
07:25:05 <lambdabot> Data.Graph.Inductive.Query.Monad (><) :: (a -> b) -> (c -> d) -> (a, c) -> (b, d)
07:30:59 <dropdrive> How might I enforce, via types, the fact that for f :: a -> a -> b, f a1 a2 = f a2 a1 ?
07:32:35 <cmccann> dropdrive, I don't think you can in any meaningful way
07:32:57 <Peaker> mysticc: I think UF with logarithmic properties is pretty trivial, the main interest in UF is the O(alpha(N)) and O(1) complexities it reaches for worst/amortized of various operations
07:33:14 <benmachine> dropdrive: is 'a' an ordered type?
07:33:20 <Peaker> mysticc: so a functional UF may not be a very interesting achievement if it throws away the O(1)ness
07:33:30 <hpc> dropdrive: i think the best you could do is come up with a canonical ordering of arguments
07:33:41 <Peaker> mysticc: (by trivial, I mean just a naive Set or such)
07:33:44 <hpc> and have the other case flip the arguments to match
07:34:06 <mekeor> can i mattern match like "afunction (AContructor x) AContructor = ...; afunction _ = ..." ?
07:34:22 <mekeor> oh, i mean:
07:34:25 <Peaker> I haven't thought it through, so it may not be trivial, but I'm pretty sure it loses the main point/purpose behind UF
07:34:26 <mekeor> can i mattern match like "afunction (AContructor x) AContructor = ...; afunction _ _ = ..." ?
07:34:39 <hpc> mekeor: you can't match on functions, no
07:34:46 <mekeor> nooo
07:35:14 <hpc> mekeor: by function, i mean "value with type of (a -> b)"
07:35:49 <mekeor> ;-C   why not?
07:36:02 <ClaudiusMaximus> dropdrive: something like this might 'work' but quickly get awkward i think...    newtype UnorderedPair a = UP{ getUP :: (a, a) }  {- don't export newtype constructor UP -} ; unorderedPair :: Ord a => a -> a -> UnorderedPair a ; unorderedPair a b | a <= b = UP (a, b) | otherwise = UP (b, a)
07:36:23 <benmachine> ClaudiusMaximus: yeah, that was pretty much what I was thinking
07:36:40 <benmachine> f :: UnorderedPair a -> b
07:36:41 <hpc> mekeor: the short answer is "because the spec says"
07:36:56 <hpc> but it also would be difficult if not impossible
07:37:01 <benmachine> mekeor: it's not in general possible to prove that two functions are equal
07:37:27 <cmccann> pattern matching on injective functions would work just fine, I think
07:37:38 <mekeor> benmachine: hmm
07:37:52 <mysticc> Peaker: whats O(alpha(N)) ??
07:38:07 <benmachine> cmccann: what do you mean by work just fine? be semantically coherent? be actually implementable?
07:38:11 <mekeor> cmccann: right! just pass to different arguments and compare results or so... or? errr no
07:38:31 <mekeor> nah – total wrong.. forget it
07:38:32 <cmccann> er, sorry, I misread I think
07:38:42 <mekeor> me, too, lol :D
07:38:46 <cmccann> you could use injective functions as if they were constructors
07:39:00 <hpc> cmccann: then you have to prove injectivity :P
07:39:05 <cmccann> hand-waving lots of implementation difficulty
07:39:07 <benmachine> mekeor: it's easy to produce a function that is const undefined if and only if, say, the goldback conjecture is true
07:39:10 <benmachine> *goldbach
07:39:14 <cmccann> and assuming you had some way to convince the compiler they were injective blah blah
07:39:38 <hpc> theoretically, you could have the program bottom out if it can't determine equality
07:39:45 <benmachine> cmccann: well, the easiest way to prove injectivity would be to provide a left inverse, in which case pattern matching wouldn't be too hard
07:39:49 <hpc> but at that point, almost everything will bottom out, and it's just not worth it
07:39:52 <hpc> even if it did work
07:39:59 <cmccann> benmachine, yes
07:40:16 <cmccann> and arguably that's the notion that stuff like view patterns and n+k patterns are sort of approximating
07:40:22 <benmachine> yeah
07:40:29 <mekeor> but, well, can't the compiler just compare the names of the function??
07:40:29 <hpc> see also, agda
07:40:47 <benmachine> mekeor: but then 'show' and '\x -> show x' would be different, and we don't want that
07:41:03 <mekeor> hmm right
07:41:16 <cmccann> data constructors can be seen as injective functions with trivial inverses
07:41:17 <benmachine> mekeor: this is the problem, that it's easy to come up with functinos which are the same but not obviously so
07:41:31 <mysticc> Peaker: Oh .. understood..
07:41:33 <mekeor> yea, i see
07:53:38 * hackagebot cabal-file-th 0.2.2 - Template Haskell expressions for reading fields from a project's cabal file.  http://hackage.haskell.org/package/cabal-file-th-0.2.2 (SimonMichael)
07:54:19 <Peaker> mysticc: Inverse-ackermann
07:54:42 <Peaker> I don't really know the math behind the derivation of that asymptotic complexity. Sounds nuts to me, but that's the amortized cost of UF find, iirc :)
07:55:18 <hpc> for all intents and purposes, α = const 5
07:55:32 <hpc> because N has to get bigger than the universe to go higher
07:55:54 <luite> bigger than the universe?
07:56:15 <hpc> bigger than the number of (atoms | subatomic particles | grams | ...) in the universe
07:56:18 <cmccann> haha, inverse ackermann
07:56:44 <cmccann> what version of the ackermann function is that though? the usual form is two argument I think
07:56:46 <Peaker> hpc: well, the explosion principle in logic might want to have a word with you :)
07:56:54 <Peaker> cmccann: Ackermann(x,x)
07:56:57 <cmccann> ah
07:57:00 <Peaker> or rather, join ackermann :)
07:59:42 <Prelude> we are a haskell shop, so we are always tinkering with our software
08:04:05 <dropdrive> cmccann: benmachine: hpc: ClaudiusMaximus: Thanks, makes sense.  Are there "more powerful" languages that do support these types of facts?
08:04:27 <cmccann> dropdrive, theorem provers like Agda, obviously
08:04:37 <benmachine> dropdrive: well, Agda would allow you to actually *prove* that f x y = f y x
08:04:46 <benmachine> although that's not to say it would be easy or useful :P
08:06:47 <dropdrive> I see :)
08:07:33 <mekeor> oh my god. wow. great feeling, really. programming in haskell is like a drug, like music or like meditation! awesome!
08:07:49 <mekeor> okay. i'm sorry for posting this in here and not in *-blah…
08:08:39 * hackagebot funcmp 1.6 - Functional MetaPost  http://hackage.haskell.org/package/funcmp-1.6 (PeterSimons)
08:08:41 * hackagebot QuickAnnotate 0.1 - Annotation Framework  http://hackage.haskell.org/package/QuickAnnotate-0.1 (ShayanNajd)
08:09:11 <merijn> Is anyone outside #haskell fanatics actually using Agda? I thought most of academia is still using Coq
08:10:33 <mekeor> ask #agda
08:12:04 <mekeor> i know, #haskell is the best channel ever but sometimes it's not good that it is good to not ask questions not concerning haskell not in other channels
08:12:20 <gatlin> I am reading the Control.Arrow source and the bibliography on Arrows; it seems that Arrows would be fantastic for orchestrating parallel, distributed computation but I don't see much evidence of it in my (limited) googling
08:14:15 <hpc> gatlin: Strategies could be made into an arrow, theoretically
08:14:50 * mux notes 'deepseq' is one substitution away from being a nasty, and very funny package name
08:14:57 <gatlin> hehe
08:16:30 <gatlin> I may be misunderstanding the implications of arrows; they are simply a useful means of expressing stream processing. I just wonder if / why they are not used for more parallel computations
08:16:43 <gatlin> and some discussions I've read in here regarding the semantics of arrows vs other constructs go over my head
08:23:12 <merijn> I would guess something simple as, no one felt compelled to implement it before?
08:24:39 <gatlin> merijn: I would too. Sometimes asking yields a surprise answer, though, or a link to a paper with more details.
08:34:51 <brad_larsen> I looked on Hoogle but perhaps I missed it:  is there a way to convert a Handle into a Ptr CFile?
08:35:30 <ClaudiusMaximus> you might be able to go via Fd
08:35:31 <brad_larsen> I have a C function I'd like to call that takes (in C) a FILE * argument; I'd like to be able to use Haskell's stdout
08:36:04 <ClaudiusMaximus> you could FFI import C's stdout, which should be the same?
08:37:14 <brad_larsen> re C stdout:  it's probably the same descriptor as C's stdout?
08:37:20 <brad_larsen> I just wonder about buffering issues
08:37:20 <tgeeky> mux: derpseq?
08:37:28 <albel727> haha
08:37:39 <everythingWorks> > 3
08:37:39 <lambdabot>   3
08:37:46 <mux> tgeeky: hah, that works too ;-)
08:38:08 <benmachine> brad_larsen: well, I believe that FILE* does buffering and Handle does buffering and they're not in any way related
08:38:17 <BobbyBlack> @pl \x y -> (== Eq) (compare x y)
08:38:17 <lambdabot> ((Eq ==) .) . compare
08:38:35 <benmachine> brad_larsen: so yeah, buffering is a potential problem; can you just flush stdout, call the function, flush it again, or something?
08:39:58 <brad_larsen> benmachine: yeah, that's what I was worried about, two separate buffers on the f.d.
08:40:08 <brad_larsen> benmachine: google has led me to some code that might work!
08:40:12 <benmachine> neat :)
08:40:33 <brad_larsen> in the mtp package on hackage
08:40:46 <brad_larsen> http://hackage.haskell.org/packages/archive/mtp/latest/doc/html/src/Foreign-Handle.html
08:41:15 <Peaker> gatlin: I think the Arrow class is wrong... There are corrections upon it, though
08:41:50 <Peaker> gatlin: Arrow as it stands is basically a cumbersome representation of Applicative+Category that gives a few extra laws that link the two
08:42:25 <gatlin> Peaker: does this make using Arrows unattractive when compared to alternatives?
08:42:59 <Peaker> gatlin: IMO, yeah. The only upside is the existing preprocessor that gives a pointed-syntax to their use. But some would say that the preprocessor kind of sucks and generates bad composition code :)
08:43:26 <Peaker> But there are also Applicative syntax preprocessors (or at least one: "she")
08:44:21 <cmccann> gatlin, Arrow includes some functions that get in the way of modeling computations that differ notably from standard Haskell
08:45:18 <lysgaard> I want to express changes to a algebraic datastructure. Anyone know of an elegant way to do this in haskell. Much like an undo redo system.
08:45:27 <cmccann> two major points being that (***) is useful independent of (&&&), and that "arr" makes it impossible to enforce many invariants
08:45:28 <gatlin> my interest sprang from looking into the various FRP implementations and noticing that Yampa stands alone in its use of arrows
08:45:39 <cmccann> gatlin, it's not the only one
08:46:12 <cmccann> actually, Arrow-based FRP seems to be converging with iteratee-style stream processing
08:46:43 <cmccann> in the form of extended versions of the automaton arrow
08:47:37 <cmccann> lysgaard, changes to the type definition? or changes to values of that type?
08:48:57 <cmccann> gatlin, btw, you were asking about linear types the other day, right?
08:49:07 <tgeeky> i dislike 'arr' because it makes outsiders think we're all working during Code Like a Pirate day
08:49:17 <gatlin> Yes. I have a round-robin attention span
08:49:24 <dmwit> lysgaard:
08:49:25 <cmccann> gatlin, heh
08:49:26 <dmwit> ?hackage gdiff
08:49:26 <lambdabot> http://hackage.haskell.org/package/gdiff
08:49:33 <dmwit> perhaps
08:50:14 <dmwit> You might also like our paper on edit lenses, which discusses edit languages for a variety of data structures.
08:50:15 <cmccann> gatlin, well, relevant to both topics, Arrow can't express linear types/logic/whatever
08:50:24 <dmwit> http://dmwit.com/papers/201107EL.pdf
08:51:04 <gatlin> cmccann I figured as much. One subject only led tangentially to another
08:51:14 <cmccann> dmwit, hey that looks remarkably relevant to something I was thinking about a few months ago
08:51:28 * cmccann tosses that paper onto his reading list
08:51:32 <dmwit> \o/
08:51:44 <gatlin> cmccann you mentioned you were working on a stream processing library
08:52:04 <cmccann> gatlin, yes, but I've been incredibly sidetracked by other things :T
08:52:26 <gatlin> I'm interested in stream processing because I get the impression setting up a network of streams would be perfect for representing and evaluating neural nets
08:52:42 <gatlin> (or really any directed graph, I suppose)
08:52:50 <cmccann> well, there are a bunch of subtly different approaches floating around
08:53:30 <cmccann> the library I'm hacking on is an attempt to codify some of the differences as a semantics for linear logic
08:53:44 <hiptobecubic> Is there a function that pulls out some middle part of a list?
08:54:40 <lysgaard> dmwit: That looks like exactly what I was looking for, wow
08:54:58 <hiptobecubic> i guess some kind of combination of drop and take
08:55:03 <dmwit> Hooray, I'm useful!
08:55:17 <gatlin> cmccann my grand master plan is to create an edsl for answer set programming in Haskell
08:55:49 <gatlin> along with an action language to sit on top of it. Stream processing looks like a great way to model it (indeed, it seems like automata are an obvious use case)
08:56:25 <gatlin> so I keep asking you all about rather random things
08:57:14 <cmccann> gatlin, makes sense but not really a direction I've looked at much
08:57:26 <lysgaard> dmwit: I'll have to read up to understand it I think though.
08:57:37 * dmwit nods agreement
08:58:00 <cmccann> gatlin, I'd be interested to see if the approach I'm trying to hammer out would be useful for you
08:58:34 <cmccann> I'm not sure how to proceed on some aspects and having a fresh scenario to apply things to might help
08:58:51 <gatlin> cmccann if you have any links or code I'm happy to read / fork / whatever. I'm interested in learning all the things and if I can be of help that's a bonus
08:59:35 <cmccann> nothing public yet, unfortunately, it's kind of a mess of experimental hacking that I haven't finished cleaning up
09:00:44 <cmccann> I'm hoping to get a partial implementation to a usable-ish state and on github this weekend though
09:01:18 <gatlin> well, let's keep each other informed about our respective efforts
09:01:22 <cmccann> yeah
09:01:44 <cmccann> if you have any examples of what you'd like to use stream automata for I could make sure I have stuff to support that
09:02:17 <cmccann> particularly in how linear logic might relate
09:02:27 <gatlin> This ends up describing two basic action languages: http://www.cs.utexas.edu/users/vl/papers/BC.pdf
09:05:19 <gatlin> My acquaintance with linear logic is mostly in the narrow application of it to linear types - which is not-quite-orthogonal to what I'm doing because it is a method I could use but not the only one
09:05:48 <cmccann> the rough idea is that linearity corresponds to stream steps, so that e.g. linear implication means a stream transducer that produces one output for one input, &c.
09:06:27 <cmccann> so the additive connectives become branching streams that can move independently
09:06:46 <cmccann> while multiplicative connectives are lockstep synchronization
09:07:02 <gatlin> a friend of mine was giving me a crash course in additive vs multiplicative connectives
09:07:59 <gatlin> I think he sent me the paper by Girard but I think knowing add/mult connectives is a prereq (so far as I can tell)
09:09:36 <sap> "module Foo (Bar) where" does not work, when Foo is a type
09:09:48 <sap> but Foo is exported when there is no export list
09:09:54 <sap> why is that?
09:10:05 <cmccann> gatlin, I'm still hammering out some of the details for my library--I'm pretty sure it all works, but encoding the connectives properly is tricky
09:10:16 <hpc> sap: wait, so you have module Foo
09:10:17 <hpc> data Foo
09:10:19 <hpc> data Bar
09:10:23 <hpc> export list is (Bar)
09:10:34 <hpc> and data Foo is exported?
09:10:38 <sap> it is not "data Bar", but "type Bar"
09:10:55 <cmccann> gatlin, my ideal is that tautologies in linear logic should have obvious generic implementations in my library, and that falsehoods shouldn't be implementable at all
09:10:56 <sap> with explicit export list, Bar is not exported
09:11:05 <sap> with no export list at all, it is
09:11:37 <cmccann> I've been mostly learning linear logic as I go, though, so some things are a bit shaky still :T
09:11:49 <ClaudiusMaximus> module M(DataType(Constructors)) where -- to export the constructor as well as the type
09:12:36 <sap> it is just declared via "type", it does not/cannot have constructors
09:13:57 <sap> to rephrase it: "module Foo (Bar) where type Bar = Int" does not export Bar -- but "module Foo where type Bar = Int" does
09:22:28 <gatlin> cmccann if you were to suggest an FRP library (say, for modeling automata), what is your completely subjective opinion? It is difficult for me to vet all the ones I've found in a timely fashion and reading around the tubes there appear to be strong opinions
09:23:04 <cmccann> I'm nowhere near familiar enough with what's out there to give firm advice
09:23:39 <cmccann> but if you want stream-processing automata, I think netwire is the most actively-developed example of that right now
09:24:29 <gatlin> grazie. /me goes off on reading binge
09:24:37 * gatlin learns /me works only at beginning of line
09:25:08 <hpc> /anything only works at the start of the line
09:25:11 <hpc> (generally)
09:25:31 <hpc> (other clients might be very strange)
09:25:41 <cmccann> gatlin, also it's written by mm_freak_ who's around pretty regularly in here
09:25:45 <cmccann> and who usually seems happy to talk about it
09:25:55 <gatlin> boss
09:42:56 <parcs`> why does parsec's tokenizer thing differentiate between operators and identifiers?
09:44:25 <parcs`> hmm maybe to be more easily integrated with the expression parser
09:44:46 <c_wraith> parsec contains a bunch of helpers for specialized use cases
09:44:48 <c_wraith> that's one of them
09:49:37 <lukish> I have some semigroups-related algebra research and start writing my own module defining some semigroups relationships. Are there some semigroups and polygons modules? How can I found them?
09:49:54 <cmccann> hackage.haskell.org/package/semigroups
09:54:04 * ski notes linear logic was being mentioned
09:54:09 <ski> @ask gatlin "answer set programming" ?
09:54:09 <lambdabot> Consider it noted.
09:55:27 <cmccann> ski, interested in linear logic?
09:56:02 <ski> been for a long time
09:56:40 <cmccann> cool, I should bother you about that at some point
09:56:48 <cmccann> been looking into it a lot recently
09:57:08 <cmccann> mostly because of the library I was telling gatlin about
09:57:32 <ski> (it's still hard for me to get a good working intuition for `par', though)
09:57:37 * ski nods
09:58:08 <ski> is it a library that is a modification of the `Arrow' (and `Category' ?) classes, but in the same vein ?
09:58:15 <cmccann> yeah, nailing down how par needs to work has occupied about 80% of my time working on that library I think
09:58:18 <cmccann> no, it's very different
09:59:02 <ski> care to elaborate any ?
09:59:14 <cmccann> I'd love to but I need to leave in about 2min
09:59:57 <cmccann> but are you familiar with the automaton arrow stuff, or the various iteratee-influenced libraries, particularly pipes?
10:00:08 <parcs`> hmm, ghc is a little too strict with "makeTokenParser $ fix $ LanguageDef{..} -> LanguageDef { ..., identLetter = identStart, ... }"
10:00:36 <parcs`> however "fix $ \languageDef -> LanguageDef { identLetter = identStart identLetter }" works
10:00:36 <cmccann> ski, it's in similar spirit to much of that, but with linear connectives for merging streams
10:00:53 <cmccann> but I need to run, sorry
10:02:10 <Saizan> parcs`: does \ ~(LanguageDef{..}) -> .. work?
10:02:15 <parcs`> good idea
10:02:51 <parcs`> doesn't even parse :P
10:02:57 <Saizan> heh
10:03:43 <parcs`> (~LanguageDef{..}) does though, and it works!
10:03:54 <ski> @tell cmccann no, i'm not
10:03:55 <lambdabot> Consider it noted.
10:04:14 <ski> @tell cmccann (but i'd like to continue the conversation later, yes)
10:04:14 <lambdabot> Consider it noted.
10:06:08 <parcs`> i don't see why \LanguageDef{..} is too strict though
10:07:36 <dolio> Do you see why (\LanguageDef list of args -> ...) is too strict?
10:07:53 <dolio> Or \(LanguageDef list of args) -> ...
10:09:28 <parcs`> is it because ghc can't tell that the constructor is LanguageDef until the rhs is fully evaluated?
10:09:58 <dolio> If f is strict, then fix f is bottom.
10:10:05 <dolio> The question is whether you see why f is strict.
10:11:10 <parcs`> because it's pattern matching on the constructor?
10:11:16 <dolio> yes.
10:14:30 <erkin> What does "naked expression at top level" mean?
10:14:50 <c_wraith> it mean the expression isn't in a name binding
10:14:58 <parcs`> dolio: i see, thanks.
10:15:14 <c_wraith> top-level entries in a haskell source file must be declarations, not expressions
10:15:26 <parcs`> > fix (\Nothing -> Nothing)
10:15:30 <lambdabot>   mueval-core: Time limit exceeded
10:15:31 <erkin> Ah, got it.
10:59:22 <ZioTantaLana> ciao
10:59:25 <ZioTantaLana> list!
11:00:48 <tomodo> hello !
11:00:58 <tomodo> Does anyone know about alpha-beta AI
11:01:39 <tomodo> I want to program a game player using it
11:03:42 <c_wraith> alpha-beta is a search strategy for two-player games.  It's very simple in concept.
11:03:57 <c_wraith> pick your best move, assuming your opponent picks their best move.
11:04:02 <c_wraith> and so on.
11:04:07 <tomodo> yes
11:04:18 <c_wraith> The interesting parts are the heuristics you apply to prune the search space
11:04:23 <tomodo> and you can't search right down until a won game
11:04:26 <luite> that's just minimax, alpha beta is a way to prune
11:04:42 <tomodo> so you have to stop at a finite depth and "evaluate" the game state
11:04:53 <tromp__> my connect-4 program uses alpha-beta
11:05:03 <tomodo> I've ben reading about this algorithm
11:05:07 <luite> I wouldn't call it a heuristic, since it isn't really :)
11:05:52 <tomodo> tromp__: I wanted to make an AI for gomoku (connect 5 with no gravity)
11:06:07 <tromp__> in haskell?
11:06:15 <tomodo> but maybe the branching is too high
11:06:39 <hpaste> “Horribly written algorithm” pasted “erkin” at http://hpaste.org/64242
11:06:47 <tomodo> I tried it in scheme because I thought fast mutable arrays would make it work, but it turned out really slow
11:06:56 <erkin> Does anybody know how I can write this in a better way?
11:07:02 <hpc> tomodo: it's a pretty big branching factor
11:07:04 <tomodo> maybe I should use haskelli instead
11:07:15 <hpc> connect-4 is easy because the choices are columns
11:07:22 <tomodo> hpc: I only considered drops adjacent to the other pieces to reduce the space
11:07:45 <tromp__> my program solves the game exhaustively (depth 42)
11:08:01 <tomodo> cool
11:08:18 <tromp__> but haskell version is like 20x slower than C :(
11:08:30 <tomodo> maybe I should use C then
11:08:33 <tomodo> but I don't like it
11:08:43 <tomodo> it's too hard
11:08:59 <companion_cube> maybe the good thing is to mix some C code with some haskell code ;)
11:09:25 <Botje> erkin: uh, tail (sort xs) isn't the last element of xs
11:09:48 <Botje> erkin: and are you sure you're not supposed to grab five *adjacent* digits?
11:10:09 <tomodo> I'm not having an suceess with programing :(
11:10:18 <ClaudiusMaximus> > 9^5
11:10:19 <lambdabot>   59049
11:10:21 <erkin> This is why I should read before I write... Or I end up wasting hours...
11:10:27 <erkin> Sigh.
11:14:17 <tomodo> I don't know what to do
11:15:52 <byorgey> erkin: digits x = map digitToInt (show x)  can be rewritten   digits = map digitToInt . show
11:16:32 <zerax> tomodo: So what's the problem you have right now?
11:16:34 <byorgey> erkin: also, x2 can be rewritten   x2 = map product (replicateM 5 x1)
11:16:37 <erkin> That's not the problem. The problem is the whole algorithm tries like 5 trillion combinations.
11:16:42 <erkin> Oh.
11:17:02 <byorgey> erkin: I know, I was just pointing out stylistic improvements
11:17:08 <erkin> That's good too.
11:17:38 <tomodo> zerax: since my program is too slow, I don't know how to fix or whether it can be fixed
11:17:51 <byorgey> erkin: is this a Project Euler problem?
11:18:02 <erkin> Yes. A misread one that costed me hours.
11:18:07 <byorgey> hehe, doh
11:18:17 <byorgey> which one?
11:18:21 <erkin> Yeah... At least it was good for practice and experience.
11:18:23 <erkin> 8th.
11:18:53 <zerax> tomodo: Are you currently trying to evaluate until completion of the game?
11:19:17 <tomodo> zerax: even just searching 1 level deep went slow
11:19:42 <byorgey> erkin: ah, I see
11:20:16 <zerax> What? That should not be. Have you shown some code that is representative of what you're doing?
11:20:42 <tomodo> I abandoned my code
11:21:42 <zerax> Ah
11:21:53 <funguy> trying to install yesod w/ghc 7.4.1 - getting build error on transformers-base-0.4.1: http://pastebin.com/yz52EMbP
11:21:55 <mauke> The paste yz52EMbP has been copied to http://hpaste.org/64243
11:22:32 <rwbarton> I learned gomoku as played on an infinite board
11:23:02 <rwbarton> that might give you some branching factor problems. :)
11:23:06 <tomodo> I only used 19x19
11:23:08 <tomodo> haha
11:25:25 <tomodo> infinite board. that must be to do with NP complete
11:26:48 <luite> you often have EXPTIME completeness with that kind of games with boardsize the parameter
11:27:07 <yrlnry> And often PSPACE-completeness.
11:27:51 <c_wraith> infinite board doesn't really change go-moku much.
11:27:53 <luite> EXPTIME completenes implies PSPACE completeness
11:28:02 <yrlnry> Those winning-strategy questions often turn out to be asking if some quantified boolean formula can be satisfied, and QBF is the canonical PSPACE-complete problem.
11:28:39 <opqdonut> actually EXPTIME is strictly more expressive than PSPACE
11:28:42 <luite> wait that's not true, yeah
11:28:43 <rostayob> is there a way to convert a value to an TH Exp?
11:28:58 <luite> I should've said hardness
11:29:12 <opqdonut> yeah, right
11:29:47 <rostayob> ok, th-lift
11:32:11 <rostayob> it's strange that there is no integrated facility to derive Lift
11:34:46 <t7> is there a neutrino based network protocol yet?
11:36:16 <PhilRod_> t7: people discuss things like that apparently seriously: http://arxiv.org/abs/0909.4554
11:36:27 <PhilRod_> (the author is a reputable neutrino physicist)
11:40:40 <jfischoff> rostayob: someone made a patch but SPJ argued against it: http://haskell.1045720.n5.nabble.com/Lift-instances-of-the-AST-related-types-td3197703.html
11:40:53 <dylukes> https://gist.github.com/1894570
11:41:01 <dylukes> Anyone care to sound off on why this might be happening?...
11:41:32 <opqdonut> wow
11:41:34 <rata_> hi guys
11:41:38 <opqdonut> charset issue?
11:42:15 <c_wraith> No, preprocessor issue.
11:42:19 <c_wraith> it's expecting C code
11:42:38 <c_wraith> So it's blowing up when the input doesn't follow C lexing rules
11:42:56 <Varifold> Greetings.
11:43:04 <dylukes> Any thoughts on a fix?
11:43:23 <dylukes> I'm installing clang 3.0, since I know that worked... (I'm using 4.0 now)
11:43:43 <c_wraith> stop using unbalanced single quotes :)
11:44:03 <opqdonut> :D
11:44:18 <rwbarton> runhaskell Setup.lhs build 2>/dev/null
11:44:31 <t7> monochrom: is allways on quotes of the week
11:44:34 <Rc43> Hi, guys.
11:44:42 <zero_> what does the >>= operator do?
11:44:50 <tgeeky> Rc43: hello, adult human operator.
11:44:58 <c_wraith> zero_: whatever it's defined to do.
11:44:58 <t7> binds the ties
11:45:17 <tgeeky> has anyone here used "An Introduction to Category Theory" -- H. Simmons 2011
11:45:17 <c_wraith> zero_: it's a type class function.  It does different things for different types.
11:45:17 <Varifold> zero_, it's the bind operator. Look up the structure of monads, or the structure of your concrete monad in action to find out what bind does in your case.
11:45:18 <t7> the ties that bind, i mean
11:45:36 <zero_> ohh okk, thanks!
11:45:59 <Rc43> How to dynamically dispatch between functions on variable type? I am parsing commands and want to use my functions like `createInt` if int is parsed, `createBool` if bool is parsed, etc
11:46:08 <Varifold> tgeeky, I don't know that book but Awodey is certainly a good introduction.
11:46:22 <Rc43> tgeeky, o_0
11:46:42 <tgeeky> Varifold: I'll contrast and compare.
11:47:06 <rwbarton> Rc43: what does "if int is parsed" mean?
11:47:19 <Varifold> tgeeky, alternatively, there is a book called "Categories and Sheaves" by Kashiwara/Schapira, which is hardcore and dry as a desert, but if you have the mathematical prerequisites to bring the abstractions to life, it's certainly a great book.
11:47:25 <jfischoff> Rc43: post your code in a paste
11:47:51 <tgeeky> Varifold: I do not. I liked this book so far because it's rather more visual and well layed out than I have seen
11:48:48 <Varifold> tgeeky, I suggest to study abstract algebra first or simultaneously. Category Theory is not going to be of much use to you without a huge amount of concrete examples at hand for all the various abstract concepts.
11:49:03 <Rc43> rwbarton, example "create 1" => ` ... read x ... >>= createInt`
11:49:09 <Rc43> jfischoff, ok
11:49:18 <tgeeky> Varifold: that is the other thing. This book dedicates several chapters to examples of categories of varying difficulty
11:49:30 <zerax> Introduction to Category Theory is pretty good in terms of examples, although I suspect for a novice some additional explanation of some of the notation would be beneficial.
11:49:37 <tgeeky> Varifold: I "took" the awesome abstract algebra course by Benedict Gross @ Harvard
11:50:00 <hpaste> Rc43 pasted “dynamic dispatching on type” at http://hpaste.org/64245
11:50:06 <Rc43> http://hpaste.org/64245
11:50:11 <tgeeky> Varifold: I really intend to sit down and type out as much of the book as I can in haskell code
11:50:16 <Rc43> oh, it is here already
11:50:25 <rwbarton> FYI "vertice" is not a word
11:50:35 <rwbarton> you probably mean "vertex"
11:51:01 <tgeeky> rwbarton: curiously, it is spelled like it sounds
11:51:28 <Varifold> tgeeky, then throw some topology and algebraic topology in, if you have the algebraic prerequisites. There is a book, by the way, called "Computational Category Theory" which has plenty of implementations of categorical concepts in StandardML. You might want to take a look. It is at some point going to be difficult to do the same in Haskell due to type system issues, I guess, but still... worth a look.
11:51:37 <rwbarton> Rc43, 'read' doesn't attempt to guess the "type" of what you pass in.
11:51:49 <rwbarton> You, the caller of 'read', must tell it what type you want to read a value of.
11:51:50 <Rc43> rwbarton, yes, it is the problem
11:51:57 <jfischoff> you need a parser
11:52:01 <rwbarton> yes.
11:52:06 <tgeeky> Varifold: singly noted. I don't know why people always dully note things.
11:52:06 <Rc43> rwbarton, but I don't want to write `create int 1`
11:52:18 <Rc43> I want to do it automatically
11:52:21 <jfischoff> sure
11:52:28 <jfischoff> you can
11:52:31 <Rc43> read is a parser, not?
11:52:44 <rwbarton> for any given type, read is a parser of that type
11:52:52 <jfischoff> yeah, but you want to parse into a universe of types
11:53:18 <jfischoff> data Universe = I Int | B Bool
11:53:30 <rwbarton> there's no reason a priori that there shouldn't be a string which could be parsed by 'read' at either of two types, for instance
11:54:06 <Rc43> yeah
11:54:16 <Rc43> Can I get possible (type, value) pairs?
11:54:20 <rwbarton> no.
11:54:26 <rwbarton> that makes no sense.
11:54:32 <Rc43> Just types?
11:54:34 <tgeeky> not in haskell, at least
11:54:38 <rwbarton> the type direction is extensible
11:54:58 <rwbarton> you could write your own function that tries to read as an Int, and then if it fails, tries to read as a Bool
11:55:06 <Rc43> When haskell determines that there is more than one type to parse?
11:55:11 <rwbarton> what?
11:55:20 <tgeeky> Rc43: you are generally confused here
11:55:20 <Varifold> tgeeky, I doubt, though, that you will get into the deep meaning of the concepts by implementing them in Haskell alone. You will at best express it, or some slight concretization of it, in a different language. The point is that abstractions are useful to hide things. Without the mathematical maturity to even have things to hide, Category Theory isn't of much use. So, what you are basically doing it a brutal top-to-bottom approach
11:55:20 <Varifold> which might fail or not. But to make it less likely to fail, you should start early-on to make the abstract concepts come to life with mathematical examples, and not with Haskell.
11:55:35 <tomodo> it is decided what sort of thing read and what type of value it returns at compile time
11:55:40 <rwbarton> like I said 'read' doesn't ever decide what type to return based on the input string.
11:56:00 <Rc43> rwbarton, if it talks that it can't determine type variable then it found more than one candidates, right?
11:56:02 <tgeeky> Varifold: well, I only mean that I don't have an instructor to test me, so I was going to write as much as I could in haskell and make poor saps in here grade me :)
11:56:06 <Rc43> rwbarton, can I get them?
11:56:29 <rwbarton> yeah so at compile time, you will probably get something like an ambiguous type variable error with your current program
11:56:41 <rwbarton> right?
11:56:48 <zerax> It's a top-down parser, it attempts to match a rule, in this case a type. Rather than trying to determine the type given the input, which it can't because you can't parse it unambiguously.
11:57:09 <Varifold> tgeeky, you don't need an instructor if your approach is good. For instance, when I study mathematical literature, I do all the proofs by myself without reading them first. That way you can actively test your understanding on the fly.
11:57:35 <rwbarton> Rc43: the candidates are every type that is an instance of Read
11:57:41 <rwbarton> which is potentially any type at all
11:57:54 <Varifold> tgeeky, if you understand what you have studied up to that point, it is highly likely that your own proof will be structurally similar to what was given in the book.
11:58:02 <Rc43> rwbarton, if there is no constraints
11:58:08 <rwbarton> you could ask ghci to list what instances of Read it currently has in scope... this isn't a productive direction to go though
11:58:13 <Rc43> rwbarton, but I get what you are talking about
11:58:15 <Rc43> *got
11:58:39 <mux> can we do package-qualified imports in GHC now?
11:58:42 <rwbarton> you should write a parser that returns something of a sum type like jfischoff said (data Universe = I Int | B Bool)
11:58:49 <tgeeky> mux: since 7.2, I think, yes
11:58:52 <tgeeky> maybe since 7.0
11:58:53 <rwbarton> you could use reads to help write this
11:59:02 <rwbarton> then do dispatch based on the constructor (I vs. B)
11:59:08 <rwbarton> not on the (static) type of anything
11:59:10 <tgeeky> import "myprelude" Prelude, etc
11:59:19 <mux> tgeeky: yay! thank you
11:59:30 <jfischoff> Rc43: I'm writing some code for you
11:59:39 <zerax> Rc4: Are the serialised form of the types you want to pass distinguishable?
11:59:48 <zerax> parse even
12:00:37 <Rc43> zerax, yes
12:00:46 <Rc43> zerax, but not from first step off course
12:01:04 <Rc43> zerax, (if it was so it would be equal to use "create int 1")
12:01:07 <zerax> Naturally
12:01:15 <tgeeky> mux: -XPackageImports, I think
12:01:18 <Rc43> only Int, Double, String, Boold, List
12:02:04 <mux> tgeeky: yep, found the docs about it
12:08:07 <rwbarton> Rc43: here is another way to say it. You don't want a variable which "might be of type Bool, and might be of type Int". You want a variable of a type which has a value for each Bool, and also a value for each Int.
12:08:40 <Rc43> Could you give an example?
12:08:47 <rwbarton> data Universe = I Int | B Bool
12:08:52 <rwbarton> parse :: String -> Universe
12:09:00 <rwbarton> doSomething :: Universe -> IO Whatever
12:09:54 <Rc43> About first way - how can we connect set of types which are in combinated type (data X = I int | B bool) with class Creatable?
12:10:33 <rwbarton> not sure why you want a type class, but "doSomething (I i) = create i; doSomething (B b) = create b"
12:10:57 <Rc43> And why we can't trivial way use Creatable, introducing another combinated data would be a duplication of information (we already described in type class it).
12:11:03 <rwbarton> no, it doesn't
12:11:11 <jfischoff> Rc43: I updated your pasted http://hpaste.org/edit/64245
12:11:11 <rwbarton> type classes are open
12:11:39 <rwbarton> also, you probably don't want a type class
12:11:42 <jfischoff> Rc43: Parsec is what I usually use for parsing, but that example should give you the idea
12:11:46 <elliott> Rc43: You don't want a typeclass.
12:11:46 <Rc43> jfischoff, thanks, I will look in a few seconds
12:11:53 <rwbarton> jfischoff: I think you need to hit submit...?
12:12:12 <hpaste> “Jonathan Fischoff” annotated “dynamic dispatching on type” with “dynamic dispatching on type (annotation)” at http://hpaste.org/64245#a64247
12:13:10 <rwbarton> Rc43: basically the question should be why not trivially use Universe, introducing a type class would be duplication of information
12:13:14 <Rc43> rwbarton, really, I can replace type class with combined type
12:13:19 <rwbarton> they are not the same
12:13:52 <rwbarton> and it's hard to tell why you think you want a type class
12:14:04 <rwbarton> but I would encourage you to consider a design which does not involve type classes
12:15:28 <jfischoff> when first learning haskell, there is an impulse to use type classes where one would use interfaces in an object oriented language. They're not the same. rwbarton is right try not to use them.
12:16:34 <Rc43> Is it a common statement aboud type classes? (I mean `classes < datas`)
12:16:52 <hpc> jfischoff: type classes are the same as SOME interfaces
12:17:00 <hpc> for instance
12:17:06 <hpc> class Num a where ...
12:17:15 <hpc> interface Num<A> {...
12:17:23 <rwbarton> that's not a very good example!
12:17:35 <rwbarton> @type fromInteger
12:17:35 <lambdabot> forall a. (Num a) => Integer -> a
12:18:41 <elliott> hpc: that can't be done as an interface...
12:19:41 <hpc> in any event, the bigger mistake is thinking in OO at all
12:19:54 <Rc43> jfischoff, btw, won't using a Maybe in your code more convenient?
12:20:02 <ski> Varifold : "It is at some point going to be difficult to do the same in Haskell due to type system issues" -- how so ?
12:20:04 <jfischoff> Rc43: you are correct
12:20:24 <jfischoff> Rc43: Error handling is something parsec would give you
12:20:48 <jfischoff> Rc43: I was more just trying to give you the idea, rather then show perfect code
12:21:01 <Rc43> jfischoff, I think Parsec is too huge tool to use it here
12:21:20 <Rc43> jfischoof, yeah, understood
12:21:41 <rwbarton> how about
12:21:45 <Philippa> what's jfischoff trying to parse?
12:21:51 <Philippa> (I'm happy to throw parsec at fairly small langs, but I'm plenty familiar with it)
12:21:51 <jfischoff> probably, but the haskell parser combinators are good
12:22:12 <jfischoff> Rc43: learn them as soon as you can
12:22:24 * ski . o O ( `[I i | (i,"") <- take 1 (readDec x)]' )
12:22:25 <rwbarton> :t let readBy f x = map f [ v | (v, "") <- reads x ] in readBy
12:22:26 <lambdabot> forall a b. (Read a) => (a -> b) -> String -> [b]
12:22:37 <Rc43> jfischoof, I have used it in university severaltimes
12:22:43 <rwbarton> \x -> readBy I x ++ readBy B x :: String -> [Universe]
12:22:45 <ski> Philippa : Rc43 is trying to parse a string as either an `Int' or a `Bool'
12:23:28 <Philippa> ski: as in, choice between their existing read funcs? Yeah, that I wouldn't use Parsec for
12:23:54 <ski> well, maybe Rc43 wants to do more as well, we don't know yet
12:24:36 <sclv> > minBound :: Int
12:24:37 <lambdabot>   -9223372036854775808
12:24:41 <sclv> > negate minBound :: Int
12:24:41 <lambdabot>   -9223372036854775808
12:24:47 <Rc43> ski, not only int and bool, in other the same
12:24:57 <ski> (Rc43 was essentially asking for something like `String -> exists a. Foo a *> a')
12:25:14 <sclv> > let m = (minBound :: Int) in m == negate m
12:25:14 <lambdabot>   True
12:25:18 <sclv> :-(
12:25:32 <ski> > let m = (0 :: Int) in m == negate m
12:25:33 <lambdabot>   True
12:25:43 <sclv> I always knew floating point was hard. But I didn't realize that 2's comp arith had a corner case too...
12:25:49 <sclv> ski :-)
12:26:35 <edwardk> preflex: xseen koninkje_away
12:26:36 <preflex>  koninkje_away was last seen on freenode 137 days, 23 hours, 35 minutes and 28 seconds ago, saying: <private message>
12:26:50 <jfischoff> sclv: is that platform dependent?
12:26:50 <Rc43> ski, how it is called?
12:26:54 <Varifold> ski, for no concrete reason. Intuitively, I think that not all proofs in "Computational Category Theory" can be expressed in Haskell. But I could be wrong.
12:27:01 <Rc43> ExistentialTypes? (`exists a. Foo a *> a') [00:24] <sclv> > let m = (minBound :: Int) in m == negate m`)
12:27:04 <ski> Rc43 : btw, note that in general you do not want `String -> Maybe Universe', you want `String -> Maybe (Universe,String)' or `String -> [(Universe,String)]' (and this latter can be abbreviated as `ReadS Universe')
12:27:15 <ski> Rc43 : how is what called ?
12:27:26 <Rc43> `exists a. Foo a *> a')`
12:27:37 * elliott mumbles that Rc43 does not want existential types.
12:27:38 <Rc43> existential types?
12:27:45 <sclv> jfischoff: my impression is that this is just what happens in 2's comp.
12:27:55 <ski> Varifold : i can't think of any part of the type system in SML which couldn't be expressed in Haskell (the module system is another thing)
12:27:59 <sclv> so if there's a platform that doesn't implement ints that way, then maybe...
12:28:04 <Rc43> elliott, just want to know what is it
12:28:09 <elliott> Rc43: ok
12:28:19 <ski> Rc43 : yes, that would be using an existential quantifier
12:28:51 <edwardk> ski: well, modules and typeclasses have a mutual representation. didn't chakravarty write that up at some point?
12:29:09 <Rc43> I am already use them in my project in other place, I think I will use same combined type there.
12:29:19 <Rc43> (instead of existential)
12:29:24 <edwardk> http://www.cse.unsw.edu.au/~chak/papers/modules-classes.pdf
12:29:26 <cmccann> elliott, some programmers have a problem to solve and think "I know, I need an existential type." now they have another problem, but can't solve it because all they know about it is that the problem exists.
12:29:26 <lambdabot> cmccann: You have 2 new messages. '/msg lambdabot @messages' to read them.
12:29:35 <edwardk> cmccann: =P
12:29:41 <elliott> @remember cmccann some programmers have a problem to solve and think "I know, I need an existential type." now they have another problem, but can't solve it because all they know about it is that the problem exists.
12:29:41 <lambdabot> Done.
12:29:44 <cmccann> :D
12:29:59 <geekosaur> heh
12:30:11 <gregAtio> how do you use djinn to generate you function signature?
12:30:28 <elliott> you can't
12:30:33 <elliott> you need a type to use djinn :P
12:30:36 <Philippa> Rc43: for a general case, how do you want to handle ambiguity?
12:30:48 <gregAtio> in ghci?
12:31:10 <Botje> gregAtio: :t yourFunction
12:31:11 <Philippa> edwardk: I still find encoding modules in typeclasses too painful to use in practice. I've used record-based encodings in anger before
12:31:23 <rwbarton> the Report doesn't say much about Int except that is bounded and can represent at least a certain range of integers
12:31:23 <edwardk> *nods*
12:31:25 <Botje> gregAtio: though that's not djinn, djinn goes from types to function definition.
12:31:34 <Rc43> Philippa, with this combined type? By hand (in this case just any = first)
12:31:50 <mjrosenb> @djinn a -> b -> a
12:31:50 <lambdabot> f a _ = a
12:31:58 <hpc> :t f -- definition to type
12:31:59 <mjrosenb> gregAtio: like that ^
12:31:59 <lambdabot> forall a. (SimpleReflect.FromExpr a) => a
12:32:14 <edwardk> the record based approach is usable enough. i find that i occasionally want to close over values from an environment when working with the type class encoding, which is why i still maintain reflection
12:32:17 <Philippa> Rc43: having a central data structure that's eg a list of acceptable types and their parsers can work
12:33:00 <ski> edwardk : yeah, i was talking about a more direct encoding, here
12:33:06 <Philippa> yeah. The record based approach winds me up about record encodings, admittedly :-) But I'm still capable of giving architecture astronauts a dose of cosmic horror, so hey...
12:33:46 <hpc> Philippa: the only data type is String :P
12:34:28 <Philippa> I disagree
12:34:32 <Philippa> the only data type is Nat!
12:34:38 <Philippa> (which succs)
12:35:04 <aristid> I disagree, the only data type is ℕ
12:35:06 <Rc43> Philippa, yes, but there is ambiguity resolving by hand in your way, too.
12:35:43 <Philippa> Rc43: Yes, totally
12:35:54 <sclv> Philippa: groan
12:36:08 <Philippa> it owns up to it fairly clearly though, which is the idea
12:36:29 <Philippa> (and factors that away from your parsing 'dispatch loop')
12:36:31 <hpc> peano arithmetic SSSSZ life
12:36:36 <cmccann> ha
12:36:46 <sclv> @remember Philippa The only data type is Nat! (Which succs).
12:36:46 <lambdabot> Good to know.
12:41:29 <elliott> @remember hpc peano arithmetic SSSSZ life
12:41:29 <lambdabot> Okay.
12:41:51 <Botje> hpc: please to be making tshirts.
12:42:04 <hpc> haha
12:42:15 <Philippa> elliott: it's an existing/known quote/gag
12:42:19 <Botje> i'd buy that.
12:42:29 <`Jake`> what size do you guys use for tabs?
12:42:39 <elliott> Philippa: But does lambdabot know it yet?
12:42:39 <qpu> quarter inch
12:42:42 <elliott> @quote SSSSZ
12:42:42 <lambdabot> hpc says: peano arithmetic SSSSZ life
12:43:02 <`Jake`> in spaces?
12:43:04 <hpc> that's not actually mine; it was a -blah topic at one point
12:43:31 <Philippa> `Jake`: I don't, but soft 4 space tabs are a fair choice
12:43:38 <Philippa> try not to put hard tabs in Haskell source
12:44:04 <`Jake`> Well, i suppose using them for guards is not too bad, is it
12:44:34 <Philippa> depends: if you end up with something that induces layout on the RHS of the guard, you could still end up with confusion down the line
12:44:35 <t7> i use tabs because its the only sane thing todo
12:44:52 <mauke> t7: what, in haskell?
12:44:59 <t7> in everything
12:45:05 <mauke> haskell isn't everything
12:45:13 <cmccann> the layout rules treat tabs correctly in a way that basically nothing else does, including most editors
12:45:15 <t7> no but its in everything
12:45:17 <mauke> in particular, haskell syntax doesn't work like any other syntax
12:45:34 <t7> it works like python
12:45:36 <mauke> no
12:45:39 <t7> kinda
12:45:39 <hpc> not even
12:45:40 <cmccann> no, it doesn't
12:45:58 <mauke> haskell isn't based on the idea of indenting code
12:46:03 <mauke> it's based on making things line up
12:46:06 <cmccann> haskell cares about column alignment, not indentation depth
12:46:11 <t7> no it doesnt
12:46:23 <Philippa> t7: RTFReport
12:46:28 <hpc> mauke: oh man, that perfectly sums up my problem with python's idea of whitespace sensitivity
12:46:40 <t7> https://github.com/tm1rbrt/haskell all the code here builds fine
12:46:53 <t7> and i use indentation level
12:46:58 <Philippa> Haskell layout is defined in terms of indentation depth, with tabs defined as 8 spaces
12:47:11 <hpc> t7: it builds because it lines up
12:47:16 <cmccann> the block-level indentation in python translates well enough to very simple do blocks because that's pretty similar to python code
12:47:22 <Philippa> sorry, I care about your examples as opposed to /the definition of the language/ why?
12:47:26 <cmccann> but it falls down badly beyond that
12:47:31 <Rc43> Can I create type from existent type with constraints? For example `type NonEmptyList a = [a] and <notEmpty>` ?
12:47:35 <elliott> t7: haskell has alignment rules
12:47:42 <mauke> t7: you don't "use indentation level" because that indentation is fucking ugly
12:47:52 <Philippa> Rc43: not really, no
12:47:55 <mauke> t7: look at pawns.hs lines 67 .. 69
12:48:00 <t7> its just parent indentation + 1 tab
12:48:05 <mauke> t7: look at pawns.hs lines 67 .. 69
12:48:06 <mee> I think of haskell layout as the same sort of layout I use when doing math calculations by hand.
12:48:13 <Philippa> Rc43: in principle you could use the Curry-Howard isomorphism to attach proofs that those constraints hold, but Haskell lets you lie through your teeth
12:48:45 <Philippa> t7: yes, that happens to work. But it's still defined in terms of indentation depth. Read the Haskell 2010 Report
12:48:46 <cmccann> haskell layout has more in common with ASCII art than python indentation
12:49:14 <Philippa> incidentally, I've /implemented/ layout per the spec. In fact, I made parsec 3 happen via SoC just so I could do so :p
12:49:18 <elliott> Rc43: Philippa: you'd need dependent types to be able to express the emptiness of the /value/ anyway
12:49:22 <elliott> unless you defined your own list type
12:49:24 <Philippa> (that's not as much of an exaggeration as it should be
12:50:07 <mauke> t7: you've got tabs in the middle of lines. that's broken in any language.
12:50:17 <t7> well i shouldnt have
12:50:23 <t7> thats just a mistake
12:50:30 <mauke> https://github.com/tm1rbrt/haskell/blob/master/poker/hand.hs line 171
12:50:31 <jfischoff> Rc43: what are you trying to accomplish?
12:51:09 <elliott> mauke: yay, tabs for alignment and not even assuming 8-width tabs
12:51:10 <t7> yeah look at the lambda calc section, thats the only bit that isnt from when i was first learning
12:51:11 <Philippa> t7: as a rule of thumb, when (generic) you make a claim about a language and people tell you it's wrong while citing the language's definition, there's a good chance that you're wrong in letter regardless of spirit?
12:51:34 <t7> yeah i mean ghc, you are correct
12:51:42 <Rc43> jfishoff, I want guarantee that special vertex contains only unique values (like Set), and isn't empty.
12:51:47 * cmccann suspects that t7 has a lot of code that only works by happenstance and is likely to break because of layout rules at some point if modified
12:52:10 <mauke> t7: you're not using "let"
12:52:18 <Rc43> And I don't want to include Set into the core of my program (it is huge and contains a lot of functions which I don't need)
12:52:21 <elliott> cmccann: well you _can_ indent everything "uniformly" python style
12:52:26 <joe9> is attoparsec the best haskell parsing library? better than parsec? I am trying to parse a file like this: http://codepad.org/YKWPiZEQ
12:52:29 <elliott> for instance let\n\tfoo=bar\n\tbar=baz
12:52:30 <elliott> and the like
12:52:33 <elliott> it's just really ugly that way :P
12:52:53 <t7> doesnt it take twice as long to line up all the lines exactly to the character?
12:52:53 <cmccann> elliott, assuming that everything starting a new layout block is less than 8 characters wide
12:53:01 <elliott> Rc43: what does it matter if it's huge? just import it, and don't use the parts you don't need
12:53:02 <Philippa> joe9: The parsing libraries are incomparable without a specific set of criteria to check against, (un)fortunately
12:53:08 <elliott> Rc43: chances are your program is already linking to containers anyway
12:53:10 <mauke> t7: no, you can let your editor do that
12:53:23 <mauke> t7: also, you're already doing that
12:53:25 <joe9> i just need a few fields from there: http://codepad.org/jIdRAQdw
12:53:27 <elliott> cmccann: right. i think you can make that always true with certain rules, but urgh
12:53:30 <tazjin> Does anyone know of any realtime collaborative text editor with multi-platform support that has Haskell syntax highlighting and a usable GUI?
12:53:34 <Philippa> also, I'd be surprised if attoparsec makes that file much easier than parsec 3, but I'd be interested if so
12:53:39 <elliott> tazjin: gobby?
12:53:42 <elliott> dunno if it does haskell
12:54:10 <Rc43> elliott, I think it is better to prevent incorrect usage
12:54:10 <joe9> Philippa: ok, so better off sticking with parsec, then. given that I have used it before.
12:54:17 <Philippa> tazjin: I found it not too hard to build my own syntax highlighting definition for Haskell (for jEdit in my case), that might be a suitable route?
12:54:23 <tazjin> elliott: Seems like there is no other choice, gobby is a pain for an interface fetishist like me though ;-)
12:54:27 <cmccann> elliott, right, but I'm guessing that t7 hasn't run into trouble mostly because of not hitting that problem due to how wide tabs are
12:54:28 <ben> :(
12:54:37 <lpsmith> does anybody have a suggestion of what I should call the type constructor: http://hpaste.org/64248
12:54:41 <ben> tazjin: what's so bad about it?
12:54:49 <tazjin> Philippa: Finding a usable collaborative text editor is already hard enough. The good ones (e.g. SubEthaEdit) are usually just built for one platform
12:54:53 <elliott> cmccann: ofc we have evidence that t7 uses tab width < 8, so it's likely they wouldn't even notice if they did ;)
12:55:05 <elliott> Rc43: Incorrect usage howso?
12:55:10 <t7> 4 spaces ftw
12:55:18 <cmccann> tabs are 8 spaces
12:55:26 <hpc> it's in the haskell spec
12:55:29 <cmccann> defined as such in the Haskell report
12:55:35 <t7> not in my world
12:55:41 <hpc> then your world is wrong
12:55:43 <cmccann> your world doesn't include Haskell?
12:55:54 <t7> how can my world be wrong?
12:56:01 <geekosaur> t7, your woeld is not relevant to how haskell comoilers are required to translate source
12:56:03 <elliott> tabs are interpreted as 8 spaces in the haskell report, rather
12:56:23 <elliott> cmccann: hm, does the report really define them as 8 spaces, rather than moving to the next column divisible by 8?
12:56:30 <t7> can you paste an example where using tab to indent will lead to a compilation error?
12:56:30 <cmccann> oh, it might
12:56:33 <geekosaur> otoh you are a good example of why tabs are just a bad idea
12:56:44 <cmccann> but that doesn't matter if you're doing indentation like this
12:56:48 <elliott> t7: it never will, compared to the same file with 8 spaces, but that's not really the point
12:56:55 <mauke> t7: it never will as long as you work in terms of "indent"
12:56:57 <cmccann> t7, don't worry, you'll find out the hard way soon enough
12:57:08 <cmccann> you'll know when because you'll get really confusing error messages
12:57:45 <mauke> t7: my personal coding style is probably similar to yours, i.e. it would work with arbitrary indentation (including hard tabs)
12:57:51 <Philippa> t7: the real examples come when you edit code that already has tabs and aren't as careful as you should be (perhaps because your editor interprets them differently from GHC)
12:57:58 <mauke> the difference is that I know what I'm doing (hah)
12:58:22 <`Jake`> so... you should use 8 spaces and no tabs?
12:58:26 <cmccann> elliott, oh btw, I actually need to run afk again, but fwiw I'm pretty convinced that acid-state is really not a good idea for hackage
12:58:44 <Philippa> `Jake`: however many spaces works for you. I actually align with syntactic elements (plus a single space gap), but styles vary
12:58:49 <hpc> mauke: same; i indent most things 2 spaces, just to keep things easy to type
12:58:52 <nyingen> if you mix tabs and spaces in a .hs file, you get errors on 'let' bindings and whatnot that look perfectly fine
12:58:58 <elliott> cmccann: hmm, why? I've been ignoring it for a while
12:59:00 <mauke> hpc: 4 spaces here :-)
12:59:08 <`Jake`> ok, thanks
12:59:15 <Rc43> elliott, hm, maybe I hurry and incorrect usage can't take place
12:59:19 <Philippa> nyingen: yeah. Last "haskell-like" lang I implemented treats tabs as lexer errors :-)
12:59:19 <elliott> hpc: you realise editors can automate the insertion of N spaces for you? :p
12:59:22 <cmccann> elliott, for a lot of reasons that I've spent entirely too much time complaining about in here already :T
12:59:32 <cmccann> I'll give you the rundown later when I have more time
12:59:35 <elliott> cmccann: ok
12:59:39 <mauke> because I used to code like t7, with variable-width tabs for indentation
12:59:45 <hpc> elliott: i don't like configuring things a whole lot
12:59:46 <magicman> "Tab stops are 8 characters apart." says the report.
12:59:49 <ben> I indent with 2 spaces because I like 80 character terminal windows :(
12:59:49 <cmccann> dunno how much time you might have for working on hackage
13:00:07 <nyingen> ben: me too. I have no intention of ever changing this practice
13:00:09 <geekosaur> the tab = go to next multiple-of-8 column is a unix command line/flat text convention, not generally applicable to other environments, hence inappropriate for a specification not otherwise tied to a unix command line.  as such it might be better if the haskell spec did not specify tab handling.
13:00:09 <cmccann> mauke, I code that way in basically every other language
13:00:14 <hpc> ben: me too, but i like having putty maximized more :P
13:00:22 <Cale> t7: There are even examples of code with mixed tabs and spaces which looks like it should compile and operate one way when viewed with 4 space tabs, but actually does something different (and compiles) with 8 space tabs
13:00:25 <ben> hpc: just put multiple putty windows side by side!
13:00:29 <hpc> (though that comes back into play when i vertical-split)
13:00:30 <cmccann> in fact, I'm about as much a die-hard tab indentation partisan as you'll ever find
13:00:30 <Philippa> geekosaur: it has to specify /something/ for tabs, unfortunately
13:00:32 <cmccann> except in haskell
13:00:37 <Philippa> ("it's an error" is still a spec)
13:00:37 <nyingen> Cale: interesting!
13:00:43 <Cale> t7: Admittedly, you kind of have to try to make that happen.
13:00:59 <hpaste> Franciman pasted “Problem” at http://hpaste.org/64250
13:01:03 <mauke> cmccann: same
13:01:04 <Cale> but it's not too hard if you have nested do-blocks
13:01:06 <nyingen> reminds me of a quote from the changelog from Perl 4 to Perl 5: "Whitespace is no longer allowed as the name of a variable"
13:01:14 <t7> but i dont use spaces
13:01:20 <Philippa> I'm probably dropping offline again in a mo btw, think my train's about to pull in
13:01:22 <geekosaur> Philippa, actually it doesn't.  all it needs to do is note that different environments define tab in different ways, and as such its behavior is not guaranteed
13:01:24 <ben> My biggest issue with variable-width tabs is opening random people's source files and their indentation being all fucked up because it gos 1 tab 6 spaces -> 2 tabs, and then it looks like it's shrinking :(
13:01:31 <Franciman> hey dudes why do I get error at line 13 : http://hpaste.org/64250 ?
13:01:35 <MaybeJust> isomorpism = something that is the same in two different domains? (+) is an isomoprism in matrices and natural numbers?
13:01:42 <Franciman> it just says parse error after =
13:01:44 <Philippa> geekosaur: "nasal demons" :p Still defined-as-undefined
13:01:50 <elliott> Franciman: your alignment is wrong. you're using tabs
13:01:52 <elliott> stop using tabs
13:01:52 <mauke> ben: then they're not using variable-width tabs
13:02:09 <elliott> Franciman: if you're not using tabs (but you almost certainly are), align updatePos's definition with moveBot's
13:02:13 <cmccann> mauke, I've written a few lengthy screeds about proper use of tabs-to-indent, spaces-to-align and that they mean different things and that the code should look correct for any tab width setting an editor uses
13:02:15 <Philippa> though tbh, I think environment-dependent definition's a bad idea. We exchange haskell code across multiple environments as-is
13:02:16 <ben> mauke: yeah, but since i configured them in my editor to be 2 or 4 spaces or whatever, I get confused
13:02:24 <ben> of course it's not a problem for *them*, or they'd have fixed it :D
13:02:28 <t7> anyone got a nice vim script for haskell indent?
13:02:30 <cmccann> mauke, but in Haskell I quickly realized it was better to stop worrying and love the layout
13:02:40 * elliott agrees w/ cmccann
13:02:43 <nyingen> t7: I just use autoindent
13:02:43 <Cale> MaybeJust: An isomorphism is a mapping between two structures which is a witness to the fact that they are "the same" in whatever ways we actually care about in context (there are separate definitions of isomorphisms for each sort of mathematical structure)
13:02:48 <elliott> though I generally just use spaces everywhere these days, because editors are a pain to configure properly
13:03:03 <cmccann> elliott, yeah
13:03:17 <t7> elliot all those extra chars
13:03:24 <t7> stealing my bandwidth
13:03:43 <mauke> write more apl
13:03:50 * cmccann was about to suggest APL as well
13:03:58 <elliott> t7: your identifiers are too long. use one-letter identifiers everywhere
13:04:03 <elliott> much fewer bytes
13:04:09 <Cale> MaybeJust: If there is a definition of homomorphism hanging around, an isomorphism f from A to B is a homomorphism A -> B such that there is a homomorphism g: B -> A, such that f . g = id and g . f = id
13:04:37 <`Jake`> @quote Ascii
13:04:37 <lambdabot> ConorMcBride says: "Sometimes it's easier to search for good programs in the space of well typed programs, rather than in the space of ascii turds."
13:04:40 <joe9> any good attoparsec tutorials, please?
13:04:44 <Franciman> okay thanks very much :D
13:04:47 <`Jake`> wrong quote
13:05:19 <hpc> @quote ascii
13:05:19 <lambdabot> ConorMcBride says: "Sometimes it's easier to search for good programs in the space of well typed programs, rather than in the space of ascii turds."
13:05:35 <elliott> @quote ascii
13:05:35 <lambdabot> ion says: It’s a well-known historical fact cave men writing Haskell hated the ASCII pseudoglyphs.
13:05:40 <qpu> what's an ascii turd?
13:05:53 <Philippa> okay, I'm off. Later!
13:06:15 <nyingen> qpu: anything written in java
13:06:18 <hpc> qpu: it's how you vandalize a unicode snowman
13:06:28 <edwardk> preflex: xseen Philippa
13:06:29 <preflex>  Philippa was last seen on freenode/#haskell 35 seconds ago, saying: okay, I'm off. Later!
13:06:31 <edwardk> hah
13:06:38 <edwardk> oh well, later i guess =)
13:06:48 <qpu> i did see the latest unicode has pile-of-poo character, finally.
13:06:49 <cmccann> unicode snowman is a valid identifier in Haskell, BTW
13:07:01 <cmccann> I'm disappointed people haven't taken more advantage of this
13:07:20 <Cale> MaybeJust: For example, in the category of vector spaces, the homomorphisms are linear transformations, and an isomorphism between two vector spaces V and W is a linear transformation f: V -> W which has an inverse g: W -> V (which is also a linear transformation). Any properties of the vector spaces in question which can be defined in terms of the vector space operations alone will be preserved between V and W.
13:07:24 <edwardk> you can make lots of identifiers using unicode in Haskell: http://hpaste.org/51474
13:07:30 <hpc> @remember cmccann unicode snowman is a valid identifier in Haskell, BTW
13:07:30 <lambdabot> Okay.
13:07:40 <hpc> an FYI for anyone trolling through @quote
13:07:50 <`Jake`> ☃
13:07:53 <cmccann> edwardk, hahaha
13:08:06 <t7> i wonder if you could use the unicode chess peices to encode a chess board state
13:08:10 <qpu> edwardk: nice!
13:08:17 <cmccann> edwardk, I do like how you made judicious use of both letter and symbol characters in that
13:08:22 <edwardk> cmccann =)
13:08:27 <Cale> t7: easily enough, sure :)
13:08:44 <edwardk> i had to swap a couple of symbol choices, but they are hardly noticable
13:08:50 <cmccann> t7, they're operators though
13:08:58 <t7> yeah thats the tough bit
13:08:59 <cmccann> so you'd need to write stuff like (♕) to use them alone
13:09:16 <Cale> Or give them something to operate on...
13:09:21 <cmccann> yeah
13:09:36 <elliott> it sucks that the bottom codepoint is an operator char
13:09:43 <t7> cant you give them prefix or postfix position?
13:09:54 <cmccann> you could probably do something horrific to let them operate on move specifications somehow
13:09:58 <edwardk> just need an unobtrusive char to delimit them with
13:10:00 <Cale> t7: you can write them prefix if you put them in parens
13:10:07 <lpsmith> tazjin, do you think Gobby is any good?  I have used that a very tiny amount, but  never SubEthaEdit
13:10:21 <Cale> Gobby is decent.
13:10:27 <hpc> > let (@) x = x + 5 in 10 @
13:10:28 <lambdabot>   <no location info>: parse error on input `@'
13:10:36 <elliott> subetha is osx only iirc
13:10:37 <hpc> > let (<) x = x + 5 in 10 <
13:10:38 <lambdabot>   <no location info>: parse error (possibly incorrect indentation)
13:10:42 <hpc> :(
13:10:54 <Cale> But there are a lot of low-hanging-fruit sort of features which could be added to Gobby easily and would make it 10 times better.
13:10:55 <`Jake`> This unicode stuff would be so useful if you wanted to write a chess related program
13:11:00 <`Jake`> maybe
13:11:02 <elliott> > let (<) x = x + 5 in (10 <) -- I think this is accepted w/ a GHC extension
13:11:03 <lambdabot>   15
13:11:08 <elliott> > let (<) x = x + 5 in (< 10) -- ditto
13:11:09 <lambdabot>   Overlapping instances for GHC.Show.Show ((t -> t1) -> t1)
13:11:09 <lambdabot>    arising from a...
13:11:12 <elliott> ah
13:11:15 <elliott> it's postfix that requires an extension
13:11:16 <lpsmith> Cale, like?
13:11:41 <elliott> or, hm, no
13:11:42 * cmccann resists the temptation to stuff his abbreviations file full of more unicode aliases to use in his code
13:11:52 <tomodo> I can't write program in haskell
13:11:57 <tomodo> I don't know if  scheme can do it
13:12:00 <tomodo> C can, but I don't want that
13:12:18 <Cale> lpsmith: Like if it had even a basic notion of file paths for open files.
13:12:29 <tazjin> lpsmith: It lacks acceptable support for Mac OS since 0.5, which makes it pretty much unuseable for me. Otherwise, except for the part about it's interface being the typical GTK mess, it's good.
13:12:32 <cmccann> @faq can Haskell do what tomodo needs?
13:12:32 <lambdabot> The answer is: Yes! Haskell can do that.
13:12:39 <edwardk> > let (♖♘♗♕♔♗♘♖) = 1 in (♖♘♗♕♔♗♘♖)
13:12:40 <lambdabot>   1
13:12:40 <qpu> `Jake`: i did that as an undegrad actually, it was nice :]
13:12:54 <edwardk> now to figure out some nearly invisible character to delimit them with
13:12:58 <Cale> lpsmith: (shared between users in some relative way)
13:12:59 <`Jake`> qpu: cool!
13:13:02 <tomodo> alpha beta pruning game AI
13:13:23 <lpsmith> aww, nobody has a naming suggestion for me?  http://hpaste.org/64248
13:13:35 <tomodo> help me :)
13:13:41 <edwardk> lpsmith: naming suggestion for what?
13:13:51 <lpsmith> Ahh, I see.  Well, not really as all I did with Gobby is to give somebody a Haskell lesson once.  :-P
13:13:56 <hpc> lpsmith: not sure what you are asking, but you should name it "George"
13:14:08 <lpsmith> edwardk, the type constructor
13:14:22 <lpsmith> hpc, hah
13:14:27 <Cale> lpsmith: It would be pretty easy when creating a session for each user to be able to pick a default "root for the project" directory, and then whenever you opened a file, its name would be relative to that root, saving people the trouble of navigating through file trees when going to save it on their end.
13:14:29 <sclv> "Oops"
13:14:29 <tazjin> lpsmith: That's what I'm planning to do with a friend, but as it seems we'll have to rely on standard version control and something like etherpad for short snippets that need more explaining.
13:14:34 <czro> I have an unsolved problem that have been buging me for a few days with the preprocessor not working with xcode 4.3 (ghc 7.4.1). Anyone else know about this?
13:14:43 <Cale> lpsmith: Also, some very basic undo would be great
13:15:02 <Cale> lpsmith: even if it was so limited that only the last person to make a change could undo
13:15:10 <sclv> data Errors a = Whoops [SomeException] | Whew !a
13:15:14 <edwardk> sclv: hah
13:15:34 <Cale> (or if people would have to coordinate to undo things)
13:15:38 <edwardk> I rather like the Ok constructor. I often use that one
13:15:54 <Cale> Also, being able to set your view of other people's colours would be good.
13:16:23 <sclv> an actual type constructor name would be, maybe "MultiError"
13:18:17 <lpsmith> edwardk,  as a type constructor,  you mean?
13:18:50 <lpsmith> I was actually using that at one point,  but it didn't quite seem right to me.   But then, neither does "Errors"
13:19:16 <otters> UnthinkableMayhem is pretty good
13:19:45 <edwardk> lpsmith: "Err" ;) done, and it doesn't collide with the stupid 'Error' class
13:20:02 <lpsmith> yeah, I'm not a fan of the error class
13:20:25 <edwardk> i just don't like the fact that the class prevents the usual naming conventions followed by all the other Foo,FooT pairs
13:20:42 <NihilistDandy> I am stunned
13:20:43 <sclv> data Er a = Hmmm [SomeException] | Uh !a
13:20:56 <qpu> Cale: lpsmith: perhaps look at https://github.com/djspiewak/cccp
13:21:30 <lpsmith> I thought about "MayErr",  which is a valid (and suggestive) english verb phrase,  but it seems most type constructors are nouns or noun phrases
13:21:39 <NihilistDandy> My programming languages professor said to me "Haskell doesn't even *have* a specification"...
13:21:55 <hpc> data Lysdexic a = Right [SomeException] | Left a
13:22:11 <hpc> NihilistDandy: oh god
13:22:15 <sclv> NihilistDandy: is yr. pl professor a ML advocate?
13:22:22 <NihilistDandy> sclv: Ocaml
13:22:34 <hpc> my AI prof said haskell has loop syntax
13:22:38 <hpc> but clisp didnt
13:22:48 <sclv> the ml guys do have more specs than we do, so...
13:22:51 <aristid> i thought only SML has the formal specification, not ocaml
13:22:53 <qpu> hpc: what does that mean?
13:22:58 <sclv> right ocaml not so much.
13:23:02 <mauke> OCaml doesn't even have a specification
13:23:05 <NihilistDandy> ^^
13:23:08 <NihilistDandy> That's what I said
13:23:14 <NihilistDandy> Though not in that tone
13:23:17 <hpc> qpu: it means i have no respect for him now :P
13:23:23 <qpu> heh
13:23:36 <aristid> NihilistDandy: make sure not to get into a duel
13:23:38 <NihilistDandy> I remarked that Ocaml had the odd quality of being specified by its implementation rather than the other way around
13:23:45 <hpc> (loop syntax, like while/for)
13:23:57 <statusfailed> hpc: D:
13:24:04 <NihilistDandy> Though I did find one extant formal spec for core Ocaml. It seems a bit ex post facto
13:24:29 <mauke> "core"? does that include modules and the OO system?
13:24:29 <NihilistDandy> aristid: I wouldn't even know where to start. I was dumbfounded
13:24:33 <NihilistDandy> mauke: Nope
13:24:38 <NihilistDandy> Basically just the ML-y parts
13:24:41 <sclv> You can tell him that this is the spec: http://www.paultaylor.eu/stable/Proofs%2BTypes.html
13:24:48 <sclv> It just hasn't all been implemented yet :-)
13:25:16 <NihilistDandy> I just stared at him and said "Haskell 98? Haskell 2010?"
13:25:16 <sclv> also, the ffi + concurrency are an appendix :P
13:25:33 <NihilistDandy> Yeah, I thought about sending him a few PDFs :D
13:26:30 <NihilistDandy> If the Haskell report (+ appendices, errata) doesn't count as a spec, I just don't know what to think. :/
13:30:23 <elliott> sclv: the FFI isn't an appendix
13:30:25 <elliott> since 2010
13:30:33 <elliott> I wasn't aware that concurrency was an official appendix at all though
13:31:27 <sclv> it was a joke w/r/t Proofs & Types as the "spec" for Haskell
13:31:40 <elliott> ah
13:31:44 * cmccann considers that any paper with SPJ's name on it is probably an appendix in all but name
13:31:57 <NihilistDandy> I can't especially decide whether it would be more prudent to point him to 98 or 2010. I suppose they're both set in stone, but 98 is the minimal spec
13:32:07 <Veinor> oh lord
13:32:16 <elliott> NihilistDandy: well 2010 is basically 98+FFI
13:32:25 <Veinor> compiling Language.Haskell.Exts.Annotated.Syntax is making me swap with 1.5GB of ram
13:32:27 <elliott> plus a few tweaks reflecting established practice and one or two tiny extensions
13:32:27 <NihilistDandy> That's fair.
13:32:31 <elliott> so I'd go for 2010
13:32:34 <sclv> Taylor's appendix A even gives a semantics, so it's one up on the reports :-)
13:32:37 <elliott> shows our standardisation efforts are active, too ;)
13:32:40 <rwbarton> haskell 98 is faster to type into google so normally I refer to that one
13:32:48 <elliott> Veinor: haskell-src-exts, right?
13:32:54 <elliott> that's a fun one to compile
13:33:09 <edwardk> elliott: - n+k patterns ;)
13:33:32 <NihilistDandy> I'll normally brush off ML nonsense, but shit. Guy's a PL researcher. It just seems… wrong.
13:33:45 <cmccann> anyway, anyone going on about languages being properly specified who uses ocaml instead of sml is probably full of it :P
13:33:53 <NihilistDandy> lol
13:33:54 <Veinor> elliott: yeah
13:33:55 <edwardk> 2010=98+FFI-(n+k)
13:34:06 <elliott> edwardk: n+k patterns NEVER EXISTED.
13:34:08 <edwardk> oh and hierarchical modules
13:34:10 <elliott> Shhhh.
13:34:11 <statusfailed> Is it possible to pass a function between processes?
13:34:20 <edwardk> but that makes the equation uglier
13:34:23 <elliott> hmm, so 2010 must have removed both n *and* k patterns from the language
13:34:34 <cmccann> elliott, no, it removed either
13:34:38 <edwardk> i just want to solve that in terms of n ;)
13:34:39 <elliott> 2010=98+FFI-(n+k patterns) -> 2010=98+FFI-n-k patterns
13:34:40 <cmccann> both would be n*k of course
13:34:47 <elliott> cmccann: oic
13:35:35 <Cale> statusfailed: Between OS processes? Not easily.
13:36:25 <Cale> statusfailed: You'll need to decide on which functions you want to be able to pass ahead of time, and find a way to represent them.
13:36:32 <statusfailed> Cale: dangit :)
13:37:12 <statusfailed> I'm not even sure I need to do it that way, just curious
13:37:46 <statusfailed> it's probably symptomatic of a bad idea :D
13:37:48 <Cale> statusfailed: There is this Cloud Haskell thing now that I don't know much about
13:38:00 <Cale> and it probably does at least something in that direction
13:38:19 <statusfailed> Cale: oh, I haven't heard of that
13:39:04 <statusfailed> Woah, nice. Thanks for the heads-up!
13:39:43 <Cale> http://hackage.haskell.org/trac/ghc/wiki/ErlangInHaskell
13:40:13 <Veinor> how can i tell ghci to load a .ghci file?
13:40:26 <salty-horse> this talk by Rich Hickey mentions "Haskell ref(erence)s" -- what are they?
13:40:53 <Cale> Veinor: -ghci-script <filename>  I think
13:40:55 <cmccann> what talk?
13:41:15 <Veinor> Cale: I mean within ghci; I don't know how to control the files that haskell-mode's inferior ghci loads
13:41:25 <jfischoff> statusfailed: passing functions around might get more important as Safe Haskell matures
13:41:45 * cmccann thinks being able to serialize functions and unevaluated thunks would be handy
13:41:47 <salty-horse> cmccann, :( -- http://www.infoq.com/presentations/Simple-Made-Easy
13:41:48 <Cale> Veinor: :script filename
13:41:51 <Cale> Veinor: It seems
13:42:21 <salty-horse> specifically, ~00:45 and a bit before
13:42:24 <statusfailed> jfischoff: I'm not at all familiar with the internals of haskell, but I figured that it could be done just by giving functions some kind of ID, and only passing that.
13:42:30 <czro> Is there a way to specify default compiler options for ghc? Looking for a way to replace the preprocessor without having to pass flags all the time.
13:42:30 <Veinor> Cale: not in 7.0 :(
13:42:39 <statusfailed> Which would mean no passing of actual code
13:43:04 <NihilistDandy> Alias ghc?
13:43:21 <Cale> statusfailed: You'd have to package them up with representations of their arguments (which may also be functions)
13:43:22 <NihilistDandy> Actually, there's probably a config file
13:44:24 <Cale> statusfailed: (after doing some global transformations to expose the free variables as parameters)
13:44:29 <czro> didn't think about alias. Should work. Thanks!
13:44:45 <cmccann> salty-horse, blah, don't suppose there's a transcript anywhere
13:44:58 * cmccann hates dealing with video
13:45:26 <salty-horse> cmccann, but you can jump to the point in the video. and sorry, you can't move the slides unless you play the video. infoq sucks that way.
13:45:35 <salty-horse> so you have no idea what could be meant by "haskell references"?
13:45:40 <Cale> statusfailed: The thing is, you can have arbitrarily many new functions which are constructed at runtime (possibly even in response to user input), so you need some way to encode all the ways in which new functions can be constructed.
13:46:45 <cmccann> salty-horse, I can think of several things that could be but I'll have to look at it in context to see which
13:46:48 <Cale> (which is basically lambda lifting and closure conversion)
13:48:59 <cmccann> salty-horse, ah, think I got it
13:49:01 <statusfailed> Cale: Ah. Well I definitely hadn't thought that through :D
13:49:18 <cmccann> salty-horse, he's talking about "ref" in clojure I think?
13:49:22 <salty-horse> yes
13:49:24 <Cale> That already gets done to some extent, but the results of it are usually something which aren't part of the exposed interface to the program in any way
13:49:32 <cmccann> ok, that's basically a TVar
13:49:38 <cmccann> if memory serves me
13:50:12 <NihilistDandy> Oh, wait.
13:50:13 <NihilistDandy> I win
13:50:35 <Cale> The lambda lifting is usually followed up with a bunch of other transformations, and if the messages that get sent out over the network start depending on how optimisations get applied, it makes versioning really brittle.
13:50:57 <NihilistDandy> Page 680 of the Ocaml book says "There are two ways to approach a new language. A first way is to read the language specification to have a global vision. A second is to plunge into the language’s user manual, following the concepts illustrated by the examples. Objective Caml has neither one, which makes a self-taught approach to it relatively difficult."
13:51:02 <NihilistDandy> I died
13:51:03 <cmccann> salty-horse, in other words a mutable reference using STM
13:51:23 <Cale> (and if it prevents optimisations from being applied in the first place, it can really hurt the performance of your programs)
13:51:37 <salty-horse> cmccann, thanks. as I assumed, a bit out of my shallow depth :)
13:52:04 <cmccann> salty-horse, last I heard haskell and clojure are the only languages with a practical and generally usable stm implementation.
13:52:09 <cmccann> hence the relevance
13:53:14 <Cale> salty-horse: I can explain TVars quickly if you want
13:53:28 <cmccann> salty-horse, STM and TVars are actually pretty simple
13:53:36 <cmccann> and worth knowing about
13:54:05 * cmccann recommends taking Cale up on the offer
13:54:25 <NihilistDandy> Go for it. I'd like to hear it, even if salty-horse doesn't
13:54:36 <salty-horse> cmccann, :D
13:54:40 <donri> http://yow.eventer.com/events/1004/talks/1055 IIRC covers STM quite nicely
13:55:08 <Cale> ah, yes, that one does a fairly okay job. It misses out on retry and orElse, but he does mention them :)
13:55:17 <salty-horse> donri, ooh, I missed that one (saw the retrospective talk)
13:55:29 <Cale> (and SPJ is just always entertaining to listen to :)
13:55:43 <cmccann> also http://research.microsoft.com/en-us/um/people/simonpj/papers/stm/#beautiful is a good read
13:55:44 <salty-horse> I had to download both videos and play them in sync :/
13:55:46 <cmccann> and pretty approachable
13:55:56 <Cale> http://research.microsoft.com/en-us/um/people/simonpj/papers/stm/stm.pdf -- I would start from this though :)
13:56:17 <Cale> Or at least, the introductory part of that
13:56:40 <salty-horse> I'll start with the video
13:56:48 <Cale> salty-horse: How much Haskell do you know? Are you familiar with IO?
13:57:10 <Cale> (If you are, then there's not *too* much which needs explaining)
13:57:11 * cmccann suggests just reading anything by SPJ that you can understand, really
13:58:00 <salty-horse> Cale, well, I started reading Real World Haskell and stopped a bit around monads. haven't picked it up yet. so, very basic understanding of monads, I guess.
13:58:33 <Cale> salty-horse: okay, so STM is a monad, like a very much cut-down version of IO
13:58:45 <Cale> salty-horse: It provides (at least) the following:
13:59:00 <Cale> newTVar :: a -> STM (TVar a)
13:59:07 <Cale> readTVar :: TVar a -> STM a
13:59:16 <Cale> writeTVar :: TVar a -> a -> STM ()
13:59:42 <Cale> in addition, there is a function:
13:59:47 <Cale> atomically :: STM a -> IO a
14:00:11 <Cale> which takes an STM action, and executes it *as if atomically* with respect to all the other running threads in the system
14:00:52 <salty-horse> obligatory "why *as if*" question
14:01:02 <Cale> In the present implementation, it does this optimistically -- reads and writes to TVars being recorded into a transaction log, and changes only being committed at the end
14:01:12 <Cale> This lets multiple transactions work in parallel
14:01:49 <Cale> and the global lock only gets taken briefly at the end of each transaction to determine that it didn't conflict with any others
14:01:58 <Cale> and if it did, the transaction is re-run
14:02:44 <salty-horse> how does it determine that, by going over all of the logs and comparing timestamps?
14:03:29 <Cale> By looking at each of the TVars that it read from in the log, and checking that they still have the same values as they did when it read them
14:03:42 <rasfar> there's also http://www.scribd.com/vsedach/d/47429835-Software-Transactional-Memory-introductory-paper which purports to be introductory, although I don't remember...
14:03:46 <cmccann> note that later reads may pull from the log instead
14:03:51 <Cale> yeah
14:03:54 <cmccann> since a transaction can see its own changes
14:05:17 <statusfailed> Can someone explain rank-2 types to me? I don't understand what is meant by "polymorphic arguments" here: http://hackage.haskell.org/trac/haskell-prime/wiki/Rank2Types
14:05:38 <Cale> statusfailed: It means that you're *required* to pass a polymorphic function as a parameter.
14:05:59 <statusfailed> Cale: as opposed to say, an Int -> Int
14:06:03 <cmccann> statusfailed, if a function takes an argument of type (a -> a) you can pass it something like not
14:06:03 <Cale> statusfailed: right
14:06:06 <statusfailed> In what scenario would that be useful?
14:06:18 <cmccann> but if it takes an argument of type (forall a. a -> a) you pretty much have to give it id
14:06:22 <tomodo> hello!
14:06:33 <Cale> salty-horse: anyway, does that kinda make sense?
14:06:57 <cmccann> statusfailed, it can be useful when you need to apply a function to multiple types
14:07:14 <Cale> salty-horse: So we could have something like  incTVar r = do v <- readTVar r; writeTVar r (v + 1)
14:07:24 <statusfailed> cmccann: I think the "const" example makes sense
14:07:45 <salty-horse> Cale, think so..
14:07:47 <statusfailed> but that's from Rank N types
14:08:01 <Cale> salty-horse: and have a program like   do ...; forkIO (atomically (incTVar r)); atomically (incTVar r)
14:08:06 <everythingWorks> __class__
14:08:28 <cmccann> statusfailed, rank N isn't all that different
14:08:31 <Cale> salty-horse: and while one transaction might briefly cause the other to re-run, you wouldn't lose an update :)
14:09:01 <Cale> salty-horse: There are also:
14:09:07 <nand`> https://www.freelancer.com/sellers/ <- Haskell (0) :(
14:09:14 <Cale> retry :: STM a
14:09:16 <Cale> and
14:09:23 <Cale> orElse :: STM a -> STM a -> STM a
14:09:32 <everythingWorks> STM?
14:09:56 <Cale> retry, when executed inside a transaction, will cause the transaction up to that point to be aborted, and be retried when any of the variables it had read changes
14:09:59 <czro> Still no luck getting the preprocessor to work with xcode 4.3. Unable to install the network package etc. Should I file a bug?
14:10:02 <Cale> (any of the TVars)
14:10:45 * cmccann likes the whole "wait until something relevant changes to retry" aspect
14:10:52 <geekosaur> czro, probably.  I would also strongly consider digging up an xcode 4.2 download from connect.apple.com
14:10:55 <salty-horse> Cale, doesn't this "force to re-run" behavior can cause unpredictable runtime?
14:10:58 <cmccann> it's so simple and effective
14:11:14 <salty-horse> sorry about the grammar there :/
14:11:18 <Cale> salty-horse: yes, and you can have long-running transactions which get stomped on continually
14:11:21 <geekosaur> (because it's going to take a while for everyone to catch up with all the changes apple made in xcode 4.3)
14:11:28 <Cale> salty-horse: So it doesn't completely prevent bugs
14:11:34 <cmccann> concurrency in general causes unpredictable stuff :P
14:11:37 <Cale> salty-horse: But it solves a lot of problems
14:11:48 <cmccann> stm is very nice for ensuring that any transaction sees things in a predictable way
14:11:58 <geekosaur> (and their NDAs-out-the-butt policy means nothing can ever be updated ahead of release)
14:12:05 <czro> Probably. annoying...
14:12:14 <salty-horse> Cale, can't two transactions stomp on each other forever?
14:12:23 <Cale> salty-horse: no, one of the two will always complete
14:12:27 <tomodo> my AI program is slow
14:12:30 <Absbeg> Cale: if i have do ...; atomically (fTVar r); atomically (gTVar r); can i be sure that fTVar is executet before gTVar? Guess not
14:12:37 <Cale> salty-horse: and so the system will make some kind of progress
14:13:08 <Cale> Absbeg: yes, you can
14:13:14 <cmccann> salty-horse, a transaction has to commit in order to stomp on other transactions, recall
14:13:21 <Cale> Absbeg: but if you forkIO both of those, then you can't be sure
14:13:45 <Absbeg> Cale: yeah that'S what i meant though...ok
14:13:53 <MaybeJust> what is a category?
14:14:17 <elliott> MaybeJust: everything
14:14:25 <Cale> MaybeJust: The definition is just long enough that you'd be better off reading it on Wikipedia, or I can give you a book
14:14:35 <Cale> http://cale.yi.org/share/S.%20Awodey%20-%20Category%20Theory.pdf
14:14:55 <Cale> ^^ that's a really nice intro
14:15:10 <salty-horse> cmccann, but I thought the conflict check is done at commit time. isn't that when it decides if something stomped on it?
14:15:53 <cmccann> salty-horse, yes, but a conflict requires one transaction to be done
14:15:57 <cmccann> which means the other gets stomped on
14:16:01 <cmccann> but can't return the favor
14:17:22 <Cale> salty-horse: So your system will, under mild assumptions, always make progress in the sense that transactions will be getting completed, but for any individual transaction, you can't say for certain that it will be able to complete without more careful checking.
14:17:33 <cmccann> the closest you could get would be two transactions in separate threads both relying on the other to put a shared resource into a particular state
14:17:34 <jfischoff> statusfailed: rank2Types show up alot in syb. 
14:18:19 <cmccann> any transaction that could succeed if it were the only one running should eventually succeed
14:18:27 <Cale> Has anyone mentioned ST to statusfailed?
14:19:04 <hpaste> Rc43 annotated “dynamic dispatching on type” with “dynamic dispatching on type (annotation)” at http://hpaste.org/64245#a64253
14:19:09 <Cale> I could have a long running transaction which read from many TVars, and lots of short ones which wrote to the TVars which that one read
14:19:27 <Cale> and so long as the short ones kept committing, the long one would never finish
14:19:39 <Cale> (live-lock)
14:20:06 <Cale> We could put in, without changing the STM interface, a system for preventing that though.
14:20:15 <Cale> (it just doesn't exist yet)
14:20:22 <cmccann> yeah, that's sort of a feature of the runtime
14:20:50 <cmccann> the long transaction would still "eventually" succeed if the scheduler gave it the chance
14:20:59 <Cale> yeah
14:21:23 <t7> my boss tried to modify a vb script... i cant even understand the thought process of a non programmer anymore
14:21:27 <cmccann> I mean, if your power goes out in the middle of a transaction it won't succeed either
14:21:35 <cmccann> have to draw a line somewhere :P
14:21:52 <elliott> cmccann: atomically should transfer the transaction to the Cloud to prevent that
14:22:14 <cmccann> oh good idea
14:23:08 <Cale> As a derpy example of something which could be done, you could put a hard limit on the number of times that a transaction could be forced to retry by other threads, and just run it in isolation after it hits that limit.
14:23:14 * cmccann wonders if there's a viable way to extend STM semantics to distributed transactions spanning multiple processes or machines
14:23:26 <Cale> There are certainly much better strategies though.
14:23:39 <cmccann> Cale, or an exponential back-off that gives the same thing in the limit, or any number of other approaches
14:23:44 <Cale> yeah
14:23:56 <NihilistDandy> @tell czro Re Xcode 4.3, did you download the Command Line Tools component from Xcode? Moving to 4.3 wipes /Developer which kills all the symlinks until you grab the component. I dunno if that's the issue, but it's worth a shot.
14:23:56 <lambdabot> Consider it noted.
14:24:24 <Cale> You could keep track of which threads in the system were causing the transaction to be retried and stop just those ones.
14:24:33 <slack1256> the lambda calculus uses only lambda term for function (kind of anonymous functions) but haskell uses system Fc
14:24:33 <cmccann> yeah
14:24:46 <slack1256> named functions are syntactic sugar or are incorporated in system Fc
14:24:50 <cmccann> Cale, particularly since that information should be easy to capture as part of the commit validation
14:25:19 <MaybeJust>  This makes category theory unusually self-referential and capable of treating many of the same questions that mathematical logic treats. In particular, it provides a language that unifies many concepts in different parts of math.
14:25:39 <MaybeJust> but ig uess Gödel stabbed down that "eliminate all self-reference"-mision anyway
14:25:43 <salty-horse> cmccann, *, thanks for the explanations! (I was distracted by a question in another channel)
14:26:04 <cmccann> eh, thank Cale, he did most of the explaining :P
14:26:41 <Cale> MaybeJust: uh, I would say that the sort of self-reference which that is referring to is mostly unrelated to Gdel's sort :)
14:27:24 <cmccann> I'd think that Gödel's sort of self-reference is also the kind that's unrelated to Gödel's sort of self-reference
14:27:28 <Cale> MaybeJust: but there are a few foundational considerations to be made in setting up CT in such a way that you can have a category of all small categories and such.
14:27:45 <Cale> cmccann: haha
14:27:49 <plat0> What do you have to add to applicative to get a monad?
14:27:59 <cmccann> :t join
14:27:59 <Cale> plat0: join will do
14:27:59 <lambdabot> forall (m :: * -> *) a. (Monad m) => m (m a) -> m a
14:28:17 <plat0> Is there anything "less"?
14:28:21 <cmccann> no
14:28:33 <t7> i dont think i could really grok spj if i knew no haskell at all
14:28:34 <elliott> less howso
14:28:38 <plat0> I mean, can join be derived from applicative + something less powerful than join
14:28:40 <Cale> plat0: You'll notice that in all the Applicative operations, the number of occurrences of m in the type of the arguments is never less than the number of occurrences of m in the result
14:28:46 <t7> i wonder if people know what hes talking about
14:29:07 <Cale> plat0: You need at least some operation which allows for a reduction in the number of occurrences of m.
14:29:09 <cmccann> plat0, no, join is the minimum required
14:29:16 <plat0> is there a proof of that?
14:29:20 <cmccann> or something equivalent to it
14:29:38 <cmccann> note that e.g. (>>=) is a combination of join and fmap
14:29:46 <Cale> plat0: Well, whatever you choose, you'd better be able to derive join from it...
14:29:47 <NihilistDandy> t7: SPJ `elem` people
14:30:00 <Cale> plat0: So, it calls into question what you mean by 'less powerful than'
14:30:09 <plat0> Cale: sure from it *and* the applicative operations
14:30:09 <t7> people is my macro for 'the people in the audience '
14:30:22 <NihilistDandy> Doesn't sound very hygienic
14:30:24 <cmccann> plat0, note that the mathematical definition of a monad is basically fmap, return, and join
14:30:31 <elliott> plat0: Monad is also return + (>>=)
14:30:32 <plat0> cmccann: yup
14:30:36 <elliott> from which you can derive (<*>) and fmap
14:30:38 <elliott> and join
14:30:48 <elliott> but that doesn't break into pieces as well as fmap + pure + (<*>) + join
14:30:53 <plat0> indeed
14:31:04 <cmccann> yeah, (>>=) is a composite operation that happens to be convenient for how we use monads in Haskell
14:31:04 <elliott> plat0: if you want a formal proof you'll need a formal definition of "less powerful", anyway
14:31:37 * cmccann thinks plat0 wants some notion of orthogonality mostly
14:32:12 <plat0> ok so is there some operation f on applicatives such that f + fmap + pure + <*> => join but f + fmap /=> join
14:32:15 <plat0> for example
14:32:52 <Cale> >>= is more closely related to Kleisli triples than monads directly, but they are the same thing in the end anyhow :)
14:34:36 <MaybeJust> > Cale == Steve Awodey
14:34:37 <lambdabot>   Not in scope: data constructor `Cale'Not in scope: data constructor `Steve'...
14:34:39 <Cale> A Kleisli triple on a category C consists of a function  T: ob(C) -> ob(C), for each object A in C, an arrow eta_A: A -> T(A), and for each arrow f: A -> T(B) in C, an arrow f*: T(A) -> T(B), satisfying some laws
14:35:03 <Cale> Which is basically exactly the return/bind definition of a monad :)
14:35:14 <Cale> with the parameters to bind swapped :)
14:36:06 <Cale> The laws are:  (eta_X)* = id_(TX),  f* . eta_X = f, and (g* . f)* = g* . f*
14:38:50 <MaybeJust> Cale: are you Steve Awodey?
14:38:54 <Cale> MaybeJust: no
14:39:17 <MaybeJust> what are you, Math/Software/Haskell PhD?
14:39:26 <Cale> I only have a BMath
14:39:54 <Cale> I'm working for a startup using Haskell to make an RPG for iPhones and (eventually) other mobile devices
14:40:34 <tromp__> using haskell for the non-performance-critical parts only?
14:41:12 <Cale> tromp__: There's a little bit of C++ code running underneath
14:41:24 <Cale> tromp__: but it's mostly Haskell
14:41:41 <bill```> Cale: ipwn?
14:41:44 <Cale> bill```: yes
14:41:51 <bill```> (was just reading "haskell in industry" page ;))
14:41:54 <Cale> :)
14:42:02 <bill```> sounds cool
14:43:01 <MaybeJust> Cale: you went to carnegie mellon?
14:43:07 <tromp__> are graphics 2d or 3d?
14:43:07 <Cale> I went to Waterloo
14:43:12 <Cale> tromp__: 3D
14:43:25 <Cale> (OpenGL ES)
14:43:49 <tromp__> I think you went to Waterloo after me
14:44:03 <tromp__> i did postdoc there in 94/95
14:44:10 <Cale> Ah, yeah, I started in 2001
14:44:25 <Axman6> Cale's a youngen
14:44:31 <Cale> (which was also about the time I started programming in Haskell)
14:44:56 <tromp__> i was still dabbling with Java in 2001, hadnt heard of haskell
14:46:16 <MaybeJust> why did you chose haskell?
14:46:33 * cmccann didn't even start learning Haskell until 2009 :[
14:46:36 <cmccann> it's hard to catch up
14:46:46 <elliott> cmccann started haskell later than me? weird
14:47:01 <stepcut> is this instance valid, instance (Monad m) => Monoid (m ()) where
14:47:01 <stepcut>     mempty        = return ()
14:47:01 <stepcut>     m `mappend` n = m >> n
14:47:13 <cmccann> elliott, hm?
14:47:22 <Cale> An acquaintance of mine mentioned Haskore when I mentioned an interest in mathematical foundations for music theory
14:47:31 <elliott> stepcut: sure, although you don't want to actually define it
14:47:31 <Cale> and I checked it out, and got hooked on Haskell :)
14:47:35 <elliott> cmccann: I started 2007-2008
14:47:49 <mux> it's been more than 24 hours now and hackage still didn't run the test build/haddock generation; is something broken again maybe?
14:47:57 * Pseudonym started with Orwell in 1992
14:48:07 <Pseudonym> Oooh, 20th anniversary.
14:48:11 * Pseudonym just realised
14:48:16 <Cale> stepcut: yes
14:48:33 <Pseudonym> 20 years this month, in fact.
14:48:40 <elliott> Man, 1992 was 20 years ago.
14:48:49 <elliott> 201x is weird.
14:48:56 <Pseudonym> I know!
14:49:02 <Cale> stepcut: apart from the fact that it might not be so nice to have in scope in practice, because it will aggressively overlap with things
14:49:06 <Pseudonym> Actually, Portlandia just started showing on Australian TV last night.
14:49:11 <Pseudonym> So I'm having 90s nostalgia.
14:49:16 <cmccann> elliott, no, why's it weird that I started later? I've always said I'm pretty new at all this :P
14:49:18 <Cale> Portlandia is hilarious
14:49:25 <Cale> One of my favourite shows right now :)
14:49:27 <MaybeJust> Cale: I meant why Haskell for an Iphone game?
14:49:42 <stepcut> Cale: yeah.. overlap is annoying. I could just do (IO ()) in this case
14:49:48 <Pseudonym> Yeah, we're just getting the first season now. Presumably they'll follow it with the second straight away.
14:49:57 <jfischoff> MaybeJust: Cale: because he's lucky :)
14:49:59 <elliott> cmccann: dunno, it's just weird to see people I consider as highly knowledgable having started later than me :P
14:50:13 <Cale> MaybeJust: oh, because Haskell is awesome and we want to build up some infrastructure for writing games in it because we think there are a lot of potential advantages to an FRP game engine in a language with powerful types.
14:50:35 <plat0> how do you deploy haskell programs to the iphone/
14:50:45 <MostAwesomeDude> You don't, AFAIK.
14:50:49 <Pseudonym> plat0: According to Apple, you don't.
14:50:58 <plat0> And according to Cale ...
14:51:03 <Cale> Hey guys, that rule went away a long time ago
14:51:07 <elliott> MostAwesomeDude: sure you do
14:51:09 <Pseudonym> Really?
14:51:13 <jfischoff> yes
14:51:14 <cmccann> elliott, ah, well. that's sort of flattering I guess, heh.
14:51:16 <Cale> and it was never enforced except in the case of Adobe
14:51:21 <elliott> if you're iPwn, you don't, though ;)
14:51:24 * Pseudonym still uses Symbian, where there never were any such rules
14:51:26 * elliott will show himself out.
14:51:49 <MostAwesomeDude> Whatever. I don't really enjoy white'n'shiny, so I don't keep up to date on development for it.
14:52:35 <cmccann> elliott, maybe it just seemed like I've been around longer because I started answering stuff on Stack Overflow pretty much as soon as I started getting the hang of it at all :P
14:52:43 <Cale> The subtext of that rule was: we don't want to allow Flash, but we also don't want to put "No flash allowed, fuck you Adobe" in our licensing agreement.
14:53:12 <cmccann> Cale, for very loud definitions of subtext...
14:53:17 <elliott> a rare case of Apple trying for subtlety :P
14:53:27 <Cale> So they kept it around just long enough for Adobe to drop their Flash iPhone project and then dropped it.
14:53:30 <elliott> I guess "No Flash allowed" would have legal problems.
14:53:37 <Pseudonym> To be fair, Flash + multitouch is a difficult combination.
14:53:51 <elliott> Flash + * is a difficult combination
14:54:10 <MostAwesomeDude> If only we had a working open-source Flash player. :c
14:54:23 <bgamari> How does one get cabal to compile an executable with useful profiling (e.g. -auto-all -caf-all)
14:54:34 <cmccann> bgamari, can always pass options directly to GHC
14:54:48 <cmccann> with --ghc-options or whatever it is
14:54:48 <dcoutts> bgamari: cabal build --ghc-options=
14:54:51 <bgamari> Ahh
14:54:55 <bgamari> gracias
14:55:21 <cmccann> I was going to say there might be a better way I guess not since dcoutts would know :P
14:55:48 <dcoutts> cmccann: it's on the long Cabal TODO list :-)
14:55:53 <bgamari> cmccann: The problem being it doesn't compile with ghc directly due to overlapping module names
14:56:06 * cmccann nods
14:56:08 <bgamari> cmccann: Ahh, I see; your suggestion == dcoutts suggestion
14:56:30 <dcoutts> bgamari: btw, also configure with --enable-executable-profiling
14:56:44 <bgamari> dcoutts: Yep, but this doesn't seem to include -auto-all -caf-all
14:56:53 <bgamari> dcoutts: Judging from the resulting profile
14:57:01 <dcoutts> right, but it builds with profiling and links against prof libs
14:57:21 <elliott> oh, you're meant to have to do that with --ghc-options?
14:57:25 <dcoutts> -auto-all -caf-all etc are particular things you might want
14:57:27 <elliott> I assumed I was just misusing --enable-executable-profiling
14:57:56 <MaybeJust> FRP?
14:58:00 <dcoutts> but they're not included in --enable-executable-profiling since you wouldn't be able to turn them off
14:58:09 <bgamari> dcoutts: fair enough
14:58:12 <dcoutts> and we havn't worked out a UI for more precise control, hence --ghc-options
14:58:32 * cmccann notes that -auto-all -caf-all can produce a lot of noise
14:58:46 <bgamari> given these are fairly compiler specific, I'm not sure it's a problem
14:59:14 <dcoutts> bgamari: yeah, that's part of the issue, we'd like to be able to say something not quite so compiler-specific
14:59:30 <Cale> MaybeJust: Functional reactive programming
15:00:20 <dcoutts> bgamari: more abstractly, it's something like "profile this component/lib/module: everything/just-things-marked"
15:01:13 <Cale> MaybeJust: Functional reactive programming is a loose collection of styles of libraries which basically serve to do incremental computation (keeping track of state updates for you)
15:01:23 <dcoutts> bgamari: and/or we change ghc and the prof tools to filter afterwards, so that the selectively adding CCSs would be just a performance thing
15:02:01 <dcoutts> that'd certainly make the UI easier most of the time
15:02:09 <dcoutts> and not have to recompile packages so much
15:03:03 <Cale> MaybeJust: There are two main concepts involved. There is the kind of state which changes "continuously" (or at least, perhaps more frequently than you examine it), and such bits of state are referred to as "behaviours". Things like the position of the mouse, what is to be displayed on the screen, (and at least conceptually) the current time of day, fall into that category.
15:03:12 * bgamari wishes profiling didn't have such a massive performance hit?
15:03:29 <bgamari> yes, he does
15:03:33 <Cale> There is also the kind of state which doesn't always have a value, but consists of discrete occurrences paired with a value
15:03:45 <Cale> which are called "events"
15:03:46 <elliott> cmccann: oh btw what was it about acid-state and hackage?
15:04:03 <cmccann> elliott, ah yeah
15:04:19 <cmccann> basically I got fed up with acid-state's incredibly monolithic approach
15:04:30 <elliott> you mean having to predeclare transactions?
15:04:38 <Cale> (things like mouse clicks or taps on a touchscreen, attacks by AI characters, sounds to be played on output fall into that regime)
15:04:39 <cmccann> there seems to be no way to avoid loading everything into memory up-front as one gigantic data structure with pre-defined operations
15:04:56 <stepcut> cmccann: yes, that would be the point of it.
15:04:58 <elliott> well, the predefined transactions thing is inherent to how it works and gives it the advantages it has... but it's ugly yes
15:05:01 <cmccann> you can't do things on demand or have separate chunks of data without losing any sort of ACID guarantees on operations using both
15:05:15 <Cale> MaybeJust: An FRP library will provide representations of some form for behaviours and events and various ways to express how they are connected with one another
15:06:32 <cmccann> elliott, it's incredibly anti-modular in that if you have two types A and B persisted using acid-state there's not really any good way that I can see to define an operation on (A, B) that preserves consistency between them
15:06:38 <stepcut> cmccann: you mean, ACID guarantess across multiple AcidState components ?
15:06:42 <cmccann> yes
15:07:04 <cmccann> I mean, maybe there is a way to do that
15:07:15 <Cale> So that you can do things like accumulate all the incoming attack events made on some character in order to produce a behaviour representing that character's current hitpoints.
15:07:15 <cmccann> and maybe I'm misusing it or whatever
15:07:20 <stepcut> no there is not. ACID guarantees like that are sure performance killers
15:07:21 <cmccann> but it just doesn't seem very flexible in multiple ways
15:08:07 <elliott> cmccann: hmm, I'm not sure when Hackage would require "cross-store" ACID guarantees like that
15:08:40 <cmccann> between users and packages, say?
15:08:41 <Cale> (which makes it difficult to screw up and forget to do an update of that piece of state, or to update something which the current HP affects)
15:08:43 <elliott> cmccann: I mean an AcidState is like an SQL server or whatever, so ACID between the two is kind of impossible :P
15:08:45 <plat0> Apart from Ziplist, is there any easy example of an applicative that's not a monad?
15:08:56 <elliott> cmccann: when would we need strong ACID guarantees between users and packages?
15:09:01 <Cale> MaybeJust: does all that make some kind of sense? :)
15:10:06 <cmccann> elliott, well, hackage really doesn't require that many guarantees at all, it's the fact that it's not even possible that makes me very unenthused about acid-state
15:10:18 <dcoutts> cmccann, elliott: I worried about that too at first, but decide that if two hackage features are really separable then they should't need atomic transactions across their data stores
15:10:31 <stepcut> cmccann: if you want that guarantee, then put everything in a single acid-state
15:10:44 <cmccann> and between that and the horrific start-up time making it painful to do development with a full index it just seems like acid-state is causing me more grief than it's preventing
15:10:52 <elliott> dcoutts: IME two components of the same system are never fully separable :P
15:11:08 <dcoutts> elliott: the test is if you can turn the feature off
15:11:43 <elliott> stepcut: that's impossible
15:11:44 * stepcut wonders why the startup time is so long.. that sounds like a bug
15:11:47 <elliott> since hackage has dynamic components
15:11:54 <elliott> so listing all types of transaction for the whole app is impossible
15:11:56 <dcoutts> cmccann: perhaps we should look at what is so slow in the deserialisation then
15:11:58 <cmccann> stepcut, the amount of data
15:12:16 <latros> any particularly category theory-y people around?
15:12:21 <elliott> cmccann: it's less than a few gigs on disk, isn't it?
15:12:32 <elliott> so there should be no problem deserialising it quickly, in theory
15:12:41 <cmccann> well, the raw tarball is a few megabytes
15:12:50 <cmccann> compressed, of course
15:12:53 <dcoutts> cmccann: in memory you mean, it should not be that slow to load ~500Mb from disk into memory and deserialise, unless it's swapping
15:12:55 <stepcut> elliott: sure. But, optional components probably should not need those types of strong guarantees anyway since the component may not even be there ?
15:13:25 <latros> I'm wondering if someone can give me an example of two functors in Hask and a natural transformation between them
15:13:38 <cmccann> dcoutts, well, it's much much worse if it needs to swap
15:13:44 <elliott> stepcut: right
15:13:56 <dcoutts> cmccann: sure, if we have to swap we've lost
15:14:18 <cmccann> stepcut, I don't think it's unreasonable to expect that two pieces of data should be mutually consistent when both are present
15:14:24 <cmccann> even if neither is required
15:14:26 <stepcut> latros: Either () a <-> Maybe a, toEither Nothing = (Left ()) ; toEither (Just a) = Right a; toMaybe (Left ()) = Nothing ; toMaybe (Right a) = Just a
15:14:31 <DanBurton> @undo do x <- foo; return $! x
15:14:31 <lambdabot> foo >>= \ x -> return $! x
15:14:32 <stepcut> latros: something like that maybe?
15:14:41 <DanBurton> @pl foo >>= \x -> return $! x
15:14:41 <lambdabot> (return $!) =<< foo
15:14:56 <DanBurton> Is there such a thing as strict fmap?
15:15:00 <cmccann> stepcut, it also makes it painful to refactor the data representation if something would cross a barrier between two acid-state components
15:15:23 <ion> @hoogle (<$!>)
15:15:23 <lambdabot> No results found
15:15:26 <latros> that's an isomorphism
15:15:33 <latros> which is stronger than I wanted
15:15:43 <stepcut> cmccann: I'm not convinced that cross Acid-State ACID guarantees are the right thing
15:15:50 <latros> it IS natural, however, so *technically* you answered my question
15:15:51 <DanBurton> is it possible to define <$!> in terms of only fmap?
15:15:52 <ion> cmccann: (<$!>) in Overture? :-)
15:15:59 <stepcut> latros: oh right
15:16:02 <hpc> DanBurton: fmap' f x = x `seq` fmap f x
15:16:18 <dcoutts> cmccann: btw, I realised we can establish sharing within a package index using the type's deserialisation, we just have to define a custom serialise instance
15:16:18 <Enigmagic> stepcut: i'm not convinced a service is the right thing
15:16:22 <cmccann> ion, hm, could be, though I'm not sure if it'd be all that useful...
15:16:23 <stepcut> cmccann: considering how many large sites (amazon, facebook, etc) don't even turn transactions on..
15:16:48 <cmccann> stepcut, well, why do we need acid-state at all, then?
15:16:57 <cmccann> just read from disk, write it out, who cares :P
15:17:14 <ion> cmccann: I guess so. I personally have yet to need it. It just seems to come up in #haskell every once in a while.
15:17:20 <dcoutts> cmccann: it matches the semantics of HTTP pretty nicely
15:17:34 <cmccann> but I'm pretty sure I wouldn't want to use acid-state for any sort of non-trivial web application, honestly
15:17:39 <elliott> why not separate the storage server and expose its interface via HTTP?
15:17:46 <dcoutts> cmccann: the way we expose resources means clients cannot do transactions on multiple state components anyway
15:17:47 <elliott> and write the "front end" separately
15:18:01 <dcoutts> elliott: what would that buy us?
15:18:02 <elliott> if HTTP-closeness is desirable
15:18:16 <elliott> dcoutts: well, it's even closer to HTTP :P
15:18:16 <stepcut> cmccann: I use it for all my web applications
15:18:21 <stepcut> gotta run
15:18:40 <dcoutts> elliott: sorry, I've missed the point you're making
15:19:32 <elliott> dcoutts: I'm not sure -- but if matching the semantics of HTTP is desirable, then using HTTP directly would seem to be reasonable, and let us swap out the actual backend arbitrarily
15:19:39 <elliott> OTOH, I'm not convinced that is desirable, or at least can't see why
15:20:00 <elliott> hpc: isn't fmap (f $!) x more desirable?
15:20:08 <Enigmagic> elliott: you mean.... serving it off of disk with no haskell involved?
15:20:12 <dcoutts> elliott: we are using http directly, it's just the code is in the same server.
15:20:14 <dcoutts> the package tarball storage and serving part is not memory-intensive
15:20:17 <patzo> CRipley@spi-ind.com
15:20:18 <elliott> Enigmagic: huh?
15:20:43 <elliott> ok, either I misinterpreted what dcoutts meant, or everybody is misinterpreting me :P
15:20:54 <dcoutts> I think we're all confused :-)
15:21:35 <Enigmagic> elliott: what would separation look like?
15:21:40 <elliott> cmccann: anyway I really wouldn't like to see hackage2 doing manual file IO everywhere
15:22:09 <dcoutts> elliott: right, that's what the old cgi scripts do and it's pretty horrible
15:22:26 <elliott> Enigmagic: well, the statement is that acid-state is close to HTTP semantics, and this is desirable; if that's true, then having the "database" be an HTTP server would match even closer, and not tie the code to a backend
15:22:31 <elliott> but I was mostly joking, in that I don't really see the benefit
15:22:41 <cmccann> sorry, had to run AFK for a moment
15:22:42 <elliott> (of closeness to HTTP)
15:23:06 <cmccann> elliott, and no, I wouldn't want that either
15:23:50 <dcoutts> in particular, since the cgi scripts do lots of file IO, it's really not clear what the behaviour is with multiple concurrent updates
15:23:58 <Enigmagic> elliott: i mostly don't see a benefit from serving the static content via a haskell service
15:24:03 <dcoutts> where as with acid-state it's fairly clear
15:24:14 <elliott> Enigmagic: I'm not talking about static content at all... I fear you're lacking the context here
15:24:20 <dcoutts> Enigmagic: sure but we're mostly not serving static content
15:24:41 <dcoutts> Enigmagic: we can certainly have passive package archives with "dumb" http file servers
15:24:43 <elliott> cmccann: anyway perhaps what has to be done is to _weaken_ our guarantees
15:24:53 <elliott> cmccann: i.e. use an AcidState for everything that would be a single file
15:25:00 <elliott> for instance, an AcidState per package, or such
15:25:11 <Enigmagic> dcoutts: ok, so what is dynamic and why is it dynamic?
15:25:15 <elliott> which lets us be more incremental about what we load, and gives us concurrency guarantees that file IO wouldn't
15:25:59 <cmccann> elliott, yeah, I'm still considering that
15:26:06 <elliott> cmccann: i.e. our main problems with AcidState seem to be that we're doing everything too monolithically
15:26:14 <elliott> which gives us more guarantees, but ones we don't need, and has a high cost
15:26:17 <dcoutts> Enigmagic: there's several sets of pages that are very large, better generated on demand rather than stored/pre-calculated
15:26:26 <Enigmagic> dcoutts: like which?
15:26:27 <dcoutts> Enigmagic: for example the reverse dependencies
15:26:33 <cmccann> elliott, and my main gripe with acid-state is that it seems to require monolithic use to get its benefits
15:26:38 <elliott> cmccann: acid-state is perfectly passable as a fast concurrency-friendly interface to some serialised data, so I don't see the need to replace it at that layer
15:26:41 <Enigmagic> dcoutts: would it be ok to generate them once a day?
15:26:47 <elliott> cmccann: sure, but just pretend it's not called acid-state ;)
15:26:52 <elliott> cmccann: anyway atomicity is useful at a local level
15:27:00 <elliott> i.e. you don't want the same package to be written to simultaneously or whatever
15:27:06 <dcoutts> Enigmagic: we didn't want an architecture that limits the kind of features we can add so much
15:27:13 <elliott> even if you're not using a monolithic state
15:27:13 <dcoutts> Enigmagic: people want voting and commenting on packages
15:27:34 <Enigmagic> dcoutts: and that means the descriptions and other information needs to be served dynamically?
15:27:59 <cmccann> elliott, the main concern there is that we'd be making it harder to ensure any consistency between stuff down the line
15:28:02 <dcoutts> Enigmagic: plus updates like build results, uploading "tentative" packages and seeing build results + haddocks generated
15:28:45 <elliott> cmccann: well consistency isn't really a big deal for hackage
15:28:50 <dcoutts> Enigmagic: rather than having a fully push model where we cache all the final html it seems more sensible and flexible to take a more traditional approach of storing the canonical data + some caches
15:28:56 <elliott> I don't see why we'd never need it
15:29:16 <Enigmagic> dcoutts: so everyone needs to see the build results in real time?
15:29:20 <cmccann> yeah, for hackage it's not incredibly major, at least as it is now
15:29:36 <hpaste> DanBurton pasted “Strict fmap challenge” at http://hpaste.org/64255
15:29:38 <cmccann> but that's still justifying acid-state on the basis of "well it's not that bad"
15:29:40 <dcoutts> Enigmagic: the most obvious one is seeing comments in real time
15:29:43 <elliott> cmccann: and anything offering really strong cross-dataset consistency will have big overhead
15:30:03 <Enigmagic> dcoutts: my blog is served statically but the comments are real-time from a 3rd party service
15:30:06 <Enigmagic> seems to work ok
15:30:22 <elliott> Enigmagic: that locks out non-JS users
15:30:23 <cmccann> and once we're in the territory of "not that bad" I'm starting to wonder why we're not just using a standard database of some sort
15:30:25 <elliott> cmccann: well, even if we split everything up into individual serialised components, we need something that can read in objects, write them out, and ensure two simultaneous requests don't mess things up
15:30:28 <dcoutts> Enigmagic: sure, so it's not that it's impossible, it just imposes a lot of constraints on the internal design
15:30:37 <Enigmagic> elliott: no it doesn't
15:30:38 <cmccann> since those are going to perform better at the cost of being kinda horrible conceptually
15:30:44 <elliott> cmccann: serialising a Package object or whatever via SQL would surely be more painful than using acid-state, at that individual level
15:30:45 <Enigmagic> iframe/objects that pull from 3rd party sites
15:30:46 <dcoutts> Enigmagic: and a major part of the point of the new server was to make it easier to add new features everyone wants
15:30:56 <elliott> Enigmagic: oh great, iframes
15:31:06 <elliott> finally we can transport hackage back to the 90s :)
15:31:21 <Enigmagic> elliott: objects (not iframes) are part of html 4/5 and do the same thing
15:31:40 <dcoutts> Enigmagic: I also use a static blog generator, it's perfectly fine for well-defined problems like that
15:31:44 <cmccann> elliott, serializing anything to SQL is pretty horrible but at least it's a very well-understood horrible
15:31:49 <dcoutts> I just don't think it's appropriate here
15:32:07 <elliott> Enigmagic: i never said html4/5
15:32:11 <elliott> iframes are horrible from a user perspective
15:32:16 <elliott> speaking as a user.
15:32:27 <elliott> cmccann: sure, but you really think SQL will have lower memory overhead or whatever?
15:32:33 <elliott> tweaking an SQL server would be horrible
15:32:41 <cmccann> no, but at least it could be moved to another server, if desired
15:32:47 <Enigmagic> elliott: well i'm just saying there are other options than serving it up 100% dynamically
15:32:53 <Enigmagic> and having to monitor another service, etc
15:32:58 <cmccann> rather than acid-state's "remote" loading which just loads everything into memory a bit slower than it does from disk :P
15:32:58 <elliott> cmccann: well the only reason that would have to be done is memory
15:33:03 <elliott> which is only a problem on *developer* machines
15:33:09 <dcoutts> cmccann: we could do the same here if we really wanted to, a component could use a data store that wasn't acid-state but it then has to only allow getting one result at a time rather than offering a convenient pure interface like data.map
15:33:21 <dcoutts> cmccann: e.g. the tarball serving is done via the blob store
15:33:55 <dcoutts> cmccann: the reason we have the package index using acid-state is that sometimes we need to be able to traverse the whole thing
15:34:08 <dcoutts> if that can always be avoided then an on disk store is ok
15:35:08 <dcoutts> cmccann: btw, I've got a nearly-completed refactoring that'll make each component own it's acid-state component more directly and other components will only access it via the owning feature's interface
15:35:37 <dcoutts> cmccann: apart from being more sane, that potentially allows experimenting with using other data stores for particular features
15:35:44 <cmccann> anyway, obviously there are ways to mitigate the problems, I'm just not sure I see why acid-state is even a net benefit
15:35:48 <cmccann> oh, nice
15:35:50 <dcoutts> but it's not obvious it's easy for the package index
15:36:00 <cmccann> when do you think your changes will be ready?
15:36:23 <dcoutts> not too sure, I've been quite busy with paying work (deadlines)
15:36:28 <cmccann> I tried refactoring some stuff but kept finding awkward interdependencies that made it tricky
15:36:36 <dcoutts> cmccann: right
15:36:47 <dcoutts> that's what I was trying to address
15:36:54 <elliott> cmccann: how did the data type stuff go?
15:36:56 <cmccann> well, I ask because I'd like to hold off making any larger changes until you're done
15:37:13 <cmccann> elliott, what, replacing String with Text and all that?
15:37:21 <davean> how much memory are we talking for acid-state?
15:37:34 <dcoutts> cmccann: aye, I understand
15:37:55 <dcoutts> davean: it's not acid-state that's taking the memory, it's what we're storing in it
15:38:09 <davean> dcoutts: I mean "in acid-state"
15:38:14 <cmccann> it's acid-state only insofar as it requires it all in memory
15:38:18 <Enigmagic> dcoutts: do you happen to have a breakdown of what browsers hit hackage?
15:38:28 <elliott> cmccann: right
15:38:28 <cmccann> and it's using about 1.6GB on my EC2 instance
15:38:49 <davean> oh, that is nothing
15:39:03 <cmccann> davean, yes, and obviously hackage isn't getting any bigger :P
15:39:04 <dcoutts> Enigmagic: no sorry, I don't have direct access to the httpd logs on hackage.h.o
15:39:17 <cmccann> elliott, the heap profile shows a mostly-even mixture of constructors last time I tried
15:39:37 <davean> cmccann: not fast enough to care ATM
15:39:40 <Enigmagic> dcoutts: no problem, just kinda curious about javascript support/etc
15:39:41 <cmccann> the majority being something in all caps that I think is array storage
15:39:56 <dcoutts> davean: that's rather my view, but not everyone agrees with me :-)
15:40:20 <dcoutts> davean: it's taking 3.2G on the VM we're using as the public test server (which has 8Gb available)
15:40:23 <cmccann> davean, it's also kind of ridiculous that it needs that much memory to load something that's like 10MB on disk :P
15:40:34 <davean> cmccann: yes
15:41:06 <MostAwesomeDude> Hey, has there been any work on kernel-level Haskell since House?
15:41:09 <dcoutts> cmccann: it's not 10Mb it's 55Mb, but yes
15:41:51 <cmccann> yeah, couldn't recall exactly
15:42:06 <dcoutts> cmccann: the 00-index.tar.gz compresses really well
15:42:09 <lpsmith> Well,  one of my cabal problems is that the index00.tar.gz file is now big and getting bigger every day.    It takes too long to download the whole thing when "cabal updating",  and too long to read the whole thing in when "cabal installing".   At least in the latter case,  I can see a strong argument for moving the index into something like sqlite or berkeleydb,  so we can get the information we need quickly without reading everything into memory
15:42:12 <hpc> MostAwesomeDude: there's Habit, which is technically a different language though
15:42:40 <dcoutts> lpsmith: I already implemented a cache for cabal-install, makes it a lot faster
15:43:10 <dcoutts> lpsmith: and we have a solution to do incremental downloads
15:43:11 <cmccann> it just seems like there's a lot of needless inefficiency buried here and there in the whole thing and I don't like just working around that
15:43:26 <cmccann> there's no obvious reason that hackage couldn't be a lot slimmer and faster
15:43:27 <elliott> cmccann: I just meant the coding effort itself :P
15:43:49 <lpsmith> dcoutts,  yeah you mentioned the incremental download, but I haven't seen the design yet.
15:43:50 <elliott> anyway I think cmccann is underestimating the amount of data that has to be stored
15:43:54 <elliott> compressed, compact disk storage is easy
15:43:57 <elliott> operating on it is slow.
15:44:04 <cmccann> elliott, oh, well in that case I've got everything obvious, as evidenced by Text and Vector being significant chunks of memory :P
15:44:15 <dcoutts> cmccann: sure, I don't like hacky workarounds either, but I think it's pretty realistic that we can get the memory use to be reasonable, combo of compaction and increasing sharing
15:44:16 <elliott> hackage2 could use 200 megabytes of memory, and it'd be really slow and the code would be awful
15:45:00 <dcoutts> yes, keep in mind that we do have performance needs too
15:45:05 <dcoutts> for a central hackage.h.o
15:45:08 <cmccann> yes, I realize that
15:45:30 <dcoutts> though it can be somewhat addressed with http proxies as long as we use etags right etc
15:47:11 <lpsmith> dcoutts, I'd like to read over the design for incremental updates at some point
15:47:39 <cmccann> I'm probably just being too pessimistic after spending a several evenings going down a few blind alleys hacking on the current codebase
15:47:53 <dcoutts> lpsmith: it's fairly simple, we just append to the .tar file and clients use http range GETs to get the tail + hash whole thing as check (if fail, GET whole thing)
15:47:57 <elliott> cmccann: don't get me wrong, I'm not the biggest fan either :P
15:48:06 <elliott> but I think an SQL database would be more hellish
15:48:08 <cmccann> the memory inefficiency and limitations of acid-state are kind of discouraging
15:48:12 <elliott> because the codebase isn't designed around it
15:48:23 <cmccann> elliott, yeah, I really don't like that idea for multiple reasons
15:48:30 <elliott> if it was designed around using an external store for everything rather than heavily-nested data types full of references, SQL would fit well
15:48:32 <dcoutts> cmccann: what's the latest on the heap profiling?
15:48:34 <elliott> but it's really not
15:49:10 <`Jake`> does anyone know if there is a way to open a new tab in gvim without having to open a file? I can't find anything about that with google... (though I'm probably using the wrong keywords)
15:49:18 <Botje> :tabnew
15:49:22 <`Jake`> thanks!
15:49:27 <cmccann> dcoutts, the main memory use at this point seemed to be a mixture of Vector, Text, Data.Map, and some lists
15:49:29 <Botje> although tabs are eww :p
15:49:49 <`Jake`> I don't use them a lot, but sometimes they are useful
15:49:59 <dcoutts> cmccann: it'd be really handy to know what portion of that is just the package index
15:50:08 <davean> my instinct would be to be more worried about GC time then memory size at that range
15:50:14 <elliott> cmccann: /me suggests HashMap
15:50:17 <cmccann> dcoutts, probably most or all of the Data.Map nodes
15:50:34 <cmccann> elliott, was actually talking about that sort of thing with tibbe the other evening
15:50:40 <dcoutts> cmccann: is it possible to make a standalone test prog using your new types and to load the whole 00-index.tar file?
15:50:44 <cmccann> apparently what I really want to use is the code he's not done with yet :P
15:50:59 <elliott> cmccann: the trie stuff?
15:51:06 <NihilistDandy> Does the report standardize a type system, or is that all on implementation?
15:51:20 <NihilistDandy> I don't see anything, so I'm guessing the latter
15:51:22 <dcoutts> NihilistDandy: yes it's standardised
15:51:27 <NihilistDandy> Oh?
15:51:44 <dcoutts> NihilistDandy: it's in the report but not in formal language
15:51:59 <qpu> NihilistDandy: yep, see also Typing Haskell in Haskell for a reference implementation
15:52:02 <cmccann> dcoutts, as possible as it'd ever be, I didn't change much else. Just ignore everything else and have main just load the acid-state stuff
15:52:28 <NihilistDandy> qpu: Saw that. That's what I was working with, but I wasn't sure since it was from the H98 days
15:52:45 <elliott> H2010 type system is identical afaik
15:52:49 <dcoutts> NihilistDandy: it's hardly different with H2010
15:53:01 <cmccann> davean, oh, fwiw stopping and starting the server without running for more than a few seconds between reports something like 35% of the time spent in GC, I think
15:53:08 <latros> stepcut: I found one
15:53:10 <latros> concat
15:53:20 <latros> (though not with the usual functor instance of [[]])
15:53:44 <elliott> latros: ?
15:53:51 <davean> cmccann: well, honestly I'd *actually* be more worried about how *long* not how much
15:53:52 <elliott> cmccann: did you use -I0?
15:53:56 <latros> it's a natural transformation between the usual list functor and this one
15:53:56 <NihilistDandy> So, HM, but GHC goes for System F_omega?
15:53:58 <elliott> like stepcut suggested
15:54:09 <latros> instance Functor [[a]] where fmap f xss = map (map f) xss
15:54:13 * cmccann doesn't recall
15:54:19 <cmccann> I set the hackage stuff aside for a while
15:54:19 <elliott> latros: ([] :. []) you mean or such
15:54:22 <elliott> that instance has the wrong kind
15:54:24 <davean> cmccann: though. yes, the percent is telling
15:54:34 <davean> albet that is a bad test case
15:54:36 <cmccann> was really busy for a few days and too frustrated by it to make progress
15:54:39 <elliott> cmccann: well the idle GC is pointless and that would turn it off, so yeah
15:54:40 <latros> uh
15:54:41 <latros> well
15:54:52 <latros> yeah, it does, because [[a]] is of the form f (f a)
15:54:54 <cmccann> davean, yeah, it's just all I remember off the top of my head, heh
15:55:02 <latros> but you can make a single type constructor
15:55:05 <latros> that does the same thing
15:55:37 <latros> (that is, the failure of the kind signature/incorrectness of the usual fmap is an implementation detail, not a conceptual one)
15:55:40 <dcoutts> elliott: yes, it's turned off in the hackage-server.cabal file
15:55:46 <elliott> latros: anyway, that instance is just the instance for the composition of [] and []
15:56:01 <elliott> instance (Functor f, Functor g) => Functor (f :. g) where fmap f (Comp x) = Comp (fmap (fmap f) x)
15:56:04 <latros> is there such an operator on type constructors?
15:56:07 <cmccann> dcoutts, oh btw, since you mentioned it earlier, it is possible that the slow loading time I get is a performance issue in cereal
15:56:10 <elliott> where newtype (f :. g) a = Comp (f (g a))
15:56:14 <elliott> available as Data.Functor.Compose.Compose
15:56:17 <latros> huh
15:56:17 <latros> k
15:56:19 <dcoutts> cmccann: sure, and in the Data.Map instance
15:56:22 <latros> well, still
15:56:35 <latros> I hadn't had a nontrivial example
15:56:36 * elliott doesn't know the context, anyway
15:56:37 <latros> until now
15:56:43 <elliott> but the composition of two functors is always a functor :)
15:56:48 <cmccann> profiling the startup stuff consistently showed stuff in cereal causing basically all the time spent
15:56:51 <latros> I was asking for a nontrivial example of a natural transformation between functors on Hask
15:57:07 <elliott> ah.
15:57:11 <latros> that is where neither functor is the identity functor and where the transformation is not an isomorphism
15:57:15 <cmccann> which isn't a problem itself, since that's what it's supposed to be doing
15:57:31 <elliott> latros: well you can do e.g.
15:57:54 <elliott> blah :: s -> (forall a. StateT s (ReaderT t m a) -> ReaderT t m a)
15:57:57 <elliott> or something
15:58:01 <elliott> but, I don't know your definition of non-trivial :P
15:58:09 <latros> *nontrivial but still intuitive
15:58:41 <elliott> that's intuitive! :P
15:58:45 <elliott> it's just flip runStateT
15:58:52 <latros> oh, nvm
15:58:54 <latros> then it's trivial
15:58:54 <latros> lol
15:58:57 <elliott> :'(
15:59:24 * cmccann recalls the feynman quote about "trivial" problems in mathematics
16:00:15 <dcoutts> cmccann: ideally with binary/cereal we should be getting 50-100Mb/s deserialisation
16:01:02 <latros> that's also probably not parametric enough
16:01:04 <monochrom> there are many non-trivial natural transformations [a] -> Maybe a
16:01:05 <latros> @ elliott
16:01:18 <latros> at least not parametric enough to be as general as it could be
16:01:40 <latros> the actual constraint to ReaderT is probably completely irrelevant
16:01:43 <monochrom> e.g., one of them is f (_ : x : _) = Just x; f _ = Nothing
16:01:48 <latros> right, right
16:01:59 <latros> but that doesn't help so much to illustrate why it's natural
16:02:00 <elliott> latros: yes, I just filled in ReaderT to satisfy your requirement :P
16:02:04 <latros> I think the concat example helped
16:02:46 <latros> the [a]->Maybe a examples don't really illustrate what a natural transformation can and cannot do, if that makes sense
16:02:57 <latros> they do as a group, but not individually
16:04:05 <latros> I take it there's a natural transformation between different State functors?
16:04:05 <cmccann> dcoutts, pretty sure I'm seeing a fraction of that speed
16:04:27 <cmccann> though I suppose GC could account for some of the difference
16:05:00 <cmccann> the profiling shows something like 80% of the time in Data.Serialize.Get.demandInput
16:05:20 <cmccann> and it takes a few minutes to load everything into memory, assuming no swapping
16:05:36 <dcoutts> cmccann: how long does it take to cat the underlying file?
16:06:07 <cmccann> which file? the export.tar?
16:06:48 <dcoutts> cmccann: the checkpoint files in state/db/
16:07:07 * cmccann can't recall how to do that recursively. :[
16:07:24 <cmccann> though I guess most of it is in the packages
16:07:44 <cmccann> hm
16:07:57 <cmccann> I'd estimate 10 seconds for everything, tops
16:08:00 <qpu> find state/db -exec cat {} \; (apologies if you meant in Haskell)
16:08:13 <elliott> qpu: -type f
16:08:24 <qpu> that too :]
16:08:25 <dcoutts> cmccann: time cat state/db/*/checkpoints*.log > /dev/null
16:08:33 <cmccann> qpu, no, just me being a bash noob despite 10 years of using a linux desktop machine :P
16:08:38 <dcoutts> cmccann: that's an overapprox since there can be multiple checkpoint files
16:09:21 <cmccann> that only took 2s
16:09:25 <cmccann> which seems suspiciously low
16:10:01 <qpu> os caches file system access so it was likely in memory, but the same is true when you read it in Haskell
16:10:37 <dmwit> ?ask kowey Do you happen to remember which version of GHC you used when you wrote the gtk2hs installation guide for Windows that's on the wiki?
16:10:38 <lambdabot> Consider it noted.
16:10:38 <cmccann> well, not very long in any case
16:11:02 <dcoutts> dmwit: would likely have been 6.12.3 or 7.0.4
16:12:09 <cmccann> dcoutts, at any rate while I understand that you have paid work to do I'm expecting to have a good chunk of free time over the next couple weeks and would like to get some progress made with hackage
16:12:28 <dcoutts> cmccann: I'll see what I can do
16:12:41 <dmwit> I guess I have to install 6.12 after all, then.
16:13:10 <cmccann> if you can sketch an outline and give me what you have I could finish the stuff you were doing
16:13:31 <dmwit> (Can't get gio to build on Windows; it doesn't like foreign import ccall "dist\build\System\blah.h" because of the \S in the String.)
16:13:34 <cmccann> I was going to try for something along those lines anyway but not being familiar enough with the whole system kept getting me stuck
16:13:58 * hackagebot GLHUI 1.1.0 - Open OpenGL context windows in X11 with libX11  http://hackage.haskell.org/package/GLHUI-1.1.0 (HugoGomes)
16:14:01 <HugoDaniel> yay
16:14:04 <HugoDaniel> my package :)
16:14:35 <DanBurton> =)
16:14:55 <dmwit> Unrelated: is there a reason that the Windows GHC distributions don't include a ghc-pkg-<version>.exe?
16:15:00 <dmwit> Very annoying.
16:15:10 <geekosaur> dmwit, shouldn't / work there?  If not, \\ should
16:15:40 <dmwit> geekosaur: Likely it will, yes.
16:15:44 <HugoDaniel> i should put a new version of it soon
16:15:47 <dmwit> geekosaur: But I want to know if this is a GHC regression.
16:15:52 <HugoDaniel> i have a few feats i want to add up to it :)
16:16:11 <dmwit> geekosaur: If it is, I plan to complain. If it isn't, I don't understand how anybody managed to use gtk2hs on Windows ever.
16:16:26 <geekosaur> I don't think it's a regression; that's a normal Haskell string, and Haskell uses \ for escapes, so there is necessarily a conflict
16:16:30 <cmccann> dcoutts, if not I have plenty of other projects I've been neglecting for the sake of hackage, so no worries if you just don't have time :]
16:16:42 <dmwit> geekosaur: The spec doesn't say anything about interpreting the string as a Haskell string.
16:16:51 <dmwit> geekosaur: It just says it copies it verbatim into the C header it generates.
16:17:43 <dmwit> (Although I couldn't tell for sure what exactly that meant. I wasn't able to interpret the spec completely.)
16:17:49 <mauke> C also uses \ for string escapes
16:17:51 <geekosaur> I think it'd assumed since it's a Haskell compiler and every other string used in Haskell uses the same format
16:18:08 <geekosaur> it would be odd if that one particular kind of string used completely different lexing rules
16:18:33 <rwbarton> what quoting rules does #include "..." use?
16:19:25 <mauke> rwbarton: that is an excellent question and I hope using \ in #include "..." is UB
16:19:35 <qpu> i don't recall \S being a defined escape sequence in any language... \n, \f, \r, \v, \t sure
16:19:59 <mauke> qpu: perl recognizes \S in regexes (but it doesn't have \v)
16:20:04 <bgamari> What does the ellipsis mean in "       spansPhotons.f.(...)      HPhoton.Utils                             890          60   10.4   26.6    10.4   26.6
16:20:13 <bgamari> In profiler output
16:20:19 <dmwit> qpu: irrelevent
16:21:13 <Guest56769> hi
16:21:25 <dmwit> bgamari: It's the name of the (...) operator, I would guess.
16:21:25 <Guest56769> I need help learning haskell
16:21:31 <qpu> i guess the \ gets discarded either way, "\x" is "x"
16:21:50 <qpu> or "\S" is "S" rather
16:21:53 <mauke> rwbarton: char '"' *> many1 q_char <* char '"' where q_char = noneOf ['\n', '"']
16:22:08 <elliott> mauke: using paths in #include in general is implementation-defined behaviour, no?
16:22:34 <Guest56769> loose :: String -> Bool                loose x = x == reverse x
16:22:51 <elliott> Guest56769: what is your question?
16:22:54 <Guest56769> what does the arrow mean?  the ::?
16:22:54 <mauke> rwbarton: but the Semantics section says that any occurrence of ' \ // /* in the q_char sequence causes UB
16:23:09 <Jafet> #include also involves openFile
16:23:13 <elliott> Guest56769: I would recommend reading Learn You a Haskell.
16:23:18 <elliott> Guest56769: it's a type signature
16:23:24 <mekeor`> @undo [a]
16:23:24 <lambdabot> [a]
16:23:27 <elliott> better to read and introductory book that would explain the basics better than we can :)
16:23:28 <elliott> @where lyah
16:23:28 <lambdabot> http://www.learnyouahaskell.com/
16:23:32 <bgamari> dmwit: Sadly there is no (...) operator in spanPhotons.f
16:23:32 <elliott> mekeor`: return a?
16:23:58 <elliott> bgamari: Is there a ... operator defined without ()? :p
16:24:02 <mauke> elliott: the mapping of include directives to headers and files is implementation defined in general
16:24:10 <mekeor`> elliott: i actually want(ed) to know whether there's a type constructor called "List"…
16:24:16 <mekeor`> is there?
16:24:23 <Guest56769> okay thanks, will read that right awya
16:24:24 <dmwit> mauke: So, is the correct way to use /, even on Windows?
16:24:27 <mauke> elliott: (note the difference because headers don't have to be files :-)
16:24:33 <dmwit> mauke: If so, that would make my life much easier.
16:24:41 <mekeor`> > let [5] :: List Integer in [5]
16:24:41 <lambdabot>   <no location info>: Invalid type signature
16:24:42 <elliott> mauke: right
16:24:46 <elliott> mekeor`: no
16:24:47 <mauke> dmwit: in general the correct way is to use / period
16:24:49 <elliott> it's []
16:24:52 <mekeor`> elliott: okay, great
16:24:54 <bgamari> elliott: Nope
16:24:58 <mauke> dmwit: regardless of #include or windows or whatever :-)
16:25:11 <dmwit> does not work everywhere in Windows.
16:25:18 <mauke> dmwit: the only exception is cmd.exe
16:25:24 <dmwit> So perhaps my definition of "correct" does not coincide with yours.
16:25:26 <mauke> it works everywhere else, including all library functions
16:25:46 * cmccann doesn't assume that any definition of correct coincides with what windows does
16:25:54 <mauke> (even DOS allowed / directory separators at the syscall level)
16:26:07 <dmwit> cmccann: yes... well, I'm learning that, too
16:26:33 <dmwit> (Thought you could copy ghc-pkg.exe to ghc-pkg-7.4.1.exe with no repercussions? SURPRISE!)
16:26:44 * cmccann has had many years of professional windows development to learn that
16:27:04 <cmccann> though at least working in .NET avoids a lot of scary stuff
16:27:41 <mauke> I "like" how you can't pass command line arguments to programs on windows
16:28:08 <elliott> cmccann: my condolences
16:28:29 * cmccann has used a combination of windows, linux and OS X for the last 5+ years
16:28:40 <zzo38> Is there any version of GHC RTS which makes some errors always fatal and some errors result in undefined behaviour, and some other things also omitted from the executable file to make them smaller?
16:29:14 <cmccann> my conclusion has been that if you want officially sanctioned end-user stuff to work nicely, use OS X, if you want development tools to work nicely, use linux, and if you want nothing to work use windows :P
16:29:57 <rwbarton> cmccann: so what did you use before that, a combination of Solaris, NeXTSTEP and OS/2? :P
16:30:05 <sm> dmwit: what went wrong with that ? thought I did that once :)
16:30:13 <hpc> zzo38: there's no way to make errors not fatal
16:30:15 <cmccann> rwbarton, I wish, that sounds hilarious
16:30:15 <hpc> afaik
16:30:33 <dmwit> sm: GHC's hacks to work around Windows' terrible command-line situation break, and it ends up looking in weird places for your package files.
16:30:43 <sm> good to know :|
16:30:55 <cmccann> dmwit, are you using cygwin, btw?
16:31:13 <dmwit> sm: e.g. if you name it ghc-pkg-something-really-long.exe, it will look in <the correct directory>\something-really-long\lib instead of the right place.
16:31:15 <cmccann> because I found that makes the whole situation fascinatingly worse
16:31:29 <dmwit> cmccann: No, I've avoided cygwin and mingw both so far.
16:31:37 <gentleben> powershell is awesome
16:31:39 <dmwit> I'm attempting to follow the gtk2hs build instructions verbatim.
16:31:53 <dmwit> (Since I'm the maintainer now, and that's kind of my responsibility.)
16:31:54 <cmccann> GHC doesn't always get along with cygwin and its ilk
16:32:05 <dmwit> I really, really believe it.
16:32:16 <cmccann> which is good on one hand because it plays comparatively nicely with native windows stuff
16:32:24 <dcoutts> dmwit: oh you're gtk2hs maintainer now?
16:32:33 <zzo38> hpc: I mean, for example, you can catch pattern match failures and I want a RTS which cannot catch pattern match failures. Some errors should be fatal always such as memory allocation failure (possibly with a C code hook to recover if necessary), some errors catchable such as I/O error, and some result in undefined behavior (pattern match fail, call to undefined, etc).
16:32:40 <dmwit> Well, technically Michael Dever and I are joint maintainers.
16:32:50 <dcoutts> dmwit: good stuff
16:32:50 <dmwit> But I seem to be on the hook for now. =)
16:32:51 <zzo38> However, it should not be the default; it should only be selected when you explicitly tell the compiler to use this one
16:33:04 <cmccann> dmwit appears to be seizing control of all kinds of interesting packages. gtk2hs and category-extras. what next, numeric prelude? :P
16:33:11 <dmwit> =)
16:33:21 <dmwit> Soon, my Haskell domination will be complete! MUAHAHAHAHA
16:33:32 <dcoutts> dmwit: if you have Qs about it feel free to ask me. I was co-maintainer for a few years and did the windows builds.
16:33:44 <dmwit> Will do.
16:33:55 <elliott> can I preorder seats for dmwit v. edwardk?
16:34:12 <cmccann> elliott, nah, I think they're working together
16:34:17 <dmwit> If I can get the current code to build with any combination of ghc version and gtk+ version, I'll call today a success, I think. =P
16:34:18 <elliott> oh, we're done for then
16:34:28 <cmccann> yes
16:35:00 <dcoutts> dmwit: in particular I've been suspicious of the all-in-one gtk+glade exe installer. I always used to use the individual gtk zip files
16:35:37 <cmccann> elliott, I think dmwit is the respectable-looking public face of the operation, edwardk looks too much like a supervillain
16:36:23 <MaybeJust> anyone good with dropbox?
16:36:28 <dmwit> dcoutts: Oh, I didn't even know there was an exe. I just used the bundle zip.
16:36:39 <dcoutts> dmwit: and I've had reports of people building gtk2hs recently on windows and getting mysterious linker problems. I blame the gtk+ they're using :-)
16:37:01 <MaybeJust> I blame you!
16:37:07 <cmccann> dmwit, let me know when you become a true expert about building haskell libraries on windows
16:37:14 <cmccann> so you can tell me how to make SDL work
16:37:15 <dmwit> cmccann: =/
16:37:24 <elliott> cmccann: step 1 install linux, etc.
16:37:38 <dmwit> I became the GNU make expert here. That's bad enough.
16:38:03 <cmccann> dmwit, well, I've written what may be the worst makefile ever
16:38:06 <cmccann> as elliott may recall
16:38:43 <cmccann> elliott, and I can't tell how much you're joking there because I think that might actually be easier
16:38:44 <dcoutts> dmwit: ah good, the instructions have been updated to not recommend that any more
16:39:12 <cmccann> the amount of time I spent failing to make it work on windows would probably have been enough to do an ubuntu install and give someone a crash course on using it
16:39:35 <monochrom> you can try it in a virtual machine first
16:39:52 <elliott> cmccann: well, I mean... I do recommend it as life advice, but not problem-solving advice :)
16:40:47 <cmccann> SDL is particularly annoying because of the horrible hack it uses on non-linux platforms to initialize stuff
16:40:58 <dcoutts> dmwit: btw, once you get past annoying install issues, and you want some bigger problem, I recommend you take a look at the new GObject haskell binding lib/tool
16:41:25 <dcoutts> dmwit: it'd be a much better approach than the generator I wrote many years back (we didn't have GObject introspection back then)
16:41:32 <dmwit> Is that a part of the repository already, or a separate project?
16:41:37 <dcoutts> separate
16:41:45 * dcoutts tries to recall what it was called
16:41:55 <MaybeJust> Weeeeee i love C
16:42:05 <elliott> cmccann: the #define main stuff?
16:42:09 <MaybeJust> C is the bestest language evah!
16:42:10 <cmccann> elliott, yes
16:42:10 <dcoutts> dmwit: http://www.haskell.org/haskellwiki/GObjectIntrospection
16:42:14 <ronankde> i don't understand class on haskell how it works?
16:42:18 * dmwit wonders vaguely how important backwards-compatibility is for gtk2hs users.
16:42:38 <elliott> ronankde: do you have a more specific question? http://learnyouahaskell.com/types-and-typeclasses is a good introduction to typeclasses
16:42:42 <dcoutts> dmwit: recently it's been distressingly stable :-)
16:42:50 <elliott> http://learnyouahaskell.com/making-our-own-types-and-typeclasses if you want to define one
16:42:56 <cmccann> elliott, it's just such an unfathomably dirty hack I don't even know what to say about it
16:42:57 <dmwit> dcoutts: Thanks for the link.
16:43:18 <cmccann> and obviously creates an extra hurdle to use SDL in Haskell on windows
16:43:26 <dcoutts> dmwit: sadly there's be more than just the gobject generator, my old generator also translated haddock docs
16:43:56 <Cale> ronankde: Do you understand type variables?
16:44:20 <MaybeJust> what would be a good haskell open source project to work on in say about a year when i have learned haskell better?
16:44:32 <dmwit> Okay, I officially don't understand how anybody ever built gtk2hs on Windows.
16:44:35 <Cale> ronankde: like in  length :: [a] -> Int,  for example, indicating that for any type a, the length function can take a list of values of type a, and produce an Int
16:44:50 <ronankde> I'm a really new on haskell
16:45:01 <dcoutts> dmwit: I swear it worked :-)
16:45:15 <ronankde> I do not understand much
16:45:22 <Cale> ronankde: okay, so first understand type variables, because typeclasses are a way of restricting the set of types that type variables range over
16:45:33 <cmccann> MaybeJust, why don't you ask that when you're ready to work on it? a year is a long time :P
16:46:06 <Veinor> are there any utilities for parsing word files?
16:46:11 <MaybeJust> not when you are 79.
16:46:14 <monochrom> dcoutts: historical semantics? http://www.mail-archive.com/haskell-cafe@haskell.org/msg86241.html :)
16:46:42 <Cale> MaybeJust: It's still a lot of time even then, because what matters is not your perception of time, but the rate of change of projects.
16:47:16 <dcoutts> monochrom: :-)
16:47:20 <elliott> ronankde: it would probably be best to continue reading whatever you're reading
16:47:30 <elliott> ronankde: and not worry about typeclasses until your book explains them
16:48:06 <MaybeJust> > let toOld = True in ToOld == True
16:48:06 <lambdabot>   Not in scope: data constructor `ToOld'
16:48:13 <MaybeJust> > let toOld = True in toOld == True
16:48:13 <lambdabot>   True
16:48:24 <ronankde> i love list comprehension in haskell
16:49:02 <ronankde> i'm Python programmer
16:49:07 <MaybeJust> > [x^2 | x <- [1..10]]
16:49:08 <lambdabot>   [1,4,9,16,25,36,49,64,81,100]
16:49:28 <MaybeJust> vs [x^2 for x in range(1,11)]
16:49:52 * cmccann used Python a lot before learning Haskell as well, but eventually stopped using list comprehensions most of the time
16:50:22 <losvedir> cmccann: why is that?
16:50:37 <MaybeJust> howdo you do colored text?
16:50:39 <ronankde> lists in haskell can not contain strings
16:50:53 <Cale> ronankde: yes they can
16:51:04 <MaybeJust> > ["oh","no","?"]
16:51:04 <lambdabot>   ["oh","no","?"]
16:51:08 <Cale> > ["here", "is", "a", "list", "of", "strings"]
16:51:09 <lambdabot>   ["here","is","a","list","of","strings"]
16:51:11 <Cale> :t ["here", "is", "a", "list", "of", "strings"]
16:51:12 <lambdabot> [[Char]]
16:51:15 <ronankde> why
16:51:16 <MaybeJust> > concat ["oh","no","?"]
16:51:17 <lambdabot>   "ohno?"
16:51:26 <ronankde> tuple is mutable
16:51:37 <cmccann> losvedir, not entirely sure, just that they're a bit limited and less composable than plain functions in many cases
16:51:43 <Cale> ronankde: ?
16:52:14 <NihilistDandy> Can anyone proofread this email I'm sending to my PL teacher to make sure I'm not coming off as hostile or just being flat god damn wrong about things?
16:52:32 <sm> MaybeJust: come work on hledger, I'll take you now :)
16:52:33 <losvedir> cmccann: interesting. would you recommend against using them? or is it just that you've happened to stop?
16:52:55 <losvedir> i'm learning haskell and it strikes me that there are lots of ways to do things; i'm having trouble at times picking "the best" way
16:53:03 <latros> they kinda obfuscate a bit
16:53:03 <cmccann> losvedir, I wouldn't recommend avoiding them, no
16:53:07 <elliott> losvedir: list comprehensions are fine to use; not using one is a stylistic preference
16:53:08 <latros> a *little* bit
16:53:16 <elliott> if you tend to code in a point-free style, you'll usually avoid them
16:53:21 <elliott> compare e.g.
16:53:23 <latros> because there's a much more general background behind them
16:53:25 <elliott> foo = map (2 ^) . filter even
16:53:26 <elliott> vs.
16:53:31 <MaybeJust> sm: hledger?
16:53:32 <elliott> foo xs = [2^x | x <- xs, even x]
16:53:32 <ronankde> tuples
16:53:44 <elliott> losvedir: the former is more composable in a way.
16:53:49 <elliott> ronankde: you're not making much sense :)
16:53:51 <Cale> If you have list comprehensions with multiple generators, those can be a good bit harder to read if you translate them away
16:54:00 <cmccann> losvedir, if you can write something easily as a list comprehension then it's fine to do so
16:54:01 <elliott> right, indeed
16:54:09 <elliott> the list monad can often help you reclaim that clarity, though
16:54:12 <elliott> since they're the same thing ;)
16:54:16 <Cale> ronankde: Please try to speak in complete sentences, eh? :)
16:54:25 <ronankde> oh sorry i'm  brazilian
16:54:37 <losvedir> elliott, cmccann: i see, thanks
16:54:54 <elliott> ronankde: lists can contain strings in haskell, and tuples aren't mutable
16:54:54 <ronankde> is difficult english for me
16:54:57 <elliott> so I'm not sure what you mean
16:55:05 * cmccann is also more likely to use a do block than a large-ish list comprehension
16:55:14 <losvedir> i really do like the list notation because of how similar it feels to math set notation, but i can see your point about composability (which I also really like!)
16:55:37 <cmccann> losvedir, yeah, though thinking of lists as sets isn't really ideal for other reasons
16:55:45 <cmccann> so that might be part of why I stopped using them as often
16:55:54 <Obfuscate> elliott: Is there really a significant difference there vs... map (2 ^) (filter even xs)
16:55:55 <elliott> losvedir: yeah, like cmccann said, you can also do: [2^x | x <- xs, even x] --> do { x <- xs; guard (even x); return (2^x) }
16:56:04 <elliott> Obfuscate: between which?
16:56:23 <elliott> losvedir: which lets you use layout, which is convenient for large comprehensions
16:56:29 <elliott> (it also lets you compose them bettwe)
16:56:30 <elliott> *better
16:56:31 <Obfuscate> elliott: That and the point-free version with identical structure.
16:56:35 <losvedir> oh, wow, i wasn't familiar with that syntax
16:56:54 <ronankde> performance problem about the tuples
16:57:02 <luite> the list comprehension version might be faster in practice since it's translated differently by ghc
16:57:06 <losvedir> is that the word 'guard', vs. a pipe like in guards when writing functions?
16:57:11 <elliott> Obfuscate: sure, it's point-free :p
16:57:16 <elliott> Obfuscate: say you want to divide every element by two before filtering it
16:57:22 <elliott> with the point-free version, you just append to the pipeline
16:57:26 <cmccann> so I guess between using do for complicated expressions and plain list functions for very simple stuff, I rarely use list comprehensions
16:57:31 <elliott> much harder to do that kind of stuff with a deeply-nested structure
16:57:47 <elliott> losvedir: I'm not sure where "guard" comes from
16:57:53 <elliott> it's kind of a guard that stops further execution if the condition is false
16:57:58 <elliott> losvedir: anyway it's not really syntax, just do-notation with the list monad
16:58:07 <elliott> guard True = return (); guard False = mzero is how it's defined
16:58:19 <elliott> (you can also use list comprehensions with any monad, rather than just [], if you turn on -XMonadComprehensions... but I digress)
16:58:30 <cmccann> it might be called "guard" by analogy to pattern guards, yes
16:58:33 <Obfuscate> elliott: I usually prefer being explicit about arguments. Can you should me an example where it really helps to be point-free? Most of what I've seen has been pretty ugly (the above example is not convincing for me).
16:58:37 <losvedir> oh boy, looks like i've got a lot of learning to do… :)
16:58:38 <cmccann> I'm not sure if that's why or not
16:59:05 <cmccann> Obfuscate, it's sort of an acquired taste
16:59:06 <elliott> Obfuscate: If you prefer being explicit about arguments, then you don't prefer point-free style by definition.
16:59:29 <elliott> Obfuscate: It's just considered idiomatic in general wherever readable (the examples you've seen were likely picked *because* of how ugly they are).
16:59:31 <cmccann> after getting used to point-free style introducing superfluous names for arguments strikes me as being ugly and unclear
16:59:41 <elliott> Obfuscate: Point-free code is easier to read when you're used to it, and it's a nicer way of looking at and reasoning about code.
16:59:53 <latros> well
16:59:54 <elliott> You can think of compositions of simple primitive programs, rather than functions defined "ad hoc" in terms of their arguments.
17:00:00 <elliott> Compositionality is really at the heart of Haskell's power.
17:00:01 <Obfuscate> I'm willing to change if there's a good reason, but what I've seen hasn't impressed me.
17:00:17 <latros> it's really when you compose together a bunch of stuff
17:00:22 <latros> that things get interesting
17:00:24 <luite> point-free code is great because it lets you write code that's even less self-documenting than regular haskell!
17:00:25 <latros> for example
17:00:27 <Obfuscate> I've used concatenative languages before, and usually found the code to be less clear.
17:00:33 <elliott> Obfuscate: which do you prefer: map (enlarge . magicify) [a,b,c] vs. map (\x -> enlarge (magicify x)) [a,b,c]
17:00:38 <elliott> the latter is IMO much harder to read
17:00:47 <elliott> Obfuscate: well point-free isn't suitable everywhere
17:00:54 <elliott> it's for self-contained definitions that fit the style well
17:00:58 <elliott> if an argument helps, you should use one
17:01:03 <latros> here's a somewhat nasty example
17:01:10 <latros> schwartzianSort f xs = sortBy (comparing fst) . map (f &&& id)
17:01:15 <latros> errr
17:01:17 <latros> sorry
17:01:19 <latros> chop off the xs
17:01:19 <ronankde> Io is one type in haskell
17:01:21 <monochrom> http://www.vex.net/~trebla/weblog/pointfree.html
17:01:32 <latros> agh
17:01:33 <latros> sorry
17:01:35 <elliott> latros: you probably want a map snd too
17:01:35 <ronankde> Io  = I/O
17:01:37 <latros> knew there was another .
17:01:38 <latros> yeah
17:01:39 <Obfuscate> elliott: The former does seem a bit cleaner.
17:01:47 <elliott> schwartzian f = map snd . sortBy (comparing fst) . map (f &&& id)
17:01:49 <latros> schwartzianSort f = map snd . sortBy (comparing fst) . map (f &&& id)
17:01:53 * elliott finds that very easy to comprehend
17:02:10 <latros> the only thing in there that it isn't relatively obvious what it means is &&&
17:02:12 <elliott> compared to schwartzianSort f xs = map snd (sortBy (comparing fst) (map (\x -> (f x, x)) xs))
17:02:27 <elliott> and of course, you could argue that (comparing fst) is point-free style in a way too
17:02:29 <elliott> since it's compositional
17:02:38 <latros> it's not really pointfree, it's less-pointed
17:02:39 <elliott> at which point the pointful version would get even uglier :)
17:02:58 <latros> actual point free code is often rather ugly
17:03:00 <Obfuscate> Does anyone have a good readable example of predominantly point-free Haskell they can paste?
17:03:07 <elliott> not much haskell is "predominantly" point-free
17:03:10 <ronankde> typeclass != OO
17:03:12 <elliott> because it'd be hideous
17:03:17 <elliott> in most cases
17:03:22 <latros> it's when you put stuff together
17:03:26 * cmccann notes that making schwartzian completely pointfree by removing the "f" argument as well would likely be horrific
17:03:26 <latros> that you do things pointfree
17:03:30 <elliott> right
17:03:30 <rwbarton> @pl schwartzian f = map snd . sortBy (comparing fst) . map (f &&& id)
17:03:31 <lambdabot> schwartzian = ((map snd . sortBy (comparing fst)) .) . map . (&&& id)
17:03:31 <latros> yes
17:03:36 <elliott> Obfuscate: it's always just a tool, it's very rare that an entire program will be elegant in point-free style
17:03:36 <latros> yeah
17:03:40 <Obfuscate> Okay, so just prefer it in some simple cases that are easily made that way?
17:03:45 <elliott> not necessarily simple
17:03:49 <elliott> it just doesn't always apply, that's all
17:03:54 <elliott> it applies when you have a compositional definition
17:03:55 <latros> ((foo . bar (baz)) .)
17:03:56 <latros> thing
17:04:00 <cmccann> Obfuscate, if you have to jump through hoops to make something pointfree that's a good sign you shouldn't
17:04:04 <elliott> now, having compositional definitions actually corresponds with a well-structured program
17:04:12 <elliott> so if point-free is working for you a lot of the time, that's a good sign
17:04:13 <monochrom> http://groups.google.com/group/comp.lang.functional/msg/17520bdd236b3351 has an example of predominantly pointful that should have been predominantly pointfree
17:04:17 <latros> that definition right there is naturally "point free in the second argument"
17:04:25 <latros> because you just pass the second argument up the pipeline
17:04:35 <latros> it is not naturally point free in the first argument
17:04:38 <dmwit> There are comments in here about Haskell 1.4 compatibility. O_o
17:04:43 <latros> because there isn't a pipeline that f gets passed through
17:04:49 <elliott> Obfuscate: but consider latros' example of "map snd . sortBy (comparing fst) . map (f &&& id)" -- I can read this instantly, it's "map everything to a tuple with f on the first and keeping the second the original value, sort by the first, and take the second of all the results"
17:05:03 <cmccann> my rules of thumb include that pointfree should be all or nothing for closely related arguments, and that operator sections of (.) are almost always a sign that you shouldn't try
17:05:09 <elliott> because it's written in a compositional style, it's easy and quick to understand as long as you understand every part
17:05:16 <elliott> and it avoids parenthesis hell by composing rather than nesting
17:05:30 <monochrom> pointful is clearer in one thing (the parameters) and pointfree is clearer in another thing (the functions)
17:05:35 <dmwit> cmccann: (foo .) . bar is almost a Haskell pattern.
17:05:50 <MaybeJust> > take 5 $ even x
17:05:51 <lambdabot>   Couldn't match expected type `[a]'
17:05:51 <lambdabot>         against inferred type `GHC.Bool....
17:05:57 <elliott> dmwit: anti-
17:06:05 <latros> (foo .) . bar is actually common enough that I have thought about making it an operator
17:06:06 <latros> >.>
17:06:10 <monochrom> so you can spend infinite time arguing which one is clearer, as long as you don't say clearer in what.
17:06:13 <dmwit> :t (:.)
17:06:13 <latros> any more nesting than that is just bad
17:06:14 <lambdabot> Not in scope: data constructor `:.'
17:06:17 <monochrom> @quote monochrom debates
17:06:17 <lambdabot> monochrom says: All pointless debates can be settled by going polymorphic.
17:06:21 <latros> :k (:.)
17:06:22 <lambdabot> Not in scope: type constructor or class `:.'
17:06:24 <latros> huh
17:06:24 <latros> nvm
17:06:26 <cmccann> :t (.:)
17:06:27 <lambdabot> forall a b (f :: * -> *) (g :: * -> *). (Functor f, Functor g) => (a -> b) -> f (g a) -> f (g b)
17:06:32 <latros> oh
17:06:33 <dmwit> There it is.
17:06:34 <latros> k
17:06:36 <elliott> CAAAAAAALE
17:06:36 <exFalso> good evening, is there a way to compose two ((->) a)s? something like ((->) a) . ((->) b) :: * -> *?
17:06:50 <losvedir> for what it's worth as a Haskell newbie, reading point free vs. not conveys a different message. Do you describe a function in terms of other functions? Or do you walk an input through a series of transformations?
17:07:03 <Obfuscate> elliott: I'm working through a few examples. It seems cleaner for some of them, but somewhat uglier in general.
17:07:03 <dmwit> exFalso: In general, there is no good (convenient) way to compose any two type constructors.
17:07:12 <dmwit> exFalso: This was a deliberate choice by the language designers.
17:07:25 <latros> it's more like, do you pipe the input through some small steps
17:07:27 <elliott> Obfuscate: I don't think anything will convince you ;)
17:07:31 <latros> or do you do things one step at a time
17:07:35 <mhitza> exit
17:07:37 <dmwit> exFalso: However, there are half a dozen implementations of newtype Compose f g a = Compose (f (g a)) on Hackage.
17:07:41 <MaybeJust> whats the &&& about?
17:07:43 <elliott> it's fine if you don't like point-free. no big deal. I have a strong preference for it when it is possible
17:07:48 <exFalso> dmwit: thanks:)
17:07:49 <elliott> and use it as a guide for when my code is structured well
17:07:49 <latros> &&& is in Control.Arrow
17:07:52 <latros> for functions, it's just
17:07:53 <elliott> MaybeJust: (f &&& g) x = (f x, g x)
17:07:57 <latros> that
17:08:15 <losvedir> e.g.: drive forward two blocks, turn left, go straight two blocks, turn right. vs. "drive to the supermarket, then head towards the sun"
17:08:16 <latros> it's defined on Arrows in general, however
17:08:23 <losvedir> hmm…. i guess that didn't really go anywhere. never mind :p
17:08:24 <latros> but lemme paste something
17:08:30 <Obfuscate> elliott: I'm not much of a Haskell programmer, which is why I asked. If you're saying it's better in some cases, but not all (or even most), then I think we already agree anyways.
17:08:32 <exFalso> dmwit: a newtype is not exactly what i was looking for, but i guess ((->)(a,b)) is isomorphic so i'll go with that
17:08:43 <elliott> Obfuscate: it's for glue code, essentially
17:08:55 <elliott> if you're implementing an all-new algorithm with pattern-matches and the like, probably point-free isn't best
17:09:01 <elliott> and writing a do block in point-free style would usually be ridiculous
17:09:16 <elliott> but when you're composing, point-free style is... defined as using composition, so for tasks of composition, it's better
17:09:38 <elliott> and compositionality is a very prominent quality of well-structured programs, so...
17:10:30 <Obfuscate> That makes sense to me.
17:11:20 <losvedir> one thing that kind of makes point free style writing is knowing when parentheses are required, and how operator precedence works in general
17:11:29 <losvedir> *makes it hard
17:11:32 <elliott> you a word
17:11:41 <losvedir> hehe, yes, thanks...
17:11:54 <losvedir> like, i just finished a project euler program and ended up with this, after some trial and error
17:12:04 <losvedir> textToTriangle =  map (map read . words ) . lines
17:13:09 <dmwit> dcoutts: "cabal clean" seems a bit broken on Windows. Do you care?
17:13:18 <losvedir> how does haskell know map read . words should be map (read . words) ?
17:13:35 <dcoutts> dmwit: the problem with deleting the dist dir containing the setup.exe
17:13:37 <losvedir> i thought white space application was the highest precedence thing?
17:13:53 <dmwit> dcoutts: the very same
17:14:15 <rwbarton> losvedir: map read . words isn't map (read . words).
17:14:29 <rwbarton> white space application is (just about) the highest precedence thing.
17:14:31 <dcoutts> dmwit: it's an annoying one. The problem is how to divide the task between the package's Setup.hs and cabal-install
17:14:33 <dmwit> losvedir: record syntax has higher precedence than function application
17:14:34 <byorgey> losvedir: it doesn't, because it isn't.
17:14:52 <dmwit> dcoutts: yeah
17:15:00 <losvedir> ah, right! it's (map read) . words
17:15:06 <byorgey> yep
17:15:22 <dcoutts> dmwit: in principle cabal-install ought to use a separate tmp dir for itself and not assume anything about the layout of the package's build dir, but that's also a bit annoying
17:15:40 <losvedir> why… is that? i don't have a good working model in my head of when haskell groups things
17:16:45 <dmwit> dcoutts: Anyway, it seems like this is a known issue, which is good enough for me. I know how to delete the dist directory myself.
17:16:59 <lpsmith> losvedir, it's just convention.   Parenthesis goes around function applications,  not infix operators
17:17:06 <dmwit> Annoying, but not annoying to fix (yet). =P
17:17:12 <byorgey> losvedir: the highest precedence thing is normal function application (with the exception of record syntax as dmwit points out, but you probably don't need to worry about that right now)
17:17:23 <byorgey> losvedir: then come infix operators, in order from high (9) to low (0) precedence
17:17:46 <byorgey> losvedir: for example  2 + 3 * 5  parses as  2 + (3 * 5)  because * has higher precedence than +
17:18:06 <losvedir> byorgey: i see. and because they're both infix, i guess
17:18:13 <byorgey> yes
17:18:31 <byorgey> as another example,  2 + abs 3 * 5  parses as  2 + ((abs 3) * 5)
17:18:45 <lpsmith> You can look up the precidence of an operator pretty easily by ghci> :info (+)
17:18:51 <rwbarton> where's that parenthesizing web app someone posted a day or two ago?
17:18:57 <dmwit> gio built! \o/
17:18:58 <lpsmith> unfortunately haddock doesn't infix
17:18:59 <losvedir> :byorgey, oh that example actually helps a lot
17:19:16 <byorgey> and  map read . words   parses as  (map read) . words    =)
17:19:33 <byorgey> dmwit: \o/
17:19:39 <lpsmith> err.  haddock doesn't list fixity declarations
17:19:43 <rwbarton> ah
17:19:55 <rwbarton> losvedir: http://bm380.user.srcf.net/prettyparsetree.cgi?exp=2+%2B+abs+3+*+5
17:20:26 <losvedir> aha! then map (map read . words ) . lines parses as   (map ((map read) . words)) . lines
17:20:45 <losvedir> lpsmith: thanks for the :info tip
17:21:13 <elliott> @hoogle (a -> Bool) -> [a] -> Bool
17:21:13 <lambdabot> Prelude all :: (a -> Bool) -> [a] -> Bool
17:21:14 <lambdabot> Data.List all :: (a -> Bool) -> [a] -> Bool
17:21:14 <lambdabot> Prelude any :: (a -> Bool) -> [a] -> Bool
17:21:20 <losvedir> rwbarton: that's neat
17:22:33 <losvedir> so i think i got it. record syntax, then function application, then infix operators from high (9) to low (0), as seen in :info. thanks everyone!
17:24:46 <byorgey> losvedir: yup, you got it
17:24:59 <rwbarton> and lastly type ascription (foo :: Bar)
17:26:13 <losvedir> ah, interesting
17:26:58 <losvedir> playing around in ghci, i see `elem` is infix 4, while (+) is infixl 7
17:27:27 <losvedir> is there something significant about infix vs infixl?
17:27:35 <cmccann> yes
17:27:35 <lpsmith> yes
17:27:40 <adnauseam> yes
17:27:40 <cmccann> it's which direction they group in
17:27:43 <adnauseam> :p
17:27:46 <rwbarton> infixl means a + b + c parses as (a + b) + c
17:27:48 <dmwit> > True == True == True
17:27:49 <lambdabot>   Precedence parsing error
17:27:49 <lambdabot>      cannot mix `GHC.Classes.==' [infix 4] and `GH...
17:27:54 <cmccann> adnauseam, fitting nick :P
17:27:58 <rwbarton> infix means x `elem` y `elem` z is a syntax error
17:28:04 <adnauseam> ;}
17:28:40 <losvedir> ah, i see! and that's for when you have multiple of the same infix operator in a row?
17:28:48 <lpsmith> exactly
17:28:49 <losvedir> or i guess, multiple operators at the same precedence level
17:28:50 <dmwit> The "..." there goes like `GHC.Classes.==' [infix 4]
17:28:58 <cmccann> yeah, doesn't need to be the same operator
17:29:00 <rwbarton> losvedir, exactly
17:29:02 <lpsmith> there's also infixr
17:29:11 <lpsmith> look up (&&) for example
17:29:27 <dmwit> > 2 + 3 - 5 :: Expr
17:29:28 <lambdabot>   2 + 3 - 5
17:29:35 <dmwit> > 2 + (3 - 5) :: Expr
17:29:36 <lambdabot>   2 + (3 - 5)
17:29:40 <dmwit> > (2 + 3) - 5 :: Expr
17:29:41 <lambdabot>   2 + 3 - 5
17:30:31 <losvedir> wow, this is all more sophisticated than i was expecting. very cool.
17:32:05 <losvedir> hm. so if i wanted to create my own infix function, how do i assign it a precedence?
17:32:14 <hpc> infix(r/l) #
17:32:17 <losvedir> */operator (not sure about terminology)
17:32:34 <losvedir> where do i put that?
17:32:41 <cmccann> losvedir, if you use :i in GHCi it shows you the same syntax a declaration uses
17:32:42 <dmwit> In the file with the operator's definition.
17:33:01 <byorgey> infixr 5 ++&
17:33:03 <cbm80> how does one decide on what fixity is best or useful for a self-made operator?
17:33:06 <byorgey> (++&) = ...
17:33:17 <losvedir> ah, gotcha
17:33:34 <dmwit> cbm80: "go with your heart"
17:33:45 <rwbarton> what? no. you must look deeply into your soul
17:33:49 <cmccann> cbm80, depends on what other operators it's likely to be mixed with in an expression
17:33:54 <dmwit> cbm80: There are some principles, though; for example, it should associate towards the side that it's not lazy in.
17:33:59 <byorgey> cbm80: I usually decide which standard operator it is "most similar to" and give it the same precedence
17:34:11 <dmwit> err... that it *is* lazy in
17:34:17 <cbm80> dmwit: ah, ok
17:34:18 <byorgey> as for associtivity, ... right, what dmwit said
17:35:04 <cmccann> and for asymmetric operators the associativity is usually obvious
17:35:13 <cmccann> e.g. (??) = flip fromMaybe
17:35:46 <dmwit> Is there a Haskell' proposal to allow arbitrary reals for precedence?
17:35:50 <cmccann> one direction is clearly useful for chaining it, the other direction not so much
17:35:57 <dmwit> (...arbitrary rationals, I suppose)
17:36:00 <cmccann> dmwit, why not complex numbers?
17:36:02 <cbm80> cmccann: i see
17:36:19 <dmwit> cmccann: Because complex numbers aren't ordered properly!
17:36:25 <NihilistDandy> Any knowledgeable Haskellers have a free moment to glance at this email to my PL professor before I send it off. I've gotten input from ##cs and #ocaml, so I thought for the sake of completeness I'd make the rounds :D
17:36:34 <dmwit> I forget the right name for it. Linearly ordered, maybe?
17:36:38 <cmccann> dmwit, that would be vertical associativity, obviously. defined in terms of layout somehow
17:36:46 <NihilistDandy> *?
17:37:01 <luite> dmwit: not an ordered field
17:37:09 <cmccann> NihilistDandy, I guess I'll take a look but I can't promise I'll have anything helpful to say :P
17:37:18 <dmwit> I can never keep all the different orderings straight.
17:37:18 <byorgey> surely we don't need our precedences to form a *field*.
17:37:21 <dmwit> There's too many of them.
17:37:24 <luite> you can linearly order them of course, but the order won't satisfy the ordered field axioms
17:37:34 <NihilistDandy> cmccann: Helpfulness would be a side effect :P
17:37:39 <NihilistDandy> http://pastehtml.com/view/bp637mz4n.mrk
17:37:48 <NihilistDandy> Context: I commented on OCaml's spec seeming to be a result of its implementation, and my professor responded by saying "Haskell doesn't even have a specification."
17:37:54 <NihilistDandy> *rather than the other way around
17:38:07 <NihilistDandy> It's a PL class, language in use is OCaml, he's an MLer, I'm a Haskeller
17:38:15 <NihilistDandy> It's enjoyable, though the syntax quirks are a bit jarring
17:38:24 <NihilistDandy> Just want to make sure it's appropriately sourced, not hostile nor kowtowing, and preferably not just flat wrong about things :D
17:38:39 <NihilistDandy> He's a great teacher when he's not evangelizing or putting on blinders, but commentary like that from a PL researcher seemed bizarre
17:39:00 <NihilistDandy> I asked #ocaml and it was suggested that I remove all the points about OCaml
17:39:16 <NihilistDandy> Not surprised, but not unconvinced
17:39:49 <NihilistDandy> I've just been doing all the homework in Haskell and rewriting it in OCaml :D
17:39:52 <zzo38> Is coKleisli category for environment comonad like the Kleisli category for reader monad?
17:40:06 <dmwit> NihilistDandy: Personally, my advice would be to just delete the email wholesale.
17:40:06 <hpc> what's CoKleisli?
17:40:21 <hpc> CK {rCK :: cm a -> b}?
17:40:23 <dmwit> NihilistDandy: At best, forward a link to the report and leave it at that.
17:40:26 <zzo38> hpc: Yes
17:41:11 <rwbarton> zzo38: well those (co)monads are adjoint, so yes
17:41:15 <hpc> zzo38: it's different then, i think
17:41:17 <rwbarton> they are the same category
17:41:24 <hpc> oh, the same?
17:41:25 * cmccann still thinks the only sensible response, if he's an ocaml fan, is "SML says you should sit down and shut up"
17:41:55 <hpc> rwbarton: how? i would think that one would be defining (.) with bind, and the other with cobind
17:41:58 <rwbarton> yeah, is this about a "specification" or a formal semantics?
17:42:06 <NihilistDandy> I thought about non sequitur H2010, but I really am curious about this OCaml spec issue
17:42:19 <dmwit> rwbarton: Wait, are you implying that OCaml has a formal semantics?
17:42:30 <rwbarton> I'm not intending to imply anything
17:42:50 <dmwit> Okay, let me try that again, because you missed what I was interested in there.
17:42:56 <dmwit> Does OCaml have a formal semantics?
17:43:15 <rwbarton> I don't know.
17:43:16 <losvedir> nihilistdandy: from a stylistic point of view, you might want to begin the email with the clause "The assertion that Haskell lacks a standard….", so it's clear from the get-go what it's about
17:43:28 <NihilistDandy> losvedir: That's a fair point
17:43:49 <dmwit> From a stylistic point of view, this email is way too uptight.
17:43:53 <NihilistDandy> rwbarton: I'm not interested in the semantics really. Meaning is mostly irrelevant to what I'm curious about
17:44:18 <zzo38> How can we possibly fix various problems with Haskell, such as that Functor is not a superclass of Monad, join is not a class method of Monad, things about numeric literals, about kinds, etc, and various other things? If such extension cannot be made, then is there no better way than making an entirely new programming language which compiles into GHC Core?
17:44:21 <rwbarton> hpc: it's true you have to check not just that the Functors are adjoint but also that cobind on the environment comonad corresponds to bind on the reader monad
17:44:26 <NihilistDandy> dmwit: I wanted to be factual and nothing more. It's not like he and I are friends or something?
17:44:33 <maurer> NihilistDandy: "Haskell has no specification at all" may be referring to haskell as it is practiced, i.e., with extensions, which is in fact not formally specified
17:44:37 <NihilistDandy> *-?
17:44:41 <cmccann> yeah, it feels like it's trying too hard on the "non-confrontational" bit
17:44:50 <dmwit> NihilistDandy: Well, with the attitude in this email, you certainly won't become friends, either.
17:45:00 <dmwit> Which would be a shame, if he's a PL guy and you're interested in Haskell so much.
17:45:09 <byorgey> NihilistDandy: what's your goal?  what are you trying to accomplish with this email?
17:45:12 <cmccann> if the guy's a PL researcher of any sort I don't see why "you are wrong and here is why" followed by multiple references isn't appropriate :P
17:45:13 <maurer> NihilistDandy: The actual answer is that he is probably well aware that there is some specification, and you're not going to help him out much with this email.
17:45:16 <NihilistDandy> dmwit: Any thoughts on a more friendly way to do this?
17:45:29 <rwbarton> NihilistDandy: I agree with maurer, to play devil's advocate, if "Haskell doesn't even have a specification." is supposed to have a true interpretation, probably he means Haskell as in what GHC accepts
17:45:39 <NihilistDandy> byorgey: Mostly I just want to point him to the spec and ask for clarification on OCaml's
17:45:53 <byorgey> NihilistDandy: why?
17:46:04 <zzo38> That too, is the other minor problem with Haskell.....
17:46:07 <NihilistDandy> Curiosity, what else?
17:46:30 <byorgey> NihilistDandy: if it's just curiosity, then there's no reason to point him to the Haskell spec, and you can learn about Ocaml's specification on your own way more easily.
17:46:37 <dmwit> NihilistDandy: "Hey man, I was surprised by your comment today because of http://<spec.org>. What did you mean?"
17:46:50 <rwbarton> dmwit++
17:46:53 <NihilistDandy> dmwit: That's useful.
17:46:55 <NihilistDandy> dmwit++
17:47:02 <elliott> dmwit++ dmwit++ dmwit++ dmwit++ dmwit++ dmwit++ dmwit++ dmwit++ dmwit++ dmwit++ dmwit++ # INFLATION
17:47:06 <dmwit> lol
17:47:14 <hpc> ~dmwit
17:47:38 <hpc> results may vary; check your word size before executing
17:47:42 <cmccann> also, if someone is in the habit of saying ridiculous things without justification, politely asking for clarification "because you're curious" until they embarrass themselves and go hide is pretty effective :P
17:47:49 <NihilistDandy> lol
17:48:31 <hpc> cmccann: or you can agree with them until they dig a hole that's impossible to get out of :P
17:48:53 <cmccann> hpc, yeah, same basic idea
17:49:10 <cmccann> keep encouraging them until they realize what's happened
17:49:40 <NihilistDandy> Sidenote, haskell++
17:49:41 <hpc> NihilistDandy: my experience with wrong professors is to just ignore their wrongness and outsmart them in all your work
17:49:58 <NihilistDandy> #ocaml said to take out the parts about OCaml. #haskell said "Don't be such a dick, moron."
17:50:15 <hpc> haha
17:50:19 <ion> preflex: karma haskell
17:50:19 <preflex>  haskell: 63
17:50:20 <cmccann> no, don't be half a dick
17:50:26 <hpc> preflex: karma ocaml
17:50:27 <preflex>  ocaml: 2
17:50:38 <dolio> Haskell doesn't have a _formal_ specification.
17:50:43 <cmccann> either don't be a dick or don't pretend you aren't :P
17:51:00 <NihilistDandy> cmccann: You've caught me :D
17:51:11 <cmccann> the "you are wrong and here is why" bullet point response is still an option if you don't mind the potential consequences :P
17:51:15 <Cale>   
17:51:31 <dolio> I haven't heard of OCaml having one either, off the top of my head.
17:51:54 <ion> preflex: karma ocml
17:51:54 <preflex>  ocml has no karma
17:51:56 <ion> preflex: karma ocaml
17:51:56 <preflex>  ocaml: 2
17:51:58 <dolio> If that was at issue.
17:52:52 <NihilistDandy> cmccann: I don't really know what he'd do. I'm the only functional programmer in the room, and I like to chat about it.
17:52:59 <NihilistDandy> I'll just have to be nice
17:53:02 * NihilistDandy shivers
17:53:24 <zzo38> How would implement programming language with types like Haskell and can compile into GHC Core, and then compile GHC Core to executable files, but omit the parts of the RTS which you are not using?
17:53:25 <cmccann> in that case I'd probably just roll your eyes privately and drop the matter
17:53:41 <Enigmagic> zzo38: i call it dynamic linking
17:53:54 <dmwit> cmccann++
17:54:04 <NihilistDandy> Damn you all and your insidious logic
17:54:08 <NihilistDandy> :D
17:54:09 <cmccann> I can't imagine any interpretation of his statement that isn't either seriously mistaken or intentionally disingenuous
17:54:17 <cmccann> and in either case, calling him on it won't improve your relationship
17:55:22 <zzo38> Enigmagic: Dynamic linking? No, I mean making the compiler recompile the RTS with the program but only the parts that are used
17:55:45 <Enigmagic> zzo38: yeah, dynamic linking. one copy sits on disk and programs only load the functions that are used
17:55:54 <NihilistDandy> Eh. I'll just link to the thing because I can't leave well enough alone, but I'll be all dmwit-like and nice
17:56:02 <NihilistDandy> Two sentences tops
17:56:04 <Enigmagic> (well, pages that contain functions that are used)
17:56:20 <dmwit> zzo38: You've asked this at least five times in the last two days. Have you started looking at the GHC codebase yet?
17:56:21 <zzo38> Enigmagic: I know what that is. But that isn't what I meant. I meant to statically link it
17:57:18 <dmwit> It's open source. The point of open source is that you massage it to work the way you need it to work.
17:57:20 <zzo38> dmwit: And what timezone are you in? I was not on yesterday
17:57:26 <Enigmagic> zzo38: seems like a function of the linker not the compiler
17:57:39 * dmwit picked the numbers "five" and "two" out of thin air
17:58:01 <dmwit> But I've seen comments or questions basically in this vein several times very recently, with approximately equal response each time.
17:58:04 <zzo38> dmwit: O, that is what timezone you are in.
18:00:15 <zzo38> You have seen that kind of questions before?
18:01:10 <ozgura> does anyone use textmate + the haskell bundle? there is an option to "Show Type" and it seems to call a tool called "haskelltype", which is not on my system. I might just as well be getting this wrong.
18:01:13 <dmwit> Yes. You suggested a "language" extension for doing this (about as devoid of detail as this last request), you asked how to get GHC to remove parts of the RTS not needed when the spec is modified to allow undefined behavior in some cases, and then there's now.
18:01:57 <dmwit> What are you expecting of us? The ability to transmute a sophisticated program analysis out of thin air to make your program binary smaller?
18:02:00 <zzo38> dmwit: Well, that wasn't yesterday. And it wasn't a language extension either; I suggested a compiler extension that's different.
18:02:50 <zzo38> dmwit: And I suppose that is almost what I was expecting, if such a things can be done
18:03:11 <dmwit> Nobody has done it yet. It is probably possible. If you want it badly, you should figure out how to do it.
18:03:34 <dmwit> I'm not sure there's much else we can say about it.
18:03:42 <zzo38> OK
18:07:14 <zzo38> I understand open source I like open source, but I told you before I cannot compile GHC on my computer.
18:08:00 <dmwit> True. You did tell me this before.
18:08:23 <dmwit> I apologize for forgetting it. I'm not sure what you can do about that.
18:08:42 <dmwit> You might consider upgrading, or purchasing some time on a more powerful computer (e.g. an Amazon EC2 instance or some such thing).
18:08:44 <elliott> you could try and fix the compilaton :p\
18:08:50 <elliott> s/\\$//
18:09:12 <dmwit> elliott: If I recall correctly, he doesn't have enough RAM.
18:09:31 <elliott> He could optimise GHC to use less RAM ... wait.
18:09:34 <elliott> Anyway, swap?
18:09:38 <elliott> It'd be slow, but...
18:09:41 <cmccann> swapping is so much fun
18:10:00 <dmwit> Yeesh, as if building GHC didn't take long enough, now you want to multiply that by 1000?
18:10:01 <byorgey> > swap ("RAM", "disk")
18:10:02 <lambdabot>   Not in scope: `swap'
18:10:05 <byorgey> aww
18:10:19 <elliott> dmwit: Well, it's a question of who's time you'd rather waste.
18:10:29 * cmccann wastes elliott's time
18:10:30 * copumpkin coughs
18:10:31 <copumpkin> whose
18:10:40 <dolio> Whom's.
18:10:47 <elliott> copumpkin: I will take you're correction into consideration.
18:10:50 <dmwit> dolio: D=
18:11:03 <elliott> copumpkin: Thank's.
18:11:08 <lpsmith> argh,  sometimes the "no circular imports" issue really bites you, especially when trying to reorganize stuff
18:11:19 <elliott> lpsmith: hs-boot time!
18:11:24 <dmwit> elliott: "Don't" use quotation marks for emphasis, please.
18:11:24 * copumpkin slaps elliott 
18:11:28 <monochrom> you can have circular imports
18:11:50 <dmwit> In fact, the spec specifically requires compilers to support circular imports.
18:12:02 <elliott> dmwit: It's a bad habit of mine.
18:12:15 <elliott> (Except it's not emphasis, I use it when I don't really know what I want the quoted word to mean.)
18:12:27 <dmwit> whooosh
18:12:38 <elliott> Oh.
18:12:43 <elliott> You should have picked something I don't actually do.
18:12:45 <elliott> Shame on you.
18:13:10 <monochrom> please don't use the ackermann function!
18:13:20 <lpsmith> dmwit,  yes but GHC doesn't really support it very well.
18:13:36 <dmwit> Really? I thought hs-boot files were pretty simple.
18:13:39 <dmwit> Once you get the hang of them.
18:16:16 <dmwit> I guess it's a bit annoying.
18:22:24 <vyom> If I pulled a darcs repo with darcs get --lazy, what is the procedure to update it with the latest changes ?
18:22:45 <dmwit> Oh man, I just asked that in #darcs a few days ago.
18:22:49 <dmwit> Hold on, I'll tell you what they said.
18:23:16 <DanBurton> It's more complicated than just "darcs pull"?
18:24:00 <dmwit> darcs check, or darcs changes -v
18:24:13 <dmwit> You can >/dev/null that second one if you don't want to watch the progress.
18:24:25 <dmwit> DanBurton: Yes, pull just pulls new patches, not old ones. =)
18:25:00 <elliott> I don't think vyom implied old patches
18:25:03 <elliott> "latest" is "new" to me
18:25:06 <dmwit> (I think I'd be annoyed if every pull tried to spend hours filling in my repository history.)
18:25:16 <dmwit> ...oh
18:25:17 <dmwit> quite
18:25:24 <vyom> thanks.. i tried darcs pull.. it displayed the prompt for every patch..
18:25:50 <dmwit> vyom: I misunderstood your question, so the commands I suggested won't do what you want.
18:25:57 <dmwit> vyom: darcs pull is indeed the right way to do it.
18:26:08 <dmwit> If you want to pull everything without reading about each patch, just hit a at the prompt.
18:26:14 <dmwit> (Hit ? to see your other options.)
18:26:31 <DanBurton> yes that ^ the "a" signals that you want all the new patches
18:26:44 <vyom> cool.. got it.. thanks for the live support :)
18:27:20 <zzo38> I try to think, is there a way to fix the typeclasses so that Monad has join as a method and Functor as a superclass instead of the way it is now, without requring making up new extensions or new programming languages?
18:27:30 <DanBurton> vyom: that'll be $20 please :) j/k
18:28:07 <DanBurton> zzo38: sure it's quite possible
18:28:39 <dmwit> {-# LANGUAGE NoImplicitPredule #-}; import FixedPrelude
18:28:40 <dmwit> done
18:28:44 <dmwit> ;-)
18:28:57 <zzo38> I mean, in a way which you can still make it compatible with things that use the standard classes
18:29:32 <dmwit> http://repetae.net/recent/out/classalias.html
18:30:02 <cmccann> dmwit, isn't that pretty much superseded by the Constraint kind?
18:30:20 <dmwit> That sounds plausible.
18:30:37 * dmwit hasn't been following the debate to closely
18:30:48 <zzo38> dmwit: That is just another extension; and anyways I have proposed an extension like that too, but you use "type" to create class aliases instead of "class alias", and "default instance", but I meant without new extensions way!!!!
18:31:10 <dmwit> cmccann: Will base-5 use constraint kinds to fix things? =)
18:31:36 <cmccann> would be nice :P
18:31:57 <dmwit> zzo38: No, you can't fix the situation without either breaking existing code or adding an extension.
18:32:02 <dmwit> Does this answer your question?
18:32:12 <zzo38> Are you sure it cannot be done using Template Haskell somehow?
18:32:39 * dmwit nods firmly
18:32:45 * elliott awards dmwit the Cale Award for Excellence in Patience
18:32:45 <cmccann> isn't that an extension as well?
18:32:56 <zzo38> cmccann: Yes but it is one that already exist
18:33:11 <cmccann> ...and ConstraintKinds doesn't?
18:33:12 <hpaste> DanBurton pasted “Mownad” at http://hpaste.org/64259
18:33:38 <NihilistDandy> mmm. Port.
18:33:50 <parcs`> what is a class alias? is it anything like what constraintkinds can do?
18:33:55 <cmccann> elliott, is patience measured in units of Cale now?
18:34:08 <Jafet> millicales.
18:34:16 <zzo38> ConstraintKinds does exist but it is the newest GHC (I am unsure if it is in Haskell Platform and compatible with everything for sure) and won't do it by itself anyways (I also think the name for the kind "Constraint" is too long but that is different)
18:34:44 <cmccann> yes, your preference for cryptic and poorly-chosen symbols has been notced
18:34:56 * DanBurton wonders what the Cales-to-mzeros exchange rate is
18:35:01 <dolio> Class aliases had features that making a type alias wouldn't give you.
18:35:17 <dolio> Potentially.
18:35:24 <cmccann> dolio, ah, like what?
18:35:27 * cmccann is curious
18:35:40 <dmwit> parcs`: cmccann claims they're so similar that ConstraintKinds subsumes class aliases
18:35:46 <dolio> Like being able to define an instance for the alias and get instances for the components.
18:36:09 <cmccann> not claiming, asking
18:36:17 <cmccann> since that was roughly my impression
18:36:26 <dmwit> I will have to retract my claim about cmccann's claims.
18:36:33 <dolio> If you define 'type Num n = ...' you have to rewrite all Num instance declarations to be multiple instances of the constituents.
18:36:52 <cmccann> dolio, ahhh, ok
18:36:54 <cmccann> makes sense.
18:36:55 <zzo38> dolio: I have discussed that too, with someone else, on #esoteric channel, and we just decided it would work if an instance head is allowed to have (A x, B x, C x) like stuff.
18:37:07 <elliott> cmccann: Yes.
18:37:10 <elliott> cmccann: Has it ever not been?
18:37:20 <cmccann> elliott, well I wasn't aware
18:37:30 <zzo38> Maybe the best way is to discard Haskell entirely and make up an entirely new programming language, but some implementation might still compile into GHC Core?
18:37:32 <dolio> The alias instance is crucial for backward compatibility.
18:37:33 <cmccann> but then I rarely have occasion to be taking measurement of patience I suppose
18:37:36 <MostAwesomeDude> There's #esoteric? Wow.
18:37:40 <elliott> zzo38: Yes, I agree! You should create a channel for it.
18:37:47 <dolio> Because there are tons of Num instances in existence.
18:37:58 <elliott> MostAwesomeDude: It's about esolangs.
18:38:01 <dmwit> elliott: Nice try, but it won't work. He's a much better troll than that. ;-)
18:38:05 <elliott> Not the other kind of esoteric. (Many people get this wrong.)
18:38:17 <elliott> dmwit: Oh, he's not trolling.
18:38:25 <dmwit> That's what makes him so great.
18:38:42 <zzo38> dolio: I have suggested to combine with -XDefaultInstances to do combine with backward compatibility, but am unsure how you can use -XDefaultInstances with associated type synonyms it doesn't seems to work
18:39:08 <elliott> MostAwesomeDude: Alternate comedy response: Of course there is; you're in it!
18:39:11 <dolio> I don't think there's any way to do what I'm suggesting.
18:39:16 <dolio> It'd have to be implemented.
18:39:18 <zzo38> elliott: I can try to make up a channel but probably a lot of people hate it; I should try to write a document of a specification or something like that
18:39:50 <zzo38> (-XDefaultInstances is one of my proposed extensions too; but still that requires a new extension and will not work with existing GHC)
18:40:07 <Enigmagic> zzo38: you could write the compiler for the language too
18:40:43 <MostAwesomeDude> elliott: I figured it was about esoteric languages, I just didn't expect that there would be a Freenode channel dedicated to such a thing.
18:40:59 <zzo38> Is it possible to write a core-to-core plugin which allows GHC to read external core?
18:41:02 <MostAwesomeDude> Also, not using Haskell for everything doesn't make me a troll, does it? :c
18:41:27 <cmccann> well, you can use agda
18:41:29 <elliott> I don't think dmwit was referring to you.
18:41:41 <cmccann> though agda may just be an extremely sophisticated way to troll people, I'm not sure
18:41:54 <elliott> MostAwesomeDude: Well, esolangs don't really get discussed there all that frequently. But it's an active (and old) community.
18:41:58 <cmccann> I mean, mixfix? really?
18:42:14 <elliott> mixfix is inferior to coq notation
18:42:19 <elliott> :(
18:42:36 <MostAwesomeDude> elliott: Nifty. I like esoteric languages. They're not practical, but they are kinda fun.
18:43:47 <nand`> I like unlambda
18:44:06 <cmccann> nand`, heresy! lazy k is better.
18:44:09 <elliott> nand`: You might also like Lazy K, then. (http://esolangs.org/wiki/Lazy_K)
18:44:13 <elliott> cmccann: ^5
18:44:40 <hpaste> “Deepak Jois” pasted “diagrams-lib build” at http://hpaste.org/64260
18:46:05 <zzo38> Such as, we try to make something similar to a combination of Haskell, C, BLISS, TeX, WEB, Prolog, INTERCAL, and Magic: the Gathering; and then make it with many things omitted such as Unicode syntax, layout, do-notation, list comprehensions; and add in macros and stuff, and then make up something new......
18:46:59 <dmwit> ?remember zzo38 Such as, we try to make something similar to a combination of Haskell, C, BLISS, TeX, WEB, Prolog, INTERCAL, and Magic: the Gathering; and then  make it with many things omitted such as Unicode syntax, layout, do-notation, list comprehensions; and add in macros and stuff, and then make  up something new......
18:46:59 <lambdabot> Done.
18:47:17 <nand`> cmccann: elliott: I'll take a look, thanks!
18:47:38 <zzo38> And without centralized package management...... and allowing that many kinds of errors (including pattern match failure and so on) which will display error messages if the program is interpreted, but cause undefined behavior (like the LLVM "undef" and "unreachable") if compiled
18:47:44 <elliott> @type filterM
18:47:45 <cmccann> nand`, it's a lazy, purely functional language
18:47:45 <lambdabot> forall a (m :: * -> *). (Monad m) => (a -> m Bool) -> [a] -> m [a]
18:47:45 <nand`> oh nice, it's like unlambda but pure
18:48:12 <elliott> It uses lazy input though. :(
18:48:14 <cmccann> it even has clumsy stream-based IO, kinda like Haskell used to before IO :P
18:49:13 <cmccann> elliott, I still maintain that it's not terribly difficult to make something well-behaved on top of that :P
18:49:13 * hackagebot gnutls 0.1.1 - Bindings for GNU TLS  http://hackage.haskell.org/package/gnutls-0.1.1 (JohnMillikin)
18:49:27 <elliott> ofc it isn't, but it's badly-behaved in itself :P
18:49:27 <zzo38> Yes, Lazy K is lazy I/O which is not always work well. Another experiement is called Bruijndejx which is not implemeneted but has I/O action values instead, and requires use of DeBruijn index
18:49:36 <elliott> @hoogle (a -> m (Maybe b)) -> [a] -> [b] -- this is hopeless, isn't it
18:49:36 <lambdabot> Parse error:
18:49:36 <lambdabot>   (a -> m (Maybe b)) -> [a] -> [b] -- this is hopeless, isn't it
18:49:36 <lambdabot>                                    ^
18:49:42 <elliott> @hoogle (a -> m (Maybe b)) -> [a] -> [b]
18:49:42 <lambdabot> No results found
18:49:54 <elliott> @hoogle (a -> m (Maybe b)) -> [a] -> m [b]
18:49:54 <lambdabot> No results found
18:50:01 <cmccann> looking for an unfoldM?
18:50:20 * cmccann isn't sure what that type is supposed to be
18:50:25 <dmwit> ?hoogle (a -> m (Maybe (a,b))) -> [a] -> m [b]
18:50:26 <lambdabot> No results found
18:50:31 <elliott> cmccann: filterAndMapM
18:50:34 <cmccann> ah
18:50:39 <byorgey> Not in scope: `takeExtension' Perhaps you meant one of these: `FP.takeExtension' (imported from System.FilePath)  -- why, yes, that is what I meant!  Thanks GHC!
18:50:41 <dmwit> ah
18:50:51 <dmwit> byorgey: Isn't it great!
18:50:58 <mauke> :t liftM catMaybes . mapM ?f
18:50:59 <dmwit> I've been really pleased with GHC's suggestions.
18:50:59 <cmccann> byorgey, hadn't seen that before?
18:50:59 <elliott> byorgey: that error message comes up when you forget to define main
18:50:59 <lambdabot> forall a (m :: * -> *) a1. (Monad m, ?f::a1 -> m (Maybe a)) => [a1] -> m [a]
18:51:02 <elliott> GHC helpfully says:
18:51:04 * cmccann thought it had been doing that for a while
18:51:04 <elliott> did you mean `min'?
18:51:15 <cmccann> elliott, hahaha
18:51:24 <byorgey> I have seen it before, it just makes me happy so I thought I would share ;)
18:51:24 <dmwit> cmccann: byorgey just typos less than you!
18:51:25 <elliott> "why yes, let me go change all 0 references to 'main' in my program to 'min'"
18:51:35 <cmccann> dmwit, that's not hard to do
18:51:41 <byorgey> elliott: hehe
18:52:15 * byorgey never tyops
18:52:15 <cmccann> now if only it would drop ridiculous suggestions like "maybe you should write a Num instance for this thing that's clearly not a number"
18:52:33 <cmccann> I don't think I've ever gotten that "add an instance" suggestion for something that actually needed an instance
18:52:45 <byorgey> I think I did once
18:52:48 <cmccann> wow
18:52:52 <byorgey> I noted it at the time since it was so momentous
18:52:52 <rwbarton> cmccann: yeah
18:52:58 <cmccann> I would have done the same
18:53:04 <nyingen> why not change that behavior?
18:53:15 <rwbarton> I always want to tell people "Have you tried doing exactly what GHC's error message told you to do?" but then I remember that "No instance for Num String" error message.
18:53:34 <elliott> :t (<$)
18:53:35 <lambdabot> forall a (f :: * -> *) b. (Functor f) => a -> f b -> f a
18:54:48 <elliott> @hoogle m Bool -> a -> m (Maybe a)
18:54:48 <lambdabot> System.Timeout timeout :: Int -> IO a -> IO (Maybe a)
18:54:48 <lambdabot> Data.Functor (<$) :: Functor f => a -> f b -> f a
18:54:48 <lambdabot> Control.Applicative (<$) :: Functor f => a -> f b -> f a
18:54:51 <elliott> Didn't think so.
18:55:06 * elliott decides to just write his own loop instead
18:55:28 <dmwit> elliott: For bonus points, add it to
18:55:30 <dmwit> ?hackage monad-loops
18:55:31 <lambdabot> http://hackage.haskell.org/package/monad-loops
18:56:19 * cmccann really needs to purge some monad looping combinators from his prelude replacement and use monad-loops instead
18:57:16 <parcs`> there should be a community-run prelude, or something
18:57:27 <elliott> dmwit: it's ok, I ended up using mapM_ and the writer monad :P
18:57:48 <mauke> :t (liftM catMaybes .) . mapM
18:57:49 <lambdabot> forall a (m :: * -> *) a1. (Monad m) => (a1 -> m (Maybe a)) -> [a1] -> m [a]
18:58:27 <dmwit> parcs`: Upload a Prelude.Parcs to Hackage and get the ball rolling!
18:59:03 <elliott> aw come on, there's no (MonadRandom m) => [a] -> m a in MonadRandom
18:59:13 * hackagebot pandoc-types 1.9.1 - Types for representing a structured document  http://hackage.haskell.org/package/pandoc-types-1.9.1 (JohnMacFarlane)
18:59:35 <cmccann> dmwit, you mean get the ball stuck along with all the other alternate preludes people have written :P
19:00:02 <dmwit> elliott: fromList is almost there
19:00:16 <elliott> dmwit: ah, so it is
19:00:24 <elliott> getRandomR will probably waste less work for this, though
19:01:03 <dmwit> hard to imagine that's going to be your bottleneck
19:01:17 <elliott> well, I'll be doing this near-constantly... so it will actually
19:01:22 <elliott> which is a good reason to not use a list :P
19:01:33 <dmwit> I was about to say... =P
19:03:07 <elliott> ugh, "filter every (key, element) pair of this Map with a monadic predicate and then map them all and then pick a random element" is... really ugly to write
19:03:32 <zzo38> dmwit: Hay you! When you try to quote my message using ?remember then you have added an extra space by mistake!
19:03:54 <dmwit> ?forget zzo38 Such as, we try to make something similar to a combination of Haskell, C, BLISS, TeX, WEB, Prolog, INTERCAL, and Magic: the Gathering; and then  make it with many things omitted such as Unicode syntax, layout, do-notation, list comprehensions; and add in macros and stuff, and then make  up something new......
19:03:54 <lambdabot> Done.
19:04:14 <Jafet> @protontorpedo
19:04:14 <lambdabot> is there an oo db in haskell?
19:04:22 * elliott thinks dmwit just combined 100 of zzo38's messages to produce that.
19:04:25 <zzo38> There, now put it back on but without the extra space, if you want it on there at all
19:04:25 <dmwit> ?remember zzo38 Such as, we try to make something similar to a combination of Haskell, C, BLISS, TeX, WEB, Prolog, INTERCAL, and Magic: the Gathering; and then make it with many things omitted such as Unicode syntax, layout, do-notation, list comprehensions; and add in macros and stuff, and then make up something new......
19:04:25 <lambdabot> Done.
19:04:32 <zzo38> OK, that's better.
19:04:53 <scrutr> what are some of the ways in which you guys have used Haskell?
19:05:06 <bill```> what does ?remember do?
19:05:10 * cmccann mostly writes programs with it
19:05:16 <elliott> bill```: remembers
19:05:18 <zzo38> scrutr: A lot of ways in which we guys have used Haskell.
19:05:20 <dmwit> ?quote zzo38
19:05:20 <lambdabot> zzo38 says: Such as, we try to make something similar to a combination of Haskell, C, BLISS, TeX, WEB, Prolog, INTERCAL, and Magic: the Gathering; and then make it with many things omitted such as
19:05:20 <cmccann> @quote
19:05:20 <lambdabot> Unicode syntax, layout, do-notation, list comprehensions; and add in macros and stuff, and then make up something new......
19:05:20 <lambdabot> HaskellLove says: haha fuck yeah i am ninja... anyways... when someone asks u about monads ask him is he a programmer or a mathematician... to a programer u can explain it in 5 minutes, not tell him
19:05:20 <lambdabot> how complex it is so he goes studies a hole day and at night he says : wait why the fuck do i waste time, i will never use this
19:05:31 <dmwit> bill```: Now do you know what ?remember does? =)
19:05:33 <bill```> elliott: for use with @quote or for some other purpose?
19:05:43 <cmccann> just quotes
19:05:47 <elliott> That HaskellLove quote is not very good.
19:05:48 <bill```> ok gotcha
19:06:03 <cmccann> it's amusing but too long
19:06:34 * elliott wonders what the best structure for inserting into a bunch of times then picking a random element is
19:06:37 <elliott> probably Set, I guess
19:06:40 <scrutr> sorry for the vague question. I'm just looking for examples of some cool stuff. I remember a guy here showed me a chat room that was written with it
19:06:54 <scrutr> I also know lambdabot is written with it
19:06:57 <dmwit> scrutr: Have you looked at Hackage?
19:07:08 <elliott> scrutr: there's also xmonad and darcs
19:07:11 <scrutr> what's that?
19:07:38 <bill```> xmonad is the only window manager with a test suite ;)
19:07:39 <dmwit> ?where hackage
19:07:39 <lambdabot> <http://hackage.haskell.org/package/>, also see `revdeps'
19:08:23 * cmccann thinks wavewave needs a demo video for hxournal, it'd be a neat example to show people
19:08:49 <dmwit> cmccann: You know the rule...
19:08:53 <scrutr> ah...is that like PyPi then?
19:11:39 <elliott> ...except that Set would end up doing a lot of comparisons.
19:11:42 <elliott> Hmm.
19:11:59 <elliott> Oh, I could just use a list and accumulate the length. But that would still be O(n) access.
19:12:02 <bgamari> I just don't understand; Data.Vector claims it that dropWhile and span won't copy, yet this appears to be the source of my heap explosion
19:12:32 <bgamari> If only I had the slightest clue what spansPhotons.f.(...) was
19:12:33 <elliott> bgamari: They'll copy if you use force on them.
19:13:43 <bgamari> elliott: That means pretty much any attempt to index into them, eh?
19:14:00 <elliott> bgamari: No, I meant force.
19:14:03 <elliott> As in Data.Vector.force.
19:14:33 <bgamari> elliott: Alright, well I shouldn't be doing that
19:14:45 <Jafet> If it doesn't copy, then the source vector cannot be collected.
19:15:17 <bgamari> I really just want to create a bunch of views into the existing buffer
19:15:47 <elliott> Jafet: Yes, which it doesn't.
19:15:48 <bgamari> but I don't want the source vector to be collect; the compiler should be able to read my mind, damnit ;)
19:15:49 <elliott> That's what force is for.
19:16:46 <bgamari> So what else might induce a copy?
19:17:11 <bgamari> I guess I probably ought to come up with a smaller test case
19:17:45 <bgamari> returning the slice within a strict State monad wouldn't do this, would it?
19:18:34 <elliott> Data.Vector.force is unrelated to forcing thunks.
19:18:38 <bgamari> alright, good
19:18:49 <bgamari> so then I'm quite confused in that case
19:18:58 <bgamari> I know for a fact that I haven't used force anywhere
19:30:33 <wannabem1nadist> hi, im a non-math non-cs physics student here
19:30:57 <MostAwesomeDude> Howdy.
19:31:03 <wannabem1nadist> i was educated in india and have no formal training in CS
19:31:07 * shergill welcomes non-math non-cs physics student
19:31:29 <cmccann> you'd probably be surprised how many people here don't have any relevant formal training either
19:31:30 <wannabem1nadist> thanks
19:31:46 <bgamari> wannabem1nadist: Hello from another physics student
19:31:48 <wannabem1nadist> i want to get started to think interms of recursion
19:32:43 <wannabem1nadist> bgamari, Hi! I am a grad student in exp particle physics (phenomology side)
19:33:06 <dmwit> Recursion is a fun topic.
19:33:21 <elliott> wannabem1nadist: Haskell doesn't use explicit recursion all that much, though ;)
19:33:30 <cmccann> there are quite a few physicists around here I think
19:33:37 <dmwit> The easiest recursion to understand is structural recursion.
19:33:51 <dmwit> For numbers (a common input type), this is basically induction.
19:34:08 <dmwit> (You must have done *some* math, even if you're not a math person, right? Enough to see induction?)
19:34:13 * cmccann programs with magnetic induction all the time
19:34:23 * cmccann is not helping
19:34:30 <shergill> heh@ cmccann
19:34:32 <elliott> Structural recursion *is* induction! :p
19:35:25 <wannabem1nadist> I just worked thorough the workshop (Strange Loop 2011, Bryan Sullivan on Github)
19:35:40 <wannabem1nadist> my first intro to haskell, and it was pretty cool
19:36:05 <bgamari> wannabem1nadist: I'm in biological physics
19:36:13 <bgamari> wannabem1nadist: doing single molecule spectroscopy
19:36:30 <wannabem1nadist> it might be naive, but even constructing simple lists, and printing capitals non-iteratively fascinated me
19:37:18 <cmccann> naive or not, I think a lot of us started from an appreciation for simple elegance at that level
19:37:36 <wannabem1nadist> bgamari: cool! Do you use haskell for any group theory stuff?
19:38:42 <wannabem1nadist> before getting into the language (of which Ive accumulated some literature) I wanted to just learn to think more problems in recursive (perhaps functional?) terms
19:38:51 <bgamari> wannabem1nadist: My research doesn't take me too close to group theory but Haskell is well suited for reasoning about formal structures
19:39:14 * hackagebot structured-mongoDB 0.2 - Structured MongoDB interface  http://hackage.haskell.org/package/structured-mongoDB-0.2 (DeianStefan)
19:39:54 <dmwit> wannabem1nadist: My recommendation is to write some code and post it to codereview.stackexchange.com
19:39:58 <dmwit> It's a great resource.
19:40:27 <cmccann> also, I think getting into using Haskell is a fine way to get comfortable with the concepts
19:40:45 <cmccann> just make sure to keep them in mind, rather than always writing stuff in a way that seems familiar
19:42:10 <wannabem1nadist> is there a resource or collection of problems intended for recursive solutions
19:42:23 <dmwit> hm... maybe
19:42:28 <dmwit> ?google haskell 99 problems
19:42:30 <lambdabot> http://www.haskell.org/haskellwiki/99_questions
19:42:30 <lambdabot> Title: H-99: Ninety-Nine Haskell Problems - HaskellWiki
19:42:46 * cmccann grumbles again about needing to get some better problems/exercises/&c. written
19:42:55 <wannabem1nadist> Ill probably write them up in C++ then try to translate to Haskell
19:43:20 <elliott> that's the wrong thing to do if you want to get better at thinking recursively etc.
19:43:42 <ddarius_> HtDP, SICP
19:43:58 <wannabem1nadist> elliott: non-iteratively in C++, I meant
19:44:13 * cmccann felt that many of SICP's exercises had a lot of useless tedium
19:44:31 <elliott> wannabem1nadist: i stand by what i said, still
19:44:35 <cmccann> but then again I was already familiar with many of the concepts, at least somewhat
19:46:26 <zhzhxtrrk> want to write something in haskell, then just write it in haskell, don't translate anything, haskell and c++ are designed in very different way.
19:47:00 <cmccann> C++ was designed? :P
19:47:41 <ddarius_> My issue with SICP has more to do with the problems going beyond programming.
19:48:52 <ddarius_> This is enjoyable, but makes it potentially less useful as a resource.
19:51:43 <edwardk> preflex: xseen koninkje
19:51:43 <preflex>  koninkje was last seen on freenode/#haskell 8 days, 23 hours, 7 minutes and 13 seconds ago, saying: * koninkje wonders what APL used for map
19:54:17 <nyingen> @quote
19:54:18 <lambdabot> dancor says: once @pl produces ap, you usually decide not to pl it
19:55:49 <parcs`> :t let mapContT f m = ContT $ \k -> f (runContT m return) >>= k in mapContT
19:55:50 <lambdabot> forall (m :: * -> *) r (m1 :: * -> *) a r1. (Monad m1, Monad m) => (m r -> m1 a) -> ContT r m r -> ContT r1 m1 a
19:56:02 <parcs`> why isn't something like this in 'transformers'?
19:57:05 <parcs`> :t mapContT
19:57:05 <lambdabot> forall (m :: * -> *) r a. (m r -> m r) -> ContT r m a -> ContT r m a
19:57:13 <bgamari> elliott: Do you suppose you could look at a small snippet for me?
19:57:20 <parcs`> :t mapStateT
19:57:21 <lambdabot> forall (m :: * -> *) a s (n :: * -> *) b. (m (a, s) -> n (b, s)) -> StateT s m a -> StateT s n b
19:57:22 <magicman> The current DJ is Jick, who is on until Thu Feb 23 23:59 EST.
19:57:29 <wannabem1nadist> ok, I have really basic question. not about haskell, but about FP theory in general
19:57:43 <cmccann> magicman, wrong channel? :P
19:58:00 <parcs`> ContT is the only monad transformer in base whose map function can not change the underlying monad
19:58:40 <elliott> bgamari: sure... can't promise I'll be able to help :P
19:58:51 <hpaste> “Ben Gamari” pasted “Heap explosion” at http://hpaste.org/64261
19:58:57 <wannabem1nadist> i am working on an elementary personal project which kinda goes through documents and computes weights for certain keywords in for each user
19:59:04 <elliott> oh boy
19:59:28 <bgamari> elliott: It's probably not quite minimal
19:59:29 <elliott> hmm
19:59:35 <wannabem1nadist> this sounds inherently statistical and an iterative task
19:59:57 <bgamari> but commenting either of the prints at the end fixes the problem, which I suppose makes some sense
20:00:00 <tibbe> cmccann: I'm closer to a release of unordered-containers
20:00:04 <tibbe> might get one out this week
20:00:06 <elliott> bgamari: you sure mapM isn't the problem?
20:00:09 <wannabem1nadist> but on wikipedia I read that every iterative problem has a recursive solution
20:00:11 <elliott> it keeps the entire list in memory and so on
20:00:20 <cmccann> tibbe, nice, looking forward to it
20:00:51 <wannabem1nadist> how do haskellers generally deal with such traditionally numerical/iterative stuff
20:01:10 <cmccann> wannabem1nadist, that mostly sounds like a pretty simple map/fold sort of thing
20:01:28 <bgamari> elliott: the profiler claims the it's ARR_WORDS
20:01:50 <adnauseam> hmm, guys, how much memory does the lambda bot need ?
20:01:53 <elliott> bgamari: try using less pirate terminology in your program
20:01:59 <cmccann> :D
20:02:10 <bgamari> elliott: ;)
20:02:18 * cmccann suggests porting the program to use ninjas rather than pirates
20:02:19 <bgamari> second reference in one day
20:02:27 <lpsmith> wannabem1nadist, you can express iteration recursively.    In fact some people do make a distinction between iterative recursion and non-iterative recursion
20:02:29 <cmccann> they're faster, you see
20:02:45 <bgamari> and slimmer, more importantly
20:02:54 <rwbarton> bgamari, try using the non-strict State?
20:02:58 <bgamari> heft seems to be my issue recently
20:03:22 <bgamari> rwbarton: I'll admit that I haven't but that's changing
20:03:44 <bgamari> The claim has been made that forcing the thunk should cause a copy
20:03:51 <bgamari> and indeed, it seems it doesn't make a difference
20:04:21 <rwbarton> on further inspection, main retains the entire list of output anyways
20:04:49 <wannabem1nadist> One last question. Has anyone already implemented a recommender system on Haskell
20:04:54 <bgamari> rwbarton: yep
20:05:04 <elliott> bgamari: nobody has made that claim :(
20:05:10 <wannabem1nadist> not looking for the source or something,
20:05:10 <elliott> you just misinterpreted what I said by "force" :P
20:05:11 <bgamari> wannabem1nadist: I've done some machine learning
20:05:21 <bgamari> elliott: heh, point taken
20:05:55 <wannabem1nadist> bgamari: so its possible?
20:06:14 <elliott> @faq Can a recommender system be implemented in Haskell?
20:06:15 <lambdabot> The answer is: Yes! Haskell can do that.
20:06:21 <bgamari> wannabem1nadist: Of course; it does fairly well too
20:06:26 * cmccann applies 5N of force to bgamari's vectors
20:06:50 <rwbarton> bgamari: how much heap usage is this "explosion"?
20:06:53 <bgamari> Note that my vectors are gaseous; they expand to fill all available volume
20:06:58 <cmccann> hahaha
20:07:08 <bgamari> rwbarton: At least a few gigabytes
20:07:19 <rwbarton> hmm, that seems a bit overkill indeed
20:07:38 <bgamari> I got to 70% of my 8GB of physical memory before I killed it
20:07:43 <wannabem1nadist> Awesome. Now I have a goal and an end project. I will leave you guys and start with "Haskell road to math ... until I hit a snag.
20:07:59 <cmccann> wannabem1nadist, don't hesitate to ask when you do
20:08:15 <rwbarton> I can't really see how any evaluation strategy could use that much memory ever
20:08:15 <cmccann> asking questions on Stack Overflow is pretty effective as well
20:08:30 <monochrom> don't hesitate to denounce math :)
20:08:58 <elliott> bgamari: Maybe you should try using force.
20:09:08 <monochrom> and bgamari's vectors satisfy PV=nRT
20:09:14 <bgamari> wannabem1nadist: It's true; this is one of the more useful channels I've had the pleasure of punishing with my presence
20:09:20 <wannabem1nadist> cmccann: I do that, sometimes. The speed of quality solutions is amazing. SO made me realize how outdated earlier Q&A engiens were
20:09:45 <bgamari> elliott: Would make for an interesting experiment
20:10:25 <bgamari> Placing them after generate makes no difference
20:11:51 <bgamari> Nor before V.length in the map
20:11:54 <elliott> Maybe I should just build a vector in ST...
20:11:59 <elliott> (Not talking about your code.)
20:12:51 <bgamari> Nor does before V.fromList
20:13:46 <bgamari> I can replace mean with V.sum and there's also no difference
20:14:35 <bgamari> Could someone else try running the example?
20:14:40 <bgamari> Perhaps it's compiler dependent
20:19:31 <bgamari> damn, still happens on 7.0.2
20:20:24 <bgamari> Time to submit a bug report perhaps
20:22:17 <rwbarton> the only thing that I can imagine is that V.dropWhile or V.span is actually copying the vector, even though the documentation explicitly says that it doesn't
20:22:22 <elliott> bgamari: try and minimise the example some more
20:25:21 <bgamari> Alright
20:26:43 <rwbarton> the Hello stuff is apparently all irrelevant
20:26:56 <bgamari> rwbarton: Perhaps
20:32:51 <hpaste> “Ben Gamari” pasted “Heap explosion...reduced” at http://hpaste.org/64262
20:34:42 <bgamari> that should be a bit better
20:35:31 <elliott> bgamari: Does it happen with just span or just dropWhile?
20:35:45 <rwbarton> hmm
20:35:49 <rwbarton> "return $ V.force a" seems to fix it
20:35:58 <elliott> Ha, I knew it. :(
20:36:11 <rwbarton> which seems like a bug in vector
20:37:38 <rwbarton> ohhhh
20:37:41 <rwbarton> hmm
20:37:59 <rwbarton> oh never mind
20:38:30 <joe9> is there a library function that can take a list of [20, 30 ..50] and return a list of tuples as [(20,20), (20,30) .. (60,60)]
20:38:33 <joe9> [20, 30 ..50] should have been [20, 30 ..60]
20:38:45 <hpaste> “Ben Gamari” annotated “Heap explosion...reduced” with “Heap explosion...reduced (annotation)” at http://hpaste.org/64262#a64263
20:38:49 <bgamari> even further reduced
20:38:52 <rwbarton> I had some crazy monomorphism restriction-related theory but it didn't pan out
20:39:10 <bgamari> doesn't need state
20:39:23 <bgamari> and just dropWhile is sufficient
20:39:25 <joe9> source: http://codepad.org/zcDhsz9S error: http://codepad.org/czv7nZol
20:39:37 <joe9> I can get mapM (putStrLn . show) $ points range
20:39:41 <joe9> to work.
20:39:56 <dibblego> s/putStrLn . show/print -- fyi
20:39:56 <joe9> but, this does not work: http://codepad.org/5tlC5Cu1
20:40:24 <bgamari> takeWhile also seems to work
20:42:00 <joe9> dibblego: ok, thanks.
20:42:13 <cmccann> > join (liftA2 (,)) [20,30..60] -- joe9
20:42:14 <lambdabot>   [(20,20),(20,30),(20,40),(20,50),(20,60),(30,20),(30,30),(30,40),(30,50),(3...
20:42:15 <joe9> any thoughts on the error about "Not in scope: "range".
20:42:31 <joe9> cmccann: cool, thanks.
20:42:53 <tikhonjelvis> If you're going to use join, you should probably use liftM2, no?
20:42:55 <mauke> joe9: broken indentation
20:42:56 <bgamari> rwbarton: What do you suppose the probability of this being a bug is at this point?
20:42:58 <rwbarton> do RULES fire without -O?
20:43:17 <rwbarton> bgamari, I'm sure that at best it is a documentation bug
20:43:20 <joe9> mauke: thanks. that's it.
20:43:28 <cmccann> tikhonjelvis, if it's monomorphic anyway it hardly matters
20:43:37 <Eduard_Munteanu> rwbarton: I don't think so, unless some GHC 7.x changed that behavior.
20:44:05 <tikhonjelvis> Well, you would only have to use stuff from a single module, at the very least.
20:44:21 <bgamari> rwbarton: The bug occurs with -O as well
20:44:40 * cmccann always has both Control.Monad and Control.Applicative imported and forgets that they're not there by default...
20:44:45 <tikhonjelvis> ah
20:44:53 <tikhonjelvis> That's actually a good idea
20:44:53 <elliott> you weren't using -O?
20:44:55 <elliott> oh
20:45:05 <bgamari> It's pretty impressive how quickly it can chew through memory with -O2
20:45:17 <bgamari> fills 4GB in a few seconds
20:45:25 <rwbarton> bgamari, I guess technically it is not copying any data
20:45:34 <rwbarton> it just allocates much much more than it needs to, and doesn't free it
20:45:35 <cmccann> tikhonjelvis, and I tend to favor the Applicative forms over the equivalent Monad functions, but yeah mixing them like that is a bit silly
20:46:09 <tikhonjelvis> Of course, being pedantic about it is pretty silly too :)
20:46:10 <bgamari> rwbarton: evidence?
20:46:19 <rwbarton> just from what I know about the way Data.Vector works
20:46:28 <bgamari> ahh
20:46:48 <jgrimes> Hi, I am trying to find a way to create a zipper over multiple types. Specifically, I want to create a zipper for haskell-src-exts data… Everything I have seen only works for a single type..
20:46:55 <bgamari> alright, I've got to run
20:46:59 <bgamari> be back in 15 or so
20:47:15 <cmccann> tikhonjelvis, well, for something intended to be polymorphic it gives you both constraints
20:47:19 <cmccann> which clutters the type
20:47:31 <jgrimes> the transition functions should be like right :: Loc a -> Loc b
20:47:44 <cmccann> jgrimes, I seem to recall there being something on hackage to do that...
20:48:02 <cmccann> dealing with mutually recursive types and all
20:48:33 <jgrimes> hmmm
20:49:19 <jgrimes> cmccann: yeah looks like the "zipper" library is based on Generics.MultiRec
20:49:26 <jgrimes> I will take a look at that… thanks
20:49:44 <cmccann> can't promise anything, never used it myself
20:50:02 <bgamari_> Looks like IRC brings about yet another missed bus
20:51:56 <elliott> jgrimes: I think there's "pez" too.
20:52:36 <jgrimes> elliott: I briefly looked at pez, but I would need to create labels/lenses for everything… which would take quite a while I think
20:52:42 <jgrimes> elliott: thanks though :)
20:52:59 <elliott> yeah, but lenses also simplifies AST manipulation :P
20:53:03 <elliott> *simplify
20:53:04 <jgrimes> true
20:53:05 <elliott> you might also be interested in syb
20:53:10 <elliott> which works with haskell-src-exts
20:53:16 <elliott> (also, btw, fclabels has template haskell deriving)
20:53:27 <elliott> (so you'd only need to enumerate the types)
20:53:39 <jgrimes> yeah true
20:53:52 <jgrimes> I am using uniplate for some stuff… but it isn't quite what I was intending
20:53:57 <jgrimes> it is nice though
21:09:31 <bgamari> elliott, rwbarton: How does one go about debugging an issue in the libraries like this/
21:09:54 <bgamari> I have a ghc build
21:11:58 <elliott> emailing the maintainer :P
21:12:12 <rwbarton> yes... it is really more of a design issue, than a bug per se
21:13:42 <quintessence> What did the problem turn out to be in the end?
21:14:07 <bgamari> ouch, alright; I was afraid of that
21:14:23 <rwbarton> the short version is when it fills each of the bursts Vectors, it allocates space based on the upper bound it knows for the size of that vector
21:14:54 <rwbarton> which is going to be the length of the entire rest of ts
21:15:11 <quintessence> Ouch.
21:15:12 <rwbarton> or something like that
21:15:42 <rwbarton> I'm pretty sure your last example demonstrates convincingly that V.dropWhile fails to "not copy" its input
21:15:46 <rwbarton> though
21:17:09 <rwbarton> there the problem is that the bursts aren't sharing the same memory
21:17:37 <rwbarton> like they would if you wrote a similar program with ByteString
21:18:12 <rwbarton> the thing is that the Vector implementation of dropWhile is good for the stream fusion situation where you have a pipeline of operations
21:18:21 <quintessence> Yeah, I don't think dropWhile can participate in stream fusion and not copy
21:18:22 <rwbarton> but not good when you want to dropWhile many different times on the same input
21:18:30 <rwbarton> right
21:18:39 <quintessence> because when you have dropWhile p . map f the thing you want to share with doesn't exist
21:18:43 <rwbarton> so I don't know what the resolution would be
21:18:49 <bgamari> ouch
21:19:08 <rwbarton> besides giving some more manual control over stream fusion perhaps
21:20:10 <bgamari> Yep
21:20:51 <bgamari> That is a tricky one
21:21:08 <dmwit> dropWhileFusable + dropWhileCopy
21:21:13 <dmwit> err...
21:21:23 <dmwit> dropWhileFusable + dropWhileDoesn'tCopy, I guess
21:21:36 <quintessence> Could you implement dropWhile the non-fusing way and then have a RULE for dropWhile p . unstream = unstream . S.dropWhile p?
21:21:57 <rwbarton> at the least you could implement dropWhile' the non-fusing way; maybe that already exists somewhere in Data.Vector
21:22:03 <tibbe> Isn't there a function to explicitly copy? Like ByteString's clone?
21:22:07 <rwbarton> there is
21:22:13 <rwbarton> but the goal here is to not copy
21:22:23 <tibbe> I'm joining this discussion late I'm afraid :)
21:22:42 <tibbe> it should be possible to write rules that only fire when fusion doesn't happen
21:22:43 <rwbarton> the issue is a program like http://hpaste.org/64262#a64263 ends up allocating a bunch of nonoverlapping vectors
21:22:53 <tibbe> they could do sharing, but the performance model might turn out to be confusing
21:23:04 <rwbarton> when it could share them (and the documentation would have you believe it does)
21:23:38 <tibbe> how would you document dropWhile? Might share the underlying vector?
21:23:40 <bgamari> tibbe: the performance model is already a bit confusing ;)
21:23:47 <tibbe> :)
21:24:51 <bgamari> I'm surprised I'm the first person to encounter this
21:26:00 <bgamari> The bug report is http://hackage.haskell.org/trac/ghc/ticket/5893#comment:1
21:29:25 <bgamari> rwbarton, Do you mind if I quote you in a message to libraries@?
21:30:40 <rwbarton> sure, I think what I said before "I'm pretty sure your last example..." is irrelevant though
21:30:43 <rwbarton> so don't quote that part :)
21:30:59 <bgamari> heh, fair enough
21:31:00 <rwbarton> at least it is irrelevant to any example but your last
21:37:34 <edwardk> what is a nice fast way to select all subsets from a list of length n
21:38:26 * elliott starts to type a trivial solution, notices edwardk is the one asking, stops.
21:38:33 <dolio> Powerslice, then filter by length.
21:38:54 <edwardk> its not a hard problem, just want an elegant solution and its not my most pressing task ;)
21:39:23 * hackagebot attoparsec-conduit 0.2.0.1 - Turn attoparsec parsers into sinks.  http://hackage.haskell.org/package/attoparsec-conduit-0.2.0.1 (MichaelSnoyman)
21:39:25 * hackagebot blaze-builder-conduit 0.2.0.1 - Convert streams of builders to streams of bytestrings.  http://hackage.haskell.org/package/blaze-builder-conduit-0.2.0.1 (MichaelSnoyman)
21:39:27 * hackagebot filesystem-conduit 0.2.0.1 - Use system-filepath data types with conduits.  http://hackage.haskell.org/package/filesystem-conduit-0.2.0.1 (MichaelSnoyman)
21:39:35 <rwbarton> probably some trickery involving replicateM in the [] monad and tails
21:40:42 <rwbarton> or do I mean StateT [a] []
21:40:48 <Eduard_Munteanu> Sublists or subsets?
21:41:25 * rwbarton is unsure this is going to turn out more elegant than explicit recursion
21:43:59 <ClaudiusMaximus> oops, i seem to have accidentally the $ ghci
21:44:00 <ClaudiusMaximus> exec: 10: /home/claude/opt/lib/ghc-7.0.4/ghc: not found
21:44:29 * hackagebot network-conduit 0.2.1.2 - Stream socket data using conduits.  http://hackage.haskell.org/package/network-conduit-0.2.1.2 (MichaelSnoyman)
21:44:30 <ulfdoz> try hash -r
21:44:31 * hackagebot zlib-conduit 0.2.0.1 - Streaming compression/decompression via conduits.  http://hackage.haskell.org/package/zlib-conduit-0.2.0.1 (MichaelSnoyman)
21:44:59 <ClaudiusMaximus> ulfdoz: no, i remember i deleted some things in too much of a hurry when i filled my /
21:45:31 <ulfdoz> Then you probably really accidently the ghci.
22:08:19 <nyingen> @quote
22:08:20 <lambdabot> solrize says: some of the most recent type-system stuff was added to catch haskell up to c++ in generics capabilities
22:21:01 <Ralith> I wonder what that referred to
22:22:09 <lispy> Ralith: associated types?
22:23:02 <lispy> Ralith: because until we had them it was very hard to have a container type that could correctly think about what it contained
22:23:17 <lispy> (I'm just guessing though, I don't really know)
22:23:46 <lispy> ?quote
22:23:46 <lambdabot> (.) says: I am the boob operator!
22:24:14 <lispy> ?vixen oh really
22:24:15 <lambdabot> You have to face the fact that whole problem is really the blacks. The key is to divise a system that reconizes this while not appearing to...
22:26:03 <zzo38> Is this good so far?   http://sprunge.us/gXVh
22:26:26 <adnauseam> . /= means not equal ?
22:26:38 <zzo38> adnauseam: Yes, /= means not equal
22:26:38 <adnauseam> "/=" rather
22:26:38 <tikhonjelvis> yeah
22:26:46 <tikhonjelvis> It's like ≠, if you think about it.
22:27:08 <adnauseam> i keep confusing it with regex or imperatives
22:27:37 <adnauseam> i'll pull a list of haskell's equality operators
22:27:42 <adnauseam> and go through them
22:28:08 <zzo38> Do you know if there is anything with is both a indexed monad and a indexed comonad?
22:28:40 <tikhonjelvis> adnauseam: /= is the only mildly odd one, and it's only odd coming from C-like languages.
22:29:08 <adnauseam> yeah im used to !=
22:29:47 <adnauseam> what's ?= supposed to be ? ;p
22:29:47 <tikhonjelvis> I think /= makes more sense in a vaccum.
22:30:05 <adnauseam> in a vaccum?
22:30:19 <tikhonjelvis> In C, ! is logical negation, so != makes sense.
22:30:22 <Eduard_Munteanu> zzo38: dunno about indexed (co)monads in particular but IIRC edwardk blogged about things which are both monads and comonads.
22:30:31 <tikhonjelvis> But /= makes sense without knowing any of the other operators in the language.
22:30:37 <Eduard_Munteanu> There's also an article by Uustalu and Vene I think.
22:30:54 <adnauseam> i think it may have to do with sets
22:31:03 <adnauseam> since A/B means a without b
22:31:13 <tikhonjelvis> I think it's just the ASCII version of ≠.
22:31:22 <adnauseam> what should ? be ? o_0
22:31:29 <zzo38> Eduard_Munteanu: I do know of many things which is both monads and comonads, not only what edwardk write about. But when I figure out some index monad, index comonad, then they seem to be only one of them and not both
22:31:34 <tikhonjelvis> Oh, the "not equals" symbol from math.
22:31:38 <edwardk> The exponential comonad can be indexed, and has an indexed reader associated with it
22:31:41 <adnauseam> oh
22:31:41 <tikhonjelvis> You should use an IRC client that supports unicode.
22:31:48 <adnauseam> really ? o_0
22:31:54 <tikhonjelvis> yes
22:31:56 <adnauseam> i never knew that - and i'm 27
22:32:05 <adnauseam> =[
22:32:09 <zzo38> Eduard_Munteanu: As you can see, the program I wrote   http://sprunge.us/gXVh   I have defined some indexed monad and indexed comonad.
22:32:26 <tikhonjelvis> Emacs supports unicode.
22:32:27 <Eduard_Munteanu> adnauseam: that would be A \ B, rather
22:32:36 <adnauseam> oh, true - \
22:32:39 <Eduard_Munteanu> (or A - B)
22:32:59 <adnauseam> so / is not but also division, in haskell ?
22:33:07 <adnauseam> and ? is also not
22:33:09 <tikhonjelvis> No, it isn't not.
22:33:10 <zzo38> tikhonjelvis: Depending on the system, it might not be the IRC client's job to support unicode, it might be the terminal emulator's job.
22:33:18 <edwardk> one thing you may find instructive is to look at indexed "ComonadZip" instances, and looking at the way that the applicative-like structure works with indices
22:33:33 <tikhonjelvis> zzo38: Fair enough. You should use a *stack* that supports unicode :)
22:33:37 <edwardk> zzo38: that might explain to you what you are seeing where one doesn't want to manipulate the index and the other does
22:34:09 <tikhonjelvis> adnauseam: Not is just not. There is no operator for it because Haskell does not like unary operators.
22:34:24 * hackagebot LambdaPrettyQuote 0.0.0.7 - Quasiquoter, and Arbitrary helpers for the lambda calculus.  http://hackage.haskell.org/package/LambdaPrettyQuote-0.0.0.7 (JonathanFischoff)
22:34:44 <Eduard_Munteanu> zzo38: mm, doubly-indexed?
22:34:54 <adnauseam> i've got out of this more confused :p
22:35:01 <zzo38> edwardk: I do not completely understand you, can you show me a better example?
22:35:20 <zzo38> Eduard_Munteanu: What about doubly-indexed?
22:35:29 <tikhonjelvis> Do you know what not equal looks like in math? If you squint, that's what /= looks like.
22:35:44 <edwardk> not off hand. i take it that your intuition is that when you work with the indexed monad and an indexed comonad you can't have then work with the indices in a compatible way?
22:35:48 <adnauseam> yeah
22:35:51 <tikhonjelvis> I'm not sure where you got the question marks, but it's probably because of issues with displaying characters.
22:35:56 <zzo38> tikhonjelvis: If you put / and backspace and = such that it will overtype, then it might be.
22:35:57 <adnauseam> a = with a / IN the middle of it
22:36:33 <adnauseam> so it's more a visual representation
22:36:49 <tikhonjelvis> yeah
22:36:56 <adnauseam> does haskell use ?= ?
22:37:12 <tikhonjelvis> no
22:37:13 <zzo38> edwardk: Yes. If you see the file I wrote, it is seen that one is indexed and one is not indexed.
22:37:19 <Jafet> It's more a we-designed-this-language-before-Unicode
22:37:20 <adnauseam> considering someone earlier mentioned it - that confused me a bit
22:37:26 <tikhonjelvis> Or rather, not by default. Nothing stops you from defining ?= yourself.
22:37:33 <zzo38> And, is a category something like a indexed monoid?
22:37:33 <Eduard_Munteanu> zzo38: nevermind, I'm a bit rusty on that.
22:38:31 <edwardk> zzo38: yes, it is =)
22:38:43 <edwardk> zzo38: or conversely a monoid is a category with a single object
22:39:04 <Eduard_Munteanu> Hm, fun duality there.
22:39:08 <edwardk> zzo38: your results there mirror mine
22:39:31 <zzo38> edwardk: I only saw one thing you wrote that mentioned an indexed store comonad, although I have discovered an indexed store comonad independently (actually I once read about index monad, and then figured out that it can be make index comonad, too)
22:39:51 <edwardk> zzo38: i can hpaste a longer indexed monad/comonad file if i can dig it up
22:39:55 <edwardk> i just never put it on hackage
22:39:59 <zzo38> OK.
22:40:20 <zzo38> I might put this file I have, on Hackage, too
22:41:43 <edwardk> the version i built kind of deliberately clobbered the names from the prelude, which led to it being pretty ugly to use. (i was just using it to gain intuition for indexed store back when i was working with roconnor on pinning down 'seek' vs 'peek', etc.
22:42:01 * Eduard_Munteanu figures he should play with that stuff in Agda a bit sometime
22:43:27 <elliott> adnauseam: You are confused about "?".
22:43:40 <elliott> adnauseam: tikhonjelvis never said "?"; he said "≠".
22:43:40 <adnauseam> yeah  - not sure where it fits now
22:43:48 <elliott> Which looks like the =/= symbol you see in mathematics.
22:43:55 <elliott> If you see a "?" there, your IRC client is broken.
22:44:05 <elliott> Probably your terminal.
22:44:33 <adnauseam> oh
22:44:40 <adnauseam> that was unicode ?
22:44:44 <elliott> Yes.
22:44:45 <tikhonjelvis> The ≠ was, yeah
22:44:48 <adnauseam> that explains lots then ;p
22:44:51 <elliott> http://en.wikipedia.org/wiki/List_of_mathematical_symbols
22:44:53 <adnauseam> good old ascii here
22:44:56 <elliott> It's the second symbol on this page.
22:45:01 <elliott> Apparently not good enough.
22:45:19 <edwardk> @hpaste
22:45:19 <adnauseam> oi, be nice to my leet linux
22:45:19 <lambdabot> Haskell pastebin: http://hpaste.org/
22:45:21 <adnauseam> =[
22:45:40 <Eduard_Munteanu> adnauseam: it's not hard to get a unicode terminal and configure something like irssi to play ball.
22:45:44 <mauke> not very leet if it's still using ascii
22:45:49 <adnauseam> never had to use it :o
22:45:55 <hpaste> edwardk pasted “some old indexed monad/comonad junk” at http://hpaste.org/64265
22:45:59 <tikhonjelvis> adnauseam: Do you use Emacs?
22:46:03 <adnauseam> i use vim
22:46:08 * elliott suspects adnauseam is using PuTTY or something.
22:46:17 <elliott> Lots of people have problems with PuTTY and Unicode, in my experience.
22:46:31 <adnauseam> zsh in debian is not putty:|
22:46:42 <mauke> UTF-8 is from 1993
22:46:44 <mauke> time to upgrade
22:46:55 <tikhonjelvis> Hey, it's about as old as me!
22:47:07 <edwardk> zzo38: note the grumblings i have in there about the relation of the index from Apply with the way that ComonadApply/ComonadZip use the applicative structure, and the incompatibility of the indices
22:47:12 <tikhonjelvis> That probably does my already limited credibility no good.
22:47:17 <adnauseam> hrm, i wonder if i can load it without restarting the client
22:47:19 <mauke> adnauseam: you're not in zsh
22:47:28 <adnauseam> sigh - let me screen cap then
22:47:35 * adnauseam grumbles
22:47:42 <mauke> you're in irssi and possibly screen
22:47:47 <edwardk> zzo38: so I'm pretty sure we both have come to the same conclusion.
22:48:06 <adnauseam> what's wrong with that  ?
22:48:12 <mauke> nothing
22:48:21 <adnauseam> :p
22:48:26 <Eduard_Munteanu> adnauseam: /set term_charset utf-8    if that's irssi
22:48:47 <adnauseam> 07:47 term_charset = utf-8
22:48:52 <mauke> Eduard_Munteanu: it's probably better to fix it properly
22:48:53 <adnauseam> done :p
22:49:12 <elliott> ≠
22:49:21 <elliott> ☃
22:49:22 <tikhonjelvis> ?
22:49:24 <adnauseam> them be odd question marks
22:49:26 <bill```> √
22:49:38 <elliott> them be odd brokenness
22:49:58 <mauke> adnauseam: do you see a difference between ? and �
22:50:10 <Eduard_Munteanu> αδναυσηαµ
22:50:16 <adnauseam> let me consult my dear friend google about how do i go about resolving this abnormality =}
22:50:26 <bill```> using latin1 somewhere in your chain?
22:50:37 <zzo38> edwardk: Yes, I think so. In mathematics it is very common for different people to come to the same conclusion anyways
22:51:01 <mauke> Eduard_Munteanu: writing latin using a greek charset is illegal!
22:51:08 <Eduard_Munteanu> :)
22:51:32 <edwardk> zzo38: anyways the code in there for store kind of hints towards why in some sense, because the way the indices for the category get used is very different, the store builds towards the center, filling a 'gap', while the state spreads outward from the center
22:51:53 * Eduard_Munteanu goes to charset prison
22:52:07 <Jafet> llǝʞsɐH
22:52:30 <edwardk> I think if Jafet is going to a charset prison it'll be in Australia
22:52:41 <mauke> ¡ןןǝʞsɐɥ
22:53:18 <edwardk> I'm used to trying to post umop apisdn just using ascii ;)
22:53:41 <Eduard_Munteanu> Heh.
22:53:44 <mauke> ROT180
22:53:49 <edwardk> you whippersnappers and your fancy unicode ;)
22:53:50 <edwardk> hah
22:54:16 <zzo38> I usually prefer to not use unicode
22:54:20 <Jafet> ¿ɐılɐɹʇsn∀ ʇoN
22:54:48 <tikhonjelvis> The power unicode gives you is intoxicating.
22:55:20 <mauke> ˢᵘᵖᵉʳ ʰⁱᵍʰ
22:55:49 <bill```> an elegant weapon from a more civilized codepage
22:56:30 <edwardk> bill```: hah
22:56:48 * Eduard_Munteanu wonders if we should be using a latex renderer-enabled client :)
22:57:13 <edwardk> trying to figure out the right way to deal with n-dimensional moment generating functions for distributions in a way that i can use my AD package to calculate the derivatives
22:57:14 * adu <3 unicode
22:57:16 <Eduard_Munteanu> That way we can even make diagrams and whatnot :D
22:57:18 <edwardk> head hurts
22:57:31 <tikhonjelvis> And define macros for stuff like links to LYAH :)
22:58:59 <zzo38> The standard way to define arrows using arr and first, but I prefer *** and fanout, and making arr not part of that class because it is a different class a functor from (->) to another category.
22:59:20 <Eduard_Munteanu> \pagebreak
22:59:54 <Eduard_Munteanu> Or how to write a book in realtime :P
23:00:12 * Eduard_Munteanu thinks "Adventures in #haskell"
23:00:14 <edwardk> zzo38: you can get almost all of the benefit of Arrow from a CCC or similar construction, except sadly for the sugar ;)
23:00:56 <zzo38> I don't care about the syntax sugar for arrows; I don't like the syntax sugar for monads either.
23:01:53 <adnauseam> i'll be back in about 5 minutes - hope to then appease the gods of unicode, lest they plague me with more question marks
23:02:01 <zzo38> I like to use TeX a lot myself. And you can have interactive mode in TeX, too, in case you care
23:02:17 <zzo38> (I use interactive mode in TeX too sometimes)
23:02:32 <tikhonjelvis> Hmm, come to think of it, Emacs already supports inlining TeX equations. I wonder if I could easily add that to ERC...
23:02:59 <Eduard_Munteanu> tikhonjelvis: pidgin has a latex plugin
23:03:16 <zzo38> If you want a secure environment for TeX, see:  http://zzo38computer.cjb.net/texify/texify.php?source=3
23:03:21 <tikhonjelvis> But that would require leaving Emacs! It's unthinkable.
23:03:24 <Eduard_Munteanu> Though I don't use it for IRC.
23:03:57 <adnauseam> vim + vim-latex
23:04:01 <adnauseam> SUPERIOR RACE.
23:04:19 <zzo38> (In addition, I use Plain TeX instead of LaTeX.)
23:04:24 <zzo38> (I prefer Plain TeX)
23:04:27 <Eduard_Munteanu> adnauseam: does that actually render latex in, say, gvim?
23:04:33 <tikhonjelvis> I'm thinking of trying LuaTeX.
23:04:38 <Eduard_Munteanu> I've only used vim-latex for folding, though.
23:04:44 <adnauseam> hrm - i use evince
23:04:52 <Eduard_Munteanu> tikhonjelvis: that's nice.
23:05:03 <adnauseam> have command line in vim
23:05:12 <tikhonjelvis> adnauseam: The trick with AUCTeX is that it can preview equations right in the buffer.
23:05:15 <adnauseam> edit file - generate pdf - evince  macros
23:05:26 <Eduard_Munteanu> tikhonjelvis: I use it as some sort of xetex.
23:05:28 <adnauseam> pretty straight forward - and fast to work with for me - it really comes down to habbit
23:05:44 <adnauseam> ill try that :o haven't done latex in a while
23:05:48 <zzo38> Except for the stupid bug in MiKTeX in which \ifeof18 is not an error even though it should result in an error message.
23:05:48 <tikhonjelvis> Eduard_Munteanu: Do you like it?
23:05:52 <adnauseam> but brb now - fixing the encoding
23:06:14 <Eduard_Munteanu> tikhonjelvis: yeah, I can just type unicode for diacritics, no more messing with latin encodings or such
23:06:57 <zzo38> This is the HTML form to write a TeX code and render PNG:   http://zzo38computer.cjb.net/texify/texify.htm
23:07:35 <zzo38> adnauseam: I also think, PDF is full of stupid stuff, DVI is much better. I wrote (not quite finish yet) Haskell package for reading and writing DVI file.
23:07:48 <tikhonjelvis> You seem to have quite a lot of TeX stuff lying around.
23:08:31 <zzo38> If you have seen any Haskell packages I wrote, you can see the .lhs files are also TeX.
23:09:26 <zzo38> Although you need a file called "birdstyle.tex" which you might not have.
23:11:13 * Eduard_Munteanu also likes the biblatex stuff, better support for online citations, that sort of stuff.
23:11:30 <tikhonjelvis> In LuaTeX, you mean?
23:11:42 <Eduard_Munteanu> Mm, I don't think it's tied to luatex.
23:11:59 <tikhonjelvis> Oh, is it to do with XeTeX then?
23:12:30 <Eduard_Munteanu> Nah, it's just some newer alternative to bibtex.
23:12:34 <tikhonjelvis> oh
23:13:14 <tikhonjelvis> Well, I haven't had to write any papers yet, so I haven't needed to use bibtex.
23:18:38 <zzo38> This is a program I wrote in Haskell, for read/write DVI file, so that you can make Haskell program to do typesetting and to make printouts.   http://sprunge.us/dFDa   The applyMoveReg is not yet complete, but if you know how to write it better then you can suggestion.   The other thing I wanted to add, is another module which can deal with printer drivers so that you can printout too
23:19:16 <adnauseam> hit me with you unicode
23:19:35 <elliott> ☃
23:19:37 <elliott> ≠
23:19:45 <adnauseam> hah - excellent
23:19:46 <elliott> √
23:19:53 <adnauseam> that wasa strange head and inequality sign
23:19:58 <elliott> it was a snowman
23:20:03 <elliott> http://unicodesnowmanforyou.com/
23:20:10 <adnauseam> hah =D
23:20:26 <zzo38> Do you know how to improve the applyMoveReg function in my program?
23:20:59 <zzo38> Or even optimizePage if there is something wrong with that one too?
23:22:36 <mauke> Spin̈al Tap
23:23:10 <elliott> zzo38: you'd probably get better responses on http://codereview.stackexchange.com/
23:23:16 <elliott> or at least, more than zero responses :P
23:25:25 <zzo38> I think some people have told me before that they hate this program
23:28:51 <zzo38> Like, some people said it is impossible to read, and so on, but I think it is readable fine
23:29:57 <zzo38> Do you think it is difficult?
23:30:21 <JoeyA> I think it is difficult for someone not familiar with Haskell.
23:31:01 <JoeyA> And those >s look really noisy to me, but I'm not accustomed to working in Literate Haskell.
23:32:18 <JoeyA> (by the way, is there a tool that converts Literate Haskell into something much more beautiful to look at?)
23:32:26 <zzo38> JoeyA: Yes, TeX.
23:32:41 <JoeyA> Will it look like a boring white piece of a4paper?
23:32:54 <JoeyA> Or is there a template or whatever I can use to highlight the Haskell and whatnot?
23:34:02 <zzo38> Call this file <http://sprunge.us/MVhW> "birdstyle.tex" and then run tex on the other program to make the DVI output. And then pipe the DVI into the printer driver or whatever.
23:37:06 <zzo38> I don't know about template to highlight the Haskell and whatnot, but I do know how to write a AWK program to make it unliterate (in a simplified way):   sub(/^>/,"")
23:38:37 <zzo38> JoeyA: You can use other papers if you want to, I suppose, including colored papers in the printer if you don't like it to be white
23:39:46 <povman> how many people use yi?
23:39:50 <JoeyA> I played around with TeX once before, but don't know the basics of converting TeX to PDF and applying filters and such.
23:41:20 <povman> the yi blog seems to have died down
23:41:29 <povman> but i love and hate vim so much
23:41:49 <zzo38> You can use dvipdf or something if you want a PDF output, but I suggest just using DVI instead it is better. To compile a TeX into DVI, simply run tex, and type in the name of the file at the ** prompt
23:42:08 <quintessence> povman: use vim-mode in emacs, you can love and hate it even more
23:42:12 <zzo38> It is very simple to do like that.
23:44:35 <zzo38> JoeyA: Does this work?
23:44:47 <povman> quintessence: emacs makes me want to frag things
23:45:34 <zzo38> You can also do something like this:    tex document.tex; dvilj4 - < document.dvi | lp    to printout your file if you are on a UNIX system and have a PCL printer.
23:45:36 <Eduard_Munteanu> zzo38: mm, do you use plain TeX?
23:45:38 <quintessence> povman: yeah I was kidding, the thought of using vim-mode (much less vim itself) makes me shudder :P
23:45:46 <zzo38> Eduard_Munteanu: Yes.
23:46:13 <MaskRay> neocomplcache+syntastic+neco-ghc make vim suitable for haskell dev
23:46:59 <JoeyA> zzo38: Thanks.  Simply typing dvi.lhs at the tex prompt produces a PDF.  How do I include your birdstyle.tex file as well?
23:47:43 <JoeyA> zzo38: But to address your original question (asking if the code is hard to read): I'm not sure I like how shipOutCmd is crammed together.  Consider using do notation and indentation to make it look more imperative.
23:48:08 <zzo38> JoeyA: Simply include birdstyle.tex in the same directory or somewhere where TeX will find it. The file birdstyle.tex is not a printable document it is only a set of macros
23:48:23 <JoeyA> oh, okay
23:48:57 <DanBurton> @type asAppliedTo
23:48:57 <lambdabot> forall t b. (t -> b) -> t -> t -> b
23:49:17 <DanBurton> Does lambdabot have a function that behaves like "flip asAppliedTo"?
23:49:28 <elliott> Can you use infix asAppliedTo?
23:49:47 <ion> f `asTypeIn` \f -> f undefined x
23:49:59 <DanBurton> @type asTypeIn
23:49:59 <lambdabot> forall a b. a -> (a -> b) -> a
23:50:03 <DanBurton> ah thanks
23:50:13 <mekeor> @hoogle asAppliedTo
23:50:13 <lambdabot> No results found
23:50:16 <ion> f `asAppliedTo` x = f `asTypeIn` ($x)
23:50:35 <DanBurton> @type fmap `asAppliedTo` (undefined :: a -> b)
23:50:36 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
23:50:38 <mekeor> @src asTypeIn
23:50:38 <lambdabot> a `asTypeIn` f = a where _ = f a
23:50:38 <lambdabot> infixl 0 `asTypeIn`
23:50:52 <quintessence> zzo38: I would agree that that code is hard to read.  It would be improved a lot by appropriate newlines, indentation, and let/where bindings.
23:51:09 <ion> @type fmap `asTypeIn` \fmap -> fmap undefined (undefined :: a -> b)
23:51:10 <lambdabot> forall a b a1. (a -> b) -> (a1 -> a) -> a1 -> b
23:51:40 <ion> @type fmap `asTypeIn` \fmap -> fmap undefined undefined :: a -> b
23:51:41 <lambdabot>     Inferred type is less polymorphic than expected
23:51:41 <lambdabot>       Quantified type variable `b' is mentioned in the environment:
23:51:41 <lambdabot>         fmap :: (a1 -> b) -> (a -> a1) -> a -> b
23:52:07 <zzo38> JoeyA: Haskell is not imperative programming language it is functional programming
23:52:26 <zzo38> quintessence: OK. But I do have let/where bindings isn't it?
23:52:27 <ion> Haskell is an excellent imperative programming language.
23:52:29 <quintessence> zzo38: I would also suggest do-notation instead of jumping through hoops ("flip (uncurry $ flip . flip Page)") to use Applicatives, and using type synonyms or records instead of large tuple types.
23:52:36 <elliott> IO is not functional programming it is imperative programming language.
23:52:57 <zzo38> elliott: IO is not a programming language it is one of the types in Haskell.
23:53:03 <elliott> IO is an EDSL.
23:53:28 <Jafet> Haskell is an imperatively functional abstract enterprise programming language template
23:53:47 <povman> framework
23:53:54 <ion> cloud 2.0 factory
23:54:36 <mekeor> @remember Jafet Haskell is an imperatively functional abstract enterprise programming language template
23:54:36 <lambdabot> Okay.
23:54:43 <drdo> WebScale too
23:54:44 <zzo38> quintessence: A lot of people prefer do-notations, but I look at many program they seem to use do-notations far more than I think it ought to do so. (In addition, if I was writing a new program today, I would use "bool" function instead of "if...then...else" that is another feature I dislike in Haskell.)
23:55:06 <tikhonjelvis> You dislike if..then..else?
23:55:12 <mekeor> yes!
23:55:15 <ion> yes
23:55:15 <tikhonjelvis> Heh, me too.
23:55:20 <JoeyA> I don't like how if-then-else can't be partially applied conveniently.
23:55:21 * DanBurton also dislikes if/then/else
23:55:22 <mekeor> it should be a function…
23:55:23 <JoeyA> Same with case.
23:55:25 <tikhonjelvis> I thought I was in the minority though.
23:55:31 <povman> same with all of the haskell syntax
23:55:38 <JoeyA> Over and over I keep wanting lambda case
23:55:56 <JoeyA> readTVar node >>= case of {TNil -> ...; TCons x xs -> ...}
23:56:00 <DanBurton> if-then-else seems out of place when you can just use a case statement
23:56:01 <ion> povman: Meh, i like most of Haskell’s syntax much more than that of most other languages.
23:56:17 <tikhonjelvis> ion: That is faint praise indeed
23:56:18 <quintessence> JoeyA: that would be lovely
23:56:22 <Eduard_Munteanu> Yeah, especially considering if-then-else requires indenting.
23:56:29 <DanBurton> JoeyA++
23:56:29 <tikhonjelvis> DanBurton: Why use a Case statement when just a function would be even better?
23:56:32 <Eduard_Munteanu> I mean, case plays better there.
23:56:43 <JoeyA> Actually, case requires indenting.  if-then is more lenient in that regard.
23:56:50 <JoeyA> With if-then, you can say:
23:56:55 <povman> i've been using Factor, which is amazing, but which is lacking in features and readability
23:56:55 <JoeyA> exists <- ...
23:56:55 <DanBurton> tikhonjelvis: well yes, a function would be better, I agree.
23:56:56 <mekeor> JoeyA: what's lambda-case?
23:56:57 <JoeyA> if exists
23:56:59 <JoeyA>     then ...
23:57:01 <JoeyA>     else do
23:57:01 <zzo38> It has nothing to do with indenting; I made up "bool" function so that it can be partially applied. And nothing requires indenting if you use non-layout mode
23:57:04 <Eduard_Munteanu> Yeah, but I mean case indents more easily.
23:57:05 <JoeyA> exists <- ...
23:57:25 <ion> eduard_munteanu: AFAIR, Haskell 2010 removed the need for indenting then and else lines within a do block, which i find klugey.
23:57:26 <zzo38> And yes I want lambda-case too
23:57:29 <Eduard_Munteanu> You might as well use case ... of False -> .... etc.
23:57:50 <DanBurton> Occupy haskell.org! We demand lambda-case!
23:58:04 * DanBurton 's enthusiasm quicky dies >.>
23:58:15 <mekeor> ion: klugey?
23:58:27 <mekeor> DanBurton: what is lambda-case?!
23:58:28 <Eduard_Munteanu> Agda has pattern-matching multiple cases in lambda :P </spam>
23:58:28 <povman> i think he meant kludgey
23:58:31 <JoeyA> mekeor: case of {...} is \e -> case e of {...}
23:58:35 <elliott> there is a ghc ticket
23:58:38 <elliott> it is mired in syntactical arguments
23:58:41 <JoeyA> http://hackage.haskell.org/trac/ghc/ticket/4359
23:58:56 <ion> povman: http://catb.org/jargon/html/K/kluge.html
23:59:08 <Eduard_Munteanu> λ { True -> ...; False -> ... } :)
23:59:15 <zzo38> I dislike Agda's use of unicode
23:59:33 <povman> ion i apologise for never knowing the correct spelling
23:59:55 <Eduard_Munteanu> zzo38: it's pretty nice especially when you write mathy stuff
23:59:56 <elliott> http://en.wikipedia.org/wiki/Kludge
23:59:59 <ion> mekeor: It’s logical for additional then/else lines to be indented more than the “if” in the beginning.
