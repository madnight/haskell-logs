00:08:15 <covi> Hi all. If I do  'fibs = 0 : scanl (+) 1 fibs'  and take sth from fibs, will each item (besides from 0 and 1) be computed/generated for several times? Or because of Haskell's laziness, only once?
00:08:37 <shachaf> covi: The latter.
00:08:47 <shachaf> But note that this is in particular because of *laziness*, not just non-strictness.
00:10:24 <covi> shachaf: Where can I read about the laziness? In my opinion this is so smart.
00:10:57 <covi> (because sequentially thinking, that statement will be evaluated for several times and those elements will be generated for several times too)
00:11:02 <shachaf> @wiki laziness
00:11:03 <lambdabot> http://www.haskell.org/haskellwiki/laziness
00:11:14 <covi> ty
00:11:18 <shachaf> covi: Are you looking for an operational understanding?
00:11:49 <covi> shachaf: maybe. I kind of understand why the statement works, but I don't understand how it works
00:12:54 <shachaf> covi: Hmm.
00:40:46 <covi> Why finding the length in haskell is expensive? Why does not it store and maintain the length invisibly in the list?
00:41:36 <ion> How would you store the length in repeat 'a'?
00:41:38 <ion> > repeat 'a'
00:41:39 <lambdabot>   "aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa...
00:41:49 <shachaf> covi: Because how would it know?
00:42:12 <ion> There are implementations for collections of values for whom the length operation is O(1).
00:42:16 <shachaf> length (1:if longComputation then [2,3] else [2])
00:43:13 <tikhonjelvis> Also, since a lot of list code is recursive, you care about the length less than with for loops or the like.
00:43:34 <covi> I mean, when we wrote in C/C++, we usually stored the length of an array in array[0].
00:43:39 <Peaker> shachaf: I think he means dynamically
00:43:40 <ion> Lists may even be optimized away entirely.
00:43:43 <ion> Lists are not arrays.
00:43:45 <shachaf> covi: Linked lists are very different from arrays.
00:43:56 <shachaf> They are more similar to loops, in many ways.
00:44:08 <covi> shachaf: lists in haskell are linked lists?
00:44:11 <shachaf> (And they're a lot more similar to arrays in other ways, of course.)
00:44:13 <tikhonjelvis> yep
00:44:14 <Peaker> data LenList a = LenList { len :: Sum Int, list :: [a] }  deriving (Monoid)
00:44:35 <shachaf> covi: Yes. The definition is along the lines of data List a = Nil | Cons a (List a)
00:44:56 <covi> Men, haskell has a serious learning curve. I'd better go finish the last several chapters of lyah.
00:45:00 <shachaf> You can derive Monoid for a record like that?
00:45:28 <Peaker> covi: When used carefully, lists in Haskell can be "fused" away -- such that the remaining code is a tight/optimized loop
00:45:37 <Peaker> shachaf: at least if you use the "derive" package :)
00:46:01 <vodik> Peaker: deforestation?
00:46:31 <vodik> the fused away bit
00:46:58 <covi> Peaker: by optimized, do you mean its evaluation would be easy?
00:47:03 <covi> *lazy
00:47:11 <Peaker> vodik: yeah
00:47:45 <vodik> covi: no, that the intermediate structurs are stripped away, so to speak
00:47:50 <Peaker> covi: no no, I mean something like   sum [1..n]  may not generate any actual list structure in runtime, but use a simple loop (this case isn't "optimized" but it's just an example)
00:48:25 <covi> Peaker: I see... is this related to non-strictness of laziness?
00:48:31 <covi> vodik: yep
00:48:34 <Peaker> it will be compiled to something like:    go 1   where  go x | x > n = 0   | otherwise = x + go (x+1)
00:48:51 <Peaker> covi: Probably, I'm not sure
00:48:59 <covi> *or
00:49:08 <vodik> covi: not necessarily
00:49:09 <Peaker> and a recursive "go" function can be compiled to efficient low-level assembly
00:49:17 <tikhonjelvis> I don't see why fusing away a list would have to involve laziness.
00:49:17 <vodik> covi: its more about pureness
00:49:48 <covi> ok, thanks guys
00:51:22 <adnauseam> guys, what's wrong with length` xs = sum [1 |  _ <- xs ] ?
00:51:32 <ben> `
00:51:39 <adnauseam> oh, damn
00:51:45 <adnauseam> >.<
00:51:50 <adnauseam> thank you >.<
00:51:58 <ben> no problem :V
00:52:05 <Peaker> I have a design issue:  I have something like:   f :: [[SomeA]] -> [[SomeB]]      and I have a bunch of variables that I want to use "f" on to process them, but then do some further processing on them after "f" is done with them.
00:52:26 <Peaker> Pattern-matching them back out of the list is error-prone and means I error-pronely repeat their position in the list at least twice
00:52:56 <Peaker> so,  res = f [[x], [y,z]]      if I use:  [[x'], [y', z']] = res ...  I am exposed to partiality and violate DRY
00:53:20 <shachaf> Are you sure you want to use lists?
00:53:43 <Peaker> well, it's actually a Grid layout for a UI
00:54:06 <Peaker> so basically I want to feed the grid with a 2-dimensional set up of widgets, and get them laid out
00:54:22 <dzhus> what's up with hackage?
00:54:31 <Peaker> Hmm.. Maybe I can encode the 2d structure using some more elaborate data type
00:56:42 <Peaker> A nested-tuple type instead of a nested-list-type would work and get rid of the partiality, which is nice
00:56:57 <Peaker> but I'd still need to re-identify the elements in there
00:59:36 <mgsloan> use a set of lenses?
01:26:34 <yitz> dzhus: not much is up with hackage. it's down.
01:26:53 <yitz> @where hackagemirror
01:26:53 <lambdabot> http://hackage.factisresearch.com/package/monadacme
01:29:00 <alistra> way to have haddock ^
01:29:36 <shachaf> @where+ hackagemirror http://hackage.factisresearch.com/
01:29:36 <lambdabot> I will remember.
01:29:53 <yitz> shachaf: yes much better not sure why someone did it that way
01:30:48 <shachaf> To promote some joke package, I guess.
01:31:06 <shachaf> There is a time and a place for that sort of thing, and it's never and /dev/null, respectively.
01:32:06 <yitz> shachaf: that package is useful to see how cabal works. or, it was useful when it was created, when cabal was more primitive.
01:32:24 <yitz> shachaf: so it wasn't originally a joke (though it was done with humor).
01:32:38 <shachaf> Oh, I'm not objecting to the package, just to the hackagemirror entry.
01:32:49 <shachaf> And my objection is about as serious as the package.
01:32:58 <yitz> shachaf: ok agreed
01:33:04 <ion> Hackage is serious business.
01:33:13 <yitz> shachaf: it could also have been just a mistake
01:33:16 <dzhus> acme-now is cooler
01:33:19 <yitz> but anyway
01:33:38 <dzhus> http://hackage.factisresearch.com/package/acme-now
01:33:52 <yitz> ion: you only fully realize how serious its business is when it's down.
01:34:48 <shachaf> yitz: That sentence came to mind and I just wanted to say it. :-) I have no problem whatsoever with the fact that it was that way for a while.
01:35:18 * shachaf ought to go to sleep a few hours ago.
01:35:32 <yitz> shachaf: especially when hackage is down ;)
01:58:41 <Dybber> http://hackage.haskell.org seems down
01:59:00 <donri> @where hackagemirror
01:59:00 <lambdabot> http://hackage.factisresearch.com/
01:59:07 <Dybber> thanks
02:00:15 <Dybber> that mirror doesn't seem to generate documentation though
02:00:36 <donri> but you can configure cabal-install both to use the mirror and to generate docs
02:00:45 <donri> ~/.cabal/config
02:01:06 <Dybber> okay, will try that, thanks again
02:01:11 <Landarzar> heyas, is it possible that hackage is down?
02:01:22 <donri> Landarzar: see above
02:02:46 <donri> Dybber: also http://lambda.haskell.org/platform/doc/current/index.html
02:03:08 <mgsloan> (Landarzar only just joined, it is down, "donri: but you can configure cabal-install both to use the mirror and to generate docs"
02:03:24 <mgsloan> http://hackage.factisresearch.com/
02:04:01 <Landarzar> ah okay, thanks
02:12:41 <Peaker> Is there some stdlib list type parameterized by its length with safe operations?
02:13:02 <Peaker> HList = Hetero-list + type-level length.  I need just the type-level length
02:13:27 <ion> GList = Gay-list + type-level length
02:13:49 <Peaker> heh, I though of making a HomoList type :)
02:14:21 <Peaker> data ZeroL a = ZeroL  ;  data SuccL l a = SuccL a (l a)
02:15:01 <Peaker> class Head l where head :: l a -> a ;  instance Head (SuccL l) where head (SuccL h _) = h
02:15:18 <Peaker> for inductive functions, this leads to Flexible* extensions and OverlappingInstances too
02:15:23 <Peaker> (and probably worse)
02:16:08 <ion> instance Head (ZeroL a) where head _ = error "empty list"  -- ;-)
02:17:02 <Peaker> ion: NO! :-)
02:25:47 <mgsloan> abstract art created while debugging haskell type debugger!
02:25:49 <mgsloan> http://www.mgsloan.com/panoptiwink.png
02:26:02 <nicklovescode> I'm crying to install Gloss through cabal, but Hackage is down. Any way to do this?
02:26:55 <sdklfjsldkfj> is hackage down?
02:27:02 <mgsloan> it is down, "donri: but you can configure cabal-install both to use the mirror and to generate docs", the site is  http://hackage.factisresearch.com/
02:27:02 <nlogax> nicklovescode: see "from the darcs repo" http://gloss.ouroborus.net/
02:27:03 <adimit> yeah, it's been acting up lately.
02:31:16 <efie> C:\Users\X>cabal update Downloading the latest package list from hackage.haskell.org cabal: failed -- do you have the same problem?
02:32:39 <efie> oh sorry, i did not read the posts above
02:34:35 <vodik> sdklfjsldkfj: yes
02:40:15 <adimit> is there a mutable boxed *strict* array type? I can only find IOArray and STArray which are both non-strict.
02:40:15 <nicklovescode> got it, thanks
02:44:00 <MaskRay> STUArray IOUArray
02:44:36 <Jafet1> adimit: boxed strict?
02:45:02 <adimit> MaskRay: right, but I want to store Data.IntSets in these arrays, so I can't use the unboxed types seeing as there's no instance for that.
02:45:22 <Jafet> You can write an MArray instance that simply seqs all input.
02:45:40 <adimit> or maybe I could use an STUArray with Foreign.Ptr s to IntSets, but that sounds complicated.
02:46:10 <adimit> Jafet: sounds interesting. I will get the orphaned instance warning though, but there's no way around that ;-)
02:46:29 <adimit> I don't *need* it to be strict, I was mostly just curious.
02:47:16 <Jafet> Involving Foreign.Ptr sounds very, very risqué.
02:47:54 <adimit> Jafet: agreed. I do need performance, but not that badly. also, premature optimization and all that.
02:48:00 <MaskRay> adimit: I think there is no way since unboxed types correspond to `raw machine' types
02:48:11 <adimit> MaskRay: yeah, I figured.
02:48:35 <adimit> I think if I really do need the performance in the end, I'll have to bite the bullet and just implement that stuff in C
02:48:51 <Jafet> I doubt you will gain any performance, as the targets of stable pointers, for obvious reasons, cannot be relocated.
02:49:44 <mux> bah, hackage is down just when I was about to send an announce e-mail for the package I uploaded yesterday
02:50:01 <adimit> Jafet: yeah. let's hope it'll be enough :-)
02:50:14 <adimit> by it I mean IOArray.
02:50:57 <mux> hackage2 is up, but it seems it was last updated the 12th
02:56:25 <dcoutts> mux: there's a live mirror http://hackage.factisresearch.com/
02:56:25 <lambdabot> dcoutts: You have 1 new message. '/msg lambdabot @messages' to read it.
02:56:43 <mux> dcoutts: ah, cool, thanks!
02:56:51 <dcoutts> updates every 30 min
02:57:00 <mux> haha something is buggy with it though
02:57:25 <mux> my last upload appears in the what's new section, but my login became "mirrorer"
02:57:56 <mux> well that's okay
02:58:01 <dcoutts> mux: yes, for some reason the last uploaded package always shows the mirrorer account as the uploader
02:58:25 <dcoutts> though the mirror client does set the original date and user after uploading the .tar.gz
02:58:37 <dcoutts> so yes, a bug there somewhere
02:58:53 <mux> it's strange, since on the package page itself, the login is correct
02:58:58 <mux> anyways, not a big deal
02:59:17 <dcoutts> yes, only seems to affect the latest item in the "what's new" page
02:59:24 <dcoutts> not yet investigated
03:15:34 <mux> mmm, I hadn't realized the haddock docs were missing from this mirror
03:19:49 <ziouzitsou> can anyone connect to hackage.haskell.org/ ?
03:20:00 <adimit> ziouzitsou: no, it's down.
03:20:13 <ziouzitsou> forever? :)
03:20:23 <dcoutts> but there's a live mirror (hackage2 test server) at http://hackage.factisresearch.com/
03:20:24 <adimit> use the mirror at http://hackage.factisresearch.com
03:20:38 <adimit> ziouzitsou: I hope not forever :-)
03:21:05 <ziouzitsou> yeah me too
03:21:05 <dcoutts> ziouzitsou: but possibly until the admin gets into work on Monday morning (US west coast time)
03:21:07 <Landarzar> someone get http://hackage.factisresearch.com/ work with cabal? the indexfile or something is bad
03:21:10 <ziouzitsou> but i cannot find a pack
03:21:11 <ziouzitsou> :(
03:21:25 <Jafet> I wonder if webservers are written with forever $
03:21:57 <Landarzar> the indexfiles from http://hackage2.uptoisomorphism.net:8080/ work, but they have not alles packes
03:22:08 <Jafet> import Control.Monad (forever as indefinitely)
03:23:06 <dcoutts> Landarzar: yes works for me
03:23:09 <dcoutts> remote-repo: hackage.factisresearch.com:http://hackage.factisresearch.com/packages/
03:23:14 <adimit> Jafet: aw, you got my hopes up that I could actually use that (function as fun-name) syntax.
03:23:29 <adimit> which would've been hilarious in a way.
03:23:37 <everythingWorks> .
03:23:47 <dcoutts> Landarzar: set the right url on your ~/.cabal/config ?
03:23:52 <Landarzar> jap
03:23:55 <dcoutts> on/in
03:24:06 <stulli> Landarzar: cabal update and then tar -f 00-index.tar --delete bytestring/0.9.2.1 on the 00-index.tar file for the mirror. same with bytestring/0.9.2.0
03:24:24 <ziouzitsou> tsiou
03:24:38 <Landarzar> ah okay
03:24:40 <Landarzar> i try it
03:24:41 <stulli> Landarzar: http://stackoverflow.com/questions/9123607/cabal-cant-read-bytestring-cabal-file-with-ghc-7-4-1
03:25:31 <stulli> But it should be .cabal/packages/hackage.factisresearch.com/00-index.tar and not .cabal/packages/hackage.haskell.org/00-index.tar
03:28:56 <donri> remote-repo: hackage.factisresearch.com:http://hackage.factisresearch.com/packages/archive
03:28:58 <donri> ^ works for me
03:31:14 <Landarzar> now it works
03:31:15 <Landarzar> thanks
03:39:31 <tranma> > tails [1,2,3]
03:39:32 <lambdabot>   [[1,2,3],[2,3],[3],[]]
03:40:09 <tranma> :t sum . map read
03:40:10 <lambdabot> forall a. (Num a, Read a) => [String] -> a
03:45:34 <adimit> I want to fill an array with values from SQL via HDBC. Since I'm doing IO actions to get at the data anyway, it's probably better to use IOArray than STArray, no?
03:45:46 <osa1_> hackage is down, are there any other ways to see module documentations?
03:46:11 <mux> adimit: it's irrelevant; you could get your values through some action in the IO monad and yet not need to mutate them afterwards, so a plain Array could be just fine
03:47:05 <adimit> mux: the values are terribly many (millions) so I'd rather get them incrementally and mutate the array since I don't want to keep everything around in lists.
03:47:37 <mux> a value that you got through the IO monad cannot, in principle, escape from it, but you can still push non-monadic functions in the monad, so it doesn't mean you need to always use them via the IO monad afterwards
03:47:57 <mux> I was mentioning plain arrays, not lists
03:48:15 <mux> non-mutable arrays (and there is an unboxed UArray variant)
03:48:31 <mux> I think the vector package also has immutable arrays
03:48:36 <adimit> mux: HDBC gives everything back as lists. so that's why I'd prefer to shove the stuff into an array periodically to get rid of the overhead (also because I can perform some computations on them.)
03:49:12 <adimit> I can't go with unboxed arrays, since my values are IntSets.
03:49:21 <mux> adimit: well if it comes from a list, there's no escaping that, whether you push that list in a mutable or immutable array, it's the same
03:49:39 <mux> once again it's orthogonal to your array choice
03:49:39 <adimit> yeah, the key factor here being memory consumption.
03:50:14 <adimit> I want to get rid of the lists as soon as possible, so to speak. I've no idea if that makes sense, but wanted to try it :-)
03:50:22 <efife> any suggestions when hackage will work again?
03:50:49 <mux> adimit: I understand you want to do that, but keep in mind that the intermediary list might not even get actually created, if you're lucky (list/stream fusion)
03:51:24 <mux> also, laziness
03:51:47 <mux> so really, the question is whether or not you'll need to mutate elements
03:51:52 <adimit> I understand little about fusion, and I'm not usually lucky :-P I also must admit that my ability to reason about laziness is limited.
03:51:59 <adimit> well, if that's the question, then, no.
03:52:11 <adimit> well, sort of.
03:52:15 <mux> then don't use mutable arrays, by all means
03:52:32 <mux> use an immutable array from the vector package and see how it behaves
03:52:36 <adimit> the IntSets *need* to be modified
03:52:50 <mux> well you need mutation then :D
03:52:57 <adimit> yeah, that's what I figured :-D
03:53:11 <adimit> sorry, in the *end* I'll be able to freeze it.
03:53:36 <adimit> but during creation, the DB is going to spit out duplicate values for some of the array's indices (I'm making a reverse index of the DB.)
03:53:43 <mux> well then it's fine to use an immutable array, providing the modification you're making to the IntSet elements happens before you put it in the array
03:54:03 <mux> and that can be just fine if your code works in such a way that it'll process elements one at a time thanks ot laziness
03:54:41 <mux> if, for example, the way you modify the IntSet elements doesn't depend on the values of all other elements, which would force the whole thing into memory
03:54:47 <Saizan> 4
03:56:19 <adimit> I don't actually modify the values of the intset, I just insert stuff into the IntSet. But in that way every insertion into the IntSet depends on the previous 'state' of the IntSet.
03:56:34 <adimit> so I'm not sure if lazyness will work here.
03:58:00 <mux> it's hard to know that without knowing more about what your code does, but it doesn't impossible either
03:58:59 <adimit> mux: yeah, the code is complex, and I'd have to boil it down to something manageable to show it… :-\ But I think I shall be fine for now. Thanks for your help :-)
03:59:09 <mux> you're welcome
04:04:40 <rndm> my "cabal update" and "cabal install" time out. is that just me or is something down?
04:11:38 <Landarzar> rndm: hackage is offline
04:11:52 <Landarzar> http://hackage.factisresearch.com/packages/archive
04:13:23 <lpjhjdh> So I am trying to learn some category theory and show that the products "axb" and "bxa" are isomorphic, could anyone give a hint? I was thinking try to show they are both products of "axb" but am having a bit of trouble. Thanks.
04:14:51 <rndm> Landarzar: forever or temporarily?
04:14:52 <dschoepe> lpjhjdh: Define a morphism from A × B to B × A and one back and then show their compositions are the respective identity arrows.
04:15:02 <Landarzar> i hope temporary
04:15:30 <rndm> ah. i didn't know if you meant to suggest there was a new address
04:15:32 <rndm> thanks
04:21:09 <lpjhjdh> dschoepe: The product arrow <proj2, proj1> seems like it should work but I don't see how to prove an inverse (also <p2,p1> I think).
04:22:11 <hpc> i assume (×) in this example is (***)?
04:22:36 <hpc> @hoogle (a, b) -> (b, a)
04:22:36 <lambdabot> Data.Tuple swap :: (a, b) -> (b, a)
04:22:36 <lambdabot> Data.Graph.Inductive.Query.Monad (><) :: (a -> b) -> (c -> d) -> (a, c) -> (b, d)
04:22:36 <lambdabot> Data.Graph.Inductive.Query.Monad mapSnd :: (a -> b) -> (c, a) -> (c, b)
04:22:59 <hpc> > arr swap -- this would be your morphism both ways
04:23:00 <lambdabot>   Not in scope: `swap'
04:23:14 <hpc> well, it would if it was in scope :P
04:24:16 <lpjhjdh> I see why that works in a concrete example but I don't see how to prove it.
04:25:35 <hpc> (A × B) :: forall a b c d. (a, b) -> (c, d)
04:25:48 <hpc> (B × A) :: forall a b c d. (b, a) -> (d, c)
04:26:21 <hpc> arr swap . (B x A) . arr swap :: forall a b c d. (a, b) -> (c, d)
04:26:29 <hpc> parametricity does the rest
04:27:23 <hpc> arr swap . arr swap :: (a, b) -> (a, b) -- which is id
04:28:09 <lpjhjdh> I don't see why it needs to be the identity though?
04:28:56 <lpjhjdh> I do given swap in haskell but not the product arrow <proj2,proj1>
04:29:01 <hpc> lpjhjdh: because if you transform from one to the other and back again, you should have the same morphism you started with
04:36:56 <lpjhjdh> hpc: apologies, I don't see how to show this without a bit of hand waving. Could one not make a category with a strange protection function that permutes? Or would this not satisfy the two product laws?
04:41:56 <lpjhjdh> Projection*
04:42:20 <hpc> lpjhjdh: so like, if you had a set [1,2,3], your (f . g) would map to [2,3,1]?
04:46:34 <hpc> i suppose the cop-out explanation would be "f . finv = id is one of the requirements of being an isomorphism"
04:46:56 <lpjhjdh> Maybe in the category with two objects and one arrow f:a->b the product of a and b is a, so the protection from axb is f.
04:47:20 <lpjhjdh> Sorry am still thinking about your example.
04:47:51 <lpjhjdh> But the product arrow I my example is id so that actually works.
04:48:21 <thoradam> Is there any mirror for the haskell platform download? - http://hackage.haskell.org/platform/ seems to be down.
04:50:24 <hpc> lpjhjdh: a more informal explanation might be that if (f . finv) /= id, you aren't showing a relationship between the two objects
04:50:33 <hpc> or at least, not enough to say they are "structurally identical"
04:51:07 <hpc> if they are isomorphic, you should always be able to find the right f/finv to meet that condition
04:51:37 <hpc> even if, in the case of my example above, it requires repeated applications of your previous f/finv
04:52:18 <hpc> i don't know nearly enough to give a proper explanation of why that law is there
04:52:54 <lpjhjdh> I guess I still just don't see why <p2,p1>.<p2,p1>=id rather than any other function from axb->axb since the protection functions are so abstract.
04:53:49 <rwbarton> check that <p2,p1>.<p2,p1> and id are equal after composing with each of the projections from a x b
04:54:16 <rwbarton> after all, that's the only thing you really know to do with a map into a product
04:56:09 <lpjhjdh> Ah right. So since they are both product arrows of axb they must be equal by uniqueness of product arrows.
04:56:34 <rwbarton> right
04:57:29 <lpjhjdh> And every f and g have a product arrow <f,g>? Is that correct?
04:57:40 <ski> otherwise it's not a product
04:58:00 <lpjhjdh> Thanks again hpc and rwbarton for your patience and help!
05:00:00 <iDolfHatler> does anybody have an idea when hackage will be back? :(
05:09:10 <dcoutts> iDolfHatler: worst case, not 'til Monday morning US west coast time when the sysadmin gets in
05:14:32 <Dodek> hey, does hackage documentation work for you? it timeouts for me
05:15:21 <Ke> Dodek: I can't connect to hackage at all
05:15:44 <Dodek> Ke: oh, me neither.
05:16:42 <hpc> hackage was down last night too
05:18:31 <shepheb> how long has Hackage been down? any estimate on when it'll be back?
05:18:49 <byorgey> FIVE YEARS
05:19:04 <byorgey> subjectively speaking
05:19:21 <rostayob> shepheb: hackage has been going down pretty often recently... usually it comes up after a few hours
05:19:25 <byorgey> also, hi shepheb, seems like I haven't seen you around in a while =)
05:20:19 <shepheb> byorgey: :)
05:20:58 <shepheb> I've been lurking. bit busy for hacking on much of anything recently, but it's a long weekend in Canada and the US and I've got a project that's /that far/ from early beta.
05:21:22 <shepheb> is there anywhere else documentation might be hosted? or should I just be building it myself?
05:21:23 <byorgey> nice =)
05:22:03 <rostayob> shepheb: enable the documentation in .cabal/confi
05:22:20 <rostayob> that way you'll get haddock documentation for every package you install via cabal
06:01:01 <Rc43> Hi, guys.
06:01:10 <Rc43> I am again about graph problem.
06:01:49 <hpaste> Rc43 pasted “Components of Graph” at http://hpaste.org/63966
06:02:59 <Rc43> Why it takes about 200mb on test with 300 nodes where first 40 are connected in a sequence with edges (like 1 -> 2; 2 -< 3, etc)
06:03:03 <Rc43> &
06:03:05 <Rc43> ?
06:03:54 <Rc43> There is a set of other nodes it every node, but set cannot be > 300 elements => there are <= 300 * 300 elements
06:04:04 <Rc43> 90 000 integers cannot be 200 mb
06:04:54 <otters> nonsense, a 2.2KB integer sounds good to me
06:04:55 <Rc43> It should be about 260kb!
06:05:04 <Rc43> *360
06:05:13 <rwbarton> lolno.
06:05:25 <Rc43> int is 32 bit?
06:05:27 <rwbarton> How are you measuring this 200 mb exactly
06:05:34 <o1iver_> src/MDP/Types.hs:35:37: Could not deduce (ModifiableMDP a1) arising from a use of `stp'
06:05:37 <o1iver_>     from the context (ModifiableMDP a)
06:05:40 <o1iver_>       bound by the class declaration for `ModifiableMDP'
06:05:42 <o1iver_>       at src/MDP/Types.hs:(25,1)-(45,42)
06:05:45 <o1iver_>     Possible fix:
06:05:47 <o1iver_>       add (ModifiableMDP a1) to the context of
06:05:50 <rwbarton> stop
06:05:50 <o1iver_>         the type signature for
06:05:52 <o1iver_>           stp' :: a1 -> ((State, Action, State), Probability) -> a1
06:05:55 <o1iver_>         or the class declaration for `ModifiableMDP'
06:05:57 <o1iver_>     In the expression: stp m s a s' p
06:05:59 <otters> it's too late now
06:06:00 <o1iver_>     In an equation for `stp'': stp' m ((s, a, s'), p) = stp m s a s' p
06:06:03 <o1iver_>     In an equation for `stps':
06:06:05 <o1iver_>         stps m ps
06:06:08 <o1iver_>           = foldl stp' m ps
06:06:09 <Rc43> rwbarton, compiled with `ghc -prof -auto-all -O -rtsopts --make test.hs`
06:06:10 <o1iver_>           where
06:06:13 <o1iver_>               stp' :: a -> ((State, Action, State), Probability) -> a
06:06:15 <o1iver_>               stp' m ((s, a, s'), p) = stp m s a s' p
06:06:16 <rwbarton> Rc43, and then?
06:06:33 <Rc43> rwbarton, then  `./test.exe +RTS -p -RTS > /dev/null`
06:07:16 <Rc43> I can give you a test file. It is trivial to generate but takes time
06:07:19 <rwbarton> sure
06:08:04 <Botje> o1iver_: please don't paste.
06:08:16 <hpaste> Rc43 pasted “Components of Graph | Test” at http://hpaste.org/63968
06:08:32 <Rc43> rwbarton, ignore the number `90000`
06:08:32 <Wooga_> hello, i am solving one of LYAH problems, about Hethrow <-> London pathfinding. currently i boiled it down to a few sub-problems one of which (the most complicated one) contains getting all possible ways of walking down binary tree. i solved it. here is how: http://paste.pocoo.org/show/553422/ . but i am not sure if it is acceptable solution, things like 'map reverse .' alarming me on. is there a
06:08:38 <Wooga_> way to solve it better?
06:11:59 <Rc43> rwbarton, btw I have tried to use IORef to set instead of set, but in one way it increased memory, in other way it was the same. (GHC uses references to same objects inside, right?)
06:13:30 <rwbarton> are you talking about: "total alloc = 380,660,240 bytes"
06:13:53 <rwbarton> or whatever it is on your system, mine is 64-bit
06:14:27 <Rc43> rwbarton, mine is 64bit windows now
06:14:44 <Rc43> total alloc = 190,041,380 bytes
06:14:49 <rwbarton> well int isn't 32 bit on 64 bit systems
06:14:53 <rwbarton> btw
06:15:01 <rwbarton> at least, not on linux, perhaps it is on windows
06:15:09 <mux> it depends on the system  but most of the time it isn't
06:15:35 <Rc43> on 64bit it is 64
06:15:50 <Wooga_> on x86_64 it is, whatever OS you use
06:15:52 <rwbarton> this isn't really that relevant anyways but I just thought I'd mention it
06:16:01 <mux> Wooga_: no
06:16:22 <Wooga_> really? all *X registers would be 64-bit anyways
06:16:32 <rwbarton> (and by "int" I meant GHC's Int of course)
06:16:52 <mux> Wooga_: the size of int has nothing to do with the size of registers
06:17:07 <mux> the vast majority of 64-bit systems don't have 64-bit ints
06:17:17 <Wooga_> interesting
06:17:25 <Wooga_> and strange
06:17:28 <mux> not strange
06:17:37 <Wooga_> still generatign ASM code, it doesn't use it fully?
06:17:49 <Wooga_> and how it calculating sizes for example?
06:17:57 <mux> the misconception that sizeof(int) somehow is the same as the architecture word size is dead wrong since decades
06:18:02 <rwbarton> on x86_64 if you have a C program with 32-bit ints, it will just use eax/ecx/etc.
06:18:37 <mux> Wooga_: there is no problems in calculating sizes, at least, there is no more problems than when you use 16-bit ints on a 32-bit system; same thing
06:18:54 <rwbarton> the question is for example, how much memory does "int x[N]" use
06:18:55 <tensorpudding_> you still get eax and co on 64-bit, and your 64-bit code might still use them
06:19:37 <Rc43> rwbarton, have you any ideas about such memory wasting?
06:19:44 <Wooga_> yeah, that you use only AX doesn't mean whole EAX isn't being used
06:19:54 <Wooga_> same thing for EAX <-> RAX
06:20:09 <Rc43> rwbarton, can it be not collected garbage?
06:20:58 <rwbarton> Rc43, I notice your program never inspects the IntMap IntSet until it tries to print its size
06:21:49 <rwbarton> so I think you are building up an enormous chain of thunks
06:22:51 <Rc43> rwbarton, the goal is to find all connected components of graph, I can't output map before the whole graph is traversed.
06:23:25 <rwbarton> you can force the map while you build it though
06:23:31 <Rc43> How?
06:23:41 <Rc43> BangPatterns?
06:23:45 <rwbarton> same difference as foldl (+) 0 [1..10000] vs. foldl' (+) 0 [1..10000]
06:24:47 <rwbarton> I find this program pretty hard to understand what with all these functions that always return Just something
06:24:53 <rwbarton> so let me fix that first
06:26:37 <Rc43> rwbarton, Just something is returned by bytestring parsing functions, it was fastest way to use them in IO monad.
06:26:58 <rwbarton> no, it's really unnecessary :P
06:27:26 <yitz> o1iver_: please do paste, but never here. use hpaste please.
06:27:26 <yitz> @hpaste
06:27:27 <lambdabot> Haskell pastebin: http://hpaste.org/
06:28:07 <Rc43> rwbarton, hackage is down =/
06:28:24 <Rc43> wanted to look at foldl and foldl' sources
06:28:38 <yitz> @where hackagemirror
06:28:38 <lambdabot> http://hackage.factisresearch.com/
06:28:45 <hpaste> rwbarton annotated “Components of Graph” with “simplify” at http://hpaste.org/63966#a63969
06:29:16 <yitz> @src foldl
06:29:16 <lambdabot> foldl f z []     = z
06:29:17 <lambdabot> foldl f z (x:xs) = foldl f (f z x) xs
06:29:22 <yitz> @src foldl'
06:29:22 <lambdabot> foldl' f a []     = a
06:29:22 <lambdabot> foldl' f a (x:xs) = let a' = f a x in a' `seq` foldl' f a' xs
06:30:21 <Rc43> yitz, thanks
06:31:47 <Rc43> rwbarton, you have edited only main and trim?
06:32:10 <Rc43> ohh. I have diff on windows
06:37:16 <Rc43> it is really better, thanks
06:38:30 <ccasin> hi folks - cabal update is timing out... is it just me or does everyone have the problem?
06:38:32 <rwbarton> runs really fast here with -A400M
06:38:54 <rwbarton> since it allocates slightly under 400 megabytes of memory total :)
06:39:09 <dcoutts> ccasin: hackage.h.o server seems to be down again, there's an up to date mirror at http://hackage.factisresearch.com/
06:39:17 <Rc43> rwbarton, it is flag for ghc or RTS?
06:39:21 <dcoutts> ccasin: (the test hackage 2 server)
06:39:24 <ccasin> dcoutts: thanks
06:39:30 <rwbarton> RTS flag
06:39:43 <rwbarton> tells it to allocate 400M for the heap up initially
06:40:14 <Rc43> I don't see difference
06:40:34 <dcoutts> rwbarton: -H sets the heap size, -A is the "nursery" area size
06:40:42 <rwbarton> oh
06:40:52 <rwbarton> I don't really understand the garbage collector
06:41:13 <dcoutts> rwbarton: using a really large -A value often does not help, the default -A value is designed to fit in the L2 cache
06:41:41 <o1iver_> Botje, yitz : sorry... god damn right mouse click ... wasnt even trying to do anything!
06:41:48 <rwbarton> in this case almost all the data it allocates is actually long-lived so -A400M eliminated all the GC
06:42:01 <dcoutts> rwbarton: -H, -M and -A are the common ones: -H and -M are initial and max heap size.
06:42:16 <rwbarton> Rc43: oh, I'm compiling without -prof -auto-all
06:42:33 <dcoutts> rwbarton: see if you get a similar effect with -H 400M
06:42:54 <dcoutts> sorry, -H400M, without the space
06:43:07 <rwbarton> -H400M has no visible effect over no GC options
06:43:29 <dcoutts> rwbarton: iirc, dons wrote some GC tuning script, to plot prog runtime with varying -H and -A
06:44:58 <rwbarton> the nursery is basically where it allocates new objects, then when it's filled the GC copies them elsewhere?
06:45:21 <rwbarton> it'd be really helpful if I could get a snapshot of heap usage at a particular time in my program
06:45:39 <dcoutts> rwbarton: you can, using heap profiling
06:45:51 <rwbarton> so I have the heap profiling graph
06:46:06 <rwbarton> but I don't want to guess what times in the graph correspond to which points in the execution of my program
06:46:34 <rwbarton> is there a way to get heap profiling data aside from the graph?
06:46:41 <dcoutts> rwbarton: ah yes, I hope we'll be able to do that nicely in ThreadScope
06:46:51 <dcoutts> but that feature is not ready yet
06:46:53 <rwbarton> okay
06:47:12 <Rc43> rwbarton, is `let result = mapWithKey update components in seq result result` what I need to add? It's do nothing.
06:47:22 <rwbarton> that will do nothing
06:47:25 <rwbarton> seq x x always does nothing
06:47:36 <dcoutts> we're adding allocation info to the eventlog, so we'll be able to see it in ThreadScope, and you can also emit custom events, so you can match up points in program evaluation
06:47:52 <rwbarton> yeah, if I could trigger a sample and then match it up with the .hp file that would be perfect
06:48:26 <Rc43> rwbarton, it mustn't evaluate x and then return calculated x? Like in foldl'.
06:49:01 <rwbarton> "seq x x" means -- when you evaluate "seq x x", first evaluate x and then return x
06:49:04 <rwbarton> this is also what "x" means
06:49:09 <rwbarton> so seq x x = x
06:49:52 <dcoutts> rwbarton: mm, and the heap profile does not show real time, but only mutator time
06:50:20 <dcoutts> which is usually a helpful thing, but not if you want to match up events
06:50:26 <Rc43> rwbarton, so where is additional effect in foldl' definition?
06:50:28 <Rc43> @src foldl'
06:50:29 <lambdabot> foldl' f a []     = a
06:50:29 <lambdabot> foldl' f a (x:xs) = let a' = f a x in a' `seq` foldl' f a' xs
06:50:42 <Rc43> I have thought that it is because of let .. seq using
06:50:46 <otters> how can I partition a list into a list of lists each of which has n elements?
06:50:56 <Rc43> ooh
06:51:06 <Rc43> I missed `in a'`
06:51:10 <otters> like partition 2 [1,2,3,4,5,6] -> [[1,2],[3,4],[5,6]]
06:51:14 <Rc43> silly =/
06:52:02 <Rc43> hm
06:52:05 <Rc43> but no
06:52:24 <Rc43> it is the same what i thought firstly, where is effect?
06:52:43 <rwbarton> a' is not foldl' f a' xs
06:52:53 <Rc43> but it is evaluated
06:53:08 <rwbarton> so when "a' `seq` foldl' f a' xs" is evaluated, a' will be evaluated before being passed to foldl' f
06:53:30 <Rc43> ah, ok
06:53:38 <rwbarton> in foldl f a xs, it's possible that f never examines a at all
06:53:53 <rwbarton> er
06:54:10 <rwbarton> even if it does, nothing is examining the accumulator until foldl returns
06:54:31 <rwbarton> I think your problem is actually with mapWithKey
06:56:11 <rwbarton> here is a dumb workaround
06:56:51 <rwbarton> the thing is that you are sticking thunks into the map that are never evaluated, when you want to be storing evaluated IntSets
06:57:19 <hpaste> rwbarton annotated “Components of Graph” with “mapWithKey” at http://hpaste.org/63966#a63970
06:57:32 <rwbarton> really you want a mapWithKey' but it doesn't seem to exist
06:59:42 <rwbarton> that reduced the maximum residency from 232 MB to a more reasonable 2 MB
06:59:42 <Rc43> rwbarton, thunks, roughly saying, are references to arguments, right? let x in x `seq` f x will reduce x or not? If yes, why can't I just place it into my `merge` function?
06:59:53 <Rc43> rwbarton, will look now
06:59:54 <rwbarton> "place it"?
07:00:01 <rwbarton> how? where?
07:00:13 <rwbarton> a thunk represents some computation that you haven't done yet
07:00:55 <rwbarton> x `seq` f x will reduce x to WHNF before evaluating f x
07:01:37 <rwbarton> but if x is an IntMap, say, reducing x to WHNF won't evaluate the values in the IntMap
07:01:49 <Rc43> rwbarton, understood
07:01:56 <rwbarton> best is to make sure the values are evaluated before you insert them
07:02:07 <hpc> IntMap is spine-strict, so it would always be in whnf anyway, i think
07:02:55 <Saizan> hpc: nope, it only means that if you try to get it into WHNF you'll also force the rest of the spine
07:03:01 <hpc> ah
07:03:05 <hpc> oh right, dur
07:03:40 <Saizan> and that still doesn't affect the values stored
07:03:41 <Rc43> rwbarton, your fix reduces memory using to 2mb?
07:03:48 <rwbarton> it does here
07:04:01 <rwbarton> it also makes the program slower even though it is doing half as much GC now :P
07:04:02 <Rc43> rwbarton, for me it increases memory to 280mb (from 190)
07:04:21 <Rc43> rwbarton, and yes, it makes program slower from 0.5 to 1.80 sec
07:04:33 <rwbarton> what number are you looking at
07:04:51 <Rc43> rwbarton ?
07:04:59 <rwbarton> this 280 mb number
07:05:01 <hpc> is that 280mb total allocated, or peak use?
07:05:04 <rwbarton> exactly what is it
07:05:07 <rwbarton> where do you see it
07:05:12 <Rc43> total allocated, yes
07:05:22 <rwbarton> total allocated means the total allocated, ever
07:05:26 <hpc> total allocated isn't a significant number
07:05:34 <rwbarton> it's normal and healthy for Haskell programs to allocate a lot of memory
07:05:45 <hpc> a long-running haskell program could allocate petabytes of memory
07:05:58 <Rc43> rwbarton, ok, so it is not max usage?
07:06:08 <rwbarton> what's not so normal is for it to be using 200+ MB at the same time to store a bunch of sets with 90000 elements total
07:06:08 <Rc43> Can I get max usage?
07:06:11 <rwbarton> correct
07:06:14 <rwbarton> +RTS -sstderr
07:06:24 <rwbarton> and look for "232,780,328 bytes maximum residency (9 sample(s))"
07:08:16 <Rc43> total memory = heap + residency?
07:08:35 <Rc43> 280 + 190 for not optimized solution for me also
07:08:59 <rwbarton> what
07:09:16 <Yrogirg> cabal is down?
07:09:24 <hpc> Yrogirg: hackage.haskell.org is down
07:09:36 <Yrogirg> oh, that's what I meant
07:09:42 <hpc> been down since last night
07:09:50 <rwbarton> Rc43: I don't know what you mean by "total memory". you have to be a lot more specific
07:09:51 <Rc43> my first solution gives 350mb total memory, and you gives 6 mb
07:10:05 <Rc43> rwbarton, it is line in output
07:10:12 <rwbarton> preferably copy and paste the exact output line
07:10:14 <dcoutts> Yrogirg, hpc: but there's a live mirror (hackage2 test server) at http://hackage.factisresearch.com/
07:10:19 <Rc43> rwbarton, X mb total memory in use
07:10:50 <rwbarton> okay, that I think is something like the total virtual memory size of the process
07:11:05 <Yrogirg> dcolish, how do I make cabal use it?
07:11:13 <Rc43> @src ($!)
07:11:13 <lambdabot> f $! x = x `seq` f x
07:11:13 <dcoutts> remote-repo: hackage.factisresearch.com:http://hackage.factisresearch.com/packages/
07:11:18 <rwbarton> or at least, the total size of that part of the process's memory which is being used to store the heap
07:11:40 <Rc43> rwbarton, why we need to wrap it into Maybe?
07:11:48 <mike-burns> This Hackage2 switchover happened more quickly than I had expected!
07:11:56 <Rc43> rwbarton, just for wrapping?
07:12:10 <dcoutts> Yrogirg: ^^ in your ~/.cabal/config. Or alternatively you can just install direct from a http url, but that doesn't give dep chasing
07:12:19 <rwbarton> the reason this works is that mapMaybeWithKey has to actually evaluate the function you pass in on the element in the map, to find out whether it's going to return Nothing or Just something
07:12:57 <hpc> or download direct from http, then run "cabal install" inside that directory
07:13:06 <rwbarton> and by returning Just $! something, we can force "something" to be evaluated at this time
07:13:16 <hpc> wait, that would check haskell.org, nvm
07:13:40 <Rc43> rwbarton, its cool, thanks
07:13:51 <rwbarton> it would be better if there was just a mapWithKey' that evaluated the value before returning the new IntMap
07:14:14 <rwbarton> btw it's a bit pointless to use an IntMap at all if you are only ever going to use mapWithKey on it... you can just use an array
07:14:31 <rwbarton> since mapWithKey has to rebuild the entire IntMap from scratch every time
07:14:54 <Rc43> rwbarton, really, forgot to change from arlier solutions
07:16:10 <Yrogirg> I've switched to the mirror but now
07:16:10 <Yrogirg> cabal: Couldn't read cabal file "bytestring/0.9.2.0/bytestring.cabal"
07:17:09 <ill_logic> Hey all, got a silly Monad I'm making just to learn how to make Monads. Wondering why it's not quite working as I expect. http://pastebin.com/XXPa4t8J
07:17:11 <mauke> The paste XXPa4t8J has been copied to http://hpaste.org/63972
07:17:36 <Yrogirg> when the original hackage will come back?
07:17:42 <dcoutts> Yrogirg: ah, we hacked it for the main server so it'd not upset older cabal-install versions
07:17:47 <ill_logic> hmm, there was no error when I compiled it locally.
07:18:00 <dcoutts> Yrogirg: at latest, Monday morning US west coast time
07:18:11 <dcoutts> when the sysadmin gets in
07:18:25 <Yrogirg> k
07:18:58 <hpc> ill_logic: you can rewrite xx as
07:19:05 <ill_logic> So I expected it to decrement every time, which it does for xx, but not x
07:19:10 <hpc> xx = foo >>= \a ->
07:19:18 <hpc>      bar >>= \a ->
07:19:19 <rwbarton> ill_logic: LimitLength is not actually a monad
07:19:24 <hpc>      etc
07:19:32 <hpc> also that
07:19:41 <ill_logic> it violates the laws or something?
07:19:47 <rwbarton> yes
07:20:26 <ill_logic> I take it that if there were a way to enforce the laws, it would be in ghc by now?
07:21:14 <rwbarton> welllllll
07:21:39 <dcoutts> ill_logic: if there were an *easy* way, yes :-)
07:21:48 <rwbarton> you can enforce the laws in a language like agda, haskell is not well suited to doing that though
07:22:24 <hpc> enforcing the laws in haskell would require solving the halting problem
07:22:31 <rwbarton> not really
07:22:35 <dcoutts> right, either need a more sophisticated type system, or a theorem checker and programmer-supplied proofs
07:22:41 <rwbarton> you just require the programmer to prove the laws
07:23:09 <ill_logic> Assuming we're all here because we love sophisticated type checkers, why don't we all flock to something like Agda? Is it because we love them but we don't love them THAT much? haha
07:23:09 <awgn> He can write a simple polymorphic test to check there the laws hold, doesn't he?
07:23:17 <rwbarton> enforcing the laws automatically and without rejecting any correct programs would require solving the halting problem
07:23:36 <awgn> s/there/wheter/
07:23:45 <Taneb> What advantages do STRefs hold over IORefs?
07:23:57 <hpc> Taneb: STRefs are references in ST
07:24:05 <dcoutts> Taneb: better question is what is the point of the ST monad, compared to IO
07:24:06 <hpc> ST is basically "IO without the I or the O"
07:24:20 <hpc> :t runST
07:24:21 <lambdabot> forall a. (forall s. ST s a) -> a
07:24:48 <Taneb> So, it's possible to get things out of the ST?
07:24:54 <hpc> yes
07:24:55 <rwbarton> ill_logic: you (the programmer) have to do a lot of work in a language like agda, currently, to convince the compiler that you have satisfied the laws.
07:24:55 <dcoutts> ill_logic: it's a balance between practicality and being able to enforce more properties
07:25:23 <hpc> Taneb: you can't get STRefs out of ST though, due to some type-level magic
07:25:24 <Philippa> also, Agda doesn't behave itself as nicely as it could on 'doze
07:25:32 <Rc43> Is there a fucntion `a -> (a -> b) -> (a,b)` ?
07:25:37 <hpc> it enforces that ST behaves like any other haskell on the outside
07:25:37 <Philippa> (an actual problem for me, to the point where I'll probably set up a VM just for Agda)
07:25:37 <ill_logic> Any case, if it's not too offensive to y'all, I want to figure out why this do notation doesn't work the way I expect before I try to figure out how to make it a proper Monad
07:25:47 <hpc> @djinn a -> (a -> b) -> (a,b)
07:25:47 <lambdabot> f a b = (a, b a)
07:26:02 <ill_logic> I'll start with trying to understand hpc's rewrite
07:26:06 <dcoutts> ill_logic: Agda is probably in the situation Haskell was 15-20 years ago in terms of practicality. It'll get better.
07:26:15 <rwbarton> ill_logic, it's because it groups the statements the other way
07:26:41 <Philippa> dcoutts: hmm. It may be missing its equivalent of monads outright, even. But yeah, close enough I guess :-)
07:27:01 <rwbarton> ill_logic: like LimitLength 5 5 >>= (\a -> ...)
07:27:18 <rwbarton> not (...) >>= \a -> LimitLength 1000 a --- if that helps
07:27:30 <dcoutts> Taneb: ST lets you use mutable state locally, so the overall result is pure. The purity is enforced by the types.
07:27:32 <hpc> :t (<*>)
07:27:33 <lambdabot> forall (f :: * -> *) a b. (Applicative f) => f (a -> b) -> f a -> f b
07:27:48 <hpc> > (f <*> g) x
07:27:48 <lambdabot>   Ambiguous type variable `a' in the constraints:
07:27:49 <lambdabot>    `SimpleReflect.FromExpr ...
07:27:52 <hpc> > (f <*> g) x :: Expr
07:27:53 <lambdabot>   Ambiguous type variable `a' in the constraints:
07:27:53 <lambdabot>    `SimpleReflect.FromExpr ...
07:27:54 <dcoutts> Taneb: both individual mutable vars (STRef) and mutable arrays (ST[U]Array)
07:27:57 <hpc> > (f <*> g) x y :: Expr
07:27:58 <lambdabot>   Ambiguous type variable `a' in the constraints:
07:27:58 <lambdabot>    `SimpleReflect.FromExpr ...
07:28:01 <hpc> pah
07:28:12 <hpc> @src (->) <*>
07:28:12 <lambdabot> Source not found. And you call yourself a Rocket Scientist!
07:28:17 <hpc> @src (->) (<*>)
07:28:17 <lambdabot> (<*>) f g x = f x (g x)
07:28:28 <rndm> Rocket Surgeon
07:28:39 <ill_logic> rwbarton: I know it's probably really simple, I just need a minute to process it
07:28:51 <ahmadia> dcoutts: what's the fix for the byestring problem?
07:29:07 <hpc> :t let f a b = (,) <*> b $ a in f -- Rc43
07:29:08 <lambdabot> forall a a1. a -> (a -> a1) -> (a, a1)
07:29:23 <hpc> Rc43: but i would go with what djinn said above
07:29:23 <dcoutts> ahmadia: either use new cabal-install, hack the index file or wait for main hackage to come back up
07:29:23 <ahmadia> dcoutts: I'm googling, do I need to untar, modify something in the 00-index.tar, and retar?
07:29:40 <ahmadia> dcoutts: which do you recommend if I don't feel like waiting? :)
07:29:52 <dcoutts> ahmadia: yes, there's a workaround like that in a SO answer, google should find it
07:29:53 <rwbarton> I wonder whether you can even make (r ->) into a monad in agda without setoid stuff
07:29:56 <Taneb> Hmm
07:29:56 <Taneb> Thanks, guys
07:29:59 <rndm> so (noob question) what's the deal with the quantifiers? lambdabot seems to give quantifiers that aren't required in ghc.
07:30:16 <hpc> rndm: lambdabot has a few extensions turned on
07:30:24 <hpc> one of them makes forall required
07:30:28 <dcoutts> Taneb: ST is actually pretty amazing. There's a paper introducing it if you're interested.
07:30:38 <Taneb> dcoutts, link?
07:30:42 <hpc> er, makes forall significant, and it affects the :t output
07:31:23 <hpc> rndm: RankNTypes i think
07:31:52 <rndm> hpc: i see. what's a case where the quantifiers are restricted?
07:32:22 <dcoutts> Taneb: http://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.50.3299
07:32:31 <hpc> rndm: restricted?
07:32:34 <Taneb> Thanks
07:33:12 <jhance> How come Hackage is down? I don't have local docs :(
07:33:20 <rndm> hpc: is it always of the form "forall a" where a ranges over the entire universe of discourse?
07:33:29 <byorgey> jhance: to spite you
07:33:38 <jhance> byorgey: That's not very nice of it....
07:33:40 <hpc> rndm: oh
07:33:41 <hpc> :t 5
07:33:42 <lambdabot> forall t. (Num t) => t
07:34:02 <rndm> ah, cool.
07:34:17 <hpc> it's just type classes :P
07:34:28 <byorgey> actually, I think Hackage is throwing a hissy fit because it can tell that we are going to replace it with Hackage 2 soon.
07:34:29 <rwbarton> you have different kinds
07:34:36 <rwbarton> :t return 5
07:34:37 <lambdabot> forall t (m :: * -> *). (Num t, Monad m) => m t
07:34:59 <rndm> yeah i was going to ask if it was restricted over class membership but i was struggling with how to phrase that
07:35:18 <rndm> what is * -> * ?
07:35:29 <labo> is there a Hackage mirror somewhere?
07:35:43 <hpc> rndm: it's the kind of things that take one type as a parameter
07:35:43 <rwbarton> you could view  "forall t. (Num t) => t"  as either quantified over t which are Num or quantified over all t with the type "(Num t) => t"
07:35:48 <labo> I have been googling, but I haven't found any
07:35:53 <hpc> rndm: like [], Maybe, (Either Int), etc
07:36:20 <alpounet> @where hackagemirror
07:36:21 <lambdabot> http://hackage.factisresearch.com/
07:36:24 <alpounet> labo, ^
07:36:37 <alpounet> it isn't up-to-date but still better than nothing
07:36:43 <labo> alpounet: thanks :)
07:37:39 <rndm> hpc: thanks.
07:38:06 <ill_logic> rwbarton: hpc: just to be clear, is this xx rewrite equivalent to my xx but easier to read, or does it change what xx means to make it more akin to my x ?
07:38:30 <hpc> ill_logic: just makes it easier to read
07:38:31 <rndm> rwbarton: the first seems more natural, what does it mean to be quantified over all t with type "(Num t) => t"?
07:38:35 <hpc> all you should change is indentation
07:38:55 <rwbarton> hpc's rewrite of xx changed it
07:39:05 <rwbarton> into what is actually the translation of x
07:39:25 <hpc> rwbarton: kind of; xx has extra lines
07:39:38 <rwbarton> yeah xx and x are a bit different anyways
07:39:56 <ill_logic> they have different values, that's what I'm trying to figure out
07:39:57 <ahmadia> here's the bytestring fix (took some googling) http://www.haskell.org/pipermail/haskell-cafe/2011-August/094883.html
07:39:58 <rwbarton> rndm: It's a little unclear
07:40:08 <hpc> but yeah, once you change it, you are seeing exactly how do-notation is translated
07:40:22 <rwbarton> but ghc certainly accepts such types...
07:40:30 <rwbarton> :t undefined :: (Num t => t) -> t
07:40:31 <lambdabot> forall t. ((Num t) => t) -> t
07:41:02 <ill_logic> ok thanks. that's what confused me. I thought you were giving me the same thing as before and I couldn't see how it was the same.
07:41:07 <rwbarton> you can try to think of (Num t) => t as -- if I give you a value of type (Num t) => t that means that I promise that *if* t turns out to be an instance of Num then I will give you a t
07:41:13 <hpc> rwbarton: gah, that's one awkwardly placed constraint
07:41:47 <rndm> rwbarton: and if t does not?
07:41:53 <rwbarton> Then I don't have to give you anything.
07:42:27 <rwbarton> in other words, it is like a function, whose input type is that of evidence that t is in the Num type class
07:42:37 <rwbarton> GHC doesn't really handle these types very well.
07:43:42 <rndm> rwbarton: thanks for the insight
07:45:29 <ill_logic> ok thanks hpc rwbarton now I see it working the same way. I will look into it for a bit from here, thanks a lot
07:45:32 <Rc43> rwbarton, array instead intmap imroved time from 1.8s to 0.8s and memory from 8mb to 4mb
07:48:38 <Rc43> rwbarton, but it is still huge, for 90000 edges (all to all) time is 8 sec and memory 21 mb.
07:53:06 <Rc43> What means `non-strict` array?
07:55:29 <Rc43> And what means `boxed` arrays?
07:56:10 <q0tw4> boxed array is array of pointers to haskell values
07:59:00 <Rc43> q0tw4, whiich difference for programmer?
07:59:42 <dzhus> yay she's up!! hackage is up!!
07:59:58 <q0tw4> memory, speed, using in C code
08:00:42 <Rc43> q0tw4, boxed are faster? Equal values are shared?
08:02:02 <q0tw4> unboxed is fater for simple types
08:02:05 <sipa> Rc43: boxed means values are stored the way you expect in more low-level languages
08:02:18 <sipa> compared to creating a thunk that may be unevaluated
08:04:04 <Landarzar> whoohay, hackage is up again
08:04:54 <Rc43> sipa, aah, so boxed doesn't storage unevaluated values?
08:05:06 <q0tw4> it is better to keep just Double than pointer to Double and Double
08:07:43 <efie> do i have to be in a specific directory to run hlint? it says it does not know the command "hlint"
08:08:01 <alpounet> efie, is ~/.cabal/bin in your PATH ?
08:08:22 <alpounet> (assuming you installed hlint by doing "cabal install hlint")
08:10:40 <Rc43> btw, what can I do with GC? It takes too much time (30 sec for GC and 7 sec for program)
08:10:56 <Rc43> I have only 2 second for my programs
08:11:24 <efie> alpounet: yes i installed hlint that way. do you mean C:\Program Files\Haskell\bin? then yes; does there have to be a cabal folder? i am using windows
08:12:46 <ChristianS> efie: cabal tells you where it puts binaries when it installs them; you have to add that dir to your path. (don't ask me how to do that on windows.)
08:15:32 <czro> anyone having problems running the preprocessor on haskell sources after upgrading to xcode 4.3?
08:16:28 * hackagebot mathblog 0.3 - A program for creating and managing a static  weblog with LaTeX math and function graphs  http://hackage.haskell.org/package/mathblog-0.3 (JonathanDaugherty)
08:16:55 <q0tw4> Haskell can't process a lot of numbers effectivelly without supercomiller. It is good for controlling dataflow
08:17:05 <alpounet> efie, on windows cabal's path is like in %AppData%/.cabal
08:17:06 <alpounet> smth like that
08:17:18 <nand`> %appdata%/cabal iirc
08:17:36 <efie> aplpunet: oh yes, i see it: "Installing executable(s) in C:\Users\X\AppData\Roaming\cabal\bin" so i should add this to my path?
08:18:01 <alpounet> here
08:18:03 <alpounet> yes
08:19:20 <efie> um the same error still occur
08:19:21 <efie> s
08:22:33 <czro> I'm getting alot of "warning: missing terminating ' character" after upgrading to Xcode 4.3. I guess It's something with the preprocessor. Anyone else experiencing this? (ghc 7.4.1)
08:22:45 <efie> alpounet: do you maybe have further suggestions?
08:27:35 <alpounet> efie, when you do: echo %PATH%
08:27:37 <alpounet> in cmd
08:27:40 <alpounet> does it appear ?
08:29:20 <efie> alpounet: no it does not
09:35:07 <alpounet> then I guess something went wrong when you added it to the PATH env variable
09:35:16 <efie> ok, thanks
09:35:28 <alpounet> i don't know windows that well, maybe you have to restart the session or smth
09:35:55 <q0tw4> cmd must be restarted
09:35:57 <efie> however it works when go via the cmd directy to the cabal\bin folder and type hlint.exe "source"
09:36:39 <alpounet> ofc it does
09:36:48 <efie> q0tw4: ah thanks,yes, now it is displayed
09:36:56 <alpounet> great! here you go efie heh
09:37:02 <efie> :)
09:38:35 <Ajdare> Bet and Win with us : http://bet-tips.cogia.net/?ref=285
09:47:24 <nand`> What's the easiest way to go to the definition of a (local) haskell function using vim?
09:48:46 <ddarius> There are tools to generate tag files.  I would just search with * though.
09:49:30 <scooty-puff> is it possible to handle permutations of tokens with happy?
09:56:20 <Rmx> mm_freak_ : you were right to say netwire is hard! Any tip to understand it better ? I can't understand all the part in the same time, and solving the puzzle mentally after having read the so many parts of the "construction" is too hard for me for now.
09:56:44 <Rmx> I feel like I should understand it better
09:57:49 <Rmx> but something strange prevent me from "getting it"
09:58:26 <Rmx> mm_freak_: (don't say stupidity.. I haven't give up yet ;)
09:59:09 <Rmx> mm_freak_ : but still, any magic sentence that would unlock some understanding ?
09:59:23 <Rmx> or nothing but more work ?
10:00:50 <yitz> Peaker: you're missing an intermediate data structure
10:00:55 <ddarius> > 960 / 4.3
10:00:55 <lambdabot>   223.25581395348837
10:02:00 <yitz> Peaker: you need one structure that represents the meaning of the data, then another that represents presentation logic. Populate the presentation from the data. Then you can stuff it into the gui.
10:02:52 <yitz> Peaker: it's not extra work, it's worth it. it will simplifiy your code and allow the type system to work for you instead of against you.
10:03:29 <lispy> yitz: are you talking about MVC or lens, or more generally?
10:04:05 <yitz> Peaker: the gui structures are *not* presentation logic. it's just an artificial thin film over the imperative api.
10:04:17 <yitz> lispy: something Peaker asked about earlier
10:04:24 <Peaker> yitz: I'm talking about the presentation logic here, the data is completely separate and gone by then
10:04:36 <yitz> lispy: it's wonderful to see you here. did you know that hackage was down?
10:04:46 <Peaker> yitz: I wrote a relatively pure GUI lib
10:04:55 <Peaker> yitz: I'm not using imperative bindings
10:04:57 <mux> oh, hackage is back
10:05:03 <lispy> yitz: I do know, but I'm afraid I'm not much help.
10:05:29 <lispy> yitz: I saw your comment last night
10:05:40 <Peaker> yitz: I've converted my data into a bunch of pure Widget values, and I want to purely compose them into a grid, and then I want to manipulate the post-grid-translations/processing Widgets
10:05:58 <lispy> yitz: heinlein probably fixed it this morning?
10:06:13 <yitz> Peaker: ok then. still, you're description of flat lists like that makes it clear that this is at the rendering level, below the high-level presentation logic.
10:06:20 <Peaker> yitz: The main thing that bothered me is the partiality, that I will solve by changing Grid from  [[Widget ..]] -> [[Widget ..]]  to be a type that enforces the size is the same on both sides
10:06:27 <yitz> Peaker: so i think you need another layer.
10:06:37 <Peaker> yitz: well, the Grid code is sort of a "rendering layer"
10:06:43 <mux> dreixel: poke
10:06:56 <dreixel> mux: yes
10:07:00 <yitz> Peaker: nah you need something in between. i've been running into that kind of thing lately.
10:07:03 <Peaker> yitz: or maybe not.. Grid takes a bunch of widgets, each with their size demands, and translates their positions, basically
10:07:23 <mux> dreixel: have you seen my report of a GHC panic (the impossible happened) when trying to derive a Generic instance for Complex a?
10:07:28 <Peaker> yitz: (maybe Grid isn't rendering layer, I meant)
10:07:29 <Peaker> yitz: not maybe not on what you said :)
10:07:48 <Peaker> yitz: We also have a low-level rendering layer underneath all that
10:07:51 <dreixel> on this channel?
10:08:09 <yitz> lispy: heh ok. hope so. hackage outages on weekends are a real bummer for the community.
10:08:24 <dreixel> hackage outages in general are a bummer :)
10:08:30 <yitz> lispy: although the working mirror was a lifesaver this time.
10:08:41 <lispy> yitz: we have a mirror this time?
10:08:48 <yitz> @where hackagemirror
10:08:49 <lambdabot> http://hackage.factisresearch.com/
10:09:24 <lispy> yitz: I agree that outtages are terrible. I think the problem is pretty general around the haskell community.  I mean, compared to the hackage trac outage, this was a blink.
10:09:27 <yitz> lispy: it's a test of hackage 2 i think, but it worked well enough to rescue a lot of people during this outage.
10:09:30 <cmccann> that's dcoutts's hackage2, yes
10:09:38 <scooty-puff> is it possible to use emacs to sort haskell imports?
10:09:39 <cmccann> it doesn't have builds, so no haddocks or anything
10:09:44 <scooty-puff> or rather, has someone already written something to do so
10:09:53 <Rc43> Hmm... What will be more optimal for time/size? The IntMap to UArrays Int16 Boolean or IntMap to IntSet? IntSet is for Int, so it will be 4x more memory for 64bit processor.
10:10:00 <lispy> scooty-puff: someone had some scripts for that.  chrisdone?
10:10:22 <cmccann> I was hoping to get my own hackage2 full of tarballs yesterday as well but didn't get that ready soon enough to help
10:10:22 <dreixel> mux: you should prob make it into a bug report
10:10:25 <lispy> scooty-puff: are you by any chance coming from eclipse?
10:10:36 <mux> dreixel: ok, will do
10:10:41 <Peaker> scooty-puff: I just use "sort-lines" on the imports
10:10:45 <scooty-puff> i often use it, but mostly i'm sick of alphebetizing my imports..
10:10:47 <Peaker> scooty-puff: M-x sort-lines
10:10:50 <scooty-puff> k
10:10:53 <lispy> scooty-puff: if so, you might want to try out eclipseFP
10:11:03 <lispy> scooty-puff: or leksah
10:11:05 <Peaker> EclipseFP is really slow, and hard to set up
10:11:13 <yitz> lispy: it's good to see that hackage 2 is moving forward. until then... isn't there *anyone* at galois who can help in these after-hours emergencies?
10:11:20 <scooty-puff> i'm already a fan of emacs for haskell
10:11:21 <dreixel> mux: GHC shouldn't panic, no matter what you're doing
10:11:37 <mux> dreixel: yeah :)
10:12:05 <lispy> yitz: heinlein, but I don't think we keep him "on call" 24/7.
10:12:32 <lispy> yitz: I guess that means it should change.
10:12:36 <yitz> Peaker: anyway, when you start to see those kinds of partial functions involving matching parts of lists, it means you want yet another conceptual layer.
10:12:45 <lispy> yitz: having a community run mirror would be a good start
10:12:55 <ahmadia> I'm hitting weird problems with happstack-server-6.5.7, it's complaining about missing C library cryptopp, but it seems to be installed properly and up to date…  Google is no help, any ideas?
10:13:20 <lispy> yitz: (I say it should change, but I don't want to ask heinlein to be on call 24/7, I mean we should make it so that there are people who can attend to it other than him)
10:13:41 <lispy> ahmadia: you may need to tell it where to find cryptopp
10:13:50 <alpounet> lispy, how much disk space does an up-to-date hackage instance take ?
10:14:13 <lispy> alpounet: I have no idea, TBH
10:14:13 <yitz> lispy: yeah. it will change. hackage 2 is already doing some of the work for us. but can't we ask heinlen very very nicely to just somehow be able to press the restart button every once in a while, just for a little more time until the system becomes more robust?
10:14:16 <cmccann> ahmadia, what OS are you using?
10:14:39 <ahmadia> cmccann: Arch, and I'm new to it
10:14:44 <alpounet> lispy, having some kind of "roll-your-own-hackage-mirror kit" would be nice
10:14:56 <cmccann> ahmadia, ah, not sure about that then, sorry
10:14:56 <yitz> alpounet: it's coming. very soon now.
10:15:05 <alpounet> oh? it's being worked on?
10:15:11 <ahmadia> lispy: thanks, I tried the usual suspects (/usr/lib, /usr/include, etc...)
10:15:32 <lispy> yitz: Perhaps, but I think he may already get notification when it goes down?
10:15:33 <cmccann> I could probably have a quick-start hackage mirror guide ready by next weekend
10:15:39 <Enigmagic> idea #2: hackage is mostly static so why not just statically generate it and host it on S3?
10:15:40 <cmccann> if people would find that useful
10:15:45 <yitz> alpounet: yes i think once hackage 2 rolls out that will be easy
10:16:23 <alpounet> cmccann, there will be a problem though once we get community feedback features etc on hackage2
10:16:23 <lispy> yitz: One important consideration here is, "why did it go down?"
10:16:39 <cmccann> alpounet, why?
10:16:40 <alpounet> keeping all the mirrors talking to each other seems irrealistic
10:16:45 <cmccann> oh
10:16:47 <lispy> yitz: I think I saw an email saying that contractors would be working in the building this weekend.  It could be that they interrupted something that brought it down
10:16:50 <yitz> lispy: probably. i image his job requires him to react more forcefully when it is a critical company server than when it is a community server. but hackage...
10:16:58 <yitz> s/image/imagine/
10:17:08 <yitz> lispy: yep that would do it
10:17:22 <yitz> cmccann: yes that would be great!
10:17:26 <cmccann> alpounet, that's sort of a separate issue, I'm just thinking of "how to clone the contents of the real hackage"
10:17:36 <alpounet> yeah sure
10:17:42 <Enigmagic> statically generate with a cdn on top = almost a guarantee it will never go down
10:17:44 <dcoutts> yitz: Paul Heinlein is the Galois sysadmin, but yes I doubt he's on a pager for the hackage server.
10:18:06 <cmccann> yitz, you've seen the recent activity involving hackage2, right?
10:18:13 <alpounet> was just trying to think of how to make that scale to new releases of hackage2 with some of the planned features
10:18:45 <dcoutts> alpounet: so it's easy to make a mirror, but the "primary" knowing the existance of the mirrors and telling clients is harder, trust issues
10:18:48 <yitz> cmccann: i haven't been following it closely, but i've heard the quiet excitement in the background
10:18:57 <dcoutts> alpounet: would also need some proper security
10:19:05 <Enigmagic> dcoutts: why not just use a CDN on top?
10:19:08 <cmccann> alpounet, what you're getting into is more like a sort of distributed hackage system, p2p style
10:19:27 <cmccann> that's much more complicated than everything just mirroring from the official site
10:20:12 <alpounet> cmccann, yes, that's exactly my point :P
10:20:13 <yitz> dcoutts: thanks for the help with text-icu on the mac the other day. not working yet, but i got the idea.
10:20:23 <dcoutts> yitz: good
10:20:36 <dcoutts> Enigmagic: I'm not really familiar with how they work, the ones that are transparent
10:20:39 <alpounet> dcoutts, and in addition to that, what happens when the "primary" hackage is down?
10:20:45 <cmccann> yitz, I have a copy of hackage2 on my github that I'm experimenting with, I'm running an instance (sans tarballs) on EC2, and dcoutts is running the instance mentioned earlier
10:20:45 <yitz> dcoutts: after hacking the pkg db, ghc is looking for lib<libname>.a.dylib. oops.
10:20:46 <Enigmagic> dcoutts: this is exactly what they are designed for
10:20:49 <dcoutts> alpounet: no uploads
10:21:14 <alpounet> and no feedback (rating, comments etc, whatever is planned to be added to hackage2)
10:21:16 <Enigmagic> dcoutts: http://aws.amazon.com/cloudfront/#functionality
10:21:17 <alpounet> ok
10:21:18 <thlorenz> I asked a question on code review. Not sure if my use of `scanl` is the best way: http://codereview.stackexchange.com/questions/9149/abusing-scanl-to-generate-a-random-number-stream-is-there-a-better-way
10:21:28 <dcoutts> Enigmagic: note also that we have limited funds
10:21:35 <lispy> I kind of wonder if an EC2 hackage would simply be more reliable than the current galois hosted one.  What are the bandwidth prices like
10:22:03 <q0tw4> It will be nice to have hackage managed by one group of people in which all packages always will be working and up to date
10:22:16 <dcoutts> lispy: if it's running full time then a more traditional host would make sense, like our current haskell.org box
10:22:24 <Enigmagic> dcoutts: is spending loads of engineering time is cheap? CDNs aren't that expensive really.
10:22:34 <rwbarton> @type unfoldr
10:22:35 <lambdabot> forall b a. (b -> Maybe (a, b)) -> b -> [a]
10:22:35 <lispy> dcoutts: I see
10:22:38 <cmccann> lispy, EC2 is probably more reliable than traditional hosting but it would be a bit pricier
10:22:45 <luite> dcoutts: can't that box be used as a mirror?
10:22:52 <yitz> lispy: it would certainly be economical to have an EC2 fallback for when abott is in trouble
10:22:54 <dcoutts> luite: which?
10:23:01 <rwbarton> @type randoms
10:23:02 <lambdabot> forall g a. (Random a, RandomGen g) => g -> [a]
10:23:03 <rwbarton> @type randomsR
10:23:03 <lambdabot> Not in scope: `randomsR'
10:23:08 <rwbarton> @type randomRs
10:23:08 <luite> dcoutts: the haskell.org box at hetzner
10:23:09 <lambdabot> forall a g. (Random a, RandomGen g) => (a, a) -> g -> [a]
10:23:12 <dcoutts> yitz: try the ld-options then
10:23:39 <rwbarton> thlorenz: does randomRs meet your needs? you can 'take' whatever amount of random numbers you need from that infinite list
10:23:45 <cmccann> lispy, the cost of the server instance is the biggest issue I suspect, my micro instance wouldn't really be viable for serious use
10:24:07 <lispy> cmccann: in which dimensions would it fall over first?
10:24:11 <dcoutts> luite: depends what you mean exactly. We don't want to run the hackage-server on their. I think we'd probably need another box, or upgrade our account for higher bandwidth
10:24:31 <cmccann> lispy, memory use mostly
10:24:32 <yitz> dcoutts: ok. thanks i'll look at that. there's a complication that we have TH so it loads text-icu already during compile. i may have to go to dynamic and distribute the dylibs. hope i can link it to find them in the same dir as the exe.
10:24:33 <Enigmagic> dcoutts: another thing that might be possible if haskell.org is a nonprofit would be to ask someone over at AWS if they'd donate some bandwidth
10:24:37 <luite> really? does hackage generate more than 10TB per month?
10:24:38 <cmccann> and builds would need to be done on something beefier
10:25:12 <cmccann> a personal-scale hackage mirror that a few people use would probably fit on a micro instance with only minor costs for storage and I/O
10:25:14 <dcoutts> luite: I'd have to check, but I thought we were using a good portion of our monthly limit for haskell.org as it is
10:25:31 <lispy> cmccann: IMO, we should factor out the building to a proper set of build slaves anyway
10:25:41 <luite> dcoutts: hm ok, the limit was doubled last summer btw, from 5 to 10TB monthly
10:26:00 <cmccann> lispy, yes, that's next on my list once I tinker with hackage2 a bit more
10:26:18 <lispy> cmccann: ah, did you see the proposal I posted?
10:26:30 <cmccann> use EC2 to launch some beefy build slaves, run a bunch of builds, shut them all down
10:26:37 <cmccann> lispy, don't think so?
10:26:51 <lispy> cmccann: http://blog.codersbase.com/2012/02/proposal-community-wide-build.html
10:26:55 <ahmadia> ??? copying the library from /usr/lib into /usr/local/lib fixed the cabal complaint...
10:27:07 <yitz> dcoutts: i had better go before someone eats my supper.
10:27:19 <yitz> thanks again.
10:27:40 <cmccann> lispy, ah right, forgot that was you
10:27:55 <lispy> cmccann: I do that sometimes too :)
10:28:27 <losvedir> hi, everyone! haskell beginner here. I'm trying to read a String from a file into [[Integer]]. I found two ways that work, but neither seems that elegant. Can a more experienced haskeller suggest a better way? http://hpaste.org/63978
10:28:47 <cmccann> lispy, I was in fact thinking about that, since EC2 would be very convenient for the disposable VM approach
10:29:52 <lispy> cmccann: I was thinking about the way github has been successful and I almost think this idea could be a successful startup
10:30:15 <lispy> cmccann: If done well, it's a lot of engineering work and it could be available to open source project all over if it's actually secure
10:30:50 <cmccann> yeah
10:31:05 <cmccann> though I'm happy to just stick with getting haskell builds going for the moment :P
10:31:23 * roconnor feels a need for higher-order constraints
10:31:57 <cmccann> lispy, should I hit you up for help when I get to working on the build stuff? :P
10:32:11 <roconnor> I want to say that instance (Functor x => Functor (t x)) => Functor (Stared t) where
10:32:26 <lispy> cmccann: yes
10:32:27 <byorgey> roconnor: yeah, that would be nice
10:32:38 <roconnor> byorgey: and insane!
10:32:43 <byorgey> hehe
10:33:02 <byorgey> I'd settle for just being able to say  instance (forall x. Functor (t x)) => ...
10:33:28 <byorgey> although that apprently wouldn't help you.
10:33:41 <thlorenz> rwbarton: wasn't aware of randomRs, but I guess writing it from scratch was a good exercise and now I can compare to that implementation
10:33:51 <rwbarton> thlorenz, yes
10:34:15 <thlorenz> rwbarton: I guess it would meet my needs, thanks
10:34:59 <cmccann> byorgey, I was trying something silly with type synonyms that I'm pretty sure would need rank-n kind polymorphism to work :D
10:35:17 <byorgey> hehe
10:35:29 <byorgey> well don't hold your breath.
10:35:34 <cmccann> yeah I kinda figured
10:35:51 <cmccann> it's not like I was trying to do anything useful
10:36:51 * hackagebot Annotations 0.2 - Constructing, analyzing and destructing annotated trees  http://hackage.haskell.org/package/Annotations-0.2 (MartijnVanSteenbergen)
10:36:51 <cmccann> in fact if it had worked it probably would have made GHC explode
10:37:34 <applicative> losvedir: why not get it out of IO toTriangle :: String -> [[Integer]] ; toTriangle =  map (map read . words ) . lines
10:37:37 <dcoutts> Enigmagic: do you know if the amazon cloudfront is designed for spreading load, or for dealing with the origin server going down?
10:38:02 <dcoutts> Enigmagic: to spread load we can just use a bunch of transparent proxies, relying on ordinary http caching hints
10:38:19 <dcoutts> but handling the origin server being unavailable is more tricky
10:38:55 * dcoutts disappears for a bit
10:39:45 <losvedir> applicative: wow! does that work? thanks. off to try it out and to wrap my head around it
10:40:31 <applicative> losvedir: then main = do triangle <- fmap toTriangle (readFile "triangle.txt")  ; print (munge triangle) where munge :: [[Integer]] -> Integer is the math problem
10:42:11 <tromp__> byorgey, did you see the hanoi sequence that works for all n?
10:43:01 <byorgey> tromp__: I must have missed it
10:43:38 <tromp__> @let hanoi  n =  take (2^n-1) [(i.&.pred i`mod`3,succ(i.|.pred i)`mod`3)|i<-[1..]]
10:43:42 <lambdabot>  Defined.
10:43:59 <byorgey> tromp__: ah, very cool =)
10:44:22 <lispy> > hanoi 4
10:44:24 <lambdabot>   [(0,2),(0,1),(2,1),(0,2),(1,0),(1,2),(0,2),(0,1),(2,1),(2,0),(1,0),(2,1),(0...
10:44:27 <losvedir> applicative: that does indeed work beautifully. thanks so much. will have to stare at the maps and compositions for a bit to make it click.
10:44:53 <byorgey> tromp__: were we discussing something about this before? I forget
10:45:22 <tromp__> yesterday there was mention of your course exercises
10:45:31 <byorgey> ahhh
10:45:32 <losvedir> applicative: I think I was close at one point, but got caught trying to shoehorn a ":: Integer" in there next to the read. I guess if I had pulled it out as a separate String -> [[Integer]] function like you suggested the type checker would have figured it out on its own. Hmm...
10:45:49 <Enigmagic> dcoutts: i was just using it as an example, not sure about cloudfront. in previous projects i've used akamai and they can handle servers going down.
10:46:38 <applicative> losvedir, yes, specifying read can occasionally be a little confusing, the signature I gave to 'toTriangle' was enough in that case
10:46:53 <mulander> hi all, is it possible to invoke 'edit' via System.Process.rawSystem on MS Windows? I'm trying but it fails on createProcess. Same issue can be observed with trying to run 'dir'. This works correctly for 'ls' and other things not strictly related to cmd.exe.
10:47:14 <mulander> I might also add that System.process.system works correctly for edit - it fails for rawSystem.
10:48:21 <Enigmagic> dcoutts: overall i think the easiest thing is to statically generate hackage (perhaps with some dynamic rendering of download counts or something like that) and serve it statically, with a cdn or other caching proxy to increase availability
10:49:06 <Enigmagic> dcoutts: serving the site would then just be a single function call to sendfile in a loop :)
10:49:15 <Enigmagic> (effectively)
10:49:19 <mulander> anyone?
10:50:32 <cpennington> has anyone been able to use hsenv with ghc 7.4.1?
10:52:36 <cmccann> mulander, I think most people do their Haskell programming on linux, so may not be able to help
10:52:58 <JoeyA> What's hsenv?
10:53:24 <lispy> cpennington: I don't know if you already know this, but ghc 7.4.1 is for brave souls at the moment who don't mind fixing anything they try to use. If you want a more stable haskell environment you are recommended to stick to the haskell platform for now
10:53:26 <Philippa_> mulander: I imagine not
10:54:30 <Philippa_> (and I'm guessing it's a windows API/wow, the command prompt is weird thing)
10:54:48 <nyingen> lispy: which version is in the platform?
10:54:50 <cmccann> is hsenv the successor to virthualenv? because I have used the latter with 7.4.1
10:54:53 <JoeyA> I for one would recommend GHC 7.2.2 over the Haskell platform.  I've already had a problem or two trying to compile stuff with GHC 7.0.3.
10:54:54 <cpennington> lispy: yup, I'm familiar with the bleeding edge warning.
10:55:12 <JoeyA> (at least for the moment)
10:55:12 <cpennington> cmcann: yes, hsenv is the successor to virthualenv
10:55:33 <lispy> nyingen: http://hackage.haskell.org/platform/changelog.html
10:55:36 <nyingen> also, why is 7.4.1 considered tricky?
10:55:57 <cpennington> so far, I've had to bump the allowed cabal and base versions for hsenv
10:56:05 <cpennington> at which point, it compiles
10:56:17 <JoeyA> err, 7.0.4
10:56:38 <nyingen> having just installed 7.4.1 on a production machine, I wonder whether I should downgrade
10:56:56 <JoeyA> nyingen: If you're developing new code, I'd say not.
10:56:57 <cpennington> however, when trying to set up an env, I get the following error "Couldn't parse package identifier depends:"
10:57:03 <JoeyA> Wait until you run into problems
10:57:07 <lispy> nyingen: version numbers change and that can superflously break builds, but also 7.4.1 includes deeper changes like removing Eq/Show from Num.
10:57:09 <cmccann> cpennington, oh, you mean installing it with 7.4.1? I thought you meant running 7.4.1. inside an environment, heh
10:57:12 <cpennington> also: "ghc-pkg: cannot find package Cabal-1.14.0"
10:57:16 <nyingen> JoeyA: Ok. I have run into a few things already, but they were fairly easily fixed
10:57:24 <cpennington> yes, installing it w/ 7.4.1
10:57:27 <o1iver> Hey! What is the general opinion on multi-parameter type classes? Should one avoid them as much as possible? Or are they quite possibly the right choice in some cases?
10:57:31 <JoeyA> Right.  Wait until you hit an issue you don't feel like fixing, then ;-)
10:57:40 <nyingen> For example c2hs wouldn't compile; I had to add the pragma DatatypeContexts to one of its source files
10:57:50 <nyingen> that triggers a deprecation warning, but what else could I do
10:58:15 <cpennington> actually, scratch that, I think the second message isn't actually an error
10:58:36 <lispy> o1iver: I avoid type classes when I can (I love them, but they are often unnecessary and complicate things).  But type classes and and multiparamater variant are sometimes just perfect
10:58:37 <JoeyA> oliver: As long as you don't try to emulate Perl, e.g. http://hackage.haskell.org/packages/archive/regex-base/latest/doc/html/Text-Regex-Base-RegexLike.html#t:RegexOptions
10:58:40 <cmccann> cpennington, that worked fine for me, I compiled hsenv with 7.4.1 a bit ago
10:58:53 <o1iver> JoeyA: I don't know perl :-p
10:59:15 <nyingen> if hackage is back up, does that mean the haskell.org mailing system is also working?
10:59:43 <lispy> nyingen: I don't think the mailing list went down.  Pretty sure they are separate these days.
10:59:52 <o1iver> lispy: yeah, well that is kind of the question at the moment... To me it seems like type classes are quite nice because they hide the implementation of complex data structures.
10:59:53 <cpennington> ok, anyone know why running "ghc-pkg field Cabal-1.14.0 depends" would return two copies of the dependency list?
10:59:57 <lispy> I certainly read the hackage is down mail on the mailing list :)
10:59:58 <cpennington> https://gist.github.com/1865185
11:00:04 <ahmadia> thanks for the help everyone
11:00:39 <nyingen> lispy: Oh, I actually meant user@haskell.org addresses. I got a "delivery delayed" message from sending to one of those 2 days ago, so I thought it might be related to the hackage outage
11:00:45 <lispy> o1iver: I would not use them for that.  I would use the module system for that
11:00:55 <nyingen> perhaps it's just that particular address
11:00:55 <o1iver> I am for example trying to define something that represents a decision rule (a map with a 2-tuple index) and I am unsure of whether to directly use map, or rather use a type class and leave the impl. seperate
11:01:56 <o1iver> But in 50% of the cases the decision rule is actually independent of the second indexing parameter....
11:02:01 <lispy> o1iver: you could create a type (data or newtype) for your type and not export the constructors, but do export functions that take the appropriate values and construct  your type
11:02:22 <o1iver> lispy: ah yes... that is interesting too
11:02:43 <o1iver> lispy: actually that is very nice. I will think in those terms... thanks!
11:02:54 <lispy> o1iver: yw.  It's a very common idiom here
11:04:21 * mee is happy hackage was down, because it forced me to implement a fun algorithm myself rather than stealing^Wusing someone elses' code, and I learned some stuff doing so
11:06:03 <lispy> maybe we should have weekend each year where hackage is down ;)
11:06:58 <osfameron> isn't hackage mirrored?
11:07:19 <lispy> nope
11:07:25 <lispy> Not officially anyway
11:07:26 <osfameron> aw, bless
11:09:26 <applicative> osfameron: there are 'unofficial' mirrors, e.g factisresearch, which seems to have the tarballs
11:10:05 <applicative> in addition to the deluxe hackage2 format
11:10:30 <efie> can anyone tell me where the .ghci file is under windows?
11:10:32 <cpennington> so, for the record, the reason you would get multiple depends: clauses when running ghc-pkg field <pkg> depends is if you have the package registered both for --global and --user
11:10:43 <JoeyA> efie: I wanna say Application Data
11:10:44 <JoeyA> lemme look
11:12:09 <JoeyA> Yeah, %HOME%\Application Data\ghc\ghci.conf  (I think)
11:13:44 <efie> JoeyA: that's what http://www.haskell.org/ghc/docs/latest/html/users_guide/ghci-dot-files.html says too, but in my C:\Users\X\AppData\Roaming\ghc folder there is only ghci_history and 2 other folders
11:14:17 <JoeyA> efie: What happens if you create a ghci.conf file?
11:14:21 <JoeyA> I don't have one, either.
11:14:46 <JoeyA> (all I have is ghci_history)
11:16:52 <efie> JoeyA: i'm not sure what to do now, i want to integrate hlint to ghci and the website says "The script is at hlint.ghci, and a copy is installed locally in the data directory. To use, add the contents to your GHCi startup file. " so i looked for the ghci.config file
11:17:07 <efie> (http://community.haskell.org/~ndm/darcs/hlint/hlint.htm)
11:17:13 <applicative> don't you have to make your own .ghci file. or maybe a blank one comes with?
11:18:27 <hpaste> applicative pasted “moronic .ghci” at http://hpaste.org/63979
11:18:52 <JoeyA> efie: I think you can just rename hlint.ghci to ghci.conf and put it where it goes.  Otherwise, I think GHC will run any .ghci files in the current directory.
11:18:52 <applicative> don't know where you'd put it on windows.  Here's mine it doesn't seem to have anything but my nonsense.
11:19:21 <JoeyA> Interesting, I didn't know you could set extension flags in GHCi: :set -XNoMonomorphismRestriction
11:19:45 <Philippa_> heh, I just did that too
11:19:51 <Philippa_> I really need to set up a .ghci
11:21:41 <cmccann> my GHCi imports my alternate prelude and sets my ridiculous prompt :P
11:22:06 <CodeWeaverX> You have a ridiculous prompt?
11:22:22 <Saizan> ridiculous prompt>
11:22:32 <efie> JoeyA: If i rename the hlint.ghci to ghci.conf and put it in the ghc folder WinGhci crashes while trying to start; i will now try to ise applicative s .conf (thanks) and add the hlint.ghci content to it
11:22:37 <alpounet> at your service>
11:22:42 <scooty-puff> does anyone have a good -XDataKinds example?
11:22:48 <cmccann> my prompt is "∀x. x ⊢ "
11:23:30 <CodeWeaverX> Hah, love it.
11:23:36 <cmccann> lots of people started using a plain lambda but I wanted something less sensible
11:25:58 <JoeyA> efie: Perhaps there's a bug in GHC?  What happens if you uncomment some of the lines in hlint.ghci?
11:26:08 <JoeyA> Maybe you can narrow down what line is causing the crash.
11:26:45 <BlankVerse> where are the ghc packages's docs stored?
11:27:15 <JoeyA> For me: file:///usr/local/share/doc/ghc/html/libraries/base-4.5.0.0/Control-Applicative.html
11:27:26 <lispy> efie: I'm slightly worried that you wrote over an important file that shipped with ghc. Whenever I've used .ghci files I always put them in my home directory not into my ghc install.
11:29:30 <scooty-puff> ok, sorted them out - kind of cool, user-defined kinds if i understand it right
11:29:34 <scooty-puff> (datakinds)
11:30:21 <efie> lispy: um i think i even never have  looked in the ghc folder before
11:30:25 <efie> i dont know
11:30:32 <cmccann> lispy, at worst that would be overwriting some sort of default .ghci
11:30:40 <cmccann> but I don't think there is one
11:32:00 <Cale> Cute problem: Let F = {f_a : a in A} be a family of analytic functions C -> C such that for each z in C, the set of values {f_a(z) : a in A} is countable. Does it follow that F is countable?
11:33:33 <efie> JoeyA
11:33:35 <efie> ups
11:34:11 <efie> JoeyA: http://community.haskell.org/~ndm/darcs/hlint/data/hlint.ghci i can comment out the lines by adding "--" in front right? even if i do this for every line winghci still crashes
11:34:39 <lispy> Cale: My guess: yes because (again, guessing) that you are some how limited by function equality and the individual ranges are countable?
11:34:41 <JoeyA> I believe so.
11:34:44 <JoeyA> hmm
11:35:07 <Paprikachu> i have this program: http://ideone.com/8rk12
11:35:48 <Paprikachu> now i want to print numbers in single lines so that each line contains the number and is_prime of the number, like "n: is_prime n"
11:35:54 <Paprikachu> how can i do that?
11:36:24 <applicative> effi, I'm on os x but I'm defeated adding the hlint business.  I wonder if ghc has changed a little, but I'm a .ghci know-nothing
11:37:05 <cmccann> I found winghci would sometimes behave oddly in general
11:37:07 <efie> applicative anyway thanks :)
11:37:19 <cmccann> have you tried running GHCi from a console instead?
11:37:27 <alpounet> Cale, doesn't { f_a(z) : a in A} being countable imply some drastical things on the f_a's?
11:37:38 <efie> cmccan: no, not yet
11:37:40 <Cale> It turns out the result depends on the continuum hypothesis :)
11:37:51 <rwbarton> i was worried it might
11:37:56 <Cale> http://www.renyi.hu/~p_erdos/1964-04.pdf
11:38:08 <Dodek> oh why programming languages make -1 `mod` n == -1 instead of -1 `mod` n == n-1
11:38:25 <dolio> -1 `mod` n = -(1 `mod` n)
11:38:48 <lispy> Cale: amazing.  Thanks for the link
11:39:19 <vodik> Paprikachu: change b2s (is_prime n)) to "n:" ++ b2s (is_prime n))
11:39:21 <tromp__> misguided sense of performance issues, Dodek
11:39:29 <vodik> Paprikachu: sorry, not quite that
11:39:46 <vodik> Paprikachu: show n ++ ":" ++ b2s (is_prime n))
11:40:26 <Dodek> tromp__: so what's your suggestion on how to deal with it in haskell?
11:40:32 <alpounet> Cale, interesting, thanks
11:40:36 <dolio> It has nothing to do with performance in Haskell.
11:40:41 <dolio> It has to do with how that expression parses.
11:40:43 <CodeWeaverX> ∀ testing unicode
11:40:49 <CodeWeaverX> Huh, that worked
11:40:55 <everythingWorks> me likey.
11:40:57 <lispy> > (-1) `mod` 4
11:40:58 <lambdabot>   3
11:41:01 <tromp__> haskell has both mod (behaves properly) and rem
11:41:07 <everythingWorks> rem?
11:41:19 <applicative> @type rem
11:41:20 <lambdabot> forall a. (Integral a) => a -> a -> a
11:41:30 <tromp__> > -1 `quotRem` 3
11:41:30 <applicative> > rem 14 7
11:41:30 <lambdabot>   (0,-1)
11:41:31 <lambdabot>   0
11:41:31 <everythingWorks> :)
11:41:40 <Dodek> Prelude Assembler> (-1) `rem` 5
11:41:40 <Dodek> -1
11:41:42 <tromp__> > -1 `divMod` 3
11:41:43 <lambdabot>   (0,-1)
11:41:50 <Dodek> Prelude Assembler> -1 `mod` 5
11:41:55 <Dodek> -1
11:42:08 <Dodek> oh
11:42:10 <lispy> Dodek: in the mod case, put parens around (-1) and you get 4
11:42:11 <Dodek> it's precedence
11:42:18 <tromp__> > (-1) `divMod` 3
11:42:19 <lambdabot>   (-1,2)
11:42:26 <Dodek> silly me, haskell treats mod correctly
11:42:29 <ChristianS> Paprikachu: your program would look more haskell-ish, if you used pattern matching, by the way. e.g.
11:42:31 <ChristianS> b2s True  = "True"
11:42:32 <ChristianS> b2s False = "False"
11:42:43 <Paprikachu> okay
11:42:50 <Paprikachu> i'm new to haskell
11:42:50 <Dodek> thanks
11:43:00 <efie> cmccann: thanks for the hint, if i run ghci with ghci.conf in my folder it says "<interactive>:10:91:     lexical error in string/character literal at character '\n <interactive>:4:105:     lexical error in string/character literal at character '\n''" however i cannot find any "\n" in the ghci.conf file
11:43:01 <tromp__> b2s = show
11:43:34 <lispy> efie: it's complaining about line endings
11:43:46 <Paprikachu> okay, it works now: http://ideone.com/vvogb
11:43:48 <lispy> efie: What text editor are you using?
11:43:58 <efie> notepad ++
11:44:03 <Paprikachu> but now i don't want to print the list, i want to print each element on a single line
11:44:10 <rwbarton> @karma notepad
11:44:10 <lambdabot> notepad has a karma of 13
11:44:12 <everythingWorks> eclipse.
11:44:24 <lispy> efie: does it have a way to save it as a unix file or dos file?  I'm not sure which one you need, but I'd try the one it's not :0
11:44:58 <losvedir> paprikachu: try `unlines` which turns a list of strings into one string joined by "\n"
11:45:18 <vodik> Paprikachu: just mapM putStrLn $ <code> instead of just print
11:45:21 <applicative> Paprikachu: or you could write b2s = show
11:45:30 <applicative> > show True
11:45:31 <lambdabot>   "True"
11:46:03 <Paprikachu> what exactly does "show" do?
11:46:05 <cmccann> efie, awesome, at least now you have something to go on
11:46:27 <applicative> notepad++ has unusually low karma today
11:46:35 <applicative> @karma notepad
11:46:35 <lambdabot> notepad has a karma of 13
11:46:39 <Paprikachu> is it a to_string function?
11:46:49 <lispy> Paprikachu: yes
11:47:00 <vodik> Paprikachu: if something implements the Show interface, it'll make a string representation of a value
11:47:19 <Paprikachu> okay, thx
11:47:20 <applicative> > show (3 * 2)
11:47:21 <lambdabot>   "6"
11:47:53 <lispy> Some of the show instances in here are non-standard, like this one
11:47:58 <lispy> > (+)
11:47:59 <lambdabot>   Overlapping instances for GHC.Show.Show (a -> a -> a)
11:47:59 <lambdabot>    arising from a use...
11:48:08 <lispy> oh, never mind maybe that's not here anymore
11:48:09 <o1iver> lispy: About the "hiding impl. by using modules" thing again. That only works if you have a sinple implementation though doesn't it?
11:48:19 <o1iver> s/sinple/single
11:48:19 <efie> lispy: um i don't know; however, if copy the hlint.ghci file from the hlint folder to the ghc folder and rename to ghci.conf the problem with the texteditor should be eliminated, shouldn't it?
11:48:34 <Paprikachu> > :t `unlines`
11:48:38 <lambdabot>   mueval-core: Time limit exceeded
11:48:49 <lispy> o1iver: Well, you can make 2 modules that export the same names and just chaneg an import.  Other than that, yes you're right.
11:49:01 <efie> besides, is a karma of 13 a good karma?
11:49:33 <efie> j
11:49:50 <o1iver> lispy: mmmh, so what is the better approach then? The type classes seem nicer :-p
11:49:51 <vodik> Paprikachu: no backquotes
11:49:55 <vodik> > :t unlines
11:49:56 <lambdabot>   <no location info>: parse error on input `:'
11:49:59 <losvedir> paprikachu: my bad on the back ticks for unlines. i forgot that in haskell back ticks actually mean something.
11:50:16 <ceii> @t unlines
11:50:16 <lambdabot> Maybe you meant: tell thank you thanks thx ticker time todo todo-add todo-delete topic-cons topic-init topic-null topic-snoc topic-tail topic-tell type . ? @ ft v
11:50:20 <ceii> :t unlines
11:50:21 <lambdabot> [String] -> String
11:50:28 <lispy> o1iver: I guess it depends on what you need to accomplish.  ByteString vs. Lazy ByteString is done the way I said with two modules but exporting the same names.
11:50:32 <Paprikachu> http://ideone.com/zGeEo
11:50:43 <Paprikachu> why is it printing \n in the string
11:50:53 <lispy> o1iver: In Haskell we often don't make competing implementations
11:51:07 <vodik> Paprikachu: don't use print, use putStr
11:51:19 <losvedir> paprikachu: use putStrLn instead of print
11:51:26 <lispy> o1iver: But if you need to use one function for different types and you need to do something different depending on the type, then you'll almost certainly want a type class
11:51:28 <Paprikachu> what's the difference?
11:51:47 <losvedir> huh, i'm curious too. i just tried them both and they each seemed to work
11:51:52 <lispy> Paprikachu: print x = putStrLn (show x)
11:52:09 <losvedir> what's the diff between putStr and putStrLn ?
11:52:16 <lispy> a new line
11:52:18 <Paprikachu> LN prints an \n
11:52:21 <o1iver> lispy: ok thanks. I guess I have to think about it a bit more. Cheers
11:52:22 <Paprikachu> i think
11:52:24 <losvedir> oh, lol
11:52:26 <applicative> the line ending
11:52:36 <Paprikachu> it works now: http://ideone.com/8Sedi
11:52:38 <Paprikachu> thanks :)
11:53:11 <vodik> Paprikachu: you should look at some pattern matching and guards now
11:53:31 <vodik> is_prime_impl n i delta
11:53:39 <vodik>     | i * i > n = True
11:53:39 <efie> i probably will write an email to the haskell mailinglist; should i use the beginner- or cafe- maillinglist?
11:53:43 <vodik>     | otherwise = ...
11:53:44 <applicative> Paprikachu: print "hello" will exhibit the haskell name of the string, putStrLn just displays the string.
11:54:21 <Paprikachu> pattern matching is easy, i use it in c++. just forgot that it's there
11:54:23 <lispy> efie: stackoverflow :)
11:54:48 <efie> lispy: why do you prever stackoverflow?
11:54:53 <applicative> efie, yes stackoverflow is the flavor of the year
11:55:17 <lispy> efie: for questions like this that have a right answer it's nice to see them ranked and to see which one worked
11:55:25 <vodik> Paprikachu: this is more haskell like: http://ideone.com/3qV8T
11:55:32 <vodik> Paprikachu: you can do the rest
11:55:40 <applicative> efie, just try it, you'll get 30 competing answers in 2 minutes
11:55:46 <efie> :D ok
11:56:04 <Paprikachu> hmm :)
11:56:21 <vodik> Paprikachu: cleaner, eh?
11:56:27 <Paprikachu> yep
11:56:31 <applicative> haskell-beginners is charming though.  some of the typical respondents are extremely good
11:57:17 <efie> and what's with the cafe-list?
11:57:27 <efie> i am just using the beginner list by npw
11:57:30 <efie> now*
11:57:41 <lispy> cafe is high volume, most anything goes
11:57:56 <lispy> I'm subscribbed, but I only skim over it
11:58:16 <lispy> (I thnk that's pretty common, is why I mention it)
12:00:00 <Paprikachu> http://ideone.com/GvgLh
12:00:10 <Paprikachu> i like that syntax
12:01:52 <applicative> http://ideone.com/oZw0S  -- you don't need 'do' on the last line, since you aren't sequencing more than one 'statement', so to say
12:03:04 <efie> Paprikachi: concerning what applicative said i recommend hlint, which tells you what you can improve in your code
12:03:34 <efie> using in the command prompt is sufficient nice :)
12:03:55 <applicative> hlint will complain about his underscores at least the one on hpaste, no?
12:04:12 <hpaste> applicative pasted “print prime” at http://hpaste.org/63985
12:04:31 <applicative> no it didn't do anything :(
12:04:41 <vodik> applicative: hlint doesn't complain about underscores for me
12:04:51 <vodik> but i only use them for c functions
12:05:14 <hpaste> applicative annotated “print prime” with “print prime (annotation)” at http://hpaste.org/63985#a63986
12:05:42 <applicative> pardon spam, can't seem to get hlint to whine about anything.  excellent work Paprikachu
12:05:57 <efie> for me hlint complains about the underscorces
12:06:16 <Paprikachu> i like the underscore style more than camel case
12:06:50 <vodik> applicative: complaines on my machine actually
12:06:59 <efie> i'm not sure, but i like that the code shrinks
12:07:32 <vodik> Paprikachu: perfer is_prime over isPrime?
12:07:38 <Paprikachu> yes
12:08:00 <Paprikachu> so.. how can i make it print only the numbers that are primes seperated by commas?
12:08:01 <vodik> Paprikachu: well if you ever release code, use the haskell convension for the public interface
12:08:43 <hpaste> applicative pasted “print primes” at http://hpaste.org/63994
12:08:48 <Paprikachu> is there a function that lets me select elements based on a condition?
12:08:57 <lispy> Paprikachu: filter
12:09:09 <nyingen> too bad "prime?" doesn't parse
12:09:09 <applicative> oh it does complain about came case, I was making a copying error which i just made again.  pardon more spam
12:09:18 <lispy> > filter (=='a') "aabccaoaaaccbtta"
12:09:19 <lambdabot>   "aaaaaaa"
12:09:49 <CodeWeaverX> >filter ('a'==) "I am the very model of a modern major-general"
12:09:56 <CodeWeaverX> Booo
12:10:15 <applicative> Paprikachu: here's the complaints, for what they're worth.  http://hpaste.org/63995 they should shut the underscore nonsense off, which can be done in your local hlint
12:10:19 <nand`> CodeWeaverX: you need a space between > and filter
12:10:26 <CodeWeaverX> Fair enough. :D
12:10:33 <CodeWeaverX> > filter ('a'==) "I am the very model of a modern major-general"
12:10:34 <lambdabot>   "aaaa"
12:10:36 <CodeWeaverX> Hah
12:10:50 <Paprikachu> what does the last message mean?
12:11:01 <nand`> > filter isUpper "AoaAaAooEoEeEeccDDxxD"
12:11:01 <lambdabot>   "AAAEEEDDD"
12:11:24 <vodik> Paprikachu: the use elem tip is worth implementing
12:11:50 <applicative> Paprikachu: I think they want n `elem` [2,3] insteadd of n == 2 || n == 3
12:11:51 <Paprikachu> what is elem?
12:12:01 <Paprikachu> okay
12:12:13 <CodeWeaverX> Paprikachu should probably read all the neat functions in the Prelude and Data.List. :D
12:12:14 <Rc43> Somehow profiling output tells that, GC time for mutable variant of program is _more_ than immutable one.
12:12:21 <tazjin> I might be missing something obvious and I don't have a problem with recursion in general, but what happens if you define x as x = x + 1 and then try to show x?
12:12:23 <applicative> It's not important, but it's a nice example of little refactorings it teaches you
12:12:42 <nand`> > filter (`elem` "aeiou") "Foo bar bat baz bla"
12:12:43 <lambdabot>   "ooaaaa"
12:12:50 <applicative> > let x = x + 1 in x
12:12:50 <CodeWeaverX> tazjin:  It tries to evaluate the right hand side x as if it's defined as the x on the left.
12:12:53 <lambdabot>   mueval-core: Time limit exceeded
12:12:54 <vodik> Paprikachu: you should install hlint and use it from time to time
12:12:55 <Rc43> And there is more memory allocated in mutable variant.
12:13:04 <Rc43> How can it be?
12:13:15 <nand`> tazjin: endless recursion
12:13:16 <CodeWeaverX> tazjin:  This means the next expansion of x+1 is x+1+1, and the expansion of that is x+1+1+1… it never ends.
12:13:21 <nand`> well
12:13:28 <nand`> stack overflow at some point
12:13:40 <tazjin> Okay, so GHC doesn't check for infinite recursion?
12:13:47 <CodeWeaverX> It'll go boom eventually.
12:13:52 <nand`> nope, because infinite recursion can be useful
12:13:55 <applicative> Paprikachu: the other good thing about hlint is it tells you when you don't need parentheses which I found really helpful before I figured out the fixities of the standard operators
12:14:03 <CodeWeaverX> There's not really a general way to know if an expression evaluation really is non-terminating.
12:14:13 <nand`> > let f n = n : f (n+1) in f 0
12:14:14 <lambdabot>   [0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,...
12:14:14 <rwbarton> in some cases it can detect a bad recursive definition at runtime
12:14:19 <Paprikachu> what's wrong? http://ideone.com/6nOYC
12:14:22 <rwbarton> if you compile with optimizations
12:14:24 <nand`> or infinite loops in interactive programs
12:14:38 <tazjin> Hm, okay
12:14:44 <applicative> why would ghc check?
12:15:04 <applicative> nand` has made my point i see
12:15:09 <CodeWeaverX> Generally, all your recursions should have an 'out', or be partially evaluable like an infinite list that you can get part of without getting the whole thing.
12:15:18 <nand`> tazjin: if you want your compiler to check whether a computation ends or not I recommend using Agda :P
12:15:58 <tazjin> nand`: Well I've never had any issues with this, I was just wondering what would happen ;D
12:16:02 <Rc43> rwbarton, can mutable array be slower than immutable?
12:16:49 <CodeWeaverX> tazjin:  Being able to refer recursively to values and functions enable some really funky and useful constructs.  So it's not without value.
12:17:23 <applicative> http://ideone.com/gVQAS -- Paprikachu you left out n in | n `elem` [2,3]
12:17:28 <rwbarton> Rc43: presumably there is some other difference between your mutable and immutable array-using programs, so obviously yes
12:17:29 <q0tw4> Paprikachu: n `elem` [2, 3]
12:17:32 <Paprikachu> oh.
12:17:48 <zomg> Errm
12:17:54 <zomg> What on earth does this mean: "writev: resource vanished (Broken pipe)"
12:18:10 <Rc43> rwbarton, algorithms are same
12:18:29 <zomg> As far as I can tell it would appear to be being caused by a socket write
12:18:30 <Rc43> rwbarton, difference is huge
12:18:40 <Paprikachu> http://ideone.com/ZO8B0
12:18:47 <hpaste> o1iver pasted “type classes” at http://hpaste.org/63996
12:18:53 <Paprikachu> now i want it to print the elements without [] and sperated by ", "
12:19:00 <Paprikachu> *seperated
12:19:45 <vodik> Paprikachu: instead you want whay?
12:19:48 <vodik> *what?
12:19:55 <Rc43> rwbarton, will give you concrete data in 1-2 minutes
12:20:02 <o1iver> Hey. I think I am doing something wrong with type classes. I think my approach is wrong. I just pasted (^^) and am wondering if you could give me a hint as to how this should be done better (the problem is the fact that the DecsionRule type class now has three parameters)...
12:20:07 <Paprikachu> "[a,b,c]" -> "a, b, c"
12:20:52 <applicative> Paprikachu: print x is the same as putStrLn (show x)
12:21:01 <o1iver> If I know want to define a further type class that depends uses DecisionRules, it get's really bad with the parameters...
12:21:06 <o1iver> s/know/now
12:21:38 <applicative> Paprikachu: so you need to separate them, instead of putStrLn'ing show [2,3,5] you need to crop the beginning and end of the string first
12:22:36 <nand`> > concat $ intersperse ", " ["hello", "world"]
12:22:37 <lambdabot>   "hello, world"
12:22:45 <rwbarton> o1iver: you could make a0 and a1 associated types of a2, perhaps.
12:22:57 <rwbarton> btw this State/Action/etc. stuff doesn't seem useful.
12:23:24 <nand`> > intercalate ", " ["hello", "world"]
12:23:24 <lambdabot>   "hello, world"
12:23:40 <rwbarton> o1iver: it also seems likely that you don't want a type class at all, but rather just a record
12:23:41 <applicative> Paprikachu: http://ideone.com/uMoXY  this is getting a little inefficient of course but there's an example
12:23:45 <o1iver> rwbarton: yes, I think I am doing something wrong on a much more basic level. The thing is that depending on the use-case it is useful to sometimes have State Int states and sometimes State (Int,String)
12:24:12 <vyom> i am running into some dependency issues with cabal-dev on ghc7.4 http://pastebin.com/AV5Cmes6
12:24:15 <mauke> The paste AV5Cmes6 has been copied to http://hpaste.org/63997
12:24:18 <Paprikachu> what do . and $ mean?
12:24:21 <vyom> not sure how to get around it
12:24:29 <nand`> > let f = intercalate ", " . map show in f [1,2,3]
12:24:31 <lambdabot>   "1, 2, 3"
12:24:34 <o1iver> rwbarton: you mean for the decision rule? I am just worried that with thousands of states/actions/epochs I will run into performance problems where it may be useful to adapt the implementation depending on the situation.
12:26:33 <hpaste> Rc43 pasted “Mutable Arrays | Components of Graph” at http://hpaste.org/63999
12:26:34 <rwbarton> What is a2 in that type class?
12:26:55 <applicative> Paprikachu, they are here used just to avoid parens  f . g . h $ x = f (g (h x))
12:26:59 <hpaste> Rc43 pasted “Immutable Arrays | Components of Graph” at http://hpaste.org/64000
12:27:16 <o1iver> rwbarton: it is the container type that will contain the actual "rule"
12:27:26 <o1iver> rwbarton: for example a map
12:27:39 <applicative> Paprikachu: here is a more sensible printing with just whitespace between the primes http://ideone.com/XLW2F
12:27:39 <mux> dreixel: http://hackage.haskell.org/trac/ghc/ticket/5884
12:27:59 <Rc43> How to comment hpaste?
12:28:11 <Rc43> Annotate will replace or post as ne message?
12:28:15 <applicative> annotate Rc43
12:28:18 <Rc43> *new
12:28:22 <applicative> new message
12:28:28 <Rc43> thanks
12:28:29 <applicative> attached to the old
12:28:39 <rwbarton> Rc43: well one easy thing is use mapM_ instead of mapM
12:29:26 <Paprikachu> haskell is funny... a shortcut for everything
12:29:26 <applicative> Paprikachu: in that last one http://ideone.com/XLW2F I use $ on line 12 so I don't need parentheses map show (filter is_prime [1 .. n]).  It just means "applied to"
12:29:31 <hpaste> Rc43 annotated “Mutable Arrays | Components of Graph” with “Mutable Arrays | Components of Graph (annotation)” at http://hpaste.org/63999#a64001
12:29:50 <hpaste> Rc43 annotated “Immutable Arrays | Components of Graph” with “Immutable Arrays | Components of Graph (annotation)” at http://hpaste.org/64000#a64002
12:30:01 <b0fh_ua> Hi all! I need to get type Data.Text.Lazy.Internal from Data.Text. No clue how should I do that. Please advice
12:30:51 <parcs`> b0fh_ua: Data.Text.Lazy.fromStrict
12:31:02 <vodik> Paprikachu: i see you already have an answer, (phone) but here's my verion: http://ideone.com/8570z
12:31:03 <Rc43> eem, don't know how to paste -sstderr output, can't copy from terminal
12:31:16 <hpaste> o1iver pasted “multiparam tcs” at http://hpaste.org/64003
12:31:57 <hiptobecubic> Can someone explain the purpose of a function like   "fix f = f (fix f)".  What good does it do? Why would you ever want such a thing?
12:32:04 <o1iver> rwbarton: could you look at the Policy type class now? I mean that must be wrong right?
12:32:12 <rwbarton> that Policy is unusable
12:32:14 <o1iver> 5 type class parameters
12:32:32 <rwbarton> if you want to follow this path I recommend you look into associated types
12:32:52 <efie> before i post the question at SO ... i am little bit confused by what http://www.haskell.org/ghc/docs/latest/html/users_guide/ghci-dot-files.html says: am i looking for a .ghci file or a ghci.conf? which one is the GHCi startup file?
12:33:01 <rwbarton> though I don't really understand what you are trying to do
12:33:49 <o1iver> I am trying to keep the base data types as abstract as possible to support both State Int and State (Int,String,...) for example
12:34:03 <rwbarton> Rc43: did you try with mapM_?
12:34:14 <cmccann> hiptobecubic, well, why would you ever want a recursive function?
12:34:25 <o1iver> But I am pretty sure that I am approaching this wrongly because associated types are definitely over-engineering in this case
12:34:25 <geekosaur> efie, it's called .ghci on unix and ghci.conf on windows, per each OS's conventions
12:34:39 <efie> geekosaur: thanks!
12:34:41 <geekosaur> also it says "tries each of these files in order"
12:34:45 <rwbarton> as far as I can tell having these type classes at all is overengineering. but then, as I said, I don't know what you are trying to do
12:34:47 <geekosaur> the first one found is used
12:34:55 <efie> ok, sorry
12:34:58 <hiptobecubic> cmccann, well sometimes it's necessary, sure, but usually you want it to produce a result somehow
12:35:05 <Rc43> rwbarton, yes, the same
12:35:15 <rwbarton> Rc43, I don't know then
12:35:18 <cmccann> hiptobecubic, I'm not sure what you mean
12:35:21 <applicative> Paprikachu: vodik's is better than my hack of just deleting the first and last "[" and "]" as you would see on a very  long list....
12:36:14 <hiptobecubic> cmccann, fix f = f (fix f)   .. does this not just become f(f(f(f(f(......  ? When will anything be evaluated?
12:36:16 <Paprikachu> what's now wrong with that? http://ideone.com/F4oXM
12:36:38 <cmccann> hiptobecubic, it'll be evaluated when you need the result, just like anything else
12:36:41 <dmwit> hiptobecubic: No, it becomes f (fix f).
12:36:51 <dmwit> hiptobecubic: So f gets a chance to ignore the value (fix f) if it likes.
12:36:58 <applicative> Paprikachu: you are intecalating strings between integers, first you must map show over the integers
12:37:06 <hiptobecubic> dmwit, ahhh. hmmm ok
12:37:12 <Paprikachu> ah, right
12:37:13 <o1iver> rwbarton: yeah I agree with you. I will have to re-think this. Thanks!
12:37:21 <applicative> Paprikachu: so you can get a list of strings to intercalate "," between
12:37:45 <Paprikachu> http://ideone.com/KCx2a
12:37:47 <Paprikachu> yeah
12:38:23 <mux> > let fac = fix (\f n -> if n == 0 then 1 else n * f (n - 1) in fac 4 -- for hiptobecubic
12:38:24 <lambdabot>   <no location info>: parse error on input `in'
12:38:29 <mux> woops
12:38:32 <vodik> Paprikachu: spliting of the intercalate into its own function is a tad cleaner
12:38:34 <mux> > let fac = fix (\f n -> if n == 0 then 1 else n * f (n - 1)) in fac 4 -- for hiptobecubic
12:38:35 <applicative> Paprikachu: excellent you're already $ mad.  Soon you'll be f . g . h $ x crazed too....
12:38:35 <lambdabot>   24
12:38:43 <b0fh_ua> parcs`: thanks!
12:38:48 <mux> hiptobecubic: it works thanks to laziness
12:38:52 <vodik> applicative: hehe
12:39:15 <cmccann> though you can write a version of fix that doesn't need laziness, also
12:39:22 <mux> the same fixed-point combinator would necessarily diverge in a strict language
12:39:27 <mux> yes, of course
12:39:38 <mux> there are infinitely many fixed-point combinators, for strict and non-strict languages
12:39:57 <Paprikachu> http://ideone.com/BaHFu
12:41:02 <vodik> that works
12:41:21 <ChristianS> Paprikachu: cool, that already looks much more haskell-ish -- and shorter, too :-)
12:41:38 <Paprikachu> :)
12:41:44 <vodik> Paprikachu: if you want to get fancy, you can define joinList like this
12:41:49 <hpaste> Rc43 annotated “Mutable Arrays | Components of Graph” with “Mutable Arrays | Components of Graph (annotation) (annotation)” at http://hpaste.org/63999#a64005
12:41:51 <hpaste> Rc43 annotated “Immutable Arrays | Components of Graph” with “Immutable Arrays | Components of Graph (annotation)” at http://hpaste.org/64000#a64006
12:41:54 <hiptobecubic> mux, i see, thanks.
12:41:59 <vodik> Paprikachu: joinList s  = intercalate s . map show
12:42:22 <Rc43> (Just for completeness)
12:42:26 <Paprikachu> what does the . mean?
12:42:41 <vodik> function composition
12:42:48 <Paprikachu> hmm
12:42:49 <rwbarton> can you paste the program that generates connect.in?
12:43:34 <geekosaur> (g . f) x = g (f x) -- or g(f(x)) as it would be written in an algol-family language
12:43:41 <vodik> Paprikachu: a good read: http://learnyouahaskell.com/higher-order-functions
12:43:50 <Rc43> rwbarton, will try to find
12:44:47 <Rc43> rwbarton, http://pastebin.com/pCUHaMeQ
12:44:49 <mauke> The paste pCUHaMeQ has been copied to http://hpaste.org/64007
12:45:18 <dreixel> mux: cool, I'll look into it tomorrow
12:46:15 <applicative> Paprikachu: f . g . h $ x is the same as f $ g $ h $ x or f ( g ( h x)) but you can abstract it out, it's a function all by itself you could have a line j = f . g . h
12:46:33 <applicative> Paprikachu: and then write h x
12:46:42 <applicative> sorry, j x
12:46:42 <rwbarton> Rc43, I am just building with ghc -O2 --make -rtsopts and my timing results don't look anything like yours
12:47:32 <rwbarton> so possibly profiling has a larger overhead on the mutable array program for some reason, or possibly you've compiled it with the wrong options
12:47:43 <Rc43> rwbarton, can you tell me roughly your results?
12:47:52 <rwbarton> sure, I will append them to the pastes
12:47:53 <Paprikachu> hmm okay, i think i get it
12:48:07 <rwbarton> this is with n=300
12:48:13 <hpaste> rwbarton annotated “Mutable Arrays | Components of Graph” with “Mutable Arrays | Components of Graph (annotation) (annotation) (annotation)” at http://hpaste.org/63999#a64008
12:48:28 <hpaste> rwbarton annotated “Immutable Arrays | Components of Graph” with “Immutable Arrays | Components of Graph (annotation) (annotation)” at http://hpaste.org/64000#a64009
12:48:46 <applicative> Paprikachu: like so http://ideone.com/Zb40Y
12:48:51 <rwbarton> also I am on a 32-bit system now btw
12:49:40 <Rc43> rwbarton, ok, thanks
12:51:06 <efie> stackoverflow, there you go :)
12:51:10 <applicative> Paprikachu: what's up with (.) might be a little clearer if you first try (>>>) from Control.Arrow, which is the other way around http://ideone.com/DCjAs then it reads like a process
12:51:40 <Paprikachu> :D
12:52:09 <applicative> Paprikachu:  process =  filter isPrime >>> map show >>> intercalate "," >>> putStrLn could be read as "first I filter out the primes, then I map show over everything, then I put "," between, then I putStrLn it
12:52:35 <Paprikachu> yeah, i think i got it :)
12:53:05 <applicative> (.) is the same, it's just that the order corresponds to function application
12:55:24 <Rc43> rwbarton, what `-auto-all` does? Without it everything is ok (numbers in output are similar to yours, some are twice more (I am on 64 bit))
12:55:49 <Rc43> about auto-all found only http://hackage.haskell.org/trac/ghc/ticket/1934 and http://hackage.haskell.org/trac/ghc/ticket/2916
12:56:04 <rwbarton> -auto-all adds cost centers to every function or something
12:56:09 <rwbarton> without it you effectively aren't profiling
12:56:47 <cmccann> it adds cost centers to all top-level definitions I believe
12:57:13 <gregatIO> how can i configure emacs to display haskell lambdas using the symbol?
12:57:18 <gregatIO> i did it with python
12:57:26 <Rc43> rwbarton, yeah, now I see that output is without time/memory ratios
12:57:43 <gregatIO> i think it might be a bit tricky with haskell as it only has the \ symbol
12:57:52 <cmccann> otherwise you only get profiling based on manual annotations
12:58:02 <cmccann> you still need manual annotations for anything that's not a top-level binding though
13:00:19 <alpounet> gregatIO, it's just some option you have to trigger in the emacs-haskell mode
13:01:11 <mux> anyone knows why the deepseq package uses a class function of type a -> () rather than something seq-like: a -> b -> b ?
13:01:17 <Paprikachu> so.. what can i do next in haskell
13:03:14 <vodik> Paprikachu: try to implement a generic prime number sieve?
13:03:37 <vodik> Paprikachu: rather than division check. more interesting
13:03:41 <cmccann> mux, the deepseq function has the type you expect
13:04:14 <Paprikachu> hmm
13:04:21 <Paprikachu> sounds too complicated
13:04:22 <cmccann> mux, the type class function is just to tell it how to force stuff inside the type
13:04:28 <vodik> Paprikachu: http://en.wikipedia.org/wiki/Sieve_of_Eratosthenes
13:05:05 <hiptobecubic> Looking at select'', implemented with foldr, would that fold over the list from back to front, replacing the acc value each time a condition evaluates to true?    http://www.haskell.org/haskellwiki/Case
13:05:29 <efie> can encoding problems / issues with '\n' in a (itself correct) file occure if i even have not opend a file with a text editor?
13:05:36 <mux> cmccann: that's not answering the question; I want to know why they went with the rnf :: a -> () function rather than something that already has the same type as seq/deepseq
13:06:05 <mux> for example, maybe it optimized better
13:06:07 <hiptobecubic> That seems like a pretty poor way to do it, if so, which is why I'm asking.
13:07:16 <cmccann> mux, it would be superfluous
13:07:28 <rwbarton> hiptobecubic: foldr folds over the list from front to back
13:07:28 <Rc43> Is order of returned values splecified for such functions like `elems` for maps, sets, arrays?
13:07:46 <mux> cmccann: how so?
13:07:58 <Rc43> E.g. Array {(1,a),(2,b),(3,c)} _must_ return [a,b,c] ?
13:08:06 <cmccann> mux, because it would just return the second argument unchanged
13:08:25 <cmccann> it would just make the instance function slightly more complicated to write without giving any benefits
13:08:38 <mux> cmccann: that's what seq/deepseq do since day 1, provided the first one doesn't evaluate to bottom :-)
13:08:51 <mux> ah, so you find it more complicated? hmm.
13:09:31 <mux> then by your reasoning seq should be like rnf to begin with
13:09:44 <mux> I somehow doubt that is the reason why deepseq has been written this way.
13:09:54 <cmccann> er, ok
13:10:00 <cmccann> I really don't see what your point is
13:10:02 * cmccann shrugs
13:10:33 <Paprikachu> [22:03:16]	<vodik>	Paprikachu: rather than division check. more interesting
13:10:43 <mux> what point? I'm asking a question; that is, what is the original reasoning that led to the NFData class being designed this way
13:10:45 <Paprikachu> my algorithm is like a sieve
13:10:53 <Paprikachu> it skips multiples of 2 and 3
13:11:21 <vodik> Paprikachu: now do it for n > 3 :)
13:11:23 <Paprikachu> that's what the delta-parameter is for
13:11:46 <rwbarton> mux, perhaps roughly 20 years ago or whenever 'seq' was introduced, people had different aesthetics than they do now
13:11:49 <mux> given that the seq functions is in the Prelude, it seems more natural to have the class function be of the same type. I was suspecting optimization reasons, as is someone on haskell-cafe, but maybe someone in here can speak authoritatively on this
13:12:00 <mux> rwbarton: perhaps indeed
13:12:19 <Paprikachu> it adds 2, then 4, then 2 and so on to i
13:12:30 <rwbarton> personally I do think a -> () is nicer than a -> b -> b, for the purpose of defining a notion of how much to evaluate something
13:12:31 <Paprikachu> and checks with modulo
13:12:36 <cmccann> mux, the type of seq and deepseq are more natural for use in expression context
13:12:39 <rwbarton> but just for aesthetic/simplicity reasons
13:12:50 <cmccann> but not at all more natural for defining what the rnf operation does
13:13:07 <cmccann> mux, as far as I can see you're asking why it was designed in the most obvious way, so all I can do is shrug
13:13:10 <mulander> re all
13:13:17 <mulander> I have my problem much more pinpointed.
13:13:40 <mux> cmccann: for now you're the only person I've talked with on this point that is of the opinion that this way is more natural
13:13:49 <mulander> I generally need to pass this raw command to cmd.exe:   "cmd.exe /v:on /c "some_command & exit !errorlevel!" in order to get the actual exit code.
13:14:04 <rwbarton> mux, you can count me also
13:14:07 <mulander> but rawSystem runs the thing through translate which breaks my quotes around both commands.
13:14:09 <rwbarton> but I don't have a strong feeling about it
13:14:12 <mux> rwbarton: noted :)
13:14:12 <vodik> Paprikachu: right, but as i understand it, you're building a list
13:14:29 <vodik> Paprikachu: the seive is about reducing one, removing all non primes
13:14:36 <mulander> so how can I avoid this as the current implementation of system and rawSystem in ghc ignore the actual exit codes from commands being run?
13:14:41 <Paprikachu> that'd me easier
13:14:44 <Paprikachu> be
13:15:09 <Paprikachu> i could combine both algorithms
13:15:22 <mux> so you two find the form a -> (), which is most useful in monadic code, more natural than the a -> b -> b form, most useful in non-monadic code? I find that surprising :-)
13:15:37 <cmccann> it's more natural for defining the operation
13:15:38 <mulander> anyone?
13:15:41 <cmccann> I don't think you'd ever use it otherwise
13:15:49 <mux> I dare say you have a dangerous tendency towards imperativeness :D
13:15:57 * mux grins
13:15:59 <cmccann> that's why the function named "deepseq" is the one with the sensible type
13:16:00 <rwbarton> I don't see what this has to do with monadic code...?
13:16:25 <cmccann> mux, monadic code has nothing to do with anything
13:16:39 <cmccann> and the rnf function wouldn't be useful there anyway
13:16:44 <efie> applicative, lispy you were right, the developer of hlint just answered that it's probably a bug due to the changed ghci 7.0 syntax
13:17:03 <mux> well maybe that wasn't the best way to put it, but that was a joke anyways
13:17:15 <cmccann> mux, also I already explained why rnf is more natural for defining the operation, rather than for using it
13:19:03 <mux> cmccann: I don't see how you've explained anything; you've expressed your subjective opinion on it (and I'm interested in it!)
13:19:19 <hiptobecubic> rwbarton, ok so it goes from front to back but it is still replacing the acc each time a condition evaluates to true?
13:19:32 <rwbarton> nothing is replaced
13:19:57 <rwbarton> it only uses the "next" accumulator if the condition is false
13:20:32 <cmccann> mux, ok, whatever
13:20:34 <cmccann> suit yourself
13:20:40 <cmccann> I'm going back to doing something useful
13:21:15 <rwbarton> actually, wait, what is this doing
13:21:23 <rwbarton> :t if'
13:21:24 <lambdabot> Not in scope: `if''
13:21:36 <rwbarton> @let if' True x _ = x; if' False _ y = y
13:21:37 <lambdabot>  Defined.
13:22:04 <rwbarton> oh right, I see
13:22:18 <rwbarton> > foldr (uncurry if') [(False, 1), (True, 2), (False, 3), (True, 4)]
13:22:19 <lambdabot>   Overlapping instances for GHC.Show.Show
13:22:19 <lambdabot>                              ([(GHC...
13:22:23 <Paprikachu> @let fib 0 = 1
13:22:24 <lambdabot>  Defined.
13:22:28 <Paprikachu> @ let fib 1 = 1
13:22:39 <rwbarton> :t foldr (uncurry if') [(False, 1), (True, 2), (False, 3), (True, 4)]
13:22:40 <lambdabot> forall t. (Num t) => [(Bool, [(Bool, t)])] -> [(Bool, t)]
13:22:53 <Paprikachu> @let fib n = fib (n - 1) + fib (n - 2)
13:22:54 <lambdabot>  Defined.
13:22:58 <Paprikachu> @let fib 1 = 1
13:22:58 <lambdabot>  <local>:3:0:
13:22:59 <lambdabot>      Warning: Pattern match(es) are overlapped
13:22:59 <lambdabot>               In...
13:23:00 <rwbarton> oh
13:23:04 <rwbarton> > foldr (uncurry if') 5 [(False, 1), (True, 2), (False, 3), (True, 4)]
13:23:05 <lambdabot>   2
13:23:07 <Paprikachu> huh
13:23:19 <hiptobecubic> hmm
13:23:20 <Paprikachu> > fib 5
13:23:22 <lambdabot>   *Exception: stack overflow
13:23:28 <Paprikachu> ;_;
13:23:34 <Landarzar> @let fib 0 = 1; fib 1 = 1; fib n = fib (n-1) + fib (n-2)
13:23:35 <lambdabot>  <local>:3:0:
13:23:35 <lambdabot>      Warning: Pattern match(es) are overlapped
13:23:35 <lambdabot>               In...
13:24:01 <JoeyA> > let fib 0 = 0; fib 1 = 1; fib n = fib (n-1) + fib (n-2) in fib 5
13:24:02 <lambdabot>   5
13:24:08 <JoeyA> > let fib 0 = 0; fib 1 = 1; fib n = fib (n-1) + fib (n-2) in fib 10
13:24:09 <lambdabot>   55
13:24:13 <JoeyA> > let fib 0 = 0; fib 1 = 1; fib n = fib (n-1) + fib (n-2) in fib 50
13:24:17 <Paprikachu> wat
13:24:17 <lambdabot>   mueval-core: Time limit exceeded
13:24:44 <Paprikachu> >42
13:24:44 <Rc43> Can I map list of values using Map or IntMap?
13:24:47 <JoeyA> Paprikachu: I'm using let...in expressions, rather than defining separate bindings with lambdabot's @let.
13:25:00 <JoeyA> @hoogle Data.Map.map
13:25:01 <lambdabot> Data.Map module Data.Map
13:25:01 <lambdabot> Data.Map data Map k a
13:25:01 <lambdabot> Data.Map map :: (a -> b) -> Map k a -> Map k b
13:25:06 <JoeyA> @hoogle Data.Map.mapMonotonic
13:25:07 <Paprikachu> yes, but why doesnt it give an error
13:25:09 <lambdabot> No results found
13:25:26 <blbrown_win3> > fib4
13:25:27 <lambdabot>   Not in scope: `fib4'
13:25:28 <blbrown_win3> > fib 4
13:25:31 <lambdabot>   *Exception: stack overflow
13:25:41 <JoeyA> Paprikachu: When you defined bindings earlier, you said fib n = ..., then you said fib 0 = ...
13:25:47 <hiptobecubic> rwbarton, i guess i'm just not "seeing" how it actually works.
13:25:56 <JoeyA> Since lambdabot still remembers fib n, it complained.
13:25:59 <blbrown_win3> @let ff x = x
13:26:00 <lambdabot>  Defined.
13:26:02 <blbrown_win3> ff 3
13:26:14 <blbrown_win3> > ff 3
13:26:16 <lambdabot>   3
13:26:17 <rwbarton> if' is getting its first two arguments from each element of the list of pairs; the third argument is what you are calling the "accumulator"
13:26:21 <blbrown_win3> sorry I was just testing
13:26:25 <JoeyA> Paprikachu: However, when I used a let ... in expression, the let expression formed a scope, so fib could shadow the fib already defined.
13:26:27 <JoeyA> :t fib
13:26:28 <lambdabot> forall t t1. (Num t, Num t1) => t -> t1
13:26:45 <Paprikachu> @let fib n | n == 0 = 0 | n == 1 = 1 | otherwise = fib (n - 1) + fib (n - 2)
13:26:45 <lambdabot>  <local>:6:0:
13:26:45 <lambdabot>      Multiple declarations of `L.fib'
13:26:45 <lambdabot>      Declared at: <local>...
13:26:50 <hiptobecubic> (uncurry if') takes a default value and a (bool, val)
13:26:52 <Paprikachu> @unlet fib
13:26:52 <lambdabot>   TemplateHaskell is not enabled
13:26:56 <Paprikachu> :<
13:26:57 <rwbarton> if the Bool is true, then if' just returns the associated value, and we never examine the "accumulator" or the rest of the input list
13:27:00 <JoeyA> pfft
13:27:01 <Paprikachu> how can i delete it
13:27:03 <JoeyA> @unlet
13:27:04 <lambdabot>  Defined.
13:27:06 <JoeyA> lol
13:27:10 <JoeyA> @undef
13:27:15 <JoeyA> There, all cleared out.
13:27:20 <Paprikachu> @let fib n | n == 0 = 0 | n == 1 = 1 | otherwise = fib (n - 1) + fib (n - 2)
13:27:21 <lambdabot>  Defined.
13:27:23 <rwbarton> if the Bool is false, then we return the "accumulator" which means we recurse on the rest of the list.
13:27:27 <Paprikachu> > fib 10
13:27:28 <lambdabot>   55
13:27:46 <mux> > fib (-1)
13:27:48 <lambdabot>   *Exception: stack overflow
13:27:57 <JoeyA> You could say: fib 0 = 0; fib 1 = 1; fib n = fib (n-1) + fib (n-2)
13:27:59 <hiptobecubic> rwbarton, the accumulator is remaining list?
13:28:30 <Paprikachu> @undef fib
13:28:33 <Paprikachu> @undef
13:28:34 <rwbarton> the accumulator is the result of calling foldr (uncurry if') default on the rest of the list
13:28:39 <Paprikachu> @unlet
13:28:40 <lambdabot>  Defined.
13:28:44 <Paprikachu> huh
13:28:45 <rwbarton> it's not really an accumulator at all
13:28:49 <Paprikachu> > fib 5
13:28:49 <lambdabot>   Not in scope: `fib'
13:29:01 <Paprikachu> @let fib n | n == 0 = 0 | n == 1 = 1 | otherwise = fib (n - 1) + fib $ n - 2
13:29:01 <lambdabot>  <local>:2:60:
13:29:01 <lambdabot>      Occurs check: cannot construct the infinite type: t = a -...
13:29:16 <rwbarton> (at least in this instance)
13:29:28 <rwbarton> since the only thing we ever do with it is ignore it or return it unchanged
13:30:46 <cmccann> mux, btw, my apologies for being a bit rude, I'm currently frustrated due to something else and feeling irritable
13:31:02 <Paprikachu> > a = if
13:31:03 <lambdabot>   <no location info>: parse error on input `='
13:31:21 <JoeyA> Paprikachu: $ binds loosely, so what you're saying is: (fib (n - 1) + fib) (n - 2)
13:31:51 <Paprikachu> hm, okay
13:32:03 * hackagebot JsonGrammar 0.3.2 - Combinators for bidirectional JSON parsing  http://hackage.haskell.org/package/JsonGrammar-0.3.2 (MartijnVanSteenbergen)
13:32:12 <mux> cmccann: much appreciated; and no worries, that kind of things happen ;-)
13:34:40 <Paprikachu> how old are you guys?
13:35:53 <Jesin> Umm, there was something about GHC 7.2 being experimental-ish
13:35:57 <Jesin> does this also apply to GHC 7.4?
13:36:25 <Axman6> Jesin: not as much. some of the new features are experimental and incomplete though
13:36:31 <mux> cmccann: I'm still unsure what to do; I was asking this because of my generic deepseq implementation using GHC.Generics where I used a class function with a seq-like type; I don't really mind one way or the other, but I was hoping there was a more substantial reason for the original author to have written things that way, rather than just subjective feelings over whether one or the other feels more natural
13:37:43 <mux> at least, using a seq-like formulation, the definition composes nicely for product types
13:38:36 <Jesin> hm, okay.
13:40:04 <cmccann> mux, well, both forms are trivially equivalent and rnf is objectively simpler to implement...
13:41:41 <mux> cmccann: objectively simpler? really, I have read the deepseq code exhaustively, and it doesn't look any simpler to me
13:43:04 <mux> I wish the original author would pop out on haskell-cafe and explain he found that using an rnf-like formulation optimized better with GHC or something, so that I can be done with this choice
13:43:45 <cmccann> given that they're obviously equivalent I'm not sure it's really a significant choice
13:44:14 <cmccann> and yes, I would say that fewer arguments and fixed return value is "simpler to implement" when writing instances
13:44:55 <rwbarton> I suppose a -> b -> b is like a CPS transformed a -> () perhaps?
13:45:07 <Saizan> yep
13:45:26 <mux> cmccann: mmm, I think I see what you mean
13:46:21 <cmccann> rwbarton, (b -> b) is the church encoding of () I suppose
13:47:02 <mux> the thing about the extra argument is that you don't really bother with it in practice for defining instances
13:47:07 <mux> for example, my product type instance is
13:47:21 <mux> deepseq (x :*: y) = deepseq y . deepseq x
13:47:46 <mux> but yeah, I think I see why one would find an rnf-like formulation simpler indeed
13:47:55 * mux scratches head some more
13:48:21 <rwbarton> I wouldn't be too surprised if the a -> b -> b formulation was more efficient in some way
13:48:21 <cmccann> you could have both rnf and deepseq in the class and interdefine them, but then you'd lose the default definition based on seq
13:48:28 <rwbarton> I also wouldn't expect it to be a very noticeable difference
13:48:36 <mux> plus I don't have to use `seq` in my instances to force evaluation; that is also simpler in some way
13:48:52 <cmccann> I'd be slightly surprised if any difference between the two forms survived GHC's optimizer
13:48:56 <mux> but really, the difference is so thin...
13:49:47 <rwbarton> do you think (a `seq` ()) `seq` b gets optimized to a `seq` b?
13:50:03 <rwbarton> or equivalent, the point is to not allocate anything for the ()
13:50:10 * mux has no idea
13:50:23 <rwbarton> seems like optimizations around `seq` could be tricky
13:50:39 <Rc43> argh, test system couldn't even compile my code (ghc 6.10.1)
13:51:30 <cmccann> rwbarton, might actually be simpler in some cases, since GHC will know exactly what should be forced
13:51:37 <cmccann> gives the strictness analyzer more to work with
13:52:00 <mux> I should probably start actually benchmarking stuff using Criterion.
13:54:51 <jtobin> anyone: getting an illegal instance declaration when trying to install template-haskell via cabal
13:54:57 <jtobin> any way to figure out what it's conflicting with?
13:55:54 <dcoutts> rwbarton: find out, look at the core. It's not so hard.
13:56:31 <mux> mmm, it looks like it should be possible to write an Arbitrary instance for representation types, to generate random types :D now that would be fun!
13:56:59 <mux> and an awesome way to QuickCheck generic code
13:57:44 <mux> except that I can't do that the way GHC.Generics is defined right now, I think
13:58:08 <mux> we would need a GADT-based representation or something
13:58:30 <hpaste> Rc43 pasted “Build failed.” at http://hpaste.org/64010
13:58:45 <Rc43> Is it about old version of `containers` package?
13:59:07 <jtobin> will take a look, thx
13:59:08 <Rc43> I am afraid to install ghc 6.10.2 with other version.
14:00:04 <rwbarton> Rc43: this looks like what happens when you build without --make, in old (pre-7?) ghc
14:00:06 <dreixel> mux: a generic Arbitrary has been recently submitted as a patch to quickcheck
14:00:32 <mux> dreixel: whoa, awesome! how was it done? I was _just_ thinking that maybe having N instances for M1, K1, etc, and a newtype wrapper may be sufficient :-)
14:00:34 <Rc43> rwbarton, it is not my build, it was building on online test system
14:00:55 <Rc43> rwbarton, I can't look inside, only ask system maintainer
14:02:11 <rwbarton> I'd ask the system maintainer to build with --make -- or preferably update ghc :)
14:02:47 <Rc43> rwbarton, yeah, ghc 6.10 is about 3 years old
14:03:33 <dreixel> mux: well, this was the basis: http://hpaste.org/63806
14:03:37 <morel> is there a function "func f x = f x >>= func f" ?
14:03:44 <dreixel> but then he refined, added a shrink, etc.
14:03:49 <Rc43> rwbarton, but it seems I can refactor code without IntSet and IntMap and it will be compiled
14:04:10 <mux> dreixel: thanks!
14:04:23 <Rc43> rwbarton, because there are words about them in right part of every line :)
14:04:23 <dreixel> can't seem to find the latest version
14:04:28 <dreixel> or remember the name of who did it :-(
14:04:55 <rwbarton> oh, just regular Set/Map do work?
14:04:57 <mux> dreixel: oh but that wasn't what I was talking about
14:05:10 <Rc43> rwbarton, didnt try yet
14:05:26 <Rc43> rwbarton, but it will be slower :(
14:05:44 <blbrown_win3> does eclipse-fp have a freenode channel?  If not, I just installed it, is there any reason I wouldn't get any syntax highlighting
14:05:46 <mux> dreixel: that patch allows to write Arbitrary instances automatically for a given type, given its generic representation, right? I meant to generate arbitrary representation types, for generating random types (not random values for a given type)
14:06:13 <dreixel> mux: ohhh, I see
14:06:23 <Rc43> rwbarton, btw why --make can make sense?
14:06:43 <rwbarton> ?
14:06:54 <mux> this patch is very cool nonetheless
14:06:55 <rwbarton> I can't parse that
14:07:24 <adimit> erm… something strange: hackage reports unsafeFixIO to be here: http://hackage.haskell.org/packages/archive/base/latest/doc/html/System-IO-Unsafe.html, i.e. in System.IO.Unsafe, but my GHC version (7.0.3) doesn't seem to agree. Is it a recent addition?
14:07:38 <Rc43> rwbarton, why code can be compiled with flag `--make` but not without it?
14:07:39 <ivanm> adimit: yes
14:07:47 <ivanm> got added in 7.2, refined in 7.4
14:07:53 <adimit> ivanm: got it, updating ghc and haskell-platform now. Thanks.
14:08:02 <rwbarton> '--make' means 'link the resulting object file against whatever libraries it needs'
14:08:08 <rwbarton> otherwise you had to specify them manually
14:09:08 <ivanm> though as of 7.0, --make is the default
14:09:36 <Rc43> rwbarton, understood
14:12:05 * hackagebot netspec 0.2.0.0 - Simplify static Networking tasks  http://hackage.haskell.org/package/netspec-0.2.0.0 (DanBurton)
14:14:17 <morel> is there a monadic function similar to "func f x = f x >>= func f" ?
14:14:31 <morel> @let func f x = f x >>= func f
14:14:32 <lambdabot>  Defined.
14:14:35 <morel> :t func
14:14:36 <lambdabot> forall a (m :: * -> *) b. (Monad m) => (a -> m a) -> a -> m b
14:14:59 <sipa> :t foreverM
14:15:00 <lambdabot> Not in scope: `foreverM'
14:15:09 <sipa> :t forever
14:15:09 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m a -> m b
14:15:40 <morel> @src forver
14:15:41 <lambdabot> Source not found. Your mind just hasn't been the same since the electro-shock, has it?
14:15:46 <morel> @src forever
14:15:46 <lambdabot> Source not found. You type like i drive.
14:16:07 <morel> sipa: forever is rather like "forever x = x >> forever x"
14:16:22 <pcavs> What's the proper way to print out a list of Strings in the IOMonad? basically something like map putStrLn ["string1" "string2" "string3" ...]
14:16:38 <morel> mapM_
14:16:40 <morel> pcavs: ^
14:16:52 <morel> @hoogle sequence
14:16:52 <lambdabot> Prelude sequence :: Monad m => [m a] -> m [a]
14:16:53 <lambdabot> Control.Monad sequence :: Monad m => [m a] -> m [a]
14:16:53 <lambdabot> Prelude sequence_ :: Monad m => [m a] -> m ()
14:16:55 <vodik> or forM_ tehncially
14:17:04 <pcavs> thanks morel
14:17:06 <pcavs> et al.
14:17:30 <morel> vodik: forM_ = flip mapM_ -- right?
14:17:35 <morel> @src forM_
14:17:35 <lambdabot> forM_ = flip mapM_
14:17:38 <morel> heh
14:17:45 <vodik> yeah mapM class of functions are implemented via sequence
14:17:47 <Paprikachu> @src map
14:17:48 <lambdabot> map _ []     = []
14:17:48 <lambdabot> map f (x:xs) = f x : map f xs
14:17:50 <vodik> morel: more or less
14:17:57 <vodik> @src mapM_
14:17:58 <lambdabot> mapM_ f as = sequence_ (map f as)
14:18:01 <morel> vodik: there are more differences?
14:18:22 <vodik> morel: its nicer to be able to write forM_ array $ do ...
14:18:27 <vodik> if you have a block of code
14:18:35 <morel> vodik: thats right
14:20:55 <morel> wow. it'd be great if i could type following in GHCI (and it'd work)(!):
14:20:58 <morel> > let (dropWhile (/='b') "foobar")@(_:t) in t
14:21:00 <lambdabot>   <no location info>: parse error on input `@'
14:21:04 <morel> hehe
14:21:47 <mauke> > let _:t = dropWhile (/= 'b') "foobar" in t
14:21:48 <lambdabot>   "ar"
14:22:30 <morel> mauke: wow! great!
14:23:12 <morel> mauke: so, actually, in my code "@" is like "flip =", right? hehe, lol xD
14:24:18 <mauke> > let map _ [] = []; map f ((f -> y) : (map f -> ys)) = y : ys in ()
14:24:19 <lambdabot>   ()
14:24:49 <morel> wtf
14:26:55 <Rc43> How can I transform [1,2,1,1,5,8,2] to [1,2,1,1,3,4,2] fast and without Map?
14:27:05 * hackagebot tremulous-query 1.0.4 - Library for polling Tremulous servers  http://hackage.haskell.org/package/tremulous-query-1.0.4 (ChristofferOjeling)
14:27:34 <sipa> > (const [1,2,1,1,3,4,2]) [1,2,1,1,5,8,2]
14:27:35 <lambdabot>   [1,2,1,1,3,4,2]
14:27:36 <otters> is there a specific thing you're trying to do there?
14:27:38 <ivanm> > let transformList [1,2,1,1,5,8,2] = [1,2,1,1,3,4,2] in transformList [1,2,1,1,5,8,2]
14:27:39 <lambdabot>   [1,2,1,1,3,4,2]
14:27:39 <sipa> Rc43: extremely fast!
14:27:40 <otters> cause uh
14:27:40 <otters> yeah
14:27:50 <Rc43> sipa, lol
14:27:52 <mauke> it's defrag
14:28:11 <sipa> Rc43: what is it supposed to do for other input?
14:28:28 <Rc43> sipa, you mean what is common rule?
14:28:37 <otters> what's the algorithm
14:28:46 <otters> yes, the common rule
14:28:47 <otters> what is it
14:29:16 <vodik> Rc43: celeing of x / 2 when x > 2
14:29:18 <vodik> ?
14:29:19 <ivanm> the common rule is http://en.wikipedia.org/wiki/Common_rule :p
14:29:29 <Rc43> DIfferent elements must stay different, in new list elements must be numbered by [1..n]
14:29:35 <otters> ...
14:29:50 <Rc43> vodik, lol, no, sorry :)
14:29:52 <vodik> Rc43: okay, let me phrase the question this way
14:29:58 <vodik> Rc43: how would you do it with a map?
14:30:00 <vodik> Rc43: show us that
14:30:55 <hpaste> Rc43 pasted “Normalizing list” at http://hpaste.org/64011
14:31:33 <otters> S == Data.Set?
14:31:46 <Rc43> Yes, and M = Map
14:31:49 <Rc43> I just have to remove Map/IntMap/Set/IntSet using.
14:32:05 <mauke> Rc43: why?
14:32:22 <Rc43> mauke, online test system has old ghc :)
14:32:30 <mauke> how old?
14:32:34 <Rc43> 6.10.1
14:32:40 <mauke> that's not old
14:32:57 <mauke> I'm pretty sure I used Map in 6.8
14:33:00 <Rc43> may be, bu it talks strange error about containers lib.
14:33:01 <otters> oh I get it
14:33:23 <otters> wait, no I do not get it
14:33:40 <otters> well I kinda do
14:34:06 <ivanm> IIRC, 6.8 was when containers was split out of base
14:34:23 <otters> whenever you find an element in the list that hasn't appeared there before
14:34:25 <vodik> wait, you can run map over M.Map?
14:34:28 <otters> it has to be (max list) + 1
14:34:36 <otters> if not, replace it with that
14:34:46 <otters> so [1,2,1,5] would become [1,2,1,3]
14:35:35 <Jafet> You can run M.map over M.Map
14:35:56 <Jafet> @instances-importing Data.Map Functor
14:35:56 <lambdabot> ((,) a), ((->) r), ContT r m, Either a, ErrorT e m, IO, Map k, Maybe, RWST r w s m, ReaderT r m, ST s, StateT s m, WriterT w m, []
14:37:33 <Rc43> Jafet, I need a list
14:37:47 <Rc43> @src Data.Map.map
14:37:47 <lambdabot> Source not found.
14:38:28 <SubtleArray> Hey folks. ^_^ The "interface" for my Haskell program is done! This wouldn't have been possible without the help I received here. Thank you, thank you!
14:38:40 <Jafet> @type M.fromList
14:38:41 <lambdabot> forall k a. (Ord k) => [(k, a)] -> M.Map k a
14:38:44 <Jafet> @type M.toList
14:38:45 <lambdabot> forall k a. M.Map k a -> [(k, a)]
14:39:05 <Rc43> Jafet, ant then I must cut keys, its quite long
14:39:37 <Rc43> otters, didn't understand your solution
14:39:43 <otters> hang on
14:41:01 <Rc43> otters, btw, nub will be bad, its O(n^2)
14:41:52 <Jafet> Rc43: try doing it by hand
14:42:01 <otters> I'm working on a solution myself
14:43:57 <Jafet> > take 20 $ unfoldr (\(g, i) -> let (x, g') = randomR (0, i) g in Just (x, (g, i+1))) (mkStdGen 1337, 1)
14:43:57 <lambdabot>   [1,2,1,1,5,0,1,2,1,5,5,0,7,11,1,16,11,17,1,14]
14:44:05 <Jafet> > take 20 $ unfoldr (\(g, i) -> let (x, g') = randomR (0, i) g in Just (x, (g, i+1))) (mkStdGen 31337, 1)
14:44:06 <lambdabot>   [1,2,1,1,5,3,1,2,1,4,5,0,3,11,1,2,11,17,1,17]
14:44:17 <Jafet> Is this generator really bad or what.
14:44:34 <Rc43> Jafet, we could generate randoom enumeration and compare for correct order! :D
14:45:05 <Jafet> You could work out an algorithm for random inputs and implement it for all inputs.
14:50:51 <Rc43> otters, I have invented, how to do it for about O(n*n/2)
14:50:58 <Rc43> (simple way)
15:00:18 <otters> Rc43: I solved it
15:01:19 <Rc43> otters, as yet I solved only with list of pairs instead of map and getting unique values with `elem`.
15:01:36 <otters> I used max
15:02:35 <otters> err, maximum
15:02:38 <otters> what performance does maximum have?
15:02:53 <Sgeo> @pl \a -> \b -> c -> c b a b
15:02:53 <lambdabot> (line 1, column 15):
15:02:53 <lambdabot> unexpected ">" or "-"
15:02:53 <lambdabot> expecting variable, "(", operator or end of input
15:02:53 <Rc43> otters, and have idea about that we can use for loop from 1 to n and check number for being member of list, if not then we take number that is in list and replace it with first one. Yes, it is hard to parse.
15:02:58 <Sgeo> @pl \a -> \b -> \c -> c b a b
15:02:59 <lambdabot> join . (flip .) . flip (flip . flip id)
15:03:37 <hpaste> otters pasted “rc43” at http://hpaste.org/64012
15:03:42 <otters> ^
15:03:58 <otters> haha l@ isn't necessary
15:04:52 <Rc43> otters, I think `max` is O(n), why it can be other?
15:05:39 <Rc43> > normalize = reverse . normalize' . reverse
15:05:39 <lambdabot>   <no location info>: parse error on input `='
15:05:40 <Rc43> lol
15:05:43 <Rc43> what is it?
15:06:12 <geekosaur> you can't create top level definitions that way in lambdabot
15:06:46 <Rc43> btw, normalize [6] is [1], otters?
15:07:06 <Rc43> I mean, your normalize isn't so, right?
15:09:04 <otters> it should be?
15:09:25 <Sgeo> Is Liskell's REPL fully-featured in allowing data definitions etc.?
15:09:31 <Sgeo> Or is it as limited as normal GHCi?
15:09:31 <otters> because if it needs to be [1] just change normalize' [x] = [x] to normalize' [x] = [1]
15:09:47 <Jafet> In Glasgow Haskell, normalize' probably takes exponential time.
15:10:13 <otters> how?
15:10:14 <alpounet> Sgeo, GHCi isn't limited anymore, to that regard
15:10:20 <Jafet> normalize' xs may be evaluated twice.
15:10:29 <otters> it might?
15:10:40 <otters> oh, yeah
15:10:40 <Jafet> You wrote it twice.
15:10:43 <otters> it sure might
15:10:52 <otters> wow I'm a real power user
15:11:38 <hpaste> otters pasted “rc43 revised” at http://hpaste.org/64013
15:12:07 * hackagebot tremulous-query 1.0.5 - Library for polling Tremulous servers  http://hackage.haskell.org/package/tremulous-query-1.0.5 (ChristofferOjeling)
15:12:24 <jhance_> I appear to be unable to load LLVM in ghci; I get Loading package llvm-base-3.0.0.0 ... can't load .so/.DLL for: lib.so (lib.so: cannot open shared object file: No such file or directory)... Any ideas? Why is it trying to load "lib.so" (obviously wrong). It works from a compiled executable
15:12:47 <Rc43> otters, yea, i didn't talk about it, but in my code [2,3,4,5] will be transformed to [1,2,3,4]
15:12:55 <otters> oh, well, that's nice to know
15:13:09 <otters> well the revised version does that now
15:13:10 <dcoutts> jhance_: iirc, LLVM doesn't supply shared libs, and loading the static libs in GHCi does not work
15:13:17 <otters> and it doesn't evaluate normalize' xs twice!
15:14:44 <Rc43> otters, second is good, but for what there is double reversing?
15:14:50 <otters> what?
15:15:04 <Rc43> normalize = reverse . normalize' . reverse
15:15:07 <otters> yeah
15:15:11 <Rc43> for what it?
15:15:15 <jhance_> dcoutts: But why would it be trying to load lib.so in the first place? This is kind of dissapointing but I understand the issue. Any way to get the shared libraries made?
15:15:21 <otters> well, normalize' takes a reversed list for pattern matching and because (:) is faster than (++)
15:15:27 <Jafet> It is required for the program to work as intended, Rc43
15:15:35 <otters> as far as I know you can't do (:) in reverse
15:15:36 <dcoutts> jhance_: you need to build llvm with the shared libs option
15:15:48 <dcoutts> jhance_: the C llvm libs I mean
15:15:51 <otters> also hpaste's Steps feature appears to be b0rked
15:15:58 <Rc43> Jafet, I know, but I can't get why
15:16:18 <dcoutts> jhance_: check what "ghc-pkg llvm describe" says for extra-libraries and extra-ghci-libraires
15:16:29 <Rc43> list transformation doesn't depend on first order
15:16:32 <Jafet> Clearly, normalize' is intended to operate on the reversed list, producing a reversed result.
15:16:36 <Rc43> only on numbers
15:17:16 <Jafet> You seem really confused.
15:17:44 <jhance_> dcoutts: Yeah, ghc-pkg describe llvm-base shows them all. I guess I will edit the ebuild for LLVM and add a useflag...
15:17:54 <Jafet> normalize [1,2,3,4] does not equal normalize [4,3,2,1].
15:19:11 <sdklfjsldkfj> is it better to say "liftA2 (,) [x1..x2] [y1..y2]" or "(,) <$> [x1..x2] <*> [y1..y2]" or something else?
15:19:49 <jhance_> dcoutts: Will the shared install of llvm also install static? Ideally I want both :\
15:20:09 <Rc43> Ha
15:20:13 <dcoutts> jhance_: I think so
15:20:17 <Rc43> I catched the bug
15:20:27 <jhance_> dcoutts: Wait, this is weird... The ebuild already enables shared
15:20:27 <Rc43> normalize [8,2,3,4,5,7,8] = [1,2,3,4,5,6,7]
15:20:33 <ciaranm> haskell doesn't have "catch". did you mean "monaded"?
15:20:42 <Rc43> ciaranm, :D
15:21:01 <Rc43> But normalize [8,2,3,4,5,7,8] must be [1,2,3,4,5,6,1]
15:21:04 <jhance_> dcoutts: I don't have any shared libraries in /usr/lib/llvm though...
15:21:22 <Rc43> or other numeration, but, first and last must be the same
15:21:41 <jhance_>  dcoutts: Actually, I have a monolithic shared object. Can I force ghcii to use the monolithic version with horrible black magic?
15:21:55 <otters> @type (:::)
15:21:56 <lambdabot> Not in scope: data constructor `:::'
15:22:07 * hackagebot apelsin 1.2 - Server and community browser for the game Tremulous  http://hackage.haskell.org/package/apelsin-1.2 (ChristofferOjeling)
15:22:56 <Jafet> Rc43: how do you expect to do this without using Set or Map?
15:23:01 <jhance_> dcoutts: Obviously I can do -lLLVM-3.0 at the start of ghcii but it still tries to load lib.so and fails even though it should have all the linked items it needs
15:23:21 <Jafet> This doesn't border on silly, this is mass immigration
15:23:30 <Rc43> Jafet, by imitating map with [(k,v)], but it is bad
15:23:53 <otters> lazy evaluation rocks
15:23:55 <dcoutts> jhance_: the extra-ghci-libraries is for that purpose. If it's not blank then it replaces the extra-libraires. So lets you use totally separate set for ghci
15:23:55 <Rc43> jafet, or by bruteforce by [1..n]
15:23:58 <Jafet> Finding duplicates in a sequence is generally as difficult as sorting.
15:24:13 <otters> First and last have to be the same?
15:24:17 <otters> why did nobody tell me
15:24:23 <jhance_> dcoutts: Can I modify that without modifying llvm-base itself?
15:24:29 <Rc43> Jafet, you don't need to remember them and return, only replace
15:24:33 <Jafet> If it is to be done efficiently, you must use some form of sorting algorithm.
15:24:47 <dcoutts> jhance_: you can re-register the package using ghc-pkg
15:25:23 <Jafet> You need to find them before replacing them.
15:25:36 <Rc43> otters, sorry, examples were bad
15:25:38 <Jafet> In any case, it's easy to prove that they're equivalent
15:25:52 <otters> agreed
15:26:31 <Rc43> Jafet, finding them is stronger problem, because by solving it we get not only duplicated but their count too
15:27:36 <Jafet> Even the problem of determining whether a list contains any duplicates is generally as difficult as sorting.
15:28:08 <Jafet> Given a normalisation xs, you can simply scan through the list and see if xs!!i /= i.
15:28:23 <jhance_> dcoutts: Does ghci not honor the extra library directories? It tried to load the right SO this time but can't find it
15:28:37 <Jafet> Actually, that gives you a count of duplicates anyway.
15:28:38 <dcoutts> jhance_: should do
15:28:56 <dcoutts> jhance_: sorry, gotta go
15:31:02 <nand`> so how close is haskell to having a type system like agda's?
15:31:44 <mike-burns> What unit do you want your answer in?
15:33:58 <nand`> mike-burns: attoseconds
15:34:51 <alpounet> in type system extension per year
15:35:54 <jhance_> Anyone know if extra-ghci-libraries honors library-dirs?
15:35:57 <Jafet> Not milliolegs?
15:42:37 <Jafet> > map fst . sortBy (comparing $ snd.snd) . join . zipWith (map . (,)) [1..] . sortBy (comparing $ snd.head) . groupBy ((==) `on` fst) . sortBy (comparing fst) . flip zip [1..] $ [1,2,1,1,5,8,2]
15:42:39 <lambdabot>   [1,2,1,1,3,4,2]
15:45:24 <Axman6> i think you just reinvented zip somewhere in there
15:45:34 <Axman6> :t zipWith (map . (,))
15:45:34 <lambdabot> forall a a1. [a1] -> [[a]] -> [[(a1, a)]]
15:45:54 <Jafet> zip is zipWith (,)
15:46:11 <Axman6> yeah, i see what's going on there now
15:51:24 <nooodl> hmph. i've got this data type for texas hold 'em hands: "data Hand = HighCard Rank | OnePair Rank | TwoPair Rank Rank | ThreeOfAKind Rank ..."
15:51:44 <nooodl> and i want to write an Ord instance for it
15:52:58 <Jafet> deriving (Ord)
15:53:29 <doserj> nooodl: you need all five cards to compare in general
15:53:37 <nooodl> i considered that, but it wouldn't really handle TwoPair Rank Rank correctly
15:53:58 <nand`> you want to compare them but you don't want to write an Ord instance? how is that supposed to work?
15:54:22 <nooodl> <nooodl> and i want to write an Ord instance for it
15:54:23 <nooodl> what?
15:54:31 <nand`> oh, sorry, misread :)
15:54:35 <nooodl> hah
15:54:48 <Jafet> nooodl's poker face
15:54:55 <nand`> instance Ord Hand where ...
15:54:59 <nand`> @src Ord
15:54:59 <lambdabot> class  (Eq a) => Ord a  where
15:55:00 <lambdabot>     compare      :: a -> a -> Ordering
15:55:00 <lambdabot>     (<), (<=), (>), (>=) :: a -> a -> Bool
15:55:00 <lambdabot>     max, min         :: a -> a -> a
15:55:30 <nooodl> anyway, it should keep the regular behaviour, where HighCards are less than OnePairs, etc
15:55:49 <nooodl> but HighCard King > HighCard Two
15:56:26 <nand`> compare (HighCard a) (HighCard b) = a `compare `b; compare (HighCard _) _ = LT
15:56:31 <Jafet> Uh, you don't seem to have enough information to decide the pot here.
15:56:45 <doserj> nooodl: and HighCard King Ten 9 8 7 > HighCard King 9 8 7 6
15:57:32 * nooodl changes the declaration to "HighCard [Rank]"
15:57:34 <nooodl> right.
15:57:54 <doserj> you also need to store the kicker for pairs, two pairs, etc
15:57:58 <nand`> depending on the rules of poker it might be possible to assign a numeric “score” to each combination then see which player has the highest score overall
15:58:03 <nand`> I don't know the game
15:58:10 <niteria> Is it really useful to have all those constructors?
15:58:13 <nooodl> that would be interesting
15:58:36 <nooodl> niteria, it might not be
15:58:46 <niteria> I've never written anyting poker related
15:58:57 <niteria> but it seems like a wasted effort
15:58:59 <nooodl> me neither, clearly
15:59:08 <nand`> does poker have a clear ranking? in other words, is there any combination of cards X, Y and Z such that X > Y, Y > Z but Z > X?
15:59:23 <Jafet> Yes, most poker rules are totally ordered
15:59:28 <niteria> i think its transitive
15:59:47 <doserj> it has to be, for a n-player game
16:00:12 <nooodl> no such combinations afaik
16:00:13 <nand`> in that case it should at least be possible to write (Card,Card,Card,Card,Card) -> Score where Score is Ord
16:00:38 <Jafet> nand`: writing that function is no simpler than writing compare
16:01:04 <Jafet> Well, it may be useful for other things.
16:01:15 <nand`> sortBy (comparing score)
16:01:17 <nooodl> oh man this function is going to be so awfully complicated
16:01:37 <nand`> nooodl: from what I gather based on the conversation here poker has a lot of complicated rules
16:01:57 <nooodl> it makes enough sense to seem simple
16:02:03 <niteria> since you can infer order from scores and not the other way (not easily) I say giving them a score is better
16:02:05 <Jafet> Some poker variants have complicated rules.
16:02:22 <doserj> nooodl: it's not "awfully complicated", it just is more complicated than a one-liner
16:02:26 <nand`> niteria: well in poker the score doesn't really matter afaik
16:02:35 <Jafet> I don't think Texas Hold'em is one of them.
16:02:37 <nand`> it just counts who has the highest
16:02:39 <mm_freak_> Rmx: i think, "the automaton arrow" is the key here
16:03:20 <mm_freak_> Rmx: and the automaton arrow is really just a generalized stream type…  generalized in that any instant of the stream can depend on the same instant of another stream
16:03:35 <Algorith> also don't forget that the suit might make a difference, like spades
16:03:54 <mm_freak_> Rmx: countFrom n = Auto (\step -> (n, countFrom (n + step)))
16:04:12 <mm_freak_> this automaton is just a counter stream, and the increment comes from another stream
16:04:50 <Jafet> If it is conceivable that you will need to consider more than one poker variant, it is unwise to use Ord.
16:04:58 <niteria> I'm sure people've written over 9k poker scoring algorithms and there's a known, easy and pretty elegant way already
16:05:36 <MostAwesomeDude> But is it obvious?
16:05:53 <roconnor_> I hate polymorphic recursion >:(
16:06:11 <Philippa_> Jafet: I'd say unwise to use a canonical Card type with an Ord instance?
16:06:22 <Philippa_> (newtypes are your bestest fiend!)
16:07:21 <mm_freak_> Rmx: one further piece of advice:  it's not really helpful to think of AFRP in terms of time-dependent values or functions of time…  AFRP is really about streams
16:11:07 <niteria> I read some articles on reactive programming and I was under the impression that everything needs recursive streams and they're not pretty, am I wrong?
16:11:39 <mm_freak_> niteria: the first is true of AFRP, the second is not true at all
16:12:09 <mm_freak_> the "A" stands for either "arrowized" or "applicative", depending on the style you use
16:12:22 <mm_freak_> the classic AFRP libraries only allow the arrowized style, while netwire allows both
16:13:39 <niteria> it all felt declarative and then recursive streams came along and broke the illusion
16:14:19 <mm_freak_> in AFRP there are primitives and compositions…  the primitives are indeed recursive streams, though i don't see why they wouldn't be declarative
16:14:43 <mm_freak_> see the countFrom automaton from above…  it's an AFRP primitive i use all the time
16:16:09 <adimit> question: i've an action f :: IO (Maybe a). At some point, it is going to return Nothing. How can I turn this into an action f' :: IO [a] that'll execute f until it returns a Nothing, and collects the results into a list?
16:17:00 <adimit> so f returns, say Just 1, then Just 2, then Nothing. I want f' to return [1,2]
16:17:31 <adimit> I think I'm thinking too iteratively…
16:17:59 <mm_freak_> adimit: you need a stopping condition
16:18:04 <mm_freak_> then just use catMaybes from Data.Maybe
16:18:08 <cmccann> adimit, you want a monadic unfold
16:18:23 <mm_freak_> > catMaybes [Just 1, Just 2, Nothing]
16:18:23 <lambdabot>   [1,2]
16:18:59 <cmccann> adimit, http://hackage.haskell.org/packages/archive/monad-loops/0.3.1.1/doc/html/Control-Monad-Loops.html#v:unfoldM
16:19:06 <mm_freak_> adimit: otherwise this is just an application of liftA2 or replicateM
16:19:41 <hpaste> “Carter Schonwald” pasted “sdist stuff” at http://hpaste.org/64016
16:19:43 <adimit> mm_freak_: yeah, the stopping condition was what tripped me.
16:19:57 <carter> hey all, i'm having some difficulty with doing cabal sdist
16:19:59 <adimit> cmccann: that sounds nice. I'll give it shot.
16:20:04 <carter> and I don't understand the error message i'm getting
16:20:06 <mm_freak_> adimit: your f' can't return anything before stopping to consume from f
16:20:25 <carter> relevant info in http://hpaste.org/64016
16:20:26 <adimit> mm_freak_: ah, damn. I wanted it to be lazy.
16:20:49 <carter> namely, I don't understand the error message i'm getting
16:20:55 <mm_freak_> adimit: you can have it lazy by using unsafe stuff, but a better method is to use a stream abstraction like conduits
16:21:09 <carter> which is in the commented lines at the top of the file
16:21:13 <mm_freak_> or in very simple cases you can just pass a callback
16:21:26 <adimit> mm_freak_: conduits would be overkill here.
16:21:44 <mm_freak_> adimit: why?
16:22:10 <adimit> cmccann: is unfoldM lazy?
16:22:21 <adimit> mm_freak_: because I'd have to learn how to use them first :-P
16:22:24 <cmccann> it runs the action until it gets a Nothing
16:22:35 <cmccann> there's no other way it can work
16:22:47 <carter> iif anyone's around who can help with cabal confusion
16:22:50 <mm_freak_> adimit: unfoldM is just a nice combinator for what you would do manually otherwise
16:22:52 <adimit> yeah, right, mm_freak_ already said it, I was just hoping against hope.
16:22:53 <mm_freak_> so no, it's not lazy
16:23:13 <mm_freak_> adimit: f' :: (Result -> IO b) -> IO b
16:23:24 <mm_freak_> this is the simple way to do it, if you want incremental processing
16:23:32 <mm_freak_> another way is to use concurrency
16:23:39 <mm_freak_> but i'd really just use a conduit
16:23:49 <cmccann> adimit, yes, if you want it more incremental than producing it as a chunk you need some sort of stream processing whatnot
16:24:04 <mm_freak_> uhm
16:24:13 <mm_freak_> f' :: (Result -> IO b) -> IO [b]
16:24:18 <mm_freak_> makes more sense
16:25:27 <cmccann> adimit, unfoldM or the like is useful for e.g. polling events and taking as many as are currently waiting
16:25:41 <mm_freak_> one final way is to use MaybeT instead of Maybe
16:25:45 <mm_freak_> x <- f
16:26:01 <mm_freak_> just loop that one…  it will stop as soon as 'f' produces a NothingT
16:26:08 <mm_freak_> f :: MaybeT IO Result
16:26:19 <mm_freak_> you can even use 'forever' there
16:26:46 <adimit> mm_freak_: That MaybeT usage is neat.
16:27:15 <mm_freak_> with the same argument you can say that MaybeT is overkill ;)
16:27:22 <adimit> but I think I'd rather go with something like stream processin.g
16:27:25 <mm_freak_> in haskell nothing is overkill, as long as it leads to beautiful code
16:27:52 <adimit> yeah, I'm using Haskell as a tool though, and unfortunately, I need to handle really large databases with it right now.
16:28:13 <adimit> which is why I'm bugging the people in #haskell with these questions lately.
16:28:23 <adimit> but you two have been very helpful, thanks!
16:29:13 <cmccann> adimit, if you like the aesthetics of the unfoldM style note that you can combine a single read step with your other processing and then use a loop combinator on the whole thing
16:29:28 <cmccann> it ends up being the same idea as the stream processors for the most part
16:30:33 <adimit> inversion of control, so to speak.
16:30:46 <mm_freak_> adimit: just more reason to employ proper stream processing
16:31:15 <adimit> I've so far only done iteratee based stream processing…
16:31:16 <mm_freak_> i have successfully processed very high loads using enumerators
16:31:23 <mm_freak_> conduits are much simpler
16:31:39 <mm_freak_> and in my benchmarks they were equally fast
16:31:55 <adimit> well, since the values are coming from an SQL db, I could write an enumerator interface for HDBC queries.
16:32:09 <adimit> … speaking of overkill…
16:32:10 * hackagebot composition 0.2.1 - Combinators for unorthodox function composition  http://hackage.haskell.org/package/composition-0.2.1 (DanBurton)
16:33:40 <adimit> well, anyway, this seems to be something I'd rather do after a good night's sleep. Thanks for your help :-)
16:33:53 <DanBurton> how often does the hackage library documentation batch process run?
16:34:18 <mm_freak_> good idea…  good night =)
16:34:32 <mm_freak_> DanBurton: every 6-12 hours i think
16:47:10 * hackagebot vowpal-utils 0.1 - Vowpal Wabbit utilities  http://hackage.haskell.org/package/vowpal-utils-0.1 (CarterSchonwald)
16:49:09 <roconnor_> are pattern views Haskell 2010?
16:51:14 <carter> woo, first hackage upload!
16:51:59 <byorgey> carter++
16:52:07 <byorgey> roconnor_: I think they are not
16:53:24 <carter> byorgey: thanks, once I put a wee bit more work into it, i'll announce lib / tool to the haskell mailing list. Basically it'll be a user friendly overlay on top of some very performant command line machine learning tools
16:53:36 <byorgey> sounds cool
16:53:48 <carter> it is
16:55:04 <carter> byorgey: the first step was sorting out how hashing is implemented in said tool, because the way vowpal wabbit outputs regression models, it reports back a hash instead of the original variable name
16:55:16 <carter> and thats whats in my wee 0.1 package
16:55:26 <byorgey> nice
16:56:41 <carter> v 0.2 should be out tomorrow assuming i'm over my sore throat, that version will include a tool for passing csv data to vowpal wabbit, and for benchmarking data cross validation in a specified range of regularization levels
16:57:11 * hackagebot yjsvg 0.1.7 - make SVG string from Haskell data  http://hackage.haskell.org/package/yjsvg-0.1.7 (YoshikuniJujo)
16:58:05 <byorgey> hehe, "vowpal wabbit" is a funny name for a tool
16:58:09 <carter> yeah
16:58:26 <carter> i'm also thinking of writing a port of the tool to haskell and naming it Hoppy Bunny
16:58:40 <jthance> Asked this a bit earlier - I have an issue with linking in LLVM... I have the path set to include /usr/lib64/llvm, and I have extra-ghci-libraries set to LLVM-3.0, but it can't find libLLVM-3.0.so even though it is indeed there.
16:58:56 <carter> ('cause vorpal swords or rabbits are scary, but hoppy bunny probably isn't)
16:59:41 <carter> the c codee for vowpal is relatively legible, but bad cli args will cause a seg fault
16:59:41 <byorgey> the one in Monty Python's Holy Grail is
16:59:53 <byorgey> ugh
17:00:19 <jthance> can I make ghci show what directories its searching
17:00:24 <carter> like, the v0.1 code i put up, which is basically the core hashing code for namespaced features
17:00:56 <nus> jthance, what's the specific error?
17:01:18 <jthance> nus: Loading package llvm-base-3.0.0.0 ... can't load .so/.DLL for: libLLVM-3.0.so (libLLVM-3.0.so: cannot open shared object file: No such file or directory)
17:02:25 <nus> jthance, what does strace tell?
17:03:07 <carter> byorgey some of the code in the vw (vowpal) was mixed in with the parsing module, the gradient descent module, and i think 1-2 other modules
17:03:23 <rasfar> roconnor_: although I'd not heard of "pattern views" (or "ViewPatterns") before your question, it seems by http://www.haskell.org/onlinereport/haskell2010/haskellch12.html#x19-19100012.3 that the extension is not included in Haskell2010?
17:03:47 <jthance> nus: One sec, need to install
17:04:23 <carter> more succintly, the definitons for how different things were hashed is spread across 3-8 modules
17:05:05 <jthance> nus: Having trouble straceing ghci, it has a lot of syscalls and never gives me prompt
17:05:21 <nus> jthance, try -e open
17:05:37 <nus> jthance, and redirect the output to a file
17:06:37 <jthance> nus: It won't redirect, does it use stderr or smething
17:07:03 <jthance> nus: Or rather, it redirects ghci output -.-
17:07:25 <nus> jthance, -o option of strace?
17:07:31 <jthance> nus: oh, duh
17:08:20 <jthance> definitely not checking for /usr/lib/llvm...
17:09:09 <jthance> ghc-pkg describe llvm-base says library-dirs: /usr/lib64/llvm-base-3.0.0.0/ghc-7.2.2               /usr/lib64/llvm though...
17:12:11 * hackagebot mainland-pretty 0.1.1.1 - Pretty printing designed for printing source code.  http://hackage.haskell.org/package/mainland-pretty-0.1.1.1 (GeoffreyMainland)
17:14:59 <jthance> I feel like ghci is not honoring library-dirs
17:15:41 <jthance> I guess I can just cheat and make a symlink to it in /usr/lib64
17:16:42 <gregATio> w to change my alt key binding for xmonad?
17:17:02 <gregATio> anyone know how to configure my alt key binding so that its Alt Gr
17:17:04 <gregATio> ?
17:17:24 <jthance> I symlinked it and now I get unknown symbol `LLVMOpaqueTypeInContext'... Great
17:17:47 <geekosaur> gregATio, #xmonad is a better place to ask those questions
17:18:10 <gregATio> @geekosaur thanks on my way
17:18:10 <lambdabot> Unknown command, try @list
17:20:19 <downloader> I have some malformed bencoded (bittorrent encoding) data. What would the easiest way to determine what is wrong with be?
17:20:20 <jthance> Well... found the error as nm: /usr/lib64/llvm/libLLVM-3.0.so: no symbols
17:20:33 <jthance> Why would libLLVM-3.0.so not have symbols? Guess its time to move to #llvm
17:20:56 <geekosaur> they often don't have normal symbols.  try nm --dynamic
17:24:07 <jthance> geekosaur: oh, thanks
17:25:04 <jthance> Well it definitely doesn't seem to have OpaqueTypeInContext...
17:26:50 <Axman6> downloader: i don't know if it ever got split out into a separate package, but the combinatorrent package has some bencoding parsing code that i wrote using attoparsec I believe, which might be of some use. I'm not sure how good its error reporting is however
17:27:12 * hackagebot language-c-quote 0.3.1.0 - C/CUDA/OpenCL quasiquoting library.  http://hackage.haskell.org/package/language-c-quote-0.3.1.0 (GeoffreyMainland)
17:27:36 <Axman6> ooo, language-c does OpenCL?
17:29:36 <cmccann> Axman6, looks like QQ'r might be doing something on top of language-c to support that
17:29:56 <cmccann> also it doesn't mention opencl in previous versions so that's probably new
17:30:38 <Axman6> it'd be great if Language.C supported OpenCL. would make producing correct code for OpenCL form Haskell much nicer
17:32:12 * hackagebot yjsvg 0.1.8 - make SVG string from Haskell data  http://hackage.haskell.org/package/yjsvg-0.1.8 (YoshikuniJujo)
17:37:19 <edwardk> has anyone done an IntMap or HashMap with a built in Tree-PLRU, so you can throw away entries that you haven't touched in a while in Haskell? I can't think of any
17:38:10 <Axman6> how does one measure 'a while'?
17:38:16 <ergot> hi, I have some code like: \x -> doSomething x >>= doOther x
17:38:29 <ergot> is there some function I can use to express that kind of pattern?
17:38:35 <Axman6> @pl \x -> doSomething x >>= doOther x
17:38:35 <lambdabot> liftM2 (>>=) doSomething doOther
17:38:52 <ergot> thanks :)
17:38:54 <Axman6> not much better
17:39:02 <Axman6> i'd use your version, it's clearer
17:40:12 <cmccann> ergot, if you have a whole lot of those using the same x you could consider using ReaderT
17:40:27 <cmccann> but otherwise just leave it as is
17:42:03 <Axman6> @unmtl ReaderT r m a
17:42:03 <lambdabot> r -> m a
17:47:46 <carter> question: whats the current understanding of the performance differences of HashMap in the hashmap package vs HashMap in unordered-containers ?
17:48:09 <edwardk> hashmap in unordered-containers is rather heavily optimized
17:48:14 <Absbeg> :t (>>=)
17:48:15 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m a -> (a -> m b) -> m b
17:48:51 <edwardk> milan's is just IntMap with a think wrapper unordered-containers is based on HAMTs
17:49:00 <edwardk> er with just a thin wrapper
17:49:19 <edwardk> the HAMT stuff is pretty much comparable across the board and 2x faster for some things, with a smaller footprint
17:49:24 <carter> hamts? i'm not familiar with that acronym
17:49:30 <edwardk> hash array mapped trie
17:49:34 <carter> ok
17:49:48 <edwardk> basically uses a fanout of up to 32 with a cute population count based indexing scheme
17:50:21 <carter> both are HAMT or just the hashmap one?
17:50:31 <edwardk> just the one in unordered-containers
17:50:36 <carter> ok
17:51:16 <edwardk> hashmap was what unordered-containers was designed to subsume ;)
17:51:23 <carter> i had a bad memory blowup experience  with hashmap last week
17:51:28 <carter> but now i know
17:51:45 <edwardk> what happened? lots of collisions?
17:51:51 <carter> hrmm
17:52:24 <carter> well, i was buliding a map with 8 million entries
17:52:42 <carter> each indexed by about 5 very short byte strings
17:52:50 <carter> with some repetitions
17:53:03 <carter> the original CSV file was 1/2 gb
17:53:06 <edwardk> sounds messy
17:53:32 <carter> so let just say
17:53:38 <carter> a set of 5 strings
17:53:39 <carter> yes
17:53:53 <carter> messy, but meant as a model for some other code
17:54:17 <carter> and with hashmap, the memory residency  was ~45gb for the map data structure
17:55:10 <edwardk> what was the fix?
17:55:19 <carter> ec2
17:55:20 <carter> :p
17:55:23 <edwardk> hah
17:55:25 <edwardk> good answer
17:55:25 <edwardk> =)
17:56:03 <carter> i just want to get the data from the run
17:56:37 <carter> though doing insertions seemed to scale worse that O(log n)
17:56:43 <carter> *wanted
17:57:02 <carter> eg doing 10k insertions was fine
17:57:09 <carter> 100k was surprisingly slow
17:57:12 * hackagebot io-choice 0.0.1 - Choice for IO and lifted IO  http://hackage.haskell.org/package/io-choice-0.0.1 (KazuYamamoto)
17:57:14 * hackagebot atmos 0.1.0.0 - 1976 US Standard Atmosphere  http://hackage.haskell.org/package/atmos-0.1.0.0 (GregHorn)
17:57:28 <carter> became "lets run it over the weekend"
17:57:36 <Absbeg> is \x -> doSomething x >>= doOther x == \x -> (doSomething x >>= doOther x) or (\x -> doSomething x) >>= doOther x?
17:57:52 <Axman6> the former
17:58:50 <maloi> thx
17:58:55 <carter> maybe too many things were hashing the same way and it became a linear insert
17:59:06 <maloi> wrong channel oO
17:59:07 <carter> i'll try out unordered tuesday and find out
17:59:08 <edwardk> anyways the main win from unordered-containers is that lookups are noticeably faster, so if your algorithm was insert heavy it may not help
17:59:23 <carter> not insert heavy, just loading it up initially
18:00:29 <carter> correction: was insert heavy
18:01:01 <carter> 8 million inserts
18:01:17 <carter> then an ungodly number of lookups
18:01:57 <carter> (basically wanted to benchmark how some prexisting models folks were using that involved "finding the best power set")
18:02:02 <carter> for my work
18:02:16 * hackagebot atmos-dimensional 0.1.0.0 - dimensional wrapper on atmos package  http://hackage.haskell.org/package/atmos-dimensional-0.1.0.0 (GregHorn)
18:02:18 * hackagebot atmos-dimensional-tf 0.1.0.0 - dimensional-tf wrapper on atmos package  http://hackage.haskell.org/package/atmos-dimensional-tf-0.1.0.0 (GregHorn)
18:02:24 <edwardk> ok, then you may win out with unordered-containers i think the inserts were slightly slower, but the lookups ~ twice as fast
18:02:32 <carter> yerah
18:02:43 <carter> i'll take a look and see how it runs
18:02:59 <carter> but going forward I"m just doing fancy regression
18:05:41 <carter> edwardk thanks for the informative reply
18:06:04 <edwardk> no problem. i'd love to see how it compares when you get around to running it
18:06:25 <Axman6> tibbe would too i think
18:08:54 <carter> remind me later this week  or next and i'll tell all
18:09:19 <carter> also really had not clue why the memory usage blew up so much
18:10:05 <carter> as the in memory size seems like it really should have maxed out at 2-3 gb
18:16:07 <carter> that said, that one off code, so the whole implicit combinatorial enumeration was also probably a culprit.
18:16:13 <tigger> I'm working with the FFI haskell interface, and I need to write a callback function for C to call into haskell of type (Ptr CInt -> CInt -> IO ()). So all that occurs is the user modifies the buffer of CInt (which has max size the second argument), the array is allocated on the C end. For my binding I'd like the users to be able to use storable vectors, so if p is the pointer, I make it a foreign pointer, and then use unsafeToForieg
18:16:33 <tigger> Now, if the users modifies the storable vector, will the underlying pointer be modified as well?
18:16:49 <dmwit> You got cut off at "and then use unsafeToForieg [sic]"
18:16:53 <tigger> I assume so, since unsafeToForeignPointer is O(1), so no copy
18:17:24 <carter> so just to double check, "unordered-containers" is the current blessed hashmap?
18:17:42 <tigger> Sorry, I mean to say For my binding I'd like the users to be able to use storable vectors, so if p is the pointer, I make it a foreign pointer, and then use unsafeFromForiegnPtr to get a storable mutable vector
18:17:48 <carter> nevermind, i'm just repeating myself
18:18:13 <tigger> If I then modify that storable vector, does the underlying pointer for the buffer actually get modified, or is a copy being modified
18:18:32 <tigger> I hope that is clear, but I think it may not be..haha
18:19:07 <dmwit> Hoogle doesn't give any results for "unsafeFromForeignPtr", what module is it from?
18:19:27 <tigger> my apologies: http://hackage.haskell.org/packages/archive/vector/0.5/doc/html/Data-Vector-Storable-Mutable.html
18:20:35 <dmwit> unsafeFromForeignPtr just wraps up its three arguments in a data type.
18:20:43 <dmwit> See http://hackage.haskell.org/packages/archive/vector/0.5/doc/html/src/Data-Vector-Storable-Mutable.html#unsafeFromForeignPtr
18:22:03 <dmwit> Perhaps I didn't understand the question.
18:22:29 <args[0]> ls
18:22:37 <Axman6> .
18:22:37 <Axman6> ..
18:22:44 <carter> that said, i'll have plenty more  data structure questions over the coming  month, so thanks in advance
18:22:44 <args[0]> ^^
18:22:55 <tigger> no then I guess it does modify the original pointer. thats what I needed! thanks! crap, I feel like I should have checked the source before posting here.
18:23:00 <tigger> @dmwit
18:23:00 <lambdabot> Unknown command, try @list
18:23:09 <tigger> dmwit: thanks
18:23:17 <dmwit> cheers
18:29:59 <mgsloan> anyone have a name for (Maybe a -> Maybe b -> c) -> [a] -> [b] -> [c] ?
18:30:14 <slack1256> let see hoogle
18:30:23 <mgsloan> I tried
18:30:27 <mgsloan> ?hoogle (Maybe a -> Maybe b -> c) -> [a] -> [b] -> [c]
18:30:27 <lambdabot> No results found
18:30:46 <monochrom> what does it do?
18:30:52 <cmccann> mgsloan, what does it do with two Nothings?
18:31:08 <mgsloan> zipWith that continues zipping until all is exhausted
18:31:16 <mgsloan> two Nothings never happens
18:31:18 <Axman6> isn't that just zipWith with maps?
18:31:37 <mgsloan> ahh
18:31:49 <monochrom> greedy zipwith
18:31:50 <shachaf> mgsloan: Clearly you want These a b -> c. :-)
18:32:04 <cmccann> mgsloan, cf. https://github.com/isomorphism/these/blob/master/Data/Align.hs
18:32:29 <shachaf> Oh, that's what Align is.
18:32:43 <mgsloan> map (uncurry f) . dropWhile (uncurry (&&) . (isNothing *** isNothing)) . zip (x ++ repeat Nothing) (y ++ repeat Nothing)
18:32:43 <cmccann> yeah, it's a generalized form
18:32:49 <cmccann> rather than being just for lists
18:33:03 <mgsloan> err left out some "map Just" s
18:33:27 <mgsloan> takeWhile (not .
18:33:48 <MostAwesomeDude> Wait, how do you get [a] into Maybe a? Are you building Just a ?
18:34:23 <MostAwesomeDude> Oh, I see. Didn't read everything.
18:34:33 <mgsloan> map (uncurry f) . takeWhile (uncurry (||) . (isJust *** isJust)) . zip (map Just xs ++ repeat Nothing) (map Just ys ++ repeat Nothing)
18:36:41 <cmccann> mgsloan, did you look at my link?
18:37:03 <mgsloan> looking at it now. cool stuff!
18:37:51 <cmccann> mgsloan, in case you want a type class that generalizes that to more than just lists, and a data type that expresses either-or-both directly :P
18:38:07 <mgsloan> fantastic! I will write the instances for Vector
18:38:48 <cmccann> it's something I got tired of reimplementing all the time
18:40:50 <mgsloan> oh man, you even made a specialization of (Maybe a, Maybe b), nice
18:42:09 <cmccann> but that excludes the (Nothing, Nothing) case, which as you say never occurs
18:42:37 <mgsloan> yeah, I'm agreeing with doing that
18:42:43 <cmccann> makes things much clearer I think
18:43:15 <mgsloan> though I'm not sure how well this'll generalize to zip3, zip4 ...
18:43:29 <mgsloan> I mean, it'll work to do nested These
18:43:34 <mgsloan> but wierd
18:43:49 <cmccann> well, in general the idea itself doesn't generalize well
18:43:50 <shachaf> Allo'These
18:44:01 <cmccann> you end up with a mess of possible combinations
18:44:12 <byorgey> TheseOrThose
18:44:24 <shachaf> ThatLotOverThere
18:44:56 <cmccann> I would expect that most cases of needing an n-ary align you have some generic way to handle missing values
18:45:08 <cmccann> like a Monoid constraint where you can shove an mempty in there
18:45:51 <mgsloan> yeah, or do one zip and then the next.  Mostly a performance consideration
18:47:21 <JoeyA> Has anyone written a correct variant of Network.Socket.setSocketOption yet?  Namely, one using constructors for arguments, rather than passing a memory representation of Int, which is unportable and unsafe.
18:47:38 <cmccann> if you have examples of doing an n-ary align I'd be interested to hear about it, so that I can think about utility functions I can add to the library
18:47:40 <JoeyA> I might go ahead and do it; I just don't want to duplicate work if someone else has already done it.
18:47:43 <cmccann> like the Monoid case really should be in there
18:48:32 <mgsloan> cmccann - I don't need it at the moment, and can't think of a very convincing example, but I imagine it'll happen to someone at somepoint :)
18:52:13 <JoeyA> Actually, a better option would be to implement separate functions for each option, e.g. Network.Socket.Options.setRecvTimeout
18:54:23 <gwern> > 2012 - 1997
18:54:23 <lambdabot>   15
18:55:58 <shachaf> > 2007 - 19912
18:55:59 <lambdabot>   -17905
18:56:23 <shachaf> Coïncidence?
18:56:37 <zachk> how do I do a cabal install with -XFlexibleInstances?
19:01:02 <scrutr> uh, so this is making my head spin: http://learnyouahaskell.com/functors-applicative-functors-and-monoids
19:01:21 <scrutr> any supplementary materials available?
19:01:51 <otters> what's confusing you exactly?
19:03:30 <ddarius> @where typeclassopedia
19:03:30 <lambdabot> http://www.haskell.org/haskellwiki/Typeclassopedia
19:04:36 <scrutr> the part about applicatives
19:06:23 <otters> well they're a lot like functors except the function you're applying is in a functor itself
19:06:35 <otters> actually you should probably ignore everything I say because I'm pretty new at this
19:06:54 <scrutr> it's alll a bunch of abstract algebra isn't it?
19:08:22 <scrutr> thanks for the ref ddarius
19:13:29 <Mandai> Hey, is there any haskell function that receives an list of input , a list of outputs, and gives me back the function that links those inputs to ouputs?
19:14:25 <td123> Mandai: you mean a hash?
19:14:29 <td123> or map?
19:14:42 <clsmith> no, he means, i think :: [a] -> [b] -> (a -> b)
19:15:07 <clsmith> (:: [a] -> [b] -> Maybe (a -> b)) could work, i suppose.
19:15:31 <byorgey> needs an Eq a constraint.
19:16:10 <shachaf> We need :: sections.
19:16:13 <byorgey> @type \as bs -> flip lookup (zip as bs)
19:16:14 <lambdabot> forall a b. (Eq a) => [a] -> [b] -> a -> Maybe b
19:16:18 <Mandai> clsmith: exactly
19:16:22 <byorgey> Mandai: how about that?
19:16:50 <Mandai> byorgey: I'll test it, thanks
19:17:04 <scrutr> that lambdabot fella is pretty cool :P
19:18:08 <clsmith> ohhh. i interpreted the question differently.
19:18:08 <bill```> cabal install lambdabot ;)
19:19:03 <clsmith> i interpreted it in a way that f [1,2,3] [1,4,9] would yield (^2) >.>
19:19:16 <clsmith> hence the Maybe (a -> b), lol
19:19:29 <Mandai> clsmith: That would be waay more dificult
19:19:35 <clsmith> it would still need the Eq constraint though
19:19:38 <Mandai> >  ((\as bs -> flip lookup (zip as bs) ) "1234" "4321") '1'
19:19:39 <lambdabot>   Just '4'
19:19:46 <Mandai> Thanks
19:19:49 <Mandai> ;D
19:20:07 <byorgey> clsmith: oh, haha, I like yours better =)
19:20:20 <byorgey> sounds more difficult though ;-)
19:20:26 <cmccann> clsmith, that would make a nice extension to hoogle
19:20:36 <cmccann> feed it some argument/result pairs and it finds a function for you
19:20:45 <clsmith> that would be cool
19:20:47 <byorgey> actually, I think I remember seeing something like that
19:20:56 <cmccann> byorgey, I've heard it suggested a couple times
19:20:57 <byorgey> it was a research projectish sort of thing
19:21:03 <cmccann> don't recall it ever being implemented
19:21:55 <clsmith> @djinn [a] -> [b] -> Maybe (a -> b)
19:21:56 <lambdabot> Error: Undefined type []
19:22:06 <cmccann> I suspect it's one of those things where a simple version of limited utility is dead simple, then there's a huge difficulty jump to do anything more interesting
19:22:07 <Mandai> well, if you aren't interested on correctness , you could use some function pool
19:22:08 <clsmith> i don't know what that means, but it was worth a try :P
19:22:18 <quintessence> djinn doesn't understand recursive types
19:22:42 <clsmith> what was recursive there?
19:22:48 <cmccann> lists
19:22:54 <cmccann> @src []
19:22:54 <lambdabot> data [] a = [] | a : [a]
19:23:08 <clsmith> oh. it doesn't understand lists? ... huh.
19:23:20 <clsmith> too complicated i suppose?
19:24:00 <cmccann> I suspect it's the possibility of non-termination that's the issue
19:24:13 <cmccann> and that it could handle finite lists if those existed as a separate type
19:24:36 <clsmith> needs more dependent typing
19:25:25 <quintessence> it basically just uses Curry-Howard and tries to prove (inhabit) your type from axioms (the environment)
19:25:46 <quintessence> so it can't be allowed to use general recursion or everything is trivially inhabited
19:29:56 <clsmith> and no special casing for lists? <.< just that it would be awesome if it could
19:32:16 * hackagebot hs-logo 0.1 - Logo interpreter written in Haskell  http://hackage.haskell.org/package/hs-logo-0.1 (DeepakJois)
19:34:47 <Mandai> > catMaybes $ map ((\as bs -> flip lookup (zip as bs) ) (['a'..'z']++['/']) (['z','y'..'a']++['/']))  "ellwll/hrnkov/proo/"
19:34:48 <lambdabot>   "voodoo/simple/kill/"
19:35:14 <Mandai> haskell can be so usefull for riddles
19:35:37 <clsmith> hmm. linkrot on the ghc wiki. is that considered 'unusual' (i.e., worth pointing out :p)?
19:35:55 <lispy> What concats 4 cons in the morning, 2 cons at noon, and 3 cons in the evening?
19:36:12 <clsmith> it also suggested i search for it to see if the page used to exist, but trac went all 'unimplemented functionality' on me
19:36:13 <lispy> clsmith: Yes
19:36:20 <lispy> clsmith: what did you find?
19:37:22 <clsmith> wiki/ExternalCore links to browser/docs/ext-core, which doesn't exist, and clicking 'search' yields "NotImplementedError"
19:38:45 <lispy> clsmith: hmmm...is that because they moved from darcs to git perhaps
19:42:44 <clsmith> not sure. could be, though it seems that *is* quite an old page
19:42:56 <clsmith> anyway, time to sleep i think.
19:45:22 <MiggyX> hi guys, does anyone know of a simple example for extracting a field from a JSON string? I've been able to decode the JSON, but I can't figure out how to then get a particular field from the result...
19:49:11 <HugoDaniel> MiggyX: are you using aeson ?
19:49:31 <MiggyX> HugoDaniel, at the moment, just the basic Text.JSON
19:50:14 <HugoDaniel> oh, you should use aeson, but let me take a look at the Text.JSON documentation
19:51:17 <MiggyX> HugoDaniel, thanks - meanwhile, I'm looking at aeson :)
19:52:37 <HugoDaniel> ok
19:52:42 <HugoDaniel> aeson is the one you should be using
19:53:02 <HugoDaniel> with aeson you build your own parser for json values that return the datatype you want
19:53:23 <HugoDaniel> with Text.JSON i think you can use the get_field function in Text.JSON.Types
19:53:40 <HugoDaniel> to get the parsed fields
19:55:04 <HugoDaniel> im going to sleep now, send me an email if you dont find any help in using aeson or if you have any doubts with it: mr.hugo.gomes@gmail.com
19:57:47 <MichaelBurge> "negate is the function applied by Haskell's only prefix operator, minus; we can't call it (-), because that is the subtraction function, so this name is provided instead. "
19:58:01 <MichaelBurge> wouldn't (0-) be fine?
19:58:16 <Axman6> yes, it is
19:58:28 <Axman6> but we can't use map (-3) [1..10] for example
19:58:58 <Axman6> because that parses as map (negate 3) [1..10] not map (\x -> x - 3) [1..10]
19:58:59 <shachaf> > map (-3) [1..10]
19:59:00 <lambdabot>   [-3,-3,-3,-3,-3,-3,-3,-3,-3,-3]
19:59:03 <shachaf> QED
19:59:04 <Axman6> shush
19:59:14 <shachaf> I hate it when people do that. Why did I just do that?
19:59:18 <shachaf> Forgive me, channel.
19:59:31 <Axman6> you should be ashamed of yourself
19:59:42 <monochrom> I hate it when lambdabot does that.
20:00:02 <ddarius> > map (negate 3) [1..10]
20:00:02 <lambdabot>   [-3,-3,-3,-3,-3,-3,-3,-3,-3,-3]
20:00:26 <MichaelBurge> How does that type-check
20:00:33 <MichaelBurge> negate 3 is a number, while it expects a function
20:00:38 <Axman6> lambdabot has some strange instances in it
20:00:54 <Axman6> like, Num a => Num (a -> a) (i think)
20:01:09 <monochrom> > 4 5
20:01:09 <lambdabot>   4
20:01:12 <Axman6> lets you do some cool stuff, like:
20:01:18 <quintessence> > 3 'a'
20:01:19 <lambdabot>   3
20:01:24 <lispy> > 3 const
20:01:25 <lambdabot>   3
20:01:25 <Axman6> > (sin ^ 2 + cos ^ 2) 7
20:01:26 <lambdabot>   0.9999999999999999
20:01:33 <Axman6> > (sin ^ 2 + cos ^ 2) 7  :: CReal
20:01:34 <lambdabot>   1.0
20:01:35 <quintessence> Num a => Num (b -> a) it looks like
20:01:36 <Axman6> better
20:01:46 <Axman6> yeah, probably that
20:01:46 <lispy> > (3 . 3) const
20:01:48 <lambdabot>   3
20:02:09 <MichaelBurge> So if I wanted to write a function like (-) that overloads the same name with several different functions, how would I write that?
20:02:21 <Axman6> you use type classes
20:02:23 <lispy> > foldr (.) (replicate 3) 3
20:02:24 <lambdabot>   Overlapping instances for GHC.Show.Show (a -> [a])
20:02:24 <lambdabot>    arising from a use of...
20:02:45 <lispy> :t foldr
20:02:46 <lambdabot> forall a b. (a -> b -> b) -> b -> [a] -> b
20:02:55 <lispy> > foldr (.) 3 (replicate 3)
20:02:56 <lambdabot>   Couldn't match expected type `[b -> b]'
20:02:56 <lambdabot>         against inferred type `a ->...
20:03:28 <roconnor__> @unpl (($(:[])).(.).(:)))
20:03:29 <lambdabot> Unbalanced parentheses
20:03:34 <roconnor__> @unpl ($(:[])).(.).(:)))
20:03:34 <lambdabot> Unbalanced parentheses
20:03:37 <roconnor__> @unpl (($(:[])).(.).(:))
20:03:37 <lambdabot> (\ h e -> ((:)) h (e : []))
20:03:49 <lispy> lambdabot: he what?
20:03:59 <lispy> lambdabot: I don't know that emoticon
20:04:15 <monochrom> ((:)) ?
20:04:35 <lispy> monochrom: does that mean turn your head sidewise and shake it?
20:04:53 <monochrom> I think it means extra parentheses
20:05:08 <lispy> :t replicate 3
20:05:09 <lambdabot> forall a. a -> [a]
20:05:18 <lispy> :t repeat 3
20:05:19 <lambdabot> forall t. (Num t) => [t]
20:05:24 <lispy> I always mix those up
20:05:31 <lispy> > foldr (.) 3 (repeat 3)
20:05:31 <lambdabot>   No instance for (GHC.Num.Num (f b))
20:05:31 <lambdabot>    arising from a use of `e_133' at <in...
20:06:48 <monochrom> @type let f = 3 . f in f
20:06:49 <lambdabot> forall (f :: * -> *) b. (Functor f, Num b) => f b
20:07:10 <monochrom> > (let f = 3 . f in f) undefined
20:07:12 <lambdabot>   3
20:07:15 <monochrom> ha
20:09:53 <mgsloan> cmccann: would you potentially add instances for Data.Vector.Fusion.Stream and maybe other Data Vector stuff?
20:10:19 <mgsloan> are you trying to keep deps minimal? I'm also not sure how cannonical the Data.Vector stuff is
20:10:41 <cmccann> well, I don't want to add deps more than necessary
20:10:48 <cmccann> but Vector seems like a pretty obvious one
20:11:39 <cmccann> don't know when I'd get to it but if you want to write some instances I'd be happy to include them
20:12:15 <mgsloan> yup, I'm almost done
20:13:37 <cmccann> awesome
20:15:38 <nand`> Does anybody here use haskell-mode for vim?
20:17:06 <nand`> _t always tells me “type not known”, even for things that are in Prelude, and all other Haddock-related stuff like _? doesn't seem to work correctly. However, tab completing via <C-x><C-o> lists everything, including the correct types
20:17:19 <nand`> I wonder why it only works for completion but not for anything else
20:18:41 <nand`> Furthermore, I remember _t working when I first tried it out, but only for that one time
20:19:45 <scrutr> > fmap (+2) (Right 2)
20:19:46 <lambdabot>   Right 4
20:20:30 <scrutr> why does that work here? It gives me a type error in GHCi
20:22:03 <geekosaur> becuase lambdabot has a few instances loaded that aren't in the prelude (and has other differewnces from standard haskell; every so often you'll see it described as "Caleskell")
20:22:06 <vodik> scrutr: import Data.Either
20:22:29 <nand`> > fmap (2) (Right 2)
20:22:30 <lambdabot>   Right 2
20:22:33 <nand`> somebody say caleskell?
20:23:15 <scrutr> vodik? I still get a type error :(
20:23:45 <nand`> scrutr: import Control.Monad.Instances
20:24:32 <scrutr> that did it
20:24:55 <vodik> scrutr: :m + Control.Monad.Instances
20:24:57 <vodik> sorry
20:25:09 <vodik> oh and it looks like someone beat me to it while i was googling
20:25:18 <geekosaur> mmm, orphan instances (you kinda think it *ought* to be in Data.Either)
20:26:01 <scrutr> I should have known; the tutorial I'm following *did* say it was defined as an instance in that module...
20:31:19 <DanBurton> hrm, tried a dry-run cabal install of lambdabot, looks like the IOSpec package doesn't acknowledge base-4.5 yet http://hackage.haskell.org/package/IOSpec-0.2.3
20:31:57 <DanBurton> also the listed "home page" is a broken link...I'm wondering if the email is also outdated
20:32:32 <DanBurton> ah well can't hurt to try I guess
20:55:04 <nyingen> @quote
20:55:04 <lambdabot> <lament> says: syntaxfree: ouch
20:56:22 <otters> @quote
20:56:22 <lambdabot> LinusTorvalds says: The slogan of Subversion for a while was 'CVS done right', or something like that, and if you start with that kind of slogan, there's nowhere you can go. There is no way to do
20:56:22 <lambdabot> CVS right.
20:59:29 <Dunearhp> amen
21:04:17 <nyingen> @quote
21:04:17 <lambdabot> not-gwern says: 'You say you're the world's greatest systems programmer, but all you academics know how to do is prove academic theorems about the module substructure over nilpotent Lie algebras,
21:04:17 <lambdabot> and even then you can't manage to generalize it past the two-step case. Your method fails to scale, because in the real world, nilpotent Lie algebras can take as many as ten steps to get to zero.
21:04:17 <lambdabot> Just like your statistic
21:06:11 <scrutr> @quote
21:06:11 <lambdabot> seydar says: what's the nick of the drug addict who wrote learn you a haskell? and i mean that in the best possible way.
21:07:12 <scrutr> hear hear
21:12:15 <DanBurton> So I've uploaded my pet library to Hackage...should I ANNOUNCE it on the mailing list? http://hackage.haskell.org/package/netspec
21:16:04 <nyingen> DanBurton: no reason not to
21:23:31 <iuyws> .
21:53:14 <JoeyA> :t \x -> x :: Int :: Int -> Int
21:53:15 <lambdabot> Int -> Int
21:53:57 <JoeyA> Apparently, the first :: binds to the x, while the second :: binds to the \x -> x as a whole.
21:54:40 <Jesin> ....what
21:54:44 <shachaf> JoeyA: Huh. I wasn't aware that that would work.
21:55:07 <shachaf> Makes some sense, I guess.
21:55:10 <pikhq> > (\x -> x :: Int :: Int -> Int) 0
21:55:11 <lambdabot>   0
21:55:21 <pikhq> Huh.
21:55:24 <JoeyA> :t \x -> x :: Int :: Int -> Int :: Int -> Int
21:55:25 <lambdabot> parse error on input `::'
21:55:28 <shachaf> An exception to the "as far to the right as possible" \ rule.
21:55:31 <JoeyA> :t (\x -> x :: Int :: Int -> Int) :: Int -> Int
21:55:32 <lambdabot> Int -> Int
21:55:47 <cmccann> I assume the :: applies "as far to the left" instead
21:56:38 <cmccann> and in the process syntactically ends whatever expression it attaches to
21:57:05 <shachaf> When an unsafePerformIO . poke force meets an immutable object.
21:57:19 * hackagebot yjsvg 0.1.9 - make SVG string from Haskell data  http://hackage.haskell.org/package/yjsvg-0.1.9 (YoshikuniJujo)
21:58:01 <shachaf> Does this person just prefix all their packages with "yj"? Makes some sense, I guess.
21:58:23 <cmccann> :t \f -> \x -> \y -> f x y :: Int :: Int -> Int :: Int -> Int -> Int
21:58:24 <lambdabot> (Int -> Int -> Int) -> Int -> Int -> Int
21:59:57 <nyingen> I've never really understood the 'fixity' of type annotations
22:00:04 <nyingen> I just always enclose them in parens
22:00:08 <nyingen> except at top-level
22:00:32 <Jesin> :t \f -> \x -> \y -> f x y :: Int :: Int -> Int :: Int -> Int -> Int :: (Int -> Int -> Int) -> Int -> Int -> Int
22:00:33 <lambdabot> (Int -> Int -> Int) -> Int -> Int -> Int
22:00:34 <shachaf> @ty \x -> \y -> x :: a :: b -> a :: forall a b. a -> b -> a
22:00:35 <lambdabot> forall a b. a -> b -> a
22:08:36 <nyingen> @quote
22:08:36 <lambdabot> nomeata says: Ah, it seems Im creating a tuple with more than 62 elements somewhere..
22:12:09 <MiggyX> Hi guys, what's the idiomatic way to convert a ByteString -> ByteString.Lazy ?
22:12:28 <mzero> fromChunks . (:[])
22:13:35 * shachaf wonders why there's not a helper function for that.
22:13:50 <MiggyX> mzero, ah right. I looked at that but figured there might be another way as it needed [ByteString]
22:14:20 <shachaf> MiggyX: A lazy ByteString is pretty much a list of strict ByteStrings.
22:14:40 <nyingen> (:[]) = monkey function?
22:14:52 <otters> I resent that
22:14:53 <mzero> indeedy!
22:15:18 <nyingen> come on, it looks like a monkey face
22:16:48 <shachaf> @quote SamB
22:16:49 <lambdabot> SamB says: GHC is smart
22:16:51 <shachaf> @quote SamB comment
22:16:52 <lambdabot> No quotes match. I've seen penguins that can type better than that.
22:17:00 <shachaf> @quote eat.a.comment
22:17:00 <lambdabot> SamB_XP says: I once saw it eat a comment (:[{- Help! -}])
22:17:58 <nyingen> heh
22:19:28 <exFalso> good day, if i have a function fun :: (?d :: a) => a ; fun = d, then explicitly typing d (with d :: a) in the function body doesnt work with ScopedTypeVariables. Is this a bug or is there a reason for this restriction?
22:21:11 * mzero wonders what extension  (?d :: a) is
22:21:26 <shachaf> ImplicitParams
22:25:13 <mzero> ah - right - those sort of make me feel unclean!
22:25:38 <Jafet> Don't google "explicit for all"
22:27:22 <Jafet> > let ?d = ":-)" in let fun :: (?d :: a) => a; fun = ?d in fun
22:27:23 <lambdabot>   ":-)"
22:27:34 <Jafet> ?d isn't a type variable
22:27:34 <lambdabot> Maybe you meant: devils dice dict dict-help djinn djinn-add djinn-clr djinn-del djinn-env djinn-names djinn-ver do docs dummy . ? @ id v
22:27:48 <exFalso> Jafet: thanks :D
22:27:48 <Jafet> ?dummy
22:27:48 <lambdabot> dummy
22:27:59 <shachaf> I wonder why e.g. djinn-add is on that list.
22:28:22 <Jafet> Use your secret identity to find out
22:29:20 <ddarius> shachaf: Why do you wonder that?
22:30:37 <shachaf> ddarius: I thought it only listed things that were within two characters or a unique completion.
22:31:07 <shachaf> It's inconsistent with behavior I thought I saw earlier. But I suppose not.
22:33:52 <ddarius> shachaf: No, it only will auto-"correct" in that case.
22:35:02 <shachaf> Right. For some reason I thought it showed every possible correction within two characters or only a single unique completion if there was one.
22:35:07 <shachaf> But that doesn't actually make sense.
22:35:53 <yitz> mzero: did you see the recent threads on ghc/beginners about the breakage with xcode 4.3?
22:36:14 <mzero> umm, no
22:38:19 <yitz> mzero: e.g.: http://www.haskell.org/pipermail/beginners/2012-February/009450.html
22:38:58 <yitz> mzero: looks like serious breakage that is very easy to fix. perhaps a point release just for the mac?
22:40:06 <mzero> is gcc included in Xcode 4.3?
22:40:19 <yitz> mzero: dunno
22:40:25 <mzero> that's what it is looking for when it tests for the developer tools
22:40:39 <yitz> mzero: oh dear. may not be so easy to fix after all.
22:40:40 <mzero> if it isn't, then it's not an easy fix!  :-)
22:43:39 <yitz> mzero: perhaps you have a suggestion for a problem i'm having. we need to compile an executable and distribute it to customers together with some other stuff. but the exe depends on text-icu, which depends on the icu C lib. How can I compile the exe so that it will link in a way that will run on any mac? we can distribute dylibs with it if need be, but how can the exe find them?
22:44:01 <mzero> ah -- appears it is there - Apple just moved it out of /usr/bin --- now it is in /Developer/usr/bin
22:44:31 <mzero> joy - *that* means that GHC will need to change (or at least all the wrapper scripts)
22:44:36 <yitz> mzero: i can't seem to convince cabal to link it statically. some way to mess around with ld-flags, perhaps? (dcoutt's suggestion)
22:45:05 <mzero> yitz: ICU is on every mac
22:45:08 <mzero> !
22:45:10 <yitz> mzero: better to have to change the wrapper scripts than to have to integrate ghc with a new compiler
22:45:33 <yitz> mzero: oh yeah? great! in /usr/lib or something?
22:45:54 <mzero> yes - so no need to worry about that being dynamically linked in
22:47:12 <yitz> mzero: i had been using my macports version. didn't realize that it's there natively. but wait. text-icu does *not* install without me pointing it manually at icu. why is that? is it in some non-standard place?
22:47:26 <yitz> or perhaps incompatible icu?
22:47:49 <mzero> possibly - once you have installed text-icu, it might be bound to your macports version
22:48:08 <mzero> on a stock mac, /usr/lib/libicucore.dylib is present
22:48:13 <yitz> mzero: i'm doing everything in a cabal-dev sandbox of course
22:48:49 <mzero> I don't know how that affects linking -- especially w.r.t. things like test-icu generating FFI calls into a system library
22:49:11 <yitz> text-icu needs icuuc, icui18n, and icudata
22:49:37 <yitz> mzero: oh you think cabal-dev will affect that? i doubt it.
22:49:40 <mzero> ah - THOSE are not on every mac
22:49:45 <yitz> aha
22:50:34 <mzero> (though, to be honest, icu can be compiled in several ways, but I'm guessing from the name, icucore, that Apple didn't choose the "put it all in one big lib" way)
22:51:24 <mzero> yitz - I'm thinking you just need to give GHC some extra link flags, which will link those in statically
22:51:43 <yitz> mzero: so far i haven't been able to convince cabal to do that.
22:51:44 <mzero> though again, one might have had to do that when installing text-icu
22:52:27 <yitz> mzero: one complication (perhaps) - our app uses TH, so it needs to load text-icu already while it is compiling
22:52:42 <mzero> I don't think that'll make a difference
22:52:48 <yitz> mzero: well right i'm trying to install text-icu separately first.
22:53:31 <yitz> mzero: but it's doing it dynamically, so then later on our exe points to the path to the icu libs on my specific mac
22:54:41 <yitz> mzero: so i want either to convince cabal to link statically to icu, or to get it to point to dylibs in the same dir as the exe (a standard technique on the mac in general, but no idea how to get cabal/ghc to do that)
22:55:13 <mzero> well - I'm not sure how cabal and ghc decide which libs are needed for the final link
22:55:22 <mzero> presumably it knows this from the package information for text-icu?
22:55:33 <Veinor> @query lambdabot
22:55:33 <lambdabot> Unknown command, try @list
22:55:35 <Veinor> whoops
22:55:45 <yitz> mzero: there are some pages on the web about how to hack a compiled exe to change to look for a lib in its own dir. but i'd really like to avoid that kind of thing, obviously.
22:56:34 <yitz> mzero: yes and the package db is hackable. you can put whatever paths you want there. but i don't know how to say "the path that the exe is in" in that language.
22:56:56 <mzero> well - here's my thought
22:57:14 <mzero> hacking "where to find the dylib" is, well, a hack
22:57:31 <mzero> better is to tell the linker, "no no, use the static versions of these libs"
22:57:31 <yitz> sure it
22:57:37 <yitz> yes
22:57:43 <mzero> so first question - do you *have* the static versions of the libs on your disk?
22:57:50 <yitz> yes i do
22:57:55 <mzero> 'k
22:57:59 <yitz> macports compiles both
22:58:15 <mzero> so what we want is to include those as extra-libraries
22:58:39 <mzero> and we want them included BEFORE what ever goes on the command line to show the linker where the dyn ones are
22:59:08 <yitz> i tried putting /opt/local/lib/libicuuc.a literally in the package db. it complained that it couldn't find /opt/local/lib/libicuuc.a.dylib. grrr.
22:59:29 <mzero> right - that ain't likely to work
22:59:51 <mzero> I'd add them to your extra-libraries: entry in your app's cabal file
23:00:01 <mzero> also see extra-lib-dirs:
23:00:12 <yitz> mzero: that's what i did. it assumed that i meant a dylib.
23:00:28 <yitz> mzero: maybe there's some ghc flag we need to add?
23:00:40 <yitz> mzero: or ld-flag, as dcoutts says?
23:00:41 <mzero> no - I think it is a linker flag
23:00:55 <mzero> ghc isn't really doing anything with what yo type here methinks - just passing through to the linker
23:01:01 <yitz> right
23:01:56 <mzero> "  When processing -lx the linker now searches
23:01:56 <mzero>                  each directory in its library search paths for `libx.dylib' then `libx.a' "
23:02:05 <mzero> so, it is going to find the .dylib there if you have it
23:02:10 <mzero> if both are sitting there in the same dir
23:02:26 <mzero> perhaps squirrel the .dylib ones away
23:02:34 <yitz> mzero: so maybe such get rid of those temporarily?
23:02:40 <yitz> ok i'll try that
23:02:48 <mzero> right
23:02:50 <zzo38> I want to make a classy records extension, you can make classy records which means you can name a field of a record the name of a class method and then it makes the instance which that class method access it, but can also be used in patterns and record updates too. But you still need to define the instance if it has other methods.
23:02:51 <yitz> what is "now"
23:03:13 <zzo38> Such as:   newtype Identity x = Identity { extract :: x };
23:04:02 <mzero> yitz - linker would search all lib paths for dylib first, then research for .a    ----"now" it searches for .dylib, then .a in each path in turn
23:04:10 <yitz> zzo38: my dad has an original dave brubeck quartet record from the 1950's. i'd say that's pretty classy.
23:04:37 <zzo38> yitz: OK. But that has nothing to do with what I wrote.
23:05:56 <yitz> mzero: got it. i was wondering what "now" meant as in as of what version of mac os x/xcode. but anyway, either of those might work for me if i rename the .dylibs.
23:06:16 <yitz> mzero: because i'm still on snow leopard.
23:06:58 <mzero> "now" was as of Xcode 4
23:07:10 <yitz> mzero: think that will be a problem for my exe to work on recent macs? (if so, someone else at work has lion, i could borrow his machine and compile there, it i'd rather avoid that)
23:07:24 <zzo38> Do you know if anyone commented on my current extensible-data package yet?
23:07:30 <mzero> yitz: no
23:07:34 <mzero> you should be fine
23:07:58 <mzero> zzo38: did you leave it somewhere where it could be commented upon?
23:08:30 <zzo38> mzero: No I just put it in Hackage. I asked for comments in the IRC.
23:08:47 <zzo38> (Although you can also use my Haskell wiki user talk page for that purpose if you prefer)
23:08:49 <mzero> oh - what's it named?
23:09:28 <zzo38> Do you mean the package or the user talk page? The package is named "extensible-data"
23:09:30 <mzero> d'oph
23:09:31 <mzero> neverf mind
23:09:37 <mzero> didn't realize that was the package name!
23:09:52 <yitz> mzero: i have xcode 3.2.5
23:10:06 * yitz blushes in embarassment
23:10:35 <mzero> zzo38: that package could do with some haddock - there's no comments, no examples,
23:10:39 <zzo38> Why did you put the backspace inside of the message text? Isn't it supposed to backspace on the client before they send to server?
23:11:26 <drdo> rant: Please change major version when you break API
23:11:34 <mzero> ? what?
23:11:50 <zzo38> mzero: OK. You could also print out the TeX; it is a literate Haskell program.
23:12:16 <dmos> I have a script-like program in Haskell which logs some output about progress currently with a WriterT, which obviously, but unfortunately, only outputs the 'log' after a complete (or aborted run). Do people log with a WriterMonad in such cases, or just directly log to IO?
23:12:19 <zzo38> But later possibly in next version I could add Haddock annotations too
23:12:25 <yitz> mzero: you seem to have overlapped a lot of places that my brother was. know israel gale?
23:12:33 <mzero> drdo: you do mean change y in x.y.z.o  right?   that is the versioning spec... no need to change x
23:12:52 <mzero> yitz: - not ringing any bells... but quite possibly
23:12:59 <yitz> k
23:13:12 <drdo> mzero: So the convention in cabal is to change y when breaking API?
23:13:28 <edwardk> dmos: its generally safer to log directly to IO if you need to ensure the log will survive a crash, etc.
23:13:50 <yitz> mzero: anyway thanks lemme give this a try
23:14:01 <zzo38> drdo: Yes that is. You can read package version policy for information
23:14:06 <mzero> drdo: http://www.haskell.org/haskellwiki/Package_versioning_policy
23:14:09 <edwardk> dmos: sadly MonadWriter contains both pass and listen, which precludes such a logger from being an instance of MonadWriter
23:14:19 <mzero> the major version number is considered the first TWO components
23:14:28 <yitz> @where pvp
23:14:28 <lambdabot> http://www.haskell.org/haskellwiki/Package_versioning_policy
23:14:36 <mzero> so, only need to go from   3.1 to 3.2 if you break the API
23:14:53 <mzero> developers tend to reserve going the big one (!) when they radically change the approach
23:14:54 <Paprikachu> > "\a"
23:14:55 <lambdabot>   "\a"
23:14:55 <drdo> If only i had known that before
23:15:03 <edwardk> drdo: the major version under the PVP consists of the first two digits
23:15:03 <Paprikachu> > print "\a"
23:15:04 <drdo> thank you
23:15:04 <lambdabot>   <IO ()>
23:15:16 <dmos> edwardk: ok thanks. any packages I should be aware of for simplifying the task? Otherwise putStr will do the trick in my case.
23:15:21 <Paprikachu> > show "\a"
23:15:22 <lambdabot>   "\"\\a\""
23:15:37 <Paprikachu> > putStr "\a"
23:15:38 <lambdabot>   <IO ()>
23:15:39 <mzero> normal your cabal constraints read like     directory >= 1.1.0 && < 1.2
23:15:43 <edwardk> dmos: pretty much stuck with putStr, etc or using the hPutStr equivalents to a log file
23:15:56 <drdo> What about base?
23:16:00 <zzo38> If you have questions about my package please indicate it to me by now
23:16:09 <dmos> edwardk: ok. Will do. Thanks again.
23:16:33 <zzo38> (If you want printouts, you will require "birdstyle.tex" which I can provide to you. Of course you also need TeX)
23:16:43 <mzero> well, base is special by convention
23:17:00 <mzero> most of us depend only on the top one:    base == 4.*,
23:17:05 <edwardk> drdo: base is tied directly to ghc versions, and kinda sidesteps the pvp, but every time they release a new major ghc version they bump the base version number a major revision regardless of whether or not any breaking changes were made
23:17:48 <mzero> zzo38: I can look at source on hackage -- but I suggest haddock for the future
23:17:48 <edwardk> since base is comparatively stable, folks tend to use base < 5 as a convention, but by doing so they are being unsafe.
23:18:16 <edwardk> however, the alternative is that folks like me spam hackage with 60 updates every time there is a new ghc version
23:19:06 <edwardk> the jump from base 3 to base 4 was big, a lot of stuff was split off into separate modules, and not much could reasonably expect to compile across the change
23:19:20 <edwardk> the intention is that any huge changes like that will hopefully induce a base 5
23:19:35 <zzo38> mzero: OK. Yes there are some things the source codes don't appears on Haddock. I could add in some things whatever necessary separately from the TeX printout such as hiding them from TeX, or something like that
23:19:39 <edwardk> (arrays were moved out, etc)
23:20:03 <zzo38> But still tell me if you have any question about it.
23:20:56 <mzero> zzo38: a motivating example would help
23:21:43 <mzero> personally, can't fathom using it - seems like a lot of machinery to avoid an export and a small "collector" module that imports those exports
23:22:19 <czro> Anyone else having issues building packages that depend on the preprocessor with xcode 4.3 installed? I'm getting a lot of "warning: missing terminating ' character".
23:22:22 <zzo38> mzero: That isn't all it does. It has four modules with somewhat different purposes.
23:23:01 <zzo38> You do not have to use it if you do not like it.
23:24:27 <mzero> true - imagine what it would be like if every time a package was added to Hackage, we all had to use it!?!?!???
23:24:45 <nus-> yitz, tried application bundles?
23:25:25 <zzo38> But it does sometimes happen, that you want to add fields to an existing record or add constructors to an existing datatype, or possibly other things. I am using these things a little bit in a text adventure game system I am writing, and later on might make up a roguelike game, in both cases using both this and Hampp (a preprocessor)...
23:26:13 <zzo38> ...for example a roguelike game, you can add in stuff simply by using the wildcard import feature of Hampp and using the extensible-data stuff and it will work without having to modify the entire program in order to get it to work.
23:26:39 <yitz> nus: unfortunately we can't go that route here. the exe is part of a plugin for a large java app that is distributed as a zip file.
23:26:42 <JoeyA> I'm calling a C function with an int64_t parameter.  Can I just use Data.Int.Int64 as the type in the FFI declaration?
23:27:13 <yitz> nus: or a framework, perhaps. but sadly, we can't do anything sane like that in this case.
23:27:29 <zzo38> Now can you understand it a bit, what I am writing about?
23:27:37 <nus> yitz, yikes
23:27:51 <yitz> > fromEnum '\a' -- Paprikachu yes, it's an escape character
23:27:51 <lambdabot>   7
23:27:53 <zzo38> I would also like to know if edwardk has anything to say about it whether is same or differently or whatever
23:28:09 <edwardk> zzo38: ?
23:28:10 <mzero> JoeyA: I think you want CLLong from Foreign.C.Types
23:28:18 <edwardk> just tuned in
23:28:29 <zzo38> I do like the other stuff edwardk writes about Haskell stuff too.
23:28:39 <JoeyA> mzero: But then I'm assuming long long ~ int64_t on the target platform :(
23:29:04 <mzero> zzo38: I get it, but I admit, I don't like programming with preprocessors - and I don't like the structural hiding those approaches lead to
23:29:08 <JoeyA> I don't think that's guaranteed by the standard, but I could be wrong.
23:29:12 <zzo38> edwardk: Specifically, the "extensible-data" and "hampp" packages. But not only you; anyone who has any question/comment/complain should write.
23:29:24 * nus thinks that zzo38 is trying to solve the expression problem in a.. very idiosyncratic manner
23:29:29 <mzero> is int64_t part of C++x0?
23:29:45 * Skola thinks that's a weird use of third person : D
23:30:10 <JoeyA> int64_t's been around for ages, at least in practice.
23:30:12 <zzo38> nus: Yes that is part of it! But at first I did not even know it was called that, but some months ago I was told what it is called.
23:30:15 <Paprikachu> * C++0x
23:30:25 <nus> zzo38, the wonders of reading (-;
23:30:31 <nus> zzo38, try more
23:30:48 <edwardk> c++11 includes cstdint which contains int64_t
23:31:12 <zzo38> But it happen a lot, in mathematics especially, not only me but other people too, invented something, which was already given a name in the past so that someone else can tell them what it is called
23:31:32 <edwardk> before c++11 standardized cstdint it was part of stdint.h in c99
23:31:59 <twb> This page: http://www.haskell.org/haskellwiki/Monad_tutorials_timeline
23:32:00 <twb> ...needs this quote: Think of a monad as a spacesuit full of nuclear waste in the ocean next to a container of apples.  Now, you can't put oranges in the spacesuit or the nucelar waste falls in the ocean, *but* the apples are carried around anyway, and you just take what you need. -- dons
23:32:20 <twb> Only I can't seem to edit anonymously and ICBF making an account just for that
23:32:33 <zzo38> When programming in C, I prefer the GNU89 version of C, rather than C99 or C++0x or whatever else
23:32:44 <mzero> I see - then yes, I don't think Foreign.C.Types has caught up with the past/future (C99/C++11) --- and is stuck only at some approximate point of "around now"
23:32:49 <zzo38> I don't like all the GNU89 features but I use some
23:33:05 <twb> zzo38: non-ISO variadic macros? ;-)
23:33:57 <edwardk> zzo38: the problem is stuff like stdint.h is too useful for me to go that far back, I find myself using c99 as a minimum
23:34:19 <zzo38> twb: That is one thing.
23:35:54 <edwardk> and when doing any sort of mathematical programming in c++, i wind up needing fenv.h for rounding modes, etc. which also is c99. i don't use much of the additional language changes, but those are kinda indispensible to me
23:36:35 <Paprikachu> use <cfenv> in c++
23:36:41 <adnauseam> herk; is there a difference between these two class declarations: "fromIntegral :: (Num b, Integral a) => a -> b" AND "fromIntegral :: (Integral a, Num b) => a -> b" ?
23:37:07 <vodik> adnauseam: its the exact same thing
23:37:10 <twb> If I hadn't flunked my numerical analysis class I'd be recmomending F77
23:37:16 <adnauseam> oh, good - thanks man
23:37:22 <vodik> adnauseam: all those conditions have to apply, it doesn't matter what order you specify them
23:37:24 * hackagebot peggy 0.3.1 - The Parser Generator for Haskell  http://hackage.haskell.org/package/peggy-0.3.1 (HideyukiTanaka)
23:37:51 <Paprikachu> is there a good haskell IDE for mac?
23:38:20 <edwardk> Paprikachu: of course
23:38:21 <zzo38> But do you even have other things to say about expression problem in general?
23:38:32 <edwardk> Paprikachu: (re using cfenv)
23:38:32 <mzero> adnauseam: note, those aren't "class declarations" - they are function declarations
23:38:59 <edwardk> twb: then its a good thing you flunked ;)
23:39:11 <mzero> Paprikachu: I use Leksah -- if you get the 0.11 release it is pretty nice
23:39:11 <twb> edwardk: the class was using f77
23:39:26 <Paprikachu> lol, Leksah
23:39:28 <edwardk> *nods*
23:39:32 <twb> And I had just learnt Scheme which has a full numeric tower with bignum rats
23:39:41 <Paprikachu> its haskell without the second 'l' reversed
23:39:49 <mzero> I'm using right now as we type!
23:39:54 <edwardk> i used to teach f77 back around 94-95
23:39:56 <twb> "Why do I care about 754 when I can just use rats and let it run for a week?!"
23:40:17 <Paprikachu> i'll try it, thx
23:40:18 <edwardk> twb: hah
23:40:50 <mzero> Paprikachu: get it from this link via their mailing list: https://groups.google.com/d/topic/leksah/xf5MgyiQiVA/discussion
23:41:11 <mzero> that was the announcement of the "pre-0.12" release, numbered "0.11" -- which isn't on their site for download
23:41:20 <mzero> but - is very nice on Mac
23:41:24 <mzero> works on Lion too
23:41:30 <Paprikachu> << snow leopard
23:41:32 <Paprikachu> ^^
23:43:24 <Paprikachu> ...and it crashed
23:43:27 <Paprikachu> :X
23:43:54 <mzero> :-(  -- I didn't' let it download meta data - had it create it all locally -- if that helps
23:44:06 <Paprikachu> Dyld Error Message:
23:44:08 <Paprikachu>   Library not loaded: /usr/lib/libcurl.4.dylib
23:44:09 <Paprikachu>   Referenced from: /Applications/Leksah.app/Contents/Resources/bin/leksah
23:44:11 <Paprikachu>   Reason: Incompatible library version: leksah requires version 7.0.0 or later, but libcurl.4.dylib provides version 6.0.0
23:45:03 <zzo38> I think I managed to solve the expression problem in a reasonable way but to you it is insane and confusing and wrong. Well, that is just a different kind of opinion. Reasonable man adapt himself to the world and unreasonable man attempt to adapt the world instead, therefore progress depends on unreasonable people
23:45:04 <mzero> :-(   --- was that on start up , or only after you answered the metadata question?
23:45:21 <Paprikachu> directly on start up
23:45:31 <mzero> no idea
23:46:04 <zzo38> Can you even analyze how I am trying to solve it, to tell me one mistake, or other related things to expression problem which is related to this file?
23:47:24 * hackagebot wai-app-file-cgi 0.5.4 - File/CGI/Rev Proxy App of WAI  http://hackage.haskell.org/package/wai-app-file-cgi-0.5.4 (KazuYamamoto)
23:47:26 * hackagebot mighttpd2 2.5.4 - A classical web server on WAI/warp  http://hackage.haskell.org/package/mighttpd2-2.5.4 (KazuYamamoto)
23:48:43 <zzo38> How do *you* solve an expression problem????
23:50:05 <adnauseam> hrm. what's the difference between Integer and Integral? is integral supposed to be a complex number ?
23:50:38 <MostAwesomeDude> Integer is a type; Integral is a class of types which all behave very much like integers.
23:50:51 <adnauseam> oh, i see :o
23:50:56 <adnauseam> that clarifies it then!
23:50:58 <adnauseam> thanks man
23:50:59 <shachaf> Int doesn't behave that much like Integer.
23:51:12 <mzero> adnauseam: do you have ghci installed?
23:51:14 <srhb> adnauseam: try typing in :i Integral and :i Integer in GHCI
23:51:16 <adnauseam> yeah - i've read and tested to see their limits
23:51:22 <mzero> what srhb said
23:51:24 <Paprikachu> so.. Integral is kind of like a concept?
23:51:26 <adnauseam> oh, i'll do that
23:51:28 <MostAwesomeDude> shachaf: Add 'em, subtract 'em, etc.?
23:51:31 <zzo38> Did Johan Tibell add the TypeRep hash because of my program or for a different reason? I am just curious about that, and if a different reason, what reason?
23:52:11 <Enigmagic> zzo38: maybe you should ask him
23:52:30 <zzo38> Enigmagic: Are they on the IRC?
23:52:53 <Enigmagic> zzo38: sometimes yes, he also has email
23:53:07 <shachaf> "tibbe" on IRC.
23:53:08 <mzero> they? I'm pretty sure he is an individual
23:53:20 <zzo38> mzero: Probably.
23:53:31 <shachaf> mzero: "they" is used as a gender-neutral singular pronoun.
23:53:38 <mzero> true dat
23:53:54 <zzo38> shachaf: Yes that too. I think I put that in my Wikipedia too you can check if you want to.
23:54:20 <mzero> but at this late hour the inquiry made me think of Johann being a collective hive trying to impersonate an individual -- which made me laugh
23:54:36 <srhb> What do you mean "trying" :-)
23:54:58 <zzo38> When is he on the IRC?
23:55:12 <shachaf> An individual claiming to be Johann Tibell just gave a talk at bahaskell the other day.
23:55:26 <shachaf> mzero: How come you're never there, by the way?
23:55:31 <mzero> where's tibbe's secretary when you need him?
23:55:40 <edwardk> shachaf: probably him
23:55:46 <srhb> Lambdabot should be able to give a guess on average online-interval for a given person, hmf..
23:55:49 <edwardk> shachaf: =)
23:55:53 <shachaf> mzero: Some of the bahaskell meetings might be happening in Mountain View in the future.
23:56:01 <mzero> shachaf: because it is held in SF on a weeknight -- and I have a family and kids
23:56:08 <shachaf> Makes sense.
23:56:16 <shachaf> Hence the other statement.
23:56:52 <mzero> none the less, the timing might still not work for me -- but more likely to make it work if I can get home, see the kids, and then nip out
23:57:15 <zzo38> Do they have it in my location?
23:57:54 <mzero> if your location is the SF Bay Area - then yes
23:58:10 <mzero> (that's what the ba is in bahaskell)
23:58:26 <zzo38> OK, now I know what it is.
23:58:40 <Enigmagic> there is an experimental compiler extension that enables bahaskell in all areas
23:58:47 <zzo38> I have never been there as far as I remember
23:59:02 <shachaf> Enigmagic: That sounds dangerous.
23:59:21 <Enigmagic> shachaf: luckily it is undocumented
23:59:38 <mzero> {-# LANGUAGE ExistentialBAHaskell #-}
23:59:56 <mzero> or is it
