00:29:19 <JoeyA> newTVar TNil >>= liftM2 (liftM2 TChan) newTVar newTVar -- How far is too far?
00:31:00 <shachaf> JoeyA: One of those liftM2 is in (r ->), right?
00:31:05 <JoeyA> Yes
00:31:09 <JoeyA> The outer one
00:31:38 <JoeyA> do {hole <- newTVar TNil; liftM2 TChan (newTVar hole) (newTVar hole)}
00:32:45 <JoeyA> I'm working on a TList package (a module defining a TList type, based on the internal representation of TChan).  I'm finding a lot of pleasant surprises like this.
00:34:55 <Jafet> Too far: liftM2 (liftM2 TChan) `join` newTVar
00:35:39 <JoeyA> Surely something can be done about that repetitive application of liftM2.  Code duplication is Bad.
00:36:29 <Jafet> @pl \f g h x y -> f (g x y) (h x y)
00:36:29 <lambdabot> (liftM2 ap .) . (.) . (.)
00:47:11 <hpaste> adimit pasted “Stricness w/ HashMaps and Iteratees” at http://hpaste.org/64160
00:48:09 <adimit> 'ello. I've a space leak somewhere in the above code. If I uncomment the liftIO line, the HashMap gets forced, and my space usage remains near-constant (modulo the space requirements of the HashMap)
00:48:34 <adimit> the iteratee package is jlato's, and the HashMap is HashMap.Strict from unordered-containers.
00:49:00 <adimit> Is there anything obvious I'm missing? How would I go about trying to find the cause?
00:49:35 <opqdonut> how about a heap profile?
00:49:35 <Jafet> I believe modify is not strict.
00:49:51 <opqdonut> I believe likewise
00:50:29 <adimit> opqdonut: heap profile would be difficult, I'd have to recompile all my libraries with profiling, i.e. delete ~/.cabal, put the appropriate line in ~/.cabal/config, then recompile everything. That's why I thought I'd ask first.
00:50:56 <adimit> Jafet: interesting. I'll try an alternative then. Do you think get & put $! should do the trick?
00:51:22 <Jafet> Will it?
00:51:26 <opqdonut> interesting, I can't find modify in http://hackage.haskell.org/packages/archive/unordered-containers/0.1.4.6/doc/html/Data-HashMap-Strict.html
00:51:41 <adimit> opqdonut: modify is part of StateT.
00:51:59 <adimit> http://hackage.haskell.org/packages/archive/transformers/latest/doc/html/Control-Monad-Trans-State-Lazy.html#v:modify
00:52:09 <opqdonut> gah, stupid me, yes
00:52:11 <yitz> adimit: modify in StateT is lazy
00:52:12 <lambdabot> yitz: You have 1 new message. '/msg lambdabot @messages' to read it.
00:52:28 <Jafet> @src StateT
00:52:28 <lambdabot> Source not found. Maybe if you used more than just two fingers...
00:52:31 <Jafet> @src State
00:52:31 <lambdabot> Source not found. Just what do you think you're doing Dave?
00:52:40 <adimit> yitz: yeah, I just looked at the code. It needs to be put $! (f s), methinks.
00:52:43 <adimit> @src modify
00:52:44 <lambdabot> Source not found. My pet ferret can type better than you!
00:52:51 <adimit> … stop insulting me!
00:53:05 <Jafet> @quote lambdabot
00:53:06 <lambdabot> lambdabot says: mUEv4L-CORE: Tim3 li/\/\IT 3xcE3dEd
00:55:56 <hpaste> adimit pasted “modify'” at http://hpaste.org/64161
00:56:06 <adimit> Using the above modify', it worked.
00:56:16 <adimit> Thanks for your help, Jafet, yitz and opqdonut !
00:57:06 <adimit> I wonder why StateT doesn't provide modify'…
00:57:43 <colah_> BTW, Toronto Haskell Users Meetup 1: http://thug1.eventbrite.com/
00:57:46 <Jafet> They hadn't thunk of it.
00:57:55 <adimit> I'm even importing Control.Monad.Trans.State.Strict.
00:58:06 <adimit> Jafet: harhar.
00:59:33 <adimit> you think this warrants a bug report/feature request against transformers?
01:00:14 <opqdonut> why not
01:00:32 <adimit> because I'd have to bugger ross patterson via email, there's no bug tracker :-P
01:00:50 <adimit> *paterson
01:01:35 <tigger> Hi all! I was working on a binding, and wanted to see if anyone works with low level audio in Haskell? If so, what package do you use (alsa, portaudio, etc)? Are there any things you wish could be done more easily?
01:01:56 <ivanm> probably something cross-platform would be preferred
01:01:58 <ivanm> but I have nfi ;)
01:02:48 <mux> damn, the performance of generic-deepseq is *far* behind deepseq :-/
01:05:22 <edwardk> hrmm, am i just overlooking something or is the statistics package missing the beta distribution?
01:06:41 <edwardk> adimit: for the most part the mtl doesn't provide the strict versions of those kinds of combinators when it provides the tools for you to make them yourself
01:07:10 <adimit> edwardk: ok, so that's by design? (I was using transformers, btw.)
01:07:41 <edwardk> adimit: transformers is kind of the substrate on which mtl is built and was built by the same guy
01:08:11 <adimit> edwardk: ok, thanks. I shan't bugger Mr. Paterson then, seeing as it was intentional.
01:08:25 <edwardk> there are lots of circumstances when using a monad that you need the return $! pattern
01:08:49 <edwardk> I actually tend to encapsulate it into a combinator (<$!>) :: Monad m => (a -> b) -> m a -> m b
01:09:14 <adimit> nice, thanks for the tip :-)
01:09:16 <edwardk> to mirror the functionality of ($!) with respect to ($) for (<$>)
01:10:28 <edwardk> its in half a dozen util modules in various packages of mine, i just haven't been able to muster enough demand to bundle it anywhere and expose it
01:11:20 <adimit> edwardk: I need strict updates in Monads very often, since I'm handling large aggregate data structures in StateT and stuff like that. From me, there's "demand" :-) Though now i know it, and shall use it in my own libs as well.
01:11:35 <edwardk> *nods*
01:12:11 <adimit> I tend to usually write everything w/o strictness at all, then see if it leaks, and if it does, hit ^C like a madman and try to fix it.
01:12:33 <adimit> because my computer usually dies within seconds if one of my programs exhibits a space leak ^^
01:13:52 <edwardk> *nods*
01:13:54 <Saizan> i think it's worth to pay some attention to strictness from the start
01:13:58 <edwardk> i tend to be more paranoid
01:14:44 <adimit> Saizan: it does, but I'm afraid my understanding of Haskell's memory management and laziness/strictness in general just isn't up to the task.
01:14:50 <edwardk> in general i put ! annotations on anything that i'm just accumulating as a memoized counter/size/etc. and try to keep strict spines for structures except when i need laziness to amortize my computational bounds (like finger trees)
01:15:43 * hackagebot egison 1.0 - An Interpreter for the Programming Language Egison  http://hackage.haskell.org/package/egison-1.0 (SatoshiEgi)
01:15:51 <edwardk> blah. going to get some sleep then i guess i'll need to write a beta distribution for statistics
01:16:07 <edwardk> or try to talk bos into it
01:16:10 <edwardk> ;)
01:16:42 <Saizan> it seems like the current culture is to keep most data strict
01:18:00 <t7> has anyone had a look at C++ 'concepts'
01:18:06 <t7> its like type classes
01:18:08 <edwardk> i've really tried to make a nice super-lazy map with a lazy spine, etc and see if i can get a speedup out of it, but the number of places that have to try to fork thunks then makes it really really scary slow
01:18:37 <edwardk> t7: yeah, but i'm off to sleep
01:18:43 <edwardk> later all
01:19:18 <JJonie213> Hey if I have a list like [1, 3, 4, 7, 2, 2], any nice way to add consecutive pairs of elements to get [4, 11, 4] ?
01:20:25 <Saizan> the direct recursion way is probably nicest here
01:21:04 <Saizan> sumPairs [] = []; sumPairs (x:y:xs) = x + y : sumPairs xs;
01:21:24 <JJonie213> No simple way with prelude? I'm thinking split into even / odd indicies and zip them or something.
01:21:53 <adimit> index operations on lists are O(n)
01:22:40 <Saizan> JJonie213: uncurry zipWith (+) . partition snd . zip xs (cycle [True, False])
01:23:05 <Saizan> > uncurry (zipWith (+)) . partition snd . zip xs (cycle [True, False]) $ [1,3,4,7,2,2]
01:23:06 <lambdabot>   Not in scope: `xs'
01:23:17 <JJonie213> That's what I was looking for! thanks
01:23:21 <Saizan> > uncurry (zipWith (+)) . partition fst . zip (cycle [True, False]) $ [1,3,4,7,2,2]
01:23:22 <lambdabot>   No instance for (GHC.Num.Num GHC.Bool.Bool)
01:23:22 <lambdabot>    arising from a use of `GHC.N...
01:23:28 <everythingWorks> >3
01:23:38 <everythingWorks> > (+) 1 3
01:23:38 <lambdabot>   4
01:23:40 <JJonie213> almost? let me try it
01:23:41 <everythingWorks> :>
01:23:56 <Saizan> > uncurry (zipWith ((+) `on` snd)) . partition fst . zip (cycle [True, False]) $ [1,3,4,7,2,2]
01:23:57 <lambdabot>   [4,11,4]
01:24:21 <Ptival> String how do I sort a list of strings lexicographically?
01:24:33 <Saizan> Ptival: sort does that
01:24:49 <Saizan> from Data.List
01:25:31 <Ptival> Saizan: is there an :: Ord String?
01:26:11 <mekeor> > sort ["foo","bar"]
01:26:12 <lambdabot>   ["bar","foo"]
01:26:12 <Ptival> (maybe Ord Char and Ord a -> Ord [a]?)
01:26:12 <lambdabot> mekeor: You have 1 new message. '/msg lambdabot @messages' to read it.
01:27:49 <adimit> Ptival: exactly, there's an Ord Char. Though if you want any decent performance out of sorting strings lexicographically, I recommend using Data.Text (if don't have performance problems, then just use String and ignore me.)
01:28:46 <Ptival> adimit: yep, no performance problem at all here, it's just a small script where I want a getSortedDirectoryContents
01:29:00 <adimit> then you should be fine with String.
01:30:44 * hackagebot stm-tlist 0.1 - Mutable, singly-linked list in STM  http://hackage.haskell.org/package/stm-tlist-0.1 (JoeyAdams)
01:58:05 <adimit> I never thought I'd see the day where I'd miss heredoc functionality in Haskell's syntax…
01:58:53 <ChristianS> adimit: at least haskell supports multiline strings, which is better than nothing
01:59:19 <adimit> ChristianS: I ended up doing an unlines [String] sort of thing.
02:02:21 <adimit> It has the benefit of being able to indent code that doesn't need to be indented, which is kinda weird: http://i.imgur.com/lER6V.png
02:03:45 <ChristianS> adimit: you could to the same with multiline strings, do you know the syntax?
02:04:20 <adimit> \ at the end, \ at the start.
02:04:28 <adimit> something like multi\
02:04:30 <adimit>              \line
02:05:20 <adimit> but you have to put in your \n's manually, since it evaluates to "multiline" i.e. without the intended newline.
02:05:22 <ChristianS> yes. because the string continues after \, you can indent as much as you like (before the \ )
02:05:33 <ChristianS> true
02:06:07 <adimit> yeah, postgres is gonna beat me over the head if I forget a newline somewhere :-P
02:06:37 <adimit> but thanks, I had actually forgotten about multiline strings in Haskell. It's *rarely* used.
02:06:53 <ChristianS> i use it ;-)
02:07:12 <ChristianS> adimit: but maybe it would be better to store your sql scripts in separate files and just read them in?
02:07:25 <adimit> ChristianS: it definitely would be.
02:07:26 <ChristianS> that would also give you sql syntax highlighting etc.
02:07:55 <adimit> I just can't be arsed to do it at the moment. It's a research project, in a month, nobody's gonna care about the code anyway ^^
02:08:54 <danr> there are multiline strings in Haskell?
02:08:56 <danr> :O
02:09:23 <adimit> danr: http://www.haskell.org/pipermail/haskell-cafe/2006-January/013911.html
02:09:36 <danr> adimit: thanks!
02:25:45 * hackagebot egison 1.0.1 - An Interpreter for the Programming Language Egison  http://hackage.haskell.org/package/egison-1.0.1 (SatoshiEgi)
02:28:05 <mux> found 1642 outliers among 1000 samples (164.2%)
02:28:12 <mux> ooooookay.
02:29:56 <merijn> mux: Interesting :>
02:30:00 <Ptival> 140% ? :)
02:30:51 <ion> mux: hah
02:32:21 <mux> variance introduced by outliers: 99.900%
02:32:24 <mux> o_o
02:32:45 <mux> criterion, y u no able to use my clock??
02:38:42 <mux> dreixel: ping
02:42:07 <mekeor> mux: pong
02:42:15 * mekeor is not dreixel though
02:44:08 <mux> I was hoping he'd be interested in taking a look at why my generic-deepseq code using GHC.Generics is about a thousand time slower than the original deepseq package :-)
02:45:10 <merijn> mux: Aliens. (imagine the picture)
02:45:23 <adimit> There should be a way to tell cabal to compile my executable with +RTS options built-in, no? I'm trying to make it run on -N4 by default.
02:45:46 * hackagebot vcs-revision 0.0.1 - Facilities for accessing the version control revision of the current directory.  http://hackage.haskell.org/package/vcs-revision-0.0.1 (EugeneKirpichov)
02:47:53 <Saizan> try --ghc-option=-rtsopts
02:48:30 <Saizan> ah, i think i misunderstood
02:49:09 <adimit> Saizan: :-) I want to add an entry to my .cabal file that'd compile the executable so that it executes with +RTS -N4 always
02:49:44 <ChristianS> that functionality would have to come from ghc, not from cabal. but i never heard it's possible...
02:50:27 <Saizan> iirc there's a ghc flag for default opts
02:51:09 <adimit> ah, ok. I was just asking because I frequently forget the +RTS… also, it seems a bit strange that I can't instruct my program to use more than one core. I mean, a user would have to know about ghc's RTS-options in order to execute a program this way, isn't that strange?
02:51:15 <Saizan> and ghc-options: is a valid field in .cabal
02:52:12 <Saizan> btw +RTS -N might make more sense
02:55:28 <adimit> Saizan: I don't want to use all cores.
02:55:46 * hackagebot timeplot 1.0.5 - A tool for visualizing time series from log files.  http://hackage.haskell.org/package/timeplot-1.0.5 (EugeneKirpichov)
02:58:34 <dreixel> mux: actually, I'm just writing an email about performance of generics in GHC
02:58:56 <dreixel> mux: I'll be happy to look at generic deepseq later. I have good hopes for that.
03:13:56 <miggyx_> Hi guys, would anyone be interested in a short piece of contract work? Basically involves taking a short C (less than 100 lines) program that calculates finite difference and porting it to idiomatic Haskell…
03:15:48 * hackagebot egison 1.0.2 - An Interpreter for the Programming Language Egison  http://hackage.haskell.org/package/egison-1.0.2 (SatoshiEgi)
03:17:53 <fosskers> hey gusy
03:17:55 <fosskers> *guys
03:18:09 <Botje> miggyx_: use the ffi
03:19:17 <hpaste> fosskers pasted “Repeating a function” at http://hpaste.org/64164
03:19:26 <miggyx_> Botje: I suspect it will benefit greatly from a nice Haskell implementation. Should be a lot easier to read and reason about, and might (hopefully) have some easy parallel benefits
03:19:58 <fosskers> I was wondering if there was a better way of repeating a function
03:20:11 <osa1> which typeclass have <|> method?
03:20:27 <fosskers> that is, repeating its executing x times, feeding the output into the next execution
03:20:40 <fosskers> seeing this: http://hpaste.org/64164
03:20:43 <fosskers> will make the most sense
03:21:40 <Peaker> (got disc'd): Is there any MonadTrans instance that needs 'm' to be a Monad and not a Pointed+Functor (Or just Applicative, unfortunately)?
03:22:45 <earthy> miggyx: and you're not up to it yourself?
03:23:04 <earthy> seems that 100 lines of C should be doable in half a day, while learning enough haskell to get by
03:23:19 <chrisdone> anyone written something interesting with uhcjs yet?
03:23:19 <lambdabot> chrisdone: You have 1 new message. '/msg lambdabot @messages' to read it.
03:24:24 <chrisdone> ivanm: ivanm said 3d 2h 34m 29s ago: zomg, haskell-emacs finally lets me open .hs files properly without them being in a project!!! :D Thanks!
03:24:30 <chrisdone> ivanm: sounds like a bug to em
03:24:39 <ivanm> :o
03:25:02 <ivanm> chrisdone: you mean if i want to quickly open a .hs file to check how I did something whilst writing up a paper, I should start a project, etc. first? :s
03:25:03 <chrisdone> ivanm: don't like most features depend on being connected to a project? auto complete, hitting space…
03:25:18 <ivanm> not if I just want to open a file to *read* it!
03:25:20 <chrisdone> ivanm: ah, no. but more or less as soon as you start editing it it'll prompt for a project
03:25:28 <ivanm> oh, I can live with that
03:25:37 <chrisdone> as i can see, you're alive!
03:25:40 <ivanm> but it used to not do any syntax highlighting, etc. if I didn't have a project for it
03:25:41 * chrisdone hugs ivanm
03:25:48 <chrisdone> yeah it did
03:25:50 <ivanm> wait, what made you think I was dead? >_>
03:26:10 <chrisdone> ivanm: mother's intuition
03:26:26 <ivanm> ...
03:26:39 <chrisdone> @vixen is ivanm alive?
03:26:40 <lambdabot> You have to face the fact that whole problem is really the blacks. The key is to divise a system that reconizes this while not appearing to...
03:26:46 <ivanm> chrisdone: @vixen is no more
03:26:49 <ivanm> @nixon
03:26:49 <lambdabot> When the President does it, that means that it is not illegal.
03:26:58 <chrisdone> oh =(
03:27:09 <ivanm> because of sexist comments, etc.
03:27:18 <chrisdone> in favour of racist comments!
03:27:19 <chrisdone> yaaaay
03:27:52 <ivanm> heh
03:27:54 <chrisdone> ivanm: i'm surprised you're using haskell-emacs on a daily basis without problem
03:28:05 <ivanm> why so?
03:28:23 <ivanm> though I haven't actually done much hacking since December
03:28:32 <chrisdone> maybe that's why…
03:29:27 <chrisdone> ivanm: if scion can do stuff like loading a file without dropping all bindings you did just because it failed to load the next module, we should switch to that
03:30:05 <fosskers> can anyone tell me if theres a better way to do this ? -> http://hpaste.org/64164
03:30:23 <ivanm> for the interpreter stuff you mean?
03:30:29 <chrisdone> ivanm: yea
03:31:17 <ivanm> I also never used the tab-completion stuff all that much
03:31:30 <chrisdone> ivanm: you mean in ghci?
03:31:36 <ivanm> yeah
03:31:43 <ivanm> it was actually rather irritating, using the wrong completions
03:31:48 <ivanm> fosskers: using iterate maybe?
03:31:50 <chrisdone> i didn't know it existed…
03:32:05 <ivanm> what existed?
03:32:10 <chrisdone> the completion
03:32:18 <ivanm> @type \ f n -> take n . iterate f
03:32:18 <lambdabot> forall a. (a -> a) -> Int -> a -> [a]
03:32:27 <chrisdone> well, i mean for a long time, i didn't know, enough to get by without
03:32:32 <ivanm> @type \ f n -> (!!n) . iterate f
03:32:33 <lambdabot> forall a. (a -> a) -> Int -> a -> a
03:32:40 <ivanm> fosskers: ^^
03:32:46 <chrisdone> atm i'm using autocomplete-mode but that's only based on the project, not bindings in scope -- which appear to be kinda hard to get with ghci
03:32:58 <ivanm> chrisdone: even in the actual source code, I didn't use it all that much
03:33:10 <chrisdone> only way i could figure would be :modules → parse that → forM_ modules :browse
03:33:10 <ivanm> I'm used to typing it all out :p
03:33:22 <chrisdone> ivanm: you don't use M-/?
03:33:28 <ivanm> nope
03:33:32 <chrisdone> fool!
03:33:36 <chrisdone> =)
03:33:36 <ivanm> heh
03:33:51 <chrisdone> i mean, that's a great feature
03:34:10 <flux> I should patch it to count how many times I press it
03:34:20 <chrisdone> flux: per che?
03:34:39 <chrisdone> oh, for SCIENCE?
03:34:39 <flux> chrisdone, actually I think it should count how many character presses I've saved by using it
03:34:52 <fosskers> ivanm: iterate eh...
03:34:53 <chrisdone> yeah that could be interesting
03:35:01 <flux> chrisdone, could be negative ;)
03:35:03 <fosskers> to the docs!
03:35:07 <flux> (but likely not)
03:35:09 <ivanm> @doc iterate
03:35:09 <lambdabot> iterate not available
03:35:13 <ivanm> @doc siterate
03:35:13 <lambdabot> siterate not available
03:35:17 <ivanm> @docs iterate
03:35:17 <lambdabot> iterate not available
03:35:19 <ivanm> bah
03:35:24 <ivanm> @docs Data.List.iterate
03:35:24 <lambdabot> Data.List.iterate not available
03:35:27 <ivanm> @docs Data.List
03:35:27 <lambdabot> http://haskell.org/ghc/docs/latest/html/libraries/base/Data-List.html
03:35:30 <ivanm> there we are!
03:36:06 <fosskers> ivanm: hmm... yes okay, i had thought of this function before but couldn't recall the name.
03:36:21 <fosskers> ivanm: my function and that are doing _slightly_ different things...
03:36:38 <chrisdone> it seems that his connection is experiencing an… *puts on sunglasses* altercation
03:36:57 <alpounet> hah
03:37:18 <altercation> whoops. if that was about my irc dropouts, apologies.
03:37:43 <fosskers> ivanm: i wrote that after having done it in Scheme while following SICP
03:37:52 <altercation> migrating my haskell dev environment from archlinux to OS X… so sad
03:38:10 <silver> why
03:38:19 <altercation> why migrating or why sad?
03:38:27 <chrisdone> why sadly migrating?
03:38:53 <altercation> just doing too much photoshop these days, can't keep switching back and forth. sad to not be on xmonad.
03:41:13 <fosskers> altercation: also on arch w/ xmonad :)
03:41:31 <chrisdone> if any haskellers have free time and are wondering what to work on, do uhcjs stuff!
03:41:32 <ivanm> altercation: wine?
03:41:41 <altercation> fosskers: it's the best
03:41:46 <fosskers> wine solves everything
03:41:46 <ivanm> chrisdone: is your stuff using uhcjs?
03:41:50 <fosskers> it plays my skyrim, my STO
03:42:07 <fosskers> altercation: yes it is. Truly. My second linux and I'll probably never switch.
03:42:15 <altercation> ivanm: thought about it, but all my licenses for CS5 are mac. Beyond that, color management with Arch+Wine is terrible
03:42:30 <chrisdone> ivanm: not atm but want to replace all js with haskell so it will
03:43:00 <lpsmith> you know, sometimes I really wish Haskell had closed type classes as an option
03:43:35 <altercation> ok. sleep and up in 4 to take a child to school. ciao all...
03:43:41 <chrisdone> ivanm: "my stuff" is the purist high quality gear on the streets of FP
03:44:14 * ivanm starts slowly backing away from chrisdone 
03:44:40 <chrisdone> ivanm: the first package is free! ;)
03:44:57 * chrisdone puts a ui library and a js compiler in ivanm's hand
03:45:06 <ivanm> no you don't!
03:45:14 <quintessence> lpsmith: like Habit instance chains or just something simpler?
03:45:20 <ivanm> I'm quite happy not knowing how to make any web stuff!
03:45:32 <lpsmith> quintessence, I've not looked at Habit
03:45:36 <ivanm> or any more complex UI than library APIs or command line flags!
03:45:50 * hackagebot egison 1.0.3 - An Interpreter for the Programming Language Egison  http://hackage.haskell.org/package/egison-1.0.3 (SatoshiEgi)
03:46:02 <lpsmith> I'd just like to be able to provide a few instances for a type class and then say,  no more
03:46:03 <fosskers> ivanm: i happen to be figuring out haskell command line flags at just this very moment
03:46:31 <lpsmith> I'd kind of assume that a closed type class and all it's instances would have to be defined in the same module,  otherwise things get needlessly complicated
03:46:32 <ivanm> fosskers: I never claimed to know much about them or having had much experience :p
03:46:33 <chrisdone> ivanm: to that end you should join me and sean leather in making a type safe haskelly shell
03:47:27 <ivanm> not *another* one...
03:47:40 * sopvop looking at QtQuick.
03:47:40 <chrisdone> ivanm: that's just what jesus said sir!
03:47:42 <sopvop>  Something like that probably can be done in haskell, without dynamic typing.
03:48:06 <ivanm> instead, I should really either a) get this graph stuff sorted out (starting off with this blog post I've been meaning to write for a while), or b) add native Cabal support to paludis (*shudder* C++ *shudder*)
03:48:43 <chrisdone> ivanm: and while you're working on that cabal c++ stuff, think about how great your shell could be
03:48:52 <alpounet> sopvop, yeah, that'd be great
03:48:56 <ivanm> chrisdone: heh
03:48:58 <alpounet> and let people write awesome tools
03:49:08 <alpounet> but... we don't have such a thing.
03:49:09 <ivanm> chrisdone: so you're not a fan of any of the other attempts of making a haskelly shell?
03:49:10 <chrisdone> ivanm: (seriously, ideas welcome)
03:49:20 <chrisdone> ivanm: you mean the ones that aren't 404?
03:49:54 <ivanm> I said they were "attempts"
03:49:57 <ivanm> ;)
03:50:09 <ivanm> but I take it they weren't salvageable?
03:50:52 * hackagebot egison 1.0.4 - An Interpreter for the Programming Language Egison  http://hackage.haskell.org/package/egison-1.0.4 (SatoshiEgi)
03:50:58 <Philippa> is there anybody here who's moderately familiar with type systems and willing to proof read a blog post for me? I'm getting a little paranoid about having made an embarrassing mistake in some of the LaTeX
03:51:31 <chrisdone> ivanm: it's more that i haven't seen one that tackles the user-interface aspect
03:51:43 <ivanm> ahhh, right
03:51:43 <sopvop> alpounet: yeah, lot's of work, and no nokia paying to for it
03:51:50 <ivanm> I've been meaning to try out fish for a few years now...
03:51:56 <alpounet> sopvop, yeah
03:52:10 <ivanm> Philippa: you write blog posts in LaTeX?
03:52:18 <alpounet> although that was actually started by only one or two of the employees as part of the "Creative Friday" thing they have over there
03:52:18 <ivanm> what blog engine are you using? :/
03:52:32 <Abraxas> wadler's paper about free theorems makes my head hurt
03:52:34 <Philippa> I write posts including LaTeX, because talking about inference rules without it's a PITA
03:52:54 <Philippa> the LaTeX snippets get rendered down to .png
03:53:01 <ivanm> alpounet: isn't QtQuick touted as the future of Qt or something nowadays?
03:53:04 <ivanm> Philippa: oh, for the math stuff?
03:53:07 <Philippa> right
03:53:10 <Abraxas> is it just me or should i read it backwards?
03:53:14 <adimit> ivanm: I'm using blogspot.com, which accepts html. I use pandoc to generate the html, and most latex just gets compiled to unicode symbols :-)
03:53:26 <alpounet> ivanm, yeah, for the "common" UIs
03:53:29 <Philippa> in particular: maths stuff that's not handled by most of the LaTeX maths renderers
03:53:30 <lpsmith> quintessence, could instance chains be used to implement closed classes?
03:53:43 <alpounet> like, whenever you don't want some exotic widget
03:53:57 <Philippa> adimit: yeah, I've got a few hundred lines of pandoc client that does my rendering, etc etc
03:53:58 <quintessence> lpsmith: the version I looked at (I forget if it was ilab or Habit) had explicit failure
03:54:13 <alpounet> and i was really annoyed we don't have such a thing after having watched the "Inventing on Principle" talk
03:54:19 <adimit> pandoc is just seriously awesome.
03:54:45 <alpounet> would anyone happen to have a function that looks for files with a given extension in subdirectories?
03:54:58 <alpounet> (and their subdirs, etc)
03:55:01 <sopvop> alpounet: separating layouts and rendering from widgets is awesome. But as I understand there is no "plastique" style css (or whatever they use for styling) out there. just mobile like apps, right?
03:55:02 <quintessence> so you could put "instance YourClass a fails" at the end of the chain and nobody would be able to define another instance chain
03:55:25 <chrisdone> alpounet: without sounding obnoxious, something like shell "find" [".","-name *.hs"]?
03:56:06 <alpounet> sopvop, i haven't been following it closely, i just played with that when it wasn't released yet, just after they announced it at their dev conference in Berlin a few years ago
03:56:36 <ivanm> alpounet: I've got some code that kinda does that in SourceGraph
03:56:38 <ivanm> it's rather hacky though
03:56:49 <ivanm> as it was my first real Haskell project, and I've never bothered to update it ;)
03:56:51 <alpounet> chrisdone, that would be exactly this, was just wondering if i could avoid calls to the shell...
03:57:10 <alpounet> (well, except it'd look for cabal files)
03:57:22 <ivanm> otherwise, something like the Glob package?
03:57:24 <ivanm> @hackage Glob
03:57:24 <lambdabot> http://hackage.haskell.org/package/Glob
03:58:12 * ivanm -> land of Nod
04:01:46 <alpounet> i guess i'll roll my own
04:01:49 <alpounet> but has to be done somewhere
04:09:21 <alpounet> hey, that could help http://hackage.haskell.org/package/directory-tree
04:15:26 <alpounet> okay, in case this can help anyone, i found what i need: http://hackage.haskell.org/packages/archive/filemanip/0.3.5.2/doc/html/System-FilePath-Find.html
04:33:28 <Dennis___> Does a * inside a type declaration like 'data EntityFiel val :: * -> *' have a special meaning or is it a ordinary type variable? The former declaration is inside a class definition.
04:34:40 <sipa> It's a kind.
04:34:53 <Saizan> * is the kind of types which can have values
04:34:56 <sipa> A kind is to types what a type is to values.
04:35:22 <Saizan> e.g. Int :: *, Bool :: *; Maybe Bool :: *
04:35:43 <sipa> For example Int or (Maybe (IO [String])) are kind *
04:35:52 <adimit> But Maybe is a type constructor, kind * -> *
04:36:18 <sipa> :k Maybe
04:36:18 <lambdabot> * -> *
04:36:23 <adimit> (i.e. take I type of kind * and produce a type of kind * in return. like a function.)
04:36:54 <Dennis___> ah, thanks
04:44:41 <JustMaybe> how do ir egister with nickserv?
04:45:03 <mekeor> @pl \x y->func (x==y) 1 0
04:45:03 <lambdabot> flip flip 0 . flip flip 1 . (func .) . (==)
04:45:06 <Saizan> JustMaybe: /msg nickserv help register
04:46:02 <mekeor> @pl \x y->func 1 0 (x==y)
04:46:02 <lambdabot> (func 1 0 .) . (==)
04:54:07 <JustMaybe> how to register with NickServ?
04:54:54 <ion> @google how to register with nickserv
04:54:56 <lambdabot> http://oreilly.com/pub/h/1940
04:54:56 <lambdabot> Title: Register with NickServ
04:55:02 <Landarzar> Type \NickServ help register
04:55:10 <Landarzar> \NickServ help register
04:55:16 <Landarzar> mhm
04:55:32 * Clint squints.
04:55:47 <Landarzar> Type /msg NickServ help register
04:55:59 <mike-burns> I bet there's a place to ask this that isn't #haskell.
04:56:04 <mike-burns> @google google
04:56:06 <lambdabot> http://www.google.com/
04:56:06 <lambdabot> Title: Google
04:56:13 <mike-burns> There's one.
05:05:53 * hackagebot augeas 0.6.0 - A Haskell FFI wrapper for the Augeas API  http://hackage.haskell.org/package/augeas-0.6.0 (JudeNagurney)
05:15:55 * hackagebot ddc-base 0.2.1.1 - Disciple Core language common utilities.  http://hackage.haskell.org/package/ddc-base-0.2.1.1 (BenLippmeier)
05:20:06 <t7> > let a = 1 :: forall a. Int in a
05:20:07 <lambdabot>   1
05:20:16 <t7> lambdabot: !
05:20:54 * hackagebot ddc-core 0.2.1.1 - Disciple Core language and type checker.  http://hackage.haskell.org/package/ddc-core-0.2.1.1 (BenLippmeier)
05:20:56 * hackagebot ddc-core-eval 0.2.1.1 - Disciple Core language semantic evaluator.  http://hackage.haskell.org/package/ddc-core-eval-0.2.1.1 (BenLippmeier)
05:24:47 <MaybeJust> tomodo: why do you say things when you have no clue?
05:25:58 * hackagebot ddc-core-simpl 0.2.1.1 - Disciple Core language simplifying code transformations.  http://hackage.haskell.org/package/ddc-core-simpl-0.2.1.1 (BenLippmeier)
05:26:00 * hackagebot ddci-core 0.2.1.1 - Disciple Core language interactive interpreter.  http://hackage.haskell.org/package/ddci-core-0.2.1.1 (BenLippmeier)
05:30:29 <opqdonut> using view patterns as quick'n'dirty preconditions: https://gist.github.com/1885148
05:30:54 * hackagebot egison 1.0.5 - An Interpreter for the Programming Language Egison  http://hackage.haskell.org/package/egison-1.0.5 (SatoshiEgi)
05:31:42 <imc> opqdonut: nice :)
05:35:23 <rostayob> opqdonut: in that case you get a more informative message without 'error' anyways
05:35:48 <rostayob> (divide by zero instead of "check failed")
05:35:52 <mekeor> yippie! imc is online again!
05:35:58 <mekeor> > 1/0
05:35:58 <lambdabot>   Infinity
05:36:08 <mekeor> > 0/0
05:36:09 <lambdabot>   NaN
05:36:33 <rostayob> > 1 `div` 0
05:36:34 <lambdabot>   *Exception: divide by zero
05:37:12 <mekeor> > 1$2
05:37:13 <lambdabot>   1
05:37:20 <mekeor> lol
05:37:30 <mekeor> what i do not understand is:
05:37:33 <merijn> mekeor: lambdabot numbers are special
05:37:34 <mekeor> :t 1 2
05:37:35 <lambdabot> forall t t1. (Num (t1 -> t), Num t1) => t
05:37:42 <mekeor> merijn: ah ok
05:37:47 <merijn> I think Num is an instance of Functor in lambdabot
05:38:00 <rostayob> > fmap (+ 1) 5
05:38:01 <lambdabot>   No instance for (GHC.Num.Num (f a))
05:38:01 <lambdabot>    arising from a use of `e_115' at <in...
05:38:05 <merijn> Or is it vice versa? Someone remind me...
05:38:07 <rostayob> merijn: they are
05:38:11 <opqdonut> rostayob: sure, it's just a simple example. and of course "check" could take an additional string argument
05:38:12 <rostayob> but I can't remember how they work
05:38:27 <rostayob> opqdonut: you shouldn't use error for this precoditions anyways
05:38:39 <rostayob> but simply plan your datatypes better
05:39:07 <mekeor> > map (+) [1 2,3 4, 5 6]
05:39:08 <lambdabot>   Overlapping instances for GHC.Show.Show (a -> a)
05:39:08 <lambdabot>    arising from a use of `...
05:39:11 <imc> mekeor: you maybe want to try out Curry?
05:39:23 <mekeor> imc: i know curry...
05:39:31 <opqdonut> rostayob: right, a "newtype Positive = Positive int" with a smart constructor
05:39:34 <mekeor> not only haskell curry but also currying..
05:39:41 <imc> mekeor: Curry the programming language
05:39:42 <rostayob> opqdonut: well in *that* case
05:39:42 <opqdonut> rostayob: I agree it's not perfect design, I just thought it was a cute hack
05:39:48 <rostayob> I'd simply leave the exceptions fly
05:39:50 <mekeor> imc: ah. okay :D
05:39:52 <imc> http://www-ps.informatik.uni-kiel.de/currywiki/
05:39:57 <rostayob> (the divide by zero exceptions)
05:40:02 <imc> haskell + "prolog"
05:40:26 <DarkUnicorn> did i read curry there?
05:40:29 <imc> or Agda (haskell + dependenty types)
05:40:33 <mekeor> imc: hm.. okay.. and what does it have to do with `1 2' ?
05:40:44 <imc> mekeor: it has to do to preconditions
05:40:50 <DarkUnicorn> imc: from where do you know curry?
05:40:50 <mekeor> imc: i know agda (in that sense that i tried it).
05:40:51 <imc> oups, sorry wrong person
05:40:56 * imc shame
05:41:14 <mekeor> huh?
05:41:17 * mekeor is confused..
05:41:22 <imc> was about this thing here : 14:30:07 < opqdonut> using view patterns as quick'n'dirty preconditions: https://gist.github.com/1885148
05:41:50 <imc> well sorry for the confusion
05:41:54 <mekeor> np
05:41:55 <mekeor> :)
05:42:09 <mekeor> imc: are you from germany, btw? the time zone would match.. :)
05:42:17 <imc> a lot of TZ match
05:42:29 <mekeor> anyway..
05:42:33 <imc> nope
05:42:33 <imc> :)
05:42:40 <imc> germany is .de
05:42:43 <mekeor> what a bmmer.
05:42:45 <mekeor> yep.
05:42:45 <imc> i'm .ch here
05:42:49 <mekeor> ah, ok.
05:43:08 <mekeor> i hadn't /whois'ed you yet..
05:43:13 <imc> DarkUnicorn: don't recall exactly
05:43:15 <imc> DarkUnicorn: google ?
05:43:31 <imc> DarkUnicorn: was researching a bit about theorem provers
05:43:55 <tejaswidp> is http://tryhaskell.org/ down ?
05:44:11 <DarkUnicorn> imc: oh okay. i just asked because i'm at uni kiel here
05:44:29 <mekeor> the yet only bad thing i know about curry is that they don't have an IRC channel, do they?
05:44:59 <mekeor> DarkUnicorn: yippie! let's found #curry (although we (at least me) don't know it, hehe)
05:45:25 <mekeor> DarkUnicorn: you are welcome on #haskell.de then, btw..
05:45:34 <DarkUnicorn> there is a haskell.de?
05:45:37 <mekeor> yep
05:45:55 <rostayob> imc: curry looks cool, I'll try it out
05:46:13 <DarkUnicorn> rostayob: it is cool, just a bit hard to set up
05:46:21 <rostayob> and it runs on SICStus, which I happen to have
05:46:21 <imc> :)
05:46:35 <rostayob> or at least the PAKCS thing
05:47:21 <DarkUnicorn> with SICStus you can't use the advanced features
05:47:39 * mekeor wants to try out #idris, #agda, #isabelle, #epigram, #curry, #coq, ... 
05:47:50 <imc> mekeor: good luck
05:47:56 <mekeor> heh :)
05:48:03 <rostayob> DarkUnicorn: it says sicstus is the recommended platform
05:48:09 <zomg> Argument on a PHP channel about what syntax is better: Ruby, Python or Haskell
05:48:11 <zomg> Fun times
05:48:12 <zomg> :D
05:48:23 <imc> zomg: on a *PHP* channel?
05:48:26 <imc> omg
05:48:41 <DarkUnicorn> rostayob: isn't sicstus the free one?
05:48:45 <rostayob> DarkUnicorn: no
05:48:50 <rostayob> that's swi
05:49:08 <rostayob> the problem with Prolog and APL is that the best implementations are proprietary
05:49:21 <DarkUnicorn> rostayob: okay i meant the free one
05:49:50 <rostayob> expecially APL, I'd like something like dyalog but open source :(
05:50:02 <rostayob> that'd be a nice side project actually...
05:51:51 <rostayob> also SICstus has the best emacs-mode
05:51:58 <rostayob> end of rant.
05:52:05 <MaskRay> Common Lisp has similar problem?
05:52:55 <rostayob> MaskRay: the best CL is proprietary?
05:53:05 <rostayob> I don't like lisp :P
05:53:47 <imc> zomg: throw them this one : http://en.wikipedia.org/wiki/MUMPS  i.e. the programming language with most obscure concrete syntax
05:54:12 <imc> from that page:
05:54:16 <imc> "Abbreviation: You can abbreviate nearly all commands and native functions to one, two, or three characters."
05:55:30 <rostayob> imc: and you're supposed to program hospitals with that. smart.
05:55:40 <MaskRay> rostayob: lispworks may be the best though its price is unacceptable
05:55:44 <imc> rostayob: indeed
05:56:24 <rostayob> MaskRay: I got good at writing convincing emals to get educational licenses :D
05:56:29 <imc> i got an answer to a job application asking me if I was ready for a real "challange" (and it wasn't at all the job i've applied to)
05:56:33 <imc> I kindly declined the offer
05:57:04 <imc> the main task was to maintain/develop a MUMPS codebase
05:57:23 <rostayob> MaskRay: what I wonders is how these people continue to make money with those prices... who buys those things? anyway, -blah material
05:57:24 <imc> i would better work as a dish washer
05:58:11 <rostayob> MaskRay: they're buzzword compliant ("Entrprise" edition)
05:58:44 <imc> i know how
05:59:00 <imc> it's so obscure that they cannot find people understanding the code to migrate it to another language
05:59:05 <imc> they're stuck with it
05:59:26 <rostayob> imc: I was talking about dyalog, sicstus and lispworks
05:59:29 <imc> oups
05:59:31 <rostayob> I mean APL is quite obscure.
05:59:31 <imc> sorry
05:59:32 <imc> :)
05:59:53 <rostayob> but prolog and lispworks? who is willing to pay ks of $ to use CL/Prolog?
06:00:30 <MaskRay> rostayob: yes, i thought they ruin the industry indirectly
06:01:31 <rostayob> I can understand MATLAB, but CL?
06:01:44 <rostayob> who are the big enterprise users of CL?
06:02:20 <merijn> Especially since there are some very decent/good free CL implementations
06:02:23 <hpaste> adimit pasted “Clumsy transformers” at http://hpaste.org/64166
06:02:26 <adimit> So, this feels like a clumsy use of transformers, to have to define your own liftX function like that. Is there another way?
06:03:03 <adimit> (I could alternatively just export the constructor A, but that feels even worse!)
06:03:52 <rostayob> adimit: use typeclasses
06:04:04 <rostayob> with GeneralizedNewtypeDeriving you can derive MonadReader, MonadIO, etc.
06:04:24 <rostayob> instead of manually lifting
06:04:58 <rostayob> adimit: in general the Monad* classes help a lot in writing generic code, so write your function with those constraints only
06:06:25 <adimit> rostayob: ah, thanks.
06:06:58 <adimit> rostayob: I tried that first, but it din't work. I gave it some more thought and Control.Monad.Reader instead of Control.Monad.Trans.Reader. Now it works.
06:13:07 <rostayob> adimit: why wouldn't Control.Monad.Reader work?
06:13:53 <rostayob> adimit: ah, you said the opposite (Trans didn't work, since there is no MonadReader class in transformers)
06:13:55 <rostayob> cool
06:13:59 * rostayob goes to have lunch
06:15:01 <adimit> rostayob: have a nice meal :-)
06:18:31 <srhb> Using GLUT, I keep needing things like Vertex3 x y z, but I seem to have to explicitly type x, y, z as GLfloat.. Can I do something like create a value constructor synonym which takes only GLfloats?
06:19:21 <Saizan> just define a function
06:20:23 <srhb> Something like glVertex3 = Vertex3 (x :: GLfloat) y z ?
06:21:03 <Saizan> glVertex3 x y z = Vertex3 (x :: GLfloat) y z
06:21:12 <srhb> Yes, of course. Thank you
06:22:49 <srhb> Is it possible to pass value constructors as arguments nakedly?
06:22:59 <srhb> I suppose it is nt.
06:23:19 <rwbarton> sure, I guess? they are also values, so you can pass them as arguments to functions
06:23:22 <srhb> Aha
06:23:26 <adimit> srhb: if you mean something like "Just", it's just a function.
06:23:31 <luite> > map Just [1..5]
06:23:32 <lambdabot>   [Just 1,Just 2,Just 3,Just 4,Just 5]
06:23:34 <adimit> :t Just
06:23:35 <lambdabot> forall a. a -> Maybe a
06:23:46 <rwbarton> but you can't pass a constructor through a function parameter and then pattern match against it or anything like that
06:23:50 <srhb> So I could do glize t x y z = t (x :: GLfloat) y z ?
06:24:00 <rwbarton> yes, you could
06:24:03 <srhb> Wow.
06:24:09 <srhb> That's amazing.
06:24:16 <adimit> Haskell generally is.
06:24:28 <srhb> I keep having those moments. O:-)
06:31:53 <t7> https://github.com/tm1rbrt/haskell/blob/master/lambdacalc/systemfomega.hs <- systemf omega without inference
06:35:50 <osa1> does functions with @ in their names have special meanings?
06:36:41 <fryguybob> osa1: http://www.haskell.org/haskellwiki/Keywords#.40
06:36:48 <Jafet> > let ($@) = id in f $@ x
06:36:49 <lambdabot>   Ambiguous type variable `a' in the constraints:
06:36:49 <lambdabot>    `GHC.Show.Show a'
06:36:49 <lambdabot>      a...
06:37:20 <osa1> thanks
06:40:06 <ChristianS> preflex: seen plucas
06:40:06 <preflex>  plucas was last seen on #haskell 1 day, 16 hours, 24 minutes and 59 seconds ago, saying: mhitza: that emits 4 permutations and then seems to block indefinitely
06:40:39 <ChristianS> preflex: seen dylukes
06:40:40 <preflex>  dylukes was last seen on #haskell-blah 11 hours, 33 minutes and 5 seconds ago, saying: I'm a bit busy ;__;
06:44:10 <hpaste> ChristianS pasted “Set creation and population tests” at http://hpaste.org/64167
06:45:45 <ChristianS> @tell plucas for updates to our set creation tests from last week, see http://hpaste.org/64167
06:45:45 <lambdabot> Consider it noted.
06:45:56 <ChristianS> @tell dylukes for updates to our set creation tests from last week, see http://hpaste.org/64167
06:45:56 <lambdabot> Consider it noted.
06:46:38 <mysticc> @hoogle confluence
06:46:38 <lambdabot> No results found
06:46:46 <mysticc> @hoogle Confluence
06:46:46 <lambdabot> No results found
06:48:41 <mysticc> Where I can see details of all the language extensions ??
06:49:53 <rostayob> mysticc: GHC manual
06:50:07 <rwbarton> http://hackage.haskell.org/trac/ghc/wiki/Building/GettingTheSources
06:50:09 <t7> :t id
06:50:10 <lambdabot> forall a. a -> a
06:50:15 <t7> :t id id
06:50:16 <lambdabot> forall a. a -> a
06:51:28 <t7> how does the type checker reduce that
06:51:52 <hpc> id x = x
06:51:54 <hpc> id id = id
06:51:56 <hpc> id
06:51:59 <t7> (forall a. a -> a) -> (forall a. a -> a)
06:52:04 <hpc> oh
06:52:05 <rwbarton> let me rename them id1 :: a -> a and id2 :: b -> b
06:52:16 <mysticc> whats difference between types :  forall a . a -> a -> b and (forall a. a -> a) -> b ?
06:52:22 <rwbarton> since you are applying id1 to id2 we must have a = (b -> b)
06:52:31 <hpc> :t let f = id, g = id in (f g, f, g)
06:52:32 <lambdabot> parse error on input `,'
06:52:36 <hpc> :t let f = id; g = id in (f g, f, g)
06:52:37 <lambdabot> forall a a1 a2. (a -> a, a1 -> a1, a2 -> a2)
06:52:37 <rwbarton> and the result is also a, that is b -> b
06:54:55 <rwbarton> the type checker doesn't actually instantiate the type of id1 to (forall b. b -> b) -> (forall b. b -> b)
06:55:03 <rwbarton> > id (id :: forall b. b -> b)
06:55:03 <lambdabot>   Overlapping instances for GHC.Show.Show (b -> b)
06:55:04 <lambdabot>    arising from a use of `...
06:55:14 <rwbarton> though apparently this works anyways
06:55:40 <t7> :k id
06:55:41 <lambdabot> Not in scope: type variable `id'
06:55:59 <t7> i think  i have done something very wrong
06:56:12 <mux> yes, kinds apply to types, not values
06:56:21 <t7> :k forall a. a -> a
06:56:22 <lambdabot> *
06:56:26 <t7> wut...
06:56:37 <mux> this is all good
06:56:38 <t7> i thought that was * -> *
06:56:41 <mux> no
06:56:44 <mux> :k Maybe
06:56:44 <lambdabot> * -> *
06:56:47 <tomodo> :k Maybe
06:56:47 <lambdabot> * -> *
06:56:56 <mux> Maybe has kind * -> * because it takes a type parameter
06:56:56 <rwbarton> any type which is the type of a value has kind *
06:57:08 <t7> oh bugger :P
06:58:18 <DrChill> woo
07:01:41 <DrChill> HueHueHueHue
07:02:23 <DanBurton> :k String -> Bool
07:02:24 <lambdabot> *
07:02:40 <DrChill> i agree
07:03:06 <_Mikey> :k (String->Int) -> Bool
07:03:07 <lambdabot> *
07:03:18 <DrChill> that makes sense aswell
07:03:22 <_Mikey> :k (String->Int) -> (Int->Bool)
07:03:23 <lambdabot> *
07:03:33 <_Mikey> >_O
07:03:39 <DrChill> now i have to doubt
07:05:39 <mysticc> :k Either
07:05:40 <lambdabot> * -> * -> *
07:05:47 <rostayob> :k (->)
07:05:48 <lambdabot> ?? -> ? -> *
07:06:01 <mysticc> :t (->)
07:06:02 <lambdabot> parse error on input `->'
07:06:15 <mysticc> whats ?? and ? here
07:06:19 <Ptival> haha
07:06:36 <rostayob> unboxed types
07:06:57 <rostayob> I mean they're the kind of unboxed types, iirc
07:06:58 <maurer> rostayob: Don't you mean kinds, not unboxed types?
07:07:01 <rwbarton> ? is the union of * (the kind of types that are the types of regular, boxed values) and # (the kind of types that are the types of unboxed values)
07:07:04 <_Mikey> Hmmm
07:07:08 <_Mikey> :k String
07:07:08 <DanBurton> types that include unboxed types, rather
07:07:09 <lambdabot> *
07:07:14 <Ptival> mysticc: http://hackage.haskell.org/trac/ghc/wiki/IntermediateTypes < see the little ASCII diagram here
07:07:15 <maurer> Ah, OK
07:07:16 <_Mikey> :k Maybe
07:07:17 <lambdabot> * -> *
07:07:18 <hpc> ?? is *, #, (#), yes?
07:07:18 <lambdabot> Plugin `compose' failed with: Unknown command: ""
07:07:21 <_Mikey> Ahhh
07:07:22 <_Mikey> :D
07:07:28 <rwbarton> hpc: yes
07:07:36 <rwbarton> er
07:07:39 <rwbarton> maybe
07:07:53 <hpc> rwbarton: ive been trying for a year now to remember which is which :P
07:07:54 <rwbarton> no, I had them backwards
07:07:55 <t7> when i type check (id id) i get (forall a.a -> a) -> (forall b.b -> b)
07:08:05 <t7> (in my language)
07:08:22 <t7> is that wrong?
07:08:31 <rwbarton> most likely
07:08:36 <rwbarton> shouldn't id id 'x' be valid
07:09:28 <mysticc> :k Int
07:09:29 <lambdabot> *
07:09:31 <mysticc> :k Int#
07:09:32 <lambdabot> Not in scope: type constructor or class `Int#'
07:09:40 <Jafet> :t id id
07:09:40 <lambdabot> forall a. a -> a
07:10:49 <t7> how does it know :(
07:11:27 <t7> some kinda reduction step im missing
07:11:49 <rwbarton> it looks like maybe you are assuming that the two instances of id have the same type?
07:12:03 <osa1> what's the point of String parameter of Monad's fail function? can you give an example Monad using this parameter for an useful purpose
07:12:14 <rostayob> rwbarton++
07:12:27 <rostayob> t7: you're not getting a quantified instance of 'id' each time
07:12:33 <cmccann> > fail "fail" :: Either String ()
07:12:34 <mysticc> @hoogle fail
07:12:34 <lambdabot>   *Exception: fail
07:12:34 <lambdabot> Prelude fail :: Monad m => String -> m a
07:12:35 <lambdabot> Control.Monad fail :: Monad m => String -> m a
07:12:35 <lambdabot> Control.Monad.Instances fail :: Monad m => String -> m a
07:12:41 <hpc> > fail "uh oh" :: Writer String Int
07:12:41 <lambdabot>   No instance for (GHC.Show.Show
07:12:42 <lambdabot>                     (Control.Monad.Trans.Wri...
07:12:42 <cmccann> hm
07:12:43 <rwbarton> osa1, it's used in the desugaring of pattern matches in do blocks
07:12:44 <hpc> pah
07:13:20 <rwbarton> > do [x] <- Just [3]; [y] <- Just [4, 5]; return [x, y]
07:13:21 <lambdabot>   Nothing
07:13:25 <hpc> osa1: mostly it's so that the default definition can be "fail = error"
07:13:26 <rwbarton> oops bad example :P
07:13:37 <mysticc> > fail "fail"
07:13:38 <lambdabot>   No instance for (GHC.Show.Show (m a))
07:13:38 <lambdabot>    arising from a use of `M6624568559...
07:13:43 <mysticc> wtf
07:13:43 <rwbarton> > do [x] <- Right [3]; [y] <- Right [4, 5]; return [x, y]
07:13:44 <lambdabot>   *Exception: Pattern match failure in do expression at <interactive>:3:21-23
07:13:47 <t7> > (id id) 123
07:13:48 <lambdabot>   123
07:14:12 <rwbarton> there it told me which pattern match failed
07:14:21 <cmccann> > runIdentity $ runErrorT (fail "abc" :: ErrorT String Identity ())
07:14:22 <lambdabot>   Left "abc"
07:14:36 <osa1> is >> and fail optional for Monads?
07:15:00 <hpc> @src (>>)
07:15:00 <lambdabot> m >> k      = m >>= \_ -> k
07:15:03 <rostayob> osa1: they have default definitions
07:15:05 <hpc> @src fail
07:15:05 <lambdabot> fail s      = error s
07:15:09 <rostayob> (sadly, for fail...)
07:15:16 <rostayob> which shouldn't be in Monad
07:15:53 <hpc> having fail in its own type class would be actually kind of awesome
07:16:08 <hpc> you would have a type-level promise that monadic code didn't use (pattern) <- expr
07:16:15 <rostayob> hpc: it would be much better
07:16:34 <_Mikey> could that change in the future?
07:16:37 <_Mikey> or is it too late now?
07:16:47 <rostayob> _Mikey: probably too late, but you never know with Haskell :)
07:16:56 <rwbarton> you could still write "x <- expr; let (pattern) = x"
07:17:14 <rostayob> there are other warts in those type classes (Monad should always be Applicative)
07:17:30 <rwbarton> which isn't quite the same, but... I'm not sure what you're getting at exactly
07:17:47 <hpc> i vote that we fix Monad for ghc 8
07:18:02 <rostayob> rwbarton: patter <- expr in do has a special meaning
07:18:03 <hpc> and just force people to fix their stuff
07:18:05 <rostayob> it fails if the pattern fails
07:18:08 <rwbarton> anyways I quite agree that a separate type class for pattern matches that may fail would be very nice
07:18:09 <osa1> @src (<-)
07:18:09 <lambdabot> Source not found. Your mind just hasn't been the same since the electro-shock, has it?
07:18:12 <rwbarton> yes I know
07:18:20 <rwbarton> (er, in do blocks I mean)
07:18:32 <rostayob> rwbarton: well than it would be different
07:18:39 <rostayob> since using let you'd get a warning
07:18:46 <osa1> ok, Monad's definiton doesn't include a function with type of m a -> a, so what's <- in do notation calling?
07:18:46 <cmccann> I don't see why "(x, y) <- expr" should be disallowed
07:18:53 <rwbarton> I would?
07:19:10 <hpc> @undo do {x <- y; z x} -- osa1
07:19:11 <lambdabot> y >>= \ x -> z x
07:19:11 <rostayob> rwbarton: well if 'fail' wasn't included in Monad
07:19:45 <osa1> hpc: oh so it's a kind of special operator, right?
07:19:53 <hpc> it's syntactic sugar
07:19:58 <rwbarton> I'm just saying, in view of the fact that in many monads, we have fail = error anyways, we don't gain any strong guarantees from the type system by doing this
07:20:06 <hpc> it disappears almost first thing when compiled
07:20:45 <rostayob> rwbarton: well the fact that people can't use 'fail' in a Monad does give "guarantees"
07:20:53 <rostayob> now of course you can always write partial code in haskell :P
07:20:57 <rwbarton> not really, since you can write "x <- expr; let (pattern) = x"
07:21:24 <rostayob> rwbarton: yeah but what's you're point? you can always write 'error' then
07:21:26 <rwbarton> or maybe I just don't see what the guarantee is
07:21:34 <rwbarton> my point is what's *your* point :)
07:21:39 <rwbarton> there is no extra guarantee
07:21:49 <rwbarton> it's just aesthetically nicer
07:22:00 <rwbarton> you cannot rule out error by making the Monad class smaller
07:22:08 <rostayob> rwbarton: no of course not
07:22:21 <rwbarton> right, that's all I was saying then.
07:22:27 <hpc> rwbarton: it's a guarantee if you assume "writing x <- foo; let pat = x" is a huge pain in the ass
07:22:37 <rwbarton> that's a pretty weak "guarantee" :P
07:22:39 <hpc> rwbarton: it's sort of a "you have to earn that partiality" guarantee
07:22:41 <cmccann> do partial matches in do blocks cause warnings due to inexhaustive patterns?
07:22:44 <rostayob> but you wouldn't have 'error' put there for you by the compiler
07:22:57 <hpc> rwbarton: it's the same strength as the IO guarantee in the presence of unsafePerformIO
07:22:59 <rostayob> rwbarton: btw hpc used the word guarantee. I put it in quotes :P
07:23:08 <rostayob> cmccann: no
07:23:10 <cmccann> because if removing fail would increase the number of things that generate that warning, that's something tangible
07:23:13 <hpc> ie, that stuff in IO stays in IO
07:23:21 <rostayob> cmccann: it's a feature, 'fail' gets called on partial matches
07:23:24 <rwbarton> let pat = x doesn't generate a warning either
07:23:38 <cmccann> rwbarton, wait, seriously? it doesn't?
07:23:44 <rwbarton> well with -Wall it probably does
07:23:48 <cmccann> that's what I meant.
07:23:49 <rostayob> rwbarton: it doesn't?
07:23:50 <rwbarton> I mean with default, no extra warning options
07:23:52 <rostayob> I'd bet it does
07:24:02 <rwbarton> it didn't with -Wall either, in ghci
07:24:09 <rostayob> yeah but do { pat <- foo } never generates a warning
07:24:12 <rostayob> really? that's weird
07:24:14 <rwbarton> > let Just y = Just 3  -- long warning about defaulting
07:24:15 <lambdabot>   not an expression: `let Just y = Just 3  -- long warning about defaulting'
07:24:26 <cmccann> huh. that seems like a misfeature.
07:24:28 <rwbarton> oops
07:24:30 <rwbarton> sorry lambdabot
07:25:25 <rostayob> rwbarton: you're right
07:25:28 <merijn> > let Just y = Just 3 in y -- like this?
07:25:29 <lambdabot>   3
07:25:36 <rostayob> do let binding in do blocks invoke fail as well?
07:25:45 <rwbarton> no
07:25:49 <rwbarton> er, I assume not?
07:25:53 <rostayob> so... why don't they generate warnings?
07:25:56 <rwbarton> I guess they could, conceivably?
07:25:57 <rostayob> let's try
07:26:08 <merijn> > let Just y = Nothing in y -- like this?
07:26:10 <lambdabot>   *Exception: <interactive>:3:4-19: Irrefutable pattern failed for pattern Da...
07:26:15 <hpaste> erus` pasted “effing types, how do they work?” at http://hpaste.org/64168
07:26:19 <hpc> im confused
07:26:20 <rostayob> > (do { let Just x = Nothing; in x}) :: Maybe Integer
07:26:21 <lambdabot>   *Exception: <interactive>:3:10-25: Irrefutable pattern failed for pattern D...
07:26:24 <t7> does that seem correct?
07:26:29 <rostayob> rwbarton: they don't call fail
07:26:32 <rostayob> well
07:26:39 <rostayob> > (do { let Just x = Nothing; in x}) :: Either String Integer
07:26:40 <lambdabot>   *Exception: <interactive>:3:10-25: Irrefutable pattern failed for pattern D...
07:26:42 <rostayob> yeah
07:26:45 <rwbarton> oh they are lazy
07:26:57 <rostayob> > (do { Just x <- return Nothing; in x}) :: Either String Integer
07:26:58 <lambdabot>   <no location info>: parse error on input `in'
07:26:59 <rwbarton> so it wouldn't make sense
07:27:08 <rostayob> > (do { Just x <- return Nothing; return x}) :: Either String Integer
07:27:09 <lambdabot>   *Exception: Pattern match failure in do expression at <interactive>:3:6-11
07:27:18 <rwbarton> > (do { let Just x = Nothing; x}) :: Either String Integer
07:27:19 <lambdabot>   <no location info>: parse error on input `}'
07:27:27 <rwbarton> > (do { let { Just x = Nothing }; x}) :: Either String Integer
07:27:28 <lambdabot>   *Exception: <interactive>:3:12-27: Irrefutable pattern failed for pattern D...
07:27:33 <rwbarton> anyways same error
07:27:42 <rostayob> i'm confused now.
07:28:01 <rwbarton> do { let Just x = Nothing; in x} is do { (let { Just x = Nothing } in x) }
07:28:06 <rostayob> I'd have guessed that fail = Left for Either
07:28:08 <rwbarton> which isn't a let command
07:28:16 <rostayob> oh right
07:28:19 <rostayob> well but apart from that
07:28:23 <rwbarton> oh I see
07:28:37 <mux> @src Either fail
07:28:38 <lambdabot> fail msg      = Left (strMsg msg)
07:28:41 <rostayob> yeah
07:28:44 <rostayob> so... why?
07:28:57 <rwbarton> :k Error
07:28:58 <lambdabot>     Class `Error' used as a type
07:28:58 <lambdabot>     In the type `Error'
07:29:00 <rwbarton> :k ErrorT
07:29:01 <lambdabot> * -> (* -> *) -> * -> *
07:29:08 <rwbarton> blargh
07:29:14 <mux> :t do { Just x <- return Nothing; in x}
07:29:14 <lambdabot> parse error on input `in'
07:29:27 <rostayob> > do { fail "blah" } :: Either String Int
07:29:28 <mux> :t do { Just x <- Nothing; return x}
07:29:28 <lambdabot>   *Exception: blah
07:29:28 <rwbarton> > runIdentity $ runErrorT $ do { Just x <- return Nothing; return x} :: Either String Int
07:29:29 <lambdabot> forall b. Maybe b
07:29:29 <lambdabot>   Left "Pattern match failure in do expression at <interactive>:3:31-36"
07:29:39 <rostayob> rwbarton: ok, fail is not Left in Either.
07:29:44 <rostayob> why would that be, I don't know.
07:29:56 <rostayob> rwbarton: ok
07:29:58 <rostayob> now, with let
07:30:06 <cmccann> because everything with fail is ridiculous is why
07:30:14 <rwbarton> it's so you can use Either b as a monad when b is not String
07:30:23 <rwbarton> also because what cmccann said
07:30:26 <rostayob> > runIdentity $ runErrorT $ do { {let Just x = return Nothing}; return x} :: Either String Int
07:30:27 <lambdabot>   <no location info>: parse error on input `{'
07:30:34 <rostayob> > runIdentity $ runErrorT $ do {let Just x = return Nothing; return x} :: Either String Int
07:30:34 <lambdabot>   <no location info>: parse error on input `}'
07:30:41 <rostayob> > runIdentity $ runErrorT $ do {let Just x = Nothing; return x} :: Either String Int
07:30:41 <lambdabot>   <no location info>: parse error on input `}'
07:30:44 <rostayob> damn
07:30:48 <rwbarton> > runIdentity $ runErrorT $ do { let {Just x = return Nothing}; return x} :: Either String Int
07:30:49 <lambdabot>   Couldn't match expected type `GHC.Types.Int'
07:30:49 <lambdabot>         against inferred type ...
07:30:56 <rwbarton> > runIdentity $ runErrorT $ do { let {Just x = return Nothing}; x} :: Either String Int
07:30:56 <lambdabot>   Couldn't match expected type `Control.Monad.Trans.Error.ErrorT
07:30:57 <lambdabot>             ...
07:31:02 <rostayob> rwbarton: the 'return'
07:31:04 <rwbarton> > runIdentity $ runErrorT $ do { let {Just x = Nothing}; x} :: Either String Int
07:31:04 <lambdabot>   *Exception: <interactive>:3:36-51: Irrefutable pattern failed for pattern D...
07:31:10 <rostayob> ok, so the let fails
07:31:14 <rostayob> but no warning.
07:31:16 <rostayob> this is wrong.
07:31:27 * cmccann grabs the torches and pitchforks
07:31:38 <mekeor> Is LYAH actually available as PDF, too?
07:31:43 <roconnor> > let x = 0.0001 in x**x :: CReal
07:31:44 <lambdabot>   0.9990793899844617687008298742772464931853
07:31:51 <roconnor> > let x = 0.0000001 in x**x :: CReal
07:31:51 <lambdabot>   0.999998388191733868507193918980177593468
07:31:59 <mekeor> lol
07:32:01 <rostayob> rwbarton: my main point is that the default fail as 'error' introduces a slew of partial functions without the user even noticing
07:32:06 <rwbarton> > 0 ** 0 :: CReal
07:32:10 <lambdabot>   mueval-core: Time limit exceeded
07:32:37 <rostayob> rwbarton: so we should have a MonadFail, and the behaviour of do depending on which typeclass is available, imho
07:32:37 <mekeor> > let x = 0.0001 in x**x :: Double
07:32:38 <rwbarton> I don't think pat <- expr being partial is any more surprising than let pat = expr being partial
07:32:38 <lambdabot>   0.9990793899844618
07:32:43 <mekeor> > let x = 0.0001 in x**x :: Real
07:32:44 <lambdabot>   Class `GHC.Real.Real' used as a type
07:32:55 <mekeor> > let x = 0.0001 in x**x :: CReal
07:32:56 <lambdabot>   0.9990793899844617687008298742772464931853
07:33:03 <mekeor> cool
07:33:09 <rostayob> constructive reals
07:33:37 <mekeor> why is hoogle not able to find creal but hayoo is? that's why i find the latter better…
07:33:55 <rostayob> rwbarton: no wait, what do you mean by "partial"? because 'pat <- expr' is not partial is 'fail' is not
07:34:17 <rostayob> while 'let pat = expr' always is
07:34:49 <cmccann> mekeor, hoogle only searches a limited set of packages
07:34:55 <cmccann> hayoo searches all of hackage I think
07:35:04 <rwbarton> I mean basically that it calls error or something equivalent
07:35:12 * cmccann has "hoogle all the packages" on his todo list for hackage2
07:35:22 <rwbarton> and yeah, pat <- expr is not always partial in that sense
07:35:54 <rostayob> rwbarton: yeah but right now let and <- in do blocks are different, and yet let never generates warnings
07:35:59 <rostayob> which is definitely wrong
07:36:01 <rostayob> if you ask me
07:36:45 <rostayob> is someone going to the hoodlum tomorrow? I'll be there
07:36:53 <rostayob> (the haskell meetup in london)
07:37:28 <rwbarton> let pat = expr in expr also doesn't generate a warning
07:37:51 <rostayob> rwbarton: oh. ok then I was unaware of how GHC treats lets
07:37:54 <rostayob> in terms of warning
07:38:00 <rostayob> *warnings
07:38:20 <rwbarton> I guess it sort of makes sense because it's not like you can actually fix the warning without switching to a completely different syntax
07:38:25 <rostayob> rwbarton: true
07:38:37 <rostayob> I guess it's an acceptable compromise..
07:38:56 <rostayob> btw, tomorrow in London there are also interesting talks at my uni: http://www3.imperial.ac.uk/newsandeventspggrp/imperialcollege/engineering/computing/eventssummary/event_15-2-2012-10-50-45
07:40:07 <mekeor> cmccann: yep, so hayoo is better :)
07:40:25 <hpaste> “C. McCann” pasted “guess which of these generate a warning” at http://hpaste.org/64170
07:40:27 <rwbarton> @hayoo CReal
07:40:27 <lambdabot> Unknown command, try @list
07:40:50 <rostayob> cmccann: 4 and 5
07:40:58 <rostayob> cmccann: what did I win?
07:41:01 <rwbarton> my guess is just 5
07:41:04 <t7> > id Maybe
07:41:05 <lambdabot>   Not in scope: data constructor `Maybe'
07:41:13 <cmccann> and rwbarton wins :T
07:41:18 <rwbarton> well I did just test most of these :P
07:41:21 <t7> type level id :3
07:41:24 <rostayob> cmccann: noooo
07:41:38 <rostayob> well. I learnt something today.
07:41:58 <rwbarton> you could add bad6 x = case x of Just y -> y
07:42:03 <rostayob> it's one of those things you don't find out in practice because you don't notice the absence of warnings
07:42:08 <rwbarton> yes
07:42:19 <cmccann> rwbarton, yeah, probably should have
07:42:27 <rostayob> well case does generate a warning
07:42:29 <rostayob> ...right?
07:42:34 <rwbarton> I would guess so
07:42:36 * cmccann expects it would
07:42:40 <t7> guiz it works now :D
07:42:48 <rwbarton> basically I think the rule here is if you could add another case to fix the warning, then it will generate a warning
07:42:53 <t7> i just wasnt recursing enough
07:43:03 <cmccann> yeah, case gives a warning
07:43:20 <inetic> Hi, I'm trying to create a simple program that would listen on an UDP socket in a never ending loop and at the same time I would like to plot these data using Gtk2HS and Cairo. Since these two loops are blocking I'm guessing I should be looking at concurrency or parallelism, but not sure shich one of the two (I understand these are two different things in haskell).
07:43:52 <mux> these are two different things regardless of the language you're using
07:44:01 <mux> in your case you actually want concurrency
07:44:13 <rwbarton> rostayob: also writing pattern bindings as in bad1 through bad4 is fairly rare in the first place
07:44:45 <rostayob> rwbarton: yeah, and most of the times when you do that you want the unsafe pattern binding, now that i'm thinking about it.
07:44:51 <rostayob> the perils of partial languages.
07:44:59 <cmccann> I never want the unsafe pattern binding :P
07:45:19 <rostayob> cmccann: except that special time
07:45:22 <rwbarton> you mean you've never written    main = do [infile, outfile] <- getArgs; ...
07:45:23 <cmccann> if I use that form, it's either to get "fail" for [], or because the pattern is comprehensive, like (x, y)
07:45:27 <rostayob> rwbarton: exactly
07:46:00 <rostayob> you should do better error handling but when you're writing something quickly
07:46:01 <cmccann> rwbarton, eh, probably a few times for one-off hacks, but even there I try to avoid it
07:46:01 <rwbarton> Just (Right (OK x)) <- parseFile blah -- why is this parsing library so awkward :/
07:46:08 <rwbarton> etc.
07:46:22 <rostayob> cmccann: yaeh but it's quite handy in the one-off hack case.
07:46:38 <rostayob> haskell is partial anyways, things go wrong
07:46:42 <rostayob> HM IS A LIE
07:46:50 <rwbarton> yep
07:47:08 <cmccann> @quote kmc prove
07:47:08 <lambdabot> kmc says: "Haskell is great, because Curry-Howard!  Proving things in the type system.  We can prove that, uh, Ints exist, unless they're ⊥."
07:47:32 <rostayob> :t fix
07:47:33 <lambdabot> forall a. (a -> a) -> a
07:47:40 <inetic> mux: thanks, I did some homework and tried to run command "dialogRun dialog" from Gtk2HS (which is the blocking loop) and also ran forkIO which was supposed to continuously print some text, it seems that the dialogRun command blocked the forkIO and it stopped printing the text very soon
07:47:52 <roconnor> > fix error
07:47:52 <lambdabot>   "*Exception: *Exception: *Exception: *Exception: *Exception: *Exception: *E...
07:47:53 <dcoutts> inetic: your problem is a good example where you want concurrency but you do not care about parallelism
07:48:01 <rostayob> roconnor: :D
07:48:04 <cmccann> roconnor, ah, the canonical use case for "fix"
07:48:21 <dcoutts> inetic: and you need a trick to get gtk to play nicely with concurrency, see the gtk2hs website
07:48:22 <mux> inetic: there are some specific restrictions with respect to threads and gtk2hs, in case you don't know
07:48:29 <rostayob> my friend always writes 'foo = foo' instead of 'foo = undefined'. much classier.
07:48:40 <rostayob> diverging functions should diverge properly.
07:48:53 <mux> but GHC tends to spot those
07:48:54 <cmccann> rostayob, I prefer using error with a silly message
07:49:04 <mux> and error with a <<loop>> thing
07:49:07 <inetic> mux, dcoutts: thanks, didn't know about the restrictions :-/
07:49:17 <rostayob> mux: not really
07:49:22 <rostayob> > let foo = foo in foo
07:49:26 <lambdabot>   mueval-core: Time limit exceeded
07:49:40 <rostayob> <<loop>> is different
07:49:40 <dcoutts> inetic: sounds like you're doing basically the right thing. Once you use the trick then the threads work fairly well, I've used it several times.
07:50:40 <rwbarton> foo = head [ (x, y, z, n) | z <- [1..], x <- [1..z], y <- [1..x], n <- [3..y], x^n + y^n == z^n ]
07:50:42 <rsimoes> Is it possible to use haskell ffi libraries without ghc?
07:50:47 <mux> rostayob: yes, really: compile main = main and see. (note: I never said it _always_ happens)
07:51:09 <parcs`> yeah, lambdabot is an interpreter not a compiler
07:51:39 <cmccann> rostayob, mux, note that behavior differs depending on optimization flags and whatnot
07:51:50 <Saizan> and -threaded
07:51:58 <rostayob> mux: it compiles just fine for me
07:52:00 <rostayob> main = main
07:52:05 <rwbarton> try with -O2
07:52:08 <rostayob> oh right
07:52:18 <Saizan> the <<loop>> is at runtime
07:52:20 <rostayob> wait
07:52:20 <rwbarton> also mux means at run time, not compile time
07:52:22 <rostayob> exactly
07:52:24 <rostayob> that's what I meant
07:52:27 <rwbarton> ah
07:52:44 <Saizan> still, try with -O2
07:52:50 <rostayob> Saizan: compiles fine...
07:52:51 <mux> yes, try with -O2
07:52:56 <mux> I never said it doesn't compile
07:53:01 <mux> <<loop>> is a runtime thing
07:53:19 <rwbarton> though for bonus points, see if you can get an invocation of ghc to produce <<loop>>
07:53:24 <rostayob> mux: ok. when I said 'foo = foo' instead of 'foo = undefined' I meant just to make the types work out while writing the definitions
07:56:06 <rostayob> rwbarton: can you even do that? The best I can do is an infinite loop with UndecidableInstances
07:56:28 <rostayob> when would a <<loop>> happen at compile time?
07:56:38 <rwbarton> I imagine it's probably impossible
07:57:52 <rostayob> register machines at the type level: https://github.com/exFalso/TypeRegister/blob/master/register.hs
07:58:09 <rostayob> for easier type-level loops!
08:00:28 <cmccann> rostayob, you can also make GHC consume memory until it grinds your system to a halt pretty easily
08:00:41 <rostayob> cmccann: yeah I'm sure
08:00:49 <rostayob> being careful not to exceed the recursion stack
08:01:01 <rostayob> the recursion depth limit
08:01:18 <cmccann> no, I mean without type-level loops
08:01:21 <cmccann> without undecidable instances
08:01:25 <rostayob> cmccann: ah, how?
08:01:28 <rwbarton> does ghc still choke on large list literals?
08:01:33 <cmccann> in plain Haskell 98 in fact
08:01:45 <rwbarton> oh yeah
08:01:50 <cmccann> rostayob, H-M type inference has very, very bad worst-case behavior
08:01:58 <rostayob> cmccann: oh, nested lets?
08:02:08 <rostayob> I remember reading about an exponential case in TaPL
08:02:54 <rostayob> but right now it escapes me
08:02:57 <cmccann> :t let f a b c d e f = f e d c b a in f
08:02:57 <lambdabot> forall t t1 t2 t3 t4 t5. t -> t1 -> t2 -> t3 -> t4 -> (t4 -> t3 -> t2 -> t1 -> t -> t5) -> t5
08:03:01 <cmccann> :t let f a b c d e f = f e d c b a in (f f)
08:03:02 <lambdabot> forall t t1 t2 t3 t4 t5 t6 t7 t8 t9 t10. t6 -> t7 -> t8 -> t9 -> (t9 -> t8 -> t7 -> t6 -> (t -> t1 -> t2 -> t3 -> t4 -> (t4 -> t3 -> t2 -> t1 -> t -> t5) -> t5) -> t10) -> t10
08:03:15 <rwbarton> there was a neat example posted to reddit a while ago where you could see that there was sharing at one stage in the compiler but it got destroyed at a later stage
08:03:43 <cmccann> :t let f a b c d e f = f e d c b a in (f . f)
08:03:44 <lambdabot> forall t t1 t2 t3 t4 t5 t6 t7 t8 t9 t10. t5 -> t -> t1 -> t2 -> t3 -> (t3 -> t2 -> t1 -> t -> (t6 -> t7 -> t8 -> t9 -> (t9 -> t8 -> t7 -> t6 -> t5 -> t10) -> t10) -> t4) -> t4
08:04:03 <t7> oi lambdabot, stop saying my name
08:04:11 <cmccann> doing stuff like that can easily lead to a huge blow up in distinct type variables
08:04:37 <rostayob> cmccann: I've got to run now, I'll think about this :P
08:04:52 <rostayob> because right now it's not clear to me why it's that bad
08:04:59 <rostayob> later
08:05:22 <parcs`> rwbarton: i just compiled gutenberg-fibonaccis pretty quickly on 7.4.1 and i remember it being at least 10x slower on 7.2 so the answer is probably no
08:05:41 <cmccann> t7, it's your fault for having a name that looks like a GHC-generated type variable :P
08:06:53 <t7> well it was the first 2 character name i found
08:07:00 <t7> and i searched for well over 5 mins
08:08:15 <cmccann> haha
08:13:51 <mekeor> :D lol
08:20:29 <inetic> mux, dcoutts: the trick with the Control.Concurrent forkIO beeing blocked by Gtk.dialogRun seemed to be in the -threaded flag, though I haven't seen it mentioned in the gtk2hs page. Is there a way I can tell ghc to use this flag somewhere at the beginning of my main.hs file?
08:21:22 <mux> maybe {-# GHC_OPTIONS -threaded #-}
08:21:29 <mux> check the syntax though, that's off the top of my head
08:21:46 <inetic> mux, cheers, gonna check
08:34:41 <inetic> mux: it's OPTIONS_GHC, but unfortuntely that pragma seems to only be applicable for so called 'dynamic' flags, -threaded belongs to category of 'static' flags, ah well... :)
08:35:01 <mux> inetic: ah, sorry then :)
08:35:01 <inetic> but thanks anyway
08:43:06 <crockeea> I just upgraded to GHC-4.7.1, and I'm having trouble using (the old?) Data.Complex module
08:43:11 <MaybeJust> how would haskell be for writing 3D-games?
08:43:24 <mysticc> crockeea: :P 4.7
08:43:37 <cmccann> wow, 4.7 :D
08:43:38 <crockeea> ghc says it is in haskell98-2.0.0.1 which is hidden
08:43:42 <crockeea> and I can't unhide it
08:43:48 <MaybeJust> lol crockea 4.7?
08:43:53 <crockeea> 7.4
08:44:00 <mysticc> crockeea: where did you find one
08:44:02 <mysticc> oh
08:44:09 <Jafet> MaybeJust: terrible
08:44:17 <cmccann> MaybeJust, well, how comfortable are you with OpenGL? :P
08:44:51 <mysticc> @hoogle Data.Complex
08:44:52 <lambdabot> Data.Complex data RealFloat a => Complex a
08:44:52 <lambdabot> Data.Complex module Data.Complex
08:44:52 <lambdabot> package complex-integrate
08:44:53 <crockeea> if i try to unhide with ghc-pkg, i get permission denied. With root I get "package not found". Any ideas?
08:47:12 <teneen> The Paterson conditions specify that any variable in an assertion should have fewer occurrences than in the head, and the assertion should have fewer constructors and variables than the head
08:47:13 <MaybeJust> jafet: why?
08:47:25 <MaybeJust> no manual mem management?
08:47:36 <teneen> however class D a => C a is valid, why?
08:47:54 <teneen> class D a a a => C a b c is also valid, why?
08:47:59 <teneen> in GHC 7.4.1
08:49:20 <mysticc> crockeea: I think you have not properly updated .. Data.Complex belongs to base ..
08:49:47 <crockeea> I figured it did. I have hase-4.5 exposed
08:49:56 <tejaswidp> I am new to funcional programming and haskell. Which interpreter woudl be apt in my case?
08:49:58 <crockeea> base-4.5
08:50:35 <mysticc> tejaswidp: what does your newness has to do with interpreter .. use ghc and ghci
08:50:47 <tejaswidp> what about hugs?
08:51:42 <mysticc> tejaswidp: I would recommend try both and choose ... but I dont think it will be much difference .. ghc is always better ...
08:51:49 <rwbarton> teneen: The Paterson conditions apply to instances, not class declarations.
08:51:59 <tejaswidp> thank you mysticc
08:52:51 <MaybeJust> Why would Haskell be terrible for 3D-games?
08:53:20 <mysticc> crockeea: which os do u use .. you built ghc from source or something else ?
08:53:27 <MaybeJust> is it a func prog lang problem or just haskell? would F# be good?
08:53:37 <crockeea> using Debian, built from source
08:53:40 <lispy> mysticc: it's not. Frag is a simplistic clone of Q3 in Haskell
08:53:41 <matthiasgorgens> @pl let f x = g x . h
08:53:41 <lambdabot> (line 1, column 18):
08:53:41 <lambdabot> unexpected end of input
08:53:41 <lambdabot> expecting letter or digit, variable, "(", ".", "`", "!!", operator, ";" or "in"
08:53:44 <lispy> oops
08:53:48 <teneen> rwbarton: wow, that makes it clear...thanks a lot!
08:53:48 <matthiasgorgens> @pl f x = g x . h
08:53:49 <lambdabot> f = (. h) . g
08:53:52 <mysticc> lispy: ??
08:53:56 <lispy> MaybeJust: it's not. Frag is a simplistic clone of Q3 in Haskell
08:54:02 <lispy> mysticc: sorry, mt
08:54:23 <rwbarton> Frag is also from approximately forever ago, right?
08:54:38 <rwbarton> So hopefully the state of affairs has improved since then
08:54:42 <lispy> It's been around for some time, 2005-2006, IIRC
08:55:14 <rwbarton> yep it's from november 2005
08:55:15 <lispy> Frag isn't amazing internally, but that has more to do with a student hacking it out as an honors thesis
08:55:31 <mm_freak_> there is one good thing about frag
08:55:34 <mm_freak_> it uses FRP
08:55:35 <lispy> And it should use the arrows syntax but it tries to avoid that extensison
08:55:45 <cmccann> I think the state of affairs for a while was that nobody was really working on most of the relevant FFI bindings, and there were lots of half-baked FRP frameworks and no basic game dev libraries
08:55:50 <lispy> So the FRP code is terrible to read
08:55:51 <crockeea> mysticc: New to this, so I followed the directions at http://blog.jasonknight.us/2012/02/how-to-install-ghc-741-in-ubuntu-from.html
08:56:01 <lispy> But that's not a problem with haskell, it's a problem with the choices the student made
08:56:37 <cmccann> these days there seem to be more mature and usable FRP libraries and more attention being paid to stuff like the OpenGL bindings
08:56:42 <Abraxas> can someone tell me if (5) takes any outside information or should be derivable as such? http://bit.ly/Agsk8s
08:56:45 <lispy> It also doesn't work well on some computers because it doesn't used a fixed time step. On my mac that means that the distance the mouse moves between time steps is always 0
08:56:49 <Abraxas> parametricity
08:56:55 <lispy> On windows the time step is closer to fixed and so it plays fine
08:57:09 <mm_freak_> well, i moved to applicative FRP, which is easy to read without requiring any extensions
08:57:26 <lispy> mm_freak_: is it possible to fix your time step?
08:57:38 <mm_freak_> lispy: my time step is dynamic based on a real clock
08:57:38 <lispy> mm_freak_: For the sake of numerical reproducibility and all that?
08:57:40 <miggyx_> Hi guys, what's the best way to find good haskell contractors?
08:57:58 <lispy> mm_freak_: That's one of my complaints with continuous time FRP
08:58:05 <lispy> miggyx_: haskellers.com?
08:58:11 <mm_freak_> lispy: why?  what's wrong with it?
08:58:43 * cmccann would expect continuous time FRP to at least be numerically stable for any sort of time step
08:58:49 <miggyx_> lispy: sweet thanks
08:58:50 <lispy> mm_freak_: If your simulation depends on numerical accuracy you really want the dt used by your sim to be constant so you can have consistent error bounds on your computations
08:59:07 <Abraxas> argh, (6) is broken
08:59:16 <mm_freak_> lispy: you can have that if you want, but for a game you don't want to
08:59:25 <miggyx_> lispy: just looking for someone to port a <100 line C prog :)
08:59:28 <lispy> mm_freak_: http://gafferongames.com/game-physics/fix-your-timestep/  <-- example of what I'm talking about
08:59:44 <mm_freak_> my library is designed such that you can choose the clock you work with
08:59:45 <mysticc> miggyx_: why haskell ??
08:59:57 <lispy> mm_freak_: it still applies to games, just less formally
09:00:32 <cmccann> miggyx_, for something that short you might be able to get people to help you port it without any contracting
09:00:40 <miggyx_> mysticc: the program calculates finite difference. It's difficult to figure out what the C code does - I'm thinking it will be a lot clearer in Haskell. Also I'm hoping it might be more easy to paralleize
09:00:49 <Abraxas> fixed: http://bit.ly/AvayA3
09:01:14 <cmccann> miggyx_, it sounds like an awfully small project to justify the hassle of arranging payment and all that to be honest, unless it's a very complicated 100 lines
09:01:54 <miggyx_> It's probably very simple. The C code is here:  http://pastebin.com/iL68ZHRv
09:01:57 <mauke> The paste iL68ZHRv has been copied to http://hpaste.org/64173
09:02:15 <miggyx_> Just that my Haskell is nowhere near good enough to make a good stab at it, and really I need something idiomatic :)
09:02:23 <mysticc> miggyx_: I agree with cmccann .. you can try yourself and get help here ..
09:02:26 <miggyx_> perhaps if not a contract beer tokens would be an option :)
09:02:57 <Abraxas> i guess (5) is using this: g p (map h l) = map h (g (p o h) l)
09:03:15 <Abraxas> o = \circ
09:04:01 <cmccann> miggyx_, yes, a naive and largely idiomatic translation of that would be pretty simple, I think
09:04:33 <Abraxas> and (6) is prob. using this? g (map f l) = map f (g l)
09:04:51 <rwbarton> hmm, I was going to suggest using repa, but these arrays are... 4 x 7?
09:05:05 <mm_freak_> lispy: i understand
09:05:08 <rwbarton> heck you could calculate this by hand :)
09:05:47 <MaybeJust> miggyx: wheres the code?
09:06:02 <miggyx_> MaybeJust: http://pastebin.com/iL68ZHRv
09:06:02 <mauke> The paste iL68ZHRv has been copied to http://hpaste.org/64173
09:06:26 <cmccann> huh, mauke's script knows not to copy duplicates, nice
09:07:21 <mysticc> do you guys have use any shell script to paste direcly to hpaste .. I always loved hpaste but dont want paste manually ..
09:07:25 <permaflex68> ciao
09:07:32 <permaflex68> !list
09:08:18 <cmccann> mysticc, http://hackage.haskell.org/package/PastePipe ?
09:08:37 <mauke> mysticc: I use http://mauke.hopto.org/stuff/perl/pastebin
09:09:42 <mysticc> mauke: perl .. have you written it ..
09:09:59 <Rc43> Hi, guys.
09:10:22 <mysticc> cmccann: pastepipe fails to install ..
09:10:41 <Rc43> What can be meaned by `ground types`?
09:10:55 <rwbarton> sounds delicious
09:10:57 <rwbarton> context?
09:11:00 <miggyx_> I don't suppose anyone is interested in ported that code? :)
09:11:32 <ziman> maybe those not containing variables? (like ground terms from logic programming)
09:11:45 <cmccann> miggyx_, I can do a very simple translation for you in a bit if nobody else does
09:11:59 <rwbarton> ziman, that would be my guess also
09:12:08 * hackagebot happstack-hsp 6.2.9 - Support for using HSP templates in Happstack  http://hackage.haskell.org/package/happstack-hsp-6.2.9 (JeremyShaw)
09:12:30 <miggyx_> cmccann: that would be awesome if you could, thanks!
09:14:00 <miggyx_> brb
09:18:44 <Rc43> rwbarton, don't remember, http://okmij.org/ftp/Haskell/types.html - what I have found from google (didn't read yet).
09:18:56 <Rc43> rwbarton, I will be afk some minutes
09:31:49 <parcs`> > 1 / 62
09:31:50 <lambdabot>   1.6129032258064516e-2
09:32:53 <miggyx_> back
09:34:32 <rostayob> > showCReal 1000 (1 / 62)
09:34:32 <lambdabot>   "0.016129032258064516129032258064516129032258064516129032258064516129032258...
09:34:59 <rostayob> > drop 1000 $ showCReal 1200 (1 / 62)
09:35:00 <lambdabot>   "22580645161290322580645161290322580645161290322580645161290322580645161290...
09:35:13 <rostayob> > showCReal 5000 (1 / 62) !! 5000
09:35:14 <lambdabot>   '1'
09:35:35 <rostayob> > last $ showCReal 10000 (1 / 62)
09:35:36 <lambdabot>   '3'
09:35:40 <rostayob> > last $ showCReal 100000 (1 / 62)
09:35:41 <lambdabot>   '3'
09:35:44 <rostayob> > last $ showCReal 1000000 (1 / 62)
09:35:48 <lambdabot>   mueval-core: Time limit exceeded
09:35:51 <rostayob> oh.
09:36:21 <benmachine> so guys I made a thing http://bm380.user.srcf.net/prettyparsetree.cgi?exp=x+`mod`+7+%2B+3
09:36:29 <benmachine> it's super crude
09:36:42 <benmachine> and the most difficult case it gets wrong because of a bug in HSE
09:36:53 <benmachine> but I wondered if anyone thought it was a good idea anyway
09:37:03 <monochrom> eh? it just adds parentheses
09:37:28 <benmachine> monochrom: yes
09:37:40 <benmachine> the idea is to show you how fixities are being applied
09:37:46 <rostayob> benmachine: so that's basically
09:37:53 <rostayob> prettyPrint . parse
09:37:58 <rostayob> from haskell-src-exts
09:38:03 <benmachine> rostayob: prettyPrint . putParenthesesEverywhere . parse
09:38:07 <rostayob> ok.
09:38:12 <rostayob> benmachine: good job!
09:38:14 <benmachine> :P
09:38:28 <benmachine> my original plan was to put divs everywhere instead
09:38:33 <benmachine> and colour them or something
09:38:37 <benmachine> I thought that might be prettier
09:38:38 <monochrom> (\x -> prettyPrint . x . parse) is the conjugation group action!
09:38:51 <benmachine> monochrom: I... suppose so
09:39:04 <benmachine> except that prettyPrint and parse aren't perfect inverses
09:39:19 <benmachine> anyway
09:39:28 <benmachine> the basic idea is, have a thing which shows how expressions are grouped
09:39:35 <benmachine> because this is a mistake people make sometimes
09:39:48 <rostayob> benmachine: that's why you have a compiler
09:39:49 <monochrom> then you should call it "Haskell operator precedence visualizer"
09:39:58 <rostayob> :)
09:40:00 <rostayob> jokes aside
09:40:01 <benmachine> monochrom: okay, I'll do that in a sec
09:40:19 <benmachine> rostayob: yeah, I'm now thinking that the use case is a bit small after all
09:40:31 <benmachine> you have to have something that parses, but not in the way you meant it
09:40:59 <rwbarton> it could definitely be useful as a lambdabot plugin
09:41:18 <rostayob> true that
09:41:28 <benmachine> mm, that would be a pretty good way to do it
09:41:29 <rostayob> what would be useful is something that
09:41:49 <rostayob> given an unparsable expression
09:41:50 <monochrom> do you know why f (g x) becomes (f (((g x)))) ?
09:41:52 <rostayob> or even untypable
09:42:05 <rostayob> tries to correct it by putting parenthesis
09:42:06 <benmachine> monochrom: I'm actually investigating that at the moment
09:42:19 <benmachine> rostayob: yeah that would be nice, requires way more intelligence though :P
09:42:25 <rwbarton> whoa
09:42:28 <benmachine> or exponential running time, either
09:42:28 <rostayob> benmachine: yeah thinking sucks
09:42:28 <rwbarton> it lays out things too
09:42:33 <nyingen> we can call the bot command @lispify
09:42:38 <benmachine> nyingen: :D
09:42:40 <monochrom> hahaha
09:42:58 <rostayob> rwbarton: yeah haskell-src-exts pretty printing is not bad
09:43:06 <rostayob> see http://hackage.haskell.org/package/groom
09:43:11 <benmachine> unfortunately the kind of motivating case for this tool
09:43:12 <monochrom> s/intelligence/brute-force search/
09:43:14 <miggyx_> cmccann: I don't think anyone else is interested in porting that code…. :)
09:43:21 <benmachine> which is how everyone gets -x `mod` m wrong
09:43:29 <benmachine> haskell-src-exts gets that wrong too >_<
09:44:34 <cmccann> in general, haskell-src-exts gets fixity wrong
09:44:41 <benmachine> cmccann: it makes a decent effort
09:44:46 <benmachine> it doesn't get it as wrong as it used to
09:44:58 <cmccann> in that it has no clue about fixities unless you tell it what to use, as far as I know
09:45:06 <lpsmith> does anybody remember what the fastest state monad for an integer looked like;  I think matt morrow and some other people were playing around with a super-fast adaptive integer-state monad years ago.
09:45:09 <benmachine> cmccann: it has prelude fixities built in
09:45:13 <benmachine> or you can supply a different list
09:45:14 <cmccann> yeah
09:45:27 <benmachine> cmccann: ghc has no clue about fixities unless you tell it what to use :P
09:45:39 <cmccann> yes, but GHC goes looking
09:45:46 <benmachine> I see what you mean
09:45:51 <cmccann> haskell-src-exts doesn't chase dependencies, obviously
09:45:57 <benmachine> no
09:46:00 <benmachine> but it does do the best it can
09:46:06 <cmccann> it does
09:46:29 <cmccann> and the best it can do is "get fixity wrong" in the general case :P
09:46:46 <benmachine> yes but the general case isn't the common case
09:47:33 <cmccann> I dunno, custom infix operators are common enough that it gave me frequent headaches having to supply them
09:48:06 <benmachine> mm
09:48:12 <benmachine> fair enough
09:49:12 <cmccann> they're just common enough to be a hassle, but not common enough that haskell-src-exts would be forced to do something more clever to be usable at all
09:49:23 * cmccann shrugs
09:49:43 <lispy> testing unicode λ
09:49:49 <lispy> Is that a lambda?
09:49:51 <benmachine> yes
09:49:53 <rwbarton> > let a + b = 5; infixl + 5 in 4 + 5
09:49:54 <lambdabot>   <no location info>: parse error on input `5'
09:49:57 <lispy> Cool
09:49:59 <lispy> brb
09:50:07 <rwbarton> > let a + b = 5; infixl 5 + in 4 + 5
09:50:08 <lambdabot>   5
09:51:11 <cmccann> rwbarton, parsing haskell is lots of fun, isn't it :P
09:52:36 <lispy> It's nice to finally have unicode working in irssi.
09:52:46 <lispy> No idea why I didn't fix that sooner
09:53:13 <benmachine> cmccann: haskell-src-exts actually does try to get that right
09:53:16 <benmachine> except it does it wrong :P
09:53:19 <cmccann> haha
09:53:22 * benmachine has a bug on the tracker about it
09:53:36 * cmccann doesn't envy whoever maintains haskell-src-exts :P
09:53:58 <benmachine> I kind of think the whole thing ought to be replaced by something cleverer
09:54:13 <benmachine> that can do things like partial input or error correcting or something
09:54:25 <benmachine> but that's a big project so it's low on my list
09:54:27 <gatlin> I was googling a bit to no avail; what support does Haskell have for linear types? As in, I could write my code so that it has linear types at runtime, but does the compiler know how to exploit it?
09:54:39 <benmachine> a CGI parenthising machine is an hour's work, so it's high :P
09:54:53 <cmccann> gatlin, none as such
09:55:51 <cmccann> gatlin, you can encode things like that a bit indirectly in various ways, and then use some compiler pragmas and other tricks to get benefit from it
09:56:46 <gatlin> oh? I'm still new to Haskell so I'm unfamiliar with the pragmas
10:02:26 <cmccann> gatlin, you might want to look at how the stream fusion stuff in e.g. Data.Vetor works
10:03:49 <cmccann> gatlin, but I suspect that what you want is rather more complicated so I'd suggest thinking carefully about what you want to accomplish and then figuring out how to get there
10:05:08 <cmccann> for instance, it might be simpler to use an EDSL of sorts that produces intermediate data structures that you can then optimize yourself rather than trying to coax the compiler into doing it for you
10:05:59 <gatlin> What I'm interested in is, if I must use a resource once and only once then when dealing with large data structures I get guarantees about resource usage and dependencies, but under the covers a clever compiler will reuse (and mutate) the same memory
10:06:19 <cmccann> right, but GHC doesn't have that kind of cleverness at all as far as I know
10:06:27 <gatlin> and that's all I was asking about :)
10:06:32 <cmccann> ok.
10:06:43 <gatlin> but, good to know! Maybe it's something I can look into to learn more about Haskell
10:07:34 <byorgey> gatlin: Clean can do that, and maybe DDC as well
10:07:37 <benmachine> gatlin: you don't get guarantees but if you build and consume datastructures nicely then it ought to be possible that the whole thing never exists all at once
10:07:38 <cmccann> gatlin, there's really no concept of linearity in Haskell's type system so you're at a starting disadvantage there
10:08:16 <benmachine> gatlin: what do you mean by dependencies? (I don't personally know much about linear types)
10:08:31 <cmccann> you can encode some stuff using runST-flavored trickery, or you can build linear-typed expressions using a more restrictive version of Arrow
10:09:08 <cmccann> how closely do linear types relate to linear logic, anyway?
10:09:11 <cmccann> I'm only familiar with the latter
10:10:05 <gatlin> benmachine, since referencing a resource is also using it, basically you can create a reference to some data and then even something like copying it uses it up; you must do something with the resource whilst copying it, perhaps creating a new resource in the process
10:10:11 <cmccann> and obviously you could have a type system that relates to linear logic the way Haskell's type system is intuitionistic logic-ish
10:10:16 <gatlin> cmccann, the latter informs the former
10:10:29 <cmccann> yeah, I'm just not sure how far they differ
10:10:35 <gatlin> but the former is much narrower
10:10:46 <cmccann> like, which connectives have equivalents
10:10:56 <cmccann> and whether the modal operators and identity values are meaningful
10:11:04 <gatlin> right. and since I'm coming at this from a practical not logical perspective, I'm in over my head there
10:11:11 <gatlin> I need to brush up on modal logic
10:11:20 <cmccann> well, modal logic is something else
10:11:34 <cmccann> but the "exponentials" in linear logic have some relation to it
10:11:54 <cmccann> I try not to call them that in this context because "exponential" can also mean function types
10:11:58 <Ngevd> &:.~#@_>1# .#<
10:12:03 <Ngevd> Woops, wrong channel
10:12:21 <dmwit> ! is a bit like a mode in linear logic
10:12:55 <mkscrg> If I have a value in a where clause, does it get re-evaluated every time the parent function is called? or is it saved from one call to the next?
10:12:59 <cmccann> dmwit, either ! or ? follows rules that fit with a particular flavor of modal logic I think
10:13:09 <cmccann> and the other is just the obvious dual, in linear logic style
10:13:24 <benmachine> gatlin: the notion of using system resources in a reliable but still composable way is, I think, sort of what iteratees were originally about; there have been various attempts to solve the problem and I think there's no real consensus as to how to do it best
10:13:27 <gatlin> my motivation for even asking about all this is that I'm interested in linear logic and linear type systems, and the only language I know of that uses it extensively is ATS … and so I was looking to see if a language I have grasp on already supports it
10:13:47 <gatlin> benmachine: I'll look into iteratees, thanks for the tip
10:13:51 <gatlin> so much to read about
10:13:54 <cmccann> benmachine, I think that's an entirely different issue than linear types to be honest
10:14:03 <benmachine> I think cmccann might be right, actually
10:14:11 <dmwit> mkscrg: Implementation-dependent, but GHC will not re-evaluate it.
10:14:15 <cmccann> though I have a stream processing library that I really need to finish tidying up that is very influenced by linear logic
10:14:17 <benmachine> iteratees will not give you insight into linear types
10:14:22 <gatlin> ah, okay
10:14:27 <benmachine> but in my mind they sort of solve the same problem
10:14:30 <cmccann> and sort of generalizes iteratees in a very abstract way
10:14:35 <dmwit> mkscrg: Be careful, though: if it's a function, "re-evaluate" means "compute until it becomes a lambda", not "memoize output results".
10:14:48 <dmwit> mkscrg: Oh, hang on.
10:14:51 <dmwit> mkscrg: I misread your question.
10:15:07 <dmwit> mkscrg: Each time the function with the where block is called, the things in the where block will be re-evaluated by GHC.
10:15:14 <rwbarton> (probably)
10:15:17 <dmwit> (The "implementation-dependent" clause still applies, though.)
10:15:19 <benmachine> gatlin: I was only mentioning them as reference to how haskell handles resources like file IO responsibly
10:15:33 <mkscrg> dmwit: good to know. thanks
10:15:42 <dmwit> mkscrg: If there are bits that can be precomputed, you have to make that explicit; e.g. define it like this:
10:15:47 <gatlin> benmachine: gotcha. Even still, thanks for mentioning them, I'm interested in learning as much as I can
10:15:48 <rwbarton> with optimizations GHC might lift the value outside of the function
10:15:58 <rwbarton> which may or may not really be an optimization
10:15:59 <dmwit> mkscrg: foo = let cache = <expensive> in \x y -> <thing using arguments x, y, and the cache>
10:16:05 <benmachine> I never really "got" iteratees
10:16:15 <benmachine> and then I left haskell for a bit and came back and everyone was all "pipes! conduits!"
10:16:26 <cmccann> benmachine, I've been trying to nail down a stream processing semantics for linear logic that I like
10:16:31 <geekosaur> they exist because nobody really got iteratees :p
10:16:38 <benmachine> :P
10:16:54 <cmccann> but I don't think iteratees as such would have a simple encoding in my system
10:16:54 <benmachine> I think I might just sit the whole fight out and write boring old monadic IO in the meantime
10:16:57 <cmccann> pipes do, though
10:16:59 <geekosaur> well, no, they exist because someone fond a significant resource issue with iteratees, but wanted to keep the basic ideas.  they did simplify some things along the way
10:16:59 <mkscrg> dmwit: or just lift the cached value into a top level definition, right?
10:17:15 <benmachine> geekosaur: what significant resource issue do you mean?
10:17:27 <dmwit> mkscrg: sure
10:17:35 <dmwit> mkscrg: That can't always be done.
10:17:43 <dmwit> mkscrg: For example, you can also write something like this:
10:17:58 <dmwit> mkscrg: foo x = let cache = <expensive, but dependent on x> in \y -> <thing using cache and y>
10:18:11 <geekosaur> hrm, I'd have to dig up the mailing list message about it to remind myself, but there's a case where an exception will be "lost" and you can't free any resources related to the source of the exception (that is, close a file)
10:18:33 <geekosaur> basically, iteratees can;t be made exception-safe in all cases
10:18:34 <dmwit> mkscrg: Then something like "map (foo x) ys" will share the cache across all the calls in the map (again, in GHC).
10:18:56 <benmachine> geekosaur: huh, interesting
10:19:05 <benmachine> I have this idea that people still like iteratees
10:19:11 <benmachine> do some people argue that your problem isn't a problem?
10:19:51 <geekosaur> not that I've seen
10:20:10 <geekosaur> with concrete examples of why it isn't reliable, that kinda shut down the argument
10:20:11 <mkscrg> dmwit: ah, that's awesome. i'd never thought of doing caching across multiple calls that way
10:20:25 <benmachine> geekosaur: I'll keep that in mind
10:20:35 <geekosaur> which is why there are conduits and pipes and other things going on as people look for better ways to do the same kind of thing
10:21:43 <shergill> i know about conduits, but not about pipes. do pipes have any advantage they offer over conduits?
10:21:44 <benmachine> I saw john lato arguing with someone about how pipes weren't
10:21:45 <benmachine> something
10:21:55 <DanBurton> pipes are super simple
10:22:31 <DanBurton> @hackage pipes
10:22:31 <lambdabot> http://hackage.haskell.org/package/pipes
10:22:53 <DanBurton> if you look at the docs for Control.Pipe, it gives a nice tutorial
10:23:04 <shergill> thanks DanBurton
10:25:07 <benmachine> https://plus.google.com/u/0/115372308262579808851/posts/8XM1RYQPP3C
10:25:35 <benmachine> "A Pipe may hold an open Handle until it's garbage collected, which may be much later than you would expect (or desire). I don't think it will be easy to regain this property without significantly altering some core design choices."
10:26:57 <benmachine> this may not actually be true
10:26:59 <benmachine> I'm not sure
10:27:46 <DanBurton> I wonder if/when Paolo and Gabriel will post an updated pipes library
10:31:03 * DanBurton adds them to his G+ circles
10:31:50 <shergill> heh that's what i did too
10:33:58 <bgamari> Arg, anyone know why an mapM_ing an RWS action over many iterations would result in a stack overflow?
10:34:19 <bgamari> I'm using the Strict variant
10:35:20 <bgamari> Unfortunately I don't have it reduced to a minimal test case yet
10:35:21 <rwbarton> Strict is not strict in the way you probably expect
10:35:34 <bgamari> I'm using $! in put, tell, etc.
10:35:40 <rwbarton> oh
10:35:54 <rwbarton> is your state type a record with non-strict fields?
10:36:03 <bgamari> Nope
10:36:11 <c_wraith> how about your writer?
10:36:14 <c_wraith> () is non-strict
10:36:17 <bgamari> It's just a Word64
10:36:23 <c_wraith> ok.
10:36:29 <bgamari> RWS () (V.Vector Time) AlexState ()
10:36:39 <bgamari> where AlexState has only strict fields
10:36:40 <c_wraith> RWS with () as the writer will always leak
10:36:50 <bgamari> That's the reader
10:36:56 <c_wraith> it's strict RWS, right?
10:37:02 <bgamari> Yep
10:37:36 <bgamari> Perhaps just a WriterT State stack would be better?
10:37:47 <bgamari> I don't need the reader (hence ())
10:37:55 <DanBurton> c_wraith: why would it "always leak"?
10:38:14 <c_wraith> DanBurton: because mappend is lazy for ()
10:38:37 <c_wraith> DanBurton: meaning it will build up giant thunk chains of uselessness.
10:38:46 <rwbarton> isn't it lazy for everything
10:38:53 <DanBurton> mmm. is there a strict version of Unit?
10:39:00 <rwbarton> I mean, what's going to examine the writer state
10:39:14 <DanBurton> meaning an mappend that is not lazy for ()
10:40:01 <c_wraith> rwbarton: that's probably true with RWS.  it's less of an issue with just plain Writer
10:40:20 <bgamari> Any ideas on the problem at hand?
10:40:47 <DanBurton> bgamari: I'm clueless until I get a little code to play with :)
10:40:51 <mux> so, it turns out the way the deepseq package uses rnf :: a -> () as the class function rather than something like seq :: a -> b -> b improves performance _dramatically_
10:40:59 <mux> http://mu.org/~mux/report.html
10:41:17 <mux> generic-deepseq2 is generic-deepseq using the same class function
10:41:59 <mux> uhoh, or I messed up and it doesn't even do anything anymore, possibly :-P
10:42:39 <c_wraith> not doing anything is usually fast
10:42:41 <bgamari> DanBurton: Alright; I'm going to try removing the reader
10:42:41 <mux> mmm, it seems to work though
10:42:52 <mux> maybe the way I wrote my criterion benchmark is wrong
10:43:22 <DanBurton> @google how to lie with numbers
10:43:24 <lambdabot> http://www.forbes.com/sites/timworstall/2011/12/10/how-to-lie-with-numbers-alcohol-and-health-care-edition/
10:43:24 <lambdabot> Title: How to Lie With Numbers: Alcohol and Health Care Edition - Forbes
10:44:10 <rwbarton> > runWriter (replicateM_ 10000 (modify (+1))) 0 :: Int
10:44:10 <lambdabot>   Couldn't match expected type `t -> GHC.Types.Int'
10:44:11 <lambdabot>         against inferred ...
10:44:23 <rwbarton> :t runWriter
10:44:24 <lambdabot> forall w a. Writer w a -> (a, w)
10:44:26 <c_wraith> did you want tell?
10:44:34 <c_wraith> also, Int is not a Monoid
10:44:36 <rwbarton> ... I wanted a lot of things. :P
10:44:47 <DanBurton> :t modify
10:44:49 <lambdabot> forall s (m :: * -> *). (MonadState s m) => (s -> s) -> m ()
10:44:57 <rwbarton> > runWriter (replicateM_ 10000 (tell (Sum 1))) :: Sum Int
10:44:57 <lambdabot>   Couldn't match expected type `Data.Monoid.Sum GHC.Types.Int'
10:44:58 <lambdabot>         agains...
10:45:05 <rwbarton> > runWriter (replicateM_ 10000 (tell (Sum 1))) :: ((), Sum Int)
10:45:06 <lambdabot>   ((),Sum {getSum = 10000})
10:45:13 <rwbarton> hmm
10:45:37 <rwbarton> > foldr (+) 0 (replicate 10000 1) :: Int
10:45:37 <lambdabot>   10000
10:46:59 <DanBurton> > execWriter $ mapM_ (const $ tell (Sum 1)) [1..100000]
10:47:01 <lambdabot>   Sum {getSum = 100000}
10:47:09 <dmwit> Sum and Product really ought to have Num instances.
10:47:21 <dmwit> tell 1 is just so much prettier than tell (Sum 1)
10:48:37 <DanBurton> dmwit: where would one request that. ghc trac?
10:49:35 <dmwit> libraries@, I guess?
10:50:26 <rwbarton> Apparently I need a much bigger number than 10000 to see the space usage. But how am I supposed to write this "runWriter (replicateM_ 10000 (tell (Sum 1))) :: Sum Int" so that it runs in constant space?
10:50:55 <dmwit> rwbarton: I think you need a strict writer to do that.
10:51:02 <dmwit> Writer is organized to carefully preserve laziness.
10:51:10 <dmwit> (And I've used that fact several times, it's quite handy.)
10:51:29 <rwbarton> but even stricter than Control.Monad.Writer.Strict
10:52:00 <dmwit> ...maybe
10:52:21 <dmwit> ?src Sum
10:52:21 <lambdabot> Source not found. Sorry about this, I know it's a bit silly.
10:52:21 <rwbarton> if this control-C doesn't go through soon, I am about to run out of swap space. So yes. :P
10:52:34 <dmwit> ^Z goes through faster
10:52:37 <c_wraith> ctrl-z instead
10:52:38 <c_wraith> heh
10:52:42 <dmwit> (Because it doesn't require the cooperation of the program.)
10:52:58 <rwbarton> oh right, well, fortunately it did
10:52:59 <dmwit> ^Zkill %1 is like muscle-memory for me now
10:53:16 <dmwit> (Which has gotten me in trouble when %1 wasn't the right job. =P)
10:53:32 <c_wraith> retrain yourself to %%
10:53:32 <rwbarton> (shouldn't GHC be checking for signals whenever my program allocates? which it obviously is doing)
10:53:48 <dmwit> What's %%?
10:54:15 <geekosaur> except it does sometimes
10:54:28 <hpaste> “Ben Gamari” pasted “Stack overflow” at http://hpaste.org/64175
10:54:38 <bgamari> rwbarton: That's about as minimal as I can make it
10:54:38 <geekosaur> in the shell, %% is the current job
10:54:45 <dmwit> rwbarton: Does expanding the stack count as allocating?
10:54:49 <c_wraith> The symbols  %%  and %+  refer  to  the shell's notion of the current job, which is the last job stopped while it was in the foreground  or  started  in  the  background.
10:54:53 <rwbarton> oh, maybe that's it
10:55:02 <bgamari> rwbarton: The problem is in getTimes
10:55:11 <rwbarton> ... is the stack supposed to grow to over 1 GB though?
10:55:13 <geekosaur> (and, "it does sometimes" is because ^z sends SIGTSTP, which the program can intercept, then SIGSTOP which it can't)
10:55:57 <dmwit> "If I could go back and change anything about Unix, I would name it 'unmount' instead."
10:56:25 <monochrom> heh
10:56:38 <c_wraith> that's it? of all the things to fix, that's it?
10:57:01 <dmwit> c_wraith: Presumably it's a comment on changing the philosophy away from short, cryptic names towards readable, explanatory ones.
10:57:11 <dmwit> I've always read that quote that way, anyway.
10:57:30 <c_wraith> at least with a use frequency filter.  note that he didn't say change ls to list
10:57:36 <dmwit> re: SIGTSTP vs SIGSTOP
10:57:44 <monochrom> I do not oppose short names. but between unmount and umount, there is not much shortening to begin with
10:57:46 <MaybeJust> is F sharp better for games than haskell?
10:58:07 <dmwit> ?faq Can Haskell do games better than F#?
10:58:08 <lambdabot> The answer is: Yes! Haskell can do that.
10:58:52 <rwbarton> why not umout
10:59:01 <dmwit> Alternate answer: yes, Haskell is 3 game-making units better than F#.
10:59:42 <c_wraith> I'm sure I was told intercal is the best game-making language ever
10:59:53 <nand`> ?faq Can Haskell rid the world of Java?
10:59:53 <lambdabot> The answer is: Yes! Haskell can do that.
10:59:57 <rwbarton> bgamari: my guess is you are building up a big V.singleton r1 `mappend` (V.singleton r2 `mappend` (V.singleton r3 `mappend` ...))
11:00:41 <bgamari> rwbarton: I guess that's possible
11:00:52 <bgamari> Writer.Strict isn't strict in the accumulator?
11:00:54 <rwbarton> no
11:01:01 <bgamari> blargh
11:01:01 <rwbarton> it's only strict in the pair (a, w)
11:01:02 <benmachine> dmwit: I heard the same quotation but with "creat"
11:01:17 <c_wraith> bgamari: that's what I was trying to tell you when I said Writer () can never not leak
11:01:30 <dmwit> benmachine: Perhaps I remembered the spirit of the quote, but not the letter.
11:01:41 <c_wraith> bgamari: if it was strict in the accumulator, that'd be fine.
11:01:47 <hpaste> DanBurton pasted “Num instances for Sum and Product” at http://hpaste.org/64176
11:01:51 <geekosaur> they are two separate quotes, wioth different wording, at different times
11:02:06 <DanBurton> quite trivial, I don't think it breaks any laws or anything ^
11:02:16 <rwbarton> what if you use something like a DList and then convert to Vector at the end
11:02:17 <bgamari> c_wraith: Ahhh, I see. I thought you were confused with the type of the Reader
11:02:19 <geekosaur> and I think one was Ken Thompson and the other was Dennis Ritchie
11:02:26 <benmachine> Num doesn't actually have laws as such
11:02:27 <bgamari> rwbarton: That's fine with me
11:02:32 <benmachine> geekosaur: oh, right
11:02:35 <mux> how would you benchmark a deepseq?
11:02:52 <c_wraith> mux: with whnf from criterion.
11:03:00 <c_wraith> (on the result of rnf)
11:03:01 <rwbarton> bgamari: I would try that, alternatively write your own Writer with a strict pair
11:03:01 <mux> that's what I'm doing
11:03:16 <mux> but what would you deepseq?
11:03:22 <mux> I'm deepseq'ing huge Int lists
11:03:24 <dmwit> DanBurton: Surely that can be just "deriving (Num)" in both cases.
11:03:31 <dmwit> DanBurton: They're newtypes, after all.
11:03:40 <bgamari> rwbarton: I'd just assume take the path of least resistance (DList)
11:03:44 <c_wraith> mux: a huge list seems fine, so long as you're sure there isn't sharing
11:03:58 <mux> that's what I'm trying to make sure of
11:04:06 <DanBurton> dmwit: I wasn't aware that Num was derivable.
11:04:11 <mux> but the fact that criterion seems to have a lot of problems with my clock doesn't help
11:04:21 <benmachine> DanBurton: there's an extension to derive classes for newtypes
11:04:24 <rwbarton> DList is going to be pretty wasteful in terms of heap usage, is the main reason to consider not using it
11:04:50 <bgamari> rwbarton: arg; I guess I could consider writing a Writer
11:05:00 <benmachine> you could abuse State as a Writer
11:05:03 <DanBurton> if we're going to propose it for the base libraries, then it should probably be vanilla Haskell 2010
11:05:19 <rwbarton> yeah that would work also
11:05:24 <benmachine> DanBurton: perhaps. Control.Exception is already non-standard
11:05:24 <bgamari> Is it just me or have I stumbled upon a bit of a gap in the library; it seems like Control.Monad.Trans.Writer.ReallyStrict would be rather useful in cases like this
11:05:41 <hpaste> dmwit pasted “Num Sum/Product” at http://hpaste.org/64177
11:06:04 <dmwit> DanBurton: Oh, yeah, maybe. I guess GeneralizedNewtypeDeriving isn't Haskell2010? =/
11:06:25 <DanBurton> it seems straightforward enough
11:06:27 <benmachine> dmwit: doing GeneralizedNewtypeDeriving correctly in general is actually a little subtle
11:06:34 <rwbarton> so do GADTs, right? *evil grin*
11:06:39 <benmachine> there's an open GHC bug about it
11:07:02 <DanBurton> benmachine: is it? I thought it would be trivial, given the newtypes disappear by runtime. Just fall back to the underlying type's instance.
11:07:21 <dmwit> DanBurton: There's something weird about coercions.
11:07:41 <benmachine> DanBurton: the key is that at the moment the extension assumes you can apply or remove constructors anywhere in a type
11:07:52 <dmwit> Ah, no, the weirdness is in conjunction with type families / GADTs.
11:08:00 <rwbarton> in order to do GeneralizedNewtypeDeriving you need to do coercion "under" another type constructor
11:08:10 <benmachine> dmwit: actually you don't even need those, although I think you do if you want to do anything really horrible
11:08:18 <rwbarton> which is only legitimate if the type constructor is suitably parametric
11:08:23 <benmachine> class SameAsInt a where conv :: t Int -> t a
11:08:38 <benmachine> newtype NotInt = NotInt Int deriving SameAsInt
11:08:44 <benmachine> then you get t Int -> t NotInt
11:08:49 <benmachine> even when t isn't a Functor
11:09:02 <rwbarton> not being a Functor isn't quite the problem
11:09:11 <rwbarton> the problem is that t may not even respect isomorphisms
11:09:33 <benmachine> rwbarton: I suppose so; being a Functor would certainly be enough
11:09:37 <rwbarton> it's fine if t is something like Endo where Endo a = Endo (a -> a)
11:09:38 <benmachine> http://hackage.haskell.org/trac/ghc/ticket/1496 see the last example
11:09:55 <copumpkin> rwbarton: it's just leibniz
11:09:58 <dmwit> benmachine: Uh... NotInt doesn't even have the right kind.
11:10:11 <benmachine> dmwit: sure it does, t isn't the parameter of the class
11:10:19 <copumpkin> this is just leibniz equality
11:10:22 <rwbarton> t has to be functorial w.r.t. isomorphisms
11:10:23 <copumpkin> hardcoded to Int
11:10:24 <dmwit> oh oh
11:10:26 <bgamari> Is there a reason why there isn't a super-strict writer in transformers?
11:10:38 <rwbarton> which normal ADTs are but type families and GADTs need not be
11:10:40 <benmachine> bgamari: transformers doesn't get everything right
11:10:56 <benmachine> rwbarton: there's a good example with Set
11:11:13 <copumpkin> yeah
11:11:15 <dmwit> Luckily, newtypes do respect isomorphisms.
11:11:16 <benmachine> rwbarton: exploiting that Int and NotInt might have different Ord instances, for e.g.
11:11:20 <copumpkin> dmwit: not really
11:11:22 <bgamari> benmachine: Do you think there's room for a monad to this effect?
11:11:24 <rwbarton> oh yeah, the coherence with instances is a problem too
11:11:30 <dmwit> Let me refine that:
11:11:38 <rwbarton> but not as big a problem as being able to write unsafeCoerce :)
11:11:39 <dmwit> newtypes that don't use type families inside respect isomorphisms.
11:11:45 <dmwit> bleh, yeah, it's tricky
11:11:46 <copumpkin> dmwit: their instances can vary
11:11:47 <benmachine> bgamari: I don't think my opinion is particularly well-informed on this subject, but yes :)
11:11:49 <mux> ok, criterion only had problems with my clock because I'm an idiot and wasn't benchmarking shit, most likely :-P
11:12:09 <bgamari> benmachine: Well thanks for reassuring my belief as least ;)
11:12:28 <benmachine> rwbarton: no, you do need TFs or GADTs to *really* ruin things, but the problem is still there without them
11:12:35 <dmwit> Anyway, I thought the new Fc stuff was supposed to address these problems?
11:12:37 <benmachine> rwbarton: where by no I mean yes
11:12:41 <dmwit> Or have they not made it yet?
11:12:45 <benmachine> dmwit: shrug
11:12:46 <mux> http://mu.org/~mux/report.html \o/
11:12:51 <benmachine> bug's still open :P
11:13:02 <rwbarton> right, wasn't there a paper that introduced two kinds of (->) kind constructors
11:13:02 <benmachine> notice that Safe Haskell disables the extension
11:13:19 <benmachine> probably because of that bug
11:13:32 <mux> at least, switching to a rnf :: a -> () class function puts me in the same league as deepseq
11:17:18 * hackagebot order-statistics 0.1 - L-Estimators for robust statistics  http://hackage.haskell.org/package/order-statistics-0.1 (EdwardKmett)
11:17:40 <MaybeJust> Haskell vs F#, go!
11:18:28 <edwardk> MaybeJust: higher kinded polymorphism. Haskell wins, flawless victory
11:18:35 <bgamari> Could someone expound upon ekmett's remark: http://permalink.gmane.org/gmane.comp.lang.haskell.libraries/16131
11:18:45 <DanBurton> Well I hate Microsoft, so since MS funds SPJ...Haskell has to be the obvious loser!
11:18:55 <mekeor> MaybeJust: F# only runs on Windows → haskell wins
11:19:16 <bgamari> I'm using $! everywhere I feel is appropriate, yet I still have leakage
11:19:25 <mekeor> DanBurton: well, F# runs on .NET, so what?
11:19:27 <edwardk> bgamari: ?
11:19:39 <edwardk> bgamari: are you using get and put rather than modify?
11:20:01 <bgamari> edwardk: bah, I misread your comment
11:20:17 <rwbarton> he was using Writer
11:20:20 <edwardk> ah
11:20:20 <bgamari> I didn't see your mention of State
11:20:24 <edwardk> yeah
11:20:26 <edwardk> the state is key =)
11:20:41 <bgamari> It seems to me like this isn't a particularly strange of Writer
11:20:55 <bgamari> It is genuinely surprising that you have to use State instead
11:21:08 <zeratul> Is there still some problem with hackage, such that cabal update would be inoperable right now?
11:21:37 <edwardk> zeratul: trying
11:22:04 <edwardk> working fine for me
11:22:12 <zeratul> Hm, okay. Thanks.
11:22:17 <bgamari> Is there a succinct reason why Writer "isn't the Monad [I] am looking for?", beyond an the lax strictness of the transformers Strict implementation
11:23:07 <edwardk> ultimately writer puts thunks in for the monoidal values
11:23:22 <edwardk> the strict/lazy is about whether or not the (,) is strict, not the values of the monoid
11:23:47 <bgamari> edwardk: but it seems this is an implementation issue; one could write a Writer which was strict in the value, no?
11:24:08 <edwardk> bgamari: yes. you can make a writer that is strict in its monoidal value
11:24:34 <bgamari> It's just very surprising to me that such an implementation doesn't already exist; I'm simply looking for a reason why this is so
11:24:48 <edwardk> its also easy to do accidentally when you swap from writer to state, and can be done by the end user using out of the box mtl machinery
11:25:06 <bgamari> sure
11:25:08 <mux> @karma+ criterion
11:25:09 <lambdabot> criterion's karma raised to 1.
11:25:41 <edwardk> part of it is that forcing polymorphic values is typically considered a bad idea ;)
11:25:54 <edwardk> not that its always, just that the mtl currently never does it
11:26:25 <bgamari> Alright
11:27:37 <benmachine> it's considered... sneaky
11:27:49 <benmachine> but it happens often enough that mtl should probably just get over it
11:28:23 <edwardk> well, i'd be willing to make a Writer.SuperStrict or something silly, but really that needs to be in transformers, which is ross's domain
11:28:26 <Abraxas> is this how elems would be implemented in foldr: elems = foldr (\y ys -> if (member y ys) then ys else y:ys) []
11:29:46 <edwardk> Abraxas: thats one way, another would be to make a more efficient lookup/storage solution than [] be the intermediate state, like a Set, etc.
11:37:00 <Abraxas> i have this example on free theorems for a filter-like function: http://bit.ly/Agsk8s
11:37:18 <Abraxas> i think 5 and 6 cannot be derived just like that?
11:37:28 <Abraxas> it's a texify link
11:38:38 <Abraxas> in the meantime i guess i found the assumptions which are made there
11:38:43 <Abraxas> i guess (5) is using this: g p (map h l) = map h (g (p o h) l)
11:38:56 <Abraxas> and (6) is prob. using this: g (map f l) = map f (g l)
11:39:52 <Abraxas> but i don't see how
11:45:29 <gui655> hi
11:46:09 <gui655> does anyone know how to create funtion for scrambling strings to given number
11:46:10 <gui655> ?
11:55:12 <MaybeJust> I got a job porting Haskell code to Java. The haskell code apparently is to buggy. it is a concurrent application.
11:56:10 <nyingen> does it have function for scrambling strings to given number?
11:56:24 <Botje> guibou: what do you mean by that?
11:56:56 <companion_cube> MaybeJust: and they hope that porting it to java will reduce the concurrency bugs?
11:56:56 <Botje> oh, completely different person. nevermind
11:57:36 <jgrimes> has anyone made fclabels  labels for haskell-src-exts? What would be the best way to do that?
11:57:51 <mux> is there a way to have a changelog via cabal now?
11:58:47 <dcoutts> mux: the new server will list changelogs
11:59:00 <dcoutts> will/does
11:59:23 <cmccann> MaybeJust, it's possible to write bad code in any language
11:59:32 <mux> dcoutts: where will it read them from, and in what format?
12:00:09 <dcoutts> mux: yeah, that's the interesting bit. From a file called changelog and in plain text, no format prescribed yet
12:00:21 <cmccann> MaybeJust, I really can't fathom how porting Haskell to Java is going to reduce concurrency bugs though
12:00:52 <mux> dcoutts: okay, thank you :) I guess I'll abuse the description field like everyone else for now
12:00:56 <dcoutts> mux: personally my tendency would be to require a format, so we can e.g. format in html and extract just the bit relevant for a single release
12:01:25 <dcoutts> mux: you mean you wouldn't use it as is, even if it were live on hackage?
12:01:38 <shergill> cmccann: they might have more people who're proficient in java? or perhaps people who're more proficient in java?
12:01:40 <dcoutts> or that you would use it, and in the mean time will abuse the description
12:01:51 <mux> dcoutts: no, not at all, I won't use it just because it's not live right now
12:02:01 <dcoutts> mux: ok, just clarifying, ta
12:03:06 * mux starts daydreaming about providing an input changelog file to cabal, and a ByteString -> [ByteString] function in the cabal file itself
12:03:36 <cmccann> shergill, concurrency is really difficult in most languages
12:03:43 <dcoutts> mux: how about ordinary gnu changelog format, with version numbers
12:04:03 <shergill> cmccann: i agree. and would be more difficult in languages like java than haskell
12:04:14 <mux> dcoutts: yeah, sure (I didn't even know there was an official GNU standard on that)
12:04:15 <shergill> was just trying to think of reasons why someone would take that path
12:04:17 <cmccann> haskell makes concurrency pretty easy
12:04:25 <mux> as long as it doesn't require me to relicense my code in GPL :D
12:04:30 <dcoutts> heh
12:04:36 <cmccann> clojure would make sense as well I'd guess
12:04:42 <Enigmagic> shergill: supportability and maintenance
12:05:46 <nyingen> I have trouble imagining a java codebase that is "more maintainable" than a haskell one
12:05:47 <cmccann> using java will support requiring a lot more maintenance, that is true
12:06:11 <Enigmagic> try hiring a haskell developer to maintain a 5 year old codebase
12:06:16 <Igloo> dcoutts: Do you know how that compares to the Debian changelog format?
12:06:39 <dcoutts> Igloo: not sure, I assumed they were the same
12:06:41 <Enigmagic> most companies don't care enough, it's "cheaper" to have one of the 500 java developers fix shit
12:06:59 <cmccann> Enigmagic, assuming that the fixes aren't required to actually work
12:07:27 <Enigmagic> cmccann: it's a business risk to have one project in a language that is not core to the company
12:07:45 <cmccann> Enigmagic, I am familiar with all the rationalizations for using substandard tools, yes
12:07:50 <ssalbiz> hey guys
12:07:57 <ssalbiz> I had a question about polymorphism in haskell
12:08:22 <Enigmagic> cmccann: substandard like haskell's debugging? :P
12:08:37 <ssalbiz> is it the same kind of polymorphism found in object oriented languages
12:08:55 <ssalbiz> or is it a kind of morphism in category theory?
12:09:11 <cmccann> ssalbiz, I don't think it's either of those
12:09:31 <cmccann> it's parametric polymorphism, it's more like what many OO languages call "generics"
12:10:09 <ssalbiz> so there is no formal mapping between a category theory morphism and haskell polymorphism?
12:10:24 <cmccann> Enigmagic, yeah, that really could stand to be improved, but even so I lose less time because of a substandard debugger than I do because of substandard everything in other languages
12:10:33 <nand`> ssalbiz: natural transformations
12:10:37 <mux> bah, Hackage won't accept a package if there's a warning about an unknown extension?
12:10:42 <cmccann> nand`, that's not quite right
12:11:03 <cmccann> nand`, parametricity gives you naturality for free with the obvious type signature I think
12:11:15 <tazjin> @src last
12:11:15 <lambdabot> last [x]    = x
12:11:16 <lambdabot> last (_:xs) = last xs
12:11:16 <lambdabot> last []     = undefined
12:11:39 <everythingWorks> what again does GHCi stand for?
12:11:41 <cmccann> ssalbiz, parametric polymorphism is related to, and often expressed in terms of, universal quantification
12:12:02 <Abraxas> speaking of which!  texify-link => http://bit.ly/Agsk8s
12:12:19 <cmccann> ssalbiz, in the usual interpretation of category theory in Haskell, morphisms are just monomorphic functions
12:12:20 <Abraxas> how do i get 5 and 6?
12:12:44 <Enigmagic> cmccann: until there is a problem that requires a debugger
12:13:02 <Abraxas> will you even look at something like this or should i paste the tex?
12:13:07 <nand`> cmccann: I see. I just knew that natural transformations can be used to model, for example, the identity function id :: forall a. a -> a as a natural transformation from (Id :: Hask -> Hask) to itself
12:13:26 <Enigmagic> cmccann: i've spent 2 days tracking down a null pointer dereference in someone elses code before, that would typically be a 30 second task in java or c++
12:13:49 <cmccann> Enigmagic, well, again it's always possible to write bad code
12:14:05 <cmccann> but it's a lot easier to write good code in Haskell
12:14:06 <Abraxas> i guess (5) is using this: g p (map h l) = map h (g (p o h) l) and (6) is using this: g (map f l) = map f (g l)
12:14:22 <shachaf> cmccann: I have a programming language that doesn't allow you to write bad code.
12:14:28 <Enigmagic> of course, even so i don't think a junior developer maintaining haskell code would have been able to do it in two days. that's a real risk imo
12:14:32 <cmccann> shachaf, HQ9+?
12:14:44 <shergill> APL!
12:15:09 <shachaf> cmccann: Well, it doesn't allow you to write good code either.
12:15:11 <nand`> cmccann: the difference between most language's generics is that generics must be of the form * -> * -> * ..., something like (* -> *) -> * -> * isn't possible using just generics the way they're commonly found in OOP languages
12:15:36 <shachaf> HQ9+ certainly lets you write bad code, full of duplication and undocumented and what not.
12:15:57 <cmccann> nand`, yes, generics are usually more limited, but they're still parametric polymorphism
12:15:58 <nand`> at least that's the way I know them from C#
12:16:10 <Enigmagic> nand: c++ doesn't have that problem
12:16:24 <cmccann> C++ also doesn't have parametric polymorphism, I don't think
12:16:28 <cmccann> templates are a different beast
12:16:36 <cmccann> more expressive
12:16:44 <cmccann> which is both good and bad of course
12:16:53 <hiptobecubic> If each module is able to be built independently, what stops cabal from building them concurrently/
12:17:06 <Enigmagic> cmccann: if you consider templates part of the language, it does
12:17:07 <lukish> How can I append to left list with some values? For example, f 8 0 $ [1,2,3,4,5] -> [0,0,0,1,2,3,4,5]
12:17:45 <hiptobecubic> lukish, replicate 3 0 ++ list
12:18:05 <cmccann> Enigmagic, are C++ templates truly parametric? do they give you any sort of parametricity guarantees?
12:18:14 <hiptobecubic> > replicate 3 0 ++ [1,2,3,4,5]
12:18:18 <lambdabot>   mueval-core: Time limit exceeded
12:18:27 <cmccann> C#'s generics do, up to mucking about with reflection and internals
12:19:14 <bgamari> everythingWorks: something like ghc interactive I think
12:19:32 <everythingWorks> aye!
12:19:44 <everythingWorks> g ~ graphical :p
12:19:52 <zeratul> cmccann: What kind of guarantees are you referring to?
12:19:57 <sp> hi
12:19:57 <Enigmagic> cmccann: guarantees?
12:20:23 <hiptobecubic> > replicate 3 0 ++ [1,2,3,4,5] -- timeout?
12:20:27 <lambdabot>   mueval-core: Time limit exceeded
12:20:35 <hiptobecubic> Am i missing something here?
12:20:38 <hiptobecubic> It works in ghci
12:20:50 <cmccann> zeratul, simple parametricity
12:21:08 <hiptobecubic> > replicate 3 0
12:21:09 <lambdabot>   [0,0,0]
12:21:28 <hiptobecubic> > (replicate 3 0) ++ [1,2,3,4,5]
12:21:29 <lambdabot>   [0,0,0,1,2,3,4,5]
12:21:48 <hiptobecubic> > replicate 3 0 ++ [1,2,3,4,5]
12:21:49 <lambdabot>   [0,0,0,1,2,3,4,5]
12:22:03 <cmccann> Enigmagic, that stuff will be treated uniformly regardless of how the type parameters are instantiated
12:22:34 <Enigmagic> cmccann: if you're careful
12:22:38 <Enigmagic> just like all c++ :P
12:22:46 <cmccann> Enigmagic, in other words no
12:22:52 <Enigmagic> it supports it
12:22:58 <Enigmagic> it just doesn't require it
12:22:59 <cmccann> no, it lets you do it manually
12:23:01 <cmccann> not the same thing at all
12:23:09 <cmccann> and is exactly my point
12:23:14 <Enigmagic> alrighty
12:24:00 <cmccann> "you can do things correctly if you're careful" is not a viable approach as code complexity increases
12:24:18 <Enigmagic> i think that's different than saying it doesn't work ever but that's just me
12:25:54 * Enigmagic is off to lunch
12:26:01 <cmccann> Enigmagic, I didn't say it never works
12:26:06 <cmccann> just that the language doesn't have it
12:26:15 <cmccann> you have to provide those guarantees yourself
12:26:16 <thoughtpolice> cmccann: trust me, if you just *think harder* and it wouldn't be a problem, obviously. now where are my TPS reports?
12:26:42 <Enigmagic> cmccann: that's how many things are in c++ land
12:26:51 <Enigmagic> anways i'm out
12:26:52 <cmccann> yes, and C++ land is terrible
12:27:01 <cmccann> because of things like that
12:27:13 <nand`> You might as well argue that C supports objected oriented programming because the user can do it manually using pointers if they're careful
12:27:35 <cmccann> nand`, people actually do, as you probably know :D
12:27:53 <cmccann> there are mature OOP-based C libraries in active use I think, though I forget what they are
12:28:07 <ben> gobject, yo
12:28:12 <nand`> It seems to me like a case of using the wrong tool for the job
12:28:41 <nand`> Something like tacking on a screw driver head to the top of a hammer
12:28:42 <nyingen> yeah, GTK and co
12:28:43 <mekeor> yippie! nand` is online again :)
12:28:47 <cmccann> probably, though sometimes things are fossilized workarounds from before better tools were established
12:28:48 <mekeor> he's like 24h online hehe
12:28:53 <nand`> mekeor: I'm always online
12:29:07 <mekeor> nand`: yea, but not always not afk, right?
12:29:16 <nand`> cmccann: ... C :)
12:29:22 <nand`> mekeor: true
12:29:27 <cmccann> welding a screwdriver tip onto a hammer might be sensible if nobody has invented handheld screwdrivers yet
12:29:32 <nand`> cmccann: I actually feel that way about Lisp though
12:29:34 <thoughtpolice> C++ reminds me of the OK chinese food you had one time, but now that it's been in your fridge for so long, it suffers from a horrible organic growth.
12:29:50 <ben> In gobject's defense, if their aim was to implement functionality in the lowest-common-denominator language that would let them expose it naturally to a variety of scripting languages and so on, they didn't do too badly
12:30:05 <cmccann> ben, yes, there are also considerations like that
12:30:31 <cmccann> nand`, heh, how so?
12:31:18 <nand`> cmccann: I mean, lisp tries to have a functional feel but it's like the authors didn't know how to implement pure functionalism back when it was created so it ended up as a “multi-paradigm” mixture of imperative and sort-of-functional
12:31:35 <nyingen> nand`: speaking of OOP in C, BDB has a pseudo-OO interface, though I'm not sure it can really be considered to be simulating OOP
12:31:37 <nand`> I'll admit I don't have much experience with lisp though
12:32:21 * hackagebot generic-deepseq 2.0.0.0 - Generic deep evaluation of data structures  http://hackage.haskell.org/package/generic-deepseq-2.0.0.0 (MaximeHenrion)
12:32:45 <ben> A lot of C libraries have a pseudo-OOP interface where you do gadget* g = gadget_init(...); gadget_do_stuff(g, ...); gadget_destroy(g);, but they don't all do things like polymorphism~
12:32:50 <nyingen> BDB's API struck me as more of a cute trick that was taken as far as it could go
12:33:21 <nand`> ben: you mean void* isn't polymorphism? :)
12:34:12 <ben> I didn't say void*! :)
12:34:24 <nand`> ben: either that's actually sort of what Go does, it has syntactic sugar for this as well (g.do_stuff(...)); it also has interfaces though
12:34:30 <nand`> either way*
12:43:01 <Jesin> hi
12:43:06 <Jesin> where did System.Random go?
12:43:30 <hpc> @hoogle random
12:43:30 <lambdabot> System.Random class Random a
12:43:30 <lambdabot> System.Random random :: (Random a, RandomGen g) => g -> (a, g)
12:43:30 <lambdabot> package random
12:43:38 <hpc> right there :P
12:44:10 <Jesin> hm, okay
12:44:24 <Jesin> I just noticed it used to be in http://www.haskell.org/ghc/docs/latest/html/libraries/ and now it isn't
12:45:09 <Jesin> I guess you just have to download the package though
12:45:10 <Jesin> k
12:46:32 <ChristianS> mwc-random is supposed to be much faster, i've heard
12:49:44 <Irfan_A> Hi all, can Haskell create application for desktop (Linux, Windows, Mac, etc) & please give examples? Sorry I am new to Haskell and still learning, I come from BASIC dialect... .
12:50:32 <hpc> Irfan_A: leksah is pure haskell
12:51:07 <hpc> there's a few games too, though they are mostly side projects
12:51:27 <hpc> and i think cale is still working on an iphone game
12:52:28 <ChristianS> plucas, dylukes (in case you missed this): i've posted some updates to our set creation experiments at http://hpaste.org/64167 . short resume: IntSet is pretty OK for pure code, judy is awesome in the IO monad.
12:52:30 <monochrom> http://hackage.haskell.org/package/manatee may blow you away. look for "Then choose extension package list in below to install:"
12:52:40 <dylukes> ChristianS: I saw
12:52:46 <dylukes> After you left I thought of Judy.
12:52:50 <dylukes> Always a good option ^^.
12:53:03 <dylukes> the stream fusion stuff was totally superfluous :P
12:53:04 <dylukes> btw
12:53:14 <ChristianS> dylukes: i noticed ;-)
12:53:15 <dylukes> and IntSet is just IntMap Int ()
12:53:19 <zeratul> Are there any native high level gui frameworks for Haskell yet? Last time I looked it seemed most of the libraries available were bindings and were limited in that it was not feasible to compose new widgets.
12:53:25 <dylukes> So, any difference between those two was just because of our respective machines
12:53:26 <dylukes> :)
12:53:32 <dylukes> (they were the same thing)
12:53:33 <plucas> ChristianS: neat - thanks for the update
12:53:33 <lambdabot> plucas: You have 1 new message. '/msg lambdabot @messages' to read it.
12:53:43 <hpc> Irfan_A: haskell is used a lot more for "hard problems", so you will see lots more internal tools
12:53:48 <hpc> research stuff
12:53:56 <hpc> or command line stuff
12:53:56 <dylukes> business/economics stuff
12:54:08 <ChristianS> dylukes: yes, i know that IntMap+IntSet is basically the same
12:54:38 <ChristianS> dylukes: what surprised my was that hashtables was so slow -- since the author boosted a lot, i supposed it would be faster...
12:54:44 <hpc> like darcs, or the whatsit that refactors facebook's shit php code
12:56:35 <dylukes> ChristianS: well, it's still an awkward structure functionally speaking I suppose.
12:56:42 <ChristianS> lambdabot: why did you what so long to tell plucas about my message? you were supposed to do it right after he came back here...
12:56:48 <ChristianS> lazy, lazy bot...
12:57:08 <dylukes> She's written in Haskell, what do you expect?
12:57:10 <plucas> ChristianS: that's haskell for you, amirite
12:57:12 <plucas> aw
12:57:20 <dylukes> Beat 'cha to it :)
12:57:24 <ChristianS> good point
12:57:29 <hpc> ChristianS: it waits for the person to talk
12:57:41 <jgrimes> how can you use fclabels on a datatype that doesn't have named records? do I just have to define my own labels/lenses or whatever?
12:57:43 <dylukes> hpc++
12:57:50 <dylukes> jgrimes: bingo.
12:57:54 <ChristianS> not just lazy, but shy, too. i see...
12:58:06 <dylukes> I recommend edwardk's data-lens
12:58:08 <nand`> dylukes: hehe, such is the plight of lazy languages :)
12:58:11 <lispy> ?vixen are you shy?
12:58:11 <lambdabot> Always remember that others may hate you but those who hate you don't win unless you hate them. And then you destroy yourself.
12:58:14 <dylukes> As opposed to fclabels though.
12:58:23 <dylukes> lispy: that's nixon :P
12:58:27 <lispy> philosobot
12:58:36 <dylukes> Everyone in here has, at some point,
12:58:43 <dylukes> flirted with a virtual "AI" of Nixon
12:58:44 <jgrimes> dylukes: oh really… I was going to use fclabels because I wanted to be able to use pez
12:58:45 <dylukes> congrats.
12:58:49 <byorgey> ChristianS: well, you wouldn't wait people to be notified on join, because it might have just been a disconnect+auto-rejoin, or a netsplit, or something
12:58:50 <dylukes> pez?
12:58:53 <byorgey> and they wouldn't see it
12:59:03 <jgrimes> http://hackage.haskell.org/package/pez-0.0.4
12:59:10 <Irfan_A> hpc: thank you...
12:59:15 <jgrimes> http://hackage.haskell.org/package/pez-0.1.0 rather, that is the most recent version
12:59:27 <jgrimes> generic zipper
12:59:51 <lispy> pez as in the candy dispenser?
12:59:59 <danr> that's a witty name
13:00:51 <elliott1> what is the difference between $ and . ?
13:01:00 <tgeeky_> :t ($)
13:01:01 <lambdabot> forall a b. (a -> b) -> a -> b
13:01:02 <tgeeky_> :t (.)
13:01:02 <Irfan_A> hpc: by the way, what do you mean with "lots more internal tool"?
13:01:02 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
13:01:03 <monochrom> like apple and orange
13:01:14 <tgeeky_> elliott1: start with: their types
13:01:35 <monochrom> f $ (g $ x) = (f . g) x  is the difference
13:02:03 <danr> elliott1: (.) is function composition, ($) is application
13:02:13 <dylukes> >_>
13:02:23 * hackagebot stm-tlist 0.1.1 - Mutable, singly-linked list in STM  http://hackage.haskell.org/package/stm-tlist-0.1.1 (JoeyAdams)
13:04:48 <nand`> and thus we have another elliott
13:05:15 <`Jake`> hmm... would be nice if the compiler would recognize a missing bracket instead of complaining about incorrect indentation
13:06:07 <tgeeky_> to which the compiler responds, it would be nice if USER would stop forgetting to type brackets!
13:06:37 <tgeeky_> <Marvin> brain as big as a spaceship, and you have me fixing your mistakes!
13:06:38 <monochrom> in an alternate universe: <ida> would be nice if the compiler would recognize incorrect indentation instead of complaining about a missing bracket
13:07:16 <`Jake`> Well, I suppose we are always complaining about negative aspects and forget the positive ones
13:07:19 <Abraxas> is there a haskell function similar to stepeval?
13:07:44 <`Jake`> I should be happy that the compiler is able to recognize incorrect indentation
13:07:48 <tromp__> what wld its type be?
13:07:49 <monochrom> in skynet: <ghc392834> would be nice if all complainers were electrocuted
13:08:34 <`Jake`> In this case, it wasn't a complain, it was constructive criticism ;-)
13:09:11 <monochrom> <gcc-489XA28I> nuking all humans subsumes that solution
13:09:12 <`Jake`> dang it, I should learn english first, i guess criticism isn't a word
13:09:23 <`Jake`> or is it?
13:09:33 <mauke> *complaint
13:09:38 <`Jake`> oh, it is
13:09:53 <`Jake`> thanks
13:09:54 <zeratul> Come on man, at least make up words that don't exist ;)
13:10:19 <`Jake`> next time
13:10:32 <monochrom> criticify
13:10:56 <mauke> perfectly cromulent
13:11:50 <`Jake`> Oh, now I remember: It's a common mistake for germans to say critics instead not criticism, not the other way round
13:11:59 <`Jake`> instead of*
13:13:07 <monochrom> I guess you can say "critiques"
13:13:25 <mauke> crises
13:13:34 * monochrom used "critiquing" recently!
13:13:59 <niteria> wow, that's a real word
13:14:29 <monochrom> yeah, I checked with merriam-webster that critique can be a verb
13:14:54 <niteria> what's wrong with criticising?
13:15:10 <niteria> or better criticizing
13:15:16 <`Jake`> not as cool?
13:15:37 <monochrom> criticism, even constructive criticism, focuses on what's wrong. critique is balanced, both pros and cons said
13:16:05 <niteria> heh, I knew I would learn something coming to #haskell
13:16:06 <`Jake`> Well, both is Kritik in german
13:17:23 <monochrom> and in my context I was really going for "both pros and cons"
13:17:36 <`Jake`> is it possible to say constructive critique?
13:17:40 <danr> monochrom: hmm, I didn't know that distinction
13:17:41 <hpaste> Abraxas pasted “repmin” at http://hpaste.org/64196
13:18:22 <Abraxas> is it at all possible to paste this into stepeval?
13:18:31 <Abraxas> or to have a look at what it does
13:19:50 <hpc> Irfan_A: by "internal tools" i mean programs to automate specific things, which would be totally useless outside the company that uses it
13:20:17 <monochrom> oh heh, I will try to tell you what the new tree looks like, in thunk form, ok?
13:20:19 <hpc> they aren't quite full programs, but they do non-trivial stuff
13:21:04 <Abraxas> or how to come up with that kind of program, what to look for if you suspect you can write it this way
13:21:49 <monochrom> so let's say the input tree is Node (Node (Leaf 1) (Leaf 2) (Node (Leaf 3) (Leaf 4))
13:22:50 <monochrom> the new tree has that same skeleton, except 1, 2, 3, 4 are all replaced by pointers to the same thunk. that thunk says min (min 1 2) (min 3 4)
13:24:08 <monochrom> and thus it is cheating to say "I traverse the tree just once". sure, but in that traversal you build a new tree (min (min 1 2) (min 3 4)) to be traversed later. there are still two traversals.
13:24:59 <dmwit> I traverse the tree O(1) times.
13:25:43 <Abraxas> oh sorry, i meant, looking at it step-by-step
13:26:04 <monochrom> I also have something said in http://www.haskell.org/haskellwiki/MonadFix#Lazy_algorithm_interleaved_with_effects , you don't have to know or care about MonadFix, just start reading at "2.2 Lazy algorithm ..." and end reading when you see "So far this can be written in pure code, needing no Monad or MonadFix"
13:27:14 <monochrom> the full step-by-step evaluation is a future project in my lazy evaluation tutorial
13:28:52 <monochrom> well, I guess I can just copy the relevant text
13:29:07 <`Jake`> if I do something like      let x = 2 * 2 in x + x        will haskell evaluate (2 * 2) once, save the result and use it twice or will it evaluate it twice (without saving the result)?
13:29:25 <Abraxas> i am reading, thanks
13:29:27 <Abraxas> nice
13:29:30 <mauke> both uses of x will refer to the same thunk
13:29:30 <tomodo> once
13:29:37 <`Jake`> ok, thanks
13:29:38 <mauke> so it will compute the result at most once
13:30:37 <monochrom> "Here is an approach. Given tree t and number s, repmin t s is written to do two things: replicate t but replace the numbers by s throughout, and find min of the numbers in t. This requires just one traversal. Now call this function in such as way as to feed the returned min back into the parameter s, and we will sneak the min into the replaced tree!"
13:30:38 <Abraxas> repmin uses partial application? because there is no m until the end, right?
13:30:55 <monochrom> that paragraph is how to come up with the code
13:31:05 <mauke> it's not partial application
13:31:44 <monochrom> it is fair to ask both "how to come up with this code" and "how it executes". but be warned that those are unrelated questions having unrelated answers.
13:33:37 <monochrom> repmin itself doesn't do the magic. the magic is in "let (t',m) = repmin t m in t'" that feeds back stuff
13:33:52 <monochrom> repmin itself does only what I said
13:34:02 <Abraxas> but where is the m coming from?
13:34:14 <mauke> from repmin
13:34:20 <monochrom> that's the feedback part
13:34:44 <Abraxas> partial application was the wrong word, i guess
13:34:53 <Abraxas> but m is not known until later on?
13:35:03 <monochrom> would it give you more incentive to read my paragraph if I replaced s by m?
13:35:29 <mkscrg> What do I have to do to get mapM to run computations concurrently?
13:35:35 <monochrom> "Here is an approach. Given tree t and number m, repmin t m is written to do two things: replicate t but replace the numbers by m throughout, and find min of the numbers in t. This requires just one traversal. Now call this function in such as way as to feed the returned min back into the parameter m, and we will sneak the min into the replaced tree!"
13:35:59 <c_wraith> knot-tying is fun!
13:36:07 <cmccann> monochrom, it would be better still if you replaced it with (☃)
13:36:19 <Abraxas> i thought there are no variables in haskell, how does it get fed to the m?
13:36:34 <c_wraith> Abraxas: let ones = 1 : ones in ones
13:36:44 <c_wraith> if you understand that, you're about 90% of the way there
13:36:55 <mekeor> is (words . unwords) or (concatMap words) better ?
13:37:05 <mhitza> mkscrg, I've had success with http://hackage.haskell.org/packages/archive/caf/0.0.3/doc/html/Control-Concurrent-Futures-Futures.html
13:37:11 <monochrom> it is recursion in m. non-strictness ensures that this recursion works out
13:37:40 <monochrom> or rather, non-strictness ensures that this recursion is not a useless infinite loop
13:39:12 <Irfan_A> hpc: thanks again... .
13:39:20 <Abraxas> ok, it's only working because of the recursion via the let
13:39:35 <monochrom> if you have a function f and you want to feed its return value into its parameter, you write something like "s = f s", no?
13:40:07 <monochrom> and if you say, but there is no global s! ok, "let s = f s", have a local s then, no?
13:41:35 <otters> @let a = a + 1
13:41:35 <lambdabot>  <local>:7:4:
13:41:35 <lambdabot>      Ambiguous occurrence `a'
13:41:35 <lambdabot>      It could refer to either `L....
13:41:40 <otters> @let foo = foo + 1
13:41:41 <lambdabot>  Defined.
13:41:43 <otters> :t foo
13:41:44 <lambdabot> forall a. (Num a) => a
13:41:45 <otters> > foo
13:41:49 <lambdabot>   mueval-core: Time limit exceeded
13:41:56 <monochrom> you can write fix(\s -> f s) or fix(\~(t',m) = repmin t m) too, if you like
13:42:31 <monochrom> err, s/=/->/
13:44:35 <Abraxas> ok =)
13:45:06 <monochrom> m is indeed not known until later on. it stays as a thunk for a while
13:45:42 <Abraxas> yeah, i was thinking it can't be a parameter variable, that confused me
13:46:01 <hpaste> “Ben Gamari” pasted “Overlapping instances” at http://hpaste.org/64199
13:46:11 <Abraxas> recursion + laziness
13:46:21 <bgamari> Anyone know why GHC things the vector Serialize instance overlaps with the generically derived one?
13:46:22 <monochrom> it is a parameter variable. you probably mean something else.
13:46:39 <bgamari>     Overlapping instances for Serialize (Hello a)
13:47:14 <monochrom> ah, I see what you mean, nevermind.
13:47:20 <hpaste> “Ben Gamari” annotated “Overlapping instances” with “Overlapping instances (error)” at http://hpaste.org/64199#a64200
13:47:28 <Abraxas> not one that can be assigned a value, i meant
13:47:48 <bgamari> There seems to be some strange data family interactions here
13:48:07 <mauke> bgamari: because it overlaps
13:48:12 <mauke> why do you think it shouldn't overlap?
13:50:03 <bgamari> mauke: Because Hello a doesn't have a Generic.Base.Vector instance
13:50:07 <bgamari> mauke: as far as I know
13:50:10 <mauke> bgamari: and?
13:50:21 <mauke> it matches 'v a'
13:50:48 <bgamari> mauke: The constraint list isn't taken into account in deciding whether instances overlap?
13:50:55 <sipa> bgamari: no
13:50:57 <mauke> no, the constraint list is the function body
13:51:31 <bgamari> What do you mean by that?
13:51:44 <bgamari>       instance (Data.Vector.Generic.Base.Vector v a, Serialize a) => Serialize (v a)
13:51:47 <ClaudiusMaximus> bgamari: no, because someone could define an instance later
13:51:49 <mauke> "instance (Data.Vector.Generic.Base.Vector v a, Serialize a) => Serialize (v a)" is like "Serialize (v a) = (Data.Vector.Generic.Base.Vector v a, Serialize a)"
13:51:56 <bgamari> ClaudiusMaximus: ahh, point taken
13:51:57 <bgamari> damn
13:51:58 <mauke> where Serialize is some kind of pseudo-function
13:52:07 <zeratul> jfischoff: there?
13:52:17 <mauke> instances are selected by pattern matching on the LHS
13:52:20 <jfischoff> zeratul: yep
13:52:25 <bgamari> So what does one do in this case?
13:52:37 <zeratul> I have no idea how, but I got it working. Kinda scares me actually.
13:52:47 <zeratul> Could you perhaps check I did it correctly?
13:52:47 <jfischoff> haha, great
13:52:52 <jfischoff> sure
13:55:16 <jfischoff> zeratul: pastebin?
13:55:21 <zeratul> yeah
13:55:24 <zeratul> http://paste.pocoo.org/show/555213/
13:56:01 <bgamari> ClaudiusMaximus: So is there a way to define my instance?
13:56:03 <zeratul> In the small use case I tested it seemed to work, but I'm not really sure on all the mechanics really. Over my head.
13:57:38 <bgamari> Are the vector-binary instances too broad perhaps?
14:01:07 <edwardk> bgamari: that instance is way too large
14:01:32 <edwardk>      instance (Data.Vector.Generic.Base.Vector v a, Serialize a) => Serialize (WrappedVector v a)
14:01:34 <edwardk> would be fine
14:01:44 <edwardk> where you supply WrappedVector as a serializable type
14:01:58 <edwardk> and then make particular instances for each vector type directly if you want
14:04:21 <bgamari> edwardk: Thanks!
14:07:48 <jfischoff> zeratul: Looks fine, but I'm not an expert. Only used this new Generics stuff a few times. As long as you are not trying to 'get' a type that has a constructor without an argument you should be fine
14:08:12 <zeratul> Yeah, I wasn't quite sure yet how it should behave, thanks for the tip about Generics, seems really cool.
14:08:20 <zeratul> Even if I don't fully understand how it works yet :D
14:08:30 <bgamari> Has anyone looked at deriving vector Unbox instances with Generics?
14:08:37 <jfischoff> thats how I feel about all of haskell
14:09:31 <zeratul> I'm not the only one then
14:11:02 <tibbe> dcoutts: If bytestring would use criterion to run its benchmarks, and criterion depends on bytestring, how would that work?
14:11:49 <jedai|2> tibbe: probably a separate package bytestring-benchmarks, no ?
14:12:10 <tibbe> jedai|2: but still, that package would depend on criterion and bytestring
14:12:14 <tibbe> j
14:12:41 <jedai> tibbe: How would that be a problem ?
14:12:46 <mux> tibbe: well you don't really care if criterion is using some older version of bytestrin an the one you're benchmarking, do you?
14:13:25 <tibbe> mux: I don't but cabal does
14:13:40 <tibbe> it has started complaining about circular dependencies
14:14:41 <jedai> tibbe: there's no circular dependencies : bytestring -> criterion -> bytestring-benchmark <- bytestring
14:15:06 <nihtml> [A4
14:15:09 <nihtml> oops
14:15:11 <jedai> tibbe: Maybe the multiple version are confusing cabal ?
14:15:18 <mux> yeah I don't see why it should cause a problem either
14:16:00 <tibbe> jedai: I think so
14:16:04 <mux> tibbe: are you trying the new solver?
14:16:11 <tibbe> mux: no
14:16:36 <tibbe> mux: http://www.reddit.com/r/haskell/comments/q0a02/wanted_an_efficient_union_algorithm_for_hasharray/
14:16:44 <tibbe> someone is having issues
14:16:48 <mux> ok, I've been installing cabal-install from darcs so that it works with GHC 7.4.1 and it keeps advertising a new solver that may help
14:17:04 <tibbe> also, duncan checked in parts of test-framework in the bytestring repo
14:17:24 <tibbe> I wish we could have an official cabal-install release soon
14:21:10 * monochrom wants union-find too :)
14:23:18 <XexonixXexillion> is there any way to specify a specific (non-haskell) linker in a cabal package?
14:25:20 <monochrom> something about "ghc-options:" in the cabal file, and then "-pgml" of ghc
14:26:05 <niteria> sometime ago I was curious if union-find could be implemented in functional languages with similiar complexity because it looks like something inherently imperative, AFAIR I've found some papers and it turned out to be possible with FP too
14:26:35 <monochrom> beware that normally ghc calls up gcc for linking. your linker should take the same flags.
14:26:44 <c_wraith> well. The merge heuristic is trivial. in a functional language.
14:26:49 <c_wraith> path compression is a bit more interesting
14:26:50 <monochrom> e.g., usually /usr/bin/ld doesn't fit
14:30:10 <XexonixXexillion> monochrom: I was looking at that, but I couldn't find a way to pass arguments to the linker
14:30:35 <monochrom> oh, you want to hardcode some flags? I don't know how.
14:31:57 <XexonixXexillion> I've got a script which compiles my code (which is a mix of haskell and ada), but I'm just trying to find some sane way to package it
14:32:01 <c_wraith> just curry the linker
14:32:30 <monochrom> haha
14:39:40 <nyingen> @quote
14:39:40 <lambdabot> PeterOtten says: [re: design patterns] When most of your code does nothing in a pompous way that is a sure sign that you are heading in the wrong direction.
14:40:26 <Phlogistique> that sounds like critics of haskell.
14:40:29 <Phlogistique> @quote
14:40:29 <lambdabot> wagle says: <wagle> in the end all entities die. don't bother living. <lambdabot> thread killed
14:43:00 <nyingen> nah, I took that quote about design patterns to be referring to Java and co
14:43:16 <glguy> Is there some way to determine (portably) if the current OS accepts IPv4 connections on IPv6 [::] listening sockets?
14:51:45 <monochrom> haskell code usually does not fit "does nothing", so nevermind "does nothing in a pompous way"
14:53:39 <monochrom> whereas e.g. Java code is more likely to fit "does nothing in a pompous way" by setting up a huge class hierarchy and at the end only 10% of its code is actually executed
14:54:07 <gentleben> monochrom: a lot of that is cultural
14:54:16 <dolio> Need your enterprise ready booleans.
14:54:16 <zeratul> glguy: it's not so easy as it also depends on configuration of the OS. But one way would obviously be to listen on something in the ephemeral range and try to connect to yourself using an IPv4 socket, if there's a dual stack it should work, otherwise not.
14:54:39 <zeratul> But I don't know if any libraries do this already.
14:54:40 <hpc> enum {FALSE, TRUE, FILE_NOT_FOUND} // gotta have that
14:54:45 <zeratul> heh
14:54:51 <dolio> No no.
14:55:16 <monochrom> you can say, ideas behind some haskell code are pompous, e.g., they involve monads, arrows, cofunctors, whatever. but that's the ideas behind the code, not the code itself.
14:55:27 <dolio> I mean a complex system of proxies and stub classes where the ultimate result is to hook up to a class that does "boolean foo() { return true; }"
14:56:41 <zeratul> I think the most complicated java systems are far scarier, there are just many parts that 'appear' to do nothing. But in concert with the other 800,000 lines of code make it so dangerous to touch that you employ PhDs just to tell the programmers not to change anything.
14:57:17 <tomodo> ~/win 21
14:57:38 <gentleben> thats just lazy, there is nothing that a couple smart guys and a debugger can't figure out
15:03:48 <nyingen> zeratul: In our huge java project, we have plenty of "dead code" that everyone is afraid to remove
15:07:24 <zeratul> Quite common I fear
15:07:37 <nyingen> as for smart guys and a debugger, I'm fine with doing that if they pay me for it
15:07:55 <Eduard_Munteanu> nyingen: I wonder if that's more of a proprietary environment issue, rather than Java issue.
15:07:57 <Ralith> Are there any parser/serializer libs that can perform both actions based on a single invertible text<->data transform specification?
15:08:34 <Eduard_Munteanu> Or rather a project management issue.
15:08:53 <zeratul> That's another thing, sometimes you just don't have an easy way to get the system running in a live environment so you can debug it.
15:09:19 <nyingen> Eduard_Munteanu: could be, but any sufficiently large project is going to accumulate some cruft. [insert Java smear here]
15:10:27 <Eduard_Munteanu> Dunno, there are plenty of really large FOSS projects, and AFAICT they do remove code every now and then.
15:10:52 <magicman_> Ralith: Try boomerang.
15:10:57 <magicman_> @hackage boomerang
15:10:58 <lambdabot> http://hackage.haskell.org/package/boomerang
15:11:29 <Eduard_Munteanu> Erm, though FOSS/proprietary is a non-issue here, I rather mean small vs large development teams.
15:12:37 <Eduard_Munteanu> I guess a small team is going to have a hard time pruning dead code in a large codebase, especially if programmers come and go.
15:13:12 <nyingen> that is exactly the situation we are in
15:13:21 <nyingen> however, I can tell you that a lot of our issues are indeed java related
15:13:36 <nyingen> we would have many fewer problems if the lead developer weren't stuck in 1999
15:14:38 <Ralith> magicman: looks promising; any docs exist?
15:15:12 <Cale> What's this about a Toronto Haskell Users Meetup? Did anyone else see it on the Haskell reddit?
15:15:14 <magicman> Ralith: There's a simple example on the Text.Boomerang page. Other than that, I don't know.
15:15:24 <Ralith> that'll do
15:15:35 <Ralith> thanks
15:16:02 <Cale> http://thug1.eventbrite.com/ -- there's this, but not much more information about what it'll be
15:16:44 <Cale> monochrom: do you know anything about this? :)
15:17:12 <monochrom> I do not know. I distance myself from reddit.
15:19:07 <mekeor> monochrom: why?
15:19:29 <monochrom> because there is not enough reason to follow reddit
15:19:31 * mekeor doesn't use it either but also doesn't explicitly distance himself from reddit
15:19:39 <mekeor> monochrom: ah
15:20:26 <monochrom> oh, and actually, distasteful forum of flame wars and bikeshed colour arguments
15:20:39 <nyingen> monochrom: heh, you should see the rest of reddit
15:22:36 <monochrom> you can say, but no no, the haskell subreddit is ok. and I say, firstly I am not interested in every little haskell news there, and secondly it is still not immune from flame wars, just fewer outbreaks
15:23:08 <zeratul> Somehow such a format is rather susceptible to mass hysteria
15:23:33 <monochrom> if there is a big news (as opposed to small news), it will make its way to haskell-cafe, #haskell, LtU, basically everywhere
15:24:07 <nyingen> I get most of my haskell news from planet haskell
15:24:33 <monochrom> I understand that the small news are of value to people who actually have a job or self-employed on haskell. I am not one of them.
15:25:50 <monochrom> but this toronto meeting seems worth going. and hacklab.to is worth visiting.
15:26:06 <luite> ooh only 499998 tickets remaining
15:26:16 <monochrom> ok, I will be going, you can quote that on me. actually, remind me too. :)
15:29:40 <monochrom> it is not so much reddit per se but generally all successful (in popularity) forums. "avoid success at all costs" is a good mantra for good (constructive, productive) forums.
15:30:42 <Pseudonym> I'm beginning to wonder about that aphorism. I think it's more accurate to redefine success.
15:31:01 <monochrom> one aspect of reddit does have my respect and praise. finally there are forum programmers who understand... trees!
15:31:02 <Pseudonym> There's the nerd definition of success and the PHB definition of success.
15:31:22 <Pseudonym> Trees?
15:31:36 <Pseudonym> Oh, you mean the data structure.
15:31:41 * Pseudonym thought you meant plants
15:31:41 <glguy> Pseudonym: comment replies stored in tree format, perhaps
15:31:58 <monochrom> yes, comments threaded by trees
15:32:18 <Pseudonym> I'm trying to understand cows at the moment, hence my confusion.
15:32:24 <ion> “One aspect of NNTP does have my respect and praise. Finally there are forum programmers who understand trees.”
15:33:12 <monochrom> I mean, how many years since the first web forum was coded up?
15:34:05 <monochrom> that period surely felt like back in the 1950s when only 1% of the programmers learned trees from school
15:34:58 <ClaudiusMaximus> forums should be a directed acyclic graph, need merges to consolidate relevant information
15:35:19 <monochrom> yeah, DAG will take 2 more decades
15:35:37 <monochrom> especially since it didn't happen for usenet either
15:35:37 <Pseudonym> How would you represent circular arguments, then?
15:35:52 <glguy> we need more dimensions
15:36:35 <Pseudonym> Actually graphs with cycles would be handy for stopping endless threads where the same issues are discussed ad nausaeum.
15:36:41 <c_wraith> most usenet arguments are already hyperbolic
15:36:55 <monochrom> hahaha
15:37:35 <Pseudonym> I've lost count of the number of times I've said "please see my previous response" in a forum.
15:38:27 <glguy> I've dreamed of an IRC interface where you could reply to specific messages, and pull certain messages aside, pinning them waiting for a response, collapsing a conversation to ignore it, etc
15:39:02 <glguy> and perhaps seeing an interleaved display by default
15:39:13 <ion> Yeah, threaded IRC would be neat.
15:39:37 <nyingen> sounds like an ajax-based web forum
15:39:50 <hpc> sounds like disqus :P
15:40:09 <nyingen> you could probably make an irc/web gateway along those lines
15:40:21 <nand`> glguy: Only problem is how would you know which reply belongs to which conversation
15:40:30 <glguy> nand: you'd need client support from everyone
15:40:36 <nand`> oh
15:40:37 <glguy> I think
15:40:38 <nand`> So it's not IRC
15:40:51 <glguy> yeah, probably wouldn't be directly compatible
15:40:55 * geekosaur thinks this sounds vaguely like zephyr or maybe jwgc, and won't fly without pervasive topic support
15:40:58 <nand`> TIRC? (threaded IRC)
15:41:07 <nyingen> IRC'
15:41:14 <nyingen> we are haskellers after all.
15:41:15 <nand`> nyingen: that sounds reasonable
15:41:21 <ion> IRCʹ
15:41:31 <monochrom> IRC 98
15:41:33 <ion> Whoops, i mean IRC′
15:42:02 <nand`> IRC_ for the () variant
15:42:06 <hpc> it needs a web 2.0 name
15:42:10 <hpc> "twitter on rails"
15:42:13 <glguy> IRCr?
15:42:22 <nand`> IRC--
15:42:31 <cmccann> how about an STM-like implementation, transactional IRC
15:42:37 <hpc> and just for fun, change the line limit from 512 chars to 140
15:42:45 <cmccann> I want the ability to rollback and entire conversation if it goes somewhere stupid
15:43:00 <nand`> How about continuation-based IRC
15:43:19 <cmccann> ok
15:43:26 <zeratul> cmccann: Only messages worth reading are commited?
15:43:35 <cmccann> zeratul, yes
15:43:50 <zeratul> Sounds ideal
15:45:19 <nand`> IRC based on git; you can rebase conversations to later points in time
15:45:53 <nand`> In order to have them play out differently as new knowledge is gained
15:46:33 <nand`> (cmccann will be in charge of resolving merge conflicts)
15:46:43 <cmccann> oh nooooo :[
15:47:25 <monochrom> my self-fulfilling prophecy is fulfilled again. the toronto haskell meeting is posted on haskell-cafe too. reddit still has 0 pros, 1 con for me.
15:47:35 <rwbarton> that's edwardk's project i thought
15:49:09 * geekosaur still not convinced he's missing anything except the tragedy of the commons by giving all of reddit a miss
15:49:12 <edwardk> rwbarton: which?
15:49:17 <nand`> I just realized #haskell isn't purely functional; you can feed the same question to it and you'll get 10 different responses (each of them assuming different context)
15:49:22 <nyingen> geekosaur: do you like 4chan?
15:49:26 <nyingen> if not, you won't like reddit
15:49:28 <rwbarton> merging
15:49:35 <MostAwesomeDude> I like 4chan but I don't like reddit.
15:49:37 <edwardk> rwbarton: ah the monad
15:50:01 <edwardk> rwbarton: https://github.com/ekmett/revisions
15:50:06 <geekosaur> 4chan hasn't any pretensions of being useful...
15:50:27 <ion> nand: Nah, it’s just a pure list representing nondeterminism.
15:50:40 <Pseudonym> ion: Except that you don't always get all answers.
15:50:58 <Pseudonym> It's more like committed choice nondeterminism with a bit of randomised algorithm thrown in.
15:52:29 <cmccann> geekosaur, reddit is in many ways a marginally nicer medium for discussion than email or IRC, and is in the same ways more conducive to wasting time on counterproductive discussions
15:53:08 <nand`> ion: #haskell :: [Users] -> Question -> [Response]; or maybe :: [Users] -> [Question -> Response]
15:53:16 <nand`> the latter would be a nice applicative
15:53:45 <cmccann> it's like a really clusmy reimplementation of usenet, except less reliable, and more prone to ridiculous bandwagoning because of the "voting" thing
16:03:22 <yezariaely> is there a technical reason why there is no cabal uninstall or did no one just implement it unitl now?
16:04:02 <Pseudonym> Who would want to uninstall a Haskell package?
16:04:21 <yezariaely> Pseudonym: me ;-)
16:04:24 <hpc> me :
16:04:28 <ben> I suspect you're eventually looking for ghc-pkg unregister
16:04:30 <hpc> :P
16:04:44 <ben> But I can't answer the actual question either ;)
16:04:50 <yezariaely> ben: No, I know that command. just wondering
16:04:53 <glguy> yeah, just unregister it and then guess which files it installed and remove those :)
16:05:02 <hpc> lol
16:05:12 <yezariaely> glguy: orcle turing machine?
16:05:15 <yezariaely> +a
16:05:16 <monochrom> how to uninstall a package: http://www.vex.net/~trebla/haskell/sicp.xhtml#remove
16:05:23 <nand`> even make files tend to have an uninstall target
16:05:31 <ben> I think the workflow for uninstalling a given package is to nuke all the packages and then reinstall all the ones you need to build whatever you're working on
16:05:36 <benmachine> yezariaely: the reason why there is no cabal uninstall is because cabal itself doesn't track installed packages, ghc-pkg does
16:05:44 <benmachine> ben: that's kinda overkill
16:05:50 <benmachine> you *can* just find and delete the files
16:06:02 <benmachine> yezariaely: anyway basically the upshot is cabal has no way of recording which files it records at the moment
16:06:08 <ben> Yeah, but who knows what other packages that ends up breaking
16:06:25 <benmachine> ben: if it didn't break when you unregistered it, it probably won't break when you delete it
16:07:15 <yezariaely> benmachine: ah sure. I basically know how to uninstall/unregister packages manually. I was just wondering. Thanks for the explanation!
16:07:32 <benmachine> yezariaely: I think the general consensus is "it would be nice, but also lots of work"
16:08:04 <ben> I guess I'd be happy if cabal didn't break stuff when installing packages, I don't entirely trust it to get uninstalling right.
16:08:25 <benmachine> ben: I do believe there has been progress in that department
16:08:53 <thoughtpolice> ben: just use something like hsenv or cabal-dev, imo. it alleviates those fears greatly
16:09:18 <Saizan> ghc-pkg describe foo shows there the files for foo are
16:09:22 <Saizan> *where
16:09:23 <ben> benmachine: Yeah, true. thoughtpolice: I'm trying to use cabal-dev now and it's made it less painful, but still seems awfully fragile.
16:09:26 <thoughtpolice> i've rapidly come to the conclusion that hsenv is superior, but that's just me. cabal-dev works quite well itself
16:09:45 <ben> is hsenv the one that also stashes ghc locally?
16:10:54 <thoughtpolice> it can do that if you give it a custom ghc tarball (i test head builds that way,) but if you just invoke it normally, it actually makes copies of all the pristine global packages for your ghc install and isolates them
16:11:07 <benmachine> cabal-dev outright didn't work for me a couple of times
16:11:17 <thoughtpolice> it then gives you a shell script which points all the tools to a local package-db, and updates your $PATH to point to all the new tools
16:11:22 <benmachine> "this doesn't want to install and I don't want to tell you why"
16:11:33 <ben> huh
16:11:39 <thoughtpolice> the reason i mainly like it is because it doesn't change the workflow
16:11:49 <thoughtpolice> you just activate the environment and use ghc-pkg, ghci, cabal etc normally
16:12:36 <thoughtpolice> so you're always using the same tools. your shell environment just silently points them to a local package db. i use it to test stuff on lots of different GHCs, it's way better than prefixing 'make install' somewhere
16:17:01 <benmachine> yezariaely: fyi http://hackage.haskell.org/trac/hackage/ticket/234
16:19:28 <Saizan> for these sub-environment i think it'd be nice to have a cabal install flag that prevents it from upgrading or reinstalling existing packages, or maybe that if it has to it should also update all the other ones in the package db, the idea is that you're going to use them all at once somewhere otherwise you wouldn't have installed them in the current env
16:20:36 <mekeor> @src read
16:20:36 <lambdabot> read s = either error id (readEither s)
16:20:50 <mekeor> @src readEither
16:20:51 <lambdabot> Source not found. Listen, broccoli brains, I don't have time to listen to this trash.
16:21:31 <nand`> That's.. harsh
16:21:53 <mekeor> how is read implemented internally?
16:22:17 <mekeor> and how is e.g. `Integer' an instance of `Read' ?
16:23:44 <nand`> Here's the source of readEither fwiw http://hackage.haskell.org/packages/archive/base/latest/doc/html/src/Text-Read.html#read
16:44:58 <edwardk> preflex: xseen bos
16:44:58 <preflex>  bos was last seen on freenode/#ghc 8 days, 2 hours, 52 minutes and 58 seconds ago, saying: dcoutts: ping
16:47:04 <edwardk> @tell bos any chance you could steal the beta distribution from my order-statistics package for statistics? I feel kind of funny maintaining that in another package, and you did all the hard work in math-functions, anyways. ;)
16:47:04 <lambdabot> Consider it noted.
16:53:35 <`Jake`> (Offtopic) Just wandering if someone here knows that problem: I got a new Keyboard yesterday and since a few minutes, some keys don't work anymore (left Ctrl, dash, equal sign)
16:53:40 <`Jake`> wondering*
16:53:50 <otters> o_O
16:55:04 <`Jake`> Oh, and Delete
16:56:02 <`Jake`> That's weird...
16:56:37 <Saizan> maybe your keyboard has something like a weirder block num
16:56:41 <`Jake`> Hey, it works again!
16:56:46 <`Jake`> That's soo weird
16:57:35 <`Jake`> I switched between to workspaces in ubuntu => didn't work anymore, I tried to close the xev command with ctrl c => works again
16:58:27 <`Jake`> I even tried to reboot with Windows and it didn't work...
17:34:13 <zachk> hoogle needs an old deepseq and deepseq needs an old array, how do I build hoogle ? http://hpaste.org/64204 <- for details
17:36:44 <cmccann> zachk, try unpacking it, modifying the deps to use the new versions, and installing the modified local copy
17:37:22 <cmccann> I've rarely found an upper bound that actually meant something
17:37:31 <zachk> thank you cmccann, :-D
17:38:11 * cmccann does that all the time when something major upgrades and some pacakges are slow to catch up
17:38:42 <cmccann> I usually bump the version for my modifications by something small, so that it's distinct but won't conflict with an actual new version
17:38:47 * Saizan found lots of lack of upper bounds that meant a lot
17:39:48 <cmccann> I think I've had more problems from old packages with no upper bound set than I have with altering dependencies that do have upper bounds
17:39:57 <cmccann> oh well
17:50:23 <edwardk> cmccann: i go through about 80 upper bound replacements every year ;)
17:50:31 <edwardk> cmccann: its all a matter of perspective i guess =)
17:50:52 <MiggyX> *yawn* back :)
17:51:36 <MiggyX> cmccann, I don't suppose you had a chance to look at that code in the end did you? :)
17:51:42 <cmccann> edwardk, I just get tired of hacking a bunch of stuff to get things building
17:51:55 <cmccann> MiggyX, sorry, ended up being really busy today
17:51:59 <edwardk> *nods*
17:52:08 <cmccann> maybe in another hour or two
17:52:20 <edwardk> koninkje_away: poking you about the probability smoothing dsl ;)
17:52:21 <MiggyX> cmccann, no worries, any help is much appreciated :)
18:00:50 <nand`> > let x = 1+1+1+undefined in x < 2
18:00:50 <lambdabot>   *Exception: Prelude.undefined
18:00:53 <nand`> aw
18:01:04 <nand`> oh right, Int not Nat
18:01:06 <nand`> nvm
18:01:30 <nand`> (or rather forall a. Num a => a, but that can still be negative)
18:02:04 <nand`> > let x = fix (1+) in x < 2
18:02:08 <lambdabot>   mueval-core: Time limit exceeded
18:04:36 <thlorenz> how would I go about storing data in memory for later reuse (e.g., if I had a server and I read a file once on startup and keep serving clients with data contained in it)?
18:06:01 <hpc> thlorenz: probably by using the linux kernel ;)
18:06:40 <hpc> thlorenz: more seriously, every OS is going to have some automatic thing it does to hold onto files in RAM
18:07:24 <thlorenz> hpc: not trying to hold a whole file, but rather sampling data from it (e.g., every other byte) and then keeping that around for future use
18:07:45 <thlorenz> am I looking into the right thing with TVar?
18:07:55 <Saizan> nope
18:08:15 <thlorenz> Saizan what should I look into instead?
18:08:22 <Saizan> (unless you have to read and modify it concurrently)
18:08:34 <thlorenz> Saizan it will be readonly
18:08:54 <Saizan> thlorenz: ok, so you just have to pass it as an argument to the functions that need it
18:09:18 <Saizan> thlorenz: you can hide the plumbing with the Reader monad if it gets annoying
18:09:34 <Saizan> (though adding a monad just for that can be annoying too)
18:10:38 <thlorenz> so I'd pull it out of the IO Monad (e.g., the ByteStrings,) sample it and then pass that to a function that listens for clients requesting data?
18:10:38 <Saizan> some like stuff like data-ivar, write-once variables which you can read from pure code, but that has its problems too
18:10:49 <Saizan> yeah
18:11:05 <thlorenz> ok, that helps, thanks
18:19:39 <MiggyX> I'm hoping to write a "converter" to take parsed JSON from Aeson and convert it to BSON for use with the MongoDB driver. At the moment I'm having to call eval() on the server side and, well, that sucks for performance. I'm not really sure where to start, so could use some pointers in the right direction :)
18:23:11 <Saizan> MiggyX: write a function Data.Aeson.Value -> Data.Bson.Document
18:24:56 <MiggyX> Saizan, I'm kinda new to Haskell... I'm guessing the conversion (from other stuff I've read) basically involves recursing through the JSON data and building up the BSON, ultimately returning the new BSON document
18:25:42 <Saizan> yep
18:25:55 <Saizan> that's what i'd guess too
18:40:47 <MiggyX> Saizan, thanks :)
18:43:39 <MiggyX> last question, where would such a module live, i.e. what should I call it?
19:07:19 <wy_> hello~
19:07:51 <sp> hi wy_
19:08:14 <wy_> hi sp
19:08:43 <wy_> acfoltzer: hey Adam?
19:10:13 <wy_> I have a question... Can Haskell do pattern matching with labels? Say I want to take just one field out of a large type containing many labelled fields?
19:11:12 <geekosaur> foo (Record { field = localBinding }) = ...
19:11:52 <geekosaur> plus some extensions for various shortcuts
19:12:23 <wy_> hmm... I didn't know that. Can I also use pattern matching in anonymous functions?
19:12:46 <cmccann> you can't have multiple patterns
19:12:47 <geekosaur> you get to use exactly one pattern
19:13:08 <cmccann> but stuff like (\(x, y) -> f x y) is fine
19:13:27 <cmccann> you can use case inside a lambda if you really want
19:13:34 <cmccann> but you probably don't want
19:14:10 <wy_> I see. So I guess there is just one general pattern binder in the implementation?
19:15:06 <wy_> Yep. It doesn't seem to make much sense using pattern matching for lambdas
19:15:40 <wy_> but in a theoretical sense, this feels beautiful :-)
19:15:54 <geekosaur> well, it does, just nobody seems to have found decent syntax that doesn't cause other problems
19:16:04 <wy_> because then we can say "lambda the ultimate pattern matcher" :-)
19:16:46 <wy_> geekosaur: right, the syntax seems to be awkward
19:17:12 <geekosaur> there's a mailing list thread from a coupleyears back where people tried to hash out a decent syntax and failed
19:17:45 <wy_> geekosaur: I guess layout syntax makes it even harder
19:17:45 * cmccann prefers using deconstructor functions like "maybe" or "either" for such things inside lambdas
19:18:12 <cmccann> and if the type is too complicated for a function like that to work, then you probably shouldn't be doing case analysis on it in a lambda anyway
19:18:46 <geekosaur> wy_, more that it rapidly becomes easier to just \x -> case x of ...
19:18:50 <wy_> geekosaur: poor python folks can only use one-liners in lambda, I guess that's because of python's syntax
19:18:56 <geekosaur> (i,e. manually desugar it0
19:19:48 <wy_> geekosaur: but this one has a "different" feel. If pattern matching is on lambda, I can feel that it is an intersection type ...
19:21:12 <wy_> but any way, that's just a hypothetical thinking
19:24:48 <Cale> http://math.andrej.com/2011/12/07/hott-equivalences/
19:29:30 <quintessence> is there a library like Data.Dynamic that gives you back some kind of coercion?  I want to discharge GADT equality obligations when the cast works
19:32:54 <nand`> unsafeCoerce?
19:34:32 <Veinor> I need to hack on the data structures of dropbox-sdk
19:34:51 <Veinor> something to do this weekend, maybe
19:37:28 <nand`> It's undecidable whether an (imperative) function ever returns, right?
19:37:40 <nand`> s/function/procedure/
19:38:48 <Veinor> In general, yeah
19:39:07 <Veinor> (and assuming you have infinite memory)
19:39:38 <nand`> I was just thinking about whether it would be possible to do compile time garbage collection in general. My reasoning is that since it's undecidable whether a procedure ever ends, and therefore whether a scope is ever left, this should be impossible to achieve with 100% accuracy
19:42:52 <nand`> but I'm not sure if I may be barking up the wrong tree here (since it might not be necessary to know whether a procedure returns if you can make assumptions about it instead, ie. this piece of memory should be cleaned assuming it *does* return)
19:43:27 <parcs`> how can even manual memory management fix that?
19:47:20 <nand`> parcs`: Not sure what you mean
19:48:28 <quintessence> nand`: Run-time GC has to be conservative like this too.  If you keep pointers to things around but are never going to dereference them (e.g. because you call a procedure that will never return), the GC doesn't collect them.
19:50:35 <nand`> quintessence: That still raises the question of “if it can't be perfect, how good can it be?” in regards to compile-time memory management
19:50:50 <mysticc> @hoogle Data.Bitmap
19:50:51 <lambdabot> package bitmap
19:50:51 <lambdabot> package bitmap-opengl
19:50:51 <lambdabot> package bitmaps
19:51:26 <mysticc> @hoogle Data.Bitmap.Pure
19:51:27 <lambdabot> package pure-fft
19:51:27 <lambdabot> package pure-priority-queue
19:51:27 <lambdabot> package pure-priority-queue-tests
19:51:40 <mysticc> @hoogle Data.Bitmap.IO
19:51:41 <lambdabot> package io-capture
19:51:41 <lambdabot> package io-reactive
19:51:41 <lambdabot> package io-storage
19:52:33 <parcs`> nand`: never mind. i just misunderstood what you said
19:53:13 <bgamari> If I have a Functor contained inside of another Functor, is there a general way to invert the order of the functors (e.g Functor1 (Functor2 a) -> Functor2 (Functor1 a)
19:53:24 <bgamari> or does this require more structure?
19:53:53 <bgamari> I feel like I read something along these lines in the typeclassopedia at one point, but I've failed to find the reference
19:53:54 <cmccann> :t traverse
19:53:55 <lambdabot> Not in scope: `traverse'
19:53:58 <cmccann> urgh
19:54:02 <bgamari> ahh
19:54:13 <cmccann> :t T.sequenceA
19:54:14 <lambdabot> Couldn't find qualified module.
19:54:19 <cmccann> whatever
19:54:22 <cmccann> you get the point :P
19:54:22 <bgamari> yep
19:55:11 <cmccann> you need a Traversable on the outside and an Applicative on the inside
19:56:32 <bgamari> sure. Thanks!
20:07:10 <parcs`> nand`: do you mean something like "int x; do_stuff_with(x); /* x should be deallocated here */ nonterminating(); do_more_stuff_with(x);"
20:07:37 <nand`> parcs`: exactly
20:08:41 <parcs`> nand`: i think that's sort of a non-issue because if it is known to whomever wrote the code that nonterminating() is non-terminating, then that should be the last thing done in the scope
20:08:46 <nand`> that aside, I wonder how the situation changes if you remove the last do_more_stuff_with(x)
20:08:54 <nand`> since relying on nontermination is a bit artificial
20:09:19 <nand`> and if nontermination is ever explicitly programmed I doubt there would be any such call after it
20:09:33 <nand`> ..
20:09:35 <nand`> yeah
20:09:38 * nand` replied before reading what parcs` wrote
20:10:09 <Eduard_Munteanu> You probably want to know the lifetime more "precisely" than whether it terminates or not.
20:11:50 <nand`> Consider also pointer operations that depend on external input, there's no simple solution here; the entire algorithm or at least some algorithm analogous to it would have to be encoded in the conditions deciding whether or not to free something or not
20:14:10 <parcs`> what languages support CTGC? the only one i know of is mercury
20:14:53 <JoeyA> Just wondering: does catchSTM catch asynchronous exceptions?
20:14:56 <quintessence> Region systems just make the programmer prove an upper bound on liveness, they don't guarantee to collect things as early as possible
20:15:42 <nand`> parcs`: Didn't Cyclone as well?
20:22:43 <nand`> quintessence: Well, if you change the problem statement from “guaranteed to collect as early as possible” to “guaranteed to collect before the program terminates” then the problem is trivial: just free everything just before a procedure returns. So there must be some in-between for the border between decidable and undecidable
20:23:14 <nand`> Or at the very least a form of transition
20:28:51 <quintessence> Yeah, in practice runtimes try to collect things as early as they can manage.  You could use dataflow analysis at compile time to determine when local variables become dead and then null out the reference so they'll be collected, and I suspect most JVMs do this.
20:32:46 <quintessence> Parts of closures can become dead too: if y = True in the closed-over environment, then (\x -> if y then x else some_huge_structure) holds on to some_big_structure (in any implementation I know of) even though it would be safe to free it
20:34:19 <nand`> Wouldn't that just store the AST for the expression until it's actually reduced?
20:34:59 <nand`> unless some_huge_structure is closed too
20:35:34 <quintessence> yeah, I meant just some variable free in that expression that's the only remaining reference to something big
20:36:17 <Eduard_Munteanu> TBH, I don't think there's a reasonable way to deal away with manual management in those situations. Maybe you could prove its correctness instead.
20:36:35 <Eduard_Munteanu> I mean in situations where it's worth doing manual management.
20:36:38 <nand`> Eduard_Munteanu: You mean like detecting leaks?
20:36:57 <nand`> Then again, that's the opposite
20:37:12 <nand`> Detecting the absence of leaks*
20:37:26 <Eduard_Munteanu> Ah, I'm not sure how you can prove that though.
20:37:46 <bgamari> Hmm, what happened to (<>) = mappend?
20:38:03 <nand`> Overall there are just too many possibilities, especially when you include external input
20:38:04 <Eduard_Munteanu> Maybe prove there's an asymptotic upper bound on the lifetime of certain objects.
20:38:17 <bgamari> I seem to remember this alias existing and Pandoc seems to require it, causing the build to fail on 7.4.1
20:38:45 <nand`> Eduard_Munteanu: That might be a reasonable starting point
20:38:48 <Eduard_Munteanu> Proving correctness wrt to memory allocation errors (double frees, using unallocated memory etc.) should be easier I think.
20:38:49 <jfischoff> when your using monad transformers, can you reuse the combinators of the underlying monad? In my case the underlying monad is the QuickCheck Gen.
20:38:59 <nand`> @quote mappend operator
20:38:59 <lambdabot> No quotes for this person. There are some things that I just don't know.
20:39:13 <nand`> Hmm, how did that command work again
20:39:23 <Eduard_Munteanu> @quote mappend.operator
20:39:23 <lambdabot> elliott says: |\/|/-\|-|-|=|\||} is my preferred mappend operator
20:39:33 <nand`> Oh right, regex
20:39:34 <bgamari> heh
20:40:09 <bgamari> does this mean I'm making up (<>) ever existing?
20:40:26 <otters> @quote mappend
20:40:27 <lambdabot> elliott says: |\/|/-\|-|-|=|\||} is my preferred mappend operator
20:40:27 <JoeyA> > 3 <> 5
20:40:28 <lambdabot>   No instance for (GHC.Num.Num Text.PrettyPrint.HughesPJ.Doc)
20:40:28 <lambdabot>    arising from...
20:40:33 <otters> @quote mappend
20:40:33 <lambdabot> elliott says: |\/|/-\|-|-|=|\||} is my preferred mappend operator
20:40:35 <otters> is that the only one?
20:40:36 <otters> damn
20:40:39 <rwbarton> it exists in the minds of some people on a Haskell mailing list
20:40:42 <JoeyA> :i <>
20:40:42 <otters> where is all my mappend related humor
20:41:08 <bgamari> hmm, interesting, Text.Pandoc.Builder should define it
20:41:16 <nand`> What ever happened to (++) = mappend?
20:41:37 <bgamari> Presumably the same thing that happened to fmap == map
20:42:06 <bgamari> Hmm, interesting
20:42:24 <bgamari> pandoc seems to think the <> is defined in Data.Monoid as of base-4.5.0
20:42:42 <nand`> I think this can work if garbage collection is done at compile time
20:42:44 <nand`> oops
20:42:48 <nand`> http://hackage.haskell.org/packages/archive/base/latest/doc/html/src/Data-Monoid.html#Monoid
20:42:50 <nand`> It seems to be
20:43:09 <bgamari> yep, indeed it does
20:44:17 <bgamari> yet my ghc (7.4.1 post release snapshot) build's Data.Monoid (base-4.5.0.0) doesn't have it
20:44:20 <bgamari> how mysterious
20:45:39 <bgamari> Uh oh
20:51:02 <edwardk> nand`: it used to be mplus, not mappend
20:51:54 <edwardk> bgamari: Data.Monoid exports (<>) in 7.4.1 -- i had to fix a whole bunch of places as a result
20:52:18 <bgamari> edwardk: Yep, looks like this one was my bad
20:52:29 <bgamari> forgot to sync-all pull on my development branch
20:52:57 <bgamari> edwardk: pandoc-types checks for base>=4.5.0 as it should
21:00:19 <nyingen> @quote
21:00:19 <lambdabot> JonathanShapiro says: We are now preparing a more sensible surface syntax, whereupon we will receive rotten egg and tomato complaints from the LISP community.
21:01:00 <tgeeky_> rotten egg and tomato? you can't even craft that into a (rotten) sandwhich or something. what a waste
21:03:27 <nyingen> mm, eggs
21:03:29 <nyingen> @quote
21:03:29 <lambdabot> Conor says: We could all sit in a long line with laptops, and talk to each other on #haskell
21:03:41 <nyingen> is that what a haskell meetup is like?
21:06:49 <amindfv> nyingen: there is also food.
21:11:19 <lispy> ?quote
21:11:19 <lambdabot> NihilistDandy says: The best part of Haskell is that 80% of module names can be turned into clever blog titles.
21:11:46 <lispy> Is he referring to dons blog?
21:11:49 <nyingen> heh
21:12:08 <nyingen> "Conduits: Malarkey? Or Effective Way?"
21:12:26 <nand`> libmalarkey
21:13:59 <lispy> undefined symbol `shenannigans' when linking libmalarkey.a
21:17:54 <nyingen> @quote
21:17:54 <lambdabot> v_ says: C++ is a pitfall-based language
21:18:01 <otters> @quote
21:18:01 <lambdabot> DuncanCoutts says: I’m slightly embarrassed to admit that I spent three days at the Haskell Hackathon and wrote no Haskell code, only POSIX shell script and M4 autoconf macros!
21:18:47 <otters> soooo
21:19:02 <otters> m4 is a tool for producing autoconf scripts which produce configure scripts which configure something
21:19:05 <otters> and produce a makefile
21:19:07 <otters> okay
21:19:12 <otters> what do we have that can produce m4 macros?
21:19:18 <nyingen> lisp
21:19:44 <nyingen> sorry, knee-jerk reaction. I saw 'macro' and my fingers spasmed out 'lisp'
21:19:53 <adnauseam> lol
21:20:09 <nand`> now somebody has to go implement a list-based m4 macro generation tool
21:20:11 <nand`> lisp*
21:20:23 <nand`> and it thus incidentally has to be based on lists
21:20:26 <otters> I think I'll work on programmatically generating lisp
21:20:35 <nyingen> I hear the only way to do that is with lisp
21:20:54 <otters> okay
21:20:59 <otters> then I will create a single dot of infinitely compressed matter
21:21:12 <nyingen> http://secretgeek.net/lisp_truth.asp
21:22:33 <lispy> omg
21:22:43 <nyingen> "By the time my bus had made it two blocks I'd written some simple lisp macros that were so powerful they made lisp completely obsolete and replaced it with a new language. Fortunately, that new language was also called lisp."
21:23:09 <Ralith> macros do that.
21:23:18 <otters> but how can you ensure that the macros will be evaluated properly
21:24:33 <lispy> Lots of testing
21:24:40 <nyingen> nah, I just use scheme
21:25:14 <lispy> strong static typing is what made me go with haskell though
21:25:19 <lispy> As nice as lisp is
21:25:41 <nyingen> agreed
21:26:08 <nyingen> but I recently had a need for embedding a powerful scripting language. I used guile scheme, and I was pleased
21:26:39 <lispy> I think it's time for bed
21:26:50 <lispy> Write good code; I'll check when I get back
21:27:50 <otters> for all my scripting embedding needs I use Lua
21:27:57 <otters> that said I've only had one need and it's not done yet
21:33:26 <nyingen> lua seems alright
21:34:00 <jeremya> oh, dons isn't here
21:34:01 <jeremya> how strange
21:34:45 <otters> lua's great
21:34:56 <jeremya> so are otters :D
21:34:57 <quintessence> It looks really easy to embed in C / (C `mappend`)
21:35:04 <otters> yeah
21:35:09 <otters> that's why I chose this username
21:35:17 <otters> because...I like otters
21:35:46 <nyingen> I like FP, and I had some scheme experience, so I used scheme despite the damn parentheses
21:36:19 <nyingen> in the course of researching lua, I read an article the Lua devs wrote regarding how lua is implemented, which was interesting
21:36:28 <jeremya> http://i.imgur.com/oVVQe.jpg <3
21:37:40 <otters> ^ exactly
21:38:32 <wolvii> hey guys I'm new to IRC
21:39:52 <timbod> Hi
21:40:05 <wolvii> hey how's it going
21:40:13 <timbod> Any expertise on type families about?
21:40:22 <timbod> I'm well by the way.
21:40:26 <wolvii> no
21:40:55 <c_wraith> timbod: I'm not an expert, but I have some minimal understanding of them.  Is that enough?
21:41:14 <wolvii> enough for what?
21:41:30 <c_wraith> to help with whatever he's running into
21:41:35 <timbod> Maybe. I don't understand whats wrong with this...
21:43:00 <hpaste> Timbod pasted “type families” at http://hpaste.org/64209
21:43:41 <timbod> It's a minimal example from something I'm working on...
21:44:13 <rwbarton> that error message is pretty terrible but basically it can't decide what instance to use
21:44:38 <timbod> Why does it not use the single instance that's there?
21:44:49 <rwbarton> it doesn't know you want the instance for HNil because there could be another instance HSequence T where type Inp T = HNil
21:44:51 <laufer> @pl \x->x
21:44:51 <lambdabot> id
21:44:59 <c_wraith> yeah
21:45:06 <c_wraith> make it a data family
21:45:08 <rwbarton> if you append ":: IO HNil" it should work
21:45:16 <laufer> @pl \x xs -> x : (xs ++ [x])
21:45:16 <lambdabot> liftM2 (.) (:) (flip (++) . return)
21:45:28 <c_wraith> I think making it a data family would also work there...
21:45:34 <c_wraith> Because it forces injectivity
21:45:35 <rwbarton> yes
21:45:49 <c_wraith> ...  If that's a property you want
21:46:02 <timbod> Ah... I see. It's because it's at the ghci top level.
21:46:18 <quintessence> Well, the problem is that (Inp t) doesn't determine t
21:46:38 <timbod> ie this works: (hsequence HNil :: IO JNill)
21:46:46 <timbod> ie this works: (hsequence HNil :: IO HNil)
21:46:57 <c_wraith> Ah, so it's not injective
21:47:00 <c_wraith> Well, then, yes
21:47:11 <timbod> what do you mean by injective?
21:47:19 <rwbarton> right because now it knows that it should use the instance l where IO l = IO HNil, which forces l = HNil
21:47:20 <c_wraith> It needs to be able to infer the return type to work, then
21:47:22 <laufer> @pl \x xs -> x : (xs ++ [x])
21:47:22 <lambdabot> liftM2 (.) (:) (flip (++) . return)
21:47:52 <c_wraith> injective means that Inp l uniquely defines l
21:48:20 <rwbarton> Basically the way it decides which instance to use is that it tries to unify what it knows about the type that hSequence is used at with the type of hSequence as defined in the type class
21:48:21 <quintessence> and therefore that you can figure out which instance of HSequence to use just by knowing what type Inp l is
21:48:54 <timbod> Got it ... thank's all for you help.
21:50:37 <nand`> “The proper way to greet a fellow lisper is just a tiny nod of the chin, and about a tenth of a wink from your left eye, then point at your tin foil hat.” <- this is golden
21:56:20 <nyingen> nand`: yeah, there are some great quips in there
21:57:07 <quintessence> <interactive>:1:4: My brain just exploded.
21:57:09 <nand`> “In Haskell this is a built-in feature” hehe
21:57:21 <nand`> quintessence: existentials?
21:57:38 <quintessence> GADTs, but pretty much
21:57:56 <nand`> I got it when mixing GADTs and existentials
21:58:09 <nand`> I've refactored the offending code to not use existentials
21:59:05 <quintessence> I was trying to do a let SomeConstructor ... = blah at the toplevel, so I can easily avoid the message
21:59:09 <quintessence> I was just amused by it
21:59:48 <Ralith> o.O
21:59:51 <Ralith> just what does that message mean
22:03:38 <nand`> Ralith: there are a few lines after it explaining what it means and its context
22:03:47 <Ralith> ah.
22:03:54 <c_wraith> and, usually, how to fix it
22:03:56 <dolio> You're not allowed to match on a GADT or existential irrefutably.
22:04:04 <c_wraith> at least if it was an existential in a let
22:04:05 <Ralith> irrefutably?
22:04:10 <c_wraith> with a let
22:04:14 <nand`> work-around is to use a case
22:04:17 <dolio> Or a ~
22:04:17 <c_wraith> Well, with a Let and a constructor
22:04:33 <c_wraith> > let Right foo = Left () in foo
22:04:34 <lambdabot>   *Exception: <interactive>:3:4-22: Irrefutable pattern failed for pattern Da...
22:04:56 <nand`> > case Left () of Right foo -> foo
22:04:57 <lambdabot>   *Exception: <interactive>:(3,0)-(4,21): Non-exhaustive patterns in case
22:05:02 <Ralith> huh, I didn't know you could do that sort of thing in the first place.
22:05:13 <Ralith> seems unsafe
22:05:26 <c_wraith> it's certainly incomplete
22:05:38 <c_wraith> But sometimes you know it's fine...  Like if a type has only one constructor
22:05:46 <c_wraith> > let (a, b) = (1,2) in b
22:05:47 <lambdabot>   2
22:06:01 <c_wraith> (,) is the only constructor, so you know it's fine
22:32:23 <nyingen> @quote
22:32:23 <lambdabot> VirginiaCurry says: "You know, Haskell actually never liked the name Haskell." -- Virgina Curry (Haskell B. Curry's widow)
22:42:02 <nand`> It seems like an odd name to me, that being said; I've never heard anything quite like it
22:42:21 <tikhonjelvis> Haskell, you mean?
22:42:23 <nand`> I couldn't even begin to guess his nationality based on the name alone
22:42:35 <nand`> tikhonjelvis: yes
22:42:52 <tikhonjelvis> Hmm, it's associated with England in my mind, but I have no idea why.
22:42:53 <nand`> Maybe it's just not in my generation
22:43:06 <nyingen> Two of my pet rats are named Haskell and Alonzo
22:43:43 <nand`> nyingen: would have to be pet mice for the analogy to hold :)
22:44:02 <ddarius> @google Haskell, TX
22:44:04 <lambdabot> http://en.wikipedia.org/wiki/Haskell,_Texas
22:44:04 <lambdabot> Title: Haskell, Texas - Wikipedia, the free encyclopedia
22:44:39 <nand`> Is that where the secret Haskell headquarters are located?
22:49:39 <tikhonjelvis> Hmm, how does Haskell deal with parsing operators efficiently?
22:50:27 <Cale> What do you mean by that?
22:50:28 <edwardk> tikhonjelvis: as in the parser for ghc itself? or in parsec or what?
22:50:40 <tikhonjelvis> I'm wondering more about GHC.
22:50:51 <edwardk> ghc parses everything associated to one side, then re-associates once its parsed the file
22:51:06 <edwardk> that way it can deal with the fact that fixity declarations can occur after they are used
22:51:13 <tikhonjelvis> ah
22:51:35 <edwardk> its actually a colossal pain ;)
22:51:42 <tikhonjelvis> Yeah, I would imagine
22:51:45 <tikhonjelvis> which is why I asked
22:52:01 <edwardk> sadly haskell 98/2011 basically requires it
22:52:02 <tikhonjelvis> It was also interesting because it turned out Scala "cheats"
22:52:09 <edwardk> yeah
22:52:26 <adnauseam> ello guys - fromIntegral - does it have any relation to the Integral of calculus ? i'm just trying to wrap my head around the concepts here
22:52:39 <edwardk> they just came up with a horribly baroque set of fixity rules to do the right thing for the stock operators
22:52:41 <tikhonjelvis> Integral as in integers rather than calculus
22:53:01 <tikhonjelvis> edwardk: Yeah, I know. I was expecting something interesting when I asked a friend, but it wasn't.
22:53:02 <adnauseam> hmm, so it's a different definition ?
22:53:08 <edwardk> and they have weird side conditions like how you can't have dangling operators start a line
22:53:27 <edwardk> so you always have to foo +\n    bar rather than foo\n + bar
22:53:36 <tikhonjelvis> The word "integral" can also be an adjective verion of "integer".
22:53:41 <srhb> adnauseam: An integral type is one of the integers
22:53:46 <edwardk> so space/newlines aren't significant, except when they are
22:53:46 <adnauseam> simply integer? but then what's the difference between Integer and Integral. i know already that Int and Integer differ by range
22:53:56 <adnauseam> oh i see
22:53:58 <edwardk> which is gloriously consistent, just like the rest of scala
22:54:00 <srhb> adnauseam: Integral is a class of types, integer is a type
22:54:04 <tikhonjelvis> Integral is an adjective--it means the type behaves like an integer.
22:54:06 <adnauseam> so Integers and Ints are Integrals
22:54:10 <srhb> adnauseam: Int is also Integral
22:54:11 <tikhonjelvis> yeah
22:54:13 <srhb> adnauseam: Right
22:54:17 <adnauseam> sweet
22:54:19 <adnauseam> now i get it
22:54:21 <adnauseam> thanks guys
22:54:24 <tikhonjelvis> edwardk: Heh, languages like that are fun :)
22:54:29 <tikhonjelvis> Like JavaScript...
22:54:38 <edwardk> Int, Word, Integer, Word64, Word32, Int64, Int32, CInt, etc. are all instances of Integral
22:54:47 <edwardk> Integral is a class, Integer is a type
22:55:02 <adnauseam> oh
22:55:11 <adnauseam> damn, haskell is deceptively broad
22:55:28 <edwardk> you have no idea ;)
22:55:35 <adnauseam> can a Word128 be created from Integral ?
22:55:48 <edwardk> sure. you can make up your own instances
22:55:51 <tikhonjelvis> Erm, it's more like Word128 would be part of the Integral class.
22:56:01 <tikhonjelvis> rather than being "created from Integral", that is
22:56:15 <adnauseam> yeah that's what i meant ;p still new
22:56:27 <adnauseam> better get on with the reading! =}
22:57:03 <tikhonjelvis> Which book are you reading?
22:57:04 <edwardk> data Word128 = Word {-# UNPACK #-} !Word64 {-# UNPACK #-} !Word64 -- then you'd have to make an instance, deal with the carry bits yourself, or get them through ffi/foreign prims, etc.
22:57:10 <edwardk> but its quite doable
22:57:30 <srhb> Or import it and do 123123 :: Word128
22:58:04 <adnauseam> i'm reading learn you a haskell
22:58:10 <tikhonjelvis> ah, that's a good choice
22:58:35 <tikhonjelvis> I remember there was one guy trying to learn the language by reading the Haskell 98 report a while back.
22:58:39 <adnauseam> edwardk: so you took 2 word64 and put them together ?
22:58:48 <srhb> edwardk: Do you know any place where that method with the unpacks is discussed? I'd like to know more.
22:58:56 <adnauseam> ouch
22:59:00 <edwardk> http://hackage.haskell.org/packages/archive/Crypto/4.2.0/doc/html/Data-LargeWord.html#t:Word128 has instances for something like that that probably just work
22:59:18 <edwardk> srhb: the UNPACK pragma is discussed in the ghc manual
22:59:25 <srhb> edwardk: Alright, thanks.
22:59:46 <ddarius> The Haskell Report is fairly readable.
23:00:19 <edwardk> bah
23:00:20 <adnauseam> is it a good source of beginners though ?
23:00:32 <tikhonjelvis> I do not think it is a good resource for beginners.
23:00:43 <srhb> Not compared to the other literature out there at least, which is quite good, often.
23:00:48 <edwardk> the LargeWord Num instance there is only (+) and fromInteger. lame
23:00:53 <tikhonjelvis> That said, it's great for learning the details when you've got a hang of the language though.
23:03:22 <adnauseam> im no way near getting the hang of things ;p
23:03:41 <adnauseam> we'll see once i am finished with learn you a haskell and write a few trivial tools
23:03:49 <adnauseam> maybe after there'll be hope ;p
23:04:27 <nand`> adnauseam: when you get finished with LYAH is where the *real* learning begins ;)
23:04:31 <tikhonjelvis> I'm sure  you'll manage soon enough.
23:05:31 * adnauseam pours more coffee into his mug 
23:05:37 <adnauseam> tis gon` be a long one.
23:05:55 <tikhonjelvis> Sleep is for the weak anyhow.
23:07:47 <tikhonjelvis> What do you guys think of unicode variable names?
23:08:07 <nand`> tikhonjelvis: As long as you don't export them in libraries
23:08:46 <tikhonjelvis> Hmm, that's tempting just to mess with people
23:09:18 <nand`> Other than that I can only say “be reasonable”. If you can anticipate that somebody might run into difficulties because of it, and you have a sane alternative that isn't awfully horrifying, weigh your options well
23:09:36 <ddarius> There are packages dedicated no nothing but unicode symbols.
23:09:58 <tikhonjelvis> nand`: That's simultaneously good advice and completely useless :)
23:10:33 <adnauseam> unicode var names are redundant
23:10:40 <tikhonjelvis> redundant?
23:10:51 <adnauseam> useless
23:11:04 <adnauseam> they'll create more issues with compatibility than they'd solve
23:11:07 <tikhonjelvis> eh
23:11:15 <adnauseam> i study in germany
23:11:21 <adnauseam> some code is written in german
23:11:40 <adnauseam> i tend to install only english environments
23:11:45 <kir> Hello. I have read Russian book about Haskell and found it awful. Now I am reading 'Learn Haskell for Great Good'. Is it a good book?
23:11:53 <tikhonjelvis> yeah
23:11:58 <adnauseam> yes kir it is good - im reading it too
23:12:09 <tikhonjelvis> Pretty pictures! What more do you need?
23:12:19 <adnauseam> haha =}
23:13:39 <tikhonjelvis> adnauseam: I'm thinking more about math symbols than letters in any particular locale.
23:15:15 <kir> adnauseam, I haven't read it all but first chapters, for example, type inference is quit brief
23:15:35 <kir> adnauseam, *quite
23:15:55 <tikhonjelvis> Is there that much to say about type inference?
23:16:01 <tikhonjelvis> That is, if you're not implementing it, I mean.
23:16:15 <adnauseam> tikh - hmm, i see what you mean. that could be possible if it remained backwards compatible
23:16:46 <adnauseam> considering the keyboard layout most of us use - the symbols will need new bindings || seperate key pad
23:16:56 <tikhonjelvis> adnauseam: I think unicode support is part of the standard.
23:17:05 <tikhonjelvis> Also, just use a good editor (Emacs).
23:17:14 <adnauseam> <3 vim
23:17:18 <tikhonjelvis> E.g. \tau is not much harder to type than tau and you get τ.
23:17:24 <nand`> I actually read LYAH without pictures :(
23:17:26 <nand`> I felt cheated
23:17:33 <edwardk> tikhonjelvis: i think they are a large part of why i don't use agda for day to day programming
23:17:36 <nand`> (When I found out that it did have such glorious drawings)
23:17:37 <adnauseam> pictures are nice :o
23:17:51 <tikhonjelvis> Yeah! The monster picture in the list chapter was my favorite.
23:18:03 <adnauseam> best worm
23:18:11 <nand`> tikhonjelvis: do you know if vim has something like this?
23:18:11 <tikhonjelvis> edwardk: Also APL? :)
23:18:25 <tikhonjelvis> nand`: Nope. That is, I don't know.
23:18:36 <edwardk> i kinda liked APL, the problem was that all the stuff you made up didn't feel APL'ish though ;)
23:19:04 <companion_cube> there is also J as a crazy array language
23:19:05 <tikhonjelvis> Eh, I just saw a talk online that mentioned that as the reason APL wasn't super popular.
23:19:32 <edwardk> tikhonjelvis: the old guy steele talk?
23:19:35 <tikhonjelvis> yeah
23:19:46 <tikhonjelvis> I really liked it
23:20:10 <edwardk> tikhonjelvis: yeah. i'm fond of sending folks to it. =)
23:20:19 <kir> tikhonjelvis, but one must understand it's mechanism to use consciously.
23:20:33 <tikhonjelvis> kir: Its mechanism?
23:20:50 <edwardk> its kind of quaint the list of things he thought java needed to reach programmer nirvana ;)
23:21:02 <tikhonjelvis> And amusing that Java still doesn't have all of them.
23:21:07 <edwardk> yep
23:21:16 <tikhonjelvis> Well, amusing now that I don't have to use Java any more :)
23:21:18 <edwardk> and how many others we take for granted in the haskelll world
23:21:33 <kir> tikhonjelvis, yes, I mean, how it works.
23:21:48 <tikhonjelvis> kir: Erm, I'm in too many conversations at once. How what works?
23:22:05 <yitz> tikhonjelvis: hmm? \tau give me tau. ^X 8 enter tau enter gives me τ.
23:22:17 <yitz> \tau gives me \tau i mean
23:22:19 <tikhonjelvis> Do C-\ and enter TeX.
23:22:27 <kir> tikhonjelvis, type inference.
23:22:31 <tikhonjelvis> ah
23:22:55 <yitz> c-\ gives me my alternate input method, for hebrew in my case
23:22:59 <tikhonjelvis> ah
23:23:04 <tikhonjelvis> Well, you can turn TeX mode on too.
23:23:12 <tikhonjelvis> C-x RET C-\
23:23:28 <yitz> ok. interesting.
23:23:40 <tikhonjelvis> TeX mode is great for programming. Also #haskell :)
23:23:44 <yitz> C-x 8 RET is also nice though
23:23:53 <tikhonjelvis> Yeah
23:25:05 <tikhonjelvis> Ironically, TeX input mode is *not* good for TeX.
23:25:20 <kir> tikhonjelvis, yes, that's true.
23:25:52 <kir> tikhonjelvis, as for me I use auctex when edit latex documents.
23:26:00 <tikhonjelvis> Yeah, me too.
23:26:30 <kir> tikhonjelvis, under Linux or Windows?
23:26:35 <tikhonjelvis> I'm on Linux
23:26:41 <srhb> Hum.. Is that method of inputting special symbols in ERC documented somewhere?
23:26:43 <srhb> It seems very clever.
23:26:48 <tikhonjelvis> It's not just in ERC
23:26:51 <srhb> Oh.
23:26:55 <tikhonjelvis> It's for Emacs proper
23:27:06 <srhb> I'm in ERC now, so I should be able to do it?
23:27:09 <tikhonjelvis> I think it's in the manual (C-h r) under input, or something like that.
23:27:19 <tikhonjelvis> Yeah, press C-\ and enter TeX
23:27:46 <srhb> Ah, I have an input method set already, I guess that's the conflict
23:27:53 <kir> tikhonjelvis, me too
23:27:56 <srhb> Wonder why that's not a ring instead of a toggle.
23:28:01 <tikhonjelvis> In that case, as I said before, you can use C-x RET C-\
23:28:15 <tikhonjelvis> Yeah, I have no idea about why it's implemented this way either.
23:28:23 <srhb> I dropped because I accidentally did M-x TeX-mode in my ERC-buffer. No comments. :-)
23:28:43 <kir> tikhonjelvis, and what distributive do you use?
23:28:46 <tikhonjelvis> Fedora
23:28:56 <tikhonjelvis> It's great for KDE and pretty good for Haskell too.
23:29:10 <kir> tikhonjelvis, mine is Slackware
23:29:24 <srhb> Wow, this is great. I might even replace my danish-postfix with this fully.
23:29:37 <tikhonjelvis> ⌣̈
23:29:51 <kir> tikhonjelvis, and for Haskell you use GHC, don't you?
23:29:55 <tikhonjelvis> yeah
23:30:00 <tikhonjelvis> I think almost everybody uses GHC
23:30:45 <Sgeo> Non-haskellers don't use GHC
23:30:56 <tikhonjelvis> Okay, everybody *important* ;)
23:31:29 <kir> tikhonjelvis, from the environment recommended in the '... for Great Good?'
23:31:56 <kir> tikhonjelvis, or from Fedora rpm's?
23:32:13 <nand`> I suggest just installing the Haskell Platform, it's likely that Fedora has a package for this platform in particular
23:32:26 <tikhonjelvis> I'm using the platfrom from the repos, yeah.
23:32:40 <tikhonjelvis> I keep on meaning to build 7.4, but I'm too lazy
23:32:42 <kir> nand`, yes, I mean Platform
23:33:13 <nand`> I do use the haskell platform but I built 7.4 and the latest cabal on top of it :)
23:33:25 <kir> tikhonjelvis, do you participate in some open source project?
23:33:32 <tikhonjelvis> not really
23:33:39 <kir> tikhonjelvis, I'm thinking of it
23:33:46 <tikhonjelvis> I have a bunch of my stuff on GitHub, but nobody uses any of it :)
23:33:58 <kir> tikhonjelvis, improving skills need real projects
23:34:00 <tikhonjelvis> I'm just a disaffected college student.
23:34:24 <kir> tikhonjelvis, I'm a student too
23:34:37 <tikhonjelvis> Eh, I'm probably going to do an internship over the summer. That's real enough for me.
23:35:09 <kir> tikhonjelvis, what is internship?
23:35:23 <tikhonjelvis> Job over the summer for students.
23:35:37 <kir> tikhonjelvis, I'm from Russia, we have a little different education
23:35:51 <tikhonjelvis> Heh, I was born in Russia, but now I'm in California.
23:35:55 <srhb> Slightly different education but lots more vodka!
23:36:03 <kir> tikhonjelvis, have been working almost for 4 years in MSTU
23:36:17 <kir> tikhonjelvis, since 2nd course of institute
23:36:23 <kir> tikhonjelvis, really? In Russia?
23:36:41 <kir> srhb, sure
23:36:45 <tikhonjelvis> Yeah. But I moved to Canada when I was very young.
23:37:30 <companion_cube> tikhonjelvis: where in california?
23:37:38 <tikhonjelvis> Bay area
23:37:46 <tikhonjelvis> near San Francisco
23:37:50 <kir> tikhonjelvis, and from what city do you come from?
23:37:58 <tikhonjelvis> St. Petersburg
23:38:02 <companion_cube> tikhonjelvis: the place to be! which city?
23:38:07 <tikhonjelvis> Berkeley
23:38:10 <kir> tikhonjelvis, I'm from Moscow
23:38:23 <companion_cube> ok
23:38:29 * companion_cube in palo alto
23:38:32 <gentleben> tikhonjelvis: going to bayhac?
23:38:37 <tikhonjelvis> probably
23:38:44 <kir> tikhonjelvis, Berkeley  has a wonderful institute
23:38:54 <tikhonjelvis> So does Palo Alto
23:39:11 <adnauseam> hrm - trying to create a function thats acts on lists with size of one
23:39:16 <tikhonjelvis> I lived in Menlo Park before college
23:39:29 <srhb> adnauseam: foo [x] = ...
23:39:53 <srhb> adnauseam: Of course you should consider what should happen for other cases.
23:39:54 <adnauseam> but that will work of lists of different sizes ;p
23:39:55 <kir> I have been programming on C and C++ on QNX and decided to widen my knowledge
23:40:07 <adnauseam> i got the case for the empty case
23:40:07 <srhb> adnauseam: No, that case will only match on lists of size one
23:40:12 <adnauseam> oh
23:40:14 <kir> In fact, on Lisp too
23:40:14 <adnauseam> hmm
23:40:20 <tikhonjelvis> Lisp is great fun
23:40:29 <tikhonjelvis> My first CS class here was in Scheme. It was awesome.
23:40:41 <kir> Haskell is much more pretty
23:40:47 <adnauseam> sweet
23:40:52 <kir> Scheme is wonderful
23:40:54 <kir> I like it
23:40:55 <adnauseam> didn't realize it was that trivial
23:41:02 <srhb> adnauseam: Patterns do that to you.
23:41:13 <adnauseam> i'm trying to write a "neck" function that does what snd does
23:41:15 <tikhonjelvis> kir: Have you looked at SICP?
23:41:18 <srhb> adnauseam: Soon you will not want to relinquish this power. *rubs hands*
23:41:25 <kir> tikhonjelvis, yes
23:41:28 <srhb> adnauseam: Neck?
23:41:35 <adnauseam> yeah - just like head
23:41:42 <adnauseam> but a neck ;p 2nd item
23:41:46 <srhb> adnauseam: Of course.
23:41:49 <kir> tikhonjelvis, I have been reading it two years ago
23:41:58 <adnauseam> soon there, soon there
23:42:21 <srhb> adnauseam: So something like foo (head:neck:_) = Just neck
23:42:37 <kir> tikhonjelvis, I don't know anybody writing on Scheme who haven't read it
23:42:54 <adnauseam> oh - heh your solution is much more elegant than mine ;p
23:43:03 <adnauseam> i was going to do a recursion ;p
23:43:05 <kir> tikhonjelvis, but in fact for my little project I used CL
23:43:10 <srhb> adnauseam: Patterns, patterns... :-)
23:43:20 <adnauseam> reading that chapter now :o)
23:43:23 <tikhonjelvis> CL is good too. I haven't used it much myself though.
23:43:51 <srhb> adnauseam: But what you should do if you're thinking recursion is make a fail-safe version of (!!) with Maybe
23:43:58 <kir> tikhonjelvis, a little C parser to find inheritance and delegation
23:44:01 <tikhonjelvis> My biggest lisp is probably elisp. I don't know if that's a good thing or a bad thing.
23:44:17 <srhb> adnauseam: Since pattern matching doesn't really work well for lists of length ?, that's where recursion fits in.
23:44:38 <kir> tikhonjelvis, to substitute delegation and inheritance with classes definitions
23:44:53 <adnauseam> i haven't gotten to Maybe yet
23:44:55 <adnauseam> i'll check it out now
23:45:00 <adnauseam> so far i've got this
23:45:01 <adnauseam> neck :: [a] -> a
23:45:02 <adnauseam> neck [] = error "Can't call neck. Empty list."
23:45:02 <adnauseam> neck [a] = a
23:45:04 <adnauseam> neck [a:b:_] = b
23:45:18 <tikhonjelvis> neck [a] = a seems weird
23:45:22 <srhb> adnauseam: Firstly you can use _ to match otherwise
23:45:34 <adnauseam> well what should i do if the list only has 1 item
23:45:37 <adnauseam> i could just fail
23:45:44 <srhb> adnauseam: Nothing
23:45:48 <tikhonjelvis> If you're going to have an error for [], have an error there too.
23:45:48 <adnauseam> hmm
23:45:49 <srhb> adnauseam: That's where Maybe comes into play
23:46:03 <srhb> adnauseam: You wrap your result in "Just results" and if there's no result, "Nothing"
23:46:05 <tikhonjelvis> Or you could use Maybe to do error handling. But the same principle applies: be consistent.
23:46:41 <adnauseam> hmm
23:46:42 <srhb> adnauseam: So you get neck (_:x:_) = Just x; neck _ = Nothing
23:46:47 <adnauseam> let me fiddle with this for abit
23:48:38 <albel727> (_:x:_)
23:48:52 * albel727 probably the only one finding this funny.
23:49:01 <osa1> what is ! before types in data constructors for?
23:49:07 <tikhonjelvis> It makes them strict.
23:49:32 <adnauseam> seems my definition is wrong
23:49:45 <osa1> tikhonjelvis: what is the name of it? I want to see it's docs
23:49:49 <Phlogistique> albel727: I'm not sure if that's a crying face or a ass with hemoroids.
23:49:56 <tikhonjelvis> BangPatterns, I think
23:50:09 <albel727> yeah. that's confusing to me as well.
23:50:26 <tikhonjelvis> Am I the only one to see a TIE fighter?
23:50:43 <srhb> If your Haskell has no TIE fighters, you're doing it wrong.
23:50:55 <tikhonjelvis> Yeah, lets one-up the perl spaceship operator :)
23:51:09 <ChristianS> tikhonjelvis: you can always use ! in constructors, but with the BangPatterns extension, you can use it in pattern matches too (or so i think)
23:51:22 <albel727> hmm. tie fighter is more like  |-o-|
23:51:23 <tikhonjelvis> ah
23:51:35 <srhb> Yeah, the other one is more like a TIE bomber.
23:52:03 <srhb> This is srs business, don't get the spaceship operators wrong.
23:52:50 * hackagebot xml-conduit 0.5.3 - Pure-Haskell utilities for dealing with XML with the conduit package.  http://hackage.haskell.org/package/xml-conduit-0.5.3 (MichaelSnoyman)
23:52:52 * hackagebot shakespeare-css 0.10.7.1 - Stick your haskell variables into css at compile time.  http://hackage.haskell.org/package/shakespeare-css-0.10.7.1 (MichaelSnoyman)
23:52:56 <albel727> hmm. now that you mention it. there is some resemblance, indeed.
23:54:12 <adnauseam> are single : not allowed in definitions ?>
23:54:31 <tikhonjelvis> You have to have something on either side.
23:54:47 <tikhonjelvis> So _:_ or a:b or even 1:2 could be fine, but just : would not fly.
23:54:50 <adnauseam> hr, i think my problem is different now
23:54:52 <adnauseam> i get this
23:54:53 <tikhonjelvis> Well, 1:2 won't either
23:54:56 <tikhonjelvis> 1:[2]
23:54:56 <adnauseam>     Couldn't match type `a' with `[a]'
23:54:57 <adnauseam>       `a' is a rigid type variable bound by
23:54:57 <adnauseam>           the type signature for neck :: [a] -> a at baby.hs:24:1
23:54:57 <adnauseam>     In the pattern: x : y : _
23:54:57 <adnauseam>     In the pattern: [x : y : _]
23:54:59 <adnauseam>     In an equation for `neck': neck [x : y : _] = y
23:55:15 <srhb> adnauseam: adnauseam That's a list of lists
23:55:19 <tikhonjelvis> You probably want parens instead of []
23:55:25 <adnauseam> oh
23:55:26 <tikhonjelvis> So (x : y : _)
23:55:41 <tikhonjelvis> Because your notation means it's a list with the x : y : _ pattern *inside*.
23:55:41 <adnauseam> damn
23:55:48 <srhb> adnauseam: otherwise you're matching inside a list already. [a:[]] matches, say [[1]] or [['a']]
23:55:49 <adnauseam> oh!
23:56:10 <adnauseam> it takes the definition and expects it in each of the variables ?
23:56:20 <adnauseam> a list of type vs a tupel of the type
23:56:27 <adnauseam> [] = multiple elements
23:56:35 <srhb> () are just used for groupin here unless you use a comma
23:56:35 <adnauseam> () = 1 entity
23:56:40 <srhb> (a,b) matches a tuple
23:56:41 <tikhonjelvis> [] means a list. a:[b] also means a list.
23:56:43 <adnauseam> , i understand - trying it now
23:56:49 <tikhonjelvis> a:b:c:[] is also a list
23:56:52 <srhb> (a:b:[]) matches a two-element list
23:57:04 <adnauseam> yep, compiled ;p
23:57:13 <adnauseam> thanks guys ;p
23:57:21 <tikhonjelvis> progress!
23:58:00 <adnauseam> one excruciating step after the other ;p
23:58:36 <srhb> adnauseam: Patterns are really about visualizing what you want to match, at least to me. It's like a template you put over the arguments of your function, and the holes in it describe what things to pick out.
23:59:35 <QinGW> #src (<|>)
23:59:45 <QinGW> @src (<|>)
23:59:45 <lambdabot> Source not found. That's something I cannot allow to happen.
23:59:45 <adnauseam> right now im trying them out - it's all pretty new. i'm used to regex but this is a bit different. i basically swinging my bat trying to hit the haskell peniata :o)
23:59:50 <adnauseam> in the dark
23:59:59 <srhb> adnauseam: You'll get there.
