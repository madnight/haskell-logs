00:01:10 <arbn> wuttf: If you do, I'll buy you a couple beers or coffees (your choice). :)
00:01:37 <wuttf> arbn: Beer ;)
00:02:31 <wuttf> arbn: Can I find you in this channel? Maybe we could brainstorm and I implement
00:02:55 <arbn> wuttf: Yeah. I'm almost always idling here.
00:03:44 <wuttf> arbn: Thats neat. Just give me a week because I couldn't even wrap my head around the state monad yet :D
00:04:07 <arbn> wuttf: Aha. Are you an immigrant from Ruby-land, or something?
00:04:13 <art2art>  ))
00:04:20 <art2art> hi all
00:05:20 <wuttf> arbn: my life was mainly ASM -> C -> C++ -> PHP -> Node.JS -> Go -> Now haskell, with some pascal and whatnot sprinkled in
00:06:14 <arbn> wuttf: Aha. Interesting.
00:06:14 <shachaf> I like the part where Node.JS is a language.
00:06:24 <elliott> shachaf: Just like "GHC Haskell"
00:06:33 <wuttf> shachaf: Nitpick more.
00:06:35 <pqmodn> which part?
00:07:01 <shachaf> wuttf: Don't mind if I do.
00:07:23 <wuttf> Did I state that the type of that list was [Language], that was a conclusion you draw :D
00:08:07 <arbn> wuttf: Hetereogeneous collections are taboo in here. ;)
00:08:25 <wuttf> I started with cracking and writing games when I was young but I was hired mainly by startups so thats why I changed my direction :-D
00:08:34 <arbn> Heterogeneous*
00:08:52 <wuttf> arbn: That was an algebraic data type of Language | Framework
00:09:14 <wuttf> I can construct a list out of that, can't I?
00:09:26 <arbn> wuttf: Yep. That works.
00:09:57 <wuttf> Ohh yeah and I have done 1-2 years of frontend JS unfortunately :S
00:11:07 <arbn> JavaScript isn't so bad. I like it more than Java or C++.
00:11:19 <wuttf> Nothing is worse than developing desktop like apps for the web which must work on all browsers. Not even with jQuery
00:11:31 <x-Suriv> arbn WTH!
00:11:35 <x-Suriv> <arbn> JavaScript isn't so bad. I like it more than Java or C++.
00:11:39 * x-Suriv makes sure he's sober
00:11:41 <x-Suriv> check
00:11:47 <arbn> x-Suriv: Sorry. Is that heresy in here?
00:11:49 * x-Suriv makes sure he isnt hallucinating.
00:11:50 <x-Suriv> Nope
00:11:53 * arbn prepares for stoning.
00:12:00 <x-Suriv> Arbn: I dunno, but personally I dont believe it lol
00:12:02 <wuttf> Trolol :D
00:12:02 <x-Suriv> :D
00:12:09 <wuttf> Let the language flame war begin
00:12:15 <x-Suriv> wutff: no flame war :D
00:12:22 <x-Suriv> I just hate JS :P
00:12:41 <wuttf> gtg guys have fun
00:12:43 <x-Suriv> I would..would rather code in prolog for the rest of my life then touch it :D
00:13:04 <simpson> usable(prolog).
00:13:05 <arbn> x-Suriv: I think of JavaScript like Scheme, except that I need to pretend that 70% of the language doesn't exist. Still easier to do FP in JS than in Java or C++.
00:13:36 <startling> "I need to pretend that 70% of the language doesn't exist" <- so exactly like scheme?
00:13:42 <startling> ;)
00:13:56 <x-Suriv> hahaha
00:14:42 * startling calls arbn with current continuation
00:14:44 <arbn> isTroll(startling)
00:14:45 <arbn> :P
00:15:57 <arbn> Scheme was my first programming language, and I like it. Not as much as I like Haskell, but still.
00:16:20 <x-Suriv> oh wow so you started with functional
00:17:55 <arbn> Fairly recently, I learned about Owl Lisp, which is a purely functional Scheme. I still need to check it out.
00:20:05 <neutrino_> hi
00:20:13 <arbn> Hi neutrino_
00:21:12 <neutrino_> hi arbn
00:27:34 <neutrino_> arbn: what do you use haskell for?
00:29:26 <arbn> neutrino_: Lately, I've been writing everything except the GUI layer of a desktop application for publishing. In the past, I've used it for writing web apps, and I'll be doing another web app again soon.
00:29:32 <sw2wolf> BTW, has prolog ugly syntax as erlang ?
00:30:33 <simpson> sw2wolf: Erlang's syntax is inspired by Prolog.
00:31:21 <sw2wolf> then what's the primary area for prolog ?
00:31:50 <sw2wolf> x-Suriv just mentioned it
00:31:50 <simpson> Logic and stuff.
00:32:16 <sw2wolf> thx
00:32:28 <neutrino_> is a desktop application for publishing like a desktop publishing application?
00:33:06 <neutrino_> DTP is a fairly well defined field, that's why i'm asking
00:33:55 <arbn> neutrino_: Well, this is an application publishing digital artifacts, rather than print artifacts.
00:34:13 <arbn> application for publishing*
00:34:14 <neutrino_> i'm not sure what that means
00:34:32 <neutrino_> are you making like a blog writing app or something?
00:35:06 <arbn> neutrino_: Say, if you wanted to make an interactive comic book, or a magazine, or an ebook, and then distribute it digitally, this application would make it easier.
00:35:44 <neutrino_> is it for creating, for authoring, or distribution?
00:36:06 <neutrino_> that sounds pretty cool imo
00:36:41 <arbn> neutrino_: All of the above, actually. We'll be launching an alpha test and looking for funding in the coming months.
00:37:27 <neutrino_> what will your content compile down to? html+js?
00:38:45 <arbn> neutrino_: Yeah. Basically EPUB. Zipped HTML+CSS+JS with XML metadata.
00:39:35 <neutrino_> cool
00:39:57 <neutrino_> i didn't know epub was html/css/js
00:40:48 <arbn> neutrino_: Yep. Feed an EPUB into an unzipper sometime, and look at the contents. Very human-readable stuff.
00:41:36 <neutrino_> that is cool
00:41:50 <neutrino_> what about containing movies? are you able to do that too?
00:42:08 <arbn> neutrino_: Yeah. That's actually in the EPUB standard.
00:42:20 <neutrino_> neat
00:42:37 <arbn> neutrino_: Apple w/ iBooks already uses EPUB for stuff like that.
00:42:55 <neutrino_> i think you can do something really nice with this
00:43:13 <neutrino_> i've worked with some people that did something like that with flash
00:44:58 <arbn> neutrino_: Yeah. For self-publishing comic books, Flash has kind of been the standard in the past.
00:45:25 <neutrino_> those guys were mostly about making online magazines
00:49:12 <neutrino_> but yeah, html and js only got good enough recently to replace everything you could have wanted to do in flash
00:49:31 <neutrino_> hmm.. hey guys, i have a question about stm
00:50:27 <neutrino_> could one somehow extend the stm runner (atomically) so that you could make transactional database queries inside STM?
00:51:09 <neutrino_> would it be possible to do that in just haskell, or would you need to change the parts of the rts that deal with stm?
00:57:54 <arbn> I suppose most Haskellers sleep at this time.
00:58:05 <neutrino_> yeah
00:58:20 <neutrino_> it's morning in europe and late night in america
00:58:26 <arbn> We don't quite have international success yet.
00:58:39 <neutrino_> i guess haskell isn't too popular in russia
00:58:43 <neutrino_> that's all
00:58:53 <statusfailed> Bangkok here :D
00:58:59 <statusfailed> but only temporarily :p
00:59:09 <neutrino_> what are you doing in bk?
00:59:21 <Hafydd> The ladyboys, obviously.
00:59:36 <neutrino_> Hafydd: shh, the grownups are talking
00:59:57 <statusfailed> mostly just chillaxin'
01:00:30 <neutrino_> cool
01:00:44 <neutrino_> what do you use haskell for?
01:01:15 <statusfailed> mostly for fun
01:01:28 <statusfailed> but i'm trying to get a job with it :)
01:01:30 <neutrino_> ahh
01:01:46 <neutrino_> where do you live if bangkok is temporary?
01:02:35 <statusfailed> well, temporary as in several months temporary
01:02:51 <statusfailed> I came from the UK though
01:02:59 <neutrino_> cool
01:03:06 <statusfailed> where are you?
01:03:14 <neutrino_> which parts? i used to live in london for a longer while
01:03:26 <neutrino_> i moved down to germany several years back
01:03:39 <statusfailed> Cambridge
01:03:45 <statusfailed> Oh aye, whereabouts?
01:03:56 <neutrino_> south east
01:04:01 <neutrino_> cambridge is nice
01:04:04 <statusfailed> it's lovely
01:04:09 <neutrino_> had a minor stopover there
01:04:11 <statusfailed> can get a bit quiet though ;)
01:04:24 <neutrino_> i liked hanging out in jesus green
01:04:57 <statusfailed> Ah yeah :)
01:05:02 <statusfailed> there's a nice sandwich shop near there
01:05:06 <statusfailed> What were you doing in Cambridge?
01:05:16 <neutrino_> just hanging out really
01:05:21 <neutrino_> :)
01:05:22 <statusfailed> good place for it :)
01:05:32 <neutrino_> yep
01:06:16 <neutrino_> think about starting a haskell user group in bangkok
01:06:22 <neutrino_> it just might work :)
01:06:54 <statusfailed> haha, that would be awesome
01:06:56 <statusfailed> I wonder if there is one
01:07:08 <statusfailed> nope :p
01:07:14 <neutrino_> it's a way to popularize
01:07:28 <neutrino_> hang a poster at the local university or something
01:08:03 <neutrino_> @hoogle QSem
01:08:03 <lambdabot> Control.Concurrent.QSem module Control.Concurrent.QSem
01:08:04 <lambdabot> Control.Concurrent.QSemN module Control.Concurrent.QSemN
01:08:04 <lambdabot> Control.Concurrent.QSem data QSem
01:08:17 <neutrino_> @hackage qsem
01:08:17 <lambdabot> http://hackage.haskell.org/package/qsem
01:11:49 <statusfailed> Well i'm planning to leave in about a month, but otherwise that would be a good idea :p
01:13:11 <neutrino_> ahh, i thought you mean 9 more months
01:14:12 <neutrino_> i obviously haven't woken up yet lol
01:14:29 <statusfailed> oh haha
01:27:03 <AfC> I just wrote a library function whose API requires that you use it curried (er, partially applied, can never tell the difference). Is that a good idea ("clever!") or a horribly bad one ("you will now proceed to burn in hell")
01:28:04 <AfC> [I realize I just asked that without context, but I figured I'd throw it out there before I started pasting type signatures]
01:28:05 <statusfailed> AfC: requires in what sense?
01:29:07 <statusfailed> i.e., what happens if you don't
01:29:42 <statusfailed> probably the answer is "that's fine"
01:29:57 <statusfailed> but I might have misunderstood your question
01:31:30 <AfC> statusfailed: so I'm working on an HTTP client API.
01:31:37 <AfC> [Now before you all start groaning, this is 90% an exercise in writing [my first] Haskell library, and 10% possibly useful, if for no other reason that it provides exercise for the underlying streaming library]
01:33:29 <AfC> statusfailed: when it comes time to send the request, the function has [evolved to being] the following usage:
01:34:00 <AfC>    sendRequest conn req body
01:34:05 <AfC> which is nothing exciting
01:34:10 <AfC> the type is
01:34:40 <AfC> sendRequest :: Connection -> Request -> (OutputStream ByteString -> IO a) -> IO Response
01:34:52 <neutrino_> AfC: it's a good idea
01:35:28 <AfC> ie, the third argument you pass, "body" there above, is a handler function that gets called with the OutputStream that is there so you can write the body to be sent off to server on other side
01:36:00 <statusfailed> Yeah you're fine
01:36:16 <AfC> the common case, a GET with no entity body, looks like
01:36:24 <AfC>    sendRequest c q emptyBody
01:36:29 <AfC> where that is a function that does what you think it does.
01:36:33 <neutrino_> instead of "sendRequest" why not just "request"?
01:37:27 <AfC> neutrino_: that's a possibility. Remains to be seen whether it's pair receiveResponse is equally shorten-able. Also, I'm a bit bothered by e.g. `maybe`, case analysis for Maybe.
01:37:48 <AfC> neutrino_: [three are convenience APIs on top of all this; I'm still working on plumbing]
01:38:19 <AfC> so, now I'm trying to see what it would be like for the user to actually use their own streams. Next common case is PUT a file, yeah? So, I need a function that does that.
01:38:23 <neutrino_> k
01:38:29 <AfC>    sendRequest c q (fileBody "/etc/passwd")
01:38:48 <AfC> that seems pretty reasonable, yeah? Kinda nice, actually. The type of fileBody, however, is
01:39:01 <neutrino_> uhh, request/receive if you ask me
01:39:04 <AfC> fileBody :: FilePath -> OutputStream ByteString -> IO ()
01:39:22 <AfC> neutrino_: taken under advisement, sir/ma'am :)
01:40:00 <AfC> so there is fileBody. Which, as I opened with, one would have to use curried / partially applied (sic).
01:40:23 <AfC> so that the resultant function was :: OutputStream ByteString -> IO a
01:40:42 <AfC> which is what good old sendRequest ^W request wants as its third argument.
01:41:10 <AfC> So. Is this freaking ugly, or permissible, or actually common and I'm just not Haskeller enough to have really seen it much.
01:41:27 <AfC> [Mostly, I'm worried about the error messages that will result if you get it wrong using it, but alas]
01:42:00 <AfC> (I should have been writing
01:42:22 <AfC>    p <- sendRequest c q (fileBody "/etc/motd")
01:42:31 <AfC> where p is the Response, but yada yada)
01:44:30 <AfC> anyway, a function that you're *supposed* to use partially applied and no other way. The only example I can think of off hand is the ShowS stuff that comes up when writing your own Show instances
01:44:45 <AfC> is this actually a common pattern?
01:45:05 <mikeplus64> edwardk and the lenseneers: is there a lens thing to alter/set the nth element of something (e.g. list)
01:45:08 <mikeplus64> ?
01:45:27 <edwardk> > [1..10] & element 3 .~ 1000
01:45:29 <lambdabot>   [1,2,3,1000,5,6,7,8,9,10]
01:45:36 <mikeplus64> oh ok
01:45:45 <elliott> generalised by "ix" also in current git
01:45:53 <edwardk> in 3.8 you can use ix for that, yeah
01:45:54 <elliott> or _at in lens 3.7 albeit restricted
01:46:01 <edwardk> _at doesn't work for it in 3.7
01:46:05 <elliott> right
01:46:08 <edwardk> because its in the At class
01:46:14 <edwardk> and is tied to at
01:46:15 <elliott> it's a sidegeneralisation
01:46:15 <dibblego> > [1..10] & element 33 .~ 1000
01:46:17 <lambdabot>   [1,2,3,4,5,6,7,8,9,10]
01:46:27 <edwardk> dibblego: element n is a traversal
01:46:35 <edwardk> :t has
01:46:36 <lambdabot> Getting (First a) s t a b -> s -> Bool
01:46:43 <edwardk> has (element 33) [1..10]
01:46:45 <edwardk> > has (element 33) [1..10]
01:46:46 <lambdabot>   False
01:47:07 <edwardk> > [1..10] ^? element 33
01:47:09 <lambdabot>   Nothing
01:47:13 <edwardk> > [1..10] ^? element 3
01:47:15 <lambdabot>   Just 4
01:47:33 <neutrino_> AfC: no it's fine
01:47:47 <neutrino_> you'd probably use a data rather than a constructor function though
01:48:09 <neutrino_> that is, p <- request c q (FileBody "/foo/bar")
01:48:23 <dibblego> @check \x n a -> has (element n) x || (x & element n .~ a == x)
01:48:25 <lambdabot>   Not in scope: `myquickcheck'Precedence parsing error
01:48:25 <lambdabot>      cannot mix `Contr...
01:48:48 <Twisol> AfC: fwiw, your API seems reasonable to me
01:48:53 <neutrino_> and you'd only resolve the IO, that is loading /foo/bar, as late as possible
01:53:44 <b___> is there a high-level (beautifulsoup-like) XML package for Haskell?
01:54:05 <dibblego> tagsoup
01:54:41 <sopvop> if I want to pass lens to a function and use it to both modify and get, I need to use Loupe, right?
01:54:51 <shachaf> sopvop: You can use cloneLens
01:55:08 <shachaf> (Or you can give it an explicit type, and then you don't need either of those.)
01:55:09 <edwardk> sopvop: cloneLens or put a type signature on the function
01:55:24 <edwardk> note: cloneLens _is_ passing a Loupe effectively
01:56:05 <shachaf> > let foo l s = (view (cloneLens l) s, set (cloneLens l) () s) in foo _1 ('a','b')
01:56:06 <edwardk> :t \l x -> x & cloneLens l .~ x^.cloneLens l + 2
01:56:07 <lambdabot>   ('a',((),'b'))
01:56:08 <lambdabot> Num b => LensLike (Context b b) s t b b -> s -> t
01:56:48 <edwardk> sopvop interestingly in 99% of the usecases i've had for passing a lens and using it twice, i've been able to fuse the two uses into one use of another combinator
01:56:50 <sopvop> Signature is ok :)
01:57:12 <shachaf> What edwardk said is also true.
01:57:18 <shachaf> How are you using the lens?
01:57:35 <sopvop> is there a modify versions which takes maybe, and modifies if just? (just in case)
01:57:58 <shachaf> What do you mean?
01:58:13 <shachaf> > over (_1.traverse) (+1) (Just 1, "hi")
01:58:15 <sopvop> hm...
01:58:16 <lambdabot>   (Just 2,"hi")
01:58:17 <shachaf> > over (_1.traverse) (+1) (Nothing, "hi")
01:58:19 <lambdabot>   (Nothing,"hi")
01:58:25 * shachaf guesses randomly
01:59:38 <sopvop> I mean like say (0, "a") & _1 .~ Just 1 => (1, "a"), and _1 .~ Nothing => (0,"a")
02:00:18 <sopvop> (.~?) ::  Setting s s a b -> (Maybe b) -> s -> s
02:00:40 <shachaf> That seems like you only want to do the set if it's Just
02:00:53 <shachaf> Not really related to lens operations at all, is it?
02:00:54 <sopvop> yes, that
02:01:11 <sopvop> Well....
02:01:35 <edwardk> sopvop: you can just use fromMaybe with the old value
02:01:54 <shachaf> Right.
02:02:14 <edwardk> :t (0, 2) & _1 %~ \a -> fromMaybe a ?n
02:02:15 <lambdabot> (?n::Maybe t, Num t1, Num t) => (t, t1)
02:02:31 <shachaf> Oh, that's not how I meant it, but that works.
02:02:38 <sopvop> there are all sorts of operators in lens, like (?~), it was worth asking
02:02:38 <edwardk> :t (0, 2) & _1 %~ (fromMaybe ?? ?n)
02:02:40 <lambdabot>     Not in scope: `??'
02:02:40 <lambdabot>     Perhaps you meant one of these:
02:02:40 <lambdabot>       `^?' (imported from Control.Lens),
02:02:54 <edwardk> that 'don't change if set to Nothing' thing isn't one we offer
02:03:54 <shachaf> > (\s -> fromMaybe s $ fmap (set _1 ?? s) (Just 5)) (0,2)
02:03:56 <lambdabot>   (5,2)
02:03:57 <shachaf> > (\s -> fromMaybe s $ fmap (set _1 ?? s) (Nothing)) (0,2)
02:03:59 <lambdabot>   (0,2)
02:04:51 <shachaf> Probably there's a better way to write that.
02:05:07 <shachaf> Anyway it seems silly to do the set if you're never going to use it.
02:05:28 <shachaf> Er, that is, if you know in advance that you're keeping the value the same.
02:10:56 <sopvop> I Just thought about    "\foo a b c -> foo & fooA .~? a & fooB .~? b & fooC .~? c", to make my applicative use prettier.
02:14:49 <AfC> neutrino_, statusfailed, Twisol: thanks for your comments.
02:15:01 * AfC commits
02:44:16 <ion> @remember elliott I can't remember the last time I wrote any Haskell without an evil grin.
02:44:16 <lambdabot> It is forever etched in my memory.
02:44:18 <ion> from #-lens
02:47:21 <ivanm> if you wanted that in the HWN, you should have @remember'd it in #haskell
02:47:33 <ivanm> as IIRC the quotes in HWN are taken by scraping the #haskell logs
02:48:08 * Eduard_Munteanu imagines a few people in here writing Haskell with a trollface on
02:48:48 <shachaf> ivanm: ion @remembered it in #-lens at first.
02:48:54 <Eduard_Munteanu> type Lens s t a b = ... PROBLEM?
02:49:04 <shachaf> Then elliott complained that it wouldn't get into HWN, so ion @forgot it and @remembered it in here.
02:49:10 <ivanm> bah, I thought this was -blah
02:49:16 * ivanm needs to learn to read the channel tabs better
02:49:23 <shachaf> Eduard_Munteanu: Pft, four type parameters?
02:49:48 <Eduard_Munteanu> shachaf: yes, problem? :P
02:49:55 <shachaf> Eduard_Munteanu: elliott is up to type LensLike f g m n s t a b = (n a -> m b) -> g s -> f t
02:50:02 <elliott> ivanm: I would *never* let one of my quotes be prevented from elevating me further into the realm of HWN legend
02:50:31 <elliott> shachaf: Hey now, I didn't define LensLike yet.
02:50:34 <shachaf> Shh, we must not let twanvl hear about this.
02:50:52 <elliott> edwardk: you get to do your disclaimer
02:50:57 <elliott> this time it can sound more like "this is never getting into lens, ever"
02:51:11 <edwardk> yeah, i'm just letting elliott dig himself a deeper and deeper hole
02:51:22 <elliott> This hole is comfortable, elegant and flexible!!
02:51:31 <shachaf> "comfortable"?
02:51:31 <twanvl> shachaf: hear about what?
02:51:35 <edwardk> and completely disconnected from any practical need ;)
02:51:41 <shachaf> twanvl: Well... Did you hear about symmetric lenses?
02:51:41 <ivanm> methinks the mutable part of vector needs better documentation; given "copy :: PrimMonad m => MVector (PrimState m) a -> MVector (PrimState m) a -> m ()" there's no indication of which is the target and which is the source
02:51:47 <edwardk> shachaf came up with another cps style for lenses
02:51:48 <ivanm> unless you read the documentation for unsafeCopy
02:51:49 <elliott> edwardk: says the guy who wrote a whole library for record fields
02:52:02 <elliott> twanvl: http://slbkbs.org/pr.hs
02:52:04 <shachaf> twanvl: It's an experimental thing, not planned to go into the lens library. http://slbkbs.org/pr.hs
02:52:35 <elliott> twanvl: you get isos that compose (and with traversals etc.) with Prelude (.)/id
02:52:36 <edwardk> twanvl: its nice in that you can do prisms and isos without breaking out Control.Category. its ugly in that 'traverse' ceases to be a traversal, etc.
02:52:45 <elliott> as opposed to the hack lens uses right now
02:53:21 <ivanm> elliott: edwardk use hacks that end up working? I don't believe it! :p
02:53:30 <elliott> ivanm: well, sometimes they export unsafeCoecre
02:53:34 <elliott> this time we got lucky. I think.
02:53:39 <ivanm> that's what I mean :)
02:53:59 <elliott> edwardk remembered to add a constructor for id to the GADT rather than just exporting id = unsafeCoerce this time
02:54:13 <shachaf> That GADT makes me sad.
02:54:20 <elliott> yes
02:54:35 <nicoo> Which GADT ?
02:54:35 <elliott> good thing we have symmetric lenses now which are definitely absolutely getting into lens tomorrow as personally guaranteed by edwardk!*
02:54:39 <elliott> *90% of words in sentence are lies
02:55:13 <edwardk> nicoo: Prismoid and Isoid in Control.Lens.Internal
02:55:33 <elliott> Not very internal. Don't .Iso and .Prism reexport them?
02:55:37 <edwardk> yes
02:55:46 <shachaf> nicoo: https://github.com/ekmett/lens/blob/master/src/Control/Lens/Internal.hs#L524
02:55:47 <edwardk> but in case someone is looking for it =P
03:02:20 <ivanm> without lots of different pattern-matching cases, how can I write a function of type ` Maybe (a,b) -> Maybe (a,b) -> Maybe (a,b) ' that will take the fst value of the first argument and the snd value of the second argument if they're both Just, or the other one if one is Nothing (and if both Nothing return Nothing) ?
03:03:29 <nicoo> shachaf: Thaks
03:03:32 <nicoo> Thanks*
03:03:50 <DrSyzygy> ivanm: I'd do that with 3-4 lines of pattern-matching myself.
03:04:02 <DrSyzygy> ivanm: But it sounds like you'll want to work with the monad structure on Maybe.
03:04:20 <ivanm> DrSyzygy: yeah, I was thinking there's probably some Alternative-based solution or something
03:04:36 <ivanm> if I have to use pattern-matching I will; it just doesn't seem very elegant though :p
03:04:48 <DrSyzygy> ivanm: it can be decently elegant here I think.
03:04:52 <art2art> ivanm Maybe is also a monad.
03:04:57 <DrSyzygy> let's see.. what's the pastebin here again?
03:04:58 <neutrino_> DrSyzygy: are you a real doctor?
03:05:03 <ivanm> @hpaste
03:05:03 <lambdabot> Haskell pastebin: http://hpaste.org/
03:05:05 <DrSyzygy> neutrino_: Yes.
03:05:06 <ivanm> neutrino_: define "real"
03:05:15 <neutrino_> make sure not to use this nick while in germany..
03:05:17 <DrSyzygy> I'm a doctor in the classical sense of the word. :-P
03:05:18 <Eduard_Munteanu> define "doctor" :)
03:05:21 <nicoo> shachaf: I'm sad too, now :(
03:05:22 <DrSyzygy> neutrino_: Why wouldn't I?
03:05:30 <neutrino_> because you don't want to go to jail
03:05:38 <shachaf> nicoo: Why?
03:05:44 <DrSyzygy> neutrino_: Since I earned my doctorate in Germany I think I'm good. :-P
03:05:48 <neutrino_> apparently, foreign dr's are not allowed to call themselves dr in germany, unless they get special permission
03:05:51 <neutrino_> oh, then you're fine.
03:05:57 <ivanm> art2art: don't think it being a Monad really applies here; if one of them is Nothing then the entire result would be Nothing if you're just doing do { (a1,b1) <- m1; (a2,b2) <- m2; ... }
03:06:06 <nicoo> neutrino_: Seriously ? This is insane xD
03:06:09 <neutrino_> yes nicoo
03:06:20 <ivanm> neutrino_: oh? why is that?
03:06:32 <neutrino_> there were police visits to MPI researchers in the news
03:06:45 <neutrino_> ivanm, arcane laws from the days of bismarck
03:07:04 <ivanm> ahhh
03:07:30 <hpaste> DrSyzygy pasted “For ivanm” at http://hpaste.org/79515
03:07:39 <DrSyzygy> ivanm: Is this what you need?
03:08:12 <DrSyzygy> neutrino_: I could have, but never got around to, gotten a driver's license issued including my title. :-P
03:08:33 <ivanm> I don't think the listToMaybe one works
03:08:40 <ivanm> needs a catMaybes in there as well
03:08:55 <DrSyzygy> ivanm: listToMaybe takes a list of maybes, and produces the first non-Nothing if there is one.
03:09:02 <DrSyzygy> ... as far as I read it ...
03:09:11 <ivanm> > listToMaybe [1..10]
03:09:12 <lambdabot>   Just 1
03:09:15 <ivanm> @type listToMaybe
03:09:15 <DrSyzygy> > listToMaybe [Just 5, Just 10]
03:09:16 <lambdabot> [a] -> Maybe a
03:09:17 <lambdabot>   Just (Just 5)
03:09:19 <DrSyzygy> ooooh.
03:09:20 <DrSyzygy> my bad.
03:09:21 <ivanm> DrSyzygy: listToMaybe == safeHead
03:09:26 <ivanm> @type listToMaybe . catMaybes
03:09:28 <lambdabot> [Maybe a] -> Maybe a
03:09:31 <DrSyzygy> wait.
03:09:33 <DrSyzygy> safeHead?
03:09:34 <shachaf> > preview traverse "hello"
03:09:36 <lambdabot>   Just 'h'
03:09:45 <ivanm> DrSyzygy: as in "return Nothing if the list is empty"
03:09:47 <DrSyzygy> :t catMaybes
03:09:48 <lambdabot> [Maybe a] -> [a]
03:09:57 <DrSyzygy> ivanm: Fair enough. So add a catMaybes.
03:10:06 <art2art> :t catMaybes
03:10:08 <lambdabot> [Maybe a] -> [a]
03:10:09 <ivanm> eh, might as well just finish it off with pattern matching then :p
03:10:12 <DrSyzygy> My point was that there is a 2-liner that does it. :-P
03:10:21 <DrSyzygy> pattern matching bumps you up to 4 lines.
03:10:26 <ivanm> 3 actually
03:10:30 <art2art> :t safeHead
03:10:32 <lambdabot> Not in scope: `safeHead'
03:10:37 <DrSyzygy> ivanm: ... how do you do this in 3?
03:10:43 <ivanm> (Just, Just); (Nothing, foo), (foo, Nothing)
03:10:52 <DrSyzygy> ivanm: ooooh, right.
03:11:11 <DrSyzygy> aaanyway. lunch.
03:13:13 <Jafet> :t \a b -> liftM2 (,) (fmap fst a <|> fmap fst b) (fmap snd b <|> fmap snd a)
03:13:14 <lambdabot> (Monad m, Alternative m) => m (a, a2) -> m (a, a2) -> m (a, a2)
03:15:31 <Nereid> @ty curry $ uncurry (liftA2 (,)) . (uncurry (<|>) *** uncurry (flip (<|>))) . over both (fmap fst &&& fmap snd)
03:15:33 <lambdabot> Alternative f => f (b, b) -> f (b, b) -> f (b, b)
03:15:35 <Nereid> gross
03:15:41 <Nereid> Jafet: why not liftA2
03:15:55 <Nereid> I'm not sure why I tried to do it pointfree.
03:16:49 <fmap> :t over  both (fmap fst &&& fmap snd)
03:16:51 <lambdabot> Functor f => (f (b, b1), f (b, b1)) -> ((f b, f b1), (f b, f b1))
03:16:51 <Jafet> (***) `on` uncurry `ap` flip?
03:17:07 <Nereid> :t (***) `on` uncurry `ap` flip
03:17:09 <lambdabot>     Couldn't match expected type `(a0, b0)'
03:17:09 <lambdabot>                 with actual type `b0 -> a0 -> a1 b1 c0'
03:17:09 <lambdabot>     Expected type: (a0 -> b0 -> a1 b1 c0) -> (a0, b0)
03:17:30 <Jafet> :t ((***) `on` uncurry) `ap` flip
03:17:32 <lambdabot> (a -> a -> c) -> ((a, a), (a, a)) -> (c, c)
03:17:59 <Nereid> > (((***) `on` uncurry) `ap` flip) const ((1,2),(3,4))
03:18:01 <lambdabot>   (1,4)
03:18:06 <Nereid> heh
03:18:41 * Nereid wonders how you came up with that.
03:18:59 <Nereid> :t (***) `on` uncurry
03:19:00 <lambdabot> (a -> b -> c) -> (a -> b -> c) -> ((a, b), (a, b)) -> (c, c)
03:21:03 * hackagebot language-python 0.3.3 - Parsing and pretty printing of Python code.  http://hackage.haskell.org/package/language-python-0.3.3 (BerniePope)
03:21:56 <ezyang> Anyone know if the 'sqlite' library does UTF-8 properly?
03:23:23 <mreh> I can't see my emails going to the haskell-beginners list, are they moderated?
03:26:03 * hackagebot language-python 0.3.4 - Parsing and pretty printing of Python code.  http://hackage.haskell.org/package/language-python-0.3.4 (BerniePope)
03:55:45 <johnkx> Hi. I'm struggling to write point-free style, because I'm constantly torn about which order my arguments should go for natural currying and point-free writing style. It's the typical needle-haystack problem - should I do `find needle haystack` or `find haystack needle`. Do people know what I mean? Is there any idiomatic style, guide or anecdote that might help me?
03:56:18 <opqdonut> no, you just have to make up your mind
03:56:37 <opqdonut> one useful guideline is to prefer signatures like "b -> c -> a -> a" over other permutations
03:56:52 <johnkx> Whatever I choose I find myself using flip 50% of the time anyway
03:56:56 <shachaf> @ty elemIndex
03:56:58 <lambdabot> Eq a => a -> [a] -> Maybe Int
03:57:11 <opqdonut> :t mapM_
03:57:12 <lambdabot> Monad m => (a -> m b) -> [a] -> m ()
03:57:13 <opqdonut> :t forM_
03:57:14 <lambdabot> Monad m => [a] -> (a -> m b) -> m ()
03:57:22 <elliott> needle before haystack
03:57:22 <shachaf> johnkx: If you use infix operators, you can use them both ways.
03:57:23 <opqdonut> johnkx: you can always offer both versions, see above :)
03:57:27 <elliott> unless it's a really big needle in a small haystack
03:57:33 <shachaf> @ty isInfixOf
03:57:34 <lambdabot> Eq a => [a] -> [a] -> Bool
03:57:41 <shachaf> > ("abc" `isInfixOf`)
03:57:43 <lambdabot>   No instance for (GHC.Show.Show
03:57:43 <lambdabot>                     ([GHC.Types.Char] -> GHC...
03:57:48 <shachaf> @ty ("abc" `isInfixOf`)
03:57:50 <lambdabot> [Char] -> Bool
03:57:54 <shachaf> @ty (`isInfixOf` "hello world")
03:57:56 <lambdabot> [Char] -> Bool
04:00:47 <arnd> Hi all nice to be here :-)
04:02:29 <bootcode_> hi
04:03:21 <bootcode_> when cabal installing, is it possible to undefine __GLASGOW_HASKELL__ ? I would like to omit the Text dependency of hashable
04:03:37 <shachaf> That's probably not a good idea.
04:04:06 <elliott> shachaf: only probably?
04:04:08 <elliott> bootcode_: that's a bad idea
04:04:11 <bootcode_> as a workaround, when using haste as backend
04:04:44 <bootcode_> undefining is a bad idea, or omitting the text dep?
04:06:49 <bootcode_> well, I guess I can always install from custom source, sothat might not be needed
04:10:29 <ivanm> bootcode_: I think that that's there because Text is meant to be a possible instance of the class, but the text library only builds on GHC
04:14:23 <mreh> I'm not getting any mail from the haskell-beginners mailing list, including password reminders
04:14:23 <mreh> odd
04:14:24 <mreh> I did only just subscribed
04:14:33 <mreh> subscribe*
04:16:04 * hackagebot AndroidViewHierarchyImporter 0.1.0.0 - Tool to import a description of an Android view hierarchy through Abd and the Android view server  http://hackage.haskell.org/package/AndroidViewHierarchyImporter-0.1.0.0 (alpheccar)
04:20:08 <fmap> AbstractAndroidViewHierarchyImporterFactoryBean
04:20:45 <ivanm> fmap: NEEDS MOAR FACTORY!!!
04:21:22 <hiptobecubic> you forgot widget
04:21:37 <hpaste> “soeren openfoo.org” pasted “Haskell GMail Count” at http://hpaste.org/79516
04:21:49 <Entroacceptor> why is there no link to the "more documentation" :(
04:23:46 <ivanm> Entroacceptor: where?
04:24:11 <Entroacceptor> on the AndroidViewHierarchyImporter package page
04:24:45 <ivanm> I guess alpheccar expects you to download the tarball and read the Main.hs file
04:25:11 <ivanm> if he doesn't have it on github or anything, then there's nowhere really you can link it to
04:26:04 * hackagebot AndroidViewHierarchyImporter 0.1.0.1 - Android view hierarchy importer  http://hackage.haskell.org/package/AndroidViewHierarchyImporter-0.1.0.1 (alpheccar)
04:27:28 <ivanm> that's also a rather out of date dependency upon split, bytestring, etc. :s
04:28:58 <dennis___> wazzaa
04:29:05 <macbookpro__> HOGESCHOOL ZEELAND!!
04:33:52 <tathi> I'm brand new to Haskell (a few days): is this (http://hpaste.org/79517) a reasonable way to structure the top level of an interactive application?
04:34:10 <tathi> The few examples I've looked at (hpong etc) have been much more ... imperative feeling
04:38:19 <mreh> isn't that something akin to coroutines
04:39:04 <M30W> Heh. gpg'd a 1.8M binary, brought it down to 485k.
04:41:05 * hackagebot direct-sqlite 2.3 - Low-level binding to SQLite3. Includes UTF8 and BLOB support.  http://hackage.haskell.org/package/direct-sqlite-2.3 (IreneKnapp)
04:46:25 <dennis___> Yooo HZ scholieren
05:00:11 <b___> I find myself writing `maybe Nothing f (g x)`, but I have the feeling that this is pretty retarded
05:00:20 <b___> help me out =[]
05:00:40 <shachaf> @ty maybe Nothing
05:00:42 <lambdabot> (a -> Maybe a1) -> Maybe a -> Maybe a1
05:00:44 <`ramses> b___: g x >>= f
05:00:47 <shachaf> @ty (=<<)
05:00:49 <lambdabot> Monad m => (a -> m b) -> m a -> m b
05:01:19 <shachaf> Which is also join (fmap f (g x))
05:01:33 <b___> ah yeah =]]]
05:02:07 <b___> also I have `maybe (error foo) f (g x)`
05:02:23 <b___> is this a common pattern?
05:02:28 <shachaf> @ty maybe (error "hi")
05:02:29 <lambdabot> (a -> b) -> Maybe a -> b
05:02:47 <shachaf> @ty \f -> f . fromMaybe (error "hi")
05:02:48 <lambdabot> (a -> b) -> Maybe a -> b
05:03:38 * shachaf goes to sleep.
05:03:45 <b___> good night, thanks =]
05:03:52 <`ramses> @localtime shachaf
05:03:54 <lambdabot> Local time for shachaf is Wed Dec 19 05:03:35 2012
05:04:06 <`ramses> haha :)
05:07:18 <b___> is there also a more succinct way of writing `foo >>= \x -> bar >>= \y -> quux $ cakes x y` ?
05:07:40 <`ramses> b___: use do notation
05:08:30 <pqmodn> @pl foo >>= \x -> bar >>= \y -> quux $ cakes x y
05:08:31 <lambdabot> (bar >>=) . (quux .) . cakes =<< foo
05:10:59 <`ramses> b___: do { x <- foo; y <- bar; quux (cakes x y)}
05:12:17 <fmap> @info do { x <- foo; y <- bar; quux (cakes x y)}
05:12:17 <lambdabot> foo >>= \ x -> bar >>= \ y -> quux (cakes x y)
05:14:21 <`ramses> heh, I thought that was what @undo was for
05:14:36 <fmap> yes
05:40:13 <neutrino_> @hoogle check
05:40:13 <lambdabot> Control.Monad.STM check :: Bool -> STM a
05:40:13 <lambdabot> package check-email
05:40:13 <lambdabot> Text.Html checkbox :: String -> String -> Html
05:40:49 <hiptobecubic> there IS no analytical solution for this. Jesus christ. What a waste of an hour.
05:41:22 * hiptobecubic wanders off, mumbling.
05:42:24 <Jafet> The answer is more drugs.
05:43:37 <dgpratt> I have a question about debugging via GHCi, I'll use this code snippet as the example scenario: http://hpaste.org/79521
05:44:10 <dgpratt> if I put a breakpoint on line 5, "i" does not show up in ":show bindings"
05:44:44 <dgpratt> if I put a breakpoint on line 6, "i" *does* show up in ":show bindings"
05:45:32 <Philippa> I suspect that's an artefact of how do notation desugars
05:45:49 <dgpratt> my question is, is there a way for me to break on a particular line in GHCi and observe some value in scope?
05:45:59 <dgpratt> possible in closure scope?
05:49:08 <lordk> I'm trying to find a combinator to solve this problem for me: [M -> M] -> M -> M. I have a list of funcitons and want to apply them, chained in order, to an initial value. I don't think Hoogle is giving me what I'm looking for. Any ideas? I'm sure it's some common pattern that I'm being blind to.
05:49:49 <Mon_Ouie> lordk: fold with function composition?
05:49:49 <yitz> lordk: foldr (>>>)
05:50:01 <yitz> @hoogle >>>
05:50:01 <lambdabot> Control.Category (>>>) :: Category cat => cat a b -> cat b c -> cat a c
05:50:02 <lambdabot> Control.Arrow (>>>) :: Category cat => cat a b -> cat b c -> cat a c
05:50:15 <lordk> Aaaah, it's function composition isn't it!
05:50:26 <yitz> lordk: or foldr (.) but i suspect that will do it in the wrong order for you
05:51:59 <Botje> how about sequence?
05:52:11 <lordk> Sequence is monads isnt it?
05:52:18 <Botje> eval: (sequence [(+1), (*2), (+3)]) 5
05:52:21 <Botje> uh
05:52:25 <Botje> > (sequence [(+1), (*2), (+3)]) 5
05:52:27 <lambdabot>   [6,10,8]
05:52:36 <Botje> boo. nevermind
05:56:09 <`ramses> > foldl' (flip ($)) "" [('a':), ('b':)]
05:56:10 <XexonixXexillion> :t flip (foldl (flip ($)))
05:56:11 <lambdabot>   "ba"
05:56:12 <lambdabot> [c -> c] -> c -> c
05:56:47 <XexonixXexillion> > flip (foldl (flip ($))) [succ, succ, (*2)] 5
05:56:48 <lambdabot>   14
05:56:56 <fmap> @ty appEndo . foldMap Endo
05:56:57 <lambdabot> Foldable t => t (a -> a) -> a -> a
05:57:19 <fmap> @ty appEndo . getDual . foldMap (Dual . Endo)
05:57:21 <lambdabot> Foldable t => t (a -> a) -> a -> a
05:57:37 <elliott> fmap:
05:57:44 <fmap> what
05:57:49 <elliott> :t au (wrapping Endo . wrapping Dual) foldMap
05:57:50 <lambdabot> (Functor (Isoid (Dual (Endo a) -> Mutator (Dual (Endo a)))), Foldable t, Wrapped (Endo a) (Endo a) (Dual (Endo a)) (Dual (Endo a))) => t (a -> a) -> a -> a
05:57:54 <elliott> oops.
05:58:13 <elliott> edwardk: wait, what did I do wrong there
05:58:23 <elliott> oh
05:58:24 <fmap> looks good
05:58:26 <elliott> broken lambdabot (.)
05:58:27 <elliott> *sigh*
05:58:32 <elliott> :t au (wrapping Endo C.. wrapping Dual) foldMap
05:58:33 <lambdabot> Couldn't find qualified module.
05:58:37 <elliott> :t au (wrapping Endo Control.Category.. wrapping Dual) foldMap
05:58:38 <lambdabot> (Foldable t, Wrapped (Endo a) (Endo a) (Dual (Endo a)) (Dual (Endo a))) => t (a -> a) -> a -> a
05:58:52 <elliott> ok that works except for the broken Wrapped constraint!
05:59:00 <elliott> oh
05:59:07 <elliott> :t au (wrapping Dual Control.Category.. wrapping Endo) foldMap
05:59:08 <lambdabot>     Couldn't match expected type `Dual t0' with actual type `a0 -> a0'
05:59:08 <lambdabot>     Expected type: Dual t0 -> b0
05:59:08 <lambdabot>       Actual type: (a0 -> a0) -> Endo a0
05:59:14 * elliott gives up
05:59:18 <elliott> I guess there's no Dual instance or something
05:59:25 <elliott> > au (wrapping Dual Control.Category.. wrapping Endo) foldMap [id,(+1)] 2
05:59:26 <lambdabot>   Not in scope: `Control.Category..'
05:59:29 <elliott> hah
06:00:52 <fmap> :t au
06:00:53 <lambdabot> AnIso s t a b -> ((s -> a) -> e -> b) -> e -> t
06:01:16 <fmap> :t wrapping
06:01:18 <lambdabot> (Functor f, Wrapped s s a a, Isomorphic k) => (s -> a) -> k (a -> f a) (s -> f s)
06:02:18 <elliott> :t wrapping Dual
06:02:19 <lambdabot> (Functor f, Wrapped s s (Dual s) (Dual s), Isomorphic k) => k (Dual s -> f (Dual s)) (s -> f s)
06:02:23 <elliott> yeah there is just no instance
06:02:26 <elliott> :t unwrapping Dual
06:02:27 <lambdabot> (Functor f, Wrapped s s (Dual s) (Dual s), Isomorphic k) => k (s -> f s) (Dual s -> f (Dual s))
06:02:29 <elliott> edwardk: bug?
06:02:40 <elliott> with an instance and a reasonable (.) in lambdabot you could do:
06:02:44 <elliott> au (wrapping Dual . wrapping Endo) foldMap
06:02:46 <edwardk> ?
06:02:51 <elliott> edwardk: no wrapped instance for Dual
06:03:03 <edwardk> ah, patch! =)
06:03:32 <elliott> :(
06:03:36 <elliott> fmap caused me to find it.
06:03:39 <elliott> fmap: you write the patch for edwardk
06:03:40 <yitz> @type (Prelude..)
06:03:41 <lambdabot> (b -> c) -> (a -> b) -> a -> c
06:03:51 <fmap> elliott: okay :(
06:05:40 <yitz> elliott: for future reference, that's ^^ how you get back normal (.) in here.
06:06:39 <elliott> yitz: no, I want the third (.) :p
06:20:47 <quchen> elliott: Prelude... :: Enum a => a -> a -> [a]
06:20:49 <quchen> ;-)
06:21:22 <elliott> heh
06:22:29 <wuttf> Can anyone explain for me noob that WTF is going on here   http://hackage.haskell.org/packages/archive/mongoDB/1.3.1/doc/html/Database-MongoDB.html         I am obviously coming from an OOP background and I am shocked to see the part
06:22:31 <wuttf> insertTeams = insertMany "team" exampleDocs
06:23:12 <elliott> amusingly that code is pretty close to traditional imperative
06:23:17 <elliott> I don't see where you see "exampleDocs" though
06:23:33 <wuttf> sorry that is in my modified stuff
06:24:00 <wuttf> elliott: Now, the thing confuses me, where is the DB handle in that? I see the line
06:24:14 <wuttf> e <- access pipe master "baseball" run
06:25:00 <elliott> "pipe" looks like the handle to me
06:26:07 <wuttf> I don't get how that run method can act on the pipe
06:27:58 <wuttf> I mean I expected to see          insertMany DBHandle "team" exampleDocs, like in OO langs, it looks much nicer in haskell but I just dont get how those different parts are glued together
06:29:06 <`ramses> wuttf: haven't looked at the code, but I guess the passing of the handle will be handled by the monad
06:29:34 <wuttf> `ramses: I guess too but it franly looks like magic to me.
06:29:38 <`ramses> maybe something reader-ish
06:29:39 <fmap> wuttf: that `DBHandle' is passed implicitly by Reader inside I guess
06:29:49 <fmap> ReaderT rather
06:30:00 <`ramses> that's what I thought :)
06:30:52 <wuttf> I read up on that then (no pun)
06:31:07 <neutrino_> http://www.haskell.org/wikiupload/a/a0/Spj-has-fun-11.jpg
06:31:10 <typoclass> wuttf: i agree with fmap. when you'd do ":t insertTeam" with that example file loaded in ghci, you'd get something mentioning Reader or a similar thing
06:31:10 <lambdabot> typoclass: You have 1 new message. '/msg lambdabot @messages' to read it.
06:31:52 <typoclass> neutrino_: gotta run now, but let's talk later :-)
06:32:48 <`ramses> wuttf: the monad chapters in lyah explain these monad instances fairly well imho
06:33:45 <fmap> unfortunately they use that stupid record wild cards extension so `access' sources might not be helpful :(
06:34:28 <wuttf> `ramses: I am going back to that then. My haskell foo is fluctuating today
06:37:56 <`ramses> fmap: what's so bad about that extension? I just checked what it does but the stupidity of it is not immediately obvious to me :)
06:42:47 <t7> neutrino_: i like the guy infornt of the blackboard full of math saying this is how we print hello world
06:43:05 <t7> there are some funny haskell pictures
06:43:12 <fmap> `ramses: well a) `Context{..}' is confusing on its own b) I have no idea what `access' arguments end up being in that Context (all of them? only part?)
06:45:06 <neutrino_> t7: dunno that one
06:45:13 <neutrino_> @tell typoclass ok
06:45:14 <lambdabot> Consider it noted.
06:45:25 <`ramses> ok, I hadn't looked at this specific code yet, but indeed that's pretty confusing
06:45:25 <wuttf> Anyone doing Haskell on Android? Is that possible?
06:45:59 <neutrino_> hey guys, does anyone have the data parallel haskell talk from oscon 2007?
06:46:04 <neutrino_> a video or slides at least?
06:46:04 <plat0> wuttf: You may find this useful: http://www.reddit.com/r/haskell/comments/14wm0r/haskell_for_android_via_ndk/
06:46:06 <neutrino_> video would be great
06:46:24 <wuttf> plat0: Wow fresh material ty
07:00:59 <hiptobecubic> what about something like frege? isn't that a jvm language?
07:03:57 <t7> yeah haskell inspired
07:05:49 <BadKitty> @tell badkitty test
07:05:49 <lambdabot> You can tell yourself!
07:06:11 <BadKitty> @tell archeydevil test
07:06:11 <lambdabot> Consider it noted.
07:06:18 <archeydevil> Really?
07:06:18 <lambdabot> archeydevil: You have 1 new message. '/msg lambdabot @messages' to read it.
07:06:21 <archeydevil> Yay
07:22:07 <bartavelle> what is the good XMPP library that should be used ? pontarius ?
07:24:28 <Taneb> Is LogicT (State Foo) a Monad?
07:25:29 <Taneb> By which I mean, is LogicT as wrong as ListT?
07:29:19 <rwbarton> LogicT is a legitimate monad transformer
07:30:06 <neutrino_> i mean this talk: http://conferences.oreillynet.com/cs/os2007/view/e_sess/14014  does anyone have slides or a video?
07:30:09 <Taneb> Thanks
07:30:46 <mreh> can we put attachments on our posts to beginners@haskell.org?
07:31:05 <mreh> I just sent one without any appearance of it being received
07:33:32 <t7> what is the Logic monad?
07:33:48 <Taneb> @hackage logict
07:33:48 <lambdabot> http://hackage.haskell.org/package/logict
07:34:20 <Taneb> It's a backtracking logic monad
07:34:32 <bartavelle> ok that pontarius-xmpp library is not trivial to use
07:35:38 <Clint> network-protocol-xmpp is okay
07:36:18 <bartavelle> ok will take a look
07:37:08 <bartavelle> it seems I still have to understand what a "stanza" is and low level stuff like that
07:39:31 <xnyhps> A stanza is just an XMPP packet.
07:39:44 <Eelis> bartavelle: i'm not sure it's wise to desire writing an XMPP program without knowing what a stanza is ;)
07:40:29 <bartavelle> I just want to write a bot, an interface where I would submit a username, passwords and a callback (Text -> SomeMonad ()) would be nice
07:40:54 <Clint> bartavelle: https://github.com/dom96/ElysiaBot/blob/master/src/Plugins/XMPP/XMPP.hs
07:41:10 <bartavelle> ah there already is a bot
07:41:25 <bartavelle> thanks a lot, seems perfect
07:41:41 <Clint> could use some deuglification
07:42:18 <bartavelle> how hackable is the whole bot ?
07:42:26 <bartavelle> it seems like exactly what I want
07:42:58 <HugoDaniel> hi
07:43:19 <HugoDaniel> how can i write this function better: fromMaybe [] . fmap return  ?
07:44:44 <S11001001> HugoDaniel: it's toList from Data.Foldable
07:44:50 <fmap> :t fromMaybe [] . fmap return
07:44:52 <lambdabot> Maybe a -> [a]
07:44:55 <xnyhps> @ty maybeToList
07:44:56 <lambdabot> Maybe a -> [a]
07:45:36 <HugoDaniel> awhh cool
07:45:44 <HugoDaniel> i wasn't aware of maybeToList :D
07:45:47 <HugoDaniel> thanks
07:46:10 <xnyhps> np
07:46:27 <Clint> bartavelle: the author is largely uninvolved, so other than him merging patches, you're on your own with that one
07:46:28 <fmap> > (Just 3 ^.. folded, Nothing ^.. folded)
07:46:30 <lambdabot>   ([3],[])
07:46:37 <bartavelle> Clint, ok !
07:48:49 <fons> Hi there
07:49:10 <fons> I am trying to make use of https://github.com/ivant/graph-matching/blob/master/Data/Graph/HopcroftKarp.hs
07:49:28 <fons> however, ghci complains about a syntax error
07:49:56 <fons> related to the TransformListComp extension which I don't get to understand well
07:50:23 <fons> I would appreciate if somebody could have a look at it
07:50:31 <fons> it must be something really really stupid
07:50:40 <rwbarton> paste the error
07:50:42 <rwbarton> @where hpaste
07:50:42 <lambdabot> http://hpaste.org/
07:51:22 <fons> I think it's simple enough to paste here: Data/Graph/Hopcroftkarp.hs:176:37: parse error on input `]'
07:51:41 <fons> I think it is related to the "then" keyword
07:51:47 <fons> used by the extension
07:52:03 <fons> rwbarton: any ideas?
07:52:06 <rwbarton> I think maybe the "then group by" got removed?
07:52:10 <rwbarton> afaik no one really uses this stuff
07:52:33 <fons> I check and it is documented in ghc's latest manual
07:52:38 <fons> maybe it broke :S
07:52:51 <fons> I would just like to make use of the algorithm
07:52:57 <rwbarton> well what version of ghc are you using, better to check that manual :)
07:53:18 <fons> the latest
07:53:20 <fons> I presume
07:53:21 <fons> The Glorious Glasgow Haskell Compilation System, version 7.4.2
07:53:36 <fons> that extension has been there for a while as it seems
07:54:39 <rwbarton> http://www.haskell.org/ghc/docs/7.4.2/html/users_guide/syntax-extns.html#generalised-list-comprehensions
07:55:09 <rwbarton> I don't see anything about just "then group by e"
07:55:25 <rwbarton> unless it is supposed to be a case of the second form with f = group
07:56:04 <rwbarton> in e.g. http://www.haskell.org/ghc/docs/7.0.4/html/users_guide/syntax-extns.html#generalised-list-comprehensions you can see there used to be "then group by e"
07:56:46 <wunki> should I just use `getArgs` for a command line program?
07:57:18 <rwbarton> so I suppose you can add 'using groupWith'
07:57:36 <Clint> wunki: depends what you're trying to do
07:57:39 <aavogt> wunki that's the easiest if you just have about one argument
07:57:46 <t7> what are some fun things to prove about semigroups?
07:57:57 <pdxleif> associativity?
07:59:22 <wunki> Clint, aavogt: I have multiple arguments. I came across CmdArgs, but didn't see it used much in other packages. Like Hakyll
07:59:25 <t7> thats defined
08:00:05 * aavogt recommends CmdArgs
08:00:17 <fons> rwbarton: thanks, let me check
08:00:41 <Clint> wunki: i use cmdargs. also there's optparse-applicative which i haven't tried
08:00:52 <bitonic> .
08:00:54 <bitonic> oops.
08:01:35 <JoeyA> Is there a way to run a test suite with and without -threaded, without duplicating the whole cabal test-suite section?
08:01:58 <wunki> ok, enough confirmation for me. Also using cmdargs. Thanks Clint and aavogt.
08:02:09 <fons> rwbarton: groupBy doesn't seem to be exported by GHC.Exts anymore
08:02:27 <Taneb> Whats the easiest way to see if a string is a subsequence of another string?
08:02:47 <rwbarton> groupWith
08:03:10 <Taneb> :t groupWith
08:03:11 <lambdabot> Not in scope: `groupWith'
08:03:15 <Taneb> Wiat
08:03:20 <Taneb> *wait
08:03:32 <fons> rwbarton: thanks! That made it work! :)
08:03:32 <dgpratt> Taneb: isInfixOf?
08:04:05 <Taneb> dgpratt, might be, thanks
08:04:47 <andsens> What am I doing wrong here: filter (any (map (==) ["mustache", "mst"]) . extension) (files args)
08:04:59 <dgpratt> somebody ought to make a "Let me Hoogle that for you" site ;-)
08:06:24 <rwbarton> any doesn't take a list
08:06:39 <Taneb> @hoogle [a] -> [a] -> Bool
08:06:39 <lambdabot> Data.List isInfixOf :: Eq a => [a] -> [a] -> Bool
08:06:39 <lambdabot> Data.List isPrefixOf :: Eq a => [a] -> [a] -> Bool
08:06:39 <lambdabot> Data.List isSuffixOf :: Eq a => [a] -> [a] -> Bool
08:06:44 <Taneb> Huh
08:06:47 <Taneb> That would have worked
08:06:47 <rwbarton> @type elem
08:06:49 <lambdabot> Eq a => a -> [a] -> Bool
08:07:04 <dgpratt> @hoogle String -> String -> Bool
08:07:05 <lambdabot> System.FilePath.Windows equalFilePath :: FilePath -> FilePath -> Bool
08:07:05 <lambdabot> System.FilePath.Posix equalFilePath :: FilePath -> FilePath -> Bool
08:07:05 <lambdabot> Data.List isInfixOf :: Eq a => [a] -> [a] -> Bool
08:07:07 <rwbarton> (`elem` ["mustache", "mst"]) . extension -- if you don't want to write a lambda
08:07:16 <dgpratt> that too, almost
08:08:24 <andsens> rwbarton: yay! It worked. thank you
08:08:46 <ziarkaen> How may I shorten (arr (\(x,y) -> y)) ?
08:09:22 <fmap> :t snd
08:09:24 <lambdabot> (a, b) -> b
08:09:26 <JoeyA> :t (arr (\(x,y) -> y))
08:09:28 <lambdabot> Arrow a => a (t, c) c
08:09:51 <weasels> @src arr
08:09:52 <lambdabot> Source not found. It can only be attributed to human error.
08:09:55 <Clint> :t second
08:09:57 <lambdabot> Arrow a => a b c -> a (d, b) (d, c)
08:10:13 <JoeyA> :t arr snd
08:10:15 <lambdabot> Arrow a => a (a1, c) c
08:11:56 <niteria>  @src fix
08:12:01 <ParahSail1n> @src snd
08:12:02 <lambdabot> snd (_,y) =  y
08:12:04 <niteria> @src fix
08:12:04 <lambdabot> fix f = let x = f x in x
08:13:17 <ziarkaen> JoeyA, Thank you.  Was trying to use Control.Arrow.second to no avail.  (I'm learning about Haskell/arrows on-the-fly as I code...)
08:14:46 <JoeyA> ziarkaen: Useful learning exercise: implement the Arrow instances for a Mealy machine
08:14:58 <JoeyA> newtype Mealy a b = Mealy (a -> (b, Mealy a b))
08:15:08 <uvelichitel> cross compile chain osx (dev)  to debian(production), is it possible?
08:15:09 <JoeyA> (also called 'Auto')
08:16:26 <scooty-puff> if i have a hidden module in a cabal package named (for instance) Data.CommonName, and another package uses my package, and a package with a public module named Data.CommonName, no problem, right?
08:16:27 <JoeyA> A Mealy machine is a "function" that updates itself as it receives items.
08:16:39 <JoeyA> Thanks to edwardk for telling me about them.
08:36:00 <mysticc> I have a function which takes 6 arguments. I am using TH to generate argument but while writing TH code for function application it is pain to write AppE 6 times, is there a better way ?
08:36:44 <rwbarton> foldl AppE?
08:37:20 <mysticc> ohh thanks :)
08:38:32 <c_wraith> mysticc: you could also use quotes.
08:39:00 <c_wraith> mysticc: [| foo arg1 arg2 arg3 arg4 arg5 arg6 arg7 |]
08:39:48 <aavogt> often it's nicer to use the liftM versions of those constructors (appE)
08:40:15 <mysticc> c_wraith: How can I if argument are themselves TH code of type ExpQ
08:40:36 <aavogt> @ty appE
08:40:37 <lambdabot>     Not in scope: `appE'
08:40:37 <lambdabot>     Perhaps you meant `app' (imported from Control.Arrow)
08:41:10 <c_wraith> [| foo $arg1 |] etc
08:41:15 <c_wraith> you can splice into a quote
08:43:14 <mysticc> c_wraith: Ohh, didn't know that. thanks.
08:44:29 <c_wraith> my TH code got way simpler when I learned that :)
08:52:01 <saml> what would functional programming look like without algebraic data type?
08:52:08 <parcs> like scheme
08:52:19 <saml> but typed
08:52:32 <hiptobecubic> racket has types
08:57:51 <mysticc> If I use something like g = [| $(f) |] in which f has reference to some free variables. Then which scope will determine the value of those variables. scope of g or scope where g is spliced?
09:02:37 <parcs> scope of g
09:08:03 <parcs> everything is still lexically scoped
09:16:58 <aavogt> mysticc: might be scope of f, if you defined it like   f = [| abc |]
09:20:53 <Fuuzetsu> edwardk: What's wrong with the audio on your new lenses video? Any chance for reupload?
09:21:27 <edwardk> Fuuzetsu: this is the 'improved' version. ion is working on improving it further.
09:21:52 <edwardk> Fuuzetsu: the mic i had on was emitting feedback through the entire talk but only into the recording channel
09:21:59 <jryan> Hey, I'm reading Real World Haskell right now and was wondering if there was a good website I could use to practice writing haskell programs and I read it?
09:22:26 <edwardk> i have the raw version of the video which has an annoying hum thats much louder than the version i uploaded, but you can make out the words a bit better in places
09:22:54 <edwardk> oh wow. the audio is screwed
09:23:12 <Fuuzetsu> ...yeah, that.
09:24:17 <edwardk> the version before youtube got it was a little muffled in places but nowhere near that bad
09:25:21 <edwardk> i'll upload the raw version with the hum in the meantime
09:29:40 <edwardk> Fuuzetsu: i've got the other version uploading now
09:30:13 <edwardk> Fuuzetsu: in the meantime you can download it directly from comonad.com http://comonad.com/~rickasaurus/ the gigantic mp4 there
09:30:56 <edwardk> the real version should be online in about an hour and a half if the length of time it took for the last one to process is any indication
09:36:45 <hiptobecubic> redub :D
09:37:15 <hiptobecubic> It will be like an old kung fu movie.
09:37:26 <edwardk> hah
09:37:48 <edwardk> i wish i could just replace the audio, but unless i want to replace it with some bad licensed youtube music i'm out of luck ;)
09:37:56 <edwardk> so youtube gets all 3 gigs again
09:38:01 <hiptobecubic> heh
09:42:37 <fmap> edwardk: I hope that .mp4 thing contains sound?
09:43:06 <edwardk> it does. it just contains an annoying hum that we tried to fix
09:43:26 <edwardk> sadly the fix, which sounded much better, didn't deal well with youtube's additional compression layer
09:43:47 <fmap> aha, and .ogg is an attempt to fix?
09:44:19 <edwardk> the .ogg is the audio fixed up, you can mix it into the gigantic mp4 and get something without the hum, but with funny audio artifacts
09:44:42 <edwardk> but youtube doesn't deal with that version well
09:45:34 <ion> fuuzetsu, edwardk: It wasn’t feedback, it was more likely something like a ground loop.
09:46:00 <edwardk> *nods*
09:46:36 <plat0> edwardk: you could redub it :)
09:46:49 <hiptobecubic> plat0, that's a good idea.
09:47:36 <edwardk> you <mouth moving> know <mouth moving> kung-fu!
09:49:39 <plat0> Redubbing your own voice will yield lot better results than doing translation
09:50:29 <hiptobecubic> why would you want that?
09:50:58 <plat0> Want what?
09:51:11 <edwardk> i'm going to push up the version with the hum for now, and see if ion can't work his magic and get us closer to a noise free version
09:51:19 <neutrino_> edwardk: ground loops are easily removed in soundforge.
09:51:25 <neutrino_> and hums.
09:51:36 <neutrino_> it's just a simple comb filter applied.
09:52:43 <edwardk> talk to ion about the tricks he used. it worked and got rid of most of the noise in the first version and then he went and started doing another because he has a second channel that just has the hum on it, so you can filter most of it out just by subtracting that scaled
09:53:04 <edwardk> its probably something with the way we re-encoded it before uploading
09:55:27 <neutrino_> yes, it might be
09:55:52 <neutrino_> or, maybe the channel wasn't *really* the same hum, for example it could have been 90 degrees out of phase
09:56:03 <neutrino_> but that's esoteria
09:56:06 <neutrino_> :)
09:56:11 * hackagebot vcd 0.2.2 - Reading and writing VCD files.  http://hackage.haskell.org/package/vcd-0.2.2 (TomHawkins)
09:58:19 <ion> (It had more or less the same phase, but its magnitude was lower.)
09:59:28 <neutrino_> ion: have you tried running it through ffmpeg to recode?
10:02:50 <ion> neutrino: edwardk combined my audio with the original video with avconv, but i recommended making the resulting MP4 streamable with MP4Box and perhaps Youtube didn’t like that for some reason.
10:03:13 <neutrino_> did it get run through mp4box?
10:03:24 <edwardk> yes
10:03:48 <neutrino_> yeah, suggest not doing that
10:04:12 <neutrino_> did youtube encode it at all, or did it reject the file altogether?
10:04:37 <edwardk> youtube took it
10:04:47 <edwardk> but they did it offline so i didn't get to see many details
10:05:09 <neutrino_> so they took it and it's up somewhere?
10:05:18 <neutrino_> trying to understand what you mean.
10:05:44 <edwardk> they took it, its up https://www.youtube.com/my_videos_edit?ns=1&video_id=QBgqTe-EszA should be the link to the butchered video they have
10:05:49 <hiptobecubic> ion, complete side note, but everything i can find about libav suggests that its a really miserable fork of ffmpeg
10:05:50 <edwardk> i'm uploading another copy
10:06:17 <neutrino_> that video is in your user profile, it's not accessible to others
10:06:33 <neutrino_> how was the video butchered? not seekable? or did the sound stutter?
10:06:53 <edwardk> i set it to be visible given the link, one sec. i must have given the edit link
10:06:59 <ion> hiptobecubic: Dunno. Debian has replaced the ffmpeg package with a transitional package that depends on libav-tools.
10:07:21 <edwardk> sound comes in stoccato bursts about half a second long each, its completely unintelligible
10:07:33 <neutrino_> edwardk: yeah, it sounds like the muxing went wrong
10:07:44 <neutrino_> edwardk: try ffmpeg (not libav)
10:08:08 <edwardk> neutrino_: http://youtu.be/QBgqTe-EszA
10:08:19 <hiptobecubic> ion, yes. it's a huge ugly and childish looking war and the debian packager is on the libav side. Do they still have that message that says "ffmpeg is dead" or something ridiculous?
10:09:16 <neutrino_> there's still a lot of hum
10:09:21 <neutrino_> you should put it through a comb filter
10:09:27 <edwardk> neutrino_: i'll wait until ion gives me an updated audio channel before remixing. the version with the ground loop hum will be going up in the meantime
10:09:30 <neutrino_> send me the audio later and i'll see what i can do
10:09:37 <neutrino_> ok
10:10:00 <neutrino_> the hum isn't distracting btw
10:10:03 <neutrino_> but it's easy enough to remove it
10:10:12 <neutrino_> so no reason not to
10:10:46 <edwardk> neutrino_: has the raw video and the first stab at fixing the audio
10:10:52 <edwardk> er http://comonad.com/~rickasaurus/
10:10:55 <edwardk> has the raw video
10:11:38 <edwardk> if you let your browser play the mp4 you can hear the hum is much more noticeable in the original
10:12:04 <edwardk> jump ~20 minutes in
10:15:04 <neutrino_> heading out. i can do this when i'm back.
10:15:34 <edwardk> k. i'll probably crash in a bit, but ping me if you get something =)
10:16:58 <neutrino_> edwardk: you know where to find me =)
10:17:04 <edwardk> hah
10:17:47 <neutrino_> :) ok i really have to go now :)
10:17:57 <neutrino_> s;ee
10:18:01 <neutrino_> sleep well
10:24:28 <mpu> How can I have function call in the expression parser built by Text.Parsec.Expr ?
10:26:44 <mpu> Ignore me, I just thought and found out.
10:27:24 <lispy> "If desired, a programmer can easily make functions and IO types into (vacuous) instances of Show, by providing an instance declaration." <-- Haskell 98 report
10:27:41 <lispy> I feel like that comes up sometimes. It's good to know the report writers deemed it reasonable.
10:27:55 <c_wraith> > print 5
10:27:57 <lambdabot>   No instance for (GHC.Show.Show (GHC.Types.IO ()))
10:27:57 <lambdabot>    arising from a use of ...
10:28:06 <c_wraith> Hmm.  When did lambdabot lose that instance?
10:28:26 <rwbarton> probably in the upgrade to 7.4, though that isn't very helpful
10:40:07 <foobaz_> hey I'm new to haskell, if I have a type Either a (Maybe b), how can get the Maybe b
10:40:42 <rwbarton> there might not be a Maybe b
10:41:28 <rwbarton> but: pattern matching is the most fundamental way
10:43:13 <hoolu> Hello! I often find myself wanting to map over a tuple, so I do something like map `foo $ map (\(a, b, c) -> [a, b, c]) tuple`. Is there a better way or am I missing something? It's a homogenuous tuple, of course, and it's a tuple because I want to encode the length in the type system so I can better reason about the code.
10:44:21 <S11001001> hoolu: there's a library providing newtypes for homogenous tuples and functors etc for those, I think
10:44:29 <rwbarton> @type each
10:44:30 <lambdabot> Not in scope: `each'
10:45:21 <hoolu> Ok, if I don't want to go into a world of extra libraries and things, is what I'm doing relatively sane? Not going to embarrass myself with that code?
10:45:36 <madhadron> hoolu, Maybe a little more detail?
10:45:43 <madhadron> Are these tuples of lots of different lengths?
10:45:57 <madhadron> Is there a maximum length?
10:45:59 <hoolu> No, a function returns three values, always three, so I use a tuple rather than a list
10:46:06 <hoolu> I'd then like to map over them for various things
10:46:17 <hoolu> I just found myself writing the same pattern match tuple to list again and again
10:46:31 <madhadron> hoolu: Then what you're doing is sane, but there's an even saner way
10:46:40 <madhadron> which is to make (a,a,a) an instance of Functor
10:46:57 <hoolu> Ah of course, but then why isn't that in the prelude?
10:47:10 <madhadron> hoolu, How do you define it for arbitrary length tuples?
10:47:12 <rwbarton> because "(a,a,a)" isn't a type
10:47:18 <rwbarton> with a variable a
10:47:25 <rwbarton> it's not of the form f a at all
10:47:38 <rwbarton> so it could never be a functor
10:47:42 <rwbarton> you would need a newtype wrapper
10:48:00 <hoolu> which is what that library does, and i'd need to tag all my tuples
10:48:04 <rwbarton> alternatively, your own data type
10:48:21 <rwbarton> data Hoolu a = Hoolu a a a deriving Functor
10:48:36 <madhadron> I'd consider a newtype wrapper or your own data type anyway if you're really returning the same thing everywhere
10:48:40 <hoolu> ah great i can even derive the functor?
10:48:55 <rwbarton> with a ghc extension
10:49:07 <Nereid> @let each3 f (a,b,c) = (,,) <$> f a <*> f b <*> f c
10:49:09 <lambdabot>  Defined.
10:49:14 <hoolu> It's like a function that splits a path into directory, name, extension, and then i want to map to change case or some shit
10:49:14 <Nereid> @type toListOf each3
10:49:16 <lambdabot> (a, a, a) -> [a]
10:49:36 <madhadron> hoolu, Ah. I would actually put a datatype around that for clarity
10:49:49 <Nereid> @type over each3
10:49:51 <lambdabot> (a -> b) -> (a, a, a) -> (b, b, b)
10:50:12 <madhadron> data PathishThing = PathishThing { path, name, extension :: String } deriving Functor
10:50:20 <madhadron> (that probably wont' work as written)
10:50:34 <fmap> that's kind error
10:50:34 * madhadron unfortunately doesn't have ghc on this machine, and currently has Ruby loaded in his head.
10:50:50 <rwbarton> no because there is no type variable to be functorial in
10:51:13 * hackagebot reform-blaze 0.1.1 - Add support for using blaze-html with Reform  http://hackage.haskell.org/package/reform-blaze-0.1.1 (JeremyShaw)
10:51:16 <madhadron> Right. Listen to them, not to the guy who is currently mentally corrupted.
10:51:47 <Nereid> use lens ;)
10:52:19 <edwardk> Nereid: in 3.8 you'll just be able to use 'each'
10:52:23 <rwbarton> I'm sort of skeptical that there are too many cases where it makes sense to apply the same function to directory, name, and extension
10:52:32 <Nereid> edwardk: I can use 'each' in 3.7 right now
10:52:41 <edwardk> oh yeah 3.7.1 had each in it
10:52:45 <Nereid> yeah 3.7.1.2
10:55:20 <hoolu> rwbarton: it's an example, i can be more precise and say that it's about splitting polygons into 3 separate polygons, but that's irrelevant
10:55:30 <rwbarton> ok
10:55:48 <hoolu> rwbarton: btw freenode says you're in manchester. can i ask if you use haskell in your job?
10:57:23 <rwbarton> it does?
10:57:48 <simpson> hoolu: That's only where the node he's connected to lives.
10:57:58 <rwbarton> anyways I just use Haskell for my personal projects
10:59:53 <elainebenes> Im interested in realtimesystems and normlly do that in C. im however also interested in haskell and i, to my surprise heard that a realtime os is written in haskell. that was surpirsiing to em considering haskell uses garbage collection. cant be hard realtime there... what is it caled and what platforms does it run on?
11:01:49 <shergill> elainebenes: where did you hear about it?
11:02:56 <Walther> BTW, would it be possible to generate raw sound with Haskell?
11:03:04 <madhadron> elainebenes: I know there's a language for realtime systems written on GHC that generates code (possibly C, but memory fails)
11:03:29 <Walther> I recently heard about C-oneliners that produce "music", but I was wondering if it would be possible to make a "8-bit instrument" with Haskell
11:03:58 <madhadron> elainebenes: On things like Lisp machines, there was usually a small core of assembly and a hunk of OS written in a subset that wasn't memory managed
11:04:00 <Walther> separate functions for separate sounds, generating e.g. square / sawtooth / sine waves, and mapping each function to a key
11:04:11 <madhadron> elainebenes: Unless you were on something like the Scheme chip which actually did garbage collection in hardware
11:04:31 <madhadron> Walther: There's some kind of output format which is getting piped somewhere.
11:04:41 <madhadron> Walther: You can certainly generate that format like you could in any language.
11:05:00 <Walther> and then the problem - playing multiple sounds at the same time
11:05:18 <madhadron> Walther: It's adding the signals, like in any other language. The math is the same.
11:05:24 <stepkut> Walther: there are a number of projects such as haskore and yampasynth..
11:06:00 <madhadron> stepkut: Please tell me that yampasynth is an FRP sound generator...
11:06:12 <stepkut> madhadron: yes
11:06:20 <stepkut> madhadron: realtime I believe
11:06:23 <madhadron> That makes my morning a little brighter.
11:07:11 <madhadron> And Ruby's insane behavior around inclusion order, code coverage, and unit testing is making it notably darker...
11:07:23 <stepkut> Walther: doing low-latency, realtime synthesis in Haskell can be a bit tricky because the pause-the-world garbage collection can take too long. But, for high latency, or non-realtime, Haskell is certainly very suitable for 8-bit synthesis
11:08:10 <elainebenes> http://mikeburrell.wordpress.com/2007/02/01/real-time-haskell/ <- is that even true about laziness? sure about gc but laziness
11:08:14 <stepkut> Walther: I have implemented a few proof of concept haskell synth things over the years.. though nothing too useful
11:08:29 <beaky> hello
11:08:59 <Walther> ...pause-the-world?
11:09:29 <tdammers> Walther: sweeping GC traditionally stops the main thread while doing its thing
11:09:40 <beaky> does haskell pause the world too?
11:09:42 <stepkut> Walther: the GHC runtime occasionally stops the app from doing anything at all while it does some garbage collection.. the pauses are short enough that you won't notice in most cases.. but when you only have 10ms to get stuff done.. it can be noticable
11:09:59 <tdammers> AFAIK, Haskell does that too, yes
11:10:15 <beaky> :(
11:10:17 <stepkut> to say 'Haskell' does is wrong... but GHC's runtime definitely does
11:10:34 <elainebenes> so whats the backside about his gc upper limit suggestion? that the memory will build and build and build...?
11:10:44 <tdammers> it can be done concurrently, and I think a few people are working on that, but I don't know of any industry-strength implementation
11:10:47 <Walther> is that in GHCI or any GHC-compiled program?
11:10:55 <stepkut> there were some experiments with non-pausing GC such as 'non-stop haskell'
11:11:08 <stepkut> doing non-stop + parallel GC is tricky business
11:11:14 <stepkut> someone should get a PhD :)
11:11:19 <beaky> lol
11:11:25 <madhadron> tdammers: A couple of the Scheme compilers do have concurrent GC, but their authors all commented that if they knew how hard it was, they wouldn't have done it.
11:11:37 <tdammers> madhadron: hehe
11:11:57 <tdammers> I thought I remembered someone on #haskell working on concurrent GC, can't remember who though
11:12:14 <madhadron> I think it was Ikarus among the Schemes
11:12:22 <stepkut> if I was going to try to do realtime synthesis using Haskell.. I think I would do something like what atom does, where you have an eDSL that you can use to generate a compile the actual code that does the synthesis, so that it can run predictably and with out (GHC's) GC
11:12:33 <madhadron> Though if you're doing realtime, you're much better off working in a language where you can assert memory allocation and collection statically
11:13:01 <tdammers> madhadron: that was my conclusion as well
11:13:17 <tdammers> as much as I love haskell, I picked C++ for my sampler
11:14:13 <madhadron> tdammers: A classic from the Lisp world is to generate the C you need for those pieces and write a control layer
11:14:30 <madhadron> Though again, if you have a Scheme chip, it's not an issue.
11:14:32 <ClaudiusMaximus> stepkut: that could work nicely with JACK - compile your eDSL to machine code and call it from the process callback which gets run in a realtime thread without any need for a ghc RTS
11:14:35 <madhadron> But no one does
11:14:44 <stepkut> ClaudiusMaximus: exactly
11:15:06 <sclv> using llvm for this stuff seems like it should be a mad win
11:15:11 <ClaudiusMaximus> stepkut: :)  add code hotswapping with sample-accurate timing, and it would be awesome
11:15:13 <sclv> so you can compile and link on the fly
11:15:59 <stepkut> madhadron: indeed. that is what makes 'atom' interesting.. it generates hard real-time code with static scheduling
11:16:06 <stepkut> ClaudiusMaximus: yup
11:16:19 <elainebenes> has some maniac ever written a big and useful program in brainfuck?
11:16:42 <tdammers> elainebenes: that, too, would be something I would write a compiler for, if I ever wanted to do it
11:16:46 <stepkut> ClaudiusMaximus: I imagine using something like the LLVM binding to generate the code on the fly
11:16:47 <ClaudiusMaximus> elainebenes: there was some text adventure game, lost kingdom (iirc)
11:17:13 * stepkut notes that sclv just said that
11:17:34 <nellthu> what does it mean when there is a function application inside a type declaration? for example: "myFun :: x -> f x"
11:17:43 <ClaudiusMaximus> elainebenes: i started a compiler targetting boolfuck and then wandered off after i got a working rot13
11:17:47 <Jafet> Lost Kingdom was not written in brainfuck
11:18:23 <S11001001> nellthu: well, that's a question that would take quite a lot of IRC lines to answer.  :)  In short, it's not a function application, it's a type application.  In long...
11:18:32 <stepkut> It would be cool, IMO to build a modular synth, and when you repatch the synth, it would generate an optimized synth via LLVM
11:18:35 <Jafet> http://www.muppetlabs.com/~breadbox/bf/factor.b.txt
11:18:49 <S11001001> nellthu: where are you looking at this?
11:19:33 <nellthu> S11001001: in a much more complicated article about 'forall' quantification :) do you want the link?
11:19:36 <stepkut> there was an operating system called "synthesis os" that used that idea.. generating optimized drivers on the fly
11:19:47 <S11001001> nellthu: no thanks
11:20:19 <nellthu> S11001001: i understand if the explanation is difficult - could you perhaps direct me to something on the web? you said it's type application?
11:20:54 <stepkut> "For example, in a normal OS when you open a file you get a handle which you pass to the Read function. In Synthesis, instead of a handle you get a version of the read function that is specialised for your particular file."
11:21:00 <S11001001> maybe https://en.wikibooks.org/wiki/Haskell/Kinds will suit, nellthu
11:22:11 <stepkut> combining LLVM generated code with bare metal Haskell would be pretty awesome
11:22:28 <nellthu> S11001001: i've read about kinds already, I didn't realize this has something to do with them. I'll read it through, thanks a lot!
11:22:51 <stepkut> in related news.. I want bare metal haskell / hOp / something of that nature for ARM please.
11:22:52 <Philippa> nellthu: just like Either Bool String is Either being applied to Bool, then String - Either is a type constructor, just as Bool and String are, but it's not nullary
11:23:38 <nellthu> oh so this "f x" means just that f is of kind * -> * and x is * ?
11:24:22 <Philippa> nellthu: yep
11:24:23 <nellthu> Philippa: I didn't think it's this simple :) ok, thank you!
11:24:27 <Jafet> f :: (k -> *), x :: k
11:24:35 <elainebenes> :t fix
11:24:37 <lambdabot> (a -> a) -> a
11:24:49 <S11001001> nellthu: as Jafet implies, it's not /quite/ that simple :)
11:24:50 <Philippa> Jafet: er, this probably isn't the time to introduce the new PolyKinds extension
11:24:55 <S11001001> :k Mu
11:24:56 <lambdabot> (* -> *) -> *
11:25:03 <S11001001> :k ()
11:25:04 <lambdabot> *
11:25:06 <S11001001> :k []
11:25:06 <elainebenes> > fix (a+)
11:25:07 <lambdabot> * -> *
11:25:08 <lambdabot>   a + (a + (a + (a + (a + (a + (a + (a + (a + (a + (a + (a + (a + (a + (a + (...
11:25:09 <Philippa> I mean, it's not that complicated until you use it? But
11:25:10 <S11001001> :k Mu []
11:25:12 <lambdabot> *
11:25:25 <elainebenes> > let f = fix (a+) in f 5
11:25:27 <lambdabot>   The function `f' is applied to one argument,
11:25:27 <lambdabot>  but its type `Debug.SimpleRef...
11:25:41 <coldpizza72i> \join #latex
11:25:47 <elainebenes> > fix (a+)
11:25:49 <lambdabot>   a + (a + (a + (a + (a + (a + (a + (a + (a + (a + (a + (a + (a + (a + (a + (...
11:25:51 <Jafet> @remember coldpizza72i \join #latex
11:25:52 <lambdabot> Good to know.
11:33:44 <nellthu> Philippa: S11001001: I got it now, thanks both of you
11:34:36 <elainebenes> > let fibs n = fix (\n -> if n > 0 then fibs (n-1) else 1) in fibs 5
11:34:40 <lambdabot>   mueval-core: Time limit exceeded
11:35:06 <elainebenes> how do i use fix?
11:35:23 <elainebenes> and when does it make sense to use it? anonymous recursive function? isnt that taking it to far?
11:38:28 <t7> elainebenes: did you mean to write cat cat cat... ?
11:45:15 <HaskAlot> Is it possible to make Applicative instance of a Category?
11:49:29 <lennart_> > fix (\f x y -> if x==0 then y else f (x-1) (y+1)) 27 15
11:49:31 <lambdabot>   42
11:53:42 <k0ral> hello there
11:54:31 <k0ral> I'm reading about template haskell, and apparently it is not possible to call a macro and use the code it generates in the same file, is it ?
11:57:16 <S11001001> k0ral: https://github.com/ekmett/lens/blob/master/examples/Turtle.hs disagrees with that
11:58:00 <c_wraith> k0ral: what's not possible is defining and using a splice in the same file
11:58:49 <plat0> Is there a tool to determine the strongly connected components of a Haskell module?
12:01:18 <HaskAlot> I mean, you can compose Applicative functors with (.) <*> f <*> g and identity would be pure id...
12:01:58 <HaskAlot> But I dont know how to make it into an instance of Category
12:03:53 <plat0> data AppCat f a b = f (a -> b)
12:04:03 <plat0> err, data AppCat f a b = AppCat (f (a -> b))
12:04:16 <plat0> Those are your morphisms
12:06:17 <elainebenes> > let f = (+1) in f 5
12:06:19 <lambdabot>   6
12:06:53 <roconnor> HaskAlot: what are the types of f and g?
12:07:54 <plat0> I think "(.) <*> f <*> g" should be "(.) <$> f <*> g"
12:08:19 <HaskAlot> Yea, I ment pure (.) <*> f <*> g
12:11:19 * hackagebot filesystem-trees 0.1.0.3 - Recursively manipulate and traverse filesystems as lazy rose trees.  http://hackage.haskell.org/package/filesystem-trees-0.1.0.3 (AdamCurtis)
12:13:36 <mvj4> [SBV/Z3] how would you represent an irrational value in the SBV smt solver module? I need pi as a constant.
12:14:52 <mvj4> maybe it's better to think of it as a constant which is eliminated, not sure if that works out though.
12:20:08 <mpu> Can I chain multiple postfix operators in the parsec module to parse expressions (e.g. I have a '.x' field acces in my language, I want to be able to do 'f.x.y')
12:23:47 <tdammers> mpu: yes, you can
12:24:11 <tdammers> a lot depends on what you want the parser to output though
12:24:23 <tdammers> e.g., you could do
12:24:38 <tdammers> manySepBy identifier dot
12:24:44 <tdammers> something like that
12:24:52 <tdammers> it would give you a list of identifiers
12:25:04 <tdammers> (provided you have defined identifier and dot already)
12:26:14 <mpu> tdammers: here is how I do it (and how it does not work) http://hpaste.org/79525
12:26:29 <tdammers> https://bitbucket.org/tdammers/hpaco/src/e98a36b02b79fc4e4db218907fa61eba299eafdb/hpaco-lib/Text/HPaco/Readers/Paco/Expressions.hs?at=master
12:26:32 <edwardk> https://www.youtube.com/watch?v=Q7l56Ryy8H8 has the raw video (with hum) for those who were asking earlier
12:26:34 <tdammers> ^ this is how I do it
12:26:58 <mpu> I take a look, thanks
12:28:01 <tdammers> I think the problem is that your postfix parser tries to recurse in a way that doesn't quite work out
12:28:45 <tdammers> hmm, no wait, that's not true
12:28:55 <mpu> The 'field' one does not recurse nor work after one indirection
12:29:25 <mpu> If I parse a.b.c I get that ast (. a b)
12:29:54 <tdammers> yeah
12:30:02 <tdammers> I remember having problems with postfix expressions too
12:30:15 <tdammers> if you look at my code, you'll see that I solved it using the `many` combinator
12:30:42 <mpu> I could do it by hand but I was happy to have this expression parser builder...
12:31:45 <atriq> Right, that takes 3 and a half minutes compiled
12:31:46 <lambdabot> atriq: You have 1 new message. '/msg lambdabot @messages' to read it.
12:31:52 <mpu> That is what you ended up doing
12:31:59 <tdammers> kind of
12:32:33 <tdammers> I could have folded the operators into one big structure, but at that point, I figured the code was clearer this way
12:32:46 <mpu> This Text.Parsec.Expr is not so 'production ready'...
12:33:08 <mpu> I would still prefer doing it in 20 lines...
12:35:32 <mpu> I will dive in Parsec guts to figure this out...
12:37:07 <mpu> Well that was not long to figure out...
12:37:40 <mpu> I quote "Prefix and postfix operators of the same precedence can only occur once"
12:37:59 <mpu> Understand here: I am screwed. This is stupid.
12:41:12 * roconnor 's noise canceling headphones doesn't remove the hum ;(
12:41:25 <ion> They’re not supposed to.
12:41:27 <johnw> roconnor: clearly you need hum canceling headphones
12:41:33 <roconnor> I know
12:41:42 <monochrom> what hum?
12:41:50 <roconnor> but all the background noise is gone to make the hum really stand out!
12:42:05 <hiptobecubic> roconnor, sounds nice
12:42:08 <djahandarie> The #haskell hum
12:42:57 <sclv> mpu: http://hackage.haskell.org/packages/archive/jmacro/0.6.3/doc/html/src/Language-Javascript-JMacro-QQ.html#dotExprOne
12:43:52 <sclv> you can mix and match a general expression parser with a special term parser for yr dots
12:47:03 <mreh> wah, I can't message beginners@haskell.org
12:47:33 <mreh> there isn't moderation is there??
12:47:49 <hiptobecubic> I think you must be subscribed
12:48:05 <hpaste> Moggle pasted “suggestions” at http://hpaste.org/79529
12:48:14 <Moggle> So I have some INCREDIBLY UGLY CODE HERE
12:48:20 <johnw> my suggestion: make it pretty
12:48:21 <mreh> hiptobecubic: I am
12:48:24 <Moggle> I would love it if anyone would care to comment on making it pretty
12:48:33 <mreh> lets see it then
12:48:57 <Moggle> If there are like, incredibly simple functions and stuff I'm missing out on here then it'd be great to know them
12:48:59 <Moggle> :P
12:49:08 <Moggle> you may want to actually just run said code
12:49:09 <elainebenes> I have implemented ghc in hardware, now im broke. but damn its fast
12:49:12 <johnw> it exceeds my "quick glance" threshhold
12:49:18 <Moggle> ah :P
12:49:22 <Moggle> i understnd johnw
12:49:29 <johnw> elainebenes: programs that don't work are the easiest to optimize
12:49:29 <tdammers> mpu: it does make sense though
12:49:29 <Moggle> I shall keep this code!
12:49:46 <Moggle> well, unfortunately this one works exactly as I want it to
12:49:46 <tdammers> it's the old undecidable --i++ problem
12:49:51 <Moggle> I shall keep it!
12:50:29 <Qett> is a recursive function that builds a list supposed to be much slower than a list comprehension?
12:50:36 <tdammers> Qett: no.
12:51:06 <Qett> hmm
12:51:11 <tdammers> show some code
12:51:18 <Qett> ok 1 sec
12:51:24 <tdammers> my bet is that they do subtly different things
12:52:17 <Moggle> Qett: if you're using ++ in the recursive function, it's going to be slower.
12:52:26 <Qett> oh
12:52:29 <Qett> yes i do use ++
12:52:35 <Moggle> Qett: use : then
12:52:36 <t7> use :
12:52:40 <Qett> i cant
12:52:42 <Moggle> as in, build a list like 1 : 2 : 3 : []
12:52:44 <Qett> i need to append to the end
12:52:49 <Moggle> Qett: then that's easy
12:52:52 <t7> nah think backwards
12:52:53 <Moggle> Just build the list inr everse order
12:52:53 <Qett> because i need to use functions like all and takeWhile
12:52:55 <Moggle> then reverse it
12:53:02 <Cale> OR
12:53:17 <Qett> http://hpaste.org/79530
12:53:26 <Cale> Instead of lists of type [a], use functions of type [a] -> [a] which add elements to the beginning of another list
12:53:30 <Cale> [] becomes id
12:53:35 <Cale> [x] becomes (x:)
12:53:40 <Cale> and (++) becomes (.)
12:53:41 <Moggle> oooh
12:53:50 <Moggle> do I detect a problem from project euler?
12:53:54 <hiptobecubic> Cale, you like that trick a lot, don't you?
12:53:54 <Qett> yes
12:53:58 <Moggle> :D
12:54:01 <Moggle> I like your solution!
12:54:05 <Moggle> It is much cleaner than mine for this one.
12:54:06 <mreh> that looks like a monoid
12:54:06 <Qett> i also have a list comprehension which is like 10x faster
12:54:23 <Cale> Since xs ++ ys takes O(length xs) time, but composition is always constant time, this tends to improve asymptotic complexity.
12:54:39 <Moggle> Qett: you probably don't need recursion for this. You could do something with a self-referencing list.
12:54:43 <S11001001> mreh: it is
12:54:48 <Moggle> Qett: Have you seen the infinite list for fibonacci numbers?
12:54:48 <Qett> yeah i have that
12:55:13 <Qett> im just trying to get similar performance with recursion
12:55:21 <johnw> Cale: are you talking about difflists?
12:55:29 <Cale> > let primes = 2 : filter isPrime [3,5..]; isPrime n = all (\p -> n `mod` p /= 0) (takeWhile (\p -> p*p <= n) primes) in primes
12:55:31 <lambdabot>   [2,3,5,7,11,13,17,19,23,29,31,37,41,43,47,53,59,61,67,71,73,79,83,89,97,101...
12:55:46 <S11001001> mreh: actually, given newtype EndoC c a = EndoC (c a b), you get instance Category c => Monoid (EndoC c a)
12:55:49 <t7> :t isPrime
12:55:50 <lambdabot>     Not in scope: `isPrime'
12:55:50 <lambdabot>     Perhaps you meant `isPrint' (imported from Data.Char)
12:55:55 <t7> cheat
12:56:21 <Cale> Qett: ^^ there's a cute mutually recursive list of primes
12:56:53 <S11001001> sorry that's c a a not c a b
12:56:57 <Cale> johnw: I'm not sure...
12:56:58 <Qett> Cale: yeah i also have basically the same thing in a list comprehension
12:57:21 <hpaste> Moggle pasted “Problem7” at http://hpaste.org/79531
12:57:28 <Moggle> That was my infinite list of primes.
12:57:33 <Moggle> Dunno if it helps any.
12:57:44 <johnw> Cale: http://www.haskell.org/haskellwiki/Difference_list
12:57:51 <johnw> uses composition just as you suggested
12:57:57 <Cale> Then yes
12:58:12 <Cale> I don't think I'd have called this trick "difference lists"
12:58:16 <Cale> But whatever :)
12:58:34 <Cale> It's often called the worker/wrapper transformation, but that's also a slightly silly name.
12:59:02 <Cale> It's just an instance of using another datatype on which the operations you want are faster.
12:59:49 <Cale> I guess it's a particularly nice one of those which happens to correspond to a monoid homomorphism
13:01:36 <elainebenes> would it be a terrible idea to write an ANSI C interpreter and offer it as a webapp? and do it in haskell?
13:01:57 <Qett> i guess if i need to go through a list both backwards and forwards i should use some other data structure?
13:02:11 <johnw> elainebenes: you could use language-c
13:02:13 <Cale> http://hackage.haskell.org/package/language-c
13:02:26 <johnw> that and Yesod and you could be parsing C in webpages before the day is through
13:02:44 <Cale> The interpreter part will probably take more time than that though :P
13:03:01 <johnw> that's why I said "parsing" :)
13:05:54 <Qett> wait so are difference lists faster than lists for appending?
13:06:01 <johnw> they are O(1) for appending
13:06:17 <johnw> but so are finger trees
13:06:28 <johnw> it depends on your overall usage pattern which you really want
13:06:44 <johnw> finger trees have an O(1) snoc operation also
13:06:47 <Cale> Finger trees are O(log k) append, where k is the length of the shorter piece.
13:06:53 <johnw> oh?
13:07:05 <johnw> oh, you are right
13:07:10 <johnw> they are O(1) cons, reverse, cdr
13:07:14 <johnw> O(log n) append and split
13:07:22 <Refried__> hey, could someone recommend some reading or guidelines on designing applications in terms of custom type classes (for OOP dummies)
13:07:24 <johnw> gotta remember that one
13:07:38 <Refried__> i'm sure i'm not thinking about the problem right
13:07:48 <hiptobecubic> Refried__, lesson one. Type classes != OOP classes
13:07:53 <Cale> Qett: Composition is about as fast an operation as you could possibly hope for. It requires a constant amount of work.
13:08:02 <Refried__> hiptobecubic: right.  what's lesson two? :-)
13:08:12 <johnw> also, for those wanting difflists: http://hackage.haskell.org/package/dlist
13:08:23 <Cale> I would never use the dlist package :P
13:08:27 <johnw> no?
13:08:31 <johnw> do tell
13:08:46 <Cale> Haskell already has very good support for functions :P
13:08:46 <Refried__> hiptobecubic: it's because they're so different that none of my instincts apply
13:08:58 <johnw> Cale: does Data.Sequence have O(1) append?
13:09:00 <johnw> http://stackoverflow.com/questions/10439821/haskell-datastruture-with-o1-append-and-o1-indexing
13:09:02 <hiptobecubic> Refried__, figure out how your problem would fit into the existing, well-known and supported typeclasses and models for computation
13:09:24 <Cale> johnw: It's a finger tree.
13:09:30 <johnw> ah
13:09:32 <monochrom> type class is not even type
13:09:43 <monochrom> whereas in java (for example) class is type.
13:09:44 <Cale> O(1) append and O(1) indexing is theoretically impossible
13:09:45 <hiptobecubic> Refried__, then after you've realized you probably don't need to design a whole slew of new type classes, just write the program using some monad transformers or something
13:10:01 <Qett> so how could i use function composition instead of appending to a list?
13:10:01 <Cale> No datastructure can exist with those properties together.
13:10:24 <Qett> Cale: what about a c array?
13:10:32 <Cale> Nope!
13:10:41 <Cale> C arrays have a horrible time to append
13:10:46 <Cale> Linear time
13:10:57 <monochrom> "expanding" an array requires copying
13:10:57 <hiptobecubic> in general
13:11:01 <Qett> if you keep track of the end of the array
13:11:06 <johnw> if you overallocate, then for the range of excess you have O(1) append and index
13:11:16 <johnw> but once you exceed it, you have to copy
13:11:23 <hiptobecubic> i think <vector> does some pre-allocation tricks to give you amortized O(1) behavior
13:11:28 <johnw> that's how std::vector works
13:11:31 <Qett> but you dont have to do it every time
13:11:36 <Qett> double the size or w/e
13:11:46 <tdammers> hiptobecubic: std::vector's append amortizes to O(log n) IIRC
13:12:14 <monochrom> ok, I agree that the amortized story sounds nice. but so does many pure-functional data structures. nice amortized story
13:12:21 <Cale> If you have a datastructure with unbounded size, then the lookup has to cost at least O(log n)
13:12:31 <Moggle> Question: I'd like to output a character that doesn't, uh, print anything. A null character? Is there such a thing?
13:12:51 <Cale> Unless you're cheating and it's periodic or something.
13:12:56 <hiptobecubic> Moggle, the null char?
13:13:07 <monochrom> '\0' exists or does not exist depending on who you're talking to
13:13:14 <Cale> But in O(1), you can only look at a bounded number of bits of your index.
13:13:15 <Qett> Cale: what about indexing the hash value for lookup
13:13:16 <Refried__> hiptobecubic: how can i figure out how my problem would fit into the existing well-known and supported typeclasses and models for computation?  I would accept some reading on that.
13:13:16 <Moggle> monochrom: I'll try that.
13:13:37 <Refried__> hiptobecubic: but keeping in mind that if I do need some new type classes, then i won't be able to fit it into existing ones :)
13:13:52 <Cale> Qett: Hashing doesn't help
13:14:06 <djahandarie> Cale, is there a proof for that somewhere?
13:14:14 <tdammers> Hashing helps until your data structure grows large enough to fill all the buckets
13:14:25 <tdammers> roughly speaking
13:14:26 <Cale> Any function which is capable of producing O(n) distinct results requires examining at least O(log n) bits of its input.
13:14:30 <monochrom> hash table inherits all array limitations. clearly.
13:14:48 <Cale> Right?
13:14:51 <Qett> true Cale
13:15:18 <Qett> usually memory indexing is considered o(1) though
13:15:22 <Cale> So it must take at least O(log n) time to compute
13:15:25 <Qett> but not for infinite lists i guess
13:15:28 <tdammers> memory isn't unbounded
13:15:31 <pmade> I'm trying to take the output of one library function which happens to be a Word8 ByteString and pass it to another library that takes a String.  unpack will give me [Word8] but I'm not sure how to turn that into [Char].
13:15:52 <Cale> tdammers: If you bound the amount of memory that your computer has access to, then every operation imaginable is O(1)
13:16:20 <Cale> So, it's not good to do that when discussing asymptotic complexity
13:16:28 <tdammers> hehe, yeah
13:16:30 <tdammers> point taken
13:18:10 <monochrom> pmade: I am just as unsure as you are. suppose you see this sequence of bytes in the bytestring: 0xc2, 0xa9. is that utf-8 and therefore one single Char ©?
13:18:40 <pmade> monochrom: in this case I know the ByteString only has ASCII values.
13:18:58 <Qett> what is another good functional language to learn?
13:19:02 <Qett> im thinking common lisp
13:19:02 <pmade> Does using `show' make sense?
13:19:08 <monochrom> ok, then you need the functions in Data.ByteString.Char8. add Lazy if that's what you're doing.
13:19:27 <monochrom> show never makes sense.
13:19:49 <pmade> monochrom: okay.  Thank you.
13:20:00 <atriq> pmade, he was probably joking
13:20:04 <atriq> Wait
13:20:07 <atriq> Missed the context
13:20:08 <atriq> Nevermind
13:26:23 * hackagebot web-plugins 0.1.2 - dynamic plugin system for web applications  http://hackage.haskell.org/package/web-plugins-0.1.2 (JeremyShaw)
13:26:25 * hackagebot reform-hsp 0.1.2 - Add support for using HSP with Reform  http://hackage.haskell.org/package/reform-hsp-0.1.2 (JeremyShaw)
13:26:35 <bananagram> .b 13
13:26:42 <bananagram> oops
13:28:43 <Yuu-chan> Qett: Ocaml
13:29:03 <elainebenes> why is ocaml so fast and haskell not?
13:29:30 <hiptobecubic> heh
13:29:40 <monochrom> because haskell doesn't specify speed
13:29:48 <atriq> elainebenes, because you are writing good Ocaml and poor Haskell, perhaps
13:31:40 <Yuu-chan> elainebenes: Ocaml is more low-level
13:32:54 <johnw> Qett: Common Lisp makes it too easy to be non-functional in your code when it gets inconvenient to be
13:33:09 <johnw> you end up writing imperative code and not realizing you left FP behind a while back
13:33:38 <johnw> aristid: everything is working great with mock_s3.py!
13:34:51 <aristid> johnw: cool
13:35:08 <aristid> johnw: were the bugs you thought there were not real in the end?
13:35:18 <Qett> johnw: what about erlang?
13:35:18 <Yuu-chan> johnw: isn't that the same in all non-pure FP languages?
13:35:37 <johnw> Yuu-chan: sure
13:35:47 <johnw> aristid: which bug?
13:35:56 <aristid> johnw: i don't remember precisely
13:36:00 <johnw> me either :(
13:36:15 <aavogt> johnw: chances are that happens in haskell too
13:36:16 <johnw> i did have to fix bugs in mock-s3, to get it to work with aws's expectations
13:36:19 <aristid> johnw: i do remember that you were changing too many things at the same time:P
13:36:24 <johnw> like, aws requires a Last-Modified header in all cases
13:36:33 * aavogt imports Data.IORef
13:36:41 * johnw unimports aavogt's Data.IORef
13:36:41 <aristid> well, real s3 does give a Last-Modified header always.
13:36:48 <johnw> yeah, and I'm fixing that in mock-s3
13:36:51 <johnw> sending them a pull request now
13:37:04 <johnw> at some future time I'll rewrite mock-s3 in Haskell, when we need "production grade"
13:37:12 <aristid> hah.
13:37:17 <Yuu-chan> btw, all my fellow lispers proudly say "It's not functional, its concept more than that!"
13:38:04 <Yuu-chan> but they take offence when I agree and exclude CL from the list of functional languages >_>
13:39:17 <aavogt> part of that offence has to do with the fact that nobody wants to be "disfunctional"
13:39:18 <johnw> aristid: https://github.com/jserver/mock-s3/pull/1
13:39:26 <johnw> that's what I need to fix, to match aws's expectations
13:39:33 <johnw> needed*
13:40:06 <johnw> i think it's dysfunctional
13:40:15 <aristid> johnw: the application/octet-stream thing we can do on aws' side
13:40:27 <johnw> aristid: that's probably a good idea
13:40:27 <aristid> i think not offering a Last-Modified on object requests is broken
13:40:53 <aristid> and... this is plainly a bug: https://github.com/jwiegley/mock-s3/commit/514d680d4c77288fc7dbe6a1d4e4a14ccd7b892b
13:41:03 <johnw> yeah
13:41:09 <johnw> surprised they never saw that one themselves
13:47:57 <Qett> Cale: so I would have to do (a ++) . (b ++) instead of a ++ b right?
13:48:34 <Qett> and then apply the result to [] for the final list
13:48:46 <shachaf> Yep, that's difference lists.
13:49:00 <Qett> ok i see
13:49:23 <Qett> doesnt really help in my case cause i need to evaluate the list in order to traverse it
13:49:27 <Qett> after every append
13:49:44 <Qett> right?
13:49:58 <shachaf> Difference lists are less helpful in that case in Haskell.
13:50:00 <shachaf> What are you doing?
13:50:08 <tromp> > sum [185259,124883,212365,137542]
13:50:10 <lambdabot>   660049
13:50:22 <Qett> http://hpaste.org/79530
13:50:26 <Qett> trying to speed that up
13:50:56 <Qett> the append seems to be what makes it much slower than a self-referencing list version
13:52:25 <Qett> using function composition for the append makes it about 10% faster
13:53:46 <S11001001> Qett: how about building it backwards and reversing when done?
13:53:55 <rhdoenges> yeah I think you
13:54:06 <rhdoenges> 'd have much better luck just by consing it up and reversing later
13:54:36 <Qett> i need to use functions like takeWhile and all
13:54:54 <rhdoenges> why??
13:55:22 <Qett> to go through the list and check if any of the numbers divide a number
13:55:36 <S11001001> Qett: you can use functions like dropWhile and all, and it'll work out just as well
13:55:44 <Qett> if you start from the smaller numbers you will hit a diviser much faster
13:56:10 <Qett> S11001001: no because you hit the condition much faster from that end of the list
13:56:19 <rhdoenges> hm good point
13:56:21 <Qett> in 99% of the cases
13:56:39 <S11001001> Qett: weighed against the cost of iteratively appending to the end?
13:56:52 <Qett> i measured the performance
13:57:02 <Qett> its almost exactly the same
13:57:04 <singpolyma> If I understand correctly, and monad transformer with a base monad of Identity is equivalent to that same transformer being fully polymorphic in base monad.  Is there any generic way to convert between the two?
13:57:18 <S11001001> I think your sqrt isn't getting thunked as is
13:58:21 <Qett> what do you mean S11001001 ?
13:58:53 <singpolyma> Any transformer that supports mapTransT (don't all of them?) I can do  mapTransT (return . runIdentity)
13:59:58 <Qett> ok ill use another variable for the sqrt of x
14:01:28 <Qett> same speed
14:02:45 <Yuu-chan> Can Haskell compilers optimize ([a1, a2] ++ someList) to (a1:a2:someList)?
14:03:24 <monochrom> dunno. I'll try GHC
14:04:18 <fmap> Yuu-chan: isn't that just inlining?
14:04:29 <shachaf> Yuu-chan: Unfortunately GHC doesn't do that.
14:04:35 <shachaf> It has trouble with recursive functions.
14:04:52 <shachaf> It won't even optimize (reverse []) into ([]) as far as I can tell.
14:05:18 <fmap> shachaf: would {-# INLINE (++) #-} help?
14:05:23 <shachaf> fmap: No.
14:05:33 <shachaf> Inlining recursive functions is tricky. :-)
14:05:37 <fmap> :[
14:06:10 <shachaf> fmap: We did this in lens, for example: https://github.com/ekmett/lens/blob/master/src/Control/Lens/Internal/Zipper.hs#L501
14:06:43 <aristid> hah
14:06:48 <monochrom> no, GHC -O and -O2 keep the ++
14:07:05 <shachaf> Even with [] ++ x
14:07:12 <shachaf> I wish it wasn't so.
14:07:19 <shachaf> This stops some other optimizations from happening.
14:07:55 <Yuu-chan> shacaf: thanks for the clarification
14:07:59 <fmap> shachaf: I guess all `f ... = as where as = ...' in Control.Lens.Fold are to help inling too?
14:08:05 <Yuu-chan> *shacaf, sorry
14:08:12 <fmap> s/inling/inlining/
14:08:13 <Yuu-chan> *shachaf >_<
14:08:22 <monochrom> no true, -O and -O2 both eliminates []++
14:08:35 <shachaf> @src (++)
14:08:36 <lambdabot> []     ++ ys = ys
14:08:36 <lambdabot> (x:xs) ++ ys = x : (xs ++ ys)
14:08:36 <lambdabot> -- OR
14:08:36 <lambdabot> xs ++ ys = foldr (:) ys xs
14:08:46 <shachaf> monochrom: Hmm, OK.
14:08:52 <shachaf> I must be thinking of a different case.
14:09:09 <shachaf> fmap: Where?
14:09:19 <monochrom> my test case is main = print ([] ++ repeat True). or replace [] by [True,False]
14:09:22 <shachaf> Oh, those help with sharing, not just inlining.
14:10:28 <shachaf> monochrom: In some cases it'll even inline (++) properly.
14:10:37 <shachaf> I must not have looked into it deeply enough.
14:10:49 <shachaf> At any rate in the code that I was looking at it didn't.
14:11:39 <shachaf> I mean it'll inline it for [1] ++ xs
14:12:33 <shachaf> Unfortunately it'll never manage reverse [] :-(
14:12:39 <shachaf> Unless I'm missing something..
14:12:44 <shachaf> s/.$//
14:14:30 <hamid> is pattern matching possible on functions? something like this:
14:14:37 <hamid> foo n (+) = n
14:14:47 <hamid> foo n (-) = -1
14:14:47 <Eelis> no
14:14:53 <Yuu-chan> Oh, if we're talking about optimisations, can somebody explain why didn't -funbox-strict-tuples work? I tried to do the exercise from the 25th chapter of RWH.
14:15:12 <hamid> hmm.
14:15:20 <Philippa> hamid: no, it's provably impossible. The best you could do is pass (function, FunctionID) pairs
14:15:41 <shachaf> Yuu-chan: unbox-strict-tuples?
14:16:10 <shachaf> Do you mean unbox-strict-fields or is that a different flag?
14:16:21 <hamid> ok thx
14:17:14 <monochrom> my question would be: how do you know it didn't work?
14:17:22 <Yuu-chan> Sorry, -fields of course, there was a tuple-like data type so I messed up things.
14:17:44 <Yuu-chan> monochrom: I read the Core output and didn't see the difference
14:18:00 <monochrom> then that's good evidence
14:18:04 <shachaf> Are you sure the file got recompiled?
14:18:14 <monochrom> heh, yeah, -fforce-recomp
14:18:14 <Ralith> @hoogle Word16 -> Word8
14:18:15 <lambdabot> Unsafe.Coerce unsafeCoerce :: a -> b
14:18:15 <lambdabot> Control.OldException throwDyn :: Typeable exception => exception -> b
14:18:16 <lambdabot> Control.DeepSeq ($!!) :: NFData a => (a -> b) -> a -> b
14:18:24 <Ralith> well that was unhelpful
14:18:30 <shachaf> @ty fromIntegral
14:18:31 <lambdabot> (Integral a, Num b) => a -> b
14:18:33 <Yuu-chan> shachaf: yes
14:18:35 <Ralith> kay
14:18:57 <shachaf> Yuu-chan: Well, I don't know what you were doing.
14:19:43 <shachaf> It works for me.
14:19:51 <shachaf> By "works" I mean "generates different Core".
14:23:05 <Skillson> So, what's going on in Haskell, guys? I haven't tried to participate in the community before. What is everyone up to?
14:23:42 <johnw> we're slowly porting to Java
14:24:05 <mikeplus64> say it ain't so :(
14:24:17 <ivanm> nah, Cobol ftw!
14:24:43 <Yuu-chan> shachaf: I tried again now and get the result needed :) I'm very sorry, probably I messed up something several times even then.
14:27:37 <Yuu-chan> The raw Core is... dazzling.
14:30:05 <Yuu-chan> Main.main7  :: GHC.Prim.State# GHC.Prim.RealWorld -> (# GHC.Prim.State# GHC.Prim.RealWorld, GHC.Prim.Any * #)
14:30:05 <Yuu-chan> Hey, somebody told me here that explaining the IO monad via transforming the RealWorld is a wrong thing.
14:30:07 <Ralith> @hoogle Word16 -> Int16
14:30:07 <lambdabot> Unsafe.Coerce unsafeCoerce :: a -> b
14:30:08 <lambdabot> Control.OldException throwDyn :: Typeable exception => exception -> b
14:30:08 <lambdabot> Control.DeepSeq ($!!) :: NFData a => (a -> b) -> a -> b
14:30:14 <Ralith> hm.
14:30:18 <Ralith> probably doesn't exist
14:30:26 <ivanm> Ralith: fromIntegral ?
14:30:28 <ion> ralith: fromIntegral
14:30:38 <Ralith> ivanm: close, but not quite
14:30:45 <Ralith> I want WordN -> IntN
14:31:08 <ivanm> yes, but it can do that, can't it?
14:31:15 <ivanm> > 5 :: Word16 -> Int16
14:31:17 <lambdabot>   No instance for (GHC.Num.Num (GHC.Word.Word16 -> GHC.Int.Int16))
14:31:17 <lambdabot>    arising...
14:31:20 <ivanm> or do you want the shifting, etc?
14:31:23 <Ralith> it can
14:31:27 <Ralith> I'm not sure how to express this
14:31:33 <ivanm> > (fromIntegral :: Word16 -> Int16) 5
14:31:35 <lambdabot>   5
14:31:38 <Ralith> well, let me un-XY myself
14:31:45 <Yuu-chan> > fromIntegral (maxBound :: Word16) :: Int16
14:31:45 <ivanm> Ralith: you want minBound :: Word16 to map to minBound :: Int16 ?
14:31:46 <lambdabot>   -1
14:31:55 <Ralith> I want a function that implements signed division on WordN
14:32:28 <Yuu-chan> unsafeCoerce (maxBound :: Word16) :: Int16
14:32:31 <Yuu-chan> > unsafeCoerce (maxBound :: Word16) :: Int16
14:32:32 <lambdabot>   Not in scope: `unsafeCoerce'
14:34:01 <Ralith> to do this, I had imagined sdiv :: Integral a => a -> a -> a; sdiv x y = fromIntegral $ (fromIntegral x) / (fromIntegral y)
14:34:08 <Ralith> except that's ambiguous, of course
14:34:16 <Ralith> but any explicitly provided constraint would be wrong.
14:34:34 <Ralith> ivanm: you see the problem?
14:35:06 <ivanm> yeah
14:35:16 <ivanm> Ralith: methinks you need to construct a type family
14:35:26 <ivanm> or some other kind of WordN -> IntN mapping
14:35:31 <Ralith> yeah
14:35:49 <Ralith> at which point I might as well just write out each incarnation of sdiv individually, since I only need this one place
14:35:52 <Ralith> oh well
14:36:20 <Yuu-chan> Ralith: how do you divide Integral numbers?
14:37:17 <Ralith> Yuu-chan: meant to write `div` there.
14:38:38 <mreh> how can I define a Storable instance for a C struct in lib whoes definition is not in the header file
14:38:45 <Jeanne-Kamikaze> heh
14:38:52 <Jeanne-Kamikaze> you don't
14:40:31 <mreh> I'm trying to do some FFI bindings, a function takes a Ptr (Ptr struct), and in a usage example I've got written in C, they define struct * s and pass in &s to the function
14:40:42 <mreh> does that mean I have to allocate a struct, or just the pointer
14:41:08 <Jeanne-Kamikaze> from the looks of it just a pointer
14:41:22 <Jeanne-Kamikaze> it seems like it'll allocate the struct for you and modify the double pointer
14:41:25 <mreh> bah, so why does it segfault for my binding!
14:41:32 <Jeanne-Kamikaze> show code
14:41:55 <mreh> i've been trying to send it to the mailing list for ages, one sec!
14:42:05 <Jeanne-Kamikaze> just hpaste if you wish
14:42:24 <mreh> https://github.com/mrehayden1/hmdfm/blob/master/dist/hmdfm-0.1.0.0.tar.gz
14:42:42 <Jeanne-Kamikaze> what's the file in question ?
14:42:54 <mreh> Spotify/Session.hsc
14:43:12 <Jeanne-Kamikaze> oh, there's no code in the repo ?
14:43:15 <Jeanne-Kamikaze> ok
14:43:18 <mreh> Jeanne-Kamikaze: not yet
14:43:28 <mreh> wanted to host it quickly
14:44:04 <Jeanne-Kamikaze> what should I be looking at
14:44:18 <mreh> the binding for sp_session_create
14:44:51 <mreh> you will need to install libspotify for it to compile
14:45:00 <mreh> it's very easy
14:45:01 <Jeanne-Kamikaze> not that I don't trust you but can you paste here the C declaration
14:45:15 <mreh> of the function?
14:45:19 <Jeanne-Kamikaze> yes
14:45:43 <mreh> sp_error sp_session_create (const sp_session_config *config, sp_session **sess)
14:47:03 <Jeanne-Kamikaze> I think the alloca + with is unnecessary
14:48:18 <Jeanne-Kamikaze> but it doesn't seem to hurt either, I don't see why this would fail
14:48:18 <mreh> Jeanne-Kamikaze: yes,
14:49:03 <mreh> alloca creates a pointer to the allocated object, so alloca + with gives you Ptr (Ptr a)
14:49:47 <Jeanne-Kamikaze> but a pointer is just a number
14:50:00 <alpounet> mreh, binding libspotify? nice! I actually started a binding too, a while back, never saw the light of day though
14:50:24 <Jeanne-Kamikaze> you can do alloca and pretend it's a Ptr (Ptr a), after all Ptr is also Storable, can't you ?
14:50:30 <mreh> alpounet: the office radio is so bad, and the jukebox example we've used is so bad and open to abuse :)
14:50:54 <mreh> Jeanne-Kamikaze: there's no storable instance for a in this case, so I can't
14:51:03 <alpounet> mreh, well, i generally use theirs clients though (windows, linux & android)
14:51:50 <hpaste> Jeanne-Kamikaze pasted “spotify thing” at http://hpaste.org/79534
14:51:58 <Jeanne-Kamikaze> ^ can you just try that for a moment ?
14:52:20 <mreh> that segfaults
14:52:48 <Jeanne-Kamikaze> let me check something else
14:53:09 <mreh> maybe it needs a Ptr to a null pointer?
14:53:41 <Jeanne-Kamikaze> as in its try to free an already existing session ?
14:53:49 <Jeanne-Kamikaze> *trying
14:54:18 <mreh> it should just be a straight translation of this code https://developer.spotify.com/technologies/libspotify/docs/12.1.45/jukebox_8c-example.html
14:54:28 <Jeanne-Kamikaze> ah wait
14:54:29 <mreh> see main for an example
14:54:58 <Jeanne-Kamikaze> yeah
14:57:07 <hpaste> Jeanne-Kamikaze pasted “spotify thing 2” at http://hpaste.org/79535
14:57:12 <Jeanne-Kamikaze> ^ try that mreh
14:58:26 <mreh> Jeanne-Kamikaze: same as before with session pointer changed to CInt?
14:58:32 <Jeanne-Kamikaze> yes
14:58:42 <Jeanne-Kamikaze> just give it a run
14:59:03 <mreh> seg fault :\
14:59:13 <Jeanne-Kamikaze> what is segfaulting exactly ?
14:59:30 <mreh> the call to the binding
14:59:33 <Jeanne-Kamikaze> the call to sp_session_create ?
14:59:36 <mreh> yeah
14:59:56 <Jeanne-Kamikaze> spconfig.application_key_size = g_appkey_size;
14:59:59 <Jeanne-Kamikaze> are you doing that ?
15:00:36 <Jeanne-Kamikaze> mreh, the first version of what I pasted should work, it must be something else
15:02:05 <quchen> What does 'web framework' mean when Haskellers talk about it? Today's 24 days post is about Snap, Yesod is feared and loved by various people, yet nobody ever says what those actually do
15:02:14 <quchen> Is that some term web people use a lot?
15:02:20 <rusty_charms> Is there a super-slick haskell function to turn [1,2,3,4] into [[1],[2],[3],[4]]
15:02:40 <ozataman> rusty_charms: map return xs
15:02:48 <ozataman> rusty_charms: assuming xs = [1,2,3,4]
15:03:03 <ivanm> ozataman: except (:[]) is usually better than return
15:03:10 <alpounet> singleton, too
15:03:13 <Jeanne-Kamikaze> mreh, still there ?
15:03:16 <mreh> Jeanne-Kamikaze: yeah
15:03:17 <ivanm> as there's no ambiguity, and it's shorter
15:03:17 <ozataman> ivanm: better in what way?
15:03:30 <Jeanne-Kamikaze> are you initialising the config correctly ? because I'm thinking it's that
15:03:47 <mreh> Jeanne-Kamikaze: just checking :)
15:04:03 <alpounet> ozataman = ozgun ataman?
15:04:08 <ozataman> yep
15:04:13 <ivanm> ozataman: if you use return somewhere to turn something into a singleton list and then change something, it could result in it being some arbitrary Monad and thus not type-checking
15:04:32 <ozataman> ivanm: I guess it could get confusing if you're not familiar with what's happening there
15:04:48 <ivanm> I mean even in refactoring
15:04:54 <ozataman> also a bit slower due to typeclass vtable lookup
15:04:57 <ivanm> (:[]) is shorter anyway
15:05:04 <ozataman> a bit uglier though for me :)
15:05:33 <ivanm> yeah, it is a bit
15:06:10 <Jeanne-Kamikaze> mreh, is it me or is 'g_appkey_size' defined internally in the libspotify api ?
15:06:14 <rusty_charms> While I'm at it, is there a less ugly way to do this lamda: (\(y:ys) -> (x:(y:ys)))
15:06:22 <rusty_charms> lambda
15:06:33 <ozataman> rusty_charms: why not just (x:)
15:06:35 <Jeanne-Kamikaze> it's declaring it as extern const, and it's nowhere in the example files
15:06:36 <rusty_charms> dahli lambda
15:06:47 <mreh> Jeanne-Kamikaze: no, it's in a C file they give you when you register a new app
15:06:50 <mreh> with your app key
15:07:03 <Jeanne-Kamikaze> keys have variable sizes ?
15:07:06 <ozataman> rusty_charms: you'd also avoid the irrefutable pattern match you have in your version
15:07:10 <mreh> Jeanne-Kamikaze: apparently so :)
15:07:22 <ivanm> rusty_charms: why do the pattern match on (y:ys) ?
15:07:26 <mreh> mine is 321 bytes
15:07:35 <ivanm> you don't need to "prove" it's a list ;-)
15:07:54 <Jeanne-Kamikaze> mreh, let's check your Storalbe instance
15:08:13 <rusty_charms> Just a n00b. I get frightened by compiler errors, so I make things explicit if I have doubt...like if a lambda needs to know that it is receiving lists of items as opposed to single items
15:08:23 <rusty_charms> @ ivanm
15:08:33 <bgamari> pcapriotti, ping
15:08:34 <ivanm> nah, don't do that
15:08:43 <simpson> :t ('a':)
15:08:45 <lambdabot> [Char] -> [Char]
15:08:47 <ivanm> for starters, it means that it won't work for empty lists
15:09:07 <rusty_charms> true....
15:10:06 <scooty-puff> i'm having trouble reasoning about i change i made to an algorithm that halved the runtime (while leaving the complexity the same - i would think)
15:10:39 <scooty-puff> the change was from explicitly recursion (in this case, in handling events - artificial, not-ui events)
15:10:52 <mreh> Jeanne-Kamikaze: I checked it by moving it in and out of a C struct
15:10:59 <scooty-puff> to using a Seq that would store up the actions to take, then have an explicit call to a "propagate" method
15:11:04 <Jeanne-Kamikaze> mreh, also check that your spconfig points to a valid key
15:11:23 <scooty-puff> https://github.com/sonyandy/fd/blob/master/src/Control/Monad/FD/Internal.hs#L404
15:11:53 <Jeanne-Kamikaze> by valid I mean valid memory address
15:16:03 <Jeanne-Kamikaze> mreh, I must hop to bed now. I'm pretty sure the session function is correct and that it's failing because of the config. Maybe debug the library call and see what part of the config it's accessing when it fails
15:17:50 <mreh> Jeanne-Kamikaze: even with a closed source library?
15:18:05 <mreh> or stick traces around the values?
15:19:02 <Jeanne-Kamikaze> just make sense of the assembly :D
15:20:21 <Jeanne-Kamikaze> like accessing the key would be something like: mov eax, [ecx+foo]; do something [eax], where ecx holds the address of spconfig (you can make the haskell program Debug.trace that)
15:20:48 <Jeanne-Kamikaze> figure out what foo is, and then figure out which field in the struct it corresponds too
15:20:50 <Jeanne-Kamikaze> and voila
15:20:56 <Jeanne-Kamikaze> *to
15:21:08 <pcapriotti> bgamari: pong
15:21:35 <Jeanne-Kamikaze> mreh, if you can't get around me tell me tomorrow, I find these things quite fun
15:21:36 <mreh> Jeanne-Kamikaze: okay, thanks
15:21:42 <Jeanne-Kamikaze> *around it
15:21:54 <bgamari> pcapriotti, optparse-applicative apparently doesn't build on ghc 7.0.4 due to TypeSynonymInstances
15:22:16 <mreh> Jeanne-Kamikaze: thanks for the help :)
15:22:17 <bgamari> pcapriotti, Given this extension is pretty superficial, do you think you could drop it for the time being?
15:22:40 <pcapriotti> bgamari: I think so, I'll have a look
15:22:46 <bgamari> pcapriotti, This is for https://github.com/colah/ImplicitCAD/pull/90
15:26:57 <pcapriotti> bgamari: I think that's already fixed in master
15:27:39 <pcapriotti> I'm planning to release 0.5.0 soon, so that should solve your problem
15:29:02 <mreh> @tell Jeanne-Kamikaze I was missing the user agent parameter!
15:29:02 <lambdabot> Consider it noted.
15:29:08 <mreh> thanks lambdabot!
15:29:20 <mreh> have a biscuit
15:29:25 <mreh> @botsnack
15:29:26 <lambdabot> :)
15:29:59 <Moggle> Question: how do you get the position of the cursor on the command line in Haskell?
15:30:05 <Moggle> Hopefully in a platform independent way.
15:30:12 <mreh> woohoo, one step closer to a cool radio app
15:30:34 <mreh> Moggle: what are you attempting to do
15:30:49 <Moggle> mreh: output a word, then delete it
15:30:52 <mreh> so complacent with my punctuation today
15:31:18 <mreh> i would rewrite the whole line with a CR char
15:31:38 <Moggle> mreh: the problem is the word is over multiple lines
15:31:54 <Moggle> mreh: as in, I output "underneath" and it prints out under then goes to the next line and prints neath.
15:32:06 <mreh> you'd have to fill the screen then
15:32:16 <Moggle> I have a solution to delete n characters on the line going backwards, but System.Console.ANSI complains when I try to move the cursor backward and I'm at the far left.
15:32:35 <Moggle> If I can get the cursor's current position on the column, I can check for 0 then move the cursor to the end of the previous line.
15:32:42 <Moggle> Unfortunately, I have no clue how to do that.
15:32:50 <mreh> me either
15:33:01 <Moggle> Perhaps there's a way to do exception handling in Haskell
15:33:03 <Moggle> :O
15:33:05 <Moggle> that could work
15:33:25 <mreh> @faq can haskell do exception handling?
15:33:26 <lambdabot> The answer is: Yes! Haskell can do that.
15:33:28 <mreh> great!
15:33:29 <Moggle> i could wait for an exception then BAM I know I'm at the far left
15:33:47 <Cale> Moggle: http://hackage.haskell.org/package/ncurses
15:36:10 <Cale> See also http://hackage.haskell.org/package/terminfo
15:40:19 <Moggle> thanks Cale
15:42:28 <rusty_charms> Alright....paranoid n00b question: Do any of you find that too much recursive programming makes you lose some or your imperative programming ability?
15:43:31 <Cale> rusty_charms: no
15:43:47 <Cale> rusty_charms: But also, recursive isn't what you want to be doing.
15:43:53 <Rembane> rusty_charms: It makes my imperative code interesting though.
15:44:38 <Cale> rusty_charms: Usually recursion is a last resort in Haskell. You really want to be writing things in terms of higher order functions.
15:44:58 <rusty_charms> Could be that many of you probably work in an imperative language, so you are "practicing" that 90% of the time, even if you tinker in haskell. It might be different if the ratio was reversed. A thought
15:45:00 <Cale> (those might be implemented recursively, but you shouldn't have to care)
15:45:26 <rusty_charms> yah, I do you use the library functions/higher order functions as often as I can
15:45:43 <Cale> rusty_charms: Who says Haskell isn't imperative? There's plenty of imperative programming involved in using the IO monad, and others :)
15:46:20 <Cale> In fact, Haskell is a really lovely imperative programming language, because you can take those chunks of imperative code and use purely functional code to glue them together into bigger things.
15:46:25 <rusty_charms> Cale: haha. Yah, and it feels dirty every time I have to "drop out" of normal haskell mode to do IO and other stuff
15:46:42 <Cale> It shouldn't, really.
15:46:46 <stepkut> I thought Haskell was the world's finest imperative language ?
15:46:58 <Cale> I mean, so long as you're doing I/O, it makes sense to use the IO monad to do that.
15:47:19 <shachaf> This channel should be called #haskell-propaganda
15:48:10 <stepkut> I only use the IO Arrow
15:48:23 <Cale> :)
15:48:25 <rusty_charms> Just trying to get perspective. I do have weird worries that getting too cozy with haskell will make my java suffer (getting out of uni and got a job as a java dev)
15:48:41 <Cale> rusty_charms: In all honesty, it will probably make your Java code better.
15:48:54 <stepkut> rusty_charms: your java will be fine.. your *willingness* to write java might suffer though
15:48:58 <rusty_charms> That's what I like to hear!
15:49:01 <rusty_charms> @ Cale
15:49:29 <clahey> I don't find myself wanting to use recursion when programming in other languages, but I do find myself wanting to use higher order functions.
15:50:17 <Cale> rusty_charms: There are things about structuring imperative OO code which are very hard to realise by programming in Java, say, and which take programmers years or decades to learn, but which are much more natural if you're used to doing things in a purely functional way.
15:51:13 <Cale> Things like strategies for minimising the number of pieces of state which can go out of sync with each other.
15:52:04 <rusty_charms> Cool. I picked up haskell because I wanted to get familiar with the 3rd party pardigm, but I can tell that it does change the way you think--as opposed to just being something neat or new.
15:52:59 <rusty_charms> Thanks for the help.
15:59:33 <mreh> what top level module should a spotify binding live in do you think?
16:02:09 <neutrino> Network
16:09:32 <cads> hey, have any of you guys ever tried to make a smart-phone into a bootable USB device?
16:09:32 <cads> that would be uber cool
16:10:37 <Moggle> Are there any ways to cut down on the generated exe size?
16:13:43 <profmakx> oarsum!
16:14:19 <Cale> Moggle: You can try -dynamic
16:14:47 <Cale> Moggle: The reason the executables are large is that all the libraries and runtime are statically linked
16:14:51 <Moggle> Cale: And that would not include the linked libraries with the exe? Seems like I'd have to
16:14:52 <Moggle> yeah
16:15:12 <Cale> So it's really more convenient just to ignore the size of the executable :P
16:15:51 <Cale> (after all, anything less than 100 MB is basically negligible these days)
16:16:51 <Cale> You have people running 4 GB games off of ram drives so the loading screens will be faster :)
16:18:55 <m_fulder> I would like to read a line using haskells IO and then save the read value into e.g. a list is this possible?
16:19:32 <Cale> Sure
16:19:46 <Cale> But what do you mean by "save into" :)
16:20:08 <Cale> You can't change a list, but you can make a new list from an existing one.
16:20:11 <lolcathost> m_fulder: If by "save into a <whatever>", you mean "take it out of IO <whatever>", nope.
16:20:31 <Cale> m_fulder: Try  replicateM 4 getLine
16:20:32 <lolcathost> m_fulder: You do not really want to take things out of IO.
16:20:35 <m_fulder> yeah I was hopening for something like take it out from IO
16:20:35 <cads> hey that's not a bad idee
16:20:49 <Cale> Don't use words like "take it out from IO"
16:21:00 <Cale> When you run an action of type IO a, you get a value of type a
16:21:13 <Cale> You can do this inside a do-block which expresses another IO action
16:21:30 <Cale> v <- x inside a do-block means "run the action x, calling its result v"
16:21:55 <Cale> So you can write  v <- getLine, and then v :: String, because getLine :: IO String
16:22:19 <Cale> i.e. To get a String from an action of type IO String, you run the action
16:22:41 <Cale> You can, say, recursively, run a bunch of actions, accumulating a list of results...
16:22:50 <m_fulder> ah I see .. hm so I can have a function returning a "pure" String while using do/IO functions? :O
16:23:09 <mreh> do we like MonadError as a nice way of documenting a function may fail?
16:23:49 <Cale> m_fulder: You can run any IO action from inside another IO action
16:23:50 <lolcathost> m_fulder: There is unsafePerformIO, but, really, do not use it, it is bad, when you use it, a baby dies
16:24:06 <Cale> lolcathost: No need to even mention unsafePerformIO here
16:24:09 <Iceland_jack> lolcathost: why mention it?
16:24:12 <mreh> exactly!
16:24:23 <m_fulder> yeah localhost I have heard of it .. I don't really see the idea of creating a function in haskell that you cannot use :P
16:24:24 <Cale> mreh: It's better than using Monad.
16:24:44 <mreh> Cale: indeed!
16:25:06 <lolcathost> m_fulder: The whole point of IO is separating real-world-effecting code from referentially transparent code.
16:25:31 <lolcathost> m_fulder: If you do not want to establish a distinction between those, then switch to a different language.
16:25:33 <Cale> m_fulder: unsafePerformIO is like a way to avoid the rare case that you'd otherwise have to modify the Haskell compiler to extend the evaluation model.
16:26:01 <Cale> It can be useful when implementing primitive data structures, for example, but it requires a great deal of care.
16:26:04 <m_fulder> aha I see ok won't use it then
16:26:14 <Cale> (and an understanding of what the compiler's going to do with it)
16:27:06 <Cale> m_fulder: So, basically, you can only run IO actions from inside other IO actions.
16:28:03 <mreh> halp, I r trapped inside IO monad
16:28:04 <Cale> Let's take a look at sequence, which is a function that will take a list of IO actions, and produce an IO action that'll run each of them in turn, producing a list of the results (when run)
16:28:20 <mreh> night all
16:28:29 <Cale> sequence [] = return [] -- if the list of actions to run is empty, we give the action which does nothing except to return an empty list.
16:28:59 <Cale> sequence (x:xs) = do v <- x; ... -- if the list of actions is nonempty, we run the first action, getting a result v, and then...
16:29:24 <Cale> sequence (x:xs) = do v <- x; vs <- sequence xs; ... -- we run the rest of the list of actions, getting a list of results vs...
16:29:27 <m_fulder> then run the rest of the actions?
16:29:29 <m_fulder> yeah
16:29:36 <Cale> sequence (x:xs) = do v <- x; vs <- sequence xs; return (v:vs) -- and finally put the whole list of results together
16:30:15 <Cale> This is a sort of primitive loop -- if we can decide ahead of time what the iterations of our loop will be doing, we can use sequence to glue them together
16:30:24 <m_fulder> but still that would give me something like IO [a] right?
16:30:27 <Cale> right
16:30:35 <Cale> sequence :: [IO a] -> IO [a]
16:30:41 <m_fulder> yeah
16:30:58 <Cale> (actually, it's more general, and works in any monad, but we won't worry about that)
16:31:14 <Cale> :t sequence
16:31:15 <lambdabot> Monad m => [m a] -> m [a]
16:31:32 <Cale> But you shouldn't be too scared if you see types like that. You can imagine the m replaced by IO if you like
16:32:00 <m_fulder> ah yes
16:32:05 <Cale> The reason I mention that is that there are a lot of handy control-structure like things in Control.Monad for constructing IO actions.
16:32:35 <Cale> So in terms of sequence, we can write
16:32:43 <Cale> mapM f xs = sequence (map f xs)
16:33:00 <Cale> or perhaps even more suggestively,  forM xs f = mapM f xs
16:33:07 <Cale> This is like a for-each loop
16:33:29 <Cale> For each of the elements of xs, we apply our "loop body" f to it to get an action to perform
16:33:38 <Cale> and it runs all the actions and gives us a list of the results
16:34:04 <Cale> forM [1..3] $ \x -> do print x; getLine
16:34:16 <monochrom> use hugs to reduce executable size
16:34:18 <Cale> You can try something like that in GHCi, after import Control.Monad
16:34:34 <m_fulder> hm but I don't see how that solves my problem .. I still would be stuck with a IO [a] list and what I wanted to do was to save a read value from the terminal into a list of [a]
16:34:58 <Cale> m_fulder: Well, suppose you take a list of the values read so far as a parameter
16:35:35 <m_fulder> ok :P
16:35:36 <Cale> You can read a value from the terminal, and then call your function with a new list of values which has that value added to it
16:36:24 <Cale> foo 0 xs = print xs; foo n xs = do x <- getLine; foo (n-1) (x:xs)
16:36:39 <Cale> Try that with, say, foo 3 []
16:36:59 <Cale> If you really genuinely want a mutable cell, there are also IORefs
16:37:00 <m_fulder> ooh I see lets try
16:37:12 <Cale> But you should understand how this way works too
16:37:16 <m_fulder> yeah
16:39:14 <BMeph_> Does anyone know of a language with Haskell-like syntax, but with a moreML-ish type/module system?
16:39:51 <Cale> m_fulder: If you have any imperative program for computing some pure function using a finite set of mutable state variables, you can turn it into a purely functional one by making a function for each statement whose parameters are the current values of the variables, and where control flow in the imperative program is represented by calling the appropriate function with whatever the new values of the variables are.
16:40:18 <hpc> BMeph_: ML?
16:40:19 <Cale> m_fulder: In fact, I've often done this in order to understand the behaviour of complicated or obfuscated imperative programs.
16:40:19 <hpc> :P
16:40:51 <Cale> (because although the initial translation produces a mess, you get a nice bunch of equations out of it which you can use to simplify things in a systematic way)
16:40:54 <BMeph_> hpc: Then the next question becomes: _Which_ ML? ;þ
16:41:18 <m_fulder> ah I see nice
16:42:18 <hpc> BMeph_: https://en.wikipedia.org/wiki/ML_postcode_area -- that one
16:43:24 <hpc> (honestly i have no idea; ML is THE family of haskell-syntax languages though)
16:43:31 <monochrom> SML has ML-ish type system and module system, and Haskell-like syntax. just swap :: and :
16:43:33 <Cale> https://en.wikipedia.org/wiki/File:ML_postcode_area_map.svg  OUR AREA IS BIGGAR
16:44:17 <liyang> https://en.wikipedia.org/wiki/HS_postcode_area ?
16:44:43 <hpc> @remember Cale https://en.wikipedia.org/wiki/File:ML_postcode_area_map.svg  OUR AREA IS BIGGAR
16:44:44 <lambdabot> It is stored.
16:56:43 <m_fulder> Cale, another question then .. can I somehow call a IO function from another function without changing the function type ?  i.e. I want to do something like   myFunc Int->Int   myFunc a = callIO AND_ALSO a+a
16:57:09 <Cale> m_fulder: No, you can only execute IO actions from inside other IO actions
16:57:28 <Cale> m_fulder: but you can apply pure functions to values inside IO actions
16:57:57 <m_fulder> ah I can :O
16:57:57 <Cale> For example, consider the program  main = do x <- getLine; putStrLn (reverse x)
16:58:11 <Cale> reverse certainly doesn't have to be aware that IO is happening
16:58:56 <m_fulder> yeah hm thats true
16:59:09 <hpc> and don't mistake that to think you can pull a String out of IO that way
16:59:17 <neutrino> hi Cale :)
16:59:25 <hpc> (>>=) doesn't say "here's a thing", it says "tell me what you want done with this thing"
16:59:29 <Cale> hpc: But you can, sort of!
16:59:46 <ivanm> how does one write type-sigs involving ST?  Specifically, I can't even get "Control.Monad.ST.runST . Data.Vector.Mutable.new" to typecheck :s
16:59:57 <neutrino> hpc:whaaat
16:59:58 <m_fulder> yeah hpc I think I understand that =)
17:00:13 <Cale> You can't write a function IO String -> String that works that way
17:00:40 <Cale> But you can compose your program in such a way that things which come from IO are parameters, and you have a pure result
17:01:09 <Cale> and then write an IO action which actually does whatever I/O is required to get the parameters, and does whatever is entailed by the result
17:01:25 <neutrino> hey guys
17:01:28 * hackagebot hosc 0.13 - Haskell Open Sound Control  http://hackage.haskell.org/package/hosc-0.13 (RohanDrape)
17:01:34 <neutrino> i've read spj's stm paper
17:01:38 <Cale> If you're familiar with Model/View/Controller, it's kind of like the split between Model and View/Controller
17:01:51 <m_fulder> yeah I know that
17:01:52 <neutrino> from oopsla 05, the one which explains it down to the C details
17:02:01 <neutrino> what other stm papers are worth reading?
17:02:29 <hpc> :t Control.Monad.ST.runST . Data.Vector.Mutable.new
17:02:31 <lambdabot>     Couldn't match expected type `forall s. ST s b0'
17:02:31 <lambdabot>                 with actual type `m0 (Data.Vector.Mutable.MVector
17:02:31 <lambdabot>                                         (Control.Monad.Primitive.PrimState m0) a0)'
17:02:37 <hpc> :t Data.Vector.Mutable.new
17:02:39 <lambdabot> Control.Monad.Primitive.PrimMonad m => Int -> m (Data.Vector.Mutable.MVector (Control.Monad.Primitive.PrimState m) a)
17:02:48 <c_wraith> is there a paper on Clojure's STM implementation, with MVCC? That's a feature GHC's STM doesn't have.
17:03:07 <c_wraith> hpc: the problem is (runST .)
17:03:15 <alpounet> neutrino, i think if you know the way it works and how to use it, you're good to go :)
17:03:19 <hpc> :t (Control.Monad.ST.runST .)
17:03:21 <lambdabot> Functor f => f (forall s. ST s b) -> f b
17:03:21 <c_wraith> :t (runST .)
17:03:22 <alpounet> experiment now!
17:03:23 <lambdabot> Functor f => f (forall s. ST s b) -> f b
17:03:31 <c_wraith> :t (runST Prelude..)
17:03:33 <lambdabot> (a -> forall s. ST s c) -> a -> c
17:03:41 <neutrino> what is mvcc?
17:03:43 <luite> does clojure stm have multiple isolation levels?
17:03:56 <hpc> c_wraith: it works just fine, but you can't let the s out
17:04:15 <luite> neutrino: multi-version concurrency control
17:04:31 <neutrino> hmm, what does that do?
17:04:44 <pqmodn> :t (runST Prelude.$)
17:04:44 <luite> neutrino: where multiple consistent version can exist at the same time. useful if you have lots of readers that shouldn't block writers, but readers need a consistent view
17:04:46 <lambdabot> (forall s. ST s b) -> b
17:04:50 <c_wraith> hpc: It won't work just fine in GHC if you get big enough expressions with (.) and ($). keeping the forall through them requires impredicative instantiation
17:04:59 <pqmodn> i think impredicative types are enabled..
17:06:28 * hackagebot hsc3 0.13 - Haskell SuperCollider  http://hackage.haskell.org/package/hsc3-0.13 (RohanDrape)
17:06:30 <c_wraith> neutrino: more or less, MVCC freezes the environment when a transaction starts.
17:06:41 <c_wraith> neutrino: as far as that transaction is concerned, anyway.
17:07:15 <c_wraith> neutrino: It's the equivalent of enforcing repeatable reads (iirc) in a database transaction
17:07:15 <neutrino> how is that different from what haskell's stm does?
17:08:08 <fryguybob> neutrino: You can have overlap of transactions that might not be suitable for some situations, but gives better performance when it is alowable.
17:08:46 <neutrino> can you give me an example?
17:08:49 <c_wraith> m1 = do { x <- readTVar t1 ; y <- readTVar t2 ; return $ x + y }      m2 = { writeTVar t1 5 }
17:09:13 <c_wraith> then running those two expressions such that the write in m2 happens between the two reads in m1
17:09:26 <c_wraith> err, wait, I meant t2, not t1, in m2
17:10:09 <m_fulder> Cale though in Model/View/Control they all can somehow contact and change variables/stuff in eachother .. in IO it seems kind of hard to change a variable/list Im using in other functions
17:10:15 <c_wraith> If it does the write before m1 does the read, m1 will never know that t2 was updated during the transaction
17:10:31 <c_wraith> in GHC's STM, that is.
17:10:35 <neutrino> yeah
17:10:38 <neutrino> and in mvcc?
17:11:07 <c_wraith> it will read the value that was set in t2 when the transaction started
17:11:30 <c_wraith> and when the transaction completes, it will check for conflicts
17:11:44 <Cale> m_fulder: In model/view/controller, the model is supposed to be a declarative specification of how inputs correspond to outputs and changes in state -- this is pretty much what a pure function is.
17:11:50 <neutrino> so what happens if we have m1 and m2 executing at the same time?
17:12:03 <Cale> m_fulder: The view and controller do all of the actual carrying out of effects
17:13:01 <c_wraith> I think in MVCC, it *should* result in no retries since there's no actual conflict between those two transactions
17:13:15 <m_fulder> Cale, hm yeah that's true
17:13:39 <c_wraith> But the result will be that you can describe a serial order for the transactions that would result in exactly the same results
17:13:43 <c_wraith> which isn't true without MVCC
17:14:04 <c_wraith> (that is, MVCC gives you the equivalent of SQL's serializable isolation level, IIRC)
17:14:44 <neutrino> no idea what serializable isolation level is though
17:14:51 <neutrino> ok, what is a "serial order"?
17:15:29 <c_wraith> it just means there is an order you could run the transactions in serially (no concurrency at all) that would give absolutely identical results to what you got running them concurrently
17:16:19 <neutrino> ahhh
17:16:58 <c_wraith> You can find examples with GHC's STM that can give results when run concurrently that they couldn't get if run serially.
17:19:34 <c_wraith> My example wasn't great, because the pair of transactions I offered can always be serialized
17:20:06 <c_wraith> It takes more complex examples to find things that can execute in ways that are inconsistent with serial execution
17:38:40 <m_fulder> can I somehow have pattern matching at a same function name but have different types on both function calls? Like:  myFunc (type1 var) = 10  myFunc (type2 var) = "aa"
17:39:12 <ivanm> m_fulder: that's what type classes are for
17:39:16 <ivanm> or sum-types
17:39:29 <ivanm> data Foo = Bar Int | Baz String
17:39:43 <ivanm> (depending exactly what you want to do)
17:41:13 <m_fulder> yeah hm the thing is ... I want to call function from the first type and then just print something using IO at the second call
17:41:44 <ivanm> yeah, that doesn't sound like a good idea
17:42:18 <JoeyA> Just wondering, does GHC have something like asyncDoProc for non-Windows?
17:42:19 <ivanm> unless you have a type-class where the method has a monadic result
17:43:15 <JoeyA> asyncDoProc executes a callback on a separate OS thread, for when -threaded is off.  Used to keep some blocking I/O operations from blocking the whole RTS.
17:44:18 <stephenjudkins> any chance it will be possible to declare new types in ghci some day?
17:44:22 <stephenjudkins> it's very frustrating to be unable to
17:44:33 <JoeyA> GHC 7.6 lets you
17:44:35 <shachaf> stephenjudkins: It is possible today.
17:44:45 <shachaf> I think even GHC 7.0 lets you.
17:44:54 <stephenjudkins> shachaf: aha!
17:45:01 <stephenjudkins> the internet is wrong. upgrading now...
17:47:55 <mpu> When using parsec, my parse error often look like "unexpected 'r' ..." while I would like to have "unexpected keyword 'return'", do you know how I can change this?
17:49:01 <mpu> (It seems to be related to the fact that my tokens are just chars, but this is what is encouraged by the parsec API, so there should be way to fix it)
17:50:27 <hpc> see (<?>)
17:52:18 <parcs> mpu: use Text.Parsec.Token
17:53:19 <mpu> parcs: I do
17:53:37 <mpu> hpc: It changes the 'expected' not the 'unexpected'
17:54:42 <mpu> An example is the the erroneous "f(x) return 42;" where a ';' is missing after "f(x)"
17:54:56 <mpu> There I will get "unexpected 'r'"
17:56:29 <mpu> parcs: The 's' in the Parsec instance is still String with this. (Meaning that my granularity is Char)
17:57:09 <m_fulder> ivanm: hm so there's no way I can have two functions where one is IO and another return a list ? a list should be a Monad so it should work somehow?
17:57:12 <Ralith> parcs: parsec's token stuff is fairly useless...
17:57:30 <Ralith> mpu: tokenize, then parse a stream of tokens instead of a stream of chars
17:57:48 <ivanm> m_fulder: that can work
17:58:08 <mpu> Ralith: You mean that I must drop this Text.Parsec.Token stuff...
17:58:17 <Ralith> yes
17:58:24 <ivanm> class (Monad m) => Foo v m a | v -> m, v -> a where bar :: v -> m a
17:58:30 <hpc> you would do two passes of parsec, as it were
17:58:36 <parcs> mpu: yeah, but the combinators provided by Text.Parsec.Token provide friendly error messages
17:58:42 <ivanm> instance Foo String IO () where bar = print
17:58:51 <mpu> parcs: apparently, no...
17:58:54 <ivanm> instance Foo Int [] Int where bar = (:[])
17:58:59 <ivanm> m_fulder: ^^
17:59:04 <parcs> mpu: which combinator are you using that is failing?
17:59:49 <parcs> on the contrary i think the Token module is really useful and convenient
17:59:59 <mpu> parcs: I told you my problem below, but I think that it is what I feared, I need a proper lexer and this is not provided by Parsec.
18:00:06 <mpu> sorry, above.
18:00:12 <Ralith> mpu: http://legacy.cs.uu.nl/daan/download/parsec/parsec.html#SeperateScanners
18:00:34 <Ralith> parcs: it's useful and convenient if you happen to be parsing haskell source.
18:00:36 <parcs> mpu: what does your parser look like?
18:00:40 <Ralith> that's not a very common need
18:01:08 <mpu> parcs: I parse a C like language
18:01:24 <mpu> It works fine, I am just a bit unsatisfied with error messages.
18:02:36 <mpu> And, for instance I have to explicitely skip spaces before calling my main parser and this makes me feel like there is no clean separation between lexer and scanner.
18:03:00 <hpc> scanner?
18:03:02 <Ralith> mpu: see the link I gave you.
18:03:08 <mpu> sorry, parser
18:04:05 <mpu> Ralith: But then I have to define a 'Stream' instance and use low level Parsec functions. I am not very eager to do this...
18:04:34 <Ralith> mpu: if you spend two minutes reading the link I pasted, you'll see that it's very easy.
18:05:47 <mpu> Ralith: I read it, I was aware of it, maybe I will end up writing the lexer by myself.
18:06:10 <Ralith> then I don't know what you're scared of
18:06:34 <mpu> I am not scared, just lazy. I don't want to write this lexer :)
18:06:49 <mpu> I thought I could have better support from what already exists.
18:07:25 <Ralith> parsec isn't the best lib to use at all if you want nice error messages
18:07:46 <Ralith> @hackage trifecta
18:07:46 <lambdabot> http://hackage.haskell.org/package/trifecta
18:08:04 <mpu> I just want 'not too ugly' ones :). And it has the advantage of being in the platform.
18:08:40 <mpu> Woo, colored messages!
18:09:30 <jmcarthur> nice error messages. no documentation.
18:09:41 <jmcarthur> don't get me wrong. i love the library
18:09:46 <mpu> he... Maybe it is not too far from Parsec.
18:09:47 <jmcarthur> it's just a warning
18:09:48 <parcs> meh, parsec has better error messages than ghc does :P
18:09:54 <jmcarthur> it's not too far from parsec, indeed
18:10:26 <mpu> Anyway I kind of dislike this "unexpected 'r'"...
18:11:01 <parcs> doesn't it later say "expecting ';'" ?
18:11:23 <mpu> parcs: It does.
18:13:46 <shachaf> Does #haskell want a fun puzzle?
18:13:48 <shachaf> I have
18:13:49 <shachaf> class Weird g where foo :: (b -> t) -> ((a -> b) -> s -> t) -> (g a -> b) -> g s -> t
18:13:52 <shachaf> instance Weird Identity where foo mk mp f = mp (f . Identity) . runIdentity
18:13:54 <shachaf> instance Weird Proxy where foo mk mp f = mk . f . coerce
18:13:56 <shachaf> What class should Weird be?
18:14:05 <shachaf> (data Proxy a = Proxy; coerce :: Proxy a -> Proxy b)
18:16:20 <hpc> is this a naming puzzle?
18:16:44 <parcs> that's not a very fun puzzle
18:17:10 <hpc> i... think Weird is actually just Comonad
18:17:38 <shachaf> hpc: Comonad?
18:17:50 <shachaf> The puzzle is, what is Weird, *really*?
18:17:58 <shachaf> For example, previously I had
18:18:21 <shachaf> class Soy g where soy :: (b -> t) -> (s -> a) -> (g a -> f b) -> g s -> f t
18:18:26 <shachaf> instance Soy Identity where ...
18:18:35 <shachaf> instance Soy Proxy where ...
18:18:51 <shachaf> It turned out the class I was really after was just Functor
18:19:28 <ivanm> with MVector, is the only real way to do a map over the elements to do a read then write for every possible index?
18:19:35 <shachaf> Then I had class Blah g where blah :: Pointed f => (b -> t) -> (s -> Either t a) -> (g a -> f b) -> g s -> f t
18:19:41 <shachaf> It turned out that Blah was just Costrong
18:19:52 <shachaf> So I want to know what Weird is.
18:20:04 <hpc> ivanm: do you want to mutate the vector or make a new one?
18:20:20 <hpc> (the answer for both of those is "yes", but for different reasons)
18:20:42 <hpc> or i suppose actually the same reason
18:21:26 <ivanm> well, mutating is the whole point of using MVector, right? :p
18:21:59 <copumpkin> would you expect a mapMVector :: MVector IO a -> (a -> a) -> IO () ?
18:22:08 <ivanm> oh, wait, I can't just mutate it if the type is different
18:22:10 <ivanm> duh
18:22:30 <ivanm> so I need to allocate a new vector, then apply the mapping function
18:22:40 <shachaf> copumpkin: Naturally I'd expect mapMVector :: Monad m => (a -> m b) -> Vector a -> m (Vector b)
18:23:00 <ivanm> that works as well
18:23:00 <copumpkin> shachaf: mutably?
18:23:25 <copumpkin> one reason you don't get all those combinators on mutable vectors is that you can write them, and they aren't really composable
18:23:36 <hpc> some kind of linear type system would be neat for those sorts of vectors
18:23:41 <hpc> so you could mutate into another type
18:23:49 <jmcarthur> huh, it occurs to me that array recycling probably works across different types when they are just newtypes with the same underlying type
18:24:08 <shachaf> coumpkin: No, just a pun. :-(
18:24:08 <ivanm> copumpkin: so I might as well freeze, then map purely and then thaw?
18:24:37 <copumpkin> ivanm: up to you, I'd avoid mutable vectors in the first place except for occasional mutable construction
18:25:04 <copumpkin> you lose all the fusion benefits with mutability
18:25:06 <jmcarthur> yeah, i've found that i almost never really want mutable arrays
18:25:16 <shachaf> Is it possible to write a function :: (Ord a, Ord b) => ((Set a -> a) -> Set b) -> Set b?
18:25:38 <ivanm> copumpkin: hmmmm....
18:25:53 <hpc> shachaf: no
18:26:05 <hpc> there doesn't exist a (Set a -> a) function
18:26:13 <shachaf> hpc: I didn't say there does.
18:26:30 <shachaf> There certainly exists a (Set Int -> Int) function.
18:26:31 <ivanm> my rationale for using MVector is that my Map-based lookup table performed really poorly compared to a simple array-based solution in C, due to (I think) a combination of mutability and O(1) lookups
18:26:42 <ivanm> (this is for my graph stuff)
18:26:44 <copumpkin> shachaf: except this function needs to be polymorphic
18:26:47 <jmcarthur> you type implies there does
18:26:49 <jmcarthur> *your
18:26:50 <hpc> you would need one to construct a Set b
18:26:53 <copumpkin> ivanm: did you profile it?
18:26:56 <shachaf> Oh, you're right.
18:27:01 <shachaf> It's passed as an argument.
18:27:14 <ivanm> copumpkin: yes
18:27:24 <copumpkin> so what caused it? :P
18:27:25 <shachaf> Well, it's still possible to write this function, but it would be boring.
18:27:31 <copumpkin> well yeah
18:27:45 <hpc> haha
18:28:13 <Luke2> can anyone see if there's anyone in #snapframework or is my IRC client just malfunctioning?
18:28:13 <copumpkin> ivanm: for example if you can use an array, you might try an IntMap instead of a Map?
18:28:13 <shachaf> Anyway ((s -> a) -> b) -> t is clearly not the right type
18:28:40 <shachaf> So what's a good type that's isomorphic to (b -> t, (a -> b) -> s -> t)?
18:28:41 <ivanm> copumpkin: couldn't really tell :s
18:28:48 <ivanm> I tried IntMap; it was actually a tad slower
18:28:49 <copumpkin> profile harder!
18:28:55 <jmcarthur> shachaf: define "good"
18:28:58 <ivanm> I profiled as much as I can
18:29:01 <copumpkin> ivanm: that probably suggests that your lookup structure isn't the factor
18:29:11 <copumpkin> was it a statistically meanignful slowerness?
18:29:17 <ivanm> copumpkin: the profiling results were dominated by the FFI and Criterion stuff
18:29:21 <ivanm> copumpkin: 30x slower...
18:29:26 <shachaf> jmcarthur: I want it to be in the form (g a -> b) -> g s -> t
18:29:28 <shachaf> If possible.
18:29:33 <shachaf> For some constraint on g
18:29:58 <copumpkin> I mean between Map and IntMap?
18:30:06 <ivanm> oh, not really
18:30:07 <ivanm> a tad slower
18:30:12 <copumpkin> that's what I meant
18:30:19 <copumpkin> because if it didn't really change anything, that probably isn't your bottleneck
18:30:29 <ivanm> I think due to some calls to size (since it's O(1) for Map but O(n) for IntMap)
18:30:46 <ivanm> huh?
18:30:46 <copumpkin> well, that's easy to work around
18:30:56 <ivanm> how can Map vs IntMap have anything to do with Haskell Map vs C arrays?
18:30:59 <jmcarthur> shachaf: is this some sort of a traversal dual?
18:31:00 <copumpkin> and is a confounding factor
18:31:17 <shachaf> jmcarthur: Something like that.
18:31:25 <copumpkin> ivanm: if changing your lookup datastructure from a slower one to a faster one for your use case didn't change your overall time, then moving to an even faster one (the array) probably won't help much either
18:31:34 <shachaf> jmcarthur: I think this combination ought to exist.
18:31:37 <ivanm> copumpkin: note that the keys I'm using are monotonically increasing
18:31:43 <shachaf> But I can't figure out what the right class on g is.
18:31:44 <ivanm> which IIUC can be pathological for IntMap
18:32:44 <copumpkin> hmm, I hadn't heard that and am not sure why it would be, but it might be true
18:33:19 <copumpkin> either way, you can still get fast array performance using immutable vectors
18:33:26 <ivanm> I can point you to my code if you'd like
18:33:32 <jmcarthur> ivanm: by pathological do you mean worse than Map?
18:33:36 <ivanm> jmcarthur: yes
18:33:40 <jmcarthur> huh!~
18:33:43 <copumpkin> I'm exhausted and don't really feel like trying stuff out right now
18:33:47 <ivanm> heh
18:33:55 <ivanm> I'm not just coming up with random Ints here
18:34:09 <ivanm> it's always a matter of highest current value + 1
18:34:59 <jmcarthur> so you're really after Data.Sequence, but not slow
18:35:10 <ivanm> well, I do delete values
18:35:25 <jmcarthur> well, that should only take log n for Data.Sequence anyway
18:35:31 <jmcarthur> oh but that woudl renumber
18:35:33 <jmcarthur> nevermind
18:35:35 <ivanm> yup :)
18:35:44 <ivanm> and lookup for Data.Sequence is O(n), isn't it?
18:35:48 <jmcarthur> no
18:36:06 <ivanm> oh?
18:36:16 <ivanm> *shrug* doesn't matter, it renumbers anyway :)
18:36:19 <jmcarthur> should be log n, where n is the distance from the closest end
18:36:54 <jmcarthur> the annotated fingertree should be reasonable for this
18:37:08 <jmcarthur> again, if fingertrees didn't have such bad constants :(
18:37:47 <jmcarthur> Data.Sequence accumulates a sum of ones, but you could instead accumulate a max of indices to get the functionality you need
18:37:59 <ivanm> I basically use two lookup tables: one stores keys for the second table (actually in Haskell I use a ring-like structure but that actually improves performance in some cases); the second stores two keys from the first and three keys for the second
18:38:25 <edwardk> ivanm: clearly you should use 'tables' ;)
18:38:37 <edwardk> now i just need to package it up
18:38:43 <ivanm> what's tables?
18:38:44 <jmcarthur> tables?
18:38:53 <jmcarthur> *intrigued*
18:39:08 <edwardk> github.com/ekmett/tables
18:39:13 <ivanm> I've been working on a type-class for Map, IntMap, Vector and MVector to abstract all the kind of stuff I do
18:39:29 <edwardk> work in progress on in-memory database tables with multiple indices
18:39:34 <edwardk> abuses lens to get a decent api
18:40:15 <shachaf> edwardk: Is there any non-abuse way of using lens?
18:40:29 <mwc> Hmm. Seems like an obvious defect in the detailed-1.0 interface is the ability to get the path of the build products
18:40:46 <ivanm> ZOMG @ all the extensions...
18:40:53 <ivanm> what are LiberalTypeSynonyms?
18:41:22 <mpu> TypeSynonymsGoneWild
18:41:32 <hpaste> mwc pasted “Setup.lhs generating TestInfo module” at http://hpaste.org/79539
18:41:39 <edwardk> ivanm: type Lens s t a b = … ; type Simple f a b = f a a b b; it lets you use 'Simple Lens a b'
18:41:42 <shachaf> ivanm: Type synonyms that are expanded later on so you can do trickery with them.
18:41:49 <edwardk> Lens isn't normally a valid arg for 'f'
18:41:52 <ivanm> hmmmm
18:41:54 <hpaste> mwc pasted “Setup.lhs generating TestInfo module” at http://hpaste.org/79540
18:41:55 <edwardk> because its just a type alias
18:42:08 <mwc> erp, wrong syntax highlighting.
18:42:10 <mwc> anyways
18:42:17 <edwardk> if i switched to lens 3.8+ then i could get rid of some of the extensions
18:42:20 <ivanm> edwardk: does tables allow you to merge two tables, with the keys to the second shifted so they don't overlap?
18:42:41 <mwc> I worked around it with that, seems like a common need to want to actually run the build products in your test at some point.
18:43:21 <ivanm> but I just look at Data/Table.hs and have nfi what I'm reading... :p
18:43:54 <edwardk> ivanm: assuming you have auto-increment on the table, 'sorta' -- you can take the rows out of the second table, map the id's to 0, then insert them into the first and they'll get auto-incremented
18:44:18 <ivanm> I don't even understand your example! :s
18:44:42 <edwardk> ivanm: load examples/Foo.hs   then use in ghc: test ^. with fooId (<) 3
18:45:05 <ivanm> any particular reason for the double underscore in the records?
18:45:09 <edwardk> test ^. with fooId (/=) 3 .> group fooBar
18:45:28 <edwardk> it causes the lenses to get a single _ then i make keys out of those lenses with no underscores
18:45:30 * ivanm suspects he needs to give in and have a look at lens to be able to grok this
18:45:59 <edwardk> the keys are overloaded so they can be used directly as lenses but i can also extract info about their key structure
18:46:49 <shachaf> ivanm: lens is fun!
18:48:32 <ivanm> that's a lot of deps... :o
18:49:17 <ivanm> edwardk: where does Prelude.Extras come from? you don't have it as a dep
18:49:33 <edwardk> ivanm: you should be able to remove it, its not used any more
18:49:46 <edwardk> it was in prelude-extras
18:50:03 <ivanm> you're also missing a dep for Data.Proxy
18:50:28 <edwardk> also not used iirc, let me see if i haven't pushed recently
18:51:05 <edwardk> pushed
18:51:20 <edwardk> its very much work-in-progress
18:51:33 <shachaf> edwardk: ==# ? :-(
18:51:40 <ivanm> what's the ".> group fooBar" you put in the second example for?
18:51:45 <ivanm> also, how performant is this?
18:51:51 <edwardk> shachaf: i've had that for a long time
18:52:08 <shachaf> That's a bit taken, isn't it?
18:52:34 <shachaf> Strange package, prelude-extras
18:52:58 <edwardk> shachaf: it'll go away those classes are going in transformers soon with some renaming
18:54:02 <shachaf> ivanm: edwardk is probably going to ignore performance and eventually bug me about it.
18:54:02 <burrows> In this case, why does the type checker not deduce that a is a floating point type?
18:54:04 <burrows> http://hpaste.org/79541
18:54:08 <ivanm> shachaf: heh
18:54:11 <edwardk> shachaf: pretty much
18:54:20 <ivanm> since my problems are due to performance, I'll pass on tables then for now :p
18:54:28 <edwardk> ivanm: performance should be better than ixset at least =P
18:54:32 <shachaf> burrows: Because you gave it an explicit signature saying that it isn't.
18:54:37 <ivanm> edwardk: heh
18:55:01 <shachaf> @ty let foo t = if t == 5.5 then 6.5 else t in foo
18:55:02 <lambdabot> (Eq a, Fractional a) => a -> a
18:55:24 <burrows> Num a won't resolve to a floating point?
18:55:33 <shachaf> burrows: Also, 5.5 isn't a floating point value.
18:55:53 <burrows> Well it's polymorphic, but in order to use == it concretes to fp, no?
18:55:53 <shachaf> It's a perfectly valid Rational, which is much more well-behaved than floating points.
18:56:01 <burrows> Oh.
18:56:04 <burrows> Guess I'm really confused.
18:56:25 <shachaf> Anyway, you gave it a certain type.
18:56:26 <edwardk> ivanm: anyways its more of a 'lets do a nicer ixset' than a solution to your particular usecase =P
18:56:34 <shachaf> Comment the type out and see what it infers.
18:56:35 <edwardk> the example is more a guide for what i need to make TH generate
18:56:39 <shachaf> @ty let foo t = if t == 5.5 then 6.5 else t in foo
18:56:40 <lambdabot> (Eq a, Fractional a) => a -> a
18:56:42 <ivanm> @tell copumpkin I was looking at MVector rather than Vector because if I want to keep adding new values, I couldn't find a way with Vector of doing so except keep expanding the Vector one value at a time (as there doesn't seem to be any way of resizing pure Vectors)
18:56:42 <lambdabot> Consider it noted.
18:56:45 <shachaf> It infers that it needs Eq and Fractional
18:56:55 <ivanm> edwardk: not that I'm particularly familiar with ixset >_>
18:56:58 <shachaf> Therefore it needs Eq and Fractional
18:58:28 <burrows> shachaf: Num and Fractional aren't types, correct?
18:58:35 <edwardk> ivanm: basically this gives you a table with multiple primary and secondary indices and the ability to efficiently select by those indices
18:58:44 <ivanm> edwardk: wait, did you give me the link to the wrong repo? is it in ekmett/tables or lens/tables ?
18:58:45 <shachaf> burrows: Correct.
18:58:49 <burrows> shachaf: So I didn't give it a type, I gave it a constraint for it's type?
18:59:08 <shachaf> burrows: Yes, but the constraint wasn't good enough.
18:59:22 <shachaf> You specified that this function works with *any* type which is Num,Eq
18:59:28 <shachaf> For example, that it works with Integers.
18:59:35 <shachaf> But this function doesn't work with Integers.
18:59:41 <burrows> Gotcha.
18:59:48 <burrows> That makes sense.
18:59:50 <ivanm> edwardk: nvm, that's your travic-CI stuff, not github
18:59:52 <edwardk> it should be ekmett/tables lens/tables doesn't exist any more
18:59:52 <burrows> Thanks.
18:59:58 <ivanm> still not seeing the stuff you said you pushed though
19:00:19 <burrows> Reading about a typed implementation of scheme and it's got my head doing some somersaults.
19:00:59 <shachaf> burrows: In particular:
19:01:00 <shachaf> @ty 5.5
19:01:01 <lambdabot> Fractional a => a
19:01:10 <edwardk> try now
19:01:27 <ivanm> OK, there they are :)
19:01:36 <aavogt> is incremental parsing common (as in http://yi-editor.blogspot.ca/2008/11/incremental-parsing-in-yi.html)?
19:01:44 <edwardk> #haskell-lens shows the build bot spam
19:01:54 <copumpkin> ivanm: how are you doing it in C? you can't expand arrays there either
19:01:54 <lambdabot> copumpkin: You have 1 new message. '/msg lambdabot @messages' to read it.
19:02:03 <edwardk> aavogt: i spent a lot of time working on it. now i'm less enthusiastic
19:02:04 <copumpkin> @messages
19:02:04 <lambdabot> ivanm said 5m 23s ago: I was looking at MVector rather than Vector because if I want to keep adding new values, I couldn't find a way with Vector of doing so except keep expanding the Vector one
19:02:05 <lambdabot> value at a time (as there doesn't seem to be any way of resizing pure Vectors)
19:02:35 <ivanm> copumpkin: my particular C benchmark implementation I knew the maximum size I wanted and set it; in general I won't know how big an array I'll want
19:02:42 * aavogt is thinking about prematurely optimizing an "editor" for some graphviz files
19:02:47 <copumpkin> ivanm: well, benchmark like against like :P
19:02:53 <copumpkin> a common approach is the ArrayList approach
19:03:02 <ivanm> aavogt: what do you mean by an "editor"?
19:03:04 <aavogt> so currently you have to push a button to update the display of the graph
19:03:37 <aavogt> ivanm: well right now it's just a text box and the picture that dot generates
19:03:54 <ivanm> so every time you complete a statement in some Dot file it will try and run dot on it?
19:03:57 <aavogt> and a way to get the name of the node that has been clicked on
19:04:05 <ivanm> which parser are you using?
19:04:21 <aavogt> ivanm: it might end up being every time you type a character
19:04:25 <aavogt> your parser
19:04:31 <ivanm> :D
19:04:47 <ivanm> I really need to bug upstream about this weird behaviour so I can make a new release
19:05:01 <ivanm> for starters, I have better parsing error descriptions now!
19:05:25 * aavogt noticed that sometimes dot will accept a file your parser doesn't
19:05:36 <aavogt> something related to not quoting names for nodes
19:06:01 <ivanm> oh? examples?
19:06:08 <ivanm> I have various cases that I know about
19:06:19 <ivanm> namely because dot does two passes and silently ignores invalid input
19:06:48 <ivanm> e.g. if an Int is expected but the value is "0.1" (with the quotes", it will first parse the value as a String, and then parse the String and discard the .1
19:06:53 <ivanm> whereas mine throws a fit
19:07:02 <coleman-> when I do  func1 (func2 5) is it guaranteed that func2 5 won't be called until I try to access that argument in the func1?
19:07:16 <ivanm> coleman-: yes
19:07:46 <coleman-> what about in here?  func1 =<< func2
19:08:00 <jmcarthur> depends on =<<
19:08:04 <coleman-> it's IO
19:08:06 <ivanm> yeah, how strict it is
19:08:07 <aavogt> ivanm: sounds about right
19:08:22 <aavogt> it's not too difficult to adjust the input file so that it gets accepted
19:08:34 <coleman-> both func1 and func2 returns IO a
19:08:39 <ivanm> yup, and my error parsing updates help track down where the error is
19:08:57 <jmcarthur> coleman-: also, it's not a *guarantee* that func2 won't be evaluated unless needed in func1 (func2 5) unless that would cause nontermination
19:09:01 <ivanm> coleman-: you can test this: (\ _ -> return () ) =<< return undefined
19:09:17 <jmcarthur> coleman-: but ghc's behavior will be to not evaluate it unless needed
19:09:32 <ivanm> aavogt: my current bug-bear is that "dot -Tdot" will litter the output with foo="" (when foo is an attribute that isn't meant to be able to take an empty string)
19:09:42 <ivanm> I had missed this earlier because my test-suite silently ignored those :s
19:09:45 <coleman-> jmcarthur you mean not guaranteed in language spec?
19:09:49 <jmcarthur> coleman-: right
19:09:59 <ivanm> yeah, non-strict vs lazy
19:11:57 <shachaf> edwardk: Data.Table.null? Is that really a good name to take over?
19:12:06 <shachaf> Can't you make a Traversal and use "has" instead?
19:12:23 <shachaf> Hmm, I guess you're taking over a lot of names, so this is meant to be imported qualified.
19:12:39 <ivanm> shachaf: as opposed to Data.Map.null say? :p
19:12:56 <shachaf> Well, the one example I see imports Data.Table unqualified.
19:13:18 <edwardk> shachaf: =P Data.Table follows the Map import pattern
19:13:38 <shachaf> @let sample_map = M.fromList [('a',1),('b',2)
19:13:38 <lambdabot>   Parse error: ;
19:13:41 <shachaf> @let sample_map = M.fromList [('a',1),('b',2)]
19:13:44 <lambdabot>  Defined.
19:13:50 <shachaf> > has (ix 'a') sample_map
19:13:52 <lambdabot>   Not in scope: `ix'
19:13:52 <lambdabot>  Perhaps you meant one of these:
19:13:53 <lambdabot>    `id' (imported from ...
19:13:59 <shachaf> > has (_at 'a') sample_map
19:14:02 <lambdabot>   True
19:14:03 <edwardk> can't use ix yet =P
19:14:10 <shachaf> @let ix = _at -- oh really?
19:14:12 <lambdabot>  Defined.
19:14:13 <edwardk> hah
19:14:21 <shachaf> Anyway, that's actually useful.
19:15:42 <shachaf> @ty has
19:15:44 <lambdabot> Not in scope: `has'
19:15:46 <shachaf> Did someone just @undefine?
19:15:53 <coleman-> ivam that is a bit different, you are not accessing argument at all, I would access it later
19:15:58 <edwardk> i'm going to break tables and tie it to 3.8 anyways so i wouldn't get too attached to it yet ;)
19:16:26 <coleman-> in particular, I thought it was guaranteed that "foo" would be printed before "bar". it's the opposite though
19:16:31 <coleman-> > (\ x -> do putStrLn "foo"; putStrLn (show x); return () ) =<< putStrLn "bar"
19:16:33 <lambdabot>   No instance for (GHC.Show.Show (GHC.Types.IO ()))
19:16:33 <lambdabot>    arising from a use of ...
19:17:18 <coleman-> since I am printing foo before touching the argument (return value of putStrLn "bar")
19:18:07 <shachaf> @let has = nullOf
19:18:09 <lambdabot>  Defined.
19:18:12 <shachaf> @let hasn't = notNullOf
19:18:14 <lambdabot>  Defined.
19:18:34 <shachaf> edwardk: This'll be misleading with Data.Set :-(
19:18:59 <coleman-> why is bar printed first, and is this guaranteed in ghc ?
19:19:14 <edwardk> shachaf: clearly we need to reintroduce contains =P
19:19:19 <shachaf> coleman-: Sure. This has nothing to do with evaluation order.
19:19:54 <shachaf> coleman-: That's do { x <- putStrLn "bar"; putStrLn "foo"; putStrLn (show x); return () }
19:19:55 <edwardk> the alternative is to change ix and contains around so you can answer has correctly, but you didn't like contains.
19:20:03 <edwardk> i'll chew on it
19:20:12 <shachaf> edwardk: I know.
19:20:18 <shachaf> You must admit that ix = contains is nice.
19:20:25 <ion> hasn't is evil. :-(
19:20:32 <edwardk> ion: why?
19:20:33 <shachaf> ion: Why?
19:20:48 <ion> In Haskell, ' is used as an approximation for ′, not ’ :-P
19:20:54 <edwardk> hahaha
19:21:03 <edwardk> oh yeah ion is the apostrophe police
19:21:06 <edwardk> i forgot
19:21:51 <Hafydd> What about character literals?
19:21:51 <shachaf> So has (foo :: Lens ...) ... = True
19:21:52 <coleman-> ok I am confused. why does this print "bar" `(\ _ ->  return () ) =<< putStrLn "bar" '
19:22:04 <coleman-> but this doesn't throw exception:  (\ _ -> return () ) =<< return undefined
19:22:18 <shachaf> coleman-: Because (=<<) runs its second argument first.
19:22:22 <shachaf> coleman-: Because you're not using the undefined
19:22:27 <johnw> coleman-: because the code doesn't use the undefined
19:22:31 <shachaf> ((...) =<< undefined) would.
19:22:45 <coleman-> I am not using whatever putStrLn returned either
19:22:52 <johnw> also, (\x -> print x) =<< return undefined would
19:23:18 <coleman-> I am ignoring putStrLn's returned value as well
19:23:31 <johnw> that doesn't mean the putStrLn's isn't executed
19:23:49 <johnw> return undefined *is* being executed
19:23:55 <johnw> and it's returning a value you never evaluate
19:24:03 <coleman-> ah, I am just not touching () returned by putStrLn
19:24:20 <coleman-> I got it
19:39:52 <hpaste> “Ertugrul Söylemez” pasted “Continuation-based user interaction” at http://hpaste.org/79542
19:40:18 <mm_freak_> stepcut: i remember you were interested in a continuation-based web monad
19:40:27 <mm_freak_> i've just written an example…  see the paste
19:40:43 <stepcut> mm_freak_: thanks
19:40:52 <mm_freak_> i think the snap people were also very interested…  it's not a web application, though, but a simplified command line application
19:41:01 <shachaf> Is that continuations or just coroutines?
19:41:11 <mm_freak_> shachaf: what's the difference?
19:41:25 <shachaf> A coroutine can only be resumed once, or something along those lines.
19:41:35 <mm_freak_> but to answer your question, that's what is usually referred to as a coroutine =)
19:41:45 <shachaf> Coroutines are pretty great.
19:42:00 <shachaf> You can implement all sorts of things in terms of them.
19:42:01 <mm_freak_> a coroutine can be consumed many times…  it's just that monad-coroutine/FreeT coroutines can only be consumed once =)
19:42:03 <shachaf> Like exceptions?
19:42:11 <mm_freak_> see the code…  i think it's a very neat thing
19:42:14 <shachaf> mm_freak_: A coroutine can be consumed many times?
19:42:26 <mm_freak_> sure…  see the code…  try it in fact =)
19:42:33 <mm_freak_> let me paste an example interaction
19:44:12 <hpaste> “Ertugrul Söylemez” annotated “Continuation-based user interaction” with “Example interaction” at http://hpaste.org/79542#a79543
19:44:21 <mm_freak_> stepcut, shachaf: that's what it looks like =)
19:45:27 <shachaf> mm_freak_: Why are you using Exists Show?
19:45:53 <mm_freak_> shachaf: for fun
19:46:01 <mm_freak_> i thought i would implement multiple example commands
19:46:11 <mm_freak_> one for Integer resulsts, one for something else
19:47:30 <mm_freak_> and the concept is actually simple…  that code took only 30 minutes to write
19:47:42 <mm_freak_> at least if you're familiar with how Free/Coroutine works
19:47:48 <shachaf> But Exists Show ~ String
19:48:02 <shachaf> mm_freak_: If you're familiar with FreeT, why rewrite that code?
19:48:03 <mm_freak_> yeah, i know
19:48:29 <mm_freak_> shachaf: because i don't think it's a free monad…  check the Alternative instance
19:48:47 <shachaf> Oh, right.
19:49:13 <shachaf> It's a weird monad.
19:49:40 <mm_freak_> it's a prototype…  the goal is to allow a coroutine to remove itself once met, etc.
19:50:01 <johnw> can I get ghc -M to output to stdout?
19:50:18 <mm_freak_> for example you want links to be available all the time, while form handlers should be one-time only
19:50:53 <mm_freak_> i imagine how nice a web application using this concept would look like
19:51:41 <mm_freak_> do login <- runForm $ liftA2 (,) (textField "User") (passwordField "Password"); checkLogin login <|> loginError; …
19:52:03 <mm_freak_> it's sad that none of the major web frameworks implement this idea yet
19:52:18 * shachaf is not sure that this is a good idea for your average web application.
19:52:30 <mm_freak_> why?
19:53:40 <jmcarthur> for one, it might be difficult to think about the back button
19:53:48 <shachaf> Well, it depends on what you're doing.
19:53:48 <jmcarthur> or multiple tabs
19:53:55 <shachaf> There are advantages to making state explicit.
19:54:08 <shachaf> The back button and tabs are part of it. :-) Though you can make that work.
19:54:09 <sclv> lots of sessions = boom goes the tspace usage
19:54:34 <shachaf> Space usage is a concern.
19:55:00 <jmcarthur> i don't see how space usage is a potential problem
19:55:03 <shachaf> Having nice URLs rather than /foo?id=blahblahblah is nice.
19:55:22 <sclv> someone did a continuation proof of concept some time back in haskell, or a few
19:55:36 <sclv> "haskell on a horse" is one i remember
19:55:59 <shachaf> Didn't WASH or something do that?
19:56:12 <sclv> oh yeah way back in the day wash had some of that too
19:56:42 <sclv> jmcarthur: space is a concern because if you have multiple "paths" from each page and each is a continuation then each page generates a mess of continuations
19:56:56 <sclv> and you need to store them all on the server b/c you don't know when you might want to ditch them
19:57:13 <shachaf> I seem to remember that Seaside, in Smalltalk, had a pretty big issue with space usage.
19:57:13 <jmcarthur> sclv: it seems to me that a lot of web applications have this issue already. i guess this design would mean you don't have a choice, though
19:57:27 <sclv> so they stick around for maybe a day or so, but if i have a page open today from last week that was hiding there for a week and i just got back to, then whoops all the links broke
19:57:33 <sclv> right. you can't scale out.
19:57:51 <sclv> if i use session state, at least i can replicate or shard
19:58:08 <sclv> but here once you're on a server you're locked in for good
19:58:31 <sclv> as i recall, the continuation marks stuff in racket is one way to tackle this stuff
19:58:38 <sclv> panels in jmacro-rpc are another
19:58:41 <shachaf> Sometimes you can get away with storing no state at all on the server.
19:58:59 <jmcarthur> maybe there could be a decent way to serialize your continuation into client-side state. it would mean you lose the nice monad, though
19:59:03 <sclv> (panels let you have no state on the server *and* continuation style programming!)
19:59:19 <mm_freak_> jmcarthur: i don't see any problem with the back button…  in fact i think this solves the back button even more nicely in the presence of forms
19:59:22 <pdxleif> I think link encodes the state into a url param?
19:59:29 <mm_freak_> jmcarthur: just think of the explicit redirections you get wrong all the time
19:59:42 <mm_freak_> this monad can do The Right Thing for you
19:59:47 <shachaf> Storing continuations on the client sounds a bit scary.
19:59:54 <sclv> (and you have a continuation monad, though i think its cleaner to just write the continuations out explicitly)
20:00:05 <jmcarthur> mm_freak_: i'm shopping, decide i'm ready to buy the stuff in my cart, start filling stuff out, decide to add that other item i had in another tab, then finish checking out
20:00:08 <sclv> (oh, *and* panels don't store continuations on the client!)
20:00:10 <mm_freak_> storing continuations on the client is difficult to impossible
20:00:22 <sclv> there's a php hack that did it back in the day
20:00:23 <jmcarthur> mm_freak_: you would need to make sure you combine those states in reasonable ways, at least
20:00:30 <sclv> infernal machine it was called -- it was hilarious
20:00:58 <sclv> (it stores on the client indexes into the tree structure of the continuations)
20:01:06 <mm_freak_> jmcarthur: you can have a combination operator that is orthogonal to composition
20:01:11 <sclv> (jmacro-rpc that is)
20:01:33 <jmcarthur> mm_freak_: that would make sense if you were somehow aware of when the user opens a new tab...
20:01:57 <QinGW> @quote lens
20:01:58 <lambdabot> quicksilver says: <quicksilver> what we need is an adapter package any-lens which uses whichever lens package is available <quicksilver> then we get potentially the disadvantages of all, without
20:01:58 <lambdabot> being able to guarantee the advantages of any.
20:02:01 <mm_freak_> jmcarthur: you don't really need to be aware of it…  coroutines can backtrack
20:03:12 <mm_freak_> jmcarthur: notice that i haven't just reinvented what racket does…  this framework can actually tell persistent things from transient things
20:03:13 <jmcarthur> mm_freak_: backtracking, mergable coroutines doesn't sound much more manageable than specializing on a case by case basis, to me, but maybe i'm being closed minded
20:03:30 <shachaf> Hmm, last HWN was two weeks ago.
20:03:48 <shachaf> sclv: What are you people doing to dstcruz?
20:03:51 <mm_freak_> jmcarthur: i think you have to see this in action in a real proof of concept web app to be convinved =)
20:03:55 <mm_freak_> convinced
20:04:00 <jmcarthur> quite possibly
20:04:05 <sclv> a shopping cart seems canonically something where a proper session is in order
20:04:16 <sclv> some webapps are naturally single-age apps otoh
20:04:17 <jmcarthur> although i should add that i, and presumaby many others, have thought pretty hard about this exact problem before
20:04:46 <sclv> shachaf: i think he's busy with family and moving, basically
20:04:51 <mm_freak_> jmcarthur: unfortunately i haven't seen a real implementation of this yet, apart from my little toy program from above
20:04:59 <mm_freak_> jmcarthur: did you actually see it?
20:05:16 <sclv> i'm on vacation thru the end of the year, so won't be able to bug him in person until jan :-P
20:05:19 <jmcarthur> i admit that i did not look and instead made assumptions about it
20:05:42 <jmcarthur> i am looking now
20:05:43 <shachaf> jmcarthur: That's the #haskell way!
20:05:50 <mm_freak_> jmcarthur: then look…  really just look at the short main function below, and there is an example interaction annotated
20:05:52 <sclv> the tagged continuation style does multiple tabs as i recall
20:06:12 <sclv> but if you hit an old tab you get old state (minus pervasive mutation)
20:06:15 <mm_freak_> why am i calling this a function?!
20:06:57 <mm_freak_> to save myself from looking stupid for calling 'main' a function i'm going back to my IO a = World -> (a, World) view
20:07:15 <jmcarthur> mm_freak_: it looks exactly the way i expected, to be honest
20:07:46 <jmcarthur> i see how back works. i still think it would be tough to automatically handle multiple tabs, since sometimes you want them to share state and sometimes you don't
20:08:10 <jmcarthur> same for back, for that matter, since you's kind of just loses state, apparently
20:08:14 <jmcarthur> *future state, that is
20:08:18 <jmcarthur> *yours
20:08:31 <mm_freak_> jmcarthur: remember that in a shop cart application the cart isn't part of this implicit coroutine state, but rather something you would have in the client session or the database
20:09:59 <jmcarthur> so the coroutine state is only for FSMs that are shaped like trees?
20:10:11 <jmcarthur> err
20:10:13 <jmcarthur> SMs
20:10:33 <jmcarthur> i never know exactly what i'm talking about when talking about state machines :)
20:10:43 <mm_freak_> the way to make this work nicely is not to assume that this is in fact a console application
20:11:00 <mm_freak_> in other words, database queries must become invalid between such "request" actions
20:11:33 <mm_freak_> and yes, it's in fact strongly related to FSMs =)
20:11:53 <jmcarthur> i meant to put the emphasis on the "tree" part of what i said
20:12:00 <mm_freak_> it's the automaton arrow in disguise
20:12:20 <jmcarthur> meh
20:12:31 <jmcarthur> i'm tired and saying nonsense
20:12:45 <mm_freak_> happens =)
20:13:01 <jmcarthur> going to bed now. i look forward to hearing more about this, because it really do want nice abstractions for web sessions
20:13:54 <sclv> panels!
20:46:40 <akkartik> Anybody have experience doing interactive parsing?
20:48:07 <akkartik> I'm relatively inexperienced with haskell and have been playing with http://jonathan.tang.name/files/scheme_in_48/tutorial. But it only parses expressions all on one line. Any hints on how I can do multi-line parsing without waiting too much for user input?
20:50:10 <Nisstyre> akkartik: for scheme you wait until the parentheses are balanced before parsing
20:50:22 <Nisstyre> or if there are no parentheses you parse and evaluate it
20:50:39 <Nisstyre> (that would be typing an identifier)
20:51:17 <akkartik> right. should I be adding lines into a buffer and running a simple parser to decide when to stop before running a more complex parser over it?
20:52:09 <Nisstyre> akkartik: in your REPL, if the user inputs a newline character, you check to see if the expression has balanced parentheses (or if it's an identifier) before actually parsing it and evaluating it, yes
20:55:06 <lispy> akkartik: This is how ghci does multiline input: https://github.com/ghc/ghc/blob/master/ghc/InteractiveUI.hs#L704
20:55:14 <lispy> akkartik: basically, with :{ }
20:55:28 <Nisstyre> lispy: it would be simpler for lisp though
20:55:30 <lispy> er :{ :}
20:56:11 <lispy> Nisstyre: this is basically doing that too, but using :{ :} instead of an outter most ()
20:56:18 <Nisstyre> lispy: also for just running the lisp interpreter on a file you can remove all of the newlines and just just parse it on one line
20:56:26 <Nisstyre> which is what that does I guess?
20:56:39 <Nisstyre> lispy: yeah but it has to add those right?
20:56:46 <akkartik> lispy: thanks!
20:57:14 <akkartik> Nisstyre: this is an interactive repl so I can't wait for eof
20:57:41 <Nisstyre> akkartik: I never told you to
20:58:01 <lispy> akkartik: seems like incremental parsing could be a related topic
20:58:37 <Nisstyre> if you fire up the Racket interpreter, you can see that if you type, "(define (foo bar) \n" it won't execute anything
20:58:43 <Nisstyre> until you close that with another paren
20:58:53 <akkartik> right
20:59:05 <akkartik> but I can't just do the removing newlines trick
20:59:12 <Nisstyre> no
20:59:14 <akkartik> I need to count the parens like you said earlier
20:59:17 <Nisstyre> yes
20:59:35 <Nisstyre> so all you need for that is a tokenizer
20:59:43 <akkartik> that seems rather imperative :) I'm playing with code now, sems like I need to juggle multiple monads
20:59:47 <lispy> It also seems like you should be able to define a parser that works on 'expression' at a time while having your readline/editline library be a sort of interactive frontend that keeps feeding the parser until the parser returns something.
21:00:17 <akkartik> lispy: but I need a parser to decide where the expression ends
21:00:40 <akkartik> even if it's a simple parser like counting parens
21:00:49 <lispy> akkartik: well, what if the parser could tell when it was out of input and stop mid parse to request more?
21:01:17 <akkartik> yeah, is there some way to do that? oh, you mean it returns a state rather than the usual space of values?
21:01:40 <lispy> akkartik: https://github.com/bos/attoparsec/blob/master/Data/Attoparsec/Internal/Types.hs#L39
21:01:48 <lispy> akkartik: attoparsec does exactly what I'm talking about
21:02:12 <akkartik> I see, ok will go try to digest that
21:02:26 <akkartik> thanks lispy and Nisstyre!
21:02:31 <Nisstyre> no prob
21:08:14 <statusfailed> Is there an easy way to compile a haskell program against an older glibc? I'm trying to deploy a binary to heroku
21:08:37 <statusfailed> (and I use Arch Linux which has a much too new version)
21:19:02 <pdxleif> statusfailed: Maybe you could make a chroot w/ an older glibc in it?  Or a VM w/ Ubuntu or something in it?
21:19:40 <pdxleif> I thought they had some setup where you could build things on heroku, too?
21:19:49 <pdxleif> Maybe you could set up something on a CI server, e.g. travis, or jenkins.
21:22:56 <statusfailed> pdxleif: I'm going with a VM for now
21:23:22 <statusfailed> pdxleif: I think you can build on heroku actually, I just wasn't sure how to do it with GHC :)
21:24:35 <pdxleif> I though I saw a guide somewhere... maybe on the yesod blog?
21:24:56 <saiko-chriskun> I think ghc is too big for heroku actually
21:24:58 <saiko-chriskun> lol
21:25:11 <statusfailed> ah, dang :D
21:25:21 <statusfailed> pdxleif: This is what i'm using at the moment: http://johnbender.us/2011/03/05/snap-setup-from-scratch-the-vagrant-way/
21:25:39 <statusfailed> but i'm only getting 100KB/s at the moment, so it's kinda crawling :)
21:29:53 <pdxleif> On this blog, he just statically linked his app, looks like: http://www.yesodweb.com/blog/2011/07/haskell-on-heroku
21:32:06 <statusfailed> Hmm.. I was avoiding that because of a stack overflow thread advising against it
21:32:24 <subbyyy> hey guys, absolutely new to haskell, and im getting this error whenever i try runhaskell  "The build-tool has reset ENV. --env=std required." (no luck googling around)
21:33:36 <statusfailed> subbyyy: Are you on linux? What happens when you try GHCi?
21:34:18 <subbyyy> on mac osx, ran ghci, got the same warning
21:34:56 <statusfailed> Have you tried adding "--env=std"? (I don't know what it does, for the record)
21:35:37 <subbyyy> i havent, ill try it out and google for that term as well, thanks
21:38:26 <shachaf> What's newtype Foo f a b = Foo (f a -> b) called?
21:38:28 <shachaf> Algebroid?
21:42:32 <sw2wolf> :t mappend
21:42:34 <lambdabot> Monoid a => a -> a -> a
21:42:44 <sw2wolf> :i mappend
21:50:42 <statusfailed> shachaf: cokleisli?
21:50:55 <statusfailed> oh, that's with a comonad constraint
21:51:40 <shachaf> Hmm...
21:51:49 <statusfailed> in fact, what's newtype Foo f a b = Foo (a -> f b) called...
21:51:50 <shachaf> That *does* have the right shape.
21:52:02 <shachaf> statusfailed: Kleisli? :-)
21:52:11 <statusfailed> shachaf: but without the monad constraint?
21:52:15 <shachaf> Or a Coalgebroid
21:52:20 <shachaf> Kleisli has no Monad constraint.
21:52:29 <statusfailed> oh, herp
21:52:33 <statusfailed> neither does cokleisli
21:52:39 <shachaf> Right.
21:52:40 <statusfailed> problem solved :p
21:53:05 <statusfailed> what's it for?
21:53:21 <shachaf> I wonder whether Cokleisli is the "right" type.
21:53:34 <shachaf> It's for lens, what else?
21:53:40 <statusfailed> haha
21:53:52 <statusfailed> I guess that makes sense :P
21:54:48 <shachaf> I'll just use Cokleisli
21:54:56 <shachaf> If it's the wrong type edwardk_ can change it.
22:12:30 <statusfailed> huh, turns out static linking works afer all
22:12:32 <statusfailed> after all*
22:15:40 <sw2wolf> :t maybe
22:15:41 <lambdabot> b -> (a -> b) -> Maybe a -> b
22:47:26 <wavewave> hi
22:53:10 <statusfailed> wavewave: hi
22:53:22 * wavewave waves statusfailed
22:57:19 <sw2wolf> In emacs haskell mode, how can i switch between the start and end of a function ?
22:58:31 <wavewave> sw2wolf: what do you mean by switching btwn start and end?
23:01:12 <sw2wolf> i  mean moving the cursor
23:03:56 <wavewave> sw2wolf: I don't know but for me control+up or down does fairly good job.
23:04:46 <sw2wolf> which functions bound to Ctrl+up/down ?
23:04:48 <wavewave> of course because I usually put empty line between function defs
23:05:42 <wavewave> sw2wolf: I think it's emacs default. just next empty line..
23:05:50 <sw2wolf> in lisp, (forward-sexp &optional ARG) is VERY convenient
23:06:27 <wavewave> sounds so.
23:07:33 <sw2wolf> please C-h k <Ctr+up/down> to see function
23:09:05 <wavewave> backward-paragraph
23:09:16 <sw2wolf> ok
23:09:16 <wavewave> forward-paragraph
23:09:23 <wavewave> sounds right
23:10:58 <sw2wolf> it is bound to M-{} already
23:11:45 <wavewave> I am not sure that I am using the default. I copy and paste lots of .emacs from here and there. ;-P
23:12:02 <sw2wolf> they are not what i want, but faster than moving just one line
23:12:54 <wavewave> sw2wolf: definitely not. but sometimes workaround is enough. hopefully
23:13:09 <sw2wolf> C-h f backward-paragraph will tell you
23:14:04 <sw2wolf> maybe there is tips in haskell-mode itself
23:15:20 <wavewave> yeah.. I am not an expert of emacs lisp at all. :-/
23:15:50 <johnw> emacs lisp expert needed?  reporting for duty
23:16:21 <wavewave> whatever defines expert
23:16:57 <sw2wolf> Eventhough i use emacs everyday, i am not an expert of elisp :(
23:17:01 <johnw> my footprints are shaped like parentheses
23:18:07 <startling> when I see my eyelashes in the mirror, I get a parser error!
23:21:11 <JoeyA> Yeah, Network.URI doesn't belong in the network package.  It doesn't have enough stuff like #if !(defined(HAVE_WINSOCK2_H) && !defined(cygwin32_HOST_OS))
23:28:09 <QinGW> Where can I get this channel log? bit.ly/5mwtRQ does not work for me.
23:28:41 <shachaf> @google haskell irc logs
23:28:43 <lambdabot> http://www.haskell.org/haskellwiki/IRC_channel
23:28:44 <lambdabot> Title: IRC channel - HaskellWiki
23:28:56 <shachaf> That page has a link.
23:29:15 <shachaf> http://bit.ly/5mwtRQ works for me, though.
23:30:12 <Twisol> Why are there two different versions of (>->) in Proxy? <http://hackage.haskell.org/packages/archive/pipes/3.0.0/doc/html/Control-Proxy-Class.html>. I can't tell how ghc can differentiate.
23:30:52 <shachaf> Twisol: It can differentiate by them not being the same name.
23:31:01 <shachaf> Twisol: Zoom in a few times. :-)
23:31:13 <Twisol> The heck? >_<
23:31:50 <Twisol> That explains a lot. Thanks
23:39:47 <QinGW> sclv: hi, Any materials about lens can recommand me, thanks
23:49:13 <johnw> QinGW: i would start at the Wiki
23:49:31 <johnw> github.com/ekmett/lens/wiki
23:50:02 <QinGW> Thank you johnw.
23:50:31 <shachaf> Man, these new semisymmetric lenses are great.
23:50:40 <c_wraith> seismic lenses?
23:51:27 <Ralith> these what now
23:52:32 <shachaf> Ralith: Algebraic g k => k a (f b) -> k s (f t)
23:52:40 <Ralith> oh dear
23:53:20 <shachaf> Ralith: You can choose (->) and these degrade to regular lenses.
23:53:34 <shachaf> Or you can choose k a f_b = g a -> f_b
23:53:40 <shachaf> And then you get symmetric lenses.
23:53:46 <Ralith> what are those
23:54:27 <shachaf> (g a -> f b) -> g s -> f t
23:54:38 <shachaf> See http://slbkbs.org/pr.hs for an example.
23:55:21 <Ralith> that is less informative than one might hope
23:55:29 <arbn> I seem to spend a lot of time removing upper bounds from cabal files. :)
23:55:36 <shachaf> Well, you know how twanvl lenses are (a -> f b) -> s -> f t?
23:55:53 <shachaf> What happens when you put a functor on the first argument, too?
23:55:59 <shachaf> The answer is "great things"
23:56:05 <shachaf> (g a -> f b) -> g s -> f t
23:56:12 <shachaf> If you pick g = Identity, you get the old behavior.
23:56:25 <shachaf> If you pick different constraints, you get different behaviors.
23:56:49 <Enigmagic> shachaf: sounds like this might help my problems?
23:57:27 <johnw> arbn: me too
23:57:28 <shachaf> Enigmagic: I was trying to figure out how to make your thing work the other day.
23:57:49 <shachaf> I still think it sounds like ((a -> b) -> s -> t, b -> t)
23:58:18 <shachaf> Which matches the shape of ((g a -> b) -> g s -> t), but I'm not sure what the right constraint on g should be.
23:58:51 <shachaf> I want something such that you can pick g = Proxy to get (b -> t), and g = Identity to get (a -> b) -> s -> t
23:58:59 <shachaf> But Functor isn't a strong enough constraint to make these.
23:59:12 <Enigmagic> the way i was doing it before was more like what you're doing now, just generalized over functors instead of being constrained to some state instance
23:59:41 <shachaf> Hmm, what do you mean?
