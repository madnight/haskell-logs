00:00:40 <Jafet> Because the people who define them want them to be new types
00:00:44 <shachaf> Because they're their own types, usually with their own operations.
00:01:03 <neutrino> for example, don't the different transformers have different instances?
00:02:06 <mmcdermo> shachaf: Good point, clarity & extra info in type system
00:02:14 <neutrino> i believe if you used type synonyms you'd get the same instances everywhere
00:02:40 <mmcdermo> neutrino: Another good point... Could be more convenient to have a MonadState instance rather than lifting etc
00:03:40 <mmcdermo> Just seemed like extra work, rederiving instances etc. But it seems like the right way now.
00:03:57 <neutrino> for example MaybeT and ContT have different instances
00:04:32 <k0001> Data.Text.length time complexity is reported to be O(n) in the docs. Is that right? Is that 'n' the number of characters in the Text? (According to http://hackage.haskell.org/packages/archive/text/0.11.2.3/doc/html/Data-Text.html )
00:04:59 <shachaf> k0001: Yes, it's right.
00:05:17 <shachaf> n is either the number of characters or the number of bytes -- it doesn't matter here.
00:05:32 <shachaf> Text is stored as UTF-16, so you can't tell its length without traversing it.
00:05:40 <mmcdermo> neutrino: Ahhh hadn't considered that.... could be confusing / incorrect
00:05:42 <Jafet> You can hide the implementation of a newtype if you do not export its constructor, or allow unsafe operations, or allow GeneralizedNewtypeDeriving or IncoherentInstances, or derive Typeable, Show, nor Data.
00:06:09 <Jafet> Encapsulation in Haskell is pretty crap, come to think of it
00:06:49 <shachaf> Jafet: What's wrong with Typeable?
00:07:48 <Jafet> It sounds shady
00:08:51 <Jafet> :t typeOf
00:08:52 <lambdabot> Typeable a => a -> TypeRep
00:12:13 <k0001> shachaf: Thanks. Isn't Text's underlying implementation mostly array based? It caught my attention that O(n)
00:13:59 <neutrino> Jafet: what is your issue with encapsulation? i haven't used haskell enough to spot any problems
00:14:49 <mmcdermo> Jafet: Good design principle - easier to make a safer typed interface.
00:15:18 <Jafet> This calls for a UCS2String
00:16:03 <Jafet> k0001: it should catch your attention that UTF-16 does not use the same number of bytes for each character.
00:16:20 <Cale> The only thing I can think of which would make encapsulation in Haskell better is if there were a way to separately export type synonyms and the type equalities they represent from a module.
00:16:36 <Jafet> (Or even each code point!)
00:16:50 <Cale> There's probably other stuff, but I don't know what it would be
00:19:55 <k0001> Jafet shachaf Oh! Now I see what you mean. Thanks.
00:20:19 <neutrino> Jafet: what you said sounded fairly interesting, since i'm always looking to improve my haskell coding practices
00:21:33 <Nereid> neutrino: I think he was just saying that haskell doesn't do a good job of it.
00:22:17 <neutrino> yeah but i wonder what the pain points are
00:22:31 <Nereid> he just listed a bunch
00:22:45 <Nereid> put template haskell in that list
00:22:49 <neutrino> hmm
00:23:23 <neutrino> why does hiding the implementation of a newtype mean bad encapsulation? i thought that if you don't show something at all you encapsulated it as much as possible?
00:23:29 <neutrino> too much, but still
00:23:37 <Nereid> no
00:23:49 <neutrino> can you explain?
00:23:53 <Nereid> the point is that there are ways to get around the hiding
00:24:03 <Nereid> I think.
00:24:24 <neutrino> mhm
00:24:51 <neutrino> so if you don't export the constructor.. how would you get around that?
00:24:58 * neutrino has no idea how he would do that
00:25:39 <Nereid> unsafeCoerce does it, GeneralizedNewtypeDeriving can do it, TH can do it, ...
00:26:33 <neutrino> hmm
00:26:40 <neutrino> in what way does unsafeCoerce do that?
00:26:48 <neutrino> i've never used it..
00:26:53 <shachaf> Most of these don't work across module boundaries.
00:27:12 <Nereid> newtype X = X Int
00:27:15 <Nereid> don't export the X constructor
00:27:23 <Nereid> unsafeCoerce :: X -> Int (and the other way) oops
00:27:27 <shachaf> Sure.
00:27:28 <DavidT> hi all, is there any way to run a ghci command from the OS command line?
00:27:36 <shachaf> unsafeCoerce or an equivalent exists in almost any language.
00:27:36 <Nereid> ghc -e
00:27:38 <shachaf> DavidT: ghc -e
00:27:56 <DavidT> look at that, it works
00:27:58 <DavidT> thanks
00:28:31 <DavidT> I was trying ghci -e which doesn't
00:28:49 <Nereid> ghci is ghc --interactive
00:28:57 <Nereid> and -e and --interactive are incompatible.
00:31:19 <neutrino> Nereid: aha
00:32:10 <neutrino> Nereid: well, there's no reason specifically to prevent people from doing that. we're not a totalitarian regime ;)
00:32:14 <Nereid> :p
00:32:18 <neutrino> but i see what you mean
00:32:21 <neutrino> that's a good example, thanks
00:32:34 <Nereid> TH can be used to access hidden constructors, iirc.
00:34:45 <neutrino> oh? in what way?
00:35:02 <neutrino> oh right, th can parse the file the constructor is defined in, right?
00:35:13 <neutrino> as a better alternative to copypaste
00:46:11 <mm_freak> TH can't really "access" the hidden constructors of type X…  it could create a new type X' from its original definition and unsafeCoerce between them
00:46:29 <neutrino> that's actually what i thought
00:47:13 <shachaf> That's not always valid if you run under different optimization levels.
00:47:31 <neutrino> how does GeneralizedNewtypeDeriving break encapsulation?
00:47:59 <shachaf> GHC doesn't respect UNPACK with -O0, for instance, so if you defined data Map = Bin {-# UNPACK #-} !Int ... | Tip, you can't unsafeCoerce a Data.Map Map to it.
00:48:35 <shachaf> rwbarton discovered that while doing exactly that at one point.
00:54:01 <neutrino> or how does IncoherentInstances break encapsulation?
00:54:26 * neutrino has never used either
01:01:14 <mm_freak> i'm impressed
01:01:31 <mm_freak> GHC 7.6.1 with dynamic linking produces a hello world binary of only 9.3 KiB
01:01:44 <alpounet> wow nice
01:02:55 <shachaf> How big are all the libraries it depends on?
01:04:11 <hpaste> mmcdermo pasted “MonadReader Instance” at http://hpaste.org/79279
01:04:23 <mmcdermo> Simple question: I'm definitely doing something wrong :)
01:04:25 <mmcdermo> http://hpaste.org/79279
01:04:47 <mmcdermo> Trying to create a very simple MonadReader instance.
01:04:58 <shachaf> mmcdermo: That doesn't look like a valid MonadReader.
01:05:12 <shachaf> But anyway did you try turning on the extensions that it asked for?
01:05:22 <shachaf> If nothing else, you certainly have a -XMultiParamTypeClass.
01:05:45 <mmcdermo> shachaf: Ahh hmm. FlexibleInstances gave me other errors. I'll look into MultiParamTypeClasses
01:06:43 <mm_freak> shachaf: probably just as big as they would have been combined in a statically linked binary…  however, now haskell applications can share some libraries like the RTS
01:06:47 <mmcdermo> schachaf: The real type I'm trying to make a MonadReader is.. ReaderT s (EitherT T.Text (W.WriterT [T.Text] IO)) a
01:06:59 <shachaf> mm_freak: Probably bigger!
01:07:01 <shachaf> But who knows?
01:07:06 <mm_freak> shachaf: likely even
01:07:13 <shachaf> mm_freak: That type is already a MonadReader.
01:07:13 <mmcdermo> shachaf *: Actually a newtype wrapper around that.
01:07:57 <shachaf> Well, before something can be a MonadReader it has to be a Monad.
01:08:09 <shachaf> But anyway the newtype would probably be fairly mechanical.
01:09:08 <mmcdermo> shachaf: Aye, is what I was aiming for. Just got that error when trying "instance MonadReader s (MyNewType s) where..."
01:09:24 <shachaf> Did you read the error?
01:09:30 <mm_freak> i've just compiled a netwire hello world…  16k now…  i'm loving it
01:09:52 <shachaf> What about a "real" Haskell program?
01:10:20 <mm_freak> a netwire hello world is already a real haskell program…  it has an application loop, uses a timing source, etc.
01:10:21 <mmcdermo> shachaf: it's claiming that the type variables are not unique. Which I suppose is true in that 's' is recurring?
01:10:55 <mm_freak> with static linking it's 1.9 MiB
01:11:00 <mm_freak> (3.0 MiB unstripped)
01:11:32 <shachaf> mm_freak: Are the libraries getting statically linked too?
01:11:37 <shachaf> Things other than the RTS, I mean.
01:11:50 <mm_freak> i assume so
01:11:59 <mm_freak> i've just compiled my optimized safe prime search program
01:12:05 <mm_freak> 46 KiB
01:12:40 <shachaf> You can probably ldd your program to find out. :-)
01:12:56 <shachaf> mm_freak: It's telling you how to fix it, maybe.
01:13:06 <shachaf> s/_freak/cdermo/
01:13:14 <shachaf> When you turn on the extension you get "other errors".
01:13:15 <mm_freak> no haskell-specific library dependencies
01:13:18 <shachaf> Did you read those errors too?
01:13:19 <mm_freak> just the usual C stuff
01:14:08 <mm_freak> the dynamic version has loads of haskell dynlibs
01:14:25 <shachaf> I meant the dynamic version.
01:14:45 <mmcdermo> shachaf: w/ FlexibleInstances I get that multiple types are given in the instance head. Reading http://www.haskell.org/ghc/docs/latest/html/users_guide/type-class-extensions.html#instance-decls to better understand what that means.
01:15:33 <shachaf> Well, I certainly can't help you, because I can't see the code+error message. :-(
01:16:21 <mmcdermo> shachaf: How very rude of me :). I should isolate the full example down more accurately in any case.
01:20:05 <johnw> mm_freak: but your hello world comes with a dynlib containing the contents of hello which isn't nearly so small
01:20:25 <johnw> you pay almost the same overall disk cost, you just get the advantage of sharing among multiple executables that use the same modules
01:20:42 <johnw> but for your custom executable's Main module, there is no space savings there
01:21:34 <mm_freak> johnw: that's not the point…  it's just nice to finally have shared libraries (i know they have been there for a while, but i decided to switch now)
01:21:44 <johnw> ah, i see
01:21:44 <hpaste> mmcdermo pasted “MonadReader Instance - Full” at http://hpaste.org/79280
01:21:55 <johnw> did you notice how long the output of ldd is now :)
01:21:57 <johnw> ?
01:22:04 <mm_freak> yes, sure
01:22:08 <mmcdermo> Much more accurate, minimal example here: http://hpaste.org/79280. Will continue reading etc to work through it.
01:22:26 <mm_freak> haskell libraries are usually much less monolithic than, say, C/C++ libraries
01:22:36 <mm_freak> so naturally there are much more library dependencies now
01:23:12 <mm_freak> after all there is a "void" library =)
01:24:21 <Twisol> somewhat relatedly, I found a list of Haskell reserved keywords today
01:24:32 <Twisol> there are so few. :o
01:24:48 <shachaf> @where keywords
01:24:49 <lambdabot> case class data default deriving do else foreign if import in infix infixl infixr instance let module newtype of then type where _
01:24:53 <shachaf> That's a lot.
01:25:06 <Twisol> http://en.cppreference.com/w/cpp/keyword
01:25:25 <mm_freak> i wish 'if' wouldn't be a reserved word
01:25:43 <johnw> the way Agda defines if_then_else_ is very cool
01:25:52 <johnw> I wish Haskell had mixfix like that
01:26:01 <mm_freak> johnw: i don't actually
01:26:05 <johnw> why?
01:26:18 <mm_freak> because it introduces structure into flat syntax
01:26:18 <Twisol> coming from languages like C++, Java, and even Ruby, that's a crazy small amount of keywords.
01:26:42 <mm_freak> johnw: the way haskell is you can tell that "f x y z" means to pass x, y and z to f
01:27:17 <johnw> meh, that's a similar line of reasoning people give for C vs. C++
01:27:22 <johnw> i didn't buy it then, I don't buy it now
01:27:34 <mmcdermo> shachaf: Anyways, thank you! Going to go do some reading / investigation and experimentation =D.
01:27:44 <shachaf> mmcdermo: let x = x in x
01:27:51 <shachaf> Are you surprised that that compiles?
01:28:14 <mmcdermo> shachaf: I suppose not :).
01:28:35 <mm_freak> johnw: it has a much different impact here…  allowing mixfix will make library authors actually use it and turns parsing into a nightmare
01:28:51 <mm_freak> not only for the compiler, but also for the human
01:28:57 <mmcdermo> shachaf: Equationally makes sense, just. I guess I still have an imperative intuition.
01:29:08 <mm_freak> to understand code you would now have to actually look up the library's API
01:29:13 <shachaf> mmcdermo: Well, it certainly won't do what you want.
01:29:15 <mm_freak> instead of just asking for a type
01:29:16 <johnw> i don't believe that considering bad coders is a sound principle of language design
01:29:21 * hackagebot snaplet-postgresql-simple 0.3 - postgresql-simple snaplet for the Snap Framework  http://hackage.haskell.org/package/snaplet-postgresql-simple-0.3 (DougBeardsley)
01:29:37 <Twisol> mm_freak: I read that record syntax can be a bit of a pain to work with. Is the reasoning here similar?
01:29:49 <johnw> I don't hear the Agda community bemoaning their decision...
01:30:02 <mm_freak> Twisol: no, the record syntax just sucks, but it's sufficient, because we got lenses =)
01:30:03 <shachaf> I don't hear the Agda community at all.
01:30:07 <Twisol> XD
01:30:08 <shachaf> It's a very small community.
01:30:35 <mm_freak> johnw: the agda community knows agda very well…  i always have to look up the source code, when i want to write something using the standard library
01:30:51 <mm_freak> johnw: because in agda i can't be sure what "[x]" means
01:30:59 <mmcdermo> shachaf: Well I'm glad that I guessed that much :)
01:31:42 <edwardk> johnw: i used to think i'd like mixfix and unicode operators. having used them, i'm not so sure i like the experience of programming in languages that have them.
01:31:54 <mm_freak> ditto
01:31:56 <johnw> edwardk: what experience did you have?
01:32:20 <mm_freak> when i saw agda for the first time i was amazed by what /i/ could do with the syntax…  but when trying to work with what /others/ have done with the syntax i hated it
01:32:57 <mm_freak> …  to the point, where i'd define stuff myself rather than using the stdlib
01:33:29 <edwardk> well, i wrote an entire structured editor back when i believed in it, that ran as custom chrome in mozilla which could edit families of grammars that happened to be unicode encoded, but could also have superscripts, subscripts, etc. later on i wrote a good chunk of agda and played with rebindable syntax in coq.
01:34:33 <elliott> the thing with something like Agda is, IMO, that you are thinking in terms of the keypresses you write
01:34:39 <edwardk> my experience with these has left me _not_ wanting them for haskell. i actually ripped mixfix _out_ of a toy language of mine after using agda for a while
01:34:39 <elliott> which means all the tex abbreviations agda-mode has
01:34:49 <elliott> and what you see doesn't correlate very closely to what you're actually typing in
01:34:55 <elliott> which is a bit of an impediment when your source is still linear text files
01:35:09 <johnw> interesting
01:35:11 <edwardk> elliott: exactly. the input translation is 'heavy'
01:35:20 <elliott> like if you go further down the structural route then that's at every layer of your system
01:35:30 <elliott> but with Agda, it looks pretty, but I don't think it makes for a good read-write experience
01:35:40 <edwardk> I don't like thinking about how to enter whatever it is i have to type. I just want to type it.
01:36:10 <elliott> I can see a system with decoupled "input commands" and display in such a way that you're not really entering a linear stream of text any more working
01:36:13 <mm_freak> yeah, that bothers me every time…  i have to find out how to type that damn thing, which gets me out of "the zone"
01:36:15 <edwardk> when i read something in agda, sure I can go into emacs, hover over it, hit a key combo and find out what the tex input form is for it, etc. but i don't want to stop and do that
01:36:21 <elliott> but that's another thing compared to what exists in Agda and the like
01:36:25 <elliott> that said I like Coq's rebindable syntax
01:36:30 <johnw> edwardk: I do find it nicer in Emacs to type ->, and see →, rather than having to type a special key combination to make →
01:36:31 <elliott> seems to be the most hassle-free of the bunch
01:36:38 <elliott> easy to add new quantifiers etc.
01:36:54 <mm_freak> johnw: in agda-mode you have to type \-> to get →
01:37:00 <elliott> or \to
01:37:00 <elliott> johnw: try typing -> and seeing ->
01:37:01 <shachaf> I find it pretty nice to type ->, and see ->
01:37:04 <shachaf> And also there's a -> in the file.
01:37:06 <johnw> yeah, I just used it to type those characters :)
01:37:09 <shachaf> And the parser parses a ->
01:37:11 <mm_freak> what i like is haskell-mode's unicode /view/
01:37:11 <edwardk> shachaf: =)
01:37:14 <elliott> johnw: that way, what you see is what you have to type to reproduce it
01:37:16 <johnw> i use Agda's input mode in my IRC client
01:37:20 <mm_freak> but that's just a view…  you still type the code as-is
01:37:22 <elliott> which is one of the nice properties of textual code
01:37:24 <johnw> yes, that's what I mean, I like the unicode view
01:37:26 <mm_freak> and you can control the view
01:37:35 <johnw> that way I see unicode, but people reading my code see what they expect
01:37:45 <elliott> of course this isn't the same thing as "Unicode is bad"... it's perfectly reasonable to have things like accents in names
01:37:58 <edwardk> johnw: except you fubared the spacing trying to line it up on your screen, not theirs ;)
01:38:00 <shachaf> johnw: The fact that what you see can be encoded as Unicode is irrelevant at that point.
01:38:03 <elliott> but unless you use an APL keyboard I don't believe Unicode is a win for syntax itself
01:38:11 <johnw> edwardk: that's true, I just account for that myself
01:38:11 <shachaf> It's just pretty-printing it. It could use graphics just as easily.
01:41:50 <mm_freak> edwardk: i use unicode view in emacs and i don't fubar the spacing =)
01:42:10 <johnw> mm_freak: how do you avoid the fact that -> and → are not the same width?
01:42:36 <mm_freak> johnw: well, first of all i set "->" to be displayed as a long arrow, but that doesn't answer the question
01:42:55 <mm_freak> it's just a matter of coding style really
01:43:22 <Jafet> Fixed-width fonts, how quaint
01:43:37 <mm_freak> for example i never write "x <- do y" followed another action after y
01:43:57 <mm_freak> the do-block content is on the next line indented in the usual way
01:49:04 <hiptobecubic> Jafet, you don't program in a fixed width font?
01:49:15 <hiptobecubic> Jafet, in a whitespace sensitive language? Must be fun
01:49:37 <osfameron> well, whitespaces are the same width as each other,even in a proportional font
01:50:15 <hiptobecubic> ah true. i guess all leading whitespace will work out
01:50:19 <nicoo> osfameron: Nope, depends on the actual space you are using </typo nerd>
01:50:32 <hiptobecubic> what do you mean?
01:50:49 <nicoo> But still, using only regular spaces will stop you from doing nice-looking alignment, won't it ?
01:51:01 <hiptobecubic> are two spaces not twice as long as one space?
01:51:44 <nicoo> hiptobecubic: you can also use hair spaces, or thin spaces
01:51:52 <nicoo> They are whitespace
01:52:47 <Mon_Ouie> Do Haskell compilers even treat those as whitespace?
01:52:57 <nicoo> See http://en.wikipedia.org/wiki/Space_(punctuation)#Spaces_in_Unicode
01:53:41 <nicoo> Mon_Ouie: I have absolutely no idea; depends on whether the lexer uses Unicode's definition for whitespace.
01:54:20 <nicoo> If it does, you may probably do awful obfuscation using zero-width space
01:55:37 <hpaste> nanothief pasted “alignment of let” at http://hpaste.org/79281
01:56:00 <nanothief> hu, anyway, wouldn't the post above need a fixed space font?
01:56:12 <nanothief> (didn't know hpaste auto posted)
01:58:13 <nicoo> nanothief: As I said, and AFAIK, nice-looking alignment requires monospace.
01:58:40 <Walther> Totally new to haskell, and as I like to learn how to make the simple prime parser as my first task in any language, could anyone help me with this: http://pastebin.com/SSNsXau9
01:59:13 <Walther> the idea is to make a thing so I could "take 100 primes" or "take 5 primes" because the ability to have infinite lists in Haskell looks nice
02:00:58 <Twisol> Walther: What particular problem did you have?
02:01:37 <Walther> Twisol: Well, first of all, that code snippet doesn't compile; there's something wrong with it :D
02:01:44 <mm_freak> Walther: if you want to generate an infinite list of primes it seems weird to use a list for one thing and recursion for the other
02:01:49 <nanothief> Walther: you are very close to getting that program right. Firstly, use False instead of false. Secondly, use "`div`" rather than "/" for dividing integer values resulting in an integer
02:01:58 <Twisol> ^
02:02:12 <Twisol> Walther: In the future, pasting your error will help us help you help us all
02:02:35 <Twisol> …I was going for a Portal quote but I think I flubbed it.
02:02:36 <nanothief> I'm not saying that is written perfectly, but it is a pretty good first program
02:02:50 <mm_freak> indeed
02:03:44 <nicoo> Walther: Why do you call this a « prime parser » ?
02:04:05 <Walther> nanothief: well, a) I've already had a course of java and a course of python, b) got a bit of help with that snippet already as well (the part of making it split in two parts)
02:04:45 <ksf_> why don't we have a version of haskell that's as lean and mean as lua?
02:05:14 <Walther> nicoo: nah, the point was merely that I like to make a "simple prime parser" (aka not erastothenes sieve but the simple division/modulo thing) and in Haskell I just took the idea of infinite lists as a cherry on top
02:05:32 <Walther> Oh, and shove "when learning a language" somewhere in that sentence
02:05:41 <mm_freak> ksf_: basically because it's not possible
02:05:57 <ksf_> how so?
02:06:18 <ksf_> lazy-k proves how small referentially transparent languages can get.
02:06:28 <mm_freak> ksf_: laziness, syntax and the type system…  those three require either a very smart compiler or a very large interpreter
02:06:33 <nicoo> Walther: Yeah, but why do you *call* this a parser ?
02:06:53 <nicoo> This has nothing to do with syntactical analysis <O>
02:07:05 <Walther> Also, thanks all! Also, is there a way to use something else in syntax than backticks e.g. `mod`, as on my keyboard layout, a backtick requires three keypresses (holding shift and two hits of the tick key)
02:07:05 <ksf_> I'd be willing to go without a type system, if that's possible.
02:07:13 <Walther> nicoo: No, this is not a parser
02:07:16 <ksf_> in any case, pure HM is way easier than what haskell does.
02:07:21 <mm_freak> ksf_: then it's just scheme with a different syntax
02:07:27 <ksf_> and lazy.
02:07:29 <Walther> nicoo: my language might be flawed occasionally, sorry about that
02:07:45 <mm_freak> ksf_: lazy without static typing?  you're insane
02:07:45 <ksf_> it's just that even when coding haskell, lua is still the best scripting language.
02:07:58 <nicoo> Walther: Np; I just wasn't able to make sense of it
02:08:00 <ksf_> ...you're not supposed to write big stuff in it.
02:08:08 <mm_freak> ksf_: when coding in haskell, haskell is a nice scripting language…  see the hint library
02:08:14 <Twisol> ksf_: can't help but agree that lua is awesome
02:08:24 <ksf_> hint is not what I'd call lean and mean
02:08:35 <Walther> Also, sweeeeeet, when loading that thing in ghci and taking an arbitrarily long list of primes, it actually outputs them lazily as well
02:08:41 <nicoo> @hoogle hint
02:08:41 <lambdabot> Graphics.Rendering.OpenGL.GL.Hints module Graphics.Rendering.OpenGL.GL.Hints
02:08:41 <lambdabot> Graphics.Rendering.OpenGL.GL.Hints hint :: HintTarget -> StateVar HintMode
02:08:41 <lambdabot> package hint
02:08:53 <mm_freak> ksf_: it's not that difficult to write an interpreter for a small functional language
02:08:57 <Twisol> Walther: welcome to Haskell. :>
02:08:58 <mm_freak> (in haskell)
02:09:35 <mm_freak> and i think it's not a big art to come up with a language better than lua
02:10:28 <mm_freak> if you can live with scheme syntax you can write an interpreter for a lazy functional language with static types quite quickly
02:10:40 <mm_freak> it won't be haskell, though
02:10:57 <mm_freak> or anywhere near haskell for that matter
02:11:46 <mm_freak> but really, when your host program is written in haskell anyway, i see little reason not to use hint
02:12:22 <c_wraith> how about the fact that the ghc api never allwos code objects to be GC'd?
02:12:55 <mm_freak> c_wraith: i don't know what you mean…  hint never releases loaded stuff?
02:13:01 <ksf_> mm_freak, what about the 90m footprint?
02:13:24 <mm_freak> ksf_: put "shared: True" into your ~/.cabal/config and compile your programs with -dynamic
02:13:46 <ksf_> it's still 90m when you deploy it.
02:13:57 <mm_freak> sure
02:14:00 <ksf_> lua weights a hundred k or so.
02:14:20 <c_wraith> also, hint needs GHC installed on the machine running it
02:14:25 <c_wraith> not just the machine that compiled it
02:14:37 <mm_freak> i agree that hint is not a nice solution
02:14:46 <mm_freak> but it's certainly quick-n-dirty
02:14:47 <Walther> Twisol: haha, thanks. It does look pretty awesome in many ways, and I read a MS research lab paper on how "the free lunch is over", as processing power/speed won't be getting any faster anymore but instead the focus will be more on additional cores -> to stay with the increasing speed of things we need to learn better parallelizing
02:16:08 <mm_freak> but really, i'd use hint rather than forcing myself to use lua
02:16:17 <Twisol> Walther: all valid. I like Haskell for more selfish reasons though: it changes (in a good way) how I design code even in other languages
02:16:40 <Walther> Anyway, then the two big questions you've all probably already got used to hear: simple explanations of monads and currying
02:17:07 <mm_freak> Walther: currying means that all functions take exactly one argument
02:17:14 <c_wraith> monads are...  don't worry about it.  They're an abstraction that won't make any sense if someone just defines.
02:17:24 <mm_freak> f x y = (f x) y, so a "binary" function is just a function that returns a function
02:17:25 <c_wraith> monads will make sense when you understand enough for them to make sense
02:17:27 <mm_freak> that's currying
02:17:37 <mm_freak> and don't try to understand monads…  just use them
02:17:39 <Twisol> monads are just function application with extra semantics.
02:18:11 <Walther> i think someone somewhere explained that monads can be a way to apply functions to results of functions, even if there are multiple results
02:18:13 <Maxdamantus> What extra semantics?
02:18:25 <mm_freak> Walther: it's useful to know that a monad is a type constructor, not a value, so Maybe is a monad, but "Just 3" is not a monad
02:18:29 <c_wraith> Maxdamantus: any extra semantics, assuming they work as kleisli arrows
02:18:53 <Walther> for example solving sixth roots of complex numbers by having a root function and a cubic root function
02:18:56 <c_wraith> Walther: that's one application of the abstraction.  the monad interface is more abstract than that.
02:19:22 * hackagebot acid-state 0.8.2 - Add ACID guarantees to any serializable Haskell data structure.  http://hackage.haskell.org/package/acid-state-0.8.2 (DavidHimmelstrup)
02:19:40 <c_wraith> Walther: and that's the problem with trying to learn what a monad is.  You'll learn examples of them instead - and potentially be mislead into thinking Monad describes the example, not the general concept.
02:20:13 <mm_freak> Walther: the core of monads is the bind operator spelled ">>=", and its type is probably the best explanation of what a monad is, if you put it into context (i.e. a specific monad like Maybe)
02:20:19 <Walther> Hm. Anyway, the whole monad/abstraction thing sounds like something very useful to learn
02:20:31 <c_wraith> the best way to learn it is to ignore it and just use haskell. :)
02:20:37 <mm_freak> =)
02:21:02 <Twisol> agreed - you tend to pick up on patterns as you go, and start realizing people have already given them names
02:22:46 <Twisol> Night!
02:22:48 <mm_freak> Walther: you have a function that produces a Maybe, like an integer square root function, Integer -> Maybe Integer, but its argument comes from another Maybe value, a Maybe Integer…  the monadic interface to Maybe allows you to express that passing
02:24:26 <Walther> mm_freak: sounds like that could be used as the type definition of the second part in the prime list thing I created then?
02:25:07 <mm_freak> Walther: your code isn't written monadically
02:25:14 <Walther> True, but it could be :P
02:25:21 <Walther> (i guess)
02:25:33 <mm_freak> you can write everything monadically, but it's not always something you want to do =)
02:26:23 <mm_freak> Walther: write an integer square root function of type Integer -> Maybe Integer
02:27:08 <mm_freak> 0 → Just 0; 1 → Just 1; 2 → Nothing; 3 → Nothing; 4 → Just 2; …
02:27:28 <mm_freak> then i will help you express the fourth root by using Maybe's monadic interface
02:28:13 <juliohm> I want Haskell, C++ templates are so restrictive. :(
02:28:38 <mm_freak> juliohm: they are far less restrictive than haskell actually
02:28:46 <mm_freak> (which is bad)
02:28:53 <c_wraith> they also have much more complicated syntax
02:31:19 <juliohm> Seriously? I was thinking generics in Haskell was much more easy to achieve.
02:31:30 <mm_freak> juliohm: they are
02:31:41 <mm_freak> id :: a -> a
02:31:41 <juliohm> pattern matching is really powerful and clean
02:31:42 <mm_freak> id x = x
02:32:08 <juliohm> partial specialization with template functions is not allowed in C++
02:32:13 <mm_freak> that's a polymorphic function with a type variable (what you call a "generic") 'a'
02:32:14 <juliohm> how about Haskell?
02:32:23 <mm_freak> what is partial specialization?
02:33:50 <shachaf> data Bush a = Nil | Cons a (Bush (Bush a)) -- you should write this in C++!
02:34:19 <juliohm> mm_freak, in some sense is the same as partial application
02:34:25 <juliohm> but with types
02:34:29 <johnw> partial specialization provides a custom definition for a specific type
02:34:39 <Nereid> shachaf: what is that even.
02:34:42 <johnw> like for foo<T, U>, you can customize for foo<int, U>
02:34:50 <shachaf> Nereid: I'm not completely sure.
02:34:52 <mm_freak> you can achieve partial specialization in johnw's sense
02:35:03 <johnw> explicit specialization is when you do the same for all types, like foo<int, double>
02:35:17 <mm_freak> but it's not transparent (because haskell forbids the same type to have different associated code)
02:35:17 <shachaf> Nereid: Can you draw me some pictures or something?
02:35:20 <shachaf> Thanks!
02:35:22 <juliohm> that's also called full specialization
02:35:25 <Nereid> nope!
02:35:30 <Nereid> I'm bad at drawing.
02:35:36 <shachaf> OK, write me some pictures.
02:35:51 <Nereid> lol
02:36:01 <invariant> johnw, that's not partial spec.
02:36:32 <johnw> ?
02:36:36 <mm_freak> juliohm: whatever it is, it's probably that either you can do it in haskell or just don't need it
02:36:51 <Walther> mm_freak: gah, can't get the integer square root done right now, will come back to it later next week - have some exams to read to (compsci math 1 midterm III tomorrow)
02:37:06 <mm_freak> Walther: alright =)
02:37:35 <mm_freak> Walther: before learning monads just write one or two little toy applications or even some command line helpers
02:37:41 <mm_freak> it's a very useful way to get into haskell
02:37:55 <mm_freak> Walther: also check out the amuse-bouche video on youtube
02:38:06 <mm_freak> it shows you what the power of higher order functions can do =)
02:39:14 <mm_freak> http://www.youtube.com/watch?v=b9FagOVqxmI
02:40:42 <DR6> hi
02:40:50 <DR6> i'm a beginner to haskell
02:40:59 <DR6> trying to learn custom typeclasses
02:41:23 <johnw> having fun?
02:41:28 <DR6> yes
02:41:29 <nyc> > let { isqrt' x (a, b) = let { c = (a + b) `div` 2 ; c' = (c + (x `div` c)) `div` 2 ; y | c' > a && c' < b = c' | otherwise = c } in if y * y > x then (a, y) else (y, b) ; isqrt'' x = let ivls = iterate (isqrt' x) (1, x) in head $ dropWhile (\(a, b) -> b > a + 1) ivls ; isqrt x = let (a, b) = isqrt'' x in guard (a * a == x) >> return a } in isqrt 1521 :: Maybe Int
02:41:31 <lambdabot>   Just 39
02:41:47 <DR6> i'm trying to implement mathematical functions
02:42:06 <DR6> so you can build a linear function giving m and n
02:42:27 <DR6> and use it as a normal function using a "run" function
02:42:37 <DR6> I have this code
02:42:37 <DR6> https://dl.dropbox.com/u/2296763/math.hs
02:42:42 <DR6> and doesn't work
02:42:55 <juliohm> mm_freak, i'm just sharing my agony doing generics with C++ templates. :P
02:43:03 <juliohm> It's a pain
02:43:07 <juliohm> boiler plate code
02:43:35 <mm_freak> DR6: you don't need/want a type class there
02:44:00 <Nereid> that doesn't explain why it doesn't work, though.
02:44:04 <Nereid> DR6: the Function class definition says that run f can be applied to *any* instance of Num, not just Float.
02:44:06 <Nereid> look at the types:
02:44:06 <DR6> I want to have several types of functions and to be able to use the same function "run" on them
02:44:21 <mm_freak> DR6: data Function = Linear (Double -> Double) | Exp (Double -> Double)
02:44:23 * hackagebot directory-layout 0.2.0.0 - Declare, construct and verify directory layout  http://hackage.haskell.org/package/directory-layout-0.2.0.0 (MatveyAksenov)
02:44:23 <Nereid> run :: (Function f, Num a) => f -> a -> a
02:44:30 <mm_freak> apply :: Double -> Function -> Double
02:44:30 <Nereid> mm_freak: why
02:44:37 <invariant> juliohm, in Haskell you pay a price for the generics at run-time (boxing).
02:44:38 <Nereid> well,
02:44:41 <Nereid> why Double -> Double
02:44:48 <mm_freak> to make it simple
02:44:54 <DR6> I tried to make it for any instance of Num, but it gave the same error
02:44:58 <juliohm> invariant, could you elaborate?
02:45:08 <juliohm> What is boxing and how it affects performance in Haskell?
02:45:16 <Nereid> let's put things on hpaste.
02:45:16 <mm_freak> data Function a = Linear { apply :: a -> a } | Exp { apply :: a -> a }
02:45:27 <invariant> juliohm, it's just a pointer to an actual value.
02:45:41 <hpaste> “Nereid (for DR6)” pasted “math.hs” at http://hpaste.org/79282
02:46:01 <mm_freak> DR6: the way i see it you just want to annotate regular functions with some additional information
02:46:04 <mm_freak> right?
02:46:20 <DR6> yes, kind of
02:46:32 <invariant> juliohm, are you looking for a language with C++ performance and high correctness?
02:46:49 <Nereid> anyway
02:46:52 <invariant> juliohm, meaning, no random segmentation faults etc.?
02:47:13 <mm_freak> DR6: well, there are very nice ways to do it, but they aren't exactly beginner-friendly
02:47:23 <mm_freak> in any case, none of them involve type classes
02:47:29 <mm_freak> in fact you seldomly write a custom type class
02:47:38 <Nereid> well here's the simplest thing you could do to make it "work"
02:47:40 <hpaste> Nereid annotated “math.hs” with “math.hs (annotation)” at http://hpaste.org/79282#a79283
02:48:08 <Nereid> or, a simple thing.
02:48:26 <mm_freak> DR6: how are you using this annotation anyway?  are there places where you specifically ask whether a function is linear or exponential?
02:48:46 <juliohm> invariant, yes, could you please present me to this dream?
02:48:46 <DR6> yes
02:48:57 <Nereid> but it's probably better to not use typeclasses at all.
02:48:58 <invariant> juliohm, ATS does this.
02:49:00 <Nereid> example:
02:49:14 <invariant> juliohm, ##ats
02:49:33 <hpaste> Nereid annotated “math.hs” with “math.hs (annotation) (annotation)” at http://hpaste.org/79282#a79284
02:49:44 <mm_freak> DR6: a proper solution here uses only one type
02:49:53 <mm_freak> and no type class at all
02:50:40 <DR6> oh yes, nereid's solution is what I was looking for
02:50:43 <mm_freak> my variant would be:  data Func a b = Lin (a -> b) | Exp (a -> b)
02:50:48 <DR6> I'm stupid
02:50:58 <juliohm> thanks invariant ,i'll investigate later. :)
02:51:03 <DR6> yes, no need for typeclasses then
02:51:05 <mm_freak> (however, i'd probably use some type trickery to make this information static)
02:51:09 <juliohm> invariant, why is it not famous?
02:51:12 <Nereid> you could even give a type parameter to Function, instead of sticking with Float.
02:51:16 <invariant> juliohm, Haskell is a nice stepping stone to learn that most programs  can be written for at least 90% in a functional way.
02:51:17 <Nereid> and then run :: Floating a => Function a -> a -> a
02:51:51 <DR6> thanks
02:51:52 <invariant> juliohm, only 0.001% of programmers have the mathematical maturity to use it.
02:52:27 <mm_freak> invariant: you seem to be implying that haskell can't be as fast as C++, but my code comes very close and when parallelized even outperforms C/C++
02:52:30 <invariant> juliohm, do you know those pictures where you see a retarded person use PHP, and Einstein Haskell? Well, for ATS there is no picture ;)
02:52:58 <mm_freak> ATS is quite ugly compared to haskell
02:53:15 <hpaste> Jack pasted “main” at http://hpaste.org/79285
02:53:22 <invariant> mm_freak, if you post that to a place where C++ are and you say that you pay 10000$ for it to be faster than whatever your wrote, you are not going to win that battle.
02:53:43 <invariant> s/C++/C++ people
02:53:56 <mm_freak> invariant: writing assembler in C++ doesn't count…  it has to be C++ code
02:54:10 <mm_freak> and even then it's actually really difficult to come up with a better implementation
02:54:12 <invariant> mm_freak, most likely the mere trolling action to suggest it is faster will already result in people proving you wrong.
02:54:19 <juliohm> I'll push my work to use this new growing world of functional languages.
02:54:48 <juliohm> thanks, now i have to finish this implementation. :)
02:55:02 <mm_freak> invariant: i'm happy to provide a piece of code that has this property…  it isn't even optimized to the edge
02:55:49 <mm_freak> but my point is, if you want to get a language with haskell's properties, but with speed close to C++, use haskell with GHC
02:55:57 <invariant> mm_freak, post it on reddit and say that you will get some stranger to show a pie at you when you are beaten.
02:56:04 <invariant> throw
02:56:12 <Nereid> what kind of pie?
02:56:23 <invariant> Warm apple pie.
02:56:45 <Walther> mm_freak: "so many of you might be scratching your heads and thinkin 'so does reverse work on a string or a list of strings'; and the answer is 'yes'" :D
02:56:52 <Nereid> what a waste of pie.
02:57:07 <hpaste> “Ertugrul Söylemez” pasted “Efficient parallel safe prime search” at http://hpaste.org/79286
02:57:14 <mm_freak> invariant: http://hpaste.org/79286
02:57:18 <mm_freak> feel free to post on reddit =)
02:57:33 <mm_freak> that code has already challenged some C programmers and is the winner so far ;)
02:57:43 <portnov> hi all
02:58:14 <mm_freak> Walther: =)
02:58:19 <Nereid> :=)
02:58:31 <portnov> forM_ [1..1000*1000] $ \i -> forkIO $ doSomethingUseful i
02:58:35 <invariant> mm_freak, you should provide dependencies too.
02:58:42 <portnov> can this work as desired on 4-core CPU?
02:58:58 <mm_freak> invariant: sorry, the deps are arithmoi and parallel
02:59:14 <mm_freak> portnov: yes
03:00:05 <portnov> in my case, it seems, it takes too much time to create so many threads
03:00:53 <mm_freak> portnov: creating a million threads takes 800ms here
03:00:54 <portnov> so they do not do anything, only borning
03:01:04 <portnov> hm
03:01:06 <portnov> ok
03:01:17 <mm_freak> benchmark:  main = replicateM_ (10^6) (forkIO (return ()))
03:01:36 <portnov> another question: isn't Control.Concurent.STM.TChan.writeTChan blocking ?
03:01:52 <mm_freak> portnov: no
03:02:00 <portnov> i.e., does it block until someone reads the chan?
03:02:03 <mm_freak> portnov: you probably want MVar/TMVar
03:02:17 <mm_freak> Chan/TChan only blocks on reading, when there is no data
03:02:49 <portnov> no, really i need only block-on-reading
03:03:13 <mm_freak> then Chan/TChan will do, although most likely TQueue will suffice
03:03:22 <invariant> mm_freak, what's a well known C++ program that does the same?
03:03:55 <mm_freak> invariant: openssl, and it sucks
03:04:04 <mm_freak> invariant: my code is orders of magnitude faster than openssl
03:04:15 <invariant> mm_freak, is this the same?  time openssl gendh 1024
03:04:29 <invariant> mm_freak, when I give your argument 1024 too as an argument?
03:04:32 <mm_freak> invariant: yes
03:04:33 <portnov> i have a million of threads which communicate using chans
03:04:47 <invariant> mm_freak, there is a two second difference here.
03:05:03 <mm_freak> invariant: the answer may be different though, because gendh gives you a random prime
03:05:32 <mm_freak> invariant: to get a real benchmark you have to run gendh many times
03:05:53 <mm_freak> it can take anywhere between a few seconds and a few hours
03:05:56 <invariant> mm_freak, doesn't OpenSSL need to generate those in a secure way?
03:06:09 <mm_freak> invariant: it needs to generate safe primes and generators
03:06:17 <mm_freak> generator generation time is negligible
03:06:24 <invariant> mm_freak, oh, right, there is nothing secret about it.
03:06:28 <mm_freak> yeah
03:07:12 <mm_freak> invariant: the power of my code becomes visible when you try this:  ./primes {512..1024} +RTS -N
03:07:19 <invariant> mm_freak, let me put it differently then: Haskell can be good for low-memory algorithms or algorithms that do not create worst case behaviour in the GC.
03:07:59 <mm_freak> that's also wrong…  one of my programs supposedly uses all of my RAM for its task
03:08:01 <invariant> mm_freak, I can also imagine that your Haskell code use number theory that is not implemented in C++.
03:08:13 <mm_freak> it too outperforms C with mpz_*
03:08:33 <invariant> mm_freak, does it access memory in an unpredictable way?
03:08:35 <mm_freak> haskell's Integer is faster than GMP's mpz_* interface, and the mpn_* interface is really inconvenient
03:08:48 <mm_freak> yes
03:08:59 <mm_freak> in a random way even
03:09:12 <mm_freak> check out my quickset library…  the program uses it
03:09:18 <invariant> mm_freak, then please write a book with a C++ expert and call it "Haskell is competetive, you n00bs!"/
03:09:38 <invariant> competitive
03:10:06 <invariant> mm_freak, also, can you let it do some I/O?
03:10:47 <mm_freak> except for some progress reports that program outputs only the result
03:11:00 <mm_freak> little I/O, but interleaved with the algorithm
03:13:06 <mm_freak> to be fair i have a few years of experience writing high performance haskell code =)
03:14:50 <invariant> mm_freak, I also optimized things to be 1000 times faster or so than a naieve implementation, but it was still 10 times slower than C++.
03:15:07 <invariant> mm_freak, and I am by no means a C++ expert.
03:15:33 <invariant> mm_freak, openssl is also not the greatest code out there, AFAIK.
03:15:42 <mm_freak> invariant: yes, but you shouldn't generalize from /your/ code's performance to the performance of haskell
03:15:48 <mm_freak> yes, openssl code is horrible
03:15:52 <invariant> Lots of people use it, but quite recently some really silly problems had been found.
03:16:48 <mm_freak> openssl is really about as bad as you can get…  worst documentation/popularity ratio i've ever seen, ugly code, complicated API, etc.
03:16:54 <mm_freak> and that's a crypto project!
03:17:07 <invariant> mm_freak, you are not writing Haskell either. You are writing C in Haskell.
03:17:20 <mm_freak> invariant: no, i'm not…  i'm using very high level abstractions
03:17:54 <mm_freak> invariant: the only imperative code in that prime searcher is the sieve
03:18:08 <mm_freak> simply because, well, it's an imperative algorithm
03:18:45 <invariant> mm_freak, I must admit that not all of your code consists of  STUArrays.
03:18:57 <mm_freak> invariant: only the sieve does
03:19:11 <mm_freak> and it makes sense for it to be a UArray (not STUArray)
03:19:37 <mm_freak> the sieve /creation/ is imperative, but the usage isn't
03:20:42 <elliott> invariant: mm_freak's code is far away from C.
03:21:09 <elliott> the only imperative bit is "sieve".
03:21:10 <mm_freak> especially in size =)
03:21:24 <elliott> even that does something you can't do in C: localise the mutability with ST so you know it can't escape
03:21:30 <mm_freak> the equivalent C code would fill a book, because it would essentially reinvent haskell's RTS
03:21:37 <elliott> in fact, not even all of sieve is very imperative
03:22:08 <elliott> since it after all builds a big old functional list to do writeArrays on
03:22:36 <mm_freak> yeah, in fact only a small part of 'sieve' is imperative…  the part that resets bits in the array =)
03:22:39 <elliott> actually you could write a simple wrapper around runSTUArray/writeArray to completely separate the imperative stuff from your code
03:22:42 <mm_freak> the indices are again created declaratively
03:22:50 <mm_freak> yeah
03:23:07 <invariant> mm_freak, how much fiddling did it require to get that to work?
03:23:30 <elliott> foo sz xs = runSTUArray $ do { s <- newArray sz True; mapM_ (\i -> writeArray s i False) xs; return s }
03:23:33 <elliott> or even:
03:23:53 <mm_freak> invariant: don't know exactly, somewhere between 30 and 60 minutes
03:23:56 <elliott> foo sz x xs = runSTUArray $ do { s <- newArray sz x; mapM_ (\(i,x') -> writeArray s i x') xs; return s }
03:24:04 <elliott> in fact, can't you just use Data.Array directly?
03:24:08 <elliott> with no ST
03:24:51 <mm_freak> elliott: that would copy an array of Trues
03:25:10 <mm_freak> the ST version gets along with no copying…  a 'vector' version could fuse the copying away
03:25:29 <mm_freak> but Vector is slightly slower than Array
03:26:11 <mm_freak> only slightly, but enough to make a big impact on that particular code
03:28:43 <invariant> mm_freak, in my experience STArrays containing garbage collected values are really, really bad for performance.
03:29:14 <mm_freak> invariant: values in an STArray don't get garbage-collected
03:29:35 <invariant> mm_freak, since when?
03:29:59 <mm_freak> invariant: since always…  you can't GC array elements before you GC the array itself
03:30:51 <invariant> mm_freak, so, you are saying that if you have an array element and point to some huge structure, and then overwrite that element that no memory is freed ever?
03:31:13 <mm_freak> invariant: in that case of course, but what has the array to do with GC performance?
03:31:39 <invariant> mm_freak, the problem with GC is that it needs to traverse a structure of linear size.
03:31:45 <mm_freak> invariant: the big problem with all kinds of mutable references including arrays is that GHC can't really localize the scope of a heap object
03:32:02 <mm_freak> so it falls back to the "big" garbage collector
03:32:03 <invariant> mm_freak, in C++ you would just say "delete only index 10232323".
03:32:33 <invariant> mm_freak, in Haskell it needs to traverse (in the worst case under low memory conditions) all the indices up to 10232323.
03:32:47 <invariant> mm_freak, that's the problem with GC which most people have.
03:32:56 <mm_freak> invariant: that's true and the reason why you don't use mutable boxed arrays
03:33:03 <mm_freak> however, immutable boxed arrays are very useful
03:33:06 <mikeplus64> there aren't any "lambda guards" are there? like \x | x < 3 -> ...
03:33:09 <mm_freak> i use them all the time
03:33:23 <mm_freak> mikeplus64: GHC 7.6 has an extension for full lambda patterns
03:33:43 <invariant> mm_freak, so, you use unboxed arrays with primitive values and boxed immutable arrays?
03:33:43 <mikeplus64> mm_freak: which?
03:34:01 <mm_freak> mikeplus64: i don't know its name, sorry…  check out the GHC manual
03:34:19 <mm_freak> invariant: i also use unboxed immutable arrays =)
03:34:31 <invariant> mm_freak, now, how are you going to represent a graph with operations to add nodes, remove nodes, add edges, etc.
03:34:37 <mm_freak> invariant: i use a combination of both boxed and unboxed immutable arrays in the 'instinct' library…  check out hackage
03:34:54 <mm_freak> invariant: a graph?  that doesn't sound like an array to me
03:35:10 <mm_freak> incidentally instinct uses something graph-like, a neural network
03:35:24 <mm_freak> high performance ANNs in haskell =)
03:35:28 <invariant> mm_freak, there is an adjacency list matrix representation of a graph which is very common.
03:35:41 <mm_freak> invariant: i'm not experienced there, sorry
03:35:47 <invariant> mm_freak, it supports a lot of operations efficiently.
03:35:58 <invariant> mm_freak, but in Haskell that just doesn't work.
03:36:05 <mm_freak> why?
03:36:36 <invariant> mm_freak, because you want to have generics, which means a boxed representation and you want constant time indexing operations.
03:36:57 <mm_freak> "generics"?  as in polymorphism?
03:37:00 <invariant> mm_freak, (and constant time in place updates)
03:37:02 <invariant> mm_freak, yes
03:37:20 <mm_freak> well, if all else fails, haskell is a wonderful imperative language
03:37:45 * Ralith wonders what invariant thinks boxing has to do with indexing complexity
03:37:59 <invariant> Ralith, you didn't follow the discussion.
03:38:01 <mm_freak> Ralith: you can't have full polymorphism for unboxed values
03:38:12 <Ralith> of course
03:38:16 <invariant> mm_freak, right, so how can that problem be solved?
03:38:34 <mm_freak> invariant: IOize, IOUArrayize everything
03:38:57 <Ralith> invariant: can you answer the question?
03:39:04 <invariant> mm_freak, how does this solve the GC problem?
03:39:34 <invariant> mm_freak, (unless you only expose an API for primitive values)
03:40:27 <mm_freak> invariant: the API isn't necessarily constrained to primitive types
03:40:34 <mm_freak> check out Data.Vector.Storable for example
03:40:50 <mm_freak> even unboxed vectors can actually hold complicated types
03:40:56 <mm_freak> you just have to write a proper Unbox instance
03:41:02 <mm_freak> (or use the TH helper)
03:41:28 <mm_freak> you would basically just write C++ in haskell
03:41:33 <invariant> mm_freak, that would probably solve the problem yes.
03:42:06 <invariant> mm_freak, however, don't you need to pay conversion costs all the time then?
03:42:16 <mm_freak> you pay them in C++ as well
03:42:36 <invariant> mm_freak, why is that?
03:43:19 <mm_freak> invariant: double x; x *= 1.187
03:43:22 <mm_freak> uhm
03:43:25 <mm_freak> invariant: int x; x *= 1.187
03:43:34 <mm_freak> you pay conversion costs there
03:43:41 <mm_freak> haskell just makes you realize it =)
03:43:42 <nicoo> mm_freak: The compiler con optimize this one away, I think
03:44:09 <nicoo> invariant: Also, static_cast and dynamic_cast all have associated, hidden cost (not huge, but it's there)
03:44:12 <mm_freak> nicoo: it's a contrived example…  the compiler can't optimize this away in general
03:44:27 <nicoo> mm_freak: Yeah, of course :)
03:44:31 <invariant> mm_freak, I mean the conversion between the raw memory and a class doesn't exist in C++.
03:45:07 <invariant> mm_freak, in Haskell, there is a difference between a Foo Int Int and some linear memory containing two ints.
03:45:25 <nicoo> invariant: The conversion exists
03:45:27 <invariant> mm_freak, perhaps if you use the proper unboxing annotations, that it will not have those conversion costs.
03:45:29 <mm_freak> invariant: it does, as soon as you start using inheritance and such…  otherwise you're just using a struct and a namespace really
03:45:42 <nicoo> You have some type information in memory (and vtables)
03:45:56 <invariant> I was thinking of the struct case.
03:46:30 <nicoo> invariant: Ah, yeah; in this case, it's just Plain Old C with namespaces and templates.
03:46:34 <mm_freak> invariant: btw, Vector (Double, Double) is really just a continuous memory array of Doubles
03:46:38 <mm_freak> assuming unboxed Vector
03:46:59 <mm_freak> you can't compare (Double, Double) to Vector (Double, Double)
03:47:25 <invariant> Conclusion: you are saying that the data types with unboxed annotations + IOArray can be represented with the exact same memory representations as in C++?
03:47:36 <mm_freak> yes
03:47:54 <invariant> In that case, there really is no room anymore for C++.
03:48:01 <mm_freak> yes, there is
03:48:07 <mm_freak> haskell always comes with its RTS
03:48:23 <invariant> Ok, so we need a pluggable RTS.
03:48:26 <Nereid> I'm actually playing with the concurrency stuff now.
03:48:29 <Nereid> STM is fantastic :O
03:48:49 <invariant> Nereid, the literature doesn't share that opinion.
03:48:59 <Nereid> oh?
03:49:22 <invariant> Nereid, when there is high contention, it breaks down.
03:49:22 <mm_freak> invariant: C and C++ are good for talking to the machine, if you happen to want that…  people like me realize that you simply don't =)
03:49:28 <ion> There are a number of devices which run C++ code but don’t run Haskell code.
03:49:31 <Nereid> ok, what else is there?
03:49:38 <mm_freak> invariant: i'd be happy to write entire OS kernels in a lazy functional language
03:50:10 <mm_freak> a proof of concept exists:  HOUSE
03:50:12 <invariant> mm_freak, I don't want to talk to a machine either. I just want to talk to a language of constructive mathematics and let someone else care about the electrons.
03:50:25 <invariant> mm_freak, yeah, I read the papers.
03:50:35 <invariant> I even ran it at some time in a VM.
03:50:42 <mm_freak> yeah, me too
03:50:55 <invariant> mm_freak, where do you work?
03:50:57 <mm_freak> ion: those devices don't run GHC haskell code
03:51:06 <mm_freak> invariant: i'm self-employed
03:51:48 <Nereid> invariant: I'm not sure how to interpret your comment. are you suggesting that there's a better alternative to STM?
03:51:52 <invariant> mm_freak, only consulting?
03:52:16 <invariant> Nereid, my personal belief is that STM is a good abstraction which has no currently good implementations.
03:52:33 <invariant> Nereid, I have not  proven that, however.
03:52:33 <mm_freak> invariant: mostly programming
03:52:59 <mm_freak> i've done some crypto consulting, but my main strength is getting things done (in haskell) =)
03:53:41 <mm_freak> invariant: haskell's STM implementation is great both in terms of flexibility and performance
03:54:22 <portnov> mm_freak: to which number of threads it is tested to scale good?
03:54:39 <mm_freak> portnov: depends on how you use it really
03:54:48 <ion> mm_freak: I’ll be happy to hear the name of the Haskell compiler i’ll be able to use with my TI Stellaris LaunchPad LM4F120.
03:55:19 <mm_freak> portnov: if you don't use failable transactions it has about the same performance characteristics as using the corresponding non-STM stuff according to my own benchmarks
03:55:24 <invariant> mm_freak, isn't a lock based painfully optimized approach always going to be faster?
03:56:18 <portnov> mm_freak:  for me, currently, it's sending about 10000 numbers between 1024*1024 threads (each sends some numbers to some other threads)
03:56:34 <fryguybob> invariant: It depends, in some ways you can more precicely say what you want with atomicity then with locks.
03:57:15 <mm_freak> invariant: yes, in the same way writing perfect assembly is always going to be better than writing haskell
03:58:48 <invariant> mm_freak, but doesn't the compiler have all the information to compile to such a painfully optimized equivalent?
03:59:44 <mm_freak> invariant: it's missing a key ingredient:  intelligence
03:59:54 <mm_freak> GHC is extremely smart, but not perfect
04:00:06 <invariant> mm_freak, about what? Caches?
04:00:32 <neutrino> hi
04:00:32 <mm_freak> everything…  the architecture, OS, target environment and simply optimization rules
04:00:37 <ion> Too bad the computers will take over and enslave us the moment we make them intelligent enough.
04:01:52 <mm_freak> invariant: as an example, when you compose multiple list functions together chances are the intermediary lists get compiled away…  but that's not the compiler's smartness, but simply a set of RULE pragmas written in the Data.List module
04:02:16 <invariant> mm_freak, and RULE pragmas are  a hack.
04:02:27 <mm_freak> most optimization rules are a hack
04:02:35 <alpounet> a useful one though :)
04:02:49 <neutrino> i am watching this video: http://channel9.msdn.com/Shows/Going+Deep/Programming-in-the-Age-of-Concurrency-Software-Transactional-Memory -- if anyone is interested i have found a way to download the whole thing to disk (not just the wmv playlist that's available)
04:02:49 <invariant> Leroy would not approve.
04:03:00 <mm_freak> there is no real formalism involved here, just a large set of, "this would run faster, if we did this"
04:03:49 <invariant> mm_freak, yeah, I don't get why nobody has written a formalism for that in which you can describe the architecture and logic and the program will figure it out all by itself.
04:04:13 <mm_freak> how do you capture "optimal code" in a formalism in a useful, composable way?
04:04:26 <mm_freak> if you come up with such a formalism, we would be very grateful =)
04:05:26 <invariant> mm_freak, should I send in a grant proposal for that? :)
04:05:53 <invariant> I don't think anyone is interested.
04:06:09 <invariant> It would already have happened if anyone cared. It's not the hardest problem out there.
04:06:42 <Nereid> you aren't interested?
04:06:52 <mm_freak> invariant: i'm very interested
04:07:04 <strebe> it sounds like a rather hard problem to me
04:07:08 <moevenpick> Hey, does anyone know what to do if cabal says "dependency doesn't exist"... if it does exist?
04:07:12 <mm_freak> exactly =)
04:07:23 <alpounet> invariant, i tend not to agree with Leroy on a few topics anyway :)
04:07:34 <mm_freak> moevenpick: after a cabal update?
04:08:01 <moevenpick> mm_freak: yes, I did a cabal update, the problem occurs when I try to install wxhaskell
04:08:25 <alpounet> moevenpick, the name of the package is just "wx" iirc
04:08:33 <alpounet> yeah: http://hackage.haskell.org/package/wx
04:08:35 <Taneb> moevenpick, cabal install wx-0.13.2.3
04:09:01 <Taneb> The 0.90.* branch is for a future, unstable version of wxWidgets
04:09:24 * hackagebot igraph 0.1 - Bindings to the igraph C library.  http://hackage.haskell.org/package/igraph-0.1 (NilsSchweinsberg)
04:09:29 <moevenpick> alpounet: yes, I know, but it fails every time... it's very weird haha
04:09:45 <moevenpick> Taneb: just tried, but it fails too
04:10:56 <alpounet> moevenpick, do you follow the install instructions? http://www.haskell.org/haskellwiki/WxHaskell/Linux - http://www.haskell.org/haskellwiki/WxHaskell/Windows or http://www.haskell.org/haskellwiki/WxHaskell/Mac ?
04:11:29 <moevenpick> alpounet: yes, I did, but for some reason it always fails for a different reason haha
04:11:39 <ksf_> moevenpick, use -v ?
04:12:23 <alpounet> moevenpick, unless someone here has a solution to your problem (about which you should give more details), i guess your best bet is to ask on their mailing list
04:12:52 <moevenpick> I think I will do that later.
04:13:54 <moevenpick> but thank you so far, I think I will try to install 0.13.2.3 for now :)
04:18:36 <sw2wolf> :t fromMabybe
04:18:38 <lambdabot>     Not in scope: `fromMabybe'
04:18:38 <lambdabot>     Perhaps you meant `fromMaybe' (imported from Data.Maybe)
04:18:44 <sw2wolf> :t fromMaybe
04:18:46 <lambdabot> a -> Maybe a -> a
04:19:30 <sw2wolf> :t runMaybeT
04:19:32 <lambdabot> Not in scope: `runMaybeT'
04:19:52 <sw2wolf> :t runMaybeT
04:19:53 <lambdabot> Not in scope: `runMaybeT'
04:28:13 <nomeata> Hi. I am having trouble getting the same module accepted by both fay and ghc. Adding "import Prelude" helps, but I need "sortBy", which is in (for GHC) Data.List and not in Prelude, but for fay it is in Prelude and there is no Data.List.
04:32:26 <gienah> nomeata: I guess this idea comes to mind: import Prelude hiding(sortBy) import Data.List (sortBy) and the create a Data.List module in fay that imports sortBy from Prelude and exports it
04:33:27 <nomeata> gienah: sounds feasible
04:33:58 <`ramses> nomeata: maybe you could use the preprocessor to detect whether you're compiling with ghc, and if so import Data.List
04:34:49 <nomeata> `ramses: it seems that fay does not support cpp, otherwise this would be a good option.
04:34:59 <fryguybob> Doesn't GHC complain if you hide something that isn't there?
04:35:26 <gienah> fryguybob: it used to, but after community pressure this was changed
04:35:53 <hpaste> EvilMachine pasted “Package list with duplicates” at http://hpaste.org/79287
04:36:14 <fryguybob> gienah: Ah, I see.
04:36:56 <EvilMachine> Hey guys. leksah doesn’t want to build, and warns that it’s likely because of duplicates. Well, I can see binary, Cabal, deepseq, being duplicates. But they are only installed once, according to portage. What do I do?
04:37:13 * fryguybob will now proactively start hiding lots of stuff.
04:37:37 <EvilMachine> oops
04:37:51 <EvilMachine> sorry, wrong channel. this should go to #Gentoo-Haskell.
04:51:30 <Guest88993> hi everyone, I am from a C# / PHP background wondering if I should begin Haskell or serverside javascript with node... What are the Haskell pros?
04:51:54 <neutrino> hi Guest88993
04:52:13 <Guest88993> hi :)
04:52:19 <neutrino> i have worked with php a lot in my time
04:52:35 <neutrino> it would be much easier to talk to you if you set your nickname, with the command /nick yournickhere
04:52:46 <neutrino> then we know who we're talking to :)
04:53:06 <neutrino> hi Rasmus
04:53:08 <neutrino> :)
04:53:11 <RasmusW> sorry, just came here ;)
04:53:16 <neutrino> np :)
04:53:24 <neutrino> ok, well
04:53:39 <RasmusW> well I understand you know what I am coming from, that is a good start :)
04:53:45 <neutrino> have you ever done any javascript development yet? for webpages for example?
04:54:22 <b__> RasmusW I was wondering the same a while ago and decided to do both
04:54:36 <Jafet> Haskell isn't webscale
04:54:41 <RasmusW> Only done it client side, mostly with jQuery involved. Just bought Javascript the good parts to kick off with vanilla JS
04:54:46 <neutrino> jafet is just kidding
04:54:49 <neutrino> right
04:55:09 <tdammers> RasmusW: biggest pros of Haskell over JS, IMO, would be performance and type safety
04:55:31 <mikeplus64> RasmusW: i think if you're starting with haskell you ought to start with lyah and/or rwh -- it's quite unlike other languages so just trying to "pick up" a haskell web framework might be very challenging from a C#/PHP background
04:55:52 <Jafet> No, it really isn't webscale
04:55:56 <neutrino> RasmusW: well, i've done some language hopping in my time. i did a lot of php, but its limitations started being too constricting - due to how limited it was in what it could do, or due to how difficult and long-wided programs had to be to do something really interesting
04:55:56 <RasmusW> b__ right now I am at a point where I want to focus on becoming efficient in one of these languages, over time maybe :)
04:56:03 <neutrino> Jafet: please stop that
04:56:08 <Jafet> If you expect it to be, you will be disappointed
04:56:23 <b__> Jafet what are you talking about
04:56:31 <tdammers> Haskell as a web programming language does have a few severe disadvantages
04:56:55 <tdammers> for once, you can't simply expect it to be able to run on cheap shared hosting
04:57:02 <neutrino> Jafet: google people are working on possibly the single fastest web framework across all languages (snap framework), it scales pretty well.
04:57:06 <b__> neither can you with node tdammers
04:57:08 <neutrino> anyways
04:57:17 <tdammers> b__: point taken
04:57:17 <neutrino> RasmusW: following my explanation so far?
04:57:28 <neutrino> explanation/story
04:57:33 <RasmusW> neutrino: Actually I was happy with PHP, it did most of the jobs well, but performance was a bummer for me!
04:57:47 <neutrino> RasmusW: well, that's what i thought too. it was a pain point
04:57:56 <tdammers> PHP is also a rather dangerous thing to work with
04:57:59 <b__> both Haskell and Node.js can be blazing fast
04:58:09 <tdammers> it's pretty easy to fuck up security with PHP
04:58:24 <neutrino> RasmusW: so what i did, was i started trying new languages. i tried Python, JS/Node, even a bit of ruby, i also tried C, and i learnt a lot about SQL, awk, perl, and lots others
04:58:25 <b__> but in developing web apps in both languages, the safety of Haskell has been wonderful
04:58:26 <RasmusW> yep neutrino :)
04:58:34 <tdammers> a more important downside of Haskell is that finding programmers is pretty hard
04:58:36 <neutrino> RasmusW: however, most of those languages had the same flaw
04:58:43 <mikeplus64> one thing haskell definitely has over node performance wise is lightweight/nice concurrency
04:58:52 <neutrino> RasmusW: they were made by people who sat down, and said "hey, let me write a simple language for doing this one job well"
04:58:52 <tdammers> PHP programmers come a dime a dozen (though you get what you pay for)
04:59:29 <neutrino> RasmusW: those languages weren't designed by people who specialize in just that - designing languages. instead, they were "homebrew" so to speak
04:59:42 <tdammers> neutrino: PHP being the parade example...
04:59:52 <neutrino> even C, and a lot of its libs, has this legacy
05:00:06 <RasmusW> Ok, but I understand for web it is not the best at the moment, mostly I am looking for a fast language which I can use to build api's... perferably with a framework...
05:00:14 <typoclass> RasmusW: in my opinion, learning haskell makes you a better programmer, no matter what language you end up using
05:00:17 <neutrino> even though a lot of research went into what we know as C today, it was just a language made to abstract the assembler of a specific piece of hardware in the 70s
05:00:22 <Jafet> Heh, shachaf was right about him talking nonsense
05:01:19 <tdammers> RasmusW: the language itself is excellent for web programming, fast, reliable, easy to secure, and the three big frameworks (yesod, snap, happstack) are all excellent
05:01:37 <tdammers> the problems are social ones, not technical
05:01:37 <neutrino> RasmusW: so i ran into the ceiling with PHP, and i literally couldn't write more complex programs because the language, frameworks, etc were limiting to me. next i went to do some python, and i was happy that there were new things i could do, but i hit the ceiling quite quickly as well
05:01:52 <neutrino> RasmusW: here's the gist of my story: with haskell, the ceiling is so high up i can't even see it yet
05:01:58 <RasmusW> typoclass I guess lerning new things always does, however sure JS is ugly if you do it wrong... I have played with LUA which for sure is different...
05:02:06 <nyc> I can go on about C
05:02:16 <strebe> neutrino: the ceiling is so high I get a headache staring up a few inches
05:02:22 <Chathurga> neutrino: That's what I was going to say haha, I can't even imagine where the ceiling is
05:02:22 <neutrino> RasmusW: and i don't think i'll ever come to a time where i run out of ways to do things in Haskell
05:02:27 <mikeplus64> RasmusW: yesod, snap and happstack are the "big" haskell web frameworks. yesod will be very hard to just "pick up" because of its design. snap or happstack you might like to look at (i prefer snap)
05:02:50 <Chathurga> Tried C for the first time this week. Basic but it makes sense. Then I tried C++... wow
05:02:54 <tdammers> mikeplus64: hehe, I'd say the same, only I prefer happstack :o
05:03:12 <Nereid> Chathurga: wow what? :)
05:03:27 <mikeplus64> maybe libraries is the better word, for none of them do you have to use their default scaffolding tools, which i usually find too much anyway
05:03:29 <blueonyx> have fun with snap and monad transformers as hakell newbie xD
05:03:29 <mm_freak> the reason you hit the ceiling in common languages is that they are defined in terms of features
05:03:29 <neutrino> RasmusW: i'm not sure if i explained this well. is there something i missed in what i was saying?
05:03:29 <Chathurga> Someone was drinking very heavily when they came up with the syntax
05:03:39 <b__> RasmusW, despite this amazing ceiling, the language is very practical
05:03:44 <mm_freak> in haskell you don't see the ceiling, because it isn't there
05:03:52 <typoclass> RasmusW: if you're curious about programming at all, give haskell a shot :-) i bet you'll be surprised in all kinds of ways. lyah is a good book available for free, and you can play around on tryhaskell.org
05:03:55 <typoclass> @where lyah
05:03:55 <lambdabot> http://www.learnyouahaskell.com/
05:04:07 <tdammers> neutrino: yeah, exactly. With PHP, Python, C, or whatever, it feels as if I have to work around the language's limitations; with Haskell, I have to work around my own limitations
05:04:19 <RasmusW> Neutrino fist off thank you... Can you reccommend a framework?
05:04:35 <neutrino> RasmusW: ah, now here's the kicker, i was thinking of this just yesterday
05:04:46 <mm_freak> PHP people don't think of monoids and categories when they design a web framework, and that's their mistake…  that's why PHP frameworks don't scale
05:04:52 <neutrino> RasmusW: you know how in e.g. PHP you have those big frameworks? say, you have Zend, Code Igniter, Drupal
05:05:05 <Jafet> @remember mm_freak PHP people don't think of monoids and categories when they design a web framework, and that's their mistake…  that's why PHP frameworks don't scale
05:05:05 <lambdabot> I will never forget.
05:05:06 <b__> RasmusW, my PHP/C#-loving colleagues like snap
05:05:08 <neutrino> RasmusW: and when you start using one of them, you can't use the others, right?
05:05:34 <neutrino> RasmusW: in haskell, it's different. it's kind of like having hundreds of micro-frameworks, and all of them work together well.
05:05:48 <RasmusW> thanks typoclass I will check that out.
05:06:15 <neutrino> RasmusW: you compose them together. basically that's just single packages. a package in haskell is a bundle of code, kind of like a small framework of sorts.
05:06:17 <mikeplus64> RasmusW: http://happstack.com/docs/crashcourse/index.html looks good, but again probably best to get a feel for haskell first
05:06:32 <tdammers> RasmusW: as others have said, yesod, snap, and happstack are the obvious candidates.
05:06:52 <tdammers> they are all fairly modular, so you can mix and match as you like
05:07:03 <RasmusW> neutrino that sounds really nice, I have used Laraval, webforms (to start ASP.NET) and MVC 4 in C# hated C# it was a school thing for me ;)
05:07:13 <neutrino> RasmusW: haskell is very big on this. "code composability" is an important value here, so that you can take small building blocks - from anywhere - and use them with any other buildig blocks you want
05:07:38 <neutrino> RasmusW: i think that's one of the most important things in haskell
05:07:59 <RasmusW> yesods website look very good and they promise what I need, I think I will kick it off with yesond... is the book they recommend http://shop.oreilly.com/product/0636920023142.do any good?
05:08:31 <mikeplus64> RasmusW: http://www.yesodweb.com/book/haskell you can find it online :)
05:08:36 <RasmusW> neutrino that sounds very efficient over time as you build up a library of code...
05:08:46 <neutrino> RasmusW: btw, since you use C#, you should be able to appreciate this.. the people who work on Haskell (and release their work for free) have also got full-time jobs in big companies like microsoft developing commercial languages, such as C# and F#
05:08:52 <mikeplus64> http://www.yesodweb.com/book RasmusW oops here's the index
05:09:18 <RasmusW> So it is faster then Node, Asynchronous and it is a cleaner language then JS...
05:09:28 <neutrino> RasmusW: for example, right now i'm watching a video about software transactional memory in Haskell. What the guys at microsoft did was first make a perfect version of STM in Haskell, and then make a version of that for C#.
05:09:53 <RasmusW> mikeplus64 oh nice thanks ;)
05:10:03 <neutrino> RasmusW: in many ways, Haskell is like this primodial soup out of which other languages end up springing, and because of that it gets to keep the good bits as this happens
05:10:52 <neutrino> RasmusW: it's kind of like the dream-team language :) imo
05:11:20 <RasmusW> neutrino, so you think haskell is well supported, I mean if MS and other big players use it.
05:11:45 <typoclass> @remember neutrino in many ways, Haskell is like this primodial soup out of which other languages end up springing
05:11:45 <RasmusW> Also I am glad to see it has a nice community, which is important to me...
05:11:46 <lambdabot> Done.
05:12:01 <neutrino> RasmusW: well, it's supported well enough that i could switch over to doing 100% of my work for the last half a year in haskell only
05:12:11 <mikeplus64> RasmusW: spj (lead ghc guy) is employed by microsoft, simon marlow was but he's gone to facebook now for his own reasons
05:12:14 <neutrino> and i depend on that for my bread and boarding
05:12:37 <typoclass> mikeplus64: well, it's microsoft research
05:13:17 <nyc> C has issues representing certain machine features like vectorized returns, BCD arithmetic, differing calling conventions, and so on.
05:13:25 <neutrino> there's also tim harris
05:13:37 <neutrino> who works on C# and works with simon peyton-jones
05:13:56 <RasmusW> so what i hear is that it is good for web... What about software then?
05:14:20 <neutrino> RasmusW: here's an example of how they trickle features down from haskell down to C#, and similarly to F#: http://channel9.msdn.com/Shows/Going+Deep/Programming-in-the-Age-of-Concurrency-Software-Transactional-Memory
05:14:33 <neutrino> it's great for systems programming, RasmusW
05:14:38 <neutrino> and for utilities and other stuff
05:14:53 <b__> even for scripting
05:14:56 <nyc> C's arithmetic assumptions about machine arithmetic and floating point arithmetic are also potentially at variance with hardware.
05:15:05 <neutrino> it also has one of the simplest frameworks for writing hard-realtime assured code for e.g. running timing computers in car engines
05:15:19 <neutrino> and it's great for writing sql manipulations and ETL in
05:15:29 <neutrino> and for writing small scripts you'd normally write in bash
05:15:44 <neutrino> and it's also pretty good for text processing
05:15:55 <nyc> There are scripting languages to do scripting in.
05:16:00 <neutrino> you could write an excel clone in it
05:16:07 <neutrino> nyc: #!/usr/bin/env runhaskell
05:16:42 <mikeplus64> call in the next 20 minutes and we'll throw in an experimental ghc feature
05:17:06 <nyc> That can also be helpful. I myself tend to prefer Haskell to various of the more typical scripting languages for the scripting tasks.
05:17:36 <mikeplus64> i find myself writing haskell-like functions for my shell that i use
05:17:53 <invariant> nyc, it takes a long time to startup a Haskell script when compared to a shell script.
05:18:13 <mikeplus64> (see http://quasimal.com/posts/2012-05-21-funsh.html)
05:18:39 <nyc> invariant: I tended to compile them vs. interpreting them.
05:18:44 <RasmusW> neutrino and everyone else, thanks a lot... I will go explore those resources ;)
05:18:48 <invariant> nyc, then it takes a long time to compile them.
05:18:49 <neutrino> yw :)
05:19:05 <neutrino> if you have any questions, make sure to come here and we'll try to help you :)
05:19:12 <RasmusW> ;)
05:19:19 <nyc> invariant: I compiled once and did the text processing many times after.
05:19:25 <RasmusW> thanks :)
05:19:29 <invariant> nyc, for application development Haskell is quite suitable, but for scripting it is not very flexible.
05:19:54 <invariant> Perhaps a reincarnation of Hugs or NHC could fix this.
05:19:56 <nyc> invariant: Really just basic statistics atop some very simple parsing.
05:20:26 <typoclass> invariant: you're right, i wrote a thingamajig like runhaskell which does compilation when it first sees the script, then on successive runs uses the compiled file. i think it's a good compromise
05:20:33 <Jafet> Haskell is Turing-complete, its applications are endless
05:20:56 * nyc had no issues with just compiling once and running many times after.
05:21:27 <nyc> Admittedly other users have other demands.
05:21:30 <neutrino> invariant: why would hugs / nhc help? were they faster to start up?
05:21:37 <invariant> neutrino, yes
05:21:42 <neutrino> cool
05:21:54 <typoclass> nyc: yes you're absolutely right. and the compiling can even be automated
05:22:01 <neutrino> i wish runhaskell would cache its compiled programs
05:22:06 <neutrino> that would own
05:22:11 <nyc> Why not instrument startup and see if it's possible to speed it up?
05:22:21 <neutrino> that's what i mean nyc
05:22:44 <saati> neutrino: what is that hard-realtime framework?
05:22:48 <neutrino> atom
05:22:53 <invariant> nyc, because the people that know the systems best have no reason to fix it.
05:23:12 <invariant> nyc, academics cannot write papers on it and other people don't use it for scripting.
05:23:35 <invariant> nyc, they don't use it for scripting because actual scripting languages already do that better.
05:23:40 <nyc> Someone who both cares and is capable will have to be found to attack it. I'm not capable for various reasons.
05:24:03 <invariant> nyc, care can be created with money.
05:25:41 <nyc> I can't be brought to bear on it with "bounties" or similar. Health insurance associated with employment is my single largest concern. Someone not operating under similar constraints to those under which I do must be found.
05:39:39 <mpu> Hi, isn't there something nicer than if b then return 42 else fail "" ?
05:40:27 <ksf_> yes, don't use fail.
05:40:46 <mpu> replace it by mzero, I know I am in the Maybe monad.
05:41:07 <elliott> mpu: 42 <$ guard b
05:41:27 <tominator2> I want to write a constructor for a Tuple with variable amount of elements. I tried Tuple = Elem a | Tuple :+: Tuple but the compiler wants me to put Tuple a = Elem a | Tuple :+: Tuple but that would not let me put different types in my tuples. What am I doing wrong?
05:41:45 <mpu> elliott: is this <$ in Control.Applicative?
05:42:13 <ksf_> yep.
05:42:25 <ksf_> @hoogle (<$)
05:42:25 <lambdabot> Data.Functor (<$) :: Functor f => a -> f b -> f a
05:42:25 <lambdabot> Control.Applicative (<$) :: Functor f => a -> f b -> f a
05:42:25 <lambdabot> Data.Functor (<$>) :: Functor f => (a -> b) -> f a -> f b
05:43:29 <DMcGill> is there a function f :: (a -> Bool) -> a -> Maybe a; f p a = if p a then Just a else Nothing?
05:43:43 <DMcGill> I suspect my question is similar to the one just asked, but filterM doesn't do what I want here.
05:43:45 <mpu> elliott: Thank you!
05:44:03 <DMcGill> is there a filterM over Maybe instead of a List perhaps?
05:44:13 <elliott> mpu: :)
05:45:03 <merijn> :t filterM
05:45:04 <lambdabot> Monad m => (a -> m Bool) -> [a] -> m [a]
05:47:26 <DMcGill> @hoogle (a -> Bool) -> t a -> t a
05:47:27 <lambdabot> Control.Monad mfilter :: MonadPlus m => (a -> Bool) -> m a -> m a
05:47:27 <lambdabot> Data.IntMap filter :: (a -> Bool) -> IntMap a -> IntMap a
05:47:27 <lambdabot> Data.Sequence dropWhileL :: (a -> Bool) -> Seq a -> Seq a
05:47:48 <merijn> Did you want Maybe a -> Maybe a at the end or a -> Maybe?
05:48:00 <DMcGill> > (mfilter even (Just 3), mfilter even (Just 4), mfilter even Nothing)
05:48:02 <lambdabot>   (Nothing,Just 4,Nothing)
05:49:23 <DMcGill> :t \p -> mfilter p . Just
05:49:25 <lambdabot> (a -> Bool) -> a -> Maybe a
05:50:34 <fmap> :t \f -> listToMaybe . filter f . return
05:50:35 <lambdabot> (a -> Bool) -> a -> Maybe a
05:51:17 <DMcGill> That also works, but seems more circuitous than mfilter
05:51:32 <DMcGill> might as well filter directly in Maybe than in List and converting imo
06:06:51 <yitz> DMcGill: you don't need mfilter, you can use Data.Foldable.find.
06:07:19 <yitz> @type Data.Foldable.find
06:07:21 <lambdabot> Foldable t => (a -> Bool) -> t a -> Maybe a
06:07:26 <yitz> @type \f -> Data.Foldable.find f . Just
06:07:28 <lambdabot> (a -> Bool) -> a -> Maybe a
06:08:49 <ksf_> :t  \f -> Data.Foldable.find f . pure
06:08:51 <lambdabot>     Ambiguous type variable `t0' in the constraints:
06:08:51 <lambdabot>       (Applicative t0)
06:08:51 <lambdabot>         arising from a use of `pure' at <interactive>:1:30-33
06:10:37 <ksf_> yet another case of type system breakage, in the end there's no way to get different semantics from different (law-abiding) implementations of pure.
06:15:01 <rwbarton> sure there is
06:16:48 <DMcGill> so currently I have `find null (Just (node %~ (L.delete word) $ trie))'
06:17:07 <DMcGill> I'm sure there's something clever than can be done using lens and Foldable
06:17:26 <DMcGill> where null :: Trie -> Bool, and Prelude.null is hidden
06:25:45 <ksf_> rwbarton, find (const True) . pure == id
06:26:00 <neutrino> @hoogle find
06:26:01 <lambdabot> Data.List find :: (a -> Bool) -> [a] -> Maybe a
06:26:01 <lambdabot> Data.Foldable find :: Foldable t => (a -> Bool) -> t a -> Maybe a
06:26:01 <lambdabot> Data.List findIndex :: (a -> Bool) -> [a] -> Maybe Int
06:26:34 <neutrino> ksf_: i think you lost a "fromMaybe" or something
06:26:38 <neutrino> but yeah
06:29:01 <mapf> it's pretty annoying that we can't derive enum for gadt's
06:29:06 <mapf> :[
06:31:45 <elliott> does standalone deriving not work?
06:32:34 <opqdonut> IIRC there is no deriving support for GADTs
06:32:57 <hpc> has anyone thought about the problem of deriving at all?
06:33:05 <neutrino> is import X as Y the same as import qualified X as Y?
06:33:24 <opqdonut> oh, there is
06:33:25 <hpc> no
06:33:29 <opqdonut> (see e.g. http://www.haskell.org/ghc/docs/7.0.4/html/users_guide/data-type-extensions.html)
06:33:33 <neutrino> what does the first one do hpc?
06:33:44 <neutrino> i'm a bit burnt out on trying to understand this stuff
06:33:45 <hpc> ill just cover every case for completeness :P
06:33:46 <opqdonut> the first one imports it unqualified and as Y
06:33:54 <hpc> import X brings stuff from X into the current namespace
06:33:55 <neutrino> opqdonut: oh, so we get both?
06:33:58 <opqdonut> yeah
06:33:59 <neutrino> ok
06:34:07 <hpc> import qualified X brings the X namespace into scope
06:34:09 <opqdonut> so "import X as Y" is pretty useless
06:34:16 <neutrino> hpc: yeha, but i've never seen import without qualified with as
06:34:22 <neutrino> which was pretty weird to see
06:34:23 <hpc> import X as Y brings X into the current namespace, brings Y into scope
06:34:28 <hpc> etc
06:34:30 <neutrino> yeah
06:34:33 <neutrino> thanks :)
06:35:52 <mapf> elliott: nope, standalone deriving doesn't works because which type will have toEnum? well...
06:36:03 <elliott> oh, i see
06:37:15 <mapf> actually I sometimes think if toEnum and fromEnum have been separated in different classes we'll have thrown such cases away
06:38:51 <chexxor_home> This guy says that 7.4.2 has GHCi support on ARM - where could I find this in release notes?
06:39:00 <chexxor_home> It isn't reported here - http://www.haskell.org/ghc/docs/7.4.2/html/users_guide/release-7-4-2.html
06:39:19 <chexxor_home> ideas for where else I could verify that claim?
06:39:42 <hpc> chexxor_home: follow the install directions for 7.4.2 on an ARM cpu
06:39:45 <hpc> see if you can ghci
06:39:57 <hpc> if it doesn't work for a normal install, there's no support for it
06:40:08 <chexxor_home> hpc: Where can I find those instructions? I did my due diligence
06:41:00 <plat0> Can anyone explain to me why Haskell does not need the value restriction?  I cannot understand whether it is because Haskell is pure or because it is non-strict.  Maybe it's both.  Pointers appreciated.
06:41:17 <hpc> http://hackage.haskell.org/trac/ghc/wiki/Building
06:41:26 <sipa> plat0: what value restriction?
06:41:46 <hpc> in theory, building ghc should be a single shell script
06:41:50 <plat0> sipa: ML's value restriction
06:41:53 <hpc> but i have never done it on ARM
06:42:01 <plat0> sipa: http://mlton.org/ValueRestriction
06:43:32 <neutrino> a question about stm
06:43:38 <neutrino> is it possible to nest transactions?
06:44:41 <chexxor_home> thanks hpc - I'm looking into it now - not immediately finding a page on ARM, but I'll keep looking
06:44:46 <hpc> neutrino: as in STM? no
06:45:22 <hpc> i forget what function it is, but it has docs about how you shouldn't use it to go back and forth in and out of STM, or things break
06:45:45 <fryguybob> neutrino: yes.
06:45:45 <nicoo> neutrino: What meaning yould you give to nested transactions ?
06:45:46 <neutrino> well the function to do transactions in stm was called "atomically"
06:46:07 <nicoo> The outer transaction is supposed to execute atomically anyways
06:46:19 <chexxor_home> hpc: When you say "follow the instructions for install on ARM", you mean to follow the normal build instructions, but do it on an ARM machine?
06:46:27 <neutrino> inside a transaction, a further transaction means that the action of that further one is seen as an atomic action by the surrounding transaction
06:46:40 <hpc> yes
06:47:08 <neutrino> a lot of things have nested transactions.. it's not a novel idea. i was wondering why it was decided that STM should explicitly not support them.
06:47:32 <neutrino> i'm certain the guys who did stm could have just as well chosen to support them, so it must've been a design decision
06:47:40 <fryguybob> neutrino: What do you mean not support them?
06:47:53 <neutrino> well stm does not support nested transactions
06:47:59 <chexxor_home> thanks hpc
06:48:06 <fryguybob> neutrino: Where did you read that?
06:48:21 <neutrino> fryguybob: well i read that you can't have an "atomically" inside another one
06:48:32 <neutrino> is that incorrect?
06:49:11 <fryguybob> Composition inside STM is nesting.
06:49:18 <neutrino> i'm only learning about stm right now
06:49:25 <neutrino> so i'm probably in error
06:49:36 <neutrino> how can i nest "atomically" calls?
06:49:40 <hpc> there's probably some reason why you wouldn't want nested transactions
06:49:48 <hpc> but i am straining my brain to figure out what it could be
06:49:52 <neutrino> hpc: right, me too
06:51:29 <fryguybob> neutrino: atomically inside STM would just be id.
06:51:51 <nicoo> fryguybob: Exactly my previous point
06:51:54 <hpc> oh haha
06:52:18 <neutrino> i don't think it would exactly be id, because the surrounding STM code can still see the actions performed in sequence
06:52:56 <hpc> oh!
06:52:59 <neutrino> so for example, if you have two calls: credit person1 100; debit person2 100; then you might want to perform these atomically
06:53:02 <fryguybob> neutrino: with atomically you get to see the result too
06:53:15 <hpc> okay, i got this
06:53:23 <neutrino> yes, the result, but not the intermediate steps fryguybob
06:53:25 <fryguybob> neutrino: Then call that a function and use bind.
06:53:38 <hpc> so what neutrino is thinking i think, is that you can have something roughly along the lines of "only roll back this much"
06:53:52 <hpc> and that can always be refactored into "run this transaction, then run this transaction..."
06:53:56 <neutrino> is that what i'm thinking? hm
06:54:04 <fryguybob> s/function/stm action/
06:54:16 <neutrino> hpc: yeah, i guess i am thinking that
06:54:39 <hpc> or if it can't be refactored that way, you can't meaningfully say "only roll back this much" to begin with
06:55:20 <hpc> it would be somewhat interesting to have checkpoint :: STM ()
06:55:25 <neutrino> why can you not?
06:55:27 <hpc> as a convenience
06:55:38 <neutrino> what i mean is..
06:55:47 <neutrino> you have many types of sql where transactions can be nested
06:55:52 <hpc> neutrino: because in the event of a failure of the inner transaction, you might just have to roll back all the way anyway
06:55:56 <neutrino> it obviously works there, why can't it work in haskell?
06:55:57 <chexxor_home> I was running a previous 'cabal install', I ctrl-c'ed to kill it. Do I have to manually remove files? I can't find a way to check the status of previous package installs.
06:56:08 <neutrino> i think it can, but i'm unable to make a reasonable argument
06:56:30 <hpc> chexxor_home: when did you kill it?
06:56:31 <neutrino> hpc: right, you might, but you might not have to as well
06:56:33 <hpc> configure, build?
06:56:38 <nicoo> neutrino: I can assure you, atomically inside a transaction is id
06:56:42 <neutrino> hpc: that's just the same as with transactions anyways
06:56:47 <neutrino> nicoo: why is it id?
06:56:55 <hpc> if you interrupt the actual install, you could probably just unregister the package and redo the install
06:56:56 <neutrino> i don't exactly see it..
06:57:02 <neutrino> can you show me how that works?
06:57:24 <nicoo> neutrino: Because the outer transaction is already serialized as a sequence of events without interleaving of other transactions
06:57:29 <chexxor_home> hpc - it downloaded,configured, pre-processed, and started building blaze-builder
06:57:39 <fryguybob> neutrino: Is this what you want? do a <- do { x <- readTVar t; writeTVar t (x+1); return t } ; ... a ...
06:57:49 <hpc> chexxor_home: yeah, you haven't broken anything at all
06:57:57 <nicoo> So there is only one valid serialization for the “inner” transaction, which is the obvious one
06:58:00 <chexxor_home> [10 of 13] Compiling <- was the last thing
06:58:20 <chexxor_home> hpc - if it was compiling, there must be files locally, riht?
06:58:29 <hpc> sure
06:58:42 <hpc> and they will either be cleaned, or used to skip some parts
06:58:51 <hpc> but it's the same as doing ^C on ghc --make
06:59:04 <hpc> it just doesn't output the broken last file
06:59:19 <hpc> (last compiled binary, rather)
06:59:24 <neutrino> nicoo: hmm
06:59:27 <chexxor_home> hpc - ah interesting, but it must have successfully created some binaries, no?
06:59:58 <neutrino> nicoo: it sort of is dawning on me, but needs a bit more explanation. can you try to put it in other words?
06:59:59 <hpc> yes; the first 9 modules are compiled
07:00:21 <neutrino> fryguybob: i'm not sure.. that is very generic code
07:00:24 <hiptobecubic> @hoogle Data.List.Ordered
07:00:24 <lambdabot> package ordered
07:00:24 <lambdabot> package unordered-containers
07:00:32 <hiptobecubic> that module is in neither of those packages
07:00:39 <nicoo> neutrino: The outer transaction is already happening « as if it was executed during a single point in time »
07:00:49 <hpc> fryguybob: you mean modifyTVar?
07:00:49 <Peaker> why are the Applicative operations defined in Control.Monad not defined for Applicatives in some standard place?
07:00:55 <nicoo> A nested transaction will then execute “during that point”
07:01:09 <Peaker> mapM is defined as traverse in Data.Traversable, but replicateM/etc are not anywhere
07:01:10 <hpc> Peaker: hysterical raisins?
07:01:13 <neutrino> nicoo: right. however, when i'm inside that transaction, i can see it "decompressed", that is as if it were executed sequentially.
07:01:15 <nicoo> There cannot be an external event interleaved inside
07:01:23 <Peaker> hpc, I mean, in new places like the "traverse" thing
07:01:31 <fryguybob> neutrino: I guess I'm asking, is this what you have in mind as a nested transaction, if only you have atomically before the second do.
07:01:37 <neutrino> nicoo: so you're saying, to an observer outside of the top-level transaction, the inner transaction executes atomically anyways.
07:01:42 <hpc> @src replicateM
07:01:43 <lambdabot> replicateM n x = sequence (replicate n x)
07:01:45 <nicoo> Exactly
07:01:53 <hpc> is there a "sequence" for applicatives?
07:02:06 <neutrino> nicoo: what i'm saying, to an observer inside the top-level transaction, but outside of the inner transaction, i think the inner transaction does not execute atomically
07:02:11 <Peaker> hpc, Yeah
07:02:15 <Peaker> @type sequenceA
07:02:17 <lambdabot>     Not in scope: `sequenceA'
07:02:17 <lambdabot>     Perhaps you meant one of these:
07:02:17 <lambdabot>       `Data.Traversable.sequenceA' (imported from Data.Traversable),
07:02:22 <Peaker> @type Data.Traversable.sequenceA
07:02:24 <lambdabot> (Applicative f, Traversable t) => t (f a) -> f (t a)
07:02:32 <neutrino> nicoo: i think that's the difference in what we're thinking of
07:02:38 <Peaker> generalized on both axis's :)
07:02:40 <nicoo> neutrino: There is sequencing without interleaving, which is the same as atomicity.
07:02:41 <fryguybob> neutrino: But it does execute atomically inside.
07:02:53 <Peaker> hpc, note how sequence is defined:
07:02:55 <Peaker> @src sequence
07:02:56 <lambdabot> sequence []     = return []
07:02:56 <lambdabot> sequence (x:xs) = do v <- x; vs <- sequence xs; return (v:vs)
07:02:56 <lambdabot> -- OR: sequence = foldr (liftM2 (:)) (return [])
07:03:02 <Peaker> (The latter definition)
07:03:02 <hpc> oh :(
07:03:03 <neutrino> nicoo: hm.
07:03:05 <nicoo> neutrino: And the external view-point is enough, since your transaction is deterministic
07:03:06 <neutrino> nicoo: ah!
07:03:07 <Peaker> it is just "liftM2" and "return"
07:03:07 <hpc> hmm
07:03:12 <neutrino> nicoo: that makes sense
07:03:20 <Peaker> @type foldr (liftA2 (:)) (pure [])
07:03:22 <lambdabot> Applicative f => [f a] -> f [a]
07:03:38 <hpc> submit it to the base maintainer!
07:03:51 <neutrino> so the transactionality is only about.. what.. not being interrupted by *others*, whereas you cooperate with other code you write or your friends write?
07:04:26 <neutrino> fryguybob: i see how it executes atomically.
07:04:28 <nicoo> neutrino: More like « being executed as if you nobody was accessing your shared ressources at the same time »
07:04:37 <neutrino> btw, you can't spawn threads inside an "atomically", right?
07:04:53 <hpc> STM actions interleave to the point where someone else steps on their toes, then they start over
07:05:05 <nicoo> It would be very surprising (but I'm not hugely familiar with Haskell's STM)
07:05:10 <neutrino> riiight
07:05:23 <Botje> neutrino: you can only do STM actions inside an atomically.
07:05:27 <neutrino> in this video, spj says if you want to fork inside a transaction you're doing it wrong
07:05:32 <neutrino> but he hasn't exactly said you can't
07:05:33 <nicoo> hpc: Some use partial restart, and some clever stuff to determine whether stepping on toes commute
07:05:35 <fryguybob> neutrino: Only ones that are deterministic.
07:05:50 <neutrino> Botje: right, and forking is an IO action
07:05:55 <neutrino> fryguybob: what do you mean?
07:05:57 <chexxor_home> hpc - so, it looks like I have a .cabal directory now. When I started installing this package, it first grabs all dependent libraries and builds them, right? These dependent libraries are placed in .cabal?
07:06:13 <fryguybob> @type par
07:06:14 <lambdabot> a -> b -> b
07:06:16 <hpc> chexxor_home: ~/.cabal?
07:06:18 <neutrino> fryguybob: oh, are you saying that you can only fork "deterministic threads"? because i'm not sure what that means
07:06:25 <atondwal> I'm trying to use GHC to generate llvm code and then run that. Anyone know how to do it properly?
07:06:29 <chexxor_home> hpc - riht
07:06:45 <hpc> ~/.cabal is for your cabal configuration
07:06:56 <hpc> ~/.ghc/something has your packages
07:07:06 <chexxor_home> atondwal: I believe there's a simple -fllvm flag when you do ghc make
07:07:11 <hpc> cabal is essentially a build system :P
07:07:15 <atondwal> http://pastebin.com/raw.php?i=WxJvvYHT what am I doing wrong?
07:07:23 <merijn> neutrino: You can fork and do atomically inside the forked thread, but inside atomically you can only do STM actions, so no IO (unless you count unsafePerformIO, but then all bets are off anyway)
07:07:32 <atondwal> chexxor_home: http://pastebin.com/raw.php?i=WxJvvYHT
07:07:33 <neutrino> right
07:07:34 <chexxor_home> hpc - ah! I see that .ghc dir now
07:07:40 <neutrino> merijn: makes sense. thanks.
07:07:50 <neutrino> thanks a lot Botje / merijn / fryguybob / nicoo
07:08:01 <neutrino> you guys have helped me understand something that's really been bothering me
07:08:03 <hpc> if you ever get into a lot of trouble, just blow both of those away and you are good as new
07:08:14 <hpc> assuming your trouble didn't happen from --global
07:08:22 <neutrino> chexxor_home: and never cabal install anything as root
07:08:28 <neutrino> chexxor_home: that's bad karma
07:08:34 <hpc> neutrino: never --global as root
07:08:41 <hpc> root still has a local ~/.ghc
07:08:46 <neutrino> oh, right, you also need --global to break things
07:08:52 <neutrino> heh yeah hpc
07:08:55 <chexxor_home> I always worry that packages install things all over the place
07:08:59 <neutrino> btw
07:09:12 <hpc> on this machine i actually use --global always
07:09:19 <hpc> because i prefer for things to break early and often
07:09:23 <hpc> instead of later and in subtle ways
07:09:27 <neutrino> btw hpc, you said it would be nice to have checkpoints, or to be able to say "only roll back this much"
07:09:42 <neutrino> i've just re-watched a piece of the stm video where they talk about exactly that
07:09:50 <hpc> heh
07:09:52 <chexxor_home> atondwal: sorry - I have only read a brief intro to it
07:09:54 <neutrino> and they use a do {} `orElse`
07:10:01 <hpc> neutrino: ooooooooooooh
07:10:03 <neutrino> to define "rollback levels"
07:10:11 <hpc> that makes sense
07:10:26 <neutrino> and i think in the Applicative orElse is just <|> isn't it?
07:10:38 <dremok> Hello every1! I am very confused about precedence and associativity when using functions and operators, and functions as arguments. Any explanation would be very helpful. My question is: Why is it that (:) (.) is a function that takes one argument of the same type as (.), even though (.) has higher precedence?
07:10:41 <fryguybob> neutrino: yes
07:10:45 <neutrino> right
07:10:48 <typoclass> i have one thread that keeps updating a status value (suppose "42% have been processed successfully"). this is write-only. i have another thread which every 10 seconds should print out the current status. this is read-only. i'm a bit unclear if i should use IORef or TVar. i think MVar is the wrong choice. opinions? links?
07:10:59 <hpc> :t (:) (.)
07:11:01 <lambdabot> Functor f => [(a -> b) -> f a -> f b] -> [(a -> b) -> f a -> f b]
07:11:18 <dremok> hpc: yes, but why?
07:11:19 <hpc> dremok: you have applied (.) to (:)
07:11:24 <hpc> or in lisp-speak
07:11:31 <chexxor_home> so you say that cabal is only allowed to touch the .cabal and .ghc directories?
07:11:32 <catsbydlo> dremok: precedence is only relevant for infix operators
07:11:34 <hpc> (cons compose OTHER ARGUMENT HERE)
07:11:45 <catsbydlo> dremok: (.) is not using infix syntax
07:11:52 <dremok> catsbydlo: so, when dealing with functions only it is always "left-to-right"?
07:11:56 <neutrino> typoclass: i have encountered exactly this same problem.
07:11:57 <hpc> (operator) in parens is how you turn an infix symbol into a regularly parsed identifier
07:11:59 <sipa> (.) is not even an operator, it's just a function
07:12:13 <catsbydlo> dremok: function application is left associative, meaning a b c is parsed as ((a b) c)
07:12:23 <typoclass> neutrino: what have people recommended? did you find a satisfactory solution?
07:12:30 <hpc> so for instance
07:12:36 <hpc> a list of functions
07:12:38 <neutrino> typoclass: the consensus was to use a TMVar. you write to the TMVar every time the percentage becomes updated. the other thread which reads it off will block until the TMVar is updated, and when it is, it will empty it and block until it's filled again.
07:12:56 <hpc> > + : * : [] -- doesn't parse
07:12:58 <lambdabot>   <hint>:1:1: parse error on input `+'
07:13:03 <fryguybob> neutrino: Note that  retry  and  orElse  go together.  Failed atomicity and retry are different things (I'm not saying you are confusing these, they are confusing things).
07:13:12 <hpc> > (+) : (*) : [] -- does parse (but ghci can't show functions)
07:13:13 <neutrino> typoclass: finally, you can just threadDelay right after you've read the TMVar successfully in order to make it update every 10 seconds.
07:13:14 <lambdabot>   No instance for (GHC.Show.Show (a0 -> a0 -> a0))
07:13:14 <lambdabot>    arising from a use of `...
07:13:21 <hpc> :t (+) : (*) : [] -- does parse (but ghci can't show functions)
07:13:22 <chexxor_home> atondwal: refer to http://www.haskell.org/ghc/docs/latest/html/users_guide/code-generators.html#llvm-code-gen
07:13:23 <lambdabot> Num a => [a -> a -> a]
07:13:35 <catsbydlo> > length ((+) : (*) : [])
07:13:37 <lambdabot>   2
07:13:41 <hpc> @let plus = (+)
07:13:44 <lambdabot>  Defined.
07:13:45 <hpc> @let times = (*)
07:13:48 <lambdabot>  Defined.
07:13:52 <hpc> :t [plus, times]
07:13:52 <neutrino> typoclass: i haven't coded this yet, but it looks like the absolute best way you can do it, i've looked at a lot of different ways of doing it (ioref, mvar, chan, tchan, interleaving, event loop)
07:13:53 <lambdabot> Num a => [a -> a -> a]
07:14:02 <catsbydlo> > double plus good
07:14:04 <lambdabot>   Not in scope: `good'
07:14:25 <hpc> "plus" and "(+)" are parsed in the same way, relative to the code around them
07:14:28 <dremok> catsbydlo++
07:14:38 <hpc> @undefine
07:14:40 <atondwal> chexxor_home: seen that, doesn't help at all...
07:14:52 <hpc> @let want = False
07:14:54 <lambdabot>  Defined.
07:14:55 <hpc> > do not want
07:14:57 <lambdabot>   True
07:15:01 <chexxor_home> atondwal: are you talking about producing llvm bytecode?
07:15:10 <neutrino> fryguybob: what is "failed atomicity"? is that when the memory under your transaction gets changed under your feet?
07:15:15 <hpc> neutrino: yes
07:15:17 <neutrino> ahh
07:15:20 <neutrino> got it
07:15:28 <dremok> catsbydlo: so, when I have a function and an operator, like in ((.) :), why does : have precedence over the (.)?
07:15:39 <typoclass> neutrino: hm ok ... maybe i can shoehorn my plan into that :-/ need to think about it. but wouldn't the TMVar solution result in a status display every 10 seconds *or more*, instead of every 10 seconds? suppose it takes 1 min to go from 42 to 43%, and the writer thread writes only every full percent
07:15:46 <fryguybob> neutrino: Right, so to get to the other side of an  orElse  you have to successfullly commit to a  retry.
07:15:50 <catsbydlo> dremok: it's not precedence
07:15:52 <hpc> dremok: when you put parens around (.), it is no longer an operator
07:15:56 <hpc> it has no precedence
07:15:57 <atondwal> chexxor_home: yeah; the page you linked to just talks about using it as an intermediate
07:16:10 <neutrino> typoclass: yes, it would. but you can use async to do that too.
07:16:32 <neutrino> typoclass: you can use async to time out the tmvar read and just use the old version.
07:16:40 <hpc> dremok: the parser sees it exactly the same way it would see (1 :) or (compose :)
07:16:47 <atondwal> chexxor_home: well, not even, it just talks about installing llvm
07:16:53 <typoclass> neutrino: hm interesting. i'll think about it. thanks a lot
07:16:57 <neutrino> yw
07:17:08 <dremok> catsbydlo: but why is this a function that expects the argument to be a list of the same type as (.)?
07:17:09 <neutrino> i'm not sure how exactly to do the timings, it sounds like just some basic arithmetic though
07:17:20 <hpc> :t (:)
07:17:22 <lambdabot> a -> [a] -> [a]
07:17:28 <dremok> What I mean is, it expects and argument to the : operator, and not to the (.) function
07:17:31 <neutrino> ok, so the read-set of a transaction gets stomped on and then my "atomically" has to restart from the top?
07:17:34 <hpc> dremok: (:) takes a thing of type 'a', and a list of things of type 'a'
07:17:39 <hpc> you have passed it (.)
07:17:45 <dremok> hpc: yes, I know this
07:17:46 <hpc> which has type 'UGLY'
07:17:50 <neutrino> or will orElse create a read-subset so that it can only roll back that much?
07:17:57 <hpc> so it wants a second parameter that is a list of type 'UGLY'
07:18:27 <dremok> hpc: but the (.) is left of the : operator, why isn't the : seen as an argument to the (.) function?
07:18:44 <chexxor_home> atondwal: what are you wanting to do?
07:18:53 <neutrino> dremok: if it's left it should be seen the way you say. but it's right of it if i saw it correctly
07:19:14 <dremok> neutrino: ((.) :)
07:19:27 <dremok> expects an argument to the : and not to the (.)
07:19:35 <Peaker> hlint has hints about >>= return .    and about x <- return $ ..   but not about the same with return replaced with pure
07:19:38 <hpc> dremok: you wrote a section of (:)
07:19:43 <neutrino> dremok: in your first message you mentioned (:) (.). i guess ((.) :) is a slightly confusing way of doing this
07:19:50 <neutrino> dremok: here, you are making a section
07:19:54 <neutrino> exactly as hpc says
07:19:55 <`ramses> dremok: (.) (:) would be what you describe
07:20:00 <hpc> let's get away from (:) and (.) so we can do some easier examples
07:20:11 <hpc> (True &&) is a section of (&&)
07:20:17 <hpc> (&&) is a function
07:20:22 <neutrino> (+2) -- this is a section of the + operator, where the right argument is 2, and the left argument is unbound.
07:20:22 <hpc> && all alone is an infix operator
07:20:28 <coleman-> how would I wrap C function that accepts a string or NULL?  the only thing coming to mind is (Maybe String), but that would make common use of the function more clumsy
07:20:31 <dremok> exactly! my point is, what are the differences? do operators always "eat up" arguments before functions if you combine operator and functions?
07:20:37 <neutrino> (2+) -- this is a section of the + operator with the right argument unbound
07:20:40 <neutrino> dremok: ^
07:20:44 <hpc> True (&&) is using True as a function
07:20:56 <atondwal> chexxor_home: I want to generate llvm bitcode that I can run with lli
07:21:17 <catsbydlo> dremok: syntactically there are operators and values
07:21:20 <catsbydlo> no functions
07:21:29 <dremok> catsbydlo: go on...
07:21:32 <hpc> dremok: so i assume you want to apply (:) to the left of a function composition
07:21:38 <hpc> which would be (.) (:)
07:21:44 <hpc> or ((:) .)
07:21:53 <catsbydlo> dremok: e.g. x + y would be an expression consisting of VALUE OPERATOR VALUE
07:21:54 <chexxor_home> atondwal: roger that - good luck
07:22:24 <catsbydlo> catsbydlo: there's a syntactic rule that says ( OPERATOR ) is a VALUE
07:22:34 <atondwal> chexxor_home: should be straighforward... I have no idea why it doesn't just _work_!
07:22:38 <dremok> hpc: I don't want to do anything specific, just want to understand what arguments are expected when combining functions and operators
07:22:42 <catsbydlo> wtf
07:22:46 <catsbydlo> why am I talking to myself?
07:22:58 <dremok> catsbydlo: haha
07:23:10 <neutrino> dremok: right, lambdabot can be very helpful
07:23:12 <catsbydlo> dremok: ( OPERATOR VALUE ) is also a VALUE, as is ( VALUE OPERATOR )
07:23:35 <catsbydlo> e.g. (+ 1) or ("hello" ++) are all syntactic values
07:23:37 <neutrino> dremok: you can /query lambdabot and you can then say @type whatever_code_here
07:23:49 <neutrino> @type fromList
07:23:51 <lambdabot>     Not in scope: `fromList'
07:23:51 <lambdabot>     Perhaps you meant one of these:
07:23:51 <lambdabot>       `IM.fromList' (imported from Data.IntMap),
07:23:58 <neutrino> haha that backfired
07:24:02 <neutrino> @type (:)
07:24:04 <lambdabot> a -> [a] -> [a]
07:24:06 <neutrino> here we go
07:24:40 <catsbydlo> dremok: as for semantics: (VALUE OPERATOR) is equivalent to ((OPERATOR) VALUE), i.e. it applies the operator to the value
07:24:44 <hpc> dremok: honestly, you picked one hell of a confusing example to get hung up on for learning how infox operators work
07:25:12 <neutrino> dremok: oh yeah. most haskell is easier than that to learn :)
07:25:19 <dremok> catsbydlo: aha, I think I understand now. so, OPERATORS are always greater than functions in some way. a function (like length or (.)) are evaluated to VALUE when combined with an OPERATOR ?
07:25:25 <neutrino> dremok: i suggest, forget it and use something simpler
07:25:29 <portnov> Control.Monad.sequence seems not tail-recursive
07:25:30 <neutrino> @type (+2)
07:25:32 <lambdabot> Num a => a -> a
07:25:35 <dremok> hpc: yes, but the questions on my upcoming Haskell exam are VERY confusing :)
07:25:38 <neutrino> @type (+)
07:25:38 <portnov> and produces stack overflow on big lists
07:25:40 <lambdabot> Num a => a -> a -> a
07:25:44 <portnov> too bad.
07:25:45 <neutrino> @type (2+)
07:25:46 <lambdabot> Num a => a -> a
07:25:51 <catsbydlo> dremok: I'd say yes but I don't understand what you mean by "greater"
07:25:59 <neutrino> dremok: do you have a list of questions?
07:26:15 <neutrino> it would be fun to see what such an exam could hold
07:26:16 <dremok> I meant "greater" (in a very flluffy way) cause I cant find the correct terms
07:26:21 <hpc> dremok: that intuition might work; one key thing to remember is that this is all at the level of parsing a string of haskell source
07:26:45 <hpc> so "evaluated to VALUE" would be best learned as "parsed to a VALUE token"
07:26:57 <neutrino> i think dremok is talking about precedence
07:27:20 <dremok> hpc: thanks, I think that will help
07:27:23 <catsbydlo> dremok: going back to ((:) .), this is parsed as a VALUE of the form (VALUE1 OPERATOR1) with OPERATOR1 = . and VALUE1 = (OPERATOR2) with OPERATOR2 = :
07:27:25 <neutrino> dremok: function application takes the highest precedence. iirc operator application is the same as function application.
07:27:30 <catsbydlo> huh
07:27:40 <neutrino> dremok: bear in mind that functions and values are the same thing in haskell.
07:27:40 <catsbydlo> I think I'm trying to describe a parser/grammar in informal english
07:29:09 <catsbydlo> VALUE -> LSECTION -> '(' VALUE OPERATOR ')' -> '(' '(' OPERATOR ')' OPERATOR ')'
07:29:25 <catsbydlo> in supporting roles: OPERATOR[1] = : and OPERATOR[2] = .
07:29:35 <fryguybob> neutrino: My understanding is that it restarts from the beginning (there are some STM systems that do partial roll backs) but it is smart about when to restart in some cases.
07:29:54 <neutrino> fryguybob: aha
07:31:05 <dremok> neutrino: http://fileadmin.cs.lth.se/cs/Education/EDAN40/exams/Exam061016.pdf
07:31:34 <dremok> Give the types for the following operator expression:  ([]>>=)(\_->[(>=)])
07:31:44 <hpc> jesus what
07:31:51 <neutrino> thanks
07:32:08 <neutrino> that's just going to be [type of bind]
07:32:28 <neutrino> :t >>=
07:32:29 <lambdabot> parse error on input `>>='
07:32:34 <neutrino> :t (>>=)
07:32:35 <lambdabot> Monad m => m a -> (a -> m b) -> m b
07:32:46 <`nand`> ([]>>=)(\_->[(>=)]) is [] >> [(>=)]
07:32:49 <catsbydlo> ok, I'mma do this top to bottom
07:32:55 <catsbydlo> first step: tokenizing the input
07:33:15 <`nand`> so that depends on what the type of (>=) is
07:33:16 <catsbydlo> that gives us ( [] >>= ) ( \ _ -> [ ( >= ) ] )
07:33:30 <neutrino> aaaahhh
07:33:37 <neutrino> i misread, i saw bind, but it's just >=
07:33:41 <`nand`> did you mean (>>=)? If so, the type would be Monad m => [m a -> (a -> m b) -> m b]
07:33:44 <`nand`> :t (>=)
07:33:45 <lambdabot> Ord a => a -> a -> Bool
07:33:46 <neutrino> the type of >= is much easier
07:33:47 <`nand`> ..oh
07:33:53 <`nand`> I forgot that's an actual operator
07:33:55 <`nand`> haha
07:33:55 <catsbydlo> we can already see that the overall shape of the line is (...) (...)
07:33:58 <neutrino> heh
07:34:04 <`nand`> yes; then it's Ord a => [a -> a -> Bool]
07:34:20 <catsbydlo> i.e. it's a function application
07:34:52 <catsbydlo> the first paren group only has two elements, [] (a value) and >>= (an operator)
07:35:19 <catsbydlo> that checks out. it's an operator section having the form '(' VALUE OPERATOR ')'
07:35:27 <atondwal> so using the llvm backend, does ghc translate the hs main into an llvm main or create an llvm library and then link?
07:35:36 <catsbydlo> the second paren group starts with a \ so it must be a lambda expression
07:35:58 <catsbydlo> the stuff between \ and -> (which is just _ in this case) is the function parameter
07:36:13 <atondwal> (i.e. should the file I get with -keep-llvm-files run under lli. doesn't seem to be the case...)
07:36:24 <catsbydlo> and the function body is [ ( >= ) ], which is a list of one element, which is the valueified operator >=
07:37:05 <catsbydlo> so much for syntax, but how does it semant?
07:37:31 <catsbydlo> ([] >>=) is equivalent to ((>>=) [])
07:37:37 <`nand`> there's no such thing as a valueified operator; operators are already values
07:37:43 <catsbydlo> `nand`: no, they aren't
07:37:43 <`nand`> I don't know why you'd trying to make this sound more complicated than it really is
07:38:54 <catsbydlo> ([] >>=) (\_ -> [(>=)]) is (>>=) [] (\_ -> [(>=)]), i.e. (informally speaking) it applies the operator >>= to two arguments, an (empty) list and a lambda
07:39:17 <catsbydlo> (it actually applies the value of the operator to the list, then applies the result of that to the lambda)
07:39:36 <chexxor_home> atondwal: interesting - there's a -keep-llvm-files ghc flag?
07:40:16 <catsbydlo> the type of (>>=) is (Monad m) => m a -> ((a -> m b) -> m b)
07:40:36 <catsbydlo> the type of [] is [] c
07:40:46 <chexxor_home> Need a quick opinion - rumors say that GHC 7.4.2 supports GHCi on  ARM. Will GHC 7.6.1 also support this?
07:40:48 <catsbydlo> we unify m a ~ [] c and get m = [], a = c
07:41:15 <catsbydlo> thus the type of (>>=) [] is (a -> [] b) -> [] b
07:41:56 <catsbydlo> ok, now the type of the lambda
07:42:11 <catsbydlo> the type of (>=) is (Ord a) => a -> (a -> Bool)
07:42:32 <atondwal> chexxor_home: I was using it in the pastebin example
07:42:33 <catsbydlo> the type of [(>=)] is (Ord a) => [] (a -> (a -> Bool))
07:43:09 <catsbydlo> the type of \_ -> [(>=)] is (Ord a) => b -> [] (a -> (a -> Bool))
07:43:16 <catsbydlo> because we're simply adding an unused argument
07:43:49 <catsbydlo> also I'm going to rename all type variables to get (Ord d) => e -> [] (d -> (d -> Bool))
07:44:32 <hpaste> DMcGill pasted “Word Tries with lens” at http://hpaste.org/79291
07:44:38 <catsbydlo> since this is the type of the argument to ((>>=) []), it must unify with (a -> [] b)
07:44:47 <DMcGill> It's impressive how much lens helped there
07:44:58 <DMcGill> any code critique or suggestions for extensions?
07:45:10 <catsbydlo> (a -> [] b) ~ (Ord d) => (e -> [] (d -> (d -> Bool)))
07:45:14 <edwardk> you can clean it up further if you are careful with the use of 'non'
07:45:38 <catsbydlo> thus a = e, [] = [], and b = (d -> (d -> Bool))
07:45:49 <edwardk> > M.fromList [] & at "hello" . non M.empty . at "goodbye" . non 0 +~ 10
07:45:51 <lambdabot>   fromList [("hello",fromList [("goodbye",10)])]
07:45:56 <`nand`> :t non
07:45:57 <lambdabot> (Eq a, Functor f, Isomorphic k) => a -> k (a -> f a) (Maybe a -> f (Maybe a))
07:46:14 <elliott> non is a non sequitur. :(
07:46:16 <edwardk> basically non says how to treat missing entries and how to remove them
07:46:19 <edwardk> :t anon
07:46:20 <lambdabot> (Functor f, Isomorphic k) => a -> (a -> Bool) -> k (a -> f a) (Maybe a -> f (Maybe a))
07:46:22 <catsbydlo> the type of the result of the whole thing was [] b and now we know what b is
07:46:31 <elliott> anon sequitur
07:46:46 <edwardk> > M.fromList [] & at "hello" . anon M.empty M.null . at "goodbye" . non 0 +~ 10
07:46:48 <lambdabot>   fromList [("hello",fromList [("goodbye",10)])]
07:46:55 <catsbydlo> so the final type of everything is (Ord d) => [] (d -> (d -> Bool))
07:46:58 <edwardk> anon avoids spurious Eq constraints
07:47:09 <`nand`> interesting
07:47:16 <`nand`> anything I have to watch out for when using that, laws-wise?
07:47:48 <edwardk> technically you should make sure the container doesn't hold anything that passes the predicate of anon or the value of the argument in non a priori.
07:48:06 <edwardk> e.g. if you have a Map of 'hit counts' and it starts with no entries for anything with 0 hits.
07:48:18 <edwardk> > M.fromList [] & at "hello" . non 0 +~ 1
07:48:20 <lambdabot>   fromList [("hello",1)]
07:48:36 <dremok> catsbydlo: thanks a lot! that helped me a lot, although I don't really think I could repeat that analysis
07:48:36 <edwardk> > M.fromList [("hello",1)] & at "hello" . non 0 -~ 1
07:48:38 <lambdabot>   fromList []
07:48:51 <`nand`> ah
07:48:51 <edwardk> it'll delete entries that fit the 'non' value or anon predicate
07:49:01 <edwardk> and you should make the anon value match the predicate
07:49:09 <edwardk> e.g. anon M.empty M.null
07:49:09 <ocharles> aw, no tekmo
07:49:29 <edwardk> since its using it like non a = anon a (a==)
07:49:49 <`nand`> I guess that rules out non NaN
07:50:00 <edwardk> not _really_
07:50:01 <preyalone> Any progress bringing Haskell to mobile?
07:50:02 <edwardk> hrmm
07:50:06 <`nand`> anon NaN isNaN
07:50:13 <edwardk> yeah
07:50:23 <edwardk> that should work in practice
07:50:25 <`nand`> not that you should be using NaN
07:50:35 <`nand`> it's just the first example I could think of where an Eq instance doesn't guarantee x==x
07:50:37 <startling> `NaNd`
07:50:38 <adnam> preyalone: I want to try Fay + PhoneGap
07:50:52 <preyalone> Fay is budding
07:51:00 <startling> adnam: oh, that's interesting.
07:51:06 <adnam> preyalone: budding? O_o
07:51:25 <startling> preyalone: what do you have against asexual reproduction?
07:51:28 <edwardk> anon naN isNaN works fine -- the predicate passes
07:51:53 <preyalone> Fay uses JS, so not sure how we'd implement parmap. But it's a start.
07:53:30 <adnam> webworkers! ? :/
07:56:48 <mapf> a short way to show an int as bit string?
07:57:20 <Botje> showIntAtBase?
07:57:33 <`nand`> > (123 :: Int) ^. partsOf bits
07:57:35 <lambdabot>   [True,True,False,True,True,True,True,False,False,False,False,False,False,Fa...
07:57:44 <`nand`> oh, wait, I guess that's not really what you wanted
07:57:59 <Botje> > showIntAtBase 2 ("01"!!) 123
07:58:01 <lambdabot>   No instance for (GHC.Show.Show GHC.Show.ShowS)
07:58:01 <lambdabot>    arising from a use of `M1...
07:58:06 <Botje> > showIntAtBase 2 ("01"!!) 123 ""
07:58:08 <lambdabot>   "1111011"
07:58:12 <Botje> will that work?
07:58:25 <mapf> nice
07:58:40 <nomeata> Fay is cool, now I can demonstrate my Haskell code easily in the browser: http://darcs.nomeata.de/circle-packing/fay/fay-demo.html
07:59:19 <nomeata> > showAtBase 1 (const *) 123 ""
07:59:19 <mapf> thanks
07:59:20 <lambdabot>   Not in scope: `showAtBase'
07:59:21 <lambdabot>  Perhaps you meant `showIntAtBase' (imported fro...
07:59:25 <nomeata> > showIntAtBase 1 (const *) 123 ""
07:59:27 <lambdabot>   Couldn't match expected type `GHC.Types.Char'
07:59:27 <lambdabot>              with actual type...
07:59:31 <mapf> :i showIntAtBase
07:59:34 <nomeata> > showIntAtBase 1 (const "*") 123 ""
07:59:36 <lambdabot>   Couldn't match expected type `GHC.Types.Char'
07:59:36 <lambdabot>              with actual type...
07:59:42 <Botje> needs a char.
07:59:45 <Botje> so const '*'
07:59:49 <nomeata> > showIntAtBase 1 (const '*') 123 ""
07:59:51 <lambdabot>   "*Exception: Numeric.showIntAtBase: applied to unsupported base 1
07:59:55 <nomeata> boring
07:59:55 <Botje> awww
08:00:06 <Botje> nomeata: of course you can just do replace 123 '*' :P
08:00:09 <Botje> *replicate
08:01:01 <nomeata> Botje: :-)
08:01:25 <`nand`> nomeata: ah, for a second there I thought you did something awesome like writing a Diagrams backend for Fay
08:01:49 <`nand`> hey, you should write a diagrams backend for fay
08:02:04 <nomeata> `nand`: no, although I don’t think the backend is the problem. Supporting the code of fay is the problem... all those language features
08:02:24 <nomeata> (I wonder why Fay is not based on  GHC core. would make many features much easier)
08:04:50 <`nand`> oh, Fay doesn't even have type classes?
08:05:08 <`nand`> wait, that doesn't make sense; how would your example work then without do/Monad
08:05:29 <`nand`> and yeah, it'd need associated type families and stuff
08:05:37 <nomeata> monomorphic do, fixed for the Fay type?
08:05:44 <`nand`> yuck
08:05:52 <`nand`> so it's ‘like Haskell, but without Haskell’
08:05:52 <nomeata> just guessing
08:05:57 <`nand`> oh
08:05:59 <`nand`> perhaps
08:07:34 <coleman-> how would one wrap C function that accepts a string and in some rare cases a null pointer?   the only thing coming to mind is (Maybe String), but that would make common use of the function more clumsy
08:07:59 <adnam> we are waiting on haskell-suite for typeclasses
08:08:46 <catsbydlo> coleman-: provide a convenience wrapper foo' = foo . Just
08:09:04 <coleman-> ok good idea
08:09:49 <catsbydlo> dremok: to be honest, I normally do this stuff intuitively. I have to sort of reverse engineer what I know to get the formal derivation
08:10:05 <coleman-> is the convention is to make the wrapper with ' at the end of the name? rather than vice versa
08:10:25 <catsbydlo> coleman-: what does the function do?
08:10:58 <Nereid> coleman-: the wrapper should have the friendlier name, as it is the one that a user of your function will see.
08:11:16 <coleman-> catsbydlo it's a FindWindow winapi function, accepting window class and window title, or null pointer for either which indicates "match anything"
08:11:37 <`nand`> you could provide two separate functions
08:11:51 <`nand`> findWindow :: Foo -> IO Window
08:11:54 <`nand`> findAnyWindow :: IO Window
08:11:56 <otters> wouldn't Maybe be the way to go for that?
08:12:07 <Nereid> `nand`: but there are two possibly-null parameters
08:12:11 <Nereid> do you want 4 functions? I don't.
08:12:17 <coleman-> yes there are 4 combinations
08:12:19 <`nand`> yeah, gets ugly for more than one parameter
08:12:46 <`nand`> but you could still provide specialized functions for common cases; along with a single catch-all with Maybes
08:12:49 <otters> data Search = NamedWindow String | AnyWindow
08:12:55 <otters> findWindow :: Search -> IO Window
08:13:04 <Nereid> Search ~ Maybe String
08:13:05 <`nand`> not much prettier than Maybe
08:13:07 <catsbydlo> otters: that's even more annoying than Maybe
08:13:15 <otters> is it
08:13:18 <catsbydlo> yes
08:13:23 <Nereid> it's strictly more annoying than Maybe, because it has all the problems of Maybe
08:13:26 <catsbydlo> because now I have to type NamedWindow instead of just Just
08:13:28 <Nereid> and it's a new type
08:16:27 <Nereid> oh I see what coleman- was asking about.
08:16:38 <Nereid> never mind my comment then.
08:16:55 <coleman-> how about findWindowByClass, findWindowByTitle findWindowByClass and findWindow accepting Maybes for completeness?  the common use is to pass NULL for either class or text to search by one or the other
08:17:05 <coleman-> err
08:17:16 <Nereid> sure
08:17:17 <coleman-> how about findWindowByClass, findWindowByTitle and findWindow accepting Maybes for completeness?  the common use is to pass NULL for either class or text to search by one or the other
08:17:27 <Nereid> I'd use it.
08:17:46 <Nereid> have easy functions for the common cases
08:22:34 <mason_> hello. is there a way to keep the state of the program after recompiling a function?
08:22:56 <hpc> recompiling a function?
08:23:33 <mason_> or I guess recompiling the source
08:23:56 <`nand`> you mean like hot reloading?
08:24:02 <mason_> basically does haskell support incremental compiling?
08:24:05 <mason_> yes
08:24:15 <weissi> Hi, is there a way to generate haddock HTML documentation and have the references to external libraries point to Hackage?
08:24:24 <`nand`> you could do something like what xmonad does; there's a library for it too, but I forgot the name
08:24:35 <`nand`> you could also use something like acid-state I guess to keep state in between restarts
08:24:51 <`nand`> but there's no magic built-in support for it like, say, erlang has
08:25:20 <arbn> `nand`: XMonad writes the state to disk, quits, and then reads it back on startup, correct?
08:25:39 <`nand`> it passes state via the command line when reinvoking itself
08:25:46 <catsbydlo> and it doesn't quit
08:26:13 <catsbydlo> it does execv("xmonad", "--restart", huegstate) or something like that
08:26:33 <arbn> Oh. OK.
08:27:08 <jmcarthur> mason_: you can also load haskell code dynamically using hint
08:27:28 <deech> Hi all, outside of Gtk2Hs are there any guidelines on the best way to make a Haskell interface to an OO library?
08:27:40 <deech> Oh and wxhaskell.
08:28:20 <mason_> the idea is to use this during development. in this case I am parsing a lot of data and building Map, which  takes considerable time. and I have to do it again every time I make some small change to a function that manipulates resulting Map
08:28:45 <hpc> deech: find a way to factor it out of OO
08:29:01 <`nand`> you could certainly use acid-state to serialize your Map to disk in between program runs
08:29:09 <hpc> gtk works fairly well because it gets a lot of attention, but what if the class heirarchy broke in some way
08:29:26 <hpc> i know i would never ever be able to find what went wrong
08:29:45 <deech> hpc: What do you mean if the class hierarchy broke?
08:29:56 <deech> hpc: Like if there was mistakes in the bindings?
08:30:14 <hpc> like if one class was a subclass of something it shouldn't be, or whatever
08:30:23 <osfameron> why would that happen?
08:30:50 <deech> hpc: Isn't that an issue with the library itself. Is that something that the Haskell interface should be fixing?
08:31:30 <hpc> just saying, with the sheer amount of type hackery going on in gtk, it's a miracle things work as well as they do
08:31:56 <deech> hpc: Yeah, I tried to understand gtk2hs and didn't get very far.
08:32:08 <deech> hpc: That GObject stuff is crazy.
08:32:13 <mapf> suppose I have data A = A Int Int; and i want derived serializion/deserializion from a single binary layout described by combinator. And binary layout, for exsample, is 15 bits from first Int and 17 bits from second one. So serialize :: A -> Word16; deserialize :: Word16 -> A;   Is Data.Binary my choice?  (i'm not asking how to do this, i'm asking that to choose to do this)
08:32:28 <hpc> deech: to be fair, it's a miracle GObject works as well as it does either ;)
08:33:12 <deech> hpc: It's certainly something I've considered - writing an OO-ish C skin on a C++ library.
08:33:27 <mapf> also i have no streams of data
08:33:32 <mapf> or something
08:34:18 <deech> hpc: CMIIW but this seems like outside of the GUI bindings this seems like largely unexplored territory.
08:40:43 <coleman-> I am a bit confused how to specify type of the object when using alloca?  I have to allocate memory for CInt and a pointer (to pass a pointer to pointer)
08:41:42 <jmcarthur> coleman-: if it's not inferrable you can just use a type annotation
08:41:49 <jmcarthur> coleman-: usually it should be inferrable though
08:43:34 <coleman-> function accepts void * which I declared as Ptr (), so haskell can't infer much
08:44:11 <catsbydlo> ok, so what are you actually allocating?
08:45:10 <coleman-> a char *
08:45:22 <coleman-> function should accept a pointer to it, or char **
08:46:14 <catsbydlo> alloca $ \p -> ... someFunc (p :: Ptr (Ptr CChar))
08:46:54 <coleman-> I will try. though won't haskell complain, as someFunc is declared as accepting Ptr () ?
08:47:12 <catsbydlo> alloca $ \p -> ... someFunc (castPtr (p :: Ptr (Ptr CChar)))
08:47:24 <coleman-> looks good I'll try, thanks
08:49:10 <mason_> So Ptr () is haskell equivalent of void pointer?
08:49:27 <catsbydlo> one of them
08:50:48 <hrumph> yo
08:50:57 <hrumph> i'm trying to install yesod on fedora 17
08:51:20 <hrumph> so i installed cabal-install
08:51:31 <mason_> what would other equivalents be? i might need to ue ffi soon so I am curious
08:51:48 <hrumph> the i tried to run cabal install yesod-platform
08:52:15 <hrumph> i got dependency errors. i'm really stuck. i wouldn't know in a million years what to do about this kind of error
08:52:38 <Taslem> hrumph: What were the errors?
08:52:50 <hrumph> i'm just about to paste them hold on
08:53:30 <mreh> what combination of extra-libraries and extra-lib-dirs do I need to get cabal to link in the C library I want to bind to?
08:53:55 <mreh> the extra-libraries directive takes file names right?
08:53:55 <hpaste> Hrumph pasted “Attempt to install yesod” at http://hpaste.org/79292
08:54:18 <mreh> minus the .so
08:54:35 <mreh> and extra-lib-dirs just points at the directory
08:54:43 <Nereid> hrumph: you're still on ghc 7.0.4?
08:55:15 <hrumph> yes
08:55:34 <hrumph> just checked ghc-7.0.4-46.fc17.x86_64
08:55:35 <Nereid> so oooold ;)
08:57:38 <hrumph> when i do cabal update it offers a new version of cabal-install but i don't really want to do do install cabal-install because then i'd be bypassing yum
08:57:56 <hrumph> would the upgrade of cabal-install help?
08:58:05 <Nereid> nope
08:58:16 <Nereid> try an older version of yesod
08:58:21 <Nereid> 1.1.2 maybe
08:58:27 <Nereid> since that doesn't need fsnotify
08:58:42 <hrumph> how do i install the older version?
08:58:43 <Nereid> although the proper solution would be to get on a current version of ghc :p
08:58:46 <Nereid> cabal install yesod-1.1.2
08:59:04 <hrumph> what is the current version of ghc?
08:59:30 <Nereid> latest is 7.6.1, but platform has 7.4.2 which is also fine
08:59:45 <hrumph> i'll probably upgrade to fedora 18 when it comes out anyway which will likely be more up to date
09:00:03 <Nereid> you can't install a current platform on fedora 17?
09:00:10 <hrumph> i'm suprised they there have been so few updates
09:00:39 <hrumph> Nereid: i don't know how other then compiling it myself
09:00:43 <Nereid> heh
09:01:01 <hrumph> like getting the tarball and compiling you mean?
09:01:37 <Nereid> that should work
09:01:49 <Nereid> there are build instructions for the haskell platform on the website
09:02:02 <hrumph> wehn i installed ghc fedora installed a million and 1 accompanying packages.
09:02:02 <Nereid> anyway, see if yesod-1.1.2 works
09:02:21 <hrumph> ok yesod-1.1.2 is the simpler solutino for now
09:03:20 <Nereid> :)
09:03:20 <hrumph> fedora 18 is coming with a yesod package
09:03:35 <hrumph> so this won't be an issue soon but i wanted to learn the system
09:04:57 <Nereid> fwiw, I built ghc and friends from source so I'm not relying on the distribution packages.
09:05:25 <Nereid> but I'm also not using the platform, heh.
09:06:06 <hrumph> install is so far successful
09:09:31 * hackagebot poppler 0.12.2.2 - Binding to the Poppler.  http://hackage.haskell.org/package/poppler-0.12.2.2 (IanWooKim)
09:10:27 <portnov> niice.
09:12:14 <mpu> Can I have a common 'where' when I use multiline function definition (to pattern match) ?
09:12:34 <byorgey> mpu: no
09:12:41 <mpu> booo...
09:12:57 <Crockeo> Though this is more specifically a Haskell-library question, I've been searching for a while and haven't been able to find an answer. I'm just starting with hOpenGL (and the Haskell-bindings for GLUT) and I've noticed that once I close (via the great red X on the top right of the window it doesn't seem to actually /stop/. The process is still running, and it hangs up both cmd (when I compile it then run it) and GHCi (when I run it 
09:13:03 <Crockeo> Anyone have any suggestions?
09:13:29 <byorgey> mpu: what you can do is make a single line definition with a where clause, and in the definition use a case expression
09:14:09 <Crockeo> mpu: Or better yet (depending on what you're doing) you could use guards.
09:14:18 <Crockeo> Just | all the things, bro.
09:15:13 <byorgey> guards and pattern-matching are not interchangeable.
09:15:27 <Crockeo> Nor are pattern-matching and case statements.
09:16:53 <hpaste> “`ramses” pasted “Where for multiline” at http://hpaste.org/79294
09:17:09 <plat0> Isn't pattern matching sugar for case?
09:17:12 <`ramses> mpu: ^ you can do something like that
09:17:29 <plat0> or rather, pattern matching in multiple function definitions
09:17:36 <mpu> `ramses: Thanks, I go take a look
09:17:42 <hrumph> yesod install failed after 10 minutes or so of installing :(
09:18:16 <hrumph> hjsmin-0.1.2 depends on language-javascript-0.5.4 which failed to install.
09:18:26 <hrumph> anyone know a workaroudn for that?
09:19:06 <zomg> hrumph: what was the error?
09:19:24 <hrumph> hjsmin-0.1.2 depends on language-javascript-0.5.4 which failed to install.
09:19:41 <hrumph> program happy version 1.185 required
09:19:42 <zomg> Did it give an ErrorCode or anything else besides that?
09:19:50 <hrumph> i'm missing something called happy
09:19:59 <hrumph> wait i can install it
09:20:02 <zomg> cabal install happy
09:20:09 <k0ral> hello
09:20:42 <hrumph> there was a fedora package for happy
09:21:01 <hrumph> javascript now successully installed i can go back to yesod again
09:21:21 <Mortchek> plat0, no - each pattern has a distinct where clause
09:21:26 <hrumph> hooray i can wait another ten minutes until something goes wrong again
09:21:28 <k0ral> generic question: should I better use an IORef MyStructure, or a data MyStructure = MyStructure { a :: IORef A, b :: IORef B, ... } ?
09:21:45 <k0ral> side question: is there a generic answer to that generic question ?
09:21:58 <Mortchek> plat0, actually, ignore that. That's not evidence against that
09:22:34 <zomg> k0ral: I guess it would depend on whether the purpose of MyStructure is to store data, or to store IORefs to some data
09:23:04 <zomg> if IORefs are irrelevant to the functionality of the type itself, then you probably don't want to put those inside it
09:23:35 <hrumph> spoke too soon yesod is now installed!!
09:24:14 <k0ral> zomg: the type itself is a global state, some parts of it are meant to change regularly, others less frequently
09:24:45 <zomg> Then I think putting IORefs in it could make sense, since it's supposed to be something that mutates
09:29:31 * hackagebot snowball 0.1.0 - Bindings to the Snowball library.  http://hackage.haskell.org/package/snowball-0.1.0 (DagOdenhall)
09:30:27 <hrumph> i tired to load some example yesod code now but it woudlt load. i got  Could not find module `Database.Persist.Sqlite'
09:32:19 <Nereid> install it then.
09:32:21 <Nereid> persistent-sqlite
09:35:04 <hrumph> i got persistent-sqlite 1.0.0 to install
09:36:29 <Nereid> hmm, not the latest?
09:36:58 <Nereid> depends on which version of persistent is installed, I guess.
09:37:05 <k0ral> zomg: it bothers me to put IORef inside a structure
09:37:08 <hrumph> i couldn't install the latest
09:37:17 <hrumph> i tried 1.0.1 but it wouldn't isntall
09:37:34 <k0ral> as it boils down to imposing the mutation process to the structure user
09:37:44 <Nereid> I wouldn't put IORefs in it.
09:37:56 <hrumph> 1.0.0 would install but I still get the same error when i try to load the code
09:38:16 <Nereid> surely you don't get the exactly same error.
09:38:35 <romildo> Is it possible to write the function         \rec x -> rec{field = x}   as a point free function?
09:39:09 <k0ral> Nereid: putting IORef "outside" of the structure causes another problem: each time I need to change a tiny part of the structure, I have to rewrite the whole structure
09:39:16 <Nereid> romildo: nope. not without lenses anyway :>
09:39:17 <newsham> romildo: you can auto-generate those functions with TH..  there's some package that will do it for you
09:39:19 <hrumph> Could not find module `Database.Persist.Sqlite'
09:39:24 <Nereid> k0ral: you should use lenses :>
09:40:06 <Nereid> romildo: well I don't mean you *must* use lenses to get it. but lenses are cool.
09:40:07 <k0ral> Nereid: I was considering that, yes
09:40:15 <Nereid> I mean lens is cool.
09:40:48 <newsham> romildo: I think http://hackage.haskell.org/package/derive-2.5.11 has funcs for that
09:41:29 <romildo> Nereid, looking at lenses is in my todo list.
09:42:42 <hrumph> i'm not going to be able to get yesod working  :(
09:43:44 <Nereid> hrumph: what's the error you get?
09:43:53 <newsham> here's one, romildo: http://hackage.haskell.org/packages/archive/setters/0.1/doc/html/Data-Setters.html
09:44:10 <Nereid> newsham: at that point he may as well use lens ;)
09:44:15 <hrumph>  Could not find module `Database.Persist.Sqlite'
09:44:30 <Nereid> hrumph: that's the only line?
09:44:30 <aavogt> data-accessor-template is another one
09:44:37 <newsham> oh, her's the one in derive: http://hackage.haskell.org/packages/archive/derive/2.5.11/doc/html/Data-Derive-Set.html
09:44:58 <newsham> s/her/here/
09:45:00 <Nereid> http://hackage.haskell.org/packages/archive/lens/3.7.1.2/doc/html/Control-Lens-TH.html ;)
09:45:07 <hrumph> only one. there is more information such as locations searched with two lines Dabase/Persist/Sqlite.hs and also for Sqlite.lhs
09:45:30 <newsham> nereid: teach the controversy
09:46:03 <aavogt> Nereid: do you know if the accessors defined in libraries like http://hackage.haskell.org/package/Chart are "convertible" to lens?
09:46:09 <Nereid> hrumph: if you're doing this in ghci, you did restart it, right?
09:46:17 <hrumph> yes
09:46:25 <aavogt> without as much boilerplate as re-defining those setter/getters in the first place
09:46:29 <hrumph> i'll see if it compiles with ghc too
09:47:33 <hrumph> no luck with compilation
09:47:37 <Nereid> aavogt: those are accessors from data-acessor no?
09:48:00 <aavogt> yes
09:48:18 <Nereid> which are plain lenses
09:49:42 <Nereid> it's too bad they give fromLens but not toLens
09:50:52 <Nereid> but yeah, you could define Accessor r a -> SimpleLens r a to get a lens lens from a data-accessor lens
09:50:54 <coleman-> why can't you pattern match on nullPtr ? http://hpaste.org/79296
09:51:05 <Nereid> coleman-: nullPtr is a variable name
09:51:10 <glguy> You can't pattern match on ANY variable
09:51:12 <Nereid> try a guard
09:51:26 <coleman-> ok
09:51:34 <catsbydlo> constructors only
09:51:51 <Nereid> what you write binds the argument of foo to a new variable called nullPtr
09:51:53 <neutrino> hello
09:51:56 <Nereid> shadowing any existing nullPtr
09:51:58 <neutrino> are there any commutative monads?
09:52:02 <Nereid> yes
09:52:03 <coleman-> yes it makes sense now
09:52:13 <neutrino> i mean where >> is commutative
09:52:15 <Nereid> yes
09:52:18 <catsbydlo> I don't know what commutative means but Reader
09:52:24 <neutrino> that's really cool, which ones?
09:52:28 <Nereid> Reader, say
09:52:29 <glguy> neutrino: Writer Data.Monoid.Any
09:52:34 <glguy> is another example
09:52:44 <Nereid> or Writer for a commutative monoid
09:52:51 <neutrino> what is Data.Monoid.Any?
09:52:54 * neutrino googles
09:52:56 <Nereid> it's a commutative monoid
09:53:11 <glguy> the first Monoid that comes to mind :), Any is False and (||)
09:53:53 <newsham> > getAny $ mconcat [Any 3, Any 5, Any 2]
09:53:55 <lambdabot>   No instance for (GHC.Num.Num GHC.Types.Bool)
09:53:55 <lambdabot>    arising from the literal `3...
09:54:01 <parcs> Identity?
09:54:04 <hrumph> are monoids the future or just a fad?
09:54:05 <neutrino> what is the meaning of False, glguy?
09:54:08 <neutrino> is False mempty?
09:54:12 <Nereid> yes
09:54:13 <newsham> > getAny $ mconcat [Any False, Any False, Any False]
09:54:13 <coleman-> @src nullPtr
09:54:14 <lambdabot> nullPtr = Ptr nullAddr#
09:54:14 <lambdabot>   False
09:54:18 <newsham> > getAny $ mconcat [Any False, Any True, Any False]
09:54:20 <aavogt> Nereid: that's not too bad. But there's no way for that conversion to be implicit? (so when a Layout1 is inside a larger record it's transparent that the inner bits use data-accessor and the outer bits use lens)
09:54:20 <lambdabot>   True
09:54:30 <neutrino> is there a typeclass for commutatice monads?
09:54:33 <Nereid> aavogt: nope
09:54:36 <neutrino> v
09:54:49 <Nereid> neutrino: nope
09:55:10 <neutrino> well i was thinking
09:55:12 <Nereid> just like how there's no type for positive Ints
09:55:21 <aavogt> Word
09:55:23 <Nereid> being commutative is a law
09:55:25 <neutrino> a type which is a commutative Monad and Alternative is a unity ring
09:55:27 <Nereid> not an extra structure
09:55:40 <newsham> try agda? :)
09:55:44 <simpson> > runWriter $ do { tell (Any False); tell (Any True); return 42 }
09:55:45 <lambdabot>   (42,Any {getAny = True})
09:55:54 <Nereid> a commutative monoid is a monoid that satisfies the commutative law, not a monoid with extra stuff.
09:55:55 <neutrino> so for example STM is a non-commutative unity ring
09:56:00 <Nereid> what
09:56:23 <Nereid> a commutative monoid satisfies do { a <- x; b <- y; z } = do { b <- y; a <- x; z }
09:56:40 <Nereid> er, commutative monad
09:56:47 <hrumph> oh i see something
09:56:55 <hrumph> i was doing the cabal installs as root...........
09:57:01 <Nereid> don't do that
09:57:06 <hrumph> it seems to just install things into the root home directory...
09:57:12 <hrumph> there's an eplanation
09:57:18 <hrumph> i wanted a system wide install of the libs
09:57:22 <neutrino> if i reason correctly, >> is multiplication, <|> is +, return is 0 (mempty) and return () is 1
09:57:26 <hrumph> is that a crime?
09:57:28 <X-suriV> is there a Monad tutorial out there that doesnt suck?
09:57:31 <Nereid> X-suriV: no
09:57:33 <hrumph> ok so what am i supposed to do?
09:57:34 <neutrino> but i'm not exactly sure about the unity
09:57:35 <X-suriV> :(
09:57:36 <simpson> hrumph: Use your distro's packages if you want them to be system-wide.
09:57:43 <simpson> hrumph: Otherwise, just do it per-user.
09:57:49 <hrumph> ok it doesn't matter for now since i'm just learning
09:57:53 * X-suriV is newer to haskell trying to find Monad information..but all of it is really sucky lol
09:58:03 <hrumph> i'm just going to install in my usual user account
09:58:04 <Nereid> neutrino: for any monad m, m () is a monoid.
09:58:26 <neutrino> X-suriV: the worst thing you can do when learning haskell is to set out and try to "learn monads"
09:58:29 <hrumph> why isn't system wide install the default when you run as root?
09:58:36 <Nereid> hrumph: because you shouldn't do that anyway.
09:58:42 <neutrino> hrumph: because system-wide install is generally a bad idea.
09:58:49 <neutrino> and root is a user anyways.
09:58:50 <newsham> neutrino: the normal route is to set out to try to "write monad tutorial" ;-)
09:58:57 <neutrino> so let's treat it like any other user.
09:59:04 <hrumph> i don't undersand why. i'd like to know why system-wide install is bad
09:59:11 <neutrino> Nereid: i know that
09:59:17 <simpson> hrumph: Because Haskell packages can break when other packages are updated, and as a result, it's far easier to manage packages either all-at-once (distro-style) or per-user.
09:59:19 <X-suriV> nuetrino: Really? so save monads for later or something?
09:59:23 <neutrino> Nereid: it's an interesting factoid, but unrelated to what i meant
09:59:25 <newsham> system wide install is a good idea
09:59:35 <Nereid> neutrino: eh
09:59:39 <neutrino> X-suriV: no, it's just that there isn't anything to "learn" about monads
09:59:44 <neutrino> X-suriV: it's like learning hammers
09:59:49 <neutrino> X-suriV: or learning pliers
10:00:01 <hrumph> ok i'm going to have a nap then return to this installation madness later on
10:00:08 <neutrino> hrumph: nn
10:00:46 <neutrino> X-suriV: you wouldn't sit down and go, ok, i have twenty different hammers. let me learn about hammers today
10:01:00 <neutrino> X-suriV: you'd just go and use one hammer, then another, see how they're similar, that's about it
10:01:25 <Nereid> monads are like hammers.
10:01:27 <Nereid> great monad tutorial.
10:01:30 <strebe> rather than deciding you need a degree in metallurgy before you can touch them
10:01:42 <Nereid> next thing we'll be hearing is that monads are like burritos.
10:01:47 <newsham> unsafeWrapBurrito
10:01:53 <strebe> Nereid: nom
10:01:54 <neutrino> if you stick a fork in a burrito it's like a mushy hammer
10:01:56 <Nereid> no, wrapping is safe, unwrapping isn't.
10:02:17 <neutrino> ununsafeWrapBurrito
10:02:18 <coleman-> this is pretty awesome how you can just cast pointer to whatever it needs to be.  peekCString =<< peek (castPtr bufPtr)
10:02:35 <simpson> Monads are like burritos: The general system for consuming burritos is relatively straightforward, and once you've eaten one burrito, you can eat any other burrito, but sometimes certain burritos have special flavors that you might want to know about before you eat it. Also, too many burritos and you'll get sick.
10:02:37 <catsbydlo> it's like I'm really writing C!
10:02:50 <neutrino> ok can we quit the monad analogies now
10:02:52 <neutrino> please
10:02:54 <coleman-> it's better than C, in C you'd have to be explicit in your casts
10:02:55 <Nereid> never!
10:03:02 <catsbydlo> ok, C++ then
10:03:17 <simpson> neutrino: I am obligated to say something whenever somebody asks for a burrito-monad comparison.
10:03:19 <newsham> coleman: http://codepad.org/Q8cgS6x8
10:03:21 <coleman-> C++ can't infer it either as far as I know
10:03:31 <neutrino> coleman-: yes, type inference in ghc is amazing
10:03:48 <neutrino> in fact i'm not sure if it's a ghc or haskell feature
10:03:50 <catsbydlo> coleman-: you can fake it with a proxy struct
10:03:51 <Nereid> you can put things in a burrito, and if you have a burrito that contains burritos, then you can put all the contents of the inner burritos into one big burrito.
10:03:53 <Nereid> there, monads!
10:03:59 <simpson> neutrino: It's a core feature of Haskell.
10:04:04 <catsbydlo> coleman-: template<typename T> operator T() { oh god what am I doing
10:04:05 <neutrino> ok.
10:04:30 <Nereid> neutrino: what.
10:04:34 <Nereid> type inference is a core haskell feature.
10:04:46 <neutrino> catsbydlo: i was just thinking today, compared to C++ and stuff, haskell is the easy way out
10:04:49 <neutrino> Nereid: ok
10:04:56 <Nereid> it's like the whole point of haskell.
10:05:01 <Nereid> aside from a few other whole points
10:05:09 <neutrino> heh
10:05:22 <neutrino> so does anyone else agree that STM is a non-commutative ring?
10:05:24 <catsbydlo> if you have a point that contains points
10:05:39 <Nereid> neutrino: it's a ring?
10:05:48 <neutrino> yeah
10:05:52 <Nereid> in what sense
10:05:52 <jmcarthur> in what way?
10:05:55 <catsbydlo> it's a ring, ring, ring, ring, bananaphone
10:05:58 <Nereid> :D
10:06:03 <bananagram> what
10:06:11 <bananagram> that highlighted me
10:06:12 <jmcarthur> doop doobydoodoodoop
10:06:13 <neutrino> <|> is +, retry is 0, >> is *
10:06:18 <newsham> kokodokodokodo... its the best, beats the rest, stereo modular interactiveodular
10:06:33 <catsbydlo> it's a phone with appeal
10:06:38 <neutrino> * is not commutative
10:06:39 <Nereid> neutrino: and does >> distribute over <|>?
10:06:58 <niteria> don't you need 1 in a ring?
10:07:07 <jmcarthur> niteria: return (), i assume
10:07:19 <parcs> Nereid: yes!
10:07:20 <catsbydlo> foo >> return () is not foo
10:07:21 <neutrino> no, you don't, that's unity ring
10:07:22 <byorgey> niteria: not necessarily, depends who you ask
10:07:30 <jmcarthur> it's the distributive properly i'm not convinced of
10:07:33 <Nereid> I don't care who you ask, rings have 1
10:07:33 <jmcarthur> catsbydlo: oh right
10:07:40 <Nereid> :p
10:07:41 <byorgey> haha
10:07:51 <byorgey> in any case something without a 1 is an interesting mathematical structure, no matter what you call it
10:08:16 <newsham> but one is the loneliest number
10:08:31 <Nereid> I know there are some important things-that-are-almost-rings-but-don't-have-1 like certain banach algebras and whatnot but I don't care! :(
10:08:56 <neutrino> (a >> b) <|> (c >> d) = a*b + c*d -- nothing changes.       (a + b) * (c + d) == (a <|> b) >> (c <|> d) == (a >> c) <|> (a >> d) <|> (b >> c) <|> (b >> d) == ac + ad + bc + bd
10:09:00 <masquerade> Nereid: Those aren't rings, those are rngs :)
10:09:04 <Nereid> yeah
10:09:11 <neutrino> you can see it distributes
10:09:28 <Nereid> neutrino: you can't just write the distributive law and say "it distributes"
10:09:41 <bourbaki> Moin
10:09:45 <neutrino> well i see the second equality as valid
10:09:48 <newsham> a r1ng without a one is an rng?
10:09:53 <Nereid> *why* is (a >> b) <|> c = a <|> c >> b <|> c?
10:10:01 <Nereid> I'm not convinced.
10:10:09 <jmcarthur> neutrino: there's some weirdness is what you're suggesting too, in that empty and <|> don't care about the type argument, but (>>) does
10:10:11 <byorgey> wait, which is + and which is * ?
10:10:13 <Nereid> and in fact it's just false.
10:10:17 <byorgey> you need * to distribute over +
10:10:27 <Nereid> jmcarthur: let's just say we're talking about STM ()
10:10:41 <neutrino> Nereid: it's not. you mixed up your operators.
10:10:43 <jmcarthur> Nereid: yeah, which also adds 1, which is a plus
10:10:45 <neutrino> Nereid: it's the other way around
10:10:55 <Nereid> oops
10:11:04 <bourbaki> Is there any way to define functions in classes later on or do i need to implement everything on the left side of the => beforehand?
10:11:08 <neutrino> (a <|> b) >> c == (a >> c) <|> (b >> c)
10:11:15 <Nereid> sure.
10:11:22 <Nereid> actually any MonadPlus instance should satisfy that.
10:11:23 <neutrino> the left means, do either a or b, and then do c.
10:11:34 <catsbydlo> bourbaki: there is no before or after. time does not exist
10:11:37 <neutrino> the right means, do either a and then c, or b and then c.
10:11:41 <neutrino> those two are equivalent
10:11:52 <jmcarthur> that property does look true, to me
10:11:57 <bourbaki> catsbydlo: Time is an illusion lunchtime doubley so :)?
10:11:57 <niteria> huh, there's r1ng -> rng joke on wiki
10:12:11 <neutrino> niteria: is there?
10:12:15 <byorgey> Nereid: there is actually some controversy over whether all MonadPlus instances should satisfy that, I think.  But I believe STM does.
10:12:17 <jmcarthur> neutrino: you can generalize from (>>) and return () to liftA2 mappend and pure mempty
10:12:19 <catsbydlo> I hate "on wiki"
10:12:19 <neutrino> where is it?
10:12:28 <Nereid> byorgey: what's an example of one that shouldn't?
10:12:28 <niteria> http://en.wikipedia.org/wiki/Semiring
10:12:30 <Nereid> or doesn't
10:12:32 <neutrino> jmcarthur: can you? that's interesting
10:12:47 <catsbydlo> I wish to diagonalize OEIS
10:12:53 <Nereid> catsbydlo: haha
10:13:08 <bourbaki> I have a function in class X and one in class Y and i can use the function in X to define the one in Y can i do that somehow when i "derive" a class Z from both?
10:13:15 <Nereid> catsbydlo: I don't know how far you'll get though, some of the sequences there are fairly short
10:13:36 <Nereid> bourbaki: instance (X a, Y a) => Z a where ...
10:13:37 <Nereid> ?
10:13:46 <bourbaki> In my case i want to use the inner product to define an induced norm.
10:13:52 <bourbaki> Nereid: Yep
10:14:00 <simpson> bourbaki: No, you can't go back from Z and set up methods in Y.
10:14:02 <byorgey> Nereid: oh, maybe it's the other way that doesn't work,   c >> (a <|> b) = (c >> a) <|> (c >> b)  -- not true for IO
10:14:07 <bourbaki> class (VectorSpace s v, MetricSpace v, InnerProductSpace s v, Norm s v) => NormedInnderProductMetricSpace s v where
10:14:11 <simpson> bourbaki: Can the one in Y *always* be defined based on X?
10:14:11 <byorgey> because if a fails there's no way to backtrack and undo c
10:14:13 <neutrino> ok, but there are no inverse elements in STM
10:14:18 <byorgey> on the RHS
10:14:21 <jmcarthur> amazing. i found a use for HBifoldable, assuming i chose the right name for this class definition
10:14:22 <byorgey> so you end up doing c twice
10:14:32 <bourbaki> Hm
10:14:39 <neutrino> so we get a non-commutative unity semiring
10:14:41 <simpson> bourbaki: What you can do is you can define a default in Y based on X, and then instances of Y can optionally specialize that method.
10:14:45 <Nereid> byorgey: IO has backtracking?
10:14:49 <bourbaki> So i would need to set up the classes differently for different types?
10:15:05 <Nereid> oh, I guess your point is that it doesn't.
10:15:07 <simpson> bourbaki: You just can't have Z instances go back and alter Y instances.
10:15:14 <bourbaki> Well but here that would make no sense at all.
10:15:24 <Nereid> I don't know what <|> is for IO.
10:15:27 <bourbaki> Then i would have to build the norm on a metric space.
10:15:32 <mason_> is there a function that strips leading and trailing white space?
10:15:55 <Nereid> mason_: to strip leading, dropWhile isSpace. to strip trailing, exercise: implement dropWhileFromEnd
10:15:57 <neutrino> how could we generalize <|> so that it has inverse elements, such that a <|> ~a == retry?
10:15:58 <jmcarthur> Nereid: catch exception on the left and then try the right
10:16:01 <bourbaki> So there is no masking or cancelation of functions?
10:16:02 <Nereid> neutrino: we don't.
10:16:08 <mason_> and trailing?
10:16:13 <Nereid> jmcarthur: that's the only thing that makes sense, I guess.
10:16:23 <simpson> bourbaki: Not really. If you're thinking of C++-style multiple inheritance, then no.
10:16:24 <Nereid> mason_: read the whole line
10:16:27 <neutrino> Nereid: yeah, we don't, i'm asking how it could be done
10:16:36 <jmcarthur> maybe it can't
10:16:47 <jmcarthur> i think that's what was meant by "we don't"
10:16:49 <Nereid> neutrino: some monoids have that. most of the ones we care about don't.
10:17:00 <mason_> ok. so I basically have to write stripWhiteSpace
10:17:05 <jmcarthur> there are a lot of interesting groups
10:17:12 <neutrino> how do monoids relate to Alternative?
10:17:22 <catsbydlo> mason_: strips them from what?
10:17:24 <neutrino> i'm not sure why you mention monoids Nereid
10:17:27 <jmcarthur> neutrino: alternative is just a monoid that doesn't care about the type argument
10:17:38 <mason_> could swear there was such a function already, but maybe I am confusing languages
10:17:38 <bourbaki> So how would you setup the normed space then? The norm does not need a metric i could have a new class InducedNorm or so ...
10:17:45 <Nereid> neutrino: any alternative is a monoid under <|> and empty
10:17:49 <neutrino> sorry, i never heard of "the type argument"
10:17:50 <mason_> catsbydlo: String
10:17:56 <Nereid> mason_: if you can strip from the start and strip from the end, then you compose those two functions to strip from both ends
10:18:00 <jmcarthur> neutrino: in (f a), a is the argument
10:18:10 <neutrino> ah
10:18:12 <neutrino> ok gotcha
10:18:14 <jmcarthur> neutrino: empty :: f a; (<|>) :: f a -> f a -> f a
10:18:23 <neutrino> isn't empty the same as mempty?
10:18:31 <eyebloom> Is there any special convention to writing a kind variable, it's alway uppercase chi in papers.
10:18:33 <Nereid> and Alternative is the same as MonadPlus.
10:18:39 <Nereid> eyebloom: 'k'
10:18:40 <catsbydlo> mason_: yeah, there aren't many functions that act on the ends of lists
10:18:48 <jmcarthur> neutrino: that's part of the relationship between Alternative and Monoid, yes
10:18:51 <simpson> bourbaki: I'm not sure. I'd try to rearrange my classes such that methods are guaranteed to belong to the correct classes. If an instance of X and Y also needs to be Z in order to fulfill a method in Y, maybe the method should be in Z.
10:19:06 <jmcarthur> neutrino: any Alternative can be used to define Monoid
10:19:06 <neutrino> jmcarthur: oh. is "empty" a thing of its own?
10:19:08 <neutrino> @type empty
10:19:10 <lambdabot> Alternative f => f a
10:19:11 <jmcarthur> neutrino: but not the other way around
10:19:17 <neutrino> @src empty
10:19:17 <lambdabot> Source not found. :(
10:19:21 <neutrino> :(
10:19:22 <eyebloom> Nereid: I'm not sure I understand.
10:19:24 <jmcarthur> it's a class method
10:19:25 <Nereid> neutrino: empty and <|> are the methods of Alternative.
10:19:26 <arbn> I want to write a service-oriented web application. That is, JSON requests and responses only... no HTML or anything like that. I was thinking of using Snap or Yesod, but I wanted to hear any thoughts or suggestions others may have.
10:19:31 <bourbaki> simpson: The problem is that this is the case for some types but not all.
10:19:32 <jmcarthur> neutrino: for STM, empty = retry
10:19:33 <Nereid> eyebloom: everyone writes k.
10:19:45 <niteria> > let strip = reverse . (dropWhile isSpace) . reverse . (dropWhile isSpace) in strip "  423 4 "
10:19:46 <lambdabot>   "423 4"
10:19:47 <neutrino> jmcarthur: mhm
10:19:50 <Nereid> niteria: that's bad.
10:19:57 <eyebloom> Can you have more than one kind variable in Haskell?
10:20:02 <neutrino> jmcarthur: so empty is just an "alternative that can't be taken"?
10:20:07 <Nereid> eyebloom: sure, how about k'
10:20:09 <jmcarthur> i wouldn't say that
10:20:13 <simpson> bourbaki: I don't know anything else that you can do, sorry. Maybe I'm just not good enough with Haskell to know of alternatives you could try.
10:20:13 <jmcarthur> neutrino: empty is just the identity
10:20:22 <mason_> ah there is strip for Text but not String. that must be what I was confusing it with
10:20:26 <Nereid> neutrino: empty is whatever the instance says it should be, and such that empty and <|> form a monoid
10:20:32 <neutrino> jmcarthur: sure, but what is its meaning in terms of Alternative?
10:20:40 <newsham> nereid: why is it bad?
10:20:40 <Nereid> "in terms of Alternative"?
10:20:43 <jmcarthur> neutrino: it's the identity of the monoid. that's all
10:20:46 <neutrino> ok.
10:20:49 <bourbaki> I guess i would need to derive something from all the classes directly  then.
10:20:50 <eyebloom> But it must be lowercase though then.
10:20:51 <Nereid> newsham: it can be done more efficiently, without reversing.
10:20:55 <neutrino> that's a bit too abstract for me.
10:20:57 <Nereid> although it's just a constant factor.
10:20:57 <bourbaki> Anyway thankts a bunch :)
10:21:00 <newsham> nereid: premature optimization
10:21:10 <Nereid> newsham: actually, there's a strictness difference too.
10:21:20 <neutrino> i was trying to figure out whether it can be put in terms in relation to Alternative.
10:21:27 <Nereid> newsham: if the string starts with a non-space, then it should be O(1) to get the head
10:21:30 <neutrino> for example, <|> can be said to be the monoid operator.
10:21:35 <Taneb> Is there a function [a] -> a -> a -> Ordering lurking about anywhere?
10:21:37 <newsham> nereid: premature optimization
10:21:43 <Nereid> newsham: it really isn't.
10:21:50 <parcs> > (unwords . words) "  423 4 "
10:21:52 <lambdabot>   "423 4"
10:21:52 <Nereid> yours doesn't work at all on an infinite list.
10:21:55 <jmcarthur> i'm doing a lot of abstract things today. my latest creation:   type f ~> g = forall x. f x -> g x; class HBifoldable f where hbifoldMap :: Alternative m => (a ~> m) -> (b ~> m) -> (f a b ~> m)
10:22:04 <neutrino> but it can also be said that "In Applicative, x <|> y means take one of the two alternatives, x or y, prefering x"
10:22:04 <simpson> Taneb: Looking at which comes first in the list in order to figure out what the ordering should be?
10:22:07 <newsham> > (unwords . words) "  423     4 "
10:22:09 <lambdabot>   "423 4"
10:22:12 <niteria> it can't work on infinite list
10:22:12 <neutrino> that's what i meant by "in terms of"
10:22:13 <simpson> Taneb: You'd still need an Eq constraint, I think.
10:22:15 <parcs> newsham: meh
10:22:18 <newsham> thats different than: strip " 423   4 "
10:22:33 <Taneb> simpson, yeah
10:22:36 <neutrino> jmcarthur: not sure if that makes any sense.
10:22:46 <newsham> nereid: the strip defn above is simple and easy to read and works perfectly fine for small strings
10:22:48 <jmcarthur> neutrino: "In Applicative, x <|> y means take one of the two alternatives, x or y, prefering x"  <-- not true in general
10:23:03 <jmcarthur> neutrino: you are thinking only in terms of specific instances right now, i think
10:23:07 <Taneb> ...for a start that's in Alternative
10:23:18 <neutrino> jmcarthur: i guess, i'm only familiar with STM.
10:23:28 <Nereid> get familiar with other things.
10:23:30 <neutrino> Taneb: yes, typo
10:23:34 <jmcarthur> neutrino: consider the [] instance, for example. at some level of abstraction, <|> can represent nondeterminism, but really it's just concatenation
10:23:36 <Nereid> [] has an Alternative=MonadPlus instance.
10:23:44 <niteria> you have to reach the end of the string to know that the space you see now isn't leading space
10:24:09 <neutrino> jmcarthur: hmm.. how does that have anything to do with alternatives? heh
10:24:17 <niteria> it can be more lazy though
10:24:18 <Nereid> neutrino: you think about it.
10:24:32 <neutrino> Nereid: i'm sorry, i can't understand what you're saying.
10:24:37 <jmcarthur> neutrino: what do you mean?
10:24:51 <jmcarthur> > empty <|> [1,2,3]
10:24:52 <lambdabot>   [1,2,3]
10:25:01 <neutrino> jmcarthur: how does nondeterminism, or concatenation, have anything to do with alternatives?
10:25:03 <Nereid> @let dropFromEnd n l = zipWith (const id) (drop n l) l
10:25:05 <lambdabot>  Defined.
10:25:09 <Nereid> > dropFromEnd 3 [1..10]
10:25:11 <lambdabot>   [1,2,3,4,5,6,7]
10:25:12 <Nereid> > dropFromEnd 3 [1..]
10:25:14 <lambdabot>   [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28...
10:25:15 <jmcarthur> neutrino: concatenation and empty form a monoid. that's what
10:25:27 <jmcarthur> neutrino: failure and choice for a monoid too
10:25:28 <jmcarthur> *form
10:25:35 <Nereid> I guess dropWhileFromEnd is a bit more work.
10:25:36 <Taneb> :t \alphabet -> comparing (`elemIndex` alphabet)
10:25:37 <neutrino> jmcarthur: i'm just surprised that something called "alternative" gets used in such ways distant from what the name implies
10:25:37 <lambdabot> Eq b => [b] -> b -> b -> Ordering
10:25:50 <jmcarthur> neutrino: i don't think it's so distant
10:25:52 <Nereid> neutrino: it really isn't
10:25:59 <Taneb> > (\alphabet -> comparing (`elemIndex` alphabet)) "ABDC" 'C' 'D'
10:26:01 <lambdabot>   GT
10:26:13 <Nereid> neutrino: in the nondeterminism interpretation of [], <|> is nondeterministic choice
10:26:15 <Taneb> > sortBy ((\alphabet -> comparing (`elemIndex` alphabet)) "ABDC") "ABCD"
10:26:17 <lambdabot>   "ABDC"
10:26:36 <jmcarthur> neutrino: i do think it's regrettable that we tried to use such a "friendly" name for it. it would be like calling Monoid "Appendable" (and i guess we have some form of that in "mappend" already). however, alternative isn't such a bad name
10:26:42 <neutrino> i cannot recall the nondeterminism interpretation of List. can you remind me?
10:26:43 <kennyd> let strip = join (.) $ reverse . dropWhile isSpace in strip "  asdf  "
10:26:53 <kennyd> > let strip = join (.) $ reverse . dropWhile isSpace in strip "  asdf  "
10:26:55 <lambdabot>   "asdf"
10:26:56 <jmcarthur> neutrino: you can think of the list monad as nondeterminism, just as the alternative instance for STM represent nondeterminism
10:27:00 <Nereid> neutrino: a list of X is a nondeterministic value of X
10:27:19 <neutrino> Nereid: how so?
10:27:25 <Nereid> that's how it's interpreted.
10:27:33 <neutrino> that's not an interpretation..
10:27:39 <jmcarthur> neutrino: in the list monad, the result is the list of all possible solutions given all possible inputs
10:27:52 <copumpkin> there are two common meanings of nondeterminism
10:27:53 <parcs> > concat . drop 1 . init . groupBy ((&&) `on` isSpace) . (" " ++) . (++ " ") $ "  423  4  "
10:27:55 <lambdabot>   "423  4"
10:27:59 <copumpkin> which might be a source of confusion
10:28:01 <copumpkin> they're related
10:28:02 <jmcarthur> yeah
10:28:41 <neutrino> for me, nondeterminism means "the output is sometimes this, and sometimes that, randomly"
10:28:47 <copumpkin> yeah, that's one of them
10:28:54 <Nereid> that's nondeterminism?
10:29:03 <copumpkin> then there's also the idea of nondeterminism as used in an NFA
10:29:03 <neutrino> i'm guessing list is nondeterministic in the other definition?
10:29:13 <Nereid> or as in the N in NP
10:29:17 <copumpkin> yeah
10:29:24 <copumpkin> neutrino: NP-complete!
10:29:29 <copumpkin> the N there is nondeterministic
10:29:32 <parcs> is there a better way of writing strip using composition of existing functions?
10:29:32 * hackagebot circle-packing 0.1.0.1 - Simple heuristic for packing discs of varying radii in a circle  http://hackage.haskell.org/package/circle-packing-0.1.0.1 (JoachimBreitner)
10:29:33 <neutrino> not sure what that is. could you explain?
10:29:35 <catsbydlo> neutrino: [a, b] means "the output is sometimes a, and sometimes b"
10:29:45 <Nereid> catsbydlo: let's not add more confusion.
10:29:54 <catsbydlo> let's add less confusion
10:29:56 <copumpkin> in CS theory, nondeterminism can be thought of as "one of these things, who knows what"
10:30:04 <neutrino> ok, so basically in this way a list is just a series of possible outputs, but we don't know exactly?
10:30:07 <jmcarthur> neutrino: the only thing you have to change about your definition to generalize it is to remove the "randomly" bit (along with the corresponding assumption that there is only one "run" of the program)
10:30:07 <neutrino> ok
10:30:14 <neutrino> i can see how <|> is an alternative in the list monad then
10:30:18 <neutrino> thank you
10:30:29 <neutrino> that was a very nice explanation
10:30:35 <Nereid> it's not so much that we don't know
10:30:38 <parcs> > concat . drop 1 . init . groupBy ((&&) `on` isSpace) . (" " ++) . (++ " ") $ "  423  4" ++ repeat ' '
10:30:41 <flebron> you can model nondeterminism like that, and probabilities with how many times a is repeated in the list, so [a, a, b] is 2/3rds a, 1/3rd b
10:30:44 <lambdabot>   mueval-core: Time limit exceeded
10:30:46 <copumpkin> so when someone talks about the complexity class NP, that's nondeterministic polynomial, meaning "if I knew what the answer was [of many], then I could verify it in polynomial time"
10:30:48 <Nereid> it's more like we are free to choose.
10:31:12 <flebron> copumpkin, well, i wouldn't say that's what it means, but it is equivalent :p
10:31:33 <neutrino> jmcarthur: aha
10:31:41 <neutrino> jmcarthur: gotcha
10:31:56 <copumpkin> flebron: other perspectives/explanations welcome :)
10:32:20 <flebron> NP's meaning would be more similar to "if whenever I had a choice I could go down both paths at the same time, could I solve a true case in polynomial time?"
10:32:36 <copumpkin> neutrino: have you come across DFAs and regular languages?
10:32:44 <copumpkin> like regular expressions in their purest form
10:32:45 <parcs> > take 3 $ concat . drop 1 . init . groupBy ((&&) `on` isSpace) . (" " ++) . (++ " ") $ "  423  4" ++ repeat ' '
10:32:50 <lambdabot>   mueval-core: Time limit exceeded
10:32:50 <flebron> (i.e. is there a branch in the machine's computation of polynomial length, that ends accepting?)
10:33:34 <Nereid> but that's exactly what it is.
10:33:44 <jmcarthur> those sound equivalent to me
10:33:52 <flebron> it is indeed equivalent
10:34:32 * hackagebot snowball 0.1.0.1 - Bindings to the Snowball library.  http://hackage.haskell.org/package/snowball-0.1.0.1 (DagOdenhall)
10:34:34 * hackagebot bytestring-handle 0.1.0.0 - ByteString-backed Handles  http://hackage.haskell.org/package/bytestring-handle-0.1.0.0 (GaneshSittampalam)
10:34:37 <wuttf> what is the idiomatic way to test haskell packages?
10:34:40 <jmcarthur> would it be equivalent to "i could solve this in polynomial time if i had infinite parallelism"?
10:34:43 <flebron> recognizing in polytime with a polynomial certificate is equivalent simply because i can give you a list of the (polynomiall bounded number of) choices to take, in each branch
10:35:23 <Nereid> jmcarthur: something like that.
10:35:32 <flebron> jmcarthur, if your parallelism means that your machine's state is any subset of the possible states of a non-parallel machine, yes
10:35:41 <flebron> (because that's what the states of a nondeterministic turing machine are)
10:35:55 <jmcarthur> i see
10:38:41 <donri> wuttf: cabal test-suites, test-framework, hunit, quickcheck, smallcheck
10:38:55 <wuttf> donri: ty
10:40:00 <niteria> quickcheck doesn't make any effort to prioritize corner cases, right?
10:40:51 <donri> it can do some assisted shrinking, but smallcheck or smartcheck might be better at that
10:41:34 <aavogt> if might depending on what your Arbitrary instance is
10:42:06 <wuttf> for algorithms with possible invalid return values should i use my own algebraic data type or Maybe?
10:42:29 <Nereid> if Maybe is appropriate, it's probably a good idea to use that.
10:42:44 <donri> depends. using your own can add type safety, but using Maybe gives you APIs and instances
10:42:45 <wuttf> wont that make my supposedly pure functions tainted
10:42:47 <Nereid> because there are a lot of things already around for working with Maybe values.
10:42:47 <niteria> when I participated in competitions I wrote some random test generators and they never seemed to catch my bugs
10:42:53 <Nereid> wuttf: what?
10:42:58 <wuttf> Nereid: sorry
10:43:14 <Nereid> how could Maybe taint anything?
10:43:21 <wuttf> Will try to rerphase, also, I may be entirely wrong
10:43:25 <flebron> well it is a monad, if that's what you mean
10:43:33 <flebron> but it's not "tainted" in the usual sense, there's no IO
10:43:54 <wuttf> Maybe is a monad, right? I thought a function containing a monad will never ever be pure again
10:44:04 <donri> yea that's not right
10:44:13 <Nereid> this is why monad tutorials are bad
10:44:28 <donri> monads are pure and maybe can merely be used with a monadic interface
10:44:33 <flebron> wuttf, depends on what you mean by "pure". if you mean computations have referential transparency and are deterministic, it's pure
10:44:36 <Nereid> monads aren't anything.
10:44:44 <flebron> the impurity in haskell comes from input and output
10:44:48 <cmccann> :t fromMaybe
10:44:50 <lambdabot> a -> Maybe a -> a
10:44:51 <hpc> wuttf: IO is a monad
10:44:54 <donri> it's not that a maybe value "is a monad", as such. well, yea, but
10:44:59 <flebron> monads themselves are just wrapping computations in some type, the type can allow for IO, or not
10:45:01 <hpc> you can't get stuff "out of IO" safely
10:45:03 <cmccann> given a default value, you can turn any Maybe back to the plain type
10:45:05 <Nereid> IO is an example of a monad, but it in no way is representative of monads in general.
10:45:06 <flebron> if the type allows for IO, the type "taints"
10:45:07 <Nereid> no monad is.
10:45:07 <hpc> but it being a monad is totally tangental to that point
10:45:14 <donri> it's more that it does monad, if you use it as such
10:45:18 <Nereid> (although if I was pressed to choose one, it would be State.)
10:45:47 <cmccann> Nereid, how about Cont? :D
10:45:51 <cmccann> or is that too terrible
10:45:53 <Nereid> it is.
10:45:58 <cmccann> yeah.
10:46:01 <Nereid> =)
10:46:16 <donri> isn't even IO pure, in some sense
10:46:31 <catsbydlo> all of Haskell is pure
10:46:31 <wuttf> So its possible to have a function  like   myFunc :: String -> Bool, in which I call functions which can return a Maybe type?
10:46:31 <flebron> if it is, "pure" is meaningless :p
10:46:39 <catsbydlo> wuttf: of course
10:46:49 <wuttf> catsbydlo: Neat. That was my concern,
10:46:54 <donri> flebron: nah, unsafePerformIO is an example of impure
10:46:56 <catsbydlo> wuttf: you can even call functions that return an IO type
10:47:11 <donri> although it can be used in pure ways ...
10:47:14 <cmccann> manipulating IO actions as opaque values is certainly pure
10:47:41 <flebron> right, but i don't know if i would call that "using the IO monad"
10:47:59 <flebron> id x = x can work with IO String, but i wouldn't call it IO
10:47:59 <cmccann> I would call it "an endless source of useless semantic quibbling"
10:48:01 <donri> define "use"
10:48:03 <donri> :)
10:48:07 <flebron> :)
10:48:19 <Nereid> define "define"
10:48:25 <catsbydlo> I'd call length [getLine >>= putStrLn] using the IO monad
10:48:35 <catsbydlo> but not putStrLn "hello"
10:48:44 <Nereid> heh
10:48:50 <donri> :)
10:48:52 <Nereid> but would you really call the first one that?
10:48:58 <mason_> catsbydlo: you mean you can call functions returning IO but you cant run the IO action? would there be a point in doing that in a pute action?
10:48:59 <Nereid> getLine >>= putStrLn never gets evaluated.
10:48:59 <catsbydlo> yes, it relies on >>=
10:49:05 <mason_> pute function even
10:49:18 <catsbydlo> mason_: all functions are pure. you cannot run actions
10:49:34 <wuttf> OMG I hope once I learn all of this the language creators wont change their mind and redesign the language so I have to start from 0 again
10:49:43 <catsbydlo> heh
10:49:50 <wuttf> I am not agains learning, but it feels like such a great investment
10:49:51 <catsbydlo> wuttf: fortunately that is very unlikely to happen
10:50:04 <wuttf> catsbydlo: Good to hear.
10:50:07 <mason_> catsbydlo: i mean is there any point in just getting IO in a pure function without running it
10:50:18 <cmccann> > fix ("define \"" ++)
10:50:20 <flebron> the core of the language at least is very very stable
10:50:21 <donri> haskell2013 changelog: we removed types, laziness and purity. it's still functional though!
10:50:21 <lambdabot>   "define \"define \"define \"define \"define \"define \"define \"define \"de...
10:50:31 <cmccann> mystery solved!
10:51:03 <flebron> best philosophy paper ever
10:51:12 <wuttf> is lazyness such a big deal? I don't see the big picture yet.
10:51:33 <flebron> well, you can sometimes avoid doing computations if you don't really need them
10:51:33 <hpc> > ("the big picture is " ++)
10:51:35 <lambdabot>   No instance for (GHC.Show.Show
10:51:36 <lambdabot>                     ([GHC.Types.Char] -> [GH...
10:51:36 <donri> that "fix" thing wouldn't work without it, i don't think?
10:51:38 <catsbydlo> > fix (("define " ++) . show)
10:51:41 <lambdabot>   "define \"define \\\"define \\\\\\\"define \\\\\\\\\\\\\\\"define \\\\\\\\\...
10:51:42 <hpc> > fix ("the big picture is " ++)
10:51:45 <lambdabot>   "the big picture is the big picture is the big picture is the big picture i...
10:51:49 <donri> haskell has made me unable to think "strictly" :(
10:51:58 <cmccann> > fix error
10:52:00 <lambdabot>   "*Exception: *Exception: *Exception: *Exception: *Exception: *Exception: *E...
10:52:09 <cmccann> someday, that will stop making me chuckle
10:52:10 <wuttf> donri: :D
10:52:18 <hpc> donri: the other day someone asked how to get the multiples of 3 and 5 less than 1000
10:52:32 <hpc> my first thought was to filter [0..]
10:52:35 <donri> flebron: meh, that's incidental. the real deal with laziness is that it encourages and permits highly compositional code?
10:52:44 <donri> and apparently that it makes you honest about purity ^_^
10:52:49 <flebron> idk what the real deal is :(
10:52:55 <hpc> i had no idea it could be done by generating a finite list lol
10:53:14 <donri> lol
10:54:00 <jmcarthur> i think both purity and laziness are big deals, although purity is the bigger of the two, since laziness wouldn't even be all that practical without it
10:54:07 <catsbydlo> hpc: merge (iterate (* 3) 1) (iterate (* 5) 1) :-)
10:54:07 <flebron> i'm slowly, very slowly, trying to get haskell to replace python as my go-to scripting language
10:54:15 <jmcarthur> and purity has other benefits besides making laziness reasonable
10:55:04 <wuttf> When I got into Haskell (48 hours ago) I thought I would never (rarely) use lists, rewritten a Go package to Haskell and the hardest algorithmical problem in the Go code became a 4liner in Haskell
10:55:23 <cmccann> jmcarthur, deterministic behavior is nice for testing.
10:55:31 <byorgey> wuttf: =)
10:55:37 <donri> wuttf: oh i'm sure we could golf that down to a one-liner ;)
10:55:41 <catsbydlo> 4 lines? that seems a bit long
10:55:46 <wuttf> :DDD
10:55:51 <cmccann> getting used to almost everything being trivially determinstic like that makes everything else feel horrifically unpredictable
10:55:58 <niteria> is lazines really that composable? what about thunks building up?
10:56:14 <jmcarthur> niteria: it depends on what you're trying to write
10:56:36 <cmccann> laziness is composable with itself
10:56:36 <jmcarthur> niteria: you can usually use laziness as a reliable way to break complex algorithms into several simpler ones without much or any performance cost
10:56:44 <donri> and you can make strict data types to avoid many thunks, while still doing the computations lazily
10:56:50 <jmcarthur> niteria: there are ways to use it incorrectly, though, for sure
10:56:53 <cmccann> thunks building up only happens when you have a lot of laziness being composed into a computation that absolutely has to be strict
10:57:05 <wuttf> Lazyness is great, I practice it every day.
10:57:11 <flebron> the first time i used haskell i tried to make a test suite runner. it blew my mind that it was "so hard" to do IO. it was my first year in uni, having never used functional languages
10:57:40 <flebron> "i just want to output that this test failed, and keep running the tests."
10:57:51 <donri> oh, but haskell is the world's finest imperative IO language :(
10:58:14 <wuttf> donri: ? :D
10:58:29 <donri> wuttf: well for one IO is first-class
10:58:45 <hpc> donri: that's pretty much all it needs :P
10:58:57 <hpc> :t forkIO
10:58:59 <lambdabot> Not in scope: `forkIO'
10:59:08 <cmccann> wuttf, IO and type-enforced distinction of things that have effects means you can manipulate imperative code in ways that imperative languages can't
10:59:22 <cmccann> or at least, can't do easily
10:59:32 <hpc> no other language can let you write stuff like mapM, sequence, etc
10:59:33 <donri> and ghc's got a nice RTS to go with it
10:59:33 <hpc> so easily
10:59:42 * wuttf feels dumb
10:59:43 <hpc> no other language has anything like fixIO
11:00:01 <hpc> wuttf: you'll eventually get the hang of it
11:00:13 <hpc> and then it will look very easy and you'll wonder how you did it any other way
11:01:07 <wuttf> How come there is so few Haskell projects then? Steep learning curve?
11:01:11 <wuttf> are*
11:01:18 <Nereid> it's great that it doesn't take any special language constructs to be able to define your own control structures.
11:01:19 <jmcarthur> few?
11:01:23 <jmcarthur> there are quite a few
11:01:28 <flebron> there are quite a few, but yeah, the learning curve is steeper
11:01:31 <hpc> jmcarthur: certainly fewer than other languages
11:01:43 <hpc> a small pile of programs from everything ever written is still small
11:01:48 <flebron> the quality tends to be higher because of this, however
11:01:48 <glguy> niteria: Laziness being composable is why you can write: 'and . map f'    to implement 'any f'
11:01:58 <catsbydlo> Haskell is an academic research language that escaped into the wild
11:02:08 <Nereid> @quote research.language
11:02:09 <lambdabot> Jafet says: Haskell is an abstract research language used only in academia, education, banking, stock trading, circuit design, embedded systems, cryptography, operating systems research, bioinformatic
11:02:09 <lambdabot> s, phone apps, and web services.
11:02:11 <glguy> err , I was implementing "all"
11:02:11 <flebron> Haskell Gone Wild
11:02:29 <glguy> niteria: without laziness you can't reuse those functions to implement that, you have to start over
11:02:49 <jmcarthur> http://redmonk.com/sogrady/2012/09/12/language-rankings-9-12/   #13 isn't bad at all
11:02:54 <jmcarthur> (IMO)
11:02:55 <wuttf> I mean Go is 5 minute old, has fewer coders, but has approx 30 (although borderline useless) web frameworks, in Haskell I only know yesod, snap and happstack
11:03:10 <niteria> glguy: I know, I'm just scared of thunks building up because I don't have an intuition on how it happens
11:03:13 <Nereid> why do you need 30 web frameworks?
11:03:17 <jmcarthur> wuttf: Go is not even in the top 20 in the list i just linked to
11:03:32 <Nereid> especially if they're borderline useless?
11:03:41 <jmcarthur> wuttf: this is, in particular, an interesting graphic:   http://sogrady-media.redmonk.com/sogrady/files/2012/09/language-ranking-0912.png
11:03:42 <wuttf> jmcarthur: I am talking mainly about github repos
11:04:01 <jmcarthur> wuttf: github is in there
11:04:04 <wuttf> like when i search
11:04:14 <donri> i guess go people are still figuring out how to do basic things like web frameworks :p
11:04:15 <jmcarthur> wuttf: look at the graph. the x axis is github popularity
11:04:21 <wuttf> I see now sorry, I know that page
11:04:44 <Nereid> haha VimL
11:04:52 <jmcarthur> there are, visually, three major groups. haskell is at the top of the second group, right under the "insanely popular" languages
11:04:54 <niteria> with types it's harder to write crappy code, that's why there aren't as many haskell web frameworks
11:05:15 <lispy> niteria: If you enjoy reading research papers, this one explains how to reason about laziness: http://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.35.2016
11:05:19 <glguy> niteria: don't worry, you can write perfectly crappy code with types
11:05:20 <b__> niteria that's probably only part of the story =p
11:05:32 <donri> Nereid: heh all vimscripts on vim.org are mirrored on github :p
11:05:37 <Nereid> heh
11:05:40 <b__> thing is, the Haskell community isn't so hot with web in general
11:05:43 <niteria> with php everyone has it's own framework
11:05:52 <flebron> many languages have types, but haskell's type system is more powerful than most
11:05:59 <wuttf> b__: Thats a reason indeed.
11:06:04 <Nereid> well the thing about the haskell web frameworks is you can take the bits of each you like and put them together.
11:06:06 <b__> but it is inevitable that things get better
11:06:08 <hiptobecubic> the vimL thing is just because of the vimscripts mirror i think
11:06:21 <niteria> and by types I mean also IO contained in type
11:06:29 <parcs> web development is the worst
11:06:31 <hiptobecubic> i'm surprised at haskell being so high, actually
11:06:35 <Nereid> me too
11:06:39 <flebron> without getting into things like agda, which have a more powerful typesystem, but are too close to proof systems for my taste (howard-curry isomorphism notwithstanding)
11:06:41 <Nereid> then again, we have over 1000 users in here
11:06:45 <hiptobecubic> I expected ocaml to be higher
11:06:54 <wuttf> Whatever, I think Haskell seduced me. I am tired of downcasting from interface{}s in Go (due to lack of generics and a sophisticated type system).
11:06:58 <hiptobecubic> that's true, this channel is as full as #python
11:07:06 <jmcarthur> no, ocaml is much less popular than haskell, from what i've observed over the last several years
11:07:18 <wuttf> I love that language but I cant bear the pain
11:07:23 <donri> wuttf: rust!
11:07:49 <Nereid> we're the second biggest language channel on freenode, not far behind python :p
11:07:52 <wuttf> donri: Look as complex as Haskell for me with 1/10 of its power
11:08:00 <tomberek> are "implicit parameters" and similar functions ever used much? I can't say I've encountered them. Is there a use case that they are needed for?   http://www.haskell.org/ghc/docs/latest/html/users_guide/other-type-extensions.html#implicit-parameters
11:08:07 <lispy> I think Go primarily makes sense if you've been programming in C++ long enough to get annoyed but you are still expected to program in something like C/C++
11:08:21 <Nereid> tomberek: I use implicit parameters all the time interactively.
11:08:29 <jmcarthur> implicit parameters are nice for discovering the type of a hole, but now that ghc is about to be released with holes that won't be so useful
11:08:32 <b__> rust is ugly, and ugliness in a language is suspect
11:08:34 <catsbydlo> tomberek: they're great for :t
11:08:37 <Nereid> yes, that.
11:08:42 <Nereid> jmcarthur: holes in 7.6.2?
11:08:42 <tomberek> Nereid: how's that?
11:08:50 <Nereid> :t map ?f "hello"
11:08:52 <lambdabot> (?f::Char -> b) => [b]
11:08:58 <catsbydlo> :t map ?f [1, 2, 3]
11:09:00 <lambdabot> (?f::a -> b, Num a) => [b]
11:09:03 <niteria> lispy: thanks, I'll try to read that
11:09:11 <jmcarthur> i don't know what release is intended to have support for holes
11:09:17 <flebron> What does ? do?
11:09:20 <catsbydlo> :t map ?f [1, 2, ?f 3]
11:09:21 <donri> jmcarthur: data Hole; __ = error "Hole" :: Hole
11:09:21 <lambdabot> (?f::b -> b, Num b) => [b]
11:09:29 <Nereid> flebron: it's from ImplicitParams
11:09:34 <jmcarthur> donri: that is not what i'm talking about
11:09:35 <catsbydlo> flebron: see tomberek's link
11:09:37 <tomberek> hm, it seems exactly like holes,
11:09:40 <donri> jmcarthur: i know
11:09:54 <wuttf> lispy: Don't get me wrong, Go is cool, but I have been proposing changes to the type system only to find out that Haskell has those ideas already
11:10:10 <donri> maybe more for Nereid
11:10:15 <tomberek> Nereid:  do holes subsume implicit parameters?
11:10:22 <Nereid> no
11:10:24 <donri> i use that in ghci to mimic type holes in ghc 7.4
11:10:31 <Nereid> ^
11:10:40 <Nereid> implicit params can be used for other things, like implicit parameters.
11:10:47 <Nereid> I've never actually seen them used that way though.
11:10:47 <jmcarthur> holes are just a more convenient way to do that one thing
11:10:49 <hpc> but that's horrible
11:11:02 <jmcarthur> i don't think the idea of implicits is so bad
11:11:06 <jmcarthur> it's just not very useful in haskell
11:11:14 <jmcarthur> they are pretty useful in agda, for example
11:11:38 <cmccann> yeah, holes subsume 99% of what implicit params were ever actually used for
11:11:50 <Nereid> it would be nice if I could put holes in type signatures though.
11:11:53 <parcs> they operator pretty differently in agda
11:11:53 <Nereid> or something
11:12:13 <donri> how do you use implicit params as holes?
11:12:16 <tomberek> I was wondering because it seems we keep adding more and more to the language, but perhaps things should be removed from the language as well, similar to n+k,,,
11:12:27 <donri> just seems harder than my __ thing, is there a benefit?
11:12:35 <jmcarthur> donri: you just stick a ?var where the hole should be
11:12:41 <cmccann> tomberek, very little has been added to the language
11:12:45 <jmcarthur> donri: and the type checker will complain about it being undefined and provide the type it expects
11:12:49 <cmccann> lots of optional things have been added to GHC, however
11:13:03 <jmcarthur> donri: your thing doesn't give you the type
11:13:10 <wuttf> > fromMaybe $ find (>10) [1..11]
11:13:13 <lambdabot>   No instance for (GHC.Show.Show
11:13:13 <lambdabot>                     (Data.Maybe.Maybe (Data....
11:13:18 <wuttf> How come?
11:13:27 <Nereid> :t all
11:13:28 <lambdabot> (a -> Bool) -> [a] -> Bool
11:13:32 <Nereid> :t and (map ?f "hello")
11:13:34 <lambdabot> (?f::Char -> Bool) => Bool
11:13:43 <parcs> :t find
11:13:44 <lambdabot> (a -> Bool) -> [a] -> Maybe a
11:13:52 <catsbydlo> :t fromMaybe
11:13:53 <lambdabot> a -> Maybe a -> a
11:13:57 <Nereid> that almost looks like a lens-like type!
11:13:59 <cmccann> > fromMaybe 0 $ find (> 10) [1..11]
11:14:01 <lambdabot>   11
11:14:02 <catsbydlo> wuttf: you forgot the default value
11:14:05 <cmccann> > fromMaybe 0 $ find (> 10) [1..9]
11:14:06 <lambdabot>   0
11:14:07 <hpaste> donri pasted “i don't see how implicit params are better herer?” at http://hpaste.org/79298
11:14:09 <tomberek> cmccan: in terms of adding to the core language, sure, but i'm thinking perhaps some pressure to cut away unused features would be a good thing
11:14:19 <jmcarthur> wuttf: maybe you meant fromJust (but try to avoid using that)
11:14:30 <jmcarthur> wuttf: fromMaybe requires a default as another argument
11:14:34 <cmccann> tomberek, why? just don't use the extensions. lots of stuff in GHC is basically ignored but why bother to remove it?
11:14:35 <wuttf> Ahh, I see guys
11:14:41 <Nereid> wuttf: you never want fromJust
11:14:46 <cmccann> > fromJust Nothing
11:14:48 <lispy> I guess new-hackage is still down but hackage is back up?
11:14:48 <lambdabot>   *Exception: Maybe.fromJust: Nothing
11:14:51 <jmcarthur> Nereid: (you sometimes want fromJust...)
11:14:57 <donri> oic you're supposed to use it with :t
11:15:16 <Nereid> donri: yes
11:15:18 <coleman-> how do you declare C function that takes int and returns void?
11:15:18 * lispy wanted to start using new-hackage in his ~/.cabal/config to test it
11:15:19 <Nereid> jmcarthur: yes, but you never *really* want it.
11:15:21 <donri> i use it without :t to cause an intentional type error that gives me the type
11:15:24 <tomberek> cmccann: if there is no tendency to simplify, it leads to bloat
11:15:28 <Nereid> coleman-: Int -> IO ()
11:15:29 <catsbydlo> coleman-: void foo(int);
11:15:35 <Nereid> coleman-: assuming you're asking about ffi again
11:15:41 <catsbydlo> Nereid: CInt?
11:15:42 <Nereid> well, CInt -> IO ()
11:15:52 <cmccann> tomberek, simplifying GHC is a wonderful idea and someone should try that one of these days
11:15:54 <coleman-> yes still doing FFI. had my first crash in haskell (dereferenced null pointer)
11:15:59 <catsbydlo> heh
11:16:11 <cmccann> removing minor extensions is not where I'd start though
11:16:17 <flebron> my first crash was an infinitely recursive type :)
11:16:24 <Nereid> I want a trailing commas extension, so I can write [1,2,]
11:16:26 <catsbydlo> newtype Void = V Void
11:16:36 <Nereid> (with newlines, in practice)
11:16:38 <k0ral> is there an existing lens library that would use IORef ?
11:16:55 <lispy> k0ral: I don't think so. I've wanted that too.
11:16:55 <jmcarthur> use it how?
11:16:57 <wuttf> Can I get docs for a function from GHCi, like :docs fromMaybe or something
11:16:59 <Nereid> k0ral: not really
11:17:06 <Nereid> k0ral: it's not too hard to use lens with IORefs though.
11:17:10 <catsbydlo> @where hoogle
11:17:11 <tomberek> cmccann: what if we look around, do some polls, and figure out features that we can remove? make it easier for maintainers and developers?
11:17:11 <lambdabot> http://haskell.org/hoogle
11:17:11 <lispy> jmcarthur: in my case, I wanted something that generalizes readIORef/writeIORef
11:17:16 <jmcarthur> i see
11:17:21 <jmcarthur> there's StateVar, but that's terrible
11:17:21 <Nereid> :t modifySTRef ?ref $ both .~ 5
11:17:23 <lambdabot> (?ref::STRef s (a, a), Num a) => ST s ()
11:17:24 <lispy> jmcarthur: then we could get rid of the OpenGL StateVar mess
11:17:29 <catsbydlo> wuttf: not as far as I know, but there's hoogle ^
11:17:33 <cmccann> tomberek, I doubt there'd be that much interest to be honest
11:17:35 <aavogt> tomberek: you can look at hackage to see which extensions are used
11:17:40 <k0ral> jmcarthur: by including readIORef/modifyIORef inside the usual get/set
11:17:44 <jmcarthur> yeah
11:17:49 <jmcarthur> it would be nice to have that
11:18:05 <wuttf> catsbydlo: I wanted something which can be used offline.
11:18:07 <lispy> k0ral: the reason lens doesn't have this is because everytime you access (readIORef) you'd also have to write the value back
11:18:08 <Nereid> yeah, I've been thinking about that recently but haven't come up with something nice.
11:18:18 <lispy> k0ral: I don't know if other lenses implementations would have such restrictions
11:18:46 <Nereid> and that problem exists, too
11:18:57 <k0ral> lispy: I don't get your point
11:19:14 <k0ral> could you please clarify ?
11:19:16 * cmccann had a library somewhere that had typeclass stuff for IORef, TVar, a lens + StateT, and a few similar things
11:19:22 <lispy> k0ral: You can't have a read-only reference, plus you pay the cost of a write everytime you read.
11:19:32 <cmccann> just a minor syntactic convenience though
11:19:34 <hpaste> bourbaki pasted “Error1” at http://hpaste.org/79299
11:19:39 <jmcarthur> i dislike how Rank2Types so often gets in the way of writing nice, point free code
11:19:48 <Nereid> well, you *can* have a read-only reference (Getter), but
11:20:05 <Nereid> hmm.
11:20:11 * lispy defers to edwardk for details
11:20:16 <k0ral> that's the second part I don't get -- where does the "write everytime you read" come from ?
11:20:22 <lispy> I've not actually tried to use lens
11:20:24 <bourbaki> How can i get rid of the error? The resolution proposed was already implemented by me, maybe the type of the Scalar can not be bound?
11:20:30 <lispy> k0ral: readIORef is a read, right?
11:20:37 <k0ral> lispy: yes
11:20:52 <tomberek> cmccann, aavogt: i like aavogt's idea, find out what extensions are used VERY rarely, find out if perhaps newer features provide a better way to do the same things, and depreciate the old ones
11:21:14 <cmccann> tomberek, very few GHC extensions overlap in functionality
11:21:25 <lispy> k0ral: with the lens library, I guess due to the way it works, if you wanted to have IORef lens they would be forced to update whenever they are accessed. I don't really know the details of why. This is just what edwardk told me when I bugged him about it.
11:21:41 <Nereid> my first (and only) attempt so far to make IORefs (and other things) work nicely with lenses ends up using atomicModifyIORef for both reading and writing.
11:21:52 <Nereid> which implies a write for every read
11:22:06 <cmccann> tomberek, you're welcome to give it a shot though, just saying that I doubt you'll accomplish much
11:22:18 <k0ral> lispy: from what I understood, lenses are just a pair of getter/setter, I don't see the necessity to write each time you read, but if you say so...
11:22:31 <tomberek> it was just a though, you're right, perhaps very little will come of it
11:22:39 <lispy> k0ral: perhaps edwardk can explain it when he's back
11:22:56 <k0ral> oh, I think I get it
11:23:13 <Nereid> let me look at my code again to see
11:23:14 <aavogt> tomberek: on at least one occasion a language feature got removed from ghc: http://www.haskell.org/ghc/docs/6.4/html/users_guide/type-extensions.html#linear-implicit-parameters
11:23:19 <k0ral> one has to abide to some laws when defining lenses
11:23:47 <Moggle> Dear lord, Haskell doesn't have a standard library split function?
11:23:49 <Moggle> I am appalled.
11:23:56 <catsbydlo> Data.List.Split
11:23:57 <Moggle> At least there's Text.Regex which only took me five years to find
11:24:00 <k0ral> if you read twice, you get the same result as if you read once, and that doesn't play well when dealing with IO-s
11:24:03 <catsbydlo> depends on how you define "standard library"
11:24:27 <Nereid> k0ral: ??
11:24:31 <jmcarthur> k0ral: but you can "read" the same action twice, at least
11:24:39 <Moggle> "A (no longer theoretical) module which contains implementations/combinators for implementing every possible method of list-splitting known to man. This way no one has to argue about what the correct interface for split is, we can just have them all. "
11:24:40 <aavogt> and in other cases the feature is still "supported" but doesn't work as it should (ex. -XImpredicativeTypes)
11:24:42 <Moggle> oh haskell wiki i love you
11:24:45 <donri> @hackage split
11:24:45 <lambdabot> http://hackage.haskell.org/package/split
11:24:49 <donri> it's part of platform
11:25:47 <k0ral> Nereid: I did not write the right law, but I think the constraint 'write when you read' comes from the need to respect laws
11:26:02 <k0ral> get l (put l b a) = b
11:26:10 <Nereid> no, it's not so much that
11:26:16 <k0ral> put l (get l a) a = a
11:26:21 <k0ral> put l b1 (put l b2 a) = put l b1 a
11:26:42 <Moggle> Thanks catsbydlo
11:26:50 <Moggle> you have saved me much pain
11:27:39 <wuttf> How many people works on GHC?
11:27:48 <Nereid> k0ral: those laws don't state anything about IO though, as view and set are pure things
11:28:08 <Nereid> what we want are things like
11:28:34 <bourbaki> Do types that are not used in a class get bound by the instance? (hope that makes sense)
11:28:37 <Nereid> setIORef ref l a = modifyIORef ref (set l a)
11:28:47 <lispy> wuttf: https://github.com/ghc/ghc/graphs/contributors
11:28:57 <Nereid> viewIORef ref l = fmap (view l) readIORef ref
11:29:17 <bourbaki> I have a class that i pass a type but it complains that there is no instance of the class it depends on with s0 but i provided Double as a type...
11:29:36 <Nereid> but my attempt to encapsulate this behaviour of an IORef ends up using atomicModifyIORef for both reading and writing
11:29:56 <Nereid> and I don't really see any way to split it up.
11:31:04 <Nereid> on the other hand I did get as far as writing something that let us do this: http://hpaste.org/79226
11:31:14 <wuttf> lispy: Where can I read more on this? Eg: who is backing their work (if there are any full time guys) etc
11:31:18 <Nereid> the implementation was pretty disgusting though, I'm not very happy with it.
11:32:25 <Nereid> notice that Reader is in there
11:32:25 <glguy> It makes sense to use lenses *with* IORefs, but not to make an IORef lens (to me)
11:32:30 <Nereid> absolutely.
11:32:42 <Moggle> Where's string replace at?
11:32:53 <Moggle> say I want to get rid of all the "\""s in mah string
11:33:01 <jmcarthur> Moggle: just use filter
11:33:01 <Moggle> I guess "list replace" is the better question
11:33:10 <Moggle> filter works only for single characters jmcarthur
11:33:15 <jmcarthur> that was your example
11:33:17 <Moggle> that works for this problem, but I'd like a gneral solution
11:33:22 <jmcarthur> ah
11:33:37 <jmcarthur> dunno, i've never had to do this
11:33:39 <k0ral> I'll try to use lenses *with* IORefs and see what it gives
11:33:43 <Moggle> :P
11:33:49 <Moggle> maybe Text.Regex has a replaceRegex
11:33:53 <Moggle> seems like overkill
11:33:57 <Moggle> i could just write my own function
11:34:04 <Nereid> k0ral: yep
11:34:07 <Nereid> you can sure do that.
11:34:10 <jmcarthur> Moggle: typically such operations come about when there is more structure to your string than just a string. i think normally you wouldn't be representing that data with a string at all
11:34:15 <b__> there is a replace function somewhere in some general library (super useful no?)
11:34:21 <Nereid> k0ral: look here:
11:34:25 <b__> I can try to find it
11:34:40 <Nereid> :t modifyIORef ?ref $ set _2 5
11:34:41 <Moggle> Text.Regex has subRegex
11:34:42 <lambdabot>     Not in scope: `modifyIORef'
11:34:42 <lambdabot>     Perhaps you meant `modifySTRef' (imported from Data.STRef)
11:34:45 <Nereid> ah
11:34:49 <Moggle> which will work pretty much perfectly
11:34:50 <Nereid> :t modifySTRef ?ref $ set _2 5
11:34:52 <lambdabot> (?ref::STRef s a, Num b, Field2 a a a1 b) => ST s ()
11:34:58 <Nereid> ergh.
11:34:59 <Moggle> but oh well regexes are a pain in haskell
11:35:04 <Moggle> not enough syntactic sugar for my tastes
11:35:09 <Nereid> :t modifySTRef (?ref :: IORef (a,Int)) $ set _2 5
11:35:10 <lambdabot> Not in scope: type constructor or class `IORef'
11:35:15 <Nereid> no
11:35:16 <Nereid> ugh!
11:35:20 <Nereid> let's not use _2
11:35:37 <b__> Moggle http://hackage.haskell.org/packages/archive/MissingH/1.0.0/doc/html/Data-String-Utils.html
11:35:56 <Moggle> "MissingH"?
11:35:57 <Moggle> haha
11:35:59 <b__> erm http://hackage.haskell.org/packages/archive/MissingH/1.2.0.0/doc/html/Data-String-Utils.html
11:36:01 <Moggle> i can see the point of the name
11:36:08 <Moggle> Haskell's lacking in some major areas standard-library wise
11:36:26 <Nereid> @let _snd f (x,y) = (,) x <$> f y
11:36:29 <lambdabot>  Defined.
11:36:30 <Nereid> :t _snd
11:36:30 <jmcarthur> i disagree that this is a major area for the reason i stated above
11:36:32 <lambdabot> Functor f => (t -> f a) -> (a1, t) -> f (a1, a)
11:36:32 <b__> I don't think so
11:36:38 <Nereid> :t modifySTRef (?ref :: IORef (a,Int)) $ set _snd 5
11:36:39 <lambdabot> Not in scope: type constructor or class `IORef'
11:36:45 <Nereid> :t modifySTRef ?ref $ set _snd 5
11:36:47 <lambdabot> (?ref::STRef s (a1, a), Num a) => ST s ()
11:36:55 <jmcarthur> it just seems major because other languages encourage such a style
11:36:59 <Moggle> Well, I suppose I'm overreacting calling it major
11:37:05 <Nereid> :t view _snd <$> readSTRef ?ref
11:37:06 <lambdabot> (?ref::STRef s (a1, b)) => ST s b
11:37:11 <Moggle> I just think these functions are so simple that they may as well be included by default
11:37:16 <Moggle> they're not hard to implement in haskell
11:37:18 <Nereid> k0ral: there
11:37:22 <jmcarthur> search and replace isn't very simple
11:37:23 <ion> What’s the difference between Data.String.Utils.join and intercalate?
11:37:30 <Moggle> I just have to parse a text file and instead of having 1000 names on single lines, they put them in quotes like huge jerks
11:37:42 <Nereid> STRef instead of IORef because of lambdabot, but you can see lenses are perfectly usable with them.
11:37:52 <jmcarthur> Moggle: can you give a sample input and output?
11:37:52 <Nereid> :t modifySTRef ?ref $ _snd .~ "hello"
11:37:54 <lambdabot> (?ref::STRef s (a1, [Char])) => ST s ()
11:37:58 <lispy> wuttf: I don't know where it's written down, but Simon Peyton-Jones is a researcher at MSR cambridge and he's the lead at this point. Simon Marlow used to work there with him, but he recently took a job at facebook. Ian (Igloo) on that page is paid to work on GHC. And then there are researchers and industry folks who rely on ghc and add features/fix bugs all the time but it's not a "paid position" for them. Johan Tible would be one such person
11:38:06 <jmcarthur> Moggle: i have a feeling you can use far simpler functions
11:38:14 <Moggle> http://projecteuler.net/project/names.txt
11:38:18 <Moggle> http://projecteuler.net/problem=22
11:38:22 <Moggle> its an utterly simple problem
11:38:26 <Moggle> i just solved it :P
11:38:33 <lispy> wuttf: MSR sponsors internships (several a year) to work on GHC as well doing research under SPJ
11:38:39 <jmcarthur> Moggle: that's an input. what kind of output is desired?
11:38:45 <Moggle> A single number, jmcarthur
11:38:48 <Moggle> I have no problems with output
11:38:53 <lispy> wuttf: the ghc trac has a page for getting started if that interests you
11:38:57 <catsbydlo> Moggle: so you wrap it in [ ] and call read, no?
11:39:00 <Moggle> I have to parse the input into a sorted list (which is easy once I got re place function)
11:39:06 <jmcarthur> Moggle: i mean the output of this smaller problem
11:39:11 <jmcarthur> Moggle: replace is too much for this i think
11:39:11 <Moggle> oh
11:39:13 <lispy> wuttf: http://hackage.haskell.org/trac/ghc/wiki/WorkingConventions
11:39:15 <Chathurga> catsbydlo: Yup that's how I did it a few days ago
11:39:17 <Moggle> If I have something like
11:39:23 <catsbydlo> Moggle: if you don't have read, you split on '","'
11:39:28 <Moggle> "HI" I'd like to strip those quotes off and have it return just HI
11:39:30 <Moggle> in other words
11:39:33 <lispy> wuttf: I have to run, but others here can probably answer other questions you might have
11:39:36 <Moggle> "\"HI\"" => "HI"
11:39:38 <Nereid> catsbydlo: I like your thinking.
11:39:42 <catsbydlo> > read "\"HI\"" :: String
11:39:44 <lambdabot>   "HI"
11:39:47 <Nereid> the "proper" way would be to write a parser.
11:39:53 <nomeata> adnam: Somewhat minimal example added to https://github.com/faylang/fay/issues/189
11:39:57 <wuttf> lispy: thank you for your help
11:39:59 <Moggle> thats something I didn't think of catsby :P
11:40:03 <Moggle> what if its a single quote?
11:40:03 <cmccann> if memory serves me, GHC's source is a fascinating museum of the haskell coding styles of years long past
11:40:05 <Nereid> :t parse
11:40:07 <lambdabot> Not in scope: `parse'
11:40:08 <catsbydlo> > read "[\"HI\",\"how\",\"are\",\"you\"]" :: [String]
11:40:08 <Moggle> I guess I can just take the tail end
11:40:10 <lambdabot>   ["HI","how","are","you"]
11:40:13 <Nereid> aw, lambdabot has no parsec.
11:40:28 <Nereid> or maybe it does, just qualified.
11:40:29 <Moggle> waiiiiit
11:40:37 <Chathurga> I was going to ask what is the best way to concat on an IO String, I did liftM scoreList (sequence [return "[", readFile "22-names.txt", return "]"]) >>= print but is there a better way?
11:40:38 <Moggle> seriously I could have just done read on that text file?
11:40:42 <Moggle> I REFUSE TO BELIEVE IT'S THAT EASY
11:40:53 <jmcarthur> :t read . words
11:40:53 <Moggle> oh god it is that easy
11:40:54 <lambdabot>     Couldn't match expected type `Char' with actual type `String'
11:40:54 <lambdabot>     Expected type: String -> String
11:40:54 <lambdabot>       Actual type: String -> [String]
11:40:55 <Moggle> kill me now
11:41:03 <Nereid> Moggle: not directly, but yeah :p
11:41:04 <catsbydlo> you're welcome :-)
11:41:08 <jmcarthur> :t map read . words
11:41:09 <lambdabot> Read b => String -> [b]
11:41:20 <catsbydlo> jmcarthur: ?
11:41:27 <Nereid> Cale: anywhere where we can see lambdabot's current L.hs ?
11:41:33 <k0ral> Nereid: thank you, I think I'll go with this
11:41:36 <jmcarthur> > map read . words $ "\"HI\" \"HEY\" \"YO\""
11:41:38 <lambdabot>   [*Exception: Prelude.read: no parse
11:41:42 <jmcarthur> > map read . words $ "\"HI\" \"HEY\" \"YO\"" :: [String]
11:41:44 <lambdabot>   ["HI","HEY","YO"]
11:41:59 <k0ral> Nereid: I'll just define something to avoid writing "modifyIORef ... =<< readIORef"
11:42:15 <Nereid> k0ral: what for?
11:42:16 <jmcarthur> oh, it's comma separated
11:42:20 <jmcarthur> nevermind me
11:42:31 <k0ral> Nereid: my bad, I meant "modifyIORef ... =<< ask"
11:42:35 <Moggle> sort . (read ("[" ++ contents ++ "]") :: [String])
11:42:39 <Moggle> things should not be that easy
11:42:39 <Cale> Nereid: I could put it on hpaste if you want
11:42:39 <Nereid> ask?
11:42:40 <k0ral> Nereid: because I'm actually working with a Reader
11:42:41 <Moggle> >:O
11:42:43 <Moggle> gosh darnit haskell
11:42:49 <Nereid> a ReaderT over IO?
11:42:50 <k0ral> Reader IORef r m
11:42:56 <Nereid> what?
11:42:58 <Nereid> oh ok
11:43:03 <k0ral> with parens :)
11:43:07 <k0ral> Reader (IORef r) m
11:43:09 <Nereid> yeah
11:43:27 <Nereid> I hope you mean ReaderT.
11:43:44 <k0ral> yes
11:43:50 <jmcarthur> Moggle: :D
11:44:03 <Nereid> time to get some sleep.
11:44:14 <Chathurga> Moggle: This is how I did it http://hpaste.org/79303
11:44:39 <Moggle> interesting method chathuga
11:44:43 <Moggle> What's return do, exactly?
11:44:54 <Moggle> seems like some kind of IO thing
11:44:56 <catsbydlo> it's a virtual constructor
11:44:59 <Moggle> oh right it is that IO thing
11:45:02 <Moggle> hence the sequence
11:45:03 <Moggle> derp
11:45:03 <jmcarthur> it's a monad thing
11:45:09 <Moggle> im just....
11:45:13 <Chathurga> I just make the strings IO so I can ram them into an IO []
11:45:16 <Moggle> so not used to seeing return used in haskell
11:45:22 <Moggle> blame all the imperative languages I know
11:45:25 <Moggle> kind of hard to break the habit
11:45:38 <cmccann> just use "pure" instead
11:45:40 <catsbydlo> inb4 linking park
11:45:44 <catsbydlo> er, linkin*
11:45:47 <Chathurga> Yeah it's a weird method, I just wanted to do it in one line and that fit, if anyone has a better way of doing that I just don't know what it is
11:45:56 <Moggle> you used a zip
11:46:00 <Moggle> that's intriguing
11:46:17 <Moggle> I was thinking zipWith would be an easier way to do it but yeah
11:46:25 <Moggle> your method is pretty much exactly mine :P
11:46:31 <Nereid> why not just fmap (\x -> "[" ++ x ++ "]") (readFile ... )
11:47:01 <catsbydlo> print =<< fmap (scoreList . read . printf "[%s]") (readFile ...)
11:47:11 <Nereid> then no need for unlines
11:47:12 <catsbydlo> take no prisoners
11:47:17 <jmcarthur> > ("["++).(++"]") "foo, bar, baz"
11:47:19 <lambdabot>   Couldn't match expected type `[GHC.Types.Char]'
11:47:19 <lambdabot>              with actual ty...
11:47:25 * cmccann would use "print . scoreList =<< "
11:47:42 <jmcarthur> > ("["++).(++"]") $ "foo, bar, baz"
11:47:44 <lambdabot>   "[foo, bar, baz]"
11:47:53 <Chathurga> catsbydlo: aaaaah I like it
11:48:13 <catsbydlo> print . scoreList . read . printf "[%s]" =<< readFile ".."
11:49:14 <hpaste> Nereid annotated “22” with “22 (annotation)” at http://hpaste.org/79303#a79304
11:49:27 <Nereid> oh I could have moved that fmap over to the left too
11:50:11 <catsbydlo> bonus points if you use interact
11:50:19 <Nereid> heh
11:50:21 <mpu> Sometimes I feel like the 'there is more than one way to do it' could also nicely fit to Haskell.
11:50:29 <strebe> it does, yes
11:50:37 <catsbydlo> it fits most languages
11:50:48 <cmccann> mpu, our equivalent is "there's a more abstract and pointfree way to do it"
11:50:57 <Chathurga> catsbydlo: How would you go about it without printf?
11:51:03 <catsbydlo> because that's what you get when you have a set of orthogonal primitive combinators
11:51:33 <catsbydlo> Chathurga: probably the way jmcarthur showed. or a lambda function
11:52:47 <Chathurga> Oh didn't see jmcarthur's, that's pretty awesome. Looks exactly like the action you want to happen
11:53:00 <Nereid> I used a lambda function.
11:53:56 <hpaste> Nereid annotated “22” with “22 (annotation) (annotation)” at http://hpaste.org/79303#a79307
11:54:03 <Nereid> improved.
11:54:34 * hackagebot smtp-mail 0.1.4.0 - Simple email sending via SMTP  http://hackage.haskell.org/package/smtp-mail-0.1.4.0 (JasonHickner)
11:55:12 <coleman-> getting weird result with ffi. can someone take a look? http://hpaste.org/79305
11:55:13 <Nereid> I haven't actually tested this code.
11:55:15 <Nereid> or even compiled it.
11:55:26 <Nereid> let's give it a go.
11:55:28 <Chathurga> Nereid: I don't know why I avoid lambdas, I think I like composition too much
11:55:36 <Chathurga> Yours is much nicwer than my original
11:55:42 <Taneb> Use lambdas when lambdas are nice
11:55:45 <Nereid> you could ("[" ++) . (++ "]") instead of that lambda ;)
11:55:58 <Nereid> also ('[':) but I like the symmetry.
11:56:11 <cmccann> Chathurga, just use lambdas at first then run everything through pointfree
11:56:15 <cmccann> that's always helpful
11:56:41 <Mortchek> I wouldn't use a pointfree version if it wasn't clear to me what it did
11:56:50 <Mortchek> Some of them can get pretty nasty
11:57:08 <Chathurga> Just couldn't out how to sandwhich a string point free, the solution is very nice though I think
11:57:12 <k0ral> naive question: why aren't lenses part of the Haskell language ?
11:57:15 <Chathurga> +figure
11:57:33 <catsbydlo> k0ral: lenses are a new invention
11:57:45 <k0ral> you mean, it appeared recently ?
11:57:47 <Nereid> yep
11:57:57 <cmccann> also, lenses would bump into the ongoing record syntax issue
11:57:59 <Nereid> the lens library is only 5 months old
11:58:01 <cmccann> which never makes any progress
11:58:03 <k0ral> so there is still hope ? :)
11:58:22 <Nereid> k0ral: it's a library, though, not a part of the language
11:58:28 <Nereid> at best we can hope for it to get included in the platform
11:59:10 <k0ral> I mean, there is currently an automatic getter created for each field of a data type, why not automatically create a lens directly in the future ?
11:59:25 <Nereid> would be cool.
11:59:26 <donri> it's been 5 months already??
11:59:33 <Nereid> yeah, amazing how time flies.
11:59:40 <Nereid> like an arrow.
11:59:41 <niteria> is there a lens paper?
11:59:43 <Nereid> et.
11:59:43 <Nereid> c
11:59:44 <k0ral> I thought I had heard of lenses for a longer time
11:59:54 <Nereid> niteria: https://github.com/ekmett/lens/wiki/FAQ
11:59:57 <donri> k0ral: yea but the lens package
12:00:20 <k0ral> donri: oh, I'm using fclabels, should I switch ?
12:00:24 <Nereid> yes!
12:00:34 <donri> you should
12:00:45 <k0ral> cool :D
12:00:52 <Nereid> btw, there's a lot more to lens than lenses ;)
12:00:59 <donri> > sequenceOf both (Just a,Just b)
12:01:01 <lambdabot>   Just (a,b)
12:01:07 <donri> do that with fclabels!
12:01:09 <Nereid> :D
12:01:34 <Nereid> > sequenceOf both ([a,b],[c,d])
12:01:36 <lambdabot>   [(a,c),(a,d),(b,c),(b,d)]
12:02:17 <Nereid> > uncurry (liftA2 (,)) ([a,b],[c,d])
12:02:19 <lambdabot>   [(a,c),(a,d),(b,c),(b,d)]
12:02:24 <Nereid> > uncurry (liftA2 (,)) (Just a,Just b)
12:02:26 <lambdabot>   Just (a,b)
12:02:39 <Nereid> fun fact: sequenceOf both = uncurry (liftA2 (,))
12:02:44 <donri> Nereid: now do it with a triple
12:03:07 <Nereid> uncurry3 (liftA3 (,,))
12:03:13 <Nereid> assuming we had uncurry3.
12:03:18 <donri> now do it with a 9-tuple
12:03:21 <donri> lalala
12:03:23 <Nereid> s/3/9/
12:03:24 <mreh> can I use alloca to pass an opaque value? I'm not sure how to make the Storable instance for a struct I dont wish to inspect.
12:03:33 <jmcarthur> donri: now you do it with a 12-tuple :P
12:03:33 <Nereid> now do it with something that's not a tuple.
12:03:35 <donri> then do it to a tuple deeply nested inside something else ;)
12:03:36 <Nereid> :P
12:03:40 <Nereid> exactly.
12:03:58 <catsbydlo> mreh: do you need a Storable instance?
12:03:59 <Nereid> > sequenceOf (both.traverse) ([Just a,Just b],[Just c,Just d,Just e])
12:04:01 <lambdabot>   Just ([a,b],[c,d,e])
12:04:05 <Nereid> fantastic.
12:04:32 <mreh> catsbydlo: alloca :: Storable a => (Ptr a -> IO b) -> IO b
12:04:45 <niteria> :t sequenceOf
12:04:47 <lambdabot> LensLike (WrappedMonad m) s t (m b) b -> s -> m t
12:05:07 <niteria> :t both
12:05:08 <catsbydlo> mreh: that's just for getting the size
12:05:08 <lambdabot> Applicative f => (a -> f b) -> (a, a) -> f (b, b)
12:05:12 <Nereid> :t sequenceAOf
12:05:14 <lambdabot> LensLike f s t (f b) b -> s -> f t
12:05:20 <Nereid> we really ought to be using this instead.
12:05:35 <bourbaki> Can i drop a type from a context in the definition of a class?
12:05:39 <rwbarton> :t each
12:05:41 <lambdabot> Not in scope: `each'
12:05:43 <mreh> catsbydlo: how do you create a Storable instance for structs normally
12:05:49 <Nereid> bourbaki: what do you mean
12:05:54 <catsbydlo> mreh: with hsc2hs
12:06:01 <bourbaki> Nereid: http://hpaste.org/79299
12:06:13 <Nereid> what am I looking for
12:06:18 <mreh> catsbydlo: with sizeof? cool :)
12:06:32 <Nereid> sizeOf sounds like a lens function.
12:06:37 <bourbaki> Nereid: The definition of InnerProductSpace
12:06:41 <catsbydlo> mreh: that is, I define a corresponding Haskell type, then use hsc2hs to define the Storable methods
12:07:07 <Nereid> bourbaki: hmm?
12:07:17 <bourbaki> Nereid: When i run this in ghci and use dist or len i get an error, when i use the uncommented functions form the end of the file i get the same error.
12:07:35 <catsbydlo> @hoogle allocaBytes
12:07:36 <lambdabot> Foreign.Marshal.Alloc allocaBytes :: Int -> (Ptr a -> IO b) -> IO b
12:07:36 <lambdabot> Foreign.Marshal.Alloc allocaBytesAligned :: Int -> Int -> (Ptr a -> IO b) -> IO b
12:07:46 <Nereid> bourbaki: you need functional dependencies.
12:07:47 <bourbaki> It complains that there is no instance of the classes i defined but says s0 instead of Double, so i wanted to try to drop the s from their definitions.
12:07:57 <Nereid> clas ... => VectorSpace s v | v -> s where ...
12:08:02 <bourbaki> Nereid: What is that :) ?
12:08:11 <Nereid> look it up. ;)
12:08:18 <bourbaki> Ok thanks a bunch.
12:08:22 <Nereid> alternatively, TypeFamilies and associated types.
12:08:42 <bourbaki> What would be better here?
12:08:56 <Nereid> that's how vector-space does it.
12:09:06 <Nereid> I'd go with associated types.
12:09:10 <Nereid> personally.
12:09:26 <mreh> catsbydlo: I don't really want to define peek and poke because it's supposed to be opaque
12:09:29 <Nereid> but either works.
12:09:36 <bourbaki> Nereid: :) ok more to read.
12:09:39 <catsbydlo> mreh: so don't define a Storable instance
12:09:52 <mreh> and use allocaBytes
12:09:53 <Nereid> bourbaki: fundeps and associated types both work well in this case.
12:09:54 <mreh> right
12:09:58 <Nereid> it's mostly preference, I guess.
12:10:22 <bourbaki> Nereid: Are associated types covered within type families?
12:10:24 <Nereid> yes
12:10:36 <bourbaki> Ah ok still on my list to read.
12:10:51 <Nereid> hmm
12:10:52 <bourbaki> How deep down the Haskell road is this?
12:11:01 <Nereid> not too deep?
12:11:06 <bourbaki> Ok :)
12:11:07 <Nereid> they're both worth knowing about.
12:11:10 <Nereid> and they're pretty simple.
12:11:18 <Nereid> although TypeFamilies can have some strange consequences.
12:11:27 <bourbaki> Also i will not be able to go on here if i do not know them now.
12:11:32 <Nereid> that I don't fully understand so maybe they're not as simple as I just said they were.
12:12:09 <bourbaki> The only thing so far that i find a bit clunky yet is the need to not name functions the same in the same module.
12:12:33 <Nereid> I see you're already using ConstraintKinds.
12:12:48 <bourbaki> Nereid: Cause the compiler told me to :)
12:12:56 <Nereid> well then!
12:13:03 <Nereid> they're already natural to you.
12:13:06 <bourbaki> But i need to read it all up
12:13:24 <Nereid> TypeFamilies and ConstraintKinds make a pretty cool combination.
12:13:29 <Nereid> example https://github.com/ekmett/lens/wiki/Varying-lens-properties-by-instance
12:13:29 <bourbaki> I know what i want to get at i just do not know the Haskell way yet.
12:14:00 <bourbaki> Thanks reading up
12:14:10 <Nereid> this assumes you're already somewhat familiar with lens.
12:14:43 <bourbaki> Im not i am rather new to Haskell
12:15:11 <bourbaki> Had a look at it some years back and came back to it now that there is a better tool chain and found a good editor
12:15:13 <Nereid> I think the example there could also work with fundeps instead of type families,
12:15:32 <Nereid> but there's a slight generalization that works with TFs
12:15:35 <Nereid> that I'm pretty sure does not with fundeps
12:15:59 <Nereid> or maybe it does
12:16:05 <Nereid> in any case it's not as pretty.
12:16:28 <Nereid> as we'd end up with an explosion of type parameters.
12:16:37 <bourbaki> :)
12:16:53 <nomeata> byorgey: have you thought about a way to give example code in the diagrams files themselves that are then rendered at build time and included in the haddock documentation using data urls?
12:17:11 <Nereid> while we're on this topic, does anyone know of a situation where fundeps can do things better than type families?
12:17:29 <hpaste> Moggle pasted “prob22” at http://hpaste.org/79308
12:17:36 <Moggle> could use some kind of feedback
12:17:51 <bourbaki> Nereid: Thanks a bunch im reading the topics up now.
12:18:08 <aavogt> Nereid: you can have a 'fallback' instance with a class that has fundeps (with -XOverlappingInstances)
12:18:08 <byorgey> nomeata: yes, https://github.com/diagrams/diagrams-doc/issues/2
12:18:17 <byorgey> nomeata: I was just thinking about it some today, in fact
12:18:26 <Nereid> Moggle: not unreasonable, although you could factor your foldl into a sum and a map
12:18:39 <Moggle> oh, good point
12:18:42 <Moggle> that would look cleaner
12:18:46 <byorgey> nomeata: it's not hard technically, but a bit tricky to figure out how it ought to work because Haddock is so liminted
12:18:46 <Nereid> foldl (\s x -> s + f x) = sum . map f
12:18:52 <byorgey> *limited
12:19:26 <Nereid> Moggle: also, you can read a file in one step with readFile
12:19:49 <Moggle> That gets the whole file?
12:19:53 <k0ral> god, lens is so much more complicated than fclabels
12:19:57 <Nereid> Moggle: yeah
12:20:00 <Moggle> :t readFile
12:20:02 <lambdabot> FilePath -> IO String
12:20:08 <Moggle> aha
12:20:09 <Moggle> I see!
12:20:17 <Nereid> Moggle: oh, you can also factor stuff out of the zipWith.
12:20:33 <Moggle> would that make it more clear, nereid?
12:20:42 <glguy> :t imap
12:20:43 <lambdabot> FunctorWithIndex i f => (i -> a -> b) -> f a -> f b
12:21:04 <Nereid> Moggle: it would get your foldl out of the zipWith argument.
12:21:12 <Moggle> the foldl, she is gone
12:21:15 <glguy> sum . imap (*) . (:) 0 . map wordValue . sort
12:21:18 <Nereid> well, what became of it.
12:21:41 <Nereid> Moggle: and yeah, I'd break that part out into a separate function score :: String -> Int
12:21:51 <Nereid> or something
12:21:59 <Nereid> value.
12:22:00 <Nereid> not score.
12:22:05 <Nereid> to use the problem phrasing.
12:23:01 <Nereid> zipWith (\place name -> place * f name) [1..] names = zipWith (*) [1..] (map f names)
12:23:38 <Nereid> Moggle: I'm basically leading you toward the code I pasted earlier :V
12:23:53 <Moggle> :P
12:24:11 <Nereid> haskell is so wonderful.
12:24:14 <Nereid> how you can factor stuff like that
12:24:15 <Moggle> the readFile suggestion was nice
12:24:21 <Moggle> haskell is funtimes but hard to understand
12:24:41 <Nereid> it gets easier when you do more of it :)
12:24:42 <Moggle> I seriously can't believe how long it took me to get self-referential things like
12:24:49 <Moggle> fib = 1 : scanl (+) 1 fib
12:24:52 <Moggle> i thought it was like
12:24:54 <Moggle> fib was a function
12:24:58 <Moggle> and it was calling itself recursively
12:25:02 <Moggle> and my brain exploded at that point
12:25:14 <Nereid> > fix $ (0:) . scanl (+) 1
12:25:17 <lambdabot>   [0,1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765,10946...
12:25:21 <bourbaki> Nereid: One more noobish question why do i have to nest that let expression in the end of the file?
12:25:39 <Nereid> bourbaki: what let expression?
12:25:46 <Moggle> What's fix even
12:25:48 <Moggle> :t fi
12:25:49 <lambdabot>     Not in scope: `fi'
12:25:50 <lambdabot>     Perhaps you meant one of these:
12:25:50 <lambdabot>       `f' (imported from Debug.SimpleReflect),
12:25:50 <Moggle> :t fix
12:25:51 <lambdabot> (a -> a) -> a
12:25:55 <Nereid> @src fix
12:25:55 <lambdabot> fix f = let x = f x in x
12:25:59 <bourbaki> Ah sec
12:26:00 <Moggle> ... wat
12:26:10 <copumpkin> Moggle: an unusual function :)
12:26:12 <Moggle> waaaaat does that even
12:26:15 <Nereid> fix f = f (fix f)
12:26:16 <jmcarthur> not that unusual!
12:26:20 <Nereid> the universal recursive function.
12:26:20 <copumpkin> well
12:26:24 <Moggle> waaaaat
12:26:25 <copumpkin> not something you'd see in most other languages
12:26:28 <Nereid> ;)
12:26:31 <jmcarthur> Moggle: it captures recursion and nothing more
12:26:37 <bourbaki> Nereid: http://hpaste.org/79309
12:26:40 <Moggle> I still don't even
12:26:45 <jmcarthur> > fix (\xs -> 'c':xs)
12:26:45 <shachaf> copumpkin: You mean, not in this eta-reduced form?
12:26:47 <lambdabot>   "cccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc...
12:26:49 <copumpkin> Moggle: fix f = f (f (f (f (f (f (f (f (f ...
12:26:50 <copumpkin> forever
12:26:51 <bourbaki> Last function
12:27:04 <jmcarthur> > fix f
12:27:05 <Moggle> copumpkin, oh I think I understand
12:27:05 <lambdabot>   Ambiguous type variable `a0' in the constraints:
12:27:06 <lambdabot>    (GHC.Show.Show a0)
12:27:06 <lambdabot>     ...
12:27:28 <Moggle> ... wait nope I don't
12:27:32 <jmcarthur> > fix f a
12:27:34 <lambdabot>   No instance for (GHC.Show.Show
12:27:34 <lambdabot>                     (Debug.SimpleReflect.Exp...
12:27:36 <hpaste> Nereid annotated “Error2” with “Error2 (annotation)” at http://hpaste.org/79309#a79311
12:27:38 <Moggle> let x = f x
12:27:39 <jmcarthur> bah not thinking
12:27:39 <shachaf> > fix f :: Expr
12:27:41 <lambdabot>   f (f (f (f (f (f (f (f (f (f (f (f (f (f (f (f (f (f (f (f (f (f (f (f (f (...
12:27:43 <Moggle> x is still being defined, how does it use itself?
12:27:44 <jmcarthur> there we go
12:27:48 <jmcarthur> Moggle: laziness
12:27:53 <copumpkin> Moggle: we can do that elsewhere too
12:28:03 <jmcarthur> Moggle: it's no different than function recursion, just more general
12:28:04 <Moggle> oh god is this more self referential things
12:28:06 <copumpkin> > let (a,b,c) = (c + 2, 3, b * 5) in (a,b,c)
12:28:08 <lambdabot>   (17,3,15)
12:28:10 <Nereid> bourbaki: there you go.
12:28:15 <bourbaki> What i would like to write is let d1 ... d2 ... d3 in the same let but then i get an error on =
12:28:16 <Moggle> I begin to see how bad I am at haskell
12:28:17 <catsbydlo> Moggle: just a recursive definition
12:28:22 <copumpkin> Moggle: in fact, I can even write that using fix!
12:28:24 <Nereid> bourbaki: see the paste
12:28:29 <copumpkin> but it might not be entirely obvious how to do that :)
12:28:35 <catsbydlo> Moggle: do you know C?
12:28:38 <Moggle> quite
12:28:46 <jmcarthur> > fix (\(a,b,c) -> (c + 2, 3, b * 5))
12:28:49 <Nereid> bourbaki: although I'd probably define vector subtraction first and then use that when I define dist
12:28:49 <lambdabot>   mueval-core: Time limit exceeded
12:28:53 <jmcarthur> fail :)
12:28:54 <copumpkin> jmcarthur: missing the magic!
12:29:00 <jmcarthur> > fix (\ ~(a,b,c) -> (c + 2, 3, b * 5))
12:29:02 <lambdabot>   (17,3,15)
12:29:07 <copumpkin> omg magick
12:29:12 <Moggle> waaaaaat
12:29:16 <jmcarthur> lazy pattern
12:29:16 <copumpkin> :P
12:29:19 <catsbydlo> struct node ones = { 1, &ones };
12:29:38 <coleman-> can someone help me figure out what is going on in here? I annotated descriptions of C functions I use for those who aren't familiar with them.   http://hpaste.org/79306 ChanServ
12:29:43 <jmcarthur> Moggle: like i said, laziness is the key to using fix for recursive values like this
12:29:57 <jmcarthur> Moggle: so i used a lazy pattern to avoid forcing the tuple until it was really needed
12:29:58 <bourbaki> Nereid: True :)
12:30:06 <sipa> > fix (\(a,b,c) -> (c+2,3,b*5))
12:30:06 <bourbaki> It seems that the tabs are the problem
12:30:09 <lambdabot>   mueval-core: Time limit exceeded
12:30:13 <Moggle> onfused a bit on notation there
12:30:21 <Moggle> (\ ~(a, b, c)
12:30:22 <bourbaki> With spaces it compiles with tabs it does not
12:30:25 <Moggle> ~(a, b, c) means what exactly?
12:30:27 <jmcarthur> Moggle: that's the lazy pattern
12:30:27 <bourbaki> Is that correct?
12:30:28 <Nereid> coleman-: does it work in compiled code outside ghci?
12:30:33 <jmcarthur> Moggle: i will demonstrate
12:30:39 <catsbydlo> coleman-: you typo'd the function name
12:30:47 <shachaf> coleman-: Please note that this may well not work the way you think with the threaded RTS.
12:30:48 <Nereid> haha that too!
12:30:59 <shachaf> coleman-: GHC has magic special-case handling of errno on UNIX that you can't get access to.
12:31:04 <jmcarthur> > case undefined of (a, b) -> ("foo", b)  -- a strict pattern
12:31:05 <lambdabot>   *Exception: Prelude.undefined
12:31:13 <jmcarthur> > case undefined of ~(a, b) -> ("foo", b)  -- a lazy pattern
12:31:14 <lambdabot>   ("foo",*Exception: Prelude.undefined
12:31:15 <bourbaki> Meh! Ok Haskell does make a difference between tabs and spaces? So i should use spaces instead of tabs?
12:31:22 <jmcarthur> note that it was able to print the "foo" that time
12:31:22 <Nereid> bourbaki: never use tabs.
12:31:25 <Nereid> @where style
12:31:25 <lambdabot> http://urchin.earth.li/~ian/style/haskell.html http://snapframework.com/docs/style-guide
12:31:29 <Nereid> the first one.
12:31:42 <bourbaki> A lesson learned :)
12:31:42 <catsbydlo> bourbaki: haskell treats tabs as multiple-of-8 spaces
12:31:46 <jmcarthur> Moggle: lazy patterns basically say to avoid forcing the value your matching until it's really needed
12:31:52 <jmcarthur> *you're
12:31:58 <pqmodn> Moggle: normally pattern matching causes evaluation
12:32:03 <Moggle> ahah
12:32:06 <Moggle> that makes sense!
12:32:13 <bourbaki> What editor are you using btw? I am using Sublime now.
12:32:19 <Nereid> vim here.
12:32:35 <Nereid> sublime sounds like a decent editor though, it should support insertion of spaces for tabs.
12:32:45 <jmcarthur> Moggle: my second example there could be written:    case x of y -> ("foo", snd y)
12:32:50 <coleman-> catsbydlo huh?  Nereid I will try give me a second
12:32:50 <tomeo> Nereid: it does
12:32:50 <bourbaki> Yes i just changed that to tabs :)
12:33:02 <Nereid> coleman-: you wrote GetLastError twice
12:33:02 <jmcarthur> Moggle: since i didn't use a pattern for y, it doesn't force it. it forces it when i apply snd to it, though
12:33:07 <bourbaki> On purpose but will change it back now.
12:33:14 <shachaf> coleman-: Lots of things could be going on. I'd apply "the usual debugging procedure" to this.
12:33:14 <catsbydlo> coleman-: you're importing GetLastError twice
12:33:16 <Nereid> coleman-: in your foreign imports
12:33:18 <jmcarthur> Moggle: ah, and i accidentally replaced undefined with x, but you get the idea
12:33:22 <coleman-> oh, damn
12:33:24 <Nereid> :D
12:33:27 <shachaf> Oh, Nereid++
12:33:27 <wuttf> What is the space complexity of the famous quicksort haskell example?
12:33:37 <coleman-> yes it works now. :))
12:33:41 <Nereid> shachaf: not attributed to me!
12:33:46 <k0ral> is there a Lens class ?
12:33:47 <jmcarthur> wuttf: space complexity is difficult to characterize since it depends on how it's consumed
12:33:49 <Moggle> case undefined of y
12:33:52 <Moggle> y is not evaluated?
12:33:54 <Nereid> k0ral: who needs one?
12:33:56 <Moggle> until it's used*
12:34:03 <Moggle> but it _is_ when doing pattern matching?
12:34:05 <shachaf> Oh, catsbydlo++
12:34:10 <shachaf> Whatever. everyone++
12:34:14 <Nereid> :)
12:34:17 <Nereid> shachaf++
12:34:27 <Nereid> shachaf +~ 1
12:34:35 * hackagebot BlogLiterately-diagrams 0.1.1 - Include images in blog posts with inline diagrams code  http://hackage.haskell.org/package/BlogLiterately-diagrams-0.1.1 (BrentYorgey)
12:34:40 <k0ral> Nereid: the instances of such class would be all data types that have a given field that can be set/got
12:35:08 <Nereid> k0ral: but part of what makes lens great is how it does away with the need for such classes.
12:35:13 <pqmodn> Moggle: case expr of var doesn't match a pattern, because you didn't specify a constructor. case expr of (x:xs) or case expr of Just x, have constructors, so expr must be evaluated far enough to check its constructor
12:35:32 <k0ral> Nereid: I'm running into the problem of naming my fields
12:35:43 <Moggle> pqmodn: Thanks, I think that makes more sense.
12:35:47 <coleman-> thanks catsbydlo
12:35:50 <k0ral> the convention for lenses is to prefix with _
12:35:56 <jmcarthur> wuttf: i'm guessing linear space, or n*log*n allocations (but where most of them are short lived)...
12:35:57 <Moggle> Learning all the ins and outs of lazy evaluation is going to take a bit
12:36:08 <Nereid> k0ral: ok, then use makeLenses or makeClassy to get lenses for them
12:36:09 <wuttf> jmcarthur: so not quadratic?
12:36:17 <jmcarthur> wuttf: i'm not sure, really
12:36:24 <Nereid> k0ral: (that's template haskell)
12:36:33 <jmcarthur> wuttf: i don't think it will take quadtratic space at any one point in time
12:36:58 <k0ral> Nereid: problem is: I have several data types with kind of the same field names
12:36:58 <wuttf> jmcarthur: If its better than quadratic then its impressive
12:36:59 <jmcarthur> wuttf: ah, but it is probably a quadratic number of allocations in total, yes. not n*log n as i said before
12:37:15 <jmcarthur> wuttf: but that's not a "snapshot" point of view
12:37:25 <Moggle> question: let names = sort (read ("[" ++ (readFile "names.txt") ++ "]") :: [String])
12:37:32 <Moggle> readFile returns an IO object, right?
12:37:36 <Nereid> k0ral: sure, so that's what makeClassy is for.
12:37:38 <Moggle> what's the best way to get the string out of it here
12:37:44 <jmcarthur> i don't have the proper terminology for discussing space usage of algorithms in the precense of gc
12:37:54 <shachaf> Moggle: That depends. Do you know how IO works?
12:37:55 <jmcarthur> *presence
12:37:57 <Moggle> quite
12:38:03 <shachaf> Moggle: (Wait. Is "names.txt" a "project euler" problem?)
12:38:05 <Moggle> I'd do contents <- readFile "names.txt"
12:38:11 <Moggle> No, shchaf it's not
12:38:14 <shachaf> OK.
12:38:15 <Moggle> you don't have to worry about that
12:38:17 <Moggle> :D
12:38:19 <Moggle> (it is)
12:38:22 <shachaf> Oh.
12:38:25 <Nereid> #22
12:38:25 <Moggle> I'm asking in general here
12:38:25 <wuttf> jmcarthur: I see, thanks.
12:38:27 <Nereid> but yeah
12:38:29 <Moggle> You don't have to boycott it
12:38:35 <Moggle> Let me rephrase
12:38:40 <Nereid> Moggle: yeah, so that doesn't typecheck.
12:38:42 <Moggle> let names = sort (read ("[" ++ (readFile "notaprojecteulerthing.txt") ++ "]") :: [String])
12:38:51 <shachaf> So what's wrong with what you wrote?
12:38:55 <shachaf> contents <- ...?
12:39:01 <Moggle> it's on two lines
12:39:08 <Nereid> Moggle: fmap (\x -> "[" ++ x ++ "]") (readFile blah) :: IO String
12:39:12 <applicative> namify x = sort (read ("[" ++x+ "]") :: [String])   ; names = fmap namify (readFile "names.txt")
12:39:23 <Nereid> this is how you apply pure functions to IO actions (or monadic actions in general)
12:39:24 <applicative> namify x = sort (read ("[" ++ x ++ "]") :: [String])   ; names = fmap namify (readFile "names.txt")
12:39:36 <Nereid> sure
12:39:45 <Moggle> Nereid: that's
12:39:52 <Nereid> :t fmap
12:39:53 <lambdabot> Functor f => (a -> b) -> f a -> f b
12:39:55 <Moggle> mildly ugly
12:39:57 <Nereid> where F = IO
12:40:03 <Nereid> well,
12:40:18 <Moggle> does using fmap that way
12:40:19 <applicative> namify x = sort (read ("[" ++ x ++ "]" :: String))   ; names = fmap namify (readFile "names.txt")
12:40:26 <Moggle> make x :: String?
12:40:30 <Nereid> yes
12:40:34 <Moggle> interesting
12:40:38 <Moggle> why's that exactly?
12:40:39 <Nereid> fmap :: (String -> String) -> IO String -> IO String
12:40:43 <Moggle> oh
12:40:46 <Moggle> fmap is defined that way
12:40:58 <Moggle> hmm, that returns an IO string though
12:41:03 <Nereid> of course.
12:41:05 <shachaf> does using newlines this way
12:41:09 <Moggle> so it's still not... exactly what I wanted
12:41:12 <shachaf> make enter :: punctuation
12:41:21 * shachaf stops.
12:41:29 <Nereid> Moggle: I would personally still put ... <- readFile ... on its own.
12:41:30 <shachaf> No point to it.
12:41:34 <applicative> Moggle: you have a text with numerals separated by commas only?
12:41:35 <Moggle> Nereid: yes I'm going to do that.
12:41:38 <Nereid> or use >>=
12:41:46 <Moggle> applicative: It's like "CAROL","HEATHER","BOB"
12:41:47 <Nereid> (see my solution)
12:41:51 <applicative> oh no, quoted expressions
12:41:54 <Moggle> so I just surrounded it with [ and ]
12:41:55 <Moggle> then read it in
12:42:09 <Nereid> who suggested that, anyway?
12:42:15 <applicative> namify x = sort (read ("[" ++ x ++ "]") :: [String])   ; names = fmap namify (readFile "names.txt")
12:42:16 <Moggle> Whoever did was clever
12:42:23 <Nereid> quite
12:42:33 <Nereid> honestly I probably would have donet he same
12:42:48 <Moggle> applicative: still gives an IO object unless I'm insane
12:42:50 <Nereid> disgusting, but clever.
12:42:59 <shachaf> I would have probably processed the file in a separate program to put one word per line.
12:42:59 <Moggle> why can't I work with pure types ;_;
12:42:59 <Nereid> Moggle: yes, at some point you're going to have to execute an IO action.
12:43:02 <shachaf> And then used lines.
12:43:16 <Moggle> I'd do that too shachaf
12:43:22 <Moggle> but the project Euler people are made of sadness
12:43:40 <Nereid> but half the exercise is to get you to parse that file.
12:43:49 <Nereid> because the rest is so simple.
12:43:52 <Nereid> at least in haskell ;)
12:44:11 <Moggle> :P
12:44:16 <Moggle> parsing things in Haskell _is_ kind of a drag
12:44:19 <applicative> >  read "[\"CAROL\",\"HEATHER\",\"BOB\"]" :: [String]
12:44:21 <lambdabot>   ["CAROL","HEATHER","BOB"]
12:44:21 <shachaf> Moggle: Well, I would either not do a "project euler" problem or, in the case of doing it, I would not ask for help.
12:44:27 <Nereid> Moggle: nah, it's much easier than other languages!
12:44:27 <Moggle> yeah, Applicative, that's what I did
12:44:38 <Moggle> shachaf: didn't need help
12:44:48 <Nereid> Moggle: to the point where we like to write parsers instead of regular expressions
12:44:51 <Moggle> I already have the solution and did like two hours ago
12:44:56 <Moggle> Nereid: example?
12:45:04 <Moggle> I'm just improving my code and making it better Haskell
12:45:10 <Nereid> not off the top of my head, no
12:45:13 <Moggle> as people have noticed I am TERRIBLE and treating it like an imperative language
12:45:24 <Moggle> asking for help on making code better is great
12:45:24 <shachaf> You should improve non-"project euler" code instead.
12:45:28 <catsbydlo> Nereid: re: "who suggested that" - guess :-)
12:45:28 <Moggle> people here are super helpful
12:45:36 <Nereid> catsbydlo: oh you. :)
12:45:40 <Moggle> shachaf, do you have another site with basic problems I can solve?
12:45:54 * cmccann suspects "how do I process this input with no coherent grammar using parsec?" is the haskell equivalent of "how do I process XML using regexps?" in other languages
12:45:56 <shachaf> @google basic haskell problems
12:45:58 <lambdabot> http://www.haskell.org/haskellwiki/H-99:_Ninety-Nine_Haskell_Problems
12:45:58 <lambdabot> Title: H-99: Ninety-Nine Haskell Problems - HaskellWiki
12:46:09 <Moggle> Ooh!
12:46:11 <Nereid> oh, shachaf is faster than me.
12:46:23 <Nereid> @where h-99
12:46:24 <lambdabot> http://www.haskell.org/haskellwiki/H-99:_Ninety-Nine_Haskell_Problems
12:46:24 <shachaf> I have no idea whether those are good.
12:46:29 <Nereid> well there you go.
12:46:33 <Nereid> me either.
12:46:36 <Moggle> I just don't understand the hatred of project euler
12:46:50 <Nereid> project euler does not resemble real life programming.
12:46:51 <Moggle> It's not particularly bad as far as I can tell?
12:46:58 <Moggle> the only problem I've had with it is that the problems are too damn easy
12:47:01 <Nereid> haha
12:47:02 <Moggle> but that changes soon enough
12:47:08 <shachaf> It's pretty bad if your goal is related to programming.
12:47:12 <Nereid> were you the guy who used !! everywhere for problem 18?
12:47:15 <shachaf> It's bad for learning a new language.
12:47:18 <Moggle> my goal is to learn Haskell syntax and basic ways of doing things
12:47:33 <Moggle> and I don't really comprehend how its bad for learning a new language O:
12:47:39 <applicative> It pretty good if your goal is learning syntax and the typesystem
12:47:40 <Moggle> yes Nereid :D
12:47:42 <Nereid> :D
12:47:47 <cmccann> project euler is great if your goal is learn ways of making shachaf complain.
12:47:54 <shachaf> cmccann: Yep.
12:48:02 <Twisol> Moggle: just curious, have you written something in another language that you enjoyed writing? some kind of personal project?
12:48:09 <shachaf> People come in here and ask why functions to generate prime numbers aren't part of the standard library.
12:48:12 <Moggle> Twisol: yes I've been programming for a long, long time
12:48:13 <applicative> we don't need to do anything to make shachaf complain
12:48:27 <Nereid> applicative: there's a lot of the language it won't cover though
12:48:43 <Twisol> Moggle: Cool. Personally, when I learn a new language, I write one of my old projects in the new language.
12:48:56 <Moggle> Twisol: interesting, but not for me unfortunately
12:49:00 <Twisol> Fair enough. :)
12:49:02 <Moggle> I don't really like resolving problems
12:49:06 <Moggle> re-solving?
12:49:13 <Nereid> heh
12:49:24 <Moggle> I have a few projects I'd like to do this winter
12:49:24 <Nereid> re-resolving
12:49:34 <Twisol> yeah - I look at it as more "I know how to do this in my head - how do I map my brainspace onto this language?"
12:49:34 <Moggle> I've wanted to do something with music forever
12:49:36 <shachaf> Moggle: OK, at least that means you'll never inflict "project euler" on any other channel.
12:49:42 <Nereid> :D
12:49:44 <Moggle> I have a basic .wma writer in C#
12:49:51 <Moggle> and I did some interesting frequency playing things in Ruby
12:49:59 <Moggle> I was planning on combining them together in something like Python
12:50:03 <Moggle> and making a music creation program
12:50:07 <Moggle> but eh we'll see
12:50:19 <Moggle> I might even do it in Haskell if Haskell is nice-enough to work with in bits
12:50:29 <Moggle> I despise Python's handling of bytestreams and the like
12:50:38 <Nereid> I wanted to do something along those lines, but now I don't have access to a computer lab full of pcs with beep speakers in them.
12:50:39 <Moggle> python numbers can be arbitrary precision and it irritats me
12:50:44 <monochrom> I started the hating of project euler. I was tired of seeing "I am doing project euler #xxx 'find the sum of all even primes', so I wrote sum [ x | x <- primes, even x ], why is it so slow", or similarly dumb algorithms. It seems to me all project euler teaches is no more than brute force using list comprehension.
12:50:46 <Moggle> C# at least has Int32 and Int16 and UInt32
12:50:56 <Nereid> C# looks like an unboxed type.
12:51:02 <Twisol> XD
12:51:04 <Nereid> or constructor.
12:51:14 <Nereid> @src Char
12:51:15 <lambdabot> data Char = C# Char#
12:51:18 <Moggle> monochrom: that's a problem with a fair few problems
12:51:18 <Nereid> what do you know!
12:51:42 <Moggle> monochrom: except that they typically get you to brute force a problem, then give you the same problem 30 questions later that's the same but with a bigger data set you CANT brute force
12:52:09 <monochrom> I give it credit for teaching list comprehension.
12:52:12 <Moggle> monochrom: http://projecteuler.net/problem=18
12:52:18 <Moggle> http://projecteuler.net/index.php?section=problems&id=67
12:52:20 <Moggle> exact same
12:52:26 <strebe> monochrom: I rather like project euler
12:52:52 <Moggle> someone told me an awesome zipWith (whatever) list (tail other list) method
12:52:54 <Moggle> for solving this problem
12:53:02 <Moggle> rather than using !! s everywhere like I was doing
12:53:06 <Nereid> > zip`ap`tail $ [1..10]
12:53:07 <Moggle> so I consider project euler useful in that way at least
12:53:08 <lambdabot>   [(1,2),(2,3),(3,4),(4,5),(5,6),(6,7),(7,8),(8,9),(9,10)]
12:53:14 <ijp> monochrom: well, the guidelines for project euler say that each problem should be solvable in under a minute, if you use a sensible algorithm.
12:53:16 <monochrom> btw the answer is 2.
12:53:27 <Moggle> Nereid: what the heck is `
12:53:41 <Nereid> `ap` is an infix version of ap
12:53:43 <c_wraith> Moggle: there are very few cases where (!!) is correct. Most of the time, it means you're hurting your algorithm's performance for no gain
12:53:47 <ijp> monochrom: if they aren't doing that, then they are not really working to the spirit of project euler
12:53:47 <Moggle> oh jeez
12:53:51 <Moggle> i thought you need spaces
12:53:53 <Nereid> :P
12:53:54 <shachaf> c_wraith: Did you see the code in question?
12:54:00 <c_wraith> shachaf: no
12:54:02 <Nereid> @quote zip`ap`tail
12:54:02 <lambdabot> quicksilver says: zip`ap`tail - the Aztec god of consecutive numbers
12:54:09 <Moggle> zip `ap` tail $ [1..10]
12:54:13 <Moggle> is what I would have expected
12:54:17 <Moggle> alright well I learned something today
12:54:19 <ijp> of course, some people take "runs under a minute" to mean "rewrite in C"
12:54:23 <Nereid> I'd rather write zip <*> drop 1
12:54:24 <Moggle> :t ap
12:54:25 <Nereid> but that's just me
12:54:25 <lambdabot> Monad m => m (a -> b) -> m a -> m b
12:54:48 <Twisol> That zip `ap` tail thing reminds me a lot of Ruby's each_cons.
12:54:48 <catsbydlo> Moggle: ap f g x = f x (g x)
12:54:50 <Nereid> ap :: (t -> a -> b) -> (t -> a) -> (t -> b) -- the S combinator
12:54:51 <Moggle> oh, ap is <$>?
12:54:57 <Nereid> no, <*> = ap
12:55:04 <Twisol> <$> is fmap
12:55:13 <Moggle> ah, knew I mixed something up
12:55:28 <Nereid> in any case, specialized to functions, <*> = ap = the S combinator.
12:55:38 <catsbydlo> :t (=<<) . flip
12:55:38 <Twisol> as in SKI?
12:55:39 <lambdabot> (a1 -> a -> b) -> (a1 -> a) -> a1 -> b
12:55:43 <fryguybob> > let zip'ap'tail a = zipWith a`ap`tail in (+) `zip'ap'tail` [0..10]
12:55:44 <Nereid> Twisol: yes
12:55:44 <lambdabot>   [1,3,5,7,9,11,13,15,17,19]
12:55:58 <Nereid> Twisol: as you know, S f g x = f x (g x)
12:56:21 <Twisol> Nereid: I don't know much about SKI really, except that it's a system of three basic combinators. But that's pretty interesting!
12:56:25 <Nereid> ok
12:56:29 <Nereid> K = const, and I = id, of course
12:56:36 <Nereid> :t ap const const
12:56:37 <lambdabot> b -> b
12:56:43 <shachaf> And I = S K K
12:56:53 <Twisol> When you put it that way, it looks a lot more approachable.
12:57:01 <Nereid> :)
12:57:09 <Twisol> so just ap, const, and id?
12:57:12 <Nereid> yep
12:57:16 <Twisol> *whistles* Nice.
12:57:18 <catsbydlo> > ((=<<) . flip) zip tail [1 .. 10]
12:57:20 <lambdabot>   [(1,2),(2,3),(3,4),(4,5),(5,6),(6,7),(7,8),(8,9),(9,10)]
12:57:37 <startling> @let s f x y = f x (f y)
12:57:38 <lambdabot>  <local>:4:16:
12:57:38 <lambdabot>      Occurs check: cannot construct the infinite type: t1 = t1...
12:57:41 <Nereid> :t ((=<<) . flip)
12:57:43 <lambdabot> (a1 -> a -> b) -> (a1 -> a) -> a1 -> b
12:57:54 <startling> Twisol, have I pointed you to "To Mock a Mockingbird"?
12:58:02 <Nereid> startling: we don't want to redefine s, anyway
12:58:07 <Nereid> > s
12:58:09 <lambdabot>   s
12:58:16 <Twisol> startling: I've heard the name before. Not sure if you actually pointed me to it.
12:58:18 <startling> Nereid: ah, that makes sense
12:58:48 <startling> Twisol: it's a puzzle-ish book and introduction to combinatory logic by Raymond Smullyan. It's fun
12:59:19 <bootcode_> Question: I have `f :: State S Bool` and `g :: State S ()`, `g = f >>= (flip when g)`. Is there a simpler way for writing g? Repeat a monadic action while successful.
12:59:43 <Nereid> incidentally, note that the types of ap and const are two of a set of axioms for propositional logic ;)
12:59:56 <Nereid> ~curry-howard isomorphism~
13:00:18 <catsbydlo> A && B => A
13:00:23 <startling> @let starling a b c  = a c (b c)
13:00:25 <lambdabot>  Defined.
13:00:31 <startling> :t starling const const
13:00:32 <lambdabot> t -> t
13:00:44 <startling> > starling const const 12 == 12
13:00:46 <lambdabot>   True
13:01:01 <catsbydlo> > fmap fix return 12
13:01:03 <lambdabot>   12
13:01:26 <hpaste> Moggle pasted “22b” at http://hpaste.org/79315
13:01:33 <Moggle> This is about as beautiful as I can get the code
13:01:35 <Twisol> Nereid: I read something about that last night. Something to do with dependent types?
13:01:42 <Moggle> anyone have any recommendations?
13:01:44 <Nereid> Twisol: not really
13:02:01 <startling> Twisol: propositional logic is used to define lots of things
13:02:02 <Moggle> i suppose i could do score = sum $ map (whatever)
13:02:18 <jmcarthur> i'll make an annotation
13:02:34 <startling> Twisol: the curry-howard isomorphism is what lets you write proofs in dependently-typed languages though
13:03:34 <startling> well, it's what makes those proofs useful, anyway. :)
13:04:01 <Nereid> exercise: viewing propositions as type variables, and _|_ as the empty type Void,
13:04:15 <Nereid> implement these axioms (as total functions): http://en.wikipedia.org/wiki/Intuitionistic_logic#Hilbert-style_calculus
13:04:36 <Nereid> or something.
13:04:44 <Twisol> Interesting
13:04:45 <Nereid> oh, conjunction is (,), and disjunction is Either.
13:04:45 <Moggle> Out of curiosity: is there any performance loss from using $ everywhere
13:04:51 <Moggle> or is that something the compiler would fix?
13:04:52 <Nereid> Moggle: nope
13:05:01 <Moggle> intriguing!
13:05:11 <Nereid> Moggle: the compiler can do much smarter optimizations than that ;)
13:05:13 <startling> Moggle: fwiw, don't use it *everywhere*
13:05:24 <Nereid> true.
13:05:31 <startling> Moggle: "a $ b $ c $ d" is "a . b . c $ d"
13:05:34 <Moggle> I have heard lots of things about ghc, Nereid
13:05:53 <ijp> startling: that isn't qualitatively different
13:06:09 <Moggle> startling: I do the second version because I find it prettier, but is it any better performance wise?
13:06:13 <startling> ijp: how do you mean?
13:06:17 <shachaf> Moggle: Yes, there's a significant performance loss in the reader of your code from overusing $
13:06:17 <startling> Moggle: I don't think there's any
13:06:27 <startling> haha
13:06:28 <Moggle> shachaf: :P
13:06:54 <aavogt> have people used something like http://hackage.haskell.org/package/gladexml-accessor recently?
13:07:34 <ijp> startling: I mean, I can't see any real argument that one is more readable than the other
13:07:44 * aavogt got it to compile with a more recent haxml (apparently haxml now cares about namespaces where before it didn't)
13:07:47 <int-e> return $ foo . bar $ x
13:08:07 <Moggle> startling: print . sum . zipWith (\name place -> place * score name) names $ [1..]
13:08:18 <int-e> to me that's more readable than return . foo . bar $ x or return $ foo $ bar $ x
13:08:18 <Moggle> versus versus
13:08:20 <Moggle> print $ sum $ zipWith (\name place -> place * score name) names [1..]
13:08:29 <Moggle> the first one is preferable?
13:08:30 <shachaf> print $ foo (bar x)
13:08:30 <startling> ijp, oh, in my experience a . b . c $ d is much more flexiple
13:08:32 <Moggle> it seems a little bit off
13:08:44 <Nereid> a $ b $ c = a . b $ c
13:08:50 <nomeata> byorgey: after upgrading diagrams from 0.5 to 0.6 this code does not work any more; it seems that the radius has become 0. any idea why? http://darcs.nomeata.de/circle-packing/diagrams-demo.hs
13:09:02 <Nereid> I wish $ was infixl :(
13:09:03 <startling> ijp: e.g. if d was an argument to a function, you could just delete $ d
13:09:15 <int-e> Nereid: I don't
13:09:20 <rwbarton> everyone has their own opinion and will assure you it is the only sensible one
13:09:30 <startling> rwbarton: I disagree.
13:09:43 <Nereid> then I could write f $ big thing $ big other thing instead of f (big thing) $ big other thing
13:10:06 <startling> big thing `f` big thing
13:10:14 <Moggle> by the way
13:10:15 <Nereid> what if f was some complex expression?
13:10:24 <Moggle> is there a way to make (\name place -> place * score name) into a nice function composition?
13:10:24 <Nereid> startling: then that wouldn't work.
13:10:29 <startling> Nereid: true
13:10:35 <Nereid> :t (*) . ?score
13:10:37 <lambdabot> (?score::f a, Functor f, Num a) => f (a -> a)
13:10:41 <Nereid> ugh
13:10:43 <Nereid> :t (*) Prelude.. ?score
13:10:45 <lambdabot> (?score::a -> b, Num b) => a -> b -> b
13:10:45 <Nereid> damn you cale!
13:10:48 <hpaste> jmcarthur annotated “22b” with “22b (annotation)” at http://hpaste.org/79315#a79316
13:10:58 <jmcarthur> Moggle: ^^
13:11:00 <Moggle> oh wow
13:11:02 <Moggle> thanks jmcarthur
13:11:02 <startling> Moggle: (*) .: score where (.:) = (.) . (.)
13:11:04 <Moggle> :D
13:11:10 <Nereid> startling: we don't want that.
13:11:17 <jmcarthur> startling: :(
13:11:20 <startling> Nereid: er right, my mistake
13:11:36 <startling> I was thinking backwards.
13:11:42 <jmcarthur> (.:) is so ugly. i don't understand the appeal.
13:11:48 <Nereid> anyway, here was mine (see the bottom): http://hpaste.org/79303
13:11:56 <startling> (socre .: (*) might be valid, the other one definitely isn't)
13:12:01 <Twisol> :t (flip (*) . score)
13:12:02 <lambdabot> Not in scope: `score'
13:12:13 <Twisol> heh, derp.
13:12:18 <startling> :t (flip (*) . f)
13:12:19 <lambdabot> (Functor f, Num c, FromExpr (f c)) => f (c -> c)
13:12:21 <Nereid> Moggle: I would put the [1..] as the first argument to zipWith anyway.
13:12:24 <startling> err
13:12:29 <startling> > flip (*) . f
13:12:30 <lambdabot>   No instance for (GHC.Show.Show (f0 (c0 -> c0)))
13:12:30 <lambdabot>    arising from a use of `M...
13:12:38 <Moggle> Nereid: is that personal preference?
13:12:41 <Nereid> because that's fixed, and it gives us more flexibility with the list.
13:12:45 <Moggle> ah
13:12:45 <startling> oh well
13:12:52 <nomeata> byorgey: I think I found it, replaced radius by envelopeS
13:12:52 <yitz> jmcarthur: (.:) is not too bad when used as a time function, e.g. 12.:45
13:13:09 <Nereid> :t zipWith (?f . ?g) ?a
13:13:11 <lambdabot> (?f::a1 -> b -> c, ?g::a -> a1, ?a::[a]) => [b] -> [c]
13:13:12 <startling> :t 12 .: 45
13:13:13 <yitz> jmcarthur: or the oposite as a constructor - 12:.45
13:13:13 <lambdabot> (Functor g, Functor f, Num (f (g a)), Num (a -> b)) => f (g b)
13:13:15 <Nereid> :t zipWith (?f) ?a . map ?g
13:13:16 <lambdabot> (?f::a -> b -> c, ?a::[a], ?g::a1 -> b) => [a1] -> [c]
13:13:17 <hpaste> jmcarthur annotated “22b” with “22b (annotation) (annotation)” at http://hpaste.org/79315#a79317
13:13:18 <startling> :P
13:13:24 <Moggle> jmcarthur, this is nice
13:13:28 <jmcarthur> Moggle: just the extras to include ^^
13:13:28 <Nereid> those are equal.
13:13:30 <Moggle> I like the idea of applying score to everything first
13:13:45 <Moggle> then mapping (*) as it kind of solves my issue nicely
13:13:49 <Nereid> :t (zipWith (?f . ?g) ?a, zipWith ?f ?a . map ?g)
13:13:49 <Moggle> zippingwith, whatever
13:13:50 <lambdabot> (?f::b -> b -> c, ?g::b -> b, ?a::[b]) => ([b] -> [c], [b] -> [c])
13:13:55 <Nereid> there.
13:13:56 <Nereid> unified.
13:14:08 <Nereid> the types are the same, so clearly they do the same thing!
13:14:25 <Nereid> (one day...)
13:15:18 <Moggle> jmcarthur, thanks again
13:15:21 <jmcarthur> np
13:15:35 <jmcarthur> Moggle: there are, of course, a hundred ways to slice it
13:15:56 <Nereid> oh wait, those things I wrote weren't quite the same.
13:16:01 <Moggle> jmcarthur: but yours is prettier
13:16:08 <Twisol> Can anyone see a way to make this cleaner? <https://gist.github.com/2652f9ae600de5c02c6d> I tried to identify patterns and make them obvious, but I don't know where to go from here.
13:16:13 <int-e> @type (++) -- sigh
13:16:15 <lambdabot> Monoid m => m -> m -> m
13:16:17 <Nereid> :t (zipWith (?f . ?g), zipWith ?f . map ?g)
13:16:18 <lambdabot> (?f::a1 -> b -> c, ?g::a -> a1) => ([a] -> [b] -> [c], [a] -> [b] -> [c])
13:16:21 <Nereid> much better.
13:16:40 <Nereid> so I dunno.
13:16:43 <jmcarthur> int-e: that is one of the only caleskell changes i agree with :)
13:16:50 <int-e> @type ((++mzero),join(++))
13:16:51 <lambdabot> (MonadPlus m, Monoid a1, Monoid (m a)) => (m a -> m a, a1 -> a1)
13:17:06 <int-e> > ((++mzero) [1],join(++) [1])
13:17:08 <lambdabot>   ([1],[1,1])
13:17:51 <yitz> jmcarthur: well now (<>) is in base, so use that instead
13:17:51 <int-e> jmcarthur: yeah but now the types of those two functions are different
13:17:53 <Nereid> :t (<>)
13:17:54 <lambdabot> Monoid m => m -> m -> m
13:17:55 <Nereid> yeah
13:19:13 <jmcarthur> int-e: but they can still be unified
13:19:18 <int-e> jmcarthur: of course
13:19:32 <jmcarthur> yitz: yeah :)
13:20:02 <int-e> @type ((++[]),(++[]).join(++))
13:20:03 <lambdabot> ([a] -> [a], [a1] -> [a1])
13:20:18 <Nereid> :t join (Prelude.++)
13:20:20 <lambdabot> [a] -> [a]
13:20:27 <startling> Twisol: why not use StateT
13:20:37 <jmcarthur> > join (++) "foo"
13:20:38 <lambdabot>   "foofoo"
13:20:52 <Nereid> right.
13:21:00 <Twisol> startling: primarily because I started from scratch so I could learn to identify patterns
13:21:07 <jmcarthur> > "little bunny " ++ join (++) "foo"
13:21:07 <yitz> > join (<>) "foo" -- :)
13:21:09 <lambdabot>   "little bunny foofoo"
13:21:09 <lambdabot>   "foofoo"
13:21:22 <startling> Twisol: StateT is a pattern you should recognize. :)
13:21:32 <Twisol> startling: I do see that there's a State idea in there, but I don't have a clear idea of how to transform the code in that direction.
13:23:07 <startling> Twisol: alright, so TelnetParser could be newtype TelnetParser m a = StateT ByteString m a
13:23:27 <startling> Twisol: this might be named TelnetT or ParserT, btw
13:23:37 <Twisol> *nod* With you so far.
13:24:01 <hrumph> these libraries sure have a lot of components
13:24:06 <hrumph> is all this really necessary?
13:24:25 <startling> Twisol, also, you probably want to make it a MonadTrans instance so you can use lift
13:24:25 <yitz> Twisol, startling: never mind StateT, how about ContT?
13:24:40 <startling> Twisol: which turns an m x into a TelnetT m x
13:24:51 <jmcarthur> hrumph: what libraries?
13:24:54 <startling> yitz: that's closer to what he has right now, yeah
13:24:55 <brayshakes> Why does the distribution weight in > 100 mb?
13:24:57 <Twisol> yitz: I see that idea in there too, but Cont is a bit beyond me right now. ^_^
13:25:04 <hrumph> i did cabal install cabal-install
13:25:15 <yitz> Twisol: well you asked for it with your CPS approach ;)
13:25:17 <hrumph> or something like that. i then proceeded to download and install a million and one things
13:25:24 <Twisol> yitz: I needed a way to interrupt the parser. ;)
13:25:36 <startling> Twisol: hooray, you invented continuations
13:25:38 <hrumph> i=it
13:25:48 <jmcarthur> hrumph: sounds about right
13:25:49 <Twisol> startling: :P
13:25:51 <startling> hrumph: yeah, they're necessary
13:25:53 <yitz> Twisol: if all you need is the ability to interrupt, just use the Either monad
13:26:13 <startling> yitz: eh, you can only interrupt from *inside* the parser, then.
13:26:52 <Twisol> Well, I need to be able to interrupt from the event handlers I've defined
13:27:09 <Twisol> or at least cause an interrupt to occur, as I have now by returning a Bool
13:27:28 <yitz> startling: i don't understand what you mean. Either can do everything ContT can do wrt early exit, except more simply.
13:28:31 <jmcarthur> ContT is often far too powerful for what you really need
13:28:39 <startling> yitz: sure, but say he wants to only run a tiny bit of this parser and then continue later
13:28:52 <startling> that's what I understood from "interrupt", anyway
13:29:03 <jmcarthur> startling: laziness is a nice way to do that kind of thing, too :)
13:29:11 <jmcarthur> although if IO is involved it's tougher
13:29:14 <Twisol> intended usage is, for example, if we realize that compression is about to start. Stop the parser, decompress, then resume
13:29:15 <startling> jmcarthur: or State
13:29:31 <jmcarthur> i don't see how state does this, but i haven't look at the code in question
13:29:36 * hackagebot happstack-jmacro 7.0.4 - Support for using JMacro with Happstack  http://hackage.haskell.org/package/happstack-jmacro-7.0.4 (JeremyShaw)
13:29:43 <Twisol> jmcarthur: https://gist.github.com/2652f9ae600de5c02c6d
13:33:05 <startling> jmcarthur: nah, I mean State can be hard to inspect parts of lazily
13:33:34 <hrumph> ok ....i'm trying to get my head around things..............on my linux box its apache the apache user that runs httpd by default.......so apache will the call yesod scripts (i guess) but how can i get all of these things installed for apache, when apache doesn't have a home dir....its not a user with a shell
13:34:15 <hrumph> earlier today i was told that cabal won't do system wide installs of libs and that they're a bad thing anyway
13:35:10 <catsbydlo> it will, just not by default
13:35:22 <hrumph> oh so i do have to do the system wide installs anyway
13:36:12 <hrumph> i wonder why people were telling me they were a bad thing when it turns out its my only option to get a server running
13:36:32 <jmcarthur> newtype TelnetParserF a = TelnetParserF (ByteString -> (ByteString, a)); newtype TelnetParserT m a = TelnetParserT (FreeT TelnetParserF m a)
13:36:45 <Moggle> out of curiosity, how would I do something like map (-64) [1..]?
13:36:53 <Moggle> so that i get [-63, -62] and so on
13:36:55 <copumpkin> map (subtract 64)
13:36:56 <Moggle> should I be using flip?
13:36:58 <catsbydlo> > map (-64) [1..]
13:36:58 <copumpkin> sadly
13:37:00 <lambdabot>   Could not deduce (GHC.Num.Num (a0 -> b))
13:37:00 <lambdabot>    arising from the ambiguity chec...
13:37:02 <simpson> hrumph: Well, let's focus on that "i guess" part.
13:37:06 <copumpkin> @let (–) = (-)
13:37:07 <lambdabot>  Defined.
13:37:08 <catsbydlo> what!
13:37:13 <copumpkin> > map (–64) [1..]
13:37:14 <lambdabot>   mueval: recoverEncode: invalid argument (invalid character)
13:37:14 <Moggle> yes, catsby
13:37:15 <Moggle> it surprised me too
13:37:17 <Moggle> :P
13:37:17 <jmcarthur> catsbydlo: "negative 64"
13:37:19 <copumpkin> > map (– 64) [1..]
13:37:19 <lambdabot>   mueval: recoverEncode: invalid argument (invalid character)
13:37:21 <copumpkin> sigh
13:37:31 <Moggle> perhaps `subtract`
13:37:33 <Moggle> could work!
13:37:35 <catsbydlo> jmcarthur: no, "error message"
13:37:44 <Moggle> >subtract 2 1
13:37:48 <jmcarthur> catsbydlo: can't show a function
13:37:49 <simpson> hrumph: It's absolutely not your only option. Also if you're using Yesod with Warp, then you're going to just be proxying, and the Yesod app can run as any user you like.
13:38:01 <catsbydlo> jmcarthur: I want to show a list
13:38:03 <Moggle> map (`subtract`  64) [1..5]
13:38:12 <Moggle> might work
13:38:21 <Moggle> nope!
13:38:25 <catsbydlo> > [(-64) 1]
13:38:27 <lambdabot>   Could not deduce (GHC.Num.Num (a0 -> t))
13:38:27 <lambdabot>    arising from the ambiguity chec...
13:38:31 <Moggle> i guess I should use flip
13:38:33 <hrumph> simpson: which web server is most suited to running yesod?
13:38:35 <catsbydlo> > 1 2
13:38:37 <lambdabot>   Could not deduce (GHC.Num.Num (a0 -> t))
13:38:37 <lambdabot>    arising from the ambiguity chec...
13:38:40 <catsbydlo> ok, how broke lambdabot?
13:38:43 <Moggle> map (flip . subtract 64) [1..5]
13:38:50 <Moggle> > map (flip . subtract 64) [1..5]
13:38:50 <startling> hrumph: doesn't yesod run on its own server?
13:38:52 <lambdabot>   No instances for (GHC.Enum.Enum (a0 -> b0 -> c0),
13:38:52 <lambdabot>                    GHC.Nu...
13:38:56 <jmcarthur> @undef
13:38:58 <startling> catsbydlo: num instances are gone
13:38:59 <simpson> hrumph: Mu. Yesod normally is deployed *with* Warp, so it doesn't need a server.
13:39:00 <jmcarthur> don't think that should help
13:39:04 <jmcarthur> wha-?
13:39:07 <hrumph> startling: i didn't know that i figured it would have to go in a cgi scripts dir
13:39:09 <jmcarthur> no more num instances? :(
13:39:11 <simpson> hrumph: You can always proxy if you want something in front.
13:39:17 <simpson> hrumph: But it's not CGI.
13:39:19 <catsbydlo> startling: terrible!
13:39:21 <startling> hrumph: it's not CGI.
13:39:23 <hrumph> i haven't actually studied this
13:39:26 <startling> catsbydlo: I know. :(
13:39:34 <jmcarthur> who didn't like numinstances in lambdabot?
13:39:47 <startling> > const 1 + const 1
13:39:47 <hrumph> maybe i should read the quickstart page :)
13:39:48 <lambdabot>   No instance for (GHC.Num.Num (b0 -> a0))
13:39:49 <lambdabot>    arising from a use of `e_111'
13:39:49 <lambdabot>  ...
13:40:00 <startling> hrumph: probably a good idea.
13:40:02 <hrumph> myt first inclination was just to get some libs installed to i could study the functions
13:40:17 <hrumph> but that opened these other cans of worms
13:40:19 <simpson> hrumph: Yesod really does have its own preferred way of being developed.
13:40:25 <simpson> And paying attention to that will help you.
13:41:50 <hrumph> i'll be happy to be free of apache and php
13:42:13 <hrumph> you have to be a genius to read someone elses php code
13:42:28 <shachaf> jmcarthur: Me.
13:42:47 <simpson> hrumph: Or insane. Insanity helps.
13:44:15 <Luke> I want to make a function for "[(ByteString, Maybe ByteString)] -> [(ByteString, ByteString)]" where the Nothings are just removed from the list. Can anyone think of a clever single liner for this? Maybe arrows or something?
13:45:15 <hpaste> roSievers pasted “Writer Monad, which imports are needed?” at http://hpaste.org/79319
13:45:16 <ClaudiusMaximus> list comprehension should work great for that
13:45:41 <simpson> :t f xs = catMaybes (map g xs) where g (x, Just y) = (x, y); g _ = Nothing
13:45:42 <lambdabot> parse error on input `='
13:45:52 <roSievers> Hi, could someone tell me, how to properly import the Writer Monad?
13:46:10 <shachaf> import Control.Monad.Writer
13:46:26 <glguy> <_< import MonadLib
13:46:26 <jmcarthur> shachaf: what undesirable effects did it have?
13:46:40 <shachaf> jmcarthur: It was confusing someone who was trying to understand something.
13:46:48 <roSievers> I did in http://hpaste.org/79319 but it did not work
13:46:49 <ClaudiusMaximus> > [ w | w@('t':_) <- words "i tawt i taw a puddy cat" ]
13:46:51 <lambdabot>   ["tawt","taw"]
13:46:57 <shachaf> jmcarthur: lambdabot's main purpose is pedagogical, I think.
13:47:12 <glguy> roSievers: do you have the "mtl" library installed?
13:47:15 <Luke> i think i'll go with the list comprehension. clean and simple
13:47:28 <roSievers> I doubt it
13:47:29 <Taneb> I did not realise you could do it
13:47:31 <Taneb> *that
13:47:38 <jmcarthur> hmm... i think the presence of numinstances is also useful for pedagogy, but for a different level of user
13:48:01 <shachaf> jmcarthur: Is it useful for something other than "explaining numinstances"?
13:48:01 <glguy> roSievers: Did you install the Haskell Platform?
13:48:08 <simpson> :t let g (x, Just y) = Just (x, y); g _ = Nothing in \xs -> catMaybes (map g xs)
13:48:09 <lambdabot> [(t, Maybe t1)] -> [(t, t1)]
13:48:09 <ClaudiusMaximus> how about > for newbie running code, and >> for insane people
13:48:14 * simpson should probably just stop now
13:48:15 <jmcarthur> i think it demonstrates something interesting about algebraic structures
13:48:25 <Saizan> and haskell
13:48:38 <roSievers> glguy, I only installed the ghc package for ubuntu, nothing more
13:49:03 <jmcarthur> i wish more of our standard applicatives had num instances, not just functions
13:49:16 <jmcarthur> > Just 5 + Just 6
13:49:17 <lambdabot>   No instance for (GHC.Num.Num (Data.Maybe.Maybe a0))
13:49:18 <lambdabot>    arising from a use o...
13:49:18 <hpaste> bourbaki pasted “Error” at http://hpaste.org/79320
13:49:22 <glguy> roSievers: There might be a "haskell-platform" package in Ubuntu. This will have the "standard" libraries that people expect you to have
13:49:28 <shachaf> I'm just going by all the "what? 5 is a function?"
13:49:39 <shachaf> lambdabot being relatively close to what people see in their ghci is a good thing.
13:49:45 <jmcarthur> i understand that there is a fair bit of initial confusion
13:49:51 <roSievers> I'll go, check synaptics
13:49:55 <bourbaki> Can anyone help me to understand and correct that error in the code pasted? Somone pointed me to fundeps but i do not see how this is solving my problem.
13:49:59 <jmcarthur> i think there are far worse violations of that than numinstances
13:50:02 <jmcarthur> :t (.)
13:50:03 <lambdabot> Functor f => (a -> b) -> f a -> f b
13:50:06 <shachaf> Agreed.
13:50:07 <bourbaki> Since i can not constraint the type that is causing the problem.
13:50:12 <shachaf> I'm slowly getting Cale to change them back:
13:50:13 <shachaf> @ty flip
13:50:13 <jmcarthur> that's not even the Control.Category version
13:50:15 <lambdabot> (a -> b -> c) -> b -> a -> c
13:50:22 <jmcarthur> i see
13:50:31 <shachaf> I doubt he'll ever give up on (.)=fmap
13:50:33 <ClaudiusMaximus> i can see both arguments, it's nice to have no unexpected suprises.   perhaps 98> for plain Haskell '98 with basic libraries (essentially, the report modules), similarly 10> for Haskell 2010,
13:50:47 <shachaf> You say initial confusion, but this is confusion that has to be repeated for every beginner who comes in here.
13:51:10 <shachaf> I think the confusion of learning actual Haskell is bad enough.
13:51:45 <ClaudiusMaximus> but i don't feel like hacking on lambdabot code to add multiple different environments
13:51:50 <simpson> :t flip flip flip flip flip
13:51:51 <lambdabot> (a1 -> ((a -> b -> c) -> b -> a -> c) -> c1) -> a1 -> c1
13:51:53 <simpson> :t flip flip flip flip flip flip
13:51:53 <Luke> :t [(x, y) | (x, Just y) <- xs]
13:51:54 <yitz> bourbaki: i like your nick
13:51:54 <lambdabot> (a1 -> ((a -> b -> c) -> b -> a -> c) -> c1) -> a1 -> c1
13:51:54 <lambdabot>     Not in scope: `xs'
13:51:55 <lambdabot>     Perhaps you meant one of these:
13:51:55 <lambdabot>       `x' (imported from Debug.SimpleReflect),
13:51:57 <Taneb> What was most confusing for me learning haskell, if I recall correctly, was that GHCi and my IRC client looked really similar
13:52:02 <yitz> bourbaki: what was the error?
13:52:05 <bourbaki> yitz: Thanks :)
13:52:09 <jmcarthur> Taneb: lol
13:52:19 <simpson> Huh. So after five flips, further flips just stop flipping?
13:52:21 <Taneb> Haskell actually matches what my brain wants most of the time
13:52:29 <bourbaki> yitz: Can i paste the error in here?
13:52:47 <yitz> bourbaki: if it's short. otherwise, you can paste that on hpaste also
13:53:11 <yitz> bourbaki: as an annotation to your original paste
13:53:24 <bourbaki> http://hpaste.org/79321
13:53:26 <bourbaki> Oh ...
13:53:49 <hpaste> bourbaki annotated “Error” with “Error (annotation)” at http://hpaste.org/79320#a79322
13:54:16 <bourbaki> Well almost :)
13:54:17 <shachaf> simpson: Well, they're flipping each other.
13:54:37 <simpson> shachaf: Right, but the type stops changing after five.
13:55:01 <bourbaki> yitz: The problem seems to be that i do not use that second type in the classes?
13:55:05 <shachaf> flip1 flip2 flip3 flip4 flip5 flip6 = flip2 flip4 flip3 flip5 flip6 = flip4 flip5 flip3 flip6 = flip5 flip6 flip3
13:55:23 <shachaf> Er, no.
13:55:39 <shachaf> Well, anyway.
13:55:45 <shachaf> The same thing happens with (.), sort of.
13:55:53 <aristid-ipad> in a way
13:56:43 <mpu> Do you have a simple way to strip the extension of a filename (assuming it is the smallest suffix that starts with a '.').
13:58:38 <applicative> bourbaki: instance InducedMetricSpace Double (T3 Double) where dist x y = let (v1, v2, v3) = (getSum (Sum x <> inv (Sum y))) in sqrt (v1 * v1 + v2 * v2 + v3 * v3)
13:58:59 <Clint> mpu: system-filepath
13:59:09 <Moggle> question: what's .: and =<< or <<= whatever ti is
13:59:57 <mpu> Clint, I would like to rely on packages that are in the platform.
14:00:06 <Twisol> oh boy :D
14:00:24 <bourbaki> applicative: Ok but it does not use len :) which was the initial cause to setup the InducedMetricSpace class, because len can be used
14:00:28 <bourbaki> Or should be
14:00:51 <`ramses> mpu: takeWhile (/= '.') . reverse
14:00:57 <applicative> you could presumably put a Double signature somewhere
14:01:38 <bourbaki> applicative: In the instance?
14:02:17 <`ramses> mpu: sorry, misread, try this: init . reverse . dropWhile (/= '.') .reverse
14:02:25 <`ramses> can probably be done shorter too :)
14:02:27 <Moggle> `ramses: would tail . dropWhile (/='.') work better?
14:02:33 <applicative> thats what I was thinking, bourbaki let me see
14:02:58 <bourbaki> Im at a total loss here because i do not even understand yet where the error arises from.
14:03:12 <mpu> `ramses: seems fairly convoluted...
14:03:22 <`ramses> mpu: it is :)
14:03:54 <yitz> bourbaki: if a method does not use one of the type variables, it's very hard to use that method. the type checker won't be able to tell which instance you want.
14:04:00 <`ramses> mpu: you just drop from the tail until you find a '.' and then take all but the last char (the dot)
14:04:35 <bourbaki> yitz: Yes i thought so, so i tried to drop the unused s from the definition of the class, then it complains though that s was not in scope
14:05:03 <applicative> bourbaki: it also works if you add FunctionalDependencies and write class (Field s, Additive Abelian v) => VectorSpace s v | v -> s  where
14:05:10 <bourbaki> So my intuition seems to be ok here but i do not see a resolution yet :(
14:05:12 <jmcarthur> Moggle: (=<<) is just (>>=) backwards
14:05:22 <applicative> bourbaki: class (Field s, Additive Abelian v) => VectorSpace s v is the real problem
14:05:25 <jmcarthur> Moggle: more precisely, (=<<) = flip (>>=)
14:05:30 <Moggle> jmcarthur: and .: or :. whatever it is? also what is >>=
14:05:46 <bourbaki> Why v -> s ?
14:05:55 <jmcarthur> Moggle: (.:) is silly. (.:) = (.).(.)
14:06:09 <bourbaki> This is a constraint that does not always have to hold.
14:06:12 <applicative> it  is wierd syntax, but means here, the vector type determines the scalar type
14:06:12 <Moggle> I am afraid I do not even understand how that applies.
14:06:13 <jmcarthur> Moggle: it's just (.), but where the second function takes two arguments
14:06:15 <saati> :t (.>)
14:06:16 <lambdabot> Indexable i k => (b -> c) -> Indexed i a b -> k a c
14:06:17 <saati> :t (.:)
14:06:18 <lambdabot> (Functor g, Functor f) => (a -> b) -> f (g a) -> f (g b)
14:06:21 <Moggle> oh!
14:06:24 <Moggle> it takes two arguments, alright.
14:06:34 <bourbaki> applicative: The vector would not have to be made up of scalars.
14:06:35 <applicative> you are envisaging diverse scalar types? grrr. hmm.
14:06:44 <edwardk> :t (.).(.)
14:06:45 <lambdabot> (Functor f1, Functor f) => (a -> b) -> f (f1 a) -> f (f1 b)
14:06:45 <jmcarthur> Moggle: (>>=) is one of the magical functions that do notation desugars into
14:06:49 <edwardk> :t fmap.fmap
14:06:50 <lambdabot> (Functor f1, Functor f) => (a -> b) -> f (f1 a) -> f (f1 b)
14:06:52 <roSievers> can someone tell me, where the oposite of >> can be found? << isn't in Prelude :-(
14:06:55 <Moggle> And what is it exactly?
14:06:55 <edwardk> :t fmap.fmap.fmap
14:06:57 <lambdabot> (Functor f2, Functor f1, Functor f) => (a -> b) -> f (f1 (f2 a)) -> f (f1 (f2 b))
14:06:58 <Moggle> What's the purpose?
14:07:00 <`ramses> mpu: init . dropWhileEnd (/= '.')
14:07:04 <jmcarthur> Moggle: it chains operations together
14:07:06 <jmcarthur> :t (>>=)
14:07:07 <lambdabot> Monad m => m a -> (a -> m b) -> m b
14:07:09 <bourbaki> applicative: I am just trying to get as close to the mathematical definition as possible.
14:07:10 <applicative> bourbaki: it isn't saying that, just that there won't be more than one scalar type for one vector type
14:07:11 <shachaf> roSievers: Nowhere.
14:07:20 <shachaf> roSievers: There's an Applicative version, though:
14:07:20 <jmcarthur> Moggle: mentally replace the "m" in that type with "IO" for specific case
14:07:22 <shachaf> @ty (<*)
14:07:24 <lambdabot> Applicative f => f a -> f b -> f a
14:07:24 <yitz> applicative: VectorSpace looks ok to me. i think InnerProductSpace is the first problem.
14:07:27 <bourbaki> applicative: Ah ok
14:07:32 <jmcarthur> *for a specific case
14:07:34 <Moggle> ah, that helps
14:07:39 <bourbaki> So it says that s just depends on v entirely?
14:07:41 <roSievers> shachaf: thanks
14:07:45 <applicative> wait, yitz has a better idea?
14:08:09 <jmcarthur> @undo do { x <- foo; y <- bar; return (x + y) }
14:08:09 <lambdabot> foo >>= \ x -> bar >>= \ y -> return (x + y)
14:08:10 <bourbaki> And all other classes that drop s?
14:08:11 <jmcarthur> Moggle: ^^
14:08:53 <Moggle> jmcarthur: there was an example earlier of turning (\name place -> place * score name) into a composition of functions using .:, how exactly does that even work
14:09:24 <`ramses> mpu: does that look better ? :) You can go through the Data.List functions and look for alternatives yourself as well ;)
14:09:46 <mpu> `ramses: Yep, thanks.
14:10:06 <applicative> right, I thinkI see what yitz means; it typechecks for one thing.  that's where you use v but not s
14:10:40 <bourbaki> Yes but if i do not use the s on the right side it tells me s was out of scope.
14:10:59 <jmcarthur> Moggle: i don't know what you are talking about. here's one way to simplify that, though:   (\name place -> place * score name)  ==>  (\name place -> (*) place (score name))  ==>  (\name place -> (*) (score name) place)  ==>  (\name -> (*) (score name))  ==>   (\name -> ((*) . score) name)  ==>  (*) . score
14:11:34 <yitz> applicative, bourbaki: i think at some point you either need to force any vector space type to have a unique scalar type associated with it, using either a fundep or an associated type; or provide a phantom parameter to methods like innerProduct so that you can specify the scalar type.
14:11:43 <Moggle> O:
14:12:10 <Moggle> It applies the left argument to the lambda function first?
14:12:17 <johnw> hi Moggle
14:12:18 <bourbaki> yitz: Is that not what i did with the instance ?
14:12:22 <Moggle> hi johnw
14:12:42 <Moggle> I understand this now! thanks jmcarthur
14:12:43 <bourbaki> I thought that the instance of InnerProductSpace , Double, would also constraint the s on the context.
14:12:47 <jmcarthur> Moggle: np
14:12:51 <johnw> (f .: g) x x turns into f (g x x)
14:13:12 <johnw> which is the same as ((f .) . g) x x
14:13:42 <yitz> bourbaki: no the instance is doesn't help. the problem is that you can't use the instance in other code. the type checker won't know what instance you are referring to, because in principal there could be many instances of VectorSpace for the same v.
14:14:21 <bourbaki> Ok
14:14:40 <bourbaki> yitz: So it is the same problem as here ? http://www.haskell.org/haskellwiki/Functional_dependencies
14:15:33 <Moggle> I pronounce my solution as good as I can get it. Now for dinner!
14:16:04 <yitz> bourbaki: yes
14:16:11 <yitz> sort of
14:16:49 <bourbaki> I see the problem but i do not yet understand why the v -> s solves it
14:16:58 <yitz> @pl \name place -> place * score name
14:16:58 <lambdabot> (*) . score
14:17:15 <Moggle> yitz: hot damn that's a nice feature
14:17:18 <bourbaki> I miss the ability to introspect what happens there yet.
14:17:25 <jmcarthur> huh, didn't realize @pl knew (*) was commutative
14:17:43 <yitz> Moggle: most often it's just a curiosity though.
14:17:53 <jmcarthur> it spits out some ugly stuff sometimes
14:18:08 <jmcarthur> @pl \a b c d e -> e b d a c
14:18:09 <lambdabot> ((flip . (flip .)) .) . flip (flip . (flip .) . flip . flip id)
14:18:18 <Moggle> oh that's a super nice feature
14:18:20 <Moggle> O:
14:18:24 <ClaudiusMaximus> @pl \name place -> score name * place
14:18:25 <lambdabot> (*) . score
14:18:28 <yitz> @pl \z y x f -> f x y z
14:18:28 <lambdabot> flip (flip . (flip .) . flip (flip . flip id))
14:18:49 <ClaudiusMaximus> interesting
14:19:04 <bourbaki> Anyway thanks ill try to understand this by reading on fundeps and typefamilies.
14:19:50 <bourbaki> Are there any ways to "debug" this or do you just need to get deeper into the type system?
14:20:07 <Moggle> General question just to make sure I understand this: (\a b -> a * fun b) when written as ((*) . fun) essentially compiles to (((*) . fun) a ) b) right?
14:20:12 <Moggle> that's how the arguments in the lambda function are applied?
14:20:29 <Moggle> left to right?
14:20:34 <jmcarthur> Moggle: \a b -> (*) a (fun b)
14:20:43 <yitz> bourbaki: when you use a method in a function, it needs to resolve uniquely to a function defined in a specific *potential* instance - not just a specific instance among those you happen to have defined so far
14:21:02 <yitz> bourbaki: that's how multi-parameter classes work
14:21:23 <jmcarthur> Moggle: nothing happens until you've applies the lambda to both arguments, in ghc (unless optimizations cause it to restructure in some way)
14:21:31 <jmcarthur> *applied
14:21:36 <startling> how difficult is dynamic module loading in haskell? I want to read a configuration file and load "plugins" from the locations given
14:22:17 <yitz> bourbaki: otherwise, the meaning of your expression could change over time just by adding new instances elsewhere, even in other modules
14:22:37 <bourbaki> yitz: So i need to read on multi parameter classes to understand this?
14:22:39 <jmcarthur> Moggle: \a b -> ((*) a) (fun b)
14:22:42 <Taneb> Where does seq get its name?
14:22:46 <jmcarthur> Moggle: i should have said that instead ^^
14:22:52 <Peaker> Is there a nice correct way to read a null-terminated UTF8 string in Data.Binary.Get?
14:22:55 <jmcarthur> Taneb: "sequence" or "sequential"
14:23:05 <jmcarthur> Taneb: even though it's not really that
14:23:19 <Peaker> Can I just read until 0 and then do a UTF8 decode? Or do 0 bytes represent non-0's in some UTF8 contexts?
14:23:23 <jmcarthur> Taneb: because it doesn't actually specify which argument to evaluate first
14:23:48 <bourbaki> yitz: Right that was the problem on the site i pasted earlier, so v -> s gives the compiler the clue that s is soley dependant von v and then can derive if from T3 Double?
14:23:55 <yitz> bourbaki: mptc's are not trivial. for example, they (together with a few other extensions) are what make haskell's type system turing complete.
14:24:34 <bourbaki> Heh ok :) so this is already rather complex but worth to dig into?
14:25:06 <yitz> bourbaki: right, it promises the compiler that you will only write one instance with that v. so if it finds one with some particular s, now it knows that must be the right instance to use.
14:25:07 <bourbaki> I mean i am totally aware that i can solve the problem i want to a lot easier but id like to see how far i can go here.
14:25:35 <bourbaki> yitz: Thus i could not define another instance with Int as a scalar?
14:25:57 <en> @unpl atDef = (. atMay) . (.) . fromMaybe
14:25:58 <lambdabot> atDef g m d = fromMaybe g (atMay m d)
14:26:01 <yitz> bourbaki: right. you promised. and the compiler will cry foul if you break your promise.
14:26:20 <bourbaki> Hehe ok but then the class would be totally useless.
14:26:21 <tbreisacher> Peaker: http://en.wikipedia.org/wiki/UTF-8#Modified_UTF-8 says that "modified UTF 8" never contains null bytes
14:26:36 <X-suriV> yitz: Unless you buy your compiler a really nice anniversary gift
14:26:39 <Peaker> tbreisacher, what's the "modified"?
14:26:42 <X-suriV> and plow it with alcohol
14:26:43 <yitz> bourbaki: oh no, you can use Int as scalar for a different v. just not a scalar other than Int with that v.
14:26:43 <tbreisacher> Peaker: which would seem to imply that standard UTF 8 may contain null bytes, though i'm not sure if it says that explicitly
14:26:45 <bourbaki> X-suriV: :))
14:27:06 <yitz> X-suriV: unfortunately, the compiler is very cynical about those things
14:27:27 <tbreisacher> Peaker: "modified UTF-8" is apparently the name of an encoding which is similar to UTF-8 but not quite identical. if you scroll up it lists a couple other such encodings
14:27:34 <bourbaki> yitz: But not Int and Double on T3 Double?
14:28:01 <bourbaki> Cause this might be totally valid for a vector space.
14:28:05 <yitz> bourbaki: right. if you take this approach. you would need to use a newtype to create a "new" version of T3 Double.
14:28:14 <bourbaki> Different instances of vector space that is.
14:28:55 <tbreisacher> Peaker: i think U+0000 is represented as 0x00 but that's the only time you'd see 0x00 in UTF-8... so if the string doesn't have U+0000 in it then you're ok... i think...
14:29:04 <bourbaki> Hm ok. Is there any way to implement this properly? Or is it a hard constraint i do have to live with atm?
14:29:14 <yitz> bourbaki: the fundep means that the concept of a vector space also includes its scalar type. perhaps the "associated types" approach - an alternative to fundeps - makes that more clear in this case.
14:29:48 <bourbaki> Ok ill read that up then, i really need to get a bit deeper in all this first i think.
14:30:42 <startling> has anyone used this? http://hackage.haskell.org/package/plugins
14:30:42 <bourbaki> The problem is that the vector space it not only dependant on v but also on s so i have a bad feeling about that v -> s
14:31:01 <aavogt> startling: have you looked at what dyre does? That's probably the easiest approach. You could also use http://hackage.haskell.org/package/hint
14:31:37 <roSievers> Is there some stock mechanism in haskell with type signature :: (b -> (c, d)) -> (a, b) -> (a, c,d)  which just applies the function  to the second entry of the tuple?
14:31:58 <tbreisacher> @hoogle (b -> (c, d)) -> (a, b) -> (a, c,d)
14:31:59 <lambdabot> No results found
14:32:04 <fmap> :t second
14:32:06 <lambdabot> Arrow a => a b c -> a (d, b) (d, c)
14:32:23 <catsbydlo> :t fmap
14:32:25 <lambdabot> Functor f => (a -> b) -> f a -> f b
14:32:31 <startling> aavogt: yeah, I've seen hint but it doesn't quite allow as much data exchange
14:32:39 <fmap> :t over _2
14:32:40 <lambdabot> Field2 s t a b => (a -> b) -> s -> t
14:33:17 <yitz> bourbaki: you could do: class InnerProductSpace v where innerProduct :: v -> v -> Double
14:33:18 <Clint> roSievers: you want (a,c,d) or (a,(c,d))?
14:33:40 <roSievers> I don't really care about that
14:34:01 <roSievers> at that point, the tuple will be read by myself anyway, not by a human
14:34:02 <tbreisacher> if you want (a,(c,d)) then you can write it more generally i think
14:34:06 <startling> aavogt: dyre looks intersting, though, thanks
14:34:11 <roSievers> @hoogle (b -> (c, d)) -> (a, b) -> (a,( c,d))
14:34:12 <lambdabot> No results found
14:34:26 <roSievers> @hoogle (b -> c) -> (a, b) -> (a,c)
14:34:27 <lambdabot> Data.Graph.Inductive.Query.Monad mapSnd :: (a -> b) -> (c, a) -> (c, b)
14:34:27 <lambdabot> Data.Graph.Inductive.Query.Monad (><) :: (a -> b) -> (c -> d) -> (a, c) -> (b, d)
14:34:27 <lambdabot> Data.Graph.Inductive.Graph emap :: DynGraph gr => (b -> c) -> gr a b -> gr a c
14:34:49 <roSievers> this is an amazing tool :-)
14:35:02 <roSievers> thanks for showing me
14:35:37 <bourbaki> yitz: Hm, yeah but that would not be the same then, i wonder if this does not work in Haskell is there a logical problem then in the definition of an inner product space also?
14:35:54 <yitz> bourbaki: same issue
14:36:08 <bourbaki> I mean in the mathematical definition.
14:36:56 <yitz> bourbaki: well it's not really different. you are leaving out the axioms of inner product, which do mention the scalar type. but there isn't an easy way to implement that in haskell.
14:37:24 <yitz> bourbaki: sounds like what you really want is a dependently typed language, like agda
14:37:47 <bourbaki> What is agda? Never heared about it.
14:37:49 <applicative> > let roSeivers :: (b -> (c, d)) -> (a, b) -> (a, (c,d)); roSeivers = fmap in roSeivers ((,)3) (1,2)
14:37:51 <lambdabot>   (1,(3,2))
14:38:20 <bourbaki> Will check it out also.
14:38:25 <applicative> > let roSievers :: (b -> (c, d)) -> (a, b) -> (a, (c,d)); roSievers = fmap in roSievers ((,)3) (1,2) --rather
14:38:26 <lambdabot>   (1,(3,2))
14:38:29 <yitz> bourbaki: in haskell the usual approach is to just implement the class part, then write the axioms in a comment.
14:39:44 <applicative> I suppose Idris's type classes can only have one parameter?
14:39:45 <yitz> bourbaki: unfortunately, dependently-type languages are still mostly only for proving theorems
14:39:47 <Moggle> Question: when I do (*) . score, this results in a function that takes one input. But... is that input the original left or right argument to (*)? ie., is it like (*) (score a) b or is it (*) b (score a)?
14:40:07 <shachaf> Moggle: Expand out (.) and see!
14:40:11 <shachaf> (.) f g x = f (g x)
14:40:21 <bourbaki> yitz: Hm, as always in live you can not get everything :)
14:40:22 <shachaf> (.) (score a) b x = (score a) (b x)
14:40:34 <shachaf> Er, not that.
14:40:48 <shachaf> (.) (*) score x = (*) (score x)
14:41:09 <Moggle> So the left argument is used, meaning the right argument is... alright, that works.
14:41:12 <Moggle> Thanks shachaf!
14:41:29 <bourbaki> yitz: I think the only use for multiple instances in one module of a vector space would be if you wanted to do something like a proof or morphismish, so it should not be a constraint too hard to take.
14:41:32 <shachaf> Moggle: Now you try one.
14:41:45 <chexxor_home> hpc: My GHC 7.6 build on ARM is getting close! Exact same error as this guy - http://web.archiveorange.com/archive/v/I7X0L4QWQTdoAtV3FnJy
14:42:25 <bourbaki> Still i find this rather itchy, but i will see if i can bend my head around this better once i read about type families and fundeps more.
14:42:27 <Moggle> (++) . show ===> (++) (show x)
14:42:45 <Moggle> uh, let me write a simple zipWith and see if I can get that to work
14:43:02 <yitz> bourbaki: right. in fact, most of the time you would have the same scalar type throughout your application, so you could just use regular type classes.
14:43:11 <startling> does cabal-dev let me set a "global" sandbox location?
14:43:26 <applicative> bourbaki: https://github.com/edwinb/Idris-dev/blob/master/lib/Prelude/Algebra.idr  ends with "-- XXX todo:--   Fields and vector spaces."
14:43:35 <yitz> startling: global in what sense?
14:43:35 <startling> hehe
14:43:46 <startling> yitz, I want cabal-dev install to install to ~/.cabal-dev
14:43:50 <bourbaki> yitz: The application i want to sue all this for is pretty straight forward but i just want to see how far i can take it there:)
14:44:04 <bourbaki> thanks applicative
14:44:09 <bourbaki> So much to read :)
14:44:21 <yitz> startling: there is the --sandbox= option
14:44:25 <startling> bourbaki, idris is fun to work on and #idris is friendly but quiet
14:44:28 <Moggle> zipWith ((++) . show) [1..] (replicate 10 "5")
14:44:32 <Moggle> aha, and it even works as expected
14:44:35 <startling> yitz: yeah, that's what I'm using atm
14:44:36 <Moggle> > zipWith ((++) . show) [1..] (replicate 10 "5")
14:44:38 <lambdabot>   ["15","25","35","45","55","65","75","85","95","105"]
14:44:40 <Moggle> is that how you even use lambdabot
14:44:42 <Moggle> oh good it is
14:45:56 <tromp> > zipWith shows [1..] (replicate 10 "5")
14:45:58 <lambdabot>   ["15","25","35","45","55","65","75","85","95","105"]
14:46:18 <yitz> > text "Moggle: you can get rid of quotes"
14:46:20 <lambdabot>   Moggle: you can get rid of quotes
14:46:33 <bourbaki> Off to bed with me, and thank you all again.
14:46:39 <Moggle> thanks yitz
14:47:00 <startling> > map show . take 10 . iterate (+ 10) $ 5
14:47:02 <lambdabot>   ["5","15","25","35","45","55","65","75","85","95"]
14:47:59 <tromp> > [5,15..95] >>= show
14:48:01 <lambdabot>   "5152535455565758595"
14:48:01 <roSievers> applicative: using that fmap looks nice, too. Thanks. (but for now mapSnd does the job just as well (-: )
14:48:38 <tromp> > [5,15..95] >>= return . show
14:48:40 <lambdabot>   ["5","15","25","35","45","55","65","75","85","95"]
14:48:40 <yitz> > text . ('[':) . (++"]") . concat . intersperse "\",\"" . map show $ [5,15..95]
14:48:42 <lambdabot>   [5","15","25","35","45","55","65","75","85","95]
14:48:57 <hiptobecubic> almost
14:49:05 <yitz> ach!
14:49:26 <yitz> > text . ("[\""++) . (++"\"]") . concat . intersperse "\",\"" . map show $ [5,15..95]
14:49:28 <lambdabot>   ["5","15","25","35","45","55","65","75","85","95"]
14:50:02 <davorb> can someone tell me why this will print out christmas five times? do "merry"; return "christmas"
14:50:08 <jmcarthur> > text . show $ map show [5,15..95]
14:50:10 <lambdabot>   ["5","15","25","35","45","55","65","75","85","95"]
14:50:21 <shachaf> davorb: Where is that from? People keep asking about it in here.
14:50:31 <catsbydlo> davorb: because there are 5 letters in "merry"
14:50:34 <davorb> exam that's taking place tomorrow
14:50:43 <startling> haha
14:50:48 <jmcarthur> lol
14:50:51 <davorb> catsbydlo: i realized that. but i didn't realize that do-notation worked that way.
14:50:53 <X-suriV> finals week eh
14:51:03 <shachaf> davorb: Do you know how do notation works?
14:51:04 <davorb> yeah. http://en.wikibooks.org/wiki/Haskell/do_Notation doesn't seem to mention it.
14:51:11 <tbreisacher> davorb: i wish i could have taken haskell classes in school
14:51:16 <catsbydlo> davorb: do "merry"; return "christmas" desugars to "merry" >> return "christmas"
14:51:17 <shachaf> davorb: Can you do the mechanical translation according to those rules?
14:51:23 <catsbydlo> aw
14:51:28 <shachaf> Well, you don't need to.
14:51:34 * arbn finds it hard to believe that Haskell is in so many college courses.
14:51:38 <startling> yeah.
14:52:00 <catsbydlo> davorb: a >> b is equivalent to a >>= \_ -> b
14:52:09 <catsbydlo> now all you need is the definition of >>=
14:52:10 <tbreisacher> it would be cool if lambdabot had a @desugar command
14:52:16 <jmcarthur> it does
14:52:20 <davorb> ah, so it's the then operator. thanks!
14:52:27 <jmcarthur> @undo do { x <- foo; bar x }
14:52:27 <lambdabot> foo >>= \ x -> bar x
14:52:32 <tbreisacher> @desugar do "merry"; return "xmas"
14:52:33 <lambdabot> Unknown command, try @list
14:52:33 <simpson> @undo do { x <- [1..10]; return (x + 1) }
14:52:34 <lambdabot> [1 .. 10] >>= \ x -> return (x + 1)
14:52:40 <tbreisacher> ah undo
14:52:41 <tbreisacher> cool
14:52:52 <catsbydlo> it even comprehends lists
14:53:04 <simpson> Does it?
14:53:11 <jmcarthur> i thought it would be agnostic to them
14:53:19 <simpson> @undo [x + 1 | x <- [1..10]]
14:53:19 <lambdabot> concatMap (\ x -> [x + 1]) [1 .. 10]
14:53:24 <simpson> Oh my.
14:53:28 <jmcarthur> oh, comprehensions
14:53:34 <davorb> tbreisacher: half of the questions on this exam are just for f*cking with people. like 1b, here. you're supposed to use 'flip' http://fileadmin.cs.lth.se/cs/Education/EDAN40/exams/Exam101216.pdf
14:53:35 <simpson> It *does* comprehend lists. :3
14:54:14 <shachaf> davorb: You can do that without flip.
14:54:23 <tbreisacher> @pl f x y = 3*y + x
14:54:23 <lambdabot> f = (. (3 *)) . (+)
14:54:31 <davorb> don't you need a function that takes x y?
14:54:44 <davorb> you're not allowed to use lambas
14:54:46 <shachaf> You can do what lambdabot said, for instance.
14:54:57 <shachaf> OK, that has an implicit flip in it.
14:55:01 <tbreisacher> a slightly silly question i admit, but i don't know if it's "just for f*cking with people"
14:55:01 <shachaf> But you can do it without flip.
14:55:02 <yitz> davorb: are you allowed to use @pl on the test? ;)
14:55:21 <davorb> yitz: pen and paper :P
14:55:27 <davorb> ah, cool! thanks shachaf.
14:55:46 <chexxor_home> what does the $ do? like here -> "BS.pack $ toUTF8 content"
14:56:03 <tbreisacher> @hoogle $
14:56:03 <lambdabot> Prelude ($) :: (a -> b) -> a -> b
14:56:03 <lambdabot> Data.Function ($) :: (a -> b) -> a -> b
14:56:03 <lambdabot> Prelude ($!) :: (a -> b) -> a -> b
14:56:06 <catsbydlo> @src ($)
14:56:07 <lambdabot> f $ x = f x
14:56:53 <chexxor_home> lol, I've never used Haskell before. I'm just trying to compile GHC
14:56:58 <jmcarthur> woah
14:57:04 <jmcarthur> why not install a binary?
14:57:12 * tbreisacher wonders why one would want to compile GHC if they've never used haskell
14:57:15 <catsbydlo> chexxor_home: wtf?
14:57:23 <chexxor_home> because there doesn't exist a binary for ARM that has GHCi working
14:57:24 <tbreisacher> chexxor_home: the Haskell Platform would be a good place to start, most likely
14:57:27 <tbreisacher> oh :(
14:57:36 <tbreisacher> davorb: the reason that lists are a monad is they're intended for things that can return multiple values
14:57:49 <chexxor_home> I think the patch is in 7.6, so I'm compiling 7.6
14:58:19 <Peaker> tbreisacher, for now, I'll assume I can read till 0, and then decode, and hope for the best :)
14:58:37 <chexxor_home> so I'm trying to figure out the best way to resolve this - should I submit a patch? Or just do a hotfix locally on the code?
14:58:48 <tbreisacher> davorb: for example, you roll two dice, what are all the possible outcomes... you can express that as
14:58:48 <tbreisacher> do
14:58:48 <tbreisacher>   x <- [1..6]
14:58:48 <tbreisacher>   y <- [1..6]
14:58:48 <tbreisacher>   (x,y)
14:58:54 <tbreisacher> (i think have that right...)
14:59:01 <jmcarthur> you need return
14:59:12 <simpson> tbreisacher: You wanted a return at the end. Also use hpaste for multiple lines.
14:59:34 <simpson> > do { x <- [1..6]; y <- [1..6]; return (x, y) }
14:59:35 <lambdabot>   [(1,1),(1,2),(1,3),(1,4),(1,5),(1,6),(2,1),(2,2),(2,3),(2,4),(2,5),(2,6),(3...
15:00:06 <davorb> tbreisacher: thanks for the explanation
15:00:39 <tbreisacher> so using strings in a do-block like that is kind of silly
15:00:48 <catsbydlo> very
15:00:56 <jmcarthur> > sortBy (comparing fst) . map (length &&& head) . group . sort $ liftA2 (+) [1..6 [1..6]
15:00:57 <shachaf> Medium silly.
15:00:58 <lambdabot>   <hint>:1:88: parse error (possibly incorrect indentation)
15:01:03 <jmcarthur> > sortBy (comparing fst) . map (length &&& head) . group . sort $ liftA2 (+) [1..6] [1..6]
15:01:05 <lambdabot>   [(1,2),(1,12),(2,3),(2,11),(3,4),(3,10),(4,5),(4,9),(5,6),(5,8),(6,7)]
15:01:06 <chexxor_home> why would this build fail for me? I pulled from the stable release branch...
15:01:13 <tbreisacher> in fact i wonder if there's a compiler warning you can turn on for that
15:01:21 <shachaf> > do x <- "hello"; y <- "world"; [(x,y)]
15:01:23 <lambdabot>   [('h','w'),('h','o'),('h','r'),('h','l'),('h','d'),('e','w'),('e','o'),('e'...
15:01:30 <shachaf> tbreisacher: Why would you want a compiler warning for that?
15:01:33 <jmcarthur> > map (length &&& head) . group . sort $ liftA2 (+) [1..6] [1..6]
15:01:33 <shachaf> I don't.
15:01:34 <lambdabot>   [(1,2),(2,3),(3,4),(4,5),(5,6),(6,7),(5,8),(4,9),(3,10),(2,11),(1,12)]
15:01:36 <chexxor_home> and it's a type mistmatch, which should have been caught by a developer...
15:02:09 <scp> #haskell is an awesome channel. so active
15:02:23 <tbreisacher> shachaf: i don't know, i can't think of an example where you would use it except for a contrived exam question. but if i did use it accidentally, i would enjoy the compiler saying "psssst, i think you didn't mean that!"
15:02:31 <Peaker> scp, the language ain't bad either
15:02:42 <shachaf> tbreisacher: What if I did mean that?
15:02:46 <yitz> shachaf: i think you might be assuming commutativity of (+) though
15:02:49 <shachaf> It seems like a very ad-hoc sort of warning.
15:02:59 <shachaf> yitz: Me?
15:03:07 <shachaf> Oh, @pl does, sure.
15:03:11 <shachaf> But you can do without flip.
15:03:16 <tbreisacher> shachaf: i can't think of a case where you would do it on purpose, though i'm sure someone could contrive one
15:03:24 <yitz> shachaf: with flip you don't need to assume that
15:03:36 <shachaf> yitz: You can do without typing the letters f l i p
15:03:42 <shachaf> For example: f = ap (const (ap (ap (const (+)) (ap (const ((*) 3)) id)))) (ap (const const) id)
15:03:56 <jmcarthur> tbreisacher: do you mean ("string" >>) specifically, or do you mean everything of the form ("string" >>=)?
15:04:15 <jmcarthur> tbreisacher: (note (>>) vs. (>>=))
15:04:21 <shachaf> tbreisacher: Remember, the only case where this wouldn't cause a type error is do-notation where you're working with lists anyway.
15:04:38 <shachaf> If you typed do { "hello"; print "hi" }, that would be a type error.
15:04:41 <yitz> shachaf: yes, the S and K combinators are sufficient, if you are allowed those and not flip
15:04:55 <shachaf> OK, ap isn't in the Prelude.
15:05:00 <shachaf> Or maybe instance Monad (r ->) isn't.
15:05:12 <shachaf> The point is that there's more than one way of doing this, and you can manage without flip.
15:05:13 <tbreisacher> jmcarthur: i'm not sure. maybe it's not worth it
15:05:30 <Peaker> that instance is in Control.Monad.Instances I think
15:05:45 <Peaker> (and in Control.Applicative)
15:05:56 <shachaf> It might be in the GHC Prelude these days.
15:06:19 <jmcarthur> i think it still isn't
15:06:25 <shachaf> It is for me.
15:06:27 <shachaf> But ap isn't.
15:06:58 <jmcarthur> ah, that instance is in GHC.Base now
15:07:18 <jmcarthur> it might not be Haskell 98 or 2010 though
15:07:29 <shachaf> It's not
15:07:43 <shachaf> But who cares about compiling Haskell 2010 compliant programs in GHC, right?
15:07:45 <chexxor_home> dang - I need to consult a GHC dev for this issue - anyone know who I should talk to?
15:07:51 <burbul> I've recently been using the StackExchange site for TeX, and it got me thinking...
15:07:52 <shachaf> #ghc might know about GHC
15:07:53 <Peaker> shachaf, I think if it were in the Prelude it'd contradict the Report?
15:08:04 <chexxor_home> shachaf: ah, I'll check
15:08:05 <shachaf> Peaker: As if they care about that!
15:08:08 <burbul> That site is absolutely fantastic, and I've learned more about Tex in a month of browsing it than several years of thinking about it
15:08:11 <jmcarthur> Peaker: ghc already contradicts the report in other ways
15:08:21 <burbul> (It's also much more helpful than the general stack overflow site)
15:08:40 <burbul> Would you all ever consider setting up a Haskell site?
15:08:52 <jmcarthur> i like haskell being in the main stackoverflow, personally
15:09:00 <jmcarthur> it gets more coverage there
15:09:03 <shachaf> There's already stackoverflow.com/questions/tagged/haskell
15:09:03 <tbreisacher> burbul: only if none of the existing sites had what i wanted
15:09:04 <jmcarthur> and probably more activity
15:09:16 <shachaf> And there's also haskell.org, so we already have a Haskell site.
15:09:44 <quchen> burbul: I'm not sure whether there's enough Haskell demand for that. I participated in the creation of SE.mathematica, and even with its unique situation - namely no good help forum existing at all - it was quite a project.
15:09:53 <burbul> Fair enough.
15:10:03 <jmcarthur> even the gamedev stackexchange gets boring sometimes
15:10:50 <quchen> burbul: Also, I'm not sure whether the admins would like that - Haskell is just some programming language after all. On the other side, Mathematica is much more than just programming, justifying its own section.
15:11:22 <quchen> Getting the 200 votes required for opening it wouldn't be a problem though for the Haskell community
15:11:59 <hiptobecubic> i don't know why you'd want it though
15:12:00 <quchen> But even if everything works out fine - is there really need for a separate subsection? Right now, I'm just filtering for [haskell]
15:13:23 <Iceland_jack> Is there any “show” function that produces a ByteString or Text?
15:13:37 <Iceland_jack> or do I need to run show and then convert
15:13:38 <yitz> Iceland_jack: pack.show
15:13:54 <shachaf> Or encodeUtf8 . show, in the case of ByteString.
15:13:58 <shachaf> Assuming that you're using UTF-8
15:14:01 <burbul> To give you one example, most of the posts on stack overflow are simply tagged [Haskell]
15:14:01 <Iceland_jack> I am
15:14:12 <shachaf> Remember, a ByteString is for bytes, not characters.
15:14:16 <Iceland_jack> I know
15:14:25 <mvj4> @pl f a b = g $ h a b
15:14:25 <lambdabot> f = (g .) . h
15:14:26 <Moggle> Out of curiosity: Integer is arbitrary precision, Int is 32 bit (I think), is there a 16 bit type?
15:14:26 <burbul> Whereas the tex.stackexchange site has very focused, TeX-specific tags.
15:14:32 <burbul> So you can really read up on a particular issue.
15:14:33 <Iceland_jack> It's a bit deceptive how easy it is to work with String in Haskell and what a pain it is once you switch to something usable
15:14:34 <Moggle> Or heck, unsigned integers
15:14:35 <mvj4> haha, I love pl.
15:14:58 <yitz> shachaf: pack.show works for show instances that only use characters in the ascii range, which is usually the case, but you are right
15:15:01 <t4nk724> ?src (elem)
15:15:01 <lambdabot> Source not found. Are you on drugs?
15:15:10 <yitz> shachaf: well no actually
15:15:12 <shachaf> yitz: No, pack :: [Word8] -> ByteString
15:15:21 <shachaf> ByteString.Char8 is a lie
15:15:29 <yitz> shachaf: pack :: Char -> Text
15:15:36 <yitz> shachaf: pack :: [Char] -> Text
15:15:47 <shachaf> Sure. [Char] -> Text and [Word8] -> ByteString
15:16:10 <tbreisacher> Moggle: no unsigned type built-in, as i recall, but you can define one of course
15:16:16 <cmccann> fwiw I'm pretty sure that a separate stackexchange site for haskell would be 1) a bad idea 2) rejected anyway as a subset of SO
15:16:27 <shachaf> Moggle: GHC has a bunch.
15:16:36 <shachaf> Moggle: Int isn't 32 bits.
15:16:36 <yitz> so show already produces text. the problem is with bytestring. you need to decode the text from the show instance.
15:16:50 <quchen> burbul: I see your point. Maybe look for similar proposals a la "Make SE.C++" and see why they don't exist yet.
15:16:52 <shachaf> GHC has Int16, Word16, Int32, Int64, Word32, ...
15:17:07 <quchen> burbul: If by then you're still thinking about SE.Haskell, head over to area51 :-)
15:17:26 <Moggle> shachaf: I may be in love with Haskell then
15:17:35 <Iceland_jack> So “"number " ++ show n” becomes something like “"number " `T.append` (T.pack.show)”
15:17:43 <Iceland_jack> yuck
15:17:44 <shachaf> I hope you learn that language first.
15:17:49 <yitz> Iceland_jack: use the OverloadedStrings extension.
15:17:52 <Iceland_jack> yitz: I am
15:18:04 <Iceland_jack> Did my example not show that?
15:18:18 <shachaf> Iceland_jack: Feel free to define an alias for T.pack . show
15:18:24 <Moggle> How would one define an unsigned integer, out of curiosity?
15:18:24 <yitz> Iceland_jack: but watch out for types with broken instances that can make syntax errors throw runtime exceptions
15:18:54 <Iceland_jack> shachaf: Sure.. but then all the other functions that work on Strings like say printf
15:18:56 <cmccann> burbul, I also suspect that elliott and dmwit would agree with me about a haskell SE site being a bad idea and unlikely to be accepted
15:19:01 <burbul> Hmmm... >This proposal would tend to drain audience from an existing Stack Exchange site.
15:19:14 <burbul> Was used to kill the C++ proposal
15:19:21 <Iceland_jack> The reason Haskell defaults to String is just a historical thing right?
15:19:23 <cmccann> yes, it'd be a pure (ha, ha) subset of SO just like C++ would have been.
15:19:26 <shachaf> Iceland_jack: Well, you're not going to get the efficiency benefits of Text anyway if you keep converting to String.
15:19:28 <burbul> That pretty much damns anything tied to a programming language
15:19:35 <shachaf> Iceland_jack: No, String is very convenient for functional algorithms.
15:19:40 <shachaf> You can build it recursively and what not.
15:19:42 <burbul> It is a shame, as the TeX site has a very different dynamic.
15:19:44 <shachaf> You can share it.
15:19:52 <cmccann> TeX is more than just a programming language, of course.
15:19:53 <burbul> There are people who hang out there and field just about every question
15:19:56 <quchen> burbul: But TeX isn't a programming language.
15:20:01 <burbul> yes
15:20:07 <cmccann> TeX is more like a lifestyle :P
15:20:13 <Iceland_jack> shachaf: Sure.. and this means the entire language is built around an impractical implementation of Strings
15:20:27 <burbul> But I find that the way I think about Haskell is so different to the way I think about C++ that lumping the two together isn't very helpful.
15:20:52 <burbul> What I was trying to say is, the TeX site has an amazing _community_, and I think the reason that is there is because
15:21:03 <shachaf> Iceland_jack: Text isn't good enough to be the default instead of String.
15:21:04 <burbul> its scope is sufficiently circumscribed that individuals can feel they really have a grip on the whole thing.
15:21:08 <cmccann> burbul, look at the people most active in the haskell tag: http://stackoverflow.com/tags/haskell/topusers
15:21:14 <shachaf> String may also not be good enough, but in a different way.
15:21:18 <cmccann> and note how many of them also participate significantly in other tags
15:21:25 <cmccann> (spoiler: most don't)
15:21:38 <yitz> Iceland_jack: i don't think the lack of a built-in alias for pack.show means that the whole language is built around String
15:21:50 <Iceland_jack> yitz: the whole language *is* built around lists though
15:22:02 <yitz> Iceland_jack: lists are good
15:22:13 <burbul> Sorry, I didn't mean to disparage the people who answer things on stackoverflow
15:22:36 <Iceland_jack> Lists are slow, but sure they look elegant since they have a nice inductive definition
15:22:43 <cmccann> burbul, wasn't saying you did. point is, in many ways the [haskell] tag is already its own little community.
15:22:50 <Iceland_jack> this means that efficient things like Data.Map and Data.Set are “second class” in Haskell
15:23:10 <shachaf> Iceland_jack: I wouldn't call Data.Map second-class.
15:23:17 <cmccann> and most people on the "top answerers" list are also very active somewhere else in the haskell community
15:23:22 <Iceland_jack> You need to qualify importing it
15:23:34 <shachaf> So?
15:23:35 <Iceland_jack> and it has no reader syntax
15:23:36 <yitz> Iceland_jack: list are not slow. they are slow when misused. and map and set are not second class, you can easily use them when they are appropriate.
15:23:46 <shachaf> I don't want Data.Map to have reader syntax.
15:23:46 <cmccann> (except maybe hammar, unless he uses some other nick on IRC)
15:24:05 <Iceland_jack> shachaf: That may sound trivial, but it does lead to map being seriously underused in every Haskell tutorial I've seen
15:24:32 <shachaf> Iceland_jack: Well, almost all "Haskell tutorial"s are bad.
15:24:32 <Iceland_jack> Just about the only time they mention Data.Map is when they're introducing it and when they actually want to do associative lookup they just use Data.List.lookup
15:24:34 <mm_freak_> Iceland_jack: lists aren't slow
15:24:39 <shachaf> But I don't think Data.Map belongs in them.
15:24:42 <mm_freak_> they're just not appropriate for many things
15:24:53 <shachaf> Iceland_jack: Lists in Haskell correspond to loops in many other languages.
15:24:58 <shachaf> They're very fundamental.
15:25:16 <Iceland_jack> Yes I know, but for actually storing data linked-lists scale horribly
15:25:19 <cmccann> burbul, anyway, even aside from the "would only drain from SO" aspect, I think you'd have a hard time convincing most of the people who watch the [haskell] tag that a separate site would be a benefit
15:25:25 <yitz> Iceland_jack: Data.List.lookup is the right thing to use in a surprising number of cases where people use dictionary types in some other languages
15:25:35 <mm_freak_> Iceland_jack: they scale best for certain applications
15:25:35 <Iceland_jack> yitz: why is that?
15:25:41 <yitz> Iceland_jack: map is only better than lookup if you have a very large map
15:25:58 <Iceland_jack> That depends on the implementation of map
15:26:04 <mm_freak_> Iceland_jack: lookup for lists has O(1) memory usage
15:26:06 <Iceland_jack> unless you're talking about pee-wee lists
15:26:21 <yitz> Iceland_jack: right pee-wee, like less than thousands
15:26:26 <Iceland_jack> yes
15:26:36 <yitz> Iceland_jack: lookup uses the cache better
15:26:43 <yitz> Iceland_jack: lookup fuses better
15:27:06 <yitz> (and if it doesn't fuse, improve the fusion rules)
15:27:22 <jmcarthur> i don't know about the cache, but the fusion is probably true, but only if you only use the list for that one thing
15:27:40 <jmcarthur> i don't see any reason it would be more cache friendly apart from the fusion though
15:28:00 <burbul> Maybe I should just make a stackoverflow account and ask all the questions I can't find answers to!
15:28:07 <yitz> of course there are plenty of cases where map is better. but it is not as common as you may think. usually it's a premature optimization.
15:28:10 <cmccann> burbul, that is an excellent plan!
15:28:30 <Iceland_jack> yitz: That totally depends on the domain
15:28:36 <cmccann> burbul, questions in the [haskell] tag on SO seem to receive useful answers in less than 20 minutes on average, if memory serves me
15:28:47 <yitz> Iceland_jack: true. s/usually/often/
15:29:00 <cmccann> entirely serious there, I actually checked the average on the SE data explorer site.
15:29:12 <Iceland_jack> managing maps and sets is really painful in Haskell, more painful than it has to be
15:29:14 <burbul> Is there an easy way of filtering things so I only see [haskell] things, and can pretend all the other material isn't there?  (Again not to disparage it... but Haskell is what I want to focus on for now.)
15:29:26 <shachaf> http://stackoverflow.com/questions/tagged/haskell
15:29:32 <quchen> burbul: Search for [haskell]
15:29:44 <mm_freak_> Iceland_jack: i don't find them painful…  why would they be?
15:29:47 <jmcarthur> Iceland_jack: i don't see them as any more painful than in any other language
15:30:01 <Iceland_jack> jmcarthur: What other languages have you been using then?
15:30:06 <jmcarthur> ...
15:30:16 <yitz> Iceland_jack: but since lookup very often is the right tool, and it is conceptually simpler, and it connects in more naturally with other haskell concepts you might want to teach, using lookup rather than map in tutorials makes perfect sense.
15:30:20 <cmccann> shachaf, incidentally, chrome seems to think that URL is the web page I view most frequently
15:30:20 <shachaf> @let (==>) = (,)
15:30:23 <lambdabot>  Defined.
15:30:24 <mm_freak_> Iceland_jack: could you point out a specific pattern that is inconvenient to express in haskell?
15:30:24 <cmccann> can't imagine why
15:30:32 <shachaf> > M.fromList ['a' ==> 1, 'b' ==> 2]
15:30:35 <lambdabot>   fromList [('a',1),('b',2)]
15:30:37 <jmcarthur> ocaml, C, java, ruby, python, javascript, io, others...
15:30:56 <shachaf> cmccann: Hmm, that's true for me too.
15:31:06 <cmccann> jmcarthur, fwiw I like the API for Data.Map much better than the Dictionary<> class in C#.
15:31:14 <shachaf> cmccann: But that's probably because it's one of the only pages I look at in non-incognito mode.
15:32:07 <mm_freak_> Data.Map's API is even far better than the in languages that have a dictionary type builtin like perl and PHP
15:32:15 <Iceland_jack> I'm not talking about the API
15:32:32 <cmccann> shachaf, just keep telling yourself that. in a few months you'll be catching up to elliott on the high score tables.
15:32:41 <Iceland_jack> Taking Python as an example, you don't need to import anything, you don't need qualified names, there is “first-class” syntactic form and it is very easy to add and access elements
15:32:55 <shachaf> cmccann: Eh. I answered a few questions here and there, that's all.
15:33:08 <Iceland_jack> They say that the syntax tells you what is important: function application is short in Haskell because function application is important: f a
15:33:11 <cmccann> shachaf, that's how it always starts
15:33:33 <yitz> shachaf: then, before you know it, you've written an SO bot like cmccann
15:33:36 <cmccann> and in Java nothing is short, which tells you that...?
15:33:40 <Iceland_jack> cmccann: ;)
15:33:41 <mm_freak_> Iceland_jack: python sacrifices a lot of flexibility for saving a few letters in code
15:33:57 <mm_freak_> for example the insertion operation is first class in haskell, which is very useful
15:34:00 <mm_freak_> modify (M.insert k v)
15:34:15 <cmccann> yitz, hammar and daniel fischer are outdoing me these days anyway :[
15:34:33 <shachaf> dons is still at the top.
15:34:38 <yitz> cmccann: i guess their bots are running on faster machines.
15:34:44 <cmccann> shachaf, yeah that's not gonna change any time soon
15:34:48 <shachaf> I think he's answered every question I've asked on SO, and in every case gave an answer that was either wrong or irrelevant.
15:34:51 <Iceland_jack> mm_freak_: I don't agree that it's only about “saving a few letter in code”
15:34:59 <mm_freak_> Iceland_jack: what else?
15:35:13 <shachaf> I think he's way too used to looking for patterns of questions people usually ask, rather than actually reading the question.
15:35:43 <Iceland_jack> mm_freak_: It's an indicator of importance
15:35:43 <yitz> shachaf: he used to be stellar before he went to work for a finance firm
15:35:55 <Iceland_jack> You are OK with maps being the way they are in Haskell, then that's fine
15:35:56 <cmccann> shachaf, he's also mentioned that he tends to answer stuff on SO in spare moments while waiting for compiles or such
15:36:10 <cmccann> so yeah I think he probably jumps the gun on stuff that looks like a familiar question
15:36:13 <cmccann> I've done that a few times
15:36:19 <shachaf> That's no excuse.
15:36:24 <shachaf> I've done it too, but still no excuse.
15:36:39 <mm_freak_> Iceland_jack: Map isn't special, and i don't see why it would need to be…  also there is an important conceptual difference:  python dictionaries are destructive by nature
15:37:29 <mm_freak_> you get crazy in python when trying to express something as simple as:  M.insertWith S.union
15:37:40 <shachaf> @ty (at 'x' ?~ 'y'):: M.Map Char Char -> M.Map Char Char
15:37:41 <roconnor> which web-frameworks supports SSL?
15:37:41 <lambdabot> M.Map Char Char -> M.Map Char Char
15:37:43 <cmccann> Iceland_jack, keep in mind that you could always define your own operators as shortcuts for Data.Map stuff
15:37:44 <mm_freak_> two words in haskell, a whole page of code in python
15:37:54 <Iceland_jack> cmccann: that's not my point frankly
15:37:59 <cmccann> so if you really need it to be convenient for some chunk of code, you can do so.
15:38:05 <Iceland_jack> mm_freak_: The (sad?) thing is how nice Haskell is while you stay in a certain bubble but then it stops being as crisply designed
15:38:11 <jmcarthur> Iceland_jack: by your reasoning, doing anything complicated with maps in python is not "important"
15:38:29 <Iceland_jack> jmcarthur: Do you think that's my argument?
15:38:57 <jmcarthur> Iceland_jack: "It's an indicator of importance"
15:38:59 <Peaker> Did anyone measure destructive hash table performance, compared with (Map Word64)?  IntMap is too small for me, my keys are Word64 :(
15:39:01 <mm_freak_> roconnor: i think none of them support that directly, because they assume that you put something in front of them like nginx
15:39:02 <cmccann> Iceland_jack, if your point is that key-value maps aren't especially important in haskell then you're correct, and in fact they shouldn't be
15:39:23 <roconnor> mm_freak_: what is nginx?
15:39:38 <Iceland_jack> cmccann: And that's just, like, your opinion man
15:39:40 <mm_freak_> roconnor: similar to lighttpd, just more flexible and probably even faster
15:39:44 <Peaker> I'm suspecting that a hash table behind the ugly-memo package could yield significantly better performance than a Map Word64
15:39:58 <Iceland_jack> jmcarthur: Do you not agree that it's an indicator of importance?
15:39:59 <yitz> Peaker: you mean the sign bit? so cast them to Ints
15:40:06 <roconnor> I thought lighttpd was a webserver.
15:40:24 <cmccann> Iceland_jack, it's my well-informed opinion after spending a fair amount of time in languages with very different attitudes toward such things
15:40:28 <jmcarthur> Iceland_jack: i do not agree at all, but that's not the point of what i said
15:40:31 <cmccann> languages like python got it wrong here
15:40:35 <Peaker> yitz, Nah, I mean Int can be 32-bits, but I need Word64
15:40:40 <Peaker> yitz, (or even smaller)
15:40:41 <roconnor> wait, don't these webframeworks come with HTTP servers.  I thought that was the whole point of snap
15:40:46 <mm_freak_> Iceland_jack: dictionaries are just as important in haskell as they are in python…  it's supposed-importance, not real importance
15:40:49 <shachaf> roconnor: I think the idea is that instead of supporting SSL directly, you let a different web server do the SSL and forward the requests to you.
15:40:59 <yitz> Peaker: oh you're on 32-bits.
15:41:07 <burbul> Well -- there we go. I've asked my first stackoverflow question!
15:41:07 <Peaker> yitz, or rather, I'd like to have support for 32-bits
15:41:13 <mm_freak_> Iceland_jack: it's just that Data.Map isn't any more important than Data.HashMap, Data.List or another implementation
15:41:14 <Peaker> yitz, (despite working with a Word64 file format)
15:41:16 <Iceland_jack> mm_freak_: So you wouldn't say lists are relatively more important than dictionaries in Haskell than they are in Python?
15:41:25 <mm_freak_> Iceland_jack: no
15:41:25 <cmccann> Peaker, IntMap (IntMap a)? :P
15:41:33 <shachaf> burbul: Oh boy, your first question's going to be closed.
15:41:37 <roconnor> shachaf: I'm pretty ignorant about web thingies, but that sounds ridiculously stupid.  What is the point of using Snap if a proxy is going to slow you down?
15:41:38 <jmcarthur> Iceland_jack: if being able to express something concisely is an indicator of importance, then the inability of python to express map operations as concisely as haskell can must indicate that that is not important
15:41:59 <Iceland_jack> jmcarthur: I'm not saying it's decisive but it certainly is an indicator
15:42:01 <shachaf> roconnor: This is fairly standard as far as I know.
15:42:02 <Peaker> cmccann, A Word64 might require 3 Ints, and the performance of 3 nested IntMaps is likely to be abysimal, might as well "Map" :)
15:42:09 <roconnor> shachaf: O_o
15:42:19 <yitz> Peaker: bummer. i wonder if IntMap . IntMap is fast. probably not. :(
15:42:29 <burbul> shachaf: I searched very hard for duplicates
15:42:33 <Twisol> this is bikeshedding if I've ever seen it
15:42:35 <burbul> Or is it that it is considered subjective?
15:42:37 <shachaf> roconnor: For a large website you probably have multiple web servers and requests being forwarded to them anyway.
15:42:42 <cmccann> Peaker, oh yeah the signedness makes things awkward
15:42:53 <Iceland_jack> E.g. Haskell puts a heavy emphasis on lists like mentioned above: that's why it has special reader syntax, that's why it has special showList syntax, that's why its constructor is only a single character, ...
15:42:56 <shachaf> burbul: I'm no expert. cmccann would probably know whether it should be closed.
15:42:56 <jmcarthur> Iceland_jack: of course complicate map operations are important, yet python gets this wrong anyway, therefore, the claim about importance must not actually be 100% true.
15:42:58 <mm_freak_> Iceland_jack: i think it isn't an indicator of importance at all…  it rather indicates the language designers' inspiration
15:43:04 <jmcarthur> *complicated
15:43:08 <mm_freak_> python is inspired by other imperative languages
15:43:09 <burbul> But I don't understand on what grounds it's going to be closed?
15:43:15 <roconnor> shachaf: mm_freak_: Thanks
15:43:17 <shachaf> burbul: I might be wrong.
15:43:22 <cmccann> burbul, too open-ended and subjective.
15:43:28 <mm_freak_> hence it generalizes array syntax to dictionary syntax and allows a few new things
15:43:34 <mm_freak_> python measures its power in terms of features
15:43:37 <cmccann> a question like "is there a canonical, official style guideline" would be one thing
15:43:49 <Peaker> Iceland_jack, it could possibly be nice to use a "Stream" rather than a list seamlessly, for when you want to assert "this doesn't keep a linked list in memory"
15:43:53 <cmccann> burbul, or even about something specific, like the question you link to
15:44:09 <Peaker> yitz, there's some fast hash table implementation on hackage, surely
15:44:11 <cmccann> but a general "what guidelines exist?" is likely to be closed as "not constructive"
15:44:21 <jmcarthur> Peaker: hashtables
15:44:23 <yitz> cmccann: http://www.haskell.org/haskellwiki/Category:Style
15:44:27 <cmccann> which is basically SO-speak for "does not have a single clear-cut answer possible"
15:44:28 <shachaf> Hmm... I wonder how much better data Stream a = Cons a (Stream a) would perform than lists, given that GHC can CPR it.
15:44:31 <Peaker> jmcarthur, destructive updates?
15:44:35 <jmcarthur> Peaker: yes
15:44:36 <shachaf> Would it make a difference?
15:44:36 <burbul> Hmmm... that feels a bit silly to me. Any language community builds up a certain folk knowledge about how things are set out.
15:44:36 <cmccann> yitz, I'm not the one asking :P
15:44:39 <Peaker> jmcarthur, great :)
15:44:43 <shirt> How do I use the finally function in MonadIO?
15:44:57 <mm_freak_> shachaf: naive list processing code is going to be slower for [] than for Stream
15:44:59 <burbul> E.g. for C++ I could tell you the one or two ways things are usually laid out.
15:45:12 <Peaker> I think I might make a hashtables-based ugly-memo derivative
15:45:14 <cmccann> burbul, yes, this is a matter of how SO works, not the haskell community
15:45:18 <monochrom> MonadIO does not support finally. try the package monad-control
15:45:21 <shachaf> mm_freak_: Right.
15:45:27 <mm_freak_> however, if you express your list operations in terms of existing functions chances are you get rid of intermediate lists, so [] can perform better in certain cases
15:45:32 <jmcarthur> Peaker: value or identity memoization?
15:45:37 <yitz> cmccann: anyway that was sort of tongue in cheek. that collection of style articles is eclectic and not well maintained. hardly "standard". but that's what we've got.
15:45:37 <cmccann> burbul, asking the same question on the haskell reddit would go over better, I expect
15:45:44 <Peaker> jmcarthur, value memoization behind unsafePerformIO
15:45:56 <burbul> Hmm... this is exactly the kind of question I can ask on the tex site! Ah well.
15:46:04 <jmcarthur> Peaker: alright, just making sure, since i already have an identity memo package based on the same idea
15:46:05 <Peaker> jmcarthur, many memoizers use thunk trickery to get the desired effect, but I think an explicit unsafePerformIO memo provides more fine-grained control that is desirable
15:46:19 <jmcarthur> Peaker: i know all about it :)
15:46:21 <Peaker> (not to mention that the thunk trickery seems fragile)
15:46:31 <cmccann> burbul, yes, and stuff like this is what falls through the cracks because a haskell-specific SE site isn't viable overall. sorry!
15:46:35 <yitz> Peaker: unordered-containers doesn't work for you?
15:46:44 <shachaf> I consider that question not useful.
15:46:45 <Peaker> yitz, what does it give me here?
15:46:53 <jmcarthur> Peaker: a benefit of the unsafePerformIO stuff is that you don't have to have a way to come up with every answer "in advance"
15:47:01 <shachaf> Indentation is one of the worst topics of anything.
15:47:06 <Moggle> Can someone explain the value of fix to me, I just read the haskell wiki article on it and made filter' with a lambda function and I don't see why it's valuale
15:47:08 <burbul> Well, there we go.
15:47:17 <shachaf> Moggle: There's no value to it.
15:47:18 <jmcarthur> Peaker: and you can also retire entries that haven't been used in a while
15:47:21 <Moggle> is it more valuable as a mathematical thing than an actual program thing?
15:47:24 <Moggle> ah, good to know shachaf
15:47:26 <Moggle> :D
15:47:32 <Peaker> yitz, destructive updates are important for a performant insert with a hash-table, I believe
15:47:32 <mm_freak_> Moggle: depends on your coding style
15:47:40 <jmcarthur> Peaker: and for identity memoization, you can even retire entiries by sticking finalizers on the keys
15:47:40 <Peaker> jmcarthur, yeah, indeed
15:47:41 <shachaf> Moggle: It's useful in some cases, but it doesn't give you magic powers that you can't get with recursion.
15:47:42 <mm_freak_> Moggle: some people never use fix, some use it all the time (me)
15:47:44 <cmccann> shachaf, I dunno, indentation style is pretty consistent in haskell from what I've seen
15:47:48 <jmcarthur> *entries
15:48:00 <shachaf> You can say things like do { ...; fix $ \again -> do { ...; when something again }; ... }
15:48:06 <yitz> Peaker: a hash-based dictionary type that is fast. and the hashable package, if you want to roll your own.
15:48:09 <cmccann> shachaf, everyone hates tabs, even people who prefer them in other languages, and there are only a few styles that people disagree on
15:48:09 <monochrom> fix: see my http://www.vex.net/~trebla/haskell/fix.xhtml
15:48:18 <shachaf> cmccann: dmwit likes tabs.
15:48:32 <Peaker> yitz, hashtables has an IO one that sounds good
15:48:39 <Peaker> I'm rehauling the "dwarf" package
15:48:49 <cmccann> shachaf, ok... so there are a few crazy people, that's probably inevitable.
15:48:58 <jmcarthur> Peaker: make sure you at least try unordered-containers. it has a reasonably performant purely functional hash table
15:49:09 <Peaker> Once I get a nicer, faster dwarf API -- I can use it to make super-nice FFI generators :)
15:49:10 <Peaker> (instead of the horrid hsc2hs)
15:49:11 <shachaf> cmccann: That's how it starts.
15:49:15 <jmcarthur> Peaker: still not as fast as the destructive ones though
15:49:32 <cmccann> shachaf, heh
15:49:44 <Peaker> jmcarthur, is it faster than a Map?
15:49:54 <jmcarthur> Peaker: depends on the data, but generally yes
15:49:59 <Peaker> jmcarthur, my keys are already integral
15:50:14 <Peaker> so I am guessing the main benefit over Map is probably not there
15:50:19 <Peaker> (since it must be using logarithmic trees behind the scenes)
15:50:26 <Peaker> (for pure updates)
15:50:53 <jmcarthur> no
15:50:57 <jmcarthur> well, sort of
15:51:01 <jmcarthur> it's using something similar to IntMap
15:51:39 <jmcarthur> i'm guessing you are on a 32 bit machine, otherwise intmaps could store your Word64 keys anyway
15:51:48 <jmcarthur> but the hash function should get that for you anyway
15:51:52 <Moggle> monochrom: a good read, I guess I can kind of see the use
15:52:34 <yitz> Peaker: for a while u-c was better maintained than hts. but i think greg may be more active again now.
15:52:35 <Peaker> jmcarthur, I want my code to work with 32-bit/64-bit machines
15:53:11 <jmcarthur> in any case, if you are using the unsafePerformIO trick, you might as well just use destructive hash tables
15:55:16 <mm_freak_> :t M.fromListWith (M.unionWith (+)) . liftA2 zip id (map (flip M.singleton 1) . tail)
15:55:17 <lambdabot> (Num a, Ord k) => [k] -> M.Map k (M.Map k a)
15:55:25 <mm_freak_> follower frequencies…  do that in python =)
15:55:47 <mm_freak_> > M.fromListWith (M.unionWith (+)) . liftA2 zip id (map (flip M.singleton 1) . tail) $ "testx"
15:55:48 <lambdabot>   fromList [('e',fromList [('s',1)]),('s',fromList [('t',1)]),('t',fromList [...
15:55:55 <monochrom> make sure your choice of hash table is really fast enough for you. do not assume. test.
15:57:48 <Peaker> monochrom, I will... still much work prior to that
15:58:03 <Peaker> I wonder if it will be acceptable to switch from hsc2hs to debug-info-based code-generators for FFI
15:58:26 <Peaker> Because some platforms may not have DWARF, or maybe it's bad to have to build the FFI target first
15:59:09 <monochrom> that may be a clever way
15:59:25 <Peaker> I know it's safer in the sense that hsc2hs may have a different preprocessor context -- or different compilation flags (e.g: in a cross-compile env), meaning that it may not have binary compatibility with the actual C interface
15:59:58 <Peaker> But on a pure win32 env (not cygwin) or other platforms, you might need to use files generated from other platforms (unsafe?)
16:00:25 <Peaker> or maybe it can generate hsc (for other platforms) and hs code (guaranteed to work with the specific platform)
16:00:51 <monochrom> is mingw sufficient? ghc comes with mingw or a significant part of mingw
16:01:49 <Peaker> monochrom, I think so, since it has gcc, and I believe gcc always knows ot make DWARF debug info
16:11:07 <hpaste> HK pasted “modules in Haskell” at http://hpaste.org/79326
16:12:02 <HK_> Is it possible to use modules in Haskell to specialize a type? e.g. http://hpaste.org/79326
16:16:12 <parcs> that should work
16:16:44 <HK_> parcs: it does not unfortunately!
16:17:15 <parcs> what's the error?
16:17:23 <Peaker> HK_, module B needs to export (T, A.T(..))
16:17:30 <Peaker> HK_, not sure if you can export a qualified name like that
16:17:48 <Peaker> HK_, as it is, module B is exporting just the type synonym
16:17:49 <parcs> oh, you're doing module B (T(..)) but T is not an ADT
16:18:36 <parcs> you should do module B (T, A.T(T)), i think
16:18:46 <parcs> er, A.T(A.T)
16:19:20 <HK_> ?
16:19:29 <HK_> A.T(A.T) ?
16:19:44 <Peaker> why not A.T(..) ?
16:19:57 <HK_> I got "Conflicting exports for `T':" when I tried "module B (T(..),A.T(A.T)) where"
16:20:27 <HK_> *I got "Conflicting exports for `T':" when I tried "module B (T(..),A.T(..)) where"
16:20:45 <Peaker> Yeah, you can't export a data constructor without also exporting the type
16:21:05 <Peaker> so you can't really export both the data constructor and the type alias for it under the same name as the type
16:21:17 <HK_> Ok, then how can I specialize it?
16:21:40 <Peaker> HK_, you can give one of the generic/specialized ones a different type name (can keep data constructor name)
16:21:46 <X-suriV> grrr...are there any Haskell GUI coding packages that arent a complete trainwreck to try and get working unlike wx? :P
16:21:59 <parcs> why not just write 'T Int' inline
16:22:01 <Peaker> X-suriV, how's gtk2hs?
16:22:49 <HK_> parcs, I don't want to change the interface of a library
16:23:05 <HK_> users should see T
16:23:13 <HK_> and  their code should not break
16:23:29 <X-suriV> ah ill have to try that one
16:23:44 <parcs> HK_: ah, then rename 'data T'
16:23:55 <parcs> and keey 'type T = InternalT Int' or something
16:23:57 <parcs> keep
16:25:55 <parcs> data InternalT a = T a, type T = InternalT Int
16:26:39 <Peaker> data TG a = ...
16:26:45 <Peaker> "G" is a common suffix for the "generic" version
16:27:47 <parcs> y
16:28:02 <parcs> yesod uses G as a prefix to mean generic
16:29:53 <HK_> type of the data constructor 'T' as seen by the user is now 'T:: a ->TG a' instead of 'T :: Int -> T'
16:30:32 <kqr> does ghci actually compile modules you load or is it interpreting them?
16:31:40 <parcs> HK_: right, doesn't break compatability though
16:31:52 <HK_> True
16:31:55 <HK_> am I the only one missing ML's module system?
16:33:55 <parcs> kqr: ghci compiles source to bytecode and then interprets that. it can use precompiled object files if possible
16:34:20 <parcs> if applicable, i should say
16:34:46 <hpc> if they already exist
16:34:59 <kqr> parcs, oh
16:35:11 <hpc> and then everything gets linked together before running, too
16:35:30 <kqr> parcs, is the code compiled differently with ghc --make? (i.e. to native code)
16:35:54 <monochrom> these days "--make" is redundant
16:36:01 <kqr> sure
16:36:12 <shachaf> "--make" does not mean "to native code"
16:36:45 <monochrom> then the answer is yes
16:36:58 <kqr> monochrom, so byte code is only really used with ghci?
16:37:05 <monochrom> yes
16:37:18 <parcs> it's used with ghci and a metaprogramming extension called Template Haskell
16:37:38 <kqr> i haven't ventured that far yet
16:37:52 <monochrom> see GHC user's guide section 2.3
16:38:43 <kqr> will do!
16:39:13 <Moggle> @pl (\n -> sum (divisors n) > n)
16:39:14 <lambdabot> (>) =<< sum . divisors
16:39:27 <Moggle> oh sweet jesus I have no idea how that works or means
16:39:32 <Moggle> alright, sticking with my version
16:39:54 <kqr> monochrom, do you know if there's an edition of the user's guide all in one large document?
16:40:31 <monochrom> yes, there is a pdf file, likely on your hard disk
16:41:10 <monochrom> it certainly is on mine, right out of the box
16:42:34 <kqr> brilliant
16:43:06 <shachaf> monochrom: You got GHC in a box?
16:43:17 <kqr> that would be cute
16:43:24 <kqr> i can just imagine the unboxing videos on youtube
16:43:28 <monochrom> yeah! I bought it at Walmart!
16:44:47 <aristid> monochrom: did you get it in a bundle with linux washing powder?
16:45:24 <monochrom> no
16:46:29 <fryguybob> monochrom: Did the box have this on it? http://www.haskell.org/wikiupload/8/85/NarleyYeeaaahh.jpg
16:46:48 <monochrom> haha
16:52:47 <Peaker> oops, all this time I was connected via phone tethering.. killing its battery :)
16:54:06 <shachaf> I like how lens has "traverse", "traversed", "itraverse", and "itraversed".
16:54:30 <shachaf> "traversed" is indexed, by the way.
16:54:36 <shachaf> (But it's just indexed with Int.)
16:54:57 <johnw> Peaker: been there, done that
16:55:09 <johnw> i've had CrashPlan spend hours backing up through my tethered connection
16:55:09 <johnw> oops
16:55:31 <Peaker> johnw, ouch.. esp. if limited data plan
16:55:37 <johnw> and it was
16:56:10 <shachaf> Limited or throttled-past-a-certain-point?
16:56:21 <shachaf> Hmm, this sounds like a #-blah topic.
16:57:40 <Twisol> I hear the term "indexed" occasionally. What does that mean?
16:57:54 <shachaf> It means a few different things.
16:58:14 <shachaf> In "lens" we've been considering renaming it to avoid the naming conflict. Maybe to "keyed".
16:58:29 <shachaf> @ty traverse
16:58:31 <lambdabot> (Applicative f, Traversable t) => (a -> f b) -> t a -> f (t b)
16:58:32 <shachaf> @ty traversed
16:58:34 <lambdabot> (Applicative f1, Traversable f, Indexable Int k) => k (a -> f1 b) (f a -> f1 (f b))
16:58:35 <shachaf> @ty itraverse
16:58:36 <lambdabot> (Applicative f, TraversableWithIndex i t) => (i -> a -> f b) -> t a -> f (t b)
16:58:37 <shachaf> @ty itraversed
16:58:39 <lambdabot> (Applicative f1, TraversableWithIndex i f, Indexable i k) => k (a -> f1 b) (f a -> f1 (f b))
16:59:05 <hpc> Twisol: in veeeeery broad terms, "that indexed by this" means "that depends on the value of this"
16:59:29 <Twisol> …so (a -> b)?
16:59:39 <hpc> or like an array indexed by int
17:00:04 <hpc> in dependently typed languages like agda, you have indexed types
17:00:16 <hpc> so a fixed-length array can be defined as the type (Vec A n)
17:00:21 <hpc> where n is a natural number of some sort
17:00:29 <hpc> [] :: forall a. Vec a 0
17:00:30 <hpc> etc
17:00:44 <hpc> it's a flexible term
17:00:49 <Twisol> I see.
17:02:56 <coleman-> I am trying to wrap a C function that accepts a callback and calls it with every window on the desktop as argument. I want to pass haskell function to it (I know how to do that), and build a list of window handles. is that even possible?  since as far as I can see it would require mutation
17:03:14 <shachaf> Haskell supports mutation.
17:03:14 <lambdabot> shachaf: You have 1 new message. '/msg lambdabot @messages' to read it.
17:03:18 <johnw> yes
17:03:27 <johnw> not only is it possible, it's somtehnig I'm doing as we speak :)
17:03:42 <coleman-> good to hear. so what should I look into
17:03:47 <johnw> coleman-: are you familiar with hsc2hs and Bindings-DSL?
17:03:48 <shachaf> That depends on the API.
17:03:57 <coleman-> johnw I am not
17:04:26 <johnw> ok, if you only need to do this for a small set of functions, you can directly use the Haskell FFI
17:04:34 <shachaf> You don't need hsc2hs and Bindings-DSL!
17:04:37 <johnw> if you need to do it for many, the above tools are far superior
17:04:44 <johnw> so which is your case?
17:04:47 <shachaf> First you should understand how the FFI works.
17:04:50 <coleman-> I am using haskell FFI directly for now. it's the mutating part that got me thinking
17:05:02 <shachaf> Tools are good but you should understand what they do first.
17:05:07 <Moggle> Question: if Haskell has to generate a new object every time you say, insert into a map, how does that manage to be space efficient?
17:05:10 <johnw> ok, so, first you need to create the callback
17:05:13 <shachaf> coleman-: Anyway, as I said, it depends on the API.
17:05:16 <johnw> let me show you what that looks like:
17:05:21 <Moggle> Does the new map created when you insert a value like... use the data of the old map?
17:05:27 <Moggle> Or... kind of not understanding here
17:05:33 <coleman-> here is what I have for now, it prints each handle
17:05:42 <shachaf> Moggle: It shares most of the old map, yes.
17:05:55 <hpaste> johnw pasted “callback.hs” at http://hpaste.org/79327
17:05:58 <shachaf> coleman-: I'm asking what API Win32 is giving you.
17:06:05 <johnw> that's a template you can use
17:06:08 <shachaf> This really affects how to write your code.
17:06:15 <shachaf> You should see "wrapper" as a last resort here.
17:06:21 <johnw> i meant CInt in two places there, not In
17:06:23 <johnw> Int
17:06:27 <shachaf> It's a big hassle and if Windows lets you pass a pointer instead, you should do that.
17:06:49 <coleman-> http://hpaste.org/79328
17:06:58 <Moggle> shachaf: but if the map is rebalanced when I insert a value, doesn't that sort of...well, I want to say waste lots of memory
17:07:13 <johnw> so, you use mk'... to wrap a Haskell callback to pass to a C function which takes FunPtr
17:07:28 <johnw> you use mK'... to accept a callback from C and make it callable as a Haskell function
17:07:31 <shachaf> See, you don't need "wrapper" here.
17:07:33 <coleman-> HWND and LPARAM is a void pointers, BOOL is CInt
17:07:42 <coleman-> are*
17:07:44 <shachaf> "wrapper" will give you a headache because you'll have to deal with manual memory management. I don't recommend it.
17:07:51 <johnw> yep
17:07:57 <johnw> see that FunPtr argument?
17:07:58 <shachaf> Just use the LPARAM.
17:08:03 <Jafet> Moggle: how much memory is wasted?
17:08:12 <johnw> apply its type to the template I pasted
17:08:20 <shachaf> Moggle: The old map can be GCed.
17:08:20 <Moggle> Jafet: depends on tree size, but I was thinking more "what if I insert multiple values"
17:08:34 <johnw> Moggle: it shares data with the old map generally
17:08:44 <johnw> Moggle: but it all depends on which map you're using, and how it was implemented
17:08:45 <coleman-> shachaf oh you mean pass haskell list as lparam?
17:08:50 <Jafet> Moggle: how much memory do you think is wasted?
17:08:59 <shachaf> coleman-: No, I mean pass a pointer as the LPARAM.
17:09:17 <coleman-> point to a haskell list?
17:09:17 <shachaf> A pointer to a Haskell value. You can do that, I think, right?
17:09:25 <shachaf> Er, to a Haskell mutable variable.
17:09:40 <coleman-> I don't think so. enumWindows doesn't accept any arguments besides the function pointer
17:09:50 <shachaf> coleman-: And the LPARAM.
17:09:57 <shachaf> http://msdn.microsoft.com/en-us/library/windows/desktop/ms633497(v=vs.85).aspx
17:10:05 <coleman-> yes you're right
17:10:29 <coleman-> and what would the mutable haskell type be?
17:10:33 <shachaf> IORef? MVar?
17:10:38 <shachaf> I don't know. Probably IORef.
17:10:49 <Moggle> shachaf: thinking about it... maybe not a whole lot
17:10:51 <shachaf> You can also explicitly malloc an Int and then use a pointer to that.
17:11:07 <Moggle> Sharing memory seems like the compiler for Haskell must be throwing pointers around like mad.
17:11:14 <Moggle> gosh, I should go find the ghc source code
17:11:15 <shachaf> coleman-: The alternative is to actually generate code at runtime with "wrapper".
17:11:19 <shachaf> But that's kind of crazy.
17:11:21 <Moggle> it'd be fascinating
17:11:24 <shachaf> And a hassle
17:11:28 <Jafet> @google stg
17:11:30 <lambdabot> http://www.stginc.com/
17:11:30 <lambdabot> Title: STG, Inc. Customer focused, Performance based
17:11:32 <shachaf> This is a low-level API -- use it as it's meant to be used.
17:11:32 <Jafet> @where stg
17:11:32 <lambdabot> http://citeseer.ist.psu.edu/viewdoc/summary?doi=10.1.1.53.3729
17:12:47 <Jafet> You can easily measure memory usage, by using GHC's profiling options. Knowing about STG doesn't matter.
17:13:01 <coleman-> you said or using malloc to allocate the buffer manually. isn't Data.IORef safer and nicer to use?
17:13:14 <shachaf> coleman-: Probably.
17:13:29 <shachaf> I just am not certain how to use it with LPARAM, though you can probably work it out.
17:13:55 <coleman-> I thought I don't even need to mess around with void *. can't I just close over it with haskell function
17:14:15 <shachaf> coleman-: You can, but Win32 doesn't know how to call Haskell closures.
17:14:31 <shachaf> So if you're interfacing directly with Win32, you'll have to do it yourself.
17:14:42 <shachaf> "wrapper" is one way -- it actually generates machine code at runtime.
17:16:34 <jpat> Hello
17:16:56 <jpat> Anyone here?
17:17:04 <shachaf> There is only silence and some second-hand clothes.
17:17:30 <jpat> I have a Haskell question, would this be the place to ask?
17:17:37 <johnw> jpat: you bet!
17:18:05 <johnw> coleman-: in general with FFI I use "alloca" or "malloc", depending on the lifetime required
17:18:07 <jpat> What is the '!!' operator and when is it used?
17:18:10 <Rotaerk> this is actually a C# channel disguised as a haskell channel
17:18:17 <johnw> jpat: it's the list index operator
17:18:19 <Rotaerk> you want ##csharp for your haskell questions
17:18:22 <johnw> > [1,2,3] !! 1
17:18:24 <lambdabot>   2
17:18:30 <Jafet> It is the list index operator and it is used more often than it should be.
17:18:44 <jpat> okay, thanks
17:18:53 <shachaf> jpat: Do you know about Hoogle? It's a good way to answer questions like this.
17:18:55 <shachaf> @where hoogle
17:18:56 <lambdabot> http://haskell.org/hoogle
17:19:06 <jpat> Also when do you use lambda expressions over recursive ones or other?
17:19:18 <johnw> jpat: i don't understand what you mean
17:19:26 <jpat> hmmm
17:19:32 <jpat> When do you use lambda expressions?
17:19:42 <johnw> when i don't want to bother naming a function
17:19:42 <Jafet> Whenever you feel like it.
17:20:09 <johnw> jpat: and lambdas can be made recursive too, using the fix combinator
17:20:10 <shachaf> When you want better inlining!
17:20:37 <jpat> alright thanks
17:20:40 <shachaf> foo = \x -> ...foo... -- whether this is recursive or not is an argument (and a silly one at that)
17:20:48 <jpat> I wasnt sure if there was a time where they were mandatory
17:20:51 <Jafet> I'm not sure if that answer is in line with the question
17:20:57 <johnw> foo = fix $ \f x -> ...f...
17:21:36 <jpat> what is that line doing
17:21:38 <jpat> ?
17:21:50 <shachaf> You shouldn't worry about it.
17:21:56 <Jafet> Something silly
17:21:57 <johnw> i would agree with shachaf
17:22:03 <Jafet> foo x = ...foo...
17:22:16 <johnw> jpat: http://newartisans.com/2012/09/the-fix-combinator-and-recursive-lambdas/ for more info, if interested
17:22:25 <jpat> thanks!
17:23:07 <jpat> is !! called the 'infix' operator?
17:23:15 <Jafet> fix is the least-fixed-point combinator. It is used way more egregiously than (!!).
17:23:19 <johnw> it's not "the" infix operator
17:23:24 <johnw> but !! is an infix operator
17:23:51 <coleman-> I've always been told that you can't mutate things in haskell, now it seems you can.
17:24:07 <coleman-> is mutation actually happening or there's some magic going on?
17:24:07 <jpat> oh yea...wow nvm infix just means between two operands
17:24:16 <Jafet> All binary operators are infix.
17:24:17 <shachaf> coleman-: It's actually happening, if you're using IORef.
17:24:41 <coleman-> yes I'm using it
17:24:49 <childish_scribbl> what does "()" mean in haskell
17:24:51 <Jafet> coleman: is that a theological question
17:25:00 <shachaf> childish_scribbl: Look it up on Hoogle. :-)
17:25:03 <shachaf> @where hoogle
17:25:04 <lambdabot> http://haskell.org/hoogle
17:25:07 <Jafet> @hoogle ()
17:25:07 <lambdabot> Control.DeepSeq rnf :: NFData a => a -> ()
17:25:08 <lambdabot> Data.Monoid mempty :: Monoid a => a
17:25:08 <lambdabot> Data.Generics.Builders empty :: Data a => a
17:25:18 <shachaf> OK, never mind.
17:25:24 <shachaf> For once a case where Hoogle isn't useful.
17:25:28 <coleman-> so writing this function should be easy, as soon as I figure out how to properly pass my function to C api (or how to pass ioref as void *). a bit of a shame that you can't just pass haskell function directly to a C function and have ffi do all the work. maybe in future..
17:25:34 <johnw> () is the unit type, and the unit value
17:25:50 <johnw> it is a type which contains only one value
17:25:57 <shachaf> coleman-: That's what import "wrapper" does. But it has to do some dirty magic to make it work.
17:26:05 <johnw> well, and undefined
17:26:07 <shachaf> There's a fair amount of overhead to this magic.
17:26:48 <coleman-> johnw you are talking about wrapper's magic being undefined or?
17:27:05 <shachaf> No, he's in a different conversation.
17:27:11 <johnw> coleman-: no, I meant that the type () contains the values () and undefined
17:27:13 <deech> Is there a cabal config flag that keeps the source and links the haddocks to it?
17:27:25 <johnw> deech: yes
17:27:30 <coleman-> good thing I found about IORef so late, I would have abused it many times when I was starting out :)
17:27:31 <johnw> --haddock-hyperlink-source
17:27:45 <johnw> coleman-: I have yet to use IORef even once :)
17:27:46 <deech> johnw: Doesn't that require that I have the source?
17:27:56 <johnw> deech: how are you installing without having source?
17:28:06 <johnw> when you cabal install, source passes through your machine
17:28:19 <jpat> Is there a command I can use so that I can step through Haskell function calls to prepare for my test?
17:28:23 <shachaf> I'm actually not sure what the right answer for passing an IORef to C as a void * is.
17:28:26 <jpat> Or a site that better explains it?
17:28:33 <johnw> jpat: there is the Hat tracer, which is quite nice
17:28:35 <shachaf> Since the IORef could be a closure too, of course.
17:28:42 <jozefg> Random Question: Why are functional dependencies necessary for multiparameter type classes?
17:28:48 <shachaf> jozefg: They're not.
17:28:59 <deech> johnw: So I can give the `--haddock-hyperlink-source' to `cabal install'?
17:29:03 <johnw> deech: yes
17:29:06 <Jafet> MPTCs tend to be necessary to use fundeps.
17:29:07 <jozefg> shachaf: so when are they necessary?
17:29:12 <deech> johnw: Is there a config file flag?
17:29:17 <johnw> deech: sadly, no
17:29:26 <johnw> deech: I have a "cabal" wrapper which adds it to my every install command
17:29:37 <deech> johnw: Ah, that makes sense.
17:29:40 <jpat> John idk how to ask this directly to you, but what is the command?
17:29:41 * hackagebot jmacro 0.6.3 - QuasiQuotation library for programmatic generation of Javascript code.  http://hackage.haskell.org/package/jmacro-0.6.3 (GershomBazerman)
17:29:46 <shachaf> jozefg: When you want to specify that one thing depends on something else. :-)
17:29:58 <deech> johnw: Thanks!
17:32:17 <Jafet> alias cabal-install='cabal install --enable-library-profiling --enable-tests --haddock-hoogle --haddock-html --haddock-executables --haddock-internal --haddock-hyperlink-source'
17:32:20 <jozefg> shachaf:  Haha so if we had RandomMPTC a b | a->b        then we couldn't have both RandomMPTC Int Double and RandomMPTC Int Int?
17:32:47 <shachaf> jozefg: Correct.
17:38:10 <jozefg> but MPTC's are still non standard aren't they?
17:38:28 <shachaf> Correct.
17:38:29 <coleman-> one thing I did not mention because I thought I would figure it out myself is that the code I pasted is crashing haskell with "Process haskell exited abnormally with code 5" error, after all the handles are printed. any idea what is going on?   http://hpaste.org/79328
17:39:05 <shachaf> coleman-: You've decided to use "wrapper" after all?
17:39:24 <shachaf> Please make sure you know how "wrapper" works first. For example, you need to manually free a "wrapper" function when you're done with it.
17:39:28 <coleman-> I don't know how to make it compile without wrapper
17:39:51 <coleman-> but could not freeing it cause a crash?
17:39:57 <shachaf> Probably not.
17:40:17 <shachaf> Your type for EnumWindows is still wrong.
17:41:37 <coleman-> oops
17:41:41 <shachaf> I think that *might* be OK with stdcall, though?
17:41:46 * shachaf has never used Win32.
17:41:50 <coleman-> lets see
17:42:40 <coleman-> yes that was it.
17:43:20 <shachaf> You could try using StablePtr instead of "wrapper"
17:43:23 <shachaf> http://www.haskell.org/ghc/docs/latest/html/libraries/base/Foreign-StablePtr.html
17:43:34 <coleman-> wrapper makes closing over a variable just work. nice
17:43:38 <shachaf> It still requires manual memory management but there's probably not much you can do about that.
17:44:09 <slack1256> which phrase is the correct? "avoid, success at all cost" or "avoid success, at all cost"
17:44:35 <latro`a> the second
17:44:39 <latro`a> or just no comma
17:44:40 <coleman-> if the only downside to wrapper is speed I really don't care. not now at least, and for this task. it is fast enough
17:45:37 <slack1256> latro`a: thanks
17:46:07 <jozefg> shachaf: are there any books and/or resources that go through these sort of details of the type system?
17:46:45 <Jafet> We have failed at both, so it doesn't matter
17:47:44 <YellowOnion> I'm new to haskell, now I'm trying to understand how to get two monads to function together, I have one monad from gloss to display a picture, and another monad to output to file using do notation the gloss example binds these to main I'm sure how to bind both.
17:47:53 <shachaf> jozefg: I don't know any good introductions off-hand -- I can look some things up but I won't know more than you about them without reading them.
17:48:05 <shachaf> http://www.haskell.org/haskellwiki/Functional_dependencies
17:48:34 <jozefg> shachaf: just throught Id ask. Thank you!
17:49:17 <johnw> hmm.. shachaf: what happens if I call freeHaskellFunPtr for a wrapper whose call i'm still in?
17:49:34 <johnw> i.e., i have a function that takes a 'free' callback, and in that callback I want to free the Haskell callback
17:50:00 <shachaf> johnw: I imagine that (a) you're not supposed to do that and (b) it'd work in practice.
17:50:06 <johnw> lol
17:50:07 <johnw> fair enough :)
17:50:18 <shachaf> But those are both just guesses.
17:50:18 <johnw> or I can just leak this one FunPtr, that's all there will ever be
17:50:53 <shachaf> Where?
17:51:11 <johnw> i'm creating backends for libgit2 in Haskell
17:51:21 <shachaf> Why is there only one FunPtr?
17:51:23 <johnw> where a "backend" is essentially just a set of callbacks
17:51:33 <johnw> i meant this one "free" FunPtr
17:51:38 <shachaf> What function are you passing it to, anyway?
17:51:40 <johnw> the callback that is called when the backend is freed
17:51:50 <johnw> shachaf: it would take too long to bring in all the context
17:52:00 <shachaf> What's the type of the function you're passing it to?
17:52:11 <johnw> passing my callback to?
17:52:17 <shachaf> Yes.
17:52:25 <johnw> it's actually a structure member
17:52:37 <shachaf> OK, the function you're passing the structure member to.
17:52:47 <johnw> Ptr <git_odb_backend> -> IO ()
17:54:02 <johnw> that is called when the C'git_odb_backend is freed, one of whose members will be my FunPtr wrapper
17:54:15 <johnw> (for doing the freeing)
17:55:03 <shachaf> git_odb_backend is your own struct?
17:55:11 <johnw> no, it's the library's
17:56:27 <coleman-> having trouble again. ref is not in scope.  http://hpaste.org/79328
17:57:08 <johnw> coleman-: why not just "wrap (callback ref)", and have your callback take an argument?
17:57:14 <johnw> or will it change between creation and call?
17:57:39 <shachaf> It can't change.
17:57:40 <shachaf> You can do:
17:57:44 <shachaf> ref <- newIORef
17:57:48 <shachaf> let callback :: ...
17:57:55 <shachaf>     callback x y = ...
17:58:00 <shachaf> c_EnumWindows ...
17:58:06 <shachaf> That way ref is in scope.
17:59:00 <shachaf> You're really not using this API the way it's meant to be used. :-(
17:59:04 <shachaf> But it'll work, I suppose.
17:59:20 <johnw> I imagine that (a) you're not supposed to do that and (b) it'd
17:59:20 <johnw>           work in practice.
17:59:59 <shachaf> Oh, this is "guaranteed" to work.
18:00:17 <shachaf> johnw: I think when you define an odb_backend you're supposed to to put your things at the end of it.
18:00:36 <shachaf> I.e. struct my_odb_backend { git_odb_backend parent; int my_x; char my_y; };
18:00:46 <johnw> shachaf: yeah, but I didn't think I even needed that
18:00:49 <shachaf> And this is where you store your extra things.
18:00:52 <johnw> let me show you my code
18:00:53 <shachaf> Instead of using "wrapper"
18:01:07 <coleman-> tell me how to pass IORef as a void * and I'll consider doing it. but both your and johnw's suggestion worked nicely!
18:01:15 <hpaste> dimday pasted “Generalizing withDB” at http://hpaste.org/79330
18:01:17 <johnw> well, I need "wrapper" to override the read/write functions
18:01:17 <shachaf> coleman-: You need to use StablePtr
18:01:27 <johnw> see: https://github.com/jwiegley/gitlib/blob/master/Data/Git/Backend/Trace.hs
18:01:43 <shachaf> johnw: No you don't. :-)
18:01:53 <dimday> I'd like to ask. If anyone can help me get my program to compile
18:01:54 <shachaf> johnw: This is a C API, and C doesn't have "wrapper".
18:02:07 <dimday> the bot pasted the link. It's http://hpaste.org/79330
18:02:32 <dimday> I've been ruminating over it for a while now. And I can't figure it out.
18:02:35 <johnw> shachaf: i need the "read" member of C'git_odb_backend to call my read function, that's what I meant
18:02:48 <johnw> otherwise, it defaults to NULL which means no reading behavior
18:03:04 <shachaf> dimday: What type do you get when you commend out the type signature and ask ghci to infer it?
18:03:16 <shachaf> johnw: Yes, but you don't need "wrapper" for that.
18:03:22 <johnw> how would you do it?
18:03:32 <johnw> wrapper is awfully convenient for this
18:03:35 <johnw> but i'm interested now
18:03:36 <shachaf> It's possible that I'd use "wrapper" -- I haven't thought about it.
18:03:41 <johnw> ah, ok
18:03:42 <shachaf> But you can do it the same way you'd do it in C.
18:03:53 <johnw> Bindings-DSL makes using "wrapper" almost effortless
18:03:56 <shachaf> That would be my "default" reaction to a C API -- use it the way you're meant to.
18:04:07 <johnw> in C?  in C I'd say: backend->read = &myread; :)
18:04:17 <shachaf> Sure, but myread won't be a closure.
18:04:38 <johnw> no, for closing variables I'd need the augemented sturcture you mentioned abov
18:04:39 <johnw> e
18:04:42 <shachaf> You can do "foreign export myread" in Haskell too, and then pass that in.
18:04:49 <shachaf> Right. That's the way you're "meant" to use git's API.
18:04:50 <hpaste> dimday annotated “Generalizing withDB” with “Generalizing withDB (annotation)” at http://hpaste.org/79330#a79331
18:04:59 <johnw> but I want to write my backend in Haskell
18:05:07 <johnw> I can just use "foreign export haskellFun"?
18:05:24 <shachaf> dimday: Oh, it's not working because you're using runReaderT
18:05:24 <coleman-> what is actually amazing is that this could work even if C function was poorly designed and didn't accept a void *. in C you would have to use a global variable
18:05:39 <shachaf> dimday: runReaderT clearly won't be polymorphic to any MonadReader -- it has "ReaderT" right in its name.
18:05:47 <shachaf> coleman-: Yes, it's quite nifty.
18:05:52 <coleman-> (and I worked with C functions likes that more than once)
18:06:09 <dimday> ah. that makes sense.
18:06:18 <dimday> so I just remove the MonadReader
18:06:27 <dimday> I'll try it
18:06:40 <shachaf> dimday: By the way, all those "transformers-3.0.0:..." probably indicate that you have multiple versions of the package installed.
18:06:48 <shachaf> You might want to get rid of some versions.
18:06:57 <shachaf> ghc-pkg list transformers, ghc-pkg hide, etc.
18:07:14 <dimday> shachaf: okay. I'll try fixing my ghc-pkg
18:07:57 <dimday> shachaf: but am I correct in thinking that I should just remove the (MonadReader Connection m) requirement since I'm using runReaderT?
18:08:17 <shachaf> dimday: The type ghci gave you is probably the correct one for that function.
18:09:20 <dimday> shachaf: okay. thanks! still wrapping my head around all this. :)
18:10:08 <johnw> shachaf: I can just use "foreign export haskellFun"?
18:10:14 <shachaf> johnw: Yep.
18:10:20 <johnw> interesting
18:10:30 <johnw> i can at least do that for my free function
18:10:33 <shachaf> That'll give you an actual exported top-level function.
18:10:36 <shachaf> It won't be a closure.
18:10:41 <johnw> i don't need this one to be
18:10:59 <shachaf> You don't need any of them to be, with libgit. :-)
18:11:08 <xrl> I'm building a hspec test suite for my library using cabal and I'm getting a link-time error: https://gist.github.com/4315229
18:11:12 <shachaf> Since you can put a void * with an environment at the end.
18:11:28 <johnw> that is indeed true, shachaf...
18:11:53 <johnw> i wonder what it's like to create a haskell
18:12:05 <johnw> n/m
18:12:14 <johnw> i see, it's all just a pointer to memory blocks, and I am the one interpreting them
18:12:25 <johnw> as long as the "base" of that structure matches C'git_odb_backend
18:12:29 <shachaf> Right.
18:12:40 <shachaf> Just pretend it's C++. :-)
18:12:46 <johnw> got it; thanks shachaf!
18:12:46 <shachaf> (Don't pretend it's C++.)
18:13:43 <shachaf> coleman-: Did you figure out how to do it without wrapper?
18:13:52 <shachaf> You should be aware of how to do it, at least.
18:13:56 <johnw> sure enough, the C examples of custom backends just do a castPtr too
18:15:09 <shachaf> johnw: "wrapper" is actually quite unusual.
18:15:16 <johnw> how so?
18:15:16 <shachaf> I don't know of many FFIs that provide something like that
18:15:23 <shachaf> Well, do you?
18:16:06 <applicative> xrl it looks like it's saying i'm a 32 bit ghc but thats a 64 bit  zeromq; but I guess that's obvious
18:16:17 <johnw> you mean, creating thunks for turning functions into closures?
18:16:45 <shachaf> I mean, creating a function pointer at runtime that C can call, which refers to a closure.
18:16:56 <johnw> yes, that's what I understood
18:17:06 <shachaf> All C does is call the function, without an "environment pointer" or anything.
18:17:19 <johnw> well, it makes sense, if you ever wanted to pass an actual lambda closure to a function wanting a callback, right?
18:17:20 <shachaf> So the RTS needs to generate executable machine code at runtime.
18:17:55 <johnw> yeah; it's kind of nice the mechanism exist
18:17:56 <johnw> s
18:18:08 <johnw> but I like your clarification that it's not necessarily the first thing one needs to turn to
18:18:17 <johnw> and also it has costs
18:18:29 <johnw> especially if the callback is called a LOT in a tight loop
18:18:49 <johnw> (although, in that case the creation of the closure might only need to happen once, so the costliness depends)
18:20:59 <kennyd> shachaf C# does that out of the box, you don't even have to call wrapper equivalent you just pass a closure. and I'm pretty sure python does too
18:21:40 <shachaf> kennyd: Are we talking about the same thing here?
18:21:54 <shachaf> Pass a closure to what?
18:21:58 <kennyd> shachaf passing a closure to a C function that accepts a function pointer?
18:22:02 <xrl> applicative: thanks for taking a look... it seems my way of exporting through a top-level module still needed the other-modules directive
18:22:14 <shachaf> kennyd: Yes.
18:22:20 <kennyd> yes that works.
18:22:30 <shachaf> Where is there documentation about it in C#?
18:22:46 <kennyd> no idea. I have done it before though
18:22:58 <shachaf> Does it actually generate executable code at runtime?
18:23:57 <kennyd> shachaf yes I'm pretty sure that's what it does
18:24:08 <shachaf> kennyd: Do you have an example? I'm surprised.
18:24:45 <applicative> xrl I see;  the error message has a number of distracting features...
18:25:01 <kennyd> I could try digging one up, give me a few minutes
18:25:04 <Moggle> I have decided that holy hell why do tabs do this to me
18:25:08 <Moggle> all my problems are due to TABS
18:25:18 <Moggle> i am making notepad++ make tabs into spaces >:O
18:25:20 <Moggle> this is ridiculous
18:25:56 <applicative> Moggle, but tabs should be spaces
18:26:02 <monochrom> yes, first thing I did when I installed notepad++, configured it to use spaces
18:26:21 <applicative> you cant make it language dependent?
18:26:43 <Moggle> I might be able to
18:26:43 <monochrom> in fact first thing I did to eclipse too. it seems like all new-fangled kiddies like tabs
18:26:47 <Moggle> this could be possible
18:26:57 <Moggle> tabs are a-okay monochrom
18:27:01 <Moggle> as long as they are 4 spaces
18:27:10 <Moggle> oooh, that code actually calculated in a decent amount of time?
18:27:11 <monochrom> you prove my point
18:27:13 <Moggle> compiled haskell #1
18:27:33 <Moggle> AND it was correct
18:27:35 <Moggle> woot #1
18:27:42 <shachaf> Tabs are 8 spaces, Moggle.
18:27:46 <shachaf> It's how GHC interprets them.
18:27:48 <Moggle> ... are you serious shachaf
18:28:00 <shachaf> About what GHC does? Yes.
18:28:01 <Moggle> well that explains why all my problems came about
18:28:03 <Moggle> I shall stick to spaces
18:28:07 <shachaf> Yes. Do that.
18:28:12 <Moggle> besides, I can align things better with spaces
18:28:12 <Jafet> Tabs are control characters whose ends align with tab stops.
18:28:12 <simpson> Python does this too. Just about everybody does.
18:28:27 <shachaf> Er, right.
18:28:30 <shachaf> They're not 8 spaces.
18:28:41 <shachaf> They align to the next tabstop, where tabstops are every 8 columns.
18:28:51 <shachaf> That's what I meant. :-)
18:29:09 <johnw> shachaf: so, it seem foreign export ccall haskellFun requires -fllvm or -fvia-C, something which wrapper does not
18:29:36 <cmccann> tabs are whitespace characters displayed incorrectly by editors that other people use
18:30:11 <johnw> hmm.. but interestingly -fvia-C claims it is a no-op
18:30:19 <shachaf> johnw: Are you sure?
18:30:30 <johnw> not anymore
18:30:35 <johnw> maybe it was just ghci complaining
18:30:38 <johnw> cabal build does not
18:30:39 <shachaf> -fvia-C isn't used nowadays.
18:30:48 <hpaste> Moggle pasted “23” at http://hpaste.org/79333
18:30:59 <Moggle> anyone care to offer any criticisms
18:31:11 <Moggle> i _think_ i did this in a Haskelly way with the whole tails thing
18:31:15 <Moggle> and no !! s
18:31:17 <Moggle> but I could be wrong
18:31:51 <shachaf> johnw: Works for me.
18:32:20 <shachaf> johnw: Haskell: foreign export ccall hask_hi :: IO (); hask_hi = putStrLn "hi!"; foreign import ccall c_hi :: IO (); main = c_hi
18:32:27 <shachaf> C: void hask_hi(); void c_hi() { hask_hi(); }
18:32:31 <johnw> yeah, it works with cabal build
18:32:37 <johnw> in works in GHCI fro you?
18:32:43 <shachaf> I didn't try ghci.
18:32:50 <shachaf> I'd be slightly surprised if it did, but maybe.
18:33:03 <johnw> ghc-mod doesn't like it either, unfortunately
18:33:53 <shachaf> foreign export and ghci have some trouble together.
18:34:01 <shachaf> Since it has to link the C code.
18:34:08 <shachaf> Not too important.
18:34:42 <johnw> not overly so, no
18:34:42 * hackagebot shelly 0.15.1 - shell-like (systems) programming in Haskell  http://hackage.haskell.org/package/shelly-0.15.1 (GregWeber)
18:36:04 <johnw> shachaf: but wait
18:36:11 <shachaf> There's more!
18:36:38 <johnw> if a structure that has a member 	int (* read)(...)
18:36:43 <johnw> the type of that member must be FunPtr, no?
18:36:50 <shachaf> Sure.
18:37:02 <johnw> ok, so how do I assign a foreign ccall to it?
18:37:13 <johnw> I'm getting FunPtr (...) != ... mismatch
18:38:09 <shachaf> Hmm. http://hackage.haskell.org/trac/ghc/ticket/7048
18:38:18 <shachaf> You could reimport it with &
18:38:30 <shachaf> Not sure if there's a better way.
18:38:53 <johnw> huh
18:41:05 <shachaf> Does the foreign import thing work?
18:41:19 <johnw> yeah, that works
18:41:30 <johnw> at least, it gets things to type check; will get back to you on "work" shortly
18:41:52 <shachaf> johnw: You're using StablePtrs in the struct, right?
18:42:00 <johnw> haven't gotten there just yet
18:42:23 <johnw> i'm not sure i need a stable ptr
18:42:54 <shachaf> Depends on what your functions do, I guess.
18:43:25 <gwern> @quote fec
18:43:26 <lambdabot> danharaj says: unsafeCoerce should be renamed to badPun
18:43:33 <johnw> i'm malloc'ing something which contains a Ptr, and libgit2 is going to free both of them
18:43:42 <johnw> so lifetime is out of my hands
18:44:33 <shachaf> freeing it is your own responsibility.
18:44:42 * hackagebot bmp 1.2.3.3 - Read and write uncompressed BMP image files.  http://hackage.haskell.org/package/bmp-1.2.3.3 (BenLippmeier)
18:44:50 <shachaf> Oh, I see, you were going to make "free" a wrapper closure which freed itself.
18:44:51 <johnw> libgit2 takes over that responsibility after you call git_odb_add_backend
18:44:59 <johnw> yepah
18:45:06 <johnw> now I can just set "free" to NULL
18:45:06 <shachaf> Right, but I mean the implementation of free().
18:45:16 <johnw> and libgit2 says that it will then call free() on the pointer for you
18:45:31 <johnw> so, it all compiles
18:45:33 <johnw> now for the real test
18:45:42 <shachaf> s/real test/segfault/
18:45:47 <johnw> :)
18:45:49 <johnw> this is Haskell!
18:46:16 <johnw> hrmph... still more work to do
18:49:42 * hackagebot bmp 1.2.3.4 - Read and write uncompressed BMP image files.  http://hackage.haskell.org/package/bmp-1.2.3.4 (BenLippmeier)
18:59:48 <johnw> shachaf: s/segfault/bus error/ :)
19:02:50 <mpu> Is 'ghc-pkg unregister foo' then, deleting all files in .cabal/foo a reasonable way to get rid of a local package?
19:04:03 <byorgey> mpu: ghc-pkg unregister foo is reasonable.  There is not usually any .cabal/foo .
19:04:28 <byorgey> ghc-pkg unregister foo is sufficient unless you really care about saving disk space.
19:04:32 <monochrom> haha. bus error is byte-misalignment
19:04:49 <mpu> Hmm, there is a directory in .cabal that stores compiled blobs, I meant this one.
19:05:14 <johnw> shachaf: so, if all I have is a FunPtr, how then I call it in Haskell?
19:05:29 <monochrom> if you care about save disk space, it's .cabal/lib/foo-version and .cabal/share/foo-version and .cabal/share/doc/foo-version etc etc
19:05:31 <byorgey> mpu: you could delete .ghc/<arch>-<ghc-version>/foo, is that what you mean?
19:05:42 <jpat> to reverse a list, how come you would use 'reverse xs ++ [x]' and not 'reverse xs : [x]' ?
19:05:43 <byorgey> oh, or that
19:05:44 <mpu> byorgey: yes
19:05:49 <byorgey> mpu: no, ignore me
19:05:57 <byorgey> that's what ghc-pkg unregister gets rid of.
19:06:02 <shachaf> @google haskell call funptr
19:06:05 <lambdabot> http://stackoverflow.com/questions/997738/haskell-ffi-calling-funptrs
19:06:05 <lambdabot> Title: c - Haskell FFI: Calling FunPtrs - Stack Overflow
19:06:15 <byorgey> jpat: reverse xs : [x] does not type check.
19:06:24 <mpu> monochrom: ok, thanks
19:06:28 <monochrom> don't manually delete .ghc/<arch>-<ghc-version>/foo-version. but if you do, learn about "ghc-pkg recache"
19:06:32 <byorgey> jpat: (:) takes an element as its first argument and a list as its second argument.
19:06:40 <jpat> Well, what about reverse xs : x?
19:06:49 <shachaf> johnw: http://www.haskell.org/ghc/docs/latest/html/libraries/base/Foreign-Ptr.html
19:06:51 <jpat> oh okay
19:07:06 <byorgey> jpat: (:) is only for adding a new element to the front of a list
19:07:13 <johnw> yeah, i'm looknig there; so I need yet another foreign import to go the other way?
19:07:19 <mpu> monochrom: Yep, I know this one, thanks.
19:07:29 <shachaf> johnw: Looks like it.
19:07:43 <monochrom> isn't cabal exciting!
19:07:45 <johnw> so, work-wise, this is more effort than just using wrappers in Bindings-DSL was
19:07:45 <shachaf> It's not too surprising because it needs to match the calling convention and all.
19:07:51 <johnw> i'm simply saving a few allocations is all
19:08:06 <shachaf> johnw: I'm not saying wrapper is necessarily the wrong way to go.
19:08:15 <coleman-> > :t (:)    -- for jpat
19:08:17 <lambdabot>   <hint>:1:1: parse error on input `:'
19:08:21 <shachaf> But you should be aware of this option -- which is how the API is designed to be used, really -- before jumping to the other one.
19:08:23 <johnw> but then i have the freeing issue
19:08:27 <johnw> well, for that one function is all
19:08:36 <jpat> byorgey: thank you
19:08:44 <coleman-> > :t (:)
19:08:45 <lambdabot>   <hint>:1:1: parse error on input `:'
19:09:53 <coleman-> anyway, the type is  (:) :: a -> [a] -> [a]
19:09:59 <byorgey> coleman-: just :t, no >
19:10:11 <johnw> yeah, i'm going with wrappers
19:10:15 <johnw> this is just getting silly
19:10:15 <coleman-> byorgey okay
19:10:49 <coleman-> johnw  I didn't even try without it. was happy when it worked. :)
19:16:47 <X-suriV> in Haskell if you declare a function to be String->String it is just inferring the String as [Char] right?
19:17:00 <shachaf> Yep.
19:17:03 <shachaf> String = [Char]
19:17:08 <shachaf> @hoogle String
19:17:09 <lambdabot> Prelude type String = [Char]
19:17:09 <lambdabot> Data.String type String = [Char]
19:17:09 <lambdabot> Data.String module Data.String
19:17:40 <X-suriV> cool :) I am writing a function to parse out file names and figured I could just iterate through the name as a list until I found '.' and get the extension
19:17:43 <dmwit> argh, why does Text.Parsec export (<|>)
19:17:45 <djahandarie> I asked this the other day, but maybe there is a new head looking. Can anyone think of a way to reduce the memory usage of threads? I'm trying to have millions of threads floating around (need one per TCP connection), and the memory overhead is killer.
19:18:03 <djahandarie> I tried toying with the -k RTS option, but it didn't help.
19:18:22 <coleman-> @hoogle FilePath -> String
19:18:23 <lambdabot> System.FilePath.Windows takeBaseName :: FilePath -> String
19:18:23 <lambdabot> System.FilePath.Posix takeBaseName :: FilePath -> String
19:18:23 <lambdabot> System.FilePath.Windows takeExtension :: FilePath -> String
19:18:36 <djahandarie> Even having the threads do nothing, like forever $ threadDelay maxBound results in the massive memory overhead.
19:19:04 <copumpkin> djahandarie: threadpools? :P
19:19:33 <coleman-> X-suriV see System.FilePath.takeExtension
19:20:42 <X-suriV> Oh wow sweet
19:21:01 <georgy> is there something like (.) that combines IO actions
19:21:02 <djahandarie> copumpkin, well, I do need all of the threads working at the same time
19:21:08 <X-suriV> lol the way I was going to do it would work, but heck if there is already a function Ill take it!
19:21:12 <X-suriV> god im loving this language
19:21:31 <copumpkin> georgy: yeah, but what it is depends on how you want to combine them
19:21:42 <copumpkin> djahandarie: not sure, perhaps JaffaCake would know
19:21:43 <copumpkin> if you can find him
19:21:52 <djahandarie> If I can find him (!)
19:22:02 <djahandarie> I'll wander over to the GHC channel
19:22:26 <djahandarie> Hm :(
19:22:28 <parcs> > 2.6 * 1024 * 1024 * 1024 / 1000000
19:22:30 <lambdabot>   2791.7287424
19:22:35 <cmccann> :t (<=<) -- georgy
19:22:36 <lambdabot> Monad m => (b -> m c) -> (a -> m b) -> a -> m c
19:23:00 <parcs> ~3kb per thread isn't very much
19:23:01 <georgy> copumpkin: if g returns IO a in (f <whatever> g) I want to pass a to f
19:23:21 <X-suriV> 2*2
19:23:23 <copumpkin> djahandarie: twitter might work
19:23:32 <X-suriV> Lambda bot :P
19:24:48 <georgy> nice <=< worked
19:26:56 <jpat> Whats the difference between => and -> in a definition
19:27:15 <johnw> Constraint => Domain -> Codomain
19:27:38 <gnuvince> I have a question about building multiple Haskell executables.  I am doing the Project Euler problems, and I have problem001.hs, problem002.hs, etc. and I'd like to have a single command to compile only those that need recompiling.  Can I do that directly with GHC, or do I need to have a headache getting a proper Makefile?
19:27:38 <djahandarie> Related, is there any way to make the RTS allocate memory... more smoothly? It does things like suddenly try and allocate 1GB of memory which can be problematic on low-mem systems
19:27:47 <jpat> constraint?
19:27:59 <johnw> jpat: (+) :: Num a => a -> a -> a
19:28:21 <jpat> so a has to be a number
19:28:26 <johnw> yep
19:28:45 <jpat> will I get an error if I dont include it
19:28:59 <jpat> for instance: if i'm trying to figure out if a list is a palindrome
19:29:52 <shachaf> gnuvince: GHC will do that directly for you anyway.
19:30:04 <shachaf> (But "project euler" is not a good way to learn Haskell.)
19:31:08 <X-suriV> take a Haskell course in college :
19:31:09 <X-suriV> :D
19:31:12 <georgy> jpat you have to compare elements with == in your function, correct?
19:32:13 <sw2wolf> :t curry
19:32:14 <lambdabot> ((a, b) -> c) -> a -> b -> c
19:32:41 <copumpkin> shachaf: worked for me!
19:33:15 <cmccann> I did a few project euler problems with haskell, sort of.
19:33:25 <copumpkin> I did 100 and then got bored
19:33:36 <copumpkin> but I do think it helped me pick up haskell
19:33:40 <cmccann> I stopped bothering after I realized that 90% of both the effort and fun was the scribbling on paper trying to figure out the problem
19:33:47 <cmccann> and the programming after that was just tedium
19:34:33 <popl> cmccann: I had more fun perusing the Project Euler fora.
19:34:51 <cmccann> popl, a.k.a. the land of J one-liners
19:35:08 <popl> and really slick x86
19:35:14 <cmccann> haha yeah
19:35:21 <cmccann> some of the solutions people post are great
19:36:59 <X-suriV> is there a way to flush the input buffer after a getChar? for example, if you call getChar, and the user enters a character and then hits enter, if there is another user input function like getLine right after it, it counts that enter for that and stops it
19:38:07 <glguy>   hSetBuffering stdin NoBuffering
19:38:14 <Moggle> @pl (\f l -> f ++ (x : l))
19:38:15 <lambdabot> (. (x :)) . (++)
19:38:17 <catsbydlo> or don't use getChar
19:38:37 <cmccann> use something like haskeline if you want nicer console input
19:38:42 <glguy> ooh, or don't ask for user input, just print the right answer
19:38:51 <X-suriV> lol
19:38:58 <gnuvince> shachaf: how do I do it with GHC?  I'd like to limit the number of calls to GHC (optimal would be 1)
19:39:03 <Moggle> (\f l -> f ++ x ++ l)
19:39:17 <Moggle> @pl (\f l -> f ++ [x] ++ l)
19:39:17 <lambdabot> (. (x :)) . (++)
19:39:26 <Moggle> >:O
19:40:03 <shachaf> gnuvince: You want to compile a hundred unrelated programs in a directory?
19:40:14 <gnuvince> yes
19:40:46 <jpat> georgy: yes, why?
19:40:54 <jpat> georgy: does that matter?
19:40:55 <shachaf> I think GHC won't do that. One run of ghc -> at most one executable generated.
19:41:03 <gnuvince> ok
19:41:08 <shachaf> But if you do for f in *; ghc $f; done, it'll only recompile the ones that need recompiling.
19:41:09 <geekosaur> X-suriV, part of the problem is that the tty driver will do buffering even if ghc isn't.  and flushing that is different on unix vs. windows
19:41:32 <gnuvince> shachaf: that's what I'm doing at the moment, but there's a noticeable delay if only one file has been modified
19:41:38 <shachaf> gnuvince: Alternatively you can make them all modules, instead of standalone executables, with one big Main.hs that depends on all of them.
19:42:24 <Jafet> GHC checks the file contents. make checks the file modification time.
19:42:40 <shachaf> True.
19:44:51 <coleman-> jpat if you need constraints but you failed to provide them you will get compile error yes
19:44:57 <geekosaur> and apparently there are no libraries with just that, at least for unix, so you'd have to use the FFI to get at tcgetattr()/tcsetattr() (note CSAFLUSH flag to the latter)
19:45:02 <geekosaur> er.  TCSAFLUSH
19:48:35 <georgy> jpat if you wanted to make your function generic (instead of just working with String) your function would look something like this:  palindrome :: Eq a => [a] -> Bool
19:53:39 <johnw> shachaf: it all works, yay!
19:54:19 <johnw> how do I #if test for 32-bit in GHC?
19:54:51 <Jafet> "You shouldn't"
19:55:01 <johnw> yeah, but I need to define a Storable instance
19:55:19 <johnw> and sizeof depends on the width of a pointer
19:55:25 <johnw> is that a constant I can access from some module?
19:56:42 <geekosaur> if you know the type in question you can use its existing Storable instance, see the sizeOf function
19:56:46 <Jafet> The size of a pointer would be sizeOf Ptr
19:56:50 <geekosaur> ^^
19:57:01 <johnw> cool, thanks
19:57:08 <hpaste> NemesisD pasted “inotify blocked” at http://hpaste.org/79334
19:57:11 <geekosaur> although I think it's actually sizeOf (Ptr CInt) or whatever, since Ptr is a type constructor
19:57:49 <Jafet> (So is Ptr CInt)
19:57:54 <NemesisD> hi guys, could someone take a look at that? i'm trying to use inotify to reload a config. i've simplified my use case to that example. it seems like the main thread blocking on an MVar is preventing INotify from hitting its callback
19:58:20 <johnw> that was the clue I needed
19:59:31 <johnw> https://github.com/jwiegley/gitlib/blob/master/Data/Git/Backend/Trace.hs
20:00:06 <johnw> well, not exactly
20:00:23 <johnw> that change to Storable resulted in an infinite loop, so I got my sizes wrong somewhere...
20:00:31 <NemesisD> hmm. it seems i'm wrong. inotify is just not working at all. i write to the file being monitored and nothing happens
20:03:49 <NemesisD> has anyone used hinotify?
20:04:51 <geisthaus> ok so Control.Lens
20:04:54 <geisthaus> any hints?
20:05:39 <beaky> @src reverse
20:05:40 <lambdabot> reverse = foldl (flip (:)) []
20:05:52 <zachk> is that O(n) or O(n^2) ?
20:06:30 <mpu> Even in a strict setting it is O(n)
20:06:45 <beaky> yes folds are O(n)
20:06:46 <johnw> oh, hehe
20:07:42 <johnw> is sizeOf (undefined :: C'git_odb_backend) a good thing to do?
20:08:14 <jpat> georgy: My question is, why the Eq a => ? what is Eq a?
20:08:22 <johnw> Eq a means that a must support ==
20:10:08 <coleman-> jpat this explains it better than I could. http://learnyouahaskell.com/types-and-typeclasses#typeclasses-101
20:13:43 <jpat> ty
20:16:00 <coleman-> and a nice follow up:  http://learnyouahaskell.com/making-our-own-types-and-typeclasses
20:16:19 <Cale> jpat: Well, you know how type variables allow you to write things like  length :: [a] -> Int  -- where the type of the elements of the list may be any type at all?
20:16:19 <lambdabot> Cale: You have 1 new message. '/msg lambdabot @messages' to read it.
20:17:36 <Cale> jpat: If you wanted to write something like a function to sort a list, you'd like it to work on a wide range of types, but [a] -> [a] wouldn't work, because it doesn't make sense to do order comparisons on elements of just any type at all (functions or IO actions for example, aren't easy to define an ordering on)
20:18:55 <Cale> jpat: So, instead, we have  sort :: Ord a => [a] -> [a]  which says that for any type a on which the ordering operations are defined, sort will take a list of values of that type, and produce another.
20:20:21 <NemesisD> if a thread rescues exceptions can it prevent itself from dying?
20:20:52 <NemesisD> from being killed w killThread*
20:22:11 <hpaste> deus_rex pasted “list of gains” at http://hpaste.org/79335
20:22:32 <geekosaur> NemesisD, yes.  see discussion at http://www.haskell.org/ghc/docs/latest/html/libraries/base/Control-Exception.html#g:4
20:22:53 <deus_rex> is there some way I could write that with a fold? i guess with the problem being that the folded function needs to receive two elements from the list at once
20:23:44 <deus_rex> I was thinking too I could use take with a fold somehow, but i'm not sure about the implications of time-efficiency
20:25:01 <NemesisD> exceptions once again are ruining my life
20:27:42 <ryant5000> aside from the list monad and LogicT, are there any monads around that are good for solving constraint problems?
20:31:29 <Saizan> ?query lambdabot
20:31:29 <lambdabot> Unknown command, try @list
20:31:59 <NemesisD> is it possible to catch an IOException or some other unrelated exception in the same handler?
20:34:24 <Saizan> > foldr (\a r f -> f a (r (\b -> (b - a :)))) (\ _ -> []) [1,5,4] (const id)
20:34:26 <lambdabot>   [4,-1]
20:34:37 <Saizan> with horrible inversion of control there
20:36:36 <evincar> ryant5000: Have you seen http://overtond.blogspot.com/2008/07/pre.html ?
20:36:44 <Saizan> NemesisD: maybe catches is what you want?
20:37:58 <NemesisD> Saizan: so I have to reiterate a handler per exception type even if the body is the same thing?
20:39:02 <NemesisD> where handleIt :: Handler IOException; handleIt' :: Handler AnotherException; handleIt'' :: Handler AThirdException
20:39:51 <Saizan> the type parameter of Handler is not the exception types
20:40:12 <Saizan> NemesisD: another way would be to use fromException yourself
20:41:09 <Saizan> NemesisD: yet another is to define a polymorphic handling function and then specialize to the different types
20:41:52 <NemesisD> yeesh
20:43:03 <Saizan> by specializing i just mean using a type annotation
20:43:10 <NemesisD> the types of Handler and fromException are a bit vague for me. i'm not seeing a strategy for implementing it
20:44:46 <Saizan> well, how does your handler look like?
20:44:48 <glguy> johnw: sizeOf doesn't use its argument, so yes, that's fine
20:45:12 <Saizan> does it care at all about the exception type?
20:45:43 <NemesisD> Saizan: my handler is gonna be something like handler e = errorM $ "Error: " ++ show e
20:45:53 <NemesisD> where errorM is a logging function
20:46:03 <johnw> glguy: seems like it, thanks
20:46:16 <NemesisD> and i've got to handle IOExceptions and HttpExceptions, as far as I know
20:46:38 <glguy> johnw: It's what the base library does, too (so make sure if you write your own Storable instance that you don't use the argument, either)
20:47:11 <Saizan> NemesisD: ok, so handler :: Show a => a -> IO b, right?
20:47:39 <NemesisD> Saizan: yeah
20:49:10 <Saizan> i guess what i would do is define two wrapper functions for the Handler constructor
20:49:43 <Saizan> handlerIO :: (IOException -> IO a) -> Handler a; handlerIO = Handler
20:50:06 <Saizan> handlerHttp :: (HttpException -> IO a) -> Handler a; handlerHttp = Handler
20:50:32 <Saizan> then you can write "... `catches` [handlerIO handler, handlerHttp handler]"
20:51:02 <Saizan> makes sense?
20:52:10 <johnw> can I make a strict bytyestring into a conduit source?
20:52:12 <NemesisD> Saizan: yeah. so you're specializing it per type you have to catch
20:52:16 <johnw> sourceLbs wants lazy, obviously
20:52:45 <Saizan> NemesisD: yep
20:53:34 <NemesisD> Saizan: i'm surprised there isn't more of a tendency to eschew usage of exceptions in haskell. as far as I can tell the exception types that can be raised aren't encoded anywhere in the function types and are up to the author's discretion to document
20:53:54 <blackdog> i've been thinking about development & testing style in haskell. Usually in Ruby, i'd use something like guard + a set of rules for determining which tests to run depending on which files changed.
20:54:08 <johnw> ah, I think I need (sourceLbs (BL.fromChunks bytes))
20:54:27 <ryant5000> evincar: that looks really interesting; thanks.
20:54:37 <blackdog> this seems difficult within a cabal project: there's only the test-suite stdio functionality. you don't want to have to rebuild everything when something changes, and you don't want to run every single test in between.
20:54:40 <NemesisD> blackdog: some things you should check out: hspec and the guard-shell gem
20:54:41 <blackdog> anyone solved this?
20:54:49 <blackdog> NemesisD: i've been using hspec
20:55:19 <Saizan> NemesisD: yeah the fact they don't appear in the type is quite nasty, there are some libs on hackage that support being more explicit but they suffer from not being canonical
20:55:23 <NemesisD> blackdog: it would be cool if hspec provided a binary that took a list of files
20:55:46 <blackdog> NemesisD: and guard-shell doesn't seem to give you much over guard + backticks, does it?
20:55:55 <blackdog> NemesisD: yeah. maybe i'll talk to solirc about it
20:56:11 <NemesisD> blackdog: not really. if you're cool with running the whole suite on writes, it works alright though
20:56:23 <blackdog> i'd really rather not :)
20:56:39 <blackdog> i mean, that's what i've been doing, but running the single test helps keep me in flow
20:56:54 <NemesisD> blackdog: there's probably some hackery you could rig up with hspec's discover feature, but i don't anticipate it being easy
20:56:58 <blackdog> i'm not sure if it's even hspec's responsibility.
20:57:08 <blackdog> no. it's about running in the context of the cabal setup
20:57:21 <NemesisD> blackdog: you could have each test file be an executable and rig up dependencies with make/shake or something
20:57:25 <startling> hspec looks really cool
20:57:35 <blackdog> pity the test-suite stuff never seemed to proceed past stdio-exit
20:57:48 <NemesisD> blackdog: last i read they were making progress on that
20:58:05 <NemesisD> i think they should probably just use that TAP (?) protocol that lots of languages use and be done with it
20:58:55 <blackdog> NemesisD: heh. did that with TBC ages ago
21:00:07 <blackdog> lot of work keeping a test framework working, though. very happy that solirc is doing it.
21:00:30 <NemesisD> blackdog: i develop mostly in Ruby and do Haskell on my free time. all I can say is that the ease of testing in haskell isn't going to be near where it is in ruby anywhere in the near future
21:00:46 <shachaf> Is data Null a = Null defined anywhere?
21:00:58 <blackdog> NemesisD: yeah, i'm in the same boat.
21:01:08 <blackdog> it doesn't need to be that hard, though.
21:01:20 <NemesisD> You can argue that haskell is safer and its easier to write obviously correct code, but the effort barrier is still much higher
21:01:47 <blackdog> i think it's just a matter of polish
21:02:05 <sm> HTF seems good
21:03:20 <lispy> HTF?
21:03:35 <blackdog> sm: i dnot' think it improves on hspec for the stuff i care about.
21:03:46 <startling> shachaf, Const ()?
21:03:50 <shachaf> startling: Yes.
21:03:54 <lispy> sm: oh, n/m just found it on hackage
21:03:55 <shachaf> Except without the ()
21:03:56 <startling> shachaf: Const ()
21:04:03 <startling> shachaf: Const Bool
21:04:03 <shachaf> But it's always ()
21:04:17 <startling> -- (it's always True)
21:04:20 <glguy> shachaf: I think they call it "Proxy"
21:04:28 * sm looks at hspec
21:04:39 <hrumph> i'm reading about functors now
21:04:41 <shachaf> glguy: Good point!
21:04:44 <glguy> shachaf: this is one of them http://hackage.haskell.org/packages/archive/tagged/0.2.3.1/doc/html/Data-Proxy.html
21:04:46 <shachaf> I knew about Proxy but somehow didn't think of it.
21:04:48 <glguy> I don't know if it's a good one :)
21:04:51 <hrumph> so why use map for lists when you've always got fmap?
21:05:01 <shachaf> I'll just keep calling it Null since I've already defined mine, though.
21:05:11 <shachaf> hrumph: In Haskell 1.4 fmap was called map.
21:05:17 <shachaf> The error messages confused people so they changed it.
21:05:25 * shachaf likes the old version better.
21:05:52 <johnw> castPtr makes me feel no less ugly than static_cast :)
21:05:57 <sm> HTF lets you write test_* near the thing you're testing and makes those runnable without much effort
21:06:02 <glguy> hrumph: If you know you want lists your types will infer to lsits
21:06:16 <hrumph> can filter also be generalised to a filter?
21:06:26 <hrumph> generalised to a monad i mean
21:06:36 <hrumph> i mean a functor
21:06:41 <otters> @pl \(a,b) -> (a,s,b)
21:06:41 <lambdabot> uncurry (flip (,,) s)
21:06:43 <blackdog> sm: yeah. same thing for hspec with hspec_discover
21:06:51 <hrumph> let me restate can filter also be generalised to a functor
21:07:05 <blackdog> sm: oh, hang on, you write the test in the same file?
21:07:12 <blackdog> how do you run it? can it gather the cabal options?
21:07:15 <hrumph> i don't see how it could off hand but i'm asking
21:07:15 <Saizan> i imagine something like filter would make sense over a Foldable
21:07:19 <glguy> hrumph: No, you couldn't write filter using only fmap
21:07:58 <glguy> Foldable doesn't leave any of the structure behind, though
21:08:22 <glguy> :t filtered
21:08:24 <lambdabot> Applicative f => (a -> Bool) -> SimpleLensLike f a a
21:08:34 <glguy> You can generalize it to a limited traversal
21:09:55 <Saizan> ?type filtered (const False) pure
21:09:56 <lambdabot> Applicative f => a -> f a
21:10:07 <Saizan> > filtered (const False) pure ()
21:10:09 <lambdabot>   No instance for (GHC.Show.Show (f0 ()))
21:10:09 <lambdabot>    arising from a use of `M24051979...
21:10:12 <glguy> johnw: static_casts are safe (assuming this is C++), castPtr is a reinterpret_cast
21:10:24 <Saizan> > runIdentity (filtered (const False) pure ())
21:10:26 <lambdabot>   ()
21:11:06 <startling> you could filter to get a list with Foldable
21:11:23 <startling> that's just filter f . Data.Foldable.toList though
21:11:57 <beaky> what are GADTs
21:13:12 <gsj> generalized algebraic data types
21:13:22 <gsj> i think it's a GHC-specific extension
21:13:48 <beaky> so ADTs are the only datatypes in the world of Haskell?
21:14:58 <beaky> :t (=<<)
21:15:00 <lambdabot> Monad m => (a -> m b) -> m a -> m b
21:15:17 <glguy> :t flip (>>=)
21:15:17 <beaky> :t flip (>>=)
21:15:18 <lambdabot> Monad m => (a -> m b) -> m a -> m b
21:15:19 <lambdabot> Monad m => (a -> m b) -> m a -> m b
21:15:24 <beaky> :D
21:15:47 <Saizan> ?type guard
21:15:49 <lambdabot> MonadPlus m => Bool -> m ()
21:24:35 <johnw> does S3 have an "exists" type of request?
21:26:39 <hpaste> NemesisD pasted “multi exception handler” at http://hpaste.org/79339
21:26:42 <NemesisD> Saizan: I think I got my types mixed up or something ^
21:27:41 <NemesisD> i think it specializes handler to the first thing it sees, IOException
21:28:18 <gsj> johnw: you mean to look for a particular key?
21:28:40 <johnw> yes
21:29:13 <gsj> johnw: you could do HEAD object on the key you're looking for, or you could do a GET Bucket (list objects) where the prefix is the key you want
21:29:25 <gsj> johnw: http://docs.aws.amazon.com/AmazonS3/latest/API/RESTObjectHEAD.html, http://docs.aws.amazon.com/AmazonS3/latest/API/RESTBucketGET.html
21:29:40 <johnw> how about if I just get the gorMetadata for a particular GetObject?
21:30:22 <johnw> i'm using the 'aws' library
21:30:54 <gsj> johnw: i don't know. you'd have to look into how the API calls map to REST queries
21:31:16 <gsj> if worse came to worst you could run Wireshark and hit an HTTP endpoint to see what requests the library is sending
21:31:17 <Saizan> NemesisD: ah, that's the monomorphism restriction kicking in
21:31:53 <Saizan> NemesisD: replace line 8 with "handler e = Left . show $ e" and you'll be fine
21:32:33 <johnw> huh, the attempt library looks kind of clever
21:33:16 <NemesisD> Saizan: so you can't do points free in cases like this?
21:34:20 <Saizan> NemesisD: with no arguments the MR forces handler to be monomorphic
21:34:45 <Saizan> NemesisD: you could {-# LANGUAGE NoMonomorphismRestriction #-} at the top of the file if you want
21:38:27 <NemesisD> ahh ok
21:38:35 <shachaf> Is there a name for (Identity a -> Identity b) -> a -> b?
21:39:13 <sw2wolf> :t Identity
21:39:14 <lambdabot> a -> Identity a
21:41:22 <aristid-ipad> :t \f -> runIdentity . f . Identity
21:41:24 <lambdabot> (Identity a -> Identity b) -> a -> b
21:41:29 <shachaf> Sure, that's what I'm doing.
21:41:33 <shachaf> The other way around is called fmap.
21:42:01 <Saizan> pamf
21:42:22 <shachaf> I'm not sure this operation makes sense for any other type.
21:44:44 <Saizan> i can see an operation forget :: cat a b -> a -> b making some sense
21:45:27 <aristid-ipad> thatd take a Kleisli Identity?
21:45:50 * flebron wonders what Identity does
21:45:58 <shachaf> Nothin'
21:46:00 <shachaf> @src Iedntity
21:46:00 <lambdabot> Source not found. Take a stress pill and think things over.
21:46:02 <shachaf> @src Identity
21:46:02 <lambdabot> newtype Identity a = Identity { runIdentity :: a }
21:46:05 <Saizan> more like Image Identity, if we had it
21:46:43 <johnw> aws doesn't expose a HEAD object type yet
21:47:27 <Saizan> but there's no way to make an instance such that Image Identity a b would unify with (Identity a -> Identity b), so it's moot
21:47:52 <frontendloader> c x = concat $ [drop 1 y | y <- group x]
21:48:27 <georgy> did this use to work?   [x + y | x <- (Just 10), y <- (Just 20)]
21:48:55 <frontendloader> It's not possible to rewrite that recursively using a function whose signiture is [Int] -> [Int]? O(n) too
21:49:01 <Cale> georgy: yes, and it will work again if you use MonadComprehensions
21:49:32 <aavogt> am I doing something wrong in that records in http://hackage.haskell.org/package/grapefruit-records don
21:49:47 <georgy> why did they remove it? seems nice you could use it for any Monad
21:49:48 <aavogt> 't infer a type for say     X :& Label1 :=
21:51:22 <aristid-ipad> johnw: for s3?
21:52:05 <johnw> yeah
21:52:10 <johnw> i'm going to use the bucket list
21:52:16 <johnw> (bucket get object list)
21:53:28 <aristid-ipad> johnw: create an issue on the github please :)
21:53:31 <gsj> johnw: i see that Hackage has both 'aws' and 'aws-sdk'
21:53:58 <georgy> I mean why did they remove it from default language
21:54:05 <johnw> i'm using 'aws'
21:54:13 <aristid-ipad> aws is the good one</shameless promotion>
21:54:23 <johnw> :)
21:54:26 <johnw> thanks aristid-ipad!
21:54:46 <gsj> looks like aws-sdk is brand new and doesn't offer s3 support yet
21:55:32 <johnw> aristid-ipad: https://github.com/aristidb/aws/issues/49
21:56:04 <georgy> I am still getting same error even with MonadComprehensions enabled
21:56:39 <aristid-ipad> johnw: ok cool.
21:58:47 <aristid-ipad> johnw: currently dont have a timeframe for the 0.8 release though
21:59:01 * johnw gives aristid-ipad a timeframe
21:59:27 <gsj> johnw: or feel free to implement HEAD object =)
22:00:29 <johnw> if i need it, I actually will
22:00:43 <johnw> i'm writing an S3 backend for gitlib
22:01:13 <aristid-ipad> johnw: you can initially put the request/response type pair in your own code btw
22:01:34 <aristid-ipad> aws exposes all the types and stuffs
22:02:16 <aristid-ipad> johnw: whats gitlib?
22:02:40 <johnw> it's a high-level interface to libgit2 for Haskell
22:02:46 <johnw> so you can easily write Git utilities in Haskell
22:03:35 <aristid-ipad> why does that need s3?
22:04:11 <johnw> the IDE FPComplete is working on will store user files in S3 as they work on their project, since our IDE runs on EC2 instances
22:04:15 <gsj> hm, i tried to "cabal install hlibgit2" and it failed to build. never seen that before with cabal
22:04:26 <johnw> gsj: can you show me?
22:04:38 <johnw> also, cabal install gitlib is the interface you want to use; hlibgit2 is very low-level
22:04:48 <aristid-ipad> johnw: git on s3? interesting
22:05:04 <johnw> sure, libgit2 supports arbitrary key/value backends, you just have to code them :)
22:05:06 <hpaste> gsj pasted “"cabal install hlibgit2" errors” at http://hpaste.org/79343
22:05:16 <gsj> yay bots
22:05:25 <aristid-ipad> johnw: oh
22:05:28 <johnw> gsj: do you have libgit2 installed?
22:05:47 <gsj> johnw: i couldn't find a package with that name. i found "libgit" and "hlibgit2" only
22:05:52 <aristid-ipad> johnw: for me git is still a .git dir :D
22:05:56 <gsj> johnw: do i need another repo or something?
22:06:01 <johnw> ok, good, you *shouldn't* have it isntalled
22:06:11 <gsj> namespace collision?
22:06:27 <johnw> checking
22:06:44 <johnw> hm.. this define is in src/compat/fnmatch.h
22:06:50 <johnw> what OS are you on?
22:07:03 <gsj> aristid-ipad: actually, cloud storage makes a lot of sense to git. you can get really exceptional durability by transmitting new objects to remote storage
22:07:06 <gsj> for git*
22:07:20 <aristid-ipad> johnw: probably need some tricks for safe and efficient git on s3?
22:07:20 <gsj> johnw: this is on an Ubuntu virt
22:07:41 <johnw> ok, let me make sure fnmatch is handled properly
22:07:47 <johnw> i just hadn't built on your OS yet
22:09:20 <johnw> this is odd; fnmatch.c is only supposed to be used on Cygwin and Solaris
22:09:24 <johnw> you shouldn't need it on Ubuntu
22:09:39 <gsj> you mean it's being pulled in by some #define?
22:09:52 <gsj> i don't know where cabal puts the source to build
22:09:59 <johnw> src/unix/posix.h in libgit2 is the one who references it
22:10:08 <johnw> but only if __sun is defined
22:10:13 <johnw> otherwise it pulls in <fnmatch.h>
22:10:20 <johnw> which clearly doesn't have the required symbol
22:10:37 <johnw> http://manpages.ubuntu.com/manpages/dapper/man3/fnmatch.3.html
22:10:44 <johnw> it's there; so why would the compile file?
22:10:46 <johnw> fail?
22:12:10 <johnw> can you try cloning git://github.com/jwiegley/libgit2 and building with cmake?
22:13:46 <gsj> isn't this the one i'm not supposed to install?
22:13:50 <gsj> anyway, cmake --build . worked fine
22:14:47 <johnw> ok, which version of Ubuntu are you using?
22:14:52 <johnw> i'll setup a VM here and get to the bottom of it
22:16:37 <shachaf> What's a good Iso?
22:16:57 <gsj> i think it's 12.10. let me double check
22:17:07 <aristid-ipad> shachaf: any newtype.
22:17:17 <shachaf> Such as?
22:17:39 <aristid-ipad> dunno, Sum!
22:17:40 <aristid-ipad> ?
22:17:48 <aristid-ipad> stupid ipad kbd
22:18:04 <gsj> johnw: yup, it's 12.10
22:18:18 <gsj> 32 bit
22:18:49 <johnw> ok, since that's rather close to our deployment environment -- and I haven't tried building it there yet -- this is something I need to fix now, give me a little bit
22:20:01 <gsj> i'm running a virt in VMWare Workstation, if that matters. which it might, because VMWare detects that you're installing a modern version of Ubuntu and does this special quick install thing
22:22:56 <johnw> you did the quick install?  I never do, but if you did, i'll do it to replicate
22:24:52 <gsj> is that some sort of linux virt faux pas on my part?
22:27:34 <sw2wolf> How to use git to produce diff between the local and remote ? thx
22:28:08 <johnw> no, not at all
22:28:17 <popl> sw2wolf: mat git-diff
22:28:18 <johnw> for me it's just historical bias
22:28:30 <johnw> sw2wolf: see #git
22:28:40 <popl> *man
22:28:43 <popl> not mat
22:30:55 <wereHamster> I have this function: createAttribute formula base = Attribute formula base base. HPC marks the last argument as unevaluated.
22:32:08 <wereHamster> it seems it is a false positive. If the third argument is evaluated then the last has to be as well, doesn't it? It's the same expression after all
22:33:30 <johnw> i don't count 4 args
22:33:39 <johnw> i see f x y = g a b c
22:33:40 <wereHamster> sorry, second and third
22:33:51 <johnw> since they are the same argument, why would it be evaluated twice?
22:34:32 <wereHamster> I'm trying to use HPC. It marks unevaluated expressions with a yellow color
22:34:38 <johnw> unless i'm misunderstanding the way HPC determines "evaluation"
22:35:23 <wereHamster> in that function above, the last token on the source code line (base) is marked with a yellow color
22:36:21 <johnw> and i'm thinking that it's marking it yellow becaues it doesn't need to be evaluated
22:36:31 <johnw> it was already evaluated for arg2
22:36:39 <johnw> but that's really just a guess
22:36:43 <wereHamster> tha'ts what I was suspecting
22:37:06 <wereHamster> so.. is there a way to tell HPC that it's being evaluated and not mark it yellow?
22:37:19 <johnw> i haven't used HPC enough to know yet
22:39:00 <johnw> is there a utility that shows me unused cabal dependencies within a project?
22:39:38 <wereHamster> also, it marks 'otherwise' with green (always evaluates to True). Thanks captain obvious.
22:39:59 <johnw> gsj: ok, it reproduces here in our deploy environment, 12.04 LTS 64-bit
22:40:00 <gsj> johnw: you mean unused imports?
22:40:12 <johnw> gsj: yaeh, unused imports in my project.cabal file
22:40:34 <gsj> johnw: do you guys have a continuous build fleet of some kind
22:40:56 <johnw> we do have CI, but that's not my area
22:41:03 <johnw> i'm not sure what system they run it with
22:41:13 <johnw> i use jenkins locally for monitoring builds
22:44:16 <NemesisD> hi guys. i'm a bit stuck working with EitherT, what is liftIO supposed to do in an EitherT?
22:44:19 <popl> (little do we know, Jenkins is some man johnw has hired to watch the computer monitor)
22:44:28 <NemesisD> would that be a Right value?
22:46:43 <johnw`> did your EitherT question get answered?  I logged
22:48:12 <wereHamster> no
22:48:14 <hpaste> NemesisD pasted “EitherT with catches” at http://hpaste.org/79345
22:48:16 <NemesisD> i'm trying to write foo :: IO a -> EitherT String IO a.
22:49:02 <johnw`> so, if you use any set of monad transformers with IO as the topmost monad, then liftIO lifts IO operations into the IO monad
22:49:09 <NemesisD> getting Expected type IO a, Actual Type: IO (Either string a0) in the first argument of liftIO namely tryAction
22:49:33 <johnw`> on which line?
22:49:54 <NemesisD> 4
22:50:15 <mysticc> Is it possible to have a function which returns true when the element's type belongs to a typeclass?
22:50:47 <johnw> tryIO' :: IO a -> EitherT String IO (Either string a)
22:50:48 <Nisstyre-laptop> mysticc: "element" ?
22:50:49 <johnw> that would work
22:51:02 <johnw> you're using both EitherT a IO b *and* IO (Either a b)?
22:51:37 <mysticc> I have typeclass C1 which have instances for type A and B. Now I have a new typeclass C2 which has a function isC1 which should return True for elements belonging to A and B
22:51:41 <NemesisD> johnw: EitherT String IO a and IO a
22:51:41 <mysticc> Nisstyre-laptop: ^^
22:52:11 <johnw> but your functions are returning IO (Either string a), as your error message clearly shows
22:52:25 <NemesisD> johnw: i'm pretty lost here. i'm trying to run an IO action and have a success be Right a, to catch exceptions with a Left String
22:52:43 <Nisstyre-laptop> mysticc: what is the actual problem you're trying to solve?
22:53:10 <johnw> ok, you don't need EitherT for this
22:53:11 <johnw> just return IO (Either String a)
22:53:17 <johnw> and in your function, use "catch" to translate exceptions into Left values
22:53:18 <Nisstyre-laptop> mysticc: what would the type of "isC1" be?
22:53:45 <NemesisD> johnw: i need it for the context i'm using it
22:53:50 <mysticc> Nisstyre-laptop: isC1 is a member of class C2. its type isC1 :: a -> Bool
22:54:05 <johnw> then i don't know enough to help you
22:54:17 <mysticc> Nisstyre-laptop: I know I can create instances for A and B and set this True
22:54:36 <NemesisD> although i see your point, maybe i can make that work, that seems more sane
22:54:42 <mysticc> Nisstyre-laptop: But is it possible to just use the context of C1 and do this
22:55:04 <mysticc> Nisstyre-laptop: Something like instance C1 a => C2 a where
22:55:36 <mysticc> Nisstyre-laptop: But this does not work as other instances of C2 give ambiguous instances error.
23:03:24 <Nisstyre-laptop> mysticc: I don't think there is a way to do that at runtime
23:03:33 <Nisstyre-laptop> If I understand what you want correctly
23:03:55 <gsj> i'm just a beginner but i've seen nothing to suggest that Haskell retains that kind of type information at runtime
23:04:05 <sopvop> So, I build function from combinators like :: ( a -> (a -> b) -> (a -> b)), in the end i have just (a -> b). And use it a lot through the code.
23:04:05 <sopvop> How well does ghc runtime treat such functions? If I put result as top level function, will runtime reuse 'computed' function between calls, or recompute before applying? What about threads?
23:04:25 <Nisstyre-laptop> you can of course code that up statically using pattern matching, but you have to add new cases for each new type that you make an instance of C1
23:05:44 <NemesisD> johnw: i'm having a lot of trouble now turning errors into lefts: tryIO' :: IO a -> IO (Either String a); tryIO action = action' `E.catches` handlers where action' = Right <$> action
23:05:52 <johnw> gsj: uploading fixed version now
23:06:31 <gsj> johnw: ok let me know when it's up and i'll try it again. then again, i dunno if it has to propagate to all the uh... edge servers or mirrors or whatever
23:06:50 <Nisstyre-laptop> actually no you couldn't even do that because the type signature would have to be "C1 a => a -> Bool"
23:06:52 <johnw> NemesisD: show me code?
23:07:05 <johnw> gsj: hackagebot will let you know in a moment :)
23:07:10 <Nisstyre-laptop> so it wouldn't even be able to work for anything that isn't an instance of C1
23:07:37 <hpaste> NemesisD pasted “Left errors” at http://hpaste.org/79346
23:08:10 <NemesisD> shoot that's not the right version, didn't mean to include the join
23:08:44 <johnw> i'm having a bit of difficulty reading it
23:09:00 <hpaste> NemesisD annotated “Left errors” with “Left errors (annotation)” at http://hpaste.org/79346#a79347
23:09:15 <johnw> i see, your using catches
23:09:48 <johnw> i don't see where result is defined
23:10:20 <NemesisD> gah, thats supposed to be action, not result
23:10:31 <johnw> show me something that type checks :)
23:10:58 <hpaste> NemesisD annotated “Left errors” with “Left errors (annotation) (annotation)” at http://hpaste.org/79346#a79348
23:11:08 <NemesisD> it doesn't type check, thats the problem :P
23:11:12 <mzero> anyone have a good example of a haskell app that does a good job of reporting its version and build info?
23:11:30 <johnw> what is the error now?
23:11:35 <mzero> I want to implement --version for my app, and it would be nice to have version and, say, git revision info
23:12:01 <Nisstyre-laptop> mysticc: there might be a way to do what you want with Template Haskell
23:12:03 <johnw> mzero: cabal-file-th will let you import info from your cabal file
23:12:18 <hpaste> NemesisD annotated “Left errors” with “Left errors (annotation) (annotation) (annotation)” at http://hpaste.org/79346#a79349
23:12:41 <johnw> which line in the pastie is your line 64?
23:12:50 <johnw> 7?
23:13:00 <NemesisD> johnw: that's the core of it, its turning a into a1, line 7 of the code
23:13:34 <mzero> johnw: ah - though the only thing I think I could want from the .cabal file is the vesion, and cabal already supplies that to your build w/o TH
23:14:01 <johnw> mzero: how does it do that?
23:14:38 <johnw> NemesisD: try using IO a -> IO (Either String b)
23:14:44 <mzero> it always generates a .hs file   Paths_xxxx  (where xxxx is the name of the executable or lib) and that module exports a value   version
23:14:48 * hackagebot hlibgit2 0.17.0.3 - Low-level bindings to libgit2  http://hackage.haskell.org/package/hlibgit2-0.17.0.3 (JohnWiegley)
23:14:59 <johnw> mzero: cool!
23:15:09 <gsj> thar she blows
23:15:09 <johnw> so, import Paths_program?
23:15:40 <gsj> ok, cabal obviously cached the older version and didn't download the latest one
23:15:41 <gsj> what do?
23:15:50 <johnw> cabal update doesn't help?
23:15:55 <johnw> which hackage mirror are you using?
23:15:58 <mzero> well that gives me the version info ---- but I'm trying to figure out how to nicely include things like the build date, and git revision
23:16:00 <gsj> oh, i just ran cabal install hlibgit2
23:16:11 <gsj> hehe, forgot about the package list cache
23:16:17 <hpaste> Enigmagic pasted “Ghetto git revision as a String” at http://hpaste.org/79350
23:16:45 <gsj> ok, now we're cooking with gas.
23:16:58 <johnw> can you cabal install gitlib?
23:17:01 <NemesisD> johnw: changed it in both the typesigs in tryIO' and it can't match type a with b1
23:17:14 <gsj> wait, gitlib? i thought i was trying to install hlibgit2
23:17:16 <gsj> which works now, btw
23:17:17 <Enigmagic> mzero: check the hpaste ^^^
23:17:17 <johnw> NemesisD: hmm..
23:17:26 <johnw> NemesisD: try writing: do { x <- action ; return (Right x) }, just to clarify things
23:17:31 <mzero> Enigmagic: that's pretty ghetto!
23:17:40 <johnw> gsj: hlibgit2 is the low-level FFI bridge
23:17:48 <johnw> gitlib is the set of Haskell types on top of it
23:17:59 <gsj> johnw: ok. hlibgit2 works. gitlib fails because i apparently need to install some other packages
23:18:08 <johnw> using hlibgit2 directly is pretty raw
23:18:31 <gsj> Missing C libraries: icui18n, icudata, icuuc
23:18:35 <Enigmagic> mzero: or you can use a custom cabal setup
23:18:43 <johnw> sudo apt-get install libicu-dev
23:18:45 <Enigmagic> it is ghetto though
23:19:29 <NemesisD> johnw: oddly enough, that seemed to just swap the type variables in the error: couldn't match expected type b1 with actual type a in the first argument of Right, namely x
23:19:50 <johnw> i wonder if this is related to your context of usage
23:19:55 <gsj> johnw: ok, gitlib works now
23:20:02 <johnw> gsj: yay!  and cabal test passes?
23:20:21 <gsj> johnw: never heard of it. do i pass it the name of the package as an argument?
23:21:10 <johnw> cabal configure --enable-tests && cabal build && cabal test
23:21:17 <NemesisD> johnw: i could paste the whole file, all i'm trying to do is catch 2 classes of errors
23:21:33 <NemesisD> been trying to get it to compile for the past hour and a half i'd say
23:21:36 <mzero> NemesisD: why all the work to find the HEAD file and add it as a dependent? is that required so that the TH is rerun if needed?
23:21:57 <johnw> paste it all, I say
23:22:09 <gsj> johnw: it wants me to create a package description file, whatever the hell that is. am i running this in the wrong directory or something?
23:22:18 <johnw> oh, sorry
23:22:24 <johnw> you can't run tests without the project checked out
23:22:26 <johnw> n/m then ;)
23:22:35 <gsj> is there a git repo or something?
23:22:43 <johnw> http://github.com/jwiegley/gitlib
23:22:49 <kennyd> shachaf here you go. a bit late but I didn't have access to windows box earlier.  http://ideone.com/wpj2Tl
23:23:01 <hpaste> NemesisD annotated “Left errors” with “ALL the Left errors :P” at http://hpaste.org/79346#a79351
23:23:13 <NemesisD> johnw: you asked for it
23:23:22 <gsj> ah, neat. a haskell unit test library
23:23:42 <gsj> i'm only up to the "Applicative Functors" chapter of LYAHFGG so this is all new to me
23:23:47 <Enigmagic> mzero: yeah... that way GHC will track it as a dep. better approach is to have the build system dump the current revision out to a file first.
23:24:02 <shachaf> kennyd: Oh, that's pretty neat.
23:24:08 <johnw> oh
23:24:13 <johnw> you never use the type of resp in any way
23:24:39 <johnw> try just (resp :: Either String ()) or something, in your call to either in makeRequest
23:24:45 <kennyd> yeah FFI is one of the things C# does well.
23:25:35 <NemesisD> johnw: it uses the Right of resp in logResponse
23:26:16 <johnw> what's the type of 'a' in that case, String?
23:26:43 <johnw> then substitute 'b' for String, and see how that changes the error message
23:26:50 <NemesisD> johnw: in Either String a, a is a response from http-conduit
23:27:02 <johnw> put () in place of a then
23:27:09 <johnw> just to get an error message about what the type is expected to be in this context
23:27:14 <NemesisD> ohh
23:27:59 <marxx> can someone explain why IO monad can only be unpacked  in a function returning IO?  Maybe is a monad too and yet we can unpack it in a function that returns something other than Maybe
23:28:22 <johnw> marxx: because Maybe provides a "fromJust" functions for extracting the value from the Maybe a type
23:28:29 <johnw> (and also fromMaybe, and maybe)
23:28:34 <sclv> the reason we can "unpack" maybe is that it is just a data type
23:28:34 <sclv> which
23:28:35 <sclv>  h
23:28:36 <sclv> a
23:28:41 <johnw> Monads are not required to permit extraction
23:28:42 <sclv> happens to be a monad
23:28:53 <NemesisD> johnw: unsurprisingly, expected type Either String (Response a0), actual Either String ()
23:28:58 <sclv> (sorry about the noise)
23:29:03 <johnw> NemesisD: interesting
23:29:11 <Jafet> @src IO
23:29:11 <lambdabot> Source not found. You speak an infinite deal of nothing
23:29:16 <Jafet> @source IO
23:29:16 <lambdabot> IO not available
23:29:20 <sclv> the reason we can't "unpack" IO is because it is a particular type of "secret" data type
23:29:22 <Enigmagic> :t IO
23:29:23 <Jafet> @src Maybe
23:29:23 <lambdabot> data Maybe a = Nothing | Just a
23:29:24 <lambdabot>     Not in scope: data constructor `IO'
23:29:24 <lambdabot>     Perhaps you meant `In' (line 132)
23:29:28 <sclv> which by construction only lets us build it up
23:29:38 <sclv> and whose "run" function is embedded in the compiler itself, so to speak
23:29:51 <Jafet> You can't build it either, you can only use IO that is already there
23:29:52 <johnw> NemesisD: i don't know why the type is broken with just 'a' or 'b'
23:29:57 <sclv>  so a program builds up an IO action, and executing the program itself is the only thing you can do with it
23:29:59 <marxx> what about IO automatically being ran in main? is that compiler magic at work?
23:30:11 <Jafet> main is magical.
23:30:13 <sclv> main is of type IO
23:30:14 <sclv> i
23:30:15 <sclv> t
23:30:15 <johnw> marxx: IO isn't run in main
23:30:16 <sclv>  
23:30:18 <sclv> do
23:30:19 <sclv> esn
23:30:20 <sclv> '
23:30:21 <sclv> t "
23:30:21 <sclv> gah!, sorry
23:30:26 <gsj> dude wtf
23:30:35 <sclv> my irc client is freaking out
23:30:37 <Jafet> Kids, do not remap your return key.
23:30:37 <johnw> marxx: the IO value named 'main' is executed after it is constructed
23:30:38 <gsj> is your keyboard at the bottom of a well?
23:30:47 <Enigmagic> :t GHC.Types.IO
23:30:49 <lambdabot> (GHC.Prim.State# GHC.Prim.RealWorld -> (# GHC.Prim.State# GHC.Prim.RealWorld, a #)) -> IO a
23:30:51 <NemesisD> johnw: maddening isn't it
23:30:52 <marxx> johnw: thats what my tutorial said, that IO is only ran if it falls into main
23:31:03 <sclv> eek, don't show him the innards of IO that's confusing
23:31:11 <Enigmagic> :)
23:31:11 <johnw> marxx: that's part of the magic of the Haskell runtime, yes
23:31:15 <sclv> main doesn't "run" IO though. it just is something of type IO
23:31:28 <sclv> executing a haskell program is what runs main
23:31:37 <johnw> NemesisD: is all this code in a github project I can just download and compile and get your error?
23:31:59 <marxx> what i am really wondering is, could users have implemented IO monad if it didnt exisr?
23:32:06 <marxx> exist
23:32:10 <sclv> not without compiler builtins, no
23:32:24 <sclv> if we included just "unsafePerformIO"
23:32:32 <johnw> marxx: I could implement something like IO, only if I had IO :)
23:32:36 <sclv> then we could build a safe IO monad on top of it
23:33:00 <sclv> so we can build safe monadic IO on an impure language
23:33:07 <gsj> johnw: i run "cabal build" on gitlib and get "ghc: could not execute: htfpp"
23:33:10 <gsj> what do?
23:33:12 <Jafet> The IO type is the only way to describe IO.
23:33:26 <johnw> gsj: cabal configure --enable-tests didn't complain?
23:33:34 <Jafet> It is like asking whether you can talk about unicorns without using the word "unicorn".
23:33:36 <johnw> it should have said you don't have HTF installed
23:33:55 <gsj> johnw: nope. it produced two lines of output and terminated with exit code 0
23:34:00 <johnw> Jafet: I can talk about monohorned equestrian beasts, clearly
23:34:07 <gsj> johnw: i installed HTF
23:34:08 <NemesisD> johnw: yep: https://github.com/michaelxavier/buster/tree/monitor
23:34:16 <marxx> what is preventing us from implementing it if it didnt exist? other than the fact that runtime calls main
23:34:18 <johnw> you need HTF, doctest HUnit
23:34:30 <johnw> NemesisD: is the failing state committed?
23:34:49 <NemesisD> johnw: you'll want to comple with "make", you'll need cabal-dev. the offending file is Request.hs
23:34:52 <NemesisD> johnw: yessir
23:34:57 <sclv> marxx: consider an action like "read from stdio"
23:34:59 <gsj> johnw: i installed all of those, because --enable-tests did complain the first time
23:35:13 <sclv> how could you "run" this without some existing way to invoke it?
23:35:34 <sclv> we have a way to invoke arbitrary interactions via the ffi with C
23:35:40 <sclv> but the ffi itself is in IO
23:35:48 <johnw> gsj: does cabal build succeed now?
23:36:06 <sclv> there was a model of IO before monads in Haskell, actually, but that was also 'baked in' even moreso than the current monadic style
23:36:12 <marxx> sclv I see
23:36:52 <johnw> NemesisD: building
23:36:59 <gsj> johnw: no, i'm saying i had already installed those dependencies when i got that error
23:37:05 <johnw> oh!
23:37:13 <Jafet> interact is an interpreter that doesn't require you to use the IO type.
23:37:14 <johnw> you installed htfpp and you don't have it on your path?
23:37:15 <Jafet> :t interact
23:37:16 <johnw> is it in ~/.cabal/bin?
23:37:17 <lambdabot> (String -> String) -> IO ()
23:37:23 <johnw> i mean, installed HTF
23:37:24 <Jafet> It's also fairly useless.
23:37:24 <sclv> (conceptually, it was just treating main as a function from stdin as a lazy list of characters to another list of characters which represented stdout… there was a bit more involved, but surprisingly little)
23:37:43 <sclv> interact is in fact the core of the old-style IO I was talking about
23:37:51 <johnw> NemesisD: are you using GHC 7.6?
23:38:01 <sclv> it just had more things you could read besides characters and more things you could put besides to stdio
23:38:23 <sclv> but then you wrap up a pattern of interacting with it and monads just sort of emerge, whether you call them that or not
23:38:40 <NemesisD> johnw: yessir
23:39:37 <gsj> johnw: ok, now it's building
23:39:50 <johnw> NemesisD: i can't help just yet then
23:40:09 <johnw> NemesisD: I have 7.6 installed, but I'm actively working on a project right now that needs 7.4.2 for the moment
23:40:13 <gsj> johnw: tests pass
23:40:24 <johnw> gsj: yay! now if only there was a shred of documentation, you'd be golden
23:40:32 <johnw> but you can see what I'm doing in test/Smoke.hs, more or less
23:40:50 <Jafet> A more sophisticated interpreter is a threaded function on the RealWorld. Once you write this using State, you get GHC.Prim.IO.
23:40:51 <johnw> I'm trying to design it to make repositories very easy to examine and manipulate
23:41:00 <Jafet> But I think concurrency is still magical.
23:41:19 <marxx> is IO monad under the hood just a function that is called when it's "unpacked" ?
23:41:40 <NemesisD> johnw: that's cool. i need to get some sleep anyways. when do you think you'd be able to get 7.6?
23:41:56 <johnw> i have 7.6 all set, i just need to "brew switch ghc 7.6"
23:42:02 <johnw> but that would mean stopping my work on my current project
23:42:04 <NemesisD> johnw: although i don't know that it won't work with 7.4
23:42:09 <johnw> this IRC stuff is just "side-band"
23:42:20 <johnw> NemesisD: it wants to install unix-2.6, which doesn't compile under 7.4
23:42:22 <Jafet> Monads are not functions.
23:42:29 <NemesisD> johnw: would you mind emailing me when you get a chance to look at it? i really appreciate you helping me out and i def  don't want to interrupt your work
23:42:30 <johnw> Monads are burritos!
23:42:35 <johnw> i know, I just ate two of them
23:42:44 <johnw> that's why >>= looks like a chomping mouth
23:43:00 <NemesisD> lol!
23:43:05 <Jafet> salsaM_
23:43:05 <johnw> NemesisD: you'll need to ping me; this isn't something I'll remember to do on my own :)
23:43:56 <NemesisD> johnw: will do. i gotta run i'll check back with you soon
23:44:01 <Jafet> I don't think that the IO type is definable "under the hood".
23:44:01 <marxx> I never said monad is a function. but a monad can wrap a function, and it can call it on >>=
23:44:42 <Jafet> It is implemented with a number of features that GHC has specifically to implement things like IO.
23:44:51 <marxx> isnt IO monad implemented in a similar way?
23:45:07 <marxx> lagging a bit
23:47:03 <Jafet> The state monad of IO is probably an analogy, but you can ask the ghc channel to be sure.
23:47:49 <Cale> The state monad of IO is a dirty hack and doesn't really make a good mental model of what it's about.
23:48:07 <Cale> Compared to say, a higher order abstract syntax representation of the actions
23:49:10 <Cale> (I mean the thought that IO a ~= RealWorld -> (RealWorld, a))
23:49:12 <aavogt> when reading files with code run by template haskell packaged by cabal, what's a good way to take care of the different possible paths to the data files?
23:49:41 <aavogt> it seems    runIO (readFile "x")  reads "x" relative to the path that ghc is called from
23:49:53 <Cale> The internal representation of IO uses impure functions, and RealWorld is a 0-bit token which is just a way to leverage GHC's dependency analysis and apply it to IO actions.
23:50:14 <Cale> But as a mental model where you think of RealWorld as representing the actual state of the world, this is pretty unusable
23:50:34 <Cale> For one, it is pretty confusing in the face of concurrency
23:50:55 <Jafet> That is what I thought.
23:51:24 <Enigmagic> but it still takes up a register, right? that's my recollection.
23:51:43 <Enigmagic> at least it's passed explicitly in cmm
23:52:23 <Cale> marxx: If you want a good mental model, think of IO actions as data describing a bunch of actions to be carried out, like the source code of a program.
23:52:46 <Jafet> A register that is never read nor written
23:52:55 <johnw> an IO value is a recipe for changing the world
23:53:00 <Jafet> Any register allocator will remove it
23:53:28 <Jafet> Or letting the world change you
23:53:33 <Jafet> !!!
23:53:43 <popl> wake up, Neo
23:53:48 <Enigmagic> Jafet: still has to be part of the calling convention?
23:53:56 <johnw> i have to change the world at least enough to reflect that you changed me... :)
23:55:40 <Jafet> Enigmagic: I have no idea about the ABI
23:55:59 <Jafet> If you run the matrix, remember to set noatime.
23:56:04 <aristid> johnw: only so much as you also change the world in a pure setting of computation :P
23:58:16 <pqmodn> aavogt: yes, assuming "x" is a relative path (one that doesn't begin with /), it will be resolved relative to the current working directory.
23:58:20 <Enigmagic> Jafet: well it's sort of important if you're talking about register allocation
23:59:20 <pqmodn> aavogt: you can find ways to resolve "x" relative to other paths if you like. perhaps you expected it to be resolved relative to the path to the executable?
23:59:32 <aavogt> pqmodn: right, but if I like to load my Main.hs with ghci, it seems only possible to get one of   "ghci src/Main.hs"  and "ghci Main.hs" to work
