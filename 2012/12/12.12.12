00:08:21 <johnw> does cabal not use Setup.hs anymore?  I'm trying to get it to build a dependency library, but it doesn't seem to be running the preBuild step
00:08:50 <c_wraith> you have to tell it to
00:08:59 <johnw> oh...
00:09:39 <c_wraith> I believe you set the build-type field to custom
00:10:17 <c_wraith> Ah, Custom
00:11:18 <johnw> that worked, thank you
00:20:35 <johnw> and if I need to do a "cd" in Setup.hs, is there a recommended way to do that?
00:21:25 <johnw> having a dependency on "unix" for that seems egregious
00:22:10 <johnw> oh, i guess directory is always available
00:37:19 * hackagebot wai-app-file-cgi 0.8.1 - File/CGI/Rev Proxy App of WAI  http://hackage.haskell.org/package/wai-app-file-cgi-0.8.1 (KazuYamamoto)
01:10:17 <johnw> which hook would you use to install a C library that gets built during cabal build?
01:10:50 <johnw> i tried copyHook, preInst and postCopy, and it seems it's not triggering
01:15:37 <johnw> hmm
01:16:02 <johnw> postCopy does copy it with "cabal copy", I just sort of assuming cabal install would run 'copy'...
01:16:42 <fmap> maus: you probably forgot to update gtk2hs-buildtools
01:17:47 <maus> fmap I tried anything I could think of including deleting .cabal and .ghc
01:18:41 <apfel> hi there, i have to use  foldr to find the highest value in an Interger List, how can i do that?
01:18:49 <shachaf> Why do you have to?
01:19:21 <maus> by the way, hackage page for gtk shows similar build errors on ghc-7.6 http://hackage.haskell.org/packages/archive/gtk/0.12.4/logs/failure/ghc-7.6
01:19:55 <apfel> shachaf: because thats the Excercise, i did it allready without foldr but i have to use foldr
01:20:56 <maus> fmap, still I was able to build it about two months ago and now I can't reproduce it.
01:21:11 <apfel> i tried this: foldr (>) 2 [1, 4, 2, 3, 6] but i got a error message from hugs i expected a list like [4, 3, 6]
01:21:25 <shachaf> You should use GHC, not Hugs.
01:21:33 <shachaf> Anyway, look at the source of foldr
01:21:35 <shachaf> @src foldr
01:21:35 <lambdabot> foldr f z []     = z
01:21:35 <lambdabot> foldr f z (x:xs) = f x (foldr f z xs)
01:21:56 <shachaf> foldr (>) 2 [1,4,2,3,6] = (>) 2 (foldr (>) 2 [4,2,3,6])
01:21:58 <shachaf> Do you see why?
01:22:20 * hackagebot websockets 0.7.1.1 - A sensible and clean way to write WebSocket-capable servers in Haskell.  http://hackage.haskell.org/package/websockets-0.7.1.1 (JasperVanDerJeugt)
01:23:38 <apfel> shachaf: no not realy, this is very confusing
01:24:06 <apfel> f is the Operator? ">" in my case
01:24:26 <FireFly> Yes
01:24:45 <FireFly> Look at the second line of the definition of foldr, and substitute the arguments with their values
01:29:49 <apfel> ok i got it, thanks
01:31:30 <fmap> maus: well, if you have latest gtk2hs-buildtools I have no idea what may go wrong with 0.12.4 release, sorry
01:45:19 <sopvop> just want to say that cabal install -j is awesome!
01:49:15 <aristid> sopvop: what does -j do?
01:49:33 <alpounet> parallel builds
01:51:19 <latermuse> do readFile and writeFile strictly close their handles after use? How can I force them to close handles?
01:53:45 <shachaf> Does NOINLINE prevent GHC from doing the worker/wrapper thing?
01:54:04 <sopvop> switched to 7.6.1 and reinstalled everything snap needs. with -j it was exceptionally fast
01:54:07 <shachaf> latermuse: writeFile is different from readFile.
01:54:17 <shachaf> latermuse: readFile closes the handle after you've read all of the file.
01:54:28 <shachaf> You can read more about "lazy I/O" in various places.
01:56:55 <bartavelle> sopvop, what is -j ?
01:57:22 <alpounet> (again) parallel builds
01:57:28 <bartavelle> lol :)
01:57:55 <bartavelle> finally !
02:02:40 <alpounet> shachaf, i found a thread that says so. i'm not sure this is still the case, the thread is from ghc-users, 2007 though
02:04:38 <alpounet> shachaf, err, actually: http://www.haskell.org/pipermail/glasgow-haskell-users/2007-June/012715.html
02:12:21 * hackagebot flock 0.3.1.4 - Wrapper for flock(2)  http://hackage.haskell.org/package/flock-0.3.1.4 (ErikHesselink)
02:14:13 <shachaf> I wish I had more metadata about the Core/Cmm/what not generated by GHC in ghc-core.
02:14:18 <shachaf> Rather than having to parse it.
02:19:36 <maus> I need to parse a JS which is not entirely conforming to rfc. For example, " { a: 'abc', b: 10 }". a and b lack quites here. Such a string is rejected by Aeson. Any ideas how to parse it?
02:20:19 <shachaf> rwbarton might know.
02:24:26 <dreixel> has anyone ever experienced that doing a cabal install --enable-executable-profiling still does not set the -prof flag when compiling?
02:39:34 <b__> anyone in here going to DutchHUG meet-up tonight?
02:41:38 <earthy> not me
02:47:36 <maus> fmap, I found the reason for gtk2hs build failures. PATH variable specified ~/.cabal/bin after ~/usr/bin, so newly generated tools were shadowed by older versions. Excuse the noise.
02:49:07 <latermuse> shachaf: thanks for your answer
03:00:02 <younder> hi all
03:02:36 <latermuse> hi younder
03:05:31 <younder> Having silly problems like trying to find out where Maybe was just settled for Data.Maybe
03:06:02 <latermuse> younder: Are you saying you arent sure which module Maybe is located in?
03:06:18 <younder> I know it is in many..
03:06:28 <younder> That's the problem
03:06:38 <latermuse> Data.Maybe is the standard module for Maybe
03:07:06 <`ramses> the others just re-export the one from Data.Maybe
03:07:51 <younder> Just oorted some old programs that seem to have imported it by default
03:07:56 <younder> ported
03:08:41 <CuteAngel24> yes, Maybe is in the Prelude
03:08:43 <younder> There must have been a time where importing Data wasn't neccesary
03:08:56 <latermuse> Haskell 98
03:09:01 <CuteAngel24> that time is now
03:09:28 <`ramses> the type is still in Prelude (which re-exports the one from Data.Maybe) you only need to import Data.Maybe if you want the extra functions that the Prelude does not give you
03:12:09 <younder> well GHC gave me gref over this
03:12:17 <younder> grief
03:13:51 <CuteAngel24> no, it didn't
03:14:18 <younder> what?
03:14:39 <hpaste> “Bas de Haas” pasted “cabal.install.htime.--enable-executable-profiling.-v” at http://hpaste.org/79108
03:14:59 <CuteAngel24> what can be asserted without evidence can also be dismissed without evidence
03:15:35 <hpaste> “Bas de Haas” pasted “htime +RTS -prof” at http://hpaste.org/79109
03:15:54 <younder> I'm not making it up..
03:16:19 <CuteAngel24> making what up? "gave me grief" is nearly content-free
03:16:37 <hpaste> “Bas de Haas” pasted “cabal config” at http://hpaste.org/79110
03:16:56 <younder> Gave me erroro messages.. Maybe not foundd. that kinda thing
03:17:11 <CuteAngel24> and what was the real error message?
03:22:20 <bartavelle> attoparsec question : the Fail constructor says that [String] refers to a set of context. What are these ? I don't know how to interpret error messages, especially compared to Parsec ...
03:22:28 <bartavelle> (it is always empty with me)
03:22:47 <maus> I've separated files of my project into a several directories. Now i'm having troubles with ghci. I can load the modules by issuing something like ghci -idir1:dir2 dir3/MyModule.hs. But this way all the modules are interpreted. And I need some of them to be compiled for performance reasons. Can anyone suggest the ghc flags needed?
03:31:56 <lzm> is there a way to read N bytes from a handle? i see hGetLine, hGetContents and hGetChar but its not what i want
03:34:20 <MasseR> Is there a good graphics library for representing ie. a self organizing map?
03:34:50 <sopvop> GADTs syntax of  'data Foo a where Foo :: Foo Int' is same as 'data  Foo a = forall . a ~ Int => Foo'. Who would have known.
03:35:33 <latermuse> lzm: Check out byte strings
03:35:48 <CuteAngel24> lzm: http://hackage.haskell.org/packages/archive/bytestring/0.10.2.0/doc/html/Data-ByteString.html#v:hGet
03:37:52 <younder> CuteAngel24, It was compiling Hskabelle for Isabelle
03:38:38 <younder> For mathematical verification of my compiler
03:38:52 <younder> Haskabelle
03:40:31 * arbn had never heard of Haskabelle, but finds it very interesting now.
03:40:41 <gienah> younder: I didn't have much luck compiling Haskabelle, I vaguely recall that haskell-src-exts had dropped support for unsupported #pragma s that haskabelle was using
03:41:07 <gienah> we should nag the devs to please add it back in
03:42:54 <younder> right
03:48:57 <jackss> is there a haskell web client library? with support for autoredirection, cookies, etc
03:49:15 <younder> I got it running after inserting a lot of import DATA ...
03:51:19 <fmap> jackss: you mean like mechanize?
03:52:09 <jackss> I have never used mechanize. like drakma for lisp
03:53:36 <arbn> jackss: There is not one yet, to the best of my knowledge. You should write one.
03:56:08 <mm_freak> jackss: there are many libraries, but they all suck =)
03:56:18 <mm_freak> in terms of convenience that is
04:00:01 <typoclass> jackss: http-conduit follows redirects and i think also handles cookies. it's also straightforward to use and well documented. but of course it's a http library, it doesn't (by itself) parse html
04:02:23 <fmap> well documented but documentation itself is kinda broken
04:02:32 <fmap> but that's probably more of haddock fault
04:07:09 <gabk> how do you force evaluation of a lazy function?
04:07:32 <Hafydd> @give gabk seq
04:07:32 <lambdabot> Maybe you meant: dice gsite time
04:07:36 <Peaker> gabk, you put a forcing expression of it in a position that itself is forced
04:08:14 <Hafydd> @hoogle seq
04:08:15 <lambdabot> Prelude seq :: a -> b -> b
04:08:15 <lambdabot> Prelude sequence :: Monad m => [m a] -> m [a]
04:08:15 <lambdabot> Control.Monad sequence :: Monad m => [m a] -> m [a]
04:09:01 <Peaker> gabk, a "forcing expression" is basically: A) x `seq` y    (makes 'x' forced when trying to force y),  or: B) another function that forces x, e.g: print x would force x, or: y $! x.    C)  case x of ... DataConstructors...  will force 'x' deep enough  to figure out whether it is the right data constructors
04:09:27 <Peaker> gabk, "print x" would force 'x' only when that IO action is executed, not when "print x" is evaluated
04:10:19 <b_jonas> > seq (print undefined) 4
04:10:22 <lambdabot>   4
04:10:30 <b_jonas> right
04:11:57 <gabk> basically I am parsing a lot of data, building a tree, and this takes a couple of seconds. then I ask a line from a user and accesss that data. I want the loading and parsing to happen before the user enters first line, not after
04:12:05 <gabk> I will try seq
04:16:24 <sopvop> seq forces only to top constructor, you will either need deepseq or decorate fields with prefix (!)
04:16:57 <gabk> hmm I see?
04:17:28 <shachaf> deepSeq is rarely what you want.
04:17:49 <gabk> what do I want, then?
04:17:53 <sopvop> like data Tree a = Leaf !a | Node !a !(Tree a) !(Tree a)
04:18:30 <sopvop> which means - give up laziness
04:18:41 <merijn> gabk: Well, what are you trying to accomplish?
04:18:57 <sopvop> (04:10:56 PM) gabk: basically I am parsing a lot of data, building a tree, and this takes a couple of seconds. then I ask a line from a user and accesss that data. I want the loading and parsing to happen before the user enters first line, not after
04:19:55 <merijn> jackss, typoclass: Of course http-conduit also plays well with xml-conduit and html-conduit, which (in my personal experience) are quite comfortable to use for parsing and navigating HTML
04:25:52 <timofonic2> Hello
04:25:57 <timofonic2> Hello
04:26:13 <timofonic2> I wonder if there's something like emacs's org-mode for Yi...
04:30:41 <epsil> is yi still alive? (hopeful question)
04:32:18 <raichoo> epsil: From what I heard yes.
04:40:45 <byorgey> epsil: definitely yes.  See https://github.com/yi-editor/yi/commits/master
04:55:30 <jackss> merijn I thought about using tagsoup for parsing but I'll check out those libraries as well. thanks
04:56:54 <hpaste> bxc pasted “partially applied type synonyms” at http://hpaste.org/79112
04:57:29 <bxc> that paste doesn't compile for me - i think becausei'm using type synonyms and I can't use X without an argument
04:57:36 <Peaker> gabk, what problem are you trying to solve with the forcing?
04:57:39 <bxc> is that whats going on? and is there a better way to write it?
04:58:20 <Peaker> gabk, also, I don't think seq is a nice function to ever use. Syntactically, bang patterns and the ($!) function are much nicer.  Operationally, if you want to control what thread does the actual work, you need `pseq` and not `seq`.
04:58:27 <Nereid> bxc: that is right.
04:58:41 <Nereid> bxc: you'll have to make a newtype or so if you want to pass X as a type argument.
04:58:52 <hpaste> bxc annotated “partially applied type synonyms” with “partially applied type synonyms (annotation)” at http://hpaste.org/79112#a79113
04:58:55 <Nereid> although
04:58:58 <Nereid> why not just
04:59:08 <Nereid> type Y a = StateT Integer (ReaderT Integer IO) a
04:59:26 <Nereid> oh you know,
04:59:28 <Nereid> you could also just
04:59:30 <bxc> Nereid: I had X in a different module
04:59:31 <Nereid> uh
04:59:38 <Nereid> type X = ReaderT Integer IO
04:59:52 <bxc> ok i'll try that
05:00:17 <bxc> putting in one def breaks the modularity I'm trying to keep
05:00:49 <gabk> Peaker I want parsing and reading to happen before user starts to interact with the loaded data, not after the first input  user makes. interaction should be instant
05:01:13 <Peaker> gabk, what is the type of your parse/read result?
05:01:33 <gabk> Map.Map
05:01:46 <bxc> Nereid: yeah that seems to make it happier. hurrah for pointfree style.
05:01:50 <bxc> thanks
05:01:54 <Peaker> gabk, What key/value types?
05:02:40 <Peaker> gabk, if you're in the IO monad, the canonical way to force values is to use Control.Exception.evaluate.   But another option for you is to use Data.Map.Strict which always keeps the keys/values forced to WHNF.  Then you need to make sure WHNF is the form you want for your keys/values
05:02:46 <gabk> are they really relevant? my issue is that reading and parsing happens after the first input, not before
05:03:19 <gabk> I see
05:03:34 <Peaker> gabk, well, if your key/value types are composite - they may be forced "one level deep" or "all the way". If they are atomic (e.g: Int) there is no difference
05:03:48 <Peaker> gabk, you probably want them forced "all the way down" (i.e: fully computed)?
05:05:18 <gabk> yes. the type is Map.Map String [Int]
05:06:01 <Peaker> gabk, you can use deepseq to force the entire Map, then. Something like: import Control.DeepSeq (force) ; import Control.Exception (evaluate) ;    evaluate (force myMap)
05:06:09 <Peaker> @type evaluate
05:06:10 <lambdabot>     Not in scope: `evaluate'
05:06:10 <lambdabot>     Perhaps you meant `evalState' (imported from Control.Monad.State)
05:06:20 <Peaker> @type Control.Exception.evaluate
05:06:21 <lambdabot> a -> IO a
05:06:29 <neutrino> why is evaluate in that module?
05:06:38 <gabk> strict map wouldnt do it?
05:06:54 <neutrino> you'd need a strict map of strict lists i think
05:07:26 <Peaker> gabk, in general, when talking about "forcing" of values, it is to WHNF, which means "1 constructor deep"
05:07:38 <Peaker> gabk, so in your case, the strings would be forced as deep as possible needed to compare them for their position in the map
05:08:00 <Peaker> and the [Int] would be forced 1 constructor deep, that is, it would evaluate the outer-most list cons to (:) or [], and that's it
05:08:14 <Peaker> gabk, it would not force any actual Int value inside the map or the deeper (:)'s
05:08:24 <gabk> I see
05:08:41 <Peaker> gabk, The deepseq package lets you force "all the way down"
05:09:51 <Peaker> With "seq" you can say: "Return a value whose WHNF forcing causes another value to get WHNF forcing"
05:09:58 <Peaker> With "deepseq" you can say: "Return a value whose WHNF forcing causes another value to get fully normal form forcing"
05:12:47 <latermuse> Is there an easier way to do this? : head $ splitOn "</tag>" $ concat $ tail $ splitOn "<tag>" "Foo<tag>FooBar</tag>Bar"
05:13:46 <bxc> use an html library?
05:13:52 <opqdonut> use a regex?
05:14:01 <latermuse> bxc: I dont need an entire library for this. Its just a one-time use.
05:14:20 <Chathurga> If you're certain it's well formed then just use regex
05:14:50 <latermuse> Will regex perform better than the function I just composed?
05:14:50 <Nereid> better, use a parser
05:15:04 <bxc> latermuse: doesn't matter its a one-time use
05:15:06 <bxc> ;)
05:15:23 <latermuse> bxc: one-time-use, many times
05:15:27 <latermuse> :D
05:15:28 <bxc> heh
05:15:39 <bxc> sufficiently large value of 1
05:15:46 <latermuse> I meant that I only need this functionality in one place. But lots of data will be going through it.
05:15:47 <bxc> i'd probably do asomething in parsec because i like parsec
05:16:33 <bxc> or look what html parser libraries there already are
05:16:41 <bxc> i don't know any off the top of my head
05:17:14 <latermuse> ok, thanks :)
05:18:05 <bxc> regexp seems reasonable too
05:18:11 <bxc> but theres always that jwz quote
05:21:59 <gabk> Peaker: that worked perfectly thanks
05:22:08 <Chathurga> bxc: You're right parsec is probably better and funner
05:22:22 <Peaker> gabk, cool :)
05:22:39 <Chathurga> Regex has a tendancy to make everyone sad
05:23:56 <latermuse> regex makes php programmers happy
05:23:59 <Peaker> gabk, "deepseq" is unpopular: It requires all data types involved to have the NFData class instance, and in many cases, it will force much more than needed -- sometimes looping forever trying to force infinite lists.. Use it when you know exactly what the data is - that it is finite, and that you indeed want all of it
05:25:22 <gabk> yeah I see how that can be a problem
05:26:46 <deech> Hi all, is there any documentation on various extensions (eg. InCoherentINstances) besides the GHC manual?
05:28:23 <Philonous> Is there a way to see the number of running (haskell) theads from within a program?
05:28:53 <typoclass> Philonous: profiling maybe?
05:29:16 <eikke> Philonous: seems like something rather runtime-specific, #ghc might be of more help
05:29:30 <gabk> would I benefit in any way to use a strict map for this, since I force evaluation of all the arguments anyway?  perhaps it would use less memory, as it doesnt have to build thunks?
05:29:44 <gabk> from using*
05:29:52 <typoclass> deech: not sure, but the ghc manual is usually pretty complete and well-written. other than that, you could google for the extension name or ask in here
05:31:38 <Philonous> eikke:  #ghc is for ghc development, not for user questions.
05:33:47 <int-e> eikke: GHC.Conc exports getNumProcessors and getNumCapabilities - one of them might be what you want.
05:33:55 <int-e> err. Philonous:
05:34:16 <quicksilver> #ghc is a perfectly reasonable place to go for obscurish RTS/GHC questiosn
05:34:26 <eikke> Philonous: what quicksilver said
05:34:27 <merijn> int-e: Capabilities reports OS threads, not haskell threads
05:34:33 <quicksilver> however, I'm pretty sure the answer to Philonous's question is "No"
05:34:43 <eikke> int-e: that's not "currently running GHC threads", which is what Philonous is looking for I guess
05:34:44 <quicksilver> the RTS doesn't have any introspection calls to check the number of threads
05:34:57 <quicksilver> extrenally, however, threadscope is designed for this
05:35:05 <quicksilver> externally :)
05:35:28 <int-e> what's a "running GHC thread" anyway? threads get garbage collected all the time.
05:35:39 * int-e wonders
05:35:44 <quicksilver> a thread which is 'live' and eligible to run
05:35:46 <quicksilver> I suspect.
05:35:50 <int-e> (ok, not all the time.)
05:36:03 <quicksilver> but there are certainly different definitions of 'running' you might use
05:36:04 <Philonous> quicksilver:  Yes, that
05:36:10 <quicksilver> (you might or might not include threads blocked on IO, etc)
05:37:08 <int-e> (Sorry, I was temporarily mixing up sparks and threads.)
05:37:11 <Philonous> quicksilver:  I want to know whether may program is leaking threads. I guess threadscope will do
05:37:21 <Philonous> my*
05:37:51 <int-e> interestingly there is a numSparks in GHC.Conc
05:40:02 <neutrino> hi int-e
05:40:31 <neutrino> Philonous: i've had exactly the same problem two days ago
05:40:47 <neutrino> Philonous: compile with -debug and then run the program with +RTS -Ds
05:41:05 <neutrino> when you kill the program you should see the rts send async exceptions to all existing threads
05:41:21 <neutrino> that's how i've found out that my program is leaking threads
05:41:47 <Philonous> neutrino:  thanks
05:41:52 <neutrino> yw :)
05:47:26 * hackagebot Crypto 4.2.5.1 - Collects together existing Haskell cryptographic functions into a package  http://hackage.haskell.org/package/Crypto-4.2.5.1 (LennartAugustsson)
05:48:31 <neutrino> i'm so disappointed, it does not include "id".
05:49:26 <quicksilver> neutrino: clever trick
05:49:28 <neutrino> is there a reason the latest version doesn't have haddocks?
05:49:40 <quicksilver> yes, because that's a job that runs occassionally
05:49:44 <neutrino> right
05:49:50 <neutrino> quicksilver: what's a clever trick - id?
05:49:53 <quicksilver> if you look as soon as hackagebot announces it it inevitably hasn't run yet :)
05:49:54 <neutrino> best encryption ever
05:50:04 <quicksilver> RTS -Ds and watch the async exceptions
05:50:23 <neutrino> dunno if that's clever, i'm just a n00b :p
05:50:45 <neutrino> i read up on debugging flags, compiled it, looked at it, and it was pretty apparent
05:50:57 <neutrino> i guess it's something you must stumble upon, but takes no figuring out
05:51:09 <neutrino> definitely disavowing any mention of cleverness on my part
05:55:11 <neutrino> btw, i wonder if it's a good idea to put a few threads that have to do with i/o and communicate via Chans on the same capability
05:55:34 <neutrino> to get a "more deterministic" functionality
05:55:42 <neutrino> my english sucks today
05:56:13 <merijn> How so?
05:56:24 <merijn> What would that help?
05:56:48 <neutrino> then you're sure they're on the same capability
05:56:55 <neutrino> as opposed to maybe sometimes being and maybe sometimes not
05:56:58 <merijn> Yes, but what benefit would that bring?
05:57:01 <neutrino> it's not high throughput
05:57:22 <merijn> Why care where they run at all?
05:57:26 <neutrino> the benefit it would bring would be that i/o streams won't be able to go out of sync just as much
05:57:33 <neutrino> and i'm not depending on them being in sync
05:57:38 <neutrino> but it's a nice extra
05:58:57 <neutrino> they're basically reading from stderr/out of a subprocess, and trying to replicate the stream of chars that you'd get if you ran the thing directly in a terminal
05:59:16 <neutrino> i.e. how the stderr and stdout mingle when both are trying to write to the terminal at the same time
05:59:51 <neutrino> if they're on separate capabilities, e.g. stderr could get preempted while stdout runs steadily
06:00:29 <neutrino> and then the output of stderr experiences a "jerk", i.e. there's nothing for some time (while stdout is happily outputting) and then it dumps a big load all at once
06:00:37 <quicksilver> I don't think you're right, neutrino
06:00:39 <neutrino> (and at that point it probably has resynced with stdout)
06:00:45 <quicksilver> even on the same capability they can pre-empty each other
06:00:46 <neutrino> can you explain quicksilver?
06:00:47 <quicksilver> and they will.
06:00:49 <neutrino> sure
06:00:59 <neutrino> but it won't happen that one gets preempted while the other doesn't
06:01:12 <neutrino> within one capaibility the threads perform cooperative multitasking
06:01:19 <neutrino> between eachother
06:01:25 <neutrino> and preemptive multitasking against the world
06:01:37 <quicksilver> well they're not normally locked to a single capability though
06:01:43 <neutrino> i know
06:01:47 <neutrino> but you can do that
06:01:50 <quicksilver> anyhow, my answer to your question is "No, that wouldn't be a good thing"
06:02:00 <quicksilver> "more determinism" is a horrendous idea
06:02:06 <neutrino> why
06:02:06 <quicksilver> you either want determinism, or not
06:02:11 <quicksilver> and if you want it, program it.
06:02:26 <neutrino> the world is only black and whit?
06:02:27 <neutrino> e
06:02:31 <quicksilver> "slightly higher probability of desirable behaviour" is a poor compromise
06:02:37 <quicksilver> my world is very black and white yes.
06:02:43 <neutrino> why is it a poor compromise?
06:02:46 <quicksilver> If you care about it enough to want it, then make it happen for sure.
06:03:00 <neutrino> i only care about it enough to want it to happen most of the time
06:03:09 <quicksilver> dont' just increase the probability slightly so that you come to rely on it and then some external change ruins it all
06:03:24 <neutrino> i don't care about it enough to ensure it happens 100% certainly with backups and failovers and an insurance policy and twenty nines uptime
06:04:07 <`nand`> Loading package base ... linking ... ghc: /usr/lib64/ghc-7.6.1/base-4.6.0.0/HSbase-4.6.0.0.o: unknown symbol `stat'
06:04:09 <`nand`> ghc: unable to load package `base'
06:04:15 <`nand`> Is this a known error? Package vector-0.10.0.1
06:04:48 <neutrino> @hoogle stat
06:04:49 <lambdabot> Control.Monad.State module Control.Monad.State
06:04:49 <lambdabot> Control.Monad.Trans.State module Control.Monad.Trans.State
06:04:49 <lambdabot> Graphics.UI.GLUT.State module Graphics.UI.GLUT.State
06:04:56 <neutrino> hrm.
06:05:12 <neutrino> quicksilver: why do you think it's just a slight increase?
06:05:15 <neutrino> and not a full increase?
06:05:44 <neutrino> like, what makes you think it'll ever not work? i'm having a hard time coming up with such a situation
06:07:51 <merijn> neutrino: Experience with concurrent programming, lightweight threading and scheduling has taught me "if it can, theoretically, go wrong at some point, it *will* fail in any non-debugging run and work fine while debugging"
06:08:09 <neutrino> haha
06:08:13 <neutrino> yeah, i guess.
06:08:18 <merijn> neutrino: That's not a joke
06:08:24 <neutrino> but, it's not a crucial element
06:08:30 <neutrino> so i don't care if it fails
06:08:38 <neutrino> but if it doesn't, it's nice
06:08:49 <quicksilver> well I probably don't understand what you're saying, neutrino
06:08:49 <merijn> I have so far encountered 6 bugs that were completely unreproducable inside GDB and appearing with probability >0.5 outside GDB
06:09:15 <quicksilver> but just because you have stdout and stderr on the same cap you have no real guarantees how their output will interleave or not
06:09:30 <merijn> Because GDB subtly fucks with scheduling behaviour of threads in your application
06:09:37 <quicksilver> no reason why you might not get 8000 bytes of stderr and then 1 byte of stdout and then another 8000 bytes of stderr
06:09:37 <neutrino> quicksilver: can you describe what you understood?
06:09:55 <quicksilver> you seemed to be saying that pre-emption in the middle of output would be more predictable
06:10:03 <neutrino> well, no
06:10:31 <neutrino> what i mean is that if the stderr relay is on another capability than stdout, then one of them can get preempted while the other doesn't
06:11:38 <neutrino> whereas when they're on the same capability, the only situation when this will happen is if one of them is taking its turn
06:12:03 <neutrino> i guess here i'm assuming that if you have two threads on the same capability, they'll roughly go 1 2 1 2 1 2
06:12:10 <gabk> I was under impression that concurrency is easy in haskell due to separation of pure and impure code. am I deluded?
06:12:11 <neutrino> i wonder what the real situation is
06:12:29 <neutrino> no it's easy
06:12:43 <neutrino> if this were C++ i wouldn't have any idea where to start describing the issue
06:12:53 <Ke> concurrency is easy, because it's a high level language
06:13:39 <shapr> Yay! Colin Runciman and Rob Noble agreed to a BSD license for Gadgets, their ~18 year old windowing system written for Gofer!
06:13:56 <shapr> Now hOp/House/LightHouse can be released with a consistent BSD license!
06:14:18 <neutrino> nice
06:14:23 <neutrino> i was just looking at House today
06:14:33 <neutrino> they have their own haskell runtime, right?
06:14:48 <neutrino> one without a GC
06:15:27 <`ramses> you have to do explicit memory management>
06:15:37 <`ramses> s/>/?
06:15:40 <neutrino> that's what i heard
06:16:02 * `ramses wonders how that syntax would look
06:17:16 <typoclass> shapr: house is the effort at writing an OS in haskell, isn't it? what's lighthouse?
06:17:31 <neutrino> yes
06:18:25 <neutrino> i can only find: Haskell LIGHT (Lutheran Indians
06:18:26 <neutrino> Gathering and Helping Together)
06:18:30 <latermuse> why not build an OS on top of xmonad?
06:18:44 * Hafydd snorts.
06:18:54 <`nand`> house uses the GHC RTS iirc
06:18:55 <shapr> typoclass: LightHouse is the extended remix of House
06:19:02 <`nand`> but modified
06:19:29 <typoclass> shapr: interesting, i can has link?
06:19:38 <neutrino> yeah, this link implies that lighthouse is aversion of house http://www.haskell.org/haskellwiki/House
06:19:38 <`nand`> “An additionl 500 lines of C and 150 lines of assembler were hadded to version 6.2 of the standard GHC runtime system to support booting on a bare machine and to set up paging.”
06:19:44 <neutrino> there's a git link there
06:20:01 <shapr> typoclass: Kenneth Graunke did his Master's thesis extending House to LightHouse.
06:20:04 * shapr gets url
06:20:16 <neutrino> web.archive.org/web/20110618203119/http://web.cecs.pdx.edu/~kennyg/house/
06:20:19 <shapr> Here it is: http://dr.archives.pdx.edu/xmlui/bitstream/handle/psu/4720/Graunke_psu_0180E_10019.pdf
06:20:37 <eikke> I've been thinking lately it might be interesting to get people to work together on this, cross-language/runtime
06:20:40 <shapr> typoclass: There's Kenny's master's thesis link.
06:20:41 <eikke> for the lowest parts that is
06:20:48 <`nand`> `ramses: house does ‘explicit memory management’ in that it does paging and allocation for other haskell processes
06:21:16 <shapr> So after finals I can put LightHouse on github with an explicit BSD license, yay!
06:21:26 <typoclass> shapr: very nice, thanks
06:21:27 <neutrino> `nand`: how is that different from not having a gc?
06:21:34 <shapr> I'm everyone knows how much I like saving old Haskell sources that could turn into awesome new projects :-)
06:21:42 <eikke> there are several projects doing "Some FP language on Xen", including OCaml (Mirage), Haskell (HalVM), Erlang (cant remember the name), they all need +- the same 'lower grounds'
06:21:45 <neutrino> shapr: :)
06:21:59 <`ramses> `nand`: and house's memory is handled by low level c code in the runtime then?
06:22:23 <neutrino> eikke: are you making the JVM of this decade
06:22:25 <`nand`> `ramses: The GHC runtime does memory management. Don't quote me on this though, I haven't really looked at house; just did a quick glance of the pdf
06:22:44 <`ramses> ok, so it does all run with gc :)
06:22:47 <eikke> neutrino: hah, no thanks :P
06:23:16 <eikke> neutrino: then I wouldn't use x86 as base system... I mean, seriously... setting up all those subsystems is... not pretty :P
06:23:16 <`ramses> just a little more complicated then plain ghc on top of an os
06:23:44 <neutrino> that is good to know
06:24:18 <`nand`> `ramses: I would guess that the RTS the OS uses is independent of the RTS the programs use, if any; it supports arbitrary x86-or-whatever processes, doesn't it?
06:24:46 <gabk> if parsing is the bottle neck rather than IO would I benefit from using more than one thread and then merge the resulting Map.Maps ?
06:24:51 <`nand`> so if you ran a haskell program on house; it might be that the haskell program compiled with GHC has its own RTS and own garbage collection; independent of the resources the operating system used to load it into memory + set up its pages
06:25:09 <`ramses> `nand`: yeah, sure, would be quite painful if the kernel would crash with every misbehaving process :)
06:25:51 <`ramses> as it would with a single RTS
06:27:51 <neutrino> gabk: there's a function somewhere which takes two lazy lists and evaluates them in parallel to create one list.
06:27:57 <neutrino> gabk: but i forgot what it's called.
06:28:09 <neutrino> @hoogle [a] -> [a] -> IO [a]
06:28:10 <lambdabot> Control.Concurrent mergeIO :: [a] -> [a] -> IO [a]
06:28:10 <lambdabot> Prelude (++) :: [a] -> [a] -> [a]
06:28:10 <lambdabot> Data.List (++) :: [a] -> [a] -> [a]
06:28:15 <neutrino> mergeIO perhaps
06:28:24 <`ramses> but I'm wondering whether the low level RTS can be garbage collected while it handles the raw low level memory. Sounds a bit like a contradiction
06:28:48 <neutrino> @hoogle [[a]] -> IO [a]
06:28:48 <lambdabot> Control.Concurrent nmergeIO :: [[a]] -> IO [a]
06:28:48 <lambdabot> Prelude concat :: [[a]] -> [a]
06:28:49 <lambdabot> Data.List concat :: [[a]] -> [a]
06:28:50 <`ramses> it probably just calls out to some native code
06:29:00 <neutrino> nmergeIO is preferred, mergeIO is deprecated gabk
06:29:22 <gabk> thanks
06:29:27 <neutrino> yw
06:30:34 <gabk> I am creating Map.Map though so I dont think I can use that
06:31:25 <gabk> or did you mean to create [(key, value)] lazy list?
06:31:38 <neutrino> yeah, you can just toList the map and then do that
06:32:14 <neutrino> however
06:32:18 <neutrino> Deprecated: Control.Concurrent.nmergeIO will be removed in GHC 7.8. Please use an alternative, e.g. the SafeSemaphore package, instead.
06:43:46 <invariant> What's the point of providing functionality in one release and then removing it in another?
06:44:11 <invariant> (other than scaring away potential users)
06:44:19 <Eelis> invariant: i would guess that it typically happens when at the time the functionality is added, it is not yet known that there are better ways to do it
06:45:08 <invariant> Eelis, given the same type signature, they did not invent a better way to do it and if they did, they could simply have kept the API.
06:45:46 <invariant> Eelis, the new and old method could easily be provided at the same time too.
06:45:47 <Eelis> invariant: with "better ways" i mean ways that involve changing to a completely different API
06:46:06 <invariant> Eelis, still no reason to remove an API.
06:46:16 <Eelis> i disagree
06:46:42 <invariant> Eelis, with your setup you are never done.
06:46:47 <Eelis> that is correct
06:46:51 <Eelis> software is never done
06:46:52 <merijn> invariant: The change is to move API bloat out of GHC and into separate libraries, allowing for fixes, updates and tweaks separate from the GHC code base
06:47:58 <invariant> Eelis, software is never done? Aren't you the big Coq user?
06:48:08 <merijn> invariant: GHC should not include more primitives than is strictly necessary, other packages should be responsible for implementing useful features on top of those primitives, rather than doing so directly in GHC and increasing the maintenance load of the GHC programmers
06:48:20 <invariant> Eelis, with Coq software is done the moment it works and you proved it to be correct.
06:48:28 <merijn> invariant: Well, if your software is done, why bother upgrading the compiler you're using?
06:48:34 <Eelis> invariant: nope, Coq releases stuff from their stdlib as well
06:48:38 <Eelis> s/releases/removes
06:48:48 <invariant> merijn, people have known this for over 30 years.
06:49:23 <invariant> merijn, because new platforms don't ship old compilers?
06:50:00 <sopvop> software is never done
06:50:04 <merijn> invariant: You either freeze your software or you maintain it, if it's frozen why care that newer compilers change things, if you maintain it then it's a completely minor thing that makes everyone's future lives easier
06:50:09 <sopvop> only dead software stops evolving
06:50:43 <invariant> merijn, please explain how one can get GHC version 2 to run on the latest Arch Linux.
06:50:58 <merijn> Well you can't get anything to run on Arch anyway
06:51:20 <invariant> merijn, uh, what?
06:51:31 <merijn> I find it mildly amusing that someone arguing *against* aggressive deprecation is bringing up Arch as an example...
06:51:59 <`nand`> GHCi crashes on startup with “unknown symbol `stat' in HSbase-4.6.0.0.o”
06:52:07 <merijn> Considering they're the people who switched to python 3 and GHC 7.6 as default versions long before they were supported by the majority of the libraries
06:52:14 <invariant> merijn, Arch continues to provide a POSIX implementation or something fairly close to it.
06:52:58 <invariant> merijn, python 3 is just as much a bad idea.
06:53:08 <merijn> invariant: That's not really going to convince me, the fact that we're all still stuck against the lowest common denominator of POSIX is one the biggest issues holding back the systems field
06:53:11 <`nand`> GHC works fine though
06:53:20 <merijn> invariant: Then why did Arch adopt it as default?
06:53:41 <ClaudiusMaximus> `nand`: http://hackage.haskell.org/trac/ghc/ticket/7072
06:53:55 <invariant> merijn, I don't know, but Intel provides the assembly language which is an incredibly stable target.
06:54:20 <invariant> merijn, as such, you don't have to depend on POSIX for your language run-time other than to get it to build.
06:54:34 <Eelis> merijn: i would even argue that once HoTT-based Coq matures, a large fraction of old Coq programs should probably be thrown out and rewritten
06:54:38 <Eelis> sorry, that was for invariant
06:54:47 <merijn> invariant: Ha!
06:54:54 <`nand`> ClaudiusMaximus: I saw that. Why does it work on some of my machines, but not all?
06:55:15 <merijn> invariant: You mean the language they attempted to deprecate in IA-64 and is largely disused by people working on x86_64 platforms? That one?
06:55:36 <ClaudiusMaximus> `nand`: dunno
06:56:21 <neutrino> invariant: if you think people doing anything serious in x86 see it as a stable target, you haven't spoken to many people
06:56:59 <neutrino> here's just a few things that completely changed how people program for your stable target:
06:57:02 <neutrino> - numa
06:57:03 <invariant> neutrino, they only managed to provide a stable language for about 25 years or so now.
06:57:03 <merijn> Hell, even C keeps introducing changes in the standard that break things in the migration from older versions
06:57:05 <neutrino> - caching
06:57:28 <neutrino> - cache validation and expunging strategies
06:57:35 <invariant> Haskell hasn't been able to provide a stable language for one year.
06:57:36 <neutrino> - speculative multithreading
06:57:41 <merijn> invariant: If you think nothing has changed about x86 ASM in the past 25 years I recommend you study more x86 ASM
06:57:48 <neutrino> - mmx, sse
06:57:56 <invariant> merijn, old code still works.
06:57:56 <merijn> invariant: See neutrino's list of changes, for one
06:57:57 <neutrino> - speed of ram
06:58:01 <neutrino> and so on.
06:58:06 <invariant> merijn, I didn't say no additions had been done.
06:58:21 <neutrino> if you think x86 is in any way a stable platform, you've never actually used it.
06:58:30 <merijn> invariant: Not just additions, but changes that alter semantics in way that may cause unexpected behaviour of existing code...
06:58:40 <invariant> merijn, show me.
06:59:06 <merijn> Changes to caching strategies drastically affect runtimes of your program
06:59:18 <Hafydd> I like how invariant's nick matches their opinion.
06:59:30 <invariant> merijn, that's not specified behaviour.
06:59:36 <neutrino> too bad it's not const TRue
06:59:37 <merijn> Anyway, keep believing what you wish. I should really be writing my paper instead of arguing on IRC
06:59:39 * typoclass thinks whatever the situation with x86 or c or arch linux, haskell is unfortunately on the more unstable end of the spectrum
06:59:40 <invariant> merijn, if you depend on it, that's your problem.
07:00:01 <merijn> typoclass: I don't necessarily consider that a problem
07:00:02 <invariant> merijn, so, in the end, you have no actual argument?
07:00:03 <neutrino> it's more like const StdRand
07:00:06 <neutrino> :p
07:00:18 <merijn> invariant: All code depends on unspecified behaviour in the end
07:00:27 <invariant> merijn, completely wrong.
07:00:30 <fmap> typoclass: you meant to say fortunately?
07:00:38 <merijn> invariant: You can't write software without doing that, but that is a much longer discussion I can't have right now
07:01:03 <neutrino> merijn: i think invariant is just hung up on this whole concept of how things should be ideally, and has not yet given it up for the realization that the real world is not ideal. we've all been there. no reason to dislike him for that, but there's little we can do to change his mind about it
07:01:04 <invariant> Almost everyone who has said that you cannot do X has been wrong.
07:01:23 <neutrino> it's natural for a computer programmer to want ideal things.
07:01:40 <invariant> neutrino, you only need to show some assembly language that evaluates to something different now then it did in 1990 or so.
07:01:45 <merijn> neutrino: I'm not saying I dislike him, but my supervisor wants to start and finish a paper *today*, so I really shouldn't procrasinate in here
07:01:48 <neutrino> however, it's also naḯve
07:01:57 <invariant> neutrino, that should be trivial for anyone who is supposedly a compiler expert.
07:02:17 <neutrino> i'm a compiler expert?
07:02:21 <neutrino> that made my day
07:02:25 <invariant> neutrino, no
07:02:25 <neutrino> i'll go celebrate
07:02:36 <invariant> neutrino, and neither is merijn.
07:02:36 <CuteAngel24> ok, all I need is undocumented opcodes, no?
07:02:43 <invariant> CuteAngel24, wrong.
07:02:52 <invariant> CuteAngel24, undocumented means it has no semantics.
07:02:53 <Hafydd> What's an appropriate drink to celebrate being a compiler expert?
07:02:59 <CuteAngel24> invariant: hah
07:03:05 <neutrino> i was just typing /me passes the Champagne around
07:03:08 <typoclass> fmap: "unfortunately" in the sense that it's annoying that 1-year-old haskell code is unlikely to still compile with a current ghc and libraries. i don't think it's completely terrible, but it's annoying and creates maintenance burden
07:03:41 <neutrino> but i'm not sure if the bubbles undergo proper confluence
07:03:45 <fmap> typoclass: well, that's what you get choosing research language I guess..?
07:04:10 <invariant> Haskell isn't really a research language anymore.
07:04:26 <invariant> Nothing has been done first for a long time in Haskell.
07:04:29 <neutrino> typoclass: yeah, it is annoying. i wish it weren't like this. but i don't think that keeping old api's around is the solution. it's a solution.
07:05:16 <neutrino> typoclass: one other way to solve it would be to have compatibility layers, that you specifically have to opt into
07:05:23 <merijn> I'm not a compiler expert? But I'm getting paid to hack on compilers :(
07:05:31 <merijn> Well, partially anyway...
07:05:34 <neutrino> merijn: shush, the compiler experts are talking
07:05:48 <neutrino> :))
07:06:03 <invariant> merijn, you could have provided an intelligent reply when you had the chance.
07:06:50 <typoclass> can you please keep it civil
07:06:50 <invariant> It just shows that Haskell has no serious commercial users willing to share the code to make it work.
07:06:52 <neutrino> invariant: i kind of think youre sort of heated up. take some time to cool down.
07:07:10 <invariant> Perhaps some organizations do these kinds of things internally.
07:07:14 <neutrino> my day job is writing haskell for external clients
07:07:26 <neutrino> works for me
07:07:27 <merijn> I just don't work on compilers that generate ASM, so my experience with ASM is orthogonal to my compiler knowledge
07:07:28 <invariant> neutrino, and it will remain your job since Haskell changes all the time.
07:07:33 <neutrino> yes
07:07:37 <neutrino> jobSecurity++
07:07:42 <invariant> neutrino, from your point of view I understand there is no problem.
07:07:59 <latermuse> my day job is porting php code to haskell *cry*
07:07:59 <neutrino> lock 'em in and bleed them dry
07:08:01 <invariant> For me, I advise people to stay away from systems that change for no good reason.
07:08:20 <neutrino> latermuse: at least you're not going the other way
07:08:21 <merijn> invariant: Ah, so which systems do you recommend?
07:08:26 <neutrino> latermuse: what is that, for facebook?
07:08:34 <neutrino> merijn: x86.
07:08:48 <latermuse> neutrino: No, i dont work for facebook. Just a small boutique company
07:09:03 <neutrino> i wonder...
07:09:03 <invariant> merijn, why should I tell you? You are not telling me anything remotely interesting.
07:09:06 <neutrino> @google x86 web framework
07:09:08 <lambdabot> http://www.microsoft.com/en-us/download/details.aspx?id=17113
07:09:08 <lambdabot> Title: Download Microsoft .NET Framework 4 Client Profile (Web Installer) from Official ...
07:09:13 <neutrino> nah.
07:09:20 <merijn> neutrino: Well, he might have an actually sound recommendation, so I'm genuinely interested
07:10:10 <merijn> neutrino: Or he's going to call me names, whatever.
07:10:17 <Chathurga> latermuse: How did you convince a boutique to witch from PHP to Haskell? That sounds like the most bizarre situation
07:10:30 <Chathurga> *switch
07:10:31 <CuteAngel24> witchery
07:10:52 <Clint> a fractal of bad witchery
07:11:01 <merijn> Chathurga: "I could fix this in PHP for you for $X, or I could reimplement this things in Haskell for $Y", just make sure X < Y by some significant fraction
07:11:13 <merijn> Chathurga: Eh, Y < X, obviously
07:12:00 <Chathurga> The PHP price included a large settlement for "pain and suffering" I presume
07:12:07 <smiler> I'm having trouble installing lamdbabot through cabal. It fails on building Boolian-0.1.1: https://gist.github.com/4268535
07:12:21 <neutrino> Chathurga: switching to haskell is a businesswise sound solution, it's not like 10 years ago
07:12:25 <merijn> Chathurga: If you're sufficiently proficient in Haskell you could probably implement many web things in a smaller time frame. And, of course, the pain and suffering premium applies
07:12:54 <neutrino> there's no reason to come up with comically silly argumentation like "suffering premium"
07:12:54 <osfameron> PHP has rather more pre-built components though
07:13:08 <osfameron> want a wiki?  a comment system?  an e-commerce system?  a CRM tool?
07:13:51 <osfameron> i.e. with PHP you may not have to "implement" anything, only customize it
07:14:07 <osfameron> (I am *not* a PHP fanboy by any means, but jus' saying)
07:14:11 <neutrino> yeah, but often you want a dog while you get the butcher's bucket taped together with clear tape to resemble a dog
07:14:22 <fmap> smiler: you may need older version of Boolean
07:14:32 <smiler> fmap: Hmm ok
07:14:42 <merijn> osfameron: As the haskell ecosystem grows that argument will become less relevant, of course. In fact you could develop said components for your first client (taking a loss on the price vs time) and then resell the same component to others
07:14:44 <neutrino> over nearly a decade of using php as a major tool in my toolkit i've done this realization over and over
07:14:59 <fmap> smiler: presumably you are using ghc 7.4?
07:15:40 <smiler> fmap: 6.12. Debian default.
07:15:44 <fmap> oh
07:15:54 <Nereid> 6.12 is aaaaaaancient
07:16:01 <smiler> Nereid: So is debian >_<
07:16:14 <JCaesar> "debian stale"
07:16:19 <Nereid> :p
07:16:54 <osfameron> merijn: it might.  but even with Perl, say, which *does* have a huge ecosystem, there aren't necessarily good alternatives to large frontend ecosystems like mediawiki, wordpress, civicrm, woocommerce, ...
07:18:20 <fmap> smiler: easy way is "cabal install lambdabot --constraint='Boolean == 0.0.1'" but I'm unsure whether it's gonna work with your cabal-install tbh
07:18:27 <neutrino> latermuse: still around? :)
07:19:32 <smiler> fmap: Naw, won't work. Other packages have a hard dependency on >=0.1.0.
07:19:41 <smiler> Maybe I'll have to look into building a never ghc
07:19:58 <neutrino> it's easy, just install the latest hp
07:22:43 <smiler> neutrino: Doesn't look that easy. I don't see any binary distribution of it.
07:24:52 <applicative> smiler you saw http://www.haskell.org/ghc/download_ghc_7_6_1#x86linux
07:25:30 <smiler> Naw, I went for the haskell-platform thingy
07:25:43 <smiler> I'll have a look at that.
07:26:09 <applicative> http://www.vex.net/~trebla/haskell/haskell-platform.xhtml tells you how to add the rest.
07:27:25 <applicative> smiler your old cabal-install may work still with this ghc, I'm not sure
07:28:03 <smiler> I could upgrade cabal-install to the latest version without problem. Thing went south first when I tried to build other stuff :)
07:28:30 <Swineflu> Hello #haskell, I am looking for a set of haskell programming tasks I can complete over xmas that will start off at beginner level and rack up harder and harder?
07:29:37 <epta> Swineflu: http://www.haskell.org/haskellwiki/H-99:_Ninety-Nine_Haskell_Problems
07:29:47 <Swineflu> Boom
07:29:48 <Swineflu> Thank you
07:30:55 <quchen> epta: I find some of the problems given in RWH useful.
07:31:02 <fmap> smiler: note that you probably don't want 7.6.1 since lambdabot doesn't build on it
07:31:09 <Swineflu> RWH?
07:31:32 <quchen> The problem with 99 Haskell problems, Project Euler etc. is usually that they don't really go into abstract stuff very much.
07:31:34 <smiler> fmap: Bummer.
07:31:42 <quchen> Swineflu: Real World Haskell
07:31:47 <quchen> @url rwh
07:31:48 <lambdabot> http://www.realworldhaskell.org/blog/ http://book.realworldhaskell.org/read/
07:31:48 <Swineflu> I'm taking a functonal programming class after xmas... I mainly want to highlight how functional "works"
07:32:28 <quchen> Swineflu: Do you know any specifics about the language that course will use?
07:32:51 <Swineflu> Ehh, Lots of typing judging by the guy who wrote it
07:33:30 <quchen> Lots of typing? I don't understand
07:34:49 <Swineflu> The guy who wrote the course is a quite well known reseacher in the type theory area
07:34:53 <smiler> fmap: vector-space-0.8.6 needs Boolean >= 0.1.0. Do you know if there's any version that is satisfied with 0.0.1?
07:35:08 <Swineflu> So i reckon he'll use lots of weird type stuff
07:36:11 <latermuse> swineflu: weird type stuff is interesting. make sure you know the basics before the class though, or you wont understand anything
07:36:18 <applicative> Swineflu: I take it you saw 'learn you a haskell'
07:36:22 <applicative> @where lyah
07:36:23 <lambdabot> http://www.learnyouahaskell.com/
07:36:31 <Swineflu> Yea
07:36:33 <Swineflu> I've been reading that
07:36:48 <fmap> ?hackage vector-space
07:36:48 <Swineflu> The guy who wrote the class created a language called Epigram
07:36:48 <lambdabot> http://hackage.haskell.org/package/vector-space
07:36:52 <applicative> It explains some fairly abstract stuff by the time your done
07:36:57 <applicative> !!!!!!!!!!!!
07:37:03 <applicative> Swineflu: awesome
07:37:08 <Philonous> Swineflu:  McBride?
07:37:10 <Swineflu> Yep
07:37:17 <applicative> amazing
07:37:30 <Philonous> Swineflu:  You're lucky
07:37:56 <Swineflu> I'm not really a functional guy but the guy seems to be a legend so might aswell make the most off it
07:38:29 <latermuse> swineflu: why corner yourself into one paradigm of study?
07:38:39 <Swineflu> I agree
07:38:53 <applicative> especially when you can have conor mcb as a teacher
07:40:06 <latermuse> Swineflu: I recommend you learn as much as possible about type system before your class. Then you might actually learn something unique from mcbride that you might not be able to get easily elsewhere.
07:40:25 <Swineflu> I'm taking his functional classes for the next 2 years anyway
07:40:32 <latermuse> still
07:40:37 <Swineflu> but yes
07:40:40 <Chathurga> Swineflu: I said It's not the way I think until I started learning, I was completely hooked within a few hours
07:42:20 <Swineflu> His course work is so well thought out
07:42:42 <mm_freak> when enabling 'shared' in ~/.cabal/config, everything gets built twice…  why is that?
07:42:55 <dcoutts> mm_freak: both static and dynamic libs
07:42:59 <mm_freak> i would understand linking twice, but compiling twice?
07:43:12 <dcoutts> mm_freak: you can independently turn them on/off
07:43:56 <dcoutts> mm_freak: plus, sometimes it has to build twice anyway, e.g. if you're using TH, then we always have to build the way that is needed for ghci/th
07:44:55 <mm_freak> dcoutts: why does it /compile/ twice?  when i do the same in, say, C, i compile once and link twice (actually i only link once and for the static version i use 'ar')…  i'm not using TH
07:45:01 <dcoutts> mm_freak: the way they get compiled is different, not just a matter of linking differently
07:45:06 <dcoutts> mm_freak: that's true even in C
07:45:06 <mm_freak> i see
07:45:20 <CuteAngel24> gcc -fPIC
07:46:44 <Swineflu> Would attempting to write a web application in Haskell make me kill myself?
07:46:49 <dcoutts> mm_freak: well, ok ELF can hack things so that the C compiler doesn't have to generate different code for accessing symbols in a different DSO, but it's better if it does
07:47:13 <dcoutts> Swineflu: no :-)
07:47:22 <mm_freak> dcoutts: my own humble explanation was that for the shared version inter-package optimizations get turned off
07:47:45 <dcoutts> mm_freak: nope, no change there, still full inter-package optimization
07:47:46 <mm_freak> Swineflu: attempting to write a web application in haskell will make you kill yourself, when you have to go back to PHP
07:47:56 <dcoutts> :-)
07:48:14 <latermuse> I write web apps in haskell and php. Its not so bad
07:48:18 <dcoutts> mm_freak: which incidentally explains why we have interesting ABI issues :-)
07:48:38 <mm_freak> dcoutts: yeah =)
07:48:50 <Swineflu> Might do my webdev class in haskell since we can choose a language, They teach PHP but I've been writing PHP for years
07:48:57 <mm_freak> latermuse: i suppose if you have written a haskell-to-PHP compiler it's indeed not so bad
07:49:03 <Swineflu> Wonder if the lecturer will get pissed at me
07:49:06 <epta> >  Then you might actually learn something unique from mcbride that you might not be able to get easily elsewhere. <--- for example?
07:49:07 <lambdabot>   <hint>:1:113: parse error on input `<---'
07:49:31 <dcoutts> Swineflu: depending on what you're doing, you can use one of the full-fledged frameworks, or something really really simple like httpd-shed, which is designed for teaching
07:49:40 <mm_freak> Swineflu: i wouldn't care…  you can demonstrate the wonderful world of haskell to the citizens of the ugly planet PHP
07:49:55 <latermuse> mm_freak: a haskell to php compiler defeats the point of php.
07:49:57 <mm_freak> Swineflu: it's an opportunity to increase the popularity of haskell for this kind of task
07:50:09 <fmap> smiler: sorry, got distracted; dependencies for every project are listed on hackage page
07:50:20 <mm_freak> latermuse: not necessarily…  it's a practical matter of not having the ability to deploy haskell web apps everywhere
07:50:51 <mm_freak> dcoutts: i would use one of the full-fledged frameworks even for simple stuff
07:51:05 <fmap> smiler: so you may see that first vector-space version that does not depend on Boolean >= 0.1.0 is vector-space-0.8.2, for example
07:51:11 <mm_freak> snap is simple enough to demonstrate the core concept of compositionality and can be understood by most PHP programmers
07:51:21 <latermuse> mm_freak: the benefits of php are in how loose it is in everything it does. You lose all that when you compile haskell to php. Haskell to javascript is a better choice for portability anyways.
07:51:22 <smiler> fmap: Aha ok. Thanks :)
07:51:51 <Swineflu> Haskell to ASSEMBLER
07:52:02 <mm_freak> latermuse: do you actually "lose" something?  i look at it as winning something
07:52:04 <dcoutts> mm_freak: take a look at the api: http://hackage.haskell.org/packages/archive/httpd-shed/0.4/doc/html/Network-Shed-Httpd.html
07:52:17 <dcoutts> mm_freak: there's a place for extreme simplicity sometimes
07:52:26 <mm_freak> type Server = ()
07:52:27 <mm_freak> lol
07:52:49 <mm_freak> Swineflu: you have haskell to assmebler…  that's what GHC does on x86, ppc and ARM
07:53:12 <latermuse> mm_freak: You lose the flexibility of php by using the type system and strictness of haskell
07:53:15 <Chathurga> Can someone help me concpetualize something, let's say I have points in a square grid. How do I calculate all the routes between two points? every time I try to map it out in my head I break down
07:53:30 <mm_freak> latermuse: you lose the flexibility to write "3" == 3
07:53:32 <wereHamster> what's the bot/command which cna simplify expressions?
07:53:37 <mm_freak> latermuse: i view that as winning things
07:53:41 <latermuse> mm_freak: php is pretty awful, but it is a pretty good awful language
07:53:49 <latermuse> pretty good (awful language)
07:53:56 <CuteAngel24> Chathurga: including cycles?
07:54:02 <mm_freak> latermuse: you lose everything you get in haskell by using PHP
07:54:15 <latermuse> mm_freak: if you dont have "3" == 3, then you lose the essence of php. its not php if you cant do ridiculous stuff like that
07:54:26 <applicative> wereHamster: simplify?
07:54:31 <mm_freak> types, libraries, a (mostly) sane API, short code
07:54:36 <Chathurga> No it's simpler, there's no back tracking so at least the x or y position has to increase until you're at the lower right of the grid
07:54:38 <applicative> > 1 + 2
07:54:39 <lambdabot>   3
07:54:41 <mm_freak> everything written in PHP seems to be awfully long and unreadable
07:54:58 <mm_freak> latermuse: well, if you will, you can do "3" == 3 in haskell as well, but it's a very bad idea
07:55:08 <Swineflu> I find PHP very readable compared to haskell
07:55:09 <wereHamster> applicative: I think @pl is what I'm after
07:55:12 <latermuse> mm_freak: lots of imperative languages have long and unreadable code
07:55:19 <CuteAngel24> Chathurga: so you have delta(x) rights and delta(y) downs, and you want all permutations?
07:55:25 <applicative> that was going to be my next suggestion
07:55:30 <Chathurga> Yes exactly
07:55:31 <mm_freak> Swineflu: how long do you need to understand two nested loops over 20 LOC?
07:55:43 <CuteAngel24> :t permutations
07:55:45 <lambdabot> [a] -> [[a]]
07:55:47 <CuteAngel24> :t replicate
07:55:49 <lambdabot> Int -> a -> [a]
07:55:50 <Swineflu> So the "G" in ghc stands for Glasgow
07:55:51 <mm_freak> Swineflu: notably /not/ written by yourself
07:55:59 <latermuse> mm_freak: Yeah, but "3"==3 in haskell is different from "3"==3 in php. Its useful in php for quick imperative prototyping (at the cost of readability, maintenance, and performance).
07:56:02 <Swineflu> mm_freak, depends on who wrote it
07:56:12 <b_jonas> > 3 == "3"
07:56:13 <lambdabot>   No instance for (GHC.Num.Num [GHC.Types.Char])
07:56:13 <lambdabot>    arising from the literal ...
07:56:22 <mm_freak> Swineflu: written by a good programmer
07:56:32 <Swineflu> idk a few mins?
07:56:34 <wereHamster> hm, \x a b c d -> (((x + a) * b) + c) * d doesn't look any simpler in its pointfree version :-/
07:56:36 <Chathurga> CuteAngel24: Ugh of course, all my manual efforts have failed that's so much more elegant!
07:56:40 <Chathurga> Thank you
07:56:42 <applicative>  @pl \f x -> f x x
07:56:50 <applicative> @pl \f x -> f x x
07:56:51 <lambdabot> join
07:57:08 <b_jonas> @pl \x a b c d -> (((x + a) * b) + c) * d
07:57:09 <lambdabot> ((((((*) .) . (+)) .) . (*)) .) . (+)
07:57:15 <Swineflu> I don't edit other peoples code alot
07:57:17 <applicative> wereHamster: I'm not sure simplification is what it's about
07:57:20 <b_jonas> @@ @unpl @pl \x a b c d -> (((x + a) * b) + c) * d
07:57:20 <lambdabot>  (\ f o r u -> (*) (((f + o) * r) + u))
07:57:49 <latermuse> It takes me roughly an hour to read and understand 100 lines of C or php code
07:58:05 <mm_freak> Swineflu: the same nested loops written as a composition of folds likely is a two- or three-liner in haskell (two lines of PHP hardly do anything in average), and i mostly understand instantly what the composition does…  compositional programming has the advantage that you can view things in isolation
07:58:19 <b_jonas> @@ @unpl @pl @unpl @pl \x a b c d -> (((x + a) * b) + c) * d
07:58:19 <lambdabot>  (\ f o r u -> (*) (((f + o) * r) + u))
07:58:27 <mm_freak> Swineflu: even a single loop in PHP is difficult to understand, because you need to keep track of everything, global state, local variables, side effects, etc.
07:58:38 <Taneb> Are there any generalizations of unfoldr?
07:58:47 <mm_freak> Taneb: anamorphisms
07:58:50 <Taneb> class Unfoldable t where...
07:59:07 <mm_freak> Taneb: well, you can generalize it to a class, but it's difficult and not terribly useful
07:59:19 <Taneb> :/
07:59:49 <Swineflu> mm_freak, I just mean that the haskell syntex is pretty different to anything I've saw before :p Its not like read off the screen english-ese like other languages
08:00:09 <CuteAngel24> haha
08:00:14 <applicative> @pl \mult plus x a b c d -> (((x `plus` a) `mult` b) `plus` c) `mult` d
08:00:14 <lambdabot> ap ((.) . (.) . (.) . (.) . (.)) (ap ((.) . (.) . (.)) . (.) . (.))
08:00:27 <mm_freak> Taneb: a conceptual generalization is explained in bananas, lenses and barbed wire (or something like that)…  searching for those terms will give you a paper by bird/meertens (did i spell that right?)
08:00:39 <applicative> wereHamster: there's real simplification ^^^
08:01:02 <mm_freak> Swineflu: sure, you have to get used to haskell syntax first…  getting fluent in a language involves learning it =)
08:01:17 <b__> @@ @unpl @pl f x y = f (x,y) f x
08:01:18 <lambdabot>  f = fix (\ r -> (\ af b c -> ((\ k al i j -> k al j i) >>= \ e f g -> e g f) (\ ao o -> r (((,)) ao o)) af c b) >>= \ s -> s)
08:01:27 <typoclass> Taneb: i wish Prelude had an "iterate2" sort of function, which you could use with break and span and splitAt
08:01:34 <typoclass> > splitAt 2 "lolcats"
08:01:35 <lambdabot>   ("lo","lcats")
08:02:00 <Taneb> mm_freak: I'll give that a look
08:02:00 <typoclass> it'd collect the fst's and keep going for the snd's. but it's easy to write
08:02:11 <Taneb> typoclass: hmm
08:03:02 <mm_freak> @unpl liftA2 (+) f g
08:03:02 <lambdabot> liftA2 (+) f g
08:03:06 <mm_freak> @unpl liftM2 (+) f g
08:03:06 <lambdabot> (f >>= \ b -> g >>= \ a -> return (b + a))
08:03:25 <mm_freak> @unpl return (+) `ap` f `ap` g
08:03:25 <lambdabot> (((return (+)) >>= \ j -> f >>= \ i -> return (j i)) >>= \ b -> g >>= \ a -> return (b a))
08:03:34 <mm_freak> ok, @unpl sucks
08:04:10 <applicative> somehow pl and unpl dont exactly make beautiful music together
08:04:12 <wereHamster> applicative: hm. all I see are boobs - (⋅)(⋅)
08:04:22 <wereHamster> .. lots of 'em
08:04:31 <mm_freak> wereHamster: asses
08:04:48 <wereHamster> ew
08:04:53 <applicative> maybe we should substitute (>>>) in pointfree
08:06:39 <applicative> ap ((>>>) >>> (>>>) >>> (>>>) >>> (>>>) >>> (>>>)) (ap ((>>>) >>> (>>>) >>> (>>>)) >>> (>>>) >>> (>>>)) is so much less distracting
08:07:00 <mm_freak> dcoutts: httpd-shed is a very bad library to use for teaching…  you would have to reinvent all the composability stuff from other frameworks
08:07:17 <dcoutts> mm_freak: it depends what you're trying to show
08:07:25 <mm_freak> dcoutts: especially for web applications it's useful to have a "web application monoid"
08:07:44 <mm_freak> (in fact yesod doesn't have that, but happstack and snap do)
08:08:03 <mm_freak> ((yesod has it, too, but very hidden and not meant to be used by the programmer))
08:08:29 <neutrino> it's only meant to be used by the ro-bots
08:08:33 <mm_freak> dcoutts: to show that category theory is the best web framework
08:08:41 <neutrino> not by hu-mans
08:08:55 <mm_freak> what about huro-manbots?
08:09:04 <neutrino> no idea what those are
08:09:53 <mm_freak> F hu . ro - F man . bot
08:11:00 <neutrino> @_@
08:11:43 <mm_freak> hu . Py ro - man . Py bot
08:12:14 <mm_freak> perhaps with Iac = Py
08:12:21 <mm_freak> hu . Py ro - man . Iac bot
08:12:29 * hackagebot shake 0.3.8 - Build system library, like Make, but more accurate dependencies.  http://hackage.haskell.org/package/shake-0.3.8 (NeilMitchell)
08:14:27 <`nand`> @unpl is clear proof that point-free code is best expressed that way
08:14:27 <lambdabot> ((is clear proof that point) - (free code is best expressed that way))
08:14:35 <`nand`> oops
08:15:15 <mm_freak> the pretty printer of @unpl sucks, too, it seems
08:15:26 <neutrino> why?
08:15:30 <`nand`> unnecessary parens
08:16:07 <mm_freak> even the pretty printer of my toy language (which is dependently typed and locally nameless!) does a better job =)
08:16:16 <neutrino> yeah in my vim plugin i remove them
08:16:19 <applicative> @pl ((is clear proof that point) - (free code is best expressed that way))
08:16:19 <lambdabot> is clear proof that point - free code is best expressed that way
08:16:24 <neutrino> automatically
08:16:33 <neutrino> so if you do :Unpl it doesn't add any parens
08:17:07 <mm_freak> you could rename @unpl to @unhipster mostly
08:17:49 <neutrino> @unhipster foo = bar
08:17:50 <lambdabot> Unknown command, try @list
08:17:59 <neutrino> @unhip foo = bar
08:17:59 <lambdabot> Unknown command, try @list
08:18:05 <neutrino> @unhipl foo = bar
08:18:06 <lambdabot> foo = bar
08:18:12 <tobias_> can anyone help me implementing an tm for busy beaver
08:18:23 <neutrino> what is an tm?
08:18:33 <tobias_> turing machine
08:18:33 <mm_freak> tobias_: no
08:18:47 <neutrino> what is busy beaver?
08:18:53 <mm_freak> tobias_: and that's not to be rude, but it actually can't be done =)
08:19:03 <tobias_> http://www.informatik.uni-bremen.de/~cxl/lehre/pi3.ws12/ueb/uebung-07.pdf
08:19:06 <tobias_> task 3
08:19:12 <neutrino> ok
08:19:14 <mm_freak> neutrino: an uncomputable function
08:19:19 <neutrino> gotcha
08:19:25 <tobias_> we have to implement it :D
08:19:49 <mm_freak> oh, you mean the busy beaver itself
08:20:06 <neutrino> as opposed to the busy beaver's brother?
08:20:09 * neutrino is confused
08:20:45 <tobias_> i am confused too O.o
08:22:16 <mm_freak> tobias_: a busy beaver is a function and you can model it as its transition function
08:22:32 <applicative> even @pl is better at unpl'ing
08:22:37 <applicative> @pl  (ap (ap . ((-) .) . flip flip point . flip ($ clear) proof) (flip flip way . flip (flip (free code) best) expressed)) is that
08:22:38 <lambdabot> is clear proof that point - free code is best expressed that way
08:22:44 <applicative> @unpl  (ap (ap . ((-) .) . flip flip point . flip ($ clear) proof) (flip flip way . flip (flip (free code) best) expressed)) is that
08:22:44 <lambdabot> ((\ af ak -> (\ ay -> (-) (af clear proof ay point)) >>= \ ah -> ak >>= \ ag -> return (ah ag)) >>= \ y -> (\ av q -> free code av best expressed q way) >>= \ x -> return (y x)) is that
08:22:50 <mm_freak> tobias_: newtype BusyBeaver s = …
08:22:58 <mm_freak> where 's' is the state space
08:23:11 <mm_freak> i'll leave writing the type to you
08:23:41 <tobias_> hm ok i ll try
08:24:03 <mm_freak> tobias_: an even better way is to express this as three types
08:24:30 <mm_freak> data MachineState s = …
08:24:46 <mm_freak> type Transition s = …
08:24:55 <mm_freak> data BusyBeaver = …
08:25:19 <mm_freak> however, this representation requires a type system extension
08:26:10 <tobias_> what do u mean with type system extension?
08:26:28 <mm_freak> tobias_: data BusyBeaver = forall s. …
08:26:36 <mm_freak> that's the ExistentialQuantification extension
08:26:53 <neutrino> tobias_: ghc implemens haskell, but it also has several non-standard extensions that allow you to do extra things
08:27:06 <neutrino> often those extensions are tryouts for new features in haskell.
08:28:00 <tobias_> hm
08:28:03 <mm_freak> tobias_: the explanation is that when you look at the BusyBeaver from outside, you don't necessarily need to know its state type…  you just let it perform its steps until it halts
08:28:34 <mm_freak> stepBB :: BusyBeaver -> Maybe BusyBeaver
08:28:45 <mm_freak> if the beaver is halted, you get Nothing
08:31:06 <tobias_> hm, i dont really understand it :/
08:31:36 <mm_freak> tobias_: ok, start with the simplest representation, a state transition table
08:32:40 <tobias_> ok, i ll try it for the first automata
08:33:13 <invariant> What's the point of helping with homework in such detail?
08:33:43 <invariant> It is counter-productive.
08:33:56 <mm_freak> invariant: giving a ready-made implementation would be counter-productive
08:34:49 <mm_freak> as far as i see it tobias_' main issue is with haskell, not with the actual problem
08:35:05 <TBJoe> hey guys, are there some good and free sources to learn things like lambda calculus and what it has to do with haskell? id really like to understand the theory behind haskell
08:35:35 <mm_freak> TBJoe: wikipedia's explanation of lambda calculus is sufficient
08:35:57 <bitonic> no, wiki is horrible
08:36:26 <bitonic> TBJoe: I suggest TaPL or TTFP
08:36:41 <tac> tapl <3
08:36:41 <bitonic> the latter is free
08:37:09 <bitonic> in general wiki sucks for learning math...
08:37:23 <tac> bitonic: very full of truth
08:37:57 <TBJoe> ok ill see what "TaPL" and "TTFP" even is :) and i think im familiar with most of the things that are described in wiki already but it doesnt help me to understand how its related to haskell
08:37:59 <mm_freak> TBJoe: imagine a language, where you have only lambdas, application and constants…  no types and nothing predefined…  and you have an evaluation strategy that applies lambdas (such as beta-reduction)…  the result of your program is whatever remains after the reduction…  it's lambda calculus in a nutshell
08:38:05 <bitonic> @where TaPL
08:38:06 <lambdabot> http://www.cis.upenn.edu/~bcpierce/tapl/
08:38:08 <bitonic> @where TTFP
08:38:08 <lambdabot> http://www.cs.kent.ac.uk/people/staff/sjt/TTFP/
08:38:11 <bitonic> TBJoe: ^^
08:38:18 <tobias_> [(_,0,1,R),(_,1,1,STOP)] The Beaver is in any state , if there is an 0 he writes a 1 and goes right, if there a 1 he writes a 1 and stops
08:38:30 <TBJoe> thx bitonic :p
08:38:45 <bitonic> mm_freak: that kind of stuff only confuses you if you’re not familiar already
08:39:11 <bitonic> TBJoe: no problem.  I think TaPL is the best, if you have access to a uni library they’re going to have it
08:39:12 <bitonic> probably.
08:39:26 <mm_freak> tobias_: busy beavers also have an internal state
08:39:33 <bitonic> at least, a lot of people like me and tac like TaPL :)
08:39:45 <TBJoe> ok ill see if they got it in my uni library :)
08:40:11 <bitonic> TaPL will teach you much more than lambda calculus btw
08:40:20 <mm_freak> bitonic: that was the way i understood lambda calculus best…  the rest is really /applying/ lambda calculus (church representation, etc.)
08:40:51 <bitonic> mm_freak: it’s impossible to picture how the things you described work like that, at least for me
08:41:02 <TBJoe> im fine to learn more ;) if its understandable
08:41:09 <bitonic> unless TBJoe is already familiar with specification for languages
08:41:22 <tac> bitonic: I don't think I've seen TTFP before
08:41:25 <tac> I'll have to check it out
08:41:34 <bitonic> tac: it’s quite good for type theory
08:41:39 <bitonic> that’s how I learnt agda
08:41:52 <tac> bitonic: yeah. I need to learn more about the foundations of dependent typing
08:42:01 <bitonic> then I went to implement the book in Agda and I found out about bugs in the book lol
08:42:12 <tac> One thing that's been bugging me a while is that I don't really understand the theoretical basis for dependent elimination
08:42:20 <tac> hehe
08:42:42 <bitonic> dependent elimination?  you mean eliminating Pi or Sigma?
08:43:25 <mm_freak> tac: as in elimination rules?
08:43:55 <tac> mm_freak: yeah. The dependent versions, though
08:44:44 <tac> natrec : (P : Nat -> Set) -> (pz : P 0) -> (ps : (n' : Nat) -> P n' -> P (n' + 1)) -> (n : Nat) -> P n
08:44:45 <bitonic> tac: right so forallE and existsE and NatE etc. etc.
08:44:47 <tac> ^ this guy
08:44:50 <bitonic> right
08:45:00 <tac> (and the corresponding version for coinduction)
08:45:24 <mm_freak> i didn't venture that deep into the theory, as i'm more interested in practical programming rather than mathematical theorem proving
08:45:39 <bitonic> tac: what’s the coinduction version?
08:46:39 <bitonic> the messiest eliminator is the one for W
08:47:06 * tac also needs to learn about W types
08:47:40 <tac> bitonic: I was reading through Connor's old blog, and I had a question on this post: http://www.e-pig.org/epilogue/?p=324
08:47:51 <tac> perhaps you might have a better idea what the problem with W types he found was
08:48:04 <Taneb> Grah, I've got no access to GHCi
08:48:10 <seren> Hi, I want to start learning haskell, what is the best resource to start with?
08:48:11 <tac> (The message is a little lost in his ever flowery language)
08:48:26 <Taneb> seren, tryhaskell.org
08:48:36 <mm_freak> seren: most people today start with Learn You A Haskell and tryhaskell.org
08:48:37 <bitonic> tac: yes I read that post, and I asked him in person a few days ago actually :)
08:48:38 <mm_freak> @where lyah
08:48:39 <lambdabot> http://www.learnyouahaskell.com/
08:48:58 <bitonic> tac: the technicalities regarding those are very subtle
08:49:16 <seren> seems like a fun book :) there is an elephant on the cover :D
08:49:25 <mm_freak> seren: it is =)
08:49:32 <tac> What it sounded like was that, despite observational equality, there are different isomorphic ways you can encode a datatype as a W type
08:49:43 <tac> that can't be proven iso in OTT
08:49:45 <rwbarton> tac: I really wish that blog was written in English yeah
08:49:46 <tac> (or something like that)
08:49:55 <bitonic> tac:  yes that’s correct
08:50:09 <bitonic> rwbarton: agreed lol
08:50:24 <bitonic> having read a lot of Conor material I’m kind of accustomed ti it
08:50:24 <tac> rwbarton: I think Connor is a fan of his Olde English
08:50:27 <bitonic> *to it
08:50:32 <bitonic> “gums up the works”
08:50:34 <rwbarton> it's harder going than the actual theory
08:50:45 * tac should spell his name properly
08:50:47 <bitonic> he’s a character in real life too!  ehe
08:53:43 <quicksilver> olde english?
08:54:14 <quicksilver> "But we’ve shimmed up saggy bits" isn't what I'd characterise as 'Olde English'
08:54:50 <mm_freak> what's the difference between W and Sigma?
08:55:18 <bitonic> mm_freak: wait, where is the similarity :P?
08:55:34 <mm_freak> how would you define W in agda?
08:55:51 <bitonic> mm_freak: <https://github.com/bitonic/agdastuff/blob/master/W.agda>
08:56:00 <bitonic> you can encode a Sigma in W
08:56:11 <rwbarton> mm_freak: W is a rotated Sigma
08:56:18 <tac> W defines a "well founded data type"
08:56:22 <tac> sigmas are just dependent pairs
08:57:31 * hackagebot hsx2hs 0.11.0 - HSX (Haskell Source with XML) allows literal XML syntax in Haskell source code.  http://hackage.haskell.org/package/hsx2hs-0.11.0 (NiklasBroberg)
08:57:41 <bitonic> mm_freak: W types were created to be able to encode inductive families using one datatype
08:58:16 <Saizan> W is basically Fix but just for strictly positive functors
08:58:22 <bitonic> mm_freak: the problem is that they are unusable in intensional type theory because you are going to have many instances of W that “do the same thing” but are not the same term
08:58:33 <mm_freak> it seems to me like W is like sigma, just one level higher…  in fact the pisigma package explains how to encode inductive families using sigma
08:59:23 <bitonic> mm_freak: I don’t know what pisigma is, but W types are more powerful
08:59:34 <bitonic> you can have the “shape” do change down the branches
08:59:34 <Saizan> mm_freak: you also need recursion
08:59:45 <mm_freak> indeed, the recursion is missing in sigma
09:00:48 <mm_freak> it just looked so familiar =)
09:01:52 <tac> mm_freak: PiSigma as in http://www.andres-loeh.de/PiSigma/PiSigma.pdf ?
09:02:21 <mm_freak> tac: yeah, and the implementation is here:
09:02:25 <mm_freak> @hackage pisigma
09:02:26 <lambdabot> http://hackage.haskell.org/package/pisigma
09:02:31 * hackagebot hsp 0.8.0 - Haskell Server Pages is a library for writing dynamic server-side web pages.  http://hackage.haskell.org/package/hsp-0.8.0 (NiklasBroberg)
09:02:32 <bitonic> mm_freak: well it is similar, but not quite - the first thing to note is that W is indexed by a function
09:02:46 <tac> mm_freak: Yeah. The sigma type is the same sigma we're talking about.
09:02:54 <tac> PiSigma doesn't have W types though, iirc
09:03:11 <mm_freak> tac: the point of the paper is that you probably don't need W
09:03:25 <bitonic> mm_freak: you do, if you want to emulate inductive families
09:03:51 <tac> mm_freak: The problem with Pi Sigma is that it is inconsistent. You can type "fix" without any help.
09:04:15 <tac> The intention was that languages compiling to PiSigma would implement a separate termination checker
09:04:25 <Saizan> Fam : Set1; Fam = Sigma Set (\ S -> S -> Set); eval : Fam -> (Set -> Set); eval (S , P) = \ X -> Sigma S (\a -> P a -> X)
09:04:56 <tac> W types, on the other hand, don't require a termination check at all. The recursion is always guaranteed to halt (any other inconsistencies aside)
09:05:05 <Saizan> Fam is also called Container, and you can describe any strictly positive functor that way
09:05:25 <mm_freak> tac: i see
09:05:32 <mm_freak> that makes sense
09:05:53 <Saizan> and you can define data W (F : Fam) : Set where node : eval F (W F) -> W F
09:06:39 <mm_freak> well, for a practical language you need a termination checker anyway, but i see how W would simplify writing it
09:07:00 <tac> mm_freak: IMO, termination checkers are a useful hack, but still a hack.
09:07:20 <tac> ideally, you'd want to be able to compile down into known-to-terminate eliminators
09:08:14 <mm_freak> tac: well, a simple conditional that discovers that it can't compile "f = f" to that core language is already a termination check
09:08:20 <tac> But, of course, you'd never want to *write* a program using W types :)
09:08:28 <mm_freak> ideally your code language itself wouldn't require that check
09:09:10 <mm_freak> but if the language is going to be a /programming/ language (as opposed to a pure theorem prover) you need to termination-check your core language anyway, because you will have letrecs and some other useful stuff
09:09:20 <epta> What hsx could be useful? What is it for?
09:09:42 <mm_freak> epta: you mean hsp/hsx?
09:09:53 <tac> mm_freak: The issue I have (so, in other words: IMO), the termination checker shouldn't be part of the typechecking.
09:10:04 <tac> The type theory is expressive enough to capture the ideas of termination and productivity
09:10:17 <tac> If you have a separate compiler tool for termination checking, it should simply direct the compiler
09:10:24 <epta> mm_freak: I mean http://hackage.haskell.org/package/hsx2hs
09:10:35 <tac> So it would still be there in your compiler -- but it's role is not to do any kind of verification of correctness
09:11:02 <mm_freak> epta: it allows you to write XML literals directly in haskell source code
09:11:13 <mm_freak> epta: similar to what ur/web does
09:11:18 <neutrino> this is a cool tutorial: http://www.haskellforall.com/2012/06/you-could-have-invented-free-monads.html
09:11:29 <neutrino> my eyes quickly glazed over but it's still a cool tutorial.
09:11:34 <epta> mm_freak: it's hard to imagine some usecase for that
09:11:47 <mm_freak> epta: web applications, XML processors, etc.
09:12:15 <mm_freak> epta: happstack's primary templating engine is HSP/HSX
09:12:48 <tac> neutrino: free structures are nice
09:13:41 <mm_freak> neutrino: free monads are convenient, but not necessarily beautiful…  you save some code here, but have to write some ugly code there
09:14:08 <mm_freak> they are beautiful in theory though, because you get a proven monad from any functor
09:14:13 <bitonic> Saizan: so wait, are enumerations + Sigma enough to express inductive families?
09:14:20 <mm_freak> bitonic: yes
09:15:14 <mm_freak> bitonic: read the pisigma paper that tac linked
09:15:20 <mm_freak> @where pisigma
09:15:20 <lambdabot> I know nothing about pisigma.
09:15:23 <bitonic> mm_freak: I was skimming it now, that’s why I asked
09:15:35 <mm_freak> http://www.andres-loeh.de/PiSigma/PiSigma.pdf
09:15:45 <mm_freak> bitonic: don't skim it, read it =)
09:15:52 <bitonic> you also need those recursion primitives
09:16:39 <mm_freak> enumerations + sigma don't give you the nice correctness properties of W, but they are all that is necessary to implement a core language for, say, agda
09:16:49 <neutrino> i'm gonna go to the city now, bbl
09:16:59 <bitonic> mm_freak: you also need that unrestricted recursion
09:17:17 <tac> mm_freak: bitonic: the "let" in the PiSigma paper is actually letrec. It has fix built-in.
09:17:28 <bitonic> which is undesirable (but might be convenient).  the beauty of ITT + W is that it’s enough while being consistent
09:17:48 <bitonic> tac: yeah that’s the recursion I was talking about
09:18:01 <bitonic> but I guess tac already said that while I was skimming it :P
09:18:19 <mm_freak> bitonic: put differently, the pisigma calculus is sufficient
09:18:25 <bitonic> in core type theory Sigma and a sum type with the usual eliminators are not enough to build W
09:19:05 <bitonic> mm_freak: W and PiSigma are there for two different goals really
09:19:15 <bitonic> W is not practical anyway, not even with OTT
09:19:23 <mm_freak> i know…  pisigma is compiler-oriented
09:19:31 <mm_freak> so a practical matter
09:20:09 <tac> bitonic: Even if it's not suitable for what Conor wanted, W is still a decent basis, right?
09:20:10 <bitonic> yeah, so without that recursion Sigma and sums are *not* enough to have inductive families, that’s the only point I wanted to make
09:20:43 * tac should just shut up and read the papers he has on W types and be done with it
09:20:59 <bitonic> tac: decent basis for what?  for a core language for a compiler?  I’m quite confused on that issue as well anyway
09:21:03 <bitonic> and TTFP covers W types
09:21:29 <tac> yeah
09:21:34 <bitonic> if you want full inductive families W is not suitable, the problem is when you start indexing things by functions
09:21:46 <tac> bitonic: ah. I will keep that in mind
09:22:03 <tac> like (f : A -> B) -> P f?
09:22:20 <bitonic> I... think.  again that issue is very shady in my mind :P
09:22:35 <bitonic> tac: well `A -> B' doesn’t look good anyway ehe
09:23:13 <bitonic> I don’t want to say silly things, probably Saizan knows more
09:24:29 <bitonic> now that I finished my last piece of CW I can focus on this again :)
09:24:39 <tac> CW?
09:24:50 <bitonic> coursework
09:25:11 <quchen> @pl f a b x = g a x && g b x
09:25:11 <lambdabot> f = (. g) . ap . ((&&) .) . g
09:25:26 <neutrino> haha quchen
09:25:31 <tac> ah
09:25:31 <quchen> Huh?
09:25:40 <neutrino> didn't quite work out to something useful.
09:25:51 <quchen> No it didn't. Why the heck is there 'ap' in there
09:25:55 <bitonic> with pl, it rarely does
09:26:02 <neutrino> it often does for me.
09:26:07 <bitonic> quchen: functions are monads
09:26:10 <neutrino> well, maybe let's put it another way
09:26:19 <tac> I wish I could go back to school to study Type Theory :X
09:26:22 <elliott> ap = S combinator
09:26:27 <neutrino> i can do it from within vim with one button press
09:26:28 <quchen> neutrino: I know, but why would you want to use Reader on that?!
09:26:31 <neutrino> so i do it all the time
09:26:46 <neutrino> and often i find something useful.
09:27:05 <rwbarton> ap is just @pl's generic way of handling an argument that is used more than once
09:27:11 <quchen> Anyway, turns out my gut feeling that this will be bad in pointless notation was right.
09:27:11 <neutrino> tac: why don't you?
09:27:14 <quchen> Pun intended.
09:27:18 <neutrino> rwbarton: aha
09:27:28 <tac> neutrino: From what I understand, America doesn't believe in software correctness.
09:27:33 <quchen> rwbarton: Makes sense, yeah
09:27:44 <neutrino> tac: how is your answer related to my question?
09:27:48 <bitonic> quchen: if you can’t manually come up quickly with the pointless representation, you shouldn’t use the pointless representation
09:28:00 <tac> I wouldn't be able to find a school where it's taught or valued.
09:28:02 <bitonic> since if it’s going to be twice as hard to decipher
09:28:05 <S11001001> tac: we've invested too much in learning how to work around incorrect software
09:28:08 <tac> Or if I did, it would probably be further away
09:28:38 <bitonic> tac: they don’t teach it here either, they teach a bit of types
09:29:15 <bitonic> they do have undegrad courses somewhere, like in nottingham and chalmers
09:29:34 <bitonic> gotta go
09:29:38 <tac> later bitonic
09:29:41 <tac> it was fun chatting
09:29:46 * bitonic is going to think about W types on the bus
09:29:50 <bitonic> tac: later :)
09:30:38 <quchen> @pl f x = x x x
09:30:39 <lambdabot> f = join (join id)
09:30:50 <quchen> @pl f x y = x y x x y
09:30:50 <lambdabot> f = join . (flip =<< join flip)
09:30:54 <quchen> Oh wow
09:31:05 <Chathurga> That is amazingly cool
09:31:07 <quchen> A new kind of obfuscation
09:31:36 <quchen> f a b = a b f
09:31:40 <quchen> @pl f a b = a b f
09:31:40 <lambdabot> f = fix (flip flip)
09:31:45 <quchen> Hahaha
09:31:53 <ypo> Hello people.
09:31:55 <ypo> I have a question about tail-recursive functions in Haskell. I think that the definition of following function (functional iteration) is tail-recursive:
09:31:57 <ypo> funcIter' 0 _ x = x
09:31:58 <ypo> funcIter' n f x = funcIter' (n-1) f (f x)
09:32:00 <ypo> Now I don't understand why the expression " funcIter'  13371337 (+5) 0 " is blowing up my pc (filling the RAM and SWAP till overful).
09:32:35 <ypo> I would have expected that it just uses a lot of runningtime but not that amount of space
09:32:35 <quchen> ypo: You build up a long chain of "-" in the first argument due to Haskell's laziness.
09:33:02 <quchen> Replace "(n-1)" with "(n `seq` (n-1))" and try again
09:33:19 <glguy> the n-1 is already strict
09:33:26 <quchen> Oh right
09:33:26 <`nand`> I would add ! in front of ‘n’ and ‘x’
09:33:26 <glguy> because that argument is tested against 0
09:33:28 <quchen> Nevermind.
09:33:39 <glguy> Only the 'x' argument needs additional strictness
09:33:40 <quchen> Then it's the x where the tunk is built up
09:33:42 <`nand`> like: funcIter' !n f !x = ... -- see if this helps
09:34:02 <glguy> To add ! to an argument you need to turn on the BangPatterns language extension
09:34:09 <`nand`> oh, yes
09:34:24 <FireFly> What does that bang do?
09:35:29 <`nand`> FireFly: makes the field strict
09:35:42 <`nand`> f !x = y  is basically f x = x `seq` y
09:35:54 <`nand`> but nicer to look at
09:35:57 <glguy> funcIter' n f x = funcIter' (n-1) f $! f x
09:36:33 <glguy> ypo: Use this version with the $!, it requires no extensions and does what you want.
09:36:42 <glguy> ?src $!
09:36:42 <lambdabot> f $! x = x `seq` f x
09:37:15 <neutrino> oo
09:37:19 <neutrino> @hoogle $!
09:37:20 <lambdabot> Prelude ($!) :: (a -> b) -> a -> b
09:37:20 <lambdabot> Control.DeepSeq ($!!) :: NFData a => (a -> b) -> a -> b
09:37:25 <neutrino> nice
09:37:28 <rwbarton> it might help to give an even more explicit version
09:37:41 <rwbarton> funcIter' n f x = let x' = f x in x' `seq` funcIter' (n-1) f x'
09:38:24 <ypo> glguy: Thanks, that worked and didn't need any extension. But could you know please explain further where the problem was?
09:38:33 <rwbarton> @where lazy
09:38:33 <lambdabot> http://www.vex.net/~trebla/haskell/lazy.xhtml
09:38:37 <rwbarton> ^ read that
09:39:14 <monochrom> thank you for choosing monochrom!
09:39:32 <`nand`> ypo: the result was looking like f (f (f (f (f (f (f (.... x)..)) in memory, since haskell wasn't actually calculating the ‘f’ yet due to laziness
09:39:45 <`nand`> so storing all of those ‘calls to f’ filled up your memory
09:39:46 <ypo> rwbarton: the complete document or is there a section that fits to this particular problem?
09:39:46 <glguy> ypo: you weren't using the value of the 'x' argument, so it wasn't being evaluated
09:40:02 <rwbarton> well
09:40:25 <rwbarton> until you understand the problem, I guess :)
09:41:20 <ypo> In some point I understanc haskells laziness, but i thought " ... (f x)" is already "forced" to evaluate
09:41:34 <glguy> Why did you think it was forced?
09:42:16 <`nand`> values aren't forced until you pattern match on them, roughly speaking
09:42:19 <ypo> aktually i dont knwo :D
09:42:30 <rwbarton> probably it's easier to understand laziness from the bottom up than by poking at the subject with random examples
09:42:51 <ypo> *actually i dont know :D
09:43:23 <ypo> So (n-1) is evaluatet strict because of the pattern matching with 0 ?
09:43:43 <`nand`> yeah
09:43:58 <ypo> that makes some kind of sense
09:44:15 <ypo> So thanks for the link. I will spend some time with it!
09:44:26 <davesque> i think i have begun to understand something about monads...and why everyone gets annoyed when someone shows up and tries to say what monads really are
09:44:27 <ypo> And thanks a lot to everyone else!
09:44:37 <rwbarton> thank monochrom, he wrote it :)
09:44:52 <monochrom> thank you for choosing monochrom!
09:44:52 <`nand`> monads are like astronauts inside space suites full of nuclear waste
09:44:54 <`nand`> or something
09:45:08 <davesque> right :)
09:45:42 <ypo> Is monochrom a bot?
09:45:48 <davesque> seems like they're a concept that's only really clearly defined in the context of higher mathematics (lambda calculus i think?)...you can't really say what they really are in any other way :P
09:45:56 <monochrom> yes. try the !list command
09:46:12 <ypo> !list
09:46:12 <monochrom> ypo: http://okmij.org/ftp
09:46:19 <`nand`> davesque: monads are defined in the context of category theory (not lambda calculus)
09:46:31 <davesque> ahh, see even then i'm wrong :)...ironic
09:46:37 <`nand`> davesque: but you can certainly define Monad in the context of Haskell without ever touching category theory
09:46:57 <`nand`> but you're right in saying that monads are simply concepts that are clearly defined in some mathematical way
09:46:59 <davesque> right, in the class definition
09:47:06 <`nand`> davesque: not just, you need the laws; too
09:47:11 <davesque> ahh, right
09:47:13 <monochrom> to the uninitiated, every advanced continuous math is calculus, every advanced discrete math is lambda calculus.
09:47:40 <`nand`> Haskell currently has no mechanism for requiring class instances follow arbitrary laws; other than what can be expressed by the type system
09:47:40 <davesque> see, i knew i'd shoot myself in the foot despite myself :)
09:47:57 <monochrom> MATH 4752 "Calculus XXIII" and COSC 4298 "Lambda Calculus XVI"
09:48:28 <quchen> Calculus is advanced?!
09:48:35 <davesque> anyhow, that gets a weight off my chest...first time something i've said about them has been almost-correct
09:48:50 <monochrom> calculus is not advanced, that's my point
09:49:00 <quchen> Oh.
09:49:03 <quchen> OH.
09:49:03 <`nand`> davesque: of course, that can be said for a lot of things; “being defined in some mathematical context” is a very broad description :)
09:49:08 <monochrom> "to the uninitiated"
09:49:15 <Chathurga> This is probably an unanswerable question but if haskell could be rewriten now with hindsight what are some of the warts that would be fixed?
09:49:28 <`nand`> Chathurga: Prelude, personally
09:49:33 <davesque> `nand`: it is
09:49:47 <`nand`> Chathurga: eg. some of the default type classes which simply make no sense or have missing hierarchies
09:50:00 <Eelis> i'd like to think that the whitespace rules would also not be remade in their current form
09:50:14 <`nand`> I haven't had any problems with the current whitespace rules
09:50:17 <Eelis> because i fucking hate them
09:50:22 <davesque> `nand`: interesting that such an abstract thing could be so broadly useful
09:50:25 <`nand`> Eelis: you can write whitespace-insensitive code
09:50:31 <quchen> Chathurga: Semigroup => Monoid => Group => Field; Applicative => Monad
09:50:32 <glguy> davesque: Is that a terrible combination of shooting yourself in the foot and cutting off your nose to spite your face?
09:50:34 <Eelis> nand: i know
09:50:37 <`nand`> davesque: ‘numbers’ are fairly useful; and fairly abstract things
09:50:44 <davesque> glguy: something like that
09:50:54 <davesque> `nand`: true, no saying what they really are
09:50:59 <Eelis> nand: the whitespace rules favour monospace fonts
09:51:05 <Chathurga> Eelis: What whitespace rules don't you like, personally love them
09:51:10 <`nand`> Chathurga: Haskell also needs dependent types :>
09:51:12 <Chathurga> who codes in non monospace...
09:51:27 <Eelis> Chathurga: there is a bunch of us
09:51:28 <`nand`> Eelis: that is true
09:51:37 <`nand`> Eelis: incidentally, I use a monospace font
09:51:43 <Eelis> nand: figures :)
09:51:45 <Chathurga> `nand`: That's the one I was wondering if it'd be mentioned although I have no concept of what that means
09:52:15 <`nand`> Chathurga: simply put; you can have regular values on the type level; for example ‘Vector Char 30’ would be a string of length 30
09:52:34 <Chathurga> Oh wow, that's nice
09:52:53 <`nand`> cons :: a -> Vector a n -> Vector a (n+1)
09:53:13 <Chathurga> And it makes a lot of sense, is it possible Haskell will ever move to being dependantly typed or is it simply impossible at this stage
09:54:06 <`nand`> On that; I have no idea, but Haskell is certainly making steps /towards/ dependent typing with GHC 7.6.1 and GHC HEAD
09:54:18 <`nand`> of course, there's probably a huge barrier between these steps and actual dependent typing
09:54:27 <glguy> dependent types means that the types depend on values, not that you have type-level numbers
09:54:31 <quchen> `nand`: In what sense does 7.6.1 step towards dependent types?
09:54:31 <`nand`> but ‘Vector Char 30’ is a legal type in GHC 7.6.1
09:54:39 <quchen> Huh? Cool.
09:54:41 <`nand`> and ‘Vector Char (30+1)’ is legal in HEAD I think
09:54:44 <Chathurga> Oh interesting
09:54:55 <davesque> `nand`: would you say monads in the context of category theory are a fairly advanced concept, or are they something that shows up fairly early on in studying that subject?
09:54:58 <Chathurga> So basically it means there's no distinction between the type and value levels?
09:55:08 <rwbarton> the trick is that that "30" is not actually a value
09:55:19 <`nand`> ^
09:55:32 <quchen> 30 is a type constructor?
09:55:34 <`nand`> GHC 7.6.1 basically promotes values to the type level
09:55:41 <S11001001> I'm not sure SPJ would like it too much
09:55:46 <`nand`> quchen: 30 is a type, yeah
09:55:53 <rwbarton> it's a type that "corresponds" (imagine hands waving furiously) to the value 30
09:56:02 <glguy> `nand`: values promoted to type level isn't dependent typing
09:56:17 <quchen> data 1 = 1
09:56:18 <quchen> data 2 = 2
09:56:19 <quchen> ...
09:56:23 <`nand`> glguy: sure; but it enables stuff like the singletons library
09:56:24 <quchen> Something like that?
09:56:34 <Eelis> i'd also like to think that if Haskell were remade today, we'd get proper non-negative integer types. we have C++ people laughing at us for god's sake :P
09:56:57 <`nand`> which allows singleton values to carry around their type-level versions
09:57:01 <quchen> Eelis: Why isn't that introduced anyway? I don't see why there shouldn't be a "Natural" typeclass
09:57:04 <rwbarton> what's wrong with Word/Word32/Word64/etc.
09:57:23 <quchen> rwbarton: A Wordeger would be nice to have.
09:57:24 <`ramses> could something like filter be written with dependently typed lists? Since you don't know the length of the resulting list at compile time?
09:57:25 <Eelis> rwbarton: i dunno, but for some reason nobody uses them in their APIs
09:57:29 <rwbarton> just that they aren't in the Report?
09:57:39 <`nand`> Word works fine; but yeah, a Natural in the spirit of Integer would be a useful addition to Prelude I think
09:57:39 <rwbarton> well, hm
09:57:57 <rwbarton> but surely an unbounded natural integer is not what the C++ people are laughing about
09:58:19 <Eelis> no, they're laughing at length returning an Int
09:58:25 <`nand`> rwbarton: for example, (!)
09:58:38 <`nand`> or (!!) or whatever that's called in Prelude
09:58:43 <quchen> length :: (Natural a) => [b] -> a
09:58:45 <quchen> !!
09:59:07 <thoughtpolice> `ramses: sure, you just need a type says that 'filter' returns a list of less than or possibly equal length to the original.
09:59:13 <`nand`> quchen: personally: there's no reason to restrict it to natural numbers though, imo
09:59:25 <rwbarton> okay, that's fair
09:59:34 <rwbarton> and more of a historical/"Word is not in the Report" issue
09:59:42 <`nand`> but the (!!) example is much worse imo; since it actually errors out on negative values
09:59:50 <quchen> `nand`: Why's that? I can't see fractional or negative lengths occurring on lists.
09:59:50 <Eelis> nand: agreed
09:59:55 <`nand`> rwbarton: well yeah, that's what this discussion is about
10:00:06 <`nand`> quchen: sure; but the user may want to use the length in a fractional context
10:00:08 <rwbarton> but it's not like the types aren't there
10:00:12 <`nand`> quchen: for example, sum xs / length xs
10:00:26 <rwbarton> fsvo "there"
10:00:47 <rwbarton> actually, they are in the 2010 report, hmm
10:00:48 <`ramses> thoughtpolice: but then you would rather quickly loose any knowledge about the types, and thus any extra type safety which the dependent types would bring, wouldn't you?
10:00:57 <quchen> `nand`: I don't think that's a good idea. Counting the length as a Double would accumulate some rounding error.
10:01:11 <quchen> I think explicit conversion is a good thing there.
10:01:12 <`ramses> thoughtpolice: I do see it's probably the only possibility, I just don't see them being very useful in reality then
10:01:34 <davesque> `nand`: guess the only way to find out is to do some homework
10:01:58 <n-dolio> You would need to have a very long list to see rounding error on length in a Double.
10:02:03 <quchen> @pl f x = sum x / length x
10:02:04 <lambdabot> f = liftM2 (/) sum length
10:02:04 <`nand`> quchen: a fair point; though in this case one could argue that-- yeah
10:02:32 <Chathurga> So is Adga and evolution of Haskell or does it make trade offs somewhere else?
10:02:36 <Chathurga> *an
10:02:48 <`nand`> Chathurga: I don't think Agda intends to be an evolution of Haskell
10:02:56 <gwern> http://plato.stanford.edu/entries/lambda-calculus/
10:03:20 <`nand`> it's based on a different theoretical principle; and makes differing design choices - in particular, if I recall correctly, Agda doesn't have typeclasses in the form Haskell has them, which is probably its most distinct feature
10:03:29 <donri> Chathurga: agda doesn't have haskell's type inference
10:03:37 <rwbarton> anyways the return type of length would be pretty low on my list of concerns for a revamped Haskell--I'd rather have a clean static semantics for MPTCs and type families and GADTs and so on
10:04:02 <Chathurga> `nand`: I just mean if it did only improve deficiencies then it would effectively be an evolution even if that's not the intent
10:04:11 <`nand`> rwbarton: what do you mean?
10:04:22 <Saizan> Chathurga: there are some trade-offs
10:04:28 <Chathurga> Oh right type inference is gone, that's pretty bad. Impossible to avouid with full dependant types?
10:04:28 <rwbarton> well for example a way to decide whether a program using these features is well-typed
10:04:31 <`nand`> rwbarton: are you talking about interactions like OverlappingTypeclasses?
10:04:37 <thoughtpolice> `ramses: sure, but that is just the basic definition of filter. you could feasibly encode more evidence of the in the type other ways (other than a fairly weak statement like 'n <= m',) there are a couple schools of thought on this, but i'm no dependent-type master
10:04:39 <`nand`> err
10:04:41 <`nand`> OverlappingInstances*
10:04:42 <rwbarton> that isn't "run GHC's type checker and see what it says"
10:04:42 <glguy> Agda has instance arguments which are similar to type-classes, more flexible, but don't support recursive instance search like type classes do
10:04:45 <Saizan> Chathurga: type inference is not "gone"
10:05:07 <glguy> Agda can infer non-polymorphic types, at least
10:05:35 <Chathurga> Ah right
10:05:42 <rwbarton> `nand`: OverlappingInstances was not in the "and so on" :) it's a definite no-no, can't imagine it working well with any semantics for type classes
10:05:47 <donri> there's also idris which is a more haskell-like agda
10:06:03 <rwbarton> on the other hand a type inequality assertion might be okay
10:06:06 <donri> at least syntactically
10:06:26 <Saizan> Chathurga: but the extra flexibility of the type system makes it harder, so you're more likely to need annotations, mostly for toplevel definitions in practice
10:07:03 <Chathurga> That's not too bad since you'd often give them anyway for clarity
10:07:06 * `nand` wants family instance groups
10:07:14 <`ramses> thoughtpolice: ok, thanks, I'll google around a bit :)
10:08:55 <Saizan> Chathurga: yeah, though it's sometimes bad when you just want to pull away some code into its own function and you're forced to figure out its type
10:09:49 <b__> does anyone happen to know of any articles using GADTs to define a HTML/XML type?
10:09:53 <Saizan> Chathurga: another drawback is that if you want your proofs to actually mean something you have to termination check them and that gets in the way of the code you'd want to write sometimes
10:10:07 <Chathurga> Are these limitations theoretical or just a deficiency of current implementations?
10:10:24 <Chathurga> Adga has to know programs will terminate?
10:10:39 <`nand`> you can disable the termination checker
10:10:57 <Saizan> there are fundamental theoretical problems, but implementations could do better too
10:11:15 <`nand`> the halting problem is pretty foundational, mind
10:11:21 <`nand`> fundamental*
10:11:40 <merijn> Chathurga: In general Agda code is supposed to be total, which means termination has to be proven
10:12:33 <Saizan> Chathurga: you can view a program as a valid proof only if doesn't hide some nasty loop inside them
10:12:36 <merijn> Which also means that it's not Turing complete unless you disable some stuff like the termination checker (I'm not really sure what is sufficient or necessary to disable to get it Turing complete, some Agda wizard here probably knows...)
10:12:47 <Saizan> Chathurga: s/them/it/
10:13:28 <Saizan> even with the termination-check on Agda is as much turing complete as Haskell can do I/O
10:13:56 <Saizan> let's not fall into a turing tarpit :)
10:14:12 <Chathurga> Language development goes so much deeper than I ever thought
10:14:27 <merijn> Saizan: Either the language is total or it isn't
10:14:39 <merijn> I dunno which it is, so I can't say
10:15:07 <Saizan> it is total, but you can embed partiality, as well as Haskell is pure but can embed IO
10:15:36 <merijn> afaik Agda was total, which precludes Turing completeness (not that you couldn't get as close as you wanted to turing completeness by having something like a corecursion/infinite loop monad)
10:16:07 <Saizan> merijn: are you reading what i'm saying?:)
10:16:30 <merijn> Saizan: That means Agda (the environment + language) is Turing complete, but Agda the language (on its own) wouldn't be
10:16:58 <ick> if i ask for the length of a list, is the list evaluated and counted in order to find that number or is something more clever going on?
10:17:15 <`nand`> ick: the number of cons cells is counted
10:17:15 <merijn> Sure, but that's just what I was referring to with my "infinite loop" monad-type idea, no?
10:17:18 <`nand`> (and evaluated)
10:17:23 <`nand`> but the lists contents may remain unevaluated
10:17:35 <merijn> ick: IOW, yes
10:18:07 <merijn> So in general you'll want to avoid length
10:18:21 <ick> thought so
10:18:23 <Saizan> merijn: how do you define turing complete?
10:18:23 <`nand`> ick: think about it like this, a list like [1,2, undefined, 3] will look like this: 1 : 2 : undefined : 3 : []; ‘length’ has two cases: length [] = 0 and length (_:xs) = 1 + length xs; so in the (:) the first element is ignored (unevaluated); the only thing it looks at is the constructor, in this case (:) or []
10:18:36 <merijn> Keeping with the "lists are loops waiting to happen" idea
10:18:43 <`nand`> oh
10:18:52 <`nand`> wait, you were asking about Agda, weren't you?
10:19:10 <ick> i wasnt
10:19:18 <merijn> `nand`: Well, given that this is #haskell and I don't see any mention of Agda I was assuming not :p
10:19:56 <merijn> Saizan: Equivalence to UTLC/turing machine?
10:20:03 <merijn> Saizan: Is there another way?
10:20:17 <ick> so are you saying that the undefined part of that list is evaluated or not `nand` ? since undefined could be []
10:20:19 <`nand`> in my mind #haskell looks like this:  {.. grey blob of Agda discussion / termination checking / turing completeness ..} <ick's question> <- so I thought it might exist in the context beforehand, which I haven't read as I got distracted :P
10:20:42 <merijn> > length [undefined, undefined, undefined]
10:20:44 <lambdabot>   3
10:20:46 <`nand`> ick: in ‘undefined : []’ the undefined doesn't get evaluated; but in ‘3 : undefined’ the undefined /does/ get evaluated
10:20:48 <merijn> > head [undefined, undefined, undefined]
10:20:51 <lambdabot>   *Exception: Prelude.undefined
10:20:53 <Saizan> merijn: right, so i must be able to simulate a universal turing machine, and Agda can
10:21:03 <`nand`> > length (1 : 2 : 3 : undefined)
10:21:04 <rwbarton> how do you define "Agda", too
10:21:04 <lambdabot>   *Exception: Prelude.undefined
10:21:27 <n-dolio> What does "simulate" mean?
10:22:05 <ick> i dont see how we can be sure [undefined, undefined, undefined] has length 3
10:22:25 <merijn> Saizan: Unless I misunderstood your earlier comment Agda + runtime, which is (for all practical purposes) a rather small point, like the Haskell RTS can execute IO whereas the haskell language can't
10:22:29 <Saizan> n-dolio: that's the problem :)
10:22:32 <merijn> ick: Why not?
10:22:32 <`nand`> ick: [[1,2,3],[4,5,6]] is distinct from [1,2,3,4,5,6] <- the latter has length 6, the former has length 2
10:22:42 <merijn> ick: The list has three elements
10:22:42 <`nand`> ick: what's /in/ the cells is of no concern to ‘length’
10:22:53 <`nand`> be it ‘undefined’, or another list, or whatever; it doesn't factor into the length
10:23:01 <merijn> ick: That the elements happen to be undefined instead of 1 is irrelevant
10:23:17 <ick> oh right yeah
10:23:34 <ick> since : cant take an empty list on the 'left'
10:23:40 <`nand`> it can
10:23:43 <`nand`> > [] : []
10:23:45 <lambdabot>   [[]]
10:23:48 <`nand`> a list containing just the empty list
10:23:52 <merijn> ick: My point was just to show `nand` explanation that length will walk the list, but not inspect the elements (if it inspected the element it'd throw an exception)
10:24:19 <merijn> > (head . tail) [undefined, 1, undefined]
10:24:21 <lambdabot>   1
10:24:22 <ick> right but only if all the other elements are also lists
10:24:29 <`nand`> ick: exactly
10:24:29 <ion> cadr
10:24:31 <`nand`> :t [] . []
10:24:33 <lambdabot>     Couldn't match expected type `a0 -> b0' with actual type `[a1]'
10:24:33 <lambdabot>     In the first argument of `(.)', namely `[]'
10:24:33 <lambdabot>     In the expression: [] . []
10:24:34 <`nand`> err
10:24:36 <`nand`> :t [] : []
10:24:37 <lambdabot> [[a]]
10:25:09 <`nand`> ick: in general, what's on the left hand side of (:) is of no concern to ‘length’, as can be seen from its type
10:25:11 <`nand`> :t length
10:25:12 <lambdabot> [a] -> Int
10:25:26 <Chathurga> How kosher are ViewPatterns?
10:25:33 <`nand`> Chathurga: quite, as far as I know
10:25:37 <merijn> Chathurga: What do you mean by Kosher?
10:25:42 <Eelis> i use them all the time. never had any problems
10:25:49 <`nand`> I guess he means “likely to launch missiles and break the type system”
10:26:08 <ick> indirectly it is though since length deconstructs the list with :?
10:26:10 <merijn> Chathurga: If you mean "Won't affect the safety of haskell code in meaningful ways", then yes they're kosher
10:26:15 <Chathurga> Well I just have it in my head that some things exist as extension but are more frowned upon than others, I don't know why I think that
10:26:22 <ick> the pattern is x:xs
10:26:49 <merijn> Chathurga: There's only a few really frowned upon extensions (if you ignore portability, but let's face it no one cares about anything but GHC :p)
10:27:18 <Chathurga> Haha okay cool
10:27:33 <merijn> Chathurga: http://stackoverflow.com/questions/10845179/which-haskell-ghc-extensions-should-users-use-avoid
10:28:18 <Chathurga> merijn: Ah thank you
10:28:28 <merijn> Chathurga: I would avoid the ugly/bad ones unless you know exactly why you need them
10:28:29 <`nand`> ick: the pattern is x:xs but the ‘x’ is never used, so it's never looked at
10:28:40 <`nand`> ick: simply matching something by giving it a name doesn't imply any evaluation
10:29:05 <merijn> Chathurga: The worst thing that could happen with the good ones is that some types might not be inferrable
10:29:41 <merijn> Chathurga: i.e. Rank2Types and RankNTypes are not inferrable and will require manual type annotation to work
10:30:04 <`nand`> the main thing I avoid is OverlappingInstances
10:30:12 <`nand`> because that can really cause you headaches and invalidate the type system
10:30:34 <`nand`> I don't see anything wrong with implicit parameters, but I've never used them
10:30:38 <Chathurga> I was just thinking from the human side of things, code shame. Like are ViewPatterns widely used or something that is generally avoided
10:30:51 <`nand`> I readily use RankNTypes where need arises, OTOH
10:31:06 <merijn> Chathurga: I would use them until you need them, but there are cases where it is *much* clearer to use them
10:31:11 <merijn> Chathurga: Which is why they exist
10:31:14 <edwardk> Cale: Are TypeFamilies turned off in lambdabot for a reason?
10:31:40 <Cale> edwardk: How would you be able to use them?
10:31:42 <Chathurga> Gotcha, thanks
10:31:54 <edwardk> :t let derp :: () :- (x ~ x); derp = Sub Dict in derp
10:31:56 <lambdabot> () :- (x ~ x)
10:31:58 <edwardk> @let derp :: () :- (x ~ x); derp = Sub Dict in derp
10:31:59 <lambdabot>   TypeFamilies is not enabled
10:31:59 <`nand`> Chathurga: View patterns are the best way to pattern match on abstract data types
10:32:01 <`nand`> Chathurga: like Map or Seq
10:32:15 <Cale> oh, hm
10:32:20 <Chathurga> Aaah yes that's the example I always wondered from scala
10:32:21 <edwardk> i can have types that reference them even if i don't make a new data type
10:32:25 <merijn> Chathurga: On other hand, GADTs and MultiParameterTypeClasses are so awesome I can't even write code without them anymore :p
10:32:32 <Chathurga> But forgot to investigate when I switched to haskell
10:32:33 <`nand`> I don't use MPTCs
10:32:37 <`nand`> well, other than stuff like mtl
10:32:40 <edwardk> @undefine
10:32:47 <`nand`> but I generally prefer associated type/data families
10:32:51 <Cale> edwardk: Kind of interesting how that restriction works :P
10:32:59 <Cale> okay, I'll see what I can do
10:33:05 <merijn> Yeah, I started working with TypeFamilies more
10:33:16 <Chathurga> merijn: Don't even know those, more reading for me
10:33:19 <edwardk> t just came up in #haskell-lens and i didn't notice until i was 20 lines later into the example ;)
10:33:24 <rwbarton> well type families are not a replacement for MPTCs in general
10:34:02 <`nand`> yes
10:34:06 <elliott> Cale: I notice that (.) is still funky even though the flip/NumInstances stuff got removed
10:34:13 <`nand`> but I see many uses of MPTCs + FunDeps where they'd be applicable as well
10:34:14 <Cale> edwardk: btw, why are you off in a separate channel for lens? Isn't that relevant discussion for here?
10:34:17 <merijn> Chathurga: MPTC let you define type classes with more than parameter, i.e. "class Convertable a b where convert :: a -> b"
10:34:35 <edwardk> cale: we have a lot of builtbot spam over there ;)
10:34:42 <Cale> (I ask because I'm probably interested in discussion of lens, but I already have too many channels)
10:34:55 <elliott> I think people would get sick of the endless lens talk
10:35:00 <`nand`> you can always make room for more #haskell- channels :)
10:35:03 <elliott> it has a lot of bikeshedding
10:35:11 <Cale> elliott: Yes, that is intentional.
10:35:14 <glguy> There is enough discussion about the library that it would would interfere with both the discussion here and there to merge them
10:35:25 <Cale> elliott: (I mean about your observation)
10:35:36 <merijn> Chathurga: GADTs is certainly worth reading about, although you'd first need to be familiar with phantom types and/or existential quantification to really see the value of GADTs, I guess
10:35:38 <Cale> @flush
10:35:44 <edwardk> i don't mean to hide away all the lens chatter. its mostly been discussion of how to get multi-field lens updates to work
10:35:45 <elliott> intentionally confusing :P
10:35:56 <Cale> It's really not confusing
10:36:27 <Chathurga> I want to bite off all of haskell and chew it all at the same time
10:36:35 <Cale> @let derp :: () :- (x ~ x); derp = Sub Dict in derp
10:36:42 <Cale> :t derp
10:36:42 <lambdabot>   TypeFamilies is not enabled
10:36:44 <edwardk> e.g. given data V2 a = V2 { __x, __y :: a }; makeExposed ''V2;   over exposed ? (V2 "hello" "world") $ \x -> x & _1 .~ 2 & _2 %~ length
10:36:45 <Cale> wat
10:36:47 <Cale> okay
10:36:52 <lambdabot>     Not in scope: `derp'
10:37:03 <edwardk> the in derp was a mistake anyways
10:37:04 <Cale> umm, I don't know what's wrong at this point
10:37:11 <edwardk> @let derp :: () :- (x ~ x); derp = Sub Dict
10:37:14 <edwardk> :t derp
10:37:16 <Chathurga> merijn: Any pointers on where to read about all the precursors to GADTs?
10:37:18 <Cale> I added -XTypeFamilies to the commandline
10:37:18 <lambdabot>   TypeFamilies is not enabled
10:37:24 <lambdabot>     Not in scope: `derp'
10:37:29 <Cale> But maybe not the right one
10:37:32 * hackagebot gnuplot 0.5.0.2 - 2D and 3D plots using gnuplot  http://hackage.haskell.org/package/gnuplot-0.5.0.2 (HenningThielemann)
10:37:41 <Cale> lambdabot's @let seems to double typecheck things
10:37:42 <merijn> Chathurga: Well, phantom types are a fairly simple idea. This explanation seems good: http://www.haskell.org/haskellwiki/Phantom_type
10:37:46 <rwbarton> > let derp :: () :- (x ~ x); derp = Sub Dict in 2
10:37:56 <lambdabot>   2
10:38:01 <rwbarton> > let derp :: () :- (x ~ x); derp = Sub Dict in typeOf derp
10:38:04 <Chathurga> Ah was going to ask if haskell wiki was sufficient
10:38:06 <Cale> and right now, this is preventing unsafeCoerce from being definable, so I'd rather not mess with it too much
10:38:08 <rwbarton> (no way will this work)
10:38:08 <lambdabot>   No instance for (Data.Typeable.Internal.Typeable
10:38:14 <lambdabot>                     (() Da...
10:38:19 <edwardk> Cale: fair enough
10:38:39 <merijn> Chathurga: Actually, this one seems a bit better: http://en.wikibooks.org/wiki/Haskell/Phantom_types
10:39:22 <merijn> Chathurga: That also goes into GADTs and shows how GADTs can be used with phantom types for fun and profit
10:39:29 <edwardk> cale: not sure if you saw the addition of Prisms to lens
10:39:34 <ion> Woot, NumInstances-by-default was killed? Nice.
10:39:37 <Chathurga> merijn: Haha very good, thanks
10:39:40 <edwardk> thats probably the most interesting thing thats happened lately
10:39:47 <edwardk> that was a big part of 3.7
10:40:01 <Cale> edwardk: I noticed it, but I didn't really look into what they were
10:40:08 <edwardk> they are 'colenses'
10:40:20 <edwardk> in part an answer to your 'what is a lens in another category'
10:40:25 <edwardk> they are lenses in Hask^op
10:40:33 <edwardk> :t _left
10:40:41 <lambdabot> (Applicative f, Prismatic k) => k (a -> f b) (Either a c -> f (Either b c))
10:40:43 <`nand`> > 1 2
10:40:50 <lambdabot>   Could not deduce (GHC.Num.Num (a0 -> t))
10:40:56 <lambdabot>    arising from the ambiguity chec...
10:40:57 <edwardk> > over _left (+1) $ Left 4
10:41:01 <`nand`> oh no!
10:41:06 <lambdabot>   Left 5
10:41:18 <edwardk> > 4 ^.remit _left
10:41:21 <lambdabot>   Left 4
10:41:30 <edwardk> they work like constructors
10:41:32 <`nand`> remit is the Prismatic ‘from’?
10:41:32 <ion> > 4 ^. remit (_left . _just)
10:41:34 <lambdabot>   Could not deduce (GHC.Base.Functor
10:41:35 <lambdabot>                      (Control.Lens.Inter...
10:41:50 <edwardk> `nand`: yeah. remit only gives you a getter
10:41:55 <rwbarton> > 4 ^. remit (_left Control.Category.. _just)
10:41:57 <lambdabot>   Not in scope: `Control.Category..'
10:42:01 <rwbarton> oh come on
10:42:04 <rwbarton> adding insult to injury
10:42:08 <edwardk> heh
10:42:10 <`nand`> ? 4 ^. remit _left . _just
10:42:17 <`nand`> > 4 ^. remit _left . _just
10:42:18 <lambdabot>   Couldn't match expected type `Data.Either.Either t0 c0'
10:42:18 <lambdabot>              with a...
10:42:23 <ion> @type (Cat..)
10:42:25 <lambdabot> Couldn't find qualified module.
10:42:26 <ion> @type (C..)
10:42:28 <lambdabot> Couldn't find qualified module.
10:42:32 <ion> @type (Category..)
10:42:34 <lambdabot> Couldn't find qualified module.
10:42:36 <ion> meh
10:42:38 <rwbarton> > 4 ^. remit (_left <<< _just)
10:42:38 <edwardk> `nand`: you need to compose with Control.Category
10:42:40 <lambdabot>   Left (Just 4)
10:42:41 <edwardk> hah
10:42:50 <edwardk> good answer
10:42:50 <Cale> :t (Control.Category..)
10:42:52 <lambdabot> Control.Category.Category cat => cat b c -> cat a b -> cat a c
10:43:01 <`nand`> oh, _just is a prism
10:43:16 <ion> > 4 ^. remit (_left Control.Category.. _just)
10:43:19 <lambdabot>   Not in scope: `Control.Category..'
10:43:26 <edwardk> most 'constructor-like' traversals were upgraded to prisms
10:43:27 <elliott> if only lambdabot had Control.Category's (.)...
10:43:32 <Chathurga> merijn: Ah yes I see now, very cool
10:43:57 <edwardk> anyways if a lens gives you access to the parts of a product, prisms give you access to the parts of a sum.
10:44:04 <ion> elliott: That would confuse newbies, though. It would be as bad as if (.) was, say, fmap.
10:44:08 <Cale> Seems reasonable :)
10:44:48 <`nand`> I wonder if there's a reasonable generalization of (.) that covers both the ‘fmap’ and the (Category..) cases
10:45:00 <ion> I’d prefer a vanilla (.) and a qualified (.) from Category.
10:45:10 <Cale> I wonder if there's an inversion of control we can do to Prism to make Prelude's (.) work
10:45:10 <ion> (Cat..) for instance.
10:45:20 <`nand`> I'd prefer a pretty operator specialized to Prisms
10:45:25 <`nand`> in Control.Lens.Prism
10:45:35 <edwardk> Cale: you can compose with Prelude (.) they just dumb down to traversals on the way
10:45:35 <elliott> `nand`: then you lose composition with Isos.
10:45:37 <elliott> oh well
10:45:43 <elliott> I guess you do with Category? wait, no
10:45:48 <`nand`> elliott: okay. Then I'd prefer a pretty operator /not/ specialized to Prisms
10:45:49 <elliott> since Isomorphic is a superclass
10:45:51 <glguy> We already have <$> for fmap, we don't need (.) , too
10:46:00 <elliott> `nand`: a pretty operator like (.) :P
10:46:07 <glguy> Then (.) can be Category's
10:46:10 <`nand`> (.) as fmap was mainly fun for (.:); but we have lenses for that now
10:46:11 <edwardk> there isn't enough information in the signature to make it both compose with a traversal using (Prelude..) and let you get access to the parts for remit, etc.
10:46:22 <Cale> hmm
10:46:24 <`nand`> I'd be in favor of Category's (.) for lenses
10:46:31 <edwardk> at least as far as i can tell
10:46:55 <edwardk> if you can make Iso and Prism compose with (.) from the Prelude and remain an Iso or Prism i'd definitely be happier
10:47:18 <edwardk> right now they come out as a Lens or Traversal respectively
10:51:21 <aristid> `nand`: but you can use Category's (.) for lenses :)
10:51:30 <`nand`> aristid: I meant for lambdabot
10:51:35 <aristid> oh
10:51:43 <aristid> `nand`: yeah i heard Cale does not like that idea
10:53:03 <ion> Yes, i can see why he would be against replacing (Prelude..) with something strange.
10:53:21 <`nand`> :)
10:53:55 <edwardk> ion: hah
10:54:15 <elliott> :t (.)
10:54:17 <lambdabot> Functor f => (a -> b) -> f a -> f b
10:54:18 <elliott> :t id
10:54:19 <lambdabot> a -> a
10:54:31 <elliott> the advantage of Category is that you can make "id" confusing too
10:55:23 <`nand`> clearly, we need Semigroupoid's (.)
10:57:29 <`nand`> I uh
10:57:54 <`nand`> I only now realized that there's an instance MonadReader r ((->) r)
10:58:23 * elliott wonders why you can't ever put a forall on the RHS of a type synonym/type family instance.
10:58:26 <elliott> it's really annoying
10:59:30 <`nand`> works for type synonyms, no?
11:00:17 <elliott> hm, well, yes, actually, but not in the context I was doing it
11:00:26 <elliott> I'd have to type-CPS stuff up
11:00:45 <edwardk> semigroupoid uses `o`
11:00:52 <edwardk> maximal confusion
11:01:00 <rwbarton> we already have o, no good
11:01:07 <rwbarton> :t o
11:01:08 <lambdabot> Expr
11:04:11 <elliott> I guess what I actually want is "exists" for constraints
11:04:14 <elliott> (exists b. (Foo a b)) => ...
11:04:22 <elliott> just (Foo a b) => ... but you ignore b
11:04:27 <elliott> and don't have to forall it outside
11:05:40 <`nand`> edwardk: surely ‘aside’ can be generalized to an arbitrary Traversal, not just (e,) ?
11:05:43 <elliott> right now it is stopping me using type families, I need to use fundeps because otherwise I need to pass in a stream of forall'd type variables to my constraint family!
11:05:47 <elliott> this is sort of ridiculous
11:06:12 <edwardk> `nand`: possibly. test it, prove it, improve it ;)
11:09:02 <rwbarton> @type aside
11:09:04 <lambdabot> (Applicative f, Prismatic k) => APrism s t a b -> k ((e, a) -> f (e, b)) ((e, s) -> f (e, t))
11:10:35 <`nand`> maybe not an arbitrary traversal but an arbitrary functor
11:13:19 <elliott> `nand`: if it works with any functor it should work with any traversable :P
11:13:47 <`nand`> I meant some Functor instance; not a lens
11:14:13 <`nand`> anyway, let's see if I get it working first
11:16:54 <`nand`> edwardk: I can't get your code to type-check, apparently
11:17:28 <`nand`> oh, never mind
11:17:32 <`nand`> you're using category's (.)
11:26:15 <`nand`> edwardk: ah, doesn't quite work as I had anticipated; since it requires f (Either a b) -> Either (f a) (f b); while Traversable only provides f (Either a b) -> Either a (f b)
11:26:53 <sclv> oh, you need biversable :-)
11:27:47 <startling> bitraversable is is the bifunctor package
11:28:29 <`nand`> isn't that the other way round?
11:28:39 <`nand`> Bitraversable gives me Either (f a) (f b) -> f (Either a b) :)
11:29:07 <startling> oh heh
11:29:11 <rwbarton> that direction is free
11:29:26 <rwbarton> well, assuming f is a Functor
11:31:42 <dgpratt> @seen dcoutts
11:31:43 <lambdabot> Unknown command, try @list
11:31:49 <dcoutts> @yarr!
11:31:50 <lambdabot> I'll keel haul ya fer that!
11:31:54 <dgpratt> :)
11:31:59 <dgpratt> worked anyways :)
11:32:04 * dcoutts notes that lambdabot is right
11:33:18 <dgpratt> dcoutts: this may not matter to you, but I thought it might be worth mentioning that I worked around my most recent cabal issue by installing bsdtar and renaming it tar
11:34:52 <dgpratt> apparently on Windows, bsdtar is...more functional than tar
11:35:12 <`nand`> Windows has tar?
11:35:20 <dgpratt> GNU Tar
11:35:30 <dgpratt> via gnuwin32
11:35:52 <`nand`> I've heard GnuWin32 is pretty broken
11:36:06 <`nand`> have you tried via Interix?
11:36:13 <dgpratt> well, gnuwin32 tar is broken, I can tell you that
11:36:22 <dgpratt> `nand`: no
11:36:39 <`nand`> I would like to know how well Haskell+Interix works :)
11:37:31 <zdani> @pl \xs -> zipWith (-) (tail xs) xs
11:37:32 <lambdabot> zipWith (-) =<< tail
11:38:39 <zdani> @pl \xs -> zipWith (\a b -> b a b) (tail xs) xs
11:38:39 <lambdabot> zipWith (join . flip id) =<< tail
11:39:11 <dcoutts> dgpratt: oh the lack of the -z option
11:39:11 <zdani> @pl \xs -> zipWith (\a b -> a b a) (tail xs) xs
11:39:12 <lambdabot> zipWith (join flip) =<< tail
11:39:22 <dgpratt> dcoutts: yes
11:39:54 <dcoutts> dgpratt: the way it should work of course is that ./setup sdist should give us a src image directory that we can do what we want with
11:40:01 <dcoutts> dgpratt: it's silly that it calls tar itself
11:40:25 <dcoutts> dgpratt: should be easy to do, if you feel like sending us a patch
11:40:41 <dcoutts> dgpratt: oh!
11:40:46 <dcoutts> I implemented that already
11:40:54 * dcoutts thought he'd already thought it was a good idea
11:40:59 <clahey> Where does =<< come from?
11:41:00 <dgpratt> dcoutts: oh?
11:41:01 <dcoutts> dgpratt: --output-directory=DIR
11:41:21 <fmap> @hoogle (=<<)
11:41:22 <lambdabot> Prelude (=<<) :: Monad m => (a -> m b) -> m a -> m b
11:41:22 <lambdabot> Control.Monad (=<<) :: Monad m => (a -> m b) -> m a -> m b
11:41:24 <clahey> Or is that the monad operator and my brain isn't working right?
11:41:31 <dgpratt> dcoutts: I shall have to try that! :)
11:41:34 <clahey> Okay.  Brain just not working right.
11:42:35 <dgpratt> dcoutts: wait a sec, though, where is this implemented? in the Cabal package?
11:42:54 <dgpratt> (I always get confused on this point)
11:45:24 <dgpratt> `nand`: by the way, apparently SUA (nee Interix) is deprecated as of Windows 8
11:47:58 <dcoutts> dgpratt: see ./setup sdist --help
11:49:23 <hpaste> mebaran151 pasted “Moandic Curry Problem” at http://hpaste.org/79127
11:49:31 <mebaran151> I have a function that seems to fail to curry: http://hpaste.org/79127
11:49:36 <`nand`> dgpratt: I heard, but who cares about windows 8?
11:50:01 <mebaran151> the function compiles and can be run at the repl, but I can't seem to make it typecheck when I create a curried version
11:50:28 <startling> mebaran151, do you have any extensions on in ghci?
11:50:39 <mebaran151> startling: only overloadedstrings
11:50:50 <rwbarton> needs NoMonomorphismRestriction or a type signature
11:51:01 <mebaran151> rwbarton: what's that?
11:51:09 <rwbarton> @google NoMonomorphismRestriction
11:51:13 <lambdabot> http://hackage.haskell.org/trac/haskell-prime/wiki/NoMonomorphismRestriction
11:51:13 <lambdabot> Title: NoMonomorphismRestriction – Haskell Prime
11:51:31 <elliott> heh, not the ideal beginner's page
11:51:35 <elliott> @where dmr
11:51:35 <lambdabot> http://www.haskell.org/haskellwiki/Monomorphism_restriction
11:51:36 <startling> oh, yeah, it's the monomorphism restriction
11:51:36 <startling>  
11:51:36 <dgpratt> `nand`: well, me, for one, but I guess its Windows 9 where the problem would arise :)
11:51:39 <elliott> i think that one is bad too though :(
11:51:41 <rwbarton> well that is probably not the most helpful result
11:54:32 <shachaf> rwbarton: I think foo_info being marked as data rather than code has to do with GHC storing foo_closure with some metadata about it directly before foo_info.
11:55:10 <shachaf> So given a foo_info pointer you can either jump to it or subtract from it to get the closure information, which it does count as data.
11:56:07 <thoughtpolice> providing you have TNTC, at least
11:56:37 <shachaf> Or maybe that's unrelated and it could still mark one as code and the other as data.
12:11:04 <pnielsen> I notice a lot of Haskell code, particularly that in popular packages on Hackage, are littered with inline pragmas, mostly for simple/one-line functions. Are these mostly redundant, or does GHC not actually inline most of them?
12:12:04 <merijn> pnielsen: (Warning, wild speculation from my side) I think GHC by default only inlines within a module, not across modules? Maybe something to do with that?
12:12:21 <pnielsen> oh, that would explain it
12:13:14 <thoughtpolice> it depends. GHC will automatically stuff 'small' definitions into interface files, and those can be inlined across modules
12:13:37 <magnusse> Hi there!
12:13:38 <hpaste> NihilistDandy pasted “Trying the Pipes tutorial” at http://hpaste.org/79128
12:13:47 <thoughtpolice> otherwise, you can force it with INLINE or INLINEABLE, which have slightly different semantics. in practice you probably want INLINEABLE unless you really want to always force it
12:13:59 <NihilistDandy> I'm looking at interleaved IO with pipes, but it's giving me some very ugly kind errors
12:14:18 <pnielsen> I'm wondering if it's mostly habit to reason about the compiler behavior (even though IIUC GHC isn't forced to respect such a pragma), or if I really need to spray inline all over my packages
12:14:21 <magnusse> I don't know if this is the right place for this. But I'm wondering if there is any helpful soul out there that can help me with a rather newbish question?
12:14:25 <NihilistDandy> And type errors
12:14:34 <NihilistDandy> magnusse: Whatcha need?
12:15:14 <pnielsen> thoughtpolice, merijn: thanks!
12:15:16 <shachaf> pnielsen: GHC will inline cross-module according to various heuristics but usually not for functions over a certain size.
12:16:00 <shachaf> pnielsen: In the case of "lens", for example, we have relatively big functions that sometimes combine together to inline into nothing at all. So we put INLINE everywhere to get all the code in one place so the simplifier can figure it out.
12:16:22 <thoughtpolice> pnielsen: GHC will actually always respect INLINE unconditionally (when the inliner is enabled of course,) but not necessarily INLINEABLE. it is in general used to make sure GHC doesn't miss things it otherwise should. sometimes you can know that large amounts of code can reduce to nothing, so you force INLINE to make sure that always happens
12:16:28 <thoughtpolice> yeah, like shachaf said
12:16:42 <shachaf> This is harder across modules because that way GHC doesn't know how many times a piece of code is used.
12:16:54 <magnusse> NihilistDandy: Well. I have a parser that currently has a method called "item" which parses a single character from a string (parser is an instance of monad also). What I want is to parse for a String instead of a char. I think I should use sequence for that somehow, but can't really figure out how sequence works well so i'm a little stuck
12:17:01 <shachaf> If it's only ever used once, for example, GHC will (probably) inline it no matter how big it is.
12:17:26 <pnielsen> thoughtpolice, shachaf: thanks, I was hoping for something like that
12:17:42 <`nand`> shachaf: id (id (id (id (id (...)
12:17:46 <shachaf> Figuring out what to inline and not inline (and when and how) is very tricky, so people who know what they want and want to be sure it happens nudge the compiler with the pragmas.
12:18:08 <NihilistDandy> magnusse: hpaste.org
12:18:32 <magnusse> NihilistDandy: 1 sec!
12:18:51 <shachaf> pnielsen: Inlining is also much more important for performance in Haskell than in strict imperative languages.
12:19:01 <shachaf> Which is why you see people paying so much attention to it.
12:19:11 <thoughtpolice> inlining is basically the mother of all our optimizations, almost.
12:19:20 <thoughtpolice> since it can enable so many more
12:19:32 <pnielsen> it makes sense
12:20:06 <thoughtpolice> it can also explode your compile time if you're not careful, but sometimes that's the only way to get acceptably speedy code :P
12:21:21 <thoughtpolice> i believe dolio mentioned to me once the INLINE pragmas in vector-algorithms make well over an order of magnitude performance difference, but being that aggressive can cause GHC to bail on inlining unless you set it's inline threshold higher, etc. and that really hurts compile time
12:22:32 <hpaste> magnusse pasted “Need help with Parsers!” at http://hpaste.org/79129
12:22:46 <magnusse> oh it automatically posted it
12:22:51 <pnielsen> interesting, is that something people do before deploying to production? (adding more aggressive optimization than -O2 / -fllvm)
12:22:54 <jerry-> is anyone familiar with a stemming porter algorithm for haskell byte strings? I could only find one for String
12:23:04 <jerry-> +library
12:23:12 <magnusse> NihilistDandy: there it is at least, might be hard to understand so incluided comments... it is NPt the whole file there, only the parts I thought u would need
12:23:26 <NihilistDandy> Okay
12:23:29 <merijn> pnielsen: Depends on your requirements. Fast enough is fast enough
12:23:40 <pnielsen> merijn: true
12:24:25 <`nand`> magnusse: you can also write newtype Parser a = P { parse :: String -> Maybe (a, String) } -- and the ‘parse’ function will be auto-generated
12:24:39 <thoughtpolice> pnielsen: well, it's the only way to get vector-algorithms to actually exhibit acceptable performance people would expect :P and that's an important aspect of vector-algorithms expected use cases anyway. so realistically any version of vector-algorithms is going to need to INLINE everything, having a version without those pragmas isn't that great
12:24:56 <jerry-> by the way how would one write a library that works with both string and bytestring? anything better than copy/paste?
12:25:23 <magnusse> NihilistDandy: should I include the rest of the code? I understand it must be hard to draw much from what I posted, but I'm desperate hehe :)
12:25:34 <thoughtpolice> in the future GHC may be smarter and such a large hammer won't need to be used (INLINE is basically a hammer,) but right now that's the way it is
12:25:40 <NihilistDandy> magnusse: No, I'm just looking it over.
12:25:43 <`nand`> jerry-: IsString maybe
12:25:51 <pnielsen> jerry-: you can use Stringable with OverloadableStrings
12:26:13 <fmap> Overloaded
12:26:23 <`nand`> (IsString s, Monoid s) -- gives you concatenation and String -> s
12:26:30 <pnielsen> OverloadedStrings :)
12:26:45 <`nand`> jerry-: depends on what operations you need, ultimately
12:27:10 <shachaf> ByteStrings aren't collections of characters, so it doesn't make sense to have a function :: String -> ByteString.
12:27:14 <pnielsen> thoughtpolice: just curious, what's the toggle?
12:27:22 <thoughtpolice> pnielsen: hm?
12:27:29 <`ramses> is xor on booleans implemented in some module? can't seem to find it immediately
12:27:32 <pnielsen> thoughtpolice: to make it inline more aggressively
12:27:32 <shachaf> Also they have completely different performance characteristics, so it rarely makes sense to build them up the same way.
12:27:35 <shachaf> `ramses: (/=)
12:27:55 <bgamari> pnielsen, are you sure you want bytestring and not Text?
12:27:57 <`ramses> shachaf: ah, of course! :)
12:28:09 <shachaf> A better comparison would be Data.Text to String, since those have the same goal, only the different performance characteristics.
12:28:26 <NihilistDandy> magnusse: So what do you want to do with the string? Just pull out the last character?
12:28:34 <pnielsen> bgamari: think you want jerry-
12:28:43 <bgamari> jerry-, rather
12:28:47 <zdani> @pl \x -> [x]
12:28:48 <lambdabot> return
12:29:23 <zdani> So apparently, join == (>>= id)
12:29:31 <thoughtpolice> pnielsen: there's a small set of -funfolding-* flags, but the most important one IIRC is -funfolding-use-threshold=<int>, which will basically say at what level the inliner bails
12:29:46 <pnielsen> thoughtpolice: perfect, thanks
12:29:52 <thoughtpolice> and every -O level implies different settings
12:30:03 <thoughtpolice> I think -Odph actually has the most aggressive inlining settings by default
12:30:19 <thoughtpolice> it sets the unfolding threshold pretty high IIRC
12:30:19 <jerry-> bgamari no idea? I only used String so far. but since I am doing some heavy parsing now I wanted to use something that wasn't a linked list
12:30:32 <magnusse> NihilistDandy: I use the parser for reading in Mathematical expressions which i then translate to my own datatype... what I want to use that particular function for is to parse "sin" and "cos" functions.. for example i parse and get a result Just ("sin", "(2*x+2)") then I know that (2*x+2) is in a "sin" function. If you understand what I mean
12:31:09 <`ramses> zdani: yes
12:31:09 <NihilistDandy> Oh, you want to take a string and split it, then, I think
12:31:30 <NihilistDandy> @hooogle split
12:31:31 <lambdabot> Prelude splitAt :: Int -> [a] -> ([a], [a])
12:31:31 <lambdabot> Data.List splitAt :: Int -> [a] -> ([a], [a])
12:31:31 <lambdabot> Data.Typeable splitTyConApp :: TypeRep -> (TyCon, [TypeRep])
12:31:50 <pnielsen> thoughtpolice: cool, didn't know about -Odph
12:31:54 <magnusse> NihilistDandy: i want it to parse a string, and recognize when it has seen exactly "sin". I already got it working for digits etc (didnt show that code).
12:32:20 <magnusse> NihilistDandy: and give "nothing" if it dont regognize something in the string as valid math-expression
12:33:00 <NihilistDandy> Hmm. That's probably a little more complicated.
12:33:37 <magnusse> NihilistDandy: You want me to send what I have? This must be quite hard to understand else I believe.. I already got most of the "skeleton" and was told this should be easy actually :)
12:33:39 <bgamari> jerry-, in that case you almost certainly want text
12:34:05 <jerry-> bgamari I see thanks
12:34:19 <NihilistDandy> magnusse: I don't know parsers too well, so someone else may be able to help more.
12:34:38 <magnusse> NihilistDandy: okay, np. Thanks anyway =
12:34:40 <magnusse> =)
12:34:49 <NihilistDandy> Any time :D
12:35:44 <NihilistDandy> Though I guess you could splitAt ' ' and then check for each word you'll accept.
12:36:03 <NihilistDandy> Unless that looks to be a long list, in which case you'll need something nicer
12:37:00 <magnusse> NihilistDandy: yeah, I just have to sit down an think harder. Will hopefully come to me eventually.
12:37:18 <zdani> @pl \x -> x * signum x
12:37:18 <lambdabot> ap (*) signum
12:37:55 <jerry-> is there something like filter for a function that returns IO Bool ?
12:38:09 <jerry-> I am trying to do something like this: filter doesDirectoryExist files
12:38:56 <jerry-> nevermind, filterM
12:39:13 <jerry-> (hoogle rocks)
12:39:23 <merijn> jerry-: Yup :)
12:39:40 <NihilistDandy> Anybody know much about the new pipes API? I'm trying to experiment with it, but I don't quite follow the errors I'm getting in the sample code.
12:40:22 <NihilistDandy> http://hpaste.org/79128
12:40:39 <merijn> jerry-: Unrelated, but worth knowing: monad-loops is pretty sweet, but unfortunately I don't think hoogle finds functions exported by it
12:40:57 <zdani> @pl \(f:fs) (g:gs) -> f + g : fs + gs
12:40:58 <lambdabot> ap (flip flip tail . (ap .) . flip flip head . ((.) .) . (. (+)) . flip . (((.) . (:)) .) . (+) . head) tail
12:41:07 <zdani> hahaha
12:41:18 <merijn> jerry-: http://hackage.haskell.org/packages/archive/monad-loops/0.3.3.0/doc/html/Control-Monad-Loops.html
12:41:54 <merijn> zdani: That's acting weird because you're adding lists together (fs + gs)
12:42:05 <zdani> ah, right
12:42:22 <merijn> zdani: Also, looks like zipWith
12:42:27 <merijn> :t zipWith
12:42:28 <lambdabot> (a -> b -> c) -> [a] -> [b] -> [c]
12:42:51 <zdani> kinda
12:42:55 <zdani> I want something like this:
12:43:14 <zdani> @pl f (f:fs) (g:gs) = f+g : f fs gs
12:43:15 <lambdabot> f = (`ap` tail) . (. head) . ap (flip . (((.) . (:)) .) . (+)) (join id) . tail
12:43:42 <merijn> zdani: Isn't that just "zipWith (+)"?
12:43:57 <zdani> Oh, right, yeah
12:43:59 <merijn> > zipWith (+) [a,b,c] [d,e,f]
12:44:01 <lambdabot>   [a + d,b + e,c + f]
12:44:17 <zdani> Thanks :)
12:45:53 <otters> @pl \x f -> (x, f x)
12:45:54 <lambdabot> liftM2 (.) (,) (flip id)
12:46:00 <otters> @pl \x f -> (f x, x)
12:46:01 <lambdabot> flip =<< ((,) .) . flip id
12:47:30 <zdani> Now what about convolution?
12:48:21 <zdani> @pl f (f:fs) (g:gs) = f*g : zipWith (+) (f [f] gs) (f fs (g:gs))
12:48:22 <lambdabot> f = (`ap` tail) . (. head) . ap (ap . (((.) . (:)) .) . (*)) (ap ((.) . ap . (zipWith (+) .) . ap id return) ((. (:)) . (.) . join id)) . tail
12:49:51 <otters> :t let foo f = (f *** id) . join (,)
12:49:52 <lambdabot> <no location info>:
12:49:53 <lambdabot>     not an expression: `let foo f = (f *** id) . join (,)'
12:50:05 <otters> :t \f -> (f *** id) . join (,)
12:50:06 <lambdabot> (c' -> c) -> c' -> (c, c')
12:54:52 <merijn> zdani: If you want to do matrix operations you might be better of using arrays instead of lists?
12:55:19 <zdani> merijn: Oh, I'm really just messing around. Thanks though.
12:59:29 <clahey> I love it when I'm going along in python and all of a sudden some haskell comes out cause it's easier code.
12:59:56 <Darkspiel_> rofl
13:00:50 <clahey> Hmm, map in python subsumes zip and zipWith and zipWith3 and so forth.
13:01:24 <`ramses> clahey: I have that all the time at work with java :)
13:02:07 <clahey> This wasn't so bad.
13:02:25 <clahey> map (lambda name: path + ":" + name, list)
13:02:38 <clahey> Instead of map ((path + ":") ++) list
13:02:40 <NihilistDandy> Looking through the pipes tutorial and getting kind errors on the example code. Any advice? http://hpaste.org/79128
13:02:45 <clahey> s/+/++/
13:04:21 <zdani> Strange. Why is ix = liftM2 (*) abs signum inferred as ix :: Integer -> Integer when it could be ix :: Num a => a -> a ?
13:04:36 <shachaf> @where dmr -- zdani
13:04:36 <lambdabot> http://www.haskell.org/haskellwiki/Monomorphism_restriction
13:06:03 <NemesisD> anyone familiar with the errors library?
13:08:46 <Chathurga> @pl f a b = swap (flip splitAt a b)
13:08:47 <lambdabot> f = (swap .) . flip splitAt
13:09:09 <`ramses> :t swap
13:09:10 <lambdabot> (a, b) -> (b, a)
13:09:39 <`ramses> :t swap . fmap . swap
13:09:40 <lambdabot>     Couldn't match expected type `(a0, b0)'
13:09:41 <lambdabot>                 with actual type `f0 a1 -> f0 b1'
13:09:41 <lambdabot>     Expected type: (a1 -> b1) -> (a0, b0)
13:09:44 <Chathurga> That pl thing is incredibly handy
13:09:55 <elliott> don't use (swap .) . flip splitAt
13:10:03 <elliott> btw (flip splitAt a b) = splitAt b a
13:10:04 <Ralith> if you had to ask @pl you shouldn't use it
13:10:28 <elliott> I use @pl sometimes out of convenience when I wrote a messy thing in longform but you have to be careful about what it gives you :p
13:10:39 <Chathurga> I want to just jam it into mapAccumL without the intermediate assignment of a new funtion
13:11:01 <Ralith> that is what lambda is for
13:11:02 <zdani> Use a lambda
13:11:05 <merijn> Chathurga: You could just pass a lambda?
13:11:19 <merijn> \a b -> swap (flip splitAt a b)
13:11:27 <Chathurga> Yeah okay I just like to see how much I can cram into point free
13:11:45 <merijn> or, better, why not "swap (splitAt b a)"?
13:12:20 <Chathurga> disclaimer: They're only euler problems, I'm not cursing some future code reader!
13:13:52 <Ralith> that's no excuse to develop bad habits
13:14:47 <Chathurga> Ralith: Jeez okay then, how would I know it's bad unless I try
13:15:03 <int-e> but one doesn't need excuses to develop bad habits.
13:15:08 <Ralith> by asking #haskell :D
13:15:33 <Chathurga> Basically what I was wondering is how to get a function that takes two arguments and pipe the result into another function, point free
13:16:16 <Ralith> :t (.:)
13:16:17 <lambdabot> (Functor g, Functor f) => (a -> b) -> f (g a) -> f (g b)
13:17:11 <clahey> > (+ 7) .: (-) 10 3
13:17:13 <lambdabot>   No instance for (GHC.Num.Num (f0 (g0 b0)))
13:17:13 <lambdabot>    arising from a use of `e_1710...
13:17:25 <clahey> > ((+ 7) .: (-)) 10 3
13:17:28 <lambdabot>   14
13:17:44 <clahey> @src (.:)
13:17:45 <lambdabot> Source not found. BOB says:  You seem to have forgotten your passwd, enter another!
13:17:48 <clahey> @src .:
13:17:48 <lambdabot> Source not found. And you call yourself a Rocket Scientist!
13:17:53 <merijn> Except, of course that .: doesn't exist in the stdlib (although you can define is using the boobie operator)
13:17:59 <merijn> :t (.).(.)
13:18:00 <lambdabot> (Functor f1, Functor f) => (a -> b) -> f (f1 a) -> f (f1 b)
13:18:12 <merijn> :t (Prelude..)Prelude..(Prelude..)
13:18:14 <lambdabot> (b -> c) -> (a -> a1 -> b) -> a -> a1 -> c
13:18:54 <NihilistDandy> :t ((.).(.).(.)) -- the total recall operator
13:18:56 <lambdabot> (Functor f2, Functor f1, Functor f) => (a -> b) -> f (f1 (f2 a)) -> f (f1 (f2 b))
13:18:57 <clahey> Now I understand the definitions with functors.
13:19:29 <clahey> :t (Prelude..)Prelude..(Prelude..)Prelude..(Prelude..)
13:19:30 <lambdabot> (b -> c) -> (a -> a1 -> a2 -> b) -> a -> a1 -> a2 -> c
13:20:23 <clahey> > ((.).(.)) (+7) (-) 10 3
13:20:25 <lambdabot>   14
13:20:42 <clahey> :t (.::)
13:20:44 <lambdabot>     Not in scope: `.::'
13:20:44 <lambdabot>     Perhaps you meant `.:' (line 111)
13:20:56 <Chathurga> Ah cool, I will ask the people instead of the bots from now on ;)
13:21:33 <`nand`> Chathurga: have a look at Data.Function.Pointless
13:21:36 <`nand`> it has lots of nice combinators
13:21:49 <Chathurga> Oh I didn't know about it, thanks
13:21:52 <Taneb> @hackage pointless-fun
13:21:52 <lambdabot> http://hackage.haskell.org/package/pointless-fun
13:22:18 <Chathurga> I'm not sure if it's considered bad in excess but I absolutely love point free
13:23:17 <croikle> I just realized recently that >=> is for making binds point-free
13:23:42 <clahey> Chathurga: It is fun.
13:25:13 <byorgey> croikle: right, (>=>) is the analogue of (.) for monadic stuff
13:25:25 <byorgey> well, (<=<) really
13:25:41 <clahey> :t (<=<)
13:25:42 <lambdabot> Monad m => (b -> m c) -> (a -> m b) -> a -> m c
13:25:53 <croikle> yeah, that direction stuff
13:26:13 <croikle> cute syntax, being able to reverse your operators
13:26:33 <`ramses> :t (>=>)
13:26:35 <lambdabot> Monad m => (a -> m b) -> (b -> m c) -> a -> m c
13:26:51 <jerry-> actually it's not a syntax it's a function. you could have written it yourself
13:27:16 <croikle> yes, I know. syntax choices by the library writers
13:27:17 <tac> fish fish fish
13:27:46 <byorgey> >=> >=> >=>
13:28:50 <croikle> :t (>=>) >=> (>=>)
13:28:51 <lambdabot> Monad m => (a -> m b) -> (b -> m b) -> a -> m b
13:28:54 <croikle> fishboob?
13:29:58 <popl> >=D -- jellyfish
13:33:09 <merijn> :t (<>~) -- sperm operator
13:33:11 <lambdabot> Monoid a => Setting s t a a -> a -> s -> t
13:33:33 <clahey> :t (>=>) . (>=>)
13:33:34 <lambdabot> Monad m => (a -> m b) -> (m c1 -> a -> c) -> (b -> m c1) -> a -> c
13:33:53 <clahey> :t (<=<) . (<=<)
13:33:55 <lambdabot> Monad m => (b -> m c) -> (a -> a1 -> a1 -> m b) -> a -> a1 -> m c
13:34:20 <croikle> are you doing the kirby dance? :)
13:34:30 <clahey> :t (<=<) . (.)
13:34:31 <lambdabot> (Monad m, Functor m) => (a1 -> c) -> (a -> m (m a1)) -> a -> m c
13:34:42 <clahey> :t (<=<) . (>=>)
13:34:43 <lambdabot> Monad m => (a1 -> m b) -> (a -> a1 -> b -> m c) -> a -> a1 -> m c
13:35:10 <clahey> croikle: :)
13:35:19 <clahey> :t (>=<)
13:35:19 <croikle> :t (>>=) . (=<<)
13:35:21 <lambdabot>     Not in scope: `>=<'
13:35:21 <lambdabot>     Perhaps you meant one of these:
13:35:21 <lambdabot>       `>=' (imported from Data.Ord),
13:35:21 <lambdabot> Monad m => (a -> m b1) -> (m b1 -> m a -> b) -> m a -> b
13:35:56 <Hafydd> @pl (\x y -> fromIntegral x / fromIntegral y)
13:35:56 <lambdabot> (. fromIntegral) . (/) . fromIntegral
13:35:59 <clahey> Now the question is whether any of these are useful.
13:36:36 <clahey> :t (\x y -> fromIntegral x / fromIntegral y)
13:36:37 <lambdabot> (Fractional a, Integral a2, Integral a1) => a1 -> a2 -> a
13:37:23 <croikle> there are ^>> and ^> to play around with too
13:37:48 <Hafydd> @hayoo Int -> Int -> Float
13:37:48 <lambdabot> Unknown command, try @list
13:37:50 <clahey> @pl \f x y ->f (fromIntegral x) (fromIntegral)
13:37:50 <lambdabot> (const .) . flip flip fromIntegral . (. fromIntegral)
13:38:13 <clahey> @hoogle Integral -> Integral -> Fractional
13:38:13 <lambdabot> Warning: Unknown type Integral
13:38:14 <lambdabot> Data.Function on :: (b -> b -> c) -> (a -> b) -> a -> a -> c
13:38:14 <lambdabot> Prelude curry :: ((a, b) -> c) -> a -> b -> c
13:38:43 <croikle> ooh, on is the way to go there
13:39:02 <croikle> :t (/) `on` fromIntegral
13:39:04 <lambdabot> (Fractional c, Integral a) => a -> a -> c
13:39:17 <Hafydd> Nice.
13:39:26 <alpounet> ocharles, hmm maybe you could mention that Text is compatible with OverloadedString through its IsString instance, so we can just write "foo" and it'll get converted automagically
13:40:36 <Hafydd> > (`on` fromIntegral) (/) 1 2
13:40:38 <lambdabot>   0.5
13:40:42 <clahey> :t uncurry (/) . (fromIntegral &&& fromIntegral)
13:40:43 <lambdabot> (Fractional b, Integral b1) => b1 -> b
13:40:49 <clahey> Oh, right.
13:41:49 <clahey> :t curry . (fromIntegral *** fromIntegral) . uncurry
13:41:50 <lambdabot>     Couldn't match expected type `(a0, b0) -> c0'
13:41:50 <lambdabot>                 with actual type `(c1, c'0)'
13:41:51 <lambdabot>     Expected type: (b1, b'0) -> (a0, b0) -> c0
13:42:23 <clahey> :t uncurry (/) (fromIntegral *** fromIntegral)
13:42:24 <lambdabot>     Couldn't match expected type `(b0, b0)' with actual type `a0 -> b1'
13:42:25 <lambdabot>     In the first argument of `(***)', namely `fromIntegral'
13:42:25 <lambdabot>     In the second argument of `uncurry', namely
13:42:30 <clahey> I'll figure it out later.
13:42:57 <Hafydd> @pl (`on` fromIntegral) (/)
13:42:57 <lambdabot> (/) `on` fromIntegral
13:42:59 <croikle> it does feel like an Arrow kind of thing
13:44:04 <Hafydd> @hoogle Integer -> Integer -> Fractional
13:44:04 <lambdabot> Warning: Unknown type Fractional
13:44:04 <lambdabot> Data.Function on :: (b -> b -> c) -> (a -> b) -> a -> a -> c
13:44:04 <lambdabot> Prelude curry :: ((a, b) -> c) -> a -> b -> c
13:44:09 <Hafydd> @hoogle Integer -> Integer -> Float
13:44:10 <lambdabot> Data.Function on :: (b -> b -> c) -> (a -> b) -> a -> a -> c
13:44:10 <lambdabot> Prelude curry :: ((a, b) -> c) -> a -> b -> c
13:44:10 <lambdabot> Data.Tuple curry :: ((a, b) -> c) -> a -> b -> c
13:44:40 <Hafydd> There really isn't a built in function to do that?
13:44:59 <NihilistDandy> Do what?
13:45:22 <Ralith> :t fromIntegral
13:45:23 <lambdabot> (Integral a, Num b) => a -> b
13:45:24 <NihilistDandy> @hoogle (%)
13:45:24 <lambdabot> Data.Ratio (%) :: Integral a => a -> a -> Ratio a
13:45:25 <Hafydd> If you'll permit me to be vague, to make a fractional out of two integrals: a numerator and a denominator.
13:45:35 <simpson> Hafydd: Data.Ratio.
13:45:38 <NihilistDandy> ^
13:45:44 <simpson> > 5 % 7
13:45:46 <lambdabot>   Not in scope: `%'
13:45:46 <NihilistDandy> > 4 % 3
13:45:46 <lambdabot>  Perhaps you meant `R.%' (imported from Data.Ratio)
13:45:47 <lambdabot>   Not in scope: `%'
13:45:47 <lambdabot>  Perhaps you meant `R.%' (imported from Data.Ratio)
13:45:54 <simpson> > 5 R.% 7
13:45:54 <rwbarton> hehe
13:45:55 <lambdabot>   5 % 7
13:45:59 <Hafydd> > 1 R.% 2 :: Float
13:46:00 <lambdabot>   Couldn't match expected type `GHC.Types.Float'
13:46:00 <c_wraith> hmm.  that import doesn't need to be qualified anymore
13:46:01 <lambdabot>              with actual typ...
13:46:06 <c_wraith> Cale: you around to fix that?
13:46:17 <simpson> > (5 R.% 7) + (3 R.% 11)
13:46:18 <lambdabot>   76 % 77
13:46:20 <Ralith> Hafydd: few things in haskell are not polymorphic.
13:46:47 <simpson> > realToFrac $ (5 R.% 7) + (3 R.% 11) :: Float
13:46:48 <lambdabot>   0.987013
13:50:25 <tromp> what do the '' do again in an expression like makeLenses ''Point ?
13:50:37 <tromp> tha's two single quotes
13:51:04 <rwbarton> ''Point is a Name or something (from TH) that names the type constructor Point
13:51:05 <c_wraith> It creates an expression referring to the type
13:51:48 <rwbarton> :t ''Int
13:51:49 <lambdabot>     Syntax error on ''Int
13:51:49 <lambdabot>     Perhaps you intended to use -XTemplateHaskell
13:51:56 <rwbarton> perhaps!
13:52:02 <Chathurga> It's a metaprogramming thing if you weren't aware either
13:52:11 <tromp> thanks
13:52:59 <Chathurga> Is there any plans to make template haskell nicer?
13:53:42 <thoughtpolice> Chathurga: there is, just a lack of effort to do it
13:54:27 <thoughtpolice> Chathurga: http://hackage.haskell.org/trac/ghc/blog/Template%20Haskell%20Proposal
13:55:25 <int80_h> I read somewhere once that you should have your data records in the same file that you have instance declarations for them. IS this still true?
13:55:34 <shachaf> Yes.
13:55:50 <shachaf> Or the classes.
13:56:33 <int80_h> shachaf: importing the classes achieves the same result right?
13:56:44 <shachaf> ?
13:56:52 <fmap> int80_h: that doesn't actually matter if you're writing application not library
13:56:58 <shachaf> You should have an instance defined either in the same module as the class or the same module as the type.
13:56:59 <int80_h> I didn't write the class myself, I'll be using one from a library
13:57:13 <shachaf> Otherwise it's an "orphan" and you might have conflicting ones.
13:57:22 <thoughtpolice> then you should define the instance in the same module as the type, otherwise you'll have orphans
13:57:25 <shachaf> You can read more about it by looking up that term.
13:57:30 <int80_h> fmap: cool, yeah writing application.
14:13:40 <lightquake> what's the difference between hoist in Control.MFunctor and fmap?
14:15:39 <scooty-puff> is it possible to emulate anything like this (type class cycle): class Pointwise b a c => Pointwise a b c | a b -> c, a c -> b, b c -> a where (.+) :: a -> b -> c
14:16:35 <elliott> is there any way to generate an infinite stream of type variables (at the type level)
14:16:38 <elliott> please don't ask why I need to do this
14:17:47 <fmap> why do you need to do this?
14:18:32 <Taneb> That sounds utterly ridiculous
14:18:45 <acowley> elliott: Why do you hate the type checker?
14:19:14 <c_wraith> scooty-puff: does that not work like that?
14:19:34 <elliott> fmap: well I can't use a typeclass for this because it doesn't glue together properly but if I use a type family I have free variables and you can't quantify inside a Constraint
14:19:45 <elliott> so I need to have the type family user pass in type variables for it to use
14:19:49 <scooty-puff> c_wraith: it gives me an error about cycles
14:19:54 <elliott> but I'd rather just make one big stream rather than having to write a list of them for each use because urgh
14:20:07 <scooty-puff> c_wraith: the closest i have involves DefaultSignatures, where the superclass constraint instead shows up there
14:20:38 <c_wraith> scooty-puff: Oh, I see.  The problem is that the typeclass depends on itself, not the functional dependencies
14:21:24 <Saizan> i guess you could add a method which gives you a dictionary of Pointwise b a c as a GADT
14:21:36 <rwbarton> how about making a one-way version of the class (no context) and then wrapping Foo a b c and Foo b a c together in a single new class
14:21:55 <elliott> hmm
14:22:01 <elliott> maybe I can "trick" alpha renaming into happening
14:22:06 <elliott> if I box stuff up somehow
14:22:19 <elliott> wait, is type-level data even lazy
14:22:42 <Taneb> Ugh
14:22:48 <Taneb> wx has stupid dependencies
14:23:02 <c_wraith> elliott: no, the type level is not lazy
14:23:13 <Taneb> Why am I being punished for having containers 0.5.0.0
14:23:15 <elliott> right, I guess I knew that
14:23:17 <elliott> even lifted data, though?
14:23:42 <scooty-puff> rwbarton: that sounds like a good idea - i guess it makes it so i can't enforce commutativity, but that sounds about as close i'll be able to get without odd extensions
14:23:50 <scooty-puff> (is DefaultSignatures and "odd" extension?)
14:23:55 <scooty-puff> *and -> an
14:24:28 <elliott> hm
14:24:32 <elliott> maybe I could represent it as a type function
14:25:20 <Taneb> elliott, will this allow you or anyone else to write better code
14:25:37 <elliott> Taneb: what do you mean by better
14:26:03 <Taneb> Either more readable or more efficient
14:26:09 <Taneb> Preferably both
14:26:26 <acowley> Taneb: have you tried editing the .cabal file to see if it builds?
14:26:34 <Taneb> Not yet
14:26:53 <Taneb> But it's late and it's the first night of a show I'm in tomorrow
14:31:23 <c_wraith> scooty-puff: by the way, you can't enforce commutativity at the type level anyway. You can enforce that the types are commutative, but not that 1 + 2 = 2 + 1
14:33:33 <quchen> Only fully applied functions can be inlined, right? So if I have something like 'f a x = g x where ...', should I make it point-free for effectivity?
14:34:02 <elliott> does anyone know why you can say
14:34:06 <elliott> type ... = forall x. ...
14:34:07 <elliott> but not
14:34:07 <hpaste> quchen pasted “An example: power algorithm” at http://hpaste.org/79131
14:34:10 <elliott> type instance ... = forall x. ...
14:34:55 <elliott> this seems a pretty pointless restriction to me
14:36:39 <A1kmm> elliott: There are various extensions to Haskell that allow you to write type instances that don't cover all variables (you don't need an explicit forall).
14:37:00 <scooty-puff> c_wraith: right - i meant to type (but got sidetracked) "or at least strongly recommend"
14:37:02 <A1kmm> elliott: The problem is they make it hard for the compiler to prove that you don't have overlapping instances.
14:37:35 <A1kmm> elliott: (or rather, that you can't possibly have overlapping instances when you import the instance)
14:38:00 <LucaS05> hi. i'm trying to define a queue. i've coded this http://hpaste.org/79132 and i got the error. can someone please can explain it? cause i don't know where i'm wrong...
14:38:32 <elliott> A1kmm: thankfully, I already have overlapping instances
14:38:43 * elliott needs -XDon'tWorryBeHappy
14:39:06 <A1kmm> UndecidableInstances??
14:39:07 <NihilistDandy> LucaS05: use ++, not (:)
14:40:17 <NihilistDandy> LucaS05: Also, you probably don't need it in (x:xs) form. Just enq q x = q ++ x should be fine
14:40:19 <elliott> A1kmm: I have that too!
14:41:04 <NihilistDandy> LucaS05: Also, your type signature should be Queue a -> a -> Queue a
14:41:04 <LMolr> I am installing cabal on gentoo, configure phase fails because it needs "base >=4 && <3 && >=2 && <5, unix >=2.0 && <2.6". What can i do!
14:41:35 <LucaS05> ok i will make the changes. sorry but i'm a beginner
14:41:43 <acowley> ocharles: s/"encode and decide"/"encode and decode"
14:41:49 <hpaste> NihilistDandy annotated “Queue” with “Queue (annotation)” at http://hpaste.org/79132#a79133
14:43:01 <A1kmm> elliott: do you have FlexibleInstances?
14:43:06 <NihilistDandy> Though that doesn't clear up the skolem type
14:43:06 <hpaste> fmap annotated “Queue” with “Queue (annotation) (annotation)” at http://hpaste.org/79132#a79134
14:43:26 <elliott> A1kmm: yep!!
14:43:28 <fmap> (++) wants 2 lists
14:43:30 <NihilistDandy> There it is. I knew I missed something obvious
14:44:25 <A1kmm> elliott: http://hpaste.org/79135
14:45:18 <elliott> A1kmm: those sure are overlappy
14:45:40 <A1kmm> that example is roughly what you want right?
14:46:39 <elliott> if it is I'm not seeing it... the type family I want looks like: type instance Foo '[] k = k; type instance Foo (x ': xs) k = forall y. (C x y) => Foo xs k
14:46:49 <elliott> (type family Foo (xs :: [*]) (k :: *) :: *)
14:54:28 <LucaS05> A1kmm the final version http://hpaste.org/79132
14:55:37 <LucaS05> there's a better way to code it?
14:56:42 <A1kmm> LucaS05: I think that looks quite clean.
14:58:27 <quchen> I'm looking for a function that finds the first element of a list occurring multiple times. For example, 'firstDouble [1,2,3,4,4,55,6] == 4', because 4 appears twice first. Using zip this is easy, however is there a fold version?
14:58:31 <quchen> I can't come up with one.
14:59:42 <NihilistDandy> LucaS05: I'd suggest not using head for front, though.
14:59:49 <Chathurga> quchen: You could use group if you mean appears side by side
14:59:57 <LucaS05> why?
15:00:17 <LucaS05> now that i've understand curried functions :D
15:00:35 <NihilistDandy> You write your own implementation with a more informative error message, mostly
15:00:50 <quchen> Chathurga: group would force me to filter by length afterwards. (I've got solutions, I'm just wondering whether this is foldable.)
15:00:59 <Chathurga> Ah right
15:01:03 <NihilistDandy> *You can write
15:01:18 <quchen> I need a fold that can abort when something's been found, so foldr it is
15:01:32 <quchen> ... that's as far as I went so far.
15:01:41 <quchen> Plus some non-working code
15:02:12 <Chathurga> Is group lazy?
15:02:13 <plhk> uhhm, how to abort foldr?
15:02:32 <Chathurga> Just as an aside
15:02:39 * hackagebot HTF 0.10.0.6 - The Haskell Test Framework  http://hackage.haskell.org/package/HTF-0.10.0.6 (StefanWehr)
15:02:49 <LucaS05> ok. so (aside from the italian things :D) the implementation is right?
15:03:02 <NihilistDandy> plhk: Reach the end of the list? C-c?
15:03:38 <plhk> that's what i thought
15:04:05 <quchen> > take 10 . group $ [1..] >>= replicate 3
15:04:08 <lambdabot>   [[1,1,1],[2,2,2],[3,3,3],[4,4,4],[5,5,5],[6,6,6],[7,7,7],[8,8,8],[9,9,9],[1...
15:04:15 <quchen> ^ Chathurga
15:05:21 <acowley> quchen: I'd probably use scanl
15:05:23 <Chathurga> So it is, very cool
15:06:25 <quchen> acowley: scanl builds up another list, how can I use it to solve my problem?
15:06:53 <acowley> quchen: the function you give scanl conses an element that you've seen before, otherwise it just recurses
15:06:57 <Hafydd> @pl sequence . replicate
15:06:57 <lambdabot> sequence . replicate
15:07:22 <zdani> :t zipWith . zipWith
15:07:24 <lambdabot> (a -> b -> c) -> [[a]] -> [[b]] -> [[c]]
15:08:46 <quchen> acowley: I'll see what I can brew with that :-) Thanks
15:10:43 <Chathurga> > fst . head . filter (uncurry (==)) . (zip <*> tail) $ [1,2,3,4,4]
15:10:45 <lambdabot>   4
15:11:20 <Chathurga> That doesn't fit with how you want to do it, just wanted to see a way of doing it
15:12:35 <quchen> Yeah, that's pretty much my zip solution as well
15:12:43 <quchen> Except I used no Applicative
15:13:38 <Chathurga> I just love using (zip <*> tail) haha
15:13:48 <hpc> @quote aztec
15:13:49 <lambdabot> quicksilver says: zip`ap`tail - the Aztec god of consecutive numbers
15:13:58 <quchen> Chathurga: that's the thing I'm trying to understand right now
15:14:02 <quchen> :t zip <*> tail
15:14:04 <lambdabot> [b] -> [(b, b)]
15:14:16 <quchen> zip xs (tail xs)?
15:14:16 <Chathurga> it's basically zip x (tail x)
15:14:21 <Chathurga> exactly
15:14:24 <hpc> > (f <*> y) [x, y, z] :: [Expr]
15:14:26 <lambdabot>   Couldn't match expected type `f0 a0'
15:14:26 <lambdabot>              with actual type `Debug.S...
15:14:30 <hpc> > (f <*> y) x
15:14:33 <lambdabot>   Couldn't match expected type `f0 a0'
15:14:33 <lambdabot>              with actual type `Debug.S...
15:14:35 <hpc> > (f <*> g) x
15:14:37 <lambdabot>   Ambiguous type variable `a0' in the constraints:
15:14:37 <lambdabot>    (GHC.Show.Show a0)
15:14:37 <lambdabot>     ...
15:14:38 <quchen> I deduced that from semantics, not from understanding the expression :x
15:14:41 <hpc> bah!
15:15:03 <hpc> f <*> g = \x -> f x (g x)
15:15:04 <quchen> Aaah! <*> is function-Applicative, not List-Applicative, right?
15:15:07 <quchen> I mean in your case
15:15:08 <ion> > ((f :: Expr -> Expr -> Expr) <*> g) x
15:15:10 <lambdabot>   f x (g x)
15:15:19 <hpc> zip <*> tail = \xs -> zip xs (tail xs)
15:15:41 <quchen> Now it strikes back that I always skipped the function instance of Applicative in LYAH.
15:15:48 <hpc> quchen: the function applicative took me forever to get right
15:15:54 <Chathurga> quchen: Yup, I have a hard time reading functor defintions though so I'm with you on that
15:16:16 <quchen> hpc: The monad's the same difficulty I guess
15:16:19 <quchen> That's why I skipped it
15:16:19 <ion> http://heh.fi/haskell/functors/#function-instance
15:16:28 <quchen> (It's easy when you know it's Reader, but if you don't good luck)
15:16:38 <hpc> yeah, that
15:16:42 <roconnor> the function applicative?  it is S essentially
15:16:54 <quchen> Let me rephrase that: it's hard when you know it should be the same as Reader. It's impossible if you don't.
15:17:13 <hpc> quchen: oddly, (e ->) is a harder monad to learn than Reader
15:17:28 <quchen> roconnor: I'm a physicist, my SKI calculus knowledge is based (scratch that - consists entirely of) reading the first 10 lines on Wikipedia.
15:17:45 <cmccann> it's basically a lightweight inline reader monad.
15:17:45 <lambdabot> cmccann: You have 1 new message. '/msg lambdabot @messages' to read it.
15:17:52 <hpc> quchen: it's easy
15:17:53 <hpc> S = SKI
15:17:58 <hpc> er, KSI
15:18:03 <hpc> dunno what SKI is
15:18:06 <quchen> hpc: Yeah, I noticed that. I never understood it in LYAH, but when I read the Reader instance I was like "wait, that's it"
15:18:07 <hpc> :t ap const id
15:18:09 <lambdabot> a -> a
15:18:13 <hpc> haaa
15:18:22 <quchen> Haha
15:18:25 <ion> :-)
15:18:44 <quchen> (const <*> id) x == const x (id x) = x
15:18:47 <quchen> ... right?
15:18:51 <elliott> right
15:18:52 <quchen> Right.
15:18:55 <quchen> Good Quchen.
15:19:19 <quchen> I'll give myself a cookie for that. And then, after learning Haskell for a year, I'll look back at LYAH for the (->) instances.
15:20:06 <hpc> or you'll just never need it again
15:20:14 * cmccann notes that the (e ->) equivalent of Reader's "ask" function is just id
15:20:16 <Chathurga> I might be getting myself into a good laughing at but I wanted to split a number into it's digits is this an okay or disgusting way of doing it? map (read . (: "")) . show
15:20:17 <hpc> until the next wanker tries out @pl
15:20:36 <hpc> cmccann: return = const
15:20:53 <cmccann> yes, return = pure = K :P
15:20:56 <acowley> quchen: My scanl solution is ugly :(
15:21:22 <hpaste> quchen pasted “integer -> digits” at http://hpaste.org/79137
15:21:25 <hpc> pure K sounds like a nickname for cocaine
15:21:33 <cmccann> what about lazy K
15:21:37 <cmccann> that's a fun language
15:21:42 <cmccann> for certain definitions of fun...
15:21:52 <quchen> acowley: Mine as well. Also, It results in a list, but I want the single element.
15:22:08 <acowley> quchen: You can get out of that
15:22:17 <A1kmm> elliott: I see what you mean about the difficulties but there is an easy workaround I think.
15:22:27 <quchen> acowley: Yeah, but then it's not just a fold anymore :-)
15:22:40 <elliott> A1kmm: ooh, there is? I resorted to a hideous hack
15:23:51 <quchen> Haha. The *definition* of <*> is 'f <*> g = \x -> f x (g x)' for functions. And I thought there would be some higher truth coming.
15:23:53 <hpaste> acowley pasted “Two ugly firstDups” at http://hpaste.org/79138
15:24:12 <cmccann> quchen, well how else would you write it?
15:24:48 <hpaste> quchen pasted “fixed point algorithms” at http://hpaste.org/79139
15:25:28 <quchen> I'm trying to find the most beautiful fixed point algorithm; fixed point in the mathematical sense: take x, apply f until the result doesn't change.
15:25:44 <acowley> I would use the recursive definition, btw. The other version could obviously be improved (eg. why not just use a Maybe for the first element of state?), but the recursion is more obvious.
15:25:59 <quchen> So in my examples, "iterate f x" will at some point reach a fixed point (or it'll be bottom, who cares :>)
15:26:11 <quchen> Therefore, the fixed point is the first double element in 'iterate f x'
15:26:21 <cmccann> quchen, note that (in an untyped setting), (\f g x -> f x (g x)) and (\x _ -> x) are sufficient to compute any computable function. :D
15:26:49 <quchen> cmccann: Is that SK?
15:26:55 <quchen> Wasn't SKI three functions?
15:27:02 <cmccann> you can write I using S and K.
15:27:08 <quchen> What's I?
15:27:09 <A1kmm> elliott: My workaround is still a hideous hack really, and I haven't quite got it to compile.
15:27:15 <cmccann> quchen, I = \x -> x
15:27:20 <quchen> Ah, I == id
15:27:35 <quchen> S.K = I?
15:27:40 <quchen> If K is \x _ -> x
15:27:55 <quchen> Eh, wait. Brainfart
15:27:57 <cmccann> yes, the combinator names are clearly short for Identity, Konstant, and... Something.
15:27:57 <mgccl> I'm looking for a longest common subsequence solution in Haskell that scales. For example non of the solutions I find an do two strings with length around 10k.
15:28:00 * cmccann coughs
15:28:07 <Iceland_jack> cmccann: are they now..
15:28:27 <cmccann> yes, indubitably. it is a true fact that I did not just make up.
15:28:33 <quchen> cmccann: S stands for "sick" I'm sure.
15:28:48 <mgccl> I know how to write one using Array, but not unboxed arrays since the solution has to access other values in the array before array is frozen.
15:29:19 <simpson> :t let s f g x = f x (g x); k x _ = x in s k k -- quchen <<
15:29:21 <lambdabot> t -> t
15:29:35 <quchen> Ah, I see
15:29:40 <hpaste> A1kmm pasted “Attempt at TF based list” at http://hpaste.org/79140
15:30:32 <A1kmm> elliott: I got this far, http://hpaste.org/79140 but ghc 7.6.1 complains about the two ListValue instances being duplicates for some reason.
15:31:45 <elliott> hmm, I see... the problem was more with the foralls, not the list though? unless this avoids the foralls in some way I'm missing
15:32:07 <elliott> (e.g. "type instance Foo () k = k; type instance Foo (x,xs) k = forall y. (C x y) => Foo xs k" exhibits the same issue)
15:34:27 <quchen> cmccann: I'm not sure whether you know this one already: https://gist.github.com/3438688
15:34:34 <quchen> Hello World in SKI :-)
15:34:46 <cmccann> hahaha
15:34:59 <quchen> And they said it's not useful for practical applications!
15:35:12 <simpson> quchen: Have you seen Unlambda yet? :3
15:35:15 <cmccann> you should look at lazy k, it's a language dedicated to that
15:35:18 <cmccann> pf unlambda
15:35:19 <alpounet> quchen, haha awesome
15:35:21 <cmccann> lazy k is better.
15:35:32 <quchen> simpson: Yes, but I don't understand why Unlambda is considered esoteric
15:35:39 <simpson> quchen: Dunno.
15:35:39 <quchen> It certainly is impractical, but so is Lambda calculus
15:35:56 <cmccann> no, pure untyped lambda calculus is (just barely) usable as a programming language.
15:35:58 <quchen> Unlambda is kind of what happens if you actually code Lambda stuff as far as I remember
15:35:59 <elliott> unlambda is cuter than lazy k in some ways
15:36:01 <cmccann> combinatory logic really, really isn't.
15:36:02 <elliott> but lazy k is more elegant
15:36:32 <quchen> The way I always saw Unlambda is that it's to Lambda calculus what Brainfuck is to the Turing Machine
15:36:38 <elliott> unlambda's d/c are pretty horrifying for example
15:36:49 <hpaste> A1kmm pasted “Forall allowed with TFs” at http://hpaste.org/79141
15:36:57 <cmccann> I do like how unlamba included callcc purely on the grounds that it made things worse
15:36:58 <elliott> quchen: well, unlambda actually contains a bunch of stuff you don't need just to make the language more terrifying :P
15:37:10 <A1kmm> elliott: ghc 7.6.1 seems to accept your example...
15:37:20 <A1kmm> (aside from needing the GetSelf hack)
15:37:28 <elliott> A1kmm: that's data, not type
15:37:37 <elliott> it's important there's no constructor unwrapping here
15:38:50 <quchen> elliott: So does Brainfuck
15:39:23 <quchen> Well, there everything makes sense beyond terrifying people actually.
15:39:50 <elliott> eh, you can only take a few instructions off BF and still have something TC, and it usually ends up non-orthogonal to do so
15:40:02 <cmccann> quchen, there's a pretty big gap between lambda calculus (which has variable bindings) and combinatory logic like unlambda, which doesn't.
15:40:17 <quchen> Lambda has variable bindings?
15:40:23 <quchen> As in named things?
15:40:25 <quchen> Huh?
15:40:39 <cmccann> "(\x -> x)" that's naming something "x".
15:40:55 <quchen> Ah, that's already naming
15:41:49 <cmccann> and if you can use arbitrary identifiers as the lambda arguments you can replace regular definitions with a huge top-level lambda that takes the top-level bindings as arguments
15:42:23 <cmccann> and then you jump through a few hoops and eventually you're a pre-processor and a few minor conveniences away from having a lisp dialect
15:42:31 <elliott> lazy lisp
15:43:11 <hpc> elliott: i have seen people write lazy lisps and it is awful
15:43:22 <cmccann> elliott, lazy or not doesn't really change things much in this case
15:43:24 <hpc> a thunk is quoted code, and to eval you literally eval
15:43:40 <elliott> cmccann: yeah. but lisps are almost always strict, so i felt it worth pointing out
15:43:58 <cmccann> heh, pattern matching on the AST of unevaluated thunks would be terrifying
15:44:04 <elliott> does anyone know why superclass cycles are disallowed?
15:44:10 <elliott> class (Foo (Bar t)) => Foo t where type Bar t
15:44:15 <elliott> I don't see why that should be disallowed
15:44:21 <ParahSail1n> i have a strange bug that is very difficult to track down-- my program opens up over 300 different handles and Data.ByteString.hPut's a couple lines at a time to different handles. at the end, there are some files that are size 0, when something should have gone to that handle
15:44:53 <mmcdermo> ParahSail1n: Post some code that has that behavior to hpaste.org
15:45:10 <cmccann> elliott, seems like it'd be easy to end up with something non-terminating that way, but I don't know why undecidable instances couldn't allow it
15:45:25 <elliott> right I have all the -XBreakEverything flags on
15:45:28 <ParahSail1n> i suspect a problem with System.IO hPutBuf
15:45:29 <cmccann> :D
15:45:40 <cmccann> -XForScience!
15:45:43 <elliott> and would like to continue breaking everything without adding an explicit witness function to my typeclass
15:45:46 <elliott> which will make usage awkward
15:45:47 <hpc> elliott: you must have a newer ghc than i do
15:45:56 <hpc> i can only find -XBreakJustTheEdgeCases
15:46:00 <cmccann> -XJustTrustMeOk
15:46:04 <ParahSail1n> if the buffer doesn't fill up, i think that it never gets written to the file
15:46:09 <elliott> hpc: one of the many improvements in 7.6.1
15:46:37 <elliott> cmccann: http://www.cse.chalmers.se/~nad/listings/lib/Relation.Binary.PropositionalEquality.TrustMe.html
15:46:46 <cmccann> -XBreakEverything would make a great replacement for the old glasgow-exts or whatever it was
15:47:10 <tromp> BLC is much closer in spirit to Lazy K than unlambda is
15:47:28 <quchen> cmccann: What did -glasgow-exts do? Something like -XEverything?
15:47:40 <cmccann> I don't recall, but yeah it enabled a bunch of stuff
15:48:21 <quchen> I'm looking at the SKI Wiki article again and I'm wondering what that's good for
15:48:31 <quchen> Minimalist calculus?
15:48:58 <cmccann> well it's not really GOOD for anything, practically speaking.
15:49:09 <cmccann> it exists to be minimal for purposes of reasoning about other things.
15:49:32 <cmccann> just like turing machines or untyped lambda calculus or whatever.
15:50:32 <quchen> So it serves a larger purpose than just being a curiosity then
15:51:24 <cmccann> quchen, yes, in the historical context of when it was developed
15:51:37 <acowley> Why don't we have Functor instances for, eg., First?
15:51:41 <cmccann> note that combinatory logic predates both turing machines and lambda calculus
15:52:01 <quchen> Ah, so SKI isn't made for programming at all?
15:52:05 <cmccann> and the concept of universal computation and computable functions and all that.
15:52:23 <cmccann> it's called "combinatory logic" for a reason!
15:52:25 <lispy> @hoogle First
15:52:25 <lambdabot> Data.Monoid First :: Maybe a -> First a
15:52:25 <lambdabot> Data.Monoid newtype First a
15:52:25 <lambdabot> Control.Arrow first :: Arrow a => a b c -> a (b, d) (c, d)
15:52:47 <quchen> Today's compsci day for me. This morning, I heard an awesome talk about how the brain may not be a turing machine.
15:53:00 <cmccann> of course it's not, it has finite storage
15:53:09 <cmccann> turing machines are much more powerful than a brain :P
15:53:23 <quchen> Not necessarily. That was the point of the talk.
15:53:29 <quchen> A brain may be something "else".
15:53:56 <quchen> Because of reason, the brain can find proofs to theorems the TM cannot solve
15:54:05 <acowley> The obvious Functor and Applicative instances for First are useful
15:54:08 <A1kmm> quchen: So it is not possible to simulate 1 second of brain activity in a finite time on a TM?
15:54:16 <cmccann> quchen, sounds like wishful thinking to me.
15:54:28 <quchen> A1kmm: The thing was speculative, it just threw ideas out there.
15:54:52 <cmccann> yes, and anything about the brain being more powerful than a turing machine always ends at speculation
15:54:57 <acowley> That sounds a bit like some of the "bottoming out" parts of G.E.B.
15:55:00 <quchen> cmccann: Well, there are certain tasks that are very easy for the brain, but unsolvable by the Turing machine.
15:55:28 * elliott thinks this sounds more or less like nonsense in the service of human exceptionalism
15:55:29 <cmccann> unsolvable? or that we don't know how to implement?
15:55:45 <quchen> Unsolvable.
15:55:54 <quchen> For example, you can't solve diophantine equations on a TM.
15:56:05 <cmccann> every time I hear stuff about the brain being more than a turing machine it's a long-winded way of saying "I don't like the idea of AI but don't want to say so"
15:56:14 <quchen> However, as a human, you can find a proof that no solution exists. Therefore, you prove that the TM will never halt.
15:56:27 <cmccann> and why couldn't a TM find the proof?
15:56:42 <quchen> We talked about that during lunch for a looooong time :-D
15:56:48 <cmccann> spoiler: it could
15:56:53 <quchen> The result is that I'm not sure.
15:56:54 <shachaf> cmccann: It might be a way of saying "I don't like the idea of Turing Machines btu don't want to say so".
15:56:56 <elliott> that argument is nonsense
15:57:01 <quchen> I've heard compelling arguments from both sides.
15:57:08 <elliott> the halting problem is that you can't decide halting in *general*
15:57:16 <elliott> not that there are not algorithms that can decide it in certain cases
15:58:41 <quchen> elliott: That was just an example. To give something more concrete: the brain may have the capability of measuring a physical process, something we know a TM cannot do. This would make the brain more than just a neural network, i.e. some set of TMs.
15:59:04 * shachaf sighs.
15:59:10 <quchen> You can now map many problems on some kind of a physical process. For example, diophantine equations can be mapped onto a Hamiltonian.
15:59:30 <quchen> If the ground state of that Hamiltonian satisfies some properties, you know that the equation has a solution.
16:00:07 <quchen> There's of course a whole lot of other problems coming from this - such as whether the ground state can be reached in finite time and everything.
16:00:14 <elliott> quchen: err, surely the argument is more than "you can do IO but a UTM can't"?
16:00:29 <elliott> anyway, this is off-topic
16:00:46 <cmccann> anyway, isn't it pretty well established that if there are any physical processes that would enable computation beyond what a turing machine does, we don't know of them?
16:00:47 <quchen> I said it was an "interesting talk", not a lecture ;-)
16:01:09 <cmccann> and yeah this is off topic
16:01:13 * cmccann goes back to programming
16:07:56 <xenocons> is there an elegant user arg parsing (like stdin) monad i can leech
16:08:56 <xenocons> seems putStrLn "enter something: "; name <- getLine is really awkward
16:09:17 <xenocons> especially when you have many user argument requirements
16:09:29 <xenocons> or am i overengineering this
16:09:54 <shachaf> You can write one function, ask :: String -> IO String
16:10:12 <shachaf> (Don't call it ask, actually.)
16:10:26 <xenocons> ah that is my current idea, and have a list of strings to print to the user
16:10:33 <popl> donttell
16:11:11 <xenocons> :t donttell
16:11:12 <lambdabot> Not in scope: `donttell'
16:11:15 <xenocons> ;p
16:11:47 <xenocons> mapping the strings into a function that prints the request then returns the input from user
16:12:01 <xenocons> still seems awkward
16:12:02 <cmccann> xenocons, if you want more elaborate user interaction with the running program you could try haskeline or something
16:12:12 <cmccann> but that doesn't really help with your immediate question
16:12:28 <xenocons> still, its a good point
16:12:41 <shachaf> What is?
16:12:42 <xenocons> looks interesting
16:13:00 <ParahSail1n> solves my problem
16:13:00 <xenocons> the point that looking at someones prexisting library to tackle this problem =p
16:13:08 <ParahSail1n> i needed to manually hFlush a buffer
16:13:33 <Chahurga> I'm confused, how much simpler could you make it?
16:13:34 <ParahSail1n> that seems like something ghc should do for me...
16:14:16 <cmccann> ParahSail1n, did you encounter the good old "buffering is different in GHCi vs. a compiled program" trap?
16:14:22 <Cale> ParahSail1n: You can use hSetBuffering to decide how a Handle is buffered
16:14:56 <acowley> I'm with Chahurga on this
16:15:11 <acowley> :t mapM ((>> getLine) . putStrLn)
16:15:11 <ParahSail1n> cmccann: no, i didnt try this at all in ghci
16:15:12 <lambdabot> [String] -> IO [String]
16:15:33 <ParahSail1n> i just assumed that buffers would be flushed automatically in a high level language
16:15:43 <Cale> ParahSail1n: They will, eventually.
16:16:01 <cmccann> the basic IO stuff in Haskell is more like what you'd find in a lower level language really
16:16:03 <Cale> The whole point of a buffer is not to flush it as frequently as possible though.
16:16:08 <cmccann> think of it as C, not python
16:16:17 <shachaf> Especially getContents.
16:16:43 * cmccann ignores the existence of lazy IO
16:17:40 * hackagebot alpha 1.0.9 - A compiler for the Alpha language  http://hackage.haskell.org/package/alpha-1.0.9 (MarcCoiffier)
16:18:43 <ParahSail1n> Cale: is it too much to expect it to be flushed on normal termination of the program?
16:18:59 <shachaf> ParahSail1n: No.
16:19:32 <ParahSail1n> maybe having 385 open file descriptors messed with ghc rts's ability to flush all the buffers
16:19:50 <cmccann> maybe you should open more files. surely that will help.
16:22:28 <ParahSail1n> cmccann: i need to take one file and divide it line by line between 385 different files based on the content of each line, you got a more clever way?
16:23:47 <acowley> ParahSail1n: How big is the original file?
16:23:50 <cmccann> 'fraid not, but seems like there should be some better way...
16:24:02 <ParahSail1n> acowley: hundreds of GB
16:24:30 <tromp> divide 20-way first, and then process those output files with another ~20 way split
16:24:39 <acowley> Is the file allocation per line uniformly distributed, or is it chunky?
16:24:52 <ParahSail1n> acowley: "random"
16:24:58 <cmccann> fun
16:25:13 <acowley> ParahSail1n: Get new data, yours stinks
16:25:19 <cmccann> good plan
16:25:26 <ParahSail1n> tell that to illumina
16:25:47 <tromp> or fill 385 big buffers, and only open file for appending when a buffer fills
16:25:54 <cmccann> how to solve any problem: do the easy thing. if that doesn't work, find an easier problem
16:26:26 <acowley> ParahSail1n: Seriously, though, I'd just append lines to the right file as I go through the original file. Never keeping a handle open. If there's any lack of total randomness, you can LRU cache the last n file handles.
16:26:39 <ParahSail1n> it works pretty well with 385 handles, good performance, i just need to remember to flush buffer as if im in a low level language
16:27:11 <ParahSail1n> flush buffer at the end i mean
16:30:37 <cmccann> quick and dirty text mangling isn't really the place haskell shines most, I will agree :P
16:33:38 <ParahSail1n> acowley: lru buffer would be cool functionality to write if i need to open more than the max fd's
16:38:51 <haltok> small HXT question: i have an arrow, which "extracts links from html page" >>> "for each link extracts data" >>> "run some IO-action". Is it possible to make action run immediately, not after all links data are collect in a list?
16:47:57 <dremok> I have problems understanding how the list works as a Monad, or in particular the do notation. Could anyone explain why the following function returns a [[char]] with "world" repeated 5 times: do ”hello”; return ”world”
16:48:25 <Heffalump> are you familiar with the Monad type class?
16:48:48 <glguy> > concatMap (\_ -> ['w','o','r','l','d']) ['h','e','l','l','o']
16:48:49 <lambdabot>   "worldworldworldworldworld"
16:49:11 <Botje> @undo do { "hello"; return "world" }
16:49:11 <lambdabot> "hello" >> return "world"
16:49:18 <Botje> dremok: ^ ^ this is your first clue.
16:49:26 <ion> dremok: For each element in "hello", append ["world"] to the resulting list.
16:49:37 <dremok> Heffalump: Yes, I think so. I know that the do notation is translated like this: "hello" >> return "world"
16:49:39 <michaeltbaker> Hello, I have a question about hGetContents. I wrote two programs that read and write to the same file at the same time: https://gist.github.com/4273086 But when I run them, the reader always writes the contents of the original file and not the new contents written by the writer. Is it just that my file isn't long enough or how does hGetContents lazily read the original contents while a different process is changing them?
16:50:00 <ion> > do c <- "hello"; return (c, "world")
16:50:02 <lambdabot>   [('h',"world"),('e',"world"),('l',"world"),('l',"world"),('o',"world")]
16:50:26 <glguy> michaeltbaker: hGetContents is definitely lazy. That can affect things
16:51:02 <ion> michaeltbaker: “Two programs that read and write to the same file at the same time”, a.k.a. a race condition.
16:51:32 <ion> michaeltbaker: loopFor is also known as replicateM
16:51:39 <kfish> haltok: is the link extraction lazy, and can you mapM the IO action in the last step?
16:51:43 <ion> michaeltbaker: Well, replicateM_
16:52:19 <Heffalump> dremok: probably the best way to understand it is to step through the definition of >> and return for [] with your translation
16:52:53 <ion> michaeltbaker: Better use “bracket” to close things in the end, btw.
16:53:22 <michaeltbaker> I know, the point is that there's a race condition. I would expect the writer to race ahead of the reader. Then, because the reader is lazy, I would expect it to read the new contents of the file. But instead it reads the original contents, as if the writer had never run.
16:53:53 <glguy> ion: or in this case, withFile ?
16:54:04 <ion> glguy: That, too. :-)
16:54:36 <ion> michaeltbaker: Then start the reader later.
16:55:56 <michaeltbaker> I expect to see it read part of the initial contents of the file, and then after the writer races ahead, it reads what the writer wrote. I don't understand why I don't see this behaviour.
16:56:21 <dremok> so, I understand that > do ”hello”; return ”world” translates to "hello" >> return "world"
16:56:37 <dremok> but why is this translated to > do c <- "hello"; return (c, "world")?
16:57:05 <michaeltbaker> This isn't a problem I'm trying to solve. I'm doing an experiment to see how hGetContent's lazy reading behaves.
16:57:23 <michaeltbaker> And its behavior is unexpected.
16:57:46 <dremok> I thought that >> just ignores the first parameter
16:57:59 <shachaf> No, it ignores the result of the first parameter.
16:58:01 <ion> michaeltbaker: openFile "foo" WriteMode probably results in a completely new file on your system. In that case, it would be unexpected for the reader to see some of the old file and some of the new file.
16:58:44 <shachaf> "hello" >> return "world" === "hello" >>= (\_ -> return "world") === concat (map (\_ -> ["world"]) "hello")
16:58:55 <shachaf> > map (\_ -> "world") "hi"
16:58:57 <lambdabot>   ["world","world"]
16:59:05 <michaeltbaker> ion: Ah, that would make sense. So you think writemode doesn't actually truncate the old file, it only creates a new one. Then append mode should give me what I want.
16:59:32 <ion> michaeltbaker: AppendMode or ReadWriteMode should modify the preexisting file, yeah.
16:59:43 <michaeltbaker> Cool, let me try that
16:59:54 <dremok> shachaf++
17:01:10 <michaeltbaker> Hrm, same result
17:08:26 <pid> haskell real time OS, how is that even possible?
17:08:39 <haltok> kfish: thanks for direction, I've verified with simplified example: hxt-lists are lazy, problem in my code
17:17:42 * hackagebot containers 0.5.2.0 - Assorted concrete container types  http://hackage.haskell.org/package/containers-0.5.2.0 (JohanTibell)
17:23:49 <orzo> I have a situation where i'm tempted to use a Maybe enum, but I think it's likely more effiicent to use a new enum that has all the values of the old plus one for nothing.  That seems like an optimization the compiler can always do though, so the question is, does it?
17:24:32 <c_wraith> That isn't an optimization GHC will do in any case I can think of
17:24:36 <shachaf> As far as I understand your question, no.
17:24:40 <shachaf> But you probably shouldn't worry about it.
17:25:26 <glguy> orzo: if it did that GHC would then have to construct a new representation once you pattern matched the Just
17:25:43 <startling> orzo, don't worry about it
17:26:20 <orzo> you say that, but i pretty much know this is very critical code that will be run a million times
17:26:46 <glguy> What happened when you profiled it?
17:26:52 <orzo> i havent yet
17:27:03 <popl> well do it then worry about optimizing it :P
17:27:15 <popl> otherwise it's just hand-wringing
17:27:27 <orzo> well i have a version that has a Bool
17:27:38 <popl> Did you profile that?
17:27:41 <orzo> yes
17:27:46 <orzo> that does veyr well
17:27:52 <orzo> but ive decided to add more cases to the bool
17:28:02 <acowley> Truish
17:28:28 <startling> ah, you're a constructivist
17:28:47 <orzo> well, specifically, i'm truning a Bool into a (Maybe Ordering) which is how i conceived of it, but while discussing it with a codeveloper, he got me thinking maybe it should be a combined MaybeOrdering enum instead
17:28:54 <c_wraith> hmm.  I wonder if anyone has formalized obstructionist logic
17:29:04 <popl> c_wraith: Republicans?
17:29:13 <c_wraith> formalized? I doubt it
17:29:49 <acowley> fillibuster |- False
17:29:56 <shachaf> orzo: It's probably not a big change to start with Maybe Ordering and switch it over later.
17:30:26 <shachaf> It's the sort of thing the type system would help you do, certainly.
17:30:26 <orzo> alright
17:30:41 <shachaf> It might be that MaybeOrdering is better, or that some other thing is better..
17:32:49 <orzo> not much point in starting with Maybe Ordering either though
17:33:01 <orzo> cept saves a type declaration i guess
17:33:20 <c_wraith> and it lets you use all the existing tools for dealing with Maybe and Ordering
17:33:27 <c_wraith> which may be of some use
17:34:01 <orzo> that reminds me of another common dilema i hit
17:34:38 <orzo> i like to be able to use the existing tools for Bool, but using Bool over a 2-value enum cauess ugly undocumenting True and Falses
17:35:03 <orzo> maybe Bool should be a class of two-value enum types
17:35:45 <fengshaun> orzo, I joined in late, what's the problem?
17:36:01 <c_wraith> huh.  And Bool is one of the types I think has the least-useful existing tools
17:36:09 <simpson> :t ala
17:36:11 <orzo> not
17:36:11 <lambdabot> Wrapped s s a a => (s -> a) -> ((s -> a) -> e -> a) -> e -> s
17:36:15 <orzo> Bool has not
17:36:16 <orzo> and such
17:36:19 <simpson> Oh, right, lens.
17:36:28 <shachaf> simpson: It works just like the newtype one.
17:36:38 <shachaf> > ala Sum foldMap [1,2,3,4]
17:36:40 <lambdabot>   10
17:36:50 <orzo> not is something that would be usable on any two-value enum an dits a nice documenting word
17:36:53 <orzo> heh
17:37:07 <simpson> > ala Product foldMap [1..5]
17:37:08 <lambdabot>   120
17:37:11 <simpson> Nifty.
17:38:40 <orzo> maybe it'd be nice to simply alias True and False with equivelent constructors that can be used in pattern matching and so on
17:39:09 <orzo> constructor alias extension?
17:39:11 <orzo> heh
17:39:24 <Jesin> orzo: um... what's the problem with just typing True or False
17:39:29 <simpson> orzo: Distinct types are nice, if you actually want them to be distinct.
17:39:32 <simpson> Otherwise, just use Bool.
17:39:42 <orzo> i said whatthe issue is
17:39:50 <Jesin> "ugly undocumenting"?
17:39:52 <simpson> Well, what's an example type that you're defining on your own?
17:40:04 <orzo> yeah, if i pass True to a function, it isn't clear wtf that means
17:40:18 <simpson> Document your functions?
17:40:29 <orzo> self-documenting code is superior if possible
17:40:31 <orzo> do you disagree?
17:40:36 <orzo> whatever
17:40:44 <orzo> i was just throwing out some thoughts
17:40:55 <Jesin> well
17:41:08 <orzo> i dont want to get into a religious war over it
17:41:10 <orzo> sheesh
17:41:15 <Jesin> maybe your function should have a clearer name or documentation, idk
17:41:16 <Jesin> um
17:41:41 <Jesin> incidentally, I have a math question and I'm not getting any answers in ##math...  =/
17:41:41 <simpson> orzo: I agree that self-documenting code is superior! But Haskell does not make keyword arguments easy.
17:42:24 <jlamothe> Anybody ever wored with the Haskell SDL wrapper?
17:42:27 <Jesin> I don't suppose anyone here knows what assumptions are necessary to prove that the Axiom of Choice does not contradict ZF set theory?
17:44:01 <orzo> probalby just compare classical set theory and look at the restrictions placed on the definition of set for zmf
17:44:48 <orzo> i worked with the SDL wrapper a very long time ago and am probalbly useless for whatever issue you have
17:45:03 <orzo> heh
17:45:06 <c_wraith> same here, as far as probably-useless SDL experience
17:46:15 <jlamothe> It's probably more experience than I have.
17:46:52 <startling> Jesin: can't you just choose an arbitrary assumption from the set of those necessary and start there?
17:47:09 <startling> >.>
17:47:49 <ivanm> why doesn't ghci like this? data Foo m a = ... ; instance (Monad m) => Bar (Foo m) where ...
17:47:57 <ivanm> it says it's expecting another argument for m :s
17:48:26 <ivanm> does 7.6.1 default kinds to * or something?
17:49:01 <c_wraith> ivanm: it does if you enable DataKinds, I think
17:49:15 <ivanm> hmmmmm
17:49:35 <c_wraith> ivanm: I know there are cases where DataKinds requires you to use kind signatures that you wouldn't need otherwise
17:49:37 <ivanm> nope, that doesn't do it
17:49:40 <c_wraith> or maybe it's PolyKinds?
17:49:48 <ivanm> the only thing I've found is to add an explicit kind signature to the data definition
17:49:51 <ivanm> which is rather fugly IMHO
17:50:02 <ivanm> OK, PolyKinds works
17:50:16 <c_wraith> Ok, it's PolyKinds, not DataKinds
17:51:07 <ivanm> which is nicer to the eye than providing a specific kind signature in the data type, so I'll take it :p
17:58:20 <koala_man> I have a finite list of elements in a monoid. how can I mconcat it in parallel?
18:04:45 <eikke> tibbe: remember our chat @ ICFP? FWIW, https://github.com/NicolasT/Paxos/ (obviously WiP etc etc)
18:05:20 <tibbe> eikke: I do remember
18:05:22 <tibbe> eikke: nice
18:05:33 <tibbe> eikke: a bit snowed under at the moment fighting fires
18:06:12 <eikke> np ;) not that much to see yet anyway :) thing can reacht consensus on a single value, making it handle sequences of values (transitions) will take a little more work
18:06:48 <eikke> then comes doing a true multi-Paxos implementation, and more testing (now only some quickcheck propoperties are in place, and a very dumb full-cycle example)
18:09:01 <eikke> off to bed, 03:08 is a nice time for sleep :)
18:40:14 <dmwit> What the heck is bin-package-db?
18:40:29 <dmwit> It's not on Hackage, and it's conflicting with a "binary >= 0.6" constraint.
18:42:09 <monadicity> can adjunctions be used in haskell?
18:43:10 <dmwit> monadicity:
18:43:13 <dmwit> ?hackage adjunctions
18:43:13 <lambdabot> http://hackage.haskell.org/package/adjunctions
18:43:40 <Saizan> dmwit: seems to be something used by ghc-pkg to store the package db
18:44:07 <johnw> monadicity: there are some adjunctions you can't represent in Haskell, like Mon ⊣ Set
18:44:19 <parcs`> it's the binary instances for cabal's package data types
18:44:28 <johnw> but others, like Prod ⊣ Hom work out quite nicely
18:44:39 <monadicity> why can't you represent it?
18:45:08 <johnw> i guess you could if you built a non-monoidal List type
18:45:28 <Saizan> why would you need that?
18:45:37 <johnw> to strip the Mon properties from []?
18:46:05 <johnw> i haven't yet actually tried and failed on that one, so ymmv
18:46:14 <Saizan> you don't have to strip in that sense
18:47:23 <dmwit> Saizan, parcs`: Hm. I'm a bit confused. But I think what's happening here is this Build-Depends: ghc >= 6.10 ought to be something like if impl(ghc < 6.10): fail or something like that.
18:47:59 <dmwit> I'm going to see what happens if I just remove that claimed build dependency entirely.
18:49:47 <Saizan> johnw: it's perfectly fine to use the fact that [a] is a monoid when writing arrows in Set
18:51:54 <monadicity> Functor f, Functor g => Adjunction f g where bijection :: f a -> b and inverse :: a -> g b
18:52:06 <monadicity> roughly
18:53:05 <Saizan> not really?
18:54:42 <Nereid> no.
18:54:42 <Nereid> monadicity: an isomorphism (f a -> b) <-> (a -> g b)
18:55:03 <monadicity> oh right!
18:55:47 <vermeille> Hello all
18:56:09 <johnw> Saizan: so in Mon ⊣ Set, FG ends up being [[]]?
18:56:17 <crdueck> jlamothe: i've used haskell-sdl recently, but I cant promise I have an answer either...
18:56:21 <Nereid> johnw: the main issue is that we don't have a type for "monoid homomorphisms"
18:56:35 <Saizan> johnw: nope
18:56:37 <Nereid> johnw: no, F is [] and G is identity
18:57:01 <johnw> ah
18:57:18 <byorgey> hi vermeille
18:57:21 <Nereid> G "forgets the monoid structure", but there's nothing to do to forget it in haskell
18:57:27 <johnw> ok
18:57:29 <johnw> that makes some sense
18:57:40 <johnw> it forgot it was a forgetful functor
18:57:47 <monadicity> hehe
18:57:51 <Nereid> and it's two functors that are adjoint, not two categories.
18:57:53 <Nereid> F ⊣ G
18:58:13 <Saizan> right, that too
18:58:43 <johnw> oh yeah
18:59:02 <monadicity> instance Adjunction [] Identity where bijection (f :: f a -> b) = return (f (return a)) would it be?
18:59:34 <donri> dmwit: you can use buildable:False for "fail"
19:00:19 <Nereid> so to write the adjunction in haskell: write functions f :: Monoid b => ([a] -> b) -> (a -> b) and g :: Monoid b => (a -> b) -> ([a] -> b), such that the image of g consists of monoid homomorphisms, f.g = id, and g.f = id when restricted to monoid homomorphisms.
19:00:48 <vermeille1> Hum. Back.
19:01:34 <vermeille1> So, I'm currently a student, I love programming and Haskell seems to be very sexy. BUT, is matering Haskell a good point for my career ?
19:01:43 <vermeille1> Is Haskell considered in the industry ?
19:01:52 <vermeille1> mastering*
19:02:35 <vermeille1> (If we can avoid troll, it's better)
19:02:38 <byorgey> vermeille1: yes.
19:02:53 <Saizan> @quote abstract.research
19:02:53 <lambdabot> Jafet says: Haskell is an abstract research language used only in academia, education, banking, stock trading, circuit design, embedded systems, cryptography, operating systems research, bioinformatic
19:02:54 <lambdabot> s, phone apps, and web services.
19:03:16 <byorgey> vermeille1: it's used in many places in industry, and even in places where it isn't used it will still look impressive on your CV.
19:03:33 <Nereid> most places domn
19:03:39 <Nereid> most places don't use it though.
19:03:50 <johnw> the only reason not to use it is that you might then not want to ever take a Java/Python/C#/C job
19:03:51 <vermeille1> Okay, in the list of programs written in Haskell I only know xMonad (awesome wm)
19:04:03 <Nereid> haha johnw.
19:04:17 <davesque_> in set theory, if S = {1, 2} and T = {3, 4}, which is true: S x T == {(1, 3), (2, 4)} or S x T == {(1, 3), (1, 4), (2, 3), (2, 4)}?
19:04:20 <lucca> Any language that helps you think about problems in a different way is worth studying.
19:04:26 <Nereid> davesque_: the latter.
19:04:28 <byorgey> davesque_: the second.
19:04:34 <vermeille1> Haha
19:04:37 <Nereid> you take all pairs formed from S and T.
19:04:40 <byorgey> davesque_: the first can't possibly be true because sets don't have any order.
19:04:45 <Nereid> the first wouldn't make sense in general because ^
19:04:54 <davesque_> okay, cool
19:04:54 <Nereid> and the sets may have different cardinalities.
19:05:01 <vermeille1> I'm learning seriously Haskell for few weeks
19:05:16 <Nereid> learning haskell is a good experience.
19:05:17 <dmwit> donri: Thanks.
19:05:28 <fayden> What about Haskell for high end performance (game server, web site a la facebook)? It seems hard to write performant code, and it seems we lose a lot of elegance
19:05:31 <Tehnix> have a question
19:05:32 <mrxy> sortBy (comparing length) ["xxx", "x", "xx"]
19:05:39 <mrxy> > sortBy (comparing length) ["xxx", "x", "xx"]
19:05:40 <lambdabot>   ["x","xx","xxx"]
19:06:04 <mrxy> how would I sort them by length from largest to smallest?  should I just reverse the result?
19:06:05 <vermeille1> lucca: I was thinking about "Maybe monad" while using boost::optional in C++ \o/
19:06:43 <Tehnix> if one was to strive for being able to be able to contribute to the GHC development, what would you recommend as a learning path towards such a thing? (I realize it's a very general question)
19:06:56 <Saizan> > sortBy (flip compare `on` length) ["xxx", "x", "xx"]
19:06:57 <lambdabot>   ["xxx","xx","x"]
19:06:58 <vermeille1> fayden: I think that C++ is still the king of performance.
19:07:01 <Nereid> > sortBy (flip $ comparing length) ["xxx", "x", "xx"]
19:07:03 <dolio> Isn't Facebook written in PHP?
19:07:03 <lambdabot>   ["xxx","xx","x"]
19:07:11 <fayden> vermeille1: but it's unpleasant :p
19:07:13 <mrxy> nice thanks
19:07:27 <vermeille1> dolio: yes, but it's "translated" to C++ with Hip-Hop
19:07:33 <Nereid> why don't we have a function Ordering -> Ordering that swaps LT with GT?
19:07:37 <byorgey> Tehnix: read the GHC commentary on the GHC wiki; look at the GHC trac and try to find some simple tickets to work on; subscribe to the ghc-users mailing list; etc.
19:07:55 <dolio> Well, I can use JHC to translate Haskell into C.
19:07:58 <Tehnix> byorgey: kk :)
19:07:59 <dolio> Does that magically make it fast?
19:08:03 <mrxy> Nereid do we need it when flip does the job?
19:08:17 <Saizan> Tehnix: spj's book on implementing a lazy functional language should be a good background, even it's outdated in places
19:08:32 <Nereid> mrxy: does it always do the job?
19:08:33 <dolio> GHC can translate it into C as well.
19:08:33 <vermeille1> dolio: Hip Hop is now open source on GitHub, you can try it and check performances it brings
19:08:37 <Saizan> Tehnix: it also depends on which areas you are interested in
19:08:43 <fayden> I want to pick up a functional programming language, and I heard a lot of good things about OCaml. Haskell is very elegant and has a lot of interesting features, but I'm afraid it's hard to write performant yet elegant code
19:09:19 <mrxy> Nereid shouldn't it?  we are flipping the arguments, if X < Y is True then Y < X is False
19:09:21 <vermeille1> dolio: GHC 'to C' compiler mode doesn't exists anymore
19:09:29 <byorgey> fayden: yes, it's true
19:09:31 <Nereid> mrxy: what if you don't have access to the arguments?
19:09:31 <dolio> One of them does.
19:09:43 <Nereid> what if someone just hands me an Ordering?
19:10:11 <vermeille1> Next question : why the hell 30% of Cabal packages doesn't even compile >_< ?
19:10:20 <vermeille1> Why Gtk2hs is so painful to install ?
19:10:27 <mrxy> Nereid yeah I misunderstood you
19:10:32 <byorgey> rev GT = LT; rev LT = GT; rev EQ = EQ   -- there, now we have a function that swaps LT with GT!
19:10:38 <byorgey> glad I could help
19:10:44 <Nereid> I meant in the standard libraries.
19:10:57 <byorgey> ;-)
19:10:59 <Nereid> ;)
19:11:29 <Saizan> > map (flip compare EQ) [LT ..]
19:11:31 <lambdabot>   [LT,EQ,GT]
19:11:47 <Nereid> haha.
19:11:56 <latro`a> @ vermeille1, afaict gtk2hs is painful mainly because cabal can't do it by itself
19:11:57 <Tehnix> Saizan: the spj book, is it this one you're referring to? http://research.microsoft.com/en-us/um/people/simonpj/papers/pj-lester-book/
19:12:10 <Saizan> > map (compare EQ) [LT ..]
19:12:12 <lambdabot>   [GT,EQ,LT]
19:12:21 <byorgey> hah, nice
19:12:23 <Saizan> too clever for my own good :)
19:12:39 <Saizan> Tehnix: yeah
19:12:53 <Tehnix> Saizan: okay, thanks :)
19:13:06 <johnw> byorgey: what part did you play in writing Software Foundations?
19:13:12 <pnielsen> is there something like forM_ :: [a] -> (a -> Bool) -> IO () that will continue as long as the function evaluates to True?
19:13:24 <pnielsen> make that (a -> IO Bool)
19:13:39 <johnw> pnielsen: there's whileJust...
19:14:11 <hamishmack> vermeille1: Answer depends on OS.  On Windows and OS X installing Gtk is the main problem.
19:14:19 <vermeille1> What is the best (== not buggy && well documented) ncurses libraries for Haskell ?
19:14:26 <dgpratt> I found what I think is a bug in some Haskell code (not mine) on this line: path <- lookup "PATH" `fmap` getEnvironment
19:14:28 <Nereid> I thought there was a "while" somewhere?
19:14:30 <simpson> pnielsen: Why IO?
19:14:36 <vermeille1> Okay, I don't care about Windows.
19:14:42 <dgpratt> the problem is its doing a case-sensitive comparison
19:14:49 <byorgey> johnw: I did lots of editing and added many exercises etc. throughout.  The most substantial part I actually wrote is the chapter on references.
19:14:50 <pnielsen> simpson: or m Bool
19:15:04 <dgpratt> what's the most straightforward way to do a case-insensitive comparison here?
19:15:11 <johnw> byorgey: it's a fantastic resource, thank you for your work on it
19:15:20 <johnw> i'm finishing chap 5 now
19:15:21 <byorgey> you're welcome!
19:15:25 <byorgey> cool
19:15:25 <pnielsen> johnw: perfect, thanks
19:15:29 <hamishmack> vermeille1: Here is Gtk2Hs installing on linux… https://travis-ci.org/leksah/ltk
19:15:43 <Saizan> dgpratt: find ((=="PATH").map toUpper), i guess
19:15:45 <pnielsen> johnw: Control.Monad.Loops is exactly what I was looking for :)
19:16:06 <Saizan> dgpratt: add a fst in there
19:16:06 <dgpratt> Saizan: thanks
19:16:17 <dgpratt> Saizan: ok
19:16:18 <hamishmack> vermeille1: Here are the steps it uses… https://github.com/leksah/ltk/blob/master/.travis.yml
19:16:22 <latermuse> > Hey is there a way to reverse the first and last elements of a list with less code than this?
19:16:23 <lambdabot>   <hint>:1:59: parse error on input `of'
19:16:38 <latermuse> > let meow = [1..10] in last meow : (tail $ init meow) ++ [head meow]
19:16:40 <lambdabot>   [10,2,3,4,5,6,7,8,9,1]
19:17:03 <byorgey> aaaand... cue crazy lens combinators in 5... 4... 3... 2...
19:17:12 <Nereid> that looks like the most reasonable way to do it, although it'll fail when the list has length < 2
19:17:17 <Nereid> well, most direct
19:17:34 <vermeille1> Thanks hamishmack !
19:17:39 <byorgey> latermuse: it's sort of a strange operation to do on lists
19:18:00 <latro`a> ...
19:18:08 <hamishmack> vermeille1: Here is how I install on OS X … https://github.com/leksah/leksah/blob/master/osx/gtk.sh
19:18:17 <statusfailed> does eitherToMaybe :: Either a b -> Maybe b exist anywhere in base?
19:18:19 <hpaste> latro`a pasted “whileM' shadowing” at http://hpaste.org/79144
19:18:20 <byorgey> hence one wouldn't expect a really short, elegant way to do it
19:18:25 <latermuse> > let meow = [1..10] in permutations meow !! 408240
19:18:27 <lambdabot>   [10,2,3,4,5,6,7,8,9,1]
19:18:27 <Nereid> there should be a way of doing it while only going through it once, though.
19:18:27 <latro`a> is there any particular reason why this does shadowing?
19:18:31 <johnw> statusfailed: see the "errors" library
19:18:36 <latro`a> seems unnecessarily confusing for it to do so :/
19:18:37 <byorgey> latermuse: hahaha
19:18:39 <johnw> statusfailed: it has Maybe -> Either and Either -> Maybe
19:18:43 <latermuse> :D
19:18:48 <byorgey> latermuse++
19:18:50 <statusfailed> johnw: cheers
19:19:05 <statusfailed> Feels bad pulling in a whole library just for that tho :\
19:19:06 <latro`a> it also has wonderful names for both
19:19:07 <latro`a> note and hush
19:19:10 <latro`a> eh, you don't
19:19:13 <latro`a> Control.Error.Util
19:19:16 <latro`a> is a tiny module
19:19:21 <johnw> pull it in so more people have it already installed :)
19:19:37 <latro`a> *don't have to
19:19:51 <statusfailed> haha, I like the naming
19:20:16 <latro`a> makes less sense if you're not using Either String-ish
19:20:28 <latro`a> but it's brilliant in that (very common) case :)
19:20:28 <vermeille1> What is the best ncurses libraries ? (I mean, without bugs and well documented)
19:21:18 <Saizan> is there more than one?
19:21:25 <vermeille1> Sadly yes
19:21:39 <Saizan> go for the most recently updated
19:21:41 <Clint> use vty instead
19:24:09 <statusfailed> I just discovered mfilter and now my code is littered with it har har
19:25:34 <beaky> hello
19:25:40 <beaky> does haskell have a stakc structure?
19:26:11 <roconnor> @quote stack
19:26:12 <lambdabot> <mc__> says: infinity <lambdabot>   * Exception: stack overflow
19:26:17 <roconnor> @quote stack-calculator
19:26:18 <lambdabot> stack-calculator says: let start f = f (); push s a f = f (a,s); add (a,(b,s)) f = f (a+b,s); end (a,_) = a in start push 2 push 3 add end
19:26:34 <johnw> statusfailed: nice
19:26:56 <hpaste> Nereid pasted “Swap head and tail” at http://hpaste.org/79145
19:26:57 <roconnor> beaky: a list works as a homogenous stack.
19:27:00 <beaky> ah
19:27:18 <vermeille1> Hum, what is the best random access structure, since arrays have performance issues ?
19:27:19 <Nereid> latermuse: ^
19:27:36 <statusfailed> johnw: I was writing error handling for the 3rd time, and I thought "I bet this generalises to MonadPlus -> I bet it exists already -> I bet it's called something like "filter""
19:27:40 <beaky> I think Data.Sequence works fine for random access
19:27:40 <Nereid> vermeille1: vector seems popular.
19:27:44 <Nereid> or sequence.
19:27:59 <johnw> what's a simple example of how you've used it?
19:28:03 <beaky> aren't Vectors just glorified Arrays?
19:28:13 <Nereid> I dunno.
19:28:16 <vermeille1> thanks !
19:28:27 <johnw> real Vectors don't grow, do they?
19:28:31 <beaky> oh
19:28:42 <statusfailed> johnw: So I want to write a function Text -> Maybe Int
19:28:43 <Nereid> right, you can grow vectors.
19:28:55 <statusfailed> if there's any input left over in the Text I want to fail (Nothing)
19:28:56 <johnw> so, Array = no grow, Vector = grow?
19:29:03 <shachaf> johnw: No.
19:29:09 <shachaf> Er.
19:29:14 <shachaf> Maybe I'm just missing context.
19:29:25 <vermeille1> And last question :D How do you debug your code ? none of solutions that I tried seemed convenient
19:29:33 <statusfailed> johnw: wait; am I answering question for someone elsee?
19:29:34 <johnw> shachaf: how would you characterize the difference between vectors and arrays?
19:29:43 <shachaf> In what context?
19:29:44 <johnw> statusfailed: you're answering my question
19:29:51 <statusfailed> johnw: ok :P
19:29:51 <johnw> shachaf: i suppose that might be the right answer
19:29:59 <statusfailed> johnw: here's the function: readNum = fmap fst . mfilter (T.null . snd) . hush . decimal
19:30:09 <statusfailed> (decimal is from Data.Text.Read)
19:30:20 <statusfailed> Data.Text is imported as T
19:30:26 <Nereid> oh I guess line 7 is unnecessary
19:30:30 <shachaf> johnw: The answer in C++ and in Haskell would be very different, for example.
19:30:39 <Nereid> oh wait it definitely is necessary.
19:30:46 <johnw> so, mfilter is a cool way to "filter" a Just so that it only stays a Just if the filter matches, that's clever, and I see the parallel with lists now
19:30:48 <shachaf> And in linear algebra.
19:30:58 <Nereid> :t mfilter
19:30:59 <lambdabot> MonadPlus m => (a -> Bool) -> m a -> m a
19:31:02 <pnielsen> johnw: had to try: http://hpaste.org/79146
19:31:09 <statusfailed> johnw: generalised to MonadPlus
19:31:09 <johnw> > mfilter odd (Just 9)
19:31:10 <lambdabot>   Just 9
19:31:14 <johnw> > mfilter odd (Just 10)
19:31:15 <lambdabot>   Nothing
19:31:19 <pnielsen> only in haskell
19:31:30 <Nereid> @src mfilter
19:31:31 <lambdabot> Source not found. It can only be attributed to human error.
19:31:36 <shachaf> I've never heard of mfilter.
19:31:39 <shachaf> Bizarre.
19:32:13 <shachaf> Hmm, I'm not sure I like it.
19:32:18 <statusfailed> aw :(
19:32:20 <johnw> pnielsen: I think maybe you want takeWhileM
19:32:21 <statusfailed> why not?
19:32:23 <johnw> :t takeWhileM
19:32:24 <simpson> > mfilter odd [1..10]
19:32:24 <shachaf> mfilter p ma = do { a <- ma; if p a then return a else mzero }
19:32:24 <lambdabot>     Not in scope: `takeWhileM'
19:32:24 <lambdabot>     Perhaps you meant one of these:
19:32:24 <lambdabot>       `takeWhile' (imported from Data.List),
19:32:25 <lambdabot>   [1,3,5,7,9]
19:32:31 <johnw> it's in the monadlist package
19:32:58 <pnielsen> cool, cheers
19:33:05 <statusfailed> shachaf: What's your objection?
19:34:50 <Nereid> I guess the ~ wasn't necessary.
19:34:51 <jmcarthur> edwardk's talk completely swayed me over to lens
19:35:01 <Nereid> has it been posted online?
19:35:20 <jmcarthur> no, i just got back from it
19:35:22 <Nereid> ah
19:35:29 <elliott> so the mind control worked
19:35:34 <Nereid> but it will be, right? :p
19:35:37 <shachaf> jmcarthur: What was your position before?
19:36:09 <jmcarthur> it looked neat, but from where i was standing it looked unprincipled in the name of "pragmatics"
19:36:24 <jmcarthur> e.g. everybody keeps saying the composition works backward from how haskellers expect, but this just isn't true
19:36:37 <statusfailed> do they?
19:36:38 <shachaf> jmcarthur: It works backwards if you think about composing getter functions.
19:36:46 <jmcarthur> even edwardk says it
19:36:48 <shachaf> But lenses are really fancy setter functions.
19:37:07 <jmcarthur> yeah it doesn't work backward to me. it transforms the function you are applying it to in just the way it normally would
19:37:08 <johnw> maybe shachaf wouldn't object if it were lfilter
19:37:09 <elliott> jmcarthur: most people seem to say lens is overprincipled at the expense of pragmatics!
19:37:09 <shachaf> mapList (mapBoth (+1)) [(1,2),(3,4)] isn't unintuitive to a Haskeller.
19:37:21 <statusfailed> I've only thought about them in terms of a hierarchy of properties, or as the magic functor type
19:37:26 <shachaf> statusfailed: No objection. Ignore me.
19:37:32 <statusfailed> (which is totally mad cool... )
19:37:37 <statusfailed> haha ok :p
19:37:44 <Clint> MagicFunctor
19:37:48 <Nereid> > over (traverse.both) (+1) [(1,2),(3,4)]
19:37:50 <lambdabot>   [(2,3),(4,5)]
19:38:00 <shachaf> I think IndexedFoo is a good example of lens selling out in the name of pragmatics.
19:38:01 <statusfailed> Clint: you gotta admit the Lens type looks like magic at first :P
19:38:06 * Clint nods.
19:38:12 <shachaf> statusfailed: Does mapM look magic?
19:38:12 <jmcarthur> i still dislike some of the operators, like (&). i see little reason to apply things backward that way
19:38:14 <shachaf> @ty mapM
19:38:16 <lambdabot> Monad m => (a -> m b) -> [a] -> m [b]
19:38:22 <statusfailed> shachaf: not anymore... but it definitely used to :)
19:38:23 <Nereid> I like &
19:38:42 <statusfailed> @ty (&)
19:38:44 <lambdabot> a -> (a -> b) -> b
19:38:55 <statusfailed> ... heh
19:39:11 <elliott> jmcarthur: well, the idea is that it looks like State
19:39:21 <jmcarthur> one thing i thought of on the way home... he presented lens by starting with fmap.fmap.fmap, traverse.traverse.traverse, foldMap.foldMap.foldMap, and generalizing them. what about "multiargument" things, like liftA2.liftA2.liftA2?
19:39:35 <elliott> cf http://hackage.haskell.org/packages/archive/lens/3.7.0.2/doc/html/Control-Lens-Getter.html#v:-38-
19:40:10 <elliott> also when using the zipper stuff
19:40:25 <shachaf> I'm ambivalent about &
19:40:42 <jmcarthur> at least i have a choice whether to use things i don't like
19:40:59 <johnw> ambivalent, or just indifferent?
19:41:04 <jmcarthur> since it's not like there's some type abstraction preventing me from just doing whatever i want
19:41:06 <shachaf> Ambivalent.
19:41:22 <beaky> how do i write a stack class in haskell
19:41:58 <Clint> with lenses, obviously
19:42:10 <Nereid> forget lenses, prisms are the new cool thing
19:42:12 <jmcarthur> beaky: by class do you mean type class?
19:42:16 <beaky> yes
19:42:23 <statusfailed> Nereid: is that actually a thing?
19:42:29 <Nereid> yes, as of lens-3.7
19:42:30 <Clint> he spent like 30 seconds talking about prisms
19:42:34 <statusfailed> wat.
19:42:34 <jmcarthur> beaky: since a type class is just an interface, all you have to do is define the interface...
19:42:44 <shachaf> Did edwardk talk about prisms?
19:42:45 <jmcarthur> yeah he barely covered prisms
19:42:47 <Clint> for about 30 seconds
19:42:48 <statusfailed> dammit! edwardk writes code faster than I can learn how to use it!
19:42:52 <Nereid> lol
19:42:58 <jmcarthur> he just said they were dual to lenses and why
19:43:59 <statusfailed> I think he's like Christian Bale in The Prestige- he actually has a twin, and they live in different time zones so they can work constantly
19:44:18 <fayden> statusfailed: I hope nobody minds about spoilers!
19:44:27 <statusfailed> shiiiit.
19:44:30 <Nereid> lol
19:44:40 <statusfailed> my bad D:
19:44:52 <beaky> how do i do it?
19:45:07 <johnw> beaky: write a stack type?
19:45:08 <shachaf> edwardk's secret is viewers like you: http://twitter.com/kmett/status/277899329015001088
19:45:10 <statusfailed> beaky: I don't think you want a type class
19:45:17 <beaky> ah
19:45:35 <Saizan> beaky: something like class Stack s where empty :: s a; push :: a -> s a -> s a; pop :: s a -> (a,s a)
19:45:45 <statusfailed> shachaf: haha :D
19:45:49 <beaky> ah
19:45:55 <Jafet> This means that if you kill edwardk, his productivity only goes down by half.
19:45:56 <beaky> that works!
19:47:13 <latro`a> hm, I can't tell, are there instances of that typeclass that are not isomorphic to List?
19:47:55 <Saizan> as i wrote it it's quite dodgy
19:48:02 <Saizan> because what is pop empty?
19:48:16 <johnw> it's a can
19:48:39 <latro`a> it does seem like you need some kind of restriction
19:48:44 <latro`a> to make pop empty make sense
19:48:56 <latro`a> (for example class Null a where null :: a, ignoring name collisions)
19:49:05 <johnw> pop empty is just like head []
19:49:11 <Saizan> i guess you could use uncons rather than pop
19:49:19 <johnw> so you need an isEmpty test
19:51:58 <Clint> or do (Maybe a, s a) instead
19:52:45 * hackagebot cuda 0.5.0.0 - FFI binding to the CUDA interface for programming NVIDIA GPUs  http://hackage.haskell.org/package/cuda-0.5.0.0 (TrevorMcDonell)
19:53:57 <vermeille1> Do you have a good link to link Haskell and C++ ?
19:54:07 <johnw> vermeille1: what kind of link?
19:55:09 <vermeille1> link to a webpage ?
19:55:50 <johnw> ok, what do you mean by "and" in that sentence?
19:56:13 <vermeille1> Okay, my english sucks
19:56:16 <cmccann> :t and
19:56:17 <lambdabot> [Bool] -> Bool
19:56:19 <cmccann> mystery solved!
19:56:28 <vermeille1> I mean that I want to use Haskell and C++ in the same program
19:56:46 <vermeille1> I know that FFI can do this easily with C
19:56:50 <cmccann> vermeille1, good luck
19:56:56 <cmccann> it's a huge headache from what I hear
19:57:03 <johnw> vermeille1: at present there isn't really a good C++/Haskell bridge
19:57:12 <cmccann> the easiest way is probably to make a C wrapper around the C++
19:57:16 <cmccann> and then use that from haskell
19:57:26 <vermeille1> Okay... It should be with I can't find a good documentation :D
19:57:28 <jmcarthur> yeah, much much easier to bind with C than C++
19:57:32 <vermeille1> WHY*
19:57:46 <jmcarthur> because C++
19:57:56 <vermeille1> (Hell, my english is horrible tonight >_<)
19:58:14 <jmcarthur> i'm drinking. you read fine :)
19:58:46 <vermeille1> Haha :p
19:59:01 <vermeille1> C++ rocks !
19:59:26 <Nereid> that may be the first time I've ever heard that.
19:59:31 <cmccann> heh
19:59:42 <cmccann> C++ is not very popular around here :P
19:59:47 <vermeille1> :D I *love* Metaprogramming
20:00:03 <cmccann> learn a lisp, then
20:00:05 <jmcarthur> vermeille1: then you should be talking about lisp, not C++
20:00:19 <vermeille1> It's sad to see that Haskell could trivially do some compile-time computation and doesn't
20:00:19 <cmccann> metaprogramming in lisp is easier than non-meta programming in many languages
20:00:37 <jmcarthur> vermeille1: ghc does do a lot of simplification, at least
20:00:49 <vermeille1> Obviously :)
20:00:53 <davesque_> does anyone happen to know if, in set theory, 0 is part of R-, R+, or both?
20:01:21 <Nereid> that's not really a question about set theory, and more a question of notation
20:01:22 <Nereid> what is R- and R+?
20:01:34 <johnw> ℝ⁺ and ℝ⁻
20:01:39 <vermeille1> But, if a function have all of its arguments known at compile-time, why ghc doesn't execute it ?
20:01:48 <solrize> erm, "set theory" is a somewhat different subject than what you seem to be referring to
20:01:49 <davesque_> sorry, the set of negative reals and the set of positive reals, and yes, it may not be a question about set theory
20:01:52 <johnw> vermeille1: you're asking about "constant folding"
20:01:57 <solrize> but generally if we say "x is a positive real number" we mean x > 0
20:01:59 <solrize> not >= 0
20:02:11 <Nereid> davesque_: if R+ is the set of positive reals, then no.
20:02:31 <Nereid> because generally positive means "strictly greater than 0"
20:02:37 <vermeille1> Maybe johnw . I'm new to Haskell world
20:02:49 <davesque_> ahh, so it's a member of R- or only of R?
20:02:54 <vermeille1> I come from C++, (I love template metaprogramming) with a few knowledge of OCaml (which I really don't like)
20:02:55 <statusfailed> johnw: have you set up shortcuts for blackboard bold?
20:02:58 <solrize> "x is negative" similarly means x < 0
20:03:15 <Nereid> so the answer would be "neither"
20:03:19 <shachaf> solrize: I think I have a book that uses it to mean "x ≤ 0"
20:03:20 <NihilistDandy> Are Kleisli arrows just a generalization of do blocks? I'm reading the pipes documentation and I keep seeing "you can do this do block, or runIdentityK (funcA >=> funcB).
20:03:27 <shachaf> And "x is strictly negative" to mean "x < 0"
20:03:31 <Nereid> assuming R- is the set of negative reals.
20:03:35 <davesque_> yes
20:03:38 <Nereid> shachaf: I've never heard that before.
20:03:39 <johnw>  statusfailed: that's the Agda input mode in my Emacs IRC client
20:03:45 <NihilistDandy> "do blocks" being "monadic blah blah blah"
20:03:47 <Nereid> what a strange way to do things.
20:03:48 <solrize> vermeille1 there's a good article about generics that you might like, comparing c++, haskell, ML and other languages
20:03:59 <vermeille1> Url :D ?
20:04:07 <solrize> looking for it, just a sec
20:04:09 <shachaf> Nereid: That author uses some unusual terminology.
20:04:14 <Nereid> apparently so.
20:04:16 <shachaf> Nereid: And it's a bit of an old book.
20:04:17 <davesque_> Nereid: so 0 is part of R and not of R- or R+?  R = all reals
20:04:25 <shachaf> (It's by Halmos, I think.)
20:04:35 <solrize> http://www.osl.iu.edu/publications/prints/2005/garcia05:_extended_comparing05.pdf
20:04:36 <rwbarton> hopefully wherever you see R+ and R- should define the notation earlier
20:04:41 <Nereid> ^
20:05:08 <rwbarton> however, I would go so far as to say that anyone who thinks 0 is in *exactly one* of R- and R+ is using bad notation
20:05:10 <johnw> davesque_: http://math.stackexchange.com/questions/27968/how-does-one-denote-the-set-of-all-positive-real-numbers
20:05:31 <davesque_> johnw: thank you
20:05:33 <NihilistDandy> \mathbb{R^+}
20:05:33 <jmcarthur> NihilistDandy: Kleisli arrows are exactly equivalent in power to monads
20:05:44 <johnw> "I'd completely avoid using ℝ⁺ since people won't know if 0 is included or not..." :)
20:05:48 <NihilistDandy> jmcarthur: Cool. So my intuitions not just wonky.
20:05:51 <vermeille1> Thanks solrize :d !
20:05:55 <NihilistDandy> *intuition's
20:06:09 <jmcarthur> NihilistDandy: you can find a Kleisli newtype in Control.Arrow that explains their relationship
20:06:24 <NihilistDandy> Oh, good. I'll have a look.
20:06:40 <Nereid> solrize: I like how haskell is the only language in the chart that supports all the features.
20:07:05 <solrize> and it didn't have type families then.  http://haskell.org/haskellwiki/Simonpj/Talk:FunWithTypeFuns
20:07:21 <johnw> but Common Lisp isn't mentioned?
20:07:33 <davesque_> johnw: good discussion.  thanks for pointing me towards that.
20:07:43 <Nereid> johnw: heh
20:08:53 <solrize> nereid i think ocaml has added some more stuff since then too.  i know it has gadt's now
20:09:23 <solrize> and also it's possible to do type hackery with ml's module system
20:12:01 <johnw> i'd think Agda would fare pretty well too
20:13:08 <solrize> http://www.seas.upenn.edu/%7Esweirich/ssgip/main.pdf
20:14:51 <statusfailed> does this exist in Control.Lens? idlens = lens id const
20:14:58 <Nereid> idlens = id
20:15:05 <statusfailed> is it
20:15:06 <statusfailed> shit
20:15:07 <statusfailed> :D
20:15:28 <statusfailed> oh wait; I wanted it to have this type: faillens :: Functor f => (s -> f a) -> s -> f s
20:15:29 <shachaf> statusfailed: By the way, you should usually not make lenses with "lens".
20:15:39 <statusfailed> oh really?
20:16:08 <statusfailed> I want a lens which gets out a constant value, and ignores anythingyou put in
20:16:19 <statusfailed> what's wrong with "lens id const"?
20:16:55 <Nereid> statusfailed: that's not a valid lens
20:17:06 <hrumph> hi
20:17:09 <statusfailed> nooo :(
20:17:09 <shachaf> Well, it's wrong.
20:17:18 <statusfailed> I forgot about the laws :\
20:17:19 <hrumph> how can i see all the typeclasses that something belongs to?
20:17:20 <shachaf> But I mean that you shouldn't build your lenses with "lens" in general.
20:17:23 <startling> you could do it with some state
20:17:27 <statusfailed> shachaf: could you explain why?
20:17:30 <shachaf> statusfailed: What does it have to do with the laws? It doesn't behave the way you want.
20:17:36 <shachaf> statusfailed: It'll be less efficient and less elegant.
20:17:47 <startling> statusfailed: setting then viewing doesn't get you the thing you set
20:17:49 <shachaf> > over (lens id const) (+1) 5
20:17:51 <lambdabot>   5
20:17:53 <shachaf> > over (lens id (flip const)) (+1) 5
20:17:55 <lambdabot>   6
20:18:01 <shachaf> > view (lens id (flip const)) 5
20:18:03 <lambdabot>   5
20:18:09 <shachaf> @ty lens id (flip const)
20:18:10 <lambdabot> Functor f => (a -> f t) -> a -> f t
20:18:39 <Saizan> shachaf: he did want it to ignore settings
20:18:40 <statusfailed> I'm still not sure why "lens id const" is wrong though
20:19:01 <statusfailed> oh; that's the law problem I guess
20:19:13 <startling> statusfailed: it's not wrong, it's just not as nice
20:19:18 <shachaf> Saizan: Oh.
20:19:25 <shachaf> In that case it's just a plain invalid lens, yes.
20:19:41 <startling> statusfailed: you could write _2 as _2 fn (a, b) = (,) a <$> b
20:19:47 <statusfailed> because "you don't get out what you put in"
20:20:27 <shachaf> What are you hoping to do with your invalid lens?
20:20:32 <shachaf> There's probably a better way of doing it.
20:21:17 <Nereid> so basically what you want is just a getter?
20:21:20 <Nereid> ??
20:21:58 <statusfailed> err, no, I think I didn't even want what I wrote :|
20:22:08 <Nereid> :v
20:22:26 <statusfailed> I'm trying to write a lens Text -> Maybe Value (using aeson-lens), which works on both objects and arrays
20:22:41 <statusfailed> so key' "0" will work on an object with a key "0", or an array with position 0
20:22:49 <statusfailed> but I don't want the answer, cuz I want to figure it out :D
20:22:49 <startling> doesn't aeson-lens have invalid lenses in it?
20:22:53 <Nereid> yep
20:22:59 <vermeille> Last question (and I need to sleep, it's late in France :D) : is there any website with ideas of Haskell exercises and/or mini-projects ?
20:23:10 <statusfailed> oh, in that case I don't mind :p
20:23:26 <startling> vermeille: http://www.haskell.org/haskellwiki/H-99:_Ninety-Nine_Haskell_Problems is a handful of exercises
20:23:34 <statusfailed> 'cause I need to output "Nothing" for keys that can't be found
20:24:04 <hrumph> why isn't num a subclass of ord?
20:24:18 <vermeille> Hum, I saw this link. It's more algorithmics problems to solve in a functional style than purely haskell exercises
20:24:29 <statusfailed> Nereid: There's no way to write valid lenses for that case, is there?
20:24:47 <statusfailed> if you don't know whether the lens target exists, you can't guarantee the law?
20:25:03 <hrumph> doe num include complex number or something?
20:25:07 <Nereid> if you don't know whether the lens target exists, maybe you're looking for a prism
20:25:08 <elliott> a partial lens is a traversal
20:25:13 <startling> statusfailed: you can write a traversal
20:25:14 <startling> yeah
20:25:17 <Nereid> prism!
20:25:26 <startling> what's a prism
20:25:28 <Saizan> hrumph: yeah
20:25:33 <Nereid> it's a partial lens
20:25:37 <Nereid> sort of
20:25:43 <Nereid> well it's a bit more than that
20:25:46 <startling> Nereid: is it a traversal or something else?
20:25:51 <Nereid> prisms are traversals.
20:25:58 <startling> are traversals prisms?
20:26:01 <Nereid> no
20:26:03 <startling> k
20:26:08 <statusfailed> startling: dangit. I don't know what a traversal is :D
20:26:26 <shachaf> statusfailed: A lens on zero or more values.
20:26:33 <Nereid> a prism is like a 0-or-1 traversal, except you can construct the outer value from the inner value.
20:26:42 <vermeille> Sooooooo, Good night and thank you all :) !
20:26:45 <startling> statusfailed: Applicative f => (a -> f b) -> x -> f y
20:26:50 <Nereid> :t right
20:26:52 <lambdabot> ArrowChoice a => a b c -> a (Either d b) (Either d c)
20:26:52 <Nereid> er
20:26:53 <Nereid> :t _right
20:26:55 <lambdabot> (Applicative f, Prismatic k) => k (a -> f b) (Either c a -> f (Either c b))
20:27:00 <startling> statusfailed, it's a generalization of MapM, kind of
20:27:09 <Nereid> the canonical example of a prism
20:27:10 <statusfailed> vermeille: night!
20:27:11 <elliott> normally you just want a traversal
20:27:12 <Nereid> or prototypical.
20:27:13 <startling> (for arbitrary structures)
20:27:23 <statusfailed> startling: isn't that the same stype as Lens?
20:27:26 <Saizan> i don't think a traversal fits here, since it's just one element of the array
20:27:31 <startling> statusfailed: nope, lens is Functor f
20:27:34 <Saizan> s/traversal/prism/
20:27:39 <statusfailed> oh yeah
20:27:41 <statusfailed> whoops
20:27:41 <Nereid> but the point is that, given a Value, you could get a Text. or something?
20:27:50 <startling> statusfailed: Functor guarantees that there's extactly one traversed item
20:28:13 <startling> with applicative, you can traverse any number of items
20:28:34 <Nereid> and if Pointed was in the hierarchy, that would let you traverse 0 or 1.
20:28:49 <startling> what's Pointed look like?
20:29:03 <Nereid> Applicative has pure and <*>, Pointed has only pure
20:29:25 <Nereid> (Apply has only <*>, and that lets you traverse 1 or more, but not 0.)
20:29:29 <statusfailed> so it goes Functor -> Pointed -> Applicative ?
20:29:30 <startling> Nereid: ah
20:29:38 <shachaf> Function -> {Pointed,Apply} -> Applicative
20:29:42 <Nereid> it *should*
20:29:42 <shachaf> Except Pointed is strange.
20:29:43 <Nereid> but it doesn't.
20:29:49 <statusfailed> Nereid: I meant in spirit :P
20:29:52 <Nereid> yes.
20:30:04 <hrumph> i'm at chpt 6. now of lyah
20:30:22 <hrumph> i guess the harder parts are coming
20:30:24 <shachaf> instance Default a => Pointed (Const a) where pure _ = Const def ?
20:30:42 <Nereid> is Default appropriate for that?
20:30:45 <shachaf> No.
20:30:48 <startling> haha
20:30:50 <shachaf> But it's as appropriate as Pointed.
20:30:59 <Nereid> what's wrong with Pointed?
20:31:03 <shachaf> class (Semigroup m, Default m) => Monoid m
20:31:11 <shachaf> Nereid: The same thing that's wrong with Default.
20:31:19 <Nereid> this seems circular.
20:31:30 <shachaf> Nereid: There are no laws for Pointed.
20:31:37 <Nereid> how can there be?
20:31:40 <shachaf> Exactly!
20:31:45 <Nereid> what's wrong with that?
20:31:47 <shachaf> So what's the, ahem, point?
20:31:48 <startling> pure a = id pure a
20:32:00 <startling> ^ guys I just wrote the Pointed law
20:32:15 <shachaf> Thanks for contributing, startling.
20:32:27 <elliott> There is a law for Pointed.
20:32:30 <elliott> It's just free.
20:32:32 <startling> shachaf, do I get a phd now
20:32:39 <shachaf> startling: At least.
20:32:39 <cmccann> the law is "I AM THE LAW"
20:32:52 <startling> shachaf: oh man, this is gonna be so cool
20:32:55 <Nereid> fmap f . pure = pure . f
20:32:56 <Nereid> would be the law
20:33:13 <elliott> Nereid: That's a free theorem.
20:33:16 <Nereid> sure.
20:33:24 <elliott> That's not a very good law.
20:33:25 <cmccann> it's a very cheap law.
20:33:35 <latermuse> Nereid: I just saw your "swap head and tail". That is awesome!
20:33:38 <Nereid> but one can still write it.
20:33:43 <Nereid> latermuse: ok
20:33:54 <statusfailed> latermuse: link?
20:33:57 <cmccann> you could also specify the law "pure = pure".
20:34:03 <cmccann> that would be similarly helpful.
20:34:12 <Nereid> statusfailed: http://hpaste.org/79145
20:34:17 <latermuse> http://hpaste.org/79145
20:34:38 <elliott> Nereid: the point is you can't usefully write code that is generic on any Pointed 90% of the time
20:34:49 <Nereid> but you can write a zero-or-one traversal.
20:34:52 <elliott> because it has no real laws you can tie stuff together or give stuff meaning with
20:34:57 <shachaf> elliott: But 0-or-1 traversals are a useful concept.
20:34:58 <Nereid> sounds useful to me.
20:35:08 <cmccann> and when you can, it's because you have some other constraint that implicitly assumes a particular kind of pointed
20:35:09 <statusfailed> crap, I forgot what ~ means
20:35:18 <Nereid> statusfailed: I realized ~ is unnecessary
20:35:19 <shapr> irrevocable pattern match
20:35:19 <cmccann> and it turns out that all the code has the same implicit assumption
20:35:20 <Nereid> so you can ignore it.
20:35:49 <statusfailed> ah ok
20:35:56 <statusfailed> (to both)
20:36:50 <statusfailed> Question re: aeson-lens; is there an alternative library that uses traversals/prism (?) to satisfy the lens laws
20:37:20 <Nereid> that would be awfully fast if there was.
20:37:24 <Nereid> but there should be!
20:38:33 <statusfailed> ok, I will stick with my evil lens id const
20:38:34 <statusfailed> for now
20:38:44 <elliott> you really shouldn't use that
20:39:20 <statusfailed> elliott: aw...
20:39:44 <jmcarthur> > uncurry (:) <<< last &&& (uncurry (++) <<< init . tail &&& pure . head) $ [1..10]  -- latermuse
20:39:46 <lambdabot>   [10,2,3,4,5,6,7,8,9,1]
20:40:08 <jmcarthur> (it's awful)
20:40:22 <statusfailed> elliott: because it doesn't satisfy lens laws, or because it uses "lens"?
20:40:32 <elliott> the laws are what matter :P
20:40:36 <statusfailed> (the first one i'm not bothered about as long as I use aeson-lens)
20:43:13 <startling> has anyone tried fixing aeson-lens?
20:44:47 <rwbarton> I have a sort of evolving style for using lens with aeson
20:44:57 <rwbarton> but I don't do any updates so it is sort of pointless
20:45:17 <rwbarton> (except as a way for me to learn about lens I guess)
20:47:06 <statusfailed> startling: wouldn't it be mostly a complete rewrite ? I'm don't know enough to really say
20:47:15 <rwbarton> basically I have objectAt :: Text -> Simple Traversal Object Object
20:47:39 <rwbarton> which is the composition objectAt key = _at key . asObject (asObject is a prism, but _at isn't)
20:47:46 <shachaf> instance IsString (Simple Traversal Object Object) where ...
20:47:55 <rwbarton> and the same for integerAt, stringAt etc.
20:47:58 <statusfailed> rwbarton: what's the type of key?
20:47:59 <shachaf> rwbarton: Hmm, that won't let you set, right?
20:48:01 <rwbarton> Text
20:48:16 <statusfailed> herp... I meant "_at"
20:48:20 <rwbarton> shachaf: it would let me set a field inside the object, if it exists, I think
20:48:23 <rwbarton> @type _at
20:48:23 <startling> statusfailed: me neither
20:48:25 <lambdabot> (Applicative f, At k m, Indexable k k1) => k -> k1 (v -> f v) (m v -> f (m v))
20:48:33 <startling> the question is how useful the result would be
20:48:37 <rwbarton> but it wouldn't let me conjure the object at that key into existence
20:48:37 <shachaf> Right, but not set a thing from nothing.
20:48:44 <rwbarton> yeah
20:49:10 <rwbarton> I'm basically just using it as a substitute for proper JSON parsing though
20:49:15 <statusfailed> startling: you mean "does a rewrite satisfying the laws actually provide any value"?
20:49:36 <rwbarton> shachaf: no no
20:49:41 <rwbarton> oh i can't do this
20:49:47 <rwbarton> I wanted ["foo"] :: Simple Traversal Object Object
20:49:51 <startling> statusfailed: yeah
20:50:01 <rwbarton> I guess x^?"foo" is pretty good too
20:50:06 <startling> statusfailed: or, well, as much value as the current one
20:50:10 <statusfailed> startling: seems like it would be able to remove the Maybes everywhere? I'm not sure how Traversal works, heh
20:50:13 <rwbarton> there's also instance Num (Simple Traversal Array Object)
20:50:44 <rwbarton> hm
20:50:57 <hrumph> has there been any thought of  a browser with native haskell support?
20:50:59 <rwbarton> I wonder whether it would work to overload it with instance IsString (Simple Traversal Object String) etc.
20:51:01 <startling> statusfailed: you'd get lists instead of maybes
20:51:04 <rwbarton> (Disclaimer: This is a terrible idea)
20:51:05 <startling> essentially
20:51:07 <hrumph> so you can don't have to translate into js
20:51:17 <startling> rwbarton: hahahaha
20:51:24 <rwbarton> sort of tempting though :)
20:51:26 <shachaf> rwbarton: Can you make overloaded instances for rank-2 things?
20:51:37 <rwbarton> can you even make instances for rank-2 things
20:51:42 <rwbarton> would have to use the specific gadget
20:51:50 <rwbarton> (because the answer is no)
20:51:54 <rwbarton> what'sitcalled
20:51:57 <rwbarton> @type (^..)
20:51:59 <lambdabot> s -> Getting (Endo [a]) s t a b -> [a]
20:52:03 <rwbarton> um not that one
20:52:26 <rwbarton> oh
20:52:40 <rwbarton> I can have an instance with a free variable f
20:52:44 <rwbarton> I guess that could work?
20:52:44 <statusfailed> startling: but they'd satisfy laws, right? :p
20:52:54 <statusfailed> startling: actually, if Traversal gives you a list, does a prism give you a Maybe?
20:53:54 <startling> presumably
20:54:08 <startling> statusfailed: yeah.
20:54:22 <startling> what's that one operator that gets a list from a traversal?
20:54:39 <Nereid> ^..
20:54:45 <startling> :t (^..)
20:54:46 <lambdabot> s -> Getting (Endo [a]) s t a b -> [a]
20:54:56 <Nereid> every prism is a traversal
20:55:06 <Nereid> > Right 5 ^.. _right
20:55:08 <lambdabot>   [5]
20:55:19 <Nereid> but there's no point in asking for a list since it won't ever have more than 1 element
20:55:21 <Nereid> > Right 5 ^? _right
20:55:23 <lambdabot>   Just 5
20:55:55 <rwbarton> @type (^?!)
20:55:57 <lambdabot> s -> Getting (First a) s t a b -> a
20:56:27 <rwbarton> > Left 5 ^?! _right
20:56:29 <startling> :t (^?)
20:56:29 <lambdabot>   *Exception: (^?!): empty Fold
20:56:30 <lambdabot> s -> Getting (First a) s t a b -> Maybe a
20:56:33 <rwbarton> good error
20:56:47 <statusfailed> I think we need a buzzword for Control.Lens, i'm thinking "emoticon driven development"
20:56:54 <startling> > _2 ^.. (1, 2)
20:56:56 <lambdabot>   Couldn't match expected type `(a0
20:56:56 <lambdabot>                                 -> Contro...
20:56:56 <statusfailed> @ty (<^^~)
20:56:58 <lambdabot> (Fractional a, Integral e) => LensLike ((,) a) s t a a -> e -> s -> (a, t)
20:57:36 <startling> traversal-driven development
20:57:43 <otters> make it a thing
20:57:48 <otters> blog post
20:58:00 <startling> give me a type and all possible traversals on it and I will move the world
20:58:16 <otters> Int
20:58:18 <statusfailed> you don't need to move the world, just traverse the universe
20:58:45 <startling> hehe
20:58:51 <donri> :t universe
20:58:53 <lambdabot> Plated a => a -> [a]
20:58:58 <statusfailed> shit.
20:59:11 <statusfailed> @where universe
20:59:11 <lambdabot> I know nothing about universe.
20:59:15 <rwbarton> :t traverse universe
20:59:16 <lambdabot> (Traversable t, Plated b) => t b -> [t b]
20:59:41 <statusfailed> :i Plated
20:59:50 <statusfailed> ... aw
21:00:07 <donri> http://hackage.haskell.org/packages/archive/lens/3.7.0.2/doc/html/Control-Lens-Plated.html
21:00:32 <startling> > universe [1, 2, 3]
21:00:35 <lambdabot>   [[1,2,3],[2,3],[3],[]]
21:00:42 <statusfailed> donri: I still can't figure it out :D
21:00:53 <statusfailed> traverse universe $ [1, 2, 3
21:00:59 <statusfailed> > traverse universe $ [1..3]
21:01:01 <lambdabot>   Ambiguous type variable `b0' in the constraints:
21:01:01 <lambdabot>    (GHC.Enum.Enum b0)
21:01:01 <lambdabot>     ...
21:01:09 <startling> statusfailed: find all the self-similar children of a thing, and then find all of their self-similar children ad infinitum
21:01:27 <statusfailed> what does self-similar mean?
21:01:36 <startling> similarly-typed, in this case
21:01:38 <sopvop> math speak makes me uneasy
21:01:48 <donri> recursive type
21:01:56 <startling> more like CS-speak
21:02:00 <mysticc>  Is it possible to get criterion benchmarking results in a datastructure of somesort rather than command line?
21:02:18 <otters> :t universe
21:02:20 <lambdabot> Plated a => a -> [a]
21:03:04 <donri> see the Expr example in the Plated docs
21:03:14 <mysticc> I want to perform benchmark in a TH code and then do some things based on the results?
21:03:15 <donri> universe finds all the Expr's embedded in another
21:03:19 <startling> statusfailed, you know how trees sometimes contain many smaller trees?
21:03:46 <startling> those smaller trees are the parent's self-similar children
21:03:48 <startling> :t plate
21:03:50 <lambdabot> (Applicative f, Plated a) => (a -> f a) -> a -> f a
21:04:04 <startling> ^ 'plate' just traverses the self-similar children of a thing
21:04:06 <donri> so if you have, universe (Neg (Val 2)), it will contain Val 2, among other things
21:05:06 <statusfailed> startling: hmm, ok
21:05:40 <donri> it's primarily useful for kind * types... for kind * -> * you can usually do a Traversable/Foldable
21:05:49 <startling> statusfailed: the self-similar child of a list is just its tail
21:05:55 <statusfailed> but it's basically up to the instance to decide what "self similar" means? Expr only allows Adds with Adds, for example
21:05:57 <startling> > view plate [1, 2, 3]
21:05:59 <lambdabot>   [2,3]
21:06:19 <statusfailed> ah ok
21:07:05 <shachaf> > view template [1,2,3]
21:07:07 <lambdabot>   ()
21:07:08 <shachaf> > view template [1,2,3] :: [Int]
21:07:11 <lambdabot>   []
21:07:18 <statusfailed> @ty template
21:07:19 <lambdabot> (Data.Data.Data s, Typeable a, Applicative f) => (a -> f a) -> s -> f s
21:07:20 <shachaf> > view template "hello" :: String
21:07:22 <lambdabot>   "ello"
21:07:42 <startling> statusfailed: the cool thing is you can define all kinds of tree transforms with plate
21:09:18 <Nereid> > over plate reverse $ [1..5]
21:09:20 <lambdabot>   [1,5,4,3,2]
21:09:28 <startling> Nereid: ha, neat
21:09:30 <Nereid> I don't know what I'm trying to do.
21:09:47 <Nereid> > [1..5] ^.. plate
21:09:50 <lambdabot>   [[2,3,4,5]]
21:09:54 <Nereid> oh ok
21:09:55 <startling> > over plate plate [1..5]
21:09:55 <Nereid> boring
21:09:57 <lambdabot>   Couldn't match expected type `a0 -> f0 a0' with actual type `[t0]'
21:10:28 <startling> > over plate (view plate) [1..5]
21:10:31 <lambdabot>   [1,3,4,5]
21:10:41 <shachaf> > universeOf plate "hello"
21:10:43 <lambdabot>   ["hello","ello","llo","lo","o",""]
21:11:03 <startling> > universe "umbrella"
21:11:06 <lambdabot>   ["umbrella","mbrella","brella","rella","ella","lla","la","a",""]
21:11:14 <donri> <statusfailed> but it's basically up to the instance to decide what "self similar" means? Expr only allows Adds with Adds, for example -- I think 'plate' is meant to traverse every 'Expr'
21:12:09 <statusfailed> donri: sorry, didn't quite follow what you mean there
21:12:14 <Nereid> tails = universe
21:12:27 <startling> tail = view plate
21:12:29 <donri> well in the Expr example it also covers 'Neg' not just 'Add'
21:13:26 <donri> so i *think* it's not "up to the instance"
21:15:17 <Nereid> :t plate
21:15:19 <lambdabot> (Applicative f, Plated a) => (a -> f a) -> a -> f a
21:15:35 <statusfailed> donri: oh, I think I misunderstood what that function was actually doing
21:15:40 <Nereid> blah
21:15:40 <Nereid> :t biplate
21:15:42 <lambdabot> (Data.Data.Data s, Typeable a, Applicative f) => (a -> f a) -> s -> f s
21:15:42 <statusfailed> so nevermind, haha
21:16:23 <startling> view plate (Add a b) = [a, b]
21:16:46 <shachaf> toListOf plate?
21:16:57 <startling> :T view plate
21:17:02 <startling> :t view plate
21:17:04 <lambdabot> (Monoid t, MonadReader t m, Plated t) => m t
21:17:29 <startling> :t toListOf plate
21:17:31 <lambdabot> Plated t => t -> [t]
21:17:37 <JamesJRH> Hi, how do I draw graphics in Haskell? Things like drawing circles, rectangles, lines, and paths like in HTML5 canvas.
21:17:39 <startling> shachaf: that's the one
21:17:50 <startling> toListOf plate (Add a b) = [a, b]
21:18:05 <startling> universe (Add a b) = [a, b] ++ universe a ++ universe b
21:18:21 <rwbarton> > universe (a + b)
21:18:22 <lambdabot>   No instance for (Control.Lens.Plated.Plated
21:18:22 <lambdabot>                     Debug.Simpl...
21:18:35 <rwbarton> oh it just uses a string doesn't it
21:18:37 <elliott> > universeOf template (a + b)
21:18:37 <rwbarton> or a showsPrec function
21:18:38 <JamesJRH> Also, is there a pure functional approach to graphics?
21:18:39 <lambdabot>   No instance for (Data.Data.Data Debug.SimpleReflect.Expr.Expr)
21:18:39 <lambdabot>    arising f...
21:18:47 <donri> JamesJRH: how about 'diagrams'?
21:18:49 <elliott> JamesJRH: several
21:18:51 <donri> @hackage diagrams
21:18:51 <lambdabot> http://hackage.haskell.org/package/diagrams
21:18:57 <elliott> look at gloss for example
21:19:00 <popl> JamesJRH: http://www.haskell.org/haskellwiki/Applications_and_libraries/Graphics
21:21:19 <JamesJRH> donri: Can that do animations?
21:21:24 <JamesJRH> popl: Thanks.
21:21:35 <donri> don't think so but don't know
21:21:38 <rwbarton> gloss can
21:22:09 <rwbarton> looks like diagrams can too
21:22:17 <rwbarton> or at least there is a Diagrams.Animation module
21:24:44 <NemesisD> anyone have any experience with http-conduit
21:26:04 <JamesJRH> I think I need to read up on 'Functional Reactive Programming': http://www.haskell.org/haskellwiki/Functional_Reactive_Programming
21:26:40 <JamesJRH> To get my head round how functional can be interactive.
21:28:02 <startling> JamesJRH: are you just learning haskell?
21:28:36 <startling> JamesJRH: there's nothing implied by "functional" that implies "non-interactive". Are you actually confused by purity?
21:30:47 <rwbarton> there are simpler places to start, like 'interact'
21:31:14 <startling> heh, I was just thinking about that
21:31:16 <JamesJRH> startling: Yes, I'm learning. And I meant purely functional.
21:32:39 <hpaste> NemesisD pasted “http-conduit crashing thread?” at http://hpaste.org/79148
21:33:02 <rwbarton> FRP is an old idea that somehow failed to revolutionize the world
21:33:03 <startling> JamesJRH: cool. so the baffling thing about purity is how you can do IO. Does that describe your confusion?
21:33:12 <rwbarton> or at least, hasn't succeeded yet
21:34:02 <neutrino> hey guys
21:34:08 <statusfailed> neutrino: hullo
21:34:17 <NemesisD> could someone take a look at that? it isn't necessarily minimal. my program forks off several threads to periodically hit urls with http-conduit. i never hear anything from the thread after it hits the url. but i have no idea whats going on
21:34:26 <neutrino> do you think atom would be a good choice to write a high-load http proxy in?
21:34:39 <JamesJRH> startling: Yes. And I get confused with monads aswell.
21:35:38 <NemesisD> i really don't have a good grasp of exceptions in haskell but I know enough to hate them
21:35:57 <startling> JamesJRH: alright. so, when we make an IO Something in haskell, we're not really doing anything magical
21:36:19 <startling> JamesJRH: we're just _describing_ a program that gives us a Something
21:36:38 <startling> JamesJRH: obviously this description of the program is pure, right?
21:36:45 <startling> NemesisD: amen
21:37:02 <neutrino> NemesisD: learn to use "catch" and "finally" and that's all.
21:37:34 <neutrino> "i get confused with monads" is kind of like "i get confused with surds"
21:37:39 <neutrino> i'm not sure how to help with either
21:37:48 <NemesisD> i have a feeling i'm going to use the errors library in the future and force myself to confront errors rather than use exceptions
21:37:53 <johnw> what is a surd?
21:38:11 <neutrino> it's something people that have to learn maths at school hate
21:38:29 <startling> JamesJRH: then, we name one of these descriptions "main". the compiler sees that description and compiles it into a program
21:38:56 <neutrino> in that scole, it's a square or cube root
21:38:59 <cmccann> neutrino, such an irrational hatred!
21:39:00 <neutrino> scale
21:39:01 <JamesJRH> Ok.
21:39:07 <statusfailed> cmccann: hohoho
21:39:12 <startling> JamesJRH: Monad just happens to be a nice way to combine programs to get programs, so we use it with IO.
21:39:31 <startling> JamesJRH: Monad doesn't do anything magical; don't fall into the trap of thinking it does
21:39:41 <startling> IO is the actual magic type special-cased by the compiler
21:39:43 <neutrino> cmccann: :)
21:39:46 <statusfailed> JamesJRH: In fact, neither does "do"
21:39:56 <statusfailed> it's just syntactic sugar
21:40:14 <statusfailed> (do anything magical, that is)
21:40:23 <startling> > do anything magical
21:40:25 <lambdabot>   Not in scope: `anything'Not in scope: `magical'
21:40:32 <rwbarton> that wasn't very magical
21:40:44 <startling> silly lambdabot
21:40:51 <JamesJRH> :-D
21:41:02 * cmccann considers whether "it's magic" is more or less helpful an explanation than the old "world-state passing" idea
21:41:59 <statusfailed> cmccann: the world-state passing idea made me conflate State with Monad, I think
21:42:08 <startling> cmccann: I don't think the "world-state passing" thing actually explains how actual IO can get done though
21:42:13 <statusfailed> I found it a bit confusing at the time
21:42:23 <cmccann> startling, exactly
21:42:31 <hpaste> NemesisD annotated “http-conduit crashing thread?” with “http-conduit crashing thread? (annotation)” at http://hpaste.org/79148#a79149
21:42:42 <cmccann> at least "it's magic" is more obviously uninformative
21:42:56 <startling> cmccann: it would just make a copy of the world's state and do stuff to it!
21:43:03 <NemesisD> i added an exception dump and still nothing. it just never logs anything after it initiates the request. i don't understand
21:43:10 <statusfailed> I think the "the compiler takes an IO () called 'main' and makes it a program using magic" is the best explanation to begin with :D
21:43:38 <latro`a> I'm still not sure how helpful it is to think of IO as being assembled in a pure way and made into an impure program by compiler magic
21:43:45 <latro`a> rather than basically being an imperative DSL
21:44:06 <startling> latro`a: what's the difference?
21:44:07 <cmccann> latro`a, well those are kinda the same idea, phrased differently
21:44:17 <latro`a> the difference is in the emphasis really
21:44:43 <latro`a> thinking of IO code as actually being pure as you write it, and then becoming impure later, seems to be a somewhat useless layer of abstraction
21:44:50 <statusfailed> latro`a: I think the point of the "magic" explanation is that you want to emphasize that 'Monad' is a general thing, not just for IO
21:44:53 <latro`a> the only advantage is that it makes IO actions' first class character "built in"
21:45:05 <latro`a> those seem orthogonal to me
21:45:09 <rwbarton> well it is true that evaluation is not the same as execution, and that you can put IO actions in containers and so on
21:45:16 <JamesJRH> startling: I started out with procedural languages using turtle graphics (using Logo), but turtle is by nature procedural which is why I didn't ask how do I do turtle graphics in Haskell. Instead, I want to learn elementary graphics the Haskell way.
21:45:34 <JamesJRH> But so far I don't even know where to start.
21:45:40 <cmccann> ...of course, logo is actually a lisp dialect...
21:45:41 <latro`a> I'm not sure thinking of a given IO action as a program unto itself, rather than something that only becomes a program when it is compiled due to being bound into main, is a bad thing
21:45:43 <startling> JamesJRH: honestly, you probably should learn haskell first
21:46:48 <startling> JamesJRH: looks like there's a thing or two for turtle graphics in haskell, but I doubt they'll help your understanding
21:46:52 <JamesJRH> startling: I've written a few CLI programs.
21:46:54 <cmccann> playing with the diagrams package actually has some of the same feel (to me at least) that logo did when I was younger, at least as much as I can recall that ancient time.
21:47:34 <cmccann> except with less immediate feedback :T
21:47:56 <latro`a> for example, doesFileExist "readme.txt", is this a program by itself, or does it need to be attached to main to become one
21:48:26 <JamesJRH> cmccann: I want to do it the Haskell way, except I want immediate feedback.
21:48:39 <statusfailed> cmccann: interesting idea- a Logo style environment using GHCI
21:48:39 <rwbarton> it's a program, but it needs to be attached to main for it to actually happen
21:48:53 <statusfailed> or at least the GHCI library
21:49:06 <shachaf> It's a program. main is a program. If you say main = it, then they're *the very same program*!
21:49:12 <cmccann> and main is a program, but it has to be executed by the operating system to actually happen.
21:49:20 <startling> @quote ls
21:49:21 <lambdabot> ChilliX says: You need to seek a balance between category theory and VLSI
21:49:22 <cmccann> turtles all the way down, y'know.
21:49:24 <NemesisD> anyone have any ideas?
21:49:26 <startling> @quote /bin/ls
21:49:27 <lambdabot> shachaf says: getLine :: IO String contains a String in the same way that /bin/ls contains a list of files
21:49:51 <latro`a> then it sounds like we actually agree, because my point was that doesFileExist "readme.txt" is an "abstract action" in the usual model
21:49:54 <latro`a> not an actual program
21:50:02 <JamesJRH> cmccann: Lol.
21:50:07 <latro`a> it lives in some weird ethereal world of "pure actions"
21:50:46 <rwbarton> I don't see any difference
21:51:05 <latro`a> it's a subtle philosophical point really, whether there's a layer of abstraction in between or not
21:51:10 <rwbarton> I guess
21:51:23 <rwbarton> would you say the same about "the number 3" and a particular pattern of voltages in a chip
21:51:24 <shachaf> That seems to me more like arguing about words than a subtle philosophical point.
21:51:35 <rwbarton> sounds like a distinction not worth making from a programming point of view
21:51:45 <neutrino> has anyone here used atom at all?
21:51:49 <latro`a> it's a philosophical point whether an IO value is "just a value", an action, or a program
21:52:05 <latro`a> (also what a "program" is)
21:52:05 <neutrino> i wonder if it's e.g. possible to call into haskell from atom
21:52:16 <neutrino> maybe in some embedded way
21:52:34 <neutrino> in order to perform soft realtime
21:52:37 <shachaf> Is "philosophical" a word which means "not worth arguing about"?
21:52:48 <neutrino> a soft, reamtime filling surrounded by a crunchy hard realtime shell
21:52:51 <latro`a> it only really matters for pedagogy
21:52:53 <neutrino> real*
21:53:07 <latro`a> to me for pedagogy the extra abstraction isn't really helpful, especially if you teach monads first and IO second
21:53:30 <shachaf> I don't know what it means to "teach monads".
21:53:36 <startling> I think maybe Reader and State should be taught before IO when teaching haskell
21:53:41 <cmccann> ok, conversations like this are why I am going to stick with "it's magic".
21:53:47 <latro`a> shachaf, please don't be pedantic
21:53:50 <latro`a> you know what I meant
21:54:04 <startling> it's the same kind of "building programs" feel as IO
21:54:14 <shachaf> latro`a: Not really.
21:54:56 <shachaf> As far as I can tell attempts to "teach monads" in the abstract tend to fail miserably.
21:54:59 <latro`a> there's the interface itself, the laws, and what you can "expect" from the interface (which is more intuition and tends to require examples)
21:55:25 <latro`a> that's not my experience, I think LYAH covers them in the abstract *and with examples* pretty well, and I also think that it could do so without randomly teaching IO a few chapters earlier
21:55:28 <latro`a> *basic IO
21:55:40 <JamesJRH> Gloss looks good.
21:55:50 <cmccann> @quote spacesuite
21:55:50 <lambdabot> dons says: Think of a monad as a spacesuite full of nuclear waste in the ocean next to a container of apples. now, you can't put oranges in the space suite or the nucelar waste falls in the ocean, *
21:55:51 <lambdabot> but* the apples are carried around anyway, and you just take what you need.
21:56:09 <JamesJRH> And it has plenty of examples!
21:56:32 <cmccann> JamesJRH, gloss is probably a good place to start given what you seem to be interested in, yeah
21:57:06 <statusfailed> cmccann: in fact, I think gloss is intended for teaching Haskell, isn't it?
21:57:21 <JamesJRH> That good, then.
21:57:25 <statusfailed> http://cdsmith.wordpress.com/2011/08/16/haskell-for-kids-week-1/
21:57:28 <cmccann> I dunno. cdsmith made good use of it, certainly.
21:57:38 <statusfailed> ah, I assumed he was the author
21:57:38 <zomg> I'm writing a haskell intro that just glosses over a bit of everything and jumps straight into doing things
21:57:48 <zomg> I'm not sure if the mathy purists are going to like it
21:57:49 <zomg> =)
21:58:05 <sacundim> zomg: my CTO asked me to give an informal talk on Haskell a couple of weeks ago.  instead of explaining monads i explained the use of ">>" and >>=" to compose IO actions.  I think that went better than explaining monads...
21:58:07 <shachaf> I don't think people usually object to "jumping straight into doing things".
21:58:21 <statusfailed> shachaf: I'm at the UN right now, you'd be surprised
21:58:22 <shachaf> Sometimes people object to using "I want to jump straight into doing things" as an excuse to say wrong and misleading things.
21:58:43 <cmccann> people mostly complain if you jump straight into doing things while giving misleading non-explanations that will make it harder to learn things correctly later
21:58:50 <cmccann> ...dammit shachaf
21:58:52 <cmccann> fine
21:58:53 <zomg> Yeah I'm trying to go over things in a general enough way that the reader will have at least some sort of understanding of what's happening
21:59:01 <zomg> without hampering the progress by going into too much detail
21:59:16 <JamesJRH> statusfailed: If Gloss is intended for teaching Haskell/purely functional, that makes it sort of equivalent to Turtle/Logo teaching procedural.
21:59:30 <statusfailed> JamesJRH: I was wrong about that being the intent of the library, but it has been used for that
21:59:41 <sacundim> question re Data.Void (http://hackage.haskell.org/packages/archive/void/0.5.10/doc/html/Data-Void.html): I roughly understand the Curry-Howardness of functions like absurd :: Void -> a, but I'm curious what sort of use such a function has
21:59:41 <mzero> zomg / sacundim - see my "Haskell Amuse-Bouche" - an hour intro/taste of Haskell that does exactly that - no theory, just dives into useful (though simple) code
22:00:01 <JamesJRH> statusfailed: Ok, but it does seem to be what I what looking for.
22:00:04 <zomg> sacundim: I didn't even try to explain monads. Right now about IO it just says it's a computation that has some result
22:00:07 <mzero> all - is cabal-dev no more? should I be using cabal-install mumble?
22:00:20 <statusfailed> JamesJRH: good stuff :)
22:00:27 <zomg> Although obviously that's something that I will attempt
22:00:29 <sacundim> my talk went over (a) purely functional, (b) composing actions with do notation, >> and >>=, and (c) quickcheck
22:00:29 <zomg> we'll see how it goes
22:00:39 <statusfailed> I found the gloss API to be quite nice, but I recall having some issues with getting it working... not exactly sure what though
22:00:40 <shachaf> cmccann: You're obsolete. Sorry. :-(
22:00:46 <cmccann> :[
22:01:08 <statusfailed> sacundim: ooh, I bet quickcheck went down well :D
22:01:12 * cmccann goes back to practicing drawing, since obviously his presence on IRC is superfluous
22:01:30 <statusfailed> shall we call when shachaf logs off?
22:01:35 <zomg> Practicing drawing? I thought people are just naturally good at drawing!
22:01:36 <zomg> ;>
22:01:46 <cmccann> ...shachaf logs off?
22:01:52 <cmccann> hunh.
22:01:59 <statusfailed> haha
22:02:03 <sacundim> oh, i went over the functor laws, but didn't call them that.  i just indirectly showed them as quickcheck properties for the list map
22:02:12 <JamesJRH> cmccann: It's a balance. And also, I'm personally quite good at breaking bad ways of doing things.
22:04:19 <cmccann> oh hm, apparently cdsmith was working on an interactive browser-based interface using gloss?
22:04:23 <cmccann> that would be pretty sweet.
22:05:37 <cmccann> apparently this still exists as well: http://dac4.designacourse.com:8000/draw
22:06:04 <rwbarton> yeah it's pretty slick
22:06:20 <JamesJRH> cmccann: Hey? I was going to ask about browsers. I wondered if Haskell and Gloss could be compiled to JS and HTML5.
22:06:43 <cmccann> JamesJRH, that's what he was working on but isn't done yet, it seems.
22:06:49 <JamesJRH> HTML5 Canvas*
22:06:51 <cmccann> the link I gave does the rendering server-side I think
22:06:55 <rwbarton> that site is all ... yeah
22:07:02 <JamesJRH> Ok, cool!
22:07:15 <cmccann> but that obviously doesn't scale well if enough people use it :]
22:07:23 <cmccann> still, it seems to work right now
22:07:29 <cmccann> so you could try it out if you want
22:07:37 <JamesJRH> cmccann: Looking forward to the client-side implementation.
22:07:42 <cmccann> it's not quite 100% immediate feedback but close
22:07:49 <JamesJRH> cmccann: Thanks.
22:07:57 <rwbarton> the game demo doesn't work but I successfully ported the sample to modern gloss a while back
22:08:40 <sacundim> i guess my question got lost in the traffic.  I recognize how absurd :: Data.Void.Void -> a correspondence to ex falso quodlibet; but what would be an example of something it's useful for?
22:08:50 <sacundim> *corresponds
22:10:36 <mzero> hmmmmph - the cabal-dev on hackage doesn't even remotely match the cabal-dev that is their official repo
22:12:06 <JamesJRH> cmccann: It is client-side! It's using Canvas and JS to generate the images! That's awesome! Now I can write in a proper language and compile to JS.. in theory.. a bit of learning yet though.
22:13:34 <mysticc> whats a decent way of getting IO [(a,b)] from [(IO a,b)] (something similar to sequence for [m a])
22:13:37 <rwbarton> the server is telling it what images to generate though
22:13:57 <rwbarton> unless it changed
22:14:09 <cmccann> yeah, I think it's not completely client-side
22:15:00 <elliott> mysticc: you can't
22:15:13 <mysticc> elliott: why not?
22:15:13 <JamesJRH> rwbarton: You mean the server is translating Haskell into JS?
22:15:21 <JamesJRH> That's ok.
22:15:27 <elliott> well, it doesn't make sense :) do you mean IO [(a,b)] to [IO (a,b)]?
22:16:23 <mysticc> elliott: I meant similar to sequence for [m a] to m [a], I want [(m a,b)] to m [(a,b)].
22:16:46 <elliott> Oh, the other way around; sorry, I misread
22:17:04 <mysticc> I could always write a recursive function but I meant using certain compositions.
22:17:08 <JamesJRH> rwbarton: I don't really mind where the translation happens, it means I can possibly avoid using JS for webpages.
22:17:12 <elliott> I can't think of a nicer way than sequence . map (\(m,b) -> (,b) <$> m)
22:17:34 <mysticc> elliott: I don't have an applicative instance for the monad :P
22:18:06 <shachaf> sequence . map strength -- or something
22:18:13 <mysticc> fmap should do
22:18:30 <otters> :t sequence . map
22:18:32 <lambdabot>     Couldn't match expected type `[m0 a0]'
22:18:32 <lambdabot>                 with actual type `[a1] -> [b0]'
22:18:32 <lambdabot>     Expected type: (a1 -> b0) -> [m0 a0]
22:18:35 <hpaste> sacundim pasted “for mysticc, the long-ish way” at http://hpaste.org/79150
22:18:47 <elliott> mysticc: you should
22:18:57 <elliott> instance Applicative MyMonad where pure = return; (<*>) = ap
22:18:58 <elliott> easy
22:19:22 <mysticc> sacundim: yeah I did this way but wanted to see if there is an easy and shortish way :P
22:19:31 <sacundim> oh
22:19:43 <mysticc> elliott: yeah, but rather using fmap is easier
22:20:37 <mysticc> elliott: and it is not a monad which I have written. Basically it is Criterion monad. So I dont want lateron a conflicting instances for Applicative.
22:20:43 <shachaf> mapM strength
22:20:46 <elliott> mm
22:20:47 <cmccann> :t sequenceA . fmap sequenceA :: [(a, IO b)] -> IO [(a, b)]
22:20:49 <lambdabot>     Not in scope: `sequenceA'
22:20:49 <lambdabot>     Perhaps you meant one of these:
22:20:49 <lambdabot>       `Data.Traversable.sequenceA' (imported from Data.Traversable),
22:20:50 <elliott> well criterion should fix that
22:20:53 <cmccann> oh come on
22:20:55 <cmccann> >:[
22:21:01 <mysticc> shachaf: what is Strength ?
22:21:15 <shachaf> strength :: (m a, b) -> m (a, b)
22:21:24 <shachaf> Or strength :: (a, m b) -> m (a, b)
22:21:30 <mysticc> :t strength
22:21:32 <shachaf> It doesn't exist so you can pretend it's either one of those.
22:21:32 <lambdabot> Not in scope: `strength'
22:21:42 <mysticc> wtf
22:21:49 <shachaf> That's what it's called, though.
22:21:55 <otters> @. pl undo \(a,b) -> do { c <- b; return (a,c) }
22:21:56 <mysticc> ohh
22:21:56 <lambdabot> uncurry (fmap . (,))
22:22:31 <mysticc> anyways thanks.
22:24:55 <otters> @. pl undo \(a,b) -> do {c <- a; return (c,b)}
22:24:55 <lambdabot> uncurry (flip (fmap . flip (,)))
22:26:28 <otters> is there a lens shorthand for Monad m => (a, m b) -> m (a, b)
22:28:07 <shachaf> _2 id
22:28:09 <statusfailed> shachaf: why is it called strength?
22:28:27 <shachaf> statusfailed: https://en.wikipedia.org/wiki/Strong_monad
22:28:36 <statusfailed> cheers
22:29:10 <t4nk332> hi I'm having some trouble with the FFI.  I'm making an argv for hs_init like -char *argv[] = { "first", "second", NULL }; but getting - no known conversion from 'char *(*)[3]' to 'char ***' for 2nd argument;
22:29:31 <JamesJRH> cmccann: Do you know why it doesn't accept 'Picture'?
22:29:37 <otters> shachaf: oh
22:29:51 <cmccann> JamesJRH, no idea, sorry :[
22:30:19 <shachaf> otters: It'll do Applicative, not Monad
22:30:30 <shachaf> Actually it'll do Functor, of course.
22:30:45 <otters> Yeah and most Monads I know of are Functors
22:33:05 <ion> …
22:33:08 <ion> Every Monad is a Functor.
22:33:17 <ion> (If it isn’t, file a bug report.)
22:33:18 <shachaf> ion: Every monad is a functor.
22:33:22 <otters> So saying "it'll do Functor, not Monad" is meaningless
22:33:24 <Gracenotes> t4nk332: how would function pointers get involved there?
22:33:27 <shachaf> Not every instance of Monad is an instance of Functor.
22:33:33 <ion> shachaf: See the second line.
22:33:37 <otters> The machine can draw rectangles, not squares.
22:33:43 <shachaf> ion: OK, but my statement wasn't meaningless.
22:33:59 <shachaf> If you do this polymorphically, for example, it'll add an extra constraint.
22:34:09 <beaky> How do you explain recursion to a 5-year old?
22:34:17 <ion> beaky: “See: recursion”
22:34:22 <ion> shachaf: true
22:35:29 <otters> @src (->) (>>=)
22:35:30 <lambdabot> f >>= k = \ r -> k (f r) r
22:35:42 <beaky> @quote recursion
22:35:42 <lambdabot> soupdragon says: why do people keep telling the same Recursion joke over and over again?   it is baseless humor
22:36:08 <sacundim> lol
22:37:36 <johnw> can anyone help me figure out why a preInst function in my Setup.hs is not being called when I "cabal install"?
22:37:48 * hackagebot Elm 0.6.0.3 - The Elm language module.  http://hackage.haskell.org/package/Elm-0.6.0.3 (EvanCzaplicki)
22:40:24 <hpaste> johnw pasted “Setup.hs” at http://hpaste.org/79151
22:42:36 <cmccann> http://dac4.designacourse.com:8000/displayInBrowser?digest=ZXDXmR2rs2npm33cb4qUBw%3d%3d :D
22:42:44 <cmccann> ok that's actually pretty fun to play with
22:44:19 <ion> Clicking results in bubbles that have a 2D coordinate or just “()”. Is something else supposed to happen?
22:44:35 <cmccann> dunno
22:47:48 * hackagebot elm-server 0.6.0.3 - The Elm language server.  http://hackage.haskell.org/package/elm-server-0.6.0.3 (EvanCzaplicki)
22:57:42 <shachaf> luite: seen luite
23:07:55 <NemesisD> anyone know how to get Posix.Signal to wait for a signal?
23:08:44 <NemesisD> awaitSignal (Just (addSignal sigINT emptySignalSet)) just breezes right by
23:12:48 <shachaf> NemesisD: What are you trying to do?
23:13:03 <shachaf> I think you need to make two changes to your code before it does what you want, but I don't actually know what you want.
23:13:10 <shachaf> Did you see http://www.haskell.org/ghc/docs/7.6.1/html/libraries/unix-2.6.0.0/System-Posix-Signals.html ?
23:17:14 <NemesisD> shachaf: i'm narrowing down an issue i'm having. so my program reads a config file, forks off a thread per entry and makes an HTTP request at a regular interval
23:17:54 <shachaf> What happens if you use deleteSignal isgINT fullSignalSet?
23:18:12 <NemesisD> shachaf: i'm trying to figure out how to properly get the main thread to basically yield until killed. i was doing forever $ threadDelay maxBound but that just pins the CPU and prevents the http threads from doing work i think
23:18:36 <shachaf> threadDelay maxBound shouldn't use much CPU
23:18:46 <shachaf> But awaitSignal is probably a better way of doing it.
23:18:51 <shachaf> Did you try awaitSignal Nothing?
23:19:51 <NemesisD> shachaf: i'm trying to arrive at the correct design. basically i want main to do nothing, but reload the config when it gets SIGHUP
23:21:10 <NemesisD> shachaf: i suspect that might actually suspend the whole runtime
23:21:36 <NemesisD> shachaf: i'm doing blockSignals reservedSignals >> awaitSignal nothing
23:21:37 <shachaf> Did you try it?
23:21:46 <shachaf> Ah.
23:21:47 <shachaf> And?
23:22:27 <NemesisD> cpu usage is low but i don't get any logs from my http clients in other threads so i think they are blocked
23:23:11 <NemesisD> the actual code is like blockSignals reservedSignals; forever $ debugM "Awaiting Signal" >> awaitSignal Nothing
23:23:52 <NemesisD> if i take out blockSignals reservedSignals, it reports "Awaiting Signal" a *ton* but my http threads are able to move forward
23:24:53 <shachaf> forever?
23:24:56 <shachaf> Does it get printed more than once?
23:25:09 <cmccann> ok so I spent entirely too long making this work: http://dac4.designacourse.com:8000/animateInBrowser?digest=jairkbbxejwhKn49I5jTDA%3d%3d
23:25:48 <NemesisD> shachaf: it prints once with the reservedSignal, prints a ton when removed
23:25:59 <cmccann> sadly it gets way too slow if I increase the iterations further :[
23:26:19 <NemesisD> shachaf: i don't know enough about posix signals, is it possible that it suspends the whole process or runtime when awaiting?
23:26:23 <shachaf> cmccann: It's awfully slow.
23:26:33 <cmccann> yeah :[
23:26:40 <shachaf> cmccann: That's compiled from Haskell?
23:26:47 <shachaf> NemesisD: Not likely.
23:28:12 <NemesisD> shachaf: the whole project source code is on github its difficult to distill to a small example, though the project itself isn't huge
23:29:22 <hpaste> “C. McCann” pasted “unfolding dragon” at http://hpaste.org/79152
23:29:30 <cmccann> shachaf, there you go
23:30:07 <cmccann> I reduced the iterations to make it less painful to watch...
23:30:24 <shachaf> Oh, that's fancy.
23:30:33 <cmccann> and inefficient!
23:31:07 <cmccann> and it took me way too long to make it work, heh.
23:31:42 <shachaf> Blugh.
23:31:52 <shachaf> GHC gives me no easy way to get all of its output!
23:32:19 <shachaf> -ddump-to-file is great, except it dumps all the occur-anal bits into the same file.
23:32:26 <shachaf> So you lose ordering information.
23:33:35 <shachaf> I think I'll just give up on ordering information.
23:33:35 <JamesJRH> I've just upgraded cabal-install, but it still says it needs upgrading. I can't install gloss, and ghc-prim apparently doesn't exist. :-(
23:33:59 <cmccann> JamesJRH, did you see my link above? :D
23:34:08 <JamesJRH> Err..
23:34:19 <shachaf> Maybe I should bind to the GHC API.
23:34:23 <shachaf> Might be easier than this mess.
23:34:38 <shachaf> Especially since I have an urge to "parse" the Core to make it more readable.
23:34:43 <shachaf> But on the other hand...
23:34:45 <JamesJRH> No, which one?
23:35:34 <cmccann> JamesJRH,  http://dac4.designacourse.com:8000/animateInBrowser?digest=jairkbbxejwhKn49I5jTDA%3d%3d
23:37:58 <JamesJRH> cmccann: Nice.
23:38:03 <JamesJRH> Dragon fractal.
23:38:18 <solrize> main = print . length $ replicateM 15 "abc"    -- this prints the value of 3^15 but why does it use nearly 1GB of ram ?
23:38:46 <cmccann> JamesJRH, the hpaste link above is the source code if you're interested
23:40:25 <statusfailed> Okay, I know this is silly, but why can't I do this:
23:40:38 <statusfailed> silly l =lens  (^. l) (set l)
23:40:51 <statusfailed> silly :: Lens s t a b -> Lens s t a b
23:41:14 <NemesisD> shachaf: would you mind taking a look at https://github.com/MichaelXavier/Buster/blob/signals/src/Buster/Main.hs#L29 this code never executes https://github.com/MichaelXavier/Buster/blob/signals/src/Buster/Request.hs#L22 but when i  get in that waiting loop, the function itself exits and I see DONE https://github.com/MichaelXavier/Buster/blob/signals/src/Buster/Pool.hs#L53
23:41:19 <mzero> solrize: because that code is running through constructing 3^15 lists
23:41:33 <solrize> mzero yeah but not lazily ?
23:41:36 <NemesisD> i think there's some sort of exception masking business going on with threads that is beyond my depth
23:41:54 <shachaf> statusfailed: Because of the type of set
23:41:59 <mzero> solrize: the list that is 3^15 is itself never all in memory at once, it is lazily produced
23:42:04 <shachaf> You can figure things like that out with :t :-)
23:42:20 <mzero> BUT - because you call length, something must run down count them
23:42:31 <solrize> mzero right, so why all the space consumption?   it's not from length, i tried a strict version using foldl1'
23:42:45 <mzero> @src replicateM
23:42:45 <lambdabot> replicateM n x = sequence (replicate n x)
23:42:56 <mzero> @src sequence
23:42:57 <lambdabot> sequence []     = return []
23:42:57 <lambdabot> sequence (x:xs) = do v <- x; vs <- sequence xs; return (v:vs)
23:42:57 <lambdabot> -- OR: sequence = foldr (liftM2 (:)) (return [])
23:42:58 <statusfailed> Oh, because Mutator /= Accessor ?
23:43:41 <shachaf> statusfailed: ?
23:43:59 <shachaf> @ty set
23:44:01 <lambdabot> Setting s t a b -> b -> s -> t
23:44:02 <shachaf> @ty lens
23:44:03 <lambdabot> Functor f => (s -> a) -> (s -> b -> t) -> (a -> f b) -> s -> f t
23:44:06 <shachaf> Match up the letters.
23:44:26 <mzero> notice that the full recursion in sequence is going to be executed 3^15 times, and that a lot of thunks are going to get build up in the process before that return gives an element that length can count...
23:44:58 <statusfailed> shachaf: ....... ;_;
23:45:16 <statusfailed> whoops
23:45:19 <statusfailed> thanks >_>
23:45:40 <solrize> the return (v:vs) is in WHNF before vs even starts being evaluated
23:45:58 <shachaf> statusfailed: I keep saying we should have a version of set that has that argument order, though.
23:46:17 <shachaf> statusfailed: If you can find a good name for it it'll probably be added.
23:46:29 <shachaf> statusfailed: (Also, (^.) = view. Might as well be consistent about infix/prefix)
23:46:53 <JamesJRH> cmccann: Thanks.
23:47:37 * liyang wants that set too. D:
23:47:38 <shachaf> NemesisD: Let me see.
23:47:49 <shachaf> liyang: Name it and it's yours!
23:48:00 <liyang> Okay!
23:49:08 <cmccann> ok, I'm out for the night, enough messing with gloss
23:49:10 <statusfailed> shachaf: Actually the reason for inconsistency is 'cause I couldn't find an operator for set, heh
23:49:28 <shachaf> @ty (.~)
23:49:30 <lambdabot> Setting s t a b -> b -> s -> t
23:49:45 <statusfailed> thanks :D
23:49:49 <JamesJRH> cmccann: I tried that hpaste in dac4, but..
23:49:52 <JamesJRH> Oh.
23:50:54 <notdan> Why is MaybeT's underlying type is m (Maybe a) and not Maybe (m a)?
23:51:03 <JamesJRH> Sorry, there were problems with your program:  * Not in scope: `picture'  Perhaps you meant `pictures' (imported from Graphics.Gloss)
23:51:18 <shachaf> NemesisD: I bet this has something to do with Conduit.
23:51:56 <shachaf> NemesisD: Try compiling with -threaded
23:53:51 <statusfailed> how about modified :: Setting s t a b -> s -> b -> t
23:54:05 <shachaf> That doesn't match the pattern of the other operators much.
23:54:13 <NemesisD> shachaf: i thought i heard somewhere that was the default
23:54:35 <shachaf> NemesisD: It's not.
23:54:45 <shachaf> Add ghc-options: -threaded to your cabal file and see.
23:55:18 <statusfailed> shachaf: you mean the name doesn't match?
23:55:22 <sopvop> :t over
23:55:24 <lambdabot> Setting s t a b -> (a -> b) -> s -> t
23:55:32 <shachaf> statusfailed: Yes.
23:57:21 * sopvop is switching to new lens release.  s/%/&/ because of stupid Ratio
23:58:55 <t4nk824> Could not find module `Graphics.UI.Gtk.Glade'     (OS: Windows7; HaskellPlatform-2012.4.0.0-setup.exe; gtk+-bundle_2.24.10-20120208_win32; glade-3-8-3-installer.exe; I am a beginner )
23:58:59 <NemesisD> shachaf: hmm do you know if what i have for blockSignals and awaitSignal is correct?. behavior seems the same with -threaded. if i blockSignals reservedSignals and awaitSignal HUP, it keeps looping and doesn't block waiting on HUP
23:59:05 <statusfailed> shachaf: mutate?
